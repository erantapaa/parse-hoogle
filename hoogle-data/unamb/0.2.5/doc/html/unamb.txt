-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Unambiguous choice
--   
--   unamb contains the <a>unambiguous choice</a> operator <a>unamb</a>,
--   which wraps thread racing up in a purely functional, semantically
--   simple wrapper. Originally a part of Reactive, I moved unamb to its
--   own package in order to encourage experimentation.
--   
--   Project wiki page: <a>http://haskell.org/haskellwiki/unamb</a>
--   
--   Â© 2008-2012 by Conal Elliott; BSD3 license.
--   
--   Contributions from: Luke Palmer, Spencer Janssen, Sterling Clover,
--   Bertram Felgenhauer, Peter Verswyvelen, Svein Ove Aas, and Edward
--   Kmett. Please let me know if I've forgotten to list you.
@package unamb
@version 0.2.5


-- | Unambiguous choice
--   
--   For non-flat types (where values may be partially defined, rather than
--   necessarily bottom or fully defined) and information merging, see the
--   lub package, <a>http://haskell.org/haskellwiki/Lub</a>.
--   
--   See unamb.cabal for the list of contributors.
module Data.Unamb

-- | Unambiguous choice operator. Equivalent to the ambiguous choice
--   operator, but with arguments restricted to be equal where not bottom,
--   so that the choice doesn't matter. See also <a>amb</a>.
--   
--   If anything kills unamb while it is evaluating (like nested unambs),
--   it can be retried later but, unlike most functions, work may be lost.
unamb :: a -> a -> a

-- | For use when we already know that neither argument is already
--   evaluated
unamb' :: a -> a -> a

-- | n-ary <a>unamb</a>
unambs :: [a] -> a

-- | Yield a value if a condition is true. Otherwise undefined.
assuming :: Bool -> a -> a

-- | The value of agreeing values (or undefined/bottom)
asAgree :: Eq a => a -> a -> a

-- | Turn a binary commutative operation into one that tries both orders in
--   parallel. Useful when there are special cases that don't require
--   evaluating both arguments. For non-flat types and information merging,
--   see <tt>parCommute</tt> in the <tt>lub</tt> package.
parCommute :: (a -> a -> b) -> (a -> a -> b)

-- | Turn a binary commutative operation into one that may try both orders.
--   unlike parCommute, if one argument is already evaluated, the function
--   is tried *only* with that as its first argument and not in both
--   orders. When in doubt, use <a>parCommute</a>.
parCommuteShortCircuit :: (a -> a -> b) -> (a -> a -> b)

-- | Binary operation with annihilator element. For instance, (*) &amp; 0,
--   (&amp;&amp;) &amp; <a>False</a>, (||) &amp; <a>True</a>, <a>min</a>
--   &amp; <a>minBound</a>, <a>max</a> &amp; <a>maxBound</a>. Tests either
--   argument as annihilator, in parallel.
parAnnihilator :: Eq a => (a -> a -> a) -> a -> (a -> a -> a)

-- | Binary operation with left &amp; right identity element. For instance,
--   (*) &amp; 1, (&amp;&amp;) &amp; <a>True</a>, (||) &amp; <a>False</a>,
--   <a>min</a> &amp; <a>maxBound</a>, <a>max</a> &amp; <a>minBound</a>.
--   Tests either argument as identity, in parallel.
parIdentity :: Eq a => (a -> a -> a) -> a -> a -> a -> a
parAnnihilatorIdentity :: Eq a => (a -> a -> a) -> a -> a -> a -> a -> a

-- | Parallel or
por :: Bool -> Bool -> Bool

-- | Parallel and
pand :: Bool -> Bool -> Bool

-- | Parallel min with minBound short-circuit and maxBound identity
pmin :: (Ord a, Bounded a) => a -> a -> a

-- | Parallel max with maxBound short-circuit and minBound identity
pmax :: (Ord a, Bounded a) => a -> a -> a

-- | Parallel multiplication with 0 short-circuit, and 1 identity
pmult :: (Eq a, Num a) => a -> a -> a

-- | Ambiguous choice operator. Yield either value. Evaluates in separate
--   threads and picks whichever finishes first. See also <a>unamb</a> and
--   <a>race</a>.
amb :: a -> a -> IO a

-- | For use when we already know that neither argument is already
--   evaluated
amb' :: a -> a -> IO a

-- | Race two actions against each other in separate threads, and pick
--   whichever finishes first. See also <a>amb</a>.
race :: IO a -> IO a -> IO a

-- | Use a particular exception as our representation for waiting forever.
data BothBottom
instance Typeable BothBottom
instance Typeable DontBother
instance Show BothBottom
instance Show DontBother
instance Exception DontBother
instance Exception BothBottom
