-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe, multi-backend data serialization.
--   
@package persistent
@version 2.2

module Database.Persist.Types

-- | A <a>Checkmark</a> should be used as a field type whenever a
--   uniqueness constraint should guarantee that a certain kind of record
--   may appear at most once, but other kinds of records may appear any
--   number of times.
--   
--   <i>NOTE:</i> You need to mark any <tt>Checkmark</tt> fields as
--   <tt>nullable</tt> (see the following example).
--   
--   For example, suppose there's a <tt>Location</tt> entity that
--   represents where a user has lived:
--   
--   <pre>
--   Location
--       user    UserId
--       name    Text
--       current Checkmark nullable
--   
--       UniqueLocation user current
--   </pre>
--   
--   The <tt>UniqueLocation</tt> constraint allows any number of
--   <a>Inactive</a> <tt>Location</tt>s to be <tt>current</tt>. However,
--   there may be at most one <tt>current</tt> <tt>Location</tt> per user
--   (i.e., either zero or one per user).
--   
--   This data type works because of the way that SQL treats
--   <tt>NULL</tt>able fields within uniqueness constraints. The SQL
--   standard says that <tt>NULL</tt> values should be considered
--   different, so we represent <a>Inactive</a> as SQL <tt>NULL</tt>, thus
--   allowing any number of <a>Inactive</a> records. On the other hand, we
--   represent <a>Active</a> as <tt>TRUE</tt>, so the uniqueness constraint
--   will disallow more than one <a>Active</a> record.
--   
--   <i>Note:</i> There may be DBMSs that do not respect the SQL standard's
--   treatment of <tt>NULL</tt> values on uniqueness constraints, please
--   check if this data type works before relying on it.
--   
--   The SQL <tt>BOOLEAN</tt> type is used because it's the smallest data
--   type available. Note that we never use <tt>FALSE</tt>, just
--   <tt>TRUE</tt> and <tt>NULL</tt>. Provides the same behavior <tt>Maybe
--   ()</tt> would if <tt>()</tt> was a valid <tt>PersistField</tt>.
data Checkmark

-- | When used on a uniqueness constraint, there may be at most one
--   <a>Active</a> record.
Active :: Checkmark

-- | When used on a uniqueness constraint, there may be any number of
--   <a>Inactive</a> records.
Inactive :: Checkmark
data IsNullable
Nullable :: !WhyNullable -> IsNullable
NotNullable :: IsNullable

-- | The reason why a field is <tt>nullable</tt> is very important. A field
--   that is nullable because of a <tt>Maybe</tt> tag will have its type
--   changed from <tt>A</tt> to <tt>Maybe A</tt>. OTOH, a field that is
--   nullable because of a <tt>nullable</tt> tag will remain with the same
--   type.
data WhyNullable
ByMaybeAttr :: WhyNullable
ByNullableAttr :: WhyNullable
data EntityDef
EntityDef :: !HaskellName -> !DBName -> !FieldDef -> ![Attr] -> ![FieldDef] -> ![UniqueDef] -> ![ForeignDef] -> ![Text] -> !(Map Text [ExtraLine]) -> !Bool -> EntityDef
entityHaskell :: EntityDef -> !HaskellName
entityDB :: EntityDef -> !DBName
entityId :: EntityDef -> !FieldDef
entityAttrs :: EntityDef -> ![Attr]
entityFields :: EntityDef -> ![FieldDef]
entityUniques :: EntityDef -> ![UniqueDef]
entityForeigns :: EntityDef -> ![ForeignDef]
entityDerives :: EntityDef -> ![Text]
entityExtra :: EntityDef -> !(Map Text [ExtraLine])
entitySum :: EntityDef -> !Bool
entityPrimary :: EntityDef -> Maybe CompositeDef
type ExtraLine = [Text]
newtype HaskellName
HaskellName :: Text -> HaskellName
unHaskellName :: HaskellName -> Text
newtype DBName
DBName :: Text -> DBName
unDBName :: DBName -> Text
type Attr = Text
data FieldType

-- | Optional module and name.
FTTypeCon :: (Maybe Text) -> Text -> FieldType
FTApp :: FieldType -> FieldType -> FieldType
FTList :: FieldType -> FieldType
data FieldDef
FieldDef :: !HaskellName -> !DBName -> !FieldType -> !SqlType -> ![Attr] -> !Bool -> !ReferenceDef -> FieldDef

-- | name of the field
fieldHaskell :: FieldDef -> !HaskellName
fieldDB :: FieldDef -> !DBName
fieldType :: FieldDef -> !FieldType
fieldSqlType :: FieldDef -> !SqlType

-- | user annotations for a field
fieldAttrs :: FieldDef -> ![Attr]

-- | a strict field in the data type. Default: true
fieldStrict :: FieldDef -> !Bool
fieldReference :: FieldDef -> !ReferenceDef

-- | There are 3 kinds of references 1) composite (to fields that exist in
--   the record) 2) single field 3) embedded
data ReferenceDef
NoReference :: ReferenceDef

-- | A ForeignRef has a late binding to the EntityDef it references via
--   HaskellName and has the Haskell type of the foreign key in the form of
--   FieldType
ForeignRef :: !HaskellName -> !FieldType -> ReferenceDef
EmbedRef :: EmbedEntityDef -> ReferenceDef
CompositeRef :: CompositeDef -> ReferenceDef

-- | A SelfReference stops an immediate cycle which causes non-termination
--   at compile-time (issue #311).
SelfReference :: ReferenceDef

-- | An EmbedEntityDef is the same as an EntityDef But it is only used for
--   fieldReference so it only has data needed for embedding
data EmbedEntityDef
EmbedEntityDef :: !HaskellName -> ![EmbedFieldDef] -> EmbedEntityDef
embeddedHaskell :: EmbedEntityDef -> !HaskellName
embeddedFields :: EmbedEntityDef -> ![EmbedFieldDef]

-- | An EmbedFieldDef is the same as a FieldDef But it is only used for
--   embeddedFields so it only has data needed for embedding
data EmbedFieldDef
EmbedFieldDef :: !DBName -> Maybe EmbedEntityDef -> Maybe HaskellName -> EmbedFieldDef
emFieldDB :: EmbedFieldDef -> !DBName
emFieldEmbed :: EmbedFieldDef -> Maybe EmbedEntityDef

-- | <a>emFieldEmbed</a> can create a cycle (issue #311) when a cycle is
--   detected, <a>emFieldEmbed</a> will be Nothing and <a>emFieldCycle</a>
--   will be Just
emFieldCycle :: EmbedFieldDef -> Maybe HaskellName
toEmbedEntityDef :: EntityDef -> EmbedEntityDef
data UniqueDef
UniqueDef :: !HaskellName -> !DBName -> ![(HaskellName, DBName)] -> ![Attr] -> UniqueDef
uniqueHaskell :: UniqueDef -> !HaskellName
uniqueDBName :: UniqueDef -> !DBName
uniqueFields :: UniqueDef -> ![(HaskellName, DBName)]
uniqueAttrs :: UniqueDef -> ![Attr]
data CompositeDef
CompositeDef :: ![FieldDef] -> ![Attr] -> CompositeDef
compositeFields :: CompositeDef -> ![FieldDef]
compositeAttrs :: CompositeDef -> ![Attr]

-- | Used instead of FieldDef to generate a smaller amount of code
type ForeignFieldDef = (HaskellName, DBName)
data ForeignDef
ForeignDef :: !HaskellName -> !DBName -> !HaskellName -> !DBName -> ![(ForeignFieldDef, ForeignFieldDef)] -> ![Attr] -> Bool -> ForeignDef
foreignRefTableHaskell :: ForeignDef -> !HaskellName
foreignRefTableDBName :: ForeignDef -> !DBName
foreignConstraintNameHaskell :: ForeignDef -> !HaskellName
foreignConstraintNameDBName :: ForeignDef -> !DBName
foreignFields :: ForeignDef -> ![(ForeignFieldDef, ForeignFieldDef)]
foreignAttrs :: ForeignDef -> ![Attr]
foreignNullable :: ForeignDef -> Bool
data PersistException

-- | Generic Exception
PersistError :: Text -> PersistException
PersistMarshalError :: Text -> PersistException
PersistInvalidField :: Text -> PersistException
PersistForeignConstraintUnmet :: Text -> PersistException
PersistMongoDBError :: Text -> PersistException
PersistMongoDBUnsupported :: Text -> PersistException

-- | A raw value which can be stored in any backend and can be marshalled
--   to and from a <tt>PersistField</tt>.
data PersistValue
PersistText :: Text -> PersistValue
PersistByteString :: ByteString -> PersistValue
PersistInt64 :: Int64 -> PersistValue
PersistDouble :: Double -> PersistValue
PersistRational :: Rational -> PersistValue
PersistBool :: Bool -> PersistValue
PersistDay :: Day -> PersistValue
PersistTimeOfDay :: TimeOfDay -> PersistValue
PersistUTCTime :: UTCTime -> PersistValue
PersistNull :: PersistValue
PersistList :: [PersistValue] -> PersistValue
PersistMap :: [(Text, PersistValue)] -> PersistValue

-- | Intended especially for MongoDB backend
PersistObjectId :: ByteString -> PersistValue

-- | Using <a>PersistDbSpecific</a> allows you to use types specific to a
--   particular backend For example, below is a simple example of the
--   PostGIS geography type:
--   
--   <pre>
--   data Geo = Geo ByteString
--   
--   instance PersistField Geo where
--     toPersistValue (Geo t) = PersistDbSpecific t
--   
--     fromPersistValue (PersistDbSpecific t) = Right $ Geo $ Data.ByteString.concat ["'", t, "'"]
--     fromPersistValue _ = Left "Geo values must be converted from PersistDbSpecific"
--   
--   instance PersistFieldSql Geo where
--     sqlType _ = SqlOther "GEOGRAPHY(POINT,4326)"
--   
--   toPoint :: Double -&gt; Double -&gt; Geo
--   toPoint lat lon = Geo $ Data.ByteString.concat ["'POINT(", ps $ lon, " ", ps $ lat, ")'"]
--     where ps = Data.Text.pack . show
--   </pre>
--   
--   If Foo has a geography field, we can then perform insertions like the
--   following:
--   
--   <pre>
--   insert $ Foo (toPoint 44 44)
--   </pre>
PersistDbSpecific :: ByteString -> PersistValue
fromPersistValueText :: PersistValue -> Either Text Text

-- | A SQL data type. Naming attempts to reflect the underlying Haskell
--   datatypes, eg SqlString instead of SqlVarchar. Different SQL databases
--   may have different translations for these types.
data SqlType
SqlString :: SqlType
SqlInt32 :: SqlType
SqlInt64 :: SqlType
SqlReal :: SqlType
SqlNumeric :: Word32 -> Word32 -> SqlType
SqlBool :: SqlType
SqlDay :: SqlType
SqlTime :: SqlType

-- | Always uses UTC timezone
SqlDayTime :: SqlType
SqlBlob :: SqlType

-- | a backend-specific name
SqlOther :: Text -> SqlType
data PersistFilter
Eq :: PersistFilter
Ne :: PersistFilter
Gt :: PersistFilter
Lt :: PersistFilter
Ge :: PersistFilter
Le :: PersistFilter
In :: PersistFilter
NotIn :: PersistFilter
BackendSpecificFilter :: Text -> PersistFilter
data UpdateException
KeyNotFound :: String -> UpdateException
UpsertError :: String -> UpdateException
data OnlyUniqueException
OnlyUniqueException :: String -> OnlyUniqueException
data PersistUpdate
Assign :: PersistUpdate
Add :: PersistUpdate
Subtract :: PersistUpdate
Multiply :: PersistUpdate
Divide :: PersistUpdate
BackendSpecificUpdate :: Text -> PersistUpdate
data SomePersistField
SomePersistField :: a -> SomePersistField

-- | Updating a database entity
--   
--   Persistent users use combinators to create these
data Update record
Update :: EntityField record typ -> typ -> PersistUpdate -> Update record
updateField :: Update record -> EntityField record typ
updateValue :: Update record -> typ
updateUpdate :: Update record -> PersistUpdate
BackendUpdate :: (BackendSpecificUpdate (PersistEntityBackend record) record) -> Update record

-- | query options
--   
--   Persistent users use these directly
data SelectOpt record
Asc :: (EntityField record typ) -> SelectOpt record
Desc :: (EntityField record typ) -> SelectOpt record
OffsetBy :: Int -> SelectOpt record
LimitTo :: Int -> SelectOpt record

-- | Filters which are available for <tt>select</tt>, <tt>updateWhere</tt>
--   and <tt>deleteWhere</tt>. Each filter constructor specifies the field
--   being filtered on, the type of comparison applied (equals, not equals,
--   etc) and the argument for the comparison.
--   
--   Persistent users use combinators to create these
data Filter record
Filter :: EntityField record typ -> Either typ [typ] -> PersistFilter -> Filter record
filterField :: Filter record -> EntityField record typ
filterValue :: Filter record -> Either typ [typ]
filterFilter :: Filter record -> PersistFilter

-- | convenient for internal use, not needed for the API
FilterAnd :: [Filter record] -> Filter record
FilterOr :: [Filter record] -> Filter record
BackendFilter :: (BackendSpecificFilter (PersistEntityBackend record) record) -> Filter record

-- | Datatype that represents an entity, with both its <a>Key</a> and its
--   Haskell record representation.
--   
--   When using a SQL-based backend (such as SQLite or PostgreSQL), an
--   <a>Entity</a> may take any number of columns depending on how many
--   fields it has. In order to reconstruct your entity on the Haskell
--   side, <tt>persistent</tt> needs all of your entity columns and in the
--   right order. Note that you don't need to worry about this when using
--   <tt>persistent</tt>'s API since everything is handled correctly behind
--   the scenes.
--   
--   However, if you want to issue a raw SQL command that returns an
--   <a>Entity</a>, then you have to be careful with the column order.
--   While you could use <tt>SELECT Entity.* WHERE ...</tt> and that would
--   work most of the time, there are times when the order of the columns
--   on your database is different from the order that <tt>persistent</tt>
--   expects (for example, if you add a new field in the middle of you
--   entity definition and then use the migration code --
--   <tt>persistent</tt> will expect the column to be in the middle, but
--   your DBMS will put it as the last column). So, instead of using a
--   query like the one above, you may use <a>rawSql</a> (from the
--   <a>Database.Persist.GenericSql</a> module) with its /entity selection
--   placeholder/ (a double question mark <tt>??</tt>). Using
--   <tt>rawSql</tt> the query above must be written as <tt>SELECT ?? WHERE
--   ..</tt>. Then <tt>rawSql</tt> will replace <tt>??</tt> with the list
--   of all columns that we need from your entity in the right order. If
--   your query returns two entities (i.e. <tt>(Entity backend a, Entity
--   backend b)</tt>), then you must you use <tt>SELECT ??, ?? WHERE
--   ...</tt>, and so on.
data Entity record
Entity :: Key record -> record -> Entity record
entityKey :: Entity record -> Key record
entityVal :: Entity record -> record

module Database.Persist.Quasi

-- | Parses a quasi-quoted syntax into a list of entity definitions.
parse :: PersistSettings -> Text -> [EntityDef]
data PersistSettings
PersistSettings :: !(Text -> Text) -> !Bool -> !Text -> PersistSettings
psToDBName :: PersistSettings -> !(Text -> Text)

-- | Whether fields are by default strict. Default value: <tt>True</tt>.
--   
--   Since 1.2
psStrictFields :: PersistSettings -> !Bool

-- | The name of the id column. Default value: <tt>id</tt> The name of the
--   id column can also be changed on a per-model basis
--   <a>https://github.com/yesodweb/persistent/wiki/Persistent-entity-syntax</a>
--   
--   Since 2.0
psIdName :: PersistSettings -> !Text
upperCaseSettings :: PersistSettings
lowerCaseSettings :: PersistSettings
nullable :: [Text] -> IsNullable
instance Show a => Show (ParseState a)
instance Show Token
instance Eq Token

module Database.Persist.Class

-- | ToBackendKey converts a <a>PersistEntity</a> <a>Key</a> into a
--   <a>BackendKey</a> This can be used by each backend to convert between
--   a <a>Key</a> and a plain Haskell type. For Sql, that is done with
--   <tt>toSqlKey</tt> and <tt>fromSqlKey</tt>.
--   
--   By default, a <a>PersistEntity</a> uses the default <a>BackendKey</a>
--   for its Key and is an instance of ToBackendKey
--   
--   A <a>Key</a> that instead uses a custom type will not be an instance
--   of <a>ToBackendKey</a>
class (PersistEntity record, PersistEntityBackend record ~ backend, PersistStore backend) => ToBackendKey backend record
toBackendKey :: ToBackendKey backend record => Key record -> BackendKey backend
fromBackendKey :: ToBackendKey backend record => BackendKey backend -> Key record
class (Show (BackendKey backend), Read (BackendKey backend), Eq (BackendKey backend), Ord (BackendKey backend), PersistField (BackendKey backend), ToJSON (BackendKey backend), FromJSON (BackendKey backend)) => PersistStore backend where data family BackendKey backend insert_ val = insert val >> return () insertMany = mapM insert insertMany_ x = insertMany x >> return () insertEntityMany = mapM_ (\ (Entity k record) -> insertKey k record) updateGet key ups = do { update key ups; get key >>= maybe (liftIO $ throwIO $ KeyNotFound $ show key) return }
get :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => Key val -> ReaderT backend m (Maybe val)
insert :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => val -> ReaderT backend m (Key val)
insert_ :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => val -> ReaderT backend m ()
insertMany :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => [val] -> ReaderT backend m [Key val]
insertMany_ :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => [val] -> ReaderT backend m ()
insertEntityMany :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => [Entity val] -> ReaderT backend m ()
insertKey :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => Key val -> val -> ReaderT backend m ()
repsert :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => Key val -> val -> ReaderT backend m ()
replace :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => Key val -> val -> ReaderT backend m ()
delete :: (PersistStore backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => Key val -> ReaderT backend m ()
update :: (PersistStore backend, MonadIO m, PersistEntity val, backend ~ PersistEntityBackend val) => Key val -> [Update val] -> ReaderT backend m ()
updateGet :: (PersistStore backend, MonadIO m, PersistEntity val, backend ~ PersistEntityBackend val) => Key val -> [Update val] -> ReaderT backend m val

-- | Same as get, but for a non-null (not Maybe) foreign key Unsafe unless
--   your database is enforcing that the foreign key is valid
getJust :: (PersistStore backend, PersistEntity val, Show (Key val), backend ~ PersistEntityBackend val, MonadIO m) => Key val -> ReaderT backend m val

-- | curry this to make a convenience function that loads an associated
--   model
--   
--   <pre>
--   foreign = belongsTo foerignId
--   </pre>
belongsTo :: (PersistStore backend, PersistEntity ent1, PersistEntity ent2, backend ~ PersistEntityBackend ent2, MonadIO m) => (ent1 -> Maybe (Key ent2)) -> ent1 -> ReaderT backend m (Maybe ent2)

-- | same as belongsTo, but uses <tt>getJust</tt> and therefore is
--   similarly unsafe
belongsToJust :: (PersistStore backend, PersistEntity ent1, PersistEntity ent2, backend ~ PersistEntityBackend ent2, MonadIO m) => (ent1 -> Key ent2) -> ent1 -> ReaderT backend m ent2

-- | like <tt>insert</tt>, but returns the complete <tt>Entity</tt>
insertEntity :: (PersistStore backend, PersistEntity e, backend ~ PersistEntityBackend e, MonadIO m) => e -> ReaderT backend m (Entity e)

-- | Queries against <a>Unique</a> keys (other than the id <a>Key</a>).
--   
--   Please read the general Persistent documentation to learn how to
--   create <a>Unique</a> keys.
--   
--   Using this with an Entity without a Unique key leads to undefined
--   behavior. A few of these functions require a *single* <a>Unique</a>,
--   so using an Entity with multiple <a>Unique</a>s is also undefined. In
--   these cases persistent's goal is to throw an exception as soon as
--   possible, but persistent is still transitioning to that.
--   
--   SQL backends automatically create uniqueness constraints, but for
--   MongoDB you must manually place a unique index on a field to have a
--   uniqueness constraint.
--   
--   Some functions in this module (insertUnique, insertBy, and
--   replaceUnique) first query the unique indexes to check for conflicts.
--   You could instead optimistically attempt to perform the operation
--   (e.g. replace instead of replaceUnique). However,
--   
--   <ul>
--   <li>there is some fragility to trying to catch the correct exception
--   and determing the column of failure.</li>
--   <li>an exception will automatically abort the current SQL
--   transaction</li>
--   </ul>
class PersistStore backend => PersistUnique backend where insertUnique datum = do { conflict <- checkUnique datum; case conflict of { Nothing -> Just `liftM` insert datum Just _ -> return Nothing } } upsert record updates = do { uniqueKey <- onlyUnique record; mExists <- getBy uniqueKey; k <- case mExists of { Just (Entity k _) -> do { when (null updates) (replace k record); return k } Nothing -> insert record }; Entity k `liftM` updateGet k updates }
getBy :: (PersistUnique backend, MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => Unique val -> ReaderT backend m (Maybe (Entity val))
deleteBy :: (PersistUnique backend, MonadIO m, PersistEntityBackend val ~ backend, PersistEntity val) => Unique val -> ReaderT backend m ()
insertUnique :: (PersistUnique backend, MonadIO m, PersistEntityBackend val ~ backend, PersistEntity val) => val -> ReaderT backend m (Maybe (Key val))
upsert :: (PersistUnique backend, MonadIO m, PersistEntityBackend val ~ backend, PersistEntity val) => val -> [Update val] -> ReaderT backend m (Entity val)

-- | A modification of <a>getBy</a>, which takes the <a>PersistEntity</a>
--   itself instead of a <a>Unique</a> record. Returns a record matching
--   <i>one</i> of the unique keys. This function makes the most sense on
--   entities with a single <a>Unique</a> constructor.
getByValue :: (MonadIO m, PersistEntity record, PersistUnique backend, PersistEntityBackend record ~ backend) => record -> ReaderT backend m (Maybe (Entity record))

-- | Insert a value, checking for conflicts with any unique constraints. If
--   a duplicate exists in the database, it is returned as <a>Left</a>.
--   Otherwise, the new 'Key is returned as <a>Right</a>.
insertBy :: (MonadIO m, PersistEntity val, PersistUnique backend, PersistEntityBackend val ~ backend) => val -> ReaderT backend m (Either (Entity val) (Key val))

-- | Attempt to replace the record of the given key with the given new
--   record. First query the unique fields to make sure the replacement
--   maintains uniqueness constraints. Return <a>Nothing</a> if the
--   replacement was made. If uniqueness is violated, return a <a>Just</a>
--   with the <a>Unique</a> violation
--   
--   Since 1.2.2.0
replaceUnique :: (MonadIO m, Eq record, Eq (Unique record), PersistEntityBackend record ~ backend, PersistEntity record, PersistUnique backend) => Key record -> record -> ReaderT backend m (Maybe (Unique record))

-- | Check whether there are any conflicts for unique keys with this entity
--   and existing entities in the database.
--   
--   Returns <a>Nothing</a> if the entity would be unique, and could thus
--   safely be inserted. on a conflict returns the conflicting key
checkUnique :: (MonadIO m, PersistEntityBackend record ~ backend, PersistEntity record, PersistUnique backend) => record -> ReaderT backend m (Maybe (Unique record))

-- | Return the single unique key for a record
onlyUnique :: (MonadIO m, PersistEntity val, PersistUnique backend, PersistEntityBackend val ~ backend) => val -> ReaderT backend m (Unique val)
class PersistStore backend => PersistQuery backend where selectFirst filts opts = do { srcRes <- selectSourceRes filts ((LimitTo 1) : opts); liftIO $ with srcRes ($$ head) }
updateWhere :: (PersistQuery backend, MonadIO m, PersistEntity val, backend ~ PersistEntityBackend val) => [Filter val] -> [Update val] -> ReaderT backend m ()
deleteWhere :: (PersistQuery backend, MonadIO m, PersistEntity val, backend ~ PersistEntityBackend val) => [Filter val] -> ReaderT backend m ()
selectSourceRes :: (PersistQuery backend, PersistEntity val, PersistEntityBackend val ~ backend, MonadIO m1, MonadIO m2) => [Filter val] -> [SelectOpt val] -> ReaderT backend m1 (Acquire (Source m2 (Entity val)))
selectFirst :: (PersistQuery backend, MonadIO m, PersistEntity val, backend ~ PersistEntityBackend val) => [Filter val] -> [SelectOpt val] -> ReaderT backend m (Maybe (Entity val))
selectKeysRes :: (PersistQuery backend, MonadIO m1, MonadIO m2, PersistEntity val, backend ~ PersistEntityBackend val) => [Filter val] -> [SelectOpt val] -> ReaderT backend m1 (Acquire (Source m2 (Key val)))
count :: (PersistQuery backend, MonadIO m, PersistEntity val, backend ~ PersistEntityBackend val) => [Filter val] -> ReaderT backend m Int

-- | Get all records matching the given criterion in the specified order.
--   Returns also the identifiers.
selectSource :: (PersistQuery backend, MonadResource m, PersistEntity val, PersistEntityBackend val ~ backend, MonadReader env m, HasPersistBackend env backend) => [Filter val] -> [SelectOpt val] -> Source m (Entity val)

-- | Get the <a>Key</a>s of all records matching the given criterion.
selectKeys :: (PersistQuery backend, MonadResource m, PersistEntity val, backend ~ PersistEntityBackend val, MonadReader env m, HasPersistBackend env backend) => [Filter val] -> [SelectOpt val] -> Source m (Key val)

-- | Call <a>selectSource</a> but return the result as a list.
selectList :: (MonadIO m, PersistEntity val, PersistQuery backend, PersistEntityBackend val ~ backend) => [Filter val] -> [SelectOpt val] -> ReaderT backend m [Entity val]

-- | Call <a>selectKeys</a> but return the result as a list.
selectKeysList :: (MonadIO m, PersistEntity val, PersistQuery backend, PersistEntityBackend val ~ backend) => [Filter val] -> [SelectOpt val] -> ReaderT backend m [Key val]
class (PersistStore backend, PersistEntity record, backend ~ PersistEntityBackend record) => DeleteCascade record backend
deleteCascade :: (DeleteCascade record backend, MonadIO m) => Key record -> ReaderT backend m ()
deleteCascadeWhere :: (MonadIO m, DeleteCascade record backend, PersistQuery backend) => [Filter record] -> ReaderT backend m ()

-- | Persistent serialized Haskell records to the database. A Database
--   <a>Entity</a> (A row in SQL, a document in MongoDB, etc) corresponds
--   to a <a>Key</a> plus a Haskell record.
--   
--   For every Haskell record type stored in the database there is a
--   corresponding <a>PersistEntity</a> instance. An instance of
--   PersistEntity contains meta-data for the record. PersistEntity also
--   helps abstract over different record types. That way the same query
--   interface can return a <a>PersistEntity</a>, with each query returning
--   different types of Haskell records.
--   
--   Some advanced type system capabilities are used to make this process
--   type-safe. Persistent users usually don't need to understand the class
--   associated data and functions.
class (PersistField (Key record), ToJSON (Key record), FromJSON (Key record), Show (Key record), Read (Key record), Eq (Key record), Ord (Key record)) => PersistEntity record where type family PersistEntityBackend record data family Key record data family EntityField record :: * -> * data family Unique record
keyToValues :: PersistEntity record => Key record -> [PersistValue]
keyFromValues :: PersistEntity record => [PersistValue] -> Either Text (Key record)
persistIdField :: PersistEntity record => EntityField record (Key record)
entityDef :: (PersistEntity record, Monad m) => m record -> EntityDef
persistFieldDef :: PersistEntity record => EntityField record typ -> FieldDef
toPersistFields :: PersistEntity record => record -> [SomePersistField]
fromPersistValues :: PersistEntity record => [PersistValue] -> Either Text record
persistUniqueKeys :: PersistEntity record => record -> [Unique record]
persistUniqueToFieldNames :: PersistEntity record => Unique record -> [(HaskellName, DBName)]
persistUniqueToValues :: PersistEntity record => Unique record -> [PersistValue]
fieldLens :: PersistEntity record => EntityField record field -> (forall f. Functor f => (field -> f field) -> Entity record -> f (Entity record))

-- | A value which can be marshalled to and from a <a>PersistValue</a>.
class PersistField a
toPersistValue :: PersistField a => a -> PersistValue
fromPersistValue :: PersistField a => PersistValue -> Either Text a

-- | Represents a value containing all the configuration options for a
--   specific backend. This abstraction makes it easier to write code that
--   can easily swap backends.
class PersistConfig c where type family PersistConfigBackend c :: (* -> *) -> * -> * type family PersistConfigPool c applyEnv = return
loadConfig :: PersistConfig c => Value -> Parser c
applyEnv :: PersistConfig c => c -> IO c
createPoolConfig :: PersistConfig c => c -> IO (PersistConfigPool c)
runPool :: (PersistConfig c, MonadBaseControl IO m, MonadIO m) => c -> PersistConfigBackend c m a -> PersistConfigPool c -> m a
class HasPersistBackend env backend | env -> backend
persistBackend :: HasPersistBackend env backend => env -> backend
liftPersist :: (MonadReader env m, HasPersistBackend env backend, MonadIO m) => ReaderT backend IO a -> m a

-- | Predefined <tt>toJSON</tt>. The resulting JSON looks like <tt>{"key":
--   1, "value": {"name": ...}}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance ToJSON (Entity User) where
--       toJSON = keyValueEntityToJSON
--   </pre>
keyValueEntityToJSON :: (PersistEntity record, ToJSON record, ToJSON (Key record)) => Entity record -> Value

-- | Predefined <tt>parseJSON</tt>. The input JSON looks like <tt>{"key":
--   1, "value": {"name": ...}}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance FromJSON (Entity User) where
--       parseJSON = keyValueEntityFromJSON
--   </pre>
keyValueEntityFromJSON :: (PersistEntity record, FromJSON record, FromJSON (Key record)) => Value -> Parser (Entity record)

-- | Predefined <tt>toJSON</tt>. The resulting JSON looks like <tt>{"id":
--   1, "name": ...}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance ToJSON (Entity User) where
--       toJSON = entityIdToJSON
--   </pre>
entityIdToJSON :: (PersistEntity record, ToJSON record, ToJSON (Key record)) => Entity record -> Value

-- | Predefined <tt>parseJSON</tt>. The input JSON looks like <tt>{"id": 1,
--   "name": ...}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance FromJSON (Entity User) where
--       parseJSON = entityIdFromJSON
--   </pre>
entityIdFromJSON :: (PersistEntity record, FromJSON record, FromJSON (Key record)) => Value -> Parser (Entity record)

module Database.Persist

-- | assign a field a value
(=.) :: PersistField typ => EntityField v typ -> typ -> Update v

-- | assign a field by addition (+=)
(+=.) :: PersistField typ => EntityField v typ -> typ -> Update v

-- | assign a field by subtraction (-=)
(-=.) :: PersistField typ => EntityField v typ -> typ -> Update v

-- | assign a field by multiplication (*=)
(*=.) :: PersistField typ => EntityField v typ -> typ -> Update v

-- | assign a field by division (/=)
(/=.) :: PersistField typ => EntityField v typ -> typ -> Update v
(==.) :: PersistField typ => EntityField v typ -> typ -> Filter v
(!=.) :: PersistField typ => EntityField v typ -> typ -> Filter v
(<.) :: PersistField typ => EntityField v typ -> typ -> Filter v
(>.) :: PersistField typ => EntityField v typ -> typ -> Filter v
(<=.) :: PersistField typ => EntityField v typ -> typ -> Filter v
(>=.) :: PersistField typ => EntityField v typ -> typ -> Filter v

-- | In
(<-.) :: PersistField typ => EntityField v typ -> [typ] -> Filter v

-- | NotIn
(/<-.) :: PersistField typ => EntityField v typ -> [typ] -> Filter v

-- | the OR of two lists of filters
(||.) :: [Filter v] -> [Filter v] -> [Filter v]
listToJSON :: [PersistValue] -> Text
mapToJSON :: [(Text, PersistValue)] -> Text
toJsonText :: ToJSON j => j -> Text
getPersistMap :: PersistValue -> Either Text [(Text, PersistValue)]
limitOffsetOrder :: PersistEntity val => [SelectOpt val] -> (Int, Int, [SelectOpt val])

module Database.Persist.Sql.Util
parseEntityValues :: PersistEntity record => EntityDef -> [PersistValue] -> Either Text (Entity record)
entityColumnNames :: EntityDef -> SqlBackend -> [Sql]
entityColumnCount :: EntityDef -> Int
isIdField :: PersistEntity record => EntityField record typ -> Bool
hasCompositeKey :: EntityDef -> Bool
dbIdColumns :: SqlBackend -> EntityDef -> [Text]
dbIdColumnsEsc :: (DBName -> Text) -> EntityDef -> [Text]
dbColumns :: SqlBackend -> EntityDef -> [Text]

module Database.Persist.Sql
data InsertSqlResult
ISRSingle :: Text -> InsertSqlResult
ISRInsertGet :: Text -> Text -> InsertSqlResult
ISRManyKeys :: Text -> [PersistValue] -> InsertSqlResult

-- | Deprecated synonym for <tt>SqlBackend</tt>.

-- | <i>Deprecated: Please use SqlBackend instead</i>
type Connection = SqlBackend
data SqlBackend
SqlBackend :: (Text -> IO Statement) -> (EntityDef -> [PersistValue] -> InsertSqlResult) -> Maybe (EntityDef -> [[PersistValue]] -> InsertSqlResult) -> IORef (Map Text Statement) -> IO () -> ([EntityDef] -> (Text -> IO Statement) -> EntityDef -> IO (Either [Text] [(Bool, Text)])) -> ((Text -> IO Statement) -> IO ()) -> ((Text -> IO Statement) -> IO ()) -> ((Text -> IO Statement) -> IO ()) -> (DBName -> Text) -> Text -> Text -> ((Int, Int) -> Bool -> Text -> Text) -> LogFunc -> SqlBackend
connPrepare :: SqlBackend -> Text -> IO Statement

-- | table name, column names, id name, either 1 or 2 statements to run
connInsertSql :: SqlBackend -> EntityDef -> [PersistValue] -> InsertSqlResult

-- | SQL for inserting many rows and returning their primary keys, for
--   backends that support this functioanlity. If <a>Nothing</a>, rows will
--   be inserted one-at-a-time using <a>connInsertSql</a>.
connInsertManySql :: SqlBackend -> Maybe (EntityDef -> [[PersistValue]] -> InsertSqlResult)
connStmtMap :: SqlBackend -> IORef (Map Text Statement)
connClose :: SqlBackend -> IO ()
connMigrateSql :: SqlBackend -> [EntityDef] -> (Text -> IO Statement) -> EntityDef -> IO (Either [Text] [(Bool, Text)])
connBegin :: SqlBackend -> (Text -> IO Statement) -> IO ()
connCommit :: SqlBackend -> (Text -> IO Statement) -> IO ()
connRollback :: SqlBackend -> (Text -> IO Statement) -> IO ()
connEscapeName :: SqlBackend -> DBName -> Text
connNoLimit :: SqlBackend -> Text
connRDBMS :: SqlBackend -> Text
connLimitOffset :: SqlBackend -> (Int, Int) -> Bool -> Text -> Text
connLogFunc :: SqlBackend -> LogFunc
type LogFunc = Loc -> LogSource -> LogLevel -> LogStr -> IO ()
data Statement
Statement :: IO () -> IO () -> ([PersistValue] -> IO Int64) -> (forall m. MonadIO m => [PersistValue] -> Acquire (Source m [PersistValue])) -> Statement
stmtFinalize :: Statement -> IO ()
stmtReset :: Statement -> IO ()
stmtExecute :: Statement -> [PersistValue] -> IO Int64
stmtQuery :: Statement -> forall m. MonadIO m => [PersistValue] -> Acquire (Source m [PersistValue])
data Column
Column :: !DBName -> !Bool -> !SqlType -> !(Maybe Text) -> !(Maybe DBName) -> !(Maybe Integer) -> !(Maybe (DBName, DBName)) -> Column
cName :: Column -> !DBName
cNull :: Column -> !Bool
cSqlType :: Column -> !SqlType
cDefault :: Column -> !(Maybe Text)
cDefaultConstraintName :: Column -> !(Maybe DBName)
cMaxLen :: Column -> !(Maybe Integer)
cReference :: Column -> !(Maybe (DBName, DBName))
data PersistentSqlException
StatementAlreadyFinalized :: Text -> PersistentSqlException
Couldn'tGetSQLConnection :: PersistentSqlException
type SqlPersistT = ReaderT SqlBackend

-- | <i>Deprecated: Please use SqlPersistT instead</i>
type SqlPersist = SqlPersistT
type SqlPersistM = SqlPersistT (NoLoggingT (ResourceT IO))
type Sql = Text
type CautiousMigration = [(Bool, Sql)]
type Migration = WriterT [Text] (WriterT CautiousMigration (ReaderT SqlBackend IO)) ()
type ConnectionPool = Pool SqlBackend

-- | A single column (see <tt>rawSql</tt>). Any <tt>PersistField</tt> may
--   be used here, including <a>PersistValue</a> (which does not do any
--   processing).
newtype Single a
Single :: a -> Single a
unSingle :: Single a -> a

-- | Class for data types that may be retrived from a <tt>rawSql</tt>
--   query.
class RawSql a
rawSqlCols :: RawSql a => (DBName -> Text) -> a -> (Int, [Text])
rawSqlColCountReason :: RawSql a => a -> String
rawSqlProcessRow :: RawSql a => [PersistValue] -> Either Text a
class PersistField a => PersistFieldSql a
sqlType :: PersistFieldSql a => Proxy a -> SqlType

-- | Get a connection from the pool, run the given action, and then return
--   the connection to the pool.
--   
--   Note: This function previously timed out after 2 seconds, but this
--   behavior was buggy and caused more problems than it solved. Since
--   version 2.1.2, it performs no timeout checks.
runSqlPool :: MonadBaseControl IO m => SqlPersistT m a -> Pool SqlBackend -> m a

-- | Like <a>withResource</a>, but times out the operation if resource
--   allocation does not complete within the given timeout period.
--   
--   Since 2.0.0
withResourceTimeout :: MonadBaseControl IO m => Int -> Pool a -> (a -> m b) -> m (Maybe b)
runSqlConn :: MonadBaseControl IO m => SqlPersistT m a -> SqlBackend -> m a
runSqlPersistM :: SqlPersistM a -> SqlBackend -> IO a
runSqlPersistMPool :: SqlPersistM a -> Pool SqlBackend -> IO a
withSqlPool :: (MonadIO m, MonadLogger m, MonadBaseControl IO m) => (LogFunc -> IO SqlBackend) -> Int -> (Pool SqlBackend -> m a) -> m a
createSqlPool :: (MonadIO m, MonadLogger m, MonadBaseControl IO m) => (LogFunc -> IO SqlBackend) -> Int -> m (Pool SqlBackend)
askLogFunc :: (MonadBaseControl IO m, MonadLogger m) => m LogFunc
withSqlConn :: (MonadIO m, MonadBaseControl IO m, MonadLogger m) => (LogFunc -> IO SqlBackend) -> (SqlBackend -> m a) -> m a
close' :: SqlBackend -> IO ()
parseMigration :: MonadIO m => Migration -> ReaderT SqlBackend m (Either [Text] CautiousMigration)
parseMigration' :: MonadIO m => Migration -> ReaderT SqlBackend m (CautiousMigration)
printMigration :: MonadIO m => Migration -> ReaderT SqlBackend m ()
showMigration :: MonadIO m => Migration -> ReaderT SqlBackend m [Text]
getMigration :: MonadIO m => Migration -> ReaderT SqlBackend m [Sql]
runMigration :: MonadIO m => Migration -> ReaderT SqlBackend m ()

-- | Same as <a>runMigration</a>, but returns a list of the SQL commands
--   executed instead of printing them to stderr.
runMigrationSilent :: (MonadBaseControl IO m, MonadIO m) => Migration -> ReaderT SqlBackend m [Text]
runMigrationUnsafe :: MonadIO m => Migration -> ReaderT SqlBackend m ()
migrate :: [EntityDef] -> EntityDef -> Migration
withRawQuery :: MonadIO m => Text -> [PersistValue] -> Sink [PersistValue] IO a -> ReaderT SqlBackend m a
toSqlKey :: ToBackendKey SqlBackend record => Int64 -> Key record
fromSqlKey :: ToBackendKey SqlBackend record => Key record -> Int64

-- | get the SQL string for the field that an EntityField represents Useful
--   for raw SQL queries
--   
--   Your backend may provide a more convenient fieldName function which
--   does not operate in a Monad
getFieldName :: (PersistEntity record, PersistEntityBackend record ~ SqlBackend, Monad m) => EntityField record typ -> ReaderT SqlBackend m Text

-- | get the SQL string for the table that a PeristEntity represents Useful
--   for raw SQL queries
--   
--   Your backend may provide a more convenient tableName function which
--   does not operate in a Monad
getTableName :: (PersistEntity record, PersistEntityBackend record ~ SqlBackend, Monad m) => record -> ReaderT SqlBackend m Text

-- | useful for a backend to implement tableName by adding escaping
tableDBName :: (PersistEntity record, PersistEntityBackend record ~ SqlBackend) => record -> DBName

-- | useful for a backend to implement fieldName by adding escaping
fieldDBName :: PersistEntity record => EntityField record typ -> DBName
rawQuery :: (MonadResource m, MonadReader env m, HasPersistBackend env SqlBackend) => Text -> [PersistValue] -> Source m [PersistValue]
rawQueryRes :: (MonadIO m1, MonadIO m2) => Text -> [PersistValue] -> ReaderT SqlBackend m1 (Acquire (Source m2 [PersistValue]))

-- | Execute a raw SQL statement
rawExecute :: MonadIO m => Text -> [PersistValue] -> ReaderT SqlBackend m ()

-- | Execute a raw SQL statement and return the number of rows it has
--   modified.
rawExecuteCount :: MonadIO m => Text -> [PersistValue] -> ReaderT SqlBackend m Int64

-- | Execute a raw SQL statement and return its results as a list.
--   
--   If you're using <a>Entity</a><tt>s</tt> (which is quite likely), then
--   you <i>must</i> use entity selection placeholders (double question
--   mark, <tt>??</tt>). These <tt>??</tt> placeholders are then replaced
--   for the names of the columns that we need for your entities. You'll
--   receive an error if you don't use the placeholders. Please see the
--   <a>Entity</a><tt>s</tt> documentation for more details.
--   
--   You may put value placeholders (question marks, <tt>?</tt>) in your
--   SQL query. These placeholders are then replaced by the values you pass
--   on the second parameter, already correctly escaped. You may want to
--   use <a>toPersistValue</a> to help you constructing the placeholder
--   values.
--   
--   Since you're giving a raw SQL statement, you don't get any guarantees
--   regarding safety. If <a>rawSql</a> is not able to parse the results of
--   your query back, then an exception is raised. However, most common
--   problems are mitigated by using the entity selection placeholder
--   <tt>??</tt>, and you shouldn't see any error at all if you're not
--   using <a>Single</a>.
rawSql :: (RawSql a, MonadIO m) => Text -> [PersistValue] -> ReaderT SqlBackend m [a]

-- | Same as <a>deleteWhere</a>, but returns the number of rows affected.
--   
--   Since 1.1.5
deleteWhereCount :: (PersistEntity val, MonadIO m, PersistEntityBackend val ~ SqlBackend) => [Filter val] -> ReaderT SqlBackend m Int64

-- | Same as <a>updateWhere</a>, but returns the number of rows affected.
--   
--   Since 1.1.5
updateWhereCount :: (PersistEntity val, MonadIO m, SqlBackend ~ PersistEntityBackend val) => [Filter val] -> [Update val] -> ReaderT SqlBackend m Int64

-- | Commit the current transaction and begin a new one.
--   
--   Since 1.2.0
transactionSave :: MonadIO m => ReaderT SqlBackend m ()

-- | Roll back the current transaction and begin a new one.
--   
--   Since 1.2.0
transactionUndo :: MonadIO m => ReaderT SqlBackend m ()
getStmtConn :: SqlBackend -> Text -> IO Statement

-- | Create the list of columns for the given entity.
mkColumns :: [EntityDef] -> EntityDef -> ([Column], [UniqueDef], [ForeignDef])
defaultAttribute :: [Attr] -> Maybe Text

-- | Generates sql for limit and offset for postgres, sqlite and mysql.
decorateSQLWithLimitOffset :: Text -> (Int, Int) -> Bool -> Text -> Text
