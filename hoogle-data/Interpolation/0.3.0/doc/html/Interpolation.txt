-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Multiline strings, interpolation and templating.
--   
--   This package adds quasiquoter for multiline strings, interpolation and
--   simple templating. It can handle repetition templates which makes it
--   Handy for outputting larger structures, such as latex tables or
--   gnuplot files.
--   
--   <ol>
--   <li>3.0 - Instead of Strings, the <a>str</a> quasiquoter produces
--   values of type `(Monoid a, IsString a) =&gt; a`, making it compatible
--   many other libraries, such as <a>Data.Text</a> and
--   <a>Blaze.Builder</a>.</li>
--   <li>2.6 - A handy quote for printing</li>
--   <li>2.5.1 - version bump for ghc-7.0.1</li>
--   </ol>
@package Interpolation
@version 0.3.0


-- | This module defines a quasiquoter for interpolated strings. For
--   example:
--   
--   <pre>
--   import qualified Data.Text.Lazy as LT
--   let fb x | x `mod` 15 == 0 = "FizzBuzz" 
--            | x `mod` 5 == 0 = "Buzz" 
--            | x `mod` 3 == 0 = "Fizz" 
--            | otherwise = LT.pack (show x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; LT.take 85 [str|#x in [1..]:$fb x$|, #|] &lt;&gt; ".. "
--   "1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, 17, Fizz.. "
--   </pre>
module Data.String.Interpolation

-- | Quasiquote <a>str</a> implements multiline strings with interpolation.
--   Interpolating a value into the string is done by $&lt;String
--   expression&gt;$ and interpolating anything with instance Show is
--   $:&lt;Show expression&gt;$. Due to pretty deep limitations, the parser
--   is not able to properly deduce associtivity of infix operators, so use
--   lots and lots of parenthesis.
--   
--   Repetitive patterns can be made with # symbol:
--   
--   <pre>
--   #&lt;pattern&gt; in &lt;list&gt;: &lt;interpolated string&gt; (|&lt;interpolated string&gt;)#
--   </pre>
--   
--   Where (|&lt;interpolated string&gt;) denotes optional separator for
--   the elements.
--   
--   Multiline indentation is handled by aligning on smallest un-empty line
--   after the first. Neither pattern matching nor nested #-patterns are
--   supported, however, see example below.
--   
--   Normal '\\n' style escaping of special characters is intentionally not
--   supported. Please use $endline$ or $<a>n</a>$ style instead.
--   
--   As an example, let's plot set of vectors with gnuplot:
--   
--   <pre>
--   plotVecs :: [(String,[Double])] -&gt; String
--   plotVecs vs =  
--       [$str| ## Plot multiple vectors
--              plot #(n,_) in vs:<a>-</a> with lines lw 5 title $:n$ |, #
--              #d in map snd vs:$singleVec d$$endline$e$endline$# |]
--   where
--    singleVec n = [$str|#(e,i) in zip n [1..]: $:i$ $:e$|$endline$#|]
--   </pre>
--   
--   <pre>
--     *Gnuplotter&gt; plotVecs [("A",[1..5]),("B",[2..6])]
--     # Plot multiple vectors
--      plot <a>-</a> with lines lw 5 title "A" , <a>-</a> with lines lw 5 title "B" 
--       1 1.0
--       2 2.0
--       3 3.0
--       4 4.0
--       5 5.0
--   
--   e
--       1 2.0
--       2 3.0
--       3 4.0
--       4 5.0
--       5 6.0
--   
--   e
--   </pre>
str :: QuasiQuoter
prnt :: QuasiQuoter

-- | End of the line
endline :: IsString a => a

-- | Tab
tab :: IsString a => a
instance Typeable StringBits
instance Eq StringBits
instance Ord StringBits
instance Show StringBits
instance Data StringBits
