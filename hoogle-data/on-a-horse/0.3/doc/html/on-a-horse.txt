-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | "Haskell on a Horse" - A combinatorial web framework
--   
--   Please read the introduction at on-a-horse.org
@package on-a-horse
@version 0.3

module Control.Arrow.Transformer.Automaton.Maybe
newtype MaybeAutomaton a i o
MaybeAutomaton :: (a i (o, Maybe (Automaton a i o))) -> MaybeAutomaton a i o
mAut :: MaybeAutomaton t t1 t2 -> t t1 (t2, Maybe (Automaton t t1 t2))
automatonFromMaybe :: Arrow a => MaybeAutomaton a b c -> Automaton a b c
maybeFromAutomaton :: Arrow a => Automaton a i o -> MaybeAutomaton a i o
instance ArrowChoice a => ArrowChoice (MaybeAutomaton a)
instance Arrow a => Arrow (MaybeAutomaton a)
instance Arrow a => Category (MaybeAutomaton a)

module Control.Arrow.Transformer.Automaton.Monad
readerArrow :: Arrow a => a (e, r) b -> ReaderArrow r a e b
swapsnd :: ((a, b), c) -> ((a, c), b)
autoToMonad :: (ArrowApply a', ArrowAddAutomaton a may a') => a i (Either o z) -> i -> ContT (o, a i o) (ArrowMonad a') z
co :: (ArrowApply a', ArrowAddAutomaton a may a') => o -> ContT (o, a i o) (ArrowMonad a') i
monadToAuto :: (ArrowAddAutomaton a may a', ArrowApply a') => (i -> ContT (o, a i o) (ArrowMonad a') z) -> a i o
pushError :: ArrowChoice a => a e (Either ex b) -> ErrorArrow ex a e b
popError :: ArrowChoice a => ErrorArrow ex a e b -> a e (Either ex b)
rstrength :: (Either ex a, b) -> Either ex (a, b)
class (ArrowChoice a, ArrowChoice may, ArrowChoice a', ArrowApply a') => ArrowAddAutomaton a may a' | a -> a', a -> may, may -> a
elimAutomaton :: ArrowAddAutomaton a may a' => a i o -> a' i (o, a i o)
liftAutomaton :: ArrowAddAutomaton a may a' => a' i (o, a i o) -> a i o
constantAutomaton :: ArrowAddAutomaton a may a' => a' i o -> a i o
toMaybeAutomaton :: ArrowAddAutomaton a may a' => a i o -> may i o
fromMaybeAutomaton :: ArrowAddAutomaton a may a' => may i o -> a i o
liftMaybeAutomaton :: ArrowAddAutomaton a may a' => a' i (o, Maybe (a i o)) -> may i o
elimMaybeAutomaton :: ArrowAddAutomaton a may a' => may i o -> a' i (o, Maybe (a i o))
dispatch :: (Ord k, ArrowAddAutomaton a may a') => (k -> may i o) -> may (i, k) o
instance (ArrowChoice a, ArrowChoice may, ArrowChoice a', ArrowAddAutomaton a may a') => ArrowAddAutomaton (ErrorArrow ex a) (ErrorArrow ex may) (ErrorArrow ex a')
instance (Arrow a, Arrow a', ArrowAddAutomaton a may a') => ArrowAddAutomaton (ReaderArrow r a) (ReaderArrow r may) (ReaderArrow r a')
instance (ArrowState s a, ArrowApply a) => MonadState s (ArrowMonad a)
instance (Arrow a, Arrow may, Arrow a', ArrowAddAutomaton a may a') => ArrowAddAutomaton (StateArrow s a) (StateArrow s may) (StateArrow s a')
instance (ArrowChoice a, ArrowApply a) => ArrowAddAutomaton (Automaton a) (MaybeAutomaton a) a

module Control.Arrow.Transformer.LabeledArrow
newtype Label
Label :: Integer -> Label
base64 :: [Char]
read64 :: (Enum a, Num a) => [Char] -> Maybe a
alterReader :: ArrowReader t2 t1 => (t2 -> t2) -> t1 e t -> t1 e t
pushId :: ArrowReader Label t1 => Integer -> t1 e t -> t1 e t
class (Arrow a, Arrow a') => ArrowAddLabel a a' | a -> a'
runLabel :: ArrowAddLabel a a' => a' (e, Label) b -> a e b
runArrowLabel :: Arrow a => a (t, Label) o -> LabeledArrow a t o
newtype LabeledArrow a i o
LabeledArrow :: (ReaderArrow Label a i o) -> LabeledArrow a i o
unLA :: LabeledArrow t t1 t2 -> ReaderArrow Label t t1 t2
runLabeledArrow :: Arrow t1 => LabeledArrow t1 e t -> t1 e t
writeState :: Show t => t -> LabeledArrow (Kleisli IO) i ()
foo :: IO ()
instance ArrowChoice a => ArrowChoice (LabeledArrow a)
instance ArrowApply a => ArrowApply (LabeledArrow a)
instance ArrowAddError ex a a' => ArrowAddError ex (LabeledArrow a) (LabeledArrow a')
instance ArrowError ex a => ArrowError ex (LabeledArrow a)
instance (Arrow a, Arrow a', ArrowAddAutomaton a may a') => ArrowAddAutomaton (LabeledArrow a) (LabeledArrow may) (LabeledArrow a')
instance Arrow a => Arrow (LabeledArrow a)
instance (Category a, Arrow a) => Category (LabeledArrow a)
instance ArrowReader r a => ArrowReader r (LabeledArrow a)
instance (ArrowAddLabel a a', ArrowChoice a, ArrowChoice a') => ArrowAddLabel (ErrorArrow ex a) (ErrorArrow ex a')
instance ArrowAddLabel a a' => ArrowAddLabel (ReaderArrow r a) (ReaderArrow r a')
instance Arrow a => ArrowAddLabel (LabeledArrow a) a
instance Read Label
instance Show Label

module Web.Horse
type FormOut = String
newtype FormIn
FormIn :: [(String, String)] -> FormIn
type HoH i o = LabeledArrow (ReaderArrow FormIn (Automaton (Kleisli IO))) i o
type HoHMay i o = LabeledArrow (ReaderArrow FormIn (MaybeAutomaton (Kleisli IO))) i o
type HoHErr ex i o = LabeledArrow (ErrorArrow ex (ReaderArrow FormIn (Automaton (Kleisli IO)))) i o
type HoHErrMay ex i o = LabeledArrow (ErrorArrow ex (ReaderArrow FormIn (MaybeAutomaton (Kleisli IO)))) i o
noInput :: FormIn
filterPrefix :: String -> FormIn -> FormIn
class HasFormOut o
getFormOut :: HasFormOut o => o -> FormOut
setFormOut :: HasFormOut o => FormOut -> o -> o
getSingle :: FormIn -> Maybe String
withInput :: (ArrowReader FormIn a', ArrowAddLabel a a', ArrowAddAutomaton a1 a' a'1) => a1 (e, String, Maybe String) b -> a e b
withInput0 :: (ArrowReader FormIn a', ArrowAddLabel a a') => a' (e, String, Maybe String) b -> a e b
restify :: ArrowAddAutomaton a may a' => a (t, t1, Maybe t2) o -> may (t, t1, Maybe t2) o
catchAuto :: ArrowAddAutomaton a may a' => (LabeledArrow (ErrorArrow (LabeledArrow a i o) a)) i o -> LabeledArrow a i o
catchMayAuto :: ArrowAddAutomaton a may a' => LabeledArrow (ErrorArrow (LabeledArrow a t1 o) may) t1 o -> LabeledArrow may t1 o
textField :: String -> Maybe String -> String -> String -> String
link :: String -> String -> String
select :: String -> [String] -> Int -> String -> String
wrapForm :: String -> String
valForm :: (ArrowReader FormIn a', ArrowAddAutomaton a1 a' a'1, ArrowAddLabel a a') => String -> a1 String (Either String a2) -> String -> a () (String, Maybe a2)
stringForm :: (ArrowReader FormIn a', ArrowAddAutomaton a1 a' a'1, ArrowAddLabel a a') => String -> a () (String, Maybe String)
readForm :: (Read a2, ArrowReader FormIn a', ArrowAddAutomaton a1 a' a'1, ArrowAddLabel a a') => String -> a () (String, Maybe a2)
enumForm :: (ArrowAddAutomaton a1 may a', ArrowAddLabel a may, ArrowReader FormIn may) => String -> [(String, b)] -> a () (String, Maybe b)
runSubStream :: ArrowChoice a => a i o -> a (Maybe i) (Maybe o)
filterDiffs :: (ArrowAddAutomaton a may a', Eq i, ArrowApply a') => a i (Maybe i)
keepState :: ArrowAddAutomaton a may a' => o -> a (Maybe o) o
replaceSecond :: (ArrowAddAutomaton a may a', ArrowAddAutomaton a1 may1 a') => a1 i o -> a (i, Maybe (a1 i o)) o
once :: ArrowAddAutomaton a may a' => a1 -> a a2 (Maybe a1)
auto :: Automaton t t1 t2 -> t t1 (t2, Automaton t t1 t2)
formSum :: (ArrowReader FormIn may, ArrowReader FormIn a', ArrowAddAutomaton a may a', HasFormOut o) => String -> [(String, LabeledArrow may t1 o)] -> o -> LabeledArrow may t1 o
throwMayAuto :: (ArrowReader FormIn a1, ArrowError (a i o) cat, ArrowAddAutomaton a may (LabeledArrow a1)) => cat (may i o) c
throwAuto :: (ArrowReader FormIn a1, ArrowError (a i o) t1, ArrowAddAutomaton a may (LabeledArrow a1)) => t1 (a i o) t
linkForm :: (ArrowReader FormIn a', ArrowReader FormIn a3, ArrowError (a2 i o) a1, ArrowAddAutomaton a1 a' a'1, ArrowAddAutomaton a2 may (LabeledArrow a3), ArrowAddLabel a a') => String -> may i o -> a () String
staticUrls :: a -> [(String, a)] -> ([String] -> a)
type Url = [String]
runHorse :: LabeledArrow (ReaderArrow FormIn (MaybeAutomaton (Kleisli IO))) Url String -> IO Application
runHorse1 :: MaybeAutomaton (Kleisli IO) (Url, FormIn) String -> IO Application
sessionTarget :: Num a => a
runWeb :: MVar [(String, MVar (Automaton (Kleisli IO) (Url, FormIn) String))] -> MaybeAutomaton (Kleisli IO) (Url, FormIn) String -> Application
compact :: Eq b => MVar [(b, b1)] -> IO ()
getSessionMVar :: MVar [(String, MVar (Automaton (Kleisli IO) (Url, FormIn) String))] -> Request -> IO (Maybe (MVar (Automaton (Kleisli IO) (Url, FormIn) String)))
sessionName :: [Char]
extractFormInputs :: Request -> ResourceT IO ([String], FormIn)
asResponse :: String -> [(String, String)] -> Response
getRequestCookies :: Request -> [(String, String)]
