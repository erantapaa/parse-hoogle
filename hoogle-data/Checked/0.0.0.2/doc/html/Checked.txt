-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Inbuilt checking for ultra reliable computing
--   
--   Inbuilt checking for ultra reliable computing
@package Checked
@version 0.0.0.2


-- | A checked value is a value, potentially wrapped in a warning, i.e. a
--   non-fatal exception.
--   
--   Where the checked value looks like (Right value), the value is within
--   limits Where the checked value looks like (Left (warning, cause,
--   value)), the value is out of limits
--   
--   Warning is ("warning message", severity), and cause is also a (Left
--   (warning, cause value)) which allows a "linked list" of warnings to be
--   set up
--   
--   Run your code within a <a>Checked</a> monad to benefit from real time
--   checking
--   
--   To retrofit checking to an existing function myFunc :: MyType1 -&gt;
--   MyType2 -&gt; MyType3:
--   
--   (a) define a type which is a tuple of the parameters to myFunc
--   
--   <pre>
--   type  MyFuncParams = (MyType1, MyType2)
--   </pre>
--   
--   (b) define the test for validity of the parameters expected by myFunc:
--   
--   <pre>
--   instance Checkable MyFuncParams where
--     check params = .. Checked (Right params) -- if OK
--                    .. Checked (Left (pack "Invalid params to myFunc", 20), Nothing, params) -- if params are out of whack
--   </pre>
--   
--   (c) define the test for validity of the output type, or any type in
--   your code:
--   
--   <pre>
--   instance <a>Checkable</a> MyType3 where
--     check v = .. Checked (Right v) -- if OK
--               .. Checked (Left (pack "Type MyType3 is out of range", 20), Nothing, v) -- if the value is out of whack for this type
--   </pre>
--   
--   (d) define a wrapper function for myFunction for myFunc which accepts
--   a parameter of type MyFuncParams:
--   
--   <pre>
--       myFunc' :: MyFuncParams -&gt; MyType3
--       myFunc' (a, b) = myFunc a b
--   * Looking to automate this step, perhaps with TH *
--   </pre>
--   
--   (e) run your function within the <a>Checked</a> monad, using
--   <a>applyWithParamsCheck</a> as the function calls, and <a>check</a> to
--   check the output values
--   
--   <pre>
--   code :: MyType1 -&gt; MyType2 -&gt; Checked MyType4
--   code a b = do
--       f &lt;- applyWithCheckedParams myFunc' (a, b)
--       g &lt;- check y
--       h &lt;- applyWithCheckedParams myFunc1' g
--       check h
--   </pre>
module Data.Checked

-- | A warning that the value is not within limits, with a measurable
--   indication of severity
type Warning = (Text, Integer)

-- | A wrapper type indicating that the value is or is not within limits
data Checked a
Checked :: (Either (Warning, Maybe (Checked b), a) a) -> Checked a

-- | Useful function
getCheckedValue :: Checked a -> a

-- | This is implemented for types whose values will be checked
class Checkable a
check :: Checkable a => a -> Checked a

-- | This is needed because we need to select the correct check function
--   for the parameters to this function We do this by capturing the
--   parameters as a single type, for which we have defined a checkable
--   instance
applyWithParamsCheck :: Checkable a => (a -> b) -> a -> Checked b
data UnderOneHundred a
UnderOneHundred :: a -> UnderOneHundred a
sumTest :: UnderOneHundred Integer -> UnderOneHundred Integer -> UnderOneHundred Integer
type SumTestFuncParams = (UnderOneHundred Integer, UnderOneHundred Integer)
sumTest' :: SumTestFuncParams -> UnderOneHundred Integer
test :: UnderOneHundred Integer -> UnderOneHundred Integer -> Checked (UnderOneHundred Integer)
instance Show a => Show (UnderOneHundred a)
instance Eq a => Eq (UnderOneHundred a)
instance Ord a => Ord (UnderOneHundred a)
instance Checkable SumTestFuncParams
instance (Num a, Eq a, Ord a) => Checkable (UnderOneHundred a)
instance Monad Checked
instance Applicative Checked
instance Functor Checked
instance Show a => Show (Checked a)
