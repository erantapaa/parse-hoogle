-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bulk array representations and operators.
--   
@package repa-array
@version 4.1.0.1

module Data.Repa.Nice.Display

-- | How a given value should be displayed.
data Display
Display :: Format -> Int -> Display

-- | Common display formats.
data Format
FormatNumeric :: Format
FormatText :: Format

-- | Display a string with the given mode.
display :: Display -> Text -> Text

-- | Examine a string to decide how we should display it.
takeDisplay :: Text -> Display

-- | Left justify some text in a column of the given width.
padL :: Int -> Text -> Text

-- | Right justify some text in a column of the given width.
padR :: Int -> Text -> Text
instance Eq Format
instance Show Format
instance Eq Display
instance Show Display
instance Monoid Display

module Data.Repa.Fusion.Unpack

-- | Unpack the pieces of a structure into a tuple.
--   
--   This is used in a low-level fusion optimisation to ensure that
--   intermediate values are unboxed.
class Unpack a t | a -> t
unpack :: Unpack a t => a -> t
repack :: Unpack a t => a -> t -> a


-- | Shapes and Indices
module Data.Repa.Array.Generic.Index

-- | Class of types that can be used as array shapes and indices.
class Eq sh => Shape sh
rank :: Shape sh => sh -> Int
zeroDim :: Shape sh => sh
unitDim :: Shape sh => sh
intersectDim :: Shape sh => sh -> sh -> sh
addDim :: Shape sh => sh -> sh -> sh
size :: Shape sh => sh -> Int
inShapeRange :: Shape sh => sh -> sh -> sh -> Bool
listOfShape :: Shape sh => sh -> [Int]
shapeOfList :: Shape sh => [Int] -> Maybe sh

-- | Given an array shape and index, check whether the index is in the
--   shape.
inShape :: Shape sh => sh -> sh -> Bool

-- | Nicely format a shape as a string
showShape :: Shape sh => sh -> String

-- | An index of dimension zero
data Z
Z :: Z

-- | Our index type, used for both shapes and indices.
data (:.) tail head
(:.) :: !tail -> !head -> (:.) tail head
type SH0 = Z
type SH1 = SH0 :. Int
type SH2 = SH1 :. Int
type SH3 = SH2 :. Int
type SH4 = SH3 :. Int
type SH5 = SH4 :. Int
ish0 :: SH0
ish1 :: Int -> SH1
ish2 :: Int -> Int -> SH2
ish3 :: Int -> Int -> Int -> SH3
ish4 :: Int -> Int -> Int -> Int -> SH4
ish5 :: Int -> Int -> Int -> Int -> Int -> SH5

-- | A layout provides a total order on the elements of an index space.
--   
--   We can talk about the n-th element of an array, independent of its
--   shape and dimensionality.
class Shape (Index l) => Layout l where data family Name l type family Index l
name :: Layout l => Name l
create :: Layout l => Name l -> Index l -> l
extent :: Layout l => l -> Index l
toIndex :: Layout l => l -> Index l -> Int
fromIndex :: Layout l => l -> Int -> Index l
type LayoutI l = (Layout l, Index l ~ Int)


-- | Index space transformation between arrays and slices.
module Data.Repa.Array.Generic.Slice

-- | Select all indices at a certain position.
data All
All :: All

-- | Place holder for any possible shape.
data Any sh
Any :: Any sh

-- | Map a type of the index in the full shape, to the type of the index in
--   the slice.

-- | Map the type of an index in the slice, to the type of the index in the
--   full shape.

-- | Class of index types that can map to slices.
class Slice ss
sliceOfFull :: Slice ss => ss -> FullShape ss -> SliceShape ss
fullOfSlice :: Slice ss => ss -> SliceShape ss -> FullShape ss
instance Slice sl => Slice (sl :. All)
instance Slice sl => Slice (sl :. Int)
instance Slice (Any sh)
instance Slice Z

module Data.Repa.Array.Meta.Window
data W l
Window :: Index l -> Index l -> l -> W l
windowStart :: W l -> Index l
windowSize :: W l -> Index l
windowInner :: W l -> l

-- | Class of array representations that can be windowed directly.
--   
--   The underlying representation can encode the window, without needing
--   to add a wrapper to the existing layout.
class Bulk l a => Windowable l a
window :: Windowable l a => Index l -> Index l -> Array l a -> Array l a

-- | Wrap a window around an exiting array.
windowed :: Index l -> Index l -> Array l a -> Array (W l) a

-- | Wrap a window around an existing array that encompases the entire
--   array.
entire :: Bulk l a => Array l a -> Array (W l) a

-- | O(1). Take the tail of an array, or <a>Nothing</a> if it's empty.
tail :: (Windowable l a, Index l ~ Int) => Array l a -> Maybe (Array l a)

-- | O(1). Take the initial elements of an array, or <a>Nothing</a> if it's
--   empty.
init :: (Windowable l a, Index l ~ Int) => Array l a -> Maybe (Array l a)
instance Show (Name l) => Show (Name (W l))
instance Eq (Name l) => Eq (Name (W l))
instance (Eq l, Eq (Index l)) => Eq (W l)
instance (Show l, Show (Index l)) => Show (W l)
instance Bulk l a => Windowable (W l) a
instance Bulk l a => Bulk (W l) a
instance Layout l => Layout (W l)

module Data.Repa.Array.Material.Strided

-- | Layout for Foreign Strided arrays.
--   
--   UNSAFE: indexing into foreign strided arrays is not bounds checked.
--   You may want to wrap this with a Checked layout as well.
data S
Strided :: !Int -> S
stridedLength :: S -> !Int

-- | O(1). Cast a foreign array from one element type to another.
unsafeCast :: (Storable a, Storable b) => Array S a -> Array S b

-- | O(1). Wrap a <tt>ForeignPtr</tt> as a strided array.
fromForeignPtr :: Int -> Int -> Int -> ForeignPtr a -> Array S a

-- | O(1). Unwrap a <tt>ForeignPtr</tt> from a strided array.
toForeignPtr :: Array S a -> (Int, Int, Int, ForeignPtr a)
instance (Storable a, Show a) => Show (Array S a)
instance Show (Name S)
instance Eq (Name S)
instance Show S
instance Eq S
instance Storable a => Windowable S a
instance Unpack (Array S a) (Int, Int, Int, ForeignPtr a)
instance Storable a => Bulk S a
instance Layout S

module Data.Repa.Array.Meta.RowWise

-- | A row-wise layout that maps higher rank indices to linear ones in a
--   row-major order.
--   
--   Indices are ordered so the inner-most coordinate varies most
--   frequently:
--   
--   <pre>
--   &gt; Prelude.map (fromIndex (RowWise (ish2 2 3))) [0..5]
--      [(Z :. 0) :. 0, (Z :. 0) :. 1, (Z :. 0) :. 2, 
--       (Z :. 1) :. 0, (Z :. 1) :. 1, (Z :. 1) :. 2]
--   </pre>
--   
--   <ul>
--   <li>Indexing is not bounds checked. Indexing outside the extent yields
--   the corresponding index.</li>
--   </ul>
data RW sh
RowWise :: !sh -> RW sh
rowWiseShape :: RW sh -> !sh

-- | Construct a rowWise array that produces the corresponding index for
--   every element.
--   
--   <pre>
--   &gt; toList $ rowWise (ish2 3 2) 
--      [(Z :. 0) :. 0, (Z :. 0) :. 1,
--       (Z :. 1) :. 0, (Z :. 1) :. 1,
--       (Z :. 2) :. 0, (Z :. 2) :. 1]
--   </pre>
rowWise :: sh -> Array (RW sh) sh
type DIM1 = RW SH1
type DIM2 = RW SH2
type DIM3 = RW SH3
type DIM4 = RW SH4
type DIM5 = RW SH5
ix1 :: Int -> DIM1
ix2 :: Int -> Int -> DIM2
ix3 :: Int -> Int -> Int -> DIM3
ix4 :: Int -> Int -> Int -> Int -> DIM4
ix5 :: Int -> Int -> Int -> Int -> Int -> DIM5
instance Show (Name (RW sh)) => Show (Name (RW (sh :. Int)))
instance Eq (Name (RW sh)) => Eq (Name (RW (sh :. Int)))
instance Show (Name (RW Z))
instance Eq (Name (RW Z))
instance Show sh => Show (RW sh)
instance Eq sh => Eq (RW sh)
instance (Layout (RW sh), Index (RW sh) ~ sh) => Bulk (RW sh) sh
instance (Layout (RW sh), Index (RW sh) ~ sh) => Layout (RW (sh :. Int))
instance Layout (RW Z)
instance Shape sh => Shape (RW sh)

module Data.Repa.Array.Meta.Linear

-- | A linear layout with the elements indexed by integers.
--   
--   <ul>
--   <li>Indexing is not bounds checked. Indexing outside the extent yields
--   the corresponding index.</li>
--   </ul>
data L
Linear :: Int -> L
linearLength :: L -> Int

-- | Construct a linear array that produces the corresponding index for
--   every element.
--   
--   <pre>
--   &gt; toList $ linear 10
--      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
--   </pre>
linear :: Int -> Array L Int
instance Show (Name L)
instance Eq (Name L)
instance Show L
instance Eq L
instance Bulk L Int
instance Layout L

module Data.Repa.Array.Generic.Load

-- | Compute all elements defined by a delayed array and write them to a
--   manifest target representation.
--   
--   The instances of this class require that the source array has a
--   delayed representation. If you want to use a pre-existing manifest
--   array as the source then <tt>delay</tt> it first.
class (Bulk l1 a, Target l2 a) => Load l1 l2 a
loadS :: Load l1 l2 a => Array l1 a -> Buffer l2 a -> IO ()
loadP :: Load l1 l2 a => Gang -> Array l1 a -> Buffer l2 a -> IO ()

-- | Sequential computation of delayed array elements.
--   
--   Elements of the source array are computed sequentially and written to
--   a new array of the specified layout.
computeS :: (Load lSrc lDst a, Index lSrc ~ Index lDst) => Name lDst -> Array lSrc a -> Array lDst a

-- | Like <a>computeS</a> but use the provided desination layout.
--   
--   The size of the destination layout must match the size of the source
--   array, else <a>Nothing</a>.
computeIntoS :: Load lSrc lDst a => lDst -> Array lSrc a -> Maybe (Array lDst a)

module Data.Repa.Array.Generic.Target

-- | Class of manifest array representations that can be constructed in a
--   random-access manner.
class Layout l => Target l a where data family Buffer l a
unsafeNewBuffer :: Target l a => l -> IO (Buffer l a)
unsafeReadBuffer :: Target l a => Buffer l a -> Int -> IO a
unsafeWriteBuffer :: Target l a => Buffer l a -> Int -> a -> IO ()
unsafeGrowBuffer :: Target l a => Buffer l a -> Int -> IO (Buffer l a)
unsafeSliceBuffer :: Target l a => Int -> Int -> Buffer l a -> IO (Buffer l a)
unsafeFreezeBuffer :: Target l a => Buffer l a -> IO (Array l a)
unsafeThawBuffer :: Target l a => Array l a -> IO (Buffer l a)
touchBuffer :: Target l a => Buffer l a -> IO ()
bufferLayout :: Target l a => Buffer l a -> l

-- | Constraint synonym that requires an integer index space.
type TargetI l a = (Target l a, Index l ~ Int)

-- | O(length src). Construct a linear array from a list of elements.
fromList :: TargetI l a => Name l -> [a] -> Array l a

-- | O(length src). Construct an array from a list of elements, and give it
--   the provided layout.
--   
--   The <a>length</a> of the provided shape must match the length of the
--   list, else <a>Nothing</a>.
fromListInto :: Target l a => l -> [a] -> Maybe (Array l a)

module Data.Repa.Array.Material.Boxed

-- | Layout an array as flat vector of boxed elements.
--   
--   UNSAFE: Indexing into raw material arrays is not bounds checked. You
--   may want to wrap this with a Checked layout as well.
data B
Boxed :: !Int -> B
boxedLength :: B -> !Int

-- | O(1). Wrap a boxed vector as an array.
fromBoxed :: Vector a -> Array B a

-- | O(1). Unwrap a boxed vector from an array.
toBoxed :: Array B a -> Vector a

-- | Scan through an array from front to back. For pairs of successive
--   elements, drop the second one when the given predicate returns true.
--   
--   This function can be used to remove duplicates from a sorted array.
--   
--   TODO: generalise to other array types.
decimate :: (a -> a -> Bool) -> Array B a -> Array B a
instance Show a => Show (Array B a)
instance Show (Name B)
instance Eq (Name B)
instance Show B
instance Eq B
instance Unpack (Buffer B a) (IOVector a)
instance Target B a
instance Windowable B a
instance Eq a => Eq (Array B a)
instance Bulk B a
instance Layout B

module Data.Repa.Array.Meta.Delayed

-- | Delayed arrays wrap functions from an index to element value. The
--   index space is specified by an inner layout, <tt>l</tt>.
--   
--   Every time you index into a delayed array the element at that position
--   is recomputed.
data D l
Delayed :: l -> D l
delayedLayout :: D l -> l

-- | Wrap a function as a delayed array.
--   
--   <pre>
--   &gt; toList $ fromFunction (Linear 10) (* 2)
--       = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
--   </pre>
fromFunction :: l -> (Index l -> a) -> Array (D l) a

-- | Produce the extent of an array, and a function to retrieve an
--   arbitrary element.
toFunction :: Bulk l a => Array (D l) a -> (l, Index l -> a)

-- | Wrap an existing array in a delayed one.
delay :: Bulk l a => Array l a -> Array (D l) a

-- | Apply a worker function to each element of an array, yielding a new
--   array with the same extent.
--   
--   The resulting array is delayed, meaning every time you index into it
--   the element at that index is recomputed.
map :: Bulk l a => (a -> b) -> Array l a -> Array (D l) b

-- | O(1). View the elements of a vector in reverse order.
--   
--   <pre>
--   &gt; toList $ reverse $ fromList U [0..10 :: Int]
--   [10,9,8,7,6,5,4,3,2,1,0]
--   </pre>
reverse :: BulkI l a => Array l a -> Array (D l) a
instance Show (Name l) => Show (Name (D l))
instance Eq (Name l) => Eq (Name (D l))
instance Show l => Show (D l)
instance Eq l => Eq (D l)
instance (Layout l1, Target l2 a) => Load (D l1) l2 a
instance Layout l => Bulk (D l) a
instance Layout l => Layout (D l)

module Data.Repa.Array.Material.Unboxed

-- | Layout an array as a flat vector of unboxed elements.
--   
--   This is the most efficient representation for numerical data.
--   
--   The implementation uses <tt>Data.Vector.Unboxed</tt> which picks an
--   efficient, specialised representation for every element type. In
--   particular, unboxed vectors of pairs are represented as pairs of
--   unboxed vectors.
--   
--   UNSAFE: Indexing into raw material arrays is not bounds checked. You
--   may want to wrap this with a Checked layout as well.
data U
Unboxed :: !Int -> U
unboxedLength :: U -> !Int
class (Vector Vector a, MVector MVector a) => Unbox a

-- | O(1). Wrap an unboxed vector as an array.
fromUnboxed :: Unbox a => Vector a -> Array U a

-- | O(1). Unwrap an unboxed vector from an array.
toUnboxed :: Unbox a => Array U a -> Vector a
instance (Show a, Unbox a) => Show (Array U a)
instance Show (Name U)
instance Eq (Name U)
instance Show U
instance Eq U
instance Unpack (Buffer U a) (IOVector a)
instance Unbox a => Target U a
instance Unbox a => Windowable U a
instance Unpack (Array U a) (Vector a)
instance (Unbox a, Eq a) => Eq (Array U a)
instance Unbox a => Bulk U a
instance Layout U


-- | Interface with stream fusion.
module Data.Repa.Eval.Stream

-- | Produce a <tt>Stream</tt> for the elements of the given array.
streamOfArray :: (Monad m, Bulk l a, Index l ~ Int) => Array l a -> Stream m a

-- | Compute the elements of a pure <tt>Stream</tt>, writing them into a
--   new array <a>Array</a>.
unstreamToArray :: (Target l a, Unpack (Buffer l a) t) => Name l -> Stream Id a -> Array l a

-- | Compute the elements of an <a>IO</a> <tt>Stream</tt>, writing them to
--   a new <a>Array</a>.
unstreamToArrayIO :: (Target l a, Unpack (Buffer l a) t) => Name l -> Stream IO a -> IO (Array l a)

module Data.Repa.Array.Meta.Delayed2

-- | A delayed array formed from two source arrays. The source arrays can
--   have different layouts but must have the same extent.
data D2 l1 l2
Delayed2 :: l1 -> l2 -> D2 l1 l2
delayed2Layout1 :: D2 l1 l2 -> l1
delayed2Layout2 :: D2 l1 l2 -> l2

-- | Wrap two existing arrays in a delayed array.
delay2 :: (Bulk l1 a, Bulk l2 b, Index l1 ~ Index l2) => Array l1 a -> Array l2 b -> Maybe (Array (D2 l1 l2) (a, b))

-- | Combine two arrays element-wise using the given worker function.
--   
--   The two source arrays must have the same extent, else <a>Nothing</a>.
map2 :: (Bulk l1 a, Bulk l2 b, Index l1 ~ Index l2) => (a -> b -> c) -> Array l1 a -> Array l2 b -> Maybe (Array (D2 l1 l2) c)
instance (Show (Name l1), Show (Name l2)) => Show (Name (D2 l1 l2))
instance (Eq (Name l1), Eq (Name l2)) => Eq (Name (D2 l1 l2))
instance (Show l1, Show l2) => Show (D2 l1 l2)
instance (Eq l1, Eq l2) => Eq (D2 l1 l2)
instance (Layout lSrc1, Layout lSrc2, Target lDst a, Index lSrc1 ~ Index lSrc2) => Load (D2 lSrc1 lSrc2) lDst a
instance (Layout l1, Layout l2, Index l1 ~ Index l2) => Bulk (D2 l1 l2) a
instance (Layout l1, Layout l2, Index l1 ~ Index l2) => Layout (D2 l1 l2)

module Data.Repa.Array.Meta.Dense

-- | The Dense layout maps a higher-ranked index space to some underlying
--   linear index space.
--   
--   For example, we can create a dense 2D row-wise array where the
--   elements are stored in a flat unboxed vector:
--   
--   <pre>
--   &gt; import Data.Repa.Array.Material
--   &gt; let Just arr  = fromListInto (matrix U 10 10) [1000..1099 :: Float]
--   
--   &gt; :type arr
--   arr :: Array (E U (RW DIM2) Float
--   
--   &gt; arr ! (Z :. 5 :. 4)
--   &gt; 1054.0
--   </pre>
data E r l
Dense :: r -> l -> E r l

-- | Yield a layout for a dense vector of the given length.
--   
--   The first argument is the name of the underlying linear layout which
--   stores the elements.
vector :: LayoutI l => Name l -> Int -> E l DIM1

-- | Yield a layout for a matrix with the given number of rows and columns.
matrix :: LayoutI l => Name l -> Int -> Int -> E l DIM2

-- | Yield a layout for a cube with the given number of planes, rows, and
--   columns.
cube :: LayoutI l => Name l -> Int -> Int -> Int -> E l DIM3
instance (Show (Name r), Show (Name l)) => Show (Name (E r l))
instance (Eq (Name r), Eq (Name l)) => Eq (Name (E r l))
instance (Show r, Show l) => Show (E r l)
instance (Eq r, Eq l) => Eq (E r l)
instance Unpack (Buffer r a) tBuf => Unpack (Buffer (E r l) a) (l, tBuf)
instance (Layout l, Index r ~ Int, Target r a) => Target (E r l) a
instance (Index r ~ Int, Layout l, Bulk r a) => Bulk (E r l) a
instance (Index r ~ Int, Layout r, Layout l) => Layout (E r l)

module Data.Repa.Array.Meta.Tuple

-- | Tupled arrays where the components are unpacked and can have separate
--   representations.
data T2 l1 l2
Tup2 :: !l1 -> !l2 -> T2 l1 l2

-- | Tuple two arrays into an array of pairs.
--   
--   The two argument arrays must have the same index type, but can have
--   different extents. The extent of the result is the intersection of the
--   extents of the two argument arrays.
tup2 :: (Bulk l1 a, Bulk l2 b, Index l1 ~ Index l2) => Array l1 a -> Array l2 b -> Array (T2 l1 l2) (a, b)

-- | Untuple an array of tuples in to a tuple of arrays.
--   
--   <ul>
--   <li>The two returned components may have different extents, though
--   they are guaranteed to be at least as big as the argument array. This
--   is the key property that makes <a>untup2</a> different from
--   <tt>unzip</tt>.</li>
--   </ul>
untup2 :: Array (T2 l1 l2) (a, b) -> (Array l1 a, Array l2 b)
instance (Show (Array l1 a), Show (Array l2 b)) => Show (Array (T2 l1 l2) (a, b))
instance (Show (Name l1), Show (Name l2)) => Show (Name (T2 l1 l2))
instance (Eq (Name l1), Eq (Name l2)) => Eq (Name (T2 l1 l2))
instance (Show l1, Show l2) => Show (T2 l1 l2)
instance (Eq l1, Eq l2) => Eq (T2 l1 l2)
instance (Unpack (Buffer r1 a) t1, Unpack (Buffer r2 b) t2) => Unpack (Buffer (T2 r1 r2) (a, b)) (t1, t2)
instance (Target l1 a, Target l2 b, Index l1 ~ Index l2) => Target (T2 l1 l2) (a, b)
instance (Windowable l1 a, Windowable l2 b, Index l1 ~ Index l2) => Windowable (T2 l1 l2) (a, b)
instance (Bulk l1 a, Bulk l2 b, Index l1 ~ Index l2) => Bulk (T2 l1 l2) (a, b)
instance (Index l1 ~ Index l2, Layout l1, Layout l2) => Layout (T2 l1 l2)


-- | Interface with chain fusion.
module Data.Repa.Eval.Chain

-- | Produce a <a>Chain</a> for the elements of the given array. The order
--   in which the elements appear in the chain is determined by the layout
--   of the array.
chainOfArray :: (Monad m, Bulk l a) => Array l a -> Chain m Int a

-- | Compute the elements of a pure <a>Chain</a>, writing them into a new
--   array <a>Array</a>.
unchainToArray :: (Target l a, Unpack (Buffer l a) t) => Name l -> Chain Id s a -> (Array l a, s)

-- | Compute the elements of an <a>IO</a> <a>Chain</a>, writing them to a
--   new <a>Array</a>.
unchainToArrayIO :: (Target l a, Unpack (Buffer l a) t) => Name l -> Chain IO s a -> IO (Array l a, s)


-- | Meta arrays either generate elements on the fly, or wrap an inner
--   array to provide an extra features.
--   
--   <h3>Delayed layouts</h3>
--   
--   Delayed layouts represent the elements of an array by a function that
--   computes those elements on demand.
--   
--   <ul>
--   <li><a>D</a> -- Functions from indices to elements.</li>
--   </ul>
--   
--   <h3>Index-space layouts </h3>
--   
--   Index-space produce the corresponding index for each element of the
--   array, rather than real data. They can be used to define an array
--   shape without needing to provide element data.
--   
--   <ul>
--   <li><a>L</a> -- Linear spaces.</li>
--   <li><a>RW</a> -- RowWise spaces.</li>
--   </ul>
--   
--   <h3>Combining layouts</h3>
--   
--   Combining layouts combine existing layouts into new ones.
--   
--   <ul>
--   <li><a>W</a> -- Windowed arrays.</li>
--   <li><a>E</a> -- Dense arrays.</li>
--   <li><a>T2</a> -- Tupled arrays.</li>
--   </ul>
--   
--   <h3>Array fusion</h3>
--   
--   Array fusion is achieved via the delayed (<a>D</a>) layout and the
--   <tt>computeS</tt> function. For example:
--   
--   <pre>
--   &gt; import Data.Repa.Array
--   &gt; computeS U $ A.map (+ 1) $ A.map (* 2) $ fromList U [1 .. 100 :: Int]
--   </pre>
--   
--   Lets look at the result of the first <a>map</a>:
--   
--   <pre>
--   &gt; :type A.map (* 2) $ fromList U [1 .. 100 :: Int]
--   A.map (* 2) $ fromList U [1 .. 100 :: Int] 
--       :: Array (D U) Int
--   </pre>
--   
--   In the type <tt>Array (D U) Int</tt>, the outer <a>D</a> indicates
--   that the array is represented as a function that computes each element
--   on demand.
--   
--   Applying a second <a>map</a> layers another element-producing function
--   on top:
--   
--   <pre>
--   &gt; :type A.map (+ 1) $ A.map (* 2) $ fromList U [1 .. 100 :: Int]
--   A.map (+ 1) $ A.map (* 2) $ fromList U [1 .. 100 :: Int]
--       :: Array (D (D U)) Int
--   </pre>
--   
--   At runtime, indexing into an array of the above type involves calling
--   the outer <tt>D</tt>-elayed function, which calls the inner
--   <tt>D</tt>-elayed function, which retrieves source data from the inner
--   <tt>U</tt>-nboxed array. Although this works, indexing into a deep
--   stack of delayed arrays can be quite expensive.
--   
--   To fully evaluate a delayed array, use the <tt>computeS</tt> function,
--   which computes each element of the array sequentially. We pass
--   <tt>computeS</tt> the name of the desired result layout, in this case
--   we use <tt>U</tt> to indicate an unboxed array of values:
--   
--   <pre>
--   &gt; :type computeS U $ A.map (+ 1) $ A.map (* 2) $ fromList U [1 .. 100 :: Int]
--   computeS U $ A.map (+ 1) $ A.map (* 2) $ fromList U [1 .. 100 :: Int]
--        :: Array U Int
--   </pre>
--   
--   At runtime, each element of the result will be computed by first
--   reading the source element, applying <tt>(*2)</tt> to it, then
--   applying <tt>(+1)</tt> to it, then writing to the result array. Array
--   "fusion" is achieved by the fact that result of applying <tt>(*2)</tt>
--   to an element is used directly, without writing it to an intermediate
--   buffer.
--   
--   An added bonus is that during compilation, the GHC simplifier will
--   inline the definitions of <a>map</a> and <tt>computeS</tt>, then
--   eliminate the intermediate function calls. In the compiled code all
--   intermediate values will be stored unboxed in registers, without any
--   overhead due to boxing or laziness.
--   
--   When used correctly, array fusion allows Repa programs to run as fast
--   as equivalents in C or Fortran. However, without fusion the programs
--   typically run 10-20x slower (so remember apply <tt>computeS</tt> to
--   delayed arrays).
module Data.Repa.Array.Meta

-- | Delayed arrays wrap functions from an index to element value. The
--   index space is specified by an inner layout, <tt>l</tt>.
--   
--   Every time you index into a delayed array the element at that position
--   is recomputed.
data D l
Delayed :: l -> D l
delayedLayout :: D l -> l

-- | Wrap a function as a delayed array.
--   
--   <pre>
--   &gt; toList $ fromFunction (Linear 10) (* 2)
--       = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
--   </pre>
fromFunction :: l -> (Index l -> a) -> Array (D l) a

-- | Produce the extent of an array, and a function to retrieve an
--   arbitrary element.
toFunction :: Bulk l a => Array (D l) a -> (l, Index l -> a)

-- | Wrap an existing array in a delayed one.
delay :: Bulk l a => Array l a -> Array (D l) a

-- | Apply a worker function to each element of an array, yielding a new
--   array with the same extent.
--   
--   The resulting array is delayed, meaning every time you index into it
--   the element at that index is recomputed.
map :: Bulk l a => (a -> b) -> Array l a -> Array (D l) b

-- | A delayed array formed from two source arrays. The source arrays can
--   have different layouts but must have the same extent.
data D2 l1 l2
Delayed2 :: l1 -> l2 -> D2 l1 l2
delayed2Layout1 :: D2 l1 l2 -> l1
delayed2Layout2 :: D2 l1 l2 -> l2

-- | Wrap two existing arrays in a delayed array.
delay2 :: (Bulk l1 a, Bulk l2 b, Index l1 ~ Index l2) => Array l1 a -> Array l2 b -> Maybe (Array (D2 l1 l2) (a, b))

-- | Combine two arrays element-wise using the given worker function.
--   
--   The two source arrays must have the same extent, else <a>Nothing</a>.
map2 :: (Bulk l1 a, Bulk l2 b, Index l1 ~ Index l2) => (a -> b -> c) -> Array l1 a -> Array l2 b -> Maybe (Array (D2 l1 l2) c)

-- | A linear layout with the elements indexed by integers.
--   
--   <ul>
--   <li>Indexing is not bounds checked. Indexing outside the extent yields
--   the corresponding index.</li>
--   </ul>
data L
Linear :: Int -> L
linearLength :: L -> Int

-- | Construct a linear array that produces the corresponding index for
--   every element.
--   
--   <pre>
--   &gt; toList $ linear 10
--      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
--   </pre>
linear :: Int -> Array L Int

-- | A row-wise layout that maps higher rank indices to linear ones in a
--   row-major order.
--   
--   Indices are ordered so the inner-most coordinate varies most
--   frequently:
--   
--   <pre>
--   &gt; Prelude.map (fromIndex (RowWise (ish2 2 3))) [0..5]
--      [(Z :. 0) :. 0, (Z :. 0) :. 1, (Z :. 0) :. 2, 
--       (Z :. 1) :. 0, (Z :. 1) :. 1, (Z :. 1) :. 2]
--   </pre>
--   
--   <ul>
--   <li>Indexing is not bounds checked. Indexing outside the extent yields
--   the corresponding index.</li>
--   </ul>
data RW sh
RowWise :: !sh -> RW sh
rowWiseShape :: RW sh -> !sh

-- | Construct a rowWise array that produces the corresponding index for
--   every element.
--   
--   <pre>
--   &gt; toList $ rowWise (ish2 3 2) 
--      [(Z :. 0) :. 0, (Z :. 0) :. 1,
--       (Z :. 1) :. 0, (Z :. 1) :. 1,
--       (Z :. 2) :. 0, (Z :. 2) :. 1]
--   </pre>
rowWise :: sh -> Array (RW sh) sh
data W l
Window :: Index l -> Index l -> l -> W l
windowStart :: W l -> Index l
windowSize :: W l -> Index l
windowInner :: W l -> l

-- | Class of array representations that can be windowed directly.
--   
--   The underlying representation can encode the window, without needing
--   to add a wrapper to the existing layout.
class Bulk l a => Windowable l a
window :: Windowable l a => Index l -> Index l -> Array l a -> Array l a

-- | Wrap a window around an exiting array.
windowed :: Index l -> Index l -> Array l a -> Array (W l) a

-- | Wrap a window around an existing array that encompases the entire
--   array.
entire :: Bulk l a => Array l a -> Array (W l) a

-- | O(1). Take the tail of an array, or <a>Nothing</a> if it's empty.
tail :: (Windowable l a, Index l ~ Int) => Array l a -> Maybe (Array l a)

-- | O(1). Take the initial elements of an array, or <a>Nothing</a> if it's
--   empty.
init :: (Windowable l a, Index l ~ Int) => Array l a -> Maybe (Array l a)

-- | The Dense layout maps a higher-ranked index space to some underlying
--   linear index space.
--   
--   For example, we can create a dense 2D row-wise array where the
--   elements are stored in a flat unboxed vector:
--   
--   <pre>
--   &gt; import Data.Repa.Array.Material
--   &gt; let Just arr  = fromListInto (matrix U 10 10) [1000..1099 :: Float]
--   
--   &gt; :type arr
--   arr :: Array (E U (RW DIM2) Float
--   
--   &gt; arr ! (Z :. 5 :. 4)
--   &gt; 1054.0
--   </pre>
data E r l
Dense :: r -> l -> E r l

-- | Yield a layout for a dense vector of the given length.
--   
--   The first argument is the name of the underlying linear layout which
--   stores the elements.
vector :: LayoutI l => Name l -> Int -> E l DIM1

-- | Yield a layout for a matrix with the given number of rows and columns.
matrix :: LayoutI l => Name l -> Int -> Int -> E l DIM2

-- | Yield a layout for a cube with the given number of planes, rows, and
--   columns.
cube :: LayoutI l => Name l -> Int -> Int -> Int -> E l DIM3

-- | Tupled arrays where the components are unpacked and can have separate
--   representations.
data T2 l1 l2
Tup2 :: !l1 -> !l2 -> T2 l1 l2

-- | Tuple two arrays into an array of pairs.
--   
--   The two argument arrays must have the same index type, but can have
--   different extents. The extent of the result is the intersection of the
--   extents of the two argument arrays.
tup2 :: (Bulk l1 a, Bulk l2 b, Index l1 ~ Index l2) => Array l1 a -> Array l2 b -> Array (T2 l1 l2) (a, b)

-- | Untuple an array of tuples in to a tuple of arrays.
--   
--   <ul>
--   <li>The two returned components may have different extents, though
--   they are guaranteed to be at least as big as the argument array. This
--   is the key property that makes <a>untup2</a> different from
--   <tt>unzip</tt>.</li>
--   </ul>
untup2 :: Array (T2 l1 l2) (a, b) -> (Array l1 a, Array l2 b)

module Data.Repa.Array.Material.Nested

-- | Nested array represented as a flat array of elements, and a segment
--   descriptor that describes how the elements are partitioned into the
--   sub-arrays. Using this representation for multidimentional arrays is
--   significantly more efficient than using a boxed array of arrays, as
--   there is no need to allocate the sub-arrays individually in the heap.
--   
--   With a nested type like: <tt>Array N (Array N (Array U Int))</tt>, the
--   concrete representation consists of five flat unboxed vectors: two for
--   each of the segment descriptors associated with each level of nesting,
--   and one unboxed vector to hold all the integer elements.
--   
--   UNSAFE: Indexing into raw material arrays is not bounds checked. You
--   may want to wrap this with a Checked layout as well.
data N
Nested :: !Int -> N
nestedLength :: N -> !Int
class (Vector Vector a, MVector MVector a) => Unbox a

-- | O(size src) Convert some lists to a nested array.
fromLists :: TargetI l a => Name l -> [[a]] -> Array N (Array l a)

-- | O(size src) Convert a triply nested list to a triply nested array.
fromListss :: TargetI l a => Name l -> [[[a]]] -> Array N (Array N (Array l a))

-- | Apply a function to all the elements of a doubly nested array,
--   preserving the nesting structure.
mapElems :: (Array l1 a -> Array l2 b) -> Array N (Array l1 a) -> Array N (Array l2 b)

-- | O(1). Produce a nested array by taking slices from some array of
--   elements.
--   
--   This is a constant time operation, as the representation for nested
--   vectors just wraps the starts, lengths and elements vectors.
slices :: Array F Int -> Array F Int -> Array l a -> Array N (Array l a)

-- | Segmented concatenation. Concatenate triply nested vector, producing a
--   doubly nested vector.
--   
--   <ul>
--   <li>Unlike the plain <a>concat</a> function, this operation is
--   performed entirely on the segment descriptors of the nested arrays,
--   and does not require the inner array elements to be copied.</li>
--   </ul>
--   
--   <pre>
--   &gt; import Data.Repa.Nice
--   &gt; nice $ concats $ fromListss U [["red", "green", "blue"], ["grey", "white"], [], ["black"]]
--   ["red","green","blue","grey","white","black"]
--   </pre>
concats :: Array N (Array N (Array l a)) -> Array N (Array l a)

-- | O(len src). Given predicates which detect the start and end of a
--   segment, split an vector into the indicated segments.
segment :: (BulkI l a, Unbox a) => (a -> Bool) -> (a -> Bool) -> Array l a -> Array N (Array l a)

-- | O(len src). Given a terminating value, split an vector into segments.
--   
--   The result segments do not include the terminator.
--   
--   <pre>
--   &gt; import Data.Repa.Nice
--   &gt; nice $ segmentOn (== ' ') (fromList U "fresh   fried fish  ") 
--   ["fresh "," "," ","fried ","fish "," "]
--   </pre>
segmentOn :: (BulkI l a, Eq a, Unbox a) => (a -> Bool) -> Array l a -> Array N (Array l a)

-- | O(len src). Like <a>segment</a>, but cut the source array twice.
dice :: (BulkI l a, Windowable l a, Unbox a) => (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> Array l a -> Array N (Array N (Array l a))

-- | O(len src). Given field and row terminating values, split an array
--   into rows and fields.
diceSep :: (BulkI l a, Windowable l a, Unbox a, Eq a) => a -> a -> Array l a -> Array N (Array N (Array l a))

-- | For each segment of a nested array, trim elements off the start and
--   end of the segment that match the given predicate.
trims :: BulkI l a => (a -> Bool) -> Array N (Array l a) -> Array N (Array l a)

-- | For each segment of a nested array, trim elements off the end of the
--   segment that match the given predicate.
trimEnds :: BulkI l a => (a -> Bool) -> Array N (Array l a) -> Array N (Array l a)

-- | For each segment of a nested array, trim elements off the start of the
--   segment that match the given predicate.
trimStarts :: BulkI l a => (a -> Bool) -> Array N (Array l a) -> Array N (Array l a)

-- | Ragged transpose of a triply nested array.
--   
--   <ul>
--   <li>This operation is performed entirely on the segment descriptors of
--   the nested arrays, and does not require the inner array elements to be
--   copied.</li>
--   </ul>
ragspose3 :: Array N (Array N (Array l a)) -> Array N (Array N (Array l a))
instance Show (Array l a) => Show (Array N (Array l a))
instance Show (Name N)
instance Eq (Name N)
instance Show N
instance Eq N
instance (BulkI l a, Windowable l a) => Windowable N (Array l a)
instance Unpack (Buffer N (Array l a)) (IOVector (Array l a))
instance (Bulk l a, Target l a, Index l ~ Int) => Target N (Array l a)
instance (BulkI l a, Windowable l a) => Bulk N (Array l a)
instance Layout N

module Data.Repa.Array.Material.Foreign

-- | Layout for dense Foreign arrays.
--   
--   UNSAFE: Indexing into raw material arrays is not bounds checked. You
--   may want to wrap this with a Checked layout as well.
data F
Foreign :: Int -> F
foreignLength :: F -> Int

-- | O(1). Cast a foreign array from one element type to another.
unsafeCast :: (Storable a, Storable b) => Array F a -> Array F b

-- | O(1). Wrap a <a>ForeignPtr</a> as an array.
fromForeignPtr :: Storable a => Int -> ForeignPtr a -> Array F a

-- | O(1). Unwrap a <a>ForeignPtr</a> from an array.
toForeignPtr :: Storable a => Array F a -> (Int, Int, ForeignPtr a)

-- | O(1). Convert a storable <tt>Vector</tt> to a foreign <a>Array</a>
fromStorableVector :: Vector a -> Array F a

-- | O(1). Convert a foreign array to a storable <tt>Vector</tt>.
toStorableVector :: Array F a -> Vector a

-- | O(1). Convert a <a>ByteString</a> to an foreign <a>Array</a>.
fromByteString :: ByteString -> Array F Word8

-- | O(1). Convert a foreign <tt>Vector</tt> to a <a>ByteString</a>.
toByteString :: Array F Word8 -> ByteString

module Data.Repa.Array.Generic.Convert

-- | Constant time conversion of one array representation to another.
class Convert r1 a1 r2 a2
convert :: Convert r1 a1 r2 a2 => Array r1 a1 -> Array r2 a2
instance [incoherent] Convert r a r a

module Data.Repa.Array.Material.Auto

-- | Arrays where the elements that are automatically layed out into some
--   efficient runtime representation.
--   
--   The implementation uses type families to chose unboxed representations
--   for all elements that can be unboxed. In particular: arrays of unboxed
--   tuples are represented as tuples of unboxed arrays, and nested arrays
--   are represented using a segment descriptor and a single single flat
--   vector containing all the elements.
data A
Auto :: Int -> A
autoLength :: A -> Int


-- | Material arrays are represented as concrete data in memory.
--   
--   For performance reasons, random access indexing into these layouts is
--   not bounds checked. However, all bulk operators like <tt>map</tt> and
--   <tt>concat</tt> are guaranteed to be safe.
--   
--   <ul>
--   <li><a>A</a> -- Type directed automatic layout.</li>
--   <li><a>F</a> -- Foreign memory buffers.</li>
--   <li><a>N</a> -- Nested arrays.</li>
--   <li><a>B</a> -- Boxed vectors, via <a>Data.Vector.Boxed</a></li>
--   <li><a>U</a> -- Adaptive unboxed vectors, via
--   <a>Data.Vector.Unboxed</a></li>
--   </ul>
module Data.Repa.Array.Material

-- | Classes supported by all material representations.
--   
--   We can index them in a random-access manner, window them in constant
--   time, and use them as targets for a computation.
--   
--   In particular, delayed arrays are not material as we cannot use them
--   as targets for a computation.
type Material l a = (Bulk l a, Windowable l a, Target l a)

-- | Arrays where the elements that are automatically layed out into some
--   efficient runtime representation.
--   
--   The implementation uses type families to chose unboxed representations
--   for all elements that can be unboxed. In particular: arrays of unboxed
--   tuples are represented as tuples of unboxed arrays, and nested arrays
--   are represented using a segment descriptor and a single single flat
--   vector containing all the elements.
data A
Auto :: Int -> A
autoLength :: A -> Int

-- | Layout for dense Foreign arrays.
--   
--   UNSAFE: Indexing into raw material arrays is not bounds checked. You
--   may want to wrap this with a Checked layout as well.
data F
Foreign :: Int -> F
foreignLength :: F -> Int

-- | O(1). Wrap a <a>ForeignPtr</a> as an array.
fromForeignPtr :: Storable a => Int -> ForeignPtr a -> Array F a

-- | O(1). Unwrap a <a>ForeignPtr</a> from an array.
toForeignPtr :: Storable a => Array F a -> (Int, Int, ForeignPtr a)

-- | O(1). Convert a <a>ByteString</a> to an foreign <a>Array</a>.
fromByteString :: ByteString -> Array F Word8

-- | O(1). Convert a foreign <tt>Vector</tt> to a <a>ByteString</a>.
toByteString :: Array F Word8 -> ByteString

-- | O(1). Convert a storable <tt>Vector</tt> to a foreign <a>Array</a>
fromStorableVector :: Vector a -> Array F a

-- | O(1). Convert a foreign array to a storable <tt>Vector</tt>.
toStorableVector :: Array F a -> Vector a

-- | Nested array represented as a flat array of elements, and a segment
--   descriptor that describes how the elements are partitioned into the
--   sub-arrays. Using this representation for multidimentional arrays is
--   significantly more efficient than using a boxed array of arrays, as
--   there is no need to allocate the sub-arrays individually in the heap.
--   
--   With a nested type like: <tt>Array N (Array N (Array U Int))</tt>, the
--   concrete representation consists of five flat unboxed vectors: two for
--   each of the segment descriptors associated with each level of nesting,
--   and one unboxed vector to hold all the integer elements.
--   
--   UNSAFE: Indexing into raw material arrays is not bounds checked. You
--   may want to wrap this with a Checked layout as well.
data N
Nested :: !Int -> N
nestedLength :: N -> !Int

-- | O(size src) Convert some lists to a nested array.
fromLists :: TargetI l a => Name l -> [[a]] -> Array N (Array l a)

-- | O(size src) Convert a triply nested list to a triply nested array.
fromListss :: TargetI l a => Name l -> [[[a]]] -> Array N (Array N (Array l a))

-- | Layout an array as flat vector of boxed elements.
--   
--   UNSAFE: Indexing into raw material arrays is not bounds checked. You
--   may want to wrap this with a Checked layout as well.
data B
Boxed :: !Int -> B
boxedLength :: B -> !Int

-- | O(1). Wrap a boxed vector as an array.
fromBoxed :: Vector a -> Array B a

-- | O(1). Unwrap a boxed vector from an array.
toBoxed :: Array B a -> Vector a

-- | Layout an array as a flat vector of unboxed elements.
--   
--   This is the most efficient representation for numerical data.
--   
--   The implementation uses <tt>Data.Vector.Unboxed</tt> which picks an
--   efficient, specialised representation for every element type. In
--   particular, unboxed vectors of pairs are represented as pairs of
--   unboxed vectors.
--   
--   UNSAFE: Indexing into raw material arrays is not bounds checked. You
--   may want to wrap this with a Checked layout as well.
data U
Unboxed :: !Int -> U
unboxedLength :: U -> !Int
class (Vector Vector a, MVector MVector a) => Unbox a

-- | O(1). Wrap an unboxed vector as an array.
fromUnboxed :: Unbox a => Vector a -> Array U a

-- | O(1). Unwrap an unboxed vector from an array.
toUnboxed :: Unbox a => Array U a -> Vector a

-- | Apply a function to all the elements of a doubly nested array,
--   preserving the nesting structure.
mapElems :: (Array l1 a -> Array l2 b) -> Array N (Array l1 a) -> Array N (Array l2 b)

-- | Scan through an array from front to back. For pairs of successive
--   elements, drop the second one when the given predicate returns true.
--   
--   This function can be used to remove duplicates from a sorted array.
--   
--   TODO: generalise to other array types.
decimate :: (a -> a -> Bool) -> Array B a -> Array B a

-- | O(1). Produce a nested array by taking slices from some array of
--   elements.
--   
--   This is a constant time operation, as the representation for nested
--   vectors just wraps the starts, lengths and elements vectors.
slices :: Array F Int -> Array F Int -> Array l a -> Array N (Array l a)

-- | Take a desired number of segments, and array of key value pairs where
--   the key is the segment number. Partition the values into the stated
--   number of segments, discarding values where the key falls outside the
--   given range.
--   
--   <ul>
--   <li>This function operates by first allocating a buffer of size (segs
--   * len src) and filling it with a default value. Both the worst case
--   runtime and memory use will be poor for a large number of destination
--   segments.</li>
--   </ul>
--   
--   TODO: we need the pre-init because otherwise unused values in the
--   elems array are undefined. We could avoid this by copying out the used
--   elements after the partition loop finishes. Use a segmented extract
--   function. This would also remove the dependency on the <a>Elt</a>
--   class.
partition :: (BulkI lSrc (Int, a), Target lDst a, Index lDst ~ Int, Elt a) => Name lDst -> Int -> Array lSrc (Int, a) -> Array N (Array lDst a)

-- | Like <a>partition</a> but use the provided function to compute the
--   segment number for each element.
partitionBy :: (BulkI lSrc a, Target lDst a, Index lDst ~ Int, Elt a) => Name lDst -> Int -> (a -> Int) -> Array lSrc a -> Array N (Array lDst a)

-- | Like <a>partition</a> but use the provided function to compute the
--   segment number for each element. The function is given the index of
--   the each element, along with the element itself.
partitionByIx :: (BulkI lSrc a, Target lDst a, Index lDst ~ Int, Elt a) => Name lDst -> Int -> (Int -> a -> Int) -> Array lSrc a -> Array N (Array lDst a)

-- | Segmented concatenation. Concatenate triply nested vector, producing a
--   doubly nested vector.
--   
--   <ul>
--   <li>Unlike the plain <a>concat</a> function, this operation is
--   performed entirely on the segment descriptors of the nested arrays,
--   and does not require the inner array elements to be copied.</li>
--   </ul>
--   
--   <pre>
--   &gt; import Data.Repa.Nice
--   &gt; nice $ concats $ fromListss U [["red", "green", "blue"], ["grey", "white"], [], ["black"]]
--   ["red","green","blue","grey","white","black"]
--   </pre>
concats :: Array N (Array N (Array l a)) -> Array N (Array l a)

-- | O(len src). Given predicates which detect the start and end of a
--   segment, split an vector into the indicated segments.
segment :: (BulkI l a, Unbox a) => (a -> Bool) -> (a -> Bool) -> Array l a -> Array N (Array l a)

-- | O(len src). Given a terminating value, split an vector into segments.
--   
--   The result segments do not include the terminator.
--   
--   <pre>
--   &gt; import Data.Repa.Nice
--   &gt; nice $ segmentOn (== ' ') (fromList U "fresh   fried fish  ") 
--   ["fresh "," "," ","fried ","fish "," "]
--   </pre>
segmentOn :: (BulkI l a, Eq a, Unbox a) => (a -> Bool) -> Array l a -> Array N (Array l a)

-- | O(len src). Like <a>segment</a>, but cut the source array twice.
dice :: (BulkI l a, Windowable l a, Unbox a) => (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> Array l a -> Array N (Array N (Array l a))

-- | O(len src). Given field and row terminating values, split an array
--   into rows and fields.
diceSep :: (BulkI l a, Windowable l a, Unbox a, Eq a) => a -> a -> Array l a -> Array N (Array N (Array l a))

-- | For each segment of a nested array, trim elements off the start and
--   end of the segment that match the given predicate.
trims :: BulkI l a => (a -> Bool) -> Array N (Array l a) -> Array N (Array l a)

-- | For each segment of a nested array, trim elements off the end of the
--   segment that match the given predicate.
trimEnds :: BulkI l a => (a -> Bool) -> Array N (Array l a) -> Array N (Array l a)

-- | For each segment of a nested array, trim elements off the start of the
--   segment that match the given predicate.
trimStarts :: BulkI l a => (a -> Bool) -> Array N (Array l a) -> Array N (Array l a)

-- | Ragged transpose of a triply nested array.
--   
--   <ul>
--   <li>This operation is performed entirely on the segment descriptors of
--   the nested arrays, and does not require the inner array elements to be
--   copied.</li>
--   </ul>
ragspose3 :: Array N (Array N (Array l a)) -> Array N (Array N (Array l a))


-- | Generic array API.
--   
--   A Repa array is a wrapper around an underlying container structure
--   that holds the array elements.
--   
--   In the type (<a>Array</a> <tt>l</tt> <tt>a</tt>), the <tt>l</tt>
--   specifies the <a>Layout</a> of data, which includes the type of the
--   underlying container, as well as how the elements should be arranged
--   in that container. The <tt>a</tt> specifies the element type.
--   
--   The operators provided by this module do not depend on any particular
--   array representation.
module Data.Repa.Array.Generic

-- | Class of array representations that we can read elements from in a
--   random-access manner.
class Layout l => Bulk l a where data family Array l a
layout :: Bulk l a => Array l a -> l
index :: Bulk l a => Array l a -> Index l -> a

-- | Constraint synonym that requires an integer index space.
type BulkI l a = (Bulk l a, Index l ~ Int)

-- | O(1). Alias for <a>index</a>.
(!) :: Bulk l a => Array l a -> Index l -> a

-- | O(1). Get the number of elements in an array.
length :: Bulk l a => Array l a -> Int

-- | Compute all elements defined by a delayed array and write them to a
--   manifest target representation.
--   
--   The instances of this class require that the source array has a
--   delayed representation. If you want to use a pre-existing manifest
--   array as the source then <tt>delay</tt> it first.
class (Bulk l1 a, Target l2 a) => Load l1 l2 a

-- | Class of manifest array representations that can be constructed in a
--   random-access manner.
class Layout l => Target l a

-- | Constraint synonym that requires an integer index space.
type TargetI l a = (Target l a, Index l ~ Int)

-- | Sequential computation of delayed array elements.
--   
--   Elements of the source array are computed sequentially and written to
--   a new array of the specified layout.
computeS :: (Load lSrc lDst a, Index lSrc ~ Index lDst) => Name lDst -> Array lSrc a -> Array lDst a

-- | Like <a>computeS</a> but use the provided desination layout.
--   
--   The size of the destination layout must match the size of the source
--   array, else <a>Nothing</a>.
computeIntoS :: Load lSrc lDst a => lDst -> Array lSrc a -> Maybe (Array lDst a)

-- | O(length src). Construct a linear array from a list of elements.
fromList :: TargetI l a => Name l -> [a] -> Array l a

-- | O(length src). Construct an array from a list of elements, and give it
--   the provided layout.
--   
--   The <a>length</a> of the provided shape must match the length of the
--   list, else <a>Nothing</a>.
fromListInto :: Target l a => l -> [a] -> Maybe (Array l a)

-- | Convert an array to a list.
toList :: Bulk l a => Array l a -> [a]

-- | O(1). Constant time conversion of one array representation to another.
convert :: Convert l1 a1 l2 a2 => Name l2 -> Array l1 a1 -> Array l2 a2

-- | O(n). Linear time copy of one array representation to another.
--   
--   This function must be used instead of <a>convert</a> when the bit-wise
--   layout of the two array representations are different.
copy :: (Bulk l1 a, Target l2 a, Index l1 ~ Index l2) => Name l2 -> Array l1 a -> Array l2 a

-- | Like <a>map</a>, but immediately <a>computeS</a> the result.
mapS :: (Bulk lSrc a, Target lDst b, Index lSrc ~ Index lDst) => Name lDst -> (a -> b) -> Array lSrc a -> Array lDst b

-- | Like <a>map2</a>, but immediately <a>computeS</a> the result.
map2S :: (Bulk lSrc1 a, Bulk lSrc2 b, Target lDst c, Index lSrc1 ~ Index lDst, Index lSrc2 ~ Index lDst) => Name lDst -> (a -> b -> c) -> Array lSrc1 a -> Array lSrc2 b -> Maybe (Array lDst c)

-- | Merge two sorted key-value streams.
merge :: (Ord k, BulkI l1 (k, a), BulkI l2 (k, b), TargetI lDst (k, c), Unpack (Buffer lDst (k, c)) t0) => Name lDst -> (k -> a -> b -> c) -> (k -> a -> c) -> (k -> b -> c) -> Array l1 (k, a) -> Array l2 (k, b) -> Array lDst (k, c)

-- | Like <a>merge</a>, but only produce the elements where the worker
--   functions return <a>Just</a>.
mergeMaybe :: (Ord k, BulkI l1 (k, a), BulkI l2 (k, b), TargetI lDst (k, c), Unpack (Buffer lDst (k, c)) t0) => Name lDst -> (k -> a -> b -> Maybe c) -> (k -> a -> Maybe c) -> (k -> b -> Maybe c) -> Array l1 (k, a) -> Array l2 (k, b) -> Array lDst (k, c)

-- | Combination of <tt>fold</tt> and <a>filter</a>.
--   
--   We walk over the stream front to back, maintaining an accumulator. At
--   each point we can chose to emit an element (or not)
compact :: (BulkI lSrc a, TargetI lDst b, Unpack (Buffer lDst b) t0) => Name lDst -> (s -> a -> (Maybe b, s)) -> s -> Array lSrc a -> Array lDst b

-- | Like <a>compact</a> but use the first value of the stream as the
--   initial state, and add the final state to the end of the output.
compactIn :: (BulkI lSrc a, TargetI lDst a, Unpack (Buffer lDst a) t0) => Name lDst -> (a -> a -> (Maybe a, a)) -> Array lSrc a -> Array lDst a

-- | Keep the elements of an array that match the given predicate.
filter :: (BulkI lSrc a, TargetI lDst a) => Name lDst -> (a -> Bool) -> Array lSrc a -> Array lDst a

-- | Insert elements produced by the given function in to an array.
insert :: (BulkI lSrc a, TargetI lDst a, Unpack (Buffer lDst a) t0) => Name lDst -> (Int -> Maybe a) -> Array lSrc a -> Array lDst a

-- | O(len src) Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: BulkI l a => (a -> Bool) -> Array l a -> Maybe Int

-- | O(len result) Concatenate nested arrays.
--   
--   <pre>
--   &gt; import Data.Repa.Array.Material
--   &gt; let arrs = fromList B [fromList U [1, 2, 3], fromList U [5, 6, 7 :: Int]]
--   &gt; toList $ concat U arrs
--   [1,2,3,5,6,7]
--   </pre>
concat :: ConcatDict lOut lIn tIn lDst a => Name lDst -> Array lOut (Array lIn a) -> Array lDst a

-- | O(len result) Concatenate the elements of some nested vector,
--   inserting a copy of the provided separator array between each element.
--   
--   <pre>
--   &gt; import Data.Repa.Array.Material
--   &gt; let sep  = fromList U [0, 0, 0]
--   &gt; let arrs = fromList B [fromList U [1, 2, 3], fromList U [5, 6, 7 :: Int]]
--   &gt; toList $ concatWith U sep arrs
--   [1,2,3,0,0,0,5,6,7,0,0,0]
--   </pre>
concatWith :: (ConcatDict lOut lIn tIn lDst a, BulkI lSep a) => Name lDst -> Array lSep a -> Array lOut (Array lIn a) -> Array lDst a

-- | O(len result). Perform a <a>concatWith</a>, adding a newline character
--   to the end of each inner array.
unlines :: ConcatDict lOut lIn tIn lDst Char => Name lDst -> Array lOut (Array lIn Char) -> Array lDst Char

-- | O(len result) Insert a copy of the separator array between the
--   elements of the second and concatenate the result.
--   
--   <pre>
--   &gt; import Data.Repa.Array.Material
--   &gt; let sep  = fromList U [0, 0, 0]
--   &gt; let arrs = fromList B [fromList U [1, 2, 3], fromList U [5, 6, 7 :: Int]]
--   &gt; toList $ intercalate U sep arrs
--   [1,2,3,0,0,0,5,6,7]
--   </pre>
intercalate :: (ConcatDict lOut lIn tIn lDst a, BulkI lSep a) => Name lDst -> Array lSep a -> Array lOut (Array lIn a) -> Array lDst a

-- | Dictionaries needed to perform a concatenation.
type ConcatDict lOut lIn tIn lDst a = (BulkI lOut (Array lIn a), BulkI lIn a, TargetI lDst a, Unpack (Array lIn a) tIn)

-- | From a stream of values which has consecutive runs of idential values,
--   produce a stream of the lengths of these runs.
--   
--   <pre>
--   &gt; import Data.Repa.Array.Material
--   &gt; import Data.Repa.Nice
--   &gt; nice $ groups U U (fromList U "waaabllle")
--   ([(<tt>w</tt>,1),(<tt>a</tt>,3),(<tt>b</tt>,1),(<tt>l</tt>,3)],Just (<tt>e</tt>,1))
--   </pre>
groups :: (GroupsDict lElt lGrp tGrp lLen tLen n, Eq n) => Name lGrp -> Name lLen -> Array lElt n -> (Array (T2 lGrp lLen) (n, Int), Maybe (n, Int))

-- | Like <a>groups</a>, but use the given function to determine whether
--   two consecutive elements should be in the same group. Also take an
--   initial starting group and count.
--   
--   <pre>
--   &gt; import Data.Repa.Array.Material
--   &gt; import Data.Repa.Nice
--   &gt; nice $ groupsWith U U (==) (Just (<tt>w</tt>, 5)) (fromList U "waaabllle")
--   ([(<tt>w</tt>,6),(<tt>a</tt>,3),(<tt>b</tt>,1),(<tt>l</tt>,3)],Just (<tt>e</tt>,1))
--   </pre>
groupsWith :: GroupsDict lElt lGrp tGrp lLen tLen n => Name lGrp -> Name lLen -> (n -> n -> Bool) -> Maybe (n, Int) -> Array lElt n -> (Array (T2 lGrp lLen) (n, Int), Maybe (n, Int))

-- | Dictionaries need to perform a grouping.
type GroupsDict lElt lGrp tGrp lLen tLen n = (Bulk lElt n, Target lGrp n, Target lLen Int, Index lGrp ~ Index lLen, Unpack (Buffer lLen Int) tLen, Unpack (Buffer lGrp n) tGrp)

-- | Left fold of all elements in an array, sequentially.
foldl :: (Bulk l b, Index l ~ Int) => (a -> b -> a) -> a -> Array l b -> a

-- | Yield the sum of the elements of an array.
sum :: (BulkI l a, Num a) => Array l a -> a

-- | Yield the product of the elements of an array.
prod :: (BulkI l a, Num a) => Array l a -> a

-- | Yield the mean value of the elements of an array.
mean :: (BulkI l a, Fractional a) => Array l a -> a

-- | Yield the standard deviation of the elements of an array
std :: (BulkI l a, Floating a) => Array l a -> a

-- | Compute the Pearson correlation of two arrays.
--   
--   If the arrays differ in length then only the common prefix is
--   correlated.
correlate :: (BulkI l1 a, BulkI l2 a, Floating a) => Array l1 a -> Array l2 a -> a

-- | Segmented fold over vectors of segment lengths and input values.
--   
--   <ul>
--   <li>The total lengths of all segments need not match the length of the
--   input elements vector. The returned <a>Folds</a> state can be
--   inspected to determine whether all segments were completely folded, or
--   the vector of segment lengths or elements was too short relative to
--   the other.</li>
--   </ul>
--   
--   <pre>
--   &gt; import Data.Repa.Array.Material
--   &gt; import Data.Repa.Nice
--   &gt; let segs  = fromList B [("red", 3), ("green", 5)]
--   &gt; let vals  = fromList U [0..100 :: Int]
--   &gt; nice $ fst $ folds B U (+) 0 segs vals
--   [("red",3),("green",25)]
--   </pre>
folds :: FoldsDict lSeg lElt lGrp tGrp lRes tRes n a b => Name lGrp -> Name lRes -> (a -> b -> b) -> b -> Array lSeg (n, Int) -> Array lElt a -> (Array (T2 lGrp lRes) (n, b), Folds Int Int n a b)

-- | Like <a>folds</a>, but take an initial state for the first segment.
--   
--   <pre>
--   &gt; import Data.Repa.Array.Material
--   &gt; import Data.Repa.Nice
--   &gt; let state = Just ("white", 4, 100)
--   &gt; let segs  = fromList B [("red", 3), ("green", 5)]
--   &gt; let vals  = fromList U [0..100 :: Int]
--   &gt; nice $ fst $ foldsWith B U (+) 0  state segs vals
--   [("white",106),("red",15),("green",45)]
--   </pre>
foldsWith :: FoldsDict lSeg lElt lGrp tGrp lRes tRes n a b => Name lGrp -> Name lRes -> (a -> b -> b) -> b -> Maybe (n, Int, b) -> Array lSeg (n, Int) -> Array lElt a -> (Array (T2 lGrp lRes) (n, b), Folds Int Int n a b)

-- | Return state of a folds operation.
data Folds sLens sVals n a b :: * -> * -> * -> * -> * -> *
Folds :: SrictNotUnpackedsLens -> SrictNotUnpackedsVals -> SrictNotUnpacked(Option n) -> SrictNotUnpackedInt -> SrictNotUnpackedb -> Folds sLens sVals n a b

-- | State of lengths chain.
_stateLens :: Folds sLens sVals n a b -> SrictNotUnpackedsLens

-- | State of values chain.
_stateVals :: Folds sLens sVals n a b -> SrictNotUnpackedsVals

-- | If we're currently in a segment, then hold its name,
_nameSeg :: Folds sLens sVals n a b -> SrictNotUnpacked(Option n)

-- | Length of current segment.
_lenSeg :: Folds sLens sVals n a b -> SrictNotUnpackedInt

-- | Accumulated value of current segment.
_valSeg :: Folds sLens sVals n a b -> SrictNotUnpackedb

-- | Dictionaries need to perform a segmented fold.
type FoldsDict lSeg lElt lGrp tGrp lRes tRes n a b = (Bulk lSeg (n, Int), Bulk lElt a, Target lGrp n, Target lRes b, Index lGrp ~ Index lRes, Unpack (Buffer lGrp n) tGrp, Unpack (Buffer lRes b) tRes)

module Data.Repa.Nice

-- | Convert some value to a nice form.
--   
--   In particular:
--   
--   <ul>
--   <li>Nested Arrays are converted to nested lists, so that they are
--   easier to work with on the ghci console.</li>
--   <li>Lists of characters are wrapped into the <a>Str</a> data type, so
--   that they can be pretty printed differently by follow-on
--   processing.</li>
--   </ul>
--   
--   As ghci automatically pretty prints lists, using <tt>nice</tt> is more
--   fun than trying to <tt>show</tt> the raw Repa array representations.
class Nicer a where type family Nice a
nice :: Nicer a => a -> Nice a

-- | Wrapper to indicate a list of characters should be printed as a
--   string, including double quotes.
data Str
Str :: [Char] -> Str

-- | Wrapper to indicate a list of characters should be printed as a
--   string, without double quotes.
data Tok
Tok :: [Char] -> Tok
instance Nicer [a] => Nicer [[a]]
instance (Bulk l a, Nicer [a]) => Nicer [Array l a]
instance (Nicer a, Nicer b) => Nicer [a :*: b]
instance (Nicer a, Nicer b) => Nicer [(a, b)]
instance Nicer a => Nicer [Maybe a]
instance (Bulk l a, Nicer [a]) => Nicer (Array l a)
instance (Nicer a, Nicer b) => Nicer (a :*: b)
instance (Nicer a, Nicer b) => Nicer (a, b)
instance Nicer a => Nicer (Maybe a)
instance Nicer [Word64]
instance Nicer [Word32]
instance Nicer [Word16]
instance Nicer [Word8]
instance Nicer [Int64]
instance Nicer [Int32]
instance Nicer [Int16]
instance Nicer [Int8]
instance Nicer [Double]
instance Nicer [Float]
instance Nicer [Int]
instance Nicer [Char]
instance Nicer Word64
instance Nicer Word32
instance Nicer Word16
instance Nicer Word8
instance Nicer Word
instance Nicer Int64
instance Nicer Int32
instance Nicer Int16
instance Nicer Int8
instance Nicer Int
instance Nicer Double
instance Nicer Float
instance Nicer Char
instance Nicer ()
instance Show Tok
instance Show Str

module Data.Repa.Nice.Present

-- | Convert some value to a form presentable to the user.
--   
--   Like <a>show</a> but we allow the nesting structure to be preserved so
--   it can be displayed in tabular format.
class Presentable a
present :: Presentable a => a -> Present

-- | A value, wrapped up nicely.
data Present

-- | An atomic thing.
Atom :: Text -> Present

-- | Many of the same thing, to display with list brackets <tt>[.. ,
--   ..]</tt>
Many :: [Present] -> Present

-- | Some different things, to display with tuple brackets <tt>(.. ,
--   ..)</tt>
Some :: [Present] -> Present

-- | Wrapper to indicate a list of characters should be printed as a
--   string, including double quotes.
data Str
Str :: [Char] -> Str

-- | Wrapper to indicate a list of characters should be printed as a
--   string, without double quotes.
data Tok
Tok :: [Char] -> Tok

-- | Yield the nesting depth of a <a>Present</a>
depth :: Present -> Int

-- | Strip the top layer of nesting into a list.
strip1 :: Present -> Maybe [Present]

-- | Strip the top two layers of nesting into lists.
strip2 :: Present -> Maybe [[Present]]

-- | Flatten a present into text
flatten :: Present -> Text
instance [overlap ok] Eq Present
instance [overlap ok] Show Present
instance [overlap ok] (Presentable a, Presentable b, Presentable c, Presentable d, Presentable e) => Presentable (a, b, c, d, e)
instance [overlap ok] (Presentable a, Presentable b, Presentable c, Presentable d) => Presentable (a, b, c, d)
instance [overlap ok] (Presentable a, Presentable b, Presentable c) => Presentable (a, b, c)
instance [overlap ok] (Presentable a, Presentable b) => Presentable (a, b)
instance [overlap ok] Presentable a => Presentable [a]
instance [overlap ok] Presentable Tok
instance [overlap ok] Presentable Str
instance [overlap ok] Presentable Word64
instance [overlap ok] Presentable Word32
instance [overlap ok] Presentable Word16
instance [overlap ok] Presentable Word8
instance [overlap ok] Presentable Double
instance [overlap ok] Presentable Float
instance [overlap ok] Presentable Int
instance [overlap ok] Presentable Char

module Data.Repa.Nice.Tabulate

-- | Print a nested value to the console in tabular form.
--   
--   The first two layers of nesting are displayed as rows and columns.
--   Numeric data is right-justified, while the rest is left-justified.
--   
--   <pre>
--   &gt; tab [[10, 20, 302], [40, 50], [60, 7001, 80, 90 :: Int]]
--   10   20 302
--   40   50
--   60 7001  80 90
--   </pre>
--   
--   Deeper layers of nesting are preserved in the output:
--   
--   <pre>
--   &gt; tab [[[10], [20, 21]], [[30, 31], [40, 41, 41], [50 :: Int]]]
--   [10]    [20,21]   
--   [30,31] [40,41,41] [50]
--   </pre>
--   
--   By default, strings are printed as lists of characters:
--   
--   <pre>
--   &gt; tab [[("red", 10), ("green", 20), ("blue", 30)], [("grey", 40), ("white", 50 :: Int)]]
--   (['r','e','d'],10)     (['g','r','e','e','n'],20) (['b','l','u','e'],30)
--   (['g','r','e','y'],40) (['w','h','i','t','e'],50)
--   </pre>
--   
--   If you want double-quotes then wrap the strings with a <tt>Str</tt>
--   constructor:
--   
--   <pre>
--   &gt; tab [[(Str "red", 10), (Str "green", 20), (Str "blue", 30)], [(Str "grey", 40), (Str "white", 50 :: Int)]]
--   ("red",10)  ("green",20) ("blue",30)
--   ("grey",40) ("white",50)
--   </pre>
--   
--   If you don't want any quotes then wrap them with a <tt>Tok</tt>
--   constructor:
--   
--   <pre>
--   &gt; tab [[(Tok "red", 10), (Tok "green", 20), (Tok "blue", 30)], [(Tok "grey", 40), (Tok "white", 50 :: Int)]]
--   (red,10)  (green,20) (blue,30)
--   (grey,40) (white,50)
--   </pre>
tab :: Presentable a => a -> IO ()

-- | Display a nested value in tabular form.
tabulate :: Presentable a => a -> Text

-- | Wrapper to indicate a list of characters should be printed as a
--   string, including double quotes.
data Str
Str :: [Char] -> Str

-- | Wrapper to indicate a list of characters should be printed as a
--   string, without double quotes.
data Tok
Tok :: [Char] -> Tok


-- | Array IO
module Data.Repa.Array.Auto.IO

-- | Get data from a file, up to the given number of bytes.
hGetArray :: Handle -> Int -> IO (Array Word8)

-- | Get data from a file, up to the given number of bytes, also copying
--   the given data to the front of the new buffer.
hGetArrayPre :: Handle -> Int -> Array Word8 -> IO (Array Word8)

-- | Write data into a file.
hPutArray :: Handle -> Array Word8 -> IO ()

-- | Read a XSV file as a nested array. We get an array of
--   rows:fields:characters.
getArrayFromXSV :: Char -> FilePath -> IO (Array (Array (Array Char)))

-- | Read an XSV file as a nested array. We get an array of
--   rows:fields:characters.
hGetArrayFromXSV :: Char -> Handle -> IO (Array (Array (Array Char)))

-- | Write a nested array as an XSV file.
--   
--   The array contains rows:fields:characters.
putArrayAsXSV :: Char -> FilePath -> Array (Array (Array Char)) -> IO ()

-- | Write a nested array as an XSV file.
--   
--   The array contains rows:fields:characters.
hPutArrayAsXSV :: Char -> Handle -> Array (Array (Array Char)) -> IO ()

module Data.Repa.Array.Auto.Convert

-- | Try to read an <a>Int</a> from the given offset in an array.
--   
--   If the conversion succeeded then you get the value, along with the
--   index of the next character, otherwise <a>Nothing</a>.
readIntFromOffset :: Array Char -> Int -> Maybe (Int, Int)

-- | Unboxed version of <a>readIntFromOffset</a>.
--   
--   We still pay to unbox the input array, but avoid boxing the result by
--   construction.
readIntFromOffset# :: Array Char -> Int# -> (# Int#, Int#, Int# #)

-- | Convert a foreign vector of characters to a Double.
--   
--   <ul>
--   <li>The standard Haskell <a>Char</a> type is four bytes in length. If
--   you already have a vector of <a>Word8</a> then use
--   <a>readDoubleFromBytes</a> instead to avoid the conversion.</li>
--   </ul>
readDouble :: Array Char -> Double

-- | Convert a foreign vector of bytes to a Double.
readDoubleFromBytes :: Array Word8 -> Double

-- | Convert a <a>Double</a> to ASCII text packed into a foreign
--   <tt>Vector</tt>.
showDouble :: Double -> Array Char

-- | Convert a <a>Double</a> to ASCII text packed into a foreign
--   <tt>Vector</tt>.
showDoubleAsBytes :: Double -> Array Word8

-- | Like <a>showDouble</a>, but use a fixed number of digits after the
--   decimal point.
showDoubleFixed :: Int -> Double -> Array Char

-- | Like <a>showDoubleAsBytes</a>, but use a fixed number of digits after
--   the decimal point.
showDoubleFixedAsBytes :: Int -> Double -> Array Word8

module Data.Repa.Array.Auto.Unpack

-- | Pack some array elements into a foreign buffer using the given binary
--   format.
packForeign :: (Packable format, Bulk A (Value format)) => format -> Array (Value format) -> Maybe (Array Word8)

-- | Unpack an array of elements from a foreign buffer into their standard
--   in-memory representation.
--   
--   The binary format of the elements in the buffer is given by the format
--   specififier, while the in-memory representation is chosen
--   automagically based on the type of the elements.
unpackForeign :: (Packable format, Target A (Value format)) => format -> Array Word8 -> Maybe (Array (Value format))

module Data.Repa.Array.Auto

-- | Arrays of elements that are automatically layed out into some
--   efficient runtime representation.
--   
--   The implementation uses type families to chose unboxed representations
--   for all elements that can be unboxed. In particular: arrays of unboxed
--   tuples are represented as tuples of unboxed arrays, and nested arrays
--   are represented using a segment descriptor and a single single flat
--   vector containing all the elements.
type Array a = Array A a

-- | Class of elements that can be automatically organised into arrays.
type Elem a = (Bulk A a, Windowable A a)

-- | Class of elements where arrays of those elements can be constructed in
--   arbitrary order.
type Build a t = (Bulk A a, Target A a, Unpack (Buffer A a) t)

-- | O(1). Get an element from an array.
--   
--   If the provided index is outside the extent of the array then the
--   result depends on the layout.
index :: Elem a => Array a -> Int -> a

-- | O(1). Alias for <a>index</a>
(!) :: Elem a => Array a -> Int -> a

-- | O(1). Get the number of elements in an array.
length :: Elem a => Array a -> Int

-- | O(1). Take the head of an array, or <a>Nothing</a> if it's empty.
head :: Elem a => Array a -> Maybe a

-- | O(1). Take the initial elements of an array, or <a>Nothing</a> if it's
--   empty.
init :: Elem a => Array a -> Maybe (Array a)

-- | O(1). Take the tail of an array, or <a>Nothing</a> if it's empty.
tail :: Elem a => Array a -> Maybe (Array a)

-- | Convert a list to an array.
fromList :: Build a at => [a] -> Array a

-- | Convert a nested list to an array.
fromLists :: Build a at => [[a]] -> Array (Array a)

-- | Convert a triply nested list to a triply nested array.
fromListss :: Build a at => [[[a]]] -> Array (Array (Array a))

-- | Convert an array to a list.
toList :: Elem a => Array a -> [a]

-- | Convert a nested array to some lists.
toLists :: (Elem a, Elem (Array a)) => Array (Array a) -> [[a]]

-- | Convert a triply nested array to a triply nested list.
toListss :: (Elem a, Elem (Array a), Elem (Array (Array a))) => Array (Array (Array a)) -> [[[a]]]

-- | Apply a function to all the elements of a list.
map :: (Elem a, Build b bt) => (a -> b) -> Array a -> Array b

-- | Combine two arrays of the same length element-wise.
--   
--   If the arrays don't have the same length then <a>Nothing</a>.
map2 :: (Elem a, Elem b, Build c ct) => (a -> b -> c) -> Array a -> Array b -> Maybe (Array c)

-- | Apply a function to all the elements of a doubly nested array,
--   preserving the nesting structure.
--   
--   <ul>
--   <li>This function has a non-standard time complexity. As nested arrays
--   use a segment descriptor based representation, detatching and
--   reattaching the nesting structure is a constant time operation.
--   However, the array passed to the worker function will also contain any
--   elements in the array representation that are not reachable from the
--   segment descriptor. This matters if the source array was produced by a
--   function that filters the segments directly, like <a>slices</a>.</li>
--   </ul>
mapElems :: (Array a -> Array b) -> Array (Array a) -> (Array (Array b))

-- | Left fold of all elements in an array.
foldl :: Elem b => (a -> b -> a) -> a -> Array b -> a

-- | Yield the sum of the elements of an array.
sum :: (Elem a, Num a) => Array a -> a

-- | Yield the product of the elements of an array.
prod :: (Elem a, Num a) => Array a -> a

-- | Yield the mean value of the elements of an array.
mean :: (Elem a, Fractional a) => Array a -> a

-- | Yield the standard deviation of the elements of an array
std :: (Elem a, Floating a) => Array a -> a

-- | Compute the Pearson correlation of two arrays.
--   
--   If the arrays differ in length then only the common prefix is
--   correlated.
correlate :: (Elem a, Floating a) => Array a -> Array a -> a

-- | Segmented fold over vectors of segment lengths and input values.
--   
--   <ul>
--   <li>The total lengths of all segments need not match the length of the
--   input elements vector. The returned <a>Folds</a> state can be
--   inspected to determine whether all segments were completely folded, or
--   the vector of segment lengths or elements was too short relative to
--   the other.</li>
--   </ul>
folds :: (Elem a, Build n nt, Build b bt) => (a -> b -> b) -> b -> Array (n, Int) -> Array a -> (Array (n, b), Folds Int Int n a b)

-- | Like <a>folds</a>, but take an initial state for the first segment.
foldsWith :: (Elem a, Build n nt, Build b bt) => (a -> b -> b) -> b -> Maybe (n, Int, b) -> Array (n, Int) -> Array a -> (Array (n, b), Folds Int Int n a b)

-- | O(len src) Keep the elements of an array that match the given
--   predicate.
filter :: Build a at => (a -> Bool) -> Array a -> Array a

-- | O(1). Produce a nested array by taking slices from some array of
--   elements.
--   
--   <ul>
--   <li>This is a constant time operation, as the representation for
--   nested vectors just wraps the starts, lengths and elements
--   vectors.</li>
--   </ul>
slices :: Array Int -> Array Int -> Array a -> Array (Array a)

-- | For each segment of a nested vector, trim elements off the start and
--   end of the segment that match the given predicate.
trims :: Elem a => (a -> Bool) -> Array (Array a) -> Array (Array a)

-- | For each segment of a nested array, trim elements off the end of the
--   segment that match the given predicate.
trimEnds :: Elem a => (a -> Bool) -> Array (Array a) -> Array (Array a)

-- | For each segment of a nested array, trim elements off the start of the
--   segment that match the given predicate.
trimStarts :: Elem a => (a -> Bool) -> Array (Array a) -> Array (Array a)

-- | O(1). Pack a pair of arrays to an array of pairs.
zip :: (Elem a, Elem b) => Array a -> Array b -> Array (a, b)

-- | O(1). Unpack an array of pairs to a pair of arrays.
unzip :: (Elem a, Elem b) => Array (a, b) -> (Array a, Array b)

-- | O(n). Reverse the elements of a list.
--   
--   <pre>
--   &gt; toList $ reverse $ fromList [0 .. 10 :: Int]
--   [10,9,8,7,6,5,4,3,2,1,0]
--   </pre>
reverse :: Build a at => Array a -> Array a

-- | Concatenate nested arrays.
concat :: (Elem a, Build a at, Unpack (Array a) aat) => Array (Array a) -> Array a

-- | O(len result) Concatenate the outer two layers of a triply nested
--   array. (Segmented concatenation).
--   
--   <ul>
--   <li>The operation is performed entirely on the segment descriptors of
--   the array, and does not require the inner array elements to be
--   copied.</li>
--   <li>This version is faster than plain <a>concat</a> on triply nested
--   arrays.</li>
--   </ul>
concats :: Array (Array (Array a)) -> Array (Array a)

-- | O(len result) Concatenate the elements of some nested vector,
--   inserting a copy of the provided separator array between each element.
concatWith :: (Elem a, Build a at, Unpack (Array a) aat) => Array a -> Array (Array a) -> Array a

-- | O(len result) Perform a <a>concatWith</a>, adding a newline character
--   to the end of each inner array.
unlines :: Unpack (Array Char) aat => Array (Array Char) -> Array Char

-- | O(len result) Insert a copy of the separator array between the
--   elements of the second and concatenate the result.
intercalate :: (Elem a, Build a at, Unpack (Array a) aat) => Array a -> Array (Array a) -> Array a

-- | Ragged transpose of a triply nested array.
--   
--   <ul>
--   <li>This operation is performed entirely on the segment descriptors of
--   the nested arrays, and does not require the inner array elements to be
--   copied.</li>
--   </ul>
ragspose3 :: Array (Array (Array a)) -> Array (Array (Array a))

-- | Take a slice out of an array, given a starting position and length.
slice :: Elem a => Int -> Int -> Array a -> Maybe (Array a)

-- | Insert elements produced by the given function in to an array.
insert :: Build a at => (Int -> Maybe a) -> Array a -> Array a

-- | O(len src) Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: Elem a => (a -> Bool) -> Array a -> Maybe Int

-- | Merge two sorted key-value streams.
merge :: (Ord k, Elem (k, a), Elem (k, b), Build (k, c) ct) => (k -> a -> b -> c) -> (k -> a -> c) -> (k -> b -> c) -> Array (k, a) -> Array (k, b) -> Array (k, c)

-- | Like <a>merge</a>, but only produce the elements where the worker
--   functions return <a>Just</a>.
mergeMaybe :: (Ord k, Elem (k, a), Elem (k, b), Build (k, c) ct) => (k -> a -> b -> Maybe c) -> (k -> a -> Maybe c) -> (k -> b -> Maybe c) -> Array (k, a) -> Array (k, b) -> Array (k, c)

-- | Combination of <tt>fold</tt> and <a>filter</a>.
--   
--   We walk over the stream front to back, maintaining an accumulator. At
--   each point we can chose to emit an element (or not)
compact :: (Elem a, Build b bt) => (s -> a -> (Maybe b, s)) -> s -> Array a -> Array b

-- | Like <a>compact</a> but use the first value of the stream as the
--   initial state, and add the final state to the end of the output.
compactIn :: Build a at => (a -> a -> (Maybe a, a)) -> Array a -> Array a

-- | From a stream of values which has consecutive runs of idential values,
--   produce a stream of the lengths of these runs.
groups :: (Eq a, Build a at) => Array a -> (Array (a, Int), Maybe (a, Int))

-- | Like <a>groups</a>, but use the given function to determine whether
--   two consecutive elements should be in the same group. Also take an
--   initial starting group and count.
groupsWith :: Build a at => (a -> a -> Bool) -> Maybe (a, Int) -> Array a -> (Array (a, Int), Maybe (a, Int))

-- | O(len src). Given predicates which detect the start and end of a
--   segment, split an vector into the indicated segments.
segment :: (Elem a, Unbox a) => (a -> Bool) -> (a -> Bool) -> Array a -> Array (Array a)

-- | O(len src). Given a terminating value, split an vector into segments.
--   
--   The result segments do not include the terminator.
segmentOn :: (Elem a, Eq a, Unbox a) => (a -> Bool) -> Array a -> Array (Array a)

-- | O(len src). Like <a>segment</a>, but cut the source array twice.
dice :: (Elem a, Unbox a) => (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> Array a -> Array (Array (Array a))

-- | O(len src). Given field and row terminating values, split an array
--   into rows and fields.
diceSep :: (Elem a, Eq a, Unbox a) => a -> a -> Array a -> Array (Array (Array a))


-- | NOTE: This is an ALPHA version of Repa 4. The API is not yet complete
--   with respect to Repa 3. Some important functions are still missing,
--   and the docs may not be up-to-date.
--   
--   <h3>How to write fast code</h3>
--   
--   <ol>
--   <li>Add <tt>INLINE</tt> pragmas to all leaf-functions in your code,
--   expecially ones that compute numeric results. Non-inlined lazy
--   function calls can cost upwards of 50 cycles each, while each numeric
--   operator only costs one (or less). Inlining leaf functions also
--   ensures they are specialised at the appropriate numeric types.</li>
--   <li>Add bang patterns to all function arguments, and all fields of
--   your data types. In a high-performance Haskell program, the cost of
--   lazy evaluation can easily dominate the run time if not handled
--   correctly. You don't want to rely on the strictness analyser in
--   numeric code because if it does not return a perfect result then the
--   performance of your program will be awful. This is less of a problem
--   for general Haskell code, and in a different context relying on
--   strictness analysis is fine.</li>
--   <li>Compile your program with <tt>ghc -O2 -fllvm -optlo-O3</tt>. The
--   LLVM compiler produces better object code that GHC's internal native
--   code generator.</li>
--   </ol>
module Data.Repa.Array

-- | Arrays of elements that are automatically layed out into some
--   efficient runtime representation.
--   
--   The implementation uses type families to chose unboxed representations
--   for all elements that can be unboxed. In particular: arrays of unboxed
--   tuples are represented as tuples of unboxed arrays, and nested arrays
--   are represented using a segment descriptor and a single single flat
--   vector containing all the elements.
type Array a = Array A a

-- | Class of elements that can be automatically organised into arrays.
type Elem a = (Bulk A a, Windowable A a)

-- | Class of elements where arrays of those elements can be constructed in
--   arbitrary order.
type Build a t = (Bulk A a, Target A a, Unpack (Buffer A a) t)

-- | O(1). Get an element from an array.
--   
--   If the provided index is outside the extent of the array then the
--   result depends on the layout.
index :: Elem a => Array a -> Int -> a

-- | O(1). Alias for <a>index</a>
(!) :: Elem a => Array a -> Int -> a

-- | O(1). Get the number of elements in an array.
length :: Elem a => Array a -> Int

-- | O(1). Take the head of an array, or <a>Nothing</a> if it's empty.
head :: Elem a => Array a -> Maybe a

-- | O(1). Take the tail of an array, or <a>Nothing</a> if it's empty.
tail :: Elem a => Array a -> Maybe (Array a)

-- | O(1). Take the initial elements of an array, or <a>Nothing</a> if it's
--   empty.
init :: Elem a => Array a -> Maybe (Array a)

-- | Convert a list to an array.
fromList :: Build a at => [a] -> Array a

-- | Convert a nested list to an array.
fromLists :: Build a at => [[a]] -> Array (Array a)

-- | Convert a triply nested list to a triply nested array.
fromListss :: Build a at => [[[a]]] -> Array (Array (Array a))

-- | Convert an array to a list.
toList :: Elem a => Array a -> [a]

-- | Convert a nested array to some lists.
toLists :: (Elem a, Elem (Array a)) => Array (Array a) -> [[a]]

-- | Convert a triply nested array to a triply nested list.
toListss :: (Elem a, Elem (Array a), Elem (Array (Array a))) => Array (Array (Array a)) -> [[[a]]]

-- | Apply a function to all the elements of a list.
map :: (Elem a, Build b bt) => (a -> b) -> Array a -> Array b

-- | Combine two arrays of the same length element-wise.
--   
--   If the arrays don't have the same length then <a>Nothing</a>.
map2 :: (Elem a, Elem b, Build c ct) => (a -> b -> c) -> Array a -> Array b -> Maybe (Array c)

-- | Apply a function to all the elements of a doubly nested array,
--   preserving the nesting structure.
--   
--   <ul>
--   <li>This function has a non-standard time complexity. As nested arrays
--   use a segment descriptor based representation, detatching and
--   reattaching the nesting structure is a constant time operation.
--   However, the array passed to the worker function will also contain any
--   elements in the array representation that are not reachable from the
--   segment descriptor. This matters if the source array was produced by a
--   function that filters the segments directly, like <a>slices</a>.</li>
--   </ul>
mapElems :: (Array a -> Array b) -> Array (Array a) -> (Array (Array b))

-- | Left fold of all elements in an array.
foldl :: Elem b => (a -> b -> a) -> a -> Array b -> a

-- | Segmented fold over vectors of segment lengths and input values.
--   
--   <ul>
--   <li>The total lengths of all segments need not match the length of the
--   input elements vector. The returned <a>Folds</a> state can be
--   inspected to determine whether all segments were completely folded, or
--   the vector of segment lengths or elements was too short relative to
--   the other.</li>
--   </ul>
folds :: (Elem a, Build n nt, Build b bt) => (a -> b -> b) -> b -> Array (n, Int) -> Array a -> (Array (n, b), Folds Int Int n a b)

-- | Like <a>folds</a>, but take an initial state for the first segment.
foldsWith :: (Elem a, Build n nt, Build b bt) => (a -> b -> b) -> b -> Maybe (n, Int, b) -> Array (n, Int) -> Array a -> (Array (n, b), Folds Int Int n a b)

-- | Yield the sum of the elements of an array.
sum :: (Elem a, Num a) => Array a -> a

-- | Yield the product of the elements of an array.
prod :: (Elem a, Num a) => Array a -> a

-- | Yield the mean value of the elements of an array.
mean :: (Elem a, Fractional a) => Array a -> a

-- | Yield the standard deviation of the elements of an array
std :: (Elem a, Floating a) => Array a -> a

-- | Compute the Pearson correlation of two arrays.
--   
--   If the arrays differ in length then only the common prefix is
--   correlated.
correlate :: (Elem a, Floating a) => Array a -> Array a -> a

-- | O(len src) Keep the elements of an array that match the given
--   predicate.
filter :: Build a at => (a -> Bool) -> Array a -> Array a

-- | O(1). Produce a nested array by taking slices from some array of
--   elements.
--   
--   <ul>
--   <li>This is a constant time operation, as the representation for
--   nested vectors just wraps the starts, lengths and elements
--   vectors.</li>
--   </ul>
slices :: Array Int -> Array Int -> Array a -> Array (Array a)

-- | For each segment of a nested vector, trim elements off the start and
--   end of the segment that match the given predicate.
trims :: Elem a => (a -> Bool) -> Array (Array a) -> Array (Array a)

-- | For each segment of a nested array, trim elements off the end of the
--   segment that match the given predicate.
trimEnds :: Elem a => (a -> Bool) -> Array (Array a) -> Array (Array a)

-- | For each segment of a nested array, trim elements off the start of the
--   segment that match the given predicate.
trimStarts :: Elem a => (a -> Bool) -> Array (Array a) -> Array (Array a)

-- | O(1). Pack a pair of arrays to an array of pairs.
zip :: (Elem a, Elem b) => Array a -> Array b -> Array (a, b)

-- | O(1). Unpack an array of pairs to a pair of arrays.
unzip :: (Elem a, Elem b) => Array (a, b) -> (Array a, Array b)

-- | O(n). Reverse the elements of a list.
--   
--   <pre>
--   &gt; toList $ reverse $ fromList [0 .. 10 :: Int]
--   [10,9,8,7,6,5,4,3,2,1,0]
--   </pre>
reverse :: Build a at => Array a -> Array a

-- | Concatenate nested arrays.
concat :: (Elem a, Build a at, Unpack (Array a) aat) => Array (Array a) -> Array a

-- | O(len result) Concatenate the outer two layers of a triply nested
--   array. (Segmented concatenation).
--   
--   <ul>
--   <li>The operation is performed entirely on the segment descriptors of
--   the array, and does not require the inner array elements to be
--   copied.</li>
--   <li>This version is faster than plain <a>concat</a> on triply nested
--   arrays.</li>
--   </ul>
concats :: Array (Array (Array a)) -> Array (Array a)

-- | O(len result) Concatenate the elements of some nested vector,
--   inserting a copy of the provided separator array between each element.
concatWith :: (Elem a, Build a at, Unpack (Array a) aat) => Array a -> Array (Array a) -> Array a

-- | O(len result) Perform a <a>concatWith</a>, adding a newline character
--   to the end of each inner array.
unlines :: Unpack (Array Char) aat => Array (Array Char) -> Array Char

-- | O(len result) Insert a copy of the separator array between the
--   elements of the second and concatenate the result.
intercalate :: (Elem a, Build a at, Unpack (Array a) aat) => Array a -> Array (Array a) -> Array a

-- | Ragged transpose of a triply nested array.
--   
--   <ul>
--   <li>This operation is performed entirely on the segment descriptors of
--   the nested arrays, and does not require the inner array elements to be
--   copied.</li>
--   </ul>
ragspose3 :: Array (Array (Array a)) -> Array (Array (Array a))

-- | Take a slice out of an array, given a starting position and length.
slice :: Elem a => Int -> Int -> Array a -> Maybe (Array a)

-- | Insert elements produced by the given function in to an array.
insert :: Build a at => (Int -> Maybe a) -> Array a -> Array a

-- | O(len src) Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: Elem a => (a -> Bool) -> Array a -> Maybe Int

-- | Merge two sorted key-value streams.
merge :: (Ord k, Elem (k, a), Elem (k, b), Build (k, c) ct) => (k -> a -> b -> c) -> (k -> a -> c) -> (k -> b -> c) -> Array (k, a) -> Array (k, b) -> Array (k, c)

-- | Like <a>merge</a>, but only produce the elements where the worker
--   functions return <a>Just</a>.
mergeMaybe :: (Ord k, Elem (k, a), Elem (k, b), Build (k, c) ct) => (k -> a -> b -> Maybe c) -> (k -> a -> Maybe c) -> (k -> b -> Maybe c) -> Array (k, a) -> Array (k, b) -> Array (k, c)

-- | Combination of <tt>fold</tt> and <a>filter</a>.
--   
--   We walk over the stream front to back, maintaining an accumulator. At
--   each point we can chose to emit an element (or not)
compact :: (Elem a, Build b bt) => (s -> a -> (Maybe b, s)) -> s -> Array a -> Array b

-- | Like <a>compact</a> but use the first value of the stream as the
--   initial state, and add the final state to the end of the output.
compactIn :: Build a at => (a -> a -> (Maybe a, a)) -> Array a -> Array a

-- | From a stream of values which has consecutive runs of idential values,
--   produce a stream of the lengths of these runs.
groups :: (Eq a, Build a at) => Array a -> (Array (a, Int), Maybe (a, Int))

-- | Like <a>groups</a>, but use the given function to determine whether
--   two consecutive elements should be in the same group. Also take an
--   initial starting group and count.
groupsWith :: Build a at => (a -> a -> Bool) -> Maybe (a, Int) -> Array a -> (Array (a, Int), Maybe (a, Int))

-- | O(len src). Given predicates which detect the start and end of a
--   segment, split an vector into the indicated segments.
segment :: (Elem a, Unbox a) => (a -> Bool) -> (a -> Bool) -> Array a -> Array (Array a)

-- | O(len src). Given a terminating value, split an vector into segments.
--   
--   The result segments do not include the terminator.
segmentOn :: (Elem a, Eq a, Unbox a) => (a -> Bool) -> Array a -> Array (Array a)

-- | O(len src). Like <a>segment</a>, but cut the source array twice.
dice :: (Elem a, Unbox a) => (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> Array a -> Array (Array (Array a))

-- | O(len src). Given field and row terminating values, split an array
--   into rows and fields.
diceSep :: (Elem a, Eq a, Unbox a) => a -> a -> Array a -> Array (Array (Array a))

module Data.Repa.Bits.Date32

-- | A date packed into a 32-bit word.
--   
--   The bitwise format is:
--   
--   <pre>
--   32             16       8      0 
--   | year          | month | day  |
--   
--   </pre>
--   
--   Pros: Packing and unpacking a Date32 is simpler than using other
--   formats that represent dates as a number of days from some epoch. We
--   can also avoid worrying about what the epoch should be, and the
--   representation will not overflow until year 65536.
--   
--   Cons: Computing a range of dates is slower than with representations
--   using an epoch, as we cannot simply add one to get to the next valid
--   date.
data Date32

-- | Pack a year, month and day into a <a>Word32</a>.
--   
--   If any components of the date are out-of-range then they will be
--   bit-wise truncated so they fit in their destination fields.
pack :: (Word, Word, Word) -> Date32

-- | Inverse of <a>pack</a>.
--   
--   This function does a simple bit-wise unpacking of the given
--   <a>Word32</a>, and does not guarantee that the returned fields are
--   within a valid range for the given calendar date.
unpack :: Date32 -> (Word, Word, Word)

-- | Yield the next date in the series.
--   
--   This assumes leap years occur every four years, which is valid after
--   year 1900 and before year 2100.
next :: Date32 -> Date32

-- | Yield an array containing a range of dates, inclusive of the end
--   points.
range :: Date32 -> Date32 -> Array Date32

-- | Pretty print a <a>Date32</a>
pretty :: Char -> Date32 -> Array Char

-- | Read a <a>Date32</a> in ASCII YYYYsMMsDD format, using the given
--   separator character <tt>s</tt>.
readYYYYsMMsDD :: Char -> Array Char -> Maybe Date32

-- | Read a <a>Date32</a> in ASCII DDsMMsYYYY format, using the given
--   separator character <tt>s</tt>.
readDDsMMsYYYY :: Char -> Array Char -> Maybe Date32
instance Show (Array A Date32)
instance Eq Date32
instance Ord Date32
instance Show Date32
instance Unpack (Buffer F Date32) t => Unpack (Buffer A Date32) t
instance Target A Date32
instance Windowable A Date32
instance Bulk A Date32
instance Storable Date32
