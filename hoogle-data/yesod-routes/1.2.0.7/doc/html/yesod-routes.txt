-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient routing for Yesod.
--   
--   Provides an efficient routing system, a parser and TH code generation.
@package yesod-routes
@version 1.2.0.7

module Yesod.Routes.Class
class Eq (Route a) => RenderRoute a where data family Route a
renderRoute :: RenderRoute a => Route a -> ([Text], [(Text, Text)])
class RenderRoute a => ParseRoute a
parseRoute :: ParseRoute a => ([Text], [(Text, Text)]) -> Maybe (Route a)
class RenderRoute a => RouteAttrs a
routeAttrs :: RouteAttrs a => Route a -> Set Text


-- | Check for overlapping routes.
module Yesod.Routes.Overlap

-- | <i>Deprecated: This function is no longer used </i>
findOverlaps :: ([String] -> [String]) -> [ResourceTree t] -> [Overlap t]
findOverlapNames :: [ResourceTree t] -> [(String, String)]
data Overlap t
Overlap :: ([String] -> [String]) -> ResourceTree t -> ResourceTree t -> Overlap t

-- | parent resource trees
overlapParents :: Overlap t -> [String] -> [String]
overlap1 :: Overlap t -> ResourceTree t
overlap2 :: Overlap t -> ResourceTree t

module Yesod.Routes.Dispatch
data Piece
Static :: Text -> Piece
Dynamic :: Piece
data Route res
Route :: [Piece] -> Bool -> Dispatch res -> Route res
rhPieces :: Route res -> [Piece]
rhHasMulti :: Route res -> Bool
rhDispatch :: Route res -> Dispatch res
type Dispatch res = [Text] -> Maybe res
toDispatch :: [Route res] -> Dispatch res

module Yesod.Routes.TH
data Resource typ
Resource :: String -> [(CheckOverlap, Piece typ)] -> Dispatch typ -> [String] -> Resource typ
resourceName :: Resource typ -> String
resourcePieces :: Resource typ -> [(CheckOverlap, Piece typ)]
resourceDispatch :: Resource typ -> Dispatch typ
resourceAttrs :: Resource typ -> [String]
data ResourceTree typ
ResourceLeaf :: (Resource typ) -> ResourceTree typ
ResourceParent :: String -> [(CheckOverlap, Piece typ)] -> [ResourceTree typ] -> ResourceTree typ
data Piece typ
Static :: String -> Piece typ
Dynamic :: typ -> Piece typ
data Dispatch typ
Methods :: Maybe typ -> [String] -> Dispatch typ

-- | type of the multi piece at the end
methodsMulti :: Dispatch typ -> Maybe typ

-- | supported request methods
methodsMethods :: Dispatch typ -> [String]
Subsite :: typ -> String -> Dispatch typ
subsiteType :: Dispatch typ -> typ
subsiteFunc :: Dispatch typ -> String
type CheckOverlap = Bool
data FlatResource a
FlatResource :: [(String, [(CheckOverlap, Piece a)])] -> String -> [(CheckOverlap, Piece a)] -> (Dispatch a) -> FlatResource a
resourceMulti :: Resource typ -> Maybe typ
resourceTreePieces :: ResourceTree typ -> [(CheckOverlap, Piece typ)]
resourceTreeName :: ResourceTree typ -> String
flatten :: [ResourceTree a] -> [FlatResource a]

-- | Generate the <a>RenderRoute</a> instance.
--   
--   This includes both the <a>Route</a> associated type and the
--   <a>renderRoute</a> method. This function uses both <a>mkRouteCons</a>
--   and <tt>mkRenderRouteClasses</tt>.
mkRenderRouteInstance :: Type -> [ResourceTree Type] -> Q [Dec]

-- | A more general version of <a>mkRenderRouteInstance</a> which takes an
--   additional context.
mkRenderRouteInstance' :: Cxt -> Type -> [ResourceTree Type] -> Q [Dec]

-- | Generate the constructors of a route data type.
mkRouteCons :: [ResourceTree Type] -> ([Con], [Dec])

-- | Clauses for the <a>renderRoute</a> method.
mkRenderRouteClauses :: [ResourceTree Type] -> Q [Clause]
mkParseRouteInstance :: Type -> [ResourceTree a] -> Q Dec
mkRouteAttrsInstance :: Type -> [ResourceTree a] -> Q Dec

-- | This function will generate a single clause that will address all your
--   routing needs. It takes four arguments. The fourth (a list of
--   <a>Resource</a>s) is self-explanatory. We'll discuss the first three.
--   But first, let's cover the terminology.
--   
--   Dispatching involves a master type and a sub type. When you dispatch
--   to the top level type, master and sub are the same. Each time to
--   dispatch to another subsite, the sub changes. This requires two
--   changes:
--   
--   <ul>
--   <li>Getting the new sub value. This is handled via
--   <a>subsiteFunc</a>.</li>
--   <li>Figure out a way to convert sub routes to the original master
--   route. To address this, we keep a toMaster function, and each time we
--   dispatch to a new subsite, we compose it with the constructor for that
--   subsite.</li>
--   </ul>
--   
--   Dispatching acts on two different components: the request method and a
--   list of path pieces. If we cannot match the path pieces, we need to
--   return a 404 response. If the path pieces match, but the method is not
--   supported, we need to return a 405 response.
--   
--   The final result of dispatch is going to be an application type. A
--   simple example would be the WAI Application type. However, our handler
--   functions will need more input: the master/subsite, the toMaster
--   function, and the type-safe route. Therefore, we need to have another
--   type, the handler type, and a function that turns a handler into an
--   application, i.e.
--   
--   <pre>
--   runHandler :: handler sub master -&gt; master -&gt; sub -&gt; Route sub -&gt; (Route sub -&gt; Route master) -&gt; app
--   </pre>
--   
--   This is the first argument to our function. Note that this will almost
--   certainly need to be a method of a typeclass, since it will want to
--   behave differently based on the subsite.
--   
--   Note that the 404 response passed in is an application, while the 405
--   response is a handler, since the former can't be passed the type-safe
--   route.
--   
--   In the case of a subsite, we don't directly deal with a handler
--   function. Instead, we redispatch to the subsite, passing on the
--   updated sub value and toMaster function, as well as any remaining,
--   unparsed path pieces. This function looks like:
--   
--   <pre>
--   dispatcher :: master -&gt; sub -&gt; (Route sub -&gt; Route master) -&gt; app -&gt; handler sub master -&gt; Text -&gt; [Text] -&gt; app
--   </pre>
--   
--   Where the parameters mean master, sub, toMaster, 404 response, 405
--   response, request method and path pieces. This is the second argument
--   of our function.
--   
--   Finally, we need a way to decide which of the possible formats should
--   the handler send the data out. Think of each URL holding an abstract
--   object which has multiple representation (JSON, plain HTML etc). Each
--   client might have a preference on which format it wants the abstract
--   object in. For example, a javascript making a request (on behalf of a
--   browser) might prefer a JSON object over a plain HTML file where as a
--   user browsing with javascript disabled would want the page in HTML.
--   The third argument is a function that converts the abstract object to
--   the desired representation depending on the preferences sent by the
--   client.
--   
--   The typical values for the first three arguments are,
--   <tt><tt>yesodRunner</tt></tt> for the first,
--   <tt><tt>yesodDispatch</tt></tt> for the second and <tt>fmap
--   <tt>chooseRep</tt></tt>.
mkDispatchClause :: MkDispatchSettings -> [ResourceTree a] -> Q Clause
data MkDispatchSettings
MkDispatchSettings :: Q Exp -> Q Exp -> Q Exp -> Q Exp -> Q Exp -> Q Exp -> Q Exp -> (Maybe String -> String -> Q Exp) -> MkDispatchSettings
mdsRunHandler :: MkDispatchSettings -> Q Exp
mdsSubDispatcher :: MkDispatchSettings -> Q Exp
mdsGetPathInfo :: MkDispatchSettings -> Q Exp
mdsSetPathInfo :: MkDispatchSettings -> Q Exp
mdsMethod :: MkDispatchSettings -> Q Exp
mds404 :: MkDispatchSettings -> Q Exp
mds405 :: MkDispatchSettings -> Q Exp
mdsGetHandler :: MkDispatchSettings -> Maybe String -> String -> Q Exp
defaultGetHandler :: Maybe String -> String -> Q Exp

module Yesod.Routes.Parse

-- | A quasi-quoter to parse a string into a list of <a>Resource</a>s.
--   Checks for overlapping routes, failing if present; use
--   <a>parseRoutesNoCheck</a> to skip the checking. See documentation site
--   for details on syntax.
parseRoutes :: QuasiQuoter
parseRoutesFile :: FilePath -> Q Exp

-- | Same as <a>parseRoutes</a>, but performs no overlap checking.
parseRoutesNoCheck :: QuasiQuoter
parseRoutesFileNoCheck :: FilePath -> Q Exp
parseType :: String -> Type
parseTypeTree :: String -> Maybe TypeTree
data TypeTree
TTTerm :: String -> TypeTree
TTApp :: TypeTree -> TypeTree -> TypeTree
TTList :: TypeTree -> TypeTree
instance Show TypeTree
instance Eq TypeTree
