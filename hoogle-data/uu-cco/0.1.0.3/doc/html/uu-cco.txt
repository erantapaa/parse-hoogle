-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for compiler construction: core functionality
--   
@package uu-cco
@version 0.1.0.3


-- | A combinator library for pretty printing.
--   
--   Inspired by
--   
--   <ul>
--   <li>S. Doaitse Swierstra, Pablo R. Azero Alcocer, and Joao Saraiva.
--   Designing and implementing combinator languages. In S. Doaitse
--   Swierstra and Pedro Rangel Henriques, and Jose Nuno Oliveira, editors,
--   <i>Advanced Functional Programming, Third International</i> <i>School,
--   Braga, Portugal, September 12-19, 1998, Revised Lectures</i>, volume
--   1608 of <i>Lecture Notes in Computer Science</i>, pages 150-206.
--   Springer-Verlag, 1999.</li>
--   </ul>
module CCO.Printing

-- | The type of documents.
data Doc

-- | Indicates whether a document is empty.
isEmpty :: Doc -> Bool

-- | The empty document. Left and right unit of <a>&gt;-&lt;</a> and
--   <a>&gt;|&lt;</a>.
empty :: Doc

-- | <tt>text txt</tt> produces a document containing the text
--   <tt>txt</tt>.
text :: String -> Doc

-- | <tt>wrapped txt</tt> produces a document containing the text
--   <tt>txt</tt>, possibly wrapping its contents to fit the available
--   space
wrapped :: String -> Doc

-- | Indents a document by a given amount of space.
indent :: Int -> Doc -> Doc

-- | "Above": puts one document on top of another.
(>-<) :: Doc -> Doc -> Doc

-- | Stacks multiple documents: <tt>above = foldr (&gt;-&lt;) empty</tt>.
above :: [Doc] -> Doc

-- | "Besides": puts two documents next to eachother by "dovetailing" them.
(>|<) :: Doc -> Doc -> Doc

-- | Queues multiple documents: <tt>besides = foldr (&gt;|&lt;) empty</tt>.
besides :: [Doc] -> Doc

-- | "Split": introduces two alternative ("parallel") formattings.
(>//<) :: Doc -> Doc -> Doc

-- | Introduces multiple alternative formattings: <tt>split = foldr
--   (&gt;//&lt;) empty</tt>.
split :: [Doc] -> Doc

-- | Selects the most space-efficient of all alternative formattings for a
--   document.
join :: Doc -> Doc

-- | Immediate choice: <tt>l &gt;^&lt; r = join (l &gt;//&lt; r)</tt>.
(>^<) :: Doc -> Doc -> Doc

-- | Immediate choice: <tt>choose = foldr (&gt;^&lt;) empty</tt>.
choose :: [Doc] -> Doc

-- | A space character: <tt>space = text " "</tt>.
space :: Doc

-- | A full stop: <tt>period = text "."</tt>.
period :: Doc

-- | A comma: <tt>comma = text ","</tt>.
comma :: Doc

-- | A semicolon: <tt>semicolon = text ";"</tt>.
semicolon :: Doc

-- | A colon: <tt>colon = text ":"</tt>.
colon :: Doc

-- | Inserts a delimiter between all adjacent nonempty documents in a list.
sepBy :: [Doc] -> Doc -> Doc

-- | Inserts a space between two documents. If one of the documents is
--   empty, the other one is returned: <tt>l &gt;#&lt; r = [l, r] `sepBy`
--   space</tt>.
(>#<) :: Doc -> Doc -> Doc

-- | Parentheses:
--   
--   <pre>
--   lparen = text "("
--   rparen = text ")"
--   </pre>
lparen :: Doc

-- | Parentheses:
--   
--   <pre>
--   lparen = text "("
--   rparen = text ")"
--   </pre>
rparen :: Doc

-- | Square brackets:
--   
--   <pre>
--   lbracket = text "["
--   rbracket = text "]"
--   </pre>
lbracket :: Doc

-- | Square brackets:
--   
--   <pre>
--   lbracket = text "["
--   rbracket = text "]"
--   </pre>
rbracket :: Doc

-- | Curly braces:
--   
--   <pre>
--   lbrace = text "{"
--   rbrace = text "}"
--   </pre>
lbrace :: Doc

-- | Curly braces:
--   
--   <pre>
--   lbrace = text "{"
--   rbrace = text "}"
--   </pre>
rbrace :: Doc

-- | Angle brackets:
--   
--   <pre>
--   langle = text "&lt;"
--   rangle = text "&gt;"
--   </pre>
langle :: Doc

-- | Angle brackets:
--   
--   <pre>
--   langle = text "&lt;"
--   rangle = text "&gt;"
--   </pre>
rangle :: Doc

-- | Encloses a document in brackets: <tt>enclose l r d = l &gt;|&lt; d
--   &gt;|&lt; r</tt>.
enclose :: Doc -> Doc -> Doc -> Doc

-- | Encloses a document in parentheses: <tt>parens = enclose lparen
--   rparen</tt>.
parens :: Doc -> Doc

-- | Encloses a document in square brackets: <tt>brackets = enclose
--   lbracket rbracket</tt>.
brackets :: Doc -> Doc

-- | Encloses a document in curly braces: <tt>braces = enclose lbrace
--   rbrace</tt>.
braces :: Doc -> Doc

-- | Encloses a document in angle brackets: <tt>angles = enclose langle
--   rangle</tt>.
angles :: Doc -> Doc

-- | Sets the foreground colour of a document to black.
--   
--   (Note: colours are only taken into account when a document is rendered
--   by means of <a>renderIO</a> or <a>renderIO_</a>. They are ignored if
--   <a>render</a> or <a>render_</a> are used.)
black :: Doc -> Doc

-- | Sets the foreground colour of a document to red.
--   
--   (Note: colours are only taken into account when a document is rendered
--   by means of <a>renderIO</a> or <a>renderIO_</a>. They are ignored if
--   <a>render</a> or <a>render_</a> are used.)
red :: Doc -> Doc

-- | Sets the foreground colour of a document to green.
--   
--   (Note: colours are only taken into account when a document is rendered
--   by means of <a>renderIO</a> or <a>renderIO_</a>. They are ignored if
--   <a>render</a> or <a>render_</a> are used.)
green :: Doc -> Doc

-- | Sets the foreground colour of a document to blue.
--   
--   (Note: colours are only taken into account when a document is rendered
--   by means of <a>renderIO</a> or <a>renderIO_</a>. They are ignored if
--   <a>render</a> or <a>render_</a> are used.)
blue :: Doc -> Doc

-- | Sets the foreground colour of a document to yellow.
--   
--   (Note: colours are only taken into account when a document is rendered
--   by means of <a>renderIO</a> or <a>renderIO_</a>. They are ignored if
--   <a>render</a> or <a>render_</a> are used.)
yellow :: Doc -> Doc

-- | Sets the foreground colour of a document to magenta.
--   
--   (Note: colours are only taken into account when a document is rendered
--   by means of <a>renderIO</a> or <a>renderIO_</a>. They are ignored if
--   <a>render</a> or <a>render_</a> are used.)
magenta :: Doc -> Doc

-- | Sets the foreground colour of a document to cyan.
--   
--   (Note: colours are only taken into account when a document is rendered
--   by means of <a>renderIO</a> or <a>renderIO_</a>. They are ignored if
--   <a>render</a> or <a>render_</a> are used.)
cyan :: Doc -> Doc

-- | Sets the foreground colour of a document to white.
--   
--   (Note: colours are only taken into account when a document is rendered
--   by means of <a>renderIO</a> or <a>renderIO_</a>. They are ignored if
--   <a>render</a> or <a>render_</a> are used.)
white :: Doc -> Doc

-- | Tries to render a document within a specified amount of horizontal
--   space.
render :: Int -> Doc -> Maybe String

-- | Tries to render a document within a specified amount of horizontal
--   space. If the document cannot be rendered within the given amount of
--   space, the amount of space is, until the document fits, repeatedly
--   enlarged by 10 percent.
render_ :: Int -> Doc -> String

-- | Tries to render a document within a specified amount of horizontal
--   space. A resulting rendering is tupled with the number of new lines
--   claimed by the rendering.
renderHeight :: Int -> Doc -> Maybe (String, Int)
renderHeight_ :: Int -> Doc -> (String, Int)

-- | Tries to render a document within a specified amount of horizontal
--   space and to print it to the standard output channel.
renderIO :: Int -> Doc -> Maybe (IO ())

-- | Tries to render a document within a specified amount of horizontal
--   space and to print it to the standard output channel. If the document
--   cannot be rendered within the given amount of space, the amount of
--   space is, until the document fits, repeatedly enlarged by 10 percent.
renderIO_ :: Int -> Doc -> IO ()

-- | Tries to render a document within a specified amount of horizontal
--   space and to print it to the standard output channel. A resulting
--   rendering is tupled with the number of new lines claimed by the
--   rendering.
renderIOHeight :: Int -> Doc -> Maybe (IO (), Int)

-- | Tries to render a document within a specified amount of horizontal
--   space and to print it to the standard output channel. If the document
--   cannot be rendered within the given amount of space, the amount of
--   space is, until the document fits, repeatedly enlarged by 10 percent.
--   The resulting rendering is tupled with the number of new lines claimed
--   by the rendering.
renderIOHeight_ :: Int -> Doc -> (IO (), Int)

-- | The class <tt>Printable</tt>. Instances of <tt>Printable</tt> provide
--   a pretty printer for their values.
--   
--   A minimal complete definition must supply the method <tt>pp</tt>.
class Printable a
pp :: Printable a => a -> Doc

-- | Prints a <a>Show</a>able value: <tt>showable = text . show</tt>.
showable :: Show a => a -> Doc
instance Printable Double
instance Printable Float
instance Printable Integer
instance Printable Int
instance Printable Char


-- | A monad for keeping track of log, warning, and error messages.
module CCO.Feedback

-- | Type of messages. Each <tt>Message</tt> holds a pretty-printable
--   document in which the text for the message is stored.
data Message

-- | A log message at a specified verbosity level, the default level being
--   1.
Log :: Int -> Doc -> Message

-- | A warning message at a specified severity level, the default level
--   being 1.
Warning :: Int -> Doc -> Message

-- | An error message.
Error :: Doc -> Message

-- | Indicates whether a <a>Message</a> is an <a>Error</a> message.
isError :: Message -> Bool

-- | Retrieves the <a>Doc</a> stored in a <a>Message</a>.
fromMessage :: Message -> Doc

-- | The <tt>Feedback</tt> monad. Keeps track of <a>Message</a>s, failing
--   if an <a>Error</a> message is encountered.
data Feedback a

-- | Issues a <a>Log</a> message at a specified verbosity level containing
--   a specified text.
trace :: Int -> String -> Feedback ()

-- | Issues a <a>Log</a> message at the default verbosity level 1
--   containing a specified text.
trace_ :: String -> Feedback ()

-- | Issues a <a>Warning</a> message at a specified severity level
--   containing a specified text.
warn :: Int -> String -> Feedback ()

-- | Issues a <a>Warning</a> message at the default severity level 1
--   containing a specified text.
warn_ :: String -> Feedback ()

-- | Issues an <a>Error</a> message.
errorMessage :: Doc -> Feedback a

-- | Issues a <a>Message</a>. Fails if an <a>Error</a> message is issued.
message :: Message -> Feedback ()

-- | Issues a list of <a>Message</a>s. Fails if the list contains an
--   <a>Error</a> message.
messages :: [Message] -> Feedback ()

-- | Turns all <a>Warning</a> messages into <a>Error</a> messages.
wError :: Feedback a -> Feedback a

-- | Retrieves whether a <a>Feedback</a> computation will succeed.
succeeding :: Feedback a -> Bool

-- | Retrieves whether a <a>Feedback</a> computation will fail.
failing :: Feedback a -> Bool

-- | Runs a <a>Feedback</a> computation at a specified verbosity and
--   severity level, pretty printing messages onto a specified
--   <a>Handle</a>.
runFeedback :: Feedback a -> Int -> Int -> Handle -> IO (Maybe a)
instance Applicative Feedback
instance Monad Feedback
instance Functor Feedback


-- | A set of simple parsing utilities that facilitate the conversion from
--   <a>ATerm</a>s to <a>Tree</a>s.
module CCO.Tree.Parser

-- | Parser that consumes <a>ATerm</a>s and, if successful, produces a
--   value of a specified type.
data TreeParser a

-- | A <a>TreeParser</a> that consumes an <a>Integer</a> term.
integer :: TreeParser Integer

-- | A <a>TreeParser</a> that consumes a <a>Float</a> term.
float :: TreeParser Double

-- | A <a>TreeParser</a> that consumes a <a>String</a> term.
string :: TreeParser String

-- | A <a>TreeParser</a> that consumes an application of a given
--   constructor and that uses a specified <a>ArgumentParser</a> to parse
--   the argument terms of the application.
app :: Con -> ArgumentParser a -> TreeParser a

-- | A <a>TreeParser</a> that consumes a tuple term and that uses a
--   specified <a>ArgumentParser</a> to parse the component terms of the
--   tuple.
tuple :: ArgumentParser a -> TreeParser a

-- | A <a>TreeParser</a> that consumes a list term and that uses a
--   specified family of <a>TreeParser</a>s to parse the elements of the
--   list.
list :: [TreeParser a] -> TreeParser [a]

-- | Uses a family of <a>TreeParser</a>s to parse a given <a>ATerm</a>.
parseTree :: [TreeParser a] -> ATerm -> Feedback a

-- | Parser that consumes a list of <a>ATerm</a>s and, if successful,
--   produces a value of a specified type.
data ArgumentParser a

-- | An <a>ArgumentParser</a> that consumes a single <a>ATerm</a>,
--   converting it to a <a>Tree</a> of the appropriate type.
arg :: Tree a => ArgumentParser a
instance Applicative ArgumentParser
instance Functor ArgumentParser
instance Functor TreeParser


-- | Representation of source positions.
module CCO.SourcePos

-- | A description of an input stream.
data Source

-- | A file.
File :: FilePath -> Source

-- | The standard input channel.
Stdin :: Source

-- | A position.
data Pos

-- | An actual position (line number, column number).
Pos :: !Int -> !Int -> Pos

-- | End of input.
EOF :: Pos

-- | A position in an input stream.
data SourcePos

-- | Combines a <a>Source</a> and a <a>Pos</a>.
SourcePos :: Source -> Pos -> SourcePos
instance Eq Source
instance Show Source
instance Read Source
instance Eq Pos
instance Show Pos
instance Read Pos
instance Eq SourcePos
instance Show SourcePos
instance Read SourcePos
instance Tree SourcePos
instance Tree Pos
instance Tree Source


-- | A library of lexer combinators that expose their functionality through
--   an <a>Applicative</a> interface.
module CCO.Lexing

-- | Type of lexers that produce tokens of type <tt>a</tt>.
data Lexer a

-- | A <a>Lexer</a> that recognises any character that satisfies a
--   specified predicate.
satisfy :: (Char -> Bool) -> Lexer Char

-- | A <a>Lexer</a> that will produce a specified error message.
message :: String -> Lexer a

-- | The trivial <a>Lexer</a> that recognises any character.
anyChar :: Lexer Char

-- | A <a>Lexer</a> that recognises any character that appears in a given
--   list.
anyCharFrom :: [Char] -> Lexer Char

-- | A <a>Lexer</a> that recognises any character that does not appear in a
--   given list.
anyCharBut :: [Char] -> Lexer Char

-- | A <a>Lexer</a> that recognises any character that appears in a given
--   range. More efficent than <tt>\(low, up) -&gt; anyCharFrom [low ..
--   up]</tt>.
range :: (Char, Char) -> Lexer Char

-- | A <a>Lexer</a> that recognises any character that does not appear in a
--   given range.
notInRange :: (Char, Char) -> Lexer Char

-- | A <a>Lexer</a> that recognises a specified character.
char :: Char -> Lexer Char

-- | A <a>Lexer</a> that recognises a specified <a>String</a>.
string :: String -> Lexer String

-- | A <a>Lexer</a> that recognises a whitespace character
space :: Lexer Char

-- | A <a>Lexer</a> that recognises lower-case alphabetic characters.
lower :: Lexer Char

-- | A <a>Lexer</a> that recognises upper-case or title-case alphabetic
--   characters.
upper :: Lexer Char

-- | A <a>Lexer</a> that recognises alphabetic characters. Equivalent to
--   <a>alpha</a>.
letter :: Lexer Char

-- | A <a>Lexer</a> that recognises alphabetic characters. Equivalet to
--   <a>letter</a>.
alpha :: Lexer Char

-- | A <a>Lexer</a> that recognises alphabetic or numeric characters.
alphaNum :: Lexer Char

-- | A <a>Lexer</a> that recognises a digit.
digit :: Lexer Char

-- | A <a>Lexer</a> that recognises a digit and tokenises it as an
--   <a>Int</a>.
digit_ :: Lexer Int

-- | A <a>Lexer</a> that recognises a binary digit.
binDigit :: Lexer Char

-- | A <a>Lexer</a> that recognises a binary digit and tokenises it as an
--   <a>Int</a>.
binDigit_ :: Lexer Int

-- | A <a>Lexer</a> that recognises an octal digit.
octDigit :: Lexer Char

-- | A <a>Lexer</a> that recognises an octal digit and tokenises it as an
--   <a>Int</a>.
octDigit_ :: Lexer Int

-- | A 'Lexer that recognises a hexedecimal digit.
hexDigit :: Lexer Char

-- | A <a>Lexer</a> that recognises a hexadecimal digit and tokenises it as
--   an <a>Int</a>.
hexDigit_ :: Lexer Int

-- | Produces a <a>Lexer</a> that recognises the same inputs as a given
--   underlying <a>Lexer</a>, but that does not result in any tokenisation.
--   
--   The input recognised by a <a>Lexer</a> constructed with
--   <tt>ignore</tt> is simply ignored when the <a>Lexer</a> is used to
--   turn a stream of characters into a stream of <a>LexicalUnit</a>s.
--   
--   Mainly used to suppress the generation of tokens for lexemes that
--   constitute-- lexical units like comments and whitespace.
ignore :: Lexer a -> Lexer b

-- | The type of lexical units.
data LexicalUnit a

-- | A tokenised lexeme: its token, its position, the characters it
--   consists of, and its its trailing characters in the input stream.
Token :: a -> Pos -> String -> String -> LexicalUnit a

-- | An invalid lexeme: its position, the characters it consists of, and
--   its trailing characters in the input stream.
Error :: Pos -> String -> String -> LexicalUnit a

-- | An invalid lexeme, labeled by a custom error message: the message, its
--   position, the characters it consists of, and its trailing characters
--   in the input stream.
Msg :: String -> Pos -> String -> String -> LexicalUnit a

-- | The type of streams of symbols described by tokens of type <tt>a</tt>.
data Symbols a
Symbols :: Source -> [LexicalUnit a] -> Symbols a

-- | Runs a lexer on a specified input stream.
lex :: Lexer a -> Source -> String -> Symbols a

-- | Retrieves all tokens together with their source positions from a list
--   of <a>Symbols</a>.
tokens :: Symbols a -> [(SourcePos, a)]

-- | Retrieves all tokens from a list of <a>Symbols</a>.
tokens_ :: Symbols a -> [a]
instance Alternative Lexer
instance Applicative Lexer
instance Functor Lexer
instance Alternative Steps
instance Applicative Steps
instance Functor Steps


-- | A library of parser combinators that expose their functionality
--   through an <a>Applicative</a> interface.
--   
--   Based on work by Doaitse Swierstra.
module CCO.Parsing

-- | The class of types that describe input symbols.
--   
--   A minimal complete definition must supply the method
--   <tt>describe</tt>.
class Symbol s
describe :: Symbol s => s -> String -> String

-- | The type of parsers that consume symbols described by tokens of type
--   <tt>s</tt> and produces values of type <tt>a</tt>.
data Parser s a

-- | Produces a <a>Parser</a> that recognises a single symbol satisfying a
--   given predicate.
satisfy :: Symbol s => (s -> Bool) -> Parser s s

-- | A <a>Parser</a> that recognises the end of input.
eof :: Symbol s => Parser s ()

-- | A <a>Parser</a> that produces the <a>SourcePos</a> of the next lexeme
--   in the input (without consuming the associated symbol).
sourcePos :: Parser s SourcePos

-- | A <a>Parser</a> that produces the next lexeme in the input (without
--   consuming the associated symbol). Fails if the end of input has been
--   reached.
lexeme :: Parser s String

-- | Labels a <a>Parser</a> with a description of the grammar production it
--   is associated with. Used to produce more informative error messages.
(<!>) :: Parser s a -> String -> Parser s a

-- | Produces a <a>Parser</a> that may use any <a>Parser</a> from a given
--   list to parse its input.
choice :: Symbol s => [Parser s a] -> Parser s a

-- | Produces a <a>Parser</a> that tries to parse its input with a given
--   argument
opt :: Symbol s => Parser s a -> a -> Parser s a

-- | Produces a <a>Parser</a> that parses one or more elements chained by a
--   left-associative operator.
chainl :: Symbol s => Parser s (a -> a -> a) -> Parser s a -> Parser s a

-- | Produces a <a>Parser</a> that parses one or more elements chained by a
--   right-associative operator.
chainr :: Symbol s => Parser s (a -> a -> a) -> Parser s a -> Parser s a

-- | Produces a <a>Parser</a> that parses zero or more elements separated
--   by specified separator.
manySepBy :: Symbol s => Parser s b -> Parser s a -> Parser s [a]

-- | Produces a <a>Parser</a> that parses one or more elements separated by
--   specified separator.
someSepBy :: Symbol s => Parser s b -> Parser s a -> Parser s [a]

-- | Uses a specified <a>Parser</a> to try and parse <a>Symbols</a>.
--   Produces,if successful, a result and any remaining <a>Symbols</a>.
parse :: Parser s a -> Symbols s -> Feedback (a, Symbols s)

-- | Uses a specified <a>Lexer</a> and <a>Parser</a> to perform syntactic
--   analysis on an input stream.
parse_ :: Lexer s -> Parser s a -> Source -> String -> Feedback a
instance Printable Diagnosis
instance Symbol s => Alternative (Parser s)
instance Applicative (Parser s)
instance Functor (Parser s)
instance Symbol Char


-- | An arrow for constructing and composing compiler components.
module CCO.Component

-- | The <tt>Component</tt> arrow. A <tt>Component a b</tt> takes input of
--   type <tt>a</tt> to output of type <tt>b</tt>.
data Component a b

-- | Creates a <a>Component</a> from a <a>Feedback</a> computation.
component :: (a -> Feedback b) -> Component a b

-- | Creates a <a>Component</a> from a <a>Lexer</a> and a <a>Parser</a>.
parser :: Lexer s -> Parser s a -> Component String a

-- | A <a>Component</a> for rendering <a>Printable</a>s.
printer :: Printable a => Component a String

-- | Wraps a <a>Component</a> into a program that provides it with input
--   from the standard input channel and relays its output to the standard
--   output channel.
ioWrap :: Component String String -> IO ()
instance ArrowChoice Component
instance Arrow Component
instance Category Component


-- | A straightforward implementation of the ATerm format for exchanging
--   tree-structured data; see
--   
--   <ul>
--   <li>Mark van den Brand, Hayco de Jong, Paul Klint, and Pieter A.
--   Olivier. Efficient annotated terms. <i>Software - Practice and
--   Experience (SPE)</i>, 30(3):259-291, 2000.</li>
--   </ul>
module CCO.Tree

-- | Terms.
data ATerm

-- | Integer literal.
Integer :: Integer -> ATerm

-- | Floating-point literal.
Float :: Double -> ATerm

-- | Textual literal.
String :: String -> ATerm

-- | Constructor application.
App :: Con -> [ATerm] -> ATerm

-- | Tuple of terms.
Tuple :: [ATerm] -> ATerm

-- | List of terms.
List :: [ATerm] -> ATerm

-- | Annotated term.
Ann :: ATerm -> [ATerm] -> ATerm

-- | Node constructors.
type Con = String

-- | The <a>Tree</a> class. Instances provide conversions between
--   tree-structured data and the <a>ATerm</a> format.
--   
--   A minimal complete defintion must supply the methods <tt>fromTree</tt>
--   and <tt>toTree</tt>.
class Tree a where fromTrees xs = List [fromTree x | x <- xs] toTrees (Ann aterm _) = toTrees aterm toTrees aterm = do { validate aterm [ListTerm]; let List aterms = aterm; mapM toTree aterms }
fromTree :: Tree a => a -> ATerm
toTree :: Tree a => ATerm -> Feedback a

-- | A <a>Component</a> for parsing <a>ATerm</a>s.
parser :: Component String ATerm
