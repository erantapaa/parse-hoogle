-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A mirror implementation of chp that generates a specification of the program
--   
--   This library mirrors the API of much of the CHP library, but instead
--   of executing the program properly, using this library will generate
--   the CSP specification of your program. See this article for details
--   and caveats:
--   <a>http://chplib.wordpress.com/2010/05/03/new-chp-spec-library-released/</a>
@package chp-spec
@version 1.0.0


-- | This module is a near-copy of the Test.LazySmallCheck module from the
--   lazysmallcheck package on Hackage. It was written by Matthew Naylor
--   and Fredrik Lindblad. I have modified it to add the <a>fuzz</a>
--   function that is used by chp-spec internally, but to write that
--   function I needed access to more internals than the original
--   Test.LazySmallCheck exposed, hence I had to make a copy of the module.
--   Unfortunately, this means that the Serial type-class here is a
--   different type-class (despite being identical in behaviour and API)
--   from the original lazysmallcheck package. The modified module is
--   exposed in case you need to supply any of your own instances for
--   <a>Serial</a>. For more explanation of how Lazy SmallCheck is used in
--   this library for modelling IO actions, see this blog post:
--   <a>http://chplib.wordpress.com/2010/04/20/automatic-model-generation-part-3-choice-and-io/</a>
module Control.Concurrent.CHPSpec.LazySmallCheck
class Serial a
series :: Serial a => Series a
type Series a = Int -> Cons a
data Cons a
cons :: a -> Series a
(><) :: Series (a -> b) -> Series a -> Series b
(\/) :: Series a -> Series a -> Series a
drawnFrom :: [a] -> Cons a
cons0 :: a -> Series a
cons1 :: Serial a => (a -> b) -> Series b
cons2 :: (Serial a, Serial b) => (a -> b -> c) -> Series c
cons3 :: (Serial a, Serial b, Serial c) => (a -> b -> c -> d) -> Series d
cons4 :: (Serial a, Serial b, Serial c, Serial d) => (a -> b -> c -> d -> e) -> Series e
cons5 :: (Serial a, Serial b, Serial c, Serial d, Serial e) => (a -> b -> c -> d -> e -> f) -> Series f
fuzz :: Serial a => (a -> StateT s IO b) -> StateT s IO ([b], Bool)
instance Serial Double
instance Serial Float
instance Serial Char
instance Serial Integer
instance Serial Int
instance (Serial a, Serial b, Serial c, Serial d, Serial e) => Serial (a, b, c, d, e)
instance (Serial a, Serial b, Serial c, Serial d) => Serial (a, b, c, d)
instance (Serial a, Serial b, Serial c) => Serial (a, b, c)
instance (Serial a, Serial b) => Serial (a, b)
instance Serial a => Serial [a]
instance (Serial a, Serial b) => Serial (Either a b)
instance Serial a => Serial (Maybe a)
instance Serial Bool
instance Serial ()


-- | A module for running items in parallel. See
--   <a>http://chplib.wordpress.com/2010/04/13/automatic-model-generation-part-1-parallel/</a>
--   for details of how parallel items are modelled.
--   
--   Parallel specifications are well supported, and the only change to
--   this module from normal CHP is that forking is not currently
--   supported.
module Control.Concurrent.CHPSpec.Parallel
runParallel :: [CHP a] -> CHP [a]
runParallel_ :: [CHP a] -> CHP ()
(<||>) :: CHP a -> CHP b -> CHP (a, b)
(<|*|>) :: CHP a -> CHP b -> CHP ()
runParMapM :: (a -> CHP b) -> [a] -> CHP [b]
runParMapM_ :: (a -> CHP b) -> [a] -> CHP ()


-- | A module with support for things that are enrollable.
--   
--   Enrollment is currently pretty much ignored during model generation,
--   but these operations are provided so that you don't have to change
--   your program.
module Control.Concurrent.CHPSpec.Enroll
data Enrolled b a
class Enrollable b z
enroll :: Enrollable b z => b z -> (Enrolled b z -> CHP a) -> CHP a
resign :: Enrollable b z => Enrolled b z -> CHP a -> CHP a
furtherEnroll :: Enrollable b z => Enrolled b z -> (Enrolled b z -> CHP a) -> CHP a
enrollPair :: (Enrollable b p, Enrollable b' p') => (b p, b' p') -> ((Enrolled b p, Enrolled b' p') -> CHP a) -> CHP a
enrollList :: Enrollable b p => [b p] -> ([Enrolled b p] -> CHP a) -> CHP a
enrollAll :: Enrollable b p => CHP (b p) -> [Enrolled b p -> CHP a] -> CHP [a]
enrollAll_ :: Enrollable b p => CHP (b p) -> [Enrolled b p -> CHP a] -> CHP ()
enrollAllT :: Enrollable b p => ([a] -> CHP c) -> CHP (b p) -> [Enrolled b p -> a] -> CHP c
enrollOneMany :: Enrollable b p => ([Enrolled b p] -> CHP a) -> [(CHP (b p), Enrolled b p -> CHP c)] -> CHP (a, [c])


-- | This module contains all the central monads in the CHP library.
module Control.Concurrent.CHPSpec.Monad

-- | The central monad of the library. You can use the <tt>specify</tt>
--   function to model programs written with this monad.
type CHP = CHPSpecT (StateT CHPState IO)
class Monad m => MonadCHP m
liftCHP :: MonadCHP m => CHP a -> m a

-- | Like <tt>liftIO_CHP'</tt>, but with an empty label.
liftIO_CHP :: Serial a => IO a -> CHP a

-- | Models the lifting of an IO action into the CHP monad.
--   
--   The IO computation itself is completely ignored. The label (first
--   parameter) is used to label various different dummy events, which
--   arise from exploring the return type of the IO computation. To support
--   this exploration, the return type must be an instance of
--   <a>Serial</a>.
--   
--   More details and a full explanation of how IO events are modelled are
--   available in this blog post:
--   <a>http://chplib.wordpress.com/2010/04/20/automatic-model-generation-part-3-choice-and-io/</a>
liftIO_CHP' :: Serial a => String -> IO a -> CHP a

-- | Models processes that run forever.
--   
--   Anything following a <a>foreverP</a> call in sequence will not be
--   modelled.
foreverP :: CHP a -> CHP b

-- | The top-level function in this library, to be used in place of runCHP
--   in your program. You pass it a boolean (True if you want to leave the
--   dummy IO events exposed, False if you want them hidden) and a CHP
--   process that you want to specify. The result is a String containing a
--   CSP-M specification that can be written out to a file and read in to
--   other tools, such as FDR, PRoBE and others.
specify :: Bool -> CHP () -> IO String

-- | A class with instances for CHP processes of the form <tt>a -&gt; b
--   -&gt; .. -&gt; CHP r</tt>.
--   
--   The return value of the process must support <a>Typeable</a>, and the
--   arguments of the process must support <a>Typeable</a> and <a>Eq</a>.
class Process p

-- | An annotation to put around a top-level process. This annotation must
--   be inside the recursive knot. You can either place it as:
--   
--   <pre>
--   foo :: Int -&gt; String -&gt; CHP ()
--   foo = process "foo" $ \n s -&gt; ...
--   </pre>
--   
--   Or as follows:
--   
--   <pre>
--   foo :: Int -&gt; String -&gt; CHP ()
--   foo = process "foo" foo'
--     where
--       foo' n s = ...
--   </pre>
--   
--   The annotation must capture all the parameters to the process. What
--   you must <i>not</i> do is place it such that there are free parameters
--   not captured, for example this is <i>wrong</i>:
--   
--   <pre>
--   foo :: Int -&gt; String -&gt; CHP ()
--   foo n s = process "foo" foo'
--     where
--       foo' = ...
--   </pre>
--   
--   If you do want to have recursive processes that have outer parameters
--   and not pass them, you must wrap the outer process in <a>process</a>
--   and the inner process(es) in <a>subProcess</a>.
process :: Process p => String -> p -> p
subProcess :: Process p => String -> p -> p

-- | Allows you to provide a handler for sections with poison. Since poison
--   is not currently modelled, this acts like <a>const</a> at the moment.
onPoisonTrap :: CHP a -> CHP a -> CHP a

-- | Like <a>onPoisonTrap</a>, this function allows you to provide a
--   handler for poison. Since poison is not currently modelled, this acts
--   like <a>const</a> at the moment.
onPoisonRethrow :: CHP a -> CHP () -> CHP a

-- | Throws a poison exception. Poison is not currently modelled.
throwPoison :: CHP a
class Poisonable c
poison :: (Poisonable c, MonadCHP m) => c -> m ()
checkForPoison :: (Poisonable c, MonadCHP m) => c -> m ()
poisonAll :: (Poisonable c, MonadCHP m) => [c] -> m ()
skip :: CHP ()
stop :: CHP a

module Control.Concurrent.CHPSpec.Channels.Creation
data Chan r w a
class Channel r w
newChannel' :: (Channel r w, MonadCHP m) => ChanOpts a -> m (Chan r w a)
sameChannel :: Channel r w => r a -> w a -> Bool
newChannel :: (MonadCHP m, Channel r w) => m (Chan r w a)

-- | Options for channel creation. The first two will be ignored, but the
--   label (if present) will be used to label the channel in the
--   specification.
data ChanOpts a
ChanOpts :: Int -> (a -> String) -> Maybe String -> ChanOpts a
chanOptsPriority :: ChanOpts a -> Int
chanOptsShow :: ChanOpts a -> a -> String
chanOptsLabel :: ChanOpts a -> Maybe String
defaultChanOpts :: ChanOpts a
chanLabel :: Show a => String -> ChanOpts a
newChannelWR :: (Channel r w, MonadCHP m) => m (w a, r a)
newChannelRW :: (Channel r w, MonadCHP m) => m (r a, w a)
newChannelList :: (Channel r w, MonadCHP m) => Int -> m [Chan r w a]
newChannelListWithLabels :: (Channel r w, MonadCHP m) => [String] -> m [Chan r w a]
newChannelListWithStem :: (Channel r w, MonadCHP m) => Int -> String -> m [Chan r w a]

-- | Labels a channel in the traces. It is easiest to do this at creation.
--   The effect of re-labelling channels after their first use is
--   undefined.
--   
--   This function does work as expected in chp-spec.
labelChannel :: MonadCHP m => Chan r w a -> String -> m ()
instance Channel (Shared Chanin) (Shared Chanout)
instance Channel Chanin (Shared Chanout)
instance Channel (Shared Chanin) Chanout
instance Channel Chanin Chanout

module Control.Concurrent.CHPSpec.Channels.Ends
data Chanin a
data Chanout a
data Shared c a
reader :: Chan r w a -> r a
writer :: Chan r w a -> w a
readers :: [Chan r w a] -> [r a]
writers :: [Chan r w a] -> [w a]
claim :: Shared c a -> (c a -> CHP b) -> CHP b

module Control.Concurrent.CHPSpec.Channels.Synonyms
type OneToOneChannel = Chan Chanin Chanout
oneToOneChannel :: MonadCHP m => m (OneToOneChannel a)
oneToOneChannel' :: MonadCHP m => ChanOpts a -> m (OneToOneChannel a)
type OneToAnyChannel = Chan (Shared Chanin) (Chanout)
oneToAnyChannel :: MonadCHP m => m (OneToAnyChannel a)
oneToAnyChannel' :: MonadCHP m => ChanOpts a -> m (OneToAnyChannel a)
type AnyToOneChannel = Chan (Chanin) (Shared Chanout)
anyToOneChannel :: MonadCHP m => m (AnyToOneChannel a)
anyToOneChannel' :: MonadCHP m => ChanOpts a -> m (AnyToOneChannel a)
type AnyToAnyChannel = Chan (Shared Chanin) (Shared Chanout)
anyToAnyChannel :: MonadCHP m => m (AnyToAnyChannel a)
anyToAnyChannel' :: MonadCHP m => ChanOpts a -> m (AnyToAnyChannel a)

module Control.Concurrent.CHPSpec.Channels.Communication
class ReadableChannel chanEnd
readChannel :: ReadableChannel chanEnd => chanEnd a -> CHP a
extReadChannel :: ReadableChannel chanEnd => chanEnd a -> (a -> CHP b) -> CHP b
class WriteableChannel chanEnd
writeChannel :: WriteableChannel chanEnd => chanEnd a -> a -> CHP ()
extWriteChannel :: WriteableChannel chanEnd => chanEnd a -> CHP a -> CHP ()
extWriteChannel' :: WriteableChannel chanEnd => chanEnd a -> CHP (a, b) -> CHP b
writeValue :: WriteableChannel chanEnd => a -> chanEnd a -> CHP ()

-- | This function strictly evaluates its second argument and then behaves
--   like <a>writeChannel</a>.
writeChannelStrict :: (NFData a, WriteableChannel chanEnd) => chanEnd a -> a -> CHP ()
instance WriteableChannel Chanout
instance ReadableChannel Chanin


-- | The module containing all the different types of channels in CHP.
--   
--   See
--   <a>http://chplib.wordpress.com/2010/04/22/automatic-model-generation-part-4-communication/</a>
--   for details of modelling communication.
module Control.Concurrent.CHPSpec.Channels


-- | A module containing barriers.
--   
--   The <a>PhasedBarrier</a> type remains, but currently
--   <a>syncBarrier</a> has been changed so that it only works on
--   <a>Barrier</a>, i.e. <tt>PhasedBarrier ()</tt>. This is because phases
--   haven't been modelled yet.
module Control.Concurrent.CHPSpec.Barriers
type Barrier = PhasedBarrier ()
type EnrolledBarrier = Enrolled PhasedBarrier ()
newBarrier :: CHP Barrier
newBarrierPri :: Int -> CHP Barrier
newBarrierWithLabel :: String -> CHP Barrier
data PhasedBarrier phase
newPhasedBarrier :: (Enum phase, Bounded phase, Eq phase, Show phase) => phase -> CHP (PhasedBarrier phase)
newPhasedBarrier' :: phase -> BarOpts phase -> CHP (PhasedBarrier phase)
data BarOpts phase
BarOpts :: (phase -> phase) -> Int -> (phase -> String) -> Maybe String -> BarOpts phase
barIncPhase :: BarOpts phase -> phase -> phase
barPriority :: BarOpts phase -> Int
barOptsShow :: BarOpts phase -> phase -> String
barOptsLabel :: BarOpts phase -> Maybe String
defaultIncPhase :: (Enum phase, Bounded phase, Eq phase) => phase -> phase
defaultBarOpts :: (Enum phase, Bounded phase, Eq phase) => BarOpts phase
barLabel :: (Enum phase, Bounded phase, Eq phase, Show phase) => String -> BarOpts phase

-- | Unlike normal CHP, this function only works on barriers with the unit
--   type for a phase.
syncBarrier :: EnrolledBarrier -> CHP ()


-- | A module containing the choice constructs. See
--   <a>http://chplib.wordpress.com/2010/04/20/automatic-model-generation-part-3-choice-and-io/</a>
--   for details of how choice is modelled.
--   
--   Currently conjunction is not modelled (mainly because CSP/FDR don't
--   support it), but external choice is modelled fine; <a>priAlt</a> is
--   modelled as a plain <a>alt</a>, though.
module Control.Concurrent.CHPSpec.Alt
alt :: [CHP a] -> CHP a
(<->) :: CHP a -> CHP a -> CHP a
priAlt :: [CHP a] -> CHP a
(</>) :: CHP a -> CHP a -> CHP a


-- | This module re-exports all of the functionality of the chp-spec
--   library, except the <a>Control.Concurrent.CHPSpec.LazySmallCheck</a>
--   module.
--   
--   The documentation for this library may seem relatively spartan; only
--   the functions and modules with significant differences/caveats from
--   CHP API are documented. All the details of how each aspect is modelled
--   is available in the original series of blog posts.
module Control.Concurrent.CHPSpec
