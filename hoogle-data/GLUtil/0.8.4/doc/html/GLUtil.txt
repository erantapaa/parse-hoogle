-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Miscellaneous OpenGL utilities.
--   
@package GLUtil
@version 0.8.4


-- | A <a>Camera</a> represents a coordinate frame into which 3D points may
--   be transformed. For rendering purposes, it is often helpful to combine
--   a transformation matrix computed from a <a>Camera</a> by
--   <a>camMatrix</a> -- that transforms points into the camera's
--   coordinate frame -- with a perspective projection matrix, as created
--   by <a>projectionMatrix</a>.
module Graphics.GLUtil.Camera3D

-- | A <a>Camera</a> may be translated and rotated to provide a coordinate
--   frame into which 3D points may be transformed.
data Camera a
Camera :: V3 a -> V3 a -> V3 a -> Quaternion a -> V3 a -> Camera a
forward :: Camera a -> V3 a
upward :: Camera a -> V3 a
rightward :: Camera a -> V3 a
orientation :: Camera a -> Quaternion a
location :: Camera a -> V3 a

-- | Pan a camera view (turn side-to-side) by an angle given in radians.
--   Panning is about the world's up-axis as captured by the initial camera
--   state (e.g. the positive Y axis for <a>fpsCamera</a>).
panRad :: (Epsilon a, RealFloat a) => a -> Camera a -> Camera a

-- | Pan a camera view (turn side-to-side) by an angle given in degrees.
--   Panning is about the world's up-axis as captured by the initial camera
--   state (e.g. the positive Y axis for <a>fpsCamera</a>).
pan :: (Epsilon a, RealFloat a) => a -> Camera a -> Camera a

-- | Tilt a camera view (up-and-down) by an angle given in radians. Tilting
--   is about the camera's horizontal axis (e.g. the positive X axis for
--   <a>fpsCamera</a>).
tiltRad :: (Epsilon a, RealFloat a) => a -> Camera a -> Camera a

-- | Tilt a camera view (up-and-down) by an angle given in degrees. Tilting
--   is about the camera's horizontal axis (e.g. the positive X axis for
--   <a>fpsCamera</a>).
tilt :: (Epsilon a, RealFloat a) => a -> Camera a -> Camera a

-- | Roll a camera view about its view direction by an angle given in
--   radians. Rolling is about the camera's forward axis (e.g. the negative
--   Z axis for <a>fpsCamera</a>).
rollRad :: (Epsilon a, RealFloat a) => a -> Camera a -> Camera a

-- | Roll a camera view about its view direction by an angle given in
--   degrees. Rolling is about the camera's forward axis (e.g. the negative
--   Z axis for <a>fpsCamera</a>).
roll :: (Epsilon a, RealFloat a) => a -> Camera a -> Camera a

-- | Translate a camera's position by the given vector.
dolly :: (Conjugate a, Epsilon a, RealFloat a) => V3 a -> Camera a -> Camera a

-- | A camera at the origin with its up-axis coincident with the positive Z
--   axis. This is the convention used by the ROS robotics platform.
rosCamera :: (Epsilon a, RealFloat a) => Camera a

-- | A camera at the origin with its up-axis coincident with the positive Y
--   axis. This is the convention used by "first-person shooter" (fps)
--   video games.
fpsCamera :: (Epsilon a, RealFloat a) => Camera a

-- | <tt>projectionMatrix fov aspect near far</tt> produces a perspective
--   projection matrix with the specified vertical field of view (FOV),
--   given in radians, aspect ratio, and near and far clipping planes.
projectionMatrix :: (Conjugate a, Epsilon a, RealFloat a) => a -> a -> a -> a -> M44 a

-- | <tt>orthoMatrix left right top bottom near far</tt> produces a
--   parallel projection matrix with the specified left, right, top,
--   bottom, near and far clipping planes.
orthoMatrix :: (Num a, Fractional a) => a -> a -> a -> a -> a -> a -> M44 a

-- | Produce a transformation matrix from a <a>Camera</a>. This matrix
--   transforms homogenous points into the camera's coordinate frame.
camMatrix :: (Conjugate a, Epsilon a, RealFloat a) => Camera a -> M44 a

-- | Convert degrees to radians.
deg2rad :: RealFloat a => a -> a


-- | A camera designed for 2D viewing. The camera may be translated
--   perpendicular to its view direction, or rolled about its view
--   direction.
module Graphics.GLUtil.Camera2D

-- | A <a>Camera</a> may be translated and rotated to provide a coordinate
--   frame into which 3D points may be transformed.
data Camera a
Camera :: V3 a -> V3 a -> V3 a -> Quaternion a -> V3 a -> Camera a
forward :: Camera a -> V3 a
upward :: Camera a -> V3 a
rightward :: Camera a -> V3 a
orientation :: Camera a -> Quaternion a
location :: Camera a -> V3 a

-- | Move the camera side-to-side or up-and-down as in a tracking shot.
track :: (Conjugate a, Epsilon a, RealFloat a) => V2 a -> Camera a -> Camera a

-- | Roll a camera view about its view direction by an angle given in
--   degrees.
roll :: (Epsilon a, RealFloat a) => a -> Camera a -> Camera a

-- | Roll a camera view about its view direction by an angle given in
--   radians.
rollRad :: (Epsilon a, RealFloat a) => a -> Camera a -> Camera a

-- | Initialize a camera for 2D rendering.
camera2D :: (Epsilon a, RealFloat a) => Camera a

-- | Produce a matrix that transforms homogenous 2D points into the
--   camera's coordinate frame.
camMatrix :: (Conjugate a, Epsilon a, RealFloat a) => Camera a -> M33 a

-- | Convert degrees to radians.
deg2rad :: RealFloat a => a -> a


-- | Helpers for working with OpenGL viewports.
module Graphics.GLUtil.Viewport

-- | <tt>withViewport pos sz m</tt> runs the action <tt>m</tt> after
--   setting the viewport with the given <a>Position</a> and <a>Size</a>.
--   The viewport is reset to its original state after the action is run,
--   and the result of the action is returned.
withViewport :: MonadIO m => Position -> Size -> m a -> m a


-- | Support for writing <a>Linear</a> types to uniform locations in shader
--   programs.
module Graphics.GLUtil.Linear

-- | A type class for things we can write to uniform locations in shader
--   programs. We can provide instances of this class for types from
--   <a>Linear</a> without introducing orphan instances.
class AsUniform t where asUniform x loc = uniform loc $= x
asUniform :: AsUniform t => t -> UniformLocation -> IO ()
instance AsUniform [V4 GLfloat]
instance AsUniform [V4 GLuint]
instance AsUniform [V4 GLint]
instance AsUniform [V3 GLfloat]
instance AsUniform [V3 GLuint]
instance AsUniform [V3 GLint]
instance AsUniform [V2 GLfloat]
instance AsUniform [V2 GLuint]
instance AsUniform [V2 GLint]
instance AsUniform [V1 GLfloat]
instance AsUniform [V1 GLuint]
instance AsUniform [V1 GLint]
instance AsUniform (M44 GLfloat)
instance AsUniform (M33 GLfloat)
instance AsUniform (M22 GLfloat)
instance AsUniform (V4 GLfloat)
instance AsUniform (V4 GLuint)
instance AsUniform (V4 GLint)
instance AsUniform (V3 GLfloat)
instance AsUniform (V3 GLuint)
instance AsUniform (V3 GLint)
instance AsUniform (V2 GLfloat)
instance AsUniform (V2 GLuint)
instance AsUniform (V2 GLint)
instance AsUniform (V1 GLfloat)
instance AsUniform (V1 GLuint)
instance AsUniform (V1 GLint)
instance UniformComponent a => AsUniform (Vertex2 a)
instance UniformComponent a => AsUniform (Vertex3 a)
instance UniformComponent a => AsUniform (Vertex4 a)
instance UniformComponent a => AsUniform (TexCoord1 a)
instance UniformComponent a => AsUniform (TexCoord2 a)
instance UniformComponent a => AsUniform (TexCoord3 a)
instance UniformComponent a => AsUniform (TexCoord4 a)
instance UniformComponent a => AsUniform (Normal3 a)
instance UniformComponent a => AsUniform (FogCoord1 a)
instance UniformComponent a => AsUniform (Color3 a)
instance UniformComponent a => AsUniform (Color4 a)
instance UniformComponent a => AsUniform (Index1 a)
instance AsUniform TextureUnit
instance AsUniform GLfloat
instance AsUniform GLuint
instance AsUniform GLint


-- | This module contains classes and functions to relate Haskell types
--   with OpenGL DataTypes (typically used to describe the values stored in
--   arrays) and VariableTypes (used as attributes and uniforms in GLSL
--   programs).
module Graphics.GLUtil.TypeMapping

-- | A mapping from Haskell types to values of <a>VariableType</a>. This
--   defines how Haskell values may be mapped to values that may be bound
--   to GLSL variables.
class HasVariableType a
variableType :: HasVariableType a => a -> VariableType

-- | Maps each <a>VariableType</a> to its corresponding <a>DataType</a>.
--   Typically this indicates the element type of composite variable types
--   (e.g. <tt>variableDataType FloatVec2 = Float</tt>). Note that this is
--   a partial mapping as we are primarily supporting the use of these
--   types as inputs to GLSL programs where types such as Bool are not
--   supported.
variableDataType :: VariableType -> DataType

-- | Open mapping from Haskell types to OpenGL types.
class Storable a => HasGLType a
glType :: HasGLType a => a -> DataType
instance HasGLType GLfloat
instance HasGLType Float
instance HasGLType GLuint
instance HasGLType Word32
instance HasGLType Word16
instance HasGLType Word8
instance HasGLType GLint
instance HasVariableType t => HasVariableType [t]
instance HasVariableType (M44 GLfloat)
instance HasVariableType (M33 GLfloat)
instance HasVariableType (M22 GLfloat)
instance HasVariableType (V4 GLuint)
instance HasVariableType (V3 GLuint)
instance HasVariableType (V2 GLuint)
instance HasVariableType (V1 GLuint)
instance HasVariableType (V4 Word32)
instance HasVariableType (V3 Word32)
instance HasVariableType (V2 Word32)
instance HasVariableType (V1 Word32)
instance HasVariableType (V4 Int32)
instance HasVariableType (V3 Int32)
instance HasVariableType (V2 Int32)
instance HasVariableType (V1 Int32)
instance HasVariableType (V4 GLint)
instance HasVariableType (V3 GLint)
instance HasVariableType (V2 GLint)
instance HasVariableType (V1 GLint)
instance HasVariableType (V4 GLfloat)
instance HasVariableType (V3 GLfloat)
instance HasVariableType (V2 GLfloat)
instance HasVariableType (V1 GLfloat)
instance HasVariableType GLuint
instance HasVariableType Word32
instance HasVariableType Int32
instance HasVariableType GLint
instance HasVariableType GLfloat
instance HasVariableType Float


-- | A thin layer over OpenGL 3.1+ vertex array objects.
module Graphics.GLUtil.VertexArrayObjects

-- | Allocate a <a>VertexArrayObject</a>, and initialize it with the
--   provided action. This action should bind the buffer data, index data
--   (if necessary), and setup vertex attributes.
makeVAO :: IO () -> IO VertexArrayObject

-- | Run an action with the given <a>VertexArrayObject</a> bound.
withVAO :: VertexArrayObject -> IO r -> IO r

-- | Delete a <a>VertexArrayObject</a>.
deleteVAO :: VertexArrayObject -> IO ()

-- | Delete a list of <a>VertexArrayObject</a>s.
deleteVAOs :: [VertexArrayObject] -> IO ()

-- | Short alias for <a>VertexArrayObject</a>.
type VAO = VertexArrayObject


-- | Miscellaneous utilities for dealing with OpenGL errors.
module Graphics.GLUtil.GLError

-- | Check OpenGL error flags and print them on <a>stderr</a>.
printError :: IO ()

-- | Check OpenGL error flags and print them on <a>stderr</a> with the
--   given message as a prefix. If there are no errors, nothing is printed.
printErrorMsg :: String -> IO ()

-- | Throw an exception if there is an OpenGL error.
throwError :: IO ()

-- | An exception type for OpenGL errors.
data GLError

-- | Throw an exception if there is an OpenGL error. The exception's error
--   message is prefixed with the supplied <a>String</a>.
throwErrorMsg :: String -> IO ()
instance Typeable GLError
instance Show GLError
instance Exception GLError


-- | Utilities for loading texture data.
module Graphics.GLUtil.Textures

-- | Pixel format of image data.
data TexColor
TexMono :: TexColor
TexRG :: TexColor
TexRGB :: TexColor
TexBGR :: TexColor
TexRGBA :: TexColor

-- | A basic texture information record.
data TexInfo a
TexInfo :: GLsizei -> GLsizei -> TexColor -> a -> TexInfo a
texWidth :: TexInfo a -> GLsizei
texHeight :: TexInfo a -> GLsizei
texColor :: TexInfo a -> TexColor
texData :: TexInfo a -> a

-- | Helper for constructing a <a>TexInfo</a> using Haskell <a>Int</a>s for
--   image dimensions.
texInfo :: Int -> Int -> TexColor -> a -> TexInfo a

-- | Class for containers of texture data.
class HasGLType (Elem a) => IsPixelData a where type family Elem a
withPixels :: IsPixelData a => a -> (Ptr (Elem a) -> IO c) -> IO c

-- | Wrapper whose <a>IsPixelData</a> instance treats the pointer
--   underlying a <a>ByteString</a> as an array of <a>Word16</a>s.
newtype ShortString
ShortString :: ByteString -> ShortString

-- | Create a new 2D texture with uninitialized contents.
freshTexture :: HasGLType a => Int -> Int -> TexColor -> proxy a -> IO TextureObject

-- | Create a new 2D texture with uninitialized <a>Word8</a> contents.
freshTextureWord8 :: Int -> Int -> TexColor -> IO TextureObject

-- | Create a new 2D texture with uninitialized <a>GLfloat</a> contents.
freshTextureFloat :: Int -> Int -> TexColor -> IO TextureObject

-- | Create a new 2D texture with data from a <a>TexInfo</a>.
loadTexture :: IsPixelData a => TexInfo a -> IO TextureObject

-- | Replace a 2D texture's pixel data with data from a <a>TexInfo</a>.
reloadTexture :: IsPixelData a => TextureObject -> TexInfo a -> IO ()

-- | Set texture coordinate wrapping options for both the <a>S</a> and
--   <a>T</a> dimensions of a 2D texture.
texture2DWrap :: StateVar (Repetition, Clamping)

-- | Set texture coordinate wrapping options for the <a>S</a>, <a>T</a>,
--   and <a>R</a> dimensions of a 3D texture.
texture3DWrap :: StateVar (Repetition, Clamping)

-- | Bind each of the given textures to successive texture units at the
--   given <tt>TextureTarget</tt> starting with texture unit 0.
withTextures :: BindableTextureTarget t => t -> [TextureObject] -> IO a -> IO a

-- | Bind each of the given 2D textures to successive texture units
--   starting with texture unit 0.
withTextures2D :: [TextureObject] -> IO a -> IO a

-- | Bind each of the given textures to the texture unit they are paired
--   with. The given action is run with these bindings, then the texture
--   bindings are reset. If you don't care which texture units are used,
--   consider using <a>withTextures</a> or <a>withTextures2D</a>.
withTexturesAt :: BindableTextureTarget t => t -> [(TextureObject, GLuint)] -> IO a -> IO a
instance IsPixelData ShortString
instance IsPixelData ByteString
instance HasGLType b => IsPixelData (Vector b)
instance HasGLType b => IsPixelData (StorableArray i b)
instance HasGLType b => IsPixelData (ForeignPtr b)
instance HasGLType b => IsPixelData (Ptr b)
instance HasGLType b => IsPixelData [b]


-- | Uses the <tt>JuicyPixels</tt> package to load images that are then
--   used to create OpenGL textuers.
module Graphics.GLUtil.JuicyTextures

-- | Load a <a>TexInfo</a> value from an image file, and supply it to a
--   user-provided function. Supported image formats include <tt>png</tt>,
--   <tt>jpeg</tt>, <tt>bmp</tt>, and <tt>gif</tt>. See <a>readTexture</a>
--   for most uses.
readTexInfo :: FilePath -> (forall a. IsPixelData a => TexInfo a -> IO b) -> IO (Either String b)

-- | Load a <a>TextureObject</a> from an image file. Supported formats
--   include <tt>png</tt>, <tt>jpeg</tt>, <tt>bmp</tt>, and <tt>gif</tt>.
readTexture :: FilePath -> IO (Either String TextureObject)


-- | Utilities for working with fragment and vertex shader programs.
module Graphics.GLUtil.Shaders

-- | Load a shader program from a file.
loadShader :: ShaderType -> FilePath -> IO Shader

-- | <tt>loadShaderBS fileName shaderType src</tt> loads a shader from
--   source code, <tt>src</tt>. The file name is used only for error
--   reporting.
loadShaderBS :: FilePath -> ShaderType -> ByteString -> IO Shader

-- | Link shaders into a <a>Program</a>.
linkShaderProgram :: [Shader] -> IO Program

-- | Link shaders into a <a>Program</a> with the given action performed
--   after attaching shaders, but before linking the program. This is most
--   commonly used to set the <a>bindFragDataLocation</a> state variable.
linkShaderProgramWith :: [Shader] -> (Program -> IO ()) -> IO Program

-- | Work with a named uniform shader parameter. Note that this looks up
--   the variable name on each access, so uniform parameters that will be
--   accessed frequently should instead be resolved to a
--   <a>UniformLocation</a>.
namedUniform :: Uniform a => String -> StateVar a

-- | Set a <a>UniformLocation</a> to a scalar value.
uniformScalar :: UniformComponent a => UniformLocation -> SettableStateVar a

-- | Set a <a>UniformLocation</a> from a list representation of a
--   low-dimensional vector of <a>GLfloat</a>s. Only 2, 3, and 4
--   dimensional vectors are supported.
uniformVec :: UniformLocation -> SettableStateVar [GLfloat]

-- | Set a uniform shader location from a nested list matrix
--   representation. Only 3x3 and 4x4 matrices are supported.
uniformMat :: UniformLocation -> SettableStateVar [[GLfloat]]

-- | Set a named uniform shader parameter from a nested list matrix
--   representation. Only 3x3 and 4x4 matrices are supported.
namedUniformMat :: String -> SettableStateVar [[GLfloat]]

-- | Set a uniform shader location with a 4x4 <a>GLmatrix</a>.
uniformGLMat4 :: UniformLocation -> SettableStateVar (GLmatrix GLfloat)


-- | Convenience interface for working with GLSL shader programs. Provides
--   an interface for setting attributes and uniforms.
module Graphics.GLUtil.ShaderProgram

-- | Representation of a GLSL shader program that has been compiled and
--   linked.
data ShaderProgram
ShaderProgram :: Map String (AttribLocation, VariableType) -> Map String (UniformLocation, VariableType) -> Program -> ShaderProgram
attribs :: ShaderProgram -> Map String (AttribLocation, VariableType)
uniforms :: ShaderProgram -> Map String (UniformLocation, VariableType)
program :: ShaderProgram -> Program

-- | Load a <a>ShaderProgram</a> from a vertex shader source file and a
--   fragment shader source file. The active attributes and uniforms in the
--   linked program are recorded in the <a>ShaderProgram</a>.
simpleShaderProgram :: FilePath -> FilePath -> IO ShaderProgram

-- | Load a <a>ShaderProgram</a> from a vertex shader source file and a
--   fragment shader source file. The active attributes and uniforms in the
--   linked program are recorded in the <a>ShaderProgram</a>. The supplied
--   <a>IO</a> function is applied to the new program after shader objects
--   are attached to the program, but before linking. This supports the use
--   of <a>bindFragDataLocation</a> to map fragment shader outputs.
simpleShaderProgramWith :: FilePath -> FilePath -> (Program -> IO ()) -> IO ShaderProgram

-- | Load a <a>ShaderProgram</a> from a vertex and fragment shader source
--   files. the third argument is a tuple of the attribute names and
--   uniform names that will be set in this program. If all attributes and
--   uniforms are desired, consider using <a>loadShaderProgram</a>.
simpleShaderExplicit :: FilePath -> FilePath -> ([String], [String]) -> IO ShaderProgram

-- | Load a <a>ShaderProgram</a> from vertex and fragment shader source
--   strings. The active attributes and uniforms in the linked program are
--   recorded in the <a>ShaderProgram</a>.
simpleShaderProgramBS :: ByteString -> ByteString -> IO ShaderProgram

-- | Load a <a>ShaderProgram</a> from vertex and fragment shader source
--   strings. See <a>simpleShaderProgramWith</a> for more information.
simpleShaderProgramWithBS :: ByteString -> ByteString -> (Program -> IO ()) -> IO ShaderProgram
simpleShaderExplicitBS :: ByteString -> ByteString -> ([String], [String]) -> IO ShaderProgram

-- | Load a shader program from vertex, geometry, and fragment shaders that
--   all share the same root file name and the various conventional
--   extensions: ".vert", ".geom", and ".frag". If a specific file doesn't
--   exist, such as a geometry shader, it is skipped. For instance,
--   <tt>loadShaderFamily "simple"</tt> will load and compile,
--   "simple.vert" and "simple.frag" if those files exist.
loadShaderFamily :: FilePath -> IO ShaderProgram

-- | Load a <a>ShaderProgram</a> from a list of individual shader program
--   files. The active attributes and uniforms in the linked program are
--   recorded in the <a>ShaderProgram</a>
loadShaderProgram :: [(ShaderType, FilePath)] -> IO ShaderProgram
loadShaderProgramWith :: [(ShaderType, FilePath)] -> (Program -> IO ()) -> IO ShaderProgram

-- | Load a <a>ShaderProgram</a> from a list of individual shader program
--   source strings. The active attributes and uniforms in the linked
--   program are recorded in the <a>ShaderProgram</a>
loadShaderProgramBS :: [(ShaderType, ByteString)] -> IO ShaderProgram
loadShaderProgramWithBS :: [(ShaderType, ByteString)] -> (Program -> IO ()) -> IO ShaderProgram

-- | Get the <a>AttribLocation</a> associated with a named vertex
--   attribute.
getAttrib :: ShaderProgram -> String -> AttribLocation

-- | Enable a named vertex attribute.
enableAttrib :: ShaderProgram -> String -> IO ()

-- | Set a named vertex attribute's <a>IntegerHandling</a> and
--   <a>VertexArrayDescriptor</a>.
setAttrib :: ShaderProgram -> String -> IntegerHandling -> VertexArrayDescriptor a -> IO ()

-- | Set a named uniform parameter associated with a particular shader
--   program.
setUniform :: AsUniform a => ShaderProgram -> String -> a -> IO ()

-- | Get the <a>UniformLocation</a> associated with a named uniform
--   parameter.
getUniform :: ShaderProgram -> String -> UniformLocation


-- | Simplify common drawing commands.
module Graphics.GLUtil.Drawing

-- | <tt>drawIndexedTris n</tt> draws <tt>n</tt> <a>Triangles</a> using
--   vertex data from the currently bound <a>ArrayBuffer</a> and indices
--   from the beginning of the currently bound <a>ElementArrayBuffer</a>.
--   Note that there must be at least <tt>n * 3</tt> indices in the
--   <a>ElementArrayBuffer</a>!
drawIndexedTris :: GLsizei -> IO ()


-- | Utilities for filling <a>BufferObject</a>s.
module Graphics.GLUtil.BufferObjects

-- | Allocate and fill a <a>BufferObject</a> from a list of
--   <a>Storable</a>s.
makeBuffer :: Storable a => BufferTarget -> [a] -> IO BufferObject

-- | Allocate and fill a <a>BufferObject</a> from a list of
--   <a>Storable</a>s whose length is explicitly given. This is useful when
--   the list is of known length, as it avoids a traversal to find the
--   length.
makeBufferLen :: Storable a => BufferTarget -> Int -> [a] -> IO BufferObject

-- | <tt>replaceBuffer target elements</tt> replaces the buffer data
--   attached to the buffer object currently bound to <tt>target</tt> with
--   the supplied list. Any previous data is deleted.
replaceBuffer :: Storable a => BufferTarget -> [a] -> IO ()

-- | Allocate and fill a <a>BufferObject</a> with the given number of bytes
--   from the supplied pointer.
fromPtr :: BufferTarget -> Int -> Ptr a -> IO BufferObject

-- | Fill a buffer with a <a>ByteString</a>.
fromByteString :: BufferTarget -> ByteString -> IO BufferObject

-- | Fill a buffer with data from a <a>ForeignPtr</a>. The application
--   <tt>fromForeignPtr target len fptr</tt> fills a <tt>target</tt>
--   <a>BufferTarget</a> with <tt>len</tt> elements starting from
--   <tt>fptr</tt>.
fromForeignPtr :: Storable a => BufferTarget -> Int -> ForeignPtr a -> IO BufferObject

-- | Fill a buffer with data from a <a>Vector</a>.
fromVector :: Storable a => BufferTarget -> Vector a -> IO BufferObject

-- | <tt>replaceVector target v</tt> replaces the buffer data attached to
--   the buffer object currently bound to <tt>target</tt> with the supplied
--   <a>Vector</a>. Any previous data is deleted.
replaceVector :: Storable a => BufferTarget -> Vector a -> IO ()

-- | Produce a <a>Ptr</a> value to be used as an offset of the given number
--   of bytes.
offsetPtr :: Int -> Ptr a

-- | A zero-offset <a>Ptr</a>.
offset0 :: Ptr a

-- | A class for things we know how to serialize into an OpenGL buffer.
class BufferSource v
fromSource :: BufferSource v => BufferTarget -> v -> IO BufferObject

-- | Create an <a>ElementArrayBuffer</a> from a source of <a>Word32</a>s.
bufferIndices :: BufferSource (v Word32) => v Word32 -> IO BufferObject
instance Storable a => BufferSource (Vector a)
instance Storable a => BufferSource [a]


-- | The main import that simply re-exports the various modules that make
--   up the <tt>GLUtil</tt> library.
module Graphics.GLUtil

-- | Load a <a>TextureObject</a> from an image file. Supported formats
--   include <tt>png</tt>, <tt>jpeg</tt>, <tt>bmp</tt>, and <tt>gif</tt>.
readTexture :: FilePath -> IO (Either String TextureObject)

-- | 32-bit unsigned integer type
data Word32 :: *
