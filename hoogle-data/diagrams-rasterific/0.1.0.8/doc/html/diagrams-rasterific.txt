-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Rasterific backend for diagrams.
--   
@package diagrams-rasterific
@version 0.1.0.8


-- | A full-featured rendering backend for diagrams using Rasterific,
--   implemented natively in Haskell (making it easy to use on any
--   platform). Can create png, tif, bmp, jpg, and animated GIFs.
--   
--   To invoke the Rasterific backend, you have three options.
--   
--   <ul>
--   <li>You can use the <a>Diagrams.Backend.Rasterific.CmdLine</a> module
--   to create standalone executables which output images when
--   invoked.</li>
--   <li>You can use the <a>renderRasterific</a> function provided by this
--   module, which gives you more flexible programmatic control over when
--   and how images are output (making it easy to, for example, write a
--   single program that outputs multiple images, or one that outputs
--   images dynamically based on user input, and so on).</li>
--   <li>For the most flexibility (<i>e.g.</i> if you want access to the
--   resulting Rasterific value directly in memory without writing it to
--   disk), you can manually invoke the <a>renderDia</a> method from the
--   <a>Backend</a> instance for <tt>Rasterific</tt>. In particular,
--   <a>renderDia</a> has the generic type</li>
--   </ul>
--   
--   <pre>
--   renderDia :: b -&gt; Options b v -&gt; QDiagram b v m -&gt; Result b v
--   </pre>
--   
--   (omitting a few type class constraints). <tt>b</tt> represents the
--   backend type, <tt>v</tt> the vector space, and <tt>m</tt> the type of
--   monoidal query annotations on the diagram. <a>Options</a> and
--   <a>Result</a> are associated data and type families, respectively,
--   which yield the type of option records and rendering results specific
--   to any particular backend. For <tt>b ~ Rasterific</tt> and <tt>v ~
--   R2</tt>, we have
--   
--   <pre>
--   data Options Rasterific R2 = RasterificOptions
--            { _rasterificSizeSpec      :: SizeSpec2D -- ^ The requested size of the output
--            , _rasterificBypassAdjust  :: Bool       -- ^ Should the 'adjustDia' step be bypassed during rendering?
--            }
--   </pre>
--   
--   <pre>
--   data family Render Rasterific R2 = 'R (RenderM ())'
--   </pre>
--   
--   <pre>
--   type family Result Rasterific R2 = 'Image PixelRGBA8'
--   </pre>
--   
--   So the type of <a>renderDia</a> resolves to
--   
--   <pre>
--   renderDia :: Rasterific -&gt; Options Rasterific R2 -&gt; QDiagram Rasterific R2 m -&gt; 'Image PixelRGBA8'
--   </pre>
--   
--   which you could call like <tt>renderDia Rasterific (RasterificOptions
--   (Width 250)) myDiagram</tt>.
module Diagrams.Backend.Rasterific

-- | This data declaration is simply used as a token to distinguish the
--   Rasterific backend: (1) when calling functions where the type
--   inference engine would otherwise have no way to know which backend you
--   wanted to use, and (2) as an argument to the <a>Backend</a> and
--   <a>Renderable</a> type classes.
data Rasterific
Rasterific :: Rasterific
type B = Rasterific

-- | Backend-specific rendering options.
renderRasterific :: FilePath -> SizeSpec2D -> Word8 -> Diagram Rasterific R2 -> IO ()
size :: Lens' (Options Rasterific R2) SizeSpec2D
writeJpeg :: Word8 -> FilePath -> Result Rasterific R2 -> IO ()
instance Show (Options Rasterific R2)
instance Renderable (DImage Embedded) Rasterific
instance Renderable Text Rasterific
instance Renderable (Path R2) Rasterific
instance Monoid (Render Rasterific R2)
instance Backend Rasterific R2
instance Default RasterificState
instance Typeable Rasterific
instance Eq Rasterific
instance Ord Rasterific
instance Read Rasterific
instance Show Rasterific


-- | Convenient creation of command-line-driven executables for rendering
--   diagrams using the Rasterific backend. Create png, tif, bmp, jpg or
--   animated GIF files.
--   
--   <ul>
--   <li><a>defaultMain</a> creates an executable which can render a single
--   diagram at various options.</li>
--   <li><a>multiMain</a> is like <a>defaultMain</a> but allows for a list
--   of diagrams from which the user can choose one to render.</li>
--   <li><a>animMain</a> is like <a>defaultMain</a> but for animations
--   instead of diagrams.</li>
--   <li><a>gifMain</a> creates an executable to generate an animated
--   GIF.</li>
--   <li><a>mainWith</a> is a generic form that does all of the above but
--   with a slightly scarier type. See <a>Diagrams.Backend.CmdLine</a>.
--   This form can also take a function type that has a suitable final
--   result (any of arguments to the above types) and <a>Parseable</a>
--   arguments.</li>
--   </ul>
--   
--   If you want to generate diagrams programmatically---<i>i.e.</i> if you
--   want to do anything more complex than what the below functions
--   provide---you have several options.
--   
--   <ul>
--   <li>Use a function with <a>mainWith</a>. This may require making
--   <a>Parseable</a> instances for custom argument types.</li>
--   <li>Make a new <a>Mainable</a> instance. This may require a newtype
--   wrapper on your diagram type to avoid the existing instances. This
--   gives you more control over argument parsing, intervening steps, and
--   diagram creation.</li>
--   <li>Build option records and pass them along with a diagram to
--   <a>mainRender</a> from <a>Diagrams.Backend.CmdLine</a>.</li>
--   <li>You can use <a>renderRasterific</a> to render a diagram to a file
--   directly; see <a>Diagrams.Backend.Rasterific</a>.</li>
--   <li>A more flexible approach is to directly call <a>renderDia</a>; see
--   <a>Diagrams.Backend.Rasterific</a> for more information.</li>
--   </ul>
--   
--   For a tutorial on command-line diagram creation see
--   <a>http://projects.haskell.org/diagrams/doc/cmdline.html</a>.
module Diagrams.Backend.Rasterific.CmdLine

-- | Main entry point for command-line diagram creation. This is the method
--   that users will call from their program <tt>main</tt>. For instance an
--   expected user program would take the following form.
--   
--   <pre>
--   import Diagrams.Prelude
--   import Diagrams.Backend.TheBestBackend.CmdLine
--   
--   d :: Diagram B R2
--   d = ...
--   
--   main = mainWith d
--   </pre>
--   
--   Most backends should be able to use the default implementation. A
--   different implementation should be used to handle more complex
--   interactions with the user.
mainWith :: (Mainable d, Parseable (MainOpts d)) => d -> IO ()
defaultMain :: Diagram Rasterific R2 -> IO ()

-- | <tt>multiMain</tt> is like <a>defaultMain</a>, except instead of a
--   single diagram it takes a list of diagrams paired with names as input.
--   The generated executable then takes a <tt>--selection</tt> option
--   specifying the name of the diagram that should be rendered. The list
--   of available diagrams may also be printed by passing the option
--   <tt>--list</tt>.
--   
--   Example usage:
--   
--   <pre>
--   $ ghc --make MultiTest
--   [1 of 1] Compiling Main             ( MultiTest.hs, MultiTest.o )
--   Linking MultiTest ...
--   $ ./MultiTest --list
--   Available diagrams:
--     foo bar
--   $ ./MultiTest --selection bar -o Bar.png -w 200
--   </pre>
multiMain :: [(String, Diagram Rasterific R2)] -> IO ()

-- | <tt>animMain</tt> is like <a>defaultMain</a>, but renders an animation
--   instead of a diagram. It takes as input an animation and produces a
--   command-line program which will crudely "render" the animation by
--   rendering one image for each frame, named by extending the given
--   output file name by consecutive integers. For example if the given
--   output file name is <tt>foo/blah.png</tt>, the frames will be saved in
--   <tt>foo/blah001.png</tt>, <tt>foo/blah002.png</tt>, and so on (the
--   number of padding digits used depends on the total number of frames).
--   It is up to the user to take these images and stitch them together
--   into an actual animation format (using, <i>e.g.</i> <tt>ffmpeg</tt>).
--   
--   Of course, this is a rather crude method of rendering animations; more
--   sophisticated methods will likely be added in the future.
--   
--   The <tt>--fpu</tt> option can be used to control how many frames will
--   be output for each second (unit time) of animation.
animMain :: Animation Rasterific R2 -> IO ()
gifMain :: [(Diagram Rasterific R2, GifDelay)] -> IO ()

-- | Extra options for animated GIFs.
data GifOpts
GifOpts :: Bool -> Bool -> Maybe Int -> GifOpts
_dither :: GifOpts -> Bool
_noLooping :: GifOpts -> Bool
_loopRepeat :: GifOpts -> Maybe Int

-- | This data declaration is simply used as a token to distinguish the
--   Rasterific backend: (1) when calling functions where the type
--   inference engine would otherwise have no way to know which backend you
--   wanted to use, and (2) as an argument to the <a>Backend</a> and
--   <a>Renderable</a> type classes.
data Rasterific
type B = Rasterific
instance Mainable [(Diagram Rasterific R2, GifDelay)]
instance Parseable GifOpts
instance Mainable (Animation Rasterific R2)
instance Mainable [(String, Diagram Rasterific R2)]
instance Mainable (Diagram Rasterific R2)
