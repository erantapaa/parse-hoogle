-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Size-parameterized vector types and functions.
--   
@package sized-vector
@version 1.4.2.0


-- | Size-parameterized vector types and functions.
module Data.Vector.Sized

-- | Fixed-length list.
data Vector (a :: *) (n :: Nat)
Nil :: Vector a Z
(:-) :: a -> Vector a n -> Vector a (S n)

-- | Type synonym for <tt>Ordinal</tt>.
type Index = Ordinal

-- | <a>replicate</a> <tt>n x</tt> is a vector of length <tt>n</tt> with
--   <tt>x</tt> the value of every element.
replicate :: SNat n -> a -> Vector a n

-- | <a>replicate</a>, with the length inferred.
replicate' :: SingI n => a -> Vector a n

-- | Construct a singleton vector.
singleton :: a -> Vector a (S Z)

-- | Uncons the non-empty list.
uncons :: Vector a (S n) -> (a, Vector a n)

-- | Convert a list into a vector. If a given list is shorter than the
--   length, it returns <tt>Nothing</tt>.
fromList :: SNat n -> [a] -> Maybe (Vector a n)

-- | Convert a list into vector, with length inferred.
fromList' :: SingI n => [a] -> Maybe (Vector a n)

-- | Unsafe version of <a>fromList</a>. If a given list is shorter than the
--   length, it aborts.
unsafeFromList :: SNat n -> [a] -> Vector a n

-- | Unsafe version of <a>unsafeFromList</a>.
unsafeFromList' :: SingI n => [a] -> Vector a n

-- | Convert a vector into a list.
toList :: Vector a n -> [a]

-- | Append two <tt>Vector</tt>s.
append :: Vector a n -> Vector a m -> Vector a (n :+ m)

-- | Extract the first element of a non-empty vector.
head :: Vector a (S n) -> a

-- | Extract the last element of a non-empty vector.
last :: Vector a (S n) -> a

-- | Extract the elements after the head of a non-empty list.
tail :: Vector a (S n) -> Vector a n

-- | Extract the elements before the last of a non-empty list. Since
--   1.4.2.0
init :: Vector a (S n) -> Vector a n

-- | Test whether a <tt>Vector</tt> is empty, though it's clear from the
--   type parameter.
null :: Vector a n -> Bool

-- | <a>length</a> returns the length of a finite list as an <a>Int</a>.
length :: Vector a n -> Int

-- | <a>sLength</a> returns the length of a finite list as a <a>SNat</a>
--   <tt>n</tt>.
sLength :: Vector a n -> SNat n

-- | <a>map</a> <tt>f xs</tt> is the vector obtained by applying <tt>f</tt>
--   to each element of xs.
map :: (a -> b) -> Vector a n -> Vector b n

-- | <a>reverse</a> <tt>xs</tt> returns the elements of xs in reverse
--   order. <tt>xs</tt> must be finite.
reverse :: Vector a n -> Vector a n

-- | The <a>intersperse</a> function takes an element and a vector and
--   `intersperses' that element between the elements of the vector.
intersperse :: a -> Vector a n -> Vector a ((Two :* n) :- One)

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument.
transpose :: SingI n => Vector (Vector a n) m -> Vector (Vector a m) n

-- | Left fold.
foldl :: (a -> b -> a) -> a -> Vector b n -> a

-- | A strict version of <a>foldl</a>.
foldl' :: (a -> b -> a) -> a -> Vector b n -> a

-- | Left fold for non-empty vector.
foldl1 :: (a -> a -> a) -> Vector a (S n) -> a

-- | A strict version of <a>foldl1</a>.
foldl1' :: (a -> a -> a) -> Vector a (S n) -> a

-- | Right fold.
foldr :: (a -> b -> b) -> b -> Vector a n -> b

-- | Right fold for non-empty vector.
foldr1 :: (a -> a -> a) -> Vector a (S n) -> a

-- | Indexed version of <a>foldl</a>. Since 1.4.2.0
ifoldl :: (a -> Index n -> b -> a) -> a -> Vector b n -> a

-- | The function <a>concat</a> concatenates all vectors in th vector.
concat :: Vector (Vector a n) m -> Vector a (m :* n)

-- | <a>and</a> returns the conjunction of a Boolean vector.
and :: Vector Bool m -> Bool

-- | <a>or</a> returns the disjunction of a Boolean vector.
or :: Vector Bool m -> Bool

-- | Applied to a predicate and a list, <a>any</a> determines if any
--   element of the vector satisfies the predicate.
any :: (a -> Bool) -> Vector a n -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   element of the vector satisfies the predicate.
all :: (a -> Bool) -> Vector a n -> Bool
sum :: Num a => Vector a n -> a
product :: Num a => Vector a n -> a
maximum :: Ord a => Vector a (S n) -> a
minimum :: Ord a => Vector a (S n) -> a

-- | <a>take</a> <tt>n xs</tt> returns the prefix of <tt>xs</tt> of length
--   <tt>n</tt>, with <tt>n</tt> less than or equal to the length of
--   <tt>xs</tt>.
take :: (n :<<= m) ~ True => SNat n -> Vector a m -> Vector a n

-- | A variant of <tt>take</tt> which returns entire <tt>xs</tt> if
--   <tt>n</tt> is greater than the length of <tt>xs</tt>.
takeAtMost :: SNat n -> Vector a m -> Vector a (Min n m)

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, with <tt>n</tt> less than or equal to the
--   length of <tt>xs</tt>.
drop :: (n :<<= m) ~ True => SNat n -> Vector a m -> Vector a (m :-: n)

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list. <tt>n</tt> should be less than or equal to the
--   length of <tt>xs</tt>.
splitAt :: (n :<<= m) ~ True => SNat n -> Vector a m -> (Vector a n, Vector a (m :-: n))

-- | A varian of <a>splitAt</a> which allows <tt>n</tt> to be greater than
--   the length of <tt>xs</tt>.
splitAtMost :: SNat n -> Vector a m -> (Vector a (Min n m), Vector a (m :-: n))

-- | The <a>stripPrefix</a> function drops the given prefix from a vector.
--   It returns <tt>Nothing</tt> if the vector did not start with the
--   prefix given or shorter than the prefix, or Just the vector after the
--   prefix, if it does.
stripPrefix :: Eq a => Vector a n -> Vector a m -> Maybe (Vector a (m :- n))
elem :: Eq a => a -> Vector a n -> Bool
notElem :: Eq a => a -> Vector a n -> Bool
find :: (a -> Bool) -> Vector a n -> Maybe a

-- | List index (subscript) operator, starting from <tt>sZero</tt>.
(!!) :: (n :<<= m) ~ True => Vector a (S m) -> SNat n -> a

-- | A <a>Index</a> version of <a>!!</a>.
(%!!) :: Vector a n -> Index n -> a

-- | Flipped version of <a>!!</a>.
index :: (n :<<= m) ~ True => SNat n -> Vector a (S m) -> a

-- | A <a>Index</a> version of <a>index</a>.
sIndex :: Index n -> Vector a n -> a

-- | The <a>elemIndex</a> function returns the index (as <a>Int</a>) of the
--   first element in the given list which is equal (by <a>==</a>) to the
--   query element, or Nothing if there is no such element.
elemIndex :: Eq a => a -> Vector a n -> Maybe Int

-- | <a>Index</a> version of <a>elemIndex</a>.
sElemIndex :: Eq a => a -> Vector a n -> Maybe (Index n)

-- | The findIndex function takes a predicate and a vector and returns the
--   index of the first element in the vector satisfying the predicate, or
--   Nothing if there is no such element.
findIndex :: (a -> Bool) -> Vector a n -> Maybe Int

-- | <a>Index</a> version of <a>findIndex</a>.
sFindIndex :: (a -> Bool) -> Vector a n -> Maybe (Index n)

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
findIndices :: (a -> Bool) -> Vector a n -> [Int]

-- | <a>Index</a> version of <a>findIndices</a>.
sFindIndices :: (a -> Bool) -> Vector a n -> [Index n]

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
elemIndices :: Eq a => a -> Vector a n -> [Int]

-- | <a>Index</a> version of <a>elemIndices</a>.
sElemIndices :: Eq a => a -> Vector a n -> [Index n]

-- | <a>zip</a> takes two vectors and returns a vector of corresponding
--   pairs. If one input list is short, excess elements of the longer list
--   are discarded.
zip :: Vector a n -> Vector b m -> Vector (a, b) (Min n m)

-- | Same as <a>zip</a>, but the given vectors must have the same length.
zipSame :: Vector a n -> Vector b n -> Vector (a, b) n

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function.
zipWith :: (a -> b -> c) -> Vector a n -> Vector b m -> Vector c (Min n m)

-- | Same as <a>zipWith</a>, but the given vectors must have the same
--   length.
zipWithSame :: (a -> b -> c) -> Vector a n -> Vector b n -> Vector c n

-- | Inverse of <a>zipSame</a>.
unzip :: Vector (a, b) n -> (Vector a n, Vector b n)
instance Ord a => Ord (Vector a n)
instance Show a => Show (Vector a n)
instance Hashable a => Hashable (Vector a n)
instance NFData a => NFData (Vector a n)
instance Eq a => Eq (Vector a n)
instance Monomorphicable (Vector a)
