-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Stack prisms
--   
@package stack-prism
@version 0.1.2

module Data.StackPrism

-- | A stack prism is a bidirectional isomorphism that is partial in the
--   backward direction. These prisms are compatible with the <tt>lens</tt>
--   library.
--   
--   Stack prisms can express constructor-deconstructor pairs. For example:
--   
--   <pre>
--   nil :: StackPrism t ([a] :- t)
--   nil = stackPrism f g
--     where
--       f        t  = [] :- t
--       g ([] :- t) = Just t
--       g _         = Nothing
--   
--   cons :: StackPrism (a :- [a] :- t) ([a] :- t)
--   cons = stackPrism f g
--     where
--       f (x :- xs  :- t) = (x : xs) :- t
--       g ((x : xs) :- t) = Just (x :- xs :- t)
--       g _               = Nothing
--   </pre>
--   
--   Here <a>:-</a> can be read as 'cons', forming a stack of values. For
--   example, <tt>nil</tt> pushes <tt>[]</tt> onto the stack; or, in the
--   backward direction, tries to remove <tt>[]</tt> from the stack.
--   <tt>cons</tt> takes a head <tt>x</tt> and tail <tt>xs</tt> from the
--   stack and pushes <tt>x : xs</tt> onto the stack, or, in the backward
--   direction, tries to take <tt>x : xs</tt> from the stack and replaces
--   it with its two individual components.
--   
--   Every constructor has its own stack prism version. You don't have to
--   write them by hand; you can automatically generate them, either using
--   Template Haskell (see module <a>Data.StackPrism.TH</a>) or using GHC
--   generic programming (see module <a>Data.StackPrism.Generic</a>).
type StackPrism a b = forall p f. (Choice p, Applicative f) => p a (f a) -> p b (f b)

-- | Construct a prism.
stackPrism :: (a -> b) -> (b -> Maybe a) -> StackPrism a b

-- | Apply a prism in forward direction.
forward :: StackPrism a b -> a -> b

-- | Apply a prism in backward direction.
backward :: StackPrism a b -> b -> Maybe a

-- | Heterogenous stack with a head and a tail. Or: an infix way to write
--   <tt>(,)</tt>.
data (:-) h t
(:-) :: h -> t -> (:-) h t
instance (Eq h, Eq t) => Eq (h :- t)
instance (Show h, Show t) => Show (h :- t)
instance Functor ((:-) h)

module Data.StackPrism.TH

-- | Derive stack prisms for a given datatype.
--   
--   For example:
--   
--   <pre>
--   deriveStackPrisms ''Maybe
--   </pre>
--   
--   will create
--   
--   <pre>
--   _Just :: StackPrism (a :- t) (Maybe a :- t)
--   _Nothing :: StackPrism t (Nothing :- t)
--   </pre>
--   
--   together with their implementations.
deriveStackPrisms :: Name -> Q [Dec]

-- | Derive stack prisms given a function that derives variable names from
--   constructor names.
deriveStackPrismsWith :: (String -> String) -> Name -> Q [Dec]

-- | Derive stack prisms given a list of variable names, one for each
--   constructor.
deriveStackPrismsFor :: [String] -> Name -> Q [Dec]

-- | A stack prism is a bidirectional isomorphism that is partial in the
--   backward direction. These prisms are compatible with the <tt>lens</tt>
--   library.
--   
--   Stack prisms can express constructor-deconstructor pairs. For example:
--   
--   <pre>
--   nil :: StackPrism t ([a] :- t)
--   nil = stackPrism f g
--     where
--       f        t  = [] :- t
--       g ([] :- t) = Just t
--       g _         = Nothing
--   
--   cons :: StackPrism (a :- [a] :- t) ([a] :- t)
--   cons = stackPrism f g
--     where
--       f (x :- xs  :- t) = (x : xs) :- t
--       g ((x : xs) :- t) = Just (x :- xs :- t)
--       g _               = Nothing
--   </pre>
--   
--   Here <a>:-</a> can be read as 'cons', forming a stack of values. For
--   example, <tt>nil</tt> pushes <tt>[]</tt> onto the stack; or, in the
--   backward direction, tries to remove <tt>[]</tt> from the stack.
--   <tt>cons</tt> takes a head <tt>x</tt> and tail <tt>xs</tt> from the
--   stack and pushes <tt>x : xs</tt> onto the stack, or, in the backward
--   direction, tries to take <tt>x : xs</tt> from the stack and replaces
--   it with its two individual components.
--   
--   Every constructor has its own stack prism version. You don't have to
--   write them by hand; you can automatically generate them, either using
--   Template Haskell (see module <a>Data.StackPrism.TH</a>) or using GHC
--   generic programming (see module <a>Data.StackPrism.Generic</a>).
type StackPrism a b = forall p f. (Choice p, Applicative f) => p a (f a) -> p b (f b)

-- | Heterogenous stack with a head and a tail. Or: an infix way to write
--   <tt>(,)</tt>.
data (:-) h t
(:-) :: h -> t -> (:-) h t

module Data.StackPrism.Generic

-- | Derive a list of stack prisms. For more information on the shape of a
--   <a>PrismList</a>, please see the documentation below.
mkPrismList :: (Generic a, MkPrismList (Rep a)) => StackPrisms a

-- | Convenient shorthand for a <a>PrismList</a> indexed by a type and its
--   generic representation.
type StackPrisms a = PrismList (Rep a) a

-- | A data family that is indexed on the building blocks from
--   representation types from <tt>GHC.Generics</tt>. It builds up to a
--   list of prisms, one for each constructor in the generic
--   representation. The list is wrapped in the unary constructor
--   <tt>PrismList</tt>. Within that constructor, the prisms are separated
--   by the right-associative binary infix constructor <tt>:&amp;</tt>.
--   Finally, the individual prisms are wrapped in the unary constructor
--   <tt>P</tt>.
--   
--   As an example, here is how to define the prisms <tt>nil</tt> and
--   <tt>cons</tt> for <tt>[a]</tt>, which is an instance of
--   <tt>Generic</tt>:
--   
--   <pre>
--   nil  :: StackPrism              t  ([a] :- t)
--   cons :: StackPrism (a :- [a] :- t) ([a] :- t)
--   PrismList (P nil :&amp; P cons) = mkPrismList :: StackPrisms [a]
--   </pre>

-- | A stack prism is a bidirectional isomorphism that is partial in the
--   backward direction. These prisms are compatible with the <tt>lens</tt>
--   library.
--   
--   Stack prisms can express constructor-deconstructor pairs. For example:
--   
--   <pre>
--   nil :: StackPrism t ([a] :- t)
--   nil = stackPrism f g
--     where
--       f        t  = [] :- t
--       g ([] :- t) = Just t
--       g _         = Nothing
--   
--   cons :: StackPrism (a :- [a] :- t) ([a] :- t)
--   cons = stackPrism f g
--     where
--       f (x :- xs  :- t) = (x : xs) :- t
--       g ((x : xs) :- t) = Just (x :- xs :- t)
--       g _               = Nothing
--   </pre>
--   
--   Here <a>:-</a> can be read as 'cons', forming a stack of values. For
--   example, <tt>nil</tt> pushes <tt>[]</tt> onto the stack; or, in the
--   backward direction, tries to remove <tt>[]</tt> from the stack.
--   <tt>cons</tt> takes a head <tt>x</tt> and tail <tt>xs</tt> from the
--   stack and pushes <tt>x : xs</tt> onto the stack, or, in the backward
--   direction, tries to take <tt>x : xs</tt> from the stack and replaces
--   it with its two individual components.
--   
--   Every constructor has its own stack prism version. You don't have to
--   write them by hand; you can automatically generate them, either using
--   Template Haskell (see module <a>Data.StackPrism.TH</a>) or using GHC
--   generic programming (see module <a>Data.StackPrism.Generic</a>).
type StackPrism a b = forall p f. (Choice p, Applicative f) => p a (f a) -> p b (f b)

-- | Heterogenous stack with a head and a tail. Or: an infix way to write
--   <tt>(,)</tt>.
data (:-) h t
(:-) :: h -> t -> (:-) h t
instance (MkStackPrism f, MkStackPrism g) => MkStackPrism (f :*: g)
instance MkStackPrism f => MkStackPrism (M1 i c f)
instance MkStackPrism (K1 i a)
instance MkStackPrism U1
instance MkStackPrism f => MkPrismList (M1 C c f)
instance (MkPrismList f, MkPrismList g) => MkPrismList (f :+: g)
instance MkPrismList f => MkPrismList (M1 D c f)
