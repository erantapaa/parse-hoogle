-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A functional pearl on encoding and decoding using question-and-answer strategies
--   
--   A functional pearl on encoding and decoding using question-and-answer
--   strategies
@package every-bit-counts
@version 0.1

module Iso
data ISO t s
Iso :: (t -> s) -> (s -> t) -> ISO t s
to :: ISO t s -> t -> s
from :: ISO t s -> s -> t
type Nat = Int
singleIso :: a -> ISO a ()
splitIso :: (a -> Bool) -> ISO a (Either a a)
boolIso :: ISO Bool (Either () ())
succIso :: ISO Nat (Either () Nat)
parityIso :: ISO Nat (Either Nat Nat)
listIso :: ISO [t] (Either () (t, [t]))
depListIso :: ISO [t] (Nat, [t])
idI :: ISO a a
seqI :: ISO a b -> ISO b c -> ISO a c
sumI :: ISO a b -> ISO c d -> ISO (Either a c) (Either b d)
prodI :: ISO a b -> ISO c d -> ISO (a, c) (b, d)
invI :: ISO a b -> ISO b a
swapProdI :: ISO (a, b) (b, a)
swapSumI :: ISO (Either a b) (Either b a)
assocProdI :: ISO (a, (b, c)) ((a, b), c)
assocSumI :: ISO (Either a (Either b c)) (Either (Either a b) c)
prodLUnitI :: ISO ((), a) a
prodRUnitI :: ISO (a, ()) a
prodRSumI :: ISO (a, Either b c) (Either (a, b) (a, c))
prodLSumI :: ISO (Either b c, a) (Either (b, a) (c, a))

module Games
data Game :: * -> *
Single :: ISO t () -> Game t
Split :: ISO t (Either t1 t2) -> Game t1 -> Game t2 -> Game t
data Bit
O :: Bit
I :: Bit
dec :: Game t -> [Bit] -> (t, [Bit])
decOpt :: Game t -> [Bit] -> Maybe (t, [Bit])
decRandAux :: RandomGen g => g -> Game t -> t
decRand :: Int -> Game t -> t
(+>) :: Game t -> ISO s t -> Game s
enc :: Game t -> t -> [Bit]
testGame :: Game t -> t -> (t, [Bit])
instance Show Bit

module BasicGames
unitGame :: Game ()
boolGame :: Game Bool
constGame :: t -> Game t
geNatGame :: Nat -> Game Nat
unaryNatGame :: Game Nat
rangeGame :: Nat -> Nat -> Game Nat
binNatGame :: Game Nat
flipGame :: Game a -> Game a
sumGame :: Game t -> Game s -> Game (Either t s)
prodGame :: Game t -> Game s -> Game (t, s)
ilGame :: Game t -> Game s -> Game (t, s)
depGame :: Game t -> (t -> Game s) -> Game (t, s)
listGame :: Game t -> Game [t]
vecGame :: Game t -> Nat -> Game [t]
listGame' :: Game t -> Game [t]

module FilterGames
voidGame :: Game t
filterGame :: (t -> Bool) -> Game t -> Game t
filterGameOpt :: (t -> Bool) -> Game t -> Maybe (Game t)
filterFinGame :: (t -> Bool) -> Game t -> Maybe (Game t)
pre_filterGame_inf :: Eq t => Game t -> (t -> Bool) -> Game t
filterInfGame :: Eq t => (t -> Bool) -> Game t -> Game t
unfoldUntil :: Game t -> (t, Game t)
unfoldOne :: Game t -> Game t
find :: Game t -> Either (t, Game t) (Game t)
shufflePartition :: Game t -> Game t

module Huffman
type Set a = [a]
type PQ a = [(Int, a)]
addItem :: Int -> a -> PQ a -> PQ a
updPQ :: Eq a => PQ a -> a -> PQ a
huff :: Eq a => PQ (Set a, Game a) -> Game a
huffGame :: Eq a => PQ a -> Game a
charHuffGame :: Game Char
sHuffGame :: PQ Char -> Game [Char]
dHuffGame :: PQ Char -> Game [Char]
vecHuffGame :: Nat -> PQ Char -> Game [Char]
lengthHuffGame :: PQ Char -> Game (Nat, [Char])
prodPQ :: PQ a -> PQ b -> PQ (a, b)

module SetGames
natMultisetGame :: Game Nat -> Game [Nat]
natSetGame :: Game Nat -> Game [Nat]
compareByGame :: Game a -> (a -> a -> Ordering)
sortByGame :: Game a -> [a] -> [a]
removeEQ :: Game a -> a -> Maybe (Game a)
removeLE :: Game a -> a -> Maybe (Game a)
removeLT :: Game a -> a -> Game a
setGame :: Game a -> Game [a]
multisetGame :: Game a -> Game [a]

module NatGames
type Pos = Int
binaryIso :: ISO Pos (Nat, Pos)
eliasGame :: Game Nat -> Game Pos
isOneIso :: ISO Pos (Either () Pos)
factIso :: [Int] -> ISO Int (Either Int Int)
factGame :: Game Pos

module STLC
data Ty
TyNat :: Ty
TyArr :: Ty -> Ty -> Ty
data Exp
Var :: Nat -> Exp
Lam :: Ty -> Exp -> Exp
App :: Exp -> Exp -> Exp
tyG :: Game Ty
type Env = [Ty]
typeOf :: Env -> Exp -> Ty
data Pat
Any :: Pat
PArr :: Ty -> Pat -> Pat
matches :: Pat -> Ty -> Bool
varGame :: (Ty -> Bool) -> Env -> Maybe (Game Nat)
expGame :: Env -> Pat -> Game Exp
progGame :: Game Exp
expGameCheck :: Env -> Ty -> Game Exp
listsOfLength :: Int -> [[Bit]]
instance Eq Exp
instance Show Exp
instance Eq Ty
instance Show Ty

module UTLC
data Exp
Var :: Nat -> Exp
Lam :: Exp -> Exp
App :: Exp -> Exp -> Exp
expGame :: Nat -> Game Exp
instance Show Exp

module PGames
data Void
data GamesOver :: * -> *
NilGames :: GamesOver Void
ConsGames :: Int -> Game t -> GamesOver s -> GamesOver (Either t s)
data Game :: * -> *
Single :: ISO t () -> Game t
Split :: ISO t s -> GamesOver s -> Game t
totalWeight :: GamesOver s -> Int
split3 :: ISO t (Either t1 (Either t2 (Either t3 Void))) -> Int -> Game t1 -> Int -> Game t2 -> Int -> Game t3 -> Game t
flat2 :: ISO t (Either t1 t2) -> ISO t (Either t1 (Either t2 Void))
flat3 :: ISO t (Either t1 (Either t2 t3)) -> ISO t (Either t1 (Either t2 (Either t3 Void)))
split2 :: ISO t (Either t1 t2) -> Int -> Game t1 -> Int -> Game t2 -> Game t
split :: ISO t (Either t1 t2) -> Game t1 -> Game t2 -> Game t
(+>) :: Game t -> ISO s t -> Game s
type Bit = Int
type MInterval = (Int, Int, Int)
type Interval = (Int, Int)
type EInterval = (Int, Interval)
w2 :: Int
w3 :: Int
w4 :: Int
w1 :: Int
e :: Int
unit :: Interval
narrow :: Interval -> MInterval -> Interval
nextBits :: EInterval -> Maybe ([Bit], EInterval)
enarrow :: EInterval -> MInterval -> EInterval
expand :: EInterval -> EInterval
bits :: Int -> Bit -> [Bit]
stream :: EInterval -> [MInterval] -> [Bit]
arithEncAux :: EInterval -> Game t -> t -> [Bit]
encodeSyms :: Game t -> t -> [MInterval]
enc :: Game t -> t -> [Bit]
decode :: EInterval -> [Bit] -> Game t -> t
ominus :: (Int, [Bit]) -> [Bit] -> (Int, [Bit])
fscale :: (Int, (Int, [Bit])) -> Int
destream :: EInterval -> (Int, [Bit]) -> Game t -> t
testGame :: Game t -> t -> t

module BadGames
voidGame :: Game t
badBoolGame :: Game Bool
badNatGame :: Game Nat
badBoolGame3 :: Game Bool
