-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Playing with reified categorical composition
--   
@package Cascade
@version 0.1.0.0

module Cascade.Util.ListKind

module Cascade
data CascadeC (c :: t -> t -> *) (ts :: [t])
(:>>>) :: c x y -> CascadeC c (y : zs) -> CascadeC c (x : (y : zs))
Done :: CascadeC c '[t]
transform :: (forall a b. c a b -> c' a b) -> CascadeC c ts -> CascadeC c' ts
cascade :: Category c => CascadeC c (t : ts) -> c t (Last (t : ts))
type Cascade = CascadeC (->)
type CascadeM m = CascadeC (Kleisli m)
(>=>:) :: (x -> m y) -> CascadeM m (y : zs) -> CascadeM m (x : (y : zs))
cascadeM :: Monad m => CascadeM m (t : ts) -> t -> m (Last (t : ts))
unwrapM :: CascadeM Identity ts -> Cascade ts
wrapM :: Monad m => Cascade ts -> CascadeM m ts
type CascadeW w = CascadeC (Cokleisli w)
(=>=:) :: (w x -> y) -> CascadeW w (y : zs) -> CascadeW w (x : (y : zs))
cascadeW :: Comonad w => CascadeW w (t : ts) -> w t -> Last (t : ts)
unwrapW :: CascadeW Identity ts -> Cascade ts
wrapW :: Comonad w => Cascade ts -> CascadeW w ts

module Cascade.Debugger
data DebuggerM (m :: * -> *) (past :: [*]) (current :: *) (future :: [*])
Begin :: (a -> m (DebuggerM m '[a] b cs)) -> DebuggerM m [] a (b : cs)
Break :: (a -> m (DebuggerM m (a : (z : ys)) b cs)) -> DebuggerM m ys z (a : (b : cs)) -> z -> a -> DebuggerM m (z : ys) a (b : cs)
End :: DebuggerM m ys z '[a] -> z -> a -> DebuggerM m (z : ys) a []
printHistory :: (All Show zs, All Show bs, Show a) => DebuggerM m zs a bs -> IO ()
given :: DebuggerM m (z : ys) a bs -> z
returned :: DebuggerM m (z : ys) a bs -> a
back :: DebuggerM m (z : ys) a bs -> DebuggerM m ys z (a : bs)
redo :: DebuggerM m (a : (z : ys)) b cs -> m (DebuggerM m (a : (z : ys)) b cs)
redoWith :: a -> DebuggerM m (a : zs) b cs -> m (DebuggerM m (a : zs) b cs)
use :: a -> DebuggerM m zs a (b : cs) -> m (DebuggerM m (a : zs) b cs)
step :: DebuggerM m (z : ys) a (b : cs) -> m (DebuggerM m (a : (z : ys)) b cs)
debugM :: Monad m => CascadeM m (a : (b : cs)) -> DebuggerM m [] a (b : cs)
instance (All Show zs, All Show bs, Show a) => Show (DebuggerM m zs a bs)

module Cascade.Examples
fc :: Cascade '[String, Int, Double, Double]
gc :: Cascade '[String, Int, Double, Double]
mc :: CascadeM IO '[String, (), String, String, ()]
nc :: CascadeM IO '[String, (), String, String, ()]
wc :: CascadeW ((,) Char) '[Int, Char, Int, String]
vc :: CascadeW ((,) Char) '[Int, Char, Int, String]
rundmc :: IO (DebuggerM IO '[String, String, (), [Char]] () [])
zigzag :: CascadeC c ts -> CascadeC c ts -> CascadeC c ts

module Cascade.Product
data ProductM (m :: * -> *) (ts :: [*])
None :: ProductM m []
(:*) :: a -> m (ProductM m ts) -> ProductM m (a : ts)
type Product = ProductM Identity
(*:) :: a -> Product ts -> Product (a : ts)
pushes :: Comonad w => (w y -> x) -> w (Product (y : zs)) -> Product (x : (y : zs))
recordW :: Comonad w => CascadeW w (t : ts) -> CascadeW w (RInitProducts (t : ts) ts')
record :: Cascade (t : ts) -> Cascade (RInitProducts (t : ts) ts')
instance (Show a, Show (ProductM Identity as)) => Show (ProductM Identity (a : as))
instance Show (ProductM Identity '[])

module Cascade.Sum
data SumW (w :: * -> *) (ts :: [*])
Here :: w a -> SumW w (a : as)
There :: SumW w as -> SumW w (a : as)
toEither :: SumW w as -> SumW' w as
type Sum = SumW Identity
here :: a -> Sum (a : as)
there :: Sum as -> Sum (a : as)
type TailSums ts = TailSumsW Identity ts
pops :: Monad m => (w x -> m (w y)) -> SumW w (x : (y : zs)) -> m (SumW w (y : zs))
resumeC :: Monad m => (forall a b. c a b -> w a -> m (w b)) -> CascadeC c ts -> CascadeM m (TailSumsW w ts)
resumeM :: Monad m => CascadeM m ts -> CascadeM m (TailSums ts)
resumeW :: Comonad w => CascadeW w ts -> Cascade (TailSumsW w ts)
resume :: Cascade ts -> Cascade (TailSums ts)
instance (Show a, Show (SumW Identity as)) => Show (SumW Identity (a : as))
instance Show (SumW Identity '[])

module Cascade.Operators
(#) :: Category c => CascadeC c (t : ts) -> c t (Last (t : ts))
(#~) :: Monad m => CascadeM m (t : ts) -> t -> m (Last (t : ts))
(~#) :: Comonad w => CascadeW w (t : ts) -> w t -> Last (t : ts)
