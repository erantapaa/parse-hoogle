-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Term manipulation library for the tamarin prover.
--   
--   This is an internal library of the Tamarin prover for security
--   protocol verification
--   (<a>hackage.haskell.org/package/tamarin-prover</a>).
--   
--   This library provides term manipulation infrastructure (matching,
--   unification, narrowing, finite variants) for the Tamarin prover. It
--   uses maude (<a>http://maude.cs.uiuc.edu/</a>) as a backend for
--   normalization, equational matching, and unification.
@package tamarin-prover-term
@version 0.8.5.0


-- | Terms with variables and constants.
module Term.VTerm

-- | A Lit is either a constant or a variable. (<tt>Const</tt> is taken by
--   Control.Applicative)
data Lit c v
Con :: c -> Lit c v
Var :: v -> Lit c v

-- | A VTerm is a term with constants and variables
type VTerm c v = Term (Lit c v)

-- | <tt>varTerm v</tt> is the <a>VTerm</a> with the variable <tt>v</tt>.
varTerm :: v -> VTerm c v

-- | <tt>constTerm c</tt> is the <a>VTerm</a> with the const <tt>c</tt>.
constTerm :: c -> VTerm c v

-- | <tt>vars t</tt> returns a duplicate-free list of variables that occur
--   in <tt>t</tt>.
varsVTerm :: (Eq v, Ord v) => VTerm c v -> [v]

-- | <tt>occurs v t</tt> returns <tt>True</tt> if <tt>v</tt> occurs in
--   <tt>t</tt>
occursVTerm :: Eq v => v -> VTerm c v -> Bool

-- | <tt>constsVTerm t</tt> returns a duplicate-free list of constants that
--   occur in <tt>t</tt>.
constsVTerm :: IsConst c => VTerm c v -> [c]
isVar :: VTerm c v -> Bool

-- | Extract just the variable from a term that may be variable.
termVar :: VTerm c v -> Maybe v

-- | Extract just the variable from a term that must be variable, throw an
--   error if this fails.
termVar' :: (Show c, Show v) => VTerm c v -> v

-- | collect class constraints for variables
class (Ord v, Eq v, Show v) => IsVar v

-- | collect class constraints for constants
class (Ord c, Eq c, Show c, Data c) => IsConst c

-- | Pretty print a term.
prettyTerm :: (Document d, Show l) => (l -> d) -> Term l -> d

-- | Convert a function symbol to its name.
showFunSymName :: FunSym -> String

-- | <tt>lits t</tt> returns all literals that occur in term <tt>t</tt>.
--   List can contain duplicates.
lits :: Ord a => Term a -> [a]

-- | Smart constructors for one, zero.
fAppOne :: Term a

-- | Smart constructors for pair, exp, pmult, and emap.
fAppExp :: Ord a => (Term a, Term a) -> Term a

-- | Smart constructors for inv, fst, and snd.
fAppInv :: Term a -> Term a

-- | Smart constructors for pair, exp, pmult, and emap.
fAppPMult :: Ord a => (Term a, Term a) -> Term a

-- | Smart constructors for pair, exp, pmult, and emap.
fAppEMap :: Ord a => (Term a, Term a) -> Term a

-- | Smart constructors for pair, exp, pmult, and emap.
fAppPair :: Ord a => (Term a, Term a) -> Term a

-- | Smart constructors for inv, fst, and snd.
fAppFst :: Term a -> Term a

-- | Smart constructors for inv, fst, and snd.
fAppSnd :: Term a -> Term a

-- | <a>True</a> iff the term is a well-formed pair.
isPair :: Show a => Term a -> Bool

-- | <a>True</a> iff the term is a well-formed inverse.
isInverse :: Show a => Term a -> Bool

-- | <a>True</a> iff the term is a well-formed product.
isProduct :: Show a => Term a -> Bool

-- | <a>True</a> iff the term is a well-formed union.
isUnion :: Show a => Term a -> Bool

-- | <a>True</a> iff the term is a well-formed emap.
isEMap :: Show a => Term a -> Bool

-- | <a>True</a> iff the term is a nullary, public function.
isNullaryPublicFunction :: Term a -> Bool
isPrivateFunction :: Term a -> Bool

-- | Function symbols
data FunSym

-- | a free function function symbol of a given arity
NoEq :: NoEqSym -> FunSym

-- | an AC function symbol, can be used n-ary
AC :: ACSym -> FunSym

-- | a C function symbol of a given arity
C :: CSym -> FunSym

-- | a free n-ary function symbol of TOP sort
List :: FunSym

-- | AC function symbols.
data ACSym
Union :: ACSym
Mult :: ACSym

-- | C(ommutative) function symbols
data CSym
EMap :: CSym

-- | A function symbol can be either Private (unknown to adversary) or
--   Public.
data Privacy
Private :: Privacy
Public :: Privacy

-- | NoEq function symbols (with respect to the background theory).
type NoEqSym = (ByteString, (Int, Privacy))

-- | Function signatures.
type FunSig = Set FunSym

-- | NoEq function signatures.
type NoEqFunSig = Set NoEqSym
expSymString :: ByteString
invSymString :: ByteString
pmultSymString :: ByteString
emapSymString :: ByteString
unionSymString :: ByteString

-- | Exponentiation.
expSym :: NoEqSym

-- | Multiplication of points (in G1) on elliptic curve by scalars.
pmultSym :: NoEqSym

-- | The signature for Diffie-Hellman function symbols.
dhFunSig :: FunSig

-- | The signature for the bilinear pairing function symbols.
bpFunSig :: FunSig

-- | The signature for the multiset function symbols.
msetFunSig :: FunSig

-- | The signature for pairing.
pairFunSig :: NoEqFunSig

-- | Reducible function symbols for DH.
dhReducibleFunSig :: FunSig

-- | Reducible function symbols for BP.
bpReducibleFunSig :: FunSig

-- | Implicit function symbols.
implicitFunSig :: FunSig
class Sized a
size :: Sized a => a -> Int

-- | A term in T(Sigma,a). Its constructors are kept abstract. Use
--   <a>viewTerm</a> or <a>viewTerm2</a> to inspect it.
data Term a

-- | View on terms that corresponds to representation.
data TermView a
Lit :: a -> TermView a
FApp :: FunSym -> [Term a] -> TermView a

-- | Return the <a>TermView</a> of the given term.
viewTerm :: Term a -> TermView a

-- | View on terms that distinguishes function application of builtin
--   symbols like exp.
data TermView2 a
FExp :: (Term a) -> (Term a) -> TermView2 a
FInv :: (Term a) -> TermView2 a
FMult :: [Term a] -> TermView2 a
One :: TermView2 a
FPMult :: (Term a) -> (Term a) -> TermView2 a
FEMap :: (Term a) -> (Term a) -> TermView2 a
FUnion :: [Term a] -> TermView2 a
FPair :: (Term a) -> (Term a) -> TermView2 a
FAppNoEq :: NoEqSym -> [Term a] -> TermView2 a
FAppC :: CSym -> [Term a] -> TermView2 a
FList :: [Term a] -> TermView2 a
Lit2 :: a -> TermView2 a

-- | Returns the <a>TermView2</a> of the given term.
viewTerm2 :: Show a => Term a -> TermView2 a
traverseTerm :: (Applicative f, Ord a, Ord b) => (a -> f b) -> Term a -> f (Term b)
fmapTerm :: (Ord a, Ord b) => (a -> b) -> Term a -> Term b
bindTerm :: (Ord a, Ord b) => Term a -> (a -> Term b) -> Term b

-- | <tt>lit l</tt> creates a term from the literal <tt>l</tt>.
lit :: a -> Term a

-- | <tt>fApp fsym as</tt> creates an application of <tt>fsym</tt> to
--   <tt>as</tt>. The function ensures that the resulting term is in
--   AC-normal-form.
fApp :: Ord a => FunSym -> [Term a] -> Term a

-- | Smart constructor for AC terms.
fAppAC :: Ord a => ACSym -> [Term a] -> Term a

-- | Smart constructor for AC terms.
fAppC :: Ord a => CSym -> [Term a] -> Term a

-- | Smart constructor for non-AC terms.
fAppNoEq :: NoEqSym -> [Term a] -> Term a

-- | Smart constructor for list terms.
fAppList :: [Term a] -> Term a

-- | <tt>unsafefApp fsym as</tt> creates an application of <tt>fsym</tt> to
--   as. The caller has to ensure that the resulting term is in
--   AC-normal-form.
unsafefApp :: FunSym -> [Term a] -> Term a
instance (Binary c_1627486233, Binary v_1627486234) => Binary (Lit c_1627486233 v_1627486234)
instance (NFData c_1627486233, NFData v_1627486234) => NFData (Lit c_1627486233 v_1627486234)
instance Typeable2 Lit
instance (Eq c, Eq v) => Eq (Lit c v)
instance (Ord c, Ord v) => Ord (Lit c v)
instance (Data c, Data v) => Data (Lit c v)
instance (Show v, Show c) => Show (Lit c v)
instance Sized (Lit c v)
instance Monad (Lit c)
instance Applicative (Lit c)
instance Traversable (Lit c)
instance Foldable (Lit c)
instance Functor (Lit c)


-- | Positions and replacement in terms.
module Term.Positions

-- | A position in a term is a list of integers.
type Position = [Int]

-- | <tt>t <a>atPos</a> p</tt> returns the subterm of term <tt>t</tt> at
--   position <tt>p</tt>. The standard notation for <tt>t <a>atPos</a>
--   p</tt> is <tt>t|_p</tt>. <a>atPos</a> accounts for AC symbols by
--   interpreting n-ary operator applications <tt>*[t1,t2,..tk-1,tk]</tt>
--   as binary applications <tt>t1*(t2*..(tk-1*tk)..)</tt>.
atPos :: Ord a => Term a -> Position -> Term a

-- | <tt>t <a>replacePos</a> (s,p)</tt> returns the term <tt>t'</tt> where
--   the subterm at position <tt>p</tt> is replaced by <tt>s</tt>. The
--   standard notation for <tt>t <a>replacePos</a> (s,p)</tt> is
--   <tt>t[s]_p</tt>. <a>replacePos</a> accounts for AC symbols in the same
--   ways as <a>atPos</a>. FIXME: The AC can be optimized.
replacePos :: Ord a => Term a -> (Term a, Position) -> Term a

-- | <tt>positionsNonVar t</tt> returns all the non-variable positions in
--   the term <tt>t</tt>. <a>positionsNonVar</a> accounts for AC symbols in
--   the same ways as <a>atPos</a>.
positionsNonVar :: (Show a, Show b) => VTerm a b -> [Position]


-- | Term Equalities, Matching Problems, and Subterm Rules.
module Term.Rewriting.Definitions

-- | An equality.
data Equal a
Equal :: a -> a -> Equal a
eqLHS :: Equal a -> a
eqRHS :: Equal a -> a

-- | True iff the two sides of the equality are equal with respect to their
--   <a>Eq</a> instance.
evalEqual :: Eq a => Equal a -> Bool

-- | Matching problems. Use the <a>Monoid</a> instance to compose matching
--   problems.
data Match a

-- | No matcher exists.
NoMatch :: Match a

-- | A bunch of delayed (term,pattern) pairs.
DelayedMatches :: [(a, a)] -> Match a

-- | Flatten a matching problem to a list of (term,pattern) pairs. If no
--   matcher exists, then <a>Nothing</a> is returned.
flattenMatch :: Match a -> Maybe [(a, a)]

-- | Match a term with a pattern.
matchWith :: a -> a -> Match a

-- | Ensure that matching only succeeds if the condition holds.
matchOnlyIf :: Bool -> Match a

-- | A rewrite rule.
data RRule a
RRule :: a -> a -> RRule a
instance Eq a => Eq (Equal a)
instance Show a => Show (Equal a)
instance Show a => Show (RRule a)
instance Ord a => Ord (RRule a)
instance Eq a => Eq (RRule a)
instance Applicative RRule
instance Traversable RRule
instance Foldable RRule
instance Monoid a => Monoid (RRule a)
instance Functor RRule
instance Traversable Match
instance Foldable Match
instance Monoid (Match a)
instance Functor Match
instance Show a => Show (Match a)
instance Eq a => Eq (Match a)
instance Applicative Equal
instance Traversable Equal
instance Foldable Equal
instance Monoid a => Monoid (Equal a)
instance Functor Equal


-- | Terms with logical variables and names.
module Term.LTerm

-- | Names.
data Name
Name :: NameTag -> NameId -> Name
nTag :: Name -> NameTag
nId :: Name -> NameId

-- | Tags for names.
data NameTag
FreshName :: NameTag
PubName :: NameTag

-- | Type safety for names.
newtype NameId
NameId :: String -> NameId
getNameId :: NameId -> String

-- | Terms with literals containing names and arbitrary variables.
type NTerm v = VTerm Name v

-- | Return <a>LSort</a> for given <a>Name</a>.
sortOfName :: Name -> LSort

-- | <tt>freshTerm f</tt> represents the fresh name <tt>f</tt>.
freshTerm :: String -> NTerm v

-- | <tt>pubTerm f</tt> represents the pub name <tt>f</tt>.
pubTerm :: String -> NTerm v

-- | Sorts for logical variables. They satisfy the following sub-sort
--   relation:
--   
--   <pre>
--   LSortFresh &lt; LSortMsg
--   LSortPub   &lt; LSortMsg
--   </pre>
data LSort

-- | Arbitrary public names.
LSortPub :: LSort

-- | Arbitrary fresh names.
LSortFresh :: LSort

-- | Arbitrary messages.
LSortMsg :: LSort

-- | Sort for variables denoting nodes of derivation graphs.
LSortNode :: LSort

-- | Logical variables. Variables with the same name and index but
--   different sorts are regarded as different variables.
data LVar
LVar :: String -> !LSort -> !Integer -> LVar
lvarName :: LVar -> String
lvarSort :: LVar -> !LSort
lvarIdx :: LVar -> !Integer

-- | An alternative name for logical variables, which are intented to be
--   variables of sort <a>LSortNode</a>.
type NodeId = LVar

-- | Terms used for proving; i.e., variables fixed to logical variables.
type LTerm c = VTerm c LVar

-- | Terms used for proving; i.e., variables fixed to logical variables and
--   constants to Names.
type LNTerm = VTerm Name LVar

-- | <tt>freshLVar v</tt> represents a fresh logical variable with name
--   <tt>v</tt>.
freshLVar :: MonadFresh m => String -> LSort -> m LVar

-- | <tt>sortPrefix s</tt> is the prefix we use for annotating variables of
--   sort <tt>s</tt>.
sortPrefix :: LSort -> String

-- | <tt>sortSuffix s</tt> is the suffix we use for annotating variables of
--   sort <tt>s</tt>.
sortSuffix :: LSort -> String

-- | <tt>sortCompare s1 s2</tt> compares <tt>s1</tt> and <tt>s2</tt> with
--   respect to the partial order on sorts. Partial order: Node Msg / --
--   Pub Fresh
sortCompare :: LSort -> LSort -> Maybe Ordering

-- | Returns the most precise sort of an <a>LTerm</a>.
sortOfLTerm :: Show c => (c -> LSort) -> LTerm c -> LSort

-- | Returns the most precise sort of an <a>LNTerm</a>.
sortOfLNTerm :: LNTerm -> LSort

-- | Returns the most precise sort of a <a>Lit</a>.
sortOfLit :: Lit Name LVar -> LSort

-- | Is a term a message variable?
isMsgVar :: LNTerm -> Bool

-- | Is a term a fresh variable?
isFreshVar :: LNTerm -> Bool

-- | A term is *simple* iff there is an instance of this term that can be
--   constructed from public names only. i.e., the term does not contain
--   any fresh names, fresh variables, or private function symbols.
isSimpleTerm :: LNTerm -> Bool

-- | The non-inverse factors of a term.
niFactors :: LNTerm -> [LNTerm]

-- | <tt>containsPrivate t</tt> returns <tt>True</tt> if <tt>t</tt>
--   contains private function symbols.
containsPrivate :: Term t -> Bool

-- | <a>True</a> iff no instance of this term contains fresh names or
--   private function symbols.
neverContainsFreshPriv :: LNTerm -> Bool

-- | Extract a variable of the given sort from a term that may be such a
--   variable. Use <a>termVar</a>, if you do not want to restrict the sort.
ltermVar :: LSort -> LTerm c -> Maybe LVar

-- | Extract a variable of the given sort from a term that must be such a
--   variable. Fails with an error, if that is not possible.
ltermVar' :: Show c => LSort -> LTerm c -> LVar

-- | Extract a node-id variable from a term that may be a node-id variable.
ltermNodeId :: LTerm c -> Maybe LVar

-- | Extract a node-id variable from a term that must be a node-id
--   variable.
ltermNodeId' :: Show c => LTerm c -> LVar

-- | Extract a node-id variable from a term that may be a node-id variable.
bltermNodeId :: BLTerm -> Maybe LVar

-- | Extract a node-id variable from a term that must be a node-id
--   variable.
bltermNodeId' :: BLTerm -> LVar

-- | <tt>HasFree t</tt> denotes that the type <tt>t</tt> has free
--   <tt>LVar</tt> variables. They can be collected using <a>foldFrees</a>
--   and <a>foldFreesOcc</a> and mapped in the context of an applicative
--   functor using <a>mapFrees</a>.
--   
--   When defining instances of this class, you have to ensure that only
--   the free LVars are collected and mapped and no others. The instances
--   for standard Haskell types assume that all variables free in all type
--   arguments are free. The <a>foldFreesOcc</a> is only used to define the
--   function <a>varOccurences</a>. See below for required properties of
--   the instance methods.
--   
--   Once we need it, we can use type synonym instances to parametrize over
--   the variable type.
class HasFrees t
foldFrees :: (HasFrees t, Monoid m) => (LVar -> m) -> t -> m
foldFreesOcc :: (HasFrees t, Monoid m) => (Occurence -> LVar -> m) -> Occurence -> t -> m
mapFrees :: (HasFrees t, Applicative f) => MonotoneFunction f -> t -> f t

-- | For performance reasons, we distinguish between monotone functions on
--   <a>LVar</a>s and arbitrary functions. For a monotone f, if <tt>x &lt;=
--   y</tt>, then <tt>f x &lt;= f y</tt>. This ensures that the AC-normal
--   form does not have to be recomputed. If you are unsure about what to
--   use, then use the <a>Arbitrary</a> function.
data MonotoneFunction f
Monotone :: (LVar -> f LVar) -> MonotoneFunction f
Arbitrary :: (LVar -> f LVar) -> MonotoneFunction f

-- | <tt>v <a>occurs</a> t</tt> iff variable <tt>v</tt> occurs as a free
--   variable in <tt>t</tt>.
occurs :: HasFrees t => LVar -> t -> Bool

-- | <tt>freesList t</tt> is the list of all free variables of <tt>t</tt>.
freesList :: HasFrees t => t -> [LVar]

-- | <tt>frees t</tt> is the sorted and duplicate-free list of all free
--   variables in <tt>t</tt>.
frees :: HasFrees t => t -> [LVar]

-- | <tt>someInst t</tt> returns an instance of <tt>t</tt> where all free
--   variables whose binding is not yet determined by the caller are
--   replaced with fresh variables.
someInst :: (MonadFresh m, MonadBind LVar LVar m, HasFrees t) => t -> m t

-- | <tt>rename t</tt> replaces all variables in <tt>t</tt> with fresh
--   variables. Note that the result is not guaranteed to be equal for
--   terms that are equal modulo changing the indices of variables.
rename :: (MonadFresh m, HasFrees a) => a -> m a

-- | <tt>eqModuloFreshness t1 t2</tt> checks whether <tt>t1</tt> is equal
--   to <tt>t2</tt> modulo renaming of indices of free variables. Note that
--   the normal form is not unique with respect to AC symbols.
eqModuloFreshnessNoAC :: (HasFrees a, Eq a) => a -> a -> Bool

-- | <tt>avoid t</tt> computes a <a>FreshState</a> that avoids generating
--   variables occurring in <tt>t</tt>.
avoid :: HasFrees t => t -> FreshState

-- | <tt>m <a>evalFreshAvoiding</a> t</tt> evaluates the monadic action
--   <tt>m</tt> with a fresh-variable supply that avoids generating
--   variables occurring in <tt>t</tt>.
evalFreshAvoiding :: HasFrees t => Fresh a -> t -> a

-- | <tt>m <a>evalFreshTAvoiding</a> t</tt> evaluates the monadic action
--   <tt>m</tt> in the underlying monad with a fresh-variable supply that
--   avoids generating variables occurring in <tt>t</tt>.
evalFreshTAvoiding :: (Monad m, HasFrees t) => FreshT m a -> t -> m a

-- | <tt>s <a>renameAvoiding</a> t</tt> replaces all free variables in
--   <tt>s</tt> by fresh variables avoiding variables in <tt>t</tt>.
renameAvoiding :: (HasFrees s, HasFrees t) => s -> t -> s

-- | <tt>avoidPrecise t</tt> computes a <a>FreshState</a> that avoids
--   generating variables occurring in <tt>t</tt>.
avoidPrecise :: HasFrees t => t -> FreshState

-- | <tt>renamePrecise t</tt> replaces all variables in <tt>t</tt> with
--   fresh variables. If <a>PreciseFresh</a> is used with non-AC terms and
--   identical fresh state, the same result is returned for two terms that
--   only differ in the indices of variables.
renamePrecise :: (MonadFresh m, HasFrees a) => a -> m a
renameDropNamehint :: (MonadFresh m, MonadBind LVar LVar m, HasFrees a) => a -> m a

-- | Returns the variables occuring in <tt>t</tt> together with the
--   contexts they appear in. Note that certain contexts (and variables
--   only occuring in such contexts) are ignored by this function. The
--   function is used to <a>guess</a> renamings of variables, i.e., if t is
--   a renaming of s, then variables that occur in equal contexts in t and
--   s are probably renamings of each other.
varOccurences :: HasFrees a => a -> [(LVar, Set Occurence)]

-- | Bound and free variables.
data BVar v

-- | A bound variable in De-Brujin notation.
Bound :: Integer -> BVar v

-- | A free variable.
Free :: v -> BVar v

-- | <a>LVar</a>s combined with quantified variables. They occur only in
--   <tt>LFormula</tt>s.
type BLVar = BVar LVar

-- | Terms built over names and <a>LVar</a>s combined with quantified
--   variables.
type BLTerm = NTerm BLVar

-- | Fold a possibly bound variable.
foldBVar :: (Integer -> a) -> (v -> a) -> BVar v -> a

-- | Extract the name of free variable under the assumption the variable is
--   guaranteed to be of the form <tt>Free a</tt>.
fromFree :: BVar v -> v

-- | Pretty print a <a>LVar</a>.
prettyLVar :: Document d => LVar -> d

-- | Pretty print a <a>NodeId</a>.
prettyNodeId :: Document d => NodeId -> d

-- | Pretty print an <tt>NTerm</tt>.
prettyNTerm :: (Show v, Document d) => NTerm v -> d

-- | Pretty print an <tt>LTerm</tt>.
prettyLNTerm :: Document d => LNTerm -> d
instance NFData v_1627517040 => NFData (BVar v_1627517040)
instance NFData LVar
instance NFData LSort
instance NFData Name
instance NFData NameTag
instance Binary v_1627517040 => Binary (BVar v_1627517040)
instance Binary LVar
instance Binary LSort
instance Binary Name
instance Binary NameTag
instance Typeable LSort
instance Typeable NameId
instance Typeable NameTag
instance Typeable Name
instance Typeable LVar
instance Typeable1 BVar
instance Eq LSort
instance Ord LSort
instance Show LSort
instance Enum LSort
instance Bounded LSort
instance Data LSort
instance Eq NameId
instance Ord NameId
instance Data NameId
instance NFData NameId
instance Binary NameId
instance Eq NameTag
instance Ord NameTag
instance Show NameTag
instance Data NameTag
instance Eq Name
instance Ord Name
instance Data Name
instance Data LVar
instance Eq v => Eq (BVar v)
instance Ord v => Ord (BVar v)
instance Show v => Show (BVar v)
instance Data v => Data (BVar v)
instance (Ord k, HasFrees k, HasFrees v) => HasFrees (Map k v)
instance (Ord a, HasFrees a) => HasFrees (Set a)
instance HasFrees a => HasFrees (Conj a)
instance HasFrees a => HasFrees (Disj a)
instance HasFrees a => HasFrees [a]
instance (HasFrees a, HasFrees b, HasFrees c) => HasFrees (a, b, c)
instance (HasFrees a, HasFrees b) => HasFrees (a, b)
instance (HasFrees a, HasFrees b) => HasFrees (Either a b)
instance HasFrees a => HasFrees (Maybe a)
instance HasFrees Char
instance HasFrees Bool
instance HasFrees Integer
instance HasFrees Int
instance HasFrees ()
instance HasFrees a => HasFrees (RRule a)
instance HasFrees a => HasFrees (Match a)
instance HasFrees a => HasFrees (Equal a)
instance (HasFrees l, Ord l) => HasFrees (Term l)
instance HasFrees v => HasFrees (BVar v)
instance HasFrees v => HasFrees (Lit c v)
instance HasFrees LVar
instance IsVar LVar
instance Show LVar
instance Ord LVar
instance Eq LVar
instance Monad BVar
instance Applicative BVar
instance Traversable BVar
instance Foldable BVar
instance Functor BVar
instance Show NameId
instance Show Name
instance IsConst Name


-- | Builtin function symbols and signatures.
module Term.Builtin.Signature

-- | Binary builtin function symbols.
sdecSym :: NoEqSym

-- | Binary builtin function symbols.
signSym :: NoEqSym

-- | Binary builtin function symbols.
aencSym :: NoEqSym

-- | Binary builtin function symbols.
adecSym :: NoEqSym

-- | Binary builtin function symbols.
sencSym :: NoEqSym

-- | Ternary builtin function symbols.
verifySym :: NoEqSym

-- | Unary builtin function symbols.
pkSym :: NoEqSym

-- | Unary builtin function symbols.
hashSym :: NoEqSym

-- | Nullary builtin function symbols.
trueSym :: NoEqSym

-- | The signature for symmetric encryption.
symEncFunSig :: NoEqFunSig

-- | The signature for asymmetric encryption.
asymEncFunSig :: NoEqFunSig

-- | The signature for cryptographic signatures.
signatureFunSig :: NoEqFunSig

-- | The signature for hashing.
hashFunSig :: NoEqFunSig


-- | Convenience abbreviations, mostly used for testing and debugging.
module Term.Builtin.Convenience
(*:) :: Ord a => Term a -> Term a -> Term a
(#) :: Ord a => Term a -> Term a -> Term a
adec :: Ord a => (Term a, Term a) -> Term a
sign :: Ord a => (Term a, Term a) -> Term a
senc :: Ord a => (Term a, Term a) -> Term a
sdec :: Ord a => (Term a, Term a) -> Term a
aenc :: Ord a => (Term a, Term a) -> Term a
verify :: Ord a => (Term a, Term a, Term a) -> Term a
pk :: Ord a => Term a -> Term a
trueC :: Ord a => Term a
var :: String -> Integer -> LNTerm
x0 :: LNTerm
x10 :: LNTerm
x9 :: LNTerm
x8 :: LNTerm
x7 :: LNTerm
x6 :: LNTerm
x5 :: LNTerm
x4 :: LNTerm
x3 :: LNTerm
x2 :: LNTerm
x1 :: LNTerm
y0 :: LNTerm
y9 :: LNTerm
y8 :: LNTerm
y7 :: LNTerm
y6 :: LNTerm
y5 :: LNTerm
y4 :: LNTerm
y3 :: LNTerm
y2 :: LNTerm
y1 :: LNTerm
freshVar :: String -> Integer -> LNTerm
fx0 :: LNTerm
fx10 :: LNTerm
fx9 :: LNTerm
fx8 :: LNTerm
fx7 :: LNTerm
fx6 :: LNTerm
fx5 :: LNTerm
fx4 :: LNTerm
fx3 :: LNTerm
fx2 :: LNTerm
fx1 :: LNTerm
pubVar :: String -> Integer -> LNTerm
px0 :: LNTerm
px10 :: LNTerm
px9 :: LNTerm
px8 :: LNTerm
px7 :: LNTerm
px6 :: LNTerm
px5 :: LNTerm
px4 :: LNTerm
px3 :: LNTerm
px2 :: LNTerm
px1 :: LNTerm
lx1 :: LVar
lx10 :: LVar
lx9 :: LVar
lx8 :: LVar
lx7 :: LVar
lx6 :: LVar
lx5 :: LVar
lx4 :: LVar
lx3 :: LVar
lx2 :: LVar
f1 :: LNTerm
f9 :: LNTerm
f8 :: LNTerm
f7 :: LNTerm
f6 :: LNTerm
f5 :: LNTerm
f4 :: LNTerm
f3 :: LNTerm
f2 :: LNTerm
p1 :: LNTerm
p9 :: LNTerm
p8 :: LNTerm
p7 :: LNTerm
p6 :: LNTerm
p5 :: LNTerm
p4 :: LNTerm
p3 :: LNTerm
p2 :: LNTerm
lv1 :: LVar
lv9 :: LVar
lv8 :: LVar
lv7 :: LVar
lv6 :: LVar
lv5 :: LVar
lv4 :: LVar
lv3 :: LVar
lv2 :: LVar
v1 :: LNTerm
v9 :: LNTerm
v8 :: LNTerm
v7 :: LNTerm
v6 :: LNTerm
v5 :: LNTerm
v4 :: LNTerm
v3 :: LNTerm
v2 :: LNTerm
li1 :: LVar
li9 :: LVar
li8 :: LVar
li7 :: LVar
li6 :: LVar
li5 :: LVar
li4 :: LVar
li3 :: LVar
li2 :: LVar
i1 :: LNTerm
i9 :: LNTerm
i8 :: LNTerm
i7 :: LNTerm
i6 :: LNTerm
i5 :: LNTerm
i4 :: LNTerm
i3 :: LNTerm
i2 :: LNTerm


-- | Subterm rewriting rules.
module Term.SubtermRule

-- | The righthand-side of a subterm rewrite rule. Does not enforce that
--   the term for RhsGround must be ground.
data StRhs
RhsGround :: LNTerm -> StRhs
RhsPosition :: Position -> StRhs

-- | A subterm rewrite rule.
data StRule
StRule :: LNTerm -> StRhs -> StRule

-- | Convert a rewrite rule to a subterm rewrite rule if possible.
rRuleToStRule :: RRule LNTerm -> Maybe StRule

-- | Convert a subterm rewrite rule to a rewrite rule.
stRuleToRRule :: StRule -> RRule LNTerm

-- | Pretty print an <a>StRule</a>
prettyStRule :: HighlightDocument d => StRule -> d
instance NFData StRule
instance NFData StRhs
instance Binary StRule
instance Binary StRhs
instance Show StRhs
instance Ord StRhs
instance Eq StRhs
instance Show StRule
instance Ord StRule
instance Eq StRule


-- | Builtin rewriting rules.
module Term.Builtin.Rules

-- | A rewrite rule.
data RRule a
RRule :: a -> a -> RRule a

-- | The rewriting rules for Diffie-Hellman. This is a presentation due to
--   Lankford with the finite variant property.
dhRules :: Set (RRule LNTerm)

-- | The rewriting rules for bilinear pairing. These rules extend the the
--   rules for Diffie-Hellman.
bpRules :: Set (RRule LNTerm)

-- | The rewriting rules for multisets.
msetRules :: Set (RRule LNTerm)

-- | The rewriting rules for standard subterm operators that are builtin.
pairRules :: Set (StRule)

-- | The rewriting rules for standard subterm operators that are builtin.
symEncRules :: Set (StRule)

-- | The rewriting rules for standard subterm operators that are builtin.
asymEncRules :: Set (StRule)

-- | The rewriting rules for standard subterm operators that are builtin.
signatureRules :: Set (StRule)


-- | Equational signatures for Maude.
module Term.Maude.Signature

-- | The required information to define a <tt>Maude functional module</tt>.
data MaudeSig
enableDH :: MaudeSig -> Bool
enableBP :: MaudeSig -> Bool
enableMSet :: MaudeSig -> Bool

-- | function signature for subterm theory
stFunSyms :: MaudeSig -> Set NoEqSym

-- | rewriting rules for subterm theory
stRules :: MaudeSig -> Set StRule

-- | function signature including the function symbols for DH, BP, and
--   Multiset can be computed from enableX and stFunSyms
funSyms :: MaudeSig -> FunSig

-- | irreducible function symbols (can be computed)
irreducibleFunSyms :: MaudeSig -> FunSig

-- | Returns all rewriting rules including the rules for DH, BP, and
--   multiset.
rrulesForMaudeSig :: MaudeSig -> Set (RRule LNTerm)

-- | Non-AC function symbols.
noEqFunSyms :: MaudeSig -> NoEqFunSig

-- | Maude signatures for the AC symbols.
dhMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
pairMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
asymEncMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
symEncMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
signatureMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
hashMaudeSig :: MaudeSig

-- | Maude signatures for the AC symbols.
msetMaudeSig :: MaudeSig

-- | Maude signatures for the AC symbols.
bpMaudeSig :: MaudeSig

-- | The minimal maude signature.
minimalMaudeSig :: MaudeSig

-- | Add function symbol to given maude signature.
addFunSym :: NoEqSym -> MaudeSig -> MaudeSig

-- | Add subterm rule to given maude signature.
addStRule :: StRule -> MaudeSig -> MaudeSig
prettyMaudeSig :: HighlightDocument d => MaudeSig -> d
instance NFData MaudeSig
instance Binary MaudeSig
instance Ord MaudeSig
instance Show MaudeSig
instance Eq MaudeSig
instance Monoid MaudeSig


-- | Standard and fresh substitutions.
module Term.Substitution

-- | <tt>composeVFresh s1 s2</tt> composes the fresh substitution s1 and
--   the free substitution s2. The result is the fresh substitution s =
--   s1.s2.
composeVFresh :: (IsConst c, Show (Lit c LVar)) => LSubstVFresh c -> LSubst c -> LSubstVFresh c

-- | <tt>freshToFree s</tt> converts the bound variables in <tt>s</tt> to
--   free variables using fresh variable names. We try to preserve
--   variables names if possible.
freshToFree :: (MonadFresh m, IsConst c) => SubstVFresh c LVar -> m (Subst c LVar)

-- | <tt>freshToFreeAvoiding s t</tt> converts all fresh variables in the
--   range of <tt>s</tt> to free variables avoiding free variables in
--   <tt>t</tt>. This function tries to reuse variable names from the
--   domain of the substitution if possible.
freshToFreeAvoiding :: (HasFrees t, IsConst c) => SubstVFresh c LVar -> t -> Subst c LVar

-- | <tt>freshToFreeAvoidingFast s t</tt> converts all fresh variables in
--   the range of <tt>s</tt> to free variables avoiding free variables in
--   <tt>t</tt>. This function does not try to reuse variable names from
--   the domain of the substitution.
freshToFreeAvoidingFast :: (HasFrees t, Ord c) => LSubstVFresh c -> t -> LSubst c

-- | <tt>freeToFreshRaw s</tt> considers all variables in the range of
--   <tt>s</tt> as fresh.
freeToFreshRaw :: Subst c LVar -> SubstVFresh c LVar

-- | We use the data type <tt>Subst c v</tt> of substitutions. <tt>c</tt>
--   is the type of constants and <tt>v</tt> the type of variables.
newtype Subst c v
Subst :: Map v (VTerm c v) -> Subst c v
sMap :: Subst c v -> Map v (VTerm c v)

-- | <tt>applyVTerm subst t</tt> applies the substitution <tt>subst</tt> to
--   the term <tt>t</tt>.
applyVTerm :: (IsConst c, IsVar v, Ord c) => Subst c v -> VTerm c v -> VTerm c v

-- | <tt>applyLit subst l</tt> applies the substitution <tt>subst</tt> to
--   the literal <tt>l</tt>.
applyLit :: IsVar v => Subst c v -> Lit c v -> VTerm c v

-- | Convert a list to a substitution. The <tt>x/x</tt> mappings are
--   removed.
substFromList :: IsVar v => [(v, VTerm c v)] -> Subst c v

-- | Convert a map to a substitution. The <tt>x/x</tt> mappings are
--   removed. FIXME: implement directly, use substFromMap for
--   substFromList.
substFromMap :: IsVar v => Map v (VTerm c v) -> Subst c v

-- | <tt>emptySubVFree</tt> is the substitution with empty domain.
emptySubst :: Subst c v

-- | <tt>compose s1 s2</tt> composes the substitutions s1 and s2. The
--   result is <tt>s1.s2</tt>, i.e., it has the same effect as <tt>(t s2)
--   s1 = s1(s2(t))</tt> when applied to a term <tt>t</tt>.
compose :: (IsConst c, IsVar v) => Subst c v -> Subst c v -> Subst c v

-- | <tt>applySubst subst subst'</tt> applies the substitution
--   <tt>subst</tt> to the range of the substitution <tt>subst'</tt>.
applySubst :: (IsConst c, IsVar v) => Subst c v -> Subst c v -> Subst c v

-- | <tt>restrict vars subst</tt> restricts the domain of the substitution
--   <tt>subst</tt> to <tt>vars</tt>.
restrict :: IsVar v => [v] -> Subst c v -> Subst c v

-- | <tt>mapRange f subst</tt> maps the function <tt>f</tt> over the range
--   of the substitution <tt>subst</tt>.
mapRange :: (IsConst c, IsVar v, IsConst c2) => (VTerm c v -> VTerm c2 v) -> Subst c v -> Subst c2 v

-- | <tt>varsRange subst</tt> returns all variables in the range of the
--   substitution.
varsRange :: IsVar v => Subst c v -> [v]

-- | <tt>dom subst</tt> returns the domain of the substitution
--   <tt>substs</tt>.
dom :: Subst c v -> [v]

-- | <tt>range subst</tt> returns the range of the substitution
--   <tt>substs</tt>.
range :: Subst c v -> [VTerm c v]

-- | Returns the image of <tt>i</tt> under <tt>subst</tt> if <tt>i</tt> is
--   in the domain of <tt>subst</tt>.
imageOf :: IsVar v => Subst c v -> v -> Maybe (VTerm c v)

-- | <tt>substToPairOn vs sigma</tt> converts the list of variables
--   <tt>[x1,..,xk]</tt> to <tt>[sigma(x1),..,sigma(xk)]</tt>.
substToListOn :: (IsConst c, IsVar v) => [v] -> Subst c v -> [VTerm c v]

-- | Convert substitution to list.
substToList :: Subst c v -> [(v, VTerm c v)]

-- | Types that support the application of <a>LSubst</a>s.
class Apply t
apply :: Apply t => LNSubst -> t -> t

-- | Pretty print a substitution.
prettySubst :: (Ord c, Ord v, HighlightDocument d, Show c, Show v) => (v -> d) -> (Lit c v -> d) -> Subst c v -> [d]

-- | A substitution for logical variables.
type LSubst c = Subst c LVar

-- | A substitution with names and logical variables.
type LNSubst = Subst Name LVar

-- | Pretty print a substitution with logical variables.
prettyLNSubst :: (Show (Lit c LVar), Ord c, HighlightDocument d, Show c) => LSubst c -> d

-- | We use the data type <tt>SubstVFresh c v</tt> of substitutions.
--   <tt>c</tt> denotes the type of constants and <tt>v</tt> the type of
--   variables. Fresh substitutions cannot be applied directly, they have
--   to be converted to free substitutions in a certain context
--   (MonadFresh).
newtype SubstVFresh c v
SubstVFresh :: Map v (VTerm c v) -> SubstVFresh c v
svMap :: SubstVFresh c v -> Map v (VTerm c v)

-- | Convert a list of mappings to a fresh substitution.
substFromListVFresh :: IsVar v => [(v, VTerm c v)] -> SubstVFresh c v

-- | <tt>emptySubstVFresh</tt> is the fresh substitution with empty domain.
emptySubstVFresh :: SubstVFresh c v

-- | <tt>restrictVFresh vars subst</tt> restricts the domain of the
--   substitution <tt>subst</tt> to <tt>vars</tt>.
restrictVFresh :: IsVar v => [v] -> SubstVFresh c v -> SubstVFresh c v

-- | <tt>mapRangeVFresh f subst</tt> maps the function <tt>f</tt> over the
--   range of the substitution <tt>subst</tt>. Note that all introduced
--   variables are considered fresh.
mapRangeVFresh :: (IsConst c, IsVar v, IsConst c2) => (VTerm c v -> VTerm c2 v) -> SubstVFresh c v -> SubstVFresh c2 v

-- | <tt>extendWithRenaming vs s</tt> extends the substitution <tt>s</tt>
--   with renamings (with fresh variables) for the variables in <tt>vs</tt>
--   that are not already in <tt>dom s</tt>.
extendWithRenaming :: (Ord c, Show (Lit c LVar)) => [LVar] -> SubstVFresh c LVar -> SubstVFresh c LVar

-- | <tt>varsRangeVFresh subst</tt> returns all variables in the range of
--   the substitution
varsRangeVFresh :: IsVar v => SubstVFresh c v -> [v]

-- | <tt>domVFresh subst</tt> returns the domain of the substitution
--   <tt>substs</tt>.
domVFresh :: SubstVFresh c v -> [v]

-- | <tt>rangeVFresh subst</tt> returns the range of the substitution
--   <tt>substs</tt>.
rangeVFresh :: SubstVFresh c v -> [VTerm c v]

-- | Returns <tt>True</tt> if the substitution is a renaming.
isRenaming :: LSubstVFresh c -> Bool

-- | Returns the image of <tt>i</tt> under <tt>subst</tt> if <tt>i</tt> is
--   in the domain of <tt>subst</tt>.
imageOfVFresh :: IsVar v => SubstVFresh c v -> v -> Maybe (VTerm c v)

-- | Convert substitution to list.
substToListVFresh :: SubstVFresh c v -> [(v, VTerm c v)]

-- | Pretty print a substitution.
prettySubstVFresh :: (Ord c, Ord v, HighlightDocument d, Show c, Show v) => (v -> d) -> (Lit c v -> d) -> SubstVFresh c v -> [d]

-- | <tt>renameFresh s</tt> renames the fresh variables in <tt>s</tt> using
--   fresh variables. This function can be used to prevent overshadowing
--   which might make output hard to read.
renameFresh :: (Ord c, MonadFresh m) => SubstVFresh c LVar -> m (SubstVFresh c LVar)

-- | <tt>renameFreshAvoiding s t</tt> renames the fresh variables in the
--   range of <tt>s</tt> away from variables that are free in <tt>t</tt>.
--   This is an internal function.
renameFreshAvoiding :: (Ord c, HasFrees t) => LSubstVFresh c -> t -> SubstVFresh c LVar

-- | <tt>removeRenamings s</tt> removes all renamings (see
--   <a>isRenamedVar</a>) from <tt>s</tt>.
removeRenamings :: LSubstVFresh c -> LSubstVFresh c

-- | Fresh substitution with logical variables
type LSubstVFresh c = SubstVFresh c LVar

-- | Fresh substitution with logical variables and names
type LNSubstVFresh = SubstVFresh Name LVar

-- | Pretty print a substitution with logical variables.
prettyLSubstVFresh :: (Show (Lit c LVar), Ord c, HighlightDocument d, Show c) => LSubstVFresh c -> d

-- | Pretty print a disjunction of substitutions.
prettyDisjLNSubstsVFresh :: Document d => Disj LNSubstVFresh -> d


-- | Types for communicating with Maude.
module Term.Maude.Types
data MaudeLit
MaudeVar :: Integer -> LSort -> MaudeLit
FreshVar :: Integer -> LSort -> MaudeLit
MaudeConst :: Integer -> LSort -> MaudeLit
type MSubst = [((LSort, Integer), MTerm)]
type MTerm = Term MaudeLit

-- | Convert an <tt>LNTerm</tt> with arbitrary names to an <tt>MTerm</tt>.
lTermToMTerm :: (MonadBind (Lit c LVar) MaudeLit m, MonadFresh m, Show c, Show (Lit c LVar), Ord c) => (c -> LSort) -> VTerm c LVar -> m MTerm

-- | Convert an <tt>LNTerm</tt> to an <tt>MTerm</tt>.
lTermToMTerm' :: (MonadBind (Lit Name LVar) MaudeLit m, MonadFresh m) => LNTerm -> m MTerm

-- | Convert an <a>MTerm</a> to an <a>LNTerm</a> under the assumption that
--   the bindings for the constants are already available.
mTermToLNTerm :: (MonadBind MaudeLit (Lit c LVar) m, MonadFresh m, Show (Lit c LVar), Ord c, Show c) => String -> MTerm -> m (VTerm c LVar)

-- | Run a <tt>BindT (Lit c LVar) MaudeLit Fresh</tt> computation with an
--   empty fresh supply and an empty binding map and return the result and
--   the resulting inverted binding map.
runConversion :: Ord c => BindT (Lit c LVar) MaudeLit Fresh a -> (a, Map MaudeLit (Lit c LVar))

-- | <tt>msubstToLSubstVFresh bindings substMaude</tt> converts a
--   substitution returned by Maude to a <tt>VFresh</tt> substitution. It
--   expects that the range of the maude substitution contains only fresh
--   variables in its range and raises an error otherwise.
msubstToLSubstVFresh :: (Ord c, Show (Lit c LVar), Show c) => Map MaudeLit (Lit c LVar) -> MSubst -> SubstVFresh c LVar

-- | <tt>msubstToLSubstVFree bindings substMaude</tt> converts a
--   substitution returned by Maude to a <tt>VFree</tt> substitution. It
--   expects that the maude substitution contains no fresh variables in its
--   range and raises an error otherwise.
msubstToLSubstVFree :: (Ord c, Show (Lit c LVar), Show c) => Map MaudeLit (Lit c LVar) -> MSubst -> Subst c LVar
instance Eq MaudeLit
instance Ord MaudeLit
instance Show MaudeLit


-- | Pretty printing and parsing of Maude terms and replies.
module Term.Maude.Parser

-- | <tt>ppMaude t</tt> pretty prints the term <tt>t</tt> for Maude.
ppMaude :: Term MaudeLit -> ByteString

-- | The term algebra and rewriting rules as a functional module in Maude.
ppTheory :: MaudeSig -> ByteString

-- | <tt>parseUnifyReply reply</tt> takes a <tt>reply</tt> to a unification
--   query returned by Maude and extracts the unifiers.
parseUnifyReply :: MaudeSig -> ByteString -> Either String [MSubst]

-- | <tt>parseMatchReply reply</tt> takes a <tt>reply</tt> to a match query
--   returned by Maude and extracts the unifiers.
parseMatchReply :: MaudeSig -> ByteString -> Either String [MSubst]

-- | <tt>parseReduceReply l</tt> parses a single solution returned by
--   Maude.
parseReduceReply :: MaudeSig -> ByteString -> Either String MTerm


-- | AC-unification of DH terms using Maude as a backend.
module Term.Maude.Process

-- | A handle to a Maude process. It requires the Maude path for Signatures
--   to be serializable. If we also add the string for the Maude config
--   file, then it would even be serializable on its own.
data MaudeHandle
MaudeHandle :: FilePath -> MaudeSig -> MVar MaudeProcess -> MaudeHandle
mhFilePath :: MaudeHandle -> FilePath
mhMaudeSig :: MaudeHandle -> MaudeSig
mhProc :: MaudeHandle -> MVar MaudeProcess

-- | <tt>startMaude</tt> starts a new instance of Maude and returns a
--   Handle to it.
startMaude :: FilePath -> MaudeSig -> IO MaudeHandle

-- | <tt>getMaudeStats</tt> returns the maude stats formatted as a string.
getMaudeStats :: MaudeHandle -> IO String

-- | <tt>unifyViaMaude hnd eqs</tt> computes all AC unifiers of
--   <tt>eqs</tt> using the Maude process <tt>hnd</tt>.
unifyViaMaude :: (IsConst c, Show (Lit c LVar), Ord c) => MaudeHandle -> (c -> LSort) -> [Equal (VTerm c LVar)] -> IO [SubstVFresh c LVar]

-- | <tt>matchViaMaude (t, p)</tt> computes a complete set of AC matchers
--   of the term <tt>t</tt> to the pattern <tt>p</tt> via Maude.
matchViaMaude :: (IsConst c, Show (Lit c LVar), Ord c) => MaudeHandle -> (c -> LSort) -> Match (VTerm c LVar) -> IO [Subst c LVar]

-- | <tt>normViaMaude t</tt> normalizes the term t via Maude.
normViaMaude :: (IsConst c, Show (Lit c LVar), Ord c) => MaudeHandle -> (c -> LSort) -> VTerm c LVar -> IO (VTerm c LVar)

-- | Values that depend on a <a>MaudeHandle</a>.
type WithMaude = Reader MaudeHandle


-- | AC unification based on maude and free unification.
module Term.Unification

-- | <tt>unifyLNTerm eqs</tt> returns a complete set of unifiers for
--   <tt>eqs</tt> modulo AC.
unifyLTerm :: (IsConst c, Show (Lit c LVar), Ord c) => (c -> LSort) -> [Equal (LTerm c)] -> WithMaude [SubstVFresh c LVar]

-- | <tt>unifyLNTerm eqs</tt> returns a complete set of unifiers for
--   <tt>eqs</tt> modulo AC.
unifyLNTerm :: [Equal LNTerm] -> WithMaude [SubstVFresh Name LVar]

-- | <a>True</a> iff the terms are unifiable.
unifiableLNTerms :: LNTerm -> LNTerm -> WithMaude Bool

-- | <tt>unifyLTerm sortOf eqs</tt> returns a complete set of unifiers for
--   <tt>eqs</tt> modulo AC.
unifyLTermFactored :: (IsConst c, Show (Lit c LVar), Ord c) => (c -> LSort) -> [Equal (LTerm c)] -> WithMaude (LSubst c, [SubstVFresh c LVar])

-- | <tt>unifyLTerm sortOf eqs</tt> returns a complete set of unifiers for
--   <tt>eqs</tt> modulo AC.
unifyLNTermFactored :: [Equal LNTerm] -> WithMaude (LNSubst, [SubstVFresh Name LVar])

-- | Match an <a>LVar</a> term to an <a>LVar</a> pattern.
matchLVar :: LVar -> LVar -> Match (LTerm c)

-- | <tt>solveMatchLNTerm sortOf eqs</tt> returns a complete set of
--   matchers for <tt>eqs</tt> modulo AC.
solveMatchLTerm :: (IsConst c, Show (Lit c LVar), Ord c) => (c -> LSort) -> Match (LTerm c) -> WithMaude [Subst c LVar]

-- | <tt>solveMatchLNTerm eqs</tt> returns a complete set of matchers for
--   <tt>eqs</tt> modulo AC.
solveMatchLNTerm :: Match LNTerm -> WithMaude [Subst Name LVar]

-- | A handle to a Maude process. It requires the Maude path for Signatures
--   to be serializable. If we also add the string for the Maude config
--   file, then it would even be serializable on its own.
data MaudeHandle

-- | Values that depend on a <a>MaudeHandle</a>.
type WithMaude = Reader MaudeHandle

-- | <tt>startMaude</tt> starts a new instance of Maude and returns a
--   Handle to it.
startMaude :: FilePath -> MaudeSig -> IO MaudeHandle

-- | <tt>getMaudeStats</tt> returns the maude stats formatted as a string.
getMaudeStats :: MaudeHandle -> IO String
mhMaudeSig :: MaudeHandle -> MaudeSig
mhFilePath :: MaudeHandle -> FilePath

-- | The required information to define a <tt>Maude functional module</tt>.
data MaudeSig
enableDH :: MaudeSig -> Bool
enableBP :: MaudeSig -> Bool
enableMSet :: MaudeSig -> Bool

-- | The minimal maude signature.
minimalMaudeSig :: MaudeSig

-- | Maude signatures for the AC symbols.
dhMaudeSig :: MaudeSig

-- | Maude signatures for the AC symbols.
bpMaudeSig :: MaudeSig

-- | Maude signatures for the AC symbols.
msetMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
pairMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
symEncMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
asymEncMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
signatureMaudeSig :: MaudeSig

-- | Maude signatures for the default subterm symbols.
hashMaudeSig :: MaudeSig

-- | Returns all rewriting rules including the rules for DH, BP, and
--   multiset.
rrulesForMaudeSig :: MaudeSig -> Set (RRule LNTerm)

-- | function signature for subterm theory
stFunSyms :: MaudeSig -> Set NoEqSym

-- | function signature including the function symbols for DH, BP, and
--   Multiset can be computed from enableX and stFunSyms
funSyms :: MaudeSig -> FunSig

-- | rewriting rules for subterm theory
stRules :: MaudeSig -> Set StRule

-- | irreducible function symbols (can be computed)
irreducibleFunSyms :: MaudeSig -> FunSig

-- | Non-AC function symbols.
noEqFunSyms :: MaudeSig -> NoEqFunSig

-- | Add function symbol to given maude signature.
addFunSym :: NoEqSym -> MaudeSig -> MaudeSig

-- | Add subterm rule to given maude signature.
addStRule :: StRule -> MaudeSig -> MaudeSig
instance Error MatchFailure


-- | Subsumption of terms and substitutions.
module Term.Subsumption

-- | Compare terms <tt>t1</tt> and <tt>t2</tt> with respect to the
--   subsumption order modulo AC.
compareTermSubs :: LNTerm -> LNTerm -> WithMaude (Maybe Ordering)

-- | Returns True if <tt>s1</tt> and <tt>s2</tt> are equal with respect to
--   the subsumption order modulo AC.
eqTermSubs :: LNTerm -> LNTerm -> WithMaude Bool
factorSubstVia :: [LVar] -> LNSubst -> LNSubst -> WithMaude [LNSubst]

-- | Returns a substitution that is equivalent modulo renaming to the given
--   substitution.
canonizeSubst :: LNSubstVFresh -> LNSubstVFresh

-- | Returns the variables occuring in <tt>t</tt> together with the
--   contexts they appear in. Note that certain contexts (and variables
--   only occuring in such contexts) are ignored by this function. The
--   function is used to <a>guess</a> renamings of variables, i.e., if t is
--   a renaming of s, then variables that occur in equal contexts in t and
--   s are probably renamings of each other.
varOccurences :: HasFrees a => a -> [(LVar, Set Occurence)]


-- | This module implements normalization and normal-form checks of terms.
module Term.Rewriting.Norm

-- | <tt>norm' t</tt> normalizes the term <tt>t</tt> using Maude.
norm' :: LNTerm -> WithMaude LNTerm

-- | <tt>nf' t</tt> returns <tt>True</tt> if the term <tt>t</tt> is in
--   normal form.
nf' :: LNTerm -> WithMaude Bool

-- | <tt>nfSubst s</tt> returns <tt>True</tt> if the substitution
--   <tt>s</tt> is in normal form.
nfSubstVFresh' :: LNSubstVFresh -> WithMaude Bool

-- | <tt>normSubst s</tt> normalizes the substitution <tt>s</tt>.
normSubstVFresh' :: LNSubstVFresh -> WithMaude LNSubstVFresh

-- | Returns all subterms that may be not in normal form.
maybeNotNfSubterms :: MaudeSig -> LNTerm -> [LNTerm]


-- | Completeness and minimality checking for the variants of a term.
module Term.Narrowing.Variants.Check

-- | <tt>checkComplete t substs</tt> checks if <tt>substs</tt> is a
--   complete set of variants for <tt>t</tt> and returns <tt>Just
--   (subst1,subst2)</tt> if there is a narrowing step from <tt>subst1</tt>
--   that yields a new variant <tt>subst2</tt>.
checkComplete :: LNTerm -> [LNSubstVFresh] -> WithMaude Bool

-- | <tt>checkMinimal t substs</tt> checks if <tt>substs</tt> is a minimal
--   set of variants for <tt>t</tt> and returns <tt>False</tt> if there are
--   subst1 /= subst2 in substs with subst1 &lt;=_Var_t subst2.
checkMinimal :: LNTerm -> [LNSubstVFresh] -> WithMaude Bool

-- | <tt>variantsFrom rules t subst</tt> returns all the <a>one-step
--   variants</a> of <tt>norm (t subst)</tt> for the given set of
--   <tt>rules</tt>.
variantsFrom :: LNTerm -> LNSubstVFresh -> WithMaude [LNSubstVFresh]

-- | <tt>isNormalInstance t s s'</tt> returns <tt>True</tt> if
--   <tt>s'(norm(s(t)))</tt> is in normal form.
isNormalInstance :: LNTerm -> LNSubst -> LNSubst -> WithMaude Bool

-- | <tt>leqSubstVariant t s1 s2</tt> compares two substitutions using the
--   variant order with respect to <tt>t</tt> and returns <tt>True</tt> if
--   <tt>s1</tt> is less or equal than <tt>s2</tt> and <tt>False</tt>
--   otherwise. Use the more expensive <tt>compareSubstVariant</tt> which
--   uses two AC matchings instead of one if you also want to distinguish
--   <tt>Nothing</tt>, <tt>Just EQ</tt>, and <tt>Just GT</tt>.
--   
--   s1 is smaller or equal to s2 wrt. to the variant order (less general)
--   iff there is an s1' such that s1 = s2' . s2 restricted to vars(t) and
--   s2'(norm(s2(t))) is in normal form, or equivalently norm(s1(t)) =AC=
--   s2'(norm(s2(1))). This means s1 is redundant since it is just an AC
--   instance of s2 that does not <a>require additional normalization
--   steps.</a>
leqSubstVariant :: LNTerm -> LNSubstVFresh -> LNSubstVFresh -> WithMaude Bool


-- | Computing the variants of a term.
module Term.Narrowing.Variants.Compute

-- | <tt>computeVariants t d</tt> compute the variants of term <tt>t</tt>
--   with bound <tt>d</tt>. The rewriting rules are taken from the Maude
--   context.
computeVariantsBound :: LNTerm -> Maybe Int -> WithMaude (Maybe [LNSubstVFresh])

-- | <tt>variantsList ts</tt> computes all variants of <tt>ts</tt>
--   considered as a single term without a bound or symmetry substitution.
--   The rewriting rules are taken from the Maude context.
computeVariants :: LNTerm -> WithMaude [LNSubstVFresh]

-- | <tt>substCompareVariant t s1 t2</tt> compares two substitutions using
--   the variant order with respect to <tt>t</tt>.
compareSubstVariant :: LNTerm -> LNSubstVFresh -> LNSubstVFresh -> WithMaude (Maybe Ordering)
instance Eq Variant
instance Ord Variant
instance Show Variant
instance Sized Variant


-- | Computing and checking the variants of a term.
module Term.Narrowing.Variants

-- | <tt>variantsListCheck ts</tt> computes all variants of <tt>ts</tt>
--   considered as a single term without a bound or symmetry substitution.
--   Before returning the result, it checks if the set of variants is
--   complete and minimal. If that is not the case, it fails with an error
computeVariantsCheck :: LNTerm -> WithMaude [LNSubstVFresh]


-- | Unit tests for the functions dealing with term algebra and related
--   notions.
module Term.UnitTests
testEqual :: (Eq a, Show a) => String -> a -> a -> Test
testTrue :: String -> Bool -> Test
testsMatching :: MaudeHandle -> Test
propMatchSound :: MaudeHandle -> LNTerm -> LNTerm -> Bool
testsUnify :: MaudeHandle -> Test
propUnifySound :: MaudeHandle -> LNTerm -> LNTerm -> Bool
testsSubst :: Test
testsSubs :: MaudeHandle -> Test
ppLTerm :: LNTerm -> String
ppLSubst :: LNSubst -> String
testsNorm :: MaudeHandle -> Test
testsTerm :: Test
propSubtermReplace :: Ord a => Term a -> Position -> (Term a, Term a)
bigTerm :: LNTerm
normBigTerm :: LNTerm
tcompare :: MaudeHandle -> Test
testsVariant :: MaudeHandle -> Test
testsSimple :: MaudeHandle -> Test

-- | All unification infrastructure unit tests.
tests :: FilePath -> IO Test

-- | Maude signatures with all builtin symbols.
allMaudeSig :: MaudeSig
te :: LNTerm
sub4 :: LNSubstVFresh
sub6 :: LNSubstVFresh
sub4' :: LNSubst
sub6' :: LNSubst
tevs :: [LVar]
runTest :: WithMaude a -> IO a
pair :: Ord a => (Term a, Term a) -> Term a
expo :: Ord a => (Term a, Term a) -> Term a
inv :: Term a -> Term a
union :: Ord a => [Term a] -> Term a
mult :: Ord a => [Term a] -> Term a
one :: Term a
