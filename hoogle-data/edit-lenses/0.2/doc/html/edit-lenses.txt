-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Symmetric, stateful edit lenses
--   
--   An implementation of the ideas of the paper <i>Edit Lenses</i>,
--   available at <a>http://dmwit.com/papers/201107EL.pdf</a>.
@package edit-lenses
@version 0.2

module Data.Lens.Bidirectional
class Bidirectional l where { type family L l; type family R l; }

module Data.Lens.Edit.Stateful
class Bidirectional l => Lens l where { type family C l; }
missing :: Lens l => l -> C l
dputr :: Lens l => l -> (L l, C l) -> (R l, C l)
dputl :: Lens l => l -> (R l, C l) -> (L l, C l)
foldState :: Monoid dY => (dX -> c -> (dY, c)) -> ([dX], c) -> (dY, c)

module Data.Lens.Edit.Stateless
class Bidirectional l => Lens l
dputr :: Lens l => l -> L l -> R l
dputl :: Lens l => l -> R l -> L l

module Data.Iso
data Iso a b
Iso :: (a -> b) -> (b -> a) -> Iso a b
instance Show (Iso a b)

module Data.Lens.Edit.Primitive
data Id dX
Id :: Id dX
data Compose k l
Compose :: k -> l -> Compose k l
data ComposeFL k l
ComposeFL :: k -> l -> ComposeFL k l
data ComposeLF k l
ComposeLF :: k -> l -> ComposeLF k l
data Op l
Op :: l -> Op l
data Disconnect dX dY
Disconnect :: Disconnect dX dY
instance Eq (Id dX)
instance Ord (Id dX)
instance Show (Id dX)
instance Read (Id dX)
instance (Eq k, Eq l) => Eq (Compose k l)
instance (Ord k, Ord l) => Ord (Compose k l)
instance (Show k, Show l) => Show (Compose k l)
instance (Read k, Read l) => Read (Compose k l)
instance (Eq k, Eq l) => Eq (ComposeFL k l)
instance (Ord k, Ord l) => Ord (ComposeFL k l)
instance (Show k, Show l) => Show (ComposeFL k l)
instance (Read k, Read l) => Read (ComposeFL k l)
instance (Eq k, Eq l) => Eq (ComposeLF k l)
instance (Ord k, Ord l) => Ord (ComposeLF k l)
instance (Show k, Show l) => Show (ComposeLF k l)
instance (Read k, Read l) => Read (ComposeLF k l)
instance Eq l => Eq (Op l)
instance Ord l => Ord (Op l)
instance Show l => Show (Op l)
instance Read l => Read (Op l)
instance Eq (Disconnect dX dY)
instance Ord (Disconnect dX dY)
instance Show (Disconnect dX dY)
instance Read (Disconnect dX dY)
instance Lens (Iso dX dY)
instance Lens (Iso dX dY)
instance Bidirectional (Iso dX dY)
instance (Monoid dX, Monoid dY) => Lens (Disconnect dX dY)
instance (Monoid dX, Monoid dY) => Lens (Disconnect dX dY)
instance Bidirectional (Disconnect dX dY)
instance Lens l => Lens (Op l)
instance Lens l => Lens (Op l)
instance Bidirectional l => Bidirectional (Op l)
instance (R k ~ L l, Lens k, Lens l) => Lens (ComposeLF k l)
instance (R k ~ L l, Bidirectional k, Bidirectional l) => Bidirectional (ComposeLF k l)
instance (R k ~ L l, Lens k, Lens l) => Lens (ComposeFL k l)
instance (R k ~ L l, Bidirectional k, Bidirectional l) => Bidirectional (ComposeFL k l)
instance (R k ~ L l, Lens k, Lens l) => Lens (Compose k l)
instance (R k ~ L l, Lens k, Lens l) => Lens (Compose k l)
instance (R k ~ L l, Bidirectional k, Bidirectional l) => Bidirectional (Compose k l)
instance Lens (Id dX)
instance Lens (Id dX)
instance Bidirectional (Id dX)

module Data.Module.Class
class (Default (V dX), Monoid dX) => Module dX where { type family V dX; }
apply :: Module dX => dX -> V dX -> Maybe (V dX)
applyDef :: Module dX => dX -> Maybe (V dX)
applyTotal :: Module dX => dX -> V dX -> V dX
applyDefTotal :: Module dX => dX -> V dX
class Default (V_0 dX) => PartialEdit dX where { type family V_0 dX; }
apply_0 :: PartialEdit dX => dX -> V_0 dX -> Maybe (V_0 dX)
instance PartialEdit dX => Module [dX]

module Data.Module.List
data Permutation
Simple :: [Integer] -> Permutation
Complex :: (Integer -> Integer -> Integer) -> Permutation
applyPermutation :: Permutation -> [a] -> [a]
complexPermutation :: Permutation -> Integer -> Integer -> Integer
simplePermutation :: Permutation -> Integer -> [Integer]
data ListAtom dX
FailList :: ListAtom dX
Modify :: Integer -> dX -> ListAtom dX
Insert :: Integer -> ListAtom dX
Delete :: Integer -> ListAtom dX
Rearrange :: Permutation -> ListAtom dX
split3 :: Integer -> [a] -> Maybe ([a], a, [a])
instance Show dX => Show (ListAtom dX)
instance Module dX => PartialEdit (ListAtom dX)
instance Show Permutation

module Data.Module.Primitive
newtype Unit x
Unit :: () -> Unit x
instance Monoid (Unit x)
instance Default x => Module (First x)
instance Default x => Module (Unit x)

module Data.Module.Product
type ProductAtom = Either
instance (Module dX, Module dY) => PartialEdit (ProductAtom dX dY)
instance (Module dX, Module dY) => Module (dX, dY)

module Data.Lens.Edit.Product
data CompactProduct k l
CompactProduct :: k -> l -> CompactProduct k l
data CompactProductFL k l
CompactProductFL :: k -> l -> CompactProductFL k l
data CompactProductLF k l
CompactProductLF :: k -> l -> CompactProductLF k l
data Product k l
Product :: k -> l -> Product k l
data ProductFL k l
ProductFL :: k -> l -> ProductFL k l
data ProductLF k l
ProductLF :: k -> l -> ProductLF k l
instance (Eq k, Eq l) => Eq (CompactProduct k l)
instance (Ord k, Ord l) => Ord (CompactProduct k l)
instance (Show k, Show l) => Show (CompactProduct k l)
instance (Read k, Read l) => Read (CompactProduct k l)
instance (Eq k, Eq l) => Eq (CompactProductFL k l)
instance (Ord k, Ord l) => Ord (CompactProductFL k l)
instance (Show k, Show l) => Show (CompactProductFL k l)
instance (Read k, Read l) => Read (CompactProductFL k l)
instance (Eq k, Eq l) => Eq (CompactProductLF k l)
instance (Ord k, Ord l) => Ord (CompactProductLF k l)
instance (Show k, Show l) => Show (CompactProductLF k l)
instance (Read k, Read l) => Read (CompactProductLF k l)
instance (Eq k, Eq l) => Eq (Product k l)
instance (Ord k, Ord l) => Ord (Product k l)
instance (Show k, Show l) => Show (Product k l)
instance (Read k, Read l) => Read (Product k l)
instance (Eq k, Eq l) => Eq (ProductFL k l)
instance (Ord k, Ord l) => Ord (ProductFL k l)
instance (Show k, Show l) => Show (ProductFL k l)
instance (Read k, Read l) => Read (ProductFL k l)
instance (Eq k, Eq l) => Eq (ProductLF k l)
instance (Ord k, Ord l) => Ord (ProductLF k l)
instance (Show k, Show l) => Show (ProductLF k l)
instance (Read k, Read l) => Read (ProductLF k l)
instance (Lens k, Lens l) => Lens (ProductLF k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (ProductLF k l)
instance (Lens k, Lens l) => Lens (ProductFL k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (ProductFL k l)
instance (Lens k, Lens l) => Lens (Product k l)
instance (Lens k, Lens l) => Lens (Product k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (Product k l)
instance (Lens k, Lens l) => Lens (CompactProductLF k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (CompactProductLF k l)
instance (Lens k, Lens l) => Lens (CompactProductFL k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (CompactProductFL k l)
instance (Lens k, Lens l) => Lens (CompactProduct k l)
instance (Lens k, Lens l) => Lens (CompactProduct k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (CompactProduct k l)

module Data.Module.Sum
data Tag
L :: Tag
R :: Tag
newtype Retag x y
Retag :: (Maybe (Endo Tag)) -> Retag x y
data Sum dX dY
Sum :: (Retag (V dX) (V dY)) -> dX -> dY -> Sum dX dY
data SumAtom dX dY
FailSum :: SumAtom dX dY
SwitchLL :: dX -> SumAtom dX dY
SwitchLR :: dY -> SumAtom dX dY
SwitchRL :: dX -> SumAtom dX dY
SwitchRR :: dY -> SumAtom dX dY
StayL :: dX -> SumAtom dX dY
StayR :: dY -> SumAtom dX dY
instance Eq Tag
instance Ord Tag
instance Bounded Tag
instance Enum Tag
instance Show Tag
instance Read Tag
instance Monoid (Retag x y)
instance (Eq dX, Eq dY) => Eq (SumAtom dX dY)
instance (Ord dX, Ord dY) => Ord (SumAtom dX dY)
instance (Show dX, Show dY) => Show (SumAtom dX dY)
instance (Read dX, Read dY) => Read (SumAtom dX dY)
instance (Module dX, Module dY) => PartialEdit (SumAtom dX dY)
instance (Module dX, Module dY) => Module (Sum dX dY)
instance (Monoid dX, Monoid dY) => Monoid (Sum dX dY)
instance (Default x, Default y) => Module (Retag x y)
instance Eq (Retag x y)
instance Default x => Default (Either x y)

module Data.Lens.Edit.Sum
data CompactSum k l
CompactSum :: k -> l -> CompactSum k l
data SumFL k l
SumFL :: k -> l -> SumFL k l
data CompactSumLF k l
CompactSumLF :: k -> l -> CompactSumLF k l
data Sum k l
Sum :: k -> l -> Sum k l
instance (Eq k, Eq l) => Eq (CompactSum k l)
instance (Ord k, Ord l) => Ord (CompactSum k l)
instance (Show k, Show l) => Show (CompactSum k l)
instance (Read k, Read l) => Read (CompactSum k l)
instance (Eq k, Eq l) => Eq (SumFL k l)
instance (Ord k, Ord l) => Ord (SumFL k l)
instance (Show k, Show l) => Show (SumFL k l)
instance (Read k, Read l) => Read (SumFL k l)
instance (Eq k, Eq l) => Eq (CompactSumLF k l)
instance (Ord k, Ord l) => Ord (CompactSumLF k l)
instance (Show k, Show l) => Show (CompactSumLF k l)
instance (Read k, Read l) => Read (CompactSumLF k l)
instance (Eq k, Eq l) => Eq (Sum k l)
instance (Ord k, Ord l) => Ord (Sum k l)
instance (Show k, Show l) => Show (Sum k l)
instance (Read k, Read l) => Read (Sum k l)
instance (Lens k, Lens l) => Lens (Sum k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (Sum k l)
instance (Lens k, Lens l) => Lens (CompactSumLF k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (CompactSumLF k l)
instance (Lens k, Lens l) => Lens (SumFL k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (SumFL k l)
instance (Lens k, Lens l) => Lens (CompactSum k l)
instance (Lens k, Lens l) => Lens (CompactSum k l)
instance (Bidirectional k, Bidirectional l) => Bidirectional (CompactSum k l)

module Data.Lens.Edit.List
data Map l
Map :: l -> Map l
data Partition dX dY
Partition :: Partition dX dY
instance Eq l => Eq (Map l)
instance Ord l => Ord (Map l)
instance Show l => Show (Map l)
instance Read l => Read (Map l)
instance Eq (Partition dX dY)
instance Ord (Partition dX dY)
instance Show (Partition dX dY)
instance Read (Partition dX dY)
instance (Monoid dX, Monoid dY) => Lens (Partition dX dY)
instance Bidirectional (Partition dX dY)
instance Lens l => Lens (Map l)
instance Lens l => Lens (Map l)
instance Bidirectional l => Bidirectional (Map l)

module Data.Container
class ((V (ShapeModule shape)) ~ shape, Module (ShapeModule shape), PartialOrd shape, Ord (P shape)) => ContainerType shape where { type family P shape; }
live :: ContainerType shape => shape -> Set (P shape)
data Container shape element
Container :: shape -> (P shape -> element) -> Container shape element
currentShape :: Container shape element -> shape
containedValues :: Container shape element -> P shape -> element
instance (Default shape, Default element) => Default (Container shape element)

module Data.Module.Shape
listToContainer :: [a] -> Container Int a
containerToList :: Container Int a -> [a]
instance ContainerType Int
instance PartialOrd Int
instance Module (Sum Int)

module Data.Module

module Data.Module.Container
data ContainerAtom shape dX
FailContainer :: ContainerAtom shape dX
Modify :: (P shape) -> dX -> ContainerAtom shape dX
Insert :: (ShapeModule shape) -> ContainerAtom shape dX
Delete :: (ShapeModule shape) -> ContainerAtom shape dX
Rearrange :: (ShapeModule shape) -> (shape -> P shape -> P shape) -> ContainerAtom shape dX
instance (ContainerType shape, Module dX) => PartialEdit (ContainerAtom shape dX)
instance (Show (P shape), Show (ShapeModule shape), Show dX) => Show (ContainerAtom shape dX)

module Data.Lens.Edit.Container
data Map shape l
Map :: l -> Map shape l
instance Eq l => Eq (Map shape l)
instance Ord l => Ord (Map shape l)
instance Show l => Show (Map shape l)
instance Read l => Read (Map shape l)
instance (ContainerType shape, Lens l) => Lens (Map shape l)
instance (ContainerType shape, Lens l) => Lens (Map shape l)
instance Bidirectional l => Bidirectional (Map shape l)

module Data.Lens.Edit
