-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Web application deployment manager, focusing on Haskell web frameworks
--   
--   Hackage documentation generation is not reliable. For up to date
--   documentation, please see:
--   <a>http://www.stackage.org/package/keter</a>.
@package keter
@version 1.3.10.1

module Keter.LabelMap

-- | A data structure for storing a hierarchical set of domain labels from
--   TLD down, supporting wildcards.
--   
--   Data structure is mutually recursive with <a>LabelEntry</a>, and each
--   level of the tree supports a static assignment for a hostname such as:
--   
--   <pre>
--   example.com
--   </pre>
--   
--   Or a wildcard assignment for a hostname such as:
--   
--   <pre>
--   *.example.com
--   </pre>
--   
--   Or a wildcard assignment with a set of teptions, for example:
--   
--   <pre>
--   *.example.com
--   admin.example.com
--   </pre>
--   
--   And lastly, empty labels are supported so that, of course, an
--   assignment for example.com does not necessarily have any subdomains
--   available. As an example suppose we have the following assigned
--   domains:
--   
--   <pre>
--           example.com
--       foo.example.com
--     *.bar.example.com
--     *.qux.example.com
--   baz.qux.example.com
--   </pre>
--   
--   This will resolve to the following value, with some loose pseudocode
--   notation.
--   
--   <pre>
--   Static (map)
--     'com' -&gt; Unassigned Static (map)
--       'example' -&gt; Assigned a (map)
--          'foo'  -&gt; Assigned a EmptyLabelMap
--          'bar'  -&gt; Unassigned (Wildcard (Assigned a EmptyLabelMap)
--          'qux'  -&gt; Unassigned (WildcardExcept (Assigned a (map)))
--            'baz' -&gt; Assigned a EmptyLabelMap
--   </pre>
--   
--   Note that the hostname "bar.example.com" is unassigned, only the
--   wildcard was set.
data LabelMap a
insert :: ByteString -> a -> LabelMap a -> LabelMap a
delete :: ByteString -> LabelMap a -> LabelMap a
lookup :: ByteString -> LabelMap a -> Maybe a
labelAssigned :: ByteString -> LabelMap a -> Bool
empty :: LabelMap a
instance Eq a => Eq (LabelEntry a)
instance Show (LabelMap a)
instance Eq a => Eq (LabelMap a)
instance Show (LabelEntry a)

module Data.Conduit.Process.Unix

-- | Represents the child process which handles process cleanup.
--   
--   Since 0.2.1
data ProcessTracker

-- | Fork off the child cleanup process.
--   
--   This will ideally only be run once for your entire application.
--   
--   Since 0.2.1
initProcessTracker :: IO ProcessTracker

-- | Abstract type containing information on a process which will be
--   restarted.
data MonitoredProcess

-- | Run the given command, restarting if the process dies.
monitorProcess :: (ByteString -> IO ()) -> ProcessTracker -> Maybe ByteString -> ByteString -> ByteString -> [ByteString] -> [(ByteString, ByteString)] -> (ByteString -> IO ()) -> (ExitCode -> IO Bool) -> IO MonitoredProcess

-- | Terminate the process and prevent it from being restarted.
terminateMonitoredProcess :: MonitoredProcess -> IO ()
instance Typeable ProcessTrackerException
instance Show ProcessTrackerException
instance Exception ProcessTrackerException

module Data.Conduit.LogFile

-- | Represents a folder used for totating log files.
--   
--   Since 0.2.1
data RotatingLog

-- | Create a new <tt>RotatingLog</tt>.
--   
--   Since 0.2.1
openRotatingLog :: FilePath -> Word -> IO RotatingLog
addChunk :: RotatingLog -> ByteString -> IO ()
close :: RotatingLog -> IO ()
defaultMaxTotal :: Word

-- | A <tt>RotatingLog</tt> which performs no logging.
--   
--   Since 0.2.1
dummy :: RotatingLog


-- | Handles allocation of temporary directories and unpacking of bundles
--   into them. Sets owner and group of all created files and directories
--   as necessary.
module Codec.Archive.TempTarball
data TempFolder
setup :: FilePath -> IO TempFolder
unpackTempTar :: Maybe (UserID, GroupID) -> TempFolder -> FilePath -> Text -> (FilePath -> IO a) -> IO a

module Keter.Types.Middleware
data MiddlewareConfig
AcceptOverride :: MiddlewareConfig
Autohead :: MiddlewareConfig
Jsonp :: MiddlewareConfig
MethodOverride :: MiddlewareConfig
MethodOverridePost :: MiddlewareConfig
AddHeaders :: ![(ByteString, ByteString)] -> MiddlewareConfig

-- | Realm [(username,password)]
BasicAuth :: !String -> ![(ByteString, ByteString)] -> MiddlewareConfig

-- | Status Message
Local :: !Int -> !ByteString -> MiddlewareConfig
processMiddleware :: [MiddlewareConfig] -> Middleware
toMiddleware :: MiddlewareConfig -> Middleware
composeMiddleware :: [Middleware] -> Middleware
instance Show MiddlewareConfig
instance Generic MiddlewareConfig
instance Datatype D1MiddlewareConfig
instance Constructor C1_0MiddlewareConfig
instance Constructor C1_1MiddlewareConfig
instance Constructor C1_2MiddlewareConfig
instance Constructor C1_3MiddlewareConfig
instance Constructor C1_4MiddlewareConfig
instance Constructor C1_5MiddlewareConfig
instance Constructor C1_6MiddlewareConfig
instance Constructor C1_7MiddlewareConfig
instance ToJSON MiddlewareConfig
instance FromJSON MiddlewareConfig


-- | Utilities for dealing with YAML config files which contain relative
--   file paths.
module Data.Yaml.FilePath

-- | Parse a config file, using the <a>ParseYamlFile</a> typeclass.
decodeFileRelative :: ParseYamlFile a => FilePath -> IO (Either ParseException a)

-- | A replacement for the <tt>.:</tt> operator which will both parse a
--   file path and apply the relative file logic.
lookupBase :: ParseYamlFile a => BaseDir -> Object -> Text -> Parser a

-- | A replacement for the <tt>.:?</tt> operator which will both parse a
--   file path and apply the relative file logic.
lookupBaseMaybe :: ParseYamlFile a => BaseDir -> Object -> Text -> Parser (Maybe a)

-- | The directory from which we're reading the config file.
data BaseDir

-- | A replacement for the standard <tt>FromJSON</tt> typeclass which can
--   handle relative filepaths.
class ParseYamlFile a
parseYamlFile :: ParseYamlFile a => BaseDir -> Value -> Parser a
data NonEmptyVector a
NonEmptyVector :: !a -> !(Vector a) -> NonEmptyVector a
instance ParseYamlFile a => ParseYamlFile (NonEmptyVector a)
instance ParseYamlFile a => ParseYamlFile (Vector a)
instance (ParseYamlFile a, Ord a) => ParseYamlFile (Set a)
instance ParseYamlFile FilePath

module Network.HTTP.ReverseProxy.Rewrite
data ReverseProxyConfig
ReverseProxyConfig :: Text -> Int -> Text -> Bool -> Maybe Int -> Set RewriteRule -> Set RewriteRule -> ReverseProxyConfig
reversedHost :: ReverseProxyConfig -> Text
reversedPort :: ReverseProxyConfig -> Int
reversingHost :: ReverseProxyConfig -> Text
reverseUseSSL :: ReverseProxyConfig -> Bool
reverseTimeout :: ReverseProxyConfig -> Maybe Int
rewriteResponseRules :: ReverseProxyConfig -> Set RewriteRule
rewriteRequestRules :: ReverseProxyConfig -> Set RewriteRule
data RewriteRule
RewriteRule :: Text -> Text -> Text -> RewriteRule
ruleHeader :: RewriteRule -> Text
ruleRegex :: RewriteRule -> Text
ruleReplacement :: RewriteRule -> Text
data RPEntry
RPEntry :: ReverseProxyConfig -> Manager -> RPEntry
config :: RPEntry -> ReverseProxyConfig
httpManager :: RPEntry -> Manager
simpleReverseProxy :: Manager -> ReverseProxyConfig -> Application
instance Eq RewriteRule
instance Ord RewriteRule
instance Show RewriteRule
instance Eq ReverseProxyConfig
instance Ord ReverseProxyConfig
instance Show ReverseProxyConfig
instance ToJSON RewriteRule
instance FromJSON RewriteRule
instance Default ReverseProxyConfig
instance ToJSON ReverseProxyConfig
instance FromJSON ReverseProxyConfig
instance Show RPEntry

module Keter.Types.Common

-- | Name of the application. Should just be the basename of the
--   application file.
type Appname = Text
data Plugin
Plugin :: (Appname -> Object -> IO [(Text, Text)]) -> Plugin
pluginGetEnv :: Plugin -> Appname -> Object -> IO [(Text, Text)]
type Plugins = [Plugin]

-- | Used for versioning data types.
class ToCurrent a where type family Previous a
toCurrent :: ToCurrent a => Previous a -> a

-- | A port for an individual app to listen on.
type Port = Int

-- | A virtual host we want to serve content from.
type Host = CI Text
type HostBS = CI ByteString
getAppname :: FilePath -> Text
data LogMessage
ProcessCreated :: FilePath -> LogMessage
InvalidBundle :: FilePath -> SomeException -> LogMessage
ProcessDidNotStart :: FilePath -> LogMessage
ExceptionThrown :: Text -> SomeException -> LogMessage
RemovingPort :: Int -> LogMessage
UnpackingBundle :: FilePath -> LogMessage
TerminatingApp :: Text -> LogMessage
FinishedReloading :: Text -> LogMessage
TerminatingOldProcess :: AppId -> LogMessage
RemovingOldFolder :: FilePath -> LogMessage
ReceivedInotifyEvent :: Text -> LogMessage
ProcessWaiting :: FilePath -> LogMessage
OtherMessage :: Text -> LogMessage
ErrorStartingBundle :: Text -> SomeException -> LogMessage
SanityChecksPassed :: LogMessage
ReservingHosts :: AppId -> (Set Host) -> LogMessage
ForgetingReservations :: AppId -> (Set Host) -> LogMessage
ActivatingApp :: AppId -> (Set Host) -> LogMessage
DeactivatingApp :: AppId -> (Set Host) -> LogMessage
ReactivatingApp :: AppId -> (Set Host) -> (Set Host) -> LogMessage
WatchedFile :: Text -> FilePath -> LogMessage
data KeterException
CannotParsePostgres :: FilePath -> KeterException
ExitCodeFailure :: FilePath -> ExitCode -> KeterException
NoPortsAvailable :: KeterException
InvalidConfigFile :: ParseException -> KeterException
InvalidKeterConfigFile :: !FilePath -> !ParseException -> KeterException
CannotReserveHosts :: !AppId -> !(Map Host AppId) -> KeterException
FileNotExecutable :: !FilePath -> KeterException
ExecutableNotFound :: !FilePath -> KeterException
logEx :: Q Exp
data AppId
AIBuiltin :: AppId
AINamed :: !Appname -> AppId
data FilePath :: *
data Text :: *

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString :: *

-- | A set of values <tt>a</tt>.
data Set a :: * -> *

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a :: * -> * -> *

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable * e, Show e) => Exception e

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException :: *
instance Typeable KeterException
instance Eq AppId
instance Ord AppId
instance Show KeterException
instance Show AppId
instance Exception KeterException
instance Show LogMessage
instance ToCurrent a => ToCurrent (Maybe a)


-- | Legacy types from Keter version 0.4. Retained to keep backwards
--   compatibility in config file format.
module Keter.Types.V04
data AppConfig
AppConfig :: FilePath -> [Text] -> Text -> Bool -> Set Text -> Object -> AppConfig
configExec :: AppConfig -> FilePath
configArgs :: AppConfig -> [Text]
configHost :: AppConfig -> Text
configSsl :: AppConfig -> Bool
configExtraHosts :: AppConfig -> Set Text
configRaw :: AppConfig -> Object
data BundleConfig
BundleConfig :: Maybe AppConfig -> Set StaticHost -> Set Redirect -> BundleConfig
bconfigApp :: BundleConfig -> Maybe AppConfig
bconfigStaticHosts :: BundleConfig -> Set StaticHost
bconfigRedirects :: BundleConfig -> Set Redirect
data StaticHost
StaticHost :: Text -> FilePath -> StaticHost
shHost :: StaticHost -> Text
shRoot :: StaticHost -> FilePath
data Redirect
Redirect :: Text -> Text -> Redirect
redFrom :: Redirect -> Text
redTo :: Redirect -> Text
data KeterConfig
KeterConfig :: FilePath -> PortSettings -> HostPreference -> Port -> Maybe TLSConfig -> Maybe Text -> Set ReverseProxyConfig -> Bool -> Int -> KeterConfig
kconfigDir :: KeterConfig -> FilePath
kconfigPortMan :: KeterConfig -> PortSettings
kconfigHost :: KeterConfig -> HostPreference
kconfigPort :: KeterConfig -> Port
kconfigSsl :: KeterConfig -> Maybe TLSConfig
kconfigSetuid :: KeterConfig -> Maybe Text
kconfigReverseProxy :: KeterConfig -> Set ReverseProxyConfig
kconfigIpFromHeader :: KeterConfig -> Bool
kconfigConnectionTimeBound :: KeterConfig -> Int
fiveMinutes :: Int
data TLSConfig
TLSConfig :: !Settings -> !TLSSettings -> TLSConfig

-- | Controls execution of the nginx thread. Follows the settings type
--   pattern. See: <a>http://www.yesodweb.com/book/settings-types</a>.
data PortSettings
PortSettings :: [Port] -> PortSettings

-- | Which ports to assign to apps. Defaults to unassigned ranges from IANA
portRange :: PortSettings -> [Port]
instance Eq StaticHost
instance Ord StaticHost
instance Eq Redirect
instance Ord Redirect
instance FromJSON PortSettings
instance Default PortSettings
instance ParseYamlFile TLSConfig
instance ParseYamlFile KeterConfig
instance Default KeterConfig
instance FromJSON Redirect
instance ParseYamlFile StaticHost
instance ParseYamlFile BundleConfig
instance ParseYamlFile AppConfig

module Keter.Types.V10
data BundleConfig
BundleConfig :: !(Vector (Stanza ())) -> !Object -> BundleConfig
bconfigStanzas :: BundleConfig -> !(Vector (Stanza ()))

-- | settings used for plugins
bconfigPlugins :: BundleConfig -> !Object
data ListeningPort
LPSecure :: !HostPreference -> !Port -> !FilePath -> !(Vector FilePath) -> !FilePath -> ListeningPort
LPInsecure :: !HostPreference -> !Port -> ListeningPort
data KeterConfig
KeterConfig :: FilePath -> PortSettings -> !(NonEmptyVector ListeningPort) -> Maybe Text -> !(Vector (Stanza ())) -> Bool -> !Int -> !Int -> !(Map Text Text) -> !Int -> KeterConfig
kconfigDir :: KeterConfig -> FilePath
kconfigPortPool :: KeterConfig -> PortSettings
kconfigListeners :: KeterConfig -> !(NonEmptyVector ListeningPort)
kconfigSetuid :: KeterConfig -> Maybe Text
kconfigBuiltinStanzas :: KeterConfig -> !(Vector (Stanza ()))
kconfigIpFromHeader :: KeterConfig -> Bool

-- | External HTTP port when generating APPROOTs.
kconfigExternalHttpPort :: KeterConfig -> !Int

-- | External HTTPS port when generating APPROOTs.
kconfigExternalHttpsPort :: KeterConfig -> !Int

-- | Environment variables to be passed to all apps.
kconfigEnvironment :: KeterConfig -> !(Map Text Text)
kconfigConnectionTimeBound :: KeterConfig -> !Int

-- | Whether we should force redirect to HTTPS routes.
type RequiresSecure = Bool
data Stanza port
Stanza :: (StanzaRaw port) -> RequiresSecure -> Stanza port
data StanzaRaw port
StanzaStaticFiles :: !StaticFilesConfig -> StanzaRaw port
StanzaRedirect :: !RedirectConfig -> StanzaRaw port
StanzaWebApp :: !(WebAppConfig port) -> StanzaRaw port
StanzaReverseProxy :: !ReverseProxyConfig -> StanzaRaw port
StanzaBackground :: !BackgroundConfig -> StanzaRaw port

-- | An action to be performed for a requested hostname.
--   
--   This datatype is very similar to Stanza, but is necessarily separate
--   since:
--   
--   <ol>
--   <li>Webapps will be assigned ports.</li>
--   <li>Not all stanzas have an associated proxy action.</li>
--   </ol>
data ProxyActionRaw
PAPort :: Port -> ProxyActionRaw
PAStatic :: StaticFilesConfig -> ProxyActionRaw
PARedirect :: RedirectConfig -> ProxyActionRaw
PAReverseProxy :: ReverseProxyConfig -> ProxyActionRaw
type ProxyAction = (ProxyActionRaw, RequiresSecure)
addRequiresSecure :: ToJSON a => Bool -> a -> Value
addStanzaType :: ToJSON a => Value -> a -> Value
data StaticFilesConfig
StaticFilesConfig :: !FilePath -> !(Set Host) -> !Bool -> ![MiddlewareConfig] -> StaticFilesConfig
sfconfigRoot :: StaticFilesConfig -> !FilePath
sfconfigHosts :: StaticFilesConfig -> !(Set Host)
sfconfigListings :: StaticFilesConfig -> !Bool
sfconfigMiddleware :: StaticFilesConfig -> ![MiddlewareConfig]
data RedirectConfig
RedirectConfig :: !(Set Host) -> !Int -> !(Vector RedirectAction) -> RedirectConfig
redirconfigHosts :: RedirectConfig -> !(Set Host)
redirconfigStatus :: RedirectConfig -> !Int
redirconfigActions :: RedirectConfig -> !(Vector RedirectAction)
data RedirectAction
RedirectAction :: !SourcePath -> !RedirectDest -> RedirectAction
data SourcePath
SPAny :: SourcePath
SPSpecific :: !Text -> SourcePath
data RedirectDest
RDUrl :: !Text -> RedirectDest
RDPrefix :: !IsSecure -> !Host -> !(Maybe Port) -> RedirectDest
type IsSecure = Bool
data WebAppConfig port
WebAppConfig :: !FilePath -> !(Vector Text) -> !(Map Text Text) -> !Host -> !(Set Host) -> !Bool -> !port -> !(Set Text) -> WebAppConfig port
waconfigExec :: WebAppConfig port -> !FilePath
waconfigArgs :: WebAppConfig port -> !(Vector Text)
waconfigEnvironment :: WebAppConfig port -> !(Map Text Text)

-- | primary host, used for approot
waconfigApprootHost :: WebAppConfig port -> !Host

-- | all hosts, not including the approot host
waconfigHosts :: WebAppConfig port -> !(Set Host)
waconfigSsl :: WebAppConfig port -> !Bool
waconfigPort :: WebAppConfig port -> !port
waconfigForwardEnv :: WebAppConfig port -> !(Set Text)
data AppInput
AIBundle :: !FilePath -> !EpochTime -> AppInput
AIData :: !BundleConfig -> AppInput
data BackgroundConfig
BackgroundConfig :: !FilePath -> !(Vector Text) -> !(Map Text Text) -> !RestartCount -> !Word -> BackgroundConfig
bgconfigExec :: BackgroundConfig -> !FilePath
bgconfigArgs :: BackgroundConfig -> !(Vector Text)
bgconfigEnvironment :: BackgroundConfig -> !(Map Text Text)
bgconfigRestartCount :: BackgroundConfig -> !RestartCount
bgconfigRestartDelaySeconds :: BackgroundConfig -> !Word
data RestartCount
UnlimitedRestarts :: RestartCount
LimitedRestarts :: !Word -> RestartCount
instance Show StaticFilesConfig
instance Show SourcePath
instance Show RedirectDest
instance Show RedirectAction
instance Show RedirectConfig
instance Show ProxyActionRaw
instance Show port => Show (WebAppConfig port)
instance Show RestartCount
instance Show BackgroundConfig
instance Show port => Show (StanzaRaw port)
instance ToJSON BackgroundConfig
instance ParseYamlFile BackgroundConfig
instance FromJSON RestartCount
instance ToJSON (WebAppConfig ())
instance ParseYamlFile (WebAppConfig ())
instance ToCurrent (WebAppConfig ())
instance ToJSON RedirectDest
instance FromJSON RedirectDest
instance ToJSON RedirectAction
instance FromJSON RedirectAction
instance ToJSON RedirectConfig
instance ParseYamlFile RedirectConfig
instance ToCurrent RedirectConfig
instance ToJSON StaticFilesConfig
instance ParseYamlFile StaticFilesConfig
instance ToCurrent StaticFilesConfig
instance ToJSON (StanzaRaw ())
instance ToJSON (Stanza ())
instance ParseYamlFile (Stanza ())
instance ParseYamlFile KeterConfig
instance Default KeterConfig
instance ToCurrent KeterConfig
instance ParseYamlFile ListeningPort
instance ToJSON BundleConfig
instance ParseYamlFile BundleConfig
instance ToCurrent BundleConfig

module Keter.Types

module Keter.HostManager
data HostManager
type Reservations = Set Host

-- | Reserve the given hosts so that no other application may use them.
--   Does not yet enable any action. The semantics are:
--   
--   <ol>
--   <li>If a requested host is currently actively used or by an app of the
--   same name, it is considered reserved.</li>
--   <li>If a requested host is currently reserved by an app of the same
--   name, it is considered an error in calling this API. Only one app
--   reservation can happen at a time.</li>
--   <li>If any requested host is currently used or reserved by an app with
--   a different name, then those values are returned as
--   <tt>Left</tt>.</li>
--   <li>Otherwise, the hosts which were reserved are returned as
--   <tt>Right</tt>. This does <i>not</i> include previously active
--   hosts.</li>
--   </ol>
reserveHosts :: (LogMessage -> IO ()) -> HostManager -> AppId -> Set Host -> IO Reservations

-- | Forget previously made reservations.
forgetReservations :: (LogMessage -> IO ()) -> HostManager -> AppId -> Reservations -> IO ()

-- | Activate a new app. Note that you <i>must</i> first reserve the
--   hostnames you'll be using.
activateApp :: (LogMessage -> IO ()) -> HostManager -> AppId -> Map Host ProxyAction -> IO ()
deactivateApp :: (LogMessage -> IO ()) -> HostManager -> AppId -> Set Host -> IO ()
reactivateApp :: (LogMessage -> IO ()) -> HostManager -> AppId -> Map Host ProxyAction -> Set Host -> IO ()
lookupAction :: HostManager -> HostBS -> IO (Maybe ProxyAction)
start :: IO HostManager


-- | Manages a pool of available ports and allocates them.
module Keter.PortPool
data PortPool

-- | Gets an unassigned port number.
getPort :: (LogMessage -> IO ()) -> PortPool -> IO (Either SomeException Port)

-- | Return a port to the recycled collection of the pool. Note that
--   recycling puts the new ports at the end of the queue (FIFO), so that
--   if an application holds onto the port longer than expected, there
--   should be no issues.
releasePort :: PortPool -> Port -> IO ()
start :: PortSettings -> IO PortPool

module Keter.App
data App
data AppStartConfig
AppStartConfig :: !TempFolder -> !(Maybe (Text, (UserID, GroupID))) -> !ProcessTracker -> !HostManager -> !PortPool -> !Plugins -> !(LogMessage -> IO ()) -> !KeterConfig -> AppStartConfig
ascTempFolder :: AppStartConfig -> !TempFolder
ascSetuid :: AppStartConfig -> !(Maybe (Text, (UserID, GroupID)))
ascProcessTracker :: AppStartConfig -> !ProcessTracker
ascHostManager :: AppStartConfig -> !HostManager
ascPortPool :: AppStartConfig -> !PortPool
ascPlugins :: AppStartConfig -> !Plugins
ascLog :: AppStartConfig -> !(LogMessage -> IO ())
ascKeterConfig :: AppStartConfig -> !KeterConfig
start :: AppStartConfig -> AppId -> AppInput -> IO App
reload :: App -> AppInput -> IO ()

-- | Get the modification time of the bundle file this app was launched
--   from, if relevant.
getTimestamp :: App -> STM (Maybe EpochTime)
terminate :: App -> IO ()


-- | Used for management of applications.
module Keter.AppManager
data AppManager
data Action
Reload :: AppInput -> Action
Terminate :: Action
perform :: AppManager -> AppId -> Action -> IO ()

-- | Reset which apps are running.
--   
--   <ul>
--   <li>Any app not listed here that is currently running will be
--   terminated.</li>
--   <li>Any app listed here that is currently running will be
--   reloaded.</li>
--   <li>Any app listed here that is not currently running will be
--   started.</li>
--   </ul>
reloadAppList :: AppManager -> Map Appname (FilePath, EpochTime) -> IO ()
addApp :: AppManager -> FilePath -> IO ()
terminateApp :: AppManager -> Appname -> IO ()
initialize :: (LogMessage -> IO ()) -> AppStartConfig -> IO AppManager


-- | A light-weight, minimalistic reverse HTTP proxy.
module Keter.Proxy
reverseProxy :: Bool -> Int -> Manager -> HostLookup -> ListeningPort -> IO ()

-- | Mapping from virtual hostname to port number.
type HostLookup = ByteString -> IO (Maybe ProxyAction)
data TLSConfig
TLSConfig :: !Settings -> !TLSSettings -> TLSConfig

module Keter.Main
keter :: FilePath -> [FilePath -> IO Plugin] -> IO ()

module Keter.Plugin.Postgres
data Settings

-- | How to create the given user/database. Default: uses the <tt>psql</tt>
--   command line tool and <tt>sudo -u postgres</tt>.
setupDBInfo :: Settings -> DBInfo -> IO ()

-- | Load a set of existing connections from a config file. If the file
--   does not exist, it will be created. Any newly created databases will
--   automatically be saved to this file.
load :: Settings -> FilePath -> IO Plugin
instance Show DBInfo
instance FromJSON DBInfo
instance ToJSON DBInfo
instance Default Settings
