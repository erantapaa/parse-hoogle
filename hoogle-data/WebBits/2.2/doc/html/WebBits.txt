-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | JavaScript analysis tools
--   
--   WebBits is a collection of libraries for working with JavaScript,
--   contains a parser, a pretty-printer and a lexical environment
--   analyser. The original author of the package is the PLT group of Brown
--   University (http://www.cs.brown.edu/research/plt/). Changes since
--   version 2.1: the syntax of the try-catch-finally statement has been
--   changed in accordance to the ECMAScript specification -- now it only
--   has at most one catch clause. The original test-suite needs updating
--   to support the current test system: patches are welcome.
@package WebBits
@version 2.2

module BrownPLT.JavaScript.Lexer
lexeme :: ParsecT String u Identity a -> ParsecT String u Identity a
identifier :: ParsecT String u Identity String
reserved :: String -> ParsecT String u Identity ()
operator :: ParsecT String u Identity String
reservedOp :: String -> ParsecT String u Identity ()
charLiteral :: ParsecT String u Identity Char
stringLiteral :: ParsecT String u Identity String
natural :: ParsecT String u Identity Integer
integer :: ParsecT String u Identity Integer
float :: ParsecT String u Identity Double
naturalOrFloat :: ParsecT String u Identity (Either Integer Double)
decimal :: ParsecT String u Identity Integer
hexadecimal :: ParsecT String u Identity Integer
octal :: ParsecT String u Identity Integer
symbol :: String -> ParsecT String u Identity String
whiteSpace :: ParsecT String u Identity ()
parens :: ParsecT String u Identity a -> ParsecT String u Identity a
braces :: ParsecT String u Identity a -> ParsecT String u Identity a
brackets :: ParsecT String u Identity a -> ParsecT String u Identity a
squares :: ParsecT String u Identity a -> ParsecT String u Identity a
semi :: ParsecT String u Identity String
comma :: ParsecT String u Identity String
colon :: ParsecT String u Identity String
dot :: ParsecT String u Identity String
identifierStart :: ParsecT [Char] u Identity Char


-- | JavaScript's syntax.
module BrownPLT.JavaScript.Syntax
data Expression a
StringLit :: a -> String -> Expression a
RegexpLit :: a -> String -> Bool -> Bool -> Expression a
NumLit :: a -> Double -> Expression a
IntLit :: a -> Int -> Expression a
BoolLit :: a -> Bool -> Expression a
NullLit :: a -> Expression a
ArrayLit :: a -> [Expression a] -> Expression a
ObjectLit :: a -> [(Prop a, Expression a)] -> Expression a
ThisRef :: a -> Expression a
VarRef :: a -> (Id a) -> Expression a
DotRef :: a -> (Expression a) -> (Id a) -> Expression a
BracketRef :: a -> (Expression a) -> (Expression a) -> Expression a
NewExpr :: a -> (Expression a) -> [Expression a] -> Expression a
PrefixExpr :: a -> PrefixOp -> (Expression a) -> Expression a
UnaryAssignExpr :: a -> UnaryAssignOp -> (LValue a) -> Expression a
InfixExpr :: a -> InfixOp -> (Expression a) -> (Expression a) -> Expression a
CondExpr :: a -> (Expression a) -> (Expression a) -> (Expression a) -> Expression a
AssignExpr :: a -> AssignOp -> (LValue a) -> (Expression a) -> Expression a
ParenExpr :: a -> (Expression a) -> Expression a
ListExpr :: a -> [Expression a] -> Expression a
CallExpr :: a -> (Expression a) -> [Expression a] -> Expression a
FuncExpr :: a -> (Maybe (Id a)) -> [(Id a)] -> (Statement a) -> Expression a
data CaseClause a
CaseClause :: a -> (Expression a) -> [Statement a] -> CaseClause a
CaseDefault :: a -> [Statement a] -> CaseClause a
data Statement a
BlockStmt :: a -> [Statement a] -> Statement a
EmptyStmt :: a -> Statement a
ExprStmt :: a -> (Expression a) -> Statement a
IfStmt :: a -> (Expression a) -> (Statement a) -> (Statement a) -> Statement a
IfSingleStmt :: a -> (Expression a) -> (Statement a) -> Statement a
SwitchStmt :: a -> (Expression a) -> [CaseClause a] -> Statement a
WhileStmt :: a -> (Expression a) -> (Statement a) -> Statement a
DoWhileStmt :: a -> (Statement a) -> (Expression a) -> Statement a
BreakStmt :: a -> (Maybe (Id a)) -> Statement a
ContinueStmt :: a -> (Maybe (Id a)) -> Statement a
LabelledStmt :: a -> (Id a) -> (Statement a) -> Statement a
ForInStmt :: a -> (ForInInit a) -> (Expression a) -> (Statement a) -> Statement a
ForStmt :: a -> (ForInit a) -> (Maybe (Expression a)) -> (Maybe (Expression a)) -> (Statement a) -> Statement a
TryStmt :: a -> (Statement a) -> (Maybe (CatchClause a)) -> (Maybe (Statement a)) -> Statement a
ThrowStmt :: a -> (Expression a) -> Statement a
ReturnStmt :: a -> (Maybe (Expression a)) -> Statement a
WithStmt :: a -> (Expression a) -> (Statement a) -> Statement a
VarDeclStmt :: a -> [VarDecl a] -> Statement a
FunctionStmt :: a -> (Id a) -> [(Id a)] -> (Statement a) -> Statement a
data InfixOp
OpLT :: InfixOp
OpLEq :: InfixOp
OpGT :: InfixOp
OpGEq :: InfixOp
OpIn :: InfixOp
OpInstanceof :: InfixOp
OpEq :: InfixOp
OpNEq :: InfixOp
OpStrictEq :: InfixOp
OpStrictNEq :: InfixOp
OpLAnd :: InfixOp
OpLOr :: InfixOp
OpMul :: InfixOp
OpDiv :: InfixOp
OpMod :: InfixOp
OpSub :: InfixOp
OpLShift :: InfixOp
OpSpRShift :: InfixOp
OpZfRShift :: InfixOp
OpBAnd :: InfixOp
OpBXor :: InfixOp
OpBOr :: InfixOp
OpAdd :: InfixOp
data CatchClause a
CatchClause :: a -> (Id a) -> (Statement a) -> CatchClause a
data VarDecl a
VarDecl :: a -> (Id a) -> (Maybe (Expression a)) -> VarDecl a
data JavaScript a

-- | A script in <a>script</a> ... <a>/script</a> tags. This may seem a
--   little silly, but the Flapjax analogue has an inline variant and
--   attribute-inline variant.
Script :: a -> [Statement a] -> JavaScript a
data AssignOp
OpAssign :: AssignOp
OpAssignAdd :: AssignOp
OpAssignSub :: AssignOp
OpAssignMul :: AssignOp
OpAssignDiv :: AssignOp
OpAssignMod :: AssignOp
OpAssignLShift :: AssignOp
OpAssignSpRShift :: AssignOp
OpAssignZfRShift :: AssignOp
OpAssignBAnd :: AssignOp
OpAssignBXor :: AssignOp
OpAssignBOr :: AssignOp
data Id a
Id :: a -> String -> Id a
data PrefixOp
PrefixLNot :: PrefixOp
PrefixBNot :: PrefixOp
PrefixPlus :: PrefixOp
PrefixMinus :: PrefixOp
PrefixTypeof :: PrefixOp
PrefixVoid :: PrefixOp
PrefixDelete :: PrefixOp
data Prop a
PropId :: a -> (Id a) -> Prop a
PropString :: a -> String -> Prop a
PropNum :: a -> Integer -> Prop a
data ForInit a
NoInit :: ForInit a
VarInit :: [VarDecl a] -> ForInit a
ExprInit :: (Expression a) -> ForInit a
data ForInInit a
ForInVar :: (Id a) -> ForInInit a
ForInNoVar :: (Id a) -> ForInInit a
unId :: Id a -> String
data UnaryAssignOp
PrefixInc :: UnaryAssignOp
PrefixDec :: UnaryAssignOp
PostfixInc :: UnaryAssignOp
PostfixDec :: UnaryAssignOp
data LValue a
LVar :: a -> String -> LValue a
LDot :: a -> (Expression a) -> String -> LValue a
LBracket :: a -> (Expression a) -> (Expression a) -> LValue a
instance Typeable1 Id
instance Typeable InfixOp
instance Typeable AssignOp
instance Typeable UnaryAssignOp
instance Typeable PrefixOp
instance Typeable1 Prop
instance Typeable1 ForInInit
instance Typeable1 Statement
instance Typeable1 ForInit
instance Typeable1 VarDecl
instance Typeable1 Expression
instance Typeable1 LValue
instance Typeable1 CatchClause
instance Typeable1 CaseClause
instance Typeable1 JavaScript
instance Show a => Show (Id a)
instance Eq a => Eq (Id a)
instance Ord a => Ord (Id a)
instance Data a => Data (Id a)
instance Show InfixOp
instance Data InfixOp
instance Eq InfixOp
instance Ord InfixOp
instance Enum InfixOp
instance Show AssignOp
instance Data AssignOp
instance Eq AssignOp
instance Ord AssignOp
instance Show UnaryAssignOp
instance Data UnaryAssignOp
instance Eq UnaryAssignOp
instance Ord UnaryAssignOp
instance Show PrefixOp
instance Data PrefixOp
instance Eq PrefixOp
instance Ord PrefixOp
instance Show a => Show (Prop a)
instance Data a => Data (Prop a)
instance Eq a => Eq (Prop a)
instance Ord a => Ord (Prop a)
instance Show a => Show (ForInInit a)
instance Data a => Data (ForInInit a)
instance Eq a => Eq (ForInInit a)
instance Ord a => Ord (ForInInit a)
instance Show a => Show (Statement a)
instance Data a => Data (Statement a)
instance Eq a => Eq (Statement a)
instance Ord a => Ord (Statement a)
instance Show a => Show (ForInit a)
instance Data a => Data (ForInit a)
instance Eq a => Eq (ForInit a)
instance Ord a => Ord (ForInit a)
instance Show a => Show (VarDecl a)
instance Data a => Data (VarDecl a)
instance Eq a => Eq (VarDecl a)
instance Ord a => Ord (VarDecl a)
instance Show a => Show (Expression a)
instance Data a => Data (Expression a)
instance Eq a => Eq (Expression a)
instance Ord a => Ord (Expression a)
instance Show a => Show (LValue a)
instance Eq a => Eq (LValue a)
instance Ord a => Ord (LValue a)
instance Data a => Data (LValue a)
instance Show a => Show (CatchClause a)
instance Data a => Data (CatchClause a)
instance Eq a => Eq (CatchClause a)
instance Ord a => Ord (CatchClause a)
instance Show a => Show (CaseClause a)
instance Data a => Data (CaseClause a)
instance Eq a => Eq (CaseClause a)
instance Ord a => Ord (CaseClause a)
instance Show a => Show (JavaScript a)
instance Data a => Data (JavaScript a)
instance Eq a => Eq (JavaScript a)
instance Ord a => Ord (JavaScript a)

module BrownPLT.JavaScript.Parser
parseScript :: CharParser state (JavaScript SourcePos)
parseExpression :: ExpressionParser st
parseString :: String -> [Statement SourcePos]
parseScriptFromString :: String -> String -> Either ParseError (JavaScript SourcePos)
emptyParsedJavaScript :: JavaScript a
type ParsedStatement = Statement SourcePos
type ParsedExpression = Expression SourcePos
parseJavaScriptFromFile :: MonadIO m => String -> m [Statement SourcePos]
parseSimpleExpr' :: ParsecT [Char] u Identity ParsedExpression
parseBlockStmt :: StatementParser st
parseStatement :: StatementParser st
type StatementParser state = CharParser state ParsedStatement
type ExpressionParser state = CharParser state ParsedExpression
assignExpr :: ExpressionParser st


-- | Pretty-printing JavaScript.
module BrownPLT.JavaScript.PrettyPrint
stmt :: Statement a -> Doc
expr :: Expression a -> Doc
javaScript :: JavaScript a -> Doc
renderStatements :: [Statement a] -> String
renderExpression :: Expression a -> String

module BrownPLT.JavaScript.Environment
env :: Map String SourcePos -> [Statement SourcePos] -> (EnvTree, Map String SourcePos)
localVars :: [Statement SourcePos] -> [(String, SourcePos)]

-- | The statically-determinate lexical structure of a JavaScript program.
data EnvTree
EnvTree :: (Map String SourcePos) -> [EnvTree] -> EnvTree


-- | Re-exports commonly used modules.
module BrownPLT.JavaScript
renderStatements :: [Statement a] -> String
renderExpression :: Expression a -> String
