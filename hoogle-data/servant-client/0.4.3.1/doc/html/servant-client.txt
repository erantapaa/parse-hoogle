-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | automatical derivation of querying functions for servant webservices
--   
@package servant-client
@version 0.4.3.1

module Servant.Common.BaseUrl

-- | URI scheme to use
data Scheme

-- | http://
Http :: Scheme

-- | https://
Https :: Scheme

-- | Simple data type to represent the target of HTTP requests for
--   servant's automatically-generated clients.
data BaseUrl
BaseUrl :: Scheme -> String -> Int -> BaseUrl

-- | URI scheme to use
baseUrlScheme :: BaseUrl -> Scheme

-- | host (eg "haskell.org")
baseUrlHost :: BaseUrl -> String

-- | port (eg 80)
baseUrlPort :: BaseUrl -> Int
showBaseUrl :: BaseUrl -> String
parseBaseUrl :: String -> Either String BaseUrl
instance Show Scheme
instance Eq Scheme
instance Ord Scheme
instance Generic Scheme
instance Show BaseUrl
instance Eq BaseUrl
instance Ord BaseUrl
instance Generic BaseUrl
instance Datatype D1Scheme
instance Constructor C1_0Scheme
instance Constructor C1_1Scheme
instance Datatype D1BaseUrl
instance Constructor C1_0BaseUrl
instance Selector S1_0_0BaseUrl
instance Selector S1_0_1BaseUrl
instance Selector S1_0_2BaseUrl

module Servant.Common.Req
data ServantError
FailureResponse :: Status -> MediaType -> ByteString -> ServantError
responseStatus :: ServantError -> Status
responseContentType :: ServantError -> MediaType
responseBody :: ServantError -> ByteString
DecodeFailure :: String -> MediaType -> ByteString -> ServantError
decodeError :: ServantError -> String
responseContentType :: ServantError -> MediaType
responseBody :: ServantError -> ByteString
UnsupportedContentType :: MediaType -> ByteString -> ServantError
responseContentType :: ServantError -> MediaType
responseBody :: ServantError -> ByteString
ConnectionError :: HttpException -> ServantError
connectionError :: ServantError -> HttpException
InvalidContentTypeHeader :: ByteString -> ByteString -> ServantError
responseContentTypeHeader :: ServantError -> ByteString
responseBody :: ServantError -> ByteString
data Req
Req :: String -> QueryText -> Maybe (ByteString, MediaType) -> [MediaType] -> [(String, Text)] -> Req
reqPath :: Req -> String
qs :: Req -> QueryText
reqBody :: Req -> Maybe (ByteString, MediaType)
reqAccept :: Req -> [MediaType]
headers :: Req -> [(String, Text)]
defReq :: Req
appendToPath :: String -> Req -> Req
appendToMatrixParams :: String -> Maybe String -> Req -> Req
appendToQueryString :: Text -> Maybe Text -> Req -> Req
addHeader :: ToText a => String -> a -> Req -> Req
setRQBody :: ByteString -> MediaType -> Req -> Req
reqToRequest :: (Functor m, MonadThrow m) => Req -> BaseUrl -> m Request
__manager :: IORef Manager
__withGlobalManager :: (Manager -> IO a) -> IO a
displayHttpRequest :: Method -> String
performRequest :: Method -> Req -> (Int -> Bool) -> BaseUrl -> EitherT ServantError IO (Int, ByteString, MediaType, [Header], Response ByteString)
performRequestCT :: MimeUnrender ct result => Proxy ct -> Method -> Req -> [Int] -> BaseUrl -> EitherT ServantError IO ([Header], result)
performRequestNoBody :: Method -> Req -> [Int] -> BaseUrl -> EitherT ServantError IO ()
catchHttpException :: IO a -> IO (Either HttpException a)
instance Show ServantError


-- | This module provides <a>client</a> which can automatically generate
--   querying functions for each endpoint just from the type representing
--   your API.
module Servant.Client

-- | <a>client</a> allows you to produce operations to query an API from a
--   client.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post Book -- POST /books
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   getAllBooks :: EitherT String IO [Book]
--   postNewBook :: Book -&gt; EitherT String IO Book
--   (getAllBooks :&lt;|&gt; postNewBook) = client myApi host
--     where host = BaseUrl Http "localhost" 8080
--   </pre>
client :: HasClient layout => Proxy layout -> BaseUrl -> Client layout

-- | This class lets us define how each API combinator influences the
--   creation of an HTTP request. It's mostly an internal class, you can
--   just use <a>client</a>.
class HasClient layout where type family Client layout :: *
clientWithRoute :: HasClient layout => Proxy layout -> Req -> BaseUrl -> Client layout
data ServantError
FailureResponse :: Status -> MediaType -> ByteString -> ServantError
responseStatus :: ServantError -> Status
responseContentType :: ServantError -> MediaType
responseBody :: ServantError -> ByteString
DecodeFailure :: String -> MediaType -> ByteString -> ServantError
decodeError :: ServantError -> String
responseContentType :: ServantError -> MediaType
responseBody :: ServantError -> ByteString
UnsupportedContentType :: MediaType -> ByteString -> ServantError
responseContentType :: ServantError -> MediaType
responseBody :: ServantError -> ByteString
ConnectionError :: HttpException -> ServantError
connectionError :: ServantError -> HttpException
InvalidContentTypeHeader :: ByteString -> ByteString -> ServantError
responseContentTypeHeader :: ServantError -> ByteString
responseBody :: ServantError -> ByteString
instance [overlap ok] (KnownSymbol path, HasClient sublayout) => HasClient (path :> sublayout)
instance [overlap ok] (MimeRender ct a, HasClient sublayout) => HasClient (ReqBody (ct : cts) a :> sublayout)
instance [overlap ok] HasClient Raw
instance [overlap ok] (KnownSymbol sym, HasClient sublayout) => HasClient (MatrixFlag sym :> sublayout)
instance [overlap ok] (KnownSymbol sym, ToText a, HasClient sublayout) => HasClient (MatrixParams sym a :> sublayout)
instance [overlap ok] (KnownSymbol sym, ToText a, HasClient sublayout) => HasClient (MatrixParam sym a :> sublayout)
instance [overlap ok] (KnownSymbol sym, HasClient sublayout) => HasClient (QueryFlag sym :> sublayout)
instance [overlap ok] (KnownSymbol sym, ToText a, HasClient sublayout) => HasClient (QueryParams sym a :> sublayout)
instance [overlap ok] (KnownSymbol sym, ToText a, HasClient sublayout) => HasClient (QueryParam sym a :> sublayout)
instance [overlap ok] (MimeUnrender ct a, BuildHeadersTo ls) => HasClient (Patch (ct : cts) (Headers ls a))
instance [overlap ok] HasClient (Patch (ct : cts) ())
instance [overlap ok] MimeUnrender ct a => HasClient (Patch (ct : cts) a)
instance [overlap ok] (MimeUnrender ct a, BuildHeadersTo ls) => HasClient (Put (ct : cts) (Headers ls a))
instance [overlap ok] HasClient (Put (ct : cts) ())
instance [overlap ok] MimeUnrender ct a => HasClient (Put (ct : cts) a)
instance [overlap ok] (MimeUnrender ct a, BuildHeadersTo ls) => HasClient (Post (ct : cts) (Headers ls a))
instance [overlap ok] HasClient (Post (ct : cts) ())
instance [overlap ok] MimeUnrender ct a => HasClient (Post (ct : cts) a)
instance [overlap ok] (KnownSymbol sym, ToText a, HasClient sublayout) => HasClient (Header sym a :> sublayout)
instance [overlap ok] (MimeUnrender ct a, BuildHeadersTo ls) => HasClient (Get (ct : cts) (Headers ls a))
instance [overlap ok] HasClient (Get (ct : cts) ())
instance [overlap ok] MimeUnrender ct result => HasClient (Get (ct : cts) result)
instance [overlap ok] (MimeUnrender ct a, BuildHeadersTo ls, cts' ~ (ct : cts)) => HasClient (Delete cts' (Headers ls a))
instance [overlap ok] HasClient (Delete cts ())
instance [overlap ok] (MimeUnrender ct a, cts' ~ (ct : cts)) => HasClient (Delete cts' a)
instance [overlap ok] (KnownSymbol capture, ToText a, HasClient sublayout) => HasClient (Capture capture a :> sublayout)
instance [overlap ok] (HasClient a, HasClient b) => HasClient (a :<|> b)
