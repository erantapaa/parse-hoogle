-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Leksah tool kit
--   
@package ltk
@version 0.15.0.1


-- | Module for parameters for editors
module Graphics.UI.Editor.Parameters

-- | A type for parameters for editors
type Parameters = [Parameter]
data Parameter
ParaName :: Text -> Parameter
ParaSynopsis :: Text -> Parameter
ParaDirection :: Direction -> Parameter
ParaShadow :: ShadowType -> Parameter
ParaShowLabel :: Bool -> Parameter
ParaOuterAlignment :: (Float, Float, Float, Float) -> Parameter

-- | xalign yalign xscale yscale
ParaOuterPadding :: (Int, Int, Int, Int) -> Parameter
ParaInnerAlignment :: (Float, Float, Float, Float) -> Parameter

-- | xalign yalign xscale yscale
ParaInnerPadding :: (Int, Int, Int, Int) -> Parameter
ParaMinSize :: (Int, Int) -> Parameter
ParaHorizontal :: HorizontalAlign -> Parameter
ParaStockId :: Text -> Parameter
ParaMultiSel :: Bool -> Parameter
ParaPack :: Packing -> Parameter
paraName :: Parameter -> Maybe Text
paraSynopsis :: Parameter -> Maybe Text
paraDirection :: Parameter -> Maybe Direction
paraShowLabel :: Parameter -> Maybe Bool
paraShadow :: Parameter -> Maybe ShadowType
paraOuterAlignment :: Parameter -> Maybe (Float, Float, Float, Float)
paraInnerAlignment :: Parameter -> Maybe (Float, Float, Float, Float)
paraOuterPadding :: Parameter -> Maybe (Int, Int, Int, Int)
paraInnerPadding :: Parameter -> Maybe (Int, Int, Int, Int)
paraMinSize :: Parameter -> Maybe (Int, Int)
paraHorizontal :: Parameter -> Maybe HorizontalAlign
paraStockId :: Parameter -> Maybe Text
paraMultiSel :: Parameter -> Maybe Bool
paraPack :: Parameter -> Maybe Packing

-- | Convenience method to get a parameter, or if not set the default
--   parameter
getParameter :: (Parameter -> Maybe beta) -> Parameters -> beta
getParameterPrim :: (Parameter -> Maybe beta) -> Parameters -> Maybe beta
(<<<-) :: (Parameter -> Maybe beta) -> Parameter -> Parameters -> Parameters
emptyParams :: [Parameter]

-- | The direction of a split
data Direction
Horizontal :: Direction
Vertical :: Direction
data HorizontalAlign
StartHorizontal :: HorizontalAlign
StopHorizontal :: HorizontalAlign
Keep :: HorizontalAlign
instance Eq Direction
instance Show Direction
instance Eq HorizontalAlign
instance Show HorizontalAlign
instance Eq Parameter
instance Show Parameter


-- | A simple event mechanism
module Control.Event

-- | Every event needs a selector, which should identify the type of event
class (Eq delta, Ord delta, Show delta) => EventSelector delta

-- | Every event needs to know its selector and its source
class EventSelector delta => Event beta delta | beta -> delta, delta -> beta
getSelector :: Event beta delta => beta -> delta

-- | Everything which is an event source needs this alpha is the Notifier
--   beta is the event gamma is the monad delta is the event selector
class (Monad gamma, Event beta delta) => EventSource alpha beta gamma delta | alpha -> beta, alpha -> gamma where canTriggerEvent _ _ = False triggerEvent o e = if canTriggerEvent o (getSelector e) then do { handlerMap <- getHandlers o; let selector = getSelector e; case selector `lookup` handlerMap of { Nothing -> return e Just l -> foldM (\ e (_, ah) -> ah e) e (reverse l) } } else error $ "Can't trigger event " ++ show (getSelector e) registerEvent o e handler = if canTriggerEvent o e then do { handlerMap <- getHandlers o; unique <- myUnique o; let newHandlers = case e `lookup` handlerMap of { Nothing -> insert e [(unique, handler)] handlerMap Just l -> insert e ((unique, handler) : l) handlerMap }; setHandlers o newHandlers; return (Just unique) } else error $ "Can't register event " ++ show e unregisterEvent o e unique = if canTriggerEvent o e then do { handlerMap <- getHandlers o; let newHandlers = case e `lookup` handlerMap of { Nothing -> handlerMap Just l -> let newList = filter (\ (mu, _) -> mu /= unique) l in insert e newList handlerMap }; setHandlers o newHandlers; return () } else error $ "Can't register event " ++ show e
getHandlers :: EventSource alpha beta gamma delta => alpha -> gamma (Handlers beta gamma delta)
setHandlers :: EventSource alpha beta gamma delta => alpha -> Handlers beta gamma delta -> gamma ()
myUnique :: EventSource alpha beta gamma delta => alpha -> gamma Unique
canTriggerEvent :: EventSource alpha beta gamma delta => alpha -> delta -> Bool
triggerEvent :: EventSource alpha beta gamma delta => alpha -> beta -> gamma beta
registerEvent :: EventSource alpha beta gamma delta => alpha -> delta -> (beta -> gamma beta) -> gamma (Maybe Unique)
unregisterEvent :: EventSource alpha beta gamma delta => alpha -> delta -> Unique -> gamma ()

-- | This shows the implementation of the event mechnism
type Handlers beta gamma delta = Map delta [(Unique, beta -> gamma beta)]
registerEvents :: EventSource alpha beta gamma delta => alpha -> [delta] -> (beta -> gamma beta) -> gamma [Unique]


-- | Module for missing base functions
module MyMissing
allOf :: (Bounded alpha, Enum alpha) => [alpha]
forceJust :: Maybe alpha -> Text -> alpha
forceHead :: [alpha] -> Text -> alpha
split :: Eq a => a -> [a] -> [[a]]
nonEmptyLines :: String -> [String]


-- | Module for the basiscs of composing GUIs from editors
module Graphics.UI.Editor.Basics

-- | A type for getting a field of a record
type Getter alpha beta = alpha -> beta

-- | A type for setting the field of a record
type Setter alpha beta = beta -> alpha -> alpha

-- | A type for injecting a value into an editor
type Injector beta = beta -> IO ()

-- | A type for extracting a value from an editor
type Extractor beta = IO (Maybe beta)

-- | A type for the application of a value to be reflected in the GUI
type Applicator beta gamma = beta -> gamma ()

-- | A type to describe an editor. alpha is the type of the individual
--   field of the record
type Editor alpha = Parameters -> Notifier -> IO (Widget, Injector alpha, Extractor alpha)
emptyNotifier :: IO Notifier

-- | A type for an event in the GUI
data GUIEvent
GUIEvent :: GUIEventSelector -> Text -> Bool -> GUIEvent
selector :: GUIEvent -> GUIEventSelector
eventText :: GUIEvent -> Text

-- | True means that the event has been completely handled, gtk shoudn't do
--   any further action about it (Often not a good idea
gtkReturn :: GUIEvent -> Bool
data GUIEventSelector

-- | generic, the widget looses the focus
FocusOut :: GUIEventSelector

-- | generic, the widget gets the focus
FocusIn :: GUIEventSelector

-- | generic, a mouse key has been pressed and released, while the widget
--   has the focus
ButtonPressed :: GUIEventSelector

-- | generic, a keyboard key has been pressed and released, while the
--   widget has the focus
KeyPressed :: GUIEventSelector

-- | button specific, the button has been pressed
Clicked :: GUIEventSelector

-- | generic, no gui event, the contents of the widget may have changed
MayHaveChanged :: GUIEventSelector

-- | validation of a contents has failed
ValidationError :: GUIEventSelector

-- | A type for a function to register a gtk event |
type GtkRegFunc = forall o. GObjectClass o => o -> GtkHandler -> IO Connection

-- | The event source in the gtk editor context If the second argument is
--   Left Handler the handler gets registered If the second argument is
--   Right Unique the handler will be removed The returned unique value
--   must be used for unregistering an event
newtype Notifier
Noti :: (IORef (Handlers GUIEvent IO GUIEventSelector, Map GUIEventSelector GUIEventReg)) -> Notifier
type GtkHandler = IO Bool

-- | Signal handlers for the different pane types
data Connection
ConnectC :: (ConnectId alpha) -> Connection
type Connections = [Connection]

-- | Activate the event after the event has been declared and the widget
--   has been constructed
activateEvent :: GObjectClass o => o -> Notifier -> Maybe (o -> IO Bool -> IO Connection) -> GUIEventSelector -> IO ()

-- | Propagate the event with the selector from notifier to eventSource
propagateEvent :: Notifier -> [Notifier] -> GUIEventSelector -> IO ()
allGUIEvents :: [GUIEventSelector]
genericGUIEvents :: [GUIEventSelector]
propagateAsChanged :: EventSource alpha GUIEvent m GUIEventSelector => alpha -> [GUIEventSelector] -> m ()
instance Eq GUIEventSelector
instance Ord GUIEventSelector
instance Show GUIEventSelector
instance Enum GUIEventSelector
instance Bounded GUIEventSelector
instance EventSource Notifier GUIEvent IO GUIEventSelector
instance EventSelector GUIEventSelector
instance Event GUIEvent GUIEventSelector


-- | Module for making editors out of descriptions
module Graphics.UI.Editor.MakeEditor
buildEditor :: FieldDescription alpha -> alpha -> IO (Widget, Injector alpha, alpha -> Extractor alpha, Notifier)

-- | A type to describe a field of a record, which can be edited | alpha is
--   the type of the individual field of the record
data FieldDescription alpha
FD :: Parameters -> (alpha -> IO (Widget, Injector alpha, alpha -> Extractor alpha, Notifier)) -> FieldDescription alpha
VFD :: Parameters -> [FieldDescription alpha] -> FieldDescription alpha
HFD :: Parameters -> [FieldDescription alpha] -> FieldDescription alpha
NFD :: [(Text, FieldDescription alpha)] -> FieldDescription alpha

-- | Function to construct a field description
mkField :: Eq beta => MkFieldDescription alpha beta

-- | Convenience method to validate and extract fields
extractAndValidate :: alpha -> [alpha -> Extractor alpha] -> [Text] -> Notifier -> IO (Maybe alpha)
extract :: alpha -> [alpha -> Extractor alpha] -> IO (Maybe alpha)

-- | Function to construct an editor
mkEditor :: (Container -> Injector alpha) -> Extractor alpha -> Editor alpha
parameters :: FieldDescription alpha -> Parameters
flattenFieldDescription :: FieldDescription alpha -> [FieldDescription alpha]

-- | get through outerAlignment, frame, innerAlignment
getRealWidget :: Widget -> IO (Maybe Widget)

-- | A constructor type for a field desciption
type MkFieldDescription alpha beta = Parameters -> Getter alpha beta -> Setter alpha beta -> Editor beta -> FieldDescription alpha


-- | Module for saving and restoring preferences and settings
module Text.PrinterParser
type Printer beta = beta -> Doc
type Parser beta = CharParser () beta
data FieldDescriptionS alpha
FDS :: Parameters -> (alpha -> Doc) -> (alpha -> CharParser () alpha) -> FieldDescriptionS alpha
parameters :: FieldDescriptionS alpha -> Parameters
fieldPrinter :: FieldDescriptionS alpha -> alpha -> Doc
fieldParser :: FieldDescriptionS alpha -> alpha -> CharParser () alpha
type MkFieldDescriptionS alpha beta = Parameters -> Printer beta -> Parser beta -> Getter alpha beta -> Setter alpha beta -> FieldDescriptionS alpha
mkFieldS :: MkFieldDescriptionS alpha beta
applyFieldParsers :: a -> [a -> CharParser () a] -> CharParser () a
boolParser :: CharParser () Bool
intParser :: CharParser () Int
lineParser :: CharParser () Text
pairParser :: CharParser () alpha -> CharParser () (alpha, alpha)
identifier :: CharParser st Text
emptyParser :: CharParser () ()
whiteSpace :: CharParser st ()
stringParser :: CharParser () Text
readParser :: Read a => CharParser () a
colorParser :: CharParser () Color
emptyPrinter :: () -> Doc

-- | Things that can be pretty-printed
class Pretty a where pretty = prettyPrec 0 prettyPrec _ = pretty
pretty :: Pretty a => a -> Doc
prettyPrec :: Pretty a => Int -> a -> Doc

-- | pretty-print with the default style and <tt>defaultMode</tt>.
prettyPrint :: Pretty a => a -> Text
maybePP :: (a -> Doc) -> Maybe a -> Doc
symbol :: Text -> CharParser st Text
colon :: CharParser st Text
writeFields :: FilePath -> alpha -> [FieldDescriptionS alpha] -> IO ()
showFields :: alpha -> [FieldDescriptionS alpha] -> Text
readFields :: FilePath -> [FieldDescriptionS alpha] -> alpha -> IO alpha
parseFields :: alpha -> [FieldDescriptionS alpha] -> CharParser () alpha
instance Pretty Text


-- | Description of a editor with additional fileds for printing and
--   parsing
module Graphics.UI.Editor.DescriptionPP

-- | A type for the application of a value to be reflected in the GUI
type Applicator beta gamma = beta -> gamma ()
data FieldDescriptionPP alpha gamma
FDPP :: Parameters -> (alpha -> Doc) -> (alpha -> CharParser () alpha) -> (alpha -> IO (Widget, Injector alpha, alpha -> Extractor alpha, Notifier)) -> (alpha -> alpha -> gamma ()) -> FieldDescriptionPP alpha gamma
parameters :: FieldDescriptionPP alpha gamma -> Parameters
fieldPrinter :: FieldDescriptionPP alpha gamma -> alpha -> Doc
fieldParser :: FieldDescriptionPP alpha gamma -> alpha -> CharParser () alpha
fieldEditor :: FieldDescriptionPP alpha gamma -> alpha -> IO (Widget, Injector alpha, alpha -> Extractor alpha, Notifier)
applicator :: FieldDescriptionPP alpha gamma -> alpha -> alpha -> gamma ()
VFDPP :: Parameters -> [FieldDescriptionPP alpha gamma] -> FieldDescriptionPP alpha gamma
HFDPP :: Parameters -> [FieldDescriptionPP alpha gamma] -> FieldDescriptionPP alpha gamma
NFDPP :: [(Text, FieldDescriptionPP alpha gamma)] -> FieldDescriptionPP alpha gamma
mkFieldPP :: (Eq beta, Monad gamma) => MkFieldDescriptionPP alpha beta gamma
extractFieldDescription :: FieldDescriptionPP alpha gamma -> FieldDescription alpha
flattenFieldDescriptionPP :: FieldDescriptionPP alpha gamma -> [FieldDescriptionPP alpha gamma]
flattenFieldDescriptionPPToS :: FieldDescriptionPP alpha gamma -> [FieldDescriptionS alpha]


-- | The basic definitions for all panes
module Graphics.UI.Frame.Panes
class MonadIO delta => PaneMonad delta
setFrameState :: PaneMonad delta => FrameState delta -> delta ()
getFrameState :: PaneMonad delta => delta (FrameState delta)
runInIO :: PaneMonad delta => (beta -> delta alpha) -> delta (beta -> IO alpha)
panePathForGroup :: PaneMonad delta => Text -> delta PanePath
getThisPane :: (PaneMonad delta, RecoverablePane alpha beta delta) => delta (Maybe alpha)
displayThisPane :: (PaneMonad delta, RecoverablePane alpha beta delta) => alpha -> Bool -> delta ()
getOrBuildThisPane :: (PaneMonad delta, RecoverablePane alpha beta delta) => Either PanePath Text -> delta (Maybe alpha)
buildThisPane :: (PaneMonad delta, RecoverablePane alpha beta delta) => PanePath -> Notebook -> (PanePath -> Notebook -> Window -> delta (Maybe alpha, Connections)) -> delta (Maybe alpha)
activateThisPane :: (PaneMonad delta, RecoverablePane alpha beta delta) => alpha -> Connections -> delta ()
closeThisPane :: (PaneMonad delta, RecoverablePane alpha beta delta) => alpha -> delta Bool
data IDEPane delta
PaneC :: alpha -> IDEPane delta

-- | All kinds of panes are instances of pane
class (Typeable alpha, PaneMonad delta) => Pane alpha delta | alpha -> delta where paneName b = if getAddedIndex b == 0 then primPaneName b else primPaneName b <> "(" <> pack (show $ getAddedIndex b) <> ")" getAddedIndex _ = 0
getTopWidget :: Pane alpha delta => alpha -> Widget
paneId :: Pane alpha delta => alpha -> Text
primPaneName :: Pane alpha delta => alpha -> Text
paneName :: Pane alpha delta => alpha -> PaneName
getAddedIndex :: Pane alpha delta => alpha -> Int
class (Pane alpha delta, Typeable beta, Show beta, Read beta) => RecoverablePane alpha beta delta | beta -> alpha, alpha -> beta where makeActive pane = activateThisPane pane [] closePane = closeThisPane getPane = getThisPane forceGetPane pp = do { mbPane <- getOrBuildPane pp; case mbPane of { Nothing -> error "Can't get pane " Just p -> return p } } getOrBuildPane = getOrBuildThisPane displayPane = displayThisPane getAndDisplayPane pps b = do { mbP <- getOrBuildThisPane pps; case mbP of { Nothing -> return Nothing Just p -> do { displayPane p b; return (Just p) } } } buildPane = buildThisPane
saveState :: RecoverablePane alpha beta delta => alpha -> delta (Maybe beta)
recoverState :: RecoverablePane alpha beta delta => PanePath -> beta -> delta (Maybe alpha)
builder :: RecoverablePane alpha beta delta => PanePath -> Notebook -> Window -> delta (Maybe alpha, Connections)
makeActive :: RecoverablePane alpha beta delta => alpha -> delta ()
closePane :: RecoverablePane alpha beta delta => alpha -> delta Bool
getPane :: RecoverablePane alpha beta delta => delta (Maybe alpha)
forceGetPane :: RecoverablePane alpha beta delta => Either PanePath Text -> delta alpha
getOrBuildPane :: RecoverablePane alpha beta delta => Either PanePath Text -> delta (Maybe alpha)
displayPane :: RecoverablePane alpha beta delta => alpha -> Bool -> delta ()
getAndDisplayPane :: RecoverablePane alpha beta delta => Either PanePath Text -> Bool -> delta (Maybe alpha)
buildPane :: RecoverablePane alpha beta delta => PanePath -> Notebook -> (PanePath -> Notebook -> Window -> delta (Maybe alpha, Connections)) -> delta (Maybe alpha)

-- | The relative direction to a pane from the parent
data PaneDirection
TopP :: PaneDirection
BottomP :: PaneDirection
LeftP :: PaneDirection
RightP :: PaneDirection

-- | An element of a path to a pane
data PanePathElement
SplitP :: PaneDirection -> PanePathElement
GroupP :: Text -> PanePathElement

-- | A path to a pane
type PanePath = [PanePathElement]

-- | Description of a window layout Horizontal: top bottom Vertical: left
--   right
data PaneLayout
HorizontalP :: PaneLayout -> PaneLayout -> Int -> PaneLayout
VerticalP :: PaneLayout -> PaneLayout -> Int -> PaneLayout
TerminalP :: Map Text PaneLayout -> Maybe PaneDirection -> Int -> Maybe Text -> Maybe (Int, Int) -> PaneLayout
paneGroups :: PaneLayout -> Map Text PaneLayout
paneTabs :: PaneLayout -> Maybe PaneDirection
currentPage :: PaneLayout -> Int
detachedId :: PaneLayout -> Maybe Text
detachedSize :: PaneLayout -> Maybe (Int, Int)
type PaneName = Text

-- | Signal handlers for the different pane types
data Connection
ConnectC :: (ConnectId alpha) -> Connection
type Connections = [Connection]
type StandardPath = PanePath
data FrameState delta
FrameState :: [Window] -> UIManager -> Map PaneName (IDEPane delta) -> Map PaneName (PanePath, Connections) -> Maybe (PaneName, Connections) -> !(Map Notebook PanePath) -> PaneLayout -> FrameState delta
windows :: FrameState delta -> [Window]
uiManager :: FrameState delta -> UIManager
panes :: FrameState delta -> Map PaneName (IDEPane delta)
paneMap :: FrameState delta -> Map PaneName (PanePath, Connections)
activePane :: FrameState delta -> Maybe (PaneName, Connections)
panePathFromNB :: FrameState delta -> !(Map Notebook PanePath)
layout :: FrameState delta -> PaneLayout
signalDisconnectAll :: Connections -> IO ()
instance Eq PaneDirection
instance Show PaneDirection
instance Read PaneDirection
instance Eq PanePathElement
instance Show PanePathElement
instance Read PanePathElement
instance Eq PaneLayout
instance Show PaneLayout
instance Read PaneLayout
instance Show (FrameState delta)
instance Show Notebook
instance Show Connection
instance Show UIManager
instance Show Window
instance Show (IDEPane delta)
instance Ord (IDEPane delta)
instance Eq (IDEPane delta)


-- | Module for making simple editors
module Graphics.UI.Editor.Simple

-- | An invisible editor without any effect
noEditor :: alpha -> Editor alpha

-- | Editor for a boolean value in the form of a check button
boolEditor :: Editor Bool

-- | Editor for a boolean value in the form of two radio buttons
boolEditor2 :: Text -> Editor Bool

-- | Editor for an enum value in the form of n radio buttons
enumEditor :: (Show alpha, Enum alpha, Bounded alpha) => [Text] -> Editor alpha

-- | An Editor for nothing (which may report a click) in the form of a
--   button
clickEditor :: Bool -> Editor ()

-- | Editor for a Text in the form of a text entry
textEditor :: (Text -> Bool) -> Bool -> Editor Text

-- | Editor for a String in the form of a text entry
stringEditor :: (String -> Bool) -> Bool -> Editor String

-- | Editor for a multiline string in the form of a multiline text entry
multilineStringEditor :: Editor Text

-- | Editor for an integer in the form of a spin entry
intEditor :: (Double, Double, Double) -> Editor Int

-- | Editor for for any value which is an instance of Read and Show in the
--   form of a | text entry
genericEditor :: (Show beta, Read beta) => Editor beta

-- | Editor for a font selection
fontEditor :: Editor (Maybe Text)

-- | Editor for color selection
colorEditor :: Editor Color

-- | Editor for the selection of some element from a static list of
--   elements in the | form of a combo box
comboSelectionEditor :: Eq beta => [beta] -> (beta -> Text) -> Editor beta

-- | Like comboSelectionEditor but allows entry of text not in the list
comboEntryEditor :: [Text] -> Editor Text

-- | Editor for the selection of some elements from a static list of
--   elements in the | form of a list box
staticListEditor :: Eq beta => [beta] -> (beta -> Text) -> Editor beta

-- | Editor for the selection of some elements from a static list of
--   elements in the | form of a list box with toggle elements
staticListMultiEditor :: Eq beta => [beta] -> (beta -> Text) -> Editor [beta]

-- | Editor for the selection of some elements from a list of elements in
--   the | form of a list box
multiselectionEditor :: (Show beta, Eq beta) => Editor [beta]

-- | Editor for the selection of a file path in the form of a text entry
--   and a button, | which opens a gtk file chooser
fileEditor :: Maybe FilePath -> FileChooserAction -> Text -> Editor FilePath

-- | An editor, which opens another editor You have to inject a value
--   before the button can be clicked.
otherEditor :: (alpha -> Text -> IO (Maybe alpha)) -> Editor alpha

-- | An Editor to display an image
imageEditor :: Editor StockId
okCancelFields :: FieldDescription ()
instance ButtonClass Widget
instance BinClass Widget
instance ContainerClass Widget


-- | Splittable panes containing notebooks with any widgets
module Graphics.UI.Frame.ViewFrame
removePaneAdmin :: RecoverablePane alpha beta delta => alpha -> delta ()
addPaneAdmin :: RecoverablePane alpha beta delta => alpha -> Connections -> PanePath -> delta Bool
notebookInsertOrdered :: PaneMonad alpha => (NotebookClass self, WidgetClass child) => self -> child -> Text -> Maybe Label -> Bool -> alpha ()

-- | Add the change mark or removes it
markLabel :: (WidgetClass alpha, NotebookClass beta) => beta -> alpha -> Bool -> IO ()
posTypeToPaneDirection :: PositionType -> PaneDirection
paneDirectionToPosType :: PaneDirection -> PositionType
paneFromName :: PaneMonad alpha => PaneName -> alpha (IDEPane alpha)
mbPaneFromName :: PaneMonad alpha => PaneName -> alpha (Maybe (IDEPane alpha))
guiPropertiesFromName :: PaneMonad alpha => PaneName -> alpha (PanePath, Connections)

-- | Moves the activePane in the given direction, if possible | If their
--   are many possibilities choose the leftmost and topmost
viewMove :: PaneMonad beta => PaneDirection -> beta ()

-- | Split the currently active pane in horizontal direction
viewSplitHorizontal :: PaneMonad alpha => alpha ()

-- | Split the currently active pane in vertical direction
viewSplitVertical :: PaneMonad alpha => alpha ()
viewSplit' :: PaneMonad alpha => PanePath -> Direction -> alpha ()
viewNewGroup :: PaneMonad alpha => alpha ()
newGroupOrBringToFront :: PaneMonad alpha => Text -> PanePath -> alpha (Maybe PanePath, Bool)
bringGroupToFront :: PaneMonad alpha => Text -> alpha (Maybe PanePath)
viewNest :: PaneMonad alpha => Text -> alpha ()
viewNest' :: PaneMonad alpha => PanePath -> Text -> alpha ()
viewDetach :: PaneMonad alpha => alpha (Maybe (Window, Widget))
viewDetach' :: PaneMonad alpha => PanePath -> Text -> alpha (Maybe (Window, Widget))
handleNotebookSwitch :: PaneMonad beta => Notebook -> Int -> beta ()

-- | Two notebooks can be collapsed to one
viewCollapse :: PaneMonad alpha => alpha ()
viewCollapse' :: PaneMonad alpha => PanePath -> alpha ()

-- | Sets the tab position in the current notebook
viewTabsPos :: PaneMonad alpha => PositionType -> alpha ()

-- | Toggle the tabs of the current notebook
viewSwitchTabs :: PaneMonad alpha => alpha ()
closeGroup :: PaneMonad alpha => Text -> alpha ()
allGroupNames :: PaneLayout -> Set Text

-- | Get a valid panePath from a standard path.
getBestPanePath :: StandardPath -> PaneLayout -> PanePath

-- | Get a standard path.
getBestPathForId :: PaneMonad alpha => Text -> alpha PanePath

-- | Get the path to the active pane
getActivePanePath :: PaneMonad alpha => alpha (Maybe PanePath)
getActivePanePathOrStandard :: PaneMonad alpha => StandardPath -> alpha (PanePath)

-- | Constructs a unique pane name, which is an index and a string
figureOutPaneName :: PaneMonad alpha => Text -> Int -> alpha (Int, Text)

-- | Get the notebook widget for the given pane path
getNotebook :: PaneMonad alpha => PanePath -> alpha Notebook

-- | Get the (gtk) Paned widget for a given path
getPaned :: PaneMonad alpha => PanePath -> alpha Paned

-- | Get the active notebook
getActiveNotebook :: PaneMonad alpha => alpha (Maybe Notebook)
getActivePane :: PaneMonad delta => delta (Maybe (PaneName, Connections))
setActivePane :: PaneMonad delta => Maybe (PaneName, Connections) -> delta ()
getUiManager :: PaneMonad delta => delta UIManager
getWindows :: PaneMonad delta => delta [Window]
getMainWindow :: PaneMonad m => m Window
getActiveWindow :: PaneMonad alpha => alpha (Maybe Window)
getActiveScreen :: PaneMonad alpha => alpha (Maybe Screen)
getLayout :: PaneMonad delta => delta PaneLayout
getPanesSt :: PaneMonad delta => delta (Map PaneName (IDEPane delta))
getPaneMapSt :: PaneMonad delta => delta (Map PaneName (PanePath, Connections))
getPanePrim :: RecoverablePane alpha beta delta => delta (Maybe alpha)
getPanes :: RecoverablePane alpha beta delta => delta ([alpha])

-- | Bring the pane to the front position in its notebook
bringPaneToFront :: RecoverablePane alpha beta delta => alpha -> IO ()

-- | Construct a new notebook,
newNotebook :: PaneMonad alpha => PanePath -> alpha Notebook

-- | Construct a new notebook
newNotebook' :: IO Notebook
getUIAction :: PaneMonad alpha => Text -> (Action -> a) -> alpha (a)
widgetGet :: PaneMonad alpha => [Text] -> (Widget -> b) -> alpha (b)
initGtkRc :: IO ()


-- | Module for default values of a data type
module Default

-- | A class for providing default values for certain types of editors
class Default alpha
getDefault :: Default alpha => alpha
instance Default Bool
instance Default (Maybe alpha)
instance Default Text
instance Default [alpha]
instance (Default alpha, Default beta, Default gamma) => Default (alpha, beta, gamma)
instance (Default alpha, Default beta) => Default (alpha, beta)
instance Default alpha => Default (Either alpha beta)
instance Default Int


-- | Module for making composite editors
module Graphics.UI.Editor.Composite

-- | An editor with a subeditor which gets active, when a checkbox is
--   selected or deselected (if the positive Argument is False)
maybeEditor :: Default beta => (Editor beta, Parameters) -> Bool -> Text -> Editor (Maybe beta)

-- | An editor with a subeditor which gets active, when a checkbox is
--   selected or grayed out (if the positive Argument is False)
disableEditor :: Default beta => (Editor beta, Parameters) -> Bool -> Text -> Editor (Bool, beta)

-- | An editor which composes two subeditors
pairEditor :: (Editor alpha, Parameters) -> (Editor beta, Parameters) -> Editor (alpha, beta)
tupel3Editor :: (Editor alpha, Parameters) -> (Editor beta, Parameters) -> (Editor gamma, Parameters) -> Editor (alpha, beta, gamma)

-- | Like a pair editor, but with a moveable split
splitEditor :: (Editor alpha, Parameters) -> (Editor beta, Parameters) -> Editor (alpha, beta)

-- | An editor with a subeditor which gets active, when a checkbox is
--   selected or deselected (if the positive Argument is False)
eitherOrEditor :: (Default alpha, Default beta) => (Editor alpha, Parameters) -> (Editor beta, Parameters) -> Text -> Editor (Either alpha beta)

-- | An editor with a subeditor, of which a list of items can be selected
multisetEditor :: (Show alpha, Default alpha, Eq alpha) => ColumnDescr alpha -> (Editor alpha, Parameters) -> Maybe ([alpha] -> [alpha]) -> Maybe (alpha -> alpha -> Bool) -> Editor [alpha]
data ColumnDescr row
ColumnDescr :: Bool -> [(Text, row -> [AttrOp CellRendererText])] -> ColumnDescr row
filesEditor :: Maybe FilePath -> FileChooserAction -> Text -> Editor [FilePath]
textsEditor :: (Text -> Bool) -> Bool -> Editor [Text]
versionEditor :: Editor Version
versionRangeEditor :: Editor VersionRange
dependencyEditor :: [PackageIdentifier] -> Editor Dependency
dependenciesEditor :: [PackageIdentifier] -> Editor [Dependency]
instance Eq Version1
instance Eq Version2
instance Default PackageName
instance Default Dependency
instance Default VersionRange
instance Default Version
instance Default Version2
instance Default Version1
instance Show Version2
instance Show Version1
