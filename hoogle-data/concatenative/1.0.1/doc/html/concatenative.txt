-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for postfix control flow.
--   
--   Concatenative gives haskell factor style combinators and arrows for
--   postfix notation. For more information on stack based languages, see
--   <a>http://concatenative.org</a>
@package concatenative
@version 1.0.1


-- | Control.Concatenative brings concatenative combinators in the style of
--   factor (see
--   <a>http://docs.factorcode.org/content/article-dataflow-combinators.html</a>)
--   to haskell in a variety of interfaces, allowing a terse, pointfree
--   style.
module Control.Concatenative

-- | Apply both arguments to a and combine the results
bi :: (a -> b) -> (a -> c) -> (b -> c -> d) -> a -> d

-- | Apply each of three arguments to a and combine the results
tri :: (a -> b) -> (a -> c) -> (a -> d) -> (b -> c -> d -> e) -> a -> e

-- | Apply the first argument to a, the second to b, and combine the
--   results
biSp :: (a -> c) -> (b -> d) -> (c -> d -> e) -> a -> b -> e

-- | Apply the first argument to a, the second to b, and the third to c,
--   combining the results
triSp :: (a -> d) -> (b -> e) -> (c -> f) -> (d -> e -> f -> g) -> a -> b -> c -> g

-- | Apply a function to two values and combine the results
biAp :: (t -> t1) -> (t1 -> t1 -> t2) -> t -> t -> t2

-- | Apply a function to three values and combine the results
triAp :: (a -> b) -> (b -> b -> b -> c) -> a -> a -> a -> c
ifte :: (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b

-- | Like <a>bi</a>, but functions can return monadic values
biM :: Monad m => (a -> m b) -> (a -> m c) -> (b -> c -> m d) -> a -> m d

-- | Like <a>tri</a>, but functions can return monadic values
triM :: Monad m => (a -> m b) -> (a -> m c) -> (a -> m d) -> (b -> c -> d -> m e) -> a -> m e

-- | Like <a>biSp</a>, but functions can return monadic values
biSpM :: Monad m => (a -> m c) -> (b -> m d) -> (c -> d -> m e) -> a -> b -> m e

-- | Like <a>triSp</a>, but functions can return monadic values
triSpM :: Monad m => (a -> m d) -> (b -> m e) -> (c -> m f) -> (d -> e -> f -> m g) -> a -> b -> c -> m g

-- | Like <a>biAp</a>, but functions can return monadic values
biApM :: Monad m => (t -> m t1) -> (t1 -> t1 -> m t2) -> t -> t -> m t2

-- | Like <a>triAp</a>, but functions can return monadic values
triApM :: Monad m => (a -> m b) -> (b -> b -> b -> m c) -> a -> a -> a -> m c

-- | Like <a>biM</a>, but throws away the end result
biM_ :: Monad m => (a -> m b) -> (a -> m c) -> a -> m ()

-- | Like <a>triM</a>, but throws away the end result
triM_ :: Monad m => (a -> m b) -> (a -> m c) -> (a -> m d) -> a -> m ()

-- | Like <a>biApM</a>, but throws away the end result
biApM_ :: Monad m => (t -> m t1) -> t -> t -> m ()

-- | Like <a>triApM</a>, but throws away the end result
triApM_ :: Monad m => (a -> m b) -> a -> a -> a -> m ()

-- | Combine with a binary function
(>>@) :: Arrow a => a b (x, y) -> (x -> y -> z) -> a b z
dup :: Arrow a => a b (b, b)
swap :: Arrow a => a (x, y) (y, x)

-- | Arrow version of <a>biAp</a>
both :: Arrow a => a b c -> a (b, b) (c, c)

-- | Left associative version of <a>&gt;&gt;&gt;</a>
(>>.) :: Arrow a => a b c -> a c d -> a b d

-- | Left associative version of <a>&amp;&amp;&amp;</a>
(&&.) :: Arrow a => a b c -> a b c' -> a b (c, c')

-- | Left associative version of <a>***</a>
(**.) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')

-- | Send the first component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
first :: Arrow a => forall b c d. a b c -> a (b, d) (c, d)

-- | A mirror image of <a>first</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
second :: Arrow a => forall b c d. a b c -> a (d, b) (d, c)

-- | Concatenative continuation
newtype Concatenative a b c d
Concatenative :: ((b -> c) -> (a -> d)) -> Concatenative a b c d
with :: Concatenative a b c d -> (b -> c) -> (a -> d)

-- | Lifts a function into <a>Concatenative</a>
cat :: (a -> b) -> Concatenative a b c c

-- | Lift a function and add it to a <a>Concatenative</a> for cleaving
(&.) :: (a -> b) -> (a -> e) -> Concatenative a b (e -> c) c

-- | Construct a <a>Concatenative</a> for cleaving
(.&.) :: Concatenative a b c d -> (a -> e) -> Concatenative a b (e -> c) d

-- | Lift a function and add it to a <a>Concatenative</a> for spreading
(*.) :: (t -> b) -> (a -> b1) -> Concatenative a b (b1 -> c) (t -> c)

-- | Construct a <a>Concatenative</a> for spreading
(.*.) :: Concatenative a b c d -> (e -> f) -> Concatenative e b (f -> c) (a -> d)

-- | Lift a monadic function to a <a>Concatenative</a>
catM :: Monad m => (a -> m b) -> Concatenative a b (m c) (m c)

-- | Construct a <a>Concatenative</a> for spreading monadic functions
clM :: Monad m => Concatenative a b c (m d) -> (a -> m e) -> Concatenative a b (e -> c) (m d)

-- | Lift a monadic function and add it to a <a>Concatenative</a> for
--   cleaving
cl :: Monad m => (a -> m b) -> (a -> m e) -> Concatenative a b (e -> m d) (m d)

-- | Construct a <a>Concatenative</a> for spreading monadic functions
spM :: Monad m => Concatenative a b c (m d) -> (e -> m f) -> Concatenative e b (f -> c) (a -> m d)

-- | Lift a monadic function and add it to a <a>Concatenative</a> for
--   spreading
sp :: Monad m => (a -> m b) -> (e -> m f) -> Concatenative e b (f -> m d) (a -> m d)

-- | Create a <a>Concatenative</a> for applying a function n times
--   
--   <pre>
--   biAp (+1)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   $(apN 2) (+1)
--   </pre>
apN :: Int -> Q Exp

-- | Create a <a>Concatenative</a> for applying a monadic function n times
--   
--   <pre>
--   biApM (+1)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   $(apM 2) (+1)
--   </pre>
apM :: Int -> Q Exp

-- | Convenience synonym for <a>replicateM_</a>
apM_ :: Monad m => Int -> m a -> m ()
