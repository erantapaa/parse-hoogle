-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic serializer/deserializer with compact representation
--   
--   Yet another binary serialization library. Beamable provides efficient
--   and fast serialization, often requiring less space than alternative
--   serializers. Incremental de-serialization is supported.
@package beamable
@version 0.1.1.1

module Data.Beamable.Util
peekBS :: Storable a => ByteString -> a
unL :: (l :+: r) a -> l a
unR :: (l :+: r) a -> r a

module Data.Beamable.Internal
class Beamable a where beam v = gbeam (from v) (0, 0) unbeam v = first to $ gunbeam v (0, 0) typeSignR prev v = gtypeSign prev (from v)
beam :: Beamable a => a -> Builder
unbeam :: Beamable a => ByteString -> (a, ByteString)
typeSignR :: Beamable a => [String] -> a -> Word64

-- | Get type signature of arbitrary Beamable datatatype encoded as Word64
--   hash with all constructors and datatypes in it. It's preferable to use
--   <a>typeSign</a> against typeSignR, because implementation of later
--   might change.
typeSign :: Beamable a => a -> Word64
newtype TypeSign
TypeSign :: Word64 -> TypeSign
unTypeSign :: TypeSign -> Word64

-- | <tt>Phantom a</tt> has just one possible value, like <tt>()</tt>, and
--   is encoded as a 0-byte sequence. However, its <a>typeSign</a> depends
--   on the <a>typeSign</a> of its parameter.
data Phantom a
Phantom :: Phantom a
instance Num TypeSign
instance Show TypeSign
instance Eq TypeSign
instance Storable TypeSign
instance Show (Phantom a)
instance Eq (Phantom a)
instance Ord (Phantom a)
instance Enum (Phantom a)
instance Beamable a => Beamable (Phantom a)
instance Beamable ByteString
instance Beamable ByteString
instance Beamable a => Beamable [a]
instance Beamable Bool
instance Beamable a => Beamable (Maybe a)
instance (Beamable a, Beamable b) => Beamable (Either a b)
instance (Beamable a, Beamable b, Beamable c, Beamable d, Beamable e, Beamable f, Beamable g) => Beamable (a, b, c, d, e, f, g)
instance (Beamable a, Beamable b, Beamable c, Beamable d, Beamable e, Beamable f) => Beamable (a, b, c, d, e, f)
instance (Beamable a, Beamable b, Beamable c, Beamable d, Beamable e) => Beamable (a, b, c, d, e)
instance (Beamable a, Beamable b, Beamable c, Beamable d) => Beamable (a, b, c, d)
instance (Beamable a, Beamable b, Beamable c) => Beamable (a, b, c)
instance (Beamable a, Beamable b) => Beamable (a, b)
instance Beamable ()
instance Beamable Char
instance Beamable Integer
instance Beamable TypeSign
instance Beamable Double
instance Beamable Float
instance Beamable Word64
instance Beamable Word32
instance Beamable Word16
instance Beamable Word8
instance Beamable Word
instance Beamable Int64
instance Beamable Int32
instance Beamable Int16
instance Beamable Int8
instance Beamable Int
instance Beamable a => GBeamable (K1 i a)
instance (GBeamable a, GBeamable b) => GBeamable (a :*: b)
instance GBeamable U1
instance GBeamable a => GBeamable (M1 S c a)
instance (GBeamable a, GBeamable b) => GBeamable (a :+: b)
instance (Datatype d, GBeamable a, GBeamable b) => GBeamable (M1 D d (a :+: b))
instance (GBeamable a, Constructor c) => GBeamable (M1 C c a)
instance (GBeamable a, Datatype d, Constructor c) => GBeamable (M1 D d (M1 C c a))


-- | To serialize your own datatype first you need to add DeriveGeneric
--   pragma to the module where your data is declared, derive Generic
--   instance for that datatype and add empty instance declaration for
--   Beamable class
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   </pre>
--   
--   <pre>
--   data Foo = Foo1 Int | Foo2 String deriving (Generic}
--   instance Beamable Foo
--   </pre>
module Data.Beamable
class Beamable a where beam v = gbeam (from v) (0, 0) unbeam v = first to $ gunbeam v (0, 0) typeSignR prev v = gtypeSign prev (from v)
beam :: Beamable a => a -> Builder
unbeam :: Beamable a => ByteString -> (a, ByteString)

-- | Get type signature of arbitrary Beamable datatatype encoded as Word64
--   hash with all constructors and datatypes in it. It's preferable to use
--   <a>typeSign</a> against typeSignR, because implementation of later
--   might change.
typeSign :: Beamable a => a -> Word64

-- | Encode single value into compact bytestring, for encoding large number
--   of values use beam and toByteString from Blaze.ByteString.Builder
encode :: Beamable a => a -> ByteString

-- | Decode single value from bytestring. ByteString must be exactly
--   correct size
decode :: Beamable a => ByteString -> a

-- | Encode single value with extra type singature added, this adds 8 bytes
--   to binary representation, but will prevent decoding using invalid data
--   instances
encodeSigned :: Beamable a => a -> ByteString

-- | Decode single value encoded with encodeSigned
decodeSigned :: Beamable a => ByteString -> a
data Decoder a
encodeLive :: Beamable a => a -> ByteString
decodeLive :: Beamable a => Decoder a
feed :: Beamable a => Decoder a -> ByteString -> Either (Decoder a) (a, ByteString)

-- | <tt>Phantom a</tt> has just one possible value, like <tt>()</tt>, and
--   is encoded as a 0-byte sequence. However, its <a>typeSign</a> depends
--   on the <a>typeSign</a> of its parameter.
data Phantom a
Phantom :: Phantom a
data Builder :: *

-- | Run the builder to construct a strict bytestring containing the
--   sequence of bytes denoted by the builder. This is done by first
--   serializing to a lazy bytestring and then packing its chunks to a
--   appropriately sized strict bytestring.
--   
--   <pre>
--   toByteString = packChunks . toLazyByteString
--   </pre>
--   
--   Note that <tt><a>toByteString</a></tt> is a <tt>Monoid</tt>
--   homomorphism.
--   
--   <pre>
--   toByteString mempty          == mempty
--   toByteString (x `mappend` y) == toByteString x `mappend` toByteString y
--   </pre>
--   
--   However, in the second equation, the left-hand-side is generally
--   faster to execute.
toByteString :: Builder -> ByteString
