-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for reading CDB (Constant Database) files.
--   
--   A library for reading CDB (Constant Database) files.
--   
--   CDB files are immutable key-value stores, designed for extremely fast
--   and memory-efficient construction and lookup. They can be as large as
--   4GB, and at no point in their construction or use must all data be
--   loaded into memory. CDB files can contain multiple values for a given
--   key.
--   
--   For more information on the CDB file format, please see:
--   <a>http://cr.yp.to/cdb.html</a>
@package hs-cdb
@version 0.1.1

module Database.CDB.Util
cdbHash :: ByteString -> Word32

module Database.CDB.Packable

-- | An instance of <a>Packable</a> can be losslessly transformed into a
--   <a>ByteString</a>.
class Packable k
pack :: Packable k => k -> ByteString

-- | An instance of <a>Unpackable</a> can be losslessly transformed from a
--   <a>ByteString</a>.
class Unpackable v
unpack :: Unpackable v => ByteString -> v
instance Packable (UArray Word32 Word32)
instance Packable Word32
instance Unpackable [Word8]
instance Packable [Word8]
instance Unpackable [Char]
instance Packable [Char]
instance Unpackable ByteString
instance Packable ByteString

module Database.CDB.Write
type CDBMake = StateT CDBMakeState IO ()

-- | Construct a CDB as described inside the supplied CDBMake computation.
--   During construction, it will be written to a temporary file and then
--   moved over top of the given file atomically.
cdbMake :: FilePath -> CDBMake -> IO ()

-- | Adds a given key-value pair to the CDB being built.
cdbAdd :: (Packable k, Packable v) => k -> v -> CDBMake

-- | Add a list of key-value pairs to the CDB being built.
cdbAddMany :: (Packable k, Packable v) => [(k, v)] -> CDBMake

module Database.CDB.Read

-- | Internal representation of a CDB file on disk.
data CDB

-- | Loads a CDB from a file.
cdbInit :: FilePath -> IO CDB

-- | Finds the first entry associated with a key in a CDB.
cdbGet :: (Packable k, Unpackable v) => CDB -> k -> Maybe v

-- | Finds all entries associated with a key in a CDB.
cdbGetAll :: (Packable k, Unpackable v) => CDB -> k -> [v]

-- | Returns True if the CDB has a value associated with the given key.
cdbHasKey :: Packable k => CDB -> k -> Bool

-- | Returns the number of values a CDB has for a given key.
cdbCount :: Packable k => CDB -> k -> Int


-- | A library for reading and writing CDB (Constant Database) files.
--   
--   CDB files are immutable key-value stores, designed for extremely fast
--   and memory-efficient construction and lookup. They can be as large as
--   4GB, and at no point in their construction or use must all data be
--   loaded into memory. CDB files can contain multiple values for a given
--   key.
--   
--   For more information on the CDB file format, please see:
--   <a>http://cr.yp.to/cdb.html</a>
--   
--   Using <tt>hs-cdb</tt> should be fairly straightforward. Here's a
--   simple example:
--   
--   <pre>
--   printStuff :: IO ()
--   printStuff = do
--     cdb &lt;- cdbInit "my.cdb"
--     let foo = cdbGet cdb "foo"
--     let bars = cdbGetAll cdb "bar"
--     maybe (putStrLn "Not found") putStrLn foo
--     mapM_ putStrLn bars
--   </pre>
--   
--   The CDB will be automatically cleaned up by the garbage collector
--   after use.
--   
--   The only sticking point may be the use of the <a>Packable</a> and
--   <a>Unpackable</a> classes. This allows the <tt>hs-cdb</tt> interface
--   to be both generic (so your CDB can store effectively any kind of
--   data) but also convenient in the common case of plaintext data.
--   Internally, <tt>hs-cdb</tt> uses <tt>ByteString</tt>s, but it will
--   automatically pack and unpack keys and values to suit the types you're
--   using in your program. In particular, in an instance is provided for
--   <a>String</a>, so <tt>hs-cdb</tt> can use <a>String</a>s as keys and
--   values transparently.
--   
--   Writing a CDB is just as straightforward:
--   
--   <pre>
--   makeCDB :: IO ()
--   makeCDB = cdbMake "my.cdb" $ do
--     cdbAdd "foo" "this is the data associated with foo"
--     cdbAddMany [("bar1", "bar1data"), ("bar2", "bar2data")]
--   </pre>
--   
--   Again, <tt>hs-cdb</tt> automatically closes the files after use.
--   Moreover, in CDB tradition, <tt>hs-cdb</tt> actually creates a CDB
--   named <tt>file.cdb</tt> by first writing it to <tt>file.cdb.tmp</tt>,
--   and then atomically renaming it over <tt>file.cdb</tt>. This means
--   that readers never need to pause when you're regenerating a CDB.
--   
--   Note that the CDBMake monad is nothing more than a State wrapper
--   around the IO monad, so you can use IO commands with liftIO from
--   Control.Monad.State.
module Database.CDB

-- | Internal representation of a CDB file on disk.
data CDB

-- | An instance of <a>Packable</a> can be losslessly transformed into a
--   <a>ByteString</a>.
class Packable k
pack :: Packable k => k -> ByteString

-- | An instance of <a>Unpackable</a> can be losslessly transformed from a
--   <a>ByteString</a>.
class Unpackable v
unpack :: Unpackable v => ByteString -> v

-- | Loads a CDB from a file.
cdbInit :: FilePath -> IO CDB

-- | Finds the first entry associated with a key in a CDB.
cdbGet :: (Packable k, Unpackable v) => CDB -> k -> Maybe v

-- | Finds all entries associated with a key in a CDB.
cdbGetAll :: (Packable k, Unpackable v) => CDB -> k -> [v]

-- | Returns True if the CDB has a value associated with the given key.
cdbHasKey :: Packable k => CDB -> k -> Bool

-- | Returns the number of values a CDB has for a given key.
cdbCount :: Packable k => CDB -> k -> Int

-- | Construct a CDB as described inside the supplied CDBMake computation.
--   During construction, it will be written to a temporary file and then
--   moved over top of the given file atomically.
cdbMake :: FilePath -> CDBMake -> IO ()

-- | Adds a given key-value pair to the CDB being built.
cdbAdd :: (Packable k, Packable v) => k -> v -> CDBMake

-- | Add a list of key-value pairs to the CDB being built.
cdbAddMany :: (Packable k, Packable v) => [(k, v)] -> CDBMake
