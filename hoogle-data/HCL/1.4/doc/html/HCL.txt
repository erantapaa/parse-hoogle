-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | High-level library for building command line interfaces.
--   
--   This module provides a set of functions for building simple
--   command-line interfaces. It allows interfaces which collect values
--   (such as Integers, Dates, or other structured values), build lists of
--   values, and use simple menus. It is not intended to build complex
--   interfaces with full cursor control. It is oriented towards line-based
--   interfaces.
@package HCL
@version 1.4


-- | This module provides a set of functions for building simple
--   command-line interfaces. It allows interfaces which collect values
--   (such as Integers, Dates, or other structured values), build lists of
--   values, and use simple menus. It is not intended to build complex
--   interfaces with full cursor control. It is oriented towards line-based
--   interfaces.
--   
--   <i>Requests</i>
--   
--   The central concept of the library is the <a>Request</a> type, which
--   embodies an interactive request for data. When requesting data, there
--   is always the possibility of failure. That is, the user may enter a
--   value that doesn't parse, or may want to quit the process. For this
--   reason, the value stored by a request is <tt><a>IO</a> (<a>Maybe
--   a</a>)</tt>, which shows there may not always be a value available.
--   <a>Request</a> is a monad, and when a request fails, no subsequent
--   requests are asked. Instead, the whole request chain is abandoned.
--   
--   The function <a>reqResp</a> gives the most basic request possible,
--   which is for a string. From this, other requests can be built. The
--   library provides several:
--   
--   <ul>
--   <li><a>reqInt</a> - Requests <a>Int</a> values.</li>
--   <li><a>reqInteger</a> - Requests <a>Integer</a> values.</li>
--   <li><a>reqRead</a> - Requests <a>Read</a>-able values.</li>
--   <li><a>reqList</a> - Asks a request repeatedly and builds a list of
--   the responses, which are returned when the user enters a failure
--   value.</li>
--   <li><a>reqMenu</a> - Given a list of items, asks the user to pick one
--   of the items and returns it.</li>
--   <li><a>reqFail</a> - Always results in failure. Useful in menus for
--   creating a "quit" or "none" selection.</li>
--   </ul>
--   
--   A number of request patterns are also exported by the module. These
--   embody different control schemes that are useful when building
--   command-line interfaces. These include:
--   
--   <ul>
--   <li><a>reqIf</a> - Takes a request which evaluates to a boolean and
--   two requests representing "then" and "else" branches. The appropriate
--   subsequent request is used, based on the value of the conditional
--   request.</li>
--   <li><a>reqAgree</a> - Takes a request and determines if the user
--   answers yes or no. A default can also be provided.</li>
--   <li><a>reqForever</a> - Takes a request and asks it over and over,
--   until a failure value appears.</li>
--   <li><a>reqIterate</a> - Takes a function which, given a value,
--   produces a request. An initial <a>Request</a> value is also provided.
--   The initial value is given to the function, and the value produced by
--   the function is fed back into it. This continues until a failure
--   occurs. This model is useful for shell-type applications which take a
--   state, operate on it, and produce a new state, which is then fed back
--   in.</li>
--   <li><a>reqCont</a> - Takes a request and a "continuation" request. If
--   the first request fails, the "continuation" request is run. This is
--   useful for confirming if the user really wants to quit an application,
--   or other escape mechanisms.</li>
--   </ul>
--   
--   <i>Running Requests</i>
--   
--   Requests can be run with two different functions:
--   
--   <ul>
--   <li><a>execReq</a> - Takes a request, runs it, and returns a
--   meaningless value. This is most often used to run a request from
--   'main'.</li>
--   <li><a>runRequest</a> - Runs a request and returns the raw
--   <tt><a>IO</a> (<a>Maybe a</a>)</tt> value returned. This is useful for
--   running a request and extracting the value returned out of it.</li>
--   </ul>
--   
--   <i>Prompting</i>
--   
--   In most req functions, except <a>reqMenu</a> and <a>reqChoices</a>,
--   nothing is printed to the screen. Instead, a set of functions is
--   provided which take a request and a string to use as a prompt. These
--   functions include:
--   
--   <ul>
--   <li><a>prompt</a> - Displays a message and gets a response. If the
--   message ends in a space, it is assumed that input should be typed on
--   the same line. Otherwise, a newline is printed and input is then
--   gathered.</li>
--   <li><a>prompt1</a> -- Simple way to ask for a response and provide a
--   default.</li>
--   <li><a>promptAgree</a> -- Simple way to ask for a yes/no
--   response.</li>
--   </ul>
--   
--   <i>Simple Programs</i>
--   
--   Getting values combines prompting and requests. Here's a 'guess a
--   number' game which probably isn't real fun (from
--   examples\guess_num.hs):
--   
--   <pre>
--   guess_num_boring =
--       do
--         num &lt;- prompt "Enter your guess between 1 - 100: " reqInt
--         if num == 50
--           then reqIO $ putStrLn "You win!"
--           else reqIO $ putStrLn "Too bad!"
--   </pre>
--   
--   To run the program, type <tt>play_game guess_num_boring</tt> at the
--   prompt. A better program might actually randomize the number, and tell
--   you if you are low or high (again from examples\guess_num.hs):
--   
--   <pre>
--   guess_num_fun =
--         do
--           target &lt;- reqIO $ getStdRandom (randomR (1::Integer,100))
--           let guessed val =
--                 case compare target val of
--                   GT -&gt; do { reqIO $ putStrLn "Too low!"; return False }
--                   LT -&gt; do { reqIO $ putStrLn "Too high!"; return False }
--                   EQ -&gt; do { reqIO $ putStrLn "You win!"; return True }
--           reqUntil guessed (prompt "Enter a number between 1 and 100: " reqInteger)
--   
--   play_game game = execReq game
--   </pre>
--   
--   To run the program, type <tt>play_game guess_num_fun</tt> at the
--   prompt. Several features of this program are worth pointing out:
--   
--   <ul>
--   <li><a>reqIO</a> - This function is used to lift IO operations into
--   the <a>Request</a> type.</li>
--   <li><a>reqUntil</a> - This function takes a condition and a request,
--   and runs the request until the condition is satisfied. The conditional
--   has the type <tt>(a -&gt; Request b)</tt>, which allows the
--   conditional to produce output, or base its decision on other requests.
--   Naturally, the second argument has the type <tt>(Request a)</tt>,
--   which means the result of the request can be passed to the condition.
--   Other functions which wrap up input patterns are <a>reqFoldl</a>,
--   <a>reqList</a>, <a>reqCont</a>, and others.</li>
--   </ul>
--   
--   <i>Combining Requests</i>
--   
--   The functions in this library are designed to allow more complex
--   <a>Request</a> values to be built from them. For example, imagine you
--   are coding for a tax form submission and have a data type like this
--   (from examples\taxpayer.hs):
--   
--   <pre>
--   data Taxpayer = Taxpayer { name :: String, age :: Int, ssn :: String }
--    deriving (Read, Show)
--   </pre>
--   
--   Because <tt>Taxpayer</tt> derives <a>Read</a>, a simple way of
--   collecting a <tt>Taxpayer</tt> value from the user would be:
--   
--   <pre>
--   reqTaxpayer :: Request Taxpayer
--   reqTaxpayer = prompt "Please enter tax payer information: " (reqRead reqResp)
--   </pre>
--   
--   Of course, this isn't very friendly:
--   
--   <pre>
--   *Main&gt; getTaxpayer reqTaxpayer
--   Please enter tax payer information: Taxpayer {name="John", age = 30, ssn = "" }
--   You entered: Taxpayer {name = "John", age = 30, ssn = ""}
--   </pre>
--   
--   Typing <tt>Taxpayer { name = "John" ... }</tt> each time is pretty
--   tedious. A better solution builds the value from simpler pieces:
--   
--   <pre>
--   reqTaxpayerEasy :: Request Taxpayer
--   reqTaxpayerEasy =
--     do
--       name &lt;- prompt "Please enter the tax payer's name: " reqResp
--       age &lt;- prompt "Please enter their age: " reqInt
--       ssn &lt;- prompt "What is their SSN/ASN: " reqResp
--       return (Taxpayer name age ssn)
--   </pre>
--   
--   Now, when tax payer info must be entered a nice set of prompts is
--   displayed:
--   
--   <pre>
--   *Main&gt; getTaxpayer reqTaxpayerEasy
--   Please enter the tax payer's name: Bob
--   Please enter their age: 50
--   Please enter their SSN/ASN: 111-11-1111
--   You entered: Taxpayer {name = "Bob", age = 50, ssn = "111-11-1111"}
--   </pre>
--   
--   <i>Validation</i>
--   
--   HCL provides the <a>reqWhile</a> and <a>reqUntil</a> functions which
--   help ensure values entered are correct. For example, in the above, we
--   could validate SSN's fairly easily like so (again, from
--   example\tax_payer.hs):
--   
--   <pre>
--   reqSSN :: Request String -&gt; Request String
--   reqSSN req =
--     do
--       -- very simple validation
--       let
--         matchSSN = matchRegex (mkRegex "^...-..-....$")
--         invalidSSN ssn = return $ isNothing (matchSSN ssn)
--       ssn &lt;- reqWhile invalidSSN req
--       return ssn
--   </pre>
--   
--   In the above, <a>reqWhile</a> repeatedly uses <tt>invalidSSN</tt> to
--   determine if the value entered matches the (very simple) regular
--   expression provided. When it does, the SSN entered is returned. Until
--   then, the request is asked over and over. One subtlety to note is that
--   a request to get the actual value is passed in to the function as
--   <tt>req</tt>. This allows the function <tt>reqTaxpayerValidate</tt> to
--   pass it's own prompt and request into reqSSN:
--   
--   <pre>
--   reqTaxpayerValidate :: Request Taxpayer
--   reqTaxpayerValidate =
--     do
--       name &lt;- prompt "Please enter the tax payer's name: " reqResp
--       age &lt;- prompt "Please enter their age: " reqInt
--       ssn &lt;- reqSSN (prompt "What is their SSN/ASN: " reqResp)
--       return (Taxpayer name age ssn)
--   </pre>
--   
--   Running <tt>reqTaxpayerValidate</tt> from the prompt then gives:
--   
--   <pre>
--   *Main&gt; getTaxpayer reqTaxpayerValidate
--   Please enter the tax payer's name: Bob
--   Please enter their age: 20
--   What is their SSN/ASN: 324=12=1231
--   What is their SSN/ASN: 324-12-1211
--   You entered: Taxpayer {name = "Bob", age = 20, ssn = "324-12-1211"}
--   </pre>
--   
--   <i>Dealing with Failure</i>
--   
--   A fundamental assumption of the <a>Request</a> type is that requests
--   can fail. The user can enter no input or provide bad input. The
--   discussion of validation above is a bit disingenuous because it does
--   not mention what happens when the user just types a newline at the
--   prompt. In all cases, the request chain ends and the program exits.
--   
--   This is due to the behavior of the <a>Request</a> monad - as soon as
--   one request fails, the rest fail. The library provides several
--   functions for dealing with this:
--   
--   <ul>
--   <li><a>reqDefault</a> - Allows a default value to be supplied, which
--   will be returned if the user provides no input or bad input.</li>
--   <li><a>required</a> - Repeatedly asks a request until the user
--   provides input. "Failure" values will not occur.</li>
--   <li><a>reqCont</a> - Takes two request arguments. If the first fails,
--   the second is used. Useful for providing a "continuation" to a request
--   chain.</li>
--   <li><a>reqWhich</a> - Indicates if a request failed or not, through
--   the use of the <a>Either</a> type. There is no direct way to determine
--   if a request failed (that is, if it evaluates to Nothing, the entire
--   chain fails and you won't see it). This function allows some
--   visibility into if a specific request succeeded or not.</li>
--   </ul>
--   
--   One use for <a>reqCont</a> is to confirm if the user really wants to
--   quit a program. In the guess-a-number game, hitting Enter at a prompt
--   stops the game. This can be avoided by changing how the guess a number
--   game is launched:
--   
--   <pre>
--   guess_num_cont =
--       reqCont guess_num_fun confirm
--     where
--       confirm =
--         reqIf (promptAgree "Are you sure you want to quit? " (Just False) reqResp)
--           reqFail
--           guess_num_cont
--   </pre>
--   
--   Above, <a>reqCont</a> will run <tt>guess_num_fun</tt> until it returns
--   a <tt>Just</tt> value. If <tt>Nothing</tt> is returned, then
--   <tt>reqConfirm</tt> is run. If the user does not wish to quit,
--   <tt>reqConfirm</tt> will run <tt>guess_num_confirm</tt> again.
--   Otherwise, <a>reqFail</a> is run, which causes the request to fail and
--   thus the program to exit. Notice that the confirmation behavior was
--   added by just adding another layer to the request chain. The
--   <tt>guess_num_fun</tt> function was used to provide gameplay -
--   <tt>guess_num_confirm</tt> just added a layer to control when the game
--   ends.
--   
--   However, because this pattern is fairly common, HCL provides the
--   <a>reqConfirm</a> function, which acts just like the <a>reqCont</a>
--   pattern above. That is, it takes a request to run and a request which
--   returns a <a>Bool</a>. If the initial request fails, the confirmation
--   request is run. If that request results in <tt>True</tt>, the failure
--   is allowed to propagate. Otherwise, the initial request is run again.
--   The function <tt>guess_num_confirm</tt> gives an example of its usage:
--   
--   <pre>
--   guess_num_confirm =
--       reqConfirm confirm guess_num_fun 
--     where
--       confirm = promptAgree "Are you sure you want to quit? " (Just False) reqResp
--   </pre>
--   
--   <i>Making Menus</i>
--   
--   Several functions are used to build simple, hierarchical menus. A menu
--   is defined as a list of pairs, where the first element is the label
--   and the second a value to return. Usually, that value is a
--   <a>Request</a>. In some cases it is not. There are two functions used
--   for building menus:
--   
--   <ul>
--   <li><a>reqChoices</a> - A low-level means to build menus. It does not
--   expect the second item in the pair to be a request, and is thus very
--   general.</li>
--   <li><a>reqMenu</a> - Expects the list given to be a pair of a string
--   and another request. When an item is selected, that request is run and
--   the value is returned.</li>
--   <li><a>reqSubMenu</a> - Inserts a menu into a menu. When the item for
--   the submenu is selected, the submenu will display its choices. When
--   the user wishes to exit (by providing a failure value), the previously
--   displayed menu will display again.</li>
--   <li><a>reqMenuItem</a> - Constructs an indvidual menu item.</li>
--   <li><a>reqMenuEnd</a> - Indicates the end of a list of menu
--   items.</li>
--   <li><a>reqMenuExit</a> - A specialized menu item which will cause the
--   menu request to fail. That means we return to the previous menu or
--   exit the request chain altogether, depending on how the menus are
--   structured.</li>
--   </ul>
--   
--   <a>reqMenu</a> and <a>reqSubMenu</a> work together to build
--   hierarchical menus in which the user can automatically navigate "up"
--   by just hitting return. For example, imagine a simple menu-driven PIM:
--   
--   <pre>
--   *Main&gt; pim
--   1. Manage contacts
--   2. Manage calendar
--   ? 1
--   1. Add a contact
--   2. Remove a contact
--   ? &lt;-- User hits return here, returns to main menu
--   1. Manage contacts
--   2. Manage calendar
--   ?
--   </pre>
--   
--   Setting this up is fairly straightforward (from examples\pim.hs):
--   
--   <pre>
--   pim = execReq $ reqConfirm confirm topMenu 
--     where
--       confirm = promptAgree "Are you sure you want to quit?" (Just False) reqResp
--       
--   topMenu =
--     reqMenu $
--     -- Insert a submenu defined elsewhere
--     reqSubMenu topMenu "Manage contacts" manageContactsMenu $
--     -- Insert a sub menu directly
--     reqSubMenu topMenu "Manage calendar"
--       (reqMenuItem "Add an event" notImpl $
--         ...
--         reqMenuExit "Return to previous menu"
--         reqMenuEnd) $
--     ...
--     -- End the menu definition
--     reqMenuEnd
--     
--   -- Defines a partial menu
--   manageContactsMenu =
--     reqMenuItem "Add a contact" notImpl $
--     ...
--     reqMenuExit "Return to previous menu"
--     reqMenuEnd
--   
--   notImpl = reqIO $ putStrLn "This function is not implemented."
--   </pre>
--   
--   <a>reqMenu</a> begins the process of definining a menu.
--   <a>reqMenuItem</a> is used to build a menu item, and when combined
--   with <tt>($)</tt> as above can be used to define a list of menu items
--   "in-line". <a>reqSubMenu</a> takes the menu to return to as its first
--   argument (in the case above, <tt>topMenu</tt>), a label to name the
--   menu item, and a request which will become the submenu. As seen above,
--   submenus can be inserted directly (e.g. "Manage calendar"), or they
--   can be defined independently (e.g. "Manage contacts").
--   <a>reqMenuExit</a> allows the submenu to return to control to its
--   calling menu. Finally, <a>reqMenuEnd</a> can be used to end an
--   "in-line" menu definition.
--   
--   <i>Just Plain Cool</i>
--   
--   Some of the other functions included are just cool to use:
--   
--   <ul>
--   <li><a>reqIterate</a> - This take a function which maps a value to a
--   request and a request. The request is evaluated and the results passed
--   to the function. The result of that function is passed back into the
--   function again. <a>reqIterate</a> is useful for applications that
--   manipulate some sort of environment by repeatedly passing the modified
--   environment back into themselves. An example of this is shown in
--   examples\shell.hs where the <tt>shell</tt> function is repeatedly
--   called from <tt>main</tt> using <a>reqIterate</a>. The hangman game in
--   hangman\hangman.hs also uses this when the <tt>playRound</tt> function
--   is repeatedly called from <tt>main</tt>.</li>
--   <li><a>reqFoldl</a> - Like <tt>foldl</tt>, but for requests. The
--   accumulating function takes values of type a (which come from the
--   request given) and type b (the accumulating value) and produces a
--   <a>Request</a> of type b. If and when the initial request fails,
--   whatever accumulated value that was built is returned.</li>
--   <li><a>reqList</a> - Takes a request and repeatedly runs it, building
--   a list of the results. When the request fails, the list is
--   returned.</li>
--   <li><a>makeReq</a> - Not really so cool, but allows you to construct
--   your own <a>Request</a> values. Values created with <a>makeReq</a> can
--   be extracted with <a>runRequest</a>. However, they will come back with
--   the type <tt>(<a>IO</a> (<a>Maybe a</a>)</tt>, where the value is
--   always a <tt>Just</tt> value.</li>
--   </ul>
--   
--   <i>Examples</i>
--   
--   Several examples are included with the library, including a hangman
--   game you can play:
--   
--   <ul>
--   <li>examples\guess_num.hs - Demonstrates various ways of implementing
--   a <a>guess a number</a> game.</li>
--   <li>examples\pim.hs - Shows how to build simple menus.</li>
--   <li>examples\shell.hs - Shows how to use reqIterate to build a simple
--   shell.</li>
--   <li>examples\tax_payer.hs - Demonstrates how to construct requests for
--   specific structured data types from simpler requests.</li>
--   <li>hangman\hangman.hs - Implements the hangman game. An executable is
--   installed when you install the library - just run <tt>hangman</tt> at
--   the command line.</li>
--   </ul>
module System.Console.HCL

-- | The <tt>Request</tt> data type represents a value requested
--   interactively. The request may have failed or been no response, in
--   which case the request fails. Otherwise, the request holds the
--   response given.
data Request a

-- | Extracts the value from a given request.
runRequest :: Request a -> IO (Maybe a)

-- | Runs a request, throws away the result, and returns an <tt>IO</tt>
--   type (rather than a <tt>Request</tt>). Useful when a request should
--   just be run and we don't care about the result. Generally used at the
--   top level to evaluate a request in main.
execReq :: Request a -> IO ()

-- | Allows <tt>IO</tt> operations in the <tt>Request</tt> type. Same as
--   <tt>liftIO</tt> in <a>MonadIO</a> class (in
--   <tt>Control.Monad.Trans</tt> module)
reqIO :: IO a -> Request a

-- | Takes a value and makes it into a request. Should not be an <tt>IO
--   (Maybe a)</tt> type value, unless multiply nested values is desired.
makeReq :: a -> Request a

-- | The basic request - get a string from the user. If a newline or all
--   whitespace is entered, the request is assumed to be a failure.
reqResp :: Request String

-- | Gets an <a>Integer</a> from the user. If the value entered cannot be
--   converted, the request fails.
reqInteger :: Request Integer

-- | Gets an <a>Int</a> from the user. If the value entered cannot be
--   converted, the request fails.
reqInt :: Request Int

-- | Uses <tt>reads</tt> to process a request. If the value cannot be
--   parsed, fails. Otherwise, returns the value parsed.
reqRead :: Read a => Request String -> Request a

-- | <tt>&amp;&amp;</tt> operator for requests (with failure). Behaves
--   similarly, including <a>short-circuit</a> behavior. If either
--   condition fails, the entire <tt>Request</tt> fails.
andReq :: Request Bool -> Request Bool -> Request Bool

-- | <tt>||</tt> operator for requests (with failure). Behaves similarly,
--   including <a>short-circuit</a> behavior. If either condition fails,
--   the entire <tt>Request</tt> fails.
orReq :: Request Bool -> Request Bool -> Request Bool

-- | not operator for requests.
notReq :: Request Bool -> Request Bool

-- | If statement for requests.
reqIf :: Request Bool -> Request a -> Request a -> Request a

-- | Takes a value and makes it into a request.
reqConst :: a -> Request a

-- | Lifts a one-argument function into <tt>Request</tt> types.
reqLift :: (a -> b) -> Request a -> Request b

-- | Lifts a two argument function into <tt>Request</tt> types. The
--   arguments to the function are evaluated in order, from left to right,
--   since the <tt>Request</tt> monad imposes sequencing.
reqLift2 :: (a -> b -> c) -> Request a -> Request b -> Request c

-- | Like the <tt>maybe</tt> function, but for requests. Given a request
--   value, a default value,and a function that maps <tt>b</tt> to
--   <tt>Request a</tt>, this function either returns the default if the
--   request value is nothing, or it applies the function given to the
--   value of the request and returns it.
reqMaybe :: Request a -> Request b -> (a -> Request b) -> Request b

-- | Returns true if the user answer <tt>y</tt> or <tt>Y</tt>. Allows a
--   default to be specified, and allows failure if no default is given.
reqAgree :: Maybe Bool -> Request String -> Request Bool

-- | Automatic failure. Useful in menus to quit or return to the previous
--   menu.
reqFail :: Request a

-- | Takes a request and guarantees a value will be returned. That is, the
--   request is repeated until a valid (i.e. not <tt>Nothing</tt>) response
--   is returned.
required :: Request a -> Request a

-- | Runs the request until the condition given is satisfied, then returns
--   the result.
reqUntil :: (a -> Request Bool) -> Request a -> Request a

-- | Runs the request while the condition given holds, then returns the
--   result. Good for verification.
reqWhile :: (a -> Request Bool) -> Request a -> Request a

-- | Requests a response from user. If <tt>Nothing</tt> is returned,
--   assumes default and returns that.
reqDefault :: Request a -> a -> Request a
reqForever :: Request a -> Request a

-- | Given a list of items and programs to run, displays a menu of the
--   items and runs the selected program. Very low level - usually
--   <tt>reqMenu</tt> is used instead. If the user selects an invalid
--   choice, failure occurs.
reqChoices :: [(String, a)] -> Request Int -> Request a

-- | Takes an initial value and function which produces a request from that
--   value. Applies the function to the initial value and then recurses.
--   Useful for functions which operate off their own output (e.g. a shell
--   maintaining an environment).
reqIterate :: (a -> Request a) -> a -> Request a

-- | Takes a request and a <a>continuation</a> request. If the first
--   request results in <tt>Nothing</tt>, run the second request. In either
--   case, return the result of the successful request.
reqCont :: Request a -> Request a -> Request a

-- | Executes the request given and, if a failure value occurs, executes
--   the <a>Bool</a> request given (usually some sort of prompt asking if
--   they want to quit). If the answer is <tt>True</tt>, the failure value
--   propagates. Otherwise, the initial request is run again.
reqConfirm :: Request Bool -> Request a -> Request a
reqWhich :: Request a -> Request (Either () a)

-- | Give a function from <tt>a -&gt; b</tt>, an initial value, and a
--   <tt>Request</tt> for <tt>a</tt>, builds a <tt>Request</tt> for
--   <tt>b</tt>. When <tt>(Request a)</tt> fails, then the function returns
--   whatever <tt>(Request b)</tt> has been built.
reqFoldl :: (a -> b -> Request b) -> b -> Request a -> Request b

-- | Given a request, builds a list of response. When the user enters
--   <tt>Nothing</tt>, the list building ends
reqList :: Request a -> Request [a]

-- | Takes a list of strings and requests and forms a menu out of them.
--   Menus can built using <a>reqMenuItem</a>, <a>reqSubMenu</a>,
--   <a>reqMenuExit</a>, and <a>reqMenuEnd</a>.
reqMenu :: [(String, Request a)] -> Request a

-- | Used to add an individual entry to a menu that is being built.
reqMenuItem :: String -> Request a -> [(String, Request a)] -> [(String, Request a)]

-- | Ends a list of menu item definitions.
reqMenuEnd :: [(String, Request a)]

-- | Creates a submenu within a menu. When the submenu exits, control
--   returns to the item specified.
reqSubMenu :: Request a -> String -> [(String, Request a)] -> [(String, Request a)] -> [(String, Request a)]

-- | Causes the program to exit from the current menu.
reqMenuExit :: String -> [(String, Request a)] -> [(String, Request a)]

-- | Prints a message and makes a request. If the message ends in a space,
--   it is assumed that the user should enter values on the same line.
--   Otherwise, a new line is printed and the reqeust is evaulated.
prompt :: String -> Request a -> Request a
promptWithDefault :: Show a => String -> Request a -> a -> Request a

-- | Displays a message prompt and a default choice in a common way. If the
--   user doesn't provide a choice or enters bad data, the default value
--   provided is returned. Otherwise, the value entered is returned.
--   
--   Deprecated name for prompt1.
prompt1 :: Show a => String -> Request a -> a -> Request a

-- | Prints a message, displays defaults (if any), and turns a <tt>Request
--   String</tt> into a <tt>Request Bool</tt>. If a default value is
--   provided, it will be returned if the user enters nothing or an invalid
--   response.
promptAgree :: String -> Maybe Bool -> Request String -> Request Bool
instance Show a => Show (Request a)
instance Show a => Show (RandomRequest a)
instance Arbitrary Char
instance Arbitrary a => Arbitrary (Request a)
instance Arbitrary a => Arbitrary (RandomRequest a)
instance MonadIO Request
instance Monad Request
