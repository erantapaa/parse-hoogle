-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | pec embedded compiler
--   
--   The intent of pec is to provide a drop-in replacement for C, but with
--   modern language features. Pec is a procedural language with a
--   functional/declarative feel. Programming in pec is very similar to
--   monadic programming in Haskell. The primary use case for pec is to
--   provide a productive environment for writing safe, efficient, embedded
--   applications.
@package pec
@version 0.1.1

module Pec.Base
data V a
V :: String -> V a
data Decl a
Decl :: Id -> (Term a) -> Decl a
data Ptr a
data Tag a cnt
data Idx cnt
data Array cnt a
data I cnt
data IString
data W cnt
data Cnt256
Cnt256 :: Cnt256
data Cnt4294967296
Cnt4294967296 :: Cnt4294967296
data SuccCnt cnt
data Term a
Arg :: Id -> (Term a -> Term b) -> Term (a -> b)
Val :: V a -> Term a
App :: Term (a -> b) -> Term a -> Term b
Lift :: M (Term a) -> Term a
data Ty
TyUnit :: Ty
TyEnum :: Integer -> Ty
TyPtr :: Ty -> Ty
TyArray :: Integer -> Ty -> Ty
TyPair :: Ty -> Ty -> Ty
TySum :: [Ty] -> Ty
TyFun :: Ty -> Ty -> Ty
TyDouble :: Ty
TyFloat :: Ty
data St
St :: [String] -> Handle -> Label -> St
istrings_tbl :: St -> [String]
outH :: St -> Handle
last_label :: St -> Label
type CntW32 = Cnt4294967296
type W32 = W CntW32
type Label = String
type M a = StateT St IO a
type Id = String
type CString = Ptr Char
type W_ a = W a
type I_ a = I a
type SuccCnt_ a = SuccCnt a
class Count cnt
countof :: Count cnt => cnt -> Integer
class (Count cnt, Typed a) => Tagged a cnt | a -> cnt
tagof :: Tagged a cnt => Term a -> Term (Tag a cnt)
class Typed a
typeof :: Typed a => a -> Ty
callt :: Typed a => Id -> [(Id, Ty)] -> Term a
class (Typed a, Typed b) => Newtype a b | a -> b
unwrap_ :: Newtype a b => Term (a -> b)
unwrap_ptr_ :: Newtype a b => Term (Ptr a -> Ptr b)
class INT a
int :: INT a => Integer -> Term a
uint :: (Count cnt, Typed (f cnt)) => f cnt -> Integer -> Term (f cnt)
sint :: (Count cnt, Typed (f cnt)) => f cnt -> Integer -> Term (f cnt)
wrap :: (Typed a, Typed b) => Term (a -> b)
unwrap2 :: (Newtype a b, Typed c) => (Term b -> Term b -> Term c) -> Term a -> Term a -> Term c
unused :: a
cast :: (Typed a, Typed b) => Term a -> Term b
tagofp :: (Typed a, Count cnt) => Term (Ptr a) -> Term (Tag (Ptr a) cnt)
alt0 :: (Typed a, Typed b) => (Term () -> Term b) -> Term a -> Term b
alt :: (Typed a, Typed b, Typed c) => (Term (Ptr b) -> Term c) -> Term (Ptr a) -> Term c
constr :: (Typed a, Count cnt, Typed b) => Term (Tag (Ptr a) cnt) -> Term (b -> a)
constr0 :: (Typed a, Count cnt) => Term (Tag (Ptr a) cnt) -> Term a
tagp :: (Typed a, Count cnt) => Term (Ptr a) -> Term (Ptr (Tag (Ptr a) cnt))
datap :: (Typed a, Typed b) => Term (Ptr a) -> Term (Ptr b)
bitcast :: (Typed a, Typed b) => Term (Ptr a) -> Term (Ptr b)
gep :: (Typed a, Typed b) => Term i -> Term (Ptr a) -> Term (Ptr b)
load :: Typed a => Term (Ptr a) -> Term a
prim2 :: (Typed a, Typed b, Typed c) => String -> Term a -> Term b -> Term c
tag :: Typed a => Integer -> Term a
store :: Typed a => Term (Ptr a) -> Term a -> Term ()
pair :: (Typed a, Typed b) => Term a -> Term b -> Term (a, b)
fst_get :: (Typed a, Typed b) => Term (Ptr (a, b)) -> Term (Ptr a)
snd_get :: (Typed a, Typed b) => Term (Ptr (a, b)) -> Term (Ptr b)
fst_ :: (Typed a, Typed b) => Term (Ptr (a, b) -> Ptr a)
snd_ :: (Typed a, Typed b) => Term (Ptr (a, b) -> Ptr b)
array :: (Count cnt, Typed a) => Term cnt -> [Term a] -> Term (Array cnt a)
new_ :: Typed a => Term (a -> Ptr a)
alloca :: Typed a => Term a -> Term (Ptr a)
alloca'_ :: Typed a => Term (Ptr a)
new :: Typed a => Term a -> Term (Ptr a)
lam3_ :: (Typed a, Typed b, Typed c, Typed d) => (Term a -> Term b -> Term c -> Term d) -> Term (a -> b -> c -> d)
lam2_ :: (Typed a, Typed b, Typed c) => (Term a -> Term b -> Term c) -> Term (a -> b -> c)
app3 :: (Typed a, Typed b, Typed c, Typed d) => Term (a -> b -> c -> d) -> Term a -> Term b -> Term c -> Term d
app2 :: (Typed a, Typed b, Typed c) => Term (a -> b -> c) -> Term a -> Term b -> Term c
arg :: (Typed a, Typed b) => Id -> (Term a -> Term b) -> Term (a -> b)
unitarg :: Typed a => Term a -> Term (() -> a)
args :: [(Id, Ty)] -> String
parens :: String -> String
argsof :: Typed a => Term a -> [(Id, Ty)]
define :: Typed a => Decl a -> M ()
switch :: (Tagged a cnt, Typed b) => Term a -> [(Term (Tag a cnt), Term a -> Term b)] -> Term b
phi :: Typed a => [(V a, Label)] -> Term a
phi_arg :: Typed a => (V a, Label) -> String
brackets :: String -> String
eval_alt :: (Typed a, Typed b) => Term a -> Label -> ((z, Term a -> Term b), Label) -> M (V b, Label)
lblout :: Label -> M ()
lblof :: Label -> String
from_istring_ :: Term (IString -> CString)
app :: (Typed a, Typed b) => Term (a -> b) -> Term a -> Term b
evalv :: Term a -> M (V a)
reduce :: Term a -> M (Term a)
val :: Typed a => String -> Term a
is_tyunit :: Ty -> Bool
tof :: Typed a => V a -> String
proc :: Typed a => Id -> Term a -> Decl a
lift :: Typed a => M (Term a) -> Term a
extern :: Typed a => Id -> Decl a
gen_files :: FilePath -> M () -> [String] -> IO ()
gen_file :: FilePath -> M () -> M ()
gen_istrings :: FilePath -> M ()
string :: String -> Term IString
tyof :: Ty -> String
unfold_tyfun :: Ty -> [Ty]
ty_sum :: [Ty] -> Ty
max_tysum :: [Ty] -> Ty
sizeofptr :: Integer
idx :: (Count cnt, Typed a) => Term (Ptr (Array cnt a)) -> Term (Idx cnt) -> Term (Ptr a)
sizeof :: Ty -> Integer
char :: Char -> Term Char
eval :: Typed a => Term a -> M (Term a)
eval_ :: Typed a => Term a -> M ()
lam_ :: (Typed a, Typed b) => (Term a -> Term b) -> Term (a -> b)
with_local :: Typed a => (V a -> M ()) -> Term a
vof :: V a -> String
vtof :: Typed a => V a -> String
out :: Int -> [String] -> M ()
new_local :: M (V a)
new_label :: M Label
unit :: Term ()
call :: Typed a => Decl a -> Term a
declare :: Typed a => Decl a -> M ()
args_ :: [Ty] -> String
const_cstring :: String -> String
const_char :: Char -> String
encode_char :: Enum a => a -> String
bitsToEncode :: Integer -> Integer
freshNm :: IO String
commaSep :: [String] -> String
inttag :: (INT a, Typed a, Count cnt) => Integer -> Term (Tag a cnt)
inttagt :: (INT a, Typed a, Count cnt) => a -> Integer -> Term (Tag a cnt)
chartag :: Char -> Term (Tag Char Cnt256)
stringtag :: String -> Term (Tag IString CntW32)
defaulttag :: Tagged a cnt => Term (Tag a cnt)
instance Eq Ty
instance (Typed a, Count cnt) => Typed (Tag a cnt)
instance Count cnt => Typed (Idx cnt)
instance Count cnt => Typed (W cnt)
instance Count cnt => Typed (I cnt)
instance (Typed a, Typed b) => Typed (a, b)
instance (Typed a, Typed b) => Typed (a -> b)
instance (Typed a, Count cnt) => Typed (Array cnt a)
instance Typed a => Typed (Ptr a)
instance Count cnt => Typed (SuccCnt cnt)
instance Typed IString
instance Typed Float
instance Typed Double
instance Typed Char
instance Typed ()
instance Tagged IString CntW32
instance Tagged Char Cnt256
instance Count cnt => Tagged (W cnt) cnt
instance Count cnt => Tagged (I cnt) cnt
instance Count cnt => INT (W cnt)
instance Count cnt => INT (Idx cnt)
instance Count cnt => INT (I cnt)
instance Count Cnt4294967296
instance Count Cnt256
instance Count cnt => Count (SuccCnt cnt)
