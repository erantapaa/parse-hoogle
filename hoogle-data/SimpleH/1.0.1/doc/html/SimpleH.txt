-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A light, clean and powerful Haskell utility library
--   
--   SimpleH is a Prelude complement that defines a few very useful
--   abstractions, such as Monad transformers, Lenses, parser combinators,
--   reactive abstractions and a few others. synopsis: A light, clean and
--   powerful Haskell utility library
@package SimpleH
@version 1.0.1

module SimpleH.Core
data Void
type (:*:) a b = (a, b)
type (:+:) a b = Either a b

-- | The class of all types that have a binary operation. Note that the
--   operation isn't necesarily commutative (in the case of lists, for
--   example)
class Semigroup m where + = (+)
(+) :: Semigroup m => m -> m -> m

-- | A monoid is a semigroup with a null element such that <tt>zero + a ==
--   a + zero == a</tt>
class Semigroup m => Monoid m where zero = 0
zero :: Monoid m => m
class Monoid m => Ring m where one = 1 * = (*)
one :: Ring m => m
(*) :: Ring m => m -> m -> m
class (Semigroup a, Semigroup b) => SubSemi a b
cast :: SubSemi a b => b -> a
class Unit f
pure :: Unit f => a -> f a

-- | A monoid on category endomorphisms under composition
newtype Endo k a
Endo :: k a a -> Endo k a
runEndo :: Endo k a -> k a a
newtype StrictEndo a
StrictEndo :: (a -> a) -> StrictEndo a
runStrictEndo :: StrictEndo a -> a -> a

-- | The dual of a monoid is the same as the original, with arguments
--   reversed
newtype Dual m
Dual :: m -> Dual m
getDual :: Dual m -> m

-- | The Product monoid
newtype Product a
Product :: a -> Product a
getProduct :: Product a -> a

-- | An ordered list. The semigroup instance merges two lists so that the
--   result remains in ascending order.
newtype OrdList a
OrdList :: [a] -> OrdList a
getOrdList :: OrdList a -> [a]
newtype Interleave a
Interleave :: [a] -> Interleave a
interleave :: Interleave a -> [a]

-- | A monoid on Maybes, where the sum is the leftmost non-Nothing value.
newtype Accum a
Accum :: Maybe a -> Accum a
getAccum :: Accum a -> Maybe a

-- | The Max monoid, where <tt>(+) =~ max</tt>
newtype Max a
Max :: a -> Max a
getMax :: Max a -> a
class Category k
id :: Category k => k a a
(.) :: Category k => k b c -> k a b -> k a c
(<<<) :: Category k => k b c -> k a b -> k a c
(>>>) :: Category k => k a b -> k b c -> k a c
(+++) :: Split k => (a -> k c c) -> (b -> k d d) -> (a :+: b) -> k (c, d) (c, d)
class Category k => Choice k
(<|>) :: Choice k => k a c -> k b c -> k (a :+: b) c
class Category k => Split k
(<#>) :: Split k => k a c -> k b d -> k (a, b) (c, d)
const :: Unit m => a -> m a
(&) :: a -> (a -> b) -> b
fix :: (a -> a) -> a
first :: Split k => k a b -> k (a, c) (b, c)
second :: Split k => k a b -> k (c, a) (c, b)
ifThenElse :: Bool -> a -> a -> a
bool :: a -> a -> Bool -> a
guard :: (Unit m, Monoid (m ())) => Bool -> m ()
fail :: String -> a
unit :: Unit m => m ()
when :: Unit m => Bool -> m () -> m ()
unless :: Unit m => Bool -> m () -> m ()
tailSafe :: [a] -> [a]
headDef :: a -> [a] -> a
class Ord t => Orderable t
inOrder :: Orderable t => t -> t -> (t, t, Bool)

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering
insertOrd :: Orderable t => t -> [t] -> [t]
invertOrd :: Ordering -> Ordering
instance Monoid (Interleave a)
instance Unit OrdList
instance Orderable a => Monoid (OrdList a)
instance Monoid m => Monoid (Dual m)
instance Eq a => Eq (Max a)
instance Ord a => Ord (Max a)
instance Bounded a => Bounded (Max a)
instance Show a => Show (Max a)
instance Eq a => Eq (OrdList a)
instance Ord a => Ord (OrdList a)
instance Show a => Show (OrdList a)
instance Semigroup (Interleave a)
instance Ord t => Orderable (Max t)
instance Orderable a => Semigroup (OrdList a)
instance Ring m => Ring (Dual m)
instance Semigroup m => Semigroup (Dual m)
instance (Ord a, Bounded a) => Ring (Max a)
instance (Ord a, Bounded a) => Monoid (Max a)
instance Ord a => Semigroup (Max a)
instance Unit Accum
instance Monoid a => Monoid (Accum a)
instance Monoid a => Semigroup (Accum a)
instance Semigroup (StrictEndo a)
instance Category k => Monoid (Endo k a)
instance Category k => Semigroup (Endo k a)
instance Ring a => Monoid (Product a)
instance Ring a => Semigroup (Product a)
instance Split (->)
instance Choice (->)
instance Category (->)
instance Unit IO
instance Unit Tree
instance Unit []
instance Unit ((->) b)
instance Monoid w => Unit ((,) w)
instance Unit Maybe
instance Unit (Either a)
instance (Ring a, Ring b) => Ring (a :*: b)
instance Monoid a => Ring [a]
instance Ring Double
instance Ring Float
instance Ring Integer
instance Ring Int
instance Ring Bool
instance Monoid a => SubSemi a Void
instance Monoid a => SubSemi a ()
instance Monoid (Maybe a)
instance Monoid Bool
instance (SubSemi b a, Monoid a) => Monoid (a :+: b)
instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)
instance (Monoid a, Monoid b) => Monoid (a :*: b)
instance Monoid [a]
instance Monoid Double
instance Monoid Float
instance Monoid Integer
instance Monoid Int
instance Monoid ()
instance Monoid Void
instance Semigroup (Maybe a)
instance SubSemi b a => Semigroup (a :+: b)
instance (Semigroup a, Semigroup b, Semigroup c) => Semigroup (a, b, c)
instance (Semigroup a, Semigroup b) => Semigroup (a :*: b)
instance Semigroup [a]
instance Semigroup Integer
instance Semigroup Double
instance Semigroup Float
instance Semigroup Int
instance Semigroup Bool
instance Semigroup ()
instance Semigroup Void


-- | A module for functors
module SimpleH.Functor
class Functor f
map :: Functor f => (a -> b) -> f a -> f b
class Cofunctor f
comap :: Cofunctor f => (a -> b) -> f b -> f a
class Bifunctor p where dimap f g = promap f . map g
dimap :: Bifunctor p => (c -> a) -> (b -> d) -> p a b -> p c d

-- | The Identity Functor
newtype Id a
Id :: a -> Id a
getId :: Id a -> a

-- | The Constant Functor
newtype Const a b
Const :: a -> Const a b
getConst :: Const a b -> a

-- | A motherflippin' functor
newtype Flip f a b
Flip :: f b a -> Flip f a b
unFlip :: Flip f a b -> f b a

-- | The Composition functor
newtype (:.:) f g a
Compose :: f (g a) -> :.: f g a
getCompose :: :.: f g a -> f (g a)
data (:**:) f g a
(:**:) :: f a -> g a -> :**: f g a
newtype (:++:) f g a
Sum :: f a :+: g a -> :++: f g a
getSum :: :++: f g a -> f a :+: g a
(<$>) :: Functor f => (a -> b) -> f a -> f b
(|||) :: (Choice k, Functor (k a), Functor (k b)) => k a c -> k b d -> k (a :+: b) (c :+: d)
(<$) :: Functor f => b -> f a -> f b
(<&>) :: Functor f => f a -> (a -> b) -> f b
void :: Functor f => f a -> f ()
left :: (Choice k, Functor (k a), Functor (k c)) => k a b -> k (a :+: c) (b :+: c)
right :: (Choice k, Functor (k a), Functor (k c)) => k a b -> k (c :+: a) (c :+: b)
promap :: Cofunctor (Flip f c) => (a -> b) -> f b c -> f a c
map2 :: (Functor f, Functor f') => (a -> b) -> f (f' a) -> f (f' b)
map3 :: (Functor f, Functor f', Functor f'') => (a -> b) -> f (f' (f'' a)) -> f (f' (f'' b))
instance Functor OrdList
instance Functor Interleave
instance Show a => Show (Id a)
instance Monad IO
instance Applicative IO
instance Functor IO
instance Functor ((->) a)
instance Functor ((,) b)
instance Functor Maybe
instance Functor (Either b)
instance (Functor f, Functor g) => Functor (f :++: g)
instance (Functor f, Functor g) => Functor (f :**: g)
instance (Functor f, Functor g) => Functor (f :.: g)
instance (Unit f, Unit g) => Unit (f :.: g)
instance Monoid a => Applicative (Const a)
instance Monoid a => Unit (Const a)
instance Functor (Const a)
instance Semigroup a => Semigroup (Const a b)
instance Monad Id
instance Applicative Id
instance Functor Id
instance Unit Id
instance Functor Tree
instance Functor []
instance Bifunctor (->)
instance Cofunctor (Flip (->) a)
instance (Functor f, Cofunctor g) => Cofunctor (f :.: g)

module SimpleH.Foldable
class Functor t => Foldable t
fold :: (Foldable t, Monoid m) => t m -> m
newtype Sized f a
Sized :: f a -> Sized f a
getSized :: Sized f a -> f a
foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m
convert :: (Unit f, Monoid (f a), Foldable t) => t a -> f a
concat :: (Monoid m, Foldable t) => t m -> m
sum :: (Monoid m, Foldable t) => t m -> m
size :: (Foldable f, Num n, Monoid n) => f a -> n
count :: (Num n, Monoid n, Foldable f) => f a -> n
length :: (Num n, Monoid n) => [a] -> n
split :: (Foldable t, Monoid b, Monoid c) => t (b :+: c) -> (b, c)
partitionEithers :: (Foldable t, Unit t, Monoid (t a), Monoid (t b)) => t (a :+: b) -> (t a, t b)
partition :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> (f a, f a)
filter :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> f a
select :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> f a
refuse :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> f a
compose :: (Category k, Foldable t) => t (k a a) -> k a a
foldr :: Foldable t => (b -> a -> a) -> a -> t b -> a
foldr1 :: (a -> a -> a) -> [a] -> a
foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
foldl1' :: (a -> a -> a) -> [a] -> a
toList :: Foldable t => t a -> [a]
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
or :: Foldable t => t Bool -> Bool
and :: Foldable t => t Bool -> Bool
all :: Foldable t => (a -> Bool) -> t a -> Bool
any :: Foldable t => (a -> Bool) -> t a -> Bool
elem :: (Eq a, Foldable t) => a -> t a -> Bool
instance Foldable OrdList
instance Foldable Interleave
instance (Foldable f, Foldable g) => Foldable (f :++: g)
instance (Foldable f, Foldable g) => Foldable (f :**: g)
instance (Foldable f, Semigroup (Sized f a), Monoid n, Num n) => SubSemi n (Sized f a)
instance (Foldable f, Foldable g) => Foldable (f :.: g)
instance Foldable Tree
instance Foldable []
instance Foldable ((,) a)
instance Foldable Maybe
instance Foldable (Either a)
instance Foldable Id


-- | A module describing applicative functors
module SimpleH.Applicative
class (Unit f, Functor f) => Applicative f where fs <*> xs = fs >>= \ f -> map f xs
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | A wrapper type for lists with zipping Applicative instances, such that
--   <tt>ZipList [f1,...,fn] <a>&lt;*&gt;</a> ZipList [x1,...,xn] ==
--   ZipList [f1 x1,...,fn xn]</tt>
newtype ZipList a
ZipList :: [a] -> ZipList a
getZipList :: ZipList a -> [a]

-- | The Tree equivalent to ZipList
newtype ZipTree a
ZipTree :: (Tree a) -> ZipTree a

-- | A wrapper for applicative functors with actions executed in the
--   reverse order
newtype Backwards f a
Backwards :: f a -> Backwards f a
forwards :: Backwards f a -> f a
(*>) :: Applicative f => f b -> f a -> f a
(<*) :: Applicative f => f a -> f b -> f a
(<**>) :: Applicative f => f (a -> b) -> f a -> f b
ap :: Applicative f => f (a -> b) -> f a -> f b
sequence_ :: (Applicative f, Foldable t) => t (f a) -> f ()
traverse_ :: (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
for_ :: (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
forever :: Applicative f => f a -> f b
between :: Applicative f => f b -> f c -> f a -> f a
liftA :: Functor f => (a -> b) -> (f a -> f b)
liftA2 :: Applicative f => (a -> b -> c) -> (f a -> f b -> f c)
liftA3 :: Applicative f => (a -> b -> c -> d) -> (f a -> f b -> f c -> f d)
liftA4 :: Applicative f => (a -> b -> c -> d -> e) -> (f a -> f b -> f c -> f d -> f e)
plusA :: (Applicative f, Semigroup a) => f a -> f a -> f a
zeroA :: (Unit f, Monoid a) => f a
filter :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> f a
instance Functor f => Functor (Backwards f)
instance Unit f => Unit (Backwards f)
instance Ring (f a) => Ring (Backwards f a)
instance Monoid (f a) => Monoid (Backwards f a)
instance Semigroup (f a) => Semigroup (Backwards f a)
instance Foldable ZipTree
instance Foldable ZipList
instance Unit Interleave
instance (Applicative f, Monoid (g a)) => Monoid ((:.:) f g a)
instance (Applicative f, Semigroup (g a)) => Semigroup ((:.:) f g a)
instance Applicative f => Applicative (Backwards f)
instance Applicative ZipTree
instance Unit ZipTree
instance Functor ZipTree
instance Applicative ZipList
instance Unit ZipList
instance Functor ZipList
instance Monoid a => Monoid (ZipList a)
instance Semigroup a => Semigroup (ZipList a)
instance Monad Interleave
instance Applicative Interleave
instance (Applicative f, Applicative g) => Applicative (f :.: g)
instance Monad Tree
instance Applicative Tree
instance (Applicative f, Applicative g) => Applicative (f :**: g)
instance (Unit f, Unit g) => Unit (f :**: g)
instance Monad []
instance Applicative []
instance Monoid w => Monad ((,) w)
instance Monoid w => Applicative ((,) w)
instance Monad ((->) a)
instance Ring b => Ring (a -> b)
instance Monoid b => Monoid (a -> b)
instance Semigroup b => Semigroup (a -> b)
instance Applicative ((->) a)
instance Monad (Either a)
instance Applicative (Either a)


-- | A module providing simple Lens functionality.
--   
--   Lenses are a Haskell abstraction that allows you to access and modify
--   part of a structure, compensating for and improving upon Haskell's
--   horrendous record syntax and giving Haskell a first-class record
--   system.
--   
--   This module defines three kinds of Lenses : Lenses that allow you to
--   access part of a structure; Traversals that allow you to modify part
--   of a structure; and Isos which may be reversed. Lenses of any kind can
--   be composed with <tt>(.)</tt>, yielding a Lens of the most general
--   kind, so that composing a Lens with a Traversal or Iso yields a Lens,
--   and a Traversal with an Iso yields a Traversal.
module SimpleH.Lens
type Iso s t a b = forall p f. (Functor f, Bifunctor p) => p s (f t) -> p a (f b)
type Iso' a b = Iso b b a a
type (:<->:) a b = Iso' a b
type LensLike f s t a b = (s -> f t) -> (a -> f b)
type LensLike' f a b = LensLike f b b a a
type Fold s t a b = forall f. (Semigroup (f b), Applicative f) => LensLike f s t a b
type Fold' a b = Fold b b a a
type Getter s t a b = LensLike (Const s) s t a b
type Getter' a b = Getter b b a a
type Lens s t a b = forall f. Functor f => LensLike f s t a b
type Lens' a b = Lens b b a a
type Traversal s t a b = forall f. Applicative f => LensLike f s t a b
type Traversal' a b = Traversal b b a a

-- | Create an <a>Iso</a> from two inverse functions.
iso :: (a -> s) -> (t -> b) -> Iso s t a b

-- | Reverse an <a>Iso</a>
--   
--   <pre>
--   from :: <a>Iso'</a> a b -&gt; <a>Iso'</a> b a
--   </pre>
from :: Iso s t a b -> Iso b a t s

-- | Create a <a>Lens</a> from a getter and setter function.
--   
--   <pre>
--   lens :: (a -&gt; b) -&gt; (a -&gt; b -&gt; a) -&gt; <a>Lens'</a> a b
--   </pre>
lens :: (a -> s) -> (a -> t -> b) -> Lens s t a b
getter :: (a -> b) -> Traversal' a b

-- | Create a <a>Traversal</a> from a maybe getter and setter function.
--   
--   <pre>
--   prism :: (a -&gt; (a:+:b)) -&gt; (a -&gt; b -&gt; a) -&gt; <a>Traversal'</a> a b
--   </pre>
prism :: (a -> (b :+: s)) -> (a -> t -> b) -> Traversal s t a b
sat :: (a -> Bool) -> Traversal' a a
simple :: Iso' a b -> Iso' a b
(.+) :: Fold s t a b -> Fold s t a b -> Fold s t a b

-- | Retrieve a value from a structure using a <a>Lens</a> (or <a>Iso</a>)
(^.) :: a -> Getter b b a a -> b
(^..) :: a -> Iso a a b b -> b
(^?) :: (Unit f, Monoid (f b)) => a -> Fold' a b -> f b
(^??) :: a -> ((b -> Const [b] b) -> a -> Const [b] a) -> [b]
(%~) :: Traversal s t a b -> (s -> t) -> (a -> b)
(%-) :: Traversal s t a b -> t -> (a -> b)
(%%~) :: Iso s t a b -> (b -> a) -> (t -> s)
(%%-) :: Iso s t a b -> a -> (t -> s)
at :: Getter b u a v -> a -> b
at' :: Iso s t a b -> t -> b
warp :: Traversal s t a b -> (s -> t) -> (a -> b)
set :: Traversal s t a b -> t -> (a -> b)
(-.) :: Getter c u b v -> (a -> b) -> a -> c
(.-) :: (b -> c) -> Iso a a b b -> a -> c
_1 :: Lens a b (a :*: c) (b :*: c)
_2 :: Lens a b (c :*: a) (c :*: b)
_l :: Traversal a b (a :+: c) (b :+: c)
_r :: Traversal a b (c :+: a) (c :+: b)
_Just :: Traversal a b (Maybe a) (Maybe b)
class Compound a b s t | s -> a, b s -> t
_each :: Compound a b s t => Traversal a b s t
_list :: [a] :<->: (() :+: (a :*: [a]))
_head :: Traversal' [a] a
_tail :: Traversal' [a] [a]
class Isomorphic b a t s | t -> b, t a -> s
_iso :: Isomorphic b a t s => Iso s t a b
adding :: (Num n, Semigroup n) => n -> Iso' n n
_Id :: Iso (Id a) (Id b) a b
_OrdList :: Iso (OrdList a) (OrdList b) [a] [b]
_Const :: Iso (Const a c) (Const b c) a b
_Dual :: Iso (Dual a) (Dual b) a b
_Endo :: Iso (Endo k a) (Endo k b) (k a a) (k b b)
_Flip :: Iso (Flip f b a) (Flip f d c) (f a b) (f c d)
_maybe :: Iso' Bool (Maybe Void)
_Max :: Iso (Max a) (Max b) a b
_Compose :: Iso ((f :.: g) a) ((f' :.: g') b) (f (g a)) (f' (g' b))
_Backwards :: Iso (Backwards f a) (Backwards f b) (f a) (f b)
warp2 :: Iso s t a b -> (s -> s -> t) -> (a -> a -> b)
_mapping :: (Functor f, Functor f') => Iso s t a b -> Iso (f s) (f' t) (f a) (f' b)
_mapping' :: Functor f => Iso s t a b -> Iso (f s) (f t) (f a) (f b)

-- | _promapping :: Bifunctor f =&gt; Iso' a b -&gt; Iso' (f a c) (f b c)
_promapping :: Bifunctor f => Iso s t a b -> Iso (f t x) (f s y) (f b x) (f a y)
class IsoFunctor f
mapIso :: IsoFunctor f => Iso s t a b -> Iso (f s) (f t) (f a) (f b)

-- | An infix synonym for <a>mapIso2</a>
(<.>) :: IsoFunctor2 f => (a :<->: c) -> (b :<->: d) -> (f a b :<->: f c d)
class IsoFunctor2 f
mapIso2 :: IsoFunctor2 f => (a :<->: c) -> (b :<->: d) -> (f a b :<->: f c d)
_thunk :: Iso a b (IO a) (IO b)
instance IsoFunctor2 Either
instance IsoFunctor2 (,)
instance IsoFunctor2 (->)
instance IsoFunctor ((->) a)
instance Isomorphic a b (Void, a) (Void, b)
instance Isomorphic (f (g a)) (f' (g' b)) ((:.:) f g a) ((:.:) f' g' b)
instance Isomorphic Bool Bool (Maybe Void) (Maybe Void)
instance Isomorphic (f a b) (f c d) (Flip f b a) (Flip f d c)
instance Isomorphic (k a a) (k b b) (Endo k a) (Endo k b)
instance Isomorphic a b (Max a) (Max b)
instance Isomorphic a b (Dual a) (Dual b)
instance Isomorphic a b (Const a c) (Const b c)
instance Isomorphic [a] [b] (OrdList a) (OrdList b)
instance Isomorphic a b (Id a) (Id b)
instance Compound a b (a :+: a) (b :+: b)
instance Compound a b (a, a, a) (b, b, b)
instance Compound a b (a, a) (b, b)
instance Bifunctor (IsoT a b)
instance Cofunctor (Flip (IsoT a b) t)
instance Functor (IsoT a b s)

module SimpleH.Traversable
class Foldable t => Traversable t
sequence :: (Traversable t, Applicative f) => t (f a) -> f (t a)
class Functor t => Contravariant t
collect :: (Contravariant t, Functor f) => f (t a) -> t (f a)
traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
foreach :: (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
transpose :: (Applicative f, Traversable t) => t (f a) -> f (t a)
flip :: (Contravariant c, Functor f) => f (c a) -> c (f a)
instance Traversable ZipTree
instance Traversable ZipList
instance Traversable OrdList
instance Traversable Interleave
instance Compound a b [a] [b]
instance Contravariant ((->) a)
instance Contravariant Id
instance (Traversable f, Traversable g) => Traversable (f :++: g)
instance (Traversable f, Traversable g) => Traversable (f :**: g)
instance (Traversable f, Traversable g) => Traversable (f :.: g)
instance Traversable Tree
instance Traversable []
instance Traversable (Either a)
instance Traversable ((,) c)

module SimpleH.Monad
class Applicative m => Monad m where join m = m >>= id ma >>= k = join (map k ma)
join :: Monad m => m (m a) -> m a
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | The class of all monads that have a fixpoint
class Monad m => MonadFix m
mfix :: MonadFix m => (a -> m a) -> m a
class MonadTrans t
lift :: (MonadTrans t, Monad m) => m a -> t m a
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
runKleisli :: Kleisli m a b -> a -> m b
_Kleisli :: Iso (Kleisli m a b) (Kleisli m' c d) (a -> m b) (c -> m' d)
(=<<) :: Monad m => (a -> m b) -> m a -> m b
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
(>>) :: Applicative f => f a -> f b -> f b
(<*=) :: Monad m => m a -> (a -> m b) -> m a
return :: Unit f => a -> f a
foldlM :: (Foldable t, Monad m) => (b -> a -> m a) -> a -> t b -> m a
foldrM :: (Foldable t, Monad m) => (b -> a -> m a) -> a -> t b -> m a
while :: Monad m => m (Maybe a) -> m ()
until :: Monad m => m (Maybe a) -> m a
bind2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c
bind3 :: Monad m => (a -> b -> c -> m d) -> m a -> m b -> m c -> m d
(>>>=) :: Monad m => (m a, m b) -> (a -> b -> m c) -> m c
(>>>>=) :: Monad m => (m a, m b, m c) -> (a -> b -> c -> m d) -> m d
newtype RWST r w s m a
RWST :: ((r, s) -> m (a, s, w)) -> RWST r w s m a
runRWST :: RWST r w s m a -> (r, s) -> m (a, s, w)
type RWS r w s a = RWST r w s Id a

-- | A simple State Monad
class Monad m => MonadState s m | m -> s where put = modify . const modify f = get >>= put . f
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()
modify :: MonadState s m => (s -> s) -> m ()
type IOLens a = Lens' (IO ()) (IO a)
_ioref :: IORef a -> IOLens a
_mvar :: MVar a -> IOLens a
data StateT s m a
type State s a = StateT s Id a
stateT :: (Functor m, Functor n) => Iso (StateT s m a) (StateT t n b) (s -> m (s, a)) (t -> n (t, b))
eval :: (Functor f, Functor f') => f (f' (a, b)) -> f (f' b)
exec :: (Functor f, Functor f') => f (f' (a, b)) -> f (f' a)
state :: Iso (State s a) (State t b) (s -> (s, a)) (t -> (t, b))
(=~) :: MonadState s m => Lens' s s' -> (s' -> s') -> m ()
(=-) :: MonadState s m => Lens' s s' -> s' -> m ()
gets :: MonadState s m => Lens' s s' -> m s'
saving :: MonadState s m => Lens' s s' -> m a -> m a
mapAccum :: Traversable t => (a -> s -> (s, b)) -> t a -> s -> (s, t b)
mapAccum_ :: Traversable t => (a -> s -> (s, b)) -> t a -> s -> t b
mapAccumR :: Traversable t => (a -> s -> (s, b)) -> t a -> s -> (s, t b)
mapAccumR_ :: Traversable t => (a -> s -> (s, b)) -> t a -> s -> t b
push :: Traversable t => t a -> a -> t a
pop :: Traversable t => t a -> a -> t a
withPrev :: Traversable t => a -> t a -> t (a, a)
withNext :: Traversable t => t a -> a -> t (a, a)
newtype StateA m s a
StateA :: (StateT s m a) -> StateA m s a
stateA :: Iso (StateA m s a) (StateA m' s' a') (StateT s m a) (StateT s' m' a')
class Monad m => MonadReader r m | m -> r
ask :: MonadReader r m => m r
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | A simple Reader monad
data ReaderT r m a
type Reader r a = ReaderT r Id a
_readerT :: (Functor m, Functor m') => Iso (ReaderT r m a) (ReaderT r' m' b) (r -> m a) (r' -> m' b)
_reader :: Iso (Reader r a) (Reader r' b) (r -> a) (r' -> b)
class (Monad m, Monoid w) => MonadWriter w m | m -> w
tell :: MonadWriter w m => w -> m ()
listen :: MonadWriter w m => m a -> m (w, a)
censor :: MonadWriter w m => m (a, w -> w) -> m a

-- | A simple Writer monad
data WriterT w m a
type Writer w a = WriterT w Id a
_writerT :: (Functor m, Functor m') => Iso (WriterT w m a) (WriterT w' m' b) (m (w, a)) (m' (w', b))
_writer :: Iso (Writer w a) (Writer w' b) (w, a) (w', b)
mute :: (MonadWriter w m, Monoid w) => m a -> m a
intercept :: (MonadWriter w m, Monoid w) => m a -> m (w, a)

-- | A simple continuation monad implementation
class Monad m => MonadCont m
callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
newtype ContT r m a
ContT :: ((a -> m r) -> m r) -> ContT r m a
runContT :: ContT r m a -> (a -> m r) -> m r
type Cont r a = ContT r Id a
evalContT :: Unit m => ContT r m r -> m r
evalCont :: Cont r r -> r
class Monad m => MonadList m
fork :: MonadList m => [a] -> m a
data ListT m a
_listT :: Iso (ListT m a) (ListT m' a') (m [a]) (m' [a'])
class Monad m => MonadError e m | m -> e
throw :: MonadError e m => e -> m a
catch :: MonadError e m => (e -> m a) -> m a -> m a
try :: MonadError Void m => m a -> m a -> m a
tryMay :: MonadError SomeException m => m a -> m (Maybe a)
data EitherT e m a
_eitherT :: Functor m => Iso (EitherT e m a) (EitherT f m b) (m (e :+: a)) (m (f :+: b))
instance Ring (m (a, Void, w)) => Ring (WriterT w m a)
instance Monoid (m (a, Void, w)) => Monoid (WriterT w m a)
instance Semigroup (m (a, Void, w)) => Semigroup (WriterT w m a)
instance Ring (m (a, Void, Void)) => Ring (ReaderT r m a)
instance Monoid (m (a, Void, Void)) => Monoid (ReaderT r m a)
instance Semigroup (m (a, Void, Void)) => Semigroup (ReaderT r m a)
instance Ring (m (a, s, Void)) => Ring (StateT s m a)
instance Monoid (m (a, s, Void)) => Monoid (StateT s m a)
instance Semigroup (m (a, s, Void)) => Semigroup (StateT s m a)
instance MonadError e m => MonadError e (StateT s m)
instance Ring (m (a, s, w)) => Ring (RWST r w s m a)
instance Monoid (m (a, s, w)) => Monoid (RWST r w s m a)
instance Semigroup (m (a, s, w)) => Semigroup (RWST r w s m a)
instance (Unit m, Monoid w) => Unit (WriterT w m)
instance Functor m => Functor (WriterT w m)
instance (Monoid w, Monad m) => Applicative (WriterT w m)
instance (Monoid w, Monad m) => Monad (WriterT w m)
instance (Monoid w, MonadFix m) => MonadFix (WriterT w m)
instance Foldable m => Foldable (WriterT w m)
instance Traversable m => Traversable (WriterT w m)
instance Monoid w => MonadTrans (WriterT w)
instance Monoid w => MonadInternal (WriterT w)
instance (Monoid w, Monad m) => MonadWriter w (WriterT w m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT w m)
instance Functor m => Functor (ReaderT r m)
instance Unit m => Unit (ReaderT r m)
instance Monad m => Applicative (ReaderT r m)
instance Monad m => Monad (ReaderT r m)
instance MonadFix m => MonadFix (ReaderT r m)
instance MonadTrans (ReaderT r)
instance MonadInternal (ReaderT r)
instance Monad m => MonadReader r (ReaderT r m)
instance MonadCont m => MonadCont (ReaderT r m)
instance Unit m => Unit (StateT s m)
instance Functor m => Functor (StateT s m)
instance Monad m => Applicative (StateT s m)
instance Monad m => Monad (StateT s m)
instance MonadFix m => MonadFix (StateT s m)
instance MonadTrans (StateT s)
instance MonadInternal (StateT s)
instance MonadCont m => MonadCont (StateT s m)
instance Monad m => MonadState s (StateT s m)
instance Semigroup (m r) => Semigroup (ContT r m a)
instance Monoid (m r) => Monoid (ContT r m a)
instance Ring (m r) => Ring (ContT r m a)
instance Applicative m => Semigroup (ListT m a)
instance Applicative m => Monoid (ListT m a)
instance Functor m => Functor (ListT m)
instance Applicative m => Applicative (ListT m)
instance Unit m => Unit (ListT m)
instance Monad m => Monad (ListT m)
instance Foldable m => Foldable (ListT m)
instance Traversable m => Traversable (ListT m)
instance Unit m => Unit (EitherT e m)
instance Functor m => Functor (EitherT e m)
instance Applicative m => Applicative (EitherT e m)
instance Monad m => Monad (EitherT e m)
instance MonadFix m => MonadFix (EitherT e m)
instance Foldable m => Foldable (EitherT e m)
instance Traversable m => Traversable (EitherT e m)
instance Exception e => MonadError e IO
instance MonadError Void Maybe
instance Monad Maybe
instance Applicative Maybe
instance MonadTrans (EitherT e)
instance MonadError Void []
instance MonadError e (Either e)
instance Monad m => MonadError Void (ListT m)
instance MonadWriter w m => MonadWriter w (ListT m)
instance MonadState s m => MonadState s (ListT m)
instance MonadTrans ListT
instance MonadFix m => MonadFix (ListT m)
instance Monad m => MonadList (ListT m)
instance MonadList []
instance MonadFix m => Monad (Backwards m)
instance MonadTrans Backwards
instance Monad m => MonadCont (ContT r m)
instance MonadTrans (ContT r)
instance Monad m => Monad (ContT r m)
instance Applicative m => Applicative (ContT r m)
instance Functor f => Functor (ContT r f)
instance Unit m => Unit (ContT r m)
instance (Monoid w, MonadState r m) => MonadState r (WriterT w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance Monoid w => MonadWriter w ((,) w)
instance MonadWriter w m => MonadWriter w (ReaderT r m)
instance MonadState s m => MonadState s (ReaderT r m)
instance MonadReader r ((->) r)
instance Monad m => Choice (StateA m)
instance Monad m => Split (StateA m)
instance Monad m => Category (StateA m)
instance MonadWriter w m => MonadWriter w (StateT s m)
instance MonadReader r m => MonadReader r (StateT s m)
instance MonadState (IO ()) IO
instance Monoid w => MonadInternal (RWST r w s)
instance Monoid w => MonadTrans (RWST r w s)
instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m)
instance Traversable m => Traversable (RWST Void w Void m)
instance Foldable m => Foldable (RWST Void w Void m)
instance (Monad m, Monoid w) => MonadWriter w (RWST r w s m)
instance (Monad m, Monoid w) => MonadReader r (RWST r w s m)
instance (Monad m, Monoid w) => MonadState s (RWST r w s m)
instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m)
instance (Monoid w, MonadFix m) => MonadFix (RWST r w s m)
instance (Monoid w, Monad m) => Monad (RWST r w s m)
instance (Monoid w, Monad m) => Applicative (RWST r w s m)
instance Functor f => Functor (RWST r w s f)
instance (Unit f, Monoid w) => Unit (RWST r w s f)
instance Isomorphic (a -> m b) (c -> m' d) (Kleisli m a b) (Kleisli m' c d)
instance Monad m => Split (Kleisli m)
instance Monad m => Choice (Kleisli m)
instance Monad m => Category (Kleisli m)
instance (MonadFix f, Traversable g, Monad g) => MonadFix (f :.: g)
instance MonadFix m => MonadFix (Backwards m)
instance MonadFix IO
instance MonadFix (Either e)
instance MonadFix []
instance MonadFix ((->) b)
instance MonadFix Id
instance (Traversable g, Monad f, Monad g) => Monad (f :.: g)

module SimpleH.Arrow
class (Split k, Choice k) => Arrow k
arr :: Arrow k => (a -> b) -> k a b
(>>^) :: Functor f => f a -> (a -> b) -> f b
(^>>) :: Cofunctor (Flip f c) => (a -> b) -> f b c -> f a c
class Arrow k => Apply k
apply :: Apply k => k (k a b, a) b
comapA :: Arrow arr => (a -> b) -> Flip arr c b -> Flip arr c a
app :: Apply k => k a b -> k a b
dup :: Arrow arr => arr a (a, a)
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
runKleisli :: Kleisli m a b -> a -> m b
newtype ListA k a b
ListA :: k [a] [b] -> ListA k a b
runListA :: ListA k a b -> k [a] [b]
instance Arrow k => Arrow (ListA k)
instance Arrow k => Split (ListA k)
instance Arrow k => Choice (ListA k)
instance Category k => Category (ListA k)
instance Monad m => Arrow (Kleisli m)
instance Monad m => Apply (Kleisli m)
instance Monad m => Arrow (StateA m)
instance Apply (->)
instance Arrow (->)

module SimpleH.Containers
class DataMap m k a | m -> k a
lookup :: DataMap m k a => k -> m -> Maybe a
alter :: DataMap m k a => (Maybe a -> Maybe a) -> k -> m -> m
newtype AList k a
AList :: [(k, a)] -> AList k a
getAList :: AList k a -> [(k, a)]

-- | A set of values <tt>a</tt>.
data Set a :: * -> *

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a :: * -> * -> *
member :: DataMap m k Void => k -> m -> Bool
delete :: DataMap m k a => k -> m -> m
minsert :: (Monoid a, DataMap m k a) => k -> m -> m
insert :: DataMap m k a => a -> k -> m -> m
instance (Ord a, Ord b) => Semigroup (Bimap a b)
instance (Ord a, Ord b) => Monoid (Bimap a b)
instance (Ord b, Ord a) => DataMap (Flip Bimap b a) b a
instance (Ord a, Ord b) => DataMap (Bimap a b) a b
instance Functor (Map k)
instance Ord k => Monoid (Map k a)
instance Ord k => Semigroup (Map k a)
instance Ord a => Monoid (Set a)
instance Ord a => Semigroup (Set a)
instance Ord k => DataMap (Map k a) k a
instance Ord a => DataMap (Set a) a Void

module SimpleH


-- | A module providing simple Parser combinator functionality. Useful for
--   small parsing tasks such as identifier parsing or command-line
--   argument parsing
module SimpleH.Parser
newtype ParserT w s m a
ParserT :: (StateT s (ListT (WriterT w m)) a) -> ParserT w s m a
type Parser w c a = ParserT w c Id a
newtype ParserA w m s a
ParserA :: (ParserT w s m a) -> ParserA w m s a
_ParserA :: Iso (ParserA w m s a) (ParserA w' m' s' a') (ParserT w s m a) (ParserT w' s' m' a')
class Stream c s | s -> c
uncons :: Stream c s => s -> Maybe (c, s)
cons :: Stream c s => c -> s -> s

-- | Test if a Stream is empty
empty :: Stream c s => s -> Bool
parserT :: (Functor n, Functor m) => Iso (ParserT w s m a) (ParserT x t n b) (s -> m (w, [(s, a)])) (t -> n (x, [(t, b)]))
parser :: Iso (Parser w s a) (Parser x t b) (s -> (w, [(s, a)])) (t -> (x, [(t, b)]))
runParser :: Parser Void s a -> s -> [(s, a)]
pureParser :: (Monoid w, Monad m) => (a -> [b]) -> ParserT w a m b

-- | The <tt>(+)</tt> operator with lower priority
(<+>) :: Semigroup m => m -> m -> m
(>*>) :: (Monoid w, Monad m) => ParserT w a m b -> ParserT w b m c -> ParserT w a m c

-- | Consume a token from the Stream
token :: (Monad m, Monoid w, Stream c s) => ParserT w s m c

-- | Consume a token and succeed if it verifies a predicate
satisfy :: (Monoid w, Monad m, Stream c s) => (c -> Bool) -> ParserT w s m c

-- | The remaining Stream to parse
remaining :: (Monad m, Monoid w) => ParserT w s m s

-- | Parse a member of a set of values
oneOf :: (Eq c, Monoid w, Monad m, Foldable t, Stream c s) => t c -> ParserT w s m c

-- | Parse anything but a member of a set
noneOf :: (Eq c, Monoid w, Monad m, Foldable t, Stream c s) => t c -> ParserT w s m c

-- | Consume a single fixed token or fail.
single :: (Eq c, Monoid w, Monad m, Stream c s) => c -> ParserT w s m ()

-- | Consume a structure of characters or fail
several :: (Eq c, Monoid w, Monad m, Foldable t, Stream c s) => t c -> ParserT w s m ()

-- | Succeed only if we are at the End Of Input.
eoi :: (Monad m, Monoid w, Stream c s) => ParserT w s m ()

-- | Parse zero, one or more successive occurences of a parser.
many :: (Monoid w, Monad m) => ParserT w c m a -> ParserT w c m [a]

-- | Parse one or more successiveÃ© occurences of a parser.
many1 :: (Monoid w, Monad m) => ParserT w c m a -> ParserT w c m [a]

-- | Parse zero or more successive occurences of a parser separated by
--   occurences of a second parser.
sepBy :: (Monoid w, Monad m) => ParserT w c m a -> ParserT w c m b -> ParserT w c m [a]

-- | Parse one or more successive occurences of a parser separated by
--   occurences of a second parser.
sepBy1 :: (Monoid w, Monad m) => ParserT w c m a -> ParserT w c m b -> ParserT w c m [a]

-- | Chain an operator with an initial value
chainl :: (Monoid w, Stream c s, Monad m) => ParserT w s m a -> ParserT w s m (a -> b -> a) -> ParserT w s m b -> ParserT w s m a

-- | Chain an operator with an initial value and several tail values.
chainr :: (Monoid w, Stream c s, Monad m) => ParserT w s m a -> ParserT w s m (b -> a -> a) -> ParserT w s m b -> ParserT w s m a
instance (Monad m, Monoid w) => MonadError Void (ParserT w c m)
instance (Unit m, Monoid w) => Unit (ParserT w s m)
instance Functor m => Functor (ParserT w s m)
instance (Monoid w, Monad m) => Applicative (ParserT w s m)
instance (Monoid w, Monad m) => Monoid (ParserT w s m a)
instance (Monoid w, Monad m) => Semigroup (ParserT w s m a)
instance (Monoid w, Monad m) => Monad (ParserT w s m)
instance (Monoid w, MonadFix m) => MonadFix (ParserT w s m)
instance (Monoid w, Monad m) => MonadState s (ParserT w s m)
instance (Monoid w, Monad m) => MonadWriter w (ParserT w s m)
instance Serializable ByteString
instance Stream a [a]
instance (Monoid w, Monad m) => Arrow (ParserA w m)
instance (Monoid w, Monad m) => Choice (ParserA w m)
instance (Monoid w, Monad m) => Split (ParserA w m)
instance (Monoid w, Monad m) => Category (ParserA w m)
instance Monoid w => MonadTrans (ParserT w s)

module SimpleH.Parser.CmdArgs

-- | Each <a>OptDescr</a> describes a single option.
--   
--   The arguments to <a>Option</a> are:
--   
--   <ul>
--   <li>list of short option characters</li>
--   <li>list of long option strings (without "--")</li>
--   <li>argument descriptor</li>
--   <li>explanation of option for user</li>
--   </ul>
data OptDescr a :: * -> *
Option :: [Char] -> [String] -> ArgDescr a -> String -> OptDescr a

-- | Describes whether an option takes an argument or not, and if so how
--   the argument is injected into a value of type <tt>a</tt>.
data ArgDescr a :: * -> *

-- | no argument expected
NoArg :: a -> ArgDescr a

-- | option requires argument
ReqArg :: (String -> a) -> String -> ArgDescr a

-- | optional argument
OptArg :: (Maybe String -> a) -> String -> ArgDescr a

-- | Return a string describing the usage of a command, derived from the
--   header (first argument) and the options described by the second
--   argument.
usageInfo :: String -> [OptDescr a] -> String

-- | Create a Parser that preprocesses the command-line arguments,
--   splitting options and their arguments into a user-defined data type.
tokenize :: Monad m => [OptDescr a] -> (String -> a) -> ParserT String [String] m [a]

module SimpleH.Reactive.TimeVal

-- | A type wrapper that adds a Bounded instance for types that don't
--   possess one.
data TimeVal t
Always :: TimeVal t
Since :: t -> TimeVal t
Never :: TimeVal t
instance Show t => Show (TimeVal t)
instance Eq t => Eq (TimeVal t)
instance Ord t => Ord (TimeVal t)
instance Bounded (TimeVal t)
instance Traversable TimeVal
instance Foldable TimeVal
instance Monad TimeVal
instance Applicative TimeVal
instance Unit TimeVal
instance Functor TimeVal

module SimpleH.Reactive.Time

-- | A type wrappers for timestamps that can be compared unambiguously
data Time t

-- | A Time's pure value. May not be defined immediately.
timeVal :: Time t -> TimeVal t
type Seconds = Double

-- | Constructs a Time representing the time at which the argument
--   terminates.
--   
--   Warning: This function executes its argument, ignoring its value.
--   Thus, it would be wise to use it on repeatable blocking actions, such
--   as <tt>readMVar</tt>.
timeIO :: IO a -> IO (Time Seconds)
waitTill :: Seconds -> IO ()
currentTime :: IO Seconds
instance Typeable Freezed
instance Show Freezed
instance Unit Time
instance Bounded (Time t)
instance Ord t => Orderable (Time t)
instance Ord t => Ring (Time t)
instance Ord t => Monoid (Time t)
instance Ord t => Semigroup (Time t)
instance Ord t => Ord (Time t)
instance Ord t => Eq (Time t)
instance (Eq t, Show t) => Show (Time t)
instance Exception Freezed

module SimpleH.Reactive

-- | An event (a list of time-value pairs of increasing times)
data Event t a
_event :: Iso (Event t a) (Event t' b) [Future t a] [Future t' b]
headE :: Event t a -> a
data Reactive t a
Reactive :: a -> (Event t a) -> Reactive t a
atTimes :: [t] -> Event t ()
mkEvent :: [(t, a)] -> Event t a
withTime :: Ord t => Event t a -> Event t (TimeVal t, a)
times :: Ord t => Event t a -> Event t (TimeVal t)
mapFutures :: (Future t a -> Future t' b) -> Event t a -> Event t' b

-- | The 'splice' operator. Occurs when <tt>a</tt> occurs.
--   
--   <pre>
--   at t: a // b = (a,before t: b)
--   </pre>
(//) :: Ord t => Event t a -> Event t b -> Event t (a, Event t b)
(<|*>) :: Ord t => Reactive t (a -> b) -> Event t a -> Event t b

-- | The 'over' operator. Occurs only when <tt>a</tt> occurs.
--   
--   <pre>
--   at t: a &lt;|*&gt; (bi,b) = a &lt;*&gt; (minBound,bi):b
--   </pre>
(<*|>) :: Ord t => Event t (a -> b) -> Reactive t a -> Event t b

-- | Group the occurences of an event by equality. Occurs when the first
--   occurence of a group occurs.
groupE :: (Eq a, Ord t) => Event t a -> Event t (Event t a)
mask :: Ord t => Event t Bool -> Event t a -> Event t a

-- | Sinks an action event into the Real World. Actions are evaluated as
--   closely to their time as possible
sink :: Event Seconds (IO ()) -> IO ()
event :: IO a -> IO (Event Seconds a)

-- | A Future value (a value with a timestamp)
data Future t a
_future :: Iso (Future t a) (Future t' b) (Time t, a) (Time t', b)
_time :: Lens (Time t) (Time t') (Future t a) (Future t' a)
_value :: Lens a b (Future t a) (Future t b)
futureIO :: IO a -> IO (Future Seconds a)
instance (Eq t, Show t, Show a) => Show (Future t a)
instance Functor (Future t)
instance Ord t => Unit (Future t)
instance Ord t => Applicative (Future t)
instance Traversable (Future t)
instance Foldable (Future t)
instance Ord t => Monad (Future t)
instance (Ord t, Semigroup a) => Semigroup (Future t a)
instance (Ord t, Monoid a) => Monoid (Future t a)
instance Ord t => Unit (Event t)
instance Functor (Event t)
instance Foldable (Event t)
instance Traversable (Event t)
instance Ord t => Orderable (Future t a)
instance Ord t => Ord (Future t a)
instance Ord t => Eq (Future t a)
instance Ord t => Monad (Event t)
instance Ord t => Applicative (Event t)
instance Ord t => Monoid (Event t a)
instance Ord t => Semigroup (Event t a)
instance (Ord t, Show t, Show a) => Show (Event t a)
instance Ord t => Applicative (Reactive t)
instance Functor (Reactive t)
instance Ord t => Unit (Reactive t)

module SimpleH.File
data File
File :: (Maybe String) -> (Maybe ByteString) -> File
Directory :: [(String, File)] -> File
getFile :: FilePath -> IO File
showFile :: File -> String
_file :: Traversal' File (Maybe String, Maybe ByteString)
_directory :: Traversal' File [(String, File)]

-- | If the operating system has a notion of current directories,
--   <a>getCurrentDirectory</a> returns an absolute path to the current
--   directory of the calling process.
--   
--   The operation may fail with:
--   
--   <ul>
--   <li><a>HardwareFault</a> A physical I/O error has occurred.
--   <tt>[EIO]</tt></li>
--   <li><a>isDoesNotExistError</a> / <a>NoSuchThing</a> There is no path
--   referring to the current directory. <tt>[EPERM, ENOENT,
--   ESTALE...]</tt></li>
--   <li><a>isPermissionError</a> / <a>PermissionDenied</a> The process has
--   insufficient privileges to perform the operation.
--   <tt>[EACCES]</tt></li>
--   <li><a>ResourceExhausted</a> Insufficient resources are available to
--   perform the operation.</li>
--   <li><a>UnsupportedOperation</a> The operating system has no notion of
--   current directory.</li>
--   </ul>
--   
--   Note that in a concurrent program, the current directory is global
--   state shared between all threads of the process. When using filesystem
--   operations from multiple threads, it is therefore highly recommended
--   to use absolute rather than relative <a>FilePath</a>s.
getCurrentDirectory :: IO FilePath
instance Show File
