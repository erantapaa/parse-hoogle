-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A collection of tools for processing XML with Haskell (Filter variant).
--   
--   The Haskell XML Toolbox bases on the ideas of HaXml and HXML. This
--   package is a compatibitlity package for old software working with the
--   filter approach like in HaXml. For new projects it's recomended to use
--   the arrow based library (hxt).
@package hxt-filter
@version 8.4.2


-- | A module for regular expression matching based on derivatives of
--   regular expressions.
--   
--   The code was taken from Joe English
--   (<a>http://www.flightlab.com/~joe/sgml/validate.html</a>). Tested and
--   extended by Martin Schmidt.
--   
--   Further references for the algorithm:
--   
--   Janusz A. Brzozowski.
--   
--   Derivatives of Regular Expressions. Journal of the ACM, Volume 11,
--   Issue 4, 1964.
--   
--   Mark Hopkins.
--   
--   Regular Expression Package. Posted to comp.compilers, 1994. Available
--   per FTP at <a>ftp://iecc.com/pub/file/regex.tar.gz</a>.
module Text.XML.HXT.Validator.RE

-- | Data type for regular expressions.
data RE a
RE_ZERO :: String -> RE a
RE_UNIT :: RE a
RE_SYM :: a -> RE a
RE_DOT :: RE a
RE_REP :: (RE a) -> RE a
RE_PLUS :: (RE a) -> RE a
RE_OPT :: (RE a) -> RE a
RE_SEQ :: (RE a) -> (RE a) -> RE a
RE_ALT :: (RE a) -> (RE a) -> RE a

-- | Constructs a regular expression for an empty sequence.
--   
--   <ul>
--   <li>returns : regular expression for an empty sequence</li>
--   </ul>
re_unit :: RE a

-- | Constructs a regular expression for an empty set.
--   
--   <ul>
--   <li>1.parameter errMsg : error message</li>
--   <li>returns : regular expression for an empty set</li>
--   </ul>
re_zero :: String -> RE a

-- | Constructs a regular expression for accepting a symbol
--   
--   <ul>
--   <li>1.parameter sym : the symbol to be accepted</li>
--   <li>returns : regular expression for accepting a symbol</li>
--   </ul>
re_sym :: a -> RE a

-- | Constructs an optional repetition (*) of a regular expression
--   
--   <ul>
--   <li>1.parameter re_a : regular expression to be repeted</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_rep :: RE a -> RE a

-- | Constructs a repetition (+) of a regular expression
--   
--   <ul>
--   <li>1.parameter re_a : regular expression to be repeted</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_plus :: RE a -> RE a

-- | Constructs an option (?) of a regular expression
--   
--   <ul>
--   <li>1.parameter re_a : regular expression to be optional</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_opt :: RE a -> RE a

-- | Constructs a sequence (,) of two regular expressions
--   
--   <ul>
--   <li>1.parameter re_a : first regular expression in sequence</li>
--   <li>2.parameter re_b : second regular expression in sequence</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_seq :: RE a -> RE a -> RE a

-- | Constructs an alternative (|) of two regular expressions
--   
--   <ul>
--   <li>1.parameter re_a : first regular expression of alternative</li>
--   <li>2.parameter re_b : second regular expression of alternative</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_alt :: RE a -> RE a -> RE a

-- | Constructs a regular expression for accepting any singel symbol
--   
--   <ul>
--   <li>returns : regular expression for accepting any singel symbol</li>
--   </ul>
re_dot :: RE a

-- | Checks if an input matched a regular expression. The function should
--   be called after matches.
--   
--   Was the sentence used in <tt>matches</tt> in the language of the
--   regular expression? -&gt; matches e s == s `in` L(e)?
--   
--   <ul>
--   <li>1.parameter re : the derived regular expression</li>
--   <li>returns : empty String if input matched the regular expression,
--   otherwise an error message is returned</li>
--   </ul>
checkRE :: Show a => RE a -> String

-- | Derives a regular expression with respect to a sentence.
--   
--   <ul>
--   <li>1.parameter re : regular expression</li>
--   <li>2.parameter s : sentence to which the regular expression is
--   applied</li>
--   <li>returns : the derived regular expression</li>
--   </ul>
matches :: (Eq a, Show a) => RE a -> [a] -> RE a

-- | Checks if a regular expression matches the empty sequence.
--   
--   nullable e == [] `in` L(e)
--   
--   This check indicates if a regular expression fits to a sentence or
--   not.
--   
--   <ul>
--   <li>1.parameter re : regular expression to be checked</li>
--   <li>returns : true if regular expression matches the empty sequence,
--   otherwise false</li>
--   </ul>
nullable :: Show a => RE a -> Bool

-- | Constructs a string representation of a regular expression.
--   
--   <ul>
--   <li>1.parameter re : a regular expression</li>
--   <li>returns : the string representation of the regular expression</li>
--   </ul>
printRE :: Show a => RE a -> String
instance Show a => Show (RE a)
instance Eq a => Eq (RE a)


-- | Version : $Id: PipeOpen.hs,v 1.2 2005<i>09</i>02 17:09:39 hxml Exp $
--   
--   pipe open implemented with System.Process functions
module System.PipeOpen

-- | call an external program with a list of command line arguments and
--   return content of stdout, content of stderr and return code
popen :: String -> [String] -> IO (String, String, Int)


-- | Filter for n-ary tree structure with filter combinators copied and
--   modified from HaXml (<a>http://www.cs.york.ac.uk/fp/HaXml/</a>)
--   
--   Similar but more flexible functions for tree processing are defined in
--   the arrow classes <a>Control.Arrow.ArrowList</a>,
--   <a>Control.Arrow.ArrowIf</a>, <a>Control.Arrow.ArrowTree</a> and
--   <a>Control.Arrow.ArrowState</a>. For new applications, especially for
--   XML processing, it's recommended to use the arrow interface
--   <a>Text.XML.HXT.Arrow</a> instead of this filter approach as part of
--   the api <a>Text.XML.HXT.Parser</a>
module Data.Tree.NTree.Filter

-- | tree filter type: a function mapping a tree onto a list of trees
--   
--   filter can be used in various ways, as predicates, selectors,
--   transformers, ...
type TFilter node = NTree node -> NTrees node

-- | a filter for sequences
type TSFilter node = NTrees node -> NTrees node

-- | satisfies converts a result of a predicate filter into a boolean
--   
--   is a shortcut for not . null
--   
--   typical use in guards or ifs: <tt>if (satisfies f) t then ... else ...
--   </tt>
--   
--   <ul>
--   <li>1.parameter f : the predicate filter</li>
--   <li>2.parameter t : the tree to be tested</li>
--   <li>returns : <tt>b = not (null (f t))</tt></li>
--   </ul>
satisfies :: (a -> [b]) -> a -> Bool

-- | the null filter, returns the empty list
none :: a -> [b]

-- | the unit filter, returns the single element list containing the
--   argument
this :: a -> [a]

-- | conversion from predicate function to filter
--   
--   <ul>
--   <li>1.parameter p : the predicate for testing the tree</li>
--   <li>returns : <a>this</a> or <a>none</a> depending on the
--   predicate</li>
--   </ul>
isOf :: (a -> Bool) -> (a -> [a])

-- | select filter, selects trees with node values with a specific property
--   
--   <ul>
--   <li>1.parameter p : the predicate for testing the node value</li>
--   <li>returns : <tt>[]</tt> or <tt>[t]</tt> depending on <tt>p
--   t</tt></li>
--   </ul>
--   
--   a special case of <a>isOf</a> filter
isOfNode :: (node -> Bool) -> TFilter node

-- | filter for substituting an arbitray tree by a constant
--   
--   <ul>
--   <li>1.parameter t : the result tree, the input tree is ignored</li>
--   <li>returns : the filter</li>
--   </ul>
mkNTree :: NTree node -> TFilter node

-- | filter for replacing the node
--   
--   <ul>
--   <li>1.parameter n : the new node</li>
--   <li>returns : the editing filter</li>
--   </ul>
replaceNode :: node -> TFilter node

-- | filter for replacing the children
--   
--   <ul>
--   <li>1.parameter cs : cs the list of children</li>
--   <li>returns : the filter</li>
--   </ul>
replaceChildren :: NTrees node -> TFilter node
modifyNode :: (node -> Maybe node) -> TFilter node

-- | filter for editing the node
--   
--   <ul>
--   <li>1.parameter nf : the XNode editing funtion</li>
--   <li>returns : the filter</li>
--   </ul>
modifyNode0 :: (node -> node) -> TFilter node

-- | filter for editing the children
--   
--   all children are processed with a filter mapping lists to lists, this
--   enables not only elementwise editing by lifting a normal filter to a
--   list filter with <tt>(f $$)</tt> (see '($$)') but also manipulation of
--   the order of the elements, e.g. <a>reverse</a> is an appropriate
--   childen editing function.
--   
--   <ul>
--   <li>1.parameter csf : the children editing function</li>
--   <li>returns : the filter</li>
--   </ul>
--   
--   see also : <a>processChildren</a>
modifyChildren :: TSFilter node -> TFilter node

-- | filter for substituting the children of a tree by a new list of
--   childen computed by applying a filter to the input tree.
--   <a>modifyChildren</a> can be expressed by <a>substChildren</a>:
--   <tt>modifyChildren f t</tt> is equal to <tt>substChildren (f .
--   getChildren)</tt>
substChildren :: TFilter node -> TFilter node

-- | Filter for editing the children of a tree element wise
--   
--   <ul>
--   <li>1.parameter cf : the filter applied to the children</li>
--   <li>returns : the editing filter</li>
--   </ul>
--   
--   see also : <a>modifyChildren</a>
processChildren :: TFilter node -> TFilter node

-- | sequential composition of filters, usually written in infix notation
--   f2 <a>o</a> f1.
--   
--   for predicate filter the logical AND
--   
--   <ul>
--   <li>1.parameter f2 : the 2. filter</li>
--   <li>2.parameter f1 : the 1. filter</li>
--   <li>returns : the fiter applying first f1 to n and then f2 to the
--   result (like function composition)</li>
--   </ul>
o :: (a -> [b]) -> (c -> [a]) -> (c -> [b])

-- | pronounced "followed by", defined as: <tt>f .&gt; g = g `o` f</tt>.
--   
--   allows filter composition in a more readable way from left to right
--   
--   <ul>
--   <li>1.parameter f1 : the 1. filter</li>
--   <li>2.parameter f2 : the 2. filter</li>
--   <li>returns : the composition of f1 and f2</li>
--   </ul>
--   
--   see also : <a>o</a>, '(..&gt;)'
(.>) :: (a -> [b]) -> (b -> [c]) -> (a -> [c])

-- | apply a list of filters sequentially with '(.&gt;)', for predicate
--   filters the generalized AND
--   
--   see also : '(.&gt;)'
seqF :: [a -> [a]] -> (a -> [a])

-- | special sequential composition.
--   
--   filter f is applied to an argument t. then filter g is applied to all
--   elements of the result list, but the argument t is also passed as
--   extra parameter to g.
--   
--   This allows for step by step transformations of a tree with access to
--   the original tree in every transformation step.
--   
--   see also : '(.&gt;)', <a>o</a>
(..>) :: (a -> [b]) -> (a -> b -> [d]) -> (a -> [d])

-- | binary parallel composition, the logical OR for predicate filter
--   
--   <ul>
--   <li>1.parameter f1 : the 1. filter</li>
--   <li>2.parameter f2 : the 2. filter</li>
--   <li>returns : the filter for applying f1 and f2 both to an argument
--   tree and concatenating the results</li>
--   </ul>
(+++) :: (a -> [b]) -> (a -> [b]) -> (a -> [b])

-- | apply a list of filters, a "union" for lists, for predicate filters
--   the generalized OR
--   
--   <ul>
--   <li>1.parameter fs : the list of filters</li>
--   <li>returns : the composing filter</li>
--   </ul>
cat :: [a -> [b]] -> (a -> [b])

-- | directional choice, usually written in infix notation as f
--   <a>orElse</a> g
--   
--   <ul>
--   <li>1.parameter f : the 1. filter</li>
--   <li>2.parameter g : the 2. filter</li>
--   <li>3.parameter t : the tree</li>
--   <li>returns : the filter, that applies f to t, if the result is not
--   the empty list, the result is found, else g t is the result</li>
--   </ul>
orElse :: (a -> [b]) -> (a -> [b]) -> (a -> [b])

-- | if then else lifted to filters
--   
--   <ul>
--   <li>1.parameter p : the predicate filter</li>
--   <li>2.parameter t : the "then" filter</li>
--   <li>3.parameter e : the "else" filter</li>
--   <li>returns : the resulting conditional filter</li>
--   </ul>
iff :: (a -> [c]) -> (a -> [b]) -> (a -> [b]) -> (a -> [b])

-- | multiway branch. The list of cases <tt>f :-&gt; g</tt> is processed
--   sequentially, in the first case for that f holds g is applied, if no
--   case matches, <a>none</a> is applied. This filter can be used like a
--   case expression: <tt>choice [ p1 :-&gt; f1, p2 :-&gt; f2, ... , this
--   :-&gt; defaultFilter]</tt>
--   
--   see also : <a>iff</a>, <a>choiceM</a>
choice :: [IfThen (a -> [c]) (a -> [b])] -> (a -> [b])

-- | auxiliary datatype for cases within choice filter
data IfThen a b
(:->) :: a -> b -> IfThen a b

-- | when the predicate p holds, f is applied, else the identity filter
--   this
--   
--   <ul>
--   <li>1.parameter f : the conditinally applied filter</li>
--   <li>2.parameter p : the predicate</li>
--   <li>returns : the conditional filter</li>
--   </ul>
--   
--   see also : <a>iff</a>, <a>whenNot</a>, <a>guards</a>, <a>whenM</a>
when :: (a -> [a]) -> (a -> [a]) -> (a -> [a])

-- | the complementary filter of when
--   
--   shortcut for f <a>when</a> neg g
--   
--   see also : <a>iff</a>, <a>when</a>, <a>whenNotM</a>, <a>neg</a>
whenNot :: (a -> [a]) -> (a -> [a]) -> (a -> [a])

-- | when the predicate p holds, f is applied, else the null filter none
--   
--   <ul>
--   <li>1.parameter p : the predicate filter</li>
--   <li>2.parameter f : the conditionally applied filter</li>
--   <li>returns : the conditional filter</li>
--   </ul>
--   
--   see also : <a>iff</a>, <a>when</a>, <a>guardsM</a>
guards :: (a -> [b]) -> (a -> [b]) -> (a -> [b])

-- | negation lifted to filters
--   
--   <ul>
--   <li>1.parameter f : the predicate filter</li>
--   <li>returns : the filter, that succeeds, when f failed</li>
--   </ul>
neg :: (a -> [c]) -> a -> [a]

-- | pruning: keep only those results from f for which g holds, usually
--   written in infix notation as f <a>containing</a> g
--   
--   <ul>
--   <li>1.parameter f : the processing filter</li>
--   <li>2.parameter g : the predicate filter</li>
--   <li>3.parameter t : the tree</li>
--   <li>returns : all trees r from f t, for which g r holds (is not the
--   empty list)</li>
--   </ul>
--   
--   see also : <a>notContaining</a>
containing :: (a -> [b]) -> (b -> [c]) -> a -> [b]

-- | pruning: keep only those results from f for which g does not hold
--   
--   see also : <a>containing</a>
notContaining :: (a -> [b]) -> (b -> [c]) -> a -> [b]

-- | pronounced "slash", meaning g inside f
(/>) :: TFilter node -> TFilter node -> TFilter node

-- | pronounced "outside" meaning f containing g
(</) :: TFilter node -> TFilter node -> TFilter node

-- | top down search.
--   
--   search terminates, when filter f succeeds can e.g. be used for finding
--   all outermost tag node of a specific kind
deep :: TFilter node -> TFilter node

-- | bottom up search.
--   
--   first the children are processed, if this does not succeed, the node
--   itself is processed can e.g. be used for finding all innermost tag
--   nodes of a specific kind
deepest :: TFilter node -> TFilter node

-- | process all nodes of the whole tree.
--   
--   can e.g. be used for finding all nodes of a specific kind
multi :: TFilter node -> TFilter node

-- | bottom up transformation
--   
--   <ul>
--   <li>1.parameter f : the <i>simple</i> transforming filter</li>
--   <li>returns : the filter that applies f to all subtrees and the tree
--   itself in a deepth first left to right manner</li>
--   </ul>
--   
--   see also : <a>processTopDown</a>, <a>processBottomUpIfNot</a>
processBottomUp :: TFilter node -> TFilter node

-- | guarded bottom up transformation, stops at subtrees for which a
--   predicate p holds
--   
--   <ul>
--   <li>1.parameter f : the transforming filter</li>
--   <li>2.parameter p : the predicate filter for the guard</li>
--   <li>returns : the filter for processing all (sub-)trees</li>
--   </ul>
--   
--   see also : <a>processBottomUp</a>
processBottomUpIfNot :: TFilter node -> TFilter node -> TFilter node

-- | top down transformation
--   
--   <ul>
--   <li>1.parameter f : the <i>simple</i> transforming filter</li>
--   <li>returns : the filter that applies f first to the tree and then
--   recursively to all subtrees of the result</li>
--   </ul>
--   
--   see also : <a>processBottomUp</a>
processTopDown :: TFilter node -> TFilter node

-- | top down transformation until a node to be transformed is found
--   
--   <ul>
--   <li>1.parameter f : the <i>simple</i> transforming filter</li>
--   <li>returns : the filter that applies f first to the tree and, if the
--   filter does not succeed, recursively to all children of the input
--   tree.</li>
--   </ul>
--   
--   Example:
--   
--   <pre>
--   processTopDownUntil none
--   </pre>
--   
--   is the identity filter (maybe a bit more inefficient).
--   
--   Example:
--   
--   <pre>
--   processTopDownUntil (add1Attr "border" "2" `containing` isTag "table")
--   </pre>
--   
--   is a filter for adding an attribute border="2" in all top level table
--   tags. The content of table tags will remain unchanged.
--   
--   see also : <a>processTopDown</a>, <a>processBottomUp</a>
processTopDownUntil :: TFilter node -> TFilter node

-- | insertion of trees into the list of children at a given position
--   
--   useful for inserting something into the list of children at a given
--   position the list of children is split with the <tt>splitAt</tt>
--   function the nodes are inserted between these two sublists.
--   
--   examples: <tt>insertChildrenAt 0 ins t</tt> inserts all elements
--   computed with <tt>ins t</tt> in front of the childen of <tt>t</tt>,
--   <tt>insertChildrenAt 1 ins t</tt> behind the first child
--   
--   see also: <a>insertChildrenAfter</a>
insertChildrenAt :: Int -> TFilter node -> TFilter node

-- | insertion of trees into the list of children after specific elements
--   
--   useful for inserting something into the list of children of a node the
--   list of children is split with the <tt>span</tt> function and the
--   filter p as predicate the nodes are inserted between these two
--   sublists
--   
--   examples: <tt>insertChildrenAfter none ins t</tt> inserts all elements
--   computed with <tt>ins t</tt> in front of the childen of <tt>t</tt>,
--   <tt>insertChildrenAfter this ins t</tt> appends the elements to the
--   children
--   
--   see also: <a>insertChildrenAt</a>
insertChildrenAfter :: TFilter node -> TFilter node -> TFilter node

-- | the monadic version of the identity filter this.
--   
--   see also : <a>this</a>
thisM :: Monad m => (a -> m [a])

-- | the monadic version of the null filter none.
--   
--   see also : <a>none</a>
noneM :: Monad m => (a -> m [b])

-- | sequential composition of monadic filters, monadic version of ".&gt;".
--   
--   <ul>
--   <li>1.parameter f1 : the 1. monadic filter</li>
--   <li>2.parameter f2 : the 2. monadic filter</li>
--   <li>returns : the monadic fiter applying first f1 to n and then f2 to
--   the result (like function composition)</li>
--   </ul>
--   
--   see also : '(.&gt;)'
(.>>) :: Monad m => (a -> m [b]) -> (b -> m [c]) -> (a -> m [c])

-- | generalized sequential composition of monadic filters
seqM :: Monad m => [a -> m [a]] -> (a -> m [a])

-- | binary parallel composition, the logical OR for predicate filter
--   
--   <ul>
--   <li>1.parameter f1 : the 1. filter</li>
--   <li>2.parameter f2 : the 2. filter</li>
--   <li>returns : the filter for applying f1 and f2 both to an argument
--   tree and concatenating the results see also: <a>cat</a>, <a>+++</a>,
--   <a>catM</a></li>
--   </ul>
(+++>>) :: Monad m => (a -> m [b]) -> (a -> m [b]) -> (a -> m [b])

-- | apply a list of monadic filters
--   
--   <ul>
--   <li>1.parameter fs : the list of filters</li>
--   <li>returns : the composing filter see also: <a>cat</a>, <a>+++</a>,
--   <a>+++&gt;&gt;</a></li>
--   </ul>
catM :: Monad m => [a -> m [b]] -> (a -> m [b])

-- | monadic if-then-else.
--   
--   <ul>
--   <li>1.parameter p : the predicate</li>
--   <li>2.parameter thenP : the then part: the monadic filter, that is
--   applied if p holds for the input tree</li>
--   <li>3.parameter elseP : the else part</li>
--   <li>returns : the monadic filter for the conditional</li>
--   </ul>
ifM :: Monad m => (a -> [b]) -> (a -> m [c]) -> (a -> m [c]) -> (a -> m [c])

-- | monadic version of multiway branch. The list of cases <tt>f :-&gt;
--   g</tt> is processed sequentially, in the first case for that f holds g
--   is applied, if no case matches, <a>noneM</a> is applied. This filter
--   can be used like a case expression: <tt>choiceM [ p1 :-&gt; f1, p2
--   :-&gt; f2, ... , thisM :-&gt; defaultFilter]</tt>
--   
--   see also : <a>choice</a>, <a>ifM</a>
choiceM :: Monad m => [IfThen (a -> [c]) (a -> m [b])] -> (a -> m [b])

-- | when the predicate p holds, the monadic filter f is applied, else the
--   identity filter.
--   
--   <ul>
--   <li>1.parameter f : the conditinally applied monadic filter</li>
--   <li>2.parameter p : the simple predicate</li>
--   <li>returns : the conditional filter</li>
--   </ul>
--   
--   see also : <a>ifM</a>, <a>when</a>, <a>guardsM</a>, <a>whenNotM</a>
whenM :: Monad m => (a -> m [a]) -> (a -> [b]) -> (a -> m [a])

-- | the complementary filter of whenM.
--   
--   see also : <a>ifM</a>, <a>whenM</a>, <a>whenNot</a>
whenNotM :: Monad m => (a -> m [a]) -> (a -> [b]) -> (a -> m [a])

-- | when the predicate p holds, the monadic filter f is applied, else the
--   null filter.
--   
--   <ul>
--   <li>1.parameter p : the simple predicate filter</li>
--   <li>2.parameter f : the conditionally applied monadic filter</li>
--   <li>returns : the conditional filter</li>
--   </ul>
--   
--   see also : <a>ifM</a>, <a>guards</a>, <a>whenM</a>
guardsM :: Monad m => (a -> [b]) -> (a -> m [c]) -> (a -> m [c])

-- | pruning: monadic version of containing, usually written in infix
--   notation as f <a>containingM</a> g
--   
--   <ul>
--   <li>1.parameter f : the monadic processing filter</li>
--   <li>2.parameter g : the predicate filter</li>
--   <li>3.parameter t : the tree</li>
--   <li>returns : all trees r from f t, for which g r holds (is not the
--   empty list)</li>
--   </ul>
--   
--   see also : <a>notContaining</a>
containingM :: Monad m => (a -> m [b]) -> (b -> [c]) -> a -> m [b]

-- | Filter for editing the children of a tree with a monadic filter
--   
--   <ul>
--   <li>1.parameter cf : the monadic filter applied to the children</li>
--   <li>returns : the monadic editing filter</li>
--   </ul>
--   
--   see also : <a>processChildren</a>
processChildrenM :: Monad m => (NTree node -> m [NTree node]) -> (NTree node -> m [NTree node])

-- | monadic variant of <a>processTopDown</a>
processTopDownM :: Monad m => (NTree node -> m [NTree node]) -> (NTree node -> m [NTree node])

-- | monadic variant of <a>processBottomUp</a>
processBottomUpM :: Monad m => (NTree node -> m [NTree node]) -> (NTree node -> m [NTree node])

-- | lift a filter to a monadic filter
--   
--   <ul>
--   <li>1.parameter f : the <i>simple</i> filter</li>
--   <li>returns : the lifted monadic version</li>
--   </ul>
liftMf :: Monad m => (a -> [b]) -> a -> m [b]

-- | infix operator for applying a filter to a list of trees
--   
--   <ul>
--   <li>1.parameter f : the filter</li>
--   <li>2.parameter ts : the list of trees</li>
--   <li>returns : the concatenated list of results</li>
--   </ul>
($$) :: (a -> [b]) -> [a] -> [b]

-- | infix operator for applying a monadic filter to a list of trees,
--   typically used in do-notation for processing of intermediate results.
--   
--   <ul>
--   <li>1.parameter f : the monadic filter</li>
--   <li>2.parameter ts : the list of trees</li>
--   <li>returns : the concatenated list of results</li>
--   </ul>
--   
--   see also : '($$)'
($$<) :: Monad m => (a -> m [b]) -> [a] -> m [b]

-- | run an arbitray command on a tree t and return the tree, used for
--   inserting arbitray commands in a filter pipeline
--   
--   <ul>
--   <li>1.parameter cmd : the command</li>
--   <li>2.parameter t : the argument tree</li>
--   <li>returns : the unchanged tree as a single element list</li>
--   </ul>
performAction :: Monad m => (a -> m b) -> a -> m [a]


-- | exports the core data types and some additional types and functions
--   for compatibility with none arrow modules
--   
--   Version : $Id: XmlTreeTypes.hs,v 1.6 2006<i>05</i>09 15:30:43 hxml Exp
--   $
module Text.XML.HXT.DOM.XmlTreeTypes
mkNode :: node -> NTrees node -> NTree node
formatNTree :: (node -> String) -> NTree node -> String
foldNTree :: (a -> [b] -> b) -> NTree a -> b
mapNTree :: (a -> b) -> NTree a -> NTree b
nTreeToList :: NTree a -> [a]
depthNTree :: NTree a -> Int
cardNTree :: NTree a -> Int

-- | A functions that takes a node and returns a list of nodes
type XmlFilter = TFilter XNode

-- | A function that takes a list of nodes and returns a list of nodes
type XmlSFilter = TSFilter XNode

-- | Tag name
type TagName = QName

-- | Attribute name
type AttrName = QName

-- | shortcut for <a>qualifiedName</a>
tName :: QName -> String

-- | shortcut for <a>qualifiedName</a>
aName :: QName -> String


-- | Basic XmlTree functions
module Text.XML.HXT.DOM.XmlTreeFunctions
isXCdataNode :: XNode -> Bool
isXCharRefNode :: XNode -> Bool
isXCmtNode :: XNode -> Bool
isXDTDNode :: XNode -> Bool
isXAttrNode :: XNode -> Bool
isXEntityRefNode :: XNode -> Bool
isXErrorNode :: XNode -> Bool
isXPiNode :: XNode -> Bool
isXTagNode :: XNode -> Bool
isXTextNode :: XNode -> Bool
isRootNode :: XNode -> Bool
isTagNode :: String -> XNode -> Bool
isOfTagNode :: (TagName -> Bool) -> XNode -> Bool
isAttrNode :: String -> XNode -> Bool
isOfAttrNode :: (AttrName -> Bool) -> XNode -> Bool
isTextNode :: String -> XNode -> Bool
isOfTextNode :: (String -> Bool) -> XNode -> Bool
isPiNode :: String -> XNode -> Bool
isOfPiNode :: (TagName -> Bool) -> XNode -> Bool
isDTDElemNode :: DTDElem -> XNode -> Bool
isErrorNode :: Int -> XNode -> Bool
textOfXNode :: XNode -> String

-- | Create a tree with a tag node.
--   
--   <ul>
--   <li>1.parameter n : the name of the tag</li>
--   <li>2.parameter al : the tag attribte list</li>
--   <li>3.parameter cs : the list of children</li>
--   <li>returns : the new tree</li>
--   </ul>
mkXTagTree :: String -> XmlTrees -> XmlTrees -> XmlTree

-- | Version with qualified name of <a>mkXTagTree</a>
mkQTagTree :: QName -> XmlTrees -> XmlTrees -> XmlTree

-- | create a tree with a namespace aware tag node.
--   
--   <ul>
--   <li>1.parameter n : the prefix:localpart of the tag</li>
--   <li>2.parameter ns: the namespace uri</li>
--   <li>3.parameter al : the tag attribte list</li>
--   <li>4.parameter cs : the list of children</li>
--   <li>returns : the new tree</li>
--   </ul>
--   
--   see also: <a>mkXTagTree</a>
mkXNsTagTree :: String -> String -> XmlTrees -> XmlTrees -> XmlTree

-- | creates a new document tree with empty contents.
--   
--   <ul>
--   <li>1.parameter al : the attribute list for the root node</li>
--   </ul>
--   
--   returns a single node tree with tag name "/" indicating a root and
--   with empty list of children
--   
--   see also : <a>emptyRoot</a>
newRoot :: XmlTrees -> XmlTree

-- | the empty document tree
--   
--   see also : <a>newRoot</a>
emptyRoot :: XmlTree

-- | create a new empty document with source name as parameter
newDocument :: String -> XmlTree

-- | create a new empty document with a list of attributes for source
--   location and options
--   
--   see also : <a>newDocument</a>
newDocument' :: Attributes -> XmlTree

-- | create a document root tree.
--   
--   <ul>
--   <li>1.parameter al : the attribute list for the root. This list must
--   contain at least an attribute "source" that contains the URI of the
--   document to be processed</li>
--   <li>2.parameter cs : the list for the document content</li>
--   <li>returns : the document root</li>
--   </ul>
mkRootTree :: XmlTrees -> XmlTrees -> XmlTree

-- | create a leaf for a text element.
--   
--   <ul>
--   <li>1.parameter txt : the text</li>
--   <li>returns : the tree with the single node containing the text</li>
--   </ul>
mkXTextTree :: String -> XmlTree

-- | create a leaf for a char reference.
--   
--   <ul>
--   <li>1.parameter i : the integer representing the Unicode char</li>
--   <li>returns : the tree with the single node containing the char
--   reference</li>
--   </ul>
mkXCharRefTree :: Int -> XmlTree

-- | create a leaf for an entity reference.
--   
--   <ul>
--   <li>1.parameter n : the name of the entity reference</li>
--   <li>returns : the tree with the single node containing the entity
--   reference</li>
--   </ul>
mkXEntityRefTree :: String -> XmlTree

-- | create a leaf for a comment,
--   
--   <ul>
--   <li>1.parameter c : the comment text</li>
--   <li>returns : the tree with the single node containing the
--   comment</li>
--   </ul>
mkXCmtTree :: String -> XmlTree

-- | create a tree for a part of a DTD
--   
--   <ul>
--   <li>1.parameter d : the type of the DTD part</li>
--   <li>2.parameter al : the attribute list for the DTD part</li>
--   <li>3.parameter ds : the possibly empty list of components for the DTD
--   part</li>
--   <li>returns : the tree with the composed DTD part</li>
--   </ul>
mkXDTDTree :: DTDElem -> Attributes -> XmlTrees -> XmlTree

-- | create an attribute tree as part of a tag attribute list of tag nodes
--   
--   <ul>
--   <li>1.parameter al : the attribute name</li>
--   <li>2.parameter av : the attribute value as tree list, usually
--   containing a single text node</li>
--   </ul>
mkXAttrTree :: String -> XmlTrees -> XmlTree

-- | Qualified version of <a>mkXAttrTree</a>
mkQAttrTree :: QName -> XmlTrees -> XmlTree

-- | create an attribute tree with a namespace
--   
--   <ul>
--   <li>1.parameter al : the attribute name</li>
--   <li>2.parameter ns : namespace uri</li>
--   <li>3.parameter av : the attribute value as tree list, usually
--   containing a single text node</li>
--   </ul>
--   
--   see also: <a>mkXAttrTree</a>, <a>mkXNsTagTree</a>
mkXNsAttrTree :: String -> String -> XmlTrees -> XmlTree

-- | create a parameter entity reference DTD part.
--   
--   <ul>
--   <li>1.parameter ref : the name of the reference</li>
--   <li>returns : the DTD part for a PERef</li>
--   </ul>
mkXPERefTree :: String -> XmlTree

-- | create a processing instruction tree.
--   
--   <ul>
--   <li>1.parameter n : the name of the PI</li>
--   <li>2.parameter str : the content of a PI</li>
--   <li>returns : the processing instruction tree with a single attribute
--   "value" with the str parameter as attribute value, with <tt>valueOf
--   a_value</tt> applied to the result tree the content of the PI can be
--   selected</li>
--   </ul>
mkXPiTree :: String -> String -> XmlTree

-- | create xml declaration
mkXmlDeclTree :: XmlTrees -> XmlTree

-- | create a CDATA section tree.
--   
--   <ul>
--   <li>1.parameter s : the content of the CDATA section</li>
--   <li>returns : the tree for the CDATA section</li>
--   </ul>
mkXCdataTree :: String -> XmlTree

-- | create an error tree.
--   
--   <ul>
--   <li>1.parameter l : the level of the error (warning, error fatal)</li>
--   <li>2.parameter msg : the error message</li>
--   <li>3.parameter cs : the context, where the error was detected</li>
--   </ul>
mkXErrorTree :: Int -> String -> XmlTrees -> XmlTree
maybeString2XText :: Maybe String -> XmlTrees
showXText :: XmlTrees -> String
showXCharRef :: XmlTrees -> String
showXEntityRef :: XmlTrees -> String
showXErrors :: XmlTrees -> String

-- | old name for <a>xshow</a> (deprecated)
xmlTreesToString :: XmlTrees -> String

-- | conversion of a filter result into a text node
--   
--   see also : <a>xshow</a>
xmlTreesToText :: XmlSFilter
xmlContentModelToString :: XmlTree -> String

-- | select the name of a node. For tags, attributes and pi's the name
--   string is returned, else the empty string.
nameOf :: XmlTree -> String

-- | select the local part of a name of a node. For tags, attributes the
--   name string is returned, for pi's the whole name, else the empty
--   string.
localPartOf :: XmlTree -> String

-- | select the namespace URI of a tag or an attribute tree, else the empty
--   string is returned see also : <a>nameOf</a>
namespaceOf :: XmlTree -> String

-- | select the namespace prefix of a tag or an attribute tree, else the
--   empty string is returned see also : <a>nameOf</a>, <a>localPartOf</a>
prefixOf :: XmlTree -> String

-- | select the universal name (namespace uri ++ localPart) of a tag or an
--   attribute tree, else the empty string is returned see also :
--   <a>nameOf</a>, <a>namespaceOf</a>
universalNameOf :: XmlTree -> String

-- | select the attributes of a dtd tree
attrlOfDTD :: XmlTree -> Attributes

-- | select a special attribute of a DTD part
valueOfDTD :: String -> XmlTree -> String

-- | test an attribute of a DTD part
ofDTDequals :: String -> String -> XmlTree -> Bool
xcmt :: String -> XmlTrees
xerr :: String -> XmlTrees
xwarn :: String -> XmlTrees
xtext :: String -> XmlTrees
xtag :: String -> XmlTrees -> XmlTrees -> XmlTrees
xattr :: String -> String -> XmlTrees
toTreel :: XmlTrees -> AssocList String XmlTrees
toAttrl :: XmlTrees -> Attributes
fromTreel :: AssocList String XmlTrees -> XmlTrees
fromAttrl :: Attributes -> XmlTrees


-- | basic XmlTree filter
module Text.XML.HXT.DOM.XmlTreeFilter

-- | test whether the root of a tree contains a document root node.
isRoot :: XmlFilter

-- | test whether the root of a tree contains a tag node.
--   
--   see also: <a>isNsTag</a>
isTag :: String -> XmlFilter

-- | namespace aware test whether the root of a tree contains a tag node.
--   Parameters are the local part and namespace. Only usable after
--   namespace propagation.
--   
--   see also: <a>isTag</a>
isNsTag :: String -> String -> XmlFilter

-- | test whether the root of a tree has a given local name see also :
--   <a>hasNamespace</a>, <a>hasPrefix</a>, <a>isTag</a>, <a>isAttr</a>
hasLocalPart :: String -> XmlFilter

-- | test whether the root of a tree has a given prefix name see also :
--   <a>hasNamespace</a>, <a>hasLocalPart</a>, <a>isTag</a>, <a>isAttr</a>
hasPrefix :: String -> XmlFilter

-- | test whether the root of a tree belongs to a given namespace see also
--   : <a>isTag</a>, <a>isAttr</a>, <a>hasLocalPart</a>, <a>hasPrefix</a>
hasNamespace :: String -> XmlFilter

-- | test whether the root of a tree contains a tag node with a special
--   name.
isOfTag :: (TagName -> Bool) -> XmlFilter

-- | test whether the node of a tree is a XTag node or a XPi node with an
--   attibute of a specific name
--   
--   see also: <a>isAttr</a>, <a>hasNsAttr</a>
hasAttr :: String -> XmlFilter

-- | test whether the tree is a XTag node with an attibute of a specific
--   local name and namespace uri
--   
--   see also: <a>hasAttr</a>, <a>isNsAttr</a>
hasNsAttr :: String -> String -> XmlFilter

-- | test whether the given node is a XTag node or a XPI node with an
--   attribute with a value with a specific property. In case of a match,
--   the attribute value represented by a text node is returned as single
--   element list, else the empty list is the result.
--   
--   see also : <a>getValue</a>
hasValue :: String -> (String -> Bool) -> XmlFilter

-- | test whether the tree is a processing instruction with a given name.
isPi :: String -> XmlFilter

-- | test whether the tree is a &lt;?xml ... ?&gt; declaration
isXmlPi :: XmlFilter

-- | test whether the root of a tree contains a processing instruction of a
--   special name.
isOfPi :: (TagName -> Bool) -> XmlFilter

-- | test whether the root of a tree contains a CDATA node.
isXCdata :: XmlFilter

-- | test whether the root of a tree contains a character reference node.
isXCharRef :: XmlFilter

-- | test whether the root of a tree contains a comment node.
isXCmt :: XmlFilter

-- | test whether the root of a tree contains a DTD part.
isXDTD :: XmlFilter

-- | test whether the root of a tree contains an entity reference node.
isXEntityRef :: XmlFilter

-- | test whether the root of a tree contains an error node.
isXError :: XmlFilter

-- | test whether the root of a tree contains a processing instruction
--   node.
isXPi :: XmlFilter

-- | test whether the root of a tree contains a tag node.
isXTag :: XmlFilter

-- | test whether the root of a tree contains an attribute node.
isXAttr :: XmlFilter

-- | test whether the root of a tree is an attribute node for a given
--   attribute name
isAttr :: String -> XmlFilter

-- | namespace aware test whether the tree contains an attribute node.
--   Parameters are the local part of the atribute name and the namespace.
--   Only usable after namespace propagation.
--   
--   see also: <a>isNsTag</a>, <a>isAttr</a>, <a>hasNsAttr</a>
isNsAttr :: String -> String -> XmlFilter

-- | general test for an attribute name
isOfAttr :: (AttrName -> Bool) -> XmlFilter

-- | test whether the root of a tree contains a text node.
isXText :: XmlFilter

-- | test whether the root of a tree contains a special text.
isText :: String -> XmlFilter

-- | test whether the root of a tree contains a text node with a special
--   property
isOfText :: (String -> Bool) -> XmlFilter

-- | test whether the root of a tree contains a text node only with
--   whitespace.
isWhiteSpace :: XmlFilter

-- | test whether the root of a tree contains a DOCTYPE DTD part.
isDoctype :: XmlFilter

-- | test whether the root of a tree contains an ATTLIST DTD part.
isAttlist :: XmlFilter

-- | test whether the root of a tree contains an ELEMENT DTD part.
isElement :: XmlFilter

-- | test whether the root of a tree contains an ENTITY DTD part.
isEntity :: XmlFilter

-- | test whether the root of a tree contains a parameter ENTITY reference.
isPeRef :: XmlFilter

-- | test whether the root of a tree contains a DTD name part.
isDTDName :: XmlFilter

-- | test whether the root of a tree contains a conditional section DTD
--   part.
isCondSect :: XmlFilter

-- | test whether the root of a tree contains a parameter entity
--   declaration.
isParameterEntity :: XmlFilter

-- | test whether the root of a tree contains a NOTATION DTD part.
isNotation :: XmlFilter
isDefaultAttrKind :: XmlFilter
isEnumAttrType :: XmlFilter
isFixedAttrKind :: XmlFilter
isIdAttrType :: XmlFilter
isIdRefAttrType :: XmlFilter
isNotationAttrType :: XmlFilter
isRequiredAttrKind :: XmlFilter
isAttlistParameterEntity :: XmlFilter
isEmptyElement :: XmlFilter
isMixedContentElement :: XmlFilter
isElemWithContent :: XmlFilter
isAttlistOfElement :: String -> XmlFilter
isElemContentParamEntity :: XmlFilter
isUnparsedEntity :: XmlFilter
isExternalParameterEntity :: XmlFilter
isInternalParameterEntity :: XmlFilter

-- | test whether the root of a tree contains an error node for a warning.
isWarning :: XmlFilter

-- | test whether the root of a tree contains an error node for an error.
isError :: XmlFilter

-- | test whether the root of a tree contains an error node for a fatal
--   error.
isFatalError :: XmlFilter

-- | constructor filter for a tag node. a new tree is constructed. the
--   attributes and the children are computed by applying the aproprate
--   filter to the input tree
--   
--   <ul>
--   <li>1.parameter n : the tag name</li>
--   <li>2.parameter af : the filter for the attribute list</li>
--   <li>3.parameter cf : the filter for the children</li>
--   <li>returns : the constructor filter</li>
--   </ul>
mkXTag :: String -> XmlFilter -> XmlFilter -> XmlFilter

-- | Version with qualified names of <a>mkXTag</a>
mkQTag :: QName -> XmlFilter -> XmlFilter -> XmlFilter

-- | constructor filter for a tag node. a new tree is constructed. the
--   attributes and the children are computed by applying the aproprate
--   filter to the input tree
--   
--   <ul>
--   <li>1.parameter n : the tag name in form of prefix:localpart</li>
--   <li>2.parameter ns: the namespace uri</li>
--   <li>3.parameter af : the filter for the attribute list</li>
--   <li>4.parameter cf : the filter for the children</li>
--   <li>returns : the constructor filter</li>
--   </ul>
mkXNsTag :: String -> String -> XmlFilter -> XmlFilter -> XmlFilter

-- | filter for attribute construction. a new tree with attribute name and
--   a value computed by a filter is build.
mkXAttr :: String -> XmlFilter -> XmlFilter

-- | Qualified version <a>mkXAttr</a>
mkQAttr :: QName -> XmlFilter -> XmlFilter

-- | filter for attribute construction. a new tree with attribute name and
--   namespace and a value computed by a filter is build.
mkXNsAttr :: String -> String -> XmlFilter -> XmlFilter

-- | constructor filter for a text node. a new tree is constructed. the
--   input tree is ignored.
mkXText :: String -> XmlFilter

-- | constructor filter for a character reference node. a new tree is
--   constructed. the input tree is ignored.
mkXCharRef :: Int -> XmlFilter

-- | constructor filter for an entity reference node. a new tree is
--   constructed. the input tree is ignored.
mkXEntityRef :: String -> XmlFilter

-- | constructor filter for a comment node. a new tree is constructed. the
--   xml string representation of the filter result forms the comment
mkXCmt :: XmlFilter -> XmlFilter

-- | constructor filter for a DTD part. a new tree is constructed. the
--   input tree is ignored.
mkXDTD :: DTDElem -> Attributes -> XmlTrees -> XmlFilter

-- | constructor filter for a CDATA section node. a new tree is
--   constructed. the input tree is ignored.
mkXCdata :: XmlFilter -> XmlFilter

-- | constructor filter for a processing instruction a new tree is
--   constructed from the text representation of the input tree
mkXPi :: String -> XmlFilter -> XmlFilter

-- | constructor filter for an error message node. a new tree is
--   constructed. the input tree is ignored.
mkXError :: Int -> String -> XmlFilter

-- | filter for selecting the name of a tag node, an attribute node or a pi
--   node. Result of the filter is a single element list with a text node
--   or the empty list
getName :: XmlFilter

-- | filter for selecting the attibute list
getAttrl :: XmlFilter

-- | filter for selecting the value of an attribute in a tag node. Result
--   of the filter is a single element list with a text node or the empty
--   list
--   
--   see also : <a>hasValue</a>, <a>getNsValue</a>
getValue :: String -> XmlFilter

-- | filter for selecting the value of an attribute with namespace in a tag
--   node. Result of the filter is a single element list with a text node
--   or the empty list
--   
--   see also : <a>getValue</a>, <a>isNsAttr</a>
getNsValue :: String -> String -> XmlFilter

-- | filter for selecting an attribute of a DTD node. Result of the filter
--   is a single element list with a text node or the empty list
getDTDValue :: String -> XmlFilter

-- | filter for selecting content of a comment. Result of the filter is a
--   single element list with a text node or the empty list
getXCmt :: XmlFilter

-- | filter for selecting the CDATA content. Result of the filter is a
--   single element list with a text node or the empty list
getXCdata :: XmlFilter

-- | edit filter for changing the name of a tag node, an attribute or a pi.
--   result of the filter is a single element list with a tag node or the
--   empty list
replaceQName :: String -> XmlFilter

-- | edit filter for changing the text of a text node. result of the filter
--   is a single element list with a text node or the empty list
--   
--   example for editing all text nodes of a tree with an edit function
--   <tt>f</tt>:
--   
--   <pre>
--   processBottomUp (modifyText f `when` isXText)
--   </pre>
modifyText :: (String -> String) -> XmlFilter

-- | edit filter for changing the name of a tag node. result of the filter
--   is a single element list with a text node or the empty list
modifyQName :: (TagName -> TagName) -> XmlFilter

-- | process the attribute list of a tag node with a tree list filter. for
--   other trees this filter acts like <a>none</a>
processAttrl :: XmlSFilter -> XmlFilter

-- | elementwise processing of the attributes of a tag. for other trees
--   this filter acts like <a>none</a>
--   
--   see also : <a>processAttrl</a>
processAttr :: XmlFilter -> XmlFilter

-- | replace an attribute list to be renamed when replaceAttrl is
--   eliminated
replaceAttrl :: XmlTrees -> XmlFilter

-- | delete an attribute from the attribute list of a tag tree
del1Attr :: String -> XmlFilter

-- | add an attribute to the attribute list of a tag. If the attribute
--   already exists, it's substituted,
--   
--   see also: <a>sattr</a>, <a>+=</a>
add1Attr :: XmlTree -> XmlFilter

-- | adds an attribute list computed by a filter, uses <a>add1Attr</a>.
--   
--   see also: <a>+=</a>
addAttrl :: XmlFilter -> XmlFilter

-- | add or change an attribute with a given string as value for a XTag or
--   XPi tree, uses <a>add1Attr</a>.
addAttr :: String -> String -> XmlFilter

-- | add or change an attribute with an Int value. uses <a>addAttr</a>.
addAttrInt :: String -> Int -> XmlFilter

-- | edit filter for changing the value of an attribute in a tag node.
--   result of the filter is a single element list with the tag node or the
--   empty list.
--   
--   <ul>
--   <li>1.parameter n : the name of the attribute</li>
--   <li>2.parameter f : the edit function for the attribute value</li>
--   <li>returns : the edit filter</li>
--   </ul>
modifyAttr :: String -> (String -> String) -> XmlFilter

-- | add or change an attribute of a DTD tree
addDTDAttr :: String -> String -> XmlFilter

-- | convenient function for tag node tree construction
--   
--   infixl 7
--   
--   filter combinator for tag tree constrcution take a 1. filter for
--   computing a tag node tree (or a whole list of tag node trees) then add
--   all trees computed by the 2. filter to the attribute list when they
--   represent attributes else append them to the list of children.
--   
--   if the 1. filter computes a list of tag nodes, the results of the 2.
--   filter are added to all trees
--   
--   example: <tt> etag "a" += sattr "href" "#42" += txt "the answer" </tt>
--   gives the tree <tt> &lt;a href="#42"&gt;the answer&lt;/a&gt; </tt>
--   
--   example: <tt> ( etag "a" +++ etag "b" ) += sattr "x" "42" </tt> gives
--   the tree <tt> &lt;a x="42"/&gt;&lt;b x="42"/&gt; </tt>
--   
--   see also : <a>etag</a>, <a>tag</a>, <a>add1Attr</a>,
--   <a>modifyChildren</a>, <a>++=</a>
(+=) :: XmlFilter -> XmlFilter -> XmlFilter

-- | convenient filter function adding a whole list of trees, just for not
--   writing to many ( ... ).
--   
--   infixl 7
--   
--   <pre>
--   f ++= gl  == f += cat gl
--   </pre>
--   
--   see also : <a>+=</a>
(++=) :: XmlFilter -> [XmlFilter] -> XmlFilter

-- | combination of <a>getValue</a> and conversion into a String
valueOf :: String -> XmlTree -> String

-- | combination of <a>getValue</a> and conversion to a Int
intValueOf :: String -> XmlTree -> Int

-- | variant of mkXTag with a list of filters for the attributes and a list
--   of filters for the children. this variant leads to a more readable
--   source for a complicated construction filter than the simple solution
--   with a combination of <a>mkXTag</a> and <a>cat</a>.
--   
--   see also : <a>mkXTag</a>, <a>stag</a>, <a>etag</a>, <a>cat</a>,
--   <a>+=</a>
tag :: String -> [XmlFilter] -> [XmlFilter] -> XmlFilter

-- | variant of tag, useful for tags without attributes and with a list of
--   filters for constructing the children
--   
--   see also : <a>mkXTag</a>, <a>tag</a>, <a>etag</a>, <a>cat</a>,
--   <a>+=</a>
stag :: String -> [XmlFilter] -> XmlFilter

-- | variant of tag, useful for tags with attributes but without children
--   
--   see also : <a>mkXTag</a>, <a>tag</a>, <a>stag</a>, <a>etag</a>,
--   <a>cat</a>
atag :: String -> [XmlFilter] -> XmlFilter

-- | Short cut for empty tags without attributes
--   
--   see also : <a>tag</a>, <a>atag</a>, <a>stag</a>, <a>mkXTag</a> and
--   <a>+=</a>
etag :: String -> XmlFilter

-- | Qualified version of etag
qetag :: QName -> XmlFilter

-- | Alias for mkQTag
qtag :: QName -> XmlFilter -> XmlFilter -> XmlFilter

-- | filter for creating a document root node with a list of filters for
--   the attributes and a list of filters for the document.
--   
--   see also : <a>tag</a>
rootTag :: [XmlFilter] -> [XmlFilter] -> XmlFilter

-- | Alias for <a>mkXAttr</a>
attr :: String -> XmlFilter -> XmlFilter

-- | Alias for mkQAttr
qattr :: QName -> XmlFilter -> XmlFilter

-- | short cut for attribute construction with string constants
--   
--   set also : <a>attr</a>, <a>mkXAttr</a> and <a>mkXText</a>
sattr :: String -> String -> XmlFilter

-- | short cut for <a>mkXText</a>
txt :: String -> XmlFilter

-- | short cut for simple comment the input tree is ignored
--   
--   see also : <a>mkXCmt</a>
cmt :: String -> XmlFilter

-- | short cut for generating simple processing instructions (spi) the
--   input tree is ignored
--   
--   <tt>spi "xyz" "abc"</tt> is equal to <tt>mkXPi "xyz" (txt "abc")</tt>
--   (the name pi is already used in prelude)
spi :: String -> String -> XmlFilter

-- | short cut for generating simple cdata sections, the input tree is
--   ignored
cdata :: String -> XmlFilter

-- | DTD part generation with filter for attributes and children see also:
--   <a>mkXDTDTree</a>
dtd :: DTDElem -> [XmlFilter] -> [XmlFilter] -> XmlFilter

-- | short cut for mkXError c_warn.
--   
--   see also : <a>mkXError</a>
warn :: String -> XmlFilter

-- | short cut for mkXError c_fatal.
--   
--   see also : <a>mkXError</a>
err :: String -> XmlFilter

-- | short cut for mkXError c_fatal.
--   
--   see also : <a>mkXError</a>
fatal :: String -> XmlFilter

-- | check whether an option is set
--   
--   reads the value of an attribute, usually applied to a document root
--   node, and checks if the value represents True. The following strings
--   are interpreted as true: "1", "True", "true", "yes", "Yes".
hasOption :: String -> XmlFilter


-- | This helper module exports elements from the basic libraries:
--   XmlTreeTypes, XmlKeywords, XNodeFunctions, XmlTreeFunctions and
--   XmlTreeFilter
module Text.XML.HXT.DOM.XmlTree


-- | XML editing filters
module Text.XML.HXT.DOM.EditFilters

-- | Applies some <a>Canonical XML</a> rules to the nodes of a tree.
--   
--   The rule differ slightly for canonical XML and XPath in handling of
--   comments
--   
--   Note: This is not the whole canonicalization as it is specified by the
--   W3C Recommendation. Adding attribute defaults or sorting attributes in
--   lexicographic order is done by the <tt>transform</tt> function of
--   module <tt>Text.XML.HXT.Validator.Validation</tt>. Replacing entities
--   or line feed normalization is done by the parser.
--   
--   Not implemented yet:
--   
--   <ul>
--   <li>Whitespace within start and end tags is normalized</li>
--   <li>Special characters in attribute values and character content are
--   replaced by character references</li>
--   </ul>
--   
--   see <a>canonicalizeAllNodes</a> and <a>canonicalizeForXPath</a>
canonicalizeTree :: XmlFilter -> XmlFilter

-- | canonicalize tree and remove comments and &lt;?xml ... ?&gt;
--   declarations
--   
--   see <a>canonicalizeTree</a>
canonicalizeAllNodes :: XmlFilter

-- | Canonicalize a tree for XPath Comment nodes are not removed
--   
--   see <a>canonicalizeTree</a>
canonicalizeForXPath :: XmlFilter

-- | Collects sequences of child XText nodes into one XText node.
collapseXText :: XmlFilter

-- | Applies collapseXText recursively.
--   
--   see also : <a>collapseXText</a>
collapseAllXText :: XmlFilter

-- | filter for indenting a document tree for pretty printing.
--   
--   the tree is traversed for inserting whitespace for tag indentation.
--   
--   whitespace is only inserted or changed at places, where it isn't
--   significant, is's not inserted between tags and text containing non
--   whitespace chars.
--   
--   whitespace is only inserted or changed at places, where it's not
--   significant. preserving whitespace may be controlled in a document
--   tree by a tag attribute <tt>xml:space</tt>
--   
--   allowed values for this attribute are <tt>default | preserve</tt>.
--   
--   input is a complete document tree. result the semantically equivalent
--   formatted tree.
--   
--   see also : <a>removeDocWhiteSpace</a>
indentDoc :: XmlFilter

-- | simple filter for removing whitespace.
--   
--   no check on sigificant whitespace is done.
--   
--   see also : <a>removeAllWhiteSpace</a>, <a>removeDocWhiteSpace</a>
removeWhiteSpace :: XmlFilter

-- | simple recursive filter for removing all whitespace.
--   
--   removes all text nodes in a tree that consist only of whitespace.
--   
--   see also : <a>removeWhiteSpace</a>, <a>removeDocWhiteSpace</a>
removeAllWhiteSpace :: XmlFilter

-- | filter for removing all not significant whitespace.
--   
--   the tree traversed for removing whitespace between tags, that was
--   inserted for indentation and readability. whitespace is only removed
--   at places, where it's not significat preserving whitespace may be
--   controlled in a document tree by a tag attribute <tt>xml:space</tt>
--   
--   allowed values for this attribute are <tt>default | preserve</tt>
--   
--   input is root node of the document to be cleaned up output the
--   semantically equivalent simplified tree
--   
--   see also : <a>indentDoc</a>, <a>removeAllWhiteSpace</a>
removeDocWhiteSpace :: XmlFilter

-- | remove Comments
removeComment :: XmlFilter

-- | remove all Comments recursively
removeAllComment :: XmlFilter

-- | converts CDATA section in normal text sections
transfCdata :: XmlFilter

-- | converts CDATA sections in whole document tree
transfAllCdata :: XmlFilter

-- | converts CDATA section in normal text nodes
transfCdataEscaped :: XmlFilter

-- | converts CDATA sections in whole document tree into normal text nodes
transfAllCdataEscaped :: XmlFilter

-- | converts character references to normal text
transfCharRef :: XmlFilter

-- | recursively converts all character references to normal text
transfAllCharRef :: XmlFilter

-- | convert the special XML chars ", &lt;, &gt;, &amp; and ' in a document
--   to char references, attribute values are converted with
--   <a>escapeXmlAttrValue</a>
--   
--   see also: <a>escapeXmlText</a>, <a>escapeXmlAttrValue</a>
escapeXmlDoc :: XmlFilter

-- | convert the special XML chars in a text or comment node into character
--   references
--   
--   see also <a>escapeXmlDoc</a>
escapeXmlText :: XmlFilter

-- | convert the special XML chars in an attribute value into charachter
--   references. Not only the XML specials but also \n, \r and \t are
--   converted
--   
--   see also: <a>escapeXmlDoc</a>, <a>escapeXmlText</a>
escapeXmlAttrValue :: XmlFilter

-- | convert a document tree into an output string representation with
--   respect to the output encoding.
--   
--   The children of the document root are stubstituted by a single text
--   node for the text representation of the document.
--   
--   Encoding of the document is performed with respect to the
--   <tt>output-encoding</tt> attribute in the root node, or if not
--   present, of the <tt>encoding</tt> attribute for the original input
--   encoding. If the encoding is not specified or not supported, UTF-8 is
--   taken.
unparseXmlDoc :: XmlFilter

-- | convert a document into a text and add line numbers to the text
--   representation.
--   
--   Result is a root node with a single text node as child. Useful for
--   debugging and trace output. see also : <a>haskellRepOfXmlDoc</a>,
--   <a>treeRepOfXmlDoc</a>
numberLinesInXmlDoc :: XmlFilter
numberLines :: String -> String

-- | convert a document into a text representation in tree form.
--   
--   Useful for debugging and trace output. see also :
--   <a>haskellRepOfXmlDoc</a>, <a>numberLinesInXmlDoc</a>
treeRepOfXmlDoc :: XmlFilter

-- | convert a document into a Haskell representation (with show).
--   
--   Useful for debugging and trace output. see also :
--   <a>treeRepOfXmlDoc</a>, <a>numberLinesInXmlDoc</a>
haskellRepOfXmlDoc :: XmlFilter
addHeadlineToXmlDoc :: XmlFilter
addXmlPiToDoc :: XmlFilter


-- | Namespace filter
--   
--   Namespaces are processed with two main filter,
--   <a>propagateNamespaces</a> and <a>validateNamespaces</a>.
--   
--   <a>propagateNamespaces</a> takes a XML tree and attaches extra
--   namespace info at every tag name and attribute name. So after
--   processing a tree with <a>propagateNamespaces</a>, the access
--   functions <a>namespaceOf</a> and <a>universalNameOf</a> deliver the
--   associated namespace (or "") for tag names and attribute names.
--   
--   <a>validateNamespaces</a> checks whether names are wellformed related
--   to the XML namespace definition. whether a legal namespace is declared
--   for all prefixes, and whether attribute names are unique related to
--   universal names.
module Text.XML.HXT.DOM.NamespaceFilter

-- | Type for the namespace association list, used when propagating
--   namespaces by modifying the <a>QName</a> values in a tree
type NamespaceTable = NsEnv

-- | propagate all namespace declarations "xmlns:ns=..." to all tag and
--   attribute nodes of a document.
--   
--   This filter does not check for illegal use of namespaces. The real
--   work is done by <a>propagateNamespaceEnv</a>.
--   
--   The filter may be applied repeatedly if neccessary.
propagateNamespaces :: XmlFilter

-- | attaches the namespace info given by the namespace table to a tag node
--   and its attributes and children.
propagateNamespaceEnv :: NamespaceTable -> XmlFilter

-- | validate the namespace constraints in a whole tree. result is the list
--   of errors concerning namespaces. Work is done by applying
--   <a>validate1Namespaces</a> to all nodes. Predicates
--   <a>isWellformedQName</a>, <a>isWellformedQualifiedName</a>,
--   <a>isDeclaredNamespace</a> and <a>isWellformedNSDecl</a> are applied
--   to the appropriate tags and attributes.
validateNamespaces :: XmlFilter

-- | a single node for namespace constrains.
validate1Namespaces :: XmlFilter
isNamespaceDecl :: XmlFilter


-- | A module for regular expression matching, adapted for XML DTDs.
--   
--   This module is based on the module RE.
--   
--   Author .\artin Schmidt
module Text.XML.HXT.Validator.XmlRE

-- | Data type for regular expressions.
data RE a

-- | Checks if an input matched a regular expression. The function should
--   be called after matches.
--   
--   Was the sentence used in <tt>matches</tt> in the language of the
--   regular expression? -&gt; matches e s == s `in` L(e)?
--   
--   <ul>
--   <li>1.parameter re : the derived regular expression</li>
--   <li>returns : empty String if input matched the regular expression,
--   otherwise an error message is returned</li>
--   </ul>
checkRE :: Show a => RE a -> String

-- | Derives a regular expression with respect to a list of elements.
--   
--   <ul>
--   <li>1.parameter re : regular expression</li>
--   <li>2.parameter list : list of elements to which the regular
--   expression is applied</li>
--   <li>returns : the derived regular expression</li>
--   </ul>
matches :: RE String -> XmlTrees -> RE String

-- | Constructs a string representation of a regular expression.
--   
--   <ul>
--   <li>1.parameter re : a regular expression</li>
--   <li>returns : the string representation of the regular expression</li>
--   </ul>
printRE :: Show a => RE a -> String

-- | Constructs a regular expression for an empty sequence.
--   
--   <ul>
--   <li>returns : regular expression for an empty sequence</li>
--   </ul>
re_unit :: RE a

-- | Constructs a regular expression for an empty set.
--   
--   <ul>
--   <li>1.parameter errMsg : error message</li>
--   <li>returns : regular expression for an empty set</li>
--   </ul>
re_zero :: String -> RE a

-- | Constructs a regular expression for accepting a symbol
--   
--   <ul>
--   <li>1.parameter sym : the symbol to be accepted</li>
--   <li>returns : regular expression for accepting a symbol</li>
--   </ul>
re_sym :: a -> RE a

-- | Constructs an optional repetition (*) of a regular expression
--   
--   <ul>
--   <li>1.parameter re_a : regular expression to be repeted</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_rep :: RE a -> RE a

-- | Constructs a repetition (+) of a regular expression
--   
--   <ul>
--   <li>1.parameter re_a : regular expression to be repeted</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_plus :: RE a -> RE a

-- | Constructs an option (?) of a regular expression
--   
--   <ul>
--   <li>1.parameter re_a : regular expression to be optional</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_opt :: RE a -> RE a

-- | Constructs a sequence (,) of two regular expressions
--   
--   <ul>
--   <li>1.parameter re_a : first regular expression in sequence</li>
--   <li>2.parameter re_b : second regular expression in sequence</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_seq :: RE a -> RE a -> RE a

-- | Constructs an alternative (|) of two regular expressions
--   
--   <ul>
--   <li>1.parameter re_a : first regular expression of alternative</li>
--   <li>2.parameter re_b : second regular expression of alternative</li>
--   <li>returns : new regular expression</li>
--   </ul>
re_alt :: RE a -> RE a -> RE a

-- | Constructs a regular expression for accepting any singel symbol
--   
--   <ul>
--   <li>returns : regular expression for accepting any singel symbol</li>
--   </ul>
re_dot :: RE a


-- | general usefull state monad for a local state and IO
--   
--   This module is used for threading a state and io actions through a
--   computation. Here the monad is constructed by hand. It could easily be
--   refactored with the use of the monad transformer library.
module Control.Monad.MonadStateIO
newtype StateIO state res
STIO :: (state -> IO (res, state)) -> StateIO state res
trans :: StateIO state res -> state -> IO (res, state)

-- | lift IO command to <a>StateIO</a>
io :: IO a -> StateIO state a

-- | state inspection command: a "show"-like function is applied to the
--   state and the result is written to stderr.
trcState :: (state -> String) -> StateIO state ()

-- | change the state with a given function and return the new state
changeState :: (state -> state) -> StateIO state state

-- | set the state
setState :: state -> StateIO state state

-- | read the state
getState :: StateIO state state

-- | run a <a>StateIO</a> command with an initial state
run :: state -> StateIO state res -> IO res
instance Monad (StateIO state)


-- | This module provides a Monad for an internal state and IO commands.
--   The state consists of two parts, the user state and the system state
--   user state ist a type parameter, the system state is a list name-value
--   pair. If the user state is not needed, the type parameter can be
--   instantiated with <tt>()</tt>.
--   
--   Furthermore there are types for Xml filter working on this monad and
--   functions for manipulating the state components and for lifting i/o
--   commands and XmlFilter to monad filters.
--   
--   Error reporting functions are also located in this module.
module Text.XML.HXT.DOM.XmlState

-- | The internal system state consists of a list of name-value pairs of
--   type <tt>(String, XmlTrees)</tt>, so arbitrary lists of trees can be
--   stored. For options, often only strings are used as values, so a set
--   of access functions with string values is available The error handling
--   method can be controlled by an error handler filter, the default
--   filter issues the errors on stderr
data SysState
SysState :: !SysStateAttrs -> !XmlStateFilter () -> SysState
sysStateAttrs :: SysState -> !SysStateAttrs
sysStateErrorHandler :: SysState -> !XmlStateFilter ()
type SysStateAttrs = AssocList String XmlTrees

-- | The State has a system and a user part the user state is a type
--   parameter
data XmlState state
XmlState :: !SysState -> !state -> XmlState state
sysState :: XmlState state -> !SysState
userState :: XmlState state -> !state

-- | The monad type for commands. It is an instance of <a>StateIO</a> from
--   the general module <a>Control.Monad.MonadStateIO</a>.
type XState state res = StateIO (XmlState state) res

-- | The <a>XmlFilter</a> type for filters working on a state
type XmlStateFilter state = XmlTree -> XState state XmlTrees

-- | change the user state
--   
--   <ul>
--   <li>1.parameter fct : the user state change function</li>
--   <li>returns : the new state</li>
--   </ul>
changeState :: (state -> state) -> XState state state

-- | set the user state.
--   
--   <ul>
--   <li>1.parameter s : the new state</li>
--   <li>returns : the new state</li>
--   </ul>
setState :: state -> XState state state

-- | read the user state
--   
--   <ul>
--   <li>returns : the current state</li>
--   </ul>
getState :: XState state state

-- | change the system part of the state.
--   
--   see also : <a>changeState</a>
changeSysState :: (SysState -> SysState) -> XState state SysState

-- | set the system part of the state.
--   
--   see also : <a>setState</a>
setSysState :: SysState -> XState state SysState

-- | read the system part of the state.
--   
--   see also : <a>getState</a>
getSysState :: XState state SysState

-- | the initial system state
--   
--   an empty list of attribute value pairs
initialSysState :: SysState

-- | change the attributes in the system state
changeSysStateAttrs :: (SysStateAttrs -> SysStateAttrs) -> (SysState -> SysState)

-- | set the error message handler
setSysErrorHandler :: XmlStateFilter () -> XState state ()

-- | get the error handler
getSysErrorHandler :: XState state (XmlStateFilter ())

-- | set or change a single system parameter.
--   
--   <ul>
--   <li>1.parameter name : the name of the parameter</li>
--   <li>2.parameter value : the list of associated trees</li>
--   <li>returns : nothing</li>
--   </ul>
--   
--   see also : <a>setSysParam</a>, <a>setSysParamInt</a>
setSysParamTree :: String -> XmlTrees -> XState state ()

-- | set or change a single system parameter of type string.
--   
--   <ul>
--   <li>1.parameter name : the name of the parameter</li>
--   <li>2.parameter value : the (new) string value</li>
--   <li>returns : nothing</li>
--   </ul>
--   
--   see also : <a>setSysParamTree</a>, setSysParamInt
setSysParam :: String -> String -> XState state ()

-- | set or change a single integer type system parameter
--   
--   see also : <a>setSysParam</a>
setSysParamInt :: String -> Int -> XState state ()

-- | add (or change) all attributes of the document root to the system
--   state - returns : this
setSystemParams :: XmlStateFilter state

-- | read a system parameter
--   
--   <ul>
--   <li>1.parameter name : the name of the parameter</li>
--   <li>returns : the list of tres associated with the key, or the empty
--   list for unknown parameters</li>
--   </ul>
getSysParamTree :: String -> XState state XmlTrees

-- | read a system string parameter
--   
--   <ul>
--   <li>1.parameter name : the name of the parameter</li>
--   <li>returns : the value, or the empty string for unknown
--   parameters</li>
--   </ul>
getSysParam :: String -> XState state String

-- | read a system parameter or return a default value
--   
--   <ul>
--   <li>1.parameter name : the name of the parameter</li>
--   <li>2.parameter default : the default value</li>
--   <li>returns : the value if found, else the default</li>
--   </ul>
getSysParamWithDefault :: String -> String -> XState state String

-- | read an integer system parameter
--   
--   <ul>
--   <li>1.parameter name :</li>
--   <li>2.parameter default :</li>
--   </ul>
--   
--   see also : <a>getSysParamWithDefault</a>
getSysParamInt :: String -> Int -> XState state Int

-- | exec a XState command with initial state.
--   
--   <ul>
--   <li>1.parameter initalState : the inital user state</li>
--   <li>2.parameter cmd : the command</li>
--   <li>returns : the i/o command with result and user state</li>
--   </ul>
run0 :: XmlState state -> XState state res -> IO (res, XmlState state)

-- | exec a XState command with initial user state. ignore final user
--   state. like run0, but ignore the resulting user state
run :: state -> XState state res -> IO res

-- | exec a XState command in th IO monad. like run with the empty state
--   ().
run' :: XState () res -> IO res

-- | run a command in a new user state. chain the system state part, init
--   new system state with the current one, run the command and update the
--   old system state with the resulting new system state
--   
--   <ul>
--   <li>1.parameter initialUserState : the initial user state</li>
--   <li>2.parameter cmd : the command</li>
--   <li>returns : the result of executing cmd and the final state</li>
--   </ul>
chain' :: state1 -> XState state1 res -> XState state0 (res, state1)

-- | like chain' but forget the final user state
--   
--   <ul>
--   <li>1.parameter initialUserState : the initial user state</li>
--   <li>2.parameter cmd : the command</li>
--   <li>returns : only the result of executing cmd</li>
--   </ul>
chain :: state1 -> XState state1 res -> XState state0 res

-- | lift a XmlFilter to a XmlStateFilter filter issue all error nodes as
--   error messages and remove the error nodes from the result
--   
--   <ul>
--   <li>1.parameter f : the filter</li>
--   <li>returns : the filter running in the state monad</li>
--   </ul>
--   
--   all errors are filtered from the result and issued on stderr
liftF :: XmlFilter -> XmlStateFilter state

-- | lift an I/O command
--   
--   <ul>
--   <li>1.parameter cmd : the i/o command</li>
--   <li>returns : the i/o command lifted to the XML state monad</li>
--   </ul>
io :: IO a -> XState state a

-- | set the trace level.
--   
--   convention:
--   
--   0: no trace output (default)
--   
--   1: trace important computation steps, e.g. accessing a document
--   
--   2: trace small computation steps
--   
--   3: output an intermediate result XmlTree in XML source format
--   
--   4: output an intermediate result XmlTree in tree representation
--   
--   <ul>
--   <li>1.parameter level : the trace level</li>
--   <li>returns : nothing</li>
--   </ul>
setTraceLevel :: Int -> XState state ()

-- | get the current trace level.
--   
--   <ul>
--   <li>returns : the current trace level</li>
--   </ul>
getTraceLevel :: XState state Int

-- | trace output for arbitray commands.
--   
--   <ul>
--   <li>1.parameter level : the trace level, for which the command will be
--   execuded if level &lt;= current trace level</li>
--   <li>2.parameter cmd : the command to be executed</li>
--   <li>returns : nothing</li>
--   </ul>
traceCmd :: Int -> XState state a -> XState state ()

-- | trace output function for simple text.
--   
--   <ul>
--   <li>1.parameter level : like in traceCmd</li>
--   <li>2.parameter str : the test</li>
--   <li>returns : nothing</li>
--   </ul>
trace :: Int -> String -> XState state ()

-- | trace output of the user part of the program state.
--   
--   <ul>
--   <li>1.parameter level : like in traceCmd</li>
--   <li>2.parameter showFct : the toString function</li>
--   <li>returns : nothing</li>
--   </ul>
traceState :: Int -> (state -> String) -> XState state ()

-- | filter to reset the state attribute <a>a_status</a> - returns : this
clearStatus :: XmlStateFilter state

-- | report an error message.
--   
--   <ul>
--   <li>returns : if the input tree n represents an error, <tt>res =
--   []</tt> and the error is processed by the errror handler filter
--   (default: error is issued on stderr) else <tt>res = [n]</tt></li>
--   </ul>
--   
--   see also : <a>issueErr</a>
issueError :: XmlStateFilter state
errorMsgHandler :: XmlStateFilter state

-- | set the error level in system state
setErrorMsgLevel :: XmlStateFilter state

-- | default error handler for writing errors to stderr
errorMsgToStderr :: XmlStateFilter state

-- | error message handler for collecting all error messages all messages
--   are stored under attribute <a>a_error_log</a> they can be read with
--   <tt>getSysParamTree a_error_log</tt> or by applying the filter
--   <a>getErrorMsg</a> to the root node
errorMsgLogging :: XmlStateFilter state
errorMsgLoggingAndToStderr :: XmlStateFilter state

-- | the filter for reading all collected error mesages
--   
--   result is the list of error messages, the input tree is ignored
getErrorMsg :: XmlStateFilter state

-- | error level translation <a>c_warn</a> (1) : warning, <a>c_err</a> (2):
--   error (e.g. parse error, validation error, ...), <a>c_fatal</a> (3) :
--   fatal error (document access error, internal error, ...)
errClass :: Int -> String

-- | short cut for issuing a warning
--   
--   see also : <a>issueError</a>, <a>issueErr</a>
issueWarn :: String -> XmlStateFilter state

-- | short cut for issuing an error
--   
--   see also : <a>issueError</a>
issueErr :: String -> XmlStateFilter state

-- | short cut for issuing a fatal error
--   
--   see also : <a>issueError</a>, <a>issueErr</a>
issueFatal :: String -> XmlStateFilter state
addFatal :: String -> XmlStateFilter state

-- | checks the value of the attribute <a>a_status</a> in a document root.
--   if it contains a value greater or equal to <a>c_err</a>, an error with
--   error message stored in attribute <a>a_module</a> is issued and the
--   filter acts as the <a>noneM</a> filter else its the <a>thisM</a>
--   filter
checkStatus :: XmlStateFilter state

-- | add the error level and the module where the error occured to the
--   attributes of a document root node and remove the children when level
--   is greater or equal to <a>c_err</a>
setStatus :: Int -> String -> XmlFilter

-- | check whether tree is a document root and the status attribute has a
--   value less than <a>c_err</a>
statusOk :: XmlFilter

-- | check whether the error level attribute in the system state is set to
--   error, in this case the children of the document root are removed and
--   error info is added as attributes with <a>setStatus</a> else nothing
--   is changed
checkResult :: String -> XmlStateFilter state

-- | monadic filter for processing the attribute list of a tag. for other
--   trees this filter acts like <a>noneM</a>
--   
--   see also : <a>processAttr</a>, <a>processAttrl</a>
processAttrM :: XmlStateFilter a -> XmlStateFilter a


-- | output functions implemented as filer
module Text.XML.HXT.Parser.XmlOutput

-- | document output for standard output
--   
--   see also : <a>hPutXmlDoc</a>
putXmlDoc :: XmlStateFilter a

-- | document output on a given file name
--   
--   Result is the input document
--   
--   see also : <a>hPutXmlDoc</a>, <a>putXmlDoc</a>
putXmlDocToFile :: String -> XmlStateFilter a
putXmlTree :: XmlStateFilter a
putXmlSource :: XmlStateFilter a

-- | document output for arbitrary files.
--   
--   Result is the input document
hPutXmlDoc :: Handle -> XmlStateFilter a

-- | output of tree representation for trace
hPutXmlTree :: Handle -> XmlStateFilter a

-- | output of text representation for trace
hPutXmlSource :: Handle -> XmlStateFilter a
traceF :: Int -> XmlStateFilter a -> XmlStateFilter a
traceMsg :: Int -> String -> XmlStateFilter a
traceTree :: XmlStateFilter a
traceSource :: XmlStateFilter a


-- | main namespace filter for propagation, checking, tracing and error
--   handling
module Text.XML.HXT.DOM.Namespace

-- | propagate all namespace declarations, check namespace constraints and
--   issue errors. If no error was found, result is the unchanged input
--   tree, else the root node "/" with an empty document is returned.
--   
--   see also : <a>propagateNamespaces</a>, <a>validateNamespaces</a>
propagateAndValidateNamespaces :: XmlStateFilter a


-- | DOM data types and functions
--   
--   export of all basic datatypes and functions of the toolbox DOM.
module Text.XML.HXT.DOM


-- | Xml Parser: the main parse filter
module Text.XML.HXT.Parser.XmlParser

-- | The monadic parser for a whole document. input must be a root node
--   with a single text child. Error messages are issued and global error
--   state is set.
parseXmlDoc :: XmlStateFilter a

-- | Filter for substitution of all occurences of the predefined XML
--   entites quot, amp, lt, gt, apos by equivalent character references
substXmlEntities :: XmlFilter


-- | This module provides functions for validating attributes.
module Text.XML.HXT.Validator.AttributeValueValidation

-- | Checks if the attribute value meets the lexical constraints of its
--   type.
--   
--   <ul>
--   <li>1.parameter dtdPart : the children of the <tt>DOCTYPE</tt>
--   node</li>
--   <li>2.parameter attrDecl : the declaration of the attribute from the
--   DTD</li>
--   <li>returns : a function which takes an element (XTag or XDTD
--   ATTLIST), checks if the attribute value meets the lexical constraints
--   of its type and returns a list of errors</li>
--   </ul>
checkAttributeValue :: XmlTrees -> XmlTree -> XmlFilter

-- | Normalizes an attribute value with respect to its type. (3.3.3 / p.29
--   in Spec)
--   
--   <ul>
--   <li>1.parameter attrDecl : the declaration of the attribute from the
--   DTD. Expected is a list. If the list is empty, no declaration
--   exists.</li>
--   <li>2.parameter value : the attribute value to be normalized</li>
--   <li>returns : the normalized value</li>
--   </ul>
normalizeAttributeValue :: Maybe XmlTree -> String -> String


-- | This module provides functions for validating the DTD of XML documents
--   represented as XmlTree.
module Text.XML.HXT.Validator.DTDValidation

-- | Removes doublicate declarations from the DTD, which first declaration
--   is binding. This is the case for ATTLIST and ENTITY declarations.
--   
--   <ul>
--   <li>returns : A function that replaces the children of DOCTYPE nodes
--   by a list where all multiple declarations are removed.</li>
--   </ul>
removeDoublicateDefs :: XmlFilter

-- | Validate a DTD.
--   
--   <ul>
--   <li>returns : a functions which takes the DTD subset of the XmlTree,
--   checks if the DTD is valid and returns a list of errors</li>
--   </ul>
validateDTD :: XmlFilter


-- | This module provides functions for transforming XML documents
--   represented as XmlTree with respect to its DTD.
module Text.XML.HXT.Validator.DocTransformation

-- | filter for transforming the document.
--   
--   <ul>
--   <li>1.parameter dtdPart : the DTD subset (Node <tt>DOCTYPE</tt>) of
--   the XmlTree</li>
--   <li>2.parameter doc : the document subset of the XmlTree</li>
--   <li>returns : a list of errors</li>
--   </ul>
transform :: XmlTree -> XmlTree -> XmlTrees


-- | This module provides functions for validating XML Documents
--   represented as XmlTree.
module Text.XML.HXT.Validator.DocValidation

-- | Validate a document.
--   
--   <ul>
--   <li>1.parameter dtdPart : the DTD subset (Node <tt>DOCTYPE</tt>) of
--   the XmlTree</li>
--   <li>2.parameter doc : the document subset of the XmlTree</li>
--   <li>returns : a list of errors</li>
--   </ul>
validateDoc :: XmlTree -> XmlTree -> XmlTrees


-- | This module provides functions for checking special
--   ID<i>IDREF</i>IDREFS constraints.
module Text.XML.HXT.Validator.IdValidation

-- | Perform the validation of the ID<i>IDREF</i>IDREFS constraints.
--   
--   <ul>
--   <li>1.parameter dtdPart : the DTD subset (Node <tt>DOCTYPE</tt>) of
--   the XmlTree</li>
--   <li>2.parameter doc : the document subset of the XmlTree</li>
--   <li>returns : a list of errors</li>
--   </ul>
validateIds :: XmlTree -> XmlTree -> XmlTrees


-- | This module provides functions for validating XML documents
--   represented as XmlTree.
module Text.XML.HXT.Validator.ValidationFilter
getDTDSubset :: XmlFilter

-- | Main validation filter. Check if the DTD and the document are valid.
--   
--   <ul>
--   <li>returns : a function which expects a complete document as XmlTree
--   input and returns a list of all errors found.</li>
--   </ul>
validate :: XmlFilter

-- | Check if the DTD is valid.
--   
--   <ul>
--   <li>returns : a function which expects an XmlTree from the parser as
--   input and returns a list of all errors found in the DTD.</li>
--   </ul>
validateDTD :: XmlFilter

-- | Check if the document corresponds to the given DTD.
--   
--   <ul>
--   <li>returns : a function which expects a complete document as XmlTree
--   input and returns a list of all errors found in the content part.</li>
--   </ul>
validateDoc :: XmlFilter

-- | Removes doublicate declarations from the DTD which first declaration
--   is binding. This is the case for ATTLIST and ENTITY declarations.
--   
--   <ul>
--   <li>returns : A function that replaces the children of DOCTYPE nodes
--   by a list where all multiple declarations are removed.</li>
--   </ul>
removeDoublicateDefs :: XmlFilter

-- | filter for transforming a document with respect to the given DTD.
--   
--   Validating parsers are expected to normalize attribute values and add
--   default values. This function should be called after a successful
--   validation.
--   
--   <ul>
--   <li>returns : a function which expects a complete XML document tree
--   and returns the transformed XmlTree</li>
--   </ul>
transform :: XmlFilter


-- | This module provides a state filter as a main function for validating
--   XML documents.
--   
--   The real validation is done with pure filters from module
--   <tt>Text.XML.HXT.Validator.ValidationFilter</tt>
--   
--   Author : .\artin Schmidt
module Text.XML.HXT.Validator.Validation

-- | monadic filter for validating and transforming a wellformed document.
--   
--   the <a>main</a> function for validation.
--   
--   the input tree must consist of a root node with a complete document
--   and DTD. Result is the single element list containing same tree but
--   tranformed with respect to the DTD, or, in case of errors, the root
--   with an empty list of children
getValidatedDoc :: XmlStateFilter state

module Text.XML.HXT.Parser.DefaultURI
setDefaultURI :: XState state ()

module Text.XML.HXT.Parser.ProtocolHandlerFile
getFileContents :: URI -> XmlStateFilter a

module Text.XML.HXT.Parser.ProtocolHandlerHttpCurl
getHttpContentsWithCurl :: URI -> XmlStateFilter a

module Text.XML.HXT.Parser.ProtocolHandlerHttpNative
getHttpContentsWithHttp :: URI -> XmlStateFilter a

module Text.XML.HXT.Parser.ProtocolHandlerHttpNativeOrCurl
getHttpContentsNativeOrWithCurl :: URI -> XmlStateFilter a

module Text.XML.HXT.Parser.ProtocolHandler
getProtocolHandler :: String -> (URI -> XmlStateFilter a)

module Text.XML.HXT.Parser.XmlInput

-- | filter for reading the content of a XML document
--   
--   input is a root node with the source as an attibute the text is read,
--   the encoding scheme is parsed and selected and the input is translated
--   into the internal UTF-8 string representation
getXmlContents :: XmlStateFilter a

-- | filter for reading the content of an external XML entity
--   
--   see also : <a>getXmlContents</a>
getXmlEntityContents :: XmlStateFilter a

-- | the hard io operations
--   
--   for reading a file or accessing a document via http input must be a
--   root node with a <tt>source</tt> attribute specifying the URI
getUrlContents :: XmlStateFilter a

-- | compute the length of the data for a document read previously by a
--   call of 'getUrlContents. The result is stored as an attribute value in
--   the document root node. the attribute name is <a>a_contentLength</a>
getContentLength :: XmlFilter

-- | guessEncoding uses encoding attribute and content to determine the
--   encoding scheme.
--   
--   it's assumed that an encoding spec has been tried to parse before
--   guessing the encoding.
--   
--   UTF-8 is the default encoding
--   
--   other supported encodings are ISO-8859-1 (also known as ISO-Latin-1),
--   US-ASCII, UTF-16 or ISO-10646-UCS-2, UTF-16BE, UTF-16LE
guessDocEncoding :: XmlStateFilter a

-- | filter command for saving and restoring the base URI
--   
--   <ul>
--   <li>1.parameter f : the filter that possible changes the base URI</li>
--   <li>returns : a filter with the same effect as f, that restores the
--   base URI after application of f</li>
--   </ul>
runInLocalURIContext :: XmlStateFilter a -> XmlStateFilter a

-- | filter command for running an action in a new URI context
runInNewURIContext :: String -> XmlStateFilter a -> XmlStateFilter a

-- | read the current base URI
--   
--   see also : <a>setBaseURI</a>
getBaseURI :: XState state String

-- | set the base URI, all other URIs are handled relative to this base URI
--   
--   the default base URI is <tt>file:///&lt;current-working-dir&gt;/</tt>
--   
--   see also : <a>getBaseURI</a>
setBaseURI :: String -> XState state ()

-- | transform an URI into an absolut URI using the current base URI
--   
--   <ul>
--   <li>1.parameter uri : the URI as string</li>
--   <li>returns : the absolut URI as string or "" in case of an error</li>
--   </ul>
getAbsolutURI :: String -> XState state String

-- | predicate for testing the standalone document attribute
isStandaloneDocument :: XState state Bool


-- | This parser tries to interprete everything as HTML no errors are
--   emitted during parsing. If something looks weired, warning messages
--   are inserted in the document tree.
--   
--   Module contains state filter for easy parsing and error handling real
--   work is done in <tt>Text.XML.HXT.Parser.HtmlParsec</tt>
module Text.XML.HXT.Parser.HtmlParser

-- | read a document and parse it with <a>parseHtmlDoc</a>. The main entry
--   point of this module
--   
--   The input tree must be a root tree like in '
--   Text.XML.HXT.Parser.MainFunctions.getXmlDoc'. The content is read with
--   <a>getXmlContents</a>, is parsed with <a>parseHtmlDoc</a> and
--   canonicalized (char refs are substituted in content and attributes,
--   but comment is preserved)
--   
--   see also : <tt>Text.XML.HXT.Parser.DTDProcessing.getWellformedDoc</tt>
getHtmlDoc :: XmlStateFilter state

-- | The HTML parsing filter
--   
--   The input is parsed with <a>runHtmlParser</a>, everything is
--   interpreted as HTML, if errors ocuur, the parser will try to do some
--   meaningfull action and continues parsing. Afterwards the entitiy
--   references for defined for XHTML are resovled, any unresolved
--   reference is transformed into plain text.
--   
--   Error messages during parsing and entity resolving are added as
--   warning nodes into the resulting tree.
--   
--   The warnings are issued, if the 1. parameter noWarnings is set to
--   True, afterwards all are removed from the resulting tree.
parseHtmlDoc :: XmlStateFilter a

-- | The pure HTML parser, usually called via <a>parseHtmlDoc</a>.
runHtmlParser :: XmlStateFilter a
substHtmlEntities :: XmlTree -> XmlTrees


-- | DTD processing function for including external parts of a DTD
--   parameter entity substitution and general entity substitution
module Text.XML.HXT.Parser.DTDProcessing

-- | monadic filter for reading, parsing and checking a wellformed
--   document. the input tree must consist of a root node with a source
--   attribute in its attribute list.
--   
--   All attributes from the document root are copied into the system
--   state, and may be queried by the monadic filters, e.g. trace options.
--   
--   Result is the single element list containing the well-formed document
--   tree or, in case of errors, the document root with an empty list as
--   children and attributes <a>a_status</a> and <a>a_module</a> for error
--   level and the module, where the error occured.
--   
--   this is a shortcut for <a>getXmlContents</a> .&gt;&gt;
--   <a>checkWellformedDoc</a>
--   
--   example for a main program:
--   
--   <pre>
--   main =
--     run' $
--     do
--     res  &lt;- getWellformedDoc $ newDocument "myfile.xml"
--     ...
--   </pre>
getWellformedDoc :: XmlStateFilter state

-- | parses a text node with <a>parseXmlDoc</a>, processes the DTD and
--   general entities and transforms all char references into characters
checkWellformedDoc :: XmlStateFilter state

-- | a filter for DTD processing
--   
--   inclusion of external parts of DTD, parameter entity substitution
--   conditional section evaluation
--   
--   input tree must represent a complete document including root node
processDTD :: XmlStateFilter a

-- | substitution of general entities
--   
--   input: a complete document tree including root node
processGeneralEntities :: XmlStateFilter a
instance Eq DTDPart


-- | Simple parse functions.
--   
--   the main building blocks for an application. this module exports
--   complex filters and functions for common tasks for input and parsing,
--   output and option handling.
module Text.XML.HXT.Parser.MainFunctions

-- | convenient function for reading a XML document without dealing with
--   state monads, error messages collection and other details
--   
--   getXmlDocument calls <a>parseDocument</a> with the list of parsing
--   options and an url or filename as document source.
--   
--   result is a triple
--   
--   <ul>
--   <li>the resulting document tree with a root node containing all meta
--   info about the document (options, status info, http header, ...)</li>
--   <li>the list of errors and warnings</li>
--   <li>the error level: one of <a>c_ok</a>, <a>c_warn</a>, <a>c_err</a>,
--   <a>c_fatal</a></li>
--   </ul>
--   
--   example for input (see also example in <a>putXmlDocument</a> and
--   example in <a>writeDocument</a>)
--   
--   <pre>
--   main :: IO ()
--   main
--     = do
--       (res, errs, rc) &lt;- getXmlDocument [] "test.xml"
--       if rc &gt;= c_err
--         then issueErrors errs
--         else processTree res
--   
--   issueErrors :: XmlTrees -&gt; IO ()
--   
--   processTree :: XmlTree  -&gt; IO ()
--   </pre>
--   
--   for options see <a>parseDocument</a>, <a>a_collect_errors</a> is set
--   implicitly
getXmlDocument :: Attributes -> String -> IO (XmlTree, XmlTrees, Int)

-- | the inverse operation to <a>getXmlDocument</a>
--   
--   writes a complete document tree to a file, writing can be controlled
--   by options, the real work is done with filter <a>writeDocument</a>.
--   useful options are the options of <a>writeDocument</a>.
--   
--   result is a pair: 1.part is a list of error messages, 2. part is the
--   return code, the status info of the write filter
--   
--   this filter is useful, when processing XML in an arbitray context in
--   the IO monad
--   
--   an example main program for such an application is:
--   
--   <pre>
--   main :: IO ()
--   main
--     = do
--       (input, readErrs, rc) &lt;- getXmlDocument [...] "test.xml"
--       if rc &gt;= c_err
--         then issueErrors readErrs
--         else processTree input
--   
--   processTree :: XmlTree -&gt; IO ()
--   processTree t
--     = let res = computeNewTree input
--       in do
--          (writeErrs, rc2) &lt;- putXmlDocument [...] "out.xml" res
--          if rc2 &gt;= c_err
--            then issueErrors writeErrs
--            else return ()
--   
--   issueErrors :: XmlTrees -&gt; IO ()
--   
--   computeNewTree :: XmlTree -&gt; XmlTree
--   </pre>
putXmlDocument :: Attributes -> String -> XmlTree -> IO (XmlTrees, Int)

-- | the main parsing filter
--   
--   this filter can be configured by an option list, a list of option
--   name, option value pairs. the input tree must be a possibly empty
--   document root tree. all the options are stored as attributes in this
--   root node to control processing.
--   
--   available options:
--   
--   <ul>
--   <li><a>a_parse_html</a>: use HTML parser, else use XML parser
--   (default)</li>
--   <li><a>a_validate</a> : validate document (default), else skip
--   validation</li>
--   <li><a>a_check_namespaces</a> : check namespaces, else skip namespace
--   processing (default)</li>
--   <li><a>a_canonicalize</a> : canonicalize document (default), else skip
--   canonicalization</li>
--   <li><a>a_preserve_comment</a> : preserve comments during
--   canonicalization, else remove comments (default)</li>
--   <li><a>a_remove_whitespace</a> : remove all whitespace, used for
--   document indentation, else skip this step (default)</li>
--   <li><a>a_indent</a> : indent document by inserting whitespace, else
--   skip this step (default)</li>
--   <li><a>a_issue_warnings</a> : issue warnings, when parsing HTML
--   (default), else ignore HTML parser warnings</li>
--   <li><a>a_issue_errors</a> : issue all error messages on stderr
--   (default), or ignore all error messages</li>
--   <li><a>a_collect_errors</a> : all error messages are collected during
--   processing and appended to the result document for further processing
--   within the calling modules</li>
--   <li><a>a_trace</a> : trace level: values: 0 -4</li>
--   <li><a>a_proxy</a> : proxy for http access, e.g. www-cache:3128</li>
--   <li><a>a_use_curl</a> : for http access via external programm curl,
--   default is native HTTP access</li>
--   <li><a>a_options_curl</a> : more options for external program
--   curl</li>
--   <li><a>a_source</a> : the document source url</li>
--   <li><a>a_encoding</a> : default document encoding (<a>utf8</a>,
--   <a>isoLatin1</a>, <a>usAscii</a>, ...)</li>
--   </ul>
--   
--   examples:
--   
--   <pre>
--   parseDocument [ (a_source,   "test.xml")
--                 , (a_validate, "0")
--                 , (a_encoding, isoLatin1)
--                 ] emptyRoot
--   </pre>
--   
--   reads document "test.xml" without validation and default encoding
--   <a>isoLatin1</a>
--   
--   <pre>
--   parseDocument [ (a_source,         "http://www.haskell.org/")
--                 , (a_parse_html,     "1")
--                 , (a_proxy,          "www-cache:3128")
--                 , (a_curl,           "1")
--                 , (a_issue_warnings, "0")
--                 ] emptyRoot
--   </pre>
--   
--   reads Haskell homepage with HTML parser ignoring any warnings and with
--   http access via external program curl and proxy "www-cache" at port
--   3128
--   
--   <pre>
--   parseDocument [ (a_source,            "http://www.w3c.org/")
--                 , (a_parse_html,        "0")                       -- default
--                 , (a_validate,          "1")                       -- default
--                 , (a_check_namespace,   "1")
--                 , (a_remove_whitespace, "1")
--                 , (a_trace,             "2")
--                 ] emptyRoot
--   </pre>
--   
--   read w3c home page, validate and chech namespaces, remove whitespace
--   between tags, trace activities with level 2
--   
--   <pre>
--   parseDocument [ (a_source,   "test.xml")
--                 , (a_validate,        "1")
--                 , (a_check_namespace, "1")
--                 , (a_collect_errors,  "1")
--                 , (a_issue_errors,    "0")
--                 ] emptyRoot
--   </pre>
--   
--   reads file "test.xml", validates it, checks namespaces, does not issue
--   any erros but collects errors and appends the list of errors to the
--   single element list for the document. this enables the calling
--   application to define own error handlers.
parseDocument :: Attributes -> XmlStateFilter state

-- | the main filter for writing documents
--   
--   this filter can be configured by an option list like
--   <a>getXmlDocument</a>
--   
--   available options are
--   
--   <ul>
--   <li><a>a_indent</a> : indent document for readability, (default: no
--   indentation)</li>
--   <li><a>a_remove_whitespace</a> : remove all redundant whitespace for
--   shorten text (default: no removal)</li>
--   <li><a>a_output_file</a> : destination file for document, default is
--   "-" for stdout</li>
--   <li><a>a_output_encoding</a> : encoding of document, default is
--   <a>a_encoding</a> or <a>utf8</a></li>
--   <li><a>a_output_xml</a> : (default) issue XML: quote special XML chars
--   &gt;,&lt;,",',&amp; add XML processing instruction and encode document
--   with respect to <a>a_output_encoding</a>, if explizitly switched of,
--   the plain text is issued, this is useful for non XML output, e.g.
--   generated Haskell code, LaTex, Java, ...</li>
--   <li><a>a_show_tree</a> : show tree representation of document (for
--   debugging)</li>
--   <li><a>a_show_haskell</a> : show Haskell representaion of document
--   (for debugging)</li>
--   <li><a>a_issue_errors</a>, <a>a_collect_errors</a> : see
--   <a>parseDocument</a></li>
--   </ul>
--   
--   a typical main program running in the XmlState monad has the following
--   structure:
--   
--   <pre>
--   main :: IO ()
--   main
--       = do
--         argv &lt;- getArgs                                              -- get the commandline arguments
--         (inp, outp, options) &lt;- cmdlineOpts argv                     -- and evaluate them, return a key-value list
--                                                                      -- and input and output
--         res  &lt;- run' $ application inp outp options $ emptyRoot      -- run the application
--   
--         exitWith (if null res
--                   then ExitFailure (-1)
--                   else exitSuccess
--                  )
--   
--   application :: String -&gt; String -&gt; Attributes -&gt; XmlStateFilter ()
--   application inp outp al
--     = parseDocument (al ++ [(a_source, inp)])                        -- set options and source
--       .&gt;&gt;                                                            -- and parse document
--       processDocument                                                -- the hard work
--       .&gt;&gt;
--       writeDocument [(a_output_file, outp)]                          -- issue results
--       .&gt;&gt;
--       checkStatus                                                    -- check errors
--   </pre>
writeDocument :: Attributes -> XmlStateFilter state


-- | Simple parse functions.
--   
--   the <a>main</a> building blocks for an application. this module
--   exports all important functions for parsing, validating and
--   transforming XML. it also exports all basic datatypes and functions of
--   the toolbox.
module Text.XML.HXT.Parser
