-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monad transformers and classes
--   
@package ether
@version 0.3.0.0


-- | Template Haskell utilities.
module Control.Ether.TH

-- | Creates a tag and a value-level proxy for it.
--   
--   <tt><a>ethereal</a> "Foo" "foo"</tt> generates the following code:
--   
--   <pre>
--   data Foo
--   foo :: Proxy Foo
--   foo = Proxy
--   </pre>
ethereal :: String -> String -> DecsQ


-- | Type-level machinery for tag manipulation.
module Control.Ether.Tagged

-- | The <a>Taggable</a> class defines the type families to manage tags in
--   monad transformer stacks. Its kind is restricted to <tt>* -&gt; *</tt>
--   to prevent incorrect instances.
class Taggable (m :: * -> *) where type family Tag m :: Maybe * type family Inner m :: Maybe (* -> *) type instance Tag m = Nothing type instance Inner m = Nothing

-- | The <a>Tagged</a> type class establishes a relationship between a
--   tagged monad transformer and its untagged counterpart.
class (Taggable m, Tag m ~ Just tag) => Tagged m tag | m -> tag where type family Untagged m :: * -> * tagged _ = pack untagged _ = unpack
tagged :: Tagged m tag => proxy tag -> Untagged m a -> m a
untagged :: Tagged m tag => proxy tag -> m a -> Untagged m a

-- | The <a>Tags</a> type function returns a type-level list of all tags in
--   a monad transformer stack. Requires <a>Taggable</a> instances.
type Tags (m :: * -> *) = MaybeToList (Tag m) ++ ListMapTag (Inners m)

-- | The <a>Inners</a> type function recursively applies <a>Inner</a> and
--   returns the results in a type-level list.
type Inners m = Inners' (Inner m)

-- | The main purpose of the <a>UniqueTag</a> class is to provide clear
--   error messages when the tag uniqueness property is violated. You
--   should never write instances for it unless you know what you're doing.
class UniqueTag a

-- | The <a>UniqueTags</a> constraint placed on a type variable
--   representing a monad transformer stack ensures that every tag in the
--   stack appears only once.

-- | Type-restricted version of <a>id</a> that adds a <a>UniqueTags</a>
--   constraint to the provided monadic value.
ensureUniqueTags :: UniqueTags m => m a -> m a
instance Taggable (WriterT w m)
instance Taggable (WriterT w m)
instance Taggable (StateT s m)
instance Taggable (StateT s m)
instance Taggable (ReaderT r m)
instance Taggable (MaybeT m)
instance Taggable (ListT m)
instance Taggable (IdentityT m)
instance Taggable (ExceptT e m)
instance Taggable (ContT r m)
instance Taggable (ST s)
instance Taggable (ST s)
instance Taggable Proxy
instance Taggable (Either e)
instance Taggable STM
instance Taggable ((->) r)
instance Taggable First
instance Taggable Last
instance Taggable Maybe
instance Taggable Identity
instance Taggable IO


-- | See <a>Control.Monad.Trans.Reader</a>.
module Control.Monad.Trans.Ether.Reader

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <a>&gt;&gt;=</a> passes the inherited environment to both
--   subcomputations.
type Reader tag r = ReaderT tag r Identity

-- | Constructor for computations in the reader monad (the inverse of
--   <a>runReader</a>).
reader :: Monad m => proxy tag -> (r -> a) -> ReaderT tag r m a

-- | Runs a <a>ReaderT</a> with the given environment and returns the vinal
--   value.
runReader :: proxy tag -> Reader tag r a -> r -> a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <a>&gt;&gt;=</a> passes the inherited environment to both
--   subcomputations.
data ReaderT tag r m a

-- | Constructor for computations in the reader monad transformer.
readerT :: proxy tag -> (r -> m a) -> ReaderT tag r m a

-- | Runs a <a>ReaderT</a> with the given environment and returns the vinal
--   value.
runReaderT :: proxy tag -> ReaderT tag r m a -> r -> m a

-- | Fetch the value of the environment.
ask :: Monad m => proxy tag -> ReaderT tag r m r

-- | Execute a computation in a modified environment (a specialization of
--   <tt>withReaderT</tt>).
--   
--   <ul>
--   <li><pre><a>runReaderT</a> tag (<a>local</a> tag f m) =
--   <a>runReaderT</a> tag m . f</pre></li>
--   </ul>
local :: proxy tag -> (r -> r) -> ReaderT tag r m a -> ReaderT tag r m a
instance Generic (ReaderT tag r m a)
instance Functor m => Functor (ReaderT tag r m)
instance Applicative m => Applicative (ReaderT tag r m)
instance Alternative m => Alternative (ReaderT tag r m)
instance Monad m => Monad (ReaderT tag r m)
instance MonadPlus m => MonadPlus (ReaderT tag r m)
instance MonadFix m => MonadFix (ReaderT tag r m)
instance MonadTrans (ReaderT tag r)
instance MonadIO m => MonadIO (ReaderT tag r m)
instance MFunctor (ReaderT tag r)
instance MMonad (ReaderT tag r)
instance Datatype D1ReaderT
instance Constructor C1_0ReaderT
instance MonadError e m => MonadError e (ReaderT tag r m)
instance MonadWriter w m => MonadWriter w (ReaderT tag r m)
instance MonadState s m => MonadState s (ReaderT tag r m)
instance MonadReader r' m => MonadReader r' (ReaderT tag r m)
instance MonadCont m => MonadCont (ReaderT tag r m)
instance Tagged (ReaderT tag r m) tag
instance Taggable (ReaderT tag r m)
instance LiftCallCC (ReaderT tag r)
instance LiftPass (ReaderT tag r)
instance LiftListen (ReaderT tag r)
instance LiftCatch (ReaderT tag r)
instance LiftLocal (ReaderT tag r)
instance MonadBaseControl b m => MonadBaseControl b (ReaderT tag r m)
instance MonadTransControl (ReaderT tag r)
instance MonadBase b m => MonadBase b (ReaderT tag r m)
instance Newtype (ReaderT tag r m a)


-- | See <a>Control.Monad.Reader.Class</a>.
module Control.Monad.Ether.Reader.Class

-- | See <a>MonadReader</a>.
class Monad m => MonadReader tag r m | m tag -> r where ask t = reader t id reader t f = fmap f (ask t)
ask :: MonadReader tag r m => proxy tag -> m r
local :: MonadReader tag r m => proxy tag -> (r -> r) -> m a -> m a
reader :: MonadReader tag r m => proxy tag -> (r -> a) -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader tag r m => proxy tag -> (r -> a) -> m a
instance [overlap ok] (LiftLocal t, Monad (t m), MonadReader tag r m) => MonadReader tag r (t m)
instance [overlap ok] Monad m => MonadReader tag r (ReaderT tag r m)


-- | See <a>Control.Monad.Reader</a>.
module Control.Monad.Ether.Reader

-- | See <a>MonadReader</a>.
class Monad m => MonadReader tag r m | m tag -> r where ask t = reader t id reader t f = fmap f (ask t)
ask :: MonadReader tag r m => proxy tag -> m r
local :: MonadReader tag r m => proxy tag -> (r -> r) -> m a -> m a
reader :: MonadReader tag r m => proxy tag -> (r -> a) -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader tag r m => proxy tag -> (r -> a) -> m a

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <a>&gt;&gt;=</a> passes the inherited environment to both
--   subcomputations.
type Reader tag r = ReaderT tag r Identity

-- | Runs a <a>ReaderT</a> with the given environment and returns the vinal
--   value.
runReader :: proxy tag -> Reader tag r a -> r -> a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <a>&gt;&gt;=</a> passes the inherited environment to both
--   subcomputations.
data ReaderT tag r m a

-- | Constructor for computations in the reader monad transformer.
readerT :: proxy tag -> (r -> m a) -> ReaderT tag r m a

-- | Runs a <a>ReaderT</a> with the given environment and returns the vinal
--   value.
runReaderT :: proxy tag -> ReaderT tag r m a -> r -> m a


-- | See <a>Control.Monad.Ether.Reader</a>.
module Control.Monad.Ether.Implicit.Reader

-- | See <a>MonadReader</a>.
type MonadReader r = MonadReader r r

-- | See <a>local</a>.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | See <a>ask</a>.
ask :: MonadReader r m => m r

-- | See <a>reader</a>.
reader :: MonadReader r m => (r -> a) -> m a

-- | See <a>asks</a>.
asks :: MonadReader r m => (r -> a) -> m a

-- | See <a>Reader</a>.
type Reader r = Reader r r

-- | See <a>runReader</a>.
runReader :: Reader r a -> r -> a

-- | See <a>ReaderT</a>.
type ReaderT r = ReaderT r r

-- | See <a>readerT</a>.
readerT :: (r -> m a) -> ReaderT r m a

-- | See <a>runReaderT</a>.
runReaderT :: ReaderT r m a -> r -> m a


-- | See <a>Control.Monad.Trans.Writer</a>.
module Control.Monad.Trans.Ether.Writer

-- | The parametrizable writer monad.
--   
--   Computations can accumulate a monoid value.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <a>&gt;&gt;=</a> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer tag w = WriterT tag w Identity

-- | Constructor for computations in the writer monad (the inverse of
--   <a>runWriter</a>).
writer :: Monad m => proxy tag -> (a, w) -> WriterT tag w m a

-- | Runs a <a>Writer</a> and returns both the normal value and the final
--   accumulator.
runWriter :: proxy tag -> Writer tag w a -> (a, w)

-- | Runs a <a>Writer</a> and returns the final accumulator, discarding the
--   normal value.
execWriter :: proxy tag -> Writer tag w a -> w

-- | The writer monad transformer.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <a>&gt;&gt;=</a> combines the outputs of the subcomputations using
--   <a>mappend</a>.
data WriterT tag w m a

-- | Constructor for computations in the writer monad transformer.
writerT :: proxy tag -> m (a, w) -> WriterT tag w m a

-- | Runs a <a>WriterT</a> and returns both the normal value and the final
--   accumulator.
runWriterT :: proxy tag -> WriterT tag w m a -> m (a, w)

-- | Runs a <a>WriterT</a> and returns the final accumulator, discarding
--   the normal value.
execWriterT :: Monad m => proxy tag -> WriterT tag w m a -> m w

-- | Appends a value to the accumulator within the monad.
tell :: Monad m => proxy tag -> w -> WriterT tag w m ()

-- | Executes an action and adds its accumulator to the value of the
--   computation.
listen :: (Monoid w, Monad m) => proxy tag -> WriterT tag w m a -> WriterT tag w m (a, w)

-- | Executes an action which returns a value and a function, and returns
--   the value, applying the function to the accumulator.
pass :: (Monoid w, Monad m) => proxy tag -> WriterT tag w m (a, w -> w) -> WriterT tag w m a
instance Generic (WriterT tag w m a)
instance Functor m => Functor (WriterT tag w m)
instance (Applicative m, Monoid w) => Applicative (WriterT tag w m)
instance (Alternative m, Monoid w) => Alternative (WriterT tag w m)
instance (Monad m, Monoid w) => Monad (WriterT tag w m)
instance (MonadPlus m, Monoid w) => MonadPlus (WriterT tag w m)
instance (MonadFix m, Monoid w) => MonadFix (WriterT tag w m)
instance Monoid w => MonadTrans (WriterT tag w)
instance (Monoid w, MonadIO m) => MonadIO (WriterT tag w m)
instance MFunctor (WriterT tag w)
instance Monoid w => MMonad (WriterT tag w)
instance Datatype D1WriterT
instance Constructor C1_0WriterT
instance (Monoid w, MonadError e m) => MonadError e (WriterT tag w m)
instance (Monoid w, MonadWriter w' m) => MonadWriter w' (WriterT tag w m)
instance (Monoid w, MonadState s m) => MonadState s (WriterT tag w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT tag w m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT tag w m)
instance Tagged (WriterT tag w m) tag
instance Taggable (WriterT tag w m)
instance Monoid w => LiftCallCC (WriterT tag w)
instance Monoid w' => LiftPass (WriterT tag w')
instance Monoid w => LiftListen (WriterT tag w)
instance Monoid w => LiftCatch (WriterT tag w)
instance Monoid w => LiftLocal (WriterT tag w)
instance (Monoid w, MonadBaseControl b m) => MonadBaseControl b (WriterT tag w m)
instance Monoid w => MonadTransControl (WriterT tag w)
instance (Monoid w, MonadBase b m) => MonadBase b (WriterT tag w m)
instance Newtype (WriterT tag w m a)


-- | See <a>Control.Monad.Writer.Class</a>.
module Control.Monad.Ether.Writer.Class

-- | See <a>MonadWriter</a>.
class (Monoid w, Monad m) => MonadWriter tag w m | m tag -> w where writer t ~(a, w) = do { tell t w; return a } tell t w = writer t ((), w)
writer :: MonadWriter tag w m => proxy tag -> (a, w) -> m a
tell :: MonadWriter tag w m => proxy tag -> w -> m ()
listen :: MonadWriter tag w m => proxy tag -> m a -> m (a, w)
pass :: MonadWriter tag w m => proxy tag -> m (a, w -> w) -> m a

-- | Execute an action and add the result of applying the given function to
--   its accumulator to the value of the computation.
listens :: MonadWriter tag w m => proxy tag -> (w -> b) -> m a -> m (a, b)

-- | Execute an action and apply a function to its accumulator.
censor :: MonadWriter tag w m => proxy tag -> (w -> w) -> m a -> m a
instance [overlap ok] (LiftListen t, LiftPass t, Monad (t m), MonadWriter tag w m, Monoid w) => MonadWriter tag w (t m)
instance [overlap ok] (Monoid w, Monad m) => MonadWriter tag w (WriterT tag w m)


-- | See <a>Control.Monad.Writer</a>.
module Control.Monad.Ether.Writer

-- | See <a>MonadWriter</a>.
class (Monoid w, Monad m) => MonadWriter tag w m | m tag -> w where writer t ~(a, w) = do { tell t w; return a } tell t w = writer t ((), w)
writer :: MonadWriter tag w m => proxy tag -> (a, w) -> m a
tell :: MonadWriter tag w m => proxy tag -> w -> m ()
listen :: MonadWriter tag w m => proxy tag -> m a -> m (a, w)
pass :: MonadWriter tag w m => proxy tag -> m (a, w -> w) -> m a

-- | Execute an action and add the result of applying the given function to
--   its accumulator to the value of the computation.
listens :: MonadWriter tag w m => proxy tag -> (w -> b) -> m a -> m (a, b)

-- | Execute an action and apply a function to its accumulator.
censor :: MonadWriter tag w m => proxy tag -> (w -> w) -> m a -> m a

-- | The parametrizable writer monad.
--   
--   Computations can accumulate a monoid value.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <a>&gt;&gt;=</a> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer tag w = WriterT tag w Identity

-- | Runs a <a>Writer</a> and returns both the normal value and the final
--   accumulator.
runWriter :: proxy tag -> Writer tag w a -> (a, w)

-- | Runs a <a>Writer</a> and returns the final accumulator, discarding the
--   normal value.
execWriter :: proxy tag -> Writer tag w a -> w

-- | The writer monad transformer.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <a>&gt;&gt;=</a> combines the outputs of the subcomputations using
--   <a>mappend</a>.
data WriterT tag w m a

-- | Constructor for computations in the writer monad transformer.
writerT :: proxy tag -> m (a, w) -> WriterT tag w m a

-- | Runs a <a>WriterT</a> and returns both the normal value and the final
--   accumulator.
runWriterT :: proxy tag -> WriterT tag w m a -> m (a, w)

-- | Runs a <a>WriterT</a> and returns the final accumulator, discarding
--   the normal value.
execWriterT :: Monad m => proxy tag -> WriterT tag w m a -> m w


-- | See <a>Control.Monad.Ether.Writer</a>.
module Control.Monad.Ether.Implicit.Writer

-- | See <a>MonadWriter</a>.
type MonadWriter w = MonadWriter w w

-- | See <a>writer</a>.
writer :: MonadWriter w m => (a, w) -> m a

-- | See <a>tell</a>.
tell :: MonadWriter w m => w -> m ()

-- | See <a>listen</a>.
listen :: MonadWriter w m => m a -> m (a, w)

-- | See <a>pass</a>.
pass :: MonadWriter w m => m (a, w -> w) -> m a

-- | See <a>listens</a>.
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)

-- | See <a>censor</a>.
censor :: MonadWriter w m => (w -> w) -> m a -> m a

-- | See <a>Writer</a>.
type Writer w = Writer w w

-- | See <a>runWriter</a>.
runWriter :: Writer w a -> (a, w)

-- | See <a>execWriter</a>.
execWriter :: Writer w a -> w

-- | See <a>WriterT</a>.
type WriterT w = WriterT w w

-- | See <a>writerT</a>.
writerT :: m (a, w) -> WriterT w m a

-- | See <a>runWriterT</a>.
runWriterT :: WriterT w m a -> m (a, w)

-- | See <a>execWriterT</a>.
execWriterT :: Monad m => WriterT w m a -> m w


-- | See <a>Control.Monad.Trans.State.Lazy</a>.
module Control.Monad.Trans.Ether.State.Lazy

-- | The parametrizable state monad.
--   
--   Computations have access to a mutable state.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <a>&gt;&gt;=</a> uses the final state of the first computation as the
--   initial state of the second.
type State tag r = StateT tag r Identity

-- | Constructor for computations in the state monad (the inverse of
--   <a>runState</a>).
state :: Monad m => proxy tag -> (s -> (a, s)) -> StateT tag s m a

-- | Runs a <a>State</a> with the given initial state and returns both the
--   final value and the final state.
runState :: proxy tag -> State tag s a -> s -> (a, s)

-- | Runs a <a>State</a> with the given initial state and returns the final
--   value, discarding the final state.
evalState :: proxy tag -> State tag s a -> s -> a

-- | Runs a <a>State</a> with the given initial state and returns the final
--   state, discarding the final value.
execState :: proxy tag -> State tag s a -> s -> s

-- | The state monad transformer.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <a>&gt;&gt;=</a> uses the final state of the first computation as the
--   initial state of the second.
data StateT tag s m a

-- | Constructor for computations in the state monad transformer.
stateT :: proxy tag -> (s -> m (a, s)) -> StateT tag s m a

-- | Runs a <a>StateT</a> with the given initial state and returns both the
--   final value and the final state.
runStateT :: proxy tag -> StateT tag s m a -> s -> m (a, s)

-- | Runs a <a>StateT</a> with the given initial state and returns the
--   final value, discarding the final state.
evalStateT :: Monad m => proxy tag -> StateT tag s m a -> s -> m a

-- | Runs a <a>StateT</a> with the given initial state and returns the
--   final state, discarding the final value.
execStateT :: Monad m => proxy tag -> StateT tag s m a -> s -> m s

-- | Fetch the current value of the state within the monad.
get :: Monad m => proxy tag -> StateT tag s m s

-- | Set the value of the state within the monad.
put :: Monad m => proxy tag -> s -> StateT tag s m ()
instance Generic (StateT tag s m a)
instance Functor m => Functor (StateT tag s m)
instance (Monad m, Functor m) => Applicative (StateT tag s m)
instance (Functor m, MonadPlus m) => Alternative (StateT tag s m)
instance Monad m => Monad (StateT tag s m)
instance MonadPlus m => MonadPlus (StateT tag s m)
instance MonadFix m => MonadFix (StateT tag s m)
instance MonadTrans (StateT tag s)
instance MonadIO m => MonadIO (StateT tag s m)
instance MFunctor (StateT tag s)
instance Datatype D1StateT
instance Constructor C1_0StateT
instance MonadError e m => MonadError e (StateT tag s m)
instance MonadWriter w m => MonadWriter w (StateT tag s m)
instance MonadState s' m => MonadState s' (StateT tag s m)
instance MonadReader r m => MonadReader r (StateT tag s m)
instance MonadCont m => MonadCont (StateT tag s m)
instance Tagged (StateT tag s m) tag
instance Taggable (StateT tag s m)
instance LiftCallCC (StateT tag s)
instance LiftPass (StateT tag s)
instance LiftListen (StateT tag s)
instance LiftCatch (StateT tag s)
instance LiftLocal (StateT tag s)
instance MonadBaseControl b m => MonadBaseControl b (StateT tag s m)
instance MonadTransControl (StateT tag s)
instance MonadBase b m => MonadBase b (StateT tag s m)
instance Newtype (StateT tag s m a)


-- | See <a>Control.Monad.Trans.State</a>.
module Control.Monad.Trans.Ether.State


-- | See <a>Control.Monad.Trans.State.Strict</a>.
module Control.Monad.Trans.Ether.State.Strict

-- | The parametrizable state monad.
--   
--   Computations have access to a mutable state.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <a>&gt;&gt;=</a> uses the final state of the first computation as the
--   initial state of the second.
type State tag r = StateT tag r Identity

-- | Constructor for computations in the state monad (the inverse of
--   <a>runState</a>).
state :: Monad m => proxy tag -> (s -> (a, s)) -> StateT tag s m a

-- | Runs a <a>State</a> with the given initial state and returns both the
--   final value and the final state.
runState :: proxy tag -> State tag s a -> s -> (a, s)

-- | Runs a <a>State</a> with the given initial state and returns the final
--   value, discarding the final state.
evalState :: proxy tag -> State tag s a -> s -> a

-- | Runs a <a>State</a> with the given initial state and returns the final
--   state, discarding the final value.
execState :: proxy tag -> State tag s a -> s -> s

-- | The state monad transformer.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <a>&gt;&gt;=</a> uses the final state of the first computation as the
--   initial state of the second.
data StateT tag s m a

-- | Constructor for computations in the state monad transformer.
stateT :: proxy tag -> (s -> m (a, s)) -> StateT tag s m a

-- | Runs a <a>StateT</a> with the given initial state and returns both the
--   final value and the final state.
runStateT :: proxy tag -> StateT tag s m a -> s -> m (a, s)

-- | Runs a <a>StateT</a> with the given initial state and returns the
--   final value, discarding the final state.
evalStateT :: Monad m => proxy tag -> StateT tag s m a -> s -> m a

-- | Runs a <a>StateT</a> with the given initial state and returns the
--   final state, discarding the final value.
execStateT :: Monad m => proxy tag -> StateT tag s m a -> s -> m s

-- | Fetch the current value of the state within the monad.
get :: Monad m => proxy tag -> StateT tag s m s

-- | Set the value of the state within the monad.
put :: Monad m => proxy tag -> s -> StateT tag s m ()
instance Generic (StateT tag s m a)
instance Functor m => Functor (StateT tag s m)
instance (Monad m, Functor m) => Applicative (StateT tag s m)
instance (Functor m, MonadPlus m) => Alternative (StateT tag s m)
instance Monad m => Monad (StateT tag s m)
instance MonadPlus m => MonadPlus (StateT tag s m)
instance MonadFix m => MonadFix (StateT tag s m)
instance MonadTrans (StateT tag s)
instance MonadIO m => MonadIO (StateT tag s m)
instance MFunctor (StateT tag s)
instance Datatype D1StateT
instance Constructor C1_0StateT
instance MonadError e m => MonadError e (StateT tag s m)
instance MonadWriter w m => MonadWriter w (StateT tag s m)
instance MonadState s' m => MonadState s' (StateT tag s m)
instance MonadReader r m => MonadReader r (StateT tag s m)
instance MonadCont m => MonadCont (StateT tag s m)
instance Tagged (StateT tag s m) tag
instance Taggable (StateT tag s m)
instance LiftCallCC (StateT tag s)
instance LiftPass (StateT tag s)
instance LiftListen (StateT tag s)
instance LiftCatch (StateT tag s)
instance LiftLocal (StateT tag s)
instance MonadBaseControl b m => MonadBaseControl b (StateT tag s m)
instance MonadTransControl (StateT tag s)
instance MonadBase b m => MonadBase b (StateT tag s m)
instance Newtype (StateT tag s m a)


-- | See <a>Control.Monad.Trans.Except</a>.
module Control.Monad.Trans.Ether.Except

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <a>&gt;&gt;=</a> exits on the first exception.
type Except tag e = ExceptT tag e Identity

-- | Constructor for computations in the exception monad (the inverse of
--   <a>runExcept</a>).
except :: Monad m => proxy tag -> Either e a -> ExceptT tag e m a

-- | Runs an <a>Except</a> and returns either an exception or a normal
--   value.
runExcept :: proxy tag -> Except tag e a -> Either e a

-- | The exception monad transformer.
--   
--   The <a>return</a> function returns a normal value, while
--   <a>&gt;&gt;=</a> exits on the first exception.
data ExceptT tag e m a

-- | Constructor for computations in the exception monad transformer.
exceptT :: proxy tag -> m (Either e a) -> ExceptT tag e m a

-- | Runs an <a>ExceptT</a> and returns either an exception or a normal
--   value.
runExceptT :: proxy tag -> ExceptT tag e m a -> m (Either e a)

-- | Is used within a monadic computation to begin exception processing.
throw :: Monad m => proxy tag -> e -> ExceptT tag e m a

-- | A handler function to handle previous exceptions and return to normal
--   execution.
catch :: Monad m => proxy tag -> ExceptT tag e m a -> (e -> ExceptT tag e m a) -> ExceptT tag e m a
instance Generic (ExceptT tag e m a)
instance Functor m => Functor (ExceptT tag e m)
instance (Monad m, Functor m) => Applicative (ExceptT tag e m)
instance (Monad m, Functor m, Monoid e) => Alternative (ExceptT tag e m)
instance Monad m => Monad (ExceptT tag e m)
instance (Monad m, Monoid e) => MonadPlus (ExceptT tag e m)
instance MonadFix m => MonadFix (ExceptT tag e m)
instance MonadTrans (ExceptT tag e)
instance MonadIO m => MonadIO (ExceptT tag e m)
instance MFunctor (ExceptT tag e)
instance MMonad (ExceptT tag e)
instance Datatype D1ExceptT
instance Constructor C1_0ExceptT
instance MonadError e' m => MonadError e' (ExceptT tag e m)
instance MonadWriter w m => MonadWriter w (ExceptT tag e m)
instance MonadState s m => MonadState s (ExceptT tag e m)
instance MonadReader r m => MonadReader r (ExceptT tag e m)
instance MonadCont m => MonadCont (ExceptT tag e m)
instance Tagged (ExceptT tag e m) tag
instance Taggable (ExceptT tag e m)
instance LiftCallCC (ExceptT tag e)
instance LiftPass (ExceptT tag e)
instance LiftListen (ExceptT tag e)
instance LiftCatch (ExceptT tag e)
instance LiftLocal (ExceptT tag e)
instance MonadBaseControl b m => MonadBaseControl b (ExceptT tag e m)
instance MonadTransControl (ExceptT tag e)
instance MonadBase b m => MonadBase b (ExceptT tag e m)
instance Newtype (ExceptT tag e m a)


-- | See <a>Control.Monad.State.Class</a>.
module Control.Monad.Ether.State.Class

-- | See <a>MonadState</a>.
class Monad m => MonadState tag s m | m tag -> s where get t = state t (\ s -> (s, s)) put t s = state t (\ _ -> ((), s)) state t f = do { s <- get t; let ~(a, s') = f s; put t s'; return a }
get :: MonadState tag s m => proxy tag -> m s
put :: MonadState tag s m => proxy tag -> s -> m ()
state :: MonadState tag s m => proxy tag -> (s -> (a, s)) -> m a

-- | Modifies the state inside a state monad.
modify :: MonadState tag s m => proxy tag -> (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState tag s m => proxy tag -> (s -> a) -> m a
instance [overlap ok] (Monoid w, MonadState tag s m) => MonadState tag s (WriterT w m)
instance [overlap ok] (Monoid w, MonadState tag s m) => MonadState tag s (WriterT w m)
instance [overlap ok] MonadState tag s m => MonadState tag s (StateT s' m)
instance [overlap ok] MonadState tag s m => MonadState tag s (StateT s' m)
instance [overlap ok] MonadState tag s m => MonadState tag s (ReaderT r m)
instance [overlap ok] MonadState tag s m => MonadState tag s (MaybeT m)
instance [overlap ok] MonadState tag s m => MonadState tag s (ListT m)
instance [overlap ok] MonadState tag s m => MonadState tag s (IdentityT m)
instance [overlap ok] MonadState tag s m => MonadState tag s (ExceptT e m)
instance [overlap ok] MonadState tag s m => MonadState tag s (ContT r m)
instance [overlap ok] MonadState tag s m => MonadState tag s (ExceptT tag' e m)
instance [overlap ok] (Monoid w, MonadState tag s m) => MonadState tag s (WriterT tag' w m)
instance [overlap ok] MonadState tag s m => MonadState tag s (ReaderT tag' r m)
instance [overlap ok] MonadState tag s m => MonadState tag s (StateT tag' s' m)
instance [overlap ok] Monad m => MonadState tag s (StateT tag s m)
instance [overlap ok] MonadState tag s m => MonadState tag s (StateT tag' s' m)
instance [overlap ok] Monad m => MonadState tag s (StateT tag s m)


-- | See <a>Control.Monad.State.Lazy</a>.
module Control.Monad.Ether.State.Lazy

-- | See <a>MonadState</a>.
class Monad m => MonadState tag s m | m tag -> s where get t = state t (\ s -> (s, s)) put t s = state t (\ _ -> ((), s)) state t f = do { s <- get t; let ~(a, s') = f s; put t s'; return a }
get :: MonadState tag s m => proxy tag -> m s
put :: MonadState tag s m => proxy tag -> s -> m ()
state :: MonadState tag s m => proxy tag -> (s -> (a, s)) -> m a

-- | Modifies the state inside a state monad.
modify :: MonadState tag s m => proxy tag -> (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState tag s m => proxy tag -> (s -> a) -> m a

-- | The parametrizable state monad.
--   
--   Computations have access to a mutable state.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <a>&gt;&gt;=</a> uses the final state of the first computation as the
--   initial state of the second.
type State tag r = StateT tag r Identity

-- | Runs a <a>State</a> with the given initial state and returns both the
--   final value and the final state.
runState :: proxy tag -> State tag s a -> s -> (a, s)

-- | Runs a <a>State</a> with the given initial state and returns the final
--   value, discarding the final state.
evalState :: proxy tag -> State tag s a -> s -> a

-- | Runs a <a>State</a> with the given initial state and returns the final
--   state, discarding the final value.
execState :: proxy tag -> State tag s a -> s -> s

-- | The state monad transformer.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <a>&gt;&gt;=</a> uses the final state of the first computation as the
--   initial state of the second.
data StateT tag s m a

-- | Constructor for computations in the state monad transformer.
stateT :: proxy tag -> (s -> m (a, s)) -> StateT tag s m a

-- | Runs a <a>StateT</a> with the given initial state and returns both the
--   final value and the final state.
runStateT :: proxy tag -> StateT tag s m a -> s -> m (a, s)

-- | Runs a <a>StateT</a> with the given initial state and returns the
--   final value, discarding the final state.
evalStateT :: Monad m => proxy tag -> StateT tag s m a -> s -> m a

-- | Runs a <a>StateT</a> with the given initial state and returns the
--   final state, discarding the final value.
execStateT :: Monad m => proxy tag -> StateT tag s m a -> s -> m s


-- | See <a>Control.Monad.State</a>.
module Control.Monad.Ether.State


-- | See <a>Control.Monad.Ether.State.Lazy</a>.
module Control.Monad.Ether.Implicit.State.Lazy

-- | See <a>MonadState</a>.
type MonadState s = MonadState s s

-- | See <a>get</a>.
get :: MonadState s m => m s

-- | See <a>put</a>.
put :: MonadState s m => s -> m ()

-- | See <a>state</a>.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | See <a>modify</a>.
modify :: MonadState s m => (s -> s) -> m ()

-- | See <a>gets</a>.
gets :: MonadState s m => (s -> a) -> m a

-- | See <a>State</a>.
type State s = State s s

-- | See <a>runState</a>.
runState :: State s a -> s -> (a, s)

-- | See <a>evalState</a>.
evalState :: State s a -> s -> a

-- | See <a>execState</a>.
execState :: State s a -> s -> s

-- | See <a>StateT</a>.
type StateT s = StateT s s

-- | See <a>stateT</a>.
stateT :: (s -> m (a, s)) -> StateT s m a

-- | See <a>runStateT</a>.
runStateT :: StateT s m a -> s -> m (a, s)

-- | See <a>evalStateT</a>.
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | See <a>execStateT</a>.
execStateT :: Monad m => StateT s m a -> s -> m s


-- | See <a>Control.Monad.Ether.State</a>.
module Control.Monad.Ether.Implicit.State


-- | See <a>Control.Monad.State.Strict</a>.
module Control.Monad.Ether.State.Strict

-- | See <a>MonadState</a>.
class Monad m => MonadState tag s m | m tag -> s where get t = state t (\ s -> (s, s)) put t s = state t (\ _ -> ((), s)) state t f = do { s <- get t; let ~(a, s') = f s; put t s'; return a }
get :: MonadState tag s m => proxy tag -> m s
put :: MonadState tag s m => proxy tag -> s -> m ()
state :: MonadState tag s m => proxy tag -> (s -> (a, s)) -> m a

-- | Modifies the state inside a state monad.
modify :: MonadState tag s m => proxy tag -> (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState tag s m => proxy tag -> (s -> a) -> m a

-- | The parametrizable state monad.
--   
--   Computations have access to a mutable state.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <a>&gt;&gt;=</a> uses the final state of the first computation as the
--   initial state of the second.
type State tag r = StateT tag r Identity

-- | Runs a <a>State</a> with the given initial state and returns both the
--   final value and the final state.
runState :: proxy tag -> State tag s a -> s -> (a, s)

-- | Runs a <a>State</a> with the given initial state and returns the final
--   value, discarding the final state.
evalState :: proxy tag -> State tag s a -> s -> a

-- | Runs a <a>State</a> with the given initial state and returns the final
--   state, discarding the final value.
execState :: proxy tag -> State tag s a -> s -> s

-- | The state monad transformer.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <a>&gt;&gt;=</a> uses the final state of the first computation as the
--   initial state of the second.
data StateT tag s m a

-- | Constructor for computations in the state monad transformer.
stateT :: proxy tag -> (s -> m (a, s)) -> StateT tag s m a

-- | Runs a <a>StateT</a> with the given initial state and returns both the
--   final value and the final state.
runStateT :: proxy tag -> StateT tag s m a -> s -> m (a, s)

-- | Runs a <a>StateT</a> with the given initial state and returns the
--   final value, discarding the final state.
evalStateT :: Monad m => proxy tag -> StateT tag s m a -> s -> m a

-- | Runs a <a>StateT</a> with the given initial state and returns the
--   final state, discarding the final value.
execStateT :: Monad m => proxy tag -> StateT tag s m a -> s -> m s


-- | See <a>Control.Monad.Ether.State.Strict</a>.
module Control.Monad.Ether.Implicit.State.Strict

-- | See <a>MonadState</a>.
type MonadState s = MonadState s s

-- | See <a>get</a>.
get :: MonadState s m => m s

-- | See <a>put</a>.
put :: MonadState s m => s -> m ()

-- | See <a>state</a>.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | See <a>modify</a>.
modify :: MonadState s m => (s -> s) -> m ()

-- | See <a>gets</a>.
gets :: MonadState s m => (s -> a) -> m a

-- | See <a>State</a>.
type State s = State s s

-- | See <a>runState</a>.
runState :: State s a -> s -> (a, s)

-- | See <a>evalState</a>.
evalState :: State s a -> s -> a

-- | See <a>execState</a>.
execState :: State s a -> s -> s

-- | See <a>StateT</a>.
type StateT s = StateT s s

-- | See <a>stateT</a>.
stateT :: (s -> m (a, s)) -> StateT s m a

-- | See <a>runStateT</a>.
runStateT :: StateT s m a -> s -> m (a, s)

-- | See <a>evalStateT</a>.
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | See <a>execStateT</a>.
execStateT :: Monad m => StateT s m a -> s -> m s


-- | See <a>Control.Monad.Except</a>.
module Control.Monad.Ether.Except.Class

-- | See <a>MonadError</a>.
class Monad m => MonadExcept tag e m | m tag -> e
throw :: MonadExcept tag e m => proxy tag -> e -> m a
catch :: MonadExcept tag e m => proxy tag -> m a -> (e -> m a) -> m a
instance [overlap ok] (LiftCatch t, Monad (t m), MonadExcept tag e m) => MonadExcept tag e (t m)
instance [overlap ok] Monad m => MonadExcept tag e (ExceptT tag e m)


-- | Annotating monads with tags to turn untagged constraints into tagged
--   ones.
--   
--   <pre>
--   import qualified Control.Monad.State as T
--   import Control.Ether.TH (ethereal)
--   import Control.Monad.Ether.State (MonadState)
--   import Control.Ether.Wrapped (ethered)
--   
--   ethereal "Foo" "foo"
--   
--   f :: T.MonadState Int m =&gt; m String
--   f = fmap show T.get
--   
--   g :: MonadState Foo Int m =&gt; m String
--   g = ethered foo f
--   </pre>
module Control.Ether.Wrapped

-- | Wrap a monad to attach a tag to it.
newtype WrappedEther tag m a
WrapEther :: m a -> WrappedEther tag m a
unwrapEther :: WrappedEther tag m a -> m a

-- | Annotate a polymorphic monadic computation with a tag.
ethered :: proxy tag -> WrappedEther tag m a -> m a
instance Generic (WrappedEther tag m a)
instance Functor m => Functor (WrappedEther tag m)
instance Applicative m => Applicative (WrappedEther tag m)
instance Alternative m => Alternative (WrappedEther tag m)
instance Monad m => Monad (WrappedEther tag m)
instance MonadPlus m => MonadPlus (WrappedEther tag m)
instance MonadFix m => MonadFix (WrappedEther tag m)
instance MonadIO m => MonadIO (WrappedEther tag m)
instance Datatype D1WrappedEther
instance Constructor C1_0WrappedEther
instance Selector S1_0_0WrappedEther
instance MonadWriter tag w m => MonadWriter tag w (WrappedEther tag' m)
instance MonadWriter tag w m => MonadWriter w (WrappedEther tag m)
instance MonadExcept tag e m => MonadExcept tag e (WrappedEther tag' m)
instance MonadExcept tag e m => MonadError e (WrappedEther tag m)
instance MonadState tag s m => MonadState tag s (WrappedEther tag' m)
instance MonadState tag s m => MonadState s (WrappedEther tag m)
instance MonadReader tag r m => MonadReader tag r (WrappedEther tag' m)
instance MonadReader tag r m => MonadReader r (WrappedEther tag m)
instance Newtype (WrappedEther tag m a)


-- | See <a>Control.Monad.Except</a>.
module Control.Monad.Ether.Except

-- | See <a>MonadError</a>.
class Monad m => MonadExcept tag e m | m tag -> e
throw :: MonadExcept tag e m => proxy tag -> e -> m a
catch :: MonadExcept tag e m => proxy tag -> m a -> (e -> m a) -> m a

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <a>&gt;&gt;=</a> exits on the first exception.
type Except tag e = ExceptT tag e Identity

-- | Runs an <a>Except</a> and returns either an exception or a normal
--   value.
runExcept :: proxy tag -> Except tag e a -> Either e a

-- | The exception monad transformer.
--   
--   The <a>return</a> function returns a normal value, while
--   <a>&gt;&gt;=</a> exits on the first exception.
data ExceptT tag e m a

-- | Constructor for computations in the exception monad transformer.
exceptT :: proxy tag -> m (Either e a) -> ExceptT tag e m a

-- | Runs an <a>ExceptT</a> and returns either an exception or a normal
--   value.
runExceptT :: proxy tag -> ExceptT tag e m a -> m (Either e a)

-- | Runs an <a>ExceptT</a> and handles the exception with the given
--   function.
handleT :: Functor m => proxy tag -> (e -> a) -> ExceptT tag e m a -> m a

-- | Runs an <a>Except</a> and handles the exception with the given
--   function.
handle :: proxy tag -> (e -> a) -> Except tag e a -> a


-- | This module provides convenience exports of all tagged monad classes
--   from Ether.
module Control.Monad.Ether

-- | Creates a tag and a value-level proxy for it.
--   
--   <tt><a>ethereal</a> "Foo" "foo"</tt> generates the following code:
--   
--   <pre>
--   data Foo
--   foo :: Proxy Foo
--   foo = Proxy
--   </pre>
ethereal :: String -> String -> DecsQ


-- | Abbreviations for constraints.
module Control.Ether.Abbr

-- | Denotes <a>MonadReader</a>. The mnemonic is that you read values of
--   type <tt>r</tt> from the reader environment tagged by <tt>tag</tt>,
--   thus the arrows points from <tt>tag</tt> to <tt>r</tt>.
data (-->) tag r

-- | Denotes <a>MonadWriter</a>. The mnemonic is that you write values of
--   type <tt>w</tt> to the writer accumulator tagged by <tt>tag</tt>, thus
--   the arrows points from <tt>w</tt> to <tt>tag</tt>.
data (<--) tag w

-- | Denotes <a>MonadState</a>. The mnemonic is that you can both read from
--   and write into the state, thus the arrow points in both directions.
data (<->) tag s

-- | Denotes <a>MonadExcept</a>.
data (-!-) tag e

-- | Reify a list of constraint abbreviations.
--   
--   <pre>
--   f :: Ether '[Foo --&gt; r, Bar &lt;-- w, Baz &lt;-&gt; s, Quux -!- e] m =&gt; m a
--   </pre>
--   
--   expands into
--   
--   <pre>
--   f :: ( MonadReader Foo  r m
--        , MonadWriter Bar  w m
--        , MonadState  Baz  s m
--        , MonadExcept Quux e m
--        ) =&gt; m a
--   </pre>

-- | Turns an abbreviation into an actual constraint.


-- | See <a>Control.Monad.Ether.Except</a>.
module Control.Monad.Ether.Implicit.Except

-- | See <a>MonadExcept</a>.
type MonadExcept e = MonadExcept e e

-- | See <a>throw</a>.
throw :: MonadExcept e m => e -> m a

-- | See <a>catch</a>.
catch :: MonadExcept e m => m a -> (e -> m a) -> m a

-- | See <a>Except</a>.
type Except e = Except e e

-- | See <a>runExcept</a>.
runExcept :: Except e a -> Either e a

-- | See <a>ExceptT</a>.
type ExceptT e = ExceptT e e

-- | See <a>exceptT</a>.
exceptT :: m (Either e a) -> ExceptT e m a

-- | See <a>runExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | See <a>handle</a>.
handle :: (e -> a) -> Except e a -> a

-- | See <a>handleT</a>.
handleT :: Functor m => (e -> a) -> ExceptT e m a -> m a


-- | This module provides convenience exports of all implicitly tagged
--   monad classes from Ether.
module Control.Monad.Ether.Implicit


-- | See <a>Control.Ether.Abbr</a>.
module Control.Ether.Implicit.Abbr

-- | Denotes <a>MonadReader</a>.
data R r

-- | Denotes <a>MonadWriter</a>.
data W w

-- | Denotes <a>MonadState</a>.
data S s

-- | Denotes <a>MonadExcept</a>.
data E e
