-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An approximate streaming (constant space) unique object counter
--   
@package hyperloglog
@version 0.3.3.1


module Data.HyperLogLog.Config

-- | Constants required for a bucketing factor b
data Config
class HasConfig t where numBits = config . to _numBits numBuckets = config . to _numBuckets smallRange = config . to _smallRange interRange = config . to _interRange rawFact = config . to _rawFact alpha = config . to _alpha bucketMask = config . to _bucketMask
config :: HasConfig t => Getter t Config
numBits :: HasConfig t => Getter t Int
numBuckets :: HasConfig t => Getter t Int
smallRange :: HasConfig t => Getter t Double
interRange :: HasConfig t => Getter t Double
rawFact :: HasConfig t => Getter t Double
alpha :: HasConfig t => Getter t Double
bucketMask :: HasConfig t => Getter t Word32

-- | Precalculate constants for a given bucketing factor b
hll :: Int -> Config
class ReifiesConfig o
reflectConfig :: ReifiesConfig o => p o -> Config
reifyConfig :: Int -> (forall (o :: *). ReifiesConfig o => Proxy o -> r) -> r
type Rank = Int8
calcBucket :: HasConfig t => t -> Word32 -> Int
calcRank :: HasConfig t => t -> Word32 -> Int8
lim32 :: Double
instance Eq Config
instance Show Config
instance Generic Config
instance Datatype D1Config
instance Constructor C1_0Config
instance Selector S1_0_0Config
instance Selector S1_0_1Config
instance Selector S1_0_2Config
instance Selector S1_0_3Config
instance Selector S1_0_4Config
instance Selector S1_0_5Config
instance Selector S1_0_6Config
instance Reifies n Int => ReifiesConfig (SD n)
instance Reifies n Int => ReifiesConfig (D n)
instance Reifies s Config => ReifiesConfig (ReifiedConfig s)
instance KnownNat n => ReifiesConfig n
instance Serial Config
instance Binary Config
instance Serialize Config
instance HasConfig Config


-- | This package provides an approximate streaming (constant space) unique
--   object counter.
--   
--   See the original paper for details:
--   <a>http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf</a>
module Data.HyperLogLog.Type

-- | Initialize a new counter:
--   
--   <pre>
--   &gt;&gt;&gt; mempty :: HyperLogLog $(3)
--   HyperLogLog {runHyperLogLog = fromList [0,0,0,0,0,0,0,0]}
--   </pre>
--   
--   Please note how you specify a counter size with the <tt>$(n)</tt>
--   invocation. Sizes of up to 16 are valid, with 7 being a likely good
--   minimum for decent accuracy.
--   
--   Let's count a list of unique items and get the latest estimate:
--   
--   <pre>
--   &gt;&gt;&gt; size (foldr insert mempty [1..10] :: HyperLogLog $(4))
--   Approximate {_confidence = 0.9972, _lo = 2, _estimate = 9, _hi = 17}
--   </pre>
--   
--   Note how <a>insert</a> can be used to add new observations to the
--   approximate counter.
newtype HyperLogLog p
HyperLogLog :: Vector Rank -> HyperLogLog p
runHyperLogLog :: HyperLogLog p -> Vector Rank
class HasHyperLogLog a p | a -> p
hyperLogLog :: HasHyperLogLog a p => Lens' a (HyperLogLog p)

-- | Approximate size of our set
size :: ReifiesConfig p => HyperLogLog p -> Approximate Int64
insert :: (ReifiesConfig s, Serial a) => a -> HyperLogLog s -> HyperLogLog s

-- | Insert a value that has already been hashed by whatever user defined
--   hash function you want.
insertHash :: ReifiesConfig s => Word32 -> HyperLogLog s -> HyperLogLog s
intersectionSize :: ReifiesConfig p => [HyperLogLog p] -> Approximate Int64
cast :: (ReifiesConfig p, ReifiesConfig q) => HyperLogLog p -> Maybe (HyperLogLog q)
instance Eq (HyperLogLog p)
instance Show (HyperLogLog p)
instance Generic (HyperLogLog p)
instance Datatype D1HyperLogLog
instance Constructor C1_0HyperLogLog
instance Selector S1_0_0HyperLogLog
instance ReifiesConfig p => Monoid (HyperLogLog p)
instance Semigroup (HyperLogLog p)
instance ReifiesConfig p => HasConfig (HyperLogLog p)
instance HasHyperLogLog (HyperLogLog p) p
instance Binary (HyperLogLog p)
instance Serial (HyperLogLog p)
instance Serialize (HyperLogLog p)


-- | See the original paper for details:
--   <a>http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf</a>
module Data.HyperLogLog

-- | Initialize a new counter:
--   
--   <pre>
--   &gt;&gt;&gt; mempty :: HyperLogLog $(3)
--   HyperLogLog {runHyperLogLog = fromList [0,0,0,0,0,0,0,0]}
--   </pre>
--   
--   Please note how you specify a counter size with the <tt>$(n)</tt>
--   invocation. Sizes of up to 16 are valid, with 7 being a likely good
--   minimum for decent accuracy.
--   
--   Let's count a list of unique items and get the latest estimate:
--   
--   <pre>
--   &gt;&gt;&gt; size (foldr insert mempty [1..10] :: HyperLogLog $(4))
--   Approximate {_confidence = 0.9972, _lo = 2, _estimate = 9, _hi = 17}
--   </pre>
--   
--   Note how <a>insert</a> can be used to add new observations to the
--   approximate counter.
data HyperLogLog p
class HasHyperLogLog a p | a -> p
hyperLogLog :: HasHyperLogLog a p => Lens' a (HyperLogLog p)

-- | Approximate size of our set
size :: ReifiesConfig p => HyperLogLog p -> Approximate Int64
intersectionSize :: ReifiesConfig p => [HyperLogLog p] -> Approximate Int64
insert :: (ReifiesConfig s, Serial a) => a -> HyperLogLog s -> HyperLogLog s

-- | Insert a value that has already been hashed by whatever user defined
--   hash function you want.
insertHash :: ReifiesConfig s => Word32 -> HyperLogLog s -> HyperLogLog s
cast :: (ReifiesConfig p, ReifiesConfig q) => HyperLogLog p -> Maybe (HyperLogLog q)

-- | Constants required for a bucketing factor b
data Config

-- | Precalculate constants for a given bucketing factor b
hll :: Int -> Config
class ReifiesConfig o
reifyConfig :: Int -> (forall (o :: *). ReifiesConfig o => Proxy o -> r) -> r
