-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extensible, efficient, lens-friendly data types
--   
@package extensible
@version 0.3.5


-- | Re-implementation of lens combinators
module Data.Extensible.Internal.Rig
type Optic p f s t a b = p a (f b) -> p s (f t)
type Optic' p f s a = p a (f a) -> p s (f s)

-- | <pre>
--   <a>view</a> :: Getter s a -&gt; s -&gt; a
--   </pre>
view :: Optic' (->) (Const a) s a -> s -> a

-- | <pre>
--   <a>views</a> :: Getter s a -&gt; (a -&gt; r) -&gt; (s -&gt; r)
--   </pre>
views :: Optic' (->) (Const r) s a -> (a -> r) -> s -> r

-- | <pre>
--   <a>over</a> :: Setter s t a b -&gt; (a -&gt; b) -&gt; (s -&gt; t)
--   </pre>
over :: Optic (->) Identity s t a b -> (a -> b) -> s -> t
withIso :: Optic (Exchange a b) Identity s t a b -> ((s -> a) -> (b -> t) -> r) -> r
data Exchange a b s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b s t
review :: Optic' Tagged Identity s a -> a -> s
instance Profunctor (Exchange a b)


-- | A bunch of combinators that contains magic
module Data.Extensible.Internal

-- | The position of <tt>x</tt> in the type level set <tt>xs</tt>.
data Membership (xs :: [k]) (x :: k)
getMemberId :: Membership xs x -> Word

-- | Generates a <a>Membership</a> that corresponds to the given ordinal
--   (0-origin).
mkMembership :: Int -> Q Exp

-- | Embodies a type equivalence to ensure that the <a>Membership</a>
--   points the first element.
runMembership :: Membership (y : xs) x -> (x :~: y -> r) -> (Membership xs x -> r) -> r

-- | Compare two <a>Membership</a>s.
compareMembership :: Membership xs x -> Membership xs y -> Either Ordering (x :~: y)
class Member xs x
membership :: Member xs x => Membership xs x

-- | Remember that <tt>Member xs x</tt> from <a>Membership</a>.
remember :: Membership xs x -> (Member xs x => r) -> r

-- | Unicode flipped alias for <a>Member</a>
type (∈) x xs = Member xs x

-- | FindType types

-- | The kind of key-value pairs
data Assoc k v
(:>) :: k -> v -> Assoc k v

-- | <tt><a>Associate</a> k v xs</tt> is essentially identical to <tt>(k
--   :&gt; v) ∈ xs</tt> , but the type <tt>v</tt> is inferred from
--   <tt>k</tt> and <tt>xs</tt>.
class Associate k v xs | k xs -> v
association :: Associate k v xs => Membership xs (k :> v)
data Elaborated k v
Expecting :: v -> Elaborated k v
Missing :: k -> Elaborated k v
Duplicate :: k -> Elaborated k v

-- | Ensure that the first element of <tt>xs</tt> is <tt>x</tt>
data NavHere xs x
Here :: NavHere (x : xs) x

-- | PRIVILEGED: Navigate a tree.
navigate :: (NavHere xs x -> r) -> (Membership (Half (Tail xs)) x -> r) -> (Membership (Half (Tail (Tail xs))) x -> r) -> Membership xs x -> r

-- | The <a>Membership</a> points the first element
here :: Membership (x : xs) x

-- | The next membership
navNext :: Membership xs y -> Membership (x : xs) y

-- | Describes the relation of <a>Membership</a> within a tree
navL :: Membership (Half xs) y -> Membership (x : xs) y

-- | Describes the relation of <a>Membership</a> within a tree
navR :: Membership (Half (Tail xs)) y -> Membership (x : xs) y

-- | Type level binary number
data Nat
Zero :: Nat
DNat :: Nat -> Nat
SDNat :: Nat -> Nat

-- | Converts type naturals into <a>Word</a>.
class KnownPosition n
theInt :: KnownPosition n => proxy n -> Word

-- | The successor of the number

-- | Interleaved list

-- | Type-level tail

-- | Type level ++

-- | Type level map

-- | Type level merging

-- | Type level concat
instance Typeable Membership
instance KnownPosition n => KnownPosition ('SDNat n)
instance KnownPosition n => KnownPosition ('DNat n)
instance KnownPosition 'Zero
instance Ord (Membership xs x)
instance Eq (Membership xs x)
instance Show (Membership xs x)
instance (Elaborate k2 (FindAssoc k2 xs) ~ 'Expecting (n ':> v), KnownPosition n) => Associate k2 v xs
instance (Elaborate x (FindType x xs) ~ 'Expecting pos, KnownPosition pos) => Member xs x


module Data.Extensible.Wrapper

-- | The extensible data types should take <tt>k -&gt; *</tt> as a
--   parameter. This class allows us to take a shortcut for direct
--   representation.
class Wrapper (h :: k -> *) where type family Repr h (v :: k) :: *
_Wrapper :: (Wrapper h, Functor f, Profunctor p) => Optic' p f (h v) (Repr h v)

-- | Restricted version of <a>_Wrapper</a>. It is useful for eliminating
--   ambiguousness.
_WrapperAs :: (Functor f, Profunctor p, Wrapper h) => proxy v -> Optic' p f (h v) (Repr h v)

-- | Poly-kinded Const
newtype Const' a x
Const' :: a -> Const' a x
getConst' :: Const' a x -> a

-- | Poly-kinded composition
newtype Comp (f :: j -> *) (g :: i -> j) (a :: i)
Comp :: f (g a) -> Comp
getComp :: Comp -> f (g a)
comp :: Functor f => (a -> g b) -> f a -> Comp f g b
instance Typeable Comp
instance Typeable Const'
instance Show (f (g a)) => Show (Comp f g a)
instance Eq (f (g a)) => Eq (Comp f g a)
instance Ord (f (g a)) => Ord (Comp f g a)
instance Show a => Show (Const' a x)
instance Eq a => Eq (Const' a x)
instance Ord a => Ord (Const' a x)
instance Wrapper Proxy
instance Wrapper (Const' a)
instance (Functor f, Wrapper g) => Wrapper (Comp f g)
instance Wrapper Identity


module Data.Extensible.Class

-- | This class allows us to use <a>pieceAt</a> for both sums and products.
class (Functor f, Profunctor p) => Extensible f p (t :: (k -> *) -> [k] -> *)
pieceAt :: Extensible f p t => Membership xs x -> Optic' p f (t h xs) (h x)

-- | Accessor for an element.
piece :: (x ∈ xs, Extensible f p t) => Optic' p f (t h xs) (h x)

-- | Like <a>piece</a>, but reckon membership from its key.
pieceAssoc :: (Associate k v xs, Extensible f p t) => Optic' p f (t h xs) (h (k :> v))
itemAt :: (Wrapper h, Extensible f p t) => Membership xs x -> Optic' p f (t h xs) (Repr h x)
item :: (Wrapper h, Extensible f p t, x ∈ xs) => proxy x -> Optic' p f (t h xs) (Repr h x)
itemAssoc :: (Wrapper h, Extensible f p t, Associate k v xs) => proxy k -> Optic' p f (t h xs) (Repr h (k :> v))

-- | The position of <tt>x</tt> in the type level set <tt>xs</tt>.
data Membership (xs :: [k]) (x :: k)

-- | Generates a <a>Membership</a> that corresponds to the given ordinal
--   (0-origin).
mkMembership :: Int -> Q Exp
class Member xs x
membership :: Member xs x => Membership xs x

-- | Remember that <tt>Member xs x</tt> from <a>Membership</a>.
remember :: Membership xs x -> (Member xs x => r) -> r

-- | Unicode flipped alias for <a>Member</a>
type (∈) x xs = Member xs x

-- | FindType types

-- | The kind of key-value pairs
data Assoc k v
(:>) :: k -> v -> Assoc k v

-- | <tt><a>Associate</a> k v xs</tt> is essentially identical to <tt>(k
--   :&gt; v) ∈ xs</tt> , but the type <tt>v</tt> is inferred from
--   <tt>k</tt> and <tt>xs</tt>.
class Associate k v xs | k xs -> v
association :: Associate k v xs => Membership xs (k :> v)
data Elaborated k v
Expecting :: v -> Elaborated k v
Missing :: k -> Elaborated k v
Duplicate :: k -> Elaborated k v


module Data.Extensible.Product

-- | The type of extensible products.
--   
--   <pre>
--   (:*) :: (k -&gt; *) -&gt; [k] -&gt; *
--   </pre>
data (:*) (h :: k -> *) (s :: [k])
Nil :: h :* []
Tree :: !(h x) -> h :* Half xs -> h :* Half (Tail xs) -> h :* (x : xs)

-- | <i>O(log n)</i> Add an element to a product.
(<:) :: h x -> h :* xs -> h :* (x : xs)

-- | An alias for (<a>&lt;:</a>).
(<:*) :: h x -> h :* xs -> h :* (x : xs)

-- | Combine products.
(*++*) :: h :* xs -> h :* ys -> h :* (xs ++ ys)

-- | <i>O(1)</i> Extract the head element.
hhead :: h :* (x : xs) -> h x

-- | <i>O(log n)</i> Extract the tail of the product.
htail :: h :* (x : xs) -> h :* xs

-- | Split a product to the head and the tail.
huncons :: h :* (x : xs) -> (h x, h :* xs)

-- | Transform every elements in a product, preserving the order.
--   
--   <pre>
--   <a>hmap</a> <a>id</a> ≡ <a>id</a>
--   <a>hmap</a> (f . g) ≡ <a>hmap</a> f . <a>hmap</a> g
--   </pre>
hmap :: (forall x. g x -> h x) -> g :* xs -> h :* xs

-- | <a>hmap</a> with <a>Membership</a>s.
hmapWithIndex :: (forall x. Membership xs x -> g x -> h x) -> g :* xs -> h :* xs

-- | Transform every elements in a product, preserving the order.
htrans :: (forall x. g x -> h (t x)) -> g :* xs -> h :* Map t xs

-- | <a>zipWith</a> for heterogeneous product
hzipWith :: (forall x. f x -> g x -> h x) -> f :* xs -> g :* xs -> h :* xs

-- | <a>zipWith3</a> for heterogeneous product
hzipWith3 :: (forall x. f x -> g x -> h x -> i x) -> f :* xs -> g :* xs -> h :* xs -> i :* xs

-- | Map elements to a monoid and combine the results.
--   
--   <pre>
--   <a>hfoldMap</a> f . <a>hmap</a> g ≡ <a>hfoldMap</a> (f . g)
--   </pre>
hfoldMap :: Monoid a => (forall x. h x -> a) -> h :* xs -> a

-- | Traverse all elements and combine the result sequentially. <tt>
--   htraverse (fmap f . g) ≡ fmap (hmap f) . htraverse g htraverse pure ≡
--   pure htraverse (Comp . fmap g . f) ≡ Comp . fmap (htraverse g) .
--   htraverse f </tt>
htraverse :: Applicative f => (forall x. g x -> f (h x)) -> g :* xs -> f (h :* xs)

-- | <a>htraverse</a> with <a>Membership</a>s.
htraverseWithIndex :: Applicative f => (forall x. Membership xs x -> g x -> f (h x)) -> g :* xs -> f (h :* xs)

-- | <a>sequence</a> analog for extensible products
hsequence :: Applicative f => Comp f h :* xs -> f (h :* xs)

-- | The dual of <a>htraverse</a>
hcollect :: (Functor f, Generate xs) => (a -> h :* xs) -> f a -> Comp f h :* xs

-- | The dual of <a>hsequence</a>
hdistribute :: (Functor f, Generate xs) => f (h :* xs) -> Comp f h :* xs

-- | <i>O(log n)</i> Pick up an elemtnt.
hlookup :: Membership xs x -> h :* xs -> h x

-- | Flipped <a>hlookup</a>
hindex :: h :* xs -> Membership xs x -> h x

-- | The legacy name for <a>pieceAt</a>

-- | <i>Deprecated: Use pieceAt</i>
sectorAt :: Functor f => Membership xs x -> (h x -> f (h x)) -> h :* xs -> f (h :* xs)

-- | The legacy name for <a>piece</a>

-- | <i>Deprecated: Use piece</i>
sector :: (Functor f, x ∈ xs) => (h x -> f (h x)) -> h :* xs -> f (h :* xs)

-- | Given a function that maps types to values, we can "collect" entities
--   all you want.
class Generate (xs :: [k])
hgenerate :: (Generate xs, Applicative f) => (forall x. Membership xs x -> f (h x)) -> f (h :* xs)

-- | Pure version of <a>hgenerate</a>.
--   
--   <pre>
--   <a>hmap</a> f (<a>htabulate</a> g) ≡ <a>htabulate</a> (f . g)
--   <a>htabulate</a> (<a>hindex</a> m) ≡ m
--   <a>hindex</a> (<a>htabulate</a> k) ≡ k
--   </pre>
htabulate :: Generate xs => (forall x. Membership xs x -> h x) -> h :* xs

-- | Guarantees the all elements satisfies the predicate.
class Forall c (xs :: [k])
hgenerateFor :: (Forall c xs, Applicative f) => proxy c -> (forall x. c x => Membership xs x -> f (h x)) -> f (h :* xs)

-- | Pure version of <a>hgenerateFor</a>.
htabulateFor :: Forall c xs => proxy c -> (forall x. c x => Membership xs x -> h x) -> h :* xs
instance Typeable (:*)
instance (c x, Forall c (Half xs), Forall c (Half (Tail xs))) => Forall c (x : xs)
instance Forall c '[]
instance (Generate (Half xs), Generate (Half (Tail xs))) => Generate (x : xs)
instance Generate '[]
instance Functor f => Extensible f (->) (:*)


module Data.Extensible.Sum

-- | The extensible sum type
--   
--   <pre>
--   (:|) :: (k -&gt; *) -&gt; [k] -&gt; *
--   </pre>
data (:|) (h :: k -> *) (s :: [k])
EmbedAt :: !(Membership xs x) -> h x -> h :| xs

-- | Change the wrapper.
hoist :: (forall x. g x -> h x) -> g :| xs -> h :| xs

-- | <i>O(1)</i> lift a value.
embed :: x ∈ xs => h x -> h :| xs

-- | Try to extract something you want.
strike :: x ∈ xs => h :| xs -> Maybe (h x)

-- | Try to extract something you want.
strikeAt :: Membership xs x -> h :| xs -> Maybe (h x)

-- | <i>O(1)</i> Naive pattern match
(<:|) :: (h x -> r) -> (h :| xs -> r) -> h :| (x : xs) -> r

-- | There is no empty union.
exhaust :: h :| [] -> r

-- | A traversal that tries to point a specific element.

-- | <i>Deprecated: Use piece instead</i>
picked :: (x ∈ xs, Applicative f) => (h x -> f (h x)) -> h :| xs -> f (h :| xs)

-- | Embed a value, but focuses on its key.
embedAssoc :: Associate k a xs => h (k :> a) -> h :| xs

-- | <i>Deprecated: This has renamed to EmbedAt</i>
instance Typeable (:|)
instance (Applicative f, Choice p) => Extensible f p (:|)

module Data.Extensible.Dictionary

-- | Reify a collection of dictionaries, as you wish.
library :: Forall c xs => Comp Dict c :* xs

-- | Forall upon a wrapper
type WrapForall c h = Forall (Instance1 c h)

-- | Composition for a class and a wrapper
class c (h x) => Instance1 c h x
instance (c (h x)) => Instance1 c h x
instance (Eq (h :| xs), WrapForall Ord h xs) => Ord (h :| xs)
instance WrapForall Eq h xs => Eq (h :| xs)
instance WrapForall Show h xs => Show (h :| xs)
instance WrapForall Monoid h xs => Monoid (h :* xs)
instance (Eq (h :* xs), WrapForall Ord h xs) => Ord (h :* xs)
instance WrapForall Eq h xs => Eq (h :* xs)
instance WrapForall Show h xs => Show (h :* xs)
instance Monoid (MergeList a)


module Data.Extensible.Inclusion

-- | Unicode alias for <a>Include</a>
type (⊆) xs ys = Include ys xs

-- | <tt>ys</tt> contains <tt>xs</tt>
type Include ys = Forall (Member ys)

-- | Reify the inclusion of type level sets.
inclusion :: Include ys xs => Membership ys :* xs

-- | <i>O(m log n)</i> Select some elements.
shrink :: xs ⊆ ys => h :* ys -> h :* xs

-- | <i>O(log n)</i> Embed to a larger union.
spread :: xs ⊆ ys => h :| xs -> h :| ys

-- | Similar to <a>Include</a>, but this focuses on keys.
type IncludeAssoc ys = Forall (Associated ys)
class Associated xs t

-- | Reify the inclusion of type level sets.
inclusionAssoc :: IncludeAssoc ys xs => Membership ys :* xs

-- | <i>O(m log n)</i> Select some elements.
shrinkAssoc :: IncludeAssoc ys xs => h :* ys -> h :* xs

-- | <i>O(log n)</i> Embed to a larger union.
spreadAssoc :: IncludeAssoc ys xs => h :| xs -> h :| ys
instance Associate k2 v xs => Associated xs (k2 ':> v)


-- | Pattern matching
module Data.Extensible.Match

-- | Retrieve the contents so that they matches and pass both to the given
--   function.
matchWith :: (forall x. f x -> g x -> r) -> f :* xs -> g :| xs -> r

-- | Turn a wrapper type into a clause for it.
newtype Match h r x
Match :: (h x -> r) -> Match h r x
runMatch :: Match h r x -> h x -> r

-- | <i>O(log n)</i> Perform pattern matching.
match :: Match h a :* xs -> h :| xs -> a

-- | Applies a function to the result of <a>Match</a>.
mapMatch :: (a -> b) -> Match h a x -> Match h b x

-- | Flipped <a>match</a>
caseOf :: h :| xs -> Match h a :* xs -> a
instance Typeable Match
instance Wrapper h => Wrapper (Match h r)


-- | Flexible records and variants Example:
--   <a>https://github.com/fumieval/extensible/blob/master/examples/records.hs</a>
module Data.Extensible.Field

-- | A <tt><a>Field</a> h (k ':&gt; v)</tt> is <tt>h v</tt>, but is along
--   with the index <tt>k</tt>.
--   
--   <pre>
--   <a>Field</a> :: (v -&gt; *) -&gt; Assoc k v -&gt; *
--   </pre>
newtype Field (h :: v -> *) (kv :: Assoc k v)
Field :: h (AssocValue kv) -> Field
getField :: Field -> h (AssocValue kv)

-- | Annotate a value by the field name.
(@=) :: Wrapper h => FieldName k -> Repr h v -> Field h (k :> v)

-- | Lifted (<a>@=</a>)
(<@=>) :: (Functor f, Wrapper h) => FieldName k -> f (Repr h v) -> Comp f (Field h) (k :> v)

-- | <tt>FieldOptic s</tt> is a type of optics that points a
--   field/constructor named <tt>s</tt>.
--   
--   The yielding fields can be <a>Lens</a>es for <a>Record</a>s and
--   <a>Prism</a>s for <a>Variant</a>s.
--   
--   <pre>
--   <a>FieldOptic</a> "foo" = Associate "foo" a xs =&gt; Lens' (<a>Record</a> xs) a
--   <a>FieldOptic</a> "foo" = Associate "foo" a xs =&gt; Prism' (<a>Variant</a> xs) a
--   </pre>
--   
--   <a>FieldOptic</a>s can be generated using <tt>mkField</tt> defined in
--   the <a>Data.Extensible.TH</a> module.
type FieldOptic k = forall f p t xs (h :: kind -> *) (v :: kind). (Extensible f p t, Associate k v xs, Labelling k p, Wrapper h) => Optic' p f (t (Field h) xs) (Repr h v)

-- | When you see this type as an argument, it expects a
--   <tt>FieldLens</tt>. This type is used to resolve the name of the field
--   internally.
type FieldName k = Optic' (LabelPhantom k) Proxy (Inextensible (Field Proxy) '[k :> ()]) ()

-- | The type of records which contain several fields.
--   
--   <pre>
--   RecordOf :: (v -&gt; *) -&gt; [Assoc k v] -&gt; *
--   </pre>
type RecordOf h = (:*) (Field h)

-- | Simple record
type Record = RecordOf Identity

-- | An empty <a>Record</a>.
emptyRecord :: Record []

-- | The dual of <a>RecordOf</a>
--   
--   <pre>
--   VariantOf :: (v -&gt; *) -&gt; [Assoc k v] -&gt; *
--   </pre>
type VariantOf h = (:|) (Field h)

-- | Simple variant
type Variant = VariantOf Identity
matchWithField :: (forall x. f x -> g x -> r) -> RecordOf f xs -> VariantOf g xs -> r
matchField :: RecordOf (Match h r) xs -> VariantOf h xs -> r
class (pk (AssocKey kv), pv (AssocValue kv)) => KeyValue pk pv kv

-- | A ghostly type which spells the field name
data LabelPhantom s a b

-- | The trivial inextensible data type
data Inextensible (h :: k -> *) (xs :: [k])
instance Profunctor (LabelPhantom s)
instance (Functor f, Profunctor p) => Extensible f p Inextensible
instance (KnownSymbol k1, Wrapper h, Show (Repr h v)) => Show (Field h (k1 ':> v))
instance Wrapper h => Wrapper (Field h)
instance (pk k2, pv v) => KeyValue pk pv (k2 ':> v)

module Data.Extensible.Effect

-- | A unit of effects
data Instruction (xs :: [Assoc k (* -> *)]) a
Instruction :: !(Membership xs kv) -> AssocValue kv a -> Instruction xs a

-- | The extensible operational monad
type Eff xs = Skeleton (Instruction xs)

-- | Lift some effect to <a>Eff</a>
liftEff :: Associate s t xs => proxy s -> t a -> Eff xs a
hoistEff :: Associate s t xs => proxy s -> (forall x. t x -> t x) -> Eff xs a -> Eff xs a
handleWith :: RecordOf (Handler m) xs -> Eff xs a -> MonadView m (Eff xs) a

-- | Transformation between effects
newtype Handler f g
Handler :: (forall a. g a -> f a) -> Handler f g
runHandler :: Handler f g -> forall a. g a -> f a

-- | Unnamed action
data Action (args :: [*]) a r
AResult :: Action [] a a
AArgument :: x -> Action xs a r -> Action (x : xs) a r
receive :: Functor f => Function xs (f a) -> Handler f (Action xs a)


module Data.Extensible.Nullable

-- | The inverse of <a>inclusion</a>.
coinclusion :: (Include ys xs, Generate ys) => Nullable (Membership xs) :* ys

-- | Extend a product and fill missing fields by <tt>Null</tt>.
wrench :: (Generate ys, xs ⊆ ys) => h :* xs -> Nullable h :* ys

-- | Narrow the range of the sum, if possible.
retrench :: (Generate ys, xs ⊆ ys) => h :| ys -> Nullable ((:|) h) xs

-- | Poly-kinded Maybe
newtype Nullable h x
Nullable :: Maybe (h x) -> Nullable h x
getNullable :: Nullable h x -> Maybe (h x)

-- | Apply a function to its content.
mapNullable :: (g x -> h y) -> Nullable g x -> Nullable h y
instance Typeable Nullable
instance Show (h x) => Show (Nullable h x)
instance Eq (h x) => Eq (Nullable h x)
instance Ord (h x) => Ord (Nullable h x)
instance Wrapper h => Wrapper (Nullable h)


module Data.Extensible.Plain

-- | Alias for plain products
type AllOf xs = Identity :* xs

-- | Alias for plain sums
type OneOf xs = Identity :| xs

-- | <i>O(log n)</i> Add a plain value to a product.
(<%) :: x -> AllOf xs -> AllOf (x : xs)

-- | Extract a plain value.
pluck :: x ∈ xs => AllOf xs -> x

-- | Embed a plain value.
bury :: x ∈ xs => x -> OneOf xs

-- | Naive pattern matching for a plain value.
(<%|) :: (x -> r) -> (OneOf xs -> r) -> OneOf (x : xs) -> r

-- | An accessor for newtype constructors.
accessing :: (Coercible x a, x ∈ xs, Extensible f p t) => (a -> x) -> Optic' p f (t Identity xs) a


module Data.Extensible.TH

-- | Generate fields using <a>itemAssoc</a>. <tt><a>mkField</a> "foo
--   Bar"</tt> defines:
--   
--   <pre>
--   foo :: FieldOptic "foo"
--   foo = itemAssoc (Proxy :: Proxy "foo")
--   _Bar :: FieldOptic <a>Bar</a>
--   _Bar = itemAssoc (Proxy :: Proxy <a>Bar</a>)
--   </pre>
mkField :: String -> DecsQ

-- | Generate newtype wrappers and lenses from type synonyms.
--   
--   <pre>
--   decFields [d|type Foo = Int|]
--   </pre>
--   
--   Generates:
--   
--   <pre>
--   newtype Foo = Foo Int
--   foo :: (Foo ∈ xs) =&gt; Lens' (AllOf xs) Int
--   foo = accessing Foo
--   </pre>
decFields :: DecsQ -> DecsQ

-- | <a>decFields</a> with additional deriving clauses
decFieldsDeriving :: [Name] -> DecsQ -> DecsQ

-- | Generate named effects from a GADT declaration.
decEffects :: DecsQ -> DecsQ


-- | Polymorphic open unions
module Data.Extensible.Union

-- | Wrap a type that has a kind <tt>* -&gt; *</tt>.
newtype K1 a f
K1 :: f a -> K1 a f
getK1 :: K1 a f -> f a
newtype Union xs a
Union :: K1 a :| xs -> Union xs a
getUnion :: Union xs a -> K1 a :| xs

-- | Transformation between effects
newtype Gondola f g
Gondola :: (forall a. g a -> f a) -> Gondola f g
runGondola :: Gondola f g -> forall a. g a -> f a
reunion :: Gondola m :* xs -> Union xs a -> m a

-- | Add a new transformation.
rung :: (forall x. f x -> g x) -> Gondola g :* fs -> Gondola g :* (f : fs)
runGondolas :: x ∈ xs => Gondola f :* xs -> x a -> f a
instance Typeable K1
instance Eq (f a) => Eq (K1 a f)
instance Ord (f a) => Ord (K1 a f)
instance Read (f a) => Read (K1 a f)
instance Wrapper (K1 a)


-- | This module just reexports everything.
module Data.Extensible
