-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Render audio signals from MIDI files or realtime messages
--   
--   This package allows to read MIDI events and to convert them to audio
--   and control signals. Included is a basic synthesizer that renders MIDI
--   to WAV (or other audio signal formats supported by SoX).
@package synthesizer-midi
@version 0.6.0.2


-- | Functions for converting MIDI controller and key values to something
--   meaningful for signal processing.
module Synthesizer.MIDI.Dimensional.ValuePlain
controllerLinear :: (C y, C v) => (T v y, T v y) -> Int -> T v y
controllerExponential :: (C y, C v) => (T v y, T v y) -> Int -> T v y
pitchBend :: (C y, C v) => y -> T v y -> Int -> T v y

-- | Convert pitch to frequency according to the default tuning in MIDI 1.0
--   Detailed Specification.
frequencyFromPitch :: C y => Pitch -> Frequency y


-- | Functions for converting MIDI controller and key values to something
--   meaningful for signal processing.
module Synthesizer.MIDI.Dimensional.Value
controllerLinear :: (C y, C v) => T v y -> (T v y, T v y) -> Int -> y
controllerExponential :: (C y, C v) => T v y -> (T v y, T v y) -> Int -> y
pitchBend :: (C y, C v) => T v y -> y -> T v y -> Int -> y

-- | Convert pitch to frequency according to the default tuning in MIDI 1.0
--   Detailed Specification.
frequencyFromPitch :: C y => Pitch -> Frequency y

module Synthesizer.MIDI.Value.BendWheelPressure
data T
Cons :: Int -> Int -> Int -> T
bend_ :: T -> Int
wheel_ :: T -> Int
pressure_ :: T -> Int
deflt :: T
bend :: T T Int
pressure :: T T Int
wheel :: T T Int
check :: C event => Channel -> event -> State T (Maybe T)
instance Show T
instance Eq T
instance NFData T


-- | Functions for converting MIDI controller and key values to something
--   meaningful for signal processing.
module Synthesizer.MIDI.Value
controllerLinear :: C y => (y, y) -> Int -> y
controllerExponential :: C y => (y, y) -> Int -> y
pitchBend :: C y => y -> y -> Int -> y
velocity :: C y => Velocity -> y

-- | Convert pitch to frequency according to the default tuning in MIDI 1.0
--   Detailed Specification.
frequencyFromPitch :: C y => Pitch -> y


-- | Combine pitchbend and modulation in one data type.
module Synthesizer.MIDI.Value.BendModulation

-- | <a>bend</a> is a frequency factor and <a>depth</a> is a modulation
--   depth to be interpreted by the instrument.
data T a
Cons :: a -> a -> T a
bend :: T a -> a
depth :: T a -> a
deflt :: C a => T a
force :: T a -> T a

-- | Multiply the pitch bend by a given factor. This way you can e.g. shift
--   the pitch bend from around 1 to the actual frequency.
shift :: C a => a -> T a -> T a
fromBendWheelPressure :: (C a, C a) => Int -> a -> a -> T -> T a
instance Show a => Show (T a)
instance Eq a => Eq (T a)
instance Storable a => Storable (T a)
instance Traversable T
instance Foldable T
instance Applicative T
instance Functor T
instance NFData a => NFData (T a)

module Synthesizer.MIDI.EventList
type StrictTime = Integer
type LazyTime = T Integer
type Filter event = State (T StrictTime [event])

-- | We turn the strict time values into lazy ones according to the breaks
--   by our beat. However for the laziness breaks we ignore the events that
--   are filtered out. That is we loose laziness granularity but hopefully
--   gain efficiency by larger blocks.
getSlice :: (event -> Maybe a) -> Filter event (T StrictTime [a])
type Channel = Channel
type Controller = Controller
type Pitch = Pitch
type Velocity = Velocity
type Program = Program
getControllerEvents :: C event => Channel -> Controller -> Filter event (T StrictTime [Int])
data NoteBoundary a
NoteBoundary :: Pitch -> Velocity -> a -> NoteBoundary a
AllNotesOff :: NoteBoundary a
data Note
Note :: Program -> Pitch -> Velocity -> LazyTime -> Note
case_ :: Maybe a -> (a -> b) -> Maybe b
getNoteEvents :: C event => Channel -> Filter event (T StrictTime [Either Program (NoteBoundary Bool)])
checkNoteEvent :: C event => Channel -> event -> Maybe (Either Program (NoteBoundary Bool))
embedPrograms :: Program -> T StrictTime [Either Program (NoteBoundary Bool)] -> T StrictTime [NoteBoundary (Maybe Program)]
embedProgramState :: Either Program (NoteBoundary Bool) -> State Program (Maybe (NoteBoundary (Maybe Program)))
matchNoteEvents :: T StrictTime [NoteBoundary (Maybe Program)] -> T StrictTime [Note]
matchNoteEventsCore :: (noteBnd -> Maybe (noteBnd -> Bool, LazyTime -> Note)) -> T StrictTime [noteBnd] -> T StrictTime [Note]

-- | Search for specific event, return its time stamp and remove it.
durationRemove :: C time => (body -> Bool) -> T time [body] -> (T time, T time [body])
durationRemoveTB :: C time => (body -> Bool) -> T time [body] -> (T time, T time [body])
makeInstrumentArray :: [instr] -> Array Program instr
getInstrumentFromArray :: Array Program instr -> Program -> Program -> instr
instance Eq a => Eq (NoteBoundary a)
instance Show a => Show (NoteBoundary a)
instance Eq Note
instance Show Note


-- | Convert MIDI events of a MIDI controller to a control signal.
module Synthesizer.MIDI.Generic
replicateLong :: Write sig y => StrictTime -> y -> sig y
piecewiseConstant :: Write sig y => T StrictTime y -> sig y
piecewiseConstantInit :: Write sig y => y -> T StrictTime y -> sig y
piecewiseConstantInitWith :: Write sig c => (y -> c) -> c -> T StrictTime [y] -> sig c
type Instrument y signal = y -> y -> LazyTime -> signal
type Bank y signal = Program -> Instrument y signal

-- | Instrument parameters are: velocity from -1 to 1 (0 is the normal
--   pressure, no pressure aka NoteOff is not supported), frequency is
--   given in Hertz
renderInstrument :: C y => Bank y signal -> Note -> signal
renderInstrumentIgnoreProgram :: C y => Instrument y signal -> Note -> signal

-- | Turn an event list with bundles of elements into an event list with
--   single events. ToDo: Move to event-list package?
flatten :: (Monoid signal, C time) => T time [signal] -> T time signal
applyModulation :: (Transform signal, NormalForm signal) => signal -> Modulator (signal -> instr, note) (instr, note)

-- | We have to evaluate the head value at each <a>drop</a> in order to
--   avoid growing thunks that lead to a space leak.
evaluateVectorHead :: NormalForm signal => signal -> t -> t
advanceModulation :: (Transform signal, NormalForm signal) => LazyTime -> State signal LazyTime
advanceModulationChunk :: (Transform signal, NormalForm signal) => StrictTime -> State signal StrictTime
advanceModulationChunkStrict :: (Transform signal, NormalForm signal) => StrictTime -> State signal StrictTime
advanceModulationChunkPC :: NFData body => StrictTime -> State (T StrictTime body) StrictTime
type FilterSequence event signal = Filter event (T ShortStrictTime signal)

-- | The state action for the time should just return the argument time.
--   However we need this time (or alternatively another result type) for
--   triggering the <a>drop</a> in <a>advanceModulationChunk</a>. Without
--   this strict evaluation, the drop will be delayed until the control
--   curve is actually needed.
data Modulator note signal
Modulator :: state -> (StrictTime -> State state StrictTime) -> (note -> State state signal) -> Modulator note signal
applyModulator :: Modulator a b -> T StrictTime [a] -> T StrictTime [b]
sequenceCore :: (C event, Monoid signal) => Channel -> Program -> Modulator Note signal -> FilterSequence event signal
errorNoProgram :: Program
sequence :: (C event, Monoid signal, C y) => Channel -> Instrument y signal -> FilterSequence event signal
sequenceModulated :: (C event, Transform ctrl, NormalForm ctrl, Monoid signal, C y) => ctrl -> Channel -> (ctrl -> Instrument y signal) -> FilterSequence event signal
sequenceMultiModulated :: (C event, Monoid signal, C y) => Channel -> instrument -> Modulator (instrument, Note) (Instrument y signal, Note) -> FilterSequence event signal
sequenceMultiProgram :: (C event, Monoid signal, C y) => Channel -> Program -> [Instrument y signal] -> FilterSequence event signal
sequenceModulatedMultiProgram :: (Transform ctrl, NormalForm ctrl, C event, Monoid signal, C y) => ctrl -> Channel -> Program -> [ctrl -> Instrument y signal] -> FilterSequence event signal
instance Arrow Modulator
instance Category Modulator


-- | Convert MIDI events of a MIDI controller to a control signal.
module Synthesizer.MIDI.Storable
chunkSizesFromLazyTime :: LazyTime -> T ChunkSize
piecewiseConstant :: Storable y => T StrictTime y -> T y
piecewiseConstantInit :: Storable y => y -> T StrictTime y -> T y
piecewiseConstantInitWith :: Storable c => (y -> c) -> c -> T StrictTime [y] -> T c
controllerLinear :: (C event, Storable y, C y) => Channel -> Controller -> (y, y) -> y -> Filter event (T y)
controllerExponential :: (C event, Storable y, C y) => Channel -> Controller -> (y, y) -> y -> Filter event (T y)

-- | <tt>pitchBend channel range center</tt>: emits frequencies on an
--   exponential scale from <tt>center/range</tt> to <tt>center*range</tt>.
pitchBend :: (C event, Storable y, C y) => Channel -> y -> y -> Filter event (T y)
channelPressure :: (C event, Storable y, C y) => Channel -> y -> y -> Filter event (T y)
bendWheelPressure :: (C event, Storable y, C y, C y) => Channel -> Int -> y -> y -> y -> Filter event (T y)
type Instrument y yv = Instrument y (T yv)
type Bank y yv = Bank y (T yv)
sequenceCore :: (C event, Storable yv, C yv) => ChunkSize -> Channel -> Program -> Modulator Note (T yv) -> Filter event (T yv)
sequence :: (C event, Storable yv, C yv, C y) => ChunkSize -> Channel -> Instrument y yv -> Filter event (T yv)
sequenceModulated :: (C event, Storable c, Storable yv, C yv, C y) => ChunkSize -> T c -> Channel -> (T c -> Instrument y yv) -> Filter event (T yv)
sequenceMultiModulated :: (C event, Storable yv, C yv, C y) => ChunkSize -> Channel -> instrument -> Modulator (instrument, Note) (Instrument y yv, Note) -> Filter event (T yv)
applyModulation :: Storable c => T c -> Modulator (T c -> instr, note) (instr, note)
advanceModulationLazy :: Storable a => LazyTime -> State (T a) LazyTime
advanceModulationStrict :: Storable a => LazyTime -> State (T a) LazyTime
advanceModulationChunky :: Storable a => LazyTime -> State (T a) LazyTime
sequenceMultiProgram :: (C event, Storable yv, C yv, C y) => ChunkSize -> Channel -> Program -> [Instrument y yv] -> Filter event (T yv)

-- | Instrument parameters are: velocity from -1 to 1 (0 is the normal
--   pressure, no pressure aka NoteOff is not supported), frequency is
--   given in Hertz
renderInstrument :: C y => Bank y signal -> Note -> signal
renderInstrumentIgnoreProgram :: C y => Instrument y signal -> Note -> signal

-- | We have to evaluate the head value at each <a>drop</a> in order to
--   avoid growing thunks that lead to a space leak.
evaluateVectorHead :: NormalForm signal => signal -> t -> t
advanceModulationChunk :: (Transform signal, NormalForm signal) => StrictTime -> State signal StrictTime

module Synthesizer.MIDI.CausalIO.Process
type Events event = T StrictTime [event]
slice :: C event => (event -> Maybe Int) -> (Int -> y) -> y -> T (Events event) (T ShortStrictTime y)
controllerLinear :: (C event, C y) => Channel -> Controller -> (y, y) -> y -> T (Events event) (T ShortStrictTime y)
controllerExponential :: (C event, C y) => Channel -> Controller -> (y, y) -> y -> T (Events event) (T ShortStrictTime y)
pitchBend :: (C event, C y) => Channel -> y -> y -> T (Events event) (T ShortStrictTime y)
channelPressure :: (C event, C y) => Channel -> y -> y -> T (Events event) (T ShortStrictTime y)
bendWheelPressure :: (C event, C y, C y) => Channel -> Int -> y -> y -> T (Events event) (T ShortStrictTime (T y))
constant :: Arrow arrow => y -> arrow (Events event) (T ShortStrictTime y)
type Instrument y chunk = y -> y -> T GateChunk chunk
type Bank y chunk = Program -> Instrument y chunk
type GateChunk = Chunk Velocity
noteEvents :: (C event, Arrow arrow) => Channel -> arrow (Events event) (Events (Either Program (NoteBoundary Bool)))
embedPrograms :: Program -> T (Events (Either Program (NoteBoundary Bool))) (Events (NoteBoundary (Maybe Program)))
applyInstrument :: Arrow arrow => (Program -> Velocity -> Pitch -> T GateChunk chunk) -> arrow (Events (NoteBoundary (NoteId, Maybe Program))) (T NoteOffList (Events (T NoteOffList chunk)))
applyModulatedInstrument :: (Arrow arrow, Read ctrl) => (Program -> Velocity -> Pitch -> T (T GateChunk ctrl) chunk) -> arrow (T (Events (NoteBoundary (NoteId, Maybe Program))) ctrl) (T (T NoteOffList ctrl) (Events (T (T NoteOffList ctrl) chunk)))
flattenControlSchedule :: (Monoid chunk, Arrow arrow) => arrow (T ctrl (T StrictTime [T ctrl chunk])) (T ctrl (T StrictTime (T ctrl chunk)))
applyModulation :: (Transform ctrl, NormalForm ctrl, Read chunk, Monoid time, C time) => T (T ctrl (T time (T ctrl chunk))) (T time chunk)
arrangeStorable :: (Arrow arrow, Storable a, C a) => arrow (T StrictTime (Vector a)) (Vector a)
sequenceCore :: (C event, Monoid chunk, Read chunk, C y) => Channel -> Bank y chunk -> T (Events event) (T StrictTime chunk)
sequenceModulated :: (C event, Monoid chunk, Read chunk, Transform ctrl, NormalForm ctrl, C y) => Channel -> ModulatedBank y ctrl chunk -> T (T (Events event) ctrl) (T StrictTime chunk)
sequenceModulatedMultiProgram :: (C event, Monoid chunk, Read chunk, Transform ctrl, NormalForm ctrl, C y) => Channel -> Program -> ModulatedBank y ctrl chunk -> T (T (Events event) ctrl) (T StrictTime chunk)

-- | may replace the other functions
sequenceModulatedMultiProgramVelocityPitch :: (C event, Monoid chunk, Read chunk, Transform ctrl, NormalForm ctrl) => Channel -> Program -> (Program -> Velocity -> Pitch -> T (T GateChunk ctrl) chunk) -> T (T (Events event) ctrl) (T StrictTime chunk)
sequenceStorable :: (C event, Storable a, C a, C y) => Channel -> Bank y (Vector a) -> T (Events event) (Vector a)
initWith :: (y -> c) -> c -> T (Events y) (T ShortStrictTime c)
mapMaybe :: (Arrow arrow, Functor f) => (a -> Maybe b) -> arrow (f [a]) (f [b])
instance Show NoteId
instance Eq NoteId
instance Ord NoteId
instance Eq a => Eq (NoteBoundary a)
instance Show a => Show (NoteBoundary a)
instance Transform NoteOffList
instance Monoid NoteOffList
instance NormalForm NoteOffList
instance Read NoteOffList


-- | Convert MIDI events of a MIDI controller to a control signal.
module Synthesizer.MIDI.PiecewiseConstant
type T = T StrictTime
duration :: T y -> LazyTime
zipWith :: C time => (a -> b -> c) -> T time a -> T time b -> T time c
initWith :: (y -> c) -> c -> T StrictTime [y] -> T c
controllerLinear :: (C event, C y) => Channel -> Controller -> (y, y) -> y -> Filter event (T y)
controllerExponential :: (C event, C y) => Channel -> Controller -> (y, y) -> y -> Filter event (T y)

-- | <tt>pitchBend channel range center</tt>: emits frequencies on an
--   exponential scale from <tt>center/range</tt> to <tt>center*range</tt>.
pitchBend :: (C event, C y) => Channel -> y -> y -> Filter event (T y)
channelPressure :: (C event, C y) => Channel -> y -> y -> Filter event (T y)
bendWheelPressure :: (C event, C y, C y) => Channel -> Int -> y -> y -> Filter event (T (T y))

-- | This one is certainly not as efficient as <a>bendWheelPressure</a>
--   since it first slices the event list and then zips the slices
--   together.
bendWheelPressureZip :: (C event, C y, C y) => Channel -> Int -> y -> y -> Filter event (T (T y))


-- | Treat a stream of MIDI events as parallel streams of MIDI controller
--   events.
module Synthesizer.MIDI.PiecewiseConstant.ControllerSet
data T key a
Cons :: Map key a -> T StrictTime [(key, a)] -> T key a
initial :: T key a -> Map key a
stream :: T key a -> T StrictTime [(key, a)]
mapStream :: (T StrictTime [(key, a)] -> T StrictTime [(key, a)]) -> T key a -> T key a
data Controller
Controller :: Controller -> Controller
PitchBend :: Controller
Pressure :: Controller
fromChannel :: C event => Channel -> Filter event (T Controller Int)
maybeController :: C event => Channel -> event -> Maybe (Controller, Int)
controllerLinear :: C y => Controller -> (y, y) -> y -> Filter (T y)
controllerExponential :: C y => Controller -> (y, y) -> y -> Filter (T y)

-- | <tt>pitchBend channel range center</tt>: emits frequencies on an
--   exponential scale from <tt>center/range</tt> to <tt>center*range</tt>.
pitchBend :: C y => y -> y -> Filter (T y)
channelPressure :: C y => y -> y -> Filter (T y)
bendWheelPressure :: (C y, C y) => Int -> y -> y -> Filter (T (T y))
checkBendWheelPressure :: (Controller, Int) -> State T (Maybe T)
bendWheelPressureZip :: (C y, C y) => Int -> y -> y -> Filter (T (T y))
instance (Show key, Show a) => Show (T key a)
instance Show Controller
instance Eq Controller
instance Ord Controller
instance Ord key => Transform (T key y)
instance (NFData key, NFData a) => NormalForm (T key a)
instance Monoid (T key y)
instance Read (T key a)
instance NFData Controller

module Synthesizer.MIDI.CausalIO.ControllerSelection
fromChannel :: (C event, Arrow arrow) => Channel -> arrow (T StrictTime [event]) (T StrictTime [(Controller, Int)])
filter :: [T a] -> T (T StrictTime [(Controller, Int)]) (T Int a)
data T a
Cons :: Controller -> (Int -> a) -> a -> T a
controllerLinear :: C y => Controller -> (y, y) -> y -> T y
controllerExponential :: C y => Controller -> (y, y) -> y -> T y
pitchBend :: C y => y -> y -> T y
channelPressure :: C y => y -> y -> T y

module Synthesizer.MIDI.CausalIO.ControllerSet
type T arrow y = arrow (T Controller Int) (T ShortStrictTime y)
fromChannel :: C event => Channel -> T (T StrictTime [event]) (T Controller Int)
slice :: Arrow arrow => Controller -> (Int -> y) -> y -> T arrow y
data Controller
Controller :: Controller -> Controller
PitchBend :: Controller
Pressure :: Controller
controllerLinear :: (C y, Arrow arrow) => Controller -> (y, y) -> y -> T arrow y
controllerExponential :: (C y, Arrow arrow) => Controller -> (y, y) -> y -> T arrow y
pitchBend :: (C y, Arrow arrow) => y -> y -> T arrow y
channelPressure :: (C y, Arrow arrow) => y -> y -> T arrow y
bendWheelPressure :: (C y, C y, Arrow arrow) => Int -> y -> y -> T arrow (T y)


-- | Convert MIDI events of a MIDI controller to a control signal.
module Synthesizer.MIDI.Dimensional
type Signal s v y signal = AmpSignal s (Dimensional v y) signal
type AmpSignal s amp signal = T (Phantom s) amp signal

-- | This type ensures that all signals generated from the event list share
--   the same sample rate.
newtype Filter event s u t a
Filter :: (Filter event (T s u t a)) -> Filter event s u t a
runFilter :: C event => T StrictTime [event] -> Filter event s u t a -> T s u t a
piecewiseConstant :: Write sig y => T rate amp (T y) -> T rate amp (sig y)
controllerLinear :: (C event, C y, Ord y, C u, C v) => Channel -> Controller -> (T v y, T v y) -> T v y -> Filter event s u t (Signal s v y (T y))
controllerExponential :: (C event, C y, Ord y, C u, C v) => Channel -> Controller -> (T v y, T v y) -> T v y -> Filter event s u t (Signal s v y (T y))

-- | <tt>pitchBend channel range center</tt>: emits frequencies on an
--   exponential scale from <tt>center/range</tt> to <tt>center*range</tt>.
pitchBend :: (C event, C y, Ord y, C u, C v) => Channel -> y -> T v y -> Filter event s u t (Signal s v y (T y))
channelPressure :: (C event, C y, Ord y, C u, C v) => Channel -> T v y -> T v y -> Filter event s u t (Signal s v y (T y))
bendWheelPressure :: (C event, Write sig q, Transform sig q, C q, C q, C q q, C u) => Channel -> Int -> T (Recip u) q -> q -> q -> Filter event s u q (Signal s Scalar q (sig q))
type LazyTime s = T (Phantom s) Abstract T
type Instrument s u v q signal = ModulatedInstrument s u q (Signal s v q signal)
type ModulatedInstrument s u q signal = q -> T (Recip u) q -> T s u q (LazyTime s -> signal)
type Bank s u q signal = Program -> ModulatedInstrument s u q signal
chunkySizeFromLazyTime :: LazyTime -> T
renderInstrument :: C q => Bank s Time q signal -> Note -> T s Time q signal

-- | Instrument parameters are: velocity from -1 to 1 (0 is the normal
--   pressure, no pressure aka NoteOff is not supported), frequency is
--   given in Hertz
makeInstrumentSounds :: C q => Bank s Time q signal -> T time [Note] -> T s Time q (T time [signal])
sequence :: (C event, RealFrac q, Storable y, C q y, C q, C v) => ChunkSize -> T v q -> Channel -> Instrument s Time v q (T y) -> Filter event s Time q (Signal s v q (T y))
sequenceModulated :: (C event, Transform ctrl, NormalForm ctrl, RealFrac q, Storable y, C q y, C q, C v) => ChunkSize -> T v q -> Channel -> ModulatedInstrument s Time q (AmpSignal s amp ctrl -> Signal s v q (T y)) -> Filter event s Time q (AmpSignal s amp ctrl -> Signal s v q (T y))
sequenceModulated2 :: (C event, Transform ctrl0, NormalForm ctrl0, Transform ctrl1, NormalForm ctrl1, RealFrac q, Storable y, C q y, C q, C v) => ChunkSize -> T v q -> Channel -> ModulatedInstrument s Time q (AmpSignal s amp0 ctrl0 -> AmpSignal s amp1 ctrl1 -> Signal s v q (T y)) -> Filter event s Time q (AmpSignal s amp0 ctrl0 -> AmpSignal s amp1 ctrl1 -> Signal s v q (T y))
sequenceMultiModulated :: (C event, RealFrac q, Storable y, C q y, C q, C v) => ChunkSize -> T v q -> Channel -> ModulatedInstrument s Time q instrument -> Filter event s Time q (Modulator instrument (Signal s v q (T y))) -> Filter event s Time q (Signal s v q (T y))
prepareTones :: (C event, RealFrac q, C q) => Channel -> Program -> Bank s Time q signal -> Filter event s Time q (T StrictTime [signal])
applyModulation :: (Transform signal, NormalForm signal) => AmpSignal s amp signal -> Modulator (AmpSignal s amp signal -> body) body
applyModulator :: Modulator a b -> T StrictTime [a] -> T StrictTime [b]
renderSequence :: (Storable y, C q y, C u, C q) => ChunkSize -> T u q -> T StrictTime [Signal s u q (T y)] -> Signal s u q (T y)
advanceModulationChunky :: (Transform signal, NormalForm signal) => LazyTime -> State (AmpSignal s amp signal) LazyTime
advanceModulationChunk :: (Transform signal, NormalForm signal) => StrictTime -> State (AmpSignal s amp signal) StrictTime
sequenceMultiProgram :: (C event, RealFrac q, Storable y, C q y, C q, C v) => ChunkSize -> T v q -> Channel -> Program -> [Instrument s Time v q (T y)] -> Filter event s Time q (Signal s v q (T y))
instance Applicative (Filter event s u t)
instance Functor (Filter event s u t)

module Synthesizer.MIDI.Dimensional.Example.Instrument
type Real = Double
ping :: Instrument s Time Voltage Real (T Real)
pingReleaseEnvelope :: Real -> T s Time Real (LazyTime s -> T (Phantom s) (Dimensional Scalar Real) (T Real))
pingRelease :: Instrument s Time Voltage Real (T Real)
pingReleaseFM :: ModulatedInstrument s Time Real (Signal s Scalar Real (T Real) -> Signal s Voltage Real (T Real))
pingStereoDetuneFM :: ModulatedInstrument s Time Real (Signal s Scalar Real (T Real) -> Signal s Scalar Real (T Real) -> Signal s Voltage Real (T (T Real)))
stringReleaseEnvelope :: Real -> T s Time Real (LazyTime s -> T (Phantom s) (Dimensional Scalar Real) (T Real))
string :: ModulatedInstrument s Time Real (Signal s Voltage Real (T (T Real)))

module Synthesizer.MIDI.Example.Instrument
type Real = Float
sampleRate :: Num a => a
chunkSize :: ChunkSize
amplitudeFromVelocity :: Real -> Real
ping :: Real -> Real -> T Real
pingDur :: Instrument Real Real
pingCausal :: Instrument Real (Vector Real)
pingReleaseEnvelope :: Real -> LazyTime -> T Real
pingRelease :: Instrument Real Real
pingStereoRelease :: Instrument Real (T Real)
pingReleaseEnvelopeCausal :: Real -> T GateChunk (Vector Real)
pingReleaseCausal :: Instrument Real (Vector Real)
tine :: Instrument Real Real
tineStereo :: Instrument Real (T Real)
softStringReleaseEnvelope :: Real -> LazyTime -> T Real
softString :: Instrument Real (T Real)
softStringReleaseEnvelopeCausal :: Real -> LazyTime -> T Real
softStringReleaseEnvelopeCausalProcess :: Real -> T Bool Real
softStringCausalProcess :: Real -> T Real (T Real)
softStringCausal :: Instrument Real (T Real)
stringStereoFM :: T Real -> Instrument Real (T Real)
stringStereoDetuneFM :: T Real -> T Real -> Instrument Real (T Real)
sampledSoundGenerator :: (Real, T Real) -> Real -> T Real
sampledSound :: (Real, T Real) -> Instrument Real Real
sampledSoundDetuneStereo :: Real -> (Real, T Real) -> Instrument Real (T Real)
sampleReleaseEnvelope :: Real -> Real -> LazyTime -> T Real
sampledSoundDetuneStereoRelease :: Real -> Real -> (Real, T Real) -> Instrument Real (T Real)
readPianoSample :: IO (Real, T Real)
readStringSample :: IO (Real, T Real)

-- | Resample a sampled sound with a smooth loop using our time
--   manipulation algorithm. Time is first controlled linearly, then
--   switches to a sine or triangular control. Loop start must be large
--   enough in order provide enough spare data for interpolation at the
--   beginning and loop start plus length must preserve according space at
--   the end. One period is enough space for linear interpolation. The
--   infinite sound we generate is not just a cycle, that uses bounded
--   space. Instead we need to compute all the time. In order to avoid
--   duplicate interpolation, we have merged resampling and time looping.
sampledSoundTimeLoop :: (Real -> Real -> Real -> Real -> T Real) -> (Real, T Real) -> Real -> Real -> Instrument Real Real
loopTimeModSine :: Real -> Real -> Real -> Real -> T Real
loopTimeModZigZag :: Real -> Real -> Real -> Real -> T Real
timeModulatedSample :: (Real, T Real) -> T Real -> T Real -> T Real -> Instrument Real Real
colourNoise :: T Real -> T Real -> Instrument Real Real
toneFromNoise :: T Real -> T Real -> Instrument Real Real
toneFromFilteredNoise :: T Real -> T Real -> T Real -> T Real -> Instrument Real Real
