-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Print text to terminal with colors and effects
--   
@package rainbow
@version 0.26.0.6


-- | All the main types in Rainbow. Using this module you can specify that
--   you want different formatting for 8- and 256-color terminals. Many of
--   the names in this module conflict with the names in <a>Rainbow</a>, so
--   it's probably best to <tt>import</tt> this module <tt>qualified</tt>.
module Rainbow.Types

-- | A color; a <a>Nothing</a> value means that the terminal's default
--   color is used. The type of the <a>Maybe</a> generally will be an
--   <a>Enum8</a> to represent one of 8 colors, or a <a>Word8</a> to
--   represent one of 256 colors.
newtype Color a
Color :: (Maybe a) -> Color a

-- | Takes the last non-Nothing Color. <a>mempty</a> is no color.

-- | A simple enumeration for eight values. Represents eight colors.
data Enum8
E0 :: Enum8
E1 :: Enum8
E2 :: Enum8
E3 :: Enum8
E4 :: Enum8
E5 :: Enum8
E6 :: Enum8
E7 :: Enum8
enum8toWord8 :: Enum8 -> Word8
black :: Enum8
red :: Enum8
green :: Enum8
yellow :: Enum8
blue :: Enum8
magenta :: Enum8
cyan :: Enum8
white :: Enum8
grey :: Word8
brightRed :: Word8
brightGreen :: Word8
brightYellow :: Word8
brightBlue :: Word8
brightMagenta :: Word8
brightCyan :: Word8
brightWhite :: Word8

-- | Text formatting such as bold, italic, etc.
data Format
Format :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Format
_bold :: Format -> Bool
_faint :: Format -> Bool
_italic :: Format -> Bool
_underline :: Format -> Bool
_blink :: Format -> Bool
_inverse :: Format -> Bool
_invisible :: Format -> Bool
_strikeout :: Format -> Bool
underline :: Lens' Format Bool
strikeout :: Lens' Format Bool
italic :: Lens' Format Bool
invisible :: Lens' Format Bool
inverse :: Lens' Format Bool
faint :: Lens' Format Bool
bold :: Lens' Format Bool
blink :: Lens' Format Bool

-- | For each field, the resulting field is True if either field is True.
--   For <a>mempty</a>, every field is False.

-- | The foreground and background color, and the <a>Format</a>. This
--   represents all colors and formatting attributes for either an 8- or
--   256-color terminal.
data Style a
Style :: Color a -> Color a -> Format -> Style a
_fore :: Style a -> Color a
_back :: Style a -> Color a
_format :: Style a -> Format
format :: Lens' (Style a_ab0G) Format
fore :: Lens' (Style a_ab0G) (Color a_ab0G)
back :: Lens' (Style a_ab0G) (Color a_ab0G)

-- | Uses the underlying <a>Monoid</a> instances for <a>Color</a> and
--   <a>Format</a>.

-- | Holds the <a>Style</a> for both 8- and 256-color terminals.
data Scheme
Scheme :: Style Enum8 -> Style Word8 -> Scheme
_style8 :: Scheme -> Style Enum8
_style256 :: Scheme -> Style Word8
style8 :: Lens' Scheme (Style Enum8)
style256 :: Lens' Scheme (Style Word8)

-- | A chunk is some textual data coupled with a description of what color
--   the text is, attributes like whether it is bold or underlined, etc.
--   The chunk knows what foreground and background colors and what
--   attributes to use for both an 8 color terminal and a 256 color
--   terminal.
data Chunk a
Chunk :: Scheme -> a -> Chunk a
_scheme :: Chunk a -> Scheme
_yarn :: Chunk a -> a

-- | Uses the underlying <a>Monoid</a> instances for the <a>Style</a> and
--   for the particular <a>_yarn</a>. Therefore <a>mempty</a> will have no
--   formatting and no colors and will generally have no text, though
--   whether or not there is any text depends on the <a>mempty</a> for the
--   type of the <a>_yarn</a>.

-- | Creates a <a>Chunk</a> with no formatting and with the given text.
chunk :: a -> Chunk a
yarn :: Lens (Chunk a_abys) (Chunk a_abIn) a_abys a_abIn
scheme :: Lens' (Chunk a_abys) Scheme

-- | Stores colors that may affect 8-color terminals, 256-color terminals,
--   both, or neither.
data Radiant
Radiant :: Color Enum8 -> Color Word8 -> Radiant
_color8 :: Radiant -> Color Enum8
_color256 :: Radiant -> Color Word8

-- | Uses the underlying <a>Monoid</a> instance for the <a>Color</a>s. Thus
--   the last non-<a>Nothing</a> <a>Color</a> is used. This can be useful
--   to specify one color for 8-color terminals and a different color for
--   256-color terminals.
color8 :: Lens' Radiant (Color Enum8)
color256 :: Lens' Radiant (Color Word8)
instance Typeable Radiant
instance Eq Radiant
instance Ord Radiant
instance Show Radiant
instance Generic Radiant
instance Datatype D1Radiant
instance Constructor C1_0Radiant
instance Selector S1_0_0Radiant
instance Selector S1_0_1Radiant
instance Monoid Radiant
instance Typeable Chunk
instance Eq a => Eq (Chunk a)
instance Show a => Show (Chunk a)
instance Ord a => Ord (Chunk a)
instance Generic (Chunk a)
instance Functor Chunk
instance Foldable Chunk
instance Traversable Chunk
instance Datatype D1Chunk
instance Constructor C1_0Chunk
instance Selector S1_0_0Chunk
instance Selector S1_0_1Chunk
instance Monoid a => Monoid (Chunk a)
instance Monoid Scheme
instance Typeable Scheme
instance Eq Scheme
instance Ord Scheme
instance Show Scheme
instance Generic Scheme
instance Datatype D1Scheme
instance Constructor C1_0Scheme
instance Selector S1_0_0Scheme
instance Selector S1_0_1Scheme
instance Monoid (Style a)
instance Typeable Style
instance Show a => Show (Style a)
instance Eq a => Eq (Style a)
instance Ord a => Ord (Style a)
instance Generic (Style a)
instance Functor Style
instance Foldable Style
instance Traversable Style
instance Datatype D1Style
instance Constructor C1_0Style
instance Selector S1_0_0Style
instance Selector S1_0_1Style
instance Selector S1_0_2Style
instance Monoid Format
instance Typeable Enum8
instance Typeable Format
instance Eq Enum8
instance Ord Enum8
instance Show Enum8
instance Bounded Enum8
instance Enum Enum8
instance Generic Enum8
instance Show Format
instance Eq Format
instance Ord Format
instance Generic Format
instance Datatype D1Enum8
instance Constructor C1_0Enum8
instance Constructor C1_1Enum8
instance Constructor C1_2Enum8
instance Constructor C1_3Enum8
instance Constructor C1_4Enum8
instance Constructor C1_5Enum8
instance Constructor C1_6Enum8
instance Constructor C1_7Enum8
instance Datatype D1Format
instance Constructor C1_0Format
instance Selector S1_0_0Format
instance Selector S1_0_1Format
instance Selector S1_0_2Format
instance Selector S1_0_3Format
instance Selector S1_0_4Format
instance Selector S1_0_5Format
instance Selector S1_0_6Format
instance Selector S1_0_7Format
instance Monoid (Color a)
instance Wrapped (Color a0)
instance Color a1 ~ t0 => Rewrapped (Color a0) t0
instance Typeable Color
instance Eq a => Eq (Color a)
instance Show a => Show (Color a)
instance Ord a => Ord (Color a)
instance Generic (Color a)
instance Functor Color
instance Foldable Color
instance Traversable Color
instance Datatype D1Color
instance Constructor C1_0Color


-- | This module contains functions that convert a <a>Chunk</a> into
--   <a>ByteString</a>s. Ordinarily everything you need from this module is
--   exported from <a>Rainbow</a>.
module Rainbow.Translate

-- | Items that can be rendered. <a>render</a> returns a difference list.
class Renderable a
render :: Renderable a => a -> [ByteString] -> [ByteString]

-- | Converts a strict Text to a UTF-8 ByteString.

-- | Converts a lazy Text to UTF-8 ByteStrings.

-- | Strict ByteString is left as-is.

-- | Lazy ByteString is converted to strict chunks.

-- | Strings are converted first to a strict Text and then to a strict
--   ByteString.
single :: Char -> [ByteString] -> [ByteString]
escape :: [ByteString] -> [ByteString]
csi :: [ByteString] -> [ByteString]
sgr :: ([ByteString] -> [ByteString]) -> [ByteString] -> [ByteString]
params :: Show a => [a] -> [ByteString] -> [ByteString]
sgrSingle :: Word -> [ByteString] -> [ByteString]
sgrDouble :: Word -> Word -> [ByteString] -> [ByteString]
normalDefault :: [ByteString] -> [ByteString]
bold :: [ByteString] -> [ByteString]
faint :: [ByteString] -> [ByteString]
italic :: [ByteString] -> [ByteString]
underline :: [ByteString] -> [ByteString]
blink :: [ByteString] -> [ByteString]
inverse :: [ByteString] -> [ByteString]
invisible :: [ByteString] -> [ByteString]
strikeout :: [ByteString] -> [ByteString]
foreBlack :: [ByteString] -> [ByteString]
foreRed :: [ByteString] -> [ByteString]
foreGreen :: [ByteString] -> [ByteString]
foreYellow :: [ByteString] -> [ByteString]
foreBlue :: [ByteString] -> [ByteString]
foreMagenta :: [ByteString] -> [ByteString]
foreCyan :: [ByteString] -> [ByteString]
foreWhite :: [ByteString] -> [ByteString]
foreDefault :: [ByteString] -> [ByteString]
backBlack :: [ByteString] -> [ByteString]
backRed :: [ByteString] -> [ByteString]
backGreen :: [ByteString] -> [ByteString]
backYellow :: [ByteString] -> [ByteString]
backBlue :: [ByteString] -> [ByteString]
backMagenta :: [ByteString] -> [ByteString]
backCyan :: [ByteString] -> [ByteString]
backWhite :: [ByteString] -> [ByteString]
backDefault :: [ByteString] -> [ByteString]
fore256 :: Word8 -> [ByteString] -> [ByteString]
back256 :: Word8 -> [ByteString] -> [ByteString]
foreColor8 :: Enum8 -> [ByteString] -> [ByteString]
backColor8 :: Enum8 -> [ByteString] -> [ByteString]
renderFormat :: Format -> [ByteString] -> [ByteString]
renderStyle8 :: Style Enum8 -> [ByteString] -> [ByteString]
renderStyle256 :: Style Word8 -> [ByteString] -> [ByteString]
toByteStringsColors0 :: Renderable a => Chunk a -> [ByteString] -> [ByteString]
toByteStringsColors8 :: Renderable a => Chunk a -> [ByteString] -> [ByteString]
toByteStringsColors256 :: Renderable a => Chunk a -> [ByteString] -> [ByteString]

-- | Spawns a subprocess to read the output of <tt>tput colors</tt>. If
--   this says there are at least 256 colors are available, returns
--   <a>toByteStringsColors256</a>. Otherwise, if there are at least 8
--   colors available, returns <a>toByteStringsColors8</a>. Otherwise,
--   returns <a>toByteStringsColors0</a>.
--   
--   If any IO exceptions arise during this process, they are discarded and
--   <a>toByteStringsColors0</a> is returned.
byteStringMakerFromEnvironment :: Renderable a => IO (Chunk a -> [ByteString] -> [ByteString])

-- | Like <a>byteStringMakerFromEnvironment</a> but also consults a
--   provided <tt>Handle</tt>. If the <tt>Handle</tt> is not a terminal,
--   <a>toByteStringsColors0</a> is returned. Otherwise, the value of
--   <a>byteStringMakerFromEnvironment</a> is returned.
byteStringMakerFromHandle :: Renderable a => Handle -> IO (Chunk a -> [ByteString] -> [ByteString])

-- | Convert a list of <a>Chunk</a> to a list of <a>ByteString</a>. The
--   length of the returned list may be longer than the length of the input
--   list.
--   
--   So, for example, to print a bunch of chunks to standard output using
--   256 colors:
--   
--   <pre>
--   module PrintMyChunks where
--   
--   import qualified Data.ByteString as BS
--   import Rainbow
--   
--   myChunks :: [Chunk String]
--   myChunks = [ chunk "Roses" &amp; fore red, chunk "\n",
--                chunk "Violets" &amp; fore blue, chunk "\n" ]
--   
--   myPrintedChunks :: IO ()
--   myPrintedChunks = mapM_ BS.putStr
--                   . chunksToByteStrings toByteStringsColors256
--                   $ myChunks
--   </pre>
--   
--   To use the highest number of colors that this terminal supports:
--   
--   <pre>
--   myPrintedChunks' :: IO ()
--   myPrintedChunks' = do
--     printer &lt;- byteStringMakerFromEnvironment
--     mapM_ BS.putStr
--       . chunksToByteStrings printer
--       $ myChunks
--   </pre>
chunksToByteStrings :: (Chunk a -> [ByteString] -> [ByteString]) -> [Chunk a] -> [ByteString]

-- | Writes a <a>Chunk</a> to standard output. Spawns a child process to
--   read the output of <tt>tput colors</tt> to determine how many colors
--   to use, for every single chunk. Therefore, this is not going to win
--   any speed awards. You are better off using <a>chunksToByteStrings</a>
--   and the functions in <a>Data.ByteString</a> to print your
--   <a>Chunk</a>s if you are printing a lot of them.
putChunk :: Renderable a => Chunk a -> IO ()

-- | Writes a <a>Chunk</a> to standard output, and appends a newline.
--   Spawns a child process to read the output of <tt>tput colors</tt> to
--   determine how many colors to use, for every single chunk. Therefore,
--   this is not going to win any speed awards. You are better off using
--   <a>chunksToByteStrings</a> and the functions in <a>Data.ByteString</a>
--   to print your <a>Chunk</a>s if you are printing a lot of them.
putChunkLn :: Renderable a => Chunk a -> IO ()
instance Renderable String
instance Renderable ByteString
instance Renderable ByteString
instance Renderable Text
instance Renderable Text


-- | Rainbow handles colors and special effects for text. The basic
--   building block of Rainbow is the <a>Chunk</a>. The <a>Chunk</a>
--   contains both text and formatting information such as colors, bold,
--   underlining, etc.
--   
--   When printed, each <a>Chunk</a> starts off with a clean slate, so if
--   you want special formatting such as any color, bold, etc, then you
--   must specify it for every <a>Chunk</a>. The appearance of one
--   <a>Chunk</a> does not affect the appearance of the next <a>Chunk</a>.
--   This makes it easy to reason about how a particular <a>Chunk</a> will
--   look.
--   
--   Rainbow supports 256-color terminals. You have full freedom to specify
--   different attributes and colors for 8 and 256 color terminals; for
--   instance, you can have text appear red on an 8-color terminal but blue
--   on a 256-color terminal.
--   
--   Here are some basic examples:
--   
--   <pre>
--   <a>putChunkLn</a> $ <a>chunk</a> "Some blue text" <a>&amp;</a> <a>fore</a> <a>blue</a>
--   <a>putChunkLn</a> $ <a>chunk</a> "Blue on red background"
--                 <a>&amp;</a> <a>fore</a> <a>blue</a> <a>&amp;</a> <a>back</a> <a>red</a>
--   <a>putChunkLn</a> $ <a>chunk</a> "Blue on red, foreground bold"
--                  <a>&amp;</a> <a>fore</a> <a>blue</a> <a>&amp;</a> <a>back</a> <a>red</a> <a>&amp;</a> <a>bold</a>
--   </pre>
--   
--   You can also specify output for 256-color terminals. To use these
--   examples, be sure your TERM environment variable is set to something
--   that supports 256 colors (like <tt>xterm-256color</tt>) before you
--   start GHCi.
--   
--   <pre>
--   <a>putChunkLn</a> $ <a>chunk</a> "Blue on 8, bright green on 256" <a>&amp;</a>
--      <a>fore</a> (<a>blue</a> <a>&lt;&gt;</a> <a>brightGreen</a>)
--   
--   <a>putChunkLn</a> $ <a>chunk</a> "Blue on 8, red on 256" <a>&amp;</a>
--      <a>fore</a> (<a>blue</a> <a>&lt;&gt;</a> <a>only256</a> <a>red</a>)
--   </pre>
--   
--   Each <a>Chunk</a> affects the formatting only of that <a>Chunk</a>. So
--   to print things in different colors, make more than one <a>Chunk</a>:
--   
--   <pre>
--   <a>mapM_</a> <a>putChunkLn</a>
--      [ <a>chunk</a> "Roses" <a>&amp;</a> <a>fore</a> <a>red</a>
--      , <a>chunk</a> "Violets" <a>&amp;</a> <a>fore</a> <a>blue</a> ]
--   </pre>
--   
--   The above examples use <a>putChunkLn</a>, but that function will be
--   inefficient if you are printing many <a>Chunk</a>s. For greater
--   efficiency see <a>chunksToByteStrings</a>.
--   
--   The functions in this module, <a>Rainbow</a>, will likely be enough
--   for most uses, but for more flexibility you can use
--   <a>Rainbow.Types</a>. Use of <a>Rainbow.Types</a> will require some
--   familiarity with the <tt>lens</tt> library.
module Rainbow

-- | A chunk is some textual data coupled with a description of what color
--   the text is, attributes like whether it is bold or underlined, etc.
--   The chunk knows what foreground and background colors and what
--   attributes to use for both an 8 color terminal and a 256 color
--   terminal.
data Chunk a

-- | Creates a <a>Chunk</a> with no formatting and with the given text.
chunk :: a -> Chunk a

-- | Bold. What actually happens when you use Bold is going to depend on
--   your terminal. For example, xterm allows you actually use a bold font
--   for bold, if you have one. Otherwise, it might simulate bold by using
--   overstriking. Another possibility is that your terminal might use a
--   different color to indicate bold. For more details (at least for
--   xterm), look at xterm (1) and search for <tt>boldColors</tt>.
--   
--   If your terminal uses a different color for bold, this allows an
--   8-color terminal to really have 16 colors.
bold :: Chunk a -> Chunk a
faint :: Chunk a -> Chunk a
italic :: Chunk a -> Chunk a
underline :: Chunk a -> Chunk a
blink :: Chunk a -> Chunk a
inverse :: Chunk a -> Chunk a
invisible :: Chunk a -> Chunk a
strikeout :: Chunk a -> Chunk a

-- | Stores colors that may affect 8-color terminals, 256-color terminals,
--   both, or neither.
data Radiant

-- | Change the foreground color for both 8- and 256-color terminals.
fore :: Radiant -> Chunk a -> Chunk a

-- | Change the background color for both 8- and 256-color terminals.
back :: Radiant -> Chunk a -> Chunk a
black :: Radiant
red :: Radiant
green :: Radiant
yellow :: Radiant
blue :: Radiant
magenta :: Radiant
cyan :: Radiant
white :: Radiant
grey :: Radiant
brightRed :: Radiant
brightGreen :: Radiant
brightYellow :: Radiant
brightBlue :: Radiant
brightMagenta :: Radiant
brightCyan :: Radiant
brightWhite :: Radiant
color256 :: Word8 -> Radiant

-- | Ensures that a <a>Radiant</a> affects only a 256-color terminal. For
--   instance, to make text that is blue on an 8-color terminal but red on
--   a 256-color terminal:
--   
--   <pre>
--   <a>putChunkLn</a> $ <tt>chunk</tt> "Blue on 8, red on 256" &amp;
--      <a>fore</a> (<a>blue</a> &lt;&gt; <a>only256</a> <a>red</a>)
--   </pre>
only256 :: Radiant -> Radiant

-- | Items that can be rendered. <a>render</a> returns a difference list.
class Renderable a
toByteStringsColors0 :: Renderable a => Chunk a -> [ByteString] -> [ByteString]
toByteStringsColors8 :: Renderable a => Chunk a -> [ByteString] -> [ByteString]
toByteStringsColors256 :: Renderable a => Chunk a -> [ByteString] -> [ByteString]

-- | Spawns a subprocess to read the output of <tt>tput colors</tt>. If
--   this says there are at least 256 colors are available, returns
--   <a>toByteStringsColors256</a>. Otherwise, if there are at least 8
--   colors available, returns <a>toByteStringsColors8</a>. Otherwise,
--   returns <a>toByteStringsColors0</a>.
--   
--   If any IO exceptions arise during this process, they are discarded and
--   <a>toByteStringsColors0</a> is returned.
byteStringMakerFromEnvironment :: Renderable a => IO (Chunk a -> [ByteString] -> [ByteString])

-- | Like <a>byteStringMakerFromEnvironment</a> but also consults a
--   provided <tt>Handle</tt>. If the <tt>Handle</tt> is not a terminal,
--   <a>toByteStringsColors0</a> is returned. Otherwise, the value of
--   <a>byteStringMakerFromEnvironment</a> is returned.
byteStringMakerFromHandle :: Renderable a => Handle -> IO (Chunk a -> [ByteString] -> [ByteString])

-- | Convert a list of <a>Chunk</a> to a list of <a>ByteString</a>. The
--   length of the returned list may be longer than the length of the input
--   list.
--   
--   So, for example, to print a bunch of chunks to standard output using
--   256 colors:
--   
--   <pre>
--   module PrintMyChunks where
--   
--   import qualified Data.ByteString as BS
--   import Rainbow
--   
--   myChunks :: [Chunk String]
--   myChunks = [ chunk "Roses" &amp; fore red, chunk "\n",
--                chunk "Violets" &amp; fore blue, chunk "\n" ]
--   
--   myPrintedChunks :: IO ()
--   myPrintedChunks = mapM_ BS.putStr
--                   . chunksToByteStrings toByteStringsColors256
--                   $ myChunks
--   </pre>
--   
--   To use the highest number of colors that this terminal supports:
--   
--   <pre>
--   myPrintedChunks' :: IO ()
--   myPrintedChunks' = do
--     printer &lt;- byteStringMakerFromEnvironment
--     mapM_ BS.putStr
--       . chunksToByteStrings printer
--       $ myChunks
--   </pre>
chunksToByteStrings :: (Chunk a -> [ByteString] -> [ByteString]) -> [Chunk a] -> [ByteString]

-- | Writes a <a>Chunk</a> to standard output. Spawns a child process to
--   read the output of <tt>tput colors</tt> to determine how many colors
--   to use, for every single chunk. Therefore, this is not going to win
--   any speed awards. You are better off using <a>chunksToByteStrings</a>
--   and the functions in <a>Data.ByteString</a> to print your
--   <a>Chunk</a>s if you are printing a lot of them.
putChunk :: Renderable a => Chunk a -> IO ()

-- | Writes a <a>Chunk</a> to standard output, and appends a newline.
--   Spawns a child process to read the output of <tt>tput colors</tt> to
--   determine how many colors to use, for every single chunk. Therefore,
--   this is not going to win any speed awards. You are better off using
--   <a>chunksToByteStrings</a> and the functions in <a>Data.ByteString</a>
--   to print your <a>Chunk</a>s if you are printing a lot of them.
putChunkLn :: Renderable a => Chunk a -> IO ()
