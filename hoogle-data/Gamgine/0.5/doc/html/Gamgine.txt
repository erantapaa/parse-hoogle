-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Some kind of game library or set of utilities.
--   
@package Gamgine
@version 0.5

module Gamgine.Lens.State

-- | apply the getter lens on the value of the state
getL :: Monad m => Lens a b -> StateT a m b

-- | apply the setter of the lens on the value of the state
setL :: Monad m => Lens a b -> b -> StateT a m ()

-- | modify the value of the state with a lens
modL :: Monad m => Lens a b -> (b -> b) -> StateT a m ()

module Gamgine.Lens.IORef
type StateIORef a = StateT (IORef a) IO

-- | map a function on the value of the IORef
mapIORef :: IORef a -> (a -> b) -> IO b

-- | get the value of the IORef inside of the State
get :: StateIORef a a

-- | apply a function on the value of the IORef
gets :: (a -> b) -> StateIORef a b

-- | apply the getter lens on the value of the IORef inside of the State
getsL :: Lens a b -> StateIORef a b

-- | set the value of the IORef inside of the State
put :: a -> StateIORef a ()

-- | put a value
putL :: Lens a b -> b -> StateIORef a ()

-- | modify the value of the IORef inside of the State with a lens
modify :: (a -> a) -> StateIORef a ()

-- | modify the value of the IORef inside of the State with a lens
modifyL :: Lens a b -> (b -> b) -> StateIORef a ()

-- | apply the getter of the lens on the value of the IORef
getL :: IORef a -> Lens a b -> IO b

-- | apply the setter of the lens on the value of the IORef
setL :: IORef a -> Lens a b -> b -> IO ()

-- | modify the value of the IORef with a lens
modL :: IORef a -> Lens a b -> (b -> b) -> IO ()

module Gamgine.Zipper

-- | get the elements before the current one
before :: Zipper a -> Zipper a

-- | get the elements after the current one
after :: Zipper a -> Zipper a

-- | get the current element, might fail
current :: Zipper a -> a

-- | get the previous element, might fail
previous :: Zipper a -> a

-- | get the next element, might fail
next :: Zipper a -> a

-- | if the current element is the last of the list
atLast :: Zipper a -> Bool

-- | if the current element is the first of the list
atFirst :: Zipper a -> Bool

module Gamgine.Image.PNG.Internal.LBS
newtype LBS
LBS :: ByteString -> LBS
unLSB :: LBS -> ByteString
unpack :: LBS -> [Word8]
unpackToString :: LBS -> String
splitAt :: Int64 -> LBS -> (LBS, LBS)
readFile :: FilePath -> IO LBS
concat :: [LBS] -> LBS
pack :: [Word8] -> LBS
null :: LBS -> Bool
head :: LBS -> Word8
tail :: LBS -> LBS
instance Show LBS
instance Monad m => Stream LBS m Word8

module Gamgine.Image.PNG.Internal.CRC
update_crc :: Word32 -> LBS -> Word32
crc :: LBS -> Word32

module Gamgine.Image.PNG.Internal.Parser
type Parser = Parsec LBS ()
word8 :: Stream LBS m Word8 => Word8 -> ParsecT LBS u m Word8
word16 :: Stream LBS m Word8 => Word16 -> ParsecT LBS u m Word16
word32 :: Stream LBS m Word8 => Word32 -> ParsecT LBS u m Word32
satisfy :: Stream LBS m Word8 => (Word8 -> Bool) -> ParsecT LBS u m Word8
anyWord8 :: Stream LBS m Word8 => ParsecT LBS u m Word8
anyWord16 :: Stream LBS m Word8 => ParsecT LBS u m Word16
anyWord32 :: Stream LBS m Word8 => ParsecT LBS u m Word32
string :: Stream LBS m Word8 => LBS -> ParsecT LBS u m LBS
block :: Stream LBS m Word8 => Int -> ParsecT LBS u m LBS
allowedValues :: (a -> Parser a) -> [(a, b)] -> Parser b
parseFromFile :: Parser a -> FilePath -> IO (Either String a)

module Gamgine.Image.PNG.Internal.Filters

-- | Defilter filtered PNG data (data includes scanlines prepended with
--   filter types).
defilter_scanlines_arr :: (Width, Height) -> Int -> ByteString -> IO (StorableArray (Width, Height) Word8)

module Gamgine.Engine
mkUpdateLoop :: MonadIO m => Int -> Int -> m a -> (Double -> m (Double, Double))


-- | A simple, pure Haskell PNG loader. Currently supports 24bit RGB(A)
--   images with no interlacing. Also lacks support for color indexed
--   (paletted) images.
--   
--   The image is stored in a StorableArray for compatibility with OpenGL
--   (the array supports getting Ptr Word8 to the image data using
--   withStorableArray function).
module Gamgine.Image.PNG
data PNGImage
type Width = Word32
type Height = Word32

-- | Load a PNG file, Left value contains a description of a problem as a
--   String, if any
loadPNGFile :: FilePath -> IO (Either String PNGImage)

-- | Get dimensions of the image (in pixels)
dimensions :: PNGImage -> (Width, Height)

-- | Get image data as C-compatible StorableArray
imageData :: PNGImage -> StorableArray (Int, Int) Word8

-- | Check if the image has alpha channel
hasAlphaChannel :: PNGImage -> Bool
instance Show RawPNGChunk
instance Show ColorType
instance Eq ColorType
instance Show BitDepth
instance Eq BitDepth
instance Show CompressionMethod
instance Eq CompressionMethod
instance Show FilterMethod
instance Eq FilterMethod
instance Show InterlaceMethod
instance Eq InterlaceMethod
instance Show PNGChunk
instance Show PNGImage

module Gamgine.System
normalizedProgName :: IO (String)
getCurrentDate :: IO (Integer, Int, Int)
getEnvOrDefault :: String -> String -> IO String
appDirectory :: IO FilePath
getAndCreateAppDir :: IO (FilePath)
getDirContents :: FilePath -> IO [FilePath]

module Gamgine.Control
whenM :: Monad m => m Bool -> m () -> m ()

-- | if a is just than apply f, otherwise 'return ()'
ifJust :: Monad m => Maybe a -> (a -> m ()) -> m ()

-- | apply f on a if p is true, otherwise just return a
applyIf :: (a -> Bool) -> (a -> a) -> a -> a

-- | apply f on a if p is true, otherwise 'return ()'
applyIfM :: Monad m => (a -> Bool) -> (a -> m ()) -> a -> m ()
(?) :: Bool -> a -> a -> a

module Gamgine.Font.GLF
init :: IO ()
newtype FontId
FontId :: Int -> FontId
loadFont :: FilePath -> IO FontId
setCurrentFont :: FontId -> IO Bool
type X = Double
type Y = Double
data Bounds
Bounds :: (X, Y) -> (X, Y) -> Bounds
min :: Bounds -> (X, Y)
max :: Bounds -> (X, Y)
getStringBounds :: String -> IO Bounds
drawWiredString :: String -> IO ()
drawSolidString :: String -> IO ()
glfError :: Int
glfOk :: Int
glfYes :: Int
glfNo :: Int
c_glfInit :: IO ()
c_glfLoadFont :: CString -> IO CInt
c_glfSetCurrentFont :: CInt -> IO CInt
c_glfGetStringBounds :: CString -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
c_glfDrawWiredString :: CString -> IO ()
c_glfDrawSolidString :: CString -> IO ()
instance Eq FontId
instance Show FontId
instance Show Bounds

module Gamgine.State.RenderState
newtype TextureName
TextureName :: Int -> TextureName
newtype FontName
FontName :: Int -> FontName
type TextureIds = [(TextureName, GLuint)]
type FontIds = [(FontName, FontId)]
data Ressources
Ressources :: TextureIds -> FontIds -> Ressources
textureIds :: Ressources -> TextureIds
fontIds :: Ressources -> FontIds
emptyRessources :: Ressources
textureId :: TextureName -> Ressources -> Maybe GLuint
fontId :: FontName -> Ressources -> Maybe FontId
textureIdsL :: Lens Ressources TextureIds
fontIdsL :: Lens Ressources FontIds
data RenderState
RenderState :: Double -> Ressources -> (Double, Double) -> RenderState

-- | value range 0-1
nextFrameFraction :: RenderState -> Double
ressources :: RenderState -> Ressources
frustumSize :: RenderState -> (Double, Double)
nextFrameFractionL :: Lens RenderState Double
ressourcesL :: Lens RenderState Ressources
frustumSizeL :: Lens RenderState (Double, Double)
instance Show TextureName
instance Eq TextureName
instance Show FontName
instance Eq FontName
instance Show Ressources
instance Show RenderState

module Gamgine.Utils
count :: Eq a => a -> [a] -> Int

-- | replace all entries in <tt>as</tt> by <tt>new</tt> for which
--   <tt>f</tt> returns true
replaceBy :: (a -> Bool) -> a -> [a] -> [a]
errorsToStderr :: IO () -> IO ()
showValue :: Show a => String -> a -> String
sv :: Show a => String -> a -> String
for_ :: [a] -> (a -> b) -> [b]
maybe_ :: Maybe a -> b -> (a -> b) -> b
firstFreeId :: Eq a => [a] -> [a] -> a
word :: Word8 -> Word8 -> Word8 -> Word8 -> Word32
bytesFromPointer :: Int -> Ptr Word8 -> IO ByteString
bytesFromStorableArray :: Int -> StorableArray (Int, Int) Word8 -> IO ByteString

module Gamgine.Math.Utils
clamp :: Double -> Double -> Double -> Double
flipSign :: Double -> Double
maxFloat :: RealFloat a => a -> a
minPositiveFloat :: RealFloat a => a -> a
minPositiveDouble :: Double
instance Bounded Double

module Gamgine.Math.Vect
type Vect = Vec3 Double
type Vect4 = Vec4 Double
x :: Vect -> Double
y :: Vect -> Double
z :: Vect -> Double
v3 :: Double -> Double -> Double -> Vect
v4 :: Double -> Double -> Double -> Double -> Vect4
fromTuple :: (Double, Double, Double) -> Vect
toTuple :: Vect -> (Double, Double, Double)
fromVect4 :: Vect4 -> Vect
len :: Vect -> Double
inverseVec :: (Map b b u v, Num b) => u -> v
clampVec :: Vect -> Vect -> Vect -> Vect
maxVec :: (ZipWith c c c u v w, Ord c) => u -> v -> w
minVec :: (ZipWith c c c u v w, Ord c) => u -> v -> w
index :: (Double -> Bool) -> Vect -> Int
absVec :: (Map b b u v, Num b) => u -> v
nullVec :: Vect
and :: Fold v Bool => v -> Bool
or :: Fold v Bool => v -> Bool
all :: (Fold s Bool, ZipWith a b c u v s) => (a -> b -> c) -> u -> v -> Bool
any :: (Fold s Bool, ZipWith a b c u v s) => (a -> b -> c) -> u -> v -> Bool

module Gamgine.Math.Box
data Box
Box :: Vect -> Vect -> Box
minPt :: Box -> Vect
maxPt :: Box -> Vect
minPtL :: Lens Box Vect
maxPtL :: Lens Box Vect
center :: Box -> Vect
halfs :: Box -> Vect
intersects :: Box -> Box -> Bool
inside :: Box -> Box -> Bool
moveBy :: Box -> Vect -> Box
extendBy :: Box -> Box -> Box
contains :: Box -> Vect -> Bool
bound :: [Box] -> Box
distance :: Box -> Box -> Vect
minOverlap :: Box -> Box -> Vect
type Tuple3d = (Double, Double, Double)
fromTuples :: (Tuple3d, Tuple3d) -> Box
toTuples :: Box -> (Tuple3d, Tuple3d)
instance Show Box
instance Read Box

module Gamgine.Math.BoxTree
data BoxTree a
Node :: Box -> [BoxTree a] -> BoxTree a
Leaf :: Box -> a -> BoxTree a
data Intersection a
Intersection :: (Box, a) -> (Box, a) -> Intersection a
leaf1 :: Intersection a -> (Box, a)
leaf2 :: Intersection a -> (Box, a)
intersection :: BoxTree a -> BoxTree a -> [Intersection a]
moveBy :: BoxTree a -> Vect -> BoxTree a
asBox :: BoxTree a -> Box
asBoxTree :: Box -> a -> BoxTree a
instance Show a => Show (BoxTree a)
instance Show a => Show (Intersection a)

module Gamgine.State.InputInfo
data Modifier
Ctrl :: Modifier
Alt :: Modifier
Shift :: Modifier

-- | mouse position in world coordinates
type MousePos = Vect

-- | if the key/mouse button was pressed or released
data InputState
Pressed :: InputState
Released :: InputState
isModifierPressed :: Modifier -> ModifierKeys -> Bool
instance Eq Modifier
instance Ord Modifier
instance Eq InputState
instance Ord InputState

module Gamgine.State.KeyInfo

-- | info for the pressed/released key
data KeyInfo
KeyInfo :: Key -> InputState -> MousePos -> ModifierKeys -> KeyInfo
key :: KeyInfo -> Key
status :: KeyInfo -> InputState
mousePos :: KeyInfo -> MousePos
modifiers :: KeyInfo -> ModifierKeys

module Gamgine.State.MouseInfo

-- | info for the pressed/released mouse button
data MouseInfo
MouseInfo :: MouseButton -> InputState -> MousePos -> ModifierKeys -> MouseInfo
button :: MouseInfo -> MouseButton
status :: MouseInfo -> InputState
mousePos :: MouseInfo -> MousePos
modifiers :: MouseInfo -> ModifierKeys

module Gamgine.State.State

-- | an application state
data State a
State :: (MousePos -> a -> Maybe (a, State a)) -> (a -> (a, State a)) -> (a -> (a, State a)) -> (RenderState -> a -> IO (a, State a)) -> (KeyInfo -> a -> (a, State a)) -> (MouseInfo -> a -> (a, State a)) -> (MousePos -> a -> (a, State a)) -> State a

-- | called when the state is entered, when Nothing is returned, than the
--   state couldn't be entered
enter :: State a -> MousePos -> a -> Maybe (a, State a)

-- | called when the state is leaved
leave :: State a -> a -> (a, State a)

-- | called for each application update cycle
update :: State a -> a -> (a, State a)

-- | called for each frame rendering
render :: State a -> RenderState -> a -> IO (a, State a)

-- | called when a key was pressed/released
keyEvent :: State a -> KeyInfo -> a -> (a, State a)

-- | called when a mouse button was pressed/released
mouseEvent :: State a -> MouseInfo -> a -> (a, State a)

-- | called when a mouse was moved
mouseMoved :: State a -> MousePos -> a -> (a, State a)

module Gamgine.State.StateTree

-- | the tree of application states and how they entered and leaved
data StateTree a
Branch :: State a -> StateTransition -> StateTransition -> [StateTree a] -> StateTree a
state :: StateTree a -> State a
enterWhen :: StateTree a -> StateTransition
leaveWhen :: StateTree a -> StateTransition
adjacents :: StateTree a -> [StateTree a]

-- | at which event the next state should be entered
type EnterWhen = StateTransition

-- | at which event the current state should be leaved
type LeaveWhen = StateTransition

-- | when a state should be entered or leaved
data StateTransition
ByKey :: Key -> InputState -> StateTransition
ByKeyWithMod :: Key -> InputState -> Modifier -> StateTransition
ByMouse :: MouseButton -> InputState -> StateTransition
ByMouseWithMod :: MouseButton -> InputState -> Modifier -> StateTransition
NoTransition :: StateTransition
root :: State a -> [StateTree a] -> StateTree a
enterState :: MousePos -> a -> StateTree a -> Maybe (a, StateTree a)
leaveState :: a -> StateTree a -> (a, StateTree a)
handleKeyEvent :: KeyInfo -> a -> StateTree a -> (a, StateTree a)
handleMouseEvent :: MouseInfo -> a -> StateTree a -> (a, StateTree a)
instance Eq StateTransition
instance Ord StateTransition

module Gamgine.State.StateTreeZipper

-- | a zipper for the state tree
data Zipper a
Zipper :: [Step a] -> StateTree a -> Zipper a
path :: Zipper a -> [Step a]
current :: Zipper a -> StateTree a

-- | represents a step walking the state tree
data Step a
Step :: (State a, EnterWhen, LeaveWhen) -> ([StateTree a], [StateTree a]) -> Step a
parent :: Step a -> (State a, EnterWhen, LeaveWhen)
siblings :: Step a -> ([StateTree a], [StateTree a])

-- | create a zipper from a StateTree
zipper :: StateTree a -> Zipper a

-- | checks if a state transition should occur, otherwise calls the
--   keyEvent function of the current state
handleKeyEvent :: KeyInfo -> a -> Zipper a -> (a, Zipper a)

-- | checks if a state transition should occur, otherwise calls the
--   mouseEvent function of the current state
handleMouseEvent :: MouseInfo -> a -> Zipper a -> (a, Zipper a)

-- | leave the current state and enter the parent state
goUp :: MousePos -> a -> Zipper a -> (a, Zipper a)

-- | leave the current state and enter the adjacent state with index
--   <tt>adjIdx</tt>
goDown :: Int -> MousePos -> a -> Zipper a -> (a, Zipper a)

-- | replace the current state
replace :: State a -> Zipper a -> Zipper a

-- | checks if the KeyInfo matches the StateTransition
transitionAppliesKI :: KeyInfo -> StateTransition -> Bool

-- | checks of the MouseInfo matches the StateTransition
transitionAppliesMI :: MouseInfo -> StateTransition -> Bool

module Gamgine.Gfx
type XY = (Double, Double)
type XYZ = (Double, Double, Double)
type XYZW = (Double, Double, Double, Double)
type RGB = (Double, Double, Double)
type RGBA = (Double, Double, Double, Double)
xy :: Double -> Double -> XY
xyz :: Double -> Double -> Double -> XYZ
xyzw :: Double -> Double -> Double -> Double -> XYZW
rgb :: Double -> Double -> Double -> RGB
rgba :: Double -> Double -> Double -> Double -> RGBA
floatToFloat :: (RealFloat a, RealFloat b) => a -> b
class Tuple4d a
t4d_first :: Tuple4d a => a -> Double
t4d_second :: Tuple4d a => a -> Double
t4d_third :: Tuple4d a => a -> Double
t4d_forth :: Tuple4d a => a -> Double
class Tuple3d a
t3d_first :: Tuple3d a => a -> Double
t3d_second :: Tuple3d a => a -> Double
t3d_third :: Tuple3d a => a -> Double
class Tuple2d a
t2d_first :: Tuple2d a => a -> Double
t2d_second :: Tuple2d a => a -> Double
(<<) :: Tuple2d a => (GLfloat -> GLfloat -> IO ()) -> a -> IO ()
(<<<) :: Tuple3d a => (GLfloat -> GLfloat -> GLfloat -> IO ()) -> a -> IO ()
(<<<<) :: Tuple4d a => (GLfloat -> GLfloat -> GLfloat -> GLfloat -> IO ()) -> a -> IO ()
quad :: (Double, Double) -> (Double, Double) -> [(Double, Double)]
quadTexCoords :: Double -> Double -> [(Double, Double)]
draw :: Tuple3d a => GLenum -> [a] -> IO ()
drawBox :: Box -> IO ()
drawQuad :: Tuple3d a => a -> a -> IO ()
drawBoxTree :: BoxTree a -> IO ()
drawPoint :: Tuple3d a => a -> RGB -> IO ()
withPrimitive :: GLenum -> IO () -> IO ()
withPushedMatrix :: IO a -> IO a
withPolyMode :: GLenum -> IO () -> IO ()
withEnabled :: GLenum -> IO () -> IO ()
withBlend :: GLenum -> GLenum -> IO () -> IO ()
withTexture2d :: GLuint -> IO () -> IO ()
makeTexture2d :: FilePath -> GLenum -> IO GLuint
renderTexturedQuad :: (Double, Double) -> GLuint -> IO ()
instance Tuple2d (Vec2 Double)
instance Tuple2d (Double, Double)
instance Tuple3d (Vec3 Double)
instance Tuple3d (Double, Double, Double)
instance Tuple4d (Vec4 Double)
instance Tuple4d (Double, Double, Double, Double)

module Gamgine.Math.Matrix
type Matrix = Mat44 Double
type Window = (Width, Height)
data Frustum
Frustum :: Double -> Double -> Double -> Double -> Double -> Double -> Frustum
left :: Frustum -> Double
right :: Frustum -> Double
bottom :: Frustum -> Double
top :: Frustum -> Double
near :: Frustum -> Double
far :: Frustum -> Double
mkOrtho :: Frustum -> Matrix
mkScale :: Vect -> Matrix
mkTranslate :: Vect -> Matrix
mkWindowMatrix :: Window -> Matrix
mkWorldToWinMatrix :: Window -> Frustum -> Matrix
mkWinToWorldMatrix :: Window -> Frustum -> Matrix
winToWorld :: Matrix -> WinCoord -> Vect
inverseOrIdentity :: Matrix -> Matrix
instance Show Frustum
instance Eq Frustum

module Gamgine.Bool
(<&&>) :: Monad m => m Bool -> m Bool -> m Bool
(<||>) :: Monad m => m Bool -> m Bool -> m Bool

module Gamgine.Coroutine
newtype Coroutine i o
Coroutine :: (i -> (o, Coroutine i o)) -> Coroutine i o
runCoroutine :: Coroutine i o -> i -> (o, Coroutine i o)
newtype CoroutineM m i o
CoroutineM :: (i -> m (o, CoroutineM m i o)) -> CoroutineM m i o
runCoroutineM :: CoroutineM m i o -> i -> m (o, CoroutineM m i o)
