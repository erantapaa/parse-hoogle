-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | State-space estimation algorithms such as Kalman Filters
--   
@package estimator
@version 1.1.0.1


-- | This package supports running filters in pure Haskell, of course. But
--   it's also designed to work with libraries like <a>sbv</a> and
--   <a>ivory</a> that can extract symbolic expressions, whether for
--   analysis in other tools or for generating code in some other language.
--   
--   This module provides helpers allowing models to abstract away from
--   standard Haskell type-classes that do not support symbolic
--   computation.
module Numeric.Estimator.Model.Symbolic

-- | The <a>atan2</a> function is defined in the <a>RealFloat</a>
--   typeclass, which can't be implemented for symbolic types because
--   nearly every member besides <a>atan2</a> returns concrete values, not
--   symbolic ones. This typeclass describes types, symbolic or concrete,
--   that support an <a>atan2</a> function.
class HasAtan2 a
arctan2 :: HasAtan2 a => a -> a -> a
instance HasAtan2 Double


-- | This module implements the <a>1976 U.S. Standard Atmosphere</a>, but
--   is only valid for altitudes from sea level to 11km.
module Numeric.Estimator.Model.Pressure

-- | Given a barometric pressure measurement in Pascals, return altitude in
--   meters.
pressureToHeight :: Floating a => a -> a

-- | Given altitude in meters, return a barometric pressure measurement in
--   Pascals.
heightToPressure :: Floating a => a -> a


-- | The <tt>Linear</tt> module provides basic fixed-dimensional vector
--   types such as <a>V3</a>, for three-element vectors. However, it does
--   not help with identifying which coordinate system a vector was
--   measured in.
--   
--   The types in this module are trivial newtype wrappers around <a>V3</a>
--   to tag vectors with an appropriate coordinate system. The systems used
--   here follow a common convention used in navigation problems.
module Numeric.Estimator.Model.Coordinate

-- | Navigation occurs in a right-hand coordinate system with respect to a
--   "local tangent plane". The origin of this plane is chosen to be some
--   convenient point on the Earth's surface--perhaps the location where
--   navigation began. The plane is oriented such that it is tangent to the
--   Earth's surface at that origin point. The basis vectors point
--   northward, eastward, and downward from the origin. Notice that the
--   further you travel from the origin, the further the tangent plane
--   separates from the surface of the Earth, so this approach is of
--   limited use over long distances.
newtype NED a
NED :: V3 a -> NED a
nedToVec3 :: NED a -> V3 a

-- | Construct a navigation frame coordinate from (north, east, down).
ned :: a -> a -> a -> NED a

-- | Most sensor measurements are taken with respect to the sensor platform
--   in the vehicle. We assume the sensors are perfectly orthogonally
--   arranged in a right-hand Cartesian coordinate system, which is usually
--   close enough to the truth, although more sophisticated approaches
--   exist to calibrate out non-orthogonal alignment and other errors. This
--   coordinate system is only meaningful with respect to the current
--   position and orientation of the sensor platform, as of the instant
--   that the measurement was taken.
newtype XYZ a
XYZ :: V3 a -> XYZ a
xyzToVec3 :: XYZ a -> V3 a

-- | Construct a body frame coordinate from (x, y, z).
xyz :: a -> a -> a -> XYZ a

-- | Most practical problems involving inertial sensors (such as
--   accelerometers and gyroscopes) require keeping track of the
--   relationship between these two coordinate systems.
--   
--   If you maintain a quaternion representing the rotation from navigation
--   frame to body frame, then you can use this function to get functions
--   that will convert coordinates between frames in either direction.
convertFrames :: Num a => Quaternion a -> (XYZ a -> NED a, NED a -> XYZ a)
instance Show a => Show (NED a)
instance Additive NED
instance Applicative NED
instance Foldable NED
instance Functor NED
instance Metric NED
instance Num a => Num (NED a)
instance Traversable NED
instance Show a => Show (XYZ a)
instance Additive XYZ
instance Applicative XYZ
instance Foldable XYZ
instance Functor XYZ
instance Metric XYZ
instance Num a => Num (XYZ a)
instance Traversable XYZ
instance Distributive XYZ
instance Distributive NED


-- | These type classes abstract many details of estimation algorithms,
--   making it easier to try different algorithms while changing the model
--   as little as possible.
--   
--   This interface does make the simplifying assumption that process
--   uncertainty and measurement noise are each always specified as a
--   covariance matrix describing a zero-mean multi-variate normal
--   distribution. While some estimation algorithms (such as the Bayesian
--   Particle Filter) can accomodate more sophisticated distributions, it's
--   unusual to encounter problems that require that degree of flexibility.
module Numeric.Estimator.Class

-- | An estimator is a model of a system, describing how to update a prior
--   estimated state with new information. Two kinds of estimators are the
--   <a>Process</a> model, and the <a>Measure</a> (or observation) model.
class Estimator t where type family Filter t :: (* -> *) -> * -> *

-- | The type of state vector used in an estimator.

-- | The type of individual state variables used in an estimator.

-- | A process model updates the estimated state by predicting how the
--   system should have changed since the last prediction.
--   
--   In a kinematic model, for instance, the process model might be a
--   dead-reckoning physics simulation which updates position using a
--   trivial numeric integration of velocity.
--   
--   Parameter estimation problems, where the parameters are expected to
--   remain constant between observations, needn't have a process model.
class Estimator t => Process t
process :: Process t => t -> State t (State t (Var t)) -> Filter t (State t) (Var t) -> Filter t (State t) (Var t)

-- | A measurement, or observation, model updates the estimated state using
--   some observation of the real state.
--   
--   In a navigation problem, for instance, an observation might come from
--   a GPS receiver or a pressure altimeter. The model computes what value
--   the sensor would be expected to read if there were no sensor noise and
--   the current estimated state were exactly correct. The difference
--   between the expected and actual measurement is called the
--   "innovation", and that difference drives the estimated state toward
--   the true state.
--   
--   In general, an observation is vector-valued. You can wrap up scalar
--   observations in a singleton functor, such as <tt>V1</tt>.
--   
--   For each dimension of the observation vector, the measurement must
--   consist of a scalar measurement, and an expression which evaluates to
--   the expected value for that measurement given the current state.
class Estimator t => Measure t where type family MeasureQuality (t :: *) (obs :: * -> *) :: * type family MeasureObservable (t :: *) (obs :: * -> *) :: Constraint
measure :: (Measure t, MeasureObservable t obs) => obs (Var t, t) -> obs (obs (Var t)) -> Filter t (State t) (Var t) -> (MeasureQuality t obs, Filter t (State t) (Var t))

-- | A filter whose state can be captured as a multi-variate normal
--   distribution can also be updated by adjusting the parameters of that
--   distribution.
class GaussianFilter t
mapStatistics :: GaussianFilter t => (state var -> state' var') -> (state (state var) -> state' (state' var')) -> t state var -> t state' var'


-- | This module implements the Extended Kalman Filter estimation
--   algorithm.
module Numeric.Estimator.KalmanFilter

-- | All variants of Kalman Filter, at their core, maintain the parameters
--   of a multi-variate normal distribution.
--   
--   Since different Kalman Filter variants share this filter type, you can
--   mix and match algorithms within the same filter. For example, you
--   could use a conventional Kalman filter for any linear measurements,
--   and a Sigma-Point Kalman Filter for a non-linear process model.
data KalmanFilter state var
KalmanFilter :: state var -> state (state var) -> KalmanFilter state var

-- | mean
kalmanState :: KalmanFilter state var -> state var

-- | covariance
kalmanCovariance :: KalmanFilter state var -> state (state var)

-- | Kalman filter estimators can report the innovation of each
--   observation, as well as the covariance of the innovation.
data KalmanInnovation obs var
KalmanInnovation :: obs var -> obs (obs var) -> KalmanInnovation obs var
kalmanInnovation :: KalmanInnovation obs var -> obs var
kalmanInnovationCovariance :: KalmanInnovation obs var -> obs (obs var)

-- | A process model in an Extended Kalman Filter transforms a state vector
--   to a new state vector, but is wrapped in reverse-mode automatic
--   differentiation.
newtype EKFProcess state var
EKFProcess :: (forall s. Reifies s Tape => state (Reverse s var) -> state (Reverse s var)) -> EKFProcess state var

-- | A measurement model in an Extended Kalman Filter uses the state vector
--   to predict what value a sensor should return, while wrapped in
--   reverse-mode automatic differentiation.
newtype EKFMeasurement state var
EKFMeasurement :: (forall s. Reifies s Tape => state (Reverse s var) -> Reverse s var) -> EKFMeasurement state var
instance (Additive state, Distributive state, Traversable state, Fractional var) => Measure (EKFMeasurement state var)
instance Estimator (EKFMeasurement state var)
instance (Additive state, Traversable state, Distributive state, Num var) => Process (EKFProcess state var)
instance Estimator (EKFProcess state var)
instance GaussianFilter KalmanFilter


-- | Some system models are best handled by injecting some measurements
--   into the process model. These measurements are not truly part of the
--   filter state, and so shouldn't appear in the state vector. However,
--   when the process model runs, the state needs to be augmented with
--   these measurements, and the process uncertainty needs to be augmented
--   with their noise covariance.
--   
--   As currently implemented, this only works for process models where the
--   <a>Filter</a> type is a <a>GaussianFilter</a> instance. Generalizing
--   this interface would be useful future work.
module Numeric.Estimator.Augment

-- | Holder for the basic state vector plus the augmented extra state.
data AugmentState state extra a
AugmentState :: state a -> extra a -> AugmentState state extra a
getState :: AugmentState state extra a -> state a
getExtra :: AugmentState state extra a -> extra a

-- | Run an augmented process model with the given extra data.
augmentProcess :: (Num (Var t), Applicative state, Applicative extra, Process t, GaussianFilter (Filter t), State t ~ AugmentState state extra) => t -> extra (Var t) -> state (state (Var t)) -> extra (extra (Var t)) -> Filter t state (Var t) -> Filter t state (Var t)
instance (Applicative state, Applicative extra, Distributive state, Distributive extra) => Distributive (AugmentState state extra)
instance (Applicative state, Applicative extra, Traversable state, Traversable extra) => Traversable (AugmentState state extra)
instance (Applicative state, Applicative extra, Traversable state, Traversable extra) => Foldable (AugmentState state extra)
instance (Applicative state, Applicative extra) => Functor (AugmentState state extra)
instance (Applicative state, Applicative extra) => Applicative (AugmentState state extra)
instance (Applicative state, Applicative extra) => Additive (AugmentState state extra)


-- | Many kinds of vehicles have a collection of sensors for measuring
--   where they are and where they're going, which may include these
--   sensors and others:
--   
--   <ul>
--   <li>accelerometers</li>
--   <li>gyroscopes</li>
--   <li>GPS receiver</li>
--   <li>pressure altimeter</li>
--   <li>3D magnetometer</li>
--   </ul>
--   
--   Each of these sensors provides some useful information about the
--   current physical state of the vehicle, but they all have two obnoxious
--   problems:
--   
--   <ol>
--   <li>No one sensor provides all the information you want at the update
--   rate you need. GPS gives you absolute position, but at best only ten
--   times per second. Accelerometers can report measurements at high
--   speeds, hundreds to thousands of times per second, but to get position
--   you have to double-integrate the measurement samples.</li>
--   <li>Every sensor is lying to you. They measure some aspect of the
--   physical state, plus some random error. If you have to integrate these
--   measurements, as with acceleration for instance, then the error
--   accumulates over time. If you take the derivative, perhaps because you
--   have position but you need velocity, the derivative amplifies the
--   noise.</li>
--   </ol>
--   
--   This is an ideal case for a state-space estimation algorithm. Once
--   you've specified the kinetic model of the physical system, and modeled
--   each of your sensors, and identified the noise parameters for
--   everything, the estimation algorithm is responsible for combining all
--   the measurements. The estimator will decide how much to trust each
--   sensor based on how much confidence it has in its current state
--   estimate, and how well that state agrees with the current measurement.
--   
--   This module implements a system model for sensor fusion. With
--   appropriate noise parameters, it should work for a wide variety of
--   vehicle types and sensor platforms, whether on land, sea, air, or
--   space. However, it has been implemented specifically for quad-copter
--   autopilots. As a result the state vector may have components your
--   system does not need, or be missing ones you do need.
module Numeric.Estimator.Model.SensorFusion

-- | A collection of all the state variables needed for this model.
data StateVector a
StateVector :: !(Quaternion a) -> !(NED a) -> !(NED a) -> !(XYZ a) -> !(NED a) -> !(NED a) -> !(XYZ a) -> StateVector a

-- | quaternions defining attitude of body axes relative to local NED
stateOrient :: StateVector a -> !(Quaternion a)

-- | NED velocity - m/sec
stateVel :: StateVector a -> !(NED a)

-- | NED position - m
statePos :: StateVector a -> !(NED a)

-- | delta angle bias - rad
stateGyroBias :: StateVector a -> !(XYZ a)

-- | NED wind velocity - m/sec
stateWind :: StateVector a -> !(NED a)

-- | NED earth fixed magnetic field components - milligauss
stateMagNED :: StateVector a -> !(NED a)

-- | XYZ body fixed magnetic field measurements - milligauss
stateMagXYZ :: StateVector a -> !(XYZ a)

-- | Define the control (disturbance) vector. Error growth in the inertial
--   solution is assumed to be driven by <tt>noise</tt> in the delta angles
--   and velocities, after bias effects have been removed. This is OK
--   becasue we have sensor bias accounted for in the state equations.
data DisturbanceVector a
DisturbanceVector :: !(XYZ a) -> !(XYZ a) -> DisturbanceVector a

-- | XYZ body rotation rate in rad/second
disturbanceGyro :: DisturbanceVector a -> !(XYZ a)

-- | XYZ body acceleration in meters/second/second
disturbanceAccel :: DisturbanceVector a -> !(XYZ a)

-- | Initial covariance for this model.
initCovariance :: Fractional a => StateVector (StateVector a)

-- | When the sensor platform is not moving, a three-axis accelerometer
--   will sense an approximately 1g acceleration in the direction of
--   gravity, which gives us the platform's orientation aside from not
--   knowing the current rotation around the gravity vector.
--   
--   At the same time, a 3D magnetometer will sense the platform's
--   orientation with respect to the local magnetic field, aside from not
--   knowing the current rotation around the magnetic field line.
--   
--   Putting these two together gives the platform's complete orientation
--   since the gravity vector and magnetic field line aren't collinear.
initAttitude :: (Floating a, HasAtan2 a) => XYZ a -> XYZ a -> a -> Quaternion a

-- | Compute an initial filter state from an assortment of initial
--   measurements.
initDynamic :: (Floating a, HasAtan2 a) => XYZ a -> XYZ a -> XYZ a -> a -> NED a -> NED a -> StateVector a

-- | This is the kinematic sensor fusion process model, driven by
--   accelerometer and gyro measurements.
processModel :: Fractional a => a -> AugmentState StateVector DisturbanceVector a -> AugmentState StateVector DisturbanceVector a

-- | Compute the local air pressure from the state vector. Useful as a
--   measurement model for a pressure sensor.
statePressure :: Floating a => StateVector a -> a

-- | Compute the true air-speed of the sensor platform. Useful as a
--   measurement model for a true air-speed sensor.
stateTAS :: Floating a => StateVector a -> a

-- | Compute the expected body-frame magnetic field strength and direction,
--   given the hard-iron correction and local declination-adjusted field
--   from the state vector. Useful as a measurement model for a 3D
--   magnetometer.
stateMag :: Num a => StateVector a -> XYZ a

-- | Convert body-frame to navigation-frame given the orientation from this
--   state vector.
body2nav :: Num a => StateVector a -> XYZ a -> NED a

-- | Convert navigation-frame to body-frame given the orientation from this
--   state vector.
nav2body :: Num a => StateVector a -> NED a -> XYZ a
instance Show a => Show (StateVector a)
instance Show a => Show (DisturbanceVector a)
instance Distributive DisturbanceVector
instance Traversable DisturbanceVector
instance Foldable DisturbanceVector
instance Functor DisturbanceVector
instance Applicative DisturbanceVector
instance Distributive StateVector
instance Traversable StateVector
instance Foldable StateVector
instance Functor StateVector
instance Applicative StateVector
instance Additive StateVector


-- | System models using this package will usually require these modules.
module Numeric.Estimator
