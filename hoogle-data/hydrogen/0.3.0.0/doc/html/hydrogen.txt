-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An alternate Prelude
--   
@package hydrogen
@version 0.3.0.0

module H.Prelude
show :: Show a => a -> Text
read :: Read a => Text -> Maybe a
todo :: a
error :: Text -> a
impossible :: Text -> a

-- | If the input is Just, do a monadic action on the value
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
onFst :: (a -> c) -> (a, b) -> (c, b)
onSnd :: (b -> c) -> (a, b) -> (a, c)
onFstF :: Functor f => (a -> f c) -> (a, b) -> f (c, b)
onSndF :: Functor f => (b -> f c) -> (a, b) -> f (a, c)
lift2 :: (MonadTrans t, MonadTrans u, Monad m, Monad (u m)) => m a -> t (u m) a
lift3 :: (MonadTrans t, MonadTrans u, MonadTrans v, Monad m, Monad (u m), Monad (t (u m))) => m a -> v (t (u m)) a
lift4 :: (MonadTrans t, MonadTrans u, MonadTrans v, MonadTrans w, Monad m, Monad (u m), Monad (t (u m)), Monad (v (t (u m)))) => m a -> w (v (t (u m))) a

-- | Modify the state of a StateT using a monadic action of the inner
--   monad.
modifyM :: Monad m => (s -> m s) -> StateT s m ()

-- | Find the minimum element of a list using a monadic comparison action.
minimumByM :: Monad m => (a -> a -> m Ordering) -> [a] -> m a
data Proxy a
Proxy :: Proxy a
asProxied :: a -> Proxy a -> a

-- | Like <a>|</a>, but the operands may have different value types, with
--   Either providing a union of those two types in the result
eitherAlt :: Alternative f => f a -> f b -> f (Either a b)

-- | Sequence a list of actions that return Maybes, stopping at the first
--   Nothing
sequenceWhileJust :: Monad m => [m (Maybe a)] -> m [a]

-- | Deconstruct a list into its head and tail
headView :: [a] -> Maybe (a, [a])

-- | Get the first element of a triple
fst3 :: (a, b, c) -> a

-- | Get the second element of a triple
snd3 :: (a, b, c) -> b

-- | Get the third element of a triple
thd3 :: (a, b, c) -> c

-- | Union two maps, with a monadic action for merging duplicates
unionWithM :: (Ord k, Monad m) => (a -> a -> m a) -> Map k a -> Map k a -> m (Map k a)

-- | Like when, but the condition is also a monadic action
whenM :: Monad m => m Bool -> m () -> m ()
traceVal :: Show a => a -> a
setCatMaybes :: Ord a => Set (Maybe a) -> Set a
setSequence :: (Ord a, Applicative f) => Set (f a) -> f (Set a)
onLeft :: (a -> c) -> Either a b -> Either c b
onRight :: (b -> c) -> Either a b -> Either a c
whenJustM :: Monad m => m (Maybe a) -> (a -> m ()) -> m ()
boolToMaybe :: Bool -> Maybe ()

module H.Pretty
text :: Text -> Doc
sizedText :: Int -> Text -> Doc
zeroWidthText :: Text -> Doc
render :: Doc -> Text
renderStyle :: Style -> Doc -> Text
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a
data TextDetails
Chr :: !Char -> TextDetails
Str :: Text -> TextDetails

module H.IO
getArgs :: MonadIO m => m [Text]

module H.Chan
data ReadChan a
data WriteChan a
class RChan chan
readChan :: RChan chan => chan a -> IO a
class WChan chan
writeChan :: WChan chan => chan a -> a -> IO ()
class (RChan chan, WChan chan) => RWChan chan
splitChan :: Chan a -> (ReadChan a, WriteChan a)
newSplitChan :: IO (ReadChan a, WriteChan a)

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a :: * -> *

-- | Build and returns a new instance of <a>Chan</a>.
newChan :: IO (Chan a)
instance RWChan Chan
instance WChan Chan
instance RChan Chan
instance WChan WriteChan
instance RChan ReadChan
