-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators for supporting interleaving of different behaviours
--   
--   This package adds some combinators that can be used with any type
--   constructor that has an instance for both Alternative and Monad. The
--   rationale, design and implementation are all explained in an article
--   in The Monad Reader issue 17, which will appear on
--   <a>http://themonadreader.wordpress.com/</a> imminently.
@package interleave
@version 1.0


-- | A module containing interleaving behaviour combinators. See the
--   <a>engage</a> function for some details and examples. A much fuller
--   explanation of this entire library is provided in the forthcoming
--   article in Issue 17 of The Monad Reader which will be published at
--   <a>http://themonadreader.wordpress.com/</a>.
module Control.Alternative.Interleave

-- | This data-type represents potentially-many actions in the <tt>f</tt>
--   <a>Monad</a> / <a>Alternative</a> that will result in returning a
--   value of type <tt>a</tt>. See <a>engage</a> for more details.
--   
--   The <a>Functor</a> instance is straightforward. The <a>&lt;*&gt;</a>
--   operator in the <a>Applicative</a> instance runs the left-hand side
--   and right-hand side <a>alongside</a> each other, and afterwards it
--   applies the left-hand function to the right-hand value.
data InterleaveT f a

-- | Offers the given behaviour until either the finite set of actions is
--   exhausted, or one of the explicit termination constructs is triggered.
--   
--   For example:
--   
--   <pre>
--   engage $ unlimited p `alongside` unlimited q
--   </pre>
--   
--   will repeatedly offer <tt>p</tt> and <tt>q</tt> without ever
--   terminating.
--   
--   <pre>
--   engage $ upTo 3 p `alongside` upTo 5 q
--   </pre>
--   
--   will do <tt>p</tt> three times and <tt>q</tt> 5 times (in any mixed
--   order) then finish.
--   
--   <pre>
--   engage $ unlimited p `alongside` unlimited q `alongside` endAfter (once r)
--   </pre>
--   
--   will offer p repeatedly and q repeatedly and r, until r happens, at
--   which point the behaviour will end.
--   
--   <pre>
--   engage $ once p `alongside` endAfter (once q)
--   </pre>
--   
--   will offer p and q; if p happens first it will wait for q, but if q
--   happens first it will finish.
--   
--   <pre>
--   engage $ once p `alongside` endAfter (once q) `alongside` endAfter (once r)
--   </pre>
--   
--   permits p to happen at most once, while either of q or r happening
--   will finish the call.
--   
--   All sorts of combinations are possible, but it is important to note
--   that you need at least one <a>endAfter</a> or <a>endWhen</a> event if
--   you ever intend a call involving <a>unlimited</a> (or similar) to
--   finish. Some laws involving <a>engage</a> (ignoring the types and
--   return values) are:
--   
--   <pre>
--   engage (unlimited p) == forever p
--   engage (once p) == Just &lt;$&gt; p
--   engage (endAfter (once p)) == engage (once p)
--   engage (endAfter (once p) `alongside` endAfter (once q)) == p &lt;|&gt; q
--   </pre>
--   
--   Most other uses of <a>engage</a> and <a>alongside</a> do not reduce
--   down to simple programs, which is of course the attraction of the
--   combinators.
engage :: Monad f => InterleaveT f a -> f a

-- | Offers all the given behaviours together, and gives back a list of the
--   outcomes.
--   
--   This is roughly a shorthand for <tt>engage . foldr1 alongside</tt>,
--   except that if you pass the empty list, you simply get the empty list
--   returned (rather than an error)
engageMany :: (Monad f, Alternative f) => [InterleaveT f a] -> f [a]

-- | Offers one behaviour alongside another.
--   
--   This operation is semantically associative and commutative.
alongside :: Alternative f => InterleaveT f a -> InterleaveT f b -> InterleaveT f (a, b)

-- | Like <a>alongside</a> but discards the results.
alongside_ :: Alternative f => InterleaveT f a -> InterleaveT f b -> InterleaveT f ()

-- | Like <a>alongside</a> but merges the results with <a>mappend</a>
--   afterwards.
--   
--   <tt>alongsideMerge a b</tt> is equivalent to <tt>uncurry mappend
--   &lt;$&gt; (a `alongside` b)</tt> and <tt>liftA2 mappend a b</tt>.
alongsideMerge :: (Alternative f, Monoid a) => InterleaveT f a -> InterleaveT f a -> InterleaveT f a

-- | Acts like the given item, but when it has no more actions to take,
--   ends the entire call to <a>engage</a>. So this code:
--   
--   <pre>
--   engage $ unlimited p `alongside` endAfter (once q)
--   </pre>
--   
--   Will terminate after <tt>q</tt> occurs. In contrast, this code:
--   
--   <pre>
--   engage $ unlimited p `alongside` once q
--   </pre>
--   
--   will never terminate because it can always offer to perform q.
endAfter :: Functor f => InterleaveT f a -> InterleaveT f a

-- | Acts like the given item, but when the current result value satisfies
--   the given function (i.e. applying the function yields <a>True</a>),
--   ends the entire call to <a>engage</a>.
endWhen :: Functor f => (a -> Bool) -> InterleaveT f a -> InterleaveT f a

-- | Offers the given behaviour, and when it occurs, does not offer it
--   again. Returns <tt>Just</tt> the result if the behaviour happens,
--   otherwise gives <tt>Nothing</tt>.
--   
--   <tt>once m</tt> is equivalent to <tt>listToMaybe &lt;$&gt; upTo 1
--   m</tt> (and thus also <tt>listToMaybe &lt;$&gt; inOrder [m]</tt>).
once :: Functor f => f a -> InterleaveT f (Maybe a)

-- | Like <a>once</a> but discards the result.
once_ :: Functor f => f a -> InterleaveT f ()

-- | Offers the given behaviour up to the given number of times, returning
--   a list of the results (in chronological order, earliest first).
--   
--   <tt>upTo n</tt> is equivalent to <tt>inOrder . replicate n</tt>.
upTo :: Functor f => Int -> f a -> InterleaveT f [a]

-- | Like <a>upTo</a>, but discards the results.
upTo_ :: Functor f => Int -> f a -> InterleaveT f ()

-- | Offers the given list of items, in order.
inOrder :: Functor f => [f a] -> InterleaveT f [a]

-- | Like <a>inOrder</a>, but discards the results.
inOrder_ :: Functor f => [f a] -> InterleaveT f ()

-- | Repeatedly offers the given behaviour. A list is returned (in
--   chronological order, earliest first) of the results of each occurrence
--   of the behaviour. If you don't want these results, it is better to use
--   <a>unlimited_</a> to avoid a space leak.
--   
--   <tt>unlimited</tt> is equivalent to <tt>inOrder . repeat</tt>.
unlimited :: Functor f => f a -> InterleaveT f [a]

-- | Like <a>unlimited</a>, but discards the output. Useful if the event is
--   likely to occur many times, and you don't need the results.
unlimited_ :: Functor f => f a -> InterleaveT f ()

-- | Like <a>unlimited</a>, but allows some state (of type <tt>a</tt>) to
--   be passed from one subsequent call to another, as well as generating
--   the results of type <tt>b</tt>. To begin with the function (first
--   parameter) will be called with the initial state (second parameter).
--   If chosen, it will return the new state, and a result to be
--   accumulated into the list. The second call to the function will be
--   passed the new state, to then return the even newer state and a second
--   result, and so on.
--   
--   If you want to use this with the StateT monad transformer from the mtl
--   library, you can call:
--   
--   <pre>
--   unlimitedRecurse (runStateT myStateAction) initialState
--     where
--       myStateAction :: StateT s m a
--       initialState :: s
--   </pre>
unlimitedRecurse :: Functor f => (a -> f (b, a)) -> a -> InterleaveT f [b]

-- | Like <a>unlimitedRecurse</a>, but does not accumulate a list of
--   results.
--   
--   If you want to use this with the StateT monad transformer from the mtl
--   library, you can call:
--   
--   <pre>
--   unlimitedRecurse (execStateT myStateAction) initialState
--     where
--       myStateAction :: StateT s m a
--       initialState :: s
--   </pre>
unlimitedRecurse_ :: Functor f => (a -> f a) -> a -> InterleaveT f ()
instance Alternative f => Applicative (InterleaveT f)
instance Functor f => Functor (InterleaveT f)
