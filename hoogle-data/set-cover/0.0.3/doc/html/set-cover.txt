-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube
--   
--   Solver for exact set cover problems. Included examples: Sudoku, 8
--   Queens, Soma Cube, Tetris Cube, Cube of L's, Logika's Baumeister
--   puzzle. Generic algorithm allows to choose between slow but flexible
--   <tt>Set</tt> from <tt>containers</tt> package and fast but cumbersome
--   bitvectors.
--   
--   Build examples with <tt>cabal install -fbuildExamples</tt>.
--   
--   The package needs only Haskell 98.
@package set-cover
@version 0.0.3

module Math.SetCover.Cuboid
data Coords a
Coords :: a -> a -> a -> Coords a
coordsFromString :: [[String]] -> [Coords Int]
coordsFrom2LayerString :: [String] -> [Coords Int]
numberOf2LayerAtoms :: [[String]] -> Int
forNestedCoords :: (Enum a, Num a) => ([z] -> b) -> ([y] -> z) -> ([x] -> y) -> (Coords a -> x) -> Coords a -> b
newtype PackedCoords
PackedCoords :: Int -> PackedCoords
dx :: Num a => Coords a -> Coords a
dz :: Num a => Coords a -> Coords a
dy :: Num a => Coords a -> Coords a
rotations :: Num a => [Coords a -> Coords a]
type Size = Coords Int
unpackCoords :: Size -> PackedCoords -> Coords Int
packCoords :: Size -> Coords Int -> PackedCoords
normalForm :: (Ord a, Num a) => [Coords a] -> [Coords a]

-- | Object must be in <a>normalForm</a>.
size :: [Coords Int] -> Coords Int
allPositions :: Size -> [Coords Int] -> [[Coords Int]]
allOrientations :: (Num a, Ord a) => [Coords a] -> [[Coords a]]
instance Eq a => Eq (Coords a)
instance Ord a => Ord (Coords a)
instance Show a => Show (Coords a)
instance Eq PackedCoords
instance Ord PackedCoords
instance Show PackedCoords
instance Traversable Coords
instance Foldable Coords
instance Applicative Coords
instance Functor Coords

module Math.SetCover.Bit
class Eq bits => C bits
empty :: C bits => bits
complement, keepMinimum :: C bits => bits -> bits
xor, .|., .&. :: C bits => bits -> bits -> bits
data Sum a b
Sum :: !a -> !b -> Sum a b
bitLeft :: (Bits a, C b) => Int -> Sum a b
bitRight :: (C a, Bits b) => Int -> Sum a b
instance (Eq a, Eq b) => Eq (Sum a b)
instance (Show a, Show b) => Show (Sum a b)
instance (C a, C b) => C (Sum a b)
instance C Word64
instance C Word32
instance C Word16
instance C Word8

module Math.SetCover.BitSet
newtype Set bits
Set :: bits -> Set bits
empty :: C bits => Set bits
null :: C bits => Set bits -> Bool
keepMinimum :: C bits => Set bits -> Set bits
disjoint :: C bits => Set bits -> Set bits -> Bool
difference :: C bits => Set bits -> Set bits -> Set bits
instance Show bits => Show (Set bits)
instance C bits => Monoid (Set bits)

module Math.SetCover.BitMap
newtype Map bits
Map :: [bits] -> Map bits
unMap :: Map bits -> [bits]
fromSet :: C bits => Set bits -> Map bits
add :: C bits => Map bits -> Map bits -> Map bits
inc :: C bits => Set bits -> Map bits -> Map bits
minimumSet :: C bits => Set bits -> Map bits -> Set bits
instance Show bits => Show (Map bits)
instance C bits => Monoid (Map bits)

module Math.SetCover.Exact
class Set set
null :: Set set => set -> Bool
disjoint :: Set set => set -> set -> Bool
unions :: Set set => [set] -> set
difference :: Set set => set -> set -> set
minimize :: Set set => set -> [Assign label set] -> [Assign label set]
data Assign label set
Assign :: label -> set -> Assign label set
label :: Assign label set -> label
labeledSet :: Assign label set -> set
assign :: label -> set -> Assign label set
data State label set
State :: [Assign label set] -> set -> [Assign label set] -> State label set
availableSubsets :: State label set -> [Assign label set]
freeElements :: State label set -> set
usedSubsets :: State label set -> [Assign label set]
initState :: Set set => [Assign label set] -> State label set
updateState :: Set set => Assign label set -> State label set -> State label set
step :: Set set => State label set -> [State label set]
search :: Set set => State label set -> [[label]]
partitions :: Set set => [Assign label set] -> [[label]]
instance Functor (State label)
instance Functor (Assign label)
instance C a => Set (Set a)
instance Ord a => Set (Set a)
