-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HDBC snaplet for Snap Framework
--   
--   This snaplet consists of two parts: an HDBC abstraction snaplet and an
--   HDBC authentication backend for Snap's authentication snaplet.
@package snaplet-hdbc
@version 0.9.1

module Snap.Snaplet.Hdbc.Types

-- | The snaplet state type containing a resource pool, parameterised by a
--   raw HDBC connection.
data HdbcSnaplet c s
HdbcSnaplet :: s c -> MVar c -> HdbcSnaplet c s
connSrc :: HdbcSnaplet c s -> s c
connVar :: HdbcSnaplet c s -> MVar c
class ConnSrc s
withConn :: (ConnSrc s, MonadCatchIO m, IConnection c) => HdbcSnaplet c s -> (c -> m b) -> m b
closeConn :: (ConnSrc s, MonadCatchIO m, IConnection c) => HdbcSnaplet c s -> c -> m ()
instance ConnSrc IO
instance ConnSrc Pool


-- | This module provides a very thin wrapper around HDBC. It wraps some of
--   the HDBC functions in more convenient functions and re-exports the
--   rest of the HDBC functions.
module Snap.Snaplet.Hdbc

-- | The snaplet state type containing a resource pool, parameterised by a
--   raw HDBC connection.
data HdbcSnaplet c s
HdbcSnaplet :: s c -> MVar c -> HdbcSnaplet c s
connSrc :: HdbcSnaplet c s -> s c
connVar :: HdbcSnaplet c s -> MVar c

-- | Instantiate this typeclass on 'Handler b YourSnapletState' so this
--   snaplet can find the connection source.
class (IConnection c, ConnSrc s, MonadCatchIO m) => HasHdbc m c s | m -> c s
getHdbcState :: HasHdbc m c s => m (HdbcSnaplet c s)
type HdbcIO c = HdbcSnaplet c IO
type HdbcPool c = HdbcSnaplet c Pool

-- | A map with the column name as key and the value from the database as
--   value
type Row = Map String SqlValue

-- | Initialise the snaplet by providing it with a raw HDBC connection. A
--   resource pool is created with some default parameters that should be
--   fine for most common usecases. If a custom resource pool configuration
--   is desired, use the <tt>hdbcInit'</tt> initialiser instead. When the
--   snaplet is unloaded, the <a>disconnect</a> function is called to close
--   any remaining connections.
hdbcInit :: (ConnSrc s, IConnection c) => s c -> SnapletInit b (HdbcSnaplet c s)

-- | Execute a <tt>SELECT</tt> query on the database by passing the query
--   as <a>String</a>, together with a list of values to bind to it. A list
--   of <a>Row</a>s is returned.
query :: HasHdbc m c s => String -> [SqlValue] -> m [Row]

-- | Similar to <a>query</a>, but instead of returning a list of
--   <a>Row</a>s, it returns an <a>Integer</a> indicating the numbers of
--   affected rows. This is typically used for <tt>INSERT</tt>,
--   <tt>UPDATE</tt> and <tt>DELETE</tt> queries. TODO: Revert to the
--   implementation below once withTransaction' works as expected.
query' :: HasHdbc m c s => String -> [SqlValue] -> m Integer
clone :: HasHdbc m c s => m c
commit :: HasHdbc m c s => m ()
dbServerVer :: HasHdbc m c s => m String
dbTransactionSupport :: HasHdbc m c s => m Bool
describeTable :: HasHdbc m c s => String -> m [(String, SqlColDesc)]

-- | The functions provided below are wrappers around the original HDBC
--   functions. Please refer to the HDBC documentation to see what they do
--   and how they work.
disconnect :: HasHdbc m c s => m ()
getTables :: HasHdbc m c s => m [String]
hdbcClientVer :: HasHdbc m c s => m String
hdbcDriverName :: HasHdbc m c s => m String
prepare :: HasHdbc m c s => String -> m Statement
proxiedClientName :: HasHdbc m c s => m String
proxiedClientVer :: HasHdbc m c s => m String
quickQuery :: HasHdbc m c s => String -> [SqlValue] -> m [[SqlValue]]
quickQuery' :: HasHdbc m c s => String -> [SqlValue] -> m [[SqlValue]]
rollback :: HasHdbc m c s => m ()
run :: HasHdbc m c s => String -> [SqlValue] -> m Integer
runRaw :: HasHdbc m c s => String -> m ()
sRun :: HasHdbc m c s => String -> [Maybe String] -> m Integer

-- | Get a new connection from the resource pool, apply the provided
--   function to it and return the result in of the <a>IO</a> compution in
--   monad <tt>m</tt>.
withHdbc :: HasHdbc m c s => (c -> IO a) -> m a

-- | Get a new connection from the resource pool, apply the provided
--   function to it and return the result in of the compution in monad
--   <tt>m</tt>.
withHdbc' :: HasHdbc m c s => (c -> a) -> m a

-- | Run an action inside a transaction. If the action throws an exception,
--   the transaction will be rolled back, and the exception rethrown.
--   
--   <pre>
--   withTransaction' $ \conn -&gt; do ...
--   </pre>
withTransaction :: HasHdbc m c s => (c -> IO a) -> m a
withTransaction' :: HasHdbc m c s => m a -> m a

-- | <a>SqlValue</a> is he main type for expressing Haskell values to SQL
--   databases.
--   
--   <i>INTRODUCTION TO SQLVALUE</i>
--   
--   This type is used to marshall Haskell data to and from database APIs.
--   HDBC driver interfaces will do their best to use the most accurate and
--   efficient way to send a particular value to the database server.
--   
--   Values read back from the server are constructed with the most
--   appropriate <a>SqlValue</a> constructor. <a>fromSql</a> or
--   <a>safeFromSql</a> can then be used to convert them into whatever type
--   is needed locally in Haskell.
--   
--   Most people will use <a>toSql</a> and <a>fromSql</a> instead of
--   manipulating <a>SqlValue</a>s directly.
--   
--   <i>EASY CONVERSIONS BETWEEN HASKELL TYPES</i>
--   
--   Conversions are powerful; for instance, you can call <a>fromSql</a> on
--   a SqlInt32 and get a String or a Double out of it. This class attempts
--   to Do The Right Thing whenever possible, and will raise an error when
--   asked to do something incorrect. In particular, when converting to any
--   type except a Maybe, <a>SqlNull</a> as the input will cause an error
--   to be raised.
--   
--   Conversions are implemented in terms of the <a>Data.Convertible</a>
--   module, part of the convertible package. You can refer to its
--   documentation, and import that module, if you wish to parse the Left
--   result from <a>safeFromSql</a> yourself, or write your own conversion
--   instances.
--   
--   Here are some notes about conversion:
--   
--   <ul>
--   <li>Fractions of a second are not preserved on time values</li>
--   <li>There is no <tt>safeToSql</tt> because <a>toSql</a> never
--   fails.</li>
--   </ul>
--   
--   See also <a>toSql</a>, <a>safeFromSql</a>, <a>fromSql</a>,
--   <a>nToSql</a>, <a>iToSql</a>, <a>posixToSql</a>.
--   
--   <i>ERROR CONDITIONS</i>
--   
--   There may sometimes be an error during conversion. For instance, if
--   you have a <a>SqlString</a> and are attempting to convert it to an
--   Integer, but it doesn't parse as an Integer, you will get an error.
--   This will be indicated as an exception if using <a>fromSql</a>, or a
--   Left result if using <a>safeFromSql</a>.
--   
--   <i>SPECIAL NOTE ON POSIXTIME</i>
--   
--   Note that a <a>NominalDiffTime</a> or <a>POSIXTime</a> is converted to
--   <a>SqlDiffTime</a> by <a>toSql</a>. HDBC cannot differentiate between
--   <a>NominalDiffTime</a> and <a>POSIXTime</a> since they are the same
--   underlying type. You must construct <a>SqlPOSIXTime</a> manually or
--   via <a>posixToSql</a>, or use <a>SqlUTCTime</a>.
--   
--   <i>DETAILS ON SQL TYPES</i>
--   
--   HDBC database backends are expected to marshal date and time data back
--   and forth using the appropriate representation for the underlying
--   database engine. Databases such as PostgreSQL with builtin date and
--   time types should see automatic conversion between these Haskell types
--   to database types. Other databases will be presented with an integer
--   or a string. Care should be taken to use the same type on the Haskell
--   side as you use on the database side. For instance, if your database
--   type lacks timezone information, you ought not to use ZonedTime, but
--   instead LocalTime or UTCTime. Database type systems are not always as
--   rich as Haskell. For instance, for data stored in a TIMESTAMP WITHOUT
--   TIME ZONE column, HDBC may not be able to tell if it is intended as
--   UTCTime or LocalTime data, and will happily convert it to both, upon
--   your request. It is your responsibility to ensure that you treat
--   timezone issues with due care.
--   
--   This behavior also exists for other types. For instance, many
--   databases do not have a Rational type, so they will just use the show
--   function and store a Rational as a string.
--   
--   The conversion between Haskell types and database types is complex,
--   and generic code in HDBC or its backends cannot possibly accomodate
--   every possible situation. In some cases, you may be best served by
--   converting your Haskell type to a String, and passing that to the
--   database.
--   
--   <i>UNICODE AND BYTESTRINGS</i>
--   
--   Beginning with HDBC v2.0, interactions with a database are presumed to
--   occur in UTF-8.
--   
--   To accomplish this, whenever a ByteString must be converted to or from
--   a String, the ByteString is assumed to be in UTF-8 encoding, and will
--   be decoded or encoded as appropriate. Database drivers will generally
--   present text or string data they have received from the database as a
--   SqlValue holding a ByteString, which <a>fromSql</a> will automatically
--   convert to a String, and thus automatically decode UTF-8, when you
--   need it. In the other direction, database drivers will generally
--   convert a <a>SqlString</a> to a ByteString in UTF-8 encoding before
--   passing it to the database engine.
--   
--   If you are handling some sort of binary data that is not in UTF-8, you
--   can of course work with the ByteString directly, which will bypass any
--   conversion.
--   
--   Due to lack of support by database engines, lazy ByteStrings are not
--   passed to database drivers. When you use <a>toSql</a> on a lazy
--   ByteString, it will be converted to a strict ByteString for storage.
--   Similarly, <a>fromSql</a> will convert a strict ByteString to a lazy
--   ByteString if you demand it.
--   
--   <i>EQUALITY OF SQLVALUE</i>
--   
--   Two SqlValues are considered to be equal if one of these hold. The
--   first comparison that can be made is controlling; if none of these
--   comparisons can be made, then they are not equal:
--   
--   <ul>
--   <li>Both are NULL</li>
--   <li>Both represent the same type and the encapsulated values are
--   considered equal by applying (==) to them</li>
--   <li>The values of each, when converted to a string, are equal.</li>
--   </ul>
--   
--   <i>STRING VERSIONS OF TIMES</i>
--   
--   Default string representations are given as comments below where such
--   are non-obvious. These are used for <a>fromSql</a> when a
--   <a>String</a> is desired. They are also defaults for representing data
--   to SQL backends, though individual backends may override them when a
--   different format is demanded by the underlying database. Date and time
--   formats use ISO8601 date format, with HH:MM:SS added for time, and
--   -HHMM added for timezone offsets.
--   
--   <i>DEPRECATED CONSTRUCTORS</i>
--   
--   <a>SqlEpochTime</a> and <a>SqlTimeDiff</a> are no longer created
--   automatically by any <a>toSql</a> or <a>fromSql</a> functions or
--   database backends. They may still be manually constructed, but are
--   expected to be removed in a future version. Although these two
--   constructures will be removed, support for marshalling to and from the
--   old System.Time data will be maintained as long as System.Time is,
--   simply using the newer data types for conversion.
data SqlValue :: *
SqlString :: String -> SqlValue
SqlByteString :: ByteString -> SqlValue
SqlWord32 :: Word32 -> SqlValue
SqlWord64 :: Word64 -> SqlValue
SqlInt32 :: Int32 -> SqlValue
SqlInt64 :: Int64 -> SqlValue
SqlInteger :: Integer -> SqlValue
SqlChar :: Char -> SqlValue
SqlBool :: Bool -> SqlValue
SqlDouble :: Double -> SqlValue
SqlRational :: Rational -> SqlValue

-- | Local YYYY-MM-DD (no timezone)
SqlLocalDate :: Day -> SqlValue

-- | Local HH:MM:SS (no timezone)
SqlLocalTimeOfDay :: TimeOfDay -> SqlValue

-- | Local HH:MM:SS -HHMM. Converts to and from (TimeOfDay, TimeZone).
SqlZonedLocalTimeOfDay :: TimeOfDay -> TimeZone -> SqlValue

-- | Local YYYY-MM-DD HH:MM:SS (no timezone)
SqlLocalTime :: LocalTime -> SqlValue

-- | Local YYYY-MM-DD HH:MM:SS -HHMM. Considered equal if both convert to
--   the same UTC time.
SqlZonedTime :: ZonedTime -> SqlValue

-- | UTC YYYY-MM-DD HH:MM:SS
SqlUTCTime :: UTCTime -> SqlValue

-- | Calendar diff between seconds. Rendered as Integer when converted to
--   String, but greater precision may be preserved for other types or to
--   underlying database.
SqlDiffTime :: NominalDiffTime -> SqlValue

-- | Time as seconds since midnight Jan 1 1970 UTC. Integer rendering as
--   for <a>SqlDiffTime</a>.
SqlPOSIXTime :: POSIXTime -> SqlValue

-- | DEPRECATED Representation of ClockTime or CalendarTime. Use
--   SqlPOSIXTime instead.
SqlEpochTime :: Integer -> SqlValue

-- | DEPRECATED Representation of TimeDiff. Use SqlDiffTime instead.
SqlTimeDiff :: Integer -> SqlValue

-- | NULL in SQL or Nothing in Haskell
SqlNull :: SqlValue

-- | Convert a value to an <a>SqlValue</a>. This function is simply a
--   restricted-type wrapper around <a>convert</a>. See extended notes on
--   <a>SqlValue</a>.
toSql :: Convertible a SqlValue => a -> SqlValue

-- | Convert from an <a>SqlValue</a> to a Haskell value. Any problem is
--   indicated by calling <a>error</a>. This function is simply a
--   restricted-type wrapper around <a>convert</a>. See extended notes on
--   <a>SqlValue</a>.
fromSql :: Convertible SqlValue a => SqlValue -> a

-- | Conversions to and from <a>SqlValue</a>s and standard Haskell types.
--   
--   This function converts from an <a>SqlValue</a> to a Haskell value.
--   Many people will use the simpler <a>fromSql</a> instead. This function
--   is simply a restricted-type wrapper around <a>safeConvert</a>.
safeFromSql :: Convertible SqlValue a => SqlValue -> ConvertResult a

-- | Converts any Integral type to a <a>SqlValue</a> by using toInteger.
nToSql :: Integral a => a -> SqlValue

-- | Convenience function for using numeric literals in your program.
iToSql :: Int -> SqlValue

-- | Convenience function for converting <a>POSIXTime</a> to a
--   <a>SqlValue</a>, because <a>toSql</a> cannot do the correct thing in
--   this instance.
posixToSql :: POSIXTime -> SqlValue

-- | Unwrap a <a>ConnWrapper</a> and pass the embedded <a>IConnection</a>
--   to a function. Example:
--   
--   <pre>
--   withWConn wrapped run $ "SELECT * from foo where bar = 1" []
--   </pre>
withWConn :: ConnWrapper -> (forall conn. IConnection conn => conn -> b) -> b
data Statement :: *

-- | Like <a>execute</a>, but take a list of Maybe Strings instead of
--   <a>SqlValue</a>s.
sExecute :: Statement -> [Maybe String] -> IO Integer

-- | Like <a>executeMany</a>, but take a list of Maybe Strings instead of
--   <a>SqlValue</a>s.
sExecuteMany :: Statement -> [[Maybe String]] -> IO ()

-- | Like <a>fetchRow</a>, but instead of returning a list, return an
--   association list from column name to value.
--   
--   The keys of the column names are lowercase versions of the data
--   returned by <a>getColumnNames</a>. Please heed the warnings there.
--   Additionally, results are undefined if multiple columns are returned
--   with identical names.
fetchRowAL :: Statement -> IO (Maybe [(String, SqlValue)])

-- | Similar to <a>fetchRowAL</a>, but return a Map instead of an
--   association list.
fetchRowMap :: Statement -> IO (Maybe (Map String SqlValue))

-- | Like <a>fetchRow</a>, but return a list of Maybe Strings instead of
--   <a>SqlValue</a>s.
sFetchRow :: Statement -> IO (Maybe [Maybe String])

-- | Lazily fetch all rows from an executed <a>Statement</a>.
--   
--   You can think of this as hGetContents applied to a database result
--   set.
--   
--   The result of this is a lazy list, and each new row will be read,
--   lazily, from the database as the list is processed.
--   
--   When you have exhausted the list, the <a>Statement</a> will be
--   <a>finish</a>ed.
--   
--   Please note that the careless use of this function can lead to some
--   unpleasant behavior. In particular, if you have not consumed the
--   entire list, then attempt to <a>finish</a> or re-execute the
--   statement, and then attempt to consume more elements from the list,
--   the result will almost certainly not be what you want.
--   
--   But then, similar caveats apply with hGetContents.
--   
--   Bottom line: this is a very convenient abstraction; use it wisely.
--   
--   Use <a>fetchAllRows'</a> if you need something that is strict, without
--   all these caveats.
fetchAllRows :: Statement -> IO [[SqlValue]]

-- | Strict version of <a>fetchAllRows</a>. Does not have the side-effects
--   of <a>fetchAllRows</a>, but forces the entire result set to be
--   buffered in memory.
fetchAllRows' :: Statement -> IO [[SqlValue]]

-- | Like <a>fetchAllRows</a>, but instead of returning a list for each
--   row, return an association list for each row, from column name to
--   value.
--   
--   See <a>fetchRowAL</a> for more details.
fetchAllRowsAL :: Statement -> IO [[(String, SqlValue)]]

-- | Strict version of <a>fetchAllRowsAL</a>
fetchAllRowsAL' :: Statement -> IO [[(String, SqlValue)]]

-- | Like <a>fetchAllRowsAL</a>, but return a list of Maps instead of a
--   list of association lists.
fetchAllRowsMap :: Statement -> IO [Map String SqlValue]

-- | Strict version of <a>fetchAllRowsMap</a>
fetchAllRowsMap' :: Statement -> IO [Map String SqlValue]

-- | Like <a>fetchAllRows</a>, but return Maybe Strings instead of
--   <a>SqlValue</a>s.
sFetchAllRows :: Statement -> IO [[Maybe String]]

-- | Strict version of <a>sFetchAllRows</a>.
sFetchAllRows' :: Statement -> IO [[Maybe String]]

-- | The main HDBC exception object. As much information as possible is
--   passed from the database through to the application through this
--   object.
--   
--   Errors generated in the Haskell layer will have seNativeError set to
--   -1.
data SqlError :: *
SqlError :: String -> Int -> String -> SqlError
seState :: SqlError -> String
seNativeError :: SqlError -> Int
seErrorMsg :: SqlError -> String

-- | A utility function to throw a <a>SqlError</a>. The mechanics of
--   throwing such a thing differ between GHC 6.8.x, Hugs, and GHC 6.10.
--   This function takes care of the special cases to make it simpler.
--   
--   With GHC 6.10, it is a type-restricted alias for throw. On all other
--   systems, it is a type-restricted alias for throwDyn.
throwSqlError :: SqlError -> IO a

-- | Execute the given IO action.
--   
--   If it raises a <a>SqlError</a>, then execute the supplied handler and
--   return its return value. Otherwise, proceed as normal.
catchSql :: IO a -> (SqlError -> IO a) -> IO a

-- | Like <a>catchSql</a>, with the order of arguments reversed.
handleSql :: (SqlError -> IO a) -> IO a -> IO a

-- | Given an Exception, return Just SqlError if it was an SqlError, or
--   Nothing otherwise. Useful with functions like catchJust.
sqlExceptions :: SqlError -> Maybe SqlError

-- | Catches <a>SqlError</a>s, and re-raises them as IO errors with fail.
--   Useful if you don't care to catch SQL errors, but want to see a sane
--   error message if one happens. One would often use this as a high-level
--   wrapper around SQL calls.
handleSqlError :: IO a -> IO a


-- | Authentication backend using HDBC
module Snap.Snaplet.Auth.Backends.Hdbc

-- | Initialises this HDBC snaplet. It automatically configures a resource
--   pool with commonly acceptable default settings. Use
--   <tt>initHdbcAuthManager'</tt> to initialise with a custom resource
--   pool.
initHdbcAuthManager :: (ConnSrc s, IConnection c) => AuthSettings -> Lens b (Snaplet SessionManager) -> s c -> AuthTable -> Queries -> SnapletInit b (AuthManager b)

-- | Authmanager state containing the resource pool and the table/query
--   configuration.
data HdbcAuthManager
HdbcAuthManager :: HdbcSnaplet c s -> AuthTable -> Queries -> HdbcAuthManager
connSt :: HdbcAuthManager -> HdbcSnaplet c s
table :: HdbcAuthManager -> AuthTable
qries :: HdbcAuthManager -> Queries

-- | Datatype containing the names of the columns for the authentication
--   table.
data AuthTable
AuthTable :: String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> AuthTable
tblName :: AuthTable -> String
colId :: AuthTable -> String
colLogin :: AuthTable -> String
colPassword :: AuthTable -> String
colActivatedAt :: AuthTable -> String
colSuspendedAt :: AuthTable -> String
colRememberToken :: AuthTable -> String
colLoginCount :: AuthTable -> String
colFailedLoginCount :: AuthTable -> String
colLockedOutUntil :: AuthTable -> String
colCurrentLoginAt :: AuthTable -> String
colLastLoginAt :: AuthTable -> String
colCurrentLoginIp :: AuthTable -> String
colLastLoginIp :: AuthTable -> String
colCreatedAt :: AuthTable -> String
colUpdatedAt :: AuthTable -> String
colRoles :: AuthTable -> String
colMeta :: AuthTable -> String

-- | Default authentication table layout
defAuthTable :: AuthTable

-- | List of deconstructors so it's easier to extract column names form an
--   <a>AuthTable</a>.
colLst :: [AuthTable -> String]
data LookupQuery
ByUserId :: LookupQuery
ByLogin :: LookupQuery
ByRememberToken :: LookupQuery
data Queries
Queries :: (AuthTable -> LookupQuery -> [SqlValue] -> (String, [SqlValue])) -> (AuthTable -> AuthUser -> (String, String, [SqlValue])) -> (AuthTable -> AuthUser -> (String, [SqlValue])) -> Queries
selectQuery :: Queries -> AuthTable -> LookupQuery -> [SqlValue] -> (String, [SqlValue])
saveQuery :: Queries -> AuthTable -> AuthUser -> (String, String, [SqlValue])
deleteQuery :: Queries -> AuthTable -> AuthUser -> (String, [SqlValue])
defQueries :: Queries
defSelectQuery :: AuthTable -> LookupQuery -> [SqlValue] -> (String, [SqlValue])
defSaveQuery :: AuthTable -> AuthUser -> (String, String, [SqlValue])
defDeleteQuery :: AuthTable -> AuthUser -> (String, [SqlValue])
prepExec :: IConnection conn => String -> [SqlValue] -> conn -> IO ()
authQuery :: HdbcAuthManager -> (String, [SqlValue]) -> IO (Maybe AuthUser)
mkUser :: AuthTable -> Map String SqlValue -> AuthUser
instance IAuthBackend HdbcAuthManager
instance Convertible UserId SqlValue
instance Convertible Password SqlValue
