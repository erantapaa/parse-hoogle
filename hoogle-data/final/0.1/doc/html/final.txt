-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | utility to add extra safety to monadic returns
--   
--   The <tt>Final</tt> library makes it possible to point out return
--   values in (monadic) functions. This adds extra compile-time safety to
--   your code, because the compiler will warn you if marked return values
--   accidentally became middle parts of a big function written with do
--   notation.
--   
--   Documentation and examples provided in the <tt>Control.Final</tt>
--   module's own documentation.
@package final
@version 0.1


-- | The <tt>Final</tt> library makes it possible to point out return
--   values in (monadic) functions. This adds extra compile-time safety to
--   your code, because the compiler will warn you if marked return values
--   accidentally became middle parts of a big function written with do
--   notation.
--   
--   A worked out example can be found in <a>Control.Final.Example</a>, and
--   an alternative approach is considered in
--   <a>Control.Final.Alternatives</a>.
module Control.Final

-- | Use this instead of <a>return</a> when you want to mark this point as
--   a final return for the corresponding <a>runFinal</a>.
final :: (Monad m, FinalClass f) => x -> m (f x)

-- | Most commonly used at the beginning of functions to mark the point in
--   the code where <a>final</a> calls "return to".
--   
--   This compiles:
--   
--   <pre>
--   simple = runFinal $ do
--     print "line1"
--     do return False
--        return True
--     final True
--   </pre>
--   
--   This fails at the first "<tt>final</tt> <tt>True</tt>":
--   
--   <pre>
--   simple = runFinal $ do
--     print "line1"
--     do return False
--        final True
--     final True
--   </pre>
runFinal :: Monad m => m (Final a) -> m a

-- | Useful when the final return value is a monadic computation itself
--   that after returned has to be joined into the current computation.
joinFinal :: Monad m => m (Final (m a)) -> m a

-- | A version of atomically, that joins and runFinals. This is the most
--   common usage for the author. Details and example can be found in
--   <a>Control.Final.Example</a>.
atomicJoinFinal :: (Functor m, MonadIO m) => STM (Final (m a)) -> m a

-- | MonadIO version of atomically. Not really related to <tt>Final</tt>,
--   but if we already have <a>atomicJoinFinal</a> in this module, it makes
--   sense to provide this too.
atomic :: MonadIO m => STM a -> m a

-- | This class is the main idea behind <tt>Final</tt>. <tt>finalV</tt> is
--   in a type class, so we we can have to instances, therefore if used
--   incorrectly the compiler sees an ambiguity.
class FinalClass f
finalV :: FinalClass f => a -> f a

-- | Usage example:
--   
--   <pre>
--   pureExample p =
--     runFinalV $ case p of
--       True -&gt; finalV "quux"
--       False -&gt; finalV "foobar"
--   </pre>
runFinalV :: Final a -> a
instance FinalClass FinalTooManyReturns
instance FinalClass Final


-- | An alternative to <a>Control.Final</a> is a using the writer monad.
--   
--   <pre>
--   instance Monoid a =&gt; Monoid (IO a) where
--     mempty = return mempty
--     mappend = liftA2 mappend
--   
--   stmExampleW = do
--     tv &lt;- newTVarIO "xxx"
--     join $ atomically $ execWriterT $ do
--       val &lt;- lift $ readTVar tv
--       case val of
--         "xxx" -&gt; do
--           lift $ writeTVar tv "foobar"
--           tell $ print "it was xxx"
--         "yyy" -&gt; do
--           lift $ writeTVar tv "quux"
--           tell $ print "it was yyy"
--       tell $ print "I finished"
--   </pre>
--   
--   This works. Unfortunately when using the writer, you have to
--   <a>lift</a> every operation of the base monad and also there is no
--   such thing as <tt>finalTell</tt> to specify that this is a return
--   point of the function. On the positive side, the writer alternative
--   let's you gather multiple <a>IO</a> operations together using a
--   <a>Monoid</a>, while <a>final</a> can't do that.
module Control.Final.Alternatives


-- | Consider this peace of code:
--   
--   <pre>
--   join $ atomically $ do
--     radarPositive &lt;- readTVar radarTVar
--     launchKeyInserted &lt;- readTVar launchKeyTVar
--     case radarPositive of
--       False -&gt; do
--         modifyTVar radarNegativeCounter (+1)
--         return $ print "No need for missiles, it's peaceful"
--       True -&gt; do
--         modifyTVar radarPositiveCounter (+1)
--         case launchKeyInserted of
--           False -&gt; do
--             modifyTVar keyMissingCounter (+1)
--             return $ print "No launch key, ignoring radar"
--           True -&gt; do
--             modifyTVar launchCounter (+1)
--             return $ launchMissiles
--     return $ print "extra debug: state checking finished"
--   </pre>
--   
--   We use <a>STM</a> to make state checking of multiple <a>TVar</a>s one
--   atomic transaction. Since we can't do <a>IO</a> in <a>STM</a>, we are
--   just returning the <a>IO</a> that needs to be done in the different
--   cases. Unfortunately when we try to add the extra debugging as the
--   last statement, that silently ignores all the previous "return"
--   values, even <tt>launchMissiles</tt>.
--   
--   On the other hand when using final:
--   
--   <pre>
--   atomicJoinFinal $ do
--     radarPositive &lt;- readTVar radarTVar
--     launchKeyInserted &lt;- readTVar launchKeyTVar
--     case radarPositive of
--       False -&gt; do
--         modifyTVar radarNegativeCounter (+1)
--         final $ print "No need for missiles, it's peaceful"
--       True -&gt; do
--         modifyTVar radarPositiveCounter (+1)
--         case launchKeyInserted of
--           False -&gt; do
--             modifyTVar keyMissingCounter (+1)
--             final $ print "No launch key, ignoring radar"
--           True -&gt; do
--             modifyTVar launchCounter (+1)
--             final $ launchMissiles
--     final $ print "extra debug: state checking finished"
--   </pre>
--   
--   We get a compile error that contains this:
--   
--   <pre>
--   Note: there are several potential instances:
--     instance FinalClass Control.Final.FinalTooManyReturns
--   </pre>
--   
--   Internally <tt>Final</tt> is based on ambiguity checking in the type
--   system. The prohibited ambiguity occurs, because the only way to
--   decide what <a>final</a> means is by matching it to the corresponding
--   <a>atomicJoinFinal</a>. This is now only possible for the <a>final</a>
--   at the end of the function and not for the middle ones, so we get the
--   error.
module Control.Final.Example
