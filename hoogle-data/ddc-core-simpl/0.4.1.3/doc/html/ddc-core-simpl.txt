-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Disciplined Disciple Compiler code transformations.
--   
--   Disciplined Disciple Compiler code transformations.
@package ddc-core-simpl
@version 0.4.1.3

module DDC.Type.Transform.Alpha
class Alpha (c :: * -> *)
alpha :: (Alpha c, Ord n2) => (n1 -> n2) -> c n1 -> c n2
instance Alpha TyCon
instance Alpha Bound
instance Alpha Bind
instance Alpha TypeSum
instance Alpha Type


-- | General purpose tree walking boilerplate.
module DDC.Core.Transform.TransformDownX
class TransformDownMX m (c :: * -> * -> *)
transformDownMX :: (TransformDownMX m c, Ord n) => (KindEnv n -> TypeEnv n -> Exp a n -> m (Exp a n)) -> KindEnv n -> TypeEnv n -> c a n -> m (c a n)

-- | Top-down rewrite of all core expressions in a thing.
transformDownX :: (Ord n, TransformDownMX Identity c) => (KindEnv n -> TypeEnv n -> Exp a n -> Exp a n) -> KindEnv n -> TypeEnv n -> c a n -> c a n

-- | Like transformDownX, but without using environments.
transformDownX' :: (Ord n, TransformDownMX Identity c) => (Exp a n -> Exp a n) -> c a n -> c a n
instance Monad m => TransformDownMX m Alt
instance Monad m => TransformDownMX m Lets
instance Monad m => TransformDownMX m Exp
instance Monad m => TransformDownMX m Module


-- | Thread a state token through calls to given functions.
--   
--   ASSUMPTIONS: * Program is a-normalized and fully named.
module DDC.Core.Transform.Thread

-- | Class of things that can have a state token threaded through them.
class Thread (c :: * -> * -> *)
thread :: (Thread c, Ord n, Show n, Pretty n) => Config a n -> KindEnv n -> TypeEnv n -> c (AnTEC a n) n -> c a n

-- | Configuration for the Thread transform.
data Config a n
Config :: Config n -> (n -> Type n -> Maybe (Type n)) -> Type n -> Type n -> (Type n -> Type n) -> (Exp (AnTEC a n) n -> Exp (AnTEC a n) n -> Exp a n) -> (n -> Maybe (Bind n -> [Bind n] -> Pat n)) -> Config a n

-- | Config for the type checker. We need to reconstruct the type of the
--   result of stateful functions when bundling them into the tuple that
--   holds the state token.
configCheckConfig :: Config a n -> Config n

-- | Function to decide which top-level bindings are stateful and need the
--   state token threaded through them. If the binding with the given name
--   is stateful then the function should return the new type for the
--   binding that accepts and returns the state token.
configThreadMe :: Config a n -> n -> Type n -> Maybe (Type n)

-- | Type of the state token to use.
configTokenType :: Config a n -> Type n

-- | Type that represents a missing value. If a stateful function returns a
--   void then our thread transform rewrites it to return the state token,
--   instead of a tuple that contains the token as well as a void value.
configVoidType :: Config a n -> Type n

-- | Wrap a type with the world token. eg change Int to (World#, Int)
configWrapResultType :: Config a n -> Type n -> Type n

-- | Wrap a result expression with the state token. The function is given
--   the types of the world token and result, then the expressions for the
--   same.
configWrapResultExp :: Config a n -> Exp (AnTEC a n) n -> Exp (AnTEC a n) n -> Exp a n

-- | Make a pattern which binds the world argument from a threaded primop.
configThreadPat :: Config a n -> n -> Maybe (Bind n -> [Bind n] -> Pat n)

-- | Inject the state token into the type of an effectful function. Eg,
--   change ([a b : Data]. a -&gt; b -&gt; Int) to ([a b : Data]. a -&gt; b
--   -&gt; World -&gt; (World, Int)
injectStateType :: Eq n => Config a n -> Type n -> Type n
instance Eq n => Eq (Context n)
instance Thread Module


-- | Add possible Const and Distinct witnesses that aren't otherwise in the
--   program.
module DDC.Core.Transform.Elaborate

-- | Elaborate witnesses in a module.
elaborateModule :: Eq n => Module a n -> Module a n

-- | Elaborate witnesses in an expression.
elaborateX :: Eq n => Exp a n -> Exp a n
instance Elaborate (Alt a)
instance Elaborate (Cast a)
instance Elaborate (Exp a)


-- | Bubble casts outwards. We float casts up and outwards so they are just
--   inside the inner-most enclosing let. This way the functions still have
--   the same effect and closure, but the casts don't get in the way of
--   subsequent transforms.
module DDC.Core.Transform.Bubble

-- | Bubble casts outwards in a <a>Module</a>.
bubbleModule :: Ord n => Module a n -> Module a n

-- | Bubble casts outwards in an <a>Exp</a>.
bubbleX :: Ord n => KindEnv n -> TypeEnv n -> Exp a n -> Exp a n
instance Ord n => MapBoundX (FvsCast a) n
instance Bubble Alt
instance Bubble Lets
instance Bubble Exp


-- | Manage representation of numeric values in a module.
--   
--   We use three seprate versions of each numeric type. Nat# Numeric index
--   type. B Boxed representation type. U Unboxed representation type.
--   
--   A numeric index type is the type of pure values like 23#, where
--   <a>pure value</a> means the mathematical value, free from any
--   considerations about how that might be represented at runtime in the
--   physical machine.
--   
--   The Boxed and Unboxed representation types commit to a specific
--   runtime representation, and have implications for runtime performance
--   and space usage of the compiled program.
--   
--   The boxing transform takes an input program using just pure values and
--   numeric index types, and refines it to a program that commits to
--   particular representations of those values. In particular, we commit
--   to a particular representation for function arguments and results,
--   which makes the program adhere to a function calling convention that
--   follow-on transformations to lower level languages (like Core Salt)
--   can deal with.
--   
--   This Boxing transform should do just enough to make the code
--   well-formed with respect to runtime representation. Demand-driven
--   optimisations like local unboxing should be done in follow-on
--   transformations.
--   
--   We make the following representation commitments, so that the default
--   representation is boxed.
--   
--   Literal values are wrapped into their boxed representation: 23# =&gt;
--   convert Nat] 23#
--   
--   Use unboxed versions of primitive operators: add] x y =&gt; convert
--   Nat Nat#] (add Nat [U] [B] x) (convert Nat Nat#] y))
--   
--   Case scrutinees are unwrapped when matching against literal patterns:
--   case x of { 0# -&gt; ... } =&gt; case convert [B] [Nat -&gt; ... }
--   
--   After performing this transformation the program is said to <a>use
--   representational types</a>, or be in <a>representational form</a>.
--   
--   <ul>
--   <li><i>Note: Boxing and Partial Application</i>
--   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Unlike in Haskell, we do not
--   allow explictly unboxed types in the source program because we don't
--   want to deal with partial applications of functions to unboxed values.
--   With our current setup we always have a version of each function that
--   accepts boxed values, so we never need to do generic application
--   involving unboxed values. Fast-path function specialisations that take
--   unboxed parameters should be created separately, and not replace the
--   existing slow-path, fully boxed version. Taking this approach is
--   possible in a strict language because the boxed and unboxed values
--   have the same semantic meaning. Boxing of values does not imply
--   <a>lifting</a> of the associated semantic domain.</li>
--   </ul>
module DDC.Core.Transform.Boxing

-- | Representation of the values of some type.
data Rep

-- | Values of this type cannot be directly represented in the target
--   language. We need to use a boxed or unboxed representation instead.
RepNone :: Rep

-- | Type is represented in boxed form, and thus can instantiate
--   polymorphic types.
RepBoxed :: Rep

-- | Type is represented in unboxed form, and thus cannot instantiate
--   polymorphic types.
RepUnboxed :: Rep
data Config a n
Config :: (Type n -> Bool) -> (Type n -> Bool) -> (Type n -> Bool) -> (Type n -> Maybe (Type n)) -> (Type n -> Maybe (Type n)) -> (Type n -> Maybe (Type n)) -> (Type n -> Maybe (Type n)) -> (n -> Maybe (Type n)) -> (n -> Maybe (Type n)) -> (n -> Maybe (Type n)) -> (n -> Bool) -> (a -> Exp a n -> Type n -> Maybe (Exp a n)) -> (a -> Exp a n -> Type n -> Maybe (Exp a n)) -> (a -> Exp a n -> Type n -> Maybe (Exp a n)) -> (a -> Exp a n -> Type n -> Maybe (Exp a n)) -> Config a n

-- | Values of this type needs boxing to make the program representational.
--   This will only be passed types of kind Data.
configIsValueIndexType :: Config a n -> Type n -> Bool

-- | Check if this is a boxed representation type.
configIsBoxedType :: Config a n -> Type n -> Bool

-- | Check if this is an unboxed representation type.
configIsUnboxedType :: Config a n -> Type n -> Bool

-- | Get the boxed version of some data type, if any. This will only be
--   passed types where typeNeedsBoxing returns True.
configBoxedOfIndexType :: Config a n -> Type n -> Maybe (Type n)

-- | Get the unboxed version of some data type, if any. This will only be
--   passed types where typeNeedsBoxing returns True.
configUnboxedOfIndexType :: Config a n -> Type n -> Maybe (Type n)

-- | Take the index type from a boxed type, if it is one.
configIndexTypeOfBoxed :: Config a n -> Type n -> Maybe (Type n)

-- | Take the index type from an unboxed type, if it is one.
configIndexTypeOfUnboxed :: Config a n -> Type n -> Maybe (Type n)

-- | Take the type of a literal name, if there is one.
configValueTypeOfLitName :: Config a n -> n -> Maybe (Type n)

-- | Take the type of a primitive operator name, if it is one. The primops
--   can be polytypic, but must have prenex rank-1 types.
configValueTypeOfPrimOpName :: Config a n -> n -> Maybe (Type n)

-- | Take the type of a foreign function name, if it is one. The function
--   can be polymorphic, but must have a prenex rank-1 type.
configValueTypeOfForeignName :: Config a n -> n -> Maybe (Type n)

-- | Check if the primop with this name works on unboxed values directly.
--   Operators where this function returns False are assumed to take boxed
--   values for every argument.
configNameIsUnboxedOp :: Config a n -> n -> Bool

-- | Wrap a value of the given index type. This will only be passed types
--   where typeNeedsBoxing returns True.
configBoxedOfValue :: Config a n -> a -> Exp a n -> Type n -> Maybe (Exp a n)

-- | Unwrap a boxed value of the given index type. This will only be passed
--   types where typeNeedsBoxing returns True.
configValueOfBoxed :: Config a n -> a -> Exp a n -> Type n -> Maybe (Exp a n)

-- | Box an unboxed value of the given index type. This will only be passed
--   types where typeNeedsBoxing returns True.
configBoxedOfUnboxed :: Config a n -> a -> Exp a n -> Type n -> Maybe (Exp a n)

-- | Unbox a boxed value of the given index type. This will only be passed
--   types where typeNeedsBoxing returns True.
configUnboxedOfBoxed :: Config a n -> a -> Exp a n -> Type n -> Maybe (Exp a n)
class Boxing (c :: * -> * -> *)
boxing :: (Boxing c, Show n, Show a, Ord n) => Config a n -> c a n -> c a n
instance Eq Rep
instance Ord Rep
instance Show Rep
instance Boxing Alt
instance Boxing Lets
instance Boxing Exp
instance Boxing Module


-- | General purpose tree walking boilerplate.
module DDC.Core.Transform.TransformUpX
class TransformUpMX m (c :: * -> * -> *)
transformUpMX :: (TransformUpMX m c, Ord n) => (KindEnv n -> TypeEnv n -> Exp a n -> m (Exp a n)) -> KindEnv n -> TypeEnv n -> c a n -> m (c a n)

-- | Bottom up rewrite of all core expressions in a thing.
transformUpX :: (Ord n, TransformUpMX Identity c) => (KindEnv n -> TypeEnv n -> Exp a n -> Exp a n) -> KindEnv n -> TypeEnv n -> c a n -> c a n

-- | Like transformUpX, but without using environments.
transformUpX' :: (Ord n, TransformUpMX Identity c) => (Exp a n -> Exp a n) -> c a n -> c a n

-- | Like <a>transformUpMX</a>, but the worker takes the Simple version of
--   the AST.
--   
--   <ul>
--   <li>To avoid repeated conversions between the different versions of
--   the AST, the worker should return <a>Nothing</a> if the provided
--   expression is unchanged.</li>
--   </ul>
transformSimpleUpMX :: (Ord n, TransformUpMX m c, Monad m) => (KindEnv n -> TypeEnv n -> Exp a n -> m (Maybe (Exp a n))) -> KindEnv n -> TypeEnv n -> c a n -> m (c a n)

-- | Like <a>transformUpX</a>, but the worker takes the Simple version of
--   the AST.
--   
--   <ul>
--   <li>To avoid repeated conversions between the different versions of
--   the AST, the worker should return <a>Nothing</a> if the provided
--   expression is unchanged.</li>
--   </ul>
transformSimpleUpX :: (Ord n, TransformUpMX Identity c) => (KindEnv n -> TypeEnv n -> Exp a n -> Maybe (Exp a n)) -> KindEnv n -> TypeEnv n -> c a n -> c a n

-- | Like <a>transformUpX'</a>, but the worker takes the Simple version of
--   the AST.
--   
--   <ul>
--   <li>To avoid repeated conversions between the different versions of
--   the AST, the worker should return <a>Nothing</a> if the provided
--   expression is unchanged.</li>
--   </ul>
transformSimpleUpX' :: (Ord n, TransformUpMX Identity c) => (Exp a n -> Maybe (Exp a n)) -> c a n -> c a n
instance Monad m => TransformUpMX m Alt
instance Monad m => TransformUpMX m Lets
instance Monad m => TransformUpMX m Exp
instance Monad m => TransformUpMX m Module

module DDC.Type.Transform.AnonymizeT

-- | Rewrite all binders in a thing to be of anonymous form.
anonymizeT :: (Ord n, AnonymizeT c) => c n -> c n
class AnonymizeT (c :: * -> *)
anonymizeWithT :: (AnonymizeT c, Ord n) => [Bind n] -> c n -> c n

-- | Push a binding occurrence of a level-1 variable on the stack,
--   returning the anonyized binding occurrence and the new stack.
pushAnonymizeBindT :: Ord n => [Bind n] -> Bind n -> ([Bind n], Bind n)
instance AnonymizeT Bound
instance AnonymizeT TypeSum
instance AnonymizeT Type


-- | Rewrite all binders to anonymous deBruijn form.
module DDC.Core.Transform.AnonymizeX

-- | Rewrite all binders in a thing to anonymous form.
anonymizeX :: (Ord n, AnonymizeX c) => c n -> c n
class AnonymizeX (c :: * -> *)
anonymizeWithX :: (AnonymizeX c, Ord n) => Set n -> [Bind n] -> [Bind n] -> c n -> c n

-- | Push a binding occurrence of a level-0 on the stack, returning the
--   anonyized binding occurrence and the new stack.
pushAnonymizeBindX :: Ord n => Set n -> [Bind n] -> [Bind n] -> Bind n -> ([Bind n], Bind n)
instance AnonymizeX Bind
instance AnonymizeX (Witness a)
instance AnonymizeX (Alt a)
instance AnonymizeX (Cast a)
instance AnonymizeX (Exp a)
instance AnonymizeX (Module a)


-- | Flattening nested let and case expressions.
module DDC.Core.Transform.Flatten

-- | Flatten binding structure in a thing.
--   
--   Flattens nested let-expressions, and single alternative let-case
--   expressions.
flatten :: Ord n => TransformUpMX Identity c => c a n -> c a n


-- | Create substitution to make (subst template) == target
module DDC.Core.Transform.Rewrite.Match

-- | Value and type substition.
type SubstInfo a n = (Map n (Exp a n), Map n (Type n))

-- | An empty substition info.
emptySubstInfo :: SubstInfo a n

-- | Create substitution to make (subst template) == target Does not handle
--   higher-order templates (ie ones with binders)
--   
--   <pre>
--    match emptySubstInfo (Set.fromList [r1, r2, s])
--      (stream [r1]  (unstream [r2]  s))
--      (stream [R0] (someStream 23))
--   
--   =&gt; { r1 |-&gt; R0#, r2 |-&gt; R1, s |-&gt; someStream 23 }
--   </pre>
match :: (Show a, Show n, Ord n) => SubstInfo a n -> Set n -> Exp a n -> Exp a n -> Maybe (SubstInfo a n)

module DDC.Core.Transform.Rewrite.Env

-- | A summary of the environment that we perform a rewrite in.
--   
--   As we decend into the program looking for expressions to rewrite, we
--   keep track of what information as been defined in the environment in a
--   <a>RewriteEnv</a>.
--   
--   When we go under an anonymous binder then we push a new outermost list
--   instead of lifting every element on the environment eagerly.
data RewriteEnv a n

-- | An empty environment.
empty :: Ord n => RewriteEnv a n

-- | Extend an environment with some lambda-bound binder (XLam) Might be a
--   witness. Don't count if it's a region.
extend :: Ord n => Bind n -> RewriteEnv a n -> RewriteEnv a n

-- | Extend an environment with the variables bount by these let-bindings.
--   
--   If it's a letregion, remember the region's name and any witnesses.
extendLets :: Ord n => Lets a n -> RewriteEnv a n -> RewriteEnv a n

-- | Check whether an environment contains the given region, bound by a
--   letregion.
containsRegion :: Ord n => Bound n -> RewriteEnv a n -> Bool

-- | Check if the witness map in the given environment.
containsWitness :: Ord n => Type n -> RewriteEnv a n -> Bool

-- | Get a list of all the witness types in an environment, normalising
--   their indices.
getWitnesses :: Ord n => RewriteEnv a n -> [Type n]

-- | Insert a rewrite definition into the environment.
insertDef :: Bind n -> Maybe (Exp a n) -> RewriteEnv a n -> RewriteEnv a n

-- | Lookup the definition of some let-bound variable from the environment.
getDef :: (Ord n, MapBoundX (Exp a) n) => Bound n -> RewriteEnv a n -> Maybe (Exp a n)
hasDef :: (Ord n, MapBoundX (Exp a) n) => Bound n -> RewriteEnv a n -> Bool

-- | Raise all elements in witness map if binder is anonymous. Only call
--   with type binders: ie XLAM, not XLam
lift :: Bind n -> RewriteEnv a n -> RewriteEnv a n

-- | Raise all elements in definitions map if binder is anonymous Use for
--   *value* binders, not type binders.
liftValue :: Bind n -> RewriteEnv a n -> RewriteEnv a n
instance (Show a, Show n) => Show (RewriteEnv a n)
instance (Eq a, Eq n) => Eq (RewriteEnv a n)


-- | Check whether two effects are non-interfering
module DDC.Core.Transform.Rewrite.Disjoint

-- | Check whether a disjointness property is true in the given rewrite
--   environment.
--   
--   Disjointness means that two effects do not interfere.
--   
--   Context is important because if two regions are known to be distinct,
--   reading from one and writing to another is valid. If they have
--   different names they may not be distinct.
--   
--   All read effects are disjoint with other reads.
--   
--   <pre>
--   Disjoint (Read r1) (Read r2)
--   Disjoint (Read r1) (DeepRead a)
--   </pre>
--   
--   Allocation effects are disjoint with everything.
--   
--   <pre>
--   Disjoint (Alloc r) (_)
--   </pre>
--   
--   Atomic reads and write effects are disjoint if they are to distinct
--   regions.
--   
--   <pre>
--           Distinct r1 r2
--   -----------------------------
--   Disjoint (Read r1) (Write r2)
--   </pre>
--   
--   <tt>DeepWrite</tt> effects are only disjoint with allocation effects,
--   because we don't know what regions it will write to.
--   
--   An effect sum is disjoint from some other effect if all its components
--   are.
--   
--   <pre>
--   Disjoint f1 g /\ Disjoint f2 g
--   -----------------------------
--        Disjoint (f1 + f2) g
--   </pre>
--   
--   Disjointness is commutative.
--   
--   <pre>
--   Disjoint f g
--   ------------
--   Disjoint g f
--   </pre>
--   
--   Example:
--   
--   <pre>
--   checkDisjoint
--     (Disjoint (Read r1 + Read r2) (Write r3))
--     [Distinct r1 r3, Distinct r2 r3]
--   = True
--   </pre>
checkDisjoint :: (Ord n, Show n) => Type n -> RewriteEnv a n -> Bool

-- | Check whether a distintness property is true in the given rewrite
--   environment.
--   
--   Distinctness means that two regions do not alias.
checkDistinct :: Ord n => Type n -> RewriteEnv a n -> Bool

module DDC.Core.Simplifier.Result

-- | Package up the result of applying a single transform.
data TransformResult r
TransformResult :: r -> Bool -> Bool -> TransformInfo -> TransformResult r

-- | Transform result proper (eg the new module)
result :: TransformResult r -> r

-- | Whether this transform made any progess.
--   
--   If <a>False</a> then the result program must be the same as the input
--   program, and a simplifer fixpoint won't apply this transform again to
--   the result program.
resultProgress :: TransformResult r -> Bool

-- | Whether it might help to run the same transform again.
--   
--   If <a>False</a> then a simplifier fixpoint won't apply this transform
--   again to the result program.
resultAgain :: TransformResult r -> Bool

-- | Transform specific log. This might contain a count of what rules
--   fired, or information about what parts of the program couldn't be
--   processed.
resultInfo :: TransformResult r -> TransformInfo

-- | Existential package for a typeable thing, used in
--   <a>TransformResult</a>.
data TransformInfo
TransformInfo :: i -> TransformInfo

-- | Place-holder type to use when there is no real <a>TransformResult</a>.
data NoInformation

-- | Create a default result with no transform again.
--   
--   We'll say we made progress, but set <a>resultAgain</a> to False so to
--   stop any simplifier fixpoints.
resultDone :: String -> r -> TransformResult r
instance Typeable NoInformation
instance Pretty (TransformResult r)
instance Pretty NoInformation

module DDC.Core.Transform.Eta
data Config
Config :: Bool -> Config
configExpand :: Config -> Bool

-- | Empty eta configuration with all flags set to False.
configZero :: Config
data Info
Info :: Int -> Int -> Info

-- | Number of level-1 lambdas added.
infoExpandedXLAMs :: Info -> Int

-- | Number of level-0 lambdas added.
infoExpandedXLams :: Info -> Int

-- | Eta-transform expressions in a module.
etaModule :: (Ord n, Show n, Pretty n, Show a) => Profile n -> Config -> Module a n -> TransformResult (Module a n)

-- | Eta-transform an expression.
etaX :: (Ord n, Show n, Show a, Pretty n) => Profile n -> Config -> KindEnv n -> TypeEnv n -> Exp a n -> TransformResult (Exp a n)
instance Typeable Info
instance Show Config
instance Eta Alt
instance Eta Lets
instance Eta Exp
instance Eta Module
instance Monoid Info
instance Pretty Info


-- | Inlining definitions into their use sites.
module DDC.Core.Transform.Inline
inline :: (Inline c, Ord n) => (n -> Maybe (Exp a n)) -> Set n -> c a n -> c a n

-- | Inlining specification says what bindings we should inline from a
--   particular module.
data InlineSpec n

-- | Inline all bindings from a module, but exclude some particulars.
InlineSpecAll :: ModuleName -> Set n -> InlineSpec n
inlineSpecModuleName :: InlineSpec n -> ModuleName
inlineSpecExclude :: InlineSpec n -> Set n

-- | Inline no bindings from a module, but include some particulars.
InlineSpecNone :: ModuleName -> Set n -> InlineSpec n
inlineSpecModuleName :: InlineSpec n -> ModuleName
inlineSpecInclude :: InlineSpec n -> Set n

-- | Lookup an inliner template from a list of modules.
lookupTemplateFromModules :: (Eq n, Ord n, Show n) => Map ModuleName (InlineSpec n) -> [Module a n] -> n -> Maybe (Exp a n)
instance Inline Alt
instance Inline Lets
instance Inline Exp
instance Inline Module


-- | Beta-reduce applications of a explicit lambda abstractions to
--   variables and values.
module DDC.Core.Transform.Beta
data Config
Config :: Bool -> Config

-- | If we find a lambda abstraction applied to a redex then let-bind the
--   redex and substitute the new variable instead.
configBindRedexes :: Config -> Bool

-- | Empty beta configuration with all flags set to False.
configZero :: Config

-- | A summary of what the beta reduction transform did.
data Info
Info :: Int -> Int -> Int -> Int -> Int -> Info

-- | Number of type applications reduced.
infoTypes :: Info -> Int

-- | Number of witness applications reduced.
infoWits :: Info -> Int

-- | Number of value applications reduced.
infoValues :: Info -> Int

-- | Number of redexes let-bound.
infoValuesLetted :: Info -> Int

-- | Number of applications that we couldn't reduce.
infoValuesSkipped :: Info -> Int

-- | Beta-reduce applications of a explicit lambda abstractions to
--   variables and values.
--   
--   If the flag is set then if we find a lambda abstraction that is
--   applied to a redex then let-bind the redex and substitute the new
--   variable instead.
betaReduce :: (Ord n, TransformUpMX (Writer Info) c) => Profile n -> Config -> c a n -> TransformResult (c a n)
instance Typeable Info
instance Show Config
instance Monoid Info
instance Pretty Info


-- | Rewriting of anonymous binders to named binders.
module DDC.Core.Transform.Namify
class Namify (c :: * -> *)
namify :: (Namify c, Ord n) => Namifier s n -> Namifier s n -> c n -> State s (c n)

-- | Holds a function to rename binders, and the state of the renamer as we
--   decend into the tree.
data Namifier s n
Namifier :: (Env n -> Bind n -> State s n) -> Env n -> [Bind n] -> Namifier s n

-- | Create a new name for this bind that is not in the given environment.
namifierNew :: Namifier s n -> Env n -> Bind n -> State s n

-- | Holds the current environment during namification.
namifierEnv :: Namifier s n -> Env n

-- | Stack of debruijn binders that have been rewritten during
--   namification.
namifierStack :: Namifier s n -> [Bind n]

-- | Construct a new namifier.
makeNamifier :: (Env n -> Bind n -> State s n) -> Env n -> Namifier s n

-- | Namify a thing, not reusing names already in the program.
namifyUnique :: (Ord n, Namify c, BindStruct c) => (KindEnv n -> Namifier s n) -> (TypeEnv n -> Namifier s n) -> c n -> State s (c n)
instance Namify (Cast a)
instance Namify (Alt a)
instance Namify (Exp a)
instance Namify (Witness a)
instance Namify (Module a)
instance Namify Type


-- | Annotate let bindings with how their bound variables are used.
module DDC.Core.Analysis.Usage

-- | Tracks how a bound variable is used.
data Used

-- | Bound variable is used as the function in an application.
UsedFunction :: Used

-- | Bound variable is destructed by a case-expression.
UsedDestruct :: Used

-- | Bound variable is used inside a <tt>weakclo</tt> cast.
UsedInCast :: Used

-- | Bound variable has an occurrence that is not one of the above.
UsedOcc :: Used

-- | Usage is inside a Lambda abstraction (either type or value)
UsedInLambda :: Used -> Used

-- | Usage is inside a case alternative.
UsedInAlt :: Used -> Used

-- | Map of bound name to how the variable is used.
data UsedMap n
UsedMap :: (Map n [Used]) -> UsedMap n

-- | Annotate all binding occurrences of variables in an expression with
--   how they are used.
usageModule :: Ord n => Module a n -> Module (UsedMap n, a) n

-- | Annotate all binding occurrences of variables in an expression with
--   how they are used.
usageX :: Ord n => Exp a n -> Exp (UsedMap n, a) n
instance Eq Used
instance Show Used
instance Show n => Show (UsedMap n)


-- | Constructing and checking whether rewrite rules are valid
module DDC.Core.Transform.Rewrite.Rule

-- | Binding level for the binders in a rewrite rule.
data BindMode

-- | Level-1 binder (specs)
BMSpec :: BindMode

-- | number of usages
BMValue :: Int -> BindMode

-- | Check if a <a>BindMode</a> is a <a>BMSpec</a>.
isBMSpec :: BindMode -> Bool

-- | Check if a <a>BindMode</a> is a <a>BMValue</a>.
isBMValue :: BindMode -> Bool

-- | A rewrite rule. For example:
--   
--   <pre>
--   RULE [r1 r2 r3 : %] (x : Int r1)
--        . addInt  [:r1 r2 r3:] x (0 [r2] ()
--        = copyInt [:r1 r3:]    x
--   </pre>
data RewriteRule a n
RewriteRule :: [(BindMode, Bind n)] -> [Type n] -> Exp a n -> Maybe (Exp a n) -> Exp a n -> Maybe (Effect n) -> [Exp a n] -> [Bound n] -> RewriteRule a n

-- | Variables bound by the rule.
ruleBinds :: RewriteRule a n -> [(BindMode, Bind n)]

-- | Extra constraints on the rule. These must all be satisfied for the
--   rule to fire.
ruleConstraints :: RewriteRule a n -> [Type n]

-- | Left-hand side of the rule. We match on this part.
ruleLeft :: RewriteRule a n -> Exp a n

-- | Extra part of left-hand side, but allow this bit to be out-of-context.
ruleLeftHole :: RewriteRule a n -> Maybe (Exp a n)

-- | Right-hand side of the rule. We replace the matched expression with
--   this part.
ruleRight :: RewriteRule a n -> Exp a n

-- | Effects that are caused by the left but not the right. When applying
--   the rule we add an effect weakning to ensure the rewritten expression
--   has the same effects.
ruleWeakEff :: RewriteRule a n -> Maybe (Effect n)

-- | Closure that the left has that is not present in the right. When
--   applying the rule we add a closure weakening to ensure the rewritten
--   expression has the same closure.
ruleWeakClo :: RewriteRule a n -> [Exp a n]

-- | References to environment. Used to check whether the rule is shadowed.
ruleFreeVars :: RewriteRule a n -> [Bound n]
type NamedRewriteRule a n = (String, RewriteRule a n)

-- | Construct a rewrite rule, but do not check if it's valid.
--   
--   You then need to apply <a>checkRewriteRule</a> to check it.
mkRewriteRule :: Ord n => [(BindMode, Bind n)] -> [Type n] -> Exp a n -> Maybe (Exp a n) -> Exp a n -> RewriteRule a n

-- | Take a rule, make sure it's valid and fill in type, closure and effect
--   information.
--   
--   The left-hand side of rule can't have any binders (lambdas, lets etc).
--   
--   All binders must appear in the left-hand side, otherwise they would
--   match with no value.
--   
--   Both sides must have the same types, but the right can have fewer
--   effects and smaller closure.
--   
--   We don't handle anonymous binders on either the left or right.
checkRewriteRule :: (Ord n, Show n, Pretty n) => Config n -> Env n -> Env n -> RewriteRule a n -> Either (Error a n) (RewriteRule (AnTEC a n) n)

-- | What can go wrong when checking a rewrite rule.
data Error a n

-- | Error typechecking one of the expressions
ErrorTypeCheck :: Side -> Exp a n -> Error a n -> Error a n

-- | What side of the rule the error was on.
errorSide :: Error a n -> Side
errorExp :: Error a n -> Exp a n
errorCheckError :: Error a n -> Error a n

-- | Error typechecking one of the expressions
ErrorBadConstraint :: Type n -> Error a n
errorConstraint :: Error a n -> Type n

-- | Types don't match...
ErrorTypeConflict :: (Type n, Effect n, Closure n) -> (Type n, Effect n, Closure n) -> Error a n
errorTypeLhs :: Error a n -> (Type n, Effect n, Closure n)
errorTypeRhs :: Error a n -> (Type n, Effect n, Closure n)

-- | No binders allowed in left-hand side (right is fine, eg <tt>let</tt>s)
ErrorNotFirstOrder :: Exp a n -> Error a n
errorExp :: Error a n -> Exp a n

-- | All variables must be mentioned in left-hand side, otherwise they
--   won't get bound.
ErrorVarUnmentioned :: Error a n

-- | I don't want to deal with anonymous variables.
ErrorAnonymousBinder :: Bind n -> Error a n
errorBinder :: Error a n -> Bind n

-- | What side of a rewrite rule we're talking about.
data Side
Lhs :: Side
Rhs :: Side
instance Eq BindMode
instance Show BindMode
instance (Eq a, Eq n) => Eq (RewriteRule a n)
instance (Show a, Show n) => Show (RewriteRule a n)
instance Reannotate RewriteRule
instance (Pretty n, Eq n) => Pretty (RewriteRule a n)


-- | Core language parser.
module DDC.Core.Transform.Rewrite.Parser

-- | Parse a rewrite rule.
pRule :: Ord n => Context -> Parser n (RewriteRule SourcePos n)

-- | Parse many rewrite rules.
pRuleMany :: Ord n => Context -> Parser n [(n, RewriteRule SourcePos n)]


-- | Slurp out arities of function bindings. and infer arities for
--   primitives based on their types.
--   
--   For function bindings the arity is the number of outer-most lambdas in
--   the definition.
--   
--   For primitives, the arity is the number of function constructors in
--   its type.
module DDC.Core.Analysis.Arity

-- | Arities of named and anonymous bindings.
type Arities n = (Map n Int, [Int])

-- | Empty arities context.
emptyArities :: Ord n => Arities n

-- | Extend map with some binders and their arities.
extendsArities :: Ord n => Arities n -> [(Bind n, Int)] -> Arities n

-- | Look up a binder's arity from the arity map or determine it from its
--   type in the case of primops.
getArity :: Ord n => Arities n -> Bound n -> Maybe Int

-- | Slurp out arities of imports and top-level bindings from a module.
aritiesOfModule :: Ord n => Module a n -> Arities n

-- | Get the arities of a <a>Lets</a>
aritiesOfLets :: Ord n => Lets a n -> Maybe [(Bind n, Int)]

-- | Retrieve binders from case pattern, so we can extend the arity
--   context. We don't know anything about their values, so record as 0.
aritiesOfPat :: Ord n => Pat n -> [(Bind n, Int)]

-- | Determine the arity of an expression by looking at its type. Count all
--   the function arrows, and foralls.
arityFromType :: Ord n => Type n -> Maybe Int

-- | Get the arity of an expression.
arityOfExp :: Ord n => Exp a n -> Maybe Int


-- | Snip out nested applications.
module DDC.Core.Transform.Snip

-- | Class of things that can have things snipped out of them.
class Snip (c :: * -> *)
snip :: (Snip c, Ord n) => Config -> c n -> c n

-- | Snipper configuration.
data Config
Config :: Bool -> Bool -> Bool -> Config

-- | Introduce new bindings for over-applied functions.
configSnipOverApplied :: Config -> Bool

-- | Ensure the body of a let-expression is a variable.
configSnipLetBody :: Config -> Bool

-- | Treat lambda abstractions as atomic, and don't snip them.
configPreserveLambdas :: Config -> Bool

-- | Snipper configuration with all flags set to False.
configZero :: Config
instance Snip (Exp a)
instance Snip (Module a)


-- | Common simplifier recipes that combine multiple transforms.
module DDC.Core.Simplifier.Recipe

-- | The identity simplifier returns the code unharmed.
idsimp :: Simplifier s a n

-- | Rewrite named binders to anonymous debruijn binders.
anonymize :: Simplifier s a n

-- | Introduce let-bindings for nested applications.
snip :: Simplifier s a n

-- | Introduce let-bindings for nested applications.
snipOver :: Simplifier s a n

-- | Flatten nested let and case expressions.
flatten :: Simplifier s a n

-- | Perform beta reduction
beta :: Simplifier s a n

-- | Perform beta reduction, introducing let-expressions for compound
--   arguments.
betaLets :: Simplifier s a n

-- | Remove unused, pure let bindings.
prune :: Simplifier s a n

-- | Float single-use bindings forward into their use sites.
forward :: Simplifier s a n

-- | Float casts outwards.
bubble :: Simplifier s a n

-- | Elaborate possible Const and Distinct witnesses that aren't otherwise
--   in the program.
elaborate :: Simplifier s a n

-- | Conversion to administrative normal-form.
anormalize :: (KindEnv n -> Namifier s n) -> (TypeEnv n -> Namifier s n) -> Simplifier s a n

-- | Intersperse rewrites and beta reduction
rewriteSimp :: Int -> NamedRewriteRules a n -> Simplifier s a n


-- | Apply rewrite rules.
module DDC.Core.Transform.Rewrite

-- | A rewrite rule. For example:
--   
--   <pre>
--   RULE [r1 r2 r3 : %] (x : Int r1)
--        . addInt  [:r1 r2 r3:] x (0 [r2] ()
--        = copyInt [:r1 r3:]    x
--   </pre>
data RewriteRule a n
RewriteRule :: [(BindMode, Bind n)] -> [Type n] -> Exp a n -> Maybe (Exp a n) -> Exp a n -> Maybe (Effect n) -> [Exp a n] -> [Bound n] -> RewriteRule a n

-- | Variables bound by the rule.
ruleBinds :: RewriteRule a n -> [(BindMode, Bind n)]

-- | Extra constraints on the rule. These must all be satisfied for the
--   rule to fire.
ruleConstraints :: RewriteRule a n -> [Type n]

-- | Left-hand side of the rule. We match on this part.
ruleLeft :: RewriteRule a n -> Exp a n

-- | Extra part of left-hand side, but allow this bit to be out-of-context.
ruleLeftHole :: RewriteRule a n -> Maybe (Exp a n)

-- | Right-hand side of the rule. We replace the matched expression with
--   this part.
ruleRight :: RewriteRule a n -> Exp a n

-- | Effects that are caused by the left but not the right. When applying
--   the rule we add an effect weakning to ensure the rewritten expression
--   has the same effects.
ruleWeakEff :: RewriteRule a n -> Maybe (Effect n)

-- | Closure that the left has that is not present in the right. When
--   applying the rule we add a closure weakening to ensure the rewritten
--   expression has the same closure.
ruleWeakClo :: RewriteRule a n -> [Exp a n]

-- | References to environment. Used to check whether the rule is shadowed.
ruleFreeVars :: RewriteRule a n -> [Bound n]

-- | Apply rewrite rules to a module.
rewriteModule :: (Show a, Show n, Ord n, Pretty n) => [NamedRewriteRule a n] -> Module a n -> Module a n

-- | Perform rewrites top-down, repeatedly.
rewriteX :: (Show a, Show n, Ord n, Pretty n) => [NamedRewriteRule a n] -> Exp a n -> TransformResult (Exp a n)
instance Typeable RewriteLog
instance Typeable RewriteInfo
instance Pretty RewriteLog
instance Pretty RewriteInfo


-- | Erase contained let-bindings that have no uses.
--   
--   Contained bindings are ones that do not perform effects that are
--   visible to anything in the calling context. This includes allocation
--   and read effects, but not writes or any globally visible effects.
module DDC.Core.Transform.Prune

-- | A summary of what the prune transform did.
data PruneInfo
PruneInfo :: Int -> PruneInfo

-- | How many let-bindings we erased.
infoBindingsErased :: PruneInfo -> Int

-- | Erase pure let-bindings in a module that have no uses.
pruneModule :: (Show a, Show n, Ord n, Pretty n) => Profile n -> Module a n -> Module a n

-- | Erase pure let-bindings in an expression that have no uses.
pruneX :: (Show a, Show n, Ord n, Pretty n) => Profile n -> KindEnv n -> TypeEnv n -> Exp a n -> TransformResult (Exp a n)
instance Typeable PruneInfo
instance Monoid PruneInfo
instance Pretty PruneInfo


-- | Float let-bindings with a single use forward into their use-sites.
module DDC.Core.Transform.Forward

-- | Summary of number of bindings floated.
data ForwardInfo
ForwardInfo :: !Int -> !Int -> !Int -> ForwardInfo

-- | Number of bindings inspected.
infoInspected :: ForwardInfo -> !Int

-- | Number of trivial <tt>v1 = v2</tt> bindings inlined.
infoSubsts :: ForwardInfo -> !Int

-- | Number of bindings floated forwards.
infoBindings :: ForwardInfo -> !Int

-- | Fine control over what should be floated.
data FloatControl

-- | Allow binding to be floated, but don't require it.
FloatAllow :: FloatControl

-- | Prevent a binding being floated, at all times.
FloatDeny :: FloatControl

-- | Force a binding to be floated, at all times.
FloatForce :: FloatControl
data Config a n
Config :: (Lets a n -> FloatControl) -> Bool -> Config a n
configFloatControl :: Config a n -> Lets a n -> FloatControl
configFloatLetBody :: Config a n -> Bool

-- | Float let-bindings in a module with a single use forward into their
--   use sites.
forwardModule :: Ord n => Profile n -> Config a n -> Module a n -> TransformResult (Module a n)

-- | Float let-bindings in an expression with a single use forward into
--   their use-sites.
forwardX :: Ord n => Profile n -> Config a n -> Exp a n -> TransformResult (Exp a n)
instance Typeable ForwardInfo
instance Eq FloatControl
instance Show FloatControl
instance Forward Alt
instance Forward Lets
instance Forward Cast
instance Forward Exp
instance Forward Module
instance Monoid ForwardInfo
instance Pretty ForwardInfo

module DDC.Core.Simplifier.Parser

-- | Auxilliary information that may be used by a simplifier.
data SimplifierDetails s a n
SimplifierDetails :: (Env n -> Namifier s n) -> (Env n -> Namifier s n) -> NamedRewriteRules a n -> [Module a n] -> SimplifierDetails s a n

-- | Create a namifier to make fresh type (level-1) names that don't
--   conflict with any already in this environment.
simplifierMkNamifierT :: SimplifierDetails s a n -> Env n -> Namifier s n

-- | Create a namifier to make fresh value or witness (level-0) names that
--   don't conflict with any already in this environment.
simplifierMkNamifierX :: SimplifierDetails s a n -> Env n -> Namifier s n

-- | Rewrite rules along with their names.
simplifierRules :: SimplifierDetails s a n -> NamedRewriteRules a n

-- | Modules available for inlining.
simplifierTemplates :: SimplifierDetails s a n -> [Module a n]

-- | Parse a simplifier from a string.
parseSimplifier :: (Ord n, Show n) => (String -> Maybe n) -> SimplifierDetails s a n -> String -> Either ParseError (Simplifier s a n)

module DDC.Core.Simplifier

-- | Specification of how to simplify a core program.
data Simplifier s a n

-- | Apply a single transform.
Trans :: (Transform s a n) -> Simplifier s a n

-- | Apply two simplifiers in sequence.
Seq :: (Simplifier s a n) -> (Simplifier s a n) -> Simplifier s a n

-- | Keep applying a transform until it reports that further applications
--   won't be helpful, bailing out after a maximum number of applications.
Fix :: Int -> (Simplifier s a n) -> Simplifier s a n

-- | Individual transforms to apply during simplification.
data Transform s a n

-- | The Identity transform returns the original program unharmed.
Id :: Transform s a n

-- | Rewrite named binders to anonymous deBruijn binders.
Anonymize :: Transform s a n

-- | Introduce let-bindings for nested applications.
Snip :: Config -> Transform s a n

-- | Flatten nested let and case expressions.
Flatten :: Transform s a n

-- | Perform beta reduction when the argument is not a redex.
Beta :: Config -> Transform s a n

-- | Perform eta expansion and reduction.
Eta :: Config -> Transform s a n

-- | Remove unused, pure let bindings.
Prune :: Transform s a n

-- | Float single-use bindings forward into their use sites.
Forward :: Transform s a n

-- | Float casts outwards.
Bubble :: Transform s a n

-- | Elaborate possible Const and Distinct witnesses that aren't otherwise
--   in the program.
Elaborate :: Transform s a n

-- | Inline definitions into their use sites.
Inline :: InlinerTemplates a n -> Transform s a n

-- | Get the unfolding for a named variable.
transInlineDef :: Transform s a n -> InlinerTemplates a n

-- | Apply general rule-based rewrites.
Rewrite :: NamedRewriteRules a n -> Transform s a n

-- | List of rewrite rules along with their names.
transRules :: Transform s a n -> NamedRewriteRules a n

-- | Rewrite anonymous binders to fresh named binders.
Namify :: (Env n -> Namifier s n) -> (Env n -> Namifier s n) -> Transform s a n

-- | Create a namifier to make fresh type (level-1) names that don't
--   conflict with any already in this environment.
transMkNamifierT :: Transform s a n -> Env n -> Namifier s n

-- | Create a namifier to make fresh value or witness (level-0) names that
--   don't conflict with any already in this environment.
transMkNamifierX :: Transform s a n -> Env n -> Namifier s n

-- | Function to get the inliner template (unfolding) for the given name.
type InlinerTemplates a n = n -> Maybe (Exp a n)

-- | Rewrite rules along with their names.
type NamedRewriteRules a n = [(String, RewriteRule a n)]

-- | Package up the result of applying a single transform.
data TransformResult r
TransformResult :: r -> Bool -> Bool -> TransformInfo -> TransformResult r

-- | Transform result proper (eg the new module)
result :: TransformResult r -> r

-- | Whether this transform made any progess.
--   
--   If <a>False</a> then the result program must be the same as the input
--   program, and a simplifer fixpoint won't apply this transform again to
--   the result program.
resultProgress :: TransformResult r -> Bool

-- | Whether it might help to run the same transform again.
--   
--   If <a>False</a> then a simplifier fixpoint won't apply this transform
--   again to the result program.
resultAgain :: TransformResult r -> Bool

-- | Transform specific log. This might contain a count of what rules
--   fired, or information about what parts of the program couldn't be
--   processed.
resultInfo :: TransformResult r -> TransformInfo

-- | Existential package for a typeable thing, used in
--   <a>TransformResult</a>.
data TransformInfo
TransformInfo :: i -> TransformInfo

-- | Create a default result with no transform again.
--   
--   We'll say we made progress, but set <a>resultAgain</a> to False so to
--   stop any simplifier fixpoints.
resultDone :: String -> r -> TransformResult r

-- | Apply a simplifier to a module.
--   
--   The state monad can be used by <a>Namifier</a> functions to generate
--   fresh names.
applySimplifier :: (Show a, Ord n, Show n, Pretty n) => Profile n -> KindEnv n -> TypeEnv n -> Simplifier s a n -> Module a n -> State s (TransformResult (Module a n))

-- | Apply a simplifier to an expression.
--   
--   The state monad can be used by <a>Namifier</a> functions to generate
--   fresh names.
applySimplifierX :: (Show a, Show n, Ord n, Pretty n) => Profile n -> KindEnv n -> TypeEnv n -> Simplifier s a n -> Exp a n -> State s (TransformResult (Exp a n))
