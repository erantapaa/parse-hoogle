-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Directory layout DSL
--   
--   Making, fitting, printing directory layouts
@package directory-layout
@version 0.7.4.1


-- | Convenience quasiquoter to ease the pain working with multiline
--   strings
module System.Directory.Layout.QQ

-- | A handy quasiquoter to work with the multiline file contents
--   
--   Strips the longest common leading spaces segment. All spacey
--   characters are treated equally. The first line is ignored if it's
--   spaces only.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStr [dedent|
--     hello
--       world
--       !
--   |]
--   :}
--   hello
--     world
--     !
--   </pre>
dedent :: QuasiQuoter

-- | <a>dedent</a> with variable substitution
--   
--   <pre>
--   &gt;&gt;&gt; let hello = "bye" :: String
--   
--   &gt;&gt;&gt; :{
--   putStr [dedentSubst|
--     #{hello}
--       world
--       !
--   |]
--   :}
--   bye
--     world
--     !
--   </pre>
dedentSubst :: QuasiQuoter


-- | directory-layout internals
module System.Directory.Layout.Internal

-- | Directory layout description
newtype Layout a
L :: Free F a -> Layout a
unL :: Layout a -> Free F a

-- | The underlying <a>Functor</a>
data F a
F :: String -> (Maybe Contents) -> Aux -> a -> F a
SL :: String -> FilePath -> Bool -> Aux -> a -> F a
D :: String -> a -> Aux -> a -> F a
E :: F a

-- | Regular file contents
data Contents
Binary :: ByteString -> Contents
Text :: Text -> Contents
CopyOf :: FilePath -> Contents

-- | Auxiliary data
data Aux
Aux :: (Maybe User) -> (Maybe Group) -> (Maybe FileMode) -> Aux

-- | File owner
data User
UserID :: UserID -> User
Username :: String -> User

-- | File group
data Group
GroupID :: GroupID -> Group
Groupname :: String -> Group

-- | Regular file with some contents or empty
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo"
--   </pre>
file :: String -> Layout ()

-- | Symbolic link
--   
--   <pre>
--   &gt;&gt;&gt; let layout = symlink "foo" "bar"
--   </pre>
symlink :: String -> FilePath -> Layout ()

-- | Directory
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let layout = dir "foo" $ do
--         file "bar"
--         file "baz"
--   :}
--   </pre>
dir :: String -> Layout a -> Layout ()

-- | Empty directory
--   
--   <pre>
--   &gt;&gt;&gt; let layout = emptydir "foo"
--   </pre>
emptydir :: String -> Layout ()

-- | A nested list of directories
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let layout = dirs ["foo", "bar"] $ do
--                  file "qux"
--                  file "quux"
--   :}
--   </pre>
dirs :: [String] -> Layout () -> Layout ()

-- | The default (empty) auxiliary data
defaux :: Aux

-- | An optic into file contents
contents :: Traversal' (Layout a) (Maybe Contents)

-- | Binary contents
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; contents ?~ binary (ByteString.pack [1..10])
--   </pre>
binary :: ByteString -> Contents

-- | Plain text contents
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; contents ?~ text (Data.Text.pack "hello")
--   </pre>
text :: Text -> Contents

-- | Contents are the copy of whose of the real file
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; contents ?~ copyOf "/home/user/.vimrc"
--   </pre>
copyOf :: FilePath -> Contents

-- | Anything
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; contents .~ anything
--   
--   &gt;&gt;&gt; let layout = file "foo" &amp; user .~ anything
--   </pre>
anything :: Maybe a

-- | An optic into symbolic link source
--   
--   <pre>
--   &gt;&gt;&gt; symlink "foo" "bar" ^? source
--   Just "bar"
--   </pre>
source :: Traversal' (Layout a) String

-- | An optic into symbolic link source expected existence
--   
--   <pre>
--   &gt;&gt;&gt; let layout = symlink "foo" "bar" &amp; exists .~ True
--   </pre>
exists :: Traversal' (Layout a) Bool

-- | An optic into file auxiliary data
aux :: Traversal' (Layout a) Aux

-- | An optic into file owner
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; user ?~ uid 0
--   </pre>
user :: Traversal' (Layout a) (Maybe User)

-- | Set the file owner by uid
uid :: UserID -> User

-- | Set the file owner by username
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; user ?~ username "root"
--   </pre>
username :: String -> User

-- | An optic into file group
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; group ?~ gid 0
--   </pre>
group :: Traversal' (Layout a) (Maybe Group)

-- | Set the file group by groupname
gid :: GroupID -> Group

-- | Set the file group by groupname
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; group ?~ groupname "wheel"
--   </pre>
groupname :: String -> Group

-- | An optic into file mode
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; mode ?~ 0o100777
--   </pre>
mode :: Traversal' (Layout a) (Maybe FileMode)

-- | An optic into directory contents
innards :: Traversal' (Layout a) (Layout a)

-- | An optic into the directory contents of the particular directory
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   dirs ["foo", "bar", "baz"] (symlink "qux" "quux")
--     ^? into "foo".into "bar".into "baz".focus "qux".source
--   :}
--   Just "quux"
--   </pre>
into :: String -> Traversal' (Layout ()) (Layout ())

-- | An optic into the particular node
focus :: String -> Traversal' (Layout ()) (Layout ())
instance Typeable Contents
instance Typeable User
instance Typeable Group
instance Typeable Aux
instance Typeable1 F
instance Typeable1 Layout
instance Eq Contents
instance Data Contents
instance Generic Contents
instance Show User
instance Eq User
instance Generic User
instance Show Group
instance Eq Group
instance Generic Group
instance Show Aux
instance Eq Aux
instance Generic Aux
instance Eq a => Eq (F a)
instance Functor F
instance Foldable F
instance Traversable F
instance Generic (F a)
instance Functor Layout
instance Applicative Layout
instance Monad Layout
instance Foldable Layout
instance Traversable Layout
instance Generic (Layout a)
instance Datatype D1Contents
instance Constructor C1_0Contents
instance Constructor C1_1Contents
instance Constructor C1_2Contents
instance Datatype D1User
instance Constructor C1_0User
instance Constructor C1_1User
instance Datatype D1Group
instance Constructor C1_0Group
instance Constructor C1_1Group
instance Datatype D1Aux
instance Constructor C1_0Aux
instance Datatype D1F
instance Constructor C1_0F
instance Constructor C1_1F
instance Constructor C1_2F
instance Constructor C1_3F
instance Datatype D1Layout
instance Constructor C1_0Layout
instance Selector S1_0_0Layout
instance Semigroup (Layout a)
instance Eq (Layout a)
instance IsString Group
instance IsString User
instance IsString Contents


-- | A bunch of <a>Layout</a> description interpreters
module System.Directory.Layout.Interpreter

-- | Pretty print the directory layout
pretty :: Layout a -> String

-- | Interpret the directory layout as a <a>Spec</a>
examples :: FilePath -> Layout a -> Spec

-- | Construct <tt>Validation</tt> value from the list of errors
--   
--   <pre>
--   &gt;&gt;&gt; fromErrors []
--   Right ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromErrors Nothing
--   Right ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromErrors "hello"
--   Left ('h' :| "ello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromErrors (Just "hello")
--   Left ("hello" :| [])
--   </pre>
fromErrors :: Foldable t => t e -> Either (NonEmpty e) ()

-- | Check the real directory layout fits the description
fit :: FilePath -> Layout a -> IO (Either (NonEmpty FitError) ())

-- | Errors encountered while running <a>fit</a>
data FitError
FitBadFileContents :: FilePath -> FitContentsError -> FitError
FitBadLinkSource :: FilePath -> String -> String -> FitError
FitBadOwnerUser :: FilePath -> User -> User -> FitError
FitBadOwnerGroup :: FilePath -> Group -> Group -> FitError
FitBadFileMode :: FilePath -> FileMode -> FileMode -> FitError
FitIOException :: FilePath -> IOErrorType -> FitError

-- | Expected/actual file contents mismatch
data FitContentsError
FitBadBinary :: ByteString -> ByteString -> FitContentsError
FitBadText :: Text -> Text -> FitContentsError
FitBadCopyOf :: FilePath -> FitContentsError

-- | Make the real directory layout from the description
make :: FilePath -> Layout a -> IO (Either (NonEmpty MakeError) ())

-- | Make the real directory layout from the description removing any
--   previous contents
remake :: FilePath -> Layout a -> IO (Either (NonEmpty MakeError) ())

-- | Errors encountered while running <a>make</a>
data MakeError
MakeIOException :: FilePath -> IOErrorType -> MakeError
instance Typeable FitContentsError
instance Typeable FitError
instance Typeable MakeError
instance Typeable2 \/
instance Eq FitContentsError
instance Generic FitContentsError
instance Eq FitError
instance Generic FitError
instance Show MakeError
instance Eq MakeError
instance Generic MakeError
instance (Show e, Show a) => Show (e \/ a)
instance (Eq e, Eq a) => Eq (e \/ a)
instance (Ord e, Ord a) => Ord (e \/ a)
instance Functor ((\/) e)
instance Foldable ((\/) e)
instance Traversable ((\/) e)
instance (Data e, Data a) => Data (e \/ a)
instance Generic (e \/ a)
instance Datatype D1FitContentsError
instance Constructor C1_0FitContentsError
instance Constructor C1_1FitContentsError
instance Constructor C1_2FitContentsError
instance Datatype D1FitError
instance Constructor C1_0FitError
instance Constructor C1_1FitError
instance Constructor C1_2FitError
instance Constructor C1_3FitError
instance Constructor C1_4FitError
instance Constructor C1_5FitError
instance Datatype D1MakeError
instance Constructor C1_0MakeError
instance Datatype D1\/
instance Constructor C1_0\/
instance Constructor C1_1\/
instance Semigroup e => Applicative ((\/) e)
instance Exception MakeError
instance Exception FitError
instance Show FitError


-- | Directory layout DSL
module System.Directory.Layout

-- | Directory layout description
data Layout a

-- | Regular file with some contents or empty
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo"
--   </pre>
file :: String -> Layout ()

-- | Symbolic link
--   
--   <pre>
--   &gt;&gt;&gt; let layout = symlink "foo" "bar"
--   </pre>
symlink :: String -> FilePath -> Layout ()

-- | Directory
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let layout = dir "foo" $ do
--         file "bar"
--         file "baz"
--   :}
--   </pre>
dir :: String -> Layout a -> Layout ()

-- | A nested list of directories
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let layout = dirs ["foo", "bar"] $ do
--                  file "qux"
--                  file "quux"
--   :}
--   </pre>
dirs :: [String] -> Layout () -> Layout ()

-- | Empty directory
--   
--   <pre>
--   &gt;&gt;&gt; let layout = emptydir "foo"
--   </pre>
emptydir :: String -> Layout ()

-- | An optic into file contents
contents :: Traversal' (Layout a) (Maybe Contents)

-- | Regular file contents
data Contents
Binary :: ByteString -> Contents
Text :: Text -> Contents
CopyOf :: FilePath -> Contents

-- | Binary contents
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; contents ?~ binary (ByteString.pack [1..10])
--   </pre>
binary :: ByteString -> Contents

-- | Plain text contents
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; contents ?~ text (Data.Text.pack "hello")
--   </pre>
text :: Text -> Contents

-- | A handy quasiquoter to work with the multiline file contents
--   
--   Strips the longest common leading spaces segment. All spacey
--   characters are treated equally. The first line is ignored if it's
--   spaces only.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStr [dedent|
--     hello
--       world
--       !
--   |]
--   :}
--   hello
--     world
--     !
--   </pre>
dedent :: QuasiQuoter

-- | <a>dedent</a> with variable substitution
--   
--   <pre>
--   &gt;&gt;&gt; let hello = "bye" :: String
--   
--   &gt;&gt;&gt; :{
--   putStr [dedentSubst|
--     #{hello}
--       world
--       !
--   |]
--   :}
--   bye
--     world
--     !
--   </pre>
dedentSubst :: QuasiQuoter

-- | Contents are the copy of whose of the real file
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; contents ?~ copyOf "/home/user/.vimrc"
--   </pre>
copyOf :: FilePath -> Contents

-- | An optic into symbolic link source
--   
--   <pre>
--   &gt;&gt;&gt; symlink "foo" "bar" ^? source
--   Just "bar"
--   </pre>
source :: Traversal' (Layout a) String

-- | An optic into symbolic link source expected existence
--   
--   <pre>
--   &gt;&gt;&gt; let layout = symlink "foo" "bar" &amp; exists .~ True
--   </pre>
exists :: Traversal' (Layout a) Bool

-- | File owner
data User
UserID :: UserID -> User
Username :: String -> User

-- | An optic into file owner
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; user ?~ uid 0
--   </pre>
user :: Traversal' (Layout a) (Maybe User)

-- | Set the file owner by uid
uid :: UserID -> User

-- | Set the file owner by username
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; user ?~ username "root"
--   </pre>
username :: String -> User

-- | File group
data Group
GroupID :: GroupID -> Group
Groupname :: String -> Group

-- | An optic into file group
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; group ?~ gid 0
--   </pre>
group :: Traversal' (Layout a) (Maybe Group)

-- | Set the file group by groupname
gid :: GroupID -> Group

-- | Set the file group by groupname
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; group ?~ groupname "wheel"
--   </pre>
groupname :: String -> Group

-- | An optic into file mode
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; mode ?~ 0o100777
--   </pre>
mode :: Traversal' (Layout a) (Maybe FileMode)

-- | Anything
--   
--   <pre>
--   &gt;&gt;&gt; let layout = file "foo" &amp; contents .~ anything
--   
--   &gt;&gt;&gt; let layout = file "foo" &amp; user .~ anything
--   </pre>
anything :: Maybe a

-- | An optic into the directory contents of the particular directory
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   dirs ["foo", "bar", "baz"] (symlink "qux" "quux")
--     ^? into "foo".into "bar".into "baz".focus "qux".source
--   :}
--   Just "quux"
--   </pre>
into :: String -> Traversal' (Layout ()) (Layout ())

-- | An optic into the particular node
focus :: String -> Traversal' (Layout ()) (Layout ())
