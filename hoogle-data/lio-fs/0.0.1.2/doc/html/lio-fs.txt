-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Labeled File System interface for LIO
--   
@package lio-fs
@version 0.0.1.2


-- | This module exports the basic interface for creating and using the
--   labeled file system, implemented as a file store. Trusted code should
--   use <a>initializeLIOFS</a> to set the root of the labeled file system.
--   Moreover, trusted code should implement all the IO functions in terms
--   of <a>createFileTCB</a>, <a>createDirectoryTCB</a>, and
--   <a>getPathLabelTCB</a> and <a>setPathLabelTCB</a>.
--   
--   The current implementation uses the <a>Show</a> and <a>Read</a>
--   instance to serialize and de-serialize labels, respectively. While
--   this is inefficient, it make it easy to use tools like <i>getfattr</i>
--   to inspect the labels of files. In a future version we may modify this
--   implementation to use binary encoding and/or compression (since
--   filesystem extended attributes are large, but limited).
module LIO.FS.TCB

-- | Initialize filesystem at the given path. The supplied path must be
--   absolute, otherwise <tt>initializeLIOFS</tt> throw
--   <a>FSRootInvalid</a>. If the FS has already been created then
--   <tt>initializeLIOFS</tt> solely verifies that the root directory is
--   not corrupt (see <a>checkFSTCB</a>) and returns the label of the root.
--   Otherwise, a new FS is created with the supplied label (see
--   <a>mkFSTCB</a>).
--   
--   NOTE: This function should only be called once per process.
initializeLIOFS :: Label l => FilePath -> Maybe l -> IO l

-- | Top-level wrapper thatexecutes <a>initializeLIOFS</a> followed by the
--   supplied action.
--   
--   NOTE: This function should only be called once per process.
withLIOFS :: Label l => FilePath -> Maybe l -> IO a -> IO a

-- | Get the root directory.
getRootDirTCB :: Label l => LIO l FilePath

-- | Set the label of a given path. This function sets the <a>labelAttr</a>
--   attribute to the encoded label, and the hash to <a>labelHashAttr</a>.
--   
--   NOTE: This function takes an arbitrary path, hence must not be
--   available to untrusted code.
setPathLabelTCB :: Label l => FilePath -> l -> IO ()

-- | Get the label of a given path. If the object does not have an
--   associated label or the hash of the label and stored-hash are not
--   equal, this function throws <a>FSLabelCorrupt</a>.
--   
--   NOTE: This function takes an arbitrary path, hence must not be
--   available to untrusted code.
getPathLabelTCB :: Label l => FilePath -> IO l

-- | Create a file object with the given label and return a handle to the
--   new file.
createFileTCB :: Label l => l -> FilePath -> IOMode -> LIO l Handle

-- | Same as <a>createFileTCB</a> but opens the file in binary mode.
createBinaryFileTCB :: Label l => l -> FilePath -> IOMode -> LIO l Handle

-- | Create a directory object with the given label.
createDirectoryTCB :: Label l => l -> FilePath -> LIO l ()

-- | Filesystem errors
data FSError

-- | Root structure is corrupt.
FSRootCorrupt :: FSError

-- | Root is invalid (must be absolute).
FSRootInvalid :: FSError

-- | Root already exists.
FSRootExists :: FSError

-- | Root does not exists.
FSRootNoExist :: FSError

-- | Cannot create root, missing label.
FSRootNeedLabel :: FSError

-- | FSobjectcannot be created without a label.
FSObjNeedLabel :: FSError

-- | Object label is corrupt.
FSLabelCorrupt :: FilePath -> FSError

-- | Supplied file name is illegal.
FSIllegalFileName :: FSError
instance Typeable FSError
instance Eq FSError
instance Show FSError
instance Exception FSError


-- | This module provides a very simple API for interacting with a labeled
--   filesystem. Each file and directory hsa an associated label that is
--   used to track and control the information flowing to/from the
--   file/directory. The API exposed by this module is analogous to a
--   subset of the <a>System.IO</a> API. We currently do not allow
--   operations on file handles. Rather, files must be read read and
--   written to in whole (as strict ByteStrings).
--   
--   The actual storage of labeled files is handled by the
--   <a>LIO.FS.TCB</a> module. The filesystem is implemented as a file
--   store in which labels are associated with files and directories using,
--   extended attributes.
--   
--   <i>IMPORTANT:</i> To use the labeled filesystem you must use
--   <a>withLIOFS</a> (or other initializers), otherwise any actions built
--   using the combinators of this module will crash.
--   
--   An example use case shown below:
--   
--   <pre>
--   import LIO.FS.Simple
--   import LIO.FS.Simple.DCLabel
--   
--   main = withDCFS "/tmp/lioFS" $ evalDC $ do
--     createDirectoryP p lsecrets "secrets"
--     writeFileP p ("secrets" &lt;/&gt; "alice" ) "I like Bob!"
--       where p = ...
--             lsecrets = ....
--   </pre>
--   
--   The file store for the labeled filesystem (see <a>LIO.FS.TCB</a>) will
--   be created in <tt>/tmp/lioFS</tt>, but this is transparent and the
--   user can think of the filesystem as having root <tt>/</tt>. Note that
--   for this to work the filesystem must be mounted with the
--   <tt>user_xattr</tt> option. For example, on GNU/Linux, you can remount
--   your drive:
--   
--   <pre>
--   mount -o remount -o user_xattr devicename
--   </pre>
--   
--   In the current version of the filesystem, there is no notion of
--   changeable current working directory in the <a>LIO</a> Monad, nor
--   symbolic links.
module LIO.FS.Simple

-- | Initialize filesystem at the given path. The supplied path must be
--   absolute, otherwise <tt>initializeLIOFS</tt> throw
--   <a>FSRootInvalid</a>. If the FS has already been created then
--   <tt>initializeLIOFS</tt> solely verifies that the root directory is
--   not corrupt (see <a>checkFSTCB</a>) and returns the label of the root.
--   Otherwise, a new FS is created with the supplied label (see
--   <a>mkFSTCB</a>).
--   
--   NOTE: This function should only be called once per process.
initializeLIOFS :: Label l => FilePath -> Maybe l -> IO l

-- | Top-level wrapper thatexecutes <a>initializeLIOFS</a> followed by the
--   supplied action.
--   
--   NOTE: This function should only be called once per process.
withLIOFS :: Label l => FilePath -> Maybe l -> IO a -> IO a

-- | Reads a file and returns the contents of the file as a strict
--   ByteString. The current label is raised to reflect all the traversed
--   directories. If the file exists it is further raised to the label of
--   the file to reflect the read.
readFile :: MonadLIO l m => FilePath -> m ByteString

-- | Same as <a>readFile</a> but uses privilege in opening the file.
readFileP :: (MonadLIO l m, PrivDesc l p) => Priv p -> FilePath -> m ByteString

-- | Given an optional label, file path and string, write the string to the
--   file at specified path. The optional label (which must be bounded by
--   the current label and clearance, as enforced by <a>guardAlloc</a>) is
--   used to set the label on the file, if the file does not already exist;
--   otherwise the label must flow to the label of the file. (Supplying a
--   <a>Nothing</a> is the same as <a>Just</a> supplying the current
--   label.) This function ensures that current label is raised to reflect
--   all the traversed directories. Note that if the file does not already
--   exist, it is further required that the current computation be able to
--   write to the containing directory, as imposed by <a>guardWrite</a>.
writeFile :: MonadLIO l m => Maybe l -> FilePath -> ByteString -> m ()

-- | Same as <a>writeFile</a> but uses privilege when writing to the file.
writeFileP :: (PrivDesc l p, MonadLIO l m) => Priv p -> Maybe l -> FilePath -> ByteString -> m ()

-- | Given a file path and string, append the string to the file at
--   specified path. This function ensures that current label is raised to
--   reflect all the traversed directories. Moreover, it requires that the
--   file this is appending to exists and its label is bounded by the
--   current label and clearance (as enforced by <a>guardAlloc</a>).
appendFile :: MonadLIO l m => FilePath -> ByteString -> m ()

-- | Same as <a>appendFile</a> but uses privilege when writing to the file.
appendFileP :: (PrivDesc l p, MonadLIO l m) => Priv p -> FilePath -> ByteString -> m ()

-- | Remove the file at the specified path. The current computation must be
--   able to both write to the file and containing directory. Moreover, the
--   current label is raised to reflect the traversal of directories up to
--   the file.
removeFile :: MonadLIO l m => FilePath -> m ()

-- | Same as <a>removeFile</a>, but uses privileges to carry out the
--   actions.
removeFileP :: (MonadLIO l m, PrivDesc l p) => Priv p -> FilePath -> m ()

-- | Get the label of a file/director at the supplied file path. The
--   current label is raised to reflect all the traversed directories.
labelOfFile :: MonadLIO l m => FilePath -> m l

-- | Same as <a>labelOfFile</a> but uses privilege in traversing
--   directories.
labelOfFileP :: (MonadLIO l m, PrivDesc l p) => Priv p -> FilePath -> m l

-- | Get the contents of a directory. The current label is raised to the
--   join of the current label and that of all the directories traversed to
--   the leaf directory. Note that, unlike the standard Haskell
--   <a>getDirectoryContents</a>, we first normalise the path by collapsing
--   all the <tt>..</tt>'s. The function uses <tt>unlabelFilePath</tt> when
--   raising the current label and thus may throw an exception if the
--   clearance is too low. <i>Note:</i> The current LIO filesystem does not
--   support links.
getDirectoryContents :: MonadLIO l m => FilePath -> m [FilePath]

-- | Same as <a>getDirectoryContents</a>, but uses privileges when raising
--   the current label.
getDirectoryContentsP :: (MonadLIO l m, PrivDesc l p) => Priv p -> FilePath -> m [FilePath]

-- | Create a directory at the supplied path with the given label. The
--   given label must be bounded by the the current label and clearance, as
--   checked by <a>guardAlloc</a>. The current label (after traversing the
--   filesystem to the directory path) must flow to the supplied label,
--   which must, in turn, flow to the current label as required by
--   <a>guardWrite</a>.
createDirectory :: MonadLIO l m => l -> FilePath -> m ()

-- | Same as <a>createDirectory</a>, but uses privileges when raising the
--   current label and checking IFC restrictions.
createDirectoryP :: (MonadLIO l m, PrivDesc l p) => Priv p -> l -> FilePath -> m ()

-- | Same as <a>removeFile</a>, but removes a directory.
removeDirectory :: MonadLIO l m => FilePath -> m ()

-- | Same as <a>removeDirectory</a>, but uses privileges to carry out the
--   actions.
removeDirectoryP :: (MonadLIO l m, PrivDesc l p) => Priv p -> FilePath -> m ()

-- | Filesystem errors
data FSError

-- | Root structure is corrupt.
FSRootCorrupt :: FSError

-- | Root is invalid (must be absolute).
FSRootInvalid :: FSError

-- | Root already exists.
FSRootExists :: FSError

-- | Root does not exists.
FSRootNoExist :: FSError

-- | Cannot create root, missing label.
FSRootNeedLabel :: FSError

-- | FSobjectcannot be created without a label.
FSObjNeedLabel :: FSError

-- | Object label is corrupt.
FSLabelCorrupt :: FilePath -> FSError

-- | Supplied file name is illegal.
FSIllegalFileName :: FSError

-- | Cleanup a file path, if it starts out with a <tt>..</tt>, we consider
--   this invalid as it can be used explore parts of the filesystem that
--   should otherwise be unaccessible. Similarly, we remove any <tt>.</tt>
--   from the path.
cleanUpPath :: CleanUpPath m => FilePath -> m FilePath

-- | Given a pathname to a labeled filesystem object, traverse all the
--   directories up to the object, while correspondingly raising the
--   current label. Note that if the object or a parent-directory does not
--   exist, an exception will be thrown; the label of the exception will be
--   the join of all the directory labels up to the lookup failure.
--   
--   <i>Note:</i> this function cleans up the path before doing the lookup,
--   so e.g., path <tt><i>foo</i>bar/..</tt> will first be rewritten to
--   <tt>/foo</tt> and thus no traversal to <tt>bar</tt>. Note that this is
--   a more permissive behavior than forcing the read of <tt>..</tt> from
--   <tt>bar</tt>. <tt>taintObjPath</tt> returns this cleaned up path.
taintObjPathP :: (MonadLIO l m, PrivDesc l p) => Priv p -> FilePath -> m FilePath

-- | Label the directory and every file within recursively with the
--   supplied label. Note this funciton expects a full path.
labelDirectoryRecursively :: Label l => l -> FilePath -> IO ()
instance Label l => CleanUpPath (LIO l)
instance CleanUpPath IO


-- | This module exposes a function for initializing a labeled filestore
--   with the default label <a>dcPublic</a>.
module LIO.FS.Simple.DCLabel

-- | Initialize root filesystem at supplied path with public label.
initializeDCFS :: FilePath -> IO ()

-- | Top-level IO wrapper for using filesystem.
withDCFS :: FilePath -> IO a -> IO a
