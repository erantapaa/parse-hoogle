-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Libraries for processing GHC Core
--   
--   Libraries for processing GHC Core
@package extcore
@version 1.0.2

module Language.Core.Encoding
type UserString = String
type EncodedString = String
zEncodeString :: UserString -> EncodedString
unencodedChar :: Char -> Bool
encode_ch :: Char -> EncodedString
zDecodeString :: EncodedString -> UserString
decode_upper :: Char -> Char
decode_lower :: Char -> Char
decode_num_esc :: Char -> EncodedString -> UserString
decode_tuple :: Char -> EncodedString -> UserString
maybe_tuple :: UserString -> Maybe EncodedString
count_commas :: Int -> String -> (Int, String)

module Language.Core.ParseGlue
data ParseResult a
OkP :: a -> ParseResult a
FailP :: String -> ParseResult a
type P a = String -> Int -> ParseResult a
thenP :: P a -> (a -> P b) -> P b
returnP :: a -> P a
failP :: String -> P a
data Token
TKmodule :: Token
TKdata :: Token
TKnewtype :: Token
TKforall :: Token
TKrec :: Token
TKlet :: Token
TKin :: Token
TKcase :: Token
TKof :: Token
TKcast :: Token
TKnote :: Token
TKexternal :: Token
TKdynexternal :: Token
TKlabel :: Token
TKwild :: Token
TKoparen :: Token
TKcparen :: Token
TKobrace :: Token
TKcbrace :: Token
TKhash :: Token
TKeq :: Token
TKcoloncolon :: Token
TKstar :: Token
TKrarrow :: Token
TKlambda :: Token
TKbiglambda :: Token
TKat :: Token
TKdot :: Token
TKcolon :: Token
TKquestion :: Token
TKsemicolon :: Token
TKname :: String -> Token
TKcname :: String -> Token
TKinteger :: Integer -> Token
TKrational :: Rational -> Token
TKstring :: String -> Token
TKchar :: Char -> Token
TKsym :: Token
TKtrans :: Token
TKunsafe :: Token
TKleft :: Token
TKright :: Token
TKinst :: Token
TKpercent :: Token
TKEOF :: Token
splitModuleName :: EncodedString -> ([String], String)
instance Show a => Show (ParseResult a)

module Language.Core.Env
eempty :: Map a b
elookup :: (Eq a, Ord a) => Map a b -> a -> Maybe b
eextend :: Ord a => Map a b -> (a, b) -> Map a b
edomain :: Eq a => Map a b -> [a]
efromlist :: Ord a => [(a, b)] -> Map a b
etolist :: Map a b -> [(a, b)]
efilter :: Ord a => Map a b -> (a -> Bool) -> Map a b
eremove :: (Eq a, Ord a) => Map a b -> a -> Map a b

module Language.Core.Core
data Module
Module :: AnMname -> [Tdef] -> [Vdefg] -> Module
data Tdef
Data :: (Qual Tcon) -> [Tbind] -> [Cdef] -> Tdef
Newtype :: (Qual Tcon) -> (Qual Tcon) -> [Tbind] -> Ty -> Tdef
data Cdef
Constr :: (Qual Dcon) -> [Tbind] -> [Ty] -> Cdef
data Vdefg
Rec :: [Vdef] -> Vdefg
Nonrec :: Vdef -> Vdefg
newtype Vdef
Vdef :: (Qual Var, Ty, Exp) -> Vdef
data Exp
Var :: (Qual Var) -> Exp
Dcon :: (Qual Dcon) -> Exp
Lit :: Lit -> Exp
App :: Exp -> Exp -> Exp
Appt :: Exp -> Ty -> Exp
Lam :: Bind -> Exp -> Exp
Let :: Vdefg -> Exp -> Exp
Case :: Exp -> Vbind -> Ty -> [Alt] -> Exp
Cast :: Exp -> Ty -> Exp
Note :: String -> Exp -> Exp
External :: String -> Ty -> Exp
data Bind
Vb :: Vbind -> Bind
Tb :: Tbind -> Bind
data Alt
Acon :: (Qual Dcon) -> [Tbind] -> [Vbind] -> Exp -> Alt
Alit :: Lit -> Exp -> Alt
Adefault :: Exp -> Alt
type Vbind = (Var, Ty)
type Tbind = (Tvar, Kind)
data Ty
Tvar :: Tvar -> Ty
Tcon :: (Qual Tcon) -> Ty
Tapp :: Ty -> Ty -> Ty
Tforall :: Tbind -> Ty -> Ty
TransCoercion :: Ty -> Ty -> Ty
SymCoercion :: Ty -> Ty
UnsafeCoercion :: Ty -> Ty -> Ty
InstCoercion :: Ty -> Ty -> Ty
LeftCoercion :: Ty -> Ty
RightCoercion :: Ty -> Ty
data Kind
Klifted :: Kind
Kunlifted :: Kind
Kopen :: Kind
Karrow :: Kind -> Kind -> Kind
Keq :: Ty -> Ty -> Kind
data CoercionKind
DefinedCoercion :: [Tbind] -> (Ty, Ty) -> CoercionKind
data KindOrCoercion
Kind :: Kind -> KindOrCoercion
Coercion :: CoercionKind -> KindOrCoercion
data Lit
Literal :: CoreLit -> Ty -> Lit
data CoreLit
Lint :: Integer -> CoreLit
Lrational :: Rational -> CoreLit
Lchar :: Char -> CoreLit
Lstring :: String -> CoreLit
type Mname = Maybe AnMname
newtype AnMname
M :: (Pname, [Id], Id) -> AnMname
newtype Pname
P :: Id -> Pname
type Var = Id
type Tvar = Id
type Tcon = Id
type Dcon = Id
type Qual t = (Mname, t)
qual :: AnMname -> t -> Qual t
unqual :: t -> Qual t
getModule :: Qual t -> Mname
type Id = String
eqKind :: Kind -> Kind -> Bool
splitTyConApp_maybe :: Ty -> Maybe (Qual Tcon, [Ty])
equalTy :: Ty -> Ty -> Bool
subKindOf :: Kind -> Kind -> Bool
baseKind :: Kind -> Bool
isPrimVar :: (Maybe AnMname, t) -> Bool
primMname :: AnMname
errMname :: AnMname
mkBaseMname :: Id -> AnMname
mkPrimMname :: Id -> AnMname
basePkg :: Pname
mainPkg :: Pname
primPkg :: Pname
ghcPrefix :: [[Char]]
mainPrefix :: [a]
boolMname :: AnMname
mainVar :: Qual [Char]
wrapperMainVar :: Qual [Char]
mainMname :: AnMname
wrapperMainMname :: AnMname
wrapperMainAnMname :: Maybe AnMname
dcTrue :: Dcon
dcFalse :: Dcon
tcArrow :: Qual Tcon
tArrow :: Ty -> Ty -> Ty
mkFunTy :: Ty -> Ty -> Ty
ktArrow :: Kind
maxUtuple :: Int
tcUtuple :: Int -> Qual Tcon
ktUtuple :: Int -> Kind
tUtuple :: [Ty] -> Ty
isUtupleTy :: Ty -> Bool
dcUtuple :: Int -> Qual Dcon
isUtupleDc :: Qual Dcon -> Bool
dcUtupleTy :: Int -> Ty
utuple :: [Ty] -> [Exp] -> Exp
flattenBinds :: [Vdefg] -> [Vdef]
unitMname :: AnMname
instance Typeable CoreLit
instance Typeable Pname
instance Typeable AnMname
instance Typeable Ty
instance Typeable Kind
instance Typeable Lit
instance Typeable Bind
instance Typeable Vdef
instance Typeable Exp
instance Typeable Alt
instance Typeable Vdefg
instance Typeable Cdef
instance Typeable Tdef
instance Typeable Module
instance Data CoreLit
instance Eq CoreLit
instance Eq Pname
instance Ord Pname
instance Data Pname
instance Eq AnMname
instance Ord AnMname
instance Data AnMname
instance Data Ty
instance Data Kind
instance Data Lit
instance Eq Lit
instance Data Bind
instance Data Vdef
instance Data Exp
instance Data Alt
instance Data Vdefg
instance Data Cdef
instance Data Tdef
instance Data Module
instance Eq Ty

module Language.Core.Printer
indent :: Doc -> Doc
pmodule :: Module -> Doc
ptdef :: Tdef -> Doc
pcdef :: Cdef -> Doc
pname :: String -> Doc
pqname :: (Maybe AnMname, String) -> Doc
pmname :: Maybe AnMname -> Doc
panmname :: AnMname -> Doc
hierModuleSeparator :: Doc
ptbind :: Tbind -> Doc
pattbind :: (Tvar, Kind) -> Doc
pakind :: Kind -> Doc
pkind :: Kind -> Doc
peqkind :: (Ty, Ty) -> Doc
paty :: Ty -> Doc
pbty :: Ty -> Doc
pty :: Ty -> Doc
pappty :: Ty -> [Ty] -> Doc
pforall :: [Tbind] -> Ty -> Doc
pvdefg :: Vdefg -> Doc
pvdef :: Vdef -> Doc
paexp :: Exp -> Doc
plamexp :: [Bind] -> Exp -> Doc
pbind :: Bind -> Doc
pfexp :: Exp -> Doc
pappexp :: Exp -> [Either Exp Ty] -> Doc
pexp :: Exp -> Doc
pvbind :: (String, Ty) -> Doc
palt :: Alt -> Doc
plit :: Lit -> Doc
pclit :: CoreLit -> Doc
pstring :: String -> Doc
escape :: String -> String
instance Show AnMname
instance Show KindOrCoercion
instance Show CoreLit
instance Show Lit
instance Show CoercionKind
instance Show Kind
instance Show Ty
instance Show Alt
instance Show Exp
instance Show Vdef
instance Show Vdefg
instance Show Cdef
instance Show Tdef
instance Show Module

module Language.Core.CoreUtils
splitDataConApp_maybe :: Exp -> Maybe (Qual Dcon, [Ty], [Exp])
splitApp :: Exp -> (Exp, [Exp])
splitAppIgnoreCasts :: Exp -> (Exp, [Exp])
splitFunTy_maybe :: Ty -> Maybe ([Ty], Ty)
splitFunTy2_maybe :: Ty -> Maybe (Ty, Ty)
vdefNamesQ :: [Vdef] -> [Qual Var]
vdefNames :: [Vdef] -> [Var]
vdefTys :: [Vdef] -> [Ty]
vdefgNames :: Vdefg -> [Var]
vdefgNamesQ :: Vdefg -> [Qual Var]
vdefgTys :: Vdefg -> [Ty]
vdefgBodies :: Vdefg -> [Exp]
vbNames :: [Vbind] -> [Var]
substIn :: Data a => Var -> Var -> a -> a
substVars :: Data a => [Var] -> [Var] -> a -> a
tdefNames :: [Tdef] -> [Qual Var]
tdefDcons :: [Tdef] -> [Qual Var]
tdefTcons :: [Tdef] -> [Qual Var]
filterVdefgs :: (Vdef -> Bool) -> [Vdefg] -> [Vdefg]
applyNewtype :: CoercionKind -> [Ty] -> (Ty, Ty)
substl :: [Tvar] -> [Ty] -> Ty -> Ty
freeTvars :: Ty -> [Tvar]
freshTvar :: [Tvar] -> Tvar
splitLambda :: Exp -> ([Bind], Exp)
vbinds :: [Bind] -> [(Var, Ty)]
splitBinds :: [Bind] -> ([(Tvar, Kind)], [(Var, Ty)])
freeVars :: Exp -> [Qual Var]
freeVarss :: [Exp] -> [Qual Var]
mapVdefg :: Monad m => (Vdef -> m Vdef) -> Vdefg -> m Vdefg

module Language.Core.Interp
evalProgram :: [Module] -> IO Value
instance Eq PrimValue
instance Show PrimValue
instance Show Value
instance Show HeapValue
instance Show Heap
instance Error Value

module Language.Core.DebugPrinter
removeTypeBinds :: Data a => a -> a
pmodule :: Print Module

-- | Options controlling the printing of external core.
data PrintOpts
PrintOpts :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> PrintOpts

-- | Whether to decode names into their recognisable form, i.e.
--   Data.List.nub instead of DataziListzinub.
decodeNames :: PrintOpts -> Bool

-- | Whether to ignore module names on fully qualified names, i.e. nub
--   instead of Data.List.nub.
ignoreQuals :: PrintOpts -> Bool

-- | Whether to ignore kinds when printing out.
ignoreKinds :: PrintOpts -> Bool

-- | Whether to ignore type annotations when printing out.
ignoreTypeBinds :: PrintOpts -> Bool

-- | Whether to ignore things that look like dictionary parameters (ignores
--   all parameters where the name begins with a dollar sign).
ignoreDicts :: PrintOpts -> Bool

-- | Whether to write Haskell operators in infix form, i.e. p + x rather
--   than (+) p x.
infixOperators :: PrintOpts -> Bool

-- | The default printing options. Everything is True except ignoreQuals.
defOpts :: PrintOpts

module Language.Core.Merge
merge :: Map (Qual Var) (Qual Var) -> [Module] -> Module
uniqueNamesIn :: [Vdefg] -> [Tdef] -> ([Qual Var], [Qual Dcon], [Qual Tcon])
nonUniqueNamesIn :: [Vdef] -> [Tdef] -> [Qual Var]

module Language.Core.ElimDeadCode
elimDeadCode :: Bool -> Module -> Module

module Language.Core.Check
checkModule :: Menv -> Module -> CheckRes Menv
envsModule :: Menv -> Module -> Menv
checkExpr :: AnMname -> Menv -> Tcenv -> Cenv -> Venv -> Tvenv -> Exp -> Ty
checkType :: AnMname -> Menv -> Tcenv -> Tvenv -> Ty -> Kind
primCoercionError :: Show a => a -> b
type Menv = Map AnMname Envs
type Venv = Map Var Ty
type Tvenv = Map Tvar Kind
type Tcenv = Map Tcon KindOrCoercion
data Envs
Envs :: Tcenv -> Cenv -> Venv -> Envs
tcenv_ :: Envs -> Tcenv
cenv_ :: Envs -> Cenv
venv_ :: Envs -> Venv
data CheckRes a
OkC :: a -> CheckRes a
FailC :: String -> CheckRes a
splitTy :: Ty -> ([Tbind], [Ty], Ty)
substl :: [Tvar] -> [Ty] -> Ty -> Ty
mkTypeEnvsNoChecking :: [Tdef] -> (Tcenv, Cenv)
type NtEnv = Map Tcon CoercionKind
mkNtEnv :: Menv -> NtEnv
instance Monad CheckRes


-- | This module currently is buggy. (Patches welcome.) Use
--   <a>Language.Core.Parser</a> instead. See also
--   <a>Language.Core.ParseGlue</a>.
module Language.Core.ParsecParser
parseCore :: FilePath -> IO (Either ParseError Module)
coreModuleName :: Parser AnMname
coreTcon :: Parser ATyOp
coreQualifiedName :: Parser (Mname, Id)
upperName :: Parser String
identifier :: Parser String
coreType :: Parser Ty
coreKind :: Parser Kind
coreTbinds :: Parser [Tbind]
parens :: CharParser st a -> CharParser st a
braces :: CharParser st a -> CharParser st a
topVbind :: Parser (Qual Var, Ty)
pt :: Show a => CharParser () a -> String -> IO ()

module Language.Core.Prep
prepModule :: Menv -> Module -> Module
boundVars :: Exp -> [Id]
boundVarsVdefs :: Vdefg -> [Id]
boundVarsVdef :: Vdef -> [Id]
boundVarsAlts :: [Alt] -> [Var]
boundVarsAlt :: Alt -> [Var]
substNewtys :: NtEnv -> Ty -> Ty
newtypeCoercion_maybe :: NtEnv -> Ty -> Maybe CoercionKind
mkTapp :: Ty -> [Ty] -> Ty
initCounter :: Int
type PrepM = State Int
freshVar :: PrepM String

module Language.Core.Prims
initialEnv :: Menv
primEnv :: Envs
primId :: String -> Qual Id
tIntzh :: Ty
tInt64zh :: Ty
tCharzh :: Ty
tFloatzh :: Ty
tAddrzh :: Ty
tDoublezh :: Ty
tcStatezh :: Qual Tcon
tWordzh :: Ty
tWord64zh :: Ty
tByteArrayzh :: Ty
tcStablePtrzh :: Qual Tcon
tcIO :: Qual Tcon
mkInitialEnv :: [Module] -> IO Menv
mkTypeEnv :: Menv -> Module -> IO Menv
tRWS :: Ty
tBool :: Ty
tcBool :: Qual Tcon
ioBaseMname :: AnMname

module Language.Core.Parser
parse :: P Module

module Language.Core.Dependencies
getDependencies :: [FilePath] -> [FilePath] -> IO [(FilePath, Module)]
