-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reify a recursive data structure into an explicit graph.
--   
--   This package is a (probably temporary) fork of Andy gill's data-reify
--   package. I've tweaked it for typed syntax representations for use with
--   GADTs.
--   
--   'data-reify' provided the ability to turn recursive structures into
--   explicit graphs. Many (implicitly or explicitly) recursive data
--   structure can be given this ability, via a type class instance. This
--   gives an alternative to using <a>Ref</a> for observable sharing.
--   
--   Observable sharing in general is unsafe, so we use the IO monad to
--   bound this effect, but can be used safely even with
--   <a>unsafePerformIO</a> if some simple conditions are met. Typically
--   this package will be used to tie the knot with DSL's that depend of
--   observable sharing, like Lava.
--   
--   Providing an instance for <a>MuRef</a> is the mechanism for allowing a
--   structure to be reified into a graph, and several examples of this are
--   provided.
--   
--   Version 0.2 of 'data-reify' uses <a>StableName</a>s, and is much
--   faster. Version 0.3 provided two versions of <a>MuRef</a>, the
--   mono-typed version, for trees of a single type, and the dynamic-typed
--   version, for trees of different types.
--   
--   Â© 2009-2012 Andy Gill &amp; Conal Elliott; BSD3 license.
@package data-treify
@version 0.3.3

module Data.Reify.TGraph
class ShowF f
showF :: ShowF f => f a -> String

-- | Identifiers
type Id = Int

-- | Typed variables
data V ty a
V :: Id -> (ty a) -> V ty a

-- | Typed binding pair, parameterized by variable and node type
--   constructors.
data Bind ty n
Bind :: (V ty a) -> (n (V ty) a) -> Bind ty n

-- | Fast version, using an IntMap. Important: partially apply.
bindEnv :: IsTy ty => [Bind ty n] -> (V ty a -> n (V ty) a)

-- | Graph, described by bindings and a root variable
data Graph ty n a
Graph :: [Bind ty n] -> (V ty a) -> Graph ty n a
instance (ShowF (n (V ty)), Show (V ty a)) => Show (Graph ty n a)
instance ShowF (n (V ty)) => Show (Bind ty n)
instance Show (V ty a)
instance ShowF (V ty)
instance Eq (V ty a)

module Data.TReify
class MuRef ty h where type family DeRef h :: (* -> *) -> * -> *
mapDeRef :: (MuRef ty h, Applicative m) => (forall a. ty a -> h a -> m (v a)) -> (forall a. ty a -> h a -> m (DeRef h v a))

-- | <a>reifyGraph</a> takes a data structure that admits <a>MuRef</a>, and
--   returns a <a>Graph</a> that contains the dereferenced nodes, with
--   their children as <a>Integer</a> rather than recursive values.
reifyGraph :: (IsTy ty, MuRef ty h) => ty a -> h a -> IO (Graph ty (DeRef h) a)
