-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pretty-printing library
--   
@package pretty
@version 1.1.3.2


-- | This module provides a version of pretty that allows for annotations
--   to be attached to documents. Annotations are arbitrary pieces of
--   metadata that can be attached to sub-documents.
module Text.PrettyPrint.Annotated.HughesPJ

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc a

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails
data AnnotDetails a
AnnotStart :: AnnotDetails a
NoAnnot :: !TextDetails -> {-# UNPACK #-} !Int -> AnnotDetails a
AnnotEnd :: a -> AnnotDetails a

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc a

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc a

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc a

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc a

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc a
int :: Int -> Doc a
integer :: Integer -> Doc a
float :: Float -> Doc a
double :: Double -> Doc a
rational :: Rational -> Doc a
semi :: Doc a
comma :: Doc a
colon :: Doc a
space :: Doc a
equals :: Doc a
lparen :: Doc a
rparen :: Doc a
lbrack :: Doc a
rbrack :: Doc a
lbrace :: Doc a
rbrace :: Doc a
parens :: Doc a -> Doc a
brackets :: Doc a -> Doc a
braces :: Doc a -> Doc a
quotes :: Doc a -> Doc a
doubleQuotes :: Doc a -> Doc a

-- | Apply <a>parens</a> to <a>Doc</a> if boolean is true.
maybeParens :: Bool -> Doc a -> Doc a

-- | Apply <a>brackets</a> to <a>Doc</a> if boolean is true.
maybeBrackets :: Bool -> Doc a -> Doc a

-- | Apply <a>braces</a> to <a>Doc</a> if boolean is true.
maybeBraces :: Bool -> Doc a -> Doc a

-- | Apply <a>quotes</a> to <a>Doc</a> if boolean is true.
maybeQuotes :: Bool -> Doc a -> Doc a

-- | Apply <a>doubleQuotes</a> to <a>Doc</a> if boolean is true.
maybeDoubleQuotes :: Bool -> Doc a -> Doc a

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc a

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc a -> Doc a -> Doc a

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc a -> Doc a -> Doc a

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc a] -> Doc a

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc a] -> Doc a

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc a -> Doc a -> Doc a

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc a -> Doc a -> Doc a

-- | List version of <a>$$</a>.
vcat :: [Doc a] -> Doc a

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc a] -> Doc a

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc a] -> Doc a

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc a] -> Doc a

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc a] -> Doc a

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc a -> Doc a

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc a -> Int -> Doc a -> Doc a

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc a -> [Doc a] -> [Doc a]

-- | Attach an annotation to a document.
annotate :: a -> Doc a -> Doc a

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc a -> Bool

-- | <tt>first</tt> returns its first argument if it is non-empty,
--   otherwise its second.
first :: Doc a -> Doc a -> Doc a

-- | Perform some simplification of a built up <tt>GDoc</tt>.
reduceDoc :: Doc a -> RDoc a

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>.
render :: Doc a -> String
renderSpans :: Doc ann -> (String, [Span ann])
data Span a
Span :: !Int -> !Int -> a -> Span a
spanStart :: Span a -> !Int
spanLength :: Span a -> !Int
spanAnnotation :: Span a -> a

-- | Render out a String, interpreting the annotations as part of the
--   resulting document.
--   
--   IMPORTANT: the size of the annotation string does NOT figure into the
--   layout of the document, so the document will lay out as though the
--   annotations are not present.
renderDecorated :: (ann -> String) -> (ann -> String) -> Doc ann -> String

-- | Render a document with annotations, by interpreting the start and end
--   of the annotations, as well as the text details in the context of a
--   monad.
renderDecoratedM :: Monad m => (ann -> m r) -> (ann -> m r) -> (String -> m r) -> m r -> Doc ann -> m r

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
mode :: Style -> Mode

-- | Length of line, in chars
lineLength :: Style -> Int

-- | Ratio of line length to ribbon length
ribbonsPerLine :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc a -> String

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc b -> a
fullRenderAnn :: Mode -> Int -> Float -> (AnnotDetails b -> a -> a) -> a -> Doc b -> a
instance [safe] Show TextDetails
instance [safe] Eq TextDetails
instance [safe] Generic TextDetails
instance [safe] Show a => Show (AnnotDetails a)
instance [safe] Eq a => Eq (AnnotDetails a)
instance [safe] Generic (Doc a)
instance [safe] Show Mode
instance [safe] Eq Mode
instance [safe] Generic Mode
instance [safe] Show Style
instance [safe] Eq Style
instance [safe] Generic Style
instance [safe] Show a => Show (Span a)
instance [safe] Eq a => Eq (Span a)
instance [safe] Datatype D1TextDetails
instance [safe] Constructor C1_0TextDetails
instance [safe] Constructor C1_1TextDetails
instance [safe] Constructor C1_2TextDetails
instance [safe] Datatype D1Doc
instance [safe] Constructor C1_0Doc
instance [safe] Constructor C1_1Doc
instance [safe] Constructor C1_2Doc
instance [safe] Constructor C1_3Doc
instance [safe] Constructor C1_4Doc
instance [safe] Constructor C1_5Doc
instance [safe] Constructor C1_6Doc
instance [safe] Constructor C1_7Doc
instance [safe] Datatype D1Mode
instance [safe] Constructor C1_0Mode
instance [safe] Constructor C1_1Mode
instance [safe] Constructor C1_2Mode
instance [safe] Constructor C1_3Mode
instance [safe] Datatype D1Style
instance [safe] Constructor C1_0Style
instance [safe] Selector S1_0_0Style
instance [safe] Selector S1_0_1Style
instance [safe] Selector S1_0_2Style
instance [safe] Functor Span
instance [safe] NFData TextDetails
instance [safe] NFData a => NFData (AnnotDetails a)
instance [safe] NFData a => NFData (Doc a)
instance [safe] Functor Doc
instance [safe] Eq (Doc a)
instance [safe] Show (Doc a)
instance [safe] IsString (Doc a)
instance [safe] Monoid (Doc a)
instance [safe] Functor AnnotDetails


-- | Pretty printing class, simlar to <a>Show</a> but nicer looking.
--   
--   Note that the precedence level is a <a>Rational</a> so there is an
--   unlimited number of levels. This module re-exports <a>HughesPJ</a>.
module Text.PrettyPrint.Annotated.HughesPJClass

-- | Pretty printing class. The precedence level is used in a similar way
--   as in the <a>Show</a> class. Minimal complete definition is either
--   <a>pPrintPrec</a> or <a>pPrint</a>.
class Pretty a where pPrintPrec _ _ = pPrint pPrint = pPrintPrec prettyNormal 0 pPrintList l = brackets . fsep . punctuate comma . map (pPrintPrec l 0)
pPrintPrec :: Pretty a => PrettyLevel -> Rational -> a -> Doc ann
pPrint :: Pretty a => a -> Doc ann
pPrintList :: Pretty a => PrettyLevel -> [a] -> Doc ann

-- | Level of detail in the pretty printed output. Level 0 is the least
--   detail.
newtype PrettyLevel
PrettyLevel :: Int -> PrettyLevel

-- | The "normal" (Level 0) of detail.
prettyNormal :: PrettyLevel

-- | Pretty print a value with the <a>prettyNormal</a> level.
prettyShow :: Pretty a => a -> String

-- | Parenthesize an value if the boolean is true.

-- | <i>Deprecated: Please use <a>maybeParens</a> instead</i>
prettyParen :: Bool -> Doc ann -> Doc ann
instance [safe] Eq PrettyLevel
instance [safe] Ord PrettyLevel
instance [safe] Show PrettyLevel
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h) => Pretty (a, b, c, d, e, f, g, h)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g) => Pretty (a, b, c, d, e, f, g)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f) => Pretty (a, b, c, d, e, f)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e) => Pretty (a, b, c, d, e)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d) => Pretty (a, b, c, d)
instance [safe] (Pretty a, Pretty b, Pretty c) => Pretty (a, b, c)
instance [safe] (Pretty a, Pretty b) => Pretty (a, b)
instance [safe] Pretty a => Pretty [a]
instance [safe] (Pretty a, Pretty b) => Pretty (Either a b)
instance [safe] Pretty a => Pretty (Maybe a)
instance [safe] Pretty Char
instance [safe] Pretty Ordering
instance [safe] Pretty Bool
instance [safe] Pretty ()
instance [safe] Pretty Double
instance [safe] Pretty Float
instance [safe] Pretty Integer
instance [safe] Pretty Int


-- | This module provides a version of pretty that allows for annotations
--   to be attached to documents. Annotations are arbitrary pieces of
--   metadata that can be attached to sub-documents.
--   
--   This module should be used as opposed to the <a>HughesPJ</a> module.
--   Both are equivalent though as this module simply re-exports the other.
module Text.PrettyPrint.Annotated

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc a

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc a

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc a

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc a

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc a

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc a
int :: Int -> Doc a
integer :: Integer -> Doc a
float :: Float -> Doc a
double :: Double -> Doc a
rational :: Rational -> Doc a
semi :: Doc a
comma :: Doc a
colon :: Doc a
space :: Doc a
equals :: Doc a
lparen :: Doc a
rparen :: Doc a
lbrack :: Doc a
rbrack :: Doc a
lbrace :: Doc a
rbrace :: Doc a
parens :: Doc a -> Doc a
brackets :: Doc a -> Doc a
braces :: Doc a -> Doc a
quotes :: Doc a -> Doc a
doubleQuotes :: Doc a -> Doc a

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc a

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc a -> Doc a -> Doc a

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc a -> Doc a -> Doc a

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc a] -> Doc a

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc a] -> Doc a

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc a -> Doc a -> Doc a

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc a -> Doc a -> Doc a

-- | List version of <a>$$</a>.
vcat :: [Doc a] -> Doc a

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc a] -> Doc a

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc a] -> Doc a

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc a] -> Doc a

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc a] -> Doc a

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc a -> Doc a

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc a -> Int -> Doc a -> Doc a

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc a -> [Doc a] -> [Doc a]

-- | Attach an annotation to a document.
annotate :: a -> Doc a -> Doc a

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc a -> Bool

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>.
render :: Doc a -> String
renderSpans :: Doc ann -> (String, [Span ann])
data Span a
Span :: !Int -> !Int -> a -> Span a
spanStart :: Span a -> !Int
spanLength :: Span a -> !Int
spanAnnotation :: Span a -> a

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
mode :: Style -> Mode

-- | Length of line, in chars
lineLength :: Style -> Int

-- | Ratio of line length to ribbon length
ribbonsPerLine :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc a -> String

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc b -> a
fullRenderAnn :: Mode -> Int -> Float -> (AnnotDetails b -> a -> a) -> a -> Doc b -> a

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails


-- | Provides a collection of pretty printer combinators, a set of API's
--   that provides a way to easily print out text in a consistent format of
--   your choosing.
--   
--   Originally designed by John Hughes's and Simon Peyton Jones's.
--   
--   For more information you can refer to the <a>original paper</a> that
--   serves as the basis for this libraries design: <i>The Design -- of a
--   Pretty-printing Library</i> by John Hughes, in Advanced Functional
--   Programming, 1995
module Text.PrettyPrint.HughesPJ

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | Apply <a>parens</a> to <a>Doc</a> if boolean is true.
maybeParens :: Bool -> Doc -> Doc

-- | Apply <a>brackets</a> to <a>Doc</a> if boolean is true.
maybeBrackets :: Bool -> Doc -> Doc

-- | Apply <a>braces</a> to <a>Doc</a> if boolean is true.
maybeBraces :: Bool -> Doc -> Doc

-- | Apply <a>quotes</a> to <a>Doc</a> if boolean is true.
maybeQuotes :: Bool -> Doc -> Doc

-- | Apply <a>doubleQuotes</a> to <a>Doc</a> if boolean is true.
maybeDoubleQuotes :: Bool -> Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | <tt>first</tt> returns its first argument if it is non-empty,
--   otherwise its second.
first :: Doc -> Doc -> Doc

-- | Perform some simplification of a built up <tt>GDoc</tt>.
reduceDoc :: Doc -> RDoc

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>.
render :: Doc -> String

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
mode :: Style -> Mode

-- | Length of line, in chars
lineLength :: Style -> Int

-- | Ratio of line length to ribbon length
ribbonsPerLine :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a
instance [safe] Generic Doc
instance [safe] Datatype D1Doc
instance [safe] Constructor C1_0Doc
instance [safe] NFData Doc
instance [safe] Eq Doc
instance [safe] Show Doc
instance [safe] IsString Doc
instance [safe] Monoid Doc


-- | Pretty printing class, simlar to <a>Show</a> but nicer looking.
--   
--   Note that the precedence level is a <a>Rational</a> so there is an
--   unlimited number of levels. This module re-exports <a>HughesPJ</a>.
module Text.PrettyPrint.HughesPJClass

-- | Pretty printing class. The precedence level is used in a similar way
--   as in the <a>Show</a> class. Minimal complete definition is either
--   <a>pPrintPrec</a> or <a>pPrint</a>.
class Pretty a where pPrintPrec _ _ = pPrint pPrint = pPrintPrec prettyNormal 0 pPrintList l = brackets . fsep . punctuate comma . map (pPrintPrec l 0)
pPrintPrec :: Pretty a => PrettyLevel -> Rational -> a -> Doc
pPrint :: Pretty a => a -> Doc
pPrintList :: Pretty a => PrettyLevel -> [a] -> Doc

-- | Level of detail in the pretty printed output. Level 0 is the least
--   detail.
newtype PrettyLevel
PrettyLevel :: Int -> PrettyLevel

-- | The "normal" (Level 0) of detail.
prettyNormal :: PrettyLevel

-- | Pretty print a value with the <a>prettyNormal</a> level.
prettyShow :: Pretty a => a -> String

-- | Parenthesize an value if the boolean is true.

-- | <i>Deprecated: Please use <a>maybeParens</a> instead</i>
prettyParen :: Bool -> Doc -> Doc
instance [safe] Eq PrettyLevel
instance [safe] Ord PrettyLevel
instance [safe] Show PrettyLevel
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h) => Pretty (a, b, c, d, e, f, g, h)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g) => Pretty (a, b, c, d, e, f, g)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f) => Pretty (a, b, c, d, e, f)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e) => Pretty (a, b, c, d, e)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d) => Pretty (a, b, c, d)
instance [safe] (Pretty a, Pretty b, Pretty c) => Pretty (a, b, c)
instance [safe] (Pretty a, Pretty b) => Pretty (a, b)
instance [safe] Pretty a => Pretty [a]
instance [safe] (Pretty a, Pretty b) => Pretty (Either a b)
instance [safe] Pretty a => Pretty (Maybe a)
instance [safe] Pretty Char
instance [safe] Pretty Ordering
instance [safe] Pretty Bool
instance [safe] Pretty ()
instance [safe] Pretty Double
instance [safe] Pretty Float
instance [safe] Pretty Integer
instance [safe] Pretty Int


-- | Provides a collection of pretty printer combinators, a set of API's
--   that provides a way to easily print out text in a consistent format of
--   your choosing.
--   
--   This module should be used as opposed to the <a>HughesPJ</a> module.
--   Both are equivalent though as this module simply re-exports the other.
module Text.PrettyPrint

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>.
render :: Doc -> String

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
mode :: Style -> Mode

-- | Length of line, in chars
lineLength :: Style -> Int

-- | Ratio of line length to ribbon length
ribbonsPerLine :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails
