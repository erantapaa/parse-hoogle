-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Yet another array library
--   
--   Yarr is a new blazing fast dataflow framework (array library), mainly
--   intented to process <tt>Storable</tt>s (including all "primitive"
--   numeric types) and <tt>fixed-vector</tt>s of them, for example
--   coordinates, color components, complex numbers.
--   
--   Yarr framework is inspired by <tt>repa</tt> library and inherits its
--   features, including shape-polymorphism and auto-parallelism.
--   Additionaly, the framework is polymorphic over type and arity of
--   fixed-size vectors and supports neat flow operations over them. For
--   example, you can convert colored image to greyscale like this:
--   
--   <pre>
--   let greyImage = zipElems (\r g b -&gt; 0.21 * r + 0.71 * g + 0.07 * b) image
--   </pre>
--   
--   In some cases the library is considerably faster than <tt>repa</tt>.
--   See benchmark results:
--   <a>https://github.com/leventov/yarr/blob/master/tests/bench-results.md</a>
--   
--   Shortcoming by design: lack of pure indexing interface.
--   
--   <i>Changes in 1.3 (ex. 0.9.3):</i>
--   
--   <ul>
--   <li>IFusion -- mapping/zipping with index</li>
--   <li>Rename: Work -&gt; Walk</li>
--   </ul>
--   
--   <i>Changes in version 0.9.2:</i>
--   
--   <ul>
--   <li>Safe folds -- see <a>Data.Yarr.Walk</a></li>
--   <li>Issue with slice-wise loading with unrolled filling function
--   solved</li>
--   </ul>
--   
--   To start with, read documentation in the root module:
--   <a>Data.Yarr</a>.
--   
--   <ul>
--   <li><i><tt>Yarr!</tt></i></li>
--   </ul>
@package yarr
@version 1.3.2

module Data.Yarr.Utils.Split
makeSplitIndex :: Int -> Int -> Int -> (Int -> Int)

-- | Well-known missed in <a>Data.List.Split</a> function.
evenChunks :: [a] -> Int -> [[a]]

module Data.Yarr.Utils.Parallel
parallel :: Int -> (Int -> IO a) -> IO [a]

-- | Version of <a>parallel</a> which discards results.
parallel_ :: Int -> (Int -> IO a) -> IO ()

module Data.Yarr.Utils.FixedVector

-- | Type family for n-ary functions.

-- | Arity of function.
arity :: Arity n => n -> Int
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (b, c)) => (a -> b -> c -> d) -> v a -> v b -> v c -> v d
zipWithM_ :: (Vector v a, Vector v b, Vector v c, Monad m, Vector v (m c)) => (a -> b -> m c) -> v a -> v b -> m ()
apply :: (Vector v a, Vector v (a -> b), Vector v b) => v (a -> b) -> v a -> v b
all :: Vector v a => (a -> Bool) -> v a -> Bool
any :: Vector v a => (a -> Bool) -> v a -> Bool
zero :: (Vector v a, Num a) => v a
iifoldl :: Vector v a => ix -> (ix -> ix) -> (b -> ix -> a -> b) -> b -> v a -> b
iifoldM :: (Vector v a, Monad m) => ix -> (ix -> ix) -> (b -> ix -> a -> m b) -> b -> v a -> m b
type N7 = S N6
type N8 = S N7
n1 :: N1
n2 :: N2
n3 :: N3
n4 :: N4
n5 :: N5
n6 :: N6
n7 :: N7
n8 :: N8
vl_1 :: a -> VecList N1 a
vl_2 :: a -> a -> VecList N2 a
vl_3 :: a -> a -> a -> VecList N3 a
vl_4 :: a -> a -> a -> a -> VecList N4 a
sel_2_2 :: VecTuple N2 e -> e
sel_2_1 :: VecTuple N2 e -> e
sel_3_3 :: VecTuple N3 e -> e
sel_3_2 :: VecTuple N3 e -> e
sel_3_1 :: VecTuple N3 e -> e
sel_4_4 :: VecTuple N4 e -> e
sel_4_3 :: VecTuple N4 e -> e
sel_4_2 :: VecTuple N4 e -> e
sel_4_1 :: VecTuple N4 e -> e
sel_5_5 :: VecTuple N5 e -> e
sel_5_4 :: VecTuple N5 e -> e
sel_5_3 :: VecTuple N5 e -> e
sel_5_2 :: VecTuple N5 e -> e
sel_5_1 :: VecTuple N5 e -> e
sel_6_6 :: VecTuple N6 e -> e
sel_6_5 :: VecTuple N6 e -> e
sel_6_4 :: VecTuple N6 e -> e
sel_6_3 :: VecTuple N6 e -> e
sel_6_2 :: VecTuple N6 e -> e
sel_6_1 :: VecTuple N6 e -> e
sel_7_7 :: VecTuple N7 e -> e
sel_7_6 :: VecTuple N7 e -> e
sel_7_5 :: VecTuple N7 e -> e
sel_7_4 :: VecTuple N7 e -> e
sel_7_3 :: VecTuple N7 e -> e
sel_7_2 :: VecTuple N7 e -> e
sel_7_1 :: VecTuple N7 e -> e
sel_8_8 :: VecTuple N8 e -> e
sel_8_7 :: VecTuple N8 e -> e
sel_8_6 :: VecTuple N8 e -> e
sel_8_5 :: VecTuple N8 e -> e
sel_8_4 :: VecTuple N8 e -> e
sel_8_3 :: VecTuple N8 e -> e
sel_8_2 :: VecTuple N8 e -> e
sel_8_1 :: VecTuple N8 e -> e
makeVecTupleInstance :: Arity n => TypeQ -> n -> Q [Dec]

-- | Workaround for slice-wise currined filling functions inlining issues.
--   See comment to <a>CVL</a> for details.
class Arity ar => InlinableArity ar
inlinableZipWith :: (InlinableArity ar, Vector v a, Vector v b, Vector v c, Dim v ~ ar) => (a -> b -> c) -> v a -> v b -> v c
inlinableMap :: (InlinableArity ar, Vector v a, Vector v b, Dim v ~ ar) => (a -> b) -> v a -> v b
makeInlinableArityInstance :: Arity n => TypeQ -> n -> Q [Dec]
instance [overlap ok] (Arity n, NFData e) => NFData (VecList n e)

module Data.Yarr.Utils.Primitive

-- | Mainly used to fight against GHC simplifier, which gives no chance to
--   LLVM to perform Global Value Numbering optimization.
--   
--   Copied from <tt>repa</tt>, see
--   <a>http://hackage.haskell.org/packages/archive/repa/3.2.3.1/doc/html/Data-Array-Repa-Eval.html</a>
class Touchable a
touch :: Touchable a => a -> IO ()

-- | Alias to <tt>(\_ -&gt; return ())</tt>.
noTouch :: a -> IO ()

-- | GHC simplifier tends to float numeric comparsions as high in execution
--   graph as possible, which in conjunction with loop unrolling sometimes
--   leads to dramatic code bloat.
--   
--   I'm not sure <tt>-M</tt> functions work at all, but strict versions
--   defenitely keep comparsions unfloated.
class PrimitiveOrd a
minM :: PrimitiveOrd a => a -> a -> IO a
minM' :: PrimitiveOrd a => a -> a -> IO a
maxM :: PrimitiveOrd a => a -> a -> IO a
maxM' :: PrimitiveOrd a => a -> a -> IO a
clampM :: PrimitiveOrd a => a -> a -> a -> IO a
clampM' :: PrimitiveOrd a => a -> a -> a -> IO a
instance [overlap ok] PrimitiveOrd Float
instance [overlap ok] PrimitiveOrd Double
instance [overlap ok] PrimitiveOrd Word
instance [overlap ok] PrimitiveOrd Char
instance [overlap ok] PrimitiveOrd Int
instance [overlap ok] (Vector v e, Touchable e) => Touchable (v e)
instance [overlap ok] Touchable Double
instance [overlap ok] Touchable Float
instance [overlap ok] Touchable Word64
instance [overlap ok] Touchable Word32
instance [overlap ok] Touchable Word16
instance [overlap ok] Touchable Word8
instance [overlap ok] Touchable Word
instance [overlap ok] Touchable Int64
instance [overlap ok] Touchable Int32
instance [overlap ok] Touchable Int16
instance [overlap ok] Touchable Int8
instance [overlap ok] Touchable Int
instance [overlap ok] Touchable Bool

module Data.Yarr.Shape

-- | Abstracts interval works: <a>Fill</a>s, <a>Walk</a>s.
--   
--   To be passed to functions from <a>Data.Yarr.Utils.Fork</a> module or
--   called directly.
type Work sh a = sh -> sh -> IO a

-- | Curried version of <a>StatefulWalk</a>. Identical to <a>Work</a>,
--   indeed.
type Walk sh a = sh -> sh -> IO a

-- | Alias to frequently used get-write-from-to arguments combo.
--   
--   To be passed as 1st parameter of all <a>Load</a>ing functions from
--   <a>Data.Yarr.Eval</a> module.
type Fill sh a = (sh -> IO a) -> (sh -> a -> IO ()) -> Work sh ()

-- | Generalizes both partially applied left and right folds, as well as
--   walks with mutable state.
--   
--   To be passed to walk runners from <a>Data.Yarr.Walk</a> module.
type StatefulWalk sh a s = IO s -> (sh -> IO a) -> Walk sh s

-- | Generalizes left folds.
--   
--   To be passed to fold combinators from <a>Data.Yarr.Walk</a> module.
type Foldl sh a b = (b -> sh -> a -> IO b) -> StatefulWalk sh a b

-- | Generalizes right folds.
--   
--   To be passed to fold combinators from <a>Data.Yarr.Walk</a> module.
type Foldr sh a b = (sh -> a -> b -> IO b) -> StatefulWalk sh a b

-- | Mainly for internal use. Abstracts top-left -- bottom-right pair of
--   indices.
type Block sh = (sh, sh)

-- | Class for column-major, regular composite array indices.
class (Eq sh, Bounded sh, Show sh, NFData sh) => Shape sh where minus = flip offset intersectBlocks blocks = let ss = map fst blocks es = map snd blocks in (complement ss, intersect es)
zero :: Shape sh => sh
size :: Shape sh => sh -> Int
inc :: Shape sh => sh -> sh
plus :: Shape sh => sh -> sh -> sh
minus :: Shape sh => sh -> sh -> sh
offset :: Shape sh => sh -> sh -> sh
fromLinear :: Shape sh => sh -> Int -> sh
toLinear :: Shape sh => sh -> sh -> Int
intersect :: (Shape sh, Arity n, n ~ S n0) => VecList n sh -> sh
complement :: (Shape sh, Arity n, n ~ S n0) => VecList n sh -> sh
intersectBlocks :: (Shape sh, Arity n, n ~ S n0) => VecList n (Block sh) -> Block sh
blockSize :: Shape sh => Block sh -> Int
insideBlock :: Shape sh => Block sh -> sh -> Bool
makeChunkRange :: Shape sh => Int -> sh -> sh -> (Int -> Block sh)
foldl :: Shape sh => Foldl sh a b
unrolledFoldl :: (Shape sh, Arity uf) => uf -> (a -> IO ()) -> Foldl sh a b
foldr :: Shape sh => Foldr sh a b
unrolledFoldr :: (Shape sh, Arity uf) => uf -> (a -> IO ()) -> Foldr sh a b
fill :: Shape sh => Fill sh a
unrolledFill :: (Shape sh, Arity uf) => uf -> (a -> IO ()) -> Fill sh a

-- | For internal use.
--   
--   <i>TODO:</i> implement for <a>Dim3</a> and merge with <a>Shape</a>
--   class
class (Shape sh, Arity (BorderCount sh)) => BlockShape sh where type family BorderCount sh
clipBlock :: BlockShape sh => Block sh -> Block sh -> VecList (BorderCount sh) (Block sh)
class (Shape sh, Shape lsh) => MultiShape sh lsh | sh -> lsh, lsh -> sh
lower :: MultiShape sh lsh => sh -> lsh
inner :: MultiShape sh lsh => sh -> Int
combine :: MultiShape sh lsh => lsh -> Int -> sh
type Dim1 = Int
type Dim2 = (Int, Int)
type Dim3 = (Int, Int, Int)

-- | 2D-unrolled filling to maximize profit from "Global value numbering"
--   LLVM optimization.
--   
--   Example:
--   
--   <pre>
--   blurred &lt;- <a>compute</a> (<a>loadS</a> (dim2BlockFill <a>n1</a> <a>n4</a> <a>touch</a>)) delayedBlurred
--   </pre>
dim2BlockFill :: (Arity bsx, Arity bsy) => bsx -> bsy -> (a -> IO ()) -> Fill Dim2 a

-- | Mainly used to fight against GHC simplifier, which gives no chance to
--   LLVM to perform Global Value Numbering optimization.
--   
--   Copied from <tt>repa</tt>, see
--   <a>http://hackage.haskell.org/packages/archive/repa/3.2.3.1/doc/html/Data-Array-Repa-Eval.html</a>
class Touchable a
touch :: Touchable a => a -> IO ()

-- | Alias to <tt>(\_ -&gt; return ())</tt>.
noTouch :: a -> IO ()
instance [overlap ok] MultiShape Dim3 Dim2
instance [overlap ok] Shape Dim3
instance [overlap ok] MultiShape Dim2 Dim1
instance [overlap ok] BlockShape Dim2
instance [overlap ok] Shape Dim2
instance [overlap ok] BlockShape Dim1
instance [overlap ok] Shape Dim1

module Data.Yarr.Utils.Fork
makeForkEachSlice :: (Shape sh, Arity n, v ~ VecList n) => Int -> sh -> sh -> v (Work sh a) -> (Int -> IO (v a))
makeForkSlicesOnce :: (Shape sh, Arity n) => Int -> VecList n (sh, sh) -> VecList n (Work sh a) -> (Int -> IO [(Int, a)])
makeFork :: Shape sh => Int -> sh -> sh -> (Work sh a) -> (Int -> IO a)


-- | Core type system
module Data.Yarr.Base

-- | This class generalizes <a>USource</a> and <a>UTarget</a>.
--   
--   Paramenters:
--   
--   <ul>
--   <li><tt>r</tt> - representation,</li>
--   <li><tt>l</tt> - load type,</li>
--   <li><tt>sh</tt> - shape,</li>
--   <li><tt>a</tt> - element type.</li>
--   </ul>
--   
--   Counterpart for arrays of vectors: <a>VecRegular</a>.
class (NFData (UArray r l sh a), Shape sh) => Regular r l sh a where data family UArray r l sh a force arr = arr `deepseq` return ()
extent :: Regular r l sh a => UArray r l sh a -> sh
touchArray :: Regular r l sh a => UArray r l sh a -> IO ()
force :: Regular r l sh a => UArray r l sh a -> IO ()

-- | Class for arrays of vectors.
--   
--   Paramenters:
--   
--   <ul>
--   <li><tt>r</tt> - (entire) representation. Associated array type for
--   this class is <tt><a>UArray</a> r sh (v e)</tt>.</li>
--   <li><tt>slr</tt> - slice representation</li>
--   <li><tt>l</tt> - load type</li>
--   <li><tt>sh</tt> - shape</li>
--   <li><tt>v</tt> - vector type</li>
--   <li><tt>e</tt> - <i>vector</i> (not array) element type. Array element
--   type is entire vector: <tt>(v e)</tt>.</li>
--   </ul>
--   
--   Counterpart for "simple" arrays: <a>Regular</a>.
class (Regular r l sh (v e), Regular slr l sh e, Vector v e) => VecRegular r slr l sh v e | r -> slr
slices :: VecRegular r slr l sh v e => UArray r l sh (v e) -> VecList (Dim v) (UArray slr l sh e)

-- | A class of types that can be fully evaluated.
class NFData a
rnf :: NFData a => a -> ()

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b

-- | Class for column-major, regular composite array indices.
class (Eq sh, Bounded sh, Show sh, NFData sh) => Shape sh where minus = flip offset intersectBlocks blocks = let ss = map fst blocks es = map snd blocks in (complement ss, intersect es)

-- | Size of vector expressed as type-level natural.

-- | Type class for handling <i>n</i>-ary functions.
class Arity n

-- | Newtype wrapper which is used to make <a>Fn</a> injective.
data Fun n a b :: * -> * -> * -> *

-- | Type class for vectors with fixed length.
class Arity (Dim v) => Vector (v :: * -> *) a

-- | Vector based on the lists. Not very useful by itself but is necessary
--   for implementation.
data VecList n a :: * -> * -> *

-- | Class for arrays which could be indexed.
--   
--   It's functions are unsafe: you <i>must</i> call <a>touchArray</a>
--   after the last call. Fortunately, you will hardly ever need to call
--   them manually.
--   
--   Minimum complete defenition: <a>index</a> or <a>linearIndex</a>.
--   
--   Counterpart for arrays of vectors: <a>UVecSource</a>
class Regular r l sh a => USource r l sh a where index arr sh = linearIndex arr $ toLinear (extent arr) sh linearIndex arr i = index arr $ fromLinear (extent arr) i
index :: USource r l sh a => UArray r l sh a -> sh -> IO a
linearIndex :: USource r l sh a => UArray r l sh a -> Int -> IO a

-- | Class for arrays of vectors which could be indexed. The class doesn't
--   need to define functions, it just gathers it's dependencies.
--   
--   Counterpart for "simple" arrays: <a>USource</a>.
class (VecRegular r slr l sh v e, USource r l sh (v e), USource slr l sh e) => UVecSource r slr l sh v e

-- | Class for mutable arrays.
--   
--   Just like for <a>USource</a>, it's function are unsafe and require
--   calling <a>touchArray</a> after the last call.
--   
--   Minimum complete defenition: <a>write</a> or <a>linearWrite</a>.
--   
--   Counterpart for arrays of vectors: <a>UVecTarget</a>
class Regular tr tl sh a => UTarget tr tl sh a where write tarr sh = linearWrite tarr $ toLinear (extent tarr) sh linearWrite tarr i = write tarr $ fromLinear (extent tarr) i
write :: UTarget tr tl sh a => UArray tr tl sh a -> sh -> a -> IO ()
linearWrite :: UTarget tr tl sh a => UArray tr tl sh a -> Int -> a -> IO ()

-- | Class for arrays which could be created. It combines a pair of
--   representations: freezed and mutable (raw). This segregation is lifted
--   from Boxed representation and, in the final, from GHC system of
--   primitive arrays.
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>r</tt> - freezed array representation.</li>
--   <li><tt>mr</tt> - mutable, raw array representation</li>
--   <li><tt>l</tt> - load type index, common for both representations</li>
--   <li><tt>sh</tt> - shape of arrays</li>
--   <li><tt>a</tt> - element type</li>
--   </ul>
class (USource r l sh a, UTarget mr l sh a) => Manifest r mr l sh a | r -> mr, mr -> r
new :: Manifest r mr l sh a => sh -> IO (UArray mr l sh a)
freeze :: Manifest r mr l sh a => UArray mr l sh a -> IO (UArray r l sh a)
thaw :: Manifest r mr l sh a => UArray r l sh a -> IO (UArray mr l sh a)

-- | Class for mutable arrays of vectors. The class doesn't need to define
--   functions, it just gathers it's dependencies.
--   
--   Counterpart for "simple" arrays: <a>UTarget</a>.
class (VecRegular tr tslr tl sh v e, UTarget tr tl sh (v e), UTarget tslr tl sh e) => UVecTarget tr tslr tl sh v e

-- | Type level fixation of preferred work (load, fold, etc.) index type of
--   the array load type.
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>l</tt> - load type index</li>
--   <li><tt>sh</tt> - shape of arrays</li>
--   <li><tt>i</tt> - preferred work index, <tt>Int</tt> or <tt>sh</tt>
--   itself</li>
--   </ul>
class WorkIndex sh i => PreferredWorkIndex l sh i | l sh -> i

-- | Internal implementation class. Generalizes <tt>linear-</tt> and simple
--   indexing and writing function in <a>USource</a> and <a>UTarget</a>
--   classes.
class (Shape sh, Shape i) => WorkIndex sh i where gsize = toWork . extent
toWork :: WorkIndex sh i => sh -> i
gindex :: (WorkIndex sh i, USource r l sh a) => UArray r l sh a -> i -> IO a
gwrite :: (WorkIndex sh i, UTarget tr tl sh a) => UArray tr tl sh a -> i -> a -> IO ()
gsize :: (WorkIndex sh i, USource r l sh a) => UArray r l sh a -> i
instance [overlap ok] WorkIndex Dim3 Int
instance [overlap ok] WorkIndex Dim2 Int
instance [overlap ok] Shape sh => WorkIndex sh sh


-- | <a>Load</a>ing and computing arrays
module Data.Yarr.Eval

-- | There are 2 common ways to parameterize parallelism: a) to say "split
--   this work between <tt>n</tt> threads" or b) to say "split this work
--   between maximum reasonable number of threads", that is
--   <i>capabilities</i>. Since <a>getNumCapabilities</a> function is
--   monadic, we need always pass <tt>IO Int</tt> as thread number
--   parameter in order not to multiply number of functions in this module
--   (there are already too many).
type Threads = IO Int

-- | Alias to <a>getNumCapabilities</a>.
caps :: Threads

-- | Alias to <a>return</a>.
threads :: Int -> Threads

-- | Alias to frequently used get-write-from-to arguments combo.
--   
--   To be passed as 1st parameter of all <a>Load</a>ing functions from
--   <a>Data.Yarr.Eval</a> module.
type Fill sh a = (sh -> IO a) -> (sh -> a -> IO ()) -> Work sh ()

-- | This class abstracts pair of array types, which could be loaded one to
--   another.
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>r</tt> - source representation. Instance of <a>USource</a>
--   class. Typically one of fused representations: <a>D</a>,
--   <tt>(<a>SE</a> <a>D</a>)</tt> or <a>CV</a>.</li>
--   <li><tt>l</tt> - source load type</li>
--   <li><tt>tr</tt> - target representation. Instance of <a>UTarget</a>
--   class.</li>
--   <li><tt>tl</tt> - target load type</li>
--   <li><tt>sh</tt> - shape of arrays</li>
--   <li><tt>a</tt> - array element type</li>
--   </ul>
--   
--   Counterpart for arrays of vectors: <a>VecLoad</a>.
--   
--   <i>TODO:</i> this class seems to be overengineered, normally it should
--   have only 3 parameters: <tt>Load l tl sh</tt>. But Convoluted
--   (<a>CV</a>) representation is tightly connected with it's load type.
class (USource r l sh a, UTarget tr tl sh a, WorkIndex sh (LoadIndex l tl sh)) => Load r l tr tl sh a where type family LoadIndex l tl sh loadP fill threads arr tarr = do { force arr; force tarr; !ts <- threads; parallel_ ts $ makeFork ts zero (gsize arr) (fill (gindex arr) (gwrite tarr)); touchArray arr; touchArray tarr } loadS fill arr tarr = do { force arr; force tarr; fill (gindex arr) (gwrite tarr) zero (gsize arr); touchArray arr; touchArray tarr }
loadP :: Load r l tr tl sh a => Fill (LoadIndex l tl sh) a -> Threads -> UArray r l sh a -> UArray tr tl sh a -> IO ()
loadS :: Load r l tr tl sh a => Fill (LoadIndex l tl sh) a -> UArray r l sh a -> UArray tr tl sh a -> IO ()

-- | Class abstracts pair of arrays which could be loaded in just specified
--   range of indices.
--   
--   "Range" is a multidimensional segment: segment for <a>Dim1</a> arrays,
--   square for <a>Dim2</a> arrays and cube for <a>Dim3</a>. Thus, it is
--   specified by pair of indices: "top-left" (minimum is <a>zero</a>) and
--   "bottom-right" (maximum is <tt>(<a>entire</a> arr tarr)</tt>) corners.
class Load r l tr tl sh a => RangeLoad r l tr tl sh a where rangeLoadP fill threads arr tarr start end = do { force arr; force tarr; !ts <- threads; parallel_ ts $ makeFork ts start end (fill (index arr) (write tarr)); touchArray arr; touchArray tarr } rangeLoadS fill arr tarr start end = do { force arr; force tarr; fill (index arr) (write tarr) start end; touchArray arr; touchArray tarr }
rangeLoadP :: RangeLoad r l tr tl sh a => Fill sh a -> Threads -> UArray r l sh a -> UArray tr tl sh a -> sh -> sh -> IO ()
rangeLoadS :: RangeLoad r l tr tl sh a => Fill sh a -> UArray r l sh a -> UArray tr tl sh a -> sh -> sh -> IO ()

-- | Class abstracts <i>separated in time and space</i> loading
--   <a>slices</a> of one array type to another. Result of running
--   functions with <tt>-Slices-</tt> infix <i>is always identical</i> to
--   result of running corresponding function from <a>Load</a> class.
--   <a>VecLoad</a> and <a>RangeVecLoad</a> are just about performance. If
--   target representation is separate (ex. <tt>(<a>SE</a> <a>F</a>)</tt>),
--   using <a>loadSlicesP</a> may be faster than <a>loadP</a> because of
--   per-thread memory locality.
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>r</tt> - source representation</li>
--   <li><tt>slr</tt> - source slice representation</li>
--   <li><tt>l</tt> - source load type</li>
--   <li><tt>tr</tt> - target representation</li>
--   <li><tt>tslr</tt> - target slice representation</li>
--   <li><tt>tl</tt> - target load type</li>
--   <li><tt>sh</tt> - shape of arrays</li>
--   <li><tt>v</tt> - source vector type</li>
--   <li><tt>v2</tt> - target vector type</li>
--   <li><tt>e</tt> - vector element type, common for source and target
--   arrays</li>
--   </ul>
class (UVecSource r slr l sh v e, UVecTarget tr tslr tl sh v2 e, Load slr l tslr tl sh e, Dim v ~ Dim v2) => VecLoad r slr l tr tslr tl sh v v2 e where loadSlicesP fill threads arr tarr = do { force arr; force tarr; !ts <- threads; parallel_ ts $ makeForkSlicesOnce ts (replicate (zero, gsize arr)) (zipWith (\ sl tsl -> fill (gindex sl) (gwrite tsl)) (slices arr) (slices tarr)); touchArray arr; touchArray tarr } loadSlicesS fill arr tarr = do { force arr; force tarr; zipWithM_ (loadS fill) (slices arr) (slices tarr); touchArray arr; touchArray tarr }
loadSlicesP :: VecLoad r slr l tr tslr tl sh v v2 e => Fill (LoadIndex l tl sh) e -> Threads -> UArray r l sh (v e) -> UArray tr tl sh (v2 e) -> IO ()
loadSlicesS :: VecLoad r slr l tr tslr tl sh v v2 e => Fill (LoadIndex l tl sh) e -> UArray r l sh (v e) -> UArray tr tl sh (v2 e) -> IO ()

-- | This class extends <a>VecLoad</a> just like <a>RangeLoad</a> extends
--   <a>Load</a>. It abstracts slice-wise loading from one array type to
--   another in specified range.
class (VecLoad r slr l tr tslr tl sh v v2 e, RangeLoad slr l tslr tl sh e) => RangeVecLoad r slr l tr tslr tl sh v v2 e where rangeLoadSlicesP fill threads arr tarr start end = do { force arr; force tarr; !ts <- threads; parallel_ ts $ makeForkSlicesOnce ts (replicate (start, end)) (zipWith (\ sl tsl -> fill (index sl) (write tsl)) (slices arr) (slices tarr)); touchArray arr; touchArray tarr } rangeLoadSlicesS fill arr tarr start end = do { force arr; force tarr; zipWithM_ (\ sl tsl -> rangeLoadS fill sl tsl start end) (slices arr) (slices tarr); touchArray arr; touchArray tarr }
rangeLoadSlicesP :: RangeVecLoad r slr l tr tslr tl sh v v2 e => Fill sh e -> Threads -> UArray r l sh (v e) -> UArray tr tl sh (v2 e) -> sh -> sh -> IO ()
rangeLoadSlicesS :: RangeVecLoad r slr l tr tslr tl sh v v2 e => Fill sh e -> UArray r l sh (v e) -> UArray tr tl sh (v2 e) -> sh -> sh -> IO ()

-- | <i>O(n)</i> This function simplifies the most common way of loading
--   arrays.
--   
--   Instead of
--   
--   <pre>
--   mTarget &lt;- <a>new</a> (extent source)
--   <a>loadP</a> <a>fill</a> <a>caps</a> source mTarget
--   target &lt;- <a>freeze</a> mTarget
--   </pre>
--   
--   You can write just
--   
--   <pre>
--   target &lt;- compute (<a>loadP</a> <a>fill</a> <a>caps</a>) source
--   </pre>
compute :: (USource r l sh a, Manifest tr mtr tl sh b) => (UArray r l sh a -> UArray mtr tl sh b -> IO ()) -> UArray r l sh a -> IO (UArray tr tl sh b)

-- | Most common parallel use case of <a>compute</a>.
--   
--   <pre>
--   dComputeP = <a>compute</a> (<a>loadP</a> <a>fill</a> <a>caps</a>)
--   </pre>
dComputeP :: (USource r l sh a, Manifest tr mtr tl sh a, Load r l mtr tl sh a) => UArray r l sh a -> IO (UArray tr tl sh a)

-- | Most common sequential use case of <a>compute</a>.
--   
--   <pre>
--   dComputeS = <a>compute</a> (<a>loadS</a> <a>fill</a>)
--   </pre>
dComputeS :: (USource r l sh a, Manifest tr mtr tl sh a, Load r l mtr tl sh a) => UArray r l sh a -> IO (UArray tr tl sh a)

-- | Linear load type index. <a>UArray</a>s with <a>L</a> load type index
--   define <a>linearIndex</a> and <a>linearWrite</a> and leave
--   <a>index</a> and <a>write</a> functions defined by default.
data L

-- | General shape load type index. <a>UArray</a>s with <a>SH</a> load type
--   index specialize <a>index</a> and <a>write</a> and leave
--   <a>linearIndex</a> and <a>linearWrite</a> functions defined by
--   default.
--   
--   Type-level distinction between <a>L</a>inear and <a>SH</a>aped arrays
--   is aimed to avoid integral division operations while looping through
--   composite (<a>Dim2</a>, <a>Dim3</a>) indices.
--   
--   Integral division is very expensive operation even on modern CPUs.
data SH

-- | Determines maximum common range of 2 arrays - <a>intersect</a>ion of
--   their <a>extent</a>s.
entire :: (Regular r l sh a, Regular r2 l2 sh b) => UArray r l sh a -> UArray r2 l2 sh b -> sh
instance [overlap ok] (VecLoad r slr SH tr tslr SH sh v v2 e, RangeLoad slr SH tslr SH sh e) => RangeVecLoad r slr SH tr tslr SH sh v v2 e
instance [overlap ok] (UVecSource r slr SH sh v e, UVecTarget tr tslr SH sh v2 e, Load slr SH tslr SH sh e, Dim v ~ Dim v2) => VecLoad r slr SH tr tslr SH sh v v2 e
instance [overlap ok] Load r SH tr SH sh a => RangeLoad r SH tr SH sh a
instance [overlap ok] (USource r SH sh a, UTarget tr SH sh a) => Load r SH tr SH sh a
instance [overlap ok] (VecLoad r slr L tr tslr SH sh v v2 e, RangeLoad slr L tslr SH sh e) => RangeVecLoad r slr L tr tslr SH sh v v2 e
instance [overlap ok] (UVecSource r slr L sh v e, UVecTarget tr tslr SH sh v2 e, Load slr L tslr SH sh e, Dim v ~ Dim v2) => VecLoad r slr L tr tslr SH sh v v2 e
instance [overlap ok] Load r L tr SH sh a => RangeLoad r L tr SH sh a
instance [overlap ok] (USource r L sh a, UTarget tr SH sh a) => Load r L tr SH sh a
instance [overlap ok] (VecLoad r slr SH tr tslr L sh v v2 e, RangeLoad slr SH tslr L sh e) => RangeVecLoad r slr SH tr tslr L sh v v2 e
instance [overlap ok] (UVecSource r slr SH sh v e, UVecTarget tr tslr L sh v2 e, Load slr SH tslr L sh e, Dim v ~ Dim v2) => VecLoad r slr SH tr tslr L sh v v2 e
instance [overlap ok] Load r SH tr L sh a => RangeLoad r SH tr L sh a
instance [overlap ok] (USource r SH sh a, UTarget tr L sh a) => Load r SH tr L sh a
instance [overlap ok] Shape sh => PreferredWorkIndex SH sh sh
instance [overlap ok] (VecLoad r slr L tr tslr L sh v v2 e, RangeLoad slr L tslr L sh e) => RangeVecLoad r slr L tr tslr L sh v v2 e
instance [overlap ok] (UVecSource r slr L sh v e, UVecTarget tr tslr L sh v2 e, Load slr L tslr L sh e, Dim v ~ Dim v2) => VecLoad r slr L tr tslr L sh v v2 e
instance [overlap ok] Load r L tr L sh a => RangeLoad r L tr L sh a
instance [overlap ok] (USource r L sh a, UTarget tr L sh a, WorkIndex sh Int) => Load r L tr L sh a
instance [overlap ok] WorkIndex sh Int => PreferredWorkIndex L sh Int


-- | Fusion type system. Use re-exported in <a>Data.Yarr.Flow</a>
--   functions.
module Data.Yarr.Fusion

-- | Generalized, non-injective version of <a>DefaultFusion</a>. Used
--   internally.
--   
--   Minimum complete defenition: <a>fmapM</a>, <a>fzip2M</a>,
--   <a>fzip3M</a> and <a>fzipM</a>.
--   
--   The class doesn't have vector counterpart, it's role play top-level
--   functions from <a>Data.Yarr.Repr.Separate</a> module.
class Fusion r fr l sh where fmap f = fmapM (return . f) fzip2 f = fzip2M (\ x y -> return (f x y)) fzip3 f = fzip3M (\ x y z -> return (f x y z)) fzip fun arrs = let funM = fmap return fun in fzipM funM arrs
fmap :: (Fusion r fr l sh, USource r l sh a, USource fr l sh b) => (a -> b) -> UArray r l sh a -> UArray fr l sh b
fmapM :: (Fusion r fr l sh, USource r l sh a, USource fr l sh b) => (a -> IO b) -> UArray r l sh a -> UArray fr l sh b
fzip2 :: (Fusion r fr l sh, USource r l sh a, USource r l sh b, USource fr l sh c) => (a -> b -> c) -> UArray r l sh a -> UArray r l sh b -> UArray fr l sh c
fzip2M :: (Fusion r fr l sh, USource r l sh a, USource r l sh b, USource fr l sh c) => (a -> b -> IO c) -> UArray r l sh a -> UArray r l sh b -> UArray fr l sh c
fzip3 :: (Fusion r fr l sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr l sh d) => (a -> b -> c -> d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr l sh d
fzip3M :: (Fusion r fr l sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr l sh d) => (a -> b -> c -> IO d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr l sh d
fzip :: (Fusion r fr l sh, USource r l sh a, USource fr l sh b, Arity n, n ~ S n0) => Fun n a b -> VecList n (UArray r l sh a) -> UArray fr l sh b
fzipM :: (Fusion r fr l sh, USource r l sh a, USource fr l sh b, Arity n, n ~ S n0) => Fun n a (IO b) -> VecList n (UArray r l sh a) -> UArray fr l sh b

-- | This class abstracts pair of array types, which could be (preferably
--   should be) mapped <i>(fused)</i> one to another. Injective version of
--   <a>Fusion</a> class.
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>r</tt> - source array representation. It determines result
--   representation.</li>
--   <li><tt>fr</tt> (fused repr) - result (fused) array representation.
--   Result array isn't indeed presented in memory, finally it should be
--   <a>compute</a>d or <a>Load</a>ed to <a>Manifest</a>
--   representation.</li>
--   <li><tt>l</tt> - load type, common for source and fused arrays</li>
--   <li><tt>sh</tt> - shape of arrays</li>
--   </ul>
--   
--   All functions are already defined, using non-injective versions from
--   <a>Fusion</a> class.
--   
--   The class doesn't have vector counterpart, it's role play top-level
--   functions from <a>Data.Yarr.Repr.Separate</a> module.
class Fusion r fr l sh => DefaultFusion r fr l sh | r -> fr where dmap = fmap dmapM = fmapM dzip2 = fzip2 dzip2M = fzip2M dzip3 = fzip3 dzip3M = fzip3M dzip = fzip dzipM = fzipM
dmap :: (DefaultFusion r fr l sh, USource r l sh a, USource fr l sh b) => (a -> b) -> UArray r l sh a -> UArray fr l sh b
dmapM :: (DefaultFusion r fr l sh, USource r l sh a, USource fr l sh b) => (a -> IO b) -> UArray r l sh a -> UArray fr l sh b
dzip2 :: (DefaultFusion r fr l sh, USource r l sh a, USource r l sh b, USource fr l sh c) => (a -> b -> c) -> UArray r l sh a -> UArray r l sh b -> UArray fr l sh c
dzip2M :: (DefaultFusion r fr l sh, USource r l sh a, USource r l sh b, USource fr l sh c) => (a -> b -> IO c) -> UArray r l sh a -> UArray r l sh b -> UArray fr l sh c
dzip3 :: (DefaultFusion r fr l sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr l sh d) => (a -> b -> c -> d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr l sh d
dzip3M :: (DefaultFusion r fr l sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr l sh d) => (a -> b -> c -> IO d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr l sh d
dzip :: (DefaultFusion r fr l sh, USource r l sh a, USource fr l sh b, Arity n, n ~ S n0) => Fun n a b -> VecList n (UArray r l sh a) -> UArray fr l sh b
dzipM :: (DefaultFusion r fr l sh, USource r l sh a, USource fr l sh b, Arity n, n ~ S n0) => Fun n a (IO b) -> VecList n (UArray r l sh a) -> UArray fr l sh b

-- | Like <a>Fusion</a>, for mappings/zippings with array index. Used to
--   define functions in <a>DefaultIFusion</a>.
--   
--   Minimum complete defenition: <a>fimapM</a>, <a>fizip2M</a>,
--   <a>fizip3M</a> and <a>fizipM</a>.
--   
--   The class doesn't have vector counterpart.
class PreferredWorkIndex fl sh sh => IFusion r l fr fl sh | r l fr -> fl where fimap f = fimapM (\ i x -> return (f i x)) fizip2 f = fizip2M (\ i x y -> return (f i x y)) fizip3 f = fizip3M (\ i x y z -> return (f i x y z)) fizip fun arrs = fizipM funM arrs where funM i = fmap return (fun i)
fimap :: (IFusion r l fr fl sh, USource r l sh a, USource fr fl sh b) => (sh -> a -> b) -> UArray r l sh a -> UArray fr fl sh b
fimapM :: (IFusion r l fr fl sh, USource r l sh a, USource fr fl sh b) => (sh -> a -> IO b) -> UArray r l sh a -> UArray fr fl sh b
fizip2 :: (IFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource fr fl sh c) => (sh -> a -> b -> c) -> UArray r l sh a -> UArray r l sh b -> UArray fr fl sh c
fizip2M :: (IFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource fr fl sh c) => (sh -> a -> b -> IO c) -> UArray r l sh a -> UArray r l sh b -> UArray fr fl sh c
fizip3 :: (IFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr fl sh d) => (sh -> a -> b -> c -> d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr fl sh d
fizip3M :: (IFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr fl sh d) => (sh -> a -> b -> c -> IO d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr fl sh d
fizip :: (IFusion r l fr fl sh, USource r l sh a, USource fr fl sh b, Arity n, n ~ S n0) => (sh -> Fun n a b) -> VecList n (UArray r l sh a) -> UArray fr fl sh b
fizipM :: (IFusion r l fr fl sh, USource r l sh a, USource fr fl sh b, Arity n, n ~ S n0) => (sh -> Fun n a (IO b)) -> VecList n (UArray r l sh a) -> UArray fr fl sh b

-- | Like <a>DefaultFusion</a>, this class abstracts the pair array types,
--   which should be fused one to another on maps and zips which accept
--   index of element (several elements for zips) in array (arrays).
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>r</tt> - source array representation. Determines result
--   representation.</li>
--   <li><tt>l</tt> - source load type</li>
--   <li><tt>fr</tt> (fused repr) - result (fused) array representation.
--   Result array isn't indeed presented in memory, finally it should be
--   <a>compute</a>d or <a>Load</a>ed to <a>Manifest</a>
--   representation.</li>
--   <li><tt>fl</tt> - result, "shaped" load type</li>
--   <li><tt>sh</tt> - shape of arrays</li>
--   </ul>
--   
--   All functions are already defined, using non-injective versions from
--   <a>IFusion</a> class.
--   
--   The class doesn't have vector counterpart.
class IFusion r l fr fl sh => DefaultIFusion r l fr fl sh | r l -> fr where imap = fimap imapM = fimapM izip2 = fizip2 izip2M = fizip2M izip3 = fizip3 izip3M = fizip3M izip = fizip izipM = fizipM
imap :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource fr fl sh b) => (sh -> a -> b) -> UArray r l sh a -> UArray fr fl sh b
imapM :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource fr fl sh b) => (sh -> a -> IO b) -> UArray r l sh a -> UArray fr fl sh b
izip2 :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource fr fl sh c) => (sh -> a -> b -> c) -> UArray r l sh a -> UArray r l sh b -> UArray fr fl sh c
izip2M :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource fr fl sh c) => (sh -> a -> b -> IO c) -> UArray r l sh a -> UArray r l sh b -> UArray fr fl sh c
izip3 :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr fl sh d) => (sh -> a -> b -> c -> d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr fl sh d
izip3M :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr fl sh d) => (sh -> a -> b -> c -> IO d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr fl sh d
izip :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource fr fl sh b, Arity n, n ~ S n0) => (sh -> Fun n a b) -> VecList n (UArray r l sh a) -> UArray fr fl sh b
izipM :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource fr fl sh b, Arity n, n ~ S n0) => (sh -> Fun n a (IO b)) -> VecList n (UArray r l sh a) -> UArray fr fl sh b
instance [overlap ok] IFusion r l fr l sh => Fusion r fr l sh

module Data.Yarr.Repr.Delayed

-- | Delayed representation is a wrapper for arbitrary indexing function.
--   
--   <tt><a>UArray</a> D <a>L</a> sh a</tt> instance holds linear getter
--   (<tt>(Int -&gt; IO a)</tt>), and <tt><a>UArray</a> D <a>SH</a> sh
--   a</tt> - shaped, "true" <tt>(sh -&gt; IO a)</tt> index, respectively.
--   
--   <tt>D</tt>elayed arrays are most common recipients for fusion
--   operations.
data D

-- | In opposite to <a>D</a>elayed (source) Delayed Target holds abstract
--   <i>writing</i> function: <tt>(sh -&gt; a -&gt; IO ())</tt>. It may be
--   used to perform arbitrarily tricky things, because no one obliges you
--   to indeed write an element inside wrapped function.
data DT

-- | Linear load type index. <a>UArray</a>s with <a>L</a> load type index
--   define <a>linearIndex</a> and <a>linearWrite</a> and leave
--   <a>index</a> and <a>write</a> functions defined by default.
data L

-- | General shape load type index. <a>UArray</a>s with <a>SH</a> load type
--   index specialize <a>index</a> and <a>write</a> and leave
--   <a>linearIndex</a> and <a>linearWrite</a> functions defined by
--   default.
--   
--   Type-level distinction between <a>L</a>inear and <a>SH</a>aped arrays
--   is aimed to avoid integral division operations while looping through
--   composite (<a>Dim2</a>, <a>Dim3</a>) indices.
--   
--   Integral division is very expensive operation even on modern CPUs.
data SH

-- | Wrap indexing function into delayed representation.
--   
--   Use this function carefully, don't implement through it something that
--   has specialized implementation in the library (mapping, zipping, etc).
--   
--   Suitable to obtain arrays of constant element, of indices
--   (<tt>fromFunction sh <a>return</a></tt>), and so on.
fromFunction :: Shape sh => sh -> (sh -> IO a) -> UArray D SH sh a
fromLinearFunction :: Shape sh => sh -> (Int -> IO a) -> UArray D L sh a

-- | Load type preserving wrapping arbirtary array into <a>D</a>elayed
--   representation.
delay :: (USource r l sh a, USource D l sh a, Fusion r D l sh) => UArray r l sh a -> UArray D l sh a

-- | Wraps <tt>(<a>index</a> arr)</tt> into Delayed representation.
--   Normally you shouldn't need to use this function. It may be dangerous
--   for performance, because preferred <a>Load</a>ing type of source array
--   is ignored.
delayShaped :: USource r l sh a => UArray r l sh a -> UArray D SH sh a
delayLinear :: USource r l sh a => UArray r l sh a -> UArray D L sh a
linearConst :: Shape sh => sh -> a -> UArray D L sh a
shapedConst :: Shape sh => sh -> a -> UArray D SH sh a
instance [overlap ok] Shape sh => UTarget DT SH sh a
instance [overlap ok] Shape sh => NFData (UArray DT SH sh a)
instance [overlap ok] Shape sh => Regular DT SH sh a
instance [overlap ok] Shape sh => DefaultFusion D D SH sh
instance [overlap ok] Shape sh => DefaultIFusion D SH D SH sh
instance [overlap ok] Shape sh => DefaultIFusion D L D SH sh
instance [overlap ok] Shape sh => IFusion r l D SH sh
instance [overlap ok] (Shape sh, Vector v e) => UVecSource D D SH sh v e
instance [overlap ok] (Shape sh, Vector v e) => VecRegular D D SH sh v e
instance [overlap ok] Shape sh => USource D SH sh a
instance [overlap ok] Shape sh => NFData (UArray D SH sh a)
instance [overlap ok] Shape sh => Regular D SH sh a
instance [overlap ok] DefaultFusion D D L sh
instance [overlap ok] Fusion r D L sh
instance [overlap ok] (Shape sh, Vector v e) => UVecSource D D L sh v e
instance [overlap ok] (Shape sh, Vector v e) => VecRegular D D L sh v e
instance [overlap ok] Shape sh => USource D L sh a
instance [overlap ok] Shape sh => NFData (UArray D L sh a)
instance [overlap ok] Shape sh => Regular D L sh a

module Data.Yarr.Repr.Separate

-- | SEparate meta array representation. Internally SEparate arrays hold
--   vector of it's slices (so, <a>slices</a> is just getter for them).
--   
--   Mostly useful for:
--   
--   <ul>
--   <li>Separate in memory manifest <a>F</a>oreign arrays ("Unboxed"
--   arrays in <tt>vector</tt>/<tt>repa</tt> libraries terms).</li>
--   <li>Element-wise vector array fusion (see group of <a>dmapElems</a>
--   functions).</li>
--   </ul>
data SE r

-- | <i>O(1)</i> Glues several arrays of the same type into one separate
--   array of vectors. All source arrays must be of the same extent.
--   
--   Example:
--   
--   <pre>
--   let separateCoords = fromSlices (<a>vl_3</a> xs ys zs)
--   </pre>
fromSlices :: (Regular r l sh e, Vector v e, Dim v ~ S n0) => VecList (Dim v) (UArray r l sh e) -> UArray (SE r) l sh (v e)

-- | <i>O(depends on mapper function)</i> Maps slices of separate array
--   "entirely".
--   
--   This function is useful when operation over slices is not element-wise
--   (in that case you should use <a>mapElems</a>):
--   
--   <pre>
--   let blurredImage = unsafeMapSlices blur image
--   </pre>
--   
--   The function is unsafe because it doesn't check that slice mapper
--   translates extents uniformly (though it is pure).
unsafeMapSlices :: (USource r l sh a, Vector v a, USource r2 l2 sh2 b, Vector v b, Dim v ~ S n0) => (UArray r l sh a -> UArray r2 l2 sh2 b) -> UArray (SE r) l sh (v a) -> UArray (SE r2) l2 sh2 (v b)

-- | <i>O(0)</i> Converts separate vector between vector types of the same
--   arity.
--   
--   Example:
--   
--   <pre>
--   -- floatPairs :: <a>UArray</a> (<a>SE</a> <a>F</a>) <a>Dim1</a> (<a>VecList</a> <a>N2</a> Float)
--   let cs :: <a>UArray</a> (<a>SE</a> <a>F</a>) <a>Dim1</a> (<a>Complex</a> Float)
--       cs = convert floatPairs
--   </pre>
convert :: (Regular r l sh e, Vector v e, Vector v2 e, Dim v ~ Dim v2) => UArray (SE r) l sh (v e) -> UArray (SE r) l sh (v2 e)

-- | <i>O(1)</i> Injective element-wise fusion (mapping).
--   
--   Example:
--   
--   <pre>
--   let domainHSVImage =
--           dmapElems (<a>vl_3</a> (* 360) (* 100) (* 100))
--                     normedHSVImage
--   </pre>
--   
--   Also, used internally to define <a>mapElems</a> function.
dmapElems :: (VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh, Vector v2 b, Dim v ~ Dim v2) => VecList (Dim v) (a -> b) -> UArray r l sh (v a) -> UArray (SE fslr) l sh (v2 b)

-- | <i>O(1)</i> Monadic vesion of <a>dmapElems</a> function.
dmapElemsM :: (VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh, Vector v2 b, Dim v ~ Dim v2) => VecList (Dim v) (a -> IO b) -> UArray r l sh (v a) -> UArray (SE fslr) l sh (v2 b)
dzipElems2 :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, USource fslr l sh c, DefaultFusion slr fslr l sh, Vector v c) => VecList (Dim v) (a -> b -> c) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray (SE fslr) l sh (v c)
dzipElems2M :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, USource fslr l sh c, DefaultFusion slr fslr l sh, Vector v c) => VecList (Dim v) (a -> b -> IO c) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray (SE fslr) l sh (v c)
dzipElems3 :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, VecRegular r slr l sh v c, USource slr l sh c, USource fslr l sh d, DefaultFusion slr fslr l sh, Vector v d) => VecList (Dim v) (a -> b -> c -> d) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray r l sh (v c) -> UArray (SE fslr) l sh (v d)
dzipElems3M :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, VecRegular r slr l sh v c, USource slr l sh c, USource fslr l sh d, DefaultFusion slr fslr l sh, Vector v d) => VecList (Dim v) (a -> b -> c -> IO d) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray r l sh (v c) -> UArray (SE fslr) l sh (v d)

-- | <i>O(1)</i> Generalized element-wise zipping of several arrays of
--   vectors.
dzipElems :: (Vector v2 b, Arity m, m ~ S m0, VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh) => VecList (Dim v2) (Fun m a b) -> VecList m (UArray r l sh (v a)) -> UArray (SE fslr) l sh (v2 b)

-- | <i>O(1)</i> Generalized monadic element-wise zipping of several arrays
--   of vectors
dzipElemsM :: (Vector v2 b, Arity m, m ~ S m0, VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh) => VecList (Dim v2) (Fun m a (IO b)) -> VecList m (UArray r l sh (v a)) -> UArray (SE fslr) l sh (v2 b)

-- | Group of <tt>f-...-Elems-</tt> functions is used internally to define
--   <tt>d-...-Elems-</tt> functions.
fmapElems :: (VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, Fusion slr fslr l sh, Vector v2 b, Dim v ~ Dim v2) => VecList (Dim v) (a -> b) -> UArray r l sh (v a) -> UArray (SE fslr) l sh (v2 b)
fmapElemsM :: (VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, Fusion slr fslr l sh, Vector v2 b, Dim v ~ Dim v2) => VecList (Dim v) (a -> IO b) -> UArray r l sh (v a) -> UArray (SE fslr) l sh (v2 b)
fzipElems2 :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, USource fslr l sh c, Fusion slr fslr l sh, Vector v c) => VecList (Dim v) (a -> b -> c) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray (SE fslr) l sh (v c)
fzipElems2M :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, USource fslr l sh c, Fusion slr fslr l sh, Vector v c) => VecList (Dim v) (a -> b -> IO c) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray (SE fslr) l sh (v c)
fzipElems3 :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, VecRegular r slr l sh v c, USource slr l sh c, USource fslr l sh d, Fusion slr fslr l sh, Vector v d) => VecList (Dim v) (a -> b -> c -> d) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray r l sh (v c) -> UArray (SE fslr) l sh (v d)
fzipElems3M :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, VecRegular r slr l sh v c, USource slr l sh c, USource fslr l sh d, Fusion slr fslr l sh, Vector v d) => VecList (Dim v) (a -> b -> c -> IO d) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray r l sh (v c) -> UArray (SE fslr) l sh (v d)
fzipElems :: (Vector v2 b, Arity m, m ~ S m0, VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, Fusion slr fslr l sh) => VecList (Dim v2) (Fun m a b) -> VecList m (UArray r l sh (v a)) -> UArray (SE fslr) l sh (v2 b)
fzipElemsM :: (Vector v2 b, Arity m, m ~ S m0, VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, Fusion slr fslr l sh) => VecList (Dim v2) (Fun m a (IO b)) -> VecList m (UArray r l sh (v a)) -> UArray (SE fslr) l sh (v2 b)
instance [overlap ok] (UTarget tr tl sh e, Vector v e) => UVecTarget (SE tr) tr tl sh v e
instance [overlap ok] (Manifest r mr l sh e, Vector v e) => Manifest (SE r) (SE mr) l sh (v e)
instance [overlap ok] (UTarget tr tl sh e, Vector v e) => UTarget (SE tr) tl sh (v e)
instance [overlap ok] (DefaultIFusion r l D SH sh, IFusion (SE r) l D SH sh) => DefaultIFusion (SE r) l D SH sh
instance [overlap ok] (DefaultFusion r D l sh, Fusion (SE r) D l sh) => DefaultFusion (SE r) D l sh
instance [overlap ok] (USource r l sh e, Vector v e) => UVecSource (SE r) r l sh v e
instance [overlap ok] (USource r l sh e, Vector v e) => USource (SE r) l sh (v e)
instance [overlap ok] (Regular r l sh e, Shape sh, Vector v e) => VecRegular (SE r) r l sh v e
instance [overlap ok] (NFData (UArray r l sh e), Shape sh, Vector v e) => NFData (UArray (SE r) l sh (v e))
instance [overlap ok] (Regular r l sh e, Vector v e) => Regular (SE r) l sh (v e)


-- | Dataflow (fusion operations)
module Data.Yarr.Flow

-- | This class abstracts pair of array types, which could be (preferably
--   should be) mapped <i>(fused)</i> one to another. Injective version of
--   <a>Fusion</a> class.
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>r</tt> - source array representation. It determines result
--   representation.</li>
--   <li><tt>fr</tt> (fused repr) - result (fused) array representation.
--   Result array isn't indeed presented in memory, finally it should be
--   <a>compute</a>d or <a>Load</a>ed to <a>Manifest</a>
--   representation.</li>
--   <li><tt>l</tt> - load type, common for source and fused arrays</li>
--   <li><tt>sh</tt> - shape of arrays</li>
--   </ul>
--   
--   All functions are already defined, using non-injective versions from
--   <a>Fusion</a> class.
--   
--   The class doesn't have vector counterpart, it's role play top-level
--   functions from <a>Data.Yarr.Repr.Separate</a> module.
class Fusion r fr l sh => DefaultFusion r fr l sh | r -> fr where dmap = fmap dmapM = fmapM dzip2 = fzip2 dzip2M = fzip2M dzip3 = fzip3 dzip3M = fzip3M dzip = fzip dzipM = fzipM
dmap :: (DefaultFusion r fr l sh, USource r l sh a, USource fr l sh b) => (a -> b) -> UArray r l sh a -> UArray fr l sh b
dmapM :: (DefaultFusion r fr l sh, USource r l sh a, USource fr l sh b) => (a -> IO b) -> UArray r l sh a -> UArray fr l sh b
dzip2 :: (DefaultFusion r fr l sh, USource r l sh a, USource r l sh b, USource fr l sh c) => (a -> b -> c) -> UArray r l sh a -> UArray r l sh b -> UArray fr l sh c
dzip2M :: (DefaultFusion r fr l sh, USource r l sh a, USource r l sh b, USource fr l sh c) => (a -> b -> IO c) -> UArray r l sh a -> UArray r l sh b -> UArray fr l sh c
dzip3 :: (DefaultFusion r fr l sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr l sh d) => (a -> b -> c -> d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr l sh d
dzip3M :: (DefaultFusion r fr l sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr l sh d) => (a -> b -> c -> IO d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr l sh d
dzip :: (DefaultFusion r fr l sh, USource r l sh a, USource fr l sh b, Arity n, n ~ S n0) => Fun n a b -> VecList n (UArray r l sh a) -> UArray fr l sh b
dzipM :: (DefaultFusion r fr l sh, USource r l sh a, USource fr l sh b, Arity n, n ~ S n0) => Fun n a (IO b) -> VecList n (UArray r l sh a) -> UArray fr l sh b

-- | Like <a>DefaultFusion</a>, this class abstracts the pair array types,
--   which should be fused one to another on maps and zips which accept
--   index of element (several elements for zips) in array (arrays).
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>r</tt> - source array representation. Determines result
--   representation.</li>
--   <li><tt>l</tt> - source load type</li>
--   <li><tt>fr</tt> (fused repr) - result (fused) array representation.
--   Result array isn't indeed presented in memory, finally it should be
--   <a>compute</a>d or <a>Load</a>ed to <a>Manifest</a>
--   representation.</li>
--   <li><tt>fl</tt> - result, "shaped" load type</li>
--   <li><tt>sh</tt> - shape of arrays</li>
--   </ul>
--   
--   All functions are already defined, using non-injective versions from
--   <a>IFusion</a> class.
--   
--   The class doesn't have vector counterpart.
class IFusion r l fr fl sh => DefaultIFusion r l fr fl sh | r l -> fr where imap = fimap imapM = fimapM izip2 = fizip2 izip2M = fizip2M izip3 = fizip3 izip3M = fizip3M izip = fizip izipM = fizipM
imap :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource fr fl sh b) => (sh -> a -> b) -> UArray r l sh a -> UArray fr fl sh b
imapM :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource fr fl sh b) => (sh -> a -> IO b) -> UArray r l sh a -> UArray fr fl sh b
izip2 :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource fr fl sh c) => (sh -> a -> b -> c) -> UArray r l sh a -> UArray r l sh b -> UArray fr fl sh c
izip2M :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource fr fl sh c) => (sh -> a -> b -> IO c) -> UArray r l sh a -> UArray r l sh b -> UArray fr fl sh c
izip3 :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr fl sh d) => (sh -> a -> b -> c -> d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr fl sh d
izip3M :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource r l sh b, USource r l sh c, USource fr fl sh d) => (sh -> a -> b -> c -> IO d) -> UArray r l sh a -> UArray r l sh b -> UArray r l sh c -> UArray fr fl sh d
izip :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource fr fl sh b, Arity n, n ~ S n0) => (sh -> Fun n a b) -> VecList n (UArray r l sh a) -> UArray fr fl sh b
izipM :: (DefaultIFusion r l fr fl sh, USource r l sh a, USource fr fl sh b, Arity n, n ~ S n0) => (sh -> Fun n a (IO b)) -> VecList n (UArray r l sh a) -> UArray fr fl sh b

-- | <i>O(1)</i> Generalized zipping of 2 arrays.
--   
--   Main basic "zipWith" in Yarr.
--   
--   Although sighature of this function has extremely big predicate, it is
--   more permissible than <a>dzip2</a> counterpart, because source arrays
--   shouldn't be of the same type.
--   
--   Implemented by means of <a>delay</a> function (source arrays are
--   simply delayed before zipping).
dzipWith :: (USource r1 l sh a, DefaultFusion r1 D l sh, USource D l sh a, USource r2 l sh b, DefaultFusion r2 D l sh, USource D l sh b, USource D l sh c, DefaultFusion D D l sh) => (a -> b -> c) -> UArray r1 l sh a -> UArray r2 l sh b -> UArray D l sh c

-- | <i>O(1)</i> Generalized zipping of 3 arrays, which shouldn't be of the
--   same representation type.
dzipWith3 :: (USource r1 l sh a, DefaultFusion r1 D l sh, USource D l sh a, USource r2 l sh b, DefaultFusion r2 D l sh, USource D l sh b, USource r3 l sh c, DefaultFusion r3 D l sh, USource D l sh c, USource D l sh d, DefaultFusion D D l sh) => (a -> b -> c -> d) -> UArray r1 l sh a -> UArray r2 l sh b -> UArray r3 l sh c -> UArray D l sh d

-- | Delayed representation is a wrapper for arbitrary indexing function.
--   
--   <tt><a>UArray</a> D <a>L</a> sh a</tt> instance holds linear getter
--   (<tt>(Int -&gt; IO a)</tt>), and <tt><a>UArray</a> D <a>SH</a> sh
--   a</tt> - shaped, "true" <tt>(sh -&gt; IO a)</tt> index, respectively.
--   
--   <tt>D</tt>elayed arrays are most common recipients for fusion
--   operations.
data D

-- | Load type preserving wrapping arbirtary array into <a>D</a>elayed
--   representation.
delay :: (USource r l sh a, USource D l sh a, Fusion r D l sh) => UArray r l sh a -> UArray D l sh a

-- | SEparate meta array representation. Internally SEparate arrays hold
--   vector of it's slices (so, <a>slices</a> is just getter for them).
--   
--   Mostly useful for:
--   
--   <ul>
--   <li>Separate in memory manifest <a>F</a>oreign arrays ("Unboxed"
--   arrays in <tt>vector</tt>/<tt>repa</tt> libraries terms).</li>
--   <li>Element-wise vector array fusion (see group of <a>dmapElems</a>
--   functions).</li>
--   </ul>
data SE r

-- | <i>O(1)</i> Injective element-wise fusion (mapping).
--   
--   Example:
--   
--   <pre>
--   let domainHSVImage =
--           dmapElems (<a>vl_3</a> (* 360) (* 100) (* 100))
--                     normedHSVImage
--   </pre>
--   
--   Also, used internally to define <a>mapElems</a> function.
dmapElems :: (VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh, Vector v2 b, Dim v ~ Dim v2) => VecList (Dim v) (a -> b) -> UArray r l sh (v a) -> UArray (SE fslr) l sh (v2 b)

-- | <i>O(1)</i> Monadic vesion of <a>dmapElems</a> function.
dmapElemsM :: (VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh, Vector v2 b, Dim v ~ Dim v2) => VecList (Dim v) (a -> IO b) -> UArray r l sh (v a) -> UArray (SE fslr) l sh (v2 b)
dzipElems2 :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, USource fslr l sh c, DefaultFusion slr fslr l sh, Vector v c) => VecList (Dim v) (a -> b -> c) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray (SE fslr) l sh (v c)
dzipElems2M :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, USource fslr l sh c, DefaultFusion slr fslr l sh, Vector v c) => VecList (Dim v) (a -> b -> IO c) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray (SE fslr) l sh (v c)
dzipElems3 :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, VecRegular r slr l sh v c, USource slr l sh c, USource fslr l sh d, DefaultFusion slr fslr l sh, Vector v d) => VecList (Dim v) (a -> b -> c -> d) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray r l sh (v c) -> UArray (SE fslr) l sh (v d)
dzipElems3M :: (VecRegular r slr l sh v a, USource slr l sh a, VecRegular r slr l sh v b, USource slr l sh b, VecRegular r slr l sh v c, USource slr l sh c, USource fslr l sh d, DefaultFusion slr fslr l sh, Vector v d) => VecList (Dim v) (a -> b -> c -> IO d) -> UArray r l sh (v a) -> UArray r l sh (v b) -> UArray r l sh (v c) -> UArray (SE fslr) l sh (v d)

-- | <i>O(1)</i> Generalized element-wise zipping of several arrays of
--   vectors.
dzipElems :: (Vector v2 b, Arity m, m ~ S m0, VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh) => VecList (Dim v2) (Fun m a b) -> VecList m (UArray r l sh (v a)) -> UArray (SE fslr) l sh (v2 b)

-- | <i>O(1)</i> Generalized monadic element-wise zipping of several arrays
--   of vectors
dzipElemsM :: (Vector v2 b, Arity m, m ~ S m0, VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh) => VecList (Dim v2) (Fun m a (IO b)) -> VecList m (UArray r l sh (v a)) -> UArray (SE fslr) l sh (v2 b)

-- | <i>O(1)</i> Function from <tt>repa</tt>.
traverse :: (USource r l sh a, Shape sh') => (sh -> sh') -> ((sh -> IO a) -> sh' -> IO b) -> UArray r l sh a -> UArray D SH sh' b

-- | <i>O(1)</i> Function for in-place zipping vector elements.
--   
--   Always true:
--   
--   <pre>
--   zipElems f arr == <a>dzip</a> (<a>Fun</a> f) (<a>slices</a> arr)
--   </pre>
--   
--   Example:
--   
--   <pre>
--   let φs = zipElems (<a>flip</a> <a>atan2</a>) coords
--   </pre>
zipElems :: (Vector v a, USource r l sh (v a), USource fr l sh b, DefaultFusion r fr l sh) => Fn (Dim v) a b -> UArray r l sh (v a) -> UArray fr l sh b

-- | <i>O(1)</i> Maps elements of vectors in array uniformly. Don't confuse
--   with <a>dmapElems</a>, which accepts a vector of mapper for each
--   slice.
--   
--   Typical use case -- type conversion:
--   
--   <pre>
--   let floatImage :: UArray F Dim2 Float
--       floatImage = mapElems <a>fromIntegral</a> word8Image
--   </pre>
mapElems :: (VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh, Vector v b) => (a -> b) -> UArray r l sh (v a) -> UArray (SE fslr) l sh (v b)

-- | <i>O(1)</i> Monadic version of <a>mapElems</a> function. Don't confuse
--   with <a>dmapElemsM</a>.
--   
--   Example:
--   
--   <pre>
--   let domained = mapElemsM (<a>clampM</a> 0.0 1.0) floatImage
--   </pre>
mapElemsM :: (VecRegular r slr l sh v a, USource slr l sh a, USource fslr l sh b, DefaultFusion slr fslr l sh, Vector v b) => (a -> IO b) -> UArray r l sh (v a) -> UArray (SE fslr) l sh (v b)
cartProduct2 :: (USource r1 l1 Dim1 a, USource r2 l2 Dim1 b) => (a -> b -> c) -> UArray r1 l1 Dim1 a -> UArray r2 l2 Dim1 b -> UArray D SH Dim2 c
icartProduct2 :: (USource r1 l1 Dim1 a, USource r2 l2 Dim1 b) => (Dim2 -> a -> b -> c) -> UArray r1 l1 Dim1 a -> UArray r2 l2 Dim1 b -> UArray D SH Dim2 c
icartProduct2M :: (USource r1 l1 Dim1 a, USource r2 l2 Dim1 b) => (Dim2 -> a -> b -> IO c) -> UArray r1 l1 Dim1 a -> UArray r2 l2 Dim1 b -> UArray D SH Dim2 c
cartProduct3 :: (USource r1 l1 Dim1 a, USource r2 l2 Dim1 b, USource r3 l3 Dim1 c) => (a -> b -> c -> d) -> UArray r1 l1 Dim1 a -> UArray r2 l2 Dim1 b -> UArray r3 l3 Dim1 c -> UArray D SH Dim3 d
icartProduct3 :: (USource r1 l1 Dim1 a, USource r2 l2 Dim1 b, USource r3 l3 Dim1 c) => (Dim3 -> a -> b -> c -> d) -> UArray r1 l1 Dim1 a -> UArray r2 l2 Dim1 b -> UArray r3 l3 Dim1 c -> UArray D SH Dim3 d
icartProduct3M :: (USource r1 l1 Dim1 a, USource r2 l2 Dim1 b, USource r3 l3 Dim1 c) => (Dim3 -> a -> b -> c -> IO d) -> UArray r1 l1 Dim1 a -> UArray r2 l2 Dim1 b -> UArray r3 l3 Dim1 c -> UArray D SH Dim3 d

module Data.Yarr.Repr.Foreign

-- | Foreign representation is the heart of Yarr framework.
--   
--   Internally it holds raw pointer (<a>Ptr</a>), which makes indexing
--   foreign arrays not slower than GHC's built-in primitive arrays, but
--   without freeze/thaw boilerplate.
--   
--   Foreign arrays are very permissible, for example you can easily use
--   them as source and target of <a>Load</a>ing operation simultaneously,
--   achieving old good in-place <tt>C-</tt>style array modifying:
--   
--   <pre>
--   <a>loadS</a> <a>fill</a> (<a>dmap</a> <a>sqrt</a> arr) arr
--   </pre>
--   
--   Foreign arrays are intented to hold all <a>Storable</a> types and
--   vectors of them (because there is a conditional instance of
--   <tt>Storalbe</tt> class for <a>Vector</a>s of <a>Storable</a>s too).
data F

-- | Foreign Slice representation, <i>view</i> slice representation for
--   <a>F</a>oreign arrays.
--   
--   To understand Foreign Slices, suppose you have standard <tt>image</tt>
--   array of <tt><a>UArray</a> <a>F</a> <a>Dim2</a> (<a>VecList</a>
--   <a>N3</a> Word8)</tt> type.
--   
--   It's layout in memory (with array indices):
--   
--   <pre>
--    r g b | r g b | r g b | ...
--   (0, 0)  (0, 1)  (0, 2)   ...
--   </pre>
--   
--   <pre>
--   let (VecList [reds, greens, blues]) = <a>slices</a> image
--   -- reds, greens, blues :: UArray FS Dim2 Word8
--   </pre>
--   
--   Now <tt>blues</tt> just indexes each third byte on the same underlying
--   memory block:
--   
--   <pre>
--   ... b | ... b | ... b | ...
--     (0, 0)  (0, 1)  (0, 2)...
--   </pre>
data FS

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
--   
--   Minimal complete definition: <a>sizeOf</a>, <a>alignment</a>, one of
--   <a>peek</a>, <a>peekElemOff</a> and <a>peekByteOff</a>, and one of
--   <a>poke</a>, <a>pokeElemOff</a> and <a>pokeByteOff</a>.
class Storable a

-- | Linear load type index. <a>UArray</a>s with <a>L</a> load type index
--   define <a>linearIndex</a> and <a>linearWrite</a> and leave
--   <a>index</a> and <a>write</a> functions defined by default.
data L

-- | <i>O(1)</i> allocates zero-initialized foreign array.
--   
--   Needed because common <a>new</a> function allocates array with
--   garbage.
newEmpty :: (Shape sh, Storable a, Integral a) => sh -> IO (UArray F L sh a)

-- | <i>O(1)</i> Returns pointer to memory block used by the given foreign
--   array.
--   
--   May be useful to reuse memory if you don't longer need the given array
--   in the program:
--   
--   <pre>
--   brandNewData &lt;-
--      <a>unsafeFromForeignPtr</a> ext (<a>castForeignPtr</a> (toForeignPtr arr))
--   </pre>
toForeignPtr :: Shape sh => UArray F L sh a -> ForeignPtr a

-- | <i>O(1)</i> Wraps foreign ptr into foreign array.
--   
--   The function is unsafe because it simply don't (and can't) check
--   anything about correctness of produced array.
unsafeFromForeignPtr :: Shape sh => sh -> ForeignPtr a -> IO (UArray F L sh a)
instance [overlap ok] (Shape sh, Vector v e, Storable e) => UVecTarget F FS L sh v e
instance [overlap ok] (Shape sh, Storable e) => UTarget FS L sh e
instance [overlap ok] (Shape sh, Storable a) => Manifest F F L sh a
instance [overlap ok] (Shape sh, Storable a) => UTarget F L sh a
instance [overlap ok] (Shape sh, Vector v e, Storable e) => UVecSource (SE F) F L sh v e
instance [overlap ok] (Shape sh, Vector v e, Storable e) => UVecSource F FS L sh v e
instance [overlap ok] (Shape sh, Vector v e, Storable e) => VecRegular F FS L sh v e
instance [overlap ok] Shape sh => DefaultIFusion FS L D SH sh
instance [overlap ok] DefaultFusion FS D L sh
instance [overlap ok] (Shape sh, Storable e) => USource FS L sh e
instance [overlap ok] Shape sh => NFData (UArray FS L sh e)
instance [overlap ok] Shape sh => Regular FS L sh e
instance [overlap ok] Shape sh => DefaultIFusion F L D SH sh
instance [overlap ok] DefaultFusion F D L sh
instance [overlap ok] (Shape sh, Storable a) => USource F L sh a
instance [overlap ok] Shape sh => NFData (UArray F L sh a)
instance [overlap ok] Shape sh => Regular F L sh a

module Data.Yarr.Walk

-- | <i>O(1)</i>
reduceL :: Foldl i a b -> (b -> a -> b) -> StatefulWalk i a b

-- | <i>O(1)</i>
ireduceL :: Foldl i a b -> (b -> i -> a -> b) -> StatefulWalk i a b

-- | <i>O(1)</i>
reduceLeftM :: Foldl i a b -> (b -> a -> IO b) -> StatefulWalk i a b

-- | <i>O(1)</i>
reduceR :: Foldr i a b -> (a -> b -> b) -> StatefulWalk i a b

-- | <i>O(1)</i>
ireduceR :: Foldr i a b -> (i -> a -> b -> b) -> StatefulWalk i a b

-- | <i>O(1)</i>
reduceRightM :: Foldr i a b -> (a -> b -> IO b) -> StatefulWalk i a b

-- | <i>O(1)</i>
reduceInner :: (USource r l sh a, MultiShape sh lsh, PreferredWorkIndex l sh i) => StatefulWalk i a b -> (lsh -> IO b) -> UArray r l sh a -> UArray D SH lsh b

-- | <i>O(1)</i>
ireduceInner :: (USource r l sh a, MultiShape sh lsh) => StatefulWalk sh a b -> (lsh -> IO b) -> UArray r l sh a -> UArray D SH lsh b

-- | <i>O(1)</i>
mutate :: Fill i a -> (s -> a -> IO ()) -> StatefulWalk i a s

-- | <i>O(1)</i> Version of <a>mutate</a>, accepts mutating function which
--   additionaly accepts array index.
imutate :: Fill i a -> (s -> i -> a -> IO ()) -> StatefulWalk i a s

-- | <i>O(n)</i> Walk with state, with non-indexed function (<a>reduceL</a>
--   group of fold combinators, <a>mutate</a>).
--   
--   Example:
--   
--   <pre>
--   <a>toList</a> = walk (<a>reduceR</a> <a>foldr</a> (:)) (return [])
--   </pre>
walk :: (USource r l sh a, PreferredWorkIndex l sh i) => StatefulWalk i a s -> IO s -> UArray r l sh a -> IO s

-- | <i>O(n)</i> Walk with state, with indexed function (<a>foldl</a>,
--   <a>foldr</a>, <a>imutate</a>, etc).
--   
--   Example:
--   
--   <pre>
--   res &lt;- iwalk (<a>foldl</a> (\s i a -&gt; ...)) foldZero sourceArray
--   </pre>
iwalk :: USource r l sh a => StatefulWalk sh a s -> IO s -> UArray r l sh a -> IO s

-- | <i>O(n)</i> Walk with state, in specified range of indices.
rangeWalk :: USource r l sh a => StatefulWalk sh a s -> IO s -> UArray r l sh a -> sh -> sh -> IO s

-- | <i>O(n)</i> Run associative non-indexed stateful walk, in parallel.
--   
--   Example -- associative image histogram filling in the test:
--   <a>https://github.com/leventov/yarr/blob/master/tests/lum-equalization.hs</a>
walkP :: (USource r l sh a, PreferredWorkIndex l sh i) => Threads -> StatefulWalk i a s -> IO s -> (s -> s -> IO s) -> UArray r l sh a -> IO s

-- | <i>O(n)</i> Run associative indexed stateful walk, in parallel.
iwalkP :: USource r l sh a => Threads -> StatefulWalk sh a s -> IO s -> (s -> s -> IO s) -> UArray r l sh a -> IO s

-- | <i>O(n)</i> Run associative stateful walk in specified range, in
--   parallel.
rangeWalkP :: USource r l sh a => Threads -> StatefulWalk sh a s -> IO s -> (s -> s -> IO s) -> UArray r l sh a -> sh -> sh -> IO s

-- | <i>O(n)</i> Walk with state, with non-indexed function, over each
--   slice of array of vectors.
walkSlicesSeparate :: (UVecSource r slr l sh v e, PreferredWorkIndex l sh i) => StatefulWalk i e s -> IO s -> UArray r l sh (v e) -> IO (VecList (Dim v) s)

-- | <i>O(n)</i> Walk with state, with indexed function, over each slice of
--   array of vectors.
iwalkSlicesSeparate :: UVecSource r slr l sh v e => StatefulWalk sh e s -> IO s -> UArray r l sh (v e) -> IO (VecList (Dim v) s)

-- | <i>O(n)</i> Walk with state, in specified range of indices, over each
--   slice of array of vectors.
rangeWalkSlicesSeparate :: UVecSource r slr l sh v e => StatefulWalk sh e s -> IO s -> UArray r l sh (v e) -> sh -> sh -> IO (VecList (Dim v) s)

-- | <i>O(n)</i> Run associative non-indexed stateful walk over slices of
--   array of vectors, in parallel.
walkSlicesSeparateP :: (UVecSource r slr l sh v e, PreferredWorkIndex l sh i) => Threads -> StatefulWalk i e s -> IO s -> (s -> s -> IO s) -> UArray r l sh (v e) -> IO (VecList (Dim v) s)

-- | <i>O(n)</i> Run associative indexed stateful walk over slices of array
--   of vectors, in parallel.
iwalkSlicesSeparateP :: UVecSource r slr l sh v e => Threads -> StatefulWalk sh e s -> IO s -> (s -> s -> IO s) -> UArray r l sh (v e) -> IO (VecList (Dim v) s)

-- | <i>O(n)</i> Run associative stateful walk in specified range, over
--   slices of array of vectors, in parallel.
rangeWalkSlicesSeparateP :: UVecSource r slr l sh v e => Threads -> StatefulWalk sh e s -> IO s -> (s -> s -> IO s) -> UArray r l sh (v e) -> sh -> sh -> IO (VecList (Dim v) s)

-- | Generalizes both partially applied left and right folds, as well as
--   walks with mutable state.
--   
--   To be passed to walk runners from <a>Data.Yarr.Walk</a> module.
type StatefulWalk sh a s = IO s -> (sh -> IO a) -> Walk sh s

-- | Generalizes left folds.
--   
--   To be passed to fold combinators from <a>Data.Yarr.Walk</a> module.
type Foldl sh a b = (b -> sh -> a -> IO b) -> StatefulWalk sh a b

-- | Generalizes right folds.
--   
--   To be passed to fold combinators from <a>Data.Yarr.Walk</a> module.
type Foldr sh a b = (sh -> a -> b -> IO b) -> StatefulWalk sh a b

module Debug.Yarr
data CHK r

-- | Yarr something to stderr.
yarr :: String -> IO ()

-- | Yarr something as <a>error</a> message.
yerr :: String -> a
instance [overlap ok] UVecTarget tr tslr l sh v e => UVecTarget (CHK tr) (CHK tslr) l sh v e
instance [overlap ok] Manifest r mr l sh a => Manifest (CHK r) (CHK mr) l sh a
instance [overlap ok] UTarget tr tl sh a => UTarget (CHK tr) tl sh a
instance [overlap ok] UVecSource r slr l sh v e => UVecSource (CHK r) (CHK slr) l sh v e
instance [overlap ok] USource r l sh a => USource (CHK r) l sh a
instance [overlap ok] VecRegular r slr l sh v e => VecRegular (CHK r) (CHK slr) l sh v e
instance [overlap ok] NFData (UArray r l sh a) => NFData (UArray (CHK r) l sh a)
instance [overlap ok] Regular r l sh a => Regular (CHK r) l sh a

module Data.Yarr.Repr.Boxed

-- | <a>B</a>oxed representation is a wrapper for <a>Array</a> from
--   <tt>primitive</tt> package. It may be used to operate with arrays of
--   variable-lengths or multiconstructor ADTs, for example, lists.
--   
--   For <a>Storable</a> element types you would better use <a>F</a>oreign
--   arrays.
--   
--   <i>TODO:</i> test this representation at least one time...
data B

-- | Mutable Boxed is a wrapper for <a>MutableArray</a>.
data MB
instance [overlap ok] (Shape sh, NFData a) => Manifest B MB L sh a
instance [overlap ok] (Shape sh, NFData a) => UTarget MB L sh a
instance [overlap ok] (Shape sh, Vector v e, NFData e) => UVecSource (SE MB) MB L sh v e
instance [overlap ok] Shape sh => DefaultIFusion MB L D SH sh
instance [overlap ok] DefaultFusion MB D L sh
instance [overlap ok] (Shape sh, NFData a) => USource MB L sh a
instance [overlap ok] (Shape sh, NFData a) => NFData (UArray MB L sh a)
instance [overlap ok] (Shape sh, NFData a) => Regular MB L sh a
instance [overlap ok] (Shape sh, Vector v e, NFData e) => UVecSource (SE B) B L sh v e
instance [overlap ok] Shape sh => DefaultIFusion B L D SH sh
instance [overlap ok] DefaultFusion B D L sh
instance [overlap ok] (Shape sh, NFData a) => USource B L sh a
instance [overlap ok] (Shape sh, NFData a) => NFData (UArray B L sh a)
instance [overlap ok] (Shape sh, NFData a) => Regular B L sh a

module Data.Yarr.Convolution

-- | Convolution fused representation internally keeps 2 element getters:
--   
--   <ul>
--   <li>slow <i>border get</i>, which checks every index from applied
--   stencil to lay inside extent of underlying source array.</li>
--   <li>fast <i>center get</i>, which doesn't worry about bound
--   checks</li>
--   </ul>
--   
--   and <a>center</a> <a>Block</a>.
data CV

-- | ConVolution <a>Load</a> type is specialized to load convoluted arrays.
--   
--   It loads <a>center</a> with <a>centerGet</a> and borders outside the
--   center with <a>borderGet</a> separately.
--   
--   It is even able to distribute quite expensive border loads evenly
--   between available threads while parallel load.
--   
--   Element-wise Loading convoluted arrays wasn't inlined propely with
--   unrolled <a>Fill</a>ing (<a>unrolledFill</a>, <a>dim2BlockFill</a>).
--   However, with simple <a>fill</a> performance was OK.
--   
--   For details see
--   <a>http://stackoverflow.com/questions/14748900/ghc-doesnt-perform-2-stage-partial-application-inlining</a>
--   
--   <i>ALMOST SOLVED:</i> you just need to support unrolled filling
--   function with <tt>INLINE</tt> pragma, see
--   <a>https://github.com/leventov/yarr/blob/master/tests/blur.hs</a>,
--   <tt>ffill</tt> function.
data CVL

-- | Retreives fast center get from convoluted array and wraps it into
--   <a>D</a>elayed array.
--   
--   Remember that array indexing in Yarr is always zero-based, so indices
--   in result array are shifted by top-level corner offset of given
--   convoluted array.
justCenter :: Shape sh => UArray CV CVL sh a -> UArray D SH sh a

-- | Generalized static <a>Dim1</a> stencil.
data Dim1Stencil size a b c
Dim1Stencil :: size -> (VecList size b) -> (c -> a -> b -> IO c) -> IO c -> Dim1Stencil size a b c
dim1StencilSize :: Dim1Stencil size a b c -> size
dim1StencilValues :: Dim1Stencil size a b c -> (VecList size b)

-- | Generalized reduce function
dim1StencilReduce :: Dim1Stencil size a b c -> c -> a -> b -> IO c

-- | Reduce zero
dim1StencilZero :: Dim1Stencil size a b c -> IO c

-- | QuasiQuoter for producing typical numeric convolving <a>Dim1</a>
--   stencil, which effectively skips unnecessary multiplications.
--   
--   <pre>
--   [dim1St| 1 4 6 4 1 |]
--   </pre>
--   
--   Produces
--   
--   <pre>
--   <a>Dim1Stencil</a>
--       <a>n5</a>
--       (<a>VecList</a>
--          [\ acc a -&gt; return (acc + a),
--           \ acc a -&gt; (return $ (acc + (4 * a))),
--           \ acc a -&gt; (return $ (acc + (6 * a))),
--           \ acc a -&gt; (return $ (acc + (4 * a))),
--           \ acc a -&gt; return (acc + a)])
--       (\ acc a reduce -&gt; reduce acc a)
--       (return 0)
--   </pre>
dim1St :: QuasiQuoter

-- | Curried version of <a>convolveDim1WithStaticStencil</a> with border
--   get clamping indices out of bounds to <tt>0</tt> or <tt>(<a>extent</a>
--   source)</tt>.
dConvolveDim1WithStaticStencil :: (StencilOffsets s so eo, USource r l Dim1 a) => Dim1Stencil s a b c -> UArray r l Dim1 a -> UArray CV CVL Dim1 c

-- | Convolves <a>Dim1</a> array with static stencil.
convolveDim1WithStaticStencil :: (USource r l Dim1 a, StencilOffsets s so eo) => (UArray r l Dim1 a -> Dim1 -> Dim1 -> IO a) -> Dim1Stencil s a b c -> UArray r l Dim1 a -> UArray CV CVL Dim1 c

-- | Generalized static <a>Dim2</a> stencil.
data Dim2Stencil sx sy a b c
Dim2Stencil :: sx -> sy -> VecList sy (VecList sx b) -> (c -> a -> b -> IO c) -> IO c -> Dim2Stencil sx sy a b c
dim2StencilSizeX :: Dim2Stencil sx sy a b c -> sx
dim2StencilSizeY :: Dim2Stencil sx sy a b c -> sy

-- | Stencil values, packed in nested vectors
dim2StencilValues :: Dim2Stencil sx sy a b c -> VecList sy (VecList sx b)

-- | Generalized reduce function
dim2StencilReduce :: Dim2Stencil sx sy a b c -> c -> a -> b -> IO c

-- | Reduce zero
dim2StencilZero :: Dim2Stencil sx sy a b c -> IO c

-- | Most useful <a>Dim2</a> stencil producer.
--   
--   Typing
--   
--   <pre>
--   [dim2St| 1   2   1
--            0   0   0
--           -1  -2  -1 |]
--   </pre>
--   
--   Results to
--   
--   <pre>
--   <a>Dim2Stencil</a>
--    <a>n3</a>
--    <a>n3</a>
--    (<a>VecList</a>
--       [<a>VecList</a>
--          [\ acc a -&gt; return (acc + a),
--           \ acc a -&gt; (return $ (acc + (2 * a))),
--           \ acc a -&gt; return (acc + a)],
--        <a>VecList</a>
--          [\ acc _ -&gt; return acc,
--           \ acc _ -&gt; return acc,
--           \ acc _ -&gt; return acc],
--        <a>VecList</a>
--          [\ acc a -&gt; return (acc - a),
--           \ acc a -&gt; (return $ (acc + (-2 * a))),
--           \ acc a -&gt; return (acc - a)]])
--    (\ acc a reduce -&gt; reducej acc a)
--    (return 0)
--   </pre>
dim2St :: QuasiQuoter

-- | Clamps <a>Dim2</a> index out of bounds to the nearest one inside
--   bounds.
dim2OutClamp :: USource r l Dim2 a => UArray r l Dim2 a -> Dim2 -> Dim2 -> IO a

-- | Defined as <tt>dConvolveShDim2WithStaticStencil =
--   <a>convolveShDim2WithStaticStencil</a> <a>dim2OutClamp</a></tt>
--   
--   Example:
--   
--   <pre>
--   let gradientX =
--           dConvolveLinearDim2WithStaticStencil
--               [<a>dim2St</a>| -1  0  1
--                        -2  0  2
--                        -1  0  1 |]
--               image
--   </pre>
dConvolveShDim2WithStaticStencil :: (StencilOffsets sx sox eox, StencilOffsets sy soy eoy, USource r SH Dim2 a) => Dim2Stencil sx sy a b c -> UArray r SH Dim2 a -> UArray CV CVL Dim2 c

-- | Convolves <a>Dim2</a> array with <a>SH</a>aped load type with static
--   stencil.
convolveShDim2WithStaticStencil :: (USource r SH Dim2 a, StencilOffsets sx sox eox, StencilOffsets sy soy eoy) => (UArray r SH Dim2 a -> Dim2 -> Dim2 -> IO a) -> Dim2Stencil sx sy a b c -> UArray r SH Dim2 a -> UArray CV CVL Dim2 c

-- | Analog of <a>dConvolveShDim2WithStaticStencil</a> to convolve arrays
--   with <a>L</a>inear load index.
dConvolveLinearDim2WithStaticStencil :: (StencilOffsets sx sox eox, StencilOffsets sy soy eoy, USource r L Dim2 a) => Dim2Stencil sx sy a b c -> UArray r L Dim2 a -> UArray CV CVL Dim2 c

-- | Analog of <a>convolveShDim2WithStaticStencil</a> to convolve arrays
--   with <a>L</a>inear load index.
convolveLinearDim2WithStaticStencil :: (StencilOffsets sx sox eox, StencilOffsets sy soy eoy, USource r L Dim2 a) => (UArray r L Dim2 a -> Dim2 -> Dim2 -> IO a) -> Dim2Stencil sx sy a b c -> UArray r L Dim2 a -> UArray CV CVL Dim2 c

module Data.Yarr.IO.List

-- | <i>O(n)</i> Covert array to flat list. Multidimentional arrays are
--   flatten in column-major order:
--   
--   [(elem at (0, .., 0, 1)), (elem at (0, .., 0, 2)), ...]
toList :: (USource r l sh a, PreferredWorkIndex l sh i) => UArray r l sh a -> IO [a]

-- | <i>O(n)</i> Loads manifest array into memory, with elements from
--   flatten list.
--   
--   Use this function in the last resort, there are plenty of methods to
--   <a>Load</a> array, from <a>D</a>elayed array for example.
fromList :: Manifest r mr l sh a => sh -> [a] -> IO (UArray r l sh a)


-- | <i>Type system intro:</i>
--   
--   <a>Regular</a> is main type class in the library. Like <tt>Source</tt>
--   class in <tt>repa</tt>, it defines indexed type family: <a>UArray</a>.
--   Classes <a>USource</a>, for arrays which could be indexed, and
--   <a>UTarget</a>, for mutable arrays, inherit from <a>Regular</a>.
--   
--   As in <tt>repa</tt>, arrays in Yarr are type-indexed. <a>UArray</a>
--   type family has 2 type indexes:
--   
--   <ul>
--   <li><i>representation index</i> - the first type argument.</li>
--   <li><i>load type index</i> - the second argument of the type family.
--   Pair of <i>load indexes</i>, from source and target array determines
--   how arrays will be loaded one to another. Load index is mostly
--   internal thing. See <a>Load</a> class for details.</li>
--   </ul>
--   
--   Rest 2 <a>UArray</a> parameters generalize <a>Shape</a> and element
--   type.
--   
--   <a>VecRegular</a>, <a>UVecSource</a>, <a>UVecTarget</a> are
--   counterparts for arrays of fixed-sized vectors. These classes have 6
--   arguments: repr type index, <i>slice repr type index</i>, load type
--   index, shape, vector type, vector element.
--   
--   <i>Note:</i> in the docs "vector" always stands for fixed-size vector.
--   Don't confuse with vector from <tt>vector</tt> library.
--   
--   As in <tt>repa</tt>, there are several kinds of representations:
--   
--   <ul>
--   <li><a>Manifest</a> representations: <a>F</a>oreign and <a>B</a>oxed
--   with <a>MB</a> (Mutable Boxed). The difference between <a>Manifest</a>
--   and <a>UTarget</a> arrays is that <a>Manifest</a> arrays could be
--   created (see <a>new</a> function). For example, <a>FS</a> (Foreign
--   Slice) is a slice representation for <a>F</a>. FS-arrays are mutable,
--   but you can't create a slice, you should firstly allocate entire
--   <a>F</a> array.</li>
--   <li><i>Delayed</i>, or <i>fused</i> representations: <a>D</a>elayed
--   and <a>CV</a> (ConVoluted). Arrays of these types aren't really exist
--   in memory. Finally they should be loaded to manifest arrays.</li>
--   <li><i>View</i> representations: <a>DT</a> (Delayed Target) and
--   <a>FS</a>. Useful for advanced hand-controlled flow operations.</li>
--   <li><i>Meta</i> representations: <a>SE</a>parate and <a>CHK</a>
--   (CHecKed). Thery are parameterized with another representation index.
--   Arrays of meta types play almost like their prototypes. <a>SE</a>
--   glues several arrays into one array of vectors (array types with
--   <a>SE</a> index are always instances of <a>VecRegular</a> class).
--   <a>CHK</a> is useful for debugging, it raises error on illegal
--   indexing attempt. By default indexing is unchecked.</li>
--   </ul>
--   
--   <i>Representation choice:</i>
--   
--   <a>F</a>oreign is the main manifest representation. "Unboxed" arrays
--   of tuples from <tt>repa</tt> and <tt>vector</tt> libraries may be
--   emulated by <tt>(<a>SE</a> <a>F</a>)</tt> type index, but keep in mind
--   that they are usually slower than vanilla foreign arrays, because the
--   latter are memory-local.
--   
--   <i>How to load array into memory:</i>
--   
--   Currently there is only one option "out of the box" - to load image :)
--   See <a>Data.Yarr.IO.Image</a> module in <tt>yarr-image-io</tt>
--   package.
--   
--   Consider also <a>Data.Yarr.IO.List</a> module, although it is very
--   slow way to obtain manifest array in memory.
--   
--   <i>How to map and zip arrays:</i>
--   
--   See <a>DefaultFusion</a> class and functions in <a>Data.Yarr.Flow</a>
--   module.
--   
--   Example:
--   
--   <pre>
--   let delayedVecLengths = <a>zipElems</a> (x y -&gt; sqrt (x * x + y * y)) vecs
--   </pre>
--   
--   <i>How to compute an array:</i>
--   
--   See <a>Load</a> class and its counterpart <a>VecLoad</a>, and
--   <a>compute</a> function.
--   
--   Typical use:
--   
--   <pre>
--   vecLengths &lt;- <a>compute</a> (<a>loadP</a> <a>fill</a> <a>caps</a>) delayedVecLengths
--   </pre>
--   
--   <ul>
--   <li><i><tt>Working examples</tt></i>
--   <a>https://github.com/leventov/yarr/tree/master/tests</a></li>
--   </ul>
--   
--   <i>How to write fast program:</i>
--   
--   <ol>
--   <li>Read corresponding section in <tt>repa</tt> guide:
--   <a>http://hackage.haskell.org/packages/archive/repa/3.2.3.1/doc/html/Data-Array-Repa.html</a></li>
--   <li>Write <tt>INLINE</tt> pragmas to all functions, including curried
--   shortcuts. For example in such case: <tt>let {myIndex = <a>index</a>
--   arr} in ...</tt> you should write: <tt>let {{-# INLINE myIndex
--   #-};</tt> <tt>myIndex = <a>index</a> arr} in ...</tt></li>
--   <li>Although the library is highly generalized, target programs should
--   be as as precise in types as possible. Don't neglect writing
--   signatures for functions.</li>
--   <li>Compilation flags: <tt>-Odph -rtsopts -threaded -fno-liberate-case
--   -funbox-strict-fields</tt> <tt>-fexpose-all-unfoldings
--   -funfolding-keeness-factor1000</tt> <tt>-fsimpl-tick-factor=500 -fllvm
--   -optlo-O3</tt>.</li>
--   </ol>
--   
--   <i>Abbreviations across the library:</i>
--   
--   In names:
--   
--   <ul>
--   <li><tt>U-</tt>, <tt>u-</tt>, <tt>unsafe-</tt> prefixes mean that: a)
--   function parameters must conform special statically unchecked
--   conditions, or b) it isn't OK just to call the function, you must do
--   something else, call another function. All functions in type classes
--   with <tt>U-</tt> prefix (<a>USource</a>, <a>UTarget</a>) are
--   unsafe.</li>
--   <li><tt>d-</tt> prefix stands for "default". Typically function with
--   <tt>d-</tt> prefix is carried version of the one without prefix.</li>
--   <li><tt>I-</tt>, <tt>i-</tt> prefixes for "indexed". Functions with
--   this prefix accept array index before element itself.</li>
--   <li><tt>f-</tt> prefix means "fused". Used for functions from
--   <a>Fusion</a> class.</li>
--   <li><tt>-M</tt>, as usual, is for monadic versions of functions.
--   However, if there isn't non-monadic version (the most part of core
--   functions), the suffix is omitted.</li>
--   <li><tt>-S</tt> and <tt>-P</tt> are suffixes from <tt>repa</tt>, they
--   indicate sequential and parallel versions of flow operation,
--   respectively.</li>
--   </ul>
--   
--   In signatures:
--   
--   <ul>
--   <li><tt>r</tt>, <tt>tr</tt>, <tt>mr</tt> - representation, target
--   repr, manifest repr. For the first type index of <a>UArray</a>
--   family.</li>
--   <li><tt>slr</tt>, <tt>tslr</tt>, <tt>mslr</tt> - slice representation,
--   respectively</li>
--   <li><tt>l</tt>, <tt>tl</tt> - load index, for the second argument of
--   <a>UArray</a></li>
--   <li><tt>sh</tt> - array shape: <a>Dim1</a>, <a>Dim2</a>, or
--   <a>Dim3</a></li>
--   <li><tt>v</tt>, <tt>v1</tt>, <tt>v2</tt> - <a>Vector</a> type</li>
--   <li><tt>e</tt>, <tt>e2</tt> - vector element</li>
--   <li><tt>n</tt>, <tt>m</tt> - <a>Arity</a> of vector</li>
--   </ul>
module Data.Yarr
type Dim1 = Int
type Dim2 = (Int, Int)
type Dim3 = (Int, Int, Int)

-- | Newtype wrapper which is used to make <a>Fn</a> injective.
newtype Fun n a b :: * -> * -> * -> *
Fun :: Fn n a b -> Fun n a b

-- | Type class for vectors with fixed length.
class Arity (Dim v) => Vector (v :: * -> *) a
construct :: Vector v a => Fun (Dim v) a (v a)
inspect :: Vector v a => v a -> Fun (Dim v) a b -> b

-- | Vector based on the lists. Not very useful by itself but is necessary
--   for implementation.
newtype VecList n a :: * -> * -> *
VecList :: [a] -> VecList n a
type N1 = S Z
type N2 = S N1
type N3 = S N2
type N4 = S N3

-- | Foreign representation is the heart of Yarr framework.
--   
--   Internally it holds raw pointer (<a>Ptr</a>), which makes indexing
--   foreign arrays not slower than GHC's built-in primitive arrays, but
--   without freeze/thaw boilerplate.
--   
--   Foreign arrays are very permissible, for example you can easily use
--   them as source and target of <a>Load</a>ing operation simultaneously,
--   achieving old good in-place <tt>C-</tt>style array modifying:
--   
--   <pre>
--   <a>loadS</a> <a>fill</a> (<a>dmap</a> <a>sqrt</a> arr) arr
--   </pre>
--   
--   Foreign arrays are intented to hold all <a>Storable</a> types and
--   vectors of them (because there is a conditional instance of
--   <tt>Storalbe</tt> class for <a>Vector</a>s of <a>Storable</a>s too).
data F

-- | <i>O(1)</i> Wraps foreign ptr into foreign array.
--   
--   The function is unsafe because it simply don't (and can't) check
--   anything about correctness of produced array.
unsafeFromForeignPtr :: Shape sh => sh -> ForeignPtr a -> IO (UArray F L sh a)

-- | <i>O(1)</i> Returns pointer to memory block used by the given foreign
--   array.
--   
--   May be useful to reuse memory if you don't longer need the given array
--   in the program:
--   
--   <pre>
--   brandNewData &lt;-
--      <a>unsafeFromForeignPtr</a> ext (<a>castForeignPtr</a> (toForeignPtr arr))
--   </pre>
toForeignPtr :: Shape sh => UArray F L sh a -> ForeignPtr a

-- | Delayed representation is a wrapper for arbitrary indexing function.
--   
--   <tt><a>UArray</a> D <a>L</a> sh a</tt> instance holds linear getter
--   (<tt>(Int -&gt; IO a)</tt>), and <tt><a>UArray</a> D <a>SH</a> sh
--   a</tt> - shaped, "true" <tt>(sh -&gt; IO a)</tt> index, respectively.
--   
--   <tt>D</tt>elayed arrays are most common recipients for fusion
--   operations.
data D

-- | Wrap indexing function into delayed representation.
--   
--   Use this function carefully, don't implement through it something that
--   has specialized implementation in the library (mapping, zipping, etc).
--   
--   Suitable to obtain arrays of constant element, of indices
--   (<tt>fromFunction sh <a>return</a></tt>), and so on.
fromFunction :: Shape sh => sh -> (sh -> IO a) -> UArray D SH sh a

-- | Load type preserving wrapping arbirtary array into <a>D</a>elayed
--   representation.
delay :: (USource r l sh a, USource D l sh a, Fusion r D l sh) => UArray r l sh a -> UArray D l sh a

-- | SEparate meta array representation. Internally SEparate arrays hold
--   vector of it's slices (so, <a>slices</a> is just getter for them).
--   
--   Mostly useful for:
--   
--   <ul>
--   <li>Separate in memory manifest <a>F</a>oreign arrays ("Unboxed"
--   arrays in <tt>vector</tt>/<tt>repa</tt> libraries terms).</li>
--   <li>Element-wise vector array fusion (see group of <a>dmapElems</a>
--   functions).</li>
--   </ul>
data SE r

-- | <i>O(1)</i> Glues several arrays of the same type into one separate
--   array of vectors. All source arrays must be of the same extent.
--   
--   Example:
--   
--   <pre>
--   let separateCoords = fromSlices (<a>vl_3</a> xs ys zs)
--   </pre>
fromSlices :: (Regular r l sh e, Vector v e, Dim v ~ S n0) => VecList (Dim v) (UArray r l sh e) -> UArray (SE r) l sh (v e)

-- | <i>O(depends on mapper function)</i> Maps slices of separate array
--   "entirely".
--   
--   This function is useful when operation over slices is not element-wise
--   (in that case you should use <a>mapElems</a>):
--   
--   <pre>
--   let blurredImage = unsafeMapSlices blur image
--   </pre>
--   
--   The function is unsafe because it doesn't check that slice mapper
--   translates extents uniformly (though it is pure).
unsafeMapSlices :: (USource r l sh a, Vector v a, USource r2 l2 sh2 b, Vector v b, Dim v ~ S n0) => (UArray r l sh a -> UArray r2 l2 sh2 b) -> UArray (SE r) l sh (v a) -> UArray (SE r2) l2 sh2 (v b)
