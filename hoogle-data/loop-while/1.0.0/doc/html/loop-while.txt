-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monad transformer supporting various styles of while loop
--   
--   A monad transformer allowing for pre-condition, post-condition and
--   mid-condition while loops.
@package loop-while
@version 1.0.0


-- | A module containing a monad transformer for performing while loops.
--   There is nothing here that can't be built using if-then-else, but it
--   can allow you to express control more succinctly.
--   
--   For example, here is a loop that executes until a certain time is
--   reached:
--   
--   <pre>
--   loop $ do lift performAction
--             t &lt;- lift getTime
--             while (t &lt; endTime)
--   </pre>
--   
--   This would commonly be called a do-while loop in other languages. But
--   the while statement does not have to be at the end of the loop:
--   
--   <pre>
--   loop $ do lift performAction
--             t &lt;- lift getTime
--             while (t &lt; endTime)
--             lift $ putStrLn ("Cur Time: " ++ show t)
--   </pre>
--   
--   This is sometimes known as do-while-do. Note that like other monad
--   transformers, you'll either need to explicitly lift the actions from
--   the transformed monad, or use an mtl-style type-class to do so.
module Control.Monad.LoopWhile

-- | A monad transformer for easier looping. See <a>loop</a> and
--   <a>while</a>.
data LoopWhileT m a

-- | Runs the given action in a loop, executing it repeatedly until a
--   <a>while</a> statement inside it has a False condition. If you use
--   <a>loop</a> without <a>while</a>, the effect is the same as
--   <tt>forever</tt>.
loop :: Monad m => LoopWhileT m a -> m ()

-- | Continues executing the loop if the given value is True. If the value
--   is False, the loop is broken immediately, and control returns to the
--   caller of the <a>loop</a> statement. Thus you can build pre-condition,
--   post-condition, and "mid-condition" loops, placing the condition
--   wherever you like.
while :: Monad m => Bool -> LoopWhileT m ()
instance MonadIO m => MonadIO (LoopWhileT m)
instance MonadTrans LoopWhileT
instance Monad m => Applicative (LoopWhileT m)
instance Monad m => Functor (LoopWhileT m)
instance Monad m => Monad (LoopWhileT m)
