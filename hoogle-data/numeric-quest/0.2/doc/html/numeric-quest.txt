-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Math and quantum mechanics
--   
--   List based linear algebra, similtaneous linear equations, eigenvalues
--   and eigenvectors, roots of polynomials, transcendent functions with
--   arbitrary precision implemented by continued fractions, quantum
--   operations, tensors
@package numeric-quest
@version 0.2

module Tensor
data Tensor
S :: Double -> Tensor
T :: [Tensor] -> Tensor
rank :: Tensor -> Int
dims :: Int
showList' :: Show t => Int -> [t] -> String -> String
tensor :: [Double] -> Tensor
(#) :: Tensor -> Int -> Tensor
(##) :: Tensor -> [Int] -> Tensor
scalar :: Tensor -> Double
vector :: Tensor -> [Double]
epsilon' :: Int -> Int -> Int -> Double
delta' :: Int -> Int -> Double
delta, epsilon :: Tensor
dot :: Tensor -> Tensor -> Tensor
cross' :: Tensor -> Tensor -> Int -> Double
cross :: Tensor -> Tensor -> Tensor
contract :: Int -> Int -> Tensor -> Tensor
(<*>) :: Tensor -> Tensor -> Tensor
(<<*>>) :: Tensor -> Tensor -> Tensor
d_standard :: Tensor
d_simpler :: Tensor
instance Num Tensor
instance Eq Tensor
instance Show Tensor

module Roots
roots :: RealFloat a => a -> Int -> [Complex a] -> [Complex a]
laguerre :: RealFloat a => a -> Int -> [Complex a] -> Complex a -> Complex a
polynomial_value :: Num a => [a] -> a -> a
polynomial_derivative :: Num a => [a] -> [a]

module Fraction
data Fraction
(:-:) :: Integer -> Integer -> Fraction
num, den :: Fraction -> Integer
reduce :: Fraction -> Fraction
(//) :: Integer -> Integer -> Fraction
approx :: Fraction -> Fraction -> Fraction
numericEnumFrom :: Real a => a -> [a]
numericEnumFromThen :: Real a => a -> a -> [a]
numericEnumFromTo :: Real a => a -> a -> [a]
numericEnumFromThenTo :: Real a => a -> a -> a -> [a]
type CF = [(Fraction, Fraction)]
fromCF :: CF -> Fraction
toCF :: Fraction -> CF
approxCF :: Fraction -> CF -> Fraction
fromTaylorToCF :: Fractional a => [a] -> a -> [(a, a)]
fromFraction :: Fraction -> Double
fac :: Integer -> Integer
integerRoot2 :: Integer -> Integer
class Transcendental a
pi' :: Transcendental a => Fraction -> a
tan' :: Transcendental a => Fraction -> a -> a
sin' :: Transcendental a => Fraction -> a -> a
cos' :: Transcendental a => Fraction -> a -> a
atan' :: Transcendental a => Fraction -> a -> a
asin' :: Transcendental a => Fraction -> a -> a
acos' :: Transcendental a => Fraction -> a -> a
sqrt' :: Transcendental a => Fraction -> a -> a
root' :: Transcendental a => Fraction -> a -> Integer -> a
power' :: Transcendental a => Fraction -> a -> a -> a
exp' :: Transcendental a => Fraction -> a -> a
tanh' :: Transcendental a => Fraction -> a -> a
sinh' :: Transcendental a => Fraction -> a -> a
cosh' :: Transcendental a => Fraction -> a -> a
atanh' :: Transcendental a => Fraction -> a -> a
asinh' :: Transcendental a => Fraction -> a -> a
acosh' :: Transcendental a => Fraction -> a -> a
log' :: Transcendental a => Fraction -> a -> a
decimal :: Transcendental a => Integer -> a -> IO ()
instance Eq Fraction
instance Transcendental Fraction
instance Enum Fraction
instance RealFrac Fraction
instance Real Fraction
instance Fractional Fraction
instance Num Fraction
instance Ord Fraction
instance Show Fraction
instance Read Fraction

module Orthogonals
bra_ket :: (Scalar a, Num a) => [a] -> [a] -> a
class Eq a => Scalar a
coupled :: Scalar a => a -> a
norm :: Scalar a => [a] -> a
almostZero :: Scalar a => a -> Bool
scaled :: Scalar a => [a] -> [a]
norm1 :: Num a => [a] -> a
norminf :: (Num a, Ord a) => [a] -> a
matnorm1 :: (Num a, Ord a) => [[a]] -> a
matnorminf :: (Num a, Ord a) => [[a]] -> a
sum_product :: Num a => [a] -> [a] -> a
normalized :: (Scalar a, Fractional a) => [a] -> [a]
scaled' :: (Fractional t, Ord t) => [t] -> [t]
transposed :: [[a]] -> [[a]]
adjoint :: Scalar a => [[a]] -> [[a]]
matrix_zipWith :: (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
add_matrices :: Num a => t -> t1 -> [[a]] -> [[a]] -> [[a]]
matrix_matrix :: Num a => [[a]] -> [[a]] -> [[a]]
matrix_matrix' :: Num a => [[a]] -> [[a]] -> [[a]]
triangle_matrix' :: Num a => [[a]] -> [[a]] -> [[a]]
matrix_ket :: Num a => [[a]] -> [a] -> [a]
bra_matrix :: (Scalar a, Num a) => [a] -> [[a]] -> [a]
bra_matrix_ket :: (Scalar a, Num a) => [a] -> [[a]] -> [a] -> a
scalar_matrix :: Num a => a -> [[a]] -> [[a]]
orthogonals :: (Scalar a, Fractional a) => [a] -> [[a]]
gram_schmidt :: (Scalar a, Fractional a) => [[a]] -> [a] -> [a]
one_ket_triangle :: (Scalar a, Fractional a) => [[a]] -> [a] -> [([a], a)]
one_ket_solution :: (Scalar a, Fractional a) => [[a]] -> [a] -> [a]
many_kets_triangle :: (Scalar a, Fractional a) => [[a]] -> [[a]] -> [([a], [a])]
many_kets_solution :: (Scalar a, Fractional a) => [[a]] -> [[a]] -> [[a]]
inverse :: (Scalar a, Fractional a) => [[a]] -> [[a]]
factors_QR :: (Scalar a, Fractional a) => [[a]] -> ([[a]], [[a]])
determinant :: (Scalar a, Fractional a) => [[a]] -> a
determinantNaive :: Num a => [[a]] -> a
determinantClow :: Num a => [[a]] -> a
newClow :: Num a => [[a]] -> [[a]] -> [a]
extendClow :: Num a => [[a]] -> [[a]] -> [[a]]
longerClow :: Num a => [[a]] -> [[a]] -> [[a]]

-- | Compositional power of a function, i.e. apply the function n times to
--   a value.
nest :: Int -> (a -> a) -> a -> a
removeEach :: [a] -> [[a]]
alternate :: Num a => [a] -> [a]
parityFlip :: Num a => Int -> a -> a

-- | Weight a list of numbers by a scalar.
scaleVec :: Num a => a -> [a] -> [a]

-- | Add corresponding numbers of two lists.
addVec :: Num a => [a] -> [a] -> [a]

-- | Add some lists.
sumVec :: Num a => [[a]] -> [a]
similar_to :: (Scalar a, Fractional a) => [[a]] -> [[a]]
iterated_eigenvalues :: (Scalar a1, Fractional a1, Eq a, Num a) => [[a1]] -> a -> [[a1]]
eigenvalues :: (Scalar a1, Fractional a1, Eq a, Num a) => [[a1]] -> a -> [a1]
add_to_diagonal :: Num a => a -> [[a]] -> [[a]]
eigenkets :: (Scalar a, Fractional a) => [[a]] -> [a] -> [[a]]
eigenket' :: (Scalar a, Fractional a) => [[a]] -> a -> a -> [a] -> [a]
unit_matrix :: Num a => Int -> [[a]]
unit_vector :: Num a => Int -> Int -> [a]
diagonals :: [[a]] -> [a]
instance RealFloat a => Scalar (Complex a)
instance Integral a => Scalar (Ratio a)
instance Scalar Float
instance Scalar Double

module EigensystemNum
mult :: Num a => [[a]] -> [[a]] -> [[a]]
matSqr :: Num a => [[a]] -> [[a]]
powerIter :: (Fractional a, Ord a) => [[a]] -> [([[a]], [[a]])]
normalize :: (Fractional a, Ord a) => [[a]] -> [[a]]
getGrowth :: (Fractional a, Ord a) => ([[a]], [[a]]) -> a
specRadApprox :: (Fractional a, Ord a) => [[a]] -> [a]
eigenValuesApprox :: (Scalar a, Fractional a) => [[a]] -> [[a]]
limit :: (Num a, Ord a) => a -> [a] -> a

module LinearAlgorithms
triangular :: Int -> [[Scalar]] -> [[Scalar]]
triangular2 :: Int -> [[Scalar]] -> ([[Scalar]], [[Scalar]])
tridiagonal :: [[Scalar]] -> [[Scalar]]
tridiagonal2 :: [[Scalar]] -> ([[Scalar]], [[Scalar]])
type Scalar = Complex Double

module QuantumVector
class DiracVector a where dimension x = length (basis x) normalize x | normx == 0 = x | otherwise = compose cs (basis x) where cs = [a * v :+ b * v | a :+ b <- components x] v = 1 / normx normx = norm x
add :: DiracVector a => a -> a -> a
scale :: DiracVector a => Scalar -> a -> a
reduce :: DiracVector a => a -> a
basis :: DiracVector a => a -> [a]
components :: DiracVector a => a -> [Scalar]
compose :: DiracVector a => [Scalar] -> [a] -> a
dimension :: DiracVector a => a -> Int
norm :: DiracVector a => a -> Double
normalize :: DiracVector a => a -> a
type Scalar = Complex Double
data Ket a
KetZero :: Ket a
Ket :: a -> Ket a
(:|>) :: Scalar -> Ket a -> Ket a
(:+>) :: Ket a -> Ket a -> Ket a
(*>) :: (Ord a, Ord b) => Ket a -> Ket b -> Ket (Tuple a b)
(|>) :: Ord a => Scalar -> Ket a -> Ket a
(+>) :: Ord a => Ket a -> Ket a -> Ket a
reduceKet :: Ord a => Ket a -> Ket a
ketBasis :: Ord a => Ket a -> [Ket a]
toBra :: Ord a => Ket a -> Bra a
data Bra a
BraZero :: Bra a
Bra :: a -> Bra a
(:<|) :: Scalar -> Bra a -> Bra a
(:<+) :: Bra a -> Bra a -> Bra a
(<*) :: (Ord a, Ord b) => Bra a -> Bra b -> Bra (Tuple a b)
(<|) :: Ord a => Scalar -> Bra a -> Bra a
(<+) :: Ord a => Bra a -> Bra a -> Bra a
reduceBra :: Ord a => Bra a -> Bra a
braBasis :: Ord a => Bra a -> [Bra a]
toKet :: Ord a => Bra a -> Ket a
(<>) :: Ord a => Bra a -> Ket a -> Scalar
d :: Eq a => a -> a -> Scalar
closure :: (DiracVector a, DiracVector b) => (a -> b) -> a -> b
(><) :: (DiracVector b, DiracVector a) => (a -> b) -> a -> b
label :: t -> Ket t1 -> Ket (t, t1)
rot :: Ket Int -> Ket (Int, Int)
label' :: (Ord a, Ord b) => Ket (a, b) -> Ket b
rot' :: Ket (Int, Int) -> Ket (Int)
showsScalar :: (Show t, RealFloat t) => Int -> Complex t -> String -> String
data Tuple a b
(:*) :: a -> b -> Tuple a b
instance (Eq a, Eq b) => Eq (Tuple a b)
instance (Ord a, Ord b) => Ord (Tuple a b)
instance (Show a, Show b) => Show (Tuple a b)
instance (Show a, Eq a, Ord a) => Show (Bra a)
instance (Show a, Eq a, Ord a) => Show (Ket a)
instance Ord a => DiracVector (Bra a)
instance (Eq a, Ord a) => Eq (Bra a)
instance Ord a => DiracVector (Ket a)
instance (Eq a, Ord a) => Eq (Ket a)

module Eigensystem
eigenvalues :: Ord a => Bool -> Int -> [Ket a] -> (Ket a -> Ket a) -> [Scalar]
adjoint :: Ord a => [Ket a] -> (Ket a -> Ket a) -> (Ket a -> Ket a)
