-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Declarative routing for WAI.
--   
@package wai-routing
@version 0.11

module Network.Wai.Routing.Request
data RoutingReq
class HasCaptures a
captures :: HasCaptures a => a -> [(ByteString, ByteString)]
fromReq :: [(ByteString, ByteString)] -> Req -> RoutingReq
lookupCapture :: HasCaptures r => ByteString -> r -> [ByteString]
instance HasVault RoutingReq
instance HasCaptures RoutingReq
instance HasPath RoutingReq
instance HasQuery RoutingReq
instance HasCookies RoutingReq
instance HasHeaders RoutingReq
instance HasMethod RoutingReq
instance HasRequest RoutingReq


-- | <a>Predicate</a>s which are specific to <tt>wai-routing</tt>. Please
--   note that these can be freely combined with other predicates from
--   <tt>wai-predicates</tt>.
module Network.Wai.Routing.Predicate

-- | Request path parameters.
capture :: (HasCaptures r, FromByteString a) => ByteString -> Predicate r Error a

-- | Request path parameters.
hasCapture :: HasCaptures r => ByteString -> Predicate r Error ()

-- | <tt>param "foo"</tt> is equivalent to <tt>query "foo" .|. capture
--   "foo"</tt>
param :: (HasCaptures r, HasQuery r, FromByteString a) => ByteString -> Predicate r Error a
hasParam :: (HasCaptures r, HasQuery r) => ByteString -> Predicate r Error ()

module Network.Wai.Routing.Route

-- | The Routes monad is used to add routing declarations via
--   <a>addRoute</a> or one of <a>get</a>, <a>post</a>, etc.
data Routes a m b

-- | Similar to a WAI <a>Application</a> but for <a>RoutingReq</a> and not
--   specific to <tt>IO</tt>.
type App m = RoutingReq -> Continue m -> m ResponseReceived

-- | The WAI 3.0 application continuation for arbitrary <tt>m</tt> instead
--   of <tt>IO</tt>.
type Continue m = Response -> m ResponseReceived

-- | Data added to a route via <a>attach</a> is returned in this
--   <tt>Meta</tt> record.
data Meta a
Meta :: !Method -> !ByteString -> a -> Meta a
routeMethod :: Meta a -> !Method
routePath :: Meta a -> !ByteString
routeMeta :: Meta a -> a

-- | Run the <a>Routes</a> monad and return the handlers per path.
prepare :: Monad m => Routes a m b -> [(ByteString, App m)]

-- | Routes requests to handlers based on predicated route declarations.
--   Note that <tt>route (prepare ...)</tt> behaves like a WAI
--   <a>Application</a> generalised to arbitrary monads.
route :: Monad m => [(ByteString, App m)] -> Request -> Continue m -> m ResponseReceived

-- | Prior to WAI 3.0 applications returned a plain <a>Response</a>.
--   <tt>continue</tt> turns such a function into a corresponding CPS
--   version. For example:
--   
--   <pre>
--   sitemap :: Monad m =&gt; Routes a m ()
--   sitemap = do
--       get "/f/:foo" (<i>continue</i> f) $ capture "foo"
--       get "/g/:foo" g            $ capture "foo"
--   
--   f :: Monad m =&gt; Int -&gt; m Response
--   f x = ...
--   
--   g :: Monad m =&gt; Int -&gt; Continue m -&gt; m ResponseReceived
--   g x k = k $ ...
--   </pre>
continue :: Monad m => (a -> m Response) -> a -> Continue m -> m ResponseReceived

-- | Add a route for some <a>Method</a> and path (potentially with variable
--   captures) and constrained by some <a>Predicate</a>.
--   
--   A route handler is like a WAI <a>Application</a> but instead of
--   <a>Request</a> the first parameter is the result-type of the
--   associated <a>Predicate</a> evaluation. I.e. the handler is applied to
--   the predicate's metadata value iff the predicate is true.
addRoute :: Monad m => Method -> ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Add some metadata to the last route.
attach :: a -> Routes a m ()

-- | Get back all attached metadata.
examine :: Routes a m b -> [Meta a]

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
get :: Monad m => ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
head :: Monad m => ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
post :: Monad m => ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
put :: Monad m => ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
delete :: Monad m => ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
trace :: Monad m => ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
options :: Monad m => ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
connect :: Monad m => ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
patch :: Monad m => ByteString -> (a -> Continue m -> m ResponseReceived) -> Predicate RoutingReq Error a -> Routes b m ()

-- | Function to turn an <a>Error</a> value into a <a>ByteString</a> to
--   send as the response body and a list of additional response headers.
--   Clients can provide their own renderer using <a>renderer</a>.
type Renderer = Error -> Maybe (ByteString, ResponseHeaders)

-- | Set a custom render function, i.e. a function to turn <a>Error</a>s
--   into <a>ByteString</a>s.
renderer :: Renderer -> Routes a m ()
instance Monad (Routes a m)
instance Applicative (Routes a m)
instance Functor (Routes a m)

module Network.Wai.Routing
class HasCaptures a
captures :: HasCaptures a => a -> [(ByteString, ByteString)]
