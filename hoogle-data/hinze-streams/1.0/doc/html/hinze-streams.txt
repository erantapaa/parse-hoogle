-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Streams and Unique Fixed Points
--   
--   Numeric instances for infinite streams. An implementation of:
--   
--   <i>Functional Pearl: Streams and Unique Fixed Points</i>, Ralf Hinze,
--   University of Oxford
--   
--   Streams, infinite sequences of elements, live in a coworld: they are
--   given by a coinductive data type, operations on streams are
--   implemented by corecursive programs, and proofs are conducted using
--   coinduction. But there is more to it: suitably restricted, stream
--   equations possess unique solutions, a fact that is not very widely
--   appreciated. We show that this property gives rise to a simple and
--   attractive proof technique essentially bringing equational reasoning
--   to the coworld. In fact, we redevelop the theory of recurrences,
--   finite calculus and generating functions using streams and stream
--   operators building on the cornerstone of unique solutions. The
--   development is constructive: streams and stream operators are
--   implemented in Haskell, usually by one-liners. The resulting calculus
--   or library, if you wish, is elegant and fun to use. Finally, we
--   rephrase the proof of uniqueness using generalised algebraic data
--   types.
--   
--   Along with the usual instances for infinite streams, this provides:
--   Num, Enum, Real, Fractional, as well as recurrences on streams, finite
--   calculus, generators
@package hinze-streams
@version 1.0


-- | Adds a few useful operators/functions to |Num|.
module Data.Stream.Hinze.NumExt
class (Num a, Ord a) => NumExt a
(/) :: (NumExt a) => a -> a -> a
(^) :: (NumExt a) => a -> a -> a
fact :: (NumExt a) => a -> a
fall :: (NumExt a) => a -> a -> a
choose :: (NumExt a) => a -> a -> a
instance (NumExt a, Integral a) => NumExt (Ratio a)
instance NumExt Integer

module Data.Stream.Hinze.Memo

-- | We could add functional dependencies |k -&gt; t| and |t -&gt; k|, but
--   since Haskell has a nominal type system there may be several
--   isomorphic key types that relate to the same table type (or vice
--   versa).
class Memo k t
tabulate :: (Memo k t) => (k -> a) -> t a
lookup :: (Memo k t) => t a -> (k -> a)
dom :: (Memo k t) => t k

module Data.Stream.Hinze.Idiom

-- | A reimplementation of the classic <tt>idioms</tt> class, which is now
--   known as Applicative.
class Idiom f
pure :: (Idiom f) => a -> f a
(<>) :: (Idiom f) => f (a -> b) -> (f a -> f b)
repeat :: (Idiom f) => a -> f a
map :: (Idiom f) => (a -> b) -> (f a -> f b)
zip :: (Idiom f) => (a -> b -> c) -> (f a -> f b -> f c)


-- | Functional Pearl: Streams and Unique Fixed Points Ralf Hinze The 13th
--   ACM SIGPLAN International Conference on Functional Programming (ICFP
--   2008) Victoria, British Columbia, Canada, September 22-24, 2008
--   
--   Streams, infinite sequences of elements, live in a coworld: they are
--   given by a coinductive data type, operations on streams are
--   implemented by corecursive programs, and proofs are conducted using
--   coinduction. But there is more to it: suitably restricted, stream
--   equations possess unique solutions, a fact that is not very widely
--   appreciated. We show that this property gives rise to a simple and
--   attractive proof technique essentially bringing equational reasoning
--   to the coworld. In fact, we redevelop the theory of recurrences,
--   finite calculus and generating functions using streams and stream
--   operators building on the cornerstone of unique solutions. The
--   development is constructive: streams and stream operators are
--   implemented in Haskell, usually by one-liners. The resulting calculus
--   or library, if you wish, is elegant and fun to use. Finally, we
--   rephrase the proof of uniqueness using generalised algebraic data
--   types.
--   
--   Particularly elegant examples are obtained using n+k patterns!
--   
--   New instances are added for:
--   
--   Memo, Idiom, Num (!), Enum, Integral, Fractional, NumExt
--   
--   The great contribution of this pearl are coherent numeric instances
--   for infinite streams, given by:
--   
--   <pre>
--   (+)              =  zip (+)
--   (-)              =  zip (-)
--   (*)              =  zip (*)
--   negate           =  map negate
--   abs              =  map abs
--   signum           =  map signum
--   toEnum i         =  repeat (toEnum i)
--   div              =  zip div
--   mod              =  zip mod
--   quotRem s t      =  unzip (zip quotRem s t)
--   fromInteger      =  repeat . fromInteger
--   s / t            =  zip (Prelude./) s t
--   recip s          =  map recip s
--   fromRational r   =  repeat (fromRational r)
--   (^)              =  zip (^)
--   (/)              =  zip (/)
--   fact             =  map fact
--   fall             =  zip fall
--   choose           =  zip choose
--   </pre>
module Data.Stream.Hinze.Stream

-- | Cons for streams
(<:) :: a -> Stream a -> Stream a

-- | unzip two streams
unzip :: Stream (a, b) -> (Stream a, Stream b)
(\/) :: Stream a -> Stream a -> Stream a
iterate :: (a -> a) -> (a -> Stream a)
(<<) :: [a] -> Stream a -> Stream a
nat :: Stream Integer
nat' :: Stream Integer
fac :: Stream Integer
fib :: Stream Integer
fib' :: Stream Integer
fib'' :: Stream Integer
fibv :: Stream Integer
bin :: Stream Integer
msb :: Stream Integer
ones :: Stream Integer
ones' :: Stream Integer
onesv :: Stream Integer
carry :: Stream Integer
frac :: Stream Integer
god :: Stream Integer
jos :: Stream Integer
pot :: Stream Bool
pot' :: Stream Bool
turn :: (Integral a) => a -> [a]
tree :: (Integral a) => a -> Stream a
diff :: (Num a) => Stream a -> Stream a
sum :: (Num a) => Stream a -> Stream a
sumv :: (Num a) => Stream a -> Stream a
const :: (Num a) => a -> Stream a
z :: (Num a) => Stream a
(**) :: (Num a) => Stream a -> Stream a -> Stream a
reciprocal :: (Fractional a) => Stream a -> Stream a
(//) :: (Fractional a) => Stream a -> Stream a -> Stream a
power :: (Fractional a, Integral b) => Stream a -> b -> Stream a
instance (NumExt a) => NumExt (Stream a)
instance (Fractional a) => Fractional (Stream a)
instance (Integral a) => Integral (Stream a)
instance (Real a) => Real (Stream a)
instance (Enum a) => Enum (Stream a)
instance (Num a) => Num (Stream a)
instance Idiom Stream
instance (Integral a) => Memo a Stream
