-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compile time generation of operation invariance tests for QuickCheck
--   
--   This package generates operation invariance tests for QuickCheck from
--   equation-based, QuickCheck-like properties at compile time. It
--   implements the approach from the paper "Automatic Testing of Operation
--   Invariance" presented at WFLP'14. The paper can be downloaded at
--   <a>http://www.iai.uni-bonn.de/~jv/GV14.html</a>.
@package qc-oi-testgenerator
@version 1.2.0.3


-- | This file should not be imported directly. Import
--   <a>Test.OITestGenerator</a> instead.
module Test.OITestGenerator.HasGens
class HasGens a
withGens :: HasGens a => a -> [Name] -> a


-- | This file should not be imported directly. Import
--   <a>Test.OITestGenerator</a> instead.
module Test.OITestGenerator.GenHelper
num_args_name :: Name -> Q Int
num_args :: Type -> Int
typeof :: Name -> TypeQ


-- | This file should not be imported directly. Import
--   <a>Test.OITestGenerator</a> instead.
module Test.OITestGenerator.Op
type Arg = Int

-- | An operation. Contains information about the operation's name, which
--   arguments may be tested (all by default), which generators should be
--   used for each argument (<tt>arbitrary</tt> by default) and possibly a
--   constraint function.
data Op

-- | <a>Op</a> constructor.
op :: Name -> Op

-- | <a>Arg</a> constructor. Only for readability.
arg :: Int -> Arg

-- | <tt>but o i</tt> excludes the <tt>i</tt>-th argument from <tt>o</tt>
--   when generating tests.
--   
--   Example:
--   
--   <pre>
--   op 'dequeue `but` arg 1
--   </pre>
but :: Op -> Arg -> Op

-- | <tt>only o i</tt> excludes all but the <tt>i</tt>-th argument from
--   <tt>o</tt> when generating tests.
--   
--   Example:
--   
--   <pre>
--   op 'dequeue `only` arg 1
--   </pre>
only :: Op -> Arg -> Op

-- | Use to specify custom generators for the given operation or axiom. The
--   <tt>i</tt>-th element of the list corresponds to the <tt>i</tt>-th
--   argument. All generators must be specified. Not using a custom
--   generator for specific arguments can be achieved by passing
--   <tt>arbitrary</tt>.
withGens :: HasGens a => a -> [Name] -> a

-- | <tt>op <a>withConstraint</a> f</tt> adds a constraint function
--   <tt>f</tt> to <tt>op</tt>. <tt>f</tt> must take arguments of the same
--   type as <tt>op</tt> and return a <a>Bool</a>.
withConstraint :: Op -> Name -> Op
op_name :: Op -> Name
op_args :: Op -> Q [Int]
op_gens :: Op -> Q [Name]
op_has_constraint :: Op -> Bool
op_constraint :: Op -> Name
op_maybe_constraint :: Op -> Maybe Name
instance HasGens Op


-- | This file should not be imported directly. Import
--   <a>Test.OITestGenerator</a> instead.
module Test.OITestGenerator.OpArg
data OpArg
opArg :: Name -> Int -> [Name] -> Maybe Name -> OpArg
opArg_name :: OpArg -> Name
opArg_argi :: OpArg -> Int
opArg_gens :: OpArg -> [Name]
opArg_has_constraint :: OpArg -> Bool
opArg_constraint :: OpArg -> Name
op2opArgs :: Op -> Q [OpArg]


-- | This file should not be imported directly. Import
--   <a>Test.OITestGenerator</a> instead.
module Test.OITestGenerator.Axiom
data Axiom

-- | <a>Axiom</a> constructor. Takes a <a>Name</a>, i.e.
--   
--   <pre>
--   axiom 'q1
--   </pre>
--   
--   or
--   
--   <pre>
--   map axiom ['q1, 'q2, 'q3]
--   </pre>
--   
--   .
axiom :: Name -> Axiom

-- | Use to specify custom generators for the given operation or axiom. The
--   <tt>i</tt>-th element of the list corresponds to the <tt>i</tt>-th
--   argument. All generators must be specified. Not using a custom
--   generator for specific arguments can be achieved by passing
--   <tt>arbitrary</tt>.
withGens :: HasGens a => a -> [Name] -> a
axiom_name :: Axiom -> Name
axiom_gens :: Axiom -> Q [Name]
data AxiomResult a
ar_cond :: AxiomResult a -> Bool
ar_lhs :: AxiomResult a -> a
ar_rhs :: AxiomResult a -> a

-- | Combine the results of the left- and right-hand sides of an axiom. A
--   simple example is
--   
--   <pre>
--   q1 :: AxiomResult Bool
--   q1 = isEmpty empty =!= True
--   </pre>
--   
--   while an axiom with variables would be written as a function like
--   this:
--   
--   <pre>
--   q2 :: Int -&gt; IntQueue -&gt; AxiomResult Bool
--   q2 x q = isEmpty (enqueue x q) =!= False
--   </pre>
(=!=) :: a -> a -> AxiomResult a

-- | Adds a condition to an axiom. If the <a>Bool</a> argument is
--   <a>False</a>, the axiom won't be evaluated. The test will neither
--   count as a failed test, nor as a successful test. It translates to the
--   QuickCheck operator <tt>==&gt;</tt>.
--   
--   Example usage:
--   
--   <pre>
--   q4 :: Int -&gt; IntQueue -&gt; AxiomResult Int
--   q4 x q = not (isEmpty q) ===&gt; front (enqueue x q) =!= front q
--   </pre>
(===>) :: Bool -> AxiomResult a -> AxiomResult a
instance HasGens Axiom


-- | This library is based on the following paper:
--   
--   <ul>
--   <li><i>Automatic Testing of Operation Invariance</i>, presented at
--   WFLP'14. <a>http://www.iai.uni-bonn.de/~jv/GV14.html</a></li>
--   </ul>
--   
--   A high-level explanation follows:
--   
--   (<a>QuickCheck</a>-)tests for data types are often formulated as
--   equations, e.g.
--   
--   <pre>
--   rev_test :: Property
--   rev_test = property $ \xs ys -&gt; reverse ys ++ reverse xs == reverse (xs ++ ys)
--   </pre>
--   
--   . There are assumptions everyone usually makes about the behaviour of
--   <tt>(==)</tt>, but does not necessarily think about:
--   
--   <ol>
--   <li><tt>x == x</tt> should always be <a>True</a> (reflexivity).</li>
--   <li>if <tt>x == y</tt> is <a>True</a>, <tt>y == x</tt> should also be
--   <a>True</a> (symmetry).</li>
--   <li>if <tt>x == y</tt> and <tt>y == z</tt> are <a>True</a>, <tt>x ==
--   z</tt> should also be <a>True</a> (transitivity).</li>
--   <li>if <tt>x == y</tt> is <a>True</a>, <tt>f x == f y</tt> should also
--   be <a>True</a> (congruence or operation invariance).</li>
--   </ol>
--   
--   It is unlikely to accidentally write an <a>Eq</a> instance that does
--   not satisfy 1.-3. Operation invariance however is fickle, as it also
--   implies sane behaviour of all functions on the data type.
--   
--   This framework takes <a>QuickCheck</a>-like equality tests (called
--   axioms) of a data type and functions on the data type (called
--   operations), and uses them to generate the corresponding
--   <a>QuickCheck</a> tests, as well as additional operation invariance
--   tests.
--   
--   For example, given a queue of integers <tt>IntQueue</tt> with the
--   following operations.
--   
--   <pre>
--   empty   :: IntQueue                    -- create an empty queue
--   isEmpty :: IntQueue -&gt; Bool            -- test if a given queue is empty
--   enqueue :: Int -&gt; IntQueue -&gt; IntQueue -- enqueue an integer to a queue
--   dequeue :: IntQueue -&gt; IntQueue        -- dequeue the first element of a queue
--   front   :: IntQueue -&gt; Int             -- get the first element of a queue
--   </pre>
--   
--   A <a>QuickCheck</a> test for this might be
--   
--   <pre>
--   property $ \x q -&gt; not (isEmpty q) ==&gt; dequeue (enqueue x q) == enqueue x (dequeue q)
--   </pre>
--   
--   while this would be formulated as an axiom for use with this package
--   as follows:
--   
--   <pre>
--   q6 x q = not (isEmpty q) ===&gt; dequeue (enqueue x q) =!= enqueue x (dequeue q)
--   </pre>
--   
--   Assuming you wrote six axioms <tt>q1</tt>-<tt>q6</tt>, the six
--   corresponding <a>QuickCheck</a> tests can be generated by
--   <a>generate_basic_tests</a>.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   ...
--   queue_basic_tests :: [Property]
--   queue_basic_tests = $(
--       let axs = map axiom ['q1, 'q2, 'q3, 'q4, 'q5, 'q6]
--       in generate_basic_tests axs)
--   </pre>
--   
--   The single quotes preceding <tt>q1</tt> to <tt>q6</tt> quote each
--   following name as a Template Haskell <a>Name</a>. Note that
--   <tt>$(...)</tt> is a Template Haskell splice and will be evaluated
--   during compile time. Because of this, you may not refer to
--   declarations of the same module except by name (this is called the
--   stage restriction), which is the motivation for the <tt>let ... in
--   ...</tt> construct.
--   
--   Additional operation invariance tests can be generated with
--   <a>generate_oi_tests</a>.
--   
--   <pre>
--   may_dequeue :: IntQueue -&gt; Bool
--   may_dequeue = not . isEmpty
--   
--   may_front :: IntQueue -&gt; Bool
--   may_front = not . isEmpty
--   
--   adt_oi_tests :: [Property]
--   adt_oi_tests = $(
--       let ops = [ op 'empty, op 'enqueue, op 'isEmpty
--                 , op 'dequeue `withConstraint` 'may_dequeue
--                 , op 'front `withConstraint` 'may_front
--                 ]
--           axs = map axiom ['q1, 'q2, 'q3, 'q4, 'q5, 'q6 ]
--       in generate_oi_tests axs ops)
--   </pre>
--   
--   For every operation <tt>f</tt> and every axiom <tt>lhs =!= rhs</tt>, a
--   test <tt>f lhs == f rhs</tt> will be generated if it is type correct.
--   Note that polymorphic types aren't supported yet, but you can simply
--   rename and specialize them, e.g.
--   
--   <pre>
--   reverse_ints :: [Int] -&gt; [Int]
--   reverse_ints = reverse
--   </pre>
--   
--   and test the renamed function. Besides type checking,
--   <a>generate_oi_tests</a> takes care of
--   
--   <ul>
--   <li>passing axiom arguments, e.g. <tt>f</tt> and <tt>ax x = lhs x =!=
--   rhs x</tt> will get translated to <tt>\x -&gt; f (lhs x) == f (rhs
--   x)</tt>.</li>
--   <li>multiple operation arguments, e.g. for an <tt>f :: A -&gt; A -&gt;
--   B -&gt; C</tt> and an axiom with result <tt>A</tt>, both tests <tt>f
--   lhs y z == f rhs y z</tt> and <tt>f x lhs z == f x rhs z</tt> will be
--   generated.</li>
--   <li>translating constraints of both axioms and operations to
--   <a>==&gt;</a>. Axiom constraints are specified via <a>===&gt;</a>,
--   while operation constraints are specified via
--   <a>withConstraint</a>.</li>
--   </ul>
module Test.OITestGenerator
data AxiomResult a

-- | Adds a condition to an axiom. If the <a>Bool</a> argument is
--   <a>False</a>, the axiom won't be evaluated. The test will neither
--   count as a failed test, nor as a successful test. It translates to the
--   QuickCheck operator <tt>==&gt;</tt>.
--   
--   Example usage:
--   
--   <pre>
--   q4 :: Int -&gt; IntQueue -&gt; AxiomResult Int
--   q4 x q = not (isEmpty q) ===&gt; front (enqueue x q) =!= front q
--   </pre>
(===>) :: Bool -> AxiomResult a -> AxiomResult a

-- | Combine the results of the left- and right-hand sides of an axiom. A
--   simple example is
--   
--   <pre>
--   q1 :: AxiomResult Bool
--   q1 = isEmpty empty =!= True
--   </pre>
--   
--   while an axiom with variables would be written as a function like
--   this:
--   
--   <pre>
--   q2 :: Int -&gt; IntQueue -&gt; AxiomResult Bool
--   q2 x q = isEmpty (enqueue x q) =!= False
--   </pre>
(=!=) :: a -> a -> AxiomResult a
data Axiom

-- | <a>Axiom</a> constructor. Takes a <a>Name</a>, i.e.
--   
--   <pre>
--   axiom 'q1
--   </pre>
--   
--   or
--   
--   <pre>
--   map axiom ['q1, 'q2, 'q3]
--   </pre>
--   
--   .
axiom :: Name -> Axiom
type Arg = Int

-- | An operation. Contains information about the operation's name, which
--   arguments may be tested (all by default), which generators should be
--   used for each argument (<tt>arbitrary</tt> by default) and possibly a
--   constraint function.
data Op

-- | <a>Op</a> constructor.
op :: Name -> Op

-- | <a>Arg</a> constructor. Only for readability.
arg :: Int -> Arg

-- | <tt>but o i</tt> excludes the <tt>i</tt>-th argument from <tt>o</tt>
--   when generating tests.
--   
--   Example:
--   
--   <pre>
--   op 'dequeue `but` arg 1
--   </pre>
but :: Op -> Arg -> Op

-- | <tt>only o i</tt> excludes all but the <tt>i</tt>-th argument from
--   <tt>o</tt> when generating tests.
--   
--   Example:
--   
--   <pre>
--   op 'dequeue `only` arg 1
--   </pre>
only :: Op -> Arg -> Op

-- | <tt>op <a>withConstraint</a> f</tt> adds a constraint function
--   <tt>f</tt> to <tt>op</tt>. <tt>f</tt> must take arguments of the same
--   type as <tt>op</tt> and return a <a>Bool</a>.
withConstraint :: Op -> Name -> Op

-- | Use to specify custom generators for the given operation or axiom. The
--   <tt>i</tt>-th element of the list corresponds to the <tt>i</tt>-th
--   argument. All generators must be specified. Not using a custom
--   generator for specific arguments can be achieved by passing
--   <tt>arbitrary</tt>.
withGens :: HasGens a => a -> [Name] -> a

-- | Generate all operation invariance tests that type check. For example,
--   given an operation
--   
--   <pre>
--   f :: A -&gt; A -&gt; B -&gt; C
--   </pre>
--   
--   and an axiom
--   
--   <pre>
--   ax :: D -&gt; AxiomResult A
--   ax x = lhs x =!= rhs x
--   </pre>
--   
--   the following tests are generated:
--   
--   <pre>
--   property $ \y2 y3 -&gt; f (lhs x) y2 y3 == f (rhs x) y2 y3
--   property $ \y1 y3 -&gt; f y1 (lhs x) y3 == f y1 (rhs x) y3
--   </pre>
--   
--   but not
--   
--   <pre>
--   property $ \y1 y2 -&gt; f y1 y2 (lhs x) == f y1 y2 (rhs x)
--   </pre>
--   
--   because of the types.
--   
--   All combinations of operations, their respective arguments and axioms
--   are tried.
--   
--   It returns an expression of type <tt>[Property]</tt>, i.e.
--   
--   <pre>
--   $(generate_oi_tests axs ops) :: [Property]
--   </pre>
generate_oi_tests :: [Axiom] -> [Op] -> ExpQ

-- | A convenience function for calling <a>generate_oi_tests</a> with only
--   one axiom.
--   
--   It returns an expression of type <tt>[Property]</tt>, i.e.
--   
--   <pre>
--   $(generate_axiom's_tests ax ops) :: [Property]
--   </pre>
generate_axiom's_tests :: Axiom -> [Op] -> ExpQ

-- | Calls <a>generate_oi_tests</a> with only the given <a>Axiom</a> and
--   <a>Op</a>. It checks if there is exactly one test that can be
--   generated and throws an error otherwise. If multiple applications of
--   the given operation to the given axioms are possible (i.e. it has
--   multiple arguments with a matching type), the allowed arguments have
--   to be restricted using <a>but</a> or <a>only</a>.
--   
--   It returns an expression of type <tt>Property</tt>, i.e.
--   
--   <pre>
--   $(generate_single_test ax op) :: Property
--   </pre>
generate_single_test :: Axiom -> Op -> ExpQ

-- | Derives one test from each <a>Axiom</a> by translating it to a
--   QuickCheck <a>Property</a>. This is done basically by replacing
--   <a>=!=</a> with <a>==</a> and <a>===&gt;</a> with <a>==&gt;</a>.
--   
--   It returns an expression of type <tt>[Property]</tt>, i.e.
--   
--   <pre>
--   $(generate_basic_tests axs) :: [Property]
--   </pre>
generate_basic_tests :: [Axiom] -> ExpQ

-- | <tt>show_all_tests Nothing axs ops</tt> returns a <a>String</a> typed
--   expression. Print the resulting string to get a piece of code,
--   containing one property for each possible operation invariance test,
--   defined via <a>generate_single_test</a>.
--   
--   The first argument can replace the default function generating a name
--   for each test, which is
--   
--   <pre>
--   \opn argi ax -&gt; opn ++ show argi ++ "_" ++ ax
--   </pre>
--   
--   . An example output looks like this:
--   
--   <pre>
--   enqueue1_q3 :: Property
--   enqueue1_q3 = $(generate_single_test (axiom 'q3) (op 'enqueue `only` 1))
--   </pre>
show_all_tests :: Maybe (String -> Int -> String -> String) -> [Name] -> [Name] -> ExpQ
