-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatic testing of Haskell programs
--   
@package QuickCheck
@version 2.8.1


-- | A wrapper around the system random number generator. Internal
--   QuickCheck module.
module Test.QuickCheck.Random
newTheGen :: IO TFGen
bits :: Integral a => a
doneBit :: Integral a => a
mask :: Integral a => a
chip :: Bool -> Word32 -> TFGen -> TFGen
chop :: Integer -> Integer
stop :: Integral a => a -> Bool
mkTheGen :: Int -> TFGen

-- | The "standard" QuickCheck random number generator. A wrapper around
--   either <a>TFGen</a> on GHC, or <a>StdGen</a> on other Haskell systems.
newtype QCGen
QCGen :: TFGen -> QCGen
newQCGen :: IO QCGen
mkQCGen :: Int -> QCGen
bigNatVariant :: Integer -> TFGen -> TFGen
natVariant :: Integral a => a -> TFGen -> TFGen
variantTheGen :: Integral a => a -> TFGen -> TFGen
boolVariant :: Bool -> TFGen -> TFGen
variantQCGen :: Integral a => a -> QCGen -> QCGen
instance RandomGen QCGen
instance Read QCGen
instance Show QCGen


-- | Throwing and catching exceptions. Internal QuickCheck module.
module Test.QuickCheck.Exception
type AnException = SomeException
tryEvaluate :: a -> IO (Either AnException a)
tryEvaluateIO :: IO a -> IO (Either AnException a)
evaluate :: a -> IO a

-- | Test if an exception was a <tt>^C</tt>. QuickCheck won't try to shrink
--   an interrupted test case.
isInterrupt :: AnException -> Bool

-- | A special exception that makes QuickCheck discard the test case.
--   Normally you should use <tt>==&gt;</tt>, but if for some reason this
--   isn't possible (e.g. you are deep inside a generator), use
--   <a>discard</a> instead.
discard :: a
isDiscard :: AnException -> Bool
finally :: IO a -> IO b -> IO a


-- | Terminal control. Internal QuickCheck module.
module Test.QuickCheck.Text
newtype Str
MkStr :: String -> Str
ranges :: (Show a, Integral a) => a -> a -> Str
number :: Int -> String -> String
short :: Int -> String -> String
showErr :: Show a => a -> String
oneLine :: String -> String
isOneLine :: String -> Bool
bold :: String -> String
newTerminal :: (String -> IO ()) -> (String -> IO ()) -> IO Terminal
withStdioTerminal :: (Terminal -> IO a) -> IO a
withNullTerminal :: (Terminal -> IO a) -> IO a
terminalOutput :: Terminal -> IO String
handle :: Handle -> String -> IO ()
data Terminal
putTemp :: Terminal -> String -> IO ()
putPart :: Terminal -> String -> IO ()
putLine :: Terminal -> String -> IO ()
instance Show Str


-- | QuickCheck's internal state. Internal QuickCheck module.
module Test.QuickCheck.State

-- | State represents QuickCheck's internal state while testing a property.
--   The state is made visible to callback functions.
data State
MkState :: Terminal -> Int -> Int -> (Int -> Int -> Int) -> !Int -> !Int -> !Int -> !(Map String Int) -> ![Set String] -> !Bool -> !QCGen -> !Int -> !Int -> !Int -> State

-- | the current terminal
terminal :: State -> Terminal

-- | maximum number of successful tests needed
maxSuccessTests :: State -> Int

-- | maximum number of tests that can be discarded
maxDiscardedTests :: State -> Int

-- | how to compute the size of test cases from discarded tests
computeSize :: State -> Int -> Int -> Int

-- | the current number of tests that have succeeded
numSuccessTests :: State -> !Int

-- | the current number of discarded tests
numDiscardedTests :: State -> !Int

-- | the number of discarded tests since the last successful test
numRecentlyDiscardedTests :: State -> !Int

-- | all labels that have been defined so far
labels :: State -> !(Map String Int)

-- | all labels that have been collected so far
collected :: State -> ![Set String]

-- | indicates if the property is expected to fail
expectedFailure :: State -> !Bool

-- | the current random seed
randomSeed :: State -> !QCGen

-- | number of successful shrinking steps so far
numSuccessShrinks :: State -> !Int

-- | number of failed shrinking steps since the last successful shrink
numTryShrinks :: State -> !Int

-- | total number of failed shrinking steps
numTotTryShrinks :: State -> !Int


-- | Test case generation.
module Test.QuickCheck.Gen

-- | A generator for values of type <tt>a</tt>.
newtype Gen a
MkGen :: (QCGen -> Int -> a) -> Gen a

-- | Run the generator on a particular seed. If you just want to get a
--   random value out, consider using <a>generate</a>.
unGen :: Gen a -> QCGen -> Int -> a

-- | Modifies a generator using an integer seed.
variant :: Integral n => n -> Gen a -> Gen a

-- | Used to construct generators that depend on the size parameter.
sized :: (Int -> Gen a) -> Gen a

-- | Overrides the size parameter. Returns a generator which uses the given
--   size instead of the runtime-size parameter.
resize :: Int -> Gen a -> Gen a

-- | Adjust the size parameter, by transforming it with the given function.
scale :: (Int -> Int) -> Gen a -> Gen a

-- | Generates a random element in the given inclusive range.
choose :: Random a => (a, a) -> Gen a

-- | Run a generator. The size passed to the generator is always 30; if you
--   want another size then you should explicitly use <a>resize</a>.
generate :: Gen a -> IO a

-- | Generates some example values.
sample' :: Gen a -> IO [a]

-- | Generates some example values and prints them to <tt>stdout</tt>.
sample :: Show a => Gen a -> IO ()

-- | Generates a value that satisfies a predicate.
suchThat :: Gen a -> (a -> Bool) -> Gen a

-- | Tries to generate a value that satisfies a predicate.
suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)

-- | Randomly uses one of the given generators. The input list must be
--   non-empty.
oneof :: [Gen a] -> Gen a

-- | Chooses one of the given generators, with a weighted random
--   distribution. The input list must be non-empty.
frequency :: [(Int, Gen a)] -> Gen a

-- | Generates one of the given values. The input list must be non-empty.
elements :: [a] -> Gen a

-- | Generates a random subsequence of the given list.
sublistOf :: [a] -> Gen [a]

-- | Generates a random permutation of the given list.
shuffle :: [a] -> Gen [a]

-- | Takes a list of elements of increasing size, and chooses among an
--   initial segment of the list. The size of this initial segment
--   increases with the size parameter. The input list must be non-empty.
growingElements :: [a] -> Gen a

-- | Generates a list of random length. The maximum length depends on the
--   size parameter.
listOf :: Gen a -> Gen [a]

-- | Generates a non-empty list of random length. The maximum length
--   depends on the size parameter.
listOf1 :: Gen a -> Gen [a]

-- | Generates a list of the given length.
vectorOf :: Int -> Gen a -> Gen [a]

-- | Generates an infinite list.
infiniteListOf :: Gen a -> Gen [a]
instance Monad Gen
instance Applicative Gen
instance Functor Gen


-- | Unsafe combinators for the <a>Gen</a> monad.
--   
--   <a>Gen</a> is only morally a monad: two generators that are supposed
--   to be equal will give the same probability distribution, but they
--   might be different as functions from random number seeds to values.
--   QuickCheck maintains the illusion that a <a>Gen</a> is a probability
--   distribution and does not allow you to distinguish two generators that
--   have the same distribution.
--   
--   The functions in this module allow you to break this illusion by
--   reusing the same random number seed twice. This is unsafe because by
--   applying the same seed to two morally equal generators, you can see
--   whether they are really equal or not.
module Test.QuickCheck.Gen.Unsafe

-- | Promotes a monadic generator to a generator of monadic values.
promote :: Monad m => m (Gen a) -> Gen (m a)

-- | Randomly generates a function of type <tt><a>Gen</a> a -&gt; a</tt>,
--   which you can then use to evaluate generators. Mostly useful in
--   implementing <a>promote</a>.
delay :: Gen (Gen a -> a)

-- | A variant of <a>delay</a> that returns a polymorphic evaluation
--   function. Can be used in a pinch to generate polymorphic (rank-2)
--   values:
--   
--   <pre>
--   genSelector :: Gen (a -&gt; a -&gt; a)
--   genSelector = elements [\x y -&gt; x, \x y -&gt; y]
--   
--   data Selector = Selector (forall a. a -&gt; a -&gt; a)
--   genPolySelector :: Gen Selector
--   genPolySelector = do
--     Capture eval &lt;- capture
--     return (Selector (eval genSelector))
--   </pre>
capture :: Gen Capture
newtype Capture
Capture :: (forall a. Gen a -> a) -> Capture


-- | Type classes for random generation of values.
module Test.QuickCheck.Arbitrary

-- | Random generation and shrinking of values.
class Arbitrary a where arbitrary = error "no default generator" shrink _ = []
arbitrary :: Arbitrary a => Gen a
shrink :: Arbitrary a => a -> [a]

-- | Used for random generation of functions.
--   
--   If you are using a recent GHC, there is a default definition of
--   <a>coarbitrary</a> using <a>genericCoarbitrary</a>, so if your type
--   has a <a>Generic</a> instance it's enough to say
--   
--   <pre>
--   instance CoArbitrary MyType
--   </pre>
--   
--   You should only use <a>genericCoarbitrary</a> for data types where
--   equality is structural, i.e. if you can't have two different
--   representations of the same value. An example where it's not safe is
--   sets implemented using binary search trees: the same set can be
--   represented as several different trees. Here you would have to
--   explicitly define <tt>coarbitrary s = coarbitrary (toList s)</tt>.
class CoArbitrary a where coarbitrary = genericCoarbitrary
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b

-- | Generates an integral number. The number can be positive or negative
--   and its maximum absolute value depends on the size parameter.
arbitrarySizedIntegral :: Integral a => Gen a

-- | Generates a natural number. The number's maximum value depends on the
--   size parameter.
arbitrarySizedNatural :: Integral a => Gen a

-- | Generates an integral number. The number is chosen uniformly from the
--   entire range of the type. You may want to use
--   <a>arbitrarySizedBoundedIntegral</a> instead.
arbitraryBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Generates an integral number from a bounded domain. The number is
--   chosen from the entire range of the type, but small numbers are
--   generated more often than big numbers. Inspired by demands from Phil
--   Wadler.
arbitrarySizedBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Generates a fractional number. The number can be positive or negative
--   and its maximum absolute value depends on the size parameter.
arbitrarySizedFractional :: Fractional a => Gen a

-- | Generates an element of a bounded type. The element is chosen from the
--   entire range of the type.
arbitraryBoundedRandom :: (Bounded a, Random a) => Gen a

-- | Generates an element of a bounded enumeration.
arbitraryBoundedEnum :: (Bounded a, Enum a) => Gen a

-- | Shrink a term to any of its immediate subterms, and also recursively
--   shrink all subterms.
genericShrink :: (Generic a, Arbitrary a, RecursivelyShrink (Rep a), GSubterms (Rep a) a) => a -> [a]

-- | All immediate subterms of a term.
subterms :: (Generic a, Arbitrary a, GSubterms (Rep a) a) => a -> [a]

-- | Recursively shrink all immediate subterms.
recursivelyShrink :: (Generic a, RecursivelyShrink (Rep a)) => a -> [a]

-- | Generic CoArbitrary implementation.
genericCoarbitrary :: (Generic a, GCoArbitrary (Rep a)) => a -> Gen b -> Gen b

-- | Returns no shrinking alternatives.
shrinkNothing :: a -> [a]

-- | Shrink a list of values given a shrinking function for individual
--   values.
shrinkList :: (a -> [a]) -> [a] -> [[a]]

-- | Shrink an integral number.
shrinkIntegral :: Integral a => a -> [a]

-- | Shrink a fraction.
shrinkRealFrac :: RealFrac a => a -> [a]

-- | Shrink a fraction, but only shrink to integral values.
shrinkRealFracToInteger :: RealFrac a => a -> [a]

-- | A <a>coarbitrary</a> implementation for integral numbers.
coarbitraryIntegral :: Integral a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for real numbers.
coarbitraryReal :: Real a => a -> Gen b -> Gen b

-- | <a>coarbitrary</a> helper for lazy people :-).
coarbitraryShow :: Show a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for enums.
coarbitraryEnum :: Enum a => a -> Gen b -> Gen b

-- | Combine two generator perturbing functions, for example the results of
--   calls to <a>variant</a> or <a>coarbitrary</a>.

-- | <i>Deprecated: Use ordinary function composition instead</i>
(><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)

-- | Generates a list of a given length.
vector :: Arbitrary a => Int -> Gen [a]

-- | Generates an ordered list of a given length.
orderedList :: (Ord a, Arbitrary a) => Gen [a]

-- | Generate an infinite list.
infiniteList :: Arbitrary a => Gen [a]
instance [overlap ok] [safe] CoArbitrary Double
instance [overlap ok] [safe] CoArbitrary Float
instance [overlap ok] [safe] CoArbitrary Char
instance [overlap ok] [safe] CoArbitrary Word64
instance [overlap ok] [safe] CoArbitrary Word32
instance [overlap ok] [safe] CoArbitrary Word16
instance [overlap ok] [safe] CoArbitrary Word8
instance [overlap ok] [safe] CoArbitrary Word
instance [overlap ok] [safe] CoArbitrary Int64
instance [overlap ok] [safe] CoArbitrary Int32
instance [overlap ok] [safe] CoArbitrary Int16
instance [overlap ok] [safe] CoArbitrary Int8
instance [overlap ok] [safe] CoArbitrary Int
instance [overlap ok] [safe] CoArbitrary Integer
instance [overlap ok] [safe] (CoArbitrary a, CoArbitrary b, CoArbitrary c, CoArbitrary d, CoArbitrary e) => CoArbitrary (a, b, c, d, e)
instance [overlap ok] [safe] (CoArbitrary a, CoArbitrary b, CoArbitrary c, CoArbitrary d) => CoArbitrary (a, b, c, d)
instance [overlap ok] [safe] (CoArbitrary a, CoArbitrary b, CoArbitrary c) => CoArbitrary (a, b, c)
instance [overlap ok] [safe] (CoArbitrary a, CoArbitrary b) => CoArbitrary (a, b)
instance [overlap ok] [safe] (RealFloat a, CoArbitrary a) => CoArbitrary (Complex a)
instance [overlap ok] [safe] HasResolution a => CoArbitrary (Fixed a)
instance [overlap ok] [safe] (Integral a, CoArbitrary a) => CoArbitrary (Ratio a)
instance [overlap ok] [safe] CoArbitrary a => CoArbitrary [a]
instance [overlap ok] [safe] (CoArbitrary a, CoArbitrary b) => CoArbitrary (Either a b)
instance [overlap ok] [safe] CoArbitrary a => CoArbitrary (Maybe a)
instance [overlap ok] [safe] CoArbitrary Ordering
instance [overlap ok] [safe] CoArbitrary Bool
instance [overlap ok] [safe] CoArbitrary ()
instance [overlap ok] [safe] (Arbitrary a, CoArbitrary b) => CoArbitrary (a -> b)
instance [overlap ok] [safe] CoArbitrary a => GCoArbitrary (K1 i a)
instance [overlap ok] [safe] GCoArbitrary f => GCoArbitrary (M1 i c f)
instance [overlap ok] [safe] (GCoArbitrary f, GCoArbitrary g) => GCoArbitrary (f :+: g)
instance [overlap ok] [safe] (GCoArbitrary f, GCoArbitrary g) => GCoArbitrary (f :*: g)
instance [overlap ok] [safe] GCoArbitrary U1
instance [overlap ok] [safe] Arbitrary Double
instance [overlap ok] [safe] Arbitrary Float
instance [overlap ok] [safe] Arbitrary Char
instance [overlap ok] [safe] Arbitrary Word64
instance [overlap ok] [safe] Arbitrary Word32
instance [overlap ok] [safe] Arbitrary Word16
instance [overlap ok] [safe] Arbitrary Word8
instance [overlap ok] [safe] Arbitrary Word
instance [overlap ok] [safe] Arbitrary Int64
instance [overlap ok] [safe] Arbitrary Int32
instance [overlap ok] [safe] Arbitrary Int16
instance [overlap ok] [safe] Arbitrary Int8
instance [overlap ok] [safe] Arbitrary Int
instance [overlap ok] [safe] Arbitrary Integer
instance [overlap ok] [safe] (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d, Arbitrary e) => Arbitrary (a, b, c, d, e)
instance [overlap ok] [safe] (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) => Arbitrary (a, b, c, d)
instance [overlap ok] [safe] (Arbitrary a, Arbitrary b, Arbitrary c) => Arbitrary (a, b, c)
instance [overlap ok] [safe] (Arbitrary a, Arbitrary b) => Arbitrary (a, b)
instance [overlap ok] [safe] HasResolution a => Arbitrary (Fixed a)
instance [overlap ok] [safe] (RealFloat a, Arbitrary a) => Arbitrary (Complex a)
instance [overlap ok] [safe] (Integral a, Arbitrary a) => Arbitrary (Ratio a)
instance [overlap ok] [safe] Arbitrary a => Arbitrary [a]
instance [overlap ok] [safe] (Arbitrary a, Arbitrary b) => Arbitrary (Either a b)
instance [overlap ok] [safe] Arbitrary a => Arbitrary (Maybe a)
instance [overlap ok] [safe] Arbitrary Ordering
instance [overlap ok] [safe] Arbitrary Bool
instance [overlap ok] [safe] Arbitrary ()
instance [overlap ok] [safe] (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)
instance [overlap ok] [safe] GSubtermsIncl (K1 i a) b
instance [overlap ok] [safe] Arbitrary a => GSubtermsIncl (K1 i a) a
instance [overlap ok] [safe] GSubtermsIncl f a => GSubtermsIncl (M1 i c f) a
instance [overlap ok] [safe] (GSubtermsIncl f a, GSubtermsIncl g a) => GSubtermsIncl (f :+: g) a
instance [overlap ok] [safe] (GSubtermsIncl f a, GSubtermsIncl g a) => GSubtermsIncl (f :*: g) a
instance [overlap ok] [safe] GSubtermsIncl U1 a
instance [overlap ok] [safe] GSubtermsIncl V1 a
instance [overlap ok] [safe] GSubterms (K1 i a) b
instance [overlap ok] [safe] GSubterms f a => GSubterms (M1 i c f) a
instance [overlap ok] [safe] (GSubtermsIncl f a, GSubtermsIncl g a) => GSubterms (f :+: g) a
instance [overlap ok] [safe] (GSubtermsIncl f a, GSubtermsIncl g a) => GSubterms (f :*: g) a
instance [overlap ok] [safe] GSubterms U1 a
instance [overlap ok] [safe] GSubterms V1 a
instance [overlap ok] [safe] RecursivelyShrink V1
instance [overlap ok] [safe] RecursivelyShrink U1
instance [overlap ok] [safe] Arbitrary a => RecursivelyShrink (K1 i a)
instance [overlap ok] [safe] RecursivelyShrink f => RecursivelyShrink (M1 i c f)
instance [overlap ok] [safe] (RecursivelyShrink f, RecursivelyShrink g) => RecursivelyShrink (f :+: g)
instance [overlap ok] [safe] (RecursivelyShrink f, RecursivelyShrink g) => RecursivelyShrink (f :*: g)


-- | Modifiers for test data.
--   
--   These types do things such as restricting the kind of test data that
--   can be generated. They can be pattern-matched on in properties as a
--   stylistic alternative to using explicit quantification.
--   
--   Examples:
--   
--   <pre>
--   -- Functions cannot be shown (but see <a>Test.QuickCheck.Function</a>)
--   prop_TakeDropWhile (<a>Blind</a> p) (xs :: [<tt>A</tt>]) =
--     takeWhile p xs ++ dropWhile p xs == xs
--   </pre>
--   
--   <pre>
--   prop_TakeDrop (<a>NonNegative</a> n) (xs :: [<tt>A</tt>]) =
--     take n xs ++ drop n xs == xs
--   </pre>
--   
--   <pre>
--   -- cycle does not work for empty lists
--   prop_Cycle (<a>NonNegative</a> n) (<a>NonEmpty</a> (xs :: [<tt>A</tt>])) =
--     take n (cycle xs) == take n (xs ++ cycle xs)
--   </pre>
--   
--   <pre>
--   -- Instead of <tt>forAll</tt> <a>orderedList</a>
--   prop_Sort (<a>Ordered</a> (xs :: [<tt>OrdA</tt>])) =
--     sort xs == xs
--   </pre>
module Test.QuickCheck.Modifiers

-- | <tt>Blind x</tt>: as x, but x does not have to be in the <a>Show</a>
--   class.
newtype Blind a
Blind :: a -> Blind a
getBlind :: Blind a -> a

-- | <tt>Fixed x</tt>: as x, but will not be shrunk.
newtype Fixed a
Fixed :: a -> Fixed a
getFixed :: Fixed a -> a

-- | <tt>Ordered xs</tt>: guarantees that xs is ordered.
newtype OrderedList a
Ordered :: [a] -> OrderedList a
getOrdered :: OrderedList a -> [a]

-- | <tt>NonEmpty xs</tt>: guarantees that xs is non-empty.
newtype NonEmptyList a
NonEmpty :: [a] -> NonEmptyList a
getNonEmpty :: NonEmptyList a -> [a]

-- | <tt>Positive x</tt>: guarantees that <tt>x &gt; 0</tt>.
newtype Positive a
Positive :: a -> Positive a
getPositive :: Positive a -> a

-- | <tt>NonZero x</tt>: guarantees that <tt>x /= 0</tt>.
newtype NonZero a
NonZero :: a -> NonZero a
getNonZero :: NonZero a -> a

-- | <tt>NonNegative x</tt>: guarantees that <tt>x &gt;= 0</tt>.
newtype NonNegative a
NonNegative :: a -> NonNegative a
getNonNegative :: NonNegative a -> a

-- | <tt>Large x</tt>: by default, QuickCheck generates <a>Int</a>s drawn
--   from a small range. <tt>Large Int</tt> gives you values drawn from the
--   entire range instead.
newtype Large a
Large :: a -> Large a
getLarge :: Large a -> a

-- | <tt>Small x</tt>: generates values of <tt>x</tt> drawn from a small
--   range. The opposite of <a>Large</a>.
newtype Small a
Small :: a -> Small a
getSmall :: Small a -> a

-- | <tt>Smart _ x</tt>: tries a different order when shrinking.
data Smart a
Smart :: Int -> a -> Smart a

-- | <tt>Shrink2 x</tt>: allows 2 shrinking steps at the same time when
--   shrinking x
newtype Shrink2 a
Shrink2 :: a -> Shrink2 a
getShrink2 :: Shrink2 a -> a

-- | <tt>Shrinking _ x</tt>: allows for maintaining a state during
--   shrinking.
data Shrinking s a
Shrinking :: s -> a -> Shrinking s a
class ShrinkState s a
shrinkInit :: ShrinkState s a => a -> s
shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
instance Eq a => Eq (Blind a)
instance Ord a => Ord (Blind a)
instance Num a => Num (Blind a)
instance Integral a => Integral (Blind a)
instance Real a => Real (Blind a)
instance Enum a => Enum (Blind a)
instance Eq a => Eq (Fixed a)
instance Ord a => Ord (Fixed a)
instance Show a => Show (Fixed a)
instance Read a => Read (Fixed a)
instance Num a => Num (Fixed a)
instance Integral a => Integral (Fixed a)
instance Real a => Real (Fixed a)
instance Enum a => Enum (Fixed a)
instance Eq a => Eq (OrderedList a)
instance Ord a => Ord (OrderedList a)
instance Show a => Show (OrderedList a)
instance Read a => Read (OrderedList a)
instance Eq a => Eq (NonEmptyList a)
instance Ord a => Ord (NonEmptyList a)
instance Show a => Show (NonEmptyList a)
instance Read a => Read (NonEmptyList a)
instance Eq a => Eq (Positive a)
instance Ord a => Ord (Positive a)
instance Show a => Show (Positive a)
instance Read a => Read (Positive a)
instance Enum a => Enum (Positive a)
instance Eq a => Eq (NonZero a)
instance Ord a => Ord (NonZero a)
instance Show a => Show (NonZero a)
instance Read a => Read (NonZero a)
instance Enum a => Enum (NonZero a)
instance Eq a => Eq (NonNegative a)
instance Ord a => Ord (NonNegative a)
instance Show a => Show (NonNegative a)
instance Read a => Read (NonNegative a)
instance Enum a => Enum (NonNegative a)
instance Eq a => Eq (Large a)
instance Ord a => Ord (Large a)
instance Show a => Show (Large a)
instance Read a => Read (Large a)
instance Num a => Num (Large a)
instance Integral a => Integral (Large a)
instance Real a => Real (Large a)
instance Enum a => Enum (Large a)
instance Eq a => Eq (Small a)
instance Ord a => Ord (Small a)
instance Show a => Show (Small a)
instance Read a => Read (Small a)
instance Num a => Num (Small a)
instance Integral a => Integral (Small a)
instance Real a => Real (Small a)
instance Enum a => Enum (Small a)
instance Eq a => Eq (Shrink2 a)
instance Ord a => Ord (Shrink2 a)
instance Show a => Show (Shrink2 a)
instance Read a => Read (Shrink2 a)
instance Num a => Num (Shrink2 a)
instance Integral a => Integral (Shrink2 a)
instance Real a => Real (Shrink2 a)
instance Enum a => Enum (Shrink2 a)
instance (Arbitrary a, ShrinkState s a) => Arbitrary (Shrinking s a)
instance Show a => Show (Shrinking s a)
instance Functor (Shrinking s)
instance Arbitrary a => Arbitrary (Smart a)
instance Show a => Show (Smart a)
instance Functor Smart
instance Arbitrary a => Arbitrary (Shrink2 a)
instance Functor Shrink2
instance Integral a => Arbitrary (Small a)
instance Functor Small
instance (Integral a, Bounded a) => Arbitrary (Large a)
instance Functor Large
instance (Num a, Ord a, Arbitrary a) => Arbitrary (NonNegative a)
instance Functor NonNegative
instance (Num a, Ord a, Arbitrary a) => Arbitrary (NonZero a)
instance Functor NonZero
instance (Num a, Ord a, Arbitrary a) => Arbitrary (Positive a)
instance Functor Positive
instance Arbitrary a => Arbitrary (NonEmptyList a)
instance Functor NonEmptyList
instance (Ord a, Arbitrary a) => Arbitrary (OrderedList a)
instance Functor OrderedList
instance Arbitrary a => Arbitrary (Fixed a)
instance Functor Fixed
instance Arbitrary a => Arbitrary (Blind a)
instance Show (Blind a)
instance Functor Blind


-- | Types to help with testing polymorphic properties.
--   
--   Types <a>A</a>, <a>B</a> and <a>C</a> are <tt>newtype</tt> wrappers
--   around <a>Integer</a> that implement <a>Eq</a>, <a>Show</a>,
--   <a>Arbitrary</a> and <a>CoArbitrary</a>. Types <a>OrdA</a>,
--   <a>OrdB</a> and <a>OrdC</a> also implement <a>Ord</a> and <a>Num</a>.
--   
--   See also <a>Test.QuickCheck.All</a> for an automatic way of testing
--   polymorphic properties.
module Test.QuickCheck.Poly
newtype A
A :: Integer -> A
unA :: A -> Integer
newtype B
B :: Integer -> B
unB :: B -> Integer
newtype C
C :: Integer -> C
unC :: C -> Integer
newtype OrdA
OrdA :: Integer -> OrdA
unOrdA :: OrdA -> Integer
newtype OrdB
OrdB :: Integer -> OrdB
unOrdB :: OrdB -> Integer
newtype OrdC
OrdC :: Integer -> OrdC
unOrdC :: OrdC -> Integer
instance Eq A
instance Eq B
instance Eq C
instance Eq OrdA
instance Ord OrdA
instance Num OrdA
instance Eq OrdB
instance Ord OrdB
instance Num OrdB
instance Eq OrdC
instance Ord OrdC
instance Num OrdC
instance CoArbitrary OrdC
instance Arbitrary OrdC
instance Show OrdC
instance CoArbitrary OrdB
instance Arbitrary OrdB
instance Show OrdB
instance CoArbitrary OrdA
instance Arbitrary OrdA
instance Show OrdA
instance CoArbitrary C
instance Arbitrary C
instance Show C
instance CoArbitrary B
instance Arbitrary B
instance Show B
instance CoArbitrary A
instance Arbitrary A
instance Show A


-- | Generation of random shrinkable, showable functions. See the paper
--   "Shrinking and showing functions" by Koen Claessen.
--   
--   Example of use:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   
--   &gt;&gt;&gt; let prop :: Fun String Integer -&gt; Bool
--   
--   &gt;&gt;&gt; prop (Fun _ f) = f "monkey" == f "banana" || f "banana" == f "elephant"
--   
--   &gt;&gt;&gt; :}
--   
--   &gt;&gt;&gt; quickCheck prop
--   *** Failed! Falsifiable (after 3 tests and 134 shrinks):
--   {"elephant"-&gt;1, "monkey"-&gt;1, _-&gt;0}
--   </pre>
--   
--   To generate random values of type <tt><a>Fun</a> a b</tt>, you must
--   have an instance <tt><a>Function</a> a</tt>. If your type has a
--   <a>Show</a> instance, you can use <a>functionShow</a> to write the
--   instance; otherwise, use <a>functionMap</a> to give a bijection
--   between your type and a type that is already an instance of
--   <a>Function</a>. See the <tt><a>Function</a> [a]</tt> instance for an
--   example of the latter.
module Test.QuickCheck.Function
data Fun a b
Fun :: (a :-> b, b) -> (a -> b) -> Fun a b
apply :: Fun a b -> (a -> b)

-- | The type of possibly partial concrete functions
data (:->) a c
class Function a
function :: Function a => (a -> b) -> (a :-> b)
functionMap :: Function b => (a -> b) -> (b -> a) -> (a -> c) -> (a :-> c)
functionShow :: (Show a, Read a) => (a -> c) -> (a :-> c)

-- | A pattern for matching against the function only:
--   
--   <pre>
--   prop :: Fun String Integer -&gt; Bool
--   prop (Fn f) = f "banana" == f "monkey"
--   </pre>
--   
--   || f "banana" == f "elephant"
instance (Function a, CoArbitrary a, Arbitrary b) => Arbitrary (Fun a b)
instance (Show a, Show b) => Show (Fun a b)
instance (Function a, CoArbitrary a, Arbitrary b) => Arbitrary (a :-> b)
instance Function OrdC
instance Function OrdB
instance Function OrdA
instance Function C
instance Function B
instance Function A
instance (Function a, Integral a) => Function (Ratio a)
instance Function Char
instance Function Int
instance Function Integer
instance Function Bool
instance Function a => Function (Maybe a)
instance Function a => Function [a]
instance (Function a, Function b, Function c, Function d, Function e, Function f, Function g) => Function (a, b, c, d, e, f, g)
instance (Function a, Function b, Function c, Function d, Function e, Function f) => Function (a, b, c, d, e, f)
instance (Function a, Function b, Function c, Function d, Function e) => Function (a, b, c, d, e)
instance (Function a, Function b, Function c, Function d) => Function (a, b, c, d)
instance (Function a, Function b, Function c) => Function (a, b, c)
instance (Function a, Function b) => Function (Either a b)
instance (Function a, Function b) => Function (a, b)
instance Function Word8
instance Function ()
instance (Show a, Show b) => Show (a :-> b)
instance Functor ((:->) a)


-- | Combinators for constructing properties.
module Test.QuickCheck.Property

-- | The type of properties.
--   
--   Backwards combatibility note: in older versions of QuickCheck
--   <a>Property</a> was a type synonym for <tt><a>Gen</a>
--   <a>Prop</a></tt>, so you could mix and match property combinators and
--   <a>Gen</a> monad operations. Code that does this will no longer
--   typecheck. However, it is easy to fix: because of the <a>Testable</a>
--   typeclass, any combinator that expects a <a>Property</a> will also
--   accept a <tt><a>Gen</a> <a>Property</a></tt>. If you have a
--   <a>Property</a> where you need a <tt><a>Gen</a> <tt>a</tt></tt>,
--   simply wrap the property combinator inside a <a>return</a> to get a
--   <tt><a>Gen</a> <a>Property</a></tt>, and all should be well.
newtype Property
MkProperty :: Gen Prop -> Property
unProperty :: Property -> Gen Prop

-- | The class of things which can be tested, i.e. turned into a property.
class Testable prop where exhaustive _ = False
property :: Testable prop => prop -> Property
exhaustive :: Testable prop => prop -> Bool

-- | If a property returns <a>Discard</a>, the current test case is
--   discarded, the same as if a precondition was false.
data Discard
Discard :: Discard

-- | Do I/O inside a property. This can obviously lead to unrepeatable
--   testcases, so use with care.

-- | <i>Deprecated: Use ioProperty instead</i>
morallyDubiousIOProperty :: Testable prop => IO prop -> Property

-- | Do I/O inside a property. This can obviously lead to unrepeatable
--   testcases, so use with care.
--   
--   For more advanced monadic testing you may want to look at
--   <a>Test.QuickCheck.Monadic</a>.
ioProperty :: Testable prop => IO prop -> Property
protect :: (AnException -> a) -> IO a -> IO a
newtype Prop
MkProp :: Rose Result -> Prop
unProp :: Prop -> Rose Result
data Rose a
MkRose :: a -> [Rose a] -> Rose a
IORose :: (IO (Rose a)) -> Rose a
ioRose :: IO (Rose Result) -> Rose Result
joinRose :: Rose (Rose a) -> Rose a

-- | Execute the <a>IORose</a> bits of a rose tree, returning a tree
--   constructed by MkRose.
reduceRose :: Rose Result -> IO (Rose Result)

-- | Apply a function to the outermost MkRose constructor of a rose tree.
--   The function must be total!
onRose :: (a -> [Rose a] -> Rose a) -> Rose a -> Rose a

-- | Wrap a rose tree in an exception handler.
protectRose :: IO (Rose Result) -> IO (Rose Result)

-- | Wrap all the Results in a rose tree in exception handlers.
protectResults :: Rose Result -> Rose Result

-- | Different kinds of callbacks
data Callback

-- | Called just after a test
PostTest :: CallbackKind -> (State -> Result -> IO ()) -> Callback

-- | Called with the final failing test-case
PostFinalFailure :: CallbackKind -> (State -> Result -> IO ()) -> Callback
data CallbackKind

-- | Affected by the <a>verbose</a> combinator
Counterexample :: CallbackKind

-- | Not affected by the <a>verbose</a> combinator
NotCounterexample :: CallbackKind

-- | The result of a single test.
data Result
MkResult :: Maybe Bool -> Bool -> String -> Maybe AnException -> Bool -> Map String Int -> Set String -> [Callback] -> Result

-- | result of the test case; Nothing = discard
ok :: Result -> Maybe Bool

-- | indicates what the expected result of the property is
expect :: Result -> Bool

-- | a message indicating what went wrong
reason :: Result -> String

-- | the exception thrown, if any
theException :: Result -> Maybe AnException

-- | if True, the test should not be repeated
abort :: Result -> Bool

-- | all labels used by this property
labels :: Result -> Map String Int

-- | the collected values for this test case
stamp :: Result -> Set String

-- | the callbacks for this test case
callbacks :: Result -> [Callback]
exception :: String -> AnException -> Result
formatException :: String -> AnException -> String
protectResult :: IO Result -> IO Result
succeeded :: Result
rejected :: Result
failed :: Result
liftBool :: Bool -> Result
mapResult :: Testable prop => (Result -> Result) -> prop -> Property
mapTotalResult :: Testable prop => (Result -> Result) -> prop -> Property
mapRoseResult :: Testable prop => (Rose Result -> Rose Result) -> prop -> Property
mapProp :: Testable prop => (Prop -> Prop) -> prop -> Property

-- | Changes the maximum test case size for a property.
mapSize :: Testable prop => (Int -> Int) -> prop -> Property

-- | Shrinks the argument to property if it fails. Shrinking is done
--   automatically for most types. This is only needed when you want to
--   override the default behavior.
shrinking :: Testable prop => (a -> [a]) -> a -> (a -> prop) -> Property

-- | Disables shrinking for a property altogether.
noShrinking :: Testable prop => prop -> Property

-- | Adds a callback
callback :: Testable prop => Callback -> prop -> Property

-- | Adds the given string to the counterexample.
counterexample :: Testable prop => String -> prop -> Property

-- | Adds the given string to the counterexample.

-- | <i>Deprecated: Use counterexample instead</i>
printTestCase :: Testable prop => String -> prop -> Property

-- | Performs an <a>IO</a> action after the last failure of a property.
whenFail :: Testable prop => IO () -> prop -> Property

-- | Performs an <a>IO</a> action every time a property fails. Thus, if
--   shrinking is done, this can be used to keep track of the failures
--   along the way.
whenFail' :: Testable prop => IO () -> prop -> Property

-- | Prints out the generated testcase every time the property is tested.
--   Only variables quantified over <i>inside</i> the <a>verbose</a> are
--   printed.
verbose :: Testable prop => prop -> Property

-- | Indicates that a property is supposed to fail. QuickCheck will report
--   an error if it does not fail.
expectFailure :: Testable prop => prop -> Property

-- | Modifies a property so that it only will be tested once.
once :: Testable prop => prop -> Property

-- | Attaches a label to a property. This is used for reporting test case
--   distribution.
label :: Testable prop => String -> prop -> Property

-- | Labels a property with a value:
--   
--   <pre>
--   collect x = label (show x)
--   </pre>
collect :: (Show a, Testable prop) => a -> prop -> Property

-- | Conditionally labels test case.
classify :: Testable prop => Bool -> String -> prop -> Property

-- | Checks that at least the given proportion of <i>successful</i> test
--   cases belong to the given class. Discarded tests (i.e. ones with a
--   false precondition) do not affect coverage.
cover :: Testable prop => Bool -> Int -> String -> prop -> Property

-- | Implication for properties: The resulting property holds if the first
--   argument is <a>False</a> (in which case the test case is discarded),
--   or if the given property holds.
(==>) :: Testable prop => Bool -> prop -> Property

-- | Considers a property failed if it does not complete within the given
--   number of microseconds.
within :: Testable prop => Int -> prop -> Property

-- | Explicit universal quantification: uses an explicitly given test case
--   generator.
forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property

-- | Like <a>forAll</a>, but tries to shrink the argument for failing test
--   cases.
forAllShrink :: (Show a, Testable prop) => Gen a -> (a -> [a]) -> (a -> prop) -> Property

-- | Nondeterministic choice: <tt>p1</tt> <a>.&amp;.</a> <tt>p2</tt> picks
--   randomly one of <tt>p1</tt> and <tt>p2</tt> to test. If you test the
--   property 100 times it makes 100 random choices.
(.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property

-- | Conjunction: <tt>p1</tt> <a>.&amp;&amp;.</a> <tt>p2</tt> passes if
--   both <tt>p1</tt> and <tt>p2</tt> pass.
(.&&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property

-- | Take the conjunction of several properties.
conjoin :: Testable prop => [prop] -> Property

-- | Disjunction: <tt>p1</tt> <a>.||.</a> <tt>p2</tt> passes unless
--   <tt>p1</tt> and <tt>p2</tt> simultaneously fail.
(.||.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property

-- | Take the disjunction of several properties.
disjoin :: Testable prop => [prop] -> Property

-- | Like <a>==</a>, but prints a counterexample when it fails.
(===) :: (Eq a, Show a) => a -> a -> Property
instance [safe] Monad Rose
instance [safe] Applicative Rose
instance [safe] Functor Rose
instance [safe] (Arbitrary a, Show a, Testable prop) => Testable (a -> prop)
instance [safe] Testable Property
instance [safe] Testable prop => Testable (Gen prop)
instance [safe] Testable Prop
instance [safe] Testable Result
instance [safe] Testable Bool
instance [safe] Testable Discard


-- | The main test loop.
module Test.QuickCheck.Test

-- | Args specifies arguments to the QuickCheck driver
data Args
Args :: Maybe (QCGen, Int) -> Int -> Int -> Int -> Bool -> Args

-- | Should we replay a previous test?
replay :: Args -> Maybe (QCGen, Int)

-- | Maximum number of successful tests before succeeding
maxSuccess :: Args -> Int

-- | Maximum number of discarded tests per successful test before giving up
maxDiscardRatio :: Args -> Int

-- | Size to use for the biggest test cases
maxSize :: Args -> Int

-- | Whether to print anything
chatty :: Args -> Bool

-- | Result represents the test result
data Result

-- | A successful test run
Success :: Int -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | Given up
GaveUp :: Int -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | A failed test run
Failure :: Int -> Int -> Int -> Int -> QCGen -> Int -> String -> Maybe AnException -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Number of successful shrinking steps performed
numShrinks :: Result -> Int

-- | Number of unsuccessful shrinking steps performed
numShrinkTries :: Result -> Int

-- | Number of unsuccessful shrinking steps performed since last successful
--   shrink
numShrinkFinal :: Result -> Int

-- | What seed was used
usedSeed :: Result -> QCGen

-- | What was the test size
usedSize :: Result -> Int

-- | Why did the property fail
reason :: Result -> String

-- | The exception the property threw, if any
theException :: Result -> Maybe AnException

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | A property that should have failed did not
NoExpectedFailure :: Int -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | The tests passed but a use of <a>cover</a> had insufficient coverage
InsufficientCoverage :: Int -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | Check if the test run result was a success
isSuccess :: Result -> Bool

-- | The default test arguments
stdArgs :: Args

-- | Tests a property and prints the results to <tt>stdout</tt>.
quickCheck :: Testable prop => prop -> IO ()

-- | Tests a property, using test arguments, and prints the results to
--   <tt>stdout</tt>.
quickCheckWith :: Testable prop => Args -> prop -> IO ()

-- | Tests a property, produces a test result, and prints the results to
--   <tt>stdout</tt>.
quickCheckResult :: Testable prop => prop -> IO Result

-- | Tests a property, using test arguments, produces a test result, and
--   prints the results to <tt>stdout</tt>.
quickCheckWithResult :: Testable prop => Args -> prop -> IO Result

-- | Tests a property and prints the results and all test cases generated
--   to <tt>stdout</tt>. This is just a convenience function that means the
--   same as <tt><a>quickCheck</a> . <a>verbose</a></tt>.
verboseCheck :: Testable prop => prop -> IO ()

-- | Tests a property, using test arguments, and prints the results and all
--   test cases generated to <tt>stdout</tt>. This is just a convenience
--   function that combines <a>quickCheckWith</a> and <a>verbose</a>.
verboseCheckWith :: Testable prop => Args -> prop -> IO ()

-- | Tests a property, produces a test result, and prints the results and
--   all test cases generated to <tt>stdout</tt>. This is just a
--   convenience function that combines <a>quickCheckResult</a> and
--   <a>verbose</a>.
verboseCheckResult :: Testable prop => prop -> IO Result

-- | Tests a property, using test arguments, produces a test result, and
--   prints the results and all test cases generated to <tt>stdout</tt>.
--   This is just a convenience function that combines
--   <a>quickCheckWithResult</a> and <a>verbose</a>.
verboseCheckWithResult :: Testable prop => Args -> prop -> IO Result
test :: State -> (QCGen -> Int -> Prop) -> IO Result
doneTesting :: State -> (QCGen -> Int -> Prop) -> IO Result
giveUp :: State -> (QCGen -> Int -> Prop) -> IO Result
runATest :: State -> (QCGen -> Int -> Prop) -> IO Result
summary :: State -> [(String, Int)]
success :: State -> IO ()
labelPercentage :: String -> State -> Int
insufficientCoverage :: State -> Bool
foundFailure :: State -> Result -> [Rose Result] -> IO (Int, Int, Int)
localMin :: State -> Result -> Result -> [Rose Result] -> IO (Int, Int, Int)
localMin' :: State -> Result -> [Rose Result] -> IO (Int, Int, Int)
localMinFound :: State -> Result -> IO (Int, Int, Int)
callbackPostTest :: State -> Result -> IO Result
callbackPostFinalFailure :: State -> Result -> IO ()
instance [safe] Show Args
instance [safe] Read Args
instance [safe] Show Result


-- | Test all properties in the current module, using Template Haskell. You
--   need to have a <tt>{-# LANGUAGE TemplateHaskell #-}</tt> pragma in
--   your module for any of these to work.
module Test.QuickCheck.All

-- | Test all properties in the current module. The name of the property
--   must begin with <tt>prop_</tt>. Polymorphic properties will be
--   defaulted to <a>Integer</a>. Returns <a>True</a> if all tests
--   succeeded, <a>False</a> otherwise.
--   
--   To use <a>quickCheckAll</a>, add a definition to your module along the
--   lines of
--   
--   <pre>
--   return []
--   runTests = $quickCheckAll
--   </pre>
--   
--   and then execute <tt>runTests</tt>.
--   
--   Note: the bizarre <tt>return []</tt> in the example above is needed on
--   GHC 7.8; without it, <a>quickCheckAll</a> will not be able to find any
--   of the properties. For the curious, the <tt>return []</tt> is a
--   Template Haskell splice that makes GHC insert the empty list of
--   declarations at that point in the program; GHC typechecks everything
--   before the <tt>return []</tt> before it starts on the rest of the
--   module, which means that the later call to <a>quickCheckAll</a> can
--   see everything that was defined before the <tt>return []</tt>. Yikes!
quickCheckAll :: Q Exp

-- | Test all properties in the current module. This is just a convenience
--   function that combines <a>quickCheckAll</a> and <a>verbose</a>.
--   
--   <a>verboseCheckAll</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
verboseCheckAll :: Q Exp

-- | Test all properties in the current module, using a custom
--   <a>quickCheck</a> function. The same caveats as with
--   <a>quickCheckAll</a> apply.
--   
--   <tt>$<a>forAllProperties</a></tt> has type <tt>(<a>Property</a> -&gt;
--   <a>IO</a> <a>Result</a>) -&gt; <a>IO</a> <a>Bool</a></tt>. An example
--   invocation is <tt>$<a>forAllProperties</a>
--   <a>quickCheckResult</a></tt>, which does the same thing as
--   <tt>$<a>quickCheckAll</a></tt>.
--   
--   <a>forAllProperties</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
forAllProperties :: Q Exp

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>.
--   
--   Invoke as <tt>$(<a>polyQuickCheck</a> 'prop)</tt>, where <tt>prop</tt>
--   is a property. Note that just evaluating <tt><a>quickCheck</a>
--   prop</tt> in GHCi will seem to work, but will silently default all
--   type variables to <tt>()</tt>!
--   
--   <tt>$(<a>polyQuickCheck</a> 'prop)</tt> means the same as
--   <tt><a>quickCheck</a> $(<a>monomorphic</a> 'prop)</tt>. If you want to
--   supply custom arguments to <a>polyQuickCheck</a>, you will have to
--   combine <a>quickCheckWith</a> and <a>monomorphic</a> yourself.
--   
--   If you want to use <a>polyQuickCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyQuickCheck :: Name -> ExpQ

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>. This is just a convenience function that combines
--   <a>verboseCheck</a> and <a>monomorphic</a>.
--   
--   If you want to use <a>polyVerboseCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyVerboseCheck :: Name -> ExpQ

-- | Monomorphise an arbitrary property by defaulting all type variables to
--   <a>Integer</a>.
--   
--   For example, if <tt>f</tt> has type <tt><a>Ord</a> a =&gt; [a] -&gt;
--   [a]</tt> then <tt>$(<a>monomorphic</a> 'f)</tt> has type
--   <tt>[<a>Integer</a>] -&gt; [<a>Integer</a>]</tt>.
--   
--   If you want to use <a>monomorphic</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
monomorphic :: Name -> ExpQ


-- | Allows testing of monadic values. Will generally follow this form:
--   
--   <pre>
--   prop_monadic a b = <a>monadicIO</a> $ do
--     a' &lt;- <a>run</a> (f a)
--     b' &lt;- <a>run</a> (f b)
--     -- ...
--     <a>assert</a> someBoolean
--   </pre>
--   
--   Example using the <tt>FACTOR(1)</tt> command-line utility:
--   
--   <pre>
--   import System.Process
--   import Test.QuickCheck
--   import Test.QuickCheck.Monadic
--   
--   -- $ factor 16
--   -- 16: 2 2 2 2
--   factor :: Integer -&gt; IO [Integer]
--   factor n = parse `fmap` <a>readProcess</a> "factor" [show n] "" where
--   
--     parse :: String -&gt; [Integer]
--     parse = map read . tail . words
--   
--   prop_factor :: Positive Integer -&gt; Property
--   prop_factor (<a>Positive</a> n) = <a>monadicIO</a> $ do
--     factors &lt;- <a>run</a> (factor n)
--   
--     <a>assert</a> (product factors == n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_factor
--   +++ OK, passed 100 tests.
--   </pre>
--   
--   See the paper "<a>Testing Monadic Code with QuickCheck</a>".
module Test.QuickCheck.Monadic

-- | The property monad is really a monad transformer that can contain
--   monadic computations in the monad <tt>m</tt> it is parameterized by:
--   
--   <ul>
--   <li><tt>m</tt> - the <tt>m</tt>-computations that may be performed
--   within <tt>PropertyM</tt></li>
--   </ul>
--   
--   Elements of <tt>PropertyM m a</tt> may mix property operations and
--   <tt>m</tt>-computations.
newtype PropertyM m a
MkPropertyM :: ((a -> Gen (m Property)) -> Gen (m Property)) -> PropertyM m a
unPropertyM :: PropertyM m a -> (a -> Gen (m Property)) -> Gen (m Property)

-- | The lifting operation of the property monad. Allows embedding
--   monadic/<a>IO</a>-actions in properties:
--   
--   <pre>
--   log :: Int -&gt; IO ()
--   
--   prop_foo n = monadicIO $ do
--     run (log n)
--     -- ...
--   </pre>
run :: Monad m => m a -> PropertyM m a

-- | Allows embedding non-monadic properties into monadic ones.
assert :: Monad m => Bool -> PropertyM m ()

-- | Tests preconditions. Unlike <a>assert</a> this does not cause the
--   property to fail, rather it discards them just like using the
--   implication combinator <a>==&gt;</a>.
--   
--   This allows representing the <a>Hoare triple</a>
--   
--   <pre>
--   {p} x ← e{q}
--   </pre>
--   
--   as
--   
--   <pre>
--   pre p
--   x &lt;- run e
--   assert q
--   </pre>
pre :: Monad m => Bool -> PropertyM m ()

-- | The <a>weakest precondition</a>
--   
--   <pre>
--   wp(x ← e, p)
--   </pre>
--   
--   can be expressed as in code as <tt>wp e (\x -&gt; p)</tt>.
wp :: Monad m => m a -> (a -> PropertyM m b) -> PropertyM m b

-- | Quantification in a monadic property, fits better with
--   <i>do-notation</i> than <a>forAllM</a>.
pick :: (Monad m, Show a) => Gen a -> PropertyM m a

-- | An alternative to quantification a monadic properties to <a>pick</a>,
--   with a notation similar to <a>forAll</a>.
forAllM :: (Monad m, Show a) => Gen a -> (a -> PropertyM m b) -> PropertyM m b

-- | Allows making observations about the test data:
--   
--   <pre>
--   monitor (<a>collect</a> e)
--   </pre>
--   
--   collects the distribution of value of <tt>e</tt>.
--   
--   <pre>
--   monitor (<a>counterexample</a> "Failure!")
--   </pre>
--   
--   Adds <tt>"Failure!"</tt> to the counterexamples.
monitor :: Monad m => (Property -> Property) -> PropertyM m ()
stop :: (Testable prop, Monad m) => prop -> PropertyM m a
monadic :: Monad m => (m Property -> Property) -> PropertyM m a -> Property
monadic' :: Monad m => PropertyM m a -> Gen (m Property)

-- | Runs the property monad for <a>IO</a>-computations.
--   
--   <pre>
--   prop_cat msg = monadicIO $ do
--     (exitCode, stdout, _) &lt;- run (<a>readProcessWithExitCode</a> "cat" [] msg)
--   
--     pre (<a>ExitSuccess</a> == exitCode)
--   
--     assert (stdout == msg)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_cat
--   +++ OK, passed 100 tests.
--   </pre>
monadicIO :: PropertyM IO a -> Property

-- | Runs the property monad for <a>ST</a>-computations.
--   
--   <pre>
--   -- Your mutable sorting algorithm here
--   sortST :: Ord a =&gt; [a] -&gt; <a>ST</a> s (MVector s a)
--   sortST = <a>thaw</a> . <a>fromList</a> . <a>sort</a>
--   
--   prop_sortST xs = monadicST $ do
--     sorted  &lt;- run (<a>freeze</a> =&lt;&lt; sortST xs)
--     assert (<a>toList</a> sorted == sort xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_sortST
--   +++ OK, passed 100 tests.
--   </pre>
monadicST :: (forall s. PropertyM (ST s) a) -> Property
runSTGen :: (forall s. Gen (ST s a)) -> Gen a
instance MonadIO m => MonadIO (PropertyM m)
instance MonadTrans PropertyM
instance Monad m => Monad (PropertyM m)
instance Monad m => Applicative (PropertyM m)
instance Functor (PropertyM m)


-- | For further information see the <a>QuickCheck manual</a>.
--   
--   To use QuickCheck to check a property, first define a function
--   expressing that property (functions expressing properties under test
--   tend to be prefixed with <tt>prop_</tt>). Testing that <tt>n + m = m +
--   n</tt> holds for <tt>Integer</tt>s one might write:
--   
--   <pre>
--   import Test.QuickCheck
--   
--   prop_commutativeAdd :: Integer -&gt; Integer -&gt; Bool
--   prop_commutativeAdd n m = n + m == m + n
--   </pre>
--   
--   and testing:
--   
--   <pre>
--   &gt;&gt;&gt; quickcheck prop_commutativeAdd
--   +++ OK, passed 100 tests.
--   </pre>
--   
--   which tests <tt>prop_commutativeAdd</tt> on 100 random <tt>(Integer,
--   Integer)</tt> pairs.
--   
--   <a>verboseCheck</a> can be used to see the actual values generated:
--   
--   <pre>
--   &gt;&gt;&gt; verboseCheck prop_commutativeAdd
--   Passed:
--   0
--   0
--     …98 tests omitted…
--   Passed:
--   -68
--   6
--   +++ OK, passed 100 tests.
--   </pre>
--   
--   and if more than 100 tests are needed the number of tests can be
--   increased by updating the <a>stdArgs</a> record:
--   
--   <pre>
--   &gt;&gt;&gt; quickCheckWith stdArgs { maxSuccess = 500 } prop_commutativeAdd
--   +++ OK, passed 500 tests.
--   </pre>
--   
--   To let QuickCheck generate values of your own data type an
--   <a>Arbitrary</a> instance must be defined:
--   
--   <pre>
--   data Point = MkPoint Int Int deriving Eq
--   
--   instance Arbitrary Point where
--     arbitrary = do
--       x &lt;- <a>arbitrary</a>
--       y &lt;- arbitrary
--       return (MkPoint x y)
--   
--   swapPoint :: Point -&gt; Point
--   swapPoint (MkPoint x y) = MkPoint y x
--   
--   -- swapPoint . swapPoint = id
--   prop_swapInvolution point = swapPoint (swapPoint point) == point
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_swapInvolution
--   +++ OK, passed 100 tests.
--   </pre>
--   
--   See <a>Test.QuickCheck.Function</a> for generating random shrinkable,
--   showable functions used for testing higher-order functions and
--   <a>Test.QuickCheck.Monadic</a> for testing impure or monadic code
--   (e.g. effectful code in <a>IO</a>).
module Test.QuickCheck

-- | Tests a property and prints the results to <tt>stdout</tt>.
quickCheck :: Testable prop => prop -> IO ()

-- | Args specifies arguments to the QuickCheck driver
data Args
Args :: Maybe (QCGen, Int) -> Int -> Int -> Int -> Bool -> Args

-- | Should we replay a previous test?
replay :: Args -> Maybe (QCGen, Int)

-- | Maximum number of successful tests before succeeding
maxSuccess :: Args -> Int

-- | Maximum number of discarded tests per successful test before giving up
maxDiscardRatio :: Args -> Int

-- | Size to use for the biggest test cases
maxSize :: Args -> Int

-- | Whether to print anything
chatty :: Args -> Bool

-- | Result represents the test result
data Result

-- | A successful test run
Success :: Int -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | Given up
GaveUp :: Int -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | A failed test run
Failure :: Int -> Int -> Int -> Int -> QCGen -> Int -> String -> Maybe AnException -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Number of successful shrinking steps performed
numShrinks :: Result -> Int

-- | Number of unsuccessful shrinking steps performed
numShrinkTries :: Result -> Int

-- | Number of unsuccessful shrinking steps performed since last successful
--   shrink
numShrinkFinal :: Result -> Int

-- | What seed was used
usedSeed :: Result -> QCGen

-- | What was the test size
usedSize :: Result -> Int

-- | Why did the property fail
reason :: Result -> String

-- | The exception the property threw, if any
theException :: Result -> Maybe AnException

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | A property that should have failed did not
NoExpectedFailure :: Int -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | The tests passed but a use of <a>cover</a> had insufficient coverage
InsufficientCoverage :: Int -> [(String, Int)] -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Labels and frequencies found during all successful tests
labels :: Result -> [(String, Int)]

-- | Printed output
output :: Result -> String

-- | The default test arguments
stdArgs :: Args

-- | Tests a property, using test arguments, and prints the results to
--   <tt>stdout</tt>.
quickCheckWith :: Testable prop => Args -> prop -> IO ()

-- | Tests a property, using test arguments, produces a test result, and
--   prints the results to <tt>stdout</tt>.
quickCheckWithResult :: Testable prop => Args -> prop -> IO Result

-- | Tests a property, produces a test result, and prints the results to
--   <tt>stdout</tt>.
quickCheckResult :: Testable prop => prop -> IO Result

-- | Tests a property and prints the results and all test cases generated
--   to <tt>stdout</tt>. This is just a convenience function that means the
--   same as <tt><a>quickCheck</a> . <a>verbose</a></tt>.
verboseCheck :: Testable prop => prop -> IO ()

-- | Tests a property, using test arguments, and prints the results and all
--   test cases generated to <tt>stdout</tt>. This is just a convenience
--   function that combines <a>quickCheckWith</a> and <a>verbose</a>.
verboseCheckWith :: Testable prop => Args -> prop -> IO ()

-- | Tests a property, using test arguments, produces a test result, and
--   prints the results and all test cases generated to <tt>stdout</tt>.
--   This is just a convenience function that combines
--   <a>quickCheckWithResult</a> and <a>verbose</a>.
verboseCheckWithResult :: Testable prop => Args -> prop -> IO Result

-- | Tests a property, produces a test result, and prints the results and
--   all test cases generated to <tt>stdout</tt>. This is just a
--   convenience function that combines <a>quickCheckResult</a> and
--   <a>verbose</a>.
verboseCheckResult :: Testable prop => prop -> IO Result

-- | Test all properties in the current module. The name of the property
--   must begin with <tt>prop_</tt>. Polymorphic properties will be
--   defaulted to <a>Integer</a>. Returns <a>True</a> if all tests
--   succeeded, <a>False</a> otherwise.
--   
--   To use <a>quickCheckAll</a>, add a definition to your module along the
--   lines of
--   
--   <pre>
--   return []
--   runTests = $quickCheckAll
--   </pre>
--   
--   and then execute <tt>runTests</tt>.
--   
--   Note: the bizarre <tt>return []</tt> in the example above is needed on
--   GHC 7.8; without it, <a>quickCheckAll</a> will not be able to find any
--   of the properties. For the curious, the <tt>return []</tt> is a
--   Template Haskell splice that makes GHC insert the empty list of
--   declarations at that point in the program; GHC typechecks everything
--   before the <tt>return []</tt> before it starts on the rest of the
--   module, which means that the later call to <a>quickCheckAll</a> can
--   see everything that was defined before the <tt>return []</tt>. Yikes!
quickCheckAll :: Q Exp

-- | Test all properties in the current module. This is just a convenience
--   function that combines <a>quickCheckAll</a> and <a>verbose</a>.
--   
--   <a>verboseCheckAll</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
verboseCheckAll :: Q Exp

-- | Test all properties in the current module, using a custom
--   <a>quickCheck</a> function. The same caveats as with
--   <a>quickCheckAll</a> apply.
--   
--   <tt>$<a>forAllProperties</a></tt> has type <tt>(<a>Property</a> -&gt;
--   <a>IO</a> <a>Result</a>) -&gt; <a>IO</a> <a>Bool</a></tt>. An example
--   invocation is <tt>$<a>forAllProperties</a>
--   <a>quickCheckResult</a></tt>, which does the same thing as
--   <tt>$<a>quickCheckAll</a></tt>.
--   
--   <a>forAllProperties</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
forAllProperties :: Q Exp

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>.
--   
--   Invoke as <tt>$(<a>polyQuickCheck</a> 'prop)</tt>, where <tt>prop</tt>
--   is a property. Note that just evaluating <tt><a>quickCheck</a>
--   prop</tt> in GHCi will seem to work, but will silently default all
--   type variables to <tt>()</tt>!
--   
--   <tt>$(<a>polyQuickCheck</a> 'prop)</tt> means the same as
--   <tt><a>quickCheck</a> $(<a>monomorphic</a> 'prop)</tt>. If you want to
--   supply custom arguments to <a>polyQuickCheck</a>, you will have to
--   combine <a>quickCheckWith</a> and <a>monomorphic</a> yourself.
--   
--   If you want to use <a>polyQuickCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyQuickCheck :: Name -> ExpQ

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>. This is just a convenience function that combines
--   <a>verboseCheck</a> and <a>monomorphic</a>.
--   
--   If you want to use <a>polyVerboseCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyVerboseCheck :: Name -> ExpQ

-- | Monomorphise an arbitrary property by defaulting all type variables to
--   <a>Integer</a>.
--   
--   For example, if <tt>f</tt> has type <tt><a>Ord</a> a =&gt; [a] -&gt;
--   [a]</tt> then <tt>$(<a>monomorphic</a> 'f)</tt> has type
--   <tt>[<a>Integer</a>] -&gt; [<a>Integer</a>]</tt>.
--   
--   If you want to use <a>monomorphic</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
monomorphic :: Name -> ExpQ

-- | A generator for values of type <tt>a</tt>.
data Gen a

-- | Generates a random element in the given inclusive range.
choose :: Random a => (a, a) -> Gen a

-- | Randomly uses one of the given generators. The input list must be
--   non-empty.
oneof :: [Gen a] -> Gen a

-- | Chooses one of the given generators, with a weighted random
--   distribution. The input list must be non-empty.
frequency :: [(Int, Gen a)] -> Gen a

-- | Generates one of the given values. The input list must be non-empty.
elements :: [a] -> Gen a

-- | Takes a list of elements of increasing size, and chooses among an
--   initial segment of the list. The size of this initial segment
--   increases with the size parameter. The input list must be non-empty.
growingElements :: [a] -> Gen a

-- | Used to construct generators that depend on the size parameter.
sized :: (Int -> Gen a) -> Gen a

-- | Overrides the size parameter. Returns a generator which uses the given
--   size instead of the runtime-size parameter.
resize :: Int -> Gen a -> Gen a

-- | Adjust the size parameter, by transforming it with the given function.
scale :: (Int -> Int) -> Gen a -> Gen a

-- | Generates a value that satisfies a predicate.
suchThat :: Gen a -> (a -> Bool) -> Gen a

-- | Tries to generate a value that satisfies a predicate.
suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)

-- | Generates a list of random length. The maximum length depends on the
--   size parameter.
listOf :: Gen a -> Gen [a]

-- | Generates a non-empty list of random length. The maximum length
--   depends on the size parameter.
listOf1 :: Gen a -> Gen [a]

-- | Generates a list of the given length.
vectorOf :: Int -> Gen a -> Gen [a]

-- | Generates an infinite list.
infiniteListOf :: Gen a -> Gen [a]

-- | Generates a random permutation of the given list.
shuffle :: [a] -> Gen [a]

-- | Generates a random subsequence of the given list.
sublistOf :: [a] -> Gen [a]

-- | Generates a list of a given length.
vector :: Arbitrary a => Int -> Gen [a]

-- | Generates an ordered list of a given length.
orderedList :: (Ord a, Arbitrary a) => Gen [a]

-- | Generate an infinite list.
infiniteList :: Arbitrary a => Gen [a]

-- | Run a generator. The size passed to the generator is always 30; if you
--   want another size then you should explicitly use <a>resize</a>.
generate :: Gen a -> IO a

-- | Generates some example values and prints them to <tt>stdout</tt>.
sample :: Show a => Gen a -> IO ()

-- | Generates some example values.
sample' :: Gen a -> IO [a]

-- | Random generation and shrinking of values.
class Arbitrary a where arbitrary = error "no default generator" shrink _ = []
arbitrary :: Arbitrary a => Gen a
shrink :: Arbitrary a => a -> [a]

-- | Used for random generation of functions.
--   
--   If you are using a recent GHC, there is a default definition of
--   <a>coarbitrary</a> using <a>genericCoarbitrary</a>, so if your type
--   has a <a>Generic</a> instance it's enough to say
--   
--   <pre>
--   instance CoArbitrary MyType
--   </pre>
--   
--   You should only use <a>genericCoarbitrary</a> for data types where
--   equality is structural, i.e. if you can't have two different
--   representations of the same value. An example where it's not safe is
--   sets implemented using binary search trees: the same set can be
--   represented as several different trees. Here you would have to
--   explicitly define <tt>coarbitrary s = coarbitrary (toList s)</tt>.
class CoArbitrary a where coarbitrary = genericCoarbitrary
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b

-- | Generates an integral number. The number can be positive or negative
--   and its maximum absolute value depends on the size parameter.
arbitrarySizedIntegral :: Integral a => Gen a

-- | Generates a natural number. The number's maximum value depends on the
--   size parameter.
arbitrarySizedNatural :: Integral a => Gen a

-- | Generates a fractional number. The number can be positive or negative
--   and its maximum absolute value depends on the size parameter.
arbitrarySizedFractional :: Fractional a => Gen a

-- | Generates an integral number from a bounded domain. The number is
--   chosen from the entire range of the type, but small numbers are
--   generated more often than big numbers. Inspired by demands from Phil
--   Wadler.
arbitrarySizedBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Generates an integral number. The number is chosen uniformly from the
--   entire range of the type. You may want to use
--   <a>arbitrarySizedBoundedIntegral</a> instead.
arbitraryBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Generates an element of a bounded type. The element is chosen from the
--   entire range of the type.
arbitraryBoundedRandom :: (Bounded a, Random a) => Gen a

-- | Generates an element of a bounded enumeration.
arbitraryBoundedEnum :: (Bounded a, Enum a) => Gen a

-- | Generic CoArbitrary implementation.
genericCoarbitrary :: (Generic a, GCoArbitrary (Rep a)) => a -> Gen b -> Gen b

-- | Shrink a term to any of its immediate subterms, and also recursively
--   shrink all subterms.
genericShrink :: (Generic a, Arbitrary a, RecursivelyShrink (Rep a), GSubterms (Rep a) a) => a -> [a]

-- | All immediate subterms of a term.
subterms :: (Generic a, Arbitrary a, GSubterms (Rep a) a) => a -> [a]

-- | Recursively shrink all immediate subterms.
recursivelyShrink :: (Generic a, RecursivelyShrink (Rep a)) => a -> [a]

-- | Returns no shrinking alternatives.
shrinkNothing :: a -> [a]

-- | Shrink a list of values given a shrinking function for individual
--   values.
shrinkList :: (a -> [a]) -> [a] -> [[a]]

-- | Shrink an integral number.
shrinkIntegral :: Integral a => a -> [a]

-- | Shrink a fraction.
shrinkRealFrac :: RealFrac a => a -> [a]

-- | Shrink a fraction, but only shrink to integral values.
shrinkRealFracToInteger :: RealFrac a => a -> [a]

-- | Modifies a generator using an integer seed.
variant :: Integral n => n -> Gen a -> Gen a

-- | A <a>coarbitrary</a> implementation for integral numbers.
coarbitraryIntegral :: Integral a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for real numbers.
coarbitraryReal :: Real a => a -> Gen b -> Gen b

-- | <a>coarbitrary</a> helper for lazy people :-).
coarbitraryShow :: Show a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for enums.
coarbitraryEnum :: Enum a => a -> Gen b -> Gen b

-- | Combine two generator perturbing functions, for example the results of
--   calls to <a>variant</a> or <a>coarbitrary</a>.

-- | <i>Deprecated: Use ordinary function composition instead</i>
(><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)

-- | <tt>Blind x</tt>: as x, but x does not have to be in the <a>Show</a>
--   class.
newtype Blind a
Blind :: a -> Blind a
getBlind :: Blind a -> a

-- | <tt>Fixed x</tt>: as x, but will not be shrunk.
newtype Fixed a
Fixed :: a -> Fixed a
getFixed :: Fixed a -> a

-- | <tt>Ordered xs</tt>: guarantees that xs is ordered.
newtype OrderedList a
Ordered :: [a] -> OrderedList a
getOrdered :: OrderedList a -> [a]

-- | <tt>NonEmpty xs</tt>: guarantees that xs is non-empty.
newtype NonEmptyList a
NonEmpty :: [a] -> NonEmptyList a
getNonEmpty :: NonEmptyList a -> [a]

-- | <tt>Positive x</tt>: guarantees that <tt>x &gt; 0</tt>.
newtype Positive a
Positive :: a -> Positive a
getPositive :: Positive a -> a

-- | <tt>NonZero x</tt>: guarantees that <tt>x /= 0</tt>.
newtype NonZero a
NonZero :: a -> NonZero a
getNonZero :: NonZero a -> a

-- | <tt>NonNegative x</tt>: guarantees that <tt>x &gt;= 0</tt>.
newtype NonNegative a
NonNegative :: a -> NonNegative a
getNonNegative :: NonNegative a -> a

-- | <tt>Large x</tt>: by default, QuickCheck generates <a>Int</a>s drawn
--   from a small range. <tt>Large Int</tt> gives you values drawn from the
--   entire range instead.
newtype Large a
Large :: a -> Large a
getLarge :: Large a -> a

-- | <tt>Small x</tt>: generates values of <tt>x</tt> drawn from a small
--   range. The opposite of <a>Large</a>.
newtype Small a
Small :: a -> Small a
getSmall :: Small a -> a

-- | <tt>Smart _ x</tt>: tries a different order when shrinking.
data Smart a
Smart :: Int -> a -> Smart a

-- | <tt>Shrink2 x</tt>: allows 2 shrinking steps at the same time when
--   shrinking x
newtype Shrink2 a
Shrink2 :: a -> Shrink2 a
getShrink2 :: Shrink2 a -> a

-- | <tt>Shrinking _ x</tt>: allows for maintaining a state during
--   shrinking.
data Shrinking s a
Shrinking :: s -> a -> Shrinking s a
class ShrinkState s a
shrinkInit :: ShrinkState s a => a -> s
shrinkState :: ShrinkState s a => a -> s -> [(a, s)]

-- | The type of properties.
--   
--   Backwards combatibility note: in older versions of QuickCheck
--   <a>Property</a> was a type synonym for <tt><a>Gen</a>
--   <a>Prop</a></tt>, so you could mix and match property combinators and
--   <a>Gen</a> monad operations. Code that does this will no longer
--   typecheck. However, it is easy to fix: because of the <a>Testable</a>
--   typeclass, any combinator that expects a <a>Property</a> will also
--   accept a <tt><a>Gen</a> <a>Property</a></tt>. If you have a
--   <a>Property</a> where you need a <tt><a>Gen</a> <tt>a</tt></tt>,
--   simply wrap the property combinator inside a <a>return</a> to get a
--   <tt><a>Gen</a> <a>Property</a></tt>, and all should be well.
data Property

-- | The class of things which can be tested, i.e. turned into a property.
class Testable prop where exhaustive _ = False
property :: Testable prop => prop -> Property
exhaustive :: Testable prop => prop -> Bool

-- | Explicit universal quantification: uses an explicitly given test case
--   generator.
forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property

-- | Like <a>forAll</a>, but tries to shrink the argument for failing test
--   cases.
forAllShrink :: (Show a, Testable prop) => Gen a -> (a -> [a]) -> (a -> prop) -> Property

-- | Shrinks the argument to property if it fails. Shrinking is done
--   automatically for most types. This is only needed when you want to
--   override the default behavior.
shrinking :: Testable prop => (a -> [a]) -> a -> (a -> prop) -> Property

-- | Implication for properties: The resulting property holds if the first
--   argument is <a>False</a> (in which case the test case is discarded),
--   or if the given property holds.
(==>) :: Testable prop => Bool -> prop -> Property

-- | Like <a>==</a>, but prints a counterexample when it fails.
(===) :: (Eq a, Show a) => a -> a -> Property

-- | Do I/O inside a property. This can obviously lead to unrepeatable
--   testcases, so use with care.
--   
--   For more advanced monadic testing you may want to look at
--   <a>Test.QuickCheck.Monadic</a>.
ioProperty :: Testable prop => IO prop -> Property

-- | Prints out the generated testcase every time the property is tested.
--   Only variables quantified over <i>inside</i> the <a>verbose</a> are
--   printed.
verbose :: Testable prop => prop -> Property

-- | Modifies a property so that it only will be tested once.
once :: Testable prop => prop -> Property

-- | Considers a property failed if it does not complete within the given
--   number of microseconds.
within :: Testable prop => Int -> prop -> Property

-- | Disables shrinking for a property altogether.
noShrinking :: Testable prop => prop -> Property

-- | Nondeterministic choice: <tt>p1</tt> <a>.&amp;.</a> <tt>p2</tt> picks
--   randomly one of <tt>p1</tt> and <tt>p2</tt> to test. If you test the
--   property 100 times it makes 100 random choices.
(.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property

-- | Conjunction: <tt>p1</tt> <a>.&amp;&amp;.</a> <tt>p2</tt> passes if
--   both <tt>p1</tt> and <tt>p2</tt> pass.
(.&&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property

-- | Take the conjunction of several properties.
conjoin :: Testable prop => [prop] -> Property

-- | Disjunction: <tt>p1</tt> <a>.||.</a> <tt>p2</tt> passes unless
--   <tt>p1</tt> and <tt>p2</tt> simultaneously fail.
(.||.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property

-- | Take the disjunction of several properties.
disjoin :: Testable prop => [prop] -> Property

-- | Adds the given string to the counterexample.
counterexample :: Testable prop => String -> prop -> Property

-- | Adds the given string to the counterexample.

-- | <i>Deprecated: Use counterexample instead</i>
printTestCase :: Testable prop => String -> prop -> Property

-- | Performs an <a>IO</a> action after the last failure of a property.
whenFail :: Testable prop => IO () -> prop -> Property

-- | Performs an <a>IO</a> action every time a property fails. Thus, if
--   shrinking is done, this can be used to keep track of the failures
--   along the way.
whenFail' :: Testable prop => IO () -> prop -> Property

-- | Indicates that a property is supposed to fail. QuickCheck will report
--   an error if it does not fail.
expectFailure :: Testable prop => prop -> Property

-- | Attaches a label to a property. This is used for reporting test case
--   distribution.
label :: Testable prop => String -> prop -> Property

-- | Labels a property with a value:
--   
--   <pre>
--   collect x = label (show x)
--   </pre>
collect :: (Show a, Testable prop) => a -> prop -> Property

-- | Conditionally labels test case.
classify :: Testable prop => Bool -> String -> prop -> Property

-- | Checks that at least the given proportion of <i>successful</i> test
--   cases belong to the given class. Discarded tests (i.e. ones with a
--   false precondition) do not affect coverage.
cover :: Testable prop => Bool -> Int -> String -> prop -> Property

-- | If a property returns <a>Discard</a>, the current test case is
--   discarded, the same as if a precondition was false.
data Discard
Discard :: Discard

-- | A special exception that makes QuickCheck discard the test case.
--   Normally you should use <tt>==&gt;</tt>, but if for some reason this
--   isn't possible (e.g. you are deep inside a generator), use
--   <a>discard</a> instead.
discard :: a

-- | Changes the maximum test case size for a property.
mapSize :: Testable prop => (Int -> Int) -> prop -> Property
