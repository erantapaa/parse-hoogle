-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | make tool. ruby : rake = haskell : hake
--   
--   Like ruby's rake, hake have Hakefile which is Haskell source.
--   
--   And Hakefile is like rake's Rakefile, and make's Makefile.
--   
--   Hakefile is just Haskell source code, then you can use all Haskell
--   features.
--   
--   New:
--   
--   <pre>
--   deps :: [ String ] -&gt; [ String] -&gt; Rule
--   deps trgts srcs == file trgts srcs $ \_ _ -&gt; []
--   </pre>
--   
--   Use <a>deps</a> if you want to define no command rule for new Targets.
--   Please use addDeps if you will add dependencies to already existing
--   targets.
--   
--   Hakefile example:
--   
--   <pre>
--   import Development.Hake
--   import Development.Hake.FunSetRaw
--   hake_rules = [
--   
--    dflt	[ "greeting" ]
--    ,
--    file	[ "greeting", "greeting.log" ] [ "hello.o", "good-bye.o" ] $
--   		const2 [ [ "linker", "-o", "greeting", "hello.o", "good-bye.o" ] ]
--    ,
--    rule	".o" ".sfx1" $
--   		\t (s:_) -&gt; [ [ "compiler1", s, "-o", t ] ]
--    ,
--    rule	".o" ".sfx2" $
--   		\t (s:_) -&gt; [ [ "compiler2", s, "-o", t ] ]
--    ,
--    task	"clean"
--         [ [ "rm", "-f", "hello.o", "good-by.o", "greeting", "greeting.log" ] ]
--    ,
--    mkfl	"script.sh" [ "#!/bin/sh", "echo This is script", "echo made by Hakefile" ]
--    ,
--    ruleSS "" ".o" $ \t (s:_) -&gt; [ (".c",  [ [ "gcc", s, "-o", t ] ] ) ,
--                               (".cc", [ [ "g++", s, "-o", t ] ] ) ] )
--    ,
--    rule   ".o" ".c" $ \_ (s:_) -&gt; [ [ "gcc", "-c", s ] ]
--    ,
--    rule   ".o" ".cc" $ \_ (s:_) -&gt; [ [ "g++", "-c", s ] ]
--    ,
--    base   (=="foo") (const [ "foo.gen", "Hakefile" ]) $ \t (s:_) _ _ -&gt; do
--                 gen &lt;- readFile s
--                 writeFile t $ unlines $
--                   [ "#!/bin/sh", "echo This is script" ] ++ lines gen
--                 return ExitSuccess
--   
--    ]
--   
--   main = hake hake_rules
--   </pre>
@package hake
@version 1.3.4

module Development.Hake.OldFunSet
file :: ([String], [String], [String]) -> Rule
task :: (String, [String]) -> Rule
rule :: (String, String, String -> String -> [String]) -> Rule
ruleSS :: (String, String, String -> String -> [(String, [String])]) -> Rule

module Development.Hake.FunSet
file :: [String] -> [String] -> (String -> [String] -> [String]) -> Rule
task :: String -> [String] -> Rule
rule :: String -> String -> (String -> [String] -> [String]) -> Rule
ruleV :: String -> [String] -> [String] -> (String -> [String] -> [String]) -> Rule
ruleSS :: String -> String -> (String -> [String] -> [(String, [String])]) -> Rule

module Development.Hake.FunSetRaw
file :: [String] -> [String] -> (String -> [String] -> [[String]]) -> Rule
task :: String -> [[String]] -> Rule
rule :: String -> String -> (String -> [String] -> [[String]]) -> Rule
ruleV :: String -> [String] -> [String] -> (String -> [String] -> [[String]]) -> Rule
ruleSS :: String -> String -> (String -> [String] -> [(String, [[String]])]) -> Rule

module Development.Hake.FunSetIO
file :: [String] -> [String] -> (String -> [String] -> IO ExitCode) -> Rule
task :: String -> IO ExitCode -> Rule
rule :: String -> String -> (String -> [String] -> IO ExitCode) -> Rule
ruleV :: String -> [String] -> [String] -> (String -> [String] -> IO ExitCode) -> Rule
ruleSS :: String -> String -> (String -> [String] -> [(String, IO ExitCode)]) -> Rule
orDie :: (MonadIO m) => m ExitCode -> (ExitCode -> String) -> m ()

module Development.Hake
type Rule = (Targets, Sources, Commands)

-- | The <a>hake</a> function take rules as argument and get target from
--   command line and make target.
hake :: [Rule] -> IO ()
hakeT :: [Rule] -> FilePath -> IO ()
hakefileIs :: FilePath -> [FilePath] -> IO ExitCode
base :: Targets -> Sources -> (String -> [String] -> MadeFromList -> Bool -> IO ExitCode) -> Rule
dflt :: [String] -> Rule
deps :: [String] -> [String] -> Rule
mkfl :: String -> [String] -> Rule
addDeps :: [Rule] -> [(FilePath, [FilePath])] -> [Rule]
delRules :: [Rule] -> [(FilePath, [FilePath])] -> [Rule]
setCmd :: Rule -> (String -> [String] -> MadeFromList -> IO ExitCode) -> Rule
systemE :: (MonadIO m) => String -> m ExitCode
rawSystemE :: (MonadIO m) => [String] -> m ExitCode

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. Both lists must be
--   finite.
isSuffixOf :: (Eq a) => [a] -> [a] -> Bool
changeSuffix :: String -> String -> String -> String
getVals :: String -> [String] -> [String]
getNewers :: FilePath -> [FilePath] -> IO [FilePath]
data ExitCode :: *

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode
const2 :: a -> b -> c -> a
