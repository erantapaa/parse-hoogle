-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Role annotations without -XRoleAnnotations
--   
--   This package is intended to ease the transition from GHC 7.6.3- to GHC
--   7.8+ by providing a backward-compatible role annotation syntax. The
--   module Language.Haskell.RoleAnnots exports backward-compatible
--   declarations usable to assign stricter roles to declarations. Proper
--   role annotations are preferred, but these work, too. The module
--   Language.Haskell.RoleAnnots.Check provides a way to check that a
--   datatype has a set of desired roles. This might be suitable for use in
--   a testsuite. See the module documentation for details. Note that this
--   package works only with GHC 7.4 and up, because it depends on the
--   -XPolyKinds extension. If you need backward compatibility before 7.4,
--   then please look at the source code and adapt the definitions to the
--   kinds of the variables in your program.
@package no-role-annots
@version 1.1


-- | This module provides three class constraints that can be used to make
--   roles stricter in your datatypes. Here is a typical use case:
--   
--   <pre>
--   -- Use an association list as a map:
--   data (Nominal k, Representational v) =&gt; Map k v = MkMap [(k,v)]
--   </pre>
--   
--   With a declaration such as this, GHC will assign correct roles to
--   <tt>k</tt> and <tt>v</tt>. In versions of GHC before roles, these
--   constraints have no effect. You will need to make sure the language
--   extension <tt>-XDatatypeContexts</tt> is enabled. This extension is
--   enabled by default with a default language of either Haskell98 or
--   Haskell2010, but not by default with a vanilla invocation of GHC. When
--   enabling it manually, you may also want to specify
--   <tt>-fno-warn-deprecated-flags</tt>, as datatype contexts are
--   generally a misfeature.
--   
--   Note that these constraints can only make roles stricter, such as a
--   change from representational to nominal. Indeed, going the other way
--   would not be type-safe! Thus, there is no guarantee that a parameter
--   has the role given -- the guarantee is only that a parameter as <i>at
--   least</i> the role given. (Thus, <a>Phantom</a> is always redundant
--   and is included only for completeness.)
--   
--   To check that the roles are what you would expect, see module
--   <a>Language.Haskell.RoleAnnots.Check</a>.
module Language.Haskell.RoleAnnots

-- | Mark a type parameter as having a nominal role
class Nominal a

-- | Mark a type parameter as having a representational role
class Representational a

-- | Mark a type parameter as having a phantom role. (This is always
--   redundant.)
class Phantom a

-- | Deprecated since role inference looks at datatype contexts (with the
--   release of GHC 7.8).

-- | <i>Deprecated: The <a>roleAnnot</a> function is not necessary. Use a
--   role constraint in a datatype context instead. </i>
roleAnnot :: [Role] -> Q [Dec] -> Q [Dec]

-- | This declaration mirrors the declaration within Template Haskell, for
--   use in earlier versions of GHC.
data Role
NominalR :: Role
RepresentationalR :: Role
PhantomR :: Role
InferR :: Role
instance Typeable Role
instance Show Role
instance Eq Role
instance Data Role
instance Phantom k a
instance Representational k a
instance Nominal k a


-- | This module uses Template Haskell to check whether a declared type has
--   the desired roles. (In versions of GHC before roles, these checks
--   always succeed.)
module Language.Haskell.RoleAnnots.Check

-- | This function ensures that a declared type has a desired set of roles.
--   Call it in a top-level Template Haskell splice, like this:
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   module MyMap where
--   
--   import Language.Haskell.RoleAnnots
--   import Language.Haskell.RoleAnnots.Check
--   
--   data MyMap k v = (Nominal k, Representational v) =&gt; ...
--   
--   $(checkRoles ''MyMap [NominalR, RepresentationalR])
--   </pre>
--   
--   If the roles are not as desired, the <a>checkRoles</a> will cause a
--   compile- time error.
--   
--   The two quote marks there are Template Haskell syntax to quote an
--   in-scope name. Also, due to the way Template Haskell works, the
--   declaration you are checking must come before the call to
--   <a>checkRoles</a>.
--   
--   <a>checkRoles</a> may be called in a separate module from where the
--   datatype of interest is defined. It might be useful, for example, in a
--   testsuite.
checkRoles :: Name -> [Role] -> Q [Dec]

-- | This function is like <a>checkRoles</a>, but it can be used in a
--   context expecting a <tt>Bool</tt> value, like this:
--   
--   <pre>
--   rolesAreCorrect :: Bool
--   rolesAreCorrect = $(checkRolesB ''MyMap [NominalR, RepresentationalR])
--   </pre>
--   
--   <a>checkRolesB</a> never produces a compile-time error.
checkRolesB :: Name -> [Role] -> Q Exp

-- | This declaration mirrors the declaration within Template Haskell, for
--   use in earlier versions of GHC.
data Role
NominalR :: Role
RepresentationalR :: Role
PhantomR :: Role
InferR :: Role
