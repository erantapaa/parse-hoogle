-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Quoridor implementation in Haskell
--   
--   An implementation in Haskell of the 2-to-4-player strategy game. For
--   more information, see: <a>https://github.com/talw/quoridor-hs</a>
@package quoridor-hs
@version 0.1.1.2

module Quoridor

-- | A tile on the board. Direction of X and Y axis are right and down
--   respectively.
type Cell = (Int, Int)
type HalfGate = (Cell, Cell)
type Gate = (HalfGate, HalfGate)
type HalfGates = Set HalfGate

-- | Size of the board in one dimension. The board is a square
type BoardSize = Int

-- | List of valid moves for a player
type ValidMoves = [Cell]

-- | The monad used for running the game. Basically adds layers of ReaderT
--   for configuration, StateT for state, and some monad for the rest
--   (currently just IO monad).
newtype Game m a
Game :: (ReaderT GameConfig (StateT GameState m) a) -> Game m a

-- | To <tt>run</tt> the Game monad
runGame :: Functor m => Game m a -> GameConfig -> m ()

-- | Same as runGame, but allows to start from a given GameState, instead
--   of from the beginning
runGameWithGameState :: Game m a -> GameState -> GameConfig -> m (a, GameState)
data Player
Player :: Color -> Cell -> Int -> Player
color :: Player -> Color
pos :: Player -> Cell
gatesLeft :: Player -> Int

-- | Represents a turn, can be either a <a>Gate</a> put, a <a>Player</a>
--   move or a <a>ShortCutMove</a> which is specified by an index from the
--   given valid moves for a player at the current turn
data Turn
PutGate :: Gate -> Turn
Move :: Cell -> Turn
ShortCutMove :: Int -> Turn

-- | Colors to distinguish between <a>Player</a>s
data Color
Blue :: Color
White :: Color
Red :: Color
Green :: Color

-- | The orientation (perhaps a better name?) of the <a>Gate</a>, it can be
--   either vertical or horizontal
data Direction
H :: Direction
V :: Direction

-- | Represents the game state. With a list of <a>Player</a>s (the head is
--   the current player), maybe a winner, and a map of the <a>Gate</a>s,
--   which actually breaks them into <tt>Halfgate</tt>s.
data GameState
GameState :: [Player] -> HalfGates -> Maybe Color -> GameState
playerList :: GameState -> [Player]
halfGates :: GameState -> HalfGates
winner :: GameState -> Maybe Color
data GameConfig
GameConfig :: Int -> Int -> Int -> GameConfig
gatesPerPlayer :: GameConfig -> Int
boardSize :: GameConfig -> Int
numOfPlayers :: GameConfig -> Int

-- | An initial state. All players begin at the first<i>last row</i>column
initialGameState :: GameConfig -> GameState
defaultGameConfig :: GameConfig

-- | Initial positions for the different <a>Color</a>s
startPos :: Int -> Map Color Cell

-- | Applies f on the current player
modifyCurrP :: (Player -> Player) -> GameState -> GameState

-- | Returns the current player
currP :: GameState -> Player
distance :: Cell -> Cell -> Int
isAdj :: Cell -> Cell -> Bool

-- | Returns adjacent cells that are within the ranger of the board
getAdj :: Int -> Cell -> [Cell]

-- | Is cell within board range
isWithinRange :: Int -> Cell -> Bool

-- | Coerces <a>HalfGate</a>s so that left item is less than or equal to
--   the right item.
align :: HalfGate -> HalfGate

-- | Equivalent to, given cells a and b (a,b) is the space between them
--   open for movement?
isHalfGateSpaceClear :: HalfGate -> HalfGates -> Bool
isGateSpaceClear :: Gate -> HalfGates -> Bool

-- | Breaks a gate into it's cell components. Used, for example, to make
--   sure a gate is placed within bounds of the board.
gateToCells :: Gate -> [Cell]

-- | Given a cell, returns a gate. That gate, the upper left corner of it's
--   encompassing 2x2 square is at the given cell.
gateUpperLeft :: Cell -> Direction -> Gate
insertGate :: Gate -> HalfGates -> HalfGates

-- | Is the cell empty (i.e. no player is standing there)
isVacant :: Cell -> GameState -> Bool

-- | Given a cell and a player, is that a cell that if the player reaches
--   it, the game ends. Used with dfs, to make sure placing a gate still
--   leaves at least one cell which is a winning cell, for every player.
isWinningCell :: Int -> Player -> Cell -> Bool

-- | Basically, translates a <a>ShortCutMove</a> into the <a>Move</a> that
--   it is a shortcut of, using the integral index that is the index of the
--   shortcut character in the list of <tt>validMovesChars</tt>
coerceTurn :: (Monad m, Functor m) => Turn -> Game m (Maybe Turn)

-- | Gets a list of possible cells which the current player can move to.
getValidMoves :: Cell -> Int -> GameState -> [Cell]

-- | Checks if from a given cell, another cell, which satisfies the given
--   predicate, can be reached. Used in gate placement, to make sure a cell
--   which is a winning cell for a player can still be reached.
dfs :: Cell -> (Cell -> Bool) -> Int -> GameState -> Bool

-- | Rotates the <a>Player</a> list to change the current player. The
--   player at the had of the player list is the current player.
changeCurrPlayer :: Monad m => Game m ()

-- | Checks if a given <a>Turn</a> is valid, rule-wise. It does it by
--   perusing <a>getCurrentValidMoves</a>s returned list of all possible
--   valid moves.
isValidTurn :: (Monad m, Functor m) => Turn -> Game m Bool

-- | Acts upon a single <a>Turn</a>. The difference with <tt>MakeTurn</tt>,
--   is that MakeTurn calls this function and does more, like changing
--   currentPlayer and checking for a winner.
actTurn :: Monad m => Turn -> Game m ()

-- | Checks if there's a winner, returning it if there is and sets the
--   winner in the <a>GameState</a>.
checkAndSetWinner :: Monad m => Game m (Maybe Color)

-- | Makes a single <a>Turn</a> in a game. Changes the state
--   (<a>GameState</a>) accordingly and returns whether or not a valid turn
--   was requested. If an invalid turn was requested, it can be safely
--   assumed that the GameState did not change.
makeTurn :: (Monad m, Functor m) => Turn -> Game m (Maybe Turn)

-- | A Game monad wrapper for the unmonadic <a>getValidMoves</a>
getCurrentValidMoves :: (Monad m, Functor m) => Game m [Cell]
instance Read Turn
instance Show Turn
instance Eq Color
instance Show Color
instance Ord Color
instance Enum Color
instance Read Color
instance Show Player
instance Eq Player
instance Read Player
instance Show Direction
instance Read Direction
instance Show GameState
instance Read GameState
instance Show GameConfig
instance Read GameConfig
instance Monad m => Monad (Game m)
instance Monad m => MonadState GameState (Game m)
instance MonadIO m => MonadIO (Game m)
instance (Monad m, Functor m) => Applicative (Game m)
instance Functor m => Functor (Game m)
instance Monad m => MonadReader GameConfig (Game m)
instance MonadThrow m => MonadThrow (Game m)
instance MonadCatch m => MonadCatch (Game m)
instance MonadMask m => MonadMask (Game m)
instance MonadTrans Game

module Quoridor.Cmdline

-- | The main entry point to quoridor-exec
cmdlineMain :: IO ()
