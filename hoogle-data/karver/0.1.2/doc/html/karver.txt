-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple template engine, inspired by jinja2
--   
@package karver
@version 0.1.2


-- | Base types used throughout Karver.
module Text.Karver.Types

-- | When dealing with the syntax of karver, we first translate the given
--   <a>Text</a> into <a>Token</a>s for easier manipulation. Each
--   <a>Token</a> type is a representation of a certain type of data.
data Token

-- | Literal token. This is the default <a>Token</a> that gets matched only
--   if it isn't any of the others.
LiteralTok :: Text -> Token

-- | Identity token. This is for a regular variable with no sign of it
--   being an object or list. eg. {{ ident }}
IdentityTok :: Text -> Token

-- | Object token. This is similar to <a>IdentityTok</a>, but if there is a
--   dot, it gets placed in the second value. The first <a>Text</a> is the
--   object name, while the second <a>Text</a> is the key to the object.
--   eg. {{ ident.key }}
ObjectTok :: Text -> Text -> Token

-- | List token. This is also similar to the <a>IdentityTok</a>, but if
--   there is an opening square bracket, it gets place in the second value.
--   <a>Text</a> is the list name, while <a>Int</a> is the index. eg {{
--   ident[4] }}
ListTok :: Text -> Int -> Token

-- | If statement token. The first <a>Text</a> will be the check if a
--   identity is available or not. Second <a>Text</a> is the body of the if
--   statement. And the third <a>Text</a> is the else body — if their isn't
--   one, it will be empty.
ConditionTok :: Text -> Text -> Text -> Token

-- | For loop token. The first <a>Text</a> is the list that will be
--   iterated over. Second <a>Text</a> is the variable name a single
--   element of the list will be placed into. Third <a>Text</a> is the body
--   of the loop that will be repeatedly translated from.
LoopTok :: Text -> Text -> Text -> Token

-- | Include token. The <a>Text</a> value store a file name, which includes
--   its relative path, based on the current working directory.
IncludeTok :: Text -> Token

-- | Fairly basic work around for using different types inside a
--   <a>HashMap</a>. The <a>Value</a> type also make it possible for
--   <a>List</a> to contain more than one type.
data Value

-- | The base value for the storing of variable.
Literal :: Text -> Value

-- | An alias for <a>HashMap</a>, that will only hold <a>Text</a> with
--   <a>Text</a> as a key as well.
Object :: (HashMap Text Text) -> Value

-- | An alias for <a>Vector</a>, that can hold all three <a>Value</a>s —
--   which isn't desirable, because their can be nested <a>List</a>s.
List :: (Vector Value) -> Value
instance Show Token
instance Eq Token
instance Show Value
instance Eq Value
instance FromJSON Value


-- | All the <a>Parser</a>s are defined here, including the one used by the
--   top level module <a>Text.Karver</a>.
module Text.Karver.Parse

-- | Top level <a>Parser</a> that will translate <a>Text</a> into
--   [<a>Token</a>]
templateParser :: Parser [Token]

-- | Takes everything until it reaches a <tt>{</tt>, resulting in the
--   <a>LiteralTok</a>
literalParser :: Parser Token

-- | <a>Parser</a> for all the variable types. Returning on of the
--   following <a>Token</a>s:
--   
--   <ul>
--   <li><a>IncludeTok</a></li>
--   <li><a>ListTok</a></li>
--   <li><a>ObjectTok</a></li>
--   </ul>
variableParser :: Parser Token

-- | <a>Parser</a> for all the variable types. Returning on of the
--   following <a>Token</a>s:
--   
--   <ul>
--   <li><a>IncludeTok</a></li>
--   <li><a>ListTok</a></li>
--   <li><a>ObjectTok</a></li>
--   </ul>
--   
--   This is without the delimiter
variableParser' :: Parser Token

-- | <a>Parser</a> for if statements, that will result in the
--   <a>ConditionTok</a>
conditionParser :: Parser Token

-- | <a>Parser</a> for for loops, that will result in the <a>LoopTok</a>
loopParser :: Parser Token

-- | <a>Parser</a> for includes, that will result in <a>IncludeTok</a>
includeParser :: Parser Token


-- | The <a>Text.Karver</a> interface for translation <a>Text</a> from it's
--   template syntax, to a generated value — based on the data that was
--   given.
module Text.Karver

-- | Renders a template
renderTemplate :: HashMap Text Value -> Text -> Text

-- | Similar to renderTemplate, only it takes JSON <a>Text</a> instead of a
--   <a>HashMap</a>
renderTemplate' :: Text -> Text -> Text
