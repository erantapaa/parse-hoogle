-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A fixed-precision real number type
--   
@package fixedprec
@version 0.2.2.1


-- | A reasonably efficient implementation of arbitrary-but-fixed precision
--   real numbers. This is inspired by, and partly based on,
--   <a>Data.Number.Fixed</a> and <a>Data.Number.CReal</a>, but more
--   efficient.
module Data.Number.FixedPrec

-- | A type class for type-level integers, capturing a precision parameter.
--   Precision is measured in decimal digits.
class Precision e

-- | Precision of 0 digits.
data P0

-- | Precision of 1 digit.
data P1

-- | Precision of 10 digits.
data P10

-- | Precision of 100 digits.
data P100

-- | Precision of 1000 digits.
data P1000

-- | Precision of 2000 digits.
data P2000

-- | Add 1 digit to the given precision.
data PPlus1 e

-- | Add 3 digits to the given precision.
data PPlus3 e

-- | Add 10 digits to the given precision.
data PPlus10 e

-- | Add 100 digits to the given precision.
data PPlus100 e

-- | Add 1000 digits to the given precision.
data PPlus1000 e

-- | The type of fixed-precision numbers.
data FixedPrec e

-- | Get the precision of a fixed-precision number, in decimal digits.
getprec :: Precision e => FixedPrec e -> Int

-- | Cast from any <a>FixedPrec</a> type to another.
cast :: (Precision e, Precision f) => FixedPrec e -> FixedPrec f

-- | Cast to a fixed-point type with three additional digits of accuracy.
upcast :: Precision e => FixedPrec e -> FixedPrec (PPlus3 e)

-- | Cast to a fixed-point type with three fewer digits of accuracy.
downcast :: Precision e => FixedPrec (PPlus3 e) -> FixedPrec e

-- | The function <a>with_added_digits</a> <i>d</i> <i>f</i> <i>x</i>
--   evaluates <i>f</i>(<i>x</i>), adding <i>d</i> digits of accuracy to
--   <i>x</i> during the computation.
with_added_digits :: Precision f => Int -> (forall e. Precision e => FixedPrec e -> a) -> FixedPrec f -> a

-- | Return the positive fractional part of a fixed-precision number. The
--   result is always in [0,1), regardless of the sign of the input.
fractional :: Precision e => FixedPrec e -> FixedPrec e

-- | Solve the quadratic equation <i>x</i>^2 + <i>bx</i> + <i>c</i> = 0
--   with maximal possible precision, using a numerically stable method.
--   Return the pair (<i>x1</i>, <i>x2</i>) of solutions with <i>x1</i>
--   &lt;= <i>x2</i>, or <a>Nothing</a> if no solution exists.
--   
--   This is far more precise, and probably more efficient, than naively
--   using the quadratic formula.
solve_quadratic :: Precision e => FixedPrec e -> FixedPrec e -> Maybe (FixedPrec e, FixedPrec e)

-- | A version of the natural logarithm that returns a <a>Double</a>. The
--   logarithm of just about any value can fit into a <a>Double</a>; so if
--   not a lot of precision is required in the mantissa, this function is
--   often faster than <a>log</a>.
log_double :: (Floating a, Real a) => a -> Double
instance Eq (FixedPrec e)
instance Ord (FixedPrec e)
instance Precision e => Random (FixedPrec e)
instance Precision e => Floating (FixedPrec e)
instance Precision e => RealFrac (FixedPrec e)
instance Precision e => Real (FixedPrec e)
instance Precision e => Fractional (FixedPrec e)
instance Precision e => Num (FixedPrec e)
instance Precision e => Show (FixedPrec e)
instance Precision e => Precision (PPlus1000 e)
instance Precision e => Precision (PPlus100 e)
instance Precision e => Precision (PPlus10 e)
instance Precision e => Precision (PPlus3 e)
instance Precision e => Precision (PPlus1 e)
instance Precision P2000
instance Precision P1000
instance Precision P100
instance Precision P10
instance Precision P1
instance Precision P0
