-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generator for Boilerplate KURE Combinators
--   
--   KURE-your-boilerplate is a Template Haskell powered library for
--   generating shallow tree walking combinators, for use with the KURE
--   DSL.
@package kure-your-boilerplate
@version 0.1.3


-- | This module contains a Template Haskell based generator for the many
--   data-type specific functions that KURE want users to write. KURE Your
--   Boilerplate (KYB) attempts to make writing these function easy.
--   Eventually, there will be a small DSL for effects inside the generated
--   functions.
--   
--   Unfortunately, you still need to write the <a>Term</a> instance by
--   hand, because of the use of type families, a feature that post-dates
--   Template Haskell. You also need to write the single MyGeneric
--   datatype, which is considered documentation of what you want KYB to
--   do.
--   
--   <a>kureYourBoilerplate</a> generates a <a>Walker</a> instance for
--   every data-type mentioned in your Generic, a <a>Walker</a> instance
--   for the Generic type itself, and the following for every constructor
--   in every data-structure that is mentioned in Generic. For exmaple if a
--   constructor is called <tt>Foo</tt>, and has type <tt>Foo :: A -&gt; B
--   -&gt; C</tt>, we generate
--   
--   <ul>
--   <li><tt>fooR :: (...) =&gt; R A -&gt; R B -&gt; R C --</tt> congruence
--   over <tt>Foo</tt>.</li>
--   <li><tt>fooU :: (...,Monoid r) =&gt; T A r -&gt; T B r -&gt; T C r
--   --</tt> unify the interesting arguments of a <tt>Foo</tt>.</li>
--   <li><tt>fooG :: (...) =&gt; R C --</tt> guard for the constructor
--   <tt>Foo</tt>.</li>
--   <li><tt>fooP :: (...) =&gt; (A -&gt; B -&gt; T C a) -&gt; T C a
--   --</tt> pattern matching on <tt>Foo</tt>.</li>
--   <li><tt>withFoo :: (...,Failable f) =&gt; (A -&gt; B -&gt; f a) -&gt;
--   C -&gt; f a --</tt> application and pattern matching on
--   <tt>Foo</tt>.</li>
--   </ul>
--   
--   Here, R is short for a 'Rewrite m dec', and 'T is short for 'Translate
--   m dec'.
--   
--   An example of use is
--   
--   <pre>
--   $(kureYourBoilerplate ''MyGeneric [(''Id,''())])
--   </pre>
--   
--   Which means <tt>MyGeneric</tt> is my universal type, <tt>Id</tt> is my
--   monad, and <tt>()</tt> is my monoid.
module Language.KURE.Boilerplate

-- | <a>kureYourBoilerplate</a> generates a number of functions for each
--   data-type mentioned in our given Generic data-type, which we need to
--   provide for KURE, as well as the Walker instance.
--   
--   The first argument is the name of the Generic data-structure, which
--   you need to write by hand. If you provide the name of a type synonym
--   as the first argument, then KYB assumes that you are acting over a
--   single data-type, i.e. you generic is your AST type. If you provide
--   the name of a data-type (the typical use-case), then this function
--   generates code for every conceptual sub-type of the provided
--   data-type.
--   
--   The second argument is the monad over which you will be parameterizing
--   your rewrite rules, and the third argument is the monoid over which
--   you will be parameterizing.
kureYourBoilerplate :: Name -> [(Name, Name)] -> Q [Dec]
