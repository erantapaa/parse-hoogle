-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Graph of the subtype relation
--   
@package th-typegraph
@version 0.18


-- | The <a>Expanded</a> class helps keep track of which <a>Type</a> values
--   have been fully expanded to a canonical form. This lets us use the
--   <a>Eq</a> and <a>Ord</a> relationships on <a>Type</a> and <a>Pred</a>
--   values when reasoning about instance context. What the
--   <a>expandType</a> function does is use the function from
--   <tt>th-desugar</tt> to replace occurrences of <tt>ConT name</tt> with
--   the associated <a>Type</a> if <tt>name</tt> is a declared type synonym
--   <tt>TySynD name _ typ</tt>. For convenience, a wrapper type <a>E</a>
--   is provided, along with the <a>Expanded</a> instances <tt>E Type</tt>
--   and <tt>E Pred</tt>. Now the <a>expandType</a> and <a>expandPred</a>
--   functions can be used to return values of type <tt>E Type</tt> and
--   <tt>E Pred</tt> respectively.
--   
--   Instances <tt>Expanded Type Type</tt> and <tt>Expanded Pred Pred</tt>
--   are provided in <a>Language.Haskell.TH.Context.Unsafe</a>, for when
--   less type safety is required.
module Language.Haskell.TH.TypeGraph.Expand

-- | This class lets us use the same expand* functions to work with
--   specially marked expanded types or with the original types.
class Expanded un ex | ex -> un
markExpanded :: Expanded un ex => un -> ex
runExpanded' :: Expanded un ex => ex -> un
runExpanded :: Expanded a (E a) => E a -> a

-- | Apply the th-desugar expand function to a <a>Type</a> and mark it as
--   expanded.
expandType :: (DsMonad m, Expanded Type e) => Type -> m e

-- | Apply the th-desugar expand function to a <a>Pred</a> and mark it as
--   expanded. Note that the definition of <a>Pred</a> changed in
--   template-haskell-2.10.0.0.
expandPred :: (DsMonad m, Expanded Pred e) => Pred -> m e

-- | Expand a list of <a>Type</a> and build an expanded <a>ClassP</a>
--   <a>Pred</a>.
expandClassP :: (DsMonad m, Expanded Pred e) => Name -> [Type] -> m e

-- | A concrete type for which Expanded instances are declared below.
newtype E a
E :: a -> E a
instance Eq a => Eq (E a)
instance Ord a => Ord (E a)
instance Show a => Show (E a)
instance Ppr a => Ppr (E a)
instance Expanded Pred (E Pred)
instance Expanded Type (E Type)


-- | Degenerate instances of Expanded that must be explicitly imported if
--   you want to use them. They are fine for simple uses of expandType, but
--   not if you are trying to use the return value of expandType as a Map
--   key.
module Language.Haskell.TH.TypeGraph.Unsafe
instance Expanded Pred Pred
instance Expanded Type Type


-- | Helper functions for dealing with record fields, type shape, type
--   arity, primitive types, and pretty printing.
module Language.Haskell.TH.TypeGraph.Core
unReify :: Data a => a -> a
unReifyName :: Name -> Name
data FieldType
FieldType :: Int -> Either StrictType VarStrictType -> FieldType
fPos :: FieldType -> Int
fNameAndType :: FieldType -> Either StrictType VarStrictType
type Field = (Name, Name, Either Int Name)
fName :: FieldType -> Maybe Name

-- | fType' with leading foralls stripped
fType :: FieldType -> Type
constructorFields :: Con -> [FieldType]

-- | Given the list of constructors from a Dec, dispatch on the different
--   levels of complexity of the type they represent - a wrapper is a
--   single arity one constructor, an enum is several arity zero
--   constructors, and so on.
foldShape :: Monad m => ([(Con, [FieldType])] -> m r) -> (Con -> [FieldType] -> m r) -> ([Con] -> m r) -> (Con -> FieldType -> m r) -> [Con] -> m r
constructorName :: Con -> Name

-- | Compute the arity of a type - the number of type parameters that must
--   be applied to it in order to obtain a concrete type.
typeArity :: Quasi m => Type -> m Int

-- | Pretty print a <a>Ppr</a> value on a single line with each block of
--   white space (newlines, tabs, etc.) converted to a single space.
pprint' :: Ppr a => a -> [Char]
unlifted :: (IsUnlifted t, Quasi m) => t -> m Bool
instance Typeable FieldType
instance Eq FieldType
instance Ord FieldType
instance Show FieldType
instance Data FieldType
instance IsUnlifted Info
instance IsUnlifted Type
instance IsUnlifted Con
instance IsUnlifted Dec
instance Lift (E Type)
instance (Lift a, Lift b) => Lift (Map a b)
instance Lift a => Lift (Set a)
instance Ppr (Maybe Field, Type)
instance Ppr (Maybe Field, E Type)
instance Ppr FieldType
instance Ppr ()
instance Ppr Field


-- | Abstract operations on Maps containing graph edges.
module Language.Haskell.TH.TypeGraph.Graph
type GraphEdges node key = Map key (node, Set key)

-- | Build a graph from the result of typeGraphEdges, each edge goes from a
--   type to one of the types it contains. Thus, each edge represents a
--   primitive lens, and each path in the graph is a composition of lenses.
graphFromMap :: Ord key => GraphEdges node key -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)

-- | Isolate and remove some nodes
cut :: (Eq a, Ord a) => Set a -> GraphEdges node a -> GraphEdges node a

-- | Monadic predicate version of <a>cut</a>.
cutM :: (Functor m, Monad m, Eq a, Ord a) => (a -> m Bool) -> GraphEdges node a -> m (GraphEdges node a)

-- | Remove all the in- and out-edges of some nodes
isolate :: (Eq a, Ord a) => Set a -> GraphEdges node a -> GraphEdges node a

-- | Monadic predicate version of <a>isolate</a>.
isolateM :: (Functor m, Monad m, Eq a, Ord a) => (a -> m Bool) -> GraphEdges node a -> m (GraphEdges node a)

-- | Remove some nodes and extend each of their in-edges to each of their
--   out-edges
dissolve :: (Eq a, Ord a) => Set a -> GraphEdges node a -> GraphEdges node a

-- | Monadic predicate version of <a>dissolve</a>.
dissolveM :: (Functor m, Monad m, Eq a, Ord a) => (a -> m Bool) -> GraphEdges node a -> m (GraphEdges node a)
instance Ppr key => Ppr (GraphEdges node key)

module Language.Haskell.TH.TypeGraph.Info

-- | Information collected about the graph implied by the structure of one
--   or more <a>Type</a> values.
data TypeGraphInfo
emptyTypeGraphInfo :: TypeGraphInfo

-- | Build a TypeGraphInfo value by scanning the supplied types
typeGraphInfo :: DsMonad m => [Type] -> m TypeGraphInfo
fields :: Lens' TypeGraphInfo (Map (E Type) (Set (Name, Name, Either Int Name)))
infoMap :: Lens' TypeGraphInfo (Map Name Info)
synonyms :: Lens' TypeGraphInfo (Map (E Type) (Set Name))
typeSet :: Lens' TypeGraphInfo (Set Type)
instance Lift TypeGraphInfo
instance Show TypeGraphInfo
instance Eq TypeGraphInfo
instance Ord TypeGraphInfo
instance Ppr TypeGraphInfo

module Language.Haskell.TH.TypeGraph.Vertex

-- | For simple type graphs always set _field and _synonyms to Nothing.
data TypeGraphVertex
TypeGraphVertex :: Maybe (Name, Name, Either Int Name) -> Set Name -> E Type -> TypeGraphVertex

-- | The record filed which contains this type
_field :: TypeGraphVertex -> Maybe (Name, Name, Either Int Name)

-- | All the type synonyms that expand to this type
_syns :: TypeGraphVertex -> Set Name

-- | The fully expanded type
_etype :: TypeGraphVertex -> E Type
field :: Lens' TypeGraphVertex (Maybe (Name, Name, Either Int Name))
syns :: Lens' TypeGraphVertex (Set Name)
etype :: Lens' TypeGraphVertex (E Type)

-- | Return the set of <a>Name</a> of a type's synonyms, plus the name (if
--   any) used in its data declaration. Note that this might return the
--   empty set.
typeNames :: TypeGraphVertex -> Set Name
bestType :: TypeGraphVertex -> Type
typeVertex :: DsMonad m => Type -> m TypeGraphVertex
fieldVertex :: DsMonad m => Type -> (Name, Name, Either Int Name) -> m TypeGraphVertex
oldVertex :: DsMonad m => (Maybe Field, Type) -> m TypeGraphVertex
instance Lift TypeGraphVertex
instance Eq TypeGraphVertex
instance Ord TypeGraphVertex
instance Show TypeGraphVertex
instance Ppr TypeGraphVertex


-- | Operations using <tt>MonadReader (TypeGraphInfo hint)</tt>.
module Language.Haskell.TH.TypeGraph.Monad

-- | Build the vertices that involve a particular type - if the field is
--   specified it return s singleton, otherwise it returns a set containing
--   a vertex one for the type on its own, and one for each field
--   containing that type.
fieldVertices :: MonadReader TypeGraphInfo m => TypeGraphVertex -> m (Set TypeGraphVertex)
allVertices :: (Functor m, DsMonad m, MonadReader TypeGraphInfo m) => Maybe Field -> E Type -> m (Set TypeGraphVertex)

-- | Build a vertex from the given <a>Type</a> and optional <a>Field</a>.
vertex :: (DsMonad m, MonadReader TypeGraphInfo m) => Maybe Field -> E Type -> m TypeGraphVertex

-- | Build a non-field vertex
typeVertex :: MonadReader TypeGraphInfo m => E Type -> m TypeGraphVertex

-- | Build a vertex associated with a field
fieldVertex :: MonadReader TypeGraphInfo m => E Type -> Field -> m TypeGraphVertex

-- | Given the discovered set of types and maps of type synonyms and
--   fields, build and return the GraphEdges relation on TypeGraphVertex.
--   This is not a recursive function, it stops when it reaches the field
--   types.
typeGraphEdges :: (DsMonad m, Functor m, Default hint, MonadReader TypeGraphInfo m) => m (GraphEdges hint TypeGraphVertex)

-- | Simplify a graph by throwing away the field information in each node.
--   This means the nodes only contain the fully expanded Type value (and
--   any type synonyms.)
simpleEdges :: Monoid hint => GraphEdges hint TypeGraphVertex -> GraphEdges hint TypeGraphVertex
simpleVertex :: TypeGraphVertex -> TypeGraphVertex

module Language.Haskell.TH.TypeGraph.Free
freeTypeVars :: (FreeTypeVars t, Quasi m) => t -> m (Set Name)
instance FreeTypeVars (Name, Strict, Type)
instance FreeTypeVars (Strict, Type)
instance FreeTypeVars Con
instance FreeTypeVars Type
instance FreeTypeVars a => FreeTypeVars [a]
instance Show St

module Language.Haskell.TH.TypeGraph
