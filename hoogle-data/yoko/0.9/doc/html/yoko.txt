-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic Programming with Disbanded Data Types
--   
--   Based off of the paper "A Pattern for Almost Homomorphic Functions" at
--   <a>http://www.ittc.ku.edu/~nfrisby/frisby-wgp-2012.pdf</a>, presented
--   at the Workshop on Generic Programming 2012. Also, my dissertation
--   <a>http://www.ittc.ku.edu/~nfrisby/frisby-dissertation.pdf</a>
--   
--   <tt>yoko</tt> views a nominal datatype as a <i>band</i> of
--   constructors, each a nominal type in its own right. Such datatypes can
--   be disbanded via the <tt>disband</tt> function into an anonymous sum
--   of nominal constructors, and vice versa via the <tt>band</tt>
--   function. This library uses extensive type-level programming to enrich
--   its <tt>instant-generics</tt> foundation with capabilities derived
--   from the constructor-centric perspective.
--   
--   For example, consider the following <i>nominal datatype</i>.
--   
--   <pre>
--   data Beatles = John ... | Paul ... | George ... | Ringo ...
--   </pre>
--   
--   This type can of course be understood as a sum of the individual
--   <i>fields types</i>.
--   
--   <pre>
--   data John   = John   ...
--   data Paul   = Paul   ...
--   data George = George ...
--   data Ringo  = Ringo  ...
--   </pre>
--   
--   <tt>yoko</tt>'s conceptual foundations start there. In particular,
--   this allows a constructor, say <tt>John</tt>, to be used independently
--   of its original range type and sibling constructors.
--   
--   As a generic programming library, <tt>yoko</tt> extends
--   <tt>instant-generics</tt> with support for constructor-centric generic
--   programming. The <tt>Examples/LambdaLift/LambdaLift.hs</tt> file
--   distributed with the <tt>yoko</tt> source demonstrates defining a
--   lambda-lifting conversion between the two types <tt>ULC</tt>, which
--   has lambdas, and <tt>Prog</tt>, which has top-level function
--   declarations instead.
--   
--   <pre>
--   data ULC = Lam Type ULC | Var Int | Let [Decl] ULC | App ULC ULC
--   
--   data Decl = Decl Type ULC
--   
--   data Prog = Prog [FunDec] TLF
--   type FunDec = ([Type], [Type], Type, TLF)
--   
--   data TLF = Top Int [Occ] | Occ Occ | App TLF TLF
--   data Occ = Par Int | Env Int
--   </pre>
--   
--   These types are defined in separate modules, since they have
--   constructors with the same name. Indeed, the fact that they having
--   matching constructors named <tt>App</tt> is crucial for
--   <tt>yoko</tt>'s automatic conversion from <tt>ULC</tt>'s <tt>App</tt>
--   to <tt>TLF</tt>'s <tt>App</tt>. As written, the generic lambda-lifter
--   would continue to work for any new <tt>ULC</tt> constructors (e.g.
--   syntax for tuples or mutable references) as long as constructors with
--   the same names and analogous fields were added to <tt>TLF</tt> and the
--   semantics of those constructors doesn't involve binding. This default
--   <i>generic</i> behavior of the lambda-lifter is specified in about ten
--   lines of user code.
--   
--   The non-generic code is much more complicated. This is intentional: I
--   wanted to show that sometimes shoehorning an algorithm into the
--   requisite type (<i>ie</i> <tt>a -&gt; m a'</tt>) can be difficult and
--   require subtleties like backwards state.
--   
--   Existing generic libraries don't use constructor names to the degree
--   that <tt>yoko</tt> does, and so cannot accomodate generic
--   <i>conversions</i> as well.
@package yoko
@version 0.9


-- | Some type-level programming basics.
module Data.Yoko.TypeBasics

-- | A polykinded proxy.
data Proxy a
Proxy :: Proxy a

-- | Convenient synonym. <tt>type Equal a b = <a>IsEQ</a>
--   (<a>SpineCompare</a> a b)</tt>
type Equal a b = IsEQ (SpineCompare a b)

-- | Template Haskell derivation for the <tt>type-spine</tt> and
--   <tt>type-cereal</tt> packages' <a>Spine</a> and <a>Serialize</a> type
--   families, which support generic instances of <tt>Compare</tt>.
derive_data :: Name -> Q [Dec]
derive_pro :: Name -> Q [Dec]

-- | Returns a type-level boolean from <tt>type-booleans</tt>.

-- | Type-level <tt>mplus</tt> for <tt>Maybe</tt>.

-- | Type-level <tt>fmap</tt> for <tt>Maybe</tt>.

-- | Encode uses the <tt>cereal</tt> package serializer to encode the value
--   and then uses <tt>type-digits</tt> to reflect it as a type-level
--   numeral.
encode :: Serialize a => a -> Type


-- | Basic support for folding through type-level sums.
module Data.Yoko.Each

-- | The constraint <tt>Each con sum</tt> corresponds to the constraing
--   <tt>forall dc in sum. con dc</tt>.
type Each = Each_

-- | Fold through a type-level sum.
each :: Each cxt sum => Proxy cxt -> (forall a. cxt a => a -> b) -> sum -> b
instance (Each_ cxt a, Each_ cxt b) => Each_ cxt (a :+: b)
instance (cxt a) => Each_ cxt (N a)

module Data.Yoko.TH

-- | Derive fields types and all <tt>yoko</tt> instances for a given data
--   type.
yokoTH :: Name -> Q [Dec]

-- | Customized derivation.
yokoTH_with :: YokoOptions -> Name -> Q [Dec]

-- | The default <tt>yoko</tt> derivations can be customised.
data YokoOptions
YokoOptions :: ((String -> String) -> (String -> String)) -> ([(Int, Mapping)] -> [(Int, Mapping)]) -> YokoOptions

-- | How fields type names are derived from constructor names. Defaults to
--   <tt>(++ "_")</tt>.
renamer :: YokoOptions -> (String -> String) -> (String -> String)

-- | How applications of higher-rank data types are represented. Defaults
--   to <tt>[(1, <a>Mapping</a> ''Par1 'Par1 'invmap), (2, <a>Mapping</a>
--   ''Par2 'Par2 'invmap2)]</tt>.
mappings :: YokoOptions -> [(Int, Mapping)] -> [(Int, Mapping)]

-- | A <a>Mapping</a> identifies the representation type, its constructor,
--   and the associated mapping function. For example, <a>Par1</a> is
--   represented with <tt>Mapping ''Par1 'Par1 'invmap</tt>.
data Mapping
Mapping :: Name -> Name -> Name -> Mapping
containerTypeName :: Mapping -> Name
containerCtor :: Mapping -> Name
methodName :: Mapping -> Name

-- | The default options. <tt>yokoDefaults = YokoOptions id id</tt>.
yokoDefaults :: YokoOptions
instance Show Target
instance Show Renamer
instance Show Mappings
instance Show BindingGroup
instance Show TargetData
instance Show TargetType
instance Show TargetKind
instance Name TargetKind
instance Name TargetType
instance Name TargetData
instance Name BindingGroup
instance Name Mappings
instance Name Renamer
instance Name Target


-- | This is the entire library, excluding the fancy builder of precise
--   cases from <a>Data.Yoko.SmartPreciseCase</a>.
module Data.YokoRaw

-- | The empty sum. Used as an error type instead of a represention type,
--   since data types with no constructors are uninteresting from a generic
--   programming perspective -- there's just not much to be done
--   generically.
data Void

-- | The singleton sum.
newtype N a
N :: a -> N a

-- | Sum union.
data (:+:) a b
L :: a -> :+: a b
R :: b -> :+: a b

-- | The empty product.
data U
U :: U

-- | Product union.
data (:*:) a b
(:*:) :: a -> b -> :*: a b

-- | A recursive occurrence.
newtype Rec a
Rec :: a -> Rec a

-- | A non-recursive occurrence.
newtype Dep a
Dep :: a -> Dep a

-- | Representation of unary type application. <tt>f</tt> is a genuine
--   <tt>*-&gt;*</tt> type, not a representation. <tt>a</tt> is a
--   representation.
newtype Par1 f a
Par1 :: (f a) -> Par1 f a

-- | Representation of binary type application. <tt>f</tt> is a genuine
--   <tt>*-&gt;*-&gt;*</tt> type, not a representation. <tt>a</tt> and
--   <tt>b</tt> are representations.
newtype Par2 f a b
Par2 :: (f a b) -> Par2 f a b

-- | A mapping to the structural representation of a fields type: just
--   products of fields, no sums -- fields types have just one constructor.

-- | Converts between a fields type and its product-of-fields structure.
class Generic a
rep :: Generic a => a -> Rep a
obj :: Generic a => Rep a -> a
unN :: N t -> t
foldN :: (b -> c) -> N b -> c
mapN :: (b1 -> b) -> N b1 -> N b
foldPlus :: (t1 -> t) -> (t2 -> t) -> :+: t1 t2 -> t
mapPlus :: (t -> b) -> (t1 -> b1) -> :+: t t1 -> :+: b b1
foldTimes :: (t3 -> t4 -> t) -> (t1 -> t3) -> (t2 -> t4) -> :*: t1 t2 -> t
mapTimes :: (t -> a) -> (t1 -> b) -> :*: t t1 -> :*: a b
unRec :: Rec t -> t
mapRec :: (t -> a) -> Rec t -> Rec a
unDep :: Dep t -> t
unPar1 :: Par1 t t1 -> t t1
unPar2 :: Par2 t t1 t2 -> t t1 t2

-- | We avoid empty sums with a type-level <tt>Maybe</tt>.
--   <tt>DistMaybePlus</tt> performs sum union on lifted sums, only
--   introducing <tt>:+:</tt> when both arguments are <tt>Just</tt>s.

-- | <tt>Tag</tt> returns a simulated type-level string that is the name of
--   the constructor that the <tt>dc</tt> fields type represents.

-- | <tt>Codomain</tt> is the data type that contains the constructor that
--   the fields type <tt>dc</tt> represents. It can also be applied to sums
--   of fields types, in which case it just uses the left-most.

-- | Any fields type can be further represented as a product-of-fields and
--   can be injected back into the original data type.
class (Generic dc, DT (Codomain dc)) => DC dc
rejoin :: DC dc => dc -> Codomain dc

-- | The <tt>DCs</tt> of a data type is sum of all of its fields types.

-- | <tt>DT</tt> disbands a data type if all of its fields types have
--   <tt>DC</tt> instances.
class Each IsDCOf (DCs t) => DT t
disband :: DT t => t -> DCs t

-- | <tt>one</tt> extends a function that consumes a fields type to a
--   function that consumes a disbanded data type containing just that
--   fields type.
one :: (dc -> a) -> N dc -> a

-- | Combines two functions that consume disbanded data types into a
--   function that consumes their union. All fields types must be from the
--   same data type.
(|||) :: Codomain sumL ~ Codomain sumR => (sumL -> a) -> (sumR -> a) -> sumL :+: sumR -> a

-- | <pre>
--   f ||. g = f <a>|||</a> one g
--   </pre>
(||.) :: ~ * (Codomain sumL) (Codomain dc) => (sumL -> a) -> (dc -> a) -> :+: sumL (N dc) -> a

-- | <pre>
--   f .|| g = one f <a>|||</a> g
--   </pre>
(.||) :: ~ * (Codomain sumR) (Codomain dc) => (dc -> a) -> (sumR -> a) -> :+: (N dc) sumR -> a

-- | <pre>
--   f .|. g = one f <a>|||</a> one g
--   </pre>
(.|.) :: ~ * (Codomain dc) (Codomain dc1) => (dc -> a) -> (dc1 -> a) -> :+: (N dc) (N dc1) -> a

-- | <tt>disbanded</tt> injects a fields type into its disbanded range
disbanded :: Embed (N dc) (DCs (Codomain dc)) => dc -> DCs (Codomain dc)

-- | <tt>band</tt>s a disbanded data type back into its normal data type.
--   
--   Since <tt>Disbanded</tt> is a type family, the range of <tt>band</tt>
--   determines the <tt>t</tt> type variable.
band :: Each (ConDCOf t) (DCs t) => DCs t -> t
class (Codomain dc ~ t, DC dc) => ConDCOf t dc

-- | <tt>precise_case</tt> is an exactly-typed case: the second argument is
--   the discriminant, the first argument is the default case, and the
--   third argument approximates a list of alternatives.
--   
--   <pre>
--   precise_case default x $
--     ((C0_ ...) -&gt; ...) <a>.||</a>
--     ((C1_ ...) -&gt; ...) <a>.|.</a>
--     ((C2_ ...) -&gt; ...)
--   </pre>
--   
--   In this example, <tt>C0_</tt>, <tt>C1_</tt>, and <tt>C2_</tt> are
--   fields types. The other fields types for the same data type are
--   handled with the <tt>default</tt> function.
precise_case :: (Codomain dcs ~ t, Codomain (DCs t) ~ t, DT t, Partition (DCs t) dcs (DCs t :-: dcs)) => (DCs t :-: dcs -> a) -> t -> (dcs -> a) -> a
class Embed sub sup
class Partition sup subL subR
embed :: (Codomain sub ~ Codomain sup, Embed sub sup) => sub -> sup

-- | <tt>inject</tt>s a fields type into a sum of fields types.
inject :: Embed (N dc) sum => dc -> sum

-- | <tt>partition</tt>s a sum of fields type into a specified sum of
--   fields types and the remaining sum.
partition :: (Codomain sum ~ Codomain sub, Partition sum sub (sum :-: sub)) => sum -> Either sub (sum :-: sub)

-- | <tt>project</tt>s a single fields type out of a disbanded data type.
project :: (Codomain sum ~ Codomain dc, Partition sum (N dc) (sum :-: N dc)) => sum -> Either dc (sum :-: N dc)

-- | <tt>reps</tt> maps a disbanded data type to its sum-of-products
--   representation.
reps :: EachGeneric sum => sum -> EachRep sum
class EachGeneric sum

-- | <tt>ig_from x =</tt> 'reps $ disband' <tt>x</tt> is a convenience. It
--   approximates the <tt>instant-generics</tt> view, less the <tt>CEq</tt>
--   annotations.
ig_from :: (DT t, EachGeneric (DCs t)) => t -> EachRep (DCs t)

-- | Convenient synonym. <tt>type Equal a b = <a>IsEQ</a>
--   (<a>SpineCompare</a> a b)</tt>
type Equal a b = IsEQ (SpineCompare a b)
instance (EachGeneric a, EachGeneric b) => EachGeneric (a :+: b)
instance Generic a => EachGeneric (N a)
instance (Codomain dc ~ t, DC dc) => ConDCOf t dc


-- | Using some McBride "Faking It" style trickery to make
--   <tt>precise_case</tt> polyvariadic in the ad-hoc cases.
--   
--   E.g.
--   
--   <pre>
--   precise_case x (\(C_ a b) -&gt; special_case a b) (Default $ \x -&gt; generic_function x)
--   </pre>
--   
--   and
--   
--   <pre>
--   precise_case x (\(C_ a b) -&gt; special_case a b) (\(D_ x) -&gt; special_case2 x) (Default $ \x -&gt; generic_function x)
--   </pre>
--   
--   both work.
module Data.Yoko.SmartPreciseCase
class Error_precise_case_requires_at_least_1_special_case a
data AdHoc dcs dt r
AdHoc :: dt -> (dcs -> r) -> AdHoc dcs dt r
newtype Default a
Default :: a -> Default a
class Builder adhoc bldr
precise_case_ :: Builder adhoc bldr => adhoc -> bldr
newtype Start dt
Start :: dt -> Start dt
precise_case :: Builder (Start dt) bldr => dt -> bldr
instance (DT dt, dt ~ Codomain dcs, dt ~ Codomain (DCs dt), Partition (DCs dt) dcs (DCs dt :-: dcs), x ~ ((DCs dt :-: dcs) -> r), final ~ r) => Builder (AdHoc dcs dt r) (Default x -> final)
instance (dt ~ Codomain dc, dt ~ Codomain dcs, r ~ r', Builder (AdHoc (dcs :+: N dc) dt r) bldr) => Builder (AdHoc dcs dt r) ((dc -> r') -> bldr)
instance (dt ~ Codomain dc, Builder (AdHoc (N dc) (Codomain dc) r) bldr) => Builder (Start dt) ((dc -> r) -> bldr)
instance Error_precise_case_requires_at_least_1_special_case () => Builder (Start dt) (Default a -> b)


-- | This omnibus module is the only necessary import for using the
--   <tt>yoko</tt> generic programming library.
--   
--   (Some sophisticated functions' types might require the import of the
--   <a>Data.Yoko.TypeBasics</a> or <a>Data.Yoko.Each</a> modules.)
--   
--   The <a>Data.Yoko.HCompos</a> module defines the generic homomorphism;
--   see the paper "A Pattern for Almost Homomorphic Functions" at
--   <a>http://www.ittc.ku.edu/~nfrisby/frisby-wgp-2012.pdf</a>, published
--   at the Workshop on Generic Programming 2012. Much more details in my
--   dissertation:
--   <a>http://www.ittc.ku.edu/~nfrisby/frisby-dissertation.pdf</a>.
--   
--   <tt>dc</tt> type variables abstract over <i>fields types</i>.
--   
--   <tt>dcs</tt> and <tt>sum</tt> type variables abstract over sums of
--   <i>fields types</i>.
--   
--   Types of the form <tt><a>DC</a> t</tt> are <i>disbanded data
--   types</i>; for each fields type <tt>dc</tt> in the resulting sum,
--   <tt><a>Codomain</a> dc ~ t</tt>. That means they all correspond to
--   constructors from <tt>t</tt>.
--   
--   A complete Template Haskell deriver is provided in the
--   <a>Data.Yoko.TH</a> module.
--   
--   It works for the data types that `instant-generics` works on,
--   excluding indexed data types. Yell loudly if you need that... then
--   send me an email :) HTH!
module Data.Yoko


-- | The generic homomorphism or "heterogenous compos".
--   
--   See the paper "A Pattern for Almost Homomorphic Functions" at
--   <a>http://www.ittc.ku.edu/~nfrisby/frisby-2012-wgp.pdf</a>, presented
--   at the Workshop on Generic Programming 2012.
module Data.Yoko.HCompos

-- | The applicative functor required by the conversion.

-- | Use the conversion <tt>cnv</tt> to convert from <tt>a</tt> to
--   <tt>b</tt>.
class Applicative (Idiom cnv) => Convert cnv a b
convert :: Convert cnv a b => cnv -> a -> Idiom cnv b

-- | The generic version of <tt>convert</tt>; operates on <i>disbanded data
--   types</i>.
class Applicative (Idiom cnv) => HCompos cnv a t
hcompos :: HCompos cnv a t => cnv -> a -> Idiom cnv t
data FoundDC star
NoCorrespondingConstructorFor_In_ :: star -> star -> FoundDC star
Match :: star -> FoundDC star

-- | <tt>FindDCs dcA dcBs</tt> returns a type-level <tt>Maybe</tt>.
--   <tt>Just dcB</tt> is a fields type <tt>dcB</tt> where <tt><a>Tag</a>
--   dcA ~ dcB</tt>.
data ResultsInIncompatibleFields (dcA :: *) (dcB :: *)
ResultsInIncompatibleFields :: ResultsInIncompatibleFields

-- | Same as <tt>compos</tt> semantics, but with a generalized type and
--   just for converting between product representations.
class Applicative (Idiom cnv) => MapRs cnv msg dc dc' prod prod'
mapRs :: MapRs cnv msg dc dc' prod prod' => cnv -> msg -> Proxy dc -> Proxy dc' -> prod -> Idiom cnv prod'
instance (Bitraversable f, MapRs cnv msg dc dc' a a', MapRs cnv msg dc dc' b b') => MapRs cnv msg dc dc' (Par2 f a b) (Par2 f a' b')
instance (Traversable f, MapRs cnv msg dc dc' a a') => MapRs cnv msg dc dc' (Par1 f a) (Par1 f a')
instance (MapRs cnv msg dc dc' a a', MapRs cnv msg dc dc' b b') => MapRs cnv msg dc dc' (a :*: b) (a' :*: b')
instance Applicative (Idiom cnv) => MapRs cnv msg dc dc' U U
instance Applicative (Idiom cnv) => MapRs cnv msg dc dc' (Dep a) (Dep a)
instance Convert cnv a b => MapRs cnv msg dc dc' (Rec a) (Rec b)
instance (Generic dcA, 'Match * dcB ~ WithMessage dcA b (FindDCs (Tag dcA) (DCs b)), MapRs cnv (ResultsInIncompatibleFields dcA dcB) dcA dcB (Rep dcA) (Rep dcB), DC dcB, Codomain dcB ~ b, DT b) => HCompos cnv (N dcA) b
instance (HCompos cnv a t, HCompos cnv b t) => HCompos cnv (a :+: b) t
instance (Applicative i, a ~ x, b ~ y) => Convert (a -> i b) x y
