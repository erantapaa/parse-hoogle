-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Win32 DHCP Server Management API
--   
--   This package provides a partial binding to the Win32 DHCP Server
--   Management API. Its purpose is to query and control a Microsoft DHCP
--   server. Enough functionality is defined so so that Ipv4 client lease
--   and reservation records can be manipulated programmatically._Only
--   32-bit versions of GHC are supported at this time._
--   
--   Here are a few notes on the required environment:
--   
--   <ul>
--   <li>Only 32-bit executables are supported. This is mainly because
--   pointers are assumed to be 4 bytes wide in a few places. Support for
--   64-bit executables may be added in the future.</li>
--   <li>All library calls should be supported on Windows 7 or above.</li>
--   </ul>
--   
--   <i>Simple Example and Usage</i>
--   
--   <pre>
--   -- Print all MAC addresses with an active client lease
--   module Main where
--   
--   import Data.Ip
--   import Data.Mac
--   import qualified Data.Text.IO as T
--   import System.Win32.DHCP
--   
--   main :: IO ()
--   main = do
--       api &lt;- loadDHCP
--       clients &lt;- enumClients api context
--       let macs = map (showMac ":" . clientHardwareAddress) clients
--       mapM_ T.putStrLn macs
--     where
--       Right subnet = readIp "192.168.1.0"
--       context = Context "192.168.1.5" subnet
--   </pre>
@package Win32-dhcp-server
@version 0.3.1


-- | This module was taken, with modifications, from the <a>maccatcher</a>
--   package.
module Data.Ip

-- | An Ip can be used as an IP address or subnet address.
--   
--   A <a>Show</a> instance is omitted to avoid confusion. Use
--   <a>showIp</a> and <a>readIp</a> to convert between <a>String</a>s.
data Ip

-- | Parse a <a>Text</a> value as an <a>Ip</a>. The string should be of the
--   form <a>X.X.X.X</a> where each <tt>X</tt> is a decimal value between 0
--   and 255 inclusive.
--   
--   <pre>
--   &gt;&gt;&gt; let Right ip = readIp "192.168.1.100"
--   
--   &gt;&gt;&gt; toOctets ip
--   (192, 168, 1, 100)
--   </pre>
readIp :: Text -> Either String Ip

-- | Represent an <a>Ip</a> as a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; showIp $ fromOctets 192 168 1 100
--   "192.168.1.100"
--   </pre>
showIp :: Ip -> Text

-- | An IP address is 32-bits wide. This function will construct an
--   <a>Ip</a> from 4 octets.
fromOctets :: Word8 -> Word8 -> Word8 -> Word8 -> Ip

-- | Extract each of the 4 octets from an <a>Ip</a>.
toOctets :: Ip -> (Word8, Word8, Word8, Word8)
toWord32 :: Ip -> Word32
instance Storable Ip
instance Bounded Ip
instance Ord Ip
instance Eq Ip


-- | This module was taken, with modifications, from the <a>maccatcher</a>
--   package.
module Data.Mac

-- | A Mac is a 6-byte unique identifier used in layer-two network
--   addressing. Its <a>Storable</a> instance occupies 6 bytes of memory
--   when <a>poke</a>d with the first byte occupying the lowest address,
--   and the last byte occupying the highest address.
--   
--   A <a>Show</a> instance is omitted to avoid confusion. Use
--   <a>showMac</a> and <a>readMac</a> to convert between <a>String</a>s.
data Mac

-- | Parse a <a>Text</a> value as a <a>Mac</a>. The string should not use
--   any separators between octets.
--   
--   <pre>
--   &gt;&gt;&gt; let Right mac = readMac "000102030405"
--   
--   &gt;&gt;&gt; toOctets mac
--   (0, 1, 2, 3, 4, 5)
--   </pre>
readMac :: Text -> Either String Mac

-- | Represent a <a>Mac</a> as a <a>String</a>. The supplied separator will
--   be placed between each octet in the final output.
--   
--   <pre>
--   &gt;&gt;&gt; showMac "" $ fromOctets 0xa 0xb 0xc 0xd 0xe 0xf
--   "0a0b0c0d0e0f"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; showMac ":" $ fromOctets 0x11 0x22 0x33 0x44 0x55 0x66
--   "11:22:33:44:55:66"
--   </pre>
showMac :: Text -> Mac -> Text

-- | A Mac address is 48-bits wide. This function will construct a
--   <a>Mac</a> from 6 octets.
fromOctets :: Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Mac

-- | Extract each of the 6 octets from a <a>Mac</a>.
toOctets :: Mac -> (Word8, Word8, Word8, Word8, Word8, Word8)
toWord64 :: Mac -> Word64
instance Ord Mac
instance Eq Mac
instance Bounded Mac
instance Storable Mac


module System.Win32.DHCP

-- | In an effort to avoid potential compile-time linker errors this
--   package uses runtime dynamic linking. Internally a <a>DhcpApi</a> is a
--   dictionary of dynamically bound foreign calls. Most actions require
--   one to be passed. Simply call <tt>loadDhcp</tt> to obtain one.
data DhcpApi

-- | Calling this function performs runtime dynamic linking for every
--   internal foreign call into the Dhcp Server Management Api. It is safe
--   to call this action multiple times. I recommend calling this function
--   once as the part of a process's initialization, and then pass the
--   returned <a>DhcpApi</a> to functions that need it.
loadDHCP :: IO DhcpApi

-- | A Context defines which server and scope within that server a command
--   refers to. Microsoft's DHCP server supports multiple scopes. This
--   allows different configurations to be sent to devices based on their
--   hardware (MAC) address. Scopes are identified by their network
--   address.
data Context
[Context] :: !Text -> !Ip -> Context

-- | The DHCP server management API uses an RPC mechanism to control the
--   server.
[contextServer] :: Context -> !Text

-- | Scopes are identified by a subnet identifier. This is useful in cases
--   where multiple scopes are defined, but still required in the common
--   case of a single scope.
[contextSubnet] :: Context -> !Ip

-- | Microsoft's DHCP server supports DHCP and BOOTP. Both protocols server
--   similar purposes, but DHCP is more widely used. Lease and reservation
--   records contain a flag field indicating which protocol the record is
--   valid for. In most cases this flag will be <a>Both</a>, because that
--   is the default behavior.
data ClientType
[Unspecified] :: ClientType
[Dhcp] :: ClientType
[Bootp] :: ClientType
[Both] :: ClientType
[ReservationFlag] :: ClientType
[None] :: ClientType

-- | The number of ticks (100-nanosecond increments) since 12:00 midnight,
--   January 1, 1 C.E. in the Gregorian calendar.
--   
--   Microsoft does not provide any functions I know of for converting this
--   value into something more convenient to work with.
--   
--   <pre>
--   typedef struct _DATE_TIME {
--       DWORD dwLowDateTime;
--       DWORD dwHighDateTime;
--   } DATE_TIME,*PDATE_TIME, *LPDATE_TIME;
--   </pre>
data DATE_TIME
[DATE_TIME] :: !DWORD -> !DWORD -> DATE_TIME
data HOST_INFO
[HOST_INFO] :: !Ip -> (Maybe String) -> (Maybe String) -> HOST_INFO

-- | Filter criteria used in actions that look up reservation or lease
--   records.
--   
--   <pre>
--   typedef struct _DHCP_CLIENT_SEARCH_INFO {
--     DHCP_SEARCH_INFO_TYPE SearchType;
--     union {
--       DHCP_IP_ADDRESS ClientIpAddress;
--       DHCP_CLIENT_UID ClientHardwareAddress;
--       LPWSTR          ClientName;
--     } SearchInfo;
--   } DHCP_SEARCH_INFO, *LPDHCP_SEARCH_INFO;
--   </pre>
data SEARCH_INFO

-- | Search based on an IP address. All scopes are searched. It should not
--   be possible for multiple records to exist.
[ClientIpAddress] :: !Ip -> SEARCH_INFO

-- | Search based on a subnet and MAC address. This method of searching has
--   not been tested.
[ClientHardwareAddress] :: !Mac -> SEARCH_INFO

-- | Search based on a client's name. Multiple records may exist, and what
--   happens in that case will depend on the function being called. This
--   method of searching has not been tested.
[ClientName] :: !String -> SEARCH_INFO

-- | Information about an active lease. This type corresponds to MSDN's
--   DHCP_CLIENT_INFO_V4 structure.
--   
--   <pre>
--   typedef struct _DHCP_CLIENT_INFO_V4 {
--     DHCP_IP_ADDRESS ClientIpAddress;
--     DHCP_IP_MASK    SubnetMask;
--     DHCP_CLIENT_UID ClientHardwareAddress;
--     LPWSTR          ClientName;
--     LPWSTR          ClientComment;
--     DATE_TIME       ClientLeaseExpires;
--     DHCP_HOST_INFO  OwnerHost;
--     BYTE            bClientType;
--   } DHCP_CLIENT_INFO_V4, *LPDHCP_CLIENT_INFO_V4;
--   </pre>
data Client
[Client] :: !Ip -> !Ip -> !Mac -> Maybe String -> Maybe String -> !DATE_TIME -> !HOST_INFO -> !ClientType -> Client
[clientIp] :: Client -> !Ip
[clientSubnetMask] :: Client -> !Ip
[clientHardwareAddress] :: Client -> !Mac
[clientName] :: Client -> Maybe String
[clientComment] :: Client -> Maybe String

-- | MSDN: The date and time the DHCP client lease will expire, in UTC
--   time.
--   
--   I don't know of any available functions to work with a
--   <a>DATE_TIME</a>.
[clientLeaseExpires] :: Client -> !DATE_TIME

-- | Information on the DHCP server that assigned the lease to the client.
[clientOwnerHost] :: Client -> !HOST_INFO
[clientType] :: Client -> !ClientType

-- | Perform a lookup operation for all client lease records within a
--   scope. This action corresponds to MSDN's DhcpEnumSubnetClientsV4
--   function.
enumClients :: DhcpApi -> Context -> IO [Client]

-- | Search the DHCP server for a lease matching the given search criteria.
--   <a>Nothing</a> is returned when no lease was found. This corresponds
--   to MSDN's DhcpGetClientInfoV4 function.
lookupClient :: DhcpApi -> Text -> SEARCH_INFO -> IO (Maybe Client)

-- | Delete an active DHCP lease from the server. The <a>SEARCH_INFO</a>
--   argument determines which search criteria to use. Searching by name
--   will delete all active leases with that name. This action corresponds
--   to MSDN's DhcpDeleteClientInfoV4 function.
deleteClient :: DhcpApi -> Text -> SEARCH_INFO -> IO ()

-- | A mapping between an IP and a MAC address. Each IP number may map to
--   only one MAC address, and each MAC address may map to only one IP
--   number.
--   
--   This is a separate type from <a>Reservation</a> for practical reasons.
--   When writing software to work with a DHCP server, <a>Reservation</a>'s
--   <a>ClientType</a> field is often not important. Without the
--   <a>Mapping</a> type defined here it would often be necessary to define
--   a custom type in each project.
data Mapping
[Mapping] :: !Mac -> !Ip -> Mapping
[mappingMac] :: Mapping -> !Mac
[mappingIp] :: Mapping -> !Ip

-- | A Reservation guarantees that a device with a given Mac address will
--   always be assigned to a particular IP address. A reservation is not
--   the same thing as a lease, and there are separate calls to work with
--   both objects.
--   
--   This type corresponds to MSDN's DHCP_IP_RESERVATION_V4 structure.
--   
--   <pre>
--   typedef struct _DHCP_IP_RESERVATION_V4 {
--     DHCP_IP_ADDRESS ReservedIpAddress;
--     DHCP_CLIENT_UID *ReservedForClient;
--     BYTE            bAllowedClientTypes;
--   } DHCP_IP_RESERVATION_V4, *LPDHCP_IP_RESERVATION_V4;
--   </pre>
data Reservation
[Reservation] :: !Mapping -> !ClientType -> Reservation
[reservationMapping] :: Reservation -> !Mapping
[reservationType] :: Reservation -> !ClientType
addReservation :: DhcpApi -> Context -> Mapping -> IO ()
enumReservations :: DhcpApi -> Context -> IO [Reservation]

-- | Remove a reservation from the server
removeReservation :: DhcpApi -> Context -> Mapping -> ClientType -> Bool -> IO ()
instance Ord Context
instance Eq Context
