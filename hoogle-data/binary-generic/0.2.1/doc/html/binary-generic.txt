-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic binary serialisation using binary and syb.
--   
--   Instead of manual or semi-automated generation of instances of
--   <a>Data.Binary.Binary</a> you just derive <a>Data.Data.Data</a> and
--   the library automatically figures out how to (de-)serialize the type.
--   You may also define your own type-specific stack of serialisation
--   functions.
@package binary-generic
@version 0.2.1


-- | You can build your own type-specific stacks. For example the default
--   stack looks like this, whereas the ordering determines, which function
--   matches first for a specific type. This especially allows you to
--   override the default choices:
--   
--   <pre>
--   getExtDefault    :: Typeable a =&gt; Get a -&gt; Get a
--   getExtDefault     = getExtInteger
--                     . getExtChar
--                     . getExtWord
--                     . getExtInt
--                     . getExtFloat
--                     . getExtText
--                     . getExtByteString
--   
--   putExtDefault    :: Typeable a =&gt; (a -&gt; Put) -&gt; a -&gt; Put
--   putExtDefault     = putExtInteger
--                     . putExtChar
--                     . putExtWord
--                     . putExtInt
--                     . putExtFloat
--                     . putExtText
--                     . putExtByteString
--   </pre>
--   
--   Notice that these stacks have to be grounded, ideally with something
--   that handles algebraic types. Have a look at
--   <tt>Data.Binary.Generic</tt> how this is done for the default stack.
--   
--   IMPORTANT: You cannot simply apply an extension to <tt>getGeneric</tt>
--   or <tt>putGeneric</tt>, since these do a recursive call at the bottom
--   level which points to the top of the stack.
module Data.Binary.Generic.Extensions
extGet :: (Monad m, Typeable a, Typeable b) => m b -> m a -> m a
extPut :: (Typeable a, Typeable b) => (b -> q) -> (a -> q) -> a -> q
getExtDefault :: Typeable a => Get a -> Get a
putExtDefault :: Typeable a => (a -> Put) -> a -> Put
getExtInteger :: Typeable a => Get a -> Get a
putExtInteger :: Typeable a => (a -> Put) -> a -> Put
getExtChar :: Typeable a => Get a -> Get a
putExtChar :: Typeable a => (a -> Put) -> a -> Put
getExtWord :: Typeable a => Get a -> Get a
putExtWord :: Typeable a => (a -> Put) -> a -> Put
getExtInt :: Typeable a => Get a -> Get a
putExtInt :: Typeable a => (a -> Put) -> a -> Put
getExtFloat :: Typeable a => Get a -> Get a
putExtFloat :: Typeable a => (a -> Put) -> a -> Put
getExtText :: Typeable a => Get a -> Get a
putExtText :: Typeable a => (a -> Put) -> a -> Put
getExtByteString :: Typeable a => Get a -> Get a
putExtByteString :: Typeable a => (a -> Put) -> a -> Put


-- | For any algebraic datatype just make it an instance of class
--   <tt>Data.Data.Data</tt> by simply deriving <a>Data</a> on definition
--   or try stand-alone-deriving. This allows the library to enumerate the
--   value constructors and thereby encoding their index. Notice that
--   serialisation depends on a type's structure. Serialisations might get
--   unreadable if the type is altered.
--   
--   <a>getGeneric</a> and <a>putGeneric</a> implement a selection of
--   type-specific defaults and are grounded by a canonical serialisation
--   for all algebraic types that instantiate <a>Data</a>. Have a look at
--   <tt>Data.Binary.Generic.Extensions</tt> for details.
--   
--   If you want to ground your own type-specific stack <tt>myStack</tt> of
--   extensions write the following for the <tt>Get</tt>-part (the
--   <tt>Put</tt>-part follows analogously):
--   
--   <pre>
--   getMyStack :: Data a =&gt; Get a
--   getMyStack  = myStack (getGenericByCallback getMyStack)
--   </pre>
module Data.Binary.Generic
getAlgebraic :: Data a => Get a
putAlgebraic :: Data a => a -> Put
getGeneric :: Data a => Get a
putGeneric :: Data a => a -> Put
getGenericByCallback :: Data a => (forall d. Data d => Get d) -> Get a
putGenericByCallback :: Data a => (forall d. Data d => d -> Put) -> a -> Put
