-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementation of the kmeans clustering algorithm based on the vector package
--   
--   Provides a simple (but efficient) implementation of the k-means
--   clustering algorithm. The goal of this algorithm is to, given a set of
--   n-dimensional points, regroup them in k groups, such that each point
--   gets to be in the group to which it is the closest to (using the
--   <a>center</a> of the group).
--   
--   CHANGELOG
--   
--   <ol>
--   <li>3: total rewrite of the code, the code scales much better on big
--   inputs and is overall consistently faster than the other kmeans
--   implementations on hackage, on my laptop. 0.2: supports having feature
--   vectors associated to objects, and thus computing kmeans on these
--   vectors, letting you recover the initial objects.</li>
--   </ol>
@package kmeans-vector
@version 0.3


-- | An implementation of the k-means clustering algorithm based on the
--   vector package.
--   
--   The core functions of this module are <a>kmeans</a> and
--   <a>kmeansWith</a>. See some examples on <a>github</a>.
module Math.KMeans

-- | Run the kmeans clustering algorithm.
--   
--   <pre>
--   kmeans f distance k points
--   </pre>
--   
--   will run the algorithm using <tt>f</tt> to extract features from your
--   type, using <tt>distance</tt> to measure the distance between vectors,
--   trying to separate <tt>points</tt> in <tt>k</tt> clusters.
--   
--   Extracting features just means getting a <a>Vector</a> with
--   <a>Double</a> coordinates that will represent your type in the space
--   in which <a>kmeans</a> will run.
kmeans :: (a -> Vector Double) -> Distance -> Int -> [a] -> Clusters a

-- | Same as <a>kmeans</a>, except that instead of using <a>partition</a>,
--   you supply your own function for choosing the initial clustering. Two
--   important things to note:
--   
--   <ul>
--   <li>If you don't need any kind of effect and just have a
--   <a>partition</a>-like function you want to use, <tt>m</tt> will can
--   just be <a>Identity</a> here. If that's too obnoxious to work with,
--   please let me know and I may just provide a separate <a>kmeansWith</a>
--   function with no there. But most of the time, you'll probably just be
--   interested in the following scenario.</li>
--   <li>Most likely, you want to have something smarter than our simple
--   <a>partition</a> function. A couple of papers I have read claim very
--   decent results by using some precise probabilistic schemas for the
--   initial partitionning. In this case, your <tt>m</tt> would probably be
--   <a>IO</a> or <tt>ST</tt> (e.g using my <a>probable</a> package) and
--   you could fine-tune the way the initial clusters are picked so that
--   the algorithm may give better results. Of course, if your
--   initialization is monadic, so is the result.</li>
--   </ul>
kmeansWith :: Monad m => (Int -> [a] -> m (Clusters a)) -> (a -> Vector Double) -> Distance -> Int -> [a] -> m (Clusters a)

-- | A distance on vectors
type Distance = Vector Double -> Vector Double -> Double

-- | This is what <a>kmeans</a> hands you back. It's just a <a>Vector</a>
--   of clusters that will hopefully be of length <tt>k</tt>.
type Clusters a = Vector (Cluster a)

-- | A <a>Cluster</a> of points is just a list of points
newtype Cluster a
Cluster :: [a] -> Cluster a

-- | elements that belong to that cluster
elements :: Cluster a -> [a]

-- | This type is used internally by <a>kmeans</a>. It represents our
--   (hopefully) <tt>k</tt> centroids, obtained by computing the new
--   centroids of a <a>Cluster</a>
type Centroids = Vector (Vector Double)

-- | This is the current partitionning strategy used by <a>kmeans</a>. If
--   we want <tt>k</tt> clusters, we just try to regroup consecutive
--   elements in <tt>k</tt> buckets
partition :: Int -> [a] -> Clusters a

-- | The euclidean distance without taking the final square root This would
--   waste cycles without changing the behavior of the algorithm
euclidSq :: Distance

-- | L1 distance of two vectors: d(v1, v2) = sum on i of |v1_i - v2_i|
l1dist :: Distance

-- | L-inf distance of two vectors: d(v1, v2) = max |v1_i - v2_i]
linfdist :: Distance
instance Eq a => Eq (Cluster a)
instance Show a => Show (Cluster a)
