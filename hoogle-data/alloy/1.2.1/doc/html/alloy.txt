-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic programming library
--   
--   Alloy is a generic programming library for performing traversals of
--   data and applying specific operations to certain types. More
--   information is available in the tutorial
--   (<a>http://twistedsquare.com/Alloy-Tutorial.pdf</a>) and the draft
--   paper (<a>http://twistedsquare.com/Alloy.pdf</a>).
@package alloy
@version 1.2.1


-- | A module containing code to generate instances of the Alloy class for
--   you.
--   
--   Generating Alloy instances by hand would be laborious, complex and
--   error-prone. This module provides instance generation, based on the
--   Scrap Your Boilerplate (<a>Data.Generics</a>) generics that have
--   built-in support in GHC. So you should just need to add
--   
--   <pre>
--   deriving (Data, Typeable)
--   </pre>
--   
--   after all your data-types, then use the functions in this module to
--   generate some Haskell code with instances of the Alloy classes. The
--   simplest functions for doing this are <a>writeInstances</a> and
--   <a>writeInstancesTo</a>. The tutorial has examples of using this
--   module.
--   
--   You do not even have to modify the definitions of your data-types if
--   you are using GHC 6.8.2 or later, you can simply add these lines in
--   your module for generating the instances (assuming the data-type is
--   not hidden during import):
--   
--   <pre>
--   deriving instance Typeable Foo
--   deriving instance Data Foo
--   </pre>
--   
--   That technique, and in fact this module as a whole generates orphan
--   instances. This is generally advised against in Haskell, but it should
--   not cause any problems here.
--   
--   The primary drawback of Alloy's approach is that it can generate a lot
--   of type-class instances (generally, the square of the number of
--   types). There are two ways to control this explosion. Using
--   <a>GenWithOverlapped</a> tends to halve the number of instances, at
--   the cost of using a GHC extension. If you need instances for more than
--   one of <tt>Alloy</tt>, <tt>AlloyA</tt> and <tt>AlloyARoute</tt>, it is
--   possible to define one based on another, and thus avoid an entire set
--   of instances altogether. See the alloy-proxy-fd package on Hackage for
--   more details.
module Data.Generics.Alloy.GenInstances

-- | Generates the instances according to the options and writes it to
--   stdout with the given header (the header is a list of lines without
--   newline characters).
--   
--   The configuration can be obtained from <a>justPure</a> (for example)
--   or constructing the configuration yourself. The list of
--   <a>GenInstance</a> can be obtained through <a>genInstance</a>. The
--   header will generally be something like:
--   
--   <pre>
--   "module FooInstances where" : "import qualified Foo" : instanceImports
--   </pre>
writeInstances :: GenInstanceConfig -> [GenInstance] -> [String] -> IO ()

-- | Generates the instances according to the options and writes it to the
--   given filename with the given header (the header is a list of lines
--   without newline characters).
writeInstancesTo :: GenInstanceConfig -> [GenInstance] -> [String] -> FilePath -> IO ()

-- | Constructs a configuration that just generates instances for the
--   <tt>Alloy</tt> type-class (not <tt>AlloyA</tt> or
--   <tt>AlloyARoute</tt>).
justPure :: GenOverlappedOption -> GenInstanceConfig

-- | Constructs instances for all the type-classes: <tt>Alloy</tt>,
--   <tt>AlloyA</tt> and <tt>AlloyARoute</tt>. This may be quite a lot, see
--   the documentation at the top of this file.
allInstances :: GenOverlappedOption -> GenInstanceConfig

-- | The lines in the header that form the import statements necessary for
--   the Alloy instances.
instanceImports :: [String]

-- | Like <a>instanceImports</a> but also adds the lines needed for maps
--   and sets. If you use <a>genMapInstance</a> or <a>genSetInstance</a>,
--   use this function, otherwise <a>instanceImports</a> will suffice.
instanceImportsMapSet :: [String]

-- | Like <a>instanceImportsMapSet</a> but for <a>Vector</a>.
instanceImportsVector :: [String]

-- | A type that represents a generator for instances of a set of types.
data GenInstance

-- | Generates instances for all types within the given type. Therefore you
--   should only need one or two of these calls to cover all of a complex
--   data structure, by calling this on the largest types in your
--   structure. The function is non-strict in its argument, so the easiest
--   way to call it is:
--   
--   <pre>
--   genInstance (undefined :: MyType)
--   </pre>
genInstance :: Data t => t -> GenInstance

-- | Generates an instance for the <a>Map</a> type. Map is a difficult type
--   because its instance of Data hides its implementation, so we can't
--   actually use the Data instance to work out what the children are (as
--   we can do for other algebraic data types). So for every different Map
--   that you want to process (or that you have inside other types you want
--   to process), you must also call this function to effectively notify
--   the generation-functions of the existence of your map. We wish there
--   was an easier, non-hacky way but we can't see one.
genMapInstance :: (Ord k, Data k, Data v) => k -> v -> GenInstance

-- | Generates an instance for the <a>Set</a> type. See
--   <a>genMapInstance</a> for an explanation.
genSetInstance :: (Ord a, Data a) => a -> GenInstance

-- | Generates all the given instances (eliminating any duplicates) with
--   the given options. The return is a list of lines of code. This should
--   then be written to a Haskell module with the appropriate header.
genInstances :: GenInstanceConfig -> [GenInstance] -> IO [String]

-- | The line with a LANGUAGE pragma detailed all the extensions needed.
--   This is automatically written by <a>writeInstances</a> and
--   <a>writeInstancesTo</a> at the top of the file, but you may want to
--   use it if you are using <a>genInstances</a>.
languageExtras :: GenOverlappedOption -> String

-- | Generates an instance for the <a>Vector</a> type. Like <a>Map</a>, the
--   Data instance for Vector hides its representation.
genVectorInstance :: Data v => v -> GenInstance

-- | The option controlling whether the generated instances can be
--   overlapped. If you choose <a>GenWithOverlapped</a> many less instances
--   (around half, in our experience) will be generated, but you must
--   enable the overlapping-instances flag in GHC (-XOverlappingInstances
--   in GHC 6.8 and 6.10) when compiling the instances.
data GenOverlappedOption
GenWithOverlapped :: GenOverlappedOption
GenWithoutOverlapped :: GenOverlappedOption

-- | For now, this option has only one setting.
data GenClassOption
GenOneClass :: GenClassOption
data GenInstanceConfig
GenInstanceConfig :: GenOverlappedOption -> GenClassOption -> Bool -> Bool -> Bool -> GenInstanceConfig
genOverlapped :: GenInstanceConfig -> GenOverlappedOption
genClass :: GenInstanceConfig -> GenClassOption
genPure :: GenInstanceConfig -> Bool
genEffect :: GenInstanceConfig -> Bool
genRoute :: GenInstanceConfig -> Bool
instance Eq GenOverlappedOption
instance Read GenOverlappedOption
instance Show GenOverlappedOption
instance Eq GenClassOption
instance Read GenClassOption
instance Show GenClassOption
instance Eq GenInstanceConfig
instance Read GenInstanceConfig
instance Show GenInstanceConfig
instance Eq ClassType
instance Eq FuncType
instance Eq DataBox
instance Show FuncType
instance Show ClassType
instance Eq Witness


-- | A slightly experimental add-on for Alloy involving the idea of routes
--   to a particular part of a tree.
module Data.Generics.Alloy.Route

-- | A Route is a way of navigating to a particular node in a tree
--   structure.
--   
--   Let's say that you have some binary tree structure:
--   
--   <pre>
--   data BinTree a = Leaf a | Branch (BinTree a) (BinTree a)
--   </pre>
--   
--   Suppose you then have a big binary tree of integers, potentially with
--   duplicate values, and you want to be able to modify a particular
--   integer. You can't modify in-place, because this is a functional
--   language. So you instead want to be able to apply a modify function to
--   the whole tree that really just modifies the particular integer, deep
--   within the tree.
--   
--   To do this you can use a route:
--   
--   <pre>
--   myRoute :: Route Int (BinTree Int)
--   </pre>
--   
--   You apply it as follows (for example, to increment the integer):
--   
--   <pre>
--   routeModify myRoute (+1) myTree
--   </pre>
--   
--   This will only work if the route is valid on the given tree.
--   
--   The usual way that you get routes is via the traversal functions in
--   the module.
--   
--   Another useful aspect is composition. If your tree was in a tree of
--   trees:
--   
--   <pre>
--   routeToInnerTree :: Route (BinTree Int) (BinTree (BinTree Int))
--   </pre>
--   
--   You could compose this with the earlier route:
--   
--   <pre>
--   routeToInnerTree @-&gt; myRoute :: Route Int (BinTree (BinTree Int))
--   </pre>
--   
--   These routes are a little like zippers, but rather than building a new
--   data type to contain the zipped version and the re-use aspect, this is
--   just a simple add-on to apply a modification function in a particular
--   part of the tree. Multiple routes can be used to modify the same tree,
--   which is also useful.
--   
--   Routes support Eq, Show and Ord. All these instances represent a route
--   as a list of integers: a route-map. [0,2,1] means first child
--   (zero-based), then third child, then second child of the given
--   data-type. Routes are ordered using the standard list ordering
--   (lexicographic) over this representation.
data Route inner outer

-- | Applies a pure modification function using the given route.
routeModify :: Route inner outer -> (inner -> inner) -> (outer -> outer)

-- | Applies a monadic modification function using the given route.
routeModifyM :: Monad m => Route inner outer -> (inner -> m inner) -> (outer -> m outer)

-- | Given a route, gets the value in the large data structure that is
--   pointed to by that route.
routeGet :: Route inner outer -> outer -> inner

-- | Given a route, sets the value in the large data structure that is
--   pointed to by that route.
routeSet :: Route inner outer -> inner -> outer -> outer

-- | Composes two routes together. The outer-to-mid route goes on the left
--   hand side, and the mid-to-inner goes on the right hand side to form an
--   outer-to-inner route.
(@->) :: Route mid outer -> Route inner mid -> Route inner outer

-- | The identity route. This has various obvious properties:
--   
--   <pre>
--   routeGet identityRoute == id
--   routeSet identityRoute == const
--   routeModify identityRoute == id
--   identityRoute @-&gt; route == route
--   route @-&gt; identityRoute == route
--   </pre>
identityRoute :: Route a a

-- | Gets the integer-list version of a route. See the documentation of
--   <a>Route</a>.
routeId :: Route inner outer -> [Int]

-- | Given an index (zero is the first item), forms a route to that index
--   item in the list. So for example:
--   
--   <pre>
--   routeModify (routeList 3) (*10) [0,1,2,3,4,5] == [0,1,2,30,4,5]
--   </pre>
routeList :: Int -> Route a [a]

-- | Given the integer list of identifiers and the modification function,
--   forms a Route. It is up to you to make sure that the integer list is
--   valid as described in the documentation of <a>Route</a>, otherwise
--   routes constructed this way and via the Alloy functions may exhibit
--   strange behaviours when compared.
makeRoute :: [Int] -> (forall m. Monad m => (inner -> m inner) -> (outer -> m outer)) -> Route inner outer

-- | Constructs a Route to the key-value pair at the given index
--   (zero-based) in the ordered map. Routes involving maps are difficult
--   because Map hides its internal representation. This route secretly
--   boxes the Map into a list of pairs and back again when used. The
--   identifiers for map entries (as used in the integer list) are simply
--   the index into the map as passed to this function.
routeDataMap :: Ord k => Int -> Route (k, v) (Map k v)

-- | Constructs a Route to the value at the given index (zero-based) in the
--   ordered set. See the documentation for <a>routeDataMap</a>, which is
--   nearly identical to this function.
routeDataSet :: Ord k => Int -> Route k (Set k)

-- | An extension to <tt>AlloyA</tt> that adds in <a>Route</a>s. The opsets
--   are now parameterised over both the monad/functor, and the outer-type
--   of the route.
class AlloyARoute t o o'
transformMRoute :: (AlloyARoute t o o', Monad m) => o m outer -> o' m outer -> (t, Route t outer) -> m t
transformARoute :: (AlloyARoute t o o', Applicative f) => o f outer -> o' f outer -> (t, Route t outer) -> f t

-- | The terminator for opsets with <a>AlloyARoute</a>.
data BaseOpARoute (m :: * -> *) outer
BaseOpARoute :: BaseOpARoute outer

-- | Like <tt>baseOpA</tt> but for <a>AlloyARoute</a>.
baseOpARoute :: BaseOpARoute m outer

-- | The type that extends an applicative/monadic opset (opT) in the given
--   functor/monad (m) to be applied to the given type (t) with routes to
--   the outer type (outer). This is for use with the <a>AlloyARoute</a>
--   class.
data (:-@) t opT m outer
(:-@) :: ((t, Route t outer) -> m t) -> (opT m outer) -> :-@ t opT m outer

-- | A handy synonym for a monadic/applicative opset with only one item, to
--   use with <a>AlloyARoute</a>.
type OneOpARoute t = t :-@ BaseOpARoute

-- | A handy synonym for a monadic/applicative opset with only two items,
--   to use with <a>AlloyARoute</a>.
type TwoOpARoute s t = s :-@ (t :-@ BaseOpARoute)
instance Show (Route inner outer)
instance Ord (Route inner outer)
instance Eq (Route inner outer)


-- | The module containing the AlloyA type-class for working with effectful
--   functions (of the type <tt>a -&gt; m a</tt>). This module is an
--   analogue to <a>Data.Generics.Alloy.Pure</a> that supports functions
--   that result in a monadic or applicative functor type.
--   
--   All the functions in this module have versions for <a>Applicative</a>
--   and for <a>Monad</a>. They have the same behaviour, and technically
--   only the <a>Applicative</a> version is necessary, but since not all
--   monads have <a>Applicative</a> instances, the <a>Monad</a> versions
--   are provided for convenience.
module Data.Generics.Alloy.Effect

-- | The Alloy type-class for effectful functions, to be used with sets of
--   operations constructed from <a>BaseOpA</a> and <a>:-*</a>. You are
--   unlikely to need to use <tt>transform</tt> directly; instead use
--   'makeRecurseA'\/'makeRecurseM' and 'makeDescendA'\/'makeDescendM'.
--   
--   The first parameter to the type-class is the type currently being
--   operated on, the second parameter is the set of operations to perform
--   directly on the type, and the third parameter is the set of operations
--   to perform on its children (if none of the second parameter operations
--   can be applied).
class AlloyA t o o'
transformM :: (AlloyA t o o', Monad m) => o m -> o' m -> t -> m t
transformA :: (AlloyA t o o', Applicative f) => o f -> o' f -> t -> f t

-- | A type representing a monadic/applicative functor modifier function
--   that applies the given ops (opT) in the given monad/functor (f)
--   directly to the given type (t).
type RecurseA f opT = forall t. AlloyA t opT BaseOpA => t -> f t

-- | Given a set of operations (as described in the <a>AlloyA</a>
--   type-class), makes a recursive modifier function that applies the
--   operations directly to the given type, and then to its children, until
--   it has been applied to all the largest instances of that type.
makeRecurseA :: Applicative f => opT f -> RecurseA f opT

-- | Useful equivalent of <a>makeRecurseA</a>.
makeRecurseM :: Monad m => opT m -> RecurseA m opT

-- | A type representing a monadic/applicative functor modifier function
--   that applies the given ops (opT) in the given monad/functor (f) to the
--   children of the given type (t).
type DescendA f opT = forall t. AlloyA t BaseOpA opT => t -> f t

-- | Given a set of operations, makes a descent modifier function that
--   applies the operation to the type's children, and further down, until
--   it has been applied to all the largest instances of that type.
makeDescendA :: Applicative f => opT f -> DescendA f opT

-- | Useful equivalent of <a>makeDescendA</a>.
makeDescendM :: Monad m => opT m -> DescendA m opT

-- | The terminator for effectful opsets. Note that all effectful opsets
--   are the same, and both can be used with the applicative functions or
--   monad functions in this module. Whereas there is, for example, both
--   <a>makeRecurseA</a> and <a>makeRecurseM</a>, there is only one
--   terminator for the opsets, <a>BaseOpA</a>, which should be used
--   regardless of whether you use <a>makeRecurseA</a> or
--   <a>makeRecurseM</a>.
data BaseOpA (m :: * -> *)
BaseOpA :: BaseOpA

-- | The function to give you an item of type <a>BaseOpA</a>.
baseOpA :: BaseOpA m

-- | The type that extends an opset (opT) in the given
--   monad/applicative-functor (m) to be applied to the given type (t).
--   This is for use with the <a>AlloyA</a> class. A set of operations that
--   operates on <tt>Foo</tt>, <tt>Bar</tt> and <tt>Baz</tt> in the IO
--   monad can be constructed so:
--   
--   <pre>
--   ops :: (Foo :-* Bar :-* Baz :-* BaseOpA) IO
--   ops = doFoo :-* doBar :-* doBaz :-* baseOpA
--   
--   doFoo :: Foo -&gt; IO Foo
--   doBar :: Bar -&gt; IO Bar
--   doBaz :: Baz -&gt; IO Baz
--   </pre>
--   
--   The monad/functor parameter needs to be given when declaring an actual
--   opset, but must be omitted when using the opset as part of a
--   type-class constraint such as:
--   
--   <pre>
--   f :: AlloyA a (Foo :-* Bar :-* Baz :-* BaseOpA) BaseOpA =&gt; a -&gt; IO a
--   f = makeRecurse ops
--   </pre>
data (:-*) t opT m
(:-*) :: (t -> m t) -> (opT m) -> :-* t opT m

-- | A handy synonym for a monadic/applicative opset with only one item, to
--   use with <a>AlloyA</a>.
type OneOpA t = t :-* BaseOpA

-- | A handy synonym for a monadic/applicative opset with only two items,
--   to use with <a>AlloyA</a>.
type TwoOpA s t = s :-* (t :-* BaseOpA)


-- | The module containing the Alloy type-class for working with pure
--   functions (of the type <tt>a -&gt; a</tt>).
module Data.Generics.Alloy.Pure

-- | The Alloy type-class for pure functions, to be used with sets of
--   operations constructed from <a>BaseOp</a> and <a>:-</a>. You are
--   unlikely to need to use <a>transform</a> directly; instead use
--   <a>makeRecurse</a> and <a>makeDescend</a>.
--   
--   The first parameter to the type-class is the type currently being
--   operated on, the second parameter is the set of operations to perform
--   directly on the type, and the third parameter is the set of operations
--   to perform on its children (if none of the second parameter operations
--   can be applied).
class Alloy t o o'
transform :: Alloy t o o' => o -> o' -> t -> t

-- | A type representing a modifier function that applies the given ops
--   (opT) directly to the given type (t).
type Recurse opT = forall t. Alloy t opT BaseOp => t -> t

-- | Given a set of operations, makes a modifier function that applies the
--   operations directly to the given type, and then to its children, until
--   it has been applied to all the largest instances of that type.
makeRecurse :: opT -> Recurse opT

-- | A type representing a modifier function that applies the given ops
--   (opT) to the children of the given type (t).
type Descend opT = forall t. Alloy t BaseOp opT => t -> t

-- | Given a set of operations, makes a descent modifier function that
--   applies the operation to the type's children, and further down, until
--   it has been applied to all the largest instances of that type.
makeDescend :: opT -> Descend opT

-- | The type of the empty set of pure operations.
data BaseOp
BaseOp :: BaseOp

-- | The function giving the empty set of pure operations.
baseOp :: BaseOp

-- | The type that extends an opset (opT) to be applied to the given type
--   (t). This is for use with the <a>Alloy</a> type-class. A set of
--   operations that operates on <tt>Foo</tt>, <tt>Bar</tt> and
--   <tt>Baz</tt> can be constructed so:
--   
--   <pre>
--   ops :: Foo :- Bar :- Baz :- BaseOp
--   ops = doFoo :- doBar :- doBaz :- baseOp
--   
--   doFoo :: Foo -&gt; Foo
--   doBar :: Bar -&gt; Bar
--   doBaz :: Baz -&gt; Baz
--   </pre>
data (:-) t opT
(:-) :: (t -> t) -> opT -> :- t opT

-- | A handy synonym for an opset with only one item, to use with
--   <a>Alloy</a>.
type OneOp t = t :- BaseOp

-- | A handy synonym for an opset with only two items, to use with
--   <a>Alloy</a>.
type TwoOp s t = s :- (t :- BaseOp)


-- | A module of helper functions for use with Alloy. Most of the functions
--   have versions for pure functions (without suffix), applicative
--   functors (A suffix) and monads (M suffix) and sometimes the monadic
--   version again with routes. Generally, only the pure version is
--   documented. The key functions you are likely to need (or their
--   suffixed versions) are <a>applyBottomUp</a> and <a>applyBottomUp2</a>,
--   and <a>listifyDepth</a>.
module Data.Generics.Alloy.Schemes

-- | Given a function that applies to a particular type (<tt>s</tt>),
--   automatically applies that function to every instance of <tt>s</tt> in
--   a larger structure of type <tt>t</tt>, performing the transformations
--   in a bottom-up fashion. It does a depth first traversal in order of a
--   constructor's children, descending first and applying the function
--   afterwards on the way back up.
--   
--   This is equivalent to SYB's everywhere function, as it applies the
--   function everywhere it can throughout the data structure. The function
--   will not be applied to the results of your transformation, so the
--   function cannot end up in infinite loop (unless the value you apply
--   the function to is infinite!).
applyBottomUp :: (Alloy t (OneOp s) BaseOp, Alloy s BaseOp (OneOp s)) => (s -> s) -> t -> t
applyBottomUpA :: (AlloyA t (OneOpA s) BaseOpA, AlloyA s BaseOpA (OneOpA s), Applicative f) => f (s -> s) -> t -> f t
applyBottomUpM :: (AlloyA t (OneOpA s) BaseOpA, AlloyA s BaseOpA (OneOpA s), Monad m) => (s -> m s) -> t -> m t
applyBottomUpMRoute :: (AlloyARoute t (OneOpARoute s) (BaseOpARoute), AlloyARoute s (BaseOpARoute) (OneOpARoute s), Monad m) => ((s, Route s t) -> m s) -> t -> m t

-- | As <a>applyBottomUp</a>, but applies both functions whereever it can
--   in the data structure. It is very important that <tt>sA</tt> is not
--   the same type as <tt>sB</tt> -- odd results will occur if they are the
--   same type. It is perfectly valid for <tt>sA</tt> to contain
--   <tt>sB</tt> or vice versa; in this case, the smaller type will be
--   processed first (as this is a bottom-up traversal) and the larger type
--   processed later on in the ascent (towards the root) of the tree.
applyBottomUp2 :: (Alloy t (TwoOp sA sB) BaseOp, Alloy sA BaseOp (TwoOp sA sB), Alloy sB BaseOp (TwoOp sA sB)) => (sA -> sA) -> (sB -> sB) -> t -> t
applyBottomUpA2 :: (AlloyA t (TwoOpA sA sB) (BaseOpA), AlloyA sA (BaseOpA) (TwoOpA sA sB), AlloyA sB (BaseOpA) (TwoOpA sA sB), Applicative f) => f (sA -> sA) -> f (sB -> sB) -> t -> f t
applyBottomUpM2 :: (AlloyA t (TwoOpA sA sB) (BaseOpA), AlloyA sA (BaseOpA) (TwoOpA sA sB), AlloyA sB (BaseOpA) (TwoOpA sA sB), Monad m) => (sA -> m sA) -> (sB -> m sB) -> t -> m t
applyBottomUpMRoute2 :: (AlloyARoute t (TwoOpARoute sA sB) (BaseOpARoute), AlloyARoute sA (BaseOpARoute) (TwoOpARoute sA sB), AlloyARoute sB (BaseOpARoute) (TwoOpARoute sA sB), Monad m) => ((sA, Route sA t) -> m sA) -> ((sB, Route sB t) -> m sB) -> t -> m t

-- | Given a function that examines a type <tt>s</tt> and gives an answer
--   (True to include the item in the list, False to drop it), finds all
--   items of type <tt>s</tt> in some larger item (of type <tt>t</tt>) that
--   satisfy this function, listed in depth-first order.
listifyDepth :: (AlloyA t (OneOpA s) BaseOpA, AlloyA s BaseOpA (OneOpA s)) => (s -> Bool) -> t -> [s]
listifyDepthRoute :: (AlloyARoute t (OneOpARoute s) (BaseOpARoute), AlloyARoute s (BaseOpARoute) (OneOpARoute s)) => ((s, Route s t) -> Bool) -> t -> [(s, Route s t)]

-- | Given a monadic function that operates on items of type <tt>s</tt>
--   (without modifying them), applies the function to all items of types
--   <tt>s</tt> within an item of type <tt>t</tt>, in depth-first order.
--   
--   This can be used, for example, to perform checks on items in an error
--   monad, or to accumulate information in a state monad, or to print out
--   the structure in a writer or IO monad.
checkDepthM :: (Monad m, AlloyA t (OneOpA s) BaseOpA, AlloyA s BaseOpA (OneOpA s)) => (s -> m ()) -> t -> m ()
checkDepthM2 :: (Monad m, AlloyA t (TwoOpA r s) (BaseOpA), AlloyA r (BaseOpA) (TwoOpA r s), AlloyA s (BaseOpA) (TwoOpA r s)) => (r -> m ()) -> (s -> m ()) -> t -> m ()

-- | Given a set of operations and a modifier function, augments that
--   modifier function to first descend into the value before then applying
--   the modifier function. This can be used to perform a bottom-up
--   depth-first traversal of a structure (see the implementation of
--   <a>applyBottomUp</a>).
--   
--   You are unlikely to need these functions much yourself; either use
--   <a>applyBottomUp</a> and similar to apply a function everywhere, or if
--   you need more fine-grained control over the descent, it is usually
--   better to handle the descent in your own functions.
makeBottomUp :: Alloy t BaseOp opT => opT -> (t -> t) -> t -> t
makeBottomUpA :: (AlloyA t BaseOpA opT, Applicative f) => opT f -> f (t -> t) -> t -> f t
makeBottomUpM :: (AlloyA t BaseOpA opT, Monad m) => opT m -> (t -> m t) -> t -> m t
makeBottomUpMRoute :: (Monad m, AlloyARoute t BaseOpARoute opT) => opT m outer -> ((t, Route t outer) -> m t) -> (t, Route t outer) -> m t


-- | Alloy is a generic programming system for automatically traversing
--   data structures, operating on specific types within that structure.
--   
--   To use the Alloy module, you can either use the helper functions from
--   the <a>Data.Generics.Alloy.Schemes</a> module or the lower-level
--   functions from <a>Data.Generics.Alloy.Pure</a> and
--   <a>Data.Generics.Alloy.Effect</a>. The tutorial
--   (<a>http://twistedsquare.com/Alloy-Tutorial.pdf</a>) provides examples
--   of each of these. The tutorial also explains how to use the
--   <a>Data.Generics.Alloy.GenInstances</a> module to generate the
--   instances that Alloy needs for your data.
module Data.Generics.Alloy
