-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Consistent set of utility functions for Maybe, Either, List and Monoids.
--   
@package data-easy
@version 0.6.1


-- | <tt>easy-data</tt> aims to make <tt><a>Either</a></tt>,
--   <tt><tt>List</tt></tt>, <tt><tt>Tuple</tt></tt>,
--   <tt><a>Monoid</a></tt> and <tt><a>Bool</a></tt> counterparts to the
--   functions originally defined in <a>Data.Maybe</a>, whenever
--   applicable.
--   
--   This module also adds some extra useful functions, that can be found
--   in otherwise disperse packages, pages, mailing lists, etc. A relevant
--   link will be included whenever appropriate, or just a simple note
--   regarding where to find the other implementations. The main goal is to
--   have a consistent set of sensible convertions between types, providing
--   either default values or custom error messages when faced with partial
--   functions (in a mathematical sense).
--   
--   This module is undoubtably neither original, nor providing the 'best'
--   implementations. Its goal is instead to provide a regular and
--   consistent set of functions, easy do memorize and use, for the Haskell
--   beginner.
--   
--   Most functions are one-liners, and you should read their actual code,
--   to either use it as a more idiomatic haskell code, or to develop a
--   better version yourself. Most of these functions are hand-picked from
--   one of the following libraries, that also feature a lot of other
--   goodies, so you should check them out.
--   
--   <tt>safe</tt> : <a>http://hackage.haskell.org/package/safe</a>
--   
--   <tt>either</tt> : <a>http://hackage.haskell.org/package/either</a>
--   
--   <tt>errors</tt> : <a>http://hackage.haskell.org/package/errors</a>
--   
--   
--   <tt>basic-prelude</tt>:<a>http://hackage.haskell.org/package/basic-prelude</a>
--   
--   <tt>missingh</tt> : <a>http://hackage.haskell.org/package/MissingH</a>
--   
--   <tt>utility-ht</tt> :
--   <a>http://hackage.haskell.org/package/utility-ht</a>
--   
--   Note that the <a>Safe</a> module is re-exported by this module. Please
--   notify me if you think I'm missing some other library.
--   
--   For monad related functions, check my other related module,
--   <a>Control.Monad.Trans.Convert</a>, or the modules that inspired it,
--   <tt>either</tt> and <tt>errors</tt>.
--   
--   Some choices have been made, and I am open to discussion whether they
--   are adequate or not. Please contribute and help me make this a (even)
--   more easy and consistent module.
module Data.Easy

-- | Maybe to monoid conversion
maybeToMonoid :: Monoid a => Maybe a -> a

-- | Convert a monoid value into a maybe value (Nothing if mempty).
--   
--   <pre>
--   monoidToMaybe = monoid Nothing Just
--   </pre>
monoidToMaybe :: (Eq a, Monoid a) => a -> Maybe a

-- | Extract the left value or a default.
--   
--   <pre>
--   <a>fromLeft</a> ≡ <a>either</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft "hello" (Right 42)
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft "hello" (Left "world")
--   "world"
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Extract the right value or a default.
--   
--   <pre>
--   <a>fromRight</a> b ≡ <a>either</a> b <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromRight "hello" (Right "world")
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromRight "hello" (Left 42)
--   "hello"
--   </pre>
fromRight :: b -> Either a b -> b

-- | Extracts the element out of a <a>Left</a> and throws an error if its
--   argument take the form <tt><a>Right</a> _</tt>.
--   
--   Using <tt>Control.Lens</tt>:
--   
--   <pre>
--   <a>fromLeft'</a> x ≡ x^?!_Left
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft' (Left 12)
--   12
--   </pre>
fromLeft' :: Either a b -> a

-- | Extracts the element out of a <a>Right</a> and throws an error if its
--   argument take the form <tt><a>Left</a> _</tt>.
--   
--   Using <tt>Control.Lens</tt>:
--   
--   <pre>
--   <a>fromRight'</a> x ≡ x^?!_Right
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromRight' (Right 12)
--   12
--   </pre>
fromRight' :: Either a b -> b

-- | The <a>mapBoth</a> function takes two functions and applies the first
--   if iff the value takes the form <tt><a>Left</a> _</tt> and the second
--   if the value takes the form <tt><a>Right</a> _</tt>.
--   
--   Using <tt>Data.Bifunctor</tt>:
--   
--   <pre>
--   <a>mapBoth</a> = bimap
--   </pre>
--   
--   Using <tt>Control.Arrow</tt>:
--   
--   <pre>
--   <a>mapBoth</a> = (<a>+++</a>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapBoth (*2) (*3) (Left 4)
--   Left 8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapBoth (*2) (*3) (Right 4)
--   Right 12
--   </pre>
mapBoth :: (a -> c) -> (b -> d) -> Either a b -> Either c d

-- | The <a>mapLeft</a> function takes a function and applies it to an
--   Either value iff the value takes the form <tt><a>Left</a> _</tt>.
--   
--   Using <tt>Data.Bifunctor</tt>:
--   
--   <pre>
--   <a>mapLeft</a> = first
--   </pre>
--   
--   Using <tt>Control.Arrow</tt>:
--   
--   <pre>
--   <a>mapLeft</a> = (<a>left</a>)
--   </pre>
--   
--   Using <tt>Control.Lens</tt>:
--   
--   <pre>
--   <a>mapLeft</a> = over _Left
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapLeft (*2) (Left 4)
--   Left 8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapLeft (*2) (Right "hello")
--   Right "hello"
--   </pre>
mapLeft :: (a -> c) -> Either a b -> Either c b

-- | The <a>mapRight</a> function takes a function and applies it to an
--   Either value iff the value takes the form <tt><a>Right</a> _</tt>.
--   
--   Using <tt>Data.Bifunctor</tt>:
--   
--   <pre>
--   <a>mapRight</a> = second
--   </pre>
--   
--   Using <tt>Control.Arrow</tt>:
--   
--   <pre>
--   <a>mapRight</a> = (<a>right</a>)
--   </pre>
--   
--   Using <tt>Control.Lens</tt>:
--   
--   <pre>
--   <a>mapRight</a> = over _Right
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapRight (*2) (Left "hello")
--   Left "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapRight (*2) (Right 4)
--   Right 8
--   </pre>
mapRight :: (b -> c) -> Either a b -> Either a c

-- | The <a>whenLeft</a> function takes an <a>Either</a> value and a
--   function which returns a monad. The monad is only executed when the
--   given argument takes the form <tt><a>Left</a> _</tt>, otherwise it
--   does nothing.
--   
--   Using <tt>Control.Lens</tt>:
--   
--   <pre>
--   <a>whenLeft</a> ≡ forOf_ _Left
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenLeft (Left 12) print
--   12
--   </pre>
whenLeft :: Applicative m => Either a b -> (a -> m ()) -> m ()

-- | The <a>whenRight</a> function takes an <a>Either</a> value and a
--   function which returns a monad. The monad is only executed when the
--   given argument takes the form <tt><a>Right</a> _</tt>, otherwise it
--   does nothing.
--   
--   Using <tt>Data.Foldable</tt>:
--   
--   <pre>
--   <a>whenRight</a> ≡ <tt>forM_</tt>
--   </pre>
--   
--   Using <tt>Control.Lens</tt>:
--   
--   <pre>
--   <a>whenRight</a> ≡ forOf_ _Right
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenRight (Right 12) print
--   12
--   </pre>
whenRight :: Applicative m => Either a b -> (b -> m ()) -> m ()

-- | A synonym of <a>whenRight</a>.
unlessLeft :: Applicative m => Either a b -> (b -> m ()) -> m ()

-- | A synonym of <a>whenLeft</a>.
unlessRight :: Applicative m => Either a b -> (a -> m ()) -> m ()

-- | Maybe get the <a>Left</a> side of an <a>Either</a>.
--   
--   <pre>
--   <a>leftToMaybe</a> ≡ <a>either</a> <a>Just</a> (<a>const</a> <a>Nothing</a>)
--   </pre>
--   
--   Using <tt>Control.Lens</tt>:
--   
--   <pre>
--   <a>leftToMaybe</a> ≡ preview _Left
--   <a>leftToMaybe</a> x ≡ x^?_Left
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; leftToMaybe (Left 12)
--   Just 12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; leftToMaybe (Right 12)
--   Nothing
--   </pre>
leftToMaybe :: Either a b -> Maybe a

-- | Maybe get the <a>Right</a> side of an <a>Either</a>.
--   
--   <pre>
--   <a>rightToMaybe</a> ≡ <a>either</a> (<a>const</a> <a>Nothing</a>) <a>Just</a>
--   </pre>
--   
--   Using <tt>Control.Lens</tt>:
--   
--   <pre>
--   <a>rightToMaybe</a> ≡ preview _Right
--   <a>rightToMaybe</a> x ≡ x^?_Right
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rightToMaybe (Left 12)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rightToMaybe (Right 12)
--   Just 12
--   </pre>
rightToMaybe :: Either a b -> Maybe b

-- | Force a right value, or otherwise fail with provided error message
--   
--   <pre>
--   fromRightNote err = either (error err) id
--   </pre>
fromRightNote :: String -> Either a b -> b

-- | Force a left value, or otherwise fail with provided error message
--   
--   <pre>
--   fromLeftNote err = either id (error err)
--   </pre>
fromLeftNote :: String -> Either a b -> a

-- | Force a right value, providing a default value if the Either is Left
fromEither :: b -> Either a b -> b

-- | Extract the first element of a list as a Right value, or else use the
--   default value provided as a Left value
listToEither :: a -> [b] -> Either a b

-- | Extracts the right value of an either to a singleton list, or an empty
--   list if the Either value is a Left
--   
--   <i>Note</i>: A Left value is lost in the convertion.
eitherToList :: Either a b -> [b]

-- | The <a>catEithers</a> function takes a list of <a>Either</a>s and
--   returns a list of all the <a>Right</a> values.
--   
--   This is just an alias for <a>rights</a>, defined in
--   <tt>Data.Either</tt>
--   
--   <pre>
--   <a>catEithers</a> = <a>rights</a>
--   </pre>
catEithers :: [Either a b] -> [b]

-- | The <a>mapEither</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Either</a> a b</tt>. If this is 'Left a', no
--   element is added on to the result list. If it just <tt><a>Right</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <pre>
--   mapEither f = rights . map f
--   </pre>
mapEither :: (a -> Either b c) -> [a] -> [c]

-- | Convert a Maybe value to an Either value, with the provided default
--   used as Left value if the Maybe value is Nothing
maybeToEither :: a -> Maybe b -> Either a b

-- | Convert an Either value to a Maybe value
--   
--   This function is provided with a different name convention on
--   <tt>Data.Either.Combinators</tt>:
--   
--   <pre>
--   <a>eitherToMaybe</a> = <a>rightToMaybe</a>
--   </pre>
eitherToMaybe :: Either a b -> Maybe b

-- | eitherToMonoid extract the right sided monoid into a single monoid
--   value, or mempty in the case of a left value.
--   
--   <pre>
--   eitherToMonoid = either mempty id
--   </pre>
eitherToMonoid :: Monoid b => Either a b -> b

-- | monoidToEither extracts a non-empty value to the right side, or
--   otherwise fills the <a>Left</a> side with the provided value.
monoidToEither :: (Eq b, Monoid b) => a -> b -> Either a b

-- | Case analysis for a either monoid. If the right side of the monoid is
--   <tt><a>mempty</a></tt>, then the value is transformed to a left value,
--   using the provided function.
joinEitherMonoid :: (Eq b, Monoid b) => a -> Either a b -> Either a b

-- | Apply a function to a non-empty list, and retrieve its result or the
--   default provided value if the list is empty.
list :: b -> ([a] -> b) -> [a] -> b

-- | Alias for <tt><a>not</a></tt>.<tt><a>null</a></tt>
isFilled :: [a] -> Bool

-- | Alias for <a>not</a> . <a>null</a> . Yeah, it saves 3 characters.
--   
--   <pre>
--   notNull = not . null
--   </pre>
notNull :: [a] -> Bool

-- | Alias for null
isNull :: [a] -> Bool

-- | Similar to <tt><a>headNote</a></tt> from <a>Safe</a> package However,
--   no text is added to the provided string error, for more deterministic
--   error messages transparency.
fromHeadNote :: String -> [a] -> a

-- | Returns the first value of a list if not empty, or the provided
--   default value if the list is empty
fromList :: a -> [a] -> a

-- | Alias for <tt><tt>catMonoid</tt></tt>.
catLists :: Eq a => [[a]] -> [[a]]

-- | Alias for concatMap
mapList :: (a -> [b]) -> [a] -> [b]

-- | Insert a single value into a list
--   
--   <pre>
--   singleton = return
--   </pre>
--   
--   or
--   
--   <pre>
--   singleton = (:[])
--   </pre>
singleton :: a -> [a]

-- | map a value over a list of functions, and return a list of values
--   
--   <i>See</i>:
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2007-February/022694.html</a>
--   
--   <pre>
--   <i>Alternative 1</i>: mapV value = map ($ value)
--   </pre>
--   
--   <pre>
--   <i>Alternative 2</i>: mapV value lst = sequence lst value
--   </pre>
mapV :: a -> [a -> b] -> [b]

-- | Sort and nub (remove duplicates) from a list. Specially for large
--   lists, this is much more efficient than <tt>nub . sort</tt>.
--   
--   <i>Note</i>: You shold probably be using <a>Data.Set</a>.
--   
--   <pre>
--   nubSort = Set.toAscList . Set.fromList
--   </pre>
nubSort :: (Eq a, Ord a) => [a] -> [a]

-- | Sort, nub (remove duplicates) and remove initial empty value, if it
--   exists. See <a>nubSort</a>.
nubSort' :: (Eq a, Ord a, Monoid a) => [a] -> [a]

-- | Lazy length: determine if a list has a given size without computing
--   all of its elements.
--   
--   See <a>http://www.haskell.org/haskellwiki/Haskell_programming_tips</a>
atLeast :: Int -> [a] -> Bool

-- | Case evaluation for a tuple pair, <tt>reducing</tt> it to a single
--   value
pair :: Monoid c => (a -> c) -> (b -> c) -> (a, b) -> c

-- | Case evaluation for single type tuple pairs, simplification of
--   <a>pair</a>.
pairS :: Monoid b => (a -> b) -> (a, a) -> b

-- | Is the pair tuple 'valid', i.e., does it have at least one non-empty
--   (monoid) value?
isPairNotEmpty :: (Eq a, Monoid a, Eq b, Monoid b) => (a, b) -> Bool

-- | Is the pair tuple 'invalid', i.e., are both (monoid) elements
--   <a>mempty</a>?
isPairEmpty :: (Eq a, Monoid a, Eq b, Monoid b) => (a, b) -> Bool

-- | Longer (??) alias for <a>fst</a>.
--   
--   <i>Note</i>: included just for 'consistency' with the rest of the API.
--   Use <tt><a>fst</a></tt>.
fromFst :: (a, b) -> a

-- | Longer (??) alias for <a>snd</a>.
fromSnd :: (a, b) -> b

-- | <a>mappend</a> the two monoid elements of a pair
fromPairNote :: (Eq a, Monoid a) => String -> (a, a) -> a

-- | <a>mappend</a> the two monoid elements of a pair
fromPair :: (Eq a, Monoid a) => a -> (a, a) -> a

-- | listToPair grabs the two first elements of a list, and inserts them
--   into a tuple. If not enough elements are available, raise the provided
--   error.
listToPairNote :: String -> [a] -> (a, a)

-- | Groups the elements of a list two by two, also returning the
--   (possible) unpaired item not grouped.
listToPairs :: [a] -> ([(a, a)], [a])

-- | Similar to <a>listToPairs</a>, but discards the (possible) unpaired
--   item.
group2 :: [a] -> [(a, a)]

-- | Convert a single type pair into a two elements list
pairToList :: (a, a) -> [a]

-- | <a>mappend</a> each pair in a list into a single value, and filter out
--   <a>mempty</a> values
catPairs :: (Eq a, Monoid a) => [(a, a)] -> [a]

-- | Applies a pair returning function to each list element, and keeps only
--   the non-empty mappend results (between the pair elements).
mapPair :: (Eq b, Monoid b) => (a -> (b, b)) -> [a] -> [b]

-- | Transform a pair into an either. We adopt the convention that the
--   second value is the one of interest. It is matched against
--   <tt><a>mempty</a></tt>, and if equal the first value is returned as a
--   <tt><a>Left</a></tt> value.
pairToEither :: (Eq b, Monoid b) => (a, b) -> Either a b

-- | Transform a pair into an either. The same as <a>pairToEither</a>, but
--   the first tuple element is considered.
pairToEither' :: (Eq a, Monoid a) => (a, b) -> Either b a

-- | Transform a pair into an either. Both values are checked for a valid
--   monoid (non-empty). The first to be found is returned as a Right
--   value. If none is found, a default value is returned.
pairBothToEither :: (Eq a, Monoid a) => b -> (a, a) -> Either b a

-- | Transform an <tt><a>Either</a></tt> value into a pair. This follows
--   the same convention as <tt><a>pairToEither</a></tt>, and thus
--   transforms a <tt><a>Left</a> value</tt> into a <tt>(<a>Left</a>
--   value,<a>mempty</a>)</tt>, and a <tt><a>Right</a> value</tt> into a
--   <tt>(def, value)</tt>.
eitherToPair :: Monoid b => a -> Either a b -> (a, b)

-- | Transform an <tt><a>Either</a></tt> value into a pair. This follows
--   the same convention as <tt><a>pairToEither'</a></tt>, and thus
--   transforms a <tt><a>Left</a> value</tt> into a <tt>(<a>mempty</a>,
--   <a>Left</a> value)</tt>, and a <tt><a>Right</a> value</tt> into a
--   <tt>(value, def)</tt>.
eitherToPair' :: Monoid a => b -> Either b a -> (a, b)

-- | Transform a pair onto a <tt><a>Maybe</a></tt> This function follows
--   the same convention as <tt><a>pairToEither</a></tt>, and thus the
--   second value is considered the most important one, and as such will
--   take precedence over the first if both are not empty. If you prefer
--   the first value to take precedence, see <tt><a>pairToMaybe'</a></tt>.
--   If both elements of the pair are <tt><a>mempty</a></tt>, this function
--   returns <tt><a>Nothing</a></tt>.
--   
--   <i>Note</i>: the reciprocal of this function is
--   <tt><a>pairToMaybe</a></tt>.
--   
--   <pre>
--   pairToMaybe = monoid (monoid Nothing Just a) Just b
--   </pre>
pairToMaybe :: (Eq a, Monoid a) => (a, a) -> Maybe a

-- | Transform a pair onto a <tt><a>Maybe</a></tt> If both the values are
--   non-empty, the first one is returned wrapped in a Just. If just one
--   value is not-empty, that value is returned, irrespectively if it is
--   the first or second. Otherwise, this function returns Nothing.
--   
--   <i>Note</i>: the reciprocal of this function is
--   <tt><a>pairToMaybe</a></tt>.
--   
--   <pre>
--   pairToMaybe' = monoid (monoid Nothing Just b) Just a
--   </pre>
pairToMaybe' :: (Eq a, Monoid a) => (a, a) -> Maybe a

-- | Transform the first element of a pair (if it is a monoid) into an
--   <tt><a>Maybe</a></tt>. Reciprocal to <tt><a>pairSndToMaybe</a></tt>.
--   
--   <pre>
--   pairToMaybe' = monoitToMaybe . fst
--   </pre>
pairFstToMaybe :: (Eq a, Monoid a) => (a, b) -> Maybe a

-- | Transform the second element of a pair (if it is a monoid) into a
--   <tt><a>Maybe</a></tt>. Reciprocal to <tt><a>pairFstToMaybe</a></tt>.
--   
--   <pre>
--   pairToMaybe = monoitToMaybe . snd
--   </pre>
pairSndToMaybe :: (Eq b, Monoid b) => (a, b) -> Maybe b

-- | Transform a <tt><a>Maybe</a></tt> value into a pair. This follows the
--   same convention as <tt><a>pairToMaybe</a></tt>, and thus transforms a
--   <tt><a>Nothing</a></tt> into a <tt>(def, <a>mempty</a>)</tt>, and a
--   <tt><a>Just</a> value</tt> into a <tt>(def, value)</tt>.
maybeToPair :: Monoid b => a -> Maybe b -> (a, b)

-- | Transform a <tt><a>Maybe</a></tt> value into a pair. This follows the
--   same convention as <tt><a>pairToMaybe'</a></tt>, and thus transforms a
--   <tt><a>Nothing</a></tt> into a <tt>(<a>mempty</a>, def)</tt>, and a
--   <tt><a>Just</a> value</tt> into a <tt>(value,def)</tt>.
maybeToPair' :: Monoid a => b -> Maybe a -> (a, b)

-- | Finds the first non-empty monoid in a pair, and returns it. If none
--   found, returns <tt><a>mempty</a></tt>.
--   
--   <i>Note</i>: reciprocal to <tt><a>pairToMonoid'</a></tt>
pairToMonoid :: (Eq a, Monoid a) => (a, a) -> a

-- | Finds the last non-empty monoid in a pair, and returns it. If none
--   found, returns <tt><a>mempty</a></tt>.
pairToMonoid' :: (Eq a, Monoid a) => (a, a) -> a

-- | Case evaluation for a tuple triple, <tt>reducing</tt> it to a single
--   value
triple :: Monoid d => (a -> d) -> (b -> d) -> (c -> d) -> (a, b, c) -> d

-- | Case evaluation for single type tuple triples, simplification of
--   <a>triple</a>.
tripleS :: Monoid b => (a -> b) -> (a, a, a) -> b

-- | Is the triple tuple 'valid', i.e., does it have at least one non-empty
--   (monoid) value?
isTripleNotEmpty :: (Eq a, Monoid a, Eq b, Monoid b, Eq c, Monoid c) => (a, b, c) -> Bool

-- | Is the pair tuple 'invalid', i.e., are both (monoid) elements
--   <a>mempty</a>?
isTripleEmpty :: (Eq a, Monoid a, Eq b, Monoid b, Eq c, Monoid c) => (a, b, c) -> Bool

-- | Extract the first element from a triple
fromFst' :: (a, b, c) -> a

-- | Alias for fromFst' (extract the first element of a triple).
fst' :: (a, b, c) -> a

-- | Extract the second element from a triple
fromSnd' :: (a, b, c) -> b

-- | Alias for fromSnd' (extract the second element of a triple).
snd' :: (a, b, c) -> b

-- | Extract the third element from a triple
fromTrd' :: (a, b, c) -> c

-- | Alias for <a>fromTrd'</a>
trd' :: (a, b, c) -> c

-- | <a>mappend</a> the two monoid elements of a pair
fromTripleNote :: (Eq a, Monoid a) => String -> (a, a, a) -> a

-- | <a>mappend</a> the three monoid elements of a triple
fromTriple :: (Eq a, Monoid a) => a -> (a, a, a) -> a

-- | listToTriple grabs the two three elements of a list, and inserts them
--   into a triple tuple. If not enough elements are available, raise the
--   provided error.
listToTripleNote :: String -> [a] -> (a, a, a)

-- | Groups the elements of a list three by three, also returning the
--   (possible) remaining item(s) (not grouped).
listToTriples :: [a] -> ([(a, a, a)], [a])

-- | Similar to <a>listToTriples</a>, but discards the (possible) remaining
--   item(s).
group3 :: [a] -> [(a, a, a)]

-- | Convert a single type triple tuple into a three elements list
tripleToList :: (a, a, a) -> [a]

-- | <a>mappend</a> each triple in a list into a single value, and filter
--   out <a>mempty</a> values
catTriples :: (Eq a, Monoid a) => [(a, a, a)] -> [a]

-- | Apply the provided function to each list element resulting in a
--   triple, and keep only the non-empty monoids concat results.
mapTriple :: (Eq b, Monoid b) => (a -> (b, b, b)) -> [a] -> [b]

-- | Pair to Triple, inserting the missing element in first place
--   
--   <pre>
--   toFstPairToTriple x (y,z) = (x,y,z)
--   </pre>
toFstPairToTriple :: a -> (b, c) -> (a, b, c)

-- | Pair to Triple, inserting the missing element in second place
--   
--   <pre>
--   toSndPairToTriple y (x, z) = (x, y, z)
--   </pre>
toSndPairToTriple :: b -> (a, c) -> (a, b, c)

-- | Pair to Triple, inserting the missing element in third place
--   
--   <pre>
--   toTrdPairToTriple z (x, y) = (x, y, z)
--   </pre>
toTrdPairToTriple :: c -> (a, b) -> (a, b, c)

-- | Alias for toTrdPairToTriple
pairToTriple :: c -> (a, b) -> (a, b, c)

-- | Triple to pair, removing the first element.
--   
--   <pre>
--   \(_,y,z) -&gt; (y,z)
--   </pre>
dropFstTripleToPair :: (a, b, c) -> (b, c)

-- | Triple to pair, removing the second element.
--   
--   <pre>
--   \(x,_,z) -&gt; (x,z)
--   </pre>
dropSndTripleToPair :: (a, b, c) -> (a, c)

-- | Triple to pair, removing the third element.
--   
--   <pre>
--   \(x,y,_) -&gt; (x,y)
--   </pre>
dropTrdTripleToPair :: (a, b, c) -> (a, b)

-- | Alias for <a>dropTrdTripleToPair</a>.
tripleToPair :: (a, b, c) -> (a, b)

-- | Triple to Maybe. Analogous to <tt><a>pairToMaybe</a></tt>, it keeps
--   the first non-empty monoid value.
tripleToMaybe :: (Eq a, Monoid a) => (a, a, a) -> Maybe a

-- | Triple to Maybe. Analogous to <tt><a>pairToMaybe'</a></tt>, it keeps
--   the last non-empty monoid value.
tripleToMaybe' :: (Eq a, Monoid a) => (a, a, a) -> Maybe a

-- | Triple to Monoid. Analogous to <tt><a>pairToMonoid</a></tt>, it keeps
--   the first non-empty monoid value.
tripleToMonoid :: (Eq a, Monoid a) => (a, a, a) -> a

-- | Triple to Maybe. Analogous to <tt><a>pairToMonoid'</a></tt>, it keeps
--   the last non-empty monoid value.
tripleToMonoid' :: (Eq a, Monoid a) => (a, a, a) -> a
curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)

-- | Apply a function to a non-empty monoid, and retrieve its result or the
--   default provided value if the monoid is mempty.
monoid :: (Monoid a, Eq a) => b -> (a -> b) -> a -> b

-- | Check that a monoid is not mempty
isNotEmpty :: (Monoid a, Eq a) => a -> Bool

-- | Alias for <tt><a>isNotEmpty</a></tt>.
notEmpty :: (Monoid a, Eq a) => a -> Bool

-- | Check it is mempty
isEmpty :: (Monoid a, Eq a) => a -> Bool

-- | fromNotEmptyNote keeps the monoid value if it is not empty, otherwise
--   it raises an error with the provided message.
--   
--   <i>Note</i>: This differs from <tt>fromJust</tt> in the sense it is
--   not possible to extract values from monoid
fromNotEmptyNote :: (Eq a, Monoid a) => String -> a -> a

-- | fromMonoid keeps the monoid value if it is not empty, otherwise it
--   replaces it with the provided default value
--   
--   <i>Note</i>: No check is made to see if default value is itself mempty
--   
--   <i>Note</i>: This differs from <tt>fromMaybe</tt> in the sense it is
--   not possible to extract values from monoid
--   
--   <i>Note</i>: similar to <tt>flip <a>|</a></tt> for the appropriate
--   types.
fromMonoid :: (Eq a, Monoid a) => a -> a -> a

-- | Infix fromMonoid. Equivalent to higher order ternary operator, similar
--   to python <tt>if</tt> in expressions
--   
--   Example usage:
--   
--   <pre>
--   let x = valueThatCanBeEmpty ?+ defaultValue
--   </pre>
(?+) :: (Eq a, Monoid a) => a -> a -> a

-- | Monoid choice operator. See (obligatory reading, even if you don't
--   understand it at first):
--   <a>http://stackoverflow.com/questions/13080606/confused-by-the-meaning-of-the-alternative-type-class-and-its-relationship-to</a>
--   
--   This operator implements <a>Alternative</a> like choice operator to
--   <a>Monoid</a>s.
(<!>) :: (Eq a, Monoid a) => a -> a -> a

-- | listToMonoid extracts the first element from a monoid list into a
--   single monoid, or returns mempty if the list is empty
--   
--   <i>Note</i>: This differs from <tt>listToMaybe</tt> in the sense it is
--   not possible to promote values into a monoid
--   
--   <pre>
--   listToMonoid = headDef mempty
--   </pre>
listToMonoid :: (Eq a, Monoid a) => [a] -> a

-- | monoidToList convert an empty monoid into an empty list, otherwise it
--   creates a singleton list with the monoid inside
--   
--   <i>Note</i>: This differs from <tt>maybeToList</tt> in the sense it is
--   not possible to extract the value from a monoid
--   
--   <pre>
--   monoidToList = monoid [] singleton
--   </pre>
monoidToList :: (Eq a, Monoid a) => a -> [a]

-- | Filter out all empty monoids from a list.
--   
--   <pre>
--   catMonoids = filter isNotEmpty
--   </pre>
catMonoids :: (Eq a, Monoid a) => [a] -> [a]

-- | Alias for <tt><a>catMonoids</a></tt>.
nonEmpty :: (Eq a, Monoid a) => [a] -> [a]

-- | Apply a function that returns a monoid to all elements of a list and
--   return a new list with only not mempty results.
--   
--   <i>Note</i>: This differs from <tt>mapMaybe</tt> in the sense it is
--   not possible to extract the value from a monoid.
mapMonoid :: (Eq b, Monoid b) => (a -> b) -> [a] -> [b]

-- | Get the first non-empty element from a list. If all elements are
--   <a>mempty</a>, or the list is empty, it returns <a>mempty</a>.
--   <i>Note</i>: A newtype based solution as done by maybe in
--   <a>Data.Monoid</a> will always be more efficient than this, so this is
--   not really recommend. However, it might come handy in some
--   non-critical code.
getFirst' :: (Eq a, Monoid a) => [a] -> a

-- | Get the last non-empty element from a list. If all elements are
--   <a>mempty</a>, or the list is empty, it returns <a>mempty</a>.
--   <i>Note</i>: A newtype based solution as done by maybe in
--   <a>Data.Monoid</a> will always be more efficient than this, so this is
--   not really recommend. However, it might come handy in some
--   non-critical code.
getLast' :: (Eq a, Monoid a) => [a] -> a

-- | A <tt><a>head</a></tt> that fails returning <tt><a>mempty</a></tt>.
--   Gets the first element of a foldable stucture of monoids.
--   
--   Returns <tt><a>mempty</a></tt> if the structure is empty.
headF :: (Foldable t, Monoid a) => t a -> a

-- | A <tt><a>last</a></tt> that fails returning <tt><a>mempty</a></tt>.
--   Gets the last element of a foldable stucture of monoids. Returns
--   <tt><a>mempty</a></tt> if the structure is empty.
--   
--   <i>Note</i>: this function starts by mapping the foldable structure to
--   a list...
lastF :: (Foldable t, Monoid a) => t a -> a

-- | A <tt>'(!!)'</tt> that fails returning <tt><a>mempty</a></tt>.
--   
--   <i>Note</i>: this function starts by mapping the foldable structure to
--   a list...
atF :: (Foldable t, Monoid a) => t a -> Int -> a

-- | Infix version of <tt><a>atF</a></tt>.
(@@) :: (Foldable t, Monoid a) => t a -> Int -> a

-- | fromBool is a 'if' rewrite following the call convention of fromMaybe.
fromBool :: a -> Bool -> a -> a

-- | fromBoolC is similar to <a>fromBool</a>, but it takes a condition
--   rather than a simple boolean value
fromBoolC :: a -> (a -> Bool) -> a -> a

-- | Cat bools. Filter out False values from a list. Probably useless.
--   
--   <pre>
--   catBools = filter id
--   </pre>
catBools :: [Bool] -> [Bool]

-- | Ternary operator. Use like this:
--   
--   <pre>
--   (i &gt; 0) ? i $ 1
--   </pre>
--   
--   <i>Note</i>: this is non-idiomatic haskell. Use at your own risk.
--   
--   <i>Note</i>: this may require additional parenthesis, so it may not be
--   worth it.
(?) :: Bool -> a -> a -> a

-- | Higher order ternary operator. Use like this:
--   
--   <pre>
--   (not . null) ?$ "" $ "default value"
--   </pre>
--   
--   <i>Note</i>: this is non-idiomatic haskell. Use at your own risk.
(?$) :: (a -> Bool) -> a -> a -> a

-- | Higher order ternary operator, similar to python <tt>if</tt> in
--   expressions. Use like this:
--   
--   <pre>
--   "" ?| (not . null) $ "default value"
--   </pre>
--   
--   <i>Note</i>: this is non-idiomatic haskell. Use at your own risk.
(?|) :: a -> (a -> Bool) -> a -> a

-- | Provided a default value, apply it to a maybe if the predicate holds
boolToMaybe :: a -> Bool -> Maybe a

-- | Same as boolToMaybe, but with a more familiar 'if-like' syntax
ifToMaybe :: Bool -> a -> Maybe a

-- | Test a value with a function returning a Bool, and apply it to a Maybe
--   accordingly.
boolCToMaybe :: a -> (a -> Bool) -> Maybe a

-- | Same as boolCToMaybe, but with a more familiar 'if-like' syntax
ifCToMaybe :: (a -> Bool) -> a -> Maybe a

-- | Provided two values, choose amongst them based on a <a>Bool</a> value.
--   
--   <pre>
--   \l r b = if b then Right r else Left l
--   </pre>
boolToEither :: a -> b -> Bool -> Either a b

-- | Provided two values, choose amongst them based on a the provided test
--   on the second value.
--   
--   <pre>
--   \l r f = if f r then Left l else Right r
--   </pre>
boolCToEither :: a -> b -> (b -> Bool) -> Either a b

-- | Insert the provided value into a list if the <a>Bool</a> value is
--   <a>True</a>, otherwise return an empty list.
boolToList :: a -> Bool -> [a]

-- | Insert the provided value into a list if the provided condition is
--   <a>True</a>, otherwise return an empty list.
--   
--   Use a list comprehension instead:
--   
--   <pre>
--   [value | f value]
--   </pre>
boolCToList :: a -> (a -> Bool) -> [a]

-- | Keep the provided value if the <a>Bool</a> value is <a>True</a>,
--   <a>mempty</a> otherwise.
boolToMonoid :: Monoid a => a -> Bool -> a

-- | Keep the provided value if the <a>Bool</a> value is <a>True</a>,
--   <a>mempty</a> otherwise.
boolCToMonoid :: Monoid a => a -> (a -> Bool) -> a

-- | Emulates <tt>and</tt>,<tt>&amp;&amp;</tt> and <tt>or</tt>,<tt>||</tt>
--   from scripting languages like python, in the sense you can mix
--   booleans with a value to get the value when the boolean is true (or
--   <a>mempty</a> otherwise).
--   
--   However, in order to allow several <tt><a>?&amp;&amp;</a></tt> in a
--   row, the order is not the one normally used in languages like bash,
--   where the test comes first.
--   
--   <i>Usage</i>:
--   
--   <pre>
--   value ?&amp;&amp; bool1 ?&amp;&amp; bool2 ?&amp;&amp; ...
--   </pre>
--   
--   <i>Note</i>: this is non-idiomatic haskell. Use at your own risk. You
--   should instead use the following code :
--   
--   <pre>
--   if bool1 &amp;&amp; bool2 &amp;&amp; ...  then value else mempty
--   </pre>
--   
--   Or better yet:
--   
--   <pre>
--   if and [bool1,bool2,...] then value else mempty
--   </pre>
(?&&) :: Monoid a => a -> Bool -> a

-- | Emulates <tt>and</tt>,<tt>&amp;&amp;</tt> and <tt>or</tt>,<tt>||</tt>
--   from scripting languages like python, in the sense you can mix boolean
--   tests with a value to get the original value when all the tests return
--   true (or <a>mempty</a> otherwise).
--   
--   However, in order to allow several <tt><tt>??&amp;&amp;</tt></tt> in a
--   row, the order is not the one normally used in languages like bash,
--   where the test comes first.
--   
--   <i>Note</i>: an easy mnemonic to remember is that operators ending in
--   \ (lambda) imply that their parameters are functions instead of values
--   (in this particular case, boolean tests)
--   
--   <i>Usage</i>:
--   
--   <pre>
--   value ?&amp;&amp;\ condition1 ?&amp;&amp;\ condition2 ?&amp;&amp;\ ...
--   </pre>
--   
--   <i>Note</i>: this is non-idiomatic haskell. Use at your own risk.
(?&&\) :: Monoid a => a -> (a -> Bool) -> a

-- | Apply a list of boolean checks/tests to a variable, and return (True)
--   if <i>all</i> of them passed.
--   
--   <i>Note</i>: See <a>All</a> in <a>Data.Monoid</a> and <a>all</a> in
--   <a>Prelude</a> for reference.
--   
--   <i>See</i>:
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2007-February/022694.html</a>
allCond :: a -> [a -> Bool] -> Bool

-- | Flipped allCond
--   
--   <pre>
--   flip allCond
--   </pre>
allCond' :: [a -> Bool] -> a -> Bool

-- | Apply a list of boolean checks/tests to a variable, and return (True)
--   if <i>any</i> of them passed.
--   
--   <i>Note</i>: See <a>Any</a> in <a>Data.Monoid</a> and <a>any</a> in
--   <a>Prelude</a> for reference.
--   
--   <i>See</i>:
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2007-February/022694.html</a>
anyCond :: a -> [a -> Bool] -> Bool

-- | Flipped anyCond
--   
--   <pre>
--   flip anyCond
--   </pre>
anyCond' :: [a -> Bool] -> a -> Bool
