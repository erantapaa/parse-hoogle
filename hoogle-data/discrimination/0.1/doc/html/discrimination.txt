-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast generic linear-time sorting, joins and container construction.
--   
@package discrimination
@version 0.1

module Data.Discrimination.Internal
runs :: Eq a => [(a, b)] -> [[b]]
groupNum :: [[k]] -> [(k, Int)]
bdiscNat :: Int -> ([v] -> v -> [v]) -> [(Int, v)] -> [[v]]
updateBag :: [Int] -> Int -> [Int]
updateSet :: [Int] -> Int -> [Int]

-- | Optimized and CPS'd version of <a>partitionEithers</a>, where all
--   lefts are known to come before all rights
spanEither :: ([a] -> [b] -> c) -> [Either a b] -> c

module Data.Discrimination.Grouping

-- | Productive Stable Unordered Discriminator
newtype Group a
Group :: (forall m b. PrimMonad m => (b -> m (b -> m ())) -> m (a -> b -> m ())) -> Group a
getGroup :: Group a -> forall m b. PrimMonad m => (b -> m (b -> m ())) -> m (a -> b -> m ())

-- | <a>Eq</a> equipped with a compatible stable unordered discriminator.
class Grouping a where grouping = deciding (Proxy :: Proxy Grouping) grouping
grouping :: Grouping a => Group a
class Grouping1 f where grouping1 = deciding1 (Proxy :: Proxy Grouping) grouping
grouping1 :: Grouping1 f => Group a -> Group (f a)

-- | <i>O(n)</i>. This upgrades <a>nub</a> from <tt>Data.List</tt> from
--   <i>O(n^2)</i> to <i>O(n)</i> by using productive unordered
--   discrimination.
--   
--   <pre>
--   <a>nub</a> = <a>nubWith</a> <a>id</a>
--   <a>nub</a> as = <a>head</a> <a>&lt;$&gt;</a> <a>group</a> as
--   </pre>
nub :: Grouping a => [a] -> [a]

-- | <i>O(n)</i>. Online <a>nub</a> with a Schwartzian transform.
--   
--   <pre>
--   <a>nubWith</a> f as = <a>head</a> <a>&lt;$&gt;</a> <a>groupWith</a> f as
--   </pre>
nubWith :: Grouping b => (a -> b) -> [a] -> [a]

-- | <i>O(n)</i>. Similar to <a>group</a>, except we do not require groups
--   to be clustered.
--   
--   This combinator still operates in linear time, at the expense of
--   storing history.
--   
--   The result equivalence classes are _not_ sorted, but the grouping is
--   stable.
--   
--   <pre>
--   <a>group</a> = <a>groupWith</a> <a>id</a>
--   </pre>
group :: Grouping a => [a] -> [[a]]

-- | <i>O(n)</i>. This is a replacement for <a>groupWith</a> using
--   discrimination.
--   
--   The result equivalence classes are _not_ sorted, but the grouping is
--   stable.
groupWith :: Grouping b => (a -> b) -> [a] -> [[a]]

-- | Valid definition for <tt>(<a>==</a>)</tt> in terms of <a>Grouping</a>.
groupingEq :: Grouping a => a -> a -> Bool
runGroup :: Group a -> [(a, b)] -> [[b]]
groupingNat :: Int -> Group Int
instance Typeable Group
instance Grouping1 Complex
instance (Grouping1 f, Grouping1 g) => Grouping1 (Compose f g)
instance (Grouping a, Grouping b, Grouping c) => Grouping1 ((,,,) a b c)
instance (Grouping a, Grouping b) => Grouping1 ((,,) a b)
instance Grouping a => Grouping1 ((,) a)
instance Grouping a => Grouping1 (Either a)
instance Grouping1 Maybe
instance Grouping1 []
instance (Grouping1 f, Grouping1 g, Grouping a) => Grouping (Compose f g a)
instance (Grouping a, Integral a) => Grouping (Ratio a)
instance Grouping a => Grouping (Complex a)
instance (Grouping a, Grouping b) => Grouping (Either a b)
instance Grouping a => Grouping (Maybe a)
instance Grouping a => Grouping [a]
instance (Grouping a, Grouping b, Grouping c, Grouping d) => Grouping (a, b, c, d)
instance (Grouping a, Grouping b, Grouping c) => Grouping (a, b, c)
instance (Grouping a, Grouping b) => Grouping (a, b)
instance Grouping Bool
instance Grouping Int
instance Grouping Int64
instance Grouping Int32
instance Grouping Int16
instance Grouping Int8
instance Grouping Word
instance Grouping Word64
instance Grouping Word32
instance Grouping Word16
instance Grouping Word8
instance Grouping Void
instance Monoid (Group a)
instance Decidable Group
instance Divisible Group
instance Contravariant Group

module Data.Discrimination.Sorting

-- | Stable Ordered Discriminator
newtype Sort a
Sort :: (forall b. [(a, b)] -> [[b]]) -> Sort a
runSort :: Sort a -> forall b. [(a, b)] -> [[b]]

-- | <a>Ord</a> equipped with a compatible stable, ordered discriminator.
class Grouping a => Sorting a where sorting = deciding (Proxy :: Proxy Sorting) sorting
sorting :: Sorting a => Sort a
class Grouping1 f => Sorting1 f where sorting1 = deciding1 (Proxy :: Proxy Sorting) sorting
sorting1 :: Sorting1 f => Sort a -> Sort (f a)

-- | <i> O(n)</i>. Sort a list using discrimination.
--   
--   <pre>
--   <a>sort</a> = <a>sortWith</a> <a>id</a>
--   </pre>
sort :: Sorting a => [a] -> [a]

-- | <i>O(n)</i>. Sort a list with a Schwartzian transformation by using
--   discrimination.
--   
--   This linear time replacement for <a>sortWith</a> and <a>sortOn</a>
--   uses discrimination.
sortWith :: Sorting b => (a -> b) -> [a] -> [a]
desc :: Sort a -> Sort a

-- | Valid definition for <a>compare</a> in terms of <a>Sorting</a>.
sortingCompare :: Sorting a => a -> a -> Ordering

-- | <i>O(n)</i>. Construct a <a>Map</a>.
--   
--   This is an asymptotically faster version of <a>fromList</a>, which
--   exploits ordered discrimination.
--   
--   <pre>
--   &gt;&gt;&gt; toMap [] == empty
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMap [(5,"a"), (3 :: Int,"b"), (5, "c")]
--   fromList [(5,"c"), (3,"b")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMap [(5,"c"), (3,"b"), (5 :: Int, "a")]
--   fromList [(5,"a"), (3,"b")]
--   </pre>
toMap :: Sorting k => [(k, v)] -> Map k v

-- | <i>O(n)</i>. Construct a <a>Map</a>, combining values.
--   
--   This is an asymptotically faster version of <a>fromListWith</a>, which
--   exploits ordered discrimination.
--   
--   (Note: values combine in anti-stable order for compatibility with
--   <a>fromListWith</a>)
--   
--   <pre>
--   &gt;&gt;&gt; toMapWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5 :: Int,"c")]
--   fromList [(3, "ab"), (5, "cba")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapWith (++) [] == empty
--   True
--   </pre>
toMapWith :: Sorting k => (v -> v -> v) -> [(k, v)] -> Map k v

-- | <i>O(n)</i>. Construct a <a>Map</a>, combining values with access to
--   the key.
--   
--   This is an asymptotically faster version of <a>fromListWithKey</a>,
--   which exploits ordered discrimination.
--   
--   (Note: the values combine in anti-stable order for compatibility with
--   <a>fromListWithKey</a>)
--   
--   <pre>
--   &gt;&gt;&gt; let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   
--   &gt;&gt;&gt; toMapWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5 :: Int,"c")]
--   fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapWithKey f [] == empty
--   True
--   </pre>
toMapWithKey :: Sorting k => (k -> v -> v -> v) -> [(k, v)] -> Map k v

-- | <i>O(n)</i>. Construct an <a>IntMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toIntMap [] == empty
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntMap [(5,"a"), (3,"b"), (5, "c")]
--   fromList [(5,"c"), (3,"b")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntMap [(5,"c"), (3,"b"), (5, "a")]
--   fromList [(5,"a"), (3,"b")]
--   </pre>
toIntMap :: [(Int, v)] -> IntMap v

-- | <i>O(n)</i>. Construct an <a>IntMap</a>, combining values.
--   
--   This is an asymptotically faster version of <a>fromListWith</a>, which
--   exploits ordered discrimination.
--   
--   (Note: values combine in anti-stable order for compatibility with
--   <a>fromListWith</a>)
--   
--   <pre>
--   &gt;&gt;&gt; toIntMapWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")]
--   fromList [(3, "ab"), (5, "cba")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntMapWith (++) [] == empty
--   True
--   </pre>
toIntMapWith :: (v -> v -> v) -> [(Int, v)] -> IntMap v

-- | <i>O(n)</i>. Construct a <a>Map</a>, combining values with access to
--   the key.
--   
--   This is an asymptotically faster version of <a>fromListWithKey</a>,
--   which exploits ordered discrimination.
--   
--   (Note: the values combine in anti-stable order for compatibility with
--   <a>fromListWithKey</a>)
--   
--   <pre>
--   &gt;&gt;&gt; let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   
--   &gt;&gt;&gt; toIntMapWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")]
--   fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntMapWithKey f [] == empty
--   True
--   </pre>
toIntMapWithKey :: (Int -> v -> v -> v) -> [(Int, v)] -> IntMap v

-- | <i>O(n)</i>. Construct a <a>Set</a> in linear time.
--   
--   This is an asymptotically faster version of <a>fromList</a>, which
--   exploits ordered discrimination.
toSet :: Sorting k => [k] -> Set k

-- | <i>O(n)</i>. Construct an <a>IntSet</a> in linear time.
--   
--   This is an asymptotically faster version of <a>fromList</a>, which
--   exploits ordered discrimination.
toIntSet :: [Int] -> IntSet
sortingNat :: Int -> Sort Int

-- | Construct a stable ordered discriminator that sorts a list as
--   multisets of elements from another stable ordered discriminator.
--   
--   The resulting discriminator only cares about the set of keys and their
--   multiplicity, and is sorted as if we'd sorted each key in turn before
--   comparing.
sortingBag :: Foldable f => Sort k -> Sort (f k)

-- | Construct a stable ordered discriminator that sorts a list as sets of
--   elements from another stable ordered discriminator.
--   
--   The resulting discriminator only cares about the set of keys, and is
--   sorted as if we'd sorted each key in turn before comparing.
sortingSet :: Foldable f => Sort k -> Sort (f k)
instance Typeable Sort
instance Sorting a => Sorting1 (Either a)
instance Sorting1 Maybe
instance Sorting1 []
instance (Sorting1 f, Sorting1 g) => Sorting1 (Compose f g)
instance (Sorting1 f, Sorting1 g, Sorting a) => Sorting (Compose f g a)
instance (Sorting a, Sorting b, Sorting c, Sorting d) => Sorting (a, b, c, d)
instance (Sorting a, Sorting b, Sorting c) => Sorting (a, b, c)
instance (Sorting a, Sorting b) => Sorting (a, b)
instance (Sorting a, Sorting b) => Sorting (Either a b)
instance Sorting a => Sorting (Maybe a)
instance Sorting a => Sorting [a]
instance Sorting Bool
instance Sorting Void
instance Sorting Int
instance Sorting Int64
instance Sorting Int32
instance Sorting Int16
instance Sorting Int8
instance Sorting Word
instance Sorting Word64
instance Sorting Word32
instance Sorting Word16
instance Sorting Word8
instance Monoid (Sort a)
instance Decidable Sort
instance Divisible Sort
instance Contravariant Sort

module Data.Discrimination.Class
class Decidable f => Discriminating f
disc :: Discriminating f => f a -> [(a, b)] -> [[b]]

-- | <i>O(n)</i>. Perform a full outer join while explicit merging of the
--   two result tables a table at a time.
--   
--   The results are grouped by the discriminator.
joining :: Discriminating f => f d -> ([a] -> [b] -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [c]

-- | <i>O(n)</i>. Perform an inner join, with operations defined one row at
--   a time.
--   
--   The results are grouped by the discriminator.
--   
--   This takes operation time linear in both the input and result sets.
inner :: Discriminating f => f d -> (a -> b -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [[c]]

-- | <i>O(n)</i>. Perform a full outer join with operations defined one row
--   at a time.
--   
--   The results are grouped by the discriminator.
--   
--   This takes operation time linear in both the input and result sets.
outer :: Discriminating f => f d -> (a -> b -> c) -> (a -> c) -> (b -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [[c]]

-- | <i>O(n)</i>. Perform a left outer join with operations defined one row
--   at a time.
--   
--   The results are grouped by the discriminator.
--   
--   This takes operation time linear in both the input and result sets.
leftOuter :: Discriminating f => f d -> (a -> b -> c) -> (a -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [[c]]

-- | <i>O(n)</i>. Perform a right outer join with operations defined one
--   row at a time.
--   
--   The results are grouped by the discriminator.
--   
--   This takes operation time linear in both the input and result sets.
rightOuter :: Discriminating f => f d -> (a -> b -> c) -> (b -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [[c]]
instance Discriminating Group
instance Discriminating Sort

module Data.Discrimination
class Decidable f => Discriminating f
disc :: Discriminating f => f a -> [(a, b)] -> [[b]]

-- | Productive Stable Unordered Discriminator
newtype Group a
Group :: (forall m b. PrimMonad m => (b -> m (b -> m ())) -> m (a -> b -> m ())) -> Group a
getGroup :: Group a -> forall m b. PrimMonad m => (b -> m (b -> m ())) -> m (a -> b -> m ())

-- | <a>Eq</a> equipped with a compatible stable unordered discriminator.
class Grouping a where grouping = deciding (Proxy :: Proxy Grouping) grouping
grouping :: Grouping a => Group a
class Grouping1 f where grouping1 = deciding1 (Proxy :: Proxy Grouping) grouping
grouping1 :: Grouping1 f => Group a -> Group (f a)

-- | <i>O(n)</i>. This upgrades <a>nub</a> from <tt>Data.List</tt> from
--   <i>O(n^2)</i> to <i>O(n)</i> by using productive unordered
--   discrimination.
--   
--   <pre>
--   <a>nub</a> = <a>nubWith</a> <a>id</a>
--   <a>nub</a> as = <a>head</a> <a>&lt;$&gt;</a> <a>group</a> as
--   </pre>
nub :: Grouping a => [a] -> [a]

-- | <i>O(n)</i>. Online <a>nub</a> with a Schwartzian transform.
--   
--   <pre>
--   <a>nubWith</a> f as = <a>head</a> <a>&lt;$&gt;</a> <a>groupWith</a> f as
--   </pre>
nubWith :: Grouping b => (a -> b) -> [a] -> [a]

-- | <i>O(n)</i>. Similar to <a>group</a>, except we do not require groups
--   to be clustered.
--   
--   This combinator still operates in linear time, at the expense of
--   storing history.
--   
--   The result equivalence classes are _not_ sorted, but the grouping is
--   stable.
--   
--   <pre>
--   <a>group</a> = <a>groupWith</a> <a>id</a>
--   </pre>
group :: Grouping a => [a] -> [[a]]

-- | <i>O(n)</i>. This is a replacement for <a>groupWith</a> using
--   discrimination.
--   
--   The result equivalence classes are _not_ sorted, but the grouping is
--   stable.
groupWith :: Grouping b => (a -> b) -> [a] -> [[a]]
runGroup :: Group a -> [(a, b)] -> [[b]]

-- | Valid definition for <tt>(<a>==</a>)</tt> in terms of <a>Grouping</a>.
groupingEq :: Grouping a => a -> a -> Bool

-- | Stable Ordered Discriminator
newtype Sort a
Sort :: (forall b. [(a, b)] -> [[b]]) -> Sort a
runSort :: Sort a -> forall b. [(a, b)] -> [[b]]

-- | <a>Ord</a> equipped with a compatible stable, ordered discriminator.
class Grouping a => Sorting a where sorting = deciding (Proxy :: Proxy Sorting) sorting
sorting :: Sorting a => Sort a
class Grouping1 f => Sorting1 f where sorting1 = deciding1 (Proxy :: Proxy Sorting) sorting
sorting1 :: Sorting1 f => Sort a -> Sort (f a)
desc :: Sort a -> Sort a

-- | <i> O(n)</i>. Sort a list using discrimination.
--   
--   <pre>
--   <a>sort</a> = <a>sortWith</a> <a>id</a>
--   </pre>
sort :: Sorting a => [a] -> [a]

-- | <i>O(n)</i>. Sort a list with a Schwartzian transformation by using
--   discrimination.
--   
--   This linear time replacement for <a>sortWith</a> and <a>sortOn</a>
--   uses discrimination.
sortWith :: Sorting b => (a -> b) -> [a] -> [a]

-- | Construct a stable ordered discriminator that sorts a list as
--   multisets of elements from another stable ordered discriminator.
--   
--   The resulting discriminator only cares about the set of keys and their
--   multiplicity, and is sorted as if we'd sorted each key in turn before
--   comparing.
sortingBag :: Foldable f => Sort k -> Sort (f k)

-- | Construct a stable ordered discriminator that sorts a list as sets of
--   elements from another stable ordered discriminator.
--   
--   The resulting discriminator only cares about the set of keys, and is
--   sorted as if we'd sorted each key in turn before comparing.
sortingSet :: Foldable f => Sort k -> Sort (f k)

-- | Valid definition for <a>compare</a> in terms of <a>Sorting</a>.
sortingCompare :: Sorting a => a -> a -> Ordering

-- | <i>O(n)</i>. Construct a <a>Map</a>.
--   
--   This is an asymptotically faster version of <a>fromList</a>, which
--   exploits ordered discrimination.
--   
--   <pre>
--   &gt;&gt;&gt; toMap [] == empty
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMap [(5,"a"), (3 :: Int,"b"), (5, "c")]
--   fromList [(5,"c"), (3,"b")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMap [(5,"c"), (3,"b"), (5 :: Int, "a")]
--   fromList [(5,"a"), (3,"b")]
--   </pre>
toMap :: Sorting k => [(k, v)] -> Map k v

-- | <i>O(n)</i>. Construct a <a>Map</a>, combining values.
--   
--   This is an asymptotically faster version of <a>fromListWith</a>, which
--   exploits ordered discrimination.
--   
--   (Note: values combine in anti-stable order for compatibility with
--   <a>fromListWith</a>)
--   
--   <pre>
--   &gt;&gt;&gt; toMapWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5 :: Int,"c")]
--   fromList [(3, "ab"), (5, "cba")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapWith (++) [] == empty
--   True
--   </pre>
toMapWith :: Sorting k => (v -> v -> v) -> [(k, v)] -> Map k v

-- | <i>O(n)</i>. Construct a <a>Map</a>, combining values with access to
--   the key.
--   
--   This is an asymptotically faster version of <a>fromListWithKey</a>,
--   which exploits ordered discrimination.
--   
--   (Note: the values combine in anti-stable order for compatibility with
--   <a>fromListWithKey</a>)
--   
--   <pre>
--   &gt;&gt;&gt; let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   
--   &gt;&gt;&gt; toMapWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5 :: Int,"c")]
--   fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapWithKey f [] == empty
--   True
--   </pre>
toMapWithKey :: Sorting k => (k -> v -> v -> v) -> [(k, v)] -> Map k v

-- | <i>O(n)</i>. Construct an <a>IntMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toIntMap [] == empty
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntMap [(5,"a"), (3,"b"), (5, "c")]
--   fromList [(5,"c"), (3,"b")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntMap [(5,"c"), (3,"b"), (5, "a")]
--   fromList [(5,"a"), (3,"b")]
--   </pre>
toIntMap :: [(Int, v)] -> IntMap v

-- | <i>O(n)</i>. Construct an <a>IntMap</a>, combining values.
--   
--   This is an asymptotically faster version of <a>fromListWith</a>, which
--   exploits ordered discrimination.
--   
--   (Note: values combine in anti-stable order for compatibility with
--   <a>fromListWith</a>)
--   
--   <pre>
--   &gt;&gt;&gt; toIntMapWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")]
--   fromList [(3, "ab"), (5, "cba")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntMapWith (++) [] == empty
--   True
--   </pre>
toIntMapWith :: (v -> v -> v) -> [(Int, v)] -> IntMap v

-- | <i>O(n)</i>. Construct a <a>Map</a>, combining values with access to
--   the key.
--   
--   This is an asymptotically faster version of <a>fromListWithKey</a>,
--   which exploits ordered discrimination.
--   
--   (Note: the values combine in anti-stable order for compatibility with
--   <a>fromListWithKey</a>)
--   
--   <pre>
--   &gt;&gt;&gt; let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   
--   &gt;&gt;&gt; toIntMapWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")]
--   fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntMapWithKey f [] == empty
--   True
--   </pre>
toIntMapWithKey :: (Int -> v -> v -> v) -> [(Int, v)] -> IntMap v

-- | <i>O(n)</i>. Construct a <a>Set</a> in linear time.
--   
--   This is an asymptotically faster version of <a>fromList</a>, which
--   exploits ordered discrimination.
toSet :: Sorting k => [k] -> Set k

-- | <i>O(n)</i>. Construct an <a>IntSet</a> in linear time.
--   
--   This is an asymptotically faster version of <a>fromList</a>, which
--   exploits ordered discrimination.
toIntSet :: [Int] -> IntSet

-- | <i>O(n)</i>. Perform a full outer join while explicit merging of the
--   two result tables a table at a time.
--   
--   The results are grouped by the discriminator.
joining :: Discriminating f => f d -> ([a] -> [b] -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [c]

-- | <i>O(n)</i>. Perform an inner join, with operations defined one row at
--   a time.
--   
--   The results are grouped by the discriminator.
--   
--   This takes operation time linear in both the input and result sets.
inner :: Discriminating f => f d -> (a -> b -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [[c]]

-- | <i>O(n)</i>. Perform a full outer join with operations defined one row
--   at a time.
--   
--   The results are grouped by the discriminator.
--   
--   This takes operation time linear in both the input and result sets.
outer :: Discriminating f => f d -> (a -> b -> c) -> (a -> c) -> (b -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [[c]]

-- | <i>O(n)</i>. Perform a left outer join with operations defined one row
--   at a time.
--   
--   The results are grouped by the discriminator.
--   
--   This takes operation time linear in both the input and result sets.
leftOuter :: Discriminating f => f d -> (a -> b -> c) -> (a -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [[c]]

-- | <i>O(n)</i>. Perform a right outer join with operations defined one
--   row at a time.
--   
--   The results are grouped by the discriminator.
--   
--   This takes operation time linear in both the input and result sets.
rightOuter :: Discriminating f => f d -> (a -> b -> c) -> (b -> c) -> (a -> d) -> (b -> d) -> [a] -> [b] -> [[c]]
