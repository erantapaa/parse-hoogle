-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments
--   
@package tagged-transformer
@version 0.8


module Data.Functor.Trans.Tagged

-- | A Tagged monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - the phantom type</li>
--   <li><tt>m</tt> - the inner monad</li>
--   <li><tt>b</tt> - the tagged value</li>
--   </ul>
--   
--   | A <tt><a>TaggedT</a> s m b</tt> value is a monadic value <tt>m
--   b</tt> with an attached phantom type <tt>s</tt>. This can be used in
--   place of the more traditional but less safe idiom of passing in an
--   undefined value with the type, because unlike an <tt>(s -&gt; m
--   b)</tt>, a <tt><a>TaggedT</a> s m b</tt> can't try to use the argument
--   <tt>s</tt> as a real value.
--   
--   Moreover, you don't have to rely on the compiler to inline away the
--   extra argument, because the newtype is "free"
newtype TaggedT s m b
TagT :: m b -> TaggedT s m b
untagT :: TaggedT s m b -> m b

-- | A <tt><a>Tagged</a> s b</tt> value is a value <tt>b</tt> with an
--   attached phantom type <tt>s</tt>. This can be used in place of the
--   more traditional but less safe idiom of passing in an undefined value
--   with the type, because unlike an <tt>(s -&gt; b)</tt>, a
--   <tt><a>Tagged</a> s b</tt> can't try to use the argument <tt>s</tt> as
--   a real value.
--   
--   Moreover, you don't have to rely on the compiler to inline away the
--   extra argument, because the newtype is "free"
type Tagged s b = TaggedT s Identity b

-- | Tag a value in Identity monad
tag :: b -> Tagged s b

-- | Easier to type alias for <a>TagT</a>
tagT :: m b -> TaggedT s m b

-- | Untag a value in Identity monad
untag :: Tagged s b -> b

-- | Some times you need to change the tag you have lying around. Idiomatic
--   usage is to make a new combinator for the relationship between the
--   tags that you want to enforce, and define that combinator using
--   <a>retag</a>.
--   
--   <pre>
--   data Succ n
--   retagSucc :: Tagged n a -&gt; Tagged (Succ n) a
--   retagSucc = retag
--   </pre>
retag :: TaggedT s m b -> TaggedT t m b

-- | Lift an operation on underlying monad
mapTaggedT :: (m a -> n b) -> TaggedT s m a -> TaggedT s n b

-- | Reflect reified value back in <a>Applicative</a> context
reflected :: (Applicative m, Reifies s a) => TaggedT s m a

-- | Reflect reified value back in <a>Monad</a> context
reflectedM :: (Monad m, Reifies s a) => TaggedT s m a

-- | <a>asTaggedTypeOf</a> is a type-restricted version of <a>const</a>. It
--   is usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   tag of the second.
asTaggedTypeOf :: s -> TaggedT s m b -> s

-- | Convert from a <a>Tagged</a> representation to a representation based
--   on a <a>Proxy</a>.
proxy :: Tagged s b -> Proxy s -> b

-- | Convert from a <a>TaggedT</a> representation to a representation based
--   on a <a>Proxy</a>.
proxyT :: TaggedT s m b -> Proxy s -> m b

-- | Convert from a representation based on a <a>Proxy</a> to a
--   <a>Tagged</a> representation.
unproxy :: (Proxy s -> a) -> Tagged s a

-- | Convert from a representation based on a <a>Proxy</a> to a
--   <a>TaggedT</a> representation.
unproxyT :: (Proxy s -> m a) -> TaggedT s m a

-- | Tag a value with its own type.
tagSelf :: a -> Tagged a a

-- | Tag a value with its own type.
tagTSelf :: m a -> TaggedT a m a

-- | <a>untagSelf</a> is a type-restricted version of <a>untag</a>.
untagSelf :: Tagged a a -> a

-- | <a>untagSelf</a> is a type-restricted version of <a>untag</a>.
untagTSelf :: TaggedT a m a -> m a

-- | Another way to convert a proxy to a tag.
tagWith :: proxy s -> a -> Tagged s a

-- | Another way to convert a proxy to a tag.
tagTWith :: proxy s -> m a -> TaggedT s m a
witness :: Tagged a b -> a -> b
witnessT :: TaggedT a m b -> a -> m b
instance Typeable TaggedT
instance Eq (m b) => Eq (TaggedT s m b)
instance Ord (m b) => Ord (TaggedT s m b)
instance Read (m b) => Read (TaggedT s m b)
instance Show (m b) => Show (TaggedT s m b)
instance MonadMask m => MonadMask (TaggedT s m)
instance MonadCatch m => MonadCatch (TaggedT s m)
instance MonadThrow m => MonadThrow (TaggedT s m)
instance ComonadHoist (TaggedT s)
instance ComonadTrans (TaggedT s)
instance Comonad w => Comonad (TaggedT s w)
instance Extend f => Extend (TaggedT s f)
instance Distributive f => Distributive (TaggedT s f)
instance Traversable f => Traversable (TaggedT s f)
instance Foldable f => Foldable (TaggedT s f)
instance MonadCont m => MonadCont (TaggedT s m)
instance MonadState t m => MonadState t (TaggedT s m)
instance MonadReader r m => MonadReader r (TaggedT s m)
instance MonadWriter w m => MonadWriter w (TaggedT s m)
instance MonadIO m => MonadIO (TaggedT s m)
instance MonadTrans (TaggedT s)
instance MonadFix m => MonadFix (TaggedT s m)
instance MonadPlus m => MonadPlus (TaggedT s m)
instance Plus m => Plus (TaggedT s m)
instance Alternative m => Alternative (TaggedT s m)
instance Alt m => Alt (TaggedT s m)
instance Monad m => Monad (TaggedT s m)
instance Bind m => Bind (TaggedT s m)
instance Applicative m => Applicative (TaggedT s m)
instance Apply m => Apply (TaggedT s m)
instance Contravariant m => Contravariant (TaggedT s m)
instance Functor m => Functor (TaggedT s m)
