-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient ordered (by popcount) enumeration of bits
--   
@package OrderedBits
@version 0.0.0.2


-- | Efficiently enumerate the bits in data types in order of population
--   count. This yields, say, <tt>000, 001, 010, 100, 011, 101, 110,
--   111</tt> (or <tt>0, 1, 2, 4, 3, 5, 6, 7</tt>). Another view is of
--   looking at the bits as a bitset, first enumerating the empty set, then
--   all 1-element sets, all 2-element sets, up to the set size.
--   
--   The enumerator can be inlined with <tt>unfoldr</tt> (of the
--   <tt>vector</tt> package) and is a good producer.
--   
--   A memo-table is available, since <tt>popCntSorted</tt> is still
--   waiting for an efficient <tt>popCntEnumerated</tt> that does not
--   require sorting.
module Data.Bits.Ordered

-- | Get the lowest active bit. Returns <tt>-1</tt> if no bit is set.
lsbZ :: Ranked t => t -> Int

-- | Given the currently active bit <tt>k</tt> and the set <tt>t</tt>, get
--   the next active bit. Return <tt>-1</tt> if there is no next active
--   bit.
nextActiveZ :: Ranked t => Int -> t -> Int

-- | Return next active bit, using <tt>Maybe</tt>.
maybeNextActive :: Ranked t => Int -> t -> Maybe Int

-- | <tt>Maybe</tt> the lowest active bit.
maybeLsb :: Ranked t => t -> Maybe Int

-- | Enumerate all sets with the same population count. Given a population
--   <tt>i</tt>, this returns <tt>Just j</tt> with <tt>j&gt;i</tt> (but
--   same number of set bits) or <tt>Nothing</tt>. For a population count
--   of <tt>k</tt>, start with <tt>2^(k+1) -1</tt>.
--   
--   Note that <tt>sort permutations == sort (nub permutations)</tt> if
--   <tt>permutations</tt> is a set of all permutations for a given
--   <tt>popCount</tt> generated by <tt>popPermutation</tt>. The
--   <tt>Data.List.permutations</tt> functions will create duplicates.
--   
--   cf
--   <a>http://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations</a>
popPermutation :: Ranked t => Int -> t -> Maybe t

-- | Given a population, get the complement. The first argument is the size
--   of the population (say. 8 for 8 bits); the second the current
--   population.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; popComplement 5 (3 :: Int)
--   28
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; popComplement 6 (3 :: Int)
--   60
--   </pre>
popComplement :: Ranked t => Int -> t -> t

-- | The <i>slow</i> default implementation. We sort the vector, not the
--   list, as sorting will walk the whole data structure anyway, and the
--   vector requires not as much memory.
--   
--   Replaced <tt>popCount &amp;&amp;&amp; id</tt> as sort, which provides
--   for <tt>a&lt;b</tt> on equal <tt>popCount</tt> with <tt>popCount
--   &amp;&amp;&amp; activeBitsL</tt> which sorts according to a list of
--   increasing bit indices. Mostly to stay in sync with the <tt>pred</tt>
--   / <tt>succ</tt> functions below.
popCntSorted :: (Unbox n, Integral n, Bits n, Ranked n) => Int -> Vector n

-- | Memoized version of <a>popCntSorted</a> for <tt>Int</tt>s.
--   
--   NOTE Since this uses <tt>popCntSorted</tt> for now it will still
--   require a lot of memory for sorting the vector!
popCntMemoInt :: Int -> Vector Int

-- | Memoized version of <a>popCntSorted</a> for <tt>Word</tt>s.
--   
--   NOTE Since this uses <tt>popCntSorted</tt> for now it will still
--   require a lot of memory for sorting the vector!
popCntMemoWord :: Int -> Vector Word

-- | Move a population more to the left. This, effectively, introduces
--   <tt>0</tt>s in the set, whereever the <tt>mask</tt> has a <tt>0</tt>.
--   Only as many <tt>1</tt>s can be set, as the mask holds. Assume that
--   you have a bitmask <tt>mask = 10101</tt> and a least-significant
--   aligned population <tt>11</tt>, then given mask and population you'd
--   like to see <tt>00101</tt>, i.e. the two lowest one bits of the mask
--   are set. <tt>101</tt> would set the lowest and third one bit.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; popShiftL (21::Int) 3 -- 10101 00011  -- 00101
--   5
--   
--   &gt;&gt;&gt; popShiftL (28::Int) 0 -- 11100 00000  -- 00000
--   0
--   
--   &gt;&gt;&gt; popShiftL (28::Int) 1 -- 11100 00001  -- 00100
--   4
--   
--   &gt;&gt;&gt; popShiftL (28::Int) 2 -- 11100 00010  -- 01000
--   8
--   
--   &gt;&gt;&gt; popShiftL (28::Int) 3 -- 11100 00011  -- 01100
--   12
--   </pre>
popShiftL :: Ranked t => t -> t -> t

-- | Effectively compresses a bitset, given a mask. Removes set elements,
--   whenever the mask is <tt>0</tt>, by moving all remaining elements one
--   to the right.
popShiftR :: Ranked t => t -> t -> t

-- | List of all active bits, from lowest to highest.
activeBitsL :: Ranked t => t -> [Int]

-- | A stream with the currently active bits, lowest to highest.
activeBitsS :: (Ranked t, Monad m) => t -> Stream m Int

-- | A generic vector (specializes to the corrept type) of the active bits,
--   lowest to highest.
activeBitsV :: (Ranked t, Vector v Int) => t -> v Int
instance Ranked Word
instance Ranked Int


-- | Check a number of properties for popcount-ordered elements.
--   
--   $setup
--   
--   <pre>
--   &gt;&gt;&gt; :set -XScopedTypeVariables
--   </pre>
module Data.Bits.Ordered.QuickCheck

-- | Check if both the memoized version and the population enumeration
--   produce the same multisets, but maybe in different order.
--   
--   <pre>
--   \(n :: Int16) -&gt; let b = popCount n in memoSorted b == enumSorted b
--   </pre>
prop_PopCountSet :: NonZero Int16 -> Bool
memoSorted :: Int -> [[Int]]
enumSorted :: Int -> [[Int]]
prop_lsb_Int :: Int -> Bool
prop_lsb_Word :: Word -> Bool
prop_OneBits_Int :: Int -> Bool
prop_allPermutations :: (Int, Int) -> Bool
prop_popShiftL_popShiftR :: (Word, Word) -> Bool
