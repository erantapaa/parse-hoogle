-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Log-domain arithmetic
--   
@package log-domain
@version 0.10.1.1


module Numeric.Log

-- | <tt>Log</tt>-domain <tt>Float</tt> and <tt>Double</tt> values.
newtype Log a
Exp :: a -> Log a
ln :: Log a -> a

-- | This provides <tt>log1p</tt> and <tt>expm1</tt> for working more
--   accurately with small numbers.
class Floating a => Precise a where log1pexp a = log1p (exp a) log1mexp a = log1p (negate (exp a))
log1p :: Precise a => a -> a
expm1 :: Precise a => a -> a
log1pexp :: Precise a => a -> a
log1mexp :: Precise a => a -> a

-- | Efficiently and accurately compute the sum of a set of log-domain
--   numbers
--   
--   While folding with <tt>(+)</tt> accomplishes the same end, it requires
--   an additional <tt>n-2</tt> logarithms to sum <tt>n</tt> terms. In
--   addition, here we introduce fewer opportunities for round-off error.
--   
--   While for small quantities the naive sum accumulates error,
--   
--   <pre>
--   &gt;&gt;&gt; let xs = Prelude.replicate 40000 (Exp 1e-4) :: [Log Float]
--   
--   &gt;&gt;&gt; Prelude.sum xs ~= 4.00e4
--   True
--   </pre>
--   
--   This sum gives a more accurate result,
--   
--   <pre>
--   &gt;&gt;&gt; Numeric.Log.sum xs ~= 4.00e4
--   True
--   </pre>
--   
--   <i>NB:</i> This does require two passes over the data.
sum :: (RealFloat a, Ord a, Precise a, Foldable f) => f (Log a) -> Log a
instance (RealFloat a, Precise a) => Precise (Complex a)
instance Precise Float
instance Precise Double
instance (RealFloat a, Precise a) => Floating (Log a)
instance (Precise a, RealFloat a) => Monoid (Log a)
instance (Precise a, RealFloat a, Ord a) => Real (Log a)
instance (RealFloat a, Unbox a) => Vector Vector (Log a)
instance (RealFloat a, Unbox a) => MVector MVector (Log a)
instance (RealFloat a, Unbox a) => Unbox (Log a)
instance (Precise a, RealFloat a) => RealFrac (Log a)
instance (Precise a, RealFloat a, Eq a) => Fractional (Log a)
instance (Precise a, RealFloat a) => Num (Log a)
instance (RealFloat a, Precise a, Enum a) => Enum (Log a)
instance Monad Log
instance Bind Log
instance Apply Log
instance ComonadApply Log
instance Applicative Log
instance Comonad Log
instance Extend Log
instance Distributive Log
instance Traversable1 Log
instance Traversable Log
instance Foldable1 Log
instance Foldable Log
instance NFData a => NFData (Log a)
instance Storable a => Storable (Log a)
instance Hashable1 Log
instance Hashable a => Hashable (Log a)
instance Functor Log
instance Serial1 Log
instance Serial a => Serial (Log a)
instance Serialize a => Serialize (Log a)
instance Binary a => Binary (Log a)
instance (Floating a, Read a) => Read (Log a)
instance (Floating a, Show a) => Show (Log a)
instance SafeCopy a0 => SafeCopy (Log a0)
instance Typeable Log
instance Eq a => Eq (Log a)
instance Ord a => Ord (Log a)
instance Data a => Data (Log a)
instance Generic (Log a)
instance Datatype D1Log
instance Constructor C1_0Log
instance Selector S1_0_0Log


module Numeric.Log.Signed

-- | <tt>Log</tt>-domain <tt>Float</tt> and <tt>Double</tt> values, with a
--   sign bit.
data SignedLog a
SLExp :: Bool -> a -> SignedLog a
signSL :: SignedLog a -> Bool
lnSL :: SignedLog a -> a
instance Typeable SignedLog
instance Data a => Data (SignedLog a)
instance Generic (SignedLog a)
instance Datatype D1SignedLog
instance Constructor C1_0SignedLog
instance Selector S1_0_0SignedLog
instance Selector S1_0_1SignedLog
instance (Precise a, RealFloat a) => RealFrac (SignedLog a)
instance (RealFloat a, Precise a) => Floating (SignedLog a)
instance (Precise a, RealFloat a, Ord a) => Real (SignedLog a)
instance (Precise a, RealFloat a) => Fractional (SignedLog a)
instance (Precise a, RealFloat a) => Num (SignedLog a)
instance (Precise a, RealFloat a, Fractional a, Read a) => Read (SignedLog a)
instance (Show a, RealFloat a, Eq a, Fractional a) => Show (SignedLog a)
instance (Ord a, Fractional a) => Ord (SignedLog a)
instance (Eq a, Fractional a) => Eq (SignedLog a)
