-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | XML parser which uses simple-pipe
--   
--   This package process subset of XML and is still far from perfect, now.
--   
--   Example programs
--   
--   examples/indians.hs
--   
--   extensions
--   
--   <ul>
--   <li>OverloadedStrings</li>
--   <li>PackageImports</li>
--   </ul>
--   
--   <pre>
--   import Control.Monad
--   import "monads-tf" Control.Monad.Trans
--   import Data.Maybe
--   import Data.Pipe
--   import Data.Pipe.List
--   import Text.XML.Pipe
--   
--   import qualified Data.ByteString.Char8 as BSC
--   
--   littleIndians :: Int -&gt; BSC.ByteString
--   littleIndians n = "&lt;indians&gt;" `BSC.append`
--   	BSC.pack (show n) `BSC.append` " little, " `BSC.append`
--   	BSC.pack (show $ n + 1) `BSC.append` " little, " `BSC.append`
--   	BSC.pack (show $ n + 2) `BSC.append` " little Indians" `BSC.append`
--   	"&lt;/indians&gt;"
--   
--   infiniteIndians :: [BSC.ByteString]
--   infiniteIndians = map littleIndians [1, 4 .. ]
--   
--   xml :: [BSC.ByteString]
--   xml = "&lt;?xml version='1.0'?&gt;&lt;song&gt;" : infiniteIndians
--   
--   main :: IO ()
--   main = void . runPipe $ fromList xml
--   	=$= xmlEvent
--   	=$= convert fromJust
--   	=$= (xmlBegin &gt;&gt;= xmlNode)
--   	=$= takeP 8
--   	=$= printP
--   
--   takeP :: Monad m =&gt; Int -&gt; Pipe a a m ()
--   takeP 0 = return ()
--   takeP n = do
--   	mx &lt;- await
--   	maybe (return ()) (\x -&gt; yield x &gt;&gt; takeP (n - 1)) mx
--   
--   convert :: Monad m =&gt; (a -&gt; b) -&gt; Pipe a b m ()
--   convert f = do
--   	mx &lt;- await
--   	maybe (return ()) (\x -&gt; yield (f x) &gt;&gt; convert f) mx
--   
--   printP :: Show a =&gt; Pipe a () IO ()
--   printP = do
--   	mx &lt;- await
--   	maybe (return ()) (\x -&gt; lift (print x) &gt;&gt; printP) mx
--   </pre>
--   
--   examples/starttls.hs
--   
--   It process STARTTLS of XMPP as client. The fllowings are only main
--   part.
--   
--   <pre>
--   main :: IO ()
--   main = do
--   	h &lt;- connectTo "localhost" (PortNumber 5222)
--   	BS.hPut h $ xmlString begin
--   	BS.hPut h $ xmlString startTls
--   	void . runPipe $ handleP h
--   		=$= xmlEvent
--   		=$= convert fromJust
--   		=$= (xmlBegin &gt;&gt;= xmlNodeUntil isProceed)
--   		=$= printP
--   	ca &lt;- readCertificateStore ["cacert.sample_pem"]
--   	g &lt;- cprgCreate &lt;$&gt; createEntropyPool :: IO SystemRNG
--   	(`run` g) $ do
--   		p &lt;- open' h "localhost" ["TLS_RSA_WITH_AES_128_CBC_SHA"] [] ca
--   		hlPut p $ xmlString begin
--   		void . runPipe $ handleP p
--   			=$= xmlEvent
--   			=$= convert fromJust
--   			=$= (xmlBegin &gt;&gt;= xmlNode)
--   			=$= printP
--   </pre>
@package xml-pipe
@version 0.0.0.11

module Text.XML.Pipe
xmlEvent :: Monad m => Pipe ByteString (Maybe XmlEvent) m ()
xmlBegin :: Monad m => Pipe XmlEvent XmlNode m [Xmlns]
xmlNode :: Monad m => [Xmlns] -> Pipe XmlEvent XmlNode m Bool
xmlReborn :: Monad m => Pipe XmlEvent XmlNode m ()
xmlNodeUntil :: Monad m => (XmlNode -> Bool) -> [Xmlns] -> Pipe XmlEvent XmlNode m ()
xmlString :: [XmlNode] -> ByteString
data XmlEvent
XEXmlDecl :: (Int, Int) -> XmlEvent
XESTag :: XEQName -> [Xmlns] -> [(XEQName, ByteString)] -> XmlEvent
XEETag :: XEQName -> XmlEvent
XEEmptyElemTag :: XEQName -> [Xmlns] -> [(XEQName, ByteString)] -> XmlEvent
XECharData :: ByteString -> XmlEvent
data XmlNode
XmlDecl :: (Int, Int) -> XmlNode
XmlStart :: QName -> [Xmlns] -> [(QName, ByteString)] -> XmlNode
XmlCharData :: ByteString -> XmlNode
XmlNode :: QName -> [Xmlns] -> [(QName, ByteString)] -> [XmlNode] -> XmlNode
XmlEnd :: QName -> XmlNode
type XEQName = (ByteString, ByteString)
type Xmlns = (ByteString, ByteString)
type QName = ((ByteString, Maybe ByteString), ByteString)
nullQ :: ByteString -> QName
