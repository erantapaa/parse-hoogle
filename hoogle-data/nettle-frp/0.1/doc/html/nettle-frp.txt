-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FRP for controlling networks of OpenFlow switches.
--   
--   This module provides an FRP-based framework for controlling OpenFlow
--   switches. The library is under active development and should still be
--   considered experimental.
@package nettle-frp
@version 0.1


-- | Module defining an abstract data type describing the connectivity
--   among a collection of OpenFlow switches.
module Nettle.Discovery.Topology

-- | Port definition that references a specific port on a specific switch
type Port = (SwitchID, PortID)

-- | A set of two Ports (as defined above) that represents a connection
--   from the PortID of a switch with a certain DataPathID to the PortID of
--   another switch with a different DataPathID
type Link = Set Port

-- | Definition of Topology, that is, a set of two-member sets of ports
--   It's constructors are not made available in other modules; Topologies
--   can only be manipulated by the functions defined in this module. This
--   is done so that certain properties can be assumed of any Topology,
--   namely that all Links contain two members
type Topology = Set Link

-- | Deconstructor for Topology constructor
unTopology :: Topology -> Set Link

-- | Merge two topologies
merge :: Topology -> Topology -> Topology

-- | Provides a Topology with no links
empty :: Topology

-- | Construct a link
link :: (Port, Port) -> Link

-- | Add a link into an existing topology. Use with empty to make a new
--   Topology.
addLink :: Port -> Port -> Topology -> Topology

-- | Removes all links that include a certain switch's DataPathID from the
--   Topology.
removeSwitch :: SwitchID -> Topology -> Topology

-- | Given two topologies, merge them into one
combine :: Topology -> Topology -> Topology
removeLink :: Link -> Topology -> Topology
removePort :: Port -> Topology -> Topology

-- | Find the subset of Links in a Topology that all include a certain
--   switch's DataPathID
subset :: SwitchID -> Topology -> Topology
containsDataPathID :: SwitchID -> Link -> Bool
containsPort :: Port -> Link -> Bool

module Nettle.FRPControl.PacketPredicate

-- | Type class for pairs of types where one type is a set of
--   <a>structures</a>, and the other is a set of predicates over these
--   structures, and for which there exists a relations of satisfaction.
class Logic m p
holds :: (Logic m p) => m -> p -> Bool

-- | A synonym for holds
(|-) :: (Logic m p) => m -> p -> Bool

-- | Packet Predicates Note that values of this data type should NOT be
--   constructed using the constructors of this data type, but rather
--   through the functions defined below. The functions below maintain this
--   data type's invariants, whereas these constructors do not.
data PacketPredicate
AndPP :: PacketPredicate -> PacketPredicate -> PacketPredicate
OrPP :: PacketPredicate -> PacketPredicate -> PacketPredicate
TruePP :: PacketPredicate
FalsePP :: PacketPredicate
InPortIs :: PortID -> PacketPredicate
MacSourceIs :: EthernetAddress -> PacketPredicate
MacDestIs :: EthernetAddress -> PacketPredicate
VLANIDIs :: VLANID -> PacketPredicate
VLANPriority :: VLANPriority -> PacketPredicate
MacFrameTypeIs :: EthernetTypeCode -> PacketPredicate
IPTypeOfService :: IPTypeOfService -> PacketPredicate
IPProtocolIs :: IPProtocol -> PacketPredicate
IPSourceIn :: IPAddressPrefix -> PacketPredicate
IPDestIn :: IPAddressPrefix -> PacketPredicate
SenderTransportPortIs :: Word16 -> PacketPredicate
ReceiverTransportPortIs :: Word16 -> PacketPredicate

-- | A clause is a list of literals. A packet satisfies a clause if it
--   satisfies all the literals in the clause. From this, it follows that
--   any packet satisfies an empty clause; i.e. the empty clause is
--   equivalent to True.
type Clause = [Literal]

-- | A literal is any packet predicate except those formed using
--   conjunction or disjunction. The type synonym does not enforce this
--   constraint - we just use it as a reminder of the intent.
type Literal = PacketPredicate
(<&>) :: PacketPredicate -> PacketPredicate -> PacketPredicate
(<|>) :: PacketPredicate -> PacketPredicate -> PacketPredicate
anyPacket :: PacketPredicate
inPortIs :: PortID -> PacketPredicate
ethSourceIs :: EthernetAddress -> PacketPredicate
ethDestIs :: EthernetAddress -> PacketPredicate
vLANIDIs :: VLANID -> PacketPredicate
vlanPriority :: VLANPriority -> PacketPredicate
ethFrameTypeIs :: EthernetTypeCode -> PacketPredicate
ipTypeOfService :: IPTypeOfService -> PacketPredicate
transportProtocolIs :: IPProtocol -> PacketPredicate
ipSourceIn :: IPAddressPrefix -> PacketPredicate
ipDestIn :: IPAddressPrefix -> PacketPredicate
senderTransportIs :: Word16 -> PacketPredicate
receiverTransportIs :: Word16 -> PacketPredicate
receiverTransportIn :: [Word16] -> PacketPredicate
ands :: [PacketPredicate] -> PacketPredicate
ors :: [PacketPredicate] -> PacketPredicate

-- | This function defines when an incoming packet (as received by a
--   switch) satisfies a given packet predicate.
satisfies :: (PortID, EthernetFrame) -> PacketPredicate -> Bool

-- | Computes the clauses for a packet predicate; assumes the data type
--   invariants hold. A packet satisfies a list of clauses if it satisfies
--   some clause in the list. From this it follows that no packet satisfies
--   the empty list of clauses. I.e. the empty list of clauses is
--   equivalent to False.
clauses :: PacketPredicate -> [Clause]
literals :: PacketPredicate -> [Literal]

-- | With the above, we can now calculate whether two packet predicates
--   overlap, that is, when their intersection is non-empty.
overlaps :: PacketPredicate -> PacketPredicate -> Bool
dhcp :: PacketPredicate

-- | Commonly occurring packet predicates.
dns :: PacketPredicate
arp :: PacketPredicate
lldp :: PacketPredicate
ip :: PacketPredicate
udp :: PacketPredicate
ethSourceDestAre :: EthernetAddress -> EthernetAddress -> PacketPredicate

-- | Calculates a packet predicate that matches the same in-packets as the
--   given match.
fromMatch :: Match -> PacketPredicate

-- | The disjunction of (toMatches pred) matches the same set of packets as
--   the packet predicate pred does.
toMatches :: PacketPredicate -> Maybe [Match]
realizable :: PacketPredicate -> Bool
packetInFrame :: PacketInfo -> Either ErrorMessage EthernetFrame
exactPredicate :: PacketInfo -> Either ErrorMessage PacketPredicate
packetInMatches :: PacketInfo -> PacketPredicate -> Either ErrorMessage Bool
instance Show PacketPredicate
instance Read PacketPredicate
instance Eq PacketPredicate
instance Logic (PortID, EthernetFrame) PacketPredicate

module Nettle.FRPControl.AFRP
class (Floating a) => VectorSpace v a | v -> a
zeroVector :: (VectorSpace v a) => v
(*^) :: (VectorSpace v a) => a -> v -> v
(^/) :: (VectorSpace v a) => v -> a -> v
negateVector :: (VectorSpace v a) => v -> v
(^+^) :: (VectorSpace v a) => v -> v -> v
(^-^) :: (VectorSpace v a) => v -> v -> v
dot :: (VectorSpace v a) => v -> v -> a
norm :: (VectorSpace v a) => v -> a
normalize :: (VectorSpace v a) => v -> v

-- | The class <a>RandomGen</a> provides a common interface to random
--   number generators.
--   
--   Minimal complete definition: <a>next</a> and <a>split</a>.
class RandomGen g
next :: (RandomGen g) => g -> (Int, g)
split :: (RandomGen g) => g -> (g, g)
genRange :: (RandomGen g) => g -> (Int, Int)

-- | With a source of random number supply in hand, the <a>Random</a> class
--   allows the programmer to extract random values of a variety of types.
--   
--   Minimal complete definition: <a>randomR</a> and <a>random</a>.
class Random a
randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
random :: (Random a, RandomGen g) => g -> (a, g)
randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
randoms :: (Random a, RandomGen g) => g -> [a]
randomRIO :: (Random a) => (a, a) -> IO a
randomIO :: (Random a) => IO a
(#) :: (a -> b) -> (b -> c) -> (a -> c)
dup :: a -> (a, a)
swap :: (a, b) -> (b, a)
type Time = Double
data SF a b
data Event a
NoEvent :: Event a
Event :: a -> Event a
identity :: SF a a
constant :: b -> SF a b
localTime :: SF a Time
time :: SF a Time
(-->) :: b -> SF a b -> SF a b
(>--) :: a -> SF a b -> SF a b
(-=>) :: (b -> b) -> SF a b -> SF a b
(>=-) :: (a -> a) -> SF a b -> SF a b
initially :: a -> SF a a
never :: SF a (Event b)
now :: b -> SF a (Event b)
after :: Time -> b -> SF a (Event b)
repeatedly :: Time -> b -> SF a (Event b)
afterEach :: [(Time, b)] -> SF a (Event b)
edge :: SF Bool (Event ())
iEdge :: Bool -> SF Bool (Event ())
edgeTag :: a -> SF Bool (Event a)
edgeJust :: SF (Maybe a) (Event a)
edgeBy :: (a -> a -> Maybe b) -> a -> SF a (Event b)
notYet :: SF (Event a) (Event a)
once :: SF (Event a) (Event a)
takeEvents :: Int -> SF (Event a) (Event a)
dropEvents :: Int -> SF (Event a) (Event a)
switch :: SF a (b, Event c) -> (c -> SF a b) -> SF a b
dSwitch :: SF a (b, Event c) -> (c -> SF a b) -> SF a b
rSwitch :: SF a b -> SF (a, Event (SF a b)) b
drSwitch :: SF a b -> SF (a, Event (SF a b)) b
kSwitch :: SF a b -> SF (a, b) (Event c) -> (SF a b -> c -> SF a b) -> SF a b
dkSwitch :: SF a b -> SF (a, b) (Event c) -> (SF a b -> c -> SF a b) -> SF a b
parB :: (Functor col) => col (SF a b) -> SF a (col b)
pSwitchB :: (Functor col) => col (SF a b) -> SF (a, col b) (Event c) -> (col (SF a b) -> c -> SF a (col b)) -> SF a (col b)
dpSwitchB :: (Functor col) => col (SF a b) -> SF (a, col b) (Event c) -> (col (SF a b) -> c -> SF a (col b)) -> SF a (col b)
rpSwitchB :: (Functor col) => col (SF a b) -> SF (a, Event (col (SF a b) -> col (SF a b))) (col b)
drpSwitchB :: (Functor col) => col (SF a b) -> SF (a, Event (col (SF a b) -> col (SF a b))) (col b)
par :: (Functor col) => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF a (col c)
pSwitch :: (Functor col) => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)
dpSwitch :: (Functor col) => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)
rpSwitch :: (Functor col) => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, Event (col (SF b c) -> col (SF b c))) (col c)
drpSwitch :: (Functor col) => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, Event (col (SF b c) -> col (SF b c))) (col c)
hold :: a -> SF (Event a) a
trackAndHold :: a -> SF (Maybe a) a
accum :: a -> SF (Event (a -> a)) (Event a)
accumBy :: (b -> a -> b) -> b -> SF (Event a) (Event b)
accumFilter :: (c -> a -> (c, Maybe b)) -> c -> SF (Event a) (Event b)
pre :: SF a a
iPre :: a -> SF a a
integral :: (VectorSpace a s) => SF a a
derivative :: (VectorSpace a s) => SF a a
imIntegral :: (VectorSpace a s) => a -> SF a a
loopPre :: c -> SF (a, c) (b, c) -> SF a b
loopIntegral :: (VectorSpace c s) => SF (a, c) (b, c) -> SF a b
noEvent :: Event a
noEventFst :: (Event a, b) -> (Event c, b)
noEventSnd :: (a, Event b) -> (a, Event c)
liftE :: (a -> b) -> Event a -> Event b
event :: a -> (b -> a) -> Event b -> a

-- | Useful function for projecting a monoidal value out of an Event value.
fromEvent :: (Monoid a) => Event a -> a
isEvent :: Event a -> Bool
isNoEvent :: Event a -> Bool
tag :: Event a -> b -> Event b
attach :: Event a -> b -> Event (a, b)
lMerge :: Event a -> Event a -> Event a
rMerge :: Event a -> Event a -> Event a
merge :: Event a -> Event a -> Event a
mergeBy :: (a -> a -> a) -> Event a -> Event a -> Event a
mapMerge :: (a -> c) -> (b -> c) -> (a -> b -> c) -> Event a -> Event b -> Event c
mergeEvents :: [Event a] -> Event a
mergeEventsBy :: (a -> a -> a) -> [Event a] -> Event a
catEvents :: [Event a] -> Event [a]
joinE :: Event a -> Event b -> Event (a, b)
splitE :: Event (a, b) -> (Event a, Event b)
filterE :: (a -> Bool) -> Event a -> Event a
mapFilterE :: (a -> Maybe b) -> Event a -> Event b
gate :: Event a -> Bool -> Event a
maybeToEvent :: Maybe a -> Event a
noise :: (RandomGen g, Random b) => g -> SF a b
noiseR :: (RandomGen g, Random b) => (b, b) -> g -> SF a b
occasionally :: (RandomGen g) => g -> Time -> b -> SF a (Event b)
reactimate :: IO a -> (Bool -> IO (DTime, Maybe a)) -> (Bool -> b -> IO Bool) -> SF a b -> IO ()
type ReactHandle a b = IORef (ReactState a b)
reactInit :: IO a -> (ReactHandle a b -> Bool -> b -> IO Bool) -> SF a b -> IO (ReactHandle a b)
react :: ReactHandle a b -> (DTime, Maybe a) -> IO Bool
type DTime = Double
embed :: SF a b -> (a, [(DTime, Maybe a)]) -> [b]
embedSynch :: SF a b -> (a, [(DTime, Maybe a)]) -> SF Double b
deltaEncode :: (Eq a) => DTime -> [a] -> (a, [(DTime, Maybe a)])
deltaEncodeBy :: (a -> a -> Bool) -> DTime -> [a] -> (a, [(DTime, Maybe a)])

-- | Evaluate the signal function.
evalSF :: SF a b -> (a, [(DTime, a)]) -> [(DTime, b)]

-- | Delay the input by the number of samples in the given list. The first
--   samples will be from the list, while the next samples will be from the
--   input. Warning: this operation only makes sense in the case when the
--   sampling interval is constant, in which case it implements a delay of
--   <tt>length xs * dt</tt> time units, where <tt>dt</tt> is the sampling
--   interval and <tt>xs</tt> is the input list.
initDelay :: [a] -> SF a a
instance ArrowLoop SF
instance Arrow SF
instance Category SF


-- | This module defines type classes for input types carrying switch
--   messages and output types carrying switch commands. It defines a few
--   basic instances of these classes. In addition it defines some signal
--   functions that implement the most basic functionality to maintain
--   switch-controller connections.
module Nettle.FRPControl.SwitchInterface

-- | A switch message is a TCP message where normal messages contain a
--   <tt>TransactionID</tt> and an <tt>SCMessage</tt>
type SwitchMessage = TCPMessage (TransactionID, SCMessage)
data SockAddr :: *

-- | Projects out the <tt>SockAddr</tt> associated with the switch from a
--   <tt>ConnectionEstablished</tt> <tt>TCPMessage</tt>.
switchJoinE :: Event SwitchMessage -> Event SockAddr

-- | Outputs an event whenever the switch disconnects from the controller.
--   The event carries the <tt>SockAddr</tt> used to communicate with the
--   switch and an <tt>IOException</tt> value indicating the reason for the
--   disconnection.
switchLeaveE :: Event SwitchMessage -> Event (SockAddr, IOException)

-- | Outputs an event whenever a switch sends a hello message.
switchHelloE :: Event SwitchMessage -> Event (SockAddr, TransactionID)

-- | Outputs an event whenever a switch sends an echo request; carries the
--   <tt>SockAddr</tt> of the switch, the <tt>TransactionID</tt> of the
--   echo request, and the data included in the echo request.
switchEchoRequestE :: Event SwitchMessage -> Event (SockAddr, TransactionID, [Word8])

-- | Outputs an event whenever a switch sends an echo reply; carries the
--   <tt>SockAddr</tt> of the switch, the <tt>TransactionID</tt> of the
--   echo reply, and the data included in the echo reply.
switchEchoReplyE :: Event SwitchMessage -> Event (SockAddr, TransactionID, [Word8])

-- | Outputs an event whenever a switch sends a packet in message. The
--   event carries the <tt>SockAddr</tt> of the switch, the
--   <tt>TransactionID</tt> of the message, and the <tt>PacketInfo</tt>
--   message itself.
packetInE :: Event SwitchMessage -> Event (SockAddr, TransactionID, PacketInfo)

-- | Outputs an event whenever a switch sends a switch features message.
--   The event carries the <tt>SockAddr</tt> of the switch, the
--   <tt>TransactionID</tt> of the message, and the <tt>SwitchFeatures</tt>
--   message itself.
switchFeaturesE :: Event SwitchMessage -> Event (SockAddr, TransactionID, SwitchFeatures)

-- | Outputs an event whenever a switch sends a port update message. The
--   event carries the <tt>SockAddr</tt> of the switch, the
--   <tt>TransactionID</tt> of the message, and the <tt>PortStatus</tt>
--   message itself.
portUpdateE :: Event SwitchMessage -> Event (SockAddr, TransactionID, PortStatus)

-- | Outputs an event whenever a switch sends an error message. The event
--   carries the <tt>SockAddr</tt> of the switch, the
--   <tt>TransactionID</tt> of the message, and the <tt>SwitchError</tt>
--   message itself.
switchErrorE :: Event SwitchMessage -> Event (SockAddr, TransactionID, SwitchError)

-- | Outputs an event whenever a switch sends an flow removed message. The
--   event carries the <tt>SockAddr</tt> of the switch, the
--   <tt>TransactionID</tt> of the message, and the <tt>FlowRemoved</tt>
--   message itself.
flowRemovalE :: Event SwitchMessage -> Event (SockAddr, TransactionID, FlowRemoved)

-- | Outputs an event whenever a switch sends statistics reply. The event
--   carries the <tt>SockAddr</tt> of the switch, the
--   <tt>TransactionID</tt> of the message, and the <tt>StatsReply</tt>
--   message itself.
statsReplyE :: Event SwitchMessage -> Event (SockAddr, TransactionID, StatsReply)

-- | Outputs an event whenever a switch sends port statistics reply. The
--   event carries the <tt>SockAddr</tt> of the switch, the
--   <tt>TransactionID</tt> of the message, a flag indicating whether more
--   statistics for this reply will follow in a separate message and the
--   port statistics included in this message itself.
portStatsReplyE :: Event SwitchMessage -> Event (SockAddr, TransactionID, MoreToFollowFlag, [(PortID, PortStats)])

-- | Outputs an event whenever a switch sends flow statistics reply. The
--   event carries the <tt>SockAddr</tt> of the switch, the
--   <tt>TransactionID</tt> of the message, a flag indicating whether more
--   statistics for this reply will follow in a separate message and the
--   flow statistics included in this message itself.
flowStatsReplyE :: Event SwitchMessage -> Event (SockAddr, TransactionID, MoreToFollowFlag, [FlowStats])

-- | Outputs an event whenever a switch sends a barrier reply. The event
--   carries the <tt>SockAddr</tt> of the switch and the
--   <tt>TransactionID</tt> of the message.
barrierReplyE :: Event SwitchMessage -> Event (SockAddr, TransactionID)

-- | Remove packet in messages not satisfying the given predicate.
filterPacketIns :: (PacketInfo -> Bool) -> Event SwitchMessage -> Event SwitchMessage
type SwitchOutput = [(SockAddr, (TransactionID, CSMessage))]
switchCommand :: SockAddr -> TransactionID -> CSMessage -> SwitchOutput

-- | Another name for the unit element of a Monoid, specialized to the
--   HasSwitchCommands class.
noOp :: (Monoid o) => o

-- | Infix binary operator for mappend.
(<+>) :: (Monoid o) => o -> o -> o

-- | Runs an OpenFlow server at the specified port number, and return the
--   driver IO actions.
switchInterfaceDriver :: ServerPortNumber -> IO (IO SwitchMessage, SwitchOutput -> IO ())

-- | <tt>openFlowController</tt> implements the basic aspects of the
--   OpenFlow protocol, such as the initial version negotiation and
--   responding to echo requests.
openFlowController :: SF (Event SwitchMessage) (Event SwitchOutput)
instance (Monoid a) => Monoid (Event a)


-- | This module provides some utilities for writing drivers of signal
--   functions.
module Nettle.FRPControl.AFRPUtils

-- | Empty list.
data Nil

-- | Cons list
data (:::) x xs

-- | Infix operator; synonymous with TCons.
--   
--   Value level representation of type level lists.
data Rep a
RNil :: Rep Nil
RCons :: Rep b -> Rep (a ::: b)

-- | Input types for each heterogeneous type list.

-- | Vector of Sensor channels of the right types

-- | Output type for each heterogeneous list

-- | Drives signal functions with the given collection of sensor channels
--   and actuator actions. It multiplexes the sensors into a single channel
--   of events.
sfDriver :: Rep s -> SensorChans s -> Rep t -> Actuators t -> SF (SFInput s) (SFOutput t) -> IO ()


-- | Module that can be used to generate UDP traffic using a signal
--   function that outputs packets and displays information on the local
--   console.
module Nettle.FRPControl.TrafficGenerator

-- | The type of signal function that can be used to generate UDP traffic.
type TrafficGenerator = SF () (Event PacketSendCommand)

-- | A packet send command is a list of triples including the destination
--   address, the UDP port, and the payload (as a String).
type PacketSendCommand = [(IPAddress, UDPPort, String)]

-- | A console message is simply a string.
type ConsoleMessage = String

-- | A UDP port is a 16 bit number.
type UDPPort = Word16

-- | Drive (i.e. run) a traffic generator.
driveTrafficGenerator :: SF () (Event PacketSendCommand, Event ConsoleMessage) -> IO ()


-- | Nettle signal functions and drivers. These drivers take care of low
--   level details, such as message numbering, correlation of stats
--   requests and replies, translation of higher level flow rules expressed
--   using packet predicates to low level flow rules expressed in terms of
--   matches.
module Nettle.FRPControl.NettleSF

-- | Runs a signal function carrying messages and commands as defined in
--   this module, converting it into a signal function in terms of basic
--   switch messages and switch output, which can be run using the switch
--   driver provided in <tt>SwitchInterface</tt>.
runNettleSF :: SF (Event (SwitchID, SwitchMessage), i) (Event SwitchCommand, o) -> SF (Event SwitchMessage, i) (SwitchOutput, o)

-- | Runs a signal function with a single input stream of switch messages
--   and two output streams, one for switch commands and one for messages
--   to the standard output device; starts a switch server at the specified
--   port.
simpleNettleDriver :: ServerPortNumber -> SF (Event (SwitchID, SwitchMessage)) (Event SwitchCommand, Event String) -> IO ()
data SwitchMessage
Arrival :: SwitchFeatures -> SwitchMessage
Departure :: IOException -> SwitchMessage
FeatureUpdate :: SwitchFeatures -> SwitchMessage
PortUpdate :: PortStatus -> SwitchMessage
SwitchError :: SwitchError -> SwitchMessage
PacketIn :: PacketInfo -> SwitchMessage
FlowRemoved :: FlowRemoved -> SwitchMessage
PortStatsUpdate :: [(PortID, PortStats)] -> SwitchMessage
FlowStatsUpdate :: [FlowStats] -> SwitchMessage

-- | Outputs an event whenever a switch connects with the controller. The
--   event carries the <tt>SwitchID</tt> of the switch.
arrivalE :: Event (SwitchID, SwitchMessage) -> Event (SwitchID, SwitchFeatures)

-- | Outputs an event whenever the switch disconnects from the controller.
--   The event carries the <tt>SwitchID</tt> of the switch and an
--   <tt>IOException</tt> value indicating the reason for the
--   disconnection.
departureE :: Event (SwitchID, SwitchMessage) -> Event (SwitchID, IOException)

-- | Outputs an event whenever a switch sends a switch features update. The
--   event carries the <tt>SwitchID</tt> of the sending switch and the
--   <tt>SwitchFeatures</tt> data.
featureUpdateE :: Event (SwitchID, SwitchMessage) -> Event (SwitchID, SwitchFeatures)

-- | Outputs an event whenever a switch sends a port status update. The
--   event carries the <tt>SwitchID</tt> of the sending switch and the
--   <tt>PortStatus</tt>.
portUpdateE :: Event (SwitchID, SwitchMessage) -> Event (SwitchID, PortStatus)

-- | Outputs an event whenever a switch sends an error message. The event
--   carries the <tt>SwitchID</tt> of the sending switch and the
--   <tt>SwitchError</tt>.
switchErrorE :: Event (SwitchID, SwitchMessage) -> Event (SwitchID, SwitchError)

-- | Outputs an event whenever a switch sends a packet in message. The
--   event carries the <tt>SwitchID</tt> of the sending switch and the
--   <tt>PacketInfo</tt>.
packetInE :: Event (SwitchID, SwitchMessage) -> Event (SwitchID, PacketInfo)

-- | Packet-in events, filtered by a packet predicate applied to the packet
--   carried by the packet-in event. The output stream will only include
--   Packet-in messages that satisfy the filter criteria.
filteredPacketInE :: PacketPredicate -> Event (SwitchID, SwitchMessage) -> Event (SwitchID, PacketInfo)

-- | Outputs an event whenever a switch notifies the controller of a flow
--   removal.
flowRemovedE :: Event (SwitchID, SwitchMessage) -> Event (SwitchID, FlowRemoved)

-- | Outputs an event whenever a switch sends a port statistics information
--   to the controller. This information may be communicated with several
--   messages; the statistics from several messages related to the same
--   statistics request are aggregated and output in one event from this
--   signal function.
portStatReplyE :: Event (SwitchID, SwitchMessage) -> Event (SwitchID, [(PortID, PortStats)])

-- | Outputs an event whenever a switch sends a flow statistics information
--   to the controller. This information may be communicated with several
--   messages; the statistics from several messages related to the same
--   statistics request are aggregated and output in one event from this
--   signal function.
flowStatReplyE :: Event (SwitchID, SwitchMessage) -> Event (SwitchID, [FlowStats])

-- | Type of switch commands
data SwitchCommand

-- | Send a packet
sendPacket :: SwitchID -> PacketOut -> SwitchCommand

-- | Modify a flow table
modifyFlowTable :: SwitchID -> FlowMod -> SwitchCommand

-- | Delete all flow entries whose match conditions fall inside a given
--   packet predicate.
deleteFlowRules :: SwitchID -> PacketPredicate -> SwitchCommand

-- | Clear the flow table of a switch. <tt>clearTables switch =
--   deleteFlowRules switch anyPacket</tt>.
clearTables :: SwitchID -> SwitchCommand

-- | Configure a port
configurePort :: SwitchID -> PortMod -> SwitchCommand

-- | Request statistics
requestStats :: SwitchID -> StatsRequest -> SwitchCommand

-- | Request switch features
requestFeatures :: SwitchID -> SwitchCommand
type FlowRule = (PacketPredicate, ActionSequence, TimeOut, TimeOut)
type PrioritizedFlowRule = (Priority, FlowRule)
addFlowRule :: PrioritizedFlowRule -> SwitchID -> SwitchCommand
addFlowRule' :: PrioritizedFlowRule -> BufferID -> SwitchID -> SwitchCommand

-- | Add a collection of flow rules to a switch.
addFlowRules :: [(Priority, (PacketPredicate, ActionSequence, TimeOut, TimeOut))] -> SwitchID -> SwitchCommand

-- | Infix binary operator for mappend.
(<+>) :: (Monoid o) => o -> o -> o

-- | Another name for the unit element of a Monoid, specialized to the
--   HasSwitchCommands class.
noOp :: (Monoid o) => o

-- | A synonym for the tupling operator, specialized to packet predicates.
--   Provides suggestive infix syntax useful in writing addFlowRule
--   commands.
(==>) :: PacketPredicate -> ActionSequence -> FlowRule
expiringAfter :: FlowRule -> Word16 -> FlowRule
expiringAfterInactive :: FlowRule -> Word16 -> FlowRule
withPriority :: FlowRule -> Priority -> PrioritizedFlowRule
instance Show BindingChange
instance Eq BindingChange
instance Monoid SwitchCommand
instance Show SwitchCommand
instance Eq SwitchCommand
instance Show SwitchMessage
instance Eq SwitchMessage


-- | This module defines a relational view of the network state and
--   configuration, and provides signal functions that dynamically maintain
--   this view.
module Nettle.FRPControl.NetInfo

-- | A <tt>SwitchTable</tt> is a list of <tt>SwitchRecord</tt>s
type SwitchTable = [SwitchRecord]
data SwitchRecord
SwitchRecord :: SwitchID -> Integer -> Integer -> [SwitchCapability] -> [ActionType] -> SwitchRecord

-- | switch identifier
switchID :: SwitchRecord -> SwitchID

-- | maximum number of packets buffered at the switch
packetBufferSize :: SwitchRecord -> Integer

-- | number of flow tables
numberFlowTables :: SwitchRecord -> Integer

-- | switch's capabilities
capabilities :: SwitchRecord -> [SwitchCapability]

-- | actions supported by the switch
supportedActions :: SwitchRecord -> [ActionType]

-- | A list of <tt>PortRecord</tt>s; <tt>PortRecords</tt> should be
--   uniquely identifiable by their <tt>SwitchID</tt> and <tt>PortID</tt>.
type PortTable = [PortRecord]
data PortRecord
PortRecord :: SwitchID -> PortID -> EthernetAddress -> SpanningTreePortState -> Bool -> Bool -> Bool -> PortRecord

-- | Switch the port belongs to
portSwitch :: PortRecord -> SwitchID

-- | Port ID of the port
portID :: PortRecord -> PortID

-- | Hardware (Ethernet) address of the port.
portAddr :: PortRecord -> EthernetAddress

-- | Spanning tree protocol state for this port
spanningTreeState :: PortRecord -> SpanningTreePortState
isPortDown :: PortRecord -> Bool
isLinkDown :: PortRecord -> Bool
isUsedForFlooding :: PortRecord -> Bool

-- | Type class for records having datapath-id fields. Having records
--   implement this class allows the client to use uniform syntax for
--   fields of different records.
class HasDataPathID a
dPID :: (HasDataPathID a) => a -> SwitchID

-- | The NetInfo datatype carries network information in a form that is
--   easily retrieved from switches.
data NetInfo

-- | Project the current <tt>PortTable</tt> value from a <tt>NetInfo</tt>
--   value.
portTable :: NetInfo -> PortTable

-- | Project the current <tt>SwitchTable</tt> value from a <tt>NetInfo</tt>
--   value.
switchTable :: NetInfo -> SwitchTable
data NetworkMonitorPolicy
NetworkMonitorPolicy :: Time -> Time -> NetworkMonitorPolicy

-- | Amount of time (in seconds) between switch feature queries
switchFeaturesRefreshPeriod :: NetworkMonitorPolicy -> Time

-- | Amount of time (in seconds) between port statistics queries
portStatisticsRefreshPeriod :: NetworkMonitorPolicy -> Time
defaultMonitorPolicy :: NetworkMonitorPolicy

-- | Issues switch queries according to the given
--   <tt>NetworkMonitorPolicy</tt>.
networkInfoRequester :: NetworkMonitorPolicy -> SF (Event (SwitchID, SwitchMessage)) (Event SwitchCommand)
switchInfo :: SF (Event (SwitchID, SwitchMessage)) NetInfo

-- | Map giving the next hop <tt>PortID</tt> (if it is known) to a host
--   from a given switch.
type HostDirectionMap = Map (SwitchID, EthernetAddress) PortID

-- | Current <tt>HostDirectionMap</tt>
hostDirectionsSF :: SF (Event (SwitchID, SwitchMessage)) HostDirectionMap

-- | Outputs an event whenever the host direction information changes.
--   Outputs both the previous and the updated host direction map.
hostDirectionsChangeSF :: SF (Event (SwitchID, SwitchMessage)) (Event (HostDirectionMap, HostDirectionMap))
type HostLocationMap = Map EthernetAddress (SwitchID, PortID)
hostLocationSF :: SF (Event (SwitchID, SwitchMessage), Topology) HostLocationMap

-- | Applies the given signal function to each switch-port pair in the
--   network.
withPortStats :: SF (Event PortStats) a -> SF (Event (SwitchID, SwitchMessage)) (Map (SwitchID, PortID) a)

-- | Computes the rate of change of the port statistics vector by
--   calculating - for each component of the vector - the difference
--   between the last two samples and dividing by the time difference. This
--   measurements are then held until the next sample is observed.
portRatesMapSF :: SF (Event (SwitchID, SwitchMessage)) (Map (SwitchID, PortID) PortStats)

-- | Tracks the average rate of change of the port statistics using a
--   moving average of the last <tt>n</tt> port statistics updates, where
--   <tt>n</tt> is the first argument to the function.
nAveragePortRateMap :: Int -> SF (Event (SwitchID, SwitchMessage)) (Map (SwitchID, PortID) PortStats)
instance Show NetworkMonitorPolicy
instance Eq NetworkMonitorPolicy
instance Show NetInfo
instance Show PortRecord
instance Eq PortRecord
instance Show SwitchRecord
instance Eq SwitchRecord
instance Ord SwitchRecord
instance HasDataPathID PortRecord
instance HasDataPathID SwitchID


-- | Experimental version of topology discovery algorithm.
module Nettle.Discovery.Discovery

-- | A signal function tracking the topology of the network. The signal
--   function sends LLDP-like packets from various points in the network
--   and infers the topology based on packet-in events generated by those
--   packets. In order to ensure that your controller does not interfere
--   with the operation of <tt>topoTracker</tt>, you should drive your
--   controllers with the switch message stream output by the
--   <tt>topoTracker</tt> (the first output stream), which has the
--   packet-in events generated by the LLDP-like packets filtered out. The
--   second output stream is a stream of commands which must be merged into
--   the overall output of your controller in order for the
--   <tt>topoTracker</tt> to inject its discovery packets into the network.
topoTracker :: SF (Event (SwitchID, SwitchMessage)) (Event (SwitchID, SwitchMessage), Event SwitchCommand, Event Topology)
