-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | librados haskell bindings
--   
@package rados-haskell
@version 3.1.0


-- | The underlying FFI wrappers, feel free to use these. I will not remove
--   any between major versions and they shouldn't need to change.
module System.Rados.FFI
data RadosT
data RadosIOCtxT
data RadosListCtxT
data RadosCompletionT
data RadosWriteOpT
type RadosCallback = Ptr RadosCompletionT -> Ptr () -> IO ()
type RadosCallbackT = FunPtr RadosCallback
newtype LockFlag
LockFlag :: Word8 -> LockFlag
unLockFlag :: LockFlag -> Word8
idempotent :: LockFlag
data TimeVal
TimeVal :: CLong -> CLong -> TimeVal
seconds :: TimeVal -> CLong
microseconds :: TimeVal -> CLong
c_rados_create :: Ptr (Ptr RadosT) -> CString -> IO CInt
c_rados_shutdown :: Ptr RadosT -> IO ()
c_rados_conf_read_file :: Ptr RadosT -> CString -> IO CInt
c_rados_conf_parse_argv :: Ptr RadosT -> CInt -> Ptr CString -> IO CInt
c_rados_conf_parse_env :: Ptr RadosT -> CString -> IO CInt
c_rados_connect :: Ptr RadosT -> IO CInt
c_rados_ioctx_create :: Ptr RadosT -> CString -> Ptr (Ptr RadosIOCtxT) -> IO CInt
c_rados_ioctx_destroy :: Ptr RadosIOCtxT -> IO ()
c_rados_aio_create_completion :: Ptr () -> RadosCallbackT -> RadosCallbackT -> Ptr (Ptr RadosCompletionT) -> IO CInt
c_rados_aio_release :: FunPtr (Ptr RadosCompletionT -> IO ())
c_strerror :: Errno -> IO (Ptr CChar)
c_rados_aio_wait_for_complete :: Ptr RadosCompletionT -> IO CInt
c_rados_aio_wait_for_safe :: Ptr RadosCompletionT -> IO CInt
c_rados_aio_get_return_value :: Ptr RadosCompletionT -> IO CInt
c_rados_aio_read :: Ptr RadosIOCtxT -> CString -> Ptr RadosCompletionT -> CString -> CSize -> Word64 -> IO CInt
c_rados_aio_write :: Ptr RadosIOCtxT -> CString -> Ptr RadosCompletionT -> CString -> CSize -> Word64 -> IO CInt
c_rados_aio_write_full :: Ptr RadosIOCtxT -> CString -> Ptr RadosCompletionT -> CString -> CSize -> IO CInt
c_rados_aio_append :: Ptr RadosIOCtxT -> CString -> Ptr RadosCompletionT -> CString -> CSize -> IO CInt
c_rados_aio_stat :: Ptr RadosIOCtxT -> CString -> Ptr RadosCompletionT -> Ptr Word64 -> Ptr CTime -> IO CInt
c_rados_aio_remove :: Ptr RadosIOCtxT -> CString -> Ptr RadosCompletionT -> IO CInt
c_rados_write :: Ptr RadosIOCtxT -> CString -> CString -> CSize -> Word64 -> IO CInt
c_rados_write_full :: Ptr RadosIOCtxT -> CString -> CString -> CSize -> IO CInt
c_rados_append :: Ptr RadosIOCtxT -> CString -> CString -> CSize -> IO CInt
c_rados_read :: Ptr RadosIOCtxT -> CString -> CString -> CSize -> Word64 -> IO CInt
c_rados_remove :: Ptr RadosIOCtxT -> CString -> IO CInt
c_rados_stat :: Ptr RadosIOCtxT -> CString -> Ptr Word64 -> Ptr CTime -> IO CInt
c_rados_lock_exclusive :: Ptr RadosIOCtxT -> CString -> CString -> CString -> CString -> Ptr TimeVal -> LockFlag -> IO CInt
c_rados_unlock :: Ptr RadosIOCtxT -> CString -> CString -> CString -> IO CInt
c_rados_lock_shared :: Ptr RadosIOCtxT -> CString -> CString -> CString -> CString -> CString -> Ptr TimeVal -> LockFlag -> IO CInt
c_rados_objects_list_open :: Ptr RadosIOCtxT -> Ptr (Ptr RadosListCtxT) -> IO CInt
c_rados_objects_list_close :: Ptr RadosListCtxT -> IO ()
c_rados_objects_list_next :: Ptr RadosListCtxT -> Ptr CString -> Ptr CString -> IO CInt
c_getProgArgv :: Ptr CInt -> Ptr (Ptr CString) -> IO ()
instance Eq TimeVal
instance Show TimeVal
instance Storable TimeVal
instance Num TimeVal


-- | Bindings to librados, covers async read/writes, locks and atomic
--   writes (build flag).
--   
--   These are underlying functions used for the monadic implementation
--   <a>System.Rados</a>.
--   
--   These can be a bit of a pain to use as they are thin wrappers around
--   the C API, you will need to do a lot of cleanup yourself.
module System.Rados.Base

-- | A connection to a rados cluster, required to get an <a>IOContext</a>
data Connection

-- | A handle to query the status of an asynchronous action
data Completion

-- | An IO context with a rados pool.
data IOContext

-- | A pool listing handle
data ListContext
data TimeVal
TimeVal :: CLong -> CLong -> TimeVal
seconds :: TimeVal -> CLong
microseconds :: TimeVal -> CLong
data LockFlag

-- | An error indicated by librados, usually in the form of a negative
--   return value
data RadosError
Unknown :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String

-- | Usually returned if a file does not exist
NoEntity :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String

-- | Returned if a file already exists, and should not.
Exists :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String

-- | Returned in the event of a failed atomic transaction
Canceled :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String

-- | A value was out of range, returned when reading or writing from/to
--   invalid regions.
Range :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String
User :: String -> RadosError
message :: RadosError -> String

-- | Perform an action given a <a>Connection</a>, cleans up with
--   <a>bracket</a>
--   
--   <pre>
--   withConnection Nothing $ c -&gt; do
--     confReadFile c "/etc/config"
--     doStuff
--   </pre>
withConnection :: Maybe ByteString -> (Connection -> IO a) -> IO a

-- | Attempt to create a new 'Connection, taking an optional id. You must
--   run cleanupConnection on the handle when you are done with it.
--   
--   <pre>
--   h  &lt;- newConnection Nothing
--   h' &lt;- newConnection $ Just "admin"
--   
--   cleanupConnection h
--   cleanupConnection h'
--   </pre>
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_create</a>
newConnection :: Maybe ByteString -> IO Connection

-- | Clean up a cluster handle.
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_shutdown</a>
cleanupConnection :: Connection -> IO ()

-- | Load a config specified by <a>FilePath</a> into a given 'Connection.
--   
--   <pre>
--   h &lt;- newConnection Nothing
--   confReadFile h "/etc/config"
--   </pre>
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_conf_read_file</a>
confReadFile :: Connection -> FilePath -> IO (Maybe RadosError)
confParseArgv :: Connection -> IO (Maybe RadosError)
confParseEnv :: Connection -> IO (Maybe RadosError)

-- | Attempt to connect a configured 'Connection.
--   
--   <pre>
--   h &lt;- newConnection Nothing
--   confReadFile h "<i>etc</i>config"
--   connect h
--   </pre>
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_connect</a>
connect :: Connection -> IO ()

-- | Perform an action given an <a>IOContext</a>, cleans up with
--   <a>bracket</a>
--   
--   <pre>
--   withConnection Nothing $ c -&gt; do
--       confParseArgv c
--       withIOContext c "pool_a" ctx -&gt;
--           syncRemove ctx "an_object"
--   </pre>
withIOContext :: Connection -> ByteString -> (IOContext -> IO a) -> IO a

-- | Attempt to create a new <a>IOContext</a>, requires a valid
--   <a>Connection</a> and pool name.
--   
--   <pre>
--   h &lt;- newConnection Nothing
--   h ctx &lt;- newIOContext h "thing"
--   cleanupIOContext ctx
--   cleanupConnection h
--   </pre>
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_ioctx_create</a>
newIOContext :: Connection -> ByteString -> IO IOContext

-- | Clean up an IOContext
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_ioctx_destroy</a>
cleanupIOContext :: IOContext -> IO ()

-- | Write a <a>ByteString</a> to <a>IOContext</a>, object id and offset.
--   
--   <pre>
--   ...
--   syncWrite IOContext "object_id" 42 "written at offset fourty-two"
--   </pre>
syncWrite :: IOContext -> ByteString -> Word64 -> ByteString -> IO (Maybe RadosError)

-- | Write a <a>ByteString</a> to <a>IOContext</a> and object id.
--   
--   This will replace any existing object at the same <a>IOContext</a> and
--   object id.
syncWriteFull :: IOContext -> ByteString -> ByteString -> IO (Maybe RadosError)

-- | Read from <a>IOContext</a>, object ID and offset n bytes.
--   
--   There is no async read provided by this binding.
--   
--   <pre>
--   ...
--   -- Read 100 bytes into bs from offset 42
--   bs &lt;- syncRead pool "object_id" 42 100
--   ...
--   </pre>
syncRead :: IOContext -> ByteString -> Word64 -> Word64 -> IO (Either RadosError ByteString)

-- | Append a <a>ByteString</a> to <a>IOContext</a> and object id.
--   
--   Returns the number of bytes written.
syncAppend :: IOContext -> ByteString -> ByteString -> IO (Maybe RadosError)

-- | Delete an object from <a>IOContext</a> by ID.
syncRemove :: IOContext -> ByteString -> IO (Maybe RadosError)
syncStat :: IOContext -> ByteString -> IO (Either RadosError (Word64, EpochTime))

-- | Attempt to create a new <a>Completion</a> that can be used with async
--   IO actions.
--   
--   Completion will automatically be cleaned up when it goes out of scope
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_aio_create_completion</a>
newCompletion :: IO Completion

-- | Block until a completion is complete. I.e. the operation associated
--   with the completion is at least in memory on all replicas.
--   
--   <pre>
--   ...
--   asyncWrite ctx c "oid" 42 "written at offset fourty-two"
--   putStrLn "Waiting for your bytes to get there..."
--   waitForComplete c
--   putStrLn "I totally wrote it! Maybe."
--   </pre>
--   
--   Calls rados_aio_wait_for_complete:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_aio_wait_for_complete</a>
waitForComplete :: Completion -> IO ()

-- | Block until a completion is safe. I.e. the operation associated with
--   the completion is on stable storage on all replicas.
--   
--   <pre>
--   ...
--   waitForSafe c
--   putStrLn "Yeah. Totally did write it. I hope."
--   </pre>
--   
--   Calls rados_aio_wait_for_safe:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_aio_wait_for_safe</a>
waitForSafe :: Completion -> IO ()

-- | From right to left, this function reads as:
--   
--   Write ByteString bytes to Word64 offset at oid ByteString, notifying
--   this Completion, all within this IOContext
--   
--   <pre>
--   ...
--   ctx &lt;- newIOContext h "thing"
--   asyncWrite ctx c "oid" 42 "written at offset fourty-two"
--   putStrLn $ "I wrote " ++ show n ++ " bytes"
--   </pre>
--   
--   Calls rados_aio_write:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_aio_write</a>
asyncWrite :: IOContext -> Completion -> ByteString -> Word64 -> ByteString -> IO (Either RadosError Int)

-- | Same calling convention as asyncWrite, simply omitting an offset. This
--   will truncate any existing object.
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_aio_write_full</a>
asyncWriteFull :: IOContext -> Completion -> ByteString -> ByteString -> IO (Either RadosError Int)

-- | Returns a ByteString that will be populated when the completion is
--   done.
--   
--   Attempting to read the ByteString before then is undefined.
--   
--   The completion will return with the number of bytes actually read.
--   
--   Due to this complexity, it is recommended to use the monadic bindings
--   when attempting to do async reads.
--   
--   Calls rados_aio_read:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_aio_read</a>
asyncRead :: IOContext -> Completion -> ByteString -> Word64 -> Word64 -> IO (Either RadosError ByteString)

-- | Same calling convention as asyncWriteFull, simply appends to an
--   object.
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_aio_append</a>
asyncAppend :: IOContext -> Completion -> ByteString -> ByteString -> IO (Either RadosError Int)

-- | Request the file size and mtime, returns two pointers to the data that
--   will be able to be peeked at when the request is complete.
--   
--   These pointers will free themselves
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_aio_stat</a>
asyncStat :: IOContext -> Completion -> ByteString -> IO (Either RadosError (ForeignPtr Word64, ForeignPtr CTime))

-- | Remove an object, calls rados_aio_remove
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_aio_remove</a>
asyncRemove :: IOContext -> Completion -> ByteString -> IO (Either RadosError Int)
getAsyncError :: Completion -> IO (Either RadosError Int)

-- | Perform an action with a list context, safely cleaning up with bracket
withList :: IOContext -> (ListContext -> IO a) -> IO a

-- | Return the next OID in the pool, Nothing for end of stream.
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_objects_list_next</a>
nextObject :: ListContext -> IO (Maybe ByteString)

-- | Provide a strict list of all objects.
objects :: IOContext -> IO ([ByteString])

-- | Provide a lazy list of all objects. Will only be evaluated as elements
--   are requested. Do not attempt to evaluate this list outside of a valid
--   iocontext. Do not call this again without consuming the whole list, or
--   you will reset the iteration halfway.
unsafeObjects :: IOContext -> IO ([ByteString])

-- | Begin listing objects in pool.
--   
--   Ensure that you call closeList. Preferably use withList.
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_objects_list_open</a>
openList :: IOContext -> IO ListContext

-- | Close a listing context.
--   
--   Calls:
--   <a>http://ceph.com/docs/master/rados/api/librados/#rados_objects_list_close</a>
closeList :: ListContext -> IO ()

-- | Create a random cookie, useful for shared locks.
newCookie :: IO ByteString

-- | Make an exclusive lock
exclusiveLock :: RealFrac duration => IOContext -> ByteString -> ByteString -> ByteString -> ByteString -> Maybe duration -> [LockFlag] -> IO ()

-- | Make a shared lock
sharedLock :: RealFrac duration => IOContext -> ByteString -> ByteString -> ByteString -> ByteString -> ByteString -> Maybe duration -> [LockFlag] -> IO ()

-- | Release a lock of any sort
unlock :: IOContext -> ByteString -> ByteString -> ByteString -> IO (Maybe RadosError)
idempotent :: LockFlag

-- | Take a Maybe Rados Error, if it's anything but NoEntity throw it,
missingOK :: Maybe RadosError -> IO ()
instance Ord Completion
instance Eq Completion


-- | Monadic interface to librados, covers async read/writes, locks and
--   atomic writes (ensure you use the build flag).
--   
--   This is the monadic API, you may use the underlying internals or FFI
--   calls via <a>System.Rados.Base</a> and <a>System.Rados.FFI</a>.
--   
--   A simple complete example:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   module Main where
--   import System.Rados
--   import Control.Exception
--   import qualified Data.ByteString.Char8 as B
--   main :: IO ()
--   main = do
--       kitty &lt;- runConnect Nothing (parseConfig "ceph.conf") $
--           runPool "magic_pool" . runObject "an oid" $ do
--               writeFull "hello kitty!"
--               readFull
--       either throwIO B.putStrLn (kitty :: Either RadosError B.ByteString)
--   </pre>
module System.Rados.Monadic

-- | Run an action within the <a>Connection</a> monad, this may throw a
--   RadosError to IO if the connection or configuration fails.
--   
--   <pre>
--   runConnect Nothing (parseConfig "ceph.conf") $ runPool ...
--   </pre>
runConnect :: Maybe ByteString -> (Connection -> IO (Maybe RadosError)) -> Connection a -> IO a

-- | Read a config from a relative or absolute <a>FilePath</a> into a
--   <a>Connection</a>.
--   
--   Intended for use with <a>runConnect</a>.
parseConfig :: FilePath -> Connection -> IO (Maybe RadosError)

-- | Read a config from the command line, note that no help flag will be
--   provided.
parseArgv :: Connection -> IO (Maybe RadosError)

-- | Parse the contents of the environment variable CEPH_ARGS as if they
--   were ceph command line options.
parseEnv :: Connection -> IO (Maybe RadosError)

-- | Run an action within the <a>Pool</a> monad.
--   
--   This may throw a RadosError to IO if the pool cannot be opened.
--   
--   For the following examples, we shall use:
--   
--   <pre>
--   runOurPool :: Pool a -&gt; IO a
--   runOurPool = 
--       runConnect Nothing parseArgv . runPool "magic_pool"
--   </pre>
runPool :: ByteString -> Pool a -> Connection a

-- | Return a strict list of pool items.
objects :: Pool [ByteString]

-- | Return a lazy list of pool items. This list must be evaluated within
--   the pool monad, if you wish to access the list outside of the pool
--   monad you must fully evaluate it first (which is all objects does).
unsafeObjects :: Pool [ByteString]
class Monad m => RadosReader m wrapper | m -> wrapper where readFull = stat >>= unWrap >>= either wrapFail (\ r -> readChunk (fileSize r) 0)
readChunk :: RadosReader m wrapper => Word64 -> Word64 -> m (wrapper ByteString)
readFull :: RadosReader m wrapper => m (wrapper ByteString)
stat :: RadosReader m wrapper => m (wrapper StatResult)
class Monad m => RadosWriter m e | m -> e
writeChunk :: RadosWriter m e => Word64 -> ByteString -> m e
writeFull :: RadosWriter m e => ByteString -> m e
append :: RadosWriter m e => ByteString -> m e
remove :: RadosWriter m e => m e

-- | Wrapper for the Control.Concurrent.Async library, you must be very
--   careful to wait for the completion of all created async actions within
--   the pool monad, or they will run with an invalid (cleaned up) context.
--   
--   This will be rectified in future versions when reference counting is
--   implemented, for now it is very unpolished and will require you to
--   import qualified Control.Concurrent.Async.
async :: PoolReader m => m a -> m (Async a)

-- | Any read/writes within this monad will be run asynchronously.
--   
--   Return values of reads and writes are wrapped within <a>AsyncRead</a>
--   or <a>AsyncWrite</a> respectively. You should extract the actual value
--   from a read via <a>look</a> and <a>waitSafe</a>.
--   
--   The asynchronous nature of error handling means that if you fail to
--   inspect asynchronous writes with <a>waitSafe</a>, you will never know
--   if they failed.
--   
--   <pre>
--   runOurPool . runAsync . runObject "a box" $ do
--     wr &lt;- writeFull "schrodinger's hai?\n"
--     writeChunk 14 "cat" -- Don't care about the cat.
--     print . isNothing &lt;$&gt; waitSafe wr
--     r &lt;- readFull &gt;&gt;= look
--     either throwIO print r
--   </pre>
runAsync :: PoolReader m => Async a -> m a

-- | Wait until a Rados write has hit stable storage on all replicas, you
--   will only know if a write has been successful when you inspect the
--   AsyncWrite with waitSafe.
--   
--   Provides a Maybe RadosError.
--   
--   <pre>
--   runOurPool . runAsync . runObject "a box" $ do
--     async_request &lt;- writeFull "schrodinger's hai?\n"
--     liftIO $ putStrLn "Write is in flight!"
--     maybe_error &lt;- waitSafe async_request
--     case maybe_error of
--        Just e  -&gt; liftIO $ print e
--        Nothing -&gt; return ()
--   </pre>
waitSafe :: MonadIO m => AsyncWrite -> m (Maybe RadosError)

-- | Wait until a Rados write has hit memory on all replicas. This is less
--   safe than waitSafe, but still pretty safe. Safe.
waitComplete :: MonadIO m => AsyncWrite -> m (Maybe RadosError)

-- | Take an <a>AsyncRead</a> a and provide Either RadosError a This
--   function is used for retrieving the value of an async read.
--   
--   <pre>
--   runOurPool . runAsync . runObject "a box" $ do
--     async_read &lt;- readFull
--     liftIO $ putStrLn "Request is in flight!"
--     either_error_or_read &lt;- look async_read
--     either (liftIO . throwIO) BS.putStrLn  either_error_or_read
--   </pre>
look :: (MonadIO m, Typeable a) => AsyncRead a -> m (Either RadosError a)

-- | Run an action within the 'Object m' monad, where m is the caller's
--   context.
--   
--   <pre>
--   (runOurPool . runObject "an oid" :: Object Pool a -&gt; IO a
--   (runOurPool . runAsync . runObject "an oid") :: Object Async a -&gt; IO a
--   </pre>
runObject :: PoolReader m => ByteString -> Object m a -> m a

-- | Perform an action with an exclusive lock.
withExclusiveLock :: ByteString -> ByteString -> ByteString -> Maybe Double -> Pool a -> Pool a

-- | Perform an action with an shared lock.
withSharedLock :: ByteString -> ByteString -> ByteString -> ByteString -> Maybe Double -> Pool a -> Pool a

-- | The result of a <a>stat</a>, access the contents with
--   <a>modifyTime</a> and <a>fileSize</a>
data StatResult
fileSize :: StatResult -> Word64
modifyTime :: StatResult -> EpochTime

-- | A read request in flight, access the contents of the read with
--   <a>look</a>
data AsyncRead a

-- | A write request in flight, access a possible error with
--   <a>waitSafe</a>
data AsyncWrite
data Connection a
data Pool a
data Object parent a
data Async a

-- | An error indicated by librados, usually in the form of a negative
--   return value
data RadosError
Unknown :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String

-- | Usually returned if a file does not exist
NoEntity :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String

-- | Returned if a file already exists, and should not.
Exists :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String

-- | Returned in the event of a failed atomic transaction
Canceled :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String

-- | A value was out of range, returned when reading or writing from/to
--   invalid regions.
Range :: Int -> String -> String -> RadosError

-- | Error number (positive)
errno :: RadosError -> Int

-- | The underlying C function
cFunction :: RadosError -> String

-- | The "nice" error message.
strerror :: RadosError -> String
User :: String -> RadosError
message :: RadosError -> String

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a
instance Typeable StatResult
instance Functor Connection
instance Applicative Connection
instance Monad Connection
instance MonadIO Connection
instance MonadReader Connection Connection
instance Functor Pool
instance Applicative Pool
instance Monad Pool
instance MonadIO Pool
instance MonadReader IOContext Pool
instance Functor parent => Functor (Object parent)
instance Applicative parent => Applicative (Object parent)
instance Monad parent => Monad (Object parent)
instance MonadIO parent => MonadIO (Object parent)
instance Monad parent => MonadReader ByteString (Object parent)
instance Functor Async
instance Applicative Async
instance Monad Async
instance MonadIO Async
instance MonadReader IOContext Async
instance RadosReader (Object Async) AsyncRead
instance RadosReader (Object Pool) (Either RadosError)
instance RadosWriter (Object Async) AsyncWrite
instance RadosWriter (Object Pool) (Maybe RadosError)
instance PoolReader Pool
instance PoolReader Async
