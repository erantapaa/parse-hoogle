-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A list-like type for lazy sequences, with a user-defined termination value.
--   
--   A list-like type for lazy sequences, with a user-defined termination
--   value.
@package capped-list
@version 1.2


-- | A list-like type for lazy sequences, with a user-defined termination
--   value.
--   
--   This module uses common names and so is designed to be imported
--   qualified:
--   
--   <pre>
--   import qualified Data.CappedList as CL
--   </pre>
module Data.CappedList

-- | A list-like type for lazy sequences, with a user-defined termination
--   value.
data CappedList cap a
Next :: a -> (CappedList cap a) -> CappedList cap a
Cap :: cap -> CappedList cap a

-- | Convert a capped list to a standard list.
--   
--   The cap is returned in the first value of the result tuple.
toList :: CappedList cap a -> (cap, [a])

-- | Convert a capped list to a standard list, discarding the cap.
toList_ :: CappedList cap a -> [a]

-- | Convert a standard list and cap to a capped list.
fromList :: [a] -> cap -> CappedList cap a

-- | Like the standard <a>null</a> function.
null :: CappedList cap a -> Bool

-- | Like the standard <a>++</a> function.
appendR :: CappedList cap1 a -> CappedList cap2 a -> (cap1, CappedList cap2 a)

-- | Like the standard <a>++</a> function.
appendL :: CappedList cap1 a -> CappedList cap2 a -> (cap2, CappedList cap1 a)

-- | Like the standard <a>++</a> function.
--   
--   The first list's "cap" will be discarded; to preserve the cap, use
--   <a>appendR</a>.
appendR_ :: CappedList cap1 a -> CappedList cap2 a -> CappedList cap2 a

-- | Like the standard <a>++</a> function.
--   
--   The second list's "cap" will be discarded; to preserve the cap, use
--   <a>appendL</a>.
appendL_ :: CappedList cap1 a -> CappedList cap2 a -> CappedList cap1 a

-- | Append two capped lists, merging the caps together using a
--   user-provided function.
appendWith :: (c -> d -> e) -> CappedList c a -> CappedList d a -> CappedList e a

-- | Like the standard <a>map</a> function.
map :: (a -> b) -> CappedList cap a -> CappedList cap b

-- | Like the standard <a>map</a> function, but the mapping function may
--   return a capping value.
mapEither :: (a -> Either cap b) -> CappedList cap a -> CappedList cap b

-- | Like the standard <a>concatMap</a> function.
concatMapM :: Monoid cap => (a -> CappedList cap b) -> CappedList cap a -> CappedList cap b

-- | Like the standard <a>foldr</a> function, but accepting an extra
--   parameter to handle <a>Cap</a> values.
foldr :: (a -> b -> b) -> (cap -> b) -> CappedList cap a -> b

-- | Like the standard <a>foldl</a> function, but accepting an extra
--   parameter to handle <a>Cap</a> values.
foldl :: (b -> a -> b) -> (cap -> b) -> CappedList cap a -> b

-- | Like the standard <tt>Data.List.unfoldr</tt> function, but the step
--   function must return a cap to terminate the unfold.
unfoldr :: (b -> Either cap (a, b)) -> b -> CappedList cap a

-- | Like the standard <a>length</a> function; <a>Cap</a> is considered
--   0-length.
length :: CappedList cap a -> Int
instance Typeable2 CappedList
instance (Eq cap, Eq a) => Eq (CappedList cap a)
instance (Show cap, Show a) => Show (CappedList cap a)
instance (Data cap, Data a) => Data (CappedList cap a)
instance Monoid cap => MonadFix (CappedList cap)
instance Monoid cap => Traversable (CappedList cap)
instance Monoid cap => Foldable (CappedList cap)
instance Monoid cap => Alternative (CappedList cap)
instance Monoid cap => Applicative (CappedList cap)
instance Monoid cap => MonadPlus (CappedList cap)
instance Monoid cap => Monad (CappedList cap)
instance Monoid cap => Monoid (CappedList cap a)
instance Functor (CappedList cap)
