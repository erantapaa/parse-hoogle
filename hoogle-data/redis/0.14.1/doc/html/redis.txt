-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A driver for Redis key-value database
--   
@package redis
@version 0.14.1

module Database.Redis.ByteStringClass

-- | Utility class for conversion to and from Strict ByteString
class BS a
toBS :: BS a => a -> ByteString
fromBS :: BS a => ByteString -> a
instance BS ()
instance BS Double
instance BS Int
instance BS String
instance BS Char
instance BS ByteString
instance BS ByteString


-- | Main Redis API and protocol implementation
module Database.Redis.Redis

-- | Redis connection descriptor
data Redis

-- | Redis reply variants
data Reply s

-- | Timeout. Currently unused
RTimeout :: Reply s

-- | Error converting value from ByteString. It's a client-side error.
RParseError :: String -> Reply s

-- | "Ok" reply
ROk :: Reply s

-- | Reply for the ping command
RPong :: Reply s

-- | Used inside multi-exec block
RQueued :: Reply s

-- | Some kind of server-side error
RError :: String -> Reply s

-- | Simple oneline reply
RInline :: s -> Reply s

-- | Integer reply
RInt :: Int -> Reply s

-- | Multiline reply
RBulk :: (Maybe s) -> Reply s

-- | Complex reply. It may consists of various type of replys
RMulti :: (Maybe [Reply s]) -> Reply s
data Message s

-- | subscribed
MSubscribe :: s -> Int -> Message s

-- | unsubscribed
MUnsubscribe :: s -> Int -> Message s

-- | pattern subscribed
MPSubscribe :: s -> Int -> Message s

-- | pattern unsubscribed
MPUnsubscribe :: s -> Int -> Message s

-- | message recieved
MMessage :: s -> s -> Message s

-- | message recieved by pattern
MPMessage :: s -> s -> s -> Message s
data LInsertDirection
BEFORE :: LInsertDirection
AFTER :: LInsertDirection

-- | Interval representation
data Interval a

-- | closed interval [a, b]
Closed :: a -> a -> Interval a

-- | open interval (a, b)
Open :: a -> a -> Interval a

-- | left-open interval (a, b]
LeftOpen :: a -> a -> Interval a

-- | right-open interval [a, b)
RightOpen :: a -> a -> Interval a

-- | Class for conversion value to <a>Interval</a>
--   
--   Definied instances is:
--   
--   <ul>
--   <li>the Interval itself</li>
--   <li>pair (a,b) for open interval</li>
--   <li>two-member list [a, b] for closed interval (throws runtime error
--   if the list length is different)</li>
--   </ul>
class IsInterval i a | i -> a
toInterval :: IsInterval i a => i -> Interval a

-- | Options data type for the <a>sort</a> command
data SortOptions s
SortOptions :: Bool -> (Int, Int) -> Bool -> s -> [s] -> s -> SortOptions s

-- | sort with descending order
desc :: SortOptions s -> Bool

-- | return (from, to) elements
limit :: SortOptions s -> (Int, Int)

-- | sort alphabetically
alpha :: SortOptions s -> Bool

-- | sort by value from this key
sort_by :: SortOptions s -> s

-- | return this keys values
get_obj :: SortOptions s -> [s]

-- | store result to this key
store :: SortOptions s -> s
data Aggregate
SUM :: Aggregate
MIN :: Aggregate
MAX :: Aggregate
data RedisKeyType
RTNone :: RedisKeyType
RTString :: RedisKeyType
RTList :: RedisKeyType
RTSet :: RedisKeyType
RTZSet :: RedisKeyType
RTHash :: RedisKeyType
type RedisInfo = Map String String

-- | Default options for the <a>sort</a> command
sortDefaults :: SortOptions ByteString

-- | Unwraps RInline reply.
--   
--   Throws an exception when called with something different from RInline
fromRInline :: (Monad m, BS s) => Reply s -> m s

-- | Unwraps RBulk reply.
--   
--   Throws an exception when called with something different from RBulk
fromRBulk :: (Monad m, BS s) => Reply s -> m (Maybe s)

-- | The same as fromRBulk but with fromJust applied
fromRBulk' :: (Monad m, BS s) => Reply s -> m s

-- | Unwraps RMulti reply
--   
--   Throws an exception when called with something different from RMulti
fromRMulti :: (Monad m, BS s) => Reply s -> m (Maybe [Reply s])

-- | Unwraps RMulti reply filled with RBulk
--   
--   Throws an exception when called with something different from RMulti
fromRMultiBulk :: (Monad m, BS s) => Reply s -> m (Maybe [Maybe s])

-- | The same as fromRMultiBulk but with fromJust applied
fromRMultiBulk' :: (Monad m, BS s) => Reply s -> m [s]

-- | Unwraps RInt reply
--   
--   Throws an exception when called with something different from RInt
fromRInt :: (Monad m, BS s) => Reply s -> m Int

-- | Unwraps ROk reply
--   
--   Throws an exception when called with something different from ROk
fromROk :: (Monad m, BS s) => Reply s -> m ()

-- | Unwraps every non-error reply
--   
--   Throws an exception when called with something different from RMulti
noError :: (Monad m, BS s) => Reply s -> m ()

-- | Parse Reply as a Message
--   
--   Throws an exception on parse error
parseMessage :: (Monad m, BS s) => Reply ByteString -> m (Message s)

-- | a (0, -1) range - takes all element from a list in lrange, zrange and
--   so on
takeAll :: (Int, Int)

-- | just a localhost
localhost :: String

-- | default Redis port
defaultPort :: String

-- | Conects to Redis server and returns connection descriptor
connect :: String -> String -> IO Redis

-- | Close connection
disconnect :: Redis -> IO ()

-- | Returns True when connection handler is opened
isConnected :: Redis -> IO Bool

-- | Returns connection host and port
getServer :: Redis -> IO (String, String)

-- | Returns currently selected database
getDatabase :: Redis -> IO Int

-- | Adds command to renaming map
renameCommand :: Redis -> ByteString -> ByteString -> IO ()

-- | ping - pong
--   
--   RPong returned if no errors happends
ping :: Redis -> IO (Reply ())

-- | Password authentication
--   
--   ROk returned
auth :: BS s => Redis -> s -> IO (Reply ())

-- | Echo the given string
--   
--   RBulk returned
echo :: BS s => Redis -> s -> IO (Reply s)

-- | Quit and close connection
quit :: Redis -> IO ()

-- | Stop all the clients, save the DB, then quit the server
shutdown :: Redis -> IO ()

-- | Begin the multi-exec block
--   
--   ROk returned
multi :: Redis -> IO (Reply ())

-- | Execute queued commands
--   
--   RMulti returned - replies for all executed commands
exec :: BS s => Redis -> IO (Reply s)

-- | Discard queued commands without execution
--   
--   ROk returned
discard :: Redis -> IO (Reply ())

-- | Run commands within multi-exec block
--   
--   RMulti returned - replies for all executed commands
run_multi :: BS s => Redis -> (Redis -> IO ()) -> IO (Reply s)

-- | Add keys to a watch list for Check-and-Set operation.
--   
--   For more information see <a>http://redis.io/topics/transactions</a>
--   
--   ROk returned
watch :: BS s => Redis -> [s] -> IO (Reply ())

-- | Force unwatch all watched keys
--   
--   For more information see <a>http://redis.io/topics/transactions</a>
--   
--   ROk returned
unwatch :: Redis -> IO (Reply ())

-- | Run actions in a CAS manner
--   
--   You have to explicitly add multi/exec commands to an appropriate place
--   in an action sequence. Command sequence will be explicitly terminated
--   with <i>unwatch</i> command even if <i>exec</i> command was sent.
--   
--   Result of user-defined action returned
run_cas :: BS s1 => Redis -> [s1] -> (Redis -> IO a) -> IO a

-- | Test if the key exists
--   
--   (RInt 1) returned if the key exists and (RInt 0) otherwise
exists :: BS s => Redis -> s -> IO (Reply Int)

-- | Remove the key
--   
--   (RInt 0) returned if no keys were removed or (RInt n) with removed
--   keys count
del :: BS s => Redis -> s -> IO (Reply Int)

-- | Variadic form of DEL
--   
--   RInt returned - number of deleted keys
del_ :: BS s => Redis -> [s] -> IO (Reply Int)

-- | Return the type of the value stored at key in form of a string
--   
--   RedisKeyType returned
getType :: BS s => Redis -> s -> IO RedisKeyType

-- | Returns all the keys matching the glob-style pattern
--   
--   RMulti filled with RBulk returned
keys :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Return random key name
--   
--   RBulk returned
randomKey :: BS s => Redis -> IO (Reply s)

-- | Rename the key. If key with that name exists it'll be overwritten.
--   
--   ROk returned
rename :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply ())

-- | Rename the key if no keys with destination name exists.
--   
--   (RInt 1) returned if key was renamed and (RInt 0) otherwise
renameNx :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Get the number of keys in the currently selected database
--   
--   RInt returned
dbsize :: Redis -> IO (Reply Int)

-- | Set an expiration timeout in seconds on the specified key.
--   
--   For more information see <a>http://redis.io/commands/expire</a>
--   
--   (RInt 1) returned if timeout was set and (RInt 0) otherwise
expire :: BS s => Redis -> s -> Int -> IO (Reply Int)

-- | Set an expiration time in form of UNIX timestamp on the specified key
--   
--   For more information see <a>http://redis.io/commands/expireat</a>
--   
--   (RInt 1) returned if timeout was set and (RInt 0) otherwise
expireAt :: BS s => Redis -> s -> Int -> IO (Reply Int)

-- | Remove the timeout from a key
--   
--   (RInt 1) returned if the timeout was removed and (RInt 0) otherwise
persist :: BS s => Redis -> s -> IO (Reply Int)

-- | Return the remining time to live of the key or -1 if key has no
--   associated timeout
--   
--   RInt returned
ttl :: BS s => Redis -> s -> IO (Reply Int)

-- | Select the DB with the specified zero-based numeric index
--   
--   ROk returned
select :: Redis -> Int -> IO (Reply ())

-- | Move the specified key from the currently selected DB to the specified
--   destination DB. If such a key is already exists in the target DB no
--   data modification performed.
--   
--   (RInt 1) returned if the key was moved and (RInt 0) otherwise
move :: BS s => Redis -> s -> Int -> IO (Reply Int)

-- | Delete all the keys of the currently selected DB
--   
--   ROk returned
flushDb :: Redis -> IO (Reply ())

-- | Delete all the keys of all the existing databases
--   
--   ROk returned
flushAll :: Redis -> IO (Reply ())

-- | Returns different information and statistics about the server
--   
--   for more information see <a>http://redis.io/commands/info</a>
--   
--   <a>RedisInfo</a> returned
info :: Redis -> IO RedisInfo

-- | Set the string value as value of the key
--   
--   ROk returned
set :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply ())

-- | Set the key value if key does not exists
--   
--   (RInt 1) returned if key was set and (RInt 0) otherwise
setNx :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Atomically sets target key value and assigns expiration time. The same
--   as <i>multi; set key val; expire key seconds; exec</i> but faster.
--   
--   Arguments order is the same as in Redis protocol.
--   
--   ROk returned
setEx :: (BS s1, BS s2) => Redis -> s1 -> Int -> s2 -> IO (Reply ())

-- | Atomically set multiple keys
--   
--   ROk returned
mSet :: (BS s1, BS s2) => Redis -> [(s1, s2)] -> IO (Reply ())

-- | Atomically set multiple keys if none of them exists.
--   
--   (RInt 1) returned if all keys was set and (RInt 0) otherwise
mSetNx :: (BS s1, BS s2) => Redis -> [(s1, s2)] -> IO (Reply Int)

-- | Get the value of the specified key.
--   
--   RBulk returned
get :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Atomically set this value and return the old value
--   
--   RBulk returned
getSet :: (BS s1, BS s2, BS s3) => Redis -> s1 -> s2 -> IO (Reply s3)

-- | Get the values of all specified keys
--   
--   RMulti filled with RBulk replies returned
mGet :: (BS s1, BS s2) => Redis -> [s1] -> IO (Reply s2)

-- | Increment the key value by one
--   
--   RInt returned with new key value
incr :: BS s => Redis -> s -> IO (Reply Int)

-- | Increment the key value by N
--   
--   RInt returned with new key value
incrBy :: BS s => Redis -> s -> Int -> IO (Reply Int)

-- | Increment the key value by N
--   
--   (RBulk Double) returned with new key value
incrByFloat :: BS s => Redis -> s -> Double -> IO (Reply Double)

-- | Decrement the key value by one
--   
--   RInt returned with new key value
decr :: BS s => Redis -> s -> IO (Reply Int)

-- | Decrement the key value by N
--   
--   RInt returned with new key value
decrBy :: BS s => Redis -> s -> Int -> IO (Reply Int)

-- | Append string to the string-typed key
--   
--   RInt returned - the length of resulting string
append :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Returns the substring of the string value stored at key, determined by
--   the offsets start and end (both are inclusive). Negative offsets can
--   be used in order to provide an offset starting from the end of the
--   string.
--   
--   RBulk returned
substr :: (BS s1, BS s2) => Redis -> s1 -> (Int, Int) -> IO (Reply s2)

-- | Returns the substring of the string value stored at key, determined by
--   the offsets start and end (both are inclusive). Negative offsets can
--   be used in order to provide an offset starting from the end of the
--   string.
--   
--   RBulk returned
getrange :: (BS s1, BS s2) => Redis -> s1 -> (Int, Int) -> IO (Reply s2)

-- | Overwrites part of the string stored at key, starting at the specified
--   offset, for the entire length of value. If the offset is larger than
--   the current length of the string at key, the string is padded with
--   zero-bytes to make offset fit. Non-existing keys are considered as
--   empty strings, so this command will make sure it holds a string large
--   enough to be able to set value at offset.
--   
--   RInt returned - resulting string length.
setrange :: (BS s1, BS s2) => Redis -> s1 -> Int -> s2 -> IO (Reply Int)

-- | Returns the bit value at offset in the string value stored at key.
--   When offset is beyond the string length, the string is assumed to be a
--   contiguous space with 0 bits. When key does not exist it is assumed to
--   be an empty string, so offset is always out of range and the value is
--   also assumed to be a contiguous space with 0 bits.
--   
--   RInt returned
getbit :: BS s => Redis -> s -> Int -> IO (Reply Int)

-- | Sets or clears the bit at offset in the string value stored at key.
--   For more information see <a>http://redis.io/commands/setbit</a>
--   
--   RInt returned - the original bit value stored at offset.
setbit :: BS s => Redis -> s -> Int -> Int -> IO (Reply Int)

-- | Returns a length of a string-typed key
--   
--   RInt returned
strlen :: BS s => Redis -> s -> IO (Reply Int)

-- | Add string value to the tail of the list-type key. New list length
--   returned
--   
--   RInt returned
rpush :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Variadic form of rpush
--   
--   RInt returned
rpush_ :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> IO (Reply Int)

-- | Add string value to the head of the list-type key. New list length
--   returned
--   
--   RInt returned
lpush :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Variadic form of LPUSH
--   
--   RInt returned
lpush_ :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> IO (Reply Int)

-- | Add string value to the tail of existing list-type key. New list
--   length returned. If such a key was not exists, list is not created and
--   (RInt 0) returned.
--   
--   RInt returned
rpushx :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Add string value to the head of existing list-type key. New list
--   length returned. If such a key was not exists, list is not created and
--   (RInt 0) returned.
--   
--   RInt returned
lpushx :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Inserts value in the list stored at key either before or after the
--   reference value pivot.
--   
--   RInt returned - resulting list length or (RInt -1) if target element
--   was not found.
linsert :: (BS s1, BS s2, BS s3) => Redis -> s1 -> LInsertDirection -> s2 -> s3 -> IO (Reply Int)

-- | Return lenght of the list. Note that for not-existing keys it returns
--   zero length.
--   
--   RInt returned or RError if key is not a list
llen :: BS s => Redis -> s -> IO (Reply Int)

-- | Return the specified range of list elements. List indexed from 0 to
--   (llen - 1). lrange returns slice including "from" and "to" elements,
--   eg. lrange 0 2 will return the first three elements of the list.
--   
--   Parameters "from" and "to" may also be negative. If so it will counts
--   as offset from end ot the list. eg. -1 - is the last element of the
--   list, -2 - is the second from the end and so on.
--   
--   RMulti filled with RBulk returned
lrange :: (BS s1, BS s2) => Redis -> s1 -> (Int, Int) -> IO (Reply s2)

-- | Trim list so that it will contain only the specified range of
--   elements.
--   
--   ROk returned
ltrim :: BS s => Redis -> s -> (Int, Int) -> IO (Reply ())

-- | Return the specified element of the list by its index
--   
--   RBulk returned
lindex :: (BS s1, BS s2) => Redis -> s1 -> Int -> IO (Reply s2)

-- | Set the list's value indexed by an <i>index</i> to the new value
--   
--   ROk returned if element was set and RError if index is out of range or
--   key is not a list
lset :: (BS s1, BS s2) => Redis -> s1 -> Int -> s2 -> IO (Reply ())

-- | Remove the first <i>count</i> occurrences of the <i>value</i> element
--   from the list
--   
--   RInt returned - the number of elements removed
lrem :: (BS s1, BS s2) => Redis -> s1 -> Int -> s2 -> IO (Reply Int)

-- | Atomically return and remove the first element of the list
--   
--   RBulk returned
lpop :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Atomically return and remove the last element of the list
--   
--   RBulk returned
rpop :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Atomically return and remove the last (tail) element of the source
--   list, and push the element as the first (head) element of the
--   destination list
--   
--   RBulk returned
rpoplpush :: (BS s1, BS s2, BS s3) => Redis -> s1 -> s2 -> IO (Reply s3)

-- | Blocking lpop
--   
--   For more information see <a>http://redis.io/commands/blpop</a>
--   
--   Return (Just (key, value)) if <i>value</i> was successfully popped
--   from <i>key</i> list or Nothing of timeout exceeded.
blpop :: (BS s1, BS s2) => Redis -> [s1] -> Int -> IO (Maybe (s1, s2))

-- | Blocking rpop
--   
--   For more information see <a>http://redis.io/commands/brpop</a>
--   
--   Return (Just (key, value)) if <i>value</i> was successfully popped
--   from <i>key</i> list or Nothing of timeout exceeded.
brpop :: (BS s1, BS s2) => Redis -> [s1] -> Int -> IO (Maybe (s1, s2))

-- | Blocking rpoplpush
--   
--   For more information see <a>http://redis.io/commands/brpoplpush</a>
--   
--   Return (Just $ Maybe value) if value was successfully popped or
--   Nothing if timeout exceeded.
brpoplpush :: (BS s1, BS s2, BS s3) => Redis -> s1 -> s2 -> Int -> IO (Maybe (Maybe s3))

-- | Add the specified member to the set value stored at key
--   
--   (RInt 1) returned if element was added and (RInt 0) if element was
--   already a member of the set
sadd :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Variadic form of SADD
--   
--   RInt returned - number of actualy added elements
sadd_ :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> IO (Reply Int)

-- | Remove the specified member from the set value stored at key
--   
--   (RInt 1) returned if element was removed and (RInt 0) if element is
--   not a member of the set
srem :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Variadic form of SREM
--   
--   RInt returned - number of removed values
srem_ :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> IO (Reply Int)

-- | Remove a random element from a Set returning it as return value
--   
--   RBulk returned
spop :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Move the specifided member from one set to another
--   
--   (RInt 1) returned if element was moved and (RInt 0) if element is not
--   a member of the source set
smove :: (BS s1, BS s2, BS s3) => Redis -> s1 -> s2 -> s3 -> IO (Reply Int)

-- | Return the number of elements of the set. If key doesn't exists 0
--   returned.
--   
--   RInt returned
scard :: BS s => Redis -> s -> IO (Reply Int)

-- | Test if element is member of the set. If key doesn't exists 0
--   returned.
--   
--   (RInt 1) returned if element is member of the set and (RInt 0)
--   otherwise
sismember :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Return all the members (elements) of the set
--   
--   RMulti filled with RBulk returned
smembers :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Return a random element from a set
--   
--   RBulk returned
srandmember :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Return the members of a set resulting from the intersection of all the
--   specifided sets
--   
--   RMulti filled with RBulk returned
sinter :: (BS s1, BS s2) => Redis -> [s1] -> IO (Reply s2)

-- | The same as <a>sinter</a> but instead of being returned the resulting
--   set is stored
--   
--   RInt returned - resulting set cardinality.
sinterStore :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> IO (Reply ())

-- | Return the members of a set resulting from the union of all the
--   specifided sets
--   
--   RMulti filled with RBulk returned
sunion :: (BS s1, BS s2) => Redis -> [s1] -> IO (Reply s2)

-- | The same as <a>sunion</a> but instead of being returned the resulting
--   set is stored
--   
--   RInt returned - resulting set cardinality.
sunionStore :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> IO (Reply ())

-- | Return the members of a set resulting from the difference between the
--   first set provided and all the successive sets
--   
--   RMulti filled with RBulk returned
sdiff :: (BS s1, BS s2) => Redis -> [s1] -> IO (Reply s2)

-- | The same as <a>sdiff</a> but instead of being returned the resulting
--   set is stored
--   
--   RInt returned - resulting set cardinality.
sdiffStore :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> IO (Reply ())

-- | Add the specified member having the specifeid score to the sorted set
--   
--   (RInt 1) returned if new element was added and (RInt 0) if that
--   element was already a member of the sortet set and the score was
--   updated
zadd :: (BS s1, BS s2) => Redis -> s1 -> Double -> s2 -> IO (Reply Int)

-- | Variadic form of zadd
--   
--   RInt returned - the number of elements actually added. Not including
--   elements which scores was just updated.
zadd_ :: (BS s1, BS s2) => Redis -> s1 -> [(Double, s2)] -> IO (Reply Int)

-- | Remove the specified member from the sorted set
--   
--   (RInt 1) returned if element was removed and (RInt 0) if element was
--   not a member of the sorted set
zrem :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Variadic form of zrem RInt returned - the number of removed elements
zrem_ :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> IO (Reply Int)

-- | If <i>member</i> already in the sorted set adds the <i>increment</i>
--   to its score and updates the position of the element in the sorted set
--   accordingly. If member does not exist in the sorted set it is added
--   with increment as score (that is, like if the previous score was
--   virtually zero). The new score of the member is returned.
--   
--   RBulk returned
zincrBy :: (BS s1, BS s2, BS s3) => Redis -> s1 -> Double -> s2 -> IO (Reply s3)

-- | Return the specified elements of the sorted set. Start and end are
--   zero-based indexes. WITHSCORES paramenter indicates if it's needed to
--   return elements with its scores or not. If WITHSCORES is True then the
--   resulting list will be composed of value1, score1, value2, score2 and
--   so on.
--   
--   RMulti filled with RBulk returned
zrange :: (BS s1, BS s2) => Redis -> s1 -> (Int, Int) -> Bool -> IO (Reply s2)

-- | Return the specified elements of the sorted set at the specified key.
--   The elements are considered sorted from the highest to the lowerest
--   score
--   
--   RMulti filled with RBulk returned
zrevrange :: (BS s1, BS s2) => Redis -> s1 -> (Int, Int) -> Bool -> IO (Reply s2)

-- | Return the all the elements in the sorted set with a score that lays
--   within a given interval
--   
--   RMulti filled with RBulk returned
zrangebyscore :: (IsInterval i Double, BS s1, BS s2) => Redis -> s1 -> i -> Maybe (Int, Int) -> Bool -> IO (Reply s2)

-- | Return the all the elements in the sorted set with a score that lays
--   within a given interval. Elements is ordered from greater score to
--   lower. Interval passed into command must be reversed (first value is
--   greater then second)
--   
--   RMulti filled with RBulk returned
zrevrangebyscore :: (IsInterval i Double, BS s1, BS s2) => Redis -> s1 -> i -> Maybe (Int, Int) -> Bool -> IO (Reply s2)

-- | Count a number of elements of the sorted set with a score that lays
--   within a given interval
--   
--   RInt returned
zcount :: (IsInterval i Double, BS s) => Redis -> s -> i -> IO (Reply Int)

-- | Remove all the elements in the sorted set with a score that lays
--   within a given interval. For now this command doesn't supports open
--   and semi-open intervals
--   
--   RInt returned - the number of elements removed
zremrangebyscore :: BS s => Redis -> s -> (Double, Double) -> IO (Reply Int)

-- | Return the sorted set cardinality (number of elements)
--   
--   RInt returned
zcard :: BS s => Redis -> s -> IO (Reply Int)

-- | Return the score of the specified element of the sorted set
--   
--   RBulk returned
zscore :: (BS s1, BS s2, BS s3) => Redis -> s1 -> s2 -> IO (Reply s3)

-- | Returns the rank of member in the sorted set stored at key, with the
--   scores ordered from low to high.
--   
--   RInt returned or (RBulk Nothing) if value is not found in set.
zrank :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Returns the rank of member in the sorted set stored at key, with the
--   scores ordered from high to low.
--   
--   RInt returned or (RBulk Nothing) if value is not found in set.
zrevrank :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Remove elements from the sorted set with rank lays within a given
--   interval.
--   
--   RInt returned - the number of elements removed
zremrangebyrank :: BS s => Redis -> s -> (Int, Int) -> IO (Reply Int)

-- | <i>Deprecated: ZUNION command was renamed to ZUNIONSTORE</i>
zunion :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> [Double] -> Aggregate -> IO (Reply Int)

-- | <i>Deprecated: ZINTER command was renamed to ZINTERSTORE</i>
zinter :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> [Double] -> Aggregate -> IO (Reply Int)

-- | Create a union of provided sorted sets and store it at
--   <i>destination</i> key
--   
--   If <i>weights</i> is not null then scores of sorted sets used with
--   corresponding weights. If so lenght of <i>weights</i> must be the same
--   as length of <i>sources</i>.
--   
--   <i>Aggregate</i> is an option how to aggregate resulting scores.
--   
--   RInt returned - the number of elements in the resulting set.
zunionStore :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> [Double] -> Aggregate -> IO (Reply Int)

-- | Create an intersectoin of provided sorted sets and store it at
--   destination key
--   
--   If <i>weights</i> is not null then scores of sorted sets used with
--   corresponding weights. If so lenght of <i>weights</i> must be the same
--   as length of <i>sources</i>.
--   
--   Aggregate is an option how to aggregate resulting scores.
--   
--   RInt returned - the number of elements in the resulting set.
zinterStore :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> [Double] -> Aggregate -> IO (Reply Int)

-- | Set the specified hash field to the specified value
--   
--   (RInt 0 returned if field value was updated and (RInt 1) if new field
--   created
hset :: (BS s1, BS s2, BS s3) => Redis -> s1 -> s2 -> s3 -> IO (Reply Int)

-- | Return value associated with specified field from hash
--   
--   RBulk returned
hget :: (BS s1, BS s2, BS s3) => Redis -> s1 -> s2 -> IO (Reply s3)

-- | Remove field from a hash
--   
--   (RInt 1) returned if field was removed and (RInt 0) otherwise
hdel :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Variadic form of HDEL
--   
--   RInt returned - number of fields deleted
hdel_ :: (BS s1, BS s2) => Redis -> s1 -> [s2] -> IO (Reply Int)

-- | Atomically sets multiple fields within a hash-typed key
--   
--   ROk returned
hmset :: (BS s1, BS s2, BS s3) => Redis -> s1 -> [(s2, s3)] -> IO (Reply ())

-- | Get the values of all specified fields from the hash-typed key
--   
--   RMulti filled with RBulk replies returned
hmget :: (BS s1, BS s2, BS s3) => Redis -> s1 -> [s2] -> IO (Reply s3)

-- | Increment the field value within a hash by N
--   
--   RInt returned with new key value
hincrBy :: (BS s1, BS s2) => Redis -> s1 -> s2 -> Int -> IO (Reply Int)

-- | Increment the field value within a hash by N
--   
--   (RBulk Double) returned with new key value
hincrByFloat :: (BS s1, BS s2) => Redis -> s1 -> s2 -> Double -> IO (Reply Double)

-- | Test if hash contains the specified field
--   
--   (RInt 1) returned if fiels exists and (RInt 0) otherwise
hexists :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Return the number of fields contained in the specified hash
--   
--   RInt returned
hlen :: BS s => Redis -> s -> IO (Reply Int)

-- | Return all the field names the hash holding
--   
--   RMulti field with RBulk returned
hkeys :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Return all the associated values the hash holding
--   
--   RMulti field with RBulk returned
hvals :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Return all the field names and associated values the hash holding in
--   form of <i>[field1, value1, field2, value2...]</i>
--   
--   RMulti field with RBulk returned. If key doesn't exists (RMulti [])
--   returned.
hgetall :: (BS s1, BS s2) => Redis -> s1 -> IO (Reply s2)

-- | Sort the elements contained in the List, Set, or Sorted Set
--   
--   for more information see <a>http://redis.io/commands/sort</a>
--   
--   RMulti filled with RBulk returned
sort :: (BS s1, BS s2, BS s3) => Redis -> s1 -> SortOptions s2 -> IO (Reply s3)

-- | Shortcut for the <a>sort</a> with some <a>get_obj</a> and constant
--   <a>sort_by</a> options
--   
--   RMulti filled with RBulk returned
listRelated :: (BS s1, BS s2, BS s3) => Redis -> s1 -> s2 -> (Int, Int) -> IO (Reply s3)

-- | Get a number of subscribed channels on this connection
--   
--   It doesn't run any redis commands, number of subscribtions is taken
--   from internal connection state
subscribed :: Redis -> IO Int

-- | Subscribe to channels
--   
--   list of Message with subscribtion information returned
subscribe :: (BS s1, BS s2) => Redis -> [s1] -> IO [Message s2]

-- | Unsubscribe from channels. If called with an empty list then
--   unsubscribe all channels
--   
--   list of Message with subscribtion information returned
unsubscribe :: (BS s1, BS s2) => Redis -> [s1] -> IO [Message s2]

-- | Subscribe to patterns
--   
--   list of Message with subscribtion information returned
psubscribe :: (BS s1, BS s2) => Redis -> [s1] -> IO [Message s2]

-- | Unsubscribe from patterns. If called with an empty list then
--   unsubscribe all patterns
--   
--   list of Message with subscribtion information returned
punsubscribe :: (BS s1, BS s2) => Redis -> [s1] -> IO [Message s2]

-- | Publish message to target channel
--   
--   RInt returned - a number of clients that recieves the message
publish :: (BS s1, BS s2) => Redis -> s1 -> s2 -> IO (Reply Int)

-- | Wait for a messages.
--   
--   Just Message returned or Nothing if timeout exceeded
listen :: BS s => Redis -> Int -> IO (Maybe (Message s))

-- | Save the whole dataset on disk
--   
--   ROk returned
save :: Redis -> IO (Reply ())

-- | Save the DB in background
--   
--   ROk returned
bgsave :: Redis -> IO (Reply ())

-- | Return the UNIX TIME of the last DB save executed with success
--   
--   RInt returned
lastsave :: Redis -> IO (Reply Int)

-- | Rewrites the Append Only File in background
--   
--   ROk returned
bgrewriteaof :: Redis -> IO (Reply ())
instance Show RedisKeyType
instance Eq RedisKeyType
instance Show LInsertDirection
instance Show a => Show (Interval a)
instance Eq Aggregate
instance Show Aggregate
instance IsInterval [a] a
instance IsInterval (a, a) a
instance IsInterval (Interval a) a


-- | Monadic wrapper for <a>Database.Redis.Redis</a>
module Database.Redis.Monad
class MonadIO m => WithRedis m
getRedis :: WithRedis m => m (Redis)
setRedis :: WithRedis m => Redis -> m ()

-- | Redis connection descriptor
data Redis
Redis :: RLock -> IORef RedisState -> Redis
r_lock :: Redis -> RLock
r_st :: Redis -> IORef RedisState

-- | Redis reply variants
data Reply s

-- | Timeout. Currently unused
RTimeout :: Reply s

-- | Error converting value from ByteString. It's a client-side error.
RParseError :: String -> Reply s

-- | "Ok" reply
ROk :: Reply s

-- | Reply for the ping command
RPong :: Reply s

-- | Used inside multi-exec block
RQueued :: Reply s

-- | Some kind of server-side error
RError :: String -> Reply s

-- | Simple oneline reply
RInline :: s -> Reply s

-- | Integer reply
RInt :: Int -> Reply s

-- | Multiline reply
RBulk :: (Maybe s) -> Reply s

-- | Complex reply. It may consists of various type of replys
RMulti :: (Maybe [Reply s]) -> Reply s
data Message s

-- | subscribed
MSubscribe :: s -> Int -> Message s

-- | unsubscribed
MUnsubscribe :: s -> Int -> Message s

-- | pattern subscribed
MPSubscribe :: s -> Int -> Message s

-- | pattern unsubscribed
MPUnsubscribe :: s -> Int -> Message s

-- | message recieved
MMessage :: s -> s -> Message s

-- | message recieved by pattern
MPMessage :: s -> s -> s -> Message s
data LInsertDirection
BEFORE :: LInsertDirection
AFTER :: LInsertDirection

-- | Interval representation
data Interval a

-- | closed interval [a, b]
Closed :: a -> a -> Interval a

-- | open interval (a, b)
Open :: a -> a -> Interval a

-- | left-open interval (a, b]
LeftOpen :: a -> a -> Interval a

-- | right-open interval [a, b)
RightOpen :: a -> a -> Interval a

-- | Class for conversion value to <a>Interval</a>
--   
--   Definied instances is:
--   
--   <ul>
--   <li>the Interval itself</li>
--   <li>pair (a,b) for open interval</li>
--   <li>two-member list [a, b] for closed interval (throws runtime error
--   if the list length is different)</li>
--   </ul>
class IsInterval i a | i -> a
toInterval :: IsInterval i a => i -> Interval a

-- | Options data type for the <a>sort</a> command
data SortOptions s
SortOptions :: Bool -> (Int, Int) -> Bool -> s -> [s] -> s -> SortOptions s

-- | sort with descending order
desc :: SortOptions s -> Bool

-- | return (from, to) elements
limit :: SortOptions s -> (Int, Int)

-- | sort alphabetically
alpha :: SortOptions s -> Bool

-- | sort by value from this key
sort_by :: SortOptions s -> s

-- | return this keys values
get_obj :: SortOptions s -> [s]

-- | store result to this key
store :: SortOptions s -> s
data Aggregate
SUM :: Aggregate
MIN :: Aggregate
MAX :: Aggregate
data RedisKeyType
type RedisInfo = Map String String

-- | Default options for the <a>sort</a> command
sortDefaults :: SortOptions ByteString

-- | Unwraps RInline reply.
--   
--   Throws an exception when called with something different from RInline
fromRInline :: (Monad m, BS s) => Reply s -> m s

-- | Unwraps RBulk reply.
--   
--   Throws an exception when called with something different from RBulk
fromRBulk :: (Monad m, BS s) => Reply s -> m (Maybe s)

-- | Unwraps RMulti reply
--   
--   Throws an exception when called with something different from RMulti
fromRMulti :: (Monad m, BS s) => Reply s -> m (Maybe [Reply s])

-- | Unwraps RMulti reply filled with RBulk
--   
--   Throws an exception when called with something different from RMulti
fromRMultiBulk :: (Monad m, BS s) => Reply s -> m (Maybe [Maybe s])

-- | The same as fromRMultiBulk but with fromJust applied
fromRMultiBulk' :: (Monad m, BS s) => Reply s -> m [s]

-- | Unwraps RInt reply
--   
--   Throws an exception when called with something different from RInt
fromRInt :: (Monad m, BS s) => Reply s -> m Int

-- | Unwraps ROk reply
--   
--   Throws an exception when called with something different from ROk
fromROk :: (Monad m, BS s) => Reply s -> m ()

-- | Unwraps every non-error reply
--   
--   Throws an exception when called with something different from RMulti
noError :: (Monad m, BS s) => Reply s -> m ()

-- | Parse Reply as a Message
--   
--   Throws an exception on parse error
parseMessage :: (Monad m, BS s) => Reply ByteString -> m (Message s)

-- | a (0, -1) range - takes all element from a list in lrange, zrange and
--   so on
takeAll :: (Int, Int)

-- | just a localhost
localhost :: String

-- | default Redis port
defaultPort :: String
connect :: WithRedis m => String -> String -> m ()
disconnect :: WithRedis m => m ()
isConnected :: WithRedis m => m Bool
getServer :: WithRedis m => m (String, String)
getDatabase :: WithRedis m => m Int
renameCommand :: WithRedis m => ByteString -> ByteString -> m ()
ping :: WithRedis m => m (Reply ())
auth :: WithRedis m => String -> m (Reply ())
echo :: (WithRedis m, BS s) => s -> m (Reply s)
quit :: WithRedis m => m ()
shutdown :: WithRedis m => m ()
multi :: WithRedis m => m (Reply ())
exec :: (WithRedis m, BS s) => m (Reply s)
discard :: WithRedis m => m (Reply ())
run_multi :: (MonadCatch m, MonadMask m, WithRedis m, BS s) => m () -> m (Reply s)
watch :: (WithRedis m, BS s) => [s] -> m (Reply ())
unwatch :: WithRedis m => m (Reply ())
run_cas :: (MonadCatch m, MonadMask m, WithRedis m, BS s1) => [s1] -> m a -> m a
exists :: (WithRedis m, BS s) => s -> m (Reply Int)
del :: (WithRedis m, BS s) => s -> m (Reply Int)
del_ :: (WithRedis m, BS s) => [s] -> m (Reply Int)
getType :: (WithRedis m, BS s1) => s1 -> m RedisKeyType
keys :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
randomKey :: (WithRedis m, BS s) => m (Reply s)
rename :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply ())
renameNx :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
dbsize :: WithRedis m => m (Reply Int)
expire :: (WithRedis m, BS s) => s -> Int -> m (Reply Int)
expireAt :: (WithRedis m, BS s) => s -> Int -> m (Reply Int)
persist :: (WithRedis m, BS s) => s -> m (Reply Int)
ttl :: (WithRedis m, BS s) => s -> m (Reply Int)
select :: WithRedis m => Int -> m (Reply ())
move :: (WithRedis m, BS s) => s -> Int -> m (Reply Int)
flushDb :: WithRedis m => m (Reply ())
flushAll :: WithRedis m => m (Reply ())
info :: WithRedis m => m RedisInfo
set :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply ())
setNx :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
setEx :: (WithRedis m, BS s1, BS s2) => s1 -> Int -> s2 -> m (Reply ())
mSet :: (WithRedis m, BS s1, BS s2) => [(s1, s2)] -> m (Reply ())
mSetNx :: (WithRedis m, BS s1, BS s2) => [(s1, s2)] -> m (Reply Int)
get :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
getSet :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> s2 -> m (Reply s3)
mGet :: (WithRedis m, BS s1, BS s2) => [s1] -> m (Reply s2)
incr :: (WithRedis m, BS s) => s -> m (Reply Int)
incrBy :: (WithRedis m, BS s) => s -> Int -> m (Reply Int)
incrByFloat :: (WithRedis m, BS s) => s -> Double -> m (Reply Double)
decr :: (WithRedis m, BS s) => s -> m (Reply Int)
decrBy :: (WithRedis m, BS s) => s -> Int -> m (Reply Int)
append :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
substr :: (WithRedis m, BS s1, BS s2) => s1 -> (Int, Int) -> m (Reply s2)
getrange :: (WithRedis m, BS s1, BS s2) => s1 -> (Int, Int) -> m (Reply s2)
setrange :: (WithRedis m, BS s1, BS s2) => s1 -> Int -> s2 -> m (Reply Int)
getbit :: (WithRedis m, BS s) => s -> Int -> m (Reply Int)
setbit :: (WithRedis m, BS s) => s -> Int -> Int -> m (Reply Int)
strlen :: (WithRedis m, BS s) => s -> m (Reply Int)
rpush :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
rpush_ :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> m (Reply Int)
lpush :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
rpushx :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
lpushx :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
llen :: (WithRedis m, BS s) => s -> m (Reply Int)
lrange :: (WithRedis m, BS s1, BS s2) => s1 -> (Int, Int) -> m (Reply s2)
ltrim :: (WithRedis m, BS s) => s -> (Int, Int) -> m (Reply ())
lindex :: (WithRedis m, BS s1, BS s2) => s1 -> Int -> m (Reply s2)
lset :: (WithRedis m, BS s1, BS s2) => s1 -> Int -> s2 -> m (Reply ())
lrem :: (WithRedis m, BS s1, BS s2) => s1 -> Int -> s2 -> m (Reply Int)
lpop :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
rpop :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
rpoplpush :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> s2 -> m (Reply s3)
blpop :: (WithRedis m, BS s1, BS s2) => [s1] -> Int -> m (Maybe (s1, s2))
brpop :: (WithRedis m, BS s1, BS s2) => [s1] -> Int -> m (Maybe (s1, s2))
brpoplpush :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> s2 -> Int -> m (Maybe (Maybe s3))
sadd :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
sadd_ :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> m (Reply Int)
srem :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
srem_ :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> m (Reply Int)
spop :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
smove :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> s2 -> s3 -> m (Reply Int)
scard :: (WithRedis m, BS s) => s -> m (Reply Int)
sismember :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
smembers :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
srandmember :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
sinter :: (WithRedis m, BS s1, BS s2) => [s1] -> m (Reply s2)
sinterStore :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> m (Reply ())
sunion :: (WithRedis m, BS s1, BS s2) => [s1] -> m (Reply s2)
sunionStore :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> m (Reply ())
sdiff :: (WithRedis m, BS s1, BS s2) => [s1] -> m (Reply s2)
sdiffStore :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> m (Reply ())
zadd :: (WithRedis m, BS s1, BS s2) => s1 -> Double -> s2 -> m (Reply Int)
zadd_ :: (WithRedis m, BS s1, BS s2) => s1 -> [(Double, s2)] -> m (Reply Int)
zrem :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
zrem_ :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> m (Reply Int)
zincrBy :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> Double -> s2 -> m (Reply s3)
zrange :: (WithRedis m, BS s1, BS s2) => s1 -> (Int, Int) -> Bool -> m (Reply s2)
zrevrange :: (WithRedis m, BS s1, BS s2) => s1 -> (Int, Int) -> Bool -> m (Reply s2)
zrangebyscore :: (WithRedis m, IsInterval i Double, BS s1, BS s2) => s1 -> i -> Maybe (Int, Int) -> Bool -> m (Reply s2)
zrevrangebyscore :: (WithRedis m, IsInterval i Double, BS s1, BS s2) => s1 -> i -> Maybe (Int, Int) -> Bool -> m (Reply s2)
zcount :: (WithRedis m, IsInterval i Double, BS s) => s -> i -> m (Reply Int)
zremrangebyscore :: (WithRedis m, BS s) => s -> (Double, Double) -> m (Reply Int)
zcard :: (WithRedis m, BS s) => s -> m (Reply Int)
zscore :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> s2 -> m (Reply s3)
zrank :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
zrevrank :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
zremrangebyrank :: (WithRedis m, BS s) => s -> (Int, Int) -> m (Reply Int)

-- | <i>Deprecated: ZUNION command was renamed to ZUNIONSTORE</i>
zunion :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> [Double] -> Aggregate -> m (Reply Int)

-- | <i>Deprecated: ZINTER command was renamed to ZINTERSTORE</i>
zinter :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> [Double] -> Aggregate -> m (Reply Int)
zunionStore :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> [Double] -> Aggregate -> m (Reply Int)
zinterStore :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> [Double] -> Aggregate -> m (Reply Int)
hset :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> s2 -> s3 -> m (Reply Int)
hget :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> s2 -> m (Reply s3)
hdel :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
hdel_ :: (WithRedis m, BS s1, BS s2) => s1 -> [s2] -> m (Reply Int)
hmset :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> [(s2, s3)] -> m (Reply ())
hmget :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> [s2] -> m (Reply s3)
hincrBy :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> Int -> m (Reply Int)
hincrByFloat :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> Double -> m (Reply Double)
hexists :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
hlen :: (WithRedis m, BS s) => s -> m (Reply Int)
hkeys :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
hvals :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
hgetall :: (WithRedis m, BS s1, BS s2) => s1 -> m (Reply s2)
sort :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> SortOptions s2 -> m (Reply s3)
listRelated :: (WithRedis m, BS s1, BS s2, BS s3) => s1 -> s2 -> (Int, Int) -> m (Reply s3)
subscribed :: WithRedis m => m Int
subscribe :: (WithRedis m, BS s1, BS s2) => [s1] -> m [Message s2]
unsubscribe :: (WithRedis m, BS s1, BS s2) => [s1] -> m [Message s2]
psubscribe :: (WithRedis m, BS s1, BS s2) => [s1] -> m [Message s2]
punsubscribe :: (WithRedis m, BS s1, BS s2) => [s1] -> m [Message s2]
publish :: (WithRedis m, BS s1, BS s2) => s1 -> s2 -> m (Reply Int)
listen :: (WithRedis m, BS s) => Int -> m (Maybe (Message s))
save :: WithRedis m => m (Reply ())
bgsave :: WithRedis m => m (Reply ())
lastsave :: WithRedis m => m (Reply Int)
bgrewriteaof :: WithRedis m => m (Reply ())


-- | This module is mainly an example of posible <a>WithRedis</a>
--   implementation
module Database.Redis.Monad.State

-- | Trivial WithRedis instance storing Redis descriptor in StateT
type RedisM = StateT Redis IO
runWithRedis :: Redis -> (RedisM a) -> IO a
instance WithRedis RedisM


-- | Emulating locking primitives
module Database.Redis.Utils.Lock

-- | Acquire lock. This function is not reentrant so thread can be locked
--   by itself if it try to acquire the same lock before it was released.
acquire :: BS s => Redis -> s -> Int -> Int -> IO Bool

-- | acquire with default last parameter set to 50 milliseconds
acquire' :: BS s => Redis -> s -> Int -> IO Bool

-- | Try to acquire lock once and return result without any timeout
acquireOnce :: BS s1 => Redis -> s1 -> IO Bool

-- | Release lock. There is no any guarantees that lock was acquired in
--   this thread. Just release this lock and go forth.
release :: BS s => Redis -> s -> IO ()


-- | Same as <a>Database.Redis.Utils.Lock</a> but with monadic wrapped
module Database.Redis.Utils.Monad.Lock
acquire :: (WithRedis m, BS s) => s -> Int -> Int -> m Bool
acquire' :: (WithRedis m, BS s) => s -> Int -> m Bool
acquireOnce :: (WithRedis m, BS b) => b -> m Bool
release :: (WithRedis m, BS s) => s -> m ()
