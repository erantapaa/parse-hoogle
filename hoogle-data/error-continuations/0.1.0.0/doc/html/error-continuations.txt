-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Error Continuations
--   
--   Error Continuations
@package error-continuations
@version 0.1.0.0


-- | The <a>MaybeContT</a> type and API provide an idiomatic way to handle
--   possibly failing computations in continuation passing style over some
--   base monad.
module Control.Monad.Trans.MaybeCont

-- | The <a>MaybeContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> type
--   encodes a nullable monad transformer in continuation passing style
--   which is monadic in <tt>r</tt>. This property holds for any type
--   constructor <tt>m</tt>.
newtype MaybeContT a m r

-- | Construct a continuation-passing computation from a function.
MaybeContT :: (m a -> (r -> m a) -> m a) -> MaybeContT a m r

-- | The result of running a CPS computation with given nothing and just
--   continuations.
runMaybeContT :: MaybeContT a m r -> m a -> (r -> m a) -> m a

-- | <a>liftMaybeT</a> embeds <a>MaybeT</a> in <a>MaybeContT</a>
--   <tt>a</tt>.
liftMaybeT :: Monad m => MaybeT m r -> MaybeContT a m r

-- | <a>nothingC</a> is the CPS representation of <a>Nothing</a>.
nothingC :: MaybeContT a m r

-- | Apply a function to transform the result of a continuation-passing
--   computation.
mapMaybeContT :: (m a -> m a) -> MaybeContT a m r -> MaybeContT a m r

-- | Apply a function to transform the just continuation passed to a
--   continuation-passing computation.
withMaybeContTJust :: ((r' -> m a) -> r -> m a) -> MaybeContT a m r -> MaybeContT a m r'

-- | Apply a function to transform the nothing continuation passed to a
--   continuation-passing computation.
withMaybeContTNothing :: (m a -> m a) -> MaybeContT a m r -> MaybeContT a m r
instance MonadCont (MaybeContT a m)
instance MonadTrans (MaybeContT a)
instance Monad (MaybeContT a m)
instance Applicative (MaybeContT a m)
instance Functor (MaybeContT a m)


-- | The <a>MaybeCont</a> type and API provide an idiomatic way to handle
--   possibly failing computations in continuation passing style.
module Control.Monad.MaybeCont

-- | <a>MaybeCont</a> <tt>a</tt> <tt>r</tt> is a CPS computation that
--   produces an intermediate result of type <tt>a</tt> within a CPS
--   computation which produces either a just or nothing.
type MaybeCont a r = MaybeContT a Identity r

-- | The <a>MaybeContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> type
--   encodes a nullable monad transformer in continuation passing style
--   which is monadic in <tt>r</tt>. This property holds for any type
--   constructor <tt>m</tt>.
data MaybeContT a m r

-- | Construct a continuation-passing computation from a function.
maybeCont :: (a -> (r -> a) -> a) -> MaybeCont a r

-- | The result of running a CPS computation with given nothing and just
--   continuations.
--   
--   <pre>
--   runMaybeCont . maybeCont = id
--   </pre>
--   
--   <pre>
--   maybeCont . runMaybeCont = id
--   </pre>
runMaybeCont :: MaybeCont a r -> (a -> (r -> a) -> a)

-- | <a>liftMaybe</a> embeds <a>Maybe</a> in <a>MaybeCont</a> <tt>a</tt>.
liftMaybe :: Maybe r -> MaybeCont a r

-- | <a>nothingC</a> is the CPS representation of <a>Nothing</a>.
nothingC :: MaybeContT a m r

-- | Apply a function to transform the result of a continuation-passing
--   computation.
mapMaybeCont :: (a -> a) -> MaybeCont a r -> MaybeCont a r

-- | Apply a function to transform the just continuation passed to a
--   continuation-passing computation.
withMaybeContJust :: ((r' -> a) -> r -> a) -> MaybeCont a r -> MaybeCont a r'

-- | Apply a function to transform the nothing continuation passed to an
--   continuation-passing computation.
withMaybeContNothing :: (a -> a) -> MaybeCont a r -> MaybeCont a r


-- | The <a>EitherContT</a> type and API provide an idiomatic way to handle
--   errors in continuation passing style over some base monad.
module Control.Monad.Trans.EitherCont

-- | The <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt>
--   type encodes a sum type monad transformer in continuation passing
--   style which is separately monadic in both <tt>l</tt> and <tt>r</tt>.
--   Interestingly, this property holds for any type constructor
--   <tt>m</tt>.
newtype EitherContT a l m r

-- | Construct a continuation-passing computation from a function.
EitherContT :: ((l -> m a) -> (r -> m a) -> m a) -> EitherContT a l m r

-- | The result of running a CPS computation with given failure and success
--   continuations.
runEitherContT :: EitherContT a l m r -> (l -> m a) -> (r -> m a) -> m a

-- | <a>liftEitherT</a> embeds <a>EitherT</a> in <a>EitherContT</a>
--   <tt>a</tt>.
liftEitherT :: Monad m => EitherT l m r -> EitherContT a l m r

-- | <a>fmapL</a> encodes functoriality of <a>EitherContT</a> <tt>a</tt>
--   <tt>l</tt> <tt>m</tt> <tt>r</tt> in <tt>l</tt>.
fmapL :: (l -> l') -> EitherContT a l m r -> EitherContT a l' m r

-- | <a>bimapEC</a> encodes bifunctoriality of <a>EitherContT</a>
--   <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> in <tt>l</tt> and
--   <tt>r</tt>.
--   
--   <pre>
--   bimapEC f id = fmapL f
--   </pre>
--   
--   <pre>
--   bimapEC id f = fmap f
--   </pre>
bimapEC :: (l -> l') -> (r -> r') -> EitherContT a l m r -> EitherContT a l' m r'

-- | <a>throwEC</a> encodes the applicative/monadic unit of
--   <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> in
--   <tt>l</tt>.
throwEC :: l -> EitherContT a l m r

-- | <a>apL</a> encodes applicativity of <a>EitherContT</a> <tt>a</tt>
--   <tt>l</tt> <tt>m</tt> <tt>r</tt> in <tt>l</tt>.
apL :: EitherContT a (l -> l') m r -> EitherContT a l m r -> EitherContT a l' m r

-- | <a>throwEC</a> and <a>catchEC</a> encode monadicity of
--   <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> in
--   <tt>l</tt>. The usual monad laws hold with <a>throwEC</a> taking the
--   role of <a>return</a> and <a>catchEC</a> taking the role of
--   <a>&gt;&gt;=</a>.
--   
--   <pre>
--   throwEC l `catchEC` f = f l
--   </pre>
--   
--   <pre>
--   ec `catchEC` throwEC = ec
--   </pre>
--   
--   <pre>
--   (ec `catchEC` f) `catchEC` g = ec `catchEC` (\l -&gt; f l `catchEC` g)
--   </pre>
catchEC :: EitherContT a l m r -> (l -> EitherContT a l' m r) -> EitherContT a l' m r

-- | <a>handleEC</a> is a flipped <a>catchEC</a>.
handleEC :: (l -> EitherContT a l' m r) -> EitherContT a l m r -> EitherContT a l' m r

-- | A right-to-left, point free way to compose handlers. The monad laws
--   look more elegant, expressed in terms of <a>&lt;?&lt;</a>.
--   
--   <pre>
--   throwEC &lt;?&lt; f = f = f &lt;?&lt; throwEC
--   </pre>
--   
--   <pre>
--   (h &lt;?&lt; g) &lt;?&lt; f = h &lt;?&lt; (g &lt;?&lt; f)
--   </pre>
(<?<) :: (l' -> EitherContT a l'' m r) -> (l -> EitherContT a l' m r) -> (l -> EitherContT a l'' m r)

-- | A left-to-right, point free way to compose handlers.
(>?>) :: (l -> EitherContT a l' m r) -> (l' -> EitherContT a l'' m r) -> (l -> EitherContT a l'' m r)

-- | <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> is a
--   monad transformer for <tt>m</tt> in <tt>l</tt>.
liftL :: Monad m => m l -> EitherContT a l m r

-- | <a>flipEC</a> encodes the symmetry of <tt>l</tt> and <tt>r</tt> in
--   <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt>.
--   
--   <pre>
--   flipEC . flipEC = id
--   </pre>
flipEC :: EitherContT a l m r -> EitherContT a r m l

-- | Apply a function to transform the result of a continuation-passing
--   computation.
mapEitherContT :: (m a -> m a) -> EitherContT a l m r -> EitherContT a l m r

-- | Apply a function to transform the success continuation passed to a
--   continuation-passing computation.
withEitherContTR :: ((r' -> m a) -> r -> m a) -> EitherContT a l m r -> EitherContT a l m r'

-- | Apply a function to transform the failure continuation passed to an
--   continuation-passing computation.
withEitherContTL :: ((l' -> m a) -> l -> m a) -> EitherContT a l m r -> EitherContT a l' m r

-- | Call with current failure continuation.
callCCL :: ((l -> EitherContT a l' m r) -> EitherContT a l m r) -> EitherContT a l m r

-- | <a>lowerMonadError</a> runs the continuation-passing computation,
--   throwing on failure and returning on success.
lowerMonadError :: MonadError l m => EitherContT r l m r -> m r

-- | <a>liftMonadError</a> embeds a <a>MonadError</a> computation
--   <tt>m</tt> <tt>r</tt> into <a>EitherContT</a> <tt>a</tt> <tt>l</tt>
--   <tt>m</tt> <tt>r</tt>.
--   
--   <a>liftMonadError</a> and <a>lowerMonadError</a> are one-sided
--   inverses, making <tt>MonadError l m =&gt; m r</tt> a retract of
--   <a>EitherContT</a> <tt>r</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt>.
--   
--   <pre>
--   lowerMonadError . liftMonadError = id
--   </pre>
liftMonadError :: MonadError l m => m r -> EitherContT a l m r
instance MonadError l (EitherContT a l m)
instance MonadCont (EitherContT a l m)
instance MonadTrans (EitherContT a l)
instance Monad (EitherContT a l m)
instance Applicative (EitherContT a l m)
instance Functor (EitherContT a l m)


-- | The <a>EitherCont</a> type and API provide an idiomatic way to handle
--   errors in continuation passing style.
module Control.Monad.EitherCont

-- | <a>EitherCont</a> <tt>a</tt> <tt>l</tt> <tt>r</tt> is a CPS
--   computation that produces an intermediate result of type <tt>a</tt>
--   within a CPS computation which produces either a success of type
--   <tt>r</tt> or failure of type <tt>l</tt>.
type EitherCont a l r = EitherContT a l Identity r

-- | The <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt>
--   type encodes a sum type monad transformer in continuation passing
--   style which is separately monadic in both <tt>l</tt> and <tt>r</tt>.
--   Interestingly, this property holds for any type constructor
--   <tt>m</tt>.
data EitherContT a l m r

-- | Construct a continuation-passing computation from a function.
eitherCont :: ((l -> a) -> (r -> a) -> a) -> EitherCont a l r

-- | The result of running a CPS computation with given failure and success
--   continuations.
--   
--   <pre>
--   runEitherCont . eitherCont = id
--   </pre>
--   
--   <pre>
--   eitherCont . runEitherCont = id
--   </pre>
runEitherCont :: EitherCont a l r -> (l -> a) -> (r -> a) -> a

-- | <a>liftEither</a> embeds <a>Either</a> in <a>EitherCont</a>
--   <tt>a</tt>.
liftEither :: Either l r -> EitherCont a l r

-- | <a>fmapL</a> encodes functoriality of <a>EitherContT</a> <tt>a</tt>
--   <tt>l</tt> <tt>m</tt> <tt>r</tt> in <tt>l</tt>.
fmapL :: (l -> l') -> EitherContT a l m r -> EitherContT a l' m r

-- | <a>bimapEC</a> encodes bifunctoriality of <a>EitherContT</a>
--   <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> in <tt>l</tt> and
--   <tt>r</tt>.
--   
--   <pre>
--   bimapEC f id = fmapL f
--   </pre>
--   
--   <pre>
--   bimapEC id f = fmap f
--   </pre>
bimapEC :: (l -> l') -> (r -> r') -> EitherContT a l m r -> EitherContT a l' m r'

-- | <a>throwEC</a> encodes the applicative/monadic unit of
--   <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> in
--   <tt>l</tt>.
throwEC :: l -> EitherContT a l m r

-- | <a>apL</a> encodes applicativity of <a>EitherContT</a> <tt>a</tt>
--   <tt>l</tt> <tt>m</tt> <tt>r</tt> in <tt>l</tt>.
apL :: EitherContT a (l -> l') m r -> EitherContT a l m r -> EitherContT a l' m r

-- | <a>throwEC</a> and <a>catchEC</a> encode monadicity of
--   <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> in
--   <tt>l</tt>. The usual monad laws hold with <a>throwEC</a> taking the
--   role of <a>return</a> and <a>catchEC</a> taking the role of
--   <a>&gt;&gt;=</a>.
--   
--   <pre>
--   throwEC l `catchEC` f = f l
--   </pre>
--   
--   <pre>
--   ec `catchEC` throwEC = ec
--   </pre>
--   
--   <pre>
--   (ec `catchEC` f) `catchEC` g = ec `catchEC` (\l -&gt; f l `catchEC` g)
--   </pre>
catchEC :: EitherContT a l m r -> (l -> EitherContT a l' m r) -> EitherContT a l' m r

-- | <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt> is a
--   monad transformer for <tt>m</tt> in <tt>l</tt>.
liftL :: Monad m => m l -> EitherContT a l m r

-- | <a>flipEC</a> encodes the symmetry of <tt>l</tt> and <tt>r</tt> in
--   <a>EitherContT</a> <tt>a</tt> <tt>l</tt> <tt>m</tt> <tt>r</tt>.
--   
--   <pre>
--   flipEC . flipEC = id
--   </pre>
flipEC :: EitherContT a l m r -> EitherContT a r m l

-- | Apply a function to transform the result of a continuation-passing
--   computation.
mapEitherCont :: (a -> a) -> EitherCont a l r -> EitherCont a l r

-- | Apply a function to transform the failure continuation passed to an
--   continuation-passing computation.
withEitherContL :: ((l' -> a) -> l -> a) -> EitherCont a l r -> EitherCont a l' r

-- | Apply a function to transform the success continuation passed to a
--   continuation-passing computation.
withEitherContR :: ((r' -> a) -> r -> a) -> EitherCont a l r -> EitherCont a l r'

-- | Call with current failure continuation.
callCCL :: ((l -> EitherContT a l' m r) -> EitherContT a l m r) -> EitherContT a l m r


-- | This module provides utility functions to convert between
--   <a>MaybeContT</a> and <a>EitherContT</a> computations.
module Control.Error.Cont.Util

-- | Suppress the nothing continuation of an <a>EitherContT</a>
hush :: EitherContT a l m r -> MaybeContT a m r

-- | Tag the nothing continuation of a <a>MaybeContT</a>
note :: l -> MaybeContT a m r -> EitherContT a l m r
