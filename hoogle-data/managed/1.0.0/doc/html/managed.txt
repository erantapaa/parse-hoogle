-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monad for managed values
--   
--   In Haskell you very often acquire values using the <tt>with...</tt>
--   idiom using functions of type <tt>(a -&gt; IO r) -&gt; IO r</tt>. This
--   idiom forms a <tt>Monad</tt>, which is a special case of the
--   <tt>ContT</tt> monad (from <tt>transformers</tt>) or the
--   <tt>Codensity</tt> monad (from <tt>kan-extensions</tt>). The main
--   purpose behind this package is to provide a restricted form of these
--   monads specialized to this unusually common case.
--   
--   The reason this package defines a specialized version of these types
--   is to:
--   
--   <ul>
--   <li>be more beginner-friendly,</li>
--   <li>simplify inferred types and error messages, and:</li>
--   <li>provide some additional type class instances that would otherwise
--   be orphan instances</li>
--   </ul>
@package managed
@version 1.0.0


-- | An example Haskell program to copy data from one handle to another
--   might look like this:
--   
--   <pre>
--   main =
--       withFile "inFile.txt" ReadMode $ \inHandle -&gt;
--           withFile "outFile.txt" WriteMode $ \outHandle -&gt;
--               copy inHandle outHandle
--   
--   -- A hypothetical function that copies data from one handle to another
--   copy :: Handle -&gt; Handle -&gt; IO ()
--   </pre>
--   
--   <a>withFile</a> is one of many functions that acquire some resource in
--   an exception-safe way. These functions take a callback function as an
--   argument and they invoke the callback on the resource when it becomes
--   available, guaranteeing that the resource is properly disposed if the
--   callback throws an exception.
--   
--   These functions usually have a type that ends with the following
--   pattern:
--   
--   <pre>
--                      Callback
--   --                -----------
--   withXXX :: ... -&gt; (a -&gt; IO r) -&gt; IO r
--   </pre>
--   
--   Here are some examples of this pattern from the <tt>base</tt>
--   libraries:
--   
--   <pre>
--   withArray      :: Storable a =&gt; [a] -&gt; (Ptr a   -&gt; IO r) -&gt; IO r
--   withBuffer     ::          Buffer e -&gt; (Ptr e   -&gt; IO r) -&gt; IO r
--   withCAString   ::            String -&gt; (CString -&gt; IO r) -&gt; IO r
--   withForeignPtr ::      ForeignPtr a -&gt; (Ptr a   -&gt; IO r) -&gt; IO r
--   withMVar       ::            Mvar a -&gt; (a       -&gt; IO r) -&gt; IO r
--   withPool       ::                      (Pool    -&gt; IO r) -&gt; IO r
--   </pre>
--   
--   Acquiring multiple resources in this way requires nesting callbacks.
--   However, you can wrap anything of the form <tt>((a -&gt; IO r) -&gt;
--   IO r)</tt> in the <a>Managed</a> monad, which translates binds to
--   callbacks for you:
--   
--   <pre>
--   import Control.Monad.Managed
--   import System.IO
--   
--   inFile :: FilePath -&gt; Managed Handle
--   inFile filePath = managed (withFile filePath ReadMode)
--   
--   outFile :: FilePath -&gt; Managed Handle
--   outFile filePath = managed (withFile filePath WriteMode)
--   
--   main = runManaged $ do
--       inHandle  &lt;- inFile "inFile.txt"
--       outHandle &lt;- outFile "outFile.txt"
--       liftIO (copy inHandle outHandle)
--   </pre>
--   
--   ... or you can just wrap things inline:
--   
--   <pre>
--   main = runManaged $ do
--       inHandle  &lt;- managed (withFile "inFile.txt" ReadMode)
--       outHandle &lt;- managed (withFile "outFile.txt" WriteMode)
--       liftIO (copy inHandle outHandle)
--   </pre>
--   
--   Additionally, since <a>Managed</a> is a <a>Monad</a>, you can take
--   advantage of all your favorite combinators from <a>Control.Monad</a>.
--   For example, the <a>withMany</a> function from
--   <a>Foreign.Marshal.Utils</a> becomes a trivial wrapper around
--   <a>mapM</a>:
--   
--   <pre>
--   withMany :: (a -&gt; (b -&gt; IO r) -&gt; IOr ) -&gt; [a] -&gt; ([b] -&gt; IO r) -&gt; IO r
--   withMany f = with . mapM (Managed . f)
--   </pre>
--   
--   Another reason to use <a>Managed</a> is that if you wrap a
--   <a>Monoid</a> value in <a>Managed</a> you get back a new
--   <a>Monoid</a>:
--   
--   <pre>
--   instance Monoid a =&gt; Monoid (Managed a)
--   </pre>
--   
--   This lets you combine managed resources transparently. You can also
--   lift operations from some numeric type classes this way, too, such as
--   the <a>Num</a> type class.
module Control.Monad.Managed

-- | A managed resource that you acquire using <a>with</a>
data Managed a

-- | Build a <a>Managed</a> value
managed :: (forall r. (a -> IO r) -> IO r) -> Managed a

-- | Acquire a <a>Managed</a> value
with :: Managed a -> (a -> IO r) -> IO r

-- | Run a <a>Managed</a> computation, enforcing that no acquired resources
--   leak
runManaged :: Managed () -> IO ()
instance Floating a => Floating (Managed a)
instance Fractional a => Fractional (Managed a)
instance Num a => Num (Managed a)
instance Monoid a => Monoid (Managed a)
instance MonadIO Managed
instance Monad Managed
instance Applicative Managed
instance Functor Managed


-- | This module is a safer subset of <a>Control.Monad.Managed</a> that
--   only lets you unwrap the <a>Managed</a> type using <a>runManaged</a>.
--   This enforces that you never leak acquired resources from a
--   <a>Managed</a> computation.
--   
--   In general, you should strive to propagate the <a>Managed</a> type as
--   much as possible and use <a>runManaged</a> when you are done with
--   acquired resources. However, there are legitimate circumstances where
--   you want to return a value other than acquired resource from the
--   bracketed computation, which requires using <a>with</a>.
--   
--   This module is not the default because you can also use the
--   <a>Managed</a> type for callback-based code that is completely
--   unrelated to resources.
module Control.Monad.Managed.Safe

-- | A managed resource that you acquire using <a>with</a>
data Managed a

-- | Build a <a>Managed</a> value
managed :: (forall r. (a -> IO r) -> IO r) -> Managed a

-- | Run a <a>Managed</a> computation, enforcing that no acquired resources
--   leak
runManaged :: Managed () -> IO ()
