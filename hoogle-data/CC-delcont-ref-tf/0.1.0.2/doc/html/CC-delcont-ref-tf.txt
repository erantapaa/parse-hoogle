-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monad transformers for multi-prompt delimited control using refercence cells
--   
--   This library implements the superset of the interface described in *
--   <i>A Monadic Framework for Delimited Continuations</i>, R. Kent
--   Dybvig, Simon Peyton Jones, and Amr Sabry JFP, v17, N6, pp. 687--730,
--   2007.
--   <a>http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615</a>
--   
--   This library is closest to the interface of Dybvig, Peyton Jones and
--   Sabry. <a>Control.Monad.CC.CCRef</a> is derived from the definitional
--   interpreter using the implementation techniques described and
--   justified in the FLOPS 2010 paper. The monad transformer <a>CC</a>
--   implemented by <a>Control.Monad.CC.CCRef</a> requires the base monad
--   to support reference cells. In other words, the base monad must be a
--   member of the type class <a>MonadRef</a>: that is, must be <a>IO</a>,
--   <a>ST</a>, <a>STM</a> or their transformer.
--   <a>Control.Monad.CC.CCRef</a> adds to the original interface the
--   frequently used function <a>abortP</a> as a primitive.
--   
--   See the original article at
--   <a>http://okmij.org/ftp/continuations/implementations.html#CC-monads</a>
--   for more information.
--   
--   This package uses <a>http://hackage.haskell.org/package/ref-tf</a>'s
--   <a>MonadRef</a> class instead of <a>Mutation</a> class what is used in
--   <a>http://hackage.haskell.org/package/CC-delcont-ref</a> package.
@package CC-delcont-ref-tf
@version 0.1.0.2


-- | Monad transformer for multi-prompt delimited control
--   
--   This library implements the superset of the interface described in
--   
--   <ul>
--   <li>"<i>A Monadic Framework for Delimited Continuations</i>", R. Kent
--   Dybvig, Simon Peyton Jones, and Amr Sabry JFP, v17, N6, pp. 687--730,
--   2007.
--   <a>http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615</a></li>
--   </ul>
--   
--   This code is the straightforward implementation of the definitional
--   machine described in the above paper. To be precise, we implement an
--   equivalent machine, where captured continuations are always sandwiched
--   between two prompts. This equivalence as well as the trick to make it
--   all well-typed are described in the FLOPS 2010 paper. Therefore, to
--   the great extent this code is the straightforward translation of
--   delimcc from OCaml. The parallel stack of delimcc is the <tt>real</tt>
--   stack now (containing parts of the real continuation, that is).
--   
--   This code implements, in CPS, what amounts to a segmented stack (the
--   technique of implementing call/cc efficiently, first described in
--   Hieb, Dybvig and Bruggeman's PLDI 1990 paper).
module Control.Monad.CC.CCRef

-- | Delimited-continuation monad transformer The (CC m) monad is the Cont
--   monad with the answer-type (), combined with the persistent-state
--   monad. The state PTop is the `parallel stack' of delimcc, which is the
--   real stack now. The base monad m must support reference cells, that
--   is, be a member of the type class MonadRef. Since we need reference
--   cells anyway, we represent the persistent state as a reference cell
--   PTop, which is passed as the environment.
data CC m a

-- | The context between two exception frames: The captured
--   sub-continuation It is a fragment of the parallel stack: a list of
--   PFrames in inverse order. Since we are in the Cont monad, there is no
--   <tt>real</tt> stack: the type Ekfragment is ()
data SubCont m a b

-- | The type of prompts is just like that in OCaml's delimcc
data Prompt m a
newPrompt :: (Monad m, MonadRef m) => CC m (Prompt m a)
pushPrompt :: (Monad m, MonadRef m) => Prompt m w -> CC m w -> CC m w
takeSubCont :: (Monad m, MonadRef m) => Prompt m b -> (SubCont m a b -> CC m b) -> CC m a
pushSubCont :: (Monad m, MonadRef m) => SubCont m a b -> CC m a -> CC m b
runCC :: (Monad m, MonadRef m) => CC m a -> m a

-- | An efficient variation of take_subcont, which does not capture any
--   continuation. This code makes it clear that abort is essentially
--   raise.
abortP :: (Monad m, MonadRef m) => Prompt m w -> CC m w -> CC m any

-- | An optimization: pushing the _delimited_ continuation. This is the
--   optimization of the pattern
--   
--   <pre>
--   pushPrompt (subcont_pb sk) (pushSubcont sk m)
--   </pre>
--   
--   corresponding to pushing the continuation captured by shift/shift0.
--   The latter continuation always has the delimiter at the end. Indeed
--   shift can be implemented more efficiently as a primitive rather than
--   via push_prompt/control combination...
pushDelimSubCont :: (Monad m, MonadRef m) => SubCont m a b -> CC m a -> CC m b
shiftP :: (Monad m, MonadRef m) => Prompt m w -> ((a -> CC m w) -> CC m w) -> CC m a
shift0P :: (Monad m, MonadRef m) => Prompt m w -> ((a -> CC m w) -> CC m w) -> CC m a
controlP :: (Monad m, MonadRef m) => Prompt m w -> ((a -> CC m w) -> CC m w) -> CC m a

-- | Check to see if a prompt is set
isPromptSet :: (Monad m, MonadRef m) => Prompt m w -> CC m Bool
instance (Monad m, MonadAtomicRef m) => MonadAtomicRef (CC m)
instance (Monad m, MonadRef m) => MonadRef (CC m)
instance MonadIO m => MonadIO (CC m)
instance MonadTrans CC
instance Monad m => Monad (CC m)
