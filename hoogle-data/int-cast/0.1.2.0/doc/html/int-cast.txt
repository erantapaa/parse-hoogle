-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Checked conversions between integral types
--   
@package int-cast
@version 0.1.2.0


-- | This module provides for statically or dynamically checked conversions
--   between <a>Integral</a> types.
module Data.IntCast

-- | Statically checked integer conversion which satisfies the property
--   
--   <ul>
--   <li><pre><a>toInteger</a> ≡ <a>toInteger</a> . intCast</pre></li>
--   </ul>
--   
--   Note: This is just a type-restricted alias of <a>fromIntegral</a> and
--   should therefore lead to the same compiled code as if
--   <a>fromIntegral</a> had been used instead of <a>intCast</a>.
intCast :: (Integral a, Integral b, IsIntSubType a b ~ True) => a -> b

-- | Statically checked integer conversion which satisfies the properties
--   
--   <ul>
--   <li><pre>∀β . <a>intCastIso</a> (<a>intCastIso</a> a ∷ β) ==
--   a</pre></li>
--   <li><pre><a>toInteger</a> (<a>intCastIso</a> a) == <a>toInteger</a> b
--   (<b>if</b> <a>toInteger</a> a == <a>toInteger</a> b)</pre></li>
--   </ul>
--   
--   Note: This is just a type-restricted alias of <a>fromIntegral</a> and
--   should therefore lead to the same compiled code as if
--   <a>fromIntegral</a> had been used instead of <a>intCast</a>.
intCastIso :: (Integral a, Integral b, IsIntTypeIso a b ~ True) => a -> b

-- | Version of <a>intCast</a> restricted to casts between types with same
--   value domain.
intCastEq :: (Integral a, Integral b, IsIntTypeEq a b ~ True) => a -> b

-- | Run-time-checked integer conversion
--   
--   This is an optimized version of the following generic code below
--   
--   <pre>
--   intCastMaybeRef :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   intCastMaybeRef x
--     | toInteger x == toInteger y = Just y
--     | otherwise                  = Nothing
--     where
--       y = fromIntegral x
--   </pre>
--   
--   The code above is rather inefficient as it needs to go via the
--   <a>Integer</a> type. The function <a>intCastMaybe</a>, however, is
--   marked <tt>INLINEABLE</tt> and if both integral types are statically
--   known, GHC will be able optimize the code signficantly (for
--   <tt>-O1</tt> and better).
--   
--   For instance (as of GHC 7.8.1) the following definitions
--   
--   <pre>
--   w16_to_i32 = intCastMaybe :: Word16 -&gt; Maybe Int32
--   
--   i16_to_w16 = intCastMaybe :: Int16 -&gt; Maybe Word16
--   </pre>
--   
--   are translated into the following (simplified) <i>GHC Core</i>
--   language
--   
--   <pre>
--   w16_to_i32 = \x -&gt; Just (case x of _ { W16# x# -&gt; I32# (word2Int# x#) })
--   
--   i16_to_w16 = \x -&gt; case eta of _
--     { I16# b1 -&gt; case tagToEnum# (&lt;=# 0 b1) of _
--         { False -&gt; Nothing
--         ; True -&gt; Just (W16# (narrow16Word# (int2Word# b1)))
--         }
--     }
--   </pre>
intCastMaybe :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b

-- | The (open) type family <a>IntBaseType</a> encodes type-level
--   information about the value range of an integral type.
--   
--   This module also provides type family instances for the standard
--   Haskell 2010 integral types (including <a>Foreign.C.Types</a>) as well
--   as the <a>Natural</a> type.
--   
--   Here's a simple example for registering a custom type with the
--   <a>Data.IntCast</a> facilities:
--   
--   <pre>
--   <i>-- user-implemented unsigned 4-bit integer</i>
--   data Nibble = …
--   
--   <i>-- declare meta-information</i>
--   type instance <a>IntBaseType</a> MyWord7 = <a>FixedIntTag</a> 4
--   
--   <i>-- user-implemented signed 7-bit integer</i>
--   data MyInt7 = …
--   
--   <i>-- declare meta-information</i>
--   type instance <a>IntBaseType</a> MyWord7 = <a>FixedIntTag</a> 7
--   </pre>
--   
--   The type-level predicate <a>IsIntSubType</a> provides a partial
--   ordering based on the types above. See also <a>intCast</a>.

-- | (Kind) Meta-information about integral types.
--   
--   If also a <a>Bits</a> instance is defined, the type-level information
--   provided by <a>IntBaseType</a> ought to match the meta-information
--   that is conveyed by the <a>Bits</a> class' <a>isSigned</a> and
--   <a>bitSizeMaybe</a> methods.
data IntBaseTypeK

-- | fixed-width <i>n</i>-bit integers with value range [-2ⁿ⁻¹, 2ⁿ⁻¹-1].
FixedIntTag :: Nat -> IntBaseTypeK

-- | fixed-width <i>n</i>-bit integers with value range [0, 2ⁿ-1].
FixedWordTag :: Nat -> IntBaseTypeK

-- | integers with value range ]-∞,+∞[.
BigIntTag :: IntBaseTypeK

-- | naturals with value range [0,+∞[.
BigWordTag :: IntBaseTypeK
type IsIntSubType a b = IsIntBaseSubType (IntBaseType a) (IntBaseType b)
type IsIntTypeIso a b = IsIntBaseTypeIso (IntBaseType a) (IntBaseType b)
type IsIntTypeEq a b = IsIntBaseTypeEq (IntBaseType a) (IntBaseType b)
