-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Real numbers and intervals with relatively efficient exact arithmetic.
--   
@package ireal
@version 0.2.1

module Data.Number.IReal.Auxiliary

-- | Base 2 logarithm of argument, rounded downwards.
lg2 :: Integer -> Int

-- | Converts precisions from decimal to binary.
dec2bits :: Int -> Int

-- | Operator allowing function expecting binary precision to be applied to
--   decimal ditto.
atDecimals :: (Int -> a) -> Int -> a

module Data.Number.IReal.Powers

-- | Common functions collected to allow for instances which handle
--   dependency problems for intervals, and for automatic differentiation.
class Num a => Powers a where sq = flip pow 2 pow x n = x ^ n
sq :: Powers a => a -> a
pow :: Powers a => a -> Int -> a
instance Powers Integer
instance Powers Double

module Data.Number.IReal.IntegerInterval
data IntegerInterval
I :: (Integer, Integer) -> IntegerInterval
upto :: Integer -> Integer -> IntegerInterval
midI :: IntegerInterval -> Integer
upperI :: IntegerInterval -> Integer
lowerI :: IntegerInterval -> Integer
radI :: IntegerInterval -> Integer
isThin :: IntegerInterval -> Bool
ivalCase :: IntegerInterval -> a -> a -> a -> a
instance Show IntegerInterval
instance Powers IntegerInterval
instance Num IntegerInterval

module Data.Number.IReal.Scalable

-- | Scaling. <tt>scale x n</tt> computes <tt>x * 2^n</tt> using bit
--   shifts.
class Scalable a
scale :: Scalable a => a -> Int -> a

-- | Correctly rounded result for negative n. Rounds upwards when decimal
--   part of unrounded result is .5
class VarPrec a where prec d = precB (dec2bits d)
prec :: VarPrec a => Int -> a -> a
precB :: VarPrec a => Int -> a -> a
instance VarPrec Double
instance VarPrec a => VarPrec [a]
instance Scalable Double
instance Scalable IntegerInterval
instance (Integral a, Bits a) => Scalable (Ratio a)
instance Scalable Integer

module Data.Number.IReal.UnsafeMemo

-- | Memoizing a function which satisfies the property <tt>f (p-r) = scale
--   (f p) (-r)</tt> for all <tt>r &gt; 0</tt>. Unsafe; based on ideas from
--   Lennart Augustsson's uglymemo.
unsafeMemo :: Scalable a => (Int -> a) -> Int -> a
memoIO :: Scalable a => (Int -> a) -> IO (Int -> IO a)


-- | Simple forward automatic differentiation. The main reason for
--   supplying this module rather than using one of several similar
--   alternatives available on Hackage is that they all seem to use the
--   following implementation of differentiation of products (in our
--   notation):
--   
--   x * y = mkDif (val x * val y) (df 1 x * y + x * df 1 y)
--   
--   This is elegant but exponential in the order of differentiation, and
--   hence unsuitable for much of validated numerics, which often uses
--   moderately high order derivatives.
--   
--   In our implementation, high order derivatives are still slow, but not
--   as bad. Derivatives of order several hundred can be handled, but in
--   type <a>Double</a> this is often useless; rounding errors dominate the
--   result. In type <tt>IReal</tt>, results are reliable, but the deep
--   nesting of the resulting expressions may lead to excessive precision
--   requirements. Often <a>Rounded</a> is preferrable from an efficiency
--   point of view.
--   
--   No attempt is made to handle functions of several variables
module Data.Number.IReal.FAD

-- | A <a>Dif</a> value is an infinite list consisting of the values of an
--   infinitely differentiable function and all its derivatives, all
--   evaluated at a common point. Polynomials are represented by finite
--   lists, omitting zero derivatives.
newtype Dif a
D :: [a] -> Dif a
con :: Num a => a -> Dif a
var :: Num a => a -> Dif a
mkDif :: a -> Dif a -> Dif a
val :: Num a => Dif a -> a
fromDif :: Num a => Dif a -> [a]
unDif :: (Num a, Num b) => (Dif a -> Dif b) -> a -> b
df :: Int -> Dif a -> Dif a

-- | deriv n f is the n'th derivative of f (with derivative information
--   omitted)
deriv :: (Num a, Num b) => Int -> (Dif a -> Dif b) -> a -> b

-- | derivs f a is the list of allderivatives of f, evaluated at a.
derivs :: (Num a, Num b) => (Dif a -> Dif b) -> a -> [b]
chain :: Num a => (a -> a) -> (Dif a -> Dif a) -> Dif a -> Dif a
rchain :: Num a => (a -> a) -> (Dif a -> Dif a) -> Dif a -> Dif a
r2chain :: Num a => (a -> a) -> (a -> a) -> (Dif a -> Dif a) -> (Dif a -> Dif a) -> Dif a -> Dif a
convs :: Num t => [t] -> [t] -> [t]
instance Show a => Show (Dif a)
instance (Powers a, RealFloat a) => RealFloat (Dif a)
instance (Powers a, RealFrac a) => RealFrac (Dif a)
instance Real a => Real (Dif a)
instance (Num a, Powers a) => Powers (Dif a)
instance (Floating a, Powers a) => Floating (Dif a)
instance (Fractional a, Powers a) => Fractional (Dif a)
instance Num a => Num (Dif a)
instance (Num a, Ord a) => Ord (Dif a)
instance (Num a, Eq a) => Eq (Dif a)
instance VarPrec a => VarPrec (Dif a)

module Data.Number.IReal.IReal
type Precision = Int

-- | A real number/interval is a function from required precision to an
--   integer interval; for numbers the interval is thin (has radius 1).
newtype IReal
IR :: (Precision -> IntegerInterval) -> IReal

-- | Smart constructor; uses an (unfortunately unsafe) memoizing technique
--   for efficiency.
ir :: (Precision -> IntegerInterval) -> IReal

-- | Selector; computes integer interval for given precision.
appr :: IReal -> Precision -> IntegerInterval

-- | prec n x is an interval of width 10^(-n) containing x.
instance VarPrec IReal

module Data.Number.IReal.IRealOperations

-- | Constructs an interval from midpoint and radius.
(+-) :: Rational -> Rational -> IReal

-- | Constructs an interval from end points (which can be given in any
--   order).
(-+-) :: IReal -> IReal -> IReal

-- | Returns left end point of argument.
lower :: IReal -> IReal

-- | Returns radius of argument.
rad :: IReal -> IReal

-- | Returns midpoint of argument.
mid :: IReal -> IReal

-- | Returns right end point of argument.
upper :: IReal -> IReal

-- | Convex hull of a list of intervals.
hull :: [IReal] -> IReal

-- | Tests whether first arg is contained in second, using total tests of
--   given precision.
containedIn :: IReal -> IReal -> Precision -> Bool

-- | Intersection of intervals; empty intersection gives <a>Nothing</a>
intersection :: IReal -> IReal -> Maybe IReal

-- | Division by zero is non-terminating.
toDouble :: IReal -> Double

-- | Equality test for overlapping values is non-terminating.
comp :: IReal -> IReal -> Ordering

-- | Total, approximate equality test. If <tt>x =?= y <a>atDecimals</a>
--   d</tt> returns <a>False</a>, then <tt>x</tt> and <tt>y</tt> are
--   definitely not equal. If it returns <a>True</a>, then the absolute
--   value of their difference is less than <tt>10^(-d)</tt> (but they may
--   be non-equal).
(=?=) :: IReal -> IReal -> Precision -> Bool

-- | Total, approximate inequality test. If <tt>x &lt;! y <a>atDecimals</a>
--   d</tt> returns <a>True</a>, then <tt>x</tt> is definitely smaller than
--   <tt>y</tt>, If it returns <a>False</a>, <tt>x</tt> may still be
--   smaller than <tt>y</tt>, but their difference is then at most
--   <tt>10^(-d)</tt>.
(<!) :: IReal -> IReal -> Precision -> Bool

-- | <tt>x &gt;! y</tt> is the same as <tt>y &lt;! x</tt>.
(>!) :: IReal -> IReal -> Precision -> Bool
showIReal :: Int -> IReal -> String

-- | IReal is an instance of <a>Show</a> but it should be avoided; see
--   introduction. Use <tt>x ? n</tt> to print <tt>x</tt> with <tt>n</tt>
--   decimals.

-- | Prints an <a>IReal</a> with given number of decimals. Rounding error
--   is up to one unit in the last position.
(?) :: IReal -> Int -> IO ()

-- | Prints an <a>IReal</a> in scientific notation with given number of
--   digits. Rounding error is up to one unit in the last position.
(??) :: IReal -> Int -> IO ()

-- | Forces evaluation of second argument to given number of decimals;
--   returns second argument.
force :: Int -> IReal -> IReal
powerSeries :: (Num a1, Integral a, Enum a1) => (Integer -> a1 -> Integer) -> Integer -> (Int -> a) -> IReal -> IReal
g0 :: IReal -> IReal
ps :: (Integer -> Integer) -> Integer -> IReal
halfPi :: IReal
log2 :: IReal
quarterPi :: IReal
instance Show IReal
instance Enum IReal
instance Ord IReal
instance Eq IReal
instance Scalable IReal
instance Powers IReal
instance RealFloat IReal
instance RealFrac IReal
instance Real IReal
instance Floating IReal
instance Fractional IReal
instance Num IReal

module Data.Number.IReal.Generators
data Dig
M :: Dig
Z :: Dig
P :: Dig
newtype Frac
Frac :: [Dig] -> Frac
m :: Frac -> Frac
z :: Frac -> Frac
p :: Frac -> Frac
ftail :: Frac -> Frac
frac :: Gen Frac
nfrac :: Gen Frac
pfrac :: Gen Frac
expand :: [Dig] -> Integer -> Int -> Integer
genIReal :: Gen Integer -> Gen Frac -> Gen IReal

-- | Generates real numbers uniformly distributed over the given interval.
uniformNum :: (Integer, Integer) -> Gen IReal

-- | Generates real intervals of varying width, with midpoints uniformly
--   distributed over given interval.
uniformIval :: (Integer, Integer) -> Gen IReal

-- | Generates random expressions built from values generated by argument
--   generator, arithmetic operators and applications of <a>Floating</a>
--   functions.
exprGen :: Floating a => Gen a -> Gen a
isCauchy :: IReal -> Int -> Int -> Bool

-- | Basic test that the argument is a proper real number (is thin and
--   satisfies Cauchy criterion).
propIsRealNum :: IReal -> Property

-- | Basic test that argument is a proper interval (the end points are
--   proper numbers, with left end smaller than right end).
propIsRealIval :: IReal -> Property
forAllI :: (IReal -> Bool) -> Bool
instance Arbitrary IReal
instance Arbitrary Frac

module Data.Number.IReal.FoldB

-- | Balanced fold, minimizing depth of call tree. Assumes associative
--   operator. Often much more efficient than foldl/foldr when type
--   <tt>a</tt> is <a>IReal</a> and the list is long.
foldb :: (a -> a -> a) -> a -> [a] -> a

-- | Balanced fold for associative operator over non-empty list.
foldb1 :: (a -> a -> a) -> [a] -> a

-- | Balanced sum, reorganized for (much) better efficiency when type
--   <tt>a</tt> is <a>IReal</a> and the list is long.
bsum :: Num a => [a] -> a
foldb' :: (a -> a -> a) -> a -> [a] -> a
isum' :: [IReal] -> IReal

-- | 1st arg should be length of 2nd arg.
isumN' :: Integer -> [IReal] -> IReal


-- | This module provides the type <a>IReal</a>, the values of which are
--   real numbers and intervals, with potentially unbounded precision
--   arithmetic and elementary functions.
--   
--   <a>IReal</a> is an instance of the standard numeric classes, so we can
--   interact in ghci as follows:
--   
--   <pre>
--   &gt;&gt;&gt; exp 0.5 + pi * sqrt ( 2 + sin 1) ? 50
--   6.94439823755032768935865535478209938180612180886848
--   </pre>
--   
--   The right operand to the operator <a>?</a> indicates the number of
--   decimals to display in the result. Using <a>?</a> is the default way
--   to print values; the <a>Show</a> instance is not recommended to use,
--   since the redundant rounding policy implies that we cannot guarantee
--   to generate equal string representations for equal values.
--   
--   For simple expressions like the above, one can request a thousand
--   decimals with more or less instantaneous result; also ten thousand
--   decimals is easy (less than a second on a typical laptop).
--   
--   Here is an example with interval arguments:
--   
--   <pre>
--   &gt;&gt;&gt; exp (0.5 +- 0.001) + pi * sqrt ( 2 + sin (1 +- 0.003)) ? 30
--   6.94[| 1236147625 .. 7554488225 |]
--   </pre>
--   
--   The result is displayed in a non-standard but hopefully easily
--   interpreted notation. We will not get the requested 30 decimals here;
--   interval upper and lower bounds are displayed with at most 10
--   distinguishing digits. The result of an interval computation is
--   conservative; it includes all possible values of the expression for
--   inputs in the given intervals. As always in interval arithmetic,
--   results may be unduly pessimistic because of the dependency problem.
--   
--   As a third example, consider
--   
--   <pre>
--   &gt;&gt;&gt; log (2 +- 1e-50) ? 30
--   0.693147180559945309417232121458
--   </pre>
--   
--   The result is obviously an interval, not a number, but displayed with
--   30 decimals it looks just like a real number. Conversely, a real
--   number is an infinite object and we can only ever compute an
--   approximation to it. So a finitely printed <a>IReal</a> value can
--   always be thought of as denoting an interval; there is an error margin
--   of one unit in the last displayed digit. These remarks give a first
--   intuition for why it may be fruitful to merge real numbers and
--   intervals into one type.
--   
--   <a>IReal</a> is also an instance of <a>Eq</a> and <a>Ord</a>; these
--   are, however, non-total for computability reasons; evaluation of e.g.
--   <tt>sin pi == 0</tt> at type <a>IReal</a> will not terminate.
--   
--   At the github site <a>https://github.com/sydow/ireal.git</a> one can
--   find a QuickCheck testsuite (in directory tests), a paper with
--   documentation (in directory doc) and a number of small applications
--   (in directory applications).
module Data.Number.IReal

-- | A real number/interval is a function from required precision to an
--   integer interval; for numbers the interval is thin (has radius 1).
data IReal
toDouble :: IReal -> Double

-- | Prints an <a>IReal</a> with given number of decimals. Rounding error
--   is up to one unit in the last position.
(?) :: IReal -> Int -> IO ()

-- | Prints an <a>IReal</a> in scientific notation with given number of
--   digits. Rounding error is up to one unit in the last position.
(??) :: IReal -> Int -> IO ()
showIReal :: Int -> IReal -> String

-- | Total, approximate inequality test. If <tt>x &lt;! y <a>atDecimals</a>
--   d</tt> returns <a>True</a>, then <tt>x</tt> is definitely smaller than
--   <tt>y</tt>, If it returns <a>False</a>, <tt>x</tt> may still be
--   smaller than <tt>y</tt>, but their difference is then at most
--   <tt>10^(-d)</tt>.
(<!) :: IReal -> IReal -> Precision -> Bool

-- | <tt>x &gt;! y</tt> is the same as <tt>y &lt;! x</tt>.
(>!) :: IReal -> IReal -> Precision -> Bool

-- | Total, approximate equality test. If <tt>x =?= y <a>atDecimals</a>
--   d</tt> returns <a>False</a>, then <tt>x</tt> and <tt>y</tt> are
--   definitely not equal. If it returns <a>True</a>, then the absolute
--   value of their difference is less than <tt>10^(-d)</tt> (but they may
--   be non-equal).
(=?=) :: IReal -> IReal -> Precision -> Bool

-- | Operator allowing function expecting binary precision to be applied to
--   decimal ditto.
atDecimals :: (Int -> a) -> Int -> a

-- | Constructs an interval from midpoint and radius.
(+-) :: Rational -> Rational -> IReal

-- | Constructs an interval from end points (which can be given in any
--   order).
(-+-) :: IReal -> IReal -> IReal

-- | Convex hull of a list of intervals.
hull :: [IReal] -> IReal

-- | Intersection of intervals; empty intersection gives <a>Nothing</a>
intersection :: IReal -> IReal -> Maybe IReal

-- | Returns left end point of argument.
lower :: IReal -> IReal

-- | Returns right end point of argument.
upper :: IReal -> IReal

-- | Returns midpoint of argument.
mid :: IReal -> IReal

-- | Returns radius of argument.
rad :: IReal -> IReal

-- | Tests whether first arg is contained in second, using total tests of
--   given precision.
containedIn :: IReal -> IReal -> Precision -> Bool

-- | Balanced fold, minimizing depth of call tree. Assumes associative
--   operator. Often much more efficient than foldl/foldr when type
--   <tt>a</tt> is <a>IReal</a> and the list is long.
foldb :: (a -> a -> a) -> a -> [a] -> a

-- | Balanced fold for associative operator over non-empty list.
foldb1 :: (a -> a -> a) -> [a] -> a

-- | Balanced sum, reorganized for (much) better efficiency when type
--   <tt>a</tt> is <a>IReal</a> and the list is long.
bsum :: Num a => [a] -> a
foldb' :: (a -> a -> a) -> a -> [a] -> a

-- | 1st arg should be length of 2nd arg.
isumN' :: Integer -> [IReal] -> IReal
isum' :: [IReal] -> IReal

-- | A <a>Dif</a> value is an infinite list consisting of the values of an
--   infinitely differentiable function and all its derivatives, all
--   evaluated at a common point. Polynomials are represented by finite
--   lists, omitting zero derivatives.
newtype Dif a
D :: [a] -> Dif a

-- | deriv n f is the n'th derivative of f (with derivative information
--   omitted)
deriv :: (Num a, Num b) => Int -> (Dif a -> Dif b) -> a -> b

-- | derivs f a is the list of allderivatives of f, evaluated at a.
derivs :: (Num a, Num b) => (Dif a -> Dif b) -> a -> [b]
con :: Num a => a -> Dif a
var :: Num a => a -> Dif a
unDif :: (Num a, Num b) => (Dif a -> Dif b) -> a -> b
val :: Num a => Dif a -> a

-- | Generates real numbers uniformly distributed over the given interval.
uniformNum :: (Integer, Integer) -> Gen IReal

-- | Generates real intervals of varying width, with midpoints uniformly
--   distributed over given interval.
uniformIval :: (Integer, Integer) -> Gen IReal

-- | Generates random expressions built from values generated by argument
--   generator, arithmetic operators and applications of <a>Floating</a>
--   functions.
exprGen :: Floating a => Gen a -> Gen a

-- | Basic test that the argument is a proper real number (is thin and
--   satisfies Cauchy criterion).
propIsRealNum :: IReal -> Property

-- | Basic test that argument is a proper interval (the end points are
--   proper numbers, with left end smaller than right end).
propIsRealIval :: IReal -> Property

-- | Forces evaluation of second argument to given number of decimals;
--   returns second argument.
force :: Int -> IReal -> IReal

-- | Converts precisions from decimal to binary.
dec2bits :: Int -> Int

-- | Base 2 logarithm of argument, rounded downwards.
lg2 :: Integer -> Int

-- | Common functions collected to allow for instances which handle
--   dependency problems for intervals, and for automatic differentiation.
class Num a => Powers a where sq = flip pow 2 pow x n = x ^ n
sq :: Powers a => a -> a
pow :: Powers a => a -> Int -> a

-- | Scaling. <tt>scale x n</tt> computes <tt>x * 2^n</tt> using bit
--   shifts.
class Scalable a
scale :: Scalable a => a -> Int -> a
class VarPrec a where prec d = precB (dec2bits d)
prec :: VarPrec a => Int -> a -> a
precB :: VarPrec a => Int -> a -> a


-- | This module uses type-level literals to provide types <a>Rounded</a>
--   <i>lit</i> where <i>lit</i> is a positive integer literal. Values of
--   this type are <a>IReal</a>s where (sub-)expressions are computed with
--   a precision of at most <i>lit</i> decimals. This is very different
--   from multi-precision floating point numbers; <a>Rounded</a> values are
--   intervals, indicating the precision in the computed result.
--   
--   To use this module in ghci you must <tt>:set -XDataKinds</tt>. Example
--   usage:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Number.IReal.FAD
--   
--   &gt;&gt;&gt; import Data.Number.IReal.Rounded
--   
--   &gt;&gt;&gt; let f x = cos x * cos (2*x) + sin x * sin (2 * x)
--   
--   &gt;&gt;&gt; :set +s
--   
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; (deriv 200 f 1 :: Rounded 120) ? 40
--   0.54030230586813971740[| 0803811043 .. 1069403842 |]
--   (0.13 secs, 114501688 bytes)
--   
--   &gt;&gt;&gt; (deriv 200 f 1 :: Rounded 150) ? 40
--   0.5403023058681397174009366074429766037324
--   (0.13 secs, 120063280 bytes)
--   </pre>
--   
--   Note that function f is in fact an obfuscated version of the cosine
--   function, using a trigonometric identity on cos (2x - x). So we can
--   check the result, but the derivatives are computed using the rules for
--   differentiation.
--   
--   We compute the 200'th derivative of f, evaluated at 1 (i.e., cos 1)
--   with 40 significant digits. First we try to do this at type Rounded
--   120, i.e. with 120 decimals in all intermediate computations. As we
--   see, this is not precision enough; we get as result an interval of
--   width circa 2e-22. Redoing it at type Rounded 150 gives sufficient
--   precision.
module Data.Number.IReal.Rounded
newtype Rounded p
R :: IReal -> Rounded p
unRound :: Rounded p -> IReal
class Precision p
precision :: Precision p => proxy p -> Int
r :: Precision p => IReal -> Rounded p
proxyPrecision :: Rounded p -> Proxy p
(?) :: Rounded k t -> Int -> IO ()
(??) :: Rounded k t -> Int -> IO ()
(=?=) :: Precision p => Rounded p -> Rounded p -> Int -> Bool
(>!) :: Precision p => Rounded p -> Rounded p -> Int -> Bool
(<!) :: Precision p => Rounded p -> Rounded p -> Int -> Bool
(+-) :: Precision p => Rational -> Rational -> Rounded p
(-+-) :: Precision p => Rounded p -> Rounded p -> Rounded p
showIReal :: Precision p => Int -> Rounded p -> String
mid :: Precision p => Rounded p -> Rounded p
upper :: Precision p => Rounded p -> Rounded p
lower :: Precision p => Rounded p -> Rounded p
rad :: Precision p => Rounded p -> Rounded p
hull :: Precision p => [Rounded p] -> Rounded p
containedIn :: Precision p => Rounded p -> Rounded p -> Int -> Bool
intersection :: Precision p => Rounded p -> Rounded p -> Maybe (Rounded p)
instance Precision p => Scalable (Rounded p)
instance Precision p => Ord (Rounded p)
instance Precision p => Eq (Rounded p)
instance Precision p => Floating (Rounded p)
instance Precision p => Show (Rounded p)
instance Precision p => Fractional (Rounded p)
instance Precision p => Num (Rounded p)
instance KnownNat n => Precision n
instance Precision p => Powers (Rounded p)
instance Precision p => VarPrec (Rounded p)
