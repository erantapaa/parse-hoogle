-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings to the LLVM compiler toolkit.
--   
--   High-level bindings to the LLVM compiler toolkit.
--   
--   <ul>
--   <li>New in 3.0.0.0: The low-level bindings have been split into the
--   llvm-base package.</li>
--   <li>New in 0.9.1.1: Builds against LLVM 2.9.</li>
--   <li>New in 0.9.1.0: Util.Memory for memory related intrinsics.</li>
--   <li>New in 0.9.0.0: Adapted to LLVM 2.8 (removed support for Union
--   types).</li>
--   </ul>
@package llvm
@version 3.0.1.0

module LLVM.Util.Foreign
with :: Storable a => a -> (Ptr a -> IO b) -> IO b
alloca :: Storable a => (Ptr a -> IO b) -> IO b
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b

module LLVM.Util.Optimize

-- | Result tells whether the module was modified by any of the passes.
optimizeModule :: Int -> Module -> IO Bool


-- | The LLVM (Low Level Virtual Machine) is virtual machine at a machine
--   code level. It supports both stand alone code generation and JITing.
--   The Haskell llvm package is a (relatively) high level interface to the
--   LLVM. The high level interface makes it easy to construct LLVM code.
--   There is also an interface to the raw low level LLVM API as exposed by
--   the LLVM C interface.
--   
--   LLVM code is organized into modules (type <a>Module</a>). Each module
--   contains a number of global variables and functions (type
--   <a>Function</a>). Each functions has a number of basic blocks (type
--   <a>BasicBlock</a>). Each basic block has a number instructions, where
--   each instruction produces a value (type <a>Value</a>).
--   
--   Unlike assembly code for a real processor the assembly code for LLVM
--   is in SSA (Static Single Assignment) form. This means that each
--   instruction generates a new bound variable which may not be assigned
--   again. A consequence of this is that where control flow joins from
--   several execution paths there has to be a phi pseudo instruction if
--   you want different variables to be joined into one.
--   
--   The definition of several of the LLVM entities (<a>Module</a>,
--   <a>Function</a>, and <a>BasicBlock</a>) follow the same pattern. First
--   the entity has to be created using <tt>newX</tt> (where <tt>X</tt> is
--   one of <tt>Module</tt>, <tt>Function</tt>, or <tt>BasicBlock</tt>),
--   then at some later point it has to given its definition using
--   <tt>defineX</tt>. The reason for splitting the creation and definition
--   is that you often need to be able to refer to an entity before giving
--   it's body, e.g., in two mutually recursive functions. The the
--   <tt>newX</tt> and <tt>defineX</tt> function can also be done at the
--   same time by using <tt>createX</tt>. Furthermore, an explicit name can
--   be given to an entity by the <tt>newNamedX</tt> function; the
--   <tt>newX</tt> function just generates a fresh name.
module LLVM.Core

-- | Initialize jitter to the native target. The operation is idempotent.
initializeNativeTarget :: IO ()

-- | Type of top level modules.
data Module

-- | Create a new module.
newModule :: IO Module

-- | Create a new explicitely named module.
newNamedModule :: String -> IO Module

-- | Give the body for a module.
defineModule :: Module -> CodeGenModule a -> IO a

-- | Free all storage related to a module. *Note*, this is a dangerous
--   call, since referring to the module after this call is an error. The
--   reason for the explicit call to free the module instead of an
--   automatic lifetime management is that modules have a somewhat
--   complicated ownership. Handing a module to a module provider changes
--   the ownership of the module, and the module provider will free the
--   module when necessary.
destroyModule :: Module -> IO ()

-- | Create a new module with the given body.
createModule :: CodeGenModule a -> IO a

-- | A module provider is used by the code generator to get access to a
--   module.
data ModuleProvider

-- | Turn a module into a module provider.
createModuleProviderForExistingModule :: Module -> IO ModuleProvider

-- | Manage compile passes.
data PassManager

-- | Create a pass manager.
createPassManager :: IO PassManager

-- | Create a pass manager for a module.
createFunctionPassManager :: ModuleProvider -> IO PassManager

-- | Write a module to a file.
writeBitcodeToFile :: String -> Module -> IO ()

-- | Read a module from a file.
readBitcodeFromFile :: String -> IO Module
getModuleValues :: Module -> IO [(String, ModuleValue)]
getFunctions :: Module -> IO [(String, Value)]
getGlobalVariables :: Module -> IO [(String, Value)]
data ModuleValue
castModuleValue :: IsType a => ModuleValue -> Maybe (Value a)
data BinOpDesc
BOAdd :: BinOpDesc
BOAddNuw :: BinOpDesc
BOAddNsw :: BinOpDesc
BOAddNuwNsw :: BinOpDesc
BOFAdd :: BinOpDesc
BOSub :: BinOpDesc
BOSubNuw :: BinOpDesc
BOSubNsw :: BinOpDesc
BOSubNuwNsw :: BinOpDesc
BOFSub :: BinOpDesc
BOMul :: BinOpDesc
BOMulNuw :: BinOpDesc
BOMulNsw :: BinOpDesc
BOMulNuwNsw :: BinOpDesc
BOFMul :: BinOpDesc
BOUDiv :: BinOpDesc
BOSDiv :: BinOpDesc
BOSDivExact :: BinOpDesc
BOFDiv :: BinOpDesc
BOURem :: BinOpDesc
BOSRem :: BinOpDesc
BOFRem :: BinOpDesc
BOShL :: BinOpDesc
BOLShR :: BinOpDesc
BOAShR :: BinOpDesc
BOAnd :: BinOpDesc
BOOr :: BinOpDesc
BOXor :: BinOpDesc
data InstrDesc
IDRet :: TypeDesc -> ArgDesc -> InstrDesc
IDRetVoid :: InstrDesc
IDBrCond :: ArgDesc -> ArgDesc -> ArgDesc -> InstrDesc
IDBrUncond :: ArgDesc -> InstrDesc
IDSwitch :: [(ArgDesc, ArgDesc)] -> InstrDesc
IDIndirectBr :: InstrDesc
IDInvoke :: InstrDesc
IDUnwind :: InstrDesc
IDUnreachable :: InstrDesc
IDBinOp :: BinOpDesc -> TypeDesc -> ArgDesc -> ArgDesc -> InstrDesc
IDAlloca :: TypeDesc -> Int -> Int -> InstrDesc
IDLoad :: TypeDesc -> ArgDesc -> InstrDesc
IDStore :: TypeDesc -> ArgDesc -> ArgDesc -> InstrDesc
IDGetElementPtr :: TypeDesc -> [ArgDesc] -> InstrDesc
IDTrunc :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDZExt :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDSExt :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDFPtoUI :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDFPtoSI :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDUItoFP :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDSItoFP :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDFPTrunc :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDFPExt :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDPtrToInt :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDIntToPtr :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDBitcast :: TypeDesc -> TypeDesc -> ArgDesc -> InstrDesc
IDICmp :: IntPredicate -> ArgDesc -> ArgDesc -> InstrDesc
IDFCmp :: FPPredicate -> ArgDesc -> ArgDesc -> InstrDesc
IDPhi :: TypeDesc -> [(ArgDesc, ArgDesc)] -> InstrDesc
IDCall :: TypeDesc -> ArgDesc -> [ArgDesc] -> InstrDesc
IDSelect :: TypeDesc -> ArgDesc -> ArgDesc -> InstrDesc
IDUserOp1 :: InstrDesc
IDUserOp2 :: InstrDesc
IDVAArg :: InstrDesc
IDExtractElement :: InstrDesc
IDInsertElement :: InstrDesc
IDShuffleVector :: InstrDesc
IDExtractValue :: InstrDesc
IDInsertValue :: InstrDesc
IDInvalidOp :: InstrDesc
data ArgDesc
AV :: String -> ArgDesc
AI :: Int -> ArgDesc
AL :: String -> ArgDesc
AE :: ArgDesc
getInstrDesc :: ValueRef -> IO (String, InstrDesc)

-- | Return from the current function with the given value. Use () as the
--   return value for what would be a void function is C.
ret :: Ret a r => a -> CodeGenFunction r Terminate

-- | Branch to the first basic block if the boolean is true, otherwise to
--   the second basic block.
condBr :: Value Bool -> BasicBlock -> BasicBlock -> CodeGenFunction r Terminate

-- | Unconditionally branch to the given basic block.
br :: BasicBlock -> CodeGenFunction r Terminate

-- | Branch table instruction.
switch :: IsInteger a => Value a -> BasicBlock -> [(ConstValue a, BasicBlock)] -> CodeGenFunction r Terminate

-- | Call a function with exception handling.
invoke :: CallArgs f g r => BasicBlock -> BasicBlock -> Function f -> g

-- | Call a function with exception handling. This also sets the calling
--   convention of the call to the function. As LLVM itself defines, if the
--   calling conventions of the calling <i>instruction</i> and the function
--   being <i>called</i> are different, undefined behavior results.
invokeWithConv :: CallArgs f g r => CallingConvention -> BasicBlock -> BasicBlock -> Function f -> g

-- | Unwind the call stack until a function call performed with
--   <a>invoke</a> is reached. I.e., throw a non-local exception. unwind ::
--   CodeGenFunction r Terminate unwind = do withCurrentBuilder_
--   FFI.buildUnwind return terminate
--   
--   Inform the code generator that this code can never be reached.
unreachable :: CodeGenFunction r Terminate
add :: (IsArithmetic c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
sub :: (IsArithmetic c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
mul :: (IsArithmetic c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
neg :: IsArithmetic a => Value a -> CodeGenFunction r (Value a)
iadd :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
isub :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
imul :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
ineg :: IsInteger a => Value a -> CodeGenFunction r (Value a)
fadd :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
fsub :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
fmul :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
fneg :: IsFloating a => Value a -> CodeGenFunction r (Value a)

-- | signed or unsigned integer division depending on the type
idiv :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)

-- | signed or unsigned remainder depending on the type
irem :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
udiv :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
sdiv :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)

-- | Floating point division.
fdiv :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
urem :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
srem :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)

-- | Floating point remainder.
frem :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
shl :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
lshr :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
ashr :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
and :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
or :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
xor :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
inv :: IsInteger a => Value a -> CodeGenFunction r (Value a)

-- | Get a value from a vector.
extractelement :: Pos n => Value (Vector n a) -> Value Word32 -> CodeGenFunction r (Value a)

-- | Insert a value into a vector, nondestructive.
insertelement :: Pos n => Value (Vector n a) -> Value a -> Value Word32 -> CodeGenFunction r (Value (Vector n a))

-- | Permute vector.
shufflevector :: (Pos n, Pos m) => Value (Vector n a) -> Value (Vector n a) -> ConstValue (Vector m Word32) -> CodeGenFunction r (Value (Vector m a))

-- | Get a value from an aggregate.
extractvalue :: GetValue agg i a => Value agg -> i -> CodeGenFunction r (Value a)

-- | Insert a value into an aggregate, nondestructive.
insertvalue :: GetValue agg i a => Value agg -> Value a -> i -> CodeGenFunction r (Value agg)

-- | Allocate heap memory.
malloc :: IsSized a s => CodeGenFunction r (Value (Ptr a))

-- | Allocate heap (array) memory.
arrayMalloc :: (IsSized a n, AllocArg s) => s -> CodeGenFunction r (Value (Ptr a))

-- | Allocate stack memory.
alloca :: IsSized a s => CodeGenFunction r (Value (Ptr a))

-- | Allocate stack (array) memory.
arrayAlloca :: (IsSized a n, AllocArg s) => s -> CodeGenFunction r (Value (Ptr a))

-- | Free heap memory.
free :: IsType a => Value (Ptr a) -> CodeGenFunction r ()

-- | Load a value from memory.
load :: Value (Ptr a) -> CodeGenFunction r (Value a)

-- | Store a value in memory
store :: Value a -> Value (Ptr a) -> CodeGenFunction r ()

-- | Address arithmetic. See LLVM description. The index is a nested tuple
--   of the form <tt>(i1,(i2,( ... ())))</tt>. (This is without a doubt the
--   most confusing LLVM instruction, but the types help.)
getElementPtr :: (GetElementPtr o i n, IsIndexArg a) => Value (Ptr o) -> (a, i) -> CodeGenFunction r (Value (Ptr n))

-- | Like getElementPtr, but with an initial index that is 0. This is
--   useful since any pointer first need to be indexed off the pointer, and
--   then into its actual value. This first indexing is often with 0.
getElementPtr0 :: GetElementPtr o i n => Value (Ptr o) -> i -> CodeGenFunction r (Value (Ptr n))

-- | Truncate a value to a shorter bit width.
trunc :: (IsInteger a, IsInteger b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, sa :>: sb) => Value a -> CodeGenFunction r (Value b)

-- | Zero extend a value to a wider width.
zext :: (IsInteger a, IsInteger b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, sa :<: sb) => Value a -> CodeGenFunction r (Value b)

-- | Sign extend a value to wider width.
sext :: (IsInteger a, IsInteger b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, sa :<: sb) => Value a -> CodeGenFunction r (Value b)

-- | Truncate a floating point value.
fptrunc :: (IsFloating a, IsFloating b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, sa :>: sb) => Value a -> CodeGenFunction r (Value b)

-- | Extend a floating point value.
fpext :: (IsFloating a, IsFloating b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, sa :<: sb) => Value a -> CodeGenFunction r (Value b)

-- | Convert a floating point value to an unsigned integer.
fptoui :: (IsFloating a, IsInteger b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert a floating point value to a signed integer.
fptosi :: (IsFloating a, IsInteger b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert a floating point value to an integer. It is mapped to
--   <tt>fptosi</tt> or <tt>fptoui</tt> depending on the type <tt>a</tt>.
fptoint :: (IsFloating a, IsInteger b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert an unsigned integer to a floating point value.
uitofp :: (IsInteger a, IsFloating b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert a signed integer to a floating point value.
sitofp :: (IsInteger a, IsFloating b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert an integer to a floating point value. It is mapped to
--   <tt>sitofp</tt> or <tt>uitofp</tt> depending on the type <tt>a</tt>.
inttofp :: (IsInteger a, IsFloating b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert a pointer to an integer.
ptrtoint :: (IsInteger b, IsPrimitive b) => Value (Ptr a) -> CodeGenFunction r (Value b)

-- | Convert an integer to a pointer.
inttoptr :: (IsInteger a, IsType b) => Value a -> CodeGenFunction r (Value (Ptr b))

-- | Convert between to values of the same size by just copying the bit
--   pattern.
bitcast :: (IsFirstClass a, IsFirstClass b, IsSized a sa, IsSized b sb, sa :==: sb) => Value a -> CodeGenFunction r (Value b)

-- | Same as bitcast but instead of the '(:==:)' type class it uses type
--   unification. This way, properties like reflexivity, symmetry and
--   transitivity are obvious to the Haskell compiler.
bitcastUnify :: (IsFirstClass a, IsFirstClass b, IsSized a s, IsSized b s) => Value a -> CodeGenFunction r (Value b)
data CmpPredicate

-- | equal
CmpEQ :: CmpPredicate

-- | not equal
CmpNE :: CmpPredicate

-- | greater than
CmpGT :: CmpPredicate

-- | greater or equal
CmpGE :: CmpPredicate

-- | less than
CmpLT :: CmpPredicate

-- | less or equal
CmpLE :: CmpPredicate
data IntPredicate

-- | equal
IntEQ :: IntPredicate

-- | not equal
IntNE :: IntPredicate

-- | unsigned greater than
IntUGT :: IntPredicate

-- | unsigned greater or equal
IntUGE :: IntPredicate

-- | unsigned less than
IntULT :: IntPredicate

-- | unsigned less or equal
IntULE :: IntPredicate

-- | signed greater than
IntSGT :: IntPredicate

-- | signed greater or equal
IntSGE :: IntPredicate

-- | signed less than
IntSLT :: IntPredicate

-- | signed less or equal
IntSLE :: IntPredicate
data FPPredicate

-- | Always false (always folded)
FPFalse :: FPPredicate

-- | True if ordered and equal
FPOEQ :: FPPredicate

-- | True if ordered and greater than
FPOGT :: FPPredicate

-- | True if ordered and greater than or equal
FPOGE :: FPPredicate

-- | True if ordered and less than
FPOLT :: FPPredicate

-- | True if ordered and less than or equal
FPOLE :: FPPredicate

-- | True if ordered and operands are unequal
FPONE :: FPPredicate

-- | True if ordered (no nans)
FPORD :: FPPredicate

-- | True if unordered: isnan(X) | isnan(Y)
FPUNO :: FPPredicate

-- | True if unordered or equal
FPUEQ :: FPPredicate

-- | True if unordered or greater than
FPUGT :: FPPredicate

-- | True if unordered, greater than, or equal
FPUGE :: FPPredicate

-- | True if unordered or less than
FPULT :: FPPredicate

-- | True if unordered, less than, or equal
FPULE :: FPPredicate

-- | True if unordered or not equal
FPUNE :: FPPredicate

-- | Always true (always folded)
FPT :: FPPredicate
class CmpRet c d | c -> d

-- | Compare values of ordered types and choose predicates according to the
--   compared types. Floating point numbers are compared in "ordered" mode,
--   that is <tt>NaN</tt> operands yields <a>False</a> as result. Pointers
--   are compared unsigned. These choices are consistent with comparison in
--   plain Haskell.
cmp :: (CmpOp a b c d, CmpRet c d) => CmpPredicate -> a -> b -> CodeGenFunction r (Value d)
pcmp :: (CmpOp a b (Ptr c) d, CmpRet (Ptr c) d) => IntPredicate -> a -> b -> CodeGenFunction r (Value d)

-- | Compare integers.
icmp :: (IsIntegerOrPointer c, CmpOp a b c d, CmpRet c d) => IntPredicate -> a -> b -> CodeGenFunction r (Value d)

-- | Compare floating point values.
fcmp :: (IsFloating c, CmpOp a b c d, CmpRet c d) => FPPredicate -> a -> b -> CodeGenFunction r (Value d)

-- | Select between two values depending on a boolean.
select :: (IsFirstClass a, CmpRet a b) => Value b -> Value a -> Value a -> CodeGenFunction r (Value a)

-- | Join several variables (virtual registers) from different basic blocks
--   into one. All of the variables in the list are joined. See also
--   <a>addPhiInputs</a>.
phi :: IsFirstClass a => [(Value a, BasicBlock)] -> CodeGenFunction r (Value a)

-- | Add additional inputs to an existing phi node. The reason for this
--   instruction is that sometimes the structure of the code makes it
--   impossible to have all variables in scope at the point where you need
--   the phi node.
addPhiInputs :: IsFirstClass a => Value a -> [(Value a, BasicBlock)] -> CodeGenFunction r ()

-- | Call a function with the given arguments. The <a>call</a> instruction
--   is variadic, i.e., the number of arguments it takes depends on the
--   type of <i>f</i>.
call :: CallArgs f g r => Function f -> g

-- | Call a function with the given arguments. The <a>call</a> instruction
--   is variadic, i.e., the number of arguments it takes depends on the
--   type of <i>f</i>. This also sets the calling convention of the call to
--   the function. As LLVM itself defines, if the calling conventions of
--   the calling <i>instruction</i> and the function being <i>called</i>
--   are different, undefined behavior results.
callWithConv :: CallArgs f g r => CallingConvention -> Function f -> g
type Terminate = ()

-- | Acceptable arguments to the <a>ret</a> instruction.
class Ret a r

-- | Acceptable arguments to <a>call</a>.
class CallArgs f g r | g -> r f, f r -> g

-- | Acceptable arguments to arithmetic binary instructions.
class ABinOp a b c | a b -> c

-- | Acceptable operands to comparison instructions.
class CmpOp a b c d | a b -> c
class FunctionArgs f g r | f -> g r, g r -> f

-- | This class is just to simplify contexts.
class FunctionArgs (IO a) (CodeGenFunction a ()) a => FunctionRet a
class IsConst a

-- | Acceptable argument to array memory allocation.
class AllocArg a

-- | Acceptable arguments to <tt>getElementPointer</tt>.
class GetElementPtr optr ixs nptr | optr ixs -> nptr

-- | Acceptable single index to <tt>getElementPointer</tt>.
class IsIndexArg a

-- | Acceptable arguments to <a>extractvalue</a> and <a>insertvalue</a>.
class GetValue agg ix el | agg ix -> el

-- | The <a>IsType</a> class classifies all types that have an LLVM
--   representation.
class IsType a
typeDesc :: IsType a => a -> TypeDesc
class StructFields as

-- | Naturals (Positives and zero)
class NatI n => Nat n

-- | Positives (Naturals without zero)
class PosI n => Pos n

-- | Arithmetic types, i.e., integral and floating types.
class IsFirstClass a => IsArithmetic a
arithmeticType :: IsArithmetic a => ArithmeticType a
data ArithmeticType a
IntegerType :: ArithmeticType a
FloatingType :: ArithmeticType a

-- | Integral types.
class (IsArithmetic a, IsIntegerOrPointer a) => IsInteger a

-- | Integral or pointer type.
class IsIntegerOrPointer a

-- | Floating types.
class IsArithmetic a => IsFloating a

-- | Primitive types.
class NumberOfElements D1 a => IsPrimitive a

-- | First class types, i.e., the types that can be passed as arguments,
--   etc.
class IsType a => IsFirstClass a

-- | Types with a fixed size.
class (IsType a, Pos s) => IsSized a s | a -> s

-- | Function type.
class IsType a => IsFunction a

-- | Number of elements for instructions that handle both primitive and
--   vector types
class IsType a => NumberOfElements n a | a -> n
type UnknownSize = D99
type :& a as = (a, as)
(&) :: a -> as -> a :& as

-- | Type descriptor, used to convey type information through the LLVM API.
data TypeDesc
TDFloat :: TypeDesc
TDDouble :: TypeDesc
TDFP128 :: TypeDesc
TDVoid :: TypeDesc
TDInt :: Bool -> Integer -> TypeDesc
TDArray :: Integer -> TypeDesc -> TypeDesc
TDVector :: Integer -> TypeDesc -> TypeDesc
TDPtr :: TypeDesc -> TypeDesc
TDFunction :: Bool -> [TypeDesc] -> TypeDesc -> TypeDesc
TDLabel :: TypeDesc
TDStruct :: [TypeDesc] -> Bool -> TypeDesc
TDInvalidType :: TypeDesc
isFloating :: IsArithmetic a => a -> Bool
isSigned :: IsInteger a => a -> Bool
typeRef :: IsType a => a -> TypeRef
typeName :: IsType a => a -> String
typeDesc2 :: TypeRef -> IO TypeDesc

-- | The <a>VarArgs</a> type is a placeholder for the real <a>IO</a> type
--   that can be obtained with <tt>castVarArgs</tt>.
data VarArgs a

-- | Define what vararg types are permissible.
class CastVarArgs a b

-- | Variable sized signed integer. The <i>n</i> parameter should belong to
--   <tt>PosI</tt>.
newtype IntN n
IntN :: Integer -> IntN n

-- | Variable sized unsigned integer. The <i>n</i> parameter should belong
--   to <tt>PosI</tt>.
newtype WordN n
WordN :: Integer -> WordN n

-- | 128 bit floating point.
newtype FP128
FP128 :: Rational -> FP128

-- | Fixed sized arrays, the array size is encoded in the <i>n</i>
--   parameter.
newtype Array n a
Array :: [a] -> Array n a

-- | Fixed sized vector, the array size is encoded in the <i>n</i>
--   parameter.
newtype Vector n a
Vector :: [a] -> Vector n a

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a :: * -> *

-- | Label type, produced by a basic block.
data Label

-- | Struct types; a list (nested tuple) of component types.
newtype Struct a
Struct :: a -> Struct a
newtype PackedStruct a
PackedStruct :: a -> PackedStruct a
data Value a
data ConstValue a
valueOf :: IsConst a => a -> Value a
value :: ConstValue a -> Value a
zero :: IsType a => ConstValue a
allOnes :: IsInteger a => ConstValue a
undef :: IsType a => ConstValue a
createString :: String -> TGlobal (Array n Word8)
createStringNul :: String -> TGlobal (Array n Word8)
withString :: WithString a => String -> (forall n. Nat n => Global (Array n Word8) -> a) -> a
withStringNul :: WithString a => String -> (forall n. Nat n => Global (Array n Word8) -> a) -> a

-- | Make a constant vector. Replicates or truncates the list to get length
--   <i>n</i>.
constVector :: Pos n => [ConstValue a] -> ConstValue (Vector n a)

-- | Make a constant array. Replicates or truncates the list to get length
--   <i>n</i>.
constArray :: (IsSized a s, Nat n) => [ConstValue a] -> ConstValue (Array n a)

-- | Make a constant struct.
constStruct :: IsConstStruct c a => c -> ConstValue (Struct a)

-- | Make a constant packed struct.
constPackedStruct :: IsConstStruct c a => c -> ConstValue (PackedStruct a)
toVector :: MkVector va n a => va -> Vector n a
fromVector :: MkVector va n a => Vector n a -> va

-- | Make a constant vector. Replicates or truncates the list to get length
--   <i>n</i>. This behaviour is consistent with that of
--   <a>constVector</a>.
vector :: Pos n => [a] -> Vector n a
data CodeGenFunction r a
data CodeGenModule a

-- | A function is simply a pointer to the function.
type Function a = Value (Ptr a)

-- | Create a new function. Use <a>newNamedFunction</a> to create a
--   function with external linkage, since it needs a known name.
newFunction :: IsFunction a => Linkage -> CodeGenModule (Function a)

-- | Create a new named function.
newNamedFunction :: IsFunction a => Linkage -> String -> CodeGenModule (Function a)

-- | Define a function body. The basic block returned by the function is
--   the function entry point.
defineFunction :: FunctionArgs f g r => Function f -> g -> CodeGenModule ()

-- | Create a new function with the given body.
createFunction :: (IsFunction f, FunctionArgs f g r) => Linkage -> g -> CodeGenModule (Function f)

-- | Create a new function with the given body.
createNamedFunction :: (IsFunction f, FunctionArgs f g r) => Linkage -> String -> g -> CodeGenModule (Function f)

-- | Set the calling convention of a function. By default it is the C
--   calling convention.
setFuncCallConv :: Function a -> CallingConvention -> CodeGenModule ()
type TFunction a = CodeGenModule (Function a)

-- | Allows you to define part of a module while in the middle of defining
--   a function.
liftCodeGenModule :: CodeGenModule a -> CodeGenFunction r a
getParams :: Value -> IO [(String, Value)]
type Global a = Value (Ptr a)

-- | Create a new global variable.
newGlobal :: IsType a => Bool -> Linkage -> TGlobal a

-- | Create a new named global variable.
newNamedGlobal :: IsType a => Bool -> Linkage -> String -> TGlobal a

-- | Give a global variable a (constant) value.
defineGlobal :: Global a -> ConstValue a -> CodeGenModule ()

-- | Create and define a global variable.
createGlobal :: IsType a => Bool -> Linkage -> ConstValue a -> TGlobal a

-- | Create and define a named global variable.
createNamedGlobal :: IsType a => Bool -> Linkage -> String -> ConstValue a -> TGlobal a

-- | Create a reference to an external function while code generating for a
--   function. If LLVM cannot resolve its name, then you may try
--   <a>staticFunction</a>.
externFunction :: IsFunction a => String -> CodeGenFunction r (Function a)

-- | Make an external C function with a fixed address callable from LLVM
--   code. This callback function can also be a Haskell function, that was
--   imported like
--   
--   <pre>
--   foreign import ccall "&amp;nextElement"
--      nextElementFunPtr :: FunPtr (StablePtr (IORef [Word32]) -&gt; IO Word32)
--   </pre>
--   
--   See <tt>examples/List.hs</tt>.
--   
--   When you only use <a>externFunction</a>, then LLVM cannot resolve the
--   name. (However, I do not know why.) Thus <a>staticFunction</a> manages
--   a list of static functions. This list is automatically installed by
--   <a>simpleFunction</a> and can be manually obtained by
--   <a>getGlobalMappings</a> and installed by <a>addGlobalMappings</a>.
--   "Installing" means calling LLVM's <tt>addGlobalMapping</tt> according
--   to
--   <a>http://old.nabble.com/jit-with-external-functions-td7769793.html</a>.
staticFunction :: IsFunction f => FunPtr f -> CodeGenFunction r (Function f)

-- | As <a>externFunction</a>, but for <a>Global</a>s rather than
--   <a>Function</a>s
externGlobal :: IsType a => Bool -> String -> CodeGenFunction r (Global a)

-- | As <a>staticFunction</a>, but for <a>Global</a>s rather than
--   <a>Function</a>s
staticGlobal :: IsType a => Bool -> Ptr a -> CodeGenFunction r (Global a)
data GlobalMappings

-- | Get a list created by calls to <tt>staticFunction</tt> that must be
--   passed to the execution engine via <a>addGlobalMappings</a>.
getGlobalMappings :: CodeGenModule GlobalMappings
type TGlobal a = CodeGenModule (Global a)

-- | An enumeration for the kinds of linkage for global values.
data Linkage :: *

-- | Externally visible function
ExternalLinkage :: Linkage
AvailableExternallyLinkage :: Linkage

-- | Keep one copy of function when linking (inline)
LinkOnceAnyLinkage :: Linkage

-- | Same, but only replaced by something equivalent.
LinkOnceODRLinkage :: Linkage

-- | Keep one copy of named function when linking (weak)
WeakAnyLinkage :: Linkage

-- | Same, but only replaced by something equivalent.
WeakODRLinkage :: Linkage

-- | Special purpose, only applies to global arrays
AppendingLinkage :: Linkage

-- | Rename collisions when linking (static functions)
InternalLinkage :: Linkage

-- | Like Internal, but omit from symbol table
PrivateLinkage :: Linkage

-- | Function to be imported from DLL
DLLImportLinkage :: Linkage

-- | Function to be accessible from DLL
DLLExportLinkage :: Linkage

-- | ExternalWeak linkage description
ExternalWeakLinkage :: Linkage

-- | Stand-in functions for streaming fns from BC files
GhostLinkage :: Linkage

-- | Tentative definitions
CommonLinkage :: Linkage

-- | Like Private, but linker removes.
LinkerPrivateLinkage :: Linkage

-- | A basic block is a sequence of non-branching instructions, terminated
--   by a control flow instruction.
data BasicBlock
newBasicBlock :: CodeGenFunction r BasicBlock
newNamedBasicBlock :: String -> CodeGenFunction r BasicBlock
defineBasicBlock :: BasicBlock -> CodeGenFunction r ()
createBasicBlock :: CodeGenFunction r BasicBlock
getCurrentBasicBlock :: CodeGenFunction r BasicBlock
getBasicBlocks :: Value -> IO [(String, Value)]
fromLabel :: Value Label -> BasicBlock
toLabel :: BasicBlock -> Value Label
getInstructions :: Value -> IO [(String, Value)]
getOperands :: Value -> IO [(String, Value)]
hasUsers :: Value -> IO Bool
getUsers :: [Use] -> IO [(String, Value)]
getUses :: Value -> IO [Use]
getUser :: Use -> IO Value
isChildOf :: BasicBlock -> Value -> IO Bool
getDep :: Use -> IO (String, String)

-- | Add attributes to a value. Beware, what attributes are allowed depends
--   on what kind of value it is.
addAttributes :: Value a -> Int -> [Attribute] -> CodeGenFunction r ()
data Attribute :: *
ZExtAttribute :: Attribute
SExtAttribute :: Attribute
NoReturnAttribute :: Attribute
InRegAttribute :: Attribute
StructRetAttribute :: Attribute
NoUnwindAttribute :: Attribute
NoAliasAttribute :: Attribute
ByValAttribute :: Attribute
NestAttribute :: Attribute
ReadNoneAttribute :: Attribute
ReadOnlyAttribute :: Attribute
NoInlineAttribute :: Attribute
AlwaysInlineAttribute :: Attribute
OptimizeForSizeAttribute :: Attribute
StackProtectAttribute :: Attribute
StackProtectReqAttribute :: Attribute
NoCaptureAttribute :: Attribute
NoRedZoneAttribute :: Attribute
NoImplicitFloatAttribute :: Attribute
NakedAttribute :: Attribute

-- | Convert a varargs function to a regular function.
castVarArgs :: CastVarArgs a b => Function a -> Function b

-- | Print a value.
dumpValue :: Value a -> IO ()

-- | Print a type.
dumpType :: Value a -> IO ()

-- | Get the name of a <a>Value</a>.
getValueName :: Value a -> IO String
annotateValueList :: [Value] -> IO [(String, Value)]


-- | An <tt>ExecutionEngine</tt> is JIT compiler that is used to generate
--   code for an LLVM module.
module LLVM.ExecutionEngine
data EngineAccess a

-- | The LLVM execution engine is encapsulated so it cannot be accessed
--   directly. The reason is that (currently) there must only ever be one
--   engine, so access to it is wrapped in a monad.
runEngineAccess :: EngineAccess a -> IO a
addModuleProvider :: ModuleProvider -> EngineAccess ()
addModule :: Module -> EngineAccess ()

-- | In contrast to <tt>generateFunction</tt> this compiles a function
--   once. Thus it is faster for many calls to the same function. See
--   <tt>examples/Vector.hs</tt>.
--   
--   If the function calls back into Haskell code, you also have to set the
--   function addresses using <a>addFunctionValue</a> or
--   <a>addGlobalMappings</a>.
getPointerToFunction :: Function f -> EngineAccess (FunPtr f)

-- | Tell LLVM the address of an external function if it cannot resolve a
--   name automatically. Alternatively you may declare the function with
--   <tt>staticFunction</tt> instead of <tt>externFunction</tt>.
addFunctionValue :: Function f -> FunPtr f -> EngineAccess ()

-- | Pass a list of global mappings to LLVM that can be obtained from
--   <a>getGlobalMappings</a>.
addGlobalMappings :: GlobalMappings -> EngineAccess ()
getFreePointers :: Function f -> EngineAccess FreePointers

-- | Get all the information needed to free a function. Freeing code might
--   have to be done from a (C) finalizer, so it has to done from C. The
--   function c_freeFunctionObject take these pointers as arguments and
--   frees the function.
type FreePointers = (Ptr ExecutionEngine, ModuleProviderRef, ValueRef)

-- | Class of LLVM function types that can be translated to the
--   corresponding Haskell type.
class Translatable f
class Generic a

-- | Generate a Haskell function from an LLVM function.
--   
--   Note that the function is compiled for every call (Just-In-Time
--   compilation). If you want to compile the function once and call it a
--   lot of times then you should better use <a>getPointerToFunction</a>.
generateFunction :: Translatable f => Value (Ptr f) -> EngineAccess f
class Unsafe a b | a -> b
unsafePurify :: Unsafe a b => a -> b

-- | Translate a function to Haskell code. This is a simplified interface
--   to the execution engine and module mechanism. It is based on
--   <a>generateFunction</a>, so see there for limitations.
simpleFunction :: Translatable f => CodeGenModule (Function f) -> IO f

-- | Combine <a>simpleFunction</a> and <a>unsafePurify</a>.
unsafeGenerateFunction :: (Unsafe t a, Translatable t) => CodeGenModule (Function t) -> a
data TargetData
TargetData :: (Type -> Int) -> (Type -> Int) -> Bool -> (Type -> Int) -> Type -> Int -> (Type -> Int) -> (Type -> Int) -> (Type -> Int) -> TargetData
aBIAlignmentOfType :: TargetData -> Type -> Int
aBISizeOfType :: TargetData -> Type -> Int
littleEndian :: TargetData -> Bool
callFrameAlignmentOfType :: TargetData -> Type -> Int
intPtrType :: TargetData -> Type
pointerSize :: TargetData -> Int
preferredAlignmentOfType :: TargetData -> Type -> Int
sizeOfTypeInBits :: TargetData -> Type -> Int
storeSizeOfType :: TargetData -> Type -> Int
getTargetData :: IO TargetData
targetDataFromString :: String -> TargetData
withIntPtrType :: (forall n. Nat n => WordN n -> a) -> a
instance Unsafe (IO a) a
instance Unsafe b b' => Unsafe (a -> b) (a -> b')
instance Generic a => Translatable (IO a)
instance (Generic a, Translatable b) => Translatable (a -> b)

module LLVM.Util.Loop
class Phi a
phis :: Phi a => BasicBlock -> a -> CodeGenFunction r a
addPhis :: Phi a => BasicBlock -> a -> a -> CodeGenFunction r ()
forLoop :: (Phi a, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> Value i -> a -> (Value i -> a -> CodeGenFunction r a) -> CodeGenFunction r a
mapVector :: (Pos n, IsPrimitive b) => (Value a -> CodeGenFunction r (Value b)) -> Value (Vector n a) -> CodeGenFunction r (Value (Vector n b))
mapVector2 :: (Pos n, IsPrimitive c) => (Value a -> Value b -> CodeGenFunction r (Value c)) -> Value (Vector n a) -> Value (Vector n b) -> CodeGenFunction r (Value (Vector n c))
instance (Phi a, Phi b, Phi c) => Phi (a, b, c)
instance (Phi a, Phi b) => Phi (a, b)
instance IsFirstClass a => Phi (Value a)
instance Phi ()

module LLVM.Util.Arithmetic

-- | Synonym for <tt>CodeGenFunction r (Value a)</tt>.
type TValue r a = CodeGenFunction r (Value a)
class CmpRet a b => Cmp a b | a -> b
cmp :: Cmp a b => IntPredicate -> Value a -> Value a -> TValue r b

-- | Comparison functions.
(%==, %>=, %>, %<=, %<, %/=) :: CmpRet a b => TValue r a -> TValue r a -> TValue r b

-- | Lazy and.
(%&&) :: TValue r Bool -> TValue r Bool -> TValue r Bool

-- | Lazy or.
(%||) :: TValue r Bool -> TValue r Bool -> TValue r Bool

-- | Conditional, returns first element of the pair when condition is true,
--   otherwise second.
(?) :: IsFirstClass a => TValue r Bool -> (TValue r a, TValue r a) -> TValue r a
(??) :: (IsFirstClass a, CmpRet a b) => TValue r b -> (TValue r a, TValue r a) -> TValue r a

-- | Return a value from an <a>arithFunction</a>.
retrn :: Ret (Value a) r => TValue r a -> CodeGenFunction r ()

-- | Use <tt>x &lt;- set $ ...</tt> to make a binding.
set :: TValue r a -> (CodeGenFunction r (TValue r a))
class ArithFunction a b | a -> b, b -> a

-- | Unlift a function with <tt>TValue</tt> to have <tt>Value</tt>
--   arguments.
arithFunction :: ArithFunction a b => a -> b
class (UncurryN a (a1 -> CodeGenFunction r b1), LiftTuple r a1 b, UncurryN a2 (b -> CodeGenFunction r b1)) => UnwrapArgs a a1 b1 b a2 r | a -> a1 b1, a1 b1 -> a, a1 -> b, b -> a1, a2 -> b b1, b b1 -> a2

-- | Lift a function from having <tt>Value</tt> arguments to having
--   <tt>TValue</tt> arguments.
toArithFunction :: (CallArgs f g r, UnwrapArgs a a1 b1 b g r) => Function f -> a

-- | Define a recursive <a>arithFunction</a>, gets passed itself as the
--   first argument.
recursiveFunction :: (CallArgs a g r0, UnwrapArgs a11 a1 b1 b g r0, FunctionArgs a a2 r1, ArithFunction a3 a2, IsFunction a) => (a11 -> a3) -> CodeGenModule (Function a)
class CallIntrinsic a
instance (Pos n, IsPrimitive a, CallIntrinsic a) => CallIntrinsic (Vector n a)
instance CallIntrinsic Double
instance CallIntrinsic Float
instance (UncurryN a (a1 -> CodeGenFunction r b1), LiftTuple r a1 b, UncurryN a2 (b -> CodeGenFunction r b1)) => UnwrapArgs a a1 b1 b a2 r
instance LiftTuple r b b' => LiftTuple r (CodeGenFunction r a, b) (a, b')
instance LiftTuple r () ()
instance UncurryN t (b -> c) => UncurryN (a -> t) ((a, b) -> c)
instance UncurryN (CodeGenFunction r a) (() -> CodeGenFunction r a)
instance ArithFunction b b' => ArithFunction (CodeGenFunction r a -> b) (a -> b')
instance Ret a r => ArithFunction (CodeGenFunction r a) (CodeGenFunction r ())
instance (Cmp a b, CallIntrinsic a, RealFloat a, IsConst a, IsFloating a) => RealFloat (TValue r a)
instance (Cmp a b, CallIntrinsic a, Floating a, IsConst a, IsFloating a) => Floating (TValue r a)
instance (Cmp a b, Fractional a, IsConst a, IsFloating a) => RealFrac (TValue r a)
instance (Cmp a b, Fractional a, IsConst a, IsFloating a) => Fractional (TValue r a)
instance (Cmp a b, Num a, IsConst a, IsInteger a) => Integral (TValue r a)
instance (IsArithmetic a, Cmp a b, Num a, IsConst a) => Real (TValue r a)
instance (IsArithmetic a, Cmp a b, Num a, IsConst a) => Enum (TValue r a)
instance (IsArithmetic a, Cmp a b, Num a, IsConst a) => Num (TValue r a)
instance Ord (TValue r a)
instance Eq (TValue r a)
instance Show (TValue r a)
instance Pos n => Cmp (Vector n Word32) (Vector n Bool)
instance Pos n => Cmp (Vector n Float) (Vector n Bool)
instance Cmp FP128 Bool
instance Cmp Double Bool
instance Cmp Float Bool
instance Cmp Int64 Bool
instance Cmp Int32 Bool
instance Cmp Int16 Bool
instance Cmp Int8 Bool
instance Cmp Word64 Bool
instance Cmp Word32 Bool
instance Cmp Word16 Bool
instance Cmp Word8 Bool
instance Cmp Bool Bool

module LLVM.Util.File
writeCodeGenModule :: FilePath -> CodeGenModule a -> IO ()
optimizeFunction :: (IsType t, Translatable t) => CodeGenModule (Function t) -> IO (Function t)
optimizeFunctionCG :: (IsType t, Translatable t) => CodeGenModule (Function t) -> IO t

module LLVM.Util.Memory
memcpy :: IsLengthType len => CodeGenModule (Value (Ptr Word8) -> Value (Ptr Word8) -> Value len -> Value Word32 -> Value Bool -> CodeGenFunction r ())
memmove :: IsLengthType len => CodeGenModule (Value (Ptr Word8) -> Value (Ptr Word8) -> Value len -> Value Word32 -> Value Bool -> CodeGenFunction r ())
memset :: IsLengthType len => CodeGenModule (Value (Ptr Word8) -> Value Word8 -> Value len -> Value Word32 -> Value Bool -> CodeGenFunction r ())
class IsFirstClass len => IsLengthType len
instance IsLengthType Word64
instance IsLengthType Word32
