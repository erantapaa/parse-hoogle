-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Approximate discrete values and numbers
--   
@package approximate
@version 0.2.2.1


module Data.Approximate.Type

-- | An approximate number, with a likely interval, an expected value and a
--   lower bound on the <tt>log</tt> of probability that the answer falls
--   in the interval.
--   
--   <i>NB:</i> The probabilities associated with confidence are stored in
--   the <tt>log</tt> domain.
data Approximate a
Approximate :: {-# UNPACK #-} !(Log Double) -> a -> a -> a -> Approximate a
class HasApproximate c_aiOH a_acyA | c_aiOH -> a_acyA where confidence = (.) approximate confidence estimate = (.) approximate estimate hi = (.) approximate hi lo = (.) approximate lo
approximate :: HasApproximate c_aiOH a_acyA => Lens' c_aiOH (Approximate a_acyA)
confidence :: HasApproximate c_aiOH a_acyA => Lens' c_aiOH (Log Double)
estimate :: HasApproximate c_aiOH a_acyA => Lens' c_aiOH a_acyA
hi :: HasApproximate c_aiOH a_acyA => Lens' c_aiOH a_acyA
lo :: HasApproximate c_aiOH a_acyA => Lens' c_aiOH a_acyA
exact :: Eq a => Prism' (Approximate a) a
zero :: (Num a, Eq a) => Prism' (Approximate a) ()
one :: (Num a, Eq a) => Prism' (Approximate a) ()
withMin :: Ord a => a -> Approximate a -> Approximate a
withMax :: Ord a => a -> Approximate a -> Approximate a
instance (Ord a, Num a) => Num (Approximate a)
instance Applicative Approximate
instance Apply Approximate
instance Pointed Approximate
instance Copointed Approximate
instance Traversable Approximate
instance Foldable Approximate
instance Functor Approximate
instance NFData a => NFData (Approximate a)
instance Unbox a => Vector Vector (Approximate a)
instance Unbox a => MVector MVector (Approximate a)
instance Unbox a => Unbox (Approximate a)
instance Serial1 Approximate
instance Serial a => Serial (Approximate a)
instance Hashable1 Approximate
instance Hashable a => Hashable (Approximate a)
instance Serialize a => SafeCopy (Approximate a)
instance Serialize a => Serialize (Approximate a)
instance Binary a => Binary (Approximate a)
instance HasApproximate (Approximate a0) a0
instance Typeable Approximate
instance Eq a => Eq (Approximate a)
instance Show a => Show (Approximate a)
instance Read a => Read (Approximate a)
instance Data a => Data (Approximate a)
instance Generic (Approximate a)
instance Datatype D1Approximate
instance Constructor C1_0Approximate
instance Selector S1_0_0Approximate
instance Selector S1_0_1Approximate
instance Selector S1_0_2Approximate
instance Selector S1_0_3Approximate


-- | These functions provide wildly inaccurate but very fast approximations
--   to common transcendental functions.
--   
--   The algorithms here are based on Martin Ankerl's optimized
--   <tt>pow</tt>,
--   <a>http://martin.ankerl.com/2007/10/04/optimized-pow-approximation-for-java-and-c-c/</a>
--   which is in turn based on
--   <a>http://nic.schraudolph.org/pubs/Schraudolph99.pdf</a>
module Data.Approximate.Numerics
class Floating a => Fast a
flog :: Fast a => a -> a
flog_lb :: Fast a => a -> a
flog_ub :: Fast a => a -> a
fexp :: Fast a => a -> a
fexp_lb :: Fast a => a -> a
fexp_ub :: Fast a => a -> a
fpow :: Fast a => a -> a -> a
fpow_lb :: Fast a => a -> a -> a
fpow_ub :: Fast a => a -> a -> a

-- | Borchardt’s Algorithm from “Dead Reckoning: Calculating without
--   instruments”.
--   
--   This is a remarkably bad approximate logarithm.
--   
--   <a>flog</a> had better outperform it! It is provided merely for
--   comparison.
blog :: Floating a => a -> a
instance Fast Double
instance Fast Float


module Data.Approximate.Mass

-- | A quantity with a lower-bound on its probability mass. This represents
--   a 'probable value' as a <a>Monad</a> that you can use to calculate
--   progressively less likely consequences.
--   
--   <i>NB:</i> These probabilities are all stored in the log domain. This
--   enables us to retain accuracy despite very long multiplication chains.
--   We never add these probabilities so the additional overhead of working
--   in the log domain is never incurred, except on transitioning in and
--   out.
--   
--   This is most useful for discrete types, such as small <a>Integral</a>
--   instances or a <a>Bounded</a> <a>Enum</a> like <a>Bool</a>.
--   
--   Also note that <tt>(<a>&amp;?</a>)</tt> and <tt>(<a>|?</a>)</tt> are
--   able to use knowledge about the function to get better precision on
--   their results than naively using <tt><a>liftA2</a>
--   (<a>&amp;&amp;</a>)</tt>
data Mass a
Mass :: {-# UNPACK #-} !(Log Double) -> a -> Mass a

-- | Calculate the logical <tt>or</tt> of two booleans with confidence
--   lower bounds.
(|?) :: Mass Bool -> Mass Bool -> Mass Bool

-- | Calculate the logical <tt>and</tt> of two booleans with confidence
--   lower bounds.
(&?) :: Mass Bool -> Mass Bool -> Mass Bool

-- | Calculate the exclusive <tt>or</tt> of two booleans with confidence
--   lower bounds.
(^?) :: Mass Bool -> Mass Bool -> Mass Bool
instance Typeable Mass
instance Eq a => Eq (Mass a)
instance Ord a => Ord (Mass a)
instance Show a => Show (Mass a)
instance Read a => Read (Mass a)
instance Data a => Data (Mass a)
instance Generic (Mass a)
instance Datatype D1Mass
instance Constructor C1_0Mass
instance ComonadApply Mass
instance Comonad Mass
instance Extend Mass
instance Monad Mass
instance Bind Mass
instance Semigroup a => Semigroup (Mass a)
instance Monoid a => Monoid (Mass a)
instance Applicative Mass
instance Copointed Mass
instance Pointed Mass
instance Apply Mass
instance Traversable Mass
instance NFData a => NFData (Mass a)
instance Unbox a => Vector Vector (Mass a)
instance Unbox a => MVector MVector (Mass a)
instance Foldable Mass
instance Functor Mass
instance Serial a => Serial (Mass a)
instance Serial1 Mass
instance Hashable1 Mass
instance Hashable a => Hashable (Mass a)
instance Serialize a => SafeCopy (Mass a)
instance Serialize a => Serialize (Mass a)
instance Binary a => Binary (Mass a)


module Data.Approximate
