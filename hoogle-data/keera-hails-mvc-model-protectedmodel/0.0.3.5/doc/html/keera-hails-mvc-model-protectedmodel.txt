-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Rapid Gtk Application Development - Protected Reactive Models
--   
@package keera-hails-mvc-model-protectedmodel
@version 0.0.3.5


-- | This module uses Template Haskell to declare reactive fields for a
--   given model field and type that access the ProtectedModel in the IO
--   Monad and the reactive model.
module Hails.MVC.Model.THFields

-- | Creates a setter and a getter that works at ProtectedModel level
--   inside the IO Monad
protectedField :: String -> Q Type -> String -> String -> Q [Dec]

-- | Creates a setter and a getter that works at ReactiveModel level.
reactiveField :: String -> Q Type -> Q [Dec]
lcFst :: String -> String

-- | Creates a setter and a getter that works at ReactiveModel level. using
--   a specific event name
reactiveFieldE :: String -> String -> Q Type -> Q [Dec]

-- | Creates a setter and a getter that works at ReactiveModel level. using
--   a specific event name
reactiveFieldEvUndo :: String -> String -> Q Type -> Q [Dec]


-- | This module uses Template Haskell to declare getters and setters for a
--   given field and type that access the ProtectedModel in the IO Monad
--   and the reactive model.
module Hails.MVC.Model.THAccessors
protectedModelAccessors :: String -> String -> Q [Dec]

-- | Creates a setter and a getter that works at ReactiveModel level.
reactiveModelAccessors :: String -> String -> Q [Dec]

-- | Creates a setter and a getter that works at ReactiveModel level.
nonReactiveModelAccessors :: String -> Q Type -> Q [Dec]
lcFst :: String -> String


-- | This module holds a reactive program model. It holds a program model,
--   but includes events that other threads can listen to, so that a change
--   in a part of the model is notified to another part of the program. The
--   reactive model is not necessarily concurrent (it doesn't have its own
--   thread), although a facility is included to make it also concurrent
--   (so that event handlers can be called as soon as they are present).
--   
--   This type includes operations to handle undoing-redoing and tracking
--   which notifications must be triggered in each undo-redo step.
module Hails.MVC.Model.ReactiveModel

-- | A model of kind a with a stack of events of kind b
data Event b => ReactiveModel a b c

-- | A reactive model uses an event datatype with all the events that our
--   model must trigger. An heterogenous container cannot be used because
--   we need an Eq operation that is efficient (a string comparison is
--   not).
--   
--   Therefore, we can declare operations that require certain events, as
--   long as we create a typeclass for Event types that have a constructor
--   for the kind of events we require. This reactive model handles
--   Undo/Redo internally, and changes to the undo-stack are notified
--   automatically. All Event types must declare an undo event, even if
--   it's not used.
--   
--   NOTE: This is experimental code. Undo/Redo support may not be
--   necessary in many programs, and another Reactive Model definition
--   could be provided with no support for undo-redo if this bothers you
--   too much.
class (Eq a, Ord a) => Event a
undoStackChangedEvent :: Event a => a

-- | Default constructor (with an empty model, no events and no handlers
--   installed)
emptyRM :: Event b => a -> ReactiveModel a b c
pendingEvents :: ReactiveModel a b c -> Seq b
pendingHandlers :: ReactiveModel a b c -> Seq c
nextModels :: ReactiveModel a b c -> Stack (a, Seq b)
previousModels :: ReactiveModel a b c -> Stack (a, Seq b)

-- | Apply a modification to the internal model (no events are triggered)
onBasicModel :: Event b => ReactiveModel a b c -> (a -> a) -> ReactiveModel a b c

-- | Install a handler for an event
onEvent :: Event b => ReactiveModel a b c -> b -> c -> ReactiveModel a b c
onEvents :: (Foldable container, Event b) => ReactiveModel a b c -> container b -> c -> ReactiveModel a b c

-- | If any pending handler exists or can be obtained, it is returned and
--   removed from the queue
getPendingHandler :: Event b => ReactiveModel a b c -> (ReactiveModel a b c, Maybe c)
eventHandlers :: ReactiveModel a b c -> Map b (Seq c)

-- | Return a reactive model that has no pending events. All the pending
--   events have been looked up in the eventHandlers table and the handlers
--   have been added to the field pendingHandlers.
prepareEventHandlers :: Event b => ReactiveModel a b c -> ReactiveModel a b c

-- | Trigger an event (execute all handlers associated to it)
triggerEvent :: Event b => ReactiveModel a b c -> b -> ReactiveModel a b c

-- | Trigger many events in sequence (execute all handlers associated to
--   them)
triggerEvents :: Event b => ReactiveModel a b c -> Seq b -> ReactiveModel a b c

-- | Record a change in the undo stack, with a list of associated events
--   for that change. Events are expected to work bi-directionally (the
--   same event will be triggered when the change is redone or undone).
recordChange :: Event b => ReactiveModel a b c -> (a -> a) -> [b] -> ReactiveModel a b c

-- | Install a handler in the previous model's event list
onUndo :: Event b => ReactiveModel a b c -> [b] -> ReactiveModel a b c

-- | Undo one step
undo :: Event b => ReactiveModel a b c -> ReactiveModel a b c

-- | Redo one step
redo :: Event b => ReactiveModel a b c -> ReactiveModel a b c

-- | Clear the undo stack (remove all known previous and next models)
clearUndoStack :: Event b => ReactiveModel a b c -> ReactiveModel a b c

-- | Apply a change to all the models in the undo stack
onUndoStack :: Event b => ReactiveModel a b c -> (a -> a) -> ReactiveModel a b c


-- | This module contains all the events in our program.
--   
--   FIXME: Because we want events to be comparable, we need to use the
--   same datatype. It remains to be checked whether using an instance of
--   Typeable and an existential type will be enough to have a good
--   instance of Eq and therefore a heterogeneous model (wrt. events).
module Hails.MVC.Model.ReactiveModel.Events
class Event a => InitialisedEvent a
initialisedEvent :: InitialisedEvent a => a


-- | Contains only one operation to notify that the system's been
--   initialised.
module Hails.MVC.Model.ReactiveModel.Initialisation
initialiseSystem :: InitialisedEvent b => ReactiveModel a b c -> ReactiveModel a b c

module Hails.MVC.Model.ReactiveFields
type Field a b c = (b -> a, a -> b -> Bool, a -> b -> b, c)
preTrue :: a -> b -> Bool
fieldSetter :: (Eq a, Event c) => Field a b c -> ReactiveModel b c d -> a -> ReactiveModel b c d
fieldGetter :: Event c => Field a b c -> ReactiveModel b c d -> a
fieldSetterUndo :: (Eq a, Event c) => Field a b c -> ReactiveModel b c d -> a -> ReactiveModel b c d


-- | Note: this is experimental code. It's what I'm using to build my own
--   Gtk apps. That being said, you may find IO more often than it's really
--   necessary. I'd be glad if you could point that out when you see it.
--   I'd like to make this code as generic and useful as possible.
--   
--   | This module holds the protected reactive program model. It holds a
--   reactive model, but includes an interface that is thread safe (can be
--   called concurrently). This makes it easier for different threads to
--   modify the model without having to worry about concurrency. Note that
--   using this interface can lead to deadlocks in the program.
module Hails.MVC.Model.ProtectedModel
data Event b => ProtectedModel a b

-- | Start executing the a new protected model.
startProtectedModel :: Event b => a -> IO (ProtectedModel a b)

-- | Calculate a value from the reactive model.
onReactiveModel :: Event b => ProtectedModel a b -> (ReactiveModelIO a b -> c) -> IO c

-- | Execute an event handler for a given Event.
onEvent :: Event b => ProtectedModel a b -> b -> IO () -> IO ()

-- | Execute an event handler for a given Event.
onEvents :: (Foldable container, Event b) => ProtectedModel a b -> container b -> IO () -> IO ()

-- | Perform a modification to the underlying reactive model.
applyToReactiveModel :: Event b => ProtectedModel a b -> (ReactiveModelIO a b -> ReactiveModelIO a b) -> IO ()

-- | Calculate a value from the reactive model and update it at the same
--   time
fromReactiveModel :: Event b => ProtectedModel a b -> (ReactiveModelIO a b -> (ReactiveModelIO a b, c)) -> IO c

-- | Lock the calling thread until the reactive model fulfills a condition.
waitFor :: Event b => ProtectedModel a b -> (ReactiveModelIO a b -> Bool) -> IO ()


-- | Protected Reactive Fields
--   
--   This module defines several classes and operations that are used to
--   create reactive fields and to bind reactive fields in the view to
--   reactive fields in the model.
--   
--   FIXME: Due to the restrictions in the type classes, the current
--   version uses
--   Model.ProtectedModel.ProtectedModelInternals.ProtectedModel.
module Hails.MVC.Model.ProtectedModel.Reactive
type Setter a b c = ProtectedModel b c -> a -> IO ()
type Getter a b c = ProtectedModel b c -> IO a
type Modifier a b c = ProtectedModel b c -> (a -> a) -> IO ()
type ModifierIO a b c = ProtectedModel b c -> (a -> IO a) -> IO ()
class ReactiveField a b c d | a -> b, a -> c, a -> d
events :: ReactiveField a b c d => a -> [d]
onChanged :: (Event d, ReactiveField a b c d) => ProtectedModel c d -> a -> IO () -> IO ()
class ReactiveField a b c d => ReactiveReadField a b c d
getter :: ReactiveReadField a b c d => a -> Getter b c d
class ReactiveWriteField a b c d
setter :: ReactiveWriteField a b c d => a -> Setter b c d
class (ReactiveField a b c d, ReactiveReadField a b c d, ReactiveWriteField a b c d) => ReactiveReadWriteField a b c d where modifier x pm f = do { v <- getter x pm; let v' = f v; setter x pm v' } modifierIO x pm f = do { v <- getter x pm; v' <- f v; setter x pm v' }
modifier :: ReactiveReadWriteField a b c d => a -> Modifier b c d
modifierIO :: ReactiveReadWriteField a b c d => a -> ModifierIO b c d
data Event c => ReactiveElement a b c
ReactiveElement :: [c] -> Setter a b c -> Getter a b c -> ReactiveElement a b c
reEvents :: ReactiveElement a b c -> [c]
reSetter :: ReactiveElement a b c -> Setter a b c
reGetter :: ReactiveElement a b c -> Getter a b c
type FieldAccessor a b c = ProtectedModel b c -> ReactiveFieldReadWrite IO a
mkFieldAccessor :: (InitialisedEvent c, Event c) => ReactiveElement a b c -> ProtectedModel b c -> ReactiveFieldReadWrite IO a
instance Event c => ReactiveReadWriteField (ReactiveElement a b c) a b c
instance Event c => ReactiveWriteField (ReactiveElement a b c) a b c
instance Event c => ReactiveReadField (ReactiveElement a b c) a b c
instance Event c => ReactiveField (ReactiveElement a b c) a b c


-- | Contains only one operation to notify that the system's been
--   initialised.
module Hails.MVC.Model.ProtectedModel.Initialisation
initialiseSystem :: InitialisedEvent c => ProtectedModel a c -> IO ()
