-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Multidimensional arrays and simple tensor computations.
--   
@package hTensor
@version 0.8.2


-- | Additional tools for manipulation of multidimensional arrays.
module Numeric.LinearAlgebra.Array.Util

-- | Types that can be elements of the multidimensional arrays.
class (Num (Vector t), Field t, Normed Vector t, Show t) => Coord t

-- | Class of compatible indices for contractions.
class (Eq a, Show (Idx a)) => Compat a
compat :: Compat a => Idx a -> Idx a -> Bool
opos :: Compat a => Idx a -> Idx a

-- | A multidimensional array with index type i and elements t.
data NArray i t

-- | Dimension descriptor.
data Idx i
Idx :: i -> Int -> Name -> Idx i
iType :: Idx i -> i
iDim :: Idx i -> Int
iName :: Idx i -> Name

-- | indices are denoted by strings, (frequently single-letter)
type Name = String

-- | Create a 0-dimensional structure.
scalar :: Coord t => t -> NArray i t

-- | The number of dimensions of a multidimensional array.
order :: NArray i t -> Int

-- | Index names.
names :: NArray i t -> [Name]

-- | Dimension of given index.
size :: Name -> NArray i t -> Int
sizes :: NArray i t -> [Int]

-- | Type of given index.
typeOf :: Compat i => Name -> NArray i t -> i

-- | Get detailed dimension information about the array.
dims :: NArray i t -> [Idx i]

-- | Get the coordinates of an array as a flattened structure (in the order
--   specified by <a>dims</a>).
coords :: NArray i t -> Vector t

-- | Rename indices using an association list.
renameExplicit :: (Compat i, Coord t) => [(Name, Name)] -> NArray i t -> NArray i t

-- | Explicit renaming of single letter index names.
--   
--   For instance, <tt>t &gt;@&gt; "pi qj"</tt> changes index "p" to "i"
--   and "q" to "j".
(!>) :: (Compat i, Coord t) => NArray i t -> [Char] -> NArray i t

-- | Rename indices in alphabetical order. Equal indices of compatible type
--   are contracted out.
renameO :: (Coord t, Compat i) => NArray i t -> [Name] -> NArray i t

-- | Rename indices in alphabetical order (<a>renameO</a>) using single
--   letter names.
(!) :: (Compat i, Coord t) => NArray i t -> [Char] -> NArray i t

-- | Create a list of the substructures at the given level.
parts :: Coord t => NArray i t -> Name -> [NArray i t]

-- | Create an array from a list of subarrays. (The inverse of
--   <a>parts</a>.)
newIndex :: (Coord t, Compat i) => i -> Name -> [NArray i t] -> NArray i t

-- | Apply a function (defined on hmatrix <a>Vector</a>s) to all elements
--   of a structure. Use <tt>mapArray (mapVector f)</tt> for general
--   functions.
mapArray :: Coord b => (Vector a -> Vector b) -> NArray i a -> NArray i b

-- | Apply an element-by-element binary function to the coordinates of two
--   arrays. The arguments are automatically made conformant.
zipArray :: (Coord a, Coord b, Compat i) => (Vector a -> Vector b -> Vector c) -> NArray i a -> NArray i b -> NArray i c

-- | Tensor product with automatic contraction of repeated indices,
--   following Einstein summation convention.
(|*|) :: (Coord t, Compat i) => NArray i t -> NArray i t -> NArray i t

-- | This is equivalent to the regular <a>product</a>, but in the order
--   that minimizes the size of the intermediate factors.
smartProduct :: (Coord t, Compat i, Num (NArray i t)) => [NArray i t] -> NArray i t

-- | Outer product of a list of arrays along the common indices.
outers :: (Coord a, Compat i) => [NArray i a] -> NArray i a

-- | Select some parts of an array, taking into account position and value.
extract :: (Compat i, Coord t) => (Int -> NArray i t -> Bool) -> Name -> NArray i t -> NArray i t

-- | Apply a list function to the parts of an array at a given index.
onIndex :: (Coord a, Coord b, Compat i) => ([NArray i a] -> [NArray i b]) -> Name -> NArray i a -> NArray i b

-- | Map a function at the internal level selected by a set of indices
mapTat :: (Coord a, Coord b, Compat i) => (NArray i a -> NArray i b) -> [Name] -> NArray i a -> NArray i b

-- | Change the internal layout of coordinates. The array, considered as an
--   abstract object, does not change.
reorder :: Coord t => [Name] -> NArray i t -> NArray i t

-- | <a>reorder</a> (transpose) dimensions of the array (with single letter
--   names).
--   
--   Operations are defined by named indices, so the transposed array is
--   operationally equivalent to the original one.
(~>) :: Coord t => NArray i t -> String -> NArray i t

-- | Show a multidimensional array as a nested 2D table.
formatArray :: (Coord t, Compat i) => (t -> String) -> NArray i t -> String

-- | Show the array as a nested table with a "%.nf" format. If all entries
--   are approximate integers the array is shown without the .00.. digits.
formatFixed :: Compat i => Int -> NArray i Double -> String

-- | Show the array as a nested table with autoscaled entries.
formatScaled :: Compat i => Int -> NArray i Double -> String

-- | Insert a dummy index of dimension 1 at a given level (for formatting
--   purposes).
dummyAt :: Coord t => Int -> NArray i t -> NArray i t

-- | Rename indices so that they are not shown in formatted output.
noIdx :: Compat i => NArray i t -> NArray i t

-- | Obtains most general structure of a list of dimension specifications
conformable :: Compat i => [[Idx i]] -> Maybe [Idx i]

-- | Check if two arrays have the same structure.
sameStructure :: Eq i => NArray i t1 -> NArray i t2 -> Bool

-- | Converts a list of arrays to a common structure.
makeConformant :: (Coord t, Compat i) => [NArray i t] -> [NArray i t]

-- | Obtain a canonical base for the array.
basisOf :: Coord t => NArray i t -> [NArray i t]
atT :: (Compat i, Coord t) => NArray i t -> [Int] -> NArray i t
takeDiagT :: (Compat i, Coord t) => NArray i t -> [t]

-- | Multidimensional diagonal of given order.
diagT :: [Double] -> Int -> Array Double

-- | Define an array using a function.
mkFun :: [Int] -> ([Int] -> Double) -> Array Double

-- | Define an array using an association list.
mkAssoc :: [Int] -> [([Int], Double)] -> Array Double

-- | Change type of index.
setType :: (Compat i, Coord t) => Name -> i -> NArray i t -> NArray i t

-- | Extract the <a>parts</a> of an array, and renameRaw one of the
--   remaining indices with succesive integers.
renameParts :: (Compat i, Coord t) => Name -> NArray i t -> Name -> String -> [NArray i t]

-- | change the whole set of coordinates.
resetCoords :: Coord t => NArray i t -> Vector t -> NArray i t

-- | Extract the scalar element corresponding to a 0-dimensional array.
asScalar :: Coord t => NArray i t -> t

-- | Extract the <a>Vector</a> corresponding to a one-dimensional array.
asVector :: Coord t => NArray i t -> Vector t

-- | Extract the <a>Matrix</a> corresponding to a two-dimensional array, in
--   the rows,cols order.
asMatrix :: Coord t => NArray i t -> Matrix t
applyAsMatrix :: (Coord t, Compat i) => (Matrix t -> Matrix t) -> (NArray i t -> NArray i t)

-- | Obtain a matrix whose columns are the fibers of the array in the given
--   dimension. The column order depends on the selected index (see
--   <a>matrixator</a>).
fibers :: Coord t => Name -> NArray i t -> Matrix t

-- | Reshapes an array as a matrix with the desired dimensions as flattened
--   rows and flattened columns.
matrixator :: Coord t => NArray i t -> [Name] -> [Name] -> Matrix t

-- | Reshapes an array as a matrix with the desired dimensions as flattened
--   rows and flattened columns. We do not force the order of the columns.
matrixatorFree :: Coord t => NArray i t -> [Name] -> (Matrix t, [Name])
analyzeProduct :: (Coord t, Compat i) => NArray i t -> NArray i t -> Maybe (NArray i t, Int)

-- | Create a 1st order array from a <a>Vector</a>.
fromVector :: (Coord t, Compat i) => i -> Vector t -> NArray i t

-- | Create a 2nd order array from a <a>Matrix</a>.
fromMatrix :: (Compat i, Coord t) => i -> i -> Matrix t -> NArray i t


-- | Simple multidimensional array with useful numeric instances.
--   
--   Contractions only require equal dimension.
module Numeric.LinearAlgebra.Array

-- | Unespecified coordinate type. Contractions only require equal
--   dimension.
data None
None :: None

-- | Multidimensional array with unespecified coordinate type.
type Array t = NArray None t

-- | Construction of an <a>Array</a> from a list of dimensions and a list
--   of elements in left to right order.
listArray :: Coord t => [Int] -> [t] -> Array t

-- | Create a 0-dimensional structure.
scalar :: Coord t => t -> NArray i t

-- | Create an <a>Array</a> from a list of parts (<tt>index =
--   <a>newIndex</a> <a>None</a></tt>).
index :: Coord t => Name -> [Array t] -> Array t

-- | Rename indices in alphabetical order (<a>renameO</a>) using single
--   letter names.
(!) :: (Compat i, Coord t) => NArray i t -> [Char] -> NArray i t

-- | Explicit renaming of single letter index names.
--   
--   For instance, <tt>t &gt;@&gt; "pi qj"</tt> changes index "p" to "i"
--   and "q" to "j".
(!>) :: (Compat i, Coord t) => NArray i t -> [Char] -> NArray i t

-- | <a>reorder</a> (transpose) dimensions of the array (with single letter
--   names).
--   
--   Operations are defined by named indices, so the transposed array is
--   operationally equivalent to the original one.
(~>) :: Coord t => NArray i t -> String -> NArray i t

-- | Element by element product.
(.*) :: (Coord a, Compat i) => NArray i a -> NArray i a -> NArray i a

-- | Print the array as a nested table with the desired format (e.g. %7.2f)
--   (see also <a>formatArray</a>, and <a>formatScaled</a>).
printA :: (Coord t, Compat i, PrintfArg t) => String -> NArray i t -> IO ()
instance (Coord t, Compat i, Fractional (NArray i t), Floating t, Floating (Vector t)) => Floating (NArray i t)
instance (Coord t, Compat i, Num (NArray i t)) => Fractional (NArray i t)
instance (Show (NArray i t), Coord t, Compat i) => Num (NArray i t)
instance (Eq t, Coord t, Compat i) => Eq (NArray i t)


-- | Tensor computations. Indices can only be contracted if they are of
--   different <a>Variant</a> type.
module Numeric.LinearAlgebra.Tensor
type Tensor t = NArray Variant t
data Variant
Contra :: Variant
Co :: Variant

-- | Creates a tensor from a list of dimensions and a list of coordinates.
--   A positive dimension means that the index is assumed to be
--   contravariant (vector-like), and a negative dimension means that the
--   index is assumed to be covariant (like a linear function, or
--   covector). Contractions can only be performed between indices of
--   different type.
listTensor :: Coord t => [Int] -> [t] -> Tensor t

-- | Create an <a>Tensor</a> from a list of parts with a contravariant
--   index (<tt>superindex = <a>newIndex</a> <a>Contra</a></tt>).
superindex :: Coord t => Name -> [Tensor t] -> Tensor t

-- | Create an <a>Tensor</a> from a list of parts with a covariant index
--   (<tt>subindex = <a>newIndex</a> <a>Co</a></tt>).
subindex :: Coord t => Name -> [Tensor t] -> Tensor t

-- | Create a contravariant 1st order tensor from a list of coordinates.
vector :: [Double] -> Tensor Double

-- | Create a covariant 1st order tensor from a list of coordinates.
covector :: [Double] -> Tensor Double

-- | Create a 1-contravariant, 1-covariant 2nd order from list of lists of
--   coordinates.
transf :: [[Double]] -> Tensor Double

-- | Change the <a>Variant</a> nature of all dimensions to the opposite
--   ones.
switch :: Tensor t -> Tensor t

-- | Make all dimensions covariant.
cov :: NArray i t -> Tensor t

-- | Make all dimensions contravariant.
contrav :: NArray i t -> Tensor t

-- | Remove the <a>Variant</a> nature of coordinates.
forget :: NArray i t -> Array t
instance Eq Variant
instance Show Variant
instance Coord t => Show (Tensor t)
instance Show (Idx Variant)
instance Compat Variant


-- | A simple implementation of Geometric Algebra.
--   
--   The Num instance provides the geometric product, and the Fractional
--   instance provides the inverse of multivectors.
--   
--   This module provides a simple Euclidean embedding.
module Numeric.LinearAlgebra.Multivector
data Multivector
coords :: Multivector -> [(Double, [Int])]

-- | Creates a scalar multivector.
scalar :: Double -> Multivector

-- | Creates a grade 1 multivector of from a list of coordinates.
vector :: [Double] -> Multivector

-- | The k-th basis element.
e :: Int -> Multivector

-- | The exterior (outer) product.
(/\) :: Multivector -> Multivector -> Multivector

-- | The contractive inner product.
(-|) :: Multivector -> Multivector -> Multivector

-- | Intersection of subspaces.
(\/) :: Multivector -> Multivector -> Multivector

-- | The reversion operator.
rever :: Multivector -> Multivector

-- | The full space of the given dimension. This is the leviCivita simbol,
--   and the basis of the pseudoscalar.
full :: Int -> Multivector

-- | The rotor operator, used in a sandwich product.
rotor :: Int -> Double -> Multivector -> Multivector

-- | Apply a linear transformation, expressed as the image of the element
--   i-th of the basis.
--   
--   (This is a monadic bind!)
apply :: (Int -> Multivector) -> Multivector -> Multivector
grade :: Int -> Multivector -> Multivector
maxGrade :: Multivector -> Int
maxDim :: Multivector -> Int

-- | Extract a multivector representation from a full antisymmetric tensor.
--   
--   (We do not check that the tensor is actually antisymmetric.)
fromTensor :: Tensor Double -> Multivector
instance Eq Multivector
instance Fractional Multivector
instance Num Multivector
instance Show Multivector


-- | Exterior Algebra.
module Numeric.LinearAlgebra.Exterior

-- | The exterior (wedge) product of two tensors. Obtains the union of
--   subspaces.
--   
--   Implemented as the antisymmetrization of the tensor product.
(/\) :: Coord t => Tensor t -> Tensor t -> Tensor t

-- | Euclidean inner product of multivectors.
inner :: Coord t => Tensor t -> Tensor t -> Tensor t

-- | The full antisymmetric tensor of order n (contravariant version).
leviCivita :: Int -> Tensor Double

-- | Inner product of a r-vector with the whole space.
--   
--   <pre>
--   dual t = inner (leviCivita n) t
--   </pre>
dual :: Tensor Double -> Tensor Double

-- | The "meet" operator. Obtains the intersection of subspaces.
--   
--   <pre>
--   a \/ b = dual (dual a /\ dual b)
--   </pre>
(\/) :: Tensor Double -> Tensor Double -> Tensor Double

-- | Extract a compact multivector representation from a full antisymmetric
--   tensor.
--   
--   asMultivector = Multivector.<a>fromTensor</a>.
--   
--   (We do not check that the tensor is actually antisymmetric.)
asMultivector :: Tensor Double -> Multivector

-- | Create an explicit antisymmetric <a>Tensor</a> from the components of
--   a Multivector of a given grade.
fromMultivector :: Int -> Multivector -> Tensor Double


-- | Solution of general multidimensional linear and multilinear systems.
module Numeric.LinearAlgebra.Array.Solve

-- | Solution of the linear system a x = b, where a and b are general
--   multidimensional arrays. The structure and dimension names of the
--   result are inferred from the arguments.
solve :: (Compat i, Coord t) => NArray i t -> NArray i t -> NArray i t

-- | Solution of the homogeneous linear system a x = 0, where a is a
--   general multidimensional array.
--   
--   If the system is overconstrained we may provide the theoretical rank
--   to get a MSE solution.
solveHomog :: (Compat i, Coord t) => NArray i t -> [Name] -> Either Double Int -> [NArray i t]

-- | A simpler way to use <a>solveHomog</a>, which returns just one
--   solution. If the system is overconstrained it returns the MSE
--   solution.
solveHomog1 :: (Compat i, Coord t) => NArray i t -> [Name] -> NArray i t

-- | <a>solveHomog1</a> for single letter index names.
solveH :: (Compat i, Coord t) => NArray i t -> [Char] -> NArray i t

-- | Solution of the linear system a x = b, where a and b are general
--   multidimensional arrays, with homogeneous equality along a given
--   index.
solveP :: Tensor Double -> Tensor Double -> Name -> Tensor Double

-- | optimization parameters for alternating least squares
data ALSParam i t
ALSParam :: Int -> Double -> Double -> ([NArray i t] -> [NArray i t]) -> (Int -> NArray i t -> NArray i t) -> (Matrix t -> Matrix t) -> ALSParam i t

-- | maximum number of iterations
nMax :: ALSParam i t -> Int

-- | minimum relative improvement in the optimization (percent, e.g. 0.1)
delta :: ALSParam i t -> Double

-- | maximum relative error. For nonhomogeneous problems it is the
--   reconstruction error in percent (e.g. 1E-3), and for homogeneous
--   problems is the frobenius norm of the expected zero structure in the
--   right hand side.
epsilon :: ALSParam i t -> Double

-- | post-processing function after each full iteration (e.g. <a>id</a>)
post :: ALSParam i t -> [NArray i t] -> [NArray i t]

-- | post-processing function for the k-th argument (e.g. <a>const</a>
--   <a>id</a>)
postk :: ALSParam i t -> Int -> NArray i t -> NArray i t

-- | preprocessing function for the linear systems (eg. <a>id</a>, or
--   <a>infoRank</a>)
presys :: ALSParam i t -> Matrix t -> Matrix t

-- | nMax = 20, epsilon = 1E-3, delta = 1, post = id, postk = const id,
--   presys = id
defaultParameters :: ALSParam i t

-- | Solution of a multilinear system a x y z ... = b based on alternating
--   least squares.
mlSolve :: (Compat i, Coord t, Num (NArray i t), Show (NArray i t)) => ALSParam i t -> [NArray i t] -> [NArray i t] -> NArray i t -> ([NArray i t], [Double])

-- | Solution of the homogeneous multilinear system a x y z ... = 0 based
--   on alternating least squares.
mlSolveH :: (Compat i, Coord t, Num (NArray i t), Show (NArray i t)) => ALSParam i t -> [NArray i t] -> [NArray i t] -> ([NArray i t], [Double])

-- | Solution of a multilinear system a x y z ... = b, with a homogeneous
--   index, based on alternating least squares.
mlSolveP :: ALSParam Variant Double -> [Tensor Double] -> [Tensor Double] -> Tensor Double -> Name -> ([Tensor Double], [Double])

-- | Given two arrays a (source) and b (target), we try to compute linear
--   transformations x,y,z,... for each dimension, such that product
--   [a,x,y,z,...] == b. (We can use <a>eqnorm</a> for <a>post</a>
--   processing, or <a>id</a>.)
solveFactors :: (Coord t, Random t, Compat i, Num (NArray i t), Show (NArray i t)) => Int -> ALSParam i t -> [NArray i t] -> String -> NArray i t -> ([NArray i t], [Double])

-- | Homogeneous factorized system. Given an array a, given as a list of
--   factors as, and a list of pairs of indices ["pi","qj", "rk", etc.], we
--   try to compute linear transformations x!"pi", y!"pi", z!"rk", etc.
--   such that product [a,x,y,z,...] == 0.
solveFactorsH :: (Coord t, Random t, Compat i, Num (NArray i t), Show (NArray i t)) => Int -> ALSParam i t -> [NArray i t] -> String -> ([NArray i t], [Double])

-- | The machine precision of a Double: <tt>eps = 2.22044604925031e-16</tt>
--   (the value used by GNU-Octave).
eps :: Double

-- | post processing function that modifies a list of tensors so that they
--   have equal frobenius norm
eqnorm :: (Compat i, Show (NArray i Double)) => [NArray i Double] -> [NArray i Double]

-- | debugging function (e.g. for <a>presys</a>), which shows rows, columns
--   and rank of the coefficient matrix of a linear system.
infoRank :: Field t => Matrix t -> Matrix t
solve' :: (Coord a, Coord t, Compat i) => (Matrix t -> Matrix a) -> NArray i t -> NArray i t -> NArray i a
solveHomog' :: (Coord a, Coord t, Compat i) => (Matrix t -> Matrix a) -> NArray i t -> [Name] -> Either Double Int -> [NArray i a]
solveHomog1' :: (Coord a, Coord t, Compat i) => (Matrix t -> Matrix a) -> NArray i t -> [Name] -> NArray i a
solveP' :: Coord b => (Matrix Double -> Matrix b) -> NArray Variant Double -> NArray Variant Double -> Name -> NArray Variant b


-- | Common multidimensional array decompositions. See the paper by Kolda
--   &amp; Balder.
module Numeric.LinearAlgebra.Array.Decomposition

-- | Multilinear Singular Value Decomposition (or Tucker's method, see
--   Lathauwer et al.).
--   
--   The result is a list with the core (head) and rotations so that t ==
--   product (hsvd t).
--   
--   The core and the rotations are truncated to the rank of each mode.
--   
--   Use <a>hosvd'</a> to get full transformations and rank information
--   about each mode.
hosvd :: Array Double -> [Array Double]

-- | Full version of <a>hosvd</a>.
--   
--   The first element in the result pair is a list with the core (head)
--   and rotations so that t == product (fst (hsvd' t)).
--   
--   The second element is a list of rank and singular values along each
--   mode, to give some idea about core structure.
hosvd' :: Array Double -> ([Array Double], [(Int, Vector Double)])

-- | Truncate a <a>hosvd</a> decomposition from the desired number of
--   principal components in each dimension.
truncateFactors :: [Int] -> [Array Double] -> [Array Double]

-- | Experimental implementation of the CP decomposition, based on
--   alternating least squares. We try approximations of increasing rank,
--   until the relative reconstruction error is below a desired percent of
--   Frobenius norm (epsilon).
--   
--   The approximation of rank k is abandoned if the error does not
--   decrease at least delta% in an iteration.
--   
--   Practical usage can be based on something like this:
--   
--   <pre>
--   cp finit d e t = cpAuto (finit t) defaultParameters {delta = d, epsilon = e} t
--   
--   cpS = cp (InitSvd . fst . hosvd')
--   cpR s = cp (cpInitRandom s)
--   </pre>
--   
--   So we can write
--   
--   <pre>
--    -- initialization based on hosvd
--   y = cpS 0.01 1E-6 t
--   
--    -- (pseudo)random initialization
--   z = cpR seed 0.1 0.1 t
--   </pre>
cpAuto :: (Int -> [Array Double]) -> ALSParam None Double -> Array Double -> [Array Double]

-- | Basic CP optimization for a given rank. The result includes the
--   obtained sequence of errors.
--   
--   For example, a rank 3 approximation can be obtained as follows, where
--   initialization is based on the hosvd:
--   
--   <pre>
--   (y,errs) = cpRank 3 t
--        where cpRank r t = cpRun (cpInitSvd (fst $ hosvd' t) r) defaultParameters t
--   </pre>
cpRun :: [Array Double] -> ALSParam None Double -> Array Double -> ([Array Double], [Double])

-- | pseudorandom cp initialization from a given seed
cpInitRandom :: Int -> NArray i t -> Int -> [NArray None Double]

-- | cp initialization based on the hosvd
cpInitSvd :: [NArray None Double] -> Int -> [NArray None Double]

-- | optimization parameters for alternating least squares
data ALSParam i t
ALSParam :: Int -> Double -> Double -> ([NArray i t] -> [NArray i t]) -> (Int -> NArray i t -> NArray i t) -> (Matrix t -> Matrix t) -> ALSParam i t

-- | maximum number of iterations
nMax :: ALSParam i t -> Int

-- | minimum relative improvement in the optimization (percent, e.g. 0.1)
delta :: ALSParam i t -> Double

-- | maximum relative error. For nonhomogeneous problems it is the
--   reconstruction error in percent (e.g. 1E-3), and for homogeneous
--   problems is the frobenius norm of the expected zero structure in the
--   right hand side.
epsilon :: ALSParam i t -> Double

-- | post-processing function after each full iteration (e.g. <a>id</a>)
post :: ALSParam i t -> [NArray i t] -> [NArray i t]

-- | post-processing function for the k-th argument (e.g. <a>const</a>
--   <a>id</a>)
postk :: ALSParam i t -> Int -> NArray i t -> NArray i t

-- | preprocessing function for the linear systems (eg. <a>id</a>, or
--   <a>infoRank</a>)
presys :: ALSParam i t -> Matrix t -> Matrix t

-- | nMax = 20, epsilon = 1E-3, delta = 1, post = id, postk = const id,
--   presys = id
defaultParameters :: ALSParam i t
