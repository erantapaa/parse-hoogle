-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Anaphoric and miscellaneous useful control-flow
--   
--   Anaphoric and miscellaneous useful control-flow
@package IfElse
@version 0.85


-- | Library for control flow inside of monads with anaphoric variants on
--   if and when and a C-like "switch" function.
--   
--   Information:
--   
--   <ul>
--   <li><i><tt>Author</tt></i> Jeff Heard</li>
--   <li><i><tt>Copyright</tt></i> 2008 Jeff Heard</li>
--   <li><i><tt>License</tt></i> BSD</li>
--   <li><i><tt>Version</tt></i> 1.0</li>
--   <li><i><tt>Status</tt></i> Alpha</li>
--   </ul>
module Control.Monad.IfElse

-- | A if with no else for unit returning thunks. Returns the value of the
--   test.
whenM :: Monad m => m Bool -> m () -> m ()

-- | Like a switch statement, and less cluttered than if else if
--   
--   <pre>
--   cond [ (t1,a1), (t2,a2), ... ]
--   </pre>
cond :: Monad m => [(Bool, m ())] -> m ()

-- | Like a switch statement, and less cluttered than if else if
--   
--   <pre>
--   condM [ (t1,a1), (t2,a2), ... ]
--   </pre>
condM :: Monad m => [(m Bool, m ())] -> m ()

-- | Chainable anaphoric when. Takes a maybe value.
--   
--   if the value is Just x then execute <tt> action x </tt> , then return
--   <tt> True </tt> . otherwise return <tt> False </tt> .
awhen :: Monad m => Maybe a -> (a -> m ()) -> m ()

-- | Chainable anaphoric whenM.
awhenM :: Monad m => m (Maybe a) -> (a -> m ()) -> m ()

-- | Anaphoric when-else chain. Like a switch statement, but less cluttered
acond :: Monad m => [(Maybe a, a -> m ())] -> m ()

-- | Anaphoric if.
aif :: Monad m => Maybe a -> (a -> m b) -> m b -> m b

-- | Anaphoric if where the test is in Monad m.
aifM :: Monad m => m (Maybe a) -> (a -> m b) -> m b -> m b

-- | Contrapositive of whenM, if not x then do y
--   
--   unless-else chain.
--   
--   monadic unless-else chain
ncondM :: Monad m => [(m Bool, m ())] -> m ()

-- | IO lifted <tt> &amp;&amp; </tt>
--   
--   IO lifted <tt> || </tt>
--   
--   Conditionally do the right action based on the truth value of the left
--   expression
--   
--   unless the left side is true, perform the right action
--   
--   unless the (monadic) left side is true, perform the right action
--   
--   Bind the result of the last expression in an anaphoric when.
--   
--   composition of <tt> &gt;&gt;= </tt> and <tt> &gt;&gt;? </tt>
--   
--   composition of <tt> &gt;&gt;= </tt> and <tt> &gt;&gt;=? </tt>
--   
--   Execute a monadic action so long as a monadic boolean returns true.
whileM :: Monad m => m Bool -> m () -> m ()

-- | Negation of <a>whileM</a>: execute an action so long as the boolean
--   returns false.
untilM :: Monad m => m Bool -> m () -> m ()

-- | Strict version of <a>return</a> because usually we don't need that
--   extra thunk.
return' :: Monad m => a -> m a

-- | Take an action and make it into a side-effecting <a>return</a>.
--   Because I seem to keep running into <tt>m ()</tt> and the like.
returning :: Monad m => (a -> m b) -> (a -> m a)

-- | This conversion is common enough to make a name for.
maybeMP :: MonadPlus m => Maybe a -> m a
