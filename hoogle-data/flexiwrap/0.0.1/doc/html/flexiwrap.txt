-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Flexible wrappers
--   
--   MPTC/FD framework using multi-purpose wrappers to direct instance
--   selection
@package flexiwrap
@version 0.0.1

module Data.Flex.MonadState
class FWMonadState m :: (* -> *) r | m -> r
data FWDefaultMonadState
FWDefaultMonadState :: FWDefaultMonadState
data FWGet t s m :: (* -> *)
FWGet :: FWGet t s
data FWPut t s m :: (* -> *)
FWPut :: FWPut t s

module Data.Flex.Functor
class FWFunctor f :: (* -> *) r | f -> r
data FWDefaultFunctor
FWDefaultFunctor :: FWDefaultFunctor
data FWFmap t f :: (* -> *)
FWFmap :: FWFmap t
newtype WrapFmap f
WrapFmap :: (forall a b. (a -> b) -> (f a -> f b)) -> WrapFmap f
unwrapFmap :: WrapFmap f -> forall a b. (a -> b) -> (f a -> f b)

module Data.Flex.Utils
inCompose :: (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
inCompose2 :: (forall a. f a -> a) -> (d -> e) -> (b -> c -> d) -> (f b -> f c -> e)
bindWrapper :: (forall q. f q -> g q) -> (d -> e) -> (g a -> (c -> g b) -> d) -> f a -> (c -> f b) -> e

module Data.Flex.Wrap
newtype FlexiWrap s a
FlexiWrap :: a -> FlexiWrap s a
unFlexiWrap :: FlexiWrap s a -> a
type FW = FlexiWrap
flexiWrap :: s -> a -> FW s a
inFlexiWrap :: (a -> b) -> (FW s a -> FW s b)
inFlexiWrap2 :: (a -> b -> c) -> (FW s a -> FW s b -> FW s c)
class FWNormAppend s t u | s t -> u
class FWrap w a b | w a -> b
fWrap :: FWrap w a b => w -> a -> b
class FWIsWrapped a r | a -> r
data FWAlreadyWrapped
FWAlreadyWrapped :: FWAlreadyWrapped
data FWNewWrapper
FWNewWrapper :: FWNewWrapper
data FWFWrap s a
FWFWrap :: FWFWrap s a
data FWTag
on :: (b -> b -> c) -> (a -> b) -> (a -> a -> c)
class FWEq a r | a -> r
data FWDefaultEq
FWDefaultEq :: FWDefaultEq
data FWEquals t a
FWEquals :: FWEquals t a
data FWNotEquals t a
FWNotEquals :: FWNotEquals t a
instance [overlap ok] (Apply (FWEquals t a) r (FW t a -> FW t a -> Bool), Apply (FWNotEquals t a) r (FW t a -> FW t a -> Bool), FWEq (FW t a) r) => Eq (FW t a)
instance [overlap ok] Eq a => Apply (FWNotEquals t a) FWDefaultEq (FW t a -> FW t a -> Bool)
instance [overlap ok] Eq a => Apply (FWEquals t a) FWDefaultEq (FW t a -> FW t a -> Bool)
instance [overlap ok] FWEq (FW s a) r => FWEq (FW (x :*: s) a) r
instance [overlap ok] TypeCast r FWDefaultEq => FWEq (FW t a) r
instance [overlap ok] (Apply FWTag a t, FWNormAppend s t u, FWIsWrapped a w, Apply (FWFWrap u a) w (a -> FW u b)) => FWrap s a (FW u b)
instance [overlap ok] TypeCast r TNil => Apply FWTag a r
instance [overlap ok] Apply FWTag (FW t a) t
instance [overlap ok] Apply (FWFWrap u (FW s a)) FWAlreadyWrapped (FW s a -> FW u a)
instance [overlap ok] Apply (FWFWrap u a) FWNewWrapper (a -> FW u a)
instance [overlap ok] TypeCast r FWNewWrapper => FWIsWrapped a r
instance [overlap ok] FWIsWrapped (FW s a) FWAlreadyWrapped
instance [overlap ok] TypeCast u (x :*: t) => FWNormAppend x t u
instance [overlap ok] FWNormAppend s t u => FWNormAppend (x :*: s) t (x :*: u)
instance [overlap ok] FWNormAppend TNil t t
instance [overlap ok] Monad (FW t)
instance [overlap ok] Traversable (FW t)
instance [overlap ok] Foldable (FW t)
instance [overlap ok] Applicative (FW t)
instance [overlap ok] Functor (FW t)

module Data.Flex.MonadTrans
class FWMonadTrans f :: ((* -> *) -> * -> *) a | f -> a
data FWDefaultMonadTrans
FWDefaultMonadTrans :: FWDefaultMonadTrans
data FWLift t :: ((* -> *) -> * -> *)
newtype WrapLift t
WrapLift :: (forall m a. Monad m => m a -> t m a) -> WrapLift t
unwrapLift :: WrapLift t -> forall m a. Monad m => m a -> t m a

module Data.Flex.MonadPlus
class FWMonadPlus m :: (* -> *) r | m -> r
data FWDefaultMonadPlus
FWDefaultMonadPlus :: FWDefaultMonadPlus
data FWMZero t m :: (* -> *)
FWMZero :: FWMZero t
newtype WrapMZero m
WrapMZero :: (forall a. m a) -> WrapMZero m
unwrapMZero :: WrapMZero m -> forall a. m a
data FWMPlus t m :: (* -> *)
FWMPlus :: FWMPlus t
newtype WrapMPlus m
WrapMPlus :: (forall a. m a -> m a -> m a) -> WrapMPlus m
unwrapMPlus :: WrapMPlus m -> forall a. m a -> m a -> m a

module Data.Flex.Monad
class FWMonad m :: (* -> *) r | m -> r
data FWDefaultMonad
FWDefaultMonad :: FWDefaultMonad
data FWReturn t m :: (* -> *)
FWReturn :: FWReturn t
newtype WrapReturn m
WrapReturn :: (forall a. a -> m a) -> WrapReturn m
unwrapReturn :: WrapReturn m -> forall a. a -> m a
wrapReturn :: (forall a. a -> m a) -> WrapReturn m
data FWBind t m :: (* -> *)
FWBind :: FWBind t
newtype WrapBind m
WrapBind :: (forall a b. m a -> (a -> m b) -> m b) -> WrapBind m
unwrapBind :: WrapBind m -> forall a b. m a -> (a -> m b) -> m b
wrapBind :: (forall a b. m a -> (a -> m b) -> m b) -> WrapBind m

module Data.Flex.WrapCTC
newtype FlexiWrapCTC s o f :: (* -> *) g :: (* -> *) a
FlexiWrapCTC :: o f g a -> FlexiWrapCTC s o a
unFlexiWrapCTC :: FlexiWrapCTC s o a -> o f g a
type FWCTC = FlexiWrapCTC
flexiWrapCTC :: s -> o f g a -> FWCTC s o f g a
inFlexiWrapCTC :: (o f g a -> o' f' g' a') -> (FWCTC s o f g a -> FWCTC s o' f' g' a')
inFlexiWrapCTC2 :: (o f g a -> o' f' g' a' -> o'' f'' g'' a'') -> (FWCTC s o f g a -> FWCTC s o' f' g' a' -> FWCTC s o'' f'' g'' a'')
data FWCTCDefaultFunctor
FWCTCDefaultFunctor :: FWCTCDefaultFunctor
data FWCTCDefaultMonad
FWCTCDefaultMonad :: FWCTCDefaultMonad
instance [overlap ok] (Apply (FWLift (FWCTC s o f)) r (WrapLift (FWCTC s o f)), FWMonadTrans (FWCTC s o f) r) => MonadTrans (FWCTC s o f)
instance [overlap ok] FWMonadTrans (FWCTC s o f) r => FWMonadTrans (FWCTC (x :*: s) o f) r
instance [overlap ok] (Monad (FWCTC t o m n), FWMonadPlus (FWCTC t o m n) r, Apply (FWMZero t (o m n)) r (WrapMZero (FWCTC t o m n)), Apply (FWMPlus t (o m n)) r (WrapMPlus (FWCTC t o m n))) => MonadPlus (FWCTC t o m n)
instance [overlap ok] FWMonadPlus (FWCTC s o m n) r => FWMonadPlus (FWCTC (t :*: s) o m n) r
instance [overlap ok] (Apply (FWReturn t (o m n)) r (WrapReturn (FWCTC t o m n)), Apply (FWBind t (o m n)) r (WrapBind (FWCTC t o m n)), FWMonad (FWCTC t o m n) r) => Monad (FWCTC t o m n)
instance [overlap ok] Monad (o m n) => Apply (FWBind t (o m n)) FWCTCDefaultMonad (WrapBind (FWCTC t o m n))
instance [overlap ok] Monad (o m n) => Apply (FWReturn t (o m n)) FWCTCDefaultMonad (WrapReturn (FWCTC t o m n))
instance [overlap ok] FWMonad (FWCTC s o m n) r => FWMonad (FWCTC (x :*: s) o m n) r
instance [overlap ok] TypeCast r FWCTCDefaultMonad => FWMonad (FWCTC t o m n) r
instance [overlap ok] (FWFunctor (FWCTC t o f g) r, Apply (FWFmap t (o f g)) r (WrapFmap (FWCTC t o f g))) => Functor (FWCTC t o f g)
instance [overlap ok] Functor (o f g) => Apply (FWFmap t (o f g)) FWCTCDefaultFunctor (WrapFmap (FWCTC t o f g))
instance [overlap ok] FWFunctor (FWCTC s o f g) r => FWFunctor (FWCTC (x :*: s) o f g) r
instance [overlap ok] TypeCast r FWCTCDefaultFunctor => FWFunctor (FWCTC t o f g) r

module Data.Flex.FlipT
newtype FlipT *. f :: (* -> *) g :: (* -> *) a
FlipT :: (g *. f) a -> FlipT *. a
unFlipT :: FlipT *. a -> (g *. f) a
inFlipT :: ((g *. f) a -> (g' ?. f') a') -> (FlipT *. f g a -> FlipT ?. f' g' a')
inFlipT2 :: ((g *. f) a -> (g' ?. f') a' -> (g'' @. f'') a'') -> (FlipT *. f g a -> FlipT ?. f' g' a' -> FlipT @. f'' g'' a'')
data FWFlipDefaults
FWFlipDefaults :: FWFlipDefaults
data FWFlipMonad
FWFlipMonad :: FWFlipMonad
data FWFlipMonadPlus
FWFlipMonadPlus :: FWFlipMonadPlus
instance MonadPlus (FWCTC t o g f) => Apply (FWMPlus t (FlipT o f g)) FWFlipMonadPlus (WrapMPlus (FWCTC t (FlipT o) f g))
instance MonadPlus (FWCTC t o g f) => Apply (FWMZero t (FlipT o f g)) FWFlipMonadPlus (WrapMZero (FWCTC t (FlipT o) f g))
instance FWMonadPlus (FWCTC (FWFlipDefaults :*: s) (FlipT o) f g) FWFlipMonadPlus
instance FWMonadPlus (FWCTC (FWFlipMonadPlus :*: s) (FlipT o) f g) FWFlipMonadPlus
instance Monad (FWCTC t o g f) => Apply (FWBind t (FlipT o f g)) FWFlipMonad (WrapBind (FWCTC t (FlipT o) f g))
instance Monad (FWCTC t o g f) => Apply (FWReturn t (FlipT o f g)) FWFlipMonad (WrapReturn (FWCTC t (FlipT o) f g))
instance FWMonad (FWCTC (FWFlipDefaults :*: s) (FlipT o) f g) FWFlipMonad
instance FWMonad (FWCTC (FWFlipMonad :*: s) (FlipT o) f g) FWFlipMonad

module Data.Flex.Compose
newtype (:.) f g a
O :: f (g a) -> :. f g a
unO :: :. f g a -> f (g a)
type O = :.
inO :: (f (g a) -> f' (g' b)) -> ((f :. g) a -> (f' :. g') b)
inO2 :: (f (g a) -> f' (g' b) -> f'' (g'' c)) -> ((f :. g) a -> (f' :. g') b -> (f'' :. g'') c)
flexiCompose :: s -> (forall b. b -> f b) -> g a -> FWCTC s O f g a
returnC :: (Monad m, Monad n) => a -> m (n a)
liftMC :: (Monad f, Monad g) => (a -> b) -> (f (g a) -> f (g b))
open :: FWCTC t O m n a -> m (n a)
close :: m (n a) -> FWCTC t O m n a
fmapC :: (Monad f, Monad g) => (a -> b) -> (FWCTC t O f g a -> FWCTC t O f g b)
wrapM :: (Monad m, Monad n) => (m (n (m (n a))) -> m (n a)) -> (FWCTC t O m n (FWCTC t O m n a) -> FWCTC t O m n a)
wrapFW :: (Monad m, Monad n) => (forall a. m (n (m (n a))) -> m (n a)) -> WrapBind (FWCTC t O m n)
class (Monad m, Monad n) => PComposable m n
prod :: PComposable m n => n (m (n a)) -> m (n a)
joinP :: PComposable m n => m (n (m (n a))) -> m (n a)
data FWCompP
FWCompP :: FWCompP
class (Monad m, Monad n) => DComposable m n
dorp :: DComposable m n => m (n (m a)) -> m (n a)
joinD :: DComposable m n => m (n (m (n a))) -> m (n a)
data FWCompD
FWCompD :: FWCompD
class (Monad m, Monad n) => SComposable m n
swap :: SComposable m n => n (m a) -> m (n a)
joinS :: SComposable m n => m (n (m (n a))) -> m (n a)
data FWCompS
FWCompS :: FWCompS
data FWCompDefaults
FWCompDefaults :: FWCompDefaults
data FWCompTrans
FWCompTrans :: FWCompTrans
data FWCompMonadPlus
FWCompMonadPlus :: FWCompMonadPlus
data FWCompMonadPlusL
FWCompMonadPlusL :: FWCompMonadPlusL
data FWCompMonadPlusR
FWCompMonadPlusR :: FWCompMonadPlusR
data FWCompMaybeMonadPlus
FWCompMaybeMonadPlus :: FWCompMaybeMonadPlus
instance [overlap ok] Monad m => Apply (FWMPlus t (O m Maybe)) FWCompMaybeMonadPlus (WrapMPlus (FWCTC t O m Maybe))
instance [overlap ok] Monad m => Apply (FWMZero t (O m Maybe)) FWCompMaybeMonadPlus (WrapMZero (FWCTC t O m Maybe))
instance [overlap ok] FWMonadPlus (FWCTC (FWCompMaybeMonadPlus :*: s) O m n) FWCompMaybeMonadPlus
instance [overlap ok] MonadPlus m => Apply (FWMPlus t (O m n)) FWCompMonadPlusL (WrapMPlus (FWCTC t O m n))
instance [overlap ok] MonadPlus m => Apply (FWMZero t (O m n)) FWCompMonadPlusL (WrapMZero (FWCTC t O m n))
instance [overlap ok] FWMonadPlus (FWCTC (FWCompMonadPlusL :*: s) O m n) FWCompMonadPlusL
instance [overlap ok] (Monad m, MonadPlus n) => Apply (FWMPlus t (O m n)) FWCompMonadPlusR (WrapMPlus (FWCTC t O m n))
instance [overlap ok] (Monad m, MonadPlus n) => Apply (FWMZero t (O m n)) FWCompMonadPlusR (WrapMZero (FWCTC t O m n))
instance [overlap ok] FWMonadPlus (FWCTC (FWCompDefaults :*: s) O m n) FWCompMonadPlusR
instance [overlap ok] FWMonadPlus (FWCTC (FWCompMonadPlus :*: s) O m n) FWCompMonadPlusR
instance [overlap ok] FWMonadPlus (FWCTC (FWCompMonadPlusR :*: s) O m n) FWCompMonadPlusR
instance [overlap ok] Monad m => Apply (FWLift (FWCTC t (FlipT O) m)) FWCompTrans (WrapLift (FWCTC t (FlipT O) m))
instance [overlap ok] Monad m => Apply (FWLift (FWCTC t O m)) FWCompTrans (WrapLift (FWCTC t O m))
instance [overlap ok] FWMonadTrans (FWCTC (FWCompDefaults :*: s) o f) FWCompTrans
instance [overlap ok] FWMonadTrans (FWCTC (FWCompTrans :*: s) o f) FWCompTrans
instance [overlap ok] Error e => SComposable (FW s) (Either e)
instance [overlap ok] SComposable (FW s) []
instance [overlap ok] Monoid s => SComposable (FW t) (Writer s)
instance [overlap ok] SComposable (FW s) (FW t)
instance [overlap ok] Monad m => SComposable (FW t) m
instance [overlap ok] Monad m => SComposable m (FW t)
instance [overlap ok] (Monad m, Error e) => SComposable m (Either e)
instance [overlap ok] (Monad m, Monoid s) => SComposable m (Writer s)
instance [overlap ok] Monad m => SComposable m []
instance [overlap ok] SComposable m n => Apply (FWBind t (O m n)) FWCompS (WrapBind (FWCTC t O m n))
instance [overlap ok] SComposable m n => Apply (FWReturn t (O m n)) FWCompS (WrapReturn (FWCTC t O m n))
instance [overlap ok] FWMonad (FWCTC (FWCompS :*: s) O m n) FWCompS
instance [overlap ok] Monad n => DComposable ((->) r) n
instance [overlap ok] DComposable m n => Apply (FWBind t (O m n)) FWCompD (WrapBind (FWCTC t O m n))
instance [overlap ok] DComposable m n => Apply (FWReturn t (O m n)) FWCompD (WrapReturn (FWCTC t O m n))
instance [overlap ok] FWMonad (FWCTC (FWCompD :*: s) O m n) FWCompD
instance [overlap ok] PComposable m n => Apply (FWBind t (O m n)) FWCompP (WrapBind (FWCTC t O m n))
instance [overlap ok] PComposable m n => Apply (FWReturn t (O m n)) FWCompP (WrapReturn (FWCTC t O m n))
instance [overlap ok] FWMonad (FWCTC (FWCompP :*: s) O m n) FWCompP
instance [overlap ok] Monad m => PComposable m Maybe

module Data.Flex.Applicative
class FWApplicative f :: (* -> *) r | f -> r
data FWDefaultApplicative
FWDefaultApplicative :: FWDefaultApplicative
data FWPure t f :: (* -> *)
FWPure :: FWPure t
newtype WrapPure f
WrapPure :: (forall a. a -> f a) -> WrapPure f
unwrapPure :: WrapPure f -> forall a. a -> f a
data FWCombine t f :: (* -> *)
FWCombine :: FWCombine t
newtype WrapCombine f
WrapCombine :: (forall a b. f (a -> b) -> (f a -> f b)) -> WrapCombine f
unwrapCombine :: WrapCombine f -> forall a b. f (a -> b) -> (f a -> f b)

module Data.Flex.WrapT
newtype FlexiWrapT s f a
FlexiWrapT :: f a -> FlexiWrapT s f a
unFlexiWrapT :: FlexiWrapT s f a -> f a
type FWT = FlexiWrapT
flexiWrapT :: s -> f a -> FWT s f a
inFlexiWrapT :: (f a -> g b) -> (FWT s f a -> FWT s g b)
inFlexiWrapT2 :: (f a -> g b -> h c) -> (FWT s f a -> FWT s g b -> FWT s h c)
asFlexiWrapT :: (FWT s f a -> FWT s g b) -> (f a -> g b)
data FWTDefaultFunctor
FWTDefaultFunctor :: FWTDefaultFunctor
data FWTDefaultApplicative
FWTDefaultApplicative :: FWTDefaultApplicative
data FWTDefaultMonad
FWTDefaultMonad :: FWTDefaultMonad
data FWTDefaultMonadAll
FWTDefaultMonadAll :: FWTDefaultMonadAll
data FWTDefaultMonadState
FWTDefaultMonadState :: FWTDefaultMonadState
class FwtMonadState s m | m -> s
fwtGet :: FwtMonadState s m => m s
fwtPut :: FwtMonadState s m => s -> m ()
class FWrapT w a b | w a -> b
fWrapT :: FWrapT w a b => w -> a -> b
data FWTagT
class FWCon a f :: (* -> *) | a -> f
class FWIsWrappedT a r | a -> r
data FWFWrapT s f :: (* -> *) a
FWFWrapT :: FWFWrapT s a
instance [overlap ok] (Apply FWTagT a t, FWCon a f, FWNormAppend s t u, FWIsWrappedT a w, Apply (FWFWrapT u f a) w (a -> FWT u f b)) => FWrapT s a (FWT u f b)
instance [overlap ok] Apply (FWFWrapT u f (FWT s f a)) FWAlreadyWrapped (FWT s f a -> FWT u f a)
instance [overlap ok] Apply (FWFWrapT u f (f a)) FWNewWrapper (f a -> FWT u f a)
instance [overlap ok] TypeCast r FWNewWrapper => FWIsWrappedT a r
instance [overlap ok] FWIsWrappedT (FWT s f a) FWAlreadyWrapped
instance [overlap ok] TypeCast (r a) (f a) => FWCon (f a) r
instance [overlap ok] FWCon (FWT t f a) f
instance [overlap ok] TypeCast r TNil => Apply FWTagT a r
instance [overlap ok] Apply FWTagT (FWT t f a) t
instance [overlap ok] (Apply (FWLift (FWT s)) r (WrapLift (FWT s)), FWMonadTrans (FWT s) r) => MonadTrans (FWT s)
instance [overlap ok] Apply (FWLift (FWT s)) FWDefaultMonadTrans (WrapLift (FWT s))
instance [overlap ok] FWMonadTrans (FWT s) r => FWMonadTrans (FWT (x :*: s)) r
instance [overlap ok] TypeCast r FWDefaultMonadTrans => FWMonadTrans (FWT t) r
instance [overlap ok] (Monad (FWT t m), FwtMonadState s (FWT t m)) => MonadState s (FWT t m)
instance [overlap ok] (MonadState s m, Apply (FWGet t s m) r (FWT t m s), Apply (FWPut t s m) r (s -> FWT t m ()), FWMonadState (FWT t m) r) => FwtMonadState s (FWT t m)
instance [overlap ok] MonadState s m => Apply (FWPut t s m) FWTDefaultMonadState (s -> FWT t m ())
instance [overlap ok] MonadState s m => Apply (FWGet t s m) FWTDefaultMonadState (FWT t m s)
instance [overlap ok] FWMonadState (FWT s m) r => FWMonadState (FWT (x :*: s) m) r
instance [overlap ok] FWMonadState (FWT (FWTDefaultMonadAll :*: s) m) FWTDefaultMonadState
instance [overlap ok] FWMonadState (FWT (FWTDefaultMonadState :*: s) m) FWTDefaultMonadState
instance [overlap ok] TypeCast r FWTDefaultMonadState => FWMonadState (FWT t m) r
instance [overlap ok] (Apply (FWReturn t m) r (WrapReturn (FWT t m)), Apply (FWBind t m) r (WrapBind (FWT t m)), FWMonad (FWT t m) r) => Monad (FWT t m)
instance [overlap ok] Monad m => Apply (FWBind t m) FWTDefaultMonad (WrapBind (FWT t m))
instance [overlap ok] Monad m => Apply (FWReturn t m) FWTDefaultMonad (WrapReturn (FWT t m))
instance [overlap ok] FWMonad (FWT s m) r => FWMonad (FWT (x :*: s) m) r
instance [overlap ok] FWMonad (FWT (FWTDefaultMonadAll :*: s) m) FWTDefaultMonad
instance [overlap ok] FWMonad (FWT (FWTDefaultMonad :*: s) m) FWTDefaultMonad
instance [overlap ok] TypeCast r FWTDefaultMonad => FWMonad (FWT t m) r
instance [overlap ok] (Apply (FWPure t f) r (WrapPure (FWT t f)), Apply (FWCombine t f) r (WrapCombine (FWT t f)), FWApplicative (FWT t f) r, Functor (FWT t f)) => Applicative (FWT t f)
instance [overlap ok] Applicative f => Apply (FWCombine t f) FWTDefaultApplicative (WrapCombine (FWT t f))
instance [overlap ok] Applicative f => Apply (FWPure t f) FWTDefaultApplicative (WrapPure (FWT t f))
instance [overlap ok] FWApplicative (FWT s f) r => FWApplicative (FWT (x :*: s) f) r
instance [overlap ok] TypeCast r FWTDefaultApplicative => FWApplicative (FWT t f) r
instance [overlap ok] (FWFunctor (FWT t f) r, Apply (FWFmap t f) r (WrapFmap (FWT t f))) => Functor (FWT t f)
instance [overlap ok] Functor f => Apply (FWFmap t f) FWTDefaultFunctor (WrapFmap (FWT t f))
instance [overlap ok] FWFunctor (FWT s f) r => FWFunctor (FWT (x :*: s) f) r
instance [overlap ok] TypeCast r FWTDefaultFunctor => FWFunctor (FWT t f) r

module Data.Flex.WrappedMonad
data FWWrapMonad
FWWrapMonad :: FWWrapMonad
data FWMonadFunctor
FWMonadFunctor :: FWMonadFunctor
data FWMonadApplicative
FWMonadApplicative :: FWMonadApplicative
instance Monad m => Apply (FWCombine t m) FWMonadApplicative (WrapCombine (FWT t m))
instance Monad m => Apply (FWPure t m) FWMonadApplicative (WrapPure (FWT t m))
instance FWApplicative (FWT (FWMonadApplicative :*: s) f) FWMonadApplicative
instance FWApplicative (FWT (FWWrapMonad :*: s) f) FWMonadApplicative
instance Monad m => Apply (FWFmap t m) FWMonadFunctor (WrapFmap (FWT t m))
instance FWFunctor (FWT (FWMonadFunctor :*: s) f) FWMonadFunctor
instance FWFunctor (FWT (FWWrapMonad :*: s) f) FWMonadFunctor
