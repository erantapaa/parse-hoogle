-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parse and evaluate mathematical expressions.
--   
--   Parse and evaluate mathematical expressions.
@package ParserFunction
@version 0.1.0


-- | Parse and evaluate mathematical expressions.
module Text.Parsec.Expr.Math

-- | Mathematical expressions.
data Expr a
Num :: a -> Expr a
Var :: String -> Expr a
Neg :: (Expr a) -> Expr a
Add :: (Expr a) -> (Expr a) -> Expr a
Sub :: (Expr a) -> (Expr a) -> Expr a
Mul :: (Expr a) -> (Expr a) -> Expr a
Div :: (Expr a) -> (Expr a) -> Expr a
Pow :: (Expr a) -> (Expr a) -> Expr a
Sqrt :: (Expr a) -> Expr a
Exp :: (Expr a) -> Expr a
Log :: (Expr a) -> Expr a
Abs :: (Expr a) -> Expr a
Sin :: (Expr a) -> Expr a
Cos :: (Expr a) -> Expr a
Tan :: (Expr a) -> Expr a
Sec :: (Expr a) -> Expr a
Csc :: (Expr a) -> Expr a
Cot :: (Expr a) -> Expr a
Sinh :: (Expr a) -> Expr a
Cosh :: (Expr a) -> Expr a
Tanh :: (Expr a) -> Expr a
Sech :: (Expr a) -> Expr a
Csch :: (Expr a) -> Expr a
Coth :: (Expr a) -> Expr a
ArcSin :: (Expr a) -> Expr a
ArcCos :: (Expr a) -> Expr a
ArcTan :: (Expr a) -> Expr a
ArcSec :: (Expr a) -> Expr a
ArcCsc :: (Expr a) -> Expr a
ArcCot :: (Expr a) -> Expr a
ArcSinh :: (Expr a) -> Expr a
ArcCosh :: (Expr a) -> Expr a
ArcTanh :: (Expr a) -> Expr a
ArcSech :: (Expr a) -> Expr a
ArcCsch :: (Expr a) -> Expr a
ArcCoth :: (Expr a) -> Expr a

-- | Parse a mathematical expression.
--   
--   <pre>
--   &gt;&gt;&gt; parse "exp(-pi*i)+1"
--   Right (Add (Exp (Mul (Neg (Var "pi")) (Var "i"))) (Num 1.0))
--   </pre>
parse :: Floating a => String -> Either ParseError (Expr a)

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <a>parse</a>. <tt>ParseError</tt> is an
--   instance of the <a>Show</a> class.
data ParseError :: *

-- | Evaluate a mathematical expression using the supplied variable
--   definitions.
--   
--   <pre>
--   &gt;&gt;&gt; :m + Data.Complex Data.Map
--   &gt;&gt;&gt; let def = fromList [("pi", pi), ("i", 0 :+ 1)]
--   &gt;&gt;&gt; evaluate def . Just $ Add (Exp (Mul (Neg (Var "pi")) (Var "i"))) (Num 1.0)
--   Just (0.0 :+ (-1.2246467991473532e-16))
--   </pre>
evaluate :: Floating a => Map String a -> Maybe (Expr a) -> Maybe a
instance Show a => Show (Expr a)
