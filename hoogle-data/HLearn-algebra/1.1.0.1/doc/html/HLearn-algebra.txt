-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Algebraic foundation for homomorphic learning
--   
--   This module contains the algebraic basis for the HLearn library. It is
--   separated out in it's own library because it contains routines that
--   may be useful to others. In particular, it contains methods for
--   automatically converting algorithms into online/parallel versions, and
--   its structure is slightly more modular (although much less complete)
--   than other algebra packages.
@package HLearn-algebra
@version 1.1.0.1


-- | This module was automatically generated by Nat1Generator.hs
module HLearn.Algebra.Types.Nat1
data Nat1Box (n :: Nat1)
Nat1Box :: Nat1Box
data Nat1
Zero :: Nat1
Succ :: Nat1 -> Nat1
instance Read Nat1
instance Show Nat1
instance Eq Nat1
instance Ord Nat1


-- | Provides a generic interface to structures that offer both a left and
--   right cons. It's based on the Data.Sequence interface.
module HLearn.Algebra.Structures.Triangles

-- | Methods for left and right cons on a data type
class Triangle f a
(<|) :: Triangle f a => a -> f -> f
(|>) :: Triangle f a => f -> a -> f
instance Triangle (Seq a) a
instance Triangle [a] a


-- | These algebraic structures have sacrificed generality in favor of
--   being easily used with the standard Haskell Prelude. The fact that
--   monoids are not guaranteed to be semigroups makes this difficult.
module HLearn.Algebra.Structures.Groups

-- | Groups are monoids that also have an inverse. See
--   <a>https://en.wikipedia.org/wiki/Regular_semigroup</a>
class Monoid g => Group g
inverse :: Group g => g -> g
class Monoid m => Abelian m
data FreeInverse a
FreeInverse :: !a -> FreeInverse a
Negate :: !a -> FreeInverse a
class Invertible a
mkinverse :: Invertible a => a -> a
isInverse :: Invertible a => a -> a -> Bool
instance Read a => Read (FreeInverse a)
instance Show a => Show (FreeInverse a)
instance Eq a => Eq (FreeInverse a)
instance Eq a => Invertible (FreeInverse a)
instance Ord a => Ord (FreeInverse a)


-- | Modules are a generalization of vector spaces
module HLearn.Algebra.Structures.Modules
class Num (Ring m) => HasRing m where type family Ring m

-- | Bug: The module classes have the constraint that r be of type Num.
--   Technically, this should be a Ring. But creating a Ring class would be
--   awkward because it would conflict with the Num class and require
--   importing a different Prelude.
class (HasRing m, Abelian m, Group m) => Module m where m *. r = r .* m
(.*) :: Module m => (Ring m) -> m -> m
(*.) :: Module m => m -> (Ring m) -> m
class (Module m, Fractional (Ring m)) => VectorSpace m where m /. r = m *. (1 / r)
(/.) :: VectorSpace m => m -> (Ring m) -> m
instance (Module m, Fractional (Ring m)) => VectorSpace m


-- | Metric spaces are mathematical structures that have a notion of
--   distance between objects. See wikipedia for more information:
--   <a>https://en.wikipedia.org/wiki/Metric_space</a>
module HLearn.Algebra.Structures.MetricSpace

-- | We assume that the MetricSpace on s is compatible with the ordering on
--   s
class HasRing s => MetricSpace s
distance :: MetricSpace s => s -> s -> Ring s
class (HasRing m, Ord (Ring m)) => Norm m
magnitude :: Norm m => m -> Ring m

module HLearn.Algebra.Types.HList

-- | The heterogenous list
data HList :: [*] -> *
HNil :: HList '[]
(:::) :: t -> HList ts -> HList (t : ts)

-- | Used only for the HList class to determine its length
class HLength xs
hlength :: HLength xs => xs -> Int

-- | For construction from lists
class List2HList x xs
list2hlist :: List2HList x xs => [x] -> HList (x : xs)

-- | For converting into a list
class HList2List xs a | xs -> a
hlist2list :: HList2List xs a => xs -> [a]

-- | Equivalent to prelude's <a>take</a>
class HTake1 n xs1 xs2 | n xs1 -> xs2
htake1 :: HTake1 n xs1 xs2 => n -> xs1 -> xs2

-- | Equivalent to prelude's <a>drop</a>
class HDrop1 n xs1 xs2 | n xs1 -> xs2
hdrop1 :: HDrop1 n xs1 xs2 => n -> xs1 -> xs2

-- | Equivalent to prelude's <a>map</a>
class HMap f xs1 xs2 | f xs1 -> xs2
hmap :: HMap f xs1 xs2 => f -> xs1 -> xs2
class TypeList t
typeList :: TypeList t => t -> [TypeRep]
class ConstraintBox box a
box :: ConstraintBox box a => a -> box
unsafeUnbox :: ConstraintBox box a => box -> a
class Downcast h box where downcastAs box = downcast
downcast :: Downcast h box => h -> [box]
downcastAs :: Downcast h box => (a -> box) -> h -> [box]

-- | Use this box unless you know for certain that your types won't have a
--   show instance.
data ShowBox
ShowBox :: !a -> ShowBox

-- | Most generic box, can be used on any type.
data AnyBox
AnyBox :: !a -> AnyBox
data Nat1
Zero :: Nat1
Succ :: Nat1 -> Nat1
data Nat1Box (n :: Nat1)
Nat1Box :: Nat1Box
instance Show a => ConstraintBox ShowBox a
instance Show ShowBox
instance (ConstraintBox box x, Downcast (HList xs) box) => Downcast (HList ((':) * x xs)) box
instance Downcast (HList ('[] *)) a
instance HMap (x1 -> x2) (HList xs1) (HList xs2) => HMap (x1 -> x2) (HList ((':) * x1 xs1)) (HList ((':) * x2 xs2))
instance HMap f (HList ('[] *)) (HList ('[] *))
instance HTake1 (Nat1Box n) (HList xs1) (HList xs2) => HTake1 (Nat1Box ('Succ n)) (HList ((':) * x xs1)) (HList ((':) * x xs2))
instance HTake1 (Nat1Box 'Zero) (HList xs1) (HList ('[] *))
instance HDrop1 (Nat1Box n) (HList xs1) (HList xs2) => HDrop1 (Nat1Box ('Succ n)) (HList ((':) * x xs1)) (HList xs2)
instance HDrop1 (Nat1Box 'Zero) (HList xs1) (HList xs1)
instance List2HList x xs => List2HList x ((':) * x xs)
instance List2HList x ('[] *)
instance HList2List (HList xs) a => HList2List (HList ((':) * a xs)) a
instance HList2List (HList ('[] *)) a
instance HLength (HList xs) => HLength (HList ((':) * x xs))
instance HLength (HList ('[] *))
instance (TypeList (HList xs), Typeable x) => TypeList (HList ((':) * x xs))
instance TypeList (HList ('[] *))
instance TypeList (HList xs) => Typeable (HList xs)
instance (Monoid x, Monoid (HList xs)) => Monoid (HList ((':) * x xs))
instance Monoid (HList ('[] *))
instance (Ord x, Ord (HList xs)) => Ord (HList ((':) * x xs))
instance Ord (HList ('[] *))
instance (Eq x, Eq (HList xs)) => Eq (HList ((':) * x xs))
instance Eq (HList ('[] *))
instance (Show x, Show (HList xs)) => Show (HList ((':) * x xs))
instance Show (HList ('[] *))

module HLearn.Algebra.Types.Indexing

-- | index into a data type, all of whose members have the same type
class (Eq (IndexType datatype), Bounded (IndexType datatype), Enum (IndexType datatype)) => Index datatype where type family IndexType datatype type family IndexResult datatype
(!) :: Index datatype => datatype -> IndexType datatype -> IndexResult datatype

-- | index into a data type, but the result type depends on which record
--   we're indexing
class DepIndex datatype index where type family DepIndexResult datatype index
(#) :: DepIndex datatype index => datatype -> index -> datatype DepIndexResult index

-- | defines a canonical ordering of all elments in the data type
class IndexList datatype (HList (DepIndexList datatype)) => HasDepIndex datatype where type family DepIndexList datatype :: [*] datatype2valueList dp = valueList dp (depIndexList dp)
depIndexList :: HasDepIndex datatype => datatype -> HList (DepIndexList datatype)
datatype2valueList :: (HasDepIndex datatype, HasDepIndex datatype) => datatype -> HList (ValueList datatype)
type ValueList datatype = IndexList2ValueList datatype (HList (DepIndexList datatype))

-- | Creates data types and instances for indexing into a class. Dependent
--   indices are preficed with "TH_" and normal indices by "I_". The
--   dependent indices and <a>DepIndex</a> instances are always created.
--   The normal index data types are always created, but the <a>Index</a>
--   instance is created only if all records within the data type have the
--   same type.
makeIndex :: Name -> Q [Dec]
data TH_0
data TH_1
data TH_2
data TH_3
instance (Ord a, Num a) => Index (a, a, a)
instance DepIndex (a, b, c) TH_2
instance DepIndex (a, b, c) TH_1
instance DepIndex (a, b, c) TH_0
instance (Ord a, Num a) => Index (a, a)
instance DepIndex (a, b) TH_1
instance DepIndex (a, b) TH_0
instance (IndexList dp (HList xs), DepIndex dp x) => IndexList dp (HList ((':) * x xs))
instance IndexList dp (HList ('[] *))
instance DepIndex (HList xs) (Nat1Box n) => DepIndex (HList ((':) * x xs)) (Nat1Box ('Succ n))
instance DepIndex (HList ((':) * x xs)) (Nat1Box 'Zero)
instance DepIndex (HList ('[] *)) (Nat1Box 'Zero)


-- | This module contains "low-level higher order functions" for
--   manipulating algebraic homomorphisms. You probably want to use the
--   <a>HomTrainer</a> type-class rather than using these functions
--   directly.
module HLearn.Algebra.Functions

-- | Every data type that implements this class has a corresponding
--   function. We can use this data type as type level parameters to other
--   data types. This gives us some of the benefit of dependently typed
--   functions.
class Function f domain range | f domain -> range
function :: Function f domain range => f -> domain -> range

-- | Parallelizes any batch trainer to run over multiple processors on a
--   single machine. The function automatically detects the number of
--   available processors and parallelizes the function accordingly. This
--   requires the use of unsafePerformIO, however, the result should still
--   be safe.
parallel :: (Monoid model, NFData model, Partitionable container, PartitionableConstraint container datapoint) => (container datapoint -> model) -> (container datapoint -> model)

-- | Converts a batch trainer into an online trainer. The input function
--   should be a semigroup homomorphism.
online :: Monoid model => (datapoint -> model) -> (model -> datapoint -> model)

-- | The inverse of <a>online</a>. Converts an online trainer into a batch
--   trainer.
offline :: Monoid model => (model -> datapoint -> model) -> (datapoint -> model)

-- | Converts a singleton trainer into a batch trainer, which is also a
--   semigroup homomorphism.
batch :: (Monoid model, Functor container, Foldable container) => (datapoint -> model) -> (container datapoint -> model)
batchCK :: (Monoid model, Functor container, FunctorConstraint container model, FunctorConstraint container datapoint, Foldable container, FoldableConstraint container model) => (datapoint -> model) -> (container datapoint -> model)

-- | Inverse of <a>unbatch</a>. Converts a semigroup homomorphism into a
--   singleton trainer.
unbatch :: ([datapoint] -> model) -> (datapoint -> model)

-- | Normally we would define our semigroup operation explicitly. However,
--   it is possible to generate one from an online trainer and a pseudo
--   inverse.
semigroup :: (model -> datapoint -> model) -> (model -> datapoint) -> (model -> model -> model)

-- | Like fold, but (i) only for use on the semigroup operation (&lt;&gt;)
--   and (ii) uses the fan-in reduction strategy which is more efficient
--   when the semigroup operation takes nonconstant time depending on the
--   size of the data structures being reduced.
reduce :: (Monoid sg, Foldable container) => container sg -> sg


-- | Every model in the HLearn library is an instance of the
--   <a>HomTrainer</a> type class. This ensures that the batch trainer is a
--   monoid homomorphism. This is a restrictive condition that not all
--   learning models satisfy; however, it is useful for two reasons. First,
--   this property lets us easily derive three important functions for
--   machine learning algorithms: online trainers, parallel trainers, and
--   fast cross-validation algorithms. Second, many popular algorithms (or
--   variants on them) satisfy the condition and are implemented in the
--   library.
--   
--   For a full theoretical description of the <a>HomTrainer</a> class, see
--   the paper: <a>HERE</a>
--   
--   Unfortunately, the class hierarchy here is slightly more complicated.
--   In the paper, we assume that all parameters for a model can be
--   included in the model's type. Currently, however, this is not possible
--   in Haskell, so every model must also have a data type that describes
--   it's parameters. This is the purpose of the <tt>ModelParams</tt>
--   class. Most models have either no parameters, or reasonable defaults,
--   and so their parameters are instances of the <tt>DefaultParams</tt>
--   class.
module HLearn.Algebra.Models.HomTrainer

-- | A minimal complete definition of the class is the singleton trainer
--   'train1dp\''
class Monoid model => HomTrainer model where type family Datapoint model train1dp = unbatch train train = batch train1dp add1dp model = online train1dp model addBatch model = online train model trainCK = batchCK train1dp addBatchCK model = online trainCK model
train1dp :: HomTrainer model => Datapoint model -> model
train :: (HomTrainer model, Functor container, Foldable container) => container (Datapoint model) -> model
add1dp :: HomTrainer model => model -> Datapoint model -> model
addBatch :: (HomTrainer model, Functor container, Foldable container) => model -> container (Datapoint model) -> model
trainCK :: (HomTrainer model, Functor container, FunctorConstraint container model, FunctorConstraint container (Datapoint model), Foldable container, FoldableConstraint container model, FoldableConstraint container (Datapoint model)) => container (Datapoint model) -> model
addBatchCK :: (HomTrainer model, Functor container, FunctorConstraint container model, FunctorConstraint container (Datapoint model), Foldable container, FoldableConstraint container model, FoldableConstraint container (Datapoint model)) => model -> container (Datapoint model) -> model
class (Module model, HomTrainer model) => WeightedHomTrainer model where train1dpW (r, dp) = r .* train1dp dp trainW = batch train1dpW add1dpW = online $ unbatch $ offline addBatchW addBatchW = online trainW
train1dpW :: WeightedHomTrainer model => (Ring model, Datapoint model) -> model
trainW :: (WeightedHomTrainer model, Foldable container, Functor container) => container (Ring model, Datapoint model) -> model
add1dpW :: WeightedHomTrainer model => model -> WeightedDatapoint model -> model
addBatchW :: (WeightedHomTrainer model, Foldable container, Functor container) => model -> container (WeightedDatapoint model) -> model

-- | numdp returns the number of data points that the model has been
--   trained on
class HasRing model => NumDP model
numdp :: NumDP model => model -> Ring model

-- | subtracts a single data point from the model
sub1dp :: (Group model, HomTrainer model) => model -> Datapoint model -> model

-- | subtracts a multiple data point from the model
subBatch :: (Group model, HomTrainer model, Foldable container, Functor container) => model -> container (Datapoint model) -> model

-- | subtracts a single weighted data point from the model
sub1dpW :: (Group model, WeightedHomTrainer model) => model -> WeightedDatapoint model -> model

-- | subtracts multiple weighted data points from the model
subBatchW :: (Group model, WeightedHomTrainer model, Foldable container, Functor container) => model -> container (WeightedDatapoint model) -> model
instance (Module model, HomTrainer model) => WeightedHomTrainer model


-- | Lame trainers are trainers that are crippled---They are not Monoids,
--   and training their models is not a homomorphism. This means we can't
--   do any of the cool manipulations automatically that we can do with the
--   HomTrainer class. These classes are provided mostly for development
--   and testing purposes. It is not recommended that you use any of their
--   instances.
module HLearn.Algebra.Models.Lame

-- | Provides a non-homomorphic batch trainer
class LameTrainer model where type family LameDatapoint model :: * type family LameContainer model :: * -> *
lame_train :: LameTrainer model => (LameContainer model) (LameDatapoint model) -> model

-- | Provides a non-homomorphic online trainer
class LameTrainerOnline model where type family LameDatapointOnline model :: *
lame_add1dp :: LameTrainerOnline model => model -> LameDatapointOnline model -> model
instance HomTrainer model => LameTrainer model

module HLearn.Algebra.Structures.Free.Bagging
type Bagging n model = Bagging' n 0 model
data Bagging' (n :: Nat) (seed :: Nat) model
instance Read model => Read (Bagging' n seed model)
instance Show model => Show (Bagging' n seed model)
instance Eq model => Eq (Bagging' n seed model)
instance Ord model => Ord (Bagging' n seed model)
instance (HomTrainer model, SingI Nat n, SingI Nat seed, Hashable (Datapoint model)) => HomTrainer (Bagging' n seed model)
instance (Module model, SingI Nat n) => Module (Bagging' n seed model)
instance HasRing model => HasRing (Bagging' n seed model)
instance (Group model, SingI Nat n) => Group (Bagging' n seed model)
instance (Monoid model, SingI Nat n) => Monoid (Bagging' n seed model)
instance (Abelian model, SingI Nat n) => Abelian (Bagging' n seed model)

module HLearn.Algebra.Structures.Free.FreeModule
newtype FreeModule r a
FreeModule :: Map a r -> FreeModule r a
getMap :: FreeModule r a -> Map a r
list2module :: (Num r, Ord r, Ord a) => [a] -> FreeModule r a
instance (Ord a, Read r, Read a) => Read (FreeModule r a)
instance (Show r, Show a) => Show (FreeModule r a)
instance (Eq r, Eq a) => Eq (FreeModule r a)
instance (Ord r, Ord a) => Ord (FreeModule r a)
instance (NFData r, NFData a) => NFData (FreeModule r a)
instance (Num r, Ord a) => HomTrainer (FreeModule r a)
instance Functor (FreeModule r)
instance (Num r, Ord a) => Module (FreeModule r a)
instance Num r => HasRing (FreeModule r a)
instance (Num r, Ord a) => Group (FreeModule r a)
instance (Num r, Ord a) => Monoid (FreeModule r a)
instance (Num r, Ord a) => Abelian (FreeModule r a)

module HLearn.Algebra.Structures.Free.FreeHomTrainer
data NoFlatten
data AbelianGroup
data FreeHomTrainer' container model
instance Module (container model) => Module (FreeHomTrainer' k container model)
instance Read (container model) => Read (FreeHomTrainer' k container model)
instance Show (container model) => Show (FreeHomTrainer' k container model)
instance Eq (container model) => Eq (FreeHomTrainer' k container model)
instance Ord (container model) => Ord (FreeHomTrainer' k container model)
instance Monoid (container model) => Monoid (FreeHomTrainer' k container model)
instance Group (container model) => Group (FreeHomTrainer' k container model)
instance Abelian (container model) => Abelian (FreeHomTrainer' k container model)
instance (Num ring, Ord model, LameTrainer model) => HomTrainer (FreeHomTrainer' * (FreeModule ring) model)
instance (Num ring, Ord model, LameTrainer model, Applicative container, Monoid (container model)) => HomTrainer (FreeHomTrainer' * container model)
instance HasRing (container model) => HasRing (FreeHomTrainer' k container model)

module HLearn.Algebra.Models.CoHomTrainer

-- | A <a>CoHomTrainer</a> is a formal way of describing a generative
--   model.
class CoHomTrainer model where type family CoDatapoint model cotrain1dp model = fmap fst (coadd1dp model) cotrain = sequence . repeat . cotrain1dp coaddBatch = sequence . repeat . coadd1dp
cotrain1dp :: CoHomTrainer model => model -> Rand g (CoDatapoint model)
cotrain :: CoHomTrainer model => model -> Rand g ([CoDatapoint model])
coadd1dp :: CoHomTrainer model => model -> Rand g ((CoDatapoint model, model))
coaddBatch :: CoHomTrainer model => model -> Rand g ([(CoDatapoint model, model)])


-- | This is the base module for the HLearn library. It exports all the
--   functions / data structures needed.
module HLearn.Algebra
