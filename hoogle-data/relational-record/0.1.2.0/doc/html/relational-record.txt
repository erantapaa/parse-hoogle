-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Meta package of Relational Record
--   
@package relational-record
@version 0.1.2.0


-- | This module is documentation module for relational record.
module Database.Relational.Query.Documentation

-- | Join sub-query. Query result is not <a>Maybe</a>.
query :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation () r -> m (Projection Flat r)

-- | Join sub-query. Query result is <a>Maybe</a>. The combinations of
--   <a>query</a> and <a>queryMaybe</a> express inner joins, left outer
--   joins, right outer joins, and full outer joins. Here is an example of
--   a right outer join:
--   
--   <pre>
--   outerJoin = relation $ do
--     e &lt;- queryMaybe employee
--     d &lt;- query department
--     on $ e ?! E.deptId' .=. just (d ! D.deptId')
--     return $ (,) |$| e |*| d
--   </pre>
queryMaybe :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation () r -> m (Projection Flat (Maybe r))

-- | Add restriction to last join. Projection type version.
on :: MonadQuery m => Projection Flat (Maybe Bool) -> m ()

-- | Add restriction to this not aggregated query.
wheres :: MonadRestrict Flat m => Projection Flat (Maybe Bool) -> m ()

-- | Add <i>GROUP BY</i> term into context and get aggregated projection.
groupBy :: MonadAggregate m => Projection Flat r -> m (Projection Aggregated r)

-- | Add restriction to this aggregated query. Aggregated Projection type
--   version.
having :: MonadRestrict Aggregated m => Projection Aggregated (Maybe Bool) -> m ()

-- | Specify DISTINCT attribute to query context.
distinct :: MonadQuery m => m ()

-- | Specify ALL attribute to query context.
all' :: MonadQuery m => m ()

-- | Add and assginment.
(<-#) :: Monad m => AssignTarget r v -> Projection Flat v -> Assignings r m ()

-- | Direct inner join.
inner :: Relation () a -> Relation () b -> [JoinRestriction a b] -> Relation () (a, b)

-- | Direct left outer join.
left :: Relation () a -> Relation () b -> [JoinRestriction a (Maybe b)] -> Relation () (a, Maybe b)

-- | Direct right outer join.
right :: Relation () a -> Relation () b -> [JoinRestriction (Maybe a) b] -> Relation () (Maybe a, b)

-- | Direct full outer join.
full :: Relation () a -> Relation () b -> [JoinRestriction (Maybe a) (Maybe b)] -> Relation () (Maybe a, Maybe b)

-- | Apply restriction for direct join style.
on' :: ([JoinRestriction a b] -> Relation pc (a, b)) -> [JoinRestriction a b] -> Relation pc (a, b)

-- | Relation type with place-holder parameter <tt>p</tt> and query result
--   type <tt>r</tt>.
data Relation p r :: * -> * -> *

-- | Finalize <a>QuerySimple</a> monad and generate <a>Relation</a>.
relation :: QuerySimple (Projection Flat r) -> Relation () r

-- | Finalize <a>QueryAggregate</a> monad and geneate <a>Relation</a>.
aggregateRelation :: QueryAggregate (Projection Aggregated r) -> Relation () r

-- | UpdateTarget type with place-holder parameter <tt>p</tt> and
--   projection record type <tt>r</tt>.
data UpdateTarget p r :: * -> * -> *

-- | Finalize <tt>Target</tt> monad and generate <a>UpdateTarget</a>.
updateTarget :: AssignStatement r () -> UpdateTarget () r

-- | Restriction type with place-holder parameter <tt>p</tt> and projection
--   record type <tt>r</tt>.
data Restriction p r :: * -> * -> *

-- | Finalize <a>Restrict</a> monad and generate <a>Restriction</a>.
restriction :: RestrictedStatement r () -> Restriction () r

-- | Phantom typed projection. Projected into Haskell record type
--   <tt>t</tt>.
data Projection c t :: * -> * -> *

-- | Type tag for flat (not-aggregated) query
data Flat :: *

-- | Type tag for aggregated query
data Aggregated :: *

-- | Type tag for exists predicate
data Exists :: *

-- | Type tag for window function building
data OverWindow :: *

-- | Projection path from type <tt>r0</tt> into type <tt>r1</tt>. This type
--   also indicate key object which type is <tt>r1</tt> for record type
--   <tt>r0</tt>.
data Pi r0 r1 :: * -> * -> *

-- | Get narrower projection along with projection path and project into
--   result projection type.
(!) :: Projectable Projection p => Projection c a -> Pi a b -> p c b

-- | Compose projection path.
(<.>) :: Pi a b -> Pi b c -> Pi a c

-- | Generate polymorphic projection of SQL constant values from Haskell
--   value.
value :: (ShowConstantTermsSQL t, OperatorProjectable p) => t -> p t

-- | Polymorphic proejction of SQL set value from Haskell list.
values :: (ShowConstantTermsSQL t, OperatorProjectable p) => [t] -> ListProjection p t

-- | Compare operator corresponding SQL <i>=</i> .
(.=.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&lt;</i> .
(.<.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&lt;=</i> .
(.<=.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&gt;</i> .
(.>.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&gt;=</i> .
(.>=.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&lt;&gt;</i> .
(.<>.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Same as <a>caseSearch</a>, but you can write like <a>list</a>
--   <a>casesOrElse</a> <a>clause</a>.
casesOrElse :: (OperatorProjectable p, ProjectableShowSql p) => [(p (Maybe Bool), p a)] -> p a -> p a

-- | Simple case operator correnponding SQL simple <i>CASE</i>. Like,
--   <i>CASE x WHEN v THEN a WHEN w THEN b ... ELSE c END</i>
case' :: (OperatorProjectable p, ProjectableShowSql p) => p a -> [(p a, p b)] -> p b -> p b

-- | Binary operator corresponding SQL <i>IN</i> .
in' :: (OperatorProjectable p, ProjectableShowSql p) => p t -> ListProjection p t -> p (Maybe Bool)

-- | Logical operator corresponding SQL <i>AND</i> .
and' :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Logical operator corresponding SQL <i>OR</i> .
or' :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Operator corresponding SQL <i>IS NULL</i> , and extended against
--   record types.
isNothing :: (OperatorProjectable (Projection c), ProjectableShowSql (Projection c), HasColumnConstraint NotNull r) => Projection c (Maybe r) -> Projection c (Maybe Bool)

-- | Operator corresponding SQL <i>NOT (... IS NULL)</i> , and extended
--   against record type.
isJust :: (OperatorProjectable (Projection c), ProjectableShowSql (Projection c), HasColumnConstraint NotNull r) => Projection c (Maybe r) -> Projection c (Maybe Bool)

-- | Operator from maybe type using record extended <tt>isNull</tt>.
fromMaybe :: (OperatorProjectable (Projection c), ProjectableShowSql (Projection c), HasColumnConstraint NotNull r) => Projection c r -> Projection c (Maybe r) -> Projection c r

-- | Logical operator corresponding SQL <i>NOT</i> .
not' :: (OperatorProjectable p, ProjectableShowSql p) => p (Maybe Bool) -> p (Maybe Bool)

-- | Logical operator corresponding SQL <i>EXISTS</i> .
exists :: (OperatorProjectable p, ProjectableShowSql p) => ListProjection (Projection Exists) r -> p (Maybe Bool)

-- | Concatinate operator corresponding SQL <i>||</i> .
(.||.) :: (OperatorProjectable p, ProjectableShowSql p, IsString a) => p a -> p a -> p a

-- | String-compare operator corresponding SQL <i>LIKE</i> .
like :: (OperatorProjectable p, ProjectableShowSql p, IsString a, ShowConstantTermsSQL a) => p a -> a -> p (Maybe Bool)

-- | String-compare operator corresponding SQL <i>LIKE</i> .
like' :: (OperatorProjectable p, ProjectableShowSql p, IsString a) => p a -> p a -> p (Maybe Bool)

-- | Number operator corresponding SQL <i>+</i> .
(.+.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a

-- | Number operator corresponding SQL <i>-</i> .
(.-.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a

-- | Number operator corresponding SQL /// .
(./.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a

-- | Number operator corresponding SQL <i>*</i> .
(.*.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a

-- | Number negate uni-operator corresponding SQL <i>-</i>.
negate' :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a

-- | Number fromIntegral uni-operator.
fromIntegral' :: (SqlProjectable p, ProjectableShowSql p, Integral a, Num b) => p a -> p b

-- | Unsafely show number into string-like type in projections.
showNum :: (SqlProjectable p, ProjectableShowSql p, Num a, IsString b) => p a -> p b

-- | Aggregation function COUNT.
count :: (Integral b, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac b

-- | Aggregation function SUM.
sum' :: (Num a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe a)

-- | Aggregation function AVG.
avg :: (Num a, Fractional b, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe b)

-- | Aggregation function MAX.
max' :: (Ord a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe a)

-- | Aggregation function MIN.
min' :: (Ord a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe a)

-- | Aggregation function EVERY.
every :: (AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe Bool) -> p ac (Maybe Bool)

-- | Aggregation function ANY.
any' :: (AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe Bool) -> p ac (Maybe Bool)

-- | Aggregation function SOME.
some' :: (AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe Bool) -> p ac (Maybe Bool)

-- | Operator to make window function result projection using built
--   <a>Window</a> monad.
over :: SqlProjectable (Projection c) => Projection OverWindow a -> Window c () -> Projection c a

-- | <i>RANK()</i> term.
rank :: Integral a => Projection OverWindow a

-- | <i>DENSE_RANK()</i> term.
denseRank :: Integral a => Projection OverWindow a

-- | <i>ROW_NUMBER()</i> term.
rowNumber :: Integral a => Projection OverWindow a

-- | <i>PERCENT_RANK()</i> term.
percentRank :: Projection OverWindow Double

-- | <i>CUME_DIST()</i> term.
cumeDist :: Projection OverWindow Double

-- | Union of two relations.
union :: Relation () a -> Relation () a -> Relation () a

-- | Subtraction of two relations.
except :: Relation () a -> Relation () a -> Relation () a

-- | Intersection of two relations.
intersect :: Relation () a -> Relation () a -> Relation () a

-- | Get narrower projection along with projection path and project into
--   result projection type. <a>Maybe</a> phantom functor is <a>map</a>-ed.
(?!) :: Projectable Projection p => Projection c (Maybe a) -> Pi a b -> p c (Maybe b)

-- | Get narrower projection along with projection path and project into
--   result projection type. Source record <a>Maybe</a> phantom functor and
--   projection path leaf <a>Maybe</a> functor are <tt>join</tt>-ed.
(?!?) :: Projectable Projection p => Projection c (Maybe a) -> Pi a (Maybe b) -> p c (Maybe b)

-- | Compose projection path. <a>Maybe</a> phantom functor is
--   <a>map</a>-ed.
(<?.>) :: Pi a (Maybe b) -> Pi b c -> Pi a (Maybe c)

-- | Compose projection path. <a>Maybe</a> phantom functors are
--   <tt>join</tt>-ed like <tt>&gt;=&gt;</tt>.
(<?.?>) :: Pi a (Maybe b) -> Pi b (Maybe c) -> Pi a (Maybe c)

-- | Number operator corresponding SQL <i>+</i> .
(?+?) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p (Maybe a) -> p (Maybe a) -> p (Maybe a)

-- | Number negate uni-operator corresponding SQL <i>-</i>.
negateMaybe :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p (Maybe a) -> p (Maybe a)

-- | Aggregation function SUM.
sumMaybe :: (Num a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe a) -> p ac (Maybe a)

-- | Join sub-query with place-holder parameter <tt>p</tt>. query result is
--   not <a>Maybe</a>.
query' :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation p r -> m (PlaceHolders p, Projection Flat r)

-- | Direct left outer join with place-holder parameters.
left' :: Relation pa a -> Relation pb b -> [JoinRestriction a (Maybe b)] -> Relation (pa, pb) (a, Maybe b)

-- | Finalize <a>QuerySimple</a> monad and generate <a>Relation</a> with
--   place-holder parameter <tt>p</tt>.
relation' :: SimpleQuery p r -> Relation p r

-- | Finalize <tt>Target</tt> monad and generate <a>UpdateTarget</a> with
--   place-holder parameter <tt>p</tt>.
updateTarget' :: AssignStatement r (PlaceHolders p) -> UpdateTarget p r

-- | Finalize <a>Restrict</a> monad and generate <a>Restriction</a> with
--   place-holder parameter <tt>p</tt>
restriction' :: RestrictedStatement r (PlaceHolders p) -> Restriction p r

-- | Union of two relations with place-holder parameters.
union' :: Relation p a -> Relation q a -> Relation (p, q) a

-- | Specify tuple like record constructors which are allowed to define
--   <tt>ProjectableFunctor</tt>.
class ProductConstructor r

-- | Weaken functor on projections.
class ProjectableFunctor (p :: * -> *)
(|$|) :: (ProjectableFunctor p, ProductConstructor (a -> b)) => (a -> b) -> p a -> p b

-- | Weaken applicative functor on projections.
class ProjectableFunctor p => ProjectableApplicative (p :: * -> *)
(|*|) :: ProjectableApplicative p => p (a -> b) -> p a -> p b

-- | Binary operator the same as <a>projectZip</a>.
(><) :: ProjectableApplicative p => p a -> p b -> p (a, b)

-- | From <a>Relation</a> into typed <a>Query</a>.
relationalQuery :: Relation p r -> Query p r

-- | Make typed <a>Insert</a> from <a>Table</a> and columns selector
--   <a>Pi</a>.
typedInsert :: Table r -> Pi r r' -> Insert r'

-- | Make typed <a>InsertQuery</a> from columns selector <a>Table</a>,
--   <a>Pi</a> and <a>Relation</a>.
typedInsertQuery :: Table r -> Pi r r' -> Relation p r' -> InsertQuery p

-- | Make typed <a>Update</a> using <a>defaultConfig</a>, <a>Table</a> and
--   <a>UpdateTarget</a>.
typedUpdate :: Table r -> UpdateTarget p r -> Update p

-- | Make typed <a>Delete</a> from <a>Table</a> and <a>Restriction</a>.
typedDelete :: Table r -> Restriction p r -> Delete p

-- | Make typed <a>KeyUpdate</a> from <a>Table</a> and key columns selector
--   <a>Pi</a>.
typedKeyUpdate :: Table a -> Pi a p -> KeyUpdate p a

-- | Table type inferred <a>Insert</a>.
derivedInsert :: TableDerivable r => Pi r r' -> Insert r'

-- | Table type inferred <a>InsertQuery</a>.
derivedInsertQuery :: TableDerivable r => Pi r r' -> Relation p r' -> InsertQuery p

-- | Make typed <a>Update</a> from <a>defaultConfig</a>, derived table and
--   <a>UpdateTargetContext</a>
derivedUpdate :: TableDerivable r => UpdateTargetContext p r -> Update p

-- | Make typed <a>Delete</a> from <a>defaultConfig</a>, derived table and
--   <tt>RestrictContext</tt>
derivedDelete :: TableDerivable r => RestrictionContext p r -> Delete p

-- | Generalized prepare inferred from <a>UntypeableNoFetch</a> instance.
prepareNoFetch :: (UntypeableNoFetch s, IConnection conn) => conn -> s p -> IO (PreparedStatement p ())

-- | Typed operation to bind parameters. Infered <a>RecordToSql</a> is
--   used.
bind :: ToSql SqlValue p => PreparedStatement p a -> p -> BoundStatement a

-- | Typed execute operation.
execute :: BoundStatement a -> IO (ExecutedStatement a)

-- | Typed execute operation. Only get result.
executeNoFetch :: BoundStatement () -> IO Integer

-- | Same as <a>prepare</a>.
prepareQuery :: IConnection conn => conn -> Query p a -> IO (PreparedQuery p a)

-- | Fetch a record.
fetch :: FromSql SqlValue a => ExecutedStatement a -> IO (Maybe a)

-- | Prepare SQL, bind parameters, execute statement and lazily fetch all
--   records.
runQuery :: (IConnection conn, ToSql SqlValue p, FromSql SqlValue a) => conn -> Query p a -> p -> IO [a]

-- | Same as <a>prepare</a>.
prepareInsert :: IConnection conn => conn -> Insert a -> IO (PreparedInsert a)

-- | Prepare insert statement, bind parameters, execute statement and get
--   execution result.
runInsert :: (IConnection conn, ToSql SqlValue a) => conn -> Insert a -> a -> IO Integer

-- | Same as <a>prepare</a>.
prepareInsertQuery :: IConnection conn => conn -> InsertQuery p -> IO (PreparedInsertQuery p)

-- | Prepare insert statement, bind parameters, execute statement and get
--   execution result.
runInsertQuery :: (IConnection conn, ToSql SqlValue p) => conn -> InsertQuery p -> p -> IO Integer

-- | Same as <a>prepare</a>.
prepareUpdate :: IConnection conn => conn -> Update p -> IO (PreparedUpdate p)

-- | Prepare update statement, bind parameters, execute statement and get
--   execution result.
runUpdate :: (IConnection conn, ToSql SqlValue p) => conn -> Update p -> p -> IO Integer

-- | Same as <a>prepare</a>.
prepareDelete :: IConnection conn => conn -> Delete p -> IO (PreparedDelete p)

-- | Prepare delete statement, bind parameters, execute statement and get
--   execution result.
runDelete :: (IConnection conn, ToSql SqlValue p) => conn -> Delete p -> p -> IO Integer

-- | Same as <a>prepare</a>.
prepareKeyUpdate :: IConnection conn => conn -> KeyUpdate p a -> IO (PreparedKeyUpdate p a)

-- | Typed operation to bind parameters for <a>PreparedKeyUpdate</a> type.
bindKeyUpdate :: ToSql SqlValue a => PreparedKeyUpdate p a -> a -> BoundStatement ()

-- | Prepare insert statement, bind parameters, execute statement and get
--   execution result.
runKeyUpdate :: (IConnection conn, ToSql SqlValue a) => conn -> KeyUpdate p a -> a -> IO Integer
