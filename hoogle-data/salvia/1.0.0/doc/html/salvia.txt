-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Modular web application framework.
--   
--   Salvia is a feature rich modular web server and web application
--   framework that can be used to write dynamic websites in Haskell. From
--   the lower level protocol code up to the high level application code,
--   everything is written as a Salvia handler. This approach makes the
--   server extremely extensible. To see a demo of a Salvia website, please
--   see the <i>salvia-demo</i> package.
--   
--   All the low level protocol code can be found in the
--   <i>salvia-protocol</i> package, which exposes the datatypes, parsers
--   and pretty-printers for the URI, HTTP, Cookie and MIME protocols.
--   
--   This Salvia package itself can be separated into three different
--   parts: the interface, the handlers and the implementation. The
--   <i>interface</i> module defines a number of type classes that the user
--   can build the web application against. Reading the request object,
--   writing to the response, or gaining direct access to the socket, all
--   of these actions are reflected using one type class aspect in the
--   interface. The <i>handlers</i> are self contained modules that
--   implement a single aspect of the Salvia web server. The handlers
--   expose their interface requirements in their type context. Salvia can
--   have multiple <i>implementations</i> which can be switched by using
--   different instances for the interface type classes. This package has
--   only one implementation, a simple accepting socket loop server. The
--   <i>salvia-extras</i> package has two additional implementations.
--   Keeping a clear distinction between the abstract server aspects and
--   the actual implementation makes it very easy to migrate existing web
--   application to different back-ends.
@package salvia
@version 1.0.0

module Network.Salvia.Impl.Config

-- | The HTTP server configuration contains some network settings the
--   server needs know before being able to run.
data Config
Config :: String -> String -> [SockAddr] -> Int -> Config

-- | Server hostname.
hostname :: Config -> String

-- | Server admin email address.
adminMail :: Config -> String

-- | Address port combinations to listen on.
listenOn :: Config -> [SockAddr]

-- | TCP backlog.
backlog :: Config -> Int

-- | The default server configuration sets some safe default values. The
--   server will by default bind to 0.0.0.0 (<a>iNADDR_ANY</a>) at port
--   8080. The default value for the TCP backlog is 64.
defaultConfig :: Config

module Network.Salvia.Handler.Range

-- | HTTP Range datatype.
data Range
Range :: (Maybe Integer) -> (Maybe Integer) -> (Maybe Integer) -> Range

-- | Access the <i>Content-Range</i> header field.
contentRange :: Http Response :-> Maybe Range

-- | Access the <i>Range</i> header field.
range :: Http Request :-> Maybe Range

-- | Lens containing parser and pretty-printer for HTTP ranges.
rangeL :: String :<->: Range
instance Show Range


-- | This interface module contains all the basic operations to access the
--   server context. The interface is just of bunch of type classes that
--   allow access to the request and response objects. Most type classes
--   allow access to the context information through lifted state
--   computations. To dig deeper into the context object you would probably
--   want to use the derived <i>fclabels</i> accessors.
--   
--   Example 1: To get the entire request object:
--   
--   <pre>
--   do r &lt;- request get  -- Control.Monad.State.get
--   </pre>
--   
--   Example 2: To get the request URI as a string:
--   
--   <pre>
--   do r &lt;- request (getM uri) -- getM from Data.Record.Label
--   </pre>
--   
--   Example 3: To get the query parameters and the <i>User-Agent</i>
--   header:
--   
--   <pre>
--   do request $
--        do q &lt;- getM (queryParams . asUri)  -- composed labels using the (.) from Control.Category.
--           u &lt;- header "user-agent"
--           return (q, u)
--   </pre>
--   
--   Example 4: To set the <i>Content-Type</i> and response status and send
--   some string.
--   
--   <pre>
--   do response $
--        do status =: BadRequest    -- the (=:) operator from Data.Record.Label
--           header "content-type" =: "text/plain"
--      send "hello, world"
--   </pre>
module Network.Salvia.Interface
class ForkM n m
forkM :: (ForkM n m) => m a -> m (n a)

-- | The <a>HttpM</a> type class indicates is parametrized with the
--   directon (<a>Request</a> or <a>Response</a>) for which the
--   implementation should be able to supply and modify the values. The
--   <a>http</a> method allow for running arbitrary state computations over
--   the request or response objects.
class (Applicative m, Monad m) => HttpM dir m
http :: (HttpM dir m) => State (Http dir) a -> m a
class (Applicative m, Monad m) => RawHttpM dir m
rawHttp :: (RawHttpM dir m) => State (Http dir) a -> m a

-- | Stub request and response used to fill in type level gaps for message
--   directions.
forRequest :: Request
forResponse :: Response

-- | Type class alias indicating an HttpM instance for both requests and
--   responses.
class (HttpM Request m, HttpM Response m) => HttpM' m
class (RawHttpM Request m, RawHttpM Response m) => RawHttpM' m

-- | Direction specific aliases for the <a>http</a> method.
request :: (HttpM Request m) => State (Http Request) a -> m a
response :: (HttpM Response m) => State (Http Response) a -> m a
rawRequest :: (RawHttpM Request m) => State (Http Request) a -> m a
rawResponse :: (RawHttpM Response m) => State (Http Response) a -> m a

-- | The <a>SocketM</a> type class allows access to the raw socket.
class (Applicative m, Monad m) => SocketM m
socket :: (SocketM m) => m Socket

-- | The <a>HandleM</a> type class allows access to the file handle,
--   probabaly associated with the socket to the peer.
class (Applicative m, Monad m) => HandleM m
handle :: (HandleM m) => m Handle

-- | The <a>ClientAddressM</a> type class gives access to socket address of
--   the client part of the connection.
class (Applicative m, Monad m) => ClientAddressM m
clientAddress :: (ClientAddressM m) => m SockAddr

-- | The <a>ServerAddressM</a> type class gives access to socket address of
--   the client part of the connection.
class (Applicative m, Monad m) => ServerAddressM m
serverAddress :: (ServerAddressM m) => m SockAddr

-- | Type class alias indicating an instances for both
--   <a>ClientAddressM</a> and <a>ServerAddressM</a>.
class (ClientAddressM m, ServerAddressM m) => AddressM' m

-- | The send queue is an abstraction to make sure all data that belongs to
--   the message body is sent after the response headers have been sent.
--   Instead of sending data to client directly over the socket from the
--   context it is preferable to queue send actions in the context's send
--   queue. The entire send queue can be flushed to the client at once
--   after the HTTP headers have been sent at the end of a request handler.
type SendQueue = [SendAction]
data SendAction
SendAction :: ((Socket, Handle) -> IO ()) -> SendAction

-- | todo: comment: The <a>QueueM</a> type class allows for queing actions
--   for sending data values over the wire. Using a queue for collecting
--   send actions instead of directly sending values over the socket allows
--   for a more modular client or server layout.
class (Applicative m, Monad m) => HandleQueueM m
enqueueHandle :: (HandleQueueM m) => (Handle -> IO ()) -> m ()
class (Applicative m, Monad m) => SocketQueueM m
enqueueSock :: (SocketQueueM m) => (Socket -> IO ()) -> m ()
class (Applicative m, Monad m) => QueueM m
dequeue :: (QueueM m) => m (Maybe SendAction)
class (Applicative m, Monad m) => SendM m
send :: (SendM m) => String -> m ()
sendBs :: (SendM m) => ByteString -> m ()
spoolWith :: (SendM m) => (String -> String) -> Handle -> m ()
spoolWithBs :: (SendM m) => (ByteString -> ByteString) -> Handle -> m ()

-- | Enqueue the action of spooling the entire contents of a file handle
--   over the wire to the other endpoint.
spool :: (SendM m) => Handle -> m ()

-- | The <a>FlushM</a> type class can be used to flush the message headers
--   and the message body directly over the wire to the other endpoint.
class (Applicative m, Monad m) => FlushM dir m
flushHeaders :: (FlushM dir m) => dir -> m ()
flushQueue :: (FlushM dir m) => dir -> m ()
class (Applicative m, Monad m) => BodyM dir m
body :: (BodyM dir m) => dir -> m ByteString

-- | The <a>ServerM</a> type class can be used to acesss the static server
--   configuration like the address/port combination the server listens on
--   and the related hostname.
class (Applicative m, Monad m) => ServerM m
host :: (ServerM m) => m String
admin :: (ServerM m) => m String
listen :: (ServerM m) => m [SockAddr]

-- | The <a>PayloadM</a> type class provides access to the server payload.
--   The payload can be an arbitrary piece of data that gets shared between
--   all the handlers. Can be used to implement sessions and such.
--   Heterogeneous lists implemented as right associated nested tuples can
--   be used to store multiple pieces of information and still let
--   individual handlers pick out the right thing they need. Picking the
--   right pieces of information from the payload can be done with the
--   <a>select</a> function from the <a>Contains</a> type class.
class (Applicative m, Monad m, Contains p (TVar q)) => PayloadM p q m | m -> p
payload :: (PayloadM p q m) => State q a -> m a
(&) :: a -> b -> (a, b)
class Contains a b
select :: (Contains a b) => a :-> b
instance [incoherent] (b ~ b', Contains a b') => Contains (c, a) b'
instance [incoherent] Contains (a, c) a
instance [incoherent] (a ~ a') => Contains a a'
instance [incoherent] Show SendAction
instance [incoherent] (ClientAddressM m, ServerAddressM m) => AddressM' m
instance [incoherent] (RawHttpM Request m, RawHttpM Response m) => RawHttpM' m
instance [incoherent] (HttpM Request m, HttpM Response m) => HttpM' m

module Network.Salvia.Handler.Banner

-- | The <a>hBanner</a> handler adds the current date-/timestamp and a
--   custom server name to the response headers.
hBanner :: (MonadIO m, HttpM Response m) => String -> m ()

module Network.Salvia.Handler.Body

-- | Like <a>hRawBody</a> but specifically for <a>Http</a> <a>Request</a>s.
hRawRequestBody :: (BodyM Request m) => m ByteString

-- | Like <a>hRawBody</a> but specifically for <a>Http</a> <a>Request</a>s.
hRawResponseBody :: (BodyM Response m) => m ByteString

-- | First (possibly naive) handler to retreive the client request or
--   server response body as a raw lazy <a>ByteString</a>. This probably
--   does not handle all the quirks that the HTTP protocol specifies, but
--   it does the job for now. When a <a>contentLength</a> header field is
--   available only this fixed number of bytes will read from the socket.
--   When neither the <a>keepAlive</a> and <a>contentLength</a> header
--   fields are available the entire payload of the request will be read
--   from the socket. The function is parametrized with a the direction of
--   the HTTP message, client request or server response.
hRawBody :: (MonadIO m, HandleM m, HttpM d m) => d -> m ByteString

-- | Like <a>hBodyText</a> but specifically for <a>Http</a>
--   <a>Request</a>s.
hRequestBodyText :: (BodyM Request m, HttpM Request m) => String -> m Text

-- | Like <a>hBodyText</a> but specifically for <a>Http</a>
--   <a>Response</a>s.
hResponseBodyText :: (BodyM Response m, HttpM Response m) => String -> m Text

-- | Like the <a>hRawBody</a> but is will handle proper decoding based on
--   the charset part of the <a>contentType</a> header line. When a valid
--   encoding is found in the <a>Http</a> message it will be decoded with
--   using the encodings package. The default encoding supplied as the
--   function's argument can be used to specify what encoding to use in the
--   absence of a proper encoding in the HTTP message itself.
hBodyText :: (BodyM dir m, HttpM dir m) => dir -> String -> m Text

-- | Like <a>hBodyStringUTF8</a> but specifically for <a>Http</a>
--   <a>Request</a>s.
hRequestBodyStringUTF8 :: (BodyM Request m) => m String

-- | Like <a>hBodyStringUTF8</a> but specifically for <a>Http</a>
--   <a>Response</a>s.
hResponseBodyStringUTF8 :: (BodyM Response m) => m String

-- | Like the <a>hRawBody</a> but decodes it as UTF-8 to a <a>String</a>.
hBodyStringUTF8 :: (BodyM dir m) => dir -> m String

-- | Like <a>hParameters</a> but specifically for <tt>HTTP</tt>
--   <a>Request</a>s.
hRequestParameters :: (BodyM Request m, HttpM Request m) => String -> m Parameters

-- | Like <a>hParameters</a> but specifically for <tt>HTTP</tt>
--   <a>Response</a>s.
hResponseParameters :: (BodyM Response m, HttpM Response m) => String -> m Parameters

-- | Try to parse the message body, as a result of <a>hBodyText</a>, as URI
--   encoded <a>POST</a> parameters. Returns as a URI <tt>Parameter</tt>
--   type or nothing when parsing fails.
hParameters :: (BodyM d m, HttpM d m) => d -> String -> m Parameters

module Network.Salvia.Handler.Cookie

-- | Set the `Set-Cookie` HTTP response header with the specified
--   <a>Cookies</a>.
hSetCookie :: (HttpM Response m) => Cookies -> m ()

-- | Try to get the cookies from the HTTP <a>cookie</a> request header.
hCookie :: (HttpM Request m) => m (Maybe Cookies)

-- | Delete one cookie by removing it from the `Set-Cookie' header.
hDelCookie :: (HttpM Response m) => String -> m ()

-- | Convenient method for creating cookies that expire in the near future
--   and are bound to the domain and port this server runs on. The path
--   will be locked to root. If the second argument is set, the cookie will
--   be valid for all subdomains.
hNewCookie :: (ServerM m, ServerAddressM m, FormatTime t) => t -> Bool -> m Cookie

module Network.Salvia.Handler.Dispatching

-- | The dispatcher type takes one value to dispatch on and two handlers.
--   The first handler will be used when the predicate on the dispatch
--   value returned <a>True</a>, the second (default) handler will be used
--   when the predicate returs <a>False</a>.
type Dispatcher a m b = a -> m b -> m b -> m b

-- | A list dispatcher takes a mapping from dispatch values to handlers and
--   one default fallback handler.
type ListDispatcher a m b = [(a, m b)] -> m b -> m b

-- | Dispatch on an arbitrary part of the context using an arbitrary
--   predicate. When the predicate returns true on the value selected with
--   the <a>Label</a> the first handler will be invoked, otherwise the
--   second handler will be used.
hDispatch :: (HttpM d m) => d -> (Http d :-> b) -> (c -> b -> Bool) -> Dispatcher c m a

-- | Turns a dispatcher function into a list dispatcher. This enables
--   handler routing based on arbitrary values from the context. When non
--   of the predicates in the <a>ListDispatcher</a> type hold the default
--   handler will be invoked.
hListDispatch :: Dispatcher a m b -> ListDispatcher a m b

-- | Like the <a>hDispatch</a> but always dispatches on a (part of) the
--   `HTTP Request' part of the context.
hRequestDispatch :: (HttpM Request m) => (Http Request :-> b) -> (t -> b -> Bool) -> Dispatcher t m c

-- | Like the <a>hDispatch</a> but always dispatches on a (part of) the
--   `HTTP Response' part of the context.
hResponseDispatch :: (HttpM Response m) => (Http Response :-> b) -> (t -> b -> Bool) -> Dispatcher t m c

module Network.Salvia.Handler.Error

-- | The <a>hError</a> handler enables the creation of a default style of
--   error responses for the specified HTTP <a>Status</a> code.
hError :: (HttpM Response m, SendM m) => Status -> m ()

-- | Like <a>hError</a> but with a custom error message.
hCustomError :: (HttpM Response m, SendM m) => Status -> String -> m ()

-- | Map an <a>IOError</a> to a default style error response.
--   
--   The mapping from an IO error to an error response is rather
--   straightforward:
--   
--   <pre>
--   | isDoesNotExistError e = hError NotFound
--   | isAlreadyInUseError e = hError ServiceUnavailable
--   | isPermissionError   e = hError Forbidden
--   | True                  = hError InternalServerError
--   </pre>
hIOError :: (HttpM Response m, SendM m) => IOError -> m ()

-- | Execute an handler with the result of an IO action. When the IO
--   actions fails a default error handler will be executed.
hSafeIO :: (MonadIO m, HttpM Response m, SendM m) => IO a -> (a -> m ()) -> m ()

-- | Utility function to easily catch IO errors.
catchIO :: (MonadIO m) => IO a -> a -> m a

module Network.Salvia.Handler.Close

-- | Run a handler once and close the connection afterwards.
hCloseConn :: (HandleM m, MonadIO m) => m a -> m ()

-- | Run a handler and keep the connection open for potential consecutive
--   requests. The connection will only be closed after a request finished
--   and one or more of the following criteria are met:
--   
--   <ul>
--   <li>There is no <a>contentLength</a> set in the response headers. When
--   this is the case the connection cannot be kept alive.</li>
--   <li>The client has set the <a>connection</a> header field to
--   <tt>close</tt>.</li>
--   <li>The connection has already been closed, possible due to IO
--   errors.</li>
--   <li>The HTTP version is HTTP/1.0.</li>
--   </ul>
hKeepAlive :: (QueueM m, HandleM m, HttpM' m, MonadIO m) => m a -> m ()

-- | Empty the send queue.
emptyQueue :: (QueueM m) => m ()

module Network.Salvia.Handler.Extension

-- | Request dispatcher based on the request path file extenstion.
hExtension :: (HttpM Request m) => Dispatcher (Maybe String) m a

-- | List dispatcher version of <a>hExtension</a>.
hExtensionRouter :: (HttpM Request m) => ListDispatcher (Maybe String) m a

module Network.Salvia.Handler.File

-- | Like <a>hFileResource</a> but uses the path of the current request
--   URI.
hFile :: (MonadIO m, HttpM' m, SendM m) => m ()

-- | Serve a file from the filesystem indicated by the specified filepath.
--   When there is some kind of <a>IOError</a> the <a>hSafeIO</a> function
--   will be used to produce a corresponding error response. The
--   <a>contentType</a> will be the mime-type based on the filename
--   extension using the <a>mimetype</a> function. The <a>contentLength</a>
--   will be set the file's size.
hFileResource :: (MonadIO m, HttpM' m, SendM m) => FilePath -> m ()
fileMime :: FilePath -> Mime

-- | Like <a>hFileResourceFilter</a> but uses the path of the current
--   request URI.
hFileFilter :: (MonadIO m, HttpM' m, SendM m) => (String -> String) -> m ()

-- | Like the <a>hFileResource</a> handler, but with a custom filter over
--   the content. This function will assume the content is an UTF-8 encoded
--   text file. Because of the possibly unpredictable behavior of the
--   filter, no <a>contentLength</a> header will be set using this handler.
hFileResourceFilter :: (MonadIO m, HttpM Response m, SendM m) => (String -> String) -> FilePath -> m ()

-- | Turn a handler that is parametrized by a file resources into a regular
--   handler that utilizes the path part of the request URI as the resource
--   identifier.
hResource :: (HttpM Request m) => (FilePath -> m a) -> m a

-- | Turn a handler that is parametrized by a URI into a regular handler
--   that utilizes the request URI as the resource identifier.
hUri :: (HttpM Request m) => (Uri -> m a) -> m a

module Network.Salvia.Handler.Log

-- | A simple logger that prints a summery of the request information to
--   the specified file handle.
hLog :: (AddressM' m, MonadIO m, HttpM' m) => Handle -> m ()

-- | Dump the request headers to the standard output, useful for debugging.
hDumpRequest :: (HttpM Request m, MonadIO m) => m ()

-- | Dump the response headers to the standard output, useful for
--   debugging.
hDumpResponse :: (HttpM Response m, MonadIO m) => m ()

module Network.Salvia.Handler.Method

-- | Request dispatcher based on the HTTP request <a>Method</a>.
hMethod :: (HttpM Request m) => Dispatcher Method m a

-- | Request list dispatcher based on the <a>hMethod</a> dispatcher.
hMethodRouter :: (HttpM Request m) => ListDispatcher Method m ()

module Network.Salvia.Handler.Parser

-- | Like the <a>hParser</a> but always parses <tt>HTTP</tt>
--   <tt>Requests</tt>s.
hRequestParser :: (HandleM m, RawHttpM Request m, HttpM Request m, MonadIO m) => Int -> (String -> m a) -> m a -> m (Maybe a)

-- | Like the <a>hParser</a> but always parses <tt>HTTP</tt>
--   <a>Response</a>s.
hResponseParser :: (HandleM m, RawHttpM Response m, HttpM Response m, MonadIO m) => Int -> (String -> m a) -> m a -> m (Maybe a)

-- | The <a>hParser</a> handler is used to parse the raw <tt>HTTP</tt>
--   message into the <tt>Message</tt> data type. This handler is generally
--   used as (one of) the first handlers in a client or server environment.
--   The first handler argument is executed when the message is invalid,
--   possibly due to parser errors, and is parametrized with the error
--   string. The second handler argument is executed when the message is
--   valid. When the message could not be parsed within the time specified
--   with the first argument the function silently returns.
hParser :: (HandleM m, MonadIO m) => (Http d -> m b) -> (String -> Either String (Http d)) -> Int -> (String -> m a) -> m a -> m (Maybe a)
readNonEmptyLines :: Handle -> IO String

module Network.Salvia.Handler.CGI

-- | Handler to run CGI scripts.
hCGI :: (MonadIO m, HttpM' m, BodyM Request m, SendM m, HandleQueueM m, ServerM m, AddressM' m) => FilePath -> m ()

module Network.Salvia.Handler.Printer

-- | The <a>hRequestPrinter</a> handler prints the entire HTTP request
--   including the headers and the body to the socket towards the server.
--   This handler is generally used as (one of) the last handler in a
--   server environment.
hRequestPrinter :: (FlushM Request m) => m ()

-- | The <a>hResponsePrinter</a> handler prints the entire HTTP response
--   including the headers and the body to the socket towards the client.
--   This handler is generally used as (one of) the last handler in a
--   client environment.
hResponsePrinter :: (FlushM Response m) => m ()

-- | Send all the message headers directly over the socket.
--   
--   todo: printer for rawResponse over response!!
hFlushHeaders :: (Show (Http d), HandleM m, QueueM m, MonadIO m, HttpM d m) => d -> m ()

-- | Like <a>hFlushHeaders</a> but does not print status line, can be
--   useful for CGI mode.
hFlushHeadersOnly :: (Show (Http d), HandleM m, QueueM m, MonadIO m, HttpM d m) => d -> m ()

-- | Like <a>hFlushHeaders</a> but specifically for the request headers.
hFlushRequestHeaders :: (FlushM Request m) => m ()

-- | Like <a>hFlushHeaders</a> but specifically for the response headers.
hFlushResponseHeaders :: (FlushM Response m) => m ()

-- | One by one apply all enqueued send actions to the socket.
hFlushQueue :: (QueueM m, HandleM m, SocketM m, MonadIO m) => m ()

module Network.Salvia.Handler.Redirect

-- | Redirect a client to another location by creating a
--   <a>MovedPermanently</a> response message with the specified
--   <tt>URI</tt> in the <a>location</a> header.
hRedirect :: (HttpM Response m) => String -> m ()


-- | Rendering of HTML directory listings.
module Network.Salvia.Handler.Directory

-- | Like <a>hDirectoryResource</a> but uses the path from the current
--   request URI.
hDirectory :: (MonadIO m, HttpM' m, SendM m) => m ()

-- | Serve a simple HTML directory listing for the specified directory on
--   the filesystem.
hDirectoryResource :: (MonadIO m, HttpM' m, SendM m) => FilePath -> m ()


-- | Serving parts of the local file system.
module Network.Salvia.Handler.FileSystem

-- | Serve single directory by combining the <a>hDirectoryResource</a> and
--   <a>hFileResource</a> handlers in the <a>hFileTypeDispatcher</a>.
hFileSystem :: (MonadIO m, HttpM' m, SendM m) => FilePath -> m ()

-- | Serve single directory like <a>hFileSystem</a> but do not show
--   directory indices. Instead of an directory index an <a>Forbidden</a>
--   response will be created.
hFileSystemNoIndexes :: (MonadIO m, HttpM' m, SendM m) => FilePath -> m ()

-- | Dispatch based on file type; regular files or directories. The first
--   handler specified will be invoked in case the resource to be served is
--   an directory, the second handler otherwise. The path from the request
--   URI will be appended to the directory resource specified as a
--   parameter, this new path will be used to lookup the real resource on
--   the file system. Every request will be jailed in the specified
--   directory resource to prevent users from requesting arbitrary parts of
--   the file system.
hFileTypeDispatcher :: (MonadIO m, HttpM' m, SendM m) => (FilePath -> m ()) -> (FilePath -> m ()) -> FilePath -> m ()

module Network.Salvia.Handler.Put

-- | Create a browseable filesystem handler (like <a>hFileSystem</a>) but
--   make all files writeable by a <a>PUT</a> request. Files that do not
--   exists will be created as long as the directory in which they will be
--   created exists.
hPutFileSystem :: (MonadIO m, HttpM' m, SendM m, BodyM Request m) => FilePath -> m ()

-- | Invokes the <a>hStore</a> handler when the request is a <a>PUT</a>
--   request and invokes the fallback handler otherwiser.
hPutResource :: (MonadIO m, BodyM Request m, HttpM' m, SendM m) => (FilePath -> m ()) -> FilePath -> m ()

-- | This handler takes a FilePath and will try to store the entire request
--   body in that file. When the request body could for some reason not be
--   fetch a <a>BadRequest</a> error response will be created. When an IO
--   error occurs the <a>hIOError</a> function is used to setup an
--   apropriate response.
hStore :: (MonadIO m, BodyM Request m, HttpM Response m, SendM m) => FilePath -> m ()

module Network.Salvia.Handler.Rewrite

-- | Run a handler in a local environment in which the <tt>HTTP</tt>
--   <a>Request</a> has been modified.
hLocalRequest :: (HttpM Request m) => (Http Request :-> b) -> (b -> b) -> m a -> m a

-- | Run an handler in a modified context in which the request <a>Uri</a>
--   has been changed by the specified modifier function. After the handler
--   completes the <a>Uri</a> remains untouched.
hRewrite :: (HttpM Request m) => (Uri -> Uri) -> m a -> m a

-- | Run handler in a context with a modified path.
hRewritePath :: (HttpM Request m) => (FilePath -> FilePath) -> m a -> m a

-- | Run handler in a context with a modified host.
hRewriteHost :: (HttpM Request m) => (String -> String) -> m a -> m a

-- | Run handler in a context with a modified file extension.
hRewriteExt :: (HttpM Request m) => (Maybe String -> Maybe String) -> m a -> m a

-- | Run handler in a context with a modified path. The specified prefix
--   will be prepended to the path.
hWithDir :: (HttpM Request m) => String -> m a -> m a

-- | Run handler in a context with a modified path. The specified prefix
--   will be stripped from the path.
hWithoutDir :: (HttpM Request m) => String -> m a -> m a

module Network.Salvia.Handler.Head

-- | The <a>hHead</a> handler makes sure no <tt>HTTP</tt> <a>Response</a>
--   body is sent to the client when the request is an HTTP <a>HEAD</a>
--   request. In the case of a <a>HEAD</a> request the specified sub
--   handler will be executed under the assumption that the request was a
--   <a>GET</a> request, otherwise this handler will act as the identify
--   function.
hHead :: (MonadIO m, QueueM m, HttpM Request m) => m a -> m a

module Network.Salvia.Handler.Environment

-- | This is the default handler environment. It takes care of request
--   parsing (<a>hRequestParser</a>), response printing
--   (<a>hResponsePrinter</a>), connection keep-alives (<a>hKeepAlive</a>),
--   handling <a>HEAD</a> requests (<a>hHead</a>) and printing the
--   `salvia-httpd` server banner (<a>hBanner</a>).
hDefaultEnv :: (MonadIO m, HandleM m, RawHttpM' m, HttpM' m, QueueM m, SendM m, FlushM Response m) => m () -> m ()

-- | Like <a>hDefaultEnv</a> but only serves one request per connection.
hEnvNoKeepAlive :: (MonadIO m, HandleM m, RawHttpM' m, HttpM' m, QueueM m, SendM m, FlushM Response m) => m () -> m ()

module Network.Salvia.Handler.Path

-- | Request dispatcher based on the request path.
hPath :: (HttpM Request m) => Dispatcher String m a

-- | List dispatcher version of <a>hPath</a>.
hPathRouter :: (HttpM Request m) => ListDispatcher String m a

-- | Request dispatcher based on a prefix of the request path.
hPrefix :: (HttpM Request m) => Dispatcher String m a

-- | List dispatcher version of <a>hPrefix</a>.
hPrefixRouter :: (HttpM Request m) => ListDispatcher String m a

-- | Helper function to fetch the URI parameters from the request.
hQueryParameters :: (HttpM Request m) => m Parameters

module Network.Salvia.Handler.VirtualHosting

-- | Dispatcher based on the host part of the <a>hostname</a> request
--   header. Everything not part of the real hostname (like the port
--   number) will be ignored. When the expected hostname starts with a dot
--   (like <a>.mydomain.com</a>) this indicates that all sub-domains of
--   this domain will match as well.
hVirtualHosting :: (HttpM Request m) => ListDispatcher String m b

-- | Dispatcher based on the port number of the <a>hostname</a> request
--   header. When no port number is available in the hostname header port
--   80 will be assumed.
hPortRouter :: (HttpM Request m) => ListDispatcher Int m b

module Network.Salvia.Handlers

-- | This is the default handler environment. It takes care of request
--   parsing (<a>hRequestParser</a>), response printing
--   (<a>hResponsePrinter</a>), connection keep-alives (<a>hKeepAlive</a>),
--   handling <a>HEAD</a> requests (<a>hHead</a>) and printing the
--   `salvia-httpd` server banner (<a>hBanner</a>).
hDefaultEnv :: (MonadIO m, HandleM m, RawHttpM' m, HttpM' m, QueueM m, SendM m, FlushM Response m) => m () -> m ()

-- | Like <a>hDefaultEnv</a> but only serves one request per connection.
hEnvNoKeepAlive :: (MonadIO m, HandleM m, RawHttpM' m, HttpM' m, QueueM m, SendM m, FlushM Response m) => m () -> m ()

-- | Like the <a>hParser</a> but always parses <tt>HTTP</tt>
--   <tt>Requests</tt>s.
hRequestParser :: (HandleM m, RawHttpM Request m, HttpM Request m, MonadIO m) => Int -> (String -> m a) -> m a -> m (Maybe a)

-- | Like the <a>hParser</a> but always parses <tt>HTTP</tt>
--   <a>Response</a>s.
hResponseParser :: (HandleM m, RawHttpM Response m, HttpM Response m, MonadIO m) => Int -> (String -> m a) -> m a -> m (Maybe a)

-- | The <a>hParser</a> handler is used to parse the raw <tt>HTTP</tt>
--   message into the <tt>Message</tt> data type. This handler is generally
--   used as (one of) the first handlers in a client or server environment.
--   The first handler argument is executed when the message is invalid,
--   possibly due to parser errors, and is parametrized with the error
--   string. The second handler argument is executed when the message is
--   valid. When the message could not be parsed within the time specified
--   with the first argument the function silently returns.
hParser :: (HandleM m, MonadIO m) => (Http d -> m b) -> (String -> Either String (Http d)) -> Int -> (String -> m a) -> m a -> m (Maybe a)
readNonEmptyLines :: Handle -> IO String

-- | The <a>hResponsePrinter</a> handler prints the entire HTTP response
--   including the headers and the body to the socket towards the client.
--   This handler is generally used as (one of) the last handler in a
--   client environment.
hResponsePrinter :: (FlushM Response m) => m ()

-- | The <a>hRequestPrinter</a> handler prints the entire HTTP request
--   including the headers and the body to the socket towards the server.
--   This handler is generally used as (one of) the last handler in a
--   server environment.
hRequestPrinter :: (FlushM Request m) => m ()

-- | Send all the message headers directly over the socket.
--   
--   todo: printer for rawResponse over response!!
hFlushHeaders :: (Show (Http d), HandleM m, QueueM m, MonadIO m, HttpM d m) => d -> m ()

-- | Like <a>hFlushHeaders</a> but does not print status line, can be
--   useful for CGI mode.
hFlushHeadersOnly :: (Show (Http d), HandleM m, QueueM m, MonadIO m, HttpM d m) => d -> m ()

-- | Like <a>hFlushHeaders</a> but specifically for the request headers.
hFlushRequestHeaders :: (FlushM Request m) => m ()

-- | Like <a>hFlushHeaders</a> but specifically for the response headers.
hFlushResponseHeaders :: (FlushM Response m) => m ()

-- | One by one apply all enqueued send actions to the socket.
hFlushQueue :: (QueueM m, HandleM m, SocketM m, MonadIO m) => m ()

-- | Like <a>hRawBody</a> but specifically for <a>Http</a> <a>Request</a>s.
hRawRequestBody :: (BodyM Request m) => m ByteString

-- | Like <a>hRawBody</a> but specifically for <a>Http</a> <a>Request</a>s.
hRawResponseBody :: (BodyM Response m) => m ByteString

-- | First (possibly naive) handler to retreive the client request or
--   server response body as a raw lazy <a>ByteString</a>. This probably
--   does not handle all the quirks that the HTTP protocol specifies, but
--   it does the job for now. When a <a>contentLength</a> header field is
--   available only this fixed number of bytes will read from the socket.
--   When neither the <a>keepAlive</a> and <a>contentLength</a> header
--   fields are available the entire payload of the request will be read
--   from the socket. The function is parametrized with a the direction of
--   the HTTP message, client request or server response.
hRawBody :: (MonadIO m, HandleM m, HttpM d m) => d -> m ByteString

-- | Like <a>hBodyText</a> but specifically for <a>Http</a>
--   <a>Request</a>s.
hRequestBodyText :: (BodyM Request m, HttpM Request m) => String -> m Text

-- | Like <a>hBodyText</a> but specifically for <a>Http</a>
--   <a>Response</a>s.
hResponseBodyText :: (BodyM Response m, HttpM Response m) => String -> m Text

-- | Like the <a>hRawBody</a> but is will handle proper decoding based on
--   the charset part of the <a>contentType</a> header line. When a valid
--   encoding is found in the <a>Http</a> message it will be decoded with
--   using the encodings package. The default encoding supplied as the
--   function's argument can be used to specify what encoding to use in the
--   absence of a proper encoding in the HTTP message itself.
hBodyText :: (BodyM dir m, HttpM dir m) => dir -> String -> m Text

-- | Like <a>hBodyStringUTF8</a> but specifically for <a>Http</a>
--   <a>Request</a>s.
hRequestBodyStringUTF8 :: (BodyM Request m) => m String

-- | Like <a>hBodyStringUTF8</a> but specifically for <a>Http</a>
--   <a>Response</a>s.
hResponseBodyStringUTF8 :: (BodyM Response m) => m String

-- | Like the <a>hRawBody</a> but decodes it as UTF-8 to a <a>String</a>.
hBodyStringUTF8 :: (BodyM dir m) => dir -> m String

-- | Like <a>hParameters</a> but specifically for <tt>HTTP</tt>
--   <a>Request</a>s.
hRequestParameters :: (BodyM Request m, HttpM Request m) => String -> m Parameters

-- | Like <a>hParameters</a> but specifically for <tt>HTTP</tt>
--   <a>Response</a>s.
hResponseParameters :: (BodyM Response m, HttpM Response m) => String -> m Parameters

-- | Try to parse the message body, as a result of <a>hBodyText</a>, as URI
--   encoded <a>POST</a> parameters. Returns as a URI <tt>Parameter</tt>
--   type or nothing when parsing fails.
hParameters :: (BodyM d m, HttpM d m) => d -> String -> m Parameters

-- | The <a>hBanner</a> handler adds the current date-/timestamp and a
--   custom server name to the response headers.
hBanner :: (MonadIO m, HttpM Response m) => String -> m ()

-- | Run a handler once and close the connection afterwards.
hCloseConn :: (HandleM m, MonadIO m) => m a -> m ()

-- | Run a handler and keep the connection open for potential consecutive
--   requests. The connection will only be closed after a request finished
--   and one or more of the following criteria are met:
--   
--   <ul>
--   <li>There is no <a>contentLength</a> set in the response headers. When
--   this is the case the connection cannot be kept alive.</li>
--   <li>The client has set the <a>connection</a> header field to
--   <tt>close</tt>.</li>
--   <li>The connection has already been closed, possible due to IO
--   errors.</li>
--   <li>The HTTP version is HTTP/1.0.</li>
--   </ul>
hKeepAlive :: (QueueM m, HandleM m, HttpM' m, MonadIO m) => m a -> m ()

-- | The <a>hHead</a> handler makes sure no <tt>HTTP</tt> <a>Response</a>
--   body is sent to the client when the request is an HTTP <a>HEAD</a>
--   request. In the case of a <a>HEAD</a> request the specified sub
--   handler will be executed under the assumption that the request was a
--   <a>GET</a> request, otherwise this handler will act as the identify
--   function.
hHead :: (MonadIO m, QueueM m, HttpM Request m) => m a -> m a

-- | The <a>hError</a> handler enables the creation of a default style of
--   error responses for the specified HTTP <a>Status</a> code.
hError :: (HttpM Response m, SendM m) => Status -> m ()

-- | Like <a>hError</a> but with a custom error message.
hCustomError :: (HttpM Response m, SendM m) => Status -> String -> m ()

-- | Map an <a>IOError</a> to a default style error response.
--   
--   The mapping from an IO error to an error response is rather
--   straightforward:
--   
--   <pre>
--   | isDoesNotExistError e = hError NotFound
--   | isAlreadyInUseError e = hError ServiceUnavailable
--   | isPermissionError   e = hError Forbidden
--   | True                  = hError InternalServerError
--   </pre>
hIOError :: (HttpM Response m, SendM m) => IOError -> m ()

-- | Execute an handler with the result of an IO action. When the IO
--   actions fails a default error handler will be executed.
hSafeIO :: (MonadIO m, HttpM Response m, SendM m) => IO a -> (a -> m ()) -> m ()

-- | A simple logger that prints a summery of the request information to
--   the specified file handle.
hLog :: (AddressM' m, MonadIO m, HttpM' m) => Handle -> m ()

-- | Dump the request headers to the standard output, useful for debugging.
hDumpRequest :: (HttpM Request m, MonadIO m) => m ()

-- | Dump the response headers to the standard output, useful for
--   debugging.
hDumpResponse :: (HttpM Response m, MonadIO m) => m ()

-- | Redirect a client to another location by creating a
--   <a>MovedPermanently</a> response message with the specified
--   <tt>URI</tt> in the <a>location</a> header.
hRedirect :: (HttpM Response m) => String -> m ()

-- | Run an handler in a modified context in which the request <a>Uri</a>
--   has been changed by the specified modifier function. After the handler
--   completes the <a>Uri</a> remains untouched.
hRewrite :: (HttpM Request m) => (Uri -> Uri) -> m a -> m a

-- | Run handler in a context with a modified host.
hRewriteHost :: (HttpM Request m) => (String -> String) -> m a -> m a

-- | Run handler in a context with a modified path.
hRewritePath :: (HttpM Request m) => (FilePath -> FilePath) -> m a -> m a

-- | Run handler in a context with a modified file extension.
hRewriteExt :: (HttpM Request m) => (Maybe String -> Maybe String) -> m a -> m a

-- | Run handler in a context with a modified path. The specified prefix
--   will be prepended to the path.
hWithDir :: (HttpM Request m) => String -> m a -> m a

-- | Run handler in a context with a modified path. The specified prefix
--   will be stripped from the path.
hWithoutDir :: (HttpM Request m) => String -> m a -> m a

-- | Serve a file from the filesystem indicated by the specified filepath.
--   When there is some kind of <a>IOError</a> the <a>hSafeIO</a> function
--   will be used to produce a corresponding error response. The
--   <a>contentType</a> will be the mime-type based on the filename
--   extension using the <a>mimetype</a> function. The <a>contentLength</a>
--   will be set the file's size.
hFileResource :: (MonadIO m, HttpM' m, SendM m) => FilePath -> m ()

-- | Like the <a>hFileResource</a> handler, but with a custom filter over
--   the content. This function will assume the content is an UTF-8 encoded
--   text file. Because of the possibly unpredictable behavior of the
--   filter, no <a>contentLength</a> header will be set using this handler.
hFileResourceFilter :: (MonadIO m, HttpM Response m, SendM m) => (String -> String) -> FilePath -> m ()

-- | Turn a handler that is parametrized by a file resources into a regular
--   handler that utilizes the path part of the request URI as the resource
--   identifier.
hResource :: (HttpM Request m) => (FilePath -> m a) -> m a
fileMime :: FilePath -> Mime

-- | Turn a handler that is parametrized by a URI into a regular handler
--   that utilizes the request URI as the resource identifier.
hUri :: (HttpM Request m) => (Uri -> m a) -> m a

-- | Like <a>hFileResource</a> but uses the path of the current request
--   URI.
hFile :: (MonadIO m, HttpM' m, SendM m) => m ()

-- | Like <a>hFileResourceFilter</a> but uses the path of the current
--   request URI.
hFileFilter :: (MonadIO m, HttpM' m, SendM m) => (String -> String) -> m ()

-- | Like <a>hDirectoryResource</a> but uses the path from the current
--   request URI.
hDirectory :: (MonadIO m, HttpM' m, SendM m) => m ()

-- | Serve a simple HTML directory listing for the specified directory on
--   the filesystem.
hDirectoryResource :: (MonadIO m, HttpM' m, SendM m) => FilePath -> m ()

-- | Dispatch based on file type; regular files or directories. The first
--   handler specified will be invoked in case the resource to be served is
--   an directory, the second handler otherwise. The path from the request
--   URI will be appended to the directory resource specified as a
--   parameter, this new path will be used to lookup the real resource on
--   the file system. Every request will be jailed in the specified
--   directory resource to prevent users from requesting arbitrary parts of
--   the file system.
hFileTypeDispatcher :: (MonadIO m, HttpM' m, SendM m) => (FilePath -> m ()) -> (FilePath -> m ()) -> FilePath -> m ()

-- | Serve single directory by combining the <a>hDirectoryResource</a> and
--   <a>hFileResource</a> handlers in the <a>hFileTypeDispatcher</a>.
hFileSystem :: (MonadIO m, HttpM' m, SendM m) => FilePath -> m ()

-- | Serve single directory like <a>hFileSystem</a> but do not show
--   directory indices. Instead of an directory index an <a>Forbidden</a>
--   response will be created.
hFileSystemNoIndexes :: (MonadIO m, HttpM' m, SendM m) => FilePath -> m ()

-- | Create a browseable filesystem handler (like <a>hFileSystem</a>) but
--   make all files writeable by a <a>PUT</a> request. Files that do not
--   exists will be created as long as the directory in which they will be
--   created exists.
hPutFileSystem :: (MonadIO m, HttpM' m, SendM m, BodyM Request m) => FilePath -> m ()

-- | Invokes the <a>hStore</a> handler when the request is a <a>PUT</a>
--   request and invokes the fallback handler otherwiser.
hPutResource :: (MonadIO m, BodyM Request m, HttpM' m, SendM m) => (FilePath -> m ()) -> FilePath -> m ()

-- | This handler takes a FilePath and will try to store the entire request
--   body in that file. When the request body could for some reason not be
--   fetch a <a>BadRequest</a> error response will be created. When an IO
--   error occurs the <a>hIOError</a> function is used to setup an
--   apropriate response.
hStore :: (MonadIO m, BodyM Request m, HttpM Response m, SendM m) => FilePath -> m ()

-- | HTTP Range datatype.
data Range
Range :: (Maybe Integer) -> (Maybe Integer) -> (Maybe Integer) -> Range

-- | Access the <i>Content-Range</i> header field.
contentRange :: Http Response :-> Maybe Range

-- | Access the <i>Range</i> header field.
range :: Http Request :-> Maybe Range

-- | Lens containing parser and pretty-printer for HTTP ranges.
rangeL :: String :<->: Range

-- | Handler to run CGI scripts.
hCGI :: (MonadIO m, HttpM' m, BodyM Request m, SendM m, HandleQueueM m, ServerM m, AddressM' m) => FilePath -> m ()

-- | The dispatcher type takes one value to dispatch on and two handlers.
--   The first handler will be used when the predicate on the dispatch
--   value returned <a>True</a>, the second (default) handler will be used
--   when the predicate returs <a>False</a>.
type Dispatcher a m b = a -> m b -> m b -> m b

-- | A list dispatcher takes a mapping from dispatch values to handlers and
--   one default fallback handler.
type ListDispatcher a m b = [(a, m b)] -> m b -> m b

-- | Dispatch on an arbitrary part of the context using an arbitrary
--   predicate. When the predicate returns true on the value selected with
--   the <a>Label</a> the first handler will be invoked, otherwise the
--   second handler will be used.
hDispatch :: (HttpM d m) => d -> (Http d :-> b) -> (c -> b -> Bool) -> Dispatcher c m a

-- | Like the <a>hDispatch</a> but always dispatches on a (part of) the
--   `HTTP Request' part of the context.
hRequestDispatch :: (HttpM Request m) => (Http Request :-> b) -> (t -> b -> Bool) -> Dispatcher t m c

-- | Turns a dispatcher function into a list dispatcher. This enables
--   handler routing based on arbitrary values from the context. When non
--   of the predicates in the <a>ListDispatcher</a> type hold the default
--   handler will be invoked.
hListDispatch :: Dispatcher a m b -> ListDispatcher a m b

-- | Request dispatcher based on the HTTP request <a>Method</a>.
hMethod :: (HttpM Request m) => Dispatcher Method m a

-- | Request list dispatcher based on the <a>hMethod</a> dispatcher.
hMethodRouter :: (HttpM Request m) => ListDispatcher Method m ()

-- | Request dispatcher based on the request path.
hPath :: (HttpM Request m) => Dispatcher String m a

-- | List dispatcher version of <a>hPath</a>.
hPathRouter :: (HttpM Request m) => ListDispatcher String m a

-- | Request dispatcher based on a prefix of the request path.
hPrefix :: (HttpM Request m) => Dispatcher String m a

-- | List dispatcher version of <a>hPrefix</a>.
hPrefixRouter :: (HttpM Request m) => ListDispatcher String m a

-- | Helper function to fetch the URI parameters from the request.
hQueryParameters :: (HttpM Request m) => m Parameters

-- | Request dispatcher based on the request path file extenstion.
hExtension :: (HttpM Request m) => Dispatcher (Maybe String) m a

-- | List dispatcher version of <a>hExtension</a>.
hExtensionRouter :: (HttpM Request m) => ListDispatcher (Maybe String) m a

-- | Dispatcher based on the host part of the <a>hostname</a> request
--   header. Everything not part of the real hostname (like the port
--   number) will be ignored. When the expected hostname starts with a dot
--   (like <a>.mydomain.com</a>) this indicates that all sub-domains of
--   this domain will match as well.
hVirtualHosting :: (HttpM Request m) => ListDispatcher String m b

-- | Dispatcher based on the port number of the <a>hostname</a> request
--   header. When no port number is available in the hostname header port
--   80 will be assumed.
hPortRouter :: (HttpM Request m) => ListDispatcher Int m b

-- | Set the `Set-Cookie` HTTP response header with the specified
--   <a>Cookies</a>.
hSetCookie :: (HttpM Response m) => Cookies -> m ()

-- | Try to get the cookies from the HTTP <a>cookie</a> request header.
hCookie :: (HttpM Request m) => m (Maybe Cookies)

-- | Delete one cookie by removing it from the `Set-Cookie' header.
hDelCookie :: (HttpM Response m) => String -> m ()

-- | Convenient method for creating cookies that expire in the near future
--   and are bound to the domain and port this server runs on. The path
--   will be locked to root. If the second argument is set, the cookie will
--   be valid for all subdomains.
hNewCookie :: (ServerM m, ServerAddressM m, FormatTime t) => t -> Bool -> m Cookie

module Network.Salvia.Impl.Context

-- | A generic handler context that contains all the information needed by
--   the request handlers to perform their task and to set up a proper
--   response. All the fields in the context are accessible using the first
--   class labels defined below.
data Context p
Context :: String -> String -> [SockAddr] -> Http Request -> Http Response -> Http Request -> Http Response -> Socket -> Handle -> SockAddr -> SockAddr -> SendQueue -> p -> Context p
_cServerHost :: Context p -> String
_cAdminMail :: Context p -> String
_cListenOn :: Context p -> [SockAddr]
_cRequest :: Context p -> Http Request
_cResponse :: Context p -> Http Response
_cRawRequest :: Context p -> Http Request
_cRawResponse :: Context p -> Http Response
_cSocket :: Context p -> Socket
_cHandle :: Context p -> Handle
_cClientAddr :: Context p -> SockAddr
_cServerAddr :: Context p -> SockAddr
_cQueue :: Context p -> SendQueue
_cPayload :: Context p -> p

-- | The server hostname.
cServerHost :: Context p :-> String

-- | The mail address of the server adminstrator.
cAdminMail :: Context p :-> String

-- | The socket address(es) the server is listening on.
cListenOn :: Context p :-> [SockAddr]

-- | Connection wide payload.
cPayload :: Context p :-> p

-- | The HTTP request header.
cRequest :: Context p :-> Http Request

-- | The HTTP response header.
cResponse :: Context p :-> Http Response

-- | The unaltered HTTP request header as received from a client.
cRawRequest :: Context p :-> Http Request

-- | The plain HTTP response header unaffected by local rewriting.
cRawResponse :: Context p :-> Http Response

-- | Raw socket for connection to the peer.
cSocket :: Context p :-> Socket

-- | File descriptor associated with socket for the connection to the peer.
cHandle :: Context p :-> Handle

-- | Client address.
cClientAddr :: Context p :-> SockAddr

-- | Server address.
cServerAddr :: Context p :-> SockAddr

-- | The queue of send actions.
cQueue :: Context p :-> SendQueue
instance (Show p) => Show (Context p)

module Network.Salvia.Impl.Handler
newtype Handler p a
Handler :: StateT (Context p) IO a -> Handler p a
unHandler :: Handler p a -> StateT (Context p) IO a
runHandler :: Handler p a -> Context p -> IO (a, Context p)
instance [incoherent] Functor (Handler p)
instance [incoherent] Applicative (Handler p)
instance [incoherent] Monad (Handler p)
instance [incoherent] MonadIO (Handler p)
instance [incoherent] MonadState (Context p) (Handler p)
instance [incoherent] (Contains p (TVar q)) => PayloadM p q (Handler p)
instance [incoherent] ServerM (Handler p)
instance [incoherent] BodyM Response (Handler p)
instance [incoherent] BodyM Request (Handler p)
instance [incoherent] FlushM Request (Handler p)
instance [incoherent] FlushM Response (Handler p)
instance [incoherent] MonadPlus (Handler p)
instance [incoherent] Alternative (Handler p)
instance [incoherent] (Monoid a) => Monoid (Handler p a)
instance [incoherent] ServerAddressM (Handler p)
instance [incoherent] ClientAddressM (Handler p)
instance [incoherent] HandleM (Handler p)
instance [incoherent] SocketM (Handler p)
instance [incoherent] SendM (Handler p)
instance [incoherent] QueueM (Handler p)
instance [incoherent] SocketQueueM (Handler p)
instance [incoherent] HandleQueueM (Handler p)
instance [incoherent] RawHttpM Response (Handler p)
instance [incoherent] RawHttpM Request (Handler p)
instance [incoherent] HttpM Response (Handler p)
instance [incoherent] HttpM Request (Handler p)
instance [incoherent] ForkM IO (Handler p)

module Network.Salvia.Impl.Server

-- | todo: Start a webserver with a specific server configuration and
--   default handler. The server will go into an infinite loop and will
--   repeatedly accept client connections on the address and port specified
--   in the configuration. For every connection the specified handler will
--   be executed with the client address and socket stored in the handler
--   context.
start :: Config -> Handler p () -> p -> IO ()

module Network.Salvia.Impl

module Network.Salvia
