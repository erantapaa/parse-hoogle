-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | JavaScript Parser
--   
--   A Javascript parser and interpreter. Works as per ECMA-262 plus some
--   parts of JS &gt;=1.5.
@package hjs
@version 0.2.1

module HJS.Parser.Utils

module HJS.Parser.Lexer
data Token
TokenWhite :: Token
TokenInt :: Int -> Token
TokenIdent :: String -> Token
TokenStringLit :: String -> Token
TokenNL :: Token
TokenRegex :: (String, String) -> Token
TokenEof :: Token
TokenRID :: String -> Token
TokenROP :: String -> Token
runLexer :: String -> [(SourcePos, Token)]
runIO :: Show a => Parser a -> String -> IO ()
instance [overlap ok] Show Token
instance [overlap ok] Eq Token

module HJS.Parser.Prim
data JSPState
JSPState :: Bool -> JSPState
nlFlag :: JSPState -> Bool
type JSParser a = GenParser (SourcePos, Token) JSPState a
mytoken :: (Token -> Maybe a) -> JSParser a
equal :: Token -> JSParser ()
rID :: String -> JSParser ()
identifier :: JSParser String
rOp :: String -> JSParser ()
nest :: JSParser String
braces :: JSParser a -> JSParser a

module HJS.Interpreter.VarArgs
class BuildList a r | r -> a
build' :: BuildList a r => [a] -> a -> r
instance [overlap ok] BuildList a b => BuildList a (a -> b)
instance [overlap ok] Show a => BuildList a [String]

module HJS.Parser.JavaScript
class EmitHaskell a
eHs :: EmitHaskell a => a -> String
data Literal
LitInt :: Int -> Literal
LitString :: String -> Literal
LitNull :: Literal
LitBool :: Bool -> Literal
data PrimExpr
Literal :: Literal -> PrimExpr
Ident :: String -> PrimExpr
Brack :: Expr -> PrimExpr
This :: PrimExpr
Regex :: (String, String) -> PrimExpr
Array :: ArrayLit -> PrimExpr
Object :: [Either (PropName, AssignE) GetterPutter] -> PrimExpr
PEFuncDecl :: FuncDecl -> PrimExpr
data GetterPutter
GetterPutter :: PropName -> FuncDecl -> GetterPutter
Putter :: FuncDecl -> GetterPutter
data PropName
PropNameId :: String -> PropName
PropNameStr :: String -> PropName
PropNameInt :: Int -> PropName
data ArrayLit
ArrSimple :: [AssignE] -> ArrayLit
data MemberExpr
MemPrimExpr :: PrimExpr -> MemberExpr
ArrayExpr :: MemberExpr -> Expr -> MemberExpr
MemberNew :: MemberExpr -> [AssignE] -> MemberExpr
MemberCall :: MemberExpr -> String -> MemberExpr
MemberCall2 :: MemberExpr -> MemberExpr -> MemberExpr
data CallExpr
CallPrim :: MemberExpr -> CallExpr
CallMember :: MemberExpr -> [AssignE] -> CallExpr
CallCall :: CallExpr -> [AssignE] -> CallExpr
CallSquare :: CallExpr -> Expr -> CallExpr
CallDot :: CallExpr -> String -> CallExpr
data NewExpr
MemberExpr :: MemberExpr -> NewExpr
NewNewExpr :: NewExpr -> NewExpr
data LeftExpr
NewExpr :: NewExpr -> LeftExpr
CallExpr :: CallExpr -> LeftExpr
data PostFix
LeftExpr :: LeftExpr -> PostFix
PostInc :: LeftExpr -> PostFix
PostDec :: LeftExpr -> PostFix
data UExpr
PostFix :: PostFix -> UExpr
Delete :: UExpr -> UExpr
Void :: UExpr -> UExpr
TypeOf :: UExpr -> UExpr
DoublePlus :: UExpr -> UExpr
DoubleMinus :: UExpr -> UExpr
UnaryPlus :: UExpr -> UExpr
UnaryMinus :: UExpr -> UExpr
Not :: UExpr -> UExpr
BitNot :: UExpr -> UExpr
data AExpr
AEUExpr :: UExpr -> AExpr
AOp :: String -> AExpr -> AExpr -> AExpr
data CondE
AExpr :: AExpr -> CondE
CondIf :: AExpr -> AssignE -> AssignE -> CondE
data AssignOp
AssignNormal :: AssignOp
AssignOpMult :: AssignOp
AssignOpDiv :: AssignOp
AssignOpMod :: AssignOp
AssignOpPlus :: AssignOp
AssignOpMinus :: AssignOp
data AssignE
CondE :: CondE -> AssignE
Assign :: LeftExpr -> AssignOp -> AssignE -> AssignE
AEFuncDecl :: FuncDecl -> AssignE
data Expr
AssignE :: AssignE -> Expr
data VarDecl
VarDecl :: String -> (Maybe AssignE) -> VarDecl
data IfStmt
IfElse :: Expr -> Stmt -> Stmt -> IfStmt
IfOnly :: Expr -> Stmt -> IfStmt
If2 :: Expr -> IfStmt
If3 :: IfStmt
data ItStmt
DoWhile :: Stmt -> Expr -> ItStmt
While :: Expr -> Stmt -> ItStmt
For :: (Maybe Expr) -> (Maybe Expr) -> (Maybe Expr) -> Stmt -> ItStmt
ForVar :: [VarDecl] -> (Maybe Expr) -> (Maybe Expr) -> Stmt -> ItStmt
ForIn :: LeftExpr -> Expr -> Stmt -> ItStmt
It2 :: Expr -> ItStmt
data TryStmt
TryBC :: [Stmt] -> [Catch] -> TryStmt
TryBF :: [Stmt] -> [Stmt] -> TryStmt
TryBCF :: [Stmt] -> [Catch] -> [Stmt] -> TryStmt
TryTry :: [Stmt] -> [Catch] -> [Stmt] -> TryStmt
data Catch
Catch :: String -> [Stmt] -> Catch
CatchIf :: String -> [Stmt] -> Expr -> Catch
CatchCatch :: String -> (Maybe Expr) -> [Stmt] -> Catch
data Stmt
StmtPos :: (Int, Int) -> Stmt' -> Stmt
data Stmt'
IfStmt :: IfStmt -> Stmt'
EmptyStmt :: Stmt'
ExprStmt :: Expr -> Stmt'
ItStmt :: ItStmt -> Stmt'
Block :: [Stmt] -> Stmt'
VarStmt :: [VarDecl] -> Stmt'
TryStmt :: TryStmt -> Stmt'
ContStmt :: (Maybe String) -> Stmt'
BreakStmt :: (Maybe String) -> Stmt'
ReturnStmt :: (Maybe Expr) -> Stmt'
WithStmt :: Expr -> Stmt -> Stmt'
LabelledStmt :: String -> Stmt -> Stmt'
Switch :: Expr -> [CaseClause] -> Stmt'
ThrowExpr :: Expr -> Stmt'
data Switch
SSwitch :: Expr -> [CaseClause] -> Switch
data CaseBlock
CaseBlock :: [CaseClause] -> CaseBlock
data CaseClause
CaseClause :: Expr -> [Stmt] -> CaseClause
DefaultClause :: [Stmt] -> CaseClause
data FuncDecl
FuncDecl :: (Maybe String) -> [String] -> [SourceElement] -> FuncDecl
data SourceElement
Stmt :: Stmt -> SourceElement
SEFuncDecl :: FuncDecl -> SourceElement
data JSProgram
JSProgram :: [SourceElement] -> JSProgram
instance [overlap ok] Show JSProgram
instance [overlap ok] Show SourceElement
instance [overlap ok] Show FuncDecl
instance [overlap ok] Show CaseClause
instance [overlap ok] Show CaseBlock
instance [overlap ok] Show Switch
instance [overlap ok] Show Stmt'
instance [overlap ok] Show Stmt
instance [overlap ok] Show Catch
instance [overlap ok] Show TryStmt
instance [overlap ok] Show ItStmt
instance [overlap ok] Show IfStmt
instance [overlap ok] Show VarDecl
instance [overlap ok] Show Expr
instance [overlap ok] Show AssignE
instance [overlap ok] Show AssignOp
instance [overlap ok] Show CondE
instance [overlap ok] Show AExpr
instance [overlap ok] Show UExpr
instance [overlap ok] Show PostFix
instance [overlap ok] Show LeftExpr
instance [overlap ok] Show NewExpr
instance [overlap ok] Show CallExpr
instance [overlap ok] Show MemberExpr
instance [overlap ok] Show ArrayLit
instance [overlap ok] Show PropName
instance [overlap ok] Show GetterPutter
instance [overlap ok] Show PrimExpr
instance [overlap ok] Show Literal

module HJS.Parser.JavaScriptParser
parseProgram :: [Char] -> Either ParseError [SourceElement]
lexProgram :: [Char] -> [(SourcePos, Token)]
runLexer :: String -> [(SourcePos, Token)]

module HJS.Parser
parseProgram :: [Char] -> Either ParseError [SourceElement]
lexProgram :: [Char] -> [(SourcePos, Token)]
lexFile :: t -> FilePath -> IO ()
runLexer :: String -> [(SourcePos, Token)]


-- | A C printf like formatter.
--   
--   Modified by MPW to take arbitrary instances of Show
module HJS.Interpreter.Printf

-- | Format a variable number of arguments with the C-style formatting
--   string. The return value is either <a>String</a> or <tt>(<a>IO</a>
--   a)</tt>.
--   
--   The format string consists of ordinary characters and /conversion
--   specifications/, which specify how to format one of the arguments to
--   printf in the output string. A conversion specification begins with
--   the character <tt>%</tt>, followed by one or more of the following
--   flags:
--   
--   <pre>
--   -      left adjust (default is right adjust)
--   0      pad with zeroes rather than spaces
--   </pre>
--   
--   followed optionally by a field width:
--   
--   <pre>
--   num    field width
--   *      as num, but taken from argument list
--   </pre>
--   
--   followed optionally by a precision:
--   
--   <pre>
--   .num   precision (number of decimal places)
--   </pre>
--   
--   and finally, a format character:
--   
--   <pre>
--   c      character               Char, Int, Integer
--   d      decimal                 Char, Int, Integer
--   o      octal                   Char, Int, Integer
--   x      hexadecimal             Char, Int, Integer
--   u      unsigned decimal        Char, Int, Integer
--   f      floating point          Float, Double
--   g      general format float    Float, Double
--   e      exponent format float   Float, Double
--   s      string                  String
--   </pre>
--   
--   Mismatch between the argument types and the format string will cause
--   an exception to be thrown at runtime.
--   
--   Examples:
--   
--   <pre>
--   &gt; printf "%d\n" (23::Int)
--   23
--   &gt; printf "%s %s\n" "Hello" "World"
--   Hello World
--   &gt; printf "%.2f\n" pi
--   3.14
--   </pre>
printf :: PrintfType r => String -> r

-- | Similar to <a>printf</a>, except that output is via the specified
--   <a>Handle</a>. The return type is restricted to <tt>(<a>IO</a>
--   a)</tt>.
hPrintf :: HPrintfType r => Handle -> String -> r

-- | The <a>PrintfType</a> class provides the variable argument magic for
--   <a>printf</a>. Its implementation is intentionally not visible from
--   this module. If you attempt to pass an argument of a type which is not
--   an instance of this class to <a>printf</a> or <a>hPrintf</a>, then the
--   compiler will report it as a missing instance of <a>PrintfArg</a>.
class PrintfType t

-- | The <a>HPrintfType</a> class provides the variable argument magic for
--   <a>hPrintf</a>. Its implementation is intentionally not visible from
--   this module.
class HPrintfType t
class PrintfArg a
class IsChar c
instance [incoherent] Show a => PrintfArg a
instance [incoherent] IsChar Char
instance [incoherent] PrintfArg Double
instance [incoherent] PrintfArg Float
instance [incoherent] PrintfArg Integer
instance [incoherent] PrintfArg Int
instance [incoherent] IsChar c => PrintfArg [c]
instance [incoherent] PrintfArg Char
instance [incoherent] (PrintfArg a, HPrintfType r) => HPrintfType (a -> r)
instance [incoherent] (PrintfArg a, PrintfType r) => PrintfType (a -> r)
instance [incoherent] HPrintfType (IO a)
instance [incoherent] PrintfType (IO a)
instance [incoherent] IsChar c => PrintfType [c]

module HJS.Interpreter.InterpMDecl
data Ref
Ref :: String -> Ref
RefObj :: ObjId -> String -> Ref
data ObjId
ObjId :: Int -> ObjId
ObjIdNull :: ObjId
data Undefined
Undefined :: Undefined
data Null
Null :: Null
data RunFlag
Debug :: RunFlag
Trace :: RunFlag
ShowHeap :: RunFlag
data CallValue
CallJS :: [SourceElement] -> CallValue
CallBuiltIn :: (InterpM Value) -> CallValue
data BreakContinue
Break :: BreakContinue
Continue :: BreakContinue
data ArgList
ArgList :: [String] -> ArgList
VarArgList :: ArgList
type Value = Either Int (Either String (Either Bool (Either Undefined (Either Null (Either ObjId (Either Ref (Either [ObjId] (Either CallValue (Either [String] (Either BreakContinue ()))))))))))
type InterpM = ErrorT Throwable (StateT JSState IO)
type Ctx = ([ObjId], ObjId, ObjId, ObjId)
data JSState
JSS :: [Ctx] -> Map ObjId Object -> (Int, Int) -> [RunFlag] -> [DebugAction] -> JSState
ctx :: JSState -> [Ctx]
oheap :: JSState -> Map ObjId Object
pos :: JSState -> (Int, Int)
flags :: JSState -> [RunFlag]
debug :: JSState -> [DebugAction]
data Throwable
ThrowReturn :: Value -> Throwable
ThrowBreak :: (Maybe String) -> Throwable
ThrowContinue :: (Maybe String) -> Throwable
ThrowException :: Value -> Throwable
ThrowTypeError :: String -> Throwable
ThrowInternalError :: String -> Throwable
data Object
Object :: ObjId -> Maybe ObjId -> String -> Maybe Value -> Map String (Value, [Attribute]) -> Object
idd :: Object -> ObjId
prototype :: Object -> Maybe ObjId
klass :: Object -> String
value :: Object -> Maybe Value
properties :: Object -> Map String (Value, [Attribute])
data Attribute
ReadOnly :: Attribute
DontEnum :: Attribute
DontDelete :: Attribute
Internal :: Attribute
data DebugAction
DBBreak :: Int -> DebugAction
DBContinue :: DebugAction
StepOver :: DebugAction
StepInto :: DebugAction
PrintObj :: Int -> DebugAction
PrintHeap :: DebugAction
PrintVar :: String -> DebugAction
PrintLine :: DebugAction
PrintStack :: DebugAction
Eval :: String -> DebugAction
instance [overlap ok] Show DebugAction
instance [overlap ok] Eq DebugAction
instance [overlap ok] Eq Attribute
instance [overlap ok] Show Attribute
instance [overlap ok] Show Object
instance [overlap ok] Show Throwable
instance [overlap ok] Show JSState
instance [overlap ok] Show BreakContinue
instance [overlap ok] Eq BreakContinue
instance [overlap ok] Ord BreakContinue
instance [overlap ok] Show RunFlag
instance [overlap ok] Eq RunFlag
instance [overlap ok] Eq Null
instance [overlap ok] Show Null
instance [overlap ok] Ord Null
instance [overlap ok] Eq Undefined
instance [overlap ok] Show Undefined
instance [overlap ok] Ord Undefined
instance [overlap ok] Eq ObjId
instance [overlap ok] Show ObjId
instance [overlap ok] Ord ObjId
instance [overlap ok] Eq Ref
instance [overlap ok] Show Ref
instance [overlap ok] Ord Ref
instance [overlap ok] Eq CallValue
instance [overlap ok] Ord CallValue
instance [overlap ok] Show CallValue

module HJS.Interpreter.InterpM
data PrimHint
HString :: PrimHint
HNumber :: PrimHint
HNone :: PrimHint
class Convert a
typeOf :: Convert a => a -> [Int]
toBoolean :: Convert a => a -> InterpM Value
toNumber :: Convert a => a -> Value
toString :: Convert a => a -> InterpM Value
toPrimitive :: Convert a => PrimHint -> a -> InterpM Value
class SubType sub sup
inj :: SubType sub sup => sub -> sup
prj :: SubType sub sup => sup -> Maybe sub
prjObjId :: Value -> ObjId
prjInt :: Value -> Int
prjBool :: Value -> Bool
prjString :: Value -> String
toValueList :: Value -> [Value]
toRealInt :: Convert a => a -> Int
toRealString :: Convert a => a -> InterpM String
toRealBool :: Convert a => a -> InterpM Bool
typeOfString :: Value -> InterpM Value
nullValue :: Value
undefinedValue :: Value
trueValue :: Value
zeroValue :: Value
nullStringValue :: Value
nullObjValue :: Value
getObject :: ObjId -> InterpM Object
putObject :: Object -> InterpM ()
getObjectProperty' :: Object -> String -> InterpM (Maybe ObjId)
getProperty' :: Object -> String -> InterpM Value
getProperty :: ObjId -> String -> InterpM Value
putProperty :: ObjId -> String -> Value -> InterpM ()
toUInt32 :: String -> Int
checkAttr :: Object -> String -> Attribute -> InterpM Bool
getAttr :: Object -> String -> InterpM [Attribute]
hasProperty :: Object -> String -> Bool
deleteProperty :: Object -> String -> Object
newObjectRaw :: String -> InterpM ObjId
getCallee :: InterpM Value
getStmtLine :: InterpM Int
putDebugFlags :: [DebugAction] -> InterpM ()
getDebugFlags :: InterpM [DebugAction]
getFlags :: InterpM [RunFlag]
getThis :: InterpM Value
getValue :: Value -> InterpM Value
getObjectValue :: Value -> InterpM ObjId
getValue' :: [ObjId] -> String -> InterpM Value
putValue :: Value -> Value -> InterpM ()
newFuncObject :: [String] -> [SourceElement] -> InterpM Value -> InterpM ObjId
newBuiltInFunction :: [String] -> InterpM Value -> InterpM ObjId
pushContext :: Ctx -> InterpM ()
popContext :: InterpM ()
getArgs :: InterpM [Value]
getPropertyNames :: ObjId -> InterpM [String]
getPropertyNames' :: Object -> InterpM [String]
traceM :: String -> InterpM ()
instance [incoherent] Error Throwable
instance [incoherent] Convert BreakContinue
instance [incoherent] SubType sub ()
instance [incoherent] SubType a b => SubType a (Either c b)
instance [incoherent] SubType a (Either a b)
instance [incoherent] Eq SourceElement
instance [incoherent] Ord SourceElement
instance [incoherent] Convert [ObjId]
instance [incoherent] Convert ObjId
instance [incoherent] Convert CallValue
instance [incoherent] Convert [String]
instance [incoherent] Convert [SourceElement]
instance [incoherent] Convert [Int]
instance [incoherent] Convert ()
instance [incoherent] Convert Undefined
instance [incoherent] Convert Null
instance [incoherent] Convert Ref
instance [incoherent] Convert Bool
instance [incoherent] Convert String
instance [incoherent] Convert Int
instance [incoherent] (Convert a, Convert b) => Convert (Either a b)

module HJS.Interpreter.ObjectBasic

module HJS.Interpreter.Regex
regexConstructor :: InterpM Value
test :: InterpM Value
newRegexObject :: Value -> Value -> Value -> InterpM Value

module HJS.Interpreter.Error
errorConstructor :: InterpM Value

module HJS.Interpreter.Debugger
debugPoint :: (Int, Int) -> InterpM ()

module HJS.Interpreter.Array
arrayConstructor :: InterpM Value
newArrayObject :: [Value] -> InterpM ObjId
toList :: Value -> InterpM [Value]
push :: InterpM Value

module HJS.Interpreter.String
stringConstructor :: InterpM Value
match :: InterpM Value

module HJS.Interpreter.Object
propertyNames :: InterpM Value
toString' :: InterpM Value
hasOwnProperty :: InterpM Value

module HJS.Interpreter.Interp
data MyError
NoMsg :: MyError
Msg :: String -> MyError
class InterpC t
interp :: InterpC t => t -> InterpM Value
toProperty :: Value -> (Either (PropName, AssignE) GetterPutter) -> InterpM ()
callFunction :: Value -> [Value] -> ObjId -> InterpM Value
liftIt22 :: (InterpC x, InterpC y) => (Int -> Int -> Int) -> x -> y -> InterpM Value
interpList :: InterpC a => [a] -> InterpM Value
liftIt :: (SubType sub Value, SubType sub1 Value, InterpC t1, InterpC t) => (sub -> sub1 -> Int) -> t -> t1 -> InterpM Value
liftIt3 :: (SubType sub Value, SubType sub1 Value) => (sub -> sub1 -> Int) -> Value -> Value -> InterpM Value
defaultConstructor :: String -> InterpM Value
x :: Value
callIt :: Int -> Int
instance [incoherent] Show MyError
instance [incoherent] InterpC JSProgram
instance [incoherent] InterpC SourceElement
instance [incoherent] InterpC Catch
instance [incoherent] InterpC TryStmt
instance [incoherent] InterpC Stmt'
instance [incoherent] InterpC Stmt
instance [incoherent] InterpC ItStmt
instance [incoherent] InterpC IfStmt
instance [incoherent] InterpC VarDecl
instance [incoherent] InterpC Expr
instance [incoherent] InterpC FuncDecl
instance [incoherent] InterpC AssignE
instance [incoherent] InterpC CondE
instance [incoherent] InterpC AExpr
instance [incoherent] InterpC UExpr
instance [incoherent] InterpC PostFix
instance [incoherent] InterpC CallExpr
instance [incoherent] InterpC LeftExpr
instance [incoherent] InterpC NewExpr
instance [incoherent] InterpC MemberExpr
instance [incoherent] InterpC PrimExpr
instance [incoherent] InterpC Literal
instance [incoherent] (InterpC t1, InterpC t2) => InterpC (Either t1 t2)
instance [incoherent] InterpC a => InterpC [a]
instance [incoherent] InterpC a => InterpC (Maybe a)
instance [incoherent] InterpC Null
instance [incoherent] Error MyError

module HJS.Interpreter.Eval
eval :: String -> InterpM Value

module HJS.Interpreter.Function

module HJS.Interpreter.Host
print' :: InterpM Value
print'' :: InterpM Value
putBuiltIn :: ObjId -> String -> [String] -> InterpM Value -> InterpM ()
objectConstructor :: InterpM Value
constructorConstructor :: InterpM Value
newConstructorWith :: String -> InterpM Value -> InterpM ObjId
addBuiltIn :: InterpM ()

module HJS.Interpreter
runInterp :: InterpC p => p -> InterpM Value
runProgram :: InterpC a => [RunFlag] -> a -> IO Bool
