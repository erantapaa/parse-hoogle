-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Oleg's Zipper FS
--   
@package ZFS
@version 0.0.2

module ZipperM
data Term
File :: String -> Term
Folder :: (Map FileName Term) -> Term
type FileName = String
type FileCont = String
data Path
Down :: Path
DownTo :: FileName -> Path
DownToN :: Int -> Path
Up :: Path
Next :: Path
data DZipper r m term dir
DZipper :: dir -> [dir] -> term -> (CCT r m (Maybe term, dir) -> CCT r m (DZipper r m term dir)) -> DZipper r m term dir
dz_dir :: DZipper r m term dir -> dir
dz_path :: DZipper r m term dir -> [dir]
dz_term :: DZipper r m term dir -> term
dz_k :: DZipper r m term dir -> CCT r m (Maybe term, dir) -> CCT r m (DZipper r m term dir)
DZipDone :: term -> DZipper r m term dir
dzip'term :: Monad m => Term -> CCT r m (DZipper r m Term Path)
promptP :: MonadDelimitedCont p s m => (p b -> m b) -> m b
instance Eq Path
instance Show Path
instance Show Term

module ZFS
newClientPort :: PortNumber
fs1 :: Term
fs2 :: Term
type FSZipper r m = DZipper r m Term Path
data OSReq r m
OSRDone :: OSReq r m
OSRRead :: (ReadK r m) -> OSReq r m
OSRWrite :: String -> (UnitK r m) -> OSReq r m
OSRTrace :: String -> (UnitK r m) -> OSReq r m
OSRCommit :: Term -> (UnitK r m) -> OSReq r m
OSRefresh :: (CCT r m (FSZipper r m) -> CCT r m (OSReq r m)) -> OSReq r m
type UnitK r m = CCT r m () -> CCT r m (OSReq r m)
type ReadK r m = CCT r m String -> CCT r m (OSReq r m)
data ProcessCTX
ProcessCTX :: Socket -> ProcessCTX
psocket :: ProcessCTX -> Socket
data JobQueueT r
JQBlockedOnRead :: ProcessCTX -> (ReadK r IO) -> JobQueueT r
JQRunnable :: ProcessCTX -> (UnitK r IO) -> JobQueueT r
JQNewClient :: Socket -> JobQueueT r
data World r
World :: Term -> [JobQueueT r] -> Prompt r (OSReq r IO) -> World r
mountedFS :: World r -> Term
jobQueue :: World r -> [JobQueueT r]
osPrompt :: World r -> Prompt r (OSReq r IO)
main' :: Term -> IO a
osloop :: World t -> CCT t IO b
syslog :: MonadIO m => [String] -> m ()
interpret'req :: World r -> ProcessCTX -> OSReq r IO -> CCT r IO (World r)
run'process :: (forall m. Monad m => (Prompt r (OSReq r m)) -> CCT r m (OSReq r m)) -> Prompt r (OSReq r IO) -> CCT r IO (OSReq r IO)
fsProcess :: Monad m => CCT r m (FSZipper r m) -> Prompt r (OSReq r m) -> CCT r m (OSReq r m)
fsloop :: Monad m => DZipper r m Term Path -> Prompt r (OSReq r m) -> String -> CCT r m (OSReq r m)
show_path :: [Path] -> String
fsCommands :: Monad m => [(String, FSZipper r m -> Prompt r (OSReq r m) -> String -> String -> String -> CCT r m (OSReq r m))]
fcmd'commit :: Monad m => DZipper r m Term Path -> Prompt r (OSReq r m) -> t -> t1 -> String -> CCT r m (OSReq r m)
data FSCmdResp r m
FSCS :: String -> FSCmdResp r m
FSCZ :: (FSZipper r m) -> FSCmdResp r m
fsWrapper :: Monad m => (FSZipper r m -> Prompt r (FSCmdResp r m) -> t -> t1 -> CCT r m (FSCmdResp r m)) -> FSZipper r m -> Prompt r (OSReq r m) -> t -> t1 -> String -> CCT r m (OSReq r m)
cmd'help :: (Monad m, Monad m1) => FSZipper r m -> t -> t1 -> t2 -> m1 (FSCmdResp r1 m2)
cmd'ls :: Monad m => FSZipper r m -> Prompt r (FSCmdResp r m) -> t -> String -> CCT r m (FSCmdResp r1 m1)
cmd'next :: Monad m => DZipper r m Term Path -> t -> t1 -> t2 -> CCT r m (FSCmdResp r m)
cd'zipper :: Monad m => FSZipper r m -> Prompt r (FSCmdResp r m) -> String -> CCT r m (FSZipper r m)
list_node :: DZipper t t1 Term t2 -> String
cmd'mknode :: Monad m1 => Term -> DZipper r m1 Term Path -> Prompt r (FSCmdResp r1 m) -> t -> String -> CCT r m1 (FSCmdResp r m1)
cmd'echo :: Monad m => DZipper r m Term Path -> Prompt r (FSCmdResp r m) -> t -> String -> CCT r m (FSCmdResp r m)

-- | zip<tt>back'to</tt>place z z1| brings z1 to the same place as z Right
--   now we use a pathetic algorithm -- but it works...
zip'back'to'place :: Monad m => Prompt r (FSCmdResp r m) -> DZipper r1 m1 term Path -> DZipper r m Term Path -> CCT r m (FSZipper r m)
del'zipper :: Monad m => DZipper r m Term Path -> Prompt r (FSCmdResp r m) -> String -> CCT r m (FSZipper r m, Term)
ins'zipper :: Monad m => Term -> FSZipper r m -> Prompt r (FSCmdResp r m) -> String -> CCT r m (FSCmdResp r m)
cmd'rm :: Monad m => DZipper r m Term Path -> Prompt r (FSCmdResp r m) -> t -> String -> CCT r m (FSCmdResp r m)
cmd'mv :: Monad m => DZipper r m Term Path -> Prompt r (FSCmdResp r m) -> t -> String -> CCT r m (FSCmdResp r m)
cmd'cp :: Monad m => DZipper r m Term Path -> Prompt r (FSCmdResp r m) -> t -> String -> CCT r m (FSCmdResp r m)
svc :: Monad m => Prompt r b -> ((CCT r m a -> CCT r m b) -> b) -> CCT r m a
is'nl :: Char -> Bool
is'whitespace :: Char -> Bool
breakspan :: (a -> Bool) -> [a] -> ([a], [a])
split'path :: String -> (String, String)
type FDSET = CUInt
type TIMEVAL = CLong
c_select :: CInt -> Ptr FDSET -> Ptr FDSET -> Ptr FDSET -> Ptr TIMEVAL -> IO CInt
fd2fds :: CInt -> [FDSET]
fds2mfd :: [FDSET] -> [CInt]
test_fd_conv :: Bool
test_fd_conv' :: Bool
select'read'pending :: [CInt] -> IO [CInt]
fcntl :: CInt -> CInt -> CInt -> IO CInt
cleanup'fd :: [CInt] -> IO ()
