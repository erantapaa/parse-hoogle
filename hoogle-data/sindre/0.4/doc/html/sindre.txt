-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A programming language for simple GUIs
--   
--   Sindre is a language inspired by Awk, meant for creating very simple
--   graphical user interfaces.
@package sindre
@version 0.4


-- | Interface to the Xft library based on the <tt>X11-xft</tt> binding by
--   Clemens Fruhwirth. This library builds upon the X11 binding to Xlib
--   (<a>Graphics.X11</a>) and cannot be used with any other. A tiny part
--   of Xrender is also exposed, as no Haskell interface exists as of this
--   writing.
--   
--   The spirit of this binding is to hide away the fact that the
--   underlying implementation is accessed via the FFI, and create a
--   Haskell-like interface that does not expose many artifacts of the C
--   implementation. To that end, the only numeric types exposed are
--   high-level (no <a>CInt</a>s), and facilities for integrating resource
--   cleanup with the Haskell garbage collector have been defined (see
--   <a>XftMgr</a>).
--   
--   Another priority has been robustness. Many naively written FFI
--   bindings to not properly check the return values of the C functions
--   they call. In particular, null pointers are often assumed to never
--   exist, and oftentimes impossible to check by the user as the
--   underlying pointer is not visible across the module boundary. In this
--   binding, any Xft function that can return null has been translated
--   into a Haskell function that returns a <a>Maybe</a> value.
--   
--   Two kinds of allocator functions are provided: some that use the
--   nomenclature <tt>new</tt> and some that uses <tt>open</tt> (for
--   example <a>newColorName</a> versus <a>openColorName</a>). The former
--   require that you explicitly call the corresponding deallocator
--   (<a>freeColor</a> in this case), while the latter takes an
--   <a>XftMgr</a> as an additional argument, and automatically calls the
--   deallocator when the value is garbage-collected. It is an error to
--   call a deallocator on an automatically managed value.
module Graphics.X11.Xft

-- | A central staging point for Xft object creation. All Xft object
--   creation functions take as argument an <a>XftMgr</a> value that keeps
--   track of lifetime information. You are required to manually free the
--   <a>XftMgr</a> via <a>freeXftMgr</a> when you are done with it.
data XftMgr

-- | Create an <a>XftMgr</a> whose objects will be used on the given screen
--   and display. As Xlib is not re-entrant, a synchronisation mechanism
--   must be used, so the <a>XftMgr</a> includes actions for obtaining and
--   releasing atomic access to the display via two <a>IO</a> actions.
--   These will be executed before and after objects allocated via the
--   manager are released. It is recommended to use an <a>MVar</a> to
--   implement a mutex for synchronising the access, but if you are
--   absolutely certain that there will not be any concurrent attempts to
--   access the display, the actions can merely be <tt>return ()</tt>.
newXftMgr :: Display -> Screen -> IO () -> IO () -> IO XftMgr

-- | Free the manager and reclaim any objects associated with it. After an
--   <a>XftMgr</a> has been freed, it is invalid to use any objects created
--   through it. The lock must currently be held by the thread calling
--   <a>freeXftMgr</a>, and it will be repeatedly released and reacquired
--   throughout deallocating any remaining objects in the manager. When the
--   command returns, the lock will once again be held.
freeXftMgr :: XftMgr -> IO ()

-- | An Xft colour.
data Color

-- | The core X11 colour contained in an Xft colour.
pixel :: Color -> Pixel

-- | Create a new Xft colour based on a name. The name may be either a
--   human-readable colour such as <a>red</a>, <a>white</a> or
--   <a>darkslategray</a> (all core X colour names are supported) or a
--   hexidecimal name such as <a>#A9E2AF</a>. Names are not case-sensitive.
--   Returns <a>Nothing</a> if the given name is not recognised as a
--   colour.
newColorName :: Display -> Visual -> Colormap -> String -> IO (Maybe Color)

-- | As <a>newColorName</a>, but instead of a name, an XRender color value
--   is used.
newColorValue :: Display -> Visual -> Colormap -> RenderColor -> IO (Maybe Color)

-- | Free a colour that has been allocated with <a>newColorName</a> or
--   <a>newColorValue</a>.
freeColor :: Display -> Visual -> Colormap -> Color -> IO ()

-- | As <a>newColorName</a>, but automatically freed through the given Xft
--   manager when no longer accessible.
openColorName :: XftMgr -> Visual -> Colormap -> String -> IO (Maybe Color)

-- | As <a>newColorValue</a>, but automatically freed through the given Xft
--   manager when no longer accessible.
openColorValue :: XftMgr -> Visual -> Colormap -> RenderColor -> IO (Maybe Color)

-- | An Xft drawable.
data Draw

-- | The display for the Xft drawable.
display :: Draw -> Display

-- | The colormap for the Xft drawable.
colormap :: Draw -> Colormap

-- | The visual for the Xft drawable.
visual :: Draw -> Visual

-- | The X11 drawable underlying the Xft drawable.
drawable :: Draw -> Drawable

-- | Change the X11 drawable underlying the Xft drawable.
changeDraw :: Draw -> Drawable -> IO ()

-- | Create a new Xft drawable on the given display, using the provided
--   <a>Drawable</a> to draw on. Will return <a>Nothing</a> if the call to
--   <tt>XftDrawCreate</tt> fails, which it will usually only do if memory
--   cannot be allocated. The <a>Draw</a> has to be manually freed with
--   <a>freeDraw</a> once you are done with it.
newDraw :: Display -> Drawable -> Visual -> Colormap -> IO (Maybe Draw)

-- | Behaves as <a>newDraw</a>, except that it uses a <a>Pixmap</a> of
--   color depth 1 instead of a <a>Drawable</a>.
newDrawBitmap :: Display -> Pixmap -> IO (Maybe Draw)

-- | Behaves as <a>newDraw</a>, except that it uses a <a>Pixmap</a> of the
--   given depth instead of a <a>Drawable</a>.
newDrawAlpha :: Integral a => Display -> Pixmap -> a -> IO (Maybe Draw)

-- | Free a <a>Draw</a> created with <a>newDraw</a>. Do not free
--   <a>Draw</a>s created with <a>openDraw</a>, these are automatically
--   managed.
freeDraw :: Draw -> IO ()

-- | As <a>newDraw</a>, but automatically freed when no longer used.
openDraw :: XftMgr -> Drawable -> Visual -> Colormap -> IO (Maybe Draw)

-- | As <a>newDrawBitmap</a>, but automatically freed when no longer used.
openDrawBitmap :: XftMgr -> Drawable -> IO (Maybe Draw)

-- | As <a>newDrawBitmap</a>, but automatically freed when no longer used.
openDrawAlpha :: Integral a => XftMgr -> Drawable -> a -> IO (Maybe Draw)

-- | An Xft font.
data Font

-- | The ascent (vertical distance upwards from the baseline) of a
--   character in the font.
ascent :: Integral a => Font -> a

-- | The descent (vertical distance downwards from the baseline) of a
--   character in the font.
descent :: Integral a => Font -> a

-- | The ascent plus descent of a character in the font.
height :: Integral a => Font -> a

-- | The greatest horizontal width of a character in the font.
maxAdvanceWidth :: Integral a => Font -> a

-- | <tt>newFontName dpy scr s</tt>, where <tt>s</tt> is a Fontconfig
--   pattern string, finds the best match for <tt>s</tt> and returns a font
--   that can be used to draw on the given screen. This function very
--   rarely returns <a>Nothing</a>, and seems to return some default font
--   even if you feed it utter garbage (or an empty string).
newFontName :: Display -> Screen -> String -> IO (Maybe Font)

-- | As <a>newFontName</a>, except that the name should be an X Logical
--   Font Description (the usual fourteen elements produced by
--   <tt>xfontsel</tt>).
newFontXlfd :: Display -> Screen -> String -> IO (Maybe Font)

-- | Close the given Xft font.
freeFont :: Display -> Font -> IO ()

-- | As <a>newFontName</a>, but automatically freed when no longer used.
openFontName :: XftMgr -> String -> IO (Maybe Font)

-- | As <tt>newFontXfld</tt>, but automatically freed when no longer used.
openFontXlfd :: XftMgr -> String -> IO (Maybe Font)

-- | Lock the file underlying the Xft font. I am not certain when you would
--   need this. The return value is supposed to be an <tt>FT_TYPE</tt> from
--   Freetype, but that binding has not been written yet.
lockFace :: Font -> IO ()

-- | Unlock a face locked by <tt>lockFontFace</tt>.
unlockFace :: Font -> IO ()

-- | Note that the 'glyphWidth'/'glyphHeight' fields are the number of
--   pixels you should advance after drawing a string of this size.
textExtents :: Display -> Font -> String -> IO GlyphInfo

-- | Shortcut for calling <a>textExtents</a> and picking out the
--   <a>glyphWidth</a> field of the <a>GlyphInfo</a>.
textWidth :: Integral a => Display -> Font -> String -> IO a

-- | Shortcut for calling <a>textExtents</a> and picking out the
--   <a>glyphHeight</a> field of the <a>GlyphInfo</a>.
textHeight :: Integral a => Display -> Font -> String -> IO a

-- | Draw a string on the given drawable in the specified colour and font.
--   Drawing begins at the baseline of the string.
drawString :: (Integral x, Integral y) => Draw -> Color -> Font -> x -> y -> String -> IO ()

-- | Draw a sequence of glyphs on the given drawable in the specified
--   colour and font. Drawing begins at the baseline of the string.
drawGlyphs :: (Integral x, Integral y, Integral c) => Draw -> Color -> Font -> x -> y -> [c] -> IO ()

-- | <tt>drawRect d c x y w h</tt> draws a solid rectangle on <tt>d</tt>
--   with colour <tt>c</tt>, with its upper left corner at <tt>(x,y)</tt>,
--   width <tt>w</tt> and height <tt>h</tt>.
drawRect :: (Integral x, Integral y, Integral w, Integral h) => Draw -> Color -> x -> y -> w -> h -> IO ()

-- | The <tt>XRenderColor</tt> from the XRender library. Note that the
--   colour channels are only interpreted as 16-bit numbers when actually
--   used.
data RenderColor
RenderColor :: Int -> Int -> Int -> Int -> RenderColor
red :: RenderColor -> Int
green :: RenderColor -> Int
blue :: RenderColor -> Int
alpha :: RenderColor -> Int

-- | The size of some glyph(s). Note that there's a difference between the
--   logical size, which may include some blank pixels, and the actual
--   bitmap.
data GlyphInfo
GlyphInfo :: Int -> Int -> Int -> Int -> Int -> Int -> GlyphInfo
glyphImageWidth :: GlyphInfo -> Int
glyphImageHeight :: GlyphInfo -> Int
glyphImageX :: GlyphInfo -> Int
glyphImageY :: GlyphInfo -> Int
glyphWidth :: GlyphInfo -> Int
glyphHeight :: GlyphInfo -> Int
instance Storable GlyphInfo
instance Storable RenderColor


-- | Various utility bits and pieces.
module Sindre.Util

-- | Short-hand for <a>liftIO</a>
io :: MonadIO m => IO a -> m a

-- | Short-hand for <a>fromIntegral</a>
fi :: (Integral a, Num b) => a -> b

-- | Short-hand for 'liftIO . hPutStrLn stderr'
err :: MonadIO m => String -> m ()

-- | Short-hand for 'map toUpper'
upcase :: String -> String

-- | Short-hand for 'map toLower'
downcase :: String -> String

-- | Conversion scheme as in
--   http:<i></i>en.wikipedia.org<i>wiki</i>HSV_color_space
hsv2rgb :: Fractional a => (Integer, a, a) -> (a, a, a)

-- | Prepend and append first argument to second argument.
wrap :: String -> String -> String

-- | Put double quotes around the given string.
quote :: String -> String

-- | Bound a value by minimum and maximum values.
clamp :: Ord a => a -> a -> a -> a

-- | The <a>mapAccumLM</a> function behaves like a combination of
--   <a>mapM</a> and <tt>foldlM</tt>; it applies a monadic function to each
--   element of a list, passing an accumulating parameter from left to
--   right, and returning a final value of this accumulator together with
--   the new list.
mapAccumLM :: Monad m => (acc -> x -> m (acc, y)) -> acc -> [x] -> m (acc, [y])

-- | Like <tt>when</tt>, but with two branches. A lifted <tt>if</tt>.
ifM :: Monad m => m Bool -> m a -> m a -> m a

module Sindre.KeyVal

-- | Parse a key-value string wrapper constructed via the permutation
--   parser combinators from <a>Perm</a> and the parsers <tt>value</tt> and
--   <tt>values</tt>.
parseKV :: PermParser Parser a -> Text -> Either String a

-- | <tt>value k</tt> is a parser for the single-valued key <tt>k</tt>.
value :: Text -> Parser Text

-- | <tt>values k</tt> is a parser for the list-valued key <tt>k</tt>. At
--   least a single value is required.
values :: Text -> Parser [Text]

-- | The expression <tt>f &lt;$?&gt; (x,p)</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is optional - if it can not
--   be applied, the default value <tt>x</tt> will be used instead.
(<$?>) :: (a -> b) -> (a, p a) -> PermParser p b

-- | The expression <tt>perm &lt;||&gt; p</tt> adds parser <tt>p</tt> to
--   the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is not
--   allowed to accept empty input - use the optional combinator
--   (<a>&lt;|?&gt;</a>) instead. Returns a new permutation parser that
--   includes <tt>p</tt>.
(<||>) :: PermParser p (a -> b) -> p a -> PermParser p b

-- | The expression <tt>f &lt;$$&gt; p</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is not allowed to accept
--   empty input - use the optional combinator (<a>&lt;$?&gt;</a>) instead.
--   
--   If the function <tt>f</tt> takes more than one parameter, the type
--   variable <tt>b</tt> is instantiated to a functional type which
--   combines nicely with the adds parser <tt>p</tt> to the
--   (<a>&lt;||&gt;</a>) combinator. This results in stylized code where a
--   permutation parser starts with a combining function <tt>f</tt>
--   followed by the parsers. The function <tt>f</tt> gets its parameters
--   in the order in which the parsers are specified, but actual input can
--   be in any order.
(<$$>) :: (a -> b) -> p a -> PermParser p b

-- | The expression <tt>perm &lt;||&gt; (x,p)</tt> adds parser <tt>p</tt>
--   to the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is
--   optional - if it can not be applied, the default value <tt>x</tt> will
--   be used instead. Returns a new permutation parser that includes the
--   optional parser <tt>p</tt>.
(<|?>) :: PermParser p (a -> b) -> (a, p a) -> PermParser p b


-- | General definitions for the Sindre programming language. The
--   documentation for this module does not include a description of the
--   language semantics.
module Sindre.Sindre

-- | A rectangle represented as its upper-left corner, width and height.
--   You should never create rectangles with negative dimensions, and the
--   functions in this module make no guarantee to their behaviour if you
--   do.
data Rectangle
Rectangle :: Integer -> Integer -> Integer -> Integer -> Rectangle
rectX :: Rectangle -> Integer
rectY :: Rectangle -> Integer
rectWidth :: Rectangle -> Integer
rectHeight :: Rectangle -> Integer

-- | A size constraint in one dimension.
data DimNeed

-- | At minimum this many pixels.
Min :: Integer -> DimNeed

-- | At most this many pixels.
Max :: Integer -> DimNeed

-- | As many or as few pixels as necessary.
Unlimited :: DimNeed

-- | Exactly this many pixels.
Exact :: Integer -> DimNeed

-- | Size constraints in both dimensions.
type SpaceNeed = (DimNeed, DimNeed)

-- | The amount of space actually used by a widget.
type SpaceUse = [Rectangle]

-- | Externally-imposed optional minimum and maximum values for width and
--   height.
type Constraints = ((Maybe Integer, Maybe Integer), (Maybe Integer, Maybe Integer))

-- | Instruction on how to align a smaller interval within a larger
--   interval.
data Align

-- | Align towards negative infinity.
AlignNeg :: Align

-- | Align towards positive infinity.
AlignPos :: Align

-- | Align towards the center of the interval.
AlignCenter :: Align

-- | <tt>constrainNeed need constraints</tt> reduces the space requirement
--   given by <tt>need</tt> in order to fulfill <tt>constraints</tt>.
constrainNeed :: SpaceNeed -> Constraints -> SpaceNeed

-- | <tt>fitRect rect need</tt> yields a rectangle as large as possible,
--   but no larger than <tt>rect</tt>, that tries to fulfill the
--   constraints <tt>need</tt>.
fitRect :: Rectangle -> SpaceNeed -> Rectangle

-- | <tt>splitHoriz rect dims</tt> splits <tt>rect</tt> horizontally into a
--   number of non-overlapping equal-width rectangles stacked on top of
--   each other. <tt>dims</tt> is a list of height requirements that the
--   function will attempt to fulfill as best it is able. The union of the
--   list of returned rectangles will always be equal to <tt>rect</tt>. No
--   rectangle will ever have negative dimensions.
splitHoriz :: Rectangle -> [DimNeed] -> [Rectangle]

-- | As <tt>splitHoriz</tt>, but splits vertically instead of horizontally,
--   so the rectangles will be next to each other.
splitVert :: Rectangle -> [DimNeed] -> [Rectangle]

-- | Flip the x and y coordinates and width and height of a rectangle, in a
--   sense rotating it ninety degrees. Note that <tt>rectTranspose .
--   rectTranspose = id</tt>.
rectTranspose :: Rectangle -> Rectangle

-- | <tt>align a lower x upper</tt>, where <tt>lower&lt;=upper</tt>, aligns
--   a subinterval of length <tt>x</tt> in the interval <tt>lower</tt> to
--   <tt>upper</tt>, returning the coordinate at which the aligned
--   subinterval starts. For example,
--   
--   <pre>
--   &gt;&gt;&gt; align AlignCenter 2 4 10
--   4
--   
--   &gt;&gt;&gt; align AlignNeg 2 4 10
--   2
--   
--   &gt;&gt;&gt; align AlignPos 2 4 10
--   6
--   </pre>
align :: Integral a => Align -> a -> a -> a -> a

-- | <tt>adjustRect (walign, halign) bigrect smallrect</tt> returns a
--   rectangle with the same dimensions as <tt>smallrect</tt> aligned
--   within <tt>bigrect</tt> in both dimensions.
adjustRect :: (Align, Align) -> Rectangle -> Rectangle -> Rectangle

-- | A keyboard modifier key. The precise meaning (and location) of these
--   is somewhat platform-dependent. Note that the <tt>Shift</tt> modifier
--   should not be passed along if the associated key is a
--   <tt>CharKey</tt>, as <tt>Shift</tt> will already have been handled.
data KeyModifier
Control :: KeyModifier
Meta :: KeyModifier
Super :: KeyModifier
Hyper :: KeyModifier
Shift :: KeyModifier

-- | Either a key corresponding to a visible character, or a control key
--   not associated with any character.
data Key

-- | Unicode character associated with the key.
CharKey :: Char -> Key

-- | Name of the control key, using X11 key names (for example
--   <tt>BackSpace</tt> or <tt>Return</tt>).
CtrlKey :: String -> Key

-- | A combination of a set of modifier keys and a primary key,
--   representing a complete piece of keyboard input.
type Chord = (Set KeyModifier, Key)

-- | Wrap a value with source position information.
data P a
P :: SourcePos -> a -> P a
sourcePos :: P a -> SourcePos
unP :: P a -> a

-- | <tt>x <a>at</a> y</tt> gives a value containing <tt>x</tt>, but with
--   the same source position as <tt>y</tt>.
at :: a -> P b -> P a

-- | A position in a source file, consisting of a file name, one-indexed
--   line number, and one-indexed column number.
type SourcePos = (String, Int, Int)

-- | A default position when no other is available.
nowhere :: SourcePos

-- | Prettyprint a source position in a human-readable form.
--   
--   <pre>
--   &gt;&gt;&gt; position ("foobar.sindre", 5, 15)
--   "foobar.sindre:5:15: "
--   </pre>
position :: SourcePos -> String

-- | The type of names (such as variables and classes) in the syntax tree.
type Identifier = String

-- | The syntax of Sindre statements.
data Stmt
Print :: [P Expr] -> Stmt
Exit :: (Maybe (P Expr)) -> Stmt
Return :: (Maybe (P Expr)) -> Stmt
Next :: Stmt
If :: (P Expr) -> [P Stmt] -> [P Stmt] -> Stmt
While :: (P Expr) -> [P Stmt] -> Stmt
For :: (P Expr) -> (P Expr) -> (P Expr) -> [P Stmt] -> Stmt
Do :: [P Stmt] -> (P Expr) -> Stmt
Break :: Stmt
Continue :: Stmt
Expr :: (P Expr) -> Stmt
Focus :: (P Expr) -> Stmt

-- | The syntax of Sindre expressions.
data Expr
Literal :: Value -> Expr
Var :: Identifier -> Expr
FieldOf :: Identifier -> (P Expr) -> Expr
Lookup :: (P Expr) -> (P Expr) -> Expr
Not :: (P Expr) -> Expr
LessThan :: (P Expr) -> (P Expr) -> Expr
LessEql :: (P Expr) -> (P Expr) -> Expr
Equal :: (P Expr) -> (P Expr) -> Expr
Assign :: (P Expr) -> (P Expr) -> Expr
PostInc :: (P Expr) -> Expr
PostDec :: (P Expr) -> Expr
Concat :: (P Expr) -> (P Expr) -> Expr
Plus :: (P Expr) -> (P Expr) -> Expr
Minus :: (P Expr) -> (P Expr) -> Expr
Times :: (P Expr) -> (P Expr) -> Expr
Divided :: (P Expr) -> (P Expr) -> Expr
Modulo :: (P Expr) -> (P Expr) -> Expr
RaisedTo :: (P Expr) -> (P Expr) -> Expr
Funcall :: Identifier -> [P Expr] -> Expr
Methcall :: (P Expr) -> Identifier -> [P Expr] -> Expr
Cond :: (P Expr) -> (P Expr) -> (P Expr) -> Expr

-- | Low-level reference to an object.
type ObjectNum = Int

-- | High-level reference to an object, containing its class and name (if
--   any) as well. For non-widgets, the object name is the same as the
--   object class.
type ObjectRef = (ObjectNum, Identifier, Maybe Identifier)

-- | High-level reference to a widget.
type WidgetRef = ObjectRef

-- | Dynamically typed run-time value in the Sindre language.
data Value
StringV :: Text -> Value
Number :: Double -> Value
Reference :: ObjectRef -> Value
Dict :: (Map Value Value) -> Value

-- | <tt>string s</tt> returns a Sindre string.
string :: String -> Value

-- | <tt>true v</tt> returns <a>True</a> if <tt>v</tt> is interpreted as a
--   true value in Sindre, <a>False</a> otherwise.
true :: Value -> Bool

-- | Canonical false value, see <a>true</a>.
--   
--   Canonical true value, see <a>true</a>.
truth, falsity :: Value

-- | Something that happened in the world.
data Event
KeyPress :: Chord -> Event
NamedEvent :: Identifier -> [Value] -> EventSource -> Event

-- | The name of the event.
eventName :: Event -> Identifier

-- | The payload of the event.
eventValue :: Event -> [Value]

-- | Where it's from.
eventSource :: Event -> EventSource

-- | The origin of an event. This is used when determining where to handle
--   it.
data EventSource

-- | <tt>FieldSrc obj f</tt> designates that the source of the event is the
--   property <tt>f</tt> of <tt>obj</tt>
FieldSrc :: ObjectRef -> Identifier -> EventSource

-- | The source is the given object.
ObjectSrc :: ObjectRef -> EventSource

-- | The source is something within the bowels of the active backend,
--   probably from the external world.
BackendSrc :: EventSource

-- | Description of sets of sources, values of this type can be used to
--   pattern-match <tt>EventSource</tt>s.
data SourcePat

-- | For <tt>NamedSource k fk</tt>, the source must be the object named
--   <tt>k</tt>. If <tt>fk</tt> is <tt>Just fk'</tt>, the source must also
--   be the field named <tt>fk'</tt>.
NamedSource :: Identifier -> (Maybe Identifier) -> SourcePat

-- | For <tt>GenericSource cn k fk</tt>, the source must be of class
--   <tt>cn</tt>. If <tt>fk</tt> is <tt>Just fk'</tt>, the source must also
--   be the field named <tt>fk'</tt>. The variable named <tt>k</tt> should
--   be bound to the actual object if this pattern matches.
GenericSource :: Identifier -> Identifier -> (Maybe Identifier) -> SourcePat

-- | A description of an event used to indicate how to handle different
--   events.
data Pattern

-- | Match if the event is a chord.
ChordPattern :: Chord -> Pattern

-- | Match if either pattern matches.
OrPattern :: Pattern -> Pattern -> Pattern

-- | <tt>SourcedPattern src ev vars</tt> matches if <tt>src</tt> matches
--   the event source (see <a>SourcePat</a>) an <tt>ev</tt> matches the
--   event name. <tt>vars</tt> should be bound to the values in the payload
--   of the event.
SourcedPattern :: SourcePat -> Identifier -> [Identifier] -> Pattern
patternSource :: Pattern -> SourcePat
patternEvent :: Pattern -> Identifier
patternVars :: Pattern -> [Identifier]

-- | Reaction to an event.
data Action

-- | Execute these statements.
StmtAction :: [P Stmt] -> Action

-- | A function consists of lexically bound parameters and a body.
data Function
Function :: [Identifier] -> [P Stmt] -> Function

-- | A Sindre GUI is a recursive tree, with each node representing a single
--   widget and consisting of the following fields.
data GUI
GUI :: Maybe Identifier -> P Identifier -> WidgetArgs -> [(Maybe (P Expr), GUI)] -> GUI

-- | Name of the widget, if any.
widgetName :: GUI -> Maybe Identifier

-- | Class of the widget.
widgetClass :: GUI -> P Identifier

-- | The arguments passed to the widget.
widgetArgs :: GUI -> WidgetArgs

-- | Children of the widget, if any.
widgetChildren :: GUI -> [(Maybe (P Expr), GUI)]

-- | A complete Sindre program. Note that this is intentionally defined
--   such that some invalid programs, like those with duplicate definitions
--   can be represented - the compiler (see <a>Sindre.Compiler</a>) should
--   detect and handle such errors.
data Program
Program :: (Maybe (P Expr), GUI) -> [P (Pattern, Action)] -> [P (Identifier, P Expr)] -> [P (Identifier, (SindreOption, Maybe Value))] -> [P (Identifier, Function)] -> [P Stmt] -> Program
programGUI :: Program -> (Maybe (P Expr), GUI)
programActions :: Program -> [P (Pattern, Action)]
programGlobals :: Program -> [P (Identifier, P Expr)]
programOptions :: Program -> [P (Identifier, (SindreOption, Maybe Value))]
programFunctions :: Program -> [P (Identifier, Function)]

-- | The contents of the <tt>BEGIN</tt> block.
programBegin :: Program -> [P Stmt]

-- | A command line argument.
type SindreOption = OptDescr (Arguments -> Arguments)

-- | The arguments passed to the Sindre program from the command line.
type Arguments = Map String String
instance Show Rectangle
instance Eq Rectangle
instance Eq DimNeed
instance Show DimNeed
instance Ord DimNeed
instance Show Align
instance Eq Align
instance Eq KeyModifier
instance Ord KeyModifier
instance Show KeyModifier
instance Show Key
instance Eq Key
instance Ord Key
instance Eq Value
instance Ord Value
instance Show a => Show (P a)
instance Eq a => Eq (P a)
instance Ord a => Ord (P a)
instance Functor P
instance Show Expr
instance Eq Expr
instance Ord Expr
instance Show Stmt
instance Eq Stmt
instance Show EventSource
instance Show Event
instance Eq SourcePat
instance Ord SourcePat
instance Show SourcePat
instance Eq Pattern
instance Ord Pattern
instance Show Pattern
instance Show Function
instance Eq Function
instance Show Action
instance Show GUI
instance Show Value
instance Monoid Rectangle


-- | Parser for the Sindre programming language. The documentation for this
--   module does not include a description of the language syntax.
module Sindre.Parser

-- | <tt>parseSindre prog filename string</tt> extends the <a>Program</a>
--   <tt>prog</tt> with the declarations in the given Sindre source code.
--   In case of mutually-exclusive definitions (such as the <tt>BEGIN</tt>
--   block, or identically named functions), the new definitions in
--   <tt>string</tt> take precedence.
parseSindre :: Program -> SourceName -> String -> Either ParseError Program

-- | Try to parse an integer according to the Sindre syntax, ignoring
--   trailing whitespace.
parseInteger :: String -> Maybe Double


-- | Definitions for the Sindre runtime environment.
module Sindre.Runtime

-- | The main monad in which a Sindre program executes. More specialised
--   monads, such as <a>Execution</a> are used for specific purposes, but
--   they all run on top of the Sindre monad.
data Sindre m a

-- | <tt>execSindre e m</tt> executes the action <tt>m</tt> in environment
--   <tt>e</tt>, returning the exit code of <tt>m</tt>.
execSindre :: MonadBackend m => SindreEnv m -> Sindre m a -> m ExitCode

-- | Immediately return from <a>execSindre</a>, returning the given exit
--   code.
quitSindre :: MonadBackend m => ExitCode -> Sindre m ()

-- | <tt>MonadSindre im m</tt> is the class of monads <tt>m</tt> that run
--   on top of <a>Sindre</a> with backend <tt>im</tt>, and can thus access
--   Sindre functionality.
class (MonadBackend im, Monad (m im)) => MonadSindre im m where back = sindre . lift
sindre :: MonadSindre im m => Sindre im a -> m im a
back :: MonadSindre im m => im a -> m im a
broadcast :: MonadBackend im => Event -> ObjectM o im ()
changed :: MonadBackend im => Identifier -> Value -> Value -> ObjectM o im ()
redraw :: MonadBackend im => ObjectM s im ()
fullRedraw :: MonadSindre im m => m im ()
setRootPosition :: MonadBackend m => Value -> Sindre m ()

-- | A monad that can be used as the layer beneath <a>Sindre</a>.
class (MonadIO m, Functor m, Applicative m, Mold (RootPosition m)) => MonadBackend m where type family BackEvent m :: * type family RootPosition m :: *
redrawRoot :: MonadBackend m => Sindre m ()
redrawRegion :: MonadBackend m => [Rectangle] -> Sindre m ()
getBackEvent :: MonadBackend m => Sindre m (Maybe Event)
waitForBackEvent :: MonadBackend m => Sindre m Event
printVal :: MonadBackend m => String -> m ()

-- | Container describing a newly created object.
data NewObject im
newObject :: s -> Map Identifier (Method s im) -> [Field s im] -> (Event -> ObjectM s im ()) -> NewObject im

-- | Container describing a newly created widget.
data NewWidget im
newWidget :: s -> Map Identifier (Method s im) -> [Field s im] -> (Event -> ObjectM s im ()) -> ObjectM s im SpaceNeed -> (Rectangle -> ObjectM s im SpaceUse) -> NewWidget im
data DataSlot im
instWidget :: NewWidget im -> Constraints -> DataSlot im
instObject :: NewObject im -> DataSlot im

-- | A typed description of a field, which may be read-write or read-only.
--   When constructing the actual widget, you must turn these into real
--   <a>Field</a>s by using the <a>field</a> function. A description of a
--   field consists of a name and monadic actions for reading and
--   optionally writing to the field.
data FieldDesc s im v
ReadWriteField :: Identifier -> (ObjectM s im v) -> (v -> ObjectM s im ()) -> FieldDesc s im v
ReadOnlyField :: Identifier -> (ObjectM s im v) -> FieldDesc s im v
fieldName :: FieldDesc s im v -> Identifier
getField :: FieldDesc s im v -> ObjectM s im v

-- | Turn a Haskell-typed high-level field description into a
--   <a>Value</a>-typed field.
field :: Mold v => FieldDesc s im v -> Field s im

-- | An opaque notion of a field. These are for internal use in the Sindre
--   runtime.
data Field s im

-- | A method takes as arguments a list of <a>Value</a>s and returns
--   another <a>Value</a>. You probably do not want to call these directly
--   from Haskell code, as they are dynamically typed. See <a>function</a>
--   for a convenient way to turn a Haskell function into a suitable
--   method.
type Method s im = [Value] -> ObjectM s im Value
data ObjectM s im a
setFieldByRef :: MonadBackend im => ObjectRef -> Identifier -> Value -> Execution im Value
getFieldByRef :: MonadBackend im => ObjectRef -> Identifier -> Execution im Value
callMethodByRef :: MonadBackend im => ObjectRef -> Identifier -> [Value] -> Execution im Value
recvEventByRef :: MonadBackend im => WidgetRef -> Event -> Execution im ()
draw :: MonadSindre im m => WidgetRef -> Maybe Rectangle -> m im SpaceUse
compose :: MonadSindre im m => WidgetRef -> m im SpaceNeed
data SindreEnv m
SindreEnv :: Array ObjectNum (DataSlot m) -> Seq Event -> IntMap Value -> Frame -> WidgetRef -> (Maybe (RootPosition m), WidgetRef) -> Arguments -> Redraw -> SindreEnv m
objects :: SindreEnv m -> Array ObjectNum (DataSlot m)
evtQueue :: SindreEnv m -> Seq Event
globals :: SindreEnv m -> IntMap Value
execFrame :: SindreEnv m -> Frame
kbdFocus :: SindreEnv m -> WidgetRef
rootWidget :: SindreEnv m -> (Maybe (RootPosition m), WidgetRef)
arguments :: SindreEnv m -> Arguments
needsRedraw :: SindreEnv m -> Redraw
newEnv :: WidgetRef -> Arguments -> SindreEnv m
globalVal :: MonadBackend m => Key -> Sindre m Value
setGlobal :: MonadBackend m => Key -> Value -> Sindre m ()
data Execution m a
execute :: MonadBackend m => Execution m Value -> Sindre m Value
execute_ :: MonadBackend m => Execution m a -> Sindre m ()
returnHere :: MonadBackend m => Execution m Value -> Execution m Value
doReturn :: MonadBackend m => Value -> Execution m ()
nextHere :: MonadBackend m => Execution m () -> Execution m ()
doNext :: MonadBackend m => Execution m ()
breakHere :: MonadBackend m => Execution m () -> Execution m ()
doBreak :: MonadBackend m => Execution m ()
contHere :: MonadBackend m => Execution m () -> Execution m ()
doCont :: MonadBackend m => Execution m ()
setScope :: MonadBackend m => [Value] -> Execution m a -> Execution m a
enterScope :: MonadBackend m => [Value] -> Execution m a -> Execution m a
lexicalVal :: MonadBackend m => Key -> Execution m Value
setLexical :: MonadBackend m => Key -> Value -> Execution m ()
eventLoop :: MonadBackend m => EventHandler m -> Sindre m ()
type EventHandler m = Event -> Execution m ()
class Mold a
mold :: Mold a => Value -> Maybe a
unmold :: Mold a => a -> Value
instance Functor (Sindre m)
instance Monad (Sindre m)
instance Applicative (Sindre m)
instance MonadCont (Sindre m)
instance MonadState (SindreEnv m) (Sindre m)
instance MonadReader (QuitFun m) (Sindre m)
instance Functor (ObjectM s im)
instance Monad (ObjectM s im)
instance Applicative (ObjectM s im)
instance MonadState s (ObjectM s im)
instance MonadReader ObjectRef (ObjectM s im)
instance Functor (Execution m)
instance Monad (Execution m)
instance Applicative (Execution m)
instance MonadReader (ExecutionEnv m) (Execution m)
instance MonadCont (Execution m)
instance Mold (Align, Align)
instance Mold a => Mold (Maybe a)
instance Mold ()
instance Mold Bool
instance Mold Int
instance Mold Integer
instance Mold Double
instance Mold Text
instance Mold String
instance Mold Value
instance MonadBackend im => MonadSindre im Execution
instance (MonadIO m, MonadBackend m) => MonadIO (ObjectM o m)
instance MonadBackend im => MonadSindre im (ObjectM o)
instance MonadBackend im => MonadSindre im Sindre
instance Monoid (Sindre m ())
instance MonadIO m => MonadIO (Sindre m)
instance MonadTrans Sindre


-- | Transforming a Sindre program into a callable function.
module Sindre.Compiler

-- | Given a Sindre program and its environment, compile the program and
--   return a pair of command-line options accepted by the program, and a
--   startup function. The program can be executed by calling the startup
--   function with the command-like arguments and an initial value for the
--   root widget. If compilation fails, an IO exception is raised.
compileSindre :: MonadBackend m => Program -> ClassMap m -> ObjectMap m -> FuncMap m -> GlobMap m -> ([SindreOption], Arguments -> m ExitCode)

-- | Mapping from class names to constructors.
type ClassMap m = Map Identifier (Constructor m)

-- | Mapping from object names to object constructor functions.
type ObjectMap m = Map Identifier (ObjectRef -> m (NewObject m))

-- | Mapping from function names to built-in functions. These must first be
--   executed in the <a>Compiler</a> monad as they may have specific
--   requirements of the environment.
type FuncMap m = Map Identifier (Compiler m ([Value] -> Sindre m Value))

-- | Mapping from names of global variables to computations that yield
--   their initial values.
type GlobMap m = Map Identifier (m Value)

-- | Function that, given an initial value, the name of itself if any, and
--   a list of children, yields a computation that constructs a new widget.
type Constructor m = WidgetRef -> [(Maybe Value, ObjectRef)] -> ConstructorM m (NewWidget m)

-- | The monad in which widget construction takes place. You can only
--   execute this by defining a <a>Constructor</a> that is then used in a
--   Sindre program (see also <a>ClassMap</a>). An example usage could be:
--   
--   <pre>
--   myWidget :: <a>Constructor</a> MyBackEnd
--   myWidget w k cs : do
--     -- ConstructorM is an instance of <a>Alternative</a>, so we can provide
--     -- defaults or fallbacks for missing parameters.
--     arg <a>- 'param' \"myParam\" &lt;|</a> return 12
--     <i>rest of construction</i>
--   </pre>
data ConstructorM m a

-- | Class of types that a given backend can convert to from <a>Value</a>s.
--   In effect, a monadic version of <a>Mold</a>.
class MonadBackend m => Param m a
moldM :: Param m a => Value -> m (Maybe a)

-- | As <a>paramM</a>, but <a>moldM</a> is always used for conversion.
paramM :: (Param m a, MonadBackend m) => Identifier -> ConstructorM m a

-- | <tt>k <a>paramAs</a> f</tt> yields the value of the widget parameter
--   <tt>k</tt>, using <tt>f</tt> to convert it to the proper Haskell type.
--   If <tt>f</tt> returns <a>Nothing</a>, <tt><a>badValue</a> k </tt> is
--   called. If <tt>k</tt> does not exist, <tt><a>noParam</a> k</tt> is
--   called.
paramAs :: MonadBackend m => Identifier -> (Value -> Maybe a) -> ConstructorM m a

-- | As <a>param</a>, but <a>mold</a> is always used for conversion.
param :: (Mold a, MonadBackend m) => Identifier -> ConstructorM m a

-- | <tt>noParam k</tt> signals that parameter <tt>k</tt> is missing.
noParam :: String -> ConstructorM m a

-- | <tt>badValue k v</tt> signals that parameter <tt>k</tt> is present
--   with value <tt>v</tt>, but that <tt>v</tt> is an invalid value.
badValue :: String -> Value -> ConstructorM m a

-- | Monad inside which compilation takes place.
type Compiler m a = RWS (CompilerEnv m) (Initialisation m) CompilerState a

-- | Given a variable name, return a computation that will yield the value
--   of the variable when executed.
value :: MonadBackend m => Identifier -> Compiler m (Execution m Value)

-- | Given a variable name, return a computation that can be used to set
--   the value of the variable when executed.
setValue :: MonadBackend m => Identifier -> Compiler m (Value -> Execution m ())
instance Show ParamError
instance MonadState (Map Identifier Value) (ConstructorM m)
instance MonadError ParamError (ConstructorM m)
instance Monad (ConstructorM m)
instance Functor (ConstructorM m)
instance Applicative (ConstructorM m)
instance (MonadIO m, MonadBackend m) => MonadIO (ConstructorM m)
instance MonadBackend im => MonadSindre im ConstructorM
instance MonadBackend m => Alternative (ConstructorM m)
instance Error ParamError


-- | Parser and definition of the dzen2-inspired formatting language used
--   by Sindre. A format string is a sequence of commands changing drawing
--   option parameters, and things to draw.
module Sindre.Formatting

-- | A formatting command is either a change to the drawing state, or a
--   string to be printed at the current location.
data Format

-- | Draw text in the given colour.
Fg :: String -> Format

-- | Draw text in the default colour.
DefFg :: Format

-- | Draw the background in the given colour.
Bg :: String -> Format

-- | Draw the background in the default colour.
DefBg :: Format

-- | Draw the given string.
Text :: Text -> Format

-- | A list of formatting commands, interpreted left-to-right.
type FormatString = [Format]

-- | The human-readable part of a format string, with formatting directives
--   stripped.
textContents :: FormatString -> Text

-- | The first background colour preceding any default background colour or
--   text entry specified in the format string, if any.
startBg :: FormatString -> Maybe String

-- | Parse a format string, returning either an error message or the result
--   of the parse.
parseFormatString :: Text -> Either String FormatString

-- | Prettyprint a <a>FormatString</a> to a string that, when parsed by
--   <a>parseFormatString</a>, results in the original <a>FormatString</a>
unparseFormatString :: FormatString -> Text
instance Show Format
instance Eq Format
instance Ord Format
instance Mold FormatString


-- | Library routines and helper functions for the Sindre programming
--   language.
module Sindre.Lib

-- | A set of pure functions that can work with any Sindre backend.
--   Includes the functions <tt>abs</tt>, <tt>atan2</tt>, <tt>cos</tt>,
--   <tt>sin</tt>, <tt>exp</tt>, <tt>log</tt>, <tt>int</tt>, <tt>sqrt</tt>,
--   <tt>length</tt>, <tt>substr</tt>, <tt>index</tt>, <tt>match</tt>,
--   <tt>sub</tt>, <tt>gsub</tt>, <tt>tolower</tt>, and <tt>toupper</tt>.
stdFunctions :: MonadBackend im => FuncMap im

-- | A set of impure functions that only work in IO backends. Includes the
--   <tt>system</tt> function.
ioFunctions :: (MonadIO m, MonadBackend m) => FuncMap m

-- | Global variables that require an IO backend. Includes the
--   <tt>ENVIRON</tt> global.
ioGlobals :: MonadIO im => Map Identifier (im Value)

-- | A class making it easy to adapt Haskell functions as Sindre functions
--   that take and return <a>Value</a>s.
class (MonadBackend im, MonadSindre im m) => LiftFunction im m a
function :: LiftFunction im m a => a -> [Value] -> m im Value

-- | Convenience class for writing <a>Chord</a> values.
class KeyLike a
chord :: KeyLike a => [KeyModifier] -> a -> Chord
instance KeyLike String
instance KeyLike Char
instance (Mold a, LiftFunction im m b, MonadSindre im m) => LiftFunction im m (a -> b)
instance (Mold a, MonadSindre im m) => LiftFunction im m (m im a)


-- | Portable Sindre gadgets and helper functions that can be used by any
--   backend.
module Sindre.Widgets

-- | A widget that arranges its children in a horizontal row.
mkHorizontally :: MonadBackend m => Constructor m

-- | A widget that arranges its children in a vertical column.
mkVertically :: MonadBackend m => Constructor m

-- | <tt>changeField field m</tt> applies <tt>m</tt> to the current value
--   of the field <tt>field</tt>, updates <tt>field</tt> with the value
--   returned by <tt>m</tt>, and returns the new value.
changeField :: FieldDesc s im v -> (v -> ObjectM s im v) -> ObjectM s im v

-- | Like <a>changeField</a>, but without a return value.
changeField_ :: FieldDesc s im v -> (v -> ObjectM s im v) -> ObjectM s im ()

-- | <tt>changingFields fields m</tt> evaluates <tt>m</tt>, then emits
--   field change events for those fields whose names are in
--   <tt>fields</tt> that changed while evaluating <tt>m</tt>.
changingField :: (MonadBackend im, Mold v) => FieldDesc s im v -> ObjectM s im a -> ObjectM s im a

-- | The result of using <a>match</a> to apply a user-provided pattern to a
--   string.
data Match
ExactMatch :: Match
PrefixMatch :: Match
InfixMatch :: Match

-- | <tt>match pat s</tt> applies the pattern <tt>pat</tt> to <tt>s</tt>
--   and returns a <a>Match</a> describing the kind of match if any, or
--   <a>Nothing</a> otherwise. The pattern is interpreted as tokens
--   delimited by whitespace, and each token must be present somewhere in
--   <tt>s</tt>.
match :: Text -> Text -> Maybe Match

-- | <tt>filterMatches f pat l</tt> returns only those elements of
--   <tt>l</tt> that match <tt>pat</tt>, using <tt>f</tt> to convert each
--   element to a <a>Text</a>. The result will be ordered equivalently to
--   <tt>l</tt>
filterMatches :: (a -> Text) -> Text -> [a] -> [a]

-- | <tt>sortMatches f pat l</tt> returns only those elements of <tt>l</tt>
--   that match <tt>pat</tt>, using <tt>f</tt> to convert each element to a
--   <a>Text</a>. The result will be reordered such that exact matches come
--   first, then prefixes, then infixes, although original order will be
--   maintained within these three groups.
sortMatches :: (a -> Text) -> Text -> [a] -> [a]
instance Eq Match
instance Ord Match
instance Show Match


-- | X11 backend for Sindre. For internationalised keyboard input to work,
--   make sure the locale is correctly set.
module Sindre.X11

-- | Sindre backend using Xlib.
data SindreX11M a

-- | The read-only configuration of the X11 backend, created during backend
--   initialisation.
data SindreX11Conf

-- | Execute Sindre in the X11 backend, grabbing control of the entire
--   display and staying on top.
sindreX11override :: String -> SindreX11M ExitCode -> IO ExitCode

-- | Execute Sindre in the X11 backend as a dock/statusbar.
sindreX11dock :: String -> SindreX11M ExitCode -> IO ExitCode

-- | Execute Sindre in the X11 backend as an ordinary client visible to the
--   window manager.
sindreX11 :: String -> SindreX11M ExitCode -> IO ExitCode

-- | Performs a lookup in the X resources database for a given property.
--   The class used is <tt><i>Sindre</i>.<i>class</i>.<i>property</i></tt>
--   and the name is <tt><i>progname</i>.<i>name</i>.<i>property</i></tt>,
--   where <i>progname</i> is the value of <a>getProgName</a>.
xopt :: Param SindreX11M a => Maybe String -> String -> String -> ConstructorM SindreX11M a

-- | Options regarding visual appearance of widgets (colors and fonts).
data VisualOpts
VisualOpts :: Color -> Color -> Color -> Color -> Font -> VisualOpts
foreground :: VisualOpts -> Color
background :: VisualOpts -> Color
focusForeground :: VisualOpts -> Color
focusBackground :: VisualOpts -> Color
font :: VisualOpts -> Font

-- | Read visual options from either widget parameters or the X resources
--   database using <a>xopt</a>, or a combination. The following graphical
--   components are read:
--   
--   <ul>
--   <li><i><tt>Foreground color</tt></i> From <tt>fg</tt> parameter or
--   <tt>foreground</tt> X property.</li>
--   <li><i><tt>Background color</tt></i> From <tt>bg</tt> parameter or
--   <tt>background</tt> X property.</li>
--   <li><i><tt>Focus foreground color</tt></i> From <tt>ffg</tt> parameter
--   or <tt>focusForeground</tt> X property.</li>
--   <li><i><tt>Focus background color</tt></i> From <tt>fbg</tt> parameter
--   or <tt>focusBackground</tt> X property.</li>
--   </ul>
visualOpts :: WidgetRef -> ConstructorM SindreX11M VisualOpts
allocColor :: MonadIO m => XftMgr -> String -> m Color

-- | Helper function that makes it easier it write consistent widgets in
--   the X11 backend. The widget is automatically filled with its
--   (nonfocus) background color. You are supposed to use this in the
--   <tt>drawI</tt> method of a <tt>Widget</tt> instance definition. An
--   example:
--   
--   <pre>
--   drawI = drawing myWidgetWin myWidgetVisual $ r fg bg ffg fbg -&gt; do
--     fg drawString 0 5 "foreground"
--     bg drawString 0 15 "background"
--     ffg drawString 0 25 "focus foreground"
--     fbg drawString 0 35 "focus background"
--   </pre>
drawing :: VisualOpts -> (Rectangle -> Drawer -> Drawer -> ObjectM a SindreX11M [Rectangle]) -> Rectangle -> ObjectM a SindreX11M SpaceUse

-- | Variant of <tt>drawing</tt> that assumes the entire rectangle is used.
drawing' :: VisualOpts -> (Rectangle -> Drawer -> Drawer -> ObjectM a SindreX11M ()) -> Rectangle -> ObjectM a SindreX11M SpaceUse
type X11Field s = FieldDesc s SindreX11M
data Drawer
Drawer :: (forall f. CoreDrawer f) -> (forall f. CoreDrawer f) -> Font -> Color -> Color -> Drawer
fg :: Drawer -> forall f. CoreDrawer f
bg :: Drawer -> forall f. CoreDrawer f
drawerFont :: Drawer -> Font
drawerFgColor :: Drawer -> Color
drawerBgColor :: Drawer -> Color
setFgColor :: Drawer -> Color -> IO Drawer
setBgColor :: Drawer -> Color -> IO Drawer
textExtents :: Font -> String -> SindreX11M (Int, Int)
drawText :: (Integral x, Integral y, Integral z) => Color -> Font -> x -> y -> z -> String -> SindreX11M ()

-- | A simple dial using an arc segment to indicate the value compared to
--   the max value. Accepts <tt>max</tt> and <tt>value</tt> parameters
--   (both integers, default values 12 and 0), and a single field:
--   <tt>value</tt>. <tt><a>n</a></tt> and <tt><a>p</a></tt> are used to
--   increase and decrease the value.
mkDial :: Constructor SindreX11M

-- | Label displaying the text contained in the field <tt>label</tt>, which
--   is also accepted as a widget parameter (defaults to the empty string).
mkLabel :: Constructor SindreX11M

-- | A blank widget, showing only background color, that can use as much or
--   as little room as necessary. Useful for constraining the layout of
--   other widgets.
mkBlank :: Constructor SindreX11M

-- | Single-line text field, whose single field <tt>value</tt> (also a
--   parameter, defaults to the empty string) is the contents of the
--   editing buffer.
mkTextField :: Constructor SindreX11M

-- | An input stream object wrapping the given <a>Handle</a>. Input is
--   purely event-driven and line-oriented: the event <tt>lines</tt> is
--   sent (roughly) for each sequence of lines that can be read without
--   blocking, with the payload being a single string value containing the
--   lines read since the last time the event was sent. When end of file is
--   reached, the <tt>eof</tt> event (no payload) is sent.
mkInStream :: Handle -> ObjectRef -> SindreX11M (NewObject SindreX11M)

-- | Horizontal dmenu-style list containing a list of elements, one of
--   which is the "selected" element. If the parameter <tt>i</tt> is given
--   a true value, element matching will be case-insensitive. The following
--   methods are supported:
--   
--   <ul>
--   <li><i><tt>insert(string)</tt></i> Split <tt>string</tt> into lines
--   and add each line as an element.</li>
--   <li><i><tt>clear()</tt></i> Delete all elements.</li>
--   <li><i><tt>filter(string)</tt></i> Only display those elements that
--   contain <tt>string</tt>.</li>
--   <li><i><tt>next()</tt></i> Move selection right.</li>
--   <li><i><tt>prev()</tt></i> Move selection left.</li>
--   <li><i><tt>first()</tt></i> Move to leftmost element.</li>
--   <li><i><tt>last()</tt></i> Move to rightmost element.</li>
--   </ul>
--   
--   The field <tt>selected</tt> is the selected element.
mkHList :: Constructor SindreX11M

-- | As <a>mkHList</a>, except the list is vertical. The parameter
--   <tt>lines</tt> (default value 10) is the number of lines shown.
mkVList :: Constructor SindreX11M
instance Functor SindreX11M
instance Monad SindreX11M
instance MonadIO SindreX11M
instance MonadReader SindreX11Conf SindreX11M
instance MonadState Surface SindreX11M
instance Applicative SindreX11M
instance Show ListElem
instance Eq ListElem
instance Ord ListElem
instance Param SindreX11M Font
instance Param SindreX11M Color
instance MonadBackend SindreX11M


-- | Sindre, a programming language for writing simple GUIs
module Sindre.Main

-- | The main Sindre entry point.
sindreMain :: Program -> ClassMap SindreX11M -> ObjectMap SindreX11M -> FuncMap SindreX11M -> GlobMap SindreX11M -> [String] -> IO ()
emptyProgram :: Program
classMap :: ClassMap SindreX11M
objectMap :: ObjectMap SindreX11M
funcMap :: FuncMap SindreX11M
globMap :: GlobMap SindreX11M
