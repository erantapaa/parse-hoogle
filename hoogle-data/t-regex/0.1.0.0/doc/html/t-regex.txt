-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Matchers and grammars using tree regular expressions
--   
@package t-regex
@version 0.1.0.0

module Test.QuickCheck.Arbitrary1

-- | Version of <a>Arbitrary</a> for functors.
class Arbitrary1 f
arbitrary1 :: Arbitrary1 f => Gen a -> Gen (f a)
instance Arbitrary1 Maybe
instance Arbitrary1 []


-- | Tree regular expressions over regular data types.
module Data.Regex.Generics

-- | Tree regular expressions over pattern functor <tt>f</tt> with capture
--   identifiers of type <tt>c</tt>.
newtype Regex c (f :: * -> *)
Regex :: (forall k. Regex' k c f) -> Regex c

-- | The basic data type for tree regular expressions.
--   
--   <ul>
--   <li><tt>k</tt> is used as phantom type to point to concatenation and
--   iteration positions.</li>
--   <li><tt>c</tt> is the type of capture identifiers.</li>
--   <li><tt>f</tt> is the pattern functor over which regular expressions
--   match. In tree regular expression jargon, expresses the set of
--   constructors for nodes.</li>
--   </ul>
data Regex' k c (f :: * -> *)

-- | Useful for defining pattern synonyms for injected constructors.
Inject :: (f (Regex' k c f)) -> Regex' k c
newtype Fix (f :: * -> *) :: (* -> *) -> *
Fix :: f (Fix f) -> Fix

-- | Matches no value.
empty_ :: Regex' k c f

-- | Matches no value.
none :: Regex' k c f

-- | Matches any value of the data type.
any_ :: Regex' k c f

-- | Injects a constructor as a regular expression. That is, specifies a
--   tree regular expression whose root is given by a constructor of the
--   corresponding pattern functor, and whose nodes are other tree regular
--   expressions. When matching, fields of types other than <tt>f</tt> are
--   checked for equality, except when using <a>__</a> as the value.
inj :: f (Regex' k c f) -> Regex' k c f

-- | Serves as a placeholder for any value in a non-<tt>f</tt>-typed
--   position.
__ :: a

-- | Indicates the position of a hole in a regular expression.
square :: k -> Regex' k c f

-- | Indicates the position of a hole in a regular expression.
var :: k -> Regex' k c f

-- | Indicates the position of a hole in a regular expression. This
--   function is meant to be used with the <tt>PostfixOperators</tt>
--   pragma.
(#) :: k -> Regex' k c f

-- | Expresses alternation between two tree regular expressions: Data types
--   may match one or the other. When capturing, the first one is given
--   priority.
choice :: Regex' k c f -> Regex' k c f -> Regex' k c f

-- | Expresses alternation between two tree regular expressions: Data types
--   may match one or the other. When capturing, the first one is given
--   priority.
(<||>) :: Regex' k c f -> Regex' k c f -> Regex' k c f

-- | Concatenation: a whole in the first tree regular expression is
--   replaced by the second one.
concat_ :: (k -> Regex' k c f) -> Regex' k c f -> Regex' k c f

-- | Concatenation: a whole in the first tree regular expression is
--   replaced by the second one.
(<.>) :: (k -> Regex' k c f) -> Regex' k c f -> Regex' k c f

-- | Repeated replacement of a hole in a tree regular expression. Iteration
--   fulfills the law: <tt>iter r = r &lt;.&gt; iter r</tt>.
iter :: (k -> Regex' k c f) -> Regex' k c f

-- | Repeated replacement of a hole in a tree regular expression. This
--   function is meant to be used with the <tt>PostfixOperators</tt>
--   pragma.
(^*) :: (k -> Regex' k c f) -> Regex' k c f

-- | Indicates a part of a value that, when matched, should be given a name
--   of type <tt>c</tt> and saved for querying.
capture :: c -> Regex' k c f -> Regex' k c f

-- | Indicates a part of a value that, when matched, should be given a name
--   of type <tt>c</tt> and saved for querying.
(<<-) :: c -> Regex' k c f -> Regex' k c f

-- | Types which can be matched.
type Matchable f = (Generic1 f, MatchG (Rep1 f))

-- | Checks whether a term <tt>t</tt> matches the tree regular expression
--   <tt>r</tt>.
matches :: (Ord c, Matchable f) => Regex c f -> Fix f -> Bool

-- | Checks whether a term <tt>t</tt> matches the tree regular expression
--   <tt>r</tt>. When successful, it returns in addition a map of captured
--   subterms.
--   
--   The behaviour of several matches over the same capture identifier is
--   governed by the <a>Alternative</a> functor <tt>m</tt>. For example, if
--   <tt>m = []</tt>, all matches are returned in prefix-order. If <tt>m =
--   Maybe</tt>, only the first result is returned.
match :: (Ord c, Matchable f, Alternative m) => Regex c f -> Fix f -> Maybe (Map c (m (Fix f)))

-- | Useful function to be used as view pattern. The first argument should
--   be a function, which indicates those places where captured are found
--   Those captured are automatically put in a tuple, giving a simpler and
--   type-safer access to captured subterms that looking inside a map.
--   
--   As an example, here is how one would use it for capturing two
--   subterms:
--   
--   <pre>
--   f (with (\x y -&gt; iter $ \k -&gt; x &lt;&lt;- inj One &lt;||&gt; y &lt;&lt;- inj (Two (var k))) -&gt; Just (x, y)) = ... x and y available here ...
--   </pre>
--   
--   For more concise syntax which uses quasi-quotation, check
--   <a>Data.Regex.TH</a>.
with :: With f fn r => fn -> Fix f -> Maybe r

-- | Return a random value which matches the given regular expression.
arbitraryFromRegex :: (Generic1 f, ArbitraryRegexG (Rep1 f), Arbitrary (Fix f)) => Regex c f -> Gen (Fix f)

-- | Return a random value which matches the given regular expression, and
--   which uses a supplied generator for <a>any_</a>.
arbitraryFromRegexAndGen :: (Generic1 f, ArbitraryRegexG (Rep1 f)) => Gen (Fix f) -> Regex c f -> Gen (Fix f)
instance Typeable DoNotCheckThisException
instance Show DoNotCheckThisException
instance (ArbitraryRegexG a, ArbitraryRegexG b) => ArbitraryRegexG (a :*: b)
instance (ArbitraryRegexG a, ArbitraryRegexG b) => ArbitraryRegexG (a :+: b)
instance ArbitraryRegexG a => ArbitraryRegexG (M1 i c a)
instance (Foldable f, Arbitrary1 f) => ArbitraryRegexG (Rec1 f)
instance Arbitrary c => ArbitraryRegexG (K1 i c)
instance ArbitraryRegexG Par1
instance ArbitraryRegexG U1
instance (Generic1 f, MatchG (Rep1 f)) => With f (Integer -> Integer -> Integer -> Integer -> Integer -> Regex Integer f) ([Fix f], [Fix f], [Fix f], [Fix f], [Fix f])
instance (Generic1 f, MatchG (Rep1 f)) => With f (Integer -> Integer -> Integer -> Integer -> Regex Integer f) ([Fix f], [Fix f], [Fix f], [Fix f])
instance (Generic1 f, MatchG (Rep1 f)) => With f (Integer -> Integer -> Integer -> Regex Integer f) ([Fix f], [Fix f], [Fix f])
instance (Generic1 f, MatchG (Rep1 f)) => With f (Integer -> Integer -> Regex Integer f) ([Fix f], [Fix f])
instance (Generic1 f, MatchG (Rep1 f)) => With f (Integer -> Regex Integer f) [Fix f]
instance (Generic1 f, MatchG (Rep1 f), Ord c) => With f (Regex c f) ()
instance (Functor f, Foldable f, MatchG g) => MatchG (f :.: g)
instance (MatchG a, MatchG b) => MatchG (a :*: b)
instance (MatchG a, MatchG b) => MatchG (a :+: b)
instance MatchG a => MatchG (M1 i c a)
instance (Functor f, Foldable f) => MatchG (Rec1 f)
instance Eq c => MatchG (K1 i c)
instance MatchG Par1
instance MatchG U1
instance Exception DoNotCheckThisException


-- | Attribute grammars with regular expression matching.
module Data.Regex.Rules

-- | Actions create new inherited attributes for their children, and
--   synthesized attribute for its own node, from the synthesized
--   attributes of children and the inheritance from its parent.
--   Additionally, actions may include an explicit backtrack.
type Action c (f :: * -> *) inh syn = Fix f -> inh -> Map c syn -> (Bool, Map c inh, syn)

-- | A rule comprises the regular expression to match and the action to
--   execute if successful.
type Rule c (f :: * -> *) inh syn = (Regex c f, Action c f inh syn)

-- | A grammar is simply a list of rules.
type Grammar c (f :: * -> *) inh syn = [Rule c f inh syn]

-- | Evaluate an attribute grammar over a certain term.
eval :: (Ord c, Matchable f, Monoid syn) => Grammar c f inh syn -> inh -> Fix f -> syn

-- | Converts a rule description into an actual <a>Rule</a>. Its use must
--   follow this pattern:
--   
--   <ul>
--   <li>A block of lambda-bound variables will introduce the capture
--   names,</li>
--   <li>A tree regular expression to match should capture using the
--   previous names,</li>
--   <li>After <a>-&gt;&gt;&gt;</a> or <a>-&gt;&gt;</a>, the state
--   calculation should proceed.</li>
--   </ul>
--   
--   <pre>
--   rule $ \c1 c2 -&gt;
--     regex ... c1 &lt;&lt;- ... c2 &lt;&lt;- ... -&gt;&gt; do
--       at c2 . inh .= ...          -- Set inherited for children
--       c1Syn &lt;- use (at c1 . syn)  -- Get synthesized from children
--       this . syn  .= ...          -- Set upwards synthesized attributes
--   </pre>
rule :: RuleBuilder f inh syn fn r => fn -> r

-- | Makes the attribute calculation fail if the condition is false. This
--   function can be used to add extra conditions over whether a certain
--   rule should be applied (a bit like guards).
check :: Bool -> State (ActionState Integer inh syn) ()

-- | Separates matching and attribute calculation on a rule. The action
--   should take as extra parameter the node which was matched.
(->>>) :: Monoid syn => (forall k. Regex' k Integer f) -> (Fix f -> State (ActionState Integer inh syn) ()) -> [Integer] -> Rule Integer f inh syn

-- | Separates matching and attribute calculation on a rule.
(->>) :: Monoid syn => (forall k. Regex' k Integer f) -> State (ActionState Integer inh syn) () -> [Integer] -> Rule Integer f inh syn

-- | Lens for the attributes of the current node. To be used in composition
--   with <a>inh</a> or <a>syn</a>.
this :: Functor f => ((inh, syn) -> f (inh, syn)) -> ActionState c inh syn -> f (ActionState c inh syn)

-- | Lens the attributes of a child node. To be used in composition with
--   <a>inh</a> or <a>syn</a>.
at :: (Ord c, Functor f) => c -> ((inh, syn) -> f (inh, syn)) -> ActionState c inh syn -> f (ActionState c inh syn)

-- | Lens for the inherited attributes of a node. Use only as getter with
--   <a>this</a> and as setter with <a>at</a>.
inh :: Functor f => (inh -> f inh) -> (inh, syn) -> f (inh, syn)

-- | Lens the inherited synthesized attributes of a node. Use only as
--   setter with <a>this</a> and as getter with <a>at</a>.
syn :: Functor f => (syn -> f syn) -> (inh, syn) -> f (inh, syn)
instance Monoid syn => RuleBuilder f inh syn (Integer -> Integer -> Integer -> Integer -> Integer -> [Integer] -> Rule Integer f inh syn) (Rule Integer f inh syn)
instance Monoid syn => RuleBuilder f inh syn (Integer -> Integer -> Integer -> Integer -> [Integer] -> Rule Integer f inh syn) (Rule Integer f inh syn)
instance Monoid syn => RuleBuilder f inh syn (Integer -> Integer -> Integer -> [Integer] -> Rule Integer f inh syn) (Rule Integer f inh syn)
instance Monoid syn => RuleBuilder f inh syn (Integer -> Integer -> [Integer] -> Rule Integer f inh syn) (Rule Integer f inh syn)
instance Monoid syn => RuleBuilder f inh syn (Integer -> [Integer] -> Rule Integer f inh syn) (Rule Integer f inh syn)
instance Monoid syn => RuleBuilder f inh syn ([Integer] -> Rule Integer f inh syn) (Rule Integer f inh syn)


-- | Multirec-style generics, indexed by data kind <tt>k</tt>. Pattern
--   functors should have kind <tt>(k -&gt; *) -&gt; k -&gt; *</tt>.
module Data.MultiGenerics

-- | Multirec-style fix-point, indexed by data kind.
newtype Fix (f :: (k -> *) -> k -> *) (ix :: k)
Fix :: f (Fix f) ix -> Fix
unFix :: Fix -> f (Fix f) ix

-- | The singleton kind-indexed data family. Taken from the
--   <tt>singletons</tt> package.

-- | A <a>SingI</a> constraint is essentially an implicitly-passed
--   singleton.
class SingI (a :: k)
sing :: SingI a => Sing a

-- | Convert a pattern functor to a readable <a>String</a>.
class ShowM (f :: k -> *)
showM :: ShowM f => f ix -> String

-- | We have equality for each instantiation of the pattern functor.
class EqM (f :: k -> *)
eqM :: EqM f => f ix -> f xi -> Bool

-- | Generate a random element given a proxy.
type GenM f = forall ix. Sing ix -> Gen (f ix)
class ArbitraryM (f :: k -> *)
arbitraryM :: ArbitraryM f => GenM f

-- | Representable types of kind * -&gt; *. This class is derivable in GHC
--   with the DeriveGeneric flag on.
class Generic1m (f :: (k -> *) -> k -> *) where type family Rep1m f :: (k -> *) -> k -> *
from1k :: Generic1m f => f a ix -> Rep1m f a ix
to1k :: Generic1m f => Rep1m f a ix -> f a ix

-- | Void: used for datatypes without constructors.
data V1m p ix

-- | Unit: used for constructors without arguments.
data U1m p ix
U1m :: U1m p ix

-- | Used for marking occurrences of the parameter.
newtype Par1m (xi :: k) (p :: k -> *) (ix :: k)
Par1m :: p xi -> Par1m
unPar1m :: Par1m -> p xi

-- | Recursive calls of kind '* -&gt; *'.
newtype Rec1m (f :: * -> *) (xi :: k) (p :: k -> *) (ix :: k)
Rec1m :: f (p xi) -> Rec1m
unRec1m :: Rec1m -> f (p xi)

-- | Constants, additional parameters and recursion of kind <a>*</a>.
newtype K1m i c p ix
K1m :: c -> K1m i c p ix
unK1m :: K1m i c p ix -> c

-- | Sums: encode choice between constructors.
data (:++:) (f :: (k -> *) -> k -> *) (g :: (k -> *) -> k -> *) p ix
L1m :: (f p ix) -> (:++:) p ix
R1m :: (g p ix) -> (:++:) p ix

-- | Products: encode multiple arguments to constructors.
data (:**:) f g p ix
(:**:) :: f p ix -> g p ix -> (:**:) f g p ix

-- | Tags: encode return type of a GADT constructor.
data Tag1m (f :: (k -> *) -> k -> *) (xi :: k) (p :: k -> *) (ix :: k)
Tag1m :: f p ix -> Tag1m f ix p ix
instance Eq (U1m p ix)
instance Ord (U1m p ix)
instance Read (U1m p ix)
instance Show (U1m p ix)
instance Eq c => Eq (K1m i c p ix)
instance Ord c => Ord (K1m i c p ix)
instance Read c => Read (K1m i c p ix)
instance Show c => Show (K1m i c p ix)
instance (Eq (f p ix), Eq (g p ix)) => Eq ((:++:) f g p ix)
instance (Ord (f p ix), Ord (g p ix)) => Ord ((:++:) f g p ix)
instance (Read (f p ix), Read (g p ix)) => Read ((:++:) f g p ix)
instance (Show (f p ix), Show (g p ix)) => Show ((:++:) f g p ix)
instance (Eq (f p ix), Eq (g p ix)) => Eq ((:**:) f g p ix)
instance (Ord (f p ix), Ord (g p ix)) => Ord ((:**:) f g p ix)
instance (Read (f p ix), Read (g p ix)) => Read ((:**:) f g p ix)
instance (Show (f p ix), Show (g p ix)) => Show ((:**:) f g p ix)
instance Generic1m f => Generic1m (Tag1m f xi)
instance (Generic1m f, Generic1m g) => Generic1m (f :**: g)
instance (Generic1m f, Generic1m g) => Generic1m (f :++: g)
instance Generic1m (K1m i c)
instance Generic1m (Rec1m f xi)
instance Generic1m (Par1m xi)
instance Generic1m U1m
instance Generic1m V1m


-- | Tree regular expressions over mutually recursive regular data types.
module Data.Regex.MultiGenerics

-- | Tree regular expressions over mutually recursive data types given by
--   the pattern functor <tt>f</tt>, where the top node is at index
--   <tt>ix</tt>, and with capture identifiers of type <tt>c</tt>.
newtype Regex c f ix
Regex :: (forall s. Regex' s c f ix) -> Regex c f ix

-- | The basic data type for tree regular expressions.
--   
--   <ul>
--   <li><tt>k</tt> is used as phantom type to point to concatenation and
--   iteration positions.</li>
--   <li><tt>c</tt> is the type of capture identifiers.</li>
--   <li><tt>f</tt> is the family of pattern functors over which regular
--   expressions match. In tree regular expression jargon, expresses the
--   set of constructors for nodes.</li>
--   <li><tt>ix</tt> is the index of the data type over which the regular
--   expression matches.</li>
--   </ul>
data Regex' (s :: k -> *) (c :: k -> *) (f :: (k -> *) -> k -> *) (ix :: k)

-- | Multirec-style fix-point, indexed by data kind.
newtype Fix (f :: (k -> *) -> k -> *) (ix :: k)
Fix :: f (Fix f) ix -> Fix
unFix :: Fix -> f (Fix f) ix

-- | Matches no value.
empty_ :: Regex' k c f ix

-- | Matches no value.
none :: Regex' k c f ix

-- | Matches any value of the data type.
any_ :: Regex' k c f ix

-- | Injects a constructor as a regular expression. That is, specifies a
--   tree regular expression whose root is given by a constructor of the
--   corresponding pattern functor, and whose nodes are other tree regular
--   expressions. When matching, fields of types other than <tt>f</tt> are
--   checked for equality, except when using <a>__</a> as the value.
inj :: f (Regex' k c f) ix -> Regex' k c f ix

-- | Serves as a placeholder for any value in a non-<tt>f</tt>-typed
--   position.
__ :: a

-- | Indicates the position of a hole in a regular expression.
square :: k ix -> Regex' k c f ix

-- | Indicates the position of a hole in a regular expression.
var :: k ix -> Regex' k c f ix

-- | Indicates the position of a hole in a regular expression. This
--   function is meant to be used with the <tt>PostfixOperators</tt>
--   pragma.
(!) :: k ix -> Regex' k c f ix

-- | Expresses alternation between two tree regular expressions: Data types
--   may match one or the other. When capturing, the first one is given
--   priority.
choice :: Regex' k c f ix -> Regex' k c f ix -> Regex' k c f ix

-- | Expresses alternation between two tree regular expressions: Data types
--   may match one or the other. When capturing, the first one is given
--   priority.
(<||>) :: Regex' k c f ix -> Regex' k c f ix -> Regex' k c f ix

-- | Concatenation: a whole in the first tree regular expression is
--   replaced by the second one.
concat_ :: (k xi -> Regex' k c f ix) -> Regex' k c f xi -> Regex' k c f ix

-- | Concatenation: a whole in the first tree regular expression is
--   replaced by the second one.
(<.>) :: (k xi -> Regex' k c f ix) -> Regex' k c f xi -> Regex' k c f ix

-- | Repeated replacement of a hole in a tree regular expression. Iteration
--   fulfills the law: <tt>iter r = r &lt;.&gt; iter r</tt>.
iter :: (k ix -> Regex' k c f ix) -> Regex' k c f ix

-- | Repeated replacement of a hole in a tree regular expression. This
--   function is meant to be used with the <tt>PostfixOperators</tt>
--   pragma.
(^*) :: (k ix -> Regex' k c f ix) -> Regex' k c f ix

-- | Indicates a part of a value that, when matched, should be given a name
--   of type <tt>c</tt> and saved for querying.
capture :: c ix -> Regex' k c f ix -> Regex' k c f ix

-- | Indicates a part of a value that, when matched, should be given a name
--   of type <tt>c</tt> and saved for querying.
(<<-) :: c ix -> Regex' k c f ix -> Regex' k c f ix

-- | Types which can be matched.
type Matchable f = (Generic1m f, MatchG (Rep1m f))

-- | Checks whether a term <tt>t</tt> matches the tree regular expression
--   <tt>r</tt>.
matches :: Matchable f => Regex c f ix -> Fix f ix -> Bool

-- | Types which can be matched and captured.
type Capturable c f = (Generic1m f, MatchG (Rep1m f), EqM c)

-- | Checks whether a term <tt>t</tt> matches the tree regular expression
--   <tt>r</tt>. When successful, it returns in addition a map of captured
--   subterms.
--   
--   The behaviour of several matches over the same capture identifier is
--   governed by the <a>Alternative</a> functor <tt>m</tt>. For example, if
--   <tt>m = []</tt>, all matches are returned in prefix-order. If <tt>m =
--   Maybe</tt>, only the first result is returned.
match :: (Capturable c f, Alternative m) => Regex c f ix -> Fix f ix -> Maybe [CaptureGroup c f m]
data CaptureGroup c f m
CaptureGroup :: c ix -> m (Fix f ix) -> CaptureGroup c f m
lookupGroup :: EqM c => c ix -> [CaptureGroup c f m] -> Maybe (m (Fix f ix))

-- | Useful function to be used as view pattern. The first argument should
--   be a function, which indicates those places where captured are found
--   Those captured are automatically put in a tuple, giving a simpler and
--   type-safer access to captured subterms that looking inside a map.
--   
--   As an example, here is how one would use it for capturing two
--   subterms:
--   
--   <pre>
--   f (with (\x y -&gt; iter $ \k -&gt; x &lt;&lt;- inj One &lt;||&gt; y &lt;&lt;- inj (Two (var k))) -&gt; Just (x, y)) = ... x and y available here ...
--   </pre>
--   
--   For more concise syntax which uses quasi-quotation, check
--   <a>Data.Regex.TH</a>.
with :: With f ix fn r => fn -> Fix f ix -> Maybe r

-- | Data type used to tag capture identifiers with their expected type.
newtype Wrap c ix
Wrap :: c -> Wrap c ix

-- | Wraps an already existing type to recall extra index information.
(?) :: c -> Wrap c ix

-- | Return a random value which matches the given regular expression.
arbitraryFromRegex :: (Generic1m f, ArbitraryRegexG (Rep1m f), ArbitraryM (Fix f), SingI ix) => Regex c f ix -> Gen (Fix f ix)

-- | Return a random value which matches the given regular expression, and
--   which uses a supplied generator for <a>any_</a>.
arbitraryFromRegexAndGen :: (Generic1m f, ArbitraryRegexG (Rep1m f), SingI ix) => GenM (Fix f) -> Regex c f ix -> Gen (Fix f ix)
instance Typeable DoNotCheckThisException
instance Show DoNotCheckThisException
instance Eq c => Eq (Wrap c ix)
instance Ord c => Ord (Wrap c ix)
instance (ArbitraryRegexG a, ArbitraryRegexG b) => ArbitraryRegexG (a :**: b)
instance (ArbitraryRegexG a, ArbitraryRegexG b) => ArbitraryRegexG (a :++: b)
instance ArbitraryRegexG f => ArbitraryRegexG (Tag1m f xi)
instance (Foldable f, Arbitrary1 f, SingI xi) => ArbitraryRegexG (Rec1m f xi)
instance Arbitrary c => ArbitraryRegexG (K1m i c)
instance SingI xi => ArbitraryRegexG (Par1m xi)
instance ArbitraryRegexG U1m
instance (Matchable f) => With f ix (WI xi1 -> WI xi2 -> WI xi3 -> WI xi4 -> WI xi5 -> Regex WI f ix) ([Fix f xi1], [Fix f xi2], [Fix f xi3], [Fix f xi4], [Fix f xi5])
instance (Matchable f) => With f ix (WI xi1 -> WI xi2 -> WI xi3 -> WI xi4 -> Regex WI f ix) ([Fix f xi1], [Fix f xi2], [Fix f xi3], [Fix f xi4])
instance (Matchable f) => With f ix (WI xi1 -> WI xi2 -> WI xi3 -> Regex WI f ix) ([Fix f xi1], [Fix f xi2], [Fix f xi3])
instance (Matchable f) => With f ix (WI xi1 -> WI xi2 -> Regex WI f ix) ([Fix f xi1], [Fix f xi2])
instance (Matchable f) => With f ix (WI xi -> Regex WI f ix) [Fix f xi]
instance (Capturable c f) => With f ix (Regex c f ix) ()
instance Show c => ShowM (Wrap c)
instance Eq c => EqM (Wrap c)
instance MatchG f => MatchG (Tag1m f xi)
instance (MatchG a, MatchG b) => MatchG (a :**: b)
instance (MatchG a, MatchG b) => MatchG (a :++: b)
instance Eq c => MatchG (K1m i c)
instance (Functor f, Foldable f) => MatchG (Rec1m f xi)
instance MatchG (Par1m xi)
instance MatchG U1m
instance (ShowM c, Foldable m, ShowM (Fix f)) => Show (CaptureGroup c f m)
instance Exception DoNotCheckThisException


-- | Quasi-quoters for doing pattern matching using tree regular
--   expressions.
module Data.Regex.TH

-- | Builds a pattern for a matching a tree regular expression over a
--   regular data type. Those variables not bound are taken to be capture
--   identifiers. Note that the value of capture identifiers is always a
--   list, even if it matches only one subterm in the given tree regular
--   expression.
--   
--   One example of use is:
--   
--   <pre>
--   f [rx| iter $ \k -&gt; x &lt;&lt;- inj One &lt;||&gt; y &lt;&lt;- inj (Two (k#)) |] =
--     ... x and y available here with type [Fix f] ...
--   </pre>
--   
--   In many cases, it is useful to define pattern synonyms for injecting
--   constructors, as shown below:
--   
--   <pre>
--   pattern One_   = Inject One
--   pattern Two_ x = Inject (Two_ x)
--   
--   f [rx| (\k -&gt; x &lt;&lt;- One_ &lt;||&gt; y &lt;&lt;- Two_ (k#))^* |] = ...
--   </pre>
rx :: QuasiQuoter

-- | Builds a pattern for a matching a tree regular expression over a
--   family of regular data type. Those variables not bound are taken to be
--   capture identifiers, and their index should be explicitly given in the
--   expression. Note that the value of capture identifiers is always a
--   list, even if it matches only one subterm in the given tree regular
--   expression.
--   
--   One example of use is:
--   
--   <pre>
--   f [mrx| iter $ \k -&gt; (x :: A) &lt;&lt;- inj One &lt;||&gt; (y :: B) &lt;&lt;- inj (Two (k#)) |] =
--     ... x is available with type [Fix f A]
--     ... and y with type [Fix f B]
--   </pre>
mrx :: QuasiQuoter


-- | Example of tree regular expressions over a regular data type. Click on
--   <tt>Source</tt> to view the code.
module Data.Regex.Example.Mono

-- | The pattern functor, which should be kept open. Recursion is done by
--   using the argument.
data Tree' f
Leaf' :: Tree' f
Branch' :: Int -> f -> f -> Tree' f
elt :: Tree' f -> Int
left :: Tree' f -> f
right :: Tree' f -> f

-- | Closes the data type by creating its fix-point.
type Tree = Fix Tree'

-- | The pattern functor for rose trees.
data Rose' f
Rose' :: Int -> [f] -> Rose' f
value :: Rose' f -> Int
child :: Rose' f -> [f]

-- | Closes the data type by creating its fix-point.
type Rose = Fix Rose'

-- | Pattern synonym for the <a>Leaf</a> constructor inside <a>Fix</a>.

-- | Pattern synonym for the <a>Branch</a> constructor inside <a>Fix</a>.

-- | Pattern synonym for the <a>Rose</a> constructor inside <a>Fix</a>.
aTree1 :: Tree
aTree2 :: Tree
aTree3 :: Tree
aRose1 :: Rose
aRose2 :: Rose
rTree1 :: Regex String Tree'
rTree2 :: Integer -> Regex Integer Tree'
rTree3 :: Integer -> Integer -> Regex Integer Tree'
rRose1 :: Regex String Rose'
eWith1 :: Tree -> [Tree]
eWith2 :: Tree -> [Tree]
eWith2Bis :: Tree -> [Tree]
eWith3 :: Tree -> [Tree]
eWith4 :: Tree -> [Int]
grammar1 :: Grammar String Tree' () String
grammar2 :: Grammar Integer Tree' () (String, Sum Integer)
grammar3 :: Grammar Integer Tree' Char (String, Sum Integer)
instance [overlap ok] Generic1 Tree'
instance [overlap ok] Show f => Show (Tree' f)
instance [overlap ok] Generic1 Rose'
instance [overlap ok] Show f => Show (Rose' f)
instance Datatype D1Tree'
instance Constructor C1_0Tree'
instance Constructor C1_1Tree'
instance Selector S1_1_0Tree'
instance Selector S1_1_1Tree'
instance Selector S1_1_2Tree'
instance Datatype D1Rose'
instance Constructor C1_0Rose'
instance Selector S1_0_0Rose'
instance Selector S1_0_1Rose'
instance [overlap ok] Show Rose
instance [overlap ok] Show Tree
instance [overlap ok] Arbitrary Tree

module Data.Regex.Example.FPDag2015
data List_ a l
Cons_ :: a -> l -> List_ a l
Nil_ :: List_ a l
type List a = Fix (List_ a)
oneTwoOrOneThree :: Regex c (List_ Int)
oneTwoThree :: List Char -> Bool
data Tree_ t
Node_ :: Int -> t -> t -> Tree_ t
Leaf_ :: Int -> Tree_ t
type Tree = Fix Tree_
matchAny :: Regex c Tree_
topTwo :: Regex c Tree_
shape1 :: Regex c Tree_
shape2 :: Regex c Tree_
allTwos :: Regex c Tree_
allTwosPostfix :: Regex c Tree_
allLeaves :: Tree -> [Int]
data Expr_ e
Plus_ :: e -> e -> Expr_ e
Times_ :: e -> e -> Expr_ e
Var_ :: Int -> Expr_ e
type Expr = Fix Expr_
iPlus :: Regex' k c Expr_ -> Regex' k c Expr_ -> Regex' k c Expr_
iTimes :: Regex' k c Expr_ -> Regex' k c Expr_ -> Regex' k c Expr_
iVar :: Int -> Regex' k c Expr_
simplify :: Expr -> Expr
instance (Show a, Show l) => Show (List_ a l)
instance Generic1 (List_ a)
instance Show t => Show (Tree_ t)
instance Generic1 Tree_
instance Show e => Show (Expr_ e)
instance Generic1 Expr_
instance Datatype D1List_
instance Constructor C1_0List_
instance Constructor C1_1List_
instance Datatype D1Tree_
instance Constructor C1_0Tree_
instance Constructor C1_1Tree_
instance Datatype D1Expr_
instance Constructor C1_0Expr_
instance Constructor C1_1Expr_
instance Constructor C1_2Expr_
instance Arbitrary a => Arbitrary (List a)


-- | Attribute grammars with regular expression matching.
module Data.Regex.MultiRules

-- | A child records both an actual values and the index it corresponds to.
data Child (c :: k -> *) (attrib :: k -> *)
Child :: c ix -> [attrib ix] -> Child c attrib

-- | Children are just a list of <a>Child</a>s.
type Children c attrib = [Child c attrib]
lookupChild :: EqM c => c ix -> Children c attrib -> [attrib ix]

-- | Actions create new inherited attributes for their children, and
--   synthesized attribute for its own node, from the synthesized
--   attributes of children and the inheritance from its parent.
--   Additionally, actions may include an explicit backtrack.
type Action (c :: k -> *) (f :: (k -> *) -> k -> *) (inh :: k -> *) (syn :: k -> *) (ix :: k) = Fix f ix -> inh ix -> Children c syn -> (Bool, Children c inh, syn ix)

-- | A rule comprises the regular expression to match and the action to
--   execute if successful.
data Rule (c :: k -> *) (f :: (k -> *) -> k -> *) (inh :: k -> *) (syn :: k -> *)
Rule :: Regex c f ix -> Action c f inh syn ix -> Rule c f inh syn

-- | A grammar is simply a list of rules.
type Grammar (c :: k -> *) (f :: (k -> *) -> k -> *) (inh :: k -> *) (syn :: k -> *) = [Rule c f inh syn]

-- | Evaluate an attribute grammar over a certain term.
eval :: Capturable c f => Grammar c f inh syn -> inh ix -> Fix f ix -> syn ix

-- | Converts a rule description into an actual <a>Rule</a>. Its use must
--   follow this pattern:
--   
--   <ul>
--   <li>A block of lambda-bound variables will introduce the capture
--   names,</li>
--   <li>A tree regular expression to match should capture using the
--   previous names,</li>
--   <li>After <a>-&gt;&gt;&gt;</a> or <a>-&gt;&gt;</a>, the state
--   calculation should proceed.</li>
--   </ul>
--   
--   <pre>
--   rule $ \c1 c2 -&gt;
--     regex ... c1 &lt;&lt;- ... c2 &lt;&lt;- ... -&gt;&gt; do
--       at c2 . inh .= ...          -- Set inherited for children
--       c1Syn &lt;- use (at c1 . syn)  -- Get synthesized from children
--       this . syn  .= ...          -- Set upwards synthesized attributes
--   </pre>
rule :: RuleBuilder f inh syn ixs fn => (fn -> IxList (Wrap Integer) ixs -> Rule (Wrap Integer) f inh syn) -> Rule (Wrap Integer) f inh syn

-- | Special case for rules without capture.
rule0 :: (IxList (Wrap Integer) [] -> Rule (Wrap Integer) f inh syn) -> Rule (Wrap Integer) f inh syn

-- | Makes the attribute calculation fail if the condition is false. This
--   function can be used to add extra conditions over whether a certain
--   rule should be applied (a bit like guards).
check :: Bool -> State (ActionState (Wrap Integer) inh syn ix) ()

-- | Separates matching and attribute calculation on a rule. The action
--   should take as extra parameter the node which was matched.
(->>>) :: (IxListMonoid inh ixs, Monoid (syn ix), IxListMonoid syn ixs) => (forall c. Regex' c (Wrap Integer) f ix) -> (Fix f ix -> State (ActionState (Wrap Integer) inh syn ix) ()) -> IxList (Wrap Integer) ixs -> Rule (Wrap Integer) f inh syn

-- | Separates matching and attribute calculation on a rule.
(->>) :: (IxListMonoid inh ixs, Monoid (syn ix), IxListMonoid syn ixs) => (forall c. Regex' c (Wrap Integer) f ix) -> State (ActionState (Wrap Integer) inh syn ix) () -> IxList (Wrap Integer) ixs -> Rule (Wrap Integer) f inh syn

-- | Lens for the attributes of the current node. To be used in composition
--   with <a>inh</a> or <a>syn</a>.
this :: Functor f => (InhAndSyn inh syn ix -> f (InhAndSyn inh syn ix)) -> ActionState c inh syn ix -> f (ActionState c inh syn ix)

-- | Lens the attributes of a child node. To be used in composition with
--   <a>inh</a> or <a>syn</a>.
at :: (EqM c, Functor f) => c xi -> (InhAndSyn inh syn xi -> f (InhAndSyn inh syn xi)) -> ActionState c inh syn ix -> f (ActionState c inh syn ix)

-- | Lens for the inherited attributes of a node. Use only as getter with
--   <a>this</a> and as setter with <a>at</a>.
inh :: Functor f => (inh ix -> f (inh ix)) -> InhAndSyn inh syn ix -> f (InhAndSyn inh syn ix)

-- | Lens the inherited synthesized attributes of a node. Use only as
--   setter with <a>this</a> and as getter with <a>at</a>.
syn :: Functor f => (syn ix -> f (syn ix)) -> InhAndSyn inh syn ix -> f (InhAndSyn inh syn ix)

-- | Utility type which does not distinguish between indices.
newtype IndexIndependent t ix
IndexIndependent :: t -> IndexIndependent t ix

-- | A grammar whose attributes are equal throughout all indices.
type IndexIndependentGrammar c f inh syn = Grammar c f (IndexIndependent inh) (IndexIndependent syn)

-- | Evaluate an index-indendepent grammar.
iieval :: Capturable c f => IndexIndependentGrammar c f inh syn -> inh -> Fix f ix -> syn

-- | Lens for <tt>Indexed</tt> inherited attributes of a node. Use only as
--   getter with <a>this</a> and as setter with <a>at</a>.
inh_ :: Functor f => (inh -> f inh) -> InhAndSyn (IndexIndependent inh) syn ix -> f (InhAndSyn (IndexIndependent inh) syn ix)

-- | Lens the <tt>Indexed</tt> synthesized attributes of a node. Use only
--   as setter with <a>this</a> and as getter with <a>at</a>.
syn_ :: Functor f => (syn -> f syn) -> InhAndSyn inh (IndexIndependent syn) ix -> f (InhAndSyn inh (IndexIndependent syn) ix)

-- | Apply copy rule for inherited attributes.
copy :: EqM c => [c xi] -> State (ActionState c (IndexIndependent inh) syn ix) ()
instance Show t => Show (IndexIndependent t ix)
instance Eq t => Eq (IndexIndependent t ix)
instance Ord t => Ord (IndexIndependent t ix)
instance Monoid t => Monoid (IndexIndependent t ix)
instance RuleBuilder f inh syn '[ix1, ix2, ix3, ix4, ix5] (Wrap Integer ix1, Wrap Integer ix2, Wrap Integer ix3, Wrap Integer ix4, Wrap Integer ix5)
instance RuleBuilder f inh syn '[ix1, ix2, ix3, ix4] (Wrap Integer ix1, Wrap Integer ix2, Wrap Integer ix3, Wrap Integer ix4)
instance RuleBuilder f inh syn '[ix1, ix2, ix3] (Wrap Integer ix1, Wrap Integer ix2, Wrap Integer ix3)
instance RuleBuilder f inh syn '[ix1, ix2] (Wrap Integer ix1, Wrap Integer ix2)
instance RuleBuilder f inh syn '[ix1] (Wrap Integer ix1)


-- | Example of tree regular expressions over a family of regular data
--   types. Click on <tt>Source</tt> to view the code.
module Data.Regex.Example.Multi
data Ty
One :: Ty
Two :: Ty
data Bis f ix
NilOne' :: Bis f One
ConsOne' :: Int -> f Two -> Bis f One
NilTwo' :: Bis f Two
ConsTwo' :: Char -> f One -> Bis f Two
type FixOne = Fix Bis One
type FixTwo = Fix Bis Two
aBis1 :: FixOne
aBis2 :: FixOne
rBis1 :: Regex (Wrap Char) Bis One
rBis2 :: Regex c Bis One
rBis3 :: Regex c Bis One
rBis4 :: Regex c Bis One
rBis5 :: Regex c Bis One
cBis1 :: Wrap Integer One -> Regex (Wrap Integer) Bis One
eBis1 :: FixOne -> [FixOne]
eBis2 :: FixOne -> [FixOne]
grammar1 :: IndexIndependentGrammar (Wrap Integer) Bis () String
instance Eq (Sing a)
instance Generic1m Bis
instance Show (Fix Bis 'Two)
instance Show (Fix Bis 'One)
instance ShowM (Fix Bis)
instance ArbitraryM (Fix Bis)
instance SingI 'Two
instance SingI 'One
