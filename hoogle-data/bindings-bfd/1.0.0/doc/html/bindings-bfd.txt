-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings for libbfd, a library of the GNU `binutils'
--   
--   These are bindings for <a>libbfd</a>, a library of the GNU
--   <a>binutils</a> package. The bindings let a Haskell program query the
--   structure of any executable, object, or library file format supported
--   by the GNU Project (alot). It also has support for disassembly of code
--   in these files where available.
@package bindings-bfd
@version 1.0.0

module Bindings.Bfd.Symbol.Flags
data Flags
Local :: Flags
Global :: Flags
Debugging :: Flags
Function :: Flags
Undefined :: Flags
Keep :: Flags
KeepG :: Flags
Weak :: Flags
SectionSym :: Flags
OldCommon :: Flags
NotAtEnd :: Flags
Constructor :: Flags
Warning :: Flags
Indirect :: Flags
File :: Flags
Dynamic :: Flags
Object :: Flags
DebuggingReloc :: Flags
ThreadLocal :: Flags
Relc :: Flags
Srelc :: Flags
Synthetic :: Flags
GnuIndirectFunction :: Flags
instance Enum Flags
instance Eq Flags
instance Show Flags

module Bindings.Bfd.Section.Flags
data Flags
NoFlags :: Flags
Alloc :: Flags
Load :: Flags
Reloc :: Flags
Readonly :: Flags
Code :: Flags
Data :: Flags
Rom :: Flags
Constructor :: Flags
HasContents :: Flags
NeverLoad :: Flags
ThreadLocal :: Flags
HasGotRef :: Flags
IsCommon :: Flags
Debugging :: Flags
InMemory :: Flags
Exclude :: Flags
SortEntries :: Flags
LinkOnce :: Flags
LinkDuplicates :: Flags
LinkDuplicatesDiscard :: Flags
LinkDuplicatesOneOnly :: Flags
LinkDuplicatesSameSize :: Flags
LinkerCreated :: Flags
Keep :: Flags
SmallData :: Flags
Merge :: Flags
Strings :: Flags
Group :: Flags
CoffSharedLibrary :: Flags
CoffShared :: Flags
Tic54xBlock :: Flags
Tic54xClink :: Flags
instance Enum Flags
instance Eq Flags
instance Show Flags

module Bindings.Bfd.LinkInfo
type LinkInfo = Ptr LinkInfo'
data LinkInfo'
LinkInfo' :: LinkInfo'

module Bindings.Bfd.Flavour
data Flavour
Unknown :: Flavour
Aout :: Flavour
Coff :: Flavour
Ecoff :: Flavour
Xcoff :: Flavour
Elf :: Flavour
Ieee :: Flavour
Nlm :: Flavour
Oasys :: Flavour
Tekhex :: Flavour
Srec :: Flavour
Verilog :: Flavour
Ihex :: Flavour
Som :: Flavour
Os9k :: Flavour
Versados :: Flavour
Msdos :: Flavour
Ovax :: Flavour
Evax :: Flavour
Mmo :: Flavour
MachO :: Flavour
Pef :: Flavour
PefXlib :: Flavour
Sym :: Flavour
instance Enum Flavour
instance Eq Flavour
instance Show Flavour

module Bindings.Bfd.Endian
data Endian
Big :: Endian
Little :: Endian
Unknown :: Endian
instance Enum Endian
instance Eq Endian
instance Show Endian

module Bindings.Bfd.Disasm.I386.Precision
data Precision
Single :: Precision
Double :: Precision
instance Show Precision

module Bindings.Bfd.Disasm.I386.XmmType
data XmmType
Int :: Int -> XmmType
width :: XmmType -> Int
FloatingPt :: Precision -> XmmType
precision :: XmmType -> Precision
instance Show XmmType

module Bindings.Bfd.Disasm.I386.Order
data Order
Low :: Order
High :: Order
instance Show Order

module Bindings.Bfd.Disasm.I386.Lex
data Token
Offset :: Int -> Token
Constant :: Int -> Token
Address :: Int -> Token
PrefixedMnemonic :: [String] -> Token
Register :: String -> Token
Mnemonic :: String -> Token
ParensL :: Token
ParensR :: Token
Comma :: Token
Colon :: Token
Hash :: Token
Star :: Token
lexer :: String -> [Token]
instance Eq Token
instance Show Token

module Bindings.Bfd.Disasm.I386.EffectiveAddr
data EffectiveAddr
EA :: String -> String -> Int -> EffectiveAddr
base :: EffectiveAddr -> String
index :: EffectiveAddr -> String
scale :: EffectiveAddr -> Int
NoEA :: EffectiveAddr
instance Eq EffectiveAddr
instance Ord EffectiveAddr
instance Show EffectiveAddr

module Bindings.Bfd.Disasm.I386.CondCode
data CondCode
Above :: CondCode
AboveOrEqual :: CondCode
Below :: CondCode
BelowOrEqual :: CondCode
Equal :: CondCode
Greater :: CondCode
GreaterOrEqual :: CondCode
Less :: CondCode
LessOrEqual :: CondCode
NotEqual :: CondCode
NotSigned :: CondCode
Parity :: CondCode
Signed :: CondCode
Zero :: CondCode
toCondCode :: String -> Maybe CondCode
instance Show CondCode

module Bindings.Bfd.Disasm.I386.Mnemonic
data Mnemonic
Add :: Int -> Mnemonic
width1 :: Mnemonic -> Int
AddCarry :: Int -> Mnemonic
width1 :: Mnemonic -> Int
AddScalar :: Precision -> Mnemonic
precision :: Mnemonic -> Precision
BitwiseAnd :: Int -> Mnemonic
width1 :: Mnemonic -> Int
BitwiseExclOr :: XmmType -> Mnemonic
xmmType :: Mnemonic -> XmmType
BitwiseNot :: Int -> Mnemonic
width1 :: Mnemonic -> Int
BitwiseOr :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Branch :: CondCode -> Mnemonic
condCode :: Mnemonic -> CondCode
Call :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Compare :: Int -> Mnemonic
width1 :: Mnemonic -> Int
CompareExchange :: Int -> Mnemonic
width1 :: Mnemonic -> Int
CompareString :: Int -> Mnemonic
width1 :: Mnemonic -> Int
CompareUnordered :: Precision -> Mnemonic
precision :: Mnemonic -> Precision
Convert :: Int -> Int -> Bool -> Mnemonic
width1 :: Mnemonic -> Int
width2 :: Mnemonic -> Int
isSplit :: Mnemonic -> Bool
ConvertXmm :: Int -> XmmType -> XmmType -> Bool -> Mnemonic
numElems :: Mnemonic -> Int
sourceXmmType :: Mnemonic -> XmmType
targetXmmType :: Mnemonic -> XmmType
isTruncate :: Mnemonic -> Bool
Cpuid :: Mnemonic
Decrement :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Direction :: Bool -> Mnemonic
isSet :: Mnemonic -> Bool
Divide :: Int -> Mnemonic
width1 :: Mnemonic -> Int
DivideInt :: Int -> Mnemonic
width1 :: Mnemonic -> Int
DivideScalar :: Precision -> Mnemonic
precision :: Mnemonic -> Precision
Exchange :: Int -> Mnemonic
width1 :: Mnemonic -> Int
ExchangeAdd :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Increment :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Jump :: Maybe Int -> Mnemonic
mbWidth :: Mnemonic -> Maybe Int
Leave :: Int -> Mnemonic
width1 :: Mnemonic -> Int
LoadEffAddr :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Loop :: Mnemonic
Move :: Int -> Maybe (Int, Bool) -> Mnemonic
width1 :: Mnemonic -> Int
mbWidthSignExtend :: Mnemonic -> Maybe (Int, Bool)
MoveAligned :: Precision -> Mnemonic
precision :: Mnemonic -> Precision
MoveCond :: Int -> CondCode -> Mnemonic
width1 :: Mnemonic -> Int
condCode :: Mnemonic -> CondCode
MoveNonTemp :: Either Int XmmType -> Mnemonic
xmmType2 :: Mnemonic -> Either Int XmmType
MovePacked :: Precision -> Bool -> Bool -> Mnemonic
precision :: Mnemonic -> Precision
isHigh1 :: Mnemonic -> Bool
isHigh2 :: Mnemonic -> Bool
MoveScalar :: Precision -> Mnemonic
precision :: Mnemonic -> Precision
MoveString :: Int -> Mnemonic
width1 :: Mnemonic -> Int
MoveUnaligned :: Precision -> Mnemonic
precision :: Mnemonic -> Precision
Multiply :: Int -> Mnemonic
width1 :: Mnemonic -> Int
MultiplyInt :: Int -> Mnemonic
width1 :: Mnemonic -> Int
MultiplyScalar :: XmmType -> Mnemonic
xmmType :: Mnemonic -> XmmType
Negate :: Int -> Mnemonic
width1 :: Mnemonic -> Int
NoOp :: Mnemonic
Pop :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Push :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Return :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Rotate :: Int -> Bool -> Mnemonic
width1 :: Mnemonic -> Int
isRight :: Mnemonic -> Bool
Set :: CondCode -> Mnemonic
condCode :: Mnemonic -> CondCode
Shift :: Int -> Bool -> Bool -> Mnemonic
width1 :: Mnemonic -> Int
isRight :: Mnemonic -> Bool
isArith :: Mnemonic -> Bool
StoreString :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Subtract :: Int -> Mnemonic
width1 :: Mnemonic -> Int
SubtractBorrow :: Int -> Mnemonic
width1 :: Mnemonic -> Int
SubtractScalar :: Precision -> Mnemonic
precision :: Mnemonic -> Precision
Test :: Int -> Mnemonic
width1 :: Mnemonic -> Int
Unpack :: Order -> Precision -> Mnemonic
order :: Mnemonic -> Order
precision :: Mnemonic -> Precision
toMnemonic :: String -> Mnemonic
isCall :: Mnemonic -> Bool
isJump :: Mnemonic -> Bool
isBranch :: Mnemonic -> Bool
isReturn :: Mnemonic -> Bool
instance Show Mnemonic

module Bindings.Bfd.Disasm.I386.Prefix
data Prefix
Lock :: Prefix
Repeat :: Maybe CondCode -> Prefix
condCode :: Prefix -> Maybe CondCode
toPrefix :: String -> Maybe Prefix
instance Show Prefix

module Bindings.Bfd.Misc
type Bool' = CUInt
type Vma = Int
type Vma' = CULong
type Size = Int
type Size' = CULong
type File = Ptr File'
data File'
File' :: File'
type FilePtr = Int
type FilePtr' = CULong
alignToPower :: Vma -> Int -> Vma
c_fdopen :: CInt -> CString -> IO File
c_fflush :: File -> IO CInt

module Bindings.Bfd.LinkOrder
type LinkOrder = Ptr LinkOrder'
data LinkOrder'
Section :: Section -> LinkOrder'
unLinkOrder'Section :: LinkOrder' -> Section
mk :: Section -> IO LinkOrder
setSection :: LinkOrder -> Section -> IO ()
instance Storable LinkOrder'

module Bindings.Bfd.Disasm.Info
type FPrintfFn = FunPtr (File -> CString -> IO CInt)
data Info
Info :: Info0 -> Fd -> Info
type Info0 = Ptr Info'
data Info'
Machine :: Info'
mk :: IO Info
setMachine :: Info -> Int -> IO ()
setBuffer :: Info -> String -> Vma -> IO ()
setOptions :: Info -> String -> IO ()
c_init_disassemble_info :: Info0 -> File -> FPrintfFn -> IO ()
c_bfd_disassembler_info_fprintf :: FPrintfFn
c_bfd_disassembler_info_print_address :: FunPtr (Vma' -> Info0 -> IO ())
instance Eq Info
instance Show Info
instance Storable Info'


-- | Describes the underlying format of the file that the <tt>Bfd</tt>
--   represents.
module Bindings.Bfd.Format
data Format

-- | File format is unknown
Unknown :: Format

-- | Linker/assembler/compiler output
Object :: Format

-- | Object archive file
Archive :: Format

-- | Core dump
Core :: Format
instance Enum Format
instance Eq Format
instance Show Format

module Bindings.Bfd.Flags
data Flags
HasReloc :: Flags
ExecP :: Flags
HasLineNo :: Flags
HasDebug :: Flags
HasSyms :: Flags
HasLocals :: Flags
Dynamic :: Flags
WpText :: Flags
DPaged :: Flags
IsRelaxable :: Flags
TraditionalFormat :: Flags
InMemory :: Flags
HasLoadPage :: Flags
LinkerCreated :: Flags
DeterministicOutput :: Flags
instance Enum Flags
instance Show Flags

module Bindings.Bfd.Exception
type FunctionName = String
type FormatName = String
type ErrorMsg = String
data BfdException
NoError :: FunctionName -> FilePath -> TargetName -> BfdException
SystemCall :: FunctionName -> FilePath -> TargetName -> ErrorMsg -> BfdException
InvalidTarget :: FunctionName -> FilePath -> TargetName -> BfdException
WrongFormat :: BfdException
WrongObjectFormat :: BfdException
InvalidOperation :: String -> String -> String -> BfdException
NoMemory :: BfdException
NoSymbols :: BfdException
NoArmap :: BfdException
NoMoreArchivedFiles :: BfdException
MalformedArchive :: BfdException
FileNotRecognized :: FunctionName -> FormatName -> BfdException
FileAmbiguouslyRecognized :: BfdException
NoContents :: BfdException
NonrepresentableSection :: BfdException
NoDebugSection :: BfdException
BadValue :: BfdException
FileTruncated :: BfdException
FileTooBig :: BfdException
OnInput :: BfdException
InvalidErrorCode :: BfdException
throwExceptionIfNull :: FunctionName -> FilePath -> TargetName -> IO (Ptr a) -> IO (Ptr a)
throwExceptionIfFalse :: FunctionName -> FormatName -> IO Bool -> IO Bool
throwException :: String -> String -> String -> IO a
c_bfd_get_error :: IO CInt
c_bfd_errmsg :: CInt -> CString
instance Typeable BfdException
instance Exception BfdException
instance Show BfdException

module Bindings.Bfd.Disasm
type Disasm = FunPtr Disasm'
type Disasm' = Vma' -> Info0 -> IO CInt
run :: Integral a => Disasm -> Info -> a -> IO (String, Int)
d_run :: Disasm -> Disasm'


-- | The <a>Target</a> represents a particular back-end used to interpret
--   the <a>Bfd</a>.
module Bindings.Bfd.Target
type Target = Ptr Target'
type TargetName = String

-- | Return a list of target names that can possibly be interpreted by this
--   particular platform.
listSupported :: IO [TargetName]

-- | Set the default target name for use with <tt>open</tt> etc. when
--   <a>TargetName</a> is equal to "default" or empty. Returns <a>True</a>
--   if successful.
--   
--   <i>Possible exceptions:</i> <a>InvalidTarget</a>
setDefault :: TargetName -> IO Bool
getByteorder :: Target -> IO Endian
getHeaderByteorder :: Target -> IO Endian
getObjectFlags :: Target -> IO [Flags]
getSectionFlags :: Target -> IO [Flags]
getFlavour :: Target -> IO Flavour
getName :: Target -> IO TargetName
getSymtabUpperBound :: Target -> Bfd -> IO Int
canonicalizeSymtab :: Target -> Bfd -> Ptr Symbol -> IO Int
getDynamicSymtabUpperBound :: Target -> Bfd -> IO Int
canonicalizeDynamicSymtab :: Target -> Bfd -> Ptr Symbol -> IO Int
getSyntheticSymtab :: Target -> Bfd -> SymbolTable -> SymbolTable -> Ptr Symbol -> IO Int
getDynamicRelocUpperBound :: Target -> Bfd -> IO Int
canonicalizeDynamicReloc :: Target -> Bfd -> Ptr (Ptr Relocation) -> Ptr Symbol -> IO Int

-- | Returns <a>True</a> if the <a>Target</a>s byte order (see
--   <a>getByteorder</a>) is <a>Big</a>. Otherwise <a>False</a>.
isBigEndian :: Target -> IO Bool

-- | Returns <a>True</a> if the <a>Target</a>s byte order (see
--   <a>getByteorder</a>) is <a>Little</a>. Otherwise <a>False</a>.
isLittleEndian :: Target -> IO Bool

-- | Returns <a>True</a> if the <a>Target</a>s header byte order (see
--   <tt>getHeaderByteOrder</tt>) is <a>Big</a>. Otherwise <a>False</a>.
isHeaderBigEndian :: Target -> IO Bool

-- | Returns <a>True</a> if the <a>Target</a>s header byte order (see
--   <tt>getHeaderByteOrder</tt>) is <a>Little</a>. Otherwise <a>False</a>.
isHeaderLittleEndian :: Target -> IO Bool

-- | Returns <a>True</a> if the <a>Flavour</a> of the <a>Target</a> is
--   either <a>Coff</a> or <a>Xcoff</a>. Otherwise <a>False</a>.
isCoffFamily :: Target -> IO Bool
getPrintSymbol :: Target -> Bfd -> File -> Symbol -> IO (IO ())
data Target'
instance Show Target'
instance Storable Target'

module Bindings.Bfd.Symbol
type Symbol = Ptr Symbol'
type SymbolName = String

-- | Returns the <a>Vma</a> of the <a>Section</a> that the symbol belongs
--   to.
getBase :: Symbol -> IO Vma

-- | Set the offset of the <a>Symbol</a> within its <a>Section</a>.
setValue :: Symbol -> Vma -> IO ()

-- | Returns the offset of the <a>Symbol</a> within its <a>Section</a>.
getValue :: Symbol -> IO Vma

-- | Returns the absolute <a>Vma</a> of the <a>Symbol</a> (that is, its
--   <a>getBase</a> + <a>getValue</a>.
getValue' :: Symbol -> IO Vma

-- | Returns the <a>Bfd</a> that the <a>Symbol</a> belongs to.
--   
--   <i>Note:</i> If the returned <a>Bfd</a> should not be passed to
--   <tt>close</tt> or <tt>closeAllDone</tt> there will be memory leaks.
getBfd :: Symbol -> IO Bfd
getFlags :: Symbol -> IO [Flags]

-- | If the <a>Symbol</a> has the <a>Synthetic</a> flag set then return
--   <a>Unknown</a>, otherwise returns <a>getFlavour</a> on the
--   <a>Symbol</a>s 'Bfd'\'s <a>Target</a>.
getFlavour :: Symbol -> IO Flavour

-- | Sets the <a>SymbolName</a> of the <a>Symbol</a>.
--   
--   <i>Note:</i> The memory allocated to the <a>SymbolName</a> is never
--   freed.
setName :: Symbol -> SymbolName -> IO ()

-- | Returns the <a>SymbolName</a> of the <a>Symbol</a>.
getName :: Symbol -> IO SymbolName

-- | Sets the <a>Symbol</a>s <a>Section</a>.
setSection :: Symbol -> Section -> IO ()

-- | Returns the <a>Symbol</a>s <a>Section</a>.
getSection :: Symbol -> IO Section

-- | Returns the <a>Symbol</a>s output <a>Section</a>.
getOutputSection :: Symbol -> IO Section
getSize :: Symbol -> Bfd -> IO Int
print :: Symbol -> Bfd -> IO String
data Symbol'
instance Show Symbol'
instance Storable Symbol'

module Bindings.Bfd.Relocation
data Relocation
Relocation :: Ptr Symbol -> Int -> Int -> Relocation
ptrSymbol :: Relocation -> Ptr Symbol
address :: Relocation -> Int
addend :: Relocation -> Int
getSymbol :: Relocation -> IO Symbol
instance Show Relocation
instance Storable Relocation

module Bindings.Bfd.Disasm.I386.Address
type Address = Either Int Symbol
isSymbolic :: Address -> Bool

module Bindings.Bfd.Disasm.I386.Operand
data Operand
Abs :: Address -> Operand
address :: Operand -> Address
DirD :: String -> Operand
direct :: Operand -> String
DirJ :: String -> Operand
direct :: Operand -> String
Imm :: Int -> Operand
immed :: Operand -> Int
IndD :: String -> EffectiveAddr -> Maybe Int -> Maybe Address -> Operand
section :: Operand -> String
effAddr :: Operand -> EffectiveAddr
displacement :: Operand -> Maybe Int
mbAddress :: Operand -> Maybe Address
IndJ :: EffectiveAddr -> Maybe Int -> Maybe Address -> Operand
effAddr :: Operand -> EffectiveAddr
displacement :: Operand -> Maybe Int
mbAddress :: Operand -> Maybe Address
Length :: Int -> Operand
len :: Operand -> Int
isAbs :: Operand -> Bool
isIndJ :: Operand -> Bool
isDirJ :: Operand -> Bool
instance Eq Operand
instance Ord Operand
instance Show Operand

module Bindings.Bfd.Disasm.I386.Insn
data Insn
Insn :: Maybe Prefix -> Mnemonic -> [Operand] -> Insn
prefix :: Insn -> Maybe Prefix
mnemonic :: Insn -> Mnemonic
operands :: Insn -> [Operand]
Extern :: String -> Insn
symbol :: Insn -> String
instance Show Insn

module Bindings.Bfd.SymbolTable
data SymbolTable
SymbolTable :: Ptr Symbol -> Int -> SymbolTable
tablePtr :: SymbolTable -> Ptr Symbol
tableSize :: SymbolTable -> Int
mk :: Ptr Symbol -> Int -> SymbolTable
toList :: SymbolTable -> IO [Symbol]
uniqifyNames :: SymbolTable -> IO SymbolTable
resolveExterns :: SymbolTable -> Bfd -> IO (SymbolTable, Section, IntMap Insn)
externSpacing :: Int
instance Show SymbolTable

module Bindings.Bfd.Section
type Section = Ptr Section'
type SectionName = String
mk :: SectionName -> Int -> IO Section
getContents :: Section -> Bfd -> FilePtr -> Size -> IO Contents

-- | Returns a list of the <a>Section</a>s <a>Flags</a>.
getFlags :: Section -> IO [Flags]
setName :: Section -> SectionName -> IO ()

-- | Returns the <a>SectionName</a>.
getName :: Section -> IO SectionName
getNext :: Section -> IO Section

-- | Return the <a>Size</a> of the <a>Section</a>.
getSize :: Section -> IO Size
getRawsize :: Section -> IO Size

-- | If the raw size (see <tt>getRawSize</tt>) is not zero then return the
--   raw size. Otherwise return the division of the size (see
--   <a>getSize</a>) by the octets per byte (see <a>getOctetsPerByte</a>).
getLimit :: Section -> Bfd -> IO Int
getOutputSection :: Section -> IO Section
setOutputSection :: Section -> Section -> IO ()
getRelocatedContents :: Section -> Bfd -> SymbolTable -> IO Contents
getRelocations :: Section -> Bfd -> SymbolTable -> IO [Relocation]
getSymbol :: Section -> IO Symbol

-- | Sets both the VMA and LMA of the <a>Section</a> to the given
--   <a>Vma</a> and sets the <a>Section</a>s <i>user_set_vma</i> flag to
--   <a>True</a>.
setVma :: Section -> Vma -> IO ()

-- | Returns the <a>Vma</a> of the <a>Section</a>.
getVma :: Section -> IO Vma

-- | Returns the LMA of the <a>Section</a>.
getLma :: Section -> IO Vma

-- | Sets the alignment power of the <a>Section</a>.
setAlignment :: Section -> Int -> IO ()

-- | Returns the alignment power of the <a>Section</a>.
getAlignment :: Section -> IO Int
isAbsolute :: Section -> Bool

-- | Return <a>True</a> if <a>IsCommon</a> is found in the <a>Section</a>s
--   <a>Flags</a>.
isCommon :: Section -> IO Bool
isExterns :: Section -> IO Bool
externsName :: String
isUndefined :: Section -> Bool
data Section'
instance Show Section'
instance Storable Section'

module Bindings.Bfd.Disasm.I386.Term
data Term
Add :: Term -> Term -> Term
BitAnd :: Term -> Term -> Term
BitExclOr :: Term -> Term -> Term
BitOr :: Term -> Term -> Term
BitTest :: Term -> Term -> Term
GreaterOrEqual :: Term -> Term -> Term
Subtract :: Term -> Term -> Term
If :: Term -> Term -> Term -> Term
Flag :: Char -> Term -> Term
Opr :: Int -> Operand -> Term
Stk :: Int -> Int -> Term
Reg :: String -> Term
Flg :: Char -> Term
Con :: Int -> Term
Udf :: Term
Nul :: Term
Todo :: Term
type Assign = (Term, Term)
instance Show Term

module Bindings.Bfd.Disasm.I386.Parse
newtype HappyAbsSyn
HappyAbsSyn :: HappyAny -> HappyAbsSyn
type HappyAny = Any
happyIn4 :: (Insn) -> (HappyAbsSyn)
happyOut4 :: (HappyAbsSyn) -> (Insn)
happyIn5 :: ([Operand]) -> (HappyAbsSyn)
happyOut5 :: (HappyAbsSyn) -> ([Operand])
happyIn6 :: (Maybe Address) -> (HappyAbsSyn)
happyOut6 :: (HappyAbsSyn) -> (Maybe Address)
happyIn7 :: (Operand) -> (HappyAbsSyn)
happyOut7 :: (HappyAbsSyn) -> (Operand)
happyIn8 :: (Operand) -> (HappyAbsSyn)
happyOut8 :: (HappyAbsSyn) -> (Operand)
happyIn9 :: (Operand) -> (HappyAbsSyn)
happyOut9 :: (HappyAbsSyn) -> (Operand)
happyIn10 :: (Operand) -> (HappyAbsSyn)
happyOut10 :: (HappyAbsSyn) -> (Operand)
happyIn11 :: (Operand) -> (HappyAbsSyn)
happyOut11 :: (HappyAbsSyn) -> (Operand)
happyIn12 :: (Operand) -> (HappyAbsSyn)
happyOut12 :: (HappyAbsSyn) -> (Operand)
happyIn13 :: ((EffectiveAddr, Maybe Int)) -> (HappyAbsSyn)
happyOut13 :: (HappyAbsSyn) -> ((EffectiveAddr, Maybe Int))
happyIn14 :: (EffectiveAddr) -> (HappyAbsSyn)
happyOut14 :: (HappyAbsSyn) -> (EffectiveAddr)
happyInTok :: (Token) -> (HappyAbsSyn)
happyOutTok :: (HappyAbsSyn) -> (Token)
happyActOffsets :: HappyAddr
happyGotoOffsets :: HappyAddr
happyDefActions :: HappyAddr
happyCheck :: HappyAddr
happyTable :: HappyAddr
newtype HappyIdentity a
HappyIdentity :: a -> HappyIdentity a
happyThen :: HappyIdentity a -> (a -> HappyIdentity b) -> HappyIdentity b
happyReturn :: a -> HappyIdentity a
happyReturn1 :: a -> b -> HappyIdentity a
happyError' :: [(Token)] -> HappyIdentity a
happyError :: [Token] -> a
data Happy_IntList
HappyCons :: Int# -> Happy_IntList -> Happy_IntList
data HappyStk a
HappyStk :: a -> (HappyStk a) -> HappyStk a
data HappyAddr
HappyA# :: Addr# -> HappyAddr
notHappyAtAll :: a
happyTcHack :: Int# -> a -> a
happyDontSeq :: a -> b -> b
happyDoSeq :: a -> b -> b
instance Monad HappyIdentity


-- | This is the top-level module containing operations that can be
--   performed on a Binary Format Descriptor (BFD). A BFD is opened on the
--   binary file to be queried/manipulated and serves an opaque pointer.
module Bindings.Bfd

-- | The opaque pointer to the Binary File Descriptor.
data Bfd

-- | Initialize the library. You need to call <a>initialize</a> once,
--   before using any of the functions in this library.
initialize :: IO ()

-- | Returns a list of tuples representing the possible combinations of
--   <a>TargetName</a> and <a>Format</a> that are valid for this file on
--   this platform.
--   
--   <i>Possible Exceptions:</i> Same as <a>open</a>.
targetsAndFormats :: FilePath -> IO [(TargetName, Format)]

-- | Opens the file <a>FilePath</a> with the given target <a>TargetName</a>
--   and open mode (as defined by the Unix fopen(3) function) and returns a
--   <a>Bfd</a> object on success. FIXME: and marks it cacheable.
--   
--   If the target is <a>Nothing</a> then the environment variable
--   <i>GNUTARGET</i> is checked for a target name; if this is NULL or not
--   defined then it chooses the the default target if set (see
--   <tt>setDefault</tt>) and sets an internal flag in the <a>Bfd</a>
--   object indicating that the target was defaulted (see
--   <tt>isTargetDefaulted</tt>), or if not set, the first entry in the
--   target list for the platform. Passing the string "default" as the
--   <a>TargetName</a> or setting the environment variable to "default"
--   also causes the above behavior.
--   
--   <i>Important:</i> Before you use the returned <a>Bfd</a> object from a
--   file you have opened, you must call <a>checkFormat</a> to 1) validate
--   that the supplied <a>TargetName</a> is appropriate for the opened
--   file, and 2) set the <a>Format</a> for the <a>Bfd</a>. So for most
--   intents and purposes, opening a file is a two-step process.
--   
--   <i>Possible Exceptions:</i> <tt>NoMemory</tt> (if any allocation
--   fails), <tt>SystemCall</tt> (if open failed), and
--   <tt>InvalidTarget</tt> (if supplied target is unknown).
open :: FilePath -> Maybe TargetName -> String -> IO Bfd

-- | Close a <a>Bfd</a> and if all went well, return <a>True</a>. If the
--   <a>Bfd</a> was open for writing, then pending operations are completed
--   and the file written out and closed. If the created file is
--   executable, then chmod(3) is called to mark it as such.
close :: Bfd -> IO Bool

-- | Close a <a>Bfd</a> and if all went well, return <a>True</a>. Differs
--   from <a>close</a> in that it does not complete any pending operations.
--   This function would be used if the application had just used a
--   <a>Bfd</a> for swapping and didn't want to use any of the writing
--   code. If the created file is executable, then chmod(3) is called to
--   mark it as such.
closeAllDone :: Bfd -> IO Bool

-- | The second part of opening a file (see <a>open</a>). Validates that
--   the <a>TargetName</a> is appropriate for the opened file and if not,
--   silently picks a more suitable <a>TargetName</a>, and also sets the
--   <a>Format</a> of the <a>Bfd</a> object representing the opened file.
--   
--   <i>Important:</i> You must call this function before using the vast
--   majority of these functions operating on the <a>Bfd</a> as it updates
--   critical data structures.
--   
--   <i>Possible Exceptions:</i> <tt>InvalidOperation</tt> (if the file was
--   opened write-only),
checkFormat :: Bfd -> Format -> IO Bool

-- | Returns the disassembler associated with the <a>Bfd</a>.
getDisasm :: Bfd -> IO Disasm

-- | Returns the <a>FilePath</a> of the file associated with the
--   <a>Bfd</a>.
getFilename :: Bfd -> IO FilePath

-- | Returns a <tt>List</tt> of the <a>Bfd</a>s set <a>Flags</a>.
getFlags :: Bfd -> IO [Flags]

-- | Returns the <a>Format</a> of the <a>Bfd</a>.
getFormat :: Bfd -> IO Format

-- | Returns <a>True</a> if the <a>Bfd</a> has an archive map. Otherwise
--   <a>False</a>.
getHasMap :: Bfd -> IO Bool

-- | Returns <a>True</a> if the <a>Bfd</a> is cacheable. Otherwise
--   <a>False</a>.
getIsCacheable :: Bfd -> IO Bool
getIsTargetDefaulted :: Bfd -> IO Bool

-- | Returns <a>True</a> if the <a>Bfd</a> is a thin archive. Otherwise
--   <a>False</a>.
getIsThinArchive :: Bfd -> IO Bool
getMachine :: Bfd -> IO Int

-- | Returns either a <a>Bfd</a> or <a>Nothing</a>. FIXME
--   
--   <i>Note:</i> Do not pass the returned <a>Bfd</a> to <a>close</a> or
--   <a>closeAllDone</a> or a memory leak will occur.
getMyArchive :: Bfd -> IO (Maybe Bfd)
getOctetsPerByte :: Bfd -> IO Int

-- | Returns the <a>Target</a> of the <a>Bfd</a>.
getTarget :: Bfd -> IO Target

-- | Return the start address. Only valid for <a>Object</a> files.
getStartAddress :: Bfd -> IO Vma

-- | Return the symbol count used for input and output. Only valid for
--   <a>Object</a> files. FIXME: returns 0 when there are symbols and in
--   main/main too!
getSymbolCount :: Bfd -> IO Int

-- | Returns the number of <a>Section</a>s in the <a>Bfd</a>.
getSectionCount :: Bfd -> IO Int
getSectionByName :: Bfd -> SectionName -> IO Section
getSectionByVma :: Bfd -> Int -> IO (Maybe Section)
getSections :: Bfd -> IO [Section]
getSymbolTable :: Bfd -> IO SymbolTable
getDynamicSymbolTable :: Bfd -> IO SymbolTable
getDynamicRelocations :: Bfd -> SymbolTable -> IO [Relocation]
demangle :: Bfd -> String -> IO String
data Bfd'
mk :: Ptr Bfd' -> Bfd
instance Show Bfd'
instance Show Bfd
instance Storable Bfd'
