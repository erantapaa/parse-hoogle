-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library for histograms creation.
--   
--   This is library for histograms filling. Its aim to provide convenient
--   way to create and fill histograms.
@package histogram-fill
@version 0.8.4.1


-- | Type classes for binning algorithms. This is mapping from set of
--   interest to integer indices and approximate reverse.
module Data.Histogram.Bin.Classes

-- | This type represent some abstract data binning algorithms. It maps
--   sets/intervals of values of type 'BinValue b' to integer indices.
--   
--   Following invariant is expected to hold:
--   
--   <pre>
--   toIndex . fromIndex == id
--   </pre>
class Bin b where type family BinValue b inRange b x = i >= 0 && i < nBins b where i = toIndex b x
toIndex :: Bin b => b -> BinValue b -> Int
fromIndex :: Bin b => b -> Int -> BinValue b
nBins :: Bin b => b -> Int
inRange :: Bin b => b -> BinValue b -> Bool

-- | Return vector of bin centers
binsCenters :: (Bin b, Vector v (BinValue b)) => b -> v (BinValue b)

-- | Approximate equality for bins. It's nessesary to define approximate
--   equality since exact equality is ill defined for bins which work with
--   floating point data. It's not safe to compare floating point numbers
--   for exact equality
class Bin b => BinEq b
binEq :: BinEq b => b -> b -> Bool

-- | For binning algorithms which work with bin values which have some
--   natural ordering and every bin is continous interval.
class (Bin b, Ord (BinValue b)) => IntervalBin b where binsList b = generate (nBins b) (binInterval b)
binInterval :: IntervalBin b => b -> Int -> (BinValue b, BinValue b)
binsList :: (IntervalBin b, Vector v (BinValue b, BinValue b)) => b -> v (BinValue b, BinValue b)

-- | <a>IntervalBin</a> which domain is single finite interval
class IntervalBin b => Bin1D b
lowerLimit :: Bin1D b => b -> BinValue b
upperLimit :: Bin1D b => b -> BinValue b

-- | Binning algorithm which support slicing.
class Bin b => SliceableBin b
unsafeSliceBin :: SliceableBin b => Int -> Int -> b -> b

-- | Slice bin using indices
sliceBin :: SliceableBin b => Int -> Int -> b -> b

-- | Bin which support rebinning.
class Bin b => MergeableBin b
unsafeMergeBins :: MergeableBin b => CutDirection -> Int -> b -> b

-- | How index should be dropped
data CutDirection

-- | Drop bins with smallest index
CutLower :: CutDirection

-- | Drop bins with bigger index
CutHigher :: CutDirection

-- | <tt>N</tt> consecutive bins are joined into single bin. If number of
--   bins isn't multiple of <tt>N</tt> remaining bins with highest or
--   lowest index are dropped. If <tt>N</tt> is larger than number of bins
--   all bins are merged into single one.
mergeBins :: MergeableBin b => CutDirection -> Int -> b -> b

-- | 1D binning algorithms with variable bin size
class Bin b => VariableBin b
binSizeN :: VariableBin b => b -> Int -> BinValue b

-- | 1D binning algorithms with constant size bins. Constant sized bins
--   could be thought as specialization of variable-sized bins therefore a
--   superclass constraint.
class VariableBin b => UniformBin b where binSize b = binSizeN b 0
binSize :: UniformBin b => b -> BinValue b

-- | Class for conversion between binning algorithms.
class (Bin b, Bin b') => ConvertBin b b'
convertBin :: ConvertBin b b' => b -> b'
instance Typeable CutDirection
instance Show CutDirection
instance Data CutDirection
instance Generic CutDirection
instance Datatype D1CutDirection
instance Constructor C1_0CutDirection
instance Constructor C1_1CutDirection


-- | Helper function for defining Read instances for bin data types.
module Data.Histogram.Bin.Read

-- | Whitespaces
ws :: ReadP String

-- | End of line
eol :: ReadP Char

-- | Key value pair
value :: Read a => String -> ReadPrec a

-- | Return optional value
maybeValue :: Read a => String -> ReadPrec (Maybe a)

-- | Keyword
keyword :: String -> ReadPrec ()

module Data.Histogram.Bin.BinI

-- | Very simple binning algorithm. Each indices. Each number correcsponds
--   to different bin.
--   
--   For rountripping use <a>lowerLimit</a> and <a>upperLimit</a>
--   
--   <pre>
--   b = binI (lowerLimit b) (upperLimit b)
--   </pre>
data BinI

-- | Safe constructor for BinI. It checks that upper bound is greater or
--   equal than lower bound
binI :: Int -> Int -> BinI

-- | Construct BinI with n bins. Indexing starts from 0. n must be positive
binI0 :: Int -> BinI
instance Typeable BinI
instance Eq BinI
instance Data BinI
instance NFData BinI
instance Read BinI
instance Show BinI
instance BinEq BinI
instance UniformBin BinI
instance VariableBin BinI
instance SliceableBin BinI
instance Bin1D BinI
instance IntervalBin BinI
instance Bin BinI

module Data.Histogram.Bin.BinInt

-- | Integer bins of equal size. For roundtripping use:
--   
--   <pre>
--   b = binIntStep (lowerLimit b) (binSize b) (nBins b)
--   </pre>
data BinInt
BinInt :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> BinInt

-- | Construct BinInt.
binInt :: Int -> Int -> Int -> BinInt

-- | Construct <a>BinInt</a>.
binIntN :: Int -> Int -> Int -> BinInt
binIntStep :: Int -> Int -> Int -> BinInt
instance Typeable BinInt
instance Eq BinInt
instance Data BinInt
instance NFData BinInt
instance Read BinInt
instance Show BinInt
instance BinEq BinInt
instance UniformBin BinInt
instance VariableBin BinInt
instance MergeableBin BinInt
instance SliceableBin BinInt
instance Bin1D BinInt
instance IntervalBin BinInt
instance Bin BinInt

module Data.Histogram.Bin.BinEnum

-- | Bin for types which are instnaces of Enum type class. Value are
--   converted to <a>Int</a> using <a>fromEnum</a> first and then binned.
newtype BinEnum a
BinEnum :: BinI -> BinEnum a

-- | Create enum based bin
binEnum :: Enum a => a -> a -> BinEnum a

-- | Use full range of data
binEnumFull :: (Enum a, Bounded a) => BinEnum a
instance Typeable BinEnum
instance Eq (BinEnum a)
instance Data a => Data (BinEnum a)
instance Enum a => BinEq (BinEnum a)
instance NFData (BinEnum a)
instance Read (BinEnum a)
instance Show (BinEnum a)
instance (Enum a, Ord a) => SliceableBin (BinEnum a)
instance (Enum a, Ord a) => Bin1D (BinEnum a)
instance (Enum a, Ord a) => IntervalBin (BinEnum a)
instance Enum a => Bin (BinEnum a)

module Data.Histogram.Bin.BinF

-- | Floating point bins of equal size. Use following function for
--   construction and inspection of value:
--   
--   <pre>
--   b = binFstep (lowerLimit b) (binSize b) (nBins b)
--   </pre>
--   
--   Performance note. Since <tt>BinF</tt> is parametric in its value it
--   could not be unpacked and every access to data will require pointer
--   indirection. <a>BinD</a> is binning specialized to <tt>Doubles</tt>
--   and it's always faster than <tt>BinF Double</tt>.
data BinF f

-- | Create bins.
binF :: RealFrac f => f -> Int -> f -> BinF f

-- | Create bins. Note that actual upper bound can differ from specified.
binFn :: RealFrac f => f -> f -> f -> BinF f

-- | Create bins
binFstep :: RealFrac f => f -> f -> Int -> BinF f

-- | 'scaleBinF a b' scales BinF using linear transform 'a+b*x'
scaleBinF :: (Show f, RealFrac f) => f -> f -> BinF f -> BinF f

-- | Floating point bins of equal sizes. If you work with Doubles this data
--   type should be used instead of <a>BinF</a>.
data BinD

-- | Create bins.
binD :: Double -> Int -> Double -> BinD

-- | Create bins. Note that actual upper bound can differ from specified.
binDn :: Double -> Double -> Double -> BinD

-- | Create bins
binDstep :: Double -> Double -> Int -> BinD

-- | 'scaleBinF a b' scales BinF using linear transform 'a+b*x'
scaleBinD :: Double -> Double -> BinD -> BinD
instance Typeable BinF
instance Typeable BinD
instance Data f => Data (BinF f)
instance Eq f => Eq (BinF f)
instance Data BinD
instance Eq BinD
instance NFData BinD
instance Read BinD
instance Show BinD
instance BinEq BinD
instance UniformBin BinD
instance VariableBin BinD
instance MergeableBin BinD
instance SliceableBin BinD
instance Bin1D BinD
instance IntervalBin BinD
instance Bin BinD
instance NFData f => NFData (BinF f)
instance (Read f, RealFrac f) => Read (BinF f)
instance Show f => Show (BinF f)
instance RealFloat f => BinEq (BinF f)
instance RealFrac f => UniformBin (BinF f)
instance RealFrac f => VariableBin (BinF f)
instance RealFrac f => MergeableBin (BinF f)
instance RealFrac f => SliceableBin (BinF f)
instance RealFrac f => Bin1D (BinF f)
instance RealFrac f => IntervalBin (BinF f)
instance RealFrac f => Bin (BinF f)

module Data.Histogram.Bin.LogBinD

-- | Uniform binning in logarithmic scale. For roundtripping use:
--   
--   <pre>
--   b = logBinDN (lowerLimit b) (logBinDIncrement b) (nBins b)
--   </pre>
data LogBinD

-- | Increment ratio for <a>LogBinD</a>
logBinDIncrement :: LogBinD -> Double

-- | Create log-scale binning algorithm.
logBinD :: Double -> Int -> Double -> LogBinD
logBinDN :: Double -> Double -> Int -> LogBinD
instance Typeable LogBinD
instance Eq LogBinD
instance Data LogBinD
instance NFData LogBinD
instance Read LogBinD
instance Show LogBinD
instance BinEq LogBinD
instance VariableBin LogBinD
instance MergeableBin LogBinD
instance SliceableBin LogBinD
instance Bin1D LogBinD
instance IntervalBin LogBinD
instance Bin LogBinD

module Data.Histogram.Bin.Bin2D

-- | 2D bins. binX is binning along X axis and binY is one along Y axis.
--   Data is stored in row-major order
data Bin2D binX binY
Bin2D :: !binX -> !binY -> Bin2D binX binY

-- | Binning algorithm for X axis
binX :: Bin2D binX binY -> !binX

-- | Binning algorithm for Y axis
binY :: Bin2D binX binY -> !binY

-- | Alias for <a>Bin2D</a>.
(><) :: binX -> binY -> Bin2D binX binY

-- | Type alias for Bin2D
type (:><:) = Bin2D

-- | 2-dimensional size of binning algorithm
nBins2D :: (Bin bx, Bin by) => Bin2D bx by -> (Int, Int)

-- | Convert index into pair of indices for X and Y axes
toIndex2D :: (Bin binX, Bin binY) => Bin2D binX binY -> Int -> (Int, Int)

-- | Apply function to X binning algorithm. If new binning algorithm have
--   different number of bins will fail.
fmapBinX :: (Bin bx, Bin bx') => (bx -> bx') -> Bin2D bx by -> Bin2D bx' by

-- | Apply function to Y binning algorithm. If new binning algorithm have
--   different number of bins will fail.
fmapBinY :: (Bin by, Bin by') => (by -> by') -> Bin2D bx by -> Bin2D bx by'
instance Typeable Bin2D
instance (Eq binX, Eq binY) => Eq (Bin2D binX binY)
instance (Data binX, Data binY) => Data (Bin2D binX binY)
instance (NFData bx, NFData by) => NFData (Bin2D bx by)
instance (Read bx, Read by) => Read (Bin2D bx by)
instance (Show bx, Show by) => Show (Bin2D bx by)
instance (BinEq bx, BinEq by) => BinEq (Bin2D bx by)
instance (Bin binX, Bin binY) => Bin (Bin2D binX binY)


-- | Binning algorithms. This is mapping from set of interest to integer
--   indices and approximate reverse.
module Data.Histogram.Bin
instance [overlap ok] (ConvertBin bx bx', ConvertBin by by') => ConvertBin (Bin2D bx by) (Bin2D bx' by')
instance [overlap ok] (ConvertBin by by', Bin bx) => ConvertBin (Bin2D bx by) (Bin2D bx by')
instance [overlap ok] (ConvertBin bx bx', Bin by) => ConvertBin (Bin2D bx by) (Bin2D bx' by)
instance [overlap ok] ConvertBin BinInt BinD
instance [overlap ok] ConvertBin BinI BinD
instance [overlap ok] RealFrac f => ConvertBin BinInt (BinF f)
instance [overlap ok] RealFrac f => ConvertBin BinI (BinF f)
instance [overlap ok] ConvertBin BinI BinInt


-- | Generic immutable histograms.
module Data.Histogram.Generic

-- | Immutable histogram. Histogram consists of binning algorithm, optional
--   number of under and overflows, and data. Type parameter have following
--   meaning:
--   
--   <ul>
--   <li><i><tt>v</tt></i> type of vector used to store bin content.</li>
--   <li><i><tt>bin</tt></i> binning. It should be instance of <a>Bin</a>.
--   Check that type class description for details.</li>
--   <li><i><tt>a</tt></i> type of bin content.</li>
--   </ul>
data Histogram v bin a

-- | Create histogram from binning algorithm and vector with data.
--   Overflows are set to Nothing.
--   
--   Number of bins and vector size must match.
histogram :: (Vector v a, Bin bin) => bin -> v a -> Histogram v bin a

-- | Create histogram from binning algorithm and vector with data.
--   
--   Number of bins and vector size must match.
histogramUO :: (Vector v a, Bin bin) => bin -> Maybe (a, a) -> v a -> Histogram v bin a

-- | Convert histogram data to list.
asList :: (Vector v a, Bin bin) => Histogram v bin a -> [(BinValue bin, a)]

-- | Convert histogram data to vector
asVector :: (Bin bin, Vector v a, Vector v (BinValue bin, a)) => Histogram v bin a -> v (BinValue bin, a)

-- | Convert String to histogram. Histogram do not have Read instance
--   because of slowness of ReadP
readHistogram :: (Read bin, Read a, Bin bin, Vector v a) => String -> Histogram v bin a

-- | Read histogram from file.
readFileHistogram :: (Read bin, Read a, Bin bin, Vector v a) => FilePath -> IO (Histogram v bin a)

-- | Histogram bins
bins :: Histogram v bin a -> bin

-- | Histogram data as vector
histData :: Histogram v bin a -> v a

-- | Number of underflows
underflows :: Histogram v bin a -> Maybe a

-- | Number of overflows
overflows :: Histogram v bin a -> Maybe a

-- | Underflows and overflows
outOfRange :: Histogram v bin a -> Maybe (a, a)

-- | Point inside histogram's domain. It could be either bin index or bin
--   value. <a>First</a> and <a>Last</a> constructors are useful for
--   histogram slicing.
data HistIndex b

-- | Index for a bin
Index :: Int -> HistIndex b

-- | Value
Value :: (BinValue b) -> HistIndex b

-- | Bin with index 0
First :: HistIndex b

-- | Bin maximum index.
Last :: HistIndex b

-- | Convert <a>HistIndex</a> to actual index
histIndex :: Bin b => b -> HistIndex b -> Int

-- | Index histogtam.
at :: (Bin bin, Vector v a) => Histogram v bin a -> HistIndex bin -> a

-- | Index histogram using bin value
atV :: (Bin bin, Vector v a) => Histogram v bin a -> BinValue bin -> a

-- | Index histogram using vector index
atI :: (Bin bin, Vector v a) => Histogram v bin a -> Int -> a

-- | fmap lookalike. It's not possible to create Functor instance because
--   of type class context.
map :: (Vector v a, Vector v b) => (a -> b) -> Histogram v bin a -> Histogram v bin b

-- | Map histogram using bin value and content. Overflows and underflows
--   are set to Nothing.
bmap :: (Vector v a, Vector v b, Bin bin) => (BinValue bin -> a -> b) -> Histogram v bin a -> Histogram v bin b
mapData :: (Vector v a, Vector u b, Bin bin) => (v a -> u b) -> Histogram v bin a -> Histogram u bin b

-- | Zip two histograms elementwise. Bins of histograms must be equal
--   otherwise error will be called.
zip :: (Bin bin, BinEq bin, Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> Histogram v bin a -> Histogram v bin b -> Histogram v bin c

-- | Zip two histogram elementwise. If bins are not equal return
--   <a>Nothing</a>
zipSafe :: (Bin bin, BinEq bin, Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> Histogram v bin a -> Histogram v bin b -> Maybe (Histogram v bin c)

-- | Convert between different vector types
convert :: (Vector v a, Vector w a) => Histogram v bin a -> Histogram w bin a

-- | Convert between binning types using <a>ConvertBin</a> type class.
convertBinning :: (ConvertBin bin bin', Vector v a) => Histogram v bin a -> Histogram v bin' a

-- | Strict fold over bin content in index order. Underflows and overflows
--   are ignored.
foldl :: (Bin bin, Vector v a) => (b -> a -> b) -> b -> Histogram v bin a -> b

-- | Strict fold over bin content in index order. Function is applied to
--   bin content and bin value. Underflows and overflows are ignored.
bfoldl :: (Bin bin, Vector v a) => (b -> BinValue bin -> a -> b) -> b -> Histogram v bin a -> b

-- | Sum contents of all bins
sum :: (Bin bin, Vector v a, Num a) => Histogram v bin a -> a

-- | Minimal bin content.
minimum :: (Bin bin, Vector v a, Ord a) => Histogram v bin a -> a

-- | Minimal bin content using custom comparison.
minimumBy :: (Bin bin, Vector v a) => (a -> a -> Ordering) -> Histogram v bin a -> a

-- | Maximal bin content
maximum :: (Bin bin, Vector v a, Ord a) => Histogram v bin a -> a

-- | Maximal bin content using custom comparison.
maximumBy :: (Bin bin, Vector v a) => (a -> a -> Ordering) -> Histogram v bin a -> a

-- | Index of a bin with minimal content
minIndex :: (Bin bin, Ord a, Vector v a) => Histogram v bin a -> Int

-- | Index of a bin with minimal content using custom comparison.
minIndexBy :: (Bin bin, Ord a, Vector v a) => (a -> a -> Ordering) -> Histogram v bin a -> Int

-- | Index of a bin with maximal content
maxIndex :: (Bin bin, Ord a, Vector v a) => Histogram v bin a -> Int

-- | Index of a bin with maximal content using custom comparison.
maxIndexBy :: (Bin bin, Ord a, Vector v a) => (a -> a -> Ordering) -> Histogram v bin a -> Int

-- | Value of a bin with minimal content
minBin :: (Bin bin, Ord a, Vector v a) => Histogram v bin a -> BinValue bin

-- | Value bin with minimal content using custom comparison.
minBinBy :: (Bin bin, Ord a, Vector v a) => (a -> a -> Ordering) -> Histogram v bin a -> BinValue bin

-- | Value of a bin with maximal content
maxBin :: (Bin bin, Ord a, Vector v a) => Histogram v bin a -> BinValue bin

-- | Value of a bin with maximal content using custom comparison.
maxBinBy :: (Bin bin, Ord a, Vector v a) => (a -> a -> Ordering) -> Histogram v bin a -> BinValue bin

-- | Slice histogram. Values/indices specify inclusive variant.
--   Under/overflows are discarded. If requested value falls out of
--   histogram range it will be truncated. Use <a>First</a> or <a>Last</a>
--   constructor if you need slice from first or to last bin
--   correspondingly.
slice :: (SliceableBin bin, Vector v a) => HistIndex bin -> HistIndex bin -> Histogram v bin a -> Histogram v bin a

-- | Rebin histogram by joining <tt>n</tt> adjacent bins.
rebin :: (MergeableBin bin, Vector v a) => CutDirection -> Int -> (a -> a -> a) -> Histogram v bin a -> Histogram v bin a

-- | Rebin histogram by joining <tt>n</tt> adjacent bins.
rebinFold :: (MergeableBin bin, Vector v a, Vector v b) => CutDirection -> Int -> (b -> a -> b) -> b -> Histogram v bin a -> Histogram v bin b

-- | Get slice of 2D histogram along X axis. This function is faster than
--   <a>sliceAlongY</a> since no array reallocations is required
sliceAlongX :: (Vector v a, Bin bX, Bin bY) => Histogram v (Bin2D bX bY) a -> HistIndex bY -> Histogram v bX a

-- | Get slice of 2D histogram along X axis
sliceAlongY :: (Vector v a, Bin bX, Bin bY) => Histogram v (Bin2D bX bY) a -> HistIndex bX -> Histogram v bY a

-- | Slice 2D histogram along Y axis. This function is fast because it does
--   not require reallocations.
listSlicesAlongX :: (Vector v a, Bin bX, Bin bY) => Histogram v (Bin2D bX bY) a -> [(BinValue bY, Histogram v bX a)]

-- | Slice 2D histogram along X axis.
listSlicesAlongY :: (Vector v a, Bin bX, Bin bY) => Histogram v (Bin2D bX bY) a -> [(BinValue bX, Histogram v bY a)]

-- | Reduce along X axis. Information about under/overlows is lost.
reduceX :: (Vector v a, Vector v b, Bin bX, Bin bY) => (Histogram v bX a -> b) -> Histogram v (Bin2D bX bY) a -> Histogram v bY b

-- | Reduce along X axis. Information about under/overlows is lost.
breduceX :: (Vector v a, Vector v b, Bin bX, Bin bY) => (BinValue bY -> Histogram v bX a -> b) -> Histogram v (Bin2D bX bY) a -> Histogram v bY b

-- | Reduce along Y axis. Information about under/overflows is lost.
reduceY :: (Vector v a, Vector v b, Bin bX, Bin bY) => (Histogram v bY a -> b) -> Histogram v (Bin2D bX bY) a -> Histogram v bX b

-- | Reduce along Y axis. Information about under/overflows is lost.
breduceY :: (Vector v a, Vector v b, Bin bX, Bin bY) => (BinValue bX -> Histogram v bY a -> b) -> Histogram v (Bin2D bX bY) a -> Histogram v bX b

-- | Transform X slices of histogram.
liftX :: (Bin bX, Bin bY, Bin bX', BinEq bX', Vector v a, Vector v b) => (Histogram v bX a -> Histogram v bX' b) -> Histogram v (Bin2D bX bY) a -> Histogram v (Bin2D bX' bY) b

-- | Transform Y slices of histogram.
liftY :: (Bin bX, Bin bY, Bin bY', BinEq bY', Vector v a, Vector v b, Vector v Int) => (Histogram v bY a -> Histogram v bY' b) -> Histogram v (Bin2D bX bY) a -> Histogram v (Bin2D bX bY') b
instance Typeable Histogram
instance Typeable HistIndex
instance (Eq bin, Eq a, Eq (v a)) => Eq (Histogram v bin a)
instance Functor v => Functor (Histogram v bin)
instance (NFData a, NFData bin, NFData (v a)) => NFData (Histogram v bin a)
instance (Show a, Show (BinValue bin), Show bin, Bin bin, Vector v a) => Show (Histogram v bin a)


-- | Mutable histograms.
module Data.Histogram.ST

-- | Mutable histogram.
data MHistogram s v bin a

-- | Create new mutable histogram. All bins are set to zero element as
--   passed to function.
newMHistogram :: (PrimMonad m, Bin bin, MVector v a) => a -> bin -> m (MHistogram (PrimState m) v bin a)

-- | Generic fill. It could be seen as left fold with multiple accumulators
--   where accumulator is chosen by <tt>BinValue bin</tt>.
fill :: (PrimMonad m, MVector v a, Bin bin) => MHistogram (PrimState m) v bin a -> BinValue bin -> (a -> b -> a) -> b -> m ()

-- | Create immutable histogram from mutable one. This operation is unsafe!
--   Accumulator mustn't be used after that
unsafeFreezeHist :: (PrimMonad m, Vector v a, Bin bin) => MHistogram (PrimState m) (Mutable v) bin a -> m (Histogram v bin a)

-- | Create immutable histogram from mutable one.
freezeHist :: (PrimMonad m, Vector v a, Bin bin) => MHistogram (PrimState m) (Mutable v) bin a -> m (Histogram v bin a)

module Data.Histogram.Bin.MaybeBin

-- | This binning algorithms adds special case of no value.
newtype MaybeBin bin
MaybeBin :: bin -> MaybeBin bin

-- | Drop bin with no events
fromMaybeBin :: (Bin b, Vector v a) => Histogram v (MaybeBin b) a -> Histogram v b a
instance Typeable MaybeBin
instance BinEq bin => BinEq (MaybeBin bin)
instance Eq bin => Eq (MaybeBin bin)
instance NFData bin => NFData (MaybeBin bin)
instance Read bin => Read (MaybeBin bin)
instance Show bin => Show (MaybeBin bin)
instance VariableBin bin => VariableBin (MaybeBin bin)
instance Bin bin => Bin (MaybeBin bin)


-- | Extra binning algorithms
module Data.Histogram.Bin.Extra

-- | Type class very similar to <a>Enum</a> but elements of type are
--   enumerated on 2-dimensional grid
class Enum2D a
fromEnum2D :: Enum2D a => a -> (Int, Int)
toEnum2D :: Enum2D a => (Int, Int) -> a

-- | Binning for 2D enumerations
data BinEnum2D i

-- | Construct indexed bin
binEnum2D :: Enum2D i => i -> i -> BinEnum2D i

-- | Direct permutation of indices.
data BinPermute b

-- | Constuct bin permutation from table
permuteByTable :: Bin b => b -> Vector Int -> Maybe (BinPermute b)

-- | Constuct bin permutation from function.
permuteBin :: Bin b => b -> (Int -> Int) -> Maybe (BinPermute b)
instance Typeable BinEnum2D
instance Typeable BinPermute
instance Eq (BinEnum2D i)
instance Data i => Data (BinEnum2D i)
instance Eq b => Eq (BinPermute b)
instance Data b => Data (BinPermute b)
instance NFData b => NFData (BinPermute b)
instance Read BinI => Read (BinPermute BinI)
instance Show b => Show (BinPermute b)
instance UniformBin b => UniformBin (BinPermute b)
instance VariableBin b => VariableBin (BinPermute b)
instance IntervalBin b => IntervalBin (BinPermute b)
instance Bin b => Bin (BinPermute b)
instance NFData (BinEnum2D i)
instance (Read i, Enum2D i) => Read (BinEnum2D i)
instance (Show i, Enum2D i) => Show (BinEnum2D i)
instance Enum2D i => Bin (BinEnum2D i)
instance (Enum a, Enum b) => Enum2D (a, b)


-- | Immutable histograms. This module export same APi as <a>Generic</a>
--   but specialzed to unboxed vectors. Refer aforementioned module for
--   documentation.
module Data.Histogram

-- | Immutable histogram. Histogram consists of binning algorithm, optional
--   number of under and overflows, and data.
type Histogram bin a = Histogram Vector bin a
histogram :: (Unbox a, Bin bin) => bin -> Vector a -> Histogram bin a
histogramUO :: (Unbox a, Bin bin) => bin -> Maybe (a, a) -> Vector a -> Histogram bin a
asList :: (Unbox a, Bin bin) => Histogram bin a -> [(BinValue bin, a)]
asVector :: (Bin bin, Unbox a, Unbox (BinValue bin), Unbox (BinValue bin, a)) => Histogram bin a -> Vector (BinValue bin, a)
readHistogram :: (Read bin, Read a, Bin bin, Unbox a) => String -> Histogram bin a
readFileHistogram :: (Read bin, Read a, Bin bin, Unbox a) => FilePath -> IO (Histogram bin a)
bins :: Histogram bin a -> bin
histData :: Histogram bin a -> Vector a
underflows :: Histogram bin a -> Maybe a
overflows :: Histogram bin a -> Maybe a
outOfRange :: Histogram bin a -> Maybe (a, a)

-- | Point inside histogram's domain. It could be either bin index or bin
--   value. <a>First</a> and <a>Last</a> constructors are useful for
--   histogram slicing.
data HistIndex b

-- | Index for a bin
Index :: Int -> HistIndex b

-- | Value
Value :: (BinValue b) -> HistIndex b

-- | Bin with index 0
First :: HistIndex b

-- | Bin maximum index.
Last :: HistIndex b

-- | Convert <a>HistIndex</a> to actual index
histIndex :: Bin b => b -> HistIndex b -> Int
at :: (Bin bin, Unbox a) => Histogram bin a -> HistIndex bin -> a
atV :: (Bin bin, Unbox a) => Histogram bin a -> BinValue bin -> a
atI :: (Bin bin, Unbox a) => Histogram bin a -> Int -> a
map :: (Unbox a, Unbox b) => (a -> b) -> Histogram bin a -> Histogram bin b
bmap :: (Unbox a, Unbox b, Bin bin) => (BinValue bin -> a -> b) -> Histogram bin a -> Histogram bin b
mapData :: (Unbox a, Unbox b, Bin bin) => (Vector a -> Vector b) -> Histogram bin a -> Histogram bin b
zip :: (Bin bin, BinEq bin, Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Histogram bin a -> Histogram bin b -> Histogram bin c
zipSafe :: (Bin bin, BinEq bin, Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Histogram bin a -> Histogram bin b -> Maybe (Histogram bin c)
convertBinning :: (ConvertBin bin bin', Unbox a) => Histogram bin a -> Histogram bin' a
foldl :: (Bin bin, Unbox a) => (b -> a -> b) -> b -> Histogram bin a -> b
bfoldl :: (Bin bin, Unbox a) => (b -> BinValue bin -> a -> b) -> b -> Histogram bin a -> b
sum :: (Bin bin, Unbox a, Num a) => Histogram bin a -> a
minimum :: (Bin bin, Unbox a, Ord a) => Histogram bin a -> a
minimumBy :: (Bin bin, Unbox a) => (a -> a -> Ordering) -> Histogram bin a -> a
maximum :: (Bin bin, Unbox a, Ord a) => Histogram bin a -> a
maximumBy :: (Bin bin, Unbox a) => (a -> a -> Ordering) -> Histogram bin a -> a
minIndex :: (Bin bin, Ord a, Unbox a) => Histogram bin a -> Int
minIndexBy :: (Bin bin, Ord a, Unbox a) => (a -> a -> Ordering) -> Histogram bin a -> Int
maxIndex :: (Bin bin, Ord a, Unbox a) => Histogram bin a -> Int
maxIndexBy :: (Bin bin, Ord a, Unbox a) => (a -> a -> Ordering) -> Histogram bin a -> Int
minBin :: (Bin bin, Ord a, Unbox a) => Histogram bin a -> BinValue bin
minBinBy :: (Bin bin, Ord a, Unbox a) => (a -> a -> Ordering) -> Histogram bin a -> BinValue bin
maxBin :: (Bin bin, Ord a, Unbox a) => Histogram bin a -> BinValue bin
maxBinBy :: (Bin bin, Ord a, Unbox a) => (a -> a -> Ordering) -> Histogram bin a -> BinValue bin
slice :: (SliceableBin bin, Unbox a) => HistIndex bin -> HistIndex bin -> Histogram bin a -> Histogram bin a
rebin :: (MergeableBin bin, Unbox a) => CutDirection -> Int -> (a -> a -> a) -> Histogram bin a -> Histogram bin a
rebinFold :: (MergeableBin bin, Unbox a, Unbox b) => CutDirection -> Int -> (b -> a -> b) -> b -> Histogram bin a -> Histogram bin b
sliceAlongX :: (Unbox a, Bin bX, Bin bY) => Histogram (Bin2D bX bY) a -> HistIndex bY -> Histogram bX a
sliceAlongY :: (Unbox a, Bin bX, Bin bY) => Histogram (Bin2D bX bY) a -> HistIndex bX -> Histogram bY a
listSlicesAlongX :: (Unbox a, Bin bX, Bin bY) => Histogram (Bin2D bX bY) a -> [(BinValue bY, Histogram bX a)]
listSlicesAlongY :: (Unbox a, Bin bX, Bin bY) => Histogram (Bin2D bX bY) a -> [(BinValue bX, Histogram bY a)]
reduceX :: (Unbox a, Unbox b, Bin bX, Bin bY) => (Histogram bX a -> b) -> Histogram (Bin2D bX bY) a -> Histogram bY b
breduceX :: (Unbox a, Unbox b, Bin bX, Bin bY) => (BinValue bY -> Histogram bX a -> b) -> Histogram (Bin2D bX bY) a -> Histogram bY b
reduceY :: (Unbox a, Unbox b, Bin bX, Bin bY) => (Histogram bY a -> b) -> Histogram (Bin2D bX bY) a -> Histogram bX b
breduceY :: (Unbox a, Unbox b, Bin bX, Bin bY) => (BinValue bX -> Histogram bY a -> b) -> Histogram (Bin2D bX bY) a -> Histogram bX b
liftX :: (Bin bX, Bin bY, Bin bX', BinEq bX', Unbox a, Unbox b) => (Histogram bX a -> Histogram bX' b) -> Histogram (Bin2D bX bY) a -> Histogram (Bin2D bX' bY) b
liftY :: (Bin bX, Bin bY, Bin bY', BinEq bY', Unbox a, Unbox b) => (Histogram bY a -> Histogram bY' b) -> Histogram (Bin2D bX bY) a -> Histogram (Bin2D bX bY') b


-- | Stateful and pure (still stateful under the hood) accumulators.
module Data.Histogram.Fill

-- | Type class for stateful accumulators. In this module they are called
--   builders. Every builder is parametrized by two types. First one is
--   type of values which are fed to accumulator and second one is type of
--   values which could be extracted from it.
--   
--   Every instance of <a>HBuilder</a> should be instance of <a>Functor</a>
--   too and satisfy <a>fmap</a> == <a>modifyOut</a>.
class HistBuilder h
modifyOut :: HistBuilder h => (b -> b') -> h a b -> h a b'
modifyIn :: HistBuilder h => (a' -> a) -> h a b -> h a' b
fromContainer :: HistBuilder h => (forall m. Monad m => (a -> m ()) -> f a -> m ()) -> h a b -> h (f a) b
addCut :: HistBuilder h => (a -> Bool) -> h a b -> h a b

-- | Modify input of builder
(<<-) :: HistBuilder h => h a b -> (a' -> a) -> h a' b

-- | Modify input of builder to use composite input
(<<-|) :: (HistBuilder h, Foldable f) => h a b -> (a' -> f a) -> h a' b

-- | Add cut for input
(<<?) :: HistBuilder h => h a b -> (a -> Bool) -> h a b

-- | Apply function which modify builder
(<<-$) :: HistBuilder h => h a b -> (h a b -> h a' b) -> h a' b

-- | Modify output of histogram. In fact it's same as <a>&lt;$&gt;</a> but
--   have opposite fixity
(-<<) :: HistBuilder h => (b -> b') -> h a b -> h a b'

-- | Stateful histogram builder. Adding value to builder could be done with
--   <a>feedOne</a> and result could be extracted with
--   <a>freezeHBuilderM</a>.
--   
--   There are two ways to obtain stateful builder. First and recommended
--   is to thaw <a>HBuilder</a> using <a>toHBuilderIO</a> or
--   <a>toHBuilderST</a>. Second is to use <a>mkStatefulBuilder</a>.
data HBuilderM m a b
HBuilderM :: (a -> m ()) -> m b -> HBuilderM m a b
hbInput :: HBuilderM m a b -> a -> m ()
hbOutput :: HBuilderM m a b -> m b

-- | Put one item into histogram
feedOne :: Monad m => HBuilderM m a b -> a -> m ()

-- | Extract result from histogram builder. It's safe to call this function
--   multiple times and mutate builder afterwards.
freezeHBuilderM :: Monad m => HBuilderM m a b -> m b

-- | Wrapper around stateful histogram builder. It is much more convenient
--   to work with than <a>HBuilderM</a>.
newtype HBuilder a b
HBuilder :: (forall m. PrimMonad m => m (HBuilderM m a b)) -> HBuilder a b

-- | Convert builder to stateful builder in ST monad
toHBuilderST :: HBuilder a b -> ST s (HBuilderM (ST s) a b)

-- | Convert builder to builder in IO monad
toHBuilderIO :: HBuilder a b -> IO (HBuilderM IO a b)

-- | Convert builder to stateful builder in primitive monad
toHBuilderM :: PrimMonad m => HBuilder a b -> m (HBuilderM m a b)

-- | Create builder. Bin content will be incremented by 1 for each item put
--   into histogram
mkSimple :: (Bin bin, Unbox val, Num val) => bin -> HBuilder (BinValue bin) (Histogram bin val)

-- | Create builder. Bin content will incremented by weight supplied for
--   each item put into histogram
mkWeighted :: (Bin bin, Unbox val, Num val) => bin -> HBuilder (BinValue bin, val) (Histogram bin val)

-- | Create builder. New value wil be mappended to current content of a bin
--   for each item put into histogram
mkMonoidal :: (Bin bin, Unbox val, Monoid val) => bin -> HBuilder (BinValue bin, val) (Histogram bin val)

-- | Create most generic histogram builder.
mkFoldBuilder :: (Bin bin, Unbox val) => bin -> val -> (val -> a -> val) -> HBuilder (BinValue bin, a) (Histogram bin val)

-- | Create builder. Bin content will be incremented by 1 for each item put
--   into histogram
mkSimpleG :: (Bin bin, Vector v val, Num val) => bin -> HBuilder (BinValue bin) (Histogram v bin val)

-- | Create builder. Bin content will incremented by weight supplied for
--   each item put into histogram
mkWeightedG :: (Bin bin, Vector v val, Num val) => bin -> HBuilder (BinValue bin, val) (Histogram v bin val)

-- | Create builder. New value wil be mappended to current content of a bin
--   for each item put into histogram
mkMonoidalG :: (Bin bin, Vector v val, Monoid val) => bin -> HBuilder (BinValue bin, val) (Histogram v bin val)

-- | Create most generic histogram builder.
mkFoldBuilderG :: (Bin bin, Vector v val) => bin -> val -> (val -> a -> val) -> HBuilder (BinValue bin, a) (Histogram v bin val)

-- | Create histogram builder which just does ordinary pure fold. It is
--   intended for use when some fold should be performed together with
--   histogram filling
mkFolder :: b -> (a -> b -> b) -> HBuilder a b

-- | Create stateful histogram builder. Output function should be safe to
--   call multiple times and builder could be modified afterwards. So
--   functions like <tt>unsafeFreeze</tt> from <tt>vector</tt> couldn't be
--   used.
mkStatefulBuilder :: Monad m => (a -> m ()) -> m b -> HBuilderM m a b

-- | Fill histogram builder.
fillBuilder :: Foldable f => HBuilder a b -> f a -> b

-- | Fill histogram builder.
fillBuilderVec :: Vector v a => HBuilder a b -> v a -> b
forceInt :: Histogram v bin Int -> Histogram v bin Int
forceDouble :: Histogram v bin Double -> Histogram v bin Double
forceFloat :: Histogram v bin Float -> Histogram v bin Float

-- | Join hitogram builders in container.

-- | <i>Deprecated: Use Data.Traversable.sequenceA instead</i>
joinHBuilder :: Traversable f => f (HBuilder a b) -> HBuilder a (f b)

-- | Join histogram builders in container

-- | <i>Deprecated: Use Data.Traversable.sequenceA instead</i>
joinHBuilderM :: (Traversable f, Monad m) => f (HBuilderM m a b) -> HBuilderM m a (f b)

-- | Apply functions to builder

-- | <i>Deprecated: Use Data.Traversable.traverse. treeHBuilderM fs h =
--   F.traverse ($ h) fs</i>
treeHBuilderM :: (Monad m, Traversable f) => f (HBuilderM m a b -> HBuilderM m a' b') -> HBuilderM m a b -> HBuilderM m a' (f b')

-- | Apply function to builder

-- | <i>Deprecated: Use Data.Traversable.traverse. treeHBuilderM fs h =
--   F.traverse ($ h) fs</i>
treeHBuilder :: Traversable f => f (HBuilder a b -> HBuilder a' b') -> HBuilder a b -> HBuilder a' (f b')
instance Monoid b => Monoid (HBuilder a b)
instance Applicative (HBuilder a)
instance Functor (HBuilder a)
instance HistBuilder HBuilder
instance (Monad m, Monoid b) => Monoid (HBuilderM m a b)
instance Monad m => Applicative (HBuilderM m a)
instance Monad m => Functor (HBuilderM m a)
instance Monad m => HistBuilder (HBuilderM m)
