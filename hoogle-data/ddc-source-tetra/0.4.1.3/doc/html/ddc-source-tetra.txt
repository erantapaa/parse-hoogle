-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Disciplined Disciple Compiler source language.
--   
--   Disciplined Disciple Compiler Tetra source language. Disciple Tetra is
--   the main source language of DDC. The word Tetra refers to the four
--   base kinds: <a>Data</a>, <a>Region</a>, <a>Effect</a> and
--   <a>Witness</a>.
@package ddc-source-tetra
@version 0.4.1.3

module DDC.Source.Tetra.Exp

-- | Well-typed expressions have types of kind <tt>Data</tt>.
data Exp a n

-- | Value variable or primitive operation.
XVar :: !a -> !(Bound n) -> Exp a n

-- | Data constructor or literal.
XCon :: !a -> !(DaCon n) -> Exp a n

-- | Type abstraction (level-1).
XLAM :: !a -> !(Bind n) -> !(Exp a n) -> Exp a n

-- | Value and Witness abstraction (level-0).
XLam :: !a -> !(Bind n) -> !(Exp a n) -> Exp a n

-- | Application.
XApp :: !a -> !(Exp a n) -> !(Exp a n) -> Exp a n

-- | Possibly recursive bindings.
XLet :: !a -> !(Lets a n) -> !(Exp a n) -> Exp a n

-- | Case branching.
XCase :: !a -> !(Exp a n) -> ![Alt a n] -> Exp a n

-- | Type cast.
XCast :: !a -> !(Cast a n) -> !(Exp a n) -> Exp a n

-- | Type can appear as the argument of an application.
XType :: !a -> !(Type n) -> Exp a n

-- | Witness can appear as the argument of an application.
XWitness :: !a -> !(Witness a n) -> Exp a n

-- | Some expressions and infix operators that need to be resolved into
--   proper function applications.
XDefix :: !a -> [Exp a n] -> Exp a n

-- | Use of a naked infix operator, like in 1 + 2. INVARIANT: only appears
--   in the list of an XDefix node.
XInfixOp :: !a -> String -> Exp a n

-- | Use of an infix operator as a plain variable, like in (+) 1 2.
--   INVARIANT: only appears in the list of an XDefix node.
XInfixVar :: !a -> String -> Exp a n

-- | Possibly recursive bindings.
data Lets a n

-- | Non-recursive let-binding.
LLet :: !(Bind n) -> !(Exp a n) -> Lets a n

-- | Recursive let bindings.
LRec :: ![(Bind n, Exp a n)] -> Lets a n

-- | Bind a local region variable, and witnesses to its properties.
LPrivate :: ![Bind n] -> !(Maybe (Type n)) -> ![Bind n] -> Lets a n

-- | Case alternatives.
data Alt a n
AAlt :: !(Pat n) -> !(Exp a n) -> Alt a n

-- | Pattern matching.
data Pat n :: * -> *

-- | The default pattern always succeeds.
PDefault :: Pat n

-- | Match a data constructor and bind its arguments.
PData :: !(DaCon n) -> ![Bind n] -> Pat n

-- | Type casts.
data Cast a n

-- | Weaken the effect of an expression. The given effect is added to the
--   effect of the body.
CastWeakenEffect :: !(Effect n) -> Cast a n

-- | Purify the effect (action) of an expression.
CastPurify :: !(Witness a n) -> Cast a n

-- | Box a computation, capturing its effects in the S computation type.
CastBox :: Cast a n

-- | Run a computation, releasing its effects into the environment.
CastRun :: Cast a n

-- | When a witness exists in the program it guarantees that a certain
--   property of the program is true.
data Witness a n :: * -> * -> *

-- | Witness variable.
WVar :: a -> !(Bound n) -> Witness a n

-- | Witness constructor.
WCon :: a -> !(WiCon n) -> Witness a n

-- | Witness application.
WApp :: a -> !(Witness a n) -> !(Witness a n) -> Witness a n

-- | Joining of witnesses.
WJoin :: a -> !(Witness a n) -> !(Witness a n) -> Witness a n

-- | Type can appear as the argument of an application.
WType :: a -> !(Type n) -> Witness a n

-- | Data constructors.
data DaCon n :: * -> *

-- | Baked in unit data constructor.
DaConUnit :: DaCon n

-- | Primitive data constructor used for literals and baked-in
--   constructors.
--   
--   The type of the constructor needs to be attached to handle the case
--   where there are too many constructors in the data type to list, like
--   for Int literals. In this case we determine what data type it belongs
--   to from the attached type of the data constructor.
DaConPrim :: !n -> !(Type n) -> DaCon n

-- | Name of the data constructor.
--   
--   Name of the data constructor.
daConName :: DaCon n -> !n

-- | Type of the data constructor.
daConType :: DaCon n -> !(Type n)

-- | Data constructor that has a data type declaration.
DaConBound :: !n -> DaCon n

-- | Name of the data constructor.
--   
--   Name of the data constructor.
daConName :: DaCon n -> !n

-- | Witness constructors.
data WiCon n :: * -> *

-- | Witness constructors baked into the language.
WiConBuiltin :: !WbCon -> WiCon n

-- | Witness constructors defined in the environment. In the interpreter we
--   use this to hold runtime capabilities. The attached type must be
--   closed.
WiConBound :: !(Bound n) -> !(Type n) -> WiCon n

-- | Built-in witness constructors.
--   
--   These are used to convert a runtime capability into a witness that the
--   corresponding property is true.
data WbCon :: *

-- | (axiom) The pure effect is pure.
--   
--   <pre>
--   pure     :: Pure !0
--   </pre>
WbConPure :: WbCon

-- | (axiom) The empty closure is empty.
--   
--   <pre>
--   empty    :: Empty $0
--   </pre>
WbConEmpty :: WbCon

-- | Convert a capability guaranteeing that a region is in the global heap,
--   into a witness that a closure using this region is empty. This lets us
--   rely on the garbage collector to reclaim objects in the region. It is
--   needed when we suspend the evaluation of expressions that have a
--   region in their closure, because the type of the returned thunk may
--   not reveal that it references objects in that region.
--   
--   <pre>
--   use      :: [r : %]. Global r =&gt; Empty (Use r)
--   </pre>
WbConUse :: WbCon

-- | Convert a capability guaranteeing the constancy of a region, into a
--   witness that a read from that region is pure. This lets us suspend
--   applications that read constant objects, because it doesn't matter if
--   the read is delayed, we'll always get the same result.
--   
--   <pre>
--   read     :: [r : %]. Const r  =&gt; Pure (Read r)
--   </pre>
WbConRead :: WbCon

-- | Convert a capability guaranteeing the constancy of a region, into a
--   witness that allocation into that region is pure. This lets us
--   increase the sharing of constant objects, because we can't tell
--   constant objects of the same value apart.
--   
--   <pre>
--   alloc    :: [r : %]. Const r  =&gt; Pure (Alloc r)
--   </pre>
WbConAlloc :: WbCon

module DDC.Source.Tetra.Prim

-- | Names of things used in Disciple Source Tetra.
data Name

-- | A user defined variable.
NameVar :: String -> Name

-- | A user defined constructor.
NameCon :: String -> Name

-- | Baked in data type constructors.
NameTyConTetra :: TyConTetra -> Name

-- | Baked in store operators.
NameOpStore :: OpStore -> Name

-- | Primitive type cosntructors.
NamePrimTyCon :: PrimTyCon -> Name

-- | Primitive arithmetic, logic and comparison.
NamePrimArith :: PrimArith -> Name

-- | A boolean literal.
NameLitBool :: Bool -> Name

-- | A natural literal.
NameLitNat :: Integer -> Name

-- | An integer literal.
NameLitInt :: Integer -> Name

-- | A word literal.
NameLitWord :: Integer -> Int -> Name

-- | A hole used during type inference.
NameHole :: Name

-- | Baked-in type constructors.
data TyConTetra

-- | <tt>Ref#</tt>. Mutable reference.
TyConTetraRef :: TyConTetra

-- | <tt>TupleN#</tt>. Tuples.
TyConTetraTuple :: Int -> TyConTetra

-- | Take the kind of a baked-in data constructor.
kindTyConTetra :: TyConTetra -> Type Name

-- | Mutable References.
data OpStore :: *

-- | Allocate a reference.
OpStoreAllocRef :: OpStore

-- | Read a reference.
OpStoreReadRef :: OpStore

-- | Write to a reference.
OpStoreWriteRef :: OpStore

-- | Take the type of a primitive arithmetic operator.
typeOpStore :: OpStore -> Maybe (Type Name)

-- | Primitive type constructors.
data PrimTyCon :: *

-- | <tt>Void#</tt> the Void type has no values.
PrimTyConVoid :: PrimTyCon

-- | <tt>Bool#</tt> unboxed booleans.
PrimTyConBool :: PrimTyCon

-- | <tt>Nat#</tt> natural numbers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
PrimTyConNat :: PrimTyCon

-- | <tt>Int#</tt> signed integers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
--   If N is the total number of objects that can exist in the heap, then
--   the range of <tt>Int#</tt> is at least (-N .. +N) inclusive.
PrimTyConInt :: PrimTyCon

-- | <tt>WordN#</tt> machine words of the given width.
PrimTyConWord :: Int -> PrimTyCon

-- | <tt>FloatN#</tt> floating point numbers of the given width.
PrimTyConFloat :: Int -> PrimTyCon

-- | <tt>VecN#</tt> a packed vector of N values. This is intended to have
--   kind (Data -&gt; Data), so we use concrete vector types like
--   <tt>Vec4</tt>.
PrimTyConVec :: Int -> PrimTyCon

-- | <tt>Addr#</tt> a relative or absolute machine address. Enough
--   precision to count every byte of memory. Unlike pointers below, an
--   absolute <tt>Addr#</tt> need not refer to memory owned by the current
--   process.
PrimTyConAddr :: PrimTyCon

-- | <tt>Ptr#</tt> should point to a well-formed object owned by the
--   current process.
PrimTyConPtr :: PrimTyCon

-- | <tt>Tag#</tt> data constructor tags. Enough precision to count every
--   possible alternative of an enumerated type.
PrimTyConTag :: PrimTyCon

-- | <tt>String#</tt> of UTF8 characters.
--   
--   These are primitive until we can define our own unboxed types.
PrimTyConString :: PrimTyCon

-- | Yield the kind of a type constructor.
kindPrimTyCon :: PrimTyCon -> Kind Name

-- | Primitive <a>Bool</a> type.
tBool :: Type Name

-- | Primitive <tt>Nat</tt> type.
tNat :: Type Name

-- | Primitive <a>Int</a> type.
tInt :: Type Name

-- | Primitive <tt>WordN</tt> type of the given width.
tWord :: Int -> Type Name

-- | Primitive arithmetic, logic, and comparison opretors. We expect the
--   backend/machine to be able to implement these directly.
--   
--   For the Shift Right operator, the type that it is used at determines
--   whether it is an arithmetic (with sign-extension) or logical (no
--   sign-extension) shift.
data PrimArith :: *

-- | Negation
PrimArithNeg :: PrimArith

-- | Addition
PrimArithAdd :: PrimArith

-- | Subtraction
PrimArithSub :: PrimArith

-- | Multiplication
PrimArithMul :: PrimArith

-- | Division
PrimArithDiv :: PrimArith

-- | Modulus
PrimArithMod :: PrimArith

-- | Remainder
PrimArithRem :: PrimArith

-- | Equality
PrimArithEq :: PrimArith

-- | Negated Equality
PrimArithNeq :: PrimArith

-- | Greater Than
PrimArithGt :: PrimArith

-- | Greater Than or Equal
PrimArithGe :: PrimArith

-- | Less Than
PrimArithLt :: PrimArith

-- | Less Than or Equal
PrimArithLe :: PrimArith

-- | Boolean And
PrimArithAnd :: PrimArith

-- | Boolean Or
PrimArithOr :: PrimArith

-- | Shift Left
PrimArithShl :: PrimArith

-- | Shift Right
PrimArithShr :: PrimArith

-- | Bit-wise And
PrimArithBAnd :: PrimArith

-- | Bit-wise Or
PrimArithBOr :: PrimArith

-- | Bit-wise eXclusive Or
PrimArithBXOr :: PrimArith

-- | Take the type of a primitive arithmetic operator.
typePrimArith :: PrimArith -> Type Name

-- | Read the name of a variable, constructor or literal.
readName :: String -> Maybe Name
instance Pretty Name
instance NFData Name

module DDC.Source.Tetra.Env

-- | Kind environment containing kinds of primitive data types.
primKindEnv :: Env Name

-- | Type environment containing types of primitive operators.
primTypeEnv :: Env Name

module DDC.Source.Tetra.Lexer

-- | Lex a string to tokens, using primitive names.
--   
--   The first argument gives the starting source line number.
lexModuleString :: String -> Int -> String -> [Token (Tok Name)]

module DDC.Source.Tetra.DataDef

-- | Data type definitions.
data DataDef n
DataDef :: !n -> [Bind n] -> [DataCtor n] -> DataDef n

-- | Data type name.
dataDefTypeName :: DataDef n -> !n

-- | Type parameters.
dataDefParams :: DataDef n -> [Bind n]

-- | Parameters and return type of each constructor.
dataDefCtors :: DataDef n -> [DataCtor n]

-- | Take the types of data constructors from a data type definition.
typeEnvOfDataDef :: Ord n => DataDef n -> TypeEnv n

-- | A data type constructor definition.
data DataCtor n
DataCtor :: !n -> ![Type n] -> !(Type n) -> DataCtor n

-- | Name of the data constructor.
dataCtorName :: DataCtor n -> !n

-- | Types of each of the fields of the constructor.
dataCtorFieldTypes :: DataCtor n -> ![Type n]

-- | Result type of the constructor.
dataCtorResultType :: DataCtor n -> !(Type n)

-- | Get the type of a data constructor.
typeOfDataCtor :: DataDef n -> DataCtor n -> Type n
instance Show n => Show (DataCtor n)
instance Show n => Show (DataDef n)
instance NFData (DataCtor n)
instance NFData (DataDef n)

module DDC.Source.Tetra.Module
data Module a n
Module :: !ModuleName -> [n] -> [n] -> [ModuleName] -> [(n, ImportSource n)] -> [(n, ImportSource n)] -> [Top a n] -> Module a n

-- | Name of this module
moduleName :: Module a n -> !ModuleName

-- | Names of exported types (level-1).
moduleExportTypes :: Module a n -> [n]

-- | Names of exported values (level-0).
moduleExportValues :: Module a n -> [n]

-- | Imported modules.
moduleImportModules :: Module a n -> [ModuleName]

-- | Kinds of imported foreign types.
moduleImportTypes :: Module a n -> [(n, ImportSource n)]

-- | Types of imported foreign values.
moduleImportValues :: Module a n -> [(n, ImportSource n)]

-- | Top-level things
moduleTops :: Module a n -> [Top a n]

-- | Check if this is the <tt>Main</tt> module.
isMainModule :: Module a n -> Bool
data ExportSource n :: * -> *

-- | A name defined in this module, with an explicit type.
ExportSourceLocal :: n -> Type n -> ExportSource n
exportSourceLocalName :: ExportSource n -> n
exportSourceLocalType :: ExportSource n -> Type n

-- | A named defined in this module, without a type attached. We use this
--   version for source language where we infer the type of the exported
--   thing.
ExportSourceLocalNoType :: n -> ExportSource n
exportSourceLocalName :: ExportSource n -> n

-- | Source of some imported thing.
data ImportSource n :: * -> *

-- | A type imported abstractly. It may be defined in a foreign language,
--   but the Disciple program treats it abstractly.
ImportSourceAbstract :: Type n -> ImportSource n
importSourceAbstractType :: ImportSource n -> Type n

-- | Something imported from a Disciple module that we compiled ourself.
ImportSourceModule :: ModuleName -> n -> Type n -> ImportSource n
importSourceModuleName :: ImportSource n -> ModuleName
importSourceModuleVar :: ImportSource n -> n
importSourceModuleType :: ImportSource n -> Type n

-- | Something imported via the C calling convention.
ImportSourceSea :: String -> Type n -> ImportSource n
importSourceSeaVar :: ImportSource n -> String
importSourceSeaType :: ImportSource n -> Type n

-- | A fully qualified name, including the name of the module it is from.
data QualName n :: * -> *
QualName :: ModuleName -> n -> QualName n

-- | A hierarchical module name.
data ModuleName :: *
ModuleName :: [String] -> ModuleName

-- | Check whether this is the name of the "Main" module.
isMainModuleName :: ModuleName -> Bool
data Top a n

-- | Top-level, possibly recursive binding.
TopBind :: a -> (Bind n) -> (Exp a n) -> Top a n

-- | Data type definition.
TopData :: a -> DataDef n -> Top a n
topAnnot :: Top a n -> a
topDataDef :: Top a n -> DataDef n

-- | Data type definitions.
data DataDef n
DataDef :: !n -> [Bind n] -> [DataCtor n] -> DataDef n

-- | Data type name.
dataDefTypeName :: DataDef n -> !n

-- | Type parameters.
dataDefParams :: DataDef n -> [Bind n]

-- | Parameters and return type of each constructor.
dataDefCtors :: DataDef n -> [DataCtor n]
instance (Show a, Show n) => Show (Top a n)
instance (Show a, Show n) => Show (Module a n)
instance (NFData a, NFData n) => NFData (Top a n)
instance (NFData a, NFData n) => NFData (Module a n)

module DDC.Source.Tetra.ToCore

-- | Convert a Source Tetra module to Core Tetra.
--   
--   The Source code needs to already have been desugared and cannot
--   contain, and <tt>XDefix</tt>, <tt>XInfixOp</tt>, or <tt>XInfixVar</tt>
--   nodes, else <a>error</a>.
toCoreModule :: a -> Module a Name -> Module a Name

module DDC.Source.Tetra.Predicates

-- | Check whether an expression is a variable.
isXVar :: Exp a n -> Bool

-- | Check whether an expression is a constructor.
isXCon :: Exp a n -> Bool

-- | Check whether an expression is a <a>XVar</a> or an <a>XCon</a>, or
--   some type or witness atom.
isAtomX :: Exp a n -> Bool

-- | Check whether a witness is a <a>WVar</a> or <a>WCon</a>.
isAtomW :: Witness a n -> Bool

-- | Check whether an expression is a spec abstraction (level-1).
isXLAM :: Exp a n -> Bool

-- | Check whether an expression is a value or witness abstraction
--   (level-0).
isXLam :: Exp a n -> Bool

-- | Check whether an expression is a spec, value, or witness abstraction.
isLambdaX :: Exp a n -> Bool

-- | Check whether an expression is an <a>XApp</a>.
isXApp :: Exp a n -> Bool

-- | Check whether an expression is a <a>XLet</a>.
isXLet :: Exp a n -> Bool

-- | Check whether an expression is an <a>XType</a>
isXType :: Exp a n -> Bool

-- | Check whether an expression is an <a>XWitness</a>
isXWitness :: Exp a n -> Bool

-- | Check whether an alternative is a <a>PDefault</a>.
isPDefault :: Pat n -> Bool

module DDC.Source.Tetra.Compounds

-- | Take the outermost annotation from an expression, or Nothing if this
--   is an <a>XType</a> or <a>XWitness</a> without an annotation.
takeAnnotOfExp :: Exp a n -> Maybe a

-- | Make some nested type lambdas.
xLAMs :: a -> [Bind n] -> Exp a n -> Exp a n

-- | Make some nested value or witness lambdas.
xLams :: a -> [Bind n] -> Exp a n -> Exp a n

-- | Make some nested lambda abstractions, using a flag to indicate whether
--   the lambda is a level-1 (True), or level-0 (False) binder.
makeXLamFlags :: a -> [(Bool, Bind n)] -> Exp a n -> Exp a n

-- | Split type lambdas from the front of an expression, or <a>Nothing</a>
--   if there aren't any.
takeXLAMs :: Exp a n -> Maybe ([Bind n], Exp a n)

-- | Split nested value or witness lambdas from the front of an expression,
--   or <a>Nothing</a> if there aren't any.
takeXLams :: Exp a n -> Maybe ([Bind n], Exp a n)

-- | Split nested lambdas from the front of an expression, with a flag
--   indicating whether the lambda was a level-1 (True), or level-0 (False)
--   binder.
takeXLamFlags :: Exp a n -> Maybe ([(Bool, Bind n)], Exp a n)

-- | Build sequence of value applications.
xApps :: a -> Exp a n -> [Exp a n] -> Exp a n

-- | Build sequence of applications. Similar to <a>xApps</a> but also takes
--   list of annotations for the <a>XApp</a> constructors.
makeXAppsWithAnnots :: Exp a n -> [(Exp a n, a)] -> Exp a n

-- | Flatten an application into the function part and its arguments.
--   
--   Returns <a>Nothing</a> if there is no outer application.
takeXApps :: Exp a n -> Maybe (Exp a n, [Exp a n])

-- | Flatten an application into the function part and its arguments.
--   
--   This is like <a>takeXApps</a> above, except we know there is at least
--   one argument.
takeXApps1 :: Exp a n -> Exp a n -> (Exp a n, [Exp a n])

-- | Flatten an application into the function parts and arguments, if any.
takeXAppsAsList :: Exp a n -> [Exp a n]

-- | Destruct sequence of applications. Similar to <a>takeXAppsAsList</a>
--   but also keeps annotations for later.
takeXAppsWithAnnots :: Exp a n -> (Exp a n, [(Exp a n, a)])

-- | Flatten an application of a data constructor into the constructor and
--   its arguments.
--   
--   Returns <a>Nothing</a> if the expression isn't a constructor
--   application.
takeXConApps :: Exp a n -> Maybe (DaCon n, [Exp a n])

-- | Flatten an application of a primop into the variable and its
--   arguments.
--   
--   Returns <a>Nothing</a> if the expression isn't a primop application.
takeXPrimApps :: Exp a n -> Maybe (n, [Exp a n])

-- | The unit data constructor.
dcUnit :: DaCon n

-- | Take the name of data constructor, if there is one.
takeNameOfDaCon :: DaCon n -> Maybe n

-- | Take the type annotation of a data constructor, if we know it locally.
takeTypeOfDaCon :: DaCon n -> Maybe (Type n)

-- | Take the binds of a <a>Pat</a>.
bindsOfPat :: Pat n -> [Bind n]

-- | Construct a witness application
wApp :: a -> Witness a n -> Witness a n -> Witness a n

-- | Construct a sequence of witness applications
wApps :: a -> Witness a n -> [Witness a n] -> Witness a n

-- | Take the witness from an <a>XWitness</a> argument, if any.
takeXWitness :: Exp a n -> Maybe (Witness a n)

-- | Flatten an application into the function parts and arguments, if any.
takeWAppsAsList :: Witness a n -> [Witness a n]

-- | Flatten an application of a witness into the witness constructor name
--   and its arguments.
--   
--   Returns nothing if there is no witness constructor in head position.
takePrimWiConApps :: Witness a n -> Maybe (n, [Witness a n])

module DDC.Source.Tetra.Transform.Defix

-- | Table of infix operator definitions.
data FixTable a n
FixTable :: [FixDef a n] -> FixTable a n

-- | Infix operator definition.
data FixDef a n
FixDefPrefix :: String -> (a -> Exp a n) -> FixDef a n
fixDefSymbol :: FixDef a n -> String
fixDefExp :: FixDef a n -> a -> Exp a n
FixDefInfix :: String -> (a -> Exp a n) -> InfixAssoc -> Int -> FixDef a n
fixDefSymbol :: FixDef a n -> String
fixDefExp :: FixDef a n -> a -> Exp a n
fixDefAssoc :: FixDef a n -> InfixAssoc
fixDefPrec :: FixDef a n -> Int

-- | Infix associativity.
data InfixAssoc

-- | Left associative.
InfixLeft :: InfixAssoc

-- | Right associative.
InfixRight :: InfixAssoc

-- | Non associative.
InfixNone :: InfixAssoc

-- | Default fixity table for infix operators.
defaultFixTable :: FixTable SourcePos Name

-- | Things that can go wrong when defixing code.
data Error a n

-- | Infix operator symbol has no infix definition.
ErrorNoInfixDef :: a -> String -> Error a n
errorAnnot :: Error a n -> a
errorSymbol :: Error a n -> String

-- | Two non-associative operators with the same precedence.
ErrorDefixNonAssoc :: String -> a -> String -> a -> Error a n
errorOp1 :: Error a n -> String
errorAnnot1 :: Error a n -> a
errorOp2 :: Error a n -> String
errorAnnot2 :: Error a n -> a

-- | Two operators of different associativies with same precedence.
ErrorDefixMixedAssoc :: a -> [String] -> Error a n
errorAnnot :: Error a n -> a
errorOps :: Error a n -> [String]

-- | Infix expression is malformed. Eg <a>+ 3</a> or <a>2 + + 2</a>
ErrorMalformed :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorExp :: Error a n -> Exp a n
class Defix (c :: * -> * -> *)
defix :: Defix c => FixTable a n -> c a n -> Either (Error a n) (c a n)
instance Defix Alt
instance Defix Lets
instance Defix Exp
instance Defix Top
instance Defix Module

module DDC.Source.Tetra.Parser

-- | A parser of core language tokens.
type Parser n a = Parser (Tok n) a

-- | Configuration and information from the context. Used for context
--   sensitive parsing.
data Context :: *
Context :: Bool -> Bool -> Bool -> Bool -> Context
contextTrackedEffects :: Context -> Bool
contextTrackedClosures :: Context -> Bool
contextFunctionalEffects :: Context -> Bool
contextFunctionalClosures :: Context -> Bool

-- | Parse a source tetra module.
pModule :: (Ord n, Pretty n) => Context -> Parser n (Module SourcePos n)

-- | Parse a core language expression.
pExp :: Ord n => Context -> Parser n (Exp SourcePos n)
pExpApp :: Ord n => Context -> Parser n (Exp SourcePos n)

-- | Parse a variable, constructor or parenthesised expression.
pExpAtom :: Ord n => Context -> Parser n (Exp SourcePos n)

-- | Parse a type.
pType :: Ord n => Context -> Parser n (Type n)

-- | Parse a type application.
pTypeApp :: Ord n => Context -> Parser n (Type n)

-- | Parse a variable, constructor or parenthesised type.
pTypeAtom :: Ord n => Context -> Parser n (Type n)

-- | Parse a witness expression.
pWitness :: Ord n => Context -> Parser n (Witness SourcePos n)

-- | Parse a witness application.
pWitnessApp :: Ord n => Context -> Parser n (Witness SourcePos n)

-- | Parse a variable, constructor or parenthesised witness.
pWitnessAtom :: Ord n => Context -> Parser n (Witness SourcePos n)

-- | Parse a constructor name.
pCon :: Eq (Tok n) => ParsecT [Token (Tok n)] (ParserState (Tok n)) Identity n

-- | Parse a literal.
pLit :: Eq (Tok n) => ParsecT [Token (Tok n)] (ParserState (Tok n)) Identity n

-- | Parse a binder.
pBinder :: (Ord n, Eq (Tok n)) => ParsecT [Token (Tok n)] (ParserState (Tok n)) Identity (Binder n)

-- | Parse a deBruijn index.
pIndex :: Eq (Tok n) => ParsecT [Token (Tok n)] (ParserState (Tok n)) Identity Int

-- | Parse a variable.
pVar :: Eq (Tok n) => ParsecT [Token (Tok n)] (ParserState (Tok n)) Identity n

-- | Parse a constructor or variable name.
pName :: Eq (Tok n) => ParsecT [Token (Tok n)] (ParserState (Tok n)) Identity n

-- | Parse an atomic token.
pTok :: TokAtom -> Parser n ()

-- | Parse an atomic token and return some value.
pTokAs :: TokAtom -> a -> Parser n a


-- | Pretty printing for Tetra modules and expressions.
module DDC.Source.Tetra.Pretty
instance (Pretty n, Eq n) => Pretty (Lets a n)
instance (Pretty n, Eq n) => Pretty (Cast a n)
instance (Pretty n, Eq n) => Pretty (Alt a n)
instance (Pretty n, Eq n) => Pretty (Exp a n)
instance (Pretty n, Eq n) => Pretty (Top a n)
instance (Pretty n, Eq n) => Pretty (Module a n)

module DDC.Source.Tetra.Transform.Expand

-- | Expander configuration.
data Config a n
Config :: (Kind n -> Type n) -> Config a n

-- | Make a type hole of the given kind.
configMakeTypeHole :: Config a n -> Kind n -> Type n

-- | Default expander configuration.
configDefault :: Config a Name
class Expand (c :: * -> * -> *)
expand :: (Expand c, Ord n) => Config a n -> KindEnv n -> TypeEnv n -> c a n -> c a n
instance Expand Alt
instance Expand Exp
instance Expand Top
instance Expand Module
