-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Optimization over arbitrary search spaces
--   
@package spaceprobe
@version 0.3.0


-- | An applicative combinator library for parameter optimization designed
--   to perform well over high-dimensional and/or discontinuous search
--   spaces, using Monte-Carlo Tree Search with several enhancements.
module Control.SpaceProbe.Internal.Probe

-- | The main data structure for this module; it describes a search space
--   and an associated exploration strategy.
--   
--   This type is an instance of the following classes:
--   
--   <ul>
--   <li><a>Functor</a> which does the obvious thing.</li>
--   <li><a>Applicative</a>, which allows us to combine multiple search
--   spaces and optimize over them simultaneously.</li>
--   <li><a>Alternative</a>, which allows us to optimize over the disjoint
--   union of two search spaces.</li>
--   </ul>
data Probe t
Probe :: s -> (s -> Forest s) -> (s -> Maybe t) -> Probe t

-- | The initial search space.
_initial :: Probe t -> s

-- | A function to partition a given search space and remove its
--   representative from contention
_partition :: Probe t -> s -> Forest s

-- | Try to choose a 'representative element' from the search space. For
--   example, if the search space were the interval [0, 10), a suitable
--   representative might be the midpoint 5. After the initial search space
--   has been recursively partitioned as deeply as possible, every possible
--   element should be the representative of exactly one subspace.
_draw :: Probe t -> s -> Maybe t

-- | generate a partition function to be use in the construction of custom
--   Probes.
newPartition :: (s -> [s]) -> (s -> Forest s)
tipConcatMap :: (a -> Forest a) -> Tree a -> Tree a
ave :: Num a => (a -> a -> a) -> a -> a -> a
floatAve :: Floating a => a -> a -> a
intAve :: Integral a => a -> a -> a

-- | Uses inverse transform sampling to draw from a probability
--   distribution given the associated inverse cumulative distribution
--   function.
distribution :: Floating b => (b -> a) -> Probe a

-- | Sample from the exponential distribution with given mean. Useful for
--   constants which are potentially unbounded but probably small.
exponential :: Floating a => a -> Probe a

-- | Sample from the normal distribution with given mean and standard
--   deviation
normal :: (Eq a, InvErf a) => a -> a -> Probe a

-- | Sample uniformly from the interval [a, b).
uniform :: Floating a => a -> a -> Probe a
bisect :: (Integral a, Num b, Ord b) => (a -> b) -> b -> a -> a -> a

-- | Approximately sample from a probability distribution over the range
--   [a, b). Relies on splitting the range into regions of approximately
--   equal probability so will be less accurate for small ranges or highly
--   unequal distributions.
intDistribution :: (Integral a, Floating b, Ord b) => (a -> b) -> a -> a -> Probe a
exponentialInt :: (Bounded a, Integral a) => Float -> Probe a

-- | Sample from an approximate normal distribution with given mean and
--   standard deviation. May fail if a very large mean and/or standard
--   deviation is given.
normalInt :: (Bounded a, Integral a) => Float -> Float -> Probe a

-- | Sample uniformly from the interval [a, b).
uniformInt :: (Eq a, Integral a) => a -> a -> Probe a

-- | Choose from a list of constants with equal probability.
constants :: [a] -> Probe a
permutation :: [Integer] -> [a] -> Integer -> [a]

-- | Samples uniformly from permutations of <tt>xs</tt>. Makes the
--   assumption that permutations which are lexicographically close are
--   likely to have similar fitness.
permute :: [a] -> Probe [a]
extractElem :: [a] -> [(a, [a])]

-- | Samples sublists of <tt>xs</tt> of size <tt>k</tt>. The order of
--   elements in <tt>xs</tt> is irrelevant.
sizedSublist :: Int -> [a] -> Probe [a]

-- | Samples sublists of <tt>xs</tt> of size <tt>k</tt> with replacement.
--   The order of elements in <tt>xs</tt> is irrelevant.
sizedWithReplacement :: Int -> [a] -> Probe [a]

-- | Samples progressively larger sublists of <tt>xs</tt>. More
--   <tt>important</tt> elements (those which are likely to affect the
--   fitness of a sample more) should ideally be placed closest to the
--   start of <tt>xs</tt>.
sublist :: [a] -> Probe [a]

-- | Samples progressively larger sublists of <tt>xs</tt> with replacement.
--   The order of elements in <tt>xs</tt> is irrelevant.
withReplacement :: [a] -> Probe [a]
instance Alternative Probe
instance Applicative Probe
instance Functor Probe


-- | An applicative combinator library for parameter optimization designed
--   to perform well over high-dimensional and/or discontinuous search
--   spaces, using Monte-Carlo Tree Search with several enhancements.
module Control.SpaceProbe.Internal.Optimize
data SearchNode t
SearchNode :: t -> !Float -> !Float -> !Int64 -> !Int16 -> !Int16 -> SearchNode t
_value :: SearchNode t -> t
_mean :: SearchNode t -> !Float
_maximum :: SearchNode t -> !Float
_playouts :: SearchNode t -> !Int64
_numchildren :: SearchNode t -> !Int16
_exploredChildren :: SearchNode t -> !Int16
data SearchTree t
SearchTree :: !(SearchNode (Maybe t)) -> ![SearchTree t] -> SearchTree t
_node :: SearchTree t -> !(SearchNode (Maybe t))
_children :: SearchTree t -> ![SearchTree t]
searchTree :: Probe t -> SearchTree t
i2f :: Integral a => a -> Float
update :: SearchNode t -> Float -> Bool -> (SearchNode t, Bool)
ucb :: Int64 -> Float -> Float -> SearchNode t -> Float
insertOn :: Ord b => (a -> b) -> a -> [a] -> [a]
insert :: Float -> Float -> Int64 -> (SearchTree a) -> [SearchTree a] -> [SearchTree a]
data PlayoutResult t
PlayoutResult :: !(SearchTree t) -> !t -> !Float -> !Float -> !Float -> !Bool -> PlayoutResult t
_tree :: PlayoutResult t -> !(SearchTree t)
_input :: PlayoutResult t -> !t
_eval :: PlayoutResult t -> !Float
_min :: PlayoutResult t -> !Float
_max :: PlayoutResult t -> !Float
_fullyExplored :: PlayoutResult t -> !Bool
playoutM :: Monad m => (t -> m Float) -> Float -> Float -> SearchTree t -> m (PlayoutResult t)
maximize_ :: Monad m => (m [(t, Float)] -> m [(t, Float)]) -> (t -> m Float) -> Probe t -> m [(t, Float)]

-- | Fairly self-explanatory. Maximize the objective function <tt>eval</tt>
--   over the given <tt>Probe</tt>. Keeps lazily generating samples until
--   it explores the whole search space so you almost certainly want to
--   apply some cut-off criterion.
maximize :: (t -> Float) -> Probe t -> [(t, Float)]

-- | The opposite of maximize.
--   
--   <pre>
--   minimize eval = map (fmap negate) . maximize (negate . eval)
--   </pre>
minimize :: (t -> Float) -> Probe t -> [(t, Float)]
type OptimizeM m t = (t -> m Float) -> Probe t -> m [(t, Float)]
invert :: Monad m => OptimizeM m t -> OptimizeM m t

-- | Maximize in the given monad. The underlying bind operator must be lazy
--   if you want to generate the result list incrementally.
maximizeM :: Monad m => (t -> m Float) -> Probe t -> m [(t, Float)]

-- | The opposite of maximizeM
minimizeM :: Monad m => (t -> m Float) -> Probe t -> m [(t, Float)]

-- | The equivalent of maximize, but running in the IO Monad. Generates the
--   output list lazily.
maximizeIO :: (t -> IO Float) -> Probe t -> IO [(t, Float)]

-- | The opposite of maximizeIO
minimizeIO :: (t -> IO Float) -> Probe t -> IO [(t, Float)]
highestYet_ :: Ord b => (a -> b) -> [a] -> [a]
lowestYet_ :: (Num b, Ord b) => (a -> b) -> [a] -> [a]

-- | Preserves only those elements <tt>(_, b)</tt> for which <tt>b</tt> is
--   higher than for all previous previous values in the list. Designed for
--   use with maximization
highestYet :: [(a, Float)] -> [(a, Float)]

-- | Preserves only those elements <tt>(_, b)</tt> for which <tt>b</tt> is
--   lower than for all previous values in the list. Designed for use with
--   minimization.
--   
--   <pre>
--   lowestYet xs == map (fmap negate) . highestYet . map (fmap negate)
--   </pre>
lowestYet :: [(a, Float)] -> [(a, Float)]
getTimeInUsecs :: IO Int64

-- | Take the largest prefix of <tt>xs</tt> which can be evaluated within
--   <tt>dt</tt> microseconds.
evaluateForusecs :: Int -> [a] -> IO [a]
instance Show t => Show (SearchNode t)
instance Show t => Show (SearchTree t)


-- | An applicative combinator library for parameter optimization designed
--   to perform well over high-dimensional and/or discontinuous search
--   spaces, using Monte-Carlo Tree Search with several enhancements.
module Control.SpaceProbe

-- | The main data structure for this module; it describes a search space
--   and an associated exploration strategy.
--   
--   This type is an instance of the following classes:
--   
--   <ul>
--   <li><a>Functor</a> which does the obvious thing.</li>
--   <li><a>Applicative</a>, which allows us to combine multiple search
--   spaces and optimize over them simultaneously.</li>
--   <li><a>Alternative</a>, which allows us to optimize over the disjoint
--   union of two search spaces.</li>
--   </ul>
data Probe t
Probe :: s -> (s -> Forest s) -> (s -> Maybe t) -> Probe t

-- | The initial search space.
_initial :: Probe t -> s

-- | A function to partition a given search space and remove its
--   representative from contention
_partition :: Probe t -> s -> Forest s

-- | Try to choose a 'representative element' from the search space. For
--   example, if the search space were the interval [0, 10), a suitable
--   representative might be the midpoint 5. After the initial search space
--   has been recursively partitioned as deeply as possible, every possible
--   element should be the representative of exactly one subspace.
_draw :: Probe t -> s -> Maybe t

-- | generate a partition function to be use in the construction of custom
--   Probes.
newPartition :: (s -> [s]) -> (s -> Forest s)

-- | Uses inverse transform sampling to draw from a probability
--   distribution given the associated inverse cumulative distribution
--   function.
distribution :: Floating b => (b -> a) -> Probe a

-- | Sample from the exponential distribution with given mean. Useful for
--   constants which are potentially unbounded but probably small.
exponential :: Floating a => a -> Probe a

-- | Sample from the normal distribution with given mean and standard
--   deviation
normal :: (Eq a, InvErf a) => a -> a -> Probe a

-- | Sample uniformly from the interval [a, b).
uniform :: Floating a => a -> a -> Probe a

-- | Approximately sample from a probability distribution over the range
--   [a, b). Relies on splitting the range into regions of approximately
--   equal probability so will be less accurate for small ranges or highly
--   unequal distributions.
intDistribution :: (Integral a, Floating b, Ord b) => (a -> b) -> a -> a -> Probe a
exponentialInt :: (Bounded a, Integral a) => Float -> Probe a

-- | Sample from an approximate normal distribution with given mean and
--   standard deviation. May fail if a very large mean and/or standard
--   deviation is given.
normalInt :: (Bounded a, Integral a) => Float -> Float -> Probe a

-- | Sample uniformly from the interval [a, b).
uniformInt :: (Eq a, Integral a) => a -> a -> Probe a

-- | Choose from a list of constants with equal probability.
constants :: [a] -> Probe a

-- | Samples uniformly from permutations of <tt>xs</tt>. Makes the
--   assumption that permutations which are lexicographically close are
--   likely to have similar fitness.
permute :: [a] -> Probe [a]

-- | Samples sublists of <tt>xs</tt> of size <tt>k</tt>. The order of
--   elements in <tt>xs</tt> is irrelevant.
sizedSublist :: Int -> [a] -> Probe [a]

-- | Samples sublists of <tt>xs</tt> of size <tt>k</tt> with replacement.
--   The order of elements in <tt>xs</tt> is irrelevant.
sizedWithReplacement :: Int -> [a] -> Probe [a]

-- | Samples progressively larger sublists of <tt>xs</tt>. More
--   <tt>important</tt> elements (those which are likely to affect the
--   fitness of a sample more) should ideally be placed closest to the
--   start of <tt>xs</tt>.
sublist :: [a] -> Probe [a]

-- | Samples progressively larger sublists of <tt>xs</tt> with replacement.
--   The order of elements in <tt>xs</tt> is irrelevant.
withReplacement :: [a] -> Probe [a]

-- | Fairly self-explanatory. Maximize the objective function <tt>eval</tt>
--   over the given <tt>Probe</tt>. Keeps lazily generating samples until
--   it explores the whole search space so you almost certainly want to
--   apply some cut-off criterion.
maximize :: (t -> Float) -> Probe t -> [(t, Float)]

-- | The opposite of maximize.
--   
--   <pre>
--   minimize eval = map (fmap negate) . maximize (negate . eval)
--   </pre>
minimize :: (t -> Float) -> Probe t -> [(t, Float)]

-- | Maximize in the given monad. The underlying bind operator must be lazy
--   if you want to generate the result list incrementally.
maximizeM :: Monad m => (t -> m Float) -> Probe t -> m [(t, Float)]

-- | The opposite of maximizeM
minimizeM :: Monad m => (t -> m Float) -> Probe t -> m [(t, Float)]

-- | The equivalent of maximize, but running in the IO Monad. Generates the
--   output list lazily.
maximizeIO :: (t -> IO Float) -> Probe t -> IO [(t, Float)]

-- | The opposite of maximizeIO
minimizeIO :: (t -> IO Float) -> Probe t -> IO [(t, Float)]

-- | Preserves only those elements <tt>(_, b)</tt> for which <tt>b</tt> is
--   higher than for all previous previous values in the list. Designed for
--   use with maximization
highestYet :: [(a, Float)] -> [(a, Float)]

-- | Preserves only those elements <tt>(_, b)</tt> for which <tt>b</tt> is
--   lower than for all previous values in the list. Designed for use with
--   minimization.
--   
--   <pre>
--   lowestYet xs == map (fmap negate) . highestYet . map (fmap negate)
--   </pre>
lowestYet :: [(a, Float)] -> [(a, Float)]

-- | Take the largest prefix of <tt>xs</tt> which can be evaluated within
--   <tt>dt</tt> microseconds.
evaluateForusecs :: Int -> [a] -> IO [a]
