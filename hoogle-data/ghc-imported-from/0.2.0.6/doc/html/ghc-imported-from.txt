-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Find the Haddock documentation for a symbol.
--   
--   Given a Haskell module and symbol, determine the URL to the Haddock
--   documentation for that symbol.
@package ghc-imported-from
@version 0.2.0.6


-- | Synopsis: Attempt to guess the location of the Haddock HTML
--   documentation for a given symbol in a particular module, file, and
--   line/col location.
--   
--   Latest development version:
--   <a>https://github.com/carlohamalainen/ghc-imported-from</a>.
module Language.Haskell.GhcImportedFrom
type QualifiedName = String
type Symbol = String
newtype GhcOptions

-- | List of user-supplied GHC options, refer to <tt>tets</tt> subdirectory
--   for example usage. Note that GHC API and ghc-pkg have inconsistencies
--   in the naming of options, see
--   <a>http://www.vex.net/~trebla/haskell/sicp.xhtml</a> for more details.
GhcOptions :: [String] -> GhcOptions
newtype GhcPkgOptions

-- | List of user-supplied ghc-pkg options.
GhcPkgOptions :: [String] -> GhcPkgOptions
data HaskellModule

-- | Information about an import of a Haskell module.
HaskellModule :: String -> Maybe String -> Bool -> [String] -> Maybe String -> [String] -> HaskellModule
modName :: HaskellModule -> String
modQualifier :: HaskellModule -> Maybe String
modIsImplicit :: HaskellModule -> Bool
modHiding :: HaskellModule -> [String]
modImportedAs :: HaskellModule -> Maybe String
modSpecifically :: HaskellModule -> [String]

-- | Add user-supplied GHC options to those discovered via cabl repl.
modifyDFlags :: [String] -> DynFlags -> IO ([GHCOption], DynFlags)

-- | Set GHC options and run <tt>initPackages</tt> in <a>GhcMonad</a>.
--   
--   Typical use:
--   
--   <pre>
--   defaultErrorHandler defaultFatalMessager defaultFlushOut $ do
--      runGhc (Just libdir) $ do
--          getSessionDynFlags &gt;&gt;= setDynamicFlags (GhcOptions myGhcOptionList)
--          -- do stuff
--   </pre>
setDynamicFlags :: GhcMonad m => GhcOptions -> DynFlags -> m ([GHCOption], DynFlags)

-- | Read the textual imports in a file.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; (showSDoc tracingDynFlags) . ppr &lt;$&gt; getTextualImports "test/data/Hiding.hs" "Hiding" &gt;&gt;= putStrLn
--   [ import (implicit) Prelude, import qualified Safe
--   , import System.Environment ( getArgs )
--   , import Data.List hiding ( map )
--   ]
--   </pre>
--   
--   See also <a>toHaskellModule</a> and <a>getSummary</a>.
getTextualImports :: GhcMonad m => GhcOptions -> FilePath -> String -> m ([GHCOption], [Located (ImportDecl RdrName)])

-- | Get the module summary for a particular file/module. The first and
--   second components of the return value are <tt>ghcOpts1</tt> and
--   <tt>ghcOpts2</tt>; see <a>setDynamicFlags</a>.
getSummary :: GhcMonad m => GhcOptions -> FilePath -> String -> m ([GHCOption], ModSummary)

-- | Convenience function for converting an <a>ImportDecl</a> to a
--   <a>HaskellModule</a>.
--   
--   Example:
--   
--   <pre>
--   -- Hiding.hs
--   module Hiding where
--   import Data.List hiding (map)
--   import System.Environment (getArgs)
--   import qualified Safe
--   </pre>
--   
--   then:
--   
--   <pre>
--   &gt;&gt;&gt; map toHaskellModule &lt;$&gt; getTextualImports "tests/data/data/Hiding.hs" "Hiding" &gt;&gt;= print
--   [ HaskellModule { modName = "Prelude"
--                   , modQualifier = Nothing
--                   , modIsImplicit = True
--                   , modHiding = []
--                   , modImportedAs = Nothing
--                   , modSpecifically = []
--                   }
--   , HaskellModule {modName = "Safe"
--                   , modQualifier = Nothing
--                   , modIsImplicit = False
--                   , modHiding = []
--                   , modImportedAs = Nothing
--                   , modSpecifically = []
--                   }
--   , HaskellModule { modName = "System.Environment"
--                   , modQualifier = Nothing
--                   , modIsImplicit = False
--                   , modHiding = []
--                   , modImportedAs = Nothing
--                   , modSpecifically = ["getArgs"]
--                   }
--   , HaskellModule { modName = "Data.List"
--                   , modQualifier = Nothing
--                   , modIsImplicit = False
--                   , modHiding = ["map"]
--                   , modImportedAs = Nothing
--                   , modSpecifically = []
--                   }
--   ]
--   </pre>
toHaskellModule :: Located (ImportDecl RdrName) -> HaskellModule

-- | Find all matches for a symbol in a source file. The last parameter is
--   a list of imports.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; x &lt;- lookupSymbol "tests/data/data/Hiding.hs" "Hiding" "head" ["Prelude", "Safe", "System.Environment", "Data.List"]
--   *GhcImportedFrom&gt; putStrLn . (showSDoc tdflags) . ppr $ x
--   [(GHC.List.head,
--     [GHC.List.head
--        imported from `Data.List' at tests/data/data/Hiding.hs:5:1-29
--        (and originally defined in `base:GHC.List')])]
--   </pre>
lookupSymbol :: GhcOptions -> String -> String -> String -> [String] -> Ghc [(Name, [GlobalRdrElt])]

-- | List of possible modules which have resulted in the name being in the
--   current scope. Using a global reader we get the provenance data and
--   then get the list of import specs.
symbolImportedFrom :: GlobalRdrElt -> [ModuleName]

-- | Returns True if the <a>Symbol</a> matches the end of the
--   <a>QualifiedName</a>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; postfixMatch "bar" "Foo.bar"
--   True
--   
--   &gt;&gt;&gt; postfixMatch "bar" "Foo.baz"
--   False
--   
--   &gt;&gt;&gt; postfixMatch "bar" "bar"
--   True
--   </pre>
postfixMatch :: Symbol -> QualifiedName -> Bool

-- | Get the module part of a qualified name.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; moduleOfQualifiedName "Foo.bar"
--   Just "Foo"
--   
--   &gt;&gt;&gt; moduleOfQualifiedName "Foo"
--   Nothing
--   </pre>
moduleOfQualifiedName :: QualifiedName -> Maybe String

-- | Find the possible qualified names for the symbol at line/col in the
--   given Haskell file and module.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; x &lt;- qualifiedName "tests/data/data/Muddle.hs" "Muddle" 27 5 ["Data.Maybe", "Data.List", "Data.Map", "Safe"]
--   
--   &gt;&gt;&gt; forM_ x print
--   "AbsBinds [] []\n  {Exports: [Muddle.h &lt;= h\n               &lt;&gt;]\n   Exported types: Muddle.h\n                     :: Data.Map.Base.Map GHC.Base.String GHC.Base.String\n                   [LclId]\n   Binds: h = Data.Map.Base.fromList [(\"x\", \"y\")]}"
--   "h = Data.Map.Base.fromList [(\"x\", \"y\")]"
--   "Data.Map.Base.fromList [(\"x\", \"y\")]"
--   "Data.Map.Base.fromList"
--   </pre>
qualifiedName :: GhcOptions -> FilePath -> String -> Int -> Int -> [String] -> Ghc [String]

-- | Call <tt>ghc-pkg find-module</tt> to determine that package that
--   provides a module, e.g. <tt>Prelude</tt> is defined in
--   <tt>base-4.6.0.1</tt>.
ghcPkgFindModule :: [String] -> GhcPkgOptions -> String -> IO (Maybe String)

-- | Call <tt>ghc-pkg field</tt> to get the <tt>haddock-html</tt> field for
--   a package.
ghcPkgHaddockUrl :: [String] -> GhcPkgOptions -> String -> IO (Maybe String)

-- | Convert a module name string, e.g. <tt>Data.List</tt> to
--   <tt>Data-List.html</tt>.
moduleNameToHtmlFile :: String -> String

-- | If the Haskell module has an import like <tt>import qualified
--   Data.List as DL</tt>, convert an occurence <tt>DL.fromList</tt> to the
--   qualified name using the actual module name:
--   <tt>Data.List.fromList</tt>.
--   
--   Example:
--   
--   <pre>
--   -- Muddle.hs
--   
--   module Muddle where
--   
--   import Data.Maybe
--   import qualified Data.List as DL
--   import qualified Data.Map as DM
--   import qualified Safe
--   </pre>
--   
--   then:
--   
--   <pre>
--   &gt;&gt;&gt; hmodules &lt;- map toHaskellModule &lt;$&gt; getTextualImports "tests/data/data/Muddle.hs" "Muddle"
--   
--   &gt;&gt;&gt; print $ expandMatchingAsImport "DL.fromList" hmodules
--   Just "Data.List.fromList"
--   </pre>
expandMatchingAsImport :: QualifiedName -> [HaskellModule] -> Maybe QualifiedName

-- | Return list of modules which explicitly import a symbol.
--   
--   Example:
--   
--   <pre>
--   -- Hiding.hs
--   module Hiding where
--   import Data.List hiding (map)
--   import System.Environment (getArgs)
--   import qualified Safe
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hmodules &lt;- map toHaskellModule &lt;$&gt; getTextualImports "tests/data/data/Hiding.hs" "Hiding"
--   
--   &gt;&gt;&gt; print $ specificallyMatches "getArgs" hmodules
--   [ HaskellModule { modName = "System.Environment"
--                   , modQualifier = Nothing
--                   , modIsImplicit = False
--                   , modHiding = []
--                   , modImportedAs = Nothing
--                   , modSpecifically = ["getArgs"]
--                   }
--   ]
--   </pre>
specificallyMatches :: Symbol -> [HaskellModule] -> [HaskellModule]

-- | Convert a file path to a Hackage HTML file to its equivalent on
--   <tt>https:<i></i>hackage.haskell.org</tt>.
toHackageUrl :: FilePath -> String -> String -> String

-- | When we use <a>parseName</a> to convert a <a>String</a> to a
--   <a>Name</a> we get a list of matches instead of a unique match, so we
--   end up having to guess the best match based on the qualified name.
bestPrefixMatches :: Name -> [GlobalRdrElt] -> [String]

-- | Find the haddock module. Returns a 4-tuple consisting of: module that
--   the symbol is imported from, haddock url, module, and module's HTML
--   filename.
findHaddockModule :: QualifiedName -> [HaskellModule] -> [String] -> GhcPkgOptions -> (Name, [GlobalRdrElt]) -> IO [(Maybe String, Maybe String, Maybe String, Maybe String)]

-- | Convert our match to a URL, either <tt>file:<i></i></tt> if the file
--   exists, or to <tt>hackage.org</tt> otherwise.
matchToUrl :: (Maybe String, Maybe String, Maybe String, Maybe String) -> IO String

-- | Attempt to guess the Haddock url, either a local file path or url to
--   <tt>hackage.haskell.org</tt> for the symbol in the given file, module,
--   at the specified line and column location.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; guessHaddockUrl "tests/data/data/Muddle.hs" "Muddle" "Maybe" 11 11
--   (lots of output)
--   SUCCESS: file:///home/carlo/opt/ghc-7.6.3_build/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Maybe.html
--   </pre>
guessHaddockUrl :: FilePath -> String -> Symbol -> Int -> Int -> GhcOptions -> GhcPkgOptions -> IO (Either String [String])

-- | Top level function; use this one from src/Main.hs.
haddockUrl :: Options -> FilePath -> String -> String -> Int -> Int -> IO String
getGhcOptionsViaCabalRepl :: IO (Maybe [String])
data Options
Options :: [String] -> [String] -> LineSeparator -> Options
ghcOpts :: Options -> [String]
ghcPkgOpts :: Options -> [String]
lineSeparator :: Options -> LineSeparator
defaultOptions :: Options
newtype LineSeparator
LineSeparator :: String -> LineSeparator
instance Show GhcOptions
instance Show GhcPkgOptions
instance Show HaskellModule
instance Eq HaskellModule
