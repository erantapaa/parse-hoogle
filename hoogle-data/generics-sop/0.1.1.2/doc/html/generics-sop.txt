-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic Programming using True Sums of Products
--   
@package generics-sop
@version 0.1.1.2


-- | Singleton types corresponding to type-level data structures.
--   
--   The implementation is similar, but subtly different to that of the
--   <tt><a>singletons</a></tt> package. See the <a>"True Sums of
--   Products"</a> paper for details.
module Generics.SOP.Sing

-- | Explicit singleton.
--   
--   A singleton can be used to reveal the structure of a type argument
--   that the function is quantified over.
--   
--   The family <a>Sing</a> should have at most one instance per kind, and
--   there should be a matching instance for <a>SingI</a>.

-- | Implicit singleton.
--   
--   A singleton can be used to reveal the structure of a type argument
--   that the function is quantified over.
--   
--   The class <a>SingI</a> should have instances that match the family
--   instances for <a>Sing</a>.
class SingI (a :: k)
sing :: SingI a => Sing a

-- | Occassionally it is useful to have an explicit, term-level,
--   representation of type-level lists (esp because of
--   <a>https://ghc.haskell.org/trac/ghc/ticket/9108)</a>
data Shape :: [k] -> *
ShapeNil :: Shape []
ShapeCons :: Shape xs -> Shape (x : xs)

-- | The shape of a type-level list.
shape :: SingI xs => Shape xs

-- | The length of a type-level list.
lengthSing :: SingI xs => Proxy xs -> Int
instance Ord (Shape xs)
instance Eq (Shape xs)
instance Show (Shape xs)
instance Ord (Sing x)
instance Eq (Sing x)
instance Show (Sing x)
instance Ord (Sing xs)
instance Eq (Sing xs)
instance Show (Sing xs)
instance (SingI x, SingI xs) => SingI (x : xs)
instance SingI '[]
instance SingI x


-- | Constraints for indexed datatypes.
--   
--   This module contains code that helps to specify that all elements of
--   an indexed structure must satisfy a particular constraint.
module Generics.SOP.Constraint

-- | Require a constraint for every element of a list.
--   
--   If you have a datatype that is indexed over a type-level list, then
--   you can use <a>All</a> to indicate that all elements of that
--   type-level list must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All Eq '[ Int, Bool, Char ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All Eq xs =&gt; NP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the n-ary
--   product satisfy <a>Eq</a>.

-- | Require a constraint for every element of a list of lists.
--   
--   If you have a datatype that is indexed over a type-level list of
--   lists, then you can use <a>All2</a> to indicate that all elements of
--   the innert lists must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All2 Eq '[ '[ Int ], '[ Bool, Char ] ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All2 Eq xss =&gt; SOP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the sum of
--   product satisfy <a>Eq</a>.

-- | A type-level <a>map</a>.

-- | A generalization of <a>All</a> and <a>All2</a>.
--   
--   The family <a>AllMap</a> expands to <a>All</a> or <a>All2</a>
--   depending on whether the argument is indexed by a list or a list of
--   lists.

-- | Dictionary for a constraint for all elements of a type-level list.
--   
--   A value of type <tt><a>AllDict</a> c xs</tt> captures the constraint
--   <tt><a>All</a> c xs</tt>.
data AllDict (c :: k -> Constraint) (xs :: [k])
AllDictC :: AllDict c xs
data Constraint :: BOX
instance Typeable AllDict


-- | Basic functors.
--   
--   Definitions of the type-level equivalents of <a>const</a>, <a>id</a>,
--   and (<a>.</a>), and a definition of the lifted function space.
--   
--   These datatypes are generally useful, but in this library, they're
--   primarily used as parameters for the <tt>NP</tt>, <tt>NS</tt>,
--   <tt>POP</tt>, and <tt>SOP</tt> types.
module Generics.SOP.BasicFunctors

-- | The constant type functor.
--   
--   Like <a>Constant</a>, but kind-polymorphic in its second argument and
--   with a shorter name.
newtype K (a :: *) (b :: k)
K :: a -> K

-- | Extract the contents of a <a>K</a> value.
unK :: K a b -> a

-- | The identity type functor.
--   
--   Like <a>Identity</a>, but with a shorter name.
newtype I (a :: *)
I :: a -> I

-- | Extract the contents of an <a>I</a> value.
unI :: I a -> a

-- | Composition of functors.
--   
--   Like <a>Compose</a>, but kind-polymorphic and with a shorter name.
newtype (:.:) (f :: l -> *) (g :: k -> l) (p :: k)
Comp :: (f (g p)) -> (:.:)

-- | Extract the contents of a <a>Comp</a> value.
unComp :: (f :.: g) p -> f (g p)
instance Typeable 'I
instance Show a => Show (K a b)
instance Functor (K a)
instance Foldable (K a)
instance Traversable (K a)
instance Generic (K a b)
instance Show a => Show (I a)
instance Functor I
instance Foldable I
instance Traversable I
instance Generic (I a)
instance Show (f (g p)) => Show ((:.:) f g p)
instance Generic ((:.:) f g p)
instance Datatype D1K
instance Constructor C1_0K
instance Datatype D1I
instance Constructor C1_0I
instance Datatype D1:.:
instance Constructor C1_0:.:
instance (Functor f, Functor g) => Functor (f :.: g)
instance Monad I
instance Applicative I
instance Monoid a => Applicative (K a)


-- | Classes for generalized combinators on SOP types.
--   
--   In the SOP approach to generic programming, we're predominantly
--   concerned with four structured datatypes:
--   
--   <pre>
--   <a>NP</a>  :: (k -&gt; *) -&gt; ( [k]  -&gt; *)   -- n-ary product
--   <a>NS</a>  :: (k -&gt; *) -&gt; ( [k]  -&gt; *)   -- n-ary sum
--   <a>POP</a> :: (k -&gt; *) -&gt; ([[k]] -&gt; *)   -- product of products
--   <a>SOP</a> :: (k -&gt; *) -&gt; ([[k]] -&gt; *)   -- sum of products
--   </pre>
--   
--   All of these have a kind that fits the following pattern:
--   
--   <pre>
--   (k -&gt; *) -&gt; (l -&gt; *)
--   </pre>
--   
--   These four types support similar interfaces. In order to allow reusing
--   the same combinator names for all of these types, we define various
--   classes in this module that allow the necessary generalization.
--   
--   The classes typically lift concepts that exist for kinds <tt>*</tt> or
--   <tt>* -&gt; *</tt> to datatypes of kind <tt>(k -&gt; *) -&gt; (l -&gt;
--   *)</tt>. This module also derives a number of derived combinators.
--   
--   The actual instances are defined in <a>Generics.SOP.NP</a> and
--   <a>Generics.SOP.NS</a>.
module Generics.SOP.Classes

-- | A generalization of <a>pure</a> or <a>return</a> to higher kinds.
class HPure (h :: (k -> *) -> (l -> *))
hpure :: (HPure h, SingI xs) => (forall a. f a) -> h f xs
hcpure :: (HPure h, SingI xs, AllMap h c xs) => Proxy c -> (forall a. c a => f a) -> h f xs

-- | Lifted functions.
newtype (-.->) f g a
Fn :: (f a -> g a) -> (-.->) f g a
apFn :: (-.->) f g a -> f a -> g a

-- | Construct a lifted function.
--   
--   Same as <a>Fn</a>. Only available for uniformity with the higher-arity
--   versions.
fn :: (f a -> f' a) -> (f -.-> f') a

-- | Construct a binary lifted function.
fn_2 :: (f a -> f' a -> f'' a) -> (f -.-> (f' -.-> f'')) a

-- | Construct a ternary lifted function.
fn_3 :: (f a -> f' a -> f'' a -> f''' a) -> (f -.-> (f' -.-> (f'' -.-> f'''))) a

-- | Construct a quarternary lifted function.
fn_4 :: (f a -> f' a -> f'' a -> f''' a -> f'''' a) -> (f -.-> (f' -.-> (f'' -.-> (f''' -.-> f'''')))) a

-- | Maps a structure containing sums to the corresponding product
--   structure.

-- | A generalization of <a>&lt;*&gt;</a>.
class (Prod (Prod h) ~ Prod h, HPure (Prod h)) => HAp (h :: (k -> *) -> (l -> *))
hap :: HAp h => Prod h (f -.-> g) xs -> h f xs -> h g xs

-- | A generalized form of <a>liftA</a>, which in turn is a generalized
--   <a>map</a>.
--   
--   Takes a lifted function and applies it to every element of a structure
--   while preserving its shape.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA</a> f xs = <a>hpure</a> (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA</a>, <a>liftA_NP</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs
--   <a>hliftA</a>, <a>liftA_NS</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NS</a>  f xs  -&gt; <a>NS</a>  f' xs
--   <a>hliftA</a>, <a>liftA_POP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss
--   <a>hliftA</a>, <a>liftA_SOP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>SOP</a> f xss -&gt; <a>SOP</a> f' xss
--   </pre>
hliftA :: (SingI xs, HAp h) => (forall a. f a -> f' a) -> h f xs -> h f' xs

-- | A generalized form of <a>liftA2</a>, which in turn is a generalized
--   <a>zipWith</a>.
--   
--   Takes a lifted binary function and uses it to combine two structures
--   of equal shape into a single structure.
--   
--   It either takes two product structures to a product structure, or one
--   product and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA2</a> f xs ys = <a>hpure</a> (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA2</a>, <a>liftA2_NP</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_NS</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NS</a>  f' xs  -&gt; <a>NS</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_POP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss
--   <a>hliftA2</a>, <a>liftA2_SOP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>SOP</a> f' xss -&gt; <a>SOP</a> f'' xss
--   </pre>
hliftA2 :: (SingI xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | A generalized form of <a>liftA3</a>, which in turn is a generalized
--   <a>zipWith3</a>.
--   
--   Takes a lifted ternary function and uses it to combine three
--   structures of equal shape into a single structure.
--   
--   It either takes three product structures to a product structure, or
--   two product structures and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA3</a> f xs ys zs = <a>hpure</a> (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA3</a>, <a>liftA3_NP</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs  -&gt; <a>NP</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_NS</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NS</a>  f'' xs  -&gt; <a>NS</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_POP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss -&gt; <a>POP</a> f''' xs
--   <a>hliftA3</a>, <a>liftA3_SOP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>SOP</a> f'' xss -&gt; <a>SOP</a> f''' xs
--   </pre>
hliftA3 :: (SingI xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Variant of <a>hliftA</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA</a> p f xs = <a>hcpure</a> p (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
hcliftA :: (AllMap (Prod h) c xs, SingI xs, HAp h) => Proxy c -> (forall a. c a => f a -> f' a) -> h f xs -> h f' xs

-- | Variant of <a>hcliftA2</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA2</a> p f xs ys = <a>hcpure</a> p (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
hcliftA2 :: (AllMap (Prod h) c xs, SingI xs, HAp h, HAp (Prod h)) => Proxy c -> (forall a. c a => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Variant of <a>hcliftA3</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA3</a> p f xs ys zs = <a>hcpure</a> p (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
hcliftA3 :: (AllMap (Prod h) c xs, SingI xs, HAp h, HAp (Prod h)) => Proxy c -> (forall a. c a => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Maps products to lists, and sums to identities.

-- | A class for collapsing a heterogeneous structure into a homogeneous
--   one.
class HCollapse (h :: (k -> *) -> (l -> *))
hcollapse :: (HCollapse h, SingI xs) => h (K a) xs -> CollapseTo h a

-- | A generalization of <a>sequenceA</a>.
class HAp h => HSequence (h :: (k -> *) -> (l -> *))
hsequence' :: (HSequence h, SingI xs, Applicative f) => h (f :.: g) xs -> f (h g xs)

-- | Special case of <a>hsequence'</a> where <tt>g = <a>I</a></tt>.
hsequence :: (SingI xs, HSequence h) => Applicative f => h f xs -> f (h I xs)

-- | Special case of <a>hsequence'</a> where <tt>g = <a>K</a> a</tt>.
hsequenceK :: (SingI xs, Applicative f, HSequence h) => h (K (f a)) xs -> f (h (K a) xs)
instance Typeable HPure
instance Typeable (-.->)
instance Typeable HAp
instance Typeable HCollapse
instance Typeable HSequence


-- | n-ary products (and products of products)
module Generics.SOP.NP

-- | An n-ary product.
--   
--   The product is parameterized by a type constructor <tt>f</tt> and
--   indexed by a type-level list <tt>xs</tt>. The length of the list
--   determines the number of elements in the product, and if the
--   <tt>i</tt>-th element of the list is of type <tt>x</tt>, then the
--   <tt>i</tt>-th element of the product is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble the names of the list
--   constructors.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the product
--   becomes a heterogeneous list, where the type-level list describes the
--   types of its components. For <tt><a>K</a> a</tt>, the product becomes
--   a homogeneous list, where the contents of the type-level list are
--   ignored, but its length still specifies the number of elements.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   product describes the structure of the arguments of a single data
--   constructor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   I 'x'    :* I True  :* Nil  ::  NP I       '[ Char, Bool ]
--   K 0      :* K 1     :* Nil  ::  NP (K Int) '[ Char, Bool ]
--   Just 'x' :* Nothing :* Nil  ::  NP Maybe   '[ Char, Bool ]
--   </pre>
data NP :: (k -> *) -> [k] -> *
Nil :: NP f []
(:*) :: f x -> NP f xs -> NP f (x : xs)

-- | A product of products.
--   
--   This is a 'newtype' for an <a>NP</a> of an <a>NP</a>. The elements of
--   the inner products are applications of the parameter <tt>f</tt>. The
--   type <a>POP</a> is indexed by the list of lists that determines the
--   lengths of both the outer and all the inner products, as well as the
--   types of all the elements of the inner products.
--   
--   A <a>POP</a> is reminiscent of a two-dimensional table (but the inner
--   lists can all be of different length). In the context of the SOP
--   approach to generic programming, a <a>POP</a> is useful to represent
--   information that is available for all arguments of all constructors of
--   a datatype.
newtype POP (f :: k -> *) (xss :: [[k]])
POP :: (NP (NP f) xss) -> POP

-- | Unwrap a product of products.
unPOP :: POP f xss -> NP (NP f) xss

-- | Specialization of <a>hpure</a>.
--   
--   The call <tt><a>pure_NP</a> x</tt> generates a product that contains
--   <tt>x</tt> in every element position.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; pure_NP [] :: NP [] '[Char, Bool]
--   "" :* [] :* Nil
--   
--   &gt;&gt;&gt; pure_NP (K 0) :: NP (K Int) '[Double, Int, String]
--   K 0 :* K 0 :* K 0 :* Nil
--   </pre>
pure_NP :: SingI xs => (forall a. f a) -> NP f xs

-- | Specialization of <a>hpure</a>.
--   
--   The call <tt><a>pure_POP</a> x</tt> generates a product of products
--   that contains <tt>x</tt> in every element position.
pure_POP :: SingI xss => (forall a. f a) -> POP f xss

-- | Specialization of <a>hcpure</a>.
--   
--   The call <tt><a>cpure_NP</a> p x</tt> generates a product that
--   contains <tt>x</tt> in every element position.
cpure_NP :: (All c xs, SingI xs) => Proxy c -> (forall a. c a => f a) -> NP f xs

-- | Specialization of <a>hcpure</a>.
--   
--   The call <tt><a>cpure_NP</a> p x</tt> generates a product of products
--   that contains <tt>x</tt> in every element position.
cpure_POP :: (All2 c xss, SingI xss) => Proxy c -> (forall a. c a => f a) -> POP f xss

-- | Construct a homogeneous n-ary product from a normal Haskell list.
--   
--   Returns <a>Nothing</a> if the length of the list does not exactly
--   match the expected size of the product.
fromList :: SingI xs => [a] -> Maybe (NP (K a) xs)

-- | Specialization of <a>hap</a>.
--   
--   Applies a product of (lifted) functions pointwise to a product of
--   suitable arguments.
ap_NP :: NP (f -.-> g) xs -> NP f xs -> NP g xs

-- | Specialization of <a>hap</a>.
--   
--   Applies a product of (lifted) functions pointwise to a product of
--   suitable arguments.
ap_POP :: POP (f -.-> g) xs -> POP f xs -> POP g xs

-- | Specialization of <a>hliftA</a>.
liftA_NP :: SingI xs => (forall a. f a -> g a) -> NP f xs -> NP g xs

-- | Specialization of <a>hliftA</a>.
liftA_POP :: SingI xss => (forall a. f a -> g a) -> POP f xss -> POP g xss

-- | Specialization of <a>hliftA2</a>.
liftA2_NP :: SingI xs => (forall a. f a -> g a -> h a) -> NP f xs -> NP g xs -> NP h xs

-- | Specialization of <a>hliftA2</a>.
liftA2_POP :: SingI xss => (forall a. f a -> g a -> h a) -> POP f xss -> POP g xss -> POP h xss

-- | Specialization of <a>hliftA3</a>.
liftA3_NP :: SingI xs => (forall a. f a -> g a -> h a -> i a) -> NP f xs -> NP g xs -> NP h xs -> NP i xs

-- | Specialization of <a>hliftA3</a>.
liftA3_POP :: SingI xss => (forall a. f a -> g a -> h a -> i a) -> POP f xss -> POP g xss -> POP h xss -> POP i xss

-- | Specialization of <a>hcliftA</a>.
cliftA_NP :: (All c xs, SingI xs) => Proxy c -> (forall a. c a => f a -> g a) -> NP f xs -> NP g xs

-- | Specialization of <a>hcliftA</a>.
cliftA_POP :: (All2 c xss, SingI xss) => Proxy c -> (forall a. c a => f a -> g a) -> POP f xss -> POP g xss

-- | Specialization of <a>hcliftA2</a>.
cliftA2_NP :: (All c xs, SingI xs) => Proxy c -> (forall a. c a => f a -> g a -> h a) -> NP f xs -> NP g xs -> NP h xs

-- | Specialization of <a>hcliftA2</a>.
cliftA2_POP :: (All2 c xss, SingI xss) => Proxy c -> (forall a. c a => f a -> g a -> h a) -> POP f xss -> POP g xss -> POP h xss

-- | Construct a product of dictionaries for a type-level list of lists.
--   
--   The structure of the product matches the outer list, the dictionaries
--   contained are <a>AllDict</a>-dictionaries for the inner list.
allDict_NP :: (All2 c xss, SingI xss) => Proxy c -> NP (AllDict c) xss

-- | Lift a constrained function operating on a list-indexed structure to a
--   function on a list-of-list-indexed structure.
--   
--   This is a variant of <a>hcliftA</a>.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA'</a> p f xs = <a>hpure</a> (<a>fn_2</a> $ \ <a>AllDictC</a> -&gt; f) ` <a>hap</a> ` <a>allDict_NP</a> p ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcliftA'</a> :: (<a>All2</a> c xss, <a>SingI</a> xss) =&gt; <a>Proxy</a> c -&gt; (forall xs. (<a>SingI</a> xs, <a>All</a> c xs) =&gt; f xs -&gt; f' xs) -&gt; <a>NP</a> f xss -&gt; <a>NP</a> f' xss
--   <a>hcliftA'</a> :: (<a>All2</a> c xss, <a>SingI</a> xss) =&gt; <a>Proxy</a> c -&gt; (forall xs. (<a>SingI</a> xs, <a>All</a> c xs) =&gt; f xs -&gt; f' xs) -&gt; <a>NS</a> f xss -&gt; <a>NS</a> f' xss
--   </pre>
hcliftA' :: (All2 c xss, SingI xss, Prod h ~ NP, HAp h) => Proxy c -> (forall xs. (SingI xs, All c xs) => f xs -> f' xs) -> h f xss -> h f' xss

-- | Like <a>hcliftA'</a>, but for binary functions.
hcliftA2' :: (All2 c xss, SingI xss, Prod h ~ NP, HAp h) => Proxy c -> (forall xs. (SingI xs, All c xs) => f xs -> f' xs -> f'' xs) -> Prod h f xss -> h f' xss -> h f'' xss

-- | Like <a>hcliftA'</a>, but for ternay functions.
hcliftA3' :: (All2 c xss, SingI xss, Prod h ~ NP, HAp h) => Proxy c -> (forall xs. (SingI xs, All c xs) => f xs -> f' xs -> f'' xs -> f''' xs) -> Prod h f xss -> Prod h f' xss -> h f'' xss -> h f''' xss

-- | Specialization of <a>hcliftA2'</a>.
cliftA2'_NP :: (All2 c xss, SingI xss) => Proxy c -> (forall xs. (SingI xs, All c xs) => f xs -> g xs -> h xs) -> NP f xss -> NP g xss -> NP h xss

-- | Specialization of <a>hcollapse</a>.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; collapse_NP (K 1 :* K 2 :* K 3 :* Nil)
--   [1,2,3]
--   </pre>
collapse_NP :: NP (K a) xs -> [a]

-- | Specialization of <a>hcollapse</a>.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; collapse_POP (POP ((K 'a' :* Nil) :* (K 'b' :* K 'c' :* Nil) :* Nil) :: POP (K Char) '[ '[(a :: *)], '[b, c] ])
--   ["a", "bc"]
--   </pre>
--   
--   (The type signature is only necessary in this case to fix the kind of
--   the type variables.)
collapse_POP :: SingI xss => POP (K a) xss -> [[a]]

-- | Specialization of <a>hsequence'</a>.
sequence'_NP :: Applicative f => NP (f :.: g) xs -> f (NP g xs)

-- | Specialization of <a>hsequence'</a>.
sequence'_POP :: (SingI xss, Applicative f) => POP (f :.: g) xss -> f (POP g xss)

-- | Specialization of <a>hsequence</a>.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; sequence_NP (Just 1 :* Just 2 :* Nil)
--   Just (I 1 :* I 2 :* Nil)
--   </pre>
sequence_NP :: (SingI xs, Applicative f) => NP f xs -> f (NP I xs)

-- | Specialization of <a>hsequence</a>.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; sequence_POP (POP ((Just 1 :* Nil) :* (Just 2 :* Just 3 :* Nil) :* Nil))
--   Just (POP ((I 1 :* Nil) :* ((I 2 :* (I 3 :* Nil)) :* Nil)))
--   </pre>
sequence_POP :: (SingI xss, Applicative f) => POP f xss -> f (POP I xss)
instance (All Eq (Map f xs), All Ord (Map f xs)) => Ord (NP f xs)
instance (All Eq (Map f xs)) => Eq (NP f xs)
instance (All Show (Map f xs)) => Show (NP f xs)
instance (All Show (Map (NP f) xss)) => Show (POP f xss)
instance (All Eq (Map (NP f) xss)) => Eq (POP f xss)
instance (All Eq (Map (NP f) xss), All Ord (Map (NP f) xss)) => Ord (POP f xss)
instance HSequence POP
instance HSequence NP
instance HCollapse POP
instance HCollapse NP
instance HAp POP
instance HAp NP
instance HPure POP
instance HPure NP


-- | Metadata about what a datatype looks like
--   
--   In <tt>generics-sop</tt>, the metadata is completely independent of
--   the main universe. Many generic functions will use this metadata, but
--   other don't, and yet others might need completely different metadata.
--   
--   This module defines a datatype to represent standard metadata, i.e.,
--   names of the datatype, its constructors, and possibly its record
--   selectors. Metadata descriptions are in general GADTs indexed by the
--   code of the datatype they're associated with, so matching on the
--   metadata will reveal information about the shape of the datatype.
module Generics.SOP.Metadata

-- | Metadata for a datatype.
--   
--   A value of type <tt><a>DatatypeInfo</a> c</tt> contains the
--   information about a datatype that is not contained in
--   <tt><tt>Code</tt> c</tt>. This information consists primarily of the
--   names of the datatype, its constructors, and possibly its record
--   selectors.
--   
--   The constructor indicates whether the datatype has been declared using
--   <tt>newtype</tt> or not.
data DatatypeInfo :: [[*]] -> *
ADT :: ModuleName -> DatatypeName -> NP ConstructorInfo xss -> DatatypeInfo xss
Newtype :: ModuleName -> DatatypeName -> ConstructorInfo '[x] -> DatatypeInfo '['[x]]

-- | Metadata for a single constructors.
--   
--   This is indexed by the product structure of the constructor
--   components.
data ConstructorInfo :: [*] -> *
Constructor :: ConstructorName -> ConstructorInfo xs
Infix :: ConstructorName -> Associativity -> Fixity -> ConstructorInfo '[x, y]
Record :: ConstructorName -> NP FieldInfo xs -> ConstructorInfo xs

-- | For records, this functor maps the component to its selector name.
data FieldInfo :: * -> *
FieldInfo :: FieldName -> FieldInfo a

-- | The name of a datatype.
type DatatypeName = String

-- | The name of a module.
type ModuleName = String

-- | The name of a data constructor.
type ConstructorName = String

-- | The name of a field / record selector.
type FieldName = String

-- | The fixity of an infix constructor.
type Fixity = Int

-- | Datatype to represent the associativity of a constructor
data Associativity :: *
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity
instance (All Eq (Map FieldInfo xs), All Ord (Map FieldInfo xs)) => Ord (ConstructorInfo xs)
instance (All Eq (Map FieldInfo xs)) => Eq (ConstructorInfo xs)
instance (All Show (Map FieldInfo xs)) => Show (ConstructorInfo xs)
instance (All Eq (Map ConstructorInfo xs), All Ord (Map ConstructorInfo xs)) => Ord (DatatypeInfo xs)
instance (All Eq (Map ConstructorInfo xs)) => Eq (DatatypeInfo xs)
instance (All Show (Map ConstructorInfo xs)) => Show (DatatypeInfo xs)
instance Show (FieldInfo $a)
instance Eq (FieldInfo $a)
instance Ord (FieldInfo $a)
instance Functor FieldInfo


-- | n-ary sums (and sums of products)
module Generics.SOP.NS

-- | An n-ary sum.
--   
--   The sum is parameterized by a type constructor <tt>f</tt> and indexed
--   by a type-level list <tt>xs</tt>. The length of the list determines
--   the number of choices in the sum and if the <tt>i</tt>-th element of
--   the list is of type <tt>x</tt>, then the <tt>i</tt>-th choice of the
--   sum is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble Peano-style natural
--   numbers, i.e., <a>Z</a> is for "zero", and <a>S</a> is for
--   "successor". Chaining <a>S</a> and <a>Z</a> chooses the corresponding
--   component of the sum.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z         :: f x -&gt; NS f (x ': xs)
--   S . Z     :: f y -&gt; NS f (x ': y ': xs)
--   S . S . Z :: f z -&gt; NS f (x ': y ': z ': xs)
--   ...
--   </pre>
--   
--   Note that empty sums (indexed by an empty list) have no non-bottom
--   elements.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the sum
--   becomes a direct generalization of the <a>Either</a> type to
--   arbitrarily many choices. For <tt><a>K</a> a</tt>, the result is a
--   homogeneous choice type, where the contents of the type-level list are
--   ignored, but its length specifies the number of options.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   sum describes the top-level structure of a datatype, which is a choice
--   between all of its constructors.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z (I 'x')      :: NS I       '[ Char, Bool ]
--   S (Z (I True)) :: NS I       '[ Char, Bool ]
--   S (Z (I 1))    :: NS (K Int) '[ Char, Bool ]
--   </pre>
data NS :: (k -> *) -> [k] -> *
Z :: f x -> NS f (x : xs)
S :: NS f xs -> NS f (x : xs)

-- | A sum of products.
--   
--   This is a 'newtype' for an <a>NS</a> of an <a>NP</a>. The elements of
--   the (inner) products are applications of the parameter <tt>f</tt>. The
--   type <a>SOP</a> is indexed by the list of lists that determines the
--   sizes of both the (outer) sum and all the (inner) products, as well as
--   the types of all the elements of the inner products.
--   
--   An <tt><a>SOP</a> <a>I</a></tt> reflects the structure of a normal
--   Haskell datatype. The sum structure represents the choice between the
--   different constructors, the product structure represents the arguments
--   of each constructor.
newtype SOP (f :: k -> *) (xss :: [[k]])
SOP :: (NS (NP f) xss) -> SOP

-- | Unwrap a sum of products.
unSOP :: SOP f xss -> NS (NP f) xss

-- | The type of injections into an n-ary sum.
--   
--   If you expand the type synonyms and newtypes involved, you get
--   
--   <pre>
--   Injection f xs a = (f -.-&gt; K (NS f xs)) a ~= f a -&gt; K (NS f xs) a ~= f a -&gt; NS f xs
--   </pre>
--   
--   If we pick <tt>a</tt> to be an element of <tt>xs</tt>, this indeed
--   corresponds to an injection into the sum.
type Injection (f :: k -> *) (xs :: [k]) = f -.-> K (NS f xs)

-- | Compute all injections into an n-ary sum.
--   
--   Each element of the resulting product contains one of the injections.
injections :: SingI xs => NP (Injection f xs) xs

-- | Shift an injection.
--   
--   Given an injection, return an injection into a sum that is one
--   component larger.
shift :: Injection f xs a -> Injection f (x : xs) a

-- | Apply injections to a product.
--   
--   Given a product containing all possible choices, produce a list of
--   sums by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_NP (I 'x' :* I True :* I 2 :* Nil)
--   [Z (I 'x'), S (Z (I True)), S (S (Z (I 2)))]
--   </pre>
apInjs_NP :: SingI xs => NP f xs -> [NS f xs]

-- | Apply injections to a product of product.
--   
--   This operates on the outer product only. Given a product containing
--   all possible choices (that are products), produce a list of sums (of
--   products) by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_POP (POP ((I 'x' :* Nil) :* (I True :* I 2 :* Nil) :* Nil))
--   [SOP (Z (I 'x' :* Nil)),SOP (S (Z (I True :* (I 2 :* Nil))))]
--   </pre>
apInjs_POP :: SingI xss => POP f xss -> [SOP f xss]

-- | Specialization of <a>hap</a>.
ap_NS :: NP (f -.-> g) xs -> NS f xs -> NS g xs

-- | Specialization of <a>hap</a>.
ap_SOP :: POP (f -.-> g) xs -> SOP f xs -> SOP g xs

-- | Specialization of <a>hliftA</a>.
liftA_NS :: SingI xs => (forall a. f a -> g a) -> NS f xs -> NS g xs

-- | Specialization of <a>hliftA</a>.
liftA_SOP :: SingI xss => (forall a. f a -> g a) -> SOP f xss -> SOP g xss

-- | Specialization of <a>hliftA2</a>.
liftA2_NS :: SingI xs => (forall a. f a -> g a -> h a) -> NP f xs -> NS g xs -> NS h xs

-- | Specialization of <a>hliftA2</a>.
liftA2_SOP :: SingI xss => (forall a. f a -> g a -> h a) -> POP f xss -> SOP g xss -> SOP h xss

-- | Specialization of <a>hcliftA</a>.
cliftA_NS :: (All c xs, SingI xs) => Proxy c -> (forall a. c a => f a -> g a) -> NS f xs -> NS g xs

-- | Specialization of <a>hcliftA</a>.
cliftA_SOP :: (All2 c xss, SingI xss) => Proxy c -> (forall a. c a => f a -> g a) -> SOP f xss -> SOP g xss

-- | Specialization of <a>hcliftA2</a>.
cliftA2_NS :: (All c xs, SingI xs) => Proxy c -> (forall a. c a => f a -> g a -> h a) -> NP f xs -> NS g xs -> NS h xs

-- | Specialization of <a>hcliftA2</a>.
cliftA2_SOP :: (All2 c xss, SingI xss) => Proxy c -> (forall a. c a => f a -> g a -> h a) -> POP f xss -> SOP g xss -> SOP h xss

-- | Specialization of <a>hcliftA2'</a>.
cliftA2'_NS :: (All2 c xss, SingI xss) => Proxy c -> (forall xs. (SingI xs, All c xs) => f xs -> g xs -> h xs) -> NP f xss -> NS g xss -> NS h xss

-- | Specialization of <a>hcollapse</a>.
collapse_NS :: NS (K a) xs -> a

-- | Specialization of <a>hcollapse</a>.
collapse_SOP :: SingI xss => SOP (K a) xss -> [a]

-- | Specialization of <a>hsequence'</a>.
sequence'_NS :: Applicative f => NS (f :.: g) xs -> f (NS g xs)

-- | Specialization of <a>hsequence'</a>.
sequence'_SOP :: (SingI xss, Applicative f) => SOP (f :.: g) xss -> f (SOP g xss)

-- | Specialization of <a>hsequence</a>.
sequence_NS :: (SingI xs, Applicative f) => NS f xs -> f (NS I xs)

-- | Specialization of <a>hsequence</a>.
sequence_SOP :: (SingI xss, Applicative f) => SOP f xss -> f (SOP I xss)
instance (All Eq (Map f xs), All Ord (Map f xs)) => Ord (NS f xs)
instance (All Eq (Map f xs)) => Eq (NS f xs)
instance (All Show (Map f xs)) => Show (NS f xs)
instance (All Show (Map (NP f) xss)) => Show (SOP f xss)
instance (All Eq (Map (NP f) xss)) => Eq (SOP f xss)
instance (All Eq (Map (NP f) xss), All Ord (Map (NP f) xss)) => Ord (SOP f xss)
instance HSequence SOP
instance HSequence NS
instance HCollapse SOP
instance HCollapse NS
instance HAp SOP
instance HAp NS


-- | Derive <tt>generics-sop</tt> boilerplate instances from GHC's
--   <a>Generic</a>.
--   
--   The technique being used here is described in the following paper:
--   
--   <ul>
--   <li>José Pedro Magalhães and Andres Löh. <a>Generic Generic
--   Programming</a>. Practical Aspects of Declarative Languages (PADL)
--   2014.</li>
--   </ul>
module Generics.SOP.GGP

-- | Compute the SOP code of a datatype.
--   
--   This requires that <a>Rep</a> is defined, which in turn requires that
--   the type has a <a>Generic</a> (from module <a>GHC.Generics</a>)
--   instance.
--   
--   This is the default definition for <a>Code</a>. For more info, see
--   <a>Generic</a>.
type GCode (a :: *) = ToSumCode (Rep a) []

-- | Constraint for the class that computes <a>gfrom</a>.
type GFrom a = GSumFrom (Rep a)

-- | Constraint for the class that computes <a>gto</a>.
type GTo a = GSumTo (Rep a)

-- | Constraint for the class that computes <a>gdatatypeInfo</a>.
type GDatatypeInfo a = GDatatypeInfo' (Rep a)

-- | An automatically computed version of <a>from</a>.
--   
--   This requires that the type being converted has a <a>Generic</a> (from
--   module <a>GHC.Generics</a>) instance.
--   
--   This is the default definition for <a>from</a>. For more info, see
--   <a>Generic</a>.
gfrom :: (GFrom a, Generic a) => a -> SOP I (GCode a)

-- | An automatically computed version of <a>to</a>.
--   
--   This requires that the type being converted has a <a>Generic</a> (from
--   module <a>GHC.Generics</a>) instance.
--   
--   This is the default definition for <a>to</a>. For more info, see
--   <a>Generic</a>.
gto :: (GTo a, Generic a) => SOP I (GCode a) -> a

-- | An automatically computed version of <a>datatypeInfo</a>.
--   
--   This requires that the type being converted has a <a>Generic</a> (from
--   module <a>GHC.Generics</a>) instance.
--   
--   This is the default definition for <a>datatypeInfo</a>. For more info,
--   see <a>HasDatatypeInfo</a>.
gdatatypeInfo :: GDatatypeInfo a => Proxy a -> DatatypeInfo (GCode a)
instance Typeable InfoProxy
instance Typeable GDatatypeInfo'
instance Typeable IsNewtypeShape
instance Typeable GConstructorInfos
instance Typeable GFieldInfos
instance Typeable GSingleFrom
instance Typeable GProductFrom
instance Typeable GSingleTo
instance Typeable GProductTo
instance Typeable GSumFrom
instance Typeable GSumTo
instance GSumTo a => GSumTo (M1 D c a)
instance GProductTo a => GSumTo (M1 C c a)
instance (GSumTo a, GSumTo b) => GSumTo (a :+: b)
instance GProductFrom a => GSumFrom (M1 C c a)
instance GSumFrom a => GSumFrom (M1 D c a)
instance (GSumFrom a, GSumFrom b) => GSumFrom (a :+: b)
instance GProductTo U1
instance GSingleTo a => GProductTo (M1 S c a)
instance (GProductTo a, GProductTo b) => GProductTo (a :*: b)
instance GSingleTo (K1 i a)
instance GSingleFrom a => GProductFrom (M1 S c a)
instance GProductFrom U1
instance (GProductFrom a, GProductFrom b) => GProductFrom (a :*: b)
instance GSingleFrom (K1 i a)
instance Selector c => GFieldInfos (M1 S c a)
instance GFieldInfos U1
instance (GFieldInfos a, GFieldInfos b) => GFieldInfos (a :*: b)
instance (Constructor c, GFieldInfos a, SingI (ToProductCode a '[])) => GConstructorInfos (M1 C c a)
instance GConstructorInfos V1
instance (GConstructorInfos a, GConstructorInfos b) => GConstructorInfos (a :+: b)
instance (SingI (ToSumCode a '[]), Datatype c, GConstructorInfos a) => GDatatypeInfo' (M1 D c a)


-- | Codes and interpretations
module Generics.SOP.Universe

-- | The (generic) representation of a datatype.
--   
--   A datatype is isomorphic to the sum-of-products of its code. The
--   isomorphism is witnessed by <a>from</a> and <a>to</a> from the
--   <a>Generic</a> class.
type Rep a = SOP I (Code a)

-- | The class of representable datatypes.
--   
--   The SOP approach to generic programming is based on viewing datatypes
--   as a representation (<a>Rep</a>) built from the sum of products of its
--   components. The components of are datatype are specified using the
--   <a>Code</a> type family.
--   
--   The isomorphism between the original Haskell datatype and its
--   representation is witnessed by the methods of this class, <a>from</a>
--   and <a>to</a>. So for instances of this class, the following laws
--   should (in general) hold:
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   <a>from</a> <a>.</a> <a>to</a> === <a>id</a> :: <a>Rep</a> a -&gt; <a>Rep</a> a
--   </pre>
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically.
--   
--   <i>Option 1:</i> Derive via the built-in GHC-generics. For this, you
--   need to use the <tt>DeriveGeneric</tt> extension to first derive an
--   instance of the <a>Generic</a> class from module <a>GHC.Generics</a>.
--   With this, you can then give an empty instance for <a>Generic</a>, and
--   the default definitions will just work. The pattern looks as follows:
--   
--   <pre>
--   import qualified <a>GHC.Generics</a> as GHC
--   import <a>Generics.SOP</a>
--   
--   ...
--   
--   data T = ... deriving (GHC.<a>Generic</a>, ...)
--   
--   instance <a>Generic</a> T -- empty
--   instance <a>HasDatatypeInfo</a> T -- empty, if you want/need metadata
--   </pre>
--   
--   <i>Option 2:</i> Derive via Template Haskell. For this, you need to
--   enable the <tt>TemplateHaskell</tt> extension. You can then use
--   <a>deriveGeneric</a> from module <a>Generics.SOP.TH</a> to have the
--   instance generated for you. The pattern looks as follows:
--   
--   <pre>
--   import <a>Generics.SOP</a>
--   import <a>Generics.SOP.TH</a>
--   
--   ...
--   
--   data T = ...
--   
--   <a>deriveGeneric</a> ''T -- derives <a>HasDatatypeInfo</a> as well
--   </pre>
--   
--   <i>Tradeoffs:</i> Whether to use Option 1 or 2 is mainly a matter of
--   personal taste. The version based on Template Haskell probably has
--   less run-time overhead.
--   
--   <i>Non-standard instances:</i> It is possible to give <a>Generic</a>
--   instances manually that deviate from the standard scheme, as long as
--   at least
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   </pre>
--   
--   still holds.
class (SingI (Code a), All SingI (Code a)) => Generic (a :: *) where type family Code a :: [[*]] type instance Code a = GCode a from = gfrom to = gto
from :: Generic a => a -> Rep a
to :: Generic a => Rep a -> a

-- | A class of datatypes that have associated metadata.
--   
--   It is possible to use the sum-of-products approach to generic
--   programming without metadata. If you need metadata in a function, an
--   additional constraint on this class is in order.
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically. See the documentation of
--   <a>Generic</a> for the options.
class HasDatatypeInfo a where datatypeInfo = gdatatypeInfo
datatypeInfo :: HasDatatypeInfo a => Proxy a -> DatatypeInfo (Code a)
instance Typeable Generic
instance Typeable HasDatatypeInfo


-- | Generate <tt>generics-sop</tt> boilerplate instances using Template
--   Haskell.
module Generics.SOP.TH

-- | Generate <tt>generics-sop</tt> boilerplate for the given datatype.
--   
--   This function takes the name of a datatype and generates:
--   
--   <ul>
--   <li>a <a>Code</a> instance</li>
--   <li>a <a>Generic</a> instance</li>
--   <li>a <a>HasDatatypeInfo</a> instance</li>
--   </ul>
--   
--   Note that the generated code will require the <tt>TypeFamilies</tt>
--   and <tt>DataKinds</tt> extensions to be enabled for the module.
--   
--   <i>Example:</i> If you have the datatype
--   
--   <pre>
--   data Tree = Leaf Int | Node Tree Tree
--   </pre>
--   
--   and say
--   
--   <pre>
--   deriveGeneric ''Tree
--   </pre>
--   
--   then you get code that is equivalent to:
--   
--   <pre>
--   instance Generic Tree where
--   
--     type Code Tree = '[ '[Int], '[Tree, Tree] ]
--   
--     from (Leaf x)   = SOP (   Z (I x :* Nil))
--     from (Node l r) = SOP (S (Z (I l :* I r :* Nil)))
--   
--     to (SOP    (Z (I x :* Nil)))         = Leaf x
--     to (SOP (S (Z (I l :* I r :* Nil)))) = Node l r
--     to _ = error "unreachable" -- to avoid GHC warnings
--   
--   instance HasDatatypeInfo Tree where
--     datatypeInfo _ = ADT "Main" "Tree"
--       (Constructor "Leaf" :* Constructor "Node" :* Nil)
--   </pre>
--   
--   <i>Limitations:</i> Generation does not work for GADTs, for datatypes
--   that involve existential quantification, for datatypes with unboxed
--   fields.
deriveGeneric :: Name -> Q [Dec]

-- | Like <a>deriveGeneric</a>, but omit the <a>HasDatatypeInfo</a>
--   instance.
deriveGenericOnly :: Name -> Q [Dec]


-- | Instances for <tt>Generic</tt> and <tt>HasMetadata</tt>.
--   
--   We define instances for datatypes from <tt>generics-sop</tt> and
--   <tt>base</tt> that are supported.
--   
--   (There are only instances defined in this module, so the documentation
--   is empty.)
module Generics.SOP.Instances
instance HasDatatypeInfo Number
instance Generic Number
instance HasDatatypeInfo Lexeme
instance Generic Lexeme
instance HasDatatypeInfo FormatParse
instance Generic FormatParse
instance HasDatatypeInfo FormatSign
instance Generic FormatSign
instance HasDatatypeInfo FormatAdjustment
instance Generic FormatAdjustment
instance HasDatatypeInfo FieldFormat
instance Generic FieldFormat
instance HasDatatypeInfo NewlineMode
instance Generic NewlineMode
instance HasDatatypeInfo Newline
instance Generic Newline
instance HasDatatypeInfo SeekMode
instance Generic SeekMode
instance HasDatatypeInfo BufferMode
instance Generic BufferMode
instance HasDatatypeInfo IOMode
instance Generic IOMode
instance HasDatatypeInfo ExitCode
instance Generic ExitCode
instance HasDatatypeInfo (ArgDescr a0)
instance Generic (ArgDescr a0)
instance HasDatatypeInfo (OptDescr a0)
instance Generic (OptDescr a0)
instance HasDatatypeInfo (ArgOrder a0)
instance Generic (ArgOrder a0)
instance HasDatatypeInfo CDouble
instance Generic CDouble
instance HasDatatypeInfo CFloat
instance Generic CFloat
instance HasDatatypeInfo CSUSeconds
instance Generic CSUSeconds
instance HasDatatypeInfo CUSeconds
instance Generic CUSeconds
instance HasDatatypeInfo CTime
instance Generic CTime
instance HasDatatypeInfo CClock
instance Generic CClock
instance HasDatatypeInfo CUIntMax
instance Generic CUIntMax
instance HasDatatypeInfo CIntMax
instance Generic CIntMax
instance HasDatatypeInfo CUIntPtr
instance Generic CUIntPtr
instance HasDatatypeInfo CIntPtr
instance Generic CIntPtr
instance HasDatatypeInfo CULLong
instance Generic CULLong
instance HasDatatypeInfo CLLong
instance Generic CLLong
instance HasDatatypeInfo CSigAtomic
instance Generic CSigAtomic
instance HasDatatypeInfo CWchar
instance Generic CWchar
instance HasDatatypeInfo CSize
instance Generic CSize
instance HasDatatypeInfo CPtrdiff
instance Generic CPtrdiff
instance HasDatatypeInfo CULong
instance Generic CULong
instance HasDatatypeInfo CLong
instance Generic CLong
instance HasDatatypeInfo CUInt
instance Generic CUInt
instance HasDatatypeInfo CInt
instance Generic CInt
instance HasDatatypeInfo CUShort
instance Generic CUShort
instance HasDatatypeInfo CShort
instance Generic CShort
instance HasDatatypeInfo CUChar
instance Generic CUChar
instance HasDatatypeInfo CSChar
instance Generic CSChar
instance HasDatatypeInfo CChar
instance Generic CChar
instance HasDatatypeInfo Errno
instance Generic Errno
instance HasDatatypeInfo Version
instance Generic Version
instance HasDatatypeInfo (Proxy t0)
instance Generic (Proxy t0)
instance HasDatatypeInfo (Down a0)
instance Generic (Down a0)
instance HasDatatypeInfo (Last a0)
instance Generic (Last a0)
instance HasDatatypeInfo (First a0)
instance Generic (First a0)
instance HasDatatypeInfo (Product a0)
instance Generic (Product a0)
instance HasDatatypeInfo (Sum a0)
instance Generic (Sum a0)
instance HasDatatypeInfo Any
instance Generic Any
instance HasDatatypeInfo All
instance Generic All
instance HasDatatypeInfo (Endo a0)
instance Generic (Endo a0)
instance HasDatatypeInfo (Dual a0)
instance Generic (Dual a0)
instance HasDatatypeInfo (Fixed a0)
instance Generic (Fixed a0)
instance HasDatatypeInfo ConstrRep
instance Generic ConstrRep
instance HasDatatypeInfo Fixity
instance Generic Fixity
instance HasDatatypeInfo DataRep
instance Generic DataRep
instance HasDatatypeInfo (Complex a0)
instance Generic (Complex a0)
instance HasDatatypeInfo GeneralCategory
instance Generic GeneralCategory
instance HasDatatypeInfo MaskingState
instance Generic MaskingState
instance HasDatatypeInfo ErrorCall
instance Generic ErrorCall
instance HasDatatypeInfo RecUpdError
instance Generic RecUpdError
instance HasDatatypeInfo RecSelError
instance Generic RecSelError
instance HasDatatypeInfo RecConError
instance Generic RecConError
instance HasDatatypeInfo PatternMatchFail
instance Generic PatternMatchFail
instance HasDatatypeInfo NoMethodError
instance Generic NoMethodError
instance HasDatatypeInfo Deadlock
instance Generic Deadlock
instance HasDatatypeInfo BlockedIndefinitelyOnSTM
instance Generic BlockedIndefinitelyOnSTM
instance HasDatatypeInfo BlockedIndefinitelyOnMVar
instance Generic BlockedIndefinitelyOnMVar
instance HasDatatypeInfo NestedAtomically
instance Generic NestedAtomically
instance HasDatatypeInfo NonTermination
instance Generic NonTermination
instance HasDatatypeInfo AsyncException
instance Generic AsyncException
instance HasDatatypeInfo AssertionFailed
instance Generic AssertionFailed
instance HasDatatypeInfo ArrayException
instance Generic ArrayException
instance HasDatatypeInfo ArithException
instance Generic ArithException
instance HasDatatypeInfo IOException
instance Generic IOException
instance HasDatatypeInfo [a0]
instance Generic [a0]
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0, t280, t290, t300, t310)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0, t280, t290, t300, t310)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0, t280, t290, t300)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0, t280, t290, t300)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0, t280, t290)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0, t280, t290)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0, t280)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0, t280)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0, z0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0, y0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0, x0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0, w0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0, v0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0, u0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0, t0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0, s0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0, r0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0, q0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0, p0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0, o0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0, n0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0, m0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0, l0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0, k0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0, j0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0, i0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0, i0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0, h0)
instance Generic (a0, b0, c0, d0, e0, f0, g0, h0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0, g0)
instance Generic (a0, b0, c0, d0, e0, f0, g0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0, f0)
instance Generic (a0, b0, c0, d0, e0, f0)
instance HasDatatypeInfo (a0, b0, c0, d0, e0)
instance Generic (a0, b0, c0, d0, e0)
instance HasDatatypeInfo (a0, b0, c0, d0)
instance Generic (a0, b0, c0, d0)
instance HasDatatypeInfo (a0, b0, c0)
instance Generic (a0, b0, c0)
instance HasDatatypeInfo (a0, b0)
instance Generic (a0, b0)
instance HasDatatypeInfo ()
instance Generic ()
instance HasDatatypeInfo (Either a0 b0)
instance Generic (Either a0 b0)
instance HasDatatypeInfo (Maybe a0)
instance Generic (Maybe a0)
instance HasDatatypeInfo Ordering
instance Generic Ordering
instance HasDatatypeInfo Bool
instance Generic Bool
instance HasDatatypeInfo ((:.:) f0 g0 p0)
instance Generic ((:.:) f0 g0 p0)
instance HasDatatypeInfo (K a0 b0)
instance Generic (K a0 b0)
instance HasDatatypeInfo (I a0)
instance Generic (I a0)


-- | Main module of <tt>generics-sop</tt>
--   
--   In most cases, you will probably want to import just this module, and
--   possibly <a>Generics.SOP.TH</a> if you want to use Template Haskell to
--   generate <a>Generic</a> instances for you.
--   
--   <h1>Generic programming with sums of products</h1>
--   
--   You need this library if you want to define your own generic functions
--   in the sum-of-products SOP style. Generic programming in the SOP style
--   follows the following idea:
--   
--   <ol>
--   <li>A large class of datatypes can be viewed in a uniform, structured
--   way: the choice between constructors is represented using an n-ary sum
--   (called <a>NS</a>), and the arguments of each constructor are
--   represented using an n-ary product (called <a>NP</a>).</li>
--   <li>The library captures the notion of a datatype being representable
--   in the following way. There is a class <a>Generic</a>, which for a
--   given datatype <tt>A</tt>, associates the isomorphic SOP
--   representation with the original type under the name <tt><a>Rep</a>
--   A</tt>. The class also provides functions <a>from</a> and <a>to</a>
--   that convert between <tt>A</tt> and <tt><a>Rep</a> A</tt> and witness
--   the isomorphism.</li>
--   <li>Since all <a>Rep</a> types are sums of products, you can define
--   functions over them by performing induction on the structure, of by
--   using predefined combinators that the library provides. Such functions
--   then work for all <a>Rep</a> types.</li>
--   <li>By combining the conversion functions <a>from</a> and <a>to</a>
--   with the function that works on <a>Rep</a> types, we obtain a function
--   that works on all types that are in the <a>Generic</a> class.</li>
--   <li>Most types can very easily be made an instance of <a>Generic</a>.
--   For example, if the datatype can be represented using GHC's built-in
--   approach to generic programming and has an instance for the
--   <a>Generic</a> class from module <a>GHC.Generics</a>, then an instance
--   of the SOP <a>Generic</a> can automatically be derived. There is also
--   Template Haskell code in <a>Generics.SOP.TH</a> that allows to
--   auto-generate an instance of <a>Generic</a> for most types.</li>
--   </ol>
--   
--   <h1>Example</h1>
--   
--   <h2>Instantiating a datatype for use with SOP generics</h2>
--   
--   Let's assume we have the datatypes:
--   
--   <pre>
--   data A   = C Bool | D A Int | E (B ())
--   data B a = F | G a Char Bool
--   </pre>
--   
--   To create <a>Generic</a> instances for <tt>A</tt> and <tt>B</tt> via
--   <a>GHC.Generics</a>, we say
--   
--   <pre>
--   {-# LANGUAGE DeriveGenerics #-}
--   
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   data A   = C Bool | D A Int | E (B ())
--     deriving (Show, GHC.Generic)
--   data B a = F | G a Char Bool
--     deriving (Show, GHC.Generic)
--   
--   instance Generic A     -- empty
--   instance Generic (B a) -- empty
--   </pre>
--   
--   Now we can convert between <tt>A</tt> and <tt><a>Rep</a> A</tt> (and
--   between <tt>B</tt> and <tt><a>Rep</a> B</tt>). For example,
--   
--   <pre>
--   &gt;&gt;&gt; from (D (C True) 3) :: Rep A
--   SOP (S (Z (I (C True) :* I 3 :* Nil)))
--   
--   &gt;&gt;&gt; to it :: A
--   D (C True) 3
--   </pre>
--   
--   Note that the transformation is shallow: In <tt>D (C True) 3</tt>, the
--   inner value <tt>C True</tt> of type <tt>A</tt> is not affected by the
--   transformation.
--   
--   For more details about <tt><a>Rep</a> A</tt>, have a look at the
--   <a>Generics.SOP.Universe</a> module.
--   
--   <h2>Defining a generic function</h2>
--   
--   As an example of a generic function, let us define a generic version
--   of <a>rnf</a> from the <tt>deepseq</tt> package.
--   
--   The type of <a>rnf</a> is
--   
--   <pre>
--   NFData a =&gt; a -&gt; ()
--   </pre>
--   
--   and the idea is that for a term <tt>x</tt> of type <tt>a</tt> in the
--   <a>NFData</a> class, <tt>rnf x</tt> forces complete evaluation of
--   <tt>x</tt> (i.e., evaluation to <i>normal form</i>), and returns
--   <tt>()</tt>.
--   
--   We call the generic version of this function <tt>grnf</tt>. A direct
--   definition in SOP style, making use of structural recursion on the
--   sums and products, looks as follows:
--   
--   <pre>
--   grnf :: (<a>Generic</a> a, <a>All2</a> NFData (<a>Code</a> a)) =&gt; a -&gt; ()
--   grnf x = grnfS (<a>from</a> x)
--   
--   grnfS :: (<a>All2</a> NFData xss) =&gt; <a>SOP</a> <a>I</a> xss -&gt; ()
--   grnfS (<a>SOP</a> (<a>Z</a> xs))  = grnfP xs
--   grnfS (<a>SOP</a> (<a>S</a> xss)) = grnfS (<a>SOP</a> xss)
--   
--   grnfP :: (<a>All</a> NFData xs) =&gt; <a>NP</a> <a>I</a> xs -&gt; ()
--   grnfP <a>Nil</a>         = ()
--   grnfP (<a>I</a> x <a>:*</a> xs) = x `deepseq` (grnfP xs)
--   </pre>
--   
--   The <tt>grnf</tt> function performs the conversion between <tt>a</tt>
--   and <tt><a>Rep</a> a</tt> by applying <a>from</a> and then applies
--   <tt>grnfS</tt>. The type of <tt>grnf</tt> indicates that <tt>a</tt>
--   must be in the <a>Generic</a> class so that we can apply <a>from</a>,
--   and that all the components of <tt>a</tt> (i.e., all the types that
--   occur as constructor arguments) must be in the <tt>NFData</tt> class
--   (<a>All2</a>).
--   
--   The function <tt>grnfS</tt> traverses the outer sum structure of the
--   sum of products (note that <tt><a>Rep</a> a = <a>SOP</a> <a>I</a>
--   (<a>Code</a> a)</tt>). It encodes which constructor was used to
--   construct the original argument of type <tt>a</tt>. Once we've found
--   the constructor in question (<a>Z</a>), we traverse the arguments of
--   that constructor using <tt>grnfP</tt>.
--   
--   The function <tt>grnfP</tt> traverses the product structure of the
--   constructor arguments. Each argument is evaluated using the
--   <a>deepseq</a> function from the <a>NFData</a> class. This requires
--   that all components of the product must be in the <tt>NFData</tt>
--   class (<a>All</a>) and triggers the corresponding constraints on the
--   other functions. Once the end of the product is reached (<a>Nil</a>),
--   we return <tt>()</tt>.
--   
--   <h2>Defining a generic function using combinators</h2>
--   
--   In many cases, generic functions can be written in a much more concise
--   way by avoiding the explicit structural recursion and resorting to the
--   powerful combinators provided by this library instead.
--   
--   For example, the <tt>grnf</tt> function can also be defined as a
--   one-liner as follows:
--   
--   <pre>
--   grnf :: (<a>Generic</a> a, <a>All2</a> NFData (<a>Code</a> a)) =&gt; a -&gt; ()
--   grnf = <tt>rnf</tt> . <a>hcollapse</a> . <a>hcliftA</a> (<a>Proxy</a> :: <a>Proxy</a> NFData) (\ (<a>I</a> x) -&gt; <a>K</a> (rnf x)) . <a>from</a>
--   </pre>
--   
--   The following interaction should provide an idea of the individual
--   transformation steps:
--   
--   <pre>
--   &gt;&gt;&gt; let x = G 2.5 'A' False :: B Double
--   
--   &gt;&gt;&gt; from x
--   SOP (S (Z (I 2.5 :* I 'A' :* I False :* Nil)))
--   
--   &gt;&gt;&gt; hcliftA (Proxy :: Proxy NFData) (\ (I x) -&gt; K (rnf x)) it
--   SOP (S (Z (K () :* K () :* K () :* Nil)))
--   
--   &gt;&gt;&gt; hcollapse it
--   [(),(),()]
--   
--   &gt;&gt;&gt; rnf it
--   ()
--   </pre>
--   
--   The <a>from</a> call converts into the structural representation. Via
--   <a>hcliftA</a>, we apply <tt>rnf</tt> to all the components. The
--   result is a sum of products of the same shape, but the components are
--   no longer heterogeneous (<a>I</a>), but homogeneous (<tt><a>K</a>
--   ()</tt>). A homogeneous structure can be collapsed (<a>hcollapse</a>)
--   into a normal Haskell list. Finally, <tt>rnf</tt> actually forces
--   evaluation of this list (and thereby actually drives the evaluation of
--   all the previous steps) and produces the final result.
--   
--   <h2>Using a generic function</h2>
--   
--   We can directly invoke <tt>grnf</tt> on any type that is an instance
--   of class <a>Generic</a>.
--   
--   <pre>
--   &gt;&gt;&gt; grnf (G 2.5 'A' False)
--   ()
--   
--   &gt;&gt;&gt; grnf (G 2.5 undefined False)
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   Note that the type of <tt>grnf</tt> requires that all components of
--   the type are in the <a>NFData</a> class. For a recursive datatype such
--   as <tt>B</tt>, this means that we have to make <tt>A</tt> (and in this
--   case, also <tt>B</tt>) an instance of <a>NFData</a> in order to be
--   able to use the <tt>grnf</tt> function. But we can use <tt>grnf</tt>
--   to supply the instance definitions:
--   
--   <pre>
--   instance NFData A where rnf = grnf
--   instance NFData a =&gt; NFData (B a) where rnf = grnf
--   </pre>
--   
--   <h1>More examples</h1>
--   
--   The best way to learn about how to define generic functions in the SOP
--   style is to look at a few simple examples. Examples are provided by
--   the following packages:
--   
--   <ul>
--   <li><tt><a>basic-sop</a></tt> basic examples,</li>
--   <li><tt><a>pretty-sop</a></tt> generic pretty printing,</li>
--   <li><tt><a>lens-sop</a></tt> generically computed lenses,</li>
--   <li><tt><a>json-sop</a></tt> generic JSON conversions.</li>
--   </ul>
--   
--   The generic functions in these packages use a wide variety of the
--   combinators that are offered by the library.
--   
--   <h1>Paper</h1>
--   
--   A detailed description of the ideas behind this library is provided by
--   the paper:
--   
--   <ul>
--   <li>Edsko de Vries and Andres Löh. <a>True Sums of Products</a>.
--   Workshop on Generic Programming (WGP) 2014.</li>
--   </ul>
module Generics.SOP

-- | The class of representable datatypes.
--   
--   The SOP approach to generic programming is based on viewing datatypes
--   as a representation (<a>Rep</a>) built from the sum of products of its
--   components. The components of are datatype are specified using the
--   <a>Code</a> type family.
--   
--   The isomorphism between the original Haskell datatype and its
--   representation is witnessed by the methods of this class, <a>from</a>
--   and <a>to</a>. So for instances of this class, the following laws
--   should (in general) hold:
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   <a>from</a> <a>.</a> <a>to</a> === <a>id</a> :: <a>Rep</a> a -&gt; <a>Rep</a> a
--   </pre>
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically.
--   
--   <i>Option 1:</i> Derive via the built-in GHC-generics. For this, you
--   need to use the <tt>DeriveGeneric</tt> extension to first derive an
--   instance of the <a>Generic</a> class from module <a>GHC.Generics</a>.
--   With this, you can then give an empty instance for <a>Generic</a>, and
--   the default definitions will just work. The pattern looks as follows:
--   
--   <pre>
--   import qualified <a>GHC.Generics</a> as GHC
--   import <a>Generics.SOP</a>
--   
--   ...
--   
--   data T = ... deriving (GHC.<a>Generic</a>, ...)
--   
--   instance <a>Generic</a> T -- empty
--   instance <a>HasDatatypeInfo</a> T -- empty, if you want/need metadata
--   </pre>
--   
--   <i>Option 2:</i> Derive via Template Haskell. For this, you need to
--   enable the <tt>TemplateHaskell</tt> extension. You can then use
--   <a>deriveGeneric</a> from module <a>Generics.SOP.TH</a> to have the
--   instance generated for you. The pattern looks as follows:
--   
--   <pre>
--   import <a>Generics.SOP</a>
--   import <a>Generics.SOP.TH</a>
--   
--   ...
--   
--   data T = ...
--   
--   <a>deriveGeneric</a> ''T -- derives <a>HasDatatypeInfo</a> as well
--   </pre>
--   
--   <i>Tradeoffs:</i> Whether to use Option 1 or 2 is mainly a matter of
--   personal taste. The version based on Template Haskell probably has
--   less run-time overhead.
--   
--   <i>Non-standard instances:</i> It is possible to give <a>Generic</a>
--   instances manually that deviate from the standard scheme, as long as
--   at least
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   </pre>
--   
--   still holds.
class (SingI (Code a), All SingI (Code a)) => Generic (a :: *) where type family Code a :: [[*]] type instance Code a = GCode a from = gfrom to = gto
from :: Generic a => a -> Rep a
to :: Generic a => Rep a -> a

-- | The (generic) representation of a datatype.
--   
--   A datatype is isomorphic to the sum-of-products of its code. The
--   isomorphism is witnessed by <a>from</a> and <a>to</a> from the
--   <a>Generic</a> class.
type Rep a = SOP I (Code a)

-- | An n-ary product.
--   
--   The product is parameterized by a type constructor <tt>f</tt> and
--   indexed by a type-level list <tt>xs</tt>. The length of the list
--   determines the number of elements in the product, and if the
--   <tt>i</tt>-th element of the list is of type <tt>x</tt>, then the
--   <tt>i</tt>-th element of the product is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble the names of the list
--   constructors.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the product
--   becomes a heterogeneous list, where the type-level list describes the
--   types of its components. For <tt><a>K</a> a</tt>, the product becomes
--   a homogeneous list, where the contents of the type-level list are
--   ignored, but its length still specifies the number of elements.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   product describes the structure of the arguments of a single data
--   constructor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   I 'x'    :* I True  :* Nil  ::  NP I       '[ Char, Bool ]
--   K 0      :* K 1     :* Nil  ::  NP (K Int) '[ Char, Bool ]
--   Just 'x' :* Nothing :* Nil  ::  NP Maybe   '[ Char, Bool ]
--   </pre>
data NP :: (k -> *) -> [k] -> *
Nil :: NP f []
(:*) :: f x -> NP f xs -> NP f (x : xs)

-- | An n-ary sum.
--   
--   The sum is parameterized by a type constructor <tt>f</tt> and indexed
--   by a type-level list <tt>xs</tt>. The length of the list determines
--   the number of choices in the sum and if the <tt>i</tt>-th element of
--   the list is of type <tt>x</tt>, then the <tt>i</tt>-th choice of the
--   sum is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble Peano-style natural
--   numbers, i.e., <a>Z</a> is for "zero", and <a>S</a> is for
--   "successor". Chaining <a>S</a> and <a>Z</a> chooses the corresponding
--   component of the sum.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z         :: f x -&gt; NS f (x ': xs)
--   S . Z     :: f y -&gt; NS f (x ': y ': xs)
--   S . S . Z :: f z -&gt; NS f (x ': y ': z ': xs)
--   ...
--   </pre>
--   
--   Note that empty sums (indexed by an empty list) have no non-bottom
--   elements.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the sum
--   becomes a direct generalization of the <a>Either</a> type to
--   arbitrarily many choices. For <tt><a>K</a> a</tt>, the result is a
--   homogeneous choice type, where the contents of the type-level list are
--   ignored, but its length specifies the number of options.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   sum describes the top-level structure of a datatype, which is a choice
--   between all of its constructors.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z (I 'x')      :: NS I       '[ Char, Bool ]
--   S (Z (I True)) :: NS I       '[ Char, Bool ]
--   S (Z (I 1))    :: NS (K Int) '[ Char, Bool ]
--   </pre>
data NS :: (k -> *) -> [k] -> *
Z :: f x -> NS f (x : xs)
S :: NS f xs -> NS f (x : xs)

-- | A sum of products.
--   
--   This is a 'newtype' for an <a>NS</a> of an <a>NP</a>. The elements of
--   the (inner) products are applications of the parameter <tt>f</tt>. The
--   type <a>SOP</a> is indexed by the list of lists that determines the
--   sizes of both the (outer) sum and all the (inner) products, as well as
--   the types of all the elements of the inner products.
--   
--   An <tt><a>SOP</a> <a>I</a></tt> reflects the structure of a normal
--   Haskell datatype. The sum structure represents the choice between the
--   different constructors, the product structure represents the arguments
--   of each constructor.
newtype SOP (f :: k -> *) (xss :: [[k]])
SOP :: (NS (NP f) xss) -> SOP

-- | Unwrap a sum of products.
unSOP :: SOP f xss -> NS (NP f) xss

-- | A product of products.
--   
--   This is a 'newtype' for an <a>NP</a> of an <a>NP</a>. The elements of
--   the inner products are applications of the parameter <tt>f</tt>. The
--   type <a>POP</a> is indexed by the list of lists that determines the
--   lengths of both the outer and all the inner products, as well as the
--   types of all the elements of the inner products.
--   
--   A <a>POP</a> is reminiscent of a two-dimensional table (but the inner
--   lists can all be of different length). In the context of the SOP
--   approach to generic programming, a <a>POP</a> is useful to represent
--   information that is available for all arguments of all constructors of
--   a datatype.
newtype POP (f :: k -> *) (xss :: [[k]])
POP :: (NP (NP f) xss) -> POP

-- | Unwrap a product of products.
unPOP :: POP f xss -> NP (NP f) xss

-- | Metadata for a datatype.
--   
--   A value of type <tt><a>DatatypeInfo</a> c</tt> contains the
--   information about a datatype that is not contained in
--   <tt><tt>Code</tt> c</tt>. This information consists primarily of the
--   names of the datatype, its constructors, and possibly its record
--   selectors.
--   
--   The constructor indicates whether the datatype has been declared using
--   <tt>newtype</tt> or not.
data DatatypeInfo :: [[*]] -> *
ADT :: ModuleName -> DatatypeName -> NP ConstructorInfo xss -> DatatypeInfo xss
Newtype :: ModuleName -> DatatypeName -> ConstructorInfo '[x] -> DatatypeInfo '['[x]]

-- | Metadata for a single constructors.
--   
--   This is indexed by the product structure of the constructor
--   components.
data ConstructorInfo :: [*] -> *
Constructor :: ConstructorName -> ConstructorInfo xs
Infix :: ConstructorName -> Associativity -> Fixity -> ConstructorInfo '[x, y]
Record :: ConstructorName -> NP FieldInfo xs -> ConstructorInfo xs

-- | For records, this functor maps the component to its selector name.
data FieldInfo :: * -> *
FieldInfo :: FieldName -> FieldInfo a

-- | A class of datatypes that have associated metadata.
--   
--   It is possible to use the sum-of-products approach to generic
--   programming without metadata. If you need metadata in a function, an
--   additional constraint on this class is in order.
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically. See the documentation of
--   <a>Generic</a> for the options.
class HasDatatypeInfo a where datatypeInfo = gdatatypeInfo
datatypeInfo :: HasDatatypeInfo a => Proxy a -> DatatypeInfo (Code a)

-- | The name of a datatype.
type DatatypeName = String

-- | The name of a module.
type ModuleName = String

-- | The name of a data constructor.
type ConstructorName = String

-- | The name of a field / record selector.
type FieldName = String

-- | Datatype to represent the associativity of a constructor
data Associativity :: *
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | The fixity of an infix constructor.
type Fixity = Int

-- | A generalization of <a>pure</a> or <a>return</a> to higher kinds.
class HPure (h :: (k -> *) -> (l -> *))
hpure :: (HPure h, SingI xs) => (forall a. f a) -> h f xs
hcpure :: (HPure h, SingI xs, AllMap h c xs) => Proxy c -> (forall a. c a => f a) -> h f xs

-- | Lifted functions.
newtype (-.->) f g a
Fn :: (f a -> g a) -> (-.->) f g a
apFn :: (-.->) f g a -> f a -> g a

-- | Construct a lifted function.
--   
--   Same as <a>Fn</a>. Only available for uniformity with the higher-arity
--   versions.
fn :: (f a -> f' a) -> (f -.-> f') a

-- | Construct a binary lifted function.
fn_2 :: (f a -> f' a -> f'' a) -> (f -.-> (f' -.-> f'')) a

-- | Construct a ternary lifted function.
fn_3 :: (f a -> f' a -> f'' a -> f''' a) -> (f -.-> (f' -.-> (f'' -.-> f'''))) a

-- | Construct a quarternary lifted function.
fn_4 :: (f a -> f' a -> f'' a -> f''' a -> f'''' a) -> (f -.-> (f' -.-> (f'' -.-> (f''' -.-> f'''')))) a

-- | Maps a structure containing sums to the corresponding product
--   structure.

-- | A generalization of <a>&lt;*&gt;</a>.
class (Prod (Prod h) ~ Prod h, HPure (Prod h)) => HAp (h :: (k -> *) -> (l -> *))
hap :: HAp h => Prod h (f -.-> g) xs -> h f xs -> h g xs

-- | A generalized form of <a>liftA</a>, which in turn is a generalized
--   <a>map</a>.
--   
--   Takes a lifted function and applies it to every element of a structure
--   while preserving its shape.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA</a> f xs = <a>hpure</a> (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA</a>, <a>liftA_NP</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs
--   <a>hliftA</a>, <a>liftA_NS</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NS</a>  f xs  -&gt; <a>NS</a>  f' xs
--   <a>hliftA</a>, <a>liftA_POP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss
--   <a>hliftA</a>, <a>liftA_SOP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>SOP</a> f xss -&gt; <a>SOP</a> f' xss
--   </pre>
hliftA :: (SingI xs, HAp h) => (forall a. f a -> f' a) -> h f xs -> h f' xs

-- | A generalized form of <a>liftA2</a>, which in turn is a generalized
--   <a>zipWith</a>.
--   
--   Takes a lifted binary function and uses it to combine two structures
--   of equal shape into a single structure.
--   
--   It either takes two product structures to a product structure, or one
--   product and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA2</a> f xs ys = <a>hpure</a> (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA2</a>, <a>liftA2_NP</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_NS</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NS</a>  f' xs  -&gt; <a>NS</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_POP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss
--   <a>hliftA2</a>, <a>liftA2_SOP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>SOP</a> f' xss -&gt; <a>SOP</a> f'' xss
--   </pre>
hliftA2 :: (SingI xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | A generalized form of <a>liftA3</a>, which in turn is a generalized
--   <a>zipWith3</a>.
--   
--   Takes a lifted ternary function and uses it to combine three
--   structures of equal shape into a single structure.
--   
--   It either takes three product structures to a product structure, or
--   two product structures and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA3</a> f xs ys zs = <a>hpure</a> (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA3</a>, <a>liftA3_NP</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs  -&gt; <a>NP</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_NS</a>  :: <a>SingI</a> xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NS</a>  f'' xs  -&gt; <a>NS</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_POP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss -&gt; <a>POP</a> f''' xs
--   <a>hliftA3</a>, <a>liftA3_SOP</a> :: <a>SingI</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>SOP</a> f'' xss -&gt; <a>SOP</a> f''' xs
--   </pre>
hliftA3 :: (SingI xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Variant of <a>hliftA</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA</a> p f xs = <a>hcpure</a> p (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
hcliftA :: (AllMap (Prod h) c xs, SingI xs, HAp h) => Proxy c -> (forall a. c a => f a -> f' a) -> h f xs -> h f' xs

-- | Variant of <a>hcliftA2</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA2</a> p f xs ys = <a>hcpure</a> p (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
hcliftA2 :: (AllMap (Prod h) c xs, SingI xs, HAp h, HAp (Prod h)) => Proxy c -> (forall a. c a => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Variant of <a>hcliftA3</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA3</a> p f xs ys zs = <a>hcpure</a> p (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
hcliftA3 :: (AllMap (Prod h) c xs, SingI xs, HAp h, HAp (Prod h)) => Proxy c -> (forall a. c a => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | The type of injections into an n-ary sum.
--   
--   If you expand the type synonyms and newtypes involved, you get
--   
--   <pre>
--   Injection f xs a = (f -.-&gt; K (NS f xs)) a ~= f a -&gt; K (NS f xs) a ~= f a -&gt; NS f xs
--   </pre>
--   
--   If we pick <tt>a</tt> to be an element of <tt>xs</tt>, this indeed
--   corresponds to an injection into the sum.
type Injection (f :: k -> *) (xs :: [k]) = f -.-> K (NS f xs)

-- | Compute all injections into an n-ary sum.
--   
--   Each element of the resulting product contains one of the injections.
injections :: SingI xs => NP (Injection f xs) xs

-- | Shift an injection.
--   
--   Given an injection, return an injection into a sum that is one
--   component larger.
shift :: Injection f xs a -> Injection f (x : xs) a

-- | Apply injections to a product.
--   
--   Given a product containing all possible choices, produce a list of
--   sums by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_NP (I 'x' :* I True :* I 2 :* Nil)
--   [Z (I 'x'), S (Z (I True)), S (S (Z (I 2)))]
--   </pre>
apInjs_NP :: SingI xs => NP f xs -> [NS f xs]

-- | Apply injections to a product of product.
--   
--   This operates on the outer product only. Given a product containing
--   all possible choices (that are products), produce a list of sums (of
--   products) by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_POP (POP ((I 'x' :* Nil) :* (I True :* I 2 :* Nil) :* Nil))
--   [SOP (Z (I 'x' :* Nil)),SOP (S (Z (I True :* (I 2 :* Nil))))]
--   </pre>
apInjs_POP :: SingI xss => POP f xss -> [SOP f xss]

-- | Dictionary for a constraint for all elements of a type-level list.
--   
--   A value of type <tt><a>AllDict</a> c xs</tt> captures the constraint
--   <tt><a>All</a> c xs</tt>.
data AllDict (c :: k -> Constraint) (xs :: [k])
AllDictC :: AllDict c xs

-- | Construct a product of dictionaries for a type-level list of lists.
--   
--   The structure of the product matches the outer list, the dictionaries
--   contained are <a>AllDict</a>-dictionaries for the inner list.
allDict_NP :: (All2 c xss, SingI xss) => Proxy c -> NP (AllDict c) xss

-- | Lift a constrained function operating on a list-indexed structure to a
--   function on a list-of-list-indexed structure.
--   
--   This is a variant of <a>hcliftA</a>.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA'</a> p f xs = <a>hpure</a> (<a>fn_2</a> $ \ <a>AllDictC</a> -&gt; f) ` <a>hap</a> ` <a>allDict_NP</a> p ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcliftA'</a> :: (<a>All2</a> c xss, <a>SingI</a> xss) =&gt; <a>Proxy</a> c -&gt; (forall xs. (<a>SingI</a> xs, <a>All</a> c xs) =&gt; f xs -&gt; f' xs) -&gt; <a>NP</a> f xss -&gt; <a>NP</a> f' xss
--   <a>hcliftA'</a> :: (<a>All2</a> c xss, <a>SingI</a> xss) =&gt; <a>Proxy</a> c -&gt; (forall xs. (<a>SingI</a> xs, <a>All</a> c xs) =&gt; f xs -&gt; f' xs) -&gt; <a>NS</a> f xss -&gt; <a>NS</a> f' xss
--   </pre>
hcliftA' :: (All2 c xss, SingI xss, Prod h ~ NP, HAp h) => Proxy c -> (forall xs. (SingI xs, All c xs) => f xs -> f' xs) -> h f xss -> h f' xss

-- | Like <a>hcliftA'</a>, but for binary functions.
hcliftA2' :: (All2 c xss, SingI xss, Prod h ~ NP, HAp h) => Proxy c -> (forall xs. (SingI xs, All c xs) => f xs -> f' xs -> f'' xs) -> Prod h f xss -> h f' xss -> h f'' xss

-- | Like <a>hcliftA'</a>, but for ternay functions.
hcliftA3' :: (All2 c xss, SingI xss, Prod h ~ NP, HAp h) => Proxy c -> (forall xs. (SingI xs, All c xs) => f xs -> f' xs -> f'' xs -> f''' xs) -> Prod h f xss -> Prod h f' xss -> h f'' xss -> h f''' xss

-- | Maps products to lists, and sums to identities.

-- | A class for collapsing a heterogeneous structure into a homogeneous
--   one.
class HCollapse (h :: (k -> *) -> (l -> *))
hcollapse :: (HCollapse h, SingI xs) => h (K a) xs -> CollapseTo h a

-- | A generalization of <a>sequenceA</a>.
class HAp h => HSequence (h :: (k -> *) -> (l -> *))
hsequence' :: (HSequence h, SingI xs, Applicative f) => h (f :.: g) xs -> f (h g xs)

-- | Special case of <a>hsequence'</a> where <tt>g = <a>I</a></tt>.
hsequence :: (SingI xs, HSequence h) => Applicative f => h f xs -> f (h I xs)

-- | Special case of <a>hsequence'</a> where <tt>g = <a>K</a> a</tt>.
hsequenceK :: (SingI xs, Applicative f, HSequence h) => h (K (f a)) xs -> f (h (K a) xs)

-- | Construct a homogeneous n-ary product from a normal Haskell list.
--   
--   Returns <a>Nothing</a> if the length of the list does not exactly
--   match the expected size of the product.
fromList :: SingI xs => [a] -> Maybe (NP (K a) xs)

-- | The constant type functor.
--   
--   Like <a>Constant</a>, but kind-polymorphic in its second argument and
--   with a shorter name.
newtype K (a :: *) (b :: k)
K :: a -> K

-- | Extract the contents of a <a>K</a> value.
unK :: K a b -> a

-- | The identity type functor.
--   
--   Like <a>Identity</a>, but with a shorter name.
newtype I (a :: *)
I :: a -> I

-- | Extract the contents of an <a>I</a> value.
unI :: I a -> a

-- | Composition of functors.
--   
--   Like <a>Compose</a>, but kind-polymorphic and with a shorter name.
newtype (:.:) (f :: l -> *) (g :: k -> l) (p :: k)
Comp :: (f (g p)) -> (:.:)

-- | Extract the contents of a <a>Comp</a> value.
unComp :: (f :.: g) p -> f (g p)

-- | Require a constraint for every element of a list.
--   
--   If you have a datatype that is indexed over a type-level list, then
--   you can use <a>All</a> to indicate that all elements of that
--   type-level list must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All Eq '[ Int, Bool, Char ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All Eq xs =&gt; NP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the n-ary
--   product satisfy <a>Eq</a>.

-- | Require a constraint for every element of a list of lists.
--   
--   If you have a datatype that is indexed over a type-level list of
--   lists, then you can use <a>All2</a> to indicate that all elements of
--   the innert lists must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All2 Eq '[ '[ Int ], '[ Bool, Char ] ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All2 Eq xss =&gt; SOP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the sum of
--   product satisfy <a>Eq</a>.

-- | A type-level <a>map</a>.

-- | A generalization of <a>All</a> and <a>All2</a>.
--   
--   The family <a>AllMap</a> expands to <a>All</a> or <a>All2</a>
--   depending on whether the argument is indexed by a list or a list of
--   lists.

-- | Explicit singleton.
--   
--   A singleton can be used to reveal the structure of a type argument
--   that the function is quantified over.
--   
--   The family <a>Sing</a> should have at most one instance per kind, and
--   there should be a matching instance for <a>SingI</a>.

-- | Implicit singleton.
--   
--   A singleton can be used to reveal the structure of a type argument
--   that the function is quantified over.
--   
--   The class <a>SingI</a> should have instances that match the family
--   instances for <a>Sing</a>.
class SingI (a :: k)
sing :: SingI a => Sing a

-- | Occassionally it is useful to have an explicit, term-level,
--   representation of type-level lists (esp because of
--   <a>https://ghc.haskell.org/trac/ghc/ticket/9108)</a>
data Shape :: [k] -> *
ShapeNil :: Shape []
ShapeCons :: Shape xs -> Shape (x : xs)

-- | The shape of a type-level list.
shape :: SingI xs => Shape xs

-- | The length of a type-level list.
lengthSing :: SingI xs => Proxy xs -> Int

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
