-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Human friendly BLAS and Lapack bindings for Haskell.
--   
@package hblas
@version 0.3.2.1

module Numerical.HBLAS.Lapack.FFI
newtype Fact_C
Fact_C :: CChar -> Fact_C
newtype Trans_C
Trans_C :: CChar -> Trans_C
newtype Stride_C
Stride_C :: Int32 -> Stride_C
newtype Equilib_C
Equilib_C :: CChar -> Equilib_C
type Fun_FFI_GESVX el = Ptr Fact_C -> Ptr Trans_C -> Ptr Int32 -> Ptr Int32 -> Ptr el -> Ptr Stride_C -> Ptr Double -> Ptr Stride_C -> Ptr Int32 -> Ptr Equilib_C -> Ptr el -> Ptr el -> Ptr el -> Ptr Stride_C -> Ptr el -> Ptr Stride_C -> Ptr el -> Ptr el -> Ptr el -> Ptr el -> Ptr Int32 -> Ptr Int32 -> IO ()
sgesvx :: Fun_FFI_GESVX Float
dgesvx :: Fun_FFI_GESVX Double
cgesvx :: Fun_FFI_GESVX (Complex Float)
zgesvx :: Fun_FFI_GESVX (Complex Double)
newtype JobTy
JBT :: CChar -> JobTy
newtype UploTy
UPLT :: CChar -> UploTy
newtype Info
Info :: Int32 -> Info
type SYEV_FUN_FFI elem = Ptr JobTy -> Ptr UploTy -> Ptr Int32 -> Ptr elem -> Ptr Int32 -> Ptr elem -> Ptr Info -> IO ()
ssyev_ffi :: SYEV_FUN_FFI Float
dsyev_ffi :: SYEV_FUN_FFI Double
ssyev_ffi_unsafe :: SYEV_FUN_FFI Float
dsyev_ffi_unsafe :: SYEV_FUN_FFI Double
type GESV_FUN_FFI elem = Ptr Int32 -> Ptr Int32 -> Ptr elem -> Ptr Int32 -> Ptr Int32 -> Ptr elem -> Ptr Int32 -> Ptr Info -> IO ()

-- | basic Linear system solvers. they act inplace
sgesv_ffi :: GESV_FUN_FFI Float
dgesv_ffi :: GESV_FUN_FFI Double
cgesv_ffi :: GESV_FUN_FFI (Complex Float)
zgesv_ffi :: GESV_FUN_FFI (Complex Double)
sgesv_ffi_unsafe :: GESV_FUN_FFI Float
dgesv_ffi_unsafe :: GESV_FUN_FFI Double
cgesv_ffi_unsafe :: GESV_FUN_FFI (Complex Float)
zgesv_ffi_unsafe :: GESV_FUN_FFI (Complex Double)

module Numerical.HBLAS.Lapack

module Numerical.HBLAS.Constants
flopsThreshold :: Int64

module Numerical.HBLAS.UtilsFFI
withRWStorable :: (Storable a, PrimMonad m) => a -> (Ptr a -> m b) -> m a
withRStorable :: (Storable a, PrimMonad m) => a -> (Ptr a -> m b) -> m b
withRStorable_ :: (Storable a, PrimMonad m) => a -> (Ptr a -> m ()) -> m ()
withForeignPtrPrim :: PrimMonad m => ForeignPtr a -> (Ptr a -> m b) -> m b
touchForeignPtrPrim :: PrimMonad m => ForeignPtr a -> m ()
unsafeWithPrim :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> (Ptr a -> m b) -> m b
unsafeWithPrimLen :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> ((Ptr a, Int) -> m b) -> m b
unsafeWithPurePrim :: (Storable a, PrimMonad m) => Vector a -> ((Ptr a) -> m b) -> m b
unsafeWithPurePrimLen :: (Storable a, PrimMonad m) => Vector a -> ((Ptr a, Int) -> m b) -> m b


-- | PSA, the matrix data types used in the hBLAS binding should not be
--   regarded as being general purpose matrices.
--   
--   They are designed to exactly express only the matrices which are valid
--   inputs for BLAS. When applicable, such matrices should be easily
--   mapped to and from other matrix libraries. That said, the BLAS and
--   LAPACK matrix formats capture a rich and very expressive subset of
--   Dense Matrix formats.
--   
--   The primary and hence default format is Dense Row and Column Major
--   Matrices, but support will be added for other formats that BLAS and
--   LAPACK provide operations for.
--   
--   A guiding rule of thumb for this package is that there are no generic
--   abstractions provided, merely machinery to ensure all uses of BLAS and
--   LAPACK operations can be used in their full generality in a human
--   friendly type safe fashion. It is the role of a higher level library
--   to provide any generic operations.
--   
--   One such higher level lib you can interface with easily is Numerical.
--   There is a work in progress binding to help this in the
--   numerical-hblas package (which may not be public yet at the time of
--   this writing)
module Numerical.HBLAS.MatrixTypes
data Orientation
Row :: Orientation
Column :: Orientation
type Row = Row
type Column = Column
data SOrientation :: Orientation -> *
SRow :: SOrientation Row
SColumn :: SOrientation Column
sTranpose :: (x ~ TransposeF y, y ~ TransposeF x) => SOrientation x -> SOrientation y
data Transpose
NoTranspose :: Transpose
Transpose :: Transpose
ConjTranspose :: Transpose
ConjNoTranspose :: Transpose

-- | For Symmetric, Hermetian or Triangular matrices, which part is
--   modeled.
data MatUpLo
MatUpper :: MatUpLo
MatLower :: MatUpLo

-- | Many triangular matrix routines expect to know if the matrix is all 1
--   (unit ) on the diagonal or not. Likewise, Many Factorizations routines
--   can be assumed to return unit triangular matrices
data MatDiag
MatUnit :: MatDiag
MatNonUnit :: MatDiag

-- | For certain Square matrix product, do you want to Compute A*B or B*A
--   only used as an argument
data EquationSide
LeftSide :: EquationSide
RightSide :: EquationSide
data Variant
Direct :: Variant
Implicit :: Variant

-- | <a>Variant</a> and <a>SVariant</a> are a bit odd looking, They crop up
--   when needing to talk about eg the row vectors of a packed triangular
--   row major matrix wrt both their logical size and manifest sizes this
--   notion only makes sense in the 1dim case. If you don't understand this
--   parameter, just use <a>SDirect</a> and <a>Direct</a> as they will
--   generally be the correct choice for most users.
data SVariant :: Variant -> *
SImplicit :: !Int -> {-# UNPACK #-} !Int -> SVariant Implicit
_frontPadding :: SVariant Implicit -> !Int
_endPadding :: SVariant Implicit -> {-# UNPACK #-} !Int
SDirect :: SVariant Direct
data DenseVector :: Variant -> * -> *
DenseVector :: !(SVariant varnt) -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !(Vector elem) -> DenseVector varnt elem
_VariantDenseVect :: DenseVector varnt elem -> !(SVariant varnt)
_LogicalDimDenseVector :: DenseVector varnt elem -> {-# UNPACK #-} !Int
_StrideDenseVector :: DenseVector varnt elem -> {-# UNPACK #-} !Int
_bufferDenseVector :: DenseVector varnt elem -> !(Vector elem)
data MDenseVector :: * -> Variant -> * -> *
MutableDenseVector :: !(SVariant varnt) -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !(MVector s elem) -> MDenseVector s varnt elem
_VariantMutDenseVect :: MDenseVector s varnt elem -> !(SVariant varnt)
_LogicalDimMutDenseVector :: MDenseVector s varnt elem -> {-# UNPACK #-} !Int
_StrideMutDenseVector :: MDenseVector s varnt elem -> {-# UNPACK #-} !Int
_bufferMutDenseVector :: MDenseVector s varnt elem -> !(MVector s elem)

-- | <a>DenseMatrix</a> is for dense row or column major matrices
data DenseMatrix :: Orientation -> * -> *
DenseMatrix :: SOrientation ornt -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !(Vector elem) -> DenseMatrix ornt elem
_OrientationMat :: DenseMatrix ornt elem -> SOrientation ornt
_XdimDenMat :: DenseMatrix ornt elem -> {-# UNPACK #-} !Int
_YdimDenMat :: DenseMatrix ornt elem -> {-# UNPACK #-} !Int
_StrideDenMat :: DenseMatrix ornt elem -> {-# UNPACK #-} !Int
_bufferDenMat :: DenseMatrix ornt elem -> {-# UNPACK #-} !(Vector elem)

-- | this should never be used in real code, ever ever, but its handy for
--   testing but seriously never use this in real code, it doesn't do what
--   you think because in the case of a matrix slice, the underlying buffer
--   will have additional elements aside from the ones you expect! never
--   use this in real code please. :)
mutableVectorToList :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> m [a]

-- | <a>MDenseMatrix</a>
data MDenseMatrix :: * -> Orientation -> * -> *
MutableDenseMatrix :: SOrientation ornt -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !(MVector s elem) -> MDenseMatrix s ornt elem
_OrientationMutMat :: MDenseMatrix s ornt elem -> SOrientation ornt
_XdimDenMutMat :: MDenseMatrix s ornt elem -> {-# UNPACK #-} !Int
_YdimDenMutMat :: MDenseMatrix s ornt elem -> {-# UNPACK #-} !Int
_StrideDenMutMat :: MDenseMatrix s ornt elem -> {-# UNPACK #-} !Int
_bufferDenMutMat :: MDenseMatrix s ornt elem -> {-# UNPACK #-} !(MVector s elem)
type IODenseMatrix = MDenseMatrix RealWorld
unsafeFreezeDenseMatrix :: (Storable elem, PrimMonad m) => MDenseMatrix (PrimState m) or elem -> m (DenseMatrix or elem)
unsafeThawDenseMatrix :: (Storable elem, PrimMonad m) => DenseMatrix or elem -> m (MDenseMatrix (PrimState m) or elem)
getDenseMatrixRow :: DenseMatrix or elem -> Int
getDenseMatrixColumn :: DenseMatrix or elem -> Int
getDenseMatrixLeadingDimStride :: DenseMatrix or elem -> Int
getDenseMatrixArray :: DenseMatrix or elem -> Vector elem
getDenseMatrixOrientation :: DenseMatrix or elem -> SOrientation or
uncheckedDenseMatrixIndex :: Storable elem => DenseMatrix or elem -> (Int, Int) -> elem
uncheckedDenseMatrixIndexM :: (Monad m, Storable elem) => DenseMatrix or elem -> (Int, Int) -> m elem
uncheckedMutableDenseMatrixIndexM :: (PrimMonad m, Storable elem) => MDenseMatrix (PrimState m) or elem -> (Int, Int) -> m elem
swap :: (a, b) -> (b, a)

-- | `map f matrix`
mapDenseMatrix :: (Storable a, Storable b) => (a -> b) -> DenseMatrix or a -> DenseMatrix or b
imapDenseMatrix :: (Storable a, Storable b) => ((Int, Int) -> a -> b) -> DenseMatrix or a -> DenseMatrix or b

-- | In Matrix format memory order enumeration of the index tuples, for
--   good locality 2dim map
uncheckedDenseMatrixNextTuple :: DenseMatrix or elem -> (Int, Int) -> Maybe (Int, Int)

-- | generateDenseMatrix Row (k,k) (i,j)-&gt; if i == j then 1.0 else 0.0
--   would generate a KxK identity matrix
generateDenseMatrix :: Storable a => SOrientation x -> (Int, Int) -> ((Int, Int) -> a) -> DenseMatrix x a

-- | mutable version of generateDenseMatrix
generateMutableDenseMatrix :: (Storable a, PrimMonad m) => SOrientation x -> (Int, Int) -> ((Int, Int) -> a) -> m (MDenseMatrix (PrimState m) x a)
generateMutableDenseVector :: (Storable a, PrimMonad m) => Int -> (Int -> a) -> m (MDenseVector (PrimState m) Direct a)
uncheckedDenseMatrixSlice :: Storable elem => DenseMatrix or elem -> (Int, Int) -> (Int, Int) -> DenseMatrix or elem

-- | tranposeMatrix does a shallow transpose that swaps the format and the
--   x y params, but changes nothing in the memory layout. Most
--   applications where transpose is used in a computation need a deep,
--   copying, tranpose operation
transposeDenseMatrix :: (inor ~ (TransposeF outor), outor ~ (TransposeF inor)) => DenseMatrix inor elem -> DenseMatrix outor elem
instance Typeable Orientation
instance Typeable Transpose
instance Typeable MatUpLo
instance Typeable MatDiag
instance Typeable EquationSide
instance Typeable Variant
instance Eq Orientation
instance Show Orientation
instance Eq Transpose
instance Show Transpose
instance Eq MatUpLo
instance Show MatUpLo
instance Eq MatDiag
instance Show MatDiag
instance Eq EquationSide
instance Show EquationSide
instance Eq Variant
instance Show Variant
instance (Show el, Storable el) => Show (DenseMatrix Column el)
instance (Show el, Storable el) => Show (DenseMatrix Row el)
instance Eq (SOrientation Column)
instance Eq (SOrientation Row)
instance Show (SOrientation Column)
instance Show (SOrientation Row)

module Numerical.HBLAS.BLAS.FFI

-- | For All of the BlAS FFI operations,
newtype CBLAS_INDEX
CBIndex :: CSize -> CBLAS_INDEX
newtype CBLAS_ORDERT
CBOInt :: CInt -> CBLAS_ORDERT
data BLASOrder
BLASRowMajor :: BLASOrder
BLASColMajor :: BLASOrder
encodeOrder :: BLASOrder -> CBLAS_ORDERT
newtype CBLAS_TRANSPOSET
CBLAS_TransposeT :: CInt -> CBLAS_TRANSPOSET
unCBLAS_TransposeT :: CBLAS_TRANSPOSET -> CInt
data BLAS_Transpose
BlasNoTranspose :: BLAS_Transpose
BlasTranspose :: BLAS_Transpose
BlasConjTranspose :: BLAS_Transpose
BlasConjNoTranspose :: BLAS_Transpose
encodeTranspose :: BLAS_Transpose -> CBLAS_TRANSPOSET
newtype CBLAS_UPLOT
CBlasUPLO :: CInt -> CBLAS_UPLOT
data BLASUplo
BUpper :: BLASUplo
BLower :: BLASUplo
encodeUPLO :: BLASUplo -> CBLAS_UPLOT
newtype CBLAS_DIAGT
CBLAS_DiagT :: CUChar -> CBLAS_DIAGT
data BlasDiag
BlasNonUnit :: BlasDiag
BlasUnit :: BlasDiag
encodeDiag :: BlasDiag -> CBLAS_DIAGT
newtype CBLAS_SIDET
CBLAS_SideT :: CUChar -> CBLAS_SIDET
unCBLAS_SideT :: CBLAS_SIDET -> CUChar
data BlasSide
BlasLeft :: BlasSide
BlasRight :: BlasSide
encodeSide :: BlasSide -> CBLAS_SIDET
cblas_sdsdot_unsafe :: CInt -> Float -> Ptr Float -> CInt -> Ptr Float -> CInt -> IO Float
cblas_dsdot_unsafe :: CInt -> Ptr Float -> CInt -> Ptr Float -> CInt -> IO Double
cblas_sdot_unsafe :: CInt -> Ptr Float -> CInt -> Ptr Float -> CInt -> IO Float
cblas_ddot_unsafe :: CInt -> Ptr Double -> CInt -> Ptr Double -> CInt -> IO Double
cblas_sasum_unsafe :: CInt -> Ptr Float -> CInt -> IO Float
cblas_dasum_unsafe :: CInt -> Ptr Double -> CInt -> IO Double
cblas_casum_unsafe :: CInt -> Ptr (Complex Float) -> CInt -> IO Float
cblas_zasum_unsafe :: CInt -> Ptr (Complex Double) -> CInt -> IO Double
cblas_snrm2_unsafe :: CInt -> Ptr Float -> CInt -> IO Float
cblas_dnrm2_unsafe :: CInt -> Ptr Double -> CInt -> IO Double
cblas_scnrm2_unsafe :: CInt -> Ptr (Complex Float) -> CInt -> IO Float
cblas_dznrm2_unsafe :: CInt -> Ptr (Complex Double) -> CInt -> IO Double
cblas_isamax_unsafe :: CInt -> Ptr Float -> CInt -> IO CInt
cblas_idamax_unsafe :: CInt -> Ptr Float -> CInt -> IO CInt
cblas_icamax_unsafe :: CInt -> Ptr (Complex Float) -> CInt -> IO CInt
cblas_izamax_unsafe :: CInt -> Ptr (Complex Double) -> CInt -> IO CInt
cblas_scopy_unsafe :: CInt -> Ptr Float -> CInt -> Ptr Float -> CInt -> IO ()
cblas_dcopy_unsafe :: CInt -> Ptr Double -> CInt -> Ptr Double -> CInt -> IO ()
cblas_ccopy_unsafe :: CInt -> Ptr (Complex Float) -> CInt -> Ptr (Complex Float) -> CInt -> IO ()
cblas_zcopy_unsafe :: CInt -> Ptr (Complex Double) -> CInt -> Ptr (Complex Double) -> CInt -> IO ()
cblas_sswap_unsafe :: CInt -> Ptr Float -> CInt -> Ptr Float -> CInt -> IO ()
cblas_dswap_unsafe :: CInt -> Ptr Double -> CInt -> Ptr Double -> CInt -> IO ()
cblas_cswap_unsafe :: CInt -> Ptr (Complex Float) -> CInt -> Ptr (Complex Float) -> CInt -> IO ()
cblas_zswap_unsafe :: CInt -> Ptr (Complex Double) -> CInt -> Ptr (Complex Double) -> CInt -> IO ()
type GemvFunFFI sc el = CBLAS_ORDERT -> CBLAS_TRANSPOSET -> CInt -> CInt -> sc -> Ptr el -> CInt -> Ptr el -> CInt -> sc -> Ptr el -> CInt -> IO ()
cblas_sgemv_unsafe :: GemvFunFFI Float Float
cblas_sgemv_safe :: GemvFunFFI Float Float
cblas_dgemv_unsafe :: GemvFunFFI Double Double
cblas_dgemv_safe :: GemvFunFFI Double Double
cblas_cgemv_unsafe :: GemvFunFFI (Ptr (Complex Float)) (Complex Float)
cblas_cgemv_safe :: GemvFunFFI (Ptr (Complex Float)) (Complex Float)
cblas_zgemv_unsafe :: GemvFunFFI (Ptr (Complex Double)) (Complex Double)
cblas_zgemv_safe :: GemvFunFFI (Ptr (Complex Double)) (Complex Double)
type TrsvFunFFI el = CBLAS_ORDERT -> CBLAS_UPLOT -> CBLAS_TRANSPOSET -> CBLAS_DIAGT -> CInt -> Ptr el -> CInt -> Ptr el -> CInt -> IO ()
cblas_strsv_unsafe :: TrsvFunFFI Float
cblas_strsv_safe :: TrsvFunFFI Float
cblas_dtrsv_unsafe :: TrsvFunFFI Double
cblas_dtrsv_safe :: TrsvFunFFI Double
cblas_ctrsv_unsafe :: TrsvFunFFI (Complex Float)
cblas_ctrsv_safe :: TrsvFunFFI (Complex Float)
cblas_ztrsv_unsafe :: TrsvFunFFI (Complex Double)
cblas_ztrsv_safe :: TrsvFunFFI (Complex Double)

-- | matrix vector product Av, writes result into v, where A is a packed
--   triangular nxn matrix
type SymvFunFFI el = CBLAS_ORDERT -> CBLAS_UPLOT -> CInt -> el -> Ptr el -> CInt -> Ptr el -> CInt -> el -> Ptr el -> CInt -> IO ()

-- | Matrix mult for general dense matrices
type GemmFunFFI scale el = CBLAS_ORDERT -> CBLAS_TRANSPOSET -> CBLAS_TRANSPOSET -> CInt -> CInt -> CInt -> scale -> Ptr el -> CInt -> Ptr el -> CInt -> scale -> Ptr el -> CInt -> IO ()
cblas_sgemm_unsafe :: GemmFunFFI Float Float
cblas_dgemm_unsafe :: GemmFunFFI Double Double
cblas_cgemm_unsafe :: GemmFunFFI (Ptr (Complex Float)) (Complex Float)
cblas_zgemm_unsafe :: GemmFunFFI (Ptr (Complex Double)) (Complex Double)
cblas_sgemm_safe :: GemmFunFFI Float Float
cblas_dgemm_safe :: GemmFunFFI Double Double
cblas_cgemm_safe :: GemmFunFFI (Ptr (Complex Float)) (Complex Float)
cblas_zgemm_safe :: GemmFunFFI (Ptr (Complex Double)) (Complex Double)
type SymmFunFFI scale el = CBLAS_ORDERT -> CBLAS_SIDET -> CBLAS_UPLOT -> CInt -> CInt -> scale -> Ptr el -> CInt -> Ptr el -> CInt -> scale -> Ptr el -> CInt -> IO ()
cblas_ssymm_unsafe :: SymmFunFFI Float Float
cblas_dsymm_unsafe :: SymmFunFFI Double Double
cblas_csymm_unsafe :: SymmFunFFI (Ptr (Complex Float)) (Complex Float)
cblas_zsymm_unsafe :: SymmFunFFI (Ptr (Complex Double)) (Complex Double)
cblas_ssymm_safe :: SymmFunFFI Float Float
cblas_dsymm_safe :: SymmFunFFI Double Double
cblas_csymm_safe :: SymmFunFFI (Ptr (Complex Float)) (Complex Float)
cblas_zsymm_safe :: SymmFunFFI (Ptr (Complex Double)) (Complex Double)
type SyrkFunFFI scale el = CBLAS_ORDERT -> CBLAS_UPLOT -> CBLAS_TRANSPOSET -> CInt -> CInt -> scale -> Ptr el -> CInt -> Ptr el -> CInt -> scale -> Ptr el -> CInt -> IO ()
cblas_ssyrk_unsafe :: SyrkFunFFI Float Float
cblas_dsyrk_unsafe :: SyrkFunFFI Double Double
cblas_csyrk_unsafe :: SyrkFunFFI (Ptr (Complex Float)) (Complex Float)
cblas_zsyrk_unsafe :: SyrkFunFFI (Ptr (Complex Double)) (Complex Double)
type Syr2kFunFFI scale el = CBLAS_ORDERT -> CBLAS_UPLOT -> CBLAS_TRANSPOSET -> CInt -> CInt -> scale -> Ptr el -> CInt -> Ptr el -> CInt -> scale -> Ptr el -> CInt -> IO ()
cblas_ssyr2k_unsafe :: Syr2kFunFFI Float Float
cblas_dsyr2k_unsafe :: Syr2kFunFFI Double Double
cblas_csyr2k_unsafe :: Syr2kFunFFI (Ptr (Complex Float)) Float
cblas_zsyr2k_unsafe :: Syr2kFunFFI (Ptr (Complex Double)) Double
type TrmmFunFFI scale el = CBLAS_ORDERT -> CBLAS_SIDET -> CBLAS_UPLOT -> CBLAS_TRANSPOSET -> CBLAS_DIAGT -> CInt -> CInt -> scale -> Ptr el -> CInt -> Ptr el -> CInt -> Ptr el -> CInt -> IO ()
cblas_strmm_unsafe :: TrmmFunFFI Float Float
cblas_dtrmm_unsafe :: TrmmFunFFI Double Double
cblas_ctrmm_unsafe :: TrmmFunFFI (Ptr (Complex Float)) (Complex Float)
cblas_ztrmm_unsafe :: TrmmFunFFI (Ptr (Complex Double)) (Complex Double)
type TrsmFunFFI scale el = CBLAS_ORDERT -> CBLAS_SIDET -> CBLAS_UPLOT -> CBLAS_TRANSPOSET -> CBLAS_DIAGT -> CInt -> CInt -> scale -> Ptr el -> CInt -> Ptr el -> CInt -> Ptr el -> CInt -> IO ()
cblas_strsm_unsafe :: TrmmFunFFI Float Float
cblas_dtrsm_unsafe :: TrmmFunFFI Double Double
cblas_ctrsm_unsafe :: TrmmFunFFI (Ptr (Complex Float)) (Complex Float)
cblas_ztrsm_unsafe :: TrmmFunFFI (Ptr (Complex Double)) (Complex Double)

-- | hermitian matrix mult
type HemmFunFFI el = CBLAS_ORDERT -> CBLAS_SIDET -> CBLAS_UPLOT -> CInt -> CInt -> Ptr el -> Ptr el -> CInt -> Ptr el -> CInt -> Ptr el -> CInt -> IO ()
cblas_chemm_unsafe :: HemmFunFFI (Complex Float)
cblas_zhemm_unsafe :: HemmFunFFI (Complex Double)
type HerkFun scale el = CBLAS_ORDERT -> CBLAS_SIDET -> CBLAS_TRANSPOSET -> CInt -> CInt -> scale -> Ptr el -> CInt -> Ptr el -> CInt -> scale -> Ptr el -> CInt -> IO ()
cblas_cherk_unsafe :: HerkFun Float (Complex Float)
cblas_zherk_unsafe :: HerkFun Double (Complex Double)
type Her2kFunFFI scale el = CBLAS_ORDERT -> CBLAS_SIDET -> CBLAS_TRANSPOSET -> CInt -> CInt -> Ptr el -> Ptr el -> CInt -> Ptr el -> CInt -> scale -> Ptr el -> CInt -> IO ()
cblas_cher2k_unsafe :: Her2kFunFFI Float (Complex Float)
cblas_zher2k_unsafe :: Her2kFunFFI Double (Complex Double)
instance Eq CBLAS_INDEX
instance Show CBLAS_INDEX
instance Eq CBLAS_ORDERT
instance Show CBLAS_ORDERT
instance Eq BLASOrder
instance Show BLASOrder
instance Eq CBLAS_TRANSPOSET
instance Show CBLAS_TRANSPOSET
instance Eq CBLAS_UPLOT
instance Show CBLAS_UPLOT
instance Eq BLASUplo
instance Show BLASUplo
instance Show CBLAS_DIAGT
instance Eq CBLAS_DIAGT
instance Eq BlasDiag
instance Show BlasDiag
instance Eq CBLAS_SIDET
instance Show CBLAS_SIDET
instance Eq BlasSide
instance Show BlasSide

module Numerical.HBLAS.BLAS.Internal
type GemmFun el orient s m = Transpose -> Transpose -> el -> el -> MDenseMatrix s orient el -> MDenseMatrix s orient el -> MDenseMatrix s orient el -> m ()
type GemvFun el orient s m = Transpose -> el -> el -> MDenseMatrix s orient el -> MDenseVector s Direct el -> MDenseVector s Direct el -> m ()
type TrsvFun el orient s m = MatUpLo -> Transpose -> MatDiag -> MDenseMatrix s orient el -> MDenseVector s Direct el -> m ()
gemmAbstraction :: (Storable el, PrimMonad m) => String -> GemmFunFFI scale el -> GemmFunFFI scale el -> (el -> (scale -> m ()) -> m ()) -> forall orient. GemmFun el orient (PrimState m) m
gemvAbstraction :: (Storable el, PrimMonad m) => String -> GemvFunFFI scale el -> GemvFunFFI scale el -> (el -> (scale -> m ()) -> m ()) -> forall orient. GemvFun el orient (PrimState m) m
trsvAbstraction :: (Storable el, PrimMonad m) => String -> TrsvFunFFI el -> TrsvFunFFI el -> forall orient. TrsvFun el orient (PrimState m) m


-- | The <a>BLAS</a> module provides a fully general yet type safe BLAS
--   API.
--   
--   When in doubt about the semantics of an operation, consult your
--   system's BLAS api documentation, or just read the documentation for
--   <a>the Intel MKL BLAS distribution</a>
--   
--   A few basic notes about how to invoke BLAS routines.
--   
--   Many BLAS operations take one or more arguments of type
--   <tt>Transpose</tt>. <tt>Tranpose</tt> has the following different
--   constructors, which tell BLAS routines what transformation to
--   implicitly apply to an input matrix <tt>mat</tt> with dimension <tt>n
--   x m</tt>.
--   
--   <ul>
--   <li><tt>NoTranspose</tt> leaves the matrix <tt>mat</tt> as is.</li>
--   <li><tt>Transpose</tt> treats the <tt>mat</tt> as being implicitly
--   transposed, with dimension <tt>m x n</tt>. Entry <tt>mat(i,j)</tt>
--   being treated as actually being the entry <tt>mat(j,i)</tt>. For Real
--   matrices this is also the matrix adjoint operation. ie
--   <tt>Tranpose(mat)(i,j)=mat(j,i)</tt></li>
--   <li><tt>ConjNoTranspose</tt> will implicitly conjugate <tt>mat</tt>,
--   which is a no op for Real (<a>Float</a> or <a>Double</a>) matrices,
--   but for 'Complex Float' and 'Complex Double' matrices, a given matrix
--   entry <tt>mat(i,j)==x<a>:+</a>y</tt> will be treated as actually being
--   <tt>conjugate(mat)(i,j)=y<a>:+</a>x</tt>.</li>
--   <li><tt>ConjTranpose</tt> will implicitly transpose and conjugate the
--   input matrix. ConjugateTranpose acts as matrix adjoint for both real
--   and complex matrices.</li>
--   </ul>
--   
--   The *gemm operations work as follows (using <a>sgemm</a> as an
--   example):
--   
--   <ul>
--   <li><tt>'sgemm trLeft trRight alpha beta left right result'</tt>,
--   where <tt>trLeft</tt> and <tt>trRight</tt> are values of type
--   <tt>Transpose</tt> that respectively act on the matrices <tt>left</tt>
--   and <tt>right</tt>.</li>
--   <li>the generalized matrix computation thusly formed can be viewed as
--   being <tt>result = alpha * trLeft(left) * trRight(right) + beta *
--   result</tt></li>
--   </ul>
--   
--   the *gemv operations are akin to the *gemm operations, but with
--   <tt>right</tt> and <tt>result</tt> being vectors rather than matrices.
--   
--   the *trsv operations solve for <tt>x</tt> in the equation <tt>A x =
--   y</tt> given <tt>A</tt> and <tt>y</tt>. The <tt>MatUpLo</tt> argument
--   determines if the matrix should be treated as upper or lower
--   triangular and <tt>MatDiag</tt> determines if the triangular solver
--   should treat the diagonal of the matrix as being all 1's or not. A
--   general pattern of invocation would be <tt><a>strsv</a> matuplo
--   tranposeMatA matdiag matrixA xVector</tt>. A key detail to note is
--   that the input vector is ALSO the result vector, ie <a>strsv</a> and
--   friends updates the vector place.
module Numerical.HBLAS.BLAS
type GemvFun el orient s m = Transpose -> el -> el -> MDenseMatrix s orient el -> MDenseVector s Direct el -> MDenseVector s Direct el -> m ()
type GemmFun el orient s m = Transpose -> Transpose -> el -> el -> MDenseMatrix s orient el -> MDenseMatrix s orient el -> MDenseMatrix s orient el -> m ()
type TrsvFun el orient s m = MatUpLo -> Transpose -> MatDiag -> MDenseMatrix s orient el -> MDenseVector s Direct el -> m ()
dgemm :: PrimMonad m => GemmFun Double orient (PrimState m) m
sgemm :: PrimMonad m => GemmFun Float orient (PrimState m) m
cgemm :: PrimMonad m => GemmFun (Complex Float) orient (PrimState m) m
zgemm :: PrimMonad m => GemmFun (Complex Double) orient (PrimState m) m
sgemv :: PrimMonad m => GemvFun Float orient (PrimState m) m
dgemv :: PrimMonad m => GemvFun Double orient (PrimState m) m
cgemv :: PrimMonad m => GemvFun (Complex Float) orient (PrimState m) m
zgemv :: PrimMonad m => GemvFun (Complex Double) orient (PrimState m) m
strsv :: PrimMonad m => TrsvFun Float orient (PrimState m) m
dtrsv :: PrimMonad m => TrsvFun Double orient (PrimState m) m
ctrsv :: PrimMonad m => TrsvFun (Complex Float) orient (PrimState m) m
ztrsv :: PrimMonad m => TrsvFun (Complex Double) orient (PrimState m) m
