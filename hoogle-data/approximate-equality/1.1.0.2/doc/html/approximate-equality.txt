-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Newtype wrappers for approximate equality
--   
--   The purpose of this module is to provide newtype wrappers that allow
--   one to effectively override the equality operator of a value so that
--   it is <i>approximate</i> rather than <i>exact</i>. The wrappers use
--   type annotations to specify the tolerance; the <a>Digits</a> type
--   constructor has been provided for specifying the tolerance using
--   type-level natural numbers. Instances for all of the classes in the
--   numerical hierarchy have been provided for the wrappers, so the
--   wrapped values can mostly be used in the same way as the original
--   values. (In fact, most of the time one doesn't even have to wrap the
--   starting values, since expressions such as <tt>(1+sqrt 2/3)</tt> are
--   automatically wrapped thanks to the <a>fromIntegral</a> method of the
--   <a>Num</a> typeclass.) See the documentation for Data.Eq.Approximate
--   for more detailed information on how to use this package. New in
--   version 1.1: Added explicit Show constraints to the Show instances, as
--   the Num class in the newest version of GHC (wisely) no longer includes
--   Show as a constraint.
@package approximate-equality
@version 1.1.0.2


-- | The purpose of this module is to provide newtype wrapper that allows
--   one to effectively override the equality operator of a value so that
--   it is <i>approximate</i> rather than <i>exact</i>. For example, the
--   type
--   
--   <pre>
--   type ApproximateDouble = AbsolutelyApproximateValue (Digits Five) Double
--   </pre>
--   
--   defines an alias for a wrapper containing <a>Double</a>s such that two
--   doubles are equal if they are equal to within five decimals of
--   accuracy; for example, we have that
--   
--   <pre>
--   1 == (1+10^^(-6) :: ApproximateDouble)
--   </pre>
--   
--   evaluates to <a>True</a>. Note that we did not need to wrap the value
--   <tt>1+10^^(-6)</tt> since <a>AbsolutelyApproximateValue</a> is an
--   instance of <a>Num</a>. For convenience, <a>Num</a> as well as many
--   other of the numerical classes such as <a>Real</a> and <a>Floating</a>
--   have all been derived for the wrappers defined in this package so that
--   one can conveniently use the wrapped values in the same way as one
--   would use the values themselves.
--   
--   Two kinds of wrappers are provided by this package.
--   
--   <ul>
--   <li><a>AbsolutelyApproximateValue</a> wraps values that are considered
--   to be equal if their absolute difference falls within the specified
--   tolerance.</li>
--   <li><a>RelativelyApproximateValue</a> wraps values that are considered
--   to be equal if the absolute difference between the values divided by
--   the average of the absolute values is within the given relative
--   tolerance, <i>or</i> if the absolute value of both values falls within
--   the zero tolerance; the latter case is checked because otherwise no
--   value, no matter how small, would be approximately equal to zero.</li>
--   </ul>
--   
--   The tolerance is specified through a type annotation. One can use any
--   annotation that one wishes as long as the type is an instance of
--   <a>AbsoluteTolerance</a> (for absolute tolerances) and/or
--   <a>RelativeTolerance</a> and <a>ZeroTolerance</a> (for relative
--   tolerances). For convenience, this package provides the type
--   <a>Digits</a> that allows one to specify the tolerance in terms of the
--   number of digits, making use of type-level natural numbers. The
--   annotation <tt>Digits n</tt> sets the tolerance to <tt>10^-n</tt>, so
--   that in the case of the absolute tolerance and the zero tolerance
--   <tt>n</tt> is the number of decimal places that numbers have to match
--   to be equal to respectively either each other or to zero, and in the
--   case of relative tolerance <tt>n</tt> is (roughly) the number of
--   leading digits that two numbers have to match in order to be equal to
--   each other.
module Data.Eq.Approximate

-- | The newtype <a>AbsolutelyApproximateValue</a> is a wrapper that can
--   contain an arbitrary value tagged with a tolerance; two values are
--   equal to each other if the absolute difference is less than or equal
--   to this tolerance. The type annotation <tt>absolute_tolerance</tt>,
--   which must be an instance of <a>AbsoluteTolerance</a>, specifies the
--   tolerance. For convenience, one may specify the tolerance using the
--   type <tt>Digits n</tt> where <tt>n</tt> is a type-level natural
--   specifying the number of decimals in the tolerance (i.e., <tt>Digits
--   Four</tt> specifies a tolerance of 0.0001).
--   
--   It is recommended that one use this wrapper by creating aliases, such
--   as
--   
--   <pre>
--   type ApproximateDouble = AbsolutelyApproximateValue (Digits Five)
--   wrapAD :: Double -&gt; ApproximateDouble
--   wrapAD = AbsolutelyApproximateValue
--   unwrapAD :: ApproximateDouble -&gt; Double
--   unwrapAD = unwrapAbsolutelyApproximateValue
--   </pre>
--   
--   You can then replace the type <a>Double</a> in your code with the type
--   alias <tt>ApproximateDouble</tt> to get the feature of approximate
--   equality. Most of the time you will find that you do not need to use
--   wrapping functions to construct wrapped values since
--   <a>AbsolutelyApproximateValue</a> is an instance of whatever numerical
--   types the wrapped value is, so that for example <tt>1 + sqrt 2/3</tt>
--   is already a value of type <tt>ApproximateDouble</tt> without needing
--   to be wrapped first.
newtype AbsolutelyApproximateValue absolute_tolerance value
AbsolutelyApproximateValue :: value -> AbsolutelyApproximateValue absolute_tolerance value
unwrapAbsolutelyApproximateValue :: AbsolutelyApproximateValue absolute_tolerance value -> value

-- | The newtype <a>RelativelyApproximateValue</a> is a wrapper that can
--   contain an arbitrary value tagged with a zero tolerance and a relative
--   tolerance; two values are equal to each other if their absolute values
--   are both less than or equal to the zero tolerance, or if the absolute
--   difference between them divided by the average of the absolute values
--   is less than or equal to the relative tolerance.
--   
--   The type annotation <tt>zero_tolerance</tt>, which must be an instance
--   of <a>ZeroTolerance</a>, specifies the tolerance within which a value
--   is considered to be equal to zero. For convenience, one may specify
--   the tolerance using the type <tt>Digits n</tt> where <tt>n</tt> is a
--   type-level natural specifying the number of decimals in the tolerance
--   (i.e., <tt>Digits Four</tt> specifies a tolerance of 0.0001).
--   
--   The type annotation <tt>relative_tolerance</tt>, which must be an
--   instance of <a>RelativeTolerance</a>, specifies the relative tolerance
--   within which two values that are not approximately equal to zero are
--   considered to be equal to each other. For convenience, as with the
--   zero tolerance, one may specify the relative tolerance using the type
--   <tt>Digits n</tt> where <tt>n</tt> is a type-level natural specifying
--   the number of decimals in the tolerance (i.e., <tt>Digits Four</tt>
--   specifies a relative tolerance of 0.0001, so that two values are equal
--   if they agree to the first four leading digits).
--   
--   It is recommended that one use this wrapper by creating aliases, such
--   as
--   
--   <pre>
--   type ApproximateDouble = RelativelyApproximateValue (Digits Five) (Digits Five)
--   wrapAD :: Double -&gt; ApproximateDouble
--   wrapAD = RelativelyApproximateValue
--   unwrapAD :: ApproximateDouble -&gt; Double
--   unwrapAD = unwrapRelativelyApproximateValue
--   </pre>
--   
--   You can then replace the type <a>Double</a> in your code with the type
--   alias <tt>ApproximateDouble</tt> to get the feature of approximate
--   equality. Most of the time you will find that you do not need to use
--   wrapping functions to construct wrapped values since
--   <a>RelativelyApproximateValue</a> is an instance of whatever numerical
--   types the wrapped value is, so that for example <tt>1 + sqrt 2/3</tt>
--   is already a value of type <tt>ApproximateDouble</tt> without needing
--   to be wrapped first.
newtype RelativelyApproximateValue zero_tolerance relative_tolerance value
RelativelyApproximateValue :: value -> RelativelyApproximateValue zero_tolerance relative_tolerance value
unwrapRelativelyApproximateValue :: RelativelyApproximateValue zero_tolerance relative_tolerance value -> value

-- | The class <a>AbsoluteTolerance</a> is used to define the absolute
--   tolerances associated with types that will be used as absolute
--   tolerance type annotations in <a>AbsolutelyApproximateValue</a>.
class AbsoluteTolerance absolute_tolerance
absoluteToleranceOf :: (AbsoluteTolerance absolute_tolerance, Fractional value) => AbsolutelyApproximateValue absolute_tolerance value -> value

-- | This is a convenience (constant) function for extracting the relative
--   tolerance type annotation from <a>AbsolutelyApproximateValue</a>; it
--   returns the value <a>undefined</a>, so don't try to evaluate the
--   result.
getAbsoluteTolerance :: AbsolutelyApproximateValue absolute_tolerance value -> absolute_tolerance

-- | The class <a>RelativeTolerance</a> is used to define the relative
--   tolerances associated with types that will be used as relative
--   tolerance type annotations in <a>RelativelyApproximateValue</a>.
class RelativeTolerance relative_tolerance
relativeToleranceOf :: (RelativeTolerance relative_tolerance, Fractional value) => RelativelyApproximateValue zero_tolerance relative_tolerance value -> value

-- | This is a convenience (constant) function for extracting the relative
--   tolerance type annotation from <a>RelativelyApproximateValue</a>; it
--   returns the value <a>undefined</a>, so don't try to evaluate the
--   result.
getRelativeTolerance :: RelativelyApproximateValue zero_tolerance relative_tolerance value -> relative_tolerance

-- | The class <a>ZeroTolerance</a> is used to define the numerical zero
--   tolerances associated with types that will be used as zero tolerance
--   type annotations in <a>RelativelyApproximateValue</a>.
class ZeroTolerance zero_tolerance
zeroToleranceOf :: (ZeroTolerance zero_tolerance, Fractional value) => RelativelyApproximateValue zero_tolerance relative_tolerance value -> value

-- | This is a convenience (constant) function for extracting the zero
--   tolerance type annotation from <a>RelativelyApproximateValue</a>; it
--   returns the value <a>undefined</a>, so don't try to evaluate the
--   result.
getZeroTolerance :: RelativelyApproximateValue zero_tolerance relative_tolerance value -> zero_tolerance

-- | Digits is a type constructor that can be used to specify tolerances
--   using type-level natural numbers. Annotating a wrapper with the type
--   <tt>Digits n</tt> specifies that the corresponding tolerance has a
--   numerical value of <tt>10^(-n)</tt>.
data Digits n

-- | This is a convenience (constant) function for extracting the
--   type-level natural number contained within the <a>Digits</a> type
--   constructor; it returns the value <a>undefined</a>, so don't try to
--   evaluate the result.
unwrapDigits :: Digits n -> n

-- | This is a convenience (constant) function that computes the numerical
--   tolerance specified by <tt>Digits n</tt>, which is <tt>10^(-n)</tt>.
toleranceFromDigits :: NaturalNumber n => Fractional value => Digits n -> value
instance NaturalNumber n => ZeroTolerance (Digits n)
instance NaturalNumber n => RelativeTolerance (Digits n)
instance NaturalNumber n => AbsoluteTolerance (Digits n)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, RealFloat value) => RealFloat (RelativelyApproximateValue zerotol reltol value)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, RealFrac value) => RealFrac (RelativelyApproximateValue zerotol reltol value)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, Floating value) => Floating (RelativelyApproximateValue zerotol reltol value)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, Fractional value) => Fractional (RelativelyApproximateValue zerotol reltol value)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, Fractional value, Integral value) => Integral (RelativelyApproximateValue zerotol reltol value)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, Fractional value, Real value) => Real (RelativelyApproximateValue zerotol reltol value)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, Fractional value) => Num (RelativelyApproximateValue zerotol reltol value)
instance Enum value => Enum (RelativelyApproximateValue zerotol reltol value)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, Fractional value) => Ord (RelativelyApproximateValue zerotol reltol value)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, Fractional value) => Eq (RelativelyApproximateValue zerotol reltol value)
instance (ZeroTolerance zerotol, RelativeTolerance reltol, Ord value, Fractional value, Show value) => Show (RelativelyApproximateValue zerotol reltol value)
instance (AbsoluteTolerance tolerance, Ord value, RealFloat value) => RealFloat (AbsolutelyApproximateValue tolerance value)
instance (AbsoluteTolerance tolerance, Ord value, RealFrac value) => RealFrac (AbsolutelyApproximateValue tolerance value)
instance (AbsoluteTolerance tolerance, Ord value, Floating value) => Floating (AbsolutelyApproximateValue tolerance value)
instance (AbsoluteTolerance tolerance, Ord value, Fractional value) => Fractional (AbsolutelyApproximateValue tolerance value)
instance (AbsoluteTolerance tolerance, Ord value, Fractional value, Integral value) => Integral (AbsolutelyApproximateValue tolerance value)
instance (AbsoluteTolerance tolerance, Ord value, Fractional value, Real value) => Real (AbsolutelyApproximateValue tolerance value)
instance (AbsoluteTolerance tolerance, Ord value, Fractional value) => Num (AbsolutelyApproximateValue tolerance value)
instance Enum value => Enum (AbsolutelyApproximateValue tolerance value)
instance (AbsoluteTolerance tolerance, Ord value, Fractional value) => Ord (AbsolutelyApproximateValue tolerance value)
instance (AbsoluteTolerance tolerance, Ord value, Fractional value) => Eq (AbsolutelyApproximateValue tolerance value)
instance (AbsoluteTolerance tolerance, Ord value, Fractional value, Show value) => Show (AbsolutelyApproximateValue tolerance value)
