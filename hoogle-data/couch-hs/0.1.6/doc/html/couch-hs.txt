-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A CouchDB view server for Haskell.
--   
--   A CouchDB view server for Haskell.
@package couch-hs
@version 0.1.6

module Database.CouchDB.ViewServer.Reduce

-- | The type of your reduce functions as they are stored in CouchDB. The
--   trivial example:
--   
--   <pre>
--   \keys values rereduce -&gt; return Null
--   </pre>
type ReduceSignature a = [Value] -> [Value] -> Bool -> ViewReduce a

-- | The monad within which a reduce computation takes place. This is a
--   transformation of the <a>Parser</a> monad, which is accessible through
--   the <a>MonadParser</a> typeclass.
data ViewReduce a

-- | Like MonadIO, but for <a>Parser</a>. This allows JSON parsing
--   operations to be lifted into our various view monads.
class Monad m => MonadParser m
liftParser :: MonadParser m => Parser a -> m a

-- | Attempts to parse a JSON value into a given type. This is typically
--   used with a type annotation to indicate the target type. If the value
--   can not be parsed into that type, the entire computation will fail.
parseJSON :: (MonadParser m, FromJSON a) => Value -> m a

-- | Applies <a>parseJSON</a> to a list of values. This is commonly used
--   with the reduce function arguments.
parseJSONList :: (MonadParser m, FromJSON a) => [Value] -> m [a]

-- | Parses a required field of an object. If the field is not present, or
--   the value can not be parsed into the target type, the computation will
--   fail.
(.:) :: (MonadParser m, FromJSON a) => Object -> Text -> m a

-- | Parses an optional field of an object. This will not halt the
--   computation on failure.
(.:?) :: (MonadParser m, FromJSON a) => Object -> Text -> m (Maybe a)

-- | Construct a <a>Pair</a> from a key and a value.
(.=) :: ToJSON a => Text -> a -> Pair

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | A JSON value represented as a Haskell value.
data Value :: *
Object :: !Object -> Value
Array :: !Array -> Value
String :: !Text -> Value
Number :: !Number -> Value
Bool :: !Bool -> Value
Null :: Value

-- | Send a log message to the CouchDB server. Note that log messages are
--   only sent if the computation succeeds. If you want to log a message in
--   the event of a failure, look at <a>Alternative</a>.
logMsg :: String -> ViewReduce ()
instance Typeable ReduceFunc
instance Monad ViewReduce
instance Functor ViewReduce
instance MonadPlus ViewReduce
instance Applicative ViewReduce
instance Alternative ViewReduce
instance MonadParser ViewReduce

module Database.CouchDB.ViewServer.Map

-- | The type of your map functions as they are stored in CouchDB. The
--   trivial example:
--   
--   <pre>
--   \doc -&gt; return ()
--   </pre>
type MapSignature = Object -> ViewMap ()

-- | The monad within which a map computation takes place. This is a
--   transformation of the <a>Parser</a> monad, which is accessible through
--   the <a>MonadParser</a> typeclass.
data ViewMap a

-- | Like MonadIO, but for <a>Parser</a>. This allows JSON parsing
--   operations to be lifted into our various view monads.
class Monad m => MonadParser m
liftParser :: MonadParser m => Parser a -> m a

-- | Attempts to parse a JSON value into a given type. This is typically
--   used with a type annotation to indicate the target type. If the value
--   can not be parsed into that type, the entire computation will fail.
parseJSON :: (MonadParser m, FromJSON a) => Value -> m a

-- | Applies <a>parseJSON</a> to a list of values. This is commonly used
--   with the reduce function arguments.
parseJSONList :: (MonadParser m, FromJSON a) => [Value] -> m [a]

-- | Parses a required field of an object. If the field is not present, or
--   the value can not be parsed into the target type, the computation will
--   fail.
(.:) :: (MonadParser m, FromJSON a) => Object -> Text -> m a

-- | Parses an optional field of an object. This will not halt the
--   computation on failure.
(.:?) :: (MonadParser m, FromJSON a) => Object -> Text -> m (Maybe a)

-- | Construct a <a>Pair</a> from a key and a value.
(.=) :: ToJSON a => Text -> a -> Pair

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | A JSON value represented as a Haskell value.
data Value :: *
Object :: !Object -> Value
Array :: !Array -> Value
String :: !Text -> Value
Number :: !Number -> Value
Bool :: !Bool -> Value
Null :: Value

-- | Emit a key/value pair for the current document. The values will be
--   turned into JSON objects for you, although you will have to provide
--   type annotations somewhere.
--   
--   <pre>
--   \doc -&gt; do value &lt;- doc .: "value" :: ViewMap Double
--              emit Null value
--   </pre>
emit :: (ToJSON k, ToJSON v) => k -> v -> ViewMap ()

-- | Same as <a>emit</a>, but with wrapped key and value.
--   
--   <pre>
--   \doc -&gt; emitM (return Null) (doc .: "value" :: ViewMap Double)
--   </pre>
emitM :: (ToJSON k, ToJSON v) => ViewMap k -> ViewMap v -> ViewMap ()

-- | Send a log message to the CouchDB server. Note that log messages are
--   only sent if the computation succeeds. If you want to log a message in
--   the event of a failure, look at <a>Alternative</a>.
logMsg :: String -> ViewMap ()
instance Typeable MapFunc
instance Monad ViewMap
instance Functor ViewMap
instance MonadPlus ViewMap
instance Applicative ViewMap
instance Alternative ViewMap
instance ToJSON MapOutput
instance MonadParser ViewMap


-- | This is a CouchDB view server in and for Haskell. With it, you can
--   define design documents that use Haskell functions to perform
--   map/reduce operations. Database.CouchDB.ViewServer is just a
--   container; see the submodules for API documentation.
module Database.CouchDB.ViewServer

-- | The type of your map functions as they are stored in CouchDB. The
--   trivial example:
--   
--   <pre>
--   \doc -&gt; return ()
--   </pre>
type MapSignature = Object -> ViewMap ()

-- | The type of your reduce functions as they are stored in CouchDB. The
--   trivial example:
--   
--   <pre>
--   \keys values rereduce -&gt; return Null
--   </pre>
type ReduceSignature a = [Value] -> [Value] -> Bool -> ViewReduce a
