-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Assorted decision procedures for SAT, Max-SAT, PB, MIP, etc
--   
@package toysolver
@version 0.3.0

module ToySolver.Version
version :: Version
packageVersions :: [(String, String)]


-- | Queue implemented using IORef and Sequence.
module ToySolver.Internal.Data.SeqQueue
data SeqQueue a

-- | Construct a new FIFO queue.
class Monad m => NewFifo q (m :: * -> *)
newFifo :: NewFifo q m => m q
class Monad m => Enqueue q (m :: * -> *) a | q -> a
enqueue :: Enqueue q m a => q -> a -> m ()
enqueueBatch :: Enqueue q m a => q -> [a] -> m ()
class Monad m => Dequeue q (m :: * -> *) a | q -> a
dequeue :: Dequeue q m a => q -> m (Maybe a)
dequeueBatch :: Dequeue q m a => q -> m [a]
class Monad m => QueueSize q (m :: * -> *)
queueSize :: QueueSize q m => q -> m Int
clear :: SeqQueue a -> IO ()
instance QueueSize (SeqQueue a) IO
instance Dequeue (SeqQueue a) IO a
instance Enqueue (SeqQueue a) IO a
instance NewFifo (SeqQueue a) IO


-- | References:
--   
--   <ul>
--   <li>SDPA (Semidefinite Programming Algorithm) User's Manual
--   <a>http://sdpa.indsys.chuo-u.ac.jp/~fujisawa/sdpa_doc.pdf</a></li>
--   <li><a>http://euler.nmt.edu/~brian/sdplib/FORMAT</a></li>
--   </ul>
module ToySolver.Text.SDPFile
data Problem
Problem :: [Int] -> [Rational] -> [Matrix] -> Problem

-- | the block strcuture vector (bLOCKsTRUCT)
blockStruct :: Problem -> [Int]

-- | Constant Vector
costs :: Problem -> [Rational]

-- | Constraint Matrices
matrices :: Problem -> [Matrix]
type Matrix = [Block]
type Block = Map (Int, Int) Rational

-- | the number of primal variables (mDim)
mDim :: Problem -> Int

-- | the number of blocks (nBLOCK)
nBlock :: Problem -> Int
blockElem :: Int -> Int -> Block -> Rational
type DenseMatrix = [DenseBlock]
type DenseBlock = [[Rational]]
denseMatrix :: DenseMatrix -> Matrix
denseBlock :: DenseBlock -> Block
diagBlock :: [Rational] -> Block
render :: Problem -> ShowS
renderSparse :: Problem -> ShowS

-- | Parse a SDPA format (.dat) string.
parseDataString :: SourceName -> String -> Either ParseError Problem

-- | Parse a SDPA format file (.dat).
parseDataFile :: FilePath -> IO (Either ParseError Problem)

-- | Parse a SDPA sparse format (.dat-s) string.
parseSparseDataString :: SourceName -> String -> Either ParseError Problem

-- | Parse a SDPA sparse format file (.dat-s).
parseSparseDataFile :: FilePath -> IO (Either ParseError Problem)
instance Show Problem
instance Ord Problem
instance Eq Problem

module ToySolver.Text.GurobiSol
type Model = Map String Double
render :: Model -> Maybe Double -> String


-- | Simple unboxed IORef-like type based on IOUArray
module ToySolver.Internal.Data.IOURef
data IOURef a
newIOURef :: MArray IOUArray a IO => a -> IO (IOURef a)
readIOURef :: MArray IOUArray a IO => IOURef a -> IO a
writeIOURef :: MArray IOUArray a IO => IOURef a -> a -> IO ()
modifyIOURef :: MArray IOUArray a IO => IOURef a -> (a -> a) -> IO ()
instance Eq (IOURef a)


-- | Simple 1-dimentional resizable array
module ToySolver.Internal.Data.Vec
data GenericVec a e
type Vec e = GenericVec IOArray e
type UVec e = GenericVec IOUArray e
type Index = Int
new :: MArray a e IO => IO (GenericVec a e)
clone :: MArray a e IO => GenericVec a e -> IO (GenericVec a e)

-- | Get the internal representation array
getSize :: MArray a e IO => GenericVec a e -> IO Int
read :: MArray a e IO => GenericVec a e -> Int -> IO e
write :: MArray a e IO => GenericVec a e -> Int -> e -> IO ()
unsafeRead :: MArray a e IO => GenericVec a e -> Int -> IO e
unsafeWrite :: MArray a e IO => GenericVec a e -> Int -> e -> IO ()
resize :: MArray a e IO => GenericVec a e -> Int -> IO ()
growTo :: MArray a e IO => GenericVec a e -> Int -> IO ()
push :: MArray a e IO => GenericVec a e -> e -> IO ()
unsafePop :: MArray a e IO => GenericVec a e -> IO e
clear :: MArray a e IO => GenericVec a e -> IO ()
getElems :: MArray a e IO => GenericVec a e -> IO [e]

-- | Get the internal representation array
getArray :: GenericVec a e -> IO (a Index e)

-- | Get the internal representation array
getCapacity :: MArray a e IO => GenericVec a e -> IO Int

-- | Pre-allocate internal buffer for <tt>n</tt> elements.
resizeCapacity :: MArray a e IO => GenericVec a e -> Int -> IO ()
instance Eq (GenericVec a e)


-- | Priority queue implemented as array-based binary heap.
module ToySolver.Internal.Data.IndexedPriorityQueue

-- | Priority queue implemented as array-based binary heap.
data PriorityQueue
type Value = Int
type Index = Int

-- | Build a priority queue with default ordering ('(&lt;)' of <a>Ord</a>
--   class)
newPriorityQueue :: IO PriorityQueue

-- | Build a priority queue with a given <i>less than</i> operator.
newPriorityQueueBy :: (Value -> Value -> IO Bool) -> IO PriorityQueue

-- | Construct a new FIFO queue.
class Monad m => NewFifo q (m :: * -> *)
newFifo :: NewFifo q m => m q

-- | Return a list of all the elements of a priority queue. (not sorted)
getElems :: PriorityQueue -> IO [Value]

-- | Remove all elements from a priority queue.
clear :: PriorityQueue -> IO ()

-- | Create a copy of a priority queue.
clone :: PriorityQueue -> IO PriorityQueue
class Monad m => Enqueue q (m :: * -> *) a | q -> a
enqueue :: Enqueue q m a => q -> a -> m ()
enqueueBatch :: Enqueue q m a => q -> [a] -> m ()
class Monad m => Dequeue q (m :: * -> *) a | q -> a
dequeue :: Dequeue q m a => q -> m (Maybe a)
dequeueBatch :: Dequeue q m a => q -> m [a]
class Monad m => QueueSize q (m :: * -> *)
queueSize :: QueueSize q m => q -> m Int
member :: PriorityQueue -> Value -> IO Bool
update :: PriorityQueue -> Value -> IO ()

-- | Get the internal representation of a given priority queue.
getHeapArray :: PriorityQueue -> IO (IOUArray Index Value)

-- | Get the internal representation of a given priority queue.
getHeapVec :: PriorityQueue -> IO (UVec Value)

-- | Pre-allocate internal buffer for <tt>n</tt> elements.
resizeHeapCapacity :: PriorityQueue -> Int -> IO ()

-- | Pre-allocate internal buffer for <tt>[0..n-1]</tt> values.
resizeTableCapacity :: PriorityQueue -> Int -> IO ()
instance QueueSize PriorityQueue IO
instance Dequeue PriorityQueue IO Value
instance Enqueue PriorityQueue IO Value
instance NewFifo PriorityQueue IO


-- | Priority queue implemented as array-based binary heap.
module ToySolver.Internal.Data.PriorityQueue

-- | Priority queue implemented as array-based binary heap.
data PriorityQueue a
type Index = Int

-- | Build a priority queue with default ordering ('(&lt;)' of <a>Ord</a>
--   class)
newPriorityQueue :: Ord a => IO (PriorityQueue a)

-- | Build a priority queue with a given <i>less than</i> operator.
newPriorityQueueBy :: (a -> a -> IO Bool) -> IO (PriorityQueue a)

-- | Construct a new FIFO queue.
class Monad m => NewFifo q (m :: * -> *)
newFifo :: NewFifo q m => m q

-- | Return a list of all the elements of a priority queue. (not sorted)
getElems :: PriorityQueue a -> IO [a]

-- | Remove all elements from a priority queue.
clear :: PriorityQueue a -> IO ()

-- | Create a copy of a priority queue.
clone :: PriorityQueue a -> IO (PriorityQueue a)
class Monad m => Enqueue q (m :: * -> *) a | q -> a
enqueue :: Enqueue q m a => q -> a -> m ()
enqueueBatch :: Enqueue q m a => q -> [a] -> m ()
class Monad m => Dequeue q (m :: * -> *) a | q -> a
dequeue :: Dequeue q m a => q -> m (Maybe a)
dequeueBatch :: Dequeue q m a => q -> m [a]
class Monad m => QueueSize q (m :: * -> *)
queueSize :: QueueSize q m => q -> m Int

-- | Get the internal representation of a given priority queue.
getHeapArray :: PriorityQueue a -> IO (IOArray Index a)

-- | Get the internal representation of a given priority queue.
getHeapVec :: PriorityQueue a -> IO (Vec a)

-- | Pre-allocate internal buffer for <tt>n</tt> elements.
resizeHeapCapacity :: PriorityQueue a -> Int -> IO ()
instance QueueSize (PriorityQueue a) IO
instance Dequeue (PriorityQueue a) IO a
instance Enqueue (PriorityQueue a) IO a
instance Ord a => NewFifo (PriorityQueue a) IO


-- | References:
--   
--   <ul>
--   <li><a>http://www.math.kobe-u.ac.jp/Asir/ca.pdf</a></li>
--   
--   <li><a>http://www14.in.tum.de/konferenzen/Jass07/courses/1/Bulwahn/Buhlwahn_Paper.pdf</a></li>
--   </ul>
module ToySolver.Data.Polynomial.Factorization.Hensel.Internal
hensel :: Nat p => UPolynomial Integer -> [UPolynomial (PrimeField p)] -> Integer -> [UPolynomial Integer]
cabook_proposition_5_10 :: (Num k, Fractional k, Eq k) => [UPolynomial k] -> [UPolynomial k]
cabook_proposition_5_11 :: (Num k, Fractional k, Eq k, PrettyCoeff k, Ord k) => [UPolynomial k] -> UPolynomial k -> [UPolynomial k]


-- | References:
--   
--   <ul>
--   <li><a>http://www.math.kobe-u.ac.jp/Asir/ca.pdf</a></li>
--   
--   <li><a>http://www14.in.tum.de/konferenzen/Jass07/courses/1/Bulwahn/Buhlwahn_Paper.pdf</a></li>
--   </ul>
module ToySolver.Data.Polynomial.Factorization.Hensel
hensel :: Nat p => UPolynomial Integer -> [UPolynomial (PrimeField p)] -> Integer -> [UPolynomial Integer]


-- | References:
--   
--   <ul>
--   <li><a>http://www.math.kobe-u.ac.jp/Asir/ca.pdf</a></li>
--   </ul>
module ToySolver.Data.Polynomial.Factorization.SquareFree

-- | Square-free decomposition of univariate polynomials over a field of
--   characteristic 0.
sqfreeChar0 :: (Eq k, Fractional k) => UPolynomial k -> [(UPolynomial k, Integer)]
instance SQFree (UPolynomial Integer)
instance SQFree (UPolynomial Rational)


module ToySolver.Internal.TextUtil
readInt :: String -> Int

-- | <a>read</a> allocate too many intermediate <a>Integer</a>. Therefore
--   we use this optimized implementation instead. Many intermediate values
--   in this implementation will be optimized away by worker-wrapper
--   transformation and unboxing.
readUnsignedInteger :: String -> Integer


-- | Mixed-Integer Programming Problems with some commmonly used extensions
module ToySolver.Data.MIP.Base

-- | Problem
data Problem
Problem :: OptDir -> ObjectiveFunction -> [Constraint] -> [SOSConstraint] -> [Constraint] -> Map Var VarInfo -> Problem
dir :: Problem -> OptDir
objectiveFunction :: Problem -> ObjectiveFunction
constraints :: Problem -> [Constraint]
sosConstraints :: Problem -> [SOSConstraint]
userCuts :: Problem -> [Constraint]
varInfo :: Problem -> Map Var VarInfo

-- | expressions
type Expr = [Term]

-- | terms
data Term
Term :: Rational -> [Var] -> Term

-- | The <a>OptDir</a> type represents optimization directions.
data OptDir :: *

-- | minimization
OptMin :: OptDir

-- | maximization
OptMax :: OptDir

-- | objective function
type ObjectiveFunction = (Maybe Label, Expr)

-- | constraint
data Constraint
Constraint :: Maybe Label -> Maybe (Var, Rational) -> (Expr, RelOp, Rational) -> Bool -> Constraint
constrLabel :: Constraint -> Maybe Label
constrIndicator :: Constraint -> Maybe (Var, Rational)
constrBody :: Constraint -> (Expr, RelOp, Rational)
constrIsLazy :: Constraint -> Bool

-- | type for representing lower/upper bound of variables
type Bounds = (BoundExpr, BoundExpr)

-- | label
type Label = String

-- | variable
type Var = InternedString
data VarType
ContinuousVariable :: VarType
IntegerVariable :: VarType
SemiContinuousVariable :: VarType
SemiIntegerVariable :: VarType
data VarInfo
VarInfo :: VarType -> Bounds -> VarInfo
varType :: VarInfo -> VarType
varBounds :: VarInfo -> Bounds

-- | type for representing lower/upper bound of variables
type BoundExpr = Extended Rational

-- | <tt>Extended r</tt> is an extension of <i>r</i> with positive/negative
--   infinity (±∞).
data Extended r :: * -> *

-- | negative infinity (-∞)
NegInf :: Extended r

-- | finite value
Finite :: SrictNotUnpackedr -> Extended r

-- | positive infinity (+∞)
PosInf :: Extended r

-- | relational operators
data RelOp
Le :: RelOp
Ge :: RelOp
Eql :: RelOp

-- | types of SOS (special ordered sets) constraints
data SOSType

-- | Type 1 SOS constraint
S1 :: SOSType

-- | Type 2 SOS constraint
S2 :: SOSType

-- | SOS (special ordered sets) constraints
data SOSConstraint
SOSConstraint :: Maybe Label -> SOSType -> [(Var, Rational)] -> SOSConstraint
sosLabel :: SOSConstraint -> Maybe Label
sosType :: SOSConstraint -> SOSType
sosBody :: SOSConstraint -> [(Var, Rational)]

-- | default bounds
defaultBounds :: Bounds

-- | default lower bound (0)
defaultLB :: BoundExpr

-- | default upper bound (+∞)
defaultUB :: BoundExpr

-- | convert a string into a variable
toVar :: String -> Var

-- | convert a variable into a string
fromVar :: Var -> String

-- | looking up attributes for a variable
getVarInfo :: Problem -> Var -> VarInfo

-- | looking up bounds for a variable
getVarType :: Problem -> Var -> VarType

-- | looking up bounds for a variable
getBounds :: Problem -> Var -> Bounds
variables :: Problem -> Set Var
integerVariables :: Problem -> Set Var
semiContinuousVariables :: Problem -> Set Var
semiIntegerVariables :: Problem -> Set Var
class Variables a
vars :: Variables a => a -> Set Var
intersectBounds :: Bounds -> Bounds -> Bounds
instance Eq VarType
instance Ord VarType
instance Show VarType
instance Eq Term
instance Ord Term
instance Show Term
instance Eq VarInfo
instance Ord VarInfo
instance Show VarInfo
instance Eq RelOp
instance Ord RelOp
instance Enum RelOp
instance Show RelOp
instance Eq Constraint
instance Ord Constraint
instance Show Constraint
instance Eq SOSType
instance Ord SOSType
instance Enum SOSType
instance Show SOSType
instance Read SOSType
instance Eq SOSConstraint
instance Ord SOSConstraint
instance Show SOSConstraint
instance Show Problem
instance Eq Problem
instance Ord Problem
instance Variables SOSConstraint
instance Variables Constraint
instance Variables Term
instance Variables Problem
instance (Variables a, Variables b) => Variables (Either a b)
instance Variables a => Variables [a]
instance Default VarInfo
instance Default VarType
instance Default Constraint
instance Default Problem


-- | A .mps format parser library.
--   
--   References:
--   
--   <ul>
--   
--   <li><a>http://pic.dhe.ibm.com/infocenter/cosinfoc/v12r4/topic/ilog.odms.cplex.help/CPLEX/File_formats_reference/topics/MPS_synopsis.html</a></li>
--   
--   <li><a>http://pic.dhe.ibm.com/infocenter/cosinfoc/v12r4/topic/ilog.odms.cplex.help/CPLEX/File_formats_reference/topics/MPS_ext_synopsis.html</a></li>
--   
--   <li><a>http://www.gurobi.com/documentation/5.0/reference-manual/node744</a></li>
--   <li><a>http://en.wikipedia.org/wiki/MPS_(format)</a></li>
--   </ul>
module ToySolver.Data.MIP.MPSFile

-- | Parse a string containing MPS file data. The source name is only |
--   used in error messages and may be the empty string.
parseString :: SourceName -> String -> Either ParseError Problem

-- | Parse a file containing MPS file data.
parseFile :: FilePath -> IO (Either ParseError Problem)

-- | MPS file parser
parser :: Parser Problem
render :: Problem -> Either String String
instance Eq BoundType
instance Ord BoundType
instance Show BoundType
instance Read BoundType
instance Enum BoundType
instance Bounded BoundType


-- | Lifted boolean type.
module ToySolver.Data.LBool

-- | Lifted Bool type. It has three values <a>lTrue</a>, <a>lFalse</a>,
--   <a>lUndef</a>.
data LBool

-- | lifted true value
lTrue :: LBool

-- | lifted false value
lFalse :: LBool

-- | undefined truth value
lUndef :: LBool

-- | <pre>
--   lnot lTrue == lFalse
--   lnot lFalse == lTrue
--   lnot lUndef == lUndef
--   </pre>
lnot :: LBool -> LBool

-- | <pre>
--   liftBool True == lTrue
--   liftBool False == lFalse
--   </pre>
liftBool :: Bool -> LBool

-- | <pre>
--   unliftBool lTrue == Just True
--   unliftBool lFalse == Just False
--   unliftBool lUndef == Nothing
--   </pre>
unliftBool :: LBool -> Maybe Bool
instance Eq LBool
instance Show LBool


module ToySolver.Converter.SAT2PB
convert :: CNF -> Formula


module ToySolver.Converter.PB2SMP
convert :: Bool -> Formula -> ShowS


-- | References:
--   
--   <ul>
--   <li>Improving Unsatisfiability-based Algorithms for Boolean
--   Optimization
--   <a>http://sat.inesc-id.pt/~ruben/talks/sat10-talk.pdf</a></li>
--   </ul>
module ToySolver.Converter.PB2WBO
convert :: Formula -> SoftFormula


module ToySolver.Converter.PB2LSP
convert :: Formula -> ShowS
convertWBO :: SoftFormula -> ShowS

module ToySolver.SAT.Types

-- | Variable is represented as positive integers (DIMACS format).
type Var = Int
type VarSet = IntSet
type VarMap = IntMap
validVar :: Var -> Bool
class IModel a
evalVar :: IModel a => a -> Var -> Bool

-- | A model is represented as a mapping from variables to its values.
type Model = UArray Var Bool

-- | Positive (resp. negative) literals are represented as positive (resp.
--   negative) integers. (DIMACS format).
type Lit = Int
type LitSet = IntSet
type LitMap = IntMap
litUndef :: Lit
validLit :: Lit -> Bool

-- | Construct a literal from a variable and its polarity. <a>True</a>
--   (resp <a>False</a>) means positive (resp. negative) literal.
literal :: Var -> Bool -> Lit

-- | Negation of the <a>Lit</a>.
litNot :: Lit -> Lit

-- | Underlying variable of the <a>Lit</a>
litVar :: Lit -> Var

-- | Polarity of the <a>Lit</a>. <a>True</a> means positive literal and
--   <a>False</a> means negative literal.
litPolarity :: Lit -> Bool
evalLit :: IModel m => m -> Lit -> Bool

-- | Disjunction of <a>Lit</a>.
type Clause = [Lit]

-- | Normalizing clause
--   
--   <a>Nothing</a> if the clause is trivially true.
normalizeClause :: Clause -> Maybe Clause
instantiateClause :: Monad m => (Lit -> m LBool) -> Clause -> m (Maybe Clause)
clauseSubsume :: Clause -> Clause -> Bool
evalClause :: IModel m => m -> Clause -> Bool
clauseToPBLinAtLeast :: Clause -> PBLinAtLeast
type AtLeast = ([Lit], Int)
normalizeAtLeast :: AtLeast -> AtLeast
instantiateAtLeast :: Monad m => (Lit -> m LBool) -> AtLeast -> m AtLeast
evalAtLeast :: IModel m => m -> AtLeast -> Bool
type PBLinTerm = (Integer, Lit)
type PBLinSum = [PBLinTerm]
type PBLinAtLeast = (PBLinSum, Integer)
type PBLinExactly = (PBLinSum, Integer)

-- | normalizing PB term of the form <i>c1 x1 + c2 x2 ... cn xn + c</i>
--   into <i>d1 x1 + d2 x2 ... dm xm + d</i> where d1,...,dm ≥ 1.
normalizePBLinSum :: (PBLinSum, Integer) -> (PBLinSum, Integer)

-- | normalizing PB constraint of the form <i>c1 x1 + c2 cn ... cn xn &gt;=
--   b</i>.
normalizePBLinAtLeast :: PBLinAtLeast -> PBLinAtLeast

-- | normalizing PB constraint of the form <i>c1 x1 + c2 cn ... cn xn =
--   b</i>.
normalizePBLinExactly :: PBLinExactly -> PBLinExactly
instantiatePBLinAtLeast :: Monad m => (Lit -> m LBool) -> PBLinAtLeast -> m PBLinAtLeast
instantiatePBLinExactly :: Monad m => (Lit -> m LBool) -> PBLinExactly -> m PBLinExactly
cutResolve :: PBLinAtLeast -> PBLinAtLeast -> Var -> PBLinAtLeast
cardinalityReduction :: PBLinAtLeast -> AtLeast
negatePBLinAtLeast :: PBLinAtLeast -> PBLinAtLeast
evalPBLinSum :: IModel m => m -> PBLinSum -> Integer
evalPBLinAtLeast :: IModel m => m -> PBLinAtLeast -> Bool
evalPBLinExactly :: IModel m => m -> PBLinAtLeast -> Bool
pbLowerBound :: PBLinSum -> Integer
pbUpperBound :: PBLinSum -> Integer
pbSubsume :: PBLinAtLeast -> PBLinAtLeast -> Bool

-- | XOR clause
--   
--   '([l1,l2..ln], b)' means l1 ⊕ l2 ⊕ ⋯ ⊕ ln = b.
--   
--   Note that:
--   
--   <ul>
--   <li>True can be represented as ([], False)</li>
--   <li>False can be represented as ([], True)</li>
--   </ul>
type XORClause = ([Lit], Bool)

-- | Normalize XOR clause
normalizeXORClause :: XORClause -> XORClause
instantiateXORClause :: Monad m => (Lit -> m LBool) -> XORClause -> m XORClause
evalXORClause :: IModel m => m -> XORClause -> Bool
instance IModel (Var -> Bool)
instance IModel (Array Var Bool)
instance IModel (UArray Var Bool)


module ToySolver.Converter.WBO2PB
convert :: SoftFormula -> (Formula, Model -> Model)

module ToySolver.SAT.TheorySolver
data TheorySolver
TheorySolver :: ((Lit -> IO Bool) -> Lit -> IO Bool) -> ((Lit -> IO Bool) -> IO Bool) -> (Maybe Lit -> IO [Lit]) -> IO () -> IO () -> TheorySolver
thAssertLit :: TheorySolver -> (Lit -> IO Bool) -> Lit -> IO Bool
thCheck :: TheorySolver -> (Lit -> IO Bool) -> IO Bool
thExplain :: TheorySolver -> Maybe Lit -> IO [Lit]
thPushBacktrackPoint :: TheorySolver -> IO ()
thPopBacktrackPoint :: TheorySolver -> IO ()
emptyTheory :: TheorySolver


-- | In this module, we assume each soft constraint <i>C_i</i> is
--   represented as a literal. If a constraint <i>C_i</i> is not a literal,
--   we can represent it as a fresh variable <i>v</i> together with a hard
--   constraint <i>v ⇒ C_i</i>.
--   
--   References:
--   
--   <ul>
--   <li>[CAMUS] M. Liffiton and K. Sakallah, Algorithms for computing
--   minimal unsatisfiable subsets of constraints, Journal of Automated
--   Reasoning, vol. 40, no. 1, pp. 1-33, Jan. 2008.
--   <a>http://sun.iwu.edu/~mliffito/publications/jar_liffiton_CAMUS.pdf</a></li>
--   </ul>
module ToySolver.SAT.MUS.Types

-- | Unsatisfiable Subset of constraints (US).
--   
--   A subset U ⊆ C is an US if U is unsatisfiable.
type US = LitSet

-- | Minimal Unsatisfiable Subset of constraints (MUS).
--   
--   A subset U ⊆ C is an MUS if U is unsatisfiable and ∀C_i ∈ U, U\{C_i}
--   is satisfiable [CAMUS].
type MUS = LitSet

-- | Correction Subset of constraints (CS).
--   
--   A subset M ⊆ C is a CS if C\M is satisfiable. A CS is the complement
--   of a <a>SS</a>.
type CS = LitSet

-- | Minimal Correction Subset of constraints (MCS).
--   
--   A subset M ⊆ C is an MCS if C\M is satisfiable and ∀C_i ∈ M,
--   C\(M\{C_i}) is unsatisfiable [CAMUS]. A MCS is the complement of an
--   <a>MSS</a> and also known as a CoMSS.
type MCS = LitSet

-- | Satisfiable Subset (SS).
--   
--   A subset S ⊆ C is a SS if S is satisfiable. A SS is the complement of
--   a <a>CS</a>.
type SS = LitSet

-- | Maximal Satisfiable Subset (MSS).
--   
--   A subset S ⊆ C is an MSS if S is satisfiable and ∀C_i ∈ U\S, S∪{C_i}
--   is unsatisfiable [CAMUS]. A MSS is the complement of an <a>MCS</a>.
type MSS = LitSet

module ToySolver.SAT.PBO.Context
class Context a
getObjectiveFunction :: Context a => a -> PBLinSum
isUnsat :: Context a => a -> STM Bool
getBestSolution :: Context a => a -> STM (Maybe (Model, Integer))
getLowerBound :: Context a => a -> STM Integer
setUnsat :: Context a => a -> IO ()
addSolution :: Context a => a -> Model -> IO ()
addLowerBound :: Context a => a -> Integer -> IO ()
logMessage :: Context a => a -> String -> IO ()
getBestValue :: Context a => a -> STM (Maybe Integer)
getBestModel :: Context a => a -> STM (Maybe Model)
isOptimum :: Context a => a -> STM Bool
isFinished :: Context a => a -> STM Bool
getSearchUpperBound :: Context a => a -> STM Integer
setFinished :: Context a => a -> IO ()
data SimpleContext
newSimpleContext :: PBLinSum -> IO SimpleContext
setOnUpdateBestSolution :: SimpleContext -> (Model -> Integer -> IO ()) -> IO ()
setOnUpdateLowerBound :: SimpleContext -> (Integer -> IO ()) -> IO ()
setLogger :: SimpleContext -> (String -> IO ()) -> IO ()
data Normalized a
normalize :: Context a => a -> Normalized a
instance Context a => Context (Normalized a)
instance Context SimpleContext


-- | Printing utilities.
module ToySolver.SAT.Printer

-- | Print a <a>Model</a> in a way specified for SAT Competition. See
--   <a>http://www.satcompetition.org/2011/rules.pdf</a> for details.
satPrintModel :: Handle -> Model -> Int -> IO ()

-- | Print a <a>Model</a> in a way specified for Max-SAT Evaluation. See
--   <a>http://maxsat.ia.udl.cat/requirements/</a> for details.
maxsatPrintModel :: Handle -> Model -> Int -> IO ()

-- | Print a <a>Model</a> in a way specified for Pseudo-Boolean
--   Competition. See <a>http://www.cril.univ-artois.fr/PB12/format.pdf</a>
--   for details.
pbPrintModel :: Handle -> Model -> Int -> IO ()
musPrintSol :: Handle -> [Int] -> IO ()


-- | References:
--   
--   <ul>
--   <li><a>http://www.satcompetition.org/2011/rules.pdf</a></li>
--   </ul>
module ToySolver.Text.GCNF
data GCNF
GCNF :: !Int -> !Int -> !GroupIndex -> [GClause] -> GCNF
numVars :: GCNF -> !Int
numClauses :: GCNF -> !Int
lastGroupIndex :: GCNF -> !GroupIndex
clauses :: GCNF -> [GClause]
type GroupIndex = Int
type GClause = (GroupIndex, Clause)
parseString :: String -> Either String GCNF
parseFile :: FilePath -> IO (Either String GCNF)


-- | References:
--   
--   <ul>
--   <li><a>http://maxsat.ia.udl.cat/requirements/</a></li>
--   </ul>
module ToySolver.Text.MaxSAT
data WCNF
WCNF :: !Int -> !Int -> !Weight -> [WeightedClause] -> WCNF
numVars :: WCNF -> !Int
numClauses :: WCNF -> !Int
topCost :: WCNF -> !Weight
clauses :: WCNF -> [WeightedClause]
type WeightedClause = (Weight, Clause)

-- | Weigths must be greater than or equal to 1, and smaller than 2^63.
type Weight = Integer
parseFile :: FilePath -> IO (Either String WCNF)
parseString :: String -> Either String WCNF
parseByteString :: ByteString -> Either String WCNF


module ToySolver.Converter.MaxSAT2WBO
convert :: WCNF -> SoftFormula


module ToySolver.Converter.MaxSAT2NLPB
convert :: WCNF -> Formula


module ToySolver.Converter.ObjType
data ObjType
ObjNone :: ObjType
ObjMaxOne :: ObjType
ObjMaxZero :: ObjType
instance Eq ObjType


module ToySolver.Converter.PBSetObj
data ObjType
ObjNone :: ObjType
ObjMaxOne :: ObjType
ObjMaxZero :: ObjType
setObj :: ObjType -> Formula -> Formula


-- | Simple 0-1 knapsack problem solver that uses DP.
module ToySolver.Combinatorial.Knapsack.DP
type Weight = Int
type Value = Rational
solve :: [(Value, Weight)] -> Weight -> (Value, Weight, [Bool])


-- | Simple 0-1 knapsack problem solver that uses branch-and-bound with
--   LP-relaxation based upper bound.
module ToySolver.Combinatorial.Knapsack.BB
type Weight = Rational
type Value = Rational
solve :: [(Value, Weight)] -> Weight -> (Value, Weight, [Bool])


-- | This modules provides functions to check whether two monotone boolean
--   functions <i>f</i> and <i>g</i> given in DNFs are mutually dual
--   (<i>i.e.</i> f(x1,…,xn) = ¬g(¬x1,…,¬xn)).
--   
--   References:
--   
--   <ul>
--   <li>[FredmanKhachiyan1996] Michael L. Fredman and Leonid Khachiyan, On
--   the Complexicy of Dualization of Monotone Disjunctifve Normal Forms,
--   Journal of Algorithms, vol. 21, pp. 618-628, 1996.
--   <a>http://www.sciencedirect.com/science/article/pii/S0196677496900620</a>
--   <a>http://www.cs.tau.ac.il/~fiat/dmsem03/On%20the%20complexity%20of%20Dualization%20of%20monotone%20Disjunctive%20Normal%20Forms%20-%201996.pdf</a></li>
--   </ul>
module ToySolver.Combinatorial.HittingSet.FredmanKhachiyan1996

-- | <tt>areDualDNFs f g</tt> checks whether two monotone boolean functions
--   <i>f</i> and <i>g</i> are mutually dual (<i>i.e.</i> f(x1,…,xn) =
--   ¬g(¬x1,…,xn)).
--   
--   Note that this function does not care about redundancy of DNFs.
--   
--   Complexity: <i>O(n^o(log n))</i> where <tt>n = <a>size</a> f +
--   <a>size</a> g</tt>.
areDualDNFs :: Set IntSet -> Set IntSet -> Bool

-- | Synonym for <a>checkDualityB</a>.
checkDuality :: Set IntSet -> Set IntSet -> Maybe IntSet

-- | <tt>checkDualityA f g</tt> checks whether two monotone boolean
--   functions <i>f</i> and <i>g</i> are mutually dual (<i>i.e.</i>
--   f(x1,…,xn) = ¬g(¬x1,…,¬xn)) using “Algorithm A” of
--   [FredmanKhachiyan1996].
--   
--   If they are indeed mutually dual it returns <tt>Nothing</tt>,
--   otherwise it returns <tt>Just cs</tt> such that {xi ↦ (if xi∈cs then
--   True else False) | i∈{1…n}} is a solution of f(x1,…,xn) =
--   g(¬x1,…,¬xn)).
--   
--   Note that this function does not care about redundancy of DNFs.
--   
--   Complexity: <i>O(n^O(log^2 n))</i> where <tt>n = <a>size</a> f +
--   <a>size</a> g</tt>.
checkDualityA :: Set IntSet -> Set IntSet -> Maybe IntSet

-- | <tt>checkDualityB f g</tt> checks whether two monotone boolean
--   functions <i>f</i> and <i>g</i> are mutually dual (i.e. f(x1,…,xn) =
--   ¬g(¬x1,…,xn)) using “Algorithm B” of [FredmanKhachiyan1996].
--   
--   If they are indeed mutually dual it returns <tt>Nothing</tt>,
--   otherwise it returns <tt>Just cs</tt> such that {xi ↦ (if xi∈cs then
--   True else False) | i∈{1…n}} is a solution of f(x1,…,xn) =
--   g(¬x1,…,xn)).
--   
--   Note that this function does not care about redundancy of DNFs.
--   
--   Complexity: <i>O(n^o(log n))</i> where <tt>n = <a>size</a> f +
--   <a>size</a> g</tt>.
checkDualityB :: Set IntSet -> Set IntSet -> Maybe IntSet

-- | <tt><a>isRedundant</a> F</tt> tests whether <i>F</i> contains
--   redundant implicants.
isRedundant :: Set IntSet -> Bool

-- | Removes redundant implicants from a given DNF.
deleteRedundancy :: Set IntSet -> Set IntSet
isCounterExampleOf :: IntSet -> (Set IntSet, Set IntSet) -> Bool

-- | <tt>occurFreq x F</tt> computes <i>|{I∈F | x∈I}| / |F|</i>
occurFreq :: Fractional a => Int -> Set IntSet -> a


-- | References:
--   
--   <ul>
--   <li>[GurvichKhachiyan1999] Vladimir Gurvich and Leonid Khachiyan, On
--   generating the irredundant conjunctive and disjunctive normal forms of
--   monotone Boolean functions, Discrete Applied Mathematics, vol. 96-97,
--   pp. 363-373, 1999.
--   <a>http://www.sciencedirect.com/science/article/pii/S0166218X99000992</a></li>
--   </ul>
module ToySolver.Combinatorial.HittingSet.GurvichKhachiyan1999

-- | Find a new prime implicant or implicate.
--   
--   Let <i>f</i> be a monotone boolean function over set of variables
--   <i>S</i>. Let ∧_{I∈C} ∨_{i∈I} x_i and ∨_{I∈D} ∧_{i∈I} x_i be the
--   irredundant CNF representation <i>f</i> and DNF representation of
--   <i>f</i> respectively.
--   
--   Given a subset <i>C' ⊆ C</i> and <i>D' ⊆ D</i>,
--   <tt><a>findPrimeImplicateOrPrimeImplicant</a> S f C' D'</tt> returns
--   
--   <ul>
--   <li><tt>Just (Left I)</tt> where I ∈ C \ C',</li>
--   <li><tt>Just (Right I)</tt> where J ∈ D \ D', or</li>
--   <li><tt>Nothing</tt> if <i>C'=C</i> and <i>D'=D</i>.</li>
--   </ul>
findPrimeImplicateOrPrimeImplicant :: IntSet -> (IntSet -> Bool) -> Set IntSet -> Set IntSet -> Maybe (Either IntSet IntSet)

-- | Compute the irredundant CNF representation and DNF representation.
--   
--   Let <i>f</i> be a monotone boolean function over set of variables
--   <i>S</i>. This function returns <i>C</i> and <i>D</i> where ∧_{I∈C}
--   ∨_{i∈I} x_i and ∨_{I∈D} ∧_{i∈I} x_i are the irredundant CNF
--   representation <i>f</i> and DNF representation of <i>f</i>
--   respectively.
generateCNFAndDNF :: IntSet -> (IntSet -> Bool) -> Set IntSet -> Set IntSet -> (Set IntSet, Set IntSet)
minimalHittingSets :: Set IntSet -> Set IntSet
enumMinimalHittingSets :: Set IntSet -> [IntSet]


module ToySolver.Internal.ProcessUtil
runProcessWithOutputCallback :: FilePath -> [String] -> String -> (String -> IO ()) -> (String -> IO ()) -> IO ExitCode


-- | Wrapper for shd command.
--   
--   <ul>
--   <li>Hypergraph Dualization Repository
--   <a>http://research.nii.ac.jp/~uno/dualization.html</a></li>
--   </ul>
module ToySolver.Combinatorial.HittingSet.SHD
data Options
Options :: FilePath -> [String] -> (String -> IO ()) -> (String -> IO ()) -> Options
optSHDCommand :: Options -> FilePath
optSHDArgs :: Options -> [String]
optOnGetLine :: Options -> String -> IO ()
optOnGetErrorLine :: Options -> String -> IO ()
data Failure
Failure :: !Int -> Failure
defaultOptions :: Options
minimalHittingSets :: Options -> Set IntSet -> IO (Set IntSet)
instance Typeable Failure
instance Show Failure
instance Exception Failure
instance Default Options


-- | Wrapper for htcbdd command.
--   
--   <ul>
--   <li>HTC-BDD: Hypergraph Transversal Computation with Binary Decision
--   Diagrams <a>http://kuma-san.net/htcbdd.html</a></li>
--   </ul>
module ToySolver.Combinatorial.HittingSet.HTCBDD
data Options
Options :: FilePath -> Method -> (String -> IO ()) -> (String -> IO ()) -> Options
optHTCBDDCommand :: Options -> FilePath
optMethod :: Options -> Method
optOnGetLine :: Options -> String -> IO ()
optOnGetErrorLine :: Options -> String -> IO ()
data Method
MethodToda :: Method
MethodKnuth :: Method
data Failure
Failure :: !Int -> Failure
defaultOptions :: Options
minimalHittingSets :: Options -> Set IntSet -> IO (Set IntSet)
instance Typeable Failure
instance Eq Method
instance Ord Method
instance Show Method
instance Show Failure
instance Exception Failure
instance Default Options
instance Default Method


module ToySolver.Combinatorial.HittingSet.Simple
minimalHittingSets :: Set IntSet -> Set IntSet
enumMinimalHittingSets :: Set IntSet -> [IntSet]


-- | A CDCL SAT solver.
--   
--   It follows the design of MiniSat and SAT4J.
--   
--   See also:
--   
--   <ul>
--   <li><a>http://hackage.haskell.org/package/funsat</a></li>
--   
--   <li><a>http://hackage.haskell.org/package/incremental-sat-solver</a></li>
--   </ul>
module ToySolver.SAT

-- | Solver instance
data Solver

-- | Create a new Solver instance.
newSolver :: IO Solver

-- | Variable is represented as positive integers (DIMACS format).
type Var = Int

-- | Positive (resp. negative) literals are represented as positive (resp.
--   negative) integers. (DIMACS format).
type Lit = Int

-- | Construct a literal from a variable and its polarity. <a>True</a>
--   (resp <a>False</a>) means positive (resp. negative) literal.
literal :: Var -> Bool -> Lit

-- | Negation of the <a>Lit</a>.
litNot :: Lit -> Lit

-- | Underlying variable of the <a>Lit</a>
litVar :: Lit -> Var

-- | Polarity of the <a>Lit</a>. <a>True</a> means positive literal and
--   <a>False</a> means negative literal.
litPolarity :: Lit -> Bool

-- | Disjunction of <a>Lit</a>.
type Clause = [Lit]

-- | Add a new variable
newVar :: Solver -> IO Var

-- | Add variables. <tt>newVars solver n = replicateM n (newVar
--   solver)</tt>
newVars :: Solver -> Int -> IO [Var]

-- | Add variables. <tt>newVars_ solver n = newVars solver n &gt;&gt;
--   return ()</tt>
newVars_ :: Solver -> Int -> IO ()

-- | Pre-allocate internal buffer for <tt>n</tt> variables.
resizeVarCapacity :: Solver -> Int -> IO ()

-- | Add a clause to the solver.
addClause :: Solver -> Clause -> IO ()

-- | Add a cardinality constraints <i>atleast({l1,l2,..},n)</i>.
addAtLeast :: Solver -> [Lit] -> Int -> IO ()

-- | Add a cardinality constraints <i>atmost({l1,l2,..},n)</i>.
addAtMost :: Solver -> [Lit] -> Int -> IO ()

-- | Add a cardinality constraints <i>exactly({l1,l2,..},n)</i>.
addExactly :: Solver -> [Lit] -> Int -> IO ()

-- | Add a pseudo boolean constraints <i>c1*l1 + c2*l2 + … ≥ n</i>.
addPBAtLeast :: Solver -> [(Integer, Lit)] -> Integer -> IO ()

-- | Add a pseudo boolean constraints <i>c1*l1 + c2*l2 + … ≤ n</i>.
addPBAtMost :: Solver -> [(Integer, Lit)] -> Integer -> IO ()

-- | Add a pseudo boolean constraints <i>c1*l1 + c2*l2 + … = n</i>.
addPBExactly :: Solver -> [(Integer, Lit)] -> Integer -> IO ()

-- | Add a soft pseudo boolean constraints <i>sel ⇒ c1*l1 + c2*l2 + … ≥
--   n</i>.
addPBAtLeastSoft :: Solver -> Lit -> [(Integer, Lit)] -> Integer -> IO ()

-- | Add a soft pseudo boolean constraints <i>sel ⇒ c1*l1 + c2*l2 + … ≤
--   n</i>.
addPBAtMostSoft :: Solver -> Lit -> [(Integer, Lit)] -> Integer -> IO ()

-- | Add a soft pseudo boolean constraints <i>sel ⇒ c1*l1 + c2*l2 + … =
--   n</i>.
addPBExactlySoft :: Solver -> Lit -> [(Integer, Lit)] -> Integer -> IO ()

-- | Add a parity constraint <i>l1 ⊕ l2 ⊕ … ⊕ ln = rhs</i>
addXORClause :: Solver -> [Lit] -> Bool -> IO ()

-- | Add a soft parity constraint <i>sel ⇒ l1 ⊕ l2 ⊕ … ⊕ ln = rhs</i>
addXORClauseSoft :: Solver -> Lit -> [Lit] -> Bool -> IO ()
setTheory :: Solver -> TheorySolver -> IO ()

-- | Solve constraints. Returns <a>True</a> if the problem is SATISFIABLE.
--   Returns <a>False</a> if the problem is UNSATISFIABLE.
solve :: Solver -> IO Bool

-- | Solve constraints under assuptions. Returns <a>True</a> if the problem
--   is SATISFIABLE. Returns <a>False</a> if the problem is UNSATISFIABLE.
solveWith :: Solver -> [Lit] -> IO Bool
data BudgetExceeded
BudgetExceeded :: BudgetExceeded

-- | A model is represented as a mapping from variables to its values.
type Model = UArray Var Bool

-- | After <a>solve</a> returns True, it returns an satisfying assignment.
getModel :: Solver -> IO Model

-- | After <a>solveWith</a> returns False, it returns a set of assumptions
--   that leads to contradiction. In particular, if it returns an empty
--   set, the problem is unsatisiable without any assumptions.
getFailedAssumptions :: Solver -> IO [Lit]
data RestartStrategy
MiniSATRestarts :: RestartStrategy
ArminRestarts :: RestartStrategy
LubyRestarts :: RestartStrategy
setRestartStrategy :: Solver -> RestartStrategy -> IO ()

-- | default value for <tt>RestartStrategy</tt>.
defaultRestartStrategy :: RestartStrategy

-- | The initial restart limit. (default 100) Zero and negative values are
--   used to disable restart.
setRestartFirst :: Solver -> Int -> IO ()

-- | default value for <tt>RestartFirst</tt>.
defaultRestartFirst :: Int

-- | The factor with which the restart limit is multiplied in each restart.
--   (default 1.5)
--   
--   This must be <tt>&gt;1</tt>.
setRestartInc :: Solver -> Double -> IO ()

-- | default value for <tt>RestartInc</tt>.
defaultRestartInc :: Double

-- | The initial limit for learnt clauses.
--   
--   Negative value means computing default value from problem instance.
setLearntSizeFirst :: Solver -> Int -> IO ()

-- | default value for <tt>LearntSizeFirst</tt>.
defaultLearntSizeFirst :: Int

-- | The limit for learnt clauses is multiplied with this factor each
--   restart. (default 1.1)
--   
--   This must be <tt>&gt;1</tt>.
setLearntSizeInc :: Solver -> Double -> IO ()

-- | default value for <tt>LearntSizeInc</tt>.
defaultLearntSizeInc :: Double

-- | Controls conflict clause minimization (0=none, 1=basic, 2=deep)
setCCMin :: Solver -> Int -> IO ()

-- | default value for <tt>CCMin</tt>.
defaultCCMin :: Int
data LearningStrategy
LearningClause :: LearningStrategy
LearningHybrid :: LearningStrategy
setLearningStrategy :: Solver -> LearningStrategy -> IO ()
defaultLearningStrategy :: LearningStrategy
setEnablePhaseSaving :: Solver -> Bool -> IO ()
getEnablePhaseSaving :: Solver -> IO Bool
defaultEnablePhaseSaving :: Bool
setEnableForwardSubsumptionRemoval :: Solver -> Bool -> IO ()
getEnableForwardSubsumptionRemoval :: Solver -> IO Bool
defaultEnableForwardSubsumptionRemoval :: Bool
setEnableBackwardSubsumptionRemoval :: Solver -> Bool -> IO ()
getEnableBackwardSubsumptionRemoval :: Solver -> IO Bool
defaultEnableBackwardSubsumptionRemoval :: Bool

-- | The default polarity of a variable.
setVarPolarity :: Solver -> Var -> Bool -> IO ()

-- | set callback function for receiving messages.
setLogger :: Solver -> (String -> IO ()) -> IO ()
setCheckModel :: Solver -> Bool -> IO ()

-- | The frequency with which the decision heuristic tries to choose a
--   random variable
setRandomFreq :: Solver -> Double -> IO ()
defaultRandomFreq :: Double

-- | Set random generator used by the random variable selection
setRandomGen :: Solver -> StdGen -> IO ()

-- | Get random generator used by the random variable selection
getRandomGen :: Solver -> IO StdGen
setConfBudget :: Solver -> Maybe Int -> IO ()
data PBHandlerType
PBHandlerTypeCounter :: PBHandlerType
PBHandlerTypePueblo :: PBHandlerType
setPBHandlerType :: Solver -> PBHandlerType -> IO ()
defaultPBHandlerType :: PBHandlerType

-- | Split PB-constraints into a PB part and a clause part.
--   
--   Example from minisat+ paper:
--   
--   <ul>
--   <li>4 x1 + 4 x2 + 4 x3 + 4 x4 + 2y1 + y2 + y3 ≥ 4</li>
--   </ul>
--   
--   would be split into
--   
--   <ul>
--   <li>x1 + x2 + x3 + x4 + ¬z ≥ 1 (clause part)</li>
--   <li>2 y1 + y2 + y3 + 4 z ≥ 4 (PB part)</li>
--   </ul>
--   
--   where z is a newly introduced variable, not present in any other
--   constraint.
--   
--   Reference:
--   
--   <ul>
--   <li>N . Eéen and N. Sörensson. Translating Pseudo-Boolean Constraints
--   into SAT. JSAT 2:1–26, 2006.</li>
--   </ul>
setPBSplitClausePart :: Solver -> Bool -> IO ()

-- | See documentation of <a>setPBSplitClausePart</a>.
getPBSplitClausePart :: Solver -> IO Bool

-- | See documentation of <a>setPBSplitClausePart</a>.
defaultPBSplitClausePart :: Bool

-- | number of variables of the problem.
getNVars :: Solver -> IO Int

-- | number of constraints.
getNConstraints :: Solver -> IO Int

-- | number of learnt constrints.
getNLearntConstraints :: Solver -> IO Int
getVarFixed :: Solver -> Var -> IO LBool
getLitFixed :: Solver -> Var -> IO LBool

-- | number of variables of the problem.

-- | <i>Deprecated: Use getNVars instead</i>
nVars :: Solver -> IO Int

-- | number of assigned variables.

-- | <i>Deprecated: nAssigns is deprecated</i>
nAssigns :: Solver -> IO Int

-- | number of constraints.

-- | <i>Deprecated: Use getNConstraints instead</i>
nConstraints :: Solver -> IO Int

-- | number of learnt constrints.

-- | <i>Deprecated: Use getNLearntConstraints instead</i>
nLearnt :: Solver -> IO Int
varBumpActivity :: Solver -> Var -> IO ()
varDecayActivity :: Solver -> IO ()
instance Typeable BudgetExceeded
instance Show BudgetExceeded
instance Show LearningStrategy
instance Eq LearningStrategy
instance Ord LearningStrategy
instance Enum LearningStrategy
instance Bounded LearningStrategy
instance Show PBHandlerType
instance Eq PBHandlerType
instance Ord PBHandlerType
instance Enum PBHandlerType
instance Bounded PBHandlerType
instance Eq TheoryHandler
instance Eq SomeConstraintHandler
instance Show RestartStrategy
instance Eq RestartStrategy
instance Ord RestartStrategy
instance Enum RestartStrategy
instance Bounded RestartStrategy
instance ConstraintHandler TheoryHandler
instance Hashable TheoryHandler
instance ConstraintHandler XORClauseHandler
instance Hashable XORClauseHandler
instance Eq XORClauseHandler
instance ConstraintHandler PBHandlerPueblo
instance Hashable PBHandlerPueblo
instance Eq PBHandlerPueblo
instance ConstraintHandler PBHandlerCounter
instance Hashable PBHandlerCounter
instance Eq PBHandlerCounter
instance ConstraintHandler AtLeastHandler
instance Hashable AtLeastHandler
instance Eq AtLeastHandler
instance ConstraintHandler ClauseHandler
instance Hashable ClauseHandler
instance Eq ClauseHandler
instance ConstraintHandler SomeConstraintHandler
instance Hashable SomeConstraintHandler
instance Exception BudgetExceeded


-- | Minimal Unsatifiable Subset (MUS) Finder
module ToySolver.SAT.MUS

-- | Options for <a>findMUSAssumptions</a> function
data Options
Options :: (String -> IO ()) -> ([Lit] -> IO ()) -> (Lit -> String) -> Options
optLogger :: Options -> String -> IO ()
optUpdateBest :: Options -> [Lit] -> IO ()
optLitPrinter :: Options -> Lit -> String

-- | default <a>Options</a> value
defaultOptions :: Options

-- | Find a minimal set of assumptions that causes a conflict. Initial set
--   of assumptions is taken from <a>getFailedAssumptions</a>.
findMUSAssumptions :: Solver -> Options -> IO MUS
instance Default Options


-- | In this module, we assume each soft constraint <i>C_i</i> is
--   represented as a literal. If a constraint <i>C_i</i> is not a literal,
--   we can represent it as a fresh variable <i>v</i> together with a hard
--   constraint <i>v ⇒ C_i</i>.
--   
--   References:
--   
--   <ul>
--   <li>[CAMUS] M. Liffiton and K. Sakallah, Algorithms for computing
--   minimal unsatisfiable subsets of constraints, Journal of Automated
--   Reasoning, vol. 40, no. 1, pp. 1-33, Jan. 2008.
--   <a>http://sun.iwu.edu/~mliffito/publications/jar_liffiton_CAMUS.pdf</a></li>
--   <li>[HYCAM] A. Gregoire, B. Mazure, and C. Piette, Boosting a complete
--   technique to find MSS and MUS: thanks to a local search oracle, in
--   Proceedings of the 20th international joint conference on Artifical
--   intelligence, ser. IJCAI'07. San Francisco, CA, USA: Morgan Kaufmann
--   Publishers Inc., 2007, pp. 2300-2305.
--   <a>http://ijcai.org/papers07/Papers/IJCAI07-370.pdf</a></li>
--   </ul>
module ToySolver.SAT.MUS.CAMUS

-- | Options for <a>enumMCSAssumptions</a>, <a>allMCSAssumptions</a>,
--   <a>allMUSAssumptions</a>
data Options
Options :: (String -> IO ()) -> (MCS -> IO ()) -> (MUS -> IO ()) -> [MCS] -> [MUS] -> [CS] -> Options
optLogger :: Options -> String -> IO ()
optOnMCSFound :: Options -> MCS -> IO ()
optOnMUSFound :: Options -> MUS -> IO ()
optKnownMCSes :: Options -> [MCS]
optKnownMUSes :: Options -> [MUS]

-- | MCS candidates (see HYCAM paper for details). A MCS candidate must be
--   a superset of a real MCS.
optKnownCSes :: Options -> [CS]

-- | default <a>Options</a> value
defaultOptions :: Options
allMCSAssumptions :: Solver -> [Lit] -> Options -> IO [MCS]
allMUSAssumptions :: Solver -> [Lit] -> Options -> IO [MUS]
enumMCSAssumptions :: Solver -> [Lit] -> Options -> IO ()
camus :: Solver -> [Lit] -> Options -> IO ([MUS], [MCS])
instance Default Options


-- | "Dualize and Advance" algorithm for finding minimal unsatisfiable
--   sets.
--   
--   <ul>
--   <li>[DAA] J. Bailey and P. Stuckey, Discovery of minimal unsatisfiable
--   subsets of constraints using hitting set dualization," in Practical
--   Aspects of Declarative Languages, pp. 174-186, 2005.
--   <a>http://ww2.cs.mu.oz.au/~pjs/papers/padl05.pdf</a></li>
--   </ul>
module ToySolver.SAT.MUS.DAA

-- | Options for <a>enumMCSAssumptions</a>, <a>allMCSAssumptions</a>,
--   <a>allMUSAssumptions</a>
data Options
Options :: (String -> IO ()) -> (MCS -> IO ()) -> (MUS -> IO ()) -> [MCS] -> [MUS] -> [CS] -> Options
optLogger :: Options -> String -> IO ()
optOnMCSFound :: Options -> MCS -> IO ()
optOnMUSFound :: Options -> MUS -> IO ()
optKnownMCSes :: Options -> [MCS]
optKnownMUSes :: Options -> [MUS]

-- | MCS candidates (see HYCAM paper for details). A MCS candidate must be
--   a superset of a real MCS.
optKnownCSes :: Options -> [CS]

-- | default <a>Options</a> value
defaultOptions :: Options
allMCSAssumptions :: Solver -> [Lit] -> Options -> IO [MCS]
allMUSAssumptions :: Solver -> [Lit] -> Options -> IO [MUS]
daa :: Solver -> [Lit] -> Options -> IO ([MUS], [MCS])


-- | Minimal Unsatifiable Subset (MUS) Finder based on QuickXplain
--   algorithm.
--   
--   References:
--   
--   <ul>
--   <li>Ulrich Junker. QuickXplain: Preferred explanations and relaxations
--   for over-constrained problems. In Proc. of AAAI’04, pages 167-172,
--   2004. <a>http://www.aaai.org/Papers/AAAI/2004/AAAI04-027.pdf</a></li>
--   </ul>
module ToySolver.SAT.MUS.QuickXplain

-- | Options for <a>findMUSAssumptions</a> function
data Options
Options :: (String -> IO ()) -> ([Lit] -> IO ()) -> (Lit -> String) -> Options
optLogger :: Options -> String -> IO ()
optUpdateBest :: Options -> [Lit] -> IO ()
optLitPrinter :: Options -> Lit -> String

-- | default <a>Options</a> value
defaultOptions :: Options

-- | Find a minimal set of assumptions that causes a conflict. Initial set
--   of assumptions is taken from <a>getFailedAssumptions</a>.
findMUSAssumptions :: Solver -> Options -> IO MUS


-- | Core-Guided binary search algorithm.
--   
--   Reference:
--   
--   <ul>
--   <li>Federico Heras, Antonio Morgado, João Marques-Silva, Core-Guided
--   binary search algorithms for maximum satisfiability, Twenty-Fifth AAAI
--   Conference on Artificial Intelligence, 2011.
--   <a>http://www.aaai.org/ocs/index.php/AAAI/AAAI11/paper/view/3713</a></li>
--   </ul>
module ToySolver.SAT.PBO.BC
solve :: Context cxt => cxt -> Solver -> IO ()


-- | Reference:
--   
--   <ul>
--   <li>Federico Heras, Antonio Morgado, João Marques-Silva, Core-Guided
--   binary search algorithms for maximum satisfiability, Twenty-Fifth AAAI
--   Conference on Artificial Intelligence, 2011.
--   <a>http://www.aaai.org/ocs/index.php/AAAI/AAAI11/paper/view/3713</a></li>
--   <li>A. Morgado, F. Heras, and J. Marques-Silva, Improvements to
--   Core-Guided binary search for MaxSAT, in Theory and Applications of
--   Satisfiability Testing (SAT 2012), pp. 284-297.
--   <a>http://dx.doi.org/10.1007/978-3-642-31612-8_22</a>
--   <a>http://ulir.ul.ie/handle/10344/2771</a></li>
--   </ul>
module ToySolver.SAT.PBO.BCD
solve :: Context cxt => cxt -> Solver -> IO ()


-- | Reference:
--   
--   <ul>
--   <li>Federico Heras, Antonio Morgado, João Marques-Silva, Core-Guided
--   binary search algorithms for maximum satisfiability, Twenty-Fifth AAAI
--   Conference on Artificial Intelligence, 2011.
--   <a>http://www.aaai.org/ocs/index.php/AAAI/AAAI11/paper/view/3713</a></li>
--   <li>A. Morgado, F. Heras, and J. Marques-Silva, Improvements to
--   Core-Guided binary search for MaxSAT, in Theory and Applications of
--   Satisfiability Testing (SAT 2012), pp. 284-297.
--   <a>http://dx.doi.org/10.1007/978-3-642-31612-8_22</a>
--   <a>http://ulir.ul.ie/handle/10344/2771</a></li>
--   </ul>
module ToySolver.SAT.PBO.BCD2
data Options
Options :: Bool -> Bool -> Bool -> Options
optEnableHardening :: Options -> Bool
optEnableBiasedSearch :: Options -> Bool
optSolvingNormalFirst :: Options -> Bool
defaultOptions :: Options
solve :: Context cxt => cxt -> Solver -> Options -> IO ()
instance Default Options


-- | Reference:
--   
--   <ul>
--   <li>Vasco Manquinho Ruben Martins Inês Lynce Improving
--   Unsatisfiability-based Algorithms for Boolean Optimization. Theory and
--   Applications of Satisfiability Testing – SAT 2010, pp 181-193.
--   <a>http://dx.doi.org/10.1007/978-3-642-14186-7_16</a>
--   <a>http://sat.inesc-id.pt/~ruben/papers/manquinho-sat10.pdf</a>
--   <a>http://sat.inesc-id.pt/~ruben/talks/sat10-talk.pdf</a></li>
--   </ul>
module ToySolver.SAT.PBO.UnsatBased
solve :: Context cxt => cxt -> Solver -> IO ()


-- | Reference:
--   
--   <ul>
--   <li>João P. Marques-Silva and Jordi Planes. Algorithms for Maximum
--   Satisfiability using Unsatisfiable Cores. In Design, Automation and
--   Test in Europe, 2008 (DATE '08). March 2008. pp. 408-413,
--   doi:10.1109/date.2008.4484715.
--   <a>http://dx.doi.org/10.1109/date.2008.4484715</a>
--   <a>http://eprints.soton.ac.uk/265000/1/jpms-date08.pdf</a>
--   <a>http://www.csi.ucd.ie/staff/jpms/talks/talksite/jpms-date08.pdf</a></li>
--   </ul>
module ToySolver.SAT.PBO.MSU4
solve :: Context cxt => cxt -> Solver -> IO ()


-- | Pseudo-Boolean Optimization (PBO) Solver
module ToySolver.SAT.PBO
data Optimizer
newOptimizer :: Solver -> PBLinSum -> IO Optimizer
optimize :: Optimizer -> IO ()
addSolution :: Optimizer -> Model -> IO ()
getBestSolution :: Optimizer -> IO (Maybe (Model, Integer))
getBestValue :: Optimizer -> IO (Maybe Integer)
getBestModel :: Optimizer -> IO (Maybe Model)
isUnsat :: Optimizer -> IO Bool
isOptimum :: Optimizer -> IO Bool
isFinished :: Optimizer -> IO Bool
data SearchStrategy
LinearSearch :: SearchStrategy
BinarySearch :: SearchStrategy
AdaptiveSearch :: SearchStrategy
UnsatBased :: SearchStrategy
MSU4 :: SearchStrategy
BC :: SearchStrategy
BCD :: SearchStrategy
BCD2 :: SearchStrategy
defaultSearchStrategy :: SearchStrategy
getSearchStrategy :: Optimizer -> IO SearchStrategy
setSearchStrategy :: Optimizer -> SearchStrategy -> IO ()
defaultEnableObjFunVarsHeuristics :: Bool
getEnableObjFunVarsHeuristics :: Optimizer -> IO Bool
setEnableObjFunVarsHeuristics :: Optimizer -> Bool -> IO ()
defaultTrialLimitConf :: Int
getTrialLimitConf :: Optimizer -> IO Int
setTrialLimitConf :: Optimizer -> Int -> IO ()
setOnUpdateBestSolution :: Optimizer -> (Model -> Integer -> IO ()) -> IO ()
setOnUpdateLowerBound :: Optimizer -> (Integer -> IO ()) -> IO ()
setLogger :: Optimizer -> (String -> IO ()) -> IO ()
instance Default SearchStrategy


-- | References:
--   
--   <ul>
--   <li>R. Nieuwenhuis and A. Oliveras, "Fast congruence closure and
--   extensions," Information and Computation, vol. 205, no. 4, pp.
--   557-580, Apr. 2007.
--   <a>http://www.lsi.upc.edu/~oliveras/espai/papers/IC.pdf</a></li>
--   </ul>
module ToySolver.CongruenceClosure
data Solver
type Var = Int
data FlatTerm
FTConst :: Var -> FlatTerm
FTApp :: Var -> Var -> FlatTerm
newSolver :: IO Solver
newVar :: Solver -> IO Var
merge :: Solver -> (FlatTerm, Var) -> IO ()
areCongruent :: Solver -> FlatTerm -> FlatTerm -> IO Bool
instance Ord FlatTerm
instance Eq FlatTerm
instance Show FlatTerm


-- | Type classes for lattices and boolean algebras.
module ToySolver.Data.Boolean
class MonotoneBoolean a where true = andB [] false = orB [] a .&&. b = andB [a, b] a .||. b = orB [a, b] andB [] = true andB [a] = a andB xs = foldr1 (.&&.) xs orB [] = false orB [a] = a orB xs = foldr1 (.||.) xs
true, false :: MonotoneBoolean a => a
(.&&.) :: MonotoneBoolean a => a -> a -> a
(.||.) :: MonotoneBoolean a => a -> a -> a
andB :: MonotoneBoolean a => [a] -> a
orB :: MonotoneBoolean a => [a] -> a

-- | types that can be negated.
class Complement a
notB :: Complement a => a -> a

-- | types that can be combined with boolean operations.
class (MonotoneBoolean a, Complement a) => Boolean a where x .=>. y = notB x .||. y x .<=>. y = (x .=>. y) .&&. (y .=>. x) ite c t e = (c .&&. t) .||. (notB c .&&. e)
(.=>., .<=>.) :: Boolean a => a -> a -> a
ite :: Boolean a => a -> a -> a -> a
instance Boolean Bool
instance MonotoneBoolean Bool
instance Complement Bool
instance Boolean a => Boolean (b -> a)
instance MonotoneBoolean a => MonotoneBoolean (b -> a)
instance Complement a => Complement (b -> a)
instance (Boolean a, Boolean b) => Boolean (a, b)
instance (MonotoneBoolean a, MonotoneBoolean b) => MonotoneBoolean (a, b)
instance (Complement a, Complement b) => Complement (a, b)


-- | A simple model finder.
--   
--   References:
--   
--   <ul>
--   <li>Koen Claessen and Niklas Sörensson. New Techniques that Improve
--   MACE-style Finite Model Finding. CADE-19. 2003.
--   <a>http://www.cs.miami.edu/~geoff/Conferences/CADE/Archive/CADE-19/WS4/04.pdf</a></li>
--   </ul>
module ToySolver.FOLModelFinder

-- | Variable
type Var = String

-- | Function Symbol
type FSym = String

-- | Predicate Symbol
type PSym = String

-- | Generalized literal type parameterized by atom type
data GenLit a
Pos :: a -> GenLit a
Neg :: a -> GenLit a

-- | Term
data Term
TmApp :: FSym -> [Term] -> Term
TmVar :: Var -> Term
data Atom
PApp :: PSym -> [Term] -> Atom
type Lit = GenLit Atom
type Clause = [Lit]
type Formula = GenFormula Atom
data GenFormula a
T :: GenFormula a
F :: GenFormula a
Atom :: a -> GenFormula a
And :: (GenFormula a) -> (GenFormula a) -> GenFormula a
Or :: (GenFormula a) -> (GenFormula a) -> GenFormula a
Not :: (GenFormula a) -> GenFormula a
Imply :: (GenFormula a) -> (GenFormula a) -> GenFormula a
Equiv :: (GenFormula a) -> (GenFormula a) -> GenFormula a
Forall :: Var -> (GenFormula a) -> GenFormula a
Exists :: Var -> (GenFormula a) -> GenFormula a

-- | normalize a formula into a skolem normal form.
--   
--   TODO:
--   
--   <ul>
--   <li>Tseitin encoding</li>
--   </ul>
toSkolemNF :: Monad m => (String -> Int -> m FSym) -> Formula -> m [Clause]
data Model
Model :: [Entity] -> Map PSym [[Entity]] -> Map FSym [([Entity], Entity)] -> Model
mUniverse :: Model -> [Entity]
mRelations :: Model -> Map PSym [[Entity]]
mFunctions :: Model -> Map FSym [([Entity], Entity)]

-- | Element of model.
type Entity = Int
showModel :: Model -> [String]

-- | print entity
showEntity :: Entity -> String
findModel :: Int -> [Clause] -> IO (Maybe Model)
instance Show a => Show (GenLit a)
instance Eq a => Eq (GenLit a)
instance Ord a => Ord (GenLit a)
instance Show Term
instance Eq Term
instance Ord Term
instance Show Atom
instance Eq Atom
instance Ord Atom
instance Show a => Show (GenFormula a)
instance Eq a => Eq (GenFormula a)
instance Ord a => Ord (GenFormula a)
instance Show v => Show (SGenTerm v)
instance Eq v => Eq (SGenTerm v)
instance Ord v => Ord (SGenTerm v)
instance Show v => Show (SGenAtom v)
instance Eq v => Eq (SGenAtom v)
instance Ord v => Ord (SGenAtom v)
instance Vars SAtom
instance Vars STerm
instance Vars a => Vars (GenFormula a)
instance Boolean (GenFormula a)
instance Complement (GenFormula a)
instance MonotoneBoolean (GenFormula a)
instance Vars Atom
instance Vars Term
instance Vars a => Vars (GenLit a)
instance Complement (GenLit a)
instance Vars a => Vars [a]


-- | Gröbner basis
--   
--   References:
--   
--   <ul>
--   <li>Monomial order
--   <a>http://en.wikipedia.org/wiki/Monomial_order</a></li>
--   <li>Gröbner basis
--   <a>http://en.wikipedia.org/wiki/Gr%C3%B6bner_basis</a></li>
--   <li>グレブナー基底
--   <a>http://d.hatena.ne.jp/keyword/%A5%B0%A5%EC%A5%D6%A5%CA%A1%BC%B4%F0%C4%EC</a></li>
--   <li>Gröbner Bases and Buchberger’s Algorithm
--   <a>http://math.rice.edu/~cbruun/vigre/vigreHW6.pdf</a></li>
--   <li>Docon <a>http://www.haskell.org/docon/</a></li>
--   </ul>
module ToySolver.Data.Polynomial.GroebnerBasis
data Options
Options :: Strategy -> Options
optStrategy :: Options -> Strategy
data Strategy
NormalStrategy :: Strategy

-- | sugar strategy (not implemented yet)
SugarStrategy :: Strategy
defaultOptions :: Options
basis :: (Eq k, Fractional k, Ord k, Ord v) => MonomialOrder v -> [Polynomial k v] -> [Polynomial k v]
basis' :: (Eq k, Fractional k, Ord k, Ord v) => Options -> MonomialOrder v -> [Polynomial k v] -> [Polynomial k v]
spolynomial :: (Eq k, Fractional k, Ord v) => MonomialOrder v -> Polynomial k v -> Polynomial k v -> Polynomial k v
reduceGBasis :: (Eq k, Ord k, Fractional k, Ord v) => MonomialOrder v -> [Polynomial k v] -> [Polynomial k v]
instance Eq Strategy
instance Ord Strategy
instance Show Strategy
instance Read Strategy
instance Bounded Strategy
instance Enum Strategy
instance Ord v => Eq (Item k v)
instance Ord v => Ord (Item k v)
instance Default Options


-- | Factoriation of polynomial over a finite field.
--   
--   References:
--   
--   <ul>
--   
--   <li><a>http://en.wikipedia.org/wiki/Factorization_of_polynomials_over_a_finite_field_and_irreducibility_tests</a></li>
--   <li><a>http://en.wikipedia.org/wiki/Berlekamp%27s_algorithm</a></li>
--   <li>Martin Kreuzer and Lorenzo Robbiano. Computational Commutative
--   Algebra 1. Springer Verlag, 2000.</li>
--   </ul>
module ToySolver.Data.Polynomial.Factorization.FiniteField
factor :: (Ord k, FiniteField k) => UPolynomial k -> [(UPolynomial k, Integer)]

-- | Square-free decomposition of univariate polynomials over a finite
--   field.
sqfree :: (Eq k, FiniteField k) => UPolynomial k -> [(UPolynomial k, Integer)]

-- | Berlekamp algorithm for polynomial factorization.
--   
--   Input polynomial is assumed to be monic and square-free.
berlekamp :: (Eq k, Ord k, FiniteField k) => UPolynomial k -> [UPolynomial k]
basisOfBerlekampSubalgebra :: (Ord k, FiniteField k) => UPolynomial k -> [UPolynomial k]
instance Nat p => SQFree (UPolynomial (PrimeField p))
instance Nat p => Factor (UPolynomial (PrimeField p))


-- | Factoriation of integer-coefficient polynomial using Zassenhaus
--   algorithm.
--   
--   References:
--   
--   <ul>
--   <li><a>http://www.math.kobe-u.ac.jp/Asir/ca.pdf</a></li>
--   </ul>
module ToySolver.Data.Polynomial.Factorization.Zassenhaus
factor :: UPolynomial Integer -> [(UPolynomial Integer, Integer)]
zassenhaus :: UPolynomial Integer -> [UPolynomial Integer]


module ToySolver.Data.Polynomial.Factorization.Integer
instance Factor (UPolynomial Integer)

module ToySolver.Data.Polynomial.Factorization.Rational
instance Factor (UPolynomial Rational)


-- | Polynomials
--   
--   References:
--   
--   <ul>
--   <li>Monomial order
--   <a>http://en.wikipedia.org/wiki/Monomial_order</a></li>
--   <li>Polynomial class for Ruby
--   <a>http://www.math.kobe-u.ac.jp/~kodama/tips-RubyPoly.html</a></li>
--   <li>constructive-algebra package
--   <a>http://hackage.haskell.org/package/constructive-algebra</a></li>
--   </ul>
module ToySolver.Data.Polynomial

-- | Polynomial over commutative ring r
data Polynomial r v
class Vars a v => Var a v | a -> v
var :: Var a v => v -> a

-- | construct a polynomial from a constant
constant :: (Eq k, Num k, Ord v) => k -> Polynomial k v

-- | list of terms
terms :: Polynomial k v -> [Term k v]

-- | construct a polynomial from a list of terms
fromTerms :: (Eq k, Num k, Ord v) => [Term k v] -> Polynomial k v
coeffMap :: Polynomial r v -> Map (Monomial v) r
fromCoeffMap :: (Eq k, Num k, Ord v) => Map (Monomial v) k -> Polynomial k v

-- | construct a polynomial from a singlet term
fromTerm :: (Eq k, Num k, Ord v) => Term k v -> Polynomial k v

-- | total degree of a given polynomial
class Degree t
deg :: Degree t => t -> Integer
class Ord v => Vars a v | a -> v
vars :: Vars a v => a -> Set v

-- | leading term with respect to a given monomial order
lt :: (Eq k, Num k, Ord v) => MonomialOrder v -> Polynomial k v -> Term k v

-- | leading coefficient with respect to a given monomial order
lc :: (Eq k, Num k, Ord v) => MonomialOrder v -> Polynomial k v -> k

-- | leading monomial with respect to a given monomial order
lm :: (Eq k, Num k, Ord v) => MonomialOrder v -> Polynomial k v -> Monomial v

-- | Look up a coefficient for a given monomial. If no such term exists, it
--   returns <tt>0</tt>.
coeff :: (Num k, Ord v) => Monomial v -> Polynomial k v -> k

-- | Look up a coefficient for a given monomial. If no such term exists, it
--   returns <tt>Nothing</tt>.
lookupCoeff :: Ord v => Monomial v -> Polynomial k v -> Maybe k

-- | a polynomial is called primitive if the greatest common divisor of its
--   coefficients is 1.
isPrimitive :: (Eq k, Num k, ContPP k, Ord v) => Polynomial k v -> Bool

-- | Prime factorization of polynomials
class Factor a
factor :: Factor a => a -> [(a, Integer)]

-- | Square-free factorization of polynomials
class SQFree a
sqfree :: SQFree a => a -> [(a, Integer)]
class ContPP k
cont :: (ContPP k, Ord v) => Polynomial k v -> k
pp :: (ContPP k, Ord v) => Polynomial k v -> Polynomial k v

-- | Formal derivative of polynomials
deriv :: (Eq k, Num k, Ord v) => Polynomial k v -> v -> Polynomial k v

-- | Formal integral of polynomials
integral :: (Eq k, Fractional k, Ord v) => Polynomial k v -> v -> Polynomial k v

-- | Evaluation
eval :: (Num k, Ord v) => (v -> k) -> Polynomial k v -> k

-- | Substitution or bind
subst :: (Eq k, Num k, Ord v1, Ord v2) => Polynomial k v1 -> (v1 -> Polynomial k v2) -> Polynomial k v2

-- | Transform polynomial coefficients.
mapCoeff :: (Eq k1, Num k1, Ord v) => (k -> k1) -> Polynomial k v -> Polynomial k1 v

-- | Transform a polynomial into a monic polynomial with respect to the
--   given monomial order.
toMonic :: (Eq r, Fractional r, Ord v) => MonomialOrder v -> Polynomial r v -> Polynomial r v

-- | Convert <i>K[x,x1,x2,…]</i> into <i>K[x1,x2,…][x]</i>.
toUPolynomialOf :: (Ord k, Num k, Ord v) => Polynomial k v -> v -> UPolynomial (Polynomial k v)

-- | Multivariate division algorithm
--   
--   <tt>divModMP cmp f [g1,g2,..]</tt> returns a pair
--   <tt>([q1,q2,…],r)</tt> such that
--   
--   <ul>
--   <li><tt>f = g1*q1 + g2*q2 + .. + r</tt> and</li>
--   <li><tt>g1, g2, ..</tt> do not divide <tt>r</tt>.</li>
--   </ul>
divModMP :: (Eq k, Fractional k, Ord v) => MonomialOrder v -> Polynomial k v -> [Polynomial k v] -> ([Polynomial k v], Polynomial k v)

-- | Multivariate division algorithm
--   
--   <pre>
--   reduce cmp f gs = snd (divModMP cmp f gs)
--   </pre>
reduce :: (Eq k, Fractional k, Ord v) => MonomialOrder v -> Polynomial k v -> [Polynomial k v] -> Polynomial k v

-- | Univariate polynomials over commutative ring r
type UPolynomial r = Polynomial r X

-- | Variable "x"
data X
X :: X
type UTerm k = Term k X
type UMonomial = Monomial X

-- | division of univariate polynomials
div :: (Eq k, Fractional k) => UPolynomial k -> UPolynomial k -> UPolynomial k

-- | division of univariate polynomials
mod :: (Eq k, Fractional k) => UPolynomial k -> UPolynomial k -> UPolynomial k

-- | division of univariate polynomials
divMod :: (Eq k, Fractional k) => UPolynomial k -> UPolynomial k -> (UPolynomial k, UPolynomial k)
divides :: (Eq k, Fractional k) => UPolynomial k -> UPolynomial k -> Bool

-- | GCD of univariate polynomials
gcd :: (Eq k, Fractional k) => UPolynomial k -> UPolynomial k -> UPolynomial k

-- | LCM of univariate polynomials
lcm :: (Eq k, Fractional k) => UPolynomial k -> UPolynomial k -> UPolynomial k

-- | Extended GCD algorithm
exgcd :: (Eq k, Fractional k) => UPolynomial k -> UPolynomial k -> (UPolynomial k, UPolynomial k, UPolynomial k)

-- | pseudo division
pdivMod :: (Eq r, Num r) => UPolynomial r -> UPolynomial r -> (r, UPolynomial r, UPolynomial r)

-- | pseudo quotient
pdiv :: (Eq r, Num r) => UPolynomial r -> UPolynomial r -> UPolynomial r

-- | pseudo reminder
pmod :: (Eq r, Num r) => UPolynomial r -> UPolynomial r -> UPolynomial r

-- | GCD of univariate polynomials
gcd' :: (Eq r, Integral r) => UPolynomial r -> UPolynomial r -> UPolynomial r

-- | Is the number a root of the polynomial?
isRootOf :: (Eq k, Num k) => k -> UPolynomial k -> Bool

-- | Is the polynomial square free?
isSquareFree :: (Eq k, Fractional k) => UPolynomial k -> Bool

-- | Natural ordering <i>x^0 &lt; x^1 &lt; x^2 ..</i> is the unique
--   monomial order for univariate polynomials.
nat :: MonomialOrder X
type Term k v = (k, Monomial v)
tdeg :: Term k v -> Integer
tscale :: (Num k, Ord v) => k -> Term k v -> Term k v
tmult :: (Num k, Ord v) => Term k v -> Term k v -> Term k v
tdivides :: (Fractional k, Ord v) => Term k v -> Term k v -> Bool
tdiv :: (Fractional k, Ord v) => Term k v -> Term k v -> Term k v
tderiv :: (Eq k, Num k, Ord v) => Term k v -> v -> Term k v
tintegral :: (Eq k, Fractional k, Ord v) => Term k v -> v -> Term k v

-- | Monic monomials
data Monomial v
mone :: Monomial v
mfromIndices :: Ord v => [(v, Integer)] -> Monomial v
mfromIndicesMap :: Ord v => Map v Integer -> Monomial v
mindices :: Ord v => Monomial v -> [(v, Integer)]
mindicesMap :: Monomial v -> Map v Integer
mmult :: Ord v => Monomial v -> Monomial v -> Monomial v
mpow :: Ord v => Monomial v -> Integer -> Monomial v
mdivides :: Ord v => Monomial v -> Monomial v -> Bool
mdiv :: Ord v => Monomial v -> Monomial v -> Monomial v
mderiv :: Ord v => Monomial v -> v -> (Integer, Monomial v)
mintegral :: Ord v => Monomial v -> v -> (Rational, Monomial v)
mlcm :: Ord v => Monomial v -> Monomial v -> Monomial v
mgcd :: Ord v => Monomial v -> Monomial v -> Monomial v
mcoprime :: Ord v => Monomial v -> Monomial v -> Bool
type MonomialOrder v = Monomial v -> Monomial v -> Ordering

-- | Lexicographic order
lex :: Ord v => MonomialOrder v

-- | Reverse lexicographic order.
--   
--   Note that revlex is <i>NOT</i> a monomial order.
revlex :: Ord v => Monomial v -> Monomial v -> Ordering

-- | Graded lexicographic order
grlex :: Ord v => MonomialOrder v

-- | Graded reverse lexicographic order
grevlex :: Ord v => MonomialOrder v
data PrintOptions k v
PrintOptions :: (PrettyLevel -> Rational -> v -> Doc) -> (PrettyLevel -> Rational -> k -> Doc) -> (k -> Bool) -> MonomialOrder v -> PrintOptions k v
pOptPrintVar :: PrintOptions k v -> PrettyLevel -> Rational -> v -> Doc
pOptPrintCoeff :: PrintOptions k v -> PrettyLevel -> Rational -> k -> Doc
pOptIsNegativeCoeff :: PrintOptions k v -> k -> Bool
pOptMonomialOrder :: PrintOptions k v -> MonomialOrder v
defaultPrintOptions :: (PrettyCoeff k, PrettyVar v, Ord v) => PrintOptions k v
prettyPrint :: (Ord k, Num k, Ord v) => PrintOptions k v -> PrettyLevel -> Rational -> Polynomial k v -> Doc
class PrettyCoeff a where isNegativeCoeff _ = False
pPrintCoeff :: PrettyCoeff a => PrettyLevel -> Rational -> a -> Doc
isNegativeCoeff :: PrettyCoeff a => a -> Bool
class PrettyVar a
pPrintVar :: PrettyVar a => PrettyLevel -> Rational -> a -> Doc


-- | Manipulating polynomials for corresponding operations for algebraic
--   numbers.
--   
--   Reference:
--   
--   <ul>
--   <li><a>http://www.dpmms.cam.ac.uk/~wtg10/galois.html</a></li>
--   </ul>
module ToySolver.Data.AlgebraicNumber.Root
type Var = Int
normalizePoly :: UPolynomial Rational -> UPolynomial Rational
rootAdd :: UPolynomial Rational -> UPolynomial Rational -> UPolynomial Rational
rootMul :: UPolynomial Rational -> UPolynomial Rational -> UPolynomial Rational
rootShift :: Rational -> UPolynomial Rational -> UPolynomial Rational
rootScale :: Rational -> UPolynomial Rational -> UPolynomial Rational
rootRecip :: UPolynomial Rational -> UPolynomial Rational
rootSimpPoly :: (a -> UPolynomial Rational) -> UPolynomial a -> UPolynomial Rational
rootNthRoot :: Integer -> UPolynomial Rational -> UPolynomial Rational
lift2 :: (forall a. Num a => a -> a -> a) -> UPolynomial Rational -> UPolynomial Rational -> UPolynomial Rational
findPoly :: Polynomial Rational Var -> [Polynomial Rational Var] -> UPolynomial Rational


-- | Reference:
--   
--   <ul>
--   <li>"<i>Sturm's theorem</i>." Wikipedia, The Free Encyclopedia.
--   Wikimedia Foundation, Inc. 2012-06-23.
--   <a>http://en.wikipedia.org/wiki/Sturm%27s_theorem</a></li>
--   <li>Weisstein, Eric W. "<i>Sturm Function</i>." From MathWorld--A
--   Wolfram Web Resource.
--   <a>http://mathworld.wolfram.com/SturmFunction.html</a></li>
--   </ul>
module ToySolver.Data.AlgebraicNumber.Sturm

-- | Sturm's chain (Sturm's sequence)
type SturmChain = [UPolynomial Rational]

-- | Sturm's sequence of a polynomial
sturmChain :: UPolynomial Rational -> SturmChain

-- | The number of distinct real roots of <tt>p</tt> in a given interval
numRoots :: UPolynomial Rational -> Interval Rational -> Int

-- | The number of distinct real roots of <tt>p</tt> in a given interval.
--   This function takes <tt>p</tt>'s sturm chain instead of <tt>p</tt>
--   itself.
numRoots' :: SturmChain -> Interval Rational -> Int

-- | Disjoint intervals each of which contains exactly one real roots of
--   the given polynoimal <tt>p</tt>. The intervals can be further narrowed
--   by <a>narrow</a> or <a>narrow'</a>.
separate :: UPolynomial Rational -> [Interval Rational]

-- | Disjoint intervals each of which contains exactly one real roots of
--   the given polynoimal <tt>p</tt>. The intervals can be further narrowed
--   by <a>narrow</a> or <a>narrow'</a>. This function takes <tt>p</tt>'s
--   sturm chain instead of <tt>p</tt> itself.
separate' :: SturmChain -> [Interval Rational]
halve :: UPolynomial Rational -> Interval Rational -> Interval Rational
halve' :: SturmChain -> Interval Rational -> Interval Rational
narrow :: UPolynomial Rational -> Interval Rational -> Rational -> Interval Rational
narrow' :: SturmChain -> Interval Rational -> Rational -> Interval Rational
approx :: UPolynomial Rational -> Interval Rational -> Rational -> Rational
approx' :: SturmChain -> Interval Rational -> Rational -> Rational

module ToySolver.Data.Polynomial.Interpolation.Lagrange
interpolate :: (Eq k, Fractional k) => [(k, k)] -> UPolynomial k


-- | Disjunctive Normal Form
module ToySolver.Data.DNF

-- | Disjunctive normal form
newtype DNF lit
DNF :: [[lit]] -> DNF lit

-- | list of conjunction of literals
unDNF :: DNF lit -> [[lit]]
instance Show lit => Show (DNF lit)
instance Complement lit => Boolean (DNF lit)
instance MonotoneBoolean (DNF lit)
instance Complement lit => Complement (DNF lit)


-- | Algebraic reals
--   
--   Reference:
--   
--   <ul>
--   <li>Why the concept of a field extension is a natural one
--   <a>http://www.dpmms.cam.ac.uk/~wtg10/galois.html</a></li>
--   </ul>
module ToySolver.Data.AlgebraicNumber.Real

-- | Algebraic real numbers.
data AReal

-- | Real roots of the polynomial in ascending order.
realRoots :: UPolynomial Rational -> [AReal]

-- | Real roots of the polynomial in ascending order.
realRootsEx :: UPolynomial AReal -> [AReal]

-- | The polynomial of which the algebraic number is root.
minimalPolynomial :: AReal -> UPolynomial Rational

-- | Isolating interval that separate the number from other roots of
--   <a>minimalPolynomial</a> of it.
isolatingInterval :: AReal -> Interval Rational

-- | Whether the algebraic number is a rational.
isRational :: AReal -> Bool

-- | Whether the algebraic number is a root of a polynomial with integer
--   coefficients with leading coefficient <tt>1</tt> (a monic polynomial).
isAlgebraicInteger :: AReal -> Bool

-- | Height of the algebraic number.
--   
--   The height of an algebraic number is the greatest absolute value of
--   the coefficients of the irreducible and primitive polynomial with
--   integral rational coefficients.
height :: AReal -> Integer

-- | root index, satisfying
--   
--   <pre>
--   <a>realRoots</a> (<a>minimalPolynomial</a> a) !! rootIndex a == a
--   </pre>
rootIndex :: AReal -> Int

-- | The <tt>n</tt>th root of <tt>a</tt>
nthRoot :: Integer -> AReal -> AReal

-- | Same algebraic real, but represented using finer grained
--   <a>isolatingInterval</a>.
refineIsolatingInterval :: AReal -> AReal

-- | Returns approximate rational value such that <tt>abs (a - approx a
--   epsilon) &lt;= epsilon</tt>.
approx :: AReal -> Rational -> Rational

-- | Returns approximate interval such that <tt>width (approxInterval a
--   epsilon) &lt;= epsilon</tt>.
approxInterval :: AReal -> Rational -> Interval Rational
simpARealPoly :: UPolynomial AReal -> UPolynomial Rational

-- | Golden ratio
goldenRatio :: AReal
instance Show AReal
instance PrettyCoeff AReal
instance Pretty AReal
instance Degree AReal
instance RealFrac AReal
instance Real AReal
instance Fractional AReal
instance Num AReal
instance Ord AReal
instance Eq AReal


-- | Some utility functions.
module ToySolver.Internal.Util

-- | Combining two <tt>Maybe</tt> values using given function.
combineMaybe :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a

-- | is the number integral?
--   
--   <pre>
--   isInteger x = fromInteger (round x) == x
--   </pre>
isInteger :: RealFrac a => a -> Bool

-- | fractional part
--   
--   <pre>
--   fracPart x = x - fromInteger (floor x)
--   </pre>
fracPart :: RealFrac a => a -> a
showRational :: Bool -> Rational -> String
showRationalAsFiniteDecimal :: Rational -> Maybe String
revSequence :: Monad m => [m a] -> m [a]
revMapM :: Monad m => (a -> m b) -> ([a] -> m [b])
revForM :: Monad m => [a] -> (a -> m b) -> m [b]


-- | Augmenting number types with infinitesimal parameter δ.
--   
--   Reference:
--   
--   <ul>
--   <li>Bruno Dutertre and Leonardo de Moura, "<i>A Fast Linear-Arithmetic
--   Solver for DPLL(T)</i>", Computer Aided Verification In Computer Aided
--   Verification, Vol. 4144 (2006), pp. 81-94.
--   <a>http://dx.doi.org/10.1007/11817963_11</a>
--   <a>http://yices.csl.sri.com/cav06.pdf</a></li>
--   </ul>
module ToySolver.Data.Delta

-- | <tt>Delta r k</tt> represents r + kδ for symbolic infinitesimal
--   parameter δ.
data Delta r
Delta :: !r -> !r -> Delta r

-- | Conversion from a base <tt>r</tt> value to <tt>Delta r</tt>.
fromReal :: Num r => r -> Delta r

-- | symbolic infinitesimal parameter δ.
delta :: Num r => Delta r

-- | Extracts the real part..
realPart :: Delta r -> r

-- | Extracts the δ part..
deltaPart :: Delta r -> r

-- | <a>Delta</a> version of <a>floor</a>. <tt><a>floor'</a> x</tt> returns
--   the greatest integer not greater than <tt>x</tt>
floor' :: (RealFrac r, Integral a) => Delta r -> a

-- | <a>Delta</a> version of <a>ceiling</a>. <tt><a>ceiling'</a> x</tt>
--   returns the least integer not less than <tt>x</tt>
ceiling' :: (RealFrac r, Integral a) => Delta r -> a

-- | Is this a integer?
isInteger' :: RealFrac r => Delta r -> Bool
instance Ord r => Ord (Delta r)
instance Eq r => Eq (Delta r)
instance Show r => Show (Delta r)
instance Num r => VectorSpace (Delta r)
instance Num r => AdditiveGroup (Delta r)


-- | A CPLEX .lp format parser library.
--   
--   References:
--   
--   <ul>
--   
--   <li><a>http://publib.boulder.ibm.com/infocenter/cosinfoc/v12r2/index.jsp?topic=/ilog.odms.cplex.help/Content/Optimization/Documentation/CPLEX/_pubskel/CPLEX880.html</a></li>
--   <li><a>http://www.gurobi.com/doc/45/refman/node589.html</a></li>
--   <li><a>http://lpsolve.sourceforge.net/5.5/CPLEX-format.htm</a></li>
--   </ul>
module ToySolver.Data.MIP.LPFile

-- | Parse a string containing LP file data. The source name is only | used
--   in error messages and may be the empty string.
parseString :: SourceName -> String -> Either ParseError Problem

-- | Parse a file containing LP file data.
parseFile :: FilePath -> IO (Either ParseError Problem)

-- | LP file parser
parser :: Parser Problem

-- | Render a problem into a string.
render :: Problem -> Either String String


-- | Mixed-Integer Programming Problems with some commmonly used extensions
module ToySolver.Data.MIP

-- | Parse .lp or .mps file based on file extension
readFile :: FilePath -> IO (Either ParseError Problem)

-- | Parse a file containing LP file data.
readLPFile :: FilePath -> IO (Either ParseError Problem)

-- | Parse a file containing MPS file data.
readMPSFile :: FilePath -> IO (Either ParseError Problem)

-- | Parse a string containing LP file data.
parseLPString :: SourceName -> String -> Either ParseError Problem

-- | Parse a string containing MPS file data.
parseMPSString :: SourceName -> String -> Either ParseError Problem
writeFile :: FilePath -> Problem -> IO ()
writeLPFile :: FilePath -> Problem -> IO ()
writeMPSFile :: FilePath -> Problem -> IO ()
toLPString :: Problem -> Either String String
toMPSString :: Problem -> Either String String


module ToySolver.Converter.MIP2SMT
convert :: Options -> Problem -> ShowS
data Options
Options :: Language -> Maybe String -> Bool -> Bool -> Bool -> Options
optLanguage :: Options -> Language
optSetLogic :: Options -> Maybe String
optCheckSAT :: Options -> Bool
optProduceModel :: Options -> Bool
optOptimize :: Options -> Bool
defaultOptions :: Options
data Language
SMTLIB2 :: Language
YICES :: YicesVersion -> Language
data YicesVersion
Yices1 :: YicesVersion
Yices2 :: YicesVersion
instance Show YicesVersion
instance Eq YicesVersion
instance Ord YicesVersion
instance Enum YicesVersion
instance Bounded YicesVersion
instance Show Language
instance Eq Language
instance Ord Language
instance Show Options
instance Eq Options
instance Ord Options
instance Default Options


module ToySolver.Converter.PB2IP
convert :: Formula -> (Problem, Map Var Rational -> Model)
convertWBO :: Bool -> SoftFormula -> (Problem, Map Var Rational -> Model)


module ToySolver.Converter.MaxSAT2IP
convert :: Bool -> WCNF -> (Problem, Map Var Rational -> Model)


module ToySolver.Converter.SAT2IP
convert :: CNF -> (Problem, Map Var Rational -> Model)


-- | Factoriation of integer-coefficient polynomial using Kronecker's
--   method.
--   
--   References:
--   
--   <ul>
--   <li><a>http://en.wikipedia.org/wiki/Polynomial_factorization</a></li>
--   </ul>
module ToySolver.Data.Polynomial.Factorization.Kronecker
factor :: UPolynomial Integer -> [(UPolynomial Integer, Integer)]


module ToySolver.Data.Var

-- | Variables are represented as non-negative integers
type Var = Int

-- | Set of variables
type VarSet = IntSet

-- | Map from variables
type VarMap = IntMap

-- | collecting free variables
class Variables a
vars :: Variables a => a -> VarSet

-- | A <tt>Model</tt> is a map from variables to values.
type Model r = VarMap r
instance Variables a => Variables [a]


-- | Boolean expression over a given type of atoms
module ToySolver.Data.BoolExpr

-- | Boolean expression over a given type of atoms
data BoolExpr a
Atom :: a -> BoolExpr a
And :: [BoolExpr a] -> BoolExpr a
Or :: [BoolExpr a] -> BoolExpr a
Not :: (BoolExpr a) -> BoolExpr a
Imply :: (BoolExpr a) -> (BoolExpr a) -> BoolExpr a
Equiv :: (BoolExpr a) -> (BoolExpr a) -> BoolExpr a
ITE :: (BoolExpr a) -> (BoolExpr a) -> (BoolExpr a) -> BoolExpr a
fold :: Boolean b => (atom -> b) -> BoolExpr atom -> b
simplify :: BoolExpr a -> BoolExpr a
instance Typeable BoolExpr
instance Eq a => Eq (BoolExpr a)
instance Ord a => Ord (BoolExpr a)
instance Show a => Show (BoolExpr a)
instance Read a => Read (BoolExpr a)
instance Data a => Data (BoolExpr a)
instance Boolean (Simplify a)
instance MonotoneBoolean (Simplify a)
instance Complement (Simplify a)
instance Variables a => Variables (BoolExpr a)
instance Boolean (BoolExpr a)
instance MonotoneBoolean (BoolExpr a)
instance Complement (BoolExpr a)
instance Hashable a => Hashable (BoolExpr a)
instance NFData a => NFData (BoolExpr a)
instance Traversable BoolExpr
instance Foldable BoolExpr
instance Monad BoolExpr
instance Applicative BoolExpr
instance Functor BoolExpr


-- | Tseitin encoding
--   
--   TODO:
--   
--   <ul>
--   <li>reduce variables.</li>
--   </ul>
--   
--   References:
--   
--   <ul>
--   <li>[Tse83] G. Tseitin. On the complexity of derivation in
--   propositional calculus. Automation of Reasoning: Classical Papers in
--   Computational Logic, 2:466-483, 1983. Springer-Verlag.</li>
--   <li>[For60] R. Fortet. Application de l'algèbre de Boole en
--   rechercheop opérationelle. Revue Française de Recherche Opérationelle,
--   4:17-26, 1960.</li>
--   <li>[BM84a] E. Balas and J. B. Mazzola. Nonlinear 0-1 programming: I.
--   Linearization techniques. Mathematical Programming, 30(1):1-21,
--   1984.</li>
--   <li>[BM84b] E. Balas and J. B. Mazzola. Nonlinear 0-1 programming: II.
--   Dominance relations and algorithms. Mathematical Programming,
--   30(1):22-45, 1984.</li>
--   <li>[PG86] D. Plaisted and S. Greenbaum. A Structure-preserving Clause
--   Form Translation. In Journal on Symbolic Computation, volume 2,
--   1986.</li>
--   <li>[ES06] N . Eéen and N. Sörensson. Translating Pseudo-Boolean
--   Constraints into SAT. JSAT 2:1–26, 2006.</li>
--   </ul>
module ToySolver.SAT.TseitinEncoder

-- | Encoder instance
data Encoder

-- | Create a <tt>Encoder</tt> instance.
newEncoder :: Solver -> IO Encoder

-- | Use <i>pseudo boolean constraints</i> or use only <i>clauses</i>.
setUsePB :: Encoder -> Bool -> IO ()
encSolver :: Encoder -> Solver
data Polarity
Polarity :: Bool -> Bool -> Polarity
polarityPosOccurs :: Polarity -> Bool
polarityNegOccurs :: Polarity -> Bool
negatePolarity :: Polarity -> Polarity
polarityPos :: Polarity
polarityNeg :: Polarity
polarityBoth :: Polarity
polarityNone :: Polarity

-- | Arbitrary formula not restricted to CNF
type Formula = BoolExpr Lit
evalFormula :: IModel m => m -> Formula -> Bool

-- | Assert a given formula to underlying SAT solver by using Tseitin
--   encoding.
addFormula :: Encoder -> Formula -> IO ()

-- | Return an literal which is equivalent to a given conjunction.
--   
--   <pre>
--   encodeConj encoder = <a>encodeConjWithPolarity</a> encoder <a>polarityBoth</a>
--   </pre>
encodeConj :: Encoder -> [Lit] -> IO Lit

-- | Return an literal which is equivalent to a given conjunction which
--   occurs only in specified polarity.
encodeConjWithPolarity :: Encoder -> Polarity -> [Lit] -> IO Lit

-- | Return an literal which is equivalent to a given disjunction.
--   
--   <pre>
--   encodeDisj encoder = <a>encodeDisjWithPolarity</a> encoder <a>polarityBoth</a>
--   </pre>
encodeDisj :: Encoder -> [Lit] -> IO Lit

-- | Return an literal which is equivalent to a given disjunction which
--   occurs only in specified polarity.
encodeDisjWithPolarity :: Encoder -> Polarity -> [Lit] -> IO Lit

-- | Return an literal which is equivalent to a given if-then-else.
--   
--   <pre>
--   encodeITE encoder = <a>encodeITEWithPolarity</a> encoder <a>polarityBoth</a>
--   </pre>
encodeITE :: Encoder -> Lit -> Lit -> Lit -> IO Lit

-- | Return an literal which is equivalent to a given if-then-else which
--   occurs only in specified polarity.
encodeITEWithPolarity :: Encoder -> Polarity -> Lit -> Lit -> Lit -> IO Lit
getDefinitions :: Encoder -> IO [(Lit, Formula)]
instance Eq Polarity
instance Show Polarity


module ToySolver.SAT.PBNLC
type PBTerm = (Integer, [Lit])
type PBSum = [PBTerm]

-- | Add a non-linear pseudo boolean constraints <i>c1*ls1 + c2*ls2 + … ≥
--   n</i>.
addPBAtLeast :: Encoder -> PBSum -> Integer -> IO ()

-- | Add a non-linear pseudo boolean constraints <i>c1*ls1 + c2*ls2 + … ≥
--   n</i>.
addPBAtMost :: Encoder -> PBSum -> Integer -> IO ()

-- | Add a non-linear pseudo boolean constraints <i>c1*ls1 + c2*ls2 + … =
--   n</i>.
addPBExactly :: Encoder -> PBSum -> Integer -> IO ()

-- | Add a soft non-linear pseudo boolean constraints <i>sel ⇒ c1*ls1 +
--   c2*ls2 + … ≥ n</i>.
addPBAtLeastSoft :: Encoder -> Lit -> PBSum -> Integer -> IO ()

-- | Add a soft non-linear pseudo boolean constraints <i>sel ⇒ c1*ls1 +
--   c2*ls2 + … ≤ n</i>.
addPBAtMostSoft :: Encoder -> Lit -> PBSum -> Integer -> IO ()

-- | Add a soft non-linear pseudo boolean constraints <i>lit ⇒ c1*ls1 +
--   c2*ls2 + … = n</i>.
addPBExactlySoft :: Encoder -> Lit -> PBSum -> Integer -> IO ()

-- | Encode a non-linear <a>PBSum</a> into a lienar <a>PBLinSum</a>.
--   
--   <tt>linearizePBSum enc s</tt> is equivalent to
--   <tt>linearizePBSumWithPolarity enc polarityBoth</tt>.
linearizePBSum :: Encoder -> PBSum -> IO PBLinSum

-- | Linearize a non-linear <a>PBSum</a> into a lienar <a>PBLinSum</a>.
--   
--   The input <a>PBSum</a> is assumed to occur only in specified polarity.
--   
--   <ul>
--   <li>If <tt><a>polarityPosOccurs</a> p</tt>, the value of resulting
--   <a>PBLinSum</a> is <i>greater than</i> or <i>equal to</i> the value of
--   original <a>PBSum</a>.</li>
--   <li>If <tt><a>polarityNegOccurs</a> p</tt>, the value of resulting
--   <a>PBLinSum</a> is <i>lesser than</i> or <i>equal to</i> the value of
--   original <a>PBSum</a>.</li>
--   </ul>
linearizePBSumWithPolarity :: Encoder -> Polarity -> PBSum -> IO PBLinSum
evalPBSum :: IModel m => m -> PBSum -> Integer

module ToySolver.Wang
type Formula a = BoolExpr a
type Sequent x = ([Formula x], [Formula x])
isValid :: Eq x => Sequent x -> Bool


-- | Formula of first order logic.
module ToySolver.Data.FOL.Formula

-- | formulas of first order logic
data Formula a
T :: Formula a
F :: Formula a
Atom :: a -> Formula a
And :: (Formula a) -> (Formula a) -> Formula a
Or :: (Formula a) -> (Formula a) -> Formula a
Not :: (Formula a) -> Formula a
Imply :: (Formula a) -> (Formula a) -> Formula a
Equiv :: (Formula a) -> (Formula a) -> Formula a
Forall :: Var -> (Formula a) -> Formula a
Exists :: Var -> (Formula a) -> Formula a

-- | convert a formula into negation normal form
pushNot :: Complement a => Formula a -> Formula a
instance Show a => Show (Formula a)
instance Eq a => Eq (Formula a)
instance Ord a => Ord (Formula a)
instance Boolean (Formula c)
instance MonotoneBoolean (Formula c)
instance Complement (Formula a)
instance Variables a => Variables (Formula a)


-- | Arithmetic relations
module ToySolver.Data.ArithRel

-- | relational operators
data RelOp
Lt :: RelOp
Le :: RelOp
Ge :: RelOp
Gt :: RelOp
Eql :: RelOp
NEq :: RelOp

-- | flipping relational operator
--   
--   <tt>rel (flipOp op) a b</tt> is equivalent to <tt>rel op b a</tt>
flipOp :: RelOp -> RelOp

-- | negating relational operator
--   
--   <tt>rel (negOp op) a b</tt> is equivalent to <tt>notB (rel op a
--   b)</tt>
negOp :: RelOp -> RelOp

-- | operator symbol
showOp :: RelOp -> String

-- | evaluate an operator into a comparision function
evalOp :: Ord a => RelOp -> a -> a -> Bool

-- | Atomic formula
data ArithRel e
ArithRel :: e -> RelOp -> e -> ArithRel e
fromArithRel :: IsArithRel e r => ArithRel e -> r

-- | type class for constructing relational formula
class IsArithRel e r | r -> e
arithRel :: IsArithRel e r => RelOp -> e -> e -> r

-- | constructing relational formula
(.<.) :: IsArithRel e r => e -> e -> r

-- | constructing relational formula
(.<=.) :: IsArithRel e r => e -> e -> r

-- | constructing relational formula
(.>=.) :: IsArithRel e r => e -> e -> r

-- | constructing relational formula
(.>.) :: IsArithRel e r => e -> e -> r

-- | constructing relational formula
(.==.) :: IsArithRel e r => e -> e -> r

-- | constructing relational formula
(./=.) :: IsArithRel e r => e -> e -> r
instance Show RelOp
instance Eq RelOp
instance Ord RelOp
instance Show e => Show (ArithRel e)
instance Eq e => Eq (ArithRel e)
instance Ord e => Ord (ArithRel e)
instance Functor ArithRel
instance Variables e => Variables (ArithRel e)
instance IsArithRel e (ArithRel e)
instance Complement (ArithRel c)


-- | Some definition for Theory of Linear Arithmetics.
module ToySolver.Data.LA

-- | Linear combination of variables and constants. Non-negative keys are
--   used for variables's coefficients. key <a>unitVar</a> is used for
--   constants.
data Expr r

-- | variable
var :: Num r => Var -> Expr r

-- | constant
constant :: (Num r, Eq r) => r -> Expr r

-- | terms contained in the expression.
terms :: Expr r -> [(r, Var)]

-- | Create a <tt>Expr</tt> from a list of terms.
fromTerms :: (Num r, Eq r) => [(r, Var)] -> Expr r

-- | a mapping from variables to coefficients
coeffMap :: Expr r -> IntMap r

-- | Create a <tt>Expr</tt> from a mapping from variables to coefficients.
fromCoeffMap :: (Num r, Eq r) => IntMap r -> Expr r

-- | Special variable that should always be evaluated to 1.
unitVar :: Var
asConst :: Num r => Expr r -> Maybe r

-- | lookup a coefficient of the variable. <tt> coeff v e == fst (extract v
--   e) </tt>
coeff :: Num r => Var -> Expr r -> r

-- | lookup a coefficient of the variable. It returns <tt>Nothing</tt> if
--   the expression does not contain <tt>v</tt>. <tt> lookupCoeff v e ==
--   fmap fst (extractMaybe v e) </tt>
lookupCoeff :: Num r => Var -> Expr r -> Maybe r

-- | <tt>extract v e</tt> returns <tt>(c, e')</tt> such that <tt>e == c *^
--   v ^+^ e'</tt>
extract :: Num r => Var -> Expr r -> (r, Expr r)

-- | <tt>extractMaybe v e</tt> returns <tt>Just (c, e')</tt> such that
--   <tt>e == c *^ v ^+^ e'</tt> if <tt>e</tt> contains v, and returns
--   <tt>Nothing</tt> otherwise.
extractMaybe :: Num r => Var -> Expr r -> Maybe (r, Expr r)

-- | map coefficients.
mapCoeff :: (Num b, Eq b) => (a -> b) -> Expr a -> Expr b

-- | map coefficients.
mapCoeffWithVar :: (Num b, Eq b) => (a -> Var -> b) -> Expr a -> Expr b

-- | evaluate the expression under the model.
evalExpr :: Num r => Model r -> Expr r -> r

-- | evaluate the expression under the model.
evalLinear :: VectorSpace a => Model a -> a -> Expr (Scalar a) -> a
lift1 :: VectorSpace x => x -> (Var -> x) -> Expr (Scalar x) -> x
applySubst :: (Num r, Eq r) => VarMap (Expr r) -> Expr r -> Expr r

-- | applySubst1 x e e1 == e1[e/x]
applySubst1 :: (Num r, Eq r) => Var -> Expr r -> Expr r -> Expr r
showExpr :: (Num r, Eq r, Show r) => Expr r -> String

-- | Atomic Formula of Linear Arithmetics
type Atom r = ArithRel (Expr r)
showAtom :: (Num r, Eq r, Show r) => Atom r -> String

-- | evaluate the formula under the model.
evalAtom :: (Num r, Ord r) => Model r -> Atom r -> Bool
applySubstAtom :: (Num r, Eq r) => VarMap (Expr r) -> Atom r -> Atom r

-- | applySubst1 x e phi == phi[e/x]
applySubst1Atom :: (Num r, Eq r) => Var -> Expr r -> Atom r -> Atom r

-- | Solve linear (in)equation for the given variable.
--   
--   <tt>solveFor a v</tt> returns <tt>Just (op, e)</tt> such that <tt>Atom
--   v op e</tt> is equivalent to <tt>a</tt>.
solveFor :: (Real r, Fractional r) => Atom r -> Var -> Maybe (RelOp, Expr r)
type BoundsEnv r = VarMap (Interval r)

-- | compute bounds for a <tt>Expr</tt> with respect to <tt>BoundsEnv</tt>.
computeInterval :: (Real r, Fractional r) => BoundsEnv r -> Expr r -> Interval r
instance Eq r => Eq (Expr r)
instance Ord r => Ord (Expr r)
instance (Num r, Eq r) => VectorSpace (Expr r)
instance (Num r, Eq r) => AdditiveGroup (Expr r)
instance NFData r => NFData (Expr r)
instance (Num r, Eq r, Read r) => Read (Expr r)
instance Show r => Show (Expr r)
instance Variables (Expr r)


-- | Naïve implementation of Simplex method
--   
--   Reference:
--   
--   <ul>
--   <li><a>http://www.math.cuhk.edu.hk/~wei/lpch3.pdf</a></li>
--   </ul>
module ToySolver.Arith.Simplex
type Tableau r = VarMap (Row r)

-- | Basic variables
type RowIndex = Int

-- | Non-basic variables
type ColIndex = Int
type Row r = (VarMap r, r)
emptyTableau :: Tableau r
objRowIndex :: RowIndex
pivot :: (Fractional r, Eq r) => RowIndex -> ColIndex -> Tableau r -> Tableau r

-- | Lookup a row by basic variable
lookupRow :: RowIndex -> Tableau r -> Row r
addRow :: (Num r, Eq r) => Tableau r -> RowIndex -> Row r -> Tableau r
setObjFun :: (Num r, Eq r) => Tableau r -> Expr r -> Tableau r
currentValue :: Num r => Tableau r -> Var -> r
currentObjValue :: Num r => Tableau r -> r
isFeasible :: Real r => Tableau r -> Bool
isOptimal :: Real r => OptDir -> Tableau r -> Bool
simplex :: (Real r, Fractional r) => OptDir -> Tableau r -> (Bool, Tableau r)
dualSimplex :: (Real r, Fractional r) => OptDir -> Tableau r -> (Bool, Tableau r)
phaseI :: (Real r, Fractional r) => Tableau r -> VarSet -> (Bool, Tableau r)
primalDualSimplex :: (Real r, Fractional r) => OptDir -> Tableau r -> (Bool, Tableau r)
isValidTableau :: Tableau r -> Bool
toCSV :: (Num r, Eq r, Show r) => (r -> String) -> Tableau r -> String
instance Show r => Show (PivotResult r)
instance Eq r => Eq (PivotResult r)
instance Ord r => Ord (PivotResult r)


-- | References:
--   
--   <ul>
--   <li>Christian Michaux and Adem Ozturk. Quantifier Elimination
--   following Muchnik
--   <a>https://math.umons.ac.be/preprints/src/Ozturk020411.pdf</a></li>
--   <li>Arnab Bhattacharyya. Something you should know about: Quantifier
--   Elimination (Part I)
--   <a>http://cstheory.blogoverflow.com/2011/11/something-you-should-know-about-quantifier-elimination-part-i/</a></li>
--   <li>Arnab Bhattacharyya. Something you should know about: Quantifier
--   Elimination (Part II)
--   <a>http://cstheory.blogoverflow.com/2012/02/something-you-should-know-about-quantifier-elimination-part-ii/</a></li>
--   </ul>
module ToySolver.Arith.CAD
data Point c
NegInf :: Point c
RootOf :: (UPolynomial c) -> Int -> Point c
PosInf :: Point c
data Cell c
Point :: (Point c) -> Cell c
Interval :: (Point c) -> (Point c) -> Cell c
project :: (Ord v, Show v, PrettyVar v) => v -> [ArithRel (Polynomial Rational v)] -> [([ArithRel (Polynomial Rational v)], Model v -> Model v)]
project' :: (Ord v, Show v, PrettyVar v) => [(UPolynomial (Polynomial Rational v), [Sign])] -> [([(Polynomial Rational v, [Sign])], [Cell (Polynomial Rational v)])]
projectN :: (Ord v, Show v, PrettyVar v) => Set v -> [ArithRel (Polynomial Rational v)] -> [([ArithRel (Polynomial Rational v)], Model v -> Model v)]
projectN' :: (Ord v, Show v, PrettyVar v) => Set v -> [(Polynomial Rational v, [Sign])] -> [([(Polynomial Rational v, [Sign])], Model v -> Model v)]
solve :: (Ord v, Show v, PrettyVar v) => Set v -> [(ArithRel (Polynomial Rational v))] -> Maybe (Model v)
solve' :: (Ord v, Show v, PrettyVar v) => Set v -> [(Polynomial Rational v, [Sign])] -> Maybe (Model v)
type Model v = Map v AReal
findSample :: Ord v => Model v -> Cell (Polynomial Rational v) -> Maybe AReal
evalCell :: Ord v => Model v -> Cell (Polynomial Rational v) -> Cell Rational
evalPoint :: Ord v => Model v -> Point (Polynomial Rational v) -> Point Rational
instance Eq c => Eq (Point c)
instance Ord c => Ord (Point c)
instance Show c => Show (Point c)
instance Eq c => Eq (Cell c)
instance Ord c => Ord (Cell c)
instance Show c => Show (Cell c)


-- | Algebraic Numbers
module ToySolver.Data.AlgebraicNumber.Complex

-- | Complex numbers are an algebraic type.
--   
--   For a complex number <tt>z</tt>, <tt><a>abs</a> z</tt> is a number
--   with the magnitude of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the phase of
--   <tt>z</tt>, but unit magnitude.
data AComplex
(:+) :: !AReal -> !AReal -> AComplex

-- | Extracts the real part of a complex number.
realPart :: AComplex -> AReal

-- | Extracts the imaginary part of a complex number.
imagPart :: AComplex -> AReal

-- | The nonnegative magnitude of a complex number.
magnitude :: AComplex -> AReal

-- | The polynomial of which the algebraic number is root.
minimalPolynomial :: AComplex -> UPolynomial Rational

-- | The conjugate of a complex number.
conjugate :: AComplex -> AComplex
instance Eq AComplex
instance Show AComplex
instance Fractional AComplex
instance Num AComplex


-- | Arithmetic language (not limited to linear ones).
module ToySolver.Data.FOL.Arith

-- | Arithmetic expressions
data Expr r
Const :: r -> Expr r
Var :: Var -> Expr r
(:+:) :: Expr r -> Expr r -> Expr r
(:*:) :: Expr r -> Expr r -> Expr r
(:/:) :: Expr r -> Expr r -> Expr r

-- | single variable expression
var :: Var -> Expr r

-- | evaluate an <a>Expr</a> with respect to a <a>Model</a>
evalExpr :: Fractional r => Model r -> Expr r -> r

-- | Atomic formula
type Atom c = ArithRel (Expr c)
evalAtom :: (Real r, Fractional r) => Model r -> Atom r -> Bool

-- | results of satisfiability checking
data SatResult r
Unknown :: SatResult r
Unsat :: SatResult r
Sat :: (Model r) -> SatResult r
instance Eq r => Eq (Expr r)
instance Ord r => Ord (Expr r)
instance Show r => Show (Expr r)
instance Show r => Show (SatResult r)
instance Eq r => Eq (SatResult r)
instance Ord r => Ord (SatResult r)
instance IsArithRel (Expr c) (Formula (Atom c))
instance Variables (Expr r)
instance Functor Expr
instance Fractional r => Fractional (Expr r)
instance Num r => Num (Expr r)

module ToySolver.Data.LA.FOL
fromFOLAtom :: (Real r, Fractional r) => Atom r -> Maybe (Atom r)
toFOLFormula :: (Real r, Fractional r) => Atom r -> Formula (Atom r)
fromFOLExpr :: (Real r, Fractional r) => Expr r -> Maybe (Expr r)
toFOLExpr :: (Real r, Fractional r) => Expr r -> Expr r


-- | Naïve implementation of Fourier-Motzkin Variable Elimination
--   
--   Reference:
--   
--   <ul>
--   
--   <li><a>http://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf</a></li>
--   </ul>
module ToySolver.Arith.FourierMotzkin.Base

-- | Atomic constraint
data Constr

-- | e ≥ 0
IsNonneg :: ExprZ -> Constr

-- | e &gt; 0
IsPos :: ExprZ -> Constr

-- | e = 0
IsZero :: ExprZ -> Constr
eqR :: Rat -> Rat -> Constr
type ExprZ = Expr Integer
fromLAAtom :: Atom Rational -> DNF Constr
toLAAtom :: Constr -> Atom Rational
constraintsToDNF :: [Atom Rational] -> DNF Constr

-- | Simplify conjunction of <a>Constr</a>s. It returns <a>Nothing</a> when
--   a inconsistency is detected.
simplify :: [Constr] -> Maybe [Constr]
type Bounds = ([Rat], [Rat], [Rat], [Rat])
evalBounds :: Model Rational -> Bounds -> Interval Rational
boundsToConstrs :: Bounds -> Maybe [Constr]
collectBounds :: Var -> [Constr] -> (Bounds, [Constr])

-- | <tt><a>project</a> x φ</tt> returns <tt>[(ψ_1, lift_1), …, (ψ_m,
--   lift_m)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LRA ∀y1, …, yn. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_m)</tt> where
--   <tt>{y1, …, yn} = FV(φ) \ {x}</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ_i</tt> then <tt>lift_i M ⊧_LRA φ</tt>.</li>
--   </ul>
project :: Var -> [Atom Rational] -> [([Atom Rational], Model Rational -> Model Rational)]
project' :: Var -> [Constr] -> Maybe ([Constr], Model Rational -> Model Rational)

-- | <tt><a>projectN</a> {x1,…,xm} φ</tt> returns <tt>[(ψ_1, lift_1), …,
--   (ψ_n, lift_n)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LRA ∀y1, …, yp. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_n)</tt> where
--   <tt>{y1, …, yp} = FV(φ) \ {x1,…,xm}</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ_i</tt> then <tt>lift_i M ⊧_LRA φ</tt>.</li>
--   </ul>
projectN :: VarSet -> [Atom Rational] -> [([Atom Rational], Model Rational -> Model Rational)]
projectN' :: VarSet -> [Constr] -> Maybe ([Constr], Model Rational -> Model Rational)

-- | <tt><a>solve</a> {x1,…,xn} φ</tt> returns <tt>Just M</tt> that <tt>M
--   ⊧_LRA φ</tt> when such <tt>M</tt> exists, returns <tt>Nothing</tt>
--   otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solve :: VarSet -> [Atom Rational] -> Maybe (Model Rational)
solve' :: VarSet -> [Constr] -> Maybe (Model Rational)

-- | (t,c) represents t/c, and c must be &gt;0.
type Rat = (ExprZ, Integer)
toRat :: Expr Rational -> Rat
instance Show Constr
instance Eq Constr
instance Ord Constr
instance Variables Constr


-- | Naïve implementation of Fourier-Motzkin Variable Elimination
--   
--   Reference:
--   
--   <ul>
--   
--   <li><a>http://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf</a></li>
--   </ul>
module ToySolver.Arith.FourierMotzkin.Optimization

-- | <tt>optimize dir obj φ</tt> returns <tt>(I, lift)</tt> where
--   
--   <ul>
--   <li><tt>I</tt> is convex hull of feasible region, and</li>
--   <li><tt>lift</tt> is a function, that takes <tt>x ∈ I</tt> and returns
--   the feasible solution with objective value <i>better than or equal
--   to</i> <tt>x</tt>.</li>
--   </ul>
--   
--   Note:
--   
--   <ul>
--   <li><tt><a>lowerBound</a> i</tt> (resp. <tt><a>upperBound</a> i</tt>)
--   is the optimal value in case of minimization (resp.
--   maximization).</li>
--   <li>If <tt>I</tt> is empty, then the problem is INFEASIBLE.</li>
--   </ul>
optimize :: VarSet -> OptDir -> Expr Rational -> [Atom Rational] -> (Interval Rational, Rational -> Model Rational)

module ToySolver.Arith.FourierMotzkin.FOL

-- | <ul>
--   <li><tt><a>solveFormula</a> {x1,…,xm} φ</tt> returns <tt><tt>Sat</tt>
--   M</tt> such that <tt>M ⊧_LRA φ</tt> when such <tt>M</tt> exists,</li>
--   <li>returns <tt><tt>Unsat</tt></tt> when such <tt>M</tt> does not
--   exists, and</li>
--   <li>returns <tt><tt>Unknown</tt></tt> when <tt>φ</tt> is beyond
--   LRA.</li>
--   </ul>
solveFormula :: VarSet -> Formula (Atom Rational) -> SatResult Rational

-- | Eliminate quantifiers and returns equivalent quantifier-free formula.
--   
--   <tt><a>eliminateQuantifiers</a> φ</tt> returns <tt>(ψ, lift)</tt> such
--   that:
--   
--   <ul>
--   <li>ψ is a quantifier-free formula and <tt>LRA ⊢ ∀y1, …, yn. φ ↔
--   ψ</tt> where <tt>{y1, …, yn} = FV(φ) ⊇ FV(ψ)</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ</tt> then <tt>lift M ⊧_LRA φ</tt>.</li>
--   </ul>
--   
--   φ may or may not be a closed formula.
eliminateQuantifiers :: Formula (Atom Rational) -> Maybe (Formula (Atom Rational))
eliminateQuantifiers' :: Formula (Atom Rational) -> Maybe (DNF Constr)


-- | Naïve implementation of Fourier-Motzkin Variable Elimination
--   
--   Reference:
--   
--   <ul>
--   
--   <li><a>http://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf</a></li>
--   </ul>
module ToySolver.Arith.FourierMotzkin

-- | Atomic constraint
data Constr

-- | e ≥ 0
IsNonneg :: ExprZ -> Constr

-- | e &gt; 0
IsPos :: ExprZ -> Constr

-- | e = 0
IsZero :: ExprZ -> Constr

-- | <tt><a>project</a> x φ</tt> returns <tt>[(ψ_1, lift_1), …, (ψ_m,
--   lift_m)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LRA ∀y1, …, yn. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_m)</tt> where
--   <tt>{y1, …, yn} = FV(φ) \ {x}</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ_i</tt> then <tt>lift_i M ⊧_LRA φ</tt>.</li>
--   </ul>
project :: Var -> [Atom Rational] -> [([Atom Rational], Model Rational -> Model Rational)]

-- | <tt><a>projectN</a> {x1,…,xm} φ</tt> returns <tt>[(ψ_1, lift_1), …,
--   (ψ_n, lift_n)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LRA ∀y1, …, yp. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_n)</tt> where
--   <tt>{y1, …, yp} = FV(φ) \ {x1,…,xm}</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ_i</tt> then <tt>lift_i M ⊧_LRA φ</tt>.</li>
--   </ul>
projectN :: VarSet -> [Atom Rational] -> [([Atom Rational], Model Rational -> Model Rational)]

-- | Eliminate quantifiers and returns equivalent quantifier-free formula.
--   
--   <tt><a>eliminateQuantifiers</a> φ</tt> returns <tt>(ψ, lift)</tt> such
--   that:
--   
--   <ul>
--   <li>ψ is a quantifier-free formula and <tt>LRA ⊢ ∀y1, …, yn. φ ↔
--   ψ</tt> where <tt>{y1, …, yn} = FV(φ) ⊇ FV(ψ)</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ</tt> then <tt>lift M ⊧_LRA φ</tt>.</li>
--   </ul>
--   
--   φ may or may not be a closed formula.
eliminateQuantifiers :: Formula (Atom Rational) -> Maybe (Formula (Atom Rational))

-- | <ul>
--   <li><tt><a>solveFormula</a> {x1,…,xm} φ</tt> returns <tt><tt>Sat</tt>
--   M</tt> such that <tt>M ⊧_LRA φ</tt> when such <tt>M</tt> exists,</li>
--   <li>returns <tt><tt>Unsat</tt></tt> when such <tt>M</tt> does not
--   exists, and</li>
--   <li>returns <tt><tt>Unknown</tt></tt> when <tt>φ</tt> is beyond
--   LRA.</li>
--   </ul>
solveFormula :: VarSet -> Formula (Atom Rational) -> SatResult Rational

-- | <tt><a>solve</a> {x1,…,xn} φ</tt> returns <tt>Just M</tt> that <tt>M
--   ⊧_LRA φ</tt> when such <tt>M</tt> exists, returns <tt>Nothing</tt>
--   otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solve :: VarSet -> [Atom Rational] -> Maybe (Model Rational)


-- | Naive implementation of Cooper's algorithm
--   
--   Reference:
--   
--   <ul>
--   
--   <li><a>http://hagi.is.s.u-tokyo.ac.jp/pub/staff/hagiya/kougiroku/ronri/5.txt</a></li>
--   
--   <li><a>http://www.cs.cmu.edu/~emc/spring06/home1_files/Presburger%20Arithmetic.ppt</a></li>
--   </ul>
--   
--   See also:
--   
--   <ul>
--   <li><a>http://hackage.haskell.org/package/presburger</a></li>
--   </ul>
module ToySolver.Arith.Cooper.Base

-- | Linear arithmetic expression over integers.
type ExprZ = Expr Integer

-- | Literals of Presburger arithmetic.
data Lit

-- | <tt>IsPos e</tt> means <tt>e &gt; 0</tt>
IsPos :: ExprZ -> Lit

-- | <ul>
--   <li><tt>Divisible True d e</tt> means <tt>e</tt> can be divided by
--   <tt>d</tt> (i.e. <tt>d | e</tt>)</li>
--   <li><tt>Divisible False d e</tt> means <tt>e</tt> can not be divided
--   by <tt>d</tt> (i.e. <tt>¬(d | e)</tt>)</li>
--   </ul>
Divisible :: Bool -> Integer -> ExprZ -> Lit
evalLit :: Model Integer -> Lit -> Bool

-- | Quantifier-free formula of Presburger arithmetic.
type QFFormula = BoolExpr Lit
fromLAAtom :: Atom Rational -> QFFormula

-- | <tt>d | e</tt> means <tt>e</tt> can be divided by <tt>d</tt>.
(.|.) :: Integer -> ExprZ -> QFFormula

-- | <tt><a>evalQFFormula</a> M φ</tt> returns whether <tt>M ⊧_LIA φ</tt>
--   or not.
evalQFFormula :: Model Integer -> QFFormula -> Bool

-- | A <tt>Model</tt> is a map from variables to values.
type Model r = VarMap r

-- | <tt><a>project</a> x φ</tt> returns <tt>(ψ, lift)</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LIA ∀y1, …, yn. (∃x. φ) ↔ ψ</tt> where <tt>{y1, …, yn} =
--   FV(φ) \ {x}</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ</tt> then <tt>lift M ⊧_LIA φ</tt>.</li>
--   </ul>
project :: Var -> QFFormula -> (QFFormula, Model Integer -> Model Integer)

-- | <tt><a>projectN</a> {x1,…,xm} φ</tt> returns <tt>(ψ, lift)</tt> such
--   that:
--   
--   <ul>
--   <li><tt>⊢_LIA ∀y1, …, yn. (∃x1, …, xm. φ) ↔ ψ</tt> where <tt>{y1, …,
--   yn} = FV(φ) \ {x1,…,xm}</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ</tt> then <tt>lift M ⊧_LIA φ</tt>.</li>
--   </ul>
projectN :: VarSet -> QFFormula -> (QFFormula, Model Integer -> Model Integer)

-- | <tt><a>projectCases</a> x φ</tt> returns <tt>[(ψ_1, lift_1), …, (ψ_m,
--   lift_m)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LIA ∀y1, …, yn. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_m)</tt> where
--   <tt>{y1, …, yn} = FV(φ) \ {x}</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ_i</tt> then <tt>lift_i M ⊧_LIA φ</tt>.</li>
--   </ul>
projectCases :: Var -> QFFormula -> [(QFFormula, Model Integer -> Model Integer)]

-- | <tt><a>projectCasesN</a> {x1,…,xm} φ</tt> returns <tt>[(ψ_1, lift_1),
--   …, (ψ_n, lift_n)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LIA ∀y1, …, yp. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_n)</tt> where
--   <tt>{y1, …, yp} = FV(φ) \ {x1,…,xm}</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ_i</tt> then <tt>lift_i M ⊧_LIA φ</tt>.</li>
--   </ul>
projectCasesN :: VarSet -> QFFormula -> [(QFFormula, Model Integer -> Model Integer)]

-- | <tt><a>solve</a> {x1,…,xn} φ</tt> returns <tt>Just M</tt> that <tt>M
--   ⊧_LIA φ</tt> when such <tt>M</tt> exists, returns <tt>Nothing</tt>
--   otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solve :: VarSet -> [Atom Rational] -> Maybe (Model Integer)

-- | <tt><a>solveQFFormula</a> {x1,…,xn} φ</tt> returns <tt>Just M</tt>
--   that <tt>M ⊧_LIA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solveQFFormula :: VarSet -> QFFormula -> Maybe (Model Integer)

-- | <tt><a>solveQFLIRAConj</a> {x1,…,xn} φ I</tt> returns <tt>Just M</tt>
--   that <tt>M ⊧_LIRA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <ul>
--   <li><tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.</li>
--   <li><tt>I</tt> is a set of integer variables and must be a subset of
--   <tt>{x1,…,xn}</tt>.</li>
--   </ul>
solveQFLIRAConj :: VarSet -> [Atom Rational] -> VarSet -> Maybe (Model Rational)
instance Show Lit
instance Eq Lit
instance Ord Lit
instance Show Witness
instance Integral a => Monoid (LCM a)
instance IsArithRel (Expr Integer) QFFormula
instance Complement Lit
instance Variables Lit


module ToySolver.Arith.Cooper.FOL

-- | Eliminate quantifiers and returns equivalent quantifier-free formula.
--   
--   <tt><a>eliminateQuantifiers</a> φ</tt> returns <tt>(ψ, lift)</tt> such
--   that:
--   
--   <ul>
--   <li>ψ is a quantifier-free formula and <tt>LIA ⊢ ∀y1, …, yn. φ ↔
--   ψ</tt> where <tt>{y1, …, yn} = FV(φ) ⊇ FV(ψ)</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ</tt> then <tt>lift M ⊧_LIA φ</tt>.</li>
--   </ul>
--   
--   φ may or may not be a closed formula.
eliminateQuantifiers :: Formula (Atom Rational) -> Maybe QFFormula

-- | <pre>
--   <a>solveFormula</a> {x1,…,xm} φ
--   </pre>
--   
--   <ul>
--   <li>returns <tt><tt>Sat</tt> M</tt> such that <tt>M ⊧_LIA φ</tt> when
--   such <tt>M</tt> exists,</li>
--   <li>returns <tt><tt>Unsat</tt></tt> when such <tt>M</tt> does not
--   exists, and</li>
--   <li>returns <tt><tt>Unknown</tt></tt> when <tt>φ</tt> is beyond
--   LIA.</li>
--   </ul>
solveFormula :: VarSet -> Formula (Atom Rational) -> SatResult Integer


-- | Naive implementation of Cooper's algorithm
--   
--   Reference:
--   
--   <ul>
--   
--   <li><a>http://hagi.is.s.u-tokyo.ac.jp/pub/staff/hagiya/kougiroku/ronri/5.txt</a></li>
--   
--   <li><a>http://www.cs.cmu.edu/~emc/spring06/home1_files/Presburger%20Arithmetic.ppt</a></li>
--   </ul>
--   
--   See also:
--   
--   <ul>
--   <li><a>http://hackage.haskell.org/package/presburger</a></li>
--   </ul>
module ToySolver.Arith.Cooper

-- | Linear arithmetic expression over integers.
type ExprZ = Expr Integer

-- | Literals of Presburger arithmetic.
data Lit

-- | <tt>IsPos e</tt> means <tt>e &gt; 0</tt>
IsPos :: ExprZ -> Lit

-- | <ul>
--   <li><tt>Divisible True d e</tt> means <tt>e</tt> can be divided by
--   <tt>d</tt> (i.e. <tt>d | e</tt>)</li>
--   <li><tt>Divisible False d e</tt> means <tt>e</tt> can not be divided
--   by <tt>d</tt> (i.e. <tt>¬(d | e)</tt>)</li>
--   </ul>
Divisible :: Bool -> Integer -> ExprZ -> Lit

-- | Quantifier-free formula of Presburger arithmetic.
type QFFormula = BoolExpr Lit
fromLAAtom :: Atom Rational -> QFFormula

-- | <tt>d | e</tt> means <tt>e</tt> can be divided by <tt>d</tt>.
(.|.) :: Integer -> ExprZ -> QFFormula

-- | <tt><a>evalQFFormula</a> M φ</tt> returns whether <tt>M ⊧_LIA φ</tt>
--   or not.
evalQFFormula :: Model Integer -> QFFormula -> Bool

-- | A <tt>Model</tt> is a map from variables to values.
type Model r = VarMap r

-- | <tt><a>project</a> x φ</tt> returns <tt>(ψ, lift)</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LIA ∀y1, …, yn. (∃x. φ) ↔ ψ</tt> where <tt>{y1, …, yn} =
--   FV(φ) \ {x}</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ</tt> then <tt>lift M ⊧_LIA φ</tt>.</li>
--   </ul>
project :: Var -> QFFormula -> (QFFormula, Model Integer -> Model Integer)

-- | <tt><a>projectN</a> {x1,…,xm} φ</tt> returns <tt>(ψ, lift)</tt> such
--   that:
--   
--   <ul>
--   <li><tt>⊢_LIA ∀y1, …, yn. (∃x1, …, xm. φ) ↔ ψ</tt> where <tt>{y1, …,
--   yn} = FV(φ) \ {x1,…,xm}</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ</tt> then <tt>lift M ⊧_LIA φ</tt>.</li>
--   </ul>
projectN :: VarSet -> QFFormula -> (QFFormula, Model Integer -> Model Integer)

-- | <tt><a>projectCases</a> x φ</tt> returns <tt>[(ψ_1, lift_1), …, (ψ_m,
--   lift_m)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LIA ∀y1, …, yn. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_m)</tt> where
--   <tt>{y1, …, yn} = FV(φ) \ {x}</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ_i</tt> then <tt>lift_i M ⊧_LIA φ</tt>.</li>
--   </ul>
projectCases :: Var -> QFFormula -> [(QFFormula, Model Integer -> Model Integer)]

-- | <tt><a>projectCasesN</a> {x1,…,xm} φ</tt> returns <tt>[(ψ_1, lift_1),
--   …, (ψ_n, lift_n)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LIA ∀y1, …, yp. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_n)</tt> where
--   <tt>{y1, …, yp} = FV(φ) \ {x1,…,xm}</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ_i</tt> then <tt>lift_i M ⊧_LIA φ</tt>.</li>
--   </ul>
projectCasesN :: VarSet -> QFFormula -> [(QFFormula, Model Integer -> Model Integer)]

-- | Eliminate quantifiers and returns equivalent quantifier-free formula.
--   
--   <tt><a>eliminateQuantifiers</a> φ</tt> returns <tt>(ψ, lift)</tt> such
--   that:
--   
--   <ul>
--   <li>ψ is a quantifier-free formula and <tt>LIA ⊢ ∀y1, …, yn. φ ↔
--   ψ</tt> where <tt>{y1, …, yn} = FV(φ) ⊇ FV(ψ)</tt>, and</li>
--   <li>if <tt>M ⊧_LIA ψ</tt> then <tt>lift M ⊧_LIA φ</tt>.</li>
--   </ul>
--   
--   φ may or may not be a closed formula.
eliminateQuantifiers :: Formula (Atom Rational) -> Maybe QFFormula

-- | <tt><a>solve</a> {x1,…,xn} φ</tt> returns <tt>Just M</tt> that <tt>M
--   ⊧_LIA φ</tt> when such <tt>M</tt> exists, returns <tt>Nothing</tt>
--   otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solve :: VarSet -> [Atom Rational] -> Maybe (Model Integer)

-- | <tt><a>solveQFFormula</a> {x1,…,xn} φ</tt> returns <tt>Just M</tt>
--   that <tt>M ⊧_LIA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solveQFFormula :: VarSet -> QFFormula -> Maybe (Model Integer)

-- | <pre>
--   <a>solveFormula</a> {x1,…,xm} φ
--   </pre>
--   
--   <ul>
--   <li>returns <tt><tt>Sat</tt> M</tt> such that <tt>M ⊧_LIA φ</tt> when
--   such <tt>M</tt> exists,</li>
--   <li>returns <tt><tt>Unsat</tt></tt> when such <tt>M</tt> does not
--   exists, and</li>
--   <li>returns <tt><tt>Unknown</tt></tt> when <tt>φ</tt> is beyond
--   LIA.</li>
--   </ul>
solveFormula :: VarSet -> Formula (Atom Rational) -> SatResult Integer

-- | <tt><a>solveQFLIRAConj</a> {x1,…,xn} φ I</tt> returns <tt>Just M</tt>
--   that <tt>M ⊧_LIRA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <ul>
--   <li><tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.</li>
--   <li><tt>I</tt> is a set of integer variables and must be a subset of
--   <tt>{x1,…,xn}</tt>.</li>
--   </ul>
solveQFLIRAConj :: VarSet -> [Atom Rational] -> VarSet -> Maybe (Model Rational)


-- | Naïve implementation of Simplex method
--   
--   Reference:
--   
--   <ul>
--   <li><a>http://www.math.cuhk.edu.hk/~wei/lpch3.pdf</a></li>
--   <li>Bruno Dutertre and Leonardo de Moura. A Fast Linear-Arithmetic
--   Solver for DPLL(T). Computer Aided Verification In Computer Aided
--   Verification, Vol. 4144 (2006), pp. 81-94.
--   <a>http://yices.csl.sri.com/cav06.pdf</a></li>
--   <li>Bruno Dutertre and Leonardo de Moura. Integrating Simplex with
--   DPLL(T). CSL Technical Report SRI-CSL-06-01. 2006.
--   <a>http://yices.csl.sri.com/sri-csl-06-01.pdf</a></li>
--   </ul>
module ToySolver.Arith.Simplex2
type Solver = GenericSolver Rational
data GenericSolver v
class (VectorSpace v, Scalar v ~ Rational, Ord v) => SolverValue v
toValue :: SolverValue v => Rational -> v
showValue :: SolverValue v => Bool -> v -> String
getModel :: SolverValue v => GenericSolver v -> IO Model
newSolver :: SolverValue v => IO (GenericSolver v)
cloneSolver :: GenericSolver v -> IO (GenericSolver v)
type Var = Int
newVar :: SolverValue v => GenericSolver v -> IO Var

-- | relational operators
data RelOp
Lt :: RelOp
Le :: RelOp
Ge :: RelOp
Gt :: RelOp
Eql :: RelOp
NEq :: RelOp

-- | constructing relational formula
(.<=.) :: IsArithRel e r => e -> e -> r

-- | constructing relational formula
(.>=.) :: IsArithRel e r => e -> e -> r

-- | constructing relational formula
(.==.) :: IsArithRel e r => e -> e -> r

-- | constructing relational formula
(.<.) :: IsArithRel e r => e -> e -> r

-- | constructing relational formula
(.>.) :: IsArithRel e r => e -> e -> r

-- | Atomic Formula of Linear Arithmetics
type Atom r = ArithRel (Expr r)
assertAtom :: Solver -> Atom Rational -> IO ()
assertAtomEx :: GenericSolver (Delta Rational) -> Atom Rational -> IO ()
assertLower :: SolverValue v => GenericSolver v -> Var -> v -> IO ()
assertUpper :: SolverValue v => GenericSolver v -> Var -> v -> IO ()
setObj :: SolverValue v => GenericSolver v -> Expr Rational -> IO ()
getObj :: SolverValue v => GenericSolver v -> IO (Expr Rational)

-- | The <a>OptDir</a> type represents optimization directions.
data OptDir :: *

-- | minimization
OptMin :: OptDir

-- | maximization
OptMax :: OptDir
setOptDir :: GenericSolver v -> OptDir -> IO ()
getOptDir :: GenericSolver v -> IO OptDir
check :: SolverValue v => GenericSolver v -> IO Bool
pushBacktrackPoint :: GenericSolver v -> IO ()
popBacktrackPoint :: GenericSolver v -> IO ()
data Options
Options :: Maybe Rational -> Options
objLimit :: Options -> Maybe Rational
defaultOptions :: Options

-- | results of optimization
data OptResult
Optimum :: OptResult
Unsat :: OptResult
Unbounded :: OptResult
ObjLimit :: OptResult
optimize :: Solver -> Options -> IO OptResult
dualSimplex :: Solver -> Options -> IO OptResult
type Model = IntMap Rational
type RawModel v = IntMap v
getRawModel :: GenericSolver v -> IO (RawModel v)
getValue :: GenericSolver v -> Var -> IO v
getObjValue :: GenericSolver v -> IO v
getTableau :: GenericSolver v -> IO (IntMap (Expr Rational))
getRow :: GenericSolver v -> Var -> IO (Expr Rational)
getCol :: SolverValue v => GenericSolver v -> Var -> IO (IntMap Rational)
getCoeff :: GenericSolver v -> Var -> Var -> IO Rational
nVars :: GenericSolver v -> IO Int
isBasicVariable :: GenericSolver v -> Var -> IO Bool
isNonBasicVariable :: GenericSolver v -> Var -> IO Bool
isFeasible :: SolverValue v => GenericSolver v -> IO Bool
isOptimal :: SolverValue v => GenericSolver v -> IO Bool
getLB :: GenericSolver v -> Var -> IO (Maybe v)
getUB :: GenericSolver v -> Var -> IO (Maybe v)

-- | set callback function for receiving messages.
setLogger :: GenericSolver v -> (String -> IO ()) -> IO ()
clearLogger :: GenericSolver v -> IO ()
data PivotStrategy
PivotStrategyBlandRule :: PivotStrategy
PivotStrategyLargestCoefficient :: PivotStrategy
setPivotStrategy :: GenericSolver v -> PivotStrategy -> IO ()
dump :: SolverValue v => GenericSolver v -> IO ()
instance Eq PivotStrategy
instance Ord PivotStrategy
instance Enum PivotStrategy
instance Show PivotStrategy
instance Read PivotStrategy
instance Show OptResult
instance Eq OptResult
instance Ord OptResult
instance Show Options
instance Eq Options
instance Ord Options
instance Default Options
instance SolverValue (Delta Rational)
instance SolverValue Rational


-- | Naïve implementation of MIP solver based on Simplex2 module
--   
--   Reference:
--   
--   <ul>
--   <li><a>http://www.math.cuhk.edu.hk/~wei/lpch3.pdf</a></li>
--   <li>Ralph E. Gomory. "An Algorithm for the Mixed Integer Problem",
--   Technical Report RM-2597, 1960, The Rand Corporation, Santa Monica,
--   CA.
--   <a>http://www.rand.org/pubs/research_memoranda/RM2597.html</a></li>
--   <li>Ralph E. Gomory. "Outline of an algorithm for integer solutions to
--   linear programs". Bull. Amer. Math. Soc., Vol. 64, No. 5. (1958), pp.
--   275-278. <a>http://projecteuclid.org/euclid.bams/1183522679</a></li>
--   <li>R. C. Daniel and Martyn Jeffreys. "Unboundedness in Integer and
--   Discrete Programming L.P. Relaxations" The Journal of the Operational
--   Research Society, Vol. 30, No. 12. (1979)
--   <a>http://www.jstor.org/stable/3009435</a></li>
--   </ul>
module ToySolver.Arith.MIPSolver2
data Solver
newSolver :: Solver -> IntSet -> IO Solver
optimize :: Solver -> IO OptResult
getBestSolution :: Solver -> IO (Maybe (Model, Rational))
getBestValue :: Solver -> IO (Maybe Rational)
getBestModel :: Solver -> IO (Maybe Model)
setNThread :: Solver -> Int -> IO ()

-- | set callback function for receiving messages.
setLogger :: Solver -> (String -> IO ()) -> IO ()
setOnUpdateBestSolution :: Solver -> (Model -> Rational -> IO ()) -> IO ()
setShowRational :: Solver -> Bool -> IO ()


-- | Naive implementation of virtual substitution
--   
--   Reference:
--   
--   <ul>
--   <li>V. Weispfenning. The complexity of linear problems in fields.
--   Journal of Symbolic Computation, 5(1-2): 3-27, Feb.-Apr. 1988.</li>
--   <li>Hirokazu Anai, Shinji Hara. Parametric Robust Control by
--   Quantifier Elimination. J.JSSAC, Vol. 10, No. 1, pp. 41-51, 2003.</li>
--   </ul>
module ToySolver.Arith.VirtualSubstitution

-- | Quantifier-free formula of LRA
type QFFormula = BoolExpr (Atom Rational)

-- | <tt><a>evalQFFormula</a> M φ</tt> returns whether <tt>M ⊧_LRA φ</tt>
--   or not.
evalQFFormula :: Model Rational -> QFFormula -> Bool

-- | <tt><a>project</a> x φ</tt> returns <tt>(ψ, lift)</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LRA ∀y1, …, yn. (∃x. φ) ↔ ψ</tt> where <tt>{y1, …, yn} =
--   FV(φ) \ {x}</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ</tt> then <tt>lift M ⊧ φ</tt>.</li>
--   </ul>
project :: Var -> QFFormula -> (QFFormula, Model Rational -> Model Rational)

-- | <tt><a>projectN</a> {x1,…,xm} φ</tt> returns <tt>(ψ, lift)</tt> such
--   that:
--   
--   <ul>
--   <li><tt>⊢_LRA ∀y1, …, yn. (∃x1, …, xm. φ) ↔ ψ</tt> where <tt>{y1, …,
--   yn} = FV(φ) \ {x1,…,xm}</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ</tt> then <tt>lift M ⊧_LRA φ</tt>.</li>
--   </ul>
projectN :: VarSet -> QFFormula -> (QFFormula, Model Rational -> Model Rational)

-- | <tt><a>projectCases</a> x φ</tt> returns <tt>[(ψ_1, lift_1), …, (ψ_m,
--   lift_m)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LRA ∀y1, …, yn. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_m)</tt> where
--   <tt>{y1, …, yn} = FV(φ) \ {x}</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ_i</tt> then <tt>lift_i M ⊧_LRA φ</tt>.</li>
--   </ul>
projectCases :: Var -> QFFormula -> [(QFFormula, Model Rational -> Model Rational)]

-- | <tt><a>projectCasesN</a> {x1,…,xm} φ</tt> returns <tt>[(ψ_1, lift_1),
--   …, (ψ_n, lift_n)]</tt> such that:
--   
--   <ul>
--   <li><tt>⊢_LRA ∀y1, …, yp. (∃x. φ) ↔ (ψ_1 ∨ … ∨ φ_n)</tt> where
--   <tt>{y1, …, yp} = FV(φ) \ {x1,…,xm}</tt>, and</li>
--   <li>if <tt>M ⊧_LRA ψ_i</tt> then <tt>lift_i M ⊧_LRA φ</tt>.</li>
--   </ul>
projectCasesN :: VarSet -> QFFormula -> [(QFFormula, Model Rational -> Model Rational)]

-- | <tt><a>solve</a> {x1,…,xn} φ</tt> returns <tt>Just M</tt> such that
--   <tt>M ⊧_LRA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solve :: VarSet -> [Atom Rational] -> Maybe (Model Rational)

-- | <tt><a>solveQFFormula</a> {x1,…,xn} φ</tt> returns <tt>Just M</tt>
--   such that <tt>M ⊧_LRA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solveQFFormula :: VarSet -> QFFormula -> Maybe (Model Rational)


-- | (incomplete) implementation of Omega Test
--   
--   References:
--   
--   <ul>
--   <li>William Pugh. The Omega test: a fast and practical integer
--   programming algorithm for dependence analysis. In Proceedings of the
--   1991 ACM/IEEE conference on Supercomputing (1991), pp. 4-13.</li>
--   
--   <li><a>http://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf</a></li>
--   </ul>
--   
--   See also:
--   
--   <ul>
--   <li><a>http://hackage.haskell.org/package/Omega</a></li>
--   </ul>
module ToySolver.Arith.OmegaTest.Base

-- | A <tt>Model</tt> is a map from variables to values.
type Model r = VarMap r

-- | <tt><a>solve</a> opt {x1,…,xn} φ</tt> returns <tt>Just M</tt> that
--   <tt>M ⊧_LIA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solve :: Options -> VarSet -> [Atom Rational] -> Maybe (Model Integer)

-- | <tt><a>solveQFLIRAConj</a> {x1,…,xn} φ I</tt> returns <tt>Just M</tt>
--   that <tt>M ⊧_LIRA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <ul>
--   <li><tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.</li>
--   <li><tt>I</tt> is a set of integer variables and must be a subset of
--   <tt>{x1,…,xn}</tt>.</li>
--   </ul>
solveQFLIRAConj :: Options -> VarSet -> [Atom Rational] -> VarSet -> Maybe (Model Rational)
data Options
Options :: (VarSet -> [Atom Rational] -> Bool) -> Options

-- | optCheckReal is used for checking whether real shadow is satisfiable.
--   
--   <ul>
--   <li>If it returns <tt>True</tt>, the real shadow may or may not be
--   satisfiable.</li>
--   <li>If it returns <tt>False</tt>, the real shadow must be
--   unsatisfiable</li>
--   </ul>
optCheckReal :: Options -> VarSet -> [Atom Rational] -> Bool
defaultOptions :: Options
checkRealNoCheck :: VarSet -> [Atom Rational] -> Bool
checkRealByFM :: VarSet -> [Atom Rational] -> Bool
zmod :: Integer -> Integer -> Integer
instance Show Constr
instance Eq Constr
instance Ord Constr
instance Variables Constr
instance Default Options


-- | (incomplete) implementation of Omega Test
--   
--   References:
--   
--   <ul>
--   <li>William Pugh. The Omega test: a fast and practical integer
--   programming algorithm for dependence analysis. In Proceedings of the
--   1991 ACM/IEEE conference on Supercomputing (1991), pp. 4-13.</li>
--   
--   <li><a>http://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf</a></li>
--   </ul>
--   
--   See also:
--   
--   <ul>
--   <li><a>http://hackage.haskell.org/package/Omega</a></li>
--   </ul>
module ToySolver.Arith.OmegaTest

-- | A <tt>Model</tt> is a map from variables to values.
type Model r = VarMap r

-- | <tt><a>solve</a> opt {x1,…,xn} φ</tt> returns <tt>Just M</tt> that
--   <tt>M ⊧_LIA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.
solve :: Options -> VarSet -> [Atom Rational] -> Maybe (Model Integer)

-- | <tt><a>solveQFLIRAConj</a> {x1,…,xn} φ I</tt> returns <tt>Just M</tt>
--   that <tt>M ⊧_LIRA φ</tt> when such <tt>M</tt> exists, returns
--   <tt>Nothing</tt> otherwise.
--   
--   <ul>
--   <li><tt>FV(φ)</tt> must be a subset of <tt>{x1,…,xn}</tt>.</li>
--   <li><tt>I</tt> is a set of integer variables and must be a subset of
--   <tt>{x1,…,xn}</tt>.</li>
--   </ul>
solveQFLIRAConj :: Options -> VarSet -> [Atom Rational] -> VarSet -> Maybe (Model Rational)
data Options
Options :: (VarSet -> [Atom Rational] -> Bool) -> Options

-- | optCheckReal is used for checking whether real shadow is satisfiable.
--   
--   <ul>
--   <li>If it returns <tt>True</tt>, the real shadow may or may not be
--   satisfiable.</li>
--   <li>If it returns <tt>False</tt>, the real shadow must be
--   unsatisfiable</li>
--   </ul>
optCheckReal :: Options -> VarSet -> [Atom Rational] -> Bool
defaultOptions :: Options
checkRealNoCheck :: VarSet -> [Atom Rational] -> Bool
checkRealByFM :: VarSet -> [Atom Rational] -> Bool
checkRealByCAD :: VarSet -> [Atom Rational] -> Bool
checkRealByVS :: VarSet -> [Atom Rational] -> Bool
checkRealBySimplex :: VarSet -> [Atom Rational] -> Bool

module ToySolver.SAT.Integer
newtype Expr
Expr :: PBSum -> Expr
newVar :: Solver -> Integer -> Integer -> IO Expr
linearize :: Encoder -> Expr -> IO (PBLinSum, Integer)
addConstraint :: Encoder -> ArithRel Expr -> IO ()
addConstraintSoft :: Encoder -> Lit -> ArithRel Expr -> IO ()
eval :: IModel m => m -> Expr -> Integer
instance Num Expr
instance VectorSpace Expr
instance AdditiveGroup Expr


-- | Tightening variable bounds by constraint propagation.
module ToySolver.Arith.BoundsInference
type BoundsEnv r = VarMap (Interval r)

-- | tightening variable bounds by constraint propagation.
inferBounds :: RealFrac r => BoundsEnv r -> [Atom r] -> VarSet -> Int -> BoundsEnv r

-- | compute bounds for a <tt>Expr</tt> with respect to <tt>BoundsEnv</tt>.
computeInterval :: (Real r, Fractional r) => BoundsEnv r -> Expr r -> Interval r

module ToySolver.Arith.LPUtil
toStandardForm :: (Expr Rational, [ArithRel (Expr Rational)]) -> ((Expr Rational, [(Expr Rational, Rational)]), Model Rational -> Model Rational)
toStandardForm' :: (Expr Rational, [ArithRel (Expr Rational)]) -> ((Expr Rational, [(Expr Rational, Rational)]), VarMap (Expr Rational))


-- | References:
--   
--   <ul>
--   <li>P. Conti and C. Traverso, "Buchberger algorithm and integer
--   programming," Applied Algebra, Algebraic Algorithms and
--   Error-Correcting Codes, Lecture Notes in Computer Science Volume 539,
--   1991, pp 130-139 <a>http://dx.doi.org/10.1007/3-540-54522-0_102</a>
--   <a>http://posso.dm.unipi.it/users/traverso/conti-traverso-ip.ps</a></li>
--   <li>IKEGAMI Daisuke, "数列と多項式の愛しい関係," 2011,
--   <a>http://madscientist.jp/~ikegami/articles/IntroSequencePolynomial.html</a></li>
--   <li>伊藤雅史, , 平林 隆一, "整数計画問題のための b-Gröbner 基底変換アルゴリズム,"
--   <a>http://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1295-27.pdf</a></li>
--   </ul>
module ToySolver.Arith.ContiTraverso
solve :: MonomialOrder Var -> VarSet -> OptDir -> Expr Rational -> [Atom Rational] -> Maybe (Model Integer)
solve' :: MonomialOrder Var -> VarSet -> Expr Integer -> [(Expr Integer, Integer)] -> Maybe (Model Integer)


-- | Naïve implementation of Simplex method
--   
--   Reference:
--   
--   <ul>
--   <li><a>http://www.math.cuhk.edu.hk/~wei/lpch3.pdf</a></li>
--   </ul>
module ToySolver.Arith.LPSolver
type Solver r = (Var, Tableau r, VarSet, VarMap (Expr r))
emptySolver :: VarSet -> Solver r
type LP r = State (Solver r)
getTableau :: LP r (Tableau r)
putTableau :: Tableau r -> LP r ()

-- | Allocate a new <i>non-negative</i> variable.
newVar :: LP r Var

-- | Add a contraint, without maintaining feasibilty condition of tableaus.
--   
--   <ul>
--   <li>Disequality is not supported.</li>
--   <li>Unlike <a>addConstraintWithArtificialVariable</a>, an equality
--   constraint becomes two rows.</li>
--   </ul>
addConstraint :: Real r => Atom r -> LP r ()

-- | Add a contraint and maintain feasibility condition by introducing
--   artificial variable (if necessary).
--   
--   <ul>
--   <li>Disequality is not supported.</li>
--   <li>Unlike <a>addConstraint</a>, an equality contstraint becomes one
--   row with an artificial variable.</li>
--   </ul>
addConstraintWithArtificialVariable :: Real r => Atom r -> LP r ()
tableau :: RealFrac r => [Atom r] -> LP r ()
define :: Var -> Expr r -> LP r ()
phaseI :: (Fractional r, Real r) => LP r Bool
simplex :: (Fractional r, Real r) => OptDir -> Expr r -> LP r Bool
dualSimplex :: (Fractional r, Real r) => OptDir -> Expr r -> LP r Bool

-- | results of optimization
data OptResult
Optimum :: OptResult
Unsat :: OptResult
Unbounded :: OptResult
twoPhaseSimplex :: (Fractional r, Real r) => OptDir -> Expr r -> LP r OptResult
primalDualSimplex :: (Fractional r, Real r) => OptDir -> Expr r -> LP r OptResult
getModel :: Fractional r => VarSet -> LP r (Model r)
collectNonnegVars :: RealFrac r => [Atom r] -> VarSet -> (VarSet, [Atom r])
instance Show OptResult
instance Eq OptResult
instance Ord OptResult


-- | High-Level API for LPSolver.hs
module ToySolver.Arith.LPSolverHL

-- | results of optimization
data OptResult r
OptUnsat :: OptResult r
Unbounded :: OptResult r
Optimum :: r -> (Model r) -> OptResult r
minimize :: RealFrac r => Expr r -> [Atom r] -> OptResult r
maximize :: RealFrac r => Expr r -> [Atom r] -> OptResult r
optimize :: RealFrac r => OptDir -> Expr r -> [Atom r] -> OptResult r
solve :: RealFrac r => [Atom r] -> Maybe (Model r)
instance Show r => Show (OptResult r)
instance Eq r => Eq (OptResult r)
instance Ord r => Ord (OptResult r)


-- | References:
--   
--   <ul>
--   <li>[Gomory1960] Ralph E. Gomory. An Algorithm for the Mixed Integer
--   Problem, Technical Report RM-2597, 1960, The Rand Corporation, Santa
--   Monica, CA.
--   <a>http://www.rand.org/pubs/research_memoranda/RM2597.html</a></li>
--   <li>[Gomory1958] Ralph E. Gomory. Outline of an algorithm for integer
--   solutions to linear programs. Bull. Amer. Math. Soc., Vol. 64, No. 5.
--   (1958), pp. 275-278.
--   <a>http://projecteuclid.org/euclid.bams/1183522679</a></li>
--   </ul>
module ToySolver.Arith.MIPSolverHL

-- | results of optimization
data OptResult r
OptUnsat :: OptResult r
Unbounded :: OptResult r
Optimum :: r -> (Model r) -> OptResult r
minimize :: RealFrac r => Expr r -> [Atom r] -> VarSet -> OptResult r
maximize :: RealFrac r => Expr r -> [Atom r] -> VarSet -> OptResult r
optimize :: RealFrac r => OptDir -> Expr r -> [Atom r] -> VarSet -> OptResult r
instance Ord Err
instance Eq Err
instance Show Err
instance Enum Err
instance Bounded Err
