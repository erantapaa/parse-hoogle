-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient automatic differentiation and code generation
--   
--   dvda == DVDA Verifiably Differentiates Algorithmically
--   
--   This library provides a symbolic scalar type <a>Dvda.Expr</a> which is
--   manipulated mathematically through its Num/Fractional/Floating
--   instances.
--   
--   Automatic differentiation can be performed with <a>Dvda.AD</a>.
--   Expressions can be turned into computational graphs
--   (<tt>FunGraph</tt>s) using toFunGraph. This uses unsafe reification
--   for performance reasons, and explicit common subexpression elimination
--   using hashing can be performed using <a>Dvda.CSE</a>
--   
--   <tt>FunGraph</tt>s can be converted to C code and MATLAB mex
--   functions. In the future there will be JIT compilation so you can call
--   these functions efficiently from Haskell.
--   
--   Pretty graphviz plots!
--   
--   To get started check out the source for <a>Dvda.Examples</a>
@package dvda
@version 0.3.2.1

module Dvda.ReifyGraph
data ReifyGraph e
ReifyGraph :: [(Unique, e Unique)] -> ReifyGraph e
instance Show (e Int) => Show (ReifyGraph e)

module Dvda.Reify
class MuRef a where type family DeRef a :: * -> *
mapDeRef :: (MuRef a, Applicative f) => (forall b. (MuRef b, DeRef a ~ DeRef b) => b -> f u) -> a -> f (DeRef a u)
data ReifyGraph e
ReifyGraph :: [(Unique, e Unique)] -> ReifyGraph e

-- | <tt>reifyGraph</tt> takes a data structure that admits <a>MuRef</a>,
--   and returns a <a>ReifyGraph</a> that contains the dereferenced nodes,
--   with their children as <a>Int</a> rather than recursive values.
reifyGraphs :: (MuRef s, Traversable t) => [t s] -> IO (ReifyGraph (DeRef s), [t Int])
instance Eq DynStableName
instance Hashable DynStableName

module Dvda.Codegen.WriteFile
writeSourceFile :: String -> FilePath -> FilePath -> IO FilePath

module Dvda.Codegen.Gcc

-- | take in name of source and future object, compile object
compileWithGcc :: FilePath -> FilePath -> IO ()

module Dvda.SparseLA
data SparseVec a
data SparseMat a
svFromList :: [a] -> SparseVec a
smFromLists :: [[a]] -> SparseMat a
svFromSparseList :: [(Int, a)] -> Int -> SparseVec a
smFromSparseList :: [((Int, Int), a)] -> (Int, Int) -> SparseMat a
denseListFromSv :: Num a => SparseVec a -> [a]
sparseListFromSv :: SparseVec a -> [a]
svZeros :: Int -> SparseVec a
smZeros :: (Int, Int) -> SparseMat a
svSize :: SparseVec a -> Int
smSize :: SparseMat a -> (Int, Int)
svMap :: (a -> b) -> SparseVec a -> SparseVec b
smMap :: (a -> b) -> SparseMat a -> SparseMat b
svBinary :: (a -> b -> c) -> (IntMap a -> IntMap c) -> (IntMap b -> IntMap c) -> SparseVec a -> SparseVec b -> Maybe (SparseVec c)
smBinary :: (a -> a -> a) -> (IntMap a -> IntMap a) -> (IntMap a -> IntMap a) -> SparseMat a -> SparseMat a -> Maybe (SparseMat a)
svAdd :: Num a => SparseVec a -> SparseVec a -> Maybe (SparseVec a)
svSub :: Num a => SparseVec a -> SparseVec a -> Maybe (SparseVec a)
svMul :: Num a => SparseVec a -> SparseVec a -> Maybe (SparseVec a)
smAdd :: Num a => SparseMat a -> SparseMat a -> Maybe (SparseMat a)
smSub :: Num a => SparseMat a -> SparseMat a -> Maybe (SparseMat a)
smMul :: Num a => SparseMat a -> SparseMat a -> Maybe (SparseMat a)
svScale :: Num a => a -> SparseVec a -> SparseVec a
smScale :: Num a => a -> SparseMat a -> SparseMat a
getRow :: Int -> SparseMat a -> SparseVec a
getCol :: Int -> SparseMat a -> SparseVec a
svCat :: SparseVec a -> SparseVec a -> SparseVec a
svCats :: [SparseVec a] -> SparseVec a
sVV :: Num a => SparseVec a -> SparseVec a -> Maybe a
sMV :: Num a => SparseMat a -> SparseVec a -> Maybe (SparseVec a)
instance Num a => Num (SparseVec a)
instance Show a => Show (SparseVec a)
instance Num a => Num (SparseMat a)
instance Show a => Show (SparseMat a)

module Dvda.Dual
data Dual a
Dual :: a -> a -> Dual a
dualPrimal :: Dual a -> a
dualPerturbation :: Dual a -> a

-- | Forward derivative propogation. fad sin x == cos x
fad :: Num a => (Dual a -> Dual a) -> a -> a

-- | Forward derivative propogation. fad' [sin x, 2*x] == [cos x, 2]
fad' :: Num a => (Dual a -> [Dual a]) -> a -> [a]
instance Show a => Show (Dual a)
instance Eq a => Eq (Dual a)
instance Floating a => Floating (Dual a)
instance Fractional a => Fractional (Dual a)
instance Num a => Num (Dual a)

module Dvda.Expr
data Expr a
ESym :: Sym -> Expr a
EConst :: a -> Expr a
ENum :: Nums (Expr a) -> Expr a
EFractional :: Fractionals (Expr a) -> Expr a
EFloating :: Floatings (Expr a) -> Expr a
data GExpr a b
GSym :: Sym -> GExpr a b
GConst :: a -> GExpr a b
GNum :: Nums b -> GExpr a b
GFractional :: Fractionals b -> GExpr a b
GFloating :: Floatings b -> GExpr a b
data Nums a
Mul :: a -> a -> Nums a
Add :: a -> a -> Nums a
Sub :: a -> a -> Nums a
Negate :: a -> Nums a
Abs :: a -> Nums a
Signum :: a -> Nums a
FromInteger :: Integer -> Nums a
data Fractionals a
Div :: a -> a -> Fractionals a
FromRational :: Rational -> Fractionals a
data Floatings a
Pow :: a -> a -> Floatings a
LogBase :: a -> a -> Floatings a
Exp :: a -> Floatings a
Log :: a -> Floatings a
Sin :: a -> Floatings a
Cos :: a -> Floatings a
ASin :: a -> Floatings a
ATan :: a -> Floatings a
ACos :: a -> Floatings a
Sinh :: a -> Floatings a
Cosh :: a -> Floatings a
Tanh :: a -> Floatings a
ASinh :: a -> Floatings a
ATanh :: a -> Floatings a
ACosh :: a -> Floatings a
data Sym
Sym :: String -> Sym
SymDependent :: String -> Int -> Sym -> Sym

-- | Checks to see if an Expr is equal to a value
isVal :: Eq a => a -> Expr a -> Bool

-- | symbolic scalar
sym :: String -> Expr a

-- | Symbolic scalar which is a function of some independent variable, like
--   time. . This lets you do d(f(g(t)))/dt == f'(g(t))*g'(t)
symDependent :: String -> Expr a -> Expr a

-- | same as symDependent but it can start as the Nth derivative
symDependentN :: String -> Expr a -> Int -> Expr a
const' :: a -> Expr a
getParents :: GExpr a b -> [b]
extractLinearPart :: (Num a, Ord a, Show a) => Expr a -> Expr a -> (Expr a, a)

-- | if the expression is a constant, a fromInteger, or a fromRational,
--   return the constant part otherwise return nothing
getConst :: Expr a -> Maybe a
substitute :: (Ord a, Hashable a, Show a) => Expr a -> [(Expr a, Expr a)] -> Expr a

-- | this substitute is sketchy because it doesn't perform simplifications
--   that are often assumed to be done
sketchySubstitute :: (Eq a, Hashable a, Show a) => Expr a -> [(Expr a, Expr a)] -> Expr a

-- | foldr over the constants and symbols
foldExpr :: (Expr a -> b -> b) -> b -> Expr a -> b
fromNeg :: (Num a, Ord a) => Expr a -> Maybe (Expr a)
instance (Eq a, Eq b) => Eq (GExpr a b)
instance (Ord a, Ord b) => Ord (GExpr a b)
instance Typeable2 GExpr
instance Typeable1 Expr
instance Typeable1 Floatings
instance Typeable1 Fractionals
instance Typeable1 Nums
instance Typeable Sym
instance (Data a, Data b, Floating a) => Data (GExpr a b)
instance (Data a, Floating a) => Data (Expr a)
instance Data a => Data (Floatings a)
instance Data a => Data (Fractionals a)
instance Data a => Data (Nums a)
instance Data Sym
instance Eq Sym
instance Ord Sym
instance Ord a => Ord (Nums a)
instance Eq a => Eq (Fractionals a)
instance Ord a => Ord (Fractionals a)
instance Eq a => Eq (Floatings a)
instance Ord a => Ord (Floatings a)
instance MuRef (Expr a)
instance (Hashable a, Hashable b) => Hashable (GExpr a b)
instance (Show a, Show b) => Show (GExpr a b)
instance (Floating a, Ord a) => Floating (Expr a)
instance (Fractional a, Ord a) => Fractional (Expr a)
instance (Num a, Ord a) => Num (Expr a)
instance Hashable a => Hashable (Expr a)
instance Hashable a => Hashable (Floatings a)
instance Hashable a => Hashable (Fractionals a)
instance Hashable a => Hashable (Nums a)
instance Hashable Sym
instance Eq a => Eq (Nums a)
instance Eq a => Eq (Expr a)
instance Show a => Show (Expr a)
instance Show a => Show (Floatings a)
instance Show a => Show (Fractionals a)
instance Show a => Show (Nums a)
instance Show Sym

module Dvda.FunGraph
data FunGraph a
class ToFunGraph a where type family NumT a
data (:*) a b
(:*) :: a -> b -> :* a b
data MVS a
Mat :: [[a]] -> MVS a
Vec :: [a] -> MVS a
Sca :: a -> MVS a

-- | Take inputs and outputs which are of classes ToFunGraph (heterogenous
--   lists of <tt>Expr a</tt>) and traverse the outputs reifying all
--   expressions and creating a hashmap of StableNames (stable pointers).
--   Once the hashmap is created, lookup the provided inputs and return a
--   FunGraph which contains an expression graph, input/output indices, and
--   other useful functions. StableNames is non-deterministic so this
--   function may return graphs with more or fewer CSE's eliminated. If CSE
--   is then performed on the graph, the result is deterministic.
toFunGraph :: (Eq a, Hashable a, Show a, ToFunGraph b, ToFunGraph c, NumT b ~ a, NumT c ~ a) => b -> c -> IO (FunGraph a)
countNodes :: FunGraph a -> Int
fgInputs :: FunGraph a -> [MVS (GExpr a Int)]
fgOutputs :: FunGraph a -> [MVS Int]
fgLookupGExpr :: FunGraph a -> Int -> Maybe (GExpr a Int)
fgReified :: FunGraph a -> [(Int, GExpr a Int)]
topSort :: FunGraph a -> [Int]
nodelistToFunGraph :: [(Int, GExpr a Int)] -> [MVS (GExpr a Int)] -> [MVS Int] -> FunGraph a

-- | make a FunGraph out of outputs, automatically detecting the proper
--   inputs
exprsToFunGraph :: (Eq a, Show a, Hashable a) => [Expr a] -> IO (FunGraph a)
instance Show a => Show (MVS a)
instance (Show a, Show b) => Show (a :* b)
instance (ToFunGraph a, ToFunGraph b, NumT a ~ NumT b) => ToFunGraph (a :* b)
instance ToFunGraph [[Expr a]]
instance ToFunGraph [Expr a]
instance ToFunGraph (Expr a)
instance Traversable MVS
instance Foldable MVS
instance Functor MVS
instance Show a => Show (FunGraph a)

module Dvda.Vis

-- | show a nice Dot graph
previewGraph :: (Ord a, Show a) => FunGraph a -> IO ()

-- | show a nice Dot graph with labeled edges
previewGraph' :: (Ord a, Show a) => FunGraph a -> IO ()
instance Show a => Labellable (FGLNode a)
instance Show a => Labellable (FGLEdge' a)
instance Labellable (FGLEdge a)
instance Ord a => Ord (FGLEdge' a)
instance Ord a => Ord (FGLEdge a)
instance Eq a => Eq (FGLEdge' a)
instance Eq a => Eq (FGLEdge a)

module Dvda.CGen

-- | Turns a FunGraph into a string containing C code
showC :: (Eq a, Show a, Hashable a) => MatrixStorageOrder -> String -> FunGraph a -> String
showMex :: (Eq a, Show a, Hashable a) => String -> FunGraph a -> String
data MatrixStorageOrder
RowMajor :: MatrixStorageOrder
ColMajor :: MatrixStorageOrder

module Dvda.MultipleShooting.CoctaveTemplates
writeMexAll :: String -> String
writeSetupSource :: Show a => String -> [Expr a] -> [a] -> [a] -> String
writeUnstructConsts :: Eq a => String -> [Expr a] -> String
writeToStruct :: (Eq a, Show a, Hashable a) => String -> [Expr a] -> [Expr a] -> [Expr a] -> HashMap String [Expr a] -> String
writeUnstruct :: (Eq a, Show a) => String -> [Expr a] -> [Expr a] -> [Expr a] -> [[Expr a]] -> [Expr a] -> [[Expr a]] -> String
writePlot :: String -> HashMap String [Expr a] -> String

module Dvda.MultipleShooting.Types
data Step a
Step :: Maybe [Expr a] -> Maybe [Expr a] -> HashSet (Expr a) -> HashSet (Expr a) -> Maybe [Expr a] -> Maybe (Expr a, (a, a)) -> Maybe (Expr a) -> Maybe (Expr a) -> [(Expr a, (a, a, BCTime))] -> [Constraint (Expr a)] -> HashMap String (Expr a) -> HashSet (Expr a) -> Step a
stepStates :: Step a -> Maybe [Expr a]
stepActions :: Step a -> Maybe [Expr a]
stepParams :: Step a -> HashSet (Expr a)
stepConstants :: Step a -> HashSet (Expr a)
stepDxdt :: Step a -> Maybe [Expr a]
stepLagrangeTerm :: Step a -> Maybe (Expr a, (a, a))
stepMayerTerm :: Step a -> Maybe (Expr a)
stepDt :: Step a -> Maybe (Expr a)
stepBounds :: Step a -> [(Expr a, (a, a, BCTime))]
stepConstraints :: Step a -> [Constraint (Expr a)]
stepOutputs :: Step a -> HashMap String (Expr a)
stepPeriodic :: Step a -> HashSet (Expr a)
data Constraint a
Constraint :: a -> Ordering -> a -> Constraint a
data Ode a
Ode :: (SparseVec (Expr a) -> SparseVec (Expr a) -> SparseVec (Expr a)) -> (Int, Int) -> Ode a
data BCTime
ALWAYS :: BCTime
TIMESTEP :: Int -> BCTime
eulerError :: Fractional (Expr a) => SparseVec (Expr a) -> SparseVec (Expr a) -> SparseVec (Expr a) -> SparseVec (Expr a) -> Ode a -> Expr a -> SparseVec (Expr a)
simpsonsRuleError :: Fractional (Expr a) => SparseVec (Expr a) -> SparseVec (Expr a) -> SparseVec (Expr a) -> SparseVec (Expr a) -> Ode a -> Expr a -> SparseVec (Expr a)
eulerError' :: Fractional (Expr a) => [Expr a] -> [Expr a] -> [Expr a] -> [Expr a] -> ([Expr a] -> [Expr a] -> [Expr a]) -> Expr a -> [Expr a]
simpsonsRuleError' :: Fractional (Expr a) => [Expr a] -> [Expr a] -> [Expr a] -> [Expr a] -> ([Expr a] -> [Expr a] -> [Expr a]) -> Expr a -> [Expr a]
instance Show BCTime
instance Eq BCTime
instance Show a => Show (Constraint a)
instance Functor Constraint

module Dvda.MultipleShooting.MSMonad

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity
setStates :: [String] -> State (Step a) [Expr a]
setActions :: [String] -> State (Step a) [Expr a]
addParam :: (Eq a, Hashable a) => String -> State (Step a) (Expr a)
addParams :: (Eq a, Hashable a) => [String] -> State (Step a) [Expr a]
addConstant :: (Eq a, Hashable a) => String -> State (Step a) (Expr a)
addConstants :: (Eq a, Hashable a) => [String] -> State (Step a) [Expr a]
setDxdt :: [Expr a] -> State (Step a) ()
setLagrangeTerm :: Expr a -> (a, a) -> State (Step a) ()
setMayerTerm :: Expr a -> State (Step a) ()
setDt :: Expr a -> State (Step a) ()
addOutput :: Expr a -> String -> State (Step a) ()
setPeriodic :: (Eq a, Hashable a, Show a) => Expr a -> State (Step a) ()
addConstraint :: Expr a -> Ordering -> Expr a -> State (Step a) ()
setBound :: (Show a, Eq a, Hashable a) => Expr a -> (a, a) -> BCTime -> State (Step a) ()
lagrangeStateName, lagrangeTermName :: String

module Dvda.CSE
cse :: (Eq a, Hashable a) => FunGraph a -> FunGraph a

module Dvda.AD
backprop :: (Num a, Ord a, Hashable a) => Expr a -> HashMap (Expr a) (Expr a)
rad :: (Num a, Ord a, Hashable a) => Expr a -> [Expr a] -> [Expr a]

module Dvda.Examples

-- | do cse on a fungraph and count nodes
doCse :: IO ()

-- | show a fungraph
showFg :: IO ()

-- | c code generation
cgen :: IO ()

-- | mex function generation
mexgen :: IO ()

module Dvda.MultipleShooting.MSCoctave
msCoctave :: State (Step Double) b -> Integrator Double -> Int -> String -> FilePath -> IO ()
run :: IO ()


-- | This is the top level module which exports the API
module Dvda

-- | symbolic scalar
sym :: String -> Expr a

-- | Symbolic scalar which is a function of some independent variable, like
--   time. . This lets you do d(f(g(t)))/dt == f'(g(t))*g'(t)
symDependent :: String -> Expr a -> Expr a

-- | same as symDependent but it can start as the Nth derivative
symDependentN :: String -> Expr a -> Int -> Expr a
rad :: (Num a, Ord a, Hashable a) => Expr a -> [Expr a] -> [Expr a]
data Expr a

-- | Take inputs and outputs which are of classes ToFunGraph (heterogenous
--   lists of <tt>Expr a</tt>) and traverse the outputs reifying all
--   expressions and creating a hashmap of StableNames (stable pointers).
--   Once the hashmap is created, lookup the provided inputs and return a
--   FunGraph which contains an expression graph, input/output indices, and
--   other useful functions. StableNames is non-deterministic so this
--   function may return graphs with more or fewer CSE's eliminated. If CSE
--   is then performed on the graph, the result is deterministic.
toFunGraph :: (Eq a, Hashable a, Show a, ToFunGraph b, ToFunGraph c, NumT b ~ a, NumT c ~ a) => b -> c -> IO (FunGraph a)
cse :: (Eq a, Hashable a) => FunGraph a -> FunGraph a

-- | show a nice Dot graph
previewGraph :: (Ord a, Show a) => FunGraph a -> IO ()

-- | show a nice Dot graph with labeled edges
previewGraph' :: (Ord a, Show a) => FunGraph a -> IO ()
data (:*) a b
(:*) :: a -> b -> :* a b
