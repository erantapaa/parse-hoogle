-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Concurrent Chans as read/write pairs. Also provides generic
Chan pair class.
--   
--   An implementation of concurrent channels identical to
--   Control.Concurrent.Chan, except that the channel is represented as a
--   pair, one of which allows only read operations, the other write
--   operations.
--   
--   This makes code easier to reason about (the types strictly delegate
--   read/write permission), suggests useful instances (e.g. <a>Functor</a>
--   and <a>Contravariant</a> are easily defined) on the chan pairs, and
--   simplifies the API.
--   
--   Furthermore this allows messages sent to channels with no readers to
--   be trivially garbage-collected, without relying on inlining
--   optimizations.
--   
--   We also provide a module that defines a class <a>SplitChan</a> which
--   defines the basic methods any pair of Chan types should provide,
--   allowing easy swapping of Chan implementations.
--   
--   To use standard Chans with these polymorphic functions, import as
--   follows:
--   
--   <pre>
--   import Control.Concurrent.Chan hiding (readChan,writeChan,writeList2Chan)
--   import Control.Concurrent.Chan.Class
--   </pre>
--   
--   When used alongside standard Chans, the Split module can be imported
--   qualified like:
--   
--   <pre>
--   import qualified Control.Concurrent.Chan.Split as S
--   </pre>
--   
--   Its interface is mostly backwards compatible with Chan. Note, we do
--   not implement the deprecated unGetChan and isEmptyChan functions.
--   
--   This module is used internally by the <a>simple-actors</a> package.
--   
--   <i>CHANGES</i>: 0.4.0 -&gt; 0.5.0
--   
--   <ul>
--   <li>modify TChan v2.4 code into split version</li>
--   <li>depend on STM</li>
--   <li>clean up Extensions section and broken links</li>
--   </ul>
@package chan-split
@version 0.5.0

module Control.Concurrent.STM.TChan.Class

-- | A class capturing Chan operations in STM.
class SplitTChan i o | i -> o, o -> i
writeTChan :: SplitTChan i o => i a -> a -> STM ()
readTChan :: SplitTChan i o => o a -> STM a
peekTChan :: SplitTChan i o => o a -> STM a
tryPeekTChan :: SplitTChan i o => o a -> STM (Maybe a)
tryReadTChan :: SplitTChan i o => o a -> STM (Maybe a)
isEmptyTChan :: SplitTChan i o => o a -> STM Bool

-- | A class for <a>SplitTChan</a> types that can be instantiated without
--   programmer input. <i>e.g.</i> the standard haskell <tt>TChan</tt> is a
--   member of this class, however a bounded chan type that took an
--   <tt>Int</tt> to define the buffer size would not.
class SplitTChan i o => NewSplitTChan i o
newSplitTChan :: NewSplitTChan i o => STM (i a, o a)
instance NewSplitTChan TChan TChan
instance NewSplitTChan TMVar TMVar
instance SplitTChan TChan TChan
instance SplitTChan TMVar TMVar

module Control.Concurrent.STM.TChan.Split

-- | The input side of an unbounded FIFO channel.
data InTChan a

-- | The output side of an unbounded FIFO channel.
data OutTChan a

-- | Create a new write end of a TChan. Use <a>dupTChan</a> to get an
--   <tt>OutChan</tt> that values can be read from.
newInTChan :: STM (InTChan a)

-- | <tt>IO</tt> version of <tt>newTChan</tt>. This is useful for creating
--   top-level <tt>TChan</tt>s using <a>unsafePerformIO</a>, because using
--   <a>atomically</a> inside <a>unsafePerformIO</a> isn't possible.
newSplitTChanIO :: IO (OutTChan a, InTChan a)

-- | <tt>IO</tt> version of <a>newInTChan</a>.
newInTChanIO :: IO (InTChan a)

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTChan :: OutTChan a -> a -> STM ()

-- | Create a duplicate <tt>OutChan</tt> from an <tt>InChan</tt>. The
--   <tt>OutChan</tt> starts empty but will receive a copy of all
--   subsequent values written.
dupTChan :: InTChan a -> STM (OutTChan a)

-- | Clone a <tt>TChan</tt>: similar to dupTChan, but the cloned channel
--   starts with the same content available as the original channel.
cloneTChan :: OutTChan a -> STM (OutTChan a)
instance Typeable1 OutTChan
instance Typeable1 InTChan
instance Eq (OutTChan a)
instance Eq (InTChan a)
instance SplitTChan InTChan OutTChan
instance NewSplitTChan InTChan OutTChan

module Control.Concurrent.Chan.Class

-- | A class for chan types with a "write end" and a "read end". A minimal
--   complete instance defines <a>readChan</a> and one of <a>writeChan</a>
--   or <a>writeList2Chan</a>.
class SplitChan i o | i -> o, o -> i where writeList2Chan = mapM_ . writeChan writeChan c = writeList2Chan c . return
readChan :: SplitChan i o => o a -> IO a
writeList2Chan :: SplitChan i o => i a -> [a] -> IO ()
writeChan :: SplitChan i o => i a -> a -> IO ()

-- | A class for <a>SplitChan</a> types that can be instantiated without
--   programmer input. <i>e.g.</i> the standard haskell <tt>Chan</tt> is a
--   member of this class, however a bounded chan type that took an
--   <tt>Int</tt> to define the buffer size would not.
class SplitChan i o => NewSplitChan i o
newSplitChan :: NewSplitChan i o => IO (i a, o a)
instance NewSplitChan MVar MVar
instance SplitChan MVar MVar
instance NewSplitChan Chan Chan
instance SplitChan Chan Chan

module Control.Concurrent.Chan.Split

-- | The "write side" of a chan pair
data InChan i

-- | The "read side" of a chan pair
data OutChan i

-- | Return a lazy list representing the contents of the supplied OutChan,
--   much like System.IO.hGetContents.
getChanContents :: OutChan a -> IO [a]

-- | Duplicate an <a>OutChan</a>: the duplicate channel contains any unread
--   messages in the original (n.b. this differs from the behavior of
--   dupChan in Chan), and data written to the corresponding <a>InChan</a>
--   will appear in both, i.e. consuming a value from the copy will have no
--   affect on the values in the original OutChan.
--   
--   (Note that a duplicated channel is not equal to its original. So:
--   <tt>fmap (c /=) $ dupChan c</tt> returns <tt>True</tt> for all
--   <tt>c</tt>.)
dupChan :: OutChan a -> IO (OutChan a)
instance Typeable1 InChan
instance Typeable1 OutChan
instance Eq (InChan i)
instance Eq (OutChan i)
instance SplitChan InChan OutChan
instance NewSplitChan InChan OutChan
