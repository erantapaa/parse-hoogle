-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generator-generator for QuickCheck
--   
--   Agata (Agata Generates Algebraic Types Automatically) uses Template
--   Haskell to derive QuickCheck generators for Haskell data types.
@package Agata
@version 0.2.1.1

module Test.Agata.Common
type Dimension a = Tagged a Int
taggedWith :: Tagged b a -> b -> Tagged b a
type Improving a = StateT (Int, Int, [Int]) Gen a
currentDimension :: Improving (Dimension a)
request :: Improving ()
acquire :: Improving Int
piles :: (Integral a, Integral a1, Random a) => a1 -> a -> Gen [a]
permute :: [a] -> Gen [a]

module Test.Agata.Strategies
type Strategy a = Int -> Dimension a -> Gen (Improving ())
listStrategy :: (Int -> Dimension a -> Gen [Int]) -> Strategy a
linearSize :: Strategy a
linearSize' :: Strategy a
quadraticSize :: Strategy a
quadraticSize' :: Strategy a
partitions :: Strategy a
exponentialSize :: Strategy a
fixedSize :: Strategy a
randomStrategy :: [Strategy a] -> Strategy a

module Test.Agata.Base
agata :: Buildable a => Gen a
agataWith :: Buildable a => Strategy a -> Gen a
agataSC :: Buildable a => Int -> [a]
agataEnum :: Buildable a => Int -> (Integer, [a])
class Buildable a where improve = return dimension = autoDim
build :: Buildable a => [Builder a]
improve :: Buildable a => a -> Improving a
dimension :: Buildable a => Dimension a
data Builder a
rebuild :: a -> (a -> Improving b) -> Improving b
rb :: Buildable a => a -> (a -> b) -> Improving b

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
(*>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
($>) :: a -> (Application b a -> Application b b) -> [Builder b]
(.>) :: (a -> b) -> (b -> c) -> a -> c
graft :: Gen a -> (Int -> (Integer, [a])) -> [Builder a]
inline :: Buildable a => (a -> b) -> [Builder b]
automutrec :: Buildable a => Application c (a -> b) -> Application c b
use :: a -> [Builder a]
construct :: a -> (Application b a -> Application b b) -> Builder b
autorec :: Buildable a => Application c (a -> b) -> Application c b
nonrec :: Buildable a => Application c (a -> b) -> Application c b
mutrec :: Buildable a => Application c (a -> b) -> Application c b
rec :: Buildable c => Application c (c -> b) -> Application c b
instance Show (Recursivity a)
instance Eq (Recursivity a)
instance Show (DB a)
instance Show (Builder a)

module Test.Agata.Instances
instance (Buildable a, Buildable b, Buildable c, Buildable d, Buildable e, Buildable f, Buildable g, Buildable h, Buildable i, Buildable j) => Buildable (a, b, c, d, e, f, g, h, i, j)
instance (Buildable a, Buildable b, Buildable c, Buildable d, Buildable e, Buildable f, Buildable g, Buildable h, Buildable i) => Buildable (a, b, c, d, e, f, g, h, i)
instance (Buildable a, Buildable b, Buildable c, Buildable d, Buildable e, Buildable f, Buildable g, Buildable h) => Buildable (a, b, c, d, e, f, g, h)
instance (Buildable a, Buildable b, Buildable c, Buildable d, Buildable e, Buildable f, Buildable g) => Buildable (a, b, c, d, e, f, g)
instance (Buildable a, Buildable b, Buildable c, Buildable d, Buildable e, Buildable f) => Buildable (a, b, c, d, e, f)
instance (Buildable a, Buildable b, Buildable c, Buildable d, Buildable e) => Buildable (a, b, c, d, e)
instance (Buildable a, Buildable b, Buildable c, Buildable d) => Buildable (a, b, c, d)
instance (Buildable a, Buildable b, Buildable c) => Buildable (a, b, c)
instance (Buildable a, Buildable b) => Buildable (a, b)
instance Buildable Int
instance Buildable Char
instance Buildable Bool
instance Buildable ()
instance Buildable a => Buildable [a]
instance (Buildable a, Buildable b) => Buildable (Either a b)
instance Buildable a => Buildable (Maybe a)

module Test.Agata

module Test.AgataTH
agatath :: Derivation -> Q [Dec]
derive :: Name -> Derivation
deriveall :: [Name] -> Derivation
data DerivOption
Inline :: Name -> DerivOption
NoArbitrary :: DerivOption
(<++>) :: Derivation -> DerivOption -> Derivation
echoAgata :: String -> Name -> Q [Dec]
instance Show DerivOption
instance Eq DerivOption
instance Ord DerivOption
instance Eq Recu
instance Show Recu
