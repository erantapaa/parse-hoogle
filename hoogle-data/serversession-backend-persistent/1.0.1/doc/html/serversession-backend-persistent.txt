-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Storage backend for serversession using persistent and an RDBMS.
--   
@package serversession-backend-persistent
@version 1.0.1


-- | Internal module exposing the guts of the package. Use at your own
--   risk. No API stability guarantees apply.
--   
--   Also exports orphan instances of <tt>PersistField{,Sql}
--   SessionId</tt>.
module Web.ServerSession.Backend.Persistent.Internal.Types

-- | Newtype of a <a>ByteString</a> with JSON support via base64url.
newtype ByteStringJ
B :: ByteString -> ByteStringJ
unB :: ByteStringJ -> ByteString
instance Typeable ByteStringJ
instance Eq ByteStringJ
instance Ord ByteStringJ
instance Show ByteStringJ
instance Read ByteStringJ
instance ToJSON SessionMap
instance FromJSON SessionMap
instance Serialize SessionMap
instance PersistFieldSql SessionMap
instance PersistField SessionMap
instance ToJSON ByteStringJ
instance FromJSON ByteStringJ
instance PersistFieldSql ByteStringJ
instance PersistField ByteStringJ
instance PersistFieldSql (SessionId sess)
instance PersistField (SessionId sess)


-- | Internal module exposing the guts of the package. Use at your own
--   risk. No API stability guarantees apply.
module Web.ServerSession.Backend.Persistent.Internal.Impl

-- | Entity corresponding to a <a>Session</a>.
--   
--   We're bending <tt>persistent</tt> in ways it wasn't expected to. In
--   particular, this entity is parametrized over the session type.
data PersistentSession sess
PersistentSession :: !(SessionId sess) -> !(Maybe ByteStringJ) -> !(Decomposed sess) -> !UTCTime -> !UTCTime -> PersistentSession sess

-- | Session ID, primary key.
persistentSessionKey :: PersistentSession sess -> !(SessionId sess)

-- | Value of "_ID" session key.
persistentSessionAuthId :: PersistentSession sess -> !(Maybe ByteStringJ)

-- | Rest of the session data.
persistentSessionSession :: PersistentSession sess -> !(Decomposed sess)

-- | When this session was created.
persistentSessionCreatedAt :: PersistentSession sess -> !UTCTime

-- | When this session was last accessed.
persistentSessionAccessedAt :: PersistentSession sess -> !UTCTime
type PersistentSessionId sess = Key (PersistentSession sess)

-- | An <a>EntityField</a> is parameterised by the Haskell record it
--   belongs to and the additional type of that field

-- | Entity definitions needed to generate the SQL schema for
--   <a>SqlStorage</a>. Example using <a>SessionMap</a>:
--   
--   <pre>
--   serverSessionDefs (Proxy :: Proxy SessionMap)
--   </pre>
serverSessionDefs :: PersistEntity (PersistentSession sess) => Proxy sess -> [EntityDef]

-- | Generate a key to the entity from the session ID.
psKey :: SessionId sess -> Key (PersistentSession sess)

-- | Convert from <a>Session</a> to <a>PersistentSession</a>.
toPersistentSession :: Session sess -> PersistentSession sess

-- | Convert from <a>PersistentSession</a> to <a>Session</a>.
fromPersistentSession :: PersistentSession sess -> Session sess

-- | SQL session storage backend using <tt>persistent</tt>.
newtype SqlStorage sess
SqlStorage :: ConnectionPool -> SqlStorage sess

-- | Pool of DB connections. You may use the same pool as your application.
connPool :: SqlStorage sess -> ConnectionPool

-- | Specialization of <a>throwIO</a> for <a>SqlStorage</a>.
throwSS :: Storage (SqlStorage sess) => StorageException (SqlStorage sess) -> TransactionM (SqlStorage sess) a
instance Typeable PersistentSession
instance Typeable SqlStorage
instance Show (Decomposed sess) => Show (PersistentSession sess)
instance Ord (Decomposed sess) => Ord (PersistentSession sess)
instance Eq (Decomposed sess) => Eq (PersistentSession sess)
instance Eq (Key (PersistentSession sess))
instance Ord (Key (PersistentSession sess))
instance Show (Key (PersistentSession sess))
instance Read (Key (PersistentSession sess))
instance PathPiece (Key (PersistentSession sess))
instance PersistField (Key (PersistentSession sess))
instance PersistFieldSql (Key (PersistentSession sess))
instance ToJSON (Key (PersistentSession sess))
instance FromJSON (Key (PersistentSession sess))
instance (IsSessionData sess, PersistFieldSql (Decomposed sess)) => Storage (SqlStorage sess)
instance (FromJSON (Decomposed sess), PersistFieldSql (Decomposed sess)) => FromJSON (Entity (PersistentSession sess))
instance (ToJSON (Decomposed sess), PersistFieldSql (Decomposed sess)) => ToJSON (Entity (PersistentSession sess))
instance FromJSON (Decomposed sess) => FromJSON (PersistentSession sess)
instance ToJSON (Decomposed sess) => ToJSON (PersistentSession sess)
instance PersistFieldSql (Decomposed sess) => PersistEntity (PersistentSession sess)


-- | Storage backend for <tt>serversession</tt> using persistent.
--   
--   In order to use this backend, you have to include
--   <a>serverSessionDefs</a> on your migration code. For example, the
--   Yesod scaffold usually includes the following code:
--   
--   <pre>
--   -- On Model.hs
--   share [mkPersist sqlSettings, mkMigrate "migrateAll"]
--   
--   -- On Application.hs
--   makeFoundation =
--       ...
--       runLoggingT (runSqlPool (runMigration migrateAll) pool) logFunc
--       ...
--   </pre>
--   
--   You should changed those lines to:
--   
--   <pre>
--   -- On Model.hs
--   share [mkPersist sqlSettings, mkSave "entityDefs"]
--   
--   -- On Application.hs
--   import qualified Data.Proxy as P -- tagged package, or base from GHC 7.10 onwards
--   import qualified Web.ServerSession.Core as SS
--   import qualified Web.ServerSession.Backend.Persistent as SS
--   
--   mkMigrate "migrateAll" (SS.serverSessionDefs (P.Proxy :: P.Proxy SS.SessionMap) ++ entityDefs)
--   
--   makeFoundation =
--       ...
--       runLoggingT (runSqlPool (runMigration migrateAll) pool) logFunc
--       ...
--   </pre>
--   
--   If you're not using <tt>SessionMap</tt>, just change <tt>Proxy</tt>
--   type above.
--   
--   If you forget to setup the migration above, this session storage
--   backend will fail at runtime as the required table will not exist.
module Web.ServerSession.Backend.Persistent

-- | SQL session storage backend using <tt>persistent</tt>.
newtype SqlStorage sess
SqlStorage :: ConnectionPool -> SqlStorage sess

-- | Pool of DB connections. You may use the same pool as your application.
connPool :: SqlStorage sess -> ConnectionPool

-- | Entity definitions needed to generate the SQL schema for
--   <a>SqlStorage</a>. Example using <a>SessionMap</a>:
--   
--   <pre>
--   serverSessionDefs (Proxy :: Proxy SessionMap)
--   </pre>
serverSessionDefs :: PersistEntity (PersistentSession sess) => Proxy sess -> [EntityDef]
