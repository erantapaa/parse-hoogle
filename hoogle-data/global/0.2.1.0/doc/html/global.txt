-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library enabling unique top-level declarations
--   
@package global
@version 0.2.1.0

module Data.Global

-- | Types that can be uniquely declared on the top level.
--   
--   Like <a>Monad</a>, this type class itself is not "magical". Its
--   instances, however, may be primitive, at least conceptually, much like
--   <a>IO</a>s <a>Monad</a> instance.
--   
--   Individual instances may be accompanied with certain caveats. Each
--   individual instance should include in its documentation what these
--   are. These caveats may affect surrounding code, perhaps in ways
--   detrimental to the program's performance or efficiency; users should
--   thus consider isolating "global" declarations in their own
--   <tt>.Global</tt> module; this is not necessarily necessary for every
--   instance. See the documentation of the particular instance to see how
--   the declarations should be declared.
--   
--   The type should be monomorphic, or concrete enough, to be type safe,
--   so that the references cannot be treated as multiple concreet types
--   (writing <tt>[Integer]</tt> to a reference that has the type <tt>IORef
--   [a]</tt> and subsequently reading <tt>[Char]</tt> can cause the
--   program to core dump). Ensuring this safety is the responsibility of
--   the implementer of the instances of this type class; other users of
--   this library who do not extend this class's functionality generally do
--   not need to be concerned whether the program will run correctly at
--   run-time, since the mistakes, which can violate type safety, will be
--   caught at compile-time and the code will not build (this is, however,
--   not intrinsically guaranteed, much like the monad laws: they are
--   expected to be followed). It is worth reiterating that instances of
--   this class need to be sure to not allow code with such erroneous types
--   to compile. For more information about type safety, see the
--   documentation of <a>unsafePerformIO</a>.
--   
--   Example:
--   
--   <pre>
--   un "lives" =:: ([| 3 |], ut [t| Integer |] :: UT TVar)
--   </pre>
--   
--   <tt>lives</tt> would then refer to the <a>TVar</a> and would initially
--   contain the value <tt>3</tt>.
class UniqueDeclaration u
(=::) :: UniqueDeclaration u => UN u -> (UV, UT u) -> Q [Dec]

-- | Identity type wrapper that indicates that the unique declaration
--   should be "empty" by default.
newtype UDEmpty u a
UDEmpty :: u a -> UDEmpty u a
unUDEmpty :: UDEmpty u a -> u a

-- | Tagged name type.
type UN u = Tagged (Cnt u) Name

-- | Construct a name for a unique declaration from a string.
un :: UniqueDeclaration u => String -> UN u

-- | Tagged unique declaration type.
type UT c = Tagged (Cnt c) TypeQ

-- | Tagged unique declaration type constructor.
ut :: UniqueDeclaration c => TypeQ -> UT c

-- | Transform a container with kind <tt>* -&gt; *</tt> into a concrete
--   type <tt>*</tt> by applying the type '()' to the constructor.
--   
--   Intended to be used for tagging types for unique declarations.
type Cnt c = c ()

-- | An expression for a value contained in a unique declaration.
type UV = ExpQ

-- | Determine whether a type is polymorphic.
monomorphic :: Type -> Bool

-- | The type of values that supply an initial quantity for quantity
--   semaphores.
type QSemQuantity = Int

-- | Translate an <a>Exts</a> AST to a Template Haskell AST, failing when
--   the translation result is not a Template Haskell AST.
--   
--   This is defined in terms of <a>translateExtsToTH</a>
translateExtsToTH' :: Exp -> Exp

-- | Apply translateExtsToTH' and lift the result into the <a>Q</a> monad.
--   
--   This is often used with <a>ud</a> to refer to variables whose names
--   are not required to be in scope when the quotation is expanded, in a
--   very roundabout way.
--   
--   "utl" can be thought of as a mnemonic for "unique", "translate" and
--   "lift"; and will be updated appropriately to reflect changes to
--   <a>UV</a>.
--   
--   For example, to enable self-referential recursion by referring to
--   variables whose names are not yet in scope, an expression quotation
--   <tt>[| … |]</tt> can usually be written as <tt>utl [ud| … |]</tt>.
utl :: Exp -> UV

-- | Alias to the <a>QuasiQuoter</a> <a>hs</a>, which does not require
--   names to be in scope when the quotation is expanded, which enables
--   self-referential recursion.
ud :: QuasiQuoter

-- | An alternative to providing an initial value.
--   
--   Warning: attempting to read uninitialized references can cause the
--   program to crash.
uninitialized :: Q Exp
instance Typeable UDEmpty
instance Eq (u a) => Eq (UDEmpty u a)
instance Ord (u a) => Ord (UDEmpty u a)
instance Show (u a) => Show (UDEmpty u a)
instance Read (u a) => Read (UDEmpty u a)
instance (Data (u a), Typeable u, Typeable a) => Data (UDEmpty u a)
instance UniqueDeclaration (UDEmpty TChan)
instance UniqueDeclaration (UDEmpty TMVar)
instance UniqueDeclaration TMVar
instance UniqueDeclaration TVar
instance UniqueDeclaration MSemN
instance UniqueDeclaration MSem
instance UniqueDeclaration (UDEmpty MSampleVar)
instance UniqueDeclaration MSampleVar
instance UniqueDeclaration (Const RWLock)
instance UniqueDeclaration (Const QSemN)
instance UniqueDeclaration (Const QSem)
instance UniqueDeclaration (UDEmpty Chan)
instance UniqueDeclaration (UDEmpty MVar)
instance UniqueDeclaration MVar
instance UniqueDeclaration IORef
