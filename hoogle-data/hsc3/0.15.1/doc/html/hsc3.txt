-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell SuperCollider
--   
@package hsc3
@version 0.15.1


-- | Multiple channel expansion.
module Sound.SC3.UGen.MCE

-- | Multiple channel expansion.
data MCE n
MCE_Unit :: n -> MCE n
MCE_Vector :: [n] -> MCE n
mce_elem :: MCE t -> [t]

-- | Extend <a>MCE</a> to specified degree.
mce_extend :: Int -> MCE n -> MCE n
mce_map :: (a -> b) -> MCE a -> MCE b
mce_binop :: (a -> b -> c) -> MCE a -> MCE b -> MCE c
instance Eq n => Eq (MCE n)
instance Show n => Show (MCE n)
instance Fractional n => Fractional (MCE n)
instance Num n => Num (MCE n)


-- | Interpolation functions for envelope segments.
module Sound.SC3.UGen.Envelope.Interpolate

-- | An interpolation function take three arguments. <i>x0</i> is the left
--   or begin value, <i>x1</i> is the right or end value, and <i>t</i> is a
--   (0,1) index.
type Interpolation_F t = t -> t -> t -> t

-- | Step function, ignores <i>t</i> and returns <i>x1</i>.
step :: Interpolation_F t

-- | Linear interpolation.
linear :: Num t => Interpolation_F t

-- | Exponential interpolation, <i>x0</i> must not be <tt>0</tt>,
--   (<i>x0</i>,<i>x1</i>) must not span <tt>0</tt>.
--   
--   <pre>
--   import Sound.SC3.Plot
--   plotTable1 (map (exponential 0.001 1) [0,0.01 .. 1])
--   </pre>
exponential :: Floating t => Interpolation_F t

-- | Variant that allows <i>x0</i> to be <tt>0</tt>, though
--   (<i>x0</i>,<i>x1</i>) must not span <tt>0</tt>.
--   
--   <pre>
--   plotTable1 (map (exponential' 0 1) [0,0.01 .. 1])
--   plotTable1 (map (exponential' 0 (-1)) [0,0.01 .. 1])
--   </pre>
exponential' :: (Eq t, Floating t) => Interpolation_F t

-- | <a>linear</a> of <a>exponential'</a>, ie. allows (<i>x0</i>,<i>x1</i>)
--   to span <tt>0</tt>.
--   
--   <pre>
--   plotTable1 (map (exponential'' (-1) 1) [0,0.01 .. 1])
--   </pre>
exponential'' :: (Eq t, Floating t) => Interpolation_F t

-- | <a>linear</a> with <i>t</i> transformed by sine function over
--   (-pi<i>2,pi</i>2).
--   
--   <pre>
--   plotTable1 (map (sine (-1) 1) [0,0.01 .. 1])
--   </pre>
sine :: Floating t => Interpolation_F t
half_pi :: Floating a => a

-- | If <i>x0</i> <a>&lt;</a> <i>x1</i> rising sine segment (0,pi/2), else
--   falling segment (pi/2,pi).
--   
--   <pre>
--   plotTable1 (map (welch (-1) 1) [0,0.01 .. 1])
--   plotTable1 (map (welch 1 (-1)) [0,0.01 .. 1])
--   </pre>
welch :: (Ord t, Floating t) => Interpolation_F t

-- | Curvature controlled by single parameter <i>c</i>. <tt>0</tt> is
--   <a>linear</a>, increasing <i>c</i> approaches <a>exponential</a>.
--   
--   <pre>
--   plotTable1 (map (curve 0 (-1) 1) [0,0.01 .. 1])
--   plotTable1 (map (curve 9 (-1) 1) [0,0.01 .. 1])
--   </pre>
curve :: (Ord t, Floating t) => t -> Interpolation_F t

-- | Square of <a>linear</a> of <a>sqrt</a> of <i>x0</i> and <i>x1</i>,
--   threfore neither may be negative.
--   
--   <pre>
--   plotTable1 (map (squared 0 1) [0,0.01 .. 1])
--   </pre>
squared :: Floating t => Interpolation_F t

-- | Cubic variant of <a>squared</a>.
--   
--   <pre>
--   plotTable1 (map (cubed 0 1) [0,0.01 .. 1])
--   </pre>
cubed :: Floating t => Interpolation_F t

-- | x0 until end, then immediately x1.
hold :: (Num t, Eq t) => Interpolation_F t


-- | Reader for LPC analysis data files.
module Sound.SC3.UGen.Bindings.HW.External.LPC

-- | LPC analysis data.
data LPC
LPC :: LPCHeader -> [LPCFrame] -> LPC
lpcHeader :: LPC -> LPCHeader
lpcFrames :: LPC -> [LPCFrame]

-- | LPC analysis meta-data.
data LPCHeader
LPCHeader :: Int -> Int -> Int -> Int -> Float -> Float -> Float -> Int -> LPCHeader
lpcHeaderSize :: LPCHeader -> Int
lpcMagic :: LPCHeader -> Int
lpcNPoles :: LPCHeader -> Int
lpcFrameSize :: LPCHeader -> Int
lpcFrameRate :: LPCHeader -> Float
lpcSampleRate :: LPCHeader -> Float
lpcAnalysisDuration :: LPCHeader -> Float
lpcNFrames :: LPCHeader -> Int

-- | LPC analysis frame data.
type LPCFrame = [Float]

-- | Read an lpanal format LPC data file.
lpcRead :: FilePath -> IO LPC

-- | Analysis data in format required by the sc3 LPC UGens.
lpcSC3 :: LPC -> [Float]
instance Eq LPCHeader
instance Show LPCHeader
instance Eq LPC
instance Show LPC


-- | Reader for ATS analyis data files.
module Sound.SC3.UGen.Bindings.HW.External.ATS

-- | ATS analysis data.
data ATS
ATS :: ATSHeader -> [Double] -> ATS
atsHeader :: ATS -> ATSHeader
atsData :: ATS -> [Double]

-- | ATS analysis meta-data.
data ATSHeader
ATSHeader :: Double -> Int -> Int -> Int -> Int -> Double -> Double -> Double -> Int -> Int -> ATSHeader
atsSampleRate :: ATSHeader -> Double
atsFrameSize :: ATSHeader -> Int
atsWindowSize :: ATSHeader -> Int
atsNPartials :: ATSHeader -> Int
atsNFrames :: ATSHeader -> Int
atsMaxAmplitude :: ATSHeader -> Double
atsMaxFrequency :: ATSHeader -> Double
atsAnalysisDuration :: ATSHeader -> Double
atsFileType :: ATSHeader -> Int
atsFrameLength :: ATSHeader -> Int

-- | ATS analysis frame data.
type ATSFrame = [Double]

-- | Extract set of <a>ATSFrame</a>s from <a>ATS</a>.
atsFrames :: ATS -> [ATSFrame]

-- | Read an ATS data file.
atsRead :: FilePath -> IO ATS
instance Eq ATSHeader
instance Show ATSHeader
instance Eq ATS
instance Show ATS


-- | Typeclass and functions to manage UGen identifiers.
module Sound.SC3.UGen.Identifier

-- | Typeclass to constrain UGen identifiers.
class Hashable a => ID a where resolveID = hash
resolveID :: ID a => a -> Int

-- | Hash <a>ID</a>s <i>p</i> and <i>q</i> and sum to form an <a>Int</a>.
--   
--   <pre>
--   'a' `joinID` (1::Int) == 1627429042
--   </pre>
joinID :: (ID a, ID b) => a -> b -> Int
instance ID Double
instance ID Float
instance ID Char
instance ID Integer
instance ID Int


-- | Functions to provide mediated access to the SC3 help system.
module Sound.SC3.UGen.Help

-- | Guarded variant of <a>getEnv</a> with default value.
get_env_default :: String -> String -> IO String

-- | <a>lookupEnv</a> with default value.
--   
--   <pre>
--   lookup_env_default "PATH" "/usr/bin"
--   </pre>
lookup_env_default :: String -> String -> IO String

-- | Read the environment variable <tt>SC3_HELP</tt>, the default value is
--   <tt>~/.local/share/SuperCollider/Help</tt>.
sc3HelpDirectory :: IO String

-- | Locate path to indicated SC3 class help file.
--   
--   <pre>
--   import System.FilePath
--   
--   d &lt;- sc3HelpDirectory
--   h &lt;- sc3HelpClassFile d "SinOsc"
--   h == Just (d &lt;/&gt; "Classes/SinOsc.html")
--   </pre>
sc3HelpClassFile :: FilePath -> String -> IO (Maybe FilePath)

-- | Generate path to indicated SC3 operator help file.
--   
--   <pre>
--   sc3HelpOperatorEntry "." "+" == "./Overviews/Operators.html#.+"
--   </pre>
sc3HelpOperatorEntry :: FilePath -> String -> FilePath

-- | Generate path to indicated SC3 method help.
--   
--   <pre>
--   sc3HelpMethod "." '*' ("C","m") == "./Classes/C.html#*m"
--   </pre>
sc3HelpMethod :: FilePath -> Char -> (String, String) -> FilePath

-- | Generate path to indicated SC3 class method help.
--   
--   <pre>
--   sc3HelpClassMethod "." ("C","m") == "./Classes/C.html#*m"
--   </pre>
sc3HelpClassMethod :: FilePath -> (String, String) -> FilePath

-- | Generate path to indicated SC3 instance method help.
--   
--   <pre>
--   sc3HelpInstanceMethod "." ("C","m") == "./Classes/C.html#-m"
--   </pre>
sc3HelpInstanceMethod :: FilePath -> (String, String) -> FilePath

-- | The name of the local SC3 Help file documenting <tt>u</tt>. Deletes
--   <tt>@</tt> to allow use on haddock quoted comments.
--   
--   <pre>
--   import Sound.SC3.UGen.Name
--   
--   ugenSC3HelpFile "Collection.*fill"
--   ugenSC3HelpFile "Collection.inject"
--   ugenSC3HelpFile (toSC3Name "sinOsc")
--   </pre>
ugenSC3HelpFile :: String -> IO FilePath

-- | Use <tt>BROWSER</tt> or <tt>x-www-browser</tt> to view SC3 help file
--   for <tt>u</tt>.
--   
--   <pre>
--   get_env_default "BROWSER" "x-www-browser"
--   </pre>
--   
--   <pre>
--   import Sound.SC3.UGen.Name
--   
--   viewSC3Help (toSC3Name "Collection.*fill")
--   viewSC3Help (toSC3Name "Collection.inject")
--   viewSC3Help (toSC3Name "sinOsc")
--   </pre>
viewSC3Help :: String -> IO ()


-- | Functions to provide mediated access to the SC3 help system.
module Sound.SC3.Server.Help

-- | Generate path to indicated SC3 instance method help.
--   
--   <pre>
--   let r = "./Reference/Server-Command-Reference.html#/b_alloc"
--   in sc3HelpServerCommand "." "b_alloc" == r
--   </pre>
sc3_server_command_ref :: FilePath -> String -> FilePath

-- | Lookup <tt>SC3</tt> help file for server command <tt>c</tt>.
--   
--   <pre>
--   Sound.SC3.Server.Help.viewServerHelp "/b_allocRead"
--   viewServerHelp "done"
--   </pre>
viewServerHelp :: String -> IO ()


-- | Operating rate definitions and utilities.
module Sound.SC3.UGen.Rate

-- | Operating rate of unit generator.
data Rate
IR :: Rate
KR :: Rate
AR :: Rate
DR :: Rate

-- | Integer rate identifier, as required for scsynth bytecode.
rateId :: Rate -> Int

-- | Rates as ordered for filter rate selection.
rate_ord :: Rate -> Int

-- | Color identifiers for each <a>Rate</a>.
rate_color :: Rate -> String

-- | Set of all <a>Rate</a> values.
all_rates :: [Rate]

-- | Case insensitive parser for rate.
--   
--   <pre>
--   Data.Maybe.mapMaybe rate_parse (words "ar kR IR Dr") == [AR,KR,IR,DR]
--   </pre>
rate_parse :: String -> Maybe Rate
instance Eq Rate
instance Enum Rate
instance Bounded Rate
instance Show Rate
instance Read Rate
instance Ord Rate


-- | Binary 'Graph Definition' as understood by <tt>scsynth</tt>.
module Sound.SC3.Server.Graphdef
type Name = ASCII
type Control = (Name, Int)
type Sample = Double
data Input
Input :: Int -> Int -> Input
input_ugen_ix :: Input -> Maybe Int
type Output = Int
type Rate = Int
type Special = Int
type UGen = (Name, Rate, [Input], [Output], Special)
ugen_inputs :: UGen -> [Input]
ugen_outputs :: UGen -> [Output]
ugen_is_control :: UGen -> Bool
ugen_rate :: UGen -> Rate
input_is_control :: Graphdef -> Input -> Bool
data Graphdef
Graphdef :: Name -> [Sample] -> [(Control, Sample)] -> [UGen] -> Graphdef
graphdef_name :: Graphdef -> Name
graphdef_constants :: Graphdef -> [Sample]
graphdef_controls :: Graphdef -> [(Control, Sample)]
graphdef_ugens :: Graphdef -> [UGen]
graphdef_ugen :: Graphdef -> Int -> UGen
graphdef_control :: Graphdef -> Int -> (Control, Sample)
graphdef_constant_nid :: Graphdef -> Int -> Int
graphdef_control_nid :: Graphdef -> Int -> Int
graphdef_ugen_nid :: Graphdef -> Int -> Int
read_i8 :: Handle -> IO Int
read_i16 :: Handle -> IO Int
read_i32 :: Handle -> IO Int
read_sample :: Handle -> IO Sample
read_pstr :: Handle -> IO ASCII
read_control :: Handle -> IO Control
read_input :: Handle -> IO Input
read_output :: Handle -> IO Int
read_ugen :: Handle -> IO UGen
read_graphdef :: Handle -> IO Graphdef
read_graphdef_file :: FilePath -> IO Graphdef

-- | Pascal (length prefixed) encoding of string.
encode_pstr :: ASCII -> ByteString

-- | Byte-encode <a>Input</a> value.
encode_input :: Input -> ByteString
encode_control :: Control -> ByteString

-- | Byte-encode <a>UGen</a>.
encode_ugen :: UGen -> ByteString
encode_sample :: Sample -> ByteString
encode_graphdef :: Graphdef -> ByteString
graphdef_stat :: Graphdef -> String
instance Eq Input
instance Show Input
instance Eq Graphdef
instance Show Graphdef


-- | Enumeration of SC3 server commands.
module Sound.SC3.Server.Command.Enum

-- | SC3 server commands are strings.
type SC3_Command = String

-- | Enumerate server command numbers.
sc3_cmd_enumeration :: [(SC3_Command, Int)]

-- | Lookup command number in <a>sc3_cmd_enumeration</a>.
--   
--   <pre>
--   map sc3_cmd_number ["/b_alloc","/s_new"] == [Just 28,Just 9]
--   </pre>
sc3_cmd_number :: SC3_Command -> Maybe Int

-- | <a>isJust</a> of <a>sc3_cmd_number</a>.
known_sc3_cmd :: SC3_Command -> Bool

-- | List of asynchronous server commands.
async_cmds :: [SC3_Command]

-- | <a>True</a> if <a>Message</a> is an asynchronous <a>Message</a>.
--   
--   <pre>
--   map isAsync [b_close 0,n_set1 0 "0" 0] == [True,False]
--   </pre>
isAsync :: Message -> Bool

-- | Asynchronous commands are at the left. This function should preserve
--   the ordering of both branches.
--   
--   <pre>
--   partition_async [b_close 0,n_set1 0 "0" 0]
--   </pre>
partition_async :: [Message] -> ([Message], [Message])


-- | Request and display status information from the synthesis server.
module Sound.SC3.Server.Status

-- | Get <i>n</i>th field of status as <a>Floating</a>.
extractStatusField :: Floating n => Int -> [Datum] -> n

-- | Names of status fields.
statusFields :: [String]

-- | Status pretty printer.
statusFormat :: [Datum] -> [String]

-- | Name or index and value or bus mapping.
type Query_Ctl = (Either String Int, Either Double Int)

-- | Nodes are either groups of synths.
data Query_Node
Query_Group :: Int -> [Query_Node] -> Query_Node
Query_Synth :: Int -> String -> (Maybe [Query_Ctl]) -> Query_Node
query_ctl_pp :: Query_Ctl -> String
query_node_pp :: Query_Node -> String

-- | Control (parameter) data may be given as names or indices and as
--   values or bus mappings.
--   
--   <pre>
--   queryTree_ctl (string "freq",float 440) == (Left "freq",Left 440.0)
--   queryTree_ctl (int32 1,string "c0") == (Right 1,Right 0)
--   </pre>
queryTree_ctl :: (Datum, Datum) -> Query_Ctl
queryTree_synth :: Bool -> Int -> String -> [Datum] -> (Query_Node, [Datum])
queryTree_group :: Bool -> Int -> Int -> [Datum] -> (Query_Node, [Datum])
queryTree_child :: Bool -> [Datum] -> (Query_Node, [Datum])

-- | Parse result of <tt>g_queryTree</tt>.
--   
--   <pre>
--   let r = [int32 1,int32 0,int32 2,int32 1,int32 1
--           ,int32 100,int32 1
--           ,int32 1000,int32 (-1),string "saw"
--           ,int32 1,string "freq",float 440.0
--           ,int32 2,int32 0]
--   in queryTree r
--   </pre>
queryTree :: [Datum] -> Query_Node

-- | Transform <a>Query_Node</a> to <a>Tree</a>.
--   
--   <pre>
--   putStrLn (T.drawTree (fmap query_node_pp (queryTree_rt (queryTree r))))
--   &gt; 0
--   &gt; |
--   &gt; +- 1
--   &gt; |  |
--   &gt; |  `- 100
--   &gt; |     |
--   &gt; |     `- (1000,"saw","freq:440.0")
--   &gt; |
--   &gt; `- 2
--   </pre>
queryTree_rt :: Query_Node -> Tree Query_Node
instance Eq Query_Node
instance Show Query_Node


-- | Server input enumerations.
module Sound.SC3.Server.Enum

-- | Enumeration of possible locations to add new nodes (s_new and g_new).
data AddAction
AddToHead :: AddAction
AddToTail :: AddAction
AddBefore :: AddAction
AddAfter :: AddAction
AddReplace :: AddAction

-- | Enumeration of flags for '/b_gen' command.
data B_Gen
Normalise :: B_Gen
Wavetable :: B_Gen
Clear :: B_Gen

-- | <a>B_Gen</a> to bit number.
--   
--   <pre>
--   map b_gen_bit [minBound .. maxBound]
--   </pre>
b_gen_bit :: B_Gen -> Int

-- | Set of <a>B_Gen</a> to flag.
--   
--   <pre>
--   b_gen_flag [minBound .. maxBound] == 7
--   </pre>
b_gen_flag :: [B_Gen] -> Int

-- | Error posting scope.
data ErrorScope

-- | Global scope
Globally :: ErrorScope

-- | Bundle scope
Locally :: ErrorScope

-- | Error posting mode.
data ErrorMode

-- | Turn error posting off
ErrorsOff :: ErrorMode

-- | Turn error posting on
ErrorsOn :: ErrorMode

-- | Enumeration of Message printer types.
data PrintLevel
NoPrinter :: PrintLevel
TextPrinter :: PrintLevel
HexPrinter :: PrintLevel
AllPrinter :: PrintLevel

-- | Sound file format.
data SoundFileFormat
Aiff :: SoundFileFormat
Flac :: SoundFileFormat
Ircam :: SoundFileFormat
Next :: SoundFileFormat
Raw :: SoundFileFormat
Wave :: SoundFileFormat

-- | Sample format.
data SampleFormat
PcmInt8 :: SampleFormat
PcmInt16 :: SampleFormat
PcmInt24 :: SampleFormat
PcmInt32 :: SampleFormat
PcmFloat :: SampleFormat
PcmDouble :: SampleFormat
PcmMulaw :: SampleFormat
PcmAlaw :: SampleFormat

-- | Sample format to standard file extension name.
soundFileFormatString :: SoundFileFormat -> String

-- | Infer sample format from file extension name.
soundFileFormat_from_extension :: String -> Maybe SoundFileFormat
sampleFormatString :: SampleFormat -> String
instance Eq AddAction
instance Show AddAction
instance Enum AddAction
instance Eq B_Gen
instance Enum B_Gen
instance Bounded B_Gen
instance Show B_Gen
instance Eq ErrorScope
instance Show ErrorScope
instance Enum ErrorScope
instance Eq ErrorMode
instance Show ErrorMode
instance Enum ErrorMode
instance Eq PrintLevel
instance Show PrintLevel
instance Enum PrintLevel
instance Enum SoundFileFormat
instance Eq SoundFileFormat
instance Read SoundFileFormat
instance Show SoundFileFormat
instance Enum SampleFormat
instance Eq SampleFormat
instance Read SampleFormat
instance Show SampleFormat


-- | Non-realtime score generation.
module Sound.SC3.Server.NRT

-- | Encode and prefix with encoded length.
oscWithSize :: Bundle -> ByteString

-- | An <a>NRT</a> score is a sequence of <a>Bundle</a>s.
data NRT
NRT :: [Bundle] -> NRT
nrt_bundles :: NRT -> [Bundle]

-- | <a>span</a> of <tt>f</tt> of <a>bundleTime</a>. Can be used to
--   separate the <i>initialisation</i> and <i>remainder</i> parts of a
--   score.
nrt_span :: (Time -> Bool) -> NRT -> ([Bundle], [Bundle])

-- | Encode an <a>NRT</a> score.
encodeNRT :: NRT -> ByteString

-- | Write an <a>NRT</a> score.
writeNRT :: FilePath -> NRT -> IO ()

-- | Write an <a>NRT</a> score to a file handle.
putNRT :: Handle -> NRT -> IO ()

-- | Decode an <a>NRT</a> <a>ByteString</a> to a list of <a>Bundle</a>s.
decode_nrt_bundles :: ByteString -> [Bundle]

-- | Decode an <a>NRT</a> <a>ByteString</a>.
decodeNRT :: ByteString -> NRT

-- | <a>decodeNRT</a> of <a>readFile</a>.
readNRT :: FilePath -> IO NRT

-- | Minimal NRT rendering options. The sound file type is inferred from
--   the file name extension. Structure is: OSC file name, output audio
--   file name, output number of channels, sample rate, sample format.
type NRT_Render_Plain = (FilePath, FilePath, Int, Int, SampleFormat)

-- | Minimal NRT rendering, for more control see Stefan Kersten's
--   <i>hsc3-process</i> package at:
--   <a>https://github.com/kaoskorobase/hsc3-process</a>.
nrt_render_plain :: NRT_Render_Plain -> NRT -> IO ()
instance Show NRT


-- | Functions to make writing <a>Applicative</a> and <a>Monad</a> UGen
--   graphs less clumsy.
module Sound.SC3.Common.Monad.Syntax

-- | <a>+</a> variant with <a>Functor</a> at left.
--   
--   <pre>
--   fmap (== 5) (return 3 .+ 2)
--   [3,4] .+ 2 == [5,6]
--   </pre>
(.+) :: (Functor f, Num a) => f a -> a -> f a

-- | <a>+</a> variant with <a>Functor</a> at right.
--   
--   <pre>
--   fmap (== 5) (3 +. return 2)
--   3 +. [2,3] == [5,6]
--   </pre>
(+.) :: (Functor f, Num a) => a -> f a -> f a

-- | <a>+</a> variant with <a>Applicative</a> at left and right.
--   
--   <pre>
--   fmap (== 5) (return 3 .+. return 2)
--   [3,4] .+. [2,3] == [5,6,6,7]
--   getZipList (ZipList [3,4] .+. ZipList [2,3]) == [5,7]
--   </pre>
(.+.) :: (Applicative m, Num a) => m a -> m a -> m a

-- | <a>*</a> variant with <a>Functor</a> at left.
--   
--   <pre>
--   fmap (== 6) (return 3 .* 2)
--   </pre>
(.*) :: (Functor f, Num a) => f a -> a -> f a

-- | <a>*</a> variant with <a>Functor</a> at right.
--   
--   <pre>
--   fmap (== 6) (3 *. return 2)
--   </pre>
(*.) :: (Functor f, Num a) => a -> f a -> f a

-- | <a>*</a> variant with <a>Applicative</a> at left and right.
--   
--   <pre>
--   fmap (== 6) (return 3 .*. return 2)
--   </pre>
(.*.) :: (Applicative m, Num a) => m a -> m a -> m a

-- | <a>-</a> variant with <a>Functor</a> at left.
--   
--   <pre>
--   fmap (== 1) (return 3 .- 2)
--   [3,4] .- 2 == [1,2]
--   </pre>
(.-) :: (Functor f, Num a) => f a -> a -> f a

-- | <a>-</a> variant with <a>Functor</a> at right.
--   
--   <pre>
--   fmap (== 1) (3 -. return 2)
--   3 -. [2,3] == [1,0]
--   </pre>
(-.) :: (Functor f, Num a) => a -> f a -> f a

-- | <a>-</a> variant with <a>Applicative</a> at left and right.
--   
--   <pre>
--   fmap (== 1) (return 3 .-. return 2)
--   [3,4] .-. [2,3] == [1,0,2,1]
--   getZipList (ZipList [3,4] .-. ZipList [2,3]) == [1,1]
--   </pre>
(.-.) :: (Applicative m, Num a) => m a -> m a -> m a

-- | <a>/</a> variant with <a>Functor</a> at left.
--   
--   <pre>
--   fmap (== 3) (return 6 ./ 2)
--   </pre>
(./) :: (Functor f, Fractional a) => f a -> a -> f a

-- | <a>/</a> variant with <a>Functor</a> at right.
--   
--   <pre>
--   fmap (== 3) (6 /. return 2)
--   </pre>
(/.) :: (Functor f, Fractional a) => a -> f a -> f a

-- | <a>/</a> variant with <a>Applicative</a> at left and right.
--   
--   <pre>
--   fmap (== 3) (return 6 ./. return 2)
--   [5,6] ./. [2,3] == [5/2,5/3,3,2]
--   </pre>
(./.) :: (Applicative m, Fractional a) => m a -> m a -> m a

-- | Right to left compositon of <a>Monad</a> functions.
--   
--   <pre>
--   fmap (== 7) (composeM [return . (+ 1),return . (/ 2)] 3)
--   fmap (== 8) (composeM [return . (* 2),return . (+ 1)] 3)
--   </pre>
composeM :: Monad m => [a -> m a] -> a -> m a

-- | Feed forward composition of <i>n</i> applications of <i>f</i>.
--   
--   <pre>
--   fmap (== 3) (chainM 3 (return . (+ 1)) 0)
--   </pre>
chainM :: Monad m => Int -> (b -> m b) -> b -> m b

module Sound.SC3.Common

-- | Variant of <a>reads</a> requiring exact match.
reads_exact :: Read a => String -> Maybe a

-- | CI = Case insensitive, CS = case sensitive.
data Case_Rule
CI :: Case_Rule
CS :: Case_Rule

-- | Predicates for <a>Case_Rule</a>.
is_ci :: Case_Rule -> Bool

-- | Predicates for <a>Case_Rule</a>.
is_cs :: Case_Rule -> Bool

-- | String equality with <a>Case_Rule</a>.
--   
--   <pre>
--   string_eq CI "lower" "LOWER" == True
--   </pre>
string_eq :: Case_Rule -> String -> String -> Bool

-- | <a>rlookup_by</a> of <a>string_eq</a>.
rlookup_str :: Case_Rule -> String -> [(a, String)] -> Maybe a

-- | <a>Enum</a> parser with <a>Case_Rule</a>.
--   
--   <pre>
--   parse_enum CI "FALSE" == Just False
--   </pre>
parse_enum :: (Show t, Enum t, Bounded t) => Case_Rule -> String -> Maybe t

-- | <a>lookup</a> with equality function.
lookup_by :: (a -> a -> Bool) -> a -> [(a, b)] -> Maybe b

-- | Reverse <a>lookup</a> with equality function.
rlookup_by :: (b -> b -> Bool) -> b -> [(a, b)] -> Maybe a

-- | (prev,cur,next) triples.
--   
--   <pre>
--   pcn_triples [1..3] == [(Nothing,1,Just 2),(Just 1,2,Just 3),(Just 2,3,Nothing)]
--   </pre>
pcn_triples :: [a] -> [(Maybe a, a, Maybe a)]
type T2 a = (a, a)
type T3 a = (a, a, a)
type T4 a = (a, a, a, a)

-- | <a>concatMap</a> of <i>f</i> at <i>x</i> and <i>g</i> at <i>y</i>.
mk_duples :: (a -> c) -> (b -> c) -> [(a, b)] -> [c]

-- | Length prefixed list variant of <a>mk_duples</a>.
mk_duples_l :: (Int -> c) -> (a -> c) -> (b -> c) -> [(a, [b])] -> [c]

-- | <a>concatMap</a> of <i>f</i> at <i>x</i> and <i>g</i> at <i>y</i> and
--   <i>h</i> at <i>z</i>.
mk_triples :: (a -> d) -> (b -> d) -> (c -> d) -> [(a, b, c)] -> [d]
instance Eq Case_Rule


-- | Functions to normalise UGen names. <tt>SC3</tt> UGen names are
--   capitalised, <tt>hsc3</tt> cannot use the same names for UGen
--   constructor functions. The functions here are heuristics, and are
--   likely only partial.
module Sound.SC3.UGen.Name

-- | Convert from <tt>hsc3</tt> name to <tt>SC3</tt> name.
--   
--   <pre>
--   toSC3Name "sinOsc" == "SinOsc"
--   toSC3Name "lfSaw" == "LFSaw"
--   toSC3Name "pv_Copy" == "PV_Copy"
--   map toSC3Name ["bpf","fft","tpv","out","in'"]
--   </pre>
toSC3Name :: String -> String

-- | Inverse of <a>toSC3Name</a>.
--   
--   <pre>
--   let nm = ["SinOsc","LFSaw","PV_Copy"]
--   in map fromSC3Name nm == ["sinOsc","lfSaw","pv_Copy"]
--   </pre>
--   
--   <pre>
--   map fromSC3Name ["BPF","FFT","TPV"] == ["bpf","fft","tpv"]
--   </pre>
--   
--   <pre>
--   map fromSC3Name (words "HPZ1 RLPF")
--   </pre>
fromSC3Name :: String -> String

-- | Find SC3 name edges.
sc3_name_edges :: String -> [Bool]

-- | Convert from SC3 name to Lisp style name.
--   
--   <pre>
--   let {s = words "SinOsc LFSaw FFT PV_Add AllpassN BHiPass BinaryOpUGen HPZ1 RLPF TGrains"
--       ;l = words "sin-osc lf-saw fft pv-add allpass-n b-hi-pass binary-op-ugen hpz1 rlpf t-grains"}
--   in map sc3_name_to_lisp_name s == l
--   </pre>
sc3_name_to_lisp_name :: String -> String

-- | SC3 UGen <i>names</i> are given with rate suffixes if oscillators,
--   without if filters.
--   
--   <pre>
--   map sc3_ugen_name_sep (words "SinOsc.ar LPF *")
--   </pre>
sc3_ugen_name_sep :: String -> Maybe (String, Maybe Rate)


-- | Enumerations of the unary and binary math unit generators. Names that
--   conflict with existing names have a <tt>_</tt> suffix.
module Sound.SC3.UGen.Operator

-- | Enumeration of <tt>SC3</tt> unary operator UGens.
data Unary
Neg :: Unary
Not :: Unary
IsNil :: Unary
NotNil :: Unary
BitNot :: Unary
Abs :: Unary
AsFloat :: Unary
AsInt :: Unary
Ceil :: Unary
Floor :: Unary
Frac :: Unary
Sign :: Unary
Squared :: Unary
Cubed :: Unary
Sqrt :: Unary
Exp :: Unary
Recip :: Unary
MIDICPS :: Unary
CPSMIDI :: Unary
MIDIRatio :: Unary
RatioMIDI :: Unary
DbAmp :: Unary
AmpDb :: Unary
OctCPS :: Unary
CPSOct :: Unary
Log :: Unary
Log2 :: Unary
Log10 :: Unary
Sin :: Unary
Cos :: Unary
Tan :: Unary
ArcSin :: Unary
ArcCos :: Unary
ArcTan :: Unary
SinH :: Unary
CosH :: Unary
TanH :: Unary
Rand_ :: Unary
Rand2 :: Unary
LinRand_ :: Unary
BiLinRand :: Unary
Sum3Rand :: Unary
Distort :: Unary
SoftClip :: Unary
Coin :: Unary
DigitValue :: Unary
Silence :: Unary
Thru :: Unary
RectWindow :: Unary
HanWindow :: Unary
WelchWindow :: Unary
TriWindow :: Unary
Ramp_ :: Unary
SCurve :: Unary

-- | Type-specialised <a>parse_enum</a>.
parse_unary :: Case_Rule -> String -> Maybe Unary

-- | Table of symbolic names for standard unary operators.
unaryTable :: [(Unary, String)]

-- | Lookup possibly symbolic name for standard unary operators.
unaryName :: Int -> String

-- | Given name of unary operator derive index.
--   
--   <pre>
--   mapMaybe (unaryIndex True) (words "NEG CUBED") == [0,13]
--   unaryIndex True "SinOsc" == Nothing
--   </pre>
unaryIndex :: Case_Rule -> String -> Maybe Int

-- | <a>isJust</a> of <a>unaryIndex</a>.
--   
--   <pre>
--   map (is_unary True) (words "ABS MIDICPS NEG")
--   map (is_unary True) (words "- RAND")
--   </pre>
is_unary :: Case_Rule -> String -> Bool

-- | Enumeration of <tt>SC3</tt> unary operator UGens.
data Binary
Add :: Binary
Sub :: Binary
Mul :: Binary
IDiv :: Binary
FDiv :: Binary
Mod :: Binary
EQ_ :: Binary
NE :: Binary
LT_ :: Binary
GT_ :: Binary
LE :: Binary
GE :: Binary
Min :: Binary
Max :: Binary
BitAnd :: Binary
BitOr :: Binary
BitXor :: Binary
LCM :: Binary
GCD :: Binary
Round :: Binary
RoundUp :: Binary
Trunc :: Binary
Atan2 :: Binary
Hypot :: Binary
Hypotx :: Binary
Pow :: Binary
ShiftLeft :: Binary
ShiftRight :: Binary
UnsignedShift :: Binary
Fill :: Binary
Ring1 :: Binary
Ring2 :: Binary
Ring3 :: Binary
Ring4 :: Binary
DifSqr :: Binary
SumSqr :: Binary
SqrSum :: Binary
SqrDif :: Binary
AbsDif :: Binary
Thresh :: Binary
AMClip :: Binary
ScaleNeg :: Binary
Clip2 :: Binary
Excess :: Binary
Fold2 :: Binary
Wrap2 :: Binary
FirstArg :: Binary
RandRange :: Binary
ExpRandRange :: Binary

-- | Type-specialised <a>parse_enum</a>.
parse_binary :: Case_Rule -> String -> Maybe Binary

-- | Table of symbolic names for standard binary operators.
binaryTable :: [(Binary, String)]

-- | Lookup possibly symbolic name for standard binary operators.
--   
--   <pre>
--   map binaryName [1,2,8,12] == ["-","*","&lt;","Min"]
--   </pre>
binaryName :: Int -> String

-- | Given name of binary operator derive index.
--   
--   <pre>
--   mapMaybe (binaryIndex True) (words "* MUL RING1") == [2,2,30]
--   binaryIndex True "SINOSC" == Nothing
--   </pre>
binaryIndex :: Case_Rule -> String -> Maybe Int

-- | <a>isJust</a> of <a>binaryIndex</a>.
--   
--   <pre>
--   map (is_binary True) (words "== &gt; % TRUNC MAX")
--   </pre>
is_binary :: Case_Rule -> String -> Bool

-- | Order of lookup: binary then unary.
--   
--   <pre>
--   map (resolve_operator True) (words "+ - ADD SUB NEG")
--   </pre>
resolve_operator :: Case_Rule -> String -> (String, Maybe Int)
instance Eq Unary
instance Show Unary
instance Enum Unary
instance Bounded Unary
instance Read Unary
instance Eq Binary
instance Show Binary
instance Enum Binary
instance Bounded Binary
instance Read Binary

module Sound.SC3.UGen.Type

-- | Data type for internalised identifier at <a>UGen</a>.
data UGenId
NoId :: UGenId
UId :: Int -> UGenId

-- | Alias of <a>NoId</a>, the <a>UGenId</a> used for deterministic UGens.
no_id :: UGenId

-- | SC3 samples are 32-bit <a>Float</a>. hsc3 represents data as 64-bit
--   <a>Double</a>. If <a>UGen</a> values are used more generally (ie. see
--   hsc3-forth) <a>Float</a> may be too imprecise, ie. for representing
--   time stamps.
type Sample = Double

-- | Constants.
--   
--   <pre>
--   Constant 3 == Constant 3
--   (Constant 3 &gt; Constant 1) == True
--   </pre>
data Constant
Constant :: Sample -> Constant
constantValue :: Constant -> Sample

-- | Control meta-data.
data C_Meta n
C_Meta :: n -> n -> String -> n -> String -> C_Meta n

-- | Minimum
ctl_min :: C_Meta n -> n

-- | Maximum
ctl_max :: C_Meta n -> n

-- | <tt>(0,1)</tt> <tt>(min,max)</tt> transfer function.
ctl_warp :: C_Meta n -> String

-- | The step to increment &amp; decrement by.
ctl_step :: C_Meta n -> n

-- | Unit of measure (ie hz, ms etc.).
ctl_units :: C_Meta n -> String

-- | 5-tuple form of <a>C_Meta</a> data.
type C_Meta' n = (n, n, String, n, String)

-- | Lift <a>C_Meta'</a> to <a>C_Meta</a> allowing type coercion.
c_meta' :: (n -> m) -> C_Meta' n -> C_Meta m

-- | Control inputs. It is an invariant that controls with equal names
--   within a UGen graph must be equal in all other respects.
data Control
Control :: Rate -> Maybe Int -> String -> Sample -> Bool -> Maybe (C_Meta Sample) -> Control
controlOperatingRate :: Control -> Rate
controlIndex :: Control -> Maybe Int
controlName :: Control -> String
controlDefault :: Control -> Sample
controlTriggered :: Control -> Bool
controlMeta :: Control -> Maybe (C_Meta Sample)

-- | Labels.
data Label
Label :: String -> Label
ugenLabel :: Label -> String

-- | Unit generator output descriptor.
type Output = Rate

-- | Operating mode of unary and binary operators.
newtype Special
Special :: Int -> Special

-- | UGen primitives.
data Primitive
Primitive :: Rate -> String -> [UGen] -> [Output] -> Special -> UGenId -> Primitive
ugenRate :: Primitive -> Rate
ugenName :: Primitive -> String
ugenInputs :: Primitive -> [UGen]
ugenOutputs :: Primitive -> [Output]
ugenSpecial :: Primitive -> Special
ugenId :: Primitive -> UGenId

-- | Proxy to multiple channel input.
data Proxy
Proxy :: Primitive -> Int -> Proxy
proxySource :: Proxy -> Primitive
proxyIndex :: Proxy -> Int

-- | Multiple root graph.
data MRG
MRG :: UGen -> UGen -> MRG
mrgLeft :: MRG -> UGen
mrgRight :: MRG -> UGen

-- | Union type of Unit Generator forms.
data UGen
Constant_U :: Constant -> UGen
Control_U :: Control -> UGen
Label_U :: Label -> UGen
Primitive_U :: Primitive -> UGen
Proxy_U :: Proxy -> UGen
MCE_U :: (MCE UGen) -> UGen
MRG_U :: MRG -> UGen
parse_constant :: String -> Maybe UGen

-- | See into <a>Constant_U</a>.
un_constant :: UGen -> Maybe Constant

-- | Value of <a>Constant_U</a> <a>Constant</a>.
u_constant :: UGen -> Maybe Sample

-- | Constant node predicate.
isConstant :: UGen -> Bool

-- | True if input is a sink <a>UGen</a>, ie. has no outputs.
isSink :: UGen -> Bool

-- | See into <a>Proxy_U</a>.
un_proxy :: UGen -> Maybe Proxy
isProxy :: UGen -> Bool

-- | Ensure input <a>UGen</a> is valid, ie. not a sink.
checkInput :: UGen -> UGen

-- | Constant value node constructor.
constant :: Real n => n -> UGen

-- | Type specialised <a>constant</a>.
int_to_ugen :: Int -> UGen

-- | Type specialised <a>constant</a>.
float_to_ugen :: Float -> UGen

-- | Type specialised <a>constant</a>.
double_to_ugen :: Double -> UGen

-- | Multiple channel expansion node constructor.
mce :: [UGen] -> UGen

-- | Multiple root graph constructor.
mrg :: [UGen] -> UGen

-- | Unit generator proxy node constructor.
proxy :: UGen -> Int -> UGen

-- | Type specified <a>mce_elem</a>.
mceProxies :: MCE UGen -> [UGen]

-- | Multiple channel expansion node (<a>MCE_U</a>) predicate.
isMCE :: UGen -> Bool

-- | Output channels of UGen as a list.
mceChannels :: UGen -> [UGen]

-- | Number of channels to expand to.
mceDegree :: UGen -> Int

-- | Extend UGen to specified degree.
mceExtend :: Int -> UGen -> [UGen]

-- | Apply MCE transform to a list of inputs.
mceInputTransform :: [UGen] -> Maybe [[UGen]]

-- | Build a UGen after MCE transformation of inputs.
mceBuild :: ([UGen] -> UGen) -> [UGen] -> UGen

-- | True if MCE is an immediate proxy for a multiple-out Primitive.
mce_is_direct_proxy :: MCE UGen -> Bool

-- | Determine the rate of a UGen.
rateOf :: UGen -> Rate

-- | Apply proxy transformation if required.
proxify :: UGen -> UGen

-- | Construct proxied and multiple channel expanded UGen.
--   
--   cf = constant function, rs = rate set, r = rate, nm = name, i =
--   inputs, o = outputs.
mkUGen :: Maybe ([Sample] -> Sample) -> [Rate] -> Either Rate [Int] -> String -> [UGen] -> Maybe UGen -> Int -> Special -> UGenId -> UGen

-- | Operator UGen constructor.
mkOperator :: ([Sample] -> Sample) -> String -> [UGen] -> Int -> UGen

-- | Unary math constructor with constant optimization.
mkUnaryOperator :: Unary -> (Sample -> Sample) -> UGen -> UGen

-- | Binary math constructor with constant optimization.
--   
--   <pre>
--   let o = sinOsc AR 440 0
--   </pre>
--   
--   <pre>
--   o * 1 == o &amp;&amp; 1 * o == o &amp;&amp; o * 2 /= o
--   o + 0 == o &amp;&amp; 0 + o == o &amp;&amp; o + 1 /= o
--   o - 0 == o &amp;&amp; 0 - o /= o
--   o / 1 == o &amp;&amp; 1 / o /= o
--   o ** 1 == o &amp;&amp; o ** 2 /= o
--   </pre>
mkBinaryOperator_optimize :: Binary -> (Sample -> Sample -> Sample) -> (Either Sample Sample -> Bool) -> UGen -> UGen -> UGen

-- | Binary math constructor with constant optimization.
mkBinaryOperator :: Binary -> (Sample -> Sample -> Sample) -> UGen -> UGen -> UGen

-- | Unit generators are numbers.

-- | Unit generators are fractional.

-- | Unit generators are floating point.

-- | Unit generators are real.

-- | Unit generators are integral.

-- | Unit generators are orderable (when <tt>Constants</tt>).
--   
--   <pre>
--   (constant 2 &gt; constant 1) == True
--   </pre>

-- | Unit generators are enumerable.

-- | Unit generators are stochastic.

-- | UGens are bit patterns.
instance Eq UGenId
instance Show UGenId
instance Eq Constant
instance Ord Constant
instance Show Constant
instance Eq n => Eq (C_Meta n)
instance Show n => Show (C_Meta n)
instance Eq Control
instance Show Control
instance Eq Label
instance Show Label
instance Eq Special
instance Show Special
instance Eq UGen
instance Show UGen
instance Eq MRG
instance Show MRG
instance Eq Proxy
instance Show Proxy
instance Eq Primitive
instance Show Primitive
instance Bits UGen
instance Random UGen
instance Enum UGen
instance Ord UGen
instance RealFrac UGen
instance Integral UGen
instance Real UGen
instance Floating UGen
instance Fractional UGen
instance Num UGen


-- | Data types for enumerated and non signal unit generator inputs.
module Sound.SC3.UGen.Enum

-- | Loop indicator input.
data Loop
Loop :: Loop
NoLoop :: Loop
WithLoop :: UGen -> Loop

-- | Resolve <a>Loop</a>.
from_loop :: Loop -> UGen

-- | Interpolation indicator input.
data Interpolation
NoInterpolation :: Interpolation
LinearInterpolation :: Interpolation
CubicInterpolation :: Interpolation
Interpolation :: UGen -> Interpolation

-- | Resolve <a>Interpolation</a>.
from_interpolation :: Interpolation -> UGen

-- | Completion mode indicator input.
data DoneAction
DoNothing :: DoneAction
PauseSynth :: DoneAction
RemoveSynth :: DoneAction
RemoveGroup :: DoneAction
DoneAction :: UGen -> DoneAction

-- | Resolve <a>DoneAction</a>.
from_done_action :: DoneAction -> UGen

-- | Warp interpolation indicator input.
data Warp
Linear :: Warp
Exponential :: Warp
Warp :: UGen -> Warp

-- | Resolve <a>Warp</a>.
from_warp :: Warp -> UGen

-- | Envelope curve indicator input.
data Envelope_Curve a
EnvStep :: Envelope_Curve a
EnvLin :: Envelope_Curve a
EnvExp :: Envelope_Curve a
EnvSin :: Envelope_Curve a

-- | Note: not implemented at SC3
EnvWelch :: Envelope_Curve a
EnvNum :: a -> Envelope_Curve a
EnvSqr :: Envelope_Curve a
EnvCub :: Envelope_Curve a
EnvHold :: Envelope_Curve a

-- | Envelope curve pair.
type Envelope_Curve2 a = T2 (Envelope_Curve a)

-- | Envelope curve triple.
type Envelope_Curve3 a = T3 (Envelope_Curve a)

-- | Envelope curve triple.
type Envelope_Curve4 a = T4 (Envelope_Curve a)

-- | Type specialised (<a>UGen</a>) envelope curve.
type EnvCurve = Envelope_Curve UGen

-- | Convert <a>Envelope_Curve</a> to shape value.
--   
--   <pre>
--   map env_curve_shape [EnvSin,EnvSqr] == [3,6]
--   </pre>
env_curve_shape :: Num a => Envelope_Curve a -> a

-- | The <i>value</i> of <a>EnvCurve</a> is non-zero for <a>EnvNum</a>.
--   
--   <pre>
--   map env_curve_value [EnvWelch,EnvNum 2] == [0,2]
--   </pre>
env_curve_value :: Num a => Envelope_Curve a -> a

-- | <tt>Interpolation_F</tt> of <a>Envelope_Curve</a>.
env_curve_interpolation_f :: (Ord t, Floating t) => Envelope_Curve t -> Interpolation_F t

-- | Unification of integer and <a>UGen</a> buffer identifiers.
data Buffer
Buffer_Id :: Int -> Buffer
Buffer :: UGen -> Buffer

-- | Lift to <a>UGen</a>.
from_buffer :: Buffer -> UGen
instance Eq Loop
instance Show Loop
instance Eq Interpolation
instance Show Interpolation
instance Eq DoneAction
instance Show DoneAction
instance Eq Warp
instance Show Warp
instance Eq a => Eq (Envelope_Curve a)
instance Show a => Show (Envelope_Curve a)
instance Eq Buffer
instance Show Buffer


-- | Envelope generators.
module Sound.SC3.UGen.Envelope

-- | SC3 envelope segment model
data Envelope a
Envelope :: [a] -> [a] -> [Envelope_Curve a] -> Maybe Int -> Maybe Int -> Envelope a

-- | Set of <i>n</i> levels, n is &gt;= 1
env_levels :: Envelope a -> [a]

-- | Set of <i>n-1</i> time intervals
env_times :: Envelope a -> [a]

-- | Possibly empty curve set
env_curves :: Envelope a -> [Envelope_Curve a]

-- | Maybe index to release node
env_release_node :: Envelope a -> Maybe Int

-- | Maybe index to loop node
env_loop_node :: Envelope a -> Maybe Int

-- | Variant without release and loop node inputs (defaulting to nil).
envelope :: [a] -> [a] -> [Envelope_Curve a] -> Envelope a

-- | Duration of <a>Envelope</a>, ie. <a>sum</a> <a>.</a> <a>env_times</a>.
envelope_duration :: Num n => Envelope n -> n

-- | Number of segments at <a>Envelope</a>, ie. <a>length</a> <a>.</a>
--   <a>env_times</a>.
envelope_n_segments :: (Num n, Integral i) => Envelope n -> i

-- | Determine which envelope segment a given time <i>t</i> falls in.
envelope_segment_ix :: (Ord a, Num a) => Envelope a -> a -> Maybe Int

-- | A set of start time, start level, end time, end level and curve.
type Envelope_Segment t = (t, t, t, t, Envelope_Curve t)

-- | Extract envelope segment given at index <i>i</i>.
envelope_segment :: Num t => Envelope t -> Int -> Envelope_Segment t

-- | Extract all segments.
envelope_segments :: Num t => Envelope t -> [Envelope_Segment t]

-- | Transform list of <a>Envelope_Segment</a>s into lists
--   (<a>env_levels</a>,<a>env_times</a>,<a>env_curves</a>).
pack_envelope_segments :: Num t => [Envelope_Segment t] -> ([t], [t], [Envelope_Curve t])

-- | An envelope is <i>normal</i> if it has no segments with zero duration.
envelope_is_normal :: (Eq n, Num n) => Envelope n -> Bool

-- | Normalise envelope by deleting segments of zero duration.
envelope_normalise :: (Num a, Ord a) => Envelope a -> Envelope a

-- | Get value for <a>Envelope</a> at time <i>t</i>, or zero if <i>t</i> is
--   out of range. By convention if the envelope has a segment of zero
--   duration we give the rightmost value.
envelope_at :: (Ord t, Floating t) => Envelope t -> t -> t

-- | Render <a>Envelope</a> to breakpoint set of <i>n</i> equi-distant
--   places.
envelope_render :: (Ord t, Floating t, Enum t) => t -> Envelope t -> [(t, t)]

-- | Contruct a lookup table of <i>n</i> places from <a>Envelope</a>.
envelope_table :: (Ord t, Floating t, Enum t) => t -> Envelope t -> [t]

-- | Variant on <a>env_curves</a> that expands the, possibly empty, user
--   list by cycling (if not empty) or by filling with <a>EnvLin</a>.
envelope_curves :: Num a => Envelope a -> [Envelope_Curve a]

-- | Linear SC3 form of <a>Envelope</a> data.
--   
--   Form is: l0 #t reset loop l1 t0 c0 c0' ...
--   
--   <pre>
--   let {l = [0,0.6,0.3,1.0,0]
--       ;t = [0.1,0.02,0.4,1.1]
--       ;c = [EnvLin,EnvExp,EnvNum (-6),EnvSin]
--       ;e = Envelope l t c Nothing Nothing
--       ;r = [0,4,-99,-99,0.6,0.1,1,0,0.3,0.02,2,0,1,0.4,5,-6,0,1.1,3,0]}
--   in envelope_sc3_array e == Just r
--   </pre>
envelope_sc3_array :: Num a => Envelope a -> Maybe [a]

-- | <tt>IEnvGen</tt> SC3 form of <a>Envelope</a> data. Offset not
--   supported (zero).
--   
--   <pre>
--   let {l = [0,0.6,0.3,1.0,0]
--       ;t = [0.1,0.02,0.4,1.1]
--       ;c = [EnvLin,EnvExp,EnvNum (-6),EnvSin]
--       ;e = Envelope l t c Nothing Nothing
--       ;r = [0,0,4,1.62,0.1,1,0,0.6,0.02,2,0,0.3,0.4,5,-6,1,1.1,3,0,0]}
--   in envelope_sc3_ienvgen_array e == Just r
--   </pre>
envelope_sc3_ienvgen_array :: Num a => Envelope a -> Maybe [a]

-- | <a>True</a> if <a>env_release_node</a> is not <a>Nothing</a>.
env_is_sustained :: Envelope a -> Bool

-- | Delay the onset of the envelope.
env_delay :: Envelope a -> a -> Envelope a

-- | Connect releaseNode (or end) to first node of envelope.
env_circle :: (Num a, Fractional a) => Envelope a -> a -> Envelope_Curve a -> Envelope a
envelope_to_ugen :: Envelope UGen -> UGen
d_dx :: Num a => [a] -> [a]
dx_d :: Num n => [n] -> [n]
d_dx' :: Num n => [n] -> [n]
dx_d' :: Num n => [n] -> [n]
instance Eq a => Eq (Envelope a)
instance Show a => Show (Envelope a)


-- | Unique identifier class for use by non-deterministic (noise) and
--   non-sharable (demand) unit generators.
module Sound.SC3.UGen.UId

-- | A class indicating a monad that will generate a sequence of unique
--   integer identifiers.
class (Functor m, Applicative m, MonadIO m) => UId m where generateUId = fmap hashUnique (liftIO newUnique)
generateUId :: UId m => m Int

-- | Unary function.
type Fn1 a b = a -> b

-- | Binary function.
type Fn2 a b c = a -> b -> c

-- | Ternary function.
type Fn3 a b c d = a -> b -> c -> d

-- | Quaternary function.
type Fn4 a b c d e = a -> b -> c -> d -> e

-- | Unary UId lift.
liftUId :: UId m => (Int -> Fn1 a b) -> Fn1 a (m b)

-- | Binary UId lift.
liftUId2 :: UId m => (Int -> Fn2 a b c) -> Fn2 a b (m c)

-- | Ternary UId lift.
liftUId3 :: UId m => (Int -> Fn3 a b c d) -> Fn3 a b c (m d)

-- | Quaternary UId lift.
liftUId4 :: UId m => (Int -> Fn4 a b c d e) -> Fn4 a b c d (m e)

-- | Clone a unit generator (mce . replicateM).
clone :: UId m => Int -> m UGen -> m UGen
instance (Transport t, Functor io, Applicative io, MonadIO io) => UId (ReaderT t io)
instance UId IO


-- | For hand-writing UGens.
module Sound.SC3.UGen.Bindings.HW.Construct

-- | Oscillator constructor with constrained set of operating <a>Rate</a>s.
mk_osc :: [Rate] -> UGenId -> Rate -> String -> [UGen] -> Int -> UGen

-- | Oscillator constructor with <a>all_rates</a>.
mkOsc :: Rate -> String -> [UGen] -> Int -> UGen

-- | Oscillator constructor, rate restricted variant.
mkOscR :: [Rate] -> Rate -> String -> [UGen] -> Int -> UGen

-- | Rate restricted oscillator constructor, setting identifier.
mkOscIdR :: [Rate] -> UGenId -> Rate -> String -> [UGen] -> Int -> UGen

-- | Oscillator constructor, setting identifier.
mkOscId :: UGenId -> Rate -> String -> [UGen] -> Int -> UGen

-- | Provided <a>UGenId</a> variant of <a>mkOscMCE</a>.
mk_osc_mce :: UGenId -> Rate -> String -> [UGen] -> UGen -> Int -> UGen

-- | Variant oscillator constructor with MCE collapsing input.
mkOscMCE :: Rate -> String -> [UGen] -> UGen -> Int -> UGen

-- | Variant oscillator constructor with MCE collapsing input.
mkOscMCEId :: UGenId -> Rate -> String -> [UGen] -> UGen -> Int -> UGen

-- | Rate constrained filter <a>UGen</a> constructor.
mk_filter :: [Rate] -> [Int] -> UGenId -> String -> [UGen] -> Int -> UGen

-- | Filter UGen constructor.
mkFilterIdR :: [Rate] -> UGenId -> String -> [UGen] -> Int -> UGen

-- | Filter UGen constructor.
mkFilterR :: [Rate] -> String -> [UGen] -> Int -> UGen

-- | Filter <a>UGen</a> constructor.
mkFilter :: String -> [UGen] -> Int -> UGen

-- | Filter UGen constructor.
mkFilterId :: UGenId -> String -> [UGen] -> Int -> UGen

-- | Provided <a>UGenId</a> filter with <a>mce</a> input.
mk_filter_mce :: [Rate] -> UGenId -> String -> [UGen] -> UGen -> Int -> UGen

-- | Variant filter constructor with MCE collapsing input.
mkFilterMCER :: [Rate] -> String -> [UGen] -> UGen -> Int -> UGen

-- | Variant filter constructor with MCE collapsing input.
mkFilterMCE :: String -> [UGen] -> UGen -> Int -> UGen

-- | Variant filter constructor with MCE collapsing input.
mkFilterMCEId :: UGenId -> String -> [UGen] -> UGen -> Int -> UGen

-- | Information unit generators are very specialized.
mkInfo :: String -> UGen


-- | F0 UGens.
module Sound.SC3.UGen.Bindings.HW.External.F0

-- | Emulation of the sound generation hardware of the Atari TIA chip.
atari2600 :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | POKEY Chip Sound Simulator
mzPokey :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen


-- | Zita UGen definitions.
--   
--   To build the SC3 plugin run <tt>faust2supercollider -d</tt> on
--   <tt>zita_rev1.dsp</tt>, which is in the <tt>examples</tt> directory of
--   Faust, see <a>http://faust.grame.fr/</a>.
module Sound.SC3.UGen.Bindings.HW.External.Zita
data ZitaRev1 a
ZitaRev1 :: a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> ZitaRev1 a
zr1_in1 :: ZitaRev1 a -> a
zr1_in2 :: ZitaRev1 a -> a
zr1_delay :: ZitaRev1 a -> a
zr1_xover :: ZitaRev1 a -> a
zr1_rtlow :: ZitaRev1 a -> a
zr1_rtmid :: ZitaRev1 a -> a
zr1_fdamp :: ZitaRev1 a -> a
zr1_eq1fr :: ZitaRev1 a -> a
zr1_eq1gn :: ZitaRev1 a -> a
zr1_eq2fr :: ZitaRev1 a -> a
zr1_eq2gn :: ZitaRev1 a -> a

-- | (-1,+1)
zr1_opmix :: ZitaRev1 a -> a
zr1_level :: ZitaRev1 a -> a
zitaRev1_r :: ZitaRev1 UGen -> UGen
zitaRev1 :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen


-- | Wavelet unit generators (Nick Collins).
module Sound.SC3.UGen.Bindings.HW.External.Wavelets

-- | Forward wavelet transform.
dwt :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Inverse of <a>dwt</a>.
idwt :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Pass wavelets above a threshold, ie. <tt>pv_MagAbove</tt>.
wt_MagAbove :: UGen -> UGen -> UGen

-- | Pass wavelets with <i>scale</i> above threshold.
wt_FilterScale :: UGen -> UGen -> UGen

-- | Pass wavelets with <i>time</i> above threshold.
wt_TimeWipe :: UGen -> UGen -> UGen

-- | Product in <i>W</i> domain, ie. <tt>pv_Mul</tt>.
wt_Mul :: UGen -> UGen -> UGen


-- | UGen data structure representation and associated functions.
module Sound.SC3.UGen.UGen

-- | <a>UId</a> of <a>resolveID</a>.
toUId :: ID a => a -> UGenId

-- | Lookup operator name for operator UGens, else UGen name.
ugen_user_name :: String -> Special -> String

-- | Depth first traversal of graph at <tt>u</tt> applying <tt>f</tt> to
--   each node.
ugenTraverse :: (UGen -> UGen) -> UGen -> UGen

-- | Right fold of UGen graph.
ugenFoldr :: (UGen -> a -> a) -> a -> UGen -> a

-- | Control input node constructor.
control_f64 :: Rate -> Maybe Int -> String -> Sample -> UGen

-- | Control input node constructor.
--   
--   Note that if the name begins with a t_ prefix the control is
--   <i>not</i> converted to a triggered control. Please see
--   <a>tr_control</a>.
control :: Rate -> String -> Double -> UGen

-- | Variant of <a>control</a> with meta data.
meta_control :: Rate -> String -> Double -> C_Meta' Double -> UGen

-- | Triggered (kr) control input node constructor.
tr_control_f64 :: Maybe Int -> String -> Sample -> UGen

-- | Triggered (kr) control input node constructor.
tr_control :: String -> Double -> UGen

-- | Set indices at a list of controls.
control_set :: [UGen] -> [UGen]

-- | Multiple root graph node constructor.
mrg2 :: UGen -> UGen -> UGen

-- | Multiple channel expansion for two inputs.
mce2 :: UGen -> UGen -> UGen

-- | Extract two channels from possible MCE.
mce2c :: UGen -> (UGen, UGen)

-- | Multiple channel expansion for two inputs.
mce3 :: UGen -> UGen -> UGen -> UGen

-- | Apply a function to each channel at a unit generator.
mceMap :: (UGen -> UGen) -> UGen -> UGen

-- | Apply UGen list operation on MCE contents.
mceEdit :: ([UGen] -> [UGen]) -> UGen -> UGen

-- | Reverse order of channels at MCE.
mceReverse :: UGen -> UGen

-- | Obtain indexed channel at MCE.
mceChannel :: Int -> UGen -> UGen

-- | Transpose rows and columns, ie. {{a,b},{c,d}} to {{a,c},{b,d}}.
mceTranspose :: UGen -> UGen

-- | Collapse mce by summing (see also mix and mixN).
mceSum :: UGen -> UGen

-- | Separate first list element.
--   
--   <pre>
--   sep_first "astring" == Just ('a',"string")
--   </pre>
sep_first :: [t] -> Maybe (t, [t])

-- | Separate last list element.
--   
--   <pre>
--   sep_last "stringb" == Just ("string",'b')
--   </pre>
sep_last :: [t] -> Maybe ([t], t)

-- | Given <i>unmce</i> function make halt mce transform.
halt_mce_transform' :: (a -> [a]) -> [a] -> [a]

-- | The halt MCE transform, ie. lift channels of last input into list.
--   
--   <pre>
--   halt_mce_transform [1,2,mce2 3 4] == [1,2,3,4]
--   </pre>
halt_mce_transform :: [UGen] -> [UGen]

-- | Lift a <a>String</a> to a UGen label (ie. for <tt>poll</tt>).
label :: String -> UGen

-- | Are lists of equal length?
--   
--   <pre>
--   equal_length_p ["t1","t2"] == True
--   equal_length_p ["t","t1","t2"] == False
--   </pre>
equal_length_p :: [[a]] -> Bool

-- | Unpack a label to a length prefixed list of <a>Constant</a>s. There is
--   a special case for mce nodes, but it requires labels to be equal
--   length. Properly, <tt>poll</tt> would not unpack the label, it would
--   be done by the synthdef builder.
unpackLabel :: UGen -> [UGen]
bitAnd :: UGen -> UGen -> UGen
bitOr :: UGen -> UGen -> UGen
bitXOr :: UGen -> UGen -> UGen
bitNot :: UGen -> UGen
shiftLeft :: UGen -> UGen -> UGen
shiftRight :: UGen -> UGen -> UGen
unsignedShift :: UGen -> UGen -> UGen
(.<<.) :: UGen -> UGen -> UGen
(.>>.) :: UGen -> UGen -> UGen

-- | UGen primitive. Sees through Proxy and MRG, possible multiple
--   primitives for MCE.
ugen_primitive :: UGen -> [Primitive]

-- | Heuristic based on primitive name (<tt>FFT</tt>, <tt>PV_</tt>). Note
--   that <tt>IFFT</tt> is at <i>control</i> rate, not <tt>PV</tt> rate.
primitive_is_pv_rate :: String -> Bool

-- | Variant on primitive_is_pv_rate.
ugen_is_pv_rate :: UGen -> Bool

-- | Traverse input graph until an <tt>FFT</tt> or <tt>PV_Split</tt> node
--   is encountered, and then locate the buffer input. Biases left at MCE
--   nodes.
--   
--   <pre>
--   import Sound.SC3
--   let z = soundIn 4
--   let f1 = fft 10 z 0.5 0 1 0
--   let f2 = ffta 'a' 1024 z 0.5 0 1 0
--   pv_track_buffer (pv_BrickWall f1 0.5) == Right 10
--   pv_track_buffer (pv_BrickWall f2 0.5) == Right (localBuf 'a' 1024 1)
--   </pre>
pv_track_buffer :: UGen -> Either String UGen

-- | Buffer node number of frames. Biases left at MCE nodes. Sees through
--   <tt>LocalBuf</tt>, otherwise uses <tt>bufFrames</tt>.
--   
--   <pre>
--   buffer_nframes 10 == bufFrames IR 10
--   buffer_nframes (control KR "b" 0) == bufFrames KR (control KR "b" 0)
--   buffer_nframes (localBuf '' 2048 1) == 2048
--   </pre>
buffer_nframes :: UGen -> UGen

-- | <a>pv_track_buffer</a> then <a>buffer_nframes</a>.
pv_track_nframes :: UGen -> Either String UGen


-- | <a>Graph</a> and related types.
module Sound.SC3.UGen.Graph

-- | Node identifier.
type NodeId = Int

-- | Port index.
type PortIndex = Int

-- | Type to represent unit generator graph.
data Graph
Graph :: NodeId -> [Node] -> [Node] -> [Node] -> Graph
nextId :: Graph -> NodeId
constants :: Graph -> [Node]
controls :: Graph -> [Node]
ugens :: Graph -> [Node]

-- | Enumeration of the four operating rates for controls.
data KType
K_IR :: KType
K_KR :: KType
K_TR :: KType
K_AR :: KType

-- | Type to represent the left hand side of an edge in a unit generator
--   graph.
data FromPort
FromPort_C :: NodeId -> FromPort
port_nid :: FromPort -> NodeId
FromPort_K :: NodeId -> KType -> FromPort
port_nid :: FromPort -> NodeId
port_kt :: FromPort -> KType
FromPort_U :: NodeId -> Maybe PortIndex -> FromPort
port_nid :: FromPort -> NodeId
port_idx :: FromPort -> Maybe PortIndex

-- | A destination port.
data ToPort
ToPort :: NodeId -> PortIndex -> ToPort

-- | A connection from <a>FromPort</a> to <a>ToPort</a>.
type Edge = (FromPort, ToPort)

-- | Type to represent nodes in unit generator graph.
data Node
NodeC :: NodeId -> Sample -> Node
node_id :: Node -> NodeId
node_c_value :: Node -> Sample
NodeK :: NodeId -> Rate -> Maybe Int -> String -> Sample -> KType -> Maybe (C_Meta Sample) -> Node
node_id :: Node -> NodeId
node_k_rate :: Node -> Rate
node_k_index :: Node -> Maybe Int
node_k_name :: Node -> String
node_k_default :: Node -> Sample
node_k_type :: Node -> KType
node_k_meta :: Node -> Maybe (C_Meta Sample)
NodeU :: NodeId -> Rate -> String -> [FromPort] -> [Output] -> Special -> UGenId -> Node
node_id :: Node -> NodeId
node_u_rate :: Node -> Rate
node_u_name :: Node -> String
node_u_inputs :: Node -> [FromPort]
node_u_outputs :: Node -> [Output]
node_u_special :: Node -> Special
node_u_ugenid :: Node -> UGenId
NodeP :: NodeId -> Node -> PortIndex -> Node
node_id :: Node -> NodeId
node_p_node :: Node -> Node
node_p_index :: Node -> PortIndex
node_k_eq :: Node -> Node -> Bool

-- | Find <a>Node</a> with indicated <a>NodeId</a>.
find_node :: Graph -> NodeId -> Maybe Node

-- | Generate a label for <a>Node</a> using the <i>type</i> and the
--   <a>node_id</a>.
node_label :: Node -> String

-- | Get <a>port_idx</a> for <a>FromPort_U</a>, else <tt>0</tt>.
port_idx_or_zero :: FromPort -> PortIndex

-- | Is <a>Node</a> a <i>constant</i>.
is_node_c :: Node -> Bool

-- | Is <a>Node</a> a <i>control</i>.
is_node_k :: Node -> Bool

-- | Is <a>Node</a> a <i>UGen</i>.
is_node_u :: Node -> Bool

-- | Calculate all edges given a set of <a>NodeU</a>.
edges :: [Node] -> [Edge]

-- | Transform <a>Node</a> to <a>FromPort</a>.
as_from_port :: Node -> FromPort

-- | Locate <a>Node</a> of <a>FromPort</a> in <a>Graph</a>.
from_port_node :: Graph -> FromPort -> Maybe Node

-- | The empty <a>Graph</a>.
empty_graph :: Graph

-- | Find the maximum <a>NodeId</a> used at <a>Graph</a> (this ought
--   normally be the <a>nextId</a>).
graph_maximum_id :: Graph -> NodeId

-- | Compare <a>NodeK</a> values <a>on</a> <a>node_k_type</a>.
node_k_cmp :: Node -> Node -> Ordering

-- | Determine class of control given <a>Rate</a> and <i>trigger</i>
--   status.
ktype :: Rate -> Bool -> KType

-- | Predicate to determine if <a>Node</a> is a constant with indicated
--   <i>value</i>.
find_c_p :: Sample -> Node -> Bool

-- | Insert a constant <a>Node</a> into the <a>Graph</a>.
push_c :: Sample -> Graph -> (Node, Graph)

-- | Either find existing <a>Constant</a> <a>Node</a>, or insert a new
--   <a>Node</a>.
mk_node_c :: Constant -> Graph -> (Node, Graph)

-- | Predicate to determine if <a>Node</a> is a control with indicated
--   <i>name</i>. Names must be unique.
find_k_p :: String -> Node -> Bool

-- | Insert a control node into the <a>Graph</a>.
push_k :: Control -> Graph -> (Node, Graph)

-- | Either find existing <a>Control</a> <a>Node</a>, or insert a new
--   <a>Node</a>.
mk_node_k :: Control -> Graph -> (Node, Graph)
type UGenParts = (Rate, String, [FromPort], [Output], Special, UGenId)

-- | Predicate to locate primitive, names must be unique.
find_u_p :: UGenParts -> Node -> Bool

-- | Insert a <i>primitive</i> <a>NodeU</a> into the <a>Graph</a>.
push_u :: UGenParts -> Graph -> (Node, Graph)
mk_node_u_acc :: [UGen] -> [Node] -> Graph -> ([Node], Graph)

-- | Either find existing <a>Primitive</a> node, or insert a new
--   <a>Node</a>.
mk_node_u :: Primitive -> Graph -> (Node, Graph)

-- | Proxies do not get stored in the graph.
mk_node_p :: Node -> PortIndex -> Graph -> (Node, Graph)

-- | Transform <a>UGen</a> into <a>Graph</a>, appending to existing
--   <a>Graph</a>.
mk_node :: UGen -> Graph -> (Node, Graph)

-- | Transform <i>mce</i> nodes to <i>mrg</i> nodes
prepare_root :: UGen -> UGen

-- | If controls have been given indices they must be coherent.
sort_controls :: [Node] -> [Node]

-- | Variant on <a>mk_node</a> starting with an empty graph, reverses the
--   <a>UGen</a> list and sorts the <a>Control</a> list, and adds implicit
--   nodes.
mk_graph :: UGen -> Graph
type Map = IntMap Int
type Maps = (Map, [Node], Map, Map, [(KType, Int)])

-- | Determine <a>KType</a> of a <i>control</i> UGen at <a>NodeU</a>, or
--   not.
node_ktype :: Node -> Maybe KType

-- | Map associating <a>KType</a> with UGen index.
mk_ktype_map :: [Node] -> [(KType, Int)]

-- | Lookup <a>KType</a> index from map (erroring variant of
--   <a>lookup</a>).
ktype_map_lookup :: KType -> [(KType, Int)] -> Int

-- | Generate <a>Maps</a> translating node identifiers to synthdef indexes.
mk_maps :: Graph -> Maps

-- | Locate index in map given node identifer <a>NodeId</a>.
fetch :: NodeId -> Map -> Int

-- | Controls are a special case. We need to know not the overall index but
--   the index in relation to controls of the same type.
fetch_k :: NodeId -> KType -> [Node] -> Int

-- | 4-tuple to count <a>KType</a>s.
type KS_COUNT = (Int, Int, Int, Int)

-- | Count the number of <i>controls</i> of each <a>KType</a>.
ks_count :: [Node] -> KS_COUNT

-- | Construct implicit <i>control</i> unit generator <tt>Nodes</tt>. Unit
--   generators are only constructed for instances of control types that
--   are present.
mk_implicit_ctl :: [Node] -> [Node]

-- | Add implicit <i>control</i> UGens to <a>Graph</a>.
add_implicit_ctl :: Graph -> Graph

-- | Zero if no local buffers, or if maxLocalBufs is given.
localbuf_count :: [Node] -> Int

-- | Add implicit <tt>maxLocalBufs</tt> if not present.
add_implicit_buf :: Graph -> Graph

-- | <a>add_implicit_buf</a> and <a>add_implicit_ctl</a>.
add_implicit :: Graph -> Graph

-- | Is <a>Node</a> an <i>implicit</i> control UGen?
is_implicit_control :: Node -> Bool

-- | Is Node implicit?
is_implicit :: Node -> Bool

-- | Remove implicit UGens from <a>Graph</a>
remove_implicit :: Graph -> Graph

-- | Is <a>FromPort</a> <a>FromPort_U</a>.
is_from_port_u :: FromPort -> Bool

-- | List of <a>FromPort_U</a> at <i>e</i> with multiple out edges.
multiple_u_out_edges :: [Edge] -> [FromPort]

-- | Descendents at <a>Graph</a> of <a>Node</a>.
node_descendents :: Graph -> Node -> [Node]

-- | List <tt>PV</tt> <a>Node</a>s at <a>Graph</a> with multiple out edges.
pv_multiple_out_edges :: Graph -> [Node]

-- | Error if graph has invalid <tt>PV</tt> subgraph, ie. multiple out
--   edges at <tt>PV</tt> node not connecting to <tt>Unpack1FFT</tt> &amp;
--   <tt>PackFFT</tt>.
pv_validate :: Graph -> Graph

-- | Transform a unit generator into a graph.
--   
--   <pre>
--   import Sound.SC3.UGen
--   ugen_to_graph (out 0 (pan2 (sinOsc AR 440 0) 0.5 0.1))
--   </pre>
ugen_to_graph :: UGen -> Graph
instance Eq KType
instance Show KType
instance Ord KType
instance Eq FromPort
instance Show FromPort
instance Eq ToPort
instance Show ToPort
instance Show Node
instance Show Graph


-- | Transform <a>Graph</a> to <tt>Graphdef</tt>.
module Sound.SC3.Server.Graphdef.Graph

-- | Construct <tt>Input</tt> form required by byte-code generator.
make_input :: Maps -> FromPort -> Input
node_k_to_control :: Maps -> Node -> Control

-- | Byte-encode <a>NodeU</a> primitive node.
node_u_to_ugen :: Maps -> Node -> UGen

-- | Construct instrument definition bytecode.
graph_to_graphdef :: String -> Graph -> Graphdef


-- | Transform (read) a <a>Graphdef</a> into a <tt>Graph</tt>.
module Sound.SC3.Server.Graphdef.Read
mk_node_k :: Graphdef -> NodeId -> (Control, Sample) -> Node
input_to_from_port :: Graphdef -> Input -> FromPort
mk_node_u :: Graphdef -> NodeId -> UGen -> Node
graphdef_to_graph :: Graphdef -> (String, Graph)


-- | Transformations over <a>Graph</a> structure.
module Sound.SC3.UGen.Graph.Transform

-- | Transform <a>NodeC</a> to <a>NodeK</a>, <a>id</a> for other
--   <a>Node</a> types.
--   
--   <pre>
--   let r = (NodeK 8 KR Nothing "k_8" 0.1 K_KR,9)
--   in constant_to_control 8 (NodeC 0 0.1) == r
--   </pre>
constant_to_control :: NodeId -> Node -> (NodeId, Node)

-- | Erroring variant of <a>from_port_node</a>.
from_port_node_err :: Graph -> FromPort -> Node

-- | If the <a>FromPort</a> is a <i>constant</i> generate a <i>control</i>
--   <a>Node</a>, else retain <a>FromPort</a>.
c_lift_from_port :: Graph -> NodeId -> FromPort -> (NodeId, Either FromPort Node)

-- | Lift a set of <a>NodeU</a> <i>inputs</i> from constants to controls.
--   The result triple gives the incremented <a>NodeId</a>, the transformed
--   <a>FromPort</a> list, and the list of newly minted control
--   <a>Node</a>s.
c_lift_inputs :: Graph -> NodeId -> [FromPort] -> (NodeId, [FromPort], [Node])
c_lift_ugen :: Graph -> NodeId -> Node -> (NodeId, Node, [Node])
c_lift_ugens :: Graph -> NodeId -> [Node] -> (NodeId, [Node], [Node])
lift_constants :: Graph -> Graph


-- | Functions to re-write assigned node identifiers at UGen graphs. Used
--   carefully it allows for composition of sub-graphs with psuedo-random
--   nodes.
module Sound.SC3.UGen.Protect

-- | Collect Ids at UGen graph
ugenIds :: UGen -> [UGenId]

-- | Apply <i>f</i> at <a>UId</a>, or no-op at <a>NoId</a>.
atUGenId :: (Int -> Int) -> UGenId -> UGenId

-- | Add <tt>idHash</tt> of <i>e</i> to all <a>Primitive_U</a> at <i>u</i>.
uprotect :: ID a => a -> UGen -> UGen

-- | Variant of <a>uprotect</a> with subsequent identifiers derived by
--   incrementing initial identifier.
uprotect' :: ID a => a -> [UGen] -> [UGen]

-- | Make <i>n</i> parallel instances of <a>UGen</a> with protected
--   identifiers.
uclone' :: ID a => a -> Int -> UGen -> [UGen]

-- | <a>mce</a> variant of <a>uclone'</a>.
uclone :: ID a => a -> Int -> UGen -> UGen

-- | Left to right UGen function composition with <a>UGenId</a> protection.
ucompose :: ID a => a -> [UGen -> UGen] -> UGen -> UGen

-- | Make <i>n</i> sequential instances of <tt>f</tt> with protected Ids.
useq :: ID a => a -> Int -> (UGen -> UGen) -> UGen -> UGen

module Sound.SC3.UGen.Bindings.DB

-- | Audio to control rate converter.
a2K :: UGen -> UGen

-- | FIXME: APF purpose.
apf :: UGen -> UGen -> UGen -> UGen

-- | All pass delay line with cubic interpolation.
allpassC :: UGen -> UGen -> UGen -> UGen -> UGen

-- | All pass delay line with linear interpolation.
allpassL :: UGen -> UGen -> UGen -> UGen -> UGen

-- | All pass delay line with no interpolation.
allpassN :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Basic psychoacoustic amplitude compensation.
ampComp :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Basic psychoacoustic amplitude compensation (ANSI A-weighting curve).
ampCompA :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Amplitude follower
amplitude :: Rate -> UGen -> UGen -> UGen -> UGen

-- | (Undocumented class)
audioControl :: Rate -> UGen -> UGen

-- | All Pass Filter
bAllPass :: UGen -> UGen -> UGen -> UGen

-- | Band Pass Filter
bBandPass :: UGen -> UGen -> UGen -> UGen

-- | Band reject filter
bBandStop :: UGen -> UGen -> UGen -> UGen

-- | 12db/oct rolloff - 2nd order resonant Hi Pass Filter
bHiPass :: UGen -> UGen -> UGen -> UGen

-- | Hi Shelf
bHiShelf :: UGen -> UGen -> UGen -> UGen -> UGen

-- | 12db/oct rolloff - 2nd order resonant Low Pass Filter
bLowPass :: UGen -> UGen -> UGen -> UGen

-- | Low Shelf
bLowShelf :: UGen -> UGen -> UGen -> UGen -> UGen

-- | 2nd order Butterworth bandpass filter.
bpf :: UGen -> UGen -> UGen -> UGen

-- | Two zero fixed midpass.
bpz2 :: UGen -> UGen

-- | Parametric equalizer
bPeakEQ :: UGen -> UGen -> UGen -> UGen -> UGen

-- | 2nd order Butterworth band reject filter.
brf :: UGen -> UGen -> UGen -> UGen

-- | Two zero fixed midcut.
brz2 :: UGen -> UGen

-- | Stereo signal balancer
balance2 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | physical model of bouncing object
ball :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Autocorrelation beat tracker
beatTrack :: Rate -> UGen -> UGen -> UGen

-- | Template matching beat tracker
beatTrack2 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | 2D Ambisonic B-format panner.
biPanB2 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Apply a binary operation to the values of an input UGen
binaryOpUGen :: UGen -> UGen -> UGen

-- | Band limited impulse oscillator.
blip :: Rate -> UGen -> UGen -> UGen

-- | (Undocumented class)
blockSize :: UGen

-- | Brown Noise.
brownNoise :: ID a => a -> Rate -> UGen

-- | Buffer based all pass delay line with cubic interpolation.
bufAllpassC :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Buffer based all pass delay line with linear interpolation.
bufAllpassL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Buffer based all pass delay line with no interpolation.
bufAllpassN :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Current number of channels of soundfile in buffer.
bufChannels :: Rate -> UGen -> UGen

-- | Buffer based comb delay line with cubic interpolation.
bufCombC :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Buffer based comb delay line with linear interpolation.
bufCombL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Buffer based comb delay line with no interpolation.
bufCombN :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Buffer based simple delay line with cubic interpolation.
bufDelayC :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Buffer based simple delay line with linear interpolation.
bufDelayL :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Buffer based simple delay line with no interpolation.
bufDelayN :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Current duration of soundfile in buffer.
bufDur :: Rate -> UGen -> UGen

-- | Current number of frames allocated in the buffer.
bufFrames :: Rate -> UGen -> UGen

-- | Buffer rate scaling in respect to server samplerate.
bufRateScale :: Rate -> UGen -> UGen

-- | Buffer reading oscillator.
bufRd :: Int -> Rate -> UGen -> UGen -> Loop -> Interpolation -> UGen

-- | Buffer sample rate.
bufSampleRate :: Rate -> UGen -> UGen

-- | Current number of samples in buffer.
bufSamples :: Rate -> UGen -> UGen

-- | Buffer writing oscillator.
bufWr :: UGen -> UGen -> Loop -> UGen -> UGen

-- | Chorusing wavetable oscillator.
cOsc :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Test for infinity, not-a-number, and denormals
checkBadValues :: UGen -> UGen -> UGen -> UGen

-- | Clip a signal outside given thresholds.
clip :: UGen -> UGen -> UGen -> UGen

-- | Clip Noise.
clipNoise :: ID a => a -> Rate -> UGen

-- | Statistical gate.
coinGate :: ID a => a -> UGen -> UGen -> UGen

-- | Comb delay line with cubic interpolation.
combC :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Comb delay line with linear interpolation.
combL :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Comb delay line with no interpolation.
combN :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Compressor, expander, limiter, gate, ducker
compander :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Compressor, expander, limiter, gate, ducker.
companderD :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Duration of one block
controlDur :: UGen

-- | Server control rate.
controlRate :: UGen

-- | Real-time convolver.
convolution :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Real-time fixed kernel convolver.
convolution2 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Real-time convolver with linear interpolation
convolution2L :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Time based convolver.
convolution3 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Chaotic noise function.
crackle :: Rate -> UGen -> UGen

-- | Cusp map chaotic generator
cuspL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Cusp map chaotic generator
cuspN :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Create a constant amplitude signal
dc :: Rate -> UGen -> UGen

-- | Demand rate brownian movement generator.
dbrown :: ID a => a -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Buffer read demand ugen
dbufrd :: ID a => a -> UGen -> UGen -> Loop -> UGen

-- | Buffer write demand ugen
dbufwr :: ID a => a -> UGen -> UGen -> UGen -> Loop -> UGen

-- | Exponential decay
decay :: UGen -> UGen -> UGen

-- | Exponential decay
decay2 :: UGen -> UGen -> UGen -> UGen

-- | 2D Ambisonic B-format decoder.
decodeB2 :: Int -> Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Convert signal to modal pitch.
degreeToKey :: UGen -> UGen -> UGen -> UGen

-- | Tap a delay line from a DelTapWr UGen
delTapRd :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Write to a buffer for a DelTapRd UGen
delTapWr :: UGen -> UGen -> UGen

-- | Single sample delay.
delay1 :: UGen -> UGen

-- | Two sample delay.
delay2 :: UGen -> UGen

-- | Simple delay line with cubic interpolation.
delayC :: UGen -> UGen -> UGen -> UGen

-- | Simple delay line with linear interpolation.
delayL :: UGen -> UGen -> UGen -> UGen

-- | Simple delay line with no interpolation.
delayN :: UGen -> UGen -> UGen -> UGen

-- | Demand results from demand rate UGens.
demand :: UGen -> UGen -> UGen -> UGen

-- | Demand rate envelope generator
demandEnvGen :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> DoneAction -> UGen

-- | Search a buffer for a value
detectIndex :: UGen -> UGen -> UGen

-- | When input falls below a threshhold, evaluate doneAction.
detectSilence :: UGen -> UGen -> UGen -> DoneAction -> UGen

-- | Demand rate geometric series UGen.
dgeom :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Demand rate brownian movement generator.
dibrown :: ID a => a -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Stream in audio from a file.
diskIn :: Int -> UGen -> Loop -> UGen

-- | Record to a soundfile to disk.
diskOut :: UGen -> UGen -> UGen

-- | Demand rate white noise random generator.
diwhite :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | (Undocumented class)
donce :: ID a => a -> UGen -> UGen

-- | Monitors another UGen to see when it is finished
done :: Rate -> UGen -> UGen

-- | Print the current output value of a demand rate UGen
dpoll :: ID a => a -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Demand rate random sequence generator.
drand :: ID a => a -> UGen -> UGen -> UGen

-- | demand rate reset
dreset :: ID a => a -> UGen -> UGen -> UGen

-- | Demand rate sequence generator.
dseq :: ID a => a -> UGen -> UGen -> UGen

-- | Demand rate sequence generator.
dser :: ID a => a -> UGen -> UGen -> UGen

-- | Demand rate arithmetic series UGen.
dseries :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Demand rate random sequence generator
dshuf :: ID a => a -> UGen -> UGen -> UGen

-- | Demand rate input replicator
dstutter :: ID a => a -> UGen -> UGen -> UGen

-- | Demand rate generator for embedding different inputs
dswitch :: ID a => a -> UGen -> UGen -> UGen

-- | Demand rate generator for switching between inputs.
dswitch1 :: ID a => a -> UGen -> UGen -> UGen

-- | Return the same unique series of values for several demand streams
dunique :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Random impulses.
dust :: ID a => a -> Rate -> UGen -> UGen

-- | Random impulses.
dust2 :: ID a => a -> Rate -> UGen -> UGen

-- | Demand results from demand rate UGens.
duty :: Rate -> UGen -> UGen -> DoneAction -> UGen -> UGen

-- | Demand rate white noise random generator.
dwhite :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Demand rate weighted random sequence generator dwrand :: ID a =&gt; a
--   -&gt; UGen -&gt; UGen -&gt; UGen -&gt; UGen dwrand z repeats weights
--   list_ = mkUGen Nothing [DR] (Left DR) <a>Dwrand</a> [repeats,weights]
--   (Just list_) 1 (Special 0) (toUId z)
--   
--   Demand rate random sequence generator.
dxrand :: ID a => a -> UGen -> UGen -> UGen

-- | Envelope generator
envGen :: Rate -> UGen -> UGen -> UGen -> UGen -> DoneAction -> Envelope UGen -> UGen

-- | Exponential single random number generator.
expRand :: ID a => a -> UGen -> UGen -> UGen

-- | Feedback sine with chaotic phase indexing
fBSineC :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Feedback sine with chaotic phase indexing
fBSineL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Feedback sine with chaotic phase indexing
fBSineN :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Fast Fourier Transform
fft :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | First order filter section.
fos :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Fast sine oscillator.
fSinOsc :: Rate -> UGen -> UGen -> UGen

-- | Fold a signal outside given thresholds.
fold :: UGen -> UGen -> UGen -> UGen

-- | Formant oscillator
formant :: Rate -> UGen -> UGen -> UGen -> UGen

-- | FOF-like filter.
formlet :: UGen -> UGen -> UGen -> UGen -> UGen

-- | When triggered, frees a node.
free :: UGen -> UGen -> UGen

-- | When triggered, free enclosing synth.
freeSelf :: UGen -> UGen

-- | Free the enclosing synth when a UGen is finished
freeSelfWhenDone :: Rate -> UGen -> UGen

-- | A reverb
freeVerb :: UGen -> UGen -> UGen -> UGen -> UGen

-- | A two-channel reverb
freeVerb2 :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Frequency Shifter.
freqShift :: UGen -> UGen -> UGen -> UGen

-- | A two-channel reverb
gVerb :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Gate or hold.
gate :: UGen -> UGen -> UGen

-- | Gingerbreadman map chaotic generator
gbmanL :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Gingerbreadman map chaotic generator
gbmanN :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Dynamic stochastic synthesis generator.
gendy1 :: ID a => a -> Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Dynamic stochastic synthesis generator.
gendy2 :: ID a => a -> Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Dynamic stochastic synthesis generator.
gendy3 :: ID a => a -> Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Granular synthesis with sound stored in a buffer
grainBuf :: Int -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Granular synthesis with frequency modulated sine tones
grainFM :: Int -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Granulate an input signal
grainIn :: Int -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Granular synthesis with sine tones
grainSin :: Int -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Gray Noise.
grayNoise :: ID a => a -> Rate -> UGen

-- | 2nd order Butterworth highpass filter.
hpf :: UGen -> UGen -> UGen

-- | Two point difference filter
hpz1 :: UGen -> UGen

-- | Two zero fixed midcut.
hPZ2 :: UGen -> UGen

-- | Randomized value.
hasher :: UGen -> UGen

-- | Henon map chaotic generator
henonC :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Henon map chaotic generator
henonL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Henon map chaotic generator
henonN :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Applies the Hilbert transform to an input signal.
hilbert :: UGen -> UGen

-- | Applies the Hilbert transform to an input signal.
hilbertFIR :: Rate -> UGen -> UGen -> UGen

-- | Envelope generator for polling values from an Env
iEnvGen :: Rate -> UGen -> Envelope UGen -> UGen

-- | Inverse Fast Fourier Transform
ifft :: UGen -> UGen -> UGen -> UGen

-- | Single integer random number generator.
iRand :: ID a => a -> UGen -> UGen -> UGen

-- | Impulse oscillator.
impulse :: Rate -> UGen -> UGen -> UGen

-- | Read a signal from a bus.
in' :: Int -> Rate -> UGen -> UGen

-- | Read signal from a bus with a current or one cycle old timestamp.
inFeedback :: Int -> UGen -> UGen

-- | Tests if a signal is within a given range.
inRange :: UGen -> UGen -> UGen -> UGen

-- | Test if a point is within a given rectangle.
inRect :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Generate a trigger anytime a bus is set.
inTrig :: Int -> Rate -> UGen -> UGen

-- | Index into a table with a signal
index :: UGen -> UGen -> UGen

-- | Finds the (lowest) point in the Buffer at which the input signal lies
--   in-between the two values
indexInBetween :: Rate -> UGen -> UGen -> UGen

-- | Index into a table with a signal, linear interpolated
indexL :: Rate -> UGen -> UGen -> UGen

-- | Base class for info ugens
infoUGenBase :: Rate -> UGen

-- | A leaky integrator.
integrator :: UGen -> UGen -> UGen

-- | Control to audio rate converter.
k2A :: UGen -> UGen

-- | Respond to the state of a key
keyState :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Key tracker
keyTrack :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Sine oscillator bank
klang :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Bank of resonators
klank :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Clipped noise
lfClipNoise :: ID a => a -> Rate -> UGen -> UGen

-- | A sine like shape made of two cubic pieces
lfCub :: Rate -> UGen -> UGen -> UGen

-- | Dynamic clipped noise
lfdClipNoise :: ID a => a -> Rate -> UGen -> UGen

-- | Dynamic step noise
lfdNoise0 :: ID a => a -> Rate -> UGen -> UGen

-- | Dynamic ramp noise
lfdNoise1 :: ID a => a -> Rate -> UGen -> UGen

-- | Dynamic cubic noise
lfdNoise3 :: ID a => a -> Rate -> UGen -> UGen

-- | Gaussian function oscillator
lfGauss :: Rate -> UGen -> UGen -> UGen -> Loop -> DoneAction -> UGen

-- | Step noise
lfNoise0 :: ID a => a -> Rate -> UGen -> UGen

-- | Ramp noise
lfNoise1 :: ID a => a -> Rate -> UGen -> UGen

-- | Quadratic noise.
lfNoise2 :: ID a => a -> Rate -> UGen -> UGen

-- | Parabolic oscillator
lfPar :: Rate -> UGen -> UGen -> UGen

-- | pulse oscillator
lfPulse :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Sawtooth oscillator
lfSaw :: Rate -> UGen -> UGen -> UGen

-- | Triangle oscillator
lfTri :: Rate -> UGen -> UGen -> UGen

-- | 2nd order Butterworth lowpass filter
lpf :: UGen -> UGen -> UGen

-- | Two point average filter
lpz1 :: UGen -> UGen

-- | Two zero fixed lowpass
lPZ2 :: UGen -> UGen

-- | Exponential lag
lag :: UGen -> UGen -> UGen

-- | Exponential lag
lag2 :: UGen -> UGen -> UGen

-- | Exponential lag
lag2UD :: UGen -> UGen -> UGen -> UGen

-- | Exponential lag
lag3 :: UGen -> UGen -> UGen

-- | Exponential lag
lag3UD :: UGen -> UGen -> UGen -> UGen

-- | Read a control signal from a bus with a lag
lagIn :: Int -> UGen -> UGen -> UGen

-- | Exponential lag
lagUD :: UGen -> UGen -> UGen -> UGen

-- | Output the last value before the input changed
lastValue :: UGen -> UGen -> UGen

-- | Sample and hold
latch :: UGen -> UGen -> UGen

-- | Latoocarfian chaotic generator
latoocarfianC :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Latoocarfian chaotic generator
latoocarfianL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Latoocarfian chaotic generator
latoocarfianN :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Remove DC
leakDC :: UGen -> UGen -> UGen

-- | Output least changed
leastChange :: Rate -> UGen -> UGen -> UGen

-- | Peak limiter
limiter :: UGen -> UGen -> UGen -> UGen

-- | Linear congruential chaotic generator
linCongC :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Linear congruential chaotic generator
linCongL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Linear congruential chaotic generator
linCongN :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Map a linear range to an exponential range
linExp :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Two channel linear pan.
linPan2 :: UGen -> UGen -> UGen -> UGen

-- | Skewed random number generator.
linRand :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Two channel linear crossfade.
linXFade2 :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Line generator.
line :: Rate -> UGen -> UGen -> UGen -> DoneAction -> UGen

-- | Simple linear envelope generator.
linen :: UGen -> UGen -> UGen -> UGen -> DoneAction -> UGen

-- | Allocate a buffer local to the synth
localBuf :: ID a => a -> UGen -> UGen -> UGen

-- | Define and read from buses local to a synth.
localIn :: Int -> Rate -> UGen -> UGen

-- | Write to buses local to a synth.
localOut :: UGen -> UGen

-- | Chaotic noise function
logistic :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Lorenz chaotic generator
lorenzL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Extraction of instantaneous loudness in sones
loudness :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Mel frequency cepstral coefficients
mFCC :: Rate -> UGen -> UGen -> UGen

-- | Reduce precision.
mantissaMask :: UGen -> UGen -> UGen

-- | Median filter.
median :: UGen -> UGen -> UGen

-- | Parametric filter.
midEQ :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Minimum difference of two values in modulo arithmetics
modDif :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Moog VCF implementation, designed by Federico Fontana
moogFF :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Output most changed.
mostChange :: UGen -> UGen -> UGen

-- | Mouse button UGen.
mouseButton :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Cursor tracking UGen.
mouseX :: Rate -> UGen -> UGen -> Warp -> UGen -> UGen

-- | Cursor tracking UGen.
mouseY :: Rate -> UGen -> UGen -> Warp -> UGen -> UGen

-- | Sum of uniform distributions.
nRand :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Flattens dynamics.
normalizer :: UGen -> UGen -> UGen -> UGen

-- | Number of audio busses.
numAudioBuses :: UGen

-- | Number of open buffers.
numBuffers :: UGen

-- | Number of control busses.
numControlBuses :: UGen

-- | Number of input busses.
numInputBuses :: UGen

-- | Number of output busses.
numOutputBuses :: UGen

-- | Number of currently running synths.
numRunningSynths :: UGen

-- | Write a signal to a bus with sample accurate timing.
offsetOut :: UGen -> UGen -> UGen

-- | One pole filter.
onePole :: UGen -> UGen -> UGen

-- | One zero filter.
oneZero :: UGen -> UGen -> UGen

-- | Onset detector
onsets :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Interpolating wavetable oscillator.
osc :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Noninterpolating wavetable oscillator.
oscN :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Write a signal to a bus.
out :: UGen -> UGen -> UGen

-- | Very fast sine grain with a parabolic envelope
pSinGrain :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Complex addition.
pv_Add :: UGen -> UGen -> UGen

-- | Scramble bins.
pv_BinScramble :: ID a => a -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Shift and stretch bin position.
pv_BinShift :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Combine low and high bins from two inputs.
pv_BinWipe :: UGen -> UGen -> UGen -> UGen

-- | Zero bins.
pv_BrickWall :: UGen -> UGen -> UGen

-- | Base class for UGens that alter FFT chains
pv_ChainUGen :: UGen -> UGen

-- | Complex plane attack.
pv_ConformalMap :: UGen -> UGen -> UGen -> UGen

-- | Complex conjugate
pv_Conj :: UGen -> UGen

-- | Copy an FFT buffer
pv_Copy :: UGen -> UGen -> UGen

-- | Copy magnitudes and phases.
pv_CopyPhase :: UGen -> UGen -> UGen

-- | Random phase shifting.
pv_Diffuser :: UGen -> UGen -> UGen

-- | Complex division
pv_Div :: UGen -> UGen -> UGen

-- | FFT onset detector.
pv_HainsworthFoote :: UGen -> UGen

-- | FFT feature detector for onset detection.
pv_JensenAndersen :: UGen -> UGen

-- | Pass bins which are a local maximum.
pv_LocalMax :: UGen -> UGen -> UGen

-- | Pass bins above a threshold.
pv_MagAbove :: UGen -> UGen -> UGen

-- | Pass bins below a threshold.
pv_MagBelow :: UGen -> UGen -> UGen

-- | Clip bins to a threshold.
pv_MagClip :: UGen -> UGen -> UGen

-- | Division of magnitudes
pv_MagDiv :: UGen -> UGen -> UGen -> UGen

-- | Freeze magnitudes.
pv_MagFreeze :: UGen -> UGen -> UGen

-- | Multiply magnitudes.
pv_MagMul :: UGen -> UGen -> UGen

-- | Multiply magnitudes by noise.
pv_MagNoise :: UGen -> UGen

-- | shift and stretch magnitude bin position.
pv_MagShift :: UGen -> UGen -> UGen -> UGen

-- | Average magnitudes across bins.
pv_MagSmear :: UGen -> UGen -> UGen

-- | Square magnitudes.
pv_MagSquared :: UGen -> UGen

-- | Maximum magnitude.
pv_Max :: UGen -> UGen -> UGen

-- | Minimum magnitude.
pv_Min :: UGen -> UGen -> UGen

-- | Complex multiply.
pv_Mul :: UGen -> UGen -> UGen

-- | Shift phase.
pv_PhaseShift :: UGen -> UGen -> UGen -> UGen

-- | Shift phase by 270 degrees.
pv_PhaseShift270 :: UGen -> UGen

-- | Shift phase by 90 degrees.
pv_PhaseShift90 :: UGen -> UGen

-- | Pass random bins.
pv_RandComb :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Crossfade in random bin order.
pv_RandWipe :: ID a => a -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Make gaps in spectrum.
pv_RectComb :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Make gaps in spectrum.
pv_RectComb2 :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Two channel equal power pan.
pan2 :: UGen -> UGen -> UGen -> UGen

-- | Four channel equal power pan.
pan4 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Azimuth panner
panAz :: Int -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Ambisonic B-format panner.
panB :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | 2D Ambisonic B-format panner.
panB2 :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Real-time partitioned convolution
partConv :: UGen -> UGen -> UGen -> UGen

-- | When triggered, pauses a node.
pause :: Rate -> UGen -> UGen -> UGen

-- | When triggered, pause enclosing synth.
pauseSelf :: Rate -> UGen -> UGen

-- | FIXME: PauseSelfWhenDone purpose.
pauseSelfWhenDone :: Rate -> UGen -> UGen

-- | Track peak signal amplitude.
peak :: UGen -> UGen -> UGen

-- | Track peak signal amplitude.
peakFollower :: UGen -> UGen -> UGen

-- | A resettable linear ramp between two levels.
phasor :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Pink Noise.
pinkNoise :: ID a => a -> Rate -> UGen

-- | Autocorrelation pitch follower
pitch :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Time domain pitch shifter.
pitchShift :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Sample playback oscillator.
playBuf :: Int -> Rate -> UGen -> UGen -> UGen -> UGen -> Loop -> DoneAction -> UGen

-- | A Karplus-Strong UGen
pluck :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Print the current output value of a UGen poll :: UGen -&gt; UGen -&gt;
--   UGen -&gt; UGen -&gt; UGen poll trig_ in_ label_ trigid = mkUGen
--   Nothing [KR,AR] (Right [1]) <a>Poll</a> [trig_,in_,label_,trigid]
--   Nothing 1 (Special 0) NoId
--   
--   Band limited pulse wave.
pulse :: Rate -> UGen -> UGen -> UGen

-- | Pulse counter.
pulseCount :: UGen -> UGen -> UGen

-- | Pulse divider.
pulseDivider :: UGen -> UGen -> UGen -> UGen

-- | General quadratic map chaotic generator
quadC :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | General quadratic map chaotic generator
quadL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | General quadratic map chaotic generator
quadN :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | A resonant high pass filter.
rhpf :: UGen -> UGen -> UGen -> UGen

-- | A resonant low pass filter.
rlpf :: UGen -> UGen -> UGen -> UGen

-- | Number of radians per sample.
radiansPerSample :: UGen

-- | Break a continuous signal into line segments
ramp :: UGen -> UGen -> UGen

-- | Single random number generator.
rand :: ID a => a -> UGen -> UGen -> UGen

-- | Set the synth's random generator ID.
randID :: Rate -> UGen -> UGen

-- | Sets the synth's random generator seed.
randSeed :: Rate -> UGen -> UGen -> UGen

-- | Record or overdub into a Buffer.
recordBuf :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> Loop -> UGen -> DoneAction -> UGen -> UGen

-- | Send signal to a bus, overwriting previous contents.
replaceOut :: UGen -> UGen -> UGen

-- | Resonant filter.
resonz :: UGen -> UGen -> UGen -> UGen

-- | Ringing filter.
ringz :: UGen -> UGen -> UGen -> UGen

-- | Rotate a sound field.
rotate2 :: UGen -> UGen -> UGen -> UGen

-- | Track maximum level.
runningMax :: UGen -> UGen -> UGen

-- | Track minimum level.
runningMin :: UGen -> UGen -> UGen

-- | Running sum over n frames
runningSum :: UGen -> UGen -> UGen

-- | Second order filter section (biquad).
sos :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Duration of one sample.
sampleDur :: UGen

-- | Server sample rate.
sampleRate :: UGen

-- | Band limited sawtooth.
saw :: Rate -> UGen -> UGen

-- | Schmidt trigger.
schmidt :: Rate -> UGen -> UGen -> UGen -> UGen

-- | FIXME: ScopeOut purpose.
scopeOut :: Rate -> UGen -> UGen -> UGen

-- | (Undocumented class)
scopeOut2 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Select output from an array of inputs.
select :: UGen -> UGen -> UGen

-- | Send a trigger message from the server back to the client.
sendTrig :: UGen -> UGen -> UGen -> UGen

-- | Set-reset flip flop.
setResetFF :: UGen -> UGen -> UGen

-- | Wave shaper.
shaper :: UGen -> UGen -> UGen

-- | Interpolating sine wavetable oscillator.
sinOsc :: Rate -> UGen -> UGen -> UGen

-- | Feedback FM oscillator
sinOscFB :: Rate -> UGen -> UGen -> UGen

-- | Slew rate limiter.
slew :: UGen -> UGen -> UGen -> UGen

-- | Slope of signal
slope :: UGen -> UGen

-- | Spectral centroid
specCentroid :: Rate -> UGen -> UGen

-- | Spectral Flatness measure
specFlatness :: Rate -> UGen -> UGen

-- | Find a percentile of FFT magnitude spectrum
specPcile :: Rate -> UGen -> UGen -> UGen -> UGen

-- | physical model of resonating spring
spring :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Standard map chaotic generator
standardL :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Standard map chaotic generator
standardN :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Pulse counter.
stepper :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Stereo real-time convolver with linear interpolation
stereoConvolution2L :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Offset from synth start within one sample.
subsampleOffset :: UGen

-- | Sum three signals
sum3 :: UGen -> UGen -> UGen -> UGen

-- | Sum four signals
sum4 :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Triggered linear ramp
sweep :: UGen -> UGen -> UGen

-- | Hard sync sawtooth wave.
syncSaw :: Rate -> UGen -> UGen -> UGen

-- | Control rate trigger to audio rate trigger converter
t2A :: UGen -> UGen -> UGen

-- | Audio rate trigger to control rate trigger converter
t2K :: Rate -> UGen -> UGen

-- | physical model of bouncing object
tBall :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Trigger delay.
tDelay :: UGen -> UGen -> UGen

-- | Demand results as trigger from demand rate UGens.
tDuty :: Rate -> UGen -> UGen -> DoneAction -> UGen -> UGen -> UGen

-- | Triggered exponential random number generator.
tExpRand :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Buffer granulator.
tGrains :: Int -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Triggered integer random number generator.
tIRand :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Triggered random number generator.
tRand :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Triggered windex.
tWindex :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Returns time since last triggered.
timer :: UGen -> UGen

-- | Toggle flip flop.
toggleFF :: UGen -> UGen

-- | Timed trigger.
trig :: UGen -> UGen -> UGen

-- | Timed trigger.
trig1 :: UGen -> UGen -> UGen

-- | FIXME: TrigControl purpose.
trigControl :: Rate -> UGen -> UGen

-- | Two pole filter.
twoPole :: UGen -> UGen -> UGen -> UGen

-- | Two zero filter.
twoZero :: UGen -> UGen -> UGen -> UGen

-- | Apply a unary operation to the values of an input ugen
unaryOpUGen :: UGen -> UGen

-- | Stream in audio from a file, with variable rate
vDiskIn :: Int -> UGen -> UGen -> Loop -> UGen -> UGen

-- | Variable wavetable oscillator.
vOsc :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Three variable wavetable oscillators.
vOsc3 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Variable shaped lag
varLag :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Variable duty saw
varSaw :: Rate -> UGen -> UGen -> UGen -> UGen

-- | The Vibrato oscillator models a slow frequency modulation.
vibrato :: ID a => a -> Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Warp a buffer with a time pointer
warp1 :: Int -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | White noise.
whiteNoise :: ID a => a -> Rate -> UGen

-- | (Undocumented class)
widthFirstUGen :: Rate -> UGen -> UGen

-- | Wrap a signal outside given thresholds.
wrap :: UGen -> UGen -> UGen -> UGen

-- | Index into a table with a signal.
wrapIndex :: UGen -> UGen -> UGen

-- | Equal power two channel cross fade.
xFade2 :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Exponential line generator.
xLine :: Rate -> UGen -> UGen -> UGen -> DoneAction -> UGen

-- | Send signal to a bus, crossfading with previous contents.
xOut :: UGen -> UGen -> UGen -> UGen

-- | Zero crossing frequency follower
zeroCrossing :: UGen -> UGen

-- | LocalBuf count
maxLocalBufs :: Rate -> UGen -> UGen

-- | Multiply add
mulAdd :: UGen -> UGen -> UGen -> UGen

-- | Set local buffer
setBuf :: UGen -> UGen -> UGen -> UGen -> UGen


-- | Hand-written bindings.
module Sound.SC3.UGen.Bindings.HW

-- | Zero local buffer.
--   
--   ClearBuf does not copy the buffer number through so this is an MRG
--   node.
clearBuf :: UGen -> UGen

-- | Demand rate weighted random sequence generator.
dwrand :: ID i => i -> UGen -> UGen -> UGen -> UGen

-- | Outputs signal for <tt>FFT</tt> chains, without performing FFT.
fftTrigger :: UGen -> UGen -> UGen -> UGen

-- | Pack demand-rate FFT bin streams into an FFT chain.
packFFT :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Poll value of input UGen when triggered.
poll :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Send a reply message from the server back to the all registered
--   clients.
sendReply :: UGen -> UGen -> String -> [UGen] -> UGen

-- | Unpack a single value (magnitude or phase) from an FFT chain
unpack1FFT :: UGen -> UGen -> UGen -> UGen -> UGen


-- | Monad constructors for <a>UGen</a>s.
module Sound.SC3.UGen.Bindings.Monad

-- | Buffer demand ugen.
dbufrdM :: UId m => UGen -> UGen -> Loop -> m UGen

-- | Buffer write on demand unit generator.
dbufwrM :: UId m => UGen -> UGen -> UGen -> Loop -> m UGen

-- | Demand rate white noise.
dwhiteM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Demand rate integer white noise.
diwhiteM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Demand rate brown noise.
dbrownM :: UId m => UGen -> UGen -> UGen -> UGen -> m UGen

-- | Demand rate integer brown noise.
dibrownM :: UId m => UGen -> UGen -> UGen -> UGen -> m UGen

-- | Demand rate random selection.
drandM :: UId m => UGen -> UGen -> m UGen

-- | Demand rate weighted random sequence generator.
dwrandM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Demand rate random selection with no immediate repetition.
dxrandM :: UId m => UGen -> UGen -> m UGen

-- | Demand rate arithmetic series.
dseriesM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Demand rate geometric series.
dgeomM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Demand rate sequence generator.
dseqM :: UId m => UGen -> UGen -> m UGen

-- | Demand rate series generator.
dserM :: UId m => UGen -> UGen -> m UGen

-- | Demand rate sequence shuffler.
dshufM :: UId m => UGen -> UGen -> m UGen

-- | Demand input replication
dstutterM :: UId m => UGen -> UGen -> m UGen

-- | Demand rate input switching.
dswitch1M :: UId m => UGen -> UGen -> m UGen

-- | Demand rate input switching.
dswitchM :: UId m => UGen -> UGen -> m UGen

-- | Randomize order of bins.
pv_BinScrambleM :: UId m => UGen -> UGen -> UGen -> UGen -> m UGen

-- | Randomly clear bins.
pv_RandCombM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Cross fade, copying bins in random order.
pv_RandWipeM :: UId m => UGen -> UGen -> UGen -> UGen -> m UGen

-- | Brown noise.
brownNoiseM :: UId m => Rate -> m UGen

-- | Clip noise.
clipNoiseM :: UId m => Rate -> m UGen

-- | Randomly pass or block triggers.
coinGateM :: UId m => UGen -> UGen -> m UGen

-- | Random impulses in (-1, 1).
dust2M :: UId m => Rate -> UGen -> m UGen

-- | Random impulse in (0,1).
dustM :: UId m => Rate -> UGen -> m UGen

-- | Random value in exponential distribution.
expRandM :: UId m => UGen -> UGen -> m UGen

-- | Gray noise.
grayNoiseM :: UId m => Rate -> m UGen

-- | Random integer in uniform distribution.
iRandM :: UId m => UGen -> UGen -> m UGen

-- | Clip noise.
lfClipNoiseM :: UId m => Rate -> UGen -> m UGen

-- | Dynamic clip noise.
lfdClipNoiseM :: UId m => Rate -> UGen -> m UGen

-- | Dynamic step noise.
lfdNoise0M :: UId m => Rate -> UGen -> m UGen

-- | Dynamic ramp noise.
lfdNoise1M :: UId m => Rate -> UGen -> m UGen

-- | Dynamic cubic noise
lfdNoise3M :: UId m => Rate -> UGen -> m UGen

-- | Step noise.
lfNoise0M :: UId m => Rate -> UGen -> m UGen

-- | Ramp noise.
lfNoise1M :: UId m => Rate -> UGen -> m UGen

-- | Quadratic noise.
lfNoise2M :: UId m => Rate -> UGen -> m UGen

-- | Random value in skewed linear distribution.
linRandM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Random value in sum of n linear distribution.
nRandM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Pink noise.
pinkNoiseM :: UId m => Rate -> m UGen

-- | Random value in uniform distribution.
randM :: UId m => UGen -> UGen -> m UGen

-- | Random value in exponential distribution on trigger.
tExpRandM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Random integer in uniform distribution on trigger.
tIRandM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Random value in uniform distribution on trigger.
tRandM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | Triggered windex.
tWindexM :: UId m => UGen -> UGen -> UGen -> m UGen

-- | White noise.
whiteNoiseM :: UId m => Rate -> m UGen


-- | Non-deterministic external <a>UGen</a>s.
module Sound.SC3.UGen.Bindings.HW.External.ID

-- | random walk step
lfBrownNoise0 :: ID a => a -> Rate -> UGen -> UGen -> UGen -> UGen

-- | random walk linear interp
lfBrownNoise1 :: ID a => a -> Rate -> UGen -> UGen -> UGen -> UGen

-- | random walk cubic interp
lfBrownNoise2 :: ID a => a -> Rate -> UGen -> UGen -> UGen -> UGen


-- | Bindings to unit generators in sc3-plugins.
module Sound.SC3.UGen.Bindings.HW.External.SC3_Plugins

-- | Band limited impulse generation
blitB3 :: Rate -> UGen -> UGen

-- | BLIT derived sawtooth
blitB3Saw :: Rate -> UGen -> UGen -> UGen

-- | Bipolar BLIT derived square waveform
blitB3Square :: Rate -> UGen -> UGen -> UGen

-- | Bipolar BLIT derived triangle
blitB3Tri :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Triangle via 3rd order differerentiated polynomial waveform
dPW3Tri :: Rate -> UGen -> UGen

-- | Sawtooth via 4th order differerentiated polynomial waveform
dPW4Saw :: Rate -> UGen -> UGen

-- | Single gammatone filter
gammatone :: UGen -> UGen -> UGen -> UGen

-- | Simple cochlear hair cell model
hairCell :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Meddis cochlear hair cell model
meddis :: UGen -> UGen

-- | Emulation of AY (aka YM) soundchip, used in Spectrum/Atari.
ay :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Convert frequency value to value appropriate for AY tone inputs.
ayFreqToTone :: Fractional a => a -> a

-- | An amplitude tracking based onset detector
coyote :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Windowed amplitude follower
wAmp :: Rate -> UGen -> UGen -> UGen

-- | Impulses around a certain frequency
gaussTrig :: Rate -> UGen -> UGen -> UGen

-- | String resonance filter
streson :: UGen -> UGen -> UGen -> UGen

-- | Triggered beta random distribution
tBetaRand :: ID a => a -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Triggered random walk generator
tBrownRand :: ID a => a -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Triggered gaussian random distribution
tGaussRand :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Concatenative cross-synthesis.
concat' :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Concatenative cross-synthesis (variant).
concat2 :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | FM-modulable resonating filter
complexRes :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Ring modulation based on the physical model of a diode.
diodeRingMod :: Rate -> UGen -> UGen -> UGen

-- | Demand rate implementation of a Wiard noise ring
dNoiseRing :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | algorithmic delay
greyholeRaw :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Raw version of the JPverb algorithmic reverberator, designed to
--   produce long tails with chorusing
jPverbRaw :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Brown noise.
disintegrator :: ID a => a -> UGen -> UGen -> UGen -> UGen

-- | Plucked physical model.
dWGPlucked2 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Resynthesize sinusoidal ATS analysis data.
atsSynth :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Resynthesize sinusoidal and critical noise ATS analysis data.
atsNoiSynth :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Granular synthesis with FM grains.
fmGrain :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Granular synthesis with FM grains and user supplied envelope.
fmGrainB :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Resynthesize LPC analysis data.
lpcSynth :: UGen -> UGen -> UGen -> UGen

-- | Extract cps, rmso and err signals from LPC data.
lpcVals :: Rate -> UGen -> UGen -> UGen

-- | Metronome
metro :: Rate -> UGen -> UGen -> UGen

-- | Delay and Feedback on a bin by bin basis.
pv_BinDelay :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Play FFT data from a memory buffer.
pv_BufRd :: UGen -> UGen -> UGen -> UGen

-- | <i>dur</i> and <i>hop</i> are in seconds, <i>frameSize</i> and
--   <i>sampleRate</i> in frames, though the latter maybe fractional.
--   
--   <pre>
--   pv_calcPVRecSize 4.2832879818594 1024 0.25 48000.0 == 823299
--   </pre>
pv_calcPVRecSize :: Double -> Int -> Double -> Double -> Int

-- | Invert FFT amplitude data.
pv_Invert :: UGen -> UGen

-- | Plays FFT data from a memory buffer.
pv_PlayBuf :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Records FFT data to a memory buffer.
pv_RecordBuf :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Sample looping oscillator
loopBuf :: Int -> Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Detect the largest value (and its position) in an array of UGens
arrayMax :: Rate -> UGen -> UGen

-- | Detect the smallest value (and its position) in an array of UGens
arrayMin :: Rate -> UGen -> UGen

-- | Detect the largest value (and its position) in an array of UGens
bufMax :: Rate -> UGen -> UGen -> UGen

-- | Detect the largest value (and its position) in an array of UGens
bufMin :: Rate -> UGen -> UGen -> UGen

-- | 3D Perlin Noise
perlin3 :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Wave squeezer. Maybe a kind of pitch shifter.
squiz :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Triangular waveguide mesh of a drum-like membrane.
membraneCircle :: UGen -> UGen -> UGen -> UGen

-- | Triangular waveguide mesh of a drum-like membrane.
membraneHexagon :: UGen -> UGen -> UGen -> UGen

-- | Spectral Modeling Synthesis
sms :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Tracking Phase Vocoder
tpv :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Tartini model pitch tracker.
tartini :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Constant Q transform pitch follower.
qitch :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Calculates mean average of audio or control rate signal.
averageOutput :: UGen -> UGen -> UGen

-- | Feedback delay line implementing switch-and-ramp buffer jumping.
switchDelay :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Octave chroma band based representation of energy in a signal;
--   Chromagram for nTET tuning systems with any base reference
chromagram :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Phase modulation oscillator matrix.
fm7 :: [[UGen]] -> [[UGen]] -> UGen

-- | Prigogine oscillator
brusselator :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Forced DoubleWell Oscillator
doubleWell3 :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Envelope Follower Filter
envDetect :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Envelope Follower
envFollow :: Rate -> UGen -> UGen -> UGen

-- | Linear Time Invariant General Filter Equation
lti :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Experimental time domain onset detector
sLOnset :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | wave terrain synthesis
waveTerrain :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | STK bowed string model.
stkBowed :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | STK flute model.
stkFlute :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | STK mandolin model.
stkMandolin :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | STK modal bar models.
stkModalBar :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | STK shaker models.
stkShakers :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Digitally modelled analog filter
dfm1 :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Vocal simulation due to W. Kaegi.
vosim :: UGen -> UGen -> UGen -> UGen -> UGen


-- | Bindings to unit generators not distributed with SuperCollider proper.
module Sound.SC3.UGen.Bindings.HW.External

module Sound.SC3.UGen.PP

-- | The default show is odd, 0.05 shows as 5.0e-2.
double_pp :: Int -> Double -> String

-- | Print as integer if integral, else as real.
real_pp :: Double -> String
bracketed :: (a, a) -> [a] -> [a]

-- | Print constants and labels directly, primitives as un-adorned names,
--   mce as [p,q], mrg as p&amp;q, contols as nm=def and proxies as u@n.
ugen_concise_pp :: UGen -> String


-- | Non-standard mathematical classes and class instances.
module Sound.SC3.UGen.Math

-- | Pseudo-infinite constant UGen.
dinf :: UGen

-- | True is conventionally 1. The test to determine true is <tt>&gt;
--   0</tt>.
sc3_true :: Num n => n

-- | False is conventionally 0.
sc3_false :: Num n => n

-- | Lifted <a>not</a>.
--   
--   <pre>
--   sc3_not sc3_true == sc3_false
--   sc3_not sc3_false == sc3_true
--   </pre>
sc3_not :: (Ord n, Num n) => n -> n

-- | Translate <a>Bool</a> to <a>sc3_true</a> and <a>sc3_false</a>.
sc3_bool :: Num n => Bool -> n

-- | Lift comparison function.
sc3_comparison :: Num n => (n -> n -> Bool) -> n -> n -> n

-- | Lifted <a>==</a>.
sc3_eq :: (Num n, Eq n) => n -> n -> n

-- | Lifted <a>/=</a>.
sc3_neq :: (Num n, Eq n) => n -> n -> n

-- | Lifted <a>&lt;</a>.
sc3_lt :: (Num n, Ord n) => n -> n -> n

-- | Lifted <a>&lt;=</a>.
sc3_lte :: (Num n, Ord n) => n -> n -> n

-- | Lifted <a>&gt;</a>.
sc3_gt :: (Num n, Ord n) => n -> n -> n

-- | Lifted <a>&gt;=</a>.
sc3_gte :: (Num n, Ord n) => n -> n -> n

-- | Variant of <tt>SC3</tt> <tt>roundTo</tt> function.
--   
--   <pre>
--   let r = [0,0,0.25,0.25,0.5,0.5,0.5,0.75,0.75,1,1]
--   in map (`roundTo_` 0.25) [0,0.1 .. 1] == r
--   </pre>
roundTo_ :: (RealFrac n, Ord n) => n -> n -> n
sc3_round_to :: (RealFrac n, Ord n) => n -> n -> n
sc3_idiv :: RealFrac n => n -> n -> n

-- | Association table for <a>Binary</a> to haskell function implementing
--   operator.
binop_hs_tbl :: (Real n, Floating n, RealFrac n, Ord n) => [(Binary, n -> n -> n)]

-- | <a>lookup</a> <a>binop_hs_tbl</a> via <a>toEnum</a>.
binop_special_hs :: (Real n, RealFrac n, Floating n, Ord n) => Int -> Maybe (n -> n -> n)

-- | Association table for <a>Unary</a> to haskell function implementing
--   operator.
uop_hs_tbl :: (RealFrac n, Floating n, Ord n) => [(Unary, n -> n)]

-- | <a>lookup</a> <a>uop_hs_tbl</a> via <a>toEnum</a>.
uop_special_hs :: (RealFrac n, Floating n, Ord n) => Int -> Maybe (n -> n)

-- | Variant on Eq class, result is of the same type as the values
--   compared.
class (Eq a, Num a) => EqE a where (==*) = sc3_eq (/=*) = sc3_neq
(==*) :: EqE a => a -> a -> a
(/=*) :: EqE a => a -> a -> a

-- | Variant on Ord class, result is of the same type as the values
--   compared.
class (Ord a, Num a) => OrdE a where (<*) = sc3_lt (<=*) = sc3_lte (>*) = sc3_gt (>=*) = sc3_gte
(<*) :: OrdE a => a -> a -> a
(<=*) :: OrdE a => a -> a -> a
(>*) :: OrdE a => a -> a -> a
(>=*) :: OrdE a => a -> a -> a
sc3_properFraction :: (RealFrac t, Num t) => t -> (t, t)
sc3_truncate :: (RealFrac a, Num a) => a -> a
sc3_round :: (RealFrac a, Num a) => a -> a
sc3_ceiling :: (RealFrac a, Num a) => a -> a
sc3_floor :: (RealFrac a, Num a) => a -> a

-- | Variant of <a>RealFrac</a> with non <a>Integral</a> results.
class RealFrac a => RealFracE a where properFractionE = sc3_properFraction truncateE = sc3_truncate roundE = sc3_round ceilingE = sc3_ceiling floorE = sc3_floor
properFractionE :: RealFracE a => a -> (a, a)
truncateE :: RealFracE a => a -> a
roundE :: RealFracE a => a -> a
ceilingE :: RealFracE a => a -> a
floorE :: RealFracE a => a -> a

-- | <a>UGen</a> form or <a>roundTo_</a>.
roundTo :: UGen -> UGen -> UGen

-- | <a>UGen</a> form of <a>ceilingE</a>.
ceil :: UGen -> UGen

-- | <a>Floating</a> form of <a>midiCPS</a>.
midiCPS' :: Floating a => a -> a

-- | <a>Floating</a> form of <a>cpsMIDI</a>.
cpsMIDI' :: Floating a => a -> a
cpsOct' :: Floating a => a -> a
ampDb' :: Floating a => a -> a
dbAmp' :: Floating a => a -> a
cubed' :: Num a => a -> a
midiRatio' :: Floating a => a -> a
octCPS' :: Floating a => a -> a
ratioMIDI' :: Floating a => a -> a
squared' :: Num a => a -> a

-- | Unary operator class.
--   
--   <pre>
--   map (floor . (* 1e4) . dbAmp) [-90,-60,-30,0] == [0,10,316,10000]
--   </pre>
class (Floating a, Ord a) => UnaryOp a where ampDb = ampDb' asFloat = error "asFloat" asInt = error "asInt" cpsMIDI = cpsMIDI' cpsOct = cpsOct' cubed = cubed' dbAmp = dbAmp' distort = error "distort" frac = error "frac" isNil a = if a == 0.0 then 0.0 else 1.0 log10 = logBase 10 log2 = logBase 2 midiCPS = midiCPS' midiRatio = midiRatio' notE a = if a > 0.0 then 0.0 else 1.0 notNil a = if a /= 0.0 then 0.0 else 1.0 octCPS = octCPS' ramp_ _ = error "ramp_" ratioMIDI = ratioMIDI' softClip = error "softClip" squared = squared'
ampDb :: UnaryOp a => a -> a
asFloat :: UnaryOp a => a -> a
asInt :: UnaryOp a => a -> a
cpsMIDI :: UnaryOp a => a -> a
cpsOct :: UnaryOp a => a -> a
cubed :: UnaryOp a => a -> a
dbAmp :: UnaryOp a => a -> a
distort :: UnaryOp a => a -> a
frac :: UnaryOp a => a -> a
isNil :: UnaryOp a => a -> a
log10 :: UnaryOp a => a -> a
log2 :: UnaryOp a => a -> a
midiCPS :: UnaryOp a => a -> a
midiRatio :: UnaryOp a => a -> a
notE :: UnaryOp a => a -> a
notNil :: UnaryOp a => a -> a
octCPS :: UnaryOp a => a -> a
ramp_ :: UnaryOp a => a -> a
ratioMIDI :: UnaryOp a => a -> a
softClip :: UnaryOp a => a -> a
squared :: UnaryOp a => a -> a
difSqr' :: Num a => a -> a -> a
hypotx' :: (Ord a, Floating a) => a -> a -> a

-- | Binary operator class.
class (Floating a, RealFrac a, Ord a) => BinaryOp a where absDif a b = abs (a - b) amClip a b = if b <= 0 then 0 else a * b atan2E a b = atan (b / a) clip2 a b = clip_ a (- b) b difSqr = difSqr' excess a b = a - clip_ a (- b) b exprandRange = error "exprandRange" fill = error "fill" firstArg a _ = a fold2 a b = fold_ a (- b) b gcdE = error "gcdE" hypot x y = sqrt (x * x + y * y) hypotx = hypotx' iDiv = sc3_idiv lcmE = error "lcmE" modE = error "modE" randRange = error "randRange" ring1 a b = a * b + a ring2 a b = a * b + a + b ring3 a b = a * a * b ring4 a b = a * a * b - a * b * b roundUp = error "roundUp" scaleNeg a b = (abs a - a) * b' + a where b' = 0.5 * b + 0.5 sqrDif a b = (a - b) * (a - b) sqrSum a b = (a + b) * (a + b) sumSqr a b = (a * a) + (b * b) thresh a b = if a < b then 0 else a trunc = error "trunc" wrap2 = error "wrap2"
absDif :: BinaryOp a => a -> a -> a
amClip :: BinaryOp a => a -> a -> a
atan2E :: BinaryOp a => a -> a -> a
clip2 :: BinaryOp a => a -> a -> a
difSqr :: BinaryOp a => a -> a -> a
excess :: BinaryOp a => a -> a -> a
exprandRange :: BinaryOp a => a -> a -> a
fill :: BinaryOp a => a -> a -> a
firstArg :: BinaryOp a => a -> a -> a
fold2 :: BinaryOp a => a -> a -> a
gcdE :: BinaryOp a => a -> a -> a
hypot :: BinaryOp a => a -> a -> a
hypotx :: BinaryOp a => a -> a -> a
iDiv :: BinaryOp a => a -> a -> a
lcmE :: BinaryOp a => a -> a -> a
modE :: BinaryOp a => a -> a -> a
randRange :: BinaryOp a => a -> a -> a
ring1 :: BinaryOp a => a -> a -> a
ring2 :: BinaryOp a => a -> a -> a
ring3 :: BinaryOp a => a -> a -> a
ring4 :: BinaryOp a => a -> a -> a
roundUp :: BinaryOp a => a -> a -> a
scaleNeg :: BinaryOp a => a -> a -> a
sqrDif :: BinaryOp a => a -> a -> a
sqrSum :: BinaryOp a => a -> a -> a
sumSqr :: BinaryOp a => a -> a -> a
thresh :: BinaryOp a => a -> a -> a
trunc :: BinaryOp a => a -> a -> a
wrap2 :: BinaryOp a => a -> a -> a

-- | The SC3 <tt>%</tt> operator is the <a>mod'</a> function.
--   
--   <pre>
--   &gt; 1.5 % 1.2 // ~= 0.3
--   &gt; -1.5 % 1.2 // ~= 0.9
--   &gt; 1.5 % -1.2 // ~= -0.9
--   &gt; -1.5 % -1.2 // ~= -0.3
--   </pre>
--   
--   <pre>
--   1.5 `fmod_f32` 1.2 -- ~= 0.3
--   (-1.5) `fmod_f32` 1.2 -- ~= 0.9
--   1.5 `fmod_f32` (-1.2) -- ~= -0.9
--   (-1.5) `fmod_f32` (-1.2) -- ~= -0.3
--   </pre>
--   
--   <pre>
--   &gt; 1.2 % 1.5 // ~= 1.2
--   &gt; -1.2 % 1.5 // ~= 0.3
--   1.2 % -1.5 // ~= -0.3
--   -1.2 % -1.5 // ~= -1.2
--   </pre>
--   
--   <pre>
--   1.2 `fmod_f32` 1.5 -- ~= 1.2
--   (-1.2) `fmod_f32` 1.5 -- ~= 0.3
--   1.2 `fmod_f32` (-1.5) -- ~= -0.3
--   (-1.2) `fmod_f32` (-1.5) -- ~= -1.2
--   </pre>
fmod_f32 :: Float -> Float -> Float

-- | Ternary operator class.
class Num a => TernaryOp a where mul_add i m a = i * m + a
mul_add :: TernaryOp a => a -> a -> a -> a

-- | Wrap <i>k</i> to within range <i>(i,j)</i>, ie.
--   <tt>AbstractFunction.wrap</tt>.
--   
--   <pre>
--   &gt; [5,6].wrap(0,5) == [5,0]
--   map (wrap' 0 5) [5,6] == [5,0]
--   </pre>
--   
--   <pre>
--   &gt; [9,10,5,6,7,8,9,10,5,6].wrap(5,10) == [9,10,5,6,7,8,9,10,5,6]
--   map (wrap' 5 10) [3..12] == [9,10,5,6,7,8,9,10,5,6]
--   </pre>
wrap' :: RealFracE n => n -> n -> n -> n

-- | Generic variant of <a>wrap'</a>.
--   
--   <pre>
--   &gt; [5,6].wrap(0,5) == [5,0]
--   map (genericWrap 0 5) [5,6] == [5,0]
--   </pre>
--   
--   <pre>
--   &gt; [9,10,5,6,7,8,9,10,5,6].wrap(5,10) == [9,10,5,6,7,8,9,10,5,6]
--   map (genericWrap (5::Integer) 10) [3..12] == [9,10,5,6,7,8,9,10,5,6]
--   </pre>
genericWrap :: (Ord a, Num a) => a -> a -> a -> a

-- | Variant of <a>wrap'</a> with <tt>SC3</tt> argument ordering.
--   
--   <pre>
--   map (\n -&gt; wrap_ n 5 10) [3..12] == map (wrap' 5 10) [3..12]
--   </pre>
wrap_ :: RealFracE n => n -> n -> n -> n

-- | Fold <i>k</i> to within range <i>(i,j)</i>, ie.
--   <tt>AbstractFunction.fold</tt>
--   
--   <pre>
--   map (foldToRange 5 10) [3..12] == [7,6,5,6,7,8,9,10,9,8]
--   </pre>
foldToRange :: (Ord a, Num a) => a -> a -> a -> a

-- | Variant of <a>foldToRange</a> with <tt>SC3</tt> argument ordering.
fold_ :: (Ord a, Num a) => a -> a -> a -> a

-- | Clip <i>k</i> to within range <i>(i,j)</i>,
--   
--   <pre>
--   map (clip' 5 10) [3..12] == [5,5,5,6,7,8,9,10,10,10]
--   </pre>
clip' :: Ord a => a -> a -> a -> a

-- | Variant of <a>clip'</a> with <tt>SC3</tt> argument ordering.
clip_ :: Ord a => a -> a -> a -> a
hypot_ :: Floating a => a -> a -> a

-- | Calculate multiplier and add values for <tt>linLin</tt> transform.
--   
--   <pre>
--   range_muladd 3 4 == (0.5,3.5)
--   linLin_muladd (-1) 1 3 4 == (0.5,3.5)
--   linLin_muladd 0 1 3 4 == (1,3)
--   linLin_muladd (-1) 1 0 1 == (0.5,0.5)
--   </pre>
linLin_muladd :: Fractional t => t -> t -> t -> t -> (t, t)

-- | Map from one linear range to another linear range.
linlin :: (Fractional a, TernaryOp a) => a -> a -> a -> a -> a -> a

-- | Variant without <a>TernaryOp</a> constraint.
linlin' :: Fractional a => a -> a -> a -> a -> a -> a

-- | Scale uni-polar (0,1) input to linear (l,r) range
--   
--   <pre>
--   map (urange 3 4) [0,0.5,1] == [3,3.5,4]
--   </pre>
urange :: (Fractional a, TernaryOp a) => a -> a -> a -> a

-- | Variant without <a>TernaryOp</a> constraint.
urange' :: Fractional a => a -> a -> a -> a

-- | Calculate multiplier and add values for <a>range</a> transform.
--   
--   <pre>
--   range_muladd 3 4 == (0.5,3.5)
--   </pre>
range_muladd :: Fractional t => t -> t -> (t, t)

-- | Scale bi-polar (-1,1) input to linear (l,r) range. Note that the
--   argument order is not the same as <tt>linLin</tt>.
--   
--   <pre>
--   map (range 3 4) [-1,0,1] == [3,3.5,4]
--   map (\x -&gt; let (m,a) = linLin_muladd (-1) 1 3 4 in x * m + a) [-1,0,1]
--   </pre>
range :: (Fractional a, TernaryOp a) => a -> a -> a -> a

-- | Variant without <a>TernaryOp</a> constraint.
range' :: Fractional a => a -> a -> a -> a
instance TernaryOp Double
instance TernaryOp Float
instance TernaryOp UGen
instance BinaryOp UGen
instance BinaryOp Double
instance BinaryOp Float
instance UnaryOp UGen
instance UnaryOp Double
instance UnaryOp Float
instance RealFracE UGen
instance RealFracE Double
instance RealFracE Float
instance OrdE UGen
instance OrdE Double
instance OrdE Float
instance OrdE Int64
instance OrdE Int32
instance OrdE Integer
instance OrdE Int
instance EqE UGen
instance EqE Double
instance EqE Float
instance EqE Int64
instance EqE Int32
instance EqE Integer
instance EqE Int


-- | Common unit generator graphs.
module Sound.SC3.UGen.Bindings.Composite

-- | Generate a localBuf and use setBuf to initialise it.
asLocalBuf :: ID i => i -> [UGen] -> UGen

-- | Calculate coefficients for bi-quad low pass filter.
bLowPassCoef :: Floating a => a -> a -> a -> (a, a, a, a, a)

-- | Buffer reader (no interpolation).
bufRdN :: Int -> Rate -> UGen -> UGen -> Loop -> UGen

-- | Buffer reader (linear interpolation).
bufRdL :: Int -> Rate -> UGen -> UGen -> Loop -> UGen

-- | Buffer reader (cubic interpolation).
bufRdC :: Int -> Rate -> UGen -> UGen -> Loop -> UGen

-- | Triggers when a value changes
changed :: UGen -> UGen -> UGen

-- | <a>mce</a> variant of <a>lchoose</a>.
choose :: ID m => m -> UGen -> UGen

-- | <a>liftUId</a> of <a>choose</a>.
chooseM :: UId m => UGen -> m UGen

-- | <a>clearBuf</a> of <a>localBuf</a>.
clearLocalBuf :: ID a => a -> UGen -> UGen -> UGen

-- | Demand rate (:) function.
dcons :: ID m => (m, m, m) -> UGen -> UGen -> UGen

-- | Demand rate (:) function.
dconsM :: UId m => UGen -> UGen -> m UGen

-- | Dynamic klang, dynamic sine oscillator bank
dynKlang :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Dynamic klank, set of non-fixed resonating filters.
dynKlank :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Variant FFT constructor with default values for hop size (0.5), window
--   type (0), active status (1) and window size (0).
fft' :: UGen -> UGen -> UGen

-- | <a>fft</a> variant that allocates <a>localBuf</a>.
--   
--   <pre>
--   let c = ffta '' 2048 (soundIn 0) 0.5 0 1 0
--   in audition (out 0 (ifft c 0 0))
--   </pre>
ffta :: ID i => i -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Sum of <a>numInputBuses</a> and <a>numOutputBuses</a>.
firstPrivateBus :: UGen

-- | Frequency shifter, in terms of <a>hilbert</a> (see also
--   <a>freqShift</a>).
freqShift_hilbert :: UGen -> UGen -> UGen -> UGen

-- | Variant ifft with default value for window type.
ifft' :: UGen -> UGen

-- | Format frequency, amplitude and phase data as required for klang.
klangSpec :: [UGen] -> [UGen] -> [UGen] -> UGen

-- | Variant of <a>klangSpec</a> for non-UGen inputs.
klangSpec' :: Real n => [n] -> [n] -> [n] -> UGen

-- | Variant of <a>klangSpec</a> for <tt>MCE</tt> inputs.
klangSpec_mce :: UGen -> UGen -> UGen -> UGen

-- | Format frequency, amplitude and decay time data as required for klank.
klankSpec :: [UGen] -> [UGen] -> [UGen] -> UGen

-- | Variant for non-UGen inputs.
klankSpec' :: Real n => [n] -> [n] -> [n] -> UGen

-- | Variant of <a>klankSpec</a> for <tt>MCE</tt> inputs.
klankSpec_mce :: UGen -> UGen -> UGen -> UGen

-- | Randomly select one of a list of UGens (initialiastion rate).
lchoose :: ID m => m -> [UGen] -> UGen

-- | <a>liftUId</a> of <a>lchoose</a>.
lchooseM :: UId m => [UGen] -> m UGen

-- | <a>linExp</a> of (-1,1).
linExp_b :: UGen -> UGen -> UGen -> UGen

-- | <a>linExp</a> of (0,1).
linExp_u :: UGen -> UGen -> UGen -> UGen

-- | Map from one linear range to another linear range.
linLin :: UGen -> UGen -> UGen -> UGen -> UGen -> UGen

-- | <a>linLin</a> where source is (0,1).
linLin_u :: UGen -> UGen -> UGen -> UGen

-- | <a>linLin</a> where source is (-1,1).
linLin_b :: UGen -> UGen -> UGen -> UGen

-- | Variant with defaults of zero.
localIn' :: Int -> Rate -> UGen

-- | Generate an <a>envGen</a> UGen with <tt>fadeTime</tt> and
--   <tt>gate</tt> controls.
--   
--   <pre>
--   import Sound.SC3
--   audition (out 0 (makeFadeEnv 1 * sinOsc AR 440 0 * 0.1))
--   withSC3 (send (n_set1 (-1) "gate" 0))
--   </pre>
makeFadeEnv :: Double -> UGen

-- | Count <a>mce</a> channels.
mceN :: UGen -> UGen

-- | Collapse possible mce by summing.
mix :: UGen -> UGen

-- | Mix variant, sum to n channels.
mixN :: Int -> UGen -> UGen

-- | Construct and sum a set of UGens.
mixFill :: Integral n => Int -> (n -> UGen) -> UGen

-- | Monad variant on mixFill.
mixFillM :: (Integral n, Monad m) => Int -> (n -> m UGen) -> m UGen

-- | Variant that is randomly pressed.
mouseButton' :: Rate -> UGen -> UGen -> UGen -> UGen

-- | Randomised mouse UGen (see also <a>mouseX'</a> and <a>mouseY'</a>).
mouseR :: ID a => a -> Rate -> UGen -> UGen -> Warp -> UGen -> UGen

-- | Variant that randomly traverses the mouseX space.
mouseX' :: Rate -> UGen -> UGen -> Warp -> UGen -> UGen

-- | Variant that randomly traverses the mouseY space.
mouseY' :: Rate -> UGen -> UGen -> Warp -> UGen -> UGen

-- | Translate onset type string to constant UGen value.
onsetType :: Num a => String -> a

-- | Onset detector with default values for minor parameters.
onsets' :: UGen -> UGen -> UGen -> UGen

-- | Format magnitude and phase data data as required for packFFT.
packFFTSpec :: [UGen] -> [UGen] -> UGen

-- | Calculate size of accumulation buffer given FFT and IR sizes.
pc_calcAccumSize :: Int -> Int -> Int

-- | PM oscillator.
pmOsc :: Rate -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Variant of <a>poll</a> that generates an <a>mrg</a> value with the
--   input signal at left, and that allows a constant <i>frequency</i>
--   input in place of a trigger.
poll' :: UGen -> UGen -> UGen -> UGen -> UGen

-- | Variant of <a>in'</a> offset so zero if the first private bus.
privateIn :: Int -> Rate -> UGen -> UGen

-- | Variant of <a>out</a> offset so zero if the first private bus.
privateOut :: UGen -> UGen -> UGen

-- | Apply function <i>f</i> to each bin of an <tt>FFT</tt> chain, <i>f</i>
--   receives magnitude, phase and index and returns a (magnitude,phase).
pvcollect :: UGen -> UGen -> (UGen -> UGen -> UGen -> (UGen, UGen)) -> UGen -> UGen -> UGen -> UGen

-- | RMS variant of <a>runningSum</a>.
runningSumRMS :: UGen -> UGen -> UGen

-- | Mix one output from many sources
selectX :: UGen -> UGen -> UGen

-- | Set local buffer values.
setBuf' :: UGen -> [UGen] -> UGen -> UGen

-- | Silence.
silent :: Int -> UGen

-- | Zero indexed audio input buses.
soundIn :: UGen -> UGen

-- | Pan a set of channels across the stereo field.
splay :: UGen -> UGen -> UGen -> UGen -> Bool -> UGen

-- | Optimised sum function.
sum_opt :: [UGen] -> UGen

-- | Single tap into a delayline
tap :: Int -> UGen -> UGen -> UGen

-- | Randomly select one of several inputs on trigger.
tChoose :: ID m => m -> UGen -> UGen -> UGen

-- | Randomly select one of several inputs.
tChooseM :: UId m => UGen -> UGen -> m UGen

-- | Randomly select one of several inputs on trigger (weighted).
tWChoose :: ID m => m -> UGen -> UGen -> UGen -> UGen -> UGen

-- | Randomly select one of several inputs (weighted).
tWChooseM :: UId m => UGen -> UGen -> UGen -> UGen -> m UGen

-- | Unpack an FFT chain into separate demand-rate FFT bin streams.
unpackFFT :: UGen -> UGen -> UGen -> UGen -> UGen -> [UGen]

-- | If <tt>z</tt> isn't a sink node route to an <tt>out</tt> node writing
--   to <tt>bus</tt>. If <tt>fadeTime</tt> is given multiply by
--   <a>makeFadeEnv</a>.
--   
--   <pre>
--   import Sound.SC3
--   audition (wrapOut (sinOsc AR 440 0 * 0.1) 1)
--   withSC3 (send (n_set1 (-1) "gate" 0))
--   </pre>
wrapOut :: Maybe Double -> UGen -> UGen
playBufCF :: Int -> UGen -> UGen -> UGen -> UGen -> Loop -> UGen -> Int -> UGen

-- | An oscillator that reads through a table once.
osc1 :: Rate -> UGen -> UGen -> DoneAction -> UGen


-- | Optimisations of UGen graphs.
module Sound.SC3.UGen.Optimise

-- | Constant form of <tt>rand</tt> UGen.
c_rand :: Random a => Int -> a -> a -> a

-- | Constant form of <tt>iRand</tt> UGen.
c_irand :: (Num b, RealFrac a, Random a) => Int -> a -> a -> b

-- | Optimise <a>UGen</a> graph by re-writing <tt>rand</tt> and
--   <tt>iRand</tt> UGens that have <a>Constant</a> inputs. This, of
--   course, changes the nature of the graph, it is no longer randomised at
--   the server. It's a useful transformation for very large graphs which
--   are being constructed and sent each time the graph is played.
--   
--   <pre>
--   import Sound.SC3.UGen.Dot
--   </pre>
--   
--   <pre>
--   let u = sinOsc AR (rand 'a' 220 440) 0 * 0.1
--   in draw (u + ugen_optimise_ir_rand u)
--   </pre>
ugen_optimise_ir_rand :: UGen -> UGen

-- | Optimise <a>UGen</a> graph by re-writing binary operators with
--   <a>Constant</a> inputs. The standard graph constructors already do
--   this, however subsequent optimisations, ie.
--   <a>ugen_optimise_ir_rand</a> can re-introduce these sub-graphs, and
--   the <i>Plain</i> graph constructors are un-optimised.
--   
--   <pre>
--   let u = constant
--   u 5 * u 10 == u 50
--   u 5 ==* u 5 == u 1
--   u 5 &gt;* u 4 == u 1
--   u 5 &lt;=* u 5 == u 1
--   abs (u (-1)) == u 1
--   u 5 / u 2 == u 2.5
--   </pre>
--   
--   <pre>
--   let {u = lfPulse AR (2 ** rand '' (-9) 1) 0 0.5
--       ;u' = ugen_optimise_ir_rand u}
--   in draw (mix (mce [u,u',ugen_optimise_const_operator u']))
--   </pre>
ugen_optimise_const_operator :: UGen -> UGen
constant_opt :: UGen -> Maybe Sample


-- | A <i>disasembler</i> for UGen graphs.
module Sound.SC3.UGen.Graph.Reconstruct
node_sort :: [Node] -> [Node]
from_port_label :: Char -> FromPort -> String
is_operator_name :: String -> Bool
parenthesise_operator :: String -> String

-- | Generate a reconstruction of a <a>Graph</a>.
--   
--   <pre>
--   import Sound.SC3.ID
--   </pre>
--   
--   <pre>
--   let {k = control KR "bus" 0
--       ;o = sinOsc AR 440 0 + whiteNoise 'a' AR
--       ;u = out k (pan2 (o * 0.1) 0 1)
--       ;m = mrg [u,out 1 (impulse AR 1 0 * 0.1)]}
--   in putStrLn (reconstruct_graph_str (synth m))
--   </pre>
reconstruct_graph_str :: Graph -> String
reconstruct_c_str :: Node -> String
reconstruct_c_ugen :: Node -> UGen

-- | Discards index.
reconstruct_k_rnd :: Node -> (Rate, String, Sample)
reconstruct_k_str :: Node -> String
reconstruct_k_ugen :: Node -> UGen
ugen_qname :: String -> Special -> (String, String)
reconstruct_mce_str :: Node -> String
reconstruct_u_str :: Node -> [String]
reconstruct_mrg_str :: [Node] -> String

module Sound.SC3.UGen.Plain

-- | Variant of <a>mkUGen</a>.
mk_plain :: Rate -> String -> [UGen] -> Int -> Special -> UGenId -> UGen

-- | Construct unary operator, the name can textual or symbolic.
--   
--   <pre>
--   uop True "NEG" AR 1
--   </pre>
uop :: Case_Rule -> String -> Rate -> UGen -> UGen

-- | Construct binary operator, the name can textual or symbolic.
--   
--   <pre>
--   binop True "*" AR 1 2 == binop True "MUL" AR 1 2
--   binop False "*" AR (ugen "SinOsc" AR [440,0] 1) 0.1 == sinOsc AR 440 0 * 0.1
--   </pre>
binop :: Case_Rule -> String -> Rate -> UGen -> UGen -> UGen

-- | Construct deterministic UGen.
--   
--   <pre>
--   let o = ugen "SinOsc" AR [440,0] 1
--   o == sinOsc AR 440 0
--   ugen "Out" AR [0,o] 0 == out 0 (sinOsc AR 440 0)
--   </pre>
ugen :: String -> Rate -> [UGen] -> Int -> UGen

-- | Construct non-deterministic UGen.
--   
--   <pre>
--   import Sound.SC3.ID
--   nondet "WhiteNoise" (UId (fromEnum 'a')) AR [] 1 == whiteNoise 'a' AR
--   </pre>
nondet :: String -> UGenId -> Rate -> [UGen] -> Int -> UGen

module Sound.SC3.UGen.Bindings


-- | Functions to generate break point data for standard envelope types.
module Sound.SC3.UGen.Envelope.Construct

-- | Co-ordinate based static envelope generator.
--   
--   <pre>
--   let e = envCoord [(0,0),(1/4,1),(1,0)] 1 1 EnvLin
--   in envelope_sc3_array e == Just [0,2,-99,-99,1,1/4,1,0,0,3/4,1,0]
--   </pre>
envCoord :: Num a => [(a, a)] -> a -> a -> Envelope_Curve a -> Envelope a

-- | Trapezoidal envelope generator. The arguments are: 1. <tt>shape</tt>
--   determines the sustain time as a proportion of <tt>dur</tt>, zero is a
--   triangular envelope, one a rectangular envelope; 2. <tt>skew</tt>
--   determines the attack/decay ratio, zero is an immediate attack and a
--   slow decay, one a slow attack and an immediate decay; 3.
--   <tt>duration</tt> in seconds; 4. <tt>amplitude</tt> as linear gain.
envTrapezoid :: (Num a, OrdE a) => a -> a -> a -> a -> Envelope a

-- | Variant <a>envPerc</a> with user specified 'Envelope_Curve a'.
envPerc' :: Num a => a -> a -> a -> Envelope_Curve2 a -> Envelope a

-- | Percussive envelope, with attack, release, level and curve inputs.
envPerc :: Num a => a -> a -> Envelope a

-- | Triangular envelope, with duration and level inputs.
--   
--   <pre>
--   let e = envTriangle 1 0.1
--   in envelope_sc3_array e = Just [0,2,-99,-99,0.1,0.5,1,0,0,0.5,1,0]
--   </pre>
envTriangle :: (Num a, Fractional a) => a -> a -> Envelope a

-- | Sine envelope, with duration and level inputs.
--   
--   <pre>
--   let e = envSine 0 0.1
--   in envelope_sc3_array e == Just [0,2,-99,-99,0.1,0,3.0,0,0,0,3,0]
--   </pre>
envSine :: (Num a, Fractional a) => a -> a -> Envelope a

-- | Parameters for LINEN envelopes.
data LINEN a
LINEN :: a -> a -> a -> a -> Envelope_Curve3 a -> LINEN a
linen_attackTime :: LINEN a -> a
linen_sustainTime :: LINEN a -> a
linen_releaseTime :: LINEN a -> a
linen_level :: LINEN a -> a
linen_curve :: LINEN a -> Envelope_Curve3 a

-- | Record (<a>LINEN</a>) variant of <a>envLinen</a>.
envLinen_r :: Num a => LINEN a -> Envelope a

-- | Variant of <a>envLinen</a> with user specified 'Envelope_Curve a'.
envLinen' :: Num a => a -> a -> a -> a -> Envelope_Curve3 a -> Envelope a

-- | Linear envelope parameter constructor.
--   
--   <pre>
--   let {e = envLinen 0 1 0 1
--       ;s = envelope_segments e
--       ;p = pack_envelope_segments s}
--   in p == (env_levels e,env_times e,env_curves e)
--   </pre>
envLinen :: Num a => a -> a -> a -> a -> Envelope a

-- | Parameters for ADSR envelopes. The sustain level is given as a
--   proportion of the peak level.
data ADSR a
ADSR :: a -> a -> a -> a -> a -> Envelope_Curve3 a -> a -> ADSR a
adsr_attackTime :: ADSR a -> a
adsr_decayTime :: ADSR a -> a
adsr_sustainLevel :: ADSR a -> a
adsr_releaseTime :: ADSR a -> a
adsr_peakLevel :: ADSR a -> a
adsr_curve :: ADSR a -> Envelope_Curve3 a
adsr_bias :: ADSR a -> a
adsrDefault :: Fractional n => ADSR n

-- | Attack, decay, sustain, release envelope parameter constructor.
envADSR :: Num a => a -> a -> a -> a -> a -> Envelope_Curve a -> a -> Envelope a

-- | Record (<a>ADSR</a>) variant of <a>envADSR</a>.
envADSR_r :: Num a => ADSR a -> Envelope a

-- | Parameters for Roland type ADSSR envelopes.
data ADSSR a
ADSSR :: a -> a -> a -> a -> a -> a -> a -> Envelope_Curve4 a -> a -> ADSSR a
adssr_attackTime :: ADSSR a -> a
adssr_attackLevel :: ADSSR a -> a
adssr_decayTime :: ADSSR a -> a
adssr_decayLevel :: ADSSR a -> a
adssr_slopeTime :: ADSSR a -> a
adssr_sustainLevel :: ADSSR a -> a
adssr_releaseTime :: ADSSR a -> a
adssr_curve :: ADSSR a -> Envelope_Curve4 a
adssr_bias :: ADSSR a -> a

-- | Attack, decay, slope, sustain, release envelope parameter constructor.
envADSSR :: Num a => a -> a -> a -> a -> a -> a -> a -> Envelope_Curve a -> a -> Envelope a

-- | Record (<a>ADSSR</a>) variant of <a>envADSSR</a>.
envADSSR_r :: Num a => ADSSR a -> Envelope a

-- | Parameters for ASR envelopes.
data ASR a
ASR :: a -> a -> a -> Envelope_Curve2 a -> ASR a
asr_attackTime :: ASR a -> a
asr_sustainLevel :: ASR a -> a
asr_releaseTime :: ASR a -> a
asr_curve :: ASR a -> Envelope_Curve2 a

-- | Attack, sustain, release envelope parameter constructor.
--   
--   <pre>
--   let {c = 3
--       ;r = Just [0,2,1,-99,0.1,3,c,0,0,2,c,0]}
--   in envelope_sc3_array (envASR 3 0.1 2 EnvSin) == r
--   </pre>
envASR :: Num a => a -> a -> a -> Envelope_Curve a -> Envelope a

-- | Record (<a>ASR</a>) variant of <a>envASR</a>.
envASR_r :: Num a => ASR a -> Envelope a

-- | All segments are horizontal lines.
envStep :: [a] -> [a] -> Maybe Int -> Maybe Int -> Envelope a

-- | Singleton fade envelope.
envGate :: UGen -> UGen -> UGen -> DoneAction -> Envelope_Curve UGen -> UGen

-- | Variant with default values for all inputs. <tt>gate</tt> and
--   <tt>fadeTime</tt> are <a>control</a>s, <tt>doneAction</tt> is
--   <a>RemoveSynth</a>, <tt>curve</tt> is <a>EnvSin</a>.
envGate' :: UGen


-- | Collection of modules for writing unit-generator graphs.
module Sound.SC3.UGen


-- | Standard SC3 graphs, referenced in documentation.
module Sound.SC3.UGen.Help.Graph

-- | The SC3 <i>default</i> instrument <a>UGen</a> graph.
default_ugen_graph :: UGen

-- | A <i>Gabor</i> grain, envelope is by <a>lfGauss</a>.
gabor_grain_ugen_graph :: UGen

-- | A <i>sine</i> grain, envelope is by <a>envGen</a> of <a>envSine</a>.
sine_grain_ugen_graph :: UGen

-- | Trivial file playback instrument.
--   
--   If <i>use_gate</i> is <a>True</a> there is a <i>gate</i> parameter and
--   the synth ends either when the sound file ends or the gate closes,
--   else there is a <i>sustain</i> parameter to indicate the duration. In
--   both cases a linear envelope with a decay time of <i>decay</i> is
--   applied.
--   
--   The <i>rdelay</i> parameter sets the maximum pre-delay time (in
--   seconds), each instance is randomly pre-delayed between zero and the
--   indicated time. The <i>ramplitude</i> parameter sets the maximum
--   amplitude offset of the <i>amp</i> parameter, each instance is
--   randomly amplified between zero and the indicated value.
default_sampler_ugen_graph :: Bool -> UGen


-- | The unit-generator graph structure implemented by the SuperCollider
--   synthesis server.
module Sound.SC3.Server.Synthdef

-- | A named unit generator graph.
data Synthdef
Synthdef :: String -> UGen -> Synthdef
synthdefName :: Synthdef -> String
synthdefUGen :: Synthdef -> UGen

-- | Lift a <a>UGen</a> graph into a <a>Synthdef</a>.
synthdef :: String -> UGen -> Synthdef

-- | The SC3 <i>default</i> instrument <a>Synthdef</a>, see
--   <a>default_ugen_graph</a>.
--   
--   <pre>
--   withSC3 (send (d_recv defaultSynthdef))
--   audition defaultSynthdef
--   </pre>
defaultSynthdef :: Synthdef

-- | The SC3 <i>default</i> sample (buffer) playback instrument
--   <a>Synthdef</a>, see <a>default_sampler_ugen_graph</a>.
--   
--   <pre>
--   withSC3 (send (d_recv (defaultSampler False)))
--   audition (defaultSampler False)
--   </pre>
defaultSampler :: Bool -> Synthdef

-- | <a>ugen_to_graph</a> of <a>synthdefUGen</a>.
synthdefGraph :: Synthdef -> Graph

-- | Parameter names at <a>Synthdef</a>.
--   
--   <pre>
--   synthdefParam def == ["amp","pan","gate","freq"]
--   </pre>
synthdefParam :: Synthdef -> [String]

-- | Find the indices of the named UGen at <a>Graph</a>. The index is
--   required when using <a>u_cmd</a>.
ugenIndices :: String -> Graph -> [Integer]

-- | <tt>graph_to_graphdef</tt> at <a>Synthdef</a>.
synthdef_to_graphdef :: Synthdef -> Graphdef

-- | Encode <a>Synthdef</a> as a binary data stream.
synthdefData :: Synthdef -> ByteString

-- | Write <a>Synthdef</a> to indicated directory. The filename is the
--   <a>synthdefName</a> with the appropriate extension
--   (<tt>scsyndef</tt>).
synthdefWrite :: Synthdef -> FilePath -> IO ()

-- | Simple statistical analysis of a unit generator graph.
graph_stat :: Graph -> String

-- | <a>graph_stat</a> of <tt>synth</tt>.
synthstat :: UGen -> String
instance Eq Synthdef
instance Show Synthdef
instance Default Synthdef


-- | This module provides variations of the asynchronous server commands
--   that expect a <i>completion packet</i> as the first argument. The
--   completion packet is executed by the server when the asynchronous
--   command has finished. Note that this mechanism is for synchronizing
--   server side processes only, for client side synchronization use
--   <tt>/done</tt> message notification or the <tt>/sync</tt> barrier.
module Sound.SC3.Server.Command.Completion

-- | Install a bytecode instrument definition. (Asynchronous)
d_recv' :: OSC o => o -> Synthdef -> Message

-- | Load an instrument definition from a named file. (Asynchronous)
d_load' :: OSC o => o -> String -> Message

-- | Load a directory of instrument definitions files. (Asynchronous)
d_loadDir' :: OSC o => o -> String -> Message

-- | Allocates zero filled buffer to number of channels and samples.
--   (Asynchronous)
b_alloc' :: OSC o => o -> Int -> Int -> Int -> Message

-- | Allocate buffer space and read a sound file. (Asynchronous)
b_allocRead' :: OSC o => o -> Int -> String -> Int -> Int -> Message

-- | Allocate buffer space and read a sound file, picking specific
--   channels. (Asynchronous)
b_allocReadChannel' :: OSC o => o -> Int -> String -> Int -> Int -> [Int] -> Message

-- | Free buffer data. (Asynchronous)
b_free' :: OSC o => o -> Int -> Message

-- | Close attached soundfile and write header information. (Asynchronous)
b_close' :: OSC o => o -> Int -> Message

-- | Read sound file data into an existing buffer. (Asynchronous)
b_read' :: OSC o => o -> Int -> String -> Int -> Int -> Int -> Bool -> Message

-- | Read sound file data into an existing buffer. (Asynchronous)
b_readChannel' :: OSC o => o -> Int -> String -> Int -> Int -> Int -> Bool -> [Int] -> Message

-- | Write sound file data. (Asynchronous)
b_write' :: OSC o => o -> Int -> String -> SoundFileFormat -> SampleFormat -> Int -> Int -> Bool -> Message

-- | Zero sample data. (Asynchronous)
b_zero' :: OSC o => o -> Int -> Message


-- | Generic constructors for the command set implemented by the
--   SuperCollider synthesis server.
module Sound.SC3.Server.Command.Generic

-- | Allocates zero filled buffer to number of channels and samples.
--   (Asynchronous)
b_alloc :: Integral i => i -> i -> i -> Message

-- | Allocate buffer space and read a sound file. (Asynchronous)
b_allocRead :: Integral i => i -> String -> i -> i -> Message

-- | Allocate buffer space and read a sound file, picking specific
--   channels. (Asynchronous)
b_allocReadChannel :: Integral i => i -> String -> i -> i -> [i] -> Message

-- | Close attached soundfile and write header information. (Asynchronous)
b_close :: Integral i => i -> Message

-- | Fill ranges of sample values.
b_fill :: (Integral i, Real n) => i -> [(i, i, n)] -> Message

-- | Free buffer data. (Asynchronous)
b_free :: Integral i => i -> Message

-- | Call a command to fill a buffer. (Asynchronous)
b_gen :: Integral i => i -> String -> [Datum] -> Message

-- | Call <tt>sine1</tt> <a>b_gen</a> command.
b_gen_sine1 :: (Integral i, Real n) => i -> [B_Gen] -> [n] -> Message

-- | Call <tt>sine2</tt> <a>b_gen</a> command.
b_gen_sine2 :: (Integral i, Real n) => i -> [B_Gen] -> [(n, n)] -> Message

-- | Call <tt>sine3</tt> <a>b_gen</a> command.
b_gen_sine3 :: (Integral i, Real n) => i -> [B_Gen] -> [(n, n, n)] -> Message

-- | Call <tt>cheby</tt> <a>b_gen</a> command.
b_gen_cheby :: (Integral i, Real n) => i -> [B_Gen] -> [n] -> Message

-- | Call <tt>copy</tt> <a>b_gen</a> command.
b_gen_copy :: Integral i => i -> i -> i -> i -> Maybe i -> Message

-- | Get sample values.
b_get :: Integral i => i -> [i] -> Message

-- | Get ranges of sample values.
b_getn :: Integral i => i -> [(i, i)] -> Message

-- | Request /b_info messages.
b_query :: Integral i => [i] -> Message

-- | Read sound file data into an existing buffer. (Asynchronous)
b_read :: Integral i => i -> String -> i -> i -> i -> Bool -> Message

-- | Read sound file data into an existing buffer, picking specific
--   channels. (Asynchronous)
b_readChannel :: Integral i => i -> String -> i -> i -> i -> Bool -> [i] -> Message

-- | Set sample values.
b_set :: (Integral i, Real n) => i -> [(i, n)] -> Message

-- | Set ranges of sample values.
b_setn :: (Integral i, Real n) => i -> [(i, [n])] -> Message

-- | Write sound file data. (Asynchronous)
b_write :: Integral i => i -> String -> SoundFileFormat -> SampleFormat -> i -> i -> Bool -> Message

-- | Zero sample data. (Asynchronous)
b_zero :: Integral i => i -> Message

-- | Fill ranges of bus values.
c_fill :: (Integral i, Real n) => [(i, i, n)] -> Message

-- | Get bus values.
c_get :: Integral i => [i] -> Message

-- | Get ranges of bus values.
c_getn :: Integral i => [(i, i)] -> Message

-- | Set bus values.
c_set :: (Integral i, Real n) => [(i, n)] -> Message

-- | Set ranges of bus values.
c_setn :: (Integral i, Real n) => [(i, [n])] -> Message

-- | Install a bytecode instrument definition. (Asynchronous)
d_recv' :: Graphdef -> Message

-- | Install a bytecode instrument definition. (Asynchronous)
d_recv :: Synthdef -> Message

-- | Load an instrument definition from a named file. (Asynchronous)
d_load :: String -> Message

-- | Load a directory of instrument definitions files. (Asynchronous)
d_loadDir :: String -> Message

-- | Remove definition once all nodes using it have ended.
d_free :: [String] -> Message

-- | Free all synths in this group and all its sub-groups.
g_deepFree :: Integral i => [i] -> Message

-- | Delete all nodes in a group.
g_freeAll :: Integral i => [i] -> Message

-- | Add node to head of group.
g_head :: Integral i => [(i, i)] -> Message

-- | Create a new group.
g_new :: Integral i => [(i, AddAction, i)] -> Message

-- | Add node to tail of group.
g_tail :: Integral i => [(i, i)] -> Message

-- | Post a representation of a group's node subtree, optionally including
--   the current control values for synths.
g_dumpTree :: Integral i => [(i, Bool)] -> Message

-- | Request a representation of a group's node subtree, optionally
--   including the current control values for synths.
--   
--   Replies to the sender with a <tt>/g_queryTree.reply</tt> message
--   listing all of the nodes contained within the group in the following
--   format:
--   
--   <pre>
--   int32 - if synth control values are included 1, else 0
--   int32 - node ID of the requested group
--   int32 - number of child nodes contained within the requested group
--   
--   For each node in the subtree:
--   [
--     int32 - node ID
--     int32 - number of child nodes contained within this node. If -1 this is a synth, if &gt;= 0 it's a group.
--   
--     If this node is a synth:
--       symbol - the SynthDef name for this node.
--   
--     If flag (see above) is true:
--       int32 - numControls for this synth (M)
--       [
--         symbol or int: control name or index
--         float or symbol: value or control bus mapping symbol (e.g. 'c1')
--       ] * M
--   ] * the number of nodes in the subtree
--   </pre>
--   
--   N.B. The order of nodes corresponds to their execution order on the
--   server. Thus child nodes (those contained within a group) are listed
--   immediately following their parent.
g_queryTree :: Integral i => [(i, Bool)] -> Message

-- | Place a node after another.
n_after :: Integral i => [(i, i)] -> Message

-- | Place a node before another.
n_before :: Integral i => [(i, i)] -> Message

-- | Fill ranges of a node's control values.
n_fill :: (Integral i, Real f) => i -> [(String, i, f)] -> Message

-- | Delete a node.
n_free :: Integral i => [i] -> Message
n_map :: Integral i => i -> [(String, i)] -> Message

-- | Map a node's controls to read from buses.
n_mapn :: Integral i => i -> [(String, i, i)] -> Message

-- | Map a node's controls to read from an audio bus.
n_mapa :: Integral i => i -> [(String, i)] -> Message

-- | Map a node's controls to read from audio buses.
n_mapan :: Integral i => i -> [(String, i, i)] -> Message

-- | Get info about a node.
n_query :: Integral i => [i] -> Message

-- | Turn node on or off.
n_run :: Integral i => [(i, Bool)] -> Message

-- | Set a node's control values.
n_set :: (Integral i, Real n) => i -> [(String, n)] -> Message

-- | Set ranges of a node's control values.
n_setn :: (Integral i, Real n) => i -> [(String, [n])] -> Message

-- | Trace a node.
n_trace :: Integral i => [i] -> Message

-- | Move an ordered sequence of nodes.
n_order :: Integral i => AddAction -> i -> [i] -> Message

-- | Create a new parallel group (supernova specific).
p_new :: Integral i => [(i, AddAction, i)] -> Message

-- | Get control values.
s_get :: Integral i => i -> [String] -> Message

-- | Get ranges of control values.
s_getn :: Integral i => i -> [(String, i)] -> Message

-- | Create a new synth.
s_new :: (Integral i, Real n) => String -> i -> AddAction -> i -> [(String, n)] -> Message

-- | Auto-reassign synth's ID to a reserved value.
s_noid :: Integral i => [i] -> Message

-- | Send a command to a unit generator.
u_cmd :: Integral i => i -> i -> String -> [Datum] -> Message

-- | Send a plugin command.
cmd :: String -> [Datum] -> Message

-- | Remove all bundles from the scheduling queue.
clearSched :: Message

-- | Select printing of incoming Open Sound Control messages.
dumpOSC :: PrintLevel -> Message

-- | Set error posting scope and mode.
errorMode :: ErrorScope -> ErrorMode -> Message

-- | Select reception of notification messages. (Asynchronous)
notify :: Bool -> Message

-- | End real time mode, close file (un-implemented).
nrt_end :: Message

-- | Stop synthesis server.
quit :: Message

-- | Request /status.reply message.
status :: Message

-- | Request /synced message when all current asynchronous commands
--   complete.
sync :: Integral i => i -> Message

-- | Add a completion message (or bundle, the name is misleading) to an
--   existing asynchronous command.
--   
--   <pre>
--   let {m = n_set1 0 "0" 0
--       ;m' = encodeMessage m}
--   in withCM (b_close 0) m == Message "/b_close" [Int 0,Blob m']
--   </pre>
withCM :: OSC o => Message -> o -> Message

-- | Pre-allocate for b_setn1, values preceding offset are zeroed.
b_alloc_setn1 :: (Integral i, Real n) => i -> i -> [n] -> Message

-- | Get ranges of sample values.
b_getn1 :: Integral i => i -> (i, i) -> Message

-- | Variant on <a>b_query</a>.
b_query1 :: Integral i => i -> Message

-- | Set single sample value.
b_set1 :: (Integral i, Real n) => i -> i -> n -> Message

-- | Set a range of sample values.
b_setn1 :: (Integral i, Real n) => i -> i -> [n] -> Message

-- | Get ranges of sample values.
c_getn1 :: Integral i => (i, i) -> Message

-- | Set single bus values.
c_set1 :: (Integral i, Real n) => i -> n -> Message

-- | Set single range of bus values.
c_setn1 :: (Integral i, Real n) => (i, [n]) -> Message

-- | Set a single node control value.
n_set1 :: (Integral i, Real n) => i -> String -> n -> Message

-- | <tt>s_new</tt> with no parameters.
s_new0 :: Integral i => String -> i -> AddAction -> i -> Message

-- | Segment a request for <i>m</i> places into sets of at most <i>n</i>.
--   
--   <pre>
--   b_segment 1024 2056 == [8,1024,1024]
--   b_segment 1 5 == replicate 5 1
--   </pre>
b_segment :: Integral i => i -> i -> [i]

-- | Variant of <a>b_segment</a> that takes a starting index and returns
--   <i>(index,size)</i> duples.
--   
--   <pre>
--   b_indices 1 5 0 == zip [0..4] (replicate 5 1)
--   b_indices 1024 2056 16 == [(16,8),(24,1024),(1048,1024)]
--   </pre>
b_indices :: Integral i => i -> i -> i -> [(i, i)]

-- | Generate accumulation buffer given time-domain IR buffer and FFT size.
pc_preparePartConv :: Integral i => i -> i -> i -> Message


-- | Functions from <a>Sound.SC3.Server.Command.Generic</a> specialised to
--   <a>Int</a> and <a>Double</a>.
module Sound.SC3.Server.Command.Plain

-- | Allocates zero filled buffer to number of channels and samples.
--   (Asynchronous)
b_alloc :: Int -> Int -> Int -> Message

-- | Allocate buffer space and read a sound file. (Asynchronous)
b_allocRead :: Int -> String -> Int -> Int -> Message

-- | Allocate buffer space and read a sound file, picking specific
--   channels. (Asynchronous)
b_allocReadChannel :: Int -> String -> Int -> Int -> [Int] -> Message

-- | Close attached soundfile and write header information. (Asynchronous)
b_close :: Int -> Message

-- | Free buffer data. (Asynchronous)
b_free :: Int -> Message

-- | Call a command to fill a buffer. (Asynchronous)
b_gen :: Int -> String -> [Datum] -> Message

-- | Call <tt>copy</tt> <a>b_gen</a> command.
b_gen_copy :: Int -> Int -> Int -> Int -> Maybe Int -> Message

-- | Get sample values.
b_get :: Int -> [Int] -> Message

-- | Get ranges of sample values.
b_getn :: Int -> [(Int, Int)] -> Message

-- | Request /b_info messages.
b_query :: [Int] -> Message

-- | Read sound file data into an existing buffer. (Asynchronous)
b_read :: Int -> String -> Int -> Int -> Int -> Bool -> Message

-- | Read sound file data into an existing buffer, picking specific
--   channels. (Asynchronous)
b_readChannel :: Int -> String -> Int -> Int -> Int -> Bool -> [Int] -> Message

-- | Write sound file data. (Asynchronous)
b_write :: Int -> String -> SoundFileFormat -> SampleFormat -> Int -> Int -> Bool -> Message

-- | Zero sample data. (Asynchronous)
b_zero :: Int -> Message

-- | Fill ranges of bus values.
c_fill :: [(Int, Int, Double)] -> Message

-- | Get bus values.
c_get :: [Int] -> Message

-- | Get ranges of bus values.
c_getn :: [(Int, Int)] -> Message

-- | Set bus values.
c_set :: [(Int, Double)] -> Message

-- | Set ranges of bus values.
c_setn :: [(Int, [Double])] -> Message

-- | Install a bytecode instrument definition. (Asynchronous)
d_recv' :: Graphdef -> Message

-- | Install a bytecode instrument definition. (Asynchronous)
d_recv :: Synthdef -> Message

-- | Load an instrument definition from a named file. (Asynchronous)
d_load :: String -> Message

-- | Load a directory of instrument definitions files. (Asynchronous)
d_loadDir :: String -> Message

-- | Remove definition once all nodes using it have ended.
d_free :: [String] -> Message

-- | Free all synths in this group and all its sub-groups.
g_deepFree :: [Int] -> Message

-- | Delete all nodes in a group.
g_freeAll :: [Int] -> Message

-- | Add node to head of group.
g_head :: [(Int, Int)] -> Message

-- | Create a new group.
g_new :: [(Int, AddAction, Int)] -> Message

-- | Add node to tail of group.
g_tail :: [(Int, Int)] -> Message

-- | Post a representation of a group's node subtree, optionally including
--   the current control values for synths.
g_dumpTree :: [(Int, Bool)] -> Message

-- | Request a representation of a group's node subtree, optionally
--   including the current control values for synths.
g_queryTree :: [(Int, Bool)] -> Message

-- | Place a node after another.
n_after :: [(Int, Int)] -> Message

-- | Place a node before another.
n_before :: [(Int, Int)] -> Message

-- | Fill ranges of a node's control values.
n_fill :: Int -> [(String, Int, Double)] -> Message

-- | Delete a node.
n_free :: [Int] -> Message
n_map :: Int -> [(String, Int)] -> Message

-- | Map a node's controls to read from buses.
n_mapn :: Int -> [(String, Int, Int)] -> Message

-- | Map a node's controls to read from an audio bus.
n_mapa :: Int -> [(String, Int)] -> Message

-- | Map a node's controls to read from audio buses.
n_mapan :: Int -> [(String, Int, Int)] -> Message

-- | Get info about a node.
n_query :: [Int] -> Message

-- | Turn node on or off.
n_run :: [(Int, Bool)] -> Message

-- | Set a node's control values.
n_set :: Int -> [(String, Double)] -> Message

-- | Set ranges of a node's control values.
n_setn :: Int -> [(String, [Double])] -> Message

-- | Trace a node.
n_trace :: [Int] -> Message

-- | Move an ordered sequence of nodes.
n_order :: AddAction -> Int -> [Int] -> Message

-- | Create a new parallel group (supernova specific).
p_new :: [(Int, AddAction, Int)] -> Message

-- | Get control values.
s_get :: Int -> [String] -> Message

-- | Get ranges of control values.
s_getn :: Int -> [(String, Int)] -> Message

-- | Auto-reassign synth's ID to a reserved value.
s_noid :: [Int] -> Message

-- | Send a command to a unit generator.
u_cmd :: Int -> Int -> String -> [Datum] -> Message

-- | Send a plugin command.
cmd :: String -> [Datum] -> Message

-- | Remove all bundles from the scheduling queue.
clearSched :: Message

-- | Select printing of incoming Open Sound Control messages.
dumpOSC :: PrintLevel -> Message

-- | Set error posting scope and mode.
errorMode :: ErrorScope -> ErrorMode -> Message

-- | Select reception of notification messages. (Asynchronous)
notify :: Bool -> Message

-- | End real time mode, close file (un-implemented).
nrt_end :: Message

-- | Stop synthesis server.
quit :: Message

-- | Request /status.reply message.
status :: Message

-- | Request /synced message when all current asynchronous commands
--   complete.
sync :: Int -> Message

-- | Get ranges of sample values.
b_getn1 :: Int -> (Int, Int) -> Message

-- | Variant on <a>b_query</a>.
b_query1 :: Int -> Message

-- | Get ranges of sample values.
c_getn1 :: (Int, Int) -> Message

-- | Set single bus values.
c_set1 :: Int -> Double -> Message

-- | Set single range of bus values.
c_setn1 :: (Int, [Double]) -> Message

-- | Set a single node control value.
n_set1 :: Int -> String -> Double -> Message

-- | <tt>s_new</tt> with no parameters.
s_new0 :: String -> Int -> AddAction -> Int -> Message

-- | Segment a request for <i>m</i> places into sets of at most <i>n</i>.
--   
--   <pre>
--   b_segment 1024 2056 == [8,1024,1024]
--   b_segment 1 5 == replicate 5 1
--   </pre>
b_segment :: Int -> Int -> [Int]

-- | Variant of <a>b_segment</a> that takes a starting index and returns
--   <i>(index,size)</i> duples.
--   
--   <pre>
--   b_indices 1 5 0 == zip [0..4] (replicate 5 1)
--   b_indices 1024 2056 16 == [(16,8),(24,1024),(1048,1024)]
--   </pre>
b_indices :: Int -> Int -> Int -> [(Int, Int)]

-- | Create a new synth.
s_new :: String -> Int -> AddAction -> Int -> [(String, Double)] -> Message

-- | Fill ranges of sample values.
b_fill :: Int -> [(Int, Int, Double)] -> Message

-- | Call <tt>sine1</tt> <a>b_gen</a> command.
b_gen_sine1 :: Int -> [B_Gen] -> [Double] -> Message

-- | Call <tt>sine2</tt> <a>b_gen</a> command.
b_gen_sine2 :: Int -> [B_Gen] -> [(Double, Double)] -> Message

-- | Call <tt>sine3</tt> <a>b_gen</a> command.
b_gen_sine3 :: Int -> [B_Gen] -> [(Double, Double, Double)] -> Message

-- | Call <tt>cheby</tt> <a>b_gen</a> command.
b_gen_cheby :: Int -> [B_Gen] -> [Double] -> Message

-- | Set sample values.
b_set :: Int -> [(Int, Double)] -> Message

-- | Set ranges of sample values.
b_setn :: Int -> [(Int, [Double])] -> Message

-- | Pre-allocate for b_setn1, values preceding offset are zeroed.
b_alloc_setn1 :: Int -> Int -> [Double] -> Message

-- | Set single sample value.
b_set1 :: Int -> Int -> Double -> Message

-- | Set a range of sample values.
b_setn1 :: Int -> Int -> [Double] -> Message

-- | Generate accumulation buffer given time-domain IR buffer and FFT size.
pc_preparePartConv :: Int -> Int -> Int -> Message


-- | Collection of standard <i>command</i> modules.
module Sound.SC3.Server.Command


-- | <a>NRT</a> operations.
module Sound.SC3.Server.NRT.Edit

-- | Inserts at the first position where it compares less but not equal to
--   the next element.
--   
--   <pre>
--   import Data.Function
--   insertBy (compare `on` fst) (3,'x') (zip [1..5] ['a'..])
--   insertBy_post (compare `on` fst) (3,'x') (zip [1..5] ['a'..])
--   </pre>
insertBy_post :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | <a>insertBy_post</a> using <a>compare</a>.
insert_post :: Bundle -> [Bundle] -> [Bundle]

-- | Apply <i>f</i> at all but last element, and <i>g</i> at last element.
--   
--   <pre>
--   at_last (* 2) negate [1..4] == [2,4,6,-4]
--   </pre>
at_last :: (a -> b) -> (a -> b) -> [a] -> [b]

-- | Merge two NRT scores. Retains internal <a>nrt_end</a> messages.
nrt_merge :: NRT -> NRT -> NRT

-- | Merge a set of NRT. Retains internal <a>nrt_end</a> messages.
nrt_merge_set :: [NRT] -> NRT

-- | The empty NRT.
nrt_empty :: NRT

-- | Add bundle at first permissable location of NRT.
nrt_insert_pre :: Bundle -> NRT -> NRT

-- | Add bundle at last permissable location of NRT.
nrt_insert_post :: Bundle -> NRT -> NRT

-- | <a>bundleTime</a> of <a>last</a> of <a>nrt_bundles</a>.
nrt_end_time :: NRT -> Time

-- | Apply temporal and message functions to bundle.
bundle_map :: (Time -> Time) -> ([Message] -> [Message]) -> Bundle -> Bundle

-- | Delete any internal <a>nrt_end</a> messages, and require one at the
--   final bundle.
nrt_close :: NRT -> NRT


-- | Recording <tt>scsynth</tt>.
module Sound.SC3.Server.Recorder

-- | Parameters for recording <tt>scsynth</tt>.
data SC3_Recorder
SC3_Recorder :: SoundFileFormat -> SampleFormat -> FilePath -> Int -> Int -> Int -> Int -> Int -> Int -> Maybe Time -> SC3_Recorder

-- | Sound file format.
rec_sftype :: SC3_Recorder -> SoundFileFormat

-- | Sample format.
rec_coding :: SC3_Recorder -> SampleFormat

-- | File name.
rec_fname :: SC3_Recorder -> FilePath

-- | Number of channels.
rec_nc :: SC3_Recorder -> Int

-- | Bus number.
rec_bus :: SC3_Recorder -> Int

-- | ID of buffer to allocate.
rec_buf_id :: SC3_Recorder -> Int

-- | Number of frames at buffer.
rec_buf_frames :: SC3_Recorder -> Int

-- | ID to allocate for node.
rec_node_id :: SC3_Recorder -> Int

-- | Group to allocate node within.
rec_group_id :: SC3_Recorder -> Int

-- | Recoring duration if fixed.
rec_dur :: SC3_Recorder -> Maybe Time

-- | Default recording structure.
default_SC3_Recorder :: SC3_Recorder

-- | Generate <a>Synthdef</a> with required number of channels.
rec_synthdef :: SC3_Recorder -> Synthdef

-- | Asyncronous initialisation <a>Message</a>s (<a>d_recv</a>,
--   <a>b_alloc</a> and <a>b_write</a>).
--   
--   <pre>
--   withSC3 (sendBundle (bundle immediately (rec_init_m def)))
--   </pre>
rec_init_m :: SC3_Recorder -> [Message]

-- | Begin recording <a>Message</a> (<a>s_new</a>).
--   
--   <pre>
--   withSC3 (sendMessage (rec_begin_m def))
--   </pre>
rec_begin_m :: SC3_Recorder -> Message

-- | End recording <a>Message</a>s (<a>n_free</a>, <a>b_close</a> and
--   <a>b_free</a>).
--   
--   <pre>
--   withSC3 (sendBundle (bundle immediately (rec_end_m def)))
--   </pre>
rec_end_m :: SC3_Recorder -> [Message]

-- | <a>NRT</a> score for recorder, if <a>rec_dur</a> is given schedule
--   <a>rec_end_m</a>.
sc3_recorder :: SC3_Recorder -> NRT
instance Default SC3_Recorder


-- | <i>FD</i> variant of interaction with the scsynth server.
--   
--   This duplicates functions at <a>Monad</a> and at some point at least
--   part of the duplication will be removed.
module Sound.SC3.Server.Transport.FD

-- | Synonym for <a>sendMessage</a>.
send :: Transport t => t -> Message -> IO ()

-- | Send a <a>Message</a> and <a>waitReply</a> for a <tt>/done</tt> reply.
async :: Transport t => t -> Message -> IO Message

-- | Bracket <tt>SC3</tt> communication.
withSC3 :: (UDP -> IO a) -> IO a

-- | Free all nodes (<a>g_freeAll</a>) at group <tt>1</tt>.
stop :: Transport t => t -> IO ()

-- | Free all nodes (<a>g_freeAll</a>) at and re-create groups <tt>1</tt>
--   and <tt>2</tt>.
reset :: Transport t => t -> IO ()

-- | Send <a>d_recv</a> and <a>s_new</a> messages to scsynth.
playGraphdef :: Transport t => Int -> t -> Graphdef -> IO ()

-- | <a>playGraphdef</a> of <a>synthdef_to_graphdef</a>.
playSynthdef :: Transport t => Int -> t -> Synthdef -> IO ()

-- | Send an <i>anonymous</i> instrument definition using
--   <a>playSynthdef</a>.
playUGen :: Transport t => Int -> t -> UGen -> IO ()

-- | Wait (<a>pauseThreadUntil</a>) until bundle is due to be sent relative
--   to initial <a>Time</a>, then send each message, asynchronously if
--   required.
run_bundle :: Transport t => t -> Time -> Bundle -> IO ()

-- | Perform an <a>NRT</a> score (as would be rendered by <a>writeNRT</a>).
--   In particular note that all timestamps <i>must</i> be in <tt>NTPr</tt>
--   form.
performNRT :: Transport t => t -> NRT -> IO ()

-- | Class for values that can be encoded and sent to <tt>scsynth</tt> for
--   audition.
class Audible e where play = play_id (- 1)
play_id :: (Audible e, Transport t) => Int -> t -> e -> IO ()
play :: (Audible e, Transport t) => t -> e -> IO ()
audition_id :: Audible e => Int -> e -> IO ()
audition :: Audible e => e -> IO ()

-- | Turn on notifications, run <i>f</i>, turn off notifications, return
--   result.
withNotifications :: Transport t => t -> (t -> IO a) -> IO a

-- | Variant of <a>b_getn1</a> that waits for return message and unpacks
--   it.
--   
--   <pre>
--   withSC3 (\fd -&gt; b_getn1_data fd 0 (0,5))
--   </pre>
b_getn1_data :: Transport t => t -> Int -> (Int, Int) -> IO [Double]

-- | Variant of <a>b_getn1_data</a> that segments individual <a>b_getn</a>
--   messages to <i>n</i> elements.
--   
--   <pre>
--   withSC3 (\fd -&gt; b_getn1_data_segment fd 1 0 (0,5))
--   </pre>
b_getn1_data_segment :: Transport t => t -> Int -> Int -> (Int, Int) -> IO [Double]

-- | Variant of <a>b_getn1_data_segment</a> that gets the entire buffer.
b_fetch :: Transport t => t -> Int -> Int -> IO [Double]

-- | Collect server status information.
serverStatus :: Transport t => t -> IO [String]

-- | Read nominal sample rate of server.
serverSampleRateNominal :: Transport t => t -> IO Double

-- | Read actual sample rate of server.
serverSampleRateActual :: Transport t => t -> IO Double

-- | Retrieve status data from server.
serverStatusData :: Transport t => t -> IO [Datum]
instance Audible NRT
instance Audible UGen
instance Audible Synthdef
instance Audible Graphdef


-- | <i>Monad</i> variant of interaction with the scsynth server.
module Sound.SC3.Server.Transport.Monad

-- | Synonym for <a>sendMessage</a>.
send :: SendOSC m => Message -> m ()

-- | Send a <a>Message</a> and <a>waitReply</a> for a <tt>/done</tt> reply.
async :: DuplexOSC m => Message -> m Message

-- | Bracket <tt>SC3</tt> communication. <a>withTransport</a> at standard
--   SC3 UDP port.
--   
--   <pre>
--   import Sound.SC3.Server.Command
--   </pre>
--   
--   <pre>
--   withSC3 (send status &gt;&gt; waitReply "/status.reply")
--   </pre>
withSC3 :: Connection UDP a -> IO a

-- | Free all nodes (<a>g_freeAll</a>) at group <tt>1</tt>.
stop :: SendOSC m => m ()

-- | <a>clearSched</a>, free all nodes (<a>g_freeAll</a>) at, and then
--   re-create, groups <tt>1</tt> and <tt>2</tt>.
reset :: SendOSC m => m ()

-- | Send <a>d_recv</a> and <a>s_new</a> messages to scsynth.
playGraphdef :: DuplexOSC m => (Int, AddAction, Int) -> Graphdef -> m ()

-- | Send <a>d_recv</a> and <a>s_new</a> messages to scsynth.
playSynthdef :: DuplexOSC m => (Int, AddAction, Int) -> Synthdef -> m ()

-- | Send an <i>anonymous</i> instrument definition using
--   <a>playSynthdef</a>.
playUGen :: DuplexOSC m => (Int, AddAction, Int) -> UGen -> m ()

-- | Wait (<a>pauseThreadUntil</a>) until bundle is due to be sent relative
--   to the initial <a>Time</a>, then send each message, asynchronously if
--   required.
run_bundle :: Transport m => Time -> Bundle -> m ()

-- | Perform an <a>NRT</a> score (as would be rendered by <a>writeNRT</a>).
--   Asynchronous commands at time <tt>0</tt> are separated out and run
--   before the initial time-stamp is taken. This re-orders synchronous
--   commands in relation to asynchronous at time <tt>0</tt>.
--   
--   <pre>
--   let sc = NRT [bundle 1 [s_new0 "default" (-1) AddToHead 1]
--                ,bundle 2 [n_set1 (-1) "gate" 0]]
--   in withSC3 (performNRT sc)
--   </pre>
performNRT :: Transport m => NRT -> m ()

-- | Class for values that can be encoded and send to <tt>scsynth</tt> for
--   audition.
class Audible e where play = play_at (- 1, AddToHead, 1)
play_at :: (Audible e, Transport m) => (Int, AddAction, Int) -> e -> m ()
play :: (Audible e, Transport m) => e -> m ()

-- | <a>withSC3</a> of <a>play_at</a>.
audition_at :: Audible e => (Int, AddAction, Int) -> e -> IO ()

-- | Variant where <i>id</i> is <tt>-1</tt>.
audition :: Audible e => e -> IO ()

-- | Turn on notifications, run <i>f</i>, turn off notifications, return
--   result.
withNotifications :: DuplexOSC m => m a -> m a

-- | Variant of <a>b_getn1</a> that waits for return message and unpacks
--   it.
--   
--   <pre>
--   withSC3 (b_getn1_data 0 (0,5))
--   </pre>
b_getn1_data :: DuplexOSC m => Int -> (Int, Int) -> m [Double]

-- | Variant of <a>b_getn1_data</a> that segments individual <a>b_getn</a>
--   messages to <i>n</i> elements.
--   
--   <pre>
--   withSC3 (b_getn1_data_segment 1 0 (0,5))
--   </pre>
b_getn1_data_segment :: DuplexOSC m => Int -> Int -> (Int, Int) -> m [Double]

-- | Variant of <a>b_getn1_data_segment</a> that gets the entire buffer.
b_fetch :: DuplexOSC m => Int -> Int -> m [Double]
c_getn1_data :: DuplexOSC m => (Int, Int) -> m [Double]

-- | Collect server status information.
serverStatus :: DuplexOSC m => m [String]

-- | Read nominal sample rate of server.
--   
--   <pre>
--   withSC3 serverSampleRateNominal
--   </pre>
serverSampleRateNominal :: DuplexOSC m => m Double

-- | Read actual sample rate of server.
--   
--   <pre>
--   withSC3 serverSampleRateActual
--   </pre>
serverSampleRateActual :: DuplexOSC m => m Double

-- | Retrieve status data from server.
serverStatusData :: DuplexOSC m => m [Datum]
instance Audible NRT
instance Audible UGen
instance Audible Synthdef
instance Audible Graphdef


-- | Collection of modules for communicating with the SuperCollider
--   synthesis server, see also <a>Sound.SC3.Server.FD</a> and
--   <a>Sound.SC3.Server.Monad</a>.
module Sound.SC3.Server


-- | Composite of <a>Sound.SC3.Server</a> and <a>Monad</a> transport.
module Sound.SC3.Server.Monad


-- | Composite of <a>Sound.SC3.Server</a> and <i>FD</i> transport.
module Sound.SC3.Server.FD


-- | Composite of <a>Sound.SC3.Server.FD</a> and <a>Sound.SC3.UGen</a> and
--   <a>Sound.SC3.UGen.Bindings</a>.
module Sound.SC3.FD


-- | Composite of <a>Sound.SC3.Server.Monad</a>, <a>Sound.SC3.UGen</a> and
--   <a>Sound.SC3.UGen.Bindings</a>.
module Sound.SC3
