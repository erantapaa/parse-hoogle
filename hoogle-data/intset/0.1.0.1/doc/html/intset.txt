-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pure, fast and memory efficient integer sets.
--   
--   This library provides persistent, time and space efficient integer
--   sets implemented as dense big-endian patricia trees with buddy
--   suffixes compaction. In randomized settings this structure expected to
--   be as fast as Data.IntSet from containers, but if a sets is likely to
--   have long continuous intervals it should be much faster.
--   
--   <ul>
--   <li><i><i>Release notes</i></i></li>
--   </ul>
--   
--   <ul>
--   <li><i>0.1.0.0:</i> Initial version.</li>
--   </ul>
@package intset
@version 0.1.0.1


-- | Fast conversion from or to lazy and strict bytestrings. Serialized
--   IntSets are represented as single continious bitmap.
--   
--   This module is kept separated due safe considerations.
module Data.IntervalSet.ByteString

-- | Unpack <a>IntSet</a> from bitmap.
fromByteString :: ByteString -> IntSet

-- | Pack the <a>IntSet</a> as bitmap to the strict bytestring.
--   
--   NOTE: negative elements are ignored!
toByteString :: IntSet -> ByteString


-- | An efficient implementation of dense integer sets based on Big-Endian
--   PATRICIA trees with buddy suffix compression.
--   
--   References:
--   
--   <ul>
--   <li>Fast Mergeable Integer Maps (1998) by Chris Okasaki, Andrew Gill
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   </ul>
--   
--   This implementation performs espessially well then set contains long
--   integer invervals like <tt>[0..2047]</tt> that are just merged into
--   one interval description. This allow to perform many operations in
--   constant time and space. However if set contain sparse integers like
--   <tt>[1,12,7908,234,897]</tt> the same operations will take <i>O(min(W,
--   n))</i> which is good enough in most cases.
--   
--   Conventions in complexity notation:
--   
--   <ul>
--   <li>n — number of elements in a set;</li>
--   <li>W — number bits in a <a>Key</a>. This is 32 or 64 at 32 and 64 bit
--   platforms respectively;</li>
--   <li>O(n) or O(k) — means this operation have complexity O(n) in worst
--   case (e.g. sparse set) or O(k) in best case (e.g. one single
--   interval).</li>
--   </ul>
--   
--   Note that some operations will take centuries to compute. For exsample
--   <tt>map id universe</tt> will never end as well as <a>filter</a>
--   applied to <a>universe</a>, <a>naturals</a>, <tt>positives</tt> or
--   <a>negatives</a>.
--   
--   Also note that some operations like <a>union</a>, <a>intersection</a>
--   and <a>difference</a> have overriden from default fixity, so use these
--   operations with infix syntax carefully.
module Data.IntervalSet

-- | Integer set.
data IntSet

-- | Layout: prefix up to branching bit, mask for branching bit, left
--   subtree and right subtree.
--   
--   IntSet = Bin: contains elements of left and right subtrees thus just
--   merge to subtrees. All elements of left subtree is less that from
--   right subtree. Except non-negative numbers, they are in left subtree
--   of root bin, if any.
Bin :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !Mask -> !IntSet -> !IntSet -> IntSet

-- | Layout: Prefix up to <i>mask of bitmap size</i>, and bitmap containing
--   elements starting <i>from the prefix</i>.
--   
--   IntSet = Tip: contains elements
Tip :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !BitMap -> IntSet

-- | Layout: Prefix up to <i>mask of bitmap size</i>, and mask specifing
--   how large is set. There is no branching bit at all. Tip is never full.
--   
--   IntSet = Fin: contains all elements from prefix to (prefix - mask - 1)
Fin :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !Mask -> IntSet

-- | Empty set. Contains nothing.
Nil :: IntSet

-- | Type of IntSet elements.
type Key = Int

-- | <i>O(1)</i>. Is this the empty set?
null :: IntSet -> Bool

-- | <i>O(n)</i> or <i>O(1)</i>. Cardinality of a set.
size :: IntSet -> Int

-- | <i>O(min(W, n))</i> or <i>O(1)</i>. Test if the value is element of
--   the set.
member :: Key -> IntSet -> Bool

-- | <i>O(min(W, n))</i> or <i>O(1)</i>. Test if the value is not an
--   element of the set.
notMember :: Key -> IntSet -> Bool

-- | <i>O(n + m)</i> or <i>O(1)</i>. Test if the second set contain each
--   element of the first.
isSubsetOf :: IntSet -> IntSet -> Bool

-- | <i>O(n + m)</i> or <i>O(1)</i>. Test if the second set is subset of
--   the first.
isSupersetOf :: IntSet -> IntSet -> Bool

-- | <i>O(1)</i>. The empty set.
empty :: IntSet

-- | <i>O(1)</i>. A set containing one element.
singleton :: Key -> IntSet

-- | <i>O(n)</i>. Set containing elements from the specified range.
--   
--   <pre>
--   interval a b = fromList [a..b]
--   </pre>
interval :: Key -> Key -> IntSet

-- | <i>O(min(W, n)</i> or <i>O(1)</i>. Add a value to the set.
insert :: Key -> IntSet -> IntSet

-- | <i>O(min(n, W))</i>. Delete a value from the set.
delete :: Key -> IntSet -> IntSet

-- | <i>O(n * min(W, n))</i>. Apply the function to each element of the
--   set.
--   
--   Do not use this operation with the <a>universe</a>, <a>naturals</a> or
--   <a>negatives</a> sets.
map :: (Key -> Key) -> IntSet -> IntSet

-- | <i>O(n)</i>. Fold the element using the given right associative binary
--   operator.
foldr :: (Key -> a -> a) -> a -> IntSet -> a

-- | <i>O(n)</i>. Filter all elements that satisfy the predicate.
--   
--   Do not use this operation with the <a>universe</a>, <a>naturals</a> or
--   <a>negatives</a> sets.
filter :: (Key -> Bool) -> IntSet -> IntSet

-- | <i>O(min(W, n)</i>. Split the set such that the left projection of the
--   resulting pair contains elements less than the key and right element
--   contains greater than the key. The exact key is excluded from result:
--   
--   <pre>
--   split 5 (fromList [0..10]) == (fromList [0..4], fromList [6..10])
--   </pre>
--   
--   Performance note: if need only lesser or greater keys, use splitLT or
--   splitGT respectively.
split :: Key -> IntSet -> (IntSet, IntSet)

-- | <i>O(min(W, n)</i>. Takes subset such that each element is greater
--   than the specified key. The exact key is excluded from result.
splitGT :: Key -> IntSet -> IntSet

-- | <i>O(min(W, n)</i>. Takes subset such that each element is less than
--   the specified key. The exact key is excluded from result.
splitLT :: Key -> IntSet -> IntSet

-- | <i>O(n)</i>. Split a set using given predicate.
--   
--   <pre>
--   forall f. fst . partition f = filter f
--   forall f. snd . partition f = filter (not . f)
--   </pre>
partition :: (Key -> Bool) -> IntSet -> (IntSet, IntSet)

-- | <i>O(min(W, n))</i> or <i>O(1)</i>. Find minimal element of the set.
--   If set is empty then min is undefined.
findMin :: IntSet -> Key

-- | <i>O(min(W, n))</i> or <i>O(1)</i>. Find maximal element of the set.
--   Is set is empty then max is undefined.
findMax :: IntSet -> Key

-- | <i>O(n + m)</i> or <i>O(1)</i>. Find set which contains elements of
--   both right and left sets.
union :: IntSet -> IntSet -> IntSet

-- | <i>O(max(n)^2 * spine)</i> or <i>O(spine)</i>. The union of list of
--   sets.
unions :: [IntSet] -> IntSet

-- | <i>O(n + m)</i> or <i>O(1)</i>. Find maximal common subset of the two
--   given sets.
intersection :: IntSet -> IntSet -> IntSet

-- | <i>O(max(n) * spine)</i> or <i>O(spine)</i>. Find out common subset of
--   the list of sets.
intersections :: [IntSet] -> IntSet

-- | <i>O(n + m)</i> or <i>O(1)</i>. Find difference of the two sets.
difference :: IntSet -> IntSet -> IntSet

-- | <i>O(n + m)</i> or <i>O(1)</i>. Find symmetric difference of the two
--   sets: resulting set containts elements that either in first or second
--   set, but not in both simultaneous.
symDiff :: IntSet -> IntSet -> IntSet

-- | Monoid under <a>union</a>. Used by default for <a>IntSet</a>.
--   
--   You could use <a>Sum</a> from <a>Monoid</a> as well.
data Union

-- | Monoid under <a>intersection</a>.
--   
--   You could use <a>Product</a> from <a>Monoid</a> as well.
data Intersection

-- | Monoid under <a>symDiff</a>.
--   
--   Don't mix up <a>symDiff</a> with <a>difference</a>.
data Difference

-- | <a>elems</a> is alias to <a>toList</a> for compatibility.
elems :: IntSet -> [Key]

-- | <i>O(n)</i>. Convert the set to a list of its elements.
toList :: IntSet -> [Key]

-- | <i>O(n * min(W, n))</i> or <i>O(n)</i>. Create a set from a list of
--   its elements.
fromList :: [Key] -> IntSet

-- | <i>O(n)</i>. Convert the set to a list of its element in ascending
--   order.
toAscList :: IntSet -> [Key]

-- | <i>O(n)</i>. Convert the set to a list of its element in descending
--   order.
toDescList :: IntSet -> [Key]

-- | Build a set from an ascending list of elements.
fromAscList :: [Key] -> IntSet
