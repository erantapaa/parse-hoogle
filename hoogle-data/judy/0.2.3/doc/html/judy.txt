-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast, scalable, mutable dynamic arrays, maps and hashes
--   
@package judy
@version 0.2.3


-- | Very fast, mutable associative data types based on Judy arrays.
--   
--   A good imperative, mutable replacement for IntMap.
--   
--   Judy arrays are both speed- and memory-efficient, with no tuning or
--   configuration required, across a wide range of index set types
--   (sequential, periodic, clustered, random). Judy's speed and memory
--   usage are typically better than other data storage models such as
--   skiplists, linked lists, binary, ternary, b-trees, or even hashing,
--   and improves with very large data sets.
--   
--   The memory used by a Judy array is nearly proportional to the
--   population (number of elements).
--   
--   For further references to the implementation, see:
--   
--   <ul>
--   <li><a>http://en.wikipedia.org/wiki/Judy_array</a></li>
--   </ul>
--   
--   <i>Examples</i>:
--   
--   Generate 1 million random integers. Report the largest one we see.
--   
--   <pre>
--   import System.Random.Mersenne
--   import qualified Data.Judy as J
--   import Control.Monad
--   
--   main = do
--      g  &lt;- getStdGen
--      rs &lt;- randoms g
--      j  &lt;- J.new :: IO (J.JudyL Int)
--      forM_ (take 1000000 rs) $ \n -&gt;
--          J.insert n 1 j
--      v  &lt;- J.findMax j
--      case v of
--           Nothing    -&gt; print "Done."
--           Just (k,_) -&gt; print k
--   </pre>
--   
--   Compile it:
--   
--   <pre>
--   $ ghc -O2 --make Test.hs
--   </pre>
--   
--   Running it:
--   
--   <pre>
--   $ time ./Test
--   18446712059962695226
--   ./Test  0.65s user 0.03s system 99% cpu 0.680 total
--   </pre>
--   
--   <i>Notes</i>:
--   
--   <ul>
--   <li><i>By default this library is threadsafe</i>.</li>
--   <li><i>Multiple Haskell threads may operate on the arrays
--   simultaneously. You can compile without locks if you know you're
--   running in a single threaded fashion with: cabal install
--   -funsafe</i></li>
--   </ul>
--   
--   Sun Sep 27 17:12:24 PDT 2009: The library has only lightly been
--   tested.
module Data.Judy

-- | A JudyL array is a mutable, finite map from Word to Word values. It is
--   threadsafe by default.
--   
--   A value is addressed by a key. The array may be sparse, and the key
--   may be any word-sized value. There are no duplicate keys.
--   
--   Values may be any instance of the JE class.
data JudyL a

-- | The type of keys in the JudyL arrays. A word-sized type (64 or 32
--   bits)
type Key = Word

-- | Allocate a new empty JudyL array.
--   
--   A finalizer is associated with the JudyL array, that will cause the
--   garbage collector to free it automatically once the last reference has
--   been dropped on the Haskell side.
--   
--   <i>Note: The Haskell GC will track references to the foreign resource,
--   but the foreign resource won't exert any heap pressure on the GC,
--   meaning that finalizers will be run much later than you expect. An
--   explicit <tt>performGC</tt> can help with this.</i>
--   
--   <i>Note: that if you store pointers in the Judy array we have no way
--   of deallocating those -- you'll need to track those yourself (e.g. via
--   StableName or ForeignPtr)</i>
new :: JE a => IO (JudyL a)

-- | <i>O(1)</i>, null. Is the map empty?
null :: JudyL a -> IO Bool

-- | <i>O(1)</i>, size. The number of elements in the map.
size :: JudyL a -> IO Int

-- | Is the key a member of the map?
member :: Key -> JudyL a -> IO Bool

-- | Lookup a value associated with a key in the JudyL array. Return
--   Nothing if no value is found.
lookup :: JE a => Key -> JudyL a -> IO (Maybe a)

-- | Insert a key and value pair into the JudyL array. Any existing key
--   will be overwritten.
insert :: JE a => Key -> a -> JudyL a -> IO ()

-- | Delete the Index/Value pair from the JudyL array.
delete :: Key -> JudyL a -> IO ()

-- | Update a value at a specific key with the result of the provided
--   function. When the key is not a member of the map, no change is made.
adjust :: JE a => (a -> a) -> Key -> JudyL a -> IO ()

-- | findMin. Find the minimal key, and its associated value, in the map.
--   Nothing if the map is empty.
findMin :: JE a => JudyL a -> IO (Maybe (Key, a))

-- | findMax. Find the maximal key, and its associated value, in the map.
--   Nothing if the map is empty.
findMax :: JE a => JudyL a -> IO (Maybe (Key, a))

-- | Return all keys of the map, <i>lazily</i>, in ascending order.
keys :: JudyL a -> IO [Key]

-- | Return all elems of the map, <i>lazily</i>, in ascending order.
elems :: JE a => JudyL a -> IO [a]

-- | Class of things that can be stored in the JudyL array. You need to be
--   able to convert the structure to a Word value, or a word-sized
--   pointer.
--   
--   <i>Note: that it is possible to convert any Haskell value into a
--   JE-type, via a StablePtr. This allocates an entry in the runtime's
--   stable pointer table, giving you a pointer that may be passed to C,
--   and that when dereferenced in Haskell will yield the original Haskell
--   value. See the source for an example of this with strict
--   bytestrings.</i>
class JE a
toWord :: JE a => a -> IO Word
fromWord :: JE a => Word -> IO a
instance JE ByteString
instance JE Char
instance JE Word32
instance JE Word16
instance JE Word8
instance JE Int32
instance JE Int16
instance JE Int8
instance JE Int
instance JE Word
instance JE Ordering
instance JE Bool
instance JE ()
instance Show (JudyL a)
