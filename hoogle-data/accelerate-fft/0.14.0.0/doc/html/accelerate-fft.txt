-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FFT using the Accelerate library
--   
--   Rank-polymorphic discrete Fourier transform (DFT), computed with a
--   fast Fourier transform (FFT) algorithm using the Accelerate library
--   
--   Refer to the main <i>Accelerate</i> package for more information:
--   <a>http://hackage.haskell.org/package/accelerate</a>
@package accelerate-fft
@version 0.14.0.0

module Data.Array.Accelerate.Math.Complex
data Complex a :: * -> *
(:+) :: !a -> !a -> Complex a

-- | Non-negative magnitude of a complex number
magnitude :: (Elt a, IsFloating a) => Exp (Complex a) -> Exp a

-- | The phase of a complex number, in the range (-pi, pi]. If the
--   magnitude is zero, then so is the phase.
phase :: (Elt a, IsFloating a) => Exp (Complex a) -> Exp a

-- | Return the real part of a complex number
real :: Elt a => Exp (Complex a) -> Exp a

-- | Return the imaginary part of a complex number
imag :: Elt a => Exp (Complex a) -> Exp a

-- | Return the complex conjugate of a complex number, defined as
--   
--   <pre>
--   conj(Z) = X - iY
--   </pre>
conj :: (Elt a, IsNum a) => Exp (Complex a) -> Exp (Complex a)
instance [incoherent] (Elt a, IsFloating a, RealFloat a) => Floating (Exp (Complex a))
instance [incoherent] (Elt a, IsFloating a) => Fractional (Exp (Complex a))
instance [incoherent] (Elt a, IsFloating a) => Num (Exp (Complex a))
instance [incoherent] Elt a => Unlift Exp (Complex (Exp a))
instance [incoherent] (Lift Exp a, Elt (Plain a)) => Lift Exp (Complex a)
instance [incoherent] IsTuple (Complex a)
instance [incoherent] Elt a => Elt (Complex a)


-- | Computation of a Discrete Fourier Transform using the Cooley-Tuckey
--   algorithm. The time complexity is O(n log n) in the size of the input.
--   
--   This uses a naïve divide-and-conquer algorithm whose absolute
--   performance is appalling.
module Data.Array.Accelerate.Math.FFT
data Mode
Forward :: Mode
Reverse :: Mode
Inverse :: Mode
fft1D :: (Elt e, IsFloating e) => Mode -> Vector (Complex e) -> Acc (Vector (Complex e))
fft1D' :: (Elt e, IsFloating e) => Mode -> Int -> Acc (Vector (Complex e)) -> Acc (Vector (Complex e))
fft2D :: (Elt e, IsFloating e) => Mode -> Array DIM2 (Complex e) -> Acc (Array DIM2 (Complex e))
fft2D' :: (Elt e, IsFloating e) => Mode -> Int -> Int -> Acc (Array DIM2 (Complex e)) -> Acc (Array DIM2 (Complex e))
fft3D :: (Elt e, IsFloating e) => Mode -> Array DIM3 (Complex e) -> Acc (Array DIM3 (Complex e))
fft3D' :: (Elt e, IsFloating e) => Mode -> Int -> Int -> Int -> Acc (Array DIM3 (Complex e)) -> Acc (Array DIM3 (Complex e))
fft :: (Slice sh, Shape sh, IsFloating e, Elt e) => e -> sh -> Int -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))
instance Eq Mode
instance Show Mode


module Data.Array.Accelerate.Math.DFT.Roots

-- | Calculate the roots of unity for the forward transform
rootsOfUnity :: (Elt e, IsFloating e, Shape sh, Slice sh) => Exp (sh :. Int) -> Acc (Array (sh :. Int) (Complex e))

-- | Calculate the roots of unity for an inverse transform
inverseRootsOfUnity :: (Elt e, IsFloating e, Shape sh, Slice sh) => Exp (sh :. Int) -> Acc (Array (sh :. Int) (Complex e))


-- | Compute the Discrete Fourier Transform (DFT) along the lower order
--   dimension of an array.
--   
--   This uses a naïve algorithm which takes O(n^2) time. However, you can
--   transform an array with an arbitrary extent, unlike with FFT which
--   requires each dimension to be a power of two.
--   
--   The <a>dft</a> and <a>idft</a> functions compute the roots of unity as
--   needed. If you need to transform several arrays with the same extent
--   than it is faster to compute the roots once using <a>rootsOfUnity</a>
--   or <a>inverseRootsOfUnity</a> respectively, then call <a>dftG</a>
--   directly.
--   
--   You can also compute single values of the transform using <a>dftGS</a>
module Data.Array.Accelerate.Math.DFT

-- | Compute the DFT along the low order dimension of an array
dft :: (Shape sh, Slice sh, Elt e, IsFloating e) => Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Compute the inverse DFT along the low order dimension of an array
idft :: (Shape sh, Slice sh, Elt e, IsFloating e) => Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Generic function for computation of forward and inverse DFT. This
--   function is also useful if you transform many arrays of the same
--   extent, and don't want to recompute the roots for each one.
--   
--   The extent of the input and roots must match.
dftG :: (Shape sh, Slice sh, Elt e, IsFloating e) => Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Compute a single value of the DFT.
dftGS :: (Shape sh, Slice sh, Elt e, IsFloating e) => Exp (sh :. Int) -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Scalar (Complex e))


-- | These transforms allow the centering of the frequency domain of a DFT
--   such that the the zero frequency is in the middle. The centering
--   transform, when performed on the input of a DFT, will cause zero
--   frequency to be centred in the middle. The shifting transform however
--   takes the output of a DFT to give the same result. Therefore the
--   relationship between the two is:
--   
--   <pre>
--   fft(center(X)) = shift(fft(X))
--   </pre>
module Data.Array.Accelerate.Math.DFT.Centre

-- | Apply the centring transform to a vector
centre1D :: (Elt e, IsFloating e) => Acc (Array DIM1 (Complex e)) -> Acc (Array DIM1 (Complex e))

-- | Apply the centring transform to a matrix
centre2D :: (Elt e, IsFloating e) => Acc (Array DIM2 (Complex e)) -> Acc (Array DIM2 (Complex e))

-- | Apply the centring transform to a 3D array
centre3D :: (Elt e, IsFloating e) => Acc (Array DIM3 (Complex e)) -> Acc (Array DIM3 (Complex e))

-- | Apply the shifting transform to a vector
shift1D :: Elt e => Acc (Vector e) -> Acc (Vector e)

-- | Apply the shifting transform to a 2D array
shift2D :: Elt e => Acc (Array DIM2 e) -> Acc (Array DIM2 e)

-- | Apply the shifting transform to a 3D array
shift3D :: Elt e => Acc (Array DIM3 e) -> Acc (Array DIM3 e)
