-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Space-efficient and privacy-preserving data dispersal algorithms.
--   
@package data-dispersal
@version 1.0.0.2


-- | Linear algebra computations in a finite prime field.
module Data.IDA.FiniteField

-- | Our finite prime field. All computations are performed in this field.
newtype FField
FField :: PrimeField (I (O (I (I (I (I (I (I (I (I Z)))))))))) -> FField
number :: FField -> PrimeField (I (O (I (I (I (I (I (I (I (I Z))))))))))

-- | The size of the finite field
prime :: Int

-- | A matrix over the finite field.
type FMatrix = Matrix FField
dotProduct :: Num a => Vector a -> Vector a -> a

-- | Solves a linear equality system <tt>A x = b</tt> given by a lower
--   triangular matrix via forward substitution.
forwardSub :: Fractional a => Matrix a -> Vector a -> Vector a

-- | Solves a linear equality system <tt>A x = b</tt> given by an upper
--   triangular matrix via backward substitution.
backwardSub :: Fractional a => Matrix a -> Vector a -> Vector a

-- | Compute the inverse of matrix. Throws <a>AssertionFailed</a> if the
--   matrix is not invertible.
inverse :: (Ord a, Fractional a) => Matrix a -> Matrix a

-- | Construct a Vandermonde matrix. The i-th list element is the i-th seed
--   of the geometric progression of the i-th row.
vandermonde :: Int -> [FField] -> FMatrix

-- | Create an nxm Vandermonde matrix. <i>O(n m)</i>.
vmatrix :: Int -> Int -> FMatrix
instance [overlap ok] Typeable FField
instance [overlap ok] Read FField
instance [overlap ok] Ord FField
instance [overlap ok] Eq FField
instance [overlap ok] Num FField
instance [overlap ok] Fractional FField
instance [overlap ok] Generic FField
instance [overlap ok] FiniteField FField
instance Datatype D1FField
instance Constructor C1_0FField
instance Selector S1_0_0FField
instance [overlap ok] Binary FField
instance [overlap ok] Enum FField
instance [overlap ok] Monoid FField
instance [overlap ok] Show FField


module Data.IDA.Internal

-- | A fragment of the original data.
data Fragment
Fragment :: !Int -> !Int -> !Int -> ![FField] -> !Int -> Fragment

-- | index of this fragment
fragmentId :: Fragment -> !Int

-- | number of symbols added to the original message
trailLength :: Fragment -> !Int

-- | number of fragments required for reconstruction
reconstructionThreshold :: Fragment -> !Int

-- | the encoded content of the fragment
theContent :: Fragment -> ![FField]

-- | length of the original message
msgLength :: Fragment -> !Int

-- | Takes a message (a bytestring) and yields <tt>n</tt> fragments such
--   that any <tt>m</tt> of them are sufficient for reconstructing the
--   original message.
encode :: Int -> Int -> ByteString -> [Fragment]

-- | Takes a list of at least m fragments (where <tt>m</tt> is the
--   reconstruction threshold used for <a>encode</a>) and tries to
--   reconstruct the original message. Throws an <a>AssertionFailed</a>
--   exception if there are less than m fragments or if the fragments
--   belong to a different message.
decode :: [Fragment] -> ByteString

-- | Takes an integer m and a bytestring and converts the bytestring into a
--   'Vector Word8', appending 0s at the end such that the length is
--   dividable by m.
toIntVec :: Int -> ByteString -> (Vector FField, Int)

-- | Converts a bytestring to a 'Vector Word8', removing the trailing 0s.
fromIntVec :: Int -> Vector FField -> ByteString

-- | Splits a vector into lists of the given size. O(vector-length / size).
groupInto :: Int -> Vector a -> [Vector a]
instance Typeable Fragment
instance Eq Fragment
instance Generic Fragment
instance Datatype D1Fragment
instance Constructor C1_0Fragment
instance Selector S1_0_0Fragment
instance Selector S1_0_1Fragment
instance Selector S1_0_2Fragment
instance Selector S1_0_3Fragment
instance Selector S1_0_4Fragment
instance Binary Fragment
instance Show Fragment


-- | This module provides an (m,n)-information dispersal scheme that
--   provides data redundancy while preserving secrecy. In other words,
--   this module combines the best of 2 worlds: secret sharing algorithms
--   with low-overhead information dispersal.
--   
--   Function <a>encode</a> splits a given bytestring into <tt>n</tt>
--   fragments with the following properties:
--   
--   <ol>
--   <li>Any <tt>m</tt> of the <tt>n</tt> fragments are sufficient for
--   reconstructing the original bytestring via <a>decode</a>, and</li>
--   <li>the knowledge of up to <tt>m-1</tt> fragments does <i>not</i> leak
--   any information about the original bytestring.</li>
--   </ol>
--   
--   In more detail, suppose that we have some bytestring <tt>b</tt> that
--   we want to (securely) disperse and parameter <tt>m</tt>, <tt>n</tt>.
--   Running <a>encode</a> <tt>m n b</tt> does the following:
--   
--   <ul>
--   <li>Generate a randomly chosen key of 32 bytes, called
--   <tt>key</tt>.</li>
--   <li>Encrypt the bytestring <tt>b</tt> using <tt>key</tt> via AES.</li>
--   <li>Generate <tt>n</tt> shares using the perfect secret sharing
--   algorithm implemented in module <a>Crypto.SecretSharing</a>; see
--   package
--   <a>http://hackage.haskell.org/package/secret-sharing</a>secret-sharing</li>
--   <li>Generate <tt>n</tt> fragments of the encrypted data using the
--   information dispersal algorithm in <a>Data.IDA</a>.</li>
--   <li>Finally, we pair up these shares and fragments as a list of
--   <a>EncryptedFragment</a>s.</li>
--   </ul>
--   
--   The size of each encrypted fragment is <tt>O(|b|/m + |key|)</tt>. For
--   sufficiently large bytestrings, the <tt>O(|b|/m)</tt> factor dominates
--   and thus the scheme is space-optimal.
--   
--   The secret sharing algorithm guarantess that the knowledge of up to
--   <tt>m-1</tt> of the fragments does not leak any information about the
--   encryption key (and hence the encrypted data).
module Crypto.IDA
data EncryptedFragment

-- | Space efficient and secrecy-preserving (m,n)-information dispersal:
--   Generates <tt>n</tt> fragments out of a given bytestring <tt>b</tt>.
--   Each fragment has size <tt>length b / m + O(1)</tt>. At least m
--   fragments are required for reconstruction. Preserves secrecy: The
--   knowledge of less than m fragments provides <i>no</i> information
--   about the original data whatsoever.
encode :: Int -> Int -> ByteString -> IO [EncryptedFragment]

-- | Same as <a>encode</a> but uses an initialization vector for the AES
--   encryption.
encodeWithIV :: Int -> Int -> ByteString -> ByteString -> IO [EncryptedFragment]

-- | Reconstruct the original data from (at least) <tt>m</tt> fragments.
--   Throws an <a>AssertionFailed</a> exception if an insufficient number
--   fragments are given or if a decoding error occurs.
decode :: [EncryptedFragment] -> ByteString
instance Typeable EncryptedFragment
instance Eq EncryptedFragment
instance Generic EncryptedFragment
instance Datatype D1EncryptedFragment
instance Constructor C1_0EncryptedFragment
instance Selector S1_0_0EncryptedFragment
instance Selector S1_0_1EncryptedFragment
instance Selector S1_0_2EncryptedFragment
instance Binary EncryptedFragment
instance Show EncryptedFragment


-- | This module provides an implementation of a space efficient
--   (m,n)-threshold information dispersal algorithm (IDA) as described in
--   "Efficient Dispersal of Information for Security, Load Balancing, and
--   Fault Tolerance", by Michael O. Rabin, JACM 1989.
--   
--   Given a ByteString bstr of length D &gt;&gt;&gt; f = encode m n bstr
--   encodes bstr as a list of n <a>Fragment</a>s, each containing a
--   ByteString of length approximately <tt>D/m</tt>. For reconstructing
--   the original ByteString out of a sublist fssub of fs, consisting of at
--   least m fragments, use &gt;&gt;&gt; decode fssub
module Data.IDA

-- | Takes a message (a bytestring) and yields <tt>n</tt> fragments such
--   that any <tt>m</tt> of them are sufficient for reconstructing the
--   original message.
encode :: Int -> Int -> ByteString -> [Fragment]

-- | Takes a list of at least m fragments (where <tt>m</tt> is the
--   reconstruction threshold used for <a>encode</a>) and tries to
--   reconstruct the original message. Throws an <a>AssertionFailed</a>
--   exception if there are less than m fragments or if the fragments
--   belong to a different message.
decode :: [Fragment] -> ByteString

-- | A fragment of the original data.
data Fragment
