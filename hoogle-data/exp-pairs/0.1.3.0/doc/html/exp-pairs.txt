-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Linear programming over exponent pairs
--   
@package exp-pairs
@version 0.1.3.0


-- | Provides types and functions for matrices and vectors of order 3. Can
--   be used instead of <a>Data.Matrix</a> to reduce overhead and simplify
--   code.
module Math.ExpPairs.Matrix3

-- | Matrix of order 3. Instances of <a>Num</a> and <a>Fractional</a> are
--   given in terms of the multiplicative group of matrices, not the
--   additive one. E. g.,
--   
--   <pre>
--   toList 1 == [1,0,0,0,1,0,0,0,1]
--   toList 1 /= [1,1,1,1,1,1,1,1,1]
--   </pre>
data Matrix3 t
Matrix3 :: !t -> !t -> !t -> !t -> !t -> !t -> !t -> !t -> !t -> Matrix3 t
a11 :: Matrix3 t -> !t
a12 :: Matrix3 t -> !t
a13 :: Matrix3 t -> !t
a21 :: Matrix3 t -> !t
a22 :: Matrix3 t -> !t
a23 :: Matrix3 t -> !t
a31 :: Matrix3 t -> !t
a32 :: Matrix3 t -> !t
a33 :: Matrix3 t -> !t

-- | Three-component vector.
data Vector3 t
Vector3 :: !t -> !t -> !t -> Vector3 t
a1 :: Vector3 t -> !t
a2 :: Vector3 t -> !t
a3 :: Vector3 t -> !t

-- | Convert a list of 9 elements into <a>Matrix3</a>. Reverse conversion
--   can be done by <a>toList</a> from <a>Data.Foldable</a>.
fromList :: [t] -> Matrix3 t

-- | List of elements of a structure.
toList :: Foldable t => t a -> [a]

-- | Compute the determinant of a matrix.
det :: (Num t, Ord t) => Matrix3 t -> t

-- | Multiplicate a matrix by a vector (considered as a column).
multCol :: Num t => Matrix3 t -> Vector3 t -> Vector3 t

-- | Divide all elements of the matrix by their greatest common divisor.
--   This is useful for matrices of projective transformations to reduce
--   the magnitude of computations.
normalize :: Integral t => Matrix3 t -> Matrix3 t

-- | Multiplicate matrices under assumption that multiplication of elements
--   is commutative. Requires 22 multiplications and 66 additions. It
--   becomes faster than usual multiplication (which requires 27
--   multiplications and 18 additions), when matrix's elements are large
--   (several hundred digits) integers.
--   
--   An algorithm follows <i>O. M. Makarov.</i> An algorithm for
--   multiplication of 3 × 3 matrices. Zh. Vychisl. Mat. i Mat. Fiz.,
--   26(2):293–294, 320, 1986.
--   
--   We were able to reduce the number of additions from 105 to 66 by
--   sofisticated choice of intermediate variables.
makarovMult :: Num t => Matrix3 t -> Matrix3 t -> Matrix3 t

-- | Multiplicate matrices by 23 multiplications and 68 additions. It
--   becomes faster than usual multiplication (which requires 27
--   multiplications and 18 additions), when matrix's elements are large
--   (several hundred digits) integers.
--   
--   An algorithm follows <i>J. Laderman.</i> A noncommutative algorithm
--   for multiplying 3 × 3 matrices using 23 multiplications. Bull. Amer.
--   Math. Soc., 82:126–128, 1976.
--   
--   We were able to reduce the number of additions from 98 to 68 by
--   sofisticated choice of intermediate variables.
ladermanMult :: Num t => Matrix3 t -> Matrix3 t -> Matrix3 t
instance Eq t => Eq (Vector3 t)
instance Show t => Show (Vector3 t)
instance Functor Vector3
instance Foldable Vector3
instance Generic (Vector3 t)
instance Eq t => Eq (Matrix3 t)
instance Functor Matrix3
instance Foldable Matrix3
instance Generic (Matrix3 t)
instance Datatype D1Vector3
instance Constructor C1_0Vector3
instance Selector S1_0_0Vector3
instance Selector S1_0_1Vector3
instance Selector S1_0_2Vector3
instance Datatype D1Matrix3
instance Constructor C1_0Matrix3
instance Selector S1_0_0Matrix3
instance Selector S1_0_1Matrix3
instance Selector S1_0_2Matrix3
instance Selector S1_0_3Matrix3
instance Selector S1_0_4Matrix3
instance Selector S1_0_5Matrix3
instance Selector S1_0_6Matrix3
instance Selector S1_0_7Matrix3
instance Selector S1_0_8Matrix3
instance Show t => Show (Matrix3 t)
instance (Fractional t, Ord t) => Fractional (Matrix3 t)
instance (Num t, Ord t) => Num (Matrix3 t)
instance NFData t => NFData (Matrix3 t)
instance NFData t => NFData (Vector3 t)


-- | Provides types for sequences of <i>A</i>- and <i>B</i>-processes of
--   van der Corput. A good account on this topic can be found in <i>Graham
--   S. W., Kolesnik G. A.</i> Van Der Corput's Method of Exponential Sums,
--   Cambridge University Press, 1991, especially Ch. 5.
module Math.ExpPairs.ProcessMatrix

-- | Since B^2 = id, B <tt>Corput16</tt> = <tt>Corput16</tt>, B
--   <tt>Hux05</tt> = <tt>Hux05</tt> and B <tt>HuxW87b1</tt> = ???, the
--   sequence of <i>A</i>- and <i>B</i>-processes, applied to
--   <tt>initPairs</tt> can be rewritten as a sequence of <a>A</a> and
--   <a>BA</a>.
data Process

-- | <i>A</i>-process
A :: Process

-- | <i>BA</i>-process
BA :: Process
data ProcessMatrix

-- | Return process matrix for <a>A</a>-process.
aMatrix :: ProcessMatrix

-- | Return process matrix for <a>BA</a>-process.
baMatrix :: ProcessMatrix

-- | Apply a projective transformation, defined by <tt>Path</tt>, to a
--   given point in two-dimensional projective space.
evalMatrix :: Num t => ProcessMatrix -> (t, t, t) -> (t, t, t)
instance Eq ProcessMatrix
instance Num ProcessMatrix
instance Show ProcessMatrix
instance Monoid ProcessMatrix
instance Memoizable Process
instance Eq Process
instance Show Process
instance Read Process
instance Ord Process
instance Enum Process


-- | Transforms sequences of <a>Process</a> into most compact (by the means
--   of typesetting) representation using brackets and powers. E. g.,
--   AAAABABABA -&gt; A^4(BA)^3.
--   
--   This module uses memoization extensively.
module Math.ExpPairs.PrettyProcess

-- | Find the most compact representation of the sequence of processes.
prettify :: [Process] -> PrettyProcess

-- | Unfold back <a>PrettyProcess</a> into the sequence of <a>Process</a>.
uglify :: PrettyProcess -> [Process]

-- | Compact representation of the sequence of <a>Process</a>.
data PrettyProcess
instance Pretty PrettyProcess
instance Memoizable PrettyProcess
instance Show PrettyProcess


-- | Provides types and necessary instances for rational numbers, extended
--   with infinite values. Just use <a>RationalInf</a> instead of
--   <a>Rational</a> from <a>Data.Ratio</a>.
module Math.ExpPairs.RatioInf

-- | Extends a rational type with positive and negative infinities.
data RatioInf t

-- | Negative infinity
InfMinus :: RatioInf t

-- | Finite value
Finite :: !(Ratio t) -> RatioInf t

-- | Positive infinity
InfPlus :: RatioInf t

-- | Arbitrary-precision rational numbers with positive and negative
--   infinities.
type RationalInf = RatioInf Integer
instance Integral t => Ord (RatioInf t)
instance Eq t => Eq (RatioInf t)
instance Integral t => Real (RatioInf t)
instance Integral t => Fractional (RatioInf t)
instance Integral t => Num (RatioInf t)
instance (Integral t, Show t) => Show (RatioInf t)


-- | Provides a set of initial exponent pairs, consisting of two points (0,
--   1), (1/2, 1/2) and a triangle with vertices in (1/6, 2/3), (2/13,
--   35/52) and (32/205, 269/410). The triangle is represented as a list of
--   nodes of a net, covering the triangle.
--   
--   Below <i>A</i> and <i>B</i> stands for van der Corput's processes. See
--   <a>Math.ExpPairs.Process</a> for explanations.
module Math.ExpPairs.Pair

-- | Vertices of the triangle of initial exponent pairs.
data Triangle

-- | Usual van der Corput exponent pair (1/6, 2/3) = <i>AB</i>(0, 1).
Corput16 :: Triangle

-- | An exponent pair (2/13, 35/52) from <i>Huxley M. N.</i> `Exponential
--   sums and the Riemann zeta function' // Proceedings of the
--   International Number Theory Conference held at Universite Laval in
--   1987, Walter de Gruyter, 1989, P. 417-423.
HuxW87b1 :: Triangle

-- | An exponent pair (32/205, 269/410) from <i>Huxley M. N.</i>
--   `Exponential sums and the Riemann zeta function V' // Proc. Lond.
--   Math. Soc., 2005, Vol. 90, no. 1., P. 1--41.
Hux05 :: Triangle

-- | Type to hold an initial exponent pair.
data InitPair' t

-- | Usual van der Corput exponent pair (0, 1).
Corput01 :: InitPair' t

-- | Usual van der Corput exponent pair (1/2, 1/2) = <i>B</i>(0, 1).
Corput12 :: InitPair' t

-- | Point from the interior of <a>Triangle</a>. Exactly <a>Mix</a> a b = a
--   * <a>Corput16</a> + b * <a>HuxW87b1</a> + (1-a-b) * <a>Hux05</a>
Mix :: t -> t -> InitPair' t

-- | Exponent pair built from rational fractions of <a>Corput16</a>,
--   <a>HuxW87b1</a> and <a>Hux05</a>
type InitPair = InitPair' Rational

-- | The set of initial exponent pairs. It consists of <a>Corput01</a>,
--   <a>Corput12</a> and 496 = sum [1..31] <a>Mix</a>-points, which forms a
--   uniform net over <a>Triangle</a>.
initPairs :: [InitPair]

-- | Convert initial exponent pair from its symbolic representation as
--   <a>InitPair</a> to pair of rationals.
initPairToValue :: InitPair -> (Rational, Rational)
instance Show Triangle
instance Bounded Triangle
instance Enum Triangle
instance Eq Triangle
instance Ord Triangle
instance Eq t => Eq (InitPair' t)
instance (Show t, Num t, Eq t) => Show (InitPair' t)


-- | Provides types for sequences of <i>A</i>- and <i>B</i>-processes of
--   van der Corput. A good account on this topic can be found in <i>Graham
--   S. W., Kolesnik G. A.</i> Van Der Corput's Method of Exponential Sums,
--   Cambridge University Press, 1991, especially Ch. 5.
module Math.ExpPairs.Process

-- | Since B^2 = id, B <tt>Corput16</tt> = <tt>Corput16</tt>, B
--   <tt>Hux05</tt> = <tt>Hux05</tt> and B <tt>HuxW87b1</tt> = ???, the
--   sequence of <i>A</i>- and <i>B</i>-processes, applied to
--   <tt>initPairs</tt> can be rewritten as a sequence of <a>A</a> and
--   <a>BA</a>.
data Process

-- | Holds a list of <a>Process</a> and a matrix of projective
--   transformation, which they define. It also provides a fancy
--   <a>Show</a> instance. E. g.,
--   
--   <pre>
--   show (mconcat $ replicate 10 aPath) == "A^10"
--   </pre>
data Path
Path :: !ProcessMatrix -> ![Process] -> Path

-- | Path consisting of a single process <a>A</a>.
aPath :: Path

-- | Path consisting of a single process <a>BA</a>.
baPath :: Path

-- | Apply a projective transformation, defined by <a>Path</a>, to a given
--   point in two-dimensional projective space.
evalPath :: Num t => Path -> (t, t, t) -> (t, t, t)

-- | Count processes in the <a>Path</a>. Note that <a>BA</a> counts for one
--   process, not two.
lengthPath :: Path -> Int
instance Eq Path
instance Generic Path
instance Datatype D1Path
instance Constructor C1_0Path
instance Ord Path
instance Read Path
instance Show Path
instance Monoid Path


-- | Provides types for rational forms (to hold objective functions in
--   <a>Math.ExpPairs</a>) and linear contraints (to hold constraints of
--   optimization). Both of them are built atop of projective linear forms.
module Math.ExpPairs.LinearForm

-- | Define an affine linear form of two variables: a*k + b*l + c*m. First
--   argument of <a>LinearForm</a> stands for a, second for b and third for
--   c. Linear forms form a monoid by addition.
data LinearForm t
LinearForm :: t -> t -> t -> LinearForm t

-- | Evaluate a linear form a*k + b*l + c*m for given k, l and m.
evalLF :: Num t => (t, t, t) -> LinearForm t -> t

-- | Substitute linear forms k, l and m into a given linear form a*k + b*l
--   + c*m to obtain a new linear form.
substituteLF :: (Eq t, Num t) => (LinearForm t, LinearForm t, LinearForm t) -> LinearForm t -> LinearForm t

-- | Define a rational form of two variables, equal to the ratio of two
--   <a>LinearForm</a>.
data RationalForm t
RationalForm :: (LinearForm t) -> (LinearForm t) -> RationalForm t

-- | Evaluate a rational form (a*k + b*l + c*m) / (a'*k + b'*l + c'*m) for
--   given k, l and m.
evalRF :: (Real t, Num t) => (Integer, Integer, Integer) -> RationalForm t -> RationalInf

-- | Constants to specify the strictness of <a>Constraint</a>.
data IneqType

-- | Strict inequality (&gt;0).
Strict :: IneqType

-- | Non-strict inequality (≥0).
NonStrict :: IneqType

-- | A linear constraint of two variables.
data Constraint t
Constraint :: (LinearForm t) -> IneqType -> Constraint t

-- | Evaluate a rational form of constraint and compare its value with 0.
--   Strictness depends on the given <a>IneqType</a>.
checkConstraint :: (Num t, Eq t) => (Integer, Integer, Integer) -> Constraint t -> Bool
instance Eq t => Eq (LinearForm t)
instance Functor LinearForm
instance Foldable LinearForm
instance Generic (LinearForm t)
instance Eq t => Eq (RationalForm t)
instance (Eq t, Num t, Show t) => Show (RationalForm t)
instance Functor RationalForm
instance Foldable RationalForm
instance Generic (RationalForm t)
instance Eq IneqType
instance Ord IneqType
instance Show IneqType
instance Enum IneqType
instance Bounded IneqType
instance Eq t => Eq (Constraint t)
instance (Eq t, Num t, Show t) => Show (Constraint t)
instance Functor Constraint
instance Foldable Constraint
instance Generic (Constraint t)
instance Datatype D1LinearForm
instance Constructor C1_0LinearForm
instance Datatype D1RationalForm
instance Constructor C1_0RationalForm
instance Datatype D1Constraint
instance Constructor C1_0Constraint
instance NFData t => NFData (Constraint t)
instance Num t => Fractional (RationalForm t)
instance Num t => Num (RationalForm t)
instance NFData t => NFData (RationalForm t)
instance Num t => Monoid (LinearForm t)
instance Num t => Num (LinearForm t)
instance (Num t, Eq t, Show t) => Show (LinearForm t)
instance NFData t => NFData (LinearForm t)


-- | Package implements an algorithm to minimize the maximum of a list of
--   rational objective functions over the set of exponent pairs. See full
--   description in A. V. Lelechenko, Linear programming over exponent
--   pairs. Acta Univ. Sapientiae, Inform. 5, No. 2, 271-287 (2013).
--   <a>http://www.acta.sapientia.ro/acta-info/C5-2/info52-7.pdf</a>
--   
--   A set of useful applications can be found in
--   <a>Math.ExpPairs.Ivic</a>, <a>Math.ExpPairs.Kratzel</a> and
--   <a>Math.ExpPairs.MenzerNowak</a>.
module Math.ExpPairs

-- | This function takes a list of rational forms and a list of constraints
--   and returns an exponent pair, which satisfies all constraints and
--   minimizes the maximum of all rational forms.
optimize :: [RationalForm Rational] -> [Constraint Rational] -> OptimizeResult

-- | Container for the result of optimization.
data OptimizeResult

-- | The minimal value of objective function.
optimalValue :: OptimizeResult -> RationalInf

-- | The initial exponent pair, on which minimal value was achieved.
optimalPair :: OptimizeResult -> InitPair

-- | The sequence of processes, after which minimal value was achieved.
optimalPath :: OptimizeResult -> Path

-- | Wrap <a>Rational</a> into <a>OptimizeResult</a>.
simulateOptimize :: Rational -> OptimizeResult

-- | Wrap <a>RationalInf</a> into <a>OptimizeResult</a>.
simulateOptimize' :: RationalInf -> OptimizeResult

-- | Define an affine linear form of two variables: a*k + b*l + c*m. First
--   argument of <a>LinearForm</a> stands for a, second for b and third for
--   c. Linear forms form a monoid by addition.
data LinearForm t
LinearForm :: t -> t -> t -> LinearForm t

-- | Define a rational form of two variables, equal to the ratio of two
--   <a>LinearForm</a>.
data RationalForm t
RationalForm :: (LinearForm t) -> (LinearForm t) -> RationalForm t

-- | Constants to specify the strictness of <a>Constraint</a>.
data IneqType

-- | Strict inequality (&gt;0).
Strict :: IneqType

-- | Non-strict inequality (≥0).
NonStrict :: IneqType

-- | A linear constraint of two variables.
data Constraint t
Constraint :: (LinearForm t) -> IneqType -> Constraint t

-- | Exponent pair built from rational fractions of <a>Corput16</a>,
--   <a>HuxW87b1</a> and <a>Hux05</a>
type InitPair = InitPair' Rational

-- | Holds a list of <a>Process</a> and a matrix of projective
--   transformation, which they define. It also provides a fancy
--   <a>Show</a> instance. E. g.,
--   
--   <pre>
--   show (mconcat $ replicate 10 aPath) == "A^10"
--   </pre>
data Path

-- | Extends a rational type with positive and negative infinities.
data RatioInf t

-- | Negative infinity
InfMinus :: RatioInf t

-- | Finite value
Finite :: !(Ratio t) -> RatioInf t

-- | Positive infinity
InfPlus :: RatioInf t

-- | Arbitrary-precision rational numbers with positive and negative
--   infinities.
type RationalInf = RatioInf Integer
instance Ord OptimizeResult
instance Eq OptimizeResult
instance Show OptimizeResult


-- | Provides functions to compute estimates Riemann zeta-function ζ in a
--   critical strip, given in <i>Ivić A.</i> `The Riemann zeta-function:
--   Theory and applications', Mineola, New York: Dover Publications, 2003.
module Math.ExpPairs.Ivic

-- | Compute µ(σ) such that |ζ(σ+it)| ≪ |t|^µ(σ) . See equation (7.57) in
--   Ivić2003.
zetaOnS :: Rational -> OptimizeResult

-- | An attempt to reverse <a>zetaOnS</a>.
reverseZetaOnS :: Rational -> OptimizeResult

-- | Compute maximal m(σ) such that ∫_1^T |ζ(σ+it)|^m(σ) dt ≪ T^(1+ε). See
--   equation (8.97) in Ivić2003.
mOnS :: Rational -> OptimizeResult

-- | Try to reverse <a>mOnS</a>: for a given precision and m compute
--   minimal possible σ. Implementation is usual try-and-divide search, so
--   performance is very poor. Sometimes, when <a>mOnS</a> gets especially
--   lucky exponent pair, <a>reverseMOnS</a> can miss real σ and returns
--   bigger value.
reverseMOnS :: Rational -> RationalInf -> Rational

-- | Check whether ∫_1^T Π |ζ(n_i*σ+it)|^m_i dt ≪ T^(1+ε) for a given list
--   of pairs [(n_1, m_1), ...] and fixed σ.
checkAbscissa :: [(Rational, Rational)] -> Rational -> Bool

-- | Find for a given precision and list of pairs [(n_1, m_1), ...] the
--   minimal σ such that ∫_1^T Π |ζ(n_i*σ+it)|^m_i dt ≪ T^(1+ε).
findMinAbscissa :: Rational -> [(Rational, Rational)] -> Rational

-- | Compute minimal M(A) such that ∫_1^T |ζ(1/2+it)|^A dt ≪ T^(M(A)+ε).
--   See Ch. 8 in Ivić2003. Further justification will be published
--   elsewhere.
mBigOnHalf :: Rational -> OptimizeResult

-- | Try to reverse <a>mBigOnHalf</a>: for a given M(A) find maximal
--   possible A. Sometimes, when <a>mBigOnHalf</a> gets especially lucky
--   exponent pair, <a>reverseMBigOnHalf</a> can miss real A and returns
--   lower value.
reverseMBigOnHalf :: Rational -> OptimizeResult


-- | Let τ_{a, b}(n) denote the number of integer (v, w) with v^a w^b = n.
--   
--   Let τ_{a, b, c}(n) denote the number of integer (v, w, z) with v^a w^b
--   z^c = n.
--   
--   Krätzel (<i>Krätzel E.</i> `Lattice points'. Dordrecht: Kluwer, 1988)
--   proved asymptotic formulas for Σ_{n ≤ x} τ_{a, b}(n) with an error
--   term of order x^(Θ(a, b) + ε) and for Σ_{n ≤ x} τ_{a, b, c}(n) with an
--   error term of order x^(Θ(a, b, c) + ε). He also provided a set of
--   theorems to estimate Θ(a, b) and Θ(a, b, c).
module Math.ExpPairs.Kratzel

-- | Special type to specify the theorem of Krätzel1988, which provided the
--   best estimate of Θ(a, b)
data TauabTheorem

-- | Theorem 5.11, case a)
Kr511a :: TauabTheorem

-- | Theorem 5.11, case b)
Kr511b :: TauabTheorem

-- | Theorem 5.12, case a)
Kr512a :: TauabTheorem

-- | Theorem 5.12, case b)
Kr512b :: TauabTheorem

-- | Compute Θ(a, b) for given a and b.
tauab :: Integer -> Integer -> (TauabTheorem, OptimizeResult)

-- | Special type to specify the theorem of Krätzel1988, which provided the
--   best estimate of Θ(a, b, c)
data TauabcTheorem

-- | Kolesnik (<i>Kolesnik G.</i> `On the estimation of multiple
--   exponential sums' // Recent progress in analytic number theory,
--   London: Academic Press, 1981, Vol. 1, P. 231–246) proved that Θ(1, 1,
--   1) = 43 /96.
Kolesnik :: TauabcTheorem

-- | Theorem 6.1
Kr61 :: TauabcTheorem

-- | Theorem 6.2
Kr62 :: TauabcTheorem

-- | Theorem 6.3
Kr63 :: TauabcTheorem

-- | Theorem 6.4
Kr64 :: TauabcTheorem

-- | Theorem 6.5
Kr65 :: TauabcTheorem

-- | Theorem 6.6
Kr66 :: TauabcTheorem

-- | In certain cases Θ(a, b, c) = Θ(a, b).
Tauab :: TauabTheorem -> TauabcTheorem

-- | Compute Θ(a, b, c) for given a, b and c.
tauabc :: Integer -> Integer -> Integer -> (TauabcTheorem, OptimizeResult)
instance Show TauabTheorem
instance Show TauabcTheorem


-- | Let τ_{a, b}(l_1, k_1; l_2, k_2; n) denote the number of integer (v,
--   w) with v^a w^b = n, v ≡ l_1 (mod k_1), w ≡ l_2 (mod k_2).
--   
--   Menzer and Nowak (<i>Menzer H., Nowak W. G.</i> `On an asymmetric
--   divisor problem with congruence conditions' // Manuscr. Math., 1989,
--   Vol. 64, no. 1, P. 107-119) proved an asymptotic formula for Σ_{n ≤ x}
--   τ_{a, b}(l_1, k_1; l_2, k_2; n) with an error term of order (x / k_1^a
--   / k_2^b)^(Θ(a, b) + ε). They provided an expression for Θ(a, b) in
--   terms of exponent pairs.
module Math.ExpPairs.MenzerNowak

-- | Compute Θ(a, b) for given a and b.
menzerNowak :: Integer -> Integer -> OptimizeResult
