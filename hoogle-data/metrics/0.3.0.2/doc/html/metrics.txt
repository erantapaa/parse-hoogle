-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | High-performance application metric tracking
--   
@package metrics
@version 0.3.0.2


-- | A pure moving average module. The interface is agnostic to the scale
--   of time that the average is tracking. It is up to the specific moving
--   average module to handle that functionality.
module Data.Metrics.MovingAverage

-- | This type encapsulates the interface of the different moving average
--   implementations in such a way that they can be reused without plumbing
--   the types through the other components that use moving averages. Most
--   people won't ever need to use record fields of this type.
data MovingAverage
MovingAverage :: !(s -> s) -> !(Double -> s -> s) -> !(s -> s) -> !(s -> Double) -> !s -> MovingAverage

-- | clear the internal state of the moving average
movingAverageClear :: MovingAverage -> !(s -> s)

-- | add a new sample to the moving average
movingAverageUpdate :: MovingAverage -> !(Double -> s -> s)

-- | perform any modifications of the internal state associated with the
--   passage of a predefined interval of time.
movingAverageTick :: MovingAverage -> !(s -> s)

-- | get the current rate of the moving average.
movingAverageRate :: MovingAverage -> !(s -> Double)

-- | the internal implementation state of the moving average
movingAverageState :: MovingAverage -> !s

-- | Reset a moving average back to a starting state.
clear :: MovingAverage -> MovingAverage

-- | Get the current rate of the moving average.
rate :: MovingAverage -> Double

-- | Update the average based upon an interval specified by the moving
--   average implementation.
tick :: MovingAverage -> MovingAverage

-- | Update the average with the specified value.
update :: Double -> MovingAverage -> MovingAverage

module Data.Metrics.Meter.Internal
data Meter
meterData :: (Int -> MovingAverage) -> NominalDiffTime -> Meter
mark :: NominalDiffTime -> Int -> Meter -> Meter
clear :: NominalDiffTime -> Meter -> Meter
tick :: Meter -> Meter
meanRate :: NominalDiffTime -> Meter -> Double
oneMinuteAverage :: Meter -> MovingAverage
fiveMinuteAverage :: Meter -> MovingAverage
fifteenMinuteAverage :: Meter -> MovingAverage
tickIfNecessary :: NominalDiffTime -> Meter -> Meter
count :: HasCount s a => Lens' s a
instance HasStartTime Meter NominalDiffTime
instance HasOneMinuteRate Meter MovingAverage
instance HasLastTick Meter NominalDiffTime
instance HasFiveMinuteRate Meter MovingAverage
instance HasFifteenMinuteRate Meter MovingAverage
instance HasCount Meter Int


module Data.Metrics.Snapshot

-- | A wrapper around a *sorted* vector intended for calculating quantile
--   statistics.
newtype Snapshot
Snapshot :: Vector Double -> Snapshot

-- | A sorted <a>Vector</a> of samples.
fromSnapshot :: Snapshot -> Vector Double

-- | Calculate an arbitrary quantile value for a <a>Snapshot</a>. Values
--   below zero or greater than one will be clamped to the range [0, 1]
quantile :: Double -> Snapshot -> Double

-- | Get the number of elements in a <a>Snapshot</a>
size :: Snapshot -> Int

-- | Calculate the median value of a <a>Snapshot</a>
median :: Snapshot -> Double

-- | Calculate the 75th percentile of a <a>Snapshot</a>
get75thPercentile :: Snapshot -> Double

-- | Calculate the 95th percentile of a <a>Snapshot</a>
get95thPercentile :: Snapshot -> Double

-- | Calculate the 98th percentile of a <a>Snapshot</a>
get98thPercentile :: Snapshot -> Double

-- | Calculate the 99th percentile of a <a>Snapshot</a>
get99thPercentile :: Snapshot -> Double

-- | Calculate the 99.9th percentile of a <a>Snapshot</a>
get999thPercentile :: Snapshot -> Double

-- | A utility function for snapshotting data from an unsorted
--   <a>MVector</a> of samples.
--   
--   NB: this function uses "unsafeFreeze" under the hood, so be sure that
--   the vector being snapshotted is not used after calling this function.
takeSnapshot :: PrimMonad m => MVector (PrimState m) Double -> m Snapshot
instance Show Snapshot


-- | A reservoir is the internal storage mechanism for a <a>Histogram</a>.
--   It provides a generic way to store histogram values in a way that
--   allows us to avoid the need to plumb the implementation type through
--   anything that uses a reservoir.
module Data.Metrics.Reservoir

-- | Encapsulates the internal state of a reservoir implementation.
--   
--   The two standard implementations are the
--   ExponentiallyDecayingReservoir and the UniformReservoir.
data Reservoir
Reservoir :: !(NominalDiffTime -> s -> s) -> !(s -> Int) -> !(s -> Snapshot) -> !(Double -> NominalDiffTime -> s -> s) -> !s -> Reservoir

-- | An operation that resets a reservoir to its initial state
reservoirClear :: Reservoir -> !(NominalDiffTime -> s -> s)

-- | Retrieve current size of the reservoir. This may or may not be
--   constant depending on the specific implementation.
reservoirSize :: Reservoir -> !(s -> Int)

-- | Take snapshot of the current reservoir.
--   
--   The number of items in the snapshot should always match the
--   reservoir's size.
reservoirSnapshot :: Reservoir -> !(s -> Snapshot)

-- | Add a new value to the reservoir, potentially evicting old values in
--   the prcoess.
reservoirUpdate :: Reservoir -> !(Double -> NominalDiffTime -> s -> s)

-- | The internal state of the reservoir.
reservoirState :: Reservoir -> !s

-- | Reset a reservoir to its initial state.
clear :: NominalDiffTime -> Reservoir -> Reservoir

-- | Get the current number of elements in the reservoir
size :: Reservoir -> Int

-- | Get a copy of all elements in the reservoir.
snapshot :: Reservoir -> Snapshot

-- | Update a reservoir with a new value.
--   
--   N.B. for some reservoir types, the latest value is not guaranteed to
--   be retained in the reservoir.
update :: Double -> NominalDiffTime -> Reservoir -> Reservoir


-- | The pure interface for histograms. This module is typically not as
--   useful as the stateful implementation since reservoir updates require
--   retrieving the current time.
module Data.Metrics.Histogram.Internal

-- | A pure histogram that maintains a bounded reservoir of samples and
--   basic statistical data about the samples.
data Histogram

-- | Create a histogram using a custom reservoir.
histogram :: Reservoir -> Histogram

-- | Reset all statistics, in addition to the underlying reservoir.
clear :: NominalDiffTime -> Histogram -> Histogram

-- | Update statistics and the reservoir with a new sample.
update :: Double -> NominalDiffTime -> Histogram -> Histogram

-- | Get the average of all samples since the histogram was created.
mean :: Histogram -> Double

-- | Get the standard deviation of all samples.
stddev :: Histogram -> Double

-- | Get the variance of all samples.
variance :: Histogram -> Double

-- | Get the minimum value of all samples.
minVal :: Histogram -> Double

-- | Get the maximum value of all samples
maxVal :: Histogram -> Double

-- | Get the number of samples that the histogram has been updated with.
count :: Histogram -> Int

-- | Get a snapshot of the current reservoir's samples.
snapshot :: Histogram -> Snapshot


-- | A timer is essentially just a data type that combines a <a>Meter</a>
--   and a <a>Histogram</a> to track both the rate at which events are
--   triggered as well as timing statistics about the calls.
--   
--   This module exports the pure internals, relying on the stateful
--   version to supply the pure timer with measurements.
module Data.Metrics.Timer.Internal
data Timer
Timer :: !Meter -> !Histogram -> Timer
timerMeter :: Timer -> !Meter
timerHistogram :: Timer -> !Histogram
class HasHistogram s a | s -> a
histogram :: HasHistogram s a => Lens' s a
class HasMeter s a | s -> a
meter :: HasMeter s a => Lens' s a
tickIfNecessary :: NominalDiffTime -> Timer -> Timer
snapshot :: Timer -> Snapshot
oneMinuteRate :: Timer -> Double
fiveMinuteRate :: Timer -> Double
fifteenMinuteRate :: Timer -> Double
meanRate :: NominalDiffTime -> Timer -> Double
count :: Timer -> Int
clear :: NominalDiffTime -> Timer -> Timer
update :: NominalDiffTime -> Double -> Timer -> Timer
mean :: Timer -> Double
stddev :: Timer -> Double
variance :: Timer -> Double
maxVal :: Timer -> Double
minVal :: Timer -> Double
instance HasMeter Timer Meter
instance HasHistogram Timer Histogram


-- | Internal helpers that provide strict atomic MutVar access.
--   
--   These functions allow us to avoid the overhead of MVar as long as we
--   can factor the impure sections of code out in such a way that the pure
--   metric calculations can be executed without requiring access to
--   multiple MutVars at a time.
module Data.Metrics.Internal

-- | Perform a strict update on a MutVar. Pretty much identical to the
--   strict variant of atomicModifyIORef.
updateRef :: PrimMonad m => MV m a -> (a -> a) -> m ()

-- | Strictly apply a function on a MutVar while blocking other access to
--   it.
--   
--   I really think this is probably not implemented correctly in terms of
--   being excessively strict.
applyWithRef :: PrimMonad m => MV m a -> (a -> b) -> m b

-- | A function which combines the previous two, updating a value
--   atomically and then returning some value calculated with the update in
--   a single step.
updateAndApplyToRef :: PrimMonad m => MV m a -> (a -> a) -> (a -> b) -> m b

-- | MutVar (PrimState m) is a little verbose.
type MV m = MutVar (PrimState m)


-- | A histogram with a uniform reservoir produces quantiles which are
--   valid for the entirely of the histogram’s lifetime. It will return a
--   median value, for example, which is the median of all the values the
--   histogram has ever been updated with. It does this by using an
--   algorithm called Vitter’s R), which randomly selects values for the
--   reservoir with linearly-decreasing probability.
--   
--   Use a uniform histogram when you’re interested in long-term
--   measurements. Don’t use one where you’d want to know if the
--   distribution of the underlying data stream has changed recently.
module Data.Metrics.Reservoir.Uniform

-- | A reservoir in which all samples are equally likely to be evicted when
--   the reservoir is at full capacity.
--   
--   This is conceptually simpler than the
--   <a>ExponentiallyDecayingReservoir</a>, but at the expense of providing
--   a less accurate sample.
data UniformReservoir

-- | Make a safe uniform reservoir. This variant provides safe access at
--   the expense of updates costing O(n)
reservoir :: Seed -> Int -> Reservoir

-- | Using this variant requires that you ensure that there is no sharing
--   of the reservoir itself.
--   
--   In other words, there must only be a single point of access (an IORef,
--   etc. that accepts some sort of modification function).
--   
--   In return, updating the reservoir becomes an O(1) operation and
--   clearing the reservoir avoids extra allocations.
unsafeReservoir :: Seed -> Int -> Reservoir

-- | Reset the reservoir to empty.
clear :: NominalDiffTime -> UniformReservoir -> UniformReservoir

-- | Reset the reservoir to empty by performing an in-place modification of
--   the reservoir.
unsafeClear :: NominalDiffTime -> UniformReservoir -> UniformReservoir

-- | Get the current size of the reservoir
size :: UniformReservoir -> Int

-- | Take a snapshot of the reservoir by doing an in-place unfreeze.
--   
--   This should be safe as long as unsafe operations are performed
--   appropriately.
snapshot :: UniformReservoir -> Snapshot

-- | Perform an update of the reservoir by copying the internal vector.
--   O(n)
update :: Double -> NominalDiffTime -> UniformReservoir -> UniformReservoir

-- | Perform an in-place update of the reservoir. O(1)
unsafeUpdate :: Double -> NominalDiffTime -> UniformReservoir -> UniformReservoir
instance HasSeed UniformReservoir Seed
instance HasInnerReservoir UniformReservoir (Vector Double)
instance HasCount UniformReservoir Int


-- | A histogram with an exponentially decaying reservoir produces
--   quantiles which are representative of (roughly) the last five minutes
--   of data. It does so by using a forward-decaying priority reservoir
--   with an exponential weighting towards newer data. Unlike the uniform
--   reservoir, an exponentially decaying reservoir represents recent data,
--   allowing you to know very quickly if the distribution of the data has
--   changed. Timers use histograms with exponentially decaying reservoirs
--   by default.
module Data.Metrics.Reservoir.ExponentiallyDecaying

-- | A forward-decaying priority reservoir
--   
--   <a>http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf</a>
data ExponentiallyDecayingReservoir

-- | An exponentially decaying reservoir with an alpha value of 0.015 and a
--   1028 sample cap.
--   
--   This offers a 99.9% confidence level with a 5% margin of error
--   assuming a normal distribution, and an alpha factor of 0.015, which
--   heavily biases the reservoir to the past 5 minutes of measurements.
standardReservoir :: NominalDiffTime -> Seed -> Reservoir

-- | Create a reservoir with a custom alpha factor and reservoir size.
reservoir :: Double -> Int -> NominalDiffTime -> Seed -> Reservoir

-- | Reset the reservoir
clear :: NominalDiffTime -> ExponentiallyDecayingReservoir -> ExponentiallyDecayingReservoir

-- | Get the current size of the reservoir.
size :: ExponentiallyDecayingReservoir -> Int

-- | Get a snapshot of the current reservoir
snapshot :: ExponentiallyDecayingReservoir -> Snapshot

-- | "A common feature of the above techniques—indeed, the key technique
--   that allows us to track the decayed weights efficiently – is that they
--   maintain counts and other quantities based on g(ti − L), and only
--   scale by g(t − L) at query time. But while g(ti −L)/g(t−L) is
--   guaranteed to lie between zero and one, the intermediate values of
--   g(ti − L) could become very large. For polynomial functions, these
--   values should not grow too large, and should be effectively
--   represented in practice by floating point values without loss of
--   precision. For exponential functions, these values could grow quite
--   large as new values of (ti − L) become large, and potentially exceed
--   the capacity of common floating point types. However, since the values
--   stored by the algorithms are linear combinations of g values (scaled
--   sums), they can be rescaled relative to a new landmark. That is, by
--   the analysis of exponential decay in Section III-A, the choice of L
--   does not affect the final result. We can therefore multiply each value
--   based on L by a factor of exp(−α(L′ − L)), and obtain the correct
--   value as if we had instead computed relative to a new landmark L′ (and
--   then use this new L′ at query time). This can be done with a linear
--   pass over whatever data structure is being used."
rescale :: Word64 -> ExponentiallyDecayingReservoir -> ExponentiallyDecayingReservoir

-- | Insert a new sample into the reservoir. This may cause old sample
--   values to be evicted based upon the probabilistic weighting given to
--   the key at insertion time.
update :: Double -> NominalDiffTime -> ExponentiallyDecayingReservoir -> ExponentiallyDecayingReservoir
instance HasStartTime ExponentiallyDecayingReservoir Word64
instance HasSeed ExponentiallyDecayingReservoir Seed
instance HasRescaleThreshold ExponentiallyDecayingReservoir Word64
instance HasNextScaleTime ExponentiallyDecayingReservoir Word64
instance HasInnerSize ExponentiallyDecayingReservoir Int
instance HasInnerReservoir ExponentiallyDecayingReservoir (Map Double Double)
instance HasCount ExponentiallyDecayingReservoir Int
instance HasAlpha ExponentiallyDecayingReservoir Double
instance Show ExponentiallyDecayingReservoir


-- | The main accessors for common stateful metric implementation data.
module Data.Metrics.Types

-- | Histogram moving averages are tracked (by default) on minute scale.
type Minutes = Int

-- | Get the current count for the given metric.
class Count m a | a -> m
count :: Count m a => a -> m Int

-- | Provides statistics from a histogram that tracks the standard moving
--   average rates.
class Rate m a | a -> m
oneMinuteRate :: Rate m a => a -> m Double
fiveMinuteRate :: Rate m a => a -> m Double
fifteenMinuteRate :: Rate m a => a -> m Double
meanRate :: Rate m a => a -> m Double

-- | Gets the current value from a simple metric (i.e. a <a>Counter</a> or
--   a <a>Gauge</a>)
class Value m a v | a -> m v
value :: Value m a v => a -> m v

-- | Update a metric by performing wholesale replacement of a value.
class Set m a v | a -> m v
set :: Set m a v => a -> v -> m ()

-- | Provides a way to reset metrics. This might be useful in a development
--   environment or to periodically get a clean state for long-running
--   processes.
class Clear m a | a -> m
clear :: Clear m a => a -> m ()

-- | Provides the main interface for retrieving statistics tabulated by a
--   histogram.
class Statistics m a | a -> m
maxVal :: Statistics m a => a -> m Double
minVal :: Statistics m a => a -> m Double
mean :: Statistics m a => a -> m Double
stddev :: Statistics m a => a -> m Double
variance :: Statistics m a => a -> m Double

-- | Update statistics tracked by a metric with a new sample.
class Update m a v | a -> m v
update :: Update m a v => a -> v -> m ()

-- | Take a snapshot (a sorted vector) of samples used for calculating
--   quantile data.
class TakeSnapshot m a | a -> m
snapshot :: TakeSnapshot m a => a -> m Snapshot


-- | An exponentially-weighted moving average.
--   
--   see <i>UNIX Load Average Part 1: How It Works</i>:
--   
--   <a>http://www.teamquest.com/pdfs/whitepaper/ldavg1.pdf</a>
--   
--   see <i>UNIX Load Average Part 2: Not Your Average Average</i>
--   
--   <a>http://www.teamquest.com/pdfs/whitepaper/ldavg2.pdf</a>
--   
--   see Wikipedia's article on exponential moving averages:
--   
--   
--   <a>http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average</a>
module Data.Metrics.MovingAverage.ExponentiallyWeighted

-- | The internal representation of the exponentially weighted moving
--   average.
--   
--   This type encapsulates the state needed for the exponentially weighted
--   <a>MovingAverage</a> implementation.
data ExponentiallyWeightedMovingAverage

-- | Create a new <a>MovingAverage</a> with 5 second tick intervals for a
--   one-minute window.
new1MinuteMovingAverage :: MovingAverage

-- | Create a new <a>MovingAverage</a> with 5 second tick intervals for a
--   five-minute window.
new5MinuteMovingAverage :: MovingAverage

-- | Create a new <a>MovingAverage</a> with 5 second tick intervals for a
--   fifteen-minute window.
new15MinuteMovingAverage :: MovingAverage

-- | Create a new <a>MovingAverage</a> with the given tick interval and
--   averaging window.
movingAverage :: Double -> Minutes -> MovingAverage

-- | Reset the moving average rate to zero.
clear :: ExponentiallyWeightedMovingAverage -> ExponentiallyWeightedMovingAverage

-- | Get the current rate of the <a>ExponentiallyWeightedMovingAverage</a>
--   for the given window.
rate :: ExponentiallyWeightedMovingAverage -> Double

-- | Create a new <a>ExpontiallyWeightedMovingAverage</a> with the given
--   tick interval and averaging window.
empty :: Double -> Minutes -> ExponentiallyWeightedMovingAverage

-- | Update the moving average based upon the given value
update :: Double -> ExponentiallyWeightedMovingAverage -> ExponentiallyWeightedMovingAverage

-- | Update the moving average as if the given interval between ticks has
--   passed.
tick :: ExponentiallyWeightedMovingAverage -> ExponentiallyWeightedMovingAverage
instance HasUncounted ExponentiallyWeightedMovingAverage Double
instance HasInterval ExponentiallyWeightedMovingAverage Double
instance HasInitialized ExponentiallyWeightedMovingAverage Bool
instance HasCurrentRate ExponentiallyWeightedMovingAverage Double
instance HasAlpha ExponentiallyWeightedMovingAverage Double
instance Show ExponentiallyWeightedMovingAverage


-- | A timer is basically a histogram of the duration of a type of event
--   and a meter of the rate of its occurrence.
module Data.Metrics.Timer

-- | A measure of time statistics for the duration of an event
data Timer m

-- | Create a timer using a custom function for retrieving the current
--   time.
--   
--   This is mostly exposed for testing purposes: prefer using "timer" if
--   possible.
mkTimer :: PrimMonad m => m NominalDiffTime -> Seed -> m (Timer m)

-- | Create a standard <a>Timer</a> with an exponentially weighted moving
--   average and an exponentially decaying histogram
timer :: IO (Timer IO)

-- | Execute an action and record statistics about the duration of the
--   event and the rate of event occurrence.
time :: Timer IO -> IO a -> IO a
instance PrimMonad m => TakeSnapshot m (Timer m)
instance PrimMonad m => Rate m (Timer m)
instance (Functor m, PrimMonad m) => Statistics m (Timer m)
instance PrimMonad m => Count m (Timer m)
instance PrimMonad m => Update m (Timer m) Double
instance PrimMonad m => Clear m (Timer m)
instance HasGetTime (Timer m0) (m0 NominalDiffTime)


-- | A meter measures the rate at which a set of events occur:
--   
--   Meters measure the rate of the events in a few different ways. The
--   mean rate is the average rate of events. It’s generally useful for
--   trivia, but as it represents the total rate for your application’s
--   entire lifetime (e.g., the total number of requests handled, divided
--   by the number of seconds the process has been running), it doesn’t
--   offer a sense of recency. Luckily, meters also record three different
--   exponentially-weighted moving average rates: the 1-, 5-, and 15-minute
--   moving averages.
--   
--   (Just like the Unix load averages visible in uptime or top.)
module Data.Metrics.Meter

-- | A measure of the <i>rate</i> at which a set of events occurs.
data Meter m

-- | Create a new meter using an exponentially weighted moving average
meter :: IO (Meter IO)

-- | Register a single occurrence of an event.
mark :: PrimMonad m => Meter m -> m ()

-- | Register multiple occurrences of an event.
mark' :: PrimMonad m => Meter m -> Int -> m ()
instance PrimMonad m => Count m (Meter m)
instance PrimMonad m => Rate m (Meter m)


-- | Histogram metrics allow you to measure not just easy things like the
--   min, mean, max, and standard deviation of values, but also quantiles
--   like the median or 95th percentile.
--   
--   Traditionally, the way the median (or any other quantile) is
--   calculated is to take the entire data set, sort it, and take the value
--   in the middle (or 1% from the end, for the 99th percentile). This
--   works for small data sets, or batch processing systems, but not for
--   high-throughput, low-latency services.
--   
--   The solution for this is to sample the data as it goes through. By
--   maintaining a small, manageable reservoir which is statistically
--   representative of the data stream as a whole, we can quickly and
--   easily calculate quantiles which are valid approximations of the
--   actual quantiles. This technique is called reservoir sampling.
module Data.Metrics.Histogram

-- | A measure of the distribution of values in a stream of data.
data Histogram m

-- | Create a histogram using a custom time data supplier function and a
--   custom reservoir.
histogram :: PrimMonad m => m NominalDiffTime -> Reservoir -> m (Histogram m)

-- | The recommended histogram type. It provides a fast histogram that
--   probabilistically evicts older entries using a weighting system. This
--   ensures that snapshots remain relatively fresh.
exponentiallyDecayingHistogram :: IO (Histogram IO)

-- | A histogram that gives all entries an equal likelihood of being
--   evicted.
--   
--   Probably not what you want for most time-series data.
uniformHistogram :: Seed -> IO (Histogram IO)
instance PrimMonad m => TakeSnapshot m (Histogram m)
instance PrimMonad m => Statistics m (Histogram m)
instance PrimMonad m => Count m (Histogram m)
instance PrimMonad m => Update m (Histogram m) Double
instance PrimMonad m => Clear m (Histogram m)


-- | A module representing a <a>Gauge</a>, which is simply an action that
--   returns the instantaneous measure of a value for charting.
--   
--   The action that provides the gauge's value may be replaced using
--   "set", or read using "value".
--   
--   <pre>
--   gaugeExample = do
--     g &lt;- gauge $ return 1
--     x &lt;- value g
--     set g $ return 2
--     y &lt;- value g
--     return (x == 1 &amp;&amp; y == 2)
--   </pre>
module Data.Metrics.Gauge

-- | An instantaneous measure of a value.
data Gauge m

-- | Create a new gauge from the given action.
gauge :: PrimMonad m => m Double -> m (Gauge m)

-- | Compose multiple actions to create a ratio. Useful for graphing
--   percentage information, e. g.
--   
--   <pre>
--   connectionUtilizationRate :: IO (Gauge IO)
--   connectionUtilizationRate = gauge $ ratio openConnectionCount $ return connectionPoolSize
--   </pre>
ratio :: Applicative f => f Double -> f Double -> f Double
instance PrimMonad m => Set m (Gauge m) (m Double)
instance PrimMonad m => Value m (Gauge m) Double


-- | An incrementing and decrementing counter metric
--   
--   <pre>
--   import Data.Metrics.Counter
--   
--   main :: IO ()
--   main = do
--     c &lt;- counter
--     increment c
--     x &lt;- value c
--     print $ x == 1
--   </pre>
module Data.Metrics.Counter

-- | A basic atomic counter.
data Counter m

-- | Create a new counter.
counter :: (Functor m, PrimMonad m) => m (Counter m)

-- | Bump up a counter by 1.
increment :: PrimMonad m => Counter m -> m ()

-- | Add an arbitrary amount to a counter.
increment' :: PrimMonad m => Counter m -> Int -> m ()

-- | Decrease the value of a counter by 1.
decrement :: PrimMonad m => Counter m -> m ()

-- | Subtract an arbitrary amount from a counter.
decrement' :: PrimMonad m => Counter m -> Int -> m ()
instance PrimMonad m => Clear m (Counter m)
instance PrimMonad m => Set m (Counter m) Int
instance PrimMonad m => Value m (Counter m) Int
instance PrimMonad m => Count m (Counter m)


-- | An interface for bundling metrics in a way that they cna be iterated
--   over for reporting or looked up for use by code that shares the
--   registry.
module Data.Metrics.Registry

-- | A container that tracks all metrics registered with it. All forms of
--   metrics share the same namespace in the registry. Consequently,
--   attempting to replace a metric with one of a different type will fail
--   (return Nothing from a call to <a>register</a>).
data MetricRegistry m

-- | A sum type of all supported metric types that reporters should be able
--   to output.
data Metric m
MetricGauge :: !(Gauge m) -> Metric m
MetricCounter :: !(Counter m) -> Metric m
MetricHistogram :: !(Histogram m) -> Metric m
MetricMeter :: !(Meter m) -> Metric m
MetricTimer :: !(Timer m) -> Metric m

-- | Add a new metric to a registry or retrieve the existing metric of the
--   same name if one exists.
class Register a
register :: Register a => MetricRegistry IO -> Text -> IO a -> IO (Maybe a)
metrics :: MetricRegistry m -> (MVar (HashMap Text (Metric m)))

-- | Initializes a new metric registry.
newMetricRegistry :: IO (MetricRegistry IO)
instance Register (Timer IO)
instance Register (Meter IO)
instance Register (Histogram IO)
instance Register (Gauge IO)
instance Register (Counter IO)


-- | A simple interface through which simple status dashboards can be
--   built.
--   
--   <pre>
--   import Data.HealthCheck
--   import Data.Metrics.Reporter.StdOut
--   
--   healthCheck1 :: HealthCheck
--   healthCheck1 = healthCheck "benign_warm_fuzzy_thing" $
--     return $ StatusReport Good Nothing
--   
--   healthCheck2 :: HealthCheck
--   healthCheck2 = healthCheck "nuclear_missile_launcher" $
--     return $ StatusReport Ugly $ Just "out of missiles"
--   
--   main :: IO ()
--   main = printHealthChecks [ healthCheck1, healthCheck2 ]
--   </pre>
module Data.HealthCheck

-- | A simple discrete health reporter
data HealthCheck
HealthCheck :: IO StatusReport -> Text -> HealthCheck

-- | An action which determines the current status of the health check
healthCheckStatusReport :: HealthCheck -> IO StatusReport

-- | A unique identifier for the health check
healthCheckName :: HealthCheck -> Text

-- | Clean up type signatures for bundling sets of health checks for
--   reporting
type HealthChecks = [HealthCheck]

-- | Create a health check.
healthCheck :: Text -> IO StatusReport -> HealthCheck

-- | Provides a simple status reporting mechanism for checking application
--   health at a glance.
data Status

-- | Everything appears to be going well.
Good :: Status

-- | Something is broken.
Bad :: Status

-- | There is some sort of non-critical issue that deserves attention.
Ugly :: Status

-- | There is no information, either good or bad, at the moment. An example
--   of this might be something like a loss of network connectivity to a
--   non-crucial service.
Unknown :: Status

-- | A report on the current status of a subsystem.
data StatusReport
StatusReport :: Status -> Maybe Text -> StatusReport

-- | Current status
status :: StatusReport -> Status

-- | An optional message to display about the current status.
statusMessage :: StatusReport -> Maybe Text
instance Read Status
instance Show Status
instance Eq Status
instance Ord Status
instance Show StatusReport


-- | A library for tracking arbitrary metrics over time. The library
--   largely provides pure and stateful versions of the same set of
--   functionality for common metric types.
module Data.Metrics


-- | Logging to stdout is primarily intended for development purposes or
--   creating command line status tools.
--   
--   For more meaningful access to statistics, metrics should be sent to
--   something like Librato or Graphite.
module Data.Metrics.Reporter.StdOut

-- | Pretty-print a single HealthCheck to the console using ANSI colors.
printHealthCheck :: HealthCheck -> IO ()

-- | Pretty-print a list of HealthChecks to the console using ANSI colors.
printHealthChecks :: HealthChecks -> IO ()
