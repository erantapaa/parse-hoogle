-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Purely functional stable heaps (fair priority queues)
--   
--   This library provides a purely functional implementation of stable
--   heaps (fair priority queues). The data structure is a cousin of the
--   pairing heap which maintains a sequential ordering of the keys.
--   Insertion can be to either end of the heap, as though it is a deque,
--   and it can be split on the left-most occurrence of the minimum key.
--   
--   The current state of the package is fairly barebones. It will be
--   fleshed out later.
@package stable-heap
@version 0.1.0.0


-- | This module provides an implementation of stable heaps, or fair
--   priority queues. The data structure is a fairly simple tweak to add
--   stability to the lazy pairing heaps described in <i>Purely Functional
--   Data Structures</i>, by Chris Okasaki.
--   
--   Unless stated otherwise, the documented asymptotic efficiencies of
--   functions on <a>Heap</a> assume that arguments are already in WHNF and
--   that the result is to be evaluated to WHNF.
module Data.Heap.Stable

-- | Semantically, <tt>Heap k a</tt> is equivalent to <tt>[(k, a)]</tt>,
--   but its operations have different efficiencies.
data Heap k a

-- | <pre>
--   toList empty = []
--   </pre>
empty :: Heap k a

-- | <i>O(1)</i>.
--   
--   <pre>
--   toList (singleton k v) = [(k, v)]
--   </pre>
singleton :: k -> a -> Heap k a

-- | <i>O(1)</i>.
--   
--   <pre>
--   toList (xs `union` ys) = toList xs ++ toList ys
--   </pre>
union :: Ord k => Heap k a -> Heap k a -> Heap k a

-- | Split the <a>Heap</a> at the leftmost occurrence of the smallest key
--   contained in the <a>Heap</a>.
--   
--   When the <a>Heap</a> is empty, <i>O(1)</i>. When the <a>Heap</a> is
--   not empty, finding the key and value is <i>O(1)</i>, and evaluating
--   the remainder of the heap to the left or right of the key-value pair
--   is amortized <i>O(log n)</i>.
--   
--   <pre>
--   toList xs =
--   case minViewWithKey xs of
--     Nothing -&gt; []
--     Just (l, kv, r) -&gt; toList l ++ [kv] ++ toList r
--   </pre>
minViewWithKey :: Ord k => Heap k a -> Maybe (Heap k a, (k, a), Heap k a)

-- | <i>O(1)</i>.
--   
--   <pre>
--   toList (cons k v xs) = (k, v) : toList xs
--   </pre>
cons :: Ord k => k -> a -> Heap k a -> Heap k a

-- | <i>O(1)</i>.
--   
--   <pre>
--   toList (snoc xs k v) = toList xs ++ [(k, v)]
--   </pre>
snoc :: Ord k => Heap k a -> k -> a -> Heap k a

-- | <pre>
--   foldrWithKey f z xs = foldr (uncurry f) z (toList xs)
--   </pre>
foldrWithKey :: (k -> a -> b -> b) -> b -> Heap k a -> b

-- | List the key-value pairs in a <a>Heap</a> in occurrence order. This is
--   the semantic function for <a>Heap</a>.
--   
--   <i>O(n)</i> when the spine of the result is evaluated fully.
toList :: Heap k a -> [(k, a)]

-- | List the key-value pairs in a <a>Heap</a> in key order.
--   
--   <i>O(n log n)</i> when the spine of the result is evaluated fully.
toListAsc :: Ord k => Heap k a -> [(k, a)]

-- | Construct a <a>Heap</a> from a list of key-value pairs.
--   
--   <i>O(n)</i>.
fromList :: Ord k => [(k, a)] -> Heap k a

-- | <pre>
--   toList (bimap f g xs) = map (f *** g) (toList xs)
--   </pre>
bimap :: Ord k2 => (k1 -> k2) -> (a -> b) -> Heap k1 a -> Heap k2 b

-- | <pre>
--   toList (mapKeys f xs) = map (first f) (toList xs)
--   </pre>
mapKeys :: Ord k2 => (k1 -> k2) -> Heap k1 a -> Heap k2 a
instance Traversable (Heap k)
instance Foldable (Heap k)
instance Functor (Heap k)
instance Ord k => Monoid (Heap k a)
instance (Monoid k, Ord k) => Applicative (Heap k)
instance (Monoid k, Ord k) => Monad (Heap k)
instance (Show k, Show a) => Show (Heap k a)
instance (Ord k, Read k, Read a) => Read (Heap k a)
instance Ord k => IsList (Heap k a)
instance (Eq k, Eq a) => Eq (Heap k a)
instance (Ord k, Ord a) => Ord (Heap k a)
instance (Monoid k, Ord k) => Alternative (Heap k)
instance (Monoid k, Ord k) => MonadPlus (Heap k)
