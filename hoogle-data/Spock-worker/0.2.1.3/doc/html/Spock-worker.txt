-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Background workers for Spock
--   
--   Adds a background-job queue to Spock
@package Spock-worker
@version 0.2.1.3

module Web.Spock.Worker.Internal.Queue
data PureQueue p v
PureQueue :: !(Map p (Vector v)) -> !Int -> PureQueue p v
pq_container :: PureQueue p v -> !(Map p (Vector v))
pq_maxSize :: PureQueue p v -> !Int
emptyPQ :: Int -> PureQueue p v
sizePQ :: PureQueue p v -> Int
isFullPQ :: PureQueue p v -> Bool
toListPQ :: Ord p => PureQueue p v -> [(p, [v])]
fromListPQ :: Ord p => Int -> [(p, [v])] -> Maybe (PureQueue p v)
maxPrioPQ :: Ord p => PureQueue p v -> p
enqueuePQ :: Ord p => p -> v -> PureQueue p v -> (Bool, PureQueue p v)
dequeuePQ :: Ord p => p -> PureQueue p v -> (Maybe v, PureQueue p v)
dequeuePQ' :: Ord p => p -> PureQueue p v -> (Maybe (p, v), PureQueue p v)
newtype WorkerQueue p v
WorkerQueue :: (TVar (PureQueue p v)) -> WorkerQueue p v
newQueue :: Int -> IO (WorkerQueue p v)
size :: WorkerQueue p v -> STM Int
isFull :: WorkerQueue p v -> STM Bool
enqueue :: Ord p => p -> v -> WorkerQueue p v -> STM ()
dequeue :: Ord p => p -> WorkerQueue p v -> STM (Maybe v)
instance (Show p, Show v) => Show (PureQueue p v)
instance (Eq p, Eq v) => Eq (PureQueue p v)

module Web.Spock.Worker

-- | The queue containing scheduled jobs
data WorkQueue a

-- | Describe how you want jobs in the queue to be performed
type WorkHandler conn sess st a = a -> ErrorT InternalError (WebStateM conn sess st) WorkResult

-- | Configure how the worker handles it's task and define the queue size
data WorkerConfig
WorkerConfig :: Int -> WorkerConcurrentStrategy -> WorkerConfig
wc_queueLimit :: WorkerConfig -> Int
wc_concurrent :: WorkerConfig -> WorkerConcurrentStrategy

-- | Configure the concurrent behaviour of a worker. If you want tasks
--   executed concurrently, consider using <a>WorkerConcurrentBounded</a>
data WorkerConcurrentStrategy
WorkerNoConcurrency :: WorkerConcurrentStrategy
WorkerConcurrentBounded :: Int -> WorkerConcurrentStrategy
WorkerConcurrentUnbounded :: WorkerConcurrentStrategy

-- | Create a new background worker and limit the size of the job queue.
newWorker :: (MonadTrans t, Monad (t (WebStateM conn sess st))) => WorkerConfig -> WorkHandler conn sess st a -> ErrorHandler conn sess st a -> t (WebStateM conn sess st) (WorkQueue a)

-- | Add a new job to the background worker. If the queue is full this will
--   block
addWork :: MonadIO m => WorkExecution -> a -> WorkQueue a -> m ()

-- | Describes when a job should be executed
data WorkExecution
WorkNow :: WorkExecution
WorkIn :: NominalDiffTime -> WorkExecution
WorkAt :: UTCTime -> WorkExecution

-- | Describes the outcome of a job after completion. You can repeat jobs
data WorkResult
WorkComplete :: WorkResult
WorkError :: WorkResult
WorkRepeatIn :: NominalDiffTime -> WorkResult
WorkRepeatAt :: UTCTime -> WorkResult

-- | Describe how you want to handle errors. Make sure you catch all
--   exceptions that can happen inside this handler, otherwise the worker
--   will crash!
data ErrorHandler conn sess st a
ErrorHandlerIO :: (InternalError -> a -> IO WorkResult) -> ErrorHandler conn sess st a
ErrorHandlerSpock :: (InternalError -> a -> (WebStateM conn sess st) WorkResult) -> ErrorHandler conn sess st a
type InternalError = String
instance Show WorkResult
instance Eq WorkResult
