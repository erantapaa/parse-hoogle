-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Strategy combinators for compositional data types
--   
@package compstrat
@version 0.1.0.2


-- | This module contains typeclasses and operations allowing dynamic
--   casing on sorts.
module Data.Comp.Multi.Strategy.Classification

-- | This operation allows you to rediscover the label giving the sort of a
--   term by inspecting the term. It is mainly used through the
--   <a>caseE</a> and <a>dynProj</a> operators
class DynCase f a
dyncase :: DynCase f a => f b -> Maybe (b :~: a)

-- | An instance <tt>KDynCase f a</tt> defines an instance <tt>DynCase
--   (Term f) a</tt>
class KDynCase f a
kdyncase :: (KDynCase f a, DynCase e a) => f e b -> Maybe (b :~: a)
dynProj :: DynCase f l => f l' -> Maybe (f l)

-- | Inspect an existentially-quantified sort
caseE :: DynCase f a => E f -> Maybe (f a)
instance [overlap ok] KDynCase f l => KDynCase (f :&: a) l
instance [overlap ok] (KDynCase f l, DynCase a l) => DynCase (Cxt h f a) l
instance [overlap ok] DynCase (K a) b
instance [overlap ok] (KDynCase f l, KDynCase g l) => KDynCase (f :+: g) l
instance [overlap ok] KDynCase f a

module Data.Comp.Multi.Strategy.Derive
makeDynCase :: Name -> Q [Dec]

module Data.Comp.Multi.Strategic
type RewriteM m f l = f l -> m (f l)
type Rewrite f l = RewriteM Identity f l
type GRewriteM m f = forall l. RewriteM m f l
type GRewrite f = GRewriteM Identity f

-- | Lifts a translation into the Maybe monad, allowing it to fail
addFail :: Monad m => TranslateM m f l t -> TranslateM (MaybeT m) f l t
tryR :: Monad m => RewriteM (MaybeT m) f l -> RewriteM m f l
promoteR :: (DynCase f l, Monad m) => RewriteM (MaybeT m) f l -> GRewriteM m f
promoteRF :: (DynCase f l, Monad m) => RewriteM (MaybeT m) f l -> GRewriteM (MaybeT m) f

-- | Applies a rewrite to all immediate subterms of the current term
allR :: (Monad m, HTraversable f) => GRewriteM m (Term f) -> RewriteM m (Term f) l

-- | Applies two rewrites in suceesion, succeeding if one or both succeed
(>+>) :: (Applicative m, MonadPlus m) => GRewriteM m f -> GRewriteM m f -> GRewriteM m f

-- | Left-biased choice -- (f +&gt; g) runs f, and, if it fails, then runs
--   g
(+>) :: MonadPlus m => RewriteM m f l -> RewriteM m f l -> RewriteM m f l

-- | Applies a rewrite to all immediate subterms of the current term,
--   succeeding if any succeed
anyR :: (Applicative m, MonadPlus m, HTraversable f) => GRewriteM m (Term f) -> RewriteM m (Term f) l

-- | Applies a rewrite to the first immediate subterm of the current term
--   where it can succeed
oneR :: (Applicative m, MonadPlus m, HTraversable f) => GRewriteM m (Term f) -> RewriteM m (Term f) l

-- | Runs a rewrite in a top-down traversal
alltdR :: (Monad m, HTraversable f) => GRewriteM m (Term f) -> GRewriteM m (Term f)

-- | Runs a rewrite in a bottom-up traversal
allbuR :: (Monad m, HTraversable f) => GRewriteM m (Term f) -> GRewriteM m (Term f)

-- | Runs a rewrite in a top-down traversal, succeeding if any succeed
anytdR :: (Applicative m, MonadPlus m, HTraversable f) => GRewriteM m (Term f) -> GRewriteM m (Term f)

-- | Runs a rewrite in a bottom-up traversal, succeeding if any succeed
anybuR :: (Applicative m, MonadPlus m, HTraversable f) => GRewriteM m (Term f) -> GRewriteM m (Term f)

-- | Runs a rewrite in a top-down traversal, succeeding if any succeed, and
--   pruning below successes
prunetdR :: (Applicative m, MonadPlus m, HTraversable f) => GRewriteM m (Term f) -> GRewriteM m (Term f)

-- | Applies a rewrite to the first node where it can succeed in a top-down
--   traversal
onetdR :: (Applicative m, MonadPlus m, HTraversable f) => GRewriteM m (Term f) -> GRewriteM m (Term f)

-- | Applies a rewrite to the first node where it can succeed in a
--   bottom-up traversal
onebuR :: (Applicative m, MonadPlus m, HTraversable f) => GRewriteM m (Term f) -> GRewriteM m (Term f)

-- | A single-sorted translation in the Identity monad
type Translate f l t = TranslateM Identity f l t

-- | A monadic translation for a single sort
type TranslateM m f l t = f l -> m t

-- | A monadic translation for all sorts
type GTranslateM m f t = forall l. TranslateM m f l t

-- | Allows a one-sorted translation to be applied to any sort, failing at
--   sorts different form the original
promoteTF :: (DynCase f l, MonadPlus m) => TranslateM m f l t -> GTranslateM m f t

-- | Runs a failable computation, replacing failure with mempty
mtryM :: (Monad m, Monoid a) => MaybeT m a -> m a

-- | Runs a translation in a top-down manner, combining its When run using
--   MaybeT, returns its result for the last node where it succeded
onetdT :: (MonadPlus m, HFoldable f) => GTranslateM m (Term f) t -> GTranslateM m (Term f) t

-- | Fold a tree in a top-down manner
foldtdT :: (HFoldable f, Monoid t, Monad m) => GTranslateM m (Term f) t -> GTranslateM m (Term f) t

-- | An always successful top-down fold, replacing failures with mempty.
crushtdT :: (HFoldable f, Monoid t, Monad m) => GTranslateM (MaybeT m) (Term f) t -> GTranslateM m (Term f) t
