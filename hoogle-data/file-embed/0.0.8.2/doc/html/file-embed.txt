-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Use Template Haskell to embed file contents directly.
--   
--   Use Template Haskell to read a file or all the files in a directory,
--   and turn them into (path, bytestring) pairs embedded in your haskell
--   code.
@package file-embed
@version 0.0.8.2


-- | This module uses template Haskell. Following is a simplified
--   explanation of usage for those unfamiliar with calling Template
--   Haskell functions.
--   
--   The function <tt>embedFile</tt> in this modules embeds a file into the
--   exceutable that you can use it at runtime. A file is represented as a
--   <tt>ByteString</tt>. However, as you can see below, the type signature
--   indicates a value of type <tt>Q Exp</tt> will be returned. In order to
--   convert this into a <tt>ByteString</tt>, you must use Template Haskell
--   syntax, e.g.:
--   
--   <pre>
--   $(embedFile "myfile.txt")
--   </pre>
--   
--   This expression will have type <tt>ByteString</tt>. Be certain to
--   enable the TemplateHaskell language extension, usually by adding the
--   following to the top of your module:
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   </pre>
module Data.FileEmbed

-- | Embed a single file in your source code.
--   
--   <pre>
--   import qualified Data.ByteString
--   
--   myFile :: Data.ByteString.ByteString
--   myFile = $(embedFile "dirName/fileName")
--   </pre>
embedFile :: FilePath -> Q Exp

-- | Embed a single existing file in your source code out of list a list of
--   paths supplied.
--   
--   <pre>
--   import qualified Data.ByteString
--   
--   myFile :: Data.ByteString.ByteString
--   myFile = $(embedFile' [ "dirName/fileName", "src/dirName/fileName" ])
--   </pre>
embedOneFileOf :: [FilePath] -> Q Exp

-- | Embed a directory recursively in your source code.
--   
--   <pre>
--   import qualified Data.ByteString
--   
--   myDir :: [(FilePath, Data.ByteString.ByteString)]
--   myDir = $(embedDir "dirName")
--   </pre>
embedDir :: FilePath -> Q Exp

-- | Get a directory tree in the IO monad.
--   
--   This is the workhorse of <a>embedDir</a>
getDir :: FilePath -> IO [(FilePath, ByteString)]

-- | Allocate the given number of bytes in the generate executable. That
--   space can be filled up with the <a>inject</a> and <a>injectFile</a>
--   functions.
dummySpace :: Int -> Q Exp

-- | Like <a>dummySpace</a>, but takes a postfix for the magic string. In
--   order for this to work, the same postfix must be used by <a>inject</a>
--   / <a>injectFile</a>. This allows an executable to have multiple
--   <tt>ByteString</tt>s injected into it, without encountering
--   collisions.
--   
--   Since 0.0.8
dummySpaceWith :: ByteString -> Int -> Q Exp

-- | Inject some raw data inside a <tt>ByteString</tt> containing empty,
--   dummy space (allocated with <tt>dummySpace</tt>). Typically, the
--   original <tt>ByteString</tt> is an executable read from the
--   filesystem.
inject :: ByteString -> ByteString -> Maybe ByteString

-- | Same as <a>inject</a>, but instead of performing the injecting in
--   memory, read the contents from the filesystem and write back to a
--   different file on the filesystem.
injectFile :: ByteString -> FilePath -> FilePath -> IO ()

-- | Like <a>inject</a>, but takes a postfix for the magic string.
--   
--   Since 0.0.8
injectWith :: ByteString -> ByteString -> ByteString -> Maybe ByteString

-- | Like <a>injectFile</a>, but takes a postfix for the magic string.
--   
--   Since 0.0.8
injectFileWith :: ByteString -> ByteString -> FilePath -> FilePath -> IO ()
stringToBs :: String -> ByteString
bsToExp :: ByteString -> Q Exp
