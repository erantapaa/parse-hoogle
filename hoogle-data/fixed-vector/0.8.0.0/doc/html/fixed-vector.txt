-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic vectors with statically known size.
--   
@package fixed-vector
@version 0.8.0.0


-- | API for Church-encoded vectors. Implementation of function from
--   <a>Data.Vector.Fixed</a> module uses these function internally in
--   order to provide shortcut fusion.
module Data.Vector.Fixed.Cont

-- | Successor of n
data S n

-- | Type level zero
data Z

-- | Type family for sum of unary natural numbers.

-- | Isomorphism between two representations of natural numbers
class (ToNat a ~ b, ToPeano b ~ a) => NatIso (a :: *) (b :: Nat)

-- | Convert Nat number to Peano represenation

-- | Convert Peano number to Nat
type N1 = S Z
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5

-- | Type family for n-ary functions.

-- | Newtype wrapper which is used to make <a>Fn</a> injective. It's also a
--   reader monad.
newtype Fun n a b
Fun :: Fn n a b -> Fun n a b
unFun :: Fun n a b -> Fn n a b

-- | Type class for handling <i>n</i>-ary functions.
class Arity n
accum :: Arity n => (forall k. t (S k) -> a -> t k) -> (t Z -> b) -> t n -> Fn n a b
applyFun :: Arity n => (forall k. t (S k) -> (a, t k)) -> t n -> Fn n a b -> (b, t Z)
applyFunM :: (Arity n, Monad m) => (forall k. t (S k) -> m (a, t k)) -> t n -> m (ContVec n a, t Z)
arity :: Arity n => n -> Int
reverseF :: Arity n => Fun n a b -> Fun n a b
gunfoldF :: (Arity n, Data a) => (forall b x. Data b => c (b -> x) -> c x) -> T_gunfold c r a n -> c r
witSum :: Arity n => WitSum n k a b

-- | Apply all parameters to the function.
apply :: Arity n => (forall k. t (S k) -> (a, t k)) -> t n -> Fn n a b -> b

-- | Apply all parameters to the function using monadic actions.
applyM :: (Monad m, Arity n) => (forall k. t (S k) -> m (a, t k)) -> t n -> m (ContVec n a)

-- | Value that carry proof that `Fn (Add n k) a b ~ Fn n a (Fn k a b)`
data WitSum n k a b
WitSum :: WitSum n k a b

-- | Prepend ignored parameter to function
constFun :: Fun n a b -> Fun (S n) a b

-- | Curry first parameter of n-ary function
curryFirst :: Fun (S n) a b -> a -> Fun n a b

-- | Uncurry first parameter of n-ary function
uncurryFirst :: (a -> Fun n a b) -> Fun (S n) a b

-- | Curry last parameter of n-ary function
curryLast :: Arity n => Fun (S n) a b -> Fun n a (a -> b)

-- | Curry <i>n</i> first parameters of n-ary function
curryMany :: Arity n => Fun (Add n k) a b -> Fun n a (Fun k a b)

-- | Uncurry <i>n</i> first parameters of n-ary function
uncurryMany :: Arity n => Fun n a (Fun k a b) -> Fun (Add n k) a b

-- | Apply last parameter to function. Unlike <tt>apFun</tt> we need to
--   traverse all parameters but last hence <a>Arity</a> constraint.
apLast :: Arity n => Fun (S n) a b -> a -> Fun n a b

-- | Move function parameter to the result of N-ary function.
shuffleFun :: Arity n => (b -> Fun n a r) -> Fun n a (b -> r)

-- | Recursive step for the function
withFun :: (Fun n a b -> Fun n a b) -> Fun (S n) a b -> Fun (S n) a b

-- | Size of vector expressed as type-level natural.

-- | Type class for vectors with fixed length. Instance should provide two
--   functions: one to create vector and another for vector deconstruction.
--   They must obey following law:
--   
--   <pre>
--   inspect v construct = v
--   </pre>
class Arity (Dim v) => Vector v a where basicIndex v i = index i (cvec v)
construct :: Vector v a => Fun (Dim v) a (v a)
inspect :: Vector v a => v a -> Fun (Dim v) a b -> b
basicIndex :: Vector v a => v a -> Int -> a

-- | Vector parametrized by length. In ideal world it should be:
--   
--   <pre>
--   forall n. (Arity n, Vector (v n) a, Dim (v n) ~ n) =&gt; VectorN v a
--   </pre>
--   
--   Alas polymorphic constraints aren't allowed in haskell.
class (Vector (v n) a, Dim (v n) ~ n) => VectorN v n a

-- | Length of vector. Function doesn't evaluate its argument.
length :: Arity (Dim v) => v a -> Int

-- | Type class for indexing of vector when index value is known at compile
--   time.
class Index k n
getF :: Index k n => k -> Fun n a a
putF :: Index k n => k -> a -> Fun n a r -> Fun n a r
lensF :: (Index k n, Functor f) => k -> (a -> f a) -> Fun n a r -> Fun n a (f r)

-- | Vector represented as continuation. Alternative wording: it's Church
--   encoded N-element vector.
newtype ContVec n a
ContVec :: (forall r. Fun n a r -> r) -> ContVec n a

-- | Convert regular vector to continuation based one.
cvec :: (Vector v a, Dim v ~ n) => v a -> ContVec n a

-- | Convert list to continuation-based vector. Will throw error if list is
--   shorter than resulting vector.
fromList :: Arity n => [a] -> ContVec n a

-- | Same as <a>fromList</a> bu throws error is list doesn't have same
--   length as vector.
fromList' :: Arity n => [a] -> ContVec n a

-- | Convert list to continuation-based vector. Will fail with
--   <a>Nothing</a> if list doesn't have right length.
fromListM :: Arity n => [a] -> Maybe (ContVec n a)

-- | Convert vector to the list
toList :: Arity n => ContVec n a -> [a]

-- | Execute monadic action for every element of vector. Synonym for
--   <a>pure</a>.
replicate :: Arity n => a -> ContVec n a

-- | Execute monadic action for every element of vector.
replicateM :: (Arity n, Monad m) => m a -> m (ContVec n a)

-- | Generate vector from function which maps element's index to its value.
generate :: Arity n => (Int -> a) -> ContVec n a

-- | Generate vector from monadic function which maps element's index to
--   its value.
generateM :: (Monad m, Arity n) => (Int -> m a) -> m (ContVec n a)

-- | Unfold vector.
unfoldr :: Arity n => (b -> (a, b)) -> b -> ContVec n a

-- | Unit vector along Nth axis.
basis :: (Num a, Arity n) => Int -> ContVec n a

-- | Create empty vector.
empty :: ContVec Z a

-- | <i>O(1)</i> Prepend element to vector
cons :: a -> ContVec n a -> ContVec (S n) a

-- | Prepend single element vector to another vector.
consV :: ContVec (S Z) a -> ContVec n a -> ContVec (S n) a

-- | <i>O(1)</i> Append element to vector
snoc :: Arity n => a -> ContVec n a -> ContVec (S n) a

-- | Concatenate vector
concat :: (Arity n, Arity k, Arity (Add n k)) => ContVec n a -> ContVec k a -> ContVec (Add n k) a
mk1 :: a -> ContVec N1 a
mk2 :: a -> a -> ContVec N2 a
mk3 :: a -> a -> a -> ContVec N3 a
mk4 :: a -> a -> a -> a -> ContVec N4 a
mk5 :: a -> a -> a -> a -> a -> ContVec N5 a

-- | Map over vector. Synonym for <a>fmap</a>
map :: Arity n => (a -> b) -> ContVec n a -> ContVec n b

-- | Apply function to every element of the vector and its index.
imap :: Arity n => (Int -> a -> b) -> ContVec n a -> ContVec n b

-- | Monadic map over vector.
mapM :: (Arity n, Monad m) => (a -> m b) -> ContVec n a -> m (ContVec n b)

-- | Apply monadic function to every element of the vector and its index.
imapM :: (Arity n, Monad m) => (Int -> a -> m b) -> ContVec n a -> m (ContVec n b)

-- | Apply monadic action to each element of vector and ignore result.
mapM_ :: (Arity n, Monad m) => (a -> m b) -> ContVec n a -> m ()

-- | Apply monadic action to each element of vector and its index and
--   ignore result.
imapM_ :: (Arity n, Monad m) => (Int -> a -> m b) -> ContVec n a -> m ()

-- | Left scan over vector
scanl :: Arity n => (b -> a -> b) -> b -> ContVec n a -> ContVec (S n) b

-- | Left scan over vector
scanl1 :: Arity n => (a -> a -> a) -> ContVec n a -> ContVec n a

-- | Evaluate every action in the vector from left to right.
sequence :: (Arity n, Monad m) => ContVec n (m a) -> m (ContVec n a)

-- | Evaluate every action in the vector from left to right and ignore
--   result.
sequence_ :: (Arity n, Monad m) => ContVec n (m a) -> m ()

-- | The dual of sequenceA
distribute :: (Functor f, Arity n) => f (ContVec n a) -> ContVec n (f a)
collect :: (Functor f, Arity n) => (a -> ContVec n b) -> f a -> ContVec n (f b)

-- | The dual of sequence
distributeM :: (Monad m, Arity n) => m (ContVec n a) -> ContVec n (m a)
collectM :: (Monad m, Arity n) => (a -> ContVec n b) -> m a -> ContVec n (m b)

-- | <i>O(1)</i> Tail of vector.
tail :: ContVec (S n) a -> ContVec n a

-- | Reverse order of elements in the vector
reverse :: Arity n => ContVec n a -> ContVec n a

-- | Zip two vector together using function.
zipWith :: Arity n => (a -> b -> c) -> ContVec n a -> ContVec n b -> ContVec n c

-- | Zip three vectors together
zipWith3 :: Arity n => (a -> b -> c -> d) -> ContVec n a -> ContVec n b -> ContVec n c -> ContVec n d

-- | Zip two vector together using function which takes element index as
--   well.
izipWith :: Arity n => (Int -> a -> b -> c) -> ContVec n a -> ContVec n b -> ContVec n c

-- | Zip three vectors together
izipWith3 :: Arity n => (Int -> a -> b -> c -> d) -> ContVec n a -> ContVec n b -> ContVec n c -> ContVec n d

-- | Zip two vector together using monadic function.
zipWithM :: (Arity n, Monad m) => (a -> b -> m c) -> ContVec n a -> ContVec n b -> m (ContVec n c)
zipWithM_ :: (Arity n, Monad m) => (a -> b -> m c) -> ContVec n a -> ContVec n b -> m ()

-- | Zip two vector together using monadic function which takes element
--   index as well..
izipWithM :: (Arity n, Monad m) => (Int -> a -> b -> m c) -> ContVec n a -> ContVec n b -> m (ContVec n c)
izipWithM_ :: (Arity n, Monad m) => (Int -> a -> b -> m c) -> ContVec n a -> ContVec n b -> m ()

-- | Run continuation vector. It's same as <a>inspect</a> but with
--   arguments flipped.
runContVec :: Fun n a r -> ContVec n a -> r

-- | Finalizer function for getting head of the vector.
head :: Arity (S n) => ContVec (S n) a -> a

-- | <i>O(n)</i> Get value at specified index.
index :: Arity n => Int -> ContVec n a -> a

-- | Twan van Laarhoven lens for continuation based vector
element :: (Arity n, Functor f) => Int -> (a -> f a) -> ContVec n a -> f (ContVec n a)

-- | Twan van Laarhoven's lens for element of vector with statically known
--   index.
elementTy :: (Arity n, Index k n, Functor f) => k -> (a -> f a) -> ContVec n a -> f (ContVec n a)

-- | Convert continuation to the vector.
vector :: (Vector v a, Dim v ~ n) => ContVec n a -> v a

-- | Left fold over continuation vector.
foldl :: Arity n => (b -> a -> b) -> b -> ContVec n a -> b

-- | Left fold.
foldl1 :: Arity (S n) => (a -> a -> a) -> ContVec (S n) a -> a

-- | Right fold over continuation vector
foldr :: Arity n => (a -> b -> b) -> b -> ContVec n a -> b

-- | Left fold over continuation vector.
ifoldl :: Arity n => (b -> Int -> a -> b) -> b -> ContVec n a -> b

-- | Right fold over continuation vector
ifoldr :: Arity n => (Int -> a -> b -> b) -> b -> ContVec n a -> b

-- | Monadic left fold over continuation vector.
foldM :: (Arity n, Monad m) => (b -> a -> m b) -> b -> ContVec n a -> m b

-- | Monadic left fold over continuation vector.
ifoldM :: (Arity n, Monad m) => (b -> Int -> a -> m b) -> b -> ContVec n a -> m b

-- | Sum all elements in the vector.
sum :: (Num a, Arity n) => ContVec n a -> a

-- | Minimal element of vector.
minimum :: (Ord a, Arity (S n)) => ContVec (S n) a -> a

-- | Maximal element of vector.
maximum :: (Ord a, Arity (S n)) => ContVec (S n) a -> a

-- | Conjunction of elements of a vector.
and :: Arity n => ContVec n Bool -> Bool

-- | Disjunction of all elements of a vector.
or :: Arity n => ContVec n Bool -> Bool

-- | Determines whether all elements of vector satisfy predicate.
all :: Arity n => (a -> Bool) -> ContVec n a -> Bool

-- | Determines whether any of element of vector satisfy predicate.
any :: Arity n => (a -> Bool) -> ContVec n a -> Bool

-- | Generic <a>gfoldl</a> which could work with any vector.
gfoldl :: (Vector v a, Data a) => (forall x y. Data x => c (x -> y) -> x -> c y) -> (forall x. x -> c x) -> v a -> c (v a)

-- | Generic <a>gunfoldl</a> which could work with any vector. Since vector
--   can only have one constructor argument for constructor is ignored.
gunfold :: (Vector v a, Data a) => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> con -> c (v a)
instance Typeable Z
instance Typeable S
instance Vector Proxy a
instance (b ~ a, c ~ a, d ~ a, e ~ a, f ~ a, g ~ a) => Vector ((,,,,,,) b c d e f g) a
instance (b ~ a, c ~ a, d ~ a, e ~ a, f ~ a) => Vector ((,,,,,) b c d e f) a
instance (b ~ a, c ~ a, d ~ a, e ~ a) => Vector ((,,,,) b c d e) a
instance (b ~ a, c ~ a, d ~ a) => Vector ((,,,) b c d) a
instance (b ~ a, c ~ a) => Vector ((,,) b c) a
instance b ~ a => Vector ((,) b) a
instance RealFloat a => Vector Complex a
instance Arity n => Traversable (ContVec n)
instance Arity n => Foldable (ContVec n)
instance Arity n => Applicative (ContVec n)
instance Arity n => Functor (ContVec n)
instance Arity n => VectorN ContVec n a
instance Arity n => Vector (ContVec n) a
instance Index k n => Index (S k) (S n)
instance Arity n => Index Z (S n)
instance Arity n => Arity (S n)
instance Arity Z
instance Arity n => Monad (Fun n a)
instance Arity n => Applicative (Fun n a)
instance Arity n => Functor (Fun n a)
instance (NatIso k (n - 1), ToPeano (n - 1) ~ k, ToPeano n ~ S k, n ~ (1 + (n - 1))) => NatIso (S k) n
instance NatIso Z 0


-- | More generic version of function from <a>Data.Vector.Fixed</a> module.
--   They do not require that all vector have same type, only same length.
--   All such functions have suffix <i>G</i>.
module Data.Vector.Fixed.Generic

-- | Map over vector
mapG :: (Vector v a, Vector w b, Dim v ~ Dim w) => (a -> b) -> v a -> w b

-- | Apply function to every element of the vector and its index.
imapG :: (Vector v a, Vector w b, Dim v ~ Dim w) => (Int -> a -> b) -> v a -> w b

-- | Monadic map over vector.
mapMG :: (Vector v a, Vector w b, Dim w ~ Dim v, Monad m) => (a -> m b) -> v a -> m (w b)

-- | Monadic map over vector.
imapMG :: (Vector v a, Vector w b, Dim w ~ Dim v, Monad m) => (Int -> a -> m b) -> v a -> m (w b)

-- | Zip two vector together using function.
zipWithG :: (Vector v a, Vector w b, Vector u c, Dim v ~ Dim u, Dim v ~ Dim w) => (a -> b -> c) -> v a -> w b -> u c

-- | Zip two vector together using function which takes element index as
--   well.
izipWithG :: (Vector v a, Vector w b, Vector u c, Dim v ~ Dim u, Dim v ~ Dim w) => (Int -> a -> b -> c) -> v a -> w b -> u c

-- | Zip two vector together using monadic function.
zipWithMG :: (Vector v a, Vector w b, Vector u c, Dim v ~ Dim u, Dim v ~ Dim w, Monad m) => (a -> b -> m c) -> v a -> w b -> m (u c)

-- | Zip two vector together using monadic function which takes element
--   index as well..
izipWithMG :: (Vector v a, Vector w b, Vector u c, Dim v ~ Dim u, Dim v ~ Dim w, Monad m) => (Int -> a -> b -> m c) -> v a -> w b -> m (u c)


-- | Type classes for vectors which are implemented on top of the arrays
--   and support in-place mutation. API is similar to one used in the
--   <tt>vector</tt> package.
module Data.Vector.Fixed.Mutable

-- | Type class for handling <i>n</i>-ary functions.
class Arity n
arity :: Arity n => n -> Int

-- | Mutable counterpart of fixed-length vector.

-- | Dimension for mutable vector.

-- | Type class for mutable vectors.
class Arity (DimM v) => MVector v a
overlaps :: MVector v a => v s a -> v s a -> Bool
copy :: (MVector v a, PrimMonad m) => v (PrimState m) a -> v (PrimState m) a -> m ()
move :: (MVector v a, PrimMonad m) => v (PrimState m) a -> v (PrimState m) a -> m ()
new :: (MVector v a, PrimMonad m) => m (v (PrimState m) a)
unsafeRead :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> m a
unsafeWrite :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> a -> m ()

-- | Length of mutable vector. Function doesn't evaluate its argument.
lengthM :: Arity (DimM v) => v s a -> Int

-- | Read value at index with bound checks.
read :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m a

-- | Write value at index with bound checks.
write :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m ()

-- | Create copy of vector.
clone :: (PrimMonad m, MVector v a) => v (PrimState m) a -> m (v (PrimState m) a)

-- | Type class for immutable vectors
class (Dim v ~ DimM (Mutable v), MVector (Mutable v) a) => IVector v a
unsafeFreeze :: (IVector v a, PrimMonad m) => Mutable v (PrimState m) a -> m (v a)
unsafeThaw :: (IVector v a, PrimMonad m) => v a -> m (Mutable v (PrimState m) a)
unsafeIndex :: IVector v a => v a -> Int -> a
index :: IVector v a => v a -> Int -> a

-- | Length of immutable vector. Function doesn't evaluate its argument.
lengthI :: IVector v a => v a -> Int

-- | Safely convert mutable vector to immutable.
freeze :: (PrimMonad m, IVector v a) => Mutable v (PrimState m) a -> m (v a)

-- | Safely convert immutable vector to mutable.
thaw :: (PrimMonad m, IVector v a) => v a -> m (Mutable v (PrimState m) a)

-- | Generic construct implementation for array-based vectors.
constructVec :: (Arity (Dim v), IVector v a) => Fun (Dim v) a (v a)

-- | Generic inspect implementation for array-based vectors.
inspectVec :: (Arity (Dim v), IVector v a) => v a -> Fun (Dim v) a b -> b


-- | Generic API for vectors with fixed length.
--   
--   For encoding of vector size library uses Peano naturals defined in the
--   library. At come point in the future it would make sense to switch to
--   new GHC type level numerals.
--   
--   <ul>
--   <li><i><tt>Common pitfalls</tt></i></li>
--   </ul>
--   
--   Library provide instances for tuples. But there's a catch. Tuples are
--   monomorphic in element type. Let consider 2-tuple <tt>(Int,Int)</tt>.
--   Vector type <tt>v</tt> is <tt>(,) Int</tt> and only allowed element
--   type is <tt>Int</tt>. Because of that we cannot change element type
--   and following code will fail:
--   
--   <pre>
--   &gt;&gt;&gt; map (== 1) ((1,2) :: (Int,Int))
--   
--   &lt;interactive&gt;:3:1:
--       Couldn't match type `Int' with `Bool'
--       In the expression: F.map (== 1) ((1, 2) :: (Int, Int))
--       In an equation for `it': it = map (== 1) ((1, 2) :: (Int, Int))
--   </pre>
--   
--   To make it work we need to change vector type as well. Functions from
--   module <a>Data.Vector.Fixed.Generic</a> provide this functionality.
--   
--   <pre>
--   &gt;&gt;&gt; map (== 1) ((1,2) :: (Int,Int)) :: (Bool,Bool)
--   (True,False)
--   </pre>
module Data.Vector.Fixed

-- | Size of vector expressed as type-level natural.

-- | Type level zero
data Z

-- | Successor of n
data S n
type N1 = S Z
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5

-- | Type class for vectors with fixed length. Instance should provide two
--   functions: one to create vector and another for vector deconstruction.
--   They must obey following law:
--   
--   <pre>
--   inspect v construct = v
--   </pre>
class Arity (Dim v) => Vector v a where basicIndex v i = index i (cvec v)
construct :: Vector v a => Fun (Dim v) a (v a)
inspect :: Vector v a => v a -> Fun (Dim v) a b -> b
basicIndex :: Vector v a => v a -> Int -> a

-- | Vector parametrized by length. In ideal world it should be:
--   
--   <pre>
--   forall n. (Arity n, Vector (v n) a, Dim (v n) ~ n) =&gt; VectorN v a
--   </pre>
--   
--   Alas polymorphic constraints aren't allowed in haskell.
class (Vector (v n) a, Dim (v n) ~ n) => VectorN v n a

-- | Type class for handling <i>n</i>-ary functions.
class Arity n

-- | Newtype wrapper which is used to make <a>Fn</a> injective. It's also a
--   reader monad.
newtype Fun n a b
Fun :: Fn n a b -> Fun n a b
unFun :: Fun n a b -> Fn n a b

-- | Length of vector. Function doesn't evaluate its argument.
length :: Arity (Dim v) => v a -> Int
mk0 :: (Vector v a, Dim v ~ Z) => v a
mk1 :: (Vector v a, Dim v ~ N1) => a -> v a
mk2 :: (Vector v a, Dim v ~ N2) => a -> a -> v a
mk3 :: (Vector v a, Dim v ~ N3) => a -> a -> a -> v a
mk4 :: (Vector v a, Dim v ~ N4) => a -> a -> a -> a -> v a
mk5 :: (Vector v a, Dim v ~ N5) => a -> a -> a -> a -> a -> v a

-- | Vector represented as continuation. Alternative wording: it's Church
--   encoded N-element vector.
data ContVec n a

-- | Create empty vector.
empty :: ContVec Z a

-- | Convert continuation to the vector.
vector :: (Vector v a, Dim v ~ n) => ContVec n a -> v a

-- | Cons value to continuation based vector.
(<|) :: a -> ContVec n a -> ContVec (S n) a

-- | Type class for variadic vector constructors.
class Make n a r

-- | Variadic vector constructor. Resulting vector should be converted from
--   <a>ContVec</a> using <a>vector</a> function. For example:
--   
--   <pre>
--   &gt;&gt;&gt; vector $ mkN 'a' 'b' 'c' :: (Char,Char,Char)
--   ('a','b','c')
--   </pre>
mkN :: Make (S Z) a r => a -> r

-- | Replicate value <i>n</i> times.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec2)
--   
--   &gt;&gt;&gt; replicate 1 :: Vec2 Int
--   fromList [1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 2 :: (Double,Double,Double)
--   (2.0,2.0,2.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec4)
--   
--   &gt;&gt;&gt; replicate "foo" :: Vec4 String
--   fromList ["foo","foo","foo","foo"]
--   </pre>
replicate :: Vector v a => a -> v a

-- | Execute monadic action for every element of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec2,Vec3)
--   
--   &gt;&gt;&gt; replicateM (Just 3) :: Maybe (Vec3 Int)
--   Just fromList [3,3,3]
--   
--   &gt;&gt;&gt; replicateM (putStrLn "Hi!") :: IO (Vec2 ())
--   Hi!
--   Hi!
--   fromList [(),()]
--   </pre>
replicateM :: (Vector v a, Monad m) => m a -> m (v a)

-- | Generate vector from function which maps element's index to its value.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Unboxed (Vec4)
--   
--   &gt;&gt;&gt; generate (^2) :: Vec4 Int
--   fromList [0,1,4,9]
--   </pre>
generate :: Vector v a => (Int -> a) -> v a

-- | Generate vector from monadic function which maps element's index to
--   its value.
generateM :: (Monad m, Vector v a) => (Int -> m a) -> m (v a)

-- | Unfold vector.
unfoldr :: Vector v a => (b -> (a, b)) -> b -> v a

-- | Unit vector along Nth axis. If index is larger than vector dimensions
--   returns zero vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; basis 0 :: Vec3 Int
--   fromList [1,0,0]
--   
--   &gt;&gt;&gt; basis 1 :: Vec3 Int
--   fromList [0,1,0]
--   
--   &gt;&gt;&gt; basis 3 :: Vec3 Int
--   fromList [0,0,0]
--   </pre>
basis :: (Vector v a, Num a) => Int -> v a

-- | First element of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; let x = mk3 1 2 3 :: Vec3 Int
--   
--   &gt;&gt;&gt; head x
--   1
--   </pre>
head :: (Vector v a, Dim v ~ S n) => v a -> a

-- | Tail of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; tail (1,2,3) :: Complex Double
--   2.0 :+ 3.0
--   </pre>
tail :: (Vector v a, Vector w a, Dim v ~ S (Dim w)) => v a -> w a

-- | Cons element to the vector
cons :: (Vector v a, Vector w a, S (Dim v) ~ Dim w) => a -> v a -> w a

-- | Append element to the vector
snoc :: (Vector v a, Vector w a, S (Dim v) ~ Dim w) => a -> v a -> w a
concat :: (Vector v a, Vector u a, Vector w a, (Add (Dim v) (Dim u)) ~ Dim w) => v a -> u a -> w a

-- | Reverse order of elements in the vector
reverse :: Vector v a => v a -> v a

-- | Type class for indexing of vector when index value is known at compile
--   time.
class Index k n

-- | Retrieve vector's element at index. Generic implementation is
--   <i>O(n)</i> but more efficient one is used when possible.
(!) :: Vector v a => v a -> Int -> a

-- | Get element from vector at statically known index
index :: (Vector v a, Index k (Dim v)) => v a -> k -> a

-- | Set n'th element in the vector
set :: (Vector v a, Index k (Dim v)) => k -> a -> v a -> v a

-- | Twan van Laarhoven's lens for element of vector
element :: (Vector v a, Functor f) => Int -> (a -> f a) -> (v a -> f (v a))

-- | Twan van Laarhoven's lens for element of vector with statically known
--   index.
elementTy :: (Vector v a, Index k (Dim v), Functor f) => k -> (a -> f a) -> (v a -> f (v a))

-- | Test two vectors for equality.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec2)
--   
--   &gt;&gt;&gt; let v0 = basis 0 :: Vec2 Int
--   
--   &gt;&gt;&gt; let v1 = basis 1 :: Vec2 Int
--   
--   &gt;&gt;&gt; v0 `eq` v0
--   True
--   
--   &gt;&gt;&gt; v0 `eq` v1
--   False
--   </pre>
eq :: (Vector v a, Eq a) => v a -> v a -> Bool

-- | Lexicographic ordering of two vectors.
ord :: (Vector v a, Ord a) => v a -> v a -> Ordering

-- | Map over vector
map :: (Vector v a, Vector v b) => (a -> b) -> v a -> v b

-- | Monadic map over vector.
mapM :: (Vector v a, Vector v b, Monad m) => (a -> m b) -> v a -> m (v b)

-- | Apply monadic action to each element of vector and ignore result.
mapM_ :: (Vector v a, Monad m) => (a -> m b) -> v a -> m ()

-- | Apply function to every element of the vector and its index.
imap :: (Vector v a, Vector v b) => (Int -> a -> b) -> v a -> v b

-- | Apply monadic function to every element of the vector and its index.
imapM :: (Vector v a, Vector v b, Monad m) => (Int -> a -> m b) -> v a -> m (v b)

-- | Apply monadic function to every element of the vector and its index
--   and discard result.
imapM_ :: (Vector v a, Monad m) => (Int -> a -> m b) -> v a -> m ()

-- | Left scan over vector
scanl :: (Vector v a, Vector w b, Dim w ~ S (Dim v)) => (b -> a -> b) -> b -> v a -> w b

-- | Left scan over vector
scanl1 :: Vector v a => (a -> a -> a) -> v a -> v a

-- | Evaluate every action in the vector from left to right.
sequence :: (Vector v a, Vector v (m a), Monad m) => v (m a) -> m (v a)

-- | Evaluate every action in the vector from left to right and ignore
--   result
sequence_ :: (Vector v (m a), Monad m) => v (m a) -> m ()

-- | Analog of <a>sequenceA</a> from <a>Traversable</a>.
sequenceA :: (Vector v a, Vector v (f a), Applicative f) => v (f a) -> f (v a)

-- | Analog of <a>traverse</a> from <a>Traversable</a>.
traverse :: (Vector v a, Vector v b, Applicative f) => (a -> f b) -> v a -> f (v b)
distribute :: (Vector v a, Vector v (f a), Functor f) => f (v a) -> v (f a)
collect :: (Vector v a, Vector v b, Vector v (f b), Functor f) => (a -> v b) -> f a -> v (f b)
distributeM :: (Vector v a, Vector v (m a), Monad m) => m (v a) -> v (m a)
collectM :: (Vector v a, Vector v b, Vector v (m b), Monad m) => (a -> v b) -> m a -> v (m b)

-- | Left fold over vector
foldl :: Vector v a => (b -> a -> b) -> b -> v a -> b

-- | Right fold over vector
foldr :: Vector v a => (a -> b -> b) -> b -> v a -> b

-- | Left fold over vector
foldl1 :: (Vector v a, Dim v ~ S n) => (a -> a -> a) -> v a -> a

-- | Combine the elements of a structure using a monoid. Similar to
--   <a>fold</a>
fold :: (Vector v m, Monoid m) => v m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results. Similar to <a>foldMap</a>
foldMap :: (Vector v a, Monoid m) => (a -> m) -> v a -> m

-- | Left fold over vector. Function is applied to each element and its
--   index.
ifoldl :: Vector v a => (b -> Int -> a -> b) -> b -> v a -> b

-- | Right fold over vector
ifoldr :: Vector v a => (Int -> a -> b -> b) -> b -> v a -> b

-- | Monadic fold over vector.
foldM :: (Vector v a, Monad m) => (b -> a -> m b) -> b -> v a -> m b

-- | Left monadic fold over vector. Function is applied to each element and
--   its index.
ifoldM :: (Vector v a, Monad m) => (b -> Int -> a -> m b) -> b -> v a -> m b

-- | Sum all elements in the vector.
sum :: (Vector v a, Num a) => v a -> a

-- | Maximal element of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; let x = mk3 1 2 3 :: Vec3 Int
--   
--   &gt;&gt;&gt; maximum x
--   3
--   </pre>
maximum :: (Vector v a, Dim v ~ S n, Ord a) => v a -> a

-- | Minimal element of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; let x = mk3 1 2 3 :: Vec3 Int
--   
--   &gt;&gt;&gt; minimum x
--   1
--   </pre>
minimum :: (Vector v a, Dim v ~ S n, Ord a) => v a -> a

-- | Conjunction of all elements of a vector.
and :: Vector v Bool => v Bool -> Bool

-- | Disjunction of all elements of a vector.
or :: Vector v Bool => v Bool -> Bool

-- | Determines whether all elements of vector satisfy predicate.
all :: Vector v a => (a -> Bool) -> v a -> Bool

-- | Determines whether any of element of vector satisfy predicate.
any :: Vector v a => (a -> Bool) -> v a -> Bool

-- | Zip two vector together using function.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; let b0 = basis 0 :: Vec3 Int
--   
--   &gt;&gt;&gt; let b1 = basis 1 :: Vec3 Int
--   
--   &gt;&gt;&gt; let b2 = basis 2 :: Vec3 Int
--   
--   &gt;&gt;&gt; let vplus x y = zipWith (+) x y
--   
--   &gt;&gt;&gt; vplus b0 b1
--   fromList [1,1,0]
--   
--   &gt;&gt;&gt; vplus b0 b2
--   fromList [1,0,1]
--   
--   &gt;&gt;&gt; vplus b1 b2
--   fromList [0,1,1]
--   </pre>
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> v a -> v b -> v c

-- | Zip three vector together
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> v a -> v b -> v c -> v d

-- | Zip two vector together using monadic function.
zipWithM :: (Vector v a, Vector v b, Vector v c, Monad m) => (a -> b -> m c) -> v a -> v b -> m (v c)

-- | Zip two vector elementwise using monadic function and discard result
zipWithM_ :: (Vector v a, Vector v b, Monad m) => (a -> b -> m c) -> v a -> v b -> m ()

-- | Zip two vector together using function which takes element index as
--   well.
izipWith :: (Vector v a, Vector v b, Vector v c) => (Int -> a -> b -> c) -> v a -> v b -> v c

-- | Zip three vector together
izipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (Int -> a -> b -> c -> d) -> v a -> v b -> v c -> v d

-- | Zip two vector together using monadic function which takes element
--   index as well..
izipWithM :: (Vector v a, Vector v b, Vector v c, Monad m) => (Int -> a -> b -> m c) -> v a -> v b -> m (v c)

-- | Zip two vector elementwise using monadic function and discard result
izipWithM_ :: (Vector v a, Vector v b, Vector v c, Monad m, Vector v (m c)) => (Int -> a -> b -> m c) -> v a -> v b -> m ()

-- | Default implementation of <a>alignment</a> for <a>Storable</a> type
--   class for fixed vectors.
defaultAlignemnt :: Storable a => v a -> Int

-- | Default implementation of <a>sizeOf</a> for <a>Storable</a> type class
--   for fixed vectors
defaultSizeOf :: (Storable a, Vector v a) => v a -> Int

-- | Default implementation of <a>peek</a> for <a>Storable</a> type class
--   for fixed vector
defaultPeek :: (Storable a, Vector v a) => Ptr (v a) -> IO (v a)

-- | Default implementation of <a>poke</a> for <a>Storable</a> type class
--   for fixed vector
defaultPoke :: (Storable a, Vector v a) => Ptr (v a) -> v a -> IO ()

-- | Convert between different vector types
convert :: (Vector v a, Vector w a, Dim v ~ Dim w) => v a -> w a

-- | Convert vector to the list
toList :: Vector v a => v a -> [a]

-- | Create vector form list. Will throw error if list is shorter than
--   resulting vector.
fromList :: Vector v a => [a] -> v a

-- | Create vector form list. Will throw error if list has different length
--   from resulting vector.
fromList' :: Vector v a => [a] -> v a

-- | Create vector form list. Will return <tt>Nothing</tt> if list has
--   different length from resulting vector.
fromListM :: Vector v a => [a] -> Maybe (v a)

-- | Create vector from <tt>Foldable</tt> data type. Will return
--   <tt>Nothing</tt> if data type different number of elements that
--   resulting vector.
fromFoldable :: (Vector v a, Foldable f) => f a -> Maybe (v a)

-- | Vector based on the lists. Not very useful by itself but is necessary
--   for implementation.
data VecList n a
Nil :: VecList Z a
Cons :: a -> VecList n a -> VecList (S n) a

-- | Single-element tuple.
newtype Only a
Only :: a -> Only a

-- | Empty tuple.
data Empty a
Empty :: Empty a
type Tuple2 a = (a, a)
type Tuple3 a = (a, a, a)
type Tuple4 a = (a, a, a, a)
type Tuple5 a = (a, a, a, a, a)
instance Typeable VecList
instance Typeable Only
instance Typeable Empty
instance Show a => Show (Only a)
instance Eq a => Eq (Only a)
instance Ord a => Ord (Only a)
instance Data a => Data (Only a)
instance Data a => Data (Empty a)
instance Vector Empty a
instance NFData (Empty a)
instance Traversable Empty
instance Foldable Empty
instance Functor Empty
instance Storable a => Storable (Only a)
instance Vector Only a
instance NFData a => NFData (Only a)
instance Monoid a => Monoid (Only a)
instance Traversable Only
instance Foldable Only
instance Functor Only
instance (Storable a, Arity n) => Storable (VecList n a)
instance (Arity n, Monoid a) => Monoid (VecList n a)
instance Arity n => Traversable (VecList n)
instance Arity n => Foldable (VecList n)
instance Arity n => Applicative (VecList n)
instance Arity n => Functor (VecList n)
instance (Ord a, Arity n) => Ord (VecList n a)
instance (Eq a, Arity n) => Eq (VecList n a)
instance (Show a, Arity n) => Show (VecList n a)
instance Arity n => VectorN VecList n a
instance Arity n => Vector (VecList n) a
instance (Arity n, NFData a) => NFData (VecList n a)


-- | Wrapper function for working with monomorphic vectors. Standard API
--   require vector to be parametric in their element type making it
--   impossible to work with vectors like
--   
--   <pre>
--   data Vec3 = Vec3 Double Double Double
--   </pre>
--   
--   This module provides newtype wrapper which allows use of functions
--   from <a>Data.Vector.Fixed</a> with such data types and function which
--   works with such vectors.
--   
--   Functions have same meaning as ones from <a>Data.Vector.Fixed</a> and
--   documented there.
module Data.Vector.Fixed.Monomorphic

-- | Dimensions of monomorphic vector.

-- | Type level zero
data Z

-- | Successor of n
data S n
type N1 = S Z
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5

-- | Counterpart of <tt>Vector</tt> type class for monomorphic vectors.
class Arity (DimMono v) => VectorMono v where type family VectorElm v :: * basicIndex v i = Mono v ! i
construct :: VectorMono v => Fun (DimMono v) (VectorElm v) v
inspect :: VectorMono v => v -> Fun (DimMono v) (VectorElm v) r -> r
basicIndex :: VectorMono v => v -> Int -> VectorElm v

-- | Type class for handling <i>n</i>-ary functions.
class Arity n

-- | Newtype wrapper which is used to make <a>Fn</a> injective. It's also a
--   reader monad.
newtype Fun n a b
Fun :: Fn n a b -> Fun n a b
unFun :: Fun n a b -> Fn n a b

-- | Length of vector
length :: Arity (DimMono v) => v -> Int
mk1 :: (VectorMono v, VectorElm v ~ a, DimMono v ~ N1) => a -> v
mk2 :: (VectorMono v, VectorElm v ~ a, DimMono v ~ N2) => a -> a -> v
mk3 :: (VectorMono v, VectorElm v ~ a, DimMono v ~ N3) => a -> a -> a -> v
mk4 :: (VectorMono v, VectorElm v ~ a, DimMono v ~ N4) => a -> a -> a -> a -> v
mk5 :: (VectorMono v, VectorElm v ~ a, DimMono v ~ N5) => a -> a -> a -> a -> a -> v
replicate :: (VectorMono v, VectorElm v ~ a) => a -> v
replicateM :: (VectorMono v, VectorElm v ~ a, Monad m) => m a -> m v
generate :: (VectorMono v, VectorElm v ~ a) => (Int -> a) -> v
generateM :: (Monad m, VectorMono v, VectorElm v ~ a) => (Int -> m a) -> m v
unfoldr :: (VectorMono v, VectorElm v ~ a) => (b -> (a, b)) -> b -> v
basis :: (VectorMono v, VectorElm v ~ a, Num a) => Int -> v
head :: (VectorMono v, VectorElm v ~ a, DimMono v ~ S n) => v -> a
tail :: (VectorMono v, VectorElm v ~ a, VectorMono w, VectorElm w ~ a, DimMono v ~ S (DimMono w)) => v -> w
reverse :: VectorMono v => v -> v
(!) :: (VectorMono v, VectorElm v ~ a) => v -> Int -> a
eq :: (VectorMono v, VectorElm v ~ a, Eq a) => v -> v -> Bool
map :: (VectorMono v, VectorElm v ~ a) => (a -> a) -> v -> v
mapM :: (VectorMono v, VectorElm v ~ a, Monad m) => (a -> m a) -> v -> m v
mapM_ :: (VectorMono v, VectorElm v ~ a, Monad m) => (a -> m b) -> v -> m ()
imap :: (VectorMono v, VectorElm v ~ a) => (Int -> a -> a) -> v -> v
imapM :: (VectorMono v, VectorElm v ~ a, Monad m) => (Int -> a -> m a) -> v -> m v
imapM_ :: (VectorMono v, VectorElm v ~ a, Monad m) => (Int -> a -> m b) -> v -> m ()
foldl :: (VectorMono v, VectorElm v ~ a) => (b -> a -> b) -> b -> v -> b
foldr :: (VectorMono v, VectorElm v ~ a) => (a -> b -> b) -> b -> v -> b
foldl1 :: (VectorMono v, VectorElm v ~ a, DimMono v ~ S n) => (a -> a -> a) -> v -> a
ifoldl :: (VectorMono v, VectorElm v ~ a) => (b -> Int -> a -> b) -> b -> v -> b
ifoldr :: (VectorMono v, VectorElm v ~ a) => (Int -> a -> b -> b) -> b -> v -> b
fold :: (VectorMono v, Monoid (VectorElm v)) => v -> VectorElm v
foldMap :: (VectorMono v, Monoid m) => (VectorElm v -> m) -> v -> m
foldM :: (VectorMono v, VectorElm v ~ a, Monad m) => (b -> a -> m b) -> b -> v -> m b
ifoldM :: (VectorMono v, VectorElm v ~ a, Monad m) => (b -> Int -> a -> m b) -> b -> v -> m b
sum :: (VectorMono v, VectorElm v ~ a, Num a) => v -> a
maximum :: (VectorMono v, VectorElm v ~ a, DimMono v ~ S n, Ord a) => v -> a
minimum :: (VectorMono v, VectorElm v ~ a, DimMono v ~ S n, Ord a) => v -> a
and :: (VectorMono v, VectorElm v ~ Bool) => v -> Bool
or :: (VectorMono v, VectorElm v ~ Bool) => v -> Bool
all :: (VectorMono v, VectorElm v ~ a) => (a -> Bool) -> v -> Bool
any :: (VectorMono v, VectorElm v ~ a) => (a -> Bool) -> v -> Bool
zipWith :: (VectorMono v, VectorElm v ~ a) => (a -> a -> a) -> v -> v -> v
zipWithM :: (VectorMono v, VectorElm v ~ a, Monad m) => (a -> a -> m a) -> v -> v -> m v
izipWith :: (VectorMono v, VectorElm v ~ a) => (Int -> a -> a -> a) -> v -> v -> v
izipWithM :: (VectorMono v, VectorElm v ~ a, Monad m) => (Int -> a -> a -> m a) -> v -> v -> m v
convert :: (VectorMono v, VectorMono w, VectorElm v ~ VectorElm w, DimMono v ~ DimMono w) => v -> w
toList :: (VectorMono v, VectorElm v ~ a) => v -> [a]
fromList :: (VectorMono v, VectorElm v ~ a) => [a] -> v
instance (VectorMono v, a ~ VectorElm v, Arity (DimMono v)) => Vector (Mono v) a


-- | Vector which could hold any value.
module Data.Vector.Fixed.Boxed

-- | Vector with fixed length which can hold any value.
data Vec n a
type Vec1 = Vec (S Z)
type Vec2 = Vec (S (S Z))
type Vec3 = Vec (S (S (S Z)))
type Vec4 = Vec (S (S (S (S Z))))
type Vec5 = Vec (S (S (S (S (S Z)))))

-- | Mutable unboxed vector with fixed length
data MVec n s a
instance Typeable MVec
instance Typeable Vec
instance Arity n => Traversable (Vec n)
instance Arity n => Foldable (Vec n)
instance Arity n => Applicative (Vec n)
instance Arity n => Functor (Vec n)
instance (Arity n, Monoid a) => Monoid (Vec n a)
instance (Arity n, Ord a) => Ord (Vec n a)
instance (Arity n, Eq a) => Eq (Vec n a)
instance Arity n => VectorN Vec n a
instance Arity n => Vector (Vec n) a
instance Arity n => IVector (Vec n) a
instance Arity n => MVector (MVec n) a
instance (Arity n, NFData a) => NFData (Vec n a)
instance (Arity n, Show a) => Show (Vec n a)
instance (Storable a, Arity n) => Storable (Vec n a)
instance (Typeable n, Arity n, Data a) => Data (Vec n a)


-- | Unboxed vectors with fixed length. Vectors from
--   <a>Data.Vector.Fixed.Unboxed</a> provide more flexibility at no
--   performeance cost.
module Data.Vector.Fixed.Primitive

-- | Unboxed vector with fixed length
data Vec n a
type Vec1 = Vec (S Z)
type Vec2 = Vec (S (S Z))
type Vec3 = Vec (S (S (S Z)))
type Vec4 = Vec (S (S (S (S Z))))
type Vec5 = Vec (S (S (S (S (S Z)))))

-- | Mutable unboxed vector with fixed length
data MVec n s a

-- | Class of types supporting primitive array operations
class Prim a
instance Typeable MVec
instance Typeable Vec
instance (Storable a, Prim a, Arity n) => Storable (Vec n a)
instance (Typeable n, Arity n, Prim a, Data a) => Data (Vec n a)
instance (Arity n, Prim a, Monoid a) => Monoid (Vec n a)
instance (Arity n, Prim a, Ord a) => Ord (Vec n a)
instance (Arity n, Prim a, Eq a) => Eq (Vec n a)
instance (Arity n, Prim a) => VectorN Vec n a
instance (Arity n, Prim a) => Vector (Vec n) a
instance (Arity n, Prim a) => IVector (Vec n) a
instance (Arity n, Prim a) => MVector (MVec n) a
instance (Arity n, Prim a, NFData a) => NFData (Vec n a)
instance (Arity n, Prim a, Show a) => Show (Vec n a)


-- | Unboxed vectors with fixed length.
module Data.Vector.Fixed.Unboxed
type Vec1 = Vec (S Z)
type Vec2 = Vec (S (S Z))
type Vec3 = Vec (S (S (S Z)))
type Vec4 = Vec (S (S (S (S Z))))
type Vec5 = Vec (S (S (S (S (S Z)))))
class (Arity n, IVector (Vec n) a, MVector (MVec n) a) => Unbox n a
instance Typeable MVec
instance Typeable Vec
instance (Arity n, Vector (Vec n) a, Vector (Vec n) b, Vector (Vec n) c, IVector (Vec n) a, IVector (Vec n) b, IVector (Vec n) c) => IVector (Vec n) (a, b, c)
instance (Arity n, MVector (MVec n) a, MVector (MVec n) b, MVector (MVec n) c) => MVector (MVec n) (a, b, c)
instance (Unbox n a, Unbox n b, Unbox n c) => Unbox n (a, b, c)
instance (Arity n, IVector (Vec n) a, IVector (Vec n) b) => IVector (Vec n) (a, b)
instance (Arity n, MVector (MVec n) a, MVector (MVec n) b) => MVector (MVec n) (a, b)
instance (Unbox n a, Unbox n b) => Unbox n (a, b)
instance (Arity n, IVector (Vec n) a) => IVector (Vec n) (Complex a)
instance (Arity n, MVector (MVec n) a) => MVector (MVec n) (Complex a)
instance Unbox n a => Unbox n (Complex a)
instance Arity n => IVector (Vec n) Double
instance Arity n => MVector (MVec n) Double
instance Arity n => Unbox n Double
instance Arity n => IVector (Vec n) Float
instance Arity n => MVector (MVec n) Float
instance Arity n => Unbox n Float
instance Arity n => IVector (Vec n) Char
instance Arity n => MVector (MVec n) Char
instance Arity n => Unbox n Char
instance Arity n => IVector (Vec n) Word64
instance Arity n => MVector (MVec n) Word64
instance Arity n => Unbox n Word64
instance Arity n => IVector (Vec n) Word32
instance Arity n => MVector (MVec n) Word32
instance Arity n => Unbox n Word32
instance Arity n => IVector (Vec n) Word16
instance Arity n => MVector (MVec n) Word16
instance Arity n => Unbox n Word16
instance Arity n => IVector (Vec n) Word8
instance Arity n => MVector (MVec n) Word8
instance Arity n => Unbox n Word8
instance Arity n => IVector (Vec n) Word
instance Arity n => MVector (MVec n) Word
instance Arity n => Unbox n Word
instance Arity n => IVector (Vec n) Int64
instance Arity n => MVector (MVec n) Int64
instance Arity n => Unbox n Int64
instance Arity n => IVector (Vec n) Int32
instance Arity n => MVector (MVec n) Int32
instance Arity n => Unbox n Int32
instance Arity n => IVector (Vec n) Int16
instance Arity n => MVector (MVec n) Int16
instance Arity n => Unbox n Int16
instance Arity n => IVector (Vec n) Int8
instance Arity n => MVector (MVec n) Int8
instance Arity n => Unbox n Int8
instance Arity n => IVector (Vec n) Int
instance Arity n => MVector (MVec n) Int
instance Arity n => Unbox n Int
instance Arity n => IVector (Vec n) Bool
instance Arity n => MVector (MVec n) Bool
instance Arity n => Unbox n Bool
instance Arity n => IVector (Vec n) ()
instance Arity n => MVector (MVec n) ()
instance Arity n => Unbox n ()
instance (Storable a, Unbox n a) => Storable (Vec n a)
instance (Typeable n, Unbox n a, Data a) => Data (Vec n a)
instance (Unbox n a, Monoid a) => Monoid (Vec n a)
instance (Unbox n a, Ord a) => Ord (Vec n a)
instance (Unbox n a, Eq a) => Eq (Vec n a)
instance Unbox n a => VectorN Vec n a
instance Unbox n a => Vector (Vec n) a
instance (Arity n, Unbox n a, NFData a) => NFData (Vec n a)
instance (Arity n, Show a, Unbox n a) => Show (Vec n a)


-- | Storable-based unboxed vectors.
module Data.Vector.Fixed.Storable

-- | Storable-based vector with fixed length
data Vec n a
type Vec1 = Vec (S Z)
type Vec2 = Vec (S (S Z))
type Vec3 = Vec (S (S (S Z)))
type Vec4 = Vec (S (S (S (S Z))))
type Vec5 = Vec (S (S (S (S (S Z)))))

-- | Construct vector from foreign pointer.
unsafeFromForeignPtr :: ForeignPtr a -> Vec n a

-- | Get underlying pointer. Data may not be modified through pointer.
unsafeToForeignPtr :: Vec n a -> ForeignPtr a
unsafeWith :: (Ptr a -> IO b) -> Vec n a -> IO b

-- | Storable-based mutable vector with fixed length
newtype MVec n s a
MVec :: (ForeignPtr a) -> MVec n s a

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
--   
--   Minimal complete definition: <a>sizeOf</a>, <a>alignment</a>, one of
--   <a>peek</a>, <a>peekElemOff</a> and <a>peekByteOff</a>, and one of
--   <a>poke</a>, <a>pokeElemOff</a> and <a>pokeByteOff</a>.
class Storable a
instance Typeable MVec
instance Typeable Vec
instance (Typeable n, Arity n, Storable a, Data a) => Data (Vec n a)
instance (Arity n, Storable a) => Storable (Vec n a)
instance (Arity n, Storable a, Monoid a) => Monoid (Vec n a)
instance (Arity n, Storable a, Ord a) => Ord (Vec n a)
instance (Arity n, Storable a, Eq a) => Eq (Vec n a)
instance (Arity n, Storable a) => VectorN Vec n a
instance (Arity n, Storable a) => Vector (Vec n) a
instance (Arity n, Storable a) => IVector (Vec n) a
instance (Arity n, Storable a) => MVector (MVec n) a
instance (Arity n, Storable a, NFData a) => NFData (Vec n a)
instance (Arity n, Storable a, Show a) => Show (Vec n a)
