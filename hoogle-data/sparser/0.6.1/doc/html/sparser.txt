-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lightweight parsing library based on partial functions.
--   
--   To be written.
@package sparser
@version 0.6.1


-- | Lightweight parsing library based on partial functions.
module Data.Sparser
data SparserT s a b
type Sparser = SparserT () Char
asSparser :: Sparser a -> Sparser a

-- | Run a parser, returning the result.
runSparser :: Sparser a -> String -> Maybe a

-- | Run a parser with a custom state, returning the result.
runSparserT :: SparserT s a b -> s -> [a] -> Maybe b

-- | Run a parser with a custom state.
--   
--   This is the most general way to run a parser. It returns the final
--   state, remaining input and the result.
runSparserT' :: SparserT s a b -> s -> [a] -> Maybe (s, [a], b)
withState :: (s -> t) -> (t -> s) -> SparserT t a b -> SparserT s a b

-- | Return the state as result.
stateP :: SparserT s a s

-- | Consumes one input element.
--   
--   Fails if the predicate fails, or if there is no more input.
headP :: (s -> a -> Bool) -> SparserT s a a

-- | Consume one or more input elements.
--   
--   The given function receives the <i>entire</i> remaining input, and
--   must return the number of consumed elements.
--   
--   Fails if the predicate return 0 or less, or if there is no more input.
splitP :: (s -> [a] -> Int) -> SparserT s a [a]

-- | Succeed based on predicate, but do not consume input.
--   
--   The given function receives the <i>entire</i> remaining input.
gateP :: (s -> [a] -> Bool) -> SparserT s a ()
atEnd :: SparserT s a ()
char :: Eq a => a -> SparserT s a a
notChar :: Eq a => a -> SparserT s a a
charIf :: (a -> Bool) -> SparserT s a a
string :: Eq a => [a] -> SparserT s a [a]
stringIf :: Int -> ([a] -> Bool) -> SparserT s a [a]
space :: SparserT s Char [Char]
integer :: SparserT s Char Integer
stringLiteral :: SparserT s Char String
brackets :: SparserT s Char b -> SparserT s Char b
braces :: SparserT s Char b -> SparserT s Char b
complete :: SparserT s a b -> SparserT s a b
ifState :: (s -> Bool) -> SparserT s a b -> SparserT s a b
between :: Monad m => m a -> m a1 -> m b -> m b
skipMany1 :: (Monad m, Alternative m) => m a -> m ()
skipMany :: (Monad f, Alternative f) => f a -> f ()
many1 :: (Monad m, Alternative m) => m a -> m [a]
sepBy :: (Monad f, Alternative f) => f a1 -> f a -> f [a1]
sepBy1 :: (Monad m, Alternative m) => m a1 -> m a -> m [a1]
sepEndBy1 :: (Monad m, Alternative m) => m a1 -> m a -> m [a1]
sepEndBy :: (Monad m, Alternative m) => m a1 -> m a -> m [a1]
endBy1 :: (Monad m, Alternative m) => m a -> m a1 -> m [a]
endBy :: (Monad f, Alternative f) => f a -> f a1 -> f [a]
count :: Monad m => Int -> m a -> m [a]
instance Semigroup (SparserT s a b)
instance Monoid (SparserT s a b)
instance Functor (SparserT s a)
instance Pointed (SparserT s a)
instance Applicative (SparserT s a)
instance Alternative (SparserT s a)
instance Monad (SparserT s a)
instance MonadPlus (SparserT s a)
instance Eq JSON
instance Ord JSON
instance Show JSON
instance Eq a => Eq (Rhythm a)
instance Show a => Show (Rhythm a)
instance Functor Rhythm
instance Foldable Rhythm
instance Eq QuantState
instance Show QuantState
instance HasRecur QuantState
instance HasTimeScale QuantState
instance HasTimeScale ()
instance Default QuantState
instance Monoid (Rhythm a)
instance Semigroup (Rhythm a)
instance IsString (SparserT s Char String)
instance Monoid (a ?-> b)
instance Semigroup (a ?-> b)
instance Pointed ((?->) r)
instance Alternative ((?->) r)
instance Applicative ((?->) r)
instance MonadPlus ((?->) r)
instance Monad ((?->) r)
instance Functor ((?->) r)
