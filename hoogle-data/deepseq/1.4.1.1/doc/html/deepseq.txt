-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Deep evaluation of data structures
--   
--   This package provides methods for fully evaluating data structures
--   ("deep evaluation"). Deep evaluation is often used for adding
--   strictness to a program, e.g. in order to force pending exceptions,
--   remove space leaks, or force lazy I/O to happen. It is also useful in
--   parallel programs, to ensure pending work does not migrate to the
--   wrong thread.
--   
--   The primary use of this package is via the <a>deepseq</a> function, a
--   "deep" version of <a>seq</a>. It is implemented on top of an
--   <a>NFData</a> typeclass ("Normal Form Data", data structures with no
--   unevaluated components) which defines strategies for fully evaluating
--   different data types.
@package deepseq
@version 1.4.1.1


-- | This module provides an overloaded function, <a>deepseq</a>, for fully
--   evaluating data structures (that is, evaluating to "Normal Form").
--   
--   A typical use is to prevent resource leaks in lazy IO programs, by
--   forcing all characters from a file to be read. For example:
--   
--   <pre>
--   import System.IO
--   import Control.DeepSeq
--   
--   main = do
--       h &lt;- openFile "f" ReadMode
--       s &lt;- hGetContents h
--       s `deepseq` hClose h
--       return s
--   </pre>
--   
--   <a>deepseq</a> differs from <a>seq</a> as it traverses data structures
--   deeply, for example, <a>seq</a> will evaluate only to the first
--   constructor in the list:
--   
--   <pre>
--   &gt; [1,2,undefined] `seq` 3
--   3
--   </pre>
--   
--   While <a>deepseq</a> will force evaluation of all the list elements:
--   
--   <pre>
--   &gt; [1,2,undefined] `deepseq` 3
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   Another common use is to ensure any exceptions hidden within lazy
--   fields of a data structure do not leak outside the scope of the
--   exception handler, or to force evaluation of a data structure in one
--   thread, before passing to another thread (preventing work moving to
--   the wrong threads).
--   
--   <i>Since: 1.1.0.0</i>
module Control.DeepSeq

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
--   
--   <i>Since: 1.1.0.0</i>
deepseq :: NFData a => a -> b -> b

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
--   
--   <i>Since: 1.2.0.0</i>
($!!) :: (NFData a) => (a -> b) -> a -> b

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   <i>Since: 1.2.0.0</i>
force :: (NFData a) => a -> a

-- | A class of types that can be fully evaluated.
--   
--   <i>Since: 1.1.0.0</i>
class NFData a where rnf = grnf . from
rnf :: NFData a => a -> ()
instance [safe] GNFData V1
instance [safe] GNFData U1
instance [safe] NFData a => GNFData (K1 i a)
instance [safe] GNFData a => GNFData (M1 i c a)
instance [safe] (GNFData a, GNFData b) => GNFData (a :*: b)
instance [safe] (GNFData a, GNFData b) => GNFData (a :+: b)
instance [safe] NFData Int
instance [safe] NFData Word
instance [safe] NFData Integer
instance [safe] NFData Float
instance [safe] NFData Double
instance [safe] NFData Char
instance [safe] NFData Bool
instance [safe] NFData ()
instance [safe] NFData Int8
instance [safe] NFData Int16
instance [safe] NFData Int32
instance [safe] NFData Int64
instance [safe] NFData Word8
instance [safe] NFData Word16
instance [safe] NFData Word32
instance [safe] NFData Word64
instance [safe] NFData (Proxy a)
instance [safe] NFData a => NFData (Identity a)
instance [safe] NFData Void
instance [safe] NFData Natural
instance [safe] NFData (Fixed a)
instance [safe] NFData (a -> b)
instance [safe] (Integral a, NFData a) => NFData (Ratio a)
instance [safe] NFData a => NFData (Complex a)
instance [safe] NFData a => NFData (Maybe a)
instance [safe] (NFData a, NFData b) => NFData (Either a b)
instance [safe] NFData Version
instance [safe] NFData a => NFData [a]
instance [safe] NFData a => NFData (ZipList a)
instance [safe] NFData a => NFData (Const a b)
instance [safe] (Ix a, NFData a, NFData b) => NFData (Array a b)
instance [safe] NFData a => NFData (Down a)
instance [safe] NFData a => NFData (Dual a)
instance [safe] NFData a => NFData (First a)
instance [safe] NFData a => NFData (Last a)
instance [safe] NFData Any
instance [safe] NFData All
instance [safe] NFData a => NFData (Sum a)
instance [safe] NFData a => NFData (Product a)
instance [safe] NFData (StableName a)
instance [safe] NFData ThreadId
instance [safe] NFData Unique
instance [safe] NFData TypeRep
instance [safe] NFData TyCon
instance [safe] NFData Fingerprint
instance [safe] NFData CChar
instance [safe] NFData CSChar
instance [safe] NFData CUChar
instance [safe] NFData CShort
instance [safe] NFData CUShort
instance [safe] NFData CInt
instance [safe] NFData CUInt
instance [safe] NFData CLong
instance [safe] NFData CULong
instance [safe] NFData CPtrdiff
instance [safe] NFData CSize
instance [safe] NFData CWchar
instance [safe] NFData CSigAtomic
instance [safe] NFData CLLong
instance [safe] NFData CULLong
instance [safe] NFData CIntPtr
instance [safe] NFData CUIntPtr
instance [safe] NFData CIntMax
instance [safe] NFData CUIntMax
instance [safe] NFData CClock
instance [safe] NFData CTime
instance [safe] NFData CUSeconds
instance [safe] NFData CSUSeconds
instance [safe] NFData CFloat
instance [safe] NFData CDouble
instance [safe] NFData CFile
instance [safe] NFData CFpos
instance [safe] NFData CJmpBuf
instance [safe] (NFData a, NFData b) => NFData (a, b)
instance [safe] (NFData a, NFData b, NFData c) => NFData (a, b, c)
instance [safe] (NFData a, NFData b, NFData c, NFData d) => NFData (a, b, c, d)
instance [safe] (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5) => NFData (a1, a2, a3, a4, a5)
instance [safe] (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5, NFData a6) => NFData (a1, a2, a3, a4, a5, a6)
instance [safe] (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5, NFData a6, NFData a7) => NFData (a1, a2, a3, a4, a5, a6, a7)
instance [safe] (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5, NFData a6, NFData a7, NFData a8) => NFData (a1, a2, a3, a4, a5, a6, a7, a8)
instance [safe] (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5, NFData a6, NFData a7, NFData a8, NFData a9) => NFData (a1, a2, a3, a4, a5, a6, a7, a8, a9)
