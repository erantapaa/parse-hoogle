-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monad (and transformer) for deferred-effect pure
prompt-response queries
--   
@package prompt
@version 0.1.1.0


-- | Provides a typeclass for <a>Applicative</a> and <a>Monad</a> types
--   that give you the ability to, at any time, "prompt" with an <tt>a</tt>
--   and get a <tt>b</tt> in response. The power of this instance is that
--   each type gets to define its own way to deliver a response.
--   
--   This library provides instances for <tt>PromptT</tt> from
--   <a>Control.Monad.Prompt</a> and the monad transformers in
--   <i>transformers</i> and <i>mtl</i>. Feel free to create your own
--   instances too.
--   
--   <pre>
--   data Interactive a = Interactive ((String -&gt; String) -&gt; a)
--   
--   -- at any time, ask with a string to get a string
--   instance MonadPrompt String String Interactive where
--       prompt str = Interactive $ f -&gt; f str
--   </pre>
module Control.Monad.Prompt.Class

-- | An <a>Applicative</a> (and possibly <a>Monad</a>) where you can, at
--   any time, "prompt" with an <tt>a</tt> and receive a <tt>b</tt> in
--   response.
--   
--   Instances include <tt>PromptT</tt> and any <i>transformers</i> monad
--   transformer over another <a>MonadPrompt</a>.
class Applicative m => MonadPrompt a b m | m -> a b where prompt = prompts id prompts f = fmap f . prompt
prompt :: MonadPrompt a b m => a -> m b
prompts :: MonadPrompt a b m => (b -> c) -> a -> m c

-- | A version of <a>prompt</a> strict on its prompting value.
prompt' :: MonadPrompt a b m => a -> m b

-- | A version of <a>prompts</a> strict on its prompting value.
prompts' :: MonadPrompt a b m => (b -> c) -> a -> m c
instance (Monad m, MonadPrompt a b m) => MonadPrompt a b (MaybeT m)
instance (Monad m, MonadPrompt a b m, Monoid w) => MonadPrompt a b (RWST r w s m)
instance (Monad m, MonadPrompt a b m, Monoid w) => MonadPrompt a b (RWST r w s m)
instance (Monad m, MonadPrompt a b m, Monoid w) => MonadPrompt a b (WriterT w m)
instance (Monad m, MonadPrompt a b m, Monoid w) => MonadPrompt a b (WriterT w m)
instance (Monad m, MonadPrompt a b m) => MonadPrompt a b (StateT s m)
instance (Monad m, MonadPrompt a b m) => MonadPrompt a b (StateT s m)
instance (Monad m, MonadPrompt a b m, Error e) => MonadPrompt a b (ErrorT e m)
instance (Monad m, MonadPrompt a b m) => MonadPrompt a b (ExceptT e m)
instance (Monad m, MonadPrompt a b m) => MonadPrompt a b (ReaderT r m)


-- | Provides the <a>PromptT</a> type, which allows you to program
--   computations that can "ask" or "prompt" with values to get values in
--   return. The computation doesn't care about the process of prompting,
--   or how it works, and has nothing to do with the effectful monad where
--   the prompting will eventually take place.
--   
--   For example, sometimes you might want a computation to be able to
--   query or database, or talk with stdio, but you don't want your type to
--   involve arbitrary IO or be over IO, opening the door to a mess of IO.
--   <a>Prompt</a> lets you write programs that can query "something", and
--   then at a later point in time, run it, providing the method of
--   fulfilling each prompt. Write your program independent of IO, or
--   databases, or stdio, etc.; only later "fill in" what it means. You can
--   even run the same <a>Prompt</a> with different ways to fulfill the
--   prompts --- pure, effectful, etc.
--   
--   For usage examples and a more detailed explanation, see <a>the
--   README</a>.
module Control.Monad.Prompt

-- | Prompt type, providing the ability to "prompt" or "query" by
--   presenting/asking with an <tt>a</tt> and receiving a <tt>b</tt>
--   response.
--   
--   <pre>
--   <a>prompt</a> :: a -&gt; (Prompt a b) b
--   </pre>
--   
--   "Ask with an <tt>a</tt>, get a <tt>b</tt>."
--   
--   Has a <a>Monad</a>, <a>Applicative</a>, <a>Functor</a>, etc. instance
--   so it can be sequenced monadically or applicatively, so you can
--   sequence and bind from <a>prompt</a>.
--   
--   Note that we defer the process of specifying <i>how</i> <a>prompt</a>
--   delivers its <tt>b</tt>. It can take place in IO, or in any other
--   effectful setting...but <a>Prompt</a> doesn't care, and it never
--   involves IO or any arbitrary IO itself.
--   
--   Can be "constructed directly" using <a>mkPrompt</a>, but typically
--   using <a>prompt</a> and the <a>Applicative</a>, <a>Monad</a> instances
--   etc. is better.
type Prompt a b = PromptT a b Identity

-- | Run a <tt><a>Prompt</a> a b r</tt> with a given effectful <tt>a -&gt;
--   m b</tt> "prompt response" function, to get the resulting <tt>r</tt>
--   in <tt>m</tt>. Note that the <a>Prompt</a> itself in general has
--   nothing to do with <tt>m</tt>, and cannot execute arbitrary <tt>m</tt>
--   other than that given in the prompt response function.
runPromptM :: Monad m => Prompt a b r -> (a -> m b) -> m r

-- | Run a <tt><a>Prompt</a> a b r</tt> with a pure <tt>a -&gt; b</tt>
--   prompt response function. More or less reduces <tt><a>Prompt</a> a
--   b</tt> to a <tt><tt>Reader</tt> (a -&gt; b)</tt>.
runPrompt :: Prompt a b r -> (a -> b) -> r

-- | Run a <tt><a>Prompt</a> String String</tt> in IO by sending the
--   request to stdout and reading the response from stdin.
interactP :: Prompt String String r -> IO r

-- | Like <a>Prompt</a>, but can perform its "pure" computations in the
--   context of a <a>Traversable</a> <tt>t</tt>, to absorb short-circuiting
--   behvaior with <a>Maybe</a> or <a>Either</a>, logging with
--   <tt>Writer</tt>, etc., but this is in general completely unrelated to
--   the effectful monad where the prompting will eventually take place.
--   Specify short-circuiting and logging logic, without worrying about IO
--   or anything relating to the prompting effect.
--   
--   <pre>
--   <a>prompt</a> :: a -&gt; (PromptT a b t) b
--   </pre>
--   
--   Implements several useful typeclasses for working with the underlying
--   <a>Traversable</a> and integrating effects, like <a>Alternative</a>,
--   <a>MonadError</a>, <a>MonadWriter</a>, etc.
--   
--   Constructor is hidden, but a direct constructing function is exported
--   as <tt>mkPrompT</tt> in the rare case it is needed or wanted.
data PromptT a b t r

-- | Run a <tt><a>PromptT</a> a b t r</tt> with a given effectful <tt>a
--   -&gt; m (t b)</tt> "prompt response" function, to get the resulting
--   <tt>r</tt> in <tt>m</tt> and <tt>t</tt>. The "prompt response"
--   function is able to interact with the underlying <a>Traversable</a>
--   <tt>t</tt>.
--   
--   Note that the <a>PromptT</a> in general has nothing to do with the
--   <tt>m</tt>, and cannot execute arbitrary <tt>m</tt> other than that
--   given in the prompt response function.
runPromptTM :: Monad m => PromptT a b t r -> (a -> m (t b)) -> m (t r)

-- | Run a <tt><a>PromptT</a> a b t r</tt> with a given <tt>a -&gt; t
--   b</tt> function, with <a>Traversable</a> <tt>t</tt>. The effects take
--   place in the same context as the underlying context of the
--   <a>PromptT</a>.
runPromptT :: PromptT a b t r -> (a -> t b) -> t r

-- | Run a <tt><a>PromptT</a> String String</tt> in IO by sending the
--   request to stdout and reading the response from stdin.
interactPT :: Applicative t => PromptT String String t r -> IO (t r)

-- | An <a>Applicative</a> (and possibly <a>Monad</a>) where you can, at
--   any time, "prompt" with an <tt>a</tt> and receive a <tt>b</tt> in
--   response.
--   
--   Instances include <tt>PromptT</tt> and any <i>transformers</i> monad
--   transformer over another <a>MonadPrompt</a>.
class Applicative m => MonadPrompt a b m | m -> a b where prompt = prompts id prompts f = fmap f . prompt
prompt :: MonadPrompt a b m => a -> m b
prompts :: MonadPrompt a b m => (b -> c) -> a -> m c

-- | A version of <a>prompt</a> strict on its prompting value.
prompt' :: MonadPrompt a b m => a -> m b

-- | A version of <a>prompts</a> strict on its prompting value.
prompts' :: MonadPrompt a b m => (b -> c) -> a -> m c

-- | Like <a>prompt</a>, but specialized to <a>PromptT</a> and without the
--   <a>Applicative</a> constraint.
promptP :: a -> PromptT a b t b

-- | Like <a>prompts</a>, but specialized to <a>PromptT</a> and downgrading
--   the <a>Applicative</a> constraint to a <a>Functor</a> constraint.
promptsP :: Functor t => (b -> c) -> a -> PromptT a b t c

-- | Like <a>prompt'</a>, but specialized to <a>PromptT</a> and without the
--   <a>Applicative</a> constraint. Is a <a>promptP</a> strict on its
--   argument.
promptP' :: a -> PromptT a b t b

-- | Like <a>prompts'</a>, but specialized to <a>PromptT</a> and
--   downgrading the <a>Applicative</a> constraint to a <a>Functor</a>
--   constraint. Is a <a>promptsP</a> strict on its argument.
promptsP' :: Functor t => (b -> c) -> a -> PromptT a b t c

-- | Maps the underying <tt>t a</tt> returned by <a>PromptT</a>. Cannot
--   change <tt>t</tt>.
mapPromptT :: (t r -> t s) -> PromptT a b t r -> PromptT a b t s

-- | Swap out the <a>Traversable</a> <tt>t</tt> with a pair of natural
--   transformations. The first maps the output <tt>t a</tt>, and the
--   second maps the result of the prompting function.
hoistP :: (forall s. t s -> u s) -> (forall s. u s -> t s) -> PromptT a b t r -> PromptT a b u r

-- | Like <a>lift</a>, but without the <a>Monad</a> constraint.
liftP :: t r -> PromptT a b t r

-- | Directly construct a <a>PromptT</a>. Has to be able to take a <tt>(a -
--   m (t b)) -&gt; m (t r)</tt> that can work on <i>any</i> <a>Monad</a>.
--   
--   Typically this won't be used, but is provided for completion; using
--   <a>prompt</a> and its <a>Applicative</a>, <a>Monad</a> instances,
--   etc., is more clear.
--   
--   <pre>
--   <a>prompt</a> r = <a>mkPromptT</a> $ g -&gt; g r
--   </pre>
mkPromptT :: (forall m. Monad m => (a -> m (t b)) -> m (t r)) -> PromptT a b t r

-- | Directly construct a <a>Prompt</a>. Has to be able to take a <tt>(a
--   -&gt; m b) -&gt; m r</tt> that can work on <i>any</i> <a>Monad</a>.
--   
--   Typically this won't be used, but is provided for completion; using
--   <a>prompt</a> and its <a>Applicative</a>, <a>Monad</a> instances,
--   etc., is more clear.
mkPrompt :: (forall m. Monad m => (a -> m b) -> m r) -> Prompt a b r
instance Applicative t => MonadPrompt a b (PromptT a b t)
instance (MonadWriter w t, Traversable t) => MonadWriter w (PromptT a b t)
instance (MonadState s t, Traversable t) => MonadState s (PromptT a b t)
instance (MonadReader r t, Traversable t) => MonadReader r (PromptT a b t)
instance (MonadError e t, Traversable t) => MonadError e (PromptT a b t)
instance MonadTrans (PromptT a b)
instance (MonadPlus t, Traversable t) => MonadPlus (PromptT a b t)
instance (Monad t, Traversable t) => Monad (PromptT a b t)
instance (Alternative t, Traversable t) => Alternative (PromptT a b t)
instance Applicative t => Applicative (PromptT a b t)
instance Functor t => Functor (PromptT a b t)
