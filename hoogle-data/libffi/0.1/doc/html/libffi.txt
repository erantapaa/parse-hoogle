-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A binding to libffi
--   
--   A binding to libffi, allowing C functions of types only known at
--   runtime to be called from Haskell.
@package libffi
@version 0.1


-- | The internals of the C library libffi
module Foreign.LibFFI.Internal
data CValue
data CType
data CIF
type C_ffi_status = Word32
type C_ffi_abi = Word32
ffi_default_abi :: C_ffi_abi
ffi_ok :: C_ffi_status
sizeOf_cif :: Int
sizeOf_ffi_type :: Int
init_ffi_type :: Ptr CType -> Ptr (Ptr CType) -> IO ()
ffi_prep_cif :: Ptr CIF -> C_ffi_abi -> CUInt -> Ptr CType -> Ptr (Ptr CType) -> IO C_ffi_status
ffi_call :: Ptr CIF -> FunPtr a -> Ptr CValue -> Ptr (Ptr CValue) -> IO ()


-- | The pointers exported and used by the C libffi describing basic ffi
--   types.
module Foreign.LibFFI.FFITypes
ffi_type_void :: Ptr CType
ffi_type_sint8 :: Ptr CType
ffi_type_uint8 :: Ptr CType
ffi_type_uint16 :: Ptr CType
ffi_type_sint16 :: Ptr CType
ffi_type_uint32 :: Ptr CType
ffi_type_sint32 :: Ptr CType
ffi_type_uint64 :: Ptr CType
ffi_type_sint64 :: Ptr CType
ffi_type_float :: Ptr CType
ffi_type_double :: Ptr CType
ffi_type_pointer :: Ptr CType
ffi_type_uchar :: Ptr CType
ffi_type_schar :: Ptr CType
ffi_type_wchar :: Ptr CType
ffi_type_size :: Ptr CType
ffi_type_time :: Ptr CType
ffi_type_uint :: Ptr CType
ffi_type_sint :: Ptr CType
ffi_type_ulong :: Ptr CType
ffi_type_slong :: Ptr CType
ffi_type_hs_int :: Ptr CType
ffi_type_hs_word :: Ptr CType


-- | This module defines the basic libffi machinery. You will need this to
--   create support for new ffi types.
module Foreign.LibFFI.Base
newtype Arg
Arg :: IO (Ptr CType, Ptr CValue, IO ()) -> Arg
unArg :: Arg -> IO (Ptr CType, Ptr CValue, IO ())
customPointerArg :: (a -> IO (Ptr b)) -> (Ptr b -> IO ()) -> a -> Arg
mkStorableArg :: Storable a => Ptr CType -> a -> Arg
data RetType a
RetType :: (Ptr CType) -> ((Ptr CValue -> IO ()) -> IO a) -> RetType a
withRetType :: (a -> IO b) -> RetType a -> RetType b
mkStorableRetType :: Storable a => Ptr CType -> RetType a
newStorableStructArgRet :: Storable a => [Ptr CType] -> IO (a -> Arg, RetType a, IO ())
newStructCType :: [Ptr CType] -> IO (Ptr CType, IO ())
callFFI :: FunPtr a -> RetType b -> [Arg] -> IO b
instance Functor RetType


-- | Arguments and return types
module Foreign.LibFFI.Types
argCInt :: CInt -> Arg
argCUInt :: CUInt -> Arg
argCLong :: CLong -> Arg
argCULong :: CULong -> Arg

-- | Note that on e.g. x86_64, Int /= CInt
argInt :: Int -> Arg
argInt8 :: Int8 -> Arg
argInt16 :: Int16 -> Arg
argInt32 :: Int32 -> Arg
argInt64 :: Int64 -> Arg
argWord :: Word -> Arg
argWord8 :: Word8 -> Arg
argWord16 :: Word16 -> Arg
argWord32 :: Word32 -> Arg
argWord64 :: Word64 -> Arg
argCFloat :: CFloat -> Arg
argCDouble :: CDouble -> Arg
argCSize :: CSize -> Arg
argCTime :: CTime -> Arg
argCChar :: CChar -> Arg
argCUChar :: CUChar -> Arg
argCWchar :: CWchar -> Arg
argPtr :: Ptr a -> Arg
argFunPtr :: FunPtr a -> Arg

-- | The string argument is passed to C as a char * pointer, which is freed
--   afterwards. The argument should not contain zero-bytes.
argString :: String -> Arg

-- | Like argString, but for ByteString's.
argByteString :: ByteString -> Arg

-- | Like argByteString, but changing the string from C breaks referential
--   transparency.
argConstByteString :: ByteString -> Arg
retVoid :: RetType ()
retCInt :: RetType CInt
retCUInt :: RetType CUInt
retCLong :: RetType CLong
retCULong :: RetType CULong
retInt :: RetType Int
retInt8 :: RetType Int8
retInt16 :: RetType Int16
retInt32 :: RetType Int32
retInt64 :: RetType Int64
retWord :: RetType Word
retWord8 :: RetType Word8
retWord16 :: RetType Word16
retWord32 :: RetType Word32
retWord64 :: RetType Word64
retCFloat :: RetType CFloat
retCDouble :: RetType CDouble
retCSize :: RetType CSize
retCTime :: RetType CTime
retCChar :: RetType CChar
retCUChar :: RetType CUChar
retCWchar :: RetType CWchar
retPtr :: RetType a -> RetType (Ptr a)
retFunPtr :: RetType a -> RetType (FunPtr a)
retCString :: RetType CString

-- | Peek a String out of the returned char *. The char * is not freed.
retString :: RetType String

-- | Like retString, but for ByteString's
retByteString :: RetType ByteString

-- | Make a ByteString out of the returned char *. The char * will be
--   free(3)ed when the ByteString is garbage collected.
retMallocByteString :: RetType ByteString


-- | This is the only module that normal users should need to import.
--   
--   As an example, allocate 1GB of memory, zero it, and crash:
--   
--   <pre>
--   import System.Posix.DynamicLinker
--   import Foreign.Ptr
--   import Foreign.LibFFI
--   
--   main = do
--       malloc &lt;- dlsym Default "malloc"
--       memset &lt;- dlsym Default "memset"
--       p &lt;- callFFI malloc (retPtr retVoid) [argCSize (2^30)]
--       callFFI memset (retPtr retVoid) [argPtr p, argCInt 0, argCSize (2^30)]
--       callFFI memset (retPtr retVoid) [argPtr nullPtr, argCInt 0, argCSize 1]
--   </pre>
module Foreign.LibFFI
data Arg
data RetType a
callFFI :: FunPtr a -> RetType b -> [Arg] -> IO b
withRetType :: (a -> IO b) -> RetType a -> RetType b
