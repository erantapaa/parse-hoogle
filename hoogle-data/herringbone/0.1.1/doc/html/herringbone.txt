-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for compiling and serving static web assets.
--   
--   A library for compiling and serving static web assets. For more
--   information, please see
--   <a>https://github.com/hdgarrood/herringbone</a>.
@package herringbone
@version 0.1.1

module Web.Herringbone.Internal.Utils

-- | Return the absolute paths of all files (excluding directories and
--   other things) below the given root.
getFilesRecursive :: FilePath -> IO [FilePath]

-- | Return the relative paths of all files (excluding directories and
--   other things) below the given root.
getFilesRecursiveRelative :: FilePath -> IO [FilePath]

-- | Partition a list of values based on a monadic predicate, with the list
--   of values satisfying the predicate as the first element of the result
--   pair, and the list of values not satisfying the predicate as the
--   second.
partitionM :: Monad m => (a -> m Bool) -> [a] -> m ([a], [a])

module Web.Herringbone.Internal.Types

-- | A value describing an error that occurred while trying to produce an
--   <a>Asset</a>.
data AssetError
AssetNotFound :: AssetError
AssetCompileError :: CompileError -> AssetError
AmbiguousSources :: [FilePath] -> AssetError

-- | Data which is given to preprocessors on the off-chance that they need
--   it (eg, Fay)
data PPReader
PPReader :: Herringbone -> FilePath -> [PP] -> PPReader

-- | The Herringbone which was used to build the asset
ppReaderHb :: PPReader -> Herringbone

-- | The file path to the source file
ppReaderSourcePath :: PPReader -> FilePath

-- | Preprocessors being invoked. Currently this will only ever have zero
--   or one elements; in the future, Herringbone may be able to run
--   multiple preprocessors on a single file.
ppReaderPPs :: PPReader -> [PP]

-- | A monad in which preprocessor actions happen.
newtype PPM a
PPM :: ReaderT PPReader IO a -> PPM a
unPPM :: PPM a -> ReaderT PPReader IO a
runPPM :: PPM a -> PPReader -> IO a

-- | A preprocessor something which is run on the asset before it is
--   served. Preprocessors are run when a file matches its rule. For
--   example, if you have a preprocessor which takes "coffee" files and
--   emits "js" files, there is a file named "application.coffee", and you
--   request "application.js", Herringbone will run the coffee preprocessor
--   on "application.coffee" and serve you the result.
data PP
PP :: Text -> Text -> Text -> PPAction -> PP

-- | Identifies a preprocessor. Mainly useful for debugging compile errors.
ppName :: PP -> Text

-- | Extension for files this preprocessor consumes.
ppConsumes :: PP -> Text

-- | Extension for files this preprocessor produces.
ppProduces :: PP -> Text

-- | Performs the compilation.
ppAction :: PP -> PPAction

-- | A function which performs the compilation.
type PPAction = ByteString -> PPM (Either CompileError ByteString)

-- | A string which should contain information about why an asset failed to
--   compile.
type CompileError = ByteString

-- | A collection of preprocessors. This can store many preprocessors which
--   produce files with the same extension, but may not store more than one
--   preprocessor which consumes files of a particular extension.
newtype PPs
PPs :: Map Text PP -> PPs
unPPs :: PPs -> Map Text PP
emptyPPs :: PPs

-- | Given a file extension, find the preprocessor (if any) which consumes
--   it.
lookupPP :: Text -> PPs -> Maybe PP

-- | Inserts a preprocessor into a PPs. If a preprocessor already exists
--   with the given extension, it is discarded.
insertPP :: PP -> PPs -> PPs

-- | Turn a list of PPs into a proper <a>PPs</a>.
fromList :: [PP] -> PPs

-- | A BuildSpec specifies how an asset should be built.
data BuildSpec
BuildSpec :: FilePath -> FilePath -> (Maybe PP) -> BuildSpec

-- | Source path (relative)
bsSourcePath :: BuildSpec -> FilePath

-- | Destination path (again, relative)
bsDestPath :: BuildSpec -> FilePath

-- | Preprocessor to run (if any)
bsPP :: BuildSpec -> (Maybe PP)

-- | A BuildMapping contains the information to build all of the assets
--   Herringbone is aware of.
type BuildMapping = [BuildSpec]

-- | The 'main' datatype in this library. All of the important functions
--   will take a <a>Herringbone</a> as their first argument.
data Herringbone
Herringbone :: HerringboneSettings -> UTCTime -> Herringbone
herringboneSettings :: Herringbone -> HerringboneSettings
herringboneStartTime :: Herringbone -> UTCTime

-- | Contains configuration.
data HerringboneSettings
HerringboneSettings :: FilePath -> FilePath -> PPs -> Bool -> HerringboneSettings

-- | The directory to take asset sources from.
settingsSourceDir :: HerringboneSettings -> FilePath

-- | Where to copy assets to after they've been compiled.
settingsDestDir :: HerringboneSettings -> FilePath

-- | Preprocessors
settingsPPs :: HerringboneSettings -> PPs

-- | Dump debugging data to stdout on every request.
settingsVerbose :: HerringboneSettings -> Bool
type ConfigBuilder = HerringboneSettings -> HerringboneSettings

-- | The directory where Herringbone will look when searching for assets.
hbSourceDir :: Herringbone -> FilePath

-- | The directory to place assets in after compilation.
hbDestDir :: Herringbone -> FilePath

-- | The collection of preprocessors that will be used when preprocessing
--   assets.
hbPPs :: Herringbone -> PPs

-- | True iff the <a>Herringbone</a> has the verbose setting enabled.
hbVerbose :: Herringbone -> Bool

-- | Log a message to stdout if hbVerbose is enabled.
verbosePut :: Herringbone -> String -> IO ()

-- | All assets in Herringbone are referenced by their logical path. This
--   is the path to an asset, relative to the source directory.
newtype LogicalPath
LogicalPath :: [Text] -> LogicalPath
fromLogicalPath :: LogicalPath -> [Text]

-- | Create a LogicalPath from a list of path segments. For example,
--   <tt>["data", "dogs.txt"]</tt> would map to data/dogs.txt (relative to
--   the source directory). This returns Nothing if the path would be
--   unsafe (that is, if it contains ".."), to prevent directory traversal
--   attacks.
makeLogicalPath :: [Text] -> Maybe LogicalPath

-- | Create a LogicalPath without checking any of the values.
unsafeMakeLogicalPath :: [Text] -> LogicalPath
toFilePath :: LogicalPath -> FilePath

-- | A preprocessed asset. Any function that returns this will already have
--   done the preprocessing (if necessary).
data Asset
Asset :: Integer -> FilePath -> FilePath -> UTCTime -> Asset

-- | Size of the asset in bytes.
assetSize :: Asset -> Integer

-- | Path to the asset's source file on disk.
assetSourcePath :: Asset -> FilePath

-- | Path to the preprocessed asset on disk. Note that assets which do not
--   require preprocessing will still be copied to the destination
--   directory.
assetFilePath :: Asset -> FilePath

-- | Modification time of the asset's source file.
assetModifiedTime :: Asset -> UTCTime
assetContent :: Asset -> IO ByteString
instance Show AssetError
instance Eq AssetError
instance Show HerringboneSettings
instance Show PPs
instance Functor PPM
instance Applicative PPM
instance Monad PPM
instance MonadIO PPM
instance MonadReader PPReader PPM
instance Show BuildSpec
instance Show LogicalPath
instance Eq LogicalPath
instance Show Asset
instance Show PP


-- | This module deals with locating assets on the disk, and determining
--   which assets needs preprocessing.
--   
--   In development mode: * At startup, build a mapping of source files to
--   destination files together with any preprocessors that should be run
--   on them (based on extension) * watch for filesystem changes, and
--   rebuild relevant parts of this mapping when necessary * listen for
--   HTTP requests and serve relevant files, performing preprocessing where
--   necessary. (well, eventually do all that. For now just rebuild the
--   BuildMapping for each request).
--   
--   In production mode: * build the mapping * preprocess all the files and
--   output them to a particular directory.
--   
--   This architecture should ensure that the file mapping is identical in
--   each mode.
module Web.Herringbone.Internal.GetBuildMapping
getBuildMapping :: Herringbone -> IO BuildMapping

-- | Given a FilePath of a source file, construct a BuildSpec for the file.
getBuildSpec :: Herringbone -> FilePath -> BuildSpec

-- | Make the destination path of a BuildSpec absolute, using the
--   destination directory of the given Herringbone.
makeDestAbsolute :: Herringbone -> BuildSpec -> IO BuildSpec
swapExtension :: PP -> FilePath -> Maybe FilePath
swapExtension' :: Text -> Text -> FilePath -> Maybe FilePath

-- | Search for a file in a list of search paths. For example, if
--   <tt>assets/test.txt</tt> exists, then <tt>searchForFile
--   [<a>assets</a>, <a>other_assets</a>] <a>test.txt</a></tt> will return
--   <tt>Just <a>assets/text.txt</a></tt>
searchForFile :: [FilePath] -> FilePath -> IO (Maybe FilePath)


-- | This module contains functions to build assets (that is, run
--   preprocessing if necessary, and copy to destination directory).
module Web.Herringbone.Internal.BuildAsset

-- | Build an asset based on a BuildSpec to produce a <a>Asset</a>. This
--   action checks whether the compilation is necessary based on the
--   modified times of the source and destination files.
buildAsset :: Herringbone -> BuildSpec -> IO (Either AssetError Asset)
buildAsset' :: Herringbone -> BuildSpec -> IO (Either CompileError Asset)

-- | Should we compile an asset? True if either the asset doesn't exist, or
--   if its modified time is older than the supplied source modification
--   time.
shouldCompile :: Herringbone -> UTCTime -> FilePath -> IO Bool

-- | Compile the given asset by invoking any preprocessors on the source
--   path, and copying the result to the destination path.
compileAsset :: Herringbone -> FilePath -> FilePath -> [PP] -> IO (Either CompileError ())
chainEither :: Monad m => [a -> m (Either b a)] -> a -> m (Either b a)

module Web.Herringbone.Internal.FindAsset

-- | The most important function in this library. Attempts to find the
--   asset referenced by the given <a>LogicalPath</a>, compiles it if
--   necessary (based on file modification time), and returns it to you as
--   an <a>Asset</a> (or an <a>AssetError</a>, if something went wrong).
findAsset :: Herringbone -> LogicalPath -> IO (Either AssetError Asset)
findAssetWithMapping :: Herringbone -> LogicalPath -> BuildMapping -> IO (Either AssetError Asset)

module Web.Herringbone.Internal.Precompile

-- | Precompiles all assets, returning a list of the logical paths of
--   assets that failed to compile (if any) together with <a>AssetError</a>
--   values describing what went wrong.
precompile :: Herringbone -> IO [(LogicalPath, AssetError)]

module Web.Herringbone.Internal.Configuration

-- | For convenience.
herringbone :: ConfigBuilder -> IO Herringbone

-- | Creates a <a>HerringboneSettings</a> instance from a
--   <a>ConfigBuilder</a>. This just applies the config builder to the
--   default settings:
--   
--   <pre>
--   makeSettings builder = builder defaultSettings
--   </pre>
makeSettings :: ConfigBuilder -> HerringboneSettings

-- | Sets up internal state, and returns a Herringbone, ready to be used.
initHerringbone :: HerringboneSettings -> IO Herringbone

-- | Adds a directory to the list of source directories.
setSourceDir :: FilePath -> ConfigBuilder

-- | Sets the destination directory. Note that this will overwrite the
--   destination directory if one is already set.
setDestDir :: FilePath -> ConfigBuilder

-- | Set the preprocessor collection to the given list of preprocessors
setPreprocessors :: [PP] -> ConfigBuilder

-- | Add a preprocessor to the <a>HerringboneSettings</a>
addPreprocessor :: PP -> ConfigBuilder

-- | Displays detailed log information during requests. Useful for
--   debugging.
setVerbose :: ConfigBuilder
defaultSettings :: HerringboneSettings


-- | herringbone is a Haskell library for compiling and serving web assets.
--   It aims to make it dead simple to create a <a>Middleware</a> or
--   <a>Application</a> which deals with all of your static assets,
--   including preprocessing for languages like Fay, CoffeeScript, Sass,
--   and LESS.
--   
--   It takes most of its inspiration from the Ruby library,
--   <a>Sprockets</a>, hence the name.
--   
--   Example:
--   
--   <pre>
--   import Web.Herringbone
--   
--   fay, sass :: PP
--   
--   hb = Herringbone
--   hb = herringbone
--       ( addSourceDir "assets"
--       . setDestDir   "compiled_assets"
--       . addPreprocessors [fay, sass]
--       )
--   
--   -- You can now access assets programmatically
--   asset &lt;- findAsset hb (fromJust . makeLogicalPath $ ["application.js"])
--   
--   -- Or serve them with a Wai application
--   app = toApplication hb
--   </pre>
module Web.Herringbone

-- | The 'main' datatype in this library. All of the important functions
--   will take a <a>Herringbone</a> as their first argument.
data Herringbone

-- | The directory where Herringbone will look when searching for assets.
hbSourceDir :: Herringbone -> FilePath

-- | The directory to place assets in after compilation.
hbDestDir :: Herringbone -> FilePath

-- | The collection of preprocessors that will be used when preprocessing
--   assets.
hbPPs :: Herringbone -> PPs

-- | True iff the <a>Herringbone</a> has the verbose setting enabled.
hbVerbose :: Herringbone -> Bool

-- | Contains configuration.
data HerringboneSettings
HerringboneSettings :: FilePath -> FilePath -> PPs -> Bool -> HerringboneSettings

-- | The directory to take asset sources from.
settingsSourceDir :: HerringboneSettings -> FilePath

-- | Where to copy assets to after they've been compiled.
settingsDestDir :: HerringboneSettings -> FilePath

-- | Preprocessors
settingsPPs :: HerringboneSettings -> PPs

-- | Dump debugging data to stdout on every request.
settingsVerbose :: HerringboneSettings -> Bool

-- | All assets in Herringbone are referenced by their logical path. This
--   is the path to an asset, relative to the source directory.
data LogicalPath

-- | Create a LogicalPath from a list of path segments. For example,
--   <tt>["data", "dogs.txt"]</tt> would map to data/dogs.txt (relative to
--   the source directory). This returns Nothing if the path would be
--   unsafe (that is, if it contains ".."), to prevent directory traversal
--   attacks.
makeLogicalPath :: [Text] -> Maybe LogicalPath

-- | Create a LogicalPath without checking any of the values.
unsafeMakeLogicalPath :: [Text] -> LogicalPath
fromLogicalPath :: LogicalPath -> [Text]
toFilePath :: LogicalPath -> FilePath

-- | A preprocessed asset. Any function that returns this will already have
--   done the preprocessing (if necessary).
data Asset
Asset :: Integer -> FilePath -> FilePath -> UTCTime -> Asset

-- | Size of the asset in bytes.
assetSize :: Asset -> Integer

-- | Path to the asset's source file on disk.
assetSourcePath :: Asset -> FilePath

-- | Path to the preprocessed asset on disk. Note that assets which do not
--   require preprocessing will still be copied to the destination
--   directory.
assetFilePath :: Asset -> FilePath

-- | Modification time of the asset's source file.
assetModifiedTime :: Asset -> UTCTime
assetContent :: Asset -> IO ByteString

-- | The most important function in this library. Attempts to find the
--   asset referenced by the given <a>LogicalPath</a>, compiles it if
--   necessary (based on file modification time), and returns it to you as
--   an <a>Asset</a> (or an <a>AssetError</a>, if something went wrong).
findAsset :: Herringbone -> LogicalPath -> IO (Either AssetError Asset)

-- | Precompiles all assets, returning a list of the logical paths of
--   assets that failed to compile (if any) together with <a>AssetError</a>
--   values describing what went wrong.
precompile :: Herringbone -> IO [(LogicalPath, AssetError)]

-- | A preprocessor something which is run on the asset before it is
--   served. Preprocessors are run when a file matches its rule. For
--   example, if you have a preprocessor which takes "coffee" files and
--   emits "js" files, there is a file named "application.coffee", and you
--   request "application.js", Herringbone will run the coffee preprocessor
--   on "application.coffee" and serve you the result.
data PP
PP :: Text -> Text -> Text -> PPAction -> PP

-- | Identifies a preprocessor. Mainly useful for debugging compile errors.
ppName :: PP -> Text

-- | Extension for files this preprocessor consumes.
ppConsumes :: PP -> Text

-- | Extension for files this preprocessor produces.
ppProduces :: PP -> Text

-- | Performs the compilation.
ppAction :: PP -> PPAction

-- | A collection of preprocessors. This can store many preprocessors which
--   produce files with the same extension, but may not store more than one
--   preprocessor which consumes files of a particular extension.
data PPs

-- | A value describing an error that occurred while trying to produce an
--   <a>Asset</a>.
data AssetError
AssetNotFound :: AssetError
AssetCompileError :: CompileError -> AssetError
AmbiguousSources :: [FilePath] -> AssetError

-- | A string which should contain information about why an asset failed to
--   compile.
type CompileError = ByteString

-- | Data which is given to preprocessors on the off-chance that they need
--   it (eg, Fay)
data PPReader
PPReader :: Herringbone -> FilePath -> [PP] -> PPReader

-- | The Herringbone which was used to build the asset
ppReaderHb :: PPReader -> Herringbone

-- | The file path to the source file
ppReaderSourcePath :: PPReader -> FilePath

-- | Preprocessors being invoked. Currently this will only ever have zero
--   or one elements; in the future, Herringbone may be able to run
--   multiple preprocessors on a single file.
ppReaderPPs :: PPReader -> [PP]

-- | A monad in which preprocessor actions happen.
data PPM a

module Web.Herringbone.Preprocessor.StdIO

-- | Make a preprocessor which works over standard IO; reading input from
--   stdin, and writing output to stdout.
makeStdIOPP :: Text -> Text -> Text -> String -> [String] -> PP

module Web.Herringbone.Preprocessor.Sass

-- | A preprocessor for the sass mode of Sass.
sass :: PP

-- | A preprocessor for the scss mode of Sass.
scss :: PP

module Web.Herringbone.Preprocessor.CoffeeScript
coffeeScript :: PP
