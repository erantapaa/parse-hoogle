-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | polynomial function enclosures (PFEs) approximating exact real functions
--   
--   AERN-RnToRm provides datatypes and abstractions for approximating
--   functions of type <tt>D -&gt; R^m</tt> where <tt>D</tt> is a bounded
--   interval in <tt>R^n</tt> with non-empty interior.
--   
--   The main datatype are function enclosures whose boundaries are
--   piece-wise polynomial with a bounded degree. (This degree can be set
--   arbitrarily high or as low as 0.) This datatype is supported by safely
--   rounding operations whose precision can be increased arbitrarily, so
--   that they all converge to the exact operations. Field operations,
--   integration, maximisation and some elementary operations (namely exp,
--   sin, cos) are among those already implemented.
--   
--   For an architectural overview, see module
--   <a>Data.Number.ER.RnToRm</a>.
--   
--   A mathematical description of the very basics as well as a brief
--   comparison with Taylor Models is included in the paper
--   <a>http://www-users.aston.ac.uk/~konecnym/papers/cfv08.html</a>.
--   
--   Simple examples of usage can be found in folder <tt>examples</tt> and
--   a test suite can be run via the module in the folder <tt>tests</tt>.
@package AERN-RnToRm
@version 0.5.0.1


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Definition of the polynomial datatype and simple related functions.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Basic

-- | A polynomial represented by its coefficients it the Chebyshev basis.
--   
--   The polynomials are never to be used outside the domain
--   <tt>[-1,1]^n</tt>.
--   
--   All operations are rounded in such a way that the resulting polynomial
--   is a <i>point-wise upper or lower bound</i> of the exact result.
data ERChebPoly box b
ERChebPoly :: (Map (TermKey box) b) -> ERChebPoly box b
chplCoeffs :: ERChebPoly box b -> (Map (TermKey box) b)
type TermKey box = box
chplConstTermKey :: (DomainBox box varid d) => box
chplIsConstTermKey :: (DomainBox box varid d) => box -> Bool
chplTermOrder :: (DomainBox box varid d, Num d) => box -> d
chplTermArity :: (DomainBox box varid d) => box -> Int

-- | Inspect all terms of the polynomial and return the degree of the
--   highest degree term.
chplGetDegree :: (ERRealBase b, DomainBox box varid d, Num d, Ord d) => (ERChebPoly box b) -> d

-- | If the polynomial is constant, return the constant, otherwise return
--   Nothing.
chplGetConst :: (ERRealBase b, DomainBox box varid d, Num d, Ord d) => (ERChebPoly box b) -> Maybe b
chplConst :: (ERRealBase b, DomainBox box varid Int, Ord box) => b -> ERChebPoly box b

-- | Make a basic <a>x</a> polynomial for a given variable number.
chplVar :: (ERRealBase b, DomainBox box varid Int, Ord box) => varid -> ERChebPoly box b

-- | Construct an affine polynomial.
chplAffine :: (ERRealBase b, DomainBox box varid Int, Ord box) => b -> Map varid b -> ERChebPoly box b
chplRemoveZeroTermsUp :: (ERRealBase b, DomainBox box varid Int, Ord box) => ERChebPoly box b -> ERChebPoly box b
chplCountTerms :: (ERRealBase b, DomainBox box varid Int, Ord box) => ERChebPoly box b -> Int

-- | Convert a polynomial to a string representation, using the ordinary
--   x^n basis.
chplShow :: (ERRealBase b, DomainBox box varid Int, Ord box) => Int -> Bool -> Bool -> ERChebPoly box b -> String

-- | conversion of polynomials from Chebyshev basis to the X^n basis
--   
--   (not exact - suffering from rounding in the coefficient conversions)
chebToXBasis :: (ERRealBase b, DomainBox box varid Int, Ord box) => (Map (TermKey box) b) -> (Map (TermKey box) b)

-- | conversion of one Chebyshev term to the X^n basis
termXterms :: (DomainBox box varid Int, Ord box) => TermKey box -> Map (TermKey box) Integer

-- | Chebyshev polynomials expressed as associative lists power -&gt; coeff
chebyXCoeffsLists :: (Num d1, Enum d1, Num d2, Enum d2) => [[(d1, d2)]]

-- | Chebyshev polynomials expressed as lists of integer coefficients for
--   powers 0,1,2...
chebyXCoeffs :: (Num d, Enum d) => [[d]]
instance Typeable2 ERChebPoly
instance (Eq box, Eq b) => Eq (ERChebPoly box b)
instance (Ord box, Ord b) => Ord (ERChebPoly box b)
instance (Data box, Data b, Ord box) => Data (ERChebPoly box b)
instance (ERRealBase b, DomainBox box varid Int, Ord box) => Show (ERChebPoly box b)
instance (Ord a, Binary a, Binary b) => Binary (ERChebPoly a b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of various evaluation functions related to polynomials.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Eval

-- | Evaluate a polynomial at a point, consistently rounding upwards and
--   downwards.
chplEval :: (ERRealBase b, DomainBox box varid Int, Ord box, DomainBoxMappable boxb boxbb varid b [ERInterval b]) => ERChebPoly box b -> boxb -> (b, b)
chplEvalUp :: (ERRealBase b, DomainBox box varid Int, Ord box, DomainBoxMappable boxb boxbb varid b [ERInterval b]) => ERChebPoly box b -> boxb -> b
chplEvalDown :: (ERRealBase b, DomainBox box varid Int, Ord box, DomainBoxMappable boxb boxbb varid b [ERInterval b]) => ERChebPoly box b -> boxb -> b
chebyEvalTsExact :: (Num v) => v -> [v]

-- | Evaluate a polynomial at a real number approximation
chplRAEval :: (ERRealBase b, ERApprox ra, DomainBox box varid Int, Ord box, DomainBoxMappable boxra boxras varid ra [ra], DomainIntBox boxra varid ra) => (b -> ra) -> ERChebPoly box b -> boxra -> ra

-- | Substitute several variables in a polynomial with real number
--   approximations, rounding downwards and upwards.
chplPartialRAEval :: (ERRealBase b, ERApprox ra, DomainBox box varid Int, Ord box, DomainBoxMappable boxra boxras varid ra [ra], DomainIntBox boxra varid ra) => (ra -> (b, b)) -> ERChebPoly box b -> boxra -> (ERChebPoly box b, ERChebPoly box b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of field arithmetic over polynomials with pointwise
--   rounding uniform over the whole unit domain.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Reduce
chplReduceTermCount :: (ERRealBase b, DomainBox box varid Int, Ord box) => Int -> ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b)

-- | Convert a polynomial to a lower-order one that is dominated by (resp.
--   dominates) it closely on the domain [-1,1].
chplReduceDegree :: (ERRealBase b, DomainBox box varid Int, Ord box) => Int -> ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of addition and multiplication over polynomials with
--   pointwise rounding uniform over the whole unit domain.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Ring

-- | Negate a polynomial exactly.
chplBall2DownUp :: (ERRealBase b, DomainBox box varid Int, Ord box) => (ERChebPoly box b, b) -> (ERChebPoly box b, ERChebPoly box b)
chplBall2DownUpWd :: (ERRealBase b, DomainBox box varid Int, Ord box) => (ERChebPoly box b, b) -> (ERChebPoly box b, ERChebPoly box b, b)
chplBall2Down :: (ERRealBase b, DomainBox box varid Int, Ord box) => (ERChebPoly box b, b) -> (ERChebPoly box b)
chplBall2Up :: (ERRealBase b, DomainBox box varid Int, Ord box) => (ERChebPoly box b, b) -> (ERChebPoly box b)

-- | Add a constant to a polynomial, rounding downwards and upwards.
ballAddConst :: (ERRealBase b, DomainBox box varid Int, Ord box) => b -> (ERChebPoly box b) -> (ERChebPoly box b, b)

-- | Add two polynomials, rounding downwards and upwards.
ballAdd :: (ERRealBase b, DomainBox box varid Int, Ord box) => (ERChebPoly box b) -> (ERChebPoly box b) -> (ERChebPoly box b, b)

-- | Multiply two polynomials, rounding downwards and upwards.
ballMultiply :: (ERRealBase b, DomainBox box varid Int, Ord box) => ERChebPoly box b -> ERChebPoly box b -> (ERChebPoly box b, b)

-- | Multiply a polynomial by a scalar rounding downwards and upwards.
ballScale :: (ERRealBase b, DomainBox box varid Int, Ord box) => b -> (ERChebPoly box b) -> (ERChebPoly box b, b)

-- | Multiply a polynomial by itself, rounding downwards and upwards.
ballSquare :: (ERRealBase b, DomainBox box varid Int, Ord box) => ERChebPoly box b -> (ERChebPoly box b, b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of safely rounded derivative of polynomials.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Derivative

-- | Differentiate a polynomial using one of its variables.
chplDifferentiate :: (ERRealBase b, DomainBox box varid Int, Ord box) => ERChebPoly box b -> varid -> (ERChebPoly box b, ERChebPoly box b)

-- | Differentiate a polynomial using one of its variables.
ballDifferentiate :: (ERRealBase b, DomainBox box varid Int, Ord box) => ERChebPoly box b -> varid -> (ERChebPoly box b, b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of various functions related to the bounds of
--   polynomials.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Bounds

-- | Find an upper bound on a polynomial over the unit domain [-1,1]^n.
--   
--   Quick method that does not converge to exact result with increasing
--   effort index.
chplUpperBound :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => EffortIndex -> ERChebPoly box b -> b

-- | Find a lower bound on a polynomial over the unit domain [-1,1]^n.
--   
--   Quick method that does not converge to exact result with increasing
--   effort index.
chplLowerBound :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => EffortIndex -> ERChebPoly box b -> b

-- | Find both lower and upper bounds on a polynomial over the unit domain
--   [-1,1]^n.
--   
--   Quick method that does not converge to exact result with increasing
--   effort index.
chplBounds :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => EffortIndex -> ERChebPoly box b -> (b, b)

-- | Find an upper bound on a polynomial over the unit domain [-1,1]^n.
chplUpperBoundExpensive :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => EffortIndex -> ERChebPoly box b -> b

-- | Find a lower bound on a polynomial over the unit domain [-1,1]^n.
--   
--   Quick method that does not converge to exact result with increasing
--   effort index.
chplLowerBoundExpensive :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => EffortIndex -> ERChebPoly box b -> b

-- | Find both lower and upper bounds on a polynomial over the unit domain
--   [-1,1]^n.
--   
--   Quick method that does not converge to exact result with increasing
--   effort index.
chplBoundsExpensive :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => EffortIndex -> ERChebPoly box b -> (b, b)

-- | Find bounds on a polynomial over the unit domain [-1,1]^n.
--   
--   Fast but inaccurate method, in essence taking the maximum of the upper
--   affine reduction.
chplBoundsAffine :: (ERRealBase b, DomainBox box varid Int, Ord box) => EffortIndex -> ERChebPoly box b -> (b, b)

-- | Find a close upper bound of a polynomial over the unit domain
--   [-1,1]^n.
--   
--   Approximates all local extrema and computes their maximum.
chplBoundsByDerivative :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => EffortIndex -> ERChebPoly box b -> (b, b)

-- | Approximate from below and from above the pointwise maximum of two
--   polynomials
chplMax :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ERChebPoly box b -> ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b)

-- | Approximate from below and from above the pointwise minimum of two
--   polynomials
chplMin :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ERChebPoly box b -> ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b)

-- | Approximate the function max(0,p(x)) by a polynomial from below and
--   from above.
chplNonneg :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b)

-- | A version of <a>chplNonneg</a> using a cubic approximation.
chplNonnegCubic :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b)

-- | Multiply a polynomial by an enclosure (with non-negated lower bound).
chplTimesLoHi :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b, b) -> (ERChebPoly box b, ERChebPoly box b, b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of selected operations working on pairs of polynomials
--   understood as function enclosures. These are needed to define
--   composition and some elementary operations.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Enclosure
enclThin :: (ERRealBase b, DomainBox box varid Int, Ord box) => ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b)
enclConst :: (ERRealBase b, DomainBox box varid Int, Ord box) => b -> (ERChebPoly box b, ERChebPoly box b)
enclRAConst :: (ERRealBase b, DomainBox box varid Int, Ord box) => (ERInterval b) -> (ERChebPoly box b, ERChebPoly box b)
enclAdd :: (ERRealBase b, DomainBox box varid Int, Ord box) => Int -> Int -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)
enclMultiply :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)
enclSquare :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)

-- | Multiply an enclosure by a scalar assuming the enclosure is
--   non-negative on the whole unit domain.
enclScaleNonneg :: (ERRealBase b, DomainBox box varid Int, Ord box) => b -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)

-- | Multiply an enclosure by a scalar.
enclScale :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> b -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)
enclRAScale :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> (ERInterval b) -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)

-- | Multiply a polynomial by a scalar interval, returning an enclosure.
chplScaleRA :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ERInterval b -> ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b)

-- | Evaluate the Chebyshev polynomials of the first kind applied to a
--   given polynomial, yielding a list of polynomial enclosures.
enclEvalTs :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> (ERChebPoly box b, ERChebPoly box b) -> [(ERChebPoly box b, ERChebPoly box b)]

-- | Multiply a polynomial by an enclosure using min/max
enclThinTimes :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of selected operations working on pairs of polynomials
--   understood as *inner approximations* of function enclosures. These are
--   needed to define full Kaucher arithmetic.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.EnclosureInner
ienclThin :: (ERRealBase b, DomainBox box varid Int, Ord box) => ERChebPoly box b -> ((ERChebPoly box b, ERChebPoly box b), Bool)
ienclConst :: (ERRealBase b, DomainBox box varid Int, Ord box) => b -> ((ERChebPoly box b, ERChebPoly box b), Bool)
ienclRAConst :: (ERRealBase b, DomainBox box varid Int, Ord box) => (ERInterval b) -> ((ERChebPoly box b, ERChebPoly box b), Bool)
ienclAdd :: (ERRealBase b, DomainBox box varid Int, Ord box) => Int -> Int -> ((ERChebPoly box b, ERChebPoly box b), Bool) -> ((ERChebPoly box b, ERChebPoly box b), Bool) -> ((ERChebPoly box b, ERChebPoly box b), Bool)
ienclMultiply :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ((ERChebPoly box b, ERChebPoly box b), Bool) -> ((ERChebPoly box b, ERChebPoly box b), Bool) -> ((ERChebPoly box b, ERChebPoly box b), Bool)
ienclSquare :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ((ERChebPoly box b, ERChebPoly box b), Bool) -> ((ERChebPoly box b, ERChebPoly box b), Bool)

-- | Multiply an enclosure by a scalar assuming the enclosure is
--   non-negative on the whole unit domain.
ienclScaleNonneg :: (ERRealBase b, DomainBox box varid Int, Ord box) => b -> ((ERChebPoly box b, ERChebPoly box b), Bool) -> ((ERChebPoly box b, ERChebPoly box b), Bool)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of pointwise consistently rounded polynomial
--   composition.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Compose

-- | Compose a polynomial and an enclosure, producing a correcly rounded
--   enclosure, assuming the second polynomial maps [-1,1] into [-1,1].
enclCompose :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ERChebPoly box b -> varid -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)

-- | Compose two polynomials, rounding upwards provided the second
--   polynomial maps [-1,1] into [-1,1].
enclComposeMany :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> ERChebPoly box b -> Map varid (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of safely rounded integration of polynomials and other
--   related functions.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Integration

-- | Approximate from below and from above the integral of a polynomial.
--   
--   Based on the following formulas for Chebyshev polynomials:
--   
--   <pre>
--   \int T_n(x)dx = 
--      T_{n+1}(x)/2(n+1) - T_{n-1}(x)/2(n-1)
--   </pre>
--   
--   <pre>
--   \int T_1(x)dx = 
--      T_2(x)/4 + 1/4
--   </pre>
--   
--   <pre>
--   \int T_0(x)dx = 
--      T_1(x)
--   </pre>
chplIntegrate :: (ERRealBase b, DomainBox box varid Int, Ord box) => varid -> ERChebPoly box b -> (ERChebPoly box b, ERChebPoly box b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of division applied to basic polynomial enclosures.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Division

-- | Approximate the pointwise reciprocal of a polynomial by another
--   polynomial from below and from above using the tau method as described
--   in [Mason &amp; Handscomb 2003, p 62].
enclRecip :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> EffortIndex -> Int -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of inner-rounded division applied to basic polynomial
--   enclosures.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.DivisionInner

-- | Approximate the pointwise reciprocal of a positive polynomial by
--   another polynomial from below and from above using the tau method as
--   described in [Mason &amp; Handscomb 2003, p 62].
ienclRecipPositive :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> EffortIndex -> Int -> ((ERChebPoly box b, ERChebPoly box b), Bool) -> ((ERChebPoly box b, ERChebPoly box b), Bool)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of elementary functions applied to polynomials.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.Elementary

-- | Approximate the pointwise square root of a polynomial enclosure.
enclSqrt :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> EffortIndex -> Int -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)

-- | Approximate the pointwise exponential of a polynomial enclosure.
enclExp :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> EffortIndex -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)

-- | Approximate the pointwise integer power of an enclosure.
enclPow :: (Integral i, ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> (ERChebPoly box b, ERChebPoly box b) -> i -> (ERChebPoly box b, ERChebPoly box b)

-- | Approximate the pointwise natural logarithm of an enclosure.
enclLog :: (ERRealBase b, DomainBox box varid Int, Ord box) => Int -> Int -> EffortIndex -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)

-- | Approximate the pointwise sine of an enclosure.
--   
--   Assuming the polynomial range is [-pi<i>2, pi</i>2].
enclSine :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> EffortIndex -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)

-- | Approximate the pointwise cosine of an enclosure.
--   
--   Assuming the polynomial range is [-pi<i>2, pi</i>2].
enclCosine :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> EffortIndex -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)
sincosTaylorAux :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> Bool -> (ERChebPoly box b, ERChebPoly box b) -> Int -> Int -> ERInterval b -> ((ERChebPoly box b, ERChebPoly box b), Int, ERInterval b)

-- | Approximate the pointwise arcus tangens of an enclosure.
enclAtan :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> EffortIndex -> (ERChebPoly box b, ERChebPoly box b) -> (ERChebPoly box b, ERChebPoly box b)


-- | Internal module for
--   <a>Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom</a>.
--   
--   Implementation of inner-rounded elementary functions applied to
--   polynomials.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom.ElementaryInner
ienclSqrt :: (ERRealBase b, DomainBox box varid Int, Ord box, Show varid, DomainIntBox boxra varid (ERInterval b), DomainBoxMappable boxra boxras varid (ERInterval b) [ERInterval b]) => Int -> Int -> EffortIndex -> Int -> ((ERChebPoly box b, ERChebPoly box b), Bool) -> ((ERChebPoly box b, ERChebPoly box b), Bool)


-- | Defines a representation for recursive bisections of <tt>R^n</tt> by
--   hyperplanes, each of which is perpendicular to a base axis.
--   
--   Arbitrary data can be associated with the sections of a partition.
--   
--   To be imported qualified, usually with prefix BISTR.
module Data.Number.ER.RnToRm.BisectionTree

-- | <ul>
--   <li>The root of the tree often represents the whole <tt>R^n</tt>.</li>
--   <li>Each node splits the parent's space into two using a specified
--   variable (ie direction) and an optional splitting point.</li>
--   <li>By default, a split is taken at the point defined by the method
--   <tt>RA.bisect</tt>.</li>
--   </ul>
data BisectionTree box varid d v
Leaf :: Depth -> box -> v -> BisectionTree box varid d v
bistrDepth :: BisectionTree box varid d v -> Depth

-- | domain
bistrDom :: BisectionTree box varid d v -> box

-- | value estimate
bistrVal :: BisectionTree box varid d v -> v
Node :: Depth -> box -> varid -> d -> BisectionTree box varid d v -> BisectionTree box varid d v -> BisectionTree box varid d v
bistrDepth :: BisectionTree box varid d v -> Depth

-- | domain
bistrDom :: BisectionTree box varid d v -> box

-- | direction to split in
bistrDir :: BisectionTree box varid d v -> varid

-- | point that the split is at
bistrPt :: BisectionTree box varid d v -> d

-- | the half towards -Infty in split dir
bistrLO :: BisectionTree box varid d v -> BisectionTree box varid d v

-- | the half towards +Infty in split dir
bistrHI :: BisectionTree box varid d v -> BisectionTree box varid d v
type Depth = Int

-- | value splitter function - parameters are: depth, domain of value,
--   value, variable to split by, point to split at; returns the two split
--   values
type ValueSplitter box varid d v = EffortIndex -> Depth -> box -> v -> varid -> d -> (v, v)
type ValueCombiner box varid d v = EffortIndex -> Depth -> (BisectionTree box varid d v) -> v
isLeaf :: BisectionTree box varid d v -> Bool
const :: box -> v -> BisectionTree box varid d v
removeVars :: (ERIntApprox d, DomainIntBox box varid d, DomainBoxMappable box box varid d d) => box -> BisectionTree box varid d v -> BisectionTree box varid d v

-- | Ensure both trees have equal structure at the top level: either they
--   are all leaves or they all split at the same direction with the same
--   splitting point.
--   
--   Also, unify the domains at the top level.
sync2 :: (ERIntApprox d, DomainIntBox box varid d) => ValueSplitter box varid d v1 -> ValueSplitter box varid d v2 -> EffortIndex -> BisectionTree box varid d v1 -> BisectionTree box varid d v2 -> (BisectionTree box varid d v1, BisectionTree box varid d v2)

-- | Ensure all the trees have equal structure at the top level: either
--   they are all leaves or they all split at the same direction with the
--   same splitting point.
--   
--   Also, unify the domains at the top level.
syncMany :: (ERIntApprox d, DomainIntBox box varid d) => ValueSplitter box varid d v -> EffortIndex -> [BisectionTree box varid d v] -> [BisectionTree box varid d v]
setDepth :: Depth -> BisectionTree box varid d v -> BisectionTree box varid d v
split :: (ERIntApprox d, DomainBox box varid d) => ValueSplitter box varid d v -> EffortIndex -> varid -> d -> box -> BisectionTree box varid d v -> BisectionTree box varid d v

-- | Apply a function to all values, thus creating a new tree.
mapWithDom :: (DomainBox box varid d) => (box -> v1 -> v2) -> BisectionTree box varid d v1 -> BisectionTree box varid d v2

-- | Apply a function to all values, thus creating a new tree.
mapLeaves :: (BisectionTree box varid d v1 -> BisectionTree box varid d v2) -> BisectionTree box varid d v1 -> BisectionTree box varid d v2

-- | Perform a given action on all branches of a bisection tree, left to
--   right. (optionally now going below the given depth)
doBistr :: (box -> v -> IO ()) -> Maybe Int -> BisectionTree box varid d v -> IO ()

-- | Perform a given action on all branches of a bisection tree, left to
--   right. (optionally now going below the given depth)
doMap :: (Depth -> box -> v -> IO v) -> Maybe Int -> BisectionTree box varid d v -> IO (BisectionTree box varid d v)

-- | Perform a given action on all branches of a bisection tree, left to
--   right with the option of further branching the tree. (optionally now
--   going below the given depth)
doMapLeaves :: (BisectionTree box varid d v -> IO (BisectionTree box varid d v)) -> Maybe Int -> BisectionTree box varid d v -> IO (BisectionTree box varid d v)

-- | Combine two bisection trees using a given value combining function.
--   Where necessary, leaves are split so that the resulting tree's
--   structure is the union of the two argument tree structures. Such
--   splitting of values in leaves is performed by the provided functions.
combineWith :: (ERIntApprox d, DomainIntBox box varid d) => ValueSplitter box varid d v1 -> ValueSplitter box varid d v2 -> (box -> v1 -> v2 -> (Maybe res, aux)) -> EffortIndex -> (BisectionTree box varid d v1) -> (BisectionTree box varid d v2) -> (Maybe (BisectionTree box varid d res), [aux])

-- | return all values in leafs (except those within some CE subtree) as a
--   list (from the leftmost to the rightmost)
collectValues :: BisectionTree box varid b a -> [a]

-- | return all values in leafs (except those within some CE subtree) as a
--   list (from the leftmost to the rightmost)
collectDomValues :: BisectionTree box varid d v -> [(box, v)]

-- | linear ordering on bisection trees
compare :: (Ord varid, DomainBox box varid d) => (d -> d -> Ordering) -> (v -> v -> Ordering) -> (BisectionTree box varid d v) -> (BisectionTree box varid d v) -> Ordering

-- | lookup all maximal subtrees whose domain intersect the given rectangle
lookupSubtreeDoms :: (ERIntApprox d, DomainBox box varid d) => (BisectionTree box varid d v) -> box -> [BisectionTree box varid d v]
instance Typeable4 BisectionTree
instance (Data box, Data varid, Data d, Data v) => Data (BisectionTree box varid d v)
instance (Show d, HTML v, DomainBox box varid d) => HTML (BisectionTree box varid d v)
instance (VariableID varid, Show d, Show v, DomainBox box varid d) => Show (BisectionTree box varid d v)
instance (Binary a, Binary b, Binary c, Binary d) => Binary (BisectionTree a b c d)


-- | To be imported qualified, usually with prefix BTINTEG.
module Data.Number.ER.RnToRm.BisectionTree.Integration

-- | Transform a bunch of bisection trees over the same domain by
--   <a>integrating</a> them in a very abstract sense. The trees are
--   unified in their splitting patterns in the process. By supplying
--   certain parameters, this function can in fact perform numerical
--   integration of piece-wise polynomial functions.
--   
--   It can be also viewed as a <a>zipping+folding</a> operator over
--   bisection trees that generates another bunch of bisection trees,
--   synchronously traversing the original trees from a certain point on a
--   selected axis outwards in both directions, carrying some data along.
zipFromOrigin :: (ERIntApprox d, DomainIntBox box varid d, Show v1, Show v2, Show valPass) => ValueSplitter box varid d v1 -> ValueCombiner box varid d v1 -> EffortIndex -> varid -> d -> (Maybe (box)) -> (Maybe valPass -> Maybe valPass -> [BisectionTree box varid d v1] -> [BisectionTree box varid d v2]) -> (EffortIndex -> Depth -> (box) -> [v1] -> [v2] -> Bool) -> (EffortIndex -> Depth -> (box) -> [v1] -> (valPass, [v2], valPass)) -> (EffortIndex -> Depth -> (box) -> valPass -> [v1] -> ([v2], valPass)) -> (EffortIndex -> Depth -> (box) -> [v1] -> valPass -> (valPass, [v2])) -> [BisectionTree box varid d v1] -> [BisectionTree box varid d v2]

-- | Zip a list of bisection trees in synchrony but do something else
--   inside and not inside a given subdomain.
--   
--   Further splitting at default points will be done up to the given depth
--   in an attempt to separate the subdomain as well as possible.
--   
--   If the subdomain is not properly isolated by the splitting at the
--   maximum depth, splits are made at irregular points to ensure full
--   isolation of the subdomain.
zipOnSubdomain :: (ERIntApprox d, DomainIntBox box varid d) => ValueSplitter box varid d v1 -> EffortIndex -> Depth -> box -> (box -> [v1] -> [v2]) -> (box -> [v1] -> [v2]) -> (box -> [v1] -> [v2]) -> [BisectionTree box varid d v1] -> [BisectionTree box varid d v2]


-- | Classes abstracting function arithmetic with directed rounding.
--   Instances are used to describe a boundary for an approximation to a
--   real function on the interval [-1,1]^n.
--   
--   To be imported qualified, usually with the synonym UFB.
module Data.Number.ER.RnToRm.UnitDom.Base
class (ERRealBase b, ERIntApprox ra, Ord ufb, DomainBox boxb varid b, DomainIntBox boxra varid ra) => ERUnitFnBase boxb boxra varid b ra ufb | ufb -> boxb boxra varid b ra
initialiseBaseArithmetic :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> IO ()
raEndpoints :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> ra -> (b, b)
raFromEndpoints :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> (b, b) -> ra
compareApprox :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> ufb -> Ordering
showDiGrCmp :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Bool -> Bool -> ufb -> String
isValid :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> Bool
check :: (ERUnitFnBase boxb boxra varid b ra ufb) => String -> ufb -> ufb
getGranularity :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> Granularity
setMinGranularity :: (ERUnitFnBase boxb boxra varid b ra ufb) => Granularity -> ufb -> ufb
setGranularity :: (ERUnitFnBase boxb boxra varid b ra ufb) => Granularity -> ufb -> ufb
getDegree :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> Int
reduceDegreeUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> ufb -> ufb
getSize :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> Int
reduceSizeUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> ufb -> ufb
getVariables :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> [varid]
const :: (ERUnitFnBase boxb boxra varid b ra ufb) => b -> ufb
affine :: (ERUnitFnBase boxb boxra varid b ra ufb) => b -> Map varid b -> ufb
bounds :: (ERUnitFnBase boxb boxra varid b ra ufb) => EffortIndex -> ufb -> (b, b)
upperBound :: (ERUnitFnBase boxb boxra varid b ra ufb) => EffortIndex -> ufb -> b
upperBoundPrecise :: (ERUnitFnBase boxb boxra varid b ra ufb) => EffortIndex -> ufb -> b
maxUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ufb -> ufb -> ufb
minUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ufb -> ufb -> ufb
maxDown :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ufb -> ufb -> ufb
minDown :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ufb -> ufb -> ufb
neg :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> ufb
addConstUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => b -> ufb -> ufb
scaleUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => b -> ufb -> ufb
scaleApproxUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ra -> ufb -> ufb
(+^) :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> ufb -> ufb
(-^) :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> ufb -> ufb
(*^) :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> ufb -> ufb
recipUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> ufb -> ufb
evalUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => boxb -> ufb -> b
evalApprox :: (ERUnitFnBase boxb boxra varid b ra ufb) => boxra -> ufb -> ra
partialEvalApproxUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => boxra -> ufb -> ufb
composeUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ufb -> varid -> ufb -> ufb
composeManyUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ufb -> Map varid ufb -> ufb
composeDown :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ufb -> varid -> ufb -> ufb
composeManyDown :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ufb -> Map varid ufb -> ufb
integrate :: (ERUnitFnBase boxb boxra varid b ra ufb) => varid -> ufb -> (ufb, ufb)
differentiate :: (ERUnitFnBase boxb boxra varid b ra ufb) => varid -> ufb -> (ufb, ufb)
volumeAboveZeroUp :: (ERUnitFnBase boxb boxra varid b ra ufb) => [varid] -> ufb -> b
class (ERUnitFnBase boxb boxra varid b ra ufb) => ERUnitFnBaseEncl boxb boxra varid b ra ufb | ufb -> boxb boxra varid b ra
boundsEncl :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => EffortIndex -> (ufb, ufb) -> (b, b)
constEncl :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => (b, b) -> (ufb, ufb)
evalEncl :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => boxra -> (ufb, ufb) -> ra
evalEnclInner :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => boxra -> (ufb, ufb) -> ra
addConstEncl :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => Int -> Int -> b -> (ufb, ufb) -> (ufb, ufb)
scaleEncl :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => Int -> Int -> b -> (ufb, ufb) -> (ufb, ufb)
addEncl :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => Int -> Int -> (ufb, ufb) -> (ufb, ufb) -> (ufb, ufb)
multiplyEncl :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => Int -> Int -> (ufb, ufb) -> (ufb, ufb) -> (ufb, ufb)
recipEncl :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> (ufb, ufb) -> (ufb, ufb)
composeEncl :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => Int -> Int -> ufb -> varid -> (ufb, ufb) -> (ufb, ufb)
composeManyEncls :: (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => Int -> Int -> ufb -> Map varid (ufb, ufb) -> (ufb, ufb)
class (ERUnitFnBaseEncl boxb boxra varid b ra ufb) => ERUnitFnBaseElementary boxb boxra varid b ra ufb | ufb -> boxb boxra varid b ra
sqrtEncl :: (ERUnitFnBaseElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> (ufb, ufb) -> (ufb, ufb)
expEncl :: (ERUnitFnBaseElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> (ufb, ufb) -> (ufb, ufb)
logEncl :: (ERUnitFnBaseElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> (ufb, ufb) -> (ufb, ufb)
sinEncl :: (ERUnitFnBaseElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> (ufb, ufb) -> (ufb, ufb)
cosEncl :: (ERUnitFnBaseElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> (ufb, ufb) -> (ufb, ufb)
atanEncl :: (ERUnitFnBaseElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> (ufb, ufb) -> (ufb, ufb)
class (ERUnitFnBase boxb boxra varid b ra ufb) => ERUnitFnBaseIEncl boxb boxra varid b ra ufb | ufb -> boxb boxra varid b ra
constIEncl :: (ERUnitFnBaseIEncl boxb boxra varid b ra ufb) => (b, b) -> ((ufb, ufb), Bool)
evalIEncl :: (ERUnitFnBaseIEncl boxb boxra varid b ra ufb) => boxra -> ((ufb, ufb), Bool) -> ra
addIEncl :: (ERUnitFnBaseIEncl boxb boxra varid b ra ufb) => Int -> Int -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
multiplyIEncl :: (ERUnitFnBaseIEncl boxb boxra varid b ra ufb) => Int -> Int -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
recipIEnclPositive :: (ERUnitFnBaseIEncl boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
composeIEncl :: (ERUnitFnBaseIEncl boxb boxra varid b ra ufb) => Int -> Int -> ufb -> varid -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
composeManyIEncls :: (ERUnitFnBaseIEncl boxb boxra varid b ra ufb) => Int -> Int -> ufb -> Map varid ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
class (ERUnitFnBaseIEncl boxb boxra varid b ra ufb) => ERUnitFnBaseIElementary boxb boxra varid b ra ufb | ufb -> boxb boxra varid b ra
sqrtIEncl :: (ERUnitFnBaseIElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
expIEncl :: (ERUnitFnBaseIElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
logIEncl :: (ERUnitFnBaseIElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
sinIEncl :: (ERUnitFnBaseIElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
cosIEncl :: (ERUnitFnBaseIElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)
atanIEncl :: (ERUnitFnBaseIElementary boxb boxra varid b ra ufb) => Int -> Int -> EffortIndex -> ((ufb, ufb), Bool) -> ((ufb, ufb), Bool)


-- | Arithmetic of multivariate polynomials represented by their
--   coefficients it the Chebyshev basis.
--   
--   The polynomials are never to be used outside the domain
--   <tt>[-1,1]^n</tt>.
--   
--   All operations are rounded in such a way that the resulting polynomial
--   is a <i>point-wise upper or lower bound</i> of the exact result.
module Data.Number.ER.RnToRm.UnitDom.ChebyshevBase.Polynom

-- | A polynomial represented by its coefficients it the Chebyshev basis.
--   
--   The polynomials are never to be used outside the domain
--   <tt>[-1,1]^n</tt>.
--   
--   All operations are rounded in such a way that the resulting polynomial
--   is a <i>point-wise upper or lower bound</i> of the exact result.
data ERChebPoly box b
ERChebPoly :: (Map (TermKey box) b) -> ERChebPoly box b
chplCoeffs :: ERChebPoly box b -> (Map (TermKey box) b)
type TermKey box = box
instance (ERRealBase rb, RealFrac rb, DomainBox box varid Int, Ord box, Show varid, DomainBoxMappable boxb boxras varid rb [ERInterval rb], DomainBoxMappable boxra boxras varid (ERInterval rb) [ERInterval rb], DomainIntBox boxra varid (ERInterval rb)) => ERUnitFnBaseIElementary boxb boxra varid rb (ERInterval rb) (ERChebPoly box rb)
instance (ERRealBase rb, RealFrac rb, DomainBox box varid Int, Ord box, Show varid, DomainBoxMappable boxb boxras varid rb [ERInterval rb], DomainBoxMappable boxra boxras varid (ERInterval rb) [ERInterval rb], DomainIntBox boxra varid (ERInterval rb)) => ERUnitFnBaseElementary boxb boxra varid rb (ERInterval rb) (ERChebPoly box rb)
instance (ERRealBase rb, RealFrac rb, DomainBox box varid Int, Ord box, Show varid, DomainBoxMappable boxb boxras varid rb [ERInterval rb], DomainBoxMappable boxra boxras varid (ERInterval rb) [ERInterval rb], DomainIntBox boxra varid (ERInterval rb)) => ERUnitFnBaseIEncl boxb boxra varid rb (ERInterval rb) (ERChebPoly box rb)
instance (ERRealBase rb, RealFrac rb, DomainBox box varid Int, Ord box, Show varid, DomainBoxMappable boxb boxras varid rb [ERInterval rb], DomainBoxMappable boxra boxras varid (ERInterval rb) [ERInterval rb], DomainIntBox boxra varid (ERInterval rb)) => ERUnitFnBaseEncl boxb boxra varid rb (ERInterval rb) (ERChebPoly box rb)
instance (ERRealBase rb, RealFrac rb, DomainBox box varid Int, Ord box, Show varid, DomainBoxMappable boxb boxras varid rb [ERInterval rb], DomainBoxMappable boxra boxras varid (ERInterval rb) [ERInterval rb], DomainIntBox boxra varid (ERInterval rb)) => ERUnitFnBase boxb boxra varid rb (ERInterval rb) (ERChebPoly box rb)


-- | A collection of basic functions to pick from when testing.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Generate
newtype FBSize10 fb
FBSize10 :: ((Int, Int), fb) -> FBSize10 fb
newtype FBSize10Small fb
FBSize10Small :: (Int, fb) -> FBSize10Small fb
newtype FBSize10Degree3 fb
FBSize10Degree3 :: (Int, fb) -> FBSize10Degree3 fb
newtype FBEnclThinSize10 fb
FBEnclThinSize10 :: ((Int, Int), E fb) -> FBEnclThinSize10 fb
newtype FBEnclThinSize10Small fb
FBEnclThinSize10Small :: (Int, E fb) -> FBEnclThinSize10Small fb
newtype FBEnclThinSize10Degree3 fb
FBEnclThinSize10Degree3 :: (Int, E fb) -> FBEnclThinSize10Degree3 fb
newtype FBEnclParalSize10 fb
FBEnclParalSize10 :: (((Int, Int), SmallRatio), E fb) -> FBEnclParalSize10 fb
newtype FBEnclParalSize10Small fb
FBEnclParalSize10Small :: ((Int, SmallRatio), E fb) -> FBEnclParalSize10Small fb
newtype FBEnclParalSize10Degree3 fb
FBEnclParalSize10Degree3 :: ((Int, SmallRatio), E fb) -> FBEnclParalSize10Degree3 fb
newtype FBEnclThickSize10 fb
FBEnclThickSize10 :: (((Int, Int), (Int, Int)), E fb) -> FBEnclThickSize10 fb
newtype FBEnclThickSize10Small fb
FBEnclThickSize10Small :: ((Int, Int), E fb) -> FBEnclThickSize10Small fb
newtype FBEnclThickSize10Degree3 fb
FBEnclThickSize10Degree3 :: ((Int, Int), E fb) -> FBEnclThickSize10Degree3 fb
data Deg20Size20
Deg20Size20 :: Int -> Int -> Deg20Size20
data Deg10Size10
Deg10Size10 :: Int -> Int -> Deg10Size10
data Deg5Size10
Deg5Size10 :: Int -> Int -> Deg5Size10
polynomials1200ishSize10 :: (ERUnitFnBase boxb boxra varid b ra fb) => fb -> [fb]
polynomials1200ishSize10Small :: (ERUnitFnBase boxb boxra varid b ra fb) => fb -> [fb]
polynomials1200ishSize10Degree3 :: (ERUnitFnBase boxb boxra varid b ra fb) => fb -> [fb]
makeThinEncl :: (ERUnitFnBase boxb boxra varid b ra ufb) => ufb -> (ufb, ufb)
makeThickEncl :: (ERUnitFnBase boxb boxra varid b ra ufb) => Int -> Int -> ufb -> ufb -> (ufb, ufb)
makeParalEncl :: (ERUnitFnBase boxb boxra varid a ra ufb) => ufb -> SmallRatio -> (ufb, ufb)
instance (Show fb) => Show (FBSize10Degree3 fb)
instance (Show fb) => Show (FBSize10Small fb)
instance (Show fb) => Show (FBSize10 fb)
instance (Show fb) => Show (FBEnclThickSize10Degree3 fb)
instance (Show fb) => Show (FBEnclThickSize10Small fb)
instance (Show fb) => Show (FBEnclThickSize10 fb)
instance (Show fb) => Show (FBEnclParalSize10Degree3 fb)
instance (Show fb) => Show (FBEnclParalSize10Small fb)
instance (Show fb) => Show (FBEnclParalSize10 fb)
instance (Show fb) => Show (FBEnclThinSize10Degree3 fb)
instance (Show fb) => Show (FBEnclThinSize10Small fb)
instance (Show fb) => Show (FBEnclThinSize10 fb)
instance Show Deg5Size10
instance Show Deg10Size10
instance Show Deg20Size20
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBSize10Small fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBSize10Degree3 fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBSize10 fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBEnclThickSize10Degree3 fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBEnclThickSize10Small fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBEnclThickSize10 fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBEnclParalSize10Degree3 fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBEnclParalSize10Small fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBEnclParalSize10 fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBEnclThinSize10Degree3 fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBEnclThinSize10Small fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Arbitrary (FBEnclThinSize10 fb)
instance Arbitrary Deg5Size10
instance Arbitrary Deg10Size10
instance Arbitrary Deg20Size20


-- | Auxiliary functions for use in test for polynomial enclosure
--   arithmetic.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Properties.Common
fbAtKeyPointsCanBeLeq :: (ERUnitFnBase boxb boxra varid b ra fb, Show boxra, Show testId) => String -> testId -> fb -> fb -> Bool
fbAtKeyPointsPointwiseBinaryDownUpConsistent :: (ERUnitFnBase boxb boxra varid b ra fb, Show boxra, Show testId) => String -> testId -> (ra -> ra -> ra) -> fb -> fb -> (fb, fb) -> Bool
enclAtKeyPointsPointwiseBinaryInnerInOuter :: (ERUnitFnBaseEncl boxb boxra varid b ra fb, Show boxra, Show testId) => String -> testId -> (ra -> ra -> ra) -> (fb, fb) -> (fb, fb) -> (fb, fb) -> Bool
enclAtKeyPointsPointwiseUnaryInnerInOuter :: (ERUnitFnBaseEncl boxb boxra varid b ra fb, Show boxra, Show testId) => String -> testId -> (ra -> ra) -> (fb, fb) -> (fb, fb) -> Bool
enclAtKeyPointsConsistent :: (ERUnitFnBaseEncl boxb boxra varid b ra fb, Show boxra, Show testId) => String -> testId -> (boxra -> ra) -> [varid] -> (fb, fb) -> Bool


-- | Quickcheck properties of bounding operations, ie constant bounds and
--   binary min/max.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Properties.Bounds


-- | Quickcheck properties of polynomial enclosure composition.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Properties.Compose


-- | Quickcheck properties of polynomial enclosure division.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Properties.Division


-- | Quickcheck properties of some elementary operations on primitive
--   polynomial enclosures.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Properties.Elementary
sincosDomain :: (ERRealBase b) => (Maybe b, Maybe b)
noDomainRestriction :: (ERRealBase b) => (Maybe b, Maybe b)
positiveDomain :: (ERRealBase b) => (Maybe b, Maybe b)


-- | Quickcheck properties of basic enclosure operations, mainly ring
--   operations.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Properties.Enclosure
prop_enclAdd_ThickEncls_consistent :: (ERUnitFnBaseEncl boxb boxra varid b ra t, Show boxra, ERInnerOuterApprox ra) => (t, t) -> String -> (Deg5Size10, (FBEnclThickSize10 t, FBEnclThickSize10 t)) -> Bool
prop_enclAdd_ParalEncls_consistent :: (ERUnitFnBaseEncl boxb boxra varid b ra t, Show boxra, ERInnerOuterApprox ra) => (t, t) -> String -> (Deg5Size10, (FBEnclParalSize10 t, FBEnclParalSize10 t)) -> Bool
prop_enclAdd_ThinEncls_consistent :: (ERUnitFnBaseEncl boxb boxra varid b ra t, Show boxra, ERInnerOuterApprox ra) => (t, t) -> String -> (Deg5Size10, (FBEnclThinSize10 t, FBEnclThinSize10 t)) -> Bool
prop_enclMult_ThickEncls_consistent :: (ERUnitFnBaseEncl boxb boxra varid b ra t, Show boxra, ERInnerOuterApprox ra) => (t, t) -> String -> (Deg5Size10, (FBEnclThickSize10 t, FBEnclThickSize10 t)) -> Bool
prop_enclMult_ParalEncls_consistent :: (ERUnitFnBaseEncl boxb boxra varid b ra t, Show boxra, ERInnerOuterApprox ra) => (t, t) -> String -> (Deg5Size10, (FBEnclParalSize10 t, FBEnclParalSize10 t)) -> Bool
prop_enclMult_ThinEncls_consistent :: (ERUnitFnBaseEncl boxb boxra varid b ra t, Show boxra, ERInnerOuterApprox ra) => (t, t) -> String -> (Deg5Size10, (FBEnclThinSize10 t, FBEnclThinSize10 t)) -> Bool


-- | Quickcheck properties for checking that polynomial intergration is
--   consistent with polynomial differentiation.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Properties.Integration


-- | Quickcheck properties of operations that reduce the size of
--   polynomials.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Properties.Reduce


-- | Quickcheck properties of ring operations, ie addition and
--   multiplication.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Properties.Ring


-- | Support for running all function enclosure base tests in a batch.
module Data.Number.ER.RnToRm.UnitDom.Base.Tests.Run
runUFBTests :: (ERUnitFnBaseElementary boxb boxra varid b ra fb, ERUnitFnBaseIElementary boxb boxra varid b ra fb, ERInnerOuterApprox ra, Ord ra, Show fb, Show boxra, Show varid) => String -> fb -> IO () -> IO ()


-- | Approximation of a real functions with rectangular domains.
--   
--   To be imported qualified, usually with the synonym FA.
module Data.Number.ER.RnToRm.Approx

-- | A class of types that approximate first-order real functions <tt>R^n
--   -&gt; R^m</tt> using some type of graph enclosures. The domains of the
--   functions can be neither specified nor investigated by operations in
--   this class.
--   
--   This class extends <a>ERApprox</a> so that we could perform point-wise
--   operations on the functions.
--   
--   This class is associated with:
--   
--   <ul>
--   <li>two real number types (instances of <a>ERIntApprox</a>) for
--   working with parts of the function's domain and range;</li>
--   <li>a type of boxes indexed by variables (instance of
--   <a>DomainBox</a>) for working with multiple-dimension function
--   domains.</li>
--   </ul>
class (ERApprox fa, ERIntApprox fa, ERIntApprox domra, ERIntApprox ranra, DomainBox box varid domra) => ERFnApprox box varid domra ranra fa | fa -> box varid domra ranra
check :: (ERFnApprox box varid domra ranra fa) => String -> fa -> fa
domra2ranra :: (ERFnApprox box varid domra ranra fa) => fa -> domra -> ranra
ranra2domra :: (ERFnApprox box varid domra ranra fa) => fa -> ranra -> domra
getDegree :: (ERFnApprox box varid domra ranra fa) => fa -> Int
setMaxDegree :: (ERFnApprox box varid domra ranra fa) => Int -> fa -> fa
getMaxDegree :: (ERFnApprox box varid domra ranra fa) => fa -> Int
getSize :: (ERFnApprox box varid domra ranra fa) => fa -> Int
setMaxSize :: (ERFnApprox box varid domra ranra fa) => Int -> fa -> fa
getMaxSize :: (ERFnApprox box varid domra ranra fa) => fa -> Int
getVariables :: (ERFnApprox box varid domra ranra fa) => fa -> [varid]
getBestPrecision :: (ERFnApprox box varid domra ranra fa) => fa -> Precision
getRangeApprox :: (ERFnApprox box varid domra ranra fa) => fa -> ranra
tuple :: (ERFnApprox box varid domra ranra fa) => [fa] -> fa
getTupleSize :: (ERFnApprox box varid domra ranra fa) => fa -> Int
applyTupleFn :: (ERFnApprox box varid domra ranra fa) => ([fa] -> [fa]) -> (fa -> fa)
volume :: (ERFnApprox box varid domra ranra fa) => fa -> ranra
scale :: (ERFnApprox box varid domra ranra fa) => ranra -> fa -> fa
partialIntersect :: (ERFnApprox box varid domra ranra fa) => EffortIndex -> box -> fa -> fa -> fa
intersectMeasureImprovement :: (ERFnApprox box varid domra ranra fa) => EffortIndex -> fa -> fa -> (fa, ranra)
eval :: (ERFnApprox box varid domra ranra fa) => box -> fa -> [ranra]
partialEval :: (ERFnApprox box varid domra ranra fa) => box -> fa -> fa
composeNonDecreasing :: (ERFnApprox box varid domra ranra fa) => fa -> varid -> fa -> fa
composeNonIncreasing :: (ERFnApprox box varid domra ranra fa) => fa -> varid -> fa -> fa

-- | This class extends <a>ERFnApprox</a> by:
--   
--   <ul>
--   <li>making the domain of the function enclosure available for
--   inspection;</li>
--   <li>allowing the construction of basic function enclosures where the
--   domain has to be specified.</li>
--   </ul>
class (ERFnApprox box varid domra ranra fa, DomainIntBox box varid domra) => ERFnDomApprox box varid domra ranra fa | fa -> box varid domra ranra
bottomApprox :: (ERFnDomApprox box varid domra ranra fa) => box -> Int -> fa
const :: (ERFnDomApprox box varid domra ranra fa) => box -> [ranra] -> fa
proj :: (ERFnDomApprox box varid domra ranra fa) => box -> varid -> fa
dom :: (ERFnDomApprox box varid domra ranra fa) => fa -> box
bisect :: (ERFnDomApprox box varid domra ranra fa) => varid -> Maybe domra -> fa -> (fa, fa)
unBisect :: (ERFnDomApprox box varid domra ranra fa) => varid -> (fa, fa) -> fa
integrate :: (ERFnDomApprox box varid domra ranra fa) => EffortIndex -> fa -> varid -> box -> domra -> fa -> fa
integrateUnary :: (ERFnDomApprox box varid domra ranra fa) => EffortIndex -> fa -> domra -> domra -> [ranra] -> fa
integrateMeasureImprovement :: (ERFnDomApprox box varid domra ranra fa) => EffortIndex -> fa -> varid -> box -> domra -> fa -> (fa, fa)
integrateMeasureImprovementUnary :: (ERFnDomApprox box varid domra ranra fa) => EffortIndex -> fa -> domra -> domra -> fa -> (fa, fa)

-- | Recursively perform a number of bisections and then glue the bits back
--   together.
--   
--   This way we can ensure that a piece-wise enclosure has a partition
--   that goes to at least the given depth.
bisectUnbisectDepth :: (ERFnDomApprox box varid domra ranra fa) => Int -> fa -> fa

-- | Check that a function approximation is consistent with a real function
--   that is meant to compute the same function.
--   
--   The result of this function is the list of points in which the
--   consistency check failed. The result of the operation is also included
--   both for the real number version and the function approximation
--   version.
keyPointsConsistencyCheck :: (ERFnDomApprox box varid domra ranra fa) => (box -> ranra) -> fa -> [(box, ranra, ranra)]

-- | Check that a pointwise operation previously performed on function
--   approximations is consistent with the same operation performed on
--   selected points in the domain of these functions. The selected points
--   are the centres of all faces of all dimensions, which includes the
--   corners.
--   
--   The result of this function is the list of points in which the
--   consistency check failed. The result of the operation is also included
--   both for the real number version and the function approximation
--   version.
keyPointsPointwiseConsistencyCheck :: (ERFnDomApprox box varid domra ranra fa) => ([ranra] -> ranra) -> [fa] -> fa -> [(box, ranra, ranra)]

-- | A class of types that approximate function enclosures of first-order
--   real functions <tt>R^n -&gt; R^m</tt> eg using a pair of function
--   enclosures. The domains of the functions can be neither specified nor
--   investigated by operations in this class.
--   
--   This class extends <a>ERApproxApprox</a> so that we could perform
--   point-wise operations on the function enclosures.
--   
--   This class is associated with:
--   
--   <ul>
--   <li>a real number type (instance of <a>ERIntApprox</a>) for working
--   with parts of the function's domain</li>
--   <li>a real number approximation approximation for approximating the
--   function enclosure range at an individual point or uniformly over many
--   points;</li>
--   <li>a type of boxes indexed by variables (instance of
--   <a>DomainBox</a>) for working with multiple-dimension function
--   domains.</li>
--   </ul>
class (ERIntApprox domra, ERApproxApprox ranraa, DomainBox box varid domra) => ERFnApproxApprox box varid domra ranraa fa | fa -> box varid domra ranraa
evalAA :: (ERFnApproxApprox box varid domra ranraa fa) => box -> fa -> [ranraa]


-- | Approximation of continuous real functions defined on the unit
--   rectangle domain of a certain dimension.
--   
--   To be imported qualified, usually with the synonym UFA.
module Data.Number.ER.RnToRm.UnitDom.Approx

-- | This class extends <tt>ERFnApprox</tt> by:
--   
--   <ul>
--   <li>assuming that the domain of the function enclosures is always
--   <tt>[-1,1]^n</tt> for some <tt>n</tt>;</li>
--   <li>allowing the construction of basic function enclosures where the
--   domain has to be known.</li>
--   </ul>
class (ERFnApprox box varid domra ranra fa) => ERUnitFnApprox box varid domra ranra fa | fa -> box varid domra ranra
bottomApprox :: (ERUnitFnApprox box varid domra ranra fa) => fa
const :: (ERUnitFnApprox box varid domra ranra fa) => [ranra] -> fa
affine :: (ERUnitFnApprox box varid domra ranra fa) => [ranra] -> Map varid ([ranra]) -> fa
composeWithThin :: (ERUnitFnApprox box varid domra ranra fa) => fa -> Map varid fa -> fa
volume :: (ERUnitFnApprox box varid domra ranra fa) => [varid] -> fa -> ranra
intersectMeasureImprovement :: (ERUnitFnApprox box varid domra ranra fa) => EffortIndex -> [varid] -> fa -> fa -> (fa, ranra)
integrate :: (ERUnitFnApprox box varid domra ranra fa) => EffortIndex -> fa -> varid -> domra -> fa -> fa

-- | Check that a function approximation is consistent with a real function
--   that is meant to compute the same function.
--   
--   The result of this function is the list of points in which the
--   consistency check failed. The result of the operation is also included
--   both for the real number version and the function approximation
--   version.
keyPointsConsistencyCheck :: (ERUnitFnApprox box varid domra ranra fa) => (box -> ranra) -> fa -> [(box, ranra, ranra)]

-- | Check that a pointwise operation previously performed on function
--   approximations is consistent with the same operation performed on
--   selected points in the domain of these functions. The selected points
--   are the centres of all faces of all dimensions, which includes the
--   corners.
--   
--   The result of this function is the list of points in which the
--   consistency check failed. The result of the operation is also included
--   both for the real number version and the function approximation
--   version.
keyPointsPointwiseConsistencyCheck :: (ERUnitFnApprox box varid domra ranra fa) => ([ranra] -> ranra) -> [fa] -> fa -> [(box, ranra, ranra)]


-- | A construction of an enclosure of a real function on the domain
--   [-1,1]^n for some n using elements of some base (eg rational functions
--   or polynomials).
module Data.Number.ER.RnToRm.UnitDom.Approx.Interval
data ERFnInterval fb
ERFnIntervalAny :: ERFnContext -> ERFnInterval fb
erfnContext :: ERFnInterval fb -> ERFnContext
ERFnInterval :: fb -> fb -> ERFnContext -> ERFnInterval fb
erfnLowerNeg :: ERFnInterval fb -> fb
erfnUpper :: ERFnInterval fb -> fb
erfnContext :: ERFnInterval fb -> ERFnContext
data ERFnContext
ERFnContext :: Int -> Int -> Granularity -> ERFnContext
erfnMaxDegree :: ERFnContext -> Int
erfnMaxSize :: ERFnContext -> Int
erfnCoeffGranularity :: ERFnContext -> Granularity
erfnContextDefault :: ERFnContext
erfnContextUnify :: ERFnContext -> ERFnContext -> ERFnContext
instance Typeable ERFnContext
instance Typeable1 ERFnInterval
instance Show ERFnContext
instance Data ERFnContext
instance (Data fb) => Data (ERFnInterval fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, Show varid, Show boxra) => ERUnitFnApprox boxra varid ra ra (ERFnInterval fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, Show varid, Show boxra) => ERFnApprox boxra varid ra ra (ERFnInterval fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, ERApproxElementary ra, Show varid, Show boxra) => ERApproxElementary (ERFnInterval fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, Show varid, Show boxra) => ERIntApprox (ERFnInterval fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, Show varid, Show boxra) => ERApprox (ERFnInterval fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, Show varid, Show boxra) => Fractional (ERFnInterval fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, Show varid, Show boxra) => Num (ERFnInterval fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Ord (ERFnInterval fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Eq (ERFnInterval fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => HTML (ERFnInterval fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Show (ERFnInterval fb)
instance Binary ERFnContext
instance (Binary a) => Binary (ERFnInterval a)


-- | Datatype translating enclosures from <tt>[-1,1]^n</tt> to any compact
--   interval in <tt>R^n</tt> with non-empty interior.
module Data.Number.ER.RnToRm.Approx.DomTransl

-- | Datatype translating enclosures from <tt>[-1,1]^n</tt> to any compact
--   interval in <tt>R^n</tt> with non-empty interior using a bunch of
--   linear maps, one for each dimension.
data ERFnDomTranslApprox dtrbox varid ufa ira
ERFnDomTranslApprox :: ufa -> dtrbox -> ERFnDomTranslApprox dtrbox varid ufa ira
erfnUnitApprox :: ERFnDomTranslApprox dtrbox varid ufa ira -> ufa
erfnDomTransl :: ERFnDomTranslApprox dtrbox varid ufa ira -> dtrbox

-- | The canonical translation of any compact non-empty and non-singleton
--   interval in <tt>R</tt> to and from the unit interval <tt>[-1,1]</tt>.
--   
--   This structure holds the two coefficients for both linear mappings.
data DomTransl ira
DomTransl :: ira -> ira -> ira -> ira -> ira -> DomTransl ira

-- | the interval being mapped
dtrDom :: DomTransl ira -> ira
dtrFromUnitSlope :: DomTransl ira -> ira
dtrFromUnitConst :: DomTransl ira -> ira
dtrToUnitSlope :: DomTransl ira -> ira
dtrToUnitConst :: DomTransl ira -> ira
instance Typeable1 DomTransl
instance Typeable4 ERFnDomTranslApprox
instance (Data ira) => Data (DomTransl ira)
instance (Data dtrbox, Data varid, Data ufa, Data ira) => Data (ERFnDomTranslApprox dtrbox varid ufa ira)
instance (DomainBoxMappable box dtrbox varid domra (DomTransl domra), ERFnApproxApprox box varid domra ranraa ufa) => ERFnApproxApprox box varid domra ranraa (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, DomainIntBox box varid domra, Show varid, Show box, DomainBoxMappable dtrbox box varid (DomTransl domra) domra, DomainBoxMappable box dtrbox varid domra (DomTransl domra), Eq dtrbox, Ord dtrbox) => ERFnDomApprox box varid domra ranra (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, DomainBoxMappable dtrbox box varid (DomTransl domra) domra, DomainIntBox box varid domra, Show varid, Show box, DomainBoxMappable box dtrbox varid domra (DomTransl domra), Eq dtrbox, Ord dtrbox) => ERFnApprox box varid domra ranra (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, ERApproxElementary ufa, DomainBoxMappable dtrbox box varid (DomTransl domra) domra, Eq dtrbox, Ord dtrbox) => ERApproxElementary (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, ERIntApprox ufa, DomainBoxMappable dtrbox box varid (DomTransl domra) domra, Eq dtrbox, Ord dtrbox) => ERIntApprox (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERApproxApprox ufa) => ERApproxApprox (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, DomainBoxMappable dtrbox box varid (DomTransl domra) domra, Eq dtrbox, Ord dtrbox) => ERApprox (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, DomainBoxMappable dtrbox box varid (DomTransl domra) domra, Eq dtrbox) => Fractional (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, DomainBoxMappable dtrbox box varid (DomTransl domra) domra, Eq dtrbox) => Num (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, Ord ufa, Eq dtrbox) => Ord (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, Eq dtrbox) => Eq (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, DomainBoxMappable dtrbox box varid (DomTransl domra) domra, DomainBoxMappable box dtrbox varid domra (DomTransl domra), HTML ufa) => HTML (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERUnitFnApprox box varid domra ranra ufa, DomainBoxMappable dtrbox box varid (DomTransl domra) domra) => Show (ERFnDomTranslApprox dtrbox varid ufa domra)
instance (ERIntApprox domra, HTML domra) => HTML (DomTransl domra)
instance (ERIntApprox domra) => Show (DomTransl domra)
instance (ERIntApprox domra) => Ord (DomTransl domra)
instance (ERIntApprox domra) => Eq (DomTransl domra)
instance (Binary a) => Binary (DomTransl a)
instance (Binary a, Binary b, Binary c, Binary d) => Binary (ERFnDomTranslApprox a b c d)


module Data.Number.ER.RnToRm.Approx.DomEdges

-- | Use some function approximation type and for each domain box keep a
--   structure of function approximations of this type indexed by the
--   hyper-edge structure. For each hyper-edge of the domain, the
--   approximation has this edge as its domain.
--   
--   E.g. for a 2D square domain there are:
--   
--   <ul>
--   <li>one approximation for the whole square</li>
--   <li>four 1D approximations, one for each edge</li>
--   <li>eight 0D approximations, one for each endpoint of each edge</li>
--   </ul>
data ERFnDomEdgesApprox varid fa
ERFnDomEdgesApprox :: fa -> Map (varid, PlusMinus) (ERFnDomEdgesApprox varid fa) -> ERFnDomEdgesApprox varid fa
erfnMainVolume :: ERFnDomEdgesApprox varid fa -> fa
erfnEdges :: ERFnDomEdgesApprox varid fa -> Map (varid, PlusMinus) (ERFnDomEdgesApprox varid fa)
instance Typeable2 ERFnDomEdgesApprox
instance (Data varid, Data fa, Ord varid) => Data (ERFnDomEdgesApprox varid fa)
instance (ERFnDomApprox box varid domra ranra fa, VariableID varid, Show box) => ERFnDomApprox box varid domra ranra (ERFnDomEdgesApprox varid fa)
instance (ERFnDomApprox box varid domra ranra fa, VariableID varid, Show box) => ERFnApprox box varid domra ranra (ERFnDomEdgesApprox varid fa)
instance (ERFnDomApprox box varid domra ranra fa, ERApproxElementary fa, VariableID varid, Show box) => ERApproxElementary (ERFnDomEdgesApprox varid fa)
instance (ERFnDomApprox box varid domra ranra fa, ERIntApprox fa, VariableID varid, Show box) => ERIntApprox (ERFnDomEdgesApprox varid fa)
instance (ERFnDomApprox box varid domra ranra fa, VariableID varid, Show box) => ERApprox (ERFnDomEdgesApprox varid fa)
instance (ERFnDomApprox box varid domra ranra fa, VariableID varid) => Fractional (ERFnDomEdgesApprox varid fa)
instance (ERFnDomApprox box varid domra ranra fa, VariableID varid) => Num (ERFnDomEdgesApprox varid fa)
instance (ERFnApprox box varid domra ranra fa, Ord fa) => Ord (ERFnDomEdgesApprox varid fa)
instance (ERFnApprox box varid domra ranra fa) => Eq (ERFnDomEdgesApprox varid fa)
instance (ERFnDomApprox box varid domra ranra fa, HTML fa) => HTML (ERFnDomEdgesApprox varid fa)
instance (ERFnDomApprox box varid domra ranra fa, Ord varid, VariableID varid) => Show (ERFnDomEdgesApprox varid fa)
instance (Ord a, Binary a, Binary b) => Binary (ERFnDomEdgesApprox a b)


-- | Lists of function approximations over the same domain.
module Data.Number.ER.RnToRm.Approx.Tuple

-- | A tuple of function approximations allowing one to get from functions
--   <tt>R^n-&gt;R</tt> to a function <tt>R^n -&gt; R^m</tt>.
data ERFnTuple fa
ERFnTuple :: [fa] -> ERFnTuple fa
erfnTuple :: ERFnTuple fa -> [fa]
instance Typeable1 ERFnTuple
instance (Data fa) => Data (ERFnTuple fa)
instance (ERFnDomApprox box varid domra ranra fa) => ERFnDomApprox box varid domra ranra (ERFnTuple fa)
instance (ERFnDomApprox box varid domra ranra fa) => ERFnApprox box varid domra ranra (ERFnTuple fa)
instance (ERFnDomApprox box varid domra ranra fa, ERApproxElementary fa) => ERApproxElementary (ERFnTuple fa)
instance (ERFnDomApprox box varid domra ranra fa, ERIntApprox fa) => ERIntApprox (ERFnTuple fa)
instance (ERFnDomApprox box varid domra ranra fa) => ERApprox (ERFnTuple fa)
instance (ERFnDomApprox box varid domra ranra fa) => Fractional (ERFnTuple fa)
instance (ERFnDomApprox box varid domra ranra fa) => Num (ERFnTuple fa)
instance (ERFnApprox box varid domra ranra fa, Ord fa) => Ord (ERFnTuple fa)
instance (ERFnApprox box varid domra ranra fa) => Eq (ERFnTuple fa)
instance (ERFnDomApprox box varid domra ranra fa, HTML fa) => HTML (ERFnTuple fa)
instance (ERFnDomApprox box varid domra ranra fa) => Show (ERFnTuple fa)
instance (Binary a) => Binary (ERFnTuple a)


-- | Arbitrary precision piece-wise something (eg linear, polynomial,
--   rational) enclosures of functions <tt>R^n-&gt;R^m</tt>.
--   
--   The type of approximation within segments is specified by an instance
--   of <a>ERFnDomApprox</a>.
--   
--   The piece-wise construction defines another instance of
--   <a>ERFnDomApprox</a>.
module Data.Number.ER.RnToRm.Approx.PieceWise

-- | Arbitrary precision piece-wise something (eg linear, polynomial,
--   rational) enclosures of functions <tt>R^n-&gt;R^m</tt>.
--   
--   The type of approximation within segments is specified by an instance
--   of <a>ERFnDomApprox</a>.
--   
--   The piece-wise construction defines another instance of
--   <a>ERFnDomApprox</a>.
data ERFnPiecewise box varid domra fa
ERFnPiecewise :: (BisectionTree box varid domra fa) -> ERFnPiecewise box varid domra fa
instance Typeable4 ERFnPiecewise
instance (Data box, Data varid, Data domra, Data fa) => Data (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa, ERIntApprox fa, Show box, DomainBoxMappable box box varid domra domra) => ERFnDomApprox box varid domra ranra (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa, ERIntApprox fa, DomainBoxMappable box box varid domra domra, Show box) => ERFnApprox box varid domra ranra (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa, ERApproxElementary fa, VariableID varid) => ERApproxElementary (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa, ERIntApprox fa, VariableID varid) => ERIntApprox (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa, VariableID varid) => ERApprox (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa, VariableID varid) => Fractional (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa, VariableID varid) => Num (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa) => Ord (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa) => Eq (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa, ERIntApprox fa, HTML fa) => HTML (ERFnPiecewise box varid domra fa)
instance (ERFnDomApprox box varid domra ranra fa, VariableID varid) => Show (ERFnPiecewise box varid domra fa)
instance (Binary a, Binary b, Binary c, Binary d) => Binary (ERFnPiecewise a b c d)


-- | Utilities for addressing and modifying leaves of binary bisection
--   trees.
module Data.Number.ER.RnToRm.BisectionTree.Path

-- | A path in a binary tree. It is used mainly in connection with
--   <tt>BisectionTree.BisectionTree</tt>.
data BisecTreePath
BTP_H :: BisecTreePath
BTP_R :: BisecTreePath -> BisecTreePath
BTP_L :: BisecTreePath -> BisecTreePath

-- | Assuming that bisection happens at default points as defined by
--   <a>bisectDomain</a> and starts from the given root interval.
path2dom :: (ERIntApprox ira) => ira -> BisecTreePath -> ira

-- | A representation of a binary tree with a hole that can be efficiently
--   filled.
data FnZipper f
FnZ_H :: f -> FnZipper f
FnZ_L :: (FnZipper f) -> f -> FnZipper f
FnZ_R :: f -> (FnZipper f) -> FnZipper f

-- | Lookup a subdomain of a function according to a bisection path. Return
--   the restrited function as well as a zipper that allows an efficient
--   modification of the function on the looked up subdomain.
lookupSubdomain :: (ERFnDomApprox box varid domra ranra fa) => fa -> BisecTreePath -> (fa, FnZipper fa)

-- | Modify a function in its subdomain as expressed by the zipper.
updateFnZ :: (ERFnDomApprox box varid domra ranra fa) => (FnZipper fa) -> fa -> fa
instance Typeable BisecTreePath
instance Eq BisecTreePath
instance Data BisecTreePath
instance Read BisecTreePath
instance Show BisecTreePath
instance Binary BisecTreePath


-- | A construction of an outer/inner enclosure of a real function on the
--   domain [-1,1]^n for some n using elements of some base (eg rational
--   functions or polynomials).
module Data.Number.ER.RnToRm.UnitDom.Approx.IntervalOI
data ERFnIntervalOI fb
ERFnIntervalOIAny :: ERFnContext -> ERFnIntervalOI fb
erfnoiContext :: ERFnIntervalOI fb -> ERFnContext
ERFnIntervalOI :: ERFnContext -> (fb, fb) -> ((fb, fb), Bool) -> ERFnIntervalOI fb
erfnoiContext :: ERFnIntervalOI fb -> ERFnContext
erfnoiOuter :: ERFnIntervalOI fb -> (fb, fb)
erfnoiInner :: ERFnIntervalOI fb -> ((fb, fb), Bool)
instance Typeable1 ERFnIntervalOI
instance (Data fb) => Data (ERFnIntervalOI fb)
instance (ERUnitFnBaseEncl boxb boxra varid b ra fb, ERUnitFnBaseIEncl boxb boxra varid b ra fb) => ERFnApproxApprox boxra varid ra (ERApproxOI ra) (ERFnIntervalOI fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => ERApproxApprox (ERFnIntervalOI fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, ERUnitFnBaseIElementary boxb boxra varid b ra fb, Show varid, Show boxra) => ERUnitFnApprox boxra varid ra ra (ERFnIntervalOI fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, ERUnitFnBaseIElementary boxb boxra varid b ra fb, Show varid, Show boxra) => ERFnApprox boxra varid ra ra (ERFnIntervalOI fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, ERUnitFnBaseIElementary boxb boxra varid b ra fb, ERApproxElementary ra, Show varid, Show boxra) => ERApproxElementary (ERFnIntervalOI fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, ERUnitFnBaseIElementary boxb boxra varid b ra fb, Show varid, Show boxra) => ERIntApprox (ERFnIntervalOI fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, ERUnitFnBaseIElementary boxb boxra varid b ra fb, Show varid, Show boxra) => ERApprox (ERFnIntervalOI fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, ERUnitFnBaseIElementary boxb boxra varid b ra fb, Show varid, Show boxra) => Fractional (ERFnIntervalOI fb)
instance (ERUnitFnBaseElementary boxb boxra varid b ra fb, ERUnitFnBaseIElementary boxb boxra varid b ra fb, Show varid, Show boxra) => Num (ERFnIntervalOI fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Ord (ERFnIntervalOI fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Eq (ERFnIntervalOI fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => HTML (ERFnIntervalOI fb)
instance (ERUnitFnBase boxb boxra varid b ra fb) => Show (ERFnIntervalOI fb)
instance (Binary a) => Binary (ERFnIntervalOI a)


-- | This module supplies default instances for the real number and
--   function classes described in <a>Data.Number.ER.RnToRm</a>.
--   
--   These classes form loosely coupled boundaries between abstraction
--   layers. Nevertheless, we usually have particular implementations in
--   mind, as shown here.
--   
--   To preserve the intended loose coupling, please use these definitions
--   only in functions that cannot infer from their input or output data
--   which type of function enclosures they should use. Eg a function to
--   add 1 to an enclosure should have the type:
--   
--   <pre>
--   add1 :: (ERFnApprox box varid domra ranra fa) =&gt; fa -&gt; fa
--   add1 f = f + 1
--   </pre>
--   
--   and <i>not</i>: <tt>add1 :: FAPWP -&gt; FAPWP</tt>
module Data.Number.ER.RnToRm.DefaultRepr
type P b = ERChebPoly (Box Int) b
type FAPU b = ERFnInterval (P b)
type FAPUOI b = ERFnIntervalOI (P b)
type FAPD b = ERFnDomTranslApprox (Box (DomTransl (IRA b))) VarID (FAPU b) (IRA b)
type FAPDOI b = ERFnDomTranslApprox (Box (DomTransl (IRA b))) VarID (FAPUOI b) (IRA b)
type FAPT b = ERFnTuple (FAPD b)
type FAPE b = ERFnDomEdgesApprox VarID (FAPT b)
type FAPWP b = ERFnPiecewise (Box (IRA b)) VarID (IRA b) (FAPE b)
type FA = FAPWP B


-- | A few definitions useful for testing the enclosures code, eg in ghci.
module Data.Number.ER.RnToRm.TestingDefs


-- | This module bundles some of the most important functionality of the
--   AERN-RnToRm package. It is intended to be imported *qualified*.
--   
--   AERN-RnToRm provides datatypes and abstractions for approximating
--   functions of type <tt>D -&gt; R^m</tt> where <tt>D</tt> is a bounded
--   interval in <tt>R^n</tt> with non-empty interior.
--   
--   Abstractions are provided via 4 type classes:
--   
--   <ul>
--   <li><a>ERUnitFnBase</a>: generalises polynomials with floating point
--   coefficients. (<i>Not exported here, used only internally.</i>)</li>
--   <li><a>ERFnApprox</a>: generalises functions enclosures on a certain
--   unspecified domain.</li>
--   <li><a>ERUnitFnApprox</a> (extends <a>ERFnApprox</a>): generalises
--   function graph enclosures on the domain <tt>[-1,1]^n</tt>. (<i>Not
--   exported here, used only internally.</i>)</li>
--   <li><a>ERFnDomApprox</a> (extends <a>ERFnApprox</a>): generalises
--   function enclosures over a specified and queriable domain box
--   (instance of class <a>DomainBox</a>).</li>
--   </ul>
--   
--   At all levels, all field operations are supported as well as some
--   elementary operations, namely exp, sin and cos. Log and sqrt are
--   planned to be added soon.
--   
--   Implementations of <a>ERUnitFnBase</a>:
--   
--   <ul>
--   <li><a>ERChebPoly</a></li>
--   </ul>
--   
--   By using the Chebyshev basis on domain <tt>[-1,1]^n</tt>, we gain
--   simple and optimally rounding degree reduction as well as relatively
--   simple handling of rounding in other operations.
--   
--   Implementations of <a>ERUnitFnApprox</a>:
--   
--   <ul>
--   <li><a>ERFnInterval</a></li>
--   </ul>
--   
--   Implementations of <a>ERFnDomApprox</a>:
--   
--   <ul>
--   <li><a>ERFnDomTranslApprox</a>: builds a basic implementation using an
--   instance of <a>ERUnitFnApprox</a>.</li>
--   <li><a>ERFnTuple</a>: extends another implementation of
--   <a>ERFnDomApprox</a> to work with lists of functions
--   simultaneously.</li>
--   <li><a>ERFnDomEdgesApprox</a>: separately enclose a function on its
--   domain box as well as on all the domain's hyper-edges (including the
--   corners) using another implementation of <a>ERFnDomApprox</a>.</li>
--   <li><a>ERFnPiecewise</a>: allows the domain box to be bisected to an
--   arbitrary finite depth and uses another implementation of
--   <a>ERFnDomApprox</a> to approximate the function on each segment.</li>
--   </ul>
module Data.Number.ER.RnToRm
