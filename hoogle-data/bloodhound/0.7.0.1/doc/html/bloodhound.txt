-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ElasticSearch client library for Haskell
--   
--   ElasticSearch made awesome for Haskell hackers
@package bloodhound
@version 0.7.0.1

module Database.Bloodhound.Types.Class
class Monoid a => Seminearring a where (<&&>) = mappend
(<||>) :: Seminearring a => a -> a -> a
(<&&>) :: Seminearring a => a -> a -> a


-- | Data types for describing actions and data structures performed to
--   interact with Elasticsearch. The two main buckets your queries against
--   Elasticsearch will fall into are <a>Query</a>s and <a>Filter</a>s.
--   <a>Filter</a>s are more like traditional database constraints and
--   often have preferable performance properties. <a>Query</a>s support
--   human-written textual queries, such as fuzzy queries.
module Database.Bloodhound.Types
defaultCache :: Cache

-- | <a>defaultIndexSettings</a> is an <a>IndexSettings</a> with 3 shards
--   and 2 replicas.
defaultIndexSettings :: IndexSettings

-- | Reasonable default settings. Chooses no version control.
defaultIndexDocumentSettings :: IndexDocumentSettings

-- | <a>mkSort</a> defaults everything but the <a>FieldName</a> and the
--   <a>SortOrder</a> so that you can concisely describe the usual kind of
--   <a>SortSpec</a>s you want.
mkSort :: FieldName -> SortOrder -> DefaultSort
showText :: Show a => a -> Text

-- | <a>unpackId</a> is a silly convenience function that gets used once.
unpackId :: DocId -> Text

-- | <a>mkMatchQuery</a> is a convenience function that defaults the less
--   common parameters, enabling you to provide only the <a>FieldName</a>
--   and <a>QueryString</a> to make a <a>MatchQuery</a>
mkMatchQuery :: FieldName -> QueryString -> MatchQuery

-- | <a>mkMultiMatchQuery</a> is a convenience function that defaults the
--   less common parameters, enabling you to provide only the list of
--   <a>FieldName</a>s and <a>QueryString</a> to make a
--   <a>MultiMatchQuery</a>.
mkMultiMatchQuery :: [FieldName] -> QueryString -> MultiMatchQuery
mkBoolQuery :: [Query] -> [Query] -> [Query] -> BoolQuery
mkRangeQuery :: FieldName -> RangeValue -> RangeQuery
mkQueryStringQuery :: QueryString -> QueryStringQuery
mkAggregations :: Text -> Aggregation -> Aggregations
mkTermsAggregation :: Text -> TermsAggregation
mkTermsScriptAggregation :: Text -> TermsAggregation
mkDateHistogram :: FieldName -> Interval -> DateHistogramAggregation

-- | Smart constructor for in-range doc version
mkDocVersion :: Int -> Maybe DocVersion
docVersionNumber :: DocVersion -> Int
toTerms :: Text -> AggregationResults -> Maybe (Bucket TermsResult)
toDateHistogram :: Text -> AggregationResults -> Maybe (Bucket DateHistogramResult)
omitNulls :: [(Text, Value)] -> Value
data BH m a
runBH :: BHEnv -> BH m a -> m a

-- | Common environment for Elasticsearch calls. Connections will be
--   pipelined according to the provided HTTP connection manager.
data BHEnv
BHEnv :: Server -> Manager -> BHEnv
bhServer :: BHEnv -> Server
bhManager :: BHEnv -> Manager

-- | All API calls to Elasticsearch operate within MonadBH. The idea is
--   that it can be easily embedded in your own monad transformer stack. A
--   default instance for a ReaderT and alias <a>BH</a> is provided for the
--   simple case.
class (Functor m, Applicative m, MonadIO m) => MonadBH m
getBHEnv :: MonadBH m => m BHEnv

-- | <a>Version</a> is embedded in <a>Status</a>
data Version
Version :: Text -> Text -> UTCTime -> Bool -> Text -> Version
number :: Version -> Text
build_hash :: Version -> Text
build_timestamp :: Version -> UTCTime
build_snapshot :: Version -> Bool
lucene_version :: Version -> Text

-- | <a>Status</a> is a data type for describing the JSON body returned by
--   Elasticsearch when you query its status. This was deprecated in 1.2.0.
--   
--   
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-status.html#indices-status</a>
data Status
Status :: Maybe Bool -> Int -> Text -> Version -> Text -> Status
ok :: Status -> Maybe Bool
status :: Status -> Int
name :: Status -> Text
version :: Status -> Version
tagline :: Status -> Text
newtype Existence
Existence :: Bool -> Existence
newtype NullValue
NullValue :: Bool -> NullValue

-- | <a>IndexSettings</a> is used to configure the shards and replicas when
--   you create an Elasticsearch Index.
--   
--   
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-create-index.html</a>
data IndexSettings
IndexSettings :: ShardCount -> ReplicaCount -> IndexSettings
indexShards :: IndexSettings -> ShardCount
indexReplicas :: IndexSettings -> ReplicaCount

-- | <a>Server</a> is used with the client functions to point at the ES
--   instance
newtype Server
Server :: Text -> Server

-- | <a>Reply</a> and <a>Method</a> are type synonyms from <a>Method</a>
type Reply = Response ByteString

-- | <a>EsResult</a> describes the standard wrapper JSON document that you
--   see in successful Elasticsearch responses.
data EsResult a
EsResult :: Text -> Text -> Text -> DocVersion -> Maybe Bool -> a -> EsResult a
_index :: EsResult a -> Text
_type :: EsResult a -> Text
_id :: EsResult a -> Text
_version :: EsResult a -> DocVersion
found :: EsResult a -> Maybe Bool
_source :: EsResult a -> a

-- | <a>DocVersion</a> is an integer version number for a document between
--   1 and 9.2e+18 used for .
data DocVersion

-- | <a>ExternalDocVersion</a> is a convenience wrapper if your code uses
--   its own version numbers instead of ones from ES.
newtype ExternalDocVersion
ExternalDocVersion :: DocVersion -> ExternalDocVersion

-- | <a>VersionControl</a> is specified when indexing documents as a
--   optimistic concurrency control.
data VersionControl

-- | Don't send a version. This is a pure overwrite.
NoVersionControl :: VersionControl

-- | Use the default ES versioning scheme. Only index the document if the
--   version is the same as the one specified. Only applicable to updates,
--   as you should be getting Version from a search result.
InternalVersion :: DocVersion -> VersionControl

-- | Use your own version numbering. Only index the document if the version
--   is strictly higher OR the document doesn't exist. The given version
--   will be used as the new version number for the stored document. N.B.
--   All updates must increment this number, meaning there is some global,
--   external ordering of updates.
ExternalGT :: ExternalDocVersion -> VersionControl

-- | Use your own version numbering. Only index the document if the version
--   is equal or higher than the stored version. Will succeed if there is
--   no existing document. The given version will be used as the new
--   version number for the stored document. Use with care, as this could
--   result in data loss.
ExternalGTE :: ExternalDocVersion -> VersionControl

-- | The document will always be indexed and the given version will be the
--   new version. This is typically used for correcting errors. Use with
--   care, as this could result in data loss.
ForceVersion :: ExternalDocVersion -> VersionControl

-- | <a>IndexDocumentSettings</a> are special settings supplied when
--   indexing a document. For the best backwards compatiblity when new
--   fields are added, you should probably prefer to start with
--   <a>defaultIndexDocumentSettings</a>
data IndexDocumentSettings
IndexDocumentSettings :: VersionControl -> IndexDocumentSettings
idsVersionControl :: IndexDocumentSettings -> VersionControl
data Query
TermQuery :: Term -> (Maybe Boost) -> Query
TermsQuery :: (NonEmpty Term) -> Query
QueryMatchQuery :: MatchQuery -> Query
QueryMultiMatchQuery :: MultiMatchQuery -> Query
QueryBoolQuery :: BoolQuery -> Query
QueryBoostingQuery :: BoostingQuery -> Query
QueryCommonTermsQuery :: CommonTermsQuery -> Query
ConstantScoreFilter :: Filter -> Boost -> Query
ConstantScoreQuery :: Query -> Boost -> Query
QueryDisMaxQuery :: DisMaxQuery -> Query
QueryFilteredQuery :: FilteredQuery -> Query
QueryFuzzyLikeThisQuery :: FuzzyLikeThisQuery -> Query
QueryFuzzyLikeFieldQuery :: FuzzyLikeFieldQuery -> Query
QueryFuzzyQuery :: FuzzyQuery -> Query
QueryHasChildQuery :: HasChildQuery -> Query
QueryHasParentQuery :: HasParentQuery -> Query
IdsQuery :: MappingName -> [DocId] -> Query
QueryIndicesQuery :: IndicesQuery -> Query
MatchAllQuery :: (Maybe Boost) -> Query
QueryMoreLikeThisQuery :: MoreLikeThisQuery -> Query
QueryMoreLikeThisFieldQuery :: MoreLikeThisFieldQuery -> Query
QueryNestedQuery :: NestedQuery -> Query
QueryPrefixQuery :: PrefixQuery -> Query
QueryQueryStringQuery :: QueryStringQuery -> Query
QuerySimpleQueryStringQuery :: SimpleQueryStringQuery -> Query
QueryRangeQuery :: RangeQuery -> Query
QueryRegexpQuery :: RegexpQuery -> Query
data Search
Search :: Maybe Query -> Maybe Filter -> Maybe Sort -> Maybe Aggregations -> Maybe Highlights -> TrackSortScores -> From -> Size -> Search
queryBody :: Search -> Maybe Query
filterBody :: Search -> Maybe Filter
sortBody :: Search -> Maybe Sort
aggBody :: Search -> Maybe Aggregations
highlight :: Search -> Maybe Highlights
trackSortScores :: Search -> TrackSortScores
from :: Search -> From
size :: Search -> Size
data SearchResult a
SearchResult :: Int -> Bool -> ShardResult -> SearchHits a -> Maybe AggregationResults -> SearchResult a
took :: SearchResult a -> Int
timedOut :: SearchResult a -> Bool
shards :: SearchResult a -> ShardResult
searchHits :: SearchResult a -> SearchHits a
aggregations :: SearchResult a -> Maybe AggregationResults
data SearchHits a
SearchHits :: Int -> Score -> [Hit a] -> SearchHits a
hitsTotal :: SearchHits a -> Int
maxScore :: SearchHits a -> Score
hits :: SearchHits a -> [Hit a]
type TrackSortScores = Bool
newtype From
From :: Int -> From
newtype Size
Size :: Int -> Size
data ShardResult
ShardResult :: Int -> Int -> Int -> ShardResult
shardTotal :: ShardResult -> Int
shardsSuccessful :: ShardResult -> Int
shardsFailed :: ShardResult -> Int
data Hit a
Hit :: IndexName -> MappingName -> DocId -> Score -> a -> Maybe HitHighlight -> Hit a
hitIndex :: Hit a -> IndexName
hitType :: Hit a -> MappingName
hitDocId :: Hit a -> DocId
hitScore :: Hit a -> Score
hitSource :: Hit a -> a
hitHighlight :: Hit a -> Maybe HitHighlight
data Filter
AndFilter :: [Filter] -> Cache -> Filter
OrFilter :: [Filter] -> Cache -> Filter
NotFilter :: Filter -> Cache -> Filter
IdentityFilter :: Filter
BoolFilter :: BoolMatch -> Filter
ExistsFilter :: FieldName -> Filter
GeoBoundingBoxFilter :: GeoBoundingBoxConstraint -> Filter
GeoDistanceFilter :: GeoPoint -> Distance -> DistanceType -> OptimizeBbox -> Cache -> Filter
GeoDistanceRangeFilter :: GeoPoint -> DistanceRange -> Filter
GeoPolygonFilter :: FieldName -> [LatLon] -> Filter
IdsFilter :: MappingName -> [DocId] -> Filter
LimitFilter :: Int -> Filter
MissingFilter :: FieldName -> Existence -> NullValue -> Filter
PrefixFilter :: FieldName -> PrefixValue -> Cache -> Filter
QueryFilter :: Query -> Cache -> Filter
RangeFilter :: FieldName -> RangeValue -> RangeExecution -> Cache -> Filter
RegexpFilter :: FieldName -> Regexp -> RegexpFlags -> CacheName -> Cache -> CacheKey -> Filter
TermFilter :: Term -> Cache -> Filter
class Monoid a => Seminearring a where (<&&>) = mappend
(<||>) :: Seminearring a => a -> a -> a
(<&&>) :: Seminearring a => a -> a -> a
data BoolMatch
MustMatch :: Term -> Cache -> BoolMatch
MustNotMatch :: Term -> Cache -> BoolMatch
ShouldMatch :: [Term] -> Cache -> BoolMatch
data Term
Term :: Text -> Text -> Term
termField :: Term -> Text
termValue :: Term -> Text
data GeoPoint
GeoPoint :: FieldName -> LatLon -> GeoPoint
geoField :: GeoPoint -> FieldName
latLon :: GeoPoint -> LatLon
data GeoBoundingBoxConstraint
GeoBoundingBoxConstraint :: FieldName -> GeoBoundingBox -> Cache -> GeoFilterType -> GeoBoundingBoxConstraint
geoBBField :: GeoBoundingBoxConstraint -> FieldName
constraintBox :: GeoBoundingBoxConstraint -> GeoBoundingBox
bbConstraintcache :: GeoBoundingBoxConstraint -> Cache
geoType :: GeoBoundingBoxConstraint -> GeoFilterType
data GeoBoundingBox
GeoBoundingBox :: LatLon -> LatLon -> GeoBoundingBox
topLeft :: GeoBoundingBox -> LatLon
bottomRight :: GeoBoundingBox -> LatLon
data GeoFilterType
GeoFilterMemory :: GeoFilterType
GeoFilterIndexed :: GeoFilterType
data Distance
Distance :: Double -> DistanceUnit -> Distance
coefficient :: Distance -> Double
unit :: Distance -> DistanceUnit
data DistanceUnit
Miles :: DistanceUnit
Yards :: DistanceUnit
Feet :: DistanceUnit
Inches :: DistanceUnit
Kilometers :: DistanceUnit
Meters :: DistanceUnit
Centimeters :: DistanceUnit
Millimeters :: DistanceUnit
NauticalMiles :: DistanceUnit
data DistanceType
Arc :: DistanceType
SloppyArc :: DistanceType
Plane :: DistanceType
data DistanceRange
DistanceRange :: Distance -> Distance -> DistanceRange
distanceFrom :: DistanceRange -> Distance
distanceTo :: DistanceRange -> Distance
data OptimizeBbox
OptimizeGeoFilterType :: GeoFilterType -> OptimizeBbox
NoOptimizeBbox :: OptimizeBbox
data LatLon
LatLon :: Double -> Double -> LatLon
lat :: LatLon -> Double
lon :: LatLon -> Double
data RangeValue
RangeDateLte :: LessThanEqD -> RangeValue
RangeDateLt :: LessThanD -> RangeValue
RangeDateGte :: GreaterThanEqD -> RangeValue
RangeDateGt :: GreaterThanD -> RangeValue
RangeDateGtLt :: GreaterThanD -> LessThanD -> RangeValue
RangeDateGteLte :: GreaterThanEqD -> LessThanEqD -> RangeValue
RangeDateGteLt :: GreaterThanEqD -> LessThanD -> RangeValue
RangeDateGtLte :: GreaterThanD -> LessThanEqD -> RangeValue
RangeDoubleLte :: LessThanEq -> RangeValue
RangeDoubleLt :: LessThan -> RangeValue
RangeDoubleGte :: GreaterThanEq -> RangeValue
RangeDoubleGt :: GreaterThan -> RangeValue
RangeDoubleGtLt :: GreaterThan -> LessThan -> RangeValue
RangeDoubleGteLte :: GreaterThanEq -> LessThanEq -> RangeValue
RangeDoubleGteLt :: GreaterThanEq -> LessThan -> RangeValue
RangeDoubleGtLte :: GreaterThan -> LessThanEq -> RangeValue
data RangeExecution
RangeExecutionIndex :: RangeExecution
RangeExecutionFielddata :: RangeExecution
newtype LessThan
LessThan :: Double -> LessThan
newtype LessThanEq
LessThanEq :: Double -> LessThanEq
newtype GreaterThan
GreaterThan :: Double -> GreaterThan
newtype GreaterThanEq
GreaterThanEq :: Double -> GreaterThanEq
newtype LessThanD
LessThanD :: UTCTime -> LessThanD
newtype LessThanEqD
LessThanEqD :: UTCTime -> LessThanEqD
newtype GreaterThanD
GreaterThanD :: UTCTime -> GreaterThanD
newtype GreaterThanEqD
GreaterThanEqD :: UTCTime -> GreaterThanEqD
newtype Regexp
Regexp :: Text -> Regexp
data RegexpFlags
AllRegexpFlags :: RegexpFlags
NoRegexpFlags :: RegexpFlags
SomeRegexpFlags :: (NonEmpty RegexpFlag) -> RegexpFlags
data RegexpFlag
AnyString :: RegexpFlag
Automaton :: RegexpFlag
Complement :: RegexpFlag
Empty :: RegexpFlag
Intersection :: RegexpFlag
Interval :: RegexpFlag

-- | <a>FieldName</a> is used all over the place wherever a specific field
--   within a document needs to be specified, usually in <a>Query</a>s or
--   <a>Filter</a>s.
newtype FieldName
FieldName :: Text -> FieldName

-- | <a>IndexName</a> is used to describe which index to
--   query<i>create</i>delete
newtype IndexName
IndexName :: Text -> IndexName

-- | <a>MappingName</a> is part of mappings which are how ES describes and
--   schematizes the data in the indices.
newtype MappingName
MappingName :: Text -> MappingName

-- | <a>DocId</a> is a generic wrapper value for expressing unique Document
--   IDs. Can be set by the user or created by ES itself. Often used in
--   client functions for poking at specific documents.
newtype DocId
DocId :: Text -> DocId

-- | <a>CacheName</a> is used in <a>RegexpFilter</a> for describing the
--   <a>CacheKey</a> keyed caching behavior.
newtype CacheName
CacheName :: Text -> CacheName

-- | <a>CacheKey</a> is used in <a>RegexpFilter</a> to key regex caching.
newtype CacheKey
CacheKey :: Text -> CacheKey

-- | <a>BulkOperation</a> is a sum type for expressing the four kinds of
--   bulk operation index, create, delete, and update. <a>BulkIndex</a>
--   behaves like an "upsert", <a>BulkCreate</a> will fail if a document
--   already exists at the DocId.
--   
--   
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/docs-bulk.html#docs-bulk</a>
data BulkOperation
BulkIndex :: IndexName -> MappingName -> DocId -> Value -> BulkOperation
BulkCreate :: IndexName -> MappingName -> DocId -> Value -> BulkOperation
BulkDelete :: IndexName -> MappingName -> DocId -> BulkOperation
BulkUpdate :: IndexName -> MappingName -> DocId -> Value -> BulkOperation

-- | <a>ReplicaCount</a> is part of <a>IndexSettings</a>
newtype ReplicaCount
ReplicaCount :: Int -> ReplicaCount

-- | <a>ShardCount</a> is part of <a>IndexSettings</a>
newtype ShardCount
ShardCount :: Int -> ShardCount

-- | <a>Sort</a> is a synonym for a list of <a>SortSpec</a>s. Sort behavior
--   is order dependent with later sorts acting as tie-breakers for earlier
--   sorts.
type Sort = [SortSpec]

-- | <a>SortMode</a> prescribes how to handle sorting array/multi-valued
--   fields.
--   
--   
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-sort.html#_sort_mode_option</a>
data SortMode
SortMin :: SortMode
SortMax :: SortMode
SortSum :: SortMode
SortAvg :: SortMode

-- | <a>SortOrder</a> is <a>Ascending</a> or <a>Descending</a>, as you
--   might expect. These get encoded into "asc" or "desc" when turned into
--   JSON.
--   
--   
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-sort.html#search-request-sort</a>
data SortOrder
Ascending :: SortOrder
Descending :: SortOrder

-- | The two main kinds of <a>SortSpec</a> are <a>DefaultSortSpec</a> and
--   <a>GeoDistanceSortSpec</a>. The latter takes a <a>SortOrder</a>,
--   <a>GeoPoint</a>, and <a>DistanceUnit</a> to express "nearness" to a
--   single geographical point as a sort specification.
--   
--   
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-sort.html#search-request-sort</a>
data SortSpec
DefaultSortSpec :: DefaultSort -> SortSpec
GeoDistanceSortSpec :: SortOrder -> GeoPoint -> DistanceUnit -> SortSpec

-- | <a>DefaultSort</a> is usually the kind of <a>SortSpec</a> you'll want.
--   There's a <a>mkSort</a> convenience function for when you want to
--   specify only the most common parameters.
--   
--   
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-sort.html#search-request-sort</a>
data DefaultSort
DefaultSort :: FieldName -> SortOrder -> Bool -> Maybe SortMode -> Maybe Missing -> Maybe Filter -> DefaultSort
sortFieldName :: DefaultSort -> FieldName
sortOrder :: DefaultSort -> SortOrder
ignoreUnmapped :: DefaultSort -> Bool
sortMode :: DefaultSort -> Maybe SortMode
missingSort :: DefaultSort -> Maybe Missing
nestedFilter :: DefaultSort -> Maybe Filter

-- | <a>Missing</a> prescribes how to handle missing fields. A missing
--   field can be sorted last, first, or using a custom value as a
--   substitute.
--   
--   
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-sort.html#_missing_values</a>
data Missing
LastMissing :: Missing
FirstMissing :: Missing
CustomMissing :: Text -> Missing

-- | <a>OpenCloseIndex</a> is a sum type for opening and closing indices.
--   
--   
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-open-close.html</a>
data OpenCloseIndex
OpenIndex :: OpenCloseIndex
CloseIndex :: OpenCloseIndex
type Method = Method
newtype Boost
Boost :: Double -> Boost
data MatchQuery
MatchQuery :: FieldName -> QueryString -> BooleanOperator -> ZeroTermsQuery -> Maybe CutoffFrequency -> Maybe MatchQueryType -> Maybe Analyzer -> Maybe MaxExpansions -> Maybe Lenient -> MatchQuery
matchQueryField :: MatchQuery -> FieldName
matchQueryQueryString :: MatchQuery -> QueryString
matchQueryOperator :: MatchQuery -> BooleanOperator
matchQueryZeroTerms :: MatchQuery -> ZeroTermsQuery
matchQueryCutoffFrequency :: MatchQuery -> Maybe CutoffFrequency
matchQueryMatchType :: MatchQuery -> Maybe MatchQueryType
matchQueryAnalyzer :: MatchQuery -> Maybe Analyzer
matchQueryMaxExpansions :: MatchQuery -> Maybe MaxExpansions
matchQueryLenient :: MatchQuery -> Maybe Lenient
data MultiMatchQuery
MultiMatchQuery :: [FieldName] -> QueryString -> BooleanOperator -> ZeroTermsQuery -> Maybe Tiebreaker -> Maybe MultiMatchQueryType -> Maybe CutoffFrequency -> Maybe Analyzer -> Maybe MaxExpansions -> Maybe Lenient -> MultiMatchQuery
multiMatchQueryFields :: MultiMatchQuery -> [FieldName]
multiMatchQueryString :: MultiMatchQuery -> QueryString
multiMatchQueryOperator :: MultiMatchQuery -> BooleanOperator
multiMatchQueryZeroTerms :: MultiMatchQuery -> ZeroTermsQuery
multiMatchQueryTiebreaker :: MultiMatchQuery -> Maybe Tiebreaker
multiMatchQueryType :: MultiMatchQuery -> Maybe MultiMatchQueryType
multiMatchQueryCutoffFrequency :: MultiMatchQuery -> Maybe CutoffFrequency
multiMatchQueryAnalyzer :: MultiMatchQuery -> Maybe Analyzer
multiMatchQueryMaxExpansions :: MultiMatchQuery -> Maybe MaxExpansions
multiMatchQueryLenient :: MultiMatchQuery -> Maybe Lenient
data BoolQuery
BoolQuery :: [Query] -> [Query] -> [Query] -> Maybe MinimumMatch -> Maybe Boost -> Maybe DisableCoord -> BoolQuery
boolQueryMustMatch :: BoolQuery -> [Query]
boolQueryMustNotMatch :: BoolQuery -> [Query]
boolQueryShouldMatch :: BoolQuery -> [Query]
boolQueryMinimumShouldMatch :: BoolQuery -> Maybe MinimumMatch
boolQueryBoost :: BoolQuery -> Maybe Boost
boolQueryDisableCoord :: BoolQuery -> Maybe DisableCoord
data BoostingQuery
BoostingQuery :: Query -> Query -> Boost -> BoostingQuery
positiveQuery :: BoostingQuery -> Query
negativeQuery :: BoostingQuery -> Query
negativeBoost :: BoostingQuery -> Boost
data CommonTermsQuery
CommonTermsQuery :: FieldName -> QueryString -> CutoffFrequency -> BooleanOperator -> BooleanOperator -> Maybe CommonMinimumMatch -> Maybe Boost -> Maybe Analyzer -> Maybe DisableCoord -> CommonTermsQuery
commonField :: CommonTermsQuery -> FieldName
commonQuery :: CommonTermsQuery -> QueryString
commonCutoffFrequency :: CommonTermsQuery -> CutoffFrequency
commonLowFreqOperator :: CommonTermsQuery -> BooleanOperator
commonHighFreqOperator :: CommonTermsQuery -> BooleanOperator
commonMinimumShouldMatch :: CommonTermsQuery -> Maybe CommonMinimumMatch
commonBoost :: CommonTermsQuery -> Maybe Boost
commonAnalyzer :: CommonTermsQuery -> Maybe Analyzer
commonDisableCoord :: CommonTermsQuery -> Maybe DisableCoord
data DisMaxQuery
DisMaxQuery :: [Query] -> Tiebreaker -> Maybe Boost -> DisMaxQuery
disMaxQueries :: DisMaxQuery -> [Query]
disMaxTiebreaker :: DisMaxQuery -> Tiebreaker
disMaxBoost :: DisMaxQuery -> Maybe Boost
data FilteredQuery
FilteredQuery :: Query -> Filter -> FilteredQuery
filteredQuery :: FilteredQuery -> Query
filteredFilter :: FilteredQuery -> Filter
data FuzzyLikeThisQuery
FuzzyLikeThisQuery :: [FieldName] -> Text -> MaxQueryTerms -> IgnoreTermFrequency -> Fuzziness -> PrefixLength -> Boost -> Maybe Analyzer -> FuzzyLikeThisQuery
fuzzyLikeFields :: FuzzyLikeThisQuery -> [FieldName]
fuzzyLikeText :: FuzzyLikeThisQuery -> Text
fuzzyLikeMaxQueryTerms :: FuzzyLikeThisQuery -> MaxQueryTerms
fuzzyLikeIgnoreTermFrequency :: FuzzyLikeThisQuery -> IgnoreTermFrequency
fuzzyLikeFuzziness :: FuzzyLikeThisQuery -> Fuzziness
fuzzyLikePrefixLength :: FuzzyLikeThisQuery -> PrefixLength
fuzzyLikeBoost :: FuzzyLikeThisQuery -> Boost
fuzzyLikeAnalyzer :: FuzzyLikeThisQuery -> Maybe Analyzer
data FuzzyLikeFieldQuery
FuzzyLikeFieldQuery :: FieldName -> Text -> MaxQueryTerms -> IgnoreTermFrequency -> Fuzziness -> PrefixLength -> Boost -> Maybe Analyzer -> FuzzyLikeFieldQuery
fuzzyLikeField :: FuzzyLikeFieldQuery -> FieldName
fuzzyLikeFieldText :: FuzzyLikeFieldQuery -> Text
fuzzyLikeFieldMaxQueryTerms :: FuzzyLikeFieldQuery -> MaxQueryTerms
fuzzyLikeFieldIgnoreTermFrequency :: FuzzyLikeFieldQuery -> IgnoreTermFrequency
fuzzyLikeFieldFuzziness :: FuzzyLikeFieldQuery -> Fuzziness
fuzzyLikeFieldPrefixLength :: FuzzyLikeFieldQuery -> PrefixLength
fuzzyLikeFieldBoost :: FuzzyLikeFieldQuery -> Boost
fuzzyLikeFieldAnalyzer :: FuzzyLikeFieldQuery -> Maybe Analyzer
data FuzzyQuery
FuzzyQuery :: FieldName -> Text -> PrefixLength -> MaxExpansions -> Fuzziness -> Maybe Boost -> FuzzyQuery
fuzzyQueryField :: FuzzyQuery -> FieldName
fuzzyQueryValue :: FuzzyQuery -> Text
fuzzyQueryPrefixLength :: FuzzyQuery -> PrefixLength
fuzzyQueryMaxExpansions :: FuzzyQuery -> MaxExpansions
fuzzyQueryFuzziness :: FuzzyQuery -> Fuzziness
fuzzyQueryBoost :: FuzzyQuery -> Maybe Boost
data HasChildQuery
HasChildQuery :: TypeName -> Query -> Maybe ScoreType -> HasChildQuery
hasChildQueryType :: HasChildQuery -> TypeName
hasChildQuery :: HasChildQuery -> Query
hasChildQueryScoreType :: HasChildQuery -> Maybe ScoreType
data HasParentQuery
HasParentQuery :: TypeName -> Query -> Maybe ScoreType -> HasParentQuery
hasParentQueryType :: HasParentQuery -> TypeName
hasParentQuery :: HasParentQuery -> Query
hasParentQueryScoreType :: HasParentQuery -> Maybe ScoreType
data IndicesQuery
IndicesQuery :: [IndexName] -> Query -> Maybe Query -> IndicesQuery
indicesQueryIndices :: IndicesQuery -> [IndexName]
indicesQuery :: IndicesQuery -> Query
indicesQueryNoMatch :: IndicesQuery -> Maybe Query
data MoreLikeThisQuery
MoreLikeThisQuery :: Text -> Maybe [FieldName] -> Maybe PercentMatch -> Maybe MinimumTermFrequency -> Maybe MaxQueryTerms -> Maybe [StopWord] -> Maybe MinDocFrequency -> Maybe MaxDocFrequency -> Maybe MinWordLength -> Maybe MaxWordLength -> Maybe BoostTerms -> Maybe Boost -> Maybe Analyzer -> MoreLikeThisQuery
moreLikeThisText :: MoreLikeThisQuery -> Text
moreLikeThisFields :: MoreLikeThisQuery -> Maybe [FieldName]
moreLikeThisPercentMatch :: MoreLikeThisQuery -> Maybe PercentMatch
moreLikeThisMinimumTermFreq :: MoreLikeThisQuery -> Maybe MinimumTermFrequency
moreLikeThisMaxQueryTerms :: MoreLikeThisQuery -> Maybe MaxQueryTerms
moreLikeThisStopWords :: MoreLikeThisQuery -> Maybe [StopWord]
moreLikeThisMinDocFrequency :: MoreLikeThisQuery -> Maybe MinDocFrequency
moreLikeThisMaxDocFrequency :: MoreLikeThisQuery -> Maybe MaxDocFrequency
moreLikeThisMinWordLength :: MoreLikeThisQuery -> Maybe MinWordLength
moreLikeThisMaxWordLength :: MoreLikeThisQuery -> Maybe MaxWordLength
moreLikeThisBoostTerms :: MoreLikeThisQuery -> Maybe BoostTerms
moreLikeThisBoost :: MoreLikeThisQuery -> Maybe Boost
moreLikeThisAnalyzer :: MoreLikeThisQuery -> Maybe Analyzer
data MoreLikeThisFieldQuery
MoreLikeThisFieldQuery :: Text -> FieldName -> Maybe PercentMatch -> Maybe MinimumTermFrequency -> Maybe MaxQueryTerms -> Maybe [StopWord] -> Maybe MinDocFrequency -> Maybe MaxDocFrequency -> Maybe MinWordLength -> Maybe MaxWordLength -> Maybe BoostTerms -> Maybe Boost -> Maybe Analyzer -> MoreLikeThisFieldQuery
moreLikeThisFieldText :: MoreLikeThisFieldQuery -> Text
moreLikeThisFieldFields :: MoreLikeThisFieldQuery -> FieldName
moreLikeThisFieldPercentMatch :: MoreLikeThisFieldQuery -> Maybe PercentMatch
moreLikeThisFieldMinimumTermFreq :: MoreLikeThisFieldQuery -> Maybe MinimumTermFrequency
moreLikeThisFieldMaxQueryTerms :: MoreLikeThisFieldQuery -> Maybe MaxQueryTerms
moreLikeThisFieldStopWords :: MoreLikeThisFieldQuery -> Maybe [StopWord]
moreLikeThisFieldMinDocFrequency :: MoreLikeThisFieldQuery -> Maybe MinDocFrequency
moreLikeThisFieldMaxDocFrequency :: MoreLikeThisFieldQuery -> Maybe MaxDocFrequency
moreLikeThisFieldMinWordLength :: MoreLikeThisFieldQuery -> Maybe MinWordLength
moreLikeThisFieldMaxWordLength :: MoreLikeThisFieldQuery -> Maybe MaxWordLength
moreLikeThisFieldBoostTerms :: MoreLikeThisFieldQuery -> Maybe BoostTerms
moreLikeThisFieldBoost :: MoreLikeThisFieldQuery -> Maybe Boost
moreLikeThisFieldAnalyzer :: MoreLikeThisFieldQuery -> Maybe Analyzer
data NestedQuery
NestedQuery :: QueryPath -> ScoreType -> Query -> NestedQuery
nestedQueryPath :: NestedQuery -> QueryPath
nestedQueryScoreType :: NestedQuery -> ScoreType
nestedQuery :: NestedQuery -> Query
data PrefixQuery
PrefixQuery :: FieldName -> Text -> Maybe Boost -> PrefixQuery
prefixQueryField :: PrefixQuery -> FieldName
prefixQueryPrefixValue :: PrefixQuery -> Text
prefixQueryBoost :: PrefixQuery -> Maybe Boost
data QueryStringQuery
QueryStringQuery :: QueryString -> Maybe FieldName -> Maybe BooleanOperator -> Maybe Analyzer -> Maybe AllowLeadingWildcard -> Maybe LowercaseExpanded -> Maybe EnablePositionIncrements -> Maybe MaxExpansions -> Maybe Fuzziness -> Maybe PrefixLength -> Maybe PhraseSlop -> Maybe Boost -> Maybe AnalyzeWildcard -> Maybe GeneratePhraseQueries -> Maybe MinimumMatch -> Maybe Lenient -> Maybe Locale -> QueryStringQuery
queryStringQuery :: QueryStringQuery -> QueryString
queryStringDefaultField :: QueryStringQuery -> Maybe FieldName
queryStringOperator :: QueryStringQuery -> Maybe BooleanOperator
queryStringAnalyzer :: QueryStringQuery -> Maybe Analyzer
queryStringAllowLeadingWildcard :: QueryStringQuery -> Maybe AllowLeadingWildcard
queryStringLowercaseExpanded :: QueryStringQuery -> Maybe LowercaseExpanded
queryStringEnablePositionIncrements :: QueryStringQuery -> Maybe EnablePositionIncrements
queryStringFuzzyMaxExpansions :: QueryStringQuery -> Maybe MaxExpansions
queryStringFuzziness :: QueryStringQuery -> Maybe Fuzziness
queryStringFuzzyPrefixLength :: QueryStringQuery -> Maybe PrefixLength
queryStringPhraseSlop :: QueryStringQuery -> Maybe PhraseSlop
queryStringBoost :: QueryStringQuery -> Maybe Boost
queryStringAnalyzeWildcard :: QueryStringQuery -> Maybe AnalyzeWildcard
queryStringGeneratePhraseQueries :: QueryStringQuery -> Maybe GeneratePhraseQueries
queryStringMinimumShouldMatch :: QueryStringQuery -> Maybe MinimumMatch
queryStringLenient :: QueryStringQuery -> Maybe Lenient
queryStringLocale :: QueryStringQuery -> Maybe Locale
data SimpleQueryStringQuery
SimpleQueryStringQuery :: QueryString -> Maybe FieldOrFields -> Maybe BooleanOperator -> Maybe Analyzer -> Maybe [SimpleQueryFlag] -> Maybe LowercaseExpanded -> Maybe Locale -> SimpleQueryStringQuery
simpleQueryStringQuery :: SimpleQueryStringQuery -> QueryString
simpleQueryStringField :: SimpleQueryStringQuery -> Maybe FieldOrFields
simpleQueryStringOperator :: SimpleQueryStringQuery -> Maybe BooleanOperator
simpleQueryStringAnalyzer :: SimpleQueryStringQuery -> Maybe Analyzer
simpleQueryStringFlags :: SimpleQueryStringQuery -> Maybe [SimpleQueryFlag]
simpleQueryStringLowercaseExpanded :: SimpleQueryStringQuery -> Maybe LowercaseExpanded
simpleQueryStringLocale :: SimpleQueryStringQuery -> Maybe Locale
data RangeQuery
RangeQuery :: FieldName -> RangeValue -> Boost -> RangeQuery
rangeQueryField :: RangeQuery -> FieldName
rangeQueryRange :: RangeQuery -> RangeValue
rangeQueryBoost :: RangeQuery -> Boost
data RegexpQuery
RegexpQuery :: FieldName -> Regexp -> RegexpFlags -> Maybe Boost -> RegexpQuery
regexpQueryField :: RegexpQuery -> FieldName
regexpQuery :: RegexpQuery -> Regexp
regexpQueryFlags :: RegexpQuery -> RegexpFlags
regexpQueryBoost :: RegexpQuery -> Maybe Boost

-- | <a>QueryString</a> is used to wrap query text bodies, be they human
--   written or not.
newtype QueryString
QueryString :: Text -> QueryString

-- | <a>BooleanOperator</a> is the usual And/Or operators with an ES
--   compatible JSON encoding baked in. Used all over the place.
data BooleanOperator
And :: BooleanOperator
Or :: BooleanOperator
data ZeroTermsQuery
ZeroTermsNone :: ZeroTermsQuery
ZeroTermsAll :: ZeroTermsQuery
newtype CutoffFrequency
CutoffFrequency :: Double -> CutoffFrequency
newtype Analyzer
Analyzer :: Text -> Analyzer
newtype MaxExpansions
MaxExpansions :: Int -> MaxExpansions

-- | <a>Lenient</a>, if set to true, will cause format based failures to be
--   ignored. I don't know what the bloody default is, Elasticsearch
--   documentation didn't say what it was. Let me know if you figure it
--   out.
newtype Lenient
Lenient :: Bool -> Lenient
data MatchQueryType
MatchPhrase :: MatchQueryType
MatchPhrasePrefix :: MatchQueryType
data MultiMatchQueryType
MultiMatchBestFields :: MultiMatchQueryType
MultiMatchMostFields :: MultiMatchQueryType
MultiMatchCrossFields :: MultiMatchQueryType
MultiMatchPhrase :: MultiMatchQueryType
MultiMatchPhrasePrefix :: MultiMatchQueryType
newtype Tiebreaker
Tiebreaker :: Double -> Tiebreaker

-- | <a>MinimumMatch</a> controls how many should clauses in the bool query
--   should match. Can be an absolute value (2) or a percentage (30%) or a
--   combination of both.
newtype MinimumMatch
MinimumMatch :: Int -> MinimumMatch
newtype DisableCoord
DisableCoord :: Bool -> DisableCoord
data CommonMinimumMatch
CommonMinimumMatchHighLow :: MinimumMatchHighLow -> CommonMinimumMatch
CommonMinimumMatch :: MinimumMatch -> CommonMinimumMatch
data MinimumMatchHighLow
MinimumMatchHighLow :: MinimumMatch -> MinimumMatch -> MinimumMatchHighLow
lowFreq :: MinimumMatchHighLow -> MinimumMatch
highFreq :: MinimumMatchHighLow -> MinimumMatch

-- | <a>PrefixLength</a> is the prefix length used in queries, defaults to
--   0.
newtype PrefixLength
PrefixLength :: Int -> PrefixLength
newtype Fuzziness
Fuzziness :: Double -> Fuzziness
newtype IgnoreTermFrequency
IgnoreTermFrequency :: Bool -> IgnoreTermFrequency
newtype MaxQueryTerms
MaxQueryTerms :: Int -> MaxQueryTerms
data ScoreType
ScoreTypeMax :: ScoreType
ScoreTypeSum :: ScoreType
ScoreTypeAvg :: ScoreType
ScoreTypeNone :: ScoreType
type Score = Maybe Double

-- | <a>Cache</a> is for telling ES whether it should cache a <a>Filter</a>
--   not. <a>Query</a>s cannot be cached.
type Cache = Bool
newtype TypeName
TypeName :: Text -> TypeName
newtype BoostTerms
BoostTerms :: Double -> BoostTerms
newtype MaxWordLength
MaxWordLength :: Int -> MaxWordLength
newtype MinWordLength
MinWordLength :: Int -> MinWordLength
newtype MaxDocFrequency
MaxDocFrequency :: Int -> MaxDocFrequency
newtype MinDocFrequency
MinDocFrequency :: Int -> MinDocFrequency

-- | <a>PhraseSlop</a> sets the default slop for phrases, 0 means exact
--   phrase matches. Default is 0.
newtype PhraseSlop
PhraseSlop :: Int -> PhraseSlop
newtype StopWord
StopWord :: Text -> StopWord
newtype QueryPath
QueryPath :: Text -> QueryPath
newtype MinimumTermFrequency
MinimumTermFrequency :: Int -> MinimumTermFrequency
newtype PercentMatch
PercentMatch :: Double -> PercentMatch
data FieldDefinition
FieldDefinition :: FieldType -> FieldDefinition
fieldType :: FieldDefinition -> FieldType
data MappingField
MappingField :: FieldName -> FieldDefinition -> MappingField
mappingFieldName :: MappingField -> FieldName
fieldDefinition :: MappingField -> FieldDefinition

-- | Support for type reification of <a>Mapping</a>s is currently
--   incomplete, for now the mapping API verbiage expects a
--   <a>ToJSON</a>able blob.
--   
--   Indexes have mappings, mappings are schemas for the documents
--   contained in the index. I'd recommend having only one mapping per
--   index, always having a mapping, and keeping different kinds of
--   documents separated if possible.
data Mapping
Mapping :: TypeName -> [MappingField] -> Mapping
typeName :: Mapping -> TypeName
mappingFields :: Mapping -> [MappingField]

-- | Allowing a wildcard at the beginning of a word (eg "*ing") is
--   particularly heavy, because all terms in the index need to be
--   examined, just in case they match. Leading wildcards can be disabled
--   by setting <a>AllowLeadingWildcard</a> to false.
newtype AllowLeadingWildcard
AllowLeadingWildcard :: Bool -> AllowLeadingWildcard
newtype LowercaseExpanded
LowercaseExpanded :: Bool -> LowercaseExpanded

-- | <a>GeneratePhraseQueries</a> defaults to false.
newtype GeneratePhraseQueries
GeneratePhraseQueries :: Bool -> GeneratePhraseQueries

-- | <a>Locale</a> is used for string conversions - defaults to ROOT.
newtype Locale
Locale :: Text -> Locale

-- | By default, wildcard terms in a query are not analyzed. Setting
--   <a>AnalyzeWildcard</a> to true enables best-effort analysis.
newtype AnalyzeWildcard
AnalyzeWildcard :: Bool -> AnalyzeWildcard
newtype EnablePositionIncrements
EnablePositionIncrements :: Bool -> EnablePositionIncrements
data SimpleQueryFlag
SimpleQueryAll :: SimpleQueryFlag
SimpleQueryNone :: SimpleQueryFlag
SimpleQueryAnd :: SimpleQueryFlag
SimpleQueryOr :: SimpleQueryFlag
SimpleQueryPrefix :: SimpleQueryFlag
SimpleQueryPhrase :: SimpleQueryFlag
SimpleQueryPrecedence :: SimpleQueryFlag
SimpleQueryEscape :: SimpleQueryFlag
SimpleQueryWhitespace :: SimpleQueryFlag
SimpleQueryFuzzy :: SimpleQueryFlag
SimpleQueryNear :: SimpleQueryFlag
SimpleQuerySlop :: SimpleQueryFlag
data FieldOrFields
FofField :: FieldName -> FieldOrFields
FofFields :: [FieldName] -> FieldOrFields

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a
class ToJSON a
toJSON :: ToJSON a => a -> Value
data Interval
Year :: Interval
Quarter :: Interval
Month :: Interval
Week :: Interval
Day :: Interval
Hour :: Interval
Minute :: Interval
Second :: Interval
FractionalInterval :: Float -> TimeInterval -> Interval
data TimeInterval
Weeks :: TimeInterval
Days :: TimeInterval
Hours :: TimeInterval
Minutes :: TimeInterval
Seconds :: TimeInterval
data ExecutionHint
Ordinals :: ExecutionHint
GlobalOrdinals :: ExecutionHint
GlobalOrdinalsHash :: ExecutionHint
GlobalOrdinalsLowCardinality :: ExecutionHint
Map :: ExecutionHint
data CollectionMode
BreadthFirst :: CollectionMode
DepthFirst :: CollectionMode
data TermOrder
TermOrder :: Text -> SortOrder -> TermOrder
termSortField :: TermOrder -> Text
termSortOrder :: TermOrder -> SortOrder
data TermInclusion
TermInclusion :: Text -> TermInclusion
TermPattern :: Text -> Text -> TermInclusion
data Aggregation
TermsAgg :: TermsAggregation -> Aggregation
DateHistogramAgg :: DateHistogramAggregation -> Aggregation
type Aggregations = Map Text Aggregation
type AggregationResults = Map Text Value
data Bucket a
Bucket :: [a] -> Bucket a
buckets :: Bucket a -> [a]
class BucketAggregation a
key :: BucketAggregation a => a -> Text
docCount :: BucketAggregation a => a -> Int
aggs :: BucketAggregation a => a -> Maybe AggregationResults
data TermsAggregation
TermsAggregation :: Either Text Text -> Maybe TermInclusion -> Maybe TermInclusion -> Maybe TermOrder -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe CollectionMode -> Maybe ExecutionHint -> Maybe Aggregations -> TermsAggregation
term :: TermsAggregation -> Either Text Text
termInclude :: TermsAggregation -> Maybe TermInclusion
termExclude :: TermsAggregation -> Maybe TermInclusion
termOrder :: TermsAggregation -> Maybe TermOrder
termMinDocCount :: TermsAggregation -> Maybe Int
termSize :: TermsAggregation -> Maybe Int
termShardSize :: TermsAggregation -> Maybe Int
termCollectMode :: TermsAggregation -> Maybe CollectionMode
termExecutionHint :: TermsAggregation -> Maybe ExecutionHint
termAggs :: TermsAggregation -> Maybe Aggregations
data DateHistogramAggregation
DateHistogramAggregation :: FieldName -> Interval -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Aggregations -> DateHistogramAggregation
dateField :: DateHistogramAggregation -> FieldName
dateInterval :: DateHistogramAggregation -> Interval
dateFormat :: DateHistogramAggregation -> Maybe Text
datePreZone :: DateHistogramAggregation -> Maybe Text
datePostZone :: DateHistogramAggregation -> Maybe Text
datePreOffset :: DateHistogramAggregation -> Maybe Text
datePostOffset :: DateHistogramAggregation -> Maybe Text
dateAggs :: DateHistogramAggregation -> Maybe Aggregations
data Highlights
Highlights :: Maybe HighlightSettings -> [FieldHighlight] -> Highlights
globalsettings :: Highlights -> Maybe HighlightSettings
highlightFields :: Highlights -> [FieldHighlight]
data FieldHighlight
FieldHighlight :: FieldName -> (Maybe HighlightSettings) -> FieldHighlight
data HighlightSettings
Plain :: PlainHighlight -> HighlightSettings
Postings :: PostingsHighlight -> HighlightSettings
FastVector :: FastVectorHighlight -> HighlightSettings
data PlainHighlight
PlainHighlight :: Maybe CommonHighlight -> Maybe NonPostings -> PlainHighlight
plainCommon :: PlainHighlight -> Maybe CommonHighlight
plainNonPost :: PlainHighlight -> Maybe NonPostings
data PostingsHighlight
PostingsHighlight :: (Maybe CommonHighlight) -> PostingsHighlight
data FastVectorHighlight
FastVectorHighlight :: Maybe CommonHighlight -> Maybe NonPostings -> Maybe Text -> Maybe Int -> Maybe Int -> [Text] -> Maybe Int -> FastVectorHighlight
fvCommon :: FastVectorHighlight -> Maybe CommonHighlight
fvNonPostSettings :: FastVectorHighlight -> Maybe NonPostings
boundaryChars :: FastVectorHighlight -> Maybe Text
boundaryMaxScan :: FastVectorHighlight -> Maybe Int
fragmentOffset :: FastVectorHighlight -> Maybe Int
matchedFields :: FastVectorHighlight -> [Text]
phraseLimit :: FastVectorHighlight -> Maybe Int
data CommonHighlight
CommonHighlight :: Maybe Text -> Maybe Bool -> Maybe HighlightTag -> Maybe HighlightEncoder -> Maybe Int -> Maybe Query -> Maybe Bool -> CommonHighlight
order :: CommonHighlight -> Maybe Text
forceSource :: CommonHighlight -> Maybe Bool
tag :: CommonHighlight -> Maybe HighlightTag
encoder :: CommonHighlight -> Maybe HighlightEncoder
noMatchSize :: CommonHighlight -> Maybe Int
highlightQuery :: CommonHighlight -> Maybe Query
requireFieldMatch :: CommonHighlight -> Maybe Bool
data NonPostings
NonPostings :: Maybe Int -> Maybe Int -> NonPostings
fragmentSize :: NonPostings -> Maybe Int
numberOfFragments :: NonPostings -> Maybe Int
data HighlightEncoder
DefaultEncoder :: HighlightEncoder
HTMLEncoder :: HighlightEncoder
data HighlightTag
TagSchema :: Text -> HighlightTag
CustomTags :: ([Text], [Text]) -> HighlightTag
type HitHighlight = Map Text [Text]
data TermsResult
TermsResult :: Text -> Int -> Maybe AggregationResults -> TermsResult
termKey :: TermsResult -> Text
termsDocCount :: TermsResult -> Int
termsAggs :: TermsResult -> Maybe AggregationResults
data DateHistogramResult
DateHistogramResult :: Int -> Maybe Text -> Int -> Maybe AggregationResults -> DateHistogramResult
dateKey :: DateHistogramResult -> Int
dateKeyStr :: DateHistogramResult -> Maybe Text
dateDocCount :: DateHistogramResult -> Int
dateHistogramAggs :: DateHistogramResult -> Maybe AggregationResults
instance Eq Version
instance Show Version
instance Generic Version
instance Eq Status
instance Show Status
instance Eq OpenCloseIndex
instance Show OpenCloseIndex
instance Eq FieldType
instance Show FieldType
instance Eq FieldDefinition
instance Show FieldDefinition
instance Eq DocVersion
instance Show DocVersion
instance Ord DocVersion
instance ToJSON DocVersion
instance Eq a => Eq (EsResult a)
instance Show a => Show (EsResult a)
instance Eq ExternalDocVersion
instance Show ExternalDocVersion
instance Ord ExternalDocVersion
instance Bounded ExternalDocVersion
instance Enum ExternalDocVersion
instance ToJSON ExternalDocVersion
instance Show VersionControl
instance Eq VersionControl
instance Ord VersionControl
instance Eq SortOrder
instance Show SortOrder
instance Eq Missing
instance Show Missing
instance Eq SortMode
instance Show SortMode
instance Eq BooleanOperator
instance Show BooleanOperator
instance Eq ShardCount
instance Show ShardCount
instance Generic ShardCount
instance Eq ReplicaCount
instance Show ReplicaCount
instance Generic ReplicaCount
instance Eq IndexSettings
instance Show IndexSettings
instance Eq Server
instance Show Server
instance Functor m => Functor (BH m)
instance Applicative m => Applicative (BH m)
instance Monad m => Monad (BH m)
instance MonadIO m => MonadIO (BH m)
instance MonadState s m => MonadState s (BH m)
instance MonadWriter w m => MonadWriter w (BH m)
instance MonadError e m => MonadError e (BH m)
instance Alternative m => Alternative (BH m)
instance MonadPlus m => MonadPlus (BH m)
instance MonadFix m => MonadFix (BH m)
instance Eq IndexName
instance Generic IndexName
instance Show IndexName
instance Eq MappingName
instance Generic MappingName
instance Show MappingName
instance Eq DocId
instance Generic DocId
instance Show DocId
instance Eq BulkOperation
instance Show BulkOperation
instance Eq QueryString
instance Generic QueryString
instance Show QueryString
instance Eq FieldName
instance Show FieldName
instance Eq MappingField
instance Show MappingField
instance Eq CacheName
instance Show CacheName
instance Eq CacheKey
instance Show CacheKey
instance Eq Existence
instance Show Existence
instance Eq NullValue
instance Show NullValue
instance Eq CutoffFrequency
instance Show CutoffFrequency
instance Generic CutoffFrequency
instance Eq Analyzer
instance Show Analyzer
instance Generic Analyzer
instance Eq MaxExpansions
instance Show MaxExpansions
instance Generic MaxExpansions
instance Eq Lenient
instance Show Lenient
instance Generic Lenient
instance Eq Tiebreaker
instance Show Tiebreaker
instance Generic Tiebreaker
instance Eq Boost
instance Show Boost
instance Generic Boost
instance Eq BoostTerms
instance Show BoostTerms
instance Generic BoostTerms
instance Eq MinimumMatch
instance Show MinimumMatch
instance Generic MinimumMatch
instance Eq MinimumMatchText
instance Show MinimumMatchText
instance Eq DisableCoord
instance Show DisableCoord
instance Generic DisableCoord
instance Eq IgnoreTermFrequency
instance Show IgnoreTermFrequency
instance Generic IgnoreTermFrequency
instance Eq MinimumTermFrequency
instance Show MinimumTermFrequency
instance Generic MinimumTermFrequency
instance Eq MaxQueryTerms
instance Show MaxQueryTerms
instance Generic MaxQueryTerms
instance Eq Fuzziness
instance Show Fuzziness
instance Generic Fuzziness
instance Eq PrefixLength
instance Show PrefixLength
instance Generic PrefixLength
instance Eq TypeName
instance Show TypeName
instance Generic TypeName
instance Eq Mapping
instance Show Mapping
instance Eq PercentMatch
instance Show PercentMatch
instance Generic PercentMatch
instance Eq StopWord
instance Show StopWord
instance Generic StopWord
instance Eq QueryPath
instance Show QueryPath
instance Generic QueryPath
instance Eq AllowLeadingWildcard
instance Show AllowLeadingWildcard
instance Generic AllowLeadingWildcard
instance Eq LowercaseExpanded
instance Show LowercaseExpanded
instance Generic LowercaseExpanded
instance Eq EnablePositionIncrements
instance Show EnablePositionIncrements
instance Generic EnablePositionIncrements
instance Eq AnalyzeWildcard
instance Show AnalyzeWildcard
instance Generic AnalyzeWildcard
instance Eq GeneratePhraseQueries
instance Show GeneratePhraseQueries
instance Generic GeneratePhraseQueries
instance Eq Locale
instance Show Locale
instance Generic Locale
instance Eq MaxWordLength
instance Show MaxWordLength
instance Generic MaxWordLength
instance Eq MinWordLength
instance Show MinWordLength
instance Generic MinWordLength
instance Eq PhraseSlop
instance Show PhraseSlop
instance Generic PhraseSlop
instance Eq MinDocFrequency
instance Show MinDocFrequency
instance Generic MinDocFrequency
instance Eq MaxDocFrequency
instance Show MaxDocFrequency
instance Generic MaxDocFrequency
instance Eq From
instance Show From
instance ToJSON From
instance Eq Size
instance Show Size
instance ToJSON Size
instance Show NonPostings
instance Eq NonPostings
instance Show HighlightEncoder
instance Eq HighlightEncoder
instance Show HighlightTag
instance Eq HighlightTag
instance Eq SimpleQueryFlag
instance Show SimpleQueryFlag
instance Eq QueryStringQuery
instance Show QueryStringQuery
instance Eq FieldOrFields
instance Show FieldOrFields
instance Eq SimpleQueryStringQuery
instance Show SimpleQueryStringQuery
instance Eq PrefixQuery
instance Show PrefixQuery
instance Eq MoreLikeThisFieldQuery
instance Show MoreLikeThisFieldQuery
instance Eq MoreLikeThisQuery
instance Show MoreLikeThisQuery
instance Eq ScoreType
instance Show ScoreType
instance Eq FuzzyQuery
instance Show FuzzyQuery
instance Eq FuzzyLikeFieldQuery
instance Show FuzzyLikeFieldQuery
instance Eq FuzzyLikeThisQuery
instance Show FuzzyLikeThisQuery
instance Eq MatchQueryType
instance Show MatchQueryType
instance Eq MultiMatchQueryType
instance Show MultiMatchQueryType
instance Eq MinimumMatchHighLow
instance Show MinimumMatchHighLow
instance Eq CommonMinimumMatch
instance Show CommonMinimumMatch
instance Eq CommonTermsQuery
instance Show CommonTermsQuery
instance Eq ZeroTermsQuery
instance Show ZeroTermsQuery
instance Eq MultiMatchQuery
instance Show MultiMatchQuery
instance Eq MatchQuery
instance Show MatchQuery
instance Eq RangeExecution
instance Show RangeExecution
instance Eq Regexp
instance Show Regexp
instance Eq RegexpFlag
instance Show RegexpFlag
instance Eq RegexpFlags
instance Show RegexpFlags
instance Eq RegexpQuery
instance Show RegexpQuery
instance Eq LessThan
instance Show LessThan
instance Eq LessThanEq
instance Show LessThanEq
instance Eq GreaterThan
instance Show GreaterThan
instance Eq GreaterThanEq
instance Show GreaterThanEq
instance Eq LessThanD
instance Show LessThanD
instance Eq LessThanEqD
instance Show LessThanEqD
instance Eq GreaterThanD
instance Show GreaterThanD
instance Eq GreaterThanEqD
instance Show GreaterThanEqD
instance Eq RangeValue
instance Show RangeValue
instance Eq RangeQuery
instance Show RangeQuery
instance Eq Term
instance Show Term
instance Eq BoolMatch
instance Show BoolMatch
instance Eq GeoFilterType
instance Show GeoFilterType
instance Eq LatLon
instance Show LatLon
instance Eq GeoBoundingBox
instance Show GeoBoundingBox
instance Eq GeoBoundingBoxConstraint
instance Show GeoBoundingBoxConstraint
instance Eq GeoPoint
instance Show GeoPoint
instance Eq DistanceUnit
instance Show DistanceUnit
instance Eq DistanceType
instance Show DistanceType
instance Eq OptimizeBbox
instance Show OptimizeBbox
instance Eq Distance
instance Show Distance
instance Eq DistanceRange
instance Show DistanceRange
instance Eq Filter
instance Show Filter
instance Eq Query
instance Show Query
instance Eq BoostingQuery
instance Show BoostingQuery
instance Eq BoolQuery
instance Show BoolQuery
instance Eq DisMaxQuery
instance Show DisMaxQuery
instance Eq FilteredQuery
instance Show FilteredQuery
instance Eq HasChildQuery
instance Show HasChildQuery
instance Eq HasParentQuery
instance Show HasParentQuery
instance Eq IndicesQuery
instance Show IndicesQuery
instance Eq NestedQuery
instance Show NestedQuery
instance Show CommonHighlight
instance Eq CommonHighlight
instance Show FastVectorHighlight
instance Eq FastVectorHighlight
instance Show PostingsHighlight
instance Eq PostingsHighlight
instance Show PlainHighlight
instance Eq PlainHighlight
instance Show HighlightSettings
instance Eq HighlightSettings
instance Show FieldHighlight
instance Eq FieldHighlight
instance Show Highlights
instance Eq Highlights
instance Eq DefaultSort
instance Show DefaultSort
instance Eq SortSpec
instance Show SortSpec
instance Eq ShardResult
instance Show ShardResult
instance Generic ShardResult
instance Eq a => Eq (Hit a)
instance Show a => Show (Hit a)
instance Eq a => Eq (SearchHits a)
instance Show a => Show (SearchHits a)
instance Eq TermOrder
instance Show TermOrder
instance Eq TermInclusion
instance Show TermInclusion
instance Eq CollectionMode
instance Show CollectionMode
instance Eq ExecutionHint
instance Show ExecutionHint
instance Eq TimeInterval
instance Eq Interval
instance Show Interval
instance Eq DateHistogramAggregation
instance Show DateHistogramAggregation
instance Eq Aggregation
instance Show Aggregation
instance Eq TermsAggregation
instance Show TermsAggregation
instance Eq Search
instance Show Search
instance Eq a => Eq (SearchResult a)
instance Show a => Show (SearchResult a)
instance Show a => Show (Bucket a)
instance Show TermsResult
instance Show DateHistogramResult
instance Datatype D1Version
instance Constructor C1_0Version
instance Selector S1_0_0Version
instance Selector S1_0_1Version
instance Selector S1_0_2Version
instance Selector S1_0_3Version
instance Selector S1_0_4Version
instance Datatype D1ShardCount
instance Constructor C1_0ShardCount
instance Datatype D1ReplicaCount
instance Constructor C1_0ReplicaCount
instance Datatype D1IndexName
instance Constructor C1_0IndexName
instance Datatype D1MappingName
instance Constructor C1_0MappingName
instance Datatype D1DocId
instance Constructor C1_0DocId
instance Datatype D1QueryString
instance Constructor C1_0QueryString
instance Datatype D1CutoffFrequency
instance Constructor C1_0CutoffFrequency
instance Datatype D1Analyzer
instance Constructor C1_0Analyzer
instance Datatype D1MaxExpansions
instance Constructor C1_0MaxExpansions
instance Datatype D1Lenient
instance Constructor C1_0Lenient
instance Datatype D1Tiebreaker
instance Constructor C1_0Tiebreaker
instance Datatype D1Boost
instance Constructor C1_0Boost
instance Datatype D1BoostTerms
instance Constructor C1_0BoostTerms
instance Datatype D1MinimumMatch
instance Constructor C1_0MinimumMatch
instance Datatype D1DisableCoord
instance Constructor C1_0DisableCoord
instance Datatype D1IgnoreTermFrequency
instance Constructor C1_0IgnoreTermFrequency
instance Datatype D1MinimumTermFrequency
instance Constructor C1_0MinimumTermFrequency
instance Datatype D1MaxQueryTerms
instance Constructor C1_0MaxQueryTerms
instance Datatype D1Fuzziness
instance Constructor C1_0Fuzziness
instance Datatype D1PrefixLength
instance Constructor C1_0PrefixLength
instance Datatype D1TypeName
instance Constructor C1_0TypeName
instance Datatype D1PercentMatch
instance Constructor C1_0PercentMatch
instance Datatype D1StopWord
instance Constructor C1_0StopWord
instance Datatype D1QueryPath
instance Constructor C1_0QueryPath
instance Datatype D1AllowLeadingWildcard
instance Constructor C1_0AllowLeadingWildcard
instance Datatype D1LowercaseExpanded
instance Constructor C1_0LowercaseExpanded
instance Datatype D1EnablePositionIncrements
instance Constructor C1_0EnablePositionIncrements
instance Datatype D1AnalyzeWildcard
instance Constructor C1_0AnalyzeWildcard
instance Datatype D1GeneratePhraseQueries
instance Constructor C1_0GeneratePhraseQueries
instance Datatype D1Locale
instance Constructor C1_0Locale
instance Datatype D1MaxWordLength
instance Constructor C1_0MaxWordLength
instance Datatype D1MinWordLength
instance Constructor C1_0MinWordLength
instance Datatype D1PhraseSlop
instance Constructor C1_0PhraseSlop
instance Datatype D1MinDocFrequency
instance Constructor C1_0MinDocFrequency
instance Datatype D1MaxDocFrequency
instance Constructor C1_0MaxDocFrequency
instance Datatype D1ShardResult
instance Constructor C1_0ShardResult
instance Selector S1_0_0ShardResult
instance Selector S1_0_1ShardResult
instance Selector S1_0_2ShardResult
instance Enum DocVersion
instance Bounded DocVersion
instance FromJSON DocVersion
instance FromJSON ShardResult
instance FromJSON a => FromJSON (Hit a)
instance FromJSON a => FromJSON (SearchHits a)
instance FromJSON a => FromJSON (SearchResult a)
instance ToJSON BoolMatch
instance ToJSON Term
instance ToJSON RegexpFlags
instance ToJSON RangeExecution
instance ToJSON LatLon
instance ToJSON GeoBoundingBox
instance ToJSON GeoFilterType
instance ToJSON GeoBoundingBoxConstraint
instance ToJSON OptimizeBbox
instance ToJSON DistanceType
instance ToJSON DistanceUnit
instance ToJSON Distance
instance ToJSON ScoreType
instance ToJSON Missing
instance ToJSON SortMode
instance ToJSON SortOrder
instance ToJSON SortSpec
instance ToJSON HighlightEncoder
instance ToJSON HighlightSettings
instance ToJSON Highlights
instance ToJSON FieldHighlight
instance ToJSON Search
instance FromJSON a => FromJSON (EsResult a)
instance ToJSON IndexSettings
instance FromJSON Status
instance FromJSON DocId
instance FromJSON MappingName
instance FromJSON IndexName
instance FromJSON Version
instance ToJSON EnablePositionIncrements
instance ToJSON Locale
instance ToJSON GeneratePhraseQueries
instance ToJSON AnalyzeWildcard
instance ToJSON LowercaseExpanded
instance ToJSON AllowLeadingWildcard
instance ToJSON QueryString
instance ToJSON DocId
instance ToJSON MappingName
instance ToJSON PercentMatch
instance ToJSON MinimumTermFrequency
instance ToJSON QueryPath
instance ToJSON StopWord
instance ToJSON PhraseSlop
instance ToJSON MinDocFrequency
instance ToJSON MaxDocFrequency
instance ToJSON MinWordLength
instance ToJSON MaxWordLength
instance ToJSON BoostTerms
instance ToJSON IndexName
instance ToJSON TypeName
instance ToJSON MaxQueryTerms
instance ToJSON IgnoreTermFrequency
instance ToJSON Fuzziness
instance ToJSON PrefixLength
instance ToJSON DisableCoord
instance ToJSON MinimumMatch
instance ToJSON Tiebreaker
instance ToJSON Version
instance ToJSON Boost
instance ToJSON Lenient
instance ToJSON MaxExpansions
instance ToJSON Analyzer
instance ToJSON CutoffFrequency
instance ToJSON ShardCount
instance ToJSON ReplicaCount
instance ToJSON FieldName
instance ToJSON MatchQueryType
instance ToJSON ZeroTermsQuery
instance ToJSON BooleanOperator
instance ToJSON MultiMatchQueryType
instance ToJSON MultiMatchQuery
instance ToJSON MatchQuery
instance ToJSON BoolQuery
instance ToJSON BoostingQuery
instance ToJSON CommonMinimumMatch
instance ToJSON CommonTermsQuery
instance ToJSON DisMaxQuery
instance ToJSON FilteredQuery
instance ToJSON FuzzyLikeThisQuery
instance ToJSON FuzzyLikeFieldQuery
instance ToJSON FuzzyQuery
instance ToJSON HasChildQuery
instance ToJSON HasParentQuery
instance ToJSON IndicesQuery
instance ToJSON MoreLikeThisQuery
instance ToJSON MoreLikeThisFieldQuery
instance ToJSON NestedQuery
instance ToJSON PrefixQuery
instance ToJSON RangeQuery
instance ToJSON QueryStringQuery
instance ToJSON RegexpQuery
instance ToJSON SimpleQueryFlag
instance ToJSON FieldOrFields
instance ToJSON SimpleQueryStringQuery
instance ToJSON Query
instance ToJSON GeoPoint
instance ToJSON Filter
instance Seminearring Filter
instance Monoid Filter
instance FromJSON DateHistogramResult
instance FromJSON TermsResult
instance (FromJSON a, BucketAggregation a) => FromJSON (Bucket a)
instance BucketAggregation DateHistogramResult
instance BucketAggregation TermsResult
instance ToJSON Aggregation
instance Show TimeInterval
instance ToJSON Interval
instance ToJSON ExecutionHint
instance ToJSON CollectionMode
instance ToJSON TermInclusion
instance ToJSON TermOrder
instance Monoid (SearchHits a)
instance (Functor m, Applicative m, MonadIO m) => MonadBH (ReaderT BHEnv m)
instance (Functor m, Applicative m, MonadIO m) => MonadBH (BH m)
instance MonadReader r m => MonadReader r (BH m)
instance MonadTrans BH


-- | Client side functions for talking to Elasticsearch servers.
module Database.Bloodhound.Client

-- | Convenience function that sets up a mananager and BHEnv and runs the
--   given set of bloodhound operations. Connections will be pipelined
--   automatically in accordance with the given manager settings in IO. If
--   you've got your own monad transformer stack, you should use
--   <a>runBH</a> directly.
withBH :: ManagerSettings -> Server -> BH IO a -> IO a

-- | <a>createIndex</a> will create an index given a <a>Server</a>,
--   <a>IndexSettings</a>, and an <a>IndexName</a>.
--   
--   <pre>
--   &gt;&gt;&gt; response &lt;- runBH' $ createIndex defaultIndexSettings (IndexName "didimakeanindex")
--   
--   &gt;&gt;&gt; respIsTwoHunna response
--   True
--   
--   &gt;&gt;&gt; runBH' $ indexExists (IndexName "didimakeanindex")
--   True
--   </pre>
createIndex :: MonadBH m => IndexSettings -> IndexName -> m Reply

-- | <a>deleteIndex</a> will delete an index given a <a>Server</a>, and an
--   <a>IndexName</a>.
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- runBH' $ createIndex defaultIndexSettings (IndexName "didimakeanindex")
--   
--   &gt;&gt;&gt; response &lt;- runBH' $ deleteIndex (IndexName "didimakeanindex")
--   
--   &gt;&gt;&gt; respIsTwoHunna response
--   True
--   
--   &gt;&gt;&gt; runBH' $ indexExists testIndex
--   False
--   </pre>
deleteIndex :: MonadBH m => IndexName -> m Reply

-- | <a>indexExists</a> enables you to check if an index exists. Returns
--   <a>Bool</a> in IO
--   
--   <pre>
--   &gt;&gt;&gt; exists &lt;- runBH' $ indexExists testIndex
--   </pre>
indexExists :: MonadBH m => IndexName -> m Bool

-- | <a>openIndex</a> opens an index given a <a>Server</a> and an
--   <a>IndexName</a>. Explained in further detail at
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-open-close.html</a>
--   
--   <pre>
--   &gt;&gt;&gt; reply &lt;- runBH' $ openIndex testIndex
--   </pre>
openIndex :: MonadBH m => IndexName -> m Reply

-- | <a>closeIndex</a> closes an index given a <a>Server</a> and an
--   <a>IndexName</a>. Explained in further detail at
--   <a>http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-open-close.html</a>
--   
--   <pre>
--   &gt;&gt;&gt; reply &lt;- runBH' $ closeIndex testIndex
--   </pre>
closeIndex :: MonadBH m => IndexName -> m Reply

-- | <a>putMapping</a> is an HTTP PUT and has upsert semantics. Mappings
--   are schemas for documents in indexes.
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- runBH' $ createIndex defaultIndexSettings testIndex
--   
--   &gt;&gt;&gt; resp &lt;- runBH' $ putMapping testIndex testMapping TweetMapping
--   
--   &gt;&gt;&gt; print resp
--   Response {responseStatus = Status {statusCode = 200, statusMessage = "OK"}, responseVersion = HTTP/1.1, responseHeaders = [("Content-Type","application/json; charset=UTF-8"),("Content-Length","21")], responseBody = "{\"acknowledged\":true}", responseCookieJar = CJ {expose = []}, responseClose' = ResponseClose}
--   </pre>
putMapping :: (MonadBH m, ToJSON a) => IndexName -> MappingName -> a -> m Reply

-- | <a>deleteMapping</a> is an HTTP DELETE and deletes a mapping for a
--   given index. Mappings are schemas for documents in indexes.
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- runBH' $ createIndex defaultIndexSettings testIndex
--   
--   &gt;&gt;&gt; _ &lt;- runBH' $ putMapping testIndex testMapping TweetMapping
--   
--   &gt;&gt;&gt; resp &lt;- runBH' $ deleteMapping testIndex testMapping
--   
--   &gt;&gt;&gt; print resp
--   Response {responseStatus = Status {statusCode = 200, statusMessage = "OK"}, responseVersion = HTTP/1.1, responseHeaders = [("Content-Type","application/json; charset=UTF-8"),("Content-Length","21")], responseBody = "{\"acknowledged\":true}", responseCookieJar = CJ {expose = []}, responseClose' = ResponseClose}
--   </pre>
deleteMapping :: MonadBH m => IndexName -> MappingName -> m Reply

-- | <a>indexDocument</a> is the primary way to save a single document in
--   Elasticsearch. The document itself is simply something we can convert
--   into a JSON <a>Value</a>. The <a>DocId</a> will function as the
--   primary key for the document.
--   
--   <pre>
--   &gt;&gt;&gt; resp &lt;- runBH' $ indexDocument testIndex testMapping defaultIndexDocumentSettings exampleTweet (DocId "1")
--   
--   &gt;&gt;&gt; print resp
--   Response {responseStatus = Status {statusCode = 201, statusMessage = "Created"}, responseVersion = HTTP/1.1, responseHeaders = [("Content-Type","application/json; charset=UTF-8"),("Content-Length","74")], responseBody = "{\"_index\":\"twitter\",\"_type\":\"tweet\",\"_id\":\"1\",\"_version\":1,\"created\":true}", responseCookieJar = CJ {expose = []}, responseClose' = ResponseClose}
--   </pre>
indexDocument :: (ToJSON doc, MonadBH m) => IndexName -> MappingName -> IndexDocumentSettings -> doc -> DocId -> m Reply

-- | <a>getDocument</a> is a straight-forward way to fetch a single
--   document from Elasticsearch using a <a>Server</a>, <a>IndexName</a>,
--   <a>MappingName</a>, and a <a>DocId</a>. The <a>DocId</a> is the
--   primary key for your Elasticsearch document.
--   
--   <pre>
--   &gt;&gt;&gt; yourDoc &lt;- runBH' $ getDocument testIndex testMapping (DocId "1")
--   </pre>
getDocument :: MonadBH m => IndexName -> MappingName -> DocId -> m Reply

-- | <a>documentExists</a> enables you to check if a document exists.
--   Returns <a>Bool</a> in IO
--   
--   <pre>
--   &gt;&gt;&gt; exists &lt;- runBH' $ documentExists testIndex testMapping (DocId "1")
--   </pre>
documentExists :: MonadBH m => IndexName -> MappingName -> DocId -> m Bool

-- | <a>deleteDocument</a> is the primary way to delete a single document.
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- runBH' $ deleteDocument testIndex testMapping (DocId "1")
--   </pre>
deleteDocument :: MonadBH m => IndexName -> MappingName -> DocId -> m Reply

-- | <a>searchAll</a>, given a <a>Search</a>, will perform that search
--   against all indexes on an Elasticsearch server. Try to avoid doing
--   this if it can be helped.
--   
--   <pre>
--   &gt;&gt;&gt; let query = TermQuery (Term "user" "bitemyapp") Nothing
--   
--   &gt;&gt;&gt; let search = mkSearch (Just query) Nothing
--   
--   &gt;&gt;&gt; reply &lt;- runBH' $ searchAll search
--   </pre>
searchAll :: MonadBH m => Search -> m Reply

-- | <a>searchByIndex</a>, given a <a>Search</a> and an <a>IndexName</a>,
--   will perform that search against all mappings within an index on an
--   Elasticsearch server.
--   
--   <pre>
--   &gt;&gt;&gt; let query = TermQuery (Term "user" "bitemyapp") Nothing
--   
--   &gt;&gt;&gt; let search = mkSearch (Just query) Nothing
--   
--   &gt;&gt;&gt; reply &lt;- runBH' $ searchByIndex testIndex search
--   </pre>
searchByIndex :: MonadBH m => IndexName -> Search -> m Reply

-- | <a>searchByType</a>, given a <a>Search</a>, <a>IndexName</a>, and
--   <a>MappingName</a>, will perform that search against a specific
--   mapping within an index on an Elasticsearch server.
--   
--   <pre>
--   &gt;&gt;&gt; let query = TermQuery (Term "user" "bitemyapp") Nothing
--   
--   &gt;&gt;&gt; let search = mkSearch (Just query) Nothing
--   
--   &gt;&gt;&gt; reply &lt;- runBH' $ searchByType testIndex testMapping search
--   </pre>
searchByType :: MonadBH m => IndexName -> MappingName -> Search -> m Reply

-- | <a>refreshIndex</a> will force a refresh on an index. You must do this
--   if you want to read what you wrote.
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- runBH' $ createIndex defaultIndexSettings testIndex
--   
--   &gt;&gt;&gt; _ &lt;- runBH' $ refreshIndex testIndex
--   </pre>
refreshIndex :: MonadBH m => IndexName -> m Reply

-- | <a>mkSearch</a> is a helper function for defaulting additional fields
--   of a <a>Search</a> to Nothing in case you only care about your
--   <a>Query</a> and <a>Filter</a>. Use record update syntax if you want
--   to add things like aggregations or highlights while still using this
--   helper function.
--   
--   <pre>
--   &gt;&gt;&gt; let query = TermQuery (Term "user" "bitemyapp") Nothing
--   
--   &gt;&gt;&gt; mkSearch (Just query) Nothing
--   Search {queryBody = Just (TermQuery (Term {termField = "user", termValue = "bitemyapp"}) Nothing), filterBody = Nothing, sortBody = Nothing, aggBody = Nothing, highlight = Nothing, trackSortScores = False, from = From 0, size = Size 10}
--   </pre>
mkSearch :: Maybe Query -> Maybe Filter -> Search

-- | <a>mkAggregateSearch</a> is a helper function that defaults everything
--   in a <a>Search</a> except for the <a>Query</a> and the
--   <a>Aggregation</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let terms = TermsAgg $ (mkTermsAggregation "user") { termCollectMode = Just BreadthFirst }
--   
--   &gt;&gt;&gt; terms
--   TermsAgg (TermsAggregation {term = Left "user", termInclude = Nothing, termExclude = Nothing, termOrder = Nothing, termMinDocCount = Nothing, termSize = Nothing, termShardSize = Nothing, termCollectMode = Just BreadthFirst, termExecutionHint = Nothing, termAggs = Nothing})
--   
--   &gt;&gt;&gt; let myAggregation = mkAggregateSearch Nothing $ mkAggregations "users" terms
--   </pre>
mkAggregateSearch :: Maybe Query -> Aggregations -> Search

-- | <a>mkHighlightSearch</a> is a helper function that defaults everything
--   in a <a>Search</a> except for the <a>Query</a> and the
--   <a>Aggregation</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let query = QueryMatchQuery $ mkMatchQuery (FieldName "_all") (QueryString "haskell")
--   
--   &gt;&gt;&gt; let testHighlight = Highlights Nothing [FieldHighlight (FieldName "message") Nothing]
--   
--   &gt;&gt;&gt; let search = mkHighlightSearch (Just query) testHighlight
--   </pre>
mkHighlightSearch :: Maybe Query -> Highlights -> Search

-- | <a>bulk</a> uses <a>Elasticsearch's bulk API</a> to perform bulk
--   operations. The <a>BulkOperation</a> data type encodes the
--   index<i>update</i>delete/create operations. You pass a <a>Vector</a>
--   of <a>BulkOperation</a>s and a <a>Server</a> to <a>bulk</a> in order
--   to send those operations up to your Elasticsearch server to be
--   performed. I changed from [BulkOperation] to a Vector due to memory
--   overhead.
--   
--   <pre>
--   &gt;&gt;&gt; let stream = V.fromList [BulkIndex testIndex testMapping (DocId "2") (toJSON (BulkTest "blah"))]
--   
--   &gt;&gt;&gt; _ &lt;- runBH' $ bulk stream
--   
--   &gt;&gt;&gt; _ &lt;- runBH' $ refreshIndex testIndex
--   </pre>
bulk :: MonadBH m => Vector BulkOperation -> m Reply

-- | <a>pageSearch</a> is a helper function that takes a search and assigns
--   the from and size fields for the search. The from parameter defines
--   the offset from the first result you want to fetch. The size parameter
--   allows you to configure the maximum amount of hits to be returned.
--   
--   <pre>
--   &gt;&gt;&gt; let query = QueryMatchQuery $ mkMatchQuery (FieldName "_all") (QueryString "haskell")
--   
--   &gt;&gt;&gt; let search = mkSearch (Just query) Nothing
--   
--   &gt;&gt;&gt; search
--   Search {queryBody = Just (QueryMatchQuery (MatchQuery {matchQueryField = FieldName "_all", matchQueryQueryString = QueryString "haskell", matchQueryOperator = Or, matchQueryZeroTerms = ZeroTermsNone, matchQueryCutoffFrequency = Nothing, matchQueryMatchType = Nothing, matchQueryAnalyzer = Nothing, matchQueryMaxExpansions = Nothing, matchQueryLenient = Nothing})), filterBody = Nothing, sortBody = Nothing, aggBody = Nothing, highlight = Nothing, trackSortScores = False, from = From 0, size = Size 10}
--   
--   &gt;&gt;&gt; pageSearch (From 10) (Size 100) search
--   Search {queryBody = Just (QueryMatchQuery (MatchQuery {matchQueryField = FieldName "_all", matchQueryQueryString = QueryString "haskell", matchQueryOperator = Or, matchQueryZeroTerms = ZeroTermsNone, matchQueryCutoffFrequency = Nothing, matchQueryMatchType = Nothing, matchQueryAnalyzer = Nothing, matchQueryMaxExpansions = Nothing, matchQueryLenient = Nothing})), filterBody = Nothing, sortBody = Nothing, aggBody = Nothing, highlight = Nothing, trackSortScores = False, from = From 10, size = Size 100}
--   </pre>
pageSearch :: From -> Size -> Search -> Search

-- | <a>mkShardCount</a> is a straight-forward smart constructor for
--   <a>ShardCount</a> which rejects <a>Int</a> values below 1 and above
--   1000.
--   
--   <pre>
--   &gt;&gt;&gt; mkShardCount 10
--   Just (ShardCount 10)
--   </pre>
mkShardCount :: Int -> Maybe ShardCount

-- | <a>mkReplicaCount</a> is a straight-forward smart constructor for
--   <a>ReplicaCount</a> which rejects <a>Int</a> values below 1 and above
--   1000.
--   
--   <pre>
--   &gt;&gt;&gt; mkReplicaCount 10
--   Just (ReplicaCount 10)
--   </pre>
mkReplicaCount :: Int -> Maybe ReplicaCount

-- | <a>getStatus</a> fetches the <a>Status</a> of a <a>Server</a>
--   
--   <pre>
--   &gt;&gt;&gt; serverStatus &lt;- runBH' getStatus
--   
--   &gt;&gt;&gt; fmap status (serverStatus)
--   Just 200
--   </pre>
getStatus :: MonadBH m => m (Maybe Status)

-- | <a>encodeBulkOperations</a> is a convenience function for dumping a
--   vector of <a>BulkOperation</a> into an <a>ByteString</a>
--   
--   <pre>
--   &gt;&gt;&gt; let bulkOps = V.fromList [BulkIndex testIndex testMapping (DocId "2") (toJSON (BulkTest "blah"))]
--   
--   &gt;&gt;&gt; encodeBulkOperations bulkOps
--   "\n{\"index\":{\"_type\":\"tweet\",\"_id\":\"2\",\"_index\":\"twitter\"}}\n{\"name\":\"blah\"}\n"
--   </pre>
encodeBulkOperations :: Vector BulkOperation -> ByteString

-- | <a>encodeBulkOperation</a> is a convenience function for dumping a
--   single <a>BulkOperation</a> into an <a>ByteString</a>
--   
--   <pre>
--   &gt;&gt;&gt; let bulkOp = BulkIndex testIndex testMapping (DocId "2") (toJSON (BulkTest "blah"))
--   
--   &gt;&gt;&gt; encodeBulkOperation bulkOp
--   "{\"index\":{\"_type\":\"tweet\",\"_id\":\"2\",\"_index\":\"twitter\"}}\n{\"name\":\"blah\"}"
--   </pre>
encodeBulkOperation :: BulkOperation -> ByteString

-- | Was there an optimistic concurrency control conflict when indexing a
--   document?
isVersionConflict :: Reply -> Bool
isSuccess :: Reply -> Bool
isCreated :: Reply -> Bool

module Database.Bloodhound
