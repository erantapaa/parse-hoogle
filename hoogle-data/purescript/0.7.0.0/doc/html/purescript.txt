-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | PureScript Programming Language Compiler
--   
@package purescript
@version 0.7.0.0

module Language.PureScript.Docs.Utils.MonoidExtras
mintersperse :: Monoid m => m -> [m] -> m


-- | State for the parser monad
module Language.PureScript.Parser.State

-- | State for the parser monad
data ParseState
ParseState :: Column -> ParseState

-- | The most recently marked indentation level
indentationLevel :: ParseState -> Column
instance Show ParseState


module Control.Monad.Unify

-- | Untyped unification variables
type Unknown = Int

-- | A type which can contain unification variables
class Partial t
unknown :: Partial t => Unknown -> t
isUnknown :: Partial t => t -> Maybe Unknown
unknowns :: Partial t => t -> [Unknown]
($?) :: Partial t => Substitution t -> t -> t

-- | Identifies types which support unification
class Partial t => Unifiable m t | t -> m
(=?=) :: Unifiable m t => t -> t -> UnifyT t m ()

-- | A substitution maintains a mapping from unification variables to their
--   values
data Substitution t
Substitution :: HashMap Int t -> Substitution t
runSubstitution :: Substitution t -> HashMap Int t

-- | State required for type checking
data UnifyState t
UnifyState :: Int -> Substitution t -> UnifyState t

-- | The next fresh unification variable
unifyNextVar :: UnifyState t -> Int

-- | The current substitution
unifyCurrentSubstitution :: UnifyState t -> Substitution t

-- | An empty <tt>UnifyState</tt>
defaultUnifyState :: Partial t => UnifyState t

-- | A class for errors which support unification errors
class UnificationError t e
occursCheckFailed :: UnificationError t e => t -> e

-- | The type checking monad, which provides the state of the type checker,
--   and error reporting capabilities
newtype UnifyT t m a
UnifyT :: StateT (UnifyState t) m a -> UnifyT t m a
unUnify :: UnifyT t m a -> StateT (UnifyState t) m a

-- | Run a computation in the Unify monad, failing with an error, or
--   succeeding with a return value and the new next unification variable
runUnify :: UnifyState t -> UnifyT t m a -> m (a, UnifyState t)

-- | Substitute a single unification variable
substituteOne :: Partial t => Unknown -> t -> Substitution t

-- | Replace a unification variable with the specified value in the current
--   substitution
(=:=) :: (UnificationError t e, Monad m, MonadError e m, Unifiable m t) => Unknown -> t -> UnifyT t m ()

-- | Perform the occurs check, to make sure a unification variable does not
--   occur inside a value
occursCheck :: (UnificationError t e, Monad m, MonadError e m, Partial t) => Unknown -> t -> UnifyT t m ()

-- | Generate a fresh untyped unification variable
fresh' :: Monad m => UnifyT t m Unknown

-- | Generate a fresh unification variable at a specific type
fresh :: (Monad m, Partial t) => UnifyT t m t
instance Functor m => Functor (UnifyT t m)
instance Monad m => Monad (UnifyT t m)
instance (Monad m, Functor m) => Applicative (UnifyT t m)
instance (Functor m, MonadPlus m) => Alternative (UnifyT t m)
instance MonadPlus m => MonadPlus (UnifyT t m)
instance MonadError e m => MonadError e (UnifyT t m)
instance MonadState s m => MonadState s (UnifyT t m)
instance Partial t => Monoid (Substitution t)


-- | The core functional representation for literal values.
module Language.PureScript.CoreFn.Literals

-- | Data type for literal values. Parameterised so it can be used for
--   Exprs and Binders.
data Literal a

-- | A numeric literal
NumericLiteral :: (Either Integer Double) -> Literal a

-- | A string literal
StringLiteral :: String -> Literal a

-- | A character literal
CharLiteral :: Char -> Literal a

-- | A boolean literal
BooleanLiteral :: Bool -> Literal a

-- | An array literal
ArrayLiteral :: [a] -> Literal a

-- | An object literal
ObjectLiteral :: [(String, a)] -> Literal a
instance Typeable Literal
instance Show a => Show (Literal a)
instance Data a => Data (Literal a)
instance Functor Literal


-- | Common functions for implementing generic traversals
module Language.PureScript.Traversals
fstM :: Functor f => (a -> f c) -> (a, b) -> f (c, b)
sndM :: Functor f => (b -> f c) -> (a, b) -> f (a, c)
thirdM :: Functor f => (c -> f d) -> (a, b, c) -> f (a, b, d)
pairM :: Applicative f => (a -> f c) -> (b -> f d) -> (a, b) -> f (c, d)
maybeM :: Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
eitherM :: Applicative f => (a -> f c) -> (b -> f d) -> Either a b -> f (Either c d)
defS :: Monad m => st -> val -> m (st, val)


-- | Source position information
module Language.PureScript.AST.SourcePos

-- | Source position information
data SourcePos
SourcePos :: Int -> Int -> SourcePos

-- | Line number
sourcePosLine :: SourcePos -> Int

-- | Column number
sourcePosColumn :: SourcePos -> Int
displaySourcePos :: SourcePos -> String
data SourceSpan
SourceSpan :: String -> SourcePos -> SourcePos -> SourceSpan

-- | Source name
spanName :: SourceSpan -> String

-- | Start of the span
spanStart :: SourceSpan -> SourcePos
spanEnd :: SourceSpan -> SourcePos
displaySourceSpan :: SourceSpan -> String
instance Typeable SourcePos
instance Typeable SourceSpan
instance Eq SourcePos
instance Ord SourcePos
instance Show SourcePos
instance Data SourcePos
instance Eq SourceSpan
instance Ord SourceSpan
instance Show SourceSpan
instance Data SourceSpan
instance ToJSON SourceSpan
instance ToJSON SourcePos


-- | Operators fixity and associativity
module Language.PureScript.AST.Operators

-- | A precedence level for an infix operator
type Precedence = Integer

-- | Associativity for infix operators
data Associativity
Infixl :: Associativity
Infixr :: Associativity
Infix :: Associativity

-- | Fixity data for infix operators
data Fixity
Fixity :: Associativity -> Precedence -> Fixity
instance Typeable Associativity
instance Typeable Fixity
instance Eq Associativity
instance Ord Associativity
instance Data Associativity
instance Show Fixity
instance Eq Fixity
instance Ord Fixity
instance Data Fixity
instance ToJSON Fixity
instance ToJSON Associativity
instance Show Associativity


-- | Various constants which refer to things in the Prelude
module Language.PureScript.Constants
($) :: String
(#) :: String
(<>) :: String
(++) :: String
(>>=) :: String
(+) :: String
(-) :: String
(*) :: String
(/) :: String
(%) :: String
(<) :: String
(>) :: String
(<=) :: String
(>=) :: String
(==) :: String
(/=) :: String
(&&) :: String
(||) :: String
bind :: String
unsafeIndex :: String
(.|.) :: String
(.&.) :: String
(.^.) :: String
(<<<) :: String
negate :: String
not :: String
sup :: String
inf :: String
mod :: String
shl :: String
shr :: String
zshr :: String
complement :: String
zero :: String
one :: String
bottom :: String
top :: String
return :: String
pure' :: String
returnEscaped :: String
untilE :: String
whileE :: String
runST :: String
stRefValue :: String
newSTRef :: String
readSTRef :: String
writeSTRef :: String
modifySTRef :: String
mkFn :: String
runFn :: String
unit :: String
undefined :: String
monadEffDictionary :: String
applicativeEffDictionary :: String
bindEffDictionary :: String
semiringNumber :: String
semiringInt :: String
ringNumber :: String
ringInt :: String
moduloSemiringNumber :: String
moduloSemiringInt :: String
ordNumber :: String
ordInt :: String
eqNumber :: String
eqInt :: String
eqString :: String
eqBoolean :: String
boundedBoolean :: String
latticeBoolean :: String
complementedLatticeBoolean :: String
semigroupString :: String
semigroupoidArr :: String
main :: String
__superclass_ :: String
__unused :: String
prim :: String
prelude :: String
dataArrayUnsafe :: String
eff :: String
st :: String
dataFunction :: String
dataInt :: String
dataIntBits :: String


-- | The data type of compiler options
module Language.PureScript.Options

-- | The data type of compiler options
data Options
Options :: Bool -> Bool -> Maybe String -> Bool -> Bool -> Bool -> Maybe FilePath -> Options

-- | Disable tail-call elimination
optionsNoTco :: Options -> Bool

-- | Disable inlining of calls to return and bind for the Eff monad
optionsNoMagicDo :: Options -> Bool

-- | When specified, checks the type of <tt>main</tt> in the module, and
--   generate a call to run main after the module definitions.
optionsMain :: Options -> Maybe String

-- | Skip all optimizations
optionsNoOptimizations :: Options -> Bool

-- | Verbose error message
optionsVerboseErrors :: Options -> Bool

-- | Remove the comments from the generated js
optionsNoComments :: Options -> Bool

-- | The path to prepend to require statements
optionsRequirePath :: Options -> Maybe FilePath

-- | Default make options
defaultOptions :: Options
instance Show Options


-- | Data types for names
module Language.PureScript.Names

-- | Names for value identifiers
data Ident

-- | An alphanumeric identifier
Ident :: String -> Ident

-- | A symbolic name for an infix operator
Op :: String -> Ident
runIdent :: Ident -> String

-- | Proper names, i.e. capitalized names for e.g. module names, type//data
--   constructors.
newtype ProperName
ProperName :: String -> ProperName
runProperName :: ProperName -> String

-- | Module names
data ModuleName
ModuleName :: [ProperName] -> ModuleName
runModuleName :: ModuleName -> String
moduleNameFromString :: String -> ModuleName

-- | A qualified name, i.e. a name with an optional module name
data Qualified a
Qualified :: (Maybe ModuleName) -> a -> Qualified a

-- | Provide a default module name, if a name is unqualified
qualify :: ModuleName -> Qualified a -> (ModuleName, a)
instance Typeable Ident
instance Typeable ProperName
instance Typeable ModuleName
instance Typeable Qualified
instance Eq Ident
instance Ord Ident
instance Data Ident
instance Eq ProperName
instance Ord ProperName
instance Data ProperName
instance Eq ModuleName
instance Ord ModuleName
instance Data ModuleName
instance Eq a => Eq (Qualified a)
instance Ord a => Ord (Qualified a)
instance Data a => Data (Qualified a)
instance Functor Qualified
instance a ~ ProperName => FromJSON (Qualified a)
instance a ~ ProperName => ToJSON (Qualified a)
instance Show a => Show (Qualified a)
instance Show ModuleName
instance Show ProperName
instance Show Ident


-- | Common code generation utility functions
module Language.PureScript.CodeGen.JS.Common

-- | Convert an Ident into a valid Javascript identifier:
--   
--   <ul>
--   <li>Alphanumeric characters are kept unmodified.</li>
--   <li>Reserved javascript identifiers are prefixed with
--   <tt>$$</tt>.</li>
--   <li>Symbols are prefixed with <a>$</a> followed by a symbol name or
--   their ordinal value.</li>
--   </ul>
identToJs :: Ident -> String

-- | Test if a string is a valid JS identifier without escaping.
identNeedsEscaping :: String -> Bool

-- | Attempts to find a human-readable name for a symbol, if none has been
--   specified returns the ordinal value.
identCharToString :: Char -> String

-- | Checks whether an identifier name is reserved in Javascript.
nameIsJsReserved :: String -> Bool
moduleNameToJs :: ModuleName -> String

-- | Checks whether a proper name is reserved in Javascript.
properNameIsJsReserved :: String -> Bool


-- | The core functional representation for binders
module Language.PureScript.CoreFn.Binders

-- | Data type for binders
data Binder a

-- | Wildcard binder
NullBinder :: a -> Binder a

-- | A binder which matches a literal value
LiteralBinder :: a -> (Literal (Binder a)) -> Binder a

-- | A binder which binds an identifier
VarBinder :: a -> Ident -> Binder a

-- | A binder which matches a data constructor (type name, constructor
--   name, binders)
ConstructorBinder :: a -> (Qualified ProperName) -> (Qualified ProperName) -> [Binder a] -> Binder a

-- | A binder which binds its input to an identifier
NamedBinder :: a -> Ident -> (Binder a) -> Binder a
instance Typeable Binder
instance Show a => Show (Binder a)
instance Data a => Data (Binder a)
instance Functor Binder


-- | The core functional representation
module Language.PureScript.CoreFn.Expr

-- | Data type for expressions and terms
data Expr a

-- | A literal value
Literal :: a -> (Literal (Expr a)) -> Expr a

-- | A data constructor (type name, constructor name, field names)
Constructor :: a -> ProperName -> ProperName -> [Ident] -> Expr a

-- | A record property accessor
Accessor :: a -> String -> (Expr a) -> Expr a

-- | Partial record update
ObjectUpdate :: a -> (Expr a) -> [(String, Expr a)] -> Expr a

-- | Function introduction
Abs :: a -> Ident -> (Expr a) -> Expr a

-- | Function application
App :: a -> (Expr a) -> (Expr a) -> Expr a

-- | Variable
Var :: a -> (Qualified Ident) -> Expr a

-- | A case expression
Case :: a -> [Expr a] -> [CaseAlternative a] -> Expr a

-- | A let binding
Let :: a -> [Bind a] -> (Expr a) -> Expr a

-- | A let or module binding.
data Bind a

-- | Non-recursive binding for a single value
NonRec :: Ident -> (Expr a) -> Bind a

-- | Mutually recursive binding group for several values
Rec :: [(Ident, Expr a)] -> Bind a

-- | A guard is just a boolean-valued expression that appears alongside a
--   set of binders
type Guard a = Expr a

-- | An alternative in a case statement
data CaseAlternative a
CaseAlternative :: [Binder a] -> Either [(Guard a, Expr a)] (Expr a) -> CaseAlternative a

-- | A collection of binders with which to match the inputs
caseAlternativeBinders :: CaseAlternative a -> [Binder a]

-- | The result expression or a collect of guarded expressions
caseAlternativeResult :: CaseAlternative a -> Either [(Guard a, Expr a)] (Expr a)

-- | Extract the annotation from a term
extractAnn :: Expr a -> a

-- | Modify the annotation on a term
modifyAnn :: (a -> a) -> Expr a -> Expr a
instance Typeable CaseAlternative
instance Typeable Expr
instance Typeable Bind
instance Show a => Show (CaseAlternative a)
instance Data a => Data (CaseAlternative a)
instance Show a => Show (Expr a)
instance Data a => Data (Expr a)
instance Functor Expr
instance Show a => Show (Bind a)
instance Data a => Data (Bind a)
instance Functor Bind
instance Functor CaseAlternative


-- | CoreFn traversal helpers
module Language.PureScript.CoreFn.Traversals
everywhereOnValues :: (Bind a -> Bind a) -> (Expr a -> Expr a) -> (Binder a -> Binder a) -> (Bind a -> Bind a, Expr a -> Expr a, Binder a -> Binder a)
everythingOnValues :: (r -> r -> r) -> (Bind a -> r) -> (Expr a -> r) -> (Binder a -> r) -> (CaseAlternative a -> r) -> (Bind a -> r, Expr a -> r, Binder a -> r, CaseAlternative a -> r)


-- | Metadata annotations for core functional representation
module Language.PureScript.CoreFn.Meta

-- | Metadata annotations
data Meta

-- | The contained value is a data constructor
IsConstructor :: ConstructorType -> [Ident] -> Meta

-- | The contained value is a newtype
IsNewtype :: Meta

-- | The contained value is a typeclass dictionary constructor
IsTypeClassConstructor :: Meta

-- | The contained reference is for a foreign member
IsForeign :: Meta

-- | Data constructor metadata
data ConstructorType

-- | The constructor is for a type with a single construcor
ProductType :: ConstructorType

-- | The constructor is for a type with multiple construcors
SumType :: ConstructorType
instance Typeable ConstructorType
instance Typeable Meta
instance Show ConstructorType
instance Data ConstructorType
instance Show Meta
instance Data Meta


module Language.PureScript.Kinds

-- | The data type of kinds
data Kind

-- | Unification variable of type Kind
KUnknown :: Unknown -> Kind

-- | The kind of types
Star :: Kind

-- | The kind of effects
Bang :: Kind

-- | Kinds for labelled, unordered rows without duplicates
Row :: Kind -> Kind

-- | Function kinds
FunKind :: Kind -> Kind -> Kind
everywhereOnKinds :: (Kind -> Kind) -> Kind -> Kind
everywhereOnKindsM :: (Functor m, Applicative m, Monad m) => (Kind -> m Kind) -> Kind -> m Kind
everythingOnKinds :: (r -> r -> r) -> (Kind -> r) -> Kind -> r
instance FromJSON Kind
instance ToJSON Kind
instance Typeable Kind
instance Show Kind
instance Eq Kind
instance Ord Kind
instance Data Kind


-- | Data types for types
module Language.PureScript.Types

-- | An identifier for the scope of a skolem variable
newtype SkolemScope
SkolemScope :: Int -> SkolemScope
runSkolemScope :: SkolemScope -> Int

-- | The type of types
data Type

-- | A unification variable of type Type
TUnknown :: Unknown -> Type

-- | A named type variable
TypeVar :: String -> Type

-- | A type wildcard, as would appear in a partial type synonym
TypeWildcard :: Type

-- | A type constructor
TypeConstructor :: (Qualified ProperName) -> Type

-- | A type application
TypeApp :: Type -> Type -> Type

-- | A type synonym which is "saturated", i.e. fully applied
SaturatedTypeSynonym :: (Qualified ProperName) -> [Type] -> Type

-- | Forall quantifier
ForAll :: String -> Type -> (Maybe SkolemScope) -> Type

-- | A type with a set of type class constraints
ConstrainedType :: [Constraint] -> Type -> Type

-- | A skolem constant
Skolem :: String -> Int -> SkolemScope -> Type

-- | An empty row
REmpty :: Type

-- | A non-empty row
RCons :: String -> Type -> Type -> Type

-- | A type with a kind annotation
KindedType :: Type -> Kind -> Type

-- | A placeholder used in pretty printing
PrettyPrintFunction :: Type -> Type -> Type

-- | A placeholder used in pretty printing
PrettyPrintObject :: Type -> Type

-- | A placeholder used in pretty printing
PrettyPrintForAll :: [String] -> Type -> Type

-- | A typeclass constraint
type Constraint = (Qualified ProperName, [Type])

-- | Convert a row to a list of pairs of labels and types
rowToList :: Type -> ([(String, Type)], Type)

-- | Convert a list of labels and types to a row
rowFromList :: ([(String, Type)], Type) -> Type

-- | Check whether a type is a monotype
isMonoType :: Type -> Bool

-- | Universally quantify a type
mkForAll :: [String] -> Type -> Type

-- | Replace a type variable, taking into account variable shadowing
replaceTypeVars :: String -> Type -> Type -> Type

-- | Replace named type variables with types
replaceAllTypeVars :: [(String, Type)] -> Type -> Type

-- | Collect all type variables appearing in a type
usedTypeVariables :: Type -> [String]

-- | Collect all free type variables appearing in a type
freeTypeVariables :: Type -> [String]

-- | Universally quantify over all type variables appearing free in a type
quantify :: Type -> Type

-- | Move all universal quantifiers to the front of a type
moveQuantifiersToFront :: Type -> Type

-- | Check if a type contains wildcards
containsWildcards :: Type -> Bool
everywhereOnTypes :: (Type -> Type) -> Type -> Type
everywhereOnTypesTopDown :: (Type -> Type) -> Type -> Type
everywhereOnTypesM :: (Functor m, Applicative m, Monad m) => (Type -> m Type) -> Type -> m Type
everywhereOnTypesTopDownM :: (Functor m, Applicative m, Monad m) => (Type -> m Type) -> Type -> m Type
everythingOnTypes :: (r -> r -> r) -> (Type -> r) -> Type -> r
instance FromJSON Type
instance ToJSON Type
instance Typeable SkolemScope
instance Typeable Type
instance Show SkolemScope
instance Eq SkolemScope
instance Ord SkolemScope
instance Data SkolemScope
instance ToJSON SkolemScope
instance FromJSON SkolemScope
instance Show Type
instance Eq Type
instance Ord Type
instance Data Type


module Language.PureScript.TypeClassDictionaries

-- | Data representing a type class dictionary which is in scope
data TypeClassDictionaryInScope
TypeClassDictionaryInScope :: Qualified Ident -> Qualified ProperName -> [Type] -> Maybe [Constraint] -> TypeClassDictionaryType -> Bool -> TypeClassDictionaryInScope

-- | The identifier with which the dictionary can be accessed at runtime
tcdName :: TypeClassDictionaryInScope -> Qualified Ident

-- | The name of the type class to which this type class instance applies
tcdClassName :: TypeClassDictionaryInScope -> Qualified ProperName

-- | The types to which this type class instance applies
tcdInstanceTypes :: TypeClassDictionaryInScope -> [Type]

-- | Type class dependencies which must be satisfied to construct this
--   dictionary
tcdDependencies :: TypeClassDictionaryInScope -> Maybe [Constraint]

-- | The type of this dictionary
tcdType :: TypeClassDictionaryInScope -> TypeClassDictionaryType

-- | Is this instance exported by its module?
tcdExported :: TypeClassDictionaryInScope -> Bool

-- | The type of a type class dictionary
data TypeClassDictionaryType

-- | A regular type class dictionary
TCDRegular :: TypeClassDictionaryType

-- | A type class dictionary which is an alias for an imported dictionary
--   from another module
TCDAlias :: (Qualified Ident) -> TypeClassDictionaryType

-- | A simplified representation of expressions which are used to represent
--   type class dictionaries at runtime, which can be compared for equality
data DictionaryValue

-- | A dictionary which is brought into scope by a local constraint
LocalDictionaryValue :: (Qualified Ident) -> DictionaryValue

-- | A dictionary which is brought into scope by an instance declaration
GlobalDictionaryValue :: (Qualified Ident) -> DictionaryValue

-- | A dictionary which depends on other dictionaries
DependentDictionaryValue :: (Qualified Ident) -> [DictionaryValue] -> DictionaryValue

-- | A subclass dictionary
SubclassDictionaryValue :: DictionaryValue -> (Qualified ProperName) -> Integer -> DictionaryValue

-- | Find the original dictionary which a type class dictionary in scope
--   refers to
canonicalizeDictionary :: TypeClassDictionaryInScope -> Qualified Ident
instance Typeable TypeClassDictionaryType
instance Typeable TypeClassDictionaryInScope
instance Show TypeClassDictionaryType
instance Eq TypeClassDictionaryType
instance Data TypeClassDictionaryType
instance Show TypeClassDictionaryInScope
instance Data TypeClassDictionaryInScope
instance Show DictionaryValue
instance Ord DictionaryValue
instance Eq DictionaryValue


module Language.PureScript.Environment

-- | The <tt>Environment</tt> defines all values and types which are
--   currently in scope:
data Environment
Environment :: Map (ModuleName, Ident) (Type, NameKind, NameVisibility) -> Map (Qualified ProperName) (Kind, TypeKind) -> Map (Qualified ProperName) (DataDeclType, ProperName, Type, [Ident]) -> Map (Qualified ProperName) ([(String, Maybe Kind)], Type) -> Map (Maybe ModuleName) (Map (Qualified ProperName) (Map (Qualified Ident) TypeClassDictionaryInScope)) -> Map (Qualified ProperName) ([(String, Maybe Kind)], [(Ident, Type)], [Constraint]) -> Environment

-- | Value names currently in scope
names :: Environment -> Map (ModuleName, Ident) (Type, NameKind, NameVisibility)

-- | Type names currently in scope
types :: Environment -> Map (Qualified ProperName) (Kind, TypeKind)

-- | Data constructors currently in scope, along with their associated data
--   type constructors
dataConstructors :: Environment -> Map (Qualified ProperName) (DataDeclType, ProperName, Type, [Ident])

-- | Type synonyms currently in scope
typeSynonyms :: Environment -> Map (Qualified ProperName) ([(String, Maybe Kind)], Type)

-- | Available type class dictionaries
typeClassDictionaries :: Environment -> Map (Maybe ModuleName) (Map (Qualified ProperName) (Map (Qualified Ident) TypeClassDictionaryInScope))

-- | Type classes
typeClasses :: Environment -> Map (Qualified ProperName) ([(String, Maybe Kind)], [(Ident, Type)], [Constraint])

-- | The initial environment with no values and only the default javascript
--   types defined
initEnvironment :: Environment

-- | The visibility of a name in scope
data NameVisibility

-- | The name is defined in the current binding group, but is not visible
Undefined :: NameVisibility

-- | The name is defined in the another binding group, or has been made
--   visible by a function binder
Defined :: NameVisibility

-- | A flag for whether a name is for an private or public value - only
--   public values will be included in a generated externs file.
data NameKind

-- | A private value introduced as an artifact of code generation (class
--   instances, class member accessors, etc.)
Private :: NameKind

-- | A public value for a module member or foreing import declaration
Public :: NameKind

-- | A name for member introduced by foreign import
External :: NameKind

-- | The kinds of a type
data TypeKind

-- | Data type
DataType :: [(String, Maybe Kind)] -> [(ProperName, [Type])] -> TypeKind

-- | Type synonym
TypeSynonym :: TypeKind

-- | Foreign data
ExternData :: TypeKind

-- | A local type variable
LocalTypeVariable :: TypeKind

-- | A scoped type variable
ScopedTypeVar :: TypeKind

-- | The type ('data' or 'newtype') of a data type declaration
data DataDeclType

-- | A standard data constructor
Data :: DataDeclType

-- | A newtype constructor
Newtype :: DataDeclType

-- | Construct a ProperName in the Prim module
primName :: String -> Qualified ProperName

-- | Construct a type in the Prim module
primTy :: String -> Type

-- | Type constructor for functions
tyFunction :: Type

-- | Type constructor for strings
tyString :: Type

-- | Type constructor for strings
tyChar :: Type

-- | Type constructor for numbers
tyNumber :: Type

-- | Type constructor for integers
tyInt :: Type

-- | Type constructor for booleans
tyBoolean :: Type

-- | Type constructor for arrays
tyArray :: Type

-- | Type constructor for objects
tyObject :: Type

-- | Check whether a type is an object
isObject :: Type -> Bool

-- | Smart constructor for function types
function :: Type -> Type -> Type

-- | The primitive types in the external javascript environment with their
--   associated kinds.
primTypes :: Map (Qualified ProperName) (Kind, TypeKind)

-- | Finds information about data constructors from the current
--   environment.
lookupConstructor :: Environment -> Qualified ProperName -> (DataDeclType, ProperName, Type, [Ident])

-- | Checks whether a data constructor is for a newtype.
isNewtypeConstructor :: Environment -> Qualified ProperName -> Bool

-- | Finds information about values from the current environment.
lookupValue :: Environment -> Qualified Ident -> Maybe (Type, NameKind, NameVisibility)
instance Typeable NameKind
instance Typeable TypeKind
instance Typeable DataDeclType
instance Show NameVisibility
instance Eq NameVisibility
instance Show NameKind
instance Eq NameKind
instance Data NameKind
instance Show TypeKind
instance Eq TypeKind
instance Data TypeKind
instance Eq DataDeclType
instance Ord DataDeclType
instance Data DataDeclType
instance Show Environment
instance FromJSON DataDeclType
instance ToJSON DataDeclType
instance Show DataDeclType


-- | Defines the types of source code comments
module Language.PureScript.Comments
data Comment
LineComment :: String -> Comment
BlockComment :: String -> Comment
instance Typeable Comment
instance Show Comment
instance Eq Comment
instance Ord Comment
instance Data Comment


-- | Case binders
module Language.PureScript.AST.Binders

-- | Data type for binders
data Binder

-- | Wildcard binder
NullBinder :: Binder

-- | A binder which matches a boolean literal
BooleanBinder :: Bool -> Binder

-- | A binder which matches a string literal
StringBinder :: String -> Binder

-- | A binder which matches a character literal
CharBinder :: Char -> Binder

-- | A binder which matches a numeric literal
NumberBinder :: (Either Integer Double) -> Binder

-- | A binder which binds an identifier
VarBinder :: Ident -> Binder

-- | A binder which matches a data constructor
ConstructorBinder :: (Qualified ProperName) -> [Binder] -> Binder

-- | A binder which matches a record and binds its properties
ObjectBinder :: [(String, Binder)] -> Binder

-- | A binder which matches an array and binds its elements
ArrayBinder :: [Binder] -> Binder

-- | A binder which binds its input to an identifier
NamedBinder :: Ident -> Binder -> Binder

-- | A binder with source position information
PositionedBinder :: SourceSpan -> [Comment] -> Binder -> Binder

-- | Collect all names introduced in binders in an expression
binderNames :: Binder -> [Ident]
instance Typeable Binder
instance Show Binder
instance Data Binder


-- | Data types for modules and declarations
module Language.PureScript.AST.Declarations

-- | A module declaration, consisting of comments about the module, a
--   module name, a list of declarations, and a list of the declarations
--   that are explicitly exported. If the export list is Nothing,
--   everything is exported.
data Module
Module :: [Comment] -> ModuleName -> [Declaration] -> (Maybe [DeclarationRef]) -> Module

-- | Return a module's name.
getModuleName :: Module -> ModuleName

-- | An item in a list of explicit imports or exports
data DeclarationRef

-- | A type constructor with data constructors
TypeRef :: ProperName -> (Maybe [ProperName]) -> DeclarationRef

-- | A value
ValueRef :: Ident -> DeclarationRef

-- | A type class
TypeClassRef :: ProperName -> DeclarationRef

-- | A type class instance, created during typeclass desugaring (name,
--   class name, instance types)
TypeInstanceRef :: Ident -> DeclarationRef

-- | A module, in its entirety
ModuleRef :: ModuleName -> DeclarationRef

-- | A declaration reference with source position information
PositionedDeclarationRef :: SourceSpan -> [Comment] -> DeclarationRef -> DeclarationRef

-- | The data type which specifies type of import declaration
data ImportDeclarationType

-- | An import with no explicit list: `import M`
Implicit :: ImportDeclarationType

-- | An import with an explicit list of references to import: `import M
--   (foo)`
Explicit :: [DeclarationRef] -> ImportDeclarationType

-- | An import with a list of references to hide: `import M hiding (foo)`
Hiding :: [DeclarationRef] -> ImportDeclarationType

-- | The data type of declarations
data Declaration

-- | A data type declaration (data or newtype, name, arguments, data
--   constructors)
DataDeclaration :: DataDeclType -> ProperName -> [(String, Maybe Kind)] -> [(ProperName, [Type])] -> Declaration

-- | A minimal mutually recursive set of data type declarations
DataBindingGroupDeclaration :: [Declaration] -> Declaration

-- | A type synonym declaration (name, arguments, type)
TypeSynonymDeclaration :: ProperName -> [(String, Maybe Kind)] -> Type -> Declaration

-- | A type declaration for a value (name, ty)
TypeDeclaration :: Ident -> Type -> Declaration

-- | A value declaration (name, top-level binders, optional guard, value)
ValueDeclaration :: Ident -> NameKind -> [Binder] -> (Either [(Guard, Expr)] Expr) -> Declaration

-- | A minimal mutually recursive set of value declarations
BindingGroupDeclaration :: [(Ident, NameKind, Expr)] -> Declaration

-- | A foreign import declaration (name, type)
ExternDeclaration :: Ident -> Type -> Declaration

-- | A data type foreign import (name, kind)
ExternDataDeclaration :: ProperName -> Kind -> Declaration

-- | A type class instance foreign import
ExternInstanceDeclaration :: Ident -> [Constraint] -> (Qualified ProperName) -> [Type] -> Declaration

-- | A fixity declaration (fixity data, operator name)
FixityDeclaration :: Fixity -> String -> Declaration

-- | A module import (module name, qualified<i>unqualified</i>hiding,
--   optional "qualified as" name)
ImportDeclaration :: ModuleName -> ImportDeclarationType -> (Maybe ModuleName) -> Declaration

-- | A type class declaration (name, argument, implies, member
--   declarations)
TypeClassDeclaration :: ProperName -> [(String, Maybe Kind)] -> [Constraint] -> [Declaration] -> Declaration

-- | A type instance declaration (name, dependencies, class name, instance
--   types, member declarations)
TypeInstanceDeclaration :: Ident -> [Constraint] -> (Qualified ProperName) -> [Type] -> [Declaration] -> Declaration

-- | A declaration with source position information
PositionedDeclaration :: SourceSpan -> [Comment] -> Declaration -> Declaration

-- | Test if a declaration is a value declaration
isValueDecl :: Declaration -> Bool

-- | Test if a declaration is a data type or type synonym declaration
isDataDecl :: Declaration -> Bool

-- | Test if a declaration is a module import
isImportDecl :: Declaration -> Bool

-- | Test if a declaration is a data type foreign import
isExternDataDecl :: Declaration -> Bool

-- | Test if a declaration is a type class instance foreign import
isExternInstanceDecl :: Declaration -> Bool

-- | Test if a declaration is a fixity declaration
isFixityDecl :: Declaration -> Bool

-- | Test if a declaration is a foreign import
isExternDecl :: Declaration -> Bool

-- | Test if a declaration is a type class instance declaration
isTypeClassInstanceDeclaration :: Declaration -> Bool

-- | Test if a declaration is a type class declaration
isTypeClassDeclaration :: Declaration -> Bool

-- | Recursively flatten data binding groups in the list of declarations
flattenDecls :: [Declaration] -> [Declaration]

-- | A guard is just a boolean-valued expression that appears alongside a
--   set of binders
type Guard = Expr

-- | Data type for expressions and terms
data Expr

-- | A numeric literal
NumericLiteral :: (Either Integer Double) -> Expr

-- | A string literal
StringLiteral :: String -> Expr

-- | A character literal
CharLiteral :: Char -> Expr

-- | A boolean literal
BooleanLiteral :: Bool -> Expr

-- | A prefix -, will be desugared
UnaryMinus :: Expr -> Expr

-- | Binary operator application. During the rebracketing phase of
--   desugaring, this data constructor will be removed.
BinaryNoParens :: Expr -> Expr -> Expr -> Expr

-- | Explicit parentheses. During the rebracketing phase of desugaring,
--   this data constructor will be removed.
Parens :: Expr -> Expr

-- | Operator section. This will be removed during desugaring and replaced
--   with a partially applied operator or lambda to flip the arguments.
OperatorSection :: Expr -> (Either Expr Expr) -> Expr

-- | An array literal
ArrayLiteral :: [Expr] -> Expr

-- | An object literal
ObjectLiteral :: [(String, Expr)] -> Expr

-- | An object constructor (object literal with underscores). This will be
--   removed during desugaring and expanded into a lambda that returns an
--   object literal.
ObjectConstructor :: [(String, Maybe Expr)] -> Expr

-- | An object property getter (e.g. `_.x`). This will be removed during
--   desugaring and expanded into a lambda that reads a property from an
--   object.
ObjectGetter :: String -> Expr

-- | An record property accessor expression
Accessor :: String -> Expr -> Expr

-- | Partial record update
ObjectUpdate :: Expr -> [(String, Expr)] -> Expr

-- | Partial record updater. This will be removed during desugaring and
--   expanded into a lambda that returns an object update.
ObjectUpdater :: (Maybe Expr) -> [(String, Maybe Expr)] -> Expr

-- | Function introduction
Abs :: (Either Ident Binder) -> Expr -> Expr

-- | Function application
App :: Expr -> Expr -> Expr

-- | Variable
Var :: (Qualified Ident) -> Expr

-- | Conditional (if-then-else expression)
IfThenElse :: Expr -> Expr -> Expr -> Expr

-- | A data constructor
Constructor :: (Qualified ProperName) -> Expr

-- | A case expression. During the case expansion phase of desugaring,
--   top-level binders will get desugared into case expressions, hence the
--   need for guards and multiple binders per branch here.
Case :: [Expr] -> [CaseAlternative] -> Expr

-- | A value with a type annotation
TypedValue :: Bool -> Expr -> Type -> Expr

-- | A let binding
Let :: [Declaration] -> Expr -> Expr

-- | A do-notation block
Do :: [DoNotationElement] -> Expr

-- | An application of a typeclass dictionary constructor. The value should
--   be an ObjectLiteral.
TypeClassDictionaryConstructorApp :: (Qualified ProperName) -> Expr -> Expr

-- | A placeholder for a type class dictionary to be inserted later. At the
--   end of type checking, these placeholders will be replaced with actual
--   expressions representing type classes dictionaries which can be
--   evaluated at runtime. The constructor arguments represent (in order):
--   whether or not to look at superclass implementations when searching
--   for a dictionary, the type class name and instance type, and the type
--   class dictionaries in scope.
TypeClassDictionary :: Bool -> Constraint -> (Map (Maybe ModuleName) (Map (Qualified ProperName) (Map (Qualified Ident) TypeClassDictionaryInScope))) -> Expr

-- | A typeclass dictionary accessor, the implementation is left
--   unspecified until CoreFn desugaring.
TypeClassDictionaryAccessor :: (Qualified ProperName) -> Ident -> Expr

-- | A placeholder for a superclass dictionary to be turned into a
--   TypeClassDictionary during typechecking
SuperClassDictionary :: (Qualified ProperName) -> [Type] -> Expr

-- | A value with source position information
PositionedValue :: SourceSpan -> [Comment] -> Expr -> Expr

-- | An alternative in a case statement
data CaseAlternative
CaseAlternative :: [Binder] -> Either [(Guard, Expr)] Expr -> CaseAlternative

-- | A collection of binders with which to match the inputs
caseAlternativeBinders :: CaseAlternative -> [Binder]

-- | The result expression or a collect of guarded expressions
caseAlternativeResult :: CaseAlternative -> Either [(Guard, Expr)] Expr

-- | A statement in a do-notation block
data DoNotationElement

-- | A monadic value without a binder
DoNotationValue :: Expr -> DoNotationElement

-- | A monadic value with a binder
DoNotationBind :: Binder -> Expr -> DoNotationElement

-- | A let statement, i.e. a pure value with a binder
DoNotationLet :: [Declaration] -> DoNotationElement

-- | A do notation element with source position information
PositionedDoNotationElement :: SourceSpan -> [Comment] -> DoNotationElement -> DoNotationElement
instance Typeable DeclarationRef
instance Typeable ImportDeclarationType
instance Typeable DoNotationElement
instance Typeable Expr
instance Typeable CaseAlternative
instance Typeable Declaration
instance Typeable Module
instance Show DeclarationRef
instance Data DeclarationRef
instance Show ImportDeclarationType
instance Data ImportDeclarationType
instance Show DoNotationElement
instance Data DoNotationElement
instance Show Expr
instance Data Expr
instance Show CaseAlternative
instance Data CaseAlternative
instance Show Declaration
instance Data Declaration
instance Show Module
instance Data Module
instance Eq DeclarationRef


-- | AST traversal helpers
module Language.PureScript.AST.Traversals
everywhereOnValues :: (Declaration -> Declaration) -> (Expr -> Expr) -> (Binder -> Binder) -> (Declaration -> Declaration, Expr -> Expr, Binder -> Binder)
everywhereOnValuesTopDownM :: (Functor m, Applicative m, Monad m) => (Declaration -> m Declaration) -> (Expr -> m Expr) -> (Binder -> m Binder) -> (Declaration -> m Declaration, Expr -> m Expr, Binder -> m Binder)
everywhereOnValuesM :: (Functor m, Applicative m, Monad m) => (Declaration -> m Declaration) -> (Expr -> m Expr) -> (Binder -> m Binder) -> (Declaration -> m Declaration, Expr -> m Expr, Binder -> m Binder)
everythingOnValues :: (r -> r -> r) -> (Declaration -> r) -> (Expr -> r) -> (Binder -> r) -> (CaseAlternative -> r) -> (DoNotationElement -> r) -> (Declaration -> r, Expr -> r, Binder -> r, CaseAlternative -> r, DoNotationElement -> r)
everythingWithContextOnValues :: s -> r -> (r -> r -> r) -> (s -> Declaration -> (s, r)) -> (s -> Expr -> (s, r)) -> (s -> Binder -> (s, r)) -> (s -> CaseAlternative -> (s, r)) -> (s -> DoNotationElement -> (s, r)) -> (Declaration -> r, Expr -> r, Binder -> r, CaseAlternative -> r, DoNotationElement -> r)
everywhereWithContextOnValuesM :: (Functor m, Applicative m, Monad m) => s -> (s -> Declaration -> m (s, Declaration)) -> (s -> Expr -> m (s, Expr)) -> (s -> Binder -> m (s, Binder)) -> (s -> CaseAlternative -> m (s, CaseAlternative)) -> (s -> DoNotationElement -> m (s, DoNotationElement)) -> (Declaration -> m Declaration, Expr -> m Expr, Binder -> m Binder, CaseAlternative -> m CaseAlternative, DoNotationElement -> m DoNotationElement)
accumTypes :: Monoid r => (Type -> r) -> (Declaration -> r, Expr -> r, Binder -> r, CaseAlternative -> r, DoNotationElement -> r)

module Language.PureScript.AST.Exported

-- | Return a list of all declarations which are exported from a module.
--   This function descends into data declarations to filter out unexported
--   data constructors, and also filters out type instance declarations if
--   they refer to classes or types which are not themselves exported.
--   
--   Note that this function assumes that the module has already had its
--   imports desugared using <a>desugarImports</a>. It will produce
--   incorrect results if this is not the case - for example, type class
--   instances will be incorrectly removed in some cases.
exportedDeclarations :: Module -> [Declaration]

-- | Test if a declaration is exported, given a module's export list. Note
--   that this function does not account for type instance declarations of
--   non-exported types, or non-exported data constructors. Therefore, you
--   should prefer <a>exportedDeclarations</a> to this function, where
--   possible.
isExported :: Maybe [DeclarationRef] -> Declaration -> Bool


-- | Data types for the intermediate simplified-Javascript AST
module Language.PureScript.CodeGen.JS.AST

-- | Built-in unary operators
data UnaryOperator

-- | Numeric negation
Negate :: UnaryOperator

-- | Boolean negation
Not :: UnaryOperator

-- | Bitwise negation
BitwiseNot :: UnaryOperator

-- | Numeric unary 'plus'
Positive :: UnaryOperator

-- | Constructor
JSNew :: UnaryOperator

-- | Built-in binary operators
data BinaryOperator

-- | Numeric addition
Add :: BinaryOperator

-- | Numeric subtraction
Subtract :: BinaryOperator

-- | Numeric multiplication
Multiply :: BinaryOperator

-- | Numeric division
Divide :: BinaryOperator

-- | Remainder
Modulus :: BinaryOperator

-- | Generic equality test
EqualTo :: BinaryOperator

-- | Generic inequality test
NotEqualTo :: BinaryOperator

-- | Numeric less-than
LessThan :: BinaryOperator

-- | Numeric less-than-or-equal
LessThanOrEqualTo :: BinaryOperator

-- | Numeric greater-than
GreaterThan :: BinaryOperator

-- | Numeric greater-than-or-equal
GreaterThanOrEqualTo :: BinaryOperator

-- | Boolean and
And :: BinaryOperator

-- | Boolean or
Or :: BinaryOperator

-- | Bitwise and
BitwiseAnd :: BinaryOperator

-- | Bitwise or
BitwiseOr :: BinaryOperator

-- | Bitwise xor
BitwiseXor :: BinaryOperator

-- | Bitwise left shift
ShiftLeft :: BinaryOperator

-- | Bitwise right shift
ShiftRight :: BinaryOperator

-- | Bitwise right shift with zero-fill
ZeroFillShiftRight :: BinaryOperator

-- | Data type for simplified Javascript expressions
data JS

-- | A numeric literal
JSNumericLiteral :: (Either Integer Double) -> JS

-- | A string literal
JSStringLiteral :: String -> JS

-- | A boolean literal
JSBooleanLiteral :: Bool -> JS

-- | A unary operator application
JSUnary :: UnaryOperator -> JS -> JS

-- | A binary operator application
JSBinary :: BinaryOperator -> JS -> JS -> JS

-- | An array literal
JSArrayLiteral :: [JS] -> JS

-- | An array indexer expression
JSIndexer :: JS -> JS -> JS

-- | An object literal
JSObjectLiteral :: [(String, JS)] -> JS

-- | An object property accessor expression
JSAccessor :: String -> JS -> JS

-- | A function introduction (optional name, arguments, body)
JSFunction :: (Maybe String) -> [String] -> JS -> JS

-- | Function application
JSApp :: JS -> [JS] -> JS

-- | Variable
JSVar :: String -> JS

-- | Conditional expression
JSConditional :: JS -> JS -> JS -> JS

-- | A block of expressions in braces
JSBlock :: [JS] -> JS

-- | A variable introduction and optional initialization
JSVariableIntroduction :: String -> (Maybe JS) -> JS

-- | A variable assignment
JSAssignment :: JS -> JS -> JS

-- | While loop
JSWhile :: JS -> JS -> JS

-- | For loop
JSFor :: String -> JS -> JS -> JS -> JS

-- | ForIn loop
JSForIn :: String -> JS -> JS -> JS

-- | If-then-else statement
JSIfElse :: JS -> JS -> (Maybe JS) -> JS

-- | Return statement
JSReturn :: JS -> JS

-- | Throw statement
JSThrow :: JS -> JS

-- | Type-Of operator
JSTypeOf :: JS -> JS

-- | InstanceOf test
JSInstanceOf :: JS -> JS -> JS

-- | Labelled statement
JSLabel :: String -> JS -> JS

-- | Break statement
JSBreak :: String -> JS

-- | Continue statement
JSContinue :: String -> JS

-- | Raw Javascript (generated when parsing fails for an inline foreign
--   import declaration)
JSRaw :: String -> JS

-- | Commented Javascript
JSComment :: [Comment] -> JS -> JS
everywhereOnJS :: (JS -> JS) -> JS -> JS
everywhereOnJSTopDown :: (JS -> JS) -> JS -> JS
everywhereOnJSTopDownM :: (Applicative m, Monad m) => (JS -> m JS) -> JS -> m JS
everythingOnJS :: (r -> r -> r) -> (JS -> r) -> JS -> r
instance Typeable UnaryOperator
instance Typeable BinaryOperator
instance Typeable JS
instance Show UnaryOperator
instance Eq UnaryOperator
instance Data UnaryOperator
instance Show BinaryOperator
instance Eq BinaryOperator
instance Data BinaryOperator
instance Show JS
instance Eq JS
instance Data JS


-- | Common functions used by the various optimizer phases
module Language.PureScript.CodeGen.JS.Optimizer.Common
applyAll :: [a -> a] -> a -> a
replaceIdent :: String -> JS -> JS -> JS
replaceIdents :: [(String, JS)] -> JS -> JS
isReassigned :: String -> JS -> Bool
isRebound :: JS -> JS -> Bool
isUsed :: String -> JS -> Bool
targetVariable :: JS -> String
isUpdated :: String -> JS -> Bool
removeFromBlock :: ([JS] -> [JS]) -> JS -> JS


-- | This module implements tail call elimination.
module Language.PureScript.CodeGen.JS.Optimizer.TCO

-- | Eliminate tail calls
tco :: Options -> JS -> JS


-- | This module implements the "Magic Do" optimization, which inlines
--   calls to return and bind for the Eff monad, as well as some of its
--   actions.
module Language.PureScript.CodeGen.JS.Optimizer.MagicDo
magicDo :: Options -> JS -> JS


-- | Removes unused variables
module Language.PureScript.CodeGen.JS.Optimizer.Unused
removeCodeAfterReturnStatements :: JS -> JS
removeUnusedArg :: JS -> JS
removeUndefinedApp :: JS -> JS


-- | Optimizer steps for simplifying Javascript blocks
module Language.PureScript.CodeGen.JS.Optimizer.Blocks

-- | Collapse blocks which appear nested directly below another block
collapseNestedBlocks :: JS -> JS
collapseNestedIfs :: JS -> JS


-- | Type alias for basic annotations
module Language.PureScript.CoreFn.Ann

-- | Type alias for basic annotations
type Ann = (Maybe SourceSpan, [Comment], Maybe Type, Maybe Meta)

-- | Initial annotation with no metadata
nullAnn :: Ann

-- | Remove the comments from an annotation
removeComments :: Ann -> Ann


-- | The CoreFn module representation
module Language.PureScript.CoreFn.Module
data Module a
Module :: [Comment] -> ModuleName -> [ModuleName] -> [Ident] -> [ForeignDecl] -> [Bind a] -> Module a
moduleComments :: Module a -> [Comment]
moduleName :: Module a -> ModuleName
moduleImports :: Module a -> [ModuleName]
moduleExports :: Module a -> [Ident]
moduleForeign :: Module a -> [ForeignDecl]
moduleDecls :: Module a -> [Bind a]
type ForeignDecl = (Ident, Type)
instance Show a => Show (Module a)


-- | The first step in the parsing process - turns source code into a list
--   of lexemes
module Language.PureScript.Parser.Lexer
data PositionedToken
PositionedToken :: SourcePos -> Token -> [Comment] -> PositionedToken
ptSourcePos :: PositionedToken -> SourcePos
ptToken :: PositionedToken -> Token
ptComments :: PositionedToken -> [Comment]
data Token
type TokenParser a = Parsec [PositionedToken] ParseState a
lex :: FilePath -> String -> Either ParseError [PositionedToken]
anyToken :: TokenParser PositionedToken
token :: (Token -> Maybe a) -> TokenParser a
match :: Token -> TokenParser ()
lparen :: TokenParser ()
rparen :: TokenParser ()
parens :: TokenParser a -> TokenParser a
lbrace :: TokenParser ()
rbrace :: TokenParser ()
braces :: TokenParser a -> TokenParser a
lsquare :: TokenParser ()
rsquare :: TokenParser ()
squares :: TokenParser a -> TokenParser a
indent :: TokenParser Int
indentAt :: Column -> TokenParser ()
larrow :: TokenParser ()
rarrow :: TokenParser ()
lfatArrow :: TokenParser ()
rfatArrow :: TokenParser ()
colon :: TokenParser ()
doubleColon :: TokenParser ()
equals :: TokenParser ()
pipe :: TokenParser ()
tick :: TokenParser ()
dot :: TokenParser ()
comma :: TokenParser ()
semi :: TokenParser ()
at :: TokenParser ()
underscore :: TokenParser ()

-- | Parse zero or more values separated by semicolons
semiSep :: TokenParser a -> TokenParser [a]

-- | Parse one or more values separated by semicolons
semiSep1 :: TokenParser a -> TokenParser [a]

-- | Parse zero or more values separated by commas
commaSep :: TokenParser a -> TokenParser [a]

-- | Parse one or more values separated by commas
commaSep1 :: TokenParser a -> TokenParser [a]
lname :: TokenParser String
qualifier :: TokenParser String
uname :: TokenParser String
uname' :: String -> TokenParser ()
mname :: TokenParser String
reserved :: String -> TokenParser ()
symbol :: TokenParser String
symbol' :: String -> TokenParser ()
identifier :: TokenParser String
charLiteral :: TokenParser Char
stringLiteral :: TokenParser String
number :: TokenParser (Either Integer Double)
natural :: TokenParser Integer

-- | A list of purescript reserved identifiers
reservedPsNames :: [String]
reservedTypeNames :: [String]

-- | The characters allowed for use in operators
opChars :: [Char]
instance Show Token
instance Eq Token
instance Ord Token
instance Eq PositionedToken
instance Show PositionedToken


-- | Constants, and utility functions to be used when parsing
module Language.PureScript.Parser.Common
featureWasRemoved :: String -> TokenParser a
properName :: TokenParser ProperName

-- | Parse a module name
moduleName :: TokenParser ModuleName

-- | Parse a qualified name, i.e. M.name or just name
parseQualified :: TokenParser a -> TokenParser (Qualified a)

-- | Parse an identifier or parenthesized operator
parseIdent :: TokenParser Ident

-- | Run the first parser, then match the second if possible, applying the
--   specified function on a successful match
augment :: Stream s m t => ParsecT s u m a -> ParsecT s u m b -> (a -> b -> a) -> ParsecT s u m a

-- | Run the first parser, then match the second zero or more times,
--   applying the specified function for each match
fold :: Stream s m t => ParsecT s u m a -> ParsecT s u m b -> (a -> b -> a) -> ParsecT s u m a

-- | Build a parser from a smaller parser and a list of parsers for postfix
--   operators
buildPostfixParser :: Stream s m t => [a -> ParsecT s u m a] -> ParsecT s u m a -> ParsecT s u m a

-- | Mark the current indentation level
mark :: Parsec s ParseState a -> Parsec s ParseState a

-- | Check that the current identation level matches a predicate
checkIndentation :: (Column -> Column -> Bool) -> Parsec s ParseState ()

-- | Check that the current indentation level is past the current mark
indented :: Parsec s ParseState ()

-- | Check that the current indentation level is at the same indentation as
--   the current mark
same :: Parsec s ParseState ()

-- | Read the comments from the the next token, without consuming it
readComments :: Parsec [PositionedToken] u [Comment]

-- | Run a parser
runTokenParser :: FilePath -> TokenParser a -> [PositionedToken] -> Either ParseError a


-- | A parser for kinds
module Language.PureScript.Parser.Kinds

-- | Parse a kind
parseKind :: TokenParser Kind


-- | Parsers for types
module Language.PureScript.Parser.Types

-- | Parse a monotype
parseType :: TokenParser Type

-- | Parse a polytype
parsePolyType :: TokenParser Type

-- | Parse an atomic type with no wildcards
noWildcards :: TokenParser Type -> TokenParser Type

-- | Parse a type as it appears in e.g. a data constructor
parseTypeAtom :: TokenParser Type


-- | Common pretty-printing utility functions
module Language.PureScript.Pretty.Common

-- | Wrap a string in parentheses
parens :: String -> String
newtype PrinterState
PrinterState :: Int -> PrinterState
indent :: PrinterState -> Int

-- | Number of characters per identation level
blockIndent :: Int

-- | Pretty print with a new indentation level
withIndent :: StateT PrinterState Maybe String -> StateT PrinterState Maybe String

-- | Get the current indentation level
currentIndent :: StateT PrinterState Maybe String

-- | Print many lines
prettyPrintMany :: (a -> StateT PrinterState Maybe String) -> [a] -> StateT PrinterState Maybe String

-- | Prints an object key, escaping reserved names.
prettyPrintObjectKey :: String -> String
instance Show PrinterState
instance Eq PrinterState
instance Ord PrinterState


-- | Pretty printer for kinds
module Language.PureScript.Pretty.Kinds

-- | Generate a pretty-printed string representing a Kind
prettyPrintKind :: Kind -> String


-- | Pretty printer for Types
module Language.PureScript.Pretty.Types

-- | Generate a pretty-printed string representing a Type
prettyPrintType :: Type -> String

-- | Generate a pretty-printed string representing a Type, as it should
--   appear inside parentheses
prettyPrintTypeAtom :: Type -> String

-- | Generate a pretty-printed string representing a Row
prettyPrintRow :: Type -> String


-- | Pretty printer for the Javascript AST
module Language.PureScript.Pretty.JS

-- | Generate a pretty-printed string representing a collection of
--   Javascript expressions at the same indentation level
prettyPrintJS :: [JS] -> String


-- | The initial PureScript AST
module Language.PureScript.AST


-- | Pretty printer for values
module Language.PureScript.Pretty.Values

-- | Generate a pretty-printed string representing an expression
prettyPrintValue :: Expr -> String

-- | Generate a pretty-printed string representing a Binder
prettyPrintBinder :: Binder -> String


-- | A collection of pretty printers for core data types:
--   
--   <ul>
--   <li><i><tt>Language.PureScript.Pretty.Kinds</tt></i> Pretty printer
--   for kinds</li>
--   <li><i><tt>Language.PureScript.Pretty.Values</tt></i> Pretty printer
--   for values</li>
--   <li><i><tt>Language.PureScript.Pretty.Types</tt></i> Pretty printer
--   for types</li>
--   <li><i><tt>Language.PureScript.Pretty.JS</tt></i> Pretty printer for
--   values, used for code generation</li>
--   </ul>
module Language.PureScript.Pretty


-- | This module generates code for "externs" files, i.e. files containing
--   only foreign import declarations.
module Language.PureScript.CodeGen.Externs

-- | Generate foreign imports for all declarations in a module
moduleToPs :: Module -> Environment -> String


module Language.PureScript.Errors

-- | A type of error messages
data SimpleErrorMessage
ErrorParsingExterns :: ParseError -> SimpleErrorMessage
ErrorParsingFFIModule :: FilePath -> SimpleErrorMessage
ErrorParsingModule :: ParseError -> SimpleErrorMessage
MissingFFIModule :: ModuleName -> SimpleErrorMessage
MultipleFFIModules :: ModuleName -> [FilePath] -> SimpleErrorMessage
UnnecessaryFFIModule :: ModuleName -> FilePath -> SimpleErrorMessage
InvalidExternsFile :: FilePath -> SimpleErrorMessage
CannotGetFileInfo :: FilePath -> SimpleErrorMessage
CannotReadFile :: FilePath -> SimpleErrorMessage
CannotWriteFile :: FilePath -> SimpleErrorMessage
InfiniteType :: Type -> SimpleErrorMessage
InfiniteKind :: Kind -> SimpleErrorMessage
CannotReorderOperators :: SimpleErrorMessage
MultipleFixities :: Ident -> SimpleErrorMessage
OrphanTypeDeclaration :: Ident -> SimpleErrorMessage
OrphanFixityDeclaration :: String -> SimpleErrorMessage
RedefinedModule :: ModuleName -> SimpleErrorMessage
RedefinedIdent :: Ident -> SimpleErrorMessage
OverlappingNamesInLet :: SimpleErrorMessage
UnknownModule :: ModuleName -> SimpleErrorMessage
UnknownType :: (Qualified ProperName) -> SimpleErrorMessage
UnknownTypeClass :: (Qualified ProperName) -> SimpleErrorMessage
UnknownValue :: (Qualified Ident) -> SimpleErrorMessage
UnknownDataConstructor :: (Qualified ProperName) -> (Maybe (Qualified ProperName)) -> SimpleErrorMessage
UnknownTypeConstructor :: (Qualified ProperName) -> SimpleErrorMessage
ConflictingImport :: String -> ModuleName -> SimpleErrorMessage
ConflictingImports :: String -> ModuleName -> ModuleName -> SimpleErrorMessage
ConflictingTypeDecls :: ProperName -> SimpleErrorMessage
ConflictingCtorDecls :: ProperName -> SimpleErrorMessage
TypeConflictsWithClass :: ProperName -> SimpleErrorMessage
CtorConflictsWithClass :: ProperName -> SimpleErrorMessage
ClassConflictsWithType :: ProperName -> SimpleErrorMessage
ClassConflictsWithCtor :: ProperName -> SimpleErrorMessage
DuplicateClassExport :: ProperName -> SimpleErrorMessage
DuplicateValueExport :: Ident -> SimpleErrorMessage
DuplicateTypeArgument :: String -> SimpleErrorMessage
InvalidDoBind :: SimpleErrorMessage
InvalidDoLet :: SimpleErrorMessage
CycleInDeclaration :: Ident -> SimpleErrorMessage
CycleInTypeSynonym :: (Maybe ProperName) -> SimpleErrorMessage
CycleInModules :: [ModuleName] -> SimpleErrorMessage
NameIsUndefined :: Ident -> SimpleErrorMessage
NameNotInScope :: Ident -> SimpleErrorMessage
UndefinedTypeVariable :: ProperName -> SimpleErrorMessage
PartiallyAppliedSynonym :: (Qualified ProperName) -> SimpleErrorMessage
EscapedSkolem :: (Maybe Expr) -> SimpleErrorMessage
UnspecifiedSkolemScope :: SimpleErrorMessage
TypesDoNotUnify :: Type -> Type -> SimpleErrorMessage
KindsDoNotUnify :: Kind -> Kind -> SimpleErrorMessage
ConstrainedTypeUnified :: Type -> Type -> SimpleErrorMessage
OverlappingInstances :: (Qualified ProperName) -> [Type] -> [DictionaryValue] -> SimpleErrorMessage
NoInstanceFound :: (Qualified ProperName) -> [Type] -> SimpleErrorMessage
DuplicateLabel :: String -> (Maybe Expr) -> SimpleErrorMessage
DuplicateValueDeclaration :: Ident -> SimpleErrorMessage
ArgListLengthsDiffer :: Ident -> SimpleErrorMessage
OverlappingArgNames :: (Maybe Ident) -> SimpleErrorMessage
MissingClassMember :: Ident -> SimpleErrorMessage
ExtraneousClassMember :: Ident -> SimpleErrorMessage
ExpectedType :: Kind -> SimpleErrorMessage
IncorrectConstructorArity :: (Qualified ProperName) -> SimpleErrorMessage
SubsumptionCheckFailed :: SimpleErrorMessage
ExprDoesNotHaveType :: Expr -> Type -> SimpleErrorMessage
PropertyIsMissing :: String -> Type -> SimpleErrorMessage
CannotApplyFunction :: Type -> Expr -> SimpleErrorMessage
TypeSynonymInstance :: SimpleErrorMessage
InvalidNewtype :: SimpleErrorMessage
InvalidInstanceHead :: Type -> SimpleErrorMessage
TransitiveExportError :: DeclarationRef -> [DeclarationRef] -> SimpleErrorMessage
ShadowedName :: Ident -> SimpleErrorMessage
WildcardInferredType :: Type -> SimpleErrorMessage
ClassOperator :: ProperName -> Ident -> SimpleErrorMessage

-- | Wrapper of simpler errors
data ErrorMessage
NotYetDefined :: [Ident] -> ErrorMessage -> ErrorMessage
ErrorUnifyingTypes :: Type -> Type -> ErrorMessage -> ErrorMessage
ErrorInExpression :: Expr -> ErrorMessage -> ErrorMessage
ErrorInModule :: ModuleName -> ErrorMessage -> ErrorMessage
ErrorInInstance :: (Qualified ProperName) -> [Type] -> ErrorMessage -> ErrorMessage
ErrorInSubsumption :: Type -> Type -> ErrorMessage -> ErrorMessage
ErrorCheckingType :: Expr -> Type -> ErrorMessage -> ErrorMessage
ErrorCheckingKind :: Type -> ErrorMessage -> ErrorMessage
ErrorInferringType :: Expr -> ErrorMessage -> ErrorMessage
ErrorInApplication :: Expr -> Type -> Expr -> ErrorMessage -> ErrorMessage
ErrorInDataConstructor :: ProperName -> ErrorMessage -> ErrorMessage
ErrorInTypeConstructor :: ProperName -> ErrorMessage -> ErrorMessage
ErrorInBindingGroup :: [Ident] -> ErrorMessage -> ErrorMessage
ErrorInDataBindingGroup :: ErrorMessage -> ErrorMessage
ErrorInTypeSynonym :: ProperName -> ErrorMessage -> ErrorMessage
ErrorInValueDeclaration :: Ident -> ErrorMessage -> ErrorMessage
ErrorInForeignImport :: Ident -> ErrorMessage -> ErrorMessage
PositionedError :: SourceSpan -> ErrorMessage -> ErrorMessage
SimpleErrorWrapper :: SimpleErrorMessage -> ErrorMessage

-- | Get the error code for a particular error type
errorCode :: ErrorMessage -> String

-- | A stack trace for an error
newtype MultipleErrors
MultipleErrors :: [ErrorMessage] -> MultipleErrors
runMultipleErrors :: MultipleErrors -> [ErrorMessage]

-- | Check whether a collection of errors is empty or not.
nonEmpty :: MultipleErrors -> Bool

-- | Create an error set from a single simple error message
errorMessage :: SimpleErrorMessage -> MultipleErrors

-- | Create an error set from a single error message
singleError :: ErrorMessage -> MultipleErrors

-- | Lift a function on ErrorMessage to a function on MultipleErrors
onErrorMessages :: (ErrorMessage -> ErrorMessage) -> MultipleErrors -> MultipleErrors

-- | The various types of things which might need to be relabelled in
--   errors messages.
data LabelType
TypeLabel :: LabelType
SkolemLabel :: String -> LabelType

-- | A map from rigid type variable name/unknown variable pairs to new
--   variables.
type UnknownMap = Map (LabelType, Unknown) Unknown

-- | Extract nested error messages from wrapper errors
unwrapErrorMessage :: ErrorMessage -> SimpleErrorMessage
replaceUnknowns :: Type -> State UnknownMap Type
onTypesInErrorMessageM :: Applicative m => (Type -> m Type) -> ErrorMessage -> m ErrorMessage

-- | Pretty print a single error, simplifying if necessary
prettyPrintSingleError :: Bool -> ErrorMessage -> State UnknownMap Box

-- | Pretty print multiple errors
prettyPrintMultipleErrors :: Bool -> MultipleErrors -> String

-- | Pretty print multiple warnings
prettyPrintMultipleWarnings :: Bool -> MultipleErrors -> String
prettyPrintMultipleErrorsWith :: String -> String -> Bool -> MultipleErrors -> State UnknownMap String
renderBox :: Box -> String

-- | Interpret multiple errors and warnings in a monad supporting errors
--   and warnings
interpretMultipleErrorsAndWarnings :: (MonadError MultipleErrors m, MonadWriter MultipleErrors m) => (Either MultipleErrors a, MultipleErrors) -> m a

-- | Rethrow an error with a more detailed error message in the case of
--   failure
rethrow :: MonadError e m => (e -> e) -> m a -> m a

-- | Rethrow an error with source position information
rethrowWithPosition :: MonadError MultipleErrors m => SourceSpan -> m a -> m a

-- | Collect errors in in parallel
parU :: (MonadError MultipleErrors m, Functor m) => [a] -> (a -> m b) -> m [b]
instance Show SimpleErrorMessage
instance Show ErrorMessage
instance Show MultipleErrors
instance Monoid MultipleErrors
instance Show LabelType
instance Eq LabelType
instance Ord LabelType
instance UnificationError Kind MultipleErrors
instance UnificationError Type MultipleErrors
instance UnificationError Kind ErrorMessage
instance UnificationError Type ErrorMessage


-- | This module implements a simple linting pass on the PureScript AST.
module Language.PureScript.Linter

-- | Lint the PureScript AST. | | Right now, this pass only performs a
--   shadowing check.
lint :: (Applicative m, MonadWriter MultipleErrors m) => Module -> m ()


-- | Provides the ability to sort modules based on module dependencies
module Language.PureScript.ModuleDependencies

-- | Sort a collection of modules based on module dependencies.
--   
--   Reports an error if the module graph contains a cycle.
sortModules :: MonadError MultipleErrors m => [Module] -> m ([Module], ModuleGraph)

-- | A list of modules with their dependencies
type ModuleGraph = [(ModuleName, [ModuleName])]


-- | Parsers for module definitions and declarations
module Language.PureScript.Parser.Declarations

-- | Parse a single declaration
parseDeclaration :: TokenParser Declaration

-- | Parse a module header and a collection of declarations
parseModule :: TokenParser Module

-- | Parse a collection of modules
parseModules :: TokenParser [Module]

-- | Parse a collection of modules
parseModulesFromFiles :: (MonadError MultipleErrors m, Functor m) => (k -> String) -> [(k, String)] -> m [(k, Module)]

-- | Parse a value
parseValue :: TokenParser Expr

-- | Parse a guard
parseGuard :: TokenParser Guard

-- | Parse a binder
parseBinder :: TokenParser Binder

-- | Parse a binder as it would appear in a top level declaration
parseBinderNoParens :: TokenParser Binder
parseImportDeclaration' :: TokenParser (ModuleName, ImportDeclarationType, Maybe ModuleName)
parseLocalDeclaration :: TokenParser Declaration


module Language.PureScript.Parser.JS
type ForeignJS = String
parseForeignModulesFromFiles :: (Functor m, MonadError MultipleErrors m, MonadWriter MultipleErrors m) => [(FilePath, ForeignJS)] -> m (Map ModuleName (FilePath, ForeignJS))


-- | A collection of parsers for core data types:
--   
--   <ul>
--   <li><i><tt>Language.PureScript.Parser.Kinds</tt></i> Parser for
--   kinds</li>
--   <li><i><tt>Language.PureScript.Parser.Values</tt></i> Parser for
--   values</li>
--   <li><i><tt>Language.PureScript.Parser.Types</tt></i> Parser for
--   types</li>
--   <li><i><tt>Language.PureScript.Parser.Declaration</tt></i> Parsers for
--   declarations and modules</li>
--   <li><i><tt>Language.PureScript.Parser.State</tt></i> Parser state,
--   including indentation</li>
--   <li><i><tt>Language.PureScript.Parser.Common</tt></i> Common parsing
--   utility functions</li>
--   </ul>
module Language.PureScript.Parser


-- | Monads for type checking and type inference and associated data types
module Language.PureScript.TypeChecker.Monad

-- | Temporarily bind a collection of names to values
bindNames :: MonadState CheckState m => Map (ModuleName, Ident) (Type, NameKind, NameVisibility) -> m a -> m a

-- | Temporarily bind a collection of names to types
bindTypes :: MonadState CheckState m => Map (Qualified ProperName) (Kind, TypeKind) -> m a -> m a

-- | Temporarily bind a collection of names to types
withScopedTypeVars :: (Functor m, MonadState CheckState m) => ModuleName -> [(String, Kind)] -> m a -> m a

-- | Temporarily make a collection of type class dictionaries available
withTypeClassDictionaries :: MonadState CheckState m => [TypeClassDictionaryInScope] -> m a -> m a

-- | Get the currently available map of type class dictionaries
getTypeClassDictionaries :: (Functor m, MonadState CheckState m) => m (Map (Maybe ModuleName) (Map (Qualified ProperName) (Map (Qualified Ident) TypeClassDictionaryInScope)))

-- | Lookup type class dictionaries in a module.
lookupTypeClassDictionaries :: (Functor m, MonadState CheckState m) => Maybe ModuleName -> m (Map (Qualified ProperName) (Map (Qualified Ident) TypeClassDictionaryInScope))

-- | Temporarily bind a collection of names to local variables
bindLocalVariables :: (Functor m, MonadState CheckState m) => ModuleName -> [(Ident, Type, NameVisibility)] -> m a -> m a

-- | Temporarily bind a collection of names to local type variables
bindLocalTypeVariables :: (Functor m, MonadState CheckState m) => ModuleName -> [(ProperName, Kind)] -> m a -> m a

-- | Update the visibility of all names to Defined
makeBindingGroupVisible :: (Functor m, MonadState CheckState m) => m ()

-- | Update the visibility of all names to Defined in the scope of the
--   provided action
withBindingGroupVisible :: (Functor m, MonadState CheckState m) => m a -> m a

-- | Perform an action while preserving the names from the
--   <tt>Environment</tt>.
preservingNames :: (Functor m, MonadState CheckState m) => m a -> m a

-- | Lookup the type of a value by name in the <tt>Environment</tt>
lookupVariable :: (e ~ MultipleErrors, Functor m, MonadState CheckState m, MonadError e m) => ModuleName -> Qualified Ident -> m Type

-- | Lookup the visibility of a value by name in the <tt>Environment</tt>
getVisibility :: (e ~ MultipleErrors, Functor m, MonadState CheckState m, MonadError e m) => ModuleName -> Qualified Ident -> m NameVisibility

-- | Assert that a name is visible
checkVisibility :: (e ~ MultipleErrors, Functor m, MonadState CheckState m, MonadError e m) => ModuleName -> Qualified Ident -> m ()

-- | Lookup the kind of a type by name in the <tt>Environment</tt>
lookupTypeVariable :: (e ~ MultipleErrors, Functor m, MonadState CheckState m, MonadError e m) => ModuleName -> Qualified ProperName -> m Kind

-- | State required for type checking:
data CheckState
CheckState :: Environment -> Int -> Int -> Maybe ModuleName -> CheckState

-- | The current <tt>Environment</tt>
checkEnv :: CheckState -> Environment

-- | The next fresh unification variable name
checkNextVar :: CheckState -> Int

-- | The next type class dictionary name
checkNextDictName :: CheckState -> Int

-- | The current module
checkCurrentModule :: CheckState -> Maybe ModuleName

-- | The type checking monad, which provides the state of the type checker,
--   and error reporting capabilities
newtype Check a
Check :: StateT CheckState (ExceptT MultipleErrors (Writer MultipleErrors)) a -> Check a
unCheck :: Check a -> StateT CheckState (ExceptT MultipleErrors (Writer MultipleErrors)) a

-- | Get the current <tt>Environment</tt>
getEnv :: (Functor m, MonadState CheckState m) => m Environment

-- | Update the <tt>Environment</tt>
putEnv :: MonadState CheckState m => Environment -> m ()

-- | Modify the <tt>Environment</tt>
modifyEnv :: MonadState CheckState m => (Environment -> Environment) -> m ()

-- | Run a computation in the Check monad, starting with an empty
--   <tt>Environment</tt>
runCheck :: (MonadError MultipleErrors m, MonadWriter MultipleErrors m) => Check a -> m (a, Environment)

-- | Run a computation in the Check monad, failing with an error, or
--   succeeding with a return value and the final <tt>Environment</tt>.
runCheck' :: (MonadError MultipleErrors m, MonadWriter MultipleErrors m) => Environment -> Check a -> m (a, Environment)

-- | Make an assertion, failing with an error message
guardWith :: MonadError e m => e -> Bool -> m ()

-- | Generate new type class dictionary name
freshDictionaryName :: Check Int

-- | Lift a computation in the <tt>Check</tt> monad into the substitution
--   monad.
liftCheck :: Check a -> UnifyT t Check a

-- | Run a computation in the substitution monad, generating a return value
--   and the final substitution.
liftUnify :: Partial t => UnifyT t Check a -> Check (a, Substitution t)

-- | Run a computation in the substitution monad, generating a return
--   value, the final substitution and updating warnings values.
liftUnifyWarnings :: Partial t => (Substitution t -> ErrorMessage -> ErrorMessage) -> UnifyT t Check a -> Check (a, Substitution t)
instance Functor Check
instance Monad Check
instance Applicative Check
instance MonadState CheckState Check
instance MonadError MultipleErrors Check
instance MonadWriter MultipleErrors Check


-- | This module implements the kind checker
module Language.PureScript.TypeChecker.Kinds

-- | Infer the kind of a single type
kindOf :: ModuleName -> Type -> Check Kind

-- | Infer the kind of a single type, returning the kinds of any scoped
--   type variables
kindOfWithScopedVars :: Type -> Check (Kind, [(String, Kind)])

-- | Infer the kind of a type constructor with a collection of arguments
--   and a collection of associated data constructors
kindsOf :: Bool -> ModuleName -> ProperName -> [(String, Maybe Kind)] -> [Type] -> Check Kind

-- | Simultaneously infer the kinds of several mutually recursive type
--   constructors
kindsOfAll :: ModuleName -> [(ProperName, [(String, Maybe Kind)], Type)] -> [(ProperName, [(String, Maybe Kind)], [Type])] -> Check ([Kind], [Kind])
instance Unifiable Check Kind
instance Partial Kind


-- | Functions for replacing fully applied type synonyms with the
--   <tt>SaturatedTypeSynonym</tt> data constructor
module Language.PureScript.TypeChecker.Synonyms

-- | Replace all type synonyms with the <tt>SaturatedTypeSynonym</tt> data
--   constructor
saturateAllTypeSynonyms :: Map (Qualified ProperName) Int -> Type -> Either ErrorMessage Type

-- | "Desaturate" <tt>SaturatedTypeSynonym</tt>s
desaturateAllTypeSynonyms :: Type -> Type
replaceAllTypeSynonyms :: (e ~ MultipleErrors, Functor m, Monad m, MonadState CheckState m, MonadError e m) => Type -> m Type
expandAllTypeSynonyms :: (e ~ MultipleErrors, Functor m, Applicative m, Monad m, MonadState CheckState m, MonadError e m) => Type -> m Type
expandTypeSynonym :: (e ~ MultipleErrors, Functor m, Monad m, MonadState CheckState m, MonadError e m) => Qualified ProperName -> [Type] -> m Type

-- | Replace a type synonym and its arguments with the aliased type
expandTypeSynonym' :: Environment -> Qualified ProperName -> [Type] -> Either ErrorMessage Type


-- | This module implements the desugaring pass which creates binding
--   groups from sets of mutually-recursive value declarations and
--   mutually-recursive type declarations.
module Language.PureScript.Sugar.BindingGroups
createBindingGroups :: (Functor m, Applicative m, MonadError MultipleErrors m) => ModuleName -> [Declaration] -> m [Declaration]

-- | Replace all sets of mutually-recursive declarations in a module with
--   binding groups
createBindingGroupsModule :: (Functor m, Applicative m, MonadError MultipleErrors m) => [Module] -> m [Module]

-- | Collapse all binding groups to individual declarations
collapseBindingGroups :: [Declaration] -> [Declaration]

-- | Collapse all binding groups in a module to individual declarations
collapseBindingGroupsModule :: [Module] -> [Module]


module Language.PureScript.Sugar.Names

-- | Replaces all local names with qualified names within a set of modules.
desugarImports :: (Applicative m, MonadError MultipleErrors m) => [Module] -> m [Module]
instance Show Exports
instance Show ImportEnvironment


-- | This module implements the desugaring pass which replaces top-level
--   type declarations with type annotations on the corresponding
--   expression.
module Language.PureScript.Sugar.TypeDeclarations

-- | Replace all top level type declarations with type annotations
desugarTypeDeclarations :: (Functor m, Applicative m, MonadError MultipleErrors m) => [Declaration] -> m [Declaration]

-- | Replace all top level type declarations in a module with type
--   annotations
desugarTypeDeclarationsModule :: (Functor m, Applicative m, MonadError MultipleErrors m) => [Module] -> m [Module]


-- | Functions relating to type checking for rows
module Language.PureScript.TypeChecker.Rows

-- | Ensure rows do not contain duplicate labels
checkDuplicateLabels :: Expr -> Check ()


-- | Functions relating to skolemization used during typechecking
module Language.PureScript.TypeChecker.Skolems

-- | Generate a new skolem constant
newSkolemConstant :: UnifyT Type Check Int

-- | Introduce skolem scope at every occurence of a ForAll
introduceSkolemScope :: Type -> UnifyT Type Check Type

-- | Generate a new skolem scope
newSkolemScope :: UnifyT Type Check SkolemScope

-- | Skolemize a type variable by replacing its instances with fresh skolem
--   constants
skolemize :: String -> Int -> SkolemScope -> Type -> Type

-- | This function has one purpose - to skolemize type variables appearing
--   in a SuperClassDictionary placeholder. These type variables are
--   somewhat unique since they are the only example of scoped type
--   variables.
skolemizeTypesInValue :: String -> Int -> SkolemScope -> Expr -> Expr

-- | Ensure skolem variables do not escape their scope
skolemEscapeCheck :: Expr -> Check ()


-- | Functions and instances relating to unification
module Language.PureScript.TypeChecker.Unify

-- | Unify two types, updating the current substitution
unifyTypes :: Type -> Type -> UnifyT Type Check ()

-- | Unify two rows, updating the current substitution
--   
--   Common labels are first identified, and unified. Remaining labels and
--   types are unified with a trailing row unification variable, if
--   appropriate, otherwise leftover labels result in a unification error.
unifyRows :: Type -> Type -> UnifyT Type Check ()

-- | Check that two types unify
unifiesWith :: Environment -> Type -> Type -> Bool

-- | Replace a single type variable with a new unification variable
replaceVarWithUnknown :: String -> Type -> UnifyT Type Check Type

-- | Replace type wildcards with unknowns
replaceTypeWildcards :: Type -> UnifyT t Check Type

-- | Replace outermost unsolved unification variables with named type
--   variables
varIfUnknown :: Type -> Type
instance Unifiable Check Type
instance Partial Type


-- | Type class entailment
module Language.PureScript.TypeChecker.Entailment

-- | Check that the current set of type class dictionaries entail the
--   specified type class goal, and, if so, return a type class dictionary
--   reference.
entails :: Environment -> ModuleName -> Map (Maybe ModuleName) (Map (Qualified ProperName) (Map (Qualified Ident) TypeClassDictionaryInScope)) -> Constraint -> Bool -> Check Expr
instance Show Work
instance Eq Work
instance Ord Work
instance Num Work


-- | Subsumption checking
module Language.PureScript.TypeChecker.Subsumption

-- | Check whether one type subsumes another, rethrowing errors to provide
--   a better error message
subsumes :: Maybe Expr -> Type -> Type -> UnifyT Type Check (Maybe Expr)


-- | This module implements the type checker
module Language.PureScript.TypeChecker.Types

-- | Infer the types of multiple mutually-recursive values, and return
--   elaborated values including type class dictionaries and type
--   annotations.
typesOf :: Maybe ModuleName -> ModuleName -> [(Ident, Expr)] -> Check [(Ident, (Expr, Type))]


-- | The top-level type checker, which checks all declarations in a module.
module Language.PureScript.TypeChecker

-- | Type check an entire module and ensure all types and classes defined
--   within the module that are required by exported members are also
--   exported.
typeCheckModule :: Maybe ModuleName -> Module -> Check Module


-- | Fresh variable supply
module Control.Monad.Supply
newtype SupplyT m a
SupplyT :: StateT Integer m a -> SupplyT m a
unSupplyT :: SupplyT m a -> StateT Integer m a
runSupplyT :: Integer -> SupplyT m a -> m (a, Integer)
evalSupplyT :: Functor m => Integer -> SupplyT m a -> m a
type Supply = SupplyT Identity
runSupply :: Integer -> Supply a -> (a, Integer)
evalSupply :: Integer -> Supply a -> a
instance Functor m => Functor (SupplyT m)
instance (Monad m, Functor m) => Applicative (SupplyT m)
instance Monad m => Monad (SupplyT m)
instance MonadTrans SupplyT
instance MonadError e m => MonadError e (SupplyT m)
instance MonadWriter w m => MonadWriter w (SupplyT m)
instance MonadReader r m => MonadReader r (SupplyT m)


-- | A class for monads supporting a supply of fresh names
module Control.Monad.Supply.Class
class Monad m => MonadSupply m
fresh :: MonadSupply m => m Integer
freshName :: MonadSupply m => m String
instance MonadSupply m => MonadSupply (StateT s m)
instance Monad m => MonadSupply (SupplyT m)


-- | This module provides basic inlining capabilities
module Language.PureScript.CodeGen.JS.Optimizer.Inliner
inlineVariables :: JS -> JS
inlineValues :: JS -> JS
inlineOperator :: (String, String) -> (JS -> JS -> JS) -> JS -> JS
inlineCommonOperators :: JS -> JS
inlineArrComposition :: (Applicative m, MonadSupply m) => JS -> m JS
etaConvert :: JS -> JS
unThunk :: JS -> JS
evaluateIifes :: JS -> JS


-- | This module optimizes code in the simplified-Javascript intermediate
--   representation.
--   
--   The following optimizations are supported:
--   
--   <ul>
--   <li>Collapsing nested blocks</li>
--   <li>Tail call elimination</li>
--   <li>Inlining of (&gt;&gt;=) and ret for the Eff monad</li>
--   <li>Removal of unnecessary thunks</li>
--   <li>Eta conversion</li>
--   <li>Inlining variables</li>
--   <li>Inline Prelude.($), Prelude.(#), Prelude.(++), Prelude.(!!)</li>
--   <li>Inlining primitive Javascript operators</li>
--   </ul>
module Language.PureScript.CodeGen.JS.Optimizer

-- | Apply a series of optimizer passes to simplified Javascript code
optimize :: (Monad m, MonadReader Options m, Applicative m, MonadSupply m) => JS -> m JS


-- | This module implements the desugaring pass which replaces top-level
--   binders with case expressions.
module Language.PureScript.Sugar.CaseDeclarations

-- | Replace all top-level binders with case expressions.
desugarCases :: (Functor m, Applicative m, MonadSupply m, MonadError MultipleErrors m) => [Declaration] -> m [Declaration]

-- | Replace all top-level binders in a module with case expressions.
desugarCasesModule :: (Functor m, Applicative m, MonadSupply m, MonadError MultipleErrors m) => [Module] -> m [Module]


-- | This module implements the desugaring pass which creates type synonyms
--   for type class dictionaries and dictionary expressions for type class
--   instances.
module Language.PureScript.Sugar.TypeClasses

-- | Add type synonym declarations for type class dictionary types, and
--   value declarations for type class instance dictionary expressions.
desugarTypeClasses :: (Functor m, Applicative m, MonadSupply m, MonadError MultipleErrors m) => [Module] -> m [Module]
typeClassMemberName :: Declaration -> String
superClassDictionaryNames :: [Constraint] -> [String]


-- | The AST -&gt; CoreFn desugaring step
module Language.PureScript.CoreFn.Desugar

-- | Desugars a module from AST to CoreFn representation.
moduleToCoreFn :: Environment -> Module -> Module Ann


-- | The core functional representation
module Language.PureScript.CoreFn


-- | Renaming pass that prevents shadowing of local identifiers.
module Language.PureScript.Renamer

-- | Renames within each declaration in a module.
renameInModules :: [Module Ann] -> [Module Ann]


-- | This module generates code in the simplified Javascript intermediate
--   representation from Purescript code
module Language.PureScript.CodeGen.JS

-- | Generate code in the simplified Javascript intermediate representation
--   for all declarations in a module.
moduleToJs :: (Applicative m, Monad m, MonadReader Options m, MonadSupply m) => Module Ann -> Maybe JS -> m [JS]
mainCall :: ModuleName -> String -> JS


-- | A collection of modules related to code generation:
--   
--   <ul>
--   <li><i><tt>Language.PureScript.CodeGen.JS</tt></i> Code generator for
--   Javascript</li>
--   <li><i><tt>Language.PureScript.CodeGen.Externs</tt></i> Code generator
--   for extern (foreign import) files</li>
--   <li><i><tt>Language.PureScript.CodeGen.Optimize</tt></i> Optimization
--   passes for generated Javascript</li>
--   </ul>
module Language.PureScript.CodeGen


-- | This module implements the desugaring pass which replaces do-notation
--   statements with appropriate calls to bind from the Prelude.Monad type
--   class.
module Language.PureScript.Sugar.DoNotation

-- | Replace all <tt>DoNotationBind</tt> and <tt>DoNotationValue</tt>
--   constructors with applications of the Prelude.bind function, and all
--   <tt>DoNotationLet</tt> constructors with let expressions.
desugarDoModule :: (Applicative m, MonadSupply m, MonadError MultipleErrors m) => Module -> m Module


module Language.PureScript.Sugar.ObjectWildcards
desugarObjectConstructors :: (Applicative m, MonadSupply m, MonadError MultipleErrors m) => Module -> m Module


-- | This module implements the desugaring pass which reapplies binary
--   operators based on their fixity data and removes explicit parentheses.
--   
--   The value parser ignores fixity data when parsing binary operator
--   applications, so it is necessary to reorder them here.
module Language.PureScript.Sugar.Operators

-- | Remove explicit parentheses and reorder binary operator applications
rebracket :: (Applicative m, MonadError MultipleErrors m) => [Module] -> m [Module]
removeSignedLiterals :: Module -> Module
desugarOperatorSections :: (Applicative m, MonadSupply m, MonadError MultipleErrors m) => Module -> m Module


-- | Desugaring passes
module Language.PureScript.Sugar

-- | The desugaring pipeline proceeds as follows:
--   
--   <ul>
--   <li>Remove signed literals in favour of <a>negate</a>
--   applications</li>
--   <li>Desugar object literals with wildcards into lambdas</li>
--   <li>Desugar operator sections</li>
--   <li>Desugar do-notation using the <tt>Prelude.Monad</tt> type
--   class</li>
--   <li>Desugar top-level case declarations into explicit case
--   expressions</li>
--   <li>Desugar type declarations into value declarations with explicit
--   type annotations</li>
--   <li>Qualify any unqualified names and types</li>
--   <li>Rebracket user-defined binary operators</li>
--   <li>Introduce type synonyms for type class dictionaries</li>
--   <li>Group mutually recursive value and data declarations into binding
--   groups.</li>
--   </ul>
desugar :: (Applicative m, MonadSupply m, MonadError MultipleErrors m) => [Module] -> m [Module]


-- | The main compiler module
module Language.PureScript

-- | Determines when to rebuild a module
data RebuildPolicy

-- | Never rebuild this module
RebuildNever :: RebuildPolicy

-- | Always rebuild this module
RebuildAlways :: RebuildPolicy

-- | Actions that require implementations when running in "make" mode.
data MakeActions m
MakeActions :: (ModuleName -> m (Either RebuildPolicy (Maybe UTCTime))) -> (ModuleName -> m (Maybe UTCTime)) -> (ModuleName -> m (FilePath, String)) -> (Module Ann -> Environment -> SupplyVar -> Externs -> m ()) -> (String -> m ()) -> MakeActions m

-- | Get the timestamp for the input file(s) for a module. If there are
--   multiple files (.purs and foreign files, for example) the timestamp
--   should be for the most recently modified file.
getInputTimestamp :: MakeActions m -> ModuleName -> m (Either RebuildPolicy (Maybe UTCTime))

-- | Get the timestamp for the output files for a module. This should be
--   the timestamp for the oldest modified file, or Nothing if any of the
--   required output files are missing.
getOutputTimestamp :: MakeActions m -> ModuleName -> m (Maybe UTCTime)

-- | Read the externs file for a module as a string and also return the
--   actual path for the file.
readExterns :: MakeActions m -> ModuleName -> m (FilePath, String)

-- | Run the code generator for the module and write any required output
--   files.
codegen :: MakeActions m -> Module Ann -> Environment -> SupplyVar -> Externs -> m ()

-- | Respond to a progress update.
progress :: MakeActions m -> String -> m ()

-- | A value to be used in the Supply monad.
type SupplyVar = Integer

-- | Generated code for an externs file.
type Externs = String

-- | Compiles in "make" mode, compiling each module separately to a js
--   files and an externs file
--   
--   If timestamps have not changed, the externs file can be used to
--   provide the module's types without having to typecheck the module
--   again.
make :: (Functor m, Applicative m, Monad m, MonadReader Options m, MonadError MultipleErrors m, MonadWriter MultipleErrors m) => MakeActions m -> [(Either RebuildPolicy FilePath, Module)] -> m Environment
version :: Version
instance Show RebuildPolicy
instance Eq RebuildPolicy
instance Ord RebuildPolicy


-- | Data types and functions for representing a simplified form of
--   PureScript code, intended for use in e.g. HTML documentation.
module Language.PureScript.Docs.RenderedCode.Types

-- | A single element in a rendered code fragment. The intention is to
--   support multiple output formats. For example, plain text, or
--   highlighted HTML.
data RenderedCodeElement
Syntax :: String -> RenderedCodeElement
Ident :: String -> RenderedCodeElement
Ctor :: String -> ContainingModule -> RenderedCodeElement
Kind :: String -> RenderedCodeElement
Keyword :: String -> RenderedCodeElement
Space :: RenderedCodeElement
asRenderedCodeElement :: Parse String RenderedCodeElement

-- | This type is isomorphic to <a>Maybe</a> <a>ModuleName</a>. It makes
--   code a bit easier to read, as the meaning is more explicit.
data ContainingModule
ThisModule :: ContainingModule
OtherModule :: ModuleName -> ContainingModule
asContainingModule :: Parse e ContainingModule

-- | Convert a <a>ContainingModule</a> to a <a>Maybe</a> <a>ModuleName</a>,
--   using the obvious isomorphism.
containingModuleToMaybe :: ContainingModule -> Maybe ModuleName

-- | Convert a <a>Maybe</a> <a>ModuleName</a> to a <a>ContainingModule</a>,
--   using the obvious isomorphism.
maybeToContainingModule :: Maybe ModuleName -> ContainingModule

-- | A version of <tt>fromMaybe</tt> for <a>ContainingModule</a> values.
fromContainingModule :: ModuleName -> ContainingModule -> ModuleName

-- | A type representing a highly simplified version of PureScript code,
--   intended for use in output formats like plain text or HTML.
data RenderedCode
asRenderedCode :: Parse String RenderedCode

-- | This function allows conversion of a <a>RenderedCode</a> value into a
--   value of some other type (for example, plain text, or HTML). The first
--   argument is a function specifying how each individual
--   <a>RenderedCodeElement</a> should be rendered.
outputWith :: Monoid a => (RenderedCodeElement -> a) -> RenderedCode -> a

-- | A <a>RenderedCode</a> fragment representing a space.
sp :: RenderedCode
syntax :: String -> RenderedCode
ident :: String -> RenderedCode
ctor :: String -> ContainingModule -> RenderedCode
kind :: String -> RenderedCode
keyword :: String -> RenderedCode
keywordForall :: RenderedCode
keywordData :: RenderedCode
keywordNewtype :: RenderedCode
keywordType :: RenderedCode
keywordClass :: RenderedCode
keywordInstance :: RenderedCode
keywordWhere :: RenderedCode
instance Show ContainingModule
instance Eq ContainingModule
instance Ord ContainingModule
instance Show RenderedCodeElement
instance Eq RenderedCodeElement
instance Ord RenderedCodeElement
instance Show RenderedCode
instance Eq RenderedCode
instance Ord RenderedCode
instance Monoid RenderedCode
instance ToJSON RenderedCode
instance ToJSON ContainingModule
instance ToJSON RenderedCodeElement


-- | Functions for producing RenderedCode values from PureScript Type
--   values.
module Language.PureScript.Docs.RenderedCode.Render

-- | Render code representing a Type
renderType :: Type -> RenderedCode

-- | Render code representing a Type, as it should appear inside
--   parentheses
renderTypeAtom :: Type -> RenderedCode

-- | Render code representing a Row
renderRow :: Type -> RenderedCode

-- | Render code representing a Kind
renderKind :: Kind -> RenderedCode
data RenderTypeOptions
RenderTypeOptions :: Bool -> RenderTypeOptions
prettyPrintObjects :: RenderTypeOptions -> Bool
defaultRenderTypeOptions :: RenderTypeOptions
renderTypeWithOptions :: RenderTypeOptions -> Type -> RenderedCode


-- | Data types and functions for representing a simplified form of
--   PureScript code, intended for use in e.g. HTML documentation.
module Language.PureScript.Docs.RenderedCode

module Language.PureScript.Docs.Types
data Package a
Package :: PackageMeta -> Version -> String -> [Module] -> [Bookmark] -> [(PackageName, Version)] -> (GithubUser, GithubRepo) -> a -> Package a
pkgMeta :: Package a -> PackageMeta
pkgVersion :: Package a -> Version
pkgVersionTag :: Package a -> String
pkgModules :: Package a -> [Module]
pkgBookmarks :: Package a -> [Bookmark]
pkgResolvedDependencies :: Package a -> [(PackageName, Version)]
pkgGithub :: Package a -> (GithubUser, GithubRepo)
pkgUploader :: Package a -> a
data NotYetKnown
NotYetKnown :: NotYetKnown
type UploadedPackage = Package NotYetKnown
type VerifiedPackage = Package GithubUser
verifyPackage :: GithubUser -> UploadedPackage -> VerifiedPackage
packageName :: Package a -> PackageName
data Module
Module :: String -> Maybe String -> [Declaration] -> Module
modName :: Module -> String
modComments :: Module -> Maybe String
modDeclarations :: Module -> [Declaration]
data Declaration
Declaration :: String -> Maybe String -> Maybe SourceSpan -> [ChildDeclaration] -> Maybe Fixity -> DeclarationInfo -> Declaration
declTitle :: Declaration -> String
declComments :: Declaration -> Maybe String
declSourceSpan :: Declaration -> Maybe SourceSpan
declChildren :: Declaration -> [ChildDeclaration]
declFixity :: Declaration -> Maybe Fixity
declInfo :: Declaration -> DeclarationInfo

-- | A value of this type contains information that is specific to a
--   particular kind of declaration (as opposed to information which exists
--   in all kinds of declarations, which goes into the <a>Declaration</a>
--   type directly).
--   
--   Many of the constructors are very similar to their equivalents in the
--   real PureScript AST, except that they have their name elided, since
--   this is already available via the rdTitle field of <a>Declaration</a>.
data DeclarationInfo

-- | A value declaration, with its type.
ValueDeclaration :: Type -> DeclarationInfo

-- | A data/newtype declaration, with the kind of declaration (data or
--   newtype) and its type arguments. Constructors are represented as child
--   declarations.
DataDeclaration :: DataDeclType -> [(String, Maybe Kind)] -> DeclarationInfo

-- | A data type foreign import, with its kind.
ExternDataDeclaration :: Kind -> DeclarationInfo

-- | A type synonym, with its type arguments and its type.
TypeSynonymDeclaration :: [(String, Maybe Kind)] -> Type -> DeclarationInfo

-- | A type class, with its type arguments and its superclasses. Instances
--   and members are represented as child declarations.
TypeClassDeclaration :: [(String, Maybe Kind)] -> [Constraint] -> DeclarationInfo
declInfoToString :: DeclarationInfo -> String
data ChildDeclaration
ChildDeclaration :: String -> Maybe String -> Maybe SourceSpan -> ChildDeclarationInfo -> ChildDeclaration
cdeclTitle :: ChildDeclaration -> String
cdeclComments :: ChildDeclaration -> Maybe String
cdeclSourceSpan :: ChildDeclaration -> Maybe SourceSpan
cdeclInfo :: ChildDeclaration -> ChildDeclarationInfo
data ChildDeclarationInfo

-- | A type instance declaration, with its dependencies and its type.
ChildInstance :: [Constraint] -> Type -> ChildDeclarationInfo

-- | A data constructor, with its type arguments.
ChildDataConstructor :: [Type] -> ChildDeclarationInfo

-- | A type class member, with its type. Note that the type does not
--   include the type class constraint; this may be added manually if
--   desired. For example, <tt>pure</tt> from <tt>Applicative</tt> would be
--   `forall a. a -&gt; f a`.
ChildTypeClassMember :: Type -> ChildDeclarationInfo
childDeclInfoToString :: ChildDeclarationInfo -> String
newtype GithubUser
GithubUser :: String -> GithubUser
runGithubUser :: GithubUser -> String
newtype GithubRepo
GithubRepo :: String -> GithubRepo
runGithubRepo :: GithubRepo -> String
data PackageError
ErrorInPackageMeta :: BowerError -> PackageError
InvalidVersion :: PackageError
InvalidDeclarationType :: String -> PackageError
InvalidChildDeclarationType :: String -> PackageError
InvalidFixity :: PackageError
InvalidKind :: String -> PackageError
InvalidDataDeclType :: String -> PackageError
type Bookmark = InPackage (ModuleName, String)
data InPackage a
Local :: a -> InPackage a
FromDep :: PackageName -> a -> InPackage a
takeLocal :: InPackage a -> Maybe a
takeLocals :: [InPackage a] -> [a]
ignorePackage :: InPackage a -> a
parseUploadedPackage :: ByteString -> Either (ParseError PackageError) UploadedPackage
parseVerifiedPackage :: ByteString -> Either (ParseError PackageError) VerifiedPackage
asPackage :: (forall e. Parse e a) -> Parse PackageError (Package a)
asUploadedPackage :: Parse PackageError UploadedPackage
asNotYetKnown :: Parse e NotYetKnown
asVerifiedPackage :: Parse PackageError VerifiedPackage
asGithubUser :: Parse e GithubUser
asVersion :: Parse PackageError Version
parseVersion' :: String -> Maybe Version
asModule :: Parse PackageError Module
asDeclaration :: Parse PackageError Declaration
asFixity :: Parse PackageError Fixity
parseAssociativity :: String -> Maybe Associativity
asAssociativity :: Parse PackageError Associativity
asDeclarationInfo :: Parse PackageError DeclarationInfo
asTypeArguments :: Parse PackageError [(String, Maybe Kind)]
asKind :: Parse e Kind
asType :: Parse e Type
asDataDeclType :: Parse PackageError DataDeclType
asChildDeclaration :: Parse PackageError ChildDeclaration
asChildDeclarationInfo :: Parse PackageError ChildDeclarationInfo
asSourcePos :: Parse e SourcePos
asConstraint :: Parse PackageError Constraint
asQualifiedProperName :: Parse e (Qualified ProperName)
asBookmarks :: Parse BowerError [Bookmark]
asBookmark :: Parse BowerError Bookmark
asResolvedDependencies :: Parse PackageError [(PackageName, Version)]
asGithub :: Parse e (GithubUser, GithubRepo)
asSourceSpan :: Parse e SourceSpan

-- | Given a function for turning association list keys into JSON object
--   keys, and a function for turning association list values to JSON
--   string values, turns an association list into a JSON object.
--   
--   For example: <tt>assocListToJSON T.pack T.pack [("a", "b")]</tt> will
--   give <tt>{"a": "b"}</tt>.
assocListToJSON :: (a -> Text) -> (b -> Text) -> [(a, b)] -> Value
instance Show NotYetKnown
instance Eq NotYetKnown
instance Ord NotYetKnown
instance Show DeclarationInfo
instance Eq DeclarationInfo
instance Ord DeclarationInfo
instance Show ChildDeclarationInfo
instance Eq ChildDeclarationInfo
instance Ord ChildDeclarationInfo
instance Show ChildDeclaration
instance Eq ChildDeclaration
instance Ord ChildDeclaration
instance Show Declaration
instance Eq Declaration
instance Ord Declaration
instance Show Module
instance Eq Module
instance Ord Module
instance Show GithubUser
instance Eq GithubUser
instance Ord GithubUser
instance Show GithubRepo
instance Eq GithubRepo
instance Ord GithubRepo
instance Show PackageError
instance Eq PackageError
instance Ord PackageError
instance Show a => Show (InPackage a)
instance Eq a => Eq (InPackage a)
instance Ord a => Ord (InPackage a)
instance Show a => Show (Package a)
instance Eq a => Eq (Package a)
instance Ord a => Ord (Package a)
instance ToJSON a => ToJSON (InPackage a)
instance ToJSON GithubRepo
instance ToJSON GithubUser
instance ToJSON ChildDeclarationInfo
instance ToJSON DeclarationInfo
instance ToJSON ChildDeclaration
instance ToJSON Declaration
instance ToJSON Module
instance ToJSON NotYetKnown
instance ToJSON a => ToJSON (Package a)
instance FromJSON a => FromJSON (Package a)
instance FromJSON GithubUser
instance FromJSON NotYetKnown
instance Functor InPackage


-- | Functions for converting PureScript ASTs into values of the data types
--   from Language.PureScript.Docs.
module Language.PureScript.Docs.Convert

-- | Convert a single Module.
convertModule :: Module -> Module

-- | Go through a PureScript module and extract a list of Bookmarks;
--   references to data types or values, to be used as a kind of index.
--   These are used for generating links in the HTML documentation, for
--   example.
collectBookmarks :: InPackage Module -> [Bookmark]


-- | Functions for creating <a>RenderedCode</a> values from data types in
--   Language.PureScript.Docs.Types.
--   
--   These functions are the ones that are used in markdown/html
--   documentation generation, but the intention is that you are able to
--   supply your own instead if necessary. For example, the Hoogle input
--   file generator substitutes some of these
module Language.PureScript.Docs.Render
renderDeclaration :: Declaration -> RenderedCode
renderDeclarationWithOptions :: RenderTypeOptions -> Declaration -> RenderedCode
renderChildDeclaration :: ChildDeclaration -> RenderedCode
renderChildDeclarationWithOptions :: RenderTypeOptions -> ChildDeclaration -> RenderedCode
renderConstraint :: (Qualified ProperName, [Type]) -> RenderedCode
renderConstraintWithOptions :: RenderTypeOptions -> (Qualified ProperName, [Type]) -> RenderedCode
renderConstraints :: [Constraint] -> Maybe RenderedCode
renderConstraintsWithOptions :: RenderTypeOptions -> [Constraint] -> Maybe RenderedCode
notQualified :: String -> Qualified ProperName
typeApp :: String -> [(String, Maybe Kind)] -> Type
toTypeVar :: (String, Maybe Kind) -> Type

module Language.PureScript.Docs.ParseAndDesugar

-- | Given:
--   
--   <ul>
--   <li>A list of local source files</li>
--   <li>A list of source files from external dependencies, together with
--   their package names</li>
--   <li>A callback, taking a list of bookmarks, and a list of desugared
--   modules</li>
--   </ul>
--   
--   This function does the following:
--   
--   <ul>
--   <li>Parse all of the input and dependency source files</li>
--   <li>Partially desugar all of the resulting modules</li>
--   <li>Collect a list of bookmarks from the whole set of source
--   files</li>
--   <li>Collect a list of desugared modules from just the input source
--   files (not dependencies)</li>
--   <li>Call the callback with the bookmarks and desugared module
--   list.</li>
--   </ul>
parseAndDesugar :: [FilePath] -> [(PackageName, FilePath)] -> ([Bookmark] -> [Module] -> IO a) -> IO (Either ParseDesugarError a)
data ParseDesugarError
ParseError :: MultipleErrors -> ParseDesugarError
SortModulesError :: MultipleErrors -> ParseDesugarError
DesugarError :: MultipleErrors -> ParseDesugarError
instance Show ParseDesugarError


-- | Data types and functions for rendering generated documentation from
--   PureScript code, in a variety of formats.
module Language.PureScript.Docs

module Language.PureScript.Docs.AsMarkdown

-- | Take a list of modules and render them all in order, returning a
--   single Markdown-formatted String.
renderModulesAsMarkdown :: [Module] -> String
instance Show First
instance Eq First
instance Ord First
