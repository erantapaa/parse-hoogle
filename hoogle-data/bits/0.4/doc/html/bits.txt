-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Various bit twiddling and bitwise serialization primitives
--   
@package bits
@version 0.4


-- | Calculate a number of fiddly bit operations using fast de Bruijn
--   multiplication tables.
module Data.Bits.Extras
class (Num t, FiniteBits t) => Ranked t where lsb n = rank n - 1 rank 0 = 0 rank n = lsb n + 1
lsb :: Ranked t => t -> Int
rank :: Ranked t => t -> Int
nlz :: Ranked t => t -> Int
log2 :: Word32 -> Int

-- | Calculate the most significant set bit.
msb :: Ranked t => t -> Int
w8 :: Integral a => a -> Word8
w16 :: Integral a => a -> Word16
w32 :: Integral a => a -> Word32
w64 :: Integral a => a -> Word64
assignBit :: Bits b => b -> Int -> Bool -> b

-- | <a>zeroBits</a> is the value with all bits unset.
--   
--   The following laws ought to hold (for all valid bit indices
--   <tt><i>n</i></tt>):
--   
--   <ul>
--   <li><pre><a>clearBit</a> <a>zeroBits</a> <i>n</i> ==
--   <a>zeroBits</a></pre></li>
--   <li><pre><a>setBit</a> <a>zeroBits</a> <i>n</i> == <a>bit</a>
--   <i>n</i></pre></li>
--   <li><pre><a>testBit</a> <a>zeroBits</a> <i>n</i> == False</pre></li>
--   <li><pre><a>popCount</a> <a>zeroBits</a> == 0</pre></li>
--   </ul>
--   
--   This method uses <tt><a>clearBit</a> (<a>bit</a> 0) 0</tt> as its
--   default implementation (which ought to be equivalent to
--   <a>zeroBits</a> for types which possess a 0th bit).
--   
--   <i>Since: 4.7.0.0</i>
zeroBits :: Bits a => a
oneBits :: Bits b => b

-- | Shift Right Logical (i.e., without sign extension)
--   
--   <i>NB:</i> When used on negative <a>Integer</a>s, hilarity may ensue.
srl :: Bits b => b -> Int -> b
instance Ranked Int8
instance Ranked Int16
instance Ranked Int32
instance Ranked Int64
instance Ranked Word8
instance Ranked Word16
instance Ranked Word32
instance Ranked Word64


module Data.Bits.Coding
newtype Coding m a
Coding :: (forall r. (a -> Int -> Word8 -> m r) -> Int -> Word8 -> m r) -> Coding m a
runCoding :: Coding m a -> forall r. (a -> Int -> Word8 -> m r) -> Int -> Word8 -> m r

-- | <tt>Get</tt> something from byte-aligned storage, starting on the next
--   byte and discarding any left over bits in the buffer.
--   
--   <i>NB:</i> Using any operation from <a>MonadGet</a> other than
--   checking <a>remaining</a> or <a>isEmpty</a> will implicitly perform
--   this operation.
getAligned :: MonadGet m => m a -> Coding m a

-- | <tt>Get</tt> a single bit, consuming an entire <tt>byte</tt> if the
--   bit buffer is empty
getBit :: MonadGet m => Coding m Bool
getBits :: (MonadGet m, Bits b) => Int -> Int -> b -> Coding m b
getBitsFrom :: (MonadGet m, Bits b) => Int -> b -> Coding m b

-- | Emit any remaining contents from the bit buffer.
--   
--   Any use of the combinators from <a>MonadPut</a> (including
--   <a>flush</a>) will cause this to happen.
putAligned :: MonadPut m => m a -> Coding m a

-- | <tt>Put</tt> all the bits without a <a>flush</a>
putUnaligned :: (MonadPut m, FiniteBits b) => b -> Coding m ()

-- | <tt>Put</tt> a single bit, emitting an entire <tt>byte</tt> if the bit
--   buffer is full
putBit :: MonadPut m => Bool -> Coding m ()

-- | <tt>Put</tt> a (closed) range of bits
putBits :: (MonadPut m, Bits b) => Int -> Int -> b -> Coding m ()

-- | <pre>
--   putBitsFrom from b = putBits from 0 b
--   </pre>
putBitsFrom :: (MonadPut m, Bits b) => Int -> b -> Coding m ()
instance MonadPut m => MonadPut (Coding m)
instance MonadGet m => MonadGet (Coding m)
instance MonadReader e m => MonadReader e (Coding m)
instance MonadState s m => MonadState s (Coding m)
instance MonadTrans Coding
instance MonadPlus m => MonadPlus (Coding m)
instance (Monad m, Alternative m) => Alternative (Coding m)
instance Monad m => Monad (Coding m)
instance Monad m => Applicative (Coding m)
instance Functor (Coding m)


module Data.Bits.Coded

-- | Unaligned codes
class Coded c where encodeMany = traverse_ encode
encode :: (Coded c, MonadPut m) => c -> Coding m ()
encodeMany :: (Coded c, MonadPut m, Foldable t) => t c -> Coding m ()
decode :: (Coded c, MonadGet m) => Coding m c

-- | Unary-coded integers
--   
--   <pre>
--   &gt;&gt;&gt; runPutL . runEncode $ encode (Unary 1) &gt;&gt; flush
--   "\128"
--   
--   &gt;&gt;&gt; runPutL . runEncode $ encode (Unary 7) &gt;&gt; flush
--   "\254"
--   </pre>
newtype Unary n
Unary :: n -> Unary n
unUnary :: Unary n -> n

-- | Representation for Elias <a>Gamma</a> and <a>Delta</a> codes. A
--   positive integer <tt>n</tt> is encoded by encoding the position of its
--   most significant bit, and then the binary representation of the rest
--   of the number.
newtype Elias c n
Elias :: n -> Elias c n
unElias :: Elias c n -> n

-- | Elias Gamma codes the position of the most significant in
--   <a>Unary</a>.
type Gamma c = Elias (Unary c)

-- | Elias Delta codes the position of the most significant bit in Elias
--   <a>Gamma</a>.
type Delta c n = Elias (Gamma c n) n
runEncode :: MonadPut m => Coding m () -> m ()
runDecode :: MonadGet m => Coding m a -> m a
instance Eq n => Eq (Unary n)
instance Ord n => Ord (Unary n)
instance Read n => Read (Unary n)
instance Show n => Show (Unary n)
instance Num n => Num (Unary n)
instance Integral n => Integral (Unary n)
instance Real n => Real (Unary n)
instance Enum n => Enum (Unary n)
instance Eq n => Eq (Elias c n)
instance Ord n => Ord (Elias c n)
instance Read n => Read (Elias c n)
instance Show n => Show (Elias c n)
instance Num n => Num (Elias c n)
instance Real n => Real (Elias c n)
instance Integral n => Integral (Elias c n)
instance Enum n => Enum (Elias c n)
instance (Coded c, Integral c, Ranked n) => Coded (Elias c n)
instance Integral n => Coded (Unary n)
