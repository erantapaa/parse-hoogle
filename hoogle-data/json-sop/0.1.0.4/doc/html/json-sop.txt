-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generics JSON (de)serialization using generics-sop
--   
@package json-sop
@version 0.1.0.4

module Generics.SOP.JSON
type JsonFieldName = String
type JsonTagName = String

-- | JSON encoder/decoder configuration
data JsonOptions
JsonOptions :: (DatatypeName -> FieldName -> JsonFieldName) -> (ConstructorName -> JsonTagName) -> JsonOptions

-- | Construct the name for JSON object fields (not for the tags that are
--   used for sum-types, however)
--   
--   The default just uses the name of the corresponding Haskell
--   constructor
jsonFieldName :: JsonOptions -> DatatypeName -> FieldName -> JsonFieldName

-- | Construct the name for a tag for sum-types.
--   
--   The default just uses the name of the Haskell constructor.
jsonTagName :: JsonOptions -> ConstructorName -> JsonTagName
defaultJsonOptions :: JsonOptions

-- | Constructor tag
--   
--   For a datatype with a single constructor we do not need to tag values
--   with their constructor; but for a datatype with multiple constructors
--   we do.
data Tag
NoTag :: Tag
Tag :: JsonTagName -> Tag
data JsonInfo :: [*] -> *
JsonZero :: ConstructorName -> JsonInfo []
JsonOne :: Tag -> JsonInfo '[a]
JsonMultiple :: Tag -> JsonInfo xs
JsonRecord :: Tag -> NP (K String) xs -> JsonInfo xs
jsonInfo :: (HasDatatypeInfo a, SingI (Code a)) => Proxy a -> JsonOptions -> NP JsonInfo (Code a)
gtoJSON :: (Generic a, HasDatatypeInfo a, All2 ToJSON (Code a)) => JsonOptions -> a -> Value
gparseJSON :: (Generic a, HasDatatypeInfo a, All2 FromJSON (Code a)) => JsonOptions -> Value -> Parser a

-- | For some values we can support "updating" the value with a "partial"
--   JSON value; record types are the prime example (and the only one
--   supported by the generic function). For non-record types we typically
--   can only replace the value with a "complete" JSON value; in this case,
--   we simply ignore the old value (see <a>replaceWithJSON</a>). Typical
--   class instances will look like
--   
--   <pre>
--   instance UpdateFromJSON SomeRecordType where
--      updateFromJSON = gupdateFromJSON &lt;jsonOptions&gt;
--   </pre>
--   
--   or
--   
--   <pre>
--   instance UpdateFromJSON SomeNonRecordType where
--      updateFromJSON = replaceWithJSON
--   </pre>
--   
--   NOTE: The generic function uses one-level lenses for the object
--   fields. We could generalize this to arbitrary paths, but then the type
--   would change to
--   
--   <pre>
--   updateFromJSON :: Value -&gt; Parser (a -&gt; UpdateM a)
--   </pre>
--   
--   I.e., updating a value from JSON would, in general, involve a database
--   write.
class UpdateFromJSON a
updateFromJSON :: UpdateFromJSON a => Value -> Parser (a -> a)

-- | Construct a function that updates a value of some record type, given a
--   JSON object with new values for some (or none, or all) of the fields
gupdateFromJSON :: (Generic a, HasDatatypeInfo a, All UpdateFromJSON xs, Code a ~ '[xs]) => JsonOptions -> Value -> Parser (a -> a)

-- | For types that we can only replace "whole", rather than update field
--   by field
replaceWithJSON :: FromJSON a => Value -> Parser (a -> a)

-- | Conversely, for types that we can only parse if we have a starting
--   point
parseWith :: UpdateFromJSON a => a -> Value -> Parser a

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where toJSON (Coord x y) = <a>object</a> ["x"
--   <tt>.=</tt> x, "y" <tt>.=</tt> y] @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>toJSON</tt>
--   function that accepts any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (GHC 7.2 and newer),
--   <tt>toJSON</tt> will have a default generic implementation.</li>
--   </ul>
--   
--   To use the latter option, simply add a <tt>deriving
--   <a>Generic</a></tt> clause to your datatype and declare a
--   <tt>ToJSON</tt> instance for your datatype without giving a definition
--   for <tt>toJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic encoding using
--   <a>genericToJSON</a> applied to your encoding/decoding <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON = <a>genericToJSON</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a
toJSON :: ToJSON a => a -> Value

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where parseJSON (<a>Object</a> v) = Coord
--   <tt>&lt;$&gt;</tt> v <tt>.:</tt> "x" <tt>&lt;*&gt;</tt> v <tt>.:</tt>
--   "y"
--   
--   -- A non-<a>Object</a> value is of the wrong type, so use
--   <tt>mzero</tt> to fail. parseJSON _ = <tt>mzero</tt> @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
instance [overlap ok] Typeable JsonOptions
instance [overlap ok] Typeable Tag
instance [overlap ok] Typeable JsonInfo
instance [overlap ok] Typeable UpdateFromJSON
instance [overlap ok] UpdateFromJSON String
instance [overlap ok] UpdateFromJSON Text
instance [overlap ok] UpdateFromJSON Bool
instance [overlap ok] UpdateFromJSON Rational
instance [overlap ok] UpdateFromJSON Double
instance [overlap ok] UpdateFromJSON Int
instance [overlap ok] FromJSON a => UpdateFromJSON (Maybe a)
instance [overlap ok] FromJSON a => UpdateFromJSON [a]

module Generics.SOP.JSON.Model
class JsonModel (a :: *)
jsonModel :: JsonModel a => Tagged a Value

-- | Generic computation of the JSON model
--   
--   Do NOT use for recursive types, you will get an infinite model.
gjsonModel :: (HasDatatypeInfo a, All2 JsonModel (Code a), SingI (Code a)) => JsonOptions -> Tagged a Value

-- | A <tt><a>Tagged</a> s b</tt> value is a value <tt>b</tt> with an
--   attached phantom type <tt>s</tt>. This can be used in place of the
--   more traditional but less safe idiom of passing in an undefined value
--   with the type, because unlike an <tt>(s -&gt; b)</tt>, a
--   <tt><a>Tagged</a> s b</tt> can't try to use the argument <tt>s</tt> as
--   a real value.
--   
--   Moreover, you don't have to rely on the compiler to inline away the
--   extra argument, because the newtype is "free"
newtype Tagged (s :: k) b :: k -> * -> *
Tagged :: b -> Tagged b
unTagged :: Tagged b -> b

-- | Alias for <a>unTagged</a>
untag :: Tagged k s b -> b
instance [overlap ok] Typeable JsonModel
instance [overlap ok] JsonModel a => JsonModel (Maybe a)
instance [overlap ok] JsonModel a => JsonModel [a]
instance [overlap ok] JsonModel Bool
instance [overlap ok] JsonModel Rational
instance [overlap ok] JsonModel Double
instance [overlap ok] JsonModel Int
instance [overlap ok] JsonModel String
instance [overlap ok] JsonModel Text
instance [overlap ok] JsonModel Text
instance [overlap ok] JsonModel UTCTime
