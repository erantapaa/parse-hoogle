-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell compiler that produce binary through C language
--   
--   Ajhc is a fork of jhc. The jhc is a haskell compiler which aims to
--   produce the most efficient programs possible via whole program
--   analysis and other optimizations.
--   
--   The jhc is very minimalist in that it does not have a precompiled run
--   time system, but rather generates what is needed as part of the
--   compilation process. However, back ends do have specific run-time
--   representations of data, which can be affected by things like the
--   choice of garbage collector.
--   
--   Perhaps you can get internal overview with following compile flow
--   image:
--   
@package ajhc
@version 0.8.0.8

module Util.Util

module Util.UnionFind
data Element w a
type T = Element
find :: MonadIO m => Element w a -> m (Element w a)
fromElement :: Element w a -> a
getW :: MonadIO m => Element w a -> m w
new :: MonadIO m => w -> a -> m (Element w a)
new_ :: MonadIO m => a -> m (Element () a)
putW :: MonadIO m => Element w a -> w -> m ()
union :: MonadIO m => (w -> w -> w) -> Element w a -> Element w a -> m ()
union_ :: MonadIO m => Element () a -> Element () a -> m ()
updateW :: MonadIO m => (w -> w) -> Element w a -> m ()
instance [overlap ok] Show a => Show (Element w a)
instance [overlap ok] Ord (Element w a)
instance [overlap ok] Eq (Element w a)

module Util.TrueSet
data TrueSet a
fromList :: Ord a => [a] -> TrueSet a
member :: Ord a => a -> TrueSet a -> Bool
empty :: TrueSet a
full :: TrueSet a
singleton :: a -> TrueSet a
insert :: Ord a => a -> TrueSet a -> TrueSet a
delete :: Ord a => a -> TrueSet a -> TrueSet a
unions :: Ord a => [TrueSet a] -> TrueSet a
union :: Ord a => TrueSet a -> TrueSet a -> TrueSet a
intersection :: Ord a => TrueSet a -> TrueSet a -> TrueSet a
intersects :: Ord a => [TrueSet a] -> TrueSet a
difference :: Ord a => TrueSet a -> TrueSet a -> TrueSet a
(\\) :: Ord a => TrueSet a -> TrueSet a -> TrueSet a

module Util.SHA1
sha1String :: String -> Hash
sha1file :: FilePath -> IO Hash
sha1Bytes :: [Word8] -> Hash
hashToBytes :: Hash -> [Word8]
sha1Handle :: Handle -> IO Hash
data ABCDE
ABCDE :: !Word32 -> !Word32 -> !Word32 -> !Word32 -> !Word32 -> ABCDE
type Hash = ABCDE
emptyHash :: ABCDE
instance [overlap ok] Eq ABCDE
instance [overlap ok] Ord ABCDE
instance [overlap ok] Show ABCDE

module Util.Histogram
data Histogram a
singleton :: a -> Histogram a
insert :: Ord a => a -> Histogram a -> Histogram a
find :: Ord a => a -> Histogram a -> Int
toList :: Histogram a -> [(a, Int)]
satisfy :: (Int -> Bool) -> Histogram a -> [a]
satisfyKey :: (Int -> Bool) -> Histogram a -> [(a, Int)]
filter :: Ord a => (a -> Int -> Bool) -> Histogram a -> Histogram a
keys :: Histogram a -> [a]
elems :: Histogram a -> [Int]
unions :: Ord a => [Histogram a] -> Histogram a
union :: Ord a => Histogram a -> Histogram a -> Histogram a
fromList :: Ord a => [a] -> Histogram a
map :: Ord b => (a -> b) -> Histogram a -> Histogram b
mapM :: (Monad m, Ord b) => (a -> m b) -> Histogram a -> m (Histogram b)
mapM_ :: Monad m => (a -> m b) -> Histogram a -> m ()
instance [overlap ok] Typeable1 Histogram
instance [overlap ok] Show a => Show (Histogram a)
instance [overlap ok] Ord a => Monoid (Histogram a)

module Util.IntBag

-- | <i>O(n+m)</i>. See <tt>difference</tt>. (\) :: IntBag -&gt; IntBag
--   -&gt; IntBag m1 \ m2 = difference m1 m2
--   
--   A map of integers to values <tt>a</tt>.
data IntBag
type Key = Int

-- | <i>O(min(n,W))</i>. Find the value at a key. Calls <a>error</a> when
--   the element can not be found.
(!) :: IntBag -> Key -> Int

-- | <i>O(1)</i>. Is the map empty?
null :: IntBag -> Bool

-- | <i>O(n)</i>. Number of elements in the map.
size :: IntBag -> Int

-- | <i>O(min(n,W))</i>. The expression <tt>(<tt>findWithDefault</tt> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not an element of the map. findWithDefault :: Int
--   -&gt; Key -&gt; IntBag -&gt; Int findWithDefault def k m = case lookup
--   k m of Nothing -&gt; def Just x -&gt; x
--   
--   <i>O(1)</i>. The empty map.
empty :: IntBag

-- | <i>O(1)</i>. A map of one element.
singleton :: Key -> IntBag
msingleton :: Key -> Int -> IntBag

-- | <i>O(min(n,W))</i>. Insert a new key/value pair in the map. If the key
--   is already present in the map, the associated value is added to the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><tt>insertWith</tt> <a>const</a></tt>.
insert :: Key -> Int -> IntBag -> IntBag

-- | <i>O(min(n,W))</i>. Delete a key and its value from the map. When the
--   key is not a member of the map, the original map is returned.
delete :: Key -> Int -> IntBag -> IntBag

-- | The union of a list of maps, with a combining operation unionsWith ::
--   (Int-&gt;Int-&gt;Int) -&gt; [IntBag] -&gt; IntBag unionsWith f ts =
--   foldlStrict (unionWith f) empty ts
--   
--   <i>O(n+m)</i>. The (left-biased) union of two maps. It prefers the
--   first map when duplicate keys are encountered, i.e. (<tt><a>union</a>
--   == <tt>unionWith</tt> <a>const</a></tt>).
union :: IntBag -> IntBag -> IntBag

-- | <i>O(n+m)</i>. The union with a combining function. unionWith :: (a
--   -&gt; a -&gt; a) -&gt; IntMap a -&gt; IntMap a -&gt; IntMap a
--   unionWith f m1 m2 = unionWithKey (k x y -&gt; f x y) m1 m2
--   
--   <i>O(n+m)</i>. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><tt>isProperSubmapOf</tt> =
--   <tt>isProperSubmapOfBy</tt> (==)</tt>). isProperSubmapOf :: Eq a =&gt;
--   IntMap a -&gt; IntMap a -&gt; Bool isProperSubmapOf m1 m2 =
--   isProperSubmapOfBy (==) m1 m2
--   
--   <i>O(n+m)</i>. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><tt>isProperSubmapOfBy</tt> f m1 m2</tt>) returns
--   <a>True</a> when <tt>m1</tt> and <tt>m2</tt> are not equal, all keys
--   in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt> returns
--   <a>True</a> when applied to their respective values. For example, the
--   following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
--   
--   <i>O(n+m)</i>. The expression (<tt><tt>isSubmapOfBy</tt> f m1 m2</tt>)
--   returns <a>True</a> if all keys in <tt>m1</tt> are in <tt>m2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   </pre>
--   
--   <i>O(n)</i>. Fold the values in the map, such that <tt><a>fold</a> f z
--   == <a>foldr</a> f z . <tt>elems</tt></tt>. For example,
--   
--   <pre>
--   elems map = fold (:) [] map
--   </pre>
fold :: (Int -> b -> b) -> b -> IntBag -> b

-- | <i>O(n)</i>. Fold the keys and values in the map, such that
--   <tt><a>foldWithKey</a> f z == <a>foldr</a> (<a>uncurry</a> f) z .
--   <a>toAscList</a></tt>. For example,
--   
--   <pre>
--   keys map = foldWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
foldWithKey :: (Key -> Int -> b -> b) -> b -> IntBag -> b

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys. elems :: IntMap a -&gt; [a] elems m = foldWithKey (k x xs
--   -&gt; x:xs) [] m
--   
--   <i>O(n)</i>. Return all key/value pairs in the map in ascending key
--   order.
assocs :: IntBag -> [(Key, Int)]

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs.
toList :: IntBag -> [(Key, Int)]

-- | <i>O(n*min(n,W))</i>. Create a map from a list of key/value pairs.
fromList :: [(Key, Int)] -> IntBag

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs where the
--   keys are in ascending order.
toAscList :: IntBag -> [(Key, Int)]
instance [overlap ok] Show IntBag
instance [overlap ok] Ord IntBag
instance [overlap ok] Eq IntBag
instance [overlap ok] Monoid IntBag

module Util.ExitCodes
exitCodeUsage :: ExitCode
exitCodeDataError :: ExitCode
exitCodeNoInput :: ExitCode
exitCodeNoUser :: ExitCode
exitCodeNoHost :: ExitCode
exitCodeUnavailable :: ExitCode
exitCodeSoftware :: ExitCode
exitCodeOSError :: ExitCode
exitCodeOSFile :: ExitCode
exitCodeCantCreate :: ExitCode
exitCodeIOErr :: ExitCode
exitCodeTempFailure :: ExitCode
exitCodeProtocol :: ExitCode
exitCodeNoPerm :: ExitCode
exitCodeConfig :: ExitCode

module Support.Cabal
getDataFileNameMaybe :: FilePath -> IO (Maybe FilePath)

module Info.Properties
data Property
PROP_INLINE :: Property
PROP_MULTISPECIALIZE :: Property
PROP_NOINLINE :: Property
PROP_SRCLOC_ANNOTATE :: Property
PROP_SUPERINLINE :: Property
PROP_NOETA :: Property
PROP_CYCLIC :: Property
PROP_EXPORTED :: Property
PROP_INSTANCE :: Property
PROP_JOINPOINT :: Property
PROP_METHOD :: Property
PROP_ONESHOT :: Property
PROP_PLACEHOLDER :: Property
PROP_RULEBINDER :: Property
PROP_SCRUTINIZED :: Property
PROP_SPECIALIZATION :: Property
PROP_SRCLOC_ANNOTATE_FUN :: Property
PROP_SUPERSPECIALIZE :: Property
PROP_UNSHARED :: Property
PROP_WHNF :: Property
PROP_WORKER :: Property
PROP_WRAPPER :: Property
PROP_HASRULE :: Property
readProp :: Monad m => [Char] -> m Property
prop_INLINE :: Property
prop_MULTISPECIALIZE :: Property
prop_NOINLINE :: Property
prop_SRCLOC_ANNOTATE :: Property
prop_SUPERINLINE :: Property
prop_NOETA :: Property
prop_CYCLIC :: Property
prop_EXPORTED :: Property
prop_INSTANCE :: Property
prop_JOINPOINT :: Property
prop_METHOD :: Property
prop_ONESHOT :: Property
prop_PLACEHOLDER :: Property
prop_RULEBINDER :: Property
prop_SCRUTINIZED :: Property
prop_SPECIALIZATION :: Property
prop_SRCLOC_ANNOTATE_FUN :: Property
prop_SUPERSPECIALIZE :: Property
prop_UNSHARED :: Property
prop_WHNF :: Property
prop_WORKER :: Property
prop_WRAPPER :: Property
prop_HASRULE :: Property
instance [overlap ok] Eq Property
instance [overlap ok] Ord Property
instance [overlap ok] Enum Property
instance [overlap ok] Bounded Property
instance [overlap ok] Show Property

module Support.MD5
data Hash
emptyHash :: Hash
md5 :: ByteString -> Hash
md5file :: FilePath -> IO Hash
md5lazy :: ByteString -> Hash
md5lazyIO :: ByteString -> IO Hash
md5show32 :: Hash -> String
md5Bytes :: [Word8] -> Hash
md5String :: String -> Hash
md5Handle :: Handle -> IO Hash
hashToBytes :: Hash -> [Word8]
instance [overlap ok] Eq Hash
instance [overlap ok] Ord Hash
instance [overlap ok] Show Hash
instance [overlap ok] Binary Hash

module Version.Config
shortVersion :: [Char]
version :: [Char]
package :: [Char]
libdir :: [Char]
datadir :: [Char]
host :: [Char]
libraryInstall :: [Char]
confDir :: [Char]
version_major :: Int
version_minor :: Int
version_patch :: Int
revision :: String

module Util.YAML
data Node
Leaf :: String -> Node
List :: [Node] -> Node
Map :: [(String, Node)] -> Node
Null :: Node
class MapKey a
showMapKey :: MapKey a => a -> String
class ToNode a
toNode :: ToNode a => a -> Node
dumpNode :: Node -> String
showYAML :: ToNode a => a -> String
showString' :: [Char] -> [Char] -> [Char]
instance [overlap ok] ToNode ()
instance [overlap ok] ToNode Bool
instance [overlap ok] (ToNode a, ToNode b) => ToNode (Either a b)
instance [overlap ok] ToNode a => ToNode (Maybe a)
instance [overlap ok] ToNode a => ToNode (Set a)
instance [overlap ok] (MapKey k, ToNode b) => ToNode (Map k b)
instance [overlap ok] (MapKey k, ToNode a) => ToNode [(k, a)]
instance [overlap ok] ToNode a => ToNode [a]
instance [overlap ok] ToNode String
instance [overlap ok] ToNode Node
instance [overlap ok] MapKey String

module Support.CFF
data ChunkType
type FileType = ChunkType
type FileOffset = Word
type ChunkLength = Word
chunkType :: String -> ChunkType
isCritical :: ChunkType -> Bool
isPrivate :: ChunkType -> Bool
isSafeToCopy :: ChunkType -> Bool
readCFFHeader :: Handle -> IO ChunkType
readCFFInfo :: Handle -> IO (ChunkType, [(ChunkType, FileOffset, ChunkLength)])
readCFF :: Handle -> IO (ChunkType, [(ChunkType, ByteString)])
bsCFF :: Monad m => ByteString -> m (FileType, [(ChunkType, ByteString)])
lbsCFF :: Monad m => ByteString -> m (FileType, [(ChunkType, ByteString)])
mkCFFfile :: FileType -> [(ChunkType, ByteString)] -> ByteString
readChunk :: Handle -> ChunkType -> ChunkType -> IO ByteString
lazyWriteCFF :: Handle -> ChunkType -> [(ChunkType, ByteString)] -> IO ()
writeCFF :: Handle -> ChunkType -> [(ChunkType, ByteString)] -> IO ()
instance [overlap ok] Eq ChunkType
instance [overlap ok] Ord ChunkType
instance [overlap ok] Read ChunkType
instance [overlap ok] Show ChunkType


-- | Simple graphviz output.
module Util.Graphviz
data Orient
Portrait :: Orient
Landscape :: Orient
graphviz :: Graph g => g a b -> String -> [(String, String)] -> (a -> [(String, String)]) -> (b -> [(String, String)]) -> (Double, Double) -> (Int, Int) -> Orient -> String

-- | Format a graph for graphviz with reasonable defaults: title of "fgl",
--   8.5x11 pages, one page, landscape orientation
graphviz' :: Graph g => g a b -> [(String, String)] -> (a -> [(String, String)]) -> (b -> [(String, String)]) -> String
instance [overlap ok] Eq Orient
instance [overlap ok] Show Orient

module Util.UnionSolve
data C l v
solve :: (Fixable l, Show l, Show v, Ord v) => (String -> IO ()) -> C l v -> IO (Map v v, Map v (Result l v))
class Fixable a where showFixable x | isBottom x = "B" | isTop x = "T" | otherwise = "*" eq x y = lte x y && lte y x isBottom _ = False isTop _ = False
isBottom :: Fixable a => a -> Bool
isTop :: Fixable a => a -> Bool
join :: Fixable a => a -> a -> a
meet :: Fixable a => a -> a -> a
eq :: Fixable a => a -> a -> Bool
lte :: Fixable a => a -> a -> Bool
showFixable :: Fixable a => a -> String
data Topped a
Only :: a -> Topped a
Top :: Topped a
data Result l a
ResultJust :: a -> l -> Result l a
resultRep :: Result l a -> a
resultValue :: Result l a -> l
ResultBounded :: a -> Maybe l -> Maybe l -> [a] -> [a] -> Result l a
resultRep :: Result l a -> a
resultLB :: Result l a -> Maybe l
resultUB :: Result l a -> Maybe l
resultLBV :: Result l a -> [a]
resultUBV :: Result l a -> [a]
cAnnotate :: String -> C l v -> C l v
islte :: (Fixable l, Ord v) => Either v l -> Either v l -> C l v
isgte :: (Fixable l, Ord v) => Either v l -> Either v l -> C l v
equals :: (Fixable l, Ord v) => Either v l -> Either v l -> C l v
(@<=) :: v -> l -> C l v
(@>=) :: v -> l -> C l v
(@=) :: v -> l -> C l v
(@<=@) :: v -> v -> C l v
(@>=@) :: v -> v -> C l v
(@=@) :: v -> v -> C l v
instance [overlap ok] Monoid (C l v)
instance [overlap ok] (Show l, Show a) => Show (R l a)
instance [overlap ok] Eq a => Eq (Topped a)
instance [overlap ok] Ord a => Ord (Topped a)
instance [overlap ok] Show a => Show (Topped a)
instance [overlap ok] Fixable a => Fixable (Topped a)
instance [overlap ok] Fixable a => Fixable (Maybe a)
instance [overlap ok] (Fixable a, Fixable b) => Fixable (a, b)
instance [overlap ok] Fixable Int
instance [overlap ok] Fixable Bool
instance [overlap ok] Ord n => Fixable (Set n)
instance [overlap ok] (Show l, Show a) => Show (Result l a)
instance [overlap ok] (Show e, Show l) => Show (CL l e)
instance [overlap ok] (Show e, Show l) => Show (C l e)
instance [overlap ok] Show Op

module Support.CompatMingw32
createLinkCompat :: FilePath -> FilePath -> IO ()
raiseSigIntCompat :: IO ()
noEscapePath :: String -> String
systemCompat :: String -> IO ExitCode

module RawFiles

-- | Generated from src/data/ViaGhc.hs
viaghc_hs :: ByteString

-- | Generated from src/data/prelude.m4
prelude_m4 :: ByteString

-- | Generated from src/data/targets.ini
targets_ini :: ByteString

-- | Generated from rts/rts/constants.h
constants_h :: ByteString

-- | Generated from rts/rts/stableptr.c
stableptr_c :: ByteString

-- | Generated from rts/rts/stableptr.h
stableptr_h :: ByteString

-- | Generated from rts/sys/queue.h
queue_h :: ByteString

-- | Generated from rts/HsFFI.h
hsffi_h :: ByteString

-- | Generated from rts/sys/wsize.h
wsize_h :: ByteString

-- | Generated from rts/sys/bitarray.h
bitarray_h :: ByteString

-- | Generated from ChangeLog
changelog :: ByteString

-- | Generated from src/data/shortchange.txt
shortchange_txt :: ByteString

-- | Generated from rts/rts/slub.c
slub_c :: ByteString

-- | Generated from rts/rts/gc_jgc.c
gc_jgc_c :: ByteString

-- | Generated from rts/rts/gc_jgc.h
gc_jgc_h :: ByteString

-- | Generated from rts/rts/profile.c
profile_c :: ByteString

-- | Generated from rts/rts/profile.h
profile_h :: ByteString

-- | Generated from rts/rts/cdefs.h
cdefs_h :: ByteString

-- | Generated from rts/rts/rts_support.c
rts_support_c :: ByteString

-- | Generated from rts/rts/rts_support.h
rts_support_h :: ByteString

-- | Generated from rts/rts/gc.h
gc_h :: ByteString

-- | Generated from rts/rts/gc_none.c
gc_none_c :: ByteString

-- | Generated from rts/rts/gc_none.h
gc_none_h :: ByteString

-- | Generated from rts/rts/jhc_rts.c
jhc_rts_c :: ByteString

-- | Generated from rts/rts/jhc_rts.h
jhc_rts_h :: ByteString

-- | Generated from rts/lib/lib_cbits.c
lib_cbits_c :: ByteString

-- | Generated from rts/jhc_rts_header.h
jhc_rts_header_h :: ByteString

-- | Generated from rts/lib/lib_cbits.h
lib_cbits_h :: ByteString

-- | Generated from rts/rts/gc_jgc_internal.h
gc_jgc_internal_h :: ByteString

-- | Generated from rts/rts/conc.c
conc_c :: ByteString

-- | Generated from rts/rts/conc.h
conc_h :: ByteString

module Version.Version
versionContext :: ByteString
versionSimple :: [Char]
versionString :: [Char]

module Util.Perhaps
data Perhaps
No :: Perhaps
Maybe :: Perhaps
Yes :: Perhaps
instance [overlap ok] Typeable Perhaps
instance [overlap ok] Show Perhaps
instance [overlap ok] Read Perhaps
instance [overlap ok] Eq Perhaps
instance [overlap ok] Ord Perhaps
instance [overlap ok] Monoid Perhaps


-- | a simple type that only lets an IO action happen once, caching its
--   result.
module Util.Once
data Once a

-- | create a new Once object
newOnce :: IO (Once a)

-- | execute the action at most once, always returning the same result
runOnce :: Once a -> IO a -> IO a

-- | run first argument once, after which perform the second
altOnce :: Once () -> IO b -> IO b -> IO b

-- | run an IO action at most once for each distinct argument
data OnceMap a b
newOnceMap :: Ord a => IO (OnceMap a b)
runOnceMap :: Ord a => OnceMap a b -> a -> IO b -> IO b
altOnceMap :: Ord a => OnceMap a () -> a -> IO b -> IO b -> IO b
onceMapToList :: OnceMap a b -> IO [(a, b)]
onceMapKeys :: OnceMap a b -> IO [a]
onceMapElems :: OnceMap a b -> IO [b]
instance [overlap ok] Typeable1 Once
instance [overlap ok] Typeable2 OnceMap

module FrontEnd.Unlit

-- | Remove literate comments leaving normal haskell source.
unlit :: String -> String -> String

module FrontEnd.Syn.Options
parseOptions :: String -> [(String, String)]

module FrontEnd.DependAnalysis
getBindGroups :: Ord name => [node] -> (node -> name) -> (node -> [name]) -> [[node]]
debugBindGroups :: Eq name => [[node]] -> (node -> String) -> (node -> name) -> (node -> [name]) -> String

module Util.Inst
instance [overlap ok] Show a => Show (Identity a)
instance [overlap ok] Monoid Bool
instance [overlap ok] Monoid (IO ())

module Support.Tickle
class Tickleable a b where tickle f x = runIdentity $ tickleM (return . f) x tickleM_ f b = tickleM (\ x -> f x >> return x) b >> return ()
tickleM :: (Tickleable a b, Monad m) => (a -> m a) -> b -> m b
tickleM_ :: (Tickleable a b, Monad m) => (a -> m c) -> b -> m ()
tickle :: Tickleable a b => (a -> a) -> b -> b
tickleCollect :: (Tickleable a b, Monoid o) => (a -> o) -> b -> o

module Support.Tuple
class Tuple a where tupleNil = tupleMany [] tupleOne x = x
tupleNil :: Tuple a => a
tupleOne :: Tuple a => a -> a
tupleMany :: Tuple a => [a] -> a
class FromTuple a
fromTuple :: FromTuple a => a -> [a]
tuple :: Tuple a => [a] -> a
instance [overlap ok] Tuple String

module Util.ReaderWriter
data ReaderWriter r w a
runReaderWriter :: ReaderWriter r w a -> r -> (a, w)
instance [overlap ok] Monoid w => MonadReader r (ReaderWriter r w)
instance [overlap ok] Monoid w => MonadWriter w (ReaderWriter r w)
instance [overlap ok] Monoid w => Monad (ReaderWriter r w)
instance [overlap ok] Functor (ReaderWriter r w)

module Util.RWS
data RWS r w s a
runRWS :: RWS r w s a -> r -> s -> (a, s, w)
instance [overlap ok] Monoid w => MonadState s (RWS r w s)
instance [overlap ok] Monoid w => MonadWriter w (RWS r w s)
instance [overlap ok] Monoid w => MonadReader r (RWS r w s)
instance [overlap ok] Monoid w => Monad (RWS r w s)
instance [overlap ok] Functor (RWS r w s)

module Util.Progress
data Progress k
progressNew :: Int -> Int -> Progress k
progressStep :: Ord k => Progress k -> k -> (Progress k, [k])
progressIOSteps :: IORef (Progress Char) -> [Char] -> IO ()
progressIONew :: Int -> Int -> Char -> IO (IORef (Progress Char))
progressSteps :: Ord k => Progress k -> [k] -> (Progress k, [k])
instance [overlap ok] (Show k, Show p) => Show (Treap k p)
instance [overlap ok] Show (Progress k)

module Util.ContextMonad
class Monad m => ContextMonad m where type family ContextOf m
withContext :: ContextMonad m => ContextOf m -> m a -> m a
newtype ContextEither a
ContextEither :: (Either [String] a) -> ContextEither a
runContextEither :: ContextEither t -> Either [String] t
runSimpleContextMonad :: ContextEither a -> a
instance [overlap ok] Functor ContextEither
instance [overlap ok] ContextMonad ContextEither
instance [overlap ok] Monad ContextEither
instance [overlap ok] Error [String]

module Support.Transform
data TransformParms p
TransformParms :: Iterate -> Bool -> Bool -> (p -> IO p) -> String -> String -> String -> TransformParms p
transformIterate :: TransformParms p -> Iterate
transformDumpProgress :: TransformParms p -> Bool
transformSkipNoStats :: TransformParms p -> Bool
transformOperation :: TransformParms p -> p -> IO p

-- | general name of transformation
transformCategory :: TransformParms p -> String

-- | what pass we are in
transformPass :: TransformParms p -> String

-- | name of what we are working on
transformName :: TransformParms p -> String
transformParms :: TransformParms p
data Iterate
DontIterate :: Iterate
IterateMax :: !Int -> Iterate
IterateExactly :: !Int -> Iterate
IterateDone :: Iterate
doIterate :: Iterate -> Bool -> Bool
iterateStep :: Iterate -> Iterate
instance [overlap ok] Eq Iterate

module Support.Compat
type SomeException' = SomeException

module FlagDump

-- | Flags
data Flag

-- | show unified type table, after everything has been typechecked
AllTypes :: Flag

-- | show as patterns
Aspats :: Flag

-- | dump atom table on exit
Atom :: Flag

-- | show bindgroups
Bindgroups :: Flag

-- | show step by step what the type inferencer is doing
BoxySteps :: Flag

-- | don't delete C source file after compilation
C :: Flag

-- | detailed information on each class
Class :: Flag

-- | summary of all classes
ClassSummary :: Flag

-- | show intermediate core code
Core :: Flag

-- | show final core before writing ho file
CoreAfterlift :: Flag

-- | show core before lambda lifting
CoreBeforelift :: Flag

-- | show core right after E.FromHs conversion
CoreInitial :: Flag

-- | de-typed core right before it is converted to grin
CoreMangled :: Flag

-- | show details even when optimizing individual functions
CoreMini :: Flag

-- | show each iteration of code while transforming
CorePass :: Flag

-- | show what happens in each pass
CoreSteps :: Flag

-- | show data table of constructors
Datatable :: Flag

-- | show data table entries for some built in types
DatatableBuiltin :: Flag

-- | data constructors
Dcons :: Flag

-- | processed declarations
Decls :: Flag

-- | Show all defined names in a module
Defs :: Flag

-- | show generated derived instances
Derived :: Flag

-- | show expanded aliases
EAlias :: Flag

-- | show info tags on all bound variables
EInfo :: Flag

-- | print the size of E after each pass
ESize :: Flag

-- | print very verbose version of E code always
EVerbose :: Flag

-- | show which names are exported from each module
Exports :: Flag

-- | dump all grin to the screen
Grin :: Flag

-- | print out grin information in a format suitable for loading into a
--   database
GrinDatalog :: Flag

-- | final grin before conversion to C
GrinFinal :: Flag

-- | print dot file of final grin code to outputname_grin.dot
GrinGraph :: Flag

-- | grin right after conversion from core
GrinInitial :: Flag

-- | grin right after first normalization
GrinNormalized :: Flag

-- | show grin code just before eval/apply inlining
GrinPosteval :: Flag

-- | show grin code just before eval/apply inlining
GrinPreeval :: Flag

-- | show in scope names for each module
Imports :: Flag

-- | all ini configuration options
Ini :: Flag

-- | show instances
Instance :: Flag

-- | show results of kind inference for each module
Kind :: Flag

-- | show steps of kind inference
KindSteps :: Flag

-- | show combined stats of optimization passes
OptimizationStats :: Flag

-- | parsed code
Parsed :: Flag

-- | code after preprocessing/deliting
Preprocessed :: Flag

-- | impl expls, the whole shebang.
Program :: Flag

-- | show basic progress indicators
Progress :: Flag

-- | code after uniqueness renaming
Renamed :: Flag

-- | show all user rules and catalysts
Rules :: Flag

-- | show specialization rules
RulesSpec :: Flag

-- | show strongly connected modules in dependency order
SccModules :: Flag

-- | initial signature environment
Sigenv :: Flag

-- | processed signatures from source code
Srcsigs :: Flag

-- | show extra information about stuff
Stats :: Flag

-- | show interpreter go
Steps :: Flag

-- | list of all tags and their types
Tags :: Flag

-- | '-d' flag. The following is a list of possible parameters you can pass
--   to
The :: Flag

-- | display unified type table containing all defined names
Types :: Flag
process :: Set Flag -> [[Char]] -> (Set Flag, [[Char]])
helpMsg :: [Char]
helpFlags :: [[Char]]
instance [overlap ok] Eq Flag
instance [overlap ok] Ord Flag
instance [overlap ok] Bounded Flag
instance [overlap ok] Show Flag

module Fixer.Fixer

-- | Fixable class, must satisfy the following rules
--   
--   isBottom bottom == True x <a>lub</a> x == x x <a>lub</a> y == y
--   <a>lub</a> x x <a>lub</a> bottom == x x <a>minus</a> bottom == x
--   bottom <a>minus</a> x == bottom x <a>minus</a> y == z --&gt; y
--   <a>lub</a> z == x
class Fixable a where lte x y = isBottom (x `minus` y) showFixable x | isBottom x = "." | otherwise = "*"
bottom :: Fixable a => a
isBottom :: Fixable a => a -> Bool
lub :: Fixable a => a -> a -> a
minus :: Fixable a => a -> a -> a
lte :: Fixable a => a -> a -> Bool
showFixable :: Fixable a => a -> String
data Value a
data Rule
data Fixer

-- | add a rule to the current set
addRule :: MonadIO m => Rule -> m ()

-- | turn an IO action into a Rule
ioToRule :: IO () -> Rule

-- | the function must satisfy the rule that if a &gt;= b then f(a) implies
--   f(b)
conditionalRule :: Fixable a => (a -> Bool) -> Value a -> Rule -> Rule
dynamicRule :: Fixable a => Value a -> (a -> Rule) -> Rule

-- | find fixpoint, perhaps printing debugging information to specified
--   handle. will not print anything if no calculation needed.
findFixpoint :: MonadIO m => Maybe (String, Handle) -> Fixer -> m ()
calcFixpoint :: MonadIO m => String -> Fixer -> m ()
isSuperSetOf :: Fixable a => Value a -> Value a -> Rule

-- | the function must satisfy the rule that if a &gt;= b then f(a) &gt;=
--   f(b)
modifiedSuperSetOf :: (Fixable a, Fixable b) => Value b -> Value a -> (a -> b) -> Rule
newFixer :: MonadIO m => m Fixer

-- | mainly for internal use
ioValue :: IO (Value a) -> Value a
newValue :: (MonadIO m, Fixable a) => Fixer -> a -> m (Value a)

-- | read result, calculating fixpoint if needed
readValue :: (Fixable a, MonadIO m) => Value a -> m a
readRawValue :: (Fixable a, MonadIO m) => Value a -> m a
value :: a -> Value a
instance [overlap ok] Typeable Rule
instance [overlap ok] Typeable1 Value
instance [overlap ok] Fixable a => Fixable (Maybe a)
instance [overlap ok] (Fixable a, Fixable b) => Fixable (a, b)
instance [overlap ok] Fixable Int
instance [overlap ok] Fixable Bool
instance [overlap ok] Ord n => Fixable (Set n)
instance [overlap ok] Ord MkFixable
instance [overlap ok] Eq MkFixable
instance [overlap ok] Fixable a => Show (Value a)
instance [overlap ok] Fixable a => Monoid (Value a)
instance [overlap ok] Monoid Rule

module Fixer.Supply
data Supply b a
newSupply :: MonadIO m => Fixer -> m (Supply b a)
supplyReadValues :: (Fixable a, MonadIO m) => Supply b a -> m [(b, a)]
sValue :: (Ord b, Fixable a) => Supply b a -> b -> (Value a)
readSValue :: (MonadIO m, Ord b, Fixable a) => Supply b a -> b -> m a
supplyValue :: (MonadIO m, Ord b, Fixable a) => Supply b a -> b -> m (Value a)
instance [overlap ok] Typeable2 Supply

module Util.NameMonad

-- | There are bound names and used names, the used names are always a
--   superset of the bound names. used names will not be chosen for any new
--   bindings, bound names should be renamed if encountered.
class Monad m => NameMonad n m | m -> n where addNames = addBoundNames
addNames :: NameMonad n m => [n] -> m ()
addBoundNames :: NameMonad n m => [n] -> m ()
newName :: NameMonad n m => m n
newNameFrom :: NameMonad n m => [n] -> m n
uniqueName :: NameMonad n m => n -> m n

-- | Generating names.
class GenName n
genNames :: GenName n => Int -> [n]

-- | Name monad transformer.
data NameMT n m a

-- | Run the name monad transformer.
runNameMT :: Monad m => NameMT a1 m a -> m a
runNameMT' :: Monad m => NameMT a1 m a -> m (a, Set a1)

-- | Generate an infinite list of names not present in the given set.
freeNames :: (Ord n, GenName n) => Set n -> [n]
mixInt :: Int -> Int -> Int
mixInt3 :: Int -> Int -> Int -> Int
hashInt :: Int -> Int
instance [overlap ok] Monad m => Monad (NameMT n m)
instance [overlap ok] MonadTrans (NameMT n)
instance [overlap ok] Functor m => Functor (NameMT n m)
instance [overlap ok] MonadFix m => MonadFix (NameMT n m)
instance [overlap ok] MonadPlus m => MonadPlus (NameMT n m)
instance [overlap ok] MonadIO m => MonadIO (NameMT n m)
instance [overlap ok] (GenName n, Ord n, Monad m) => NameMonad n (NameMT n m)
instance [overlap ok] (Monad m, Monad (t m), MonadTrans t, NameMonad n m) => NameMonad n (t m)
instance [overlap ok] GenName Int


module Util.Seq

-- | Sequences of values <tt>a</tt>.
data Seq a

-- | <i>O(1)</i>. Append two sequences, see <a>append</a>.
(<>) :: Seq a -> Seq a -> Seq a

-- | <i>O(1)</i>. Create an empty sequence.
empty :: Seq a

-- | <i>O(1)</i>. Create a sequence of one element.
single :: a -> Seq a

-- | <i>O(1)</i>. Create a sequence of one element.
singleton :: a -> Seq a

-- | <i>O(1)</i>. Put a value in front of a sequence.
cons :: a -> Seq a -> Seq a

-- | <i>O(1)</i>. Append two sequences.
append :: Seq a -> Seq a -> Seq a

-- | <i>O(n)</i>. Convert a sequence to a list.
toList :: Seq a -> [a]

-- | <i>O(n)</i>. Create a sequence from a list.
fromList :: [a] -> Seq a
instance [overlap ok] Monoid (Seq a)
instance [overlap ok] MonadPlus Seq
instance [overlap ok] Monad Seq
instance [overlap ok] Functor Seq

module Util.VarName
data VarNameT nc ni no m a
type VarName ni no a = VarNameT () ni no Identity a
runVarNameT :: Monad m => VarNameT nc ni no m a -> m a
runVarName :: VarName ni no a -> a
newName :: (Ord ni, Ord nc, Monad m) => [no] -> nc -> ni -> VarNameT nc ni no m no
subVarName :: Monad m => VarNameT nc ni no m a -> VarNameT nc ni no m a
lookupName :: (Ord ni, Monad m, Show ni) => ni -> VarNameT nc ni no m no
maybeLookupName :: (Ord ni, Monad m, Show ni) => ni -> VarNameT nc ni no m (Maybe no)
newLookupName :: (Ord ni, Ord nc, Monad m) => [no] -> nc -> ni -> VarNameT nc ni no m no
instance [overlap ok] Monad m => Monad (VarNameT nc ni no m)
instance [overlap ok] MonadTrans (VarNameT nc ni no)
instance [overlap ok] Functor m => Functor (VarNameT nc ni no m)
instance [overlap ok] MonadFix m => MonadFix (VarNameT nc ni no m)
instance [overlap ok] MonadPlus m => MonadPlus (VarNameT nc ni no m)
instance [overlap ok] MonadIO m => MonadIO (VarNameT nc ni no m)

module Util.SameShape
class SameShape1 f
sameShape1 :: SameShape1 f => f a -> f b -> Bool
class SameShape2 f
sameShape2 :: SameShape2 f => f a b -> f c d -> Bool
instance [overlap ok] SameShape1 IO
instance [overlap ok] SameShape2 Either
instance [overlap ok] SameShape1 Maybe
instance [overlap ok] SameShape1 Tree
instance [overlap ok] SameShape1 []

module Util.HasSize
class IsEmpty a
isEmpty :: IsEmpty a => a -> Bool
class HasSize a where sizeEQ s x = size x == s sizeGT s x = size x > s sizeLT s x = size x < s sizeGTE s x = not $ sizeLT s x sizeLTE s x = not $ sizeGT s x
size :: HasSize a => a -> Int
sizeEQ :: HasSize a => Int -> a -> Bool
sizeGT :: HasSize a => Int -> a -> Bool
sizeLT :: HasSize a => Int -> a -> Bool
sizeGTE :: HasSize a => Int -> a -> Bool
sizeLTE :: HasSize a => Int -> a -> Bool
genSize :: (Integral b, HasSize a) => a -> b
instance [overlap ok] (IsEmpty a, IsEmpty b, IsEmpty c) => IsEmpty (a, b, c)
instance [overlap ok] (IsEmpty a, IsEmpty b) => IsEmpty (a, b)
instance [overlap ok] IsEmpty IntSet
instance [overlap ok] IsEmpty (IntMap v)
instance [overlap ok] IsEmpty (Set a)
instance [overlap ok] IsEmpty (Map a b)
instance [overlap ok] IsEmpty [x]
instance [overlap ok] (HasSize a, HasSize b, HasSize c) => HasSize (a, b, c)
instance [overlap ok] (HasSize a, HasSize b) => HasSize (a, b)
instance [overlap ok] (HasSize a, HasSize b) => HasSize (Either a b)
instance [overlap ok] HasSize IntSet
instance [overlap ok] HasSize (IntMap v)
instance [overlap ok] HasSize (Set a)
instance [overlap ok] HasSize (Map a b)
instance [overlap ok] HasSize [x]

module Support.MapBinaryInstance
putMap :: (Binary k, Ord k, Binary v) => Map k v -> Put
getMap :: (Binary k, Ord k, Binary v) => Get (Map k v)
putSet :: (Binary a, Ord a) => Set a -> Put
getSet :: (Binary a, Ord a) => Get (Set a)

module Name.VConsts
class TypeNames a where tInt = error "tInt" tRational = error "tRational" tChar = error "tChar" tIntzh = error "tIntzh" tEnumzh = error "tEnumzh" tCharzh = error "tCharzh" tBool = error "tBool" tUnit = error "tUnit" tString = error "tString" tInteger = error "tInteger" tWorld__ = error "tWorld"
tInt :: TypeNames a => a
tRational :: TypeNames a => a
tChar :: TypeNames a => a
tIntzh :: TypeNames a => a
tEnumzh :: TypeNames a => a
tCharzh :: TypeNames a => a
tBool :: TypeNames a => a
tUnit :: TypeNames a => a
tString :: TypeNames a => a
tInteger :: TypeNames a => a
tWorld__ :: TypeNames a => a
class ConNames a where vTrue = error "vTrue" vFalse = error "vFalse" vCons = error "vCons" vUnit = error "vUnit"
vTrue :: ConNames a => a
vFalse :: ConNames a => a
vCons :: ConNames a => a
vUnit :: ConNames a => a
class FromTupname a
fromTupname :: (FromTupname a, Monad m) => a -> m Int
class ToTuple a
toTuple :: ToTuple a => Int -> a

-- | various functions needed for desugaring.
data FuncNames a
FuncNames :: a -> a -> a -> a -> a -> a -> a -> a -> a -> FuncNames a
func_equals :: FuncNames a -> a
func_fromInt :: FuncNames a -> a
func_fromInteger :: FuncNames a -> a
func_fromRational :: FuncNames a -> a
func_negate :: FuncNames a -> a
func_runExpr :: FuncNames a -> a
func_runMain :: FuncNames a -> a
func_runNoWrapper :: FuncNames a -> a
func_runRaw :: FuncNames a -> a
instance [overlap ok] Foldable FuncNames
instance [overlap ok] Traversable FuncNames
instance [overlap ok] Functor FuncNames
instance [overlap ok] ToTuple (String, String)
instance [overlap ok] ToTuple String
instance [overlap ok] FromTupname (String, String)
instance [overlap ok] FromTupname String


-- | This is a collection of random useful utility functions written in
--   pure Haskell 98. In general, it trys to conform to the naming scheme
--   put forth the haskell prelude and fill in the obvious omissions, as
--   well as provide useful routines in general. To ensure maximum
--   portability, no instances are exported so it may be added to any
--   project without conflicts.
module GenUtil

-- | Flushes stdout and writes string to standard error
putErr :: String -> IO ()

-- | Flush stdout and write string and newline to standard error
putErrLn :: String -> IO ()

-- | Flush stdout, write string and newline to standard error, then exit
--   program with failure.
putErrDie :: String -> IO a
fromLeft :: Either a b -> a
fromRight :: Either a b -> b

-- | take the fst of every element of a list
fsts :: [(a, b)] -> [a]

-- | take the snd of every element of a list
snds :: [(a, b)] -> [b]

-- | partition a list of eithers.
splitEither :: [Either a b] -> ([a], [b])

-- | take just the rights
rights :: [Either a b] -> [b]

-- | take just the lefts
lefts :: [Either a b] -> [a]
isLeft :: Either t t1 -> Bool
isRight :: Either t t1 -> Bool
fst3 :: (t, t1, t2) -> t
snd3 :: (t, t1, t2) -> t1
thd3 :: (t, t1, t2) -> t2

-- | The computation <a>exitSuccess</a> is equivalent to <a>exitWith</a>
--   <a>ExitSuccess</a>, It terminates the program successfully.
exitSuccess :: IO a

-- | The computation <a>exitFailure</a> is equivalent to <a>exitWith</a>
--   <tt>(</tt><a>ExitFailure</a> <i>exitfail</i><tt>)</tt>, where
--   <i>exitfail</i> is implementation-dependent.
exitFailure :: IO a

-- | the standard unix epoch
epoch :: ClockTime

-- | looks up an enviornment variable and returns it in an arbitrary Monad
--   rather than raising an exception if the variable is not set.
lookupEnv :: Monad m => String -> IO (m String)

-- | an arbitrary time in the future
endOfTime :: ClockTime

-- | recursivly apply function to value until it returns Nothing
repMaybe :: (a -> Maybe a) -> a -> a

-- | apply functions to values inside a tupele. <a>liftT3</a> and
--   <a>liftT4</a> also exist.
liftT2 :: (a -> b, c -> d) -> (a, c) -> (b, d)
liftT3 :: (t -> t3, t1 -> t4, t2 -> t5) -> (t, t1, t2) -> (t3, t4, t5)
liftT4 :: (t -> t4, t1 -> t5, t2 -> t6, t3 -> t7) -> (t, t1, t2, t3) -> (t4, t5, t6, t7)

-- | sorted nub of list, much more efficient than nub, but doesnt preserve
--   ordering.
snub :: Ord a => [a] -> [a]

-- | sorted nub of list of tuples, based solely on the first element of
--   each tuple.
snubFst :: Ord a => [(a, b)] -> [(a, b)]

-- | sorted nub of list based on function of values
snubUnder :: Ord b => (a -> b) -> [a] -> [a]

-- | merge sorted lists in linear time
smerge :: Ord a => [a] -> [a] -> [a]

-- | sort list of tuples, based on first element of each tuple.
sortFst :: Ord a => [(a, b)] -> [(a, b)]

-- | group list of tuples, based only on equality of the first element of
--   each tuple.
groupFst :: Eq a => [(a, b)] -> [[(a, b)]]

-- | A strict version of <a>foldl</a>.
foldl' :: (a -> b -> a) -> a -> [b] -> a
fmapLeft :: Functor f => (a -> c) -> f (Either a b) -> f (Either c b)
fmapRight :: Functor f => (b -> c) -> f (Either a b) -> f (Either a c)

-- | set operations on lists. (slow!)
isDisjoint :: Eq a => [a] -> [a] -> Bool

-- | set operations on lists. (slow!)
isConjoint :: Eq a => [a] -> [a] -> Bool

-- | group a list based on a function of the values.
groupUnder :: Eq b => (a -> b) -> [a] -> [[a]]

-- | sort a list based on a function of the values.
sortUnder :: Ord b => (a -> b) -> [a] -> [a]
minimumUnder :: Ord b => (a -> b) -> [a] -> a
maximumUnder :: Ord b => (a -> b) -> [a] -> a
sortGroupUnder :: Ord a => (b -> a) -> [b] -> [[b]]
sortGroupUnderF :: Ord a => (b -> a) -> [b] -> [(a, [b])]
sortGroupUnderFG :: Ord b => (a -> b) -> (a -> c) -> [a] -> [(b, [c])]
sameLength :: [t] -> [t1] -> Bool
naturals :: [Int]
perhapsM :: Monad m => Bool -> a -> m a
repeatM :: Monad m => m a -> m [a]
repeatM_ :: Monad m => m a -> m ()
replicateM :: Monad m => Int -> m a -> m [a]
replicateM_ :: Monad m => Int -> m a -> m ()

-- | convert a maybe to an arbitrary failable monad
maybeToMonad :: Monad m => Maybe a -> m a
toMonadM :: Monad m => m (Maybe a) -> m a

-- | Trasform IO errors into the failing of an arbitrary monad.
ioM :: Monad m => IO a -> IO (m a)

-- | Trasform IO errors into the mzero of an arbitrary member of MonadPlus.
ioMp :: MonadPlus m => IO a -> IO (m a)
foldlM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
foldlM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
foldl1M :: Monad m => (a -> a -> m a) -> [a] -> m a
foldl1M_ :: Monad m => (a -> a -> m a) -> [a] -> m ()

-- | convert a maybe to an arbitrary failable monad
maybeM :: Monad m => String -> Maybe a -> m a

-- | quote a set of strings as would be appropriate to pass them as
--   arguments to a sh style shell
shellQuote :: [String] -> String

-- | quote strings rc style. single quotes protect any characters between
--   them, to get an actual single quote double it up. Inverse of
--   <a>simpleUnquote</a>
simpleQuote :: [String] -> String

-- | inverse of <a>simpleQuote</a>
simpleUnquote :: String -> [String]

-- | place spaces before each line in string.
indentLines :: Int -> String -> String
buildTableLL :: [(String, String)] -> [String]
buildTableRL :: [(String, String)] -> [String]
buildTable :: [String] -> [(String, [String])] -> String

-- | trim blank lines at beginning and end of string
trimBlankLines :: String -> String

-- | reformat a string to not be wider than a given width, breaking it up
--   between words.
paragraph :: Int -> String -> String
paragraphBreak :: Int -> String -> String

-- | expand tabs into spaces in a string assuming tabs are every 8 spaces
--   and we are starting at column 0.
expandTabs :: String -> String
chunkText :: Int -> String -> String
rot13 :: String -> String

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | compute the power set of a list
powerSet :: [a] -> [[a]]

-- | randomly permute a list given a RNG
randomPermute :: StdGen -> [a] -> [a]

-- | randomly permute a list, using the standard random number generator.
randomPermuteIO :: [a] -> IO [a]
chunk :: Int -> [a] -> [[a]]
rtup :: t1 -> t -> (t, t1)
triple :: t -> t1 -> t2 -> (t, t1, t2)
fromEither :: Either a a -> a
mapFst :: (a -> b) -> (a, c) -> (b, c)
mapSnd :: (a -> b) -> (c, a) -> (c, b)
mapFsts :: (a -> b) -> [(a, c)] -> [(b, c)]
mapSnds :: (a -> b) -> [(c, a)] -> [(c, b)]

-- | Translate characters to other characters in a string, if the second
--   argument is empty, delete the characters in the first argument, else
--   map each character to the cooresponding one in the second argument,
--   cycling the second argument if necessary.
tr :: String -> String -> String -> String
readHex :: Monad m => String -> m Int

-- | determine if two closed intervals overlap at all.
overlaps :: Ord a => (a, a) -> (a, a) -> Bool

-- | translate a number of seconds to a string representing the duration
--   expressed.
showDuration :: (Show a, Integral a) => a -> String
readM :: (Monad m, Read a) => String -> m a
readsM :: (Monad m, Read a) => String -> m (a, String)

-- | Splits a list into components delimited by separators, where the
--   predicate returns True for a separator element. The resulting
--   components do not contain the separators. Two adjacent separators
--   result in an empty component in the output. eg.
--   
--   <pre>
--   split (=='a') "aabbaca"
--   ["", "", "bb", "c", ""]
--   </pre>
split :: (a -> Bool) -> [a] -> [[a]]

-- | Like <a>split</a>, except that sequences of adjacent separators are
--   treated as a single separator. eg.
--   
--   <pre>
--   tokens (=='a') "aabbaca"
--   ["bb","c"]
--   </pre>
tokens :: (a -> Bool) -> [a] -> [[a]]

-- | count elements of list that have a given property
count :: (a -> Bool) -> [a] -> Int
hasRepeatUnder :: Ord a1 => (a -> a1) -> [a] -> Bool

-- | behave like while(<a></a>) in perl, go through the argument list,
--   reading the concation of each file name mentioned or stdin if <a>-</a>
--   is on it. If no arguments are given, read stdin.
getArgContents :: IO String

-- | Process options with an option string like the standard C getopt
--   function call.
parseOpt :: Monad m => String -> [String] -> m ([String], [Char], [(Char, String)])

-- | Combination of parseOpt and getArgContents.
getOptContents :: String -> IO (String, [Char], [(Char, String)])

-- | time task
doTime :: String -> IO a -> IO a
getPrefix :: Monad m => String -> String -> m String
rspan :: (a -> Bool) -> [a] -> ([a], [a])
rbreak :: (a -> Bool) -> [a] -> ([a], [a])
rdropWhile :: (a -> Bool) -> [a] -> [a]
rtakeWhile :: (a -> Bool) -> [a] -> [a]
rbdropWhile :: (a -> Bool) -> [a] -> [a]
concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]
on :: (a -> a -> b) -> (c -> a) -> c -> c -> b
mapMsnd :: Monad m => (b -> m c) -> [(a, b)] -> m [(a, c)]
mapMfst :: Monad m => (b -> m c) -> [(b, a)] -> m [(c, a)]

-- | catch function only for IOException
iocatch :: IO a -> (IOException -> IO a) -> IO a

-- | class for monads which can generate unique values.
class Monad m => UniqueProducer m
newUniq :: UniqueProducer m => m Int


-- | Data.Graph is sorely lacking in several ways, This just tries to fill
--   in some holes and provide a more convinient interface
module Util.Graph
data Graph n
fromGraph :: Graph n -> [(n, [n])]
newGraph :: Ord k => [n] -> (n -> k) -> (n -> [k]) -> (Graph n)

-- | Build a graph from a list of nodes uniquely identified by keys, with a
--   list of keys of nodes this node should have edges to. The out-list may
--   contain keys that don't correspond to nodes of the graph; they are
--   ignored.
newGraph' :: Ord k => [n] -> (n -> k) -> (n -> [k]) -> (Map k Vertex, Graph n)
newGraphReachable :: Ord k => [n] -> (n -> k) -> (n -> [k]) -> ([k] -> [n], Graph n)
reachableFrom :: Ord k => (n -> k) -> (n -> [k]) -> [n] -> [k] -> [n]
reachable :: Graph n -> [Vertex] -> [n]
fromScc :: Either t [t] -> [t]

-- | determine a set of loopbreakers subject to a fitness function
--   loopbreakers have a minimum of their incoming edges ignored.
findLoopBreakers :: (n -> Int) -> (n -> Bool) -> Graph n -> ([n], [n])
sccGroups :: Graph n -> [[n]]
scc :: Graph n -> [Either n [n]]
sccForest :: Graph n -> Forest n
dff :: Graph n -> Forest n
components :: Graph n -> [[n]]
topSort :: Graph n -> [n]
cyclicNodes :: Graph n -> [n]
toDag :: Graph n -> Graph [n]
restitchGraph :: Ord k => (n -> k) -> (n -> [k]) -> Graph n -> Graph n
mapGraph :: (a -> [b] -> b) -> Graph a -> Graph b
transitiveClosure :: Graph n -> Graph n
transitiveReduction :: Graph n -> Graph n
instance [overlap ok] Functor Graph
instance [overlap ok] Show n => Show (Graph n)

module Info.Info
type T = Info
newtype Info
Info :: [Entry] -> Info
data Entry
Entry :: Dynamic -> String -> !TypeRep -> Entry
entryThing :: Entry -> Dynamic
entryString :: Entry -> String
entryType :: Entry -> !TypeRep
class HasInfo a
getInfo :: HasInfo a => a -> Info
modifyInfo :: HasInfo a => (Info -> Info) -> a -> a
lookup :: (Monad m, Typeable a) => Info -> m a
lookupTyp :: Typeable a => a -> Info -> Maybe a
insertWith :: (Show a, Typeable a) => (a -> a -> a) -> a -> Info -> Info
insert :: (Show a, Typeable a) => a -> Info -> Info
limit :: [TypeRep] -> Info -> Info
maybeInsert :: (Show a, Typeable a) => Maybe a -> Info -> Info
singleton :: (Show a, Typeable a) => a -> Info
member :: Typeable a => a -> Info -> Bool
delete :: Typeable a => a -> Info -> Info
fetch :: (Monoid a, Typeable a) => Info -> a
extend :: (Show a, Monoid a, Typeable a) => a -> Info -> Info
empty :: Info
infoMap :: (Typeable a, Typeable b, Show b) => (a -> b) -> Info -> Info
infoMapM :: (Typeable a, Typeable b, Show b, Monad m) => (a -> m b) -> Info -> m Info
instance [overlap ok] Typeable Info
instance [overlap ok] HasSize Info
instance [overlap ok] HasInfo Info
instance [overlap ok] Monoid Info
instance [overlap ok] Show Info
instance [overlap ok] Ord Info
instance [overlap ok] Eq Info
instance [overlap ok] Ord Entry
instance [overlap ok] Show Entry
instance [overlap ok] Eq Entry

module Support.TempDir
getTempDir :: IO FilePath
createTempFile :: FilePath -> IO (FilePath, Handle)
fileInTempDir :: FilePath -> (FilePath -> IO ()) -> IO FilePath
cleanTempDir :: Bool -> IO ()
setTempDir :: FilePath -> IO ()
addAtExit :: IO () -> IO ()
withStackStatus :: String -> IO a -> IO a
wrapMain :: IO () -> IO ()

module Util.Interact
data Interact
Interact :: String -> [InteractCommand] -> [String] -> String -> Map String String -> (Interact -> String -> IO Interact) -> [String] -> [String] -> Bool -> Bool -> Maybe String -> Maybe String -> Interact

-- | the prompt to use
interactPrompt :: Interact -> String

-- | a list of commands
interactCommands :: Interact -> [InteractCommand]

-- | possible things that may be set
interactSettables :: Interact -> [String]

-- | version string to print
interactVersion :: Interact -> String

-- | vars that are actually set
interactSet :: Interact -> Map String String

-- | what to run on a bare expression
interactExpr :: Interact -> Interact -> String -> IO Interact

-- | commands to run at startup
interactRC :: Interact -> [String]

-- | list of words to autocomplete
interactWords :: Interact -> [String]

-- | whether to echo commands
interactEcho :: Interact -> Bool

-- | whether we are in command mode
interactCommandMode :: Interact -> Bool

-- | filename to store history of commands in
interactHistFile :: Interact -> Maybe String

-- | comment initializer
interactComment :: Interact -> Maybe String
data InteractCommand
InteractCommand :: String -> String -> (Interact -> String -> String -> IO Interact) -> InteractCommand
commandName :: InteractCommand -> String
commandHelp :: InteractCommand -> String
commandAction :: InteractCommand -> Interact -> String -> String -> IO Interact

-- | begin interactive interaction
beginInteraction :: Interact -> IO ()

-- | run a command as if typed at prompt
runInteraction :: Interact -> String -> IO Interact
runInteractions :: Interact -> [String] -> IO Interact
emptyInteract :: Interact

module Support.IniParse
parseIniFiles :: Bool -> String -> [FilePath] -> [String] -> IO (Map String String)
instance [overlap ok] Monad P
instance [overlap ok] MonadState St P

module FlagOpts

-- | Flags
data Flag

-- | <ul>
--   <li>bang patterns</li>
--   </ul>
BangPatterns :: Flag

-- | use Boehm garbage collector
Boehm :: Flag

-- | with the '-f' flag, the following options are availible, you can
Controlled :: Flag

-- | pass haskell source through c preprocessor
Cpp :: Flag

-- | use your own thread mechanism
Customthread :: Flag

-- | enable debugging code in generated executable
Debug :: Flag

-- | perform defaulting of ambiguous types
Defaulting :: Flag

-- | <ul>
--   <li>exists keyword for existential types recognized</li>
--   </ul>
Exists :: Flag

-- | support foreign function declarations
Ffi :: Flag

-- | <ul>
--   <li>forall keyword for rank-n types and explicit quantification</li>
--   </ul>
Forall :: Flag

-- | extend Int and Word to 32 bits on a 32 bit machine (rather than 30)
FullInt :: Flag

-- | perform whole program E optimization
GlobalOptimize :: Flag

-- | use inline pragmas
InlinePragmas :: Flag

-- | use the jgc garbage collector
Jgc :: Flag

-- | perform lots of extra type checks
Lint :: Flag

-- | pass haskell source through m4 preprocessor
M4 :: Flag

-- | enforce monomorphism restriction
MonomorphismRestriction :: Flag

-- | any particular one by prepending 'no-' to it.
Negate :: Flag

-- | do not support thread
Nothread :: Flag

-- | implicitly import Prelude
Prelude :: Flag

-- | enable profiling code in generated executable
Profile :: Flag

-- | use pthread for concurrency
Pthread :: Flag

-- | just evaluate main to WHNF and nothing else.
Raw :: Flag

-- | use rules
Rules :: Flag

-- | compile to a standalone executable
Standalone :: Flag

-- | perform a basic points-to analysis on types right after method
--   generation
TypeAnalysis :: Flag

-- | type/data family support
TypeFamilies :: Flag

-- | allow unboxed tuple syntax to be recognized
UnboxedTuples :: Flag

-- | allow unboxed value syntax
UnboxedValues :: Flag

-- | user defined kinds
UserKinds :: Flag

-- | wrap main in exception handler
Wrapper :: Flag
process :: Set Flag -> [[Char]] -> (Set Flag, [[Char]])
helpMsg :: [Char]
helpFlags :: [[Char]]
instance [overlap ok] Eq Flag
instance [overlap ok] Ord Flag
instance [overlap ok] Bounded Flag
instance [overlap ok] Show Flag

module Util.UniqueMonad

-- | Unique integer generator monad transformer.
data UniqT m a

-- | Unique integer generator monad.
type Uniq = UniqT Identity

-- | Run the bare version of the unique int generator.
runUniq :: Int -> Uniq a -> (a, Int)

-- | Run the transformer version of the unique int generator.
runUniqT :: Monad m => UniqT m a -> Int -> m (a, Int)

-- | Execute the bare unique int generator starting with 1.
execUniq1 :: Uniq a -> a

-- | Execute the bare unique int generator starting with the suplied
--   number.
execUniq :: Int -> Uniq a -> a

-- | Execute the transformer version of the unique int generator starting
--   with the suplied number.
execUniqT :: Monad m => Int -> UniqT m a -> m a
instance [overlap ok] Monad m => Monad (UniqT m)
instance [overlap ok] MonadTrans UniqT
instance [overlap ok] Functor m => Functor (UniqT m)
instance [overlap ok] MonadFix m => MonadFix (UniqT m)
instance [overlap ok] MonadPlus m => MonadPlus (UniqT m)
instance [overlap ok] MonadReader s m => MonadReader s (UniqT m)
instance [overlap ok] (Monad m, Monad (t m), MonadTrans t, UniqueProducer m) => UniqueProducer (t m)
instance [overlap ok] Monad m => UniqueProducer (UniqT m)
instance [overlap ok] UniqueProducer IO

module Util.SetLike
(\\) :: Unionize s => s -> s -> s
class Monoid s => Unionize s where sempty = mempty union = mappend unions = foldl' union mempty
union :: Unionize s => s -> s -> s
difference :: Unionize s => s -> s -> s
intersection :: Unionize s => s -> s -> s
unions :: Unionize s => [s] -> s
sempty :: Unionize s => s
class Monoid s => Collection s where singleton e = fromList [e] fromDistinctAscList = fromList
fromList :: Collection s => [Elem s] -> s
fromDistinctAscList :: Collection s => [Elem s] -> s
toList :: Collection s => s -> [Elem s]
singleton :: Collection s => Elem s -> s
class Collection s => SetLike s
keys :: SetLike s => s -> [Key s]
member :: SetLike s => Key s -> s -> Bool
delete :: SetLike s => Key s -> s -> s
sfilter :: SetLike s => (Elem s -> Bool) -> s -> s
insert :: SetLike s => Elem s -> s -> s
spartition :: SetLike s => (Elem s -> Bool) -> s -> (s, s)
notMember :: SetLike s => Key s -> s -> Bool
class SetLike m => MapLike m
mlookup :: MapLike m => Key m -> m -> Maybe (Value m)
values :: MapLike m => m -> [Value m]
unionWith :: MapLike m => (Value m -> Value m -> Value m) -> m -> m -> m
minsert :: (MapLike m, Elem m ~ (k, v)) => k -> v -> m -> m
msingleton :: (MapLike m, Elem m ~ (k, v)) => k -> v -> m
intersects :: (IsEmpty a, Unionize a) => a -> a -> Bool
findWithDefault :: MapLike m => Value m -> Key m -> m -> Value m
newtype EnumSet a
EnumSet :: IntSet -> EnumSet a
newtype EnumMap k v
EnumMap :: (IntMap v) -> EnumMap k v
class Intjection a
fromIntjection :: Intjection a => a -> Int
toIntjection :: Intjection a => Int -> a
newtype IntjectionSet a
IntjectionSet :: IntSet -> IntjectionSet a
newtype IntjectionMap k v
IntjectionMap :: (IntMap v) -> IntjectionMap k v
instance [overlap ok] Monoid (EnumSet a)
instance [overlap ok] IsEmpty (EnumSet a)
instance [overlap ok] HasSize (EnumSet a)
instance [overlap ok] Unionize (EnumSet a)
instance [overlap ok] Eq (EnumSet a)
instance [overlap ok] Ord (EnumSet a)
instance [overlap ok] Monoid (EnumMap k v)
instance [overlap ok] IsEmpty (EnumMap k v)
instance [overlap ok] Functor (EnumMap k)
instance [overlap ok] Foldable (EnumMap k)
instance [overlap ok] Traversable (EnumMap k)
instance [overlap ok] HasSize (EnumMap k v)
instance [overlap ok] Unionize (EnumMap k v)
instance [overlap ok] Eq v => Eq (EnumMap k v)
instance [overlap ok] Ord v => Ord (EnumMap k v)
instance [overlap ok] Monoid (IntjectionSet a)
instance [overlap ok] IsEmpty (IntjectionSet a)
instance [overlap ok] HasSize (IntjectionSet a)
instance [overlap ok] Unionize (IntjectionSet a)
instance [overlap ok] Eq (IntjectionSet a)
instance [overlap ok] Ord (IntjectionSet a)
instance [overlap ok] Monoid (IntjectionMap k v)
instance [overlap ok] IsEmpty (IntjectionMap k v)
instance [overlap ok] Functor (IntjectionMap k)
instance [overlap ok] Foldable (IntjectionMap k)
instance [overlap ok] Traversable (IntjectionMap k)
instance [overlap ok] HasSize (IntjectionMap k v)
instance [overlap ok] Unionize (IntjectionMap k v)
instance [overlap ok] Eq v => Eq (IntjectionMap k v)
instance [overlap ok] Ord v => Ord (IntjectionMap k v)
instance [overlap ok] Intjection k => MapLike (IntjectionMap k v)
instance [overlap ok] Intjection k => SetLike (IntjectionMap k v)
instance [overlap ok] Intjection k => Collection (IntjectionMap k v)
instance [overlap ok] Intjection a => SetLike (IntjectionSet a)
instance [overlap ok] Intjection a => Collection (IntjectionSet a)
instance [overlap ok] (Intjection a, Show a) => Show (IntjectionSet a)
instance [overlap ok] Enum k => MapLike (EnumMap k v)
instance [overlap ok] Enum k => SetLike (EnumMap k v)
instance [overlap ok] Enum k => Collection (EnumMap k v)
instance [overlap ok] Enum a => SetLike (EnumSet a)
instance [overlap ok] Enum a => Collection (EnumSet a)
instance [overlap ok] Ord k => MapLike (Map k v)
instance [overlap ok] Ord k => SetLike (Map k v)
instance [overlap ok] Ord k => Collection (Map k v)
instance [overlap ok] Ord k => Unionize (Map k v)
instance [overlap ok] MapLike (IntMap v)
instance [overlap ok] SetLike (IntMap v)
instance [overlap ok] Collection (IntMap v)
instance [overlap ok] Unionize (IntMap v)
instance [overlap ok] Ord k => SetLike (Set k)
instance [overlap ok] Ord k => Collection (Set k)
instance [overlap ok] Ord k => Unionize (Set k)
instance [overlap ok] SetLike IntSet
instance [overlap ok] Collection IntSet
instance [overlap ok] Unionize IntSet


-- | extend Data.Set with relation operations
module Util.Relation
newtype Rel a b
Rel :: (Map a (Set b)) -> Rel a b
prune :: Map a (Set b) -> Rel a b
domain :: (Ord a, Ord b) => Rel a b -> Set a
range :: (Ord a, Ord b) => Rel a b -> Set b
restrictDomain :: (Ord a, Ord b) => (a -> Bool) -> Rel a b -> Rel a b
restrictDomainS :: (Ord a, Ord b) => a -> Rel a b -> Rel a b
restrictDomainSet :: (Ord a, Ord b) => Set a -> Rel a b -> Rel a b
restrictRange :: (Ord a, Ord b) => (b -> Bool) -> Rel a b -> Rel a b
mapDomain :: (Ord a, Ord b, Ord c) => (a -> c) -> Rel a b -> Rel c b
mapRange :: (Ord a, Ord b, Ord c) => (b -> c) -> Rel a b -> Rel a c
partitionDomain :: (a -> Bool) -> Rel a b -> (Rel a b, Rel a b)
unRel :: Rel t t1 -> Map t (Set t1)
toRelationList :: (Ord a, Ord b) => Rel a b -> [(a, [b])]
instance [overlap ok] (Eq a, Eq b) => Eq (Rel a b)
instance [overlap ok] (Ord a, Ord b) => Collection (Rel a b)
instance [overlap ok] (Ord a, Ord b) => Unionize (Rel a b)
instance [overlap ok] (Ord a, Ord b) => Monoid (Rel a b)

module Util.GMap
gsetToSet :: (Collection (GSet a), Ord a) => GSet a -> Set a
class GMapSet k
toSet :: GMapSet k => GMap k v -> GSet k
toMap :: GMapSet k => (k -> v) -> GSet k -> GMap k v
instance [overlap ok] Monoid (GMap Char v)
instance [overlap ok] IsEmpty (GMap Char v)
instance [overlap ok] HasSize (GMap Char v)
instance [overlap ok] Collection (GMap Char v)
instance [overlap ok] Unionize (GMap Char v)
instance [overlap ok] SetLike (GMap Char v)
instance [overlap ok] MapLike (GMap Char v)
instance [overlap ok] Monoid (GSet Char)
instance [overlap ok] IsEmpty (GSet Char)
instance [overlap ok] HasSize (GSet Char)
instance [overlap ok] Collection (GSet Char)
instance [overlap ok] Unionize (GSet Char)
instance [overlap ok] SetLike (GSet Char)
instance [overlap ok] Monoid (GSet Int)
instance [overlap ok] IsEmpty (GSet Int)
instance [overlap ok] HasSize (GSet Int)
instance [overlap ok] Collection (GSet Int)
instance [overlap ok] Unionize (GSet Int)
instance [overlap ok] SetLike (GSet Int)
instance [overlap ok] Monoid (GMap Int v)
instance [overlap ok] IsEmpty (GMap Int v)
instance [overlap ok] HasSize (GMap Int v)
instance [overlap ok] Collection (GMap Int v)
instance [overlap ok] Unionize (GMap Int v)
instance [overlap ok] SetLike (GMap Int v)
instance [overlap ok] MapLike (GMap Int v)
instance [overlap ok] GMapSet Int
instance [overlap ok] Functor (GMap Int)

module Util.BitSet
data BitSet
newtype EnumBitSet a
EBS :: BitSet -> EnumBitSet a
toWord :: BitSet -> Word
fromWord :: Word -> BitSet
instance [overlap ok] Eq BitSet
instance [overlap ok] Ord BitSet
instance [overlap ok] Monoid (EnumBitSet a)
instance [overlap ok] Unionize (EnumBitSet a)
instance [overlap ok] HasSize (EnumBitSet a)
instance [overlap ok] Eq (EnumBitSet a)
instance [overlap ok] Ord (EnumBitSet a)
instance [overlap ok] IsEmpty (EnumBitSet a)
instance [overlap ok] Enum a => SetLike (EnumBitSet a)
instance [overlap ok] Enum a => Collection (EnumBitSet a)
instance [overlap ok] Show BitSet
instance [overlap ok] HasSize BitSet
instance [overlap ok] IsEmpty BitSet
instance [overlap ok] SetLike BitSet
instance [overlap ok] Collection BitSet
instance [overlap ok] Unionize BitSet
instance [overlap ok] Monoid BitSet


-- | some useful types to use in Info's that don't really fit anywhere else
module Info.Types

-- | how many arguments a function my be applied to before it performs work
--   and whether it bottoms out after that many arguments
data Arity
Arity :: Int -> Bool -> Arity

-- | list of properties of a function, such as specified by use pragmas or
--   options
newtype Properties
Properties :: (EnumBitSet Property) -> Properties
class HasProperties a where unsetProperty prop = modifyProperties (delete prop) setProperty prop = modifyProperties (insert prop) setProperties xs = modifyProperties (`mappend` fromList xs) getProperty atom = member atom . getProperties
modifyProperties :: HasProperties a => (Properties -> Properties) -> a -> a
getProperties :: HasProperties a => a -> Properties
putProperties :: HasProperties a => Properties -> a -> a
setProperty :: HasProperties a => Property -> a -> a
unsetProperty :: HasProperties a => Property -> a -> a
getProperty :: HasProperties a => Property -> a -> Bool
setProperties :: HasProperties a => [Property] -> a -> a
fetchProperties :: Info -> Maybe Properties
instance [overlap ok] Typeable Arity
instance [overlap ok] Typeable Properties
instance [overlap ok] Show Arity
instance [overlap ok] Ord Arity
instance [overlap ok] Eq Arity
instance [overlap ok] Eq Properties
instance [overlap ok] Collection Properties
instance [overlap ok] SetLike Properties
instance [overlap ok] HasSize Properties
instance [overlap ok] Monoid Properties
instance [overlap ok] Unionize Properties
instance [overlap ok] IsEmpty Properties
instance [overlap ok] HasProperties Info
instance [overlap ok] HasProperties Properties
instance [overlap ok] Show Properties


-- | similar to GenUtil but can rely on non-haskell 98 features
module Util.Gen
mconcatMap :: Monoid a => (a1 -> a) -> [a1] -> a
mintercalate :: Monoid a => a -> [a] -> a
mconcatMapM :: (Monad m, Monoid b) => (a -> m b) -> [a] -> m b
runReadP :: Monad m => ReadP a -> String -> m a
runEither :: String -> Either String a -> a
travCollect :: Monoid w => ((a -> Writer w a) -> a -> Writer w a) -> (a -> w) -> a -> w
forMn_ :: Monad m => [a] -> ((a, Int) -> m b) -> m ()
forMn :: Monad m => [a] -> ((a, Int) -> m b) -> m [b]
shortenPath :: String -> IO String
maybeDo :: Monad m => Maybe (m a) -> (m ())

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

module Cmm.Op
data BinOp
Add :: BinOp
Sub :: BinOp
Mul :: BinOp
Mulx :: BinOp
UMulx :: BinOp

-- | round to -Infinity
Div :: BinOp

-- | mod rounding to -Infinity
Mod :: BinOp

-- | round to 0
Quot :: BinOp

-- | rem rounding to 0
Rem :: BinOp

-- | round to zero (unsigned)
UDiv :: BinOp

-- | unsigned mod
UMod :: BinOp
And :: BinOp
Or :: BinOp
Xor :: BinOp
Shl :: BinOp

-- | shift right logical
Shr :: BinOp

-- | shift right arithmetic
Shra :: BinOp
Rotl :: BinOp
Rotr :: BinOp
FAdd :: BinOp
FSub :: BinOp
FDiv :: BinOp
FMul :: BinOp
FPwr :: BinOp
FAtan2 :: BinOp
Eq :: BinOp
NEq :: BinOp
Gt :: BinOp
Gte :: BinOp
Lt :: BinOp
Lte :: BinOp
UGt :: BinOp
UGte :: BinOp
ULt :: BinOp
ULte :: BinOp
FEq :: BinOp
FNEq :: BinOp
FGt :: BinOp
FGte :: BinOp
FLt :: BinOp
FLte :: BinOp
FOrdered :: BinOp
data UnOp

-- | 2s compliment negation
Neg :: UnOp

-- | bitwise compliment floating
Com :: UnOp

-- | floating absolute value
FAbs :: UnOp

-- | floating point negation
FNeg :: UnOp
Sin :: UnOp
Cos :: UnOp
Tan :: UnOp
Sinh :: UnOp
Cosh :: UnOp
Tanh :: UnOp
Asin :: UnOp
Acos :: UnOp
Atan :: UnOp
Log :: UnOp
Exp :: UnOp
Sqrt :: UnOp

-- | Switch the order of the bytes in a word
Bswap :: UnOp

-- | Returns one plus the index of the least significant 1-bit of x, 0 if x
--   is zero.
Ffs :: UnOp

-- | number of leading (from MSB) zeros, undefined if zero
Clz :: UnOp

-- | number of trailing (from LSB) zeros, undefined if zero.
Ctz :: UnOp

-- | number of bits set to 1 in word
Popcount :: UnOp

-- | number of bits set to 1 mod 2
Parity :: UnOp
data ConvOp

-- | convert a floating point to an integral value via truncation
F2I :: ConvOp

-- | convert a floating point to an unsigned integral value via truncation,
--   negative values become zero
F2U :: ConvOp

-- | convert an unsigned integral value to a floating point number
U2F :: ConvOp

-- | convert an integral value to a floating point number
I2F :: ConvOp

-- | convert a float from one precision to another, preserving value as
--   much as possible
F2F :: ConvOp

-- | extract the low order bits
Lobits :: ConvOp

-- | sign extend a value (signed)
Sx :: ConvOp

-- | zero extend a value (unsigned)
Zx :: ConvOp

-- | perform a <a>Lobits</a> or a <a>Sx</a> depending on the sizes of the
--   arguments
I2I :: ConvOp

-- | perform a <a>Lobits</a> or a <a>Zx</a> depending on the sizes of the
--   arguments
U2U :: ConvOp

-- | a nop, useful for coercing hints (bits 2 bits)
B2B :: ConvOp
data ValOp
NaN :: ValOp
PInf :: ValOp
NInf :: ValOp
PZero :: ValOp
NZero :: ValOp
data ArchBits
BitsMax :: ArchBits
BitsPtr :: ArchBits
BitsUnknown :: ArchBits
data TyBits
Bits :: {-# UNPACK #-} !Int -> TyBits
BitsArch :: !ArchBits -> TyBits
BitsExt :: String -> TyBits
data TyHint
HintSigned :: TyHint
HintUnsigned :: TyHint
HintFloat :: TyHint
HintCharacter :: TyHint
HintNone :: TyHint
data Ty
TyBits :: !TyBits -> !TyHint -> Ty
TyBool :: Ty
TyComplex :: Ty -> Ty
TyVector :: !Int -> Ty -> Ty
preadTy :: ReadP Ty
readTy :: Monad m => String -> m Ty
stringToOpTy :: String -> Ty
bool :: Ty
bits_ptr :: Ty
bits_max :: Ty
bits8 :: Ty
bits16 :: Ty
bits32 :: Ty
bits64 :: Ty
class ToCmmTy a
toCmmTy :: ToCmmTy a => a -> Maybe Ty
cmmTyBits :: ToCmmTy a => a -> Maybe Int
cmmTyHint :: ToCmmTy a => a -> Maybe TyHint
data Op v
BinOp :: BinOp -> v -> v -> Op v
UnOp :: UnOp -> v -> Op v
ValOp :: ValOp -> Op v
ConvOp :: ConvOp -> v -> Op v
binopType :: BinOp -> Ty -> Ty -> Ty
isCommutable :: BinOp -> Bool
commuteBinOp :: BinOp -> Maybe BinOp
isAssociative :: BinOp -> Bool
unopFloat :: Ty -> UnOp -> Maybe String
binopFunc :: Ty -> Ty -> BinOp -> Maybe String
binopInfix :: BinOp -> Maybe (String, Int)
class IsOperator o
isCheap :: IsOperator o => o -> Bool
isEagerSafe :: IsOperator o => o -> Bool
instance [overlap ok] Binary v_1627847622 => Binary (Op v_1627847622)
instance [overlap ok] Binary Ty
instance [overlap ok] Binary TyHint
instance [overlap ok] Binary TyBits
instance [overlap ok] Binary ArchBits
instance [overlap ok] Binary ValOp
instance [overlap ok] Binary ConvOp
instance [overlap ok] Binary UnOp
instance [overlap ok] Binary BinOp
instance [overlap ok] Eq BinOp
instance [overlap ok] Show BinOp
instance [overlap ok] Ord BinOp
instance [overlap ok] Read BinOp
instance [overlap ok] Enum BinOp
instance [overlap ok] Bounded BinOp
instance [overlap ok] Eq UnOp
instance [overlap ok] Show UnOp
instance [overlap ok] Ord UnOp
instance [overlap ok] Read UnOp
instance [overlap ok] Enum UnOp
instance [overlap ok] Bounded UnOp
instance [overlap ok] Eq ConvOp
instance [overlap ok] Show ConvOp
instance [overlap ok] Ord ConvOp
instance [overlap ok] Read ConvOp
instance [overlap ok] Enum ConvOp
instance [overlap ok] Bounded ConvOp
instance [overlap ok] Eq ValOp
instance [overlap ok] Show ValOp
instance [overlap ok] Ord ValOp
instance [overlap ok] Read ValOp
instance [overlap ok] Bounded ValOp
instance [overlap ok] Eq ArchBits
instance [overlap ok] Ord ArchBits
instance [overlap ok] Eq TyBits
instance [overlap ok] Ord TyBits
instance [overlap ok] Eq TyHint
instance [overlap ok] Ord TyHint
instance [overlap ok] Eq Ty
instance [overlap ok] Ord Ty
instance [overlap ok] Eq v => Eq (Op v)
instance [overlap ok] Show v => Show (Op v)
instance [overlap ok] Ord v => Ord (Op v)
instance [overlap ok] IsOperator (Op v)
instance [overlap ok] IsOperator ConvOp
instance [overlap ok] IsOperator UnOp
instance [overlap ok] IsOperator BinOp
instance [overlap ok] Show ArchBits
instance [overlap ok] Show TyBits
instance [overlap ok] Show Ty
instance [overlap ok] Show TyHint
instance [overlap ok] ToCmmTy String
instance [overlap ok] ToCmmTy Ty

module FindFixpoint
data Ms b c
getVal :: Int -> Ms b b
solve :: Eq b => Maybe String -> b -> [Ms b b] -> IO [b]
instance [overlap ok] Functor (Ms b)
instance [overlap ok] Monad (Ms b)

module Util.FilterInput
filterInput :: String -> [String] -> Handle -> IO String
readSystem :: String -> [String] -> IO ByteString

module Support.FreeVars
class Monoid b => FreeVars a b
freeVars :: FreeVars a b => a -> b
instance [overlap ok] (FreeVars x b, FreeVars y b) => FreeVars (Either x y) b
instance [overlap ok] FreeVars a b => FreeVars (Maybe a) b
instance [overlap ok] FreeVars a b => FreeVars [a] b
instance [overlap ok] (FreeVars x b, FreeVars y b, FreeVars z b) => FreeVars (x, y, z) b
instance [overlap ok] (FreeVars x b, FreeVars y b) => FreeVars (x, y) b
instance [overlap ok] Monoid x => FreeVars () x

module Support.CanType
class CanType a where type family TypeOf a
getType :: CanType a => a -> (TypeOf a)
instance [overlap ok] (CanType e1, CanType e2) => CanType (Either e1 e2)
instance [overlap ok] CanType e => CanType (Maybe e)
instance [overlap ok] CanType e => CanType [e]

module StringTable.Atom
data Atom
class ToAtom a where toAtomIO a = return (toAtom a) toAtom a = unsafePerformIO (toAtomIO a)
toAtom :: ToAtom a => a -> Atom
toAtomIO :: ToAtom a => a -> IO Atom
class FromAtom a where fromAtomIO a = return (fromAtom a) fromAtom a = unsafePerformIO (fromAtomIO a)
fromAtom :: FromAtom a => Atom -> a
fromAtomIO :: FromAtom a => Atom -> IO a
class HasHash a
hash32 :: HasHash a => a -> Word32
intToAtom :: Monad m => Int -> m Atom
isValidAtom :: Int -> Bool
unsafeIntToAtom :: Int -> Atom
atomCompare :: Atom -> Atom -> Ordering
unsafeByteIndex :: Atom -> Int -> Word8
dumpTable :: IO ()
dumpToFile :: IO ()
dumpStringTableStats :: IO ()
instance [overlap ok] Typeable Atom
instance [overlap ok] Eq Atom
instance [overlap ok] Data Atom
instance [overlap ok] Ord Atom
instance [overlap ok] Monoid (GMap Atom v)
instance [overlap ok] IsEmpty (GMap Atom v)
instance [overlap ok] HasSize (GMap Atom v)
instance [overlap ok] Collection (GMap Atom v)
instance [overlap ok] Unionize (GMap Atom v)
instance [overlap ok] SetLike (GMap Atom v)
instance [overlap ok] MapLike (GMap Atom v)
instance [overlap ok] Eq v => Eq (GMap Atom v)
instance [overlap ok] Ord v => Ord (GMap Atom v)
instance [overlap ok] Monoid (GSet Atom)
instance [overlap ok] IsEmpty (GSet Atom)
instance [overlap ok] HasSize (GSet Atom)
instance [overlap ok] Collection (GSet Atom)
instance [overlap ok] Unionize (GSet Atom)
instance [overlap ok] SetLike (GSet Atom)
instance [overlap ok] Eq (GSet Atom)
instance [overlap ok] Ord (GSet Atom)
instance [overlap ok] Show (GSet Atom)
instance [overlap ok] Binary Atom
instance [overlap ok] Functor (GMap Atom)
instance [overlap ok] Intjection Atom
instance [overlap ok] Read Atom
instance [overlap ok] Show Atom
instance [overlap ok] IsString Atom
instance [overlap ok] Monoid Atom
instance [overlap ok] FromAtom ByteString
instance [overlap ok] FromAtom Int
instance [overlap ok] FromAtom Word
instance [overlap ok] FromAtom CStringLen
instance [overlap ok] ToAtom ByteString
instance [overlap ok] FromAtom String
instance [overlap ok] ToAtom String
instance [overlap ok] ToAtom CString
instance [overlap ok] ToAtom CStringLen
instance [overlap ok] ToAtom Char
instance [overlap ok] FromAtom Atom
instance [overlap ok] ToAtom Atom
instance [overlap ok] FromAtom (String -> String)
instance [overlap ok] HasHash String
instance [overlap ok] HasHash ByteString
instance [overlap ok] HasHash Atom

module PackedString
data PackedString

-- | Convert a <a>String</a> into a <a>PackedString</a>
packString :: String -> PackedString
unpackPS :: PackedString -> String
instance [overlap ok] Typeable PackedString
instance [overlap ok] Binary PackedString
instance [overlap ok] Eq PackedString
instance [overlap ok] Ord PackedString
instance [overlap ok] Monoid PackedString
instance [overlap ok] Data PackedString
instance [overlap ok] IsString PackedString
instance [overlap ok] Show PackedString

module FrontEnd.SrcLoc
data SrcLoc
SrcLoc :: PackedString -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> SrcLoc
srcLocFileName :: SrcLoc -> PackedString
srcLocLine :: SrcLoc -> {-# UNPACK #-} !Int
srcLocColumn :: SrcLoc -> {-# UNPACK #-} !Int
data SrcSpan
SrcSpan :: !SrcLoc -> !SrcLoc -> SrcSpan
srcSpanBegin :: SrcSpan -> !SrcLoc
srcSpanEnd :: SrcSpan -> !SrcLoc
fileNameCommandLine :: PackedString
fileNameUnknown :: PackedString
fileNameGenerated :: PackedString
bogusASrcLoc :: SrcLoc
bogusSrcSpan :: SrcSpan
class HasLocation a where srcSpan x = bogusSrcSpan {srcSpanBegin = slx, srcSpanEnd = slx} where slx = srcLoc x srcLoc x = srcSpanBegin (srcSpan x)
srcLoc :: HasLocation a => a -> SrcLoc
srcSpan :: HasLocation a => a -> SrcSpan
data Located x
Located :: SrcSpan -> x -> Located x
fromLocated :: Located x -> x
located :: HasLocation a => a -> x -> Located x
class Monad m => MonadSrcLoc m where getSrcSpan = getSrcLoc >>= return . srcSpan getSrcLoc = getSrcSpan >>= return . srcLoc
getSrcLoc :: MonadSrcLoc m => m SrcLoc
getSrcSpan :: MonadSrcLoc m => m SrcSpan
class MonadSrcLoc m => MonadSetSrcLoc m where withSrcLoc sl a = withSrcSpan (srcSpan sl) a withSrcSpan ss a = withSrcLoc (srcLoc ss) a
withSrcLoc :: MonadSetSrcLoc m => SrcLoc -> m a -> m a
withSrcSpan :: MonadSetSrcLoc m => SrcSpan -> m a -> m a
withLocation :: (HasLocation l, MonadSetSrcLoc m) => l -> m a -> m a
srcLocLine_s :: Int -> SrcLoc -> SrcLoc
srcLocLine_u :: (Int -> Int) -> SrcLoc -> SrcLoc
srcLocFileName_s :: PackedString -> SrcLoc -> SrcLoc
srcLocFileName_u :: (PackedString -> PackedString) -> SrcLoc -> SrcLoc
srcLocColumn_s :: Int -> SrcLoc -> SrcLoc
srcLocColumn_u :: (Int -> Int) -> SrcLoc -> SrcLoc
srcSpanEnd_s :: SrcLoc -> SrcSpan -> SrcSpan
srcSpanEnd_u :: (SrcLoc -> SrcLoc) -> SrcSpan -> SrcSpan
srcSpanBegin_s :: SrcLoc -> SrcSpan -> SrcSpan
srcSpanBegin_u :: (SrcLoc -> SrcLoc) -> SrcSpan -> SrcSpan
instance [overlap ok] Binary x_1627988786 => Binary (Located x_1627988786)
instance [overlap ok] Binary SrcSpan
instance [overlap ok] Binary SrcLoc
instance [overlap ok] Typeable SrcLoc
instance [overlap ok] Typeable SrcSpan
instance [overlap ok] Typeable1 Located
instance [overlap ok] Data SrcLoc
instance [overlap ok] Eq SrcLoc
instance [overlap ok] Ord SrcLoc
instance [overlap ok] Data SrcSpan
instance [overlap ok] Eq SrcSpan
instance [overlap ok] Ord SrcSpan
instance [overlap ok] Ord x => Ord (Located x)
instance [overlap ok] Show x => Show (Located x)
instance [overlap ok] Data x => Data (Located x)
instance [overlap ok] Eq x => Eq (Located x)
instance [overlap ok] Show SrcSpan
instance [overlap ok] Show SrcLoc
instance [overlap ok] MonadSetSrcLoc Identity
instance [overlap ok] MonadSrcLoc Identity
instance [overlap ok] Monoid w => MonadSetSrcLoc (Writer w)
instance [overlap ok] Monoid w => MonadSrcLoc (Writer w)
instance [overlap ok] Traversable Located
instance [overlap ok] Foldable Located
instance [overlap ok] Functor Located
instance [overlap ok] HasLocation (Located a)
instance [overlap ok] HasLocation (SrcLoc, SrcLoc)
instance [overlap ok] HasLocation SrcSpan
instance [overlap ok] HasLocation SrcLoc
instance [overlap ok] HasLocation a => HasLocation [a]
instance [overlap ok] Monoid SrcLoc

module FrontEnd.Diagnostic
data Diagnostic
Msg :: (Maybe SrcLoc) -> String -> Diagnostic
makeMsg :: Description -> String -> Diagnostic
locMsg :: SrcLoc -> Description -> String -> Diagnostic
locSimple :: SrcLoc -> Description -> Diagnostic
simpleMsg :: Description -> Diagnostic
dumpDiagnostic :: Int -> [Diagnostic] -> String
typeError :: Monad m => TypeError -> [Diagnostic] -> m a
data TypeError
Unification :: String -> TypeError
Failure :: String -> TypeError
instance [overlap ok] Show Diagnostic

module Options

-- | Parse commandline options.
processOptions :: IO Opt
data Opt
Opt :: Mode -> !Int -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> StopCondition -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> [String] -> [String] -> !Bool -> Maybe (Bool, String) -> [String] -> Bool -> Maybe String -> !Bool -> !Bool -> !Bool -> !Int -> !Int -> Map String String -> Set Flag -> Set Flag -> Opt

-- | Mode of interaction
optMode :: Opt -> Mode

-- | Width of terminal.
optColumns :: Opt -> !Int

-- | Dump options (raw).
optDump :: Opt -> [String]

-- | statements to execute
optStmts :: Opt -> [String]

-- | Flag options (raw).
optFOpts :: Opt -> [String]

-- | Include directories.
optIncdirs :: Opt -> [String]

-- | Optional arguments to the C compiler.
optCCargs :: Opt -> [String]

-- | Load the specified hl-files (haskell libraries).
optHls :: Opt -> [String]

-- | AutoLoaded haskell libraries.
optAutoLoads :: Opt -> [String]

-- | Path to look for libraries.
optHlPath :: Opt -> [String]
optIncs :: Opt -> [String]
optDefs :: Opt -> [String]
optExtensions :: Opt -> [String]
optStop :: Opt -> StopCondition
optWorkDir :: Opt -> Maybe FilePath
optAnnotate :: Opt -> Maybe FilePath
optDeps :: Opt -> Maybe FilePath
optHoDir :: Opt -> Maybe FilePath
optHoCache :: Opt -> Maybe FilePath
optTargetsIni :: Opt -> Maybe FilePath
optArgs :: Opt -> [String]

-- | treat these modules as stale
optStale :: Opt -> [String]

-- | Keep going when encountering errors.
optKeepGoing :: Opt -> !Bool

-- | Entry point name for the main function.
optMainFunc :: Opt -> Maybe (Bool, String)

-- | target architecture
optArch :: Opt -> [String]
optCross :: Opt -> Bool

-- | Name of output file.
optOutName :: Opt -> Maybe String

-- | Ignore ho-files.
optIgnoreHo :: Opt -> !Bool

-- | Don't write ho-files.
optNoWriteHo :: Opt -> !Bool

-- | Don't autoload packages
optNoAuto :: Opt -> !Bool

-- | Verbosity
optVerbose :: Opt -> !Int

-- | Level to print statistics
optStatLevel :: Opt -> !Int

-- | options read from ini files
optInis :: Opt -> Map String String

-- | Dump flags.
optDumpSet :: Opt -> Set Flag

-- | Flag options (-f&lt;opt&gt;).
optFOptsSet :: Opt -> Set Flag

-- | The global options currently used.
options :: Opt
data Mode

-- | Build the specified hl-file given a description file.
BuildHl :: FilePath -> Mode

-- | Run interactively.
Interactive :: Mode

-- | Print version and die.
Version :: Mode

-- | Print version context and die.
VersionCtx :: Mode

-- | Show help message and die.
ShowHelp :: Mode

-- | Show configuration info.
ShowConfig :: Mode

-- | Compile executable
CompileExe :: Mode

-- | Show ho-file.
ShowHo :: String -> Mode

-- | List libraries
ListLibraries :: Mode

-- | Print options for hsc2hs
PrintHscOptions :: Mode

-- | Purge the cache
PurgeCache :: Mode

-- | Filter through preprocessor
Preprocess :: Mode
data StopCondition

-- | error
StopError :: String -> StopCondition

-- | Just parse and rename modules then exit
StopParse :: StopCondition

-- | Stop after type checking
StopTypeCheck :: StopCondition

-- | Stop after producing C code.
StopC :: StopCondition

-- | Compile ho
CompileHo :: StopCondition

-- | Don't stop believing.
StopNot :: StopCondition

-- | Put a string to stderr when running verbose.
putVerbose :: String -> IO ()

-- | Put a line to stderr when running verbose.
putVerboseLn :: String -> IO ()
putProgress :: String -> IO ()

-- | Put a line to stderr when running verbose.
putProgressLn :: String -> IO ()
getArguments :: IO [String]
findHoCache :: IO (Maybe FilePath)

-- | Is verbose &gt; 0?
verbose :: Bool

-- | Is verbose &gt; 1?
verbose2 :: Bool

-- | Is verbose &gt; 0?
progress :: Bool

-- | Test whether a dump flag is set.
dump :: Flag -> Bool

-- | Do the action when the suplied dump flag is set.
wdump :: Monad m => Flag -> m () -> m ()

-- | Test whether an option flag is set.
fopts :: Flag -> Bool

-- | Is the "lint" option flag set?
flint :: Bool
fileOptions :: Monad m => Opt -> [String] -> m Opt
withOptions :: Opt -> OptM a -> a
withOptionsT :: Opt -> OptT m a -> m a
getArgString :: IO (String, String)
outputName :: [Char]
type OptM = OptT Identity
data OptT m a
class Monad m => OptionMonad m where getOptions = return options
getOptions :: OptionMonad m => m Opt
flagOpt :: OptionMonad m => Flag -> m Bool
instance [overlap ok] Eq Mode
instance [overlap ok] Eq StopCondition
instance [overlap ok] MonadIO m => MonadIO (OptT m)
instance [overlap ok] Monad m => Monad (OptT m)
instance [overlap ok] Functor m => Functor (OptT m)
instance [overlap ok] MonadTrans OptT
instance [overlap ok] Monad m => OptionMonad (OptT m)
instance [overlap ok] OptionMonad Identity

module Doc.DocLike
class TextLike a where char x = text [x] empty = text ""
empty :: TextLike a => a
text :: TextLike a => String -> a
char :: TextLike a => Char -> a
class TextLike a => DocLike a where hcat [] = empty hcat xs = foldr1 (<>) xs hsep [] = empty hsep xs = foldr1 (<+>) xs vcat [] = empty vcat xs = foldr1 (\ x y -> x <> char '\n' <> y) xs x <+> y = x <> char ' ' <> y x <$> y = x <> char '\n' <> y encloseSep l r s ds = enclose l r (hcat $ punctuate s ds) enclose l r x = l <> x <> r list = encloseSep lbracket rbracket comma tupled = encloseSep lparen rparen comma semiBraces = encloseSep lbrace rbrace semi
(<>) :: DocLike a => a -> a -> a
(<+>) :: DocLike a => a -> a -> a
(<$>) :: DocLike a => a -> a -> a
hsep :: DocLike a => [a] -> a
hcat :: DocLike a => [a] -> a
vcat :: DocLike a => [a] -> a
tupled :: DocLike a => [a] -> a
list :: DocLike a => [a] -> a
semiBraces :: DocLike a => [a] -> a
enclose :: DocLike a => a -> a -> a -> a
encloseSep :: DocLike a => a -> a -> a -> [a] -> a
tshow :: (Show a, DocLike b) => a -> b
lparen :: TextLike a => a
equals :: TextLike a => a
backslash :: TextLike a => a
dot :: TextLike a => a
space :: TextLike a => a
comma :: TextLike a => a
colon :: TextLike a => a
semi :: TextLike a => a
dquote :: TextLike a => a
squote :: TextLike a => a
rbracket :: TextLike a => a
lbracket :: TextLike a => a
rbrace :: TextLike a => a
lbrace :: TextLike a => a
rangle :: TextLike a => a
langle :: TextLike a => a
rparen :: TextLike a => a
squotes :: DocLike a => a -> a
dquotes :: DocLike a => a -> a
parens :: DocLike a => a -> a
braces :: DocLike a => a -> a
brackets :: DocLike a => a -> a
angles :: DocLike a => a -> a
punctuate :: DocLike a => a -> [a] -> [a]
instance [overlap ok] DocLike Doc
instance [overlap ok] TextLike Doc
instance [overlap ok] (DocLike a, Monad m, TextLike (m a)) => DocLike (m a)
instance [overlap ok] (TextLike a, Monad m) => TextLike (m a)
instance [overlap ok] DocLike ShowS
instance [overlap ok] TextLike ShowS
instance [overlap ok] DocLike String
instance [overlap ok] TextLike Char
instance [overlap ok] TextLike String


-- | A Pretty printing class using multiparameter type classes for maximal
--   generality with some useful instances.
--   
--   the pprinted type comes as the last argument so newtype deriving can
--   be used in more places.
module Doc.PPrint
data Assoc
AssocLeft :: Assoc
AssocRight :: Assoc
AssocNone :: Assoc
class DocLike d => PPrint d a where pprintAssoc _ _ a = pprint a pprint a = pprintAssoc AssocNone (- 1) a pplist xs = brackets (hcat (punctuate comma (map pprint xs)))
pprint :: PPrint d a => a -> d
pprintAssoc :: PPrint d a => Assoc -> Int -> a -> d
pplist :: PPrint d a => [a] -> d
pprintParen :: PPrint d a => a -> d
pprintPrec :: PPrint d a => Int -> a -> d
checkAssoc :: (Ord a1, DocLike a) => Assoc -> a1 -> Assoc -> a1 -> a -> a
checkAssocApp :: (Num a1, Ord a1, DocLike a) => Assoc -> a1 -> a -> a
pprintBinary :: (PPrint a a1, PPrint a a2) => Assoc -> Int -> Assoc -> Int -> a1 -> a -> a2 -> a
instance [overlap ok] Eq Assoc
instance [overlap ok] Ord Assoc
instance [overlap ok] Show Assoc
instance [overlap ok] (PPrint d a, PPrint d b) => PPrint d (Map a b)
instance [overlap ok] (PPrint d a, PPrint d b, PPrint d c) => PPrint d (a, b, c)
instance [overlap ok] (PPrint d a, PPrint d b) => PPrint d (Either a b)
instance [overlap ok] (PPrint d a, PPrint d b) => PPrint d (a, b)
instance [overlap ok] DocLike d => PPrint d ()
instance [overlap ok] DocLike d => PPrint d Double
instance [overlap ok] DocLike d => PPrint d Float
instance [overlap ok] DocLike d => PPrint d Int
instance [overlap ok] DocLike d => PPrint d Integer
instance [overlap ok] DocLike d => PPrint d Char
instance [overlap ok] PPrint d a => PPrint d [a]


-- | Modification od Daan Leijens pretty printer. main changes are use of
--   Doc.DocLike framework and the addition of out-of-band data for html
--   tags or ansi escape codes
module Doc.Pretty
data Doc
putDoc :: Doc -> IO ()
hPutDoc :: Handle -> Doc -> IO ()
putDocM :: Monad m => (String -> m ()) -> Doc -> m ()
putDocMLn :: Monad m => (String -> m ()) -> Doc -> m ()
(</>) :: Doc -> Doc -> Doc
(<//>) :: Doc -> Doc -> Doc
(<$$>) :: Doc -> Doc -> Doc
sep :: [Doc] -> Doc
fillSep :: [Doc] -> Doc
hsep :: DocLike a => [a] -> a
vsep :: [Doc] -> Doc
cat :: [Doc] -> Doc
fillCat :: [Doc] -> Doc
hcat :: DocLike a => [a] -> a
vcat :: DocLike a => [a] -> a
align :: Doc -> Doc
hang :: Int -> Doc -> Doc
indent :: Int -> Doc -> Doc
fill :: Int -> Doc -> Doc
fillBreak :: Int -> Doc -> Doc
errorDoc :: Doc -> a
failDoc :: Monad m => Doc -> m a
softline :: Doc
softbreak :: Doc
line :: Doc
linebreak :: Doc
nest :: Int -> Doc -> Doc
group :: Doc -> Doc
column :: (Int -> Doc) -> Doc
nesting :: (Int -> Doc) -> Doc
width :: Doc -> (Int -> Doc) -> Doc
data SimpleDoc
SEmpty :: SimpleDoc
SChar :: Char -> SimpleDoc -> SimpleDoc
SText :: !Int -> String -> SimpleDoc -> SimpleDoc
SLine :: !Int -> SimpleDoc -> SimpleDoc
renderPretty :: Float -> Int -> Doc -> SimpleDoc
renderCompact :: Doc -> SimpleDoc
displayS :: SimpleDoc -> ShowS
displayIO :: Handle -> SimpleDoc -> IO ()
displayM :: Monad m => (String -> m ()) -> SimpleDoc -> m ()
textProc :: (Char -> String) -> String -> Doc

-- | out of band data. This text will appear in the pretty printed output
--   but won't count towards formatting, as far as pretty printing is
--   concerned, it is of length 0.
oob :: String -> Doc
instance [overlap ok] Show Doc
instance [overlap ok] DocLike Doc
instance [overlap ok] TextLike Doc
instance [overlap ok] Monoid Doc

module Support.Unparse
data Unparse a
data Unparsable a
Unparsable :: (a -> a) -> (a -> a -> a) -> Unparsable a
unparseGroup :: Unparsable a -> a -> a
unparseCat :: Unparsable a -> a -> a -> a
unparse :: DocLike a => Unparse a -> a
unparse' :: Unparsable a -> Unparse a -> a
data Side
R :: Side
L :: Side
N :: Side
atom :: a -> Unparse a
atomize :: Unparse a -> Unparse a
bop :: (Side, Int) -> a -> Unparse a -> Unparse a -> Unparse a
pop :: a -> Unparse a -> Unparse a
fixitize :: (Side, Int) -> Unparse a -> Unparse a
instance [overlap ok] Eq Side

module Doc.Attr
data Attr d
Attr :: (d -> d) -> (String -> d -> d) -> Attr d
attrBold :: Attr d -> d -> d
attrColor :: Attr d -> String -> d -> d
attrEmpty :: Attr d
ansi :: DocLike d => (String -> d) -> Attr d
html :: DocLike d => (String -> d) -> Attr d


-- | A variety of useful constant documents representing many unicode
--   characters.
module Doc.Chars
ulCorner :: TextLike a => a
sqcparen :: TextLike a => a
sqoparen :: TextLike a => a
or :: TextLike a => a
and :: TextLike a => a
notElem :: TextLike a => a
elem :: TextLike a => a
star :: TextLike a => a
lAmbda :: TextLike a => a
pI :: TextLike a => a
top :: TextLike a => a
bottom :: TextLike a => a
bot :: TextLike a => a
box :: TextLike a => a
exists :: TextLike a => a
forall :: TextLike a => a
lambda :: TextLike a => a
beta :: TextLike a => a
alpha :: TextLike a => a
coloncolon :: TextLike a => a
sterling :: TextLike a => a
nEqual :: TextLike a => a
pi :: TextLike a => a
gEqual :: TextLike a => a
lEqual :: TextLike a => a
s7 :: TextLike a => a
s3 :: TextLike a => a
block :: TextLike a => a
lantern :: TextLike a => a
board :: TextLike a => a
uArrow :: TextLike a => a
dArrow :: TextLike a => a
rArrow :: TextLike a => a
lArrow :: TextLike a => a
bullet :: TextLike a => a
plMinus :: TextLike a => a
degree :: TextLike a => a
ckBoard :: TextLike a => a
diamond :: TextLike a => a
s9 :: TextLike a => a
s1 :: TextLike a => a
plus :: TextLike a => a
vLine :: TextLike a => a
hLine :: TextLike a => a
tTee :: TextLike a => a
bTee :: TextLike a => a
lTee :: TextLike a => a
rTee :: TextLike a => a
lrCorner :: TextLike a => a
urCorner :: TextLike a => a
llCorner :: TextLike a => a

module Stats
data Stats
new :: IO Stats
tick :: ToAtom a => Stats -> a -> IO ()
setPrintStats :: Bool -> IO ()
ticks :: ToAtom a => Stats -> Int -> a -> IO ()
theStats :: Stats
isEmpty :: Stats -> IO Bool
null :: Stat -> Bool
print :: [Char] -> Stats -> IO ()
clear :: Stats -> IO ()
combine :: Stats -> Stats -> IO ()
printStat :: [Char] -> Stat -> IO ()
printLStat :: Int -> [Char] -> Stat -> IO ()
data Stat
singleton :: ToAtom a => a -> Stat
singleStat :: ToAtom a => Int -> a -> Stat
prependStat :: String -> Stat -> Stat
class Monad m => MonadStats m
mticks' :: MonadStats m => Int -> Atom -> m ()
mtickStat :: MonadStats m => Stat -> m ()
data StatT m a
data StatM a
mtick :: (ToAtom a, MonadStats m) => a -> m ()
mtick' :: MonadStats m => Atom -> m ()
mticks :: (ToAtom a, MonadStats m) => Int -> a -> m ()
runStatT :: Monad m => StatT m a -> m (a, Stat)
runStatIO :: MonadIO m => Stats -> StatT m a -> m a
runStatM :: StatM a -> (a, Stat)
tickStat :: Stats -> Stat -> IO ()
readStat :: Stats -> IO Stat
instance [overlap ok] Eq Stat
instance [overlap ok] Ord Stat
instance [overlap ok] Monoid Stat
instance [overlap ok] MonadIO m => MonadIO (StatT m)
instance [overlap ok] Functor m => Functor (StatT m)
instance [overlap ok] MonadFix m => MonadFix (StatT m)
instance [overlap ok] MonadTrans StatT
instance [overlap ok] Monad m => Monad (StatT m)
instance [overlap ok] MonadStats IO
instance [overlap ok] Monad m => MonadStats (StatT m)
instance [overlap ok] (Monad m, Monad (t m), MonadTrans t, MonadStats m) => MonadStats (t m)
instance [overlap ok] MonadReader r m => MonadReader r (StatT m)
instance [overlap ok] MonadStats Identity
instance [overlap ok] MonadStats StatM
instance [overlap ok] Monad StatM
instance [overlap ok] Functor StatM

module Fixer.VMap

-- | General data type for finding the fixpoint of a general tree-like
--   structure.
data VMap p n
data Proxy p
Proxy :: p -> Proxy p
DepthExceeded :: Proxy p
vmapSingleton :: (Ord p, Ord n) => n -> VMap p n
vmapArgSingleton :: (Ord p, Ord n, Show p, Show n) => n -> Int -> VMap p n -> VMap p n
vmapArg :: (Ord p, Ord n, Show p, Show n) => n -> Int -> VMap p n -> VMap p n
vmapValue :: (Show p, Show n, Ord p, Ord n) => n -> [VMap p n] -> VMap p n
vmapMember :: Ord n => n -> VMap p n -> Bool
vmapProxyIndirect :: (Show p, Show n, Ord p, Ord n, Fixable (VMap p n)) => Int -> VMap p n -> VMap p n
vmapPlaceholder :: (Show p, Show n, Ord p, Ord n) => p -> VMap p n
vmapDropArgs :: Ord n => VMap p n -> VMap p n
vmapHeads :: Monad m => VMap p n -> m [n]
instance [overlap ok] Typeable1 Proxy
instance [overlap ok] Typeable2 VMap
instance [overlap ok] Eq p => Eq (Proxy p)
instance [overlap ok] Ord p => Ord (Proxy p)
instance [overlap ok] (Show p, Show n, Ord p, Ord n) => Monoid (VMap p n)
instance [overlap ok] (Show p, Show n, Ord p, Ord n) => Fixable (VMap p n)
instance [overlap ok] (Ord p, Ord n, Show p, Show n) => Show (VMap p n)
instance [overlap ok] Show p => Show (Proxy p)

module Cmm.Number
newtype Number
Number :: Rational -> Number
toIntegral :: (Integral i, Monad m) => Number -> m i
instance [overlap ok] Num Number
instance [overlap ok] Eq Number
instance [overlap ok] Ord Number
instance [overlap ok] Binary Number
instance [overlap ok] Real Number
instance [overlap ok] Fractional Number
instance [overlap ok] RealFrac Number
instance [overlap ok] Enum Number
instance [overlap ok] Show Number
instance [overlap ok] Integral Number

module Cmm.OpEval
class Expression t e | e -> t where toConstant _ = Nothing fromBinOp _ = Nothing fromUnOp _ = Nothing equalsExpression _ _ = False
toConstant :: Expression t e => e -> Maybe (Number, t)
toExpression :: Expression t e => Number -> t -> e
toBool :: Expression t e => Bool -> e
createBinOp :: Expression t e => BinOp -> Ty -> Ty -> Ty -> e -> e -> t -> e
createUnOp :: Expression t e => UnOp -> Ty -> Ty -> e -> t -> e
fromUnOp :: Expression t e => e -> Maybe (UnOp, Ty, Ty, e, t)
fromBinOp :: Expression t e => e -> Maybe (BinOp, Ty, Ty, Ty, e, e, t)
caseEquals :: Expression t e => e -> (Number, t) -> e -> e -> e
equalsExpression :: Expression t e => e -> e -> Bool
convOp :: ConvOp -> Ty -> Ty -> Maybe ConvOp
convNumber :: ConvOp -> Ty -> Ty -> Number -> Number
convCombine :: Ty -> ConvOp -> Ty -> ConvOp -> Ty -> Maybe ConvOp
binOp :: Expression t e => BinOp -> Ty -> Ty -> Ty -> e -> e -> t -> Maybe e
binOp' :: Expression t e => BinOp -> Ty -> Ty -> Ty -> e -> e -> t -> e
unOp :: Expression t e => UnOp -> Ty -> Ty -> e -> t -> Maybe e

module C.Generate
class Annotate e
annotate :: Annotate e => String -> e -> e
data Structure
Structure :: Name -> [(Name, Type)] -> Bool -> Bool -> Bool -> Structure
structureName :: Structure -> Name
structureFields :: Structure -> [(Name, Type)]

-- | emit a macro that declares a discriminator when needed
structureNeedsDiscriminator :: Structure -> Bool

-- | the first field must appear first in the on memory layout, don't move
--   it.
structureHasDiscriminator :: Structure -> Bool

-- | this structure needs to be aligned to a pointer boundry, even if it
--   woudn't be otherwise.
structureAligned :: Structure -> Bool
(=*) :: (ToExpression x, ToExpression y) => x -> y -> Statement
(&) :: (ToStatement a, ToStatement b) => a -> b -> Statement
(*#) :: (ToExpression a, ToExpression a1) => a -> a1 -> Expression
(+#) :: (ToExpression a, ToExpression a1) => a -> a1 -> Expression
class ToExpression a
toExpression :: ToExpression a => a -> Expression
class ToStatement a
toStatement :: ToStatement a => a -> Statement
eq :: (ToExpression x, ToExpression y) => x -> y -> Expression
basicStructure :: Structure
anonStructType :: [Type] -> Type
basicType :: String -> Type

-- | a basic type the garbage collector might want to follow, guarenteed to
--   be the size of a pointer.
basicGCType :: String -> Type
cast :: Type -> Expression -> Expression
noAssign :: Expression -> Expression
cif :: Expression -> Statement -> Statement -> Statement
constant :: Constant -> Expression
creturn :: Expression -> Statement
dereference :: Expression -> Expression
reference :: Expression -> Expression
class Draw d where pdraw = draw err s = error s
err :: Draw d => String -> d
drawG :: Draw d => d -> Doc
emptyExpression :: Expression
enum :: Name -> Constant
data Expression
data Constant
expressionRaw :: String -> Expression
statementOOB :: Statement -> Statement
indexArray :: Expression -> Expression -> Expression
function :: Name -> Type -> [(Name, Type)] -> [FunctionOpts] -> Statement -> Function
data Function
functionCall :: Name -> [Expression] -> Expression
indirectFunctionCall :: Expression -> [Expression] -> Expression
data FunctionOpts
Public :: FunctionOpts
Attribute :: String -> FunctionOpts
generateC :: [Function] -> [Structure] -> (Doc, Doc)
goto :: Name -> Statement
subBlock :: Statement -> Statement
isEmptyExpression :: Expression -> Bool
label :: Name -> Statement
localVariable :: Type -> Name -> Expression
name :: String -> Name
data Name
newVar :: UniqueProducer m => Type -> m Expression
newDeclVar :: UniqueProducer m => Type -> m (Statement, Expression)
newAssignVar :: (Monad m, Draw d) => d -> Name -> Expression -> m Statement
newTmpVar :: (UniqueProducer m, Draw d) => d -> Expression -> m (Statement, Expression)
forLoop :: Expression -> Expression -> Expression -> Statement -> Statement
nullPtr :: Expression
number :: Integer -> Constant
floating :: Double -> Constant
operator :: (ToExpression a, ToExpression b) => String -> a -> b -> Expression
project :: Name -> Expression -> Expression
project' :: Name -> Expression -> Expression
projectAnon :: Int -> Expression -> Expression
ptrType :: Type -> Type
funPtrType :: Type -> [Type] -> Type
renderG :: Draw d => d -> String
sizeof :: Type -> Expression
data Statement
string :: String -> Expression
structAnon :: [(Expression, Type)] -> Expression
structType :: Name -> Type
switch' :: Expression -> [(Maybe Constant, Statement)] -> Statement
character :: Char -> Constant
toName :: [Char] -> Name
data Type
uoperator :: String -> Expression -> Expression
variable :: Name -> Expression
voidType :: Type
voidStarType :: Type
instance [overlap ok] Eq Name
instance [overlap ok] Ord Name
instance [overlap ok] Eq Type
instance [overlap ok] Ord Type
instance [overlap ok] Monad G
instance [overlap ok] MonadWriter [(Name, Type)] G
instance [overlap ok] MonadState (Int, Map [Type] Name) G
instance [overlap ok] MonadReader Env G
instance [overlap ok] MonadFix G
instance [overlap ok] Eq FunctionOpts
instance [overlap ok] (ToExpression a, ToExpression b) => ToExpression (a, b)
instance [overlap ok] ToExpression Bool
instance [overlap ok] ToExpression Integer
instance [overlap ok] ToExpression Int
instance [overlap ok] ToExpression Char
instance [overlap ok] ToExpression Name
instance [overlap ok] ToExpression Constant
instance [overlap ok] ToExpression a => ToStatement a
instance [overlap ok] ToExpression Expression
instance [overlap ok] ToStatement Expression
instance [overlap ok] ToStatement Statement
instance [overlap ok] Show Expression
instance [overlap ok] Annotate Statement
instance [overlap ok] Monoid Statement
instance [overlap ok] Draw Type
instance [overlap ok] Draw Constant
instance [overlap ok] Draw Name
instance [overlap ok] Draw Expression
instance [overlap ok] Draw E
instance [overlap ok] Draw Stmt
instance [overlap ok] Draw Statement
instance [overlap ok] Show Name

module C.Prims
data CallConv
CCall :: CallConv
StdCall :: CallConv
CApi :: CallConv
Primitive :: CallConv
DotNet :: CallConv
data Safety
Safe :: Safety
Unsafe :: Safety
JhcContext :: Safety
newtype ExtType
ExtType :: PackedString -> ExtType
newtype Requires
Requires :: (Set (CallConv, PackedString)) -> Requires
data DotNetPrim
DotNetField :: DotNetPrim
DotNetCtor :: DotNetPrim
DotNetMethod :: DotNetPrim
primReqs :: Prim -> Requires
data Prim
PrimPrim :: Atom -> Prim
CConst :: Requires -> !PackedString -> Prim
primRequires :: Prim -> Requires
primConst :: Prim -> !PackedString
Func :: Requires -> !PackedString -> [ExtType] -> ExtType -> [ExtType] -> Safety -> Prim
primRequires :: Prim -> Requires
funcName :: Prim -> !PackedString
primArgTypes :: Prim -> [ExtType]
primRetType :: Prim -> ExtType
primRetArgs :: Prim -> [ExtType]
primSafety :: Prim -> Safety
IFunc :: Requires -> [ExtType] -> ExtType -> Prim
primRequires :: Prim -> Requires
primArgTypes :: Prim -> [ExtType]
primRetType :: Prim -> ExtType
AddrOf :: Requires -> !PackedString -> Prim
primRequires :: Prim -> Requires
primConst :: Prim -> !PackedString
Peek :: Ty -> Prim
primArgTy :: Prim -> Ty
Poke :: Ty -> Prim
primArgTy :: Prim -> Ty
PrimTypeInfo :: Ty -> Ty -> !PrimTypeInfo -> Prim
primArgTy :: Prim -> Ty
primRetTy :: Prim -> Ty
primTypeInfo :: Prim -> !PrimTypeInfo
PrimString :: !PackedString -> Prim
PrimDotNet :: !Bool -> !DotNetPrim -> !Bool -> !PackedString -> !PackedString -> Prim
primStatic :: Prim -> !Bool
primDotNet :: Prim -> !DotNetPrim
primIOLike :: Prim -> !Bool
primAssembly :: Prim -> !PackedString
primDotNetName :: Prim -> !PackedString
Op :: Op Ty -> Ty -> Prim
primCOp :: Prim -> Op Ty
primRetTy :: Prim -> Ty
data PrimTypeInfo
PrimSizeOf :: PrimTypeInfo
PrimMaxBound :: PrimTypeInfo
PrimMinBound :: PrimTypeInfo
PrimAlignmentOf :: PrimTypeInfo
PrimUMaxBound :: PrimTypeInfo
primStaticTypeInfo :: Ty -> PrimTypeInfo -> Maybe Integer

-- | These primitives may safely be duplicated without affecting
--   performance or correctness too adversly. either because they are cheap
--   to begin with, or will be recombined in a later pass.
primIsCheap :: Prim -> Bool

-- | whether a primitive represents a constant expression (assuming all its
--   arguments are constant) TODO needs grin support
primIsConstant :: Prim -> Bool

-- | whether a primitive can be eagarly evaluated. TODO needs grin support
primEagerSafe :: Prim -> Bool
primPrim :: ToAtom a => a -> Prim
parseDotNetFFI :: Monad m => String -> m Prim
instance [overlap ok] Binary PrimTypeInfo
instance [overlap ok] Binary Prim
instance [overlap ok] Binary DotNetPrim
instance [overlap ok] Binary Safety
instance [overlap ok] Typeable DotNetPrim
instance [overlap ok] Typeable PrimTypeInfo
instance [overlap ok] Typeable Prim
instance [overlap ok] Eq Safety
instance [overlap ok] Ord Safety
instance [overlap ok] Show Safety
instance [overlap ok] Binary ExtType
instance [overlap ok] IsString ExtType
instance [overlap ok] Eq ExtType
instance [overlap ok] Ord ExtType
instance [overlap ok] Eq Requires
instance [overlap ok] Ord Requires
instance [overlap ok] Monoid Requires
instance [overlap ok] Binary Requires
instance [overlap ok] Eq DotNetPrim
instance [overlap ok] Ord DotNetPrim
instance [overlap ok] Show DotNetPrim
instance [overlap ok] Eq PrimTypeInfo
instance [overlap ok] Ord PrimTypeInfo
instance [overlap ok] Show PrimTypeInfo
instance [overlap ok] Eq Prim
instance [overlap ok] Ord Prim
instance [overlap ok] Show Prim
instance [overlap ok] (DocLike d, Show v) => PPrint d (Op v)
instance [overlap ok] DocLike d => PPrint d Ty
instance [overlap ok] DocLike d => PPrint d Prim
instance [overlap ok] DocLike d => PPrint d ExtType
instance [overlap ok] Show Requires
instance [overlap ok] Show ExtType
instance [overlap ok] Binary CallConv
instance [overlap ok] Eq CallConv
instance [overlap ok] Ord CallConv
instance [overlap ok] Show CallConv

module C.FFI
data CallConv
CCall :: CallConv
StdCall :: CallConv
CApi :: CallConv
Primitive :: CallConv
DotNet :: CallConv
data Safety
Safe :: Safety
Unsafe :: Safety
JhcContext :: Safety
data FfiType
Import :: CName -> Requires -> FfiType
ImportAddr :: CName -> Requires -> FfiType
Wrapper :: FfiType
Dynamic :: FfiType
data FfiExport
FfiExport :: CName -> Safety -> CallConv -> [ExtType] -> ExtType -> FfiExport
ffiExportCName :: FfiExport -> CName
ffiExportSafety :: FfiExport -> Safety
ffiExportCallConv :: FfiExport -> CallConv
ffiExportArgTypes :: FfiExport -> [ExtType]
ffiExportRetType :: FfiExport -> ExtType
data FfiSpec
FfiSpec :: FfiType -> Safety -> CallConv -> FfiSpec
newtype Requires
Requires :: (Set (CallConv, PackedString)) -> Requires
instance [overlap ok] Binary FfiExport
instance [overlap ok] Typeable FfiExport
instance [overlap ok] Eq FfiType
instance [overlap ok] Ord FfiType
instance [overlap ok] Show FfiType
instance [overlap ok] Eq FfiSpec
instance [overlap ok] Ord FfiSpec
instance [overlap ok] Show FfiSpec
instance [overlap ok] Eq FfiExport
instance [overlap ok] Ord FfiExport
instance [overlap ok] Show FfiExport

module Grin.Grin
data Callable
Continuation :: Callable
Function :: Callable
Closure :: Callable
LocalFunction :: Callable
Primitive' :: Callable
data Exp

-- | Sequencing - the same as &gt;&gt;= for monads.
(:>>=) :: Exp -> Lam -> Exp
BaseOp :: BaseOp -> [Val] -> Exp
expBaseOp :: Exp -> BaseOp
expArgs :: Exp -> [Val]

-- | Application of functions and builtins
App :: Atom -> [Val] -> [Ty] -> Exp
expFunction :: Exp -> Atom
expArgs :: Exp -> [Val]
expType :: Exp -> [Ty]

-- | Primitive operation
Prim :: Prim -> [Val] -> [Ty] -> Exp
expPrimitive :: Exp -> Prim
expArgs :: Exp -> [Val]
expType :: Exp -> [Ty]

-- | Case statement
Case :: Val -> [Lam] -> Exp
expValue :: Exp -> Val
expAlts :: Exp -> [Lam]

-- | Return a value
Return :: [Val] -> Exp

-- | add some new variables to the GC roots for a subcomputation
expValues :: Exp -> [Val]

-- | Abort with an error message, non recoverably.
Error :: String -> [Ty] -> Exp
expError :: Exp -> String
expType :: Exp -> [Ty]

-- | Call or jump to a callable
Call :: Val -> [Val] -> [Ty] -> Bool -> FuncProps -> Info -> Exp
expValue :: Exp -> Val
expArgs :: Exp -> [Val]
expType :: Exp -> [Ty]

-- | Jump is equivalent to a call except it deallocates the region it
--   resides in before transfering control
expJump :: Exp -> Bool
expFuncProps :: Exp -> FuncProps
expInfo :: Exp -> Info

-- | create a new region and pass it to its argument
NewRegion :: Lam -> Info -> Exp

-- | the computation that is passed the newly created computation
expLam :: Exp -> Lam
expInfo :: Exp -> Info

-- | allocate space for a number of values in the given region
Alloc :: Val -> Val -> Val -> Info -> Exp
expValue :: Exp -> Val
expCount :: Exp -> Val
expRegion :: Exp -> Val
expInfo :: Exp -> Info

-- | A let of local functions
Let :: [FuncDef] -> Exp -> (Set Atom, Set Atom) -> Bool -> Set Atom -> Info -> Exp
expDefs :: Exp -> [FuncDef]
expBody :: Exp -> Exp

-- | cache
expFuncCalls :: Exp -> (Set Atom, Set Atom)

-- | cache, True = definitely normal, False = maybe normal
expIsNormal :: Exp -> Bool

-- | cache, a superset of functions called in non-tail call position.
expNonNormal :: Exp -> Set Atom
expInfo :: Exp -> Info

-- | create a closure
MkClosure :: Val -> [Val] -> Val -> [Ty] -> Info -> Exp
expValue :: Exp -> Val
expArgs :: Exp -> [Val]
expRegion :: Exp -> Val
expType :: Exp -> [Ty]
expInfo :: Exp -> Info

-- | Make a continuation, always allocated on region encompasing expLam
MkCont :: Lam -> Lam -> Info -> Exp

-- | the continuation routine
expCont :: Exp -> Lam

-- | the computation that is passed the newly created computation
expLam :: Exp -> Lam
expInfo :: Exp -> Info
GcRoots :: [Val] -> Exp -> Exp

-- | add some new variables to the GC roots for a subcomputation
expValues :: Exp -> [Val]
expBody :: Exp -> Exp
data FuncDef
FuncDef :: Atom -> Lam -> Val -> FuncProps -> FuncDef
funcDefName :: FuncDef -> Atom
funcDefBody :: FuncDef -> Lam
funcDefCall :: FuncDef -> Val
funcDefProps :: FuncDef -> FuncProps
data FuncProps
FuncProps :: Info -> Set Var -> Set Tag -> ([Ty], [Ty]) -> Perhaps -> Perhaps -> Perhaps -> Perhaps -> Perhaps -> FuncProps
funcInfo :: FuncProps -> Info
funcFreeVars :: FuncProps -> Set Var
funcTags :: FuncProps -> Set Tag
funcType :: FuncProps -> ([Ty], [Ty])

-- | function quits the program
funcExits :: FuncProps -> Perhaps

-- | function cuts to a value
funcCuts :: FuncProps -> Perhaps

-- | function allocates memory
funcAllocs :: FuncProps -> Perhaps

-- | function allocates memory and stores or returns it
funcCreates :: FuncProps -> Perhaps

-- | function may loop
funcLoops :: FuncProps -> Perhaps
data Grin
Grin :: GMap Atom FfiExport -> !Phase -> TyEnv -> [FuncDef] -> Set Atom -> Set Atom -> !Stat -> [(Var, Val)] -> Grin
grinEntryPoints :: Grin -> GMap Atom FfiExport
grinPhase :: Grin -> !Phase
grinTypeEnv :: Grin -> TyEnv
grinFunctions :: Grin -> [FuncDef]
grinSuspFunctions :: Grin -> Set Atom
grinPartFunctions :: Grin -> Set Atom
grinStats :: Grin -> !Stat
grinCafs :: Grin -> [(Var, Val)]
data TyThunk

-- | not the thunk
TyNotThunk :: TyThunk

-- | can be applied to (possibly) an argument, and what results
TyPApp :: (Maybe Ty) -> Atom -> TyThunk

-- | can be evaluated and calls what function
TySusp :: Atom -> TyThunk
data Lam
(:->) :: [Val] -> Exp -> Lam
data Phase
PhaseInit :: Phase
PostInlineEval :: Phase
PostAeOptimize :: Phase
PostDevolve :: Phase
data BaseOp
Demote :: BaseOp
Promote :: BaseOp
Eval :: BaseOp
Apply :: [Ty] -> BaseOp
StoreNode :: !Bool -> BaseOp
Redirect :: BaseOp
Overwrite :: BaseOp
PeekVal :: BaseOp
PokeVal :: BaseOp
Consume :: BaseOp
GcTouch :: BaseOp
Coerce :: Ty -> BaseOp
GcPush :: BaseOp
NewRegister :: BaseOp
ReadRegister :: BaseOp
WriteRegister :: BaseOp
type Tag = Atom
updateFuncDefProps :: FuncDef -> FuncDef
data Ty

-- | pointer to a memory location which contains its argument
TyPtr :: Ty -> Ty

-- | a whole node
TyNode :: Ty

-- | a whole possibly indirect node
TyINode :: Ty

-- | attach an attribute to a type
TyAttr :: Ty -> Ty -> Ty

-- | boolean conjunction of types
TyAnd :: Ty -> Ty -> Ty

-- | boolean disjunction of types
TyOr :: Ty -> Ty -> Ty

-- | a basic type
TyPrim :: Ty -> Ty

-- | type of Unit
TyUnit :: Ty

-- | something call,jump, or cut-to-able
TyCall :: Callable -> [Ty] -> [Ty] -> Ty

-- | a region
TyRegion :: Ty

-- | the context for garbage collection
TyGcContext :: Ty

-- | a register contains a mutable value, the register itself cannot be
--   addressed, hence they may not be returned from functions or passed as
--   arguments.
TyRegister :: Ty -> Ty

-- | A complex version of a basic type
TyComplex :: Ty -> Ty

-- | A vector of a basic type
TyVector :: !Int -> Ty -> Ty

-- | an unknown possibly undefined type, All of these must be eliminated by
--   code generation
TyUnknown :: Ty
newtype TyEnv
TyEnv :: (GMap Atom TyTy) -> TyEnv
data TyTy
TyTy :: [Ty] -> [Ty] -> TyThunk -> Maybe [Atom] -> TyTy
tySlots :: TyTy -> [Ty]
tyReturn :: TyTy -> [Ty]
tyThunk :: TyTy -> TyThunk
tySiblings :: TyTy -> Maybe [Atom]
tyTy :: TyTy
data Val

-- | Complete node, of type TyNode
NodeC :: !Tag -> [Val] -> Val

-- | constant data, only Lit, Const and NodeC may be children. of type
--   TyINode
Const :: Val -> Val

-- | Literal
Lit :: !Number -> Ty -> Val

-- | Variable
Var :: !Var -> Ty -> Val

-- | Empty value used as placeholder
Unit :: Val

-- | Primitive value
ValPrim :: Prim -> [Val] -> Ty -> Val

-- | A pointer incremented some number of values (Index v 0) == v
Index :: Val -> Val -> Val

-- | Specific named thing. function, global, region, etc..
Item :: Atom -> Ty -> Val

-- | Unknown or unimportant value
ValUnknown :: Ty -> Val
newtype Var
V :: Int -> Var
extendTyEnv :: [FuncDef] -> TyEnv -> TyEnv
createFuncDef :: Bool -> Atom -> Lam -> FuncDef
setGrinFunctions :: [(Atom, Lam)] -> Grin -> Grin
grinFuncs :: Grin -> [(Atom, Lam)]
emptyGrin :: Grin

-- | lazy node sptr_t
tyINode :: Ty

-- | strict node wptr_t
tyDNode :: Ty
findArgs :: Monad m => TyEnv -> Atom -> m [Ty]
findArgsType :: Monad m => TyEnv -> Atom -> m ([Ty], [Ty])
findTyTy :: Monad m => TyEnv -> Atom -> m TyTy
gEval :: Val -> Exp
grinEntryPointNames :: Grin -> [Atom]
isHole :: Val -> Bool
isValUnknown :: Val -> Bool
isVar :: Val -> Bool
n0 :: Val
n1 :: Val
n2 :: Val
n3 :: Val
p0 :: Val
p1 :: Val
p2 :: Val
p3 :: Val
partialTag :: Tag -> Int -> Tag
phaseEvalInlined :: Phase -> Bool
properHole :: Ty -> Val
tagFlipFunction :: Atom -> Atom
tagHole :: Atom
tagInfo :: Atom -> TagInfo
data TagInfo
TagPApp :: !Int -> !Atom -> TagInfo
TagSusp :: !Bool -> !Atom -> TagInfo
TagDataCons :: TagInfo
TagTypeCons :: TagInfo
TagTypePApp :: !Int -> Tag -> TagInfo
TagFunc :: TagInfo
tagIsFunction :: Atom -> Bool
tagIsPartialAp :: Atom -> Bool
tagIsSuspFunction :: Atom -> Bool
tagIsTag :: Atom -> Bool
tagIsWHNF :: Atom -> Bool
tagToFunction :: Monad m => Atom -> m Atom
tagUnfunction :: Monad m => Tag -> m (Int, Tag)
v0 :: Var
v1 :: Var
v2 :: Var
v3 :: Var
lamExp :: Lam -> Exp
lamBind :: Lam -> [Val]
valIsNF :: Val -> Bool
instance [overlap ok] Eq Callable
instance [overlap ok] Ord Callable
instance [overlap ok] Show Callable
instance [overlap ok] Eq Ty
instance [overlap ok] Ord Ty
instance [overlap ok] Eq BaseOp
instance [overlap ok] Ord BaseOp
instance [overlap ok] Show BaseOp
instance [overlap ok] Eq Var
instance [overlap ok] Ord Var
instance [overlap ok] Enum Var
instance [overlap ok] Eq Val
instance [overlap ok] Ord Val
instance [overlap ok] Eq TyThunk
instance [overlap ok] Show TyThunk
instance [overlap ok] Monoid TyEnv
instance [overlap ok] Eq FuncProps
instance [overlap ok] Ord FuncProps
instance [overlap ok] Show FuncProps
instance [overlap ok] Eq Exp
instance [overlap ok] Show Exp
instance [overlap ok] Ord Exp
instance [overlap ok] Eq FuncDef
instance [overlap ok] Ord FuncDef
instance [overlap ok] Show FuncDef
instance [overlap ok] Eq Lam
instance [overlap ok] Ord Lam
instance [overlap ok] Show Lam
instance [overlap ok] Show Phase
instance [overlap ok] Eq Phase
instance [overlap ok] Ord Phase
instance [overlap ok] Enum Phase
instance [overlap ok] Monoid (GMap Var v)
instance [overlap ok] IsEmpty (GMap Var v)
instance [overlap ok] HasSize (GMap Var v)
instance [overlap ok] Collection (GMap Var v)
instance [overlap ok] Unionize (GMap Var v)
instance [overlap ok] SetLike (GMap Var v)
instance [overlap ok] MapLike (GMap Var v)
instance [overlap ok] Eq v => Eq (GMap Var v)
instance [overlap ok] Ord v => Ord (GMap Var v)
instance [overlap ok] Monoid (GSet Var)
instance [overlap ok] IsEmpty (GSet Var)
instance [overlap ok] HasSize (GSet Var)
instance [overlap ok] Collection (GSet Var)
instance [overlap ok] Unionize (GSet Var)
instance [overlap ok] SetLike (GSet Var)
instance [overlap ok] Eq (GSet Var)
instance [overlap ok] Ord (GSet Var)
instance [overlap ok] Intjection Var
instance [overlap ok] TypeNames Ty
instance [overlap ok] Show Val
instance [overlap ok] Show Ty
instance [overlap ok] Show Var
instance [overlap ok] FreeVars Exp (GSet Tag)
instance [overlap ok] FreeVars Lam (GSet Tag)
instance [overlap ok] FreeVars Val (GSet Tag)
instance [overlap ok] FreeVars Lam [Var]
instance [overlap ok] FreeVars Val [Var]
instance [overlap ok] FreeVars Exp [Var]
instance [overlap ok] FreeVars Exp (GSet Var)
instance [overlap ok] FreeVars FuncProps (GSet Tag)
instance [overlap ok] FreeVars FuncProps (GSet Var)
instance [overlap ok] FreeVars Val (GSet Var)
instance [overlap ok] FreeVars Exp (GSet Var, GSet Tag)
instance [overlap ok] FreeVars Lam (GSet Var)
instance [overlap ok] FreeVars Exp (Set Tag)
instance [overlap ok] FreeVars Lam (Set Tag)
instance [overlap ok] FreeVars Exp [Tag]
instance [overlap ok] FreeVars Val [Tag]
instance [overlap ok] FreeVars Val (Set Tag)
instance [overlap ok] FreeVars Exp (Set (Var, Ty))
instance [overlap ok] FreeVars Exp (Set Var)
instance [overlap ok] FreeVars FuncProps a => FreeVars FuncDef a
instance [overlap ok] FreeVars FuncProps (Set Tag)
instance [overlap ok] FreeVars FuncProps (Set Var)
instance [overlap ok] FreeVars Val (Set (Var, Ty))
instance [overlap ok] FreeVars Val (Set Var)
instance [overlap ok] FreeVars Exp (Set Var, Set Tag)
instance [overlap ok] FreeVars Lam (Set (Var, Ty))
instance [overlap ok] FreeVars Lam (Set Var)
instance [overlap ok] CanType Val
instance [overlap ok] CanType Exp

module Grin.HashConst
newConst :: MonadState HcHash m => Set Atom -> Val -> m (Bool, Int)
data HcHash
data HcNode
HcNode :: {-# UNPACK #-} !Atom -> [Either Val Int] -> HcNode
toList :: HcHash -> [(HcNode, Int)]
emptyHcHash :: HcHash
instance [overlap ok] Show HcNode
instance [overlap ok] Ord HcNode
instance [overlap ok] Eq HcNode
instance [overlap ok] Show HcHash

module Grin.Noodle
modifyTail :: Lam -> Exp -> Exp
mapBodyM :: Monad m => (Exp -> m Exp) -> Lam -> m Lam
mapExpVal :: Monad m => (Val -> m Val) -> Exp -> m Exp
mapValVal :: Monad m => (Val -> m Val) -> Val -> m Val
mapValVal_ :: Monad m => (Val -> m b) -> Val -> m ()
mapExpLam :: Monad m => (Lam -> m Lam) -> Exp -> m Exp
mapExpExp :: Monad m => (Exp -> m Exp) -> Exp -> m Exp
mapFBodies :: Monad m => (Exp -> m Exp) -> [FuncDef] -> m [FuncDef]
funcDefBody_uM :: Monad m => (Lam -> m Lam) -> FuncDef -> m FuncDef
grinFunctions_s :: [FuncDef] -> Grin -> Grin
isManifestNode :: Monad m => Exp -> m [Atom]

-- | Is a Val constant?
valIsConstant :: Val -> Bool
isNop :: Exp -> Bool
isOmittable :: Exp -> Bool
isErrOmittable :: Exp -> Bool
collectFuncs :: Exp -> (Set Atom, Set Atom)
grinLet :: [FuncDef] -> Exp -> Exp
updateLetProps :: Exp -> Exp
data ReturnInfo
ReturnNode :: (Maybe Atom, [Ty]) -> ReturnInfo
ReturnConst :: Val -> ReturnInfo
ReturnCalls :: Atom -> ReturnInfo
ReturnOther :: ReturnInfo
ReturnError :: ReturnInfo
getReturnInfo :: Exp -> [ReturnInfo]
mapGrinFuncsM :: Monad m => (Atom -> Lam -> m Lam) -> Grin -> m Grin
instance [overlap ok] Eq ReturnInfo
instance [overlap ok] Ord ReturnInfo
instance [overlap ok] Tickleable (Atom, Lam) FuncDef
instance [overlap ok] Tickleable Lam FuncDef
instance [overlap ok] Tickleable Lam Grin
instance [overlap ok] Tickleable Val Val
instance [overlap ok] Tickleable Val Exp
instance [overlap ok] Tickleable Exp Exp
instance [overlap ok] Tickleable Exp Lam

module Grin.Whiz

-- | magic traversal and flattening routine. whiz traverses Grin code and
--   right assosiates it as well as renaming and repeated variables along
--   the way. in addition, it provides a nice monadic traversal of the
--   flattened renamed code suitable for a wide range of grin -&gt; grin
--   transformations. basically, you may use <a>whiz</a> to perform
--   tranformations which do not require lookahead, and depend only on the
--   code that happened before. note that a case is presented after all of
--   its sub code blocks have been processed Whiz also vectorizes
--   tuple-&gt;tuple assignments, breaking them into individual assignments
--   for its components to better aid future optimizations.
whiz :: Monad m => (forall a. [Val] -> m a -> m a) -> (([Val], Exp) -> m (Maybe ([Val], Exp))) -> (Exp -> m Exp) -> WhizState -> Lam -> m (Lam, WhizState)

-- | magic traversal and flattening routine. whiz traverses Grin code and
--   right assosiates it as well as renaming and repeated variables along
--   the way. in addition, it provides a nice monadic traversal of the
--   flattened renamed code suitable for a wide range of grin -&gt; grin
--   transformations. basically, you may use <a>whiz</a> to perform
--   tranformations which do not require lookahead, and depend only on the
--   code that happened before. note that a case is presented after all of
--   its sub code blocks have been processed Whiz also vectorizes
--   tuple-&gt;tuple assignments, breaking them into individual assignments
--   for its components to better aid future optimizations. fizz is similar
--   to whiz, but processes things in 'bottom-up' order. fizz also removes
--   all statements past an Error.
fizz :: Monad m => (forall a. [Val] -> m a -> m a) -> (([Val], Exp) -> m (Maybe ([Val], Exp))) -> (Exp -> m Exp) -> WhizState -> Lam -> m (Lam, WhizState)
type WhizState = Either (Set Int) Int
whizState :: WhizState
normalizeGrin :: Grin -> Grin
normalizeGrin' :: Grin -> Grin
applySubstE :: (Monad m, MapLike m1, ~ * (Key m1) Var, ~ * (Value m1) Val) => m1 -> Exp -> m Exp
applySubst :: (Monad m1, MapLike m, ~ * (Key m) Var, ~ * (Value m) Val) => m -> Val -> m1 Val
whizExps :: Monad m => (Exp -> m Exp) -> Lam -> m Lam

module Grin.DeadCode

-- | Remove dead code from Grin.
deadCode :: Stats -> [Atom] -> Grin -> IO Grin

module Grin.Devolve
twiddleGrin :: Grin -> Grin
devolveTransform :: TransformParms Grin
instance [overlap ok] Monad R
instance [overlap ok] Functor R
instance [overlap ok] MonadReader Env R
instance [overlap ok] MonadWriter (Set Var) R
instance [overlap ok] Twiddle FuncDef
instance [overlap ok] Twiddle Lam
instance [overlap ok] Twiddle a => Twiddle [a]
instance [overlap ok] Twiddle Val
instance [overlap ok] Twiddle Exp

module Grin.EvalInline
createEvalApply :: Grin -> IO Grin

module Grin.NodeAnalyze
nodeAnalyze :: Grin -> IO Grin
instance [overlap ok] Eq NodeType
instance [overlap ok] Ord NodeType
instance [overlap ok] Show NodeType
instance [overlap ok] Eq N
instance [overlap ok] Eq Va
instance [overlap ok] Ord Va
instance [overlap ok] Eq V
instance [overlap ok] Ord V
instance [overlap ok] Monad M
instance [overlap ok] Functor M
instance [overlap ok] MonadWriter (C N V) M
instance [overlap ok] Show V
instance [overlap ok] NodeLike (Either V b)
instance [overlap ok] NodeLike V
instance [overlap ok] NodeLike Val
instance [overlap ok] NodeLike Ty
instance [overlap ok] Fixable N
instance [overlap ok] Fixable NodeType
instance [overlap ok] Show N

module Grin.Optimize

-- | grinPush pushes the definitions of variables as far inward as they can
--   go so peephole optimizations have a better chance of firing. when the
--   order of definitons doesn't matter, it uses heuristics to decide which
--   one to push to allow the most peephole optimizations.
grinPush :: Stats -> Lam -> IO Lam
grinSpeculate :: Grin -> IO Grin
instance [overlap ok] Show PExp
instance [overlap ok] Eq PExp

module Grin.SSimplify
simplify :: Grin -> IO Grin
explicitRecurse :: Grin -> IO Grin
instance [overlap ok] Monoid SEnv
instance [overlap ok] Monad S
instance [overlap ok] Functor S
instance [overlap ok] MonadWriter SCol S
instance [overlap ok] MonadReader SEnv S
instance [overlap ok] MonadState SState S
instance [overlap ok] Eq Unbox
instance [overlap ok] Ord Unbox
instance [overlap ok] CanType Unbox
instance [overlap ok] CanType UnboxingResult
instance [overlap ok] MonadStats S
instance [overlap ok] Monoid SCol

module Name.Name
newtype Module
Module :: Atom -> Module
data Name
type Class = Name
data NameType
TypeConstructor :: NameType
DataConstructor :: NameType
ClassName :: NameType
TypeVal :: NameType
Val :: NameType
SortName :: NameType
FieldLabel :: NameType
RawType :: NameType
UnknownType :: NameType
QuotedName :: NameType
class ToName a
toName :: ToName a => NameType -> a -> Name
fromName :: ToName a => Name -> (NameType, a)
ffiExportName :: FfiExport -> Name
fromModule :: FromAtom a => Module -> a
fromTypishHsName :: Name -> Name
fromValishHsName :: Name -> Name
getIdent :: Name -> String
getModule :: Monad m => Name -> m Module
isConstructorLike :: Name -> Bool
isTypeNamespace :: NameType -> Bool
isValNamespace :: NameType -> Bool
mainModule :: Module
preludeModule :: Module
mapName :: (Module -> Module, String -> String) -> Name -> Name
mapName' :: (Maybe Module -> Maybe Module) -> (String -> String) -> Name -> Name
nameName :: Name -> Name
nameParts :: Name -> (NameType, Maybe Module, String)
nameType :: Name -> NameType
parseName :: NameType -> String -> Name
primModule :: Module
qualifyName :: Module -> Name -> Name
setModule :: Module -> Name -> Name
quoteName :: Name -> Name
fromQuotedName :: Name -> Maybe Name
toModule :: String -> Module
toUnqualified :: Name -> Name
instance [overlap ok] Typeable Name
instance [overlap ok] Typeable Module
instance [overlap ok] Ord NameType
instance [overlap ok] Eq NameType
instance [overlap ok] Enum NameType
instance [overlap ok] Read NameType
instance [overlap ok] Show NameType
instance [overlap ok] Ord Name
instance [overlap ok] Eq Name
instance [overlap ok] Binary Name
instance [overlap ok] Data Name
instance [overlap ok] ToAtom Name
instance [overlap ok] FromAtom Name
instance [overlap ok] Eq Module
instance [overlap ok] Data Module
instance [overlap ok] ToAtom Module
instance [overlap ok] FromAtom Module
instance [overlap ok] Show Module
instance [overlap ok] Ord Module
instance [overlap ok] DocLike d => PPrint d Name
instance [overlap ok] Show Name
instance [overlap ok] ToName String
instance [overlap ok] ToName Name
instance [overlap ok] ToName (Maybe Module, String)
instance [overlap ok] ToName (Module, String)
instance [overlap ok] ToName (String, String)

module Name.Id
data Id
type IdMap = IntjectionMap Id

-- | Name monad transformer.
data IdNameT m a
type IdSet = IntjectionSet Id
anonymous :: Int -> Id

-- | some convinience anonymous ids
va1 :: Id

-- | some convinience anonymous ids
va2 :: Id

-- | some convinience anonymous ids
va3 :: Id

-- | some convinience anonymous ids
va4 :: Id

-- | some convinience anonymous ids
va5 :: Id
addBoundNamesIdMap :: Monad m => IntjectionMap Id a -> IdNameT m ()
addBoundNamesIdSet :: Monad m => IdSet -> IdNameT m ()
addNamesIdSet :: Monad m => IdSet -> IdNameT m ()
idMapToIdSet :: IdMap a -> IdSet
anonymousIds :: [Id]

-- | A occasionally useful random ethereal id
sillyId :: Id
etherealIds :: [Id]
isEtherealId :: Id -> Bool

-- | id isn't anonymous or atom-mapped
isInvalidId :: Id -> Bool
isEmptyId :: Id -> Bool
idSetToIdMap :: (Id -> a) -> IdSet -> IdMap a
mapMaybeIdMap :: (a -> Maybe b) -> IdMap a -> IdMap b
idSetFromList :: [Id] -> IdSet
idToInt :: Id -> Int
idSetFromDistinctAscList :: [Id] -> IdSet
idMapFromList :: [(Id, a)] -> IdMap a
idMapFromDistinctAscList :: [(Id, a)] -> IdMap a
idSetToList :: IdSet -> [Id]
idMapToList :: IdMap a -> [(Id, a)]
emptyId :: Id

-- | find some temporary ids that are not members of the set, useful for
--   generating a small number of local unique names.
newIds :: IdSet -> [Id]
newId :: Int -> (Id -> Bool) -> Id
mixInt :: Int -> Int -> Int
mixInt3 :: Int -> Int -> Int -> Int
toId :: Name -> Id
fromId :: Monad m => Id -> m Name
candidateIds :: Int -> [Id]

-- | Run the name monad transformer.
runIdNameT :: Monad m => IdNameT m a -> m (a, IdSet)
instance [overlap ok] Eq Id
instance [overlap ok] Ord Id
instance [overlap ok] Monad m => Monad (IdNameT m)
instance [overlap ok] MonadTrans IdNameT
instance [overlap ok] Functor m => Functor (IdNameT m)
instance [overlap ok] MonadFix m => MonadFix (IdNameT m)
instance [overlap ok] MonadPlus m => MonadPlus (IdNameT m)
instance [overlap ok] MonadIO m => MonadIO (IdNameT m)
instance [overlap ok] Binary Id
instance [overlap ok] GenName Id
instance [overlap ok] DocLike d => PPrint d Id
instance [overlap ok] FromAtom Id
instance [overlap ok] Show v => Show (IdMap v)
instance [overlap ok] Show IdSet
instance [overlap ok] Show Id
instance [overlap ok] Monad m => NameMonad Id (IdNameT m)
instance [overlap ok] MonadReader r m => MonadReader r (IdNameT m)
instance [overlap ok] Intjection Id

module Name.Prim
tc_IOErrorType :: Name
tc_IOMode :: Name
tc_Bang_ :: Name
tc_Arrow :: Name
tc_MutArray__ :: Name
tc_List :: Name
tc_Char :: Name
tc_IO :: Name
tc_ST :: Name
tc_ACIO :: Name
tc_State_ :: Name
tc_RealWorld :: Name
tc_Bool :: Name
tc_Ordering :: Name
tc_Bool_ :: Name
tc_Unit :: Name
tc_Ratio :: Name
tc_Float :: Name
tc_Double :: Name
tc_Ptr :: Name
tc_FunPtr :: Name
tc_Integer :: Name
tc_Int :: Name
tc_Bits1 :: Name
tc_Bits8 :: Name
tc_Bits16 :: Name
tc_Bits32 :: Name
tc_Bits64 :: Name
tc_Bits128 :: Name
tc_BitsPtr :: Name
tc_BitsMax :: Name
tc_Float32 :: Name
tc_Float64 :: Name
tc_Float80 :: Name
tc_Float128 :: Name
tc_Complex :: Name
tc_Addr_ :: Name
tc_FunAddr_ :: Name
tc_Char_ :: Name
dc_Boolzh :: Name
dc_Char :: Name
dc_Cons :: Name
dc_EmptyList :: Name
dc_Int :: Name
dc_Integer :: Name
dc_Ratio :: Name
dc_Unit :: Name
dc_Pair :: Name
dc_Word :: Name
dc_True :: Name
dc_False :: Name
dc_EQ :: Name
class_Eq :: Name
class_Ord :: Name
class_Enum :: Name
class_Bounded :: Name
class_Show :: Name
class_Read :: Name
class_Ix :: Name
class_Functor :: Name
class_Monad :: Name
class_Num :: Name
class_Real :: Name
class_Integral :: Name
class_Fractional :: Name
class_Floating :: Name
class_RealFrac :: Name
class_RealFloat :: Name
rt_bits8 :: Name
rt_bits16 :: Name
rt_bits32 :: Name
rt_bits64 :: Name
rt_bits128 :: Name
rt_bool :: Name
rt_float32 :: Name
rt_float64 :: Name
rt_float80 :: Name
rt_float128 :: Name
rt_bits_max_ :: Name
rt_bits_ptr_ :: Name
v_eqString :: Name
v_eqUnpackedString :: Name
v_error :: Name
v_map :: Name
v_and :: Name
v_foldr :: Name
v_foldl :: Name
v_drop :: Name
v_cat :: Name
v_compose :: Name
v_bind :: Name
v_bind_ :: Name
v_fail :: Name
v_concatMap :: Name
v_fromInteger :: Name
v_fromInt :: Name
v_sub :: Name
v_fromRational :: Name
v_negate :: Name
v_compare :: Name
v_leq :: Name
v_geq :: Name
v_lt :: Name
v_gt :: Name
v_equals :: Name
v_fromEnum :: Name
v_toEnum :: Name
v_enumFrom :: Name
v_enumFromTo :: Name
v_enumFromThenTo :: Name
v_enumFromThen :: Name
v_succ :: Name
v_pred :: Name
v_minBound :: Name
v_maxBound :: Name
v_showsPrec :: Name
v_showParen :: Name
v_showChar :: Name
v_showString :: Name
v_readsPrec :: Name
v_readParen :: Name
v_lex :: Name
v_range :: Name
v_index :: Name
v_inRange :: Name
v_runExpr :: Name
v_runRaw :: Name
v_runMain :: Name
v_runNoWrapper :: Name
v_enum_succ :: Name
v_enum_pred :: Name
v_enum_from :: Name
v_enum_fromTo :: Name
v_enum_fromThen :: Name
v_enum_fromThenTo :: Name
v_enum_toEnum :: Name
v_ix_index :: Name
v_ix_inRange :: Name
v_ix_range :: Name
s_Star :: Name
s_Hash :: Name
s_Bang :: Name
s_Tuple :: Name
s_HashHash :: Name
s_StarStar :: Name


-- | All hardcoded names in the compiler should go in here the convention
--   is v_foo for values tc_foo for type constructors dc_foo for data
--   constructors s_foo for sort names rt_foo for raw names class_foo for
--   classes
module Name.Names
nameTuple :: NameType -> Int -> Name
unboxedNameTuple :: Show a => NameType -> a -> Name
fromUnboxedNameTuple :: (Monad m, Show a) => a -> m Int
s_Quest :: Name
s_QuestQuest :: Name
s_StarBang :: Name
s_Any :: Name
u_instance :: Name
sFuncNames :: FuncNames Name
instance [overlap ok] FromTupname Name
instance [overlap ok] TypeNames Name

module Grin.Val
class FromVal a where fromUnVal x = fromVal x
fromVal :: (FromVal a, Monad m) => Val -> m a
fromUnVal :: (FromVal a, Monad m) => Val -> m a
class ToVal a where toUnVal x = toVal x
toVal :: ToVal a => a -> Val
toUnVal :: ToVal a => a -> Val
tn_2Tup :: Atom
valToList :: Monad m => Val -> m [Val]
cChar :: Atom
cWord :: Atom
cInt :: Atom
convertName :: Name -> Atom
region_heap :: Val
region_atomic_heap :: Val
region_stack :: Val
region_block :: Val
instance [overlap ok] FromVal Val
instance [overlap ok] FromVal Bool
instance [overlap ok] FromVal a => FromVal [a]
instance [overlap ok] FromVal Char
instance [overlap ok] FromVal Int
instance [overlap ok] ToVal Val
instance [overlap ok] ToVal Int
instance [overlap ok] ToVal Char
instance [overlap ok] ToVal (Val, Val)
instance [overlap ok] ToVal a => ToVal [a]
instance [overlap ok] ToVal Bool
instance [overlap ok] ConNames Val

module Grin.Show
prettyFun :: (Atom, Lam) -> Doc
prettyExp :: Doc -> Exp -> Doc
printGrin :: Grin -> IO ()
hPrintGrin :: Handle -> Grin -> IO ()
graphGrin :: Grin -> String
render :: Doc -> String
instance [overlap ok] Ord CallType
instance [overlap ok] Show CallType
instance [overlap ok] Eq CallType
instance [overlap ok] FreeVars Exp (Set (CallType, Atom))
instance [overlap ok] DocLike d => PPrint d Var
instance [overlap ok] PPrint Doc Exp
instance [overlap ok] DocLike d => PPrint d Val

module C.FromGrin2
compileGrin :: Grin -> (ByteString, Requires)
instance [overlap ok] Monad C
instance [overlap ok] UniqueProducer C
instance [overlap ok] MonadState HcHash C
instance [overlap ok] MonadWriter Written C
instance [overlap ok] MonadReader Env C
instance [overlap ok] Functor C
instance [overlap ok] ToCmmTy Ty
instance [overlap ok] Monoid Written

module Grin.Lint
lintCheckGrin :: Grin -> IO ()
typecheckGrin :: Grin -> IO ()
transformGrin :: TransformParms Grin -> Grin -> IO Grin
dumpGrin :: [Char] -> Grin -> IO ()
instance [overlap ok] Monad Tc
instance [overlap ok] MonadReader TcEnv Tc
instance [overlap ok] (DShow a, DShow b) => DShow (Either a b)
instance [overlap ok] DShow Ty
instance [overlap ok] DShow Var
instance [overlap ok] DShow Tag
instance [overlap ok] DShow String

module Grin.StorageAnalysis
storeAnalyze :: Grin -> IO Grin
instance [overlap ok] Eq T
instance [overlap ok] Show T
instance [overlap ok] Eq Vr
instance [overlap ok] Ord Vr
instance [overlap ok] Show Vr
instance [overlap ok] Fixable T

module FrontEnd.HsSyn
hsNameIdent_u :: (String -> String) -> Name -> Name
hsIdentString_u :: (t1 -> t) -> t1 -> t
type HsName = Name
data HsModule
HsModule :: Module -> SrcLoc -> (Maybe [HsExportSpec]) -> [HsImportDecl] -> [HsDecl] -> [String] -> Opt -> HsModule
hsModuleName :: HsModule -> Module
hsModuleSrcLoc :: HsModule -> SrcLoc
hsModuleExports :: HsModule -> (Maybe [HsExportSpec])
hsModuleImports :: HsModule -> [HsImportDecl]
hsModuleDecls :: HsModule -> [HsDecl]
hsModuleOptions :: HsModule -> [String]
hsModuleOpt :: HsModule -> Opt
data HsExportSpec
HsEVar :: HsName -> HsExportSpec
HsEAbs :: HsName -> HsExportSpec
HsEThingAll :: HsName -> HsExportSpec
HsEThingWith :: HsName -> [HsName] -> HsExportSpec
HsEModuleContents :: Module -> HsExportSpec
HsEQualified :: NameType -> HsExportSpec -> HsExportSpec
data HsImportDecl
HsImportDecl :: SrcLoc -> Module -> !Bool -> (Maybe Module) -> (Maybe (Bool, [HsExportSpec])) -> HsImportDecl
hsImportDeclSrcLoc :: HsImportDecl -> SrcLoc
hsImportDeclModule :: HsImportDecl -> Module
hsImportDeclQualified :: HsImportDecl -> !Bool
hsImportDeclAs :: HsImportDecl -> (Maybe Module)
hsImportDeclSpec :: HsImportDecl -> (Maybe (Bool, [HsExportSpec]))
data HsAssoc
HsAssocNone :: HsAssoc
HsAssocLeft :: HsAssoc
HsAssocRight :: HsAssoc
hsDataDecl :: HsDecl
hsNewTypeDecl :: HsDecl
data DeclType
DeclTypeData :: DeclType
DeclTypeNewtype :: DeclType
DeclTypeKind :: DeclType
data HsDecl
HsTypeFamilyDecl :: SrcLoc -> !Bool -> HsName -> [HsType] -> Maybe HsKind -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclData :: HsDecl -> !Bool
hsDeclName :: HsDecl -> HsName
hsDeclTArgs :: HsDecl -> [HsType]
hsDeclHasKind :: HsDecl -> Maybe HsKind
HsTypeDecl :: SrcLoc -> HsName -> [HsType] -> HsType -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclName :: HsDecl -> HsName
hsDeclTArgs :: HsDecl -> [HsType]
hsDeclType :: HsDecl -> HsType
HsDataDecl :: !DeclType -> SrcLoc -> HsContext -> HsName -> [Name] -> [HsConDecl] -> Maybe HsKind -> Maybe String -> [HsName] -> HsDecl
hsDeclDeclType :: HsDecl -> !DeclType
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclContext :: HsDecl -> HsContext
hsDeclName :: HsDecl -> HsName
hsDeclArgs :: HsDecl -> [Name]
hsDeclCons :: HsDecl -> [HsConDecl]
hsDeclHasKind :: HsDecl -> Maybe HsKind
hsDeclCTYPE :: HsDecl -> Maybe String
hsDeclDerives :: HsDecl -> [HsName]
HsInfixDecl :: SrcLoc -> HsAssoc -> !Int -> [HsName] -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclAssoc :: HsDecl -> HsAssoc
hsDeclInt :: HsDecl -> !Int
hsDeclNames :: HsDecl -> [HsName]
HsClassDecl :: SrcLoc -> HsClassHead -> [HsDecl] -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclClassHead :: HsDecl -> HsClassHead
hsDeclDecls :: HsDecl -> [HsDecl]
HsClassAliasDecl :: SrcLoc -> HsName -> [HsType] -> HsContext -> HsContext -> [HsDecl] -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclName :: HsDecl -> HsName
hsDeclTypeArgs :: HsDecl -> [HsType]
hsDeclContext :: HsDecl -> HsContext
hsDeclClasses :: HsDecl -> HsContext
hsDeclDecls :: HsDecl -> [HsDecl]
HsInstDecl :: SrcLoc -> HsClassHead -> [HsDecl] -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclClassHead :: HsDecl -> HsClassHead
hsDeclDecls :: HsDecl -> [HsDecl]
HsDefaultDecl :: SrcLoc -> HsType -> HsDecl
HsTypeSig :: SrcLoc -> [HsName] -> HsQualType -> HsDecl
HsFunBind :: [HsMatch] -> HsDecl
HsPatBind :: SrcLoc -> HsPat -> HsRhs -> [HsDecl] -> HsDecl
HsActionDecl :: SrcLoc -> HsPat -> HsExp -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclPat :: HsDecl -> HsPat
hsDeclExp :: HsDecl -> HsExp
HsSpaceDecl :: SrcLoc -> HsName -> HsExp -> Maybe String -> Int -> HsQualType -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclName :: HsDecl -> HsName
hsDeclExp :: HsDecl -> HsExp
hsDeclCName :: HsDecl -> Maybe String
hsDeclCount :: HsDecl -> Int
hsDeclQualType :: HsDecl -> HsQualType
HsForeignDecl :: SrcLoc -> FfiSpec -> HsName -> HsQualType -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclForeign :: HsDecl -> FfiSpec
hsDeclName :: HsDecl -> HsName
hsDeclQualType :: HsDecl -> HsQualType
HsForeignExport :: SrcLoc -> FfiExport -> HsName -> HsQualType -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclFFIExport :: HsDecl -> FfiExport
hsDeclName :: HsDecl -> HsName
hsDeclQualType :: HsDecl -> HsQualType
HsPragmaProps :: SrcLoc -> String -> [HsName] -> HsDecl
HsPragmaRules :: [HsRule] -> HsDecl
HsPragmaSpecialize :: (Module, Int) -> SrcLoc -> Bool -> HsName -> HsType -> HsDecl
hsDeclUniq :: HsDecl -> (Module, Int)
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclBool :: HsDecl -> Bool
hsDeclName :: HsDecl -> HsName
hsDeclType :: HsDecl -> HsType
HsDeclDeriving :: SrcLoc -> HsClassHead -> HsDecl
hsDeclSrcLoc :: HsDecl -> SrcLoc
hsDeclClassHead :: HsDecl -> HsClassHead
data HsRule
HsRule :: (Module, Int) -> SrcLoc -> Bool -> String -> [(HsName, Maybe HsType)] -> HsExp -> HsExp -> HsRule
hsRuleUniq :: HsRule -> (Module, Int)
hsRuleSrcLoc :: HsRule -> SrcLoc
hsRuleIsMeta :: HsRule -> Bool
hsRuleString :: HsRule -> String
hsRuleFreeVars :: HsRule -> [(HsName, Maybe HsType)]
hsRuleLeftExpr :: HsRule -> HsExp
hsRuleRightExpr :: HsRule -> HsExp
data HsPragmaExp
HsPragmaExp :: String -> [HsExp] -> HsPragmaExp
data HsMatch
HsMatch :: SrcLoc -> HsName -> [HsPat] -> HsRhs -> [HsDecl] -> HsMatch
hsMatchSrcLoc :: HsMatch -> SrcLoc
hsMatchName :: HsMatch -> HsName
hsMatchPats :: HsMatch -> [HsPat]
hsMatchRhs :: HsMatch -> HsRhs
hsMatchDecls :: HsMatch -> [HsDecl]
data HsConDecl
HsConDecl :: SrcLoc -> [HsTyVarBind] -> HsName -> [HsBangType] -> HsConDecl
hsConDeclSrcLoc :: HsConDecl -> SrcLoc
hsConDeclExists :: HsConDecl -> [HsTyVarBind]
hsConDeclName :: HsConDecl -> HsName
hsConDeclConArg :: HsConDecl -> [HsBangType]
HsRecDecl :: SrcLoc -> [HsTyVarBind] -> HsName -> [([HsName], HsBangType)] -> HsConDecl
hsConDeclSrcLoc :: HsConDecl -> SrcLoc
hsConDeclExists :: HsConDecl -> [HsTyVarBind]
hsConDeclName :: HsConDecl -> HsName
hsConDeclRecArg :: HsConDecl -> [([HsName], HsBangType)]
hsConDeclArgs :: HsConDecl -> [HsBangType]
data HsBangType
HsBangedTy :: HsType -> HsBangType
hsBangType :: HsBangType -> HsType
HsUnBangedTy :: HsType -> HsBangType
hsBangType :: HsBangType -> HsType
data HsRhs
HsUnGuardedRhs :: HsExp -> HsRhs
HsGuardedRhss :: [HsGuardedRhs] -> HsRhs
data HsGuardedRhs
HsGuardedRhs :: SrcLoc -> HsExp -> HsExp -> HsGuardedRhs
data HsQualType
HsQualType :: HsContext -> HsType -> HsQualType
hsQualTypeContext :: HsQualType -> HsContext
hsQualTypeType :: HsQualType -> HsType
type LHsType = Located HsType
data HsType
HsTyFun :: HsType -> HsType -> HsType
HsTyTuple :: [HsType] -> HsType
HsTyUnboxedTuple :: [HsType] -> HsType
HsTyApp :: HsType -> HsType -> HsType
HsTyVar :: HsName -> HsType
hsTypeName :: HsType -> HsName
HsTyCon :: HsName -> HsType
hsTypeName :: HsType -> HsName
HsTyForall :: [HsTyVarBind] -> HsQualType -> HsType
hsTypeVars :: HsType -> [HsTyVarBind]
hsTypeType :: HsType -> HsQualType
HsTyExists :: [HsTyVarBind] -> HsQualType -> HsType
hsTypeVars :: HsType -> [HsTyVarBind]
hsTypeType :: HsType -> HsQualType
HsTyExpKind :: LHsType -> HsKind -> HsType
hsTyLType :: HsType -> LHsType
hsTyKind :: HsType -> HsKind
HsTyStrictType :: !Bool -> LHsType -> HsType
hsTyStrict :: HsType -> !Bool
hsTyLType :: HsType -> LHsType
HsTyAssoc :: HsType
HsTyEq :: HsType -> HsType -> HsType
data HsTyVarBind
HsTyVarBind :: SrcLoc -> HsName -> Maybe HsKind -> HsTyVarBind
hsTyVarBindSrcLoc :: HsTyVarBind -> SrcLoc
hsTyVarBindName :: HsTyVarBind -> HsName
hsTyVarBindKind :: HsTyVarBind -> Maybe HsKind
hsTyVarBind :: HsTyVarBind
type HsContext = [HsAsst]
data HsAsst
HsAsst :: HsName -> [HsName] -> HsAsst
HsAsstEq :: HsType -> HsType -> HsAsst
data HsLiteral
HsInt :: !Integer -> HsLiteral
HsChar :: !Char -> HsLiteral
HsString :: String -> HsLiteral
HsFrac :: Rational -> HsLiteral
HsCharPrim :: Char -> HsLiteral
HsStringPrim :: String -> HsLiteral
HsIntPrim :: Integer -> HsLiteral
HsFloatPrim :: Rational -> HsLiteral
HsDoublePrim :: Rational -> HsLiteral
HsLitLit :: String -> HsLiteral
hsParen :: HsExp -> HsExp
data HsErrorType
HsErrorPatternFailure :: HsErrorType
HsErrorSource :: HsErrorType
HsErrorFieldSelect :: HsErrorType
HsErrorUnderscore :: HsErrorType
HsErrorUninitializedField :: HsErrorType
HsErrorRecordUpdate :: HsErrorType
type LHsExp = Located HsExp
data HsExp
HsVar :: HsName -> HsExp
hsExpName :: HsExp -> HsName
HsCon :: HsName -> HsExp
hsExpName :: HsExp -> HsName
HsLit :: HsLiteral -> HsExp
HsInfixApp :: HsExp -> HsExp -> HsExp -> HsExp
HsApp :: HsExp -> HsExp -> HsExp
HsNegApp :: HsExp -> HsExp
HsLambda :: SrcLoc -> [HsPat] -> HsExp -> HsExp
HsLet :: [HsDecl] -> HsExp -> HsExp
HsIf :: HsExp -> HsExp -> HsExp -> HsExp
HsCase :: HsExp -> [HsAlt] -> HsExp
HsDo :: [HsStmt] -> HsExp
hsExpStatements :: HsExp -> [HsStmt]
HsTuple :: [HsExp] -> HsExp
HsUnboxedTuple :: [HsExp] -> HsExp
HsList :: [HsExp] -> HsExp
HsParen :: HsExp -> HsExp
HsLeftSection :: HsExp -> HsExp -> HsExp
HsRightSection :: HsExp -> HsExp -> HsExp
HsRecConstr :: HsName -> [HsFieldUpdate] -> HsExp
HsRecUpdate :: HsExp -> [HsFieldUpdate] -> HsExp
HsEnumFrom :: HsExp -> HsExp
HsEnumFromTo :: HsExp -> HsExp -> HsExp
HsEnumFromThen :: HsExp -> HsExp -> HsExp
HsEnumFromThenTo :: HsExp -> HsExp -> HsExp -> HsExp
HsListComp :: HsExp -> [HsStmt] -> HsExp
HsExpTypeSig :: SrcLoc -> HsExp -> HsQualType -> HsExp
HsAsPat :: HsName -> HsExp -> HsExp
hsExpName :: HsExp -> HsName
hsExpExp :: HsExp -> HsExp
HsError :: SrcLoc -> HsErrorType -> String -> HsExp
hsExpSrcLoc :: HsExp -> SrcLoc
hsExpErrorType :: HsExp -> HsErrorType
hsExpString :: HsExp -> String
HsWildCard :: SrcLoc -> HsExp
HsIrrPat :: LHsExp -> HsExp
hsExpLExp :: HsExp -> LHsExp
HsBangPat :: LHsExp -> HsExp
hsExpLExp :: HsExp -> LHsExp
HsLocatedExp :: LHsExp -> HsExp
data HsClassHead
HsClassHead :: HsContext -> HsName -> [HsType] -> HsClassHead
hsClassHeadContext :: HsClassHead -> HsContext
hsClassHead :: HsClassHead -> HsName
hsClassHeadArgs :: HsClassHead -> [HsType]
type LHsPat = Located HsPat
data HsPat
HsPVar :: HsName -> HsPat
hsPatName :: HsPat -> HsName
HsPLit :: HsLiteral -> HsPat
hsPatLit :: HsPat -> HsLiteral
HsPNeg :: HsPat -> HsPat
HsPInfixApp :: HsPat -> HsName -> HsPat -> HsPat
HsPApp :: HsName -> [HsPat] -> HsPat
hsPatName :: HsPat -> HsName
hsPatPats :: HsPat -> [HsPat]
HsPTuple :: [HsPat] -> HsPat
HsPUnboxedTuple :: [HsPat] -> HsPat
HsPList :: [HsPat] -> HsPat
HsPParen :: HsPat -> HsPat
HsPRec :: HsName -> [HsPatField] -> HsPat
HsPAsPat :: HsName -> HsPat -> HsPat
hsPatName :: HsPat -> HsName
hsPatPat :: HsPat -> HsPat
HsPWildCard :: HsPat
HsPIrrPat :: LHsPat -> HsPat
hsPatLPat :: HsPat -> LHsPat
HsPBangPat :: LHsPat -> HsPat
hsPatLPat :: HsPat -> LHsPat
HsPTypeSig :: SrcLoc -> HsPat -> HsQualType -> HsPat
data HsPatField
HsPFieldPat :: HsName -> HsPat -> HsPatField
data HsStmt
HsGenerator :: SrcLoc -> HsPat -> HsExp -> HsStmt
HsQualifier :: HsExp -> HsStmt
HsLetStmt :: [HsDecl] -> HsStmt
data HsFieldUpdate
HsFieldUpdate :: HsName -> HsExp -> HsFieldUpdate
data HsAlt
HsAlt :: SrcLoc -> HsPat -> HsRhs -> [HsDecl] -> HsAlt
data HsKind
HsKind :: HsName -> HsKind
HsKindFn :: HsKind -> HsKind -> HsKind
hsKindStar :: HsKind
hsKindHash :: HsKind
hsKindBang :: HsKind
hsKindQuest :: HsKind
hsKindQuestQuest :: HsKind
hsKindStarBang :: HsKind
hsModuleSrcLoc_s :: SrcLoc -> HsModule -> HsModule
hsModuleSrcLoc_u :: (SrcLoc -> SrcLoc) -> HsModule -> HsModule
hsModuleOptions_s :: [[Char]] -> HsModule -> HsModule
hsModuleOptions_u :: ([[Char]] -> [[Char]]) -> HsModule -> HsModule
hsModuleOpt_s :: Opt -> HsModule -> HsModule
hsModuleOpt_u :: (Opt -> Opt) -> HsModule -> HsModule
hsModuleName_s :: Module -> HsModule -> HsModule
hsModuleName_u :: (Module -> Module) -> HsModule -> HsModule
hsModuleImports_s :: [HsImportDecl] -> HsModule -> HsModule
hsModuleImports_u :: ([HsImportDecl] -> [HsImportDecl]) -> HsModule -> HsModule
hsModuleExports_s :: Maybe [HsExportSpec] -> HsModule -> HsModule
hsModuleExports_u :: (Maybe [HsExportSpec] -> Maybe [HsExportSpec]) -> HsModule -> HsModule
hsModuleDecls_s :: [HsDecl] -> HsModule -> HsModule
hsModuleDecls_u :: ([HsDecl] -> [HsDecl]) -> HsModule -> HsModule
isHsDeclDeriving :: HsDecl -> Bool
isHsPragmaSpecialize :: HsDecl -> Bool
isHsPragmaRules :: HsDecl -> Bool
isHsPragmaProps :: HsDecl -> Bool
isHsForeignExport :: HsDecl -> Bool
isHsForeignDecl :: HsDecl -> Bool
isHsSpaceDecl :: HsDecl -> Bool
isHsActionDecl :: HsDecl -> Bool
isHsPatBind :: HsDecl -> Bool
isHsFunBind :: HsDecl -> Bool
isHsTypeSig :: HsDecl -> Bool
isHsDefaultDecl :: HsDecl -> Bool
isHsInstDecl :: HsDecl -> Bool
isHsClassAliasDecl :: HsDecl -> Bool
isHsClassDecl :: HsDecl -> Bool
isHsInfixDecl :: HsDecl -> Bool
isHsDataDecl :: HsDecl -> Bool
isHsTypeDecl :: HsDecl -> Bool
isHsTypeFamilyDecl :: HsDecl -> Bool
isHsRecDecl :: HsConDecl -> Bool
isHsConDecl :: HsConDecl -> Bool
hsConDeclSrcLoc_s :: SrcLoc -> HsConDecl -> HsConDecl
hsConDeclSrcLoc_u :: (SrcLoc -> SrcLoc) -> HsConDecl -> HsConDecl
hsConDeclRecArg_s :: [([Name], HsBangType)] -> HsConDecl -> HsConDecl
hsConDeclRecArg_u :: ([([Name], HsBangType)] -> [([Name], HsBangType)]) -> HsConDecl -> HsConDecl
hsConDeclName_s :: Name -> HsConDecl -> HsConDecl
hsConDeclName_u :: (Name -> Name) -> HsConDecl -> HsConDecl
hsConDeclExists_s :: [HsTyVarBind] -> HsConDecl -> HsConDecl
hsConDeclExists_u :: ([HsTyVarBind] -> [HsTyVarBind]) -> HsConDecl -> HsConDecl
hsConDeclConArg_s :: [HsBangType] -> HsConDecl -> HsConDecl
hsConDeclConArg_u :: ([HsBangType] -> [HsBangType]) -> HsConDecl -> HsConDecl
isHsTyEq :: HsType -> Bool
isHsTyAssoc :: HsType -> Bool
isHsTyStrictType :: HsType -> Bool
isHsTyExpKind :: HsType -> Bool
isHsTyExists :: HsType -> Bool
isHsTyForall :: HsType -> Bool
isHsTyCon :: HsType -> Bool
isHsTyVar :: HsType -> Bool
isHsTyApp :: HsType -> Bool
isHsTyUnboxedTuple :: HsType -> Bool
isHsTyTuple :: HsType -> Bool
isHsTyFun :: HsType -> Bool
hsTyVarBindSrcLoc_s :: SrcLoc -> HsTyVarBind -> HsTyVarBind
hsTyVarBindSrcLoc_u :: (SrcLoc -> SrcLoc) -> HsTyVarBind -> HsTyVarBind
hsTyVarBindName_s :: Name -> HsTyVarBind -> HsTyVarBind
hsTyVarBindName_u :: (Name -> Name) -> HsTyVarBind -> HsTyVarBind
hsTyVarBindKind_s :: Maybe HsKind -> HsTyVarBind -> HsTyVarBind
hsTyVarBindKind_u :: (Maybe HsKind -> Maybe HsKind) -> HsTyVarBind -> HsTyVarBind
isHsLitLit :: HsLiteral -> Bool
isHsDoublePrim :: HsLiteral -> Bool
isHsFloatPrim :: HsLiteral -> Bool
isHsIntPrim :: HsLiteral -> Bool
isHsStringPrim :: HsLiteral -> Bool
isHsCharPrim :: HsLiteral -> Bool
isHsFrac :: HsLiteral -> Bool
isHsString :: HsLiteral -> Bool
isHsChar :: HsLiteral -> Bool
isHsInt :: HsLiteral -> Bool
isHsLocatedExp :: HsExp -> Bool
isHsBangPat :: HsExp -> Bool
isHsIrrPat :: HsExp -> Bool
isHsWildCard :: HsExp -> Bool
isHsError :: HsExp -> Bool
isHsAsPat :: HsExp -> Bool
isHsExpTypeSig :: HsExp -> Bool
isHsListComp :: HsExp -> Bool
isHsEnumFromThenTo :: HsExp -> Bool
isHsEnumFromThen :: HsExp -> Bool
isHsEnumFromTo :: HsExp -> Bool
isHsEnumFrom :: HsExp -> Bool
isHsRecUpdate :: HsExp -> Bool
isHsRecConstr :: HsExp -> Bool
isHsRightSection :: HsExp -> Bool
isHsLeftSection :: HsExp -> Bool
isHsParen :: HsExp -> Bool
isHsList :: HsExp -> Bool
isHsUnboxedTuple :: HsExp -> Bool
isHsTuple :: HsExp -> Bool
isHsDo :: HsExp -> Bool
isHsCase :: HsExp -> Bool
isHsIf :: HsExp -> Bool
isHsLet :: HsExp -> Bool
isHsLambda :: HsExp -> Bool
isHsNegApp :: HsExp -> Bool
isHsApp :: HsExp -> Bool
isHsInfixApp :: HsExp -> Bool
isHsLit :: HsExp -> Bool
isHsCon :: HsExp -> Bool
isHsVar :: HsExp -> Bool
hsExpString_s :: [Char] -> HsExp -> HsExp
hsExpString_u :: ([Char] -> [Char]) -> HsExp -> HsExp
hsExpStatements_s :: [HsStmt] -> HsExp -> HsExp
hsExpStatements_u :: ([HsStmt] -> [HsStmt]) -> HsExp -> HsExp
hsExpSrcLoc_s :: SrcLoc -> HsExp -> HsExp
hsExpSrcLoc_u :: (SrcLoc -> SrcLoc) -> HsExp -> HsExp
hsExpName_s :: Name -> HsExp -> HsExp
hsExpName_u :: (Name -> Name) -> HsExp -> HsExp
hsExpLExp_s :: Located HsExp -> HsExp -> HsExp
hsExpLExp_u :: (Located HsExp -> Located HsExp) -> HsExp -> HsExp
hsExpExp_s :: HsExp -> HsExp -> HsExp
hsExpExp_u :: (HsExp -> HsExp) -> HsExp -> HsExp
hsExpErrorType_s :: HsErrorType -> HsExp -> HsExp
hsExpErrorType_u :: (HsErrorType -> HsErrorType) -> HsExp -> HsExp
hsClassHeadContext_s :: [HsAsst] -> HsClassHead -> HsClassHead
hsClassHeadContext_u :: ([HsAsst] -> [HsAsst]) -> HsClassHead -> HsClassHead
hsClassHeadArgs_s :: [HsType] -> HsClassHead -> HsClassHead
hsClassHeadArgs_u :: ([HsType] -> [HsType]) -> HsClassHead -> HsClassHead
hsClassHead_s :: Name -> HsClassHead -> HsClassHead
hsClassHead_u :: (Name -> Name) -> HsClassHead -> HsClassHead
isHsPTypeSig :: HsPat -> Bool
isHsPBangPat :: HsPat -> Bool
isHsPIrrPat :: HsPat -> Bool
isHsPWildCard :: HsPat -> Bool
isHsPAsPat :: HsPat -> Bool
isHsPRec :: HsPat -> Bool
isHsPParen :: HsPat -> Bool
isHsPList :: HsPat -> Bool
isHsPUnboxedTuple :: HsPat -> Bool
isHsPTuple :: HsPat -> Bool
isHsPApp :: HsPat -> Bool
isHsPInfixApp :: HsPat -> Bool
isHsPNeg :: HsPat -> Bool
isHsPLit :: HsPat -> Bool
isHsPVar :: HsPat -> Bool
instance [overlap ok] Binary HsKind
instance [overlap ok] Binary HsAsst
instance [overlap ok] Binary HsTyVarBind
instance [overlap ok] Binary HsType
instance [overlap ok] Binary HsQualType
instance [overlap ok] Binary HsAssoc
instance [overlap ok] Typeable HsKind
instance [overlap ok] Typeable HsTyVarBind
instance [overlap ok] Typeable HsType
instance [overlap ok] Typeable HsQualType
instance [overlap ok] Typeable HsAsst
instance [overlap ok] Eq HsExportSpec
instance [overlap ok] Show HsExportSpec
instance [overlap ok] Eq HsImportDecl
instance [overlap ok] Show HsImportDecl
instance [overlap ok] Eq HsAssoc
instance [overlap ok] Show HsAssoc
instance [overlap ok] Eq DeclType
instance [overlap ok] Show DeclType
instance [overlap ok] Eq HsLiteral
instance [overlap ok] Ord HsLiteral
instance [overlap ok] Show HsLiteral
instance [overlap ok] Eq HsErrorType
instance [overlap ok] Show HsErrorType
instance [overlap ok] Data HsKind
instance [overlap ok] Eq HsKind
instance [overlap ok] Ord HsKind
instance [overlap ok] Show HsKind
instance [overlap ok] Data HsTyVarBind
instance [overlap ok] Eq HsTyVarBind
instance [overlap ok] Ord HsTyVarBind
instance [overlap ok] Show HsTyVarBind
instance [overlap ok] Data HsType
instance [overlap ok] Eq HsType
instance [overlap ok] Ord HsType
instance [overlap ok] Show HsType
instance [overlap ok] Data HsQualType
instance [overlap ok] Eq HsQualType
instance [overlap ok] Ord HsQualType
instance [overlap ok] Show HsQualType
instance [overlap ok] Data HsAsst
instance [overlap ok] Eq HsAsst
instance [overlap ok] Ord HsAsst
instance [overlap ok] Show HsAsst
instance [overlap ok] Eq HsClassHead
instance [overlap ok] Show HsClassHead
instance [overlap ok] Eq HsPat
instance [overlap ok] Ord HsPat
instance [overlap ok] Show HsPat
instance [overlap ok] Eq HsPatField
instance [overlap ok] Ord HsPatField
instance [overlap ok] Show HsPatField
instance [overlap ok] Eq HsBangType
instance [overlap ok] Show HsBangType
instance [overlap ok] Eq HsConDecl
instance [overlap ok] Show HsConDecl
instance [overlap ok] Eq HsDecl
instance [overlap ok] Show HsDecl
instance [overlap ok] Eq HsExp
instance [overlap ok] Show HsExp
instance [overlap ok] Eq HsAlt
instance [overlap ok] Show HsAlt
instance [overlap ok] Eq HsRhs
instance [overlap ok] Show HsRhs
instance [overlap ok] Eq HsGuardedRhs
instance [overlap ok] Show HsGuardedRhs
instance [overlap ok] Eq HsFieldUpdate
instance [overlap ok] Show HsFieldUpdate
instance [overlap ok] Eq HsStmt
instance [overlap ok] Show HsStmt
instance [overlap ok] Eq HsMatch
instance [overlap ok] Show HsMatch
instance [overlap ok] Eq HsRule
instance [overlap ok] Show HsRule
instance [overlap ok] HasLocation HsTyVarBind
instance [overlap ok] HasLocation HsMatch
instance [overlap ok] HasLocation HsRule
instance [overlap ok] HasLocation HsDecl
instance [overlap ok] HasLocation HsImportDecl
instance [overlap ok] HasLocation HsModule
instance [overlap ok] Binary Module
instance [overlap ok] HasLocation HsExp
instance [overlap ok] HasLocation HsAlt

module FrontEnd.Syn.Traverse
traverse_ :: Monad m => (a -> m b) -> a -> m a
traverseHsExp_ :: MonadSetSrcLoc m => (HsExp -> m ()) -> HsExp -> m ()
traverseHsExp :: MonadSetSrcLoc m => (HsExp -> m HsExp) -> HsExp -> m HsExp
traverseHsType_ :: Monad m => (HsType -> m b) -> HsType -> m ()
traverseHsType :: Monad m => (HsType -> m HsType) -> HsType -> m HsType
doQual :: Monad m => (a -> HsQualType -> b) -> (HsType -> m HsType) -> a -> HsQualType -> m b
traverseHsPat_ :: MonadSetSrcLoc m => (HsPat -> m b) -> HsPat -> m ()
traverseHsPat :: MonadSetSrcLoc m => (HsPat -> m HsPat) -> HsPat -> m HsPat
traverseHsRhsHsExp :: MonadSetSrcLoc m => (HsExp -> m HsExp) -> HsRhs -> m HsRhs
traverseHsStmtHsExp :: MonadSetSrcLoc m => (HsExp -> m HsExp) -> HsStmt -> m HsStmt
traverseHsDeclHsExp :: MonadSetSrcLoc m => (HsExp -> m HsExp) -> HsDecl -> m HsDecl
getNamesFromHsPat :: HsPat -> [HsName]
instance [overlap ok] FreeVars HsType (Set Name)

module DerivingDrift.DataP
data Statement
DataStmt :: Statement
NewTypeStmt :: Statement
data Data
D :: Name -> [(Class, Var)] -> [Var] -> [Body] -> [Class] -> Statement -> Data
name :: Data -> Name
constraints :: Data -> [(Class, Var)]
vars :: Data -> [Var]
body :: Data -> [Body]
derives :: Data -> [Class]
statement :: Data -> Statement
data Body
Body :: Constructor -> [Name] -> [HsBangType] -> Body
constructor :: Body -> Constructor
labels :: Body -> [Name]
types :: Body -> [HsBangType]
type Var = String
type Class = String
type Constructor = String
instance [overlap ok] Eq Statement
instance [overlap ok] Show Statement
instance [overlap ok] Eq Body
instance [overlap ok] Show Body
instance [overlap ok] Eq Data
instance [overlap ok] Show Data

module DerivingDrift.RuleUtils
x :: Doc
f :: Doc
rArrow :: Doc
lArrow :: Doc
blank :: Doc
semicolon :: Doc
texts :: [String] -> [Doc]
block :: [Doc] -> Doc
bracketList :: [Doc] -> Doc
parenList :: [Doc] -> Doc
blockList :: [Doc] -> Doc
sepWith :: a -> [a] -> [a]
opt :: [a] -> ([a] -> Doc) -> Doc
opt1 :: [a] -> ([a] -> Doc) -> (a -> Doc) -> Doc
commentLine :: Doc -> Doc
commentBlock :: Doc -> Doc
simpleInstance :: Class -> Data -> Doc
type IFunction = Body -> Doc
instanceSkeleton :: Class -> [(IFunction, Doc)] -> Data -> Doc
varNames :: [a] -> [Doc]
varNames' :: [a] -> [Doc]
pattern :: Constructor -> [a] -> Doc
pattern_ :: Constructor -> [a] -> Doc
pattern' :: Constructor -> [a] -> Doc
hasRecord :: Data -> Bool
tuple :: [Doc] -> Doc

module DerivingDrift.StandardRules
standardRules :: Map Name (Data -> Doc)
driftResolvedNames :: [(Name, [Name])]


-- | The definitions related to jhc core
module E.Type
data Comb
Comb :: TVr -> E -> [Rule] -> Comb
combHead :: Comb -> TVr
combBody :: Comb -> E
combRules :: Comb -> [Rule]
combBody_u :: (E -> E) -> Comb -> Comb
combHead_u :: (TVr -> TVr) -> Comb -> Comb
combRules_u :: ([Rule] -> [Rule]) -> Comb -> Comb
combBody_s :: E -> Comb -> Comb
combHead_s :: TVr -> Comb -> Comb
combRules_s :: [Rule] -> Comb -> Comb
emptyComb :: Comb
combIdent :: Comb -> Id
combArgs :: Comb -> [TVr]
combABody :: Comb -> E
combBind :: Comb -> (TVr, E)
bindComb :: (TVr, E) -> Comb
combTriple :: Comb -> (TVr, [TVr], E)
combTriple_s :: (TVr, [TVr], E) -> Comb -> Comb
data RuleType
RuleSpecialization :: RuleType
RuleUser :: RuleType
RuleCatalyst :: RuleType
data Rule
Rule :: TVr -> [TVr] -> [E] -> {-# UNPACK #-} !Int -> E -> RuleType -> (Module, Int) -> Atom -> Rule
ruleHead :: Rule -> TVr
ruleBinds :: Rule -> [TVr]
ruleArgs :: Rule -> [E]
ruleNArgs :: Rule -> {-# UNPACK #-} !Int
ruleBody :: Rule -> E
ruleType :: Rule -> RuleType
ruleUniq :: Rule -> (Module, Int)
ruleName :: Rule -> Atom
data ARules
ARules :: IdSet -> [Rule] -> ARules
aruleFreeVars :: ARules -> IdSet
aruleRules :: ARules -> [Rule]
data Lit e t
LitInt :: Number -> t -> Lit e t
litNumber :: Lit e t -> Number
litType :: Lit e t -> t
LitCons :: Name -> [e] -> t -> Maybe E -> Lit e t
litName :: Lit e t -> Name
litArgs :: Lit e t -> [e]
litType :: Lit e t -> t
litAliasFor :: Lit e t -> Maybe E
data ESort

-- | the sort of boxed lazy types
EStar :: ESort

-- | the sort of boxed strict types
EBang :: ESort

-- | the sort of unboxed types
EHash :: ESort

-- | the sort of unboxed tuples
ETuple :: ESort

-- | the supersort of unboxed types
EHashHash :: ESort

-- | the supersort of boxed types
EStarStar :: ESort

-- | user defined sorts
ESortNamed :: Name -> ESort
data E
EAp :: E -> E -> E
ELam :: TVr -> E -> E
EPi :: TVr -> E -> E
EVar :: TVr -> E
Unknown :: E
ESort :: ESort -> E
ELit :: !(Lit E E) -> E
ELetRec :: [(TVr, E)] -> E -> E
eDefs :: E -> [(TVr, E)]
eBody :: E -> E
EPrim :: Prim -> [E] -> E -> E
EError :: String -> E -> E
ECase :: E -> E -> TVr -> [Alt E] -> (Maybe E) -> IdSet -> E
eCaseScrutinee :: E -> E
eCaseType :: E -> E
eCaseBind :: E -> TVr
eCaseAlts :: E -> [Alt E]
eCaseDefault :: E -> (Maybe E)
eCaseAllFV :: E -> IdSet
type TVr = TVr' E
data TVr' e
TVr :: !Id -> e -> Info -> TVr' e
tvrIdent :: TVr' e -> !Id
tvrType :: TVr' e -> e
tvrInfo :: TVr' e -> Info
tvrInfo_u :: (Info -> Info) -> TVr' e -> TVr' e
tvrType_u :: (t -> e) -> TVr' t -> TVr' e
tvrInfo_s :: Info -> TVr' e -> TVr' e
tvrType_s :: e -> TVr' t -> TVr' e
data Alt e
Alt :: (Lit TVr e) -> e -> Alt e
altHead :: Alt E -> Lit () ()
litHead :: Lit a b -> Lit () ()
litBinds :: Lit t t1 -> [t]
patToLitEE :: Lit TVr E -> E
caseBodies :: E -> [E]
casePats :: E -> [Lit TVr E]
caseBinds :: E -> [TVr]

-- | extract out EAp nodes a value and the arguments it is applied to.
fromAp :: E -> (E, [E])

-- | deconstruct EPi terms, getting function argument types.
fromPi :: E -> (E, [TVr])

-- | deconstruct ELam term.
fromLam :: E -> (E, [TVr])
litCons :: Lit e t
eStar :: E
eHash :: E
tVr :: Id -> e -> TVr' e
tvr :: TVr' E
isLitCons :: Lit e_1629244139 t_1629244140 -> Bool
isLitInt :: Lit e_1629244139 t_1629244140 -> Bool
isESortNamed :: ESort -> Bool
isEStarStar :: ESort -> Bool
isEHashHash :: ESort -> Bool
isETuple :: ESort -> Bool
isEHash :: ESort -> Bool
isEBang :: ESort -> Bool
isEStar :: ESort -> Bool
isECase :: E -> Bool
isEError :: E -> Bool
isEPrim :: E -> Bool
isELetRec :: E -> Bool
isELit :: E -> Bool
isESort :: E -> Bool
isUnknown :: E -> Bool
isEVar :: E -> Bool
isEPi :: E -> Bool
isELam :: E -> Bool
isEAp :: E -> Bool
fromECase :: E -> (E, E, TVr' E, [Alt E], Maybe E, IntjectionSet Id)
fromEError :: E -> ([Char], E)
fromEPrim :: E -> (Prim, [E], E)
fromELetRec :: E -> ([(TVr' E, E)], E)
fromELit :: E -> Lit E E
fromESort :: E -> ESort
fromUnknown :: E -> ()
fromEVar :: E -> TVr' E
fromEPi :: E -> (TVr' E, E)
fromELam :: E -> (TVr' E, E)
fromEAp :: E -> (E, E)
instance [overlap ok] Eq RuleType
instance [overlap ok] Eq ESort
instance [overlap ok] Ord ESort
instance [overlap ok] Functor TVr'
instance [overlap ok] Foldable TVr'
instance [overlap ok] Traversable TVr'
instance [overlap ok] Eq e => Eq (Alt e)
instance [overlap ok] Ord e => Ord (Alt e)
instance [overlap ok] Eq E
instance [overlap ok] Ord E
instance [overlap ok] (Eq e, Eq t) => Eq (Lit e t)
instance [overlap ok] (Ord e, Ord t) => Ord (Lit e t)
instance [overlap ok] Functor (Lit e)
instance [overlap ok] Foldable (Lit e)
instance [overlap ok] Traversable (Lit e)
instance [overlap ok] Ord TVr
instance [overlap ok] Eq TVr
instance [overlap ok] Show a => Show (TVr' a)
instance [overlap ok] (Show e, Show t) => Show (Lit e t)
instance [overlap ok] Show ESort
instance [overlap ok] HasProperties TVr
instance [overlap ok] HasProperties Comb

module E.FreeVars

-- | pull apart an ELet and separate out recursive strongly connected
--   components from an ELet.
decomposeLet :: E -> ([Either (TVr, E) [(TVr, E)]], E)

-- | separate out recursive strongly connected components from a
--   declaration list
decomposeDs :: [(TVr, E)] -> [Either (TVr, E) [(TVr, E)]]
caseUpdate :: E -> E
freeIds :: E -> IdSet
instance [overlap ok] FreeVars Rule IdSet
instance [overlap ok] FreeVars Comb [Id]
instance [overlap ok] FreeVars Comb IdSet
instance [overlap ok] FreeVars ARules IdSet
instance [overlap ok] FreeVars TVr IdSet
instance [overlap ok] FreeVars E (IdMap (Maybe E))
instance [overlap ok] FreeVars E (IdMap TVr)
instance [overlap ok] FreeVars (Alt E) (IdMap TVr)
instance [overlap ok] FreeVars E IdSet
instance [overlap ok] FreeVars (Alt E) IdSet
instance [overlap ok] FreeVars E x => FreeVars (Lit TVr E) x
instance [overlap ok] FreeVars E t => FreeVars TVr t
instance [overlap ok] FreeVars E [Id]
instance [overlap ok] FreeVars E [TVr]

module E.E
data Id
type IdMap = IntjectionMap Id
type IdSet = IntjectionSet Id

-- | find some temporary ids that are not members of the set, useful for
--   generating a small number of local unique names.
newIds :: IdSet -> [Id]
isWHNF :: E -> Bool
tIntegerzh :: E
tBits32zh :: E
tFunc :: E -> E -> E
tvrSilly :: TVr' E
tBoolzh :: E
lFalsezh :: Lit e E
lTruezh :: Lit e E
ePi :: TVr -> E -> E
eLam :: TVr -> E -> E

-- | throw away first n EPi terms
discardArgs :: Int -> E -> E
tvrName :: Monad m => TVr -> m Name
tvrShowName :: TVr -> String
modAbsurd :: Module
modBox :: Module
nameConjured :: Module -> E -> Name
fromConjured :: Monad m => Module -> Name -> m E
isBottom :: E -> Bool
caseBodiesMapM :: Monad m => (E -> m E) -> E -> m E
caseBodiesMap :: (E -> E) -> E -> E
eToList :: Monad m => E -> m [E]
toString :: Monad m => E -> m [Char]
ltTuple :: [E] -> E
ltTuple' :: [E] -> E
p_unsafeCoerce :: Prim
p_dependingOn :: Prim
p_toTag :: Prim
p_fromTag :: Prim
fromUnboxedTuple :: Monad m => E -> m [E]
isUnboxedTuple :: E -> Bool
instance [overlap ok] Show e => Show (Alt e)
instance [overlap ok] Show E
instance [overlap ok] ConNames (Lit E E)
instance [overlap ok] ConNames E
instance [overlap ok] TypeNames E

module E.Traverse
emapE_ :: Monad m => (E -> m a) -> E -> m ()
emapE :: Monad m => (E -> m E) -> E -> m E
emapE' :: Monad m => (E -> m E) -> E -> m E
emapEG :: Monad m => (E -> m E) -> (E -> m E) -> E -> m E
emapEGH :: Monad m => (E -> m E) -> (E -> m E) -> (E -> m E) -> E -> m E
eSize :: E -> Int
renameE :: IdSet -> IdMap E -> E -> (E, IdSet)
scopeCheck :: Monad m => Bool -> IdMap TVr -> E -> m ()
runRename :: IdSet -> E -> (E, IdSet)
instance [overlap ok] HasSize E
instance [overlap ok] Monoid MInt

module E.Subst
doSubst :: Bool -> Bool -> IdMap (Maybe E) -> E -> E
doSubst' :: Bool -> Bool -> IdMap E -> (Id -> Bool) -> E -> E
eAp :: E -> E -> E
litSMapM :: Monad m => (a -> m t) -> Lit a a -> m (Lit t t)

-- | Basic substitution routine
subst :: TVr -> E -> E -> E

-- | Identitcal to <a>subst</a> except that it substitutes inside the local
--   types for variables in expressions. This should not be used because it
--   breaks the sharing of types between a binding site of a variable and
--   its uses and can lead to inconsistant terms. However, it is sometimes
--   useful to create transient terms for typechecking.
subst' :: TVr -> E -> E -> E
substMap :: IdMap E -> E -> E

-- | doesn't seed with free variables.
substMap' :: IdMap E -> E -> E

-- | doesn't seed with free variables.
substMap'' :: IdMap (Maybe E) -> E -> E

-- | substitution routine that can substitute different values at the term
--   and type level. this is useful to enforce the invarient that let-bound
--   variables must not occur at the type level, yet non-atomic values
--   (even typelike ones) cannot appear in argument positions at the term
--   level.
typeSubst :: IdMap (Maybe E) -> IdMap E -> (E -> E)
typeSubst' :: IdMap E -> IdMap E -> E -> E

module E.Eval
eval :: E -> E
strong :: Monad m => [(TVr, E)] -> E -> m E

module E.TypeCheck
canBeBox :: (CanType (TypeOf a), CanType a, ~ * (TypeOf (TypeOf a)) E) => a -> Bool
eAp :: E -> E -> E

-- | Perform a full typecheck, evaluating type terms as necessary.
inferType :: (ContextMonad m, ContextOf m ~ String) => DataTable -> [(TVr, E)] -> E -> m E
infertype :: CanTypeCheck a => DataTable -> a -> E
typecheck :: (CanTypeCheck a, Monad m) => DataTable -> a -> m E

-- | find substitution that will transform the left term into the right
--   one, only substituting for the vars in the list
match :: Monad m => (Id -> Maybe E) -> [TVr] -> E -> E -> m [(TVr, E)]
sortSortLike :: E -> Bool
sortKindLike :: E -> Bool
sortTermLike :: E -> Bool
sortTypeLike :: E -> Bool

-- | Determine type of term using full algorithm with substitutions. This
--   should be used instead of <tt>typ</tt> when let-bound type variables
--   exist or you wish a more thorough checking of types.
typeInfer :: DataTable -> E -> E
typeInfer' :: DataTable -> [(TVr, E)] -> E -> E
instance [overlap ok] Monad Tc
instance [overlap ok] Functor Tc
instance [overlap ok] MonadReader TcEnv Tc
instance [overlap ok] ContextMonad Tc
instance [overlap ok] CanTypeCheck (Alt E)
instance [overlap ok] CanTypeCheck (Lit a E)
instance [overlap ok] CanTypeCheck TVr
instance [overlap ok] CanTypeCheck E
instance [overlap ok] CanType e => CanType (Alt e)
instance [overlap ok] CanType (Lit x t)
instance [overlap ok] CanType TVr
instance [overlap ok] CanType ESort
instance [overlap ok] CanType E

module E.Show
ePretty :: E -> Doc
render :: Doc -> String
prettyE :: E -> String
instance [overlap ok] Monad SEM
instance [overlap ok] Functor SEM
instance [overlap ok] PPrint String (Lit E E)
instance [overlap ok] PPrint String E
instance [overlap ok] PPrint Doc E
instance [overlap ok] DocLike d => PPrint d TVr

module E.Arbitrary
data EP
EP :: Bool -> Set TVr -> EP
canDiverge :: EP -> Bool
usedVars :: EP -> Set TVr
choose :: [IO a] -> IO a
value :: E -> IO E
var :: e -> IO (TVr' e)
complicate :: Set TVr -> E -> IO E
complicate' :: Set TVr -> E -> IO E
genE :: IO E
ge :: IO ()
testE :: IO ()

module E.Values
eTuple :: [E] -> E
eTuple' :: [E] -> E
unboxedTuple :: (CanType e, ~ * (TypeOf e) E) => [e] -> Lit e E
unboxedUnit :: E
unboxedTyUnit :: E
class ToE a
toE :: ToE a => a -> E
typeE :: ToE a => a -> E
class ToEzh a
toEzh :: ToEzh a => a -> E
typeEzh :: ToEzh a => a -> E
eCons :: E -> E -> E
eNil :: E -> E
emptyCase :: E
eCaseTup :: E -> [TVr] -> E -> E
eCaseTup' :: E -> [TVr] -> E -> E
eJustIO :: E -> E -> E
eCase :: E -> [Alt E] -> E -> E

-- | This takes care of types right away, it simplifies various other
--   things to do it this way.
eLet :: TVr -> E -> E -> E

-- | strict version of let, evaluates argument before assigning it.
eStrictLet :: TVr' E -> E -> E -> E
substLet :: [(TVr, E)] -> E -> E
substLet' :: [(TVr, E)] -> E -> E
eLetRec :: [(TVr, E)] -> E -> E
prim_seq :: E -> E -> E
prim_unsafeCoerce :: E -> E -> E
from_unsafeCoerce :: Monad m => E -> m (E, E)
isState_ :: E -> Bool
unsafeCoerceOpt :: E -> (Int, E, E -> E)

-- | whether a value is a compile time constant
isFullyConst :: E -> Bool

-- | whether a value may be used as an argument to an application, literal,
--   or primitive these may be duplicated with no code size or runtime
--   penalty
isAtomic :: E -> Bool

-- | whether a type is <a>obviously</a> atomic. fast and lazy, doesn't
--   recurse True -&gt; definitely atomic False -&gt; maybe atomic
isManifestAtomic :: E -> Bool

-- | whether an expression is small enough that it can be duplicated
--   without code size growing too much. (work may be repeated)
isSmall :: E -> Bool

-- | whether an expression may be duplicated or pushed inside a lambda
--   without duplicating too much work
isCheap :: E -> Bool

-- | determine if term can contain _|_
isLifted :: E -> Bool
whnfOrBot :: E -> Bool
isUnboxed :: E -> Bool
safeToDup :: E -> Bool
eToPat :: Monad m => E -> m (Lit TVr E)
patToE :: Monad m => Lit TVr E -> m E
instance [overlap ok] HasInfo TVr
instance [overlap ok] ToE a => ToE [a]
instance [overlap ok] ToE Int
instance [overlap ok] ToE Integer
instance [overlap ok] ToE Rational
instance [overlap ok] ToE Char
instance [overlap ok] ToE Bool
instance [overlap ok] ToE ()
instance [overlap ok] ToEzh Integer
instance [overlap ok] ToEzh Int
instance [overlap ok] ToEzh Char
instance [overlap ok] Tuple E

module E.PrimOpt
performPrimOpt :: MonadStats m => E -> m E
instance [overlap ok] Expression E E


-- | Attempt to find pretty printable differences between terms.
module E.Diff

-- | take two expressions and return (hopefully smaller) expressions with
--   their differences
diff :: E -> E -> (E, E)
findOddFreeVars :: [TVr] -> E -> E
printEStats :: E -> IO ()

module Name.Binary
instance [overlap ok] Binary a => Binary (IdMap a)
instance [overlap ok] Binary IdSet

module E.Binary
instance [overlap ok] Binary e => Binary (Alt e)
instance [overlap ok] Binary E
instance [overlap ok] Binary ESort
instance [overlap ok] (Binary e, Binary t) => Binary (Lit e t)
instance [overlap ok] Binary ARules
instance [overlap ok] Binary Rule
instance [overlap ok] Binary RuleType
instance [overlap ok] Binary TVr

module E.Rules
data ARules
data Rule
Rule :: TVr -> [TVr] -> [E] -> {-# UNPACK #-} !Int -> E -> RuleType -> (Module, Int) -> Atom -> Rule
data RuleType
RuleSpecialization :: RuleType
RuleUser :: RuleType
RuleCatalyst :: RuleType
newtype Rules
Rules :: (IdMap [Rule]) -> Rules
applyRules :: MonadStats m => (Id -> Maybe E) -> ARules -> [E] -> m (Maybe (E, [E]))
arules :: [Rule] -> ARules
builtinRule :: MonadStats m => TVr' t -> [E] -> m (Maybe (E, [E]))
dropArguments :: [(Int, E)] -> [Rule] -> [Rule]
fromRules :: [Rule] -> Rules
ruleUpdate :: Rule -> Rule
mapRBodyArgs :: Monad m => (E -> m E) -> Rule -> m Rule
makeRule :: String -> (Module, Int) -> RuleType -> [TVr] -> TVr -> [E] -> E -> Rule
mapBodies :: Monad m => (E -> m E) -> Rules -> m Rules
printRules :: RuleType -> Rules -> IO ()
rulesFromARules :: ARules -> [Rule]
instance [overlap ok] HasSize Rules
instance [overlap ok] IsEmpty Rules
instance [overlap ok] Monoid ARules
instance [overlap ok] Show ARules
instance [overlap ok] Monoid Rules
instance [overlap ok] FreeVars Rule [Id]
instance [overlap ok] Binary Rules
instance [overlap ok] Eq Rule
instance [overlap ok] Show Rule

module FrontEnd.Warning
data Warning
Warning :: !SrcLoc -> WarnType -> String -> Warning
warnSrcLoc :: Warning -> !SrcLoc
warnType :: Warning -> WarnType
warnMessage :: Warning -> String
class Monad m => MonadWarn m where addWarning w = fail $ show w
addWarning :: MonadWarn m => Warning -> m ()
data WarnType
AmbiguousExport :: Module -> [Name] -> WarnType
AmbiguousName :: Name -> [Name] -> WarnType
DuplicateInstances :: WarnType
InvalidDecl :: WarnType
MissingDep :: String -> WarnType
MissingModule :: Module -> WarnType
MultiplyDefined :: Name -> [SrcLoc] -> WarnType
InvalidFFIType :: WarnType
OccursCheck :: WarnType
PrimitiveBadType :: WarnType
PrimitiveUnknown :: Atom -> WarnType
TypeSynonymPartialAp :: WarnType
TypeSynonymRecursive :: WarnType
UndefinedName :: Name -> WarnType
UnificationError :: WarnType
UnknownDeriving :: [Class] -> WarnType
UnknownOption :: WarnType
UnknownPragma :: PackedString -> WarnType
UnsupportedFeature :: WarnType
processErrors :: [Warning] -> IO ()
warn :: MonadWarn m => SrcLoc -> WarnType -> String -> m ()
err :: MonadWarn m => WarnType -> String -> m ()
addWarn :: (MonadWarn m, MonadSrcLoc m) => WarnType -> String -> m ()
processIOErrors :: IO ()

-- | just show IO errors and return whether it would have died
printIOErrors :: IO Bool
instance [overlap ok] Eq WarnType
instance [overlap ok] Ord WarnType
instance [overlap ok] Eq Warning
instance [overlap ok] Ord Warning
instance [overlap ok] MonadWarn m => MonadWarn (ReaderT a m)
instance [overlap ok] MonadWarn Identity
instance [overlap ok] MonadWarn (Writer [Warning])
instance [overlap ok] MonadWarn IO
instance [overlap ok] Show Warning


-- | Monads for the Haskell parser and lexer.
module FrontEnd.ParseMonad

-- | Monad for parsing
data P a

-- | The result of a parse.
data ParseResult a

-- | The parse succeeded, yielding a value and a set of warnings.
ParseOk :: a -> ParseResult a

-- | The parse failed at the specified source location, with an error
--   message.
ParseFailed :: SrcLoc -> String -> ParseResult a
atSrcLoc :: P a -> SrcLoc -> P a
data LexContext
NoLayout :: LexContext
Layout :: Int -> LexContext

-- | Static parameters governing a parse. More to come later, e.g. literate
--   mode, language extensions.
data ParseMode
ParseMode :: FilePath -> Opt -> Bool -> Bool -> Bool -> ParseMode

-- | original name of the file being parsed
parseFilename :: ParseMode -> FilePath
parseOpt :: ParseMode -> Opt
parseFFI :: ParseMode -> Bool
parseUnboxedValues :: ParseMode -> Bool
parseUnboxedTuples :: ParseMode -> Bool
parseModeOptions :: Opt -> ParseMode
runParserWithMode :: ParseMode -> P a -> String -> ([Warning], ParseResult a)
runParser :: P a -> String -> ([Warning], ParseResult a)
getSrcLoc :: MonadSrcLoc m => m SrcLoc
setSrcLoc :: SrcLoc -> Lex a ()
pushCurrentContext :: P ()
popContext :: P ()
thenP :: P a -> (a -> P b) -> P b
returnP :: a -> P a
data Lex r a
getInput :: Lex r String

-- | Discard some input characters (these must not include tabs or
--   newlines).
discard :: Int -> Lex r ()

-- | Discard the next character, which must be a newline.
lexNewline :: Lex a ()

-- | Discard the next character, which must be a tab.
lexTab :: Lex a ()
lexWhile :: (Char -> Bool) -> Lex a String
alternative :: Lex a v -> Lex a (Lex a v)
checkBOL :: Lex a Bool
setBOL :: Lex a ()
startToken :: Lex a ()
getOffside :: Lex a Ordering
pushContextL :: LexContext -> Lex a ()
popContextL :: String -> Lex a ()
lexParseMode :: Lex a ParseMode
pullCtxtFlag :: Lex a Bool
setFlagDo :: Lex a ()
instance [overlap ok] Show a => Show (ParseResult a)
instance [overlap ok] Eq LexContext
instance [overlap ok] Ord LexContext
instance [overlap ok] Show LexContext
instance [overlap ok] Show ParseState
instance [overlap ok] Show a => Show (ParseStatus a)
instance [overlap ok] MonadSrcLoc (Lex r)
instance [overlap ok] MonadWarn (Lex r)
instance [overlap ok] Monad (Lex r)
instance [overlap ok] MonadWarn P
instance [overlap ok] MonadSrcLoc P
instance [overlap ok] Monad P
instance [overlap ok] Monoid m => Monoid (ParseResult m)
instance [overlap ok] Monad ParseResult
instance [overlap ok] Applicative ParseResult
instance [overlap ok] Functor ParseResult

module FrontEnd.Tc.Kind
data Kind
KBase :: KBase -> Kind
Kfun :: Kind -> Kind -> Kind
KVar :: Kindvar -> Kind
data KBase
Star :: KBase
KHash :: KBase
KUTuple :: KBase
KQuestQuest :: KBase
KQuest :: KBase
KNamed :: Name -> KBase
data Kindvar
Kindvar :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !(IORef (Maybe Kind)) -> !KindConstraint -> Kindvar
kvarUniq :: Kindvar -> {-# UNPACK #-} !Int
kvarRef :: Kindvar -> {-# UNPACK #-} !(IORef (Maybe Kind))
kvarConstraint :: Kindvar -> !KindConstraint
data KindConstraint

-- | <ul>
--   <li>| kindSimple -&gt; kindSimple</li>
--   </ul>
KindSimple :: KindConstraint

-- | ?, so * or (
KindQuest :: KindConstraint

-- | ??, * or #
KindQuestQuest :: KindConstraint

-- | must be *
KindStar :: KindConstraint

-- | may be anything
KindAny :: KindConstraint
kindCombine :: Monad m => Kind -> Kind -> m Kind
kindStar :: Kind
kindUTuple :: Kind
kindFunRet :: Kind
kindHash :: Kind
kindArg :: Kind
isSubsumedBy :: Kind -> Kind -> Bool
unfoldKind :: Kind -> [Kind]
instance [overlap ok] Binary Kind
instance [overlap ok] Binary KBase
instance [overlap ok] Eq KBase
instance [overlap ok] Ord KBase
instance [overlap ok] Eq KindConstraint
instance [overlap ok] Ord KindConstraint
instance [overlap ok] Show KindConstraint
instance [overlap ok] Eq Kind
instance [overlap ok] Ord Kind
instance [overlap ok] DocLike d => PPrint d Kindvar
instance [overlap ok] DocLike d => PPrint d Kind
instance [overlap ok] DocLike d => PPrint d KBase
instance [overlap ok] Show KBase
instance [overlap ok] Show Kindvar
instance [overlap ok] Show Kind
instance [overlap ok] Ord Kindvar
instance [overlap ok] Eq Kindvar
instance [overlap ok] Binary Kindvar
instance [overlap ok] Monoid KindConstraint

module FrontEnd.Utils
maybeGetDeclName :: Monad m => HsDecl -> m Name
getDeclName :: HsDecl -> Name

-- | Convert name to what it was before renaming.
hsNameToOrig :: HsName -> HsName
pprintEnvMap :: (PPrint d k, PPrint d a) => Map k a -> d

module FrontEnd.Desugar
doToExp :: Monad m => m HsName -> HsName -> HsName -> HsName -> [HsStmt] -> m HsExp
listCompToExp :: Monad m => m HsName -> HsExp -> [HsStmt] -> m HsExp
desugarHsModule :: HsModule -> HsModule
desugarHsStmt :: Monad m => HsStmt -> m HsStmt
instance [overlap ok] MonadSetSrcLoc PatSM
instance [overlap ok] MonadSrcLoc PatSM


-- | determine export/imports for modules via fixpoint recursion
module FrontEnd.Exports
determineExports :: [(Name, SrcLoc, [Name])] -> [(Module, [Name])] -> [ModInfo] -> IO [ModInfo]
data ModInfo
ModInfo :: Module -> [(Name, SrcLoc, [Name])] -> [(Name, Int)] -> [Name] -> [(Name, [Name])] -> HsModule -> Map Name Name -> Opt -> ModInfo
modInfoName :: ModInfo -> Module
modInfoDefs :: ModInfo -> [(Name, SrcLoc, [Name])]
modInfoConsArity :: ModInfo -> [(Name, Int)]
modInfoExport :: ModInfo -> [Name]
modInfoImport :: ModInfo -> [(Name, [Name])]
modInfoHsModule :: ModInfo -> HsModule
modInfoReverseMap :: ModInfo -> Map Name Name
modInfoOptions :: ModInfo -> Opt
instance [overlap ok] Ord ModInfo
instance [overlap ok] Eq ModInfo


-- | Lexer for Haskell.
module FrontEnd.Lexer
data Token
VarId :: !Name -> Token
QVarId :: !Name -> Token
ConId :: !Name -> Token
QConId :: !Name -> Token
VarSym :: !Name -> Token
ConSym :: !Name -> Token
QVarSym :: !Name -> Token
QConSym :: !Name -> Token
IntTok :: !Integer -> Token
UIntTok :: !Integer -> Token
FloatTok :: !Rational -> Token
Character :: !Char -> Token
UCharacter :: !Char -> Token
StringTok :: String -> Token
UStringTok :: String -> Token
PragmaOptions :: [String] -> Token
PragmaInline :: String -> Token
PragmaExp :: String -> Token
PragmaRules :: !Bool -> Token
PragmaSpecialize :: !Bool -> Token
PragmaStart :: String -> Token
PragmaEnd :: Token
LeftParen :: Token
RightParen :: Token
LeftUParen :: Token
RightUParen :: Token
SemiColon :: Token
LeftCurly :: Token
RightCurly :: Token
VRightCurly :: Token
LeftSquare :: Token
RightSquare :: Token
Comma :: Token
Underscore :: Token
BackQuote :: Token
DotDot :: Token
Colon :: Token
DoubleColon :: Token
Equals :: Token
Backslash :: Token
Bar :: Token
LeftArrow :: Token
RightArrow :: Token
At :: Token
Tilde :: Token
DoubleArrow :: Token
Minus :: Token
Quest :: Token
QuestQuest :: Token
StarBang :: Token
Exclamation :: Token
BangExclamation :: Token
Star :: Token
Hash :: Token
Dot :: Token
KW_As :: Token
KW_Case :: Token
KW_Class :: Token
KW_Alias :: Token
KW_Data :: Token
KW_Default :: Token
KW_Deriving :: Token
KW_Do :: Token
KW_Else :: Token
KW_Hiding :: Token
KW_If :: Token
KW_Import :: Token
KW_In :: Token
KW_Infix :: Token
KW_InfixL :: Token
KW_InfixR :: Token
KW_Instance :: Token
KW_Let :: Token
KW_Module :: Token
KW_NewType :: Token
KW_Of :: Token
KW_Then :: Token
KW_Type :: Token
KW_Where :: Token
KW_Qualified :: Token
KW_Foreign :: Token
KW_Forall :: Token
KW_Exists :: Token
KW_Kind :: Token
KW_Family :: Token
KW_Closed :: Token
EOF :: Token
lexer :: (Token -> P a) -> P a

module FrontEnd.Infix
buildFixityMap :: [HsDecl] -> FixityMap
infixHsModule :: FixityMap -> HsModule -> HsModule
data FixityMap
size :: HasSize a => a -> Int
infixStatement :: FixityMap -> HsStmt -> HsStmt
restrictFixityMap :: (Name -> Bool) -> FixityMap -> FixityMap
instance [overlap ok] Monoid FixityMap
instance [overlap ok] HasSize FixityMap
instance [overlap ok] Binary FixityMap

module FrontEnd.Representation
data Type
TVar :: !Tyvar -> Type
typeVar :: Type -> !Tyvar
TCon :: !Tycon -> Type
typeCon :: Type -> !Tycon
TAp :: Type -> Type -> Type
TArrow :: Type -> Type -> Type
TForAll :: [Tyvar] -> (Qual Type) -> Type
typeArgs :: Type -> [Tyvar]
typeBody :: Type -> (Qual Type)
TExists :: [Tyvar] -> (Qual Type) -> Type
typeArgs :: Type -> [Tyvar]
typeBody :: Type -> (Qual Type)
TMetaVar :: MetaVar -> Type
metaVar :: Type -> MetaVar
TAssoc :: !Tycon -> [Type] -> [Type] -> Type
typeCon :: Type -> !Tycon
typeClassArgs :: Type -> [Type]
typeExtraArgs :: Type -> [Type]
data Tyvar
Tyvar :: {-# UNPACK #-} !Name -> Kind -> Tyvar
tyvarName :: Tyvar -> {-# UNPACK #-} !Name
tyvarKind :: Tyvar -> Kind
tyvar :: Name -> Kind -> Tyvar
data Tycon
Tycon :: Name -> Kind -> Tycon
tyconName :: Tycon -> Name
tyconKind :: Tycon -> Kind
fn :: Type -> Type -> Type
data Pred
IsIn :: Class -> Type -> Pred
IsEq :: Type -> Type -> Pred
data Qual t
(:=>) :: [Pred] -> t -> Qual t
type Class = Name
tForAll :: [Tyvar] -> Qual Type -> Type
tExists :: [Tyvar] -> Qual Type -> Type
data MetaVarType
Tau :: MetaVarType
Rho :: MetaVarType
Sigma :: MetaVarType
prettyPrintType :: DocLike d => Type -> d
fromTAp :: Type -> (Type, [Type])
fromTArrow :: Type -> ([Type], Type)
tassocToAp :: Type -> Type

-- | metavars are used in type checking
data MetaVar
MetaVar :: {-# UNPACK #-} !Int -> Kind -> {-# UNPACK #-} !(IORef (Maybe Type)) -> !MetaVarType -> MetaVar
metaUniq :: MetaVar -> {-# UNPACK #-} !Int
metaKind :: MetaVar -> Kind
metaRef :: MetaVar -> {-# UNPACK #-} !(IORef (Maybe Type))
metaType :: MetaVar -> !MetaVarType
tTTuple :: [Type] -> Type
tTTuple' :: [Type] -> Type
tList :: Type

-- | The <tt>(-&gt;)</tt> type constructor. Invariant: <tt>tArrow</tt>
--   shall not be fully applied. To this end, see <a>tAp</a>.
tArrow :: Type

-- | Type application, enforcing the invariant that there be no
--   fully-applied <a>tArrow</a>s
tAp :: Type -> Type -> Type
instance [overlap ok] Binary t_1629666554 => Binary (Qual t_1629666554)
instance [overlap ok] Binary Pred
instance [overlap ok] Binary Tycon
instance [overlap ok] Binary MetaVar
instance [overlap ok] Binary Type
instance [overlap ok] Binary MetaVarType
instance [overlap ok] Eq MetaVarType
instance [overlap ok] Ord MetaVarType
instance [overlap ok] Eq Tycon
instance [overlap ok] Show Tycon
instance [overlap ok] Ord Tycon
instance [overlap ok] Show t => Show (Qual t)
instance [overlap ok] Eq t => Eq (Qual t)
instance [overlap ok] Ord t => Ord (Qual t)
instance [overlap ok] Show Pred
instance [overlap ok] Eq Pred
instance [overlap ok] Ord Pred
instance [overlap ok] Ord Type
instance [overlap ok] Show Type
instance [overlap ok] CanType Type
instance [overlap ok] CanType Tyvar
instance [overlap ok] CanType Tycon
instance [overlap ok] CanType MetaVar
instance [overlap ok] Show MetaVar
instance [overlap ok] Show MetaVarType
instance [overlap ok] DocLike d => PPrint d MetaVar
instance [overlap ok] DocLike d => PPrint d Pred
instance [overlap ok] DocLike d => PPrint d MetaVarType
instance [overlap ok] DocLike d => PPrint d Type
instance [overlap ok] DocLike d => PPrint d Module
instance [overlap ok] Binary Tyvar
instance [overlap ok] DocLike d => PPrint d Tyvar
instance [overlap ok] (DocLike d, PPrint d t) => PPrint d (Qual t)
instance [overlap ok] DocLike d => PPrint d Tycon
instance [overlap ok] ToTuple Type
instance [overlap ok] ToTuple Tycon
instance [overlap ok] Ord Tyvar
instance [overlap ok] Eq Tyvar
instance [overlap ok] Show Tyvar
instance [overlap ok] Eq Type
instance [overlap ok] Binary (IORef a)
instance [overlap ok] Ord (IORef a)
instance [overlap ok] TypeNames Type
instance [overlap ok] Ord MetaVar
instance [overlap ok] Eq MetaVar

module FrontEnd.Tc.Type
data Kind
KBase :: KBase -> Kind
Kfun :: Kind -> Kind -> Kind
KVar :: Kindvar -> Kind
data KBase
Star :: KBase
KHash :: KBase
KUTuple :: KBase
KQuestQuest :: KBase
KQuest :: KBase
KNamed :: Name -> KBase

-- | metavars are used in type checking
data MetaVar
MetaVar :: {-# UNPACK #-} !Int -> Kind -> {-# UNPACK #-} !(IORef (Maybe Type)) -> !MetaVarType -> MetaVar
metaUniq :: MetaVar -> {-# UNPACK #-} !Int
metaKind :: MetaVar -> Kind
metaRef :: MetaVar -> {-# UNPACK #-} !(IORef (Maybe Type))
metaType :: MetaVar -> !MetaVarType
data MetaVarType
Tau :: MetaVarType
Rho :: MetaVarType
Sigma :: MetaVarType
data Pred
IsIn :: Class -> Type -> Pred
IsEq :: Type -> Type -> Pred
type Preds = [Pred]
data Qual t
(:=>) :: [Pred] -> t -> Qual t
data Tycon
Tycon :: Name -> Kind -> Tycon
tyconName :: Tycon -> Name
tyconKind :: Tycon -> Kind
data Type
TVar :: !Tyvar -> Type
typeVar :: Type -> !Tyvar
TCon :: !Tycon -> Type
typeCon :: Type -> !Tycon
TAp :: Type -> Type -> Type
TArrow :: Type -> Type -> Type
TForAll :: [Tyvar] -> (Qual Type) -> Type
typeArgs :: Type -> [Tyvar]
typeBody :: Type -> (Qual Type)
TExists :: [Tyvar] -> (Qual Type) -> Type
typeArgs :: Type -> [Tyvar]
typeBody :: Type -> (Qual Type)
TMetaVar :: MetaVar -> Type
metaVar :: Type -> MetaVar
TAssoc :: !Tycon -> [Type] -> [Type] -> Type
typeCon :: Type -> !Tycon
typeClassArgs :: Type -> [Type]
typeExtraArgs :: Type -> [Type]
data Tyvar
Tyvar :: {-# UNPACK #-} !Name -> Kind -> Tyvar
tyvarName :: Tyvar -> {-# UNPACK #-} !Name
tyvarKind :: Tyvar -> Kind
kindStar :: Kind
kindFunRet :: Kind
kindUTuple :: Kind
unfoldKind :: Kind -> [Kind]
fn :: Type -> Type -> Type
fromTAp :: Type -> (Type, [Type])
fromTArrow :: Type -> ([Type], Type)
type Sigma' = Sigma
type Tau' = Tau
type Rho' = Rho
type Sigma = Type
type Rho = Type
type Tau = Type
type SkolemTV = Tyvar
type BoundTV = Tyvar
type Preds = [Pred]
data Constraint
Equality :: SrcLoc -> Type -> Type -> Constraint
constraintSrcLoc :: Constraint -> SrcLoc
constraintType1 :: Constraint -> Type
constraintType2 :: Constraint -> Type
applyTyvarMap :: [(Tyvar, Type)] -> Type -> Type
applyTyvarMapQT :: [(Tyvar, Type)] -> Qual Type -> Qual Type
typeOfType :: Type -> (MetaVarType, Bool)
fromType :: Sigma -> ([Tyvar], [Pred], Type)
isTau :: Type -> Bool
isTau' :: Type -> Bool
isBoxy :: Type -> Bool
isRho' :: Type -> Bool
isRho :: Type -> Bool
isBoxyMetaVar :: MetaVar -> Bool
extractTyVar :: Monad m => Type -> m Tyvar
extractMetaVar :: Monad m => Type -> m MetaVar
extractBox :: Monad m => Type -> m MetaVar
newtype UnVarOpt
UnVarOpt :: Bool -> UnVarOpt
failEmptyMetaVar :: UnVarOpt -> Bool
flattenType :: (MonadIO m, UnVar t) => t -> m t
class UnVar t
unVar' :: UnVar t => t -> IO t
followTaus :: MonadIO m => Type -> m Type
findType :: MonadIO m => Type -> m Type
readMetaVar :: MonadIO m => MetaVar -> m (Maybe Type)
freeMetaVars :: Type -> Set MetaVar
data Rule
RuleSpec :: (Module, Int) -> Name -> Bool -> Type -> Rule
ruleUniq :: Rule -> (Module, Int)
ruleName :: Rule -> Name
ruleSuper :: Rule -> Bool
ruleType :: Rule -> Type
RuleUser :: (Module, Int) -> [(Name, Kind)] -> Rule
ruleUniq :: Rule -> (Module, Int)
ruleFreeTVars :: Rule -> [(Name, Kind)]
data CoerceTerm
CTId :: CoerceTerm
CTAp :: [Type] -> CoerceTerm
CTAbs :: [Tyvar] -> CoerceTerm
CTFun :: CoerceTerm -> CoerceTerm
CTCompose :: CoerceTerm -> CoerceTerm -> CoerceTerm

-- | Apply the function if the <a>Bool</a> is <a>True</a>.
ptrans :: Bool -> (a -> a) -> (a -> a)
ctFun :: CoerceTerm -> CoerceTerm
ctAbs :: [Tyvar] -> CoerceTerm
ctAp :: [Type] -> CoerceTerm
ctId :: CoerceTerm
composeCoerce :: CoerceTerm -> CoerceTerm -> CoerceTerm
prettyPrintType :: DocLike d => Type -> d
tForAll :: [Tyvar] -> Qual Type -> Type
tList :: Type
data Constraint
Equality :: SrcLoc -> Type -> Type -> Constraint
constraintSrcLoc :: Constraint -> SrcLoc
constraintType1 :: Constraint -> Type
constraintType2 :: Constraint -> Type
type Class = Name
data Kindvar
Kindvar :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !(IORef (Maybe Kind)) -> !KindConstraint -> Kindvar
kvarUniq :: Kindvar -> {-# UNPACK #-} !Int
kvarRef :: Kindvar -> {-# UNPACK #-} !(IORef (Maybe Kind))
kvarConstraint :: Kindvar -> !KindConstraint
tTTuple :: [Type] -> Type
tTTuple' :: [Type] -> Type

-- | Type application, enforcing the invariant that there be no
--   fully-applied <a>tArrow</a>s
tAp :: Type -> Type -> Type

-- | The <tt>(-&gt;)</tt> type constructor. Invariant: <tt>tArrow</tt>
--   shall not be fully applied. To this end, see <a>tAp</a>.
tArrow :: Type
tyvar :: Name -> Kind -> Tyvar
instance [overlap ok] UnVar Type => UnVar CoerceTerm
instance [overlap ok] Monoid CoerceTerm
instance [overlap ok] Show CoerceTerm
instance [overlap ok] Tickleable Type Type
instance [overlap ok] Tickleable Type Pred
instance [overlap ok] FreeVars Type b => FreeVars Pred b
instance [overlap ok] (FreeVars t b, FreeVars Pred b) => FreeVars (Qual t) b
instance [overlap ok] FreeVars Type (Set MetaVar)
instance [overlap ok] FreeVars Type [MetaVar]
instance [overlap ok] FreeVars Type [Tyvar]
instance [overlap ok] UnVar Type
instance [overlap ok] UnVar t => UnVar (Qual t)
instance [overlap ok] (UnVar a, UnVar b) => UnVar (a, b)
instance [overlap ok] UnVar Pred
instance [overlap ok] UnVar t => UnVar [t]
instance [overlap ok] HasLocation Constraint


-- | This module implements the Kind Inference algorithm, and the routines
--   which use the product of kind inference to convert haskell source
--   types into the simplified kind annotated types used by the rest of the
--   FrontEnd.
module FrontEnd.KindInfer
kiDecls :: KindEnv -> [HsDecl] -> IO KindEnv
data KindEnv
hsQualTypeToSigma :: Monad m => KindEnv -> HsQualType -> m Sigma
hsAsstToPred :: KindEnv -> HsAsst -> Pred
kiHsQualType :: KindEnv -> HsQualType -> KindEnv
kindOfClass :: Name -> KindEnv -> [Kind]
kindOf :: Name -> KindEnv -> Kind
restrictKindEnv :: (Name -> Bool) -> KindEnv -> KindEnv
hsTypeToType :: Monad m => KindEnv -> HsType -> m Type
getConstructorKinds :: KindEnv -> Map Name Kind
instance [overlap ok] Monoid KindEnv
instance [overlap ok] Typeable KindEnv
instance [overlap ok] Show KindEnv
instance [overlap ok] Eq KiWhere
instance [overlap ok] Monad Ki
instance [overlap ok] MonadReader KiEnv Ki
instance [overlap ok] MonadIO Ki
instance [overlap ok] Functor Ki
instance [overlap ok] MonadWarn Ki
instance [overlap ok] ContextMonad Ki
instance [overlap ok] MonadSetSrcLoc Ki
instance [overlap ok] MonadSrcLoc Ki
instance [overlap ok] DocLike d => PPrint d KindEnv
instance [overlap ok] FreeVars Kind (Set Kindvar)
instance [overlap ok] HasSize KindEnv
instance [overlap ok] Binary KindEnv

module FrontEnd.Class
printClassHierarchy :: ClassHierarchy -> IO ()
instanceToTopDecls :: KindEnv -> ClassHierarchy -> HsDecl -> (([HsDecl], [Assump]))
data ClassHierarchy
augmentClassHierarchy :: ClassHierarchy -> ClassHierarchy -> ClassHierarchy
chToClassHead :: KindEnv -> HsClassHead -> ([Pred], (Name, [Type]))
data ClassRecord
ClassRecord :: !Class -> !SrcLoc -> [Tyvar] -> [Class] -> Maybe (Qual [Pred]) -> [(Name, Sigma)] -> [AssociatedType] -> ClassRecord

-- | can be a TypeConstructor if we are a type or data family
className :: ClassRecord -> !Class
classSrcLoc :: ClassRecord -> !SrcLoc
classArgs :: ClassRecord -> [Tyvar]
classSupers :: ClassRecord -> [Class]
classAlias :: ClassRecord -> Maybe (Qual [Pred])

-- | method signatures
classAssumps :: ClassRecord -> [(Name, Sigma)]
classAssocs :: ClassRecord -> [AssociatedType]
data ClassType
ClassNormal :: ClassType
ClassTypeFamily :: ClassType
ClassDataFamily :: ClassType
ClassAlias :: ClassType
instanceName :: (Show a, Show a1) => a -> a1 -> Name
defaultInstanceName :: Show a => a -> Name
checkForDuplicateInstaces :: MonadWarn m => ClassHierarchy -> ClassHierarchy -> m ClassHierarchy
printClassSummary :: ClassHierarchy -> IO ()
findClassInsts :: ClassHierarchy -> Class -> [Inst]
findClassRecord :: ClassHierarchy -> Class -> ClassRecord
asksClassRecord :: ClassHierarchy -> Class -> (ClassRecord -> t) -> t
classRecords :: ClassHierarchy -> [ClassRecord]
addInstanceToHierarchy :: Inst -> ClassHierarchy -> ClassHierarchy
makeClassHierarchy :: MonadWarn m => ClassHierarchy -> KindEnv -> [HsDecl] -> m ClassHierarchy
scatterAliasInstances :: ClassHierarchy -> ClassHierarchy
derivableClasses :: [Name]
enumDerivableClasses :: [Name]
noNewtypeDerivable :: [Name]
makeInstanceEnv :: ClassHierarchy -> InstanceEnv
emptyInstance :: Inst
newtype InstanceEnv
InstanceEnv :: Map (Name, Name) ([Tyvar], [Tyvar], Type) -> InstanceEnv
instanceEnv :: InstanceEnv -> Map (Name, Name) ([Tyvar], [Tyvar], Type)
data Inst
Inst :: SrcLoc -> !Bool -> Qual Pred -> [(Tycon, [Tyvar], [Tyvar], Sigma)] -> Inst
instSrcLoc :: Inst -> SrcLoc

-- | whether this instance was derived
instDerived :: Inst -> !Bool
instHead :: Inst -> Qual Pred
instAssocs :: Inst -> [(Tycon, [Tyvar], [Tyvar], Sigma)]
instance [overlap ok] Binary ClassRecord
instance [overlap ok] Binary AssociatedType
instance [overlap ok] Binary Inst
instance [overlap ok] Eq Inst
instance [overlap ok] Ord Inst
instance [overlap ok] Show Inst
instance [overlap ok] Eq ClassType
instance [overlap ok] Ord ClassType
instance [overlap ok] Eq AssociatedType
instance [overlap ok] Show AssociatedType
instance [overlap ok] Show ClassRecord
instance [overlap ok] Eq ClassRecord
instance [overlap ok] Monoid ClassHierarchy
instance [overlap ok] Binary ClassHierarchy
instance [overlap ok] PPrint a (Qual Pred) => PPrint a Inst

module DataConstructors
data AliasType
ErasedAlias :: AliasType
RecursiveAlias :: AliasType
boxPrimitive :: Monad m => DataTable -> E -> E -> m (E, (ExtType, E))
collectDeriving :: [HsDecl] -> [(SrcLoc, Name, Name)]
conSlots :: Constructor -> [E]
constructionExpression :: DataTable -> Name -> E -> E

-- | Record describing a data type. * is also a data type containing the
--   type constructors, which are unlifted, yet boxed.
data Constructor
Constructor :: Name -> E -> E -> [Slot] -> Name -> Maybe [Name] -> DataFamily -> Maybe ExtType -> Constructor
conName :: Constructor -> Name
conType :: Constructor -> E
conExpr :: Constructor -> E
conOrigSlots :: Constructor -> [Slot]
conInhabits :: Constructor -> Name
conVirtual :: Constructor -> Maybe [Name]
conChildren :: Constructor -> DataFamily
conCTYPE :: Constructor -> Maybe ExtType
data DataFamily
DataAbstract :: DataFamily
DataNone :: DataFamily
DataPrimitive :: DataFamily
DataEnum :: {-# UNPACK #-} !Int -> DataFamily
DataNormal :: [Name] -> DataFamily
DataAlias :: !AliasType -> DataFamily
newtype DataTable
DataTable :: (Map Name Constructor) -> DataTable
class Monad m => DataTableMonad m where getDataTable = return mempty
getDataTable :: DataTableMonad m => m DataTable
dataTablePrims :: DataTable
deconstructionExpression :: UniqueProducer m => DataTable -> Name -> E -> [TVr] -> E -> m (Alt E)
deriveClasses :: IdMap Comb -> DataTable -> [(SrcLoc, Name, Name)] -> [(TVr, E)]
extractIO :: Monad m => E -> m E
extractIO' :: E -> ([E], Bool, E)
extractPrimitive :: Monad m => DataTable -> E -> m (E, (ExtType, E))
data ExtTypeInfo
ExtTypeVoid :: ExtTypeInfo
ExtTypeRaw :: ExtType -> ExtTypeInfo
ExtTypeBoxed :: Name -> E -> ExtType -> ExtTypeInfo
extTypeInfoExtType :: ExtTypeInfo -> ExtType
followAlias :: Monad m => DataTable -> E -> m E
followAliases :: DataTable -> E -> E
getConstructor :: Monad m => Name -> DataTable -> m Constructor
getConstructorArities :: DataTable -> [(Name, Int)]

-- | return the single constructor of product types
getProduct :: Monad m => DataTable -> E -> m Constructor
getSiblings :: DataTable -> Name -> Maybe [Name]
lookupExtTypeInfo :: Monad m => DataTable -> E -> m ExtTypeInfo
mktBox :: E -> E
modBox :: Module
numberSiblings :: DataTable -> Name -> Maybe Int
onlyChild :: DataTable -> Name -> Bool
pprintTypeOfCons :: (Monad m, DocLike a) => DataTable -> Name -> m a

-- | list of declared data types that map directly to primitive real types
primitiveAliases :: Map Name Name
removeNewtypes :: DataTable -> E -> E
samplePrimitiveDataTable :: DataTable
showDataTable :: DataTable -> Doc
data Slot
SlotNormal :: E -> Slot
SlotUnpacked :: E -> !Name -> [E] -> Slot
SlotExistential :: TVr -> Slot
slotTypes :: DataTable -> Name -> E -> [E]
slotTypesHs :: DataTable -> Name -> E -> [E]

-- | conjured data types, these data types are created as needed and can be
--   of any type, their actual type is encoded in their names.
--   
--   Absurd - this is a type that it used to default otherwise
--   unconstrained types, it is not special in any particular way but is
--   just an arbitrary type to give to things.
--   
--   Box - this type can be used to represent any boxed values. It is
--   considered equivalent to all boxed values so is not a very precise
--   type. It is used in the final stages of compilation before core
--   mangling so that optimizations that were previously blocked by type
--   variables can be carried out.
tAbsurd :: E -> E
toDataTable :: (Map Name Kind) -> (Map Name Type) -> [HsDecl] -> DataTable -> DataTable
typesCompatable :: Monad m => E -> E -> m ()
updateLit :: DataTable -> Lit e t -> Lit e t
instance [overlap ok] Binary Slot
instance [overlap ok] Binary Constructor
instance [overlap ok] Binary DataFamily
instance [overlap ok] Binary AliasType
instance [overlap ok] Eq AliasType
instance [overlap ok] Ord AliasType
instance [overlap ok] Show AliasType
instance [overlap ok] Monoid DataTable
instance [overlap ok] Show Constructor
instance [overlap ok] Eq Slot
instance [overlap ok] Ord Slot
instance [overlap ok] Show Slot
instance [overlap ok] Eq DataFamily
instance [overlap ok] Ord DataFamily
instance [overlap ok] Show DataFamily
instance [overlap ok] DataTableMonad Identity
instance [overlap ok] HasSize DataTable
instance [overlap ok] Binary DataTable

module E.Program
data ProgramType
SubProgram :: Bool -> ProgramType
MainProgram :: ProgramType
MainComponent :: ProgramType
data Program
Program :: IdSet -> [Comb] -> DataTable -> IdSet -> Id -> Module -> [String] -> IdSet -> IdSet -> IdSet -> ProgramType -> IdMap Comb -> !Stat -> Program
progExternalNames :: Program -> IdSet
progCombinators :: Program -> [Comb]
progDataTable :: Program -> DataTable
progEntry :: Program -> IdSet
progMain :: Program -> Id
progModule :: Program -> Module

-- | record of passes the program goes through
progPasses :: Program -> [String]

-- | filled in by occurance info collection
progUsedIds :: Program -> IdSet

-- | filled in by occurance info collection
progFreeIds :: Program -> IdSet

-- | these ids are depended on by external names via RULES
progSeasoning :: Program -> IdSet
progType :: Program -> ProgramType
progCombMap :: Program -> IdMap Comb
progStats :: Program -> !Stat
program :: Program
progEntryPoints :: Program -> [TVr]
progMainEntry :: Program -> TVr
progComb :: Monad m => Program -> Id -> m Comb
programDs :: Program -> [(TVr, E)]
progCombinators_u :: ([Comb] -> [Comb]) -> Program -> Program
progCombinators_s :: [Comb] -> Program -> Program
programUpdate :: Program -> Program
programSetDs' :: [(TVr, E)] -> Program -> Program
programSetDs :: [(TVr, E)] -> Program -> Program
programE :: Program -> E
programEsMap :: Monad m => Program -> m (Map Name (TVr, E))
programMapBodies :: Monad m => (E -> m E) -> Program -> m Program
programMapDs :: Monad m => ((TVr, E) -> m (TVr, E)) -> Program -> m Program
programMapDs_ :: Monad m => ((TVr, E) -> m ()) -> Program -> m ()
hPrintProgram :: Handle -> Program -> IO ()
printProgram :: Program -> IO ()
printCheckName'' :: DataTable -> TVr -> E -> IO ()
hPrintCheckName :: Handle -> DataTable -> TVr -> E -> IO ()

module E.Annotate
annotateCombs :: Monad m => (IdMap (Maybe E)) -> (Id -> Info -> m Info) -> (E -> Info -> m Info) -> (E -> Info -> m Info) -> [Comb] -> m [Comb]
annotateDs :: Monad m => (IdMap (Maybe E)) -> (Id -> Info -> m Info) -> (E -> Info -> m Info) -> (E -> Info -> m Info) -> [(TVr, E)] -> m [(TVr, E)]
annotateProgram :: Monad m => (IdMap (Maybe E)) -> (Id -> Info -> m Info) -> (E -> Info -> m Info) -> (E -> Info -> m Info) -> Program -> m Program
type AM m = ReaderT (IdMap (Maybe E)) m
annotate :: Monad m => (IdMap (Maybe E)) -> (Id -> Info -> m Info) -> (E -> Info -> m Info) -> (E -> Info -> m Info) -> E -> m E
mnv :: (HasSize a, SetLike a, ~ * (Key a) Id) => [Key a] -> Id -> a -> Id

module E.Inline
app :: MonadStats m => (E, [E]) -> m E

-- | Map recursive groups, allowing an initial map to be passed in and it
--   will also propagate changes in the tvrInfo properly, and make sure
--   nothing shadows one of the global names.
programMapRecGroups :: Monad m => IdMap (Maybe E) -> (Id -> Info -> m Info) -> (E -> Info -> m Info) -> (E -> Info -> m Info) -> ((Bool, [Comb]) -> m [Comb]) -> Program -> m Program
forceInline :: HasProperties a => a -> Bool
programDecomposedDs :: Program -> [Either (TVr, E) [(TVr, E)]]
programDecomposedCombs :: Program -> [(Bool, [Comb])]
programMapProgGroups :: Monad m => IdMap (Maybe E) -> (Program -> m Program) -> Program -> m Program
forceNoinline :: HasProperties a => a -> Bool

-- | higher numbers mean we want to inline it more
baseInlinability :: (Num a, HasProperties a1) => a1 -> E -> a

module E.LambdaLift
lambdaLift :: Program -> IO Program

-- | transform simple recursive functions into non-recursive variants this
--   is exactly the opposite of lambda lifting, but is a big win if the
--   function ends up inlined and is conducive to other optimizations
--   
--   in particular, the type arguments can almost always be transformed
--   away from the recursive inner function
--   
--   this has potentially exponential behavior. beware
staticArgumentTransform :: Program -> Program

module E.Lint
transformProgram :: MonadIO m => TransformParms Program -> Program -> m Program
onerrNone :: IO ()
lintCheckProgram :: IO a -> Program -> IO ()
dumpCore :: [Char] -> Program -> IO ()

module E.Demand
data Demand
Bottom :: Demand
L :: !SubDemand -> Demand
S :: !SubDemand -> Demand
Error :: !SubDemand -> Demand
Absent :: Demand
data DemandSignature
DemandSignature :: {-# UNPACK #-} !Int -> !DemandType -> DemandSignature
data DemandType
(:=>) :: !DemandEnv -> ![Demand] -> DemandType
data SubDemand
None :: SubDemand
Product :: ![Demand] -> SubDemand
analyzeProgram :: Monad m => Program -> m Program
absSig :: DemandSignature
lazy :: Demand
instance [overlap ok] Binary DemandSignature
instance [overlap ok] Binary DemandType
instance [overlap ok] Binary DemandEnv
instance [overlap ok] Binary SubDemand
instance [overlap ok] Binary Demand
instance [overlap ok] Typeable Demand
instance [overlap ok] Typeable DemandSignature
instance [overlap ok] Eq SubDemand
instance [overlap ok] Ord SubDemand
instance [overlap ok] Eq Demand
instance [overlap ok] Ord Demand
instance [overlap ok] Eq DemandEnv
instance [overlap ok] Ord DemandEnv
instance [overlap ok] Eq DemandType
instance [overlap ok] Ord DemandType
instance [overlap ok] Eq DemandSignature
instance [overlap ok] Ord DemandSignature
instance [overlap ok] Monad IM
instance [overlap ok] Functor IM
instance [overlap ok] MonadReader (Env, DataTable) IM
instance [overlap ok] Show DemandSignature
instance [overlap ok] Show DemandEnv
instance [overlap ok] Show DemandType
instance [overlap ok] DocLike d => PPrint d Demand
instance [overlap ok] Show Demand
instance [overlap ok] DataTableMonad IM
instance [overlap ok] Lattice DemandEnv
instance [overlap ok] Lattice Demand
instance [overlap ok] Lattice DemandType

module E.CPR
data Val
Top :: Val
Fun :: Val -> Val
Tup :: Name -> [Val] -> Val
VInt :: Number -> Val
Tag :: [Name] -> Val
Bot :: Val
cprAnalyzeDs :: DataTable -> [(TVr, E)] -> [(TVr, E)]
cprAnalyzeProgram :: Program -> Program
instance [overlap ok] Binary Val
instance [overlap ok] Typeable Val
instance [overlap ok] Eq Val
instance [overlap ok] Ord Val
instance [overlap ok] Monoid Env
instance [overlap ok] Monoid Val
instance [overlap ok] Show Val

module E.Eta
data ArityType
ABottom :: ArityType
ATop :: ArityType

-- | eta expand a use of a value
etaExpandAp :: (NameMonad Id m, MonadStats m) => DataTable -> TVr -> [E] -> m (Maybe E)
annotateArity :: E -> Info -> Info
deleteArity :: Info -> Info

-- | eta expand a definition
etaExpandDef :: (NameMonad Id m, MonadStats m) => DataTable -> Int -> TVr -> E -> m (Maybe (TVr, E))

-- | only reduce if all lambdas can be discarded. otherwise leave them in
--   place
etaExpandDef' :: (NameMonad Id m, MonadStats m) => DataTable -> Int -> TVr -> E -> m (TVr' E, E)
etaExpandProgram :: MonadStats m => Program -> m Program
getArityInfo :: Num t => TVr' e -> (ArityType, t)
etaAnnotateProgram :: Program -> Program

-- | eta reduce as much as possible
etaReduce :: E -> E
instance [overlap ok] Typeable ArityType
instance [overlap ok] Eq ArityType
instance [overlap ok] Ord ArityType
instance [overlap ok] Show ArityType

module E.LetFloat
atomizeApps :: Bool -> Program -> Program
atomizeAp :: IdSet -> Bool -> DataTable -> E -> E
floatOutward :: Program -> IO Program
programFloatInward :: Program -> IO Program
floatInward :: E -> E
instance [overlap ok] Typeable Level
instance [overlap ok] Typeable CLevel
instance [overlap ok] Eq Level
instance [overlap ok] Ord Level
instance [overlap ok] Enum Level
instance [overlap ok] Show Level
instance [overlap ok] Eq CLevel
instance [overlap ok] Ord CLevel
instance [overlap ok] Enum CLevel
instance [overlap ok] Show CLevel

module E.PrimDecode
processPrim :: MonadWarn m => DataTable -> SrcLoc -> Atom -> [E] -> E -> Requires -> m E
instance [overlap ok] Show Typ
instance [overlap ok] Show BType


-- | examine all uses of types in a program to determine which ones are
--   actually needed in the method generation
module E.TypeAnalysis
typeAnalyze :: Bool -> Program -> IO Program
type Typ = VMap () Name
expandPlaceholder :: Monad m => Comb -> m Comb
instance [overlap ok] Error ()

module E.WorkerWrapper
performWorkWrap :: DataTable -> [(TVr, E)] -> ([(TVr, E)], Stat)
workWrapProgram :: Program -> Program

module E.SSimplify
data Occurance

-- | unused means a var is not used at the term level, but might be at the
--   type level
Unused :: Occurance

-- | Used at most once not inside a lambda or as an argument
Once :: Occurance

-- | used once inside a lambda
OnceInLam :: Occurance

-- | used once in several branches
ManyBranch :: Occurance

-- | used many or an unknown number of times
Many :: Occurance

-- | chosen as a loopbreaker, never inline
LoopBreaker :: Occurance
cacheSimpOpts :: SimplifyOpts -> SimplifyOpts
simplifyE :: SimplifyOpts -> InE -> (Stat, OutE)
collectOccurance' :: E -> (E, IdMap UseInfo)
programPruneOccurance :: Program -> Program
programSSimplify :: SimplifyOpts -> Program -> Program
programSSimplifyPStat :: SimplifyOpts -> Program -> IO Program
data SimplifyOpts
SimpOpts :: !Bool -> !Bool -> !Bool -> IdMap Comb -> IdSet -> IdSet -> Env -> SimplifyOpts

-- | this inhibits all inlining inside functions which will always be
--   inlined
so_noInlining :: SimplifyOpts -> !Bool

-- | no rules and don't inhibit inlining
so_finalPhase :: SimplifyOpts -> !Bool

-- | don't inline anything that was lifted out
so_postLift :: SimplifyOpts -> !Bool

-- | bound variables
so_boundVars :: SimplifyOpts -> IdMap Comb

-- | variables that we know will exist, but might not yet.
so_forwardVars :: SimplifyOpts -> IdSet
so_boundVarsCache :: SimplifyOpts -> IdSet
so_cachedScope :: SimplifyOpts -> Env
emptySimplifyOpts :: SimplifyOpts
instance [overlap ok] Monoid Env
instance [overlap ok] Typeable UseInfo
instance [overlap ok] Show Occurance
instance [overlap ok] Eq Occurance
instance [overlap ok] Ord Occurance
instance [overlap ok] Show UseInfo
instance [overlap ok] Eq UseInfo
instance [overlap ok] Ord UseInfo
instance [overlap ok] HasSize OMap
instance [overlap ok] Collection OMap
instance [overlap ok] Unionize OMap
instance [overlap ok] SetLike OMap
instance [overlap ok] MapLike OMap
instance [overlap ok] Show OMap
instance [overlap ok] IsEmpty OMap
instance [overlap ok] Eq OMap
instance [overlap ok] Ord OMap
instance [overlap ok] Monad OM
instance [overlap ok] Functor OM
instance [overlap ok] MonadWriter (OMap, IdSet) OM
instance [overlap ok] MonadReader IdSet OM
instance [overlap ok] Eq Forced
instance [overlap ok] Ord Forced
instance [overlap ok] Show Forced
instance [overlap ok] Ord Binding
instance [overlap ok] Eq Binding
instance [overlap ok] Show Binding
instance [overlap ok] Show Range
instance [overlap ok] Eq Range
instance [overlap ok] Ord Range
instance [overlap ok] Show Cont
instance [overlap ok] Eq KnowSomething
instance [overlap ok] Monad SM
instance [overlap ok] Functor SM
instance [overlap ok] MonadReader Env SM
instance [overlap ok] MonadState SmState SM
instance [overlap ok] NameMonad Id SM
instance [overlap ok] MonadStats SM
instance [overlap ok] Monoid Forced
instance [overlap ok] Monoid OMap

module FrontEnd.HsErrors
hsType :: (MonadSrcLoc m, MonadWarn m) => HsType -> m ()
hsDeclTopLevel :: MonadWarn m => HsDecl -> m ()
hsDeclLocal :: MonadWarn m => HsDecl -> m ()
instance [overlap ok] Eq Context
instance [overlap ok] Show Context

module FrontEnd.DataConsAssump
dataConsEnv :: KindEnv -> [HsDecl] -> Map Name Sigma

module FrontEnd.TypeSigs
collectSigs :: [(HsDecl)] -> [(HsDecl)]
collectSigEnv :: KindEnv -> HsStmt -> SigEnv
type SigEnv = Map Name Type
listSigsToSigEnv :: KindEnv -> [HsDecl] -> SigEnv
instance [overlap ok] Monad SC
instance [overlap ok] MonadSetSrcLoc SC
instance [overlap ok] MonadSrcLoc SC

module FrontEnd.TypeSynonyms
removeSynonymsFromType :: MonadWarn m => TypeSynonyms -> HsType -> m HsType

-- | convert a set of type synonym declarations to a synonym map used for
--   efficient synonym expansion
--   
--   convert a set of type synonym declarations to a synonym map used for
--   efficient synonym expansion, expanding out the body of synonyms along
--   the way.
declsToTypeSynonyms :: MonadWarn m => TypeSynonyms -> [HsDecl] -> m TypeSynonyms
data TypeSynonyms
restrictTypeSynonyms :: (Name -> Bool) -> TypeSynonyms -> TypeSynonyms
showSynonyms :: DocLike d => (HsType -> d) -> TypeSynonyms -> d
showSynonym :: (DocLike d, Monad m) => (HsType -> d) -> Name -> TypeSynonyms -> m d
instance [overlap ok] Monoid TypeSynonyms
instance [overlap ok] HasSize TypeSynonyms
instance [overlap ok] Binary TypeSynonyms

module FrontEnd.TypeSyns
expandTypeSyns :: MonadWarn m => TypeSynonyms -> HsModule -> m HsModule
expandTypeSynsStmt :: MonadWarn m => TypeSynonyms -> Module -> HsStmt -> m HsStmt
instance [overlap ok] MonadSetSrcLoc ScopeSM
instance [overlap ok] MonadSrcLoc ScopeSM
instance [overlap ok] MonadWarn ScopeSM

module Info.Binary
putInfo :: Info -> Put
getInfo :: Get Info
instance [overlap ok] Binary Info
instance [overlap ok] Binary Properties


-- | Utilities for the Haskell parser.
module FrontEnd.ParseUtils
splitTyConApp :: HsType -> P (Name, [HsType])
mkRecConstrOrUpdate :: HsExp -> [HsFieldUpdate] -> P HsExp
checkPrec :: Integer -> P Int
checkContext :: HsType -> P HsContext
checkDataHeader :: HsQualType -> P (HsContext, Name, [Name])
checkPattern :: HsExp -> P HsPat
checkPatterns :: [HsExp] -> P [HsPat]
checkExpr :: HsExp -> P HsExp
checkValDef :: SrcLoc -> HsExp -> HsRhs -> [HsDecl] -> P HsDecl
checkUnQual :: Name -> P Name
readInteger :: String -> Integer
readRational :: String -> Rational
fixupHsDecls :: [HsDecl] -> [HsDecl]
parseError :: String -> P a
parseExport :: Monad m => String -> Name -> m String
qualTypeToClassHead :: HsQualType -> P HsClassHead
doForeign :: Monad m => SrcLoc -> [Name] -> Maybe (String, Name) -> HsQualType -> m HsDecl
doForeignEq :: Monad m => SrcLoc -> [Name] -> Maybe (String, Name) -> HsQualType -> HsExp -> m HsDecl

module FrontEnd.HsParser
parse :: P HsModule
parseHsStmt :: P HsStmt

module DerivingDrift.Drift
driftDerive :: HsModule -> [HsDecl]
driftResolvedNames :: [(Name, [Name])]

module FrontEnd.Rename
renameModule :: MonadWarn m => Opt -> FieldMap -> [(Name, [Name])] -> HsModule -> m ((HsModule, [HsDecl]), Map Name Name)

-- | unRename gets the original identifier name from the renamed version
unRename :: Name -> Name

-- | Collect all names defined in a module as well as their declaration
--   points and any subnames they might have. In addition, collect the
--   arities of any constructors.
collectDefsHsModule :: HsModule -> ([(Name, SrcLoc, [Name])], [(Name, Int)])
data FieldMap
FieldMap :: !(Map Name Int) -> !(Map Name [(Name, Int)]) -> FieldMap
class DeNameable a
deName :: DeNameable a => Module -> a -> a
renameStatement :: MonadWarn m => FieldMap -> [(Name, [Name])] -> Module -> HsStmt -> m HsStmt
instance [overlap ok] Eq Context
instance [overlap ok] Monad RM
instance [overlap ok] Functor RM
instance [overlap ok] MonadReader Env RM
instance [overlap ok] MonadWriter (Map Name Name, [Warning]) RM
instance [overlap ok] MonadState ScopeState RM
instance [overlap ok] DeNameable HsExp
instance [overlap ok] DeNameable HsAlt
instance [overlap ok] DeNameable HsPat
instance [overlap ok] DeNameable Name
instance [overlap ok] (Functor f, DeNameable a) => DeNameable (f a)
instance [overlap ok] OptionMonad RM
instance [overlap ok] MonadSetSrcLoc RM
instance [overlap ok] MonadSrcLoc RM
instance [overlap ok] UniqueProducer RM
instance [overlap ok] MonadWarn RM
instance [overlap ok] Applicative RM
instance [overlap ok] UpdateTable HsType
instance [overlap ok] UpdateTable HsQualType
instance [overlap ok] UpdateTable HsStmt
instance [overlap ok] UpdateTable HsPat
instance [overlap ok] UpdateTable HsDecl
instance [overlap ok] UpdateTable Name
instance [overlap ok] (UpdateTable a, UpdateTable b) => UpdateTable (a, b)
instance [overlap ok] UpdateTable a => UpdateTable [a]
instance [overlap ok] Rename HsFieldUpdate
instance [overlap ok] Rename HsStmt
instance [overlap ok] Rename HsAlt
instance [overlap ok] Rename HsExp
instance [overlap ok] Rename HsGuardedRhs
instance [overlap ok] Rename HsRhs
instance [overlap ok] Rename HsPatField
instance [overlap ok] Rename HsPat
instance [overlap ok] Rename HsMatch
instance [overlap ok] Rename HsTyVarBind
instance [overlap ok] Rename a => Rename (Maybe a)
instance [overlap ok] (Rename a, Rename b) => Rename (a, b)
instance [overlap ok] Rename a => Rename [a]
instance [overlap ok] Rename SrcLoc
instance [overlap ok] Rename x => Rename (Located x)
instance [overlap ok] Rename HsType
instance [overlap ok] Rename HsBangType
instance [overlap ok] Rename HsConDecl
instance [overlap ok] Rename HsAsst
instance [overlap ok] Rename HsQualType
instance [overlap ok] Rename HsRule
instance [overlap ok] Rename HsClassHead
instance [overlap ok] Rename HsDecl
instance [overlap ok] Monoid FieldMap

module FrontEnd.DeclsDepends
getDeclDeps :: HsDecl -> [HsName]
debugDeclBindGroups :: [[HsDecl]] -> String

module Ho.Type
cff_magic :: ChunkType
cff_link :: ChunkType
cff_libr :: ChunkType
cff_jhdr :: ChunkType
cff_core :: ChunkType
cff_defs :: ChunkType
cff_lcor :: ChunkType
cff_ldef :: ChunkType
cff_idep :: ChunkType
cff_file :: ChunkType

-- | A SourceHash is the hash of a specific file, it is associated with a
--   specific <a>Module</a> that said file implements.
type SourceHash = Hash

-- | HoHash is a unique identifier for a ho file or library.
type HoHash = Hash

-- | while a <a>Module</a> is a single Module associated with a single
--   haskell source file, a <a>ModuleGroup</a> identifies a group of
--   mutually recursive modules. Generally it is chosen from among the
--   Modules making up the group, but the specific choice has no other
--   meaning. We could use the HoHash, but for readability reasons when
--   debugging it makes more sense to choose an arbitrary Module.
type ModuleGroup = Module

-- | the collected information that is passed around this is not stored in
--   any file, but is what is collected from the ho files.
data CollectedHo
CollectedHo :: IdSet -> IdMap Comb -> Rules -> Map ModuleGroup Ho -> Map PackedString HoHash -> Ho -> IdMap (Maybe E) -> CollectedHo

-- | this is a list of external names that are valid but that we may not
--   know anything else about it is used to recognize invalid ids.
choExternalNames :: CollectedHo -> IdSet

-- | these are the functions in Comb form.
choCombinators :: CollectedHo -> IdMap Comb

-- | these are rules that may need to be retroactively applied to other
--   modules
choOrphanRules :: CollectedHo -> Rules

-- | the hos
choHoMap :: CollectedHo -> Map ModuleGroup Ho

-- | libraries depended on
choLibDeps :: CollectedHo -> Map PackedString HoHash

-- | these are caches of pre-computed values
choHo :: CollectedHo -> Ho

-- | cache of variable substitution map
choVarMap :: CollectedHo -> IdMap (Maybe E)

-- | The header contains basic information about the file, it should be
--   enough to determine whether we can discard the file right away or
--   consider it further.
data HoHeader
HoHeader :: Int -> HoHash -> Either ModuleGroup (PackedString, Version) -> [(PackedString, HoHash)] -> [(PackedString, PackedString)] -> HoHeader

-- | the version of the file format. it comes first so we don't try to read
--   data that may be in a different format.
hohVersion :: HoHeader -> Int

-- | my sha1 id
hohHash :: HoHeader -> HoHash

-- | the human readable name, either the ModuleGroup or the library name
--   and version.
hohName :: HoHeader -> Either ModuleGroup (PackedString, Version)

-- | library dependencies
hohLibDeps :: HoHeader -> [(PackedString, HoHash)]

-- | arch dependencies, these say whether the file is specialized for a
--   given arch.
hohArchDeps :: HoHeader -> [(PackedString, PackedString)]

-- | These are the dependencies needed to check if a ho file is up to date.
--   it only appears in ho files as hl files do not have source code to
--   check against or depend on anything but other libraries.
data HoIDeps
HoIDeps :: Map SourceHash (Module, [(Module, SrcLoc)]) -> [(Module, SourceHash)] -> [HoHash] -> [ModuleGroup] -> HoIDeps

-- | modules depended on indexed by a hash of the source.
hoIDeps :: HoIDeps -> Map SourceHash (Module, [(Module, SrcLoc)])

-- | Haskell Source files depended on
hoDepends :: HoIDeps -> [(Module, SourceHash)]

-- | Other objects depended on to be considered up to date.
hoModDepends :: HoIDeps -> [HoHash]

-- | library module groups needed
hoModuleGroupNeeds :: HoIDeps -> [ModuleGroup]
data HoLib
HoLib :: Map Module ModuleGroup -> Map Module Module -> Map ModuleGroup [ModuleGroup] -> [(PackedString, PackedString)] -> HoLib

-- | arbitrary metainformation such as library author, web site, etc.
hoModuleMap :: HoLib -> Map Module ModuleGroup
hoReexports :: HoLib -> Map Module Module
hoModuleDeps :: HoLib -> Map ModuleGroup [ModuleGroup]
hoMetaInfo :: HoLib -> [(PackedString, PackedString)]
data Library
Library :: HoHeader -> HoLib -> (Map ModuleGroup HoTcInfo) -> (Map ModuleGroup HoBuild) -> [ExtraFile] -> FilePath -> Library
libHoHeader :: Library -> HoHeader
libHoLib :: Library -> HoLib
libTcMap :: Library -> (Map ModuleGroup HoTcInfo)
libBuildMap :: Library -> (Map ModuleGroup HoBuild)
libExtraFiles :: Library -> [ExtraFile]
libFileName :: Library -> FilePath

-- | data only needed for type checking.
data HoTcInfo
HoTcInfo :: Map Module [Name] -> Map Name (SrcLoc, [Name]) -> Map Name Type -> FixityMap -> KindEnv -> TypeSynonyms -> ClassHierarchy -> FieldMap -> HoTcInfo
hoExports :: HoTcInfo -> Map Module [Name]
hoDefs :: HoTcInfo -> Map Name (SrcLoc, [Name])

-- | used for typechecking
hoAssumps :: HoTcInfo -> Map Name Type
hoFixities :: HoTcInfo -> FixityMap

-- | used for typechecking
hoKinds :: HoTcInfo -> KindEnv
hoTypeSynonyms :: HoTcInfo -> TypeSynonyms
hoClassHierarchy :: HoTcInfo -> ClassHierarchy
hoFieldMap :: HoTcInfo -> FieldMap
data HoBuild
HoBuild :: DataTable -> [(TVr, E)] -> Rules -> HoBuild

-- | Filled in by E generation
hoDataTable :: HoBuild -> DataTable
hoEs :: HoBuild -> [(TVr, E)]
hoRules :: HoBuild -> Rules
data Ho
Ho :: ModuleGroup -> HoTcInfo -> HoBuild -> Ho
hoModuleGroup :: Ho -> ModuleGroup
hoTcInfo :: Ho -> HoTcInfo
hoBuild :: Ho -> HoBuild
data ExtraFile
ExtraFile :: PackedString -> ByteString -> ExtraFile
extraFileName :: ExtraFile -> PackedString
extraFileData :: ExtraFile -> ByteString
choVarMap_s :: IntjectionMap Id (Maybe E) -> CollectedHo -> CollectedHo
choVarMap_u :: (IntjectionMap Id (Maybe E) -> IntjectionMap Id (Maybe E)) -> CollectedHo -> CollectedHo
choOrphanRules_s :: Rules -> CollectedHo -> CollectedHo
choOrphanRules_u :: (Rules -> Rules) -> CollectedHo -> CollectedHo
choLibDeps_s :: Map PackedString Hash -> CollectedHo -> CollectedHo
choLibDeps_u :: (Map PackedString Hash -> Map PackedString Hash) -> CollectedHo -> CollectedHo
choHoMap_s :: Map Module Ho -> CollectedHo -> CollectedHo
choHoMap_u :: (Map Module Ho -> Map Module Ho) -> CollectedHo -> CollectedHo
choHo_s :: Ho -> CollectedHo -> CollectedHo
choHo_u :: (Ho -> Ho) -> CollectedHo -> CollectedHo
choExternalNames_s :: IntjectionSet Id -> CollectedHo -> CollectedHo
choExternalNames_u :: (IntjectionSet Id -> IntjectionSet Id) -> CollectedHo -> CollectedHo
choCombinators_s :: IntjectionMap Id Comb -> CollectedHo -> CollectedHo
choCombinators_u :: (IntjectionMap Id Comb -> IntjectionMap Id Comb) -> CollectedHo -> CollectedHo
hoTypeSynonyms_s :: TypeSynonyms -> HoTcInfo -> HoTcInfo
hoTypeSynonyms_u :: (TypeSynonyms -> TypeSynonyms) -> HoTcInfo -> HoTcInfo
hoKinds_s :: KindEnv -> HoTcInfo -> HoTcInfo
hoKinds_u :: (KindEnv -> KindEnv) -> HoTcInfo -> HoTcInfo
hoFixities_s :: FixityMap -> HoTcInfo -> HoTcInfo
hoFixities_u :: (FixityMap -> FixityMap) -> HoTcInfo -> HoTcInfo
hoFieldMap_s :: FieldMap -> HoTcInfo -> HoTcInfo
hoFieldMap_u :: (FieldMap -> FieldMap) -> HoTcInfo -> HoTcInfo
hoExports_s :: Map Module [Name] -> HoTcInfo -> HoTcInfo
hoExports_u :: (Map Module [Name] -> Map Module [Name]) -> HoTcInfo -> HoTcInfo
hoDefs_s :: Map Name (SrcLoc, [Name]) -> HoTcInfo -> HoTcInfo
hoDefs_u :: (Map Name (SrcLoc, [Name]) -> Map Name (SrcLoc, [Name])) -> HoTcInfo -> HoTcInfo
hoClassHierarchy_s :: ClassHierarchy -> HoTcInfo -> HoTcInfo
hoClassHierarchy_u :: (ClassHierarchy -> ClassHierarchy) -> HoTcInfo -> HoTcInfo
hoAssumps_s :: Map Name Type -> HoTcInfo -> HoTcInfo
hoAssumps_u :: (Map Name Type -> Map Name Type) -> HoTcInfo -> HoTcInfo
hoRules_s :: Rules -> HoBuild -> HoBuild
hoRules_u :: (Rules -> Rules) -> HoBuild -> HoBuild
hoEs_s :: [(TVr' E, E)] -> HoBuild -> HoBuild
hoEs_u :: ([(TVr' E, E)] -> [(TVr' E, E)]) -> HoBuild -> HoBuild
hoDataTable_s :: DataTable -> HoBuild -> HoBuild
hoDataTable_u :: (DataTable -> DataTable) -> HoBuild -> HoBuild
hoTcInfo_s :: HoTcInfo -> Ho -> Ho
hoTcInfo_u :: (HoTcInfo -> HoTcInfo) -> Ho -> Ho
hoModuleGroup_s :: Module -> Ho -> Ho
hoModuleGroup_u :: (Module -> Module) -> Ho -> Ho
hoBuild_s :: HoBuild -> Ho -> Ho
hoBuild_u :: (HoBuild -> HoBuild) -> Ho -> Ho
instance [overlap ok] Monoid HoBuild
instance [overlap ok] Monoid HoTcInfo
instance [overlap ok] Monoid Ho
instance [overlap ok] Show Library

module Ho.Collected

-- | the collected information that is passed around this is not stored in
--   any file, but is what is collected from the ho files.
data CollectedHo
CollectedHo :: IdSet -> IdMap Comb -> Rules -> Map ModuleGroup Ho -> Map PackedString HoHash -> Ho -> IdMap (Maybe E) -> CollectedHo

-- | this is a list of external names that are valid but that we may not
--   know anything else about it is used to recognize invalid ids.
choExternalNames :: CollectedHo -> IdSet

-- | these are the functions in Comb form.
choCombinators :: CollectedHo -> IdMap Comb

-- | these are rules that may need to be retroactively applied to other
--   modules
choOrphanRules :: CollectedHo -> Rules

-- | the hos
choHoMap :: CollectedHo -> Map ModuleGroup Ho

-- | libraries depended on
choLibDeps :: CollectedHo -> Map PackedString HoHash

-- | these are caches of pre-computed values
choHo :: CollectedHo -> Ho

-- | cache of variable substitution map
choVarMap :: CollectedHo -> IdMap (Maybe E)
choDataTable :: CollectedHo -> DataTable
choClassHierarchy :: CollectedHo -> ClassHierarchy
choTypeSynonyms :: CollectedHo -> TypeSynonyms
choFixities :: CollectedHo -> FixityMap
choAssumps :: CollectedHo -> Map Name Type
choRules :: CollectedHo -> Rules
choEs :: CollectedHo -> [(TVr, E)]
updateChoHo :: CollectedHo -> CollectedHo
instance [overlap ok] Monoid CollectedHo

module FrontEnd.HsPretty
data PPLayout
PPOffsideRule :: PPLayout
PPSemiColon :: PPLayout
PPInLine :: PPLayout
PPNoLayout :: PPLayout
data PPHsMode
PPHsMode :: Indent -> Indent -> Indent -> Indent -> Indent -> Indent -> Bool -> PPLayout -> Bool -> PPHsMode
classIndent :: PPHsMode -> Indent
doIndent :: PPHsMode -> Indent
caseIndent :: PPHsMode -> Indent
letIndent :: PPHsMode -> Indent
whereIndent :: PPHsMode -> Indent
onsideIndent :: PPHsMode -> Indent
spacing :: PPHsMode -> Bool
layout :: PPHsMode -> PPLayout
comments :: PPHsMode -> Bool
render :: Doc -> String
ppHsModule :: HsModule -> Doc
ppHsDecl :: HsDecl -> Doc
ppHsDecls :: [HsDecl] -> Doc
ppHsExp :: HsExp -> Doc
ppHsStmt :: HsStmt -> Doc
ppHsPat :: HsPat -> Doc
ppHsAlt :: HsAlt -> Doc
ppGAlt :: HsGuardedRhs -> Doc
ppHsGuardedRhs :: HsGuardedRhs -> Doc
instance [overlap ok] Eq PPLayout
instance [overlap ok] PPrint Doc HsPat
instance [overlap ok] PPrint Doc HsTyVarBind
instance [overlap ok] PPrint Doc HsQualType
instance [overlap ok] PPrint Doc HsType
instance [overlap ok] PPrint Doc HsExp
instance [overlap ok] PPrint Doc HsDecl
instance [overlap ok] DocLike d => PPrint d HsKind
instance [overlap ok] PPrint Doc HsType
instance [overlap ok] DocLike Doc
instance [overlap ok] TextLike Doc
instance [overlap ok] Monad (DocM s)
instance [overlap ok] Functor (DocM s)

module FrontEnd.Tc.Monad
data CoerceTerm
CTId :: CoerceTerm
CTAp :: [Type] -> CoerceTerm
CTAbs :: [Tyvar] -> CoerceTerm
CTFun :: CoerceTerm -> CoerceTerm
CTCompose :: CoerceTerm -> CoerceTerm -> CoerceTerm
data Tc a

-- | information that is passed into the type checker.
data TcInfo
TcInfo :: TypeEnv -> TypeEnv -> Module -> KindEnv -> ClassHierarchy -> TcInfo
tcInfoEnv :: TcInfo -> TypeEnv
tcInfoSigEnv :: TcInfo -> TypeEnv
tcInfoModName :: TcInfo -> Module
tcInfoKindInfo :: TcInfo -> KindEnv
tcInfoClassHierarchy :: TcInfo -> ClassHierarchy
type TypeEnv = Map Name Sigma
data TcEnv
TcEnv :: TcInfo -> [Diagnostic] -> {-# UNPACK #-} !(IORef Int) -> {-# UNPACK #-} !(IORef (Map Name Sigma)) -> {-# UNPACK #-} !(IORef (Map Name CoerceTerm)) -> Map Name Sigma -> Map Name Sigma -> Set MetaVar -> Set Name -> InstanceEnv -> Opt -> TcEnv
tcInfo :: TcEnv -> TcInfo
tcDiagnostics :: TcEnv -> [Diagnostic]
tcVarnum :: TcEnv -> {-# UNPACK #-} !(IORef Int)
tcCollectedEnv :: TcEnv -> {-# UNPACK #-} !(IORef (Map Name Sigma))
tcCollectedCoerce :: TcEnv -> {-# UNPACK #-} !(IORef (Map Name CoerceTerm))
tcConcreteEnv :: TcEnv -> Map Name Sigma
tcMutableEnv :: TcEnv -> Map Name Sigma
tcCurrentScope :: TcEnv -> Set MetaVar
tcRecursiveCalls :: TcEnv -> Set Name
tcInstanceEnv :: TcEnv -> InstanceEnv
tcOptions :: TcEnv -> Opt
tcRecursiveCalls_u :: (Set Name -> Set Name) -> TcEnv -> TcEnv
data Output
Output :: !Preds -> !Preds -> !(Seq Constraint) -> !(Seq Rule) -> [Tyvar] -> !(Seq Warning) -> [(Name, Name)] -> Output
collectedPreds :: Output -> !Preds
existentialPreds :: Output -> !Preds
constraints :: Output -> !(Seq Constraint)
checkedRules :: Output -> !(Seq Rule)
existentialVars :: Output -> [Tyvar]
tcWarnings :: Output -> !(Seq Warning)
outKnots :: Output -> [(Name, Name)]
addCoerce :: Name -> CoerceTerm -> Tc ()
addPreds :: Preds -> Tc ()
composeCoerce :: CoerceTerm -> CoerceTerm -> CoerceTerm
addRule :: Rule -> Tc ()
addToCollectedEnv :: TypeEnv -> Tc ()
boxyInstantiate :: Sigma -> Tc ([Type], Rho')
boxySpec :: Sigma -> Tc ([(BoundTV, [Sigma'])], Rho')
deconstructorInstantiate :: Sigma -> Tc Rho'
freeMetaVarsEnv :: Tc (Set MetaVar)
freshInstance :: MetaVarType -> Sigma -> Tc ([Type], Rho)
freshSigma :: Sigma -> Tc Sigma
getClassHierarchy :: Tc ClassHierarchy
getCollectedEnv :: Tc TypeEnv
getCollectedCoerce :: Tc (Map Name CoerceTerm)
getDeName :: DeNameable n => Tc (n -> n)
getKindEnv :: Tc KindEnv
getSigEnv :: Tc TypeEnv
evalFullType :: (MonadIO m, MonadReader TcEnv m) => Type -> m Type
inst :: Instantiate a => Map Int Type -> Map Name Type -> a -> a
listenCheckedRules :: Tc a -> Tc (a, [Rule])
listenPreds :: Tc a -> Tc (a, Preds)
listenCPreds :: Tc a -> Tc (a, (Preds, [Constraint]))

-- | run a computation with a local environment
localEnv :: TypeEnv -> Tc a -> Tc a
lookupName :: Name -> Tc Sigma

-- | returns a new box and a function to read said box.
newBox :: Kind -> Tc Type
newMetaVar :: MetaVarType -> Kind -> Tc Type
newVar :: Kind -> Tc Tyvar
quantify :: [MetaVar] -> [Pred] -> Rho -> Tc Sigma
quantify_n :: [MetaVar] -> [Pred] -> [Rho] -> Tc [Sigma]
runTc :: (MonadIO m, OptionMonad m) => TcInfo -> Tc a -> m a

-- | replace bound variables with arbitrary new ones and drop the binding
--   TODO predicates?
skolomize :: Sigma -> Tc ([Tyvar], [Pred], Type)
tcInfoEmpty :: TcInfo
toSigma :: Sigma -> Sigma
unBox :: Type -> Tc Type
evalType :: (MonadIO m, MonadReader TcEnv m) => Type -> m Type
unificationError :: Type -> Type -> Tc b
varBind :: MetaVar -> Type -> Tc ()
zonkKind :: Kind -> MetaVar -> Tc MetaVar

-- | given a diagnostic and a computation to take place inside the
--   TI-monad, run the computation but during it have the diagnostic at the
--   top of the stack
withContext :: Diagnostic -> Tc a -> Tc a
withMetaVars :: MetaVar -> [Kind] -> ([Sigma] -> Sigma) -> ([Sigma'] -> Tc a) -> Tc a
instance [overlap ok] MonadFix Tc
instance [overlap ok] MonadIO Tc
instance [overlap ok] MonadReader TcEnv Tc
instance [overlap ok] MonadWriter Output Tc
instance [overlap ok] Functor Tc
instance [overlap ok] UniqueProducer Tc
instance [overlap ok] MonadSrcLoc Tc
instance [overlap ok] MonadWarn Tc
instance [overlap ok] Monad Tc
instance [overlap ok] Instantiate Pred
instance [overlap ok] Instantiate t => Instantiate (Qual t)
instance [overlap ok] Instantiate a => Instantiate [a]
instance [overlap ok] Instantiate Type
instance [overlap ok] OptionMonad Tc
instance [overlap ok] Monoid Output

module FrontEnd.Tc.Class
data Pred
data ClassHierarchy

-- | split predicates into ones that only mention metavars in the list vs
--   other ones
splitPreds :: Monad m => ClassHierarchy -> Set MetaVar -> Preds -> m (Preds, Preds)
generalize :: [Pred] -> Rho -> Tc Sigma
splitReduce :: Set MetaVar -> Set MetaVar -> [Pred] -> Tc ([MetaVar], [Pred], [Pred])
topDefaults :: [Pred] -> Tc ()
freeMetaVarsPreds :: Preds -> Set MetaVar
simplify :: ClassHierarchy -> [Pred] -> [Pred]
assertEntailment :: Preds -> Preds -> Tc ()
assertEquivalant :: Preds -> Preds -> Tc ()
type Preds = [Pred]

module FrontEnd.Tc.Unify

-- | this ensures the first argument is at least as polymorphic as the
--   second actual/offered &lt;= expected actual/offered <a>subsumes</a>
--   expected
subsumes :: Sigma' -> Sigma' -> Tc CoerceTerm
boxyMatch :: Sigma' -> Sigma' -> Tc ()
printRule :: String -> Tc ()
listenSolvePreds :: Tc a -> Tc (a, [Pred])

module FrontEnd.Tc.Main
tiExpr :: HsExp -> Type -> Tc HsExp
tiProgram :: [BindGroup] -> [HsDecl] -> Tc [HsDecl]

-- | make a program from a set of binding groups
makeProgram :: TypeEnv -> [[HsDecl]] -> [BindGroup]
isTypePlaceholder :: HsName -> Bool

module Ho.Binary
readHoFile :: FilePath -> IO (HoHeader, HoIDeps, Ho)
recordHoFile :: Ho -> HoIDeps -> [FilePath] -> HoHeader -> IO ()
readHlFile :: FilePath -> IO Library
recordHlFile :: Library -> IO ()
instance [overlap ok] Binary HoBuild
instance [overlap ok] Binary HoTcInfo
instance [overlap ok] Binary Version
instance [overlap ok] Binary HoLib
instance [overlap ok] Binary HoIDeps
instance [overlap ok] Binary HoHeader
instance [overlap ok] Binary FieldMap
instance [overlap ok] Binary ExtraFile

module FrontEnd.Tc.Module
tiModules :: HoTcInfo -> [ModInfo] -> IO (HoTcInfo, TiData)
data TiData
TiData :: [HsDecl] -> [(Module, HsModule)] -> [(Module, Opt)] -> [Rule] -> Map Name CoerceTerm -> Map Name Properties -> Map Name Type -> TiData
tiDataDecls :: TiData -> [HsDecl]
tiDataModules :: TiData -> [(Module, HsModule)]
tiModuleOptions :: TiData -> [(Module, Opt)]
tiCheckedRules :: TiData -> [Rule]
tiCoerce :: TiData -> Map Name CoerceTerm
tiProps :: TiData -> Map Name Properties
tiAllAssumptions :: TiData -> Map Name Type

module E.FromHs
convertDecls :: TiData -> IdMap Properties -> ClassHierarchy -> Map Name Type -> DataTable -> [HsDecl] -> IO [(Name, TVr, E)]
convertRules :: Module -> TiData -> ClassHierarchy -> Map Name Type -> DataTable -> [HsDecl] -> IO Rules

-- | create a RULE for each instance attached to the class methods. These
--   rules allow early specialization of monomorphic code, and are
--   eventually used in E.TypeAnalysis.expandPlaceholder to fill out the
--   generic class method bodies.
createInstanceRules :: Monad m => DataTable -> ClassHierarchy -> [(TVr, E)] -> m Rules
procAllSpecs :: Monad m => DataTable -> [Rule] -> [(TVr, E)] -> m ([(TVr, E)], Rules)
getMainFunction :: Monad m => DataTable -> Name -> (Map Name (TVr, E)) -> m (TVr, E)
instance [overlap ok] Monad C
instance [overlap ok] Functor C
instance [overlap ok] MonadIO C
instance [overlap ok] MonadReader CeEnv C
instance [overlap ok] MonadState Int C
instance [overlap ok] MonadError IOError C
instance [overlap ok] DataTableMonad C
instance [overlap ok] UniqueProducer C
instance [overlap ok] MonadSetSrcLoc C
instance [overlap ok] MonadSrcLoc C
instance [overlap ok] MonadWarn C
instance [overlap ok] GenName String

module FrontEnd.FrontEnd
doModules :: HoTcInfo -> [HsModule] -> IO (HoTcInfo, TiData)
data TiData
TiData :: [HsDecl] -> [(Module, HsModule)] -> [(Module, Opt)] -> [Rule] -> Map Name CoerceTerm -> Map Name Properties -> Map Name Type -> TiData
tiDataDecls :: TiData -> [HsDecl]
tiDataModules :: TiData -> [(Module, HsModule)]
tiModuleOptions :: TiData -> [(Module, Opt)]
tiCheckedRules :: TiData -> [Rule]
tiCoerce :: TiData -> Map Name CoerceTerm
tiProps :: TiData -> Map Name Properties
tiAllAssumptions :: TiData -> Map Name Type

module Ho.ReadSource
preprocess :: Opt -> FilePath -> ByteString -> IO ByteString
preprocessHs :: Opt -> FilePath -> ByteString -> IO ByteString
languageFlags :: [String] -> (Set Flag, Set Flag, [String])
fetchCompilerFlags :: IO (FilePath, [String])
parseHsSource :: Opt -> FilePath -> ByteString -> IO (HsModule, ByteString)

module Ho.Library
data LibDesc
LibDesc :: (Map String [String]) -> (Map String String) -> LibDesc
readDescFile :: FilePath -> IO LibDesc
collectLibraries :: [String] -> IO ([Library], [Library])
libModMap :: Library -> Map Module ModuleGroup
libHash :: Library -> HoHash
libMgHash :: Show t => t -> Library -> Hash
libProvides :: ModuleGroup -> Library -> [Module]
libName :: Library -> [Char]
libBaseName :: Library -> PackedString
libHoLib :: Library -> HoLib
preprocess :: Opt -> FilePath -> ByteString -> IO ByteString
listLibraries :: IO ()
instance [overlap ok] ToNode PackedString
instance [overlap ok] ToNode HoHash
instance [overlap ok] ToNode Module

module Ho.Build
dumpHoFile :: String -> IO ()
parseFiles :: Opt -> [FilePath] -> [String] -> [Either Module FilePath] -> (CollectedHo -> Ho -> IO CollectedHo) -> (CollectedHo -> Ho -> TiData -> IO (CollectedHo, Ho)) -> IO (CompNode, CollectedHo)
preprocess :: Opt -> FilePath -> ByteString -> IO ByteString
preprocessHs :: Opt -> FilePath -> ByteString -> IO ByteString
buildLibrary :: (CollectedHo -> Ho -> IO CollectedHo) -> (CollectedHo -> Ho -> TiData -> IO (CollectedHo, Ho)) -> FilePath -> IO ()
instance [overlap ok] DocLike d => PPrint d PackedString
instance [overlap ok] DocLike d => PPrint d Version
instance [overlap ok] DocLike d => PPrint d SrcLoc
instance [overlap ok] DocLike d => PPrint d Hash
instance [overlap ok] ProvidesModules SourceCode
instance [overlap ok] ProvidesModules CompLink
instance [overlap ok] ProvidesModules CompUnit
instance [overlap ok] ProvidesModules HoLib
instance [overlap ok] ProvidesModules HoIDeps
instance [overlap ok] Show CompUnit
instance [overlap ok] MapKey Hash
instance [overlap ok] MapKey Module

module E.Main
processInitialHo :: CollectedHo -> Ho -> IO CollectedHo
processDecls :: CollectedHo -> Ho -> TiData -> IO (CollectedHo, Ho)
compileWholeProgram :: Program -> IO Program
dumpRules :: Rules -> IO ()

module Interactive
interact :: CollectedHo -> IO ()
isInteractive :: IO Bool
instance [overlap ok] MonadIO In
instance [overlap ok] Monad In
instance [overlap ok] Functor In
instance [overlap ok] MonadReader InteractiveState In
instance [overlap ok] MonadWarn In
instance [overlap ok] OptionMonad In

module Grin.FromE
compile :: Program -> IO Grin
instance [overlap ok] Monad C
instance [overlap ok] MonadReader LEnv C
instance [overlap ok] UniqueProducer C
instance [overlap ok] Functor C
instance [overlap ok] MonadIO C
instance [overlap ok] MonadStats C
instance [overlap ok] ToVal TVr
instance [overlap ok] Keepable Val
instance [overlap ok] Keepable Ty
instance [overlap ok] ToCmmTy E
instance [overlap ok] ToCmmTy Name

module Grin.Main
compileToGrin :: Program -> IO ()
