-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Solve Lagrange multiplier problems
--   
@package lagrangian
@version 0.6.0.1


-- | Numerically solve convex Lagrange-multiplier problems with conjugate
--   gradient descent.
--   
--   Consider an example from the Wikipedia page on Lagrange multipliers in
--   which we want to maximize the function f(x, y) = x + y, subject to the
--   constraint x^2 + y^2 = 1:
--   
--   <pre>
--   &gt;&gt;&gt; maximize (\[x, y] -&gt; x + y) [(\[x, y] -&gt; x^2 + y^2) &lt;=&gt; 1] 0.00001 2
--   Right ([0.707,0.707], [-0.707])
--   </pre>
--   
--   The <a>Right</a> indicates success; the first element of the pair is
--   the argument of the objective function at the maximum, and the second
--   element is a list of Lagrange multipliers.
module Numeric.AD.Lagrangian

-- | An equality constraint of the form <tt>g(x, y, ...) = c</tt>. Use
--   <a>&lt;=&gt;</a> to construct a <a>Constraint</a>.
data Constraint

-- | Build a <a>Constraint</a> from a function and a constant
(<=>) :: (forall a. Floating a => [a] -> a) -> (forall b. Floating b => b) -> Constraint

-- | Numerically maximize the Langrangian. The objective function and each
--   of the constraints must take the same number of arguments.
maximize :: (forall a. Floating a => [a] -> a) -> [Constraint] -> Double -> Int -> Either (Result, Statistics) (Vector Double, Vector Double)

-- | Numerically minimize the Langrangian. The objective function and each
--   of the constraints must take the same number of arguments.
minimize :: (forall a. Floating a => [a] -> a) -> [Constraint] -> Double -> Int -> Either (Result, Statistics) (Vector Double, Vector Double)

-- | WARNING: Experimental. This is not a true feasibility test for the
--   function. I am not sure exactly how to implement that. This just
--   checks the feasiblility at a point. If this ever returns false,
--   <tt>solve</tt> can fail.
feasible :: (Floating a, Field a, Element a) => (forall b. Floating b => [b] -> b) -> [Constraint] -> [a] -> Bool
