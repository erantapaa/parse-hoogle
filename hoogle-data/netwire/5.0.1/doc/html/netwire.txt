-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functional reactive programming library
--   
--   This library provides interfaces for and implements wire arrows useful
--   both for functional reactive programming (FRP) and locally stateful
--   programming (LSP).
@package netwire
@version 5.0.1


module FRP.Netwire.Utils.Timeline

-- | A time line is a non-empty set of samples together with time
--   information.
data Timeline t a

-- | Insert the given data point.
insert :: Ord t => t -> a -> Timeline t a -> Timeline t a

-- | Singleton timeline with the given point.
singleton :: t -> a -> Timeline t a

-- | Union of two time lines. Right-biased.
union :: Ord t => Timeline t a -> Timeline t a -> Timeline t a

-- | Linearly interpolate the points in the time line, integrate the given
--   time interval of the graph, divide by the interval length.
linAvg :: (Fractional a, Fractional t, Real t) => t -> t -> Timeline t a -> a

-- | Cut the timeline at the given point in time <tt>t</tt>, such that all
--   samples up to but not including <tt>t</tt> are forgotten. The most
--   recent sample before <tt>t</tt> is moved and interpolated accordingly.
linCutL :: (Fractional a, Fractional t, Real t) => t -> Timeline t a -> Timeline t a

-- | Cut the timeline at the given point in time <tt>t</tt>, such that all
--   samples later than <tt>t</tt> are forgotten. The most recent sample
--   after <tt>t</tt> is moved and interpolated accordingly.
linCutR :: (Fractional a, Fractional t, Real t) => t -> Timeline t a -> Timeline t a

-- | Look up with linear sampling.
linLookup :: (Fractional a, Fractional t, Real t) => t -> Timeline t a -> a

-- | Integrate the given time interval of the staircase, divide by the
--   interval length.
scAvg :: (Fractional a, Real t) => t -> t -> Timeline t a -> a

-- | Cut the timeline at the given point in time <tt>t</tt>, such that all
--   samples up to but not including <tt>t</tt> are forgotten. The most
--   recent sample before <tt>t</tt> is moved accordingly.
scCutL :: Ord t => t -> Timeline t a -> Timeline t a

-- | Cut the timeline at the given point in time <tt>t</tt>, such that all
--   samples later than <tt>t</tt> are forgotten. The earliest sample after
--   <tt>t</tt> is moved accordingly.
scCutR :: Ord t => t -> Timeline t a -> Timeline t a

-- | Look up on staircase.
scLookup :: Ord t => t -> Timeline t a -> a
instance Typeable Timeline
instance (Data t, Data a, Ord t) => Data (Timeline t a)
instance (Eq t, Eq a) => Eq (Timeline t a)
instance (Ord t, Ord a) => Ord (Timeline t a)
instance (Ord t, Read t, Read a) => Read (Timeline t a)
instance (Show t, Show a) => Show (Timeline t a)
instance Functor (Timeline t)


module Control.Wire.Session

-- | State delta types with time deltas.
class (Monoid s, Real t) => HasTime t s | s -> t
dtime :: HasTime t s => s -> t

-- | State delta generators as required for wire sessions, most notably to
--   generate time deltas. These are mini-wires with the sole purpose of
--   generating these deltas.
newtype Session m s
Session :: m (s, Session m s) -> Session m s
stepSession :: Session m s -> m (s, Session m s)

-- | This state delta type denotes time deltas. This is necessary for most
--   FRP applications.
data Timed t s
Timed :: t -> s -> Timed t s

-- | State delta generator for a real time clock.
clockSession :: MonadIO m => Session m (s -> Timed NominalDiffTime s)

-- | Non-extending version of <a>clockSession</a>.
clockSession_ :: (Applicative m, MonadIO m) => Session m (Timed NominalDiffTime ())

-- | State delta generator for a simple counting clock. Denotes a fixed
--   framerate. This is likely more useful than <a>clockSession</a> for
--   simulations and real-time games.
countSession :: Applicative m => t -> Session m (s -> Timed t s)

-- | Non-extending version of <a>countSession</a>.
countSession_ :: Applicative m => t -> Session m (Timed t ())
instance Typeable Timed
instance Functor m => Functor (Session m)
instance (Data t, Data s) => Data (Timed t s)
instance (Eq t, Eq s) => Eq (Timed t s)
instance Foldable (Timed t)
instance Functor (Timed t)
instance (Ord t, Ord s) => Ord (Timed t s)
instance (Read t, Read s) => Read (Timed t s)
instance (Show t, Show s) => Show (Timed t s)
instance Traversable (Timed t)
instance (Monoid s, Num t) => Monoid (Timed t s)
instance (Monoid s, Real t) => HasTime t (Timed t s)
instance Applicative m => Applicative (Session m)


module Control.Wire.Core

-- | A wire is a signal function. It maps a reactive value to another
--   reactive value.
data Wire s e m a b
WArr :: (Either e a -> Either e b) -> Wire s e m a b
WConst :: Either e b -> Wire s e m a b
WGen :: (s -> Either e a -> m (Either e b, Wire s e m a b)) -> Wire s e m a b
WId :: Wire s e m a a
WPure :: (s -> Either e a -> (Either e b, Wire s e m a b)) -> Wire s e m a b

-- | Perform one step of the given wire.
stepWire :: Monad m => Wire s e m a b -> s -> Either e a -> m (Either e b, Wire s e m a b)

-- | Construct a stateless wire from the given signal mapping function.
mkConst :: Either e b -> Wire s e m a b

-- | Construct the empty wire, which inhibits forever.
mkEmpty :: Monoid e => Wire s e m a b

-- | Construct a stateful wire from the given transition function.
mkGen :: (Monad m, Monoid s) => (s -> a -> m (Either e b, Wire s e m a b)) -> Wire s e m a b

-- | Construct a stateless wire from the given transition function.
mkGen_ :: Monad m => (a -> m (Either e b)) -> Wire s e m a b

-- | Construct a stateful wire from the given transition function.
mkGenN :: Monad m => (a -> m (Either e b, Wire s e m a b)) -> Wire s e m a b

-- | Construct the identity wire.
mkId :: Wire s e m a a

-- | Construct a pure stateful wire from the given transition function.
mkPure :: Monoid s => (s -> a -> (Either e b, Wire s e m a b)) -> Wire s e m a b

-- | Construct a pure stateless wire from the given transition function.
mkPure_ :: (a -> Either e b) -> Wire s e m a b

-- | Construct a pure stateful wire from the given transition function.
mkPureN :: (a -> (Either e b, Wire s e m a b)) -> Wire s e m a b

-- | Construct a pure stateful wire from the given signal function.
mkSF :: Monoid s => (s -> a -> (b, Wire s e m a b)) -> Wire s e m a b

-- | Construct a pure stateless wire from the given function.
mkSF_ :: (a -> b) -> Wire s e m a b

-- | Construct a pure stateful wire from the given signal function.
mkSFN :: (a -> (b, Wire s e m a b)) -> Wire s e m a b

-- | This wire delays its input signal by the smallest possible
--   (semantically infinitesimal) amount of time. You can use it when you
--   want to use feedback (<a>ArrowLoop</a>): If the user of the feedback
--   depends on <i>now</i>, delay the value before feeding it back. The
--   argument value is the replacement signal at the beginning.
--   
--   <ul>
--   <li>Depends: before now.</li>
--   </ul>
delay :: a -> Wire s e m a a

-- | Evaluate the input signal using the given <a>Strategy</a> here. This
--   wire evaluates only produced values.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
evalWith :: Strategy a -> Wire s e m a a

-- | Force the input signal to WHNF here. This wire forces both produced
--   values and inhibition values.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
force :: Wire s e m a a

-- | Force the input signal to NF here. This wire forces only produced
--   values.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
forceNF :: NFData a => Wire s e m a a

-- | Left-strict version of <a>&amp;&amp;&amp;</a> for functions.
(&&&!) :: (a -> b) -> (a -> c) -> (a -> (b, c))

-- | Left-strict version of <a>***</a> for functions.
(***!) :: (a -> c) -> (b -> d) -> ((a, b) -> (c, d))

-- | Left-strict tuple.
lstrict :: (a, b) -> (a, b)

-- | Apply the given monad morphism to the wire's underlying monad.
mapWire :: (Monad m', Monad m) => (forall a. m' a -> m a) -> Wire s e m' a b -> Wire s e m a b
instance (Monad m, Monoid e) => Strong (Wire s e m)
instance (Monad m, Semigroup b) => Semigroup (Wire s e m a b)
instance Monad m => Profunctor (Wire s e m)
instance (Monad m, Num b) => Num (Wire s e m a b)
instance (Monad m, Monoid b) => Monoid (Wire s e m a b)
instance (Monad m, IsString b) => IsString (Wire s e m a b)
instance Monad m => Functor (Wire s e m a)
instance (Monad m, Fractional b) => Fractional (Wire s e m a b)
instance (Monad m, Floating b) => Floating (Wire s e m a b)
instance (Monad m, Monoid e) => Choice (Wire s e m)
instance Monad m => Category (Wire s e m)
instance (Monad m, Monoid e) => ArrowZero (Wire s e m)
instance (Monad m, Monoid e) => ArrowPlus (Wire s e m)
instance MonadFix m => ArrowLoop (Wire s e m)
instance (Monad m, Monoid e) => ArrowChoice (Wire s e m)
instance Monad m => Arrow (Wire s e m)
instance Monad m => Applicative (Wire s e m a)
instance (Monad m, Monoid e) => Alternative (Wire s e m a)


module Control.Wire.Run

-- | This function runs the given wire using the given state delta
--   generator. It constantly shows the output of the wire on one line on
--   stdout. Press Ctrl-C to abort.
testWire :: (MonadIO m, Show b, Show e) => Session m s -> (forall a. Wire s e Identity a b) -> m c

-- | This function runs the given wire using the given state delta
--   generator. It constantly shows the output of the wire on one line on
--   stdout. Press Ctrl-C to abort.
testWireM :: (Monad m', MonadIO m, Show b, Show e) => (forall a. m' a -> m a) -> Session m s -> (forall a. Wire s e m' a b) -> m c


module Control.Wire.Time

-- | Local time starting from zero.
time :: HasTime t s => Wire s e m a t

-- | Local time starting from zero, converted to your favorite fractional
--   type.
timeF :: (Fractional b, HasTime t s, Monad m) => Wire s e m a b

-- | Local time starting from the given value.
timeFrom :: HasTime t s => t -> Wire s e m a t


module Control.Wire.Unsafe.Event

-- | Denotes a stream of values, each together with time of occurrence.
--   Since <a>Event</a> is commonly used for functional reactive
--   programming it does not define most of the usual instances to protect
--   continuous time and discrete event occurrence semantics.
data Event a
Event :: a -> Event a
NoEvent :: Event a

-- | Fold the given event.
event :: b -> (a -> b) -> Event a -> b

-- | Merge two events using the given function when both occur at the same
--   time.
merge :: (a -> a -> a) -> Event a -> Event a -> Event a

-- | Did the given event occur?
occurred :: Event a -> Bool

-- | Each time the given event occurs, perform the given action with the
--   value the event carries. The resulting event carries the result of the
--   action.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
onEventM :: Monad m => (a -> m b) -> Wire s e m (Event a) (Event b)
instance Typeable Event
instance Semigroup a => Semigroup (Event a)
instance NFData a => NFData (Event a)
instance Semigroup a => Monoid (Event a)
instance Functor Event


module Control.Wire.Event

-- | Denotes a stream of values, each together with time of occurrence.
--   Since <a>Event</a> is commonly used for functional reactive
--   programming it does not define most of the usual instances to protect
--   continuous time and discrete event occurrence semantics.
data Event a

-- | At the given point in time.
--   
--   <ul>
--   <li>Depends: now when occurring.</li>
--   </ul>
at :: HasTime t s => t -> Wire s e m a (Event a)

-- | Never occurs.
never :: Wire s e m a (Event b)

-- | Occurs once immediately.
--   
--   <ul>
--   <li>Depends: now when occurring.</li>
--   </ul>
now :: Wire s e m a (Event a)

-- | Periodic occurrence with the given time period. First occurrence is
--   now.
--   
--   <ul>
--   <li>Depends: now when occurring.</li>
--   </ul>
periodic :: HasTime t s => t -> Wire s e m a (Event a)

-- | Periodic occurrence with the given time period. First occurrence is
--   now. The event values are picked one by one from the given list. When
--   the list is exhausted, the event does not occur again.
periodicList :: HasTime t s => t -> [b] -> Wire s e m a (Event b)

-- | Occurs each time the predicate becomes true for the input signal, for
--   example each time a given threshold is reached.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
became :: (a -> Bool) -> Wire s e m a (Event a)

-- | Occurs each time the predicate becomes false for the input signal, for
--   example each time a given threshold is no longer exceeded.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
noLonger :: (a -> Bool) -> Wire s e m a (Event a)

-- | Events occur first when the predicate is false then when it is true,
--   and then this pattern repeats.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
edge :: (a -> Bool) -> Wire s e m a (Event a)

-- | Merge events with the leftmost event taking precedence. Equivalent to
--   using the monoid interface with <tt>First</tt>. Infixl 5.
--   
--   <ul>
--   <li>Depends: now on both.</li>
--   <li>Inhibits: when any of the two wires inhibit.</li>
--   </ul>
(<&) :: Monad m => Wire s e m a (Event b) -> Wire s e m a (Event b) -> Wire s e m a (Event b)

-- | Merge events with the rightmost event taking precedence. Equivalent to
--   using the monoid interface with <tt>Last</tt>. Infixl 5.
--   
--   <ul>
--   <li>Depends: now on both.</li>
--   <li>Inhibits: when any of the two wires inhibit.</li>
--   </ul>
(&>) :: Monad m => Wire s e m a (Event b) -> Wire s e m a (Event b) -> Wire s e m a (Event b)

-- | Forget the first given number of occurrences.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
dropE :: Int -> Wire s e m (Event a) (Event a)

-- | Forget all initial occurrences until the given predicate becomes
--   false.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
dropWhileE :: (a -> Bool) -> Wire s e m (Event a) (Event a)

-- | Forget all occurrences for which the given predicate is false.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
filterE :: (a -> Bool) -> Wire s e m (Event a) (Event a)

-- | Merge two events using the given function when both occur at the same
--   time.
merge :: (a -> a -> a) -> Event a -> Event a -> Event a

-- | Left-biased event merge.
mergeL :: Event a -> Event a -> Event a

-- | Right-biased event merge.
mergeR :: Event a -> Event a -> Event a

-- | Forget the first occurrence.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
notYet :: Wire s e m (Event a) (Event a)

-- | Forget all occurrences except the first.
--   
--   <ul>
--   <li>Depends: now when occurring.</li>
--   </ul>
once :: Wire s e m (Event a) (Event a)

-- | Forget all but the first given number of occurrences.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
takeE :: Int -> Wire s e m (Event a) (Event a)

-- | Forget all but the initial occurrences for which the given predicate
--   is true.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
takeWhileE :: (a -> Bool) -> Wire s e m (Event a) (Event a)

-- | Left scan for events. Each time an event occurs, apply the given
--   function.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
accumE :: (b -> a -> b) -> b -> Wire s e m (Event a) (Event b)

-- | Left scan for events with no initial value. Each time an event occurs,
--   apply the given function. The first event is produced unchanged.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
accum1E :: (a -> a -> a) -> Wire s e m (Event a) (Event a)

-- | On each occurrence, apply the function the event carries.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
iterateE :: a -> Wire s e m (Event (a -> a)) (Event a)

-- | Maximum of all events.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
maximumE :: Ord a => Wire s e m (Event a) (Event a)

-- | Minimum of all events.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
minimumE :: Ord a => Wire s e m (Event a) (Event a)

-- | Product of all events.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
productE :: Num a => Wire s e m (Event a) (Event a)

-- | Sum of all events.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
sumE :: Num a => Wire s e m (Event a) (Event a)


module Control.Wire.Interval

-- | Inhibit forever with the given value.
--   
--   <ul>
--   <li>Inhibits: always.</li>
--   </ul>
inhibit :: e -> Wire s e m a b

-- | After the given time period.
--   
--   <ul>
--   <li>Depends: now after the given time period.</li>
--   <li>Inhibits: for the given time period.</li>
--   </ul>
after :: (HasTime t s, Monoid e) => t -> Wire s e m a a

-- | For the given time period.
--   
--   <ul>
--   <li>Depends: now for the given time period.</li>
--   <li>Inhibits: after the given time period.</li>
--   </ul>
for :: (HasTime t s, Monoid e) => t -> Wire s e m a a

-- | When the given predicate is false for the input signal.
--   
--   <ul>
--   <li>Depends: now.</li>
--   <li>Inhibits: unless the predicate is false.</li>
--   </ul>
unless :: Monoid e => (a -> Bool) -> Wire s e m a a

-- | When the given predicate is true for the input signal.
--   
--   <ul>
--   <li>Depends: now.</li>
--   <li>Inhibits: when the predicate is false.</li>
--   </ul>
when :: Monoid e => (a -> Bool) -> Wire s e m a a

-- | Alias for <a>hold</a>.
asSoonAs :: Monoid e => Wire s e m (Event a) a

-- | Start each time the left event occurs, stop each time the right event
--   occurs.
--   
--   <ul>
--   <li>Depends: now when active.</li>
--   <li>Inhibits: after the right event occurred, before the left event
--   occurs.</li>
--   </ul>
between :: Monoid e => Wire s e m (a, Event b, Event c) a

-- | Start when the event occurs for the first time reflecting its latest
--   value.
--   
--   <ul>
--   <li>Depends: now.</li>
--   <li>Inhibits: until the event occurs for the first time.</li>
--   </ul>
hold :: Monoid e => Wire s e m (Event a) a

-- | Hold each event occurrence for the given time period. Inhibits when no
--   event occurred for the given amount of time. New occurrences override
--   old occurrences, even when they are still held.
--   
--   <ul>
--   <li>Depends: now.</li>
--   <li>Inhibits: when no event occurred for the given amount of
--   time.</li>
--   </ul>
holdFor :: (HasTime t s, Monoid e) => t -> Wire s e m (Event a) a

-- | Produce until the given event occurs. When it occurs, inhibit with its
--   value forever.
--   
--   <ul>
--   <li>Depends: now until event occurs.</li>
--   <li>Inhibits: forever after event occurs.</li>
--   </ul>
until :: Monoid e => Wire s e m (a, Event b) a


module Control.Wire.Switch

-- | Acts like the first wire until it inhibits, then switches to the
--   second wire. Infixr 1.
--   
--   <ul>
--   <li>Depends: like current wire.</li>
--   <li>Inhibits: after switching like the second wire.</li>
--   <li>Switch: now.</li>
--   </ul>
(-->) :: Monad m => Wire s e m a b -> Wire s e m a b -> Wire s e m a b

-- | Acts like the first wire until the second starts producing, at which
--   point it switches to the second wire. Infixr 1.
--   
--   <ul>
--   <li>Depends: like current wire.</li>
--   <li>Inhibits: after switching like the second wire.</li>
--   <li>Switch: now.</li>
--   </ul>
(>--) :: Monad m => Wire s e m a b -> Wire s e m a b -> Wire s e m a b

-- | Route the left input signal based on the current mode. The right input
--   signal can be used to change the current mode. When switching away
--   from a mode and then switching back to it, it will be resumed. Freezes
--   time during inactivity.
--   
--   <ul>
--   <li>Complexity: O(n * log n) space, O(log n) lookup time on switch wrt
--   number of started, inactive modes.</li>
--   <li>Depends: like currently active wire (left), now (right).</li>
--   <li>Inhibits: when active wire inhibits.</li>
--   <li>Switch: now on mode change.</li>
--   </ul>
modes :: (Monad m, Ord k) => k -> (k -> Wire s e m a b) -> Wire s e m (a, Event k) b

-- | Intrinsic switch: Start with the given wire. As soon as its event
--   occurs, switch to the wire in the event's value.
--   
--   <ul>
--   <li>Inhibits: like argument wire until switch, then like the new
--   wire.</li>
--   <li>Switch: once, now, restart state.</li>
--   </ul>
switch :: (Monad m, Monoid s) => Wire s e m a (b, Event (Wire s e m a b)) -> Wire s e m a b

-- | Intrinsic switch: Delayed version of <a>switch</a>.
--   
--   <ul>
--   <li>Inhibits: like argument wire until switch, then like the new
--   wire.</li>
--   <li>Switch: once, after now, restart state.</li>
--   </ul>
dSwitch :: Monad m => Wire s e m a (b, Event (Wire s e m a b)) -> Wire s e m a b

-- | Intrinsic continuable switch: <tt>kSwitch w1 w2</tt> starts with
--   <tt>w1</tt>. Its signal is received by <tt>w2</tt>, which may choose
--   to switch to a new wire. Passes the wire we are switching away from to
--   the new wire, such that it may be reused in it.
--   
--   <ul>
--   <li>Inhibits: like the first argument wire, like the new wire after
--   switch. Inhibition of the second argument wire is ignored.</li>
--   <li>Switch: once, now, restart state.</li>
--   </ul>
kSwitch :: (Monad m, Monoid s) => Wire s e m a b -> Wire s e m (a, b) (Event (Wire s e m a b -> Wire s e m a b)) -> Wire s e m a b

-- | Intrinsic continuable switch: Delayed version of <a>kSwitch</a>.
--   
--   <ul>
--   <li>Inhibits: like the first argument wire, like the new wire after
--   switch. Inhibition of the second argument wire is ignored.</li>
--   <li>Switch: once, after now, restart state.</li>
--   </ul>
dkSwitch :: Monad m => Wire s e m a b -> Wire s e m (a, b) (Event (Wire s e m a b -> Wire s e m a b)) -> Wire s e m a b

-- | Extrinsic switch: Start with the given wire. Each time the input event
--   occurs, switch to the wire it carries.
--   
--   <ul>
--   <li>Inhibits: like the current wire.</li>
--   <li>Switch: recurrent, now, restart state.</li>
--   </ul>
rSwitch :: Monad m => Wire s e m a b -> Wire s e m (a, Event (Wire s e m a b)) b

-- | Extrinsic switch: Delayed version of <a>rSwitch</a>.
--   
--   <ul>
--   <li>Inhibits: like the current wire.</li>
--   <li>Switch: recurrent, after now, restart state.</li>
--   </ul>
drSwitch :: Monad m => Wire s e m a b -> Wire s e m (a, Event (Wire s e m a b)) b

-- | Acts like the first wire until an event occurs then switches to the
--   second wire. Behaves like this wire until the event occurs at which
--   point a *new* instance of the first wire is switched to.
--   
--   <ul>
--   <li>Depends: like current wire.</li>
--   <li>Inhibits: like the argument wires.</li>
--   <li>Switch: once, now, restart state.</li>
--   </ul>
alternate :: Monad m => Wire s e m a b -> Wire s e m a b -> Wire s e m (a, Event x) b

-- | Extrinsic continuable switch. This switch works like <a>rSwitch</a>,
--   except that it passes the wire we are switching away from to the new
--   wire.
--   
--   <ul>
--   <li>Inhibits: like the current wire.</li>
--   <li>Switch: recurrent, now, restart state.</li>
--   </ul>
krSwitch :: Monad m => Wire s e m a b -> Wire s e m (a, Event (Wire s e m a b -> Wire s e m a b)) b

-- | Extrinsic continuable switch. Delayed version of <a>krSwitch</a>.
--   
--   <ul>
--   <li>Inhibits: like the current wire.</li>
--   <li>Switch: recurrent, after now, restart state.</li>
--   </ul>
dkrSwitch :: Monad m => Wire s e m a b -> Wire s e m (a, Event (Wire s e m a b -> Wire s e m a b)) b


module Control.Wire

-- | Pure wires.
type WireP s e = Wire s e Identity

-- | Simple wires with time.
type SimpleWire = Wire (Timed NominalDiffTime ()) () Identity

-- | Identity functor and monad.
newtype Identity a :: * -> *
Identity :: a -> Identity a
runIdentity :: Identity a -> a

-- | This is a length of time, as measured by UTC. Conversion functions
--   will treat it as seconds. It has a precision of 10^-12 s. It ignores
--   leap-seconds, so it's not necessarily a fixed amount of clock time.
--   For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1
--   day), regardless of whether a leap-second intervened.
data NominalDiffTime :: *


module FRP.Netwire.Analyze

-- | Calculate the average of the signal over the given interval (from
--   now). This is done by calculating the integral of the corresponding
--   linearly interpolated graph and dividing it by the interval length.
--   See <a>linAvg</a> for details.
--   
--   Linear interpolation can be slow. If you don't need it, you can use
--   the staircase variant <a>sAvg</a>.
--   
--   Example: <tt>lAvg 2</tt>
--   
--   <ul>
--   <li>Complexity: O(s) space, O(s) time wrt number of samples in the
--   interval.</li>
--   <li>Depends: now.</li>
--   </ul>
lAvg :: (Fractional a, Fractional t, HasTime t s) => t -> Wire s e m a a

-- | Produce a linearly interpolated graph for the given points in time,
--   where the magnitudes of the points are distances from <i>now</i>.
--   
--   Linear interpolation can be slow. If you don't need it, you can use
--   the faster staircase variant <a>sGraph</a>.
--   
--   Example: <tt>lGraph [0, 1, 2]</tt> will output the interpolated inputs
--   at <i>now</i>, one second before now and two seconds before now.
--   
--   <ul>
--   <li>Complexity: O(s) space, O(n * log s) time, where s = number of
--   samples in the interval, n = number of requested data points.</li>
--   <li>Depends: now.</li>
--   </ul>
lGraph :: (Fractional a, Fractional t, HasTime t s) => [t] -> Wire s e m a [a]

-- | Graph the given interval from now with the given number of evenly
--   distributed points in time. Convenience interface to <a>lGraph</a>.
--   
--   Linear interpolation can be slow. If you don't need it, you can use
--   the faster staircase variant <a>sGraphN</a>.
--   
--   <ul>
--   <li>Complexity: O(s) space, O(n * log s) time, where s = number of
--   samples in the interval, n = number of requested data points.</li>
--   <li>Depends: now.</li>
--   </ul>
lGraphN :: (Fractional a, Fractional t, HasTime t s) => t -> Int -> Wire s e m a [a]

-- | Calculate the average of the signal over the given interval (from
--   now). This is done by calculating the integral of the corresponding
--   staircase graph and dividing it by the interval length. See
--   <a>scAvg</a> for details.
--   
--   See also <a>lAvg</a>.
--   
--   Example: <tt>sAvg 2</tt>
--   
--   <ul>
--   <li>Complexity: O(s) space, O(s) time wrt number of samples in the
--   interval.</li>
--   <li>Depends: now.</li>
--   </ul>
sAvg :: (Fractional a, Fractional t, HasTime t s) => t -> Wire s e m a a

-- | Produce a staircase graph for the given points in time, where the
--   magnitudes of the points are distances from <i>now</i>.
--   
--   See also <a>lGraph</a>.
--   
--   Example: <tt>sGraph [0, 1, 2]</tt> will output the inputs at
--   <i>now</i>, one second before now and two seconds before now.
--   
--   <ul>
--   <li>Complexity: O(s) space, O(n * log s) time, where s = number of
--   samples in the interval, n = number of requested data points.</li>
--   <li>Depends: now.</li>
--   </ul>
sGraph :: (Fractional t, HasTime t s) => [t] -> Wire s e m a [a]

-- | Graph the given interval from now with the given number of evenly
--   distributed points in time. Convenience interface to <a>sGraph</a>.
--   
--   See also <a>lGraphN</a>.
--   
--   <ul>
--   <li>Complexity: O(s) space, O(n * log s) time, where s = number of
--   samples in the interval, n = number of requested data points.</li>
--   <li>Depends: now.</li>
--   </ul>
sGraphN :: (Fractional t, HasTime t s) => t -> Int -> Wire s e m a [a]

-- | High peak.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
highPeak :: Ord a => Wire s e m a a

-- | High peak with respect to the given comparison function.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
highPeakBy :: (a -> a -> Ordering) -> Wire s e m a a

-- | Low peak.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
lowPeak :: Ord a => Wire s e m a a

-- | Low peak with respect to the given comparison function.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
lowPeakBy :: (a -> a -> Ordering) -> Wire s e m a a

-- | Average framerate over the last given number of samples. One important
--   thing to note is that the value of this wire will generally disagree
--   with <a>sAvg</a> composed with <a>framerate</a>. This is expected,
--   because this wire simply calculates the arithmetic mean, whereas
--   <a>sAvg</a> will actually integrate the framerate graph.
--   
--   Note: This wire is for debugging purposes only, because it exposes
--   discrete time. Do not taint your application with discrete time.
--   
--   <ul>
--   <li>Complexity: O(n) time and space wrt number of samples.</li>
--   </ul>
avgFps :: (RealFloat b, HasTime t s) => Int -> Wire s e m a b

-- | Current framerate.
--   
--   Note: This wire is for debugging purposes only, because it exposes
--   discrete time. Do not taint your application with discrete time.
--   
--   <ul>
--   <li>Inhibits: when the clock stopped ticking.</li>
--   </ul>
framerate :: (Eq b, Fractional b, HasTime t s, Monoid e) => Wire s e m a b


module FRP.Netwire.Move

-- | Time derivative of the input signal.
--   
--   <ul>
--   <li>Depends: now.</li>
--   <li>Inhibits: at singularities.</li>
--   </ul>
derivative :: (RealFloat a, HasTime t s, Monoid e) => Wire s e m a a

-- | Integrate the input signal over time.
--   
--   <ul>
--   <li>Depends: before now.</li>
--   </ul>
integral :: (Fractional a, HasTime t s) => a -> Wire s e m a a

-- | Integrate the left input signal over time, but apply the given
--   correction function to it. This can be used to implement collision
--   detection/reaction.
--   
--   The right signal of type <tt>w</tt> is the <i>world value</i>. It is
--   just passed to the correction function for reference and is not used
--   otherwise.
--   
--   The correction function must be idempotent with respect to the world
--   value: <tt>f w (f w x) = f w x</tt>. This is necessary and sufficient
--   to protect time continuity.
--   
--   <ul>
--   <li>Depends: before now.</li>
--   </ul>
integralWith :: (Fractional a, HasTime t s) => (w -> a -> a) -> a -> Wire s e m (a, w) a


module FRP.Netwire.Noise

-- | Noise events with the given distance between events. Use <a>hold</a>
--   or <a>holdFor</a> to generate a staircase.
noise :: (HasTime t s, Random b, RandomGen g) => t -> g -> Wire s e m a (Event b)

-- | Noise events with the given distance between events. Noise will be in
--   the given range. Use <a>hold</a> or <a>holdFor</a> to generate a
--   staircase.
noiseR :: (HasTime t s, Random b, RandomGen g) => t -> (b, b) -> g -> Wire s e m a (Event b)

-- | Randomly produce or inhibit with the given probability, each time for
--   the given duration.
--   
--   The name <i>Wackelkontakt</i> (German for <i>slack joint</i>) is a
--   Netwire running gag. It makes sure that you revisit the documentation
--   from time to time. =)
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
wackelkontakt :: (HasTime t s, Monad m, Monoid e, RandomGen g) => t -> Double -> g -> Wire s e m a a

-- | Convenience interface to <a>noise</a> for <a>StdGen</a>.
stdNoise :: (HasTime t s, Random b) => t -> Int -> Wire s e m a (Event b)

-- | Convenience interface to <a>noiseR</a> for <a>StdGen</a>.
stdNoiseR :: (HasTime t s, Monad m, Random b) => t -> (b, b) -> Int -> Wire s e m a (Event b)

-- | Convenience interface to <a>wackelkontakt</a> for <a>StdGen</a>.
stdWackelkontakt :: (HasTime t s, Monad m, Monoid e) => t -> Double -> Int -> Wire s e m a a


module FRP.Netwire

-- | A wire is a signal function. It maps a reactive value to another
--   reactive value.
data Wire s e m a b

-- | Pure wires.
type WireP s e = Wire s e Identity

-- | Simple wires with time.
type SimpleWire = Wire (Timed NominalDiffTime ()) () Identity

-- | This wire delays its input signal by the smallest possible
--   (semantically infinitesimal) amount of time. You can use it when you
--   want to use feedback (<a>ArrowLoop</a>): If the user of the feedback
--   depends on <i>now</i>, delay the value before feeding it back. The
--   argument value is the replacement signal at the beginning.
--   
--   <ul>
--   <li>Depends: before now.</li>
--   </ul>
delay :: a -> Wire s e m a a

-- | Evaluate the input signal using the given <a>Strategy</a> here. This
--   wire evaluates only produced values.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
evalWith :: Strategy a -> Wire s e m a a

-- | Force the input signal to WHNF here. This wire forces both produced
--   values and inhibition values.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
force :: Wire s e m a a

-- | Force the input signal to NF here. This wire forces only produced
--   values.
--   
--   <ul>
--   <li>Depends: now.</li>
--   </ul>
forceNF :: NFData a => Wire s e m a a
