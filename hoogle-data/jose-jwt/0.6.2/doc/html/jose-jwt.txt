-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | JSON Object Signing and Encryption Library
--   
@package jose-jwt
@version 0.6.2

module Jose.Jwa

-- | General representation of the <tt>alg</tt> JWT header value.
data Alg
Signed :: JwsAlg -> Alg
Encrypted :: JweAlg -> Alg

-- | A subset of the signature algorithms from the <a>JWA Spec</a>.
data JwsAlg
None :: JwsAlg
HS256 :: JwsAlg
HS384 :: JwsAlg
HS512 :: JwsAlg
RS256 :: JwsAlg
RS384 :: JwsAlg
RS512 :: JwsAlg
ES256 :: JwsAlg
ES384 :: JwsAlg
ES512 :: JwsAlg

-- | A subset of the key management algorithms from the <a>JWA Spec</a>.
data JweAlg
RSA1_5 :: JweAlg
RSA_OAEP :: JweAlg

-- | Content encryption algorithms from the <a>JWA Spec</a>. The optional
--   algorithms A192CBC-HS384 and A192GCM are not supported yet.
data Enc
A128CBC_HS256 :: Enc
A256CBC_HS512 :: Enc
A128GCM :: Enc
A256GCM :: Enc
instance Eq JwsAlg
instance Show JwsAlg
instance Read JwsAlg
instance Eq JweAlg
instance Show JweAlg
instance Read JweAlg
instance Eq Alg
instance Show Alg
instance Eq Enc
instance Show Enc
instance ToJSON Enc
instance FromJSON Enc
instance ToJSON JweAlg
instance FromJSON JweAlg
instance ToJSON JwsAlg
instance FromJSON JwsAlg
instance ToJSON Alg
instance FromJSON Alg

module Jose.Jwk
instance Eq KeyType
instance Show KeyType
instance Eq EcCurve
instance Show EcCurve
instance Eq KeyUse
instance Show KeyUse
instance Show Jwk
instance Eq Jwk
instance Show JwkSet
instance Eq JwkSet
instance Generic JwkSet
instance Show JwkBytes
instance Show JwkData
instance Generic JwkData
instance Datatype D1JwkSet
instance Constructor C1_0JwkSet
instance Selector S1_0_0JwkSet
instance Datatype D1JwkData
instance Constructor C1_0JwkData
instance Selector S1_0_0JwkData
instance Selector S1_0_1JwkData
instance Selector S1_0_2JwkData
instance Selector S1_0_3JwkData
instance Selector S1_0_4JwkData
instance Selector S1_0_5JwkData
instance Selector S1_0_6JwkData
instance Selector S1_0_7JwkData
instance Selector S1_0_8JwkData
instance Selector S1_0_9JwkData
instance Selector S1_0_10JwkData
instance Selector S1_0_11JwkData
instance Selector S1_0_12JwkData
instance Selector S1_0_13JwkData
instance Selector S1_0_14JwkData
instance Selector S1_0_15JwkData
instance Selector S1_0_16JwkData
instance Selector S1_0_17JwkData
instance Selector S1_0_18JwkData
instance ToJSON JwkData
instance FromJSON JwkData
instance FromJSON JwkSet
instance ToJSON JwkSet
instance ToJSON Jwk
instance FromJSON Jwk
instance ToJSON JwkBytes
instance FromJSON JwkBytes
instance ToJSON EcCurve
instance FromJSON EcCurve
instance ToJSON KeyUse
instance FromJSON KeyUse
instance ToJSON KeyType
instance FromJSON KeyType


-- | Internal functions for encrypting and signing / decrypting and
--   verifying JWT content.
module Jose.Internal.Crypto

-- | Sign a message with an HMAC key.
hmacSign :: JwsAlg -> ByteString -> ByteString -> Either JwtError ByteString

-- | Verify the HMAC for a given message. Returns false if the MAC is
--   incorrect or the <a>Alg</a> is not an HMAC.
hmacVerify :: JwsAlg -> ByteString -> ByteString -> ByteString -> Bool

-- | Sign a message using an RSA private key.
--   
--   The failure condition should only occur if the algorithm is not an RSA
--   algorithm, or the RSA key is too small, causing the padding of the
--   signature to fail. With real-world RSA keys this shouldn't happen in
--   practice.
rsaSign :: Maybe Blinder -> JwsAlg -> PrivateKey -> ByteString -> Either JwtError ByteString

-- | Verify the signature for a message using an RSA public key.
--   
--   Returns false if the check fails or if the <a>Alg</a> value is not an
--   RSA signature algorithm.
rsaVerify :: JwsAlg -> PublicKey -> ByteString -> ByteString -> Bool

-- | Encrypts a message (typically a symmetric key) using RSA.
rsaEncrypt :: CPRG g => g -> JweAlg -> PublicKey -> ByteString -> (ByteString, g)

-- | Decrypts an RSA encrypted message.
rsaDecrypt :: Maybe Blinder -> JweAlg -> PrivateKey -> ByteString -> Either JwtError ByteString

-- | Verify the signature for a message using an EC public key.
--   
--   Returns false if the check fails or if the <a>Alg</a> value is not an
--   EC signature algorithm.
ecVerify :: JwsAlg -> PublicKey -> ByteString -> ByteString -> Bool

-- | Encrypt a message using AES.
encryptPayload :: Enc -> ByteString -> ByteString -> ByteString -> ByteString -> (ByteString, AuthTag)

-- | Decrypt an AES encrypted message.
decryptPayload :: MonadError JwtError m => Enc -> ByteString -> ByteString -> ByteString -> ByteString -> ByteString -> m ByteString

-- | Generates the symmetric key (content management key) and IV
--   
--   Used to encrypt a message.
generateCmkAndIV :: CPRG g => g -> Enc -> ((ByteString, ByteString), g)


-- | JWS HMAC and RSA signed token support.
--   
--   Example usage with HMAC:
--   
--   <pre>
--   &gt;&gt;&gt; import Jose.Jws
--   
--   &gt;&gt;&gt; import Jose.Jwa
--   
--   &gt;&gt;&gt; let Right (Jwt jwt) = hmacEncode HS256 "secretmackey" "public claims"
--   
--   &gt;&gt;&gt; jwt
--   "eyJhbGciOiJIUzI1NiJ9.cHVibGljIGNsYWltcw.GDV7RdBrCYfCtFCZZGPy_sWry4GwfX3ckMywXUyxBsc"
--   
--   &gt;&gt;&gt; hmacDecode "wrongkey" jwt
--   Left BadSignature
--   
--   &gt;&gt;&gt; hmacDecode "secretmackey" jwt
--   Right (JwsHeader {jwsAlg = HS256, jwsTyp = Nothing, jwsCty = Nothing, jwsKid = Nothing},"public claims")
--   </pre>
module Jose.Jws

-- | Create a JWS signed with a JWK. The key and algorithm must be
--   consistent or an error will be returned.
jwkEncode :: CPRG g => g -> JwsAlg -> Jwk -> Payload -> (Either JwtError Jwt, g)

-- | Create a JWS with an HMAC for validation.
hmacEncode :: JwsAlg -> ByteString -> ByteString -> Either JwtError Jwt

-- | Decodes and validates an HMAC signed JWS.
hmacDecode :: ByteString -> ByteString -> Either JwtError Jws

-- | Creates a JWS with an RSA signature.
rsaEncode :: CPRG g => g -> JwsAlg -> PrivateKey -> ByteString -> (Either JwtError Jwt, g)

-- | Decode and validate an RSA signed JWS.
rsaDecode :: PublicKey -> ByteString -> Either JwtError Jws

-- | Decode and validate an EC signed JWS
ecDecode :: PublicKey -> ByteString -> Either JwtError Jws


-- | JWE RSA encrypted token support.
--   
--   Example usage:
--   
--   <pre>
--   &gt;&gt;&gt; import Jose.Jwe
--   
--   &gt;&gt;&gt; import Jose.Jwa
--   
--   &gt;&gt;&gt; import Crypto.Random.AESCtr
--   
--   &gt;&gt;&gt; g &lt;- makeSystem
--   
--   &gt;&gt;&gt; import Crypto.PubKey.RSA
--   
--   &gt;&gt;&gt; let ((kPub, kPr), g') = generate g 512 65537
--   
--   &gt;&gt;&gt; let (Jwt jwt, g'') = rsaEncode g' RSA_OAEP A128GCM kPub "secret claims"
--   
--   &gt;&gt;&gt; fst $ rsaDecode g'' kPr jwt
--   Right (JweHeader {jweAlg = RSA_OAEP, jweEnc = A128GCM, jweTyp = Nothing, jweCty = Nothing, jweZip = Nothing, jweKid = Nothing},"secret claims")
--   </pre>
module Jose.Jwe

-- | Create a JWE using a JWK. The key and algorithms must be consistent or
--   an error will be returned.
jwkEncode :: CPRG g => g -> JweAlg -> Enc -> Jwk -> Payload -> (Either JwtError Jwt, g)

-- | Creates a JWE.
rsaEncode :: CPRG g => g -> JweAlg -> Enc -> PublicKey -> ByteString -> (Jwt, g)

-- | Decrypts a JWE.
rsaDecode :: CPRG g => g -> PrivateKey -> ByteString -> (Either JwtError Jwe, g)


-- | High-level JWT encoding and decoding.
--   
--   Example usage:
--   
--   <pre>
--   &gt;&gt;&gt; import Jose.Jwe
--   
--   &gt;&gt;&gt; import Jose.Jwa
--   
--   &gt;&gt;&gt; import Jose.Jwk
--   
--   &gt;&gt;&gt; import Data.ByteString
--   
--   &gt;&gt;&gt; import Data.Aeson (decodeStrict)
--   
--   &gt;&gt;&gt; import Crypto.Random.AESCtr
--   
--   &gt;&gt;&gt; g &lt;- makeSystem
--   
--   &gt;&gt;&gt; let jsonJwk = "{\"kty\":\"RSA\", \"kid\":\"mykey\", \"n\":\"ofgWCuLjybRlzo0tZWJjNiuSfb4p4fAkd_wWJcyQoTbji9k0l8W26mPddxHmfHQp-Vaw-4qPCJrcS2mJPMEzP1Pt0Bm4d4QlL-yRT-SFd2lZS-pCgNMsD1W_YpRPEwOWvG6b32690r2jZ47soMZo9wGzjb_7OMg0LOL-bSf63kpaSHSXndS5z5rexMdbBYUsLA9e-KXBdQOS-UTo7WTBEMa2R2CapHg665xsmtdVMTBQY4uDZlxvb3qCo5ZwKh9kG4LT6_I5IhlJH7aGhyxXFvUK-DWNmoudF8NAco9_h9iaGNj8q2ethFkMLs91kzk2PAcDTW9gb54h4FRWyuXpoQ\", \"e\":\"AQAB\", \"d\":\"Eq5xpGnNCivDflJsRQBXHx1hdR1k6Ulwe2JZD50LpXyWPEAeP88vLNO97IjlA7_GQ5sLKMgvfTeXZx9SE-7YwVol2NXOoAJe46sui395IW_GO-pWJ1O0BkTGoVEn2bKVRUCgu-GjBVaYLU6f3l9kJfFNS3E0QbVdxzubSu3Mkqzjkn439X0M_V51gfpRLI9JYanrC4D4qAdGcopV_0ZHHzQlBjudU2QvXt4ehNYTCBr6XCLQUShb1juUO1ZdiYoFaFQT5Tw8bGUl_x_jTj3ccPDVZFD9pIuhLhBOneufuBiB4cS98l2SR_RQyGWSeWjnczT0QU91p1DhOVRuOopznQ\"}" :: ByteString
--   
--   &gt;&gt;&gt; let Just jwk = decodeStrict jsonJwk :: Maybe Jwk
--   
--   &gt;&gt;&gt; let (Right (Jwt jwtEncoded), g')  = encode g [jwk] (JwsEncoding RS256) (Claims "public claims")
--   
--   &gt;&gt;&gt; let (Right jwtDecoded, g'') = Jose.Jwt.decode g' [jwk] (Just (JwsEncoding RS256)) jwtEncoded
--   
--   &gt;&gt;&gt; jwtDecoded
--   Jws (JwsHeader {jwsAlg = RS256, jwsTyp = Nothing, jwsCty = Nothing, jwsKid = Just (KeyId "mykey")},"public claims")
--   </pre>
module Jose.Jwt

-- | An encoded JWT.
newtype Jwt
Jwt :: ByteString -> Jwt
unJwt :: Jwt -> ByteString

-- | The header and claims of a decoded JWE.
type Jwe = (JweHeader, ByteString)

-- | The header and claims of a decoded JWS.
type Jws = (JwsHeader, ByteString)

-- | Registered claims defined in section 4 of the JWT spec.
data JwtClaims
JwtClaims :: !(Maybe Text) -> !(Maybe Text) -> !(Maybe [Text]) -> !(Maybe IntDate) -> !(Maybe IntDate) -> !(Maybe IntDate) -> !(Maybe Text) -> JwtClaims
jwtIss :: JwtClaims -> !(Maybe Text)
jwtSub :: JwtClaims -> !(Maybe Text)
jwtAud :: JwtClaims -> !(Maybe [Text])
jwtExp :: JwtClaims -> !(Maybe IntDate)
jwtNbf :: JwtClaims -> !(Maybe IntDate)
jwtIat :: JwtClaims -> !(Maybe IntDate)
jwtJti :: JwtClaims -> !(Maybe Text)

-- | Header content for a JWS.
data JwsHeader
JwsHeader :: JwsAlg -> Maybe Text -> Maybe Text -> Maybe KeyId -> JwsHeader
jwsAlg :: JwsHeader -> JwsAlg
jwsTyp :: JwsHeader -> Maybe Text
jwsCty :: JwsHeader -> Maybe Text
jwsKid :: JwsHeader -> Maybe KeyId

-- | Header content for a JWE.
data JweHeader
JweHeader :: JweAlg -> Enc -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe KeyId -> JweHeader
jweAlg :: JweHeader -> JweAlg
jweEnc :: JweHeader -> Enc
jweTyp :: JweHeader -> Maybe Text
jweCty :: JweHeader -> Maybe Text
jweZip :: JweHeader -> Maybe Text
jweKid :: JweHeader -> Maybe KeyId

-- | A decoded JWT which can be either a JWE or a JWS, or an unsecured JWT.
data JwtContent
Unsecured :: !ByteString -> JwtContent
Jws :: !Jws -> JwtContent
Jwe :: !Jwe -> JwtContent

-- | Defines the encoding information for a JWT.
--   
--   Used for both encoding new JWTs and validating existing ones.
data JwtEncoding
JwsEncoding :: JwsAlg -> JwtEncoding
JweEncoding :: JweAlg -> Enc -> JwtEncoding

-- | Decoding errors.
data JwtError

-- | No suitable key or wrong key type
KeyError :: Text -> JwtError

-- | The supplied algorithm is invalid
BadAlgorithm :: Text -> JwtError

-- | Wrong number of "." characters in the JWT
BadDots :: Int -> JwtError

-- | Header couldn't be decoded or contains bad data
BadHeader :: Text -> JwtError

-- | Claims part couldn't be decoded or contains bad data
BadClaims :: JwtError

-- | Signature is invalid
BadSignature :: JwtError

-- | A cryptographic operation failed
BadCrypto :: JwtError

-- | A base64 decoding error
Base64Error :: String -> JwtError

-- | The payload to be encoded in a JWT.
data Payload
Nested :: Jwt -> Payload
Claims :: ByteString -> Payload

-- | Use the supplied JWKs to create a JWT. The list of keys will be
--   searched to locate one which is consistent with the chosen encoding
--   algorithms.
encode :: CPRG g => g -> [Jwk] -> JwtEncoding -> Payload -> (Either JwtError Jwt, g)

-- | Uses the supplied keys to decode a JWT. Locates a matching key by
--   header <tt>kid</tt> value where possible or by suitable key type for
--   the encoding algorithm.
--   
--   The algorithm(s) used can be optionally be supplied for validation by
--   setting the <tt>JwtEncoding</tt> parameter, in which case an error
--   will be returned if they don't match.
--   
--   For unsecured tokens (with algorithm "none"), the expected algorithm
--   must be set to <tt>Just (JwsEncoding None)</tt> or an error will be
--   returned.
decode :: CPRG g => g -> [Jwk] -> Maybe JwtEncoding -> ByteString -> (Either JwtError JwtContent, g)

-- | Convenience function to return the claims contained in a JWT. This is
--   required in situations such as client assertion authentication, where
--   the contents of the JWT may be required in order to work out which key
--   should be used to verify the token. Obviously this should not be used
--   by itself to decode a token since no integrity checking is done and
--   the contents may be forged.
decodeClaims :: ByteString -> Either JwtError (JwtHeader, JwtClaims)
