-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Package allowing parsec parser initeratee
--   
--   Package providing instances of Stream in Iteratee monad.
@package iteratee-parsec
@version 0.0.6


-- | Module providing simple implementation based on mutable linked list.
--   It is optimised for longer parsers.
module Text.Parsec.Iteratee.LinkedList

-- | Class connecting mutable variable and monad it exists in.
class Monad m => Reference r :: (* -> *) m :: (* -> *)
newRef :: Reference r m => a -> m (r a)
readRef :: Reference r m => r a -> m a
writeRef :: Reference r m => r a -> a -> m ()
modifyRef :: Reference r m => r a -> (a -> m (a, b)) -> m b

-- | Cursor holds current value and reference to possible next cursor
data (Monad m, Reference r m) => Cursor r m s el

-- | Specify the 3 possible states of next cursor - existence,
--   non-existence and not being evaluated
data (Monad m, Reference r m, ListLike s el) => NextCursor r m s el

-- | Creates new cursor
mkCursor :: (Monad m, Reference r m, ListLike s el) => m (Cursor r m s el)

-- | Runs parser. If it suceed the remaining part of stream stands in
--   stream, however if it fails the stream is not in defined state.
parsecIteratee :: (Monad m, Reference r m, Nullable c, ListLike c el) => ParsecT (Cursor r m c el) u (Iteratee c m) a -> u -> SourceName -> Iteratee c m (Either ParseError a)

-- | Runs parser. If it suceed the remaining part of stream stands in
--   stream, however if it fails everything stands in stream.
safeParsecIteratee :: (Monad m, Reference r m, Nullable c, ListLike c el) => ParsecT (Cursor r m c el) u (Iteratee c m) a -> u -> SourceName -> Iteratee c m (Either ParseError a)
instance (Monad m, Nullable s, Reference r m, ListLike s el) => Stream (Cursor r m s el) (Iteratee s m) el


-- | Module providing simple implementation based on accumulating chunks.
--   It is optimised for short parsers.
module Text.Parsec.Iteratee.Chunk

-- | Create an Iteratee from a ParsecT parser. This is most efficient for
--   relatively smaller parsers (&lt; 1e5 chars), and becomes increasingly
--   inefficient as the parser size increases. If the parse fails, no input
--   is consumed. If the parse succeeds, any data remaining after the parse
--   is available to the iteratee.
safeParsecIterateeShort :: (Monad m, Nullable s, ListLike s t) => ParsecT Int u (Iteratee s m) a -> u -> SourceName -> Iteratee s m (Either ParseError a)
instance (Monad m, Nullable s, ListLike s el) => Stream Int (Iteratee s m) el


module Text.Parsec.Iteratee

-- | Runs parser. If it suceed the remaining part of stream stands in
--   stream, however if it fails everything stands in stream.
safeParsecIteratee :: (Monad m, Reference r m, Nullable c, ListLike c el) => ParsecT (Cursor r m c el) u (Iteratee c m) a -> u -> SourceName -> Iteratee c m (Either ParseError a)

-- | Create an Iteratee from a ParsecT parser. This is most efficient for
--   relatively smaller parsers (&lt; 1e5 chars), and becomes increasingly
--   inefficient as the parser size increases. If the parse fails, no input
--   is consumed. If the parse succeeds, any data remaining after the parse
--   is available to the iteratee.
safeParsecIterateeShort :: (Monad m, Nullable s, ListLike s t) => ParsecT Int u (Iteratee s m) a -> u -> SourceName -> Iteratee s m (Either ParseError a)

-- | Runs parser. If it suceed the remaining part of stream stands in
--   stream, however if it fails the stream is not in defined state.
parsecIteratee :: (Monad m, Reference r m, Nullable c, ListLike c el) => ParsecT (Cursor r m c el) u (Iteratee c m) a -> u -> SourceName -> Iteratee c m (Either ParseError a)
