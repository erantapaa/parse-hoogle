-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compositional Data Types
--   
@package compdata
@version 0.10


-- | This module defines higher-order functors (Johann, Ghani, POPL '08),
--   i.e. endofunctors on the category of endofunctors.
module Data.Comp.Multi.HFunctor

-- | This class represents higher-order functors (Johann, Ghani, POPL '08)
--   which are endofunctors on the category of endofunctors.
class HFunctor h
hfmap :: HFunctor h => (f :-> g) -> h f :-> h g

-- | This type represents natural transformations.
type (:->) f g = forall i. f i -> g i

-- | This type represents co-cones from <tt>f</tt> to <tt>a</tt>. <tt>f
--   :=&gt; a</tt> is isomorphic to f :-&gt; K a
type (:=>) f a = forall i. f i -> a
type NatM m f g = forall i. f i -> m (g i)

-- | The identity Functor.
newtype I a
I :: a -> I a
unI :: I a -> a

-- | The parametrised constant functor.
newtype K a i
K :: a -> K a i
unK :: K a i -> a
data A f
A :: (forall i. f i) -> A f
unA :: A f -> forall i. f i
data E f
E :: f i -> E f
unE :: E f -> f i
runE :: (f :=> b) -> E f -> b

-- | This data type denotes the composition of two functor families.
data (:.:) f (g :: (* -> *) -> (* -> *)) (e :: * -> *) t
Comp :: (f (g e) t) -> (:.:) f t
instance [incoherent] Functor I
instance [incoherent] Foldable I
instance [incoherent] Traversable I
instance [incoherent] Functor (K a)
instance [incoherent] Foldable (K a)
instance [incoherent] Traversable (K a)
instance [incoherent] Functor f => HFunctor (Compose f)
instance [incoherent] Ord a => Ord (K a i)
instance [incoherent] Eq a => Eq (K a i)


-- | This module defines higher-order foldable functors.
module Data.Comp.Multi.HFoldable

-- | Higher-order functors that can be folded.
--   
--   Minimal complete definition: <a>hfoldMap</a> or <a>hfoldr</a>.
class HFunctor h => HFoldable h where hfold = hfoldMap unK hfoldMap f = hfoldr (mappend . f) mempty hfoldr f z t = appEndo (hfoldMap (Endo . f) t) z hfoldl f z t = appEndo (getDual (hfoldMap (Dual . Endo . flip f) t)) z hfoldr1 f xs = fromMaybe (error "hfoldr1: empty structure") (hfoldr mf Nothing xs) where mf :: K a :=> (Maybe a -> Maybe a) mf (K x) Nothing = Just x mf (K x) (Just y) = Just (f x y) hfoldl1 f xs = fromMaybe (error "hfoldl1: empty structure") (hfoldl mf Nothing xs) where mf :: Maybe a -> K a :=> Maybe a mf Nothing (K y) = Just y mf (Just x) (K y) = Just (f x y)
hfold :: (HFoldable h, Monoid m) => h (K m) :=> m
hfoldMap :: (HFoldable h, Monoid m) => (a :=> m) -> h a :=> m
hfoldr :: HFoldable h => (a :=> (b -> b)) -> b -> h a :=> b
hfoldl :: HFoldable h => (b -> a :=> b) -> b -> h a :=> b
hfoldr1 :: HFoldable h => (a -> a -> a) -> h (K a) :=> a
hfoldl1 :: HFoldable h => (a -> a -> a) -> h (K a) :=> a
kfoldr :: HFoldable f => (a -> b -> b) -> b -> f (K a) :=> b
kfoldl :: HFoldable f => (b -> a -> b) -> b -> f (K a) :=> b
htoList :: HFoldable f => f a :=> [E a]


-- | This module defines higher-order traversable functors.
module Data.Comp.Multi.HTraversable
class HFoldable t => HTraversable t
hmapM :: (HTraversable t, Monad m) => NatM m a b -> NatM m (t a) (t b)
htraverse :: (HTraversable t, Applicative f) => NatM f a b -> NatM f (t a) (t b)


-- | This module provides functionality to construct mappings from
--   positions in a functorial value.
module Data.Comp.Multi.Mapping

-- | This type is used for numbering components of a functorial value.
data Numbered a i
Numbered :: Int -> (a i) -> Numbered a i
unNumbered :: Numbered a :-> a

-- | This function numbers the components of the given functorial value
--   with consecutive integers starting at 0.
number :: HTraversable f => f a :-> f (Numbered a)
class HFoldable t => HTraversable t
class Mapping m (k :: * -> *) | m -> k
(&) :: Mapping m k => m v -> m v -> m v
(|->) :: Mapping m k => k i -> v -> m v
empty :: Mapping m k => m v
prodMap :: Mapping m k => v1 -> v2 -> m v1 -> m v2 -> m (v1, v2)
findWithDefault :: Mapping m k => a -> k i -> m a -> a
lookupNumMap :: a -> Int -> NumMap t a -> a
instance Functor (NumMap k)
instance Mapping (NumMap k) (Numbered k)


-- | This module defines the central notion of mutual recursive (or,
--   higher-order) <i>terms</i> and its generalisation to (higher-order)
--   contexts. All definitions are generalised versions of those in
--   <a>Data.Comp.Term</a>.
module Data.Comp.Multi.Term

-- | This data type represents contexts over a signature. Contexts are
--   terms containing zero or more holes. The first type parameter is
--   supposed to be one of the phantom types <a>Hole</a> and <a>NoHole</a>.
--   The second parameter is the signature of the context. The third
--   parameter is the type family of the holes. The last parameter is the
--   index/label.
data Cxt h f a i
Term :: f (Cxt h f a) i -> Cxt h f a i
Hole :: a i -> Cxt Hole f a i

-- | Phantom type that signals that a <a>Cxt</a> might contain holes.
data Hole

-- | Phantom type that signals that a <a>Cxt</a> does not contain holes.
data NoHole

-- | A context might contain holes.
type Context = Cxt Hole

-- | A (higher-order) term is a context with no holes.
type Term f = Cxt NoHole f (K ())
type Const (f :: (* -> *) -> * -> *) = f (K ())

-- | This function converts a constant to a term. This assumes that the
--   argument is indeed a constant, i.e. does not have a value for the
--   argument type of the functor f.
constTerm :: HFunctor f => Const f :-> Term f

-- | This function unravels the given term at the topmost layer.
unTerm :: Term f t -> f (Term f) t

-- | Cast a term over a signature to a context over the same signature.
toCxt :: HFunctor f => Term f :-> Context f a
simpCxt :: HFunctor f => f a i -> Context f a i
instance HTraversable f => HTraversable (Cxt h f)
instance HFoldable f => HFoldable (Cxt h f)
instance HFunctor f => HFunctor (Cxt h f)


-- | This module provides a generic projection function <a>pr</a> for
--   arbitrary nested binary products.
module Data.Comp.Projection

-- | This function projects the component of type <tt>e</tt> out or the
--   compound value of type <tt>p</tt>.
pr :: p :< q => q -> p

-- | The constraint <tt>e :&lt; p</tt> expresses that <tt>e</tt> is a
--   component of the type <tt>p</tt>. That is, <tt>p</tt> is formed by
--   binary products using the type <tt>e</tt>. The occurrence of
--   <tt>e</tt> must be unique. For example we have <tt>Int :&lt;
--   (Bool,(Int,Bool))</tt> but not <tt>Bool :&lt; (Bool,(Int,Bool))</tt>.
type (:<) f g = Proj (ComprEmb (Elem f g)) f g
instance (Proj ('Found p1) f1 g, Proj ('Found p2) f2 g) => Proj ('Found ('Sum p1 p2)) (f1, f2) g
instance Proj ('Found p) f g => Proj ('Found ('Ri p)) f (g', g)
instance Proj ('Found p) f g => Proj ('Found ('Le p)) f (g, g')
instance Proj ('Found 'Here) f f


-- | This module provides functionality to construct mappings from
--   positions in a functorial value.
module Data.Comp.Mapping

-- | This type is used for numbering components of a functorial value.
data Numbered a
Numbered :: Int -> a -> Numbered a
unNumbered :: Numbered a -> a

-- | This function numbers the components of the given functorial value
--   with consecutive integers starting at 0.
number :: Traversable f => f a -> f (Numbered a)

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   Minimal complete definition: <a>traverse</a> or <a>sequenceA</a>.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Indentity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: * -> *)
class Functor m => Mapping m k | m -> k
(&) :: Mapping m k => m v -> m v -> m v
(|->) :: Mapping m k => k -> v -> m v
empty :: Mapping m k => m v
prodMapWith :: Mapping m k => (v1 -> v2 -> v) -> v1 -> v2 -> m v1 -> m v2 -> m v
findWithDefault :: Mapping m k => a -> k -> m a -> a

-- | This function constructs the pointwise product of two maps each with a
--   default value.
prodMap :: Mapping m k => v1 -> v2 -> m v1 -> m v2 -> m (v1, v2)
lookupNumMap :: a -> Int -> NumMap t a -> a
lookupNumMap' :: Int -> NumMap t a -> Maybe a
data NumMap k v
instance Functor (NumMap k)
instance Foldable (NumMap k)
instance Traversable (NumMap k)
instance Mapping (NumMap k) (Numbered k)


-- | This module defines some utility functions for deriving instances for
--   functor based type classes.
module Data.Comp.Derive.Utils

-- | This is the <tt>Q</tt>-lifted version of 'abstractNewtype.
abstractNewtypeQ :: Q Info -> Q Info

-- | This function abstracts away <tt>newtype</tt> declaration, it turns
--   them into <tt>data</tt> declarations.
abstractNewtype :: Info -> Info

-- | This function provides the name and the arity of the given data
--   constructor.
normalCon :: Con -> (Name, [StrictType])
normalCon' :: Con -> (Name, [Type])

-- | Same as normalCon' but expands type synonyms.
normalConExp :: Con -> Q (Name, [Type])

-- | Same as normalConExp' but retains strictness annotations.
normalConStrExp :: Con -> Q (Name, [StrictType])

-- | This function provides the name and the arity of the given data
--   constructor.
abstractConType :: Con -> (Name, Int)

-- | This function returns the name of a bound type variable
tyVarBndrName :: TyVarBndr -> Name
containsType :: Type -> Type -> Bool
containsType' :: Type -> Type -> [Int]

-- | This function provides a list (of the given length) of new names based
--   on the given string.
newNames :: Int -> String -> Q [Name]
tupleTypes :: Int -> Int -> [Name]

-- | Helper function for generating a list of instances for a list of named
--   signatures. For example, in order to derive instances <a>Functor</a>
--   and <tt>ShowF</tt> for a signature <tt>Exp</tt>, use derive as follows
--   (requires Template Haskell):
--   
--   <pre>
--   $(derive [makeFunctor, makeShowF] [''Exp])
--   </pre>
derive :: [Name -> Q [Dec]] -> [Name] -> Q [Dec]

-- | Apply a class name to type arguments to construct a type class
--   constraint.
mkClassP :: Name -> [Type] -> Pred

-- | This function checks whether the given type constraint is an equality
--   constraint. If so, the types of the equality constraint are returned.
isEqualP :: Pred -> Maybe (Type, Type)

-- | This function lifts type class instances over sums ofsignatures. To
--   this end it assumes that it contains only methods with types of the
--   form <tt>f t1 .. tn -&gt; t</tt> where <tt>f</tt> is the signature
--   that is used to construct sums. Since this function is generic it
--   assumes as its first argument the name of the function that is used to
--   lift methods over sums i.e. a function of type
--   
--   <pre>
--   (f t1 .. tn -&gt; t) -&gt; (g t1 .. tn -&gt; t) -&gt; ((f :+: g) t1 .. tn -&gt; t)
--   </pre>
--   
--   where <tt>:+:</tt> is the sum type constructor. The second argument to
--   this function is expected to be the name of that constructor. The last
--   argument is the name of the class whose instances should be lifted
--   over sums.
liftSumGen :: Name -> Name -> Name -> Q [Dec]
findSig :: [Name] -> [Dec] -> Q (Maybe ([Name], [Name]))


-- | This module provides operators on functors.
module Data.Comp.Ops

-- | Formal sum of signatures (functors).
data (:+:) f g e
Inl :: (f e) -> (:+:) f g e
Inr :: (g e) -> (:+:) f g e
fromInl :: (f :+: g) e -> Maybe (f e)
fromInr :: (f :+: g) e -> Maybe (g e)

-- | Utility function to case on a functor sum, without exposing the
--   internal representation of sums.
caseF :: (f a -> b) -> (g a -> b) -> (f :+: g) a -> b
class Subsume (e :: Emb) (f :: * -> *) (g :: * -> *)
inj' :: Subsume e f g => Proxy e -> f a -> g a
prj' :: Subsume e f g => Proxy e -> g a -> Maybe (f a)

-- | A constraint <tt>f :&lt;: g</tt> expresses that the signature
--   <tt>f</tt> is subsumed by <tt>g</tt>, i.e. <tt>f</tt> can be used to
--   construct elements in <tt>g</tt>.
type (:<:) f g = Subsume (ComprEmb (Elem f g)) f g
inj :: f :<: g => f a -> g a
proj :: f :<: g => g a -> Maybe (f a)
type (:=:) f g = (f :<: g, g :<: f)
spl :: f :=: (f1 :+: f2) => (f1 a -> b) -> (f2 a -> b) -> f a -> b

-- | Formal product of signatures (functors).
data (:*:) f g a
(:*:) :: f a -> g a -> (:*:) f g a
ffst :: (f :*: g) a -> f a
fsnd :: (f :*: g) a -> g a

-- | This data type adds a constant product (annotation) to a signature.
data (:&:) f a e
(:&:) :: f e -> a -> (:&:) f a e

-- | This class defines how to distribute an annotation over a sum of
--   signatures.
class DistAnn s p s' | s' -> s, s' -> p
injectA :: DistAnn s p s' => p -> s a -> s' a
projectA :: DistAnn s p s' => s' a -> (s a, p)
class RemA s s' | s -> s'
remA :: RemA s s' => s a -> s' a
instance DistAnn s p s' => DistAnn (f :+: s) p ((f :&: p) :+: s')
instance DistAnn f p (f :&: p)
instance RemA (f :&: p) f
instance RemA s s' => RemA ((f :&: p) :+: s) (f :+: s')
instance Traversable f => Traversable (f :&: a)
instance Foldable f => Foldable (f :&: a)
instance Functor f => Functor (f :&: a)
instance (Traversable f, Traversable g) => Traversable (f :*: g)
instance (Foldable f, Foldable g) => Foldable (f :*: g)
instance (Functor f, Functor g) => Functor (f :*: g)
instance (Subsume ('Found p1) f1 g, Subsume ('Found p2) f2 g) => Subsume ('Found ('Sum p1 p2)) (f1 :+: f2) g
instance Subsume ('Found p) f g => Subsume ('Found ('Ri p)) f (g' :+: g)
instance Subsume ('Found p) f g => Subsume ('Found ('Le p)) f (g :+: g')
instance Subsume ('Found 'Here) f f
instance (Traversable f, Traversable g) => Traversable (f :+: g)
instance (Foldable f, Foldable g) => Foldable (f :+: g)
instance (Functor f, Functor g) => Functor (f :+: g)


-- | This module defines the notion of algebras and catamorphisms, and
--   their generalizations to e.g. monadic versions and other (co)recursion
--   schemes. All definitions are generalised versions of those in
--   <a>Data.Comp.Algebra</a>.
module Data.Comp.Multi.Algebra

-- | This type represents multisorted <tt>f</tt>-algebras with a family
--   <tt>e</tt> of carriers.
type Alg f e = f e :-> e

-- | Construct a catamorphism for contexts over <tt>f</tt> with holes of
--   type <tt>b</tt>, from the given algebra.
free :: HFunctor f => Alg f b -> (a :-> b) -> Cxt h f a :-> b

-- | Construct a catamorphism from the given algebra.
cata :: HFunctor f => Alg f a -> Term f :-> a

-- | A generalisation of <a>cata</a> from terms over <tt>f</tt> to contexts
--   over <tt>f</tt>, where the holes have the type of the algebra carrier.
cata' :: HFunctor f => Alg f e -> Cxt h f e :-> e

-- | This function applies a whole context into another context.
appCxt :: HFunctor f => Context f (Cxt h f a) :-> Cxt h f a

-- | This type represents a monadic algebra. It is similar to <a>Alg</a>
--   but the return type is monadic.
type AlgM m f e = NatM m (f e) e

-- | Construct a monadic catamorphism for contexts over <tt>f</tt> with
--   holes of type <tt>b</tt>, from the given monadic algebra.
freeM :: (HTraversable f, Monad m) => AlgM m f b -> NatM m a b -> NatM m (Cxt h f a) b

-- | This is a monadic version of <a>cata</a>.
cataM :: (HTraversable f, Monad m) => AlgM m f a -> NatM m (Term f) a
cataM' :: (Monad m, HTraversable f) => AlgM m f a -> NatM m (Cxt h f a) a

-- | This function lifts a many-sorted algebra to a monadic domain.
liftMAlg :: (Monad m, HTraversable f) => Alg f I -> Alg f m

-- | This type represents context function.
type CxtFun f g = forall h. SigFun (Cxt h f) (Cxt h g)

-- | This type represents uniform signature function specification.
type SigFun f g = forall (a :: * -> *). f a :-> g a

-- | This type represents term homomorphisms.
type Hom f g = SigFun f (Context g)

-- | This function applies the given term homomorphism to a term/context.
appHom :: (HFunctor f, HFunctor g) => Hom f g -> CxtFun f g

-- | This function applies the given term homomorphism to a term/context.
--   This is the top-down variant of <a>appHom</a>.
appHom' :: HFunctor g => Hom f g -> CxtFun f g

-- | This function composes two term algebras.
compHom :: (HFunctor g, HFunctor h) => Hom g h -> Hom f g -> Hom f h

-- | This function applies a signature function to the given context.
appSigFun :: HFunctor f => SigFun f g -> CxtFun f g

-- | This function applies a signature function to the given context. This
--   is the top-down variant of <a>appSigFun</a>.
appSigFun' :: HFunctor g => SigFun f g -> CxtFun f g

-- | This function composes two signature functions.
compSigFun :: SigFun g h -> SigFun f g -> SigFun f h

-- | Lifts the given signature function to the canonical term homomorphism.
hom :: HFunctor g => SigFun f g -> Hom f g

-- | This function composes a term algebra with an algebra.
compAlg :: HFunctor g => Alg g a -> Hom f g -> Alg f a

-- | This type represents monadic context function.
type CxtFunM m f g = forall h. SigFunM m (Cxt h f) (Cxt h g)

-- | This type represents monadic signature functions.
type SigFunM m f g = forall (a :: * -> *). NatM m (f a) (g a)

-- | This type represents monadic term algebras.
type HomM m f g = SigFunM m f (Context g)

-- | This function lifts the given signature function to a monadic
--   signature function. Note that term algebras are instances of signature
--   functions. Hence this function also applies to term algebras.
sigFunM :: Monad m => SigFun f g -> SigFunM m f g

-- | This function lifts the give monadic signature function to a monadic
--   term algebra.
hom' :: (HFunctor f, HFunctor g, Monad m) => SigFunM m f g -> HomM m f g

-- | This function applies the given monadic term homomorphism to the given
--   term/context.
appHomM :: (HTraversable f, HFunctor g, Monad m) => HomM m f g -> CxtFunM m f g

-- | This function applies the given monadic term homomorphism to the given
--   term/context. This is a top-down variant of <a>appHomM</a>.
appHomM' :: (HTraversable g, Monad m) => HomM m f g -> CxtFunM m f g

-- | This function lifts the given signature function to a monadic term
--   algebra.
homM :: (HFunctor g, Monad m) => SigFun f g -> HomM m f g

-- | This function applies the given monadic signature function to the
--   given context.
appSigFunM :: (HTraversable f, Monad m) => SigFunM m f g -> CxtFunM m f g

-- | This function applies the given monadic signature function to the
--   given context. This is a top-down variant of <a>appSigFunM</a>.
appSigFunM' :: (HTraversable g, Monad m) => SigFunM m f g -> CxtFunM m f g

-- | This function composes two monadic term algebras.
compHomM :: (HTraversable g, HFunctor h, Monad m) => HomM m g h -> HomM m f g -> HomM m f h

-- | This function composes two monadic signature functions.
compSigFunM :: Monad m => SigFunM m g h -> SigFunM m f g -> SigFunM m f h

-- | This function composes a monadic term algebra with a monadic algebra
compAlgM :: (HTraversable g, Monad m) => AlgM m g a -> HomM m f g -> AlgM m f a

-- | This function composes a monadic term algebra with a monadic algebra.
compAlgM' :: (HTraversable g, Monad m) => AlgM m g a -> Hom f g -> AlgM m f a
type Coalg f a = a :-> f a

-- | This function unfolds the given value to a term using the given
--   unravelling function. This is the unique homomorphism <tt>a -&gt; Term
--   f</tt> from the given coalgebra of type <tt>a -&gt; f a</tt> to the
--   final coalgebra <tt>Term f</tt>.
ana :: HFunctor f => Coalg f a -> a :-> Term f
type CoalgM m f a = NatM m a (f a)

-- | This function unfolds the given value to a term using the given
--   monadic unravelling function. This is the unique homomorphism <tt>a
--   -&gt; Term f</tt> from the given coalgebra of type <tt>a -&gt; f
--   a</tt> to the final coalgebra <tt>Term f</tt>.
anaM :: (HTraversable f, Monad m) => CoalgM m f a -> NatM m a (Term f)

-- | This type represents r-algebras over functor <tt>f</tt> and with
--   domain <tt>a</tt>.
type RAlg f a = f (Term f :*: a) :-> a

-- | This function constructs a paramorphism from the given r-algebra
para :: HFunctor f => RAlg f a -> Term f :-> a

-- | This type represents monadic r-algebras over monad <tt>m</tt> and
--   functor <tt>f</tt> and with domain <tt>a</tt>.
type RAlgM m f a = NatM m (f (Term f :*: a)) a

-- | This function constructs a monadic paramorphism from the given monadic
--   r-algebra
paraM :: (HTraversable f, Monad m) => RAlgM m f a -> NatM m (Term f) a

-- | This type represents r-coalgebras over functor <tt>f</tt> and with
--   domain <tt>a</tt>.
type RCoalg f a = a :-> f (Term f :+: a)

-- | This function constructs an apomorphism from the given r-coalgebra.
apo :: HFunctor f => RCoalg f a -> a :-> Term f

-- | This type represents monadic r-coalgebras over monad <tt>m</tt> and
--   functor <tt>f</tt> with domain <tt>a</tt>.
type RCoalgM m f a = NatM m a (f (Term f :+: a))

-- | This function constructs a monadic apomorphism from the given monadic
--   r-coalgebra.
apoM :: (HTraversable f, Monad m) => RCoalgM m f a -> NatM m a (Term f)

-- | This type represents cv-coalgebras over functor <tt>f</tt> and with
--   domain <tt>a</tt>.
type CVCoalg f a = a :-> f (Context f a)

-- | This function constructs the unique futumorphism from the given
--   cv-coalgebra to the term algebra.
futu :: HFunctor f => CVCoalg f a -> a :-> Term f

-- | This type represents monadic cv-coalgebras over monad <tt>m</tt> and
--   functor <tt>f</tt>, and with domain <tt>a</tt>.
type CVCoalgM m f a = NatM m a (f (Context f a))

-- | This function constructs the unique monadic futumorphism from the
--   given monadic cv-coalgebra to the term algebra.
futuM :: (HTraversable f, Monad m) => CVCoalgM m f a -> NatM m a (Term f)


-- | This module provides operators on higher-order functors. All
--   definitions are generalised versions of those in <a>Data.Comp.Ops</a>.
module Data.Comp.Multi.Ops

-- | Data type defining coproducts.
data (:+:) f g (h :: * -> *) e
Inl :: (f h e) -> (:+:) f g e
Inr :: (g h e) -> (:+:) f g e

-- | Utility function to case on a higher-order functor sum, without
--   exposing the internal representation of sums.
caseH :: (f a b -> c) -> (g a b -> c) -> (f :+: g) a b -> c
class Subsume (e :: Emb) (f :: (* -> *) -> * -> *) (g :: (* -> *) -> * -> *)
inj' :: Subsume e f g => Proxy e -> f a :-> g a
prj' :: Subsume e f g => Proxy e -> NatM Maybe (g a) (f a)

-- | A constraint <tt>f :&lt;: g</tt> expresses that the signature
--   <tt>f</tt> is subsumed by <tt>g</tt>, i.e. <tt>f</tt> can be used to
--   construct elements in <tt>g</tt>.
type (:<:) f g = Subsume (ComprEmb (Elem f g)) f g
inj :: f :<: g => f a :-> g a
proj :: f :<: g => NatM Maybe (g a) (f a)
type (:=:) f g = (f :<: g, g :<: f)
spl :: f :=: (f1 :+: f2) => (f1 a :-> b) -> (f2 a :-> b) -> f a :-> b

-- | This data type adds a constant product to a signature. Alternatively,
--   this could have also been defined as
--   
--   <pre>
--   data (f :&amp;: a) (g ::  * -&gt; *) e = f g e :&amp;: a e
--   </pre>
--   
--   This is too general, however, for example for <tt>productHHom</tt>.
data (:&:) f a (g :: * -> *) e
(:&:) :: f g e -> a -> (:&:) f a e

-- | This class defines how to distribute an annotation over a sum of
--   signatures.
class DistAnn (s :: (* -> *) -> * -> *) p s' | s' -> s, s' -> p
injectA :: DistAnn s p s' => p -> s a :-> s' a
projectA :: DistAnn s p s' => s' a :-> (s a :&: p)
class RemA (s :: (* -> *) -> * -> *) s' | s -> s'
remA :: RemA s s' => s a :-> s' a

-- | Formal product of signatures (functors).
data (:*:) f g a
(:*:) :: f a -> g a -> (:*:) f g a
ffst :: (f :*: g) a -> f a
fsnd :: (f :*: g) a -> g a
instance DistAnn s p s' => DistAnn (f :+: s) p ((f :&: p) :+: s')
instance DistAnn f p (f :&: p)
instance RemA (f :&: p) f
instance RemA s s' => RemA ((f :&: p) :+: s) (f :+: s')
instance HTraversable f => HTraversable (f :&: a)
instance HFoldable f => HFoldable (f :&: a)
instance HFunctor f => HFunctor (f :&: a)
instance (Subsume ('Found p1) f1 g, Subsume ('Found p2) f2 g) => Subsume ('Found ('Sum p1 p2)) (f1 :+: f2) g
instance Subsume ('Found p) f g => Subsume ('Found ('Ri p)) f (g' :+: g)
instance Subsume ('Found p) f g => Subsume ('Found ('Le p)) f (g :+: g')
instance Subsume ('Found 'Here) f f
instance (HTraversable f, HTraversable g) => HTraversable (f :+: g)
instance (HFoldable f, HFoldable g) => HFoldable (f :+: g)
instance (HFunctor f, HFunctor g) => HFunctor (f :+: g)


-- | This module defines sums on signatures. All definitions are
--   generalised versions of those in <a>Data.Comp.Sum</a>.
module Data.Comp.Multi.Sum

-- | A constraint <tt>f :&lt;: g</tt> expresses that the signature
--   <tt>f</tt> is subsumed by <tt>g</tt>, i.e. <tt>f</tt> can be used to
--   construct elements in <tt>g</tt>.
type (:<:) f g = Subsume (ComprEmb (Elem f g)) f g

-- | Data type defining coproducts.
data (:+:) f g (h :: * -> *) e

-- | Utility function to case on a higher-order functor sum, without
--   exposing the internal representation of sums.
caseH :: (f a b -> c) -> (g a b -> c) -> (f :+: g) a b -> c
proj :: f :<: g => NatM Maybe (g a) (f a)

-- | Project the outermost layer of a term to a sub signature. If the
--   signature <tt>g</tt> is compound of <i>n</i> atomic signatures, use
--   <tt>project</tt><i>n</i> instead.
project :: g :<: f => NatM Maybe (Cxt h f a) (g (Cxt h f a))

-- | Tries to coerce a term<i>context to a term</i>context over a
--   sub-signature. If the signature <tt>g</tt> is compound of <i>n</i>
--   atomic signatures, use <tt>deepProject</tt><i>n</i> instead.
deepProject :: (HTraversable g, g :<: f) => CxtFunM Maybe f g
inj :: f :<: g => f a :-> g a

-- | Inject a term where the outermost layer is a sub signature. If the
--   signature <tt>g</tt> is compound of <i>n</i> atomic signatures, use
--   <tt>inject</tt><i>n</i> instead.
inject :: g :<: f => g (Cxt h f a) :-> Cxt h f a

-- | Inject a term over a sub signature to a term over larger signature. If
--   the signature <tt>g</tt> is compound of <i>n</i> atomic signatures,
--   use <tt>deepInject</tt><i>n</i> instead.
deepInject :: (HFunctor g, g :<: f) => CxtFun g f
split :: f :=: (f1 :+: f2) => (f1 (Term f) :-> a) -> (f2 (Term f) :-> a) -> Term f :-> a
injectConst :: (HFunctor g, g :<: f) => Const g :-> Cxt h f a
projectConst :: (HFunctor g, g :<: f) => NatM Maybe (Cxt h f a) (Const g)

-- | This function injects a whole context into another context.
injectCxt :: (HFunctor g, g :<: f) => Cxt h' g (Cxt h f a) :-> Cxt h f a

-- | This function lifts the given functor to a context.
liftCxt :: (HFunctor f, g :<: f) => g a :-> Context f a

-- | This function applies the given context with hole type <tt>a</tt> to a
--   family <tt>f</tt> of contexts (possibly terms) indexed by <tt>a</tt>.
--   That is, each hole <tt>h</tt> is replaced by the context <tt>f h</tt>.
substHoles :: (HFunctor f, HFunctor g, f :<: g) => (v :-> Cxt h g a) -> Cxt h' f v :-> Cxt h g a


-- | This module defines type generic functions and recursive schemes along
--   the lines of the Uniplate library. All definitions are generalised
--   versions of those in <a>Data.Comp.Generic</a>.
module Data.Comp.Multi.Generic

-- | This function returns a list of all subterms of the given term. This
--   function is similar to Uniplate's <tt>universe</tt> function.
subterms :: HFoldable f => Term f :=> [E (Term f)]

-- | This function returns a list of all subterms of the given term that
--   are constructed from a particular functor.
subterms' :: (HFoldable f, g :<: f) => Term f :=> [E (g (Term f))]

-- | This function transforms every subterm according to the given function
--   in a bottom-up manner. This function is similar to Uniplate's
--   <tt>transform</tt> function.
transform :: HFunctor f => (Term f :-> Term f) -> Term f :-> Term f

-- | Monadic version of <a>transform</a>.
transformM :: (HTraversable f, Monad m) => NatM m (Term f) (Term f) -> NatM m (Term f) (Term f)
query :: HFoldable f => (Term f :=> r) -> (r -> r -> r) -> Term f :=> r
subs :: HFoldable f => Term f :=> [E (Term f)]
subs' :: (HFoldable f, g :<: f) => Term f :=> [E (g (Term f))]

-- | This function computes the generic size of the given term, i.e. the
--   its number of subterm occurrences.
size :: HFoldable f => Cxt h f a :=> Int

-- | This function computes the generic depth of the given term.
depth :: HFoldable f => Cxt h f a :=> Int


-- | This module defines annotations on signatures. All definitions are
--   generalised versions of those in <a>Data.Comp.Annotation</a>.
module Data.Comp.Multi.Annotation

-- | This data type adds a constant product to a signature. Alternatively,
--   this could have also been defined as
--   
--   <pre>
--   data (f :&amp;: a) (g ::  * -&gt; *) e = f g e :&amp;: a e
--   </pre>
--   
--   This is too general, however, for example for <tt>productHHom</tt>.
data (:&:) f a (g :: * -> *) e
(:&:) :: f g e -> a -> (:&:) f a e

-- | This class defines how to distribute an annotation over a sum of
--   signatures.
class DistAnn (s :: (* -> *) -> * -> *) p s' | s' -> s, s' -> p
injectA :: DistAnn s p s' => p -> s a :-> s' a
projectA :: DistAnn s p s' => s' a :-> (s a :&: p)
class RemA (s :: (* -> *) -> * -> *) s' | s -> s'
remA :: RemA s s' => s a :-> s' a

-- | This function transforms a function with a domain constructed from a
--   functor to a function with a domain constructed with the same functor
--   but with an additional annotation.
liftA :: RemA s s' => (s' a :-> t) -> s a :-> t

-- | This function annotates each sub term of the given term with the given
--   value (of type a).
ann :: (DistAnn f p g, HFunctor f) => p -> CxtFun f g

-- | This function transforms a function with a domain constructed from a
--   functor to a function with a domain constructed with the same functor
--   but with an additional annotation.
liftA' :: (DistAnn s' p s, HFunctor s') => (s' a :-> Cxt h s' a) -> s a :-> Cxt h s a

-- | This function strips the annotations from a term over a functor with
--   annotations.
stripA :: (RemA g f, HFunctor g) => CxtFun g f
propAnn :: (DistAnn f p f', DistAnn g p g', HFunctor g) => Hom f g -> Hom f' g'

-- | This function is similar to <tt>project</tt> but applies to signatures
--   with an annotation which is then ignored.
project' :: (RemA f f', s :<: f') => Cxt h f a i -> Maybe (s (Cxt h f a) i)


-- | This module defines equality for (higher-order) signatures, which
--   lifts to equality for (higher-order) terms and contexts. All
--   definitions are generalised versions of those in
--   <a>Data.Comp.Equality</a>.
module Data.Comp.Multi.Equality

-- | Signature equality. An instance <tt>EqHF f</tt> gives rise to an
--   instance <tt>KEq (HTerm f)</tt>.
class EqHF f
eqHF :: (EqHF f, KEq g) => f g i -> f g j -> Bool
class KEq f
keq :: KEq f => f i -> f j -> Bool

-- | This function implements equality of values of type <tt>f a</tt>
--   modulo the equality of <tt>a</tt> itself. If two functorial values are
--   equal in this sense, <tt>eqMod</tt> returns a <a>Just</a> value
--   containing a list of pairs consisting of corresponding components of
--   the two functorial values.
heqMod :: (EqHF f, HFunctor f, HFoldable f) => f a i -> f b i -> Maybe [(E a, E b)]
instance (EqHF f, KEq a) => Eq (Cxt h f a i)
instance (EqHF f, KEq a) => KEq (Cxt h f a)
instance EqHF f => EqHF (Cxt h f)
instance (EqHF f, EqHF g) => EqHF (f :+: g)
instance KEq a => Eq (E a)
instance Eq a => KEq (K a)


-- | This module defines the infrastructure necessary to use <i>Generalised
--   Compositional Data Types</i>. Generalised Compositional Data Types is
--   an extension of Compositional Data Types with mutually recursive data
--   types, and more generally GADTs. Examples of usage are bundled with
--   the package in the library <tt>examples/Examples/Multi</tt>.
module Data.Comp.Multi


-- | This modules defines the <a>Desugar</a> type class for desugaring of
--   terms.
module Data.Comp.Multi.Desugar

-- | The desugaring term homomorphism.
class (HFunctor f, HFunctor g) => Desugar f g where desugHom = desugHom' . hfmap Hole desugHom' x = appCxt (desugHom x)
desugHom :: Desugar f g => Hom f g
desugHom' :: Desugar f g => Alg f (Context g a)

-- | Desugar a term.
desugar :: Desugar f g => Term f :-> Term g

-- | Lift desugaring to annotated terms.
desugarA :: (HFunctor f', HFunctor g', DistAnn f p f', DistAnn g p g', Desugar f g) => Term f' :-> Term g'

-- | Default desugaring instance.
instance [overlap ok] (HFunctor f, HFunctor g, f :<: g) => Desugar f g
instance [overlap ok] (Desugar f h, Desugar g h) => Desugar (f :+: g) h


-- | This module defines ordering of signatures, which lifts to ordering of
--   terms and contexts.
module Data.Comp.Multi.Ordering
class KEq f => KOrd f
kcompare :: KOrd f => f i -> f j -> Ordering

-- | Signature ordering. An instance <tt>OrdHF f</tt> gives rise to an
--   instance <tt>Ord (Term f)</tt>.
class EqHF f => OrdHF f
compareHF :: (OrdHF f, KOrd a) => f a i -> f a j -> Ordering
instance (HFunctor f, OrdHF f, KOrd a) => Ord (Cxt h f a i)
instance (HFunctor f, OrdHF f, KOrd a) => KOrd (Cxt h f a)
instance (HFunctor f, OrdHF f) => OrdHF (Cxt h f)
instance (OrdHF f, OrdHF g) => OrdHF (f :+: g)
instance Ord a => KOrd (K a)
instance KOrd f => Ord (E f)


-- | This module contains functionality for automatically deriving
--   boilerplate code using Template Haskell. Examples include instances of
--   <a>HFunctor</a>, <a>HFoldable</a>, and <a>HTraversable</a>.
module Data.Comp.Multi.Derive

-- | Helper function for generating a list of instances for a list of named
--   signatures. For example, in order to derive instances <a>Functor</a>
--   and <tt>ShowF</tt> for a signature <tt>Exp</tt>, use derive as follows
--   (requires Template Haskell):
--   
--   <pre>
--   $(derive [makeFunctor, makeShowF] [''Exp])
--   </pre>
derive :: [Name -> Q [Dec]] -> [Name] -> Q [Dec]

-- | Signature printing. An instance <tt>ShowHF f</tt> gives rise to an
--   instance <tt>KShow (HTerm f)</tt>.
class ShowHF f where showHF = K . showHF' showHF' = unK . showHF
showHF :: ShowHF f => Alg f (K String)
showHF' :: ShowHF f => f (K String) :=> String
class KShow a
kshow :: KShow a => a i -> K String i

-- | Derive an instance of <a>ShowHF</a> for a type constructor of any
--   higher-order kind taking at least two arguments.
makeShowHF :: Name -> Q [Dec]

-- | Signature equality. An instance <tt>EqHF f</tt> gives rise to an
--   instance <tt>KEq (HTerm f)</tt>.
class EqHF f
eqHF :: (EqHF f, KEq g) => f g i -> f g j -> Bool
class KEq f
keq :: KEq f => f i -> f j -> Bool

-- | Derive an instance of <a>EqHF</a> for a type constructor of any
--   higher-order kind taking at least two arguments.
makeEqHF :: Name -> Q [Dec]

-- | Signature ordering. An instance <tt>OrdHF f</tt> gives rise to an
--   instance <tt>Ord (Term f)</tt>.
class EqHF f => OrdHF f
compareHF :: (OrdHF f, KOrd a) => f a i -> f a j -> Ordering

-- | Derive an instance of <a>OrdHF</a> for a type constructor of any
--   parametric kind taking at least three arguments.
makeOrdHF :: Name -> Q [Dec]

-- | This class represents higher-order functors (Johann, Ghani, POPL '08)
--   which are endofunctors on the category of endofunctors.
class HFunctor h

-- | Derive an instance of <a>HFunctor</a> for a type constructor of any
--   higher-order kind taking at least two arguments.
makeHFunctor :: Name -> Q [Dec]

-- | Higher-order functors that can be folded.
--   
--   Minimal complete definition: <a>hfoldMap</a> or <a>hfoldr</a>.
class HFunctor h => HFoldable h where hfold = hfoldMap unK hfoldMap f = hfoldr (mappend . f) mempty hfoldr f z t = appEndo (hfoldMap (Endo . f) t) z hfoldl f z t = appEndo (getDual (hfoldMap (Dual . Endo . flip f) t)) z hfoldr1 f xs = fromMaybe (error "hfoldr1: empty structure") (hfoldr mf Nothing xs) where mf :: K a :=> (Maybe a -> Maybe a) mf (K x) Nothing = Just x mf (K x) (Just y) = Just (f x y) hfoldl1 f xs = fromMaybe (error "hfoldl1: empty structure") (hfoldl mf Nothing xs) where mf :: Maybe a -> K a :=> Maybe a mf Nothing (K y) = Just y mf (Just x) (K y) = Just (f x y)

-- | Derive an instance of <a>HFoldable</a> for a type constructor of any
--   higher-order kind taking at least two arguments.
makeHFoldable :: Name -> Q [Dec]
class HFoldable t => HTraversable t

-- | Derive an instance of <a>HTraversable</a> for a type constructor of
--   any higher-order kind taking at least two arguments.
makeHTraversable :: Name -> Q [Dec]

-- | Derive smart constructors for a type constructor of any higher-order
--   kind taking at least two arguments. The smart constructors are similar
--   to the ordinary constructors, but an <a>inject</a> is automatically
--   inserted.
smartConstructors :: Name -> Q [Dec]

-- | Derive smart constructors with products for a type constructor of any
--   parametric kind taking at least two arguments. The smart constructors
--   are similar to the ordinary constructors, but an <a>injectA</a> is
--   automatically inserted.
smartAConstructors :: Name -> Q [Dec]

-- | Given the name of a type class, where the first parameter is a
--   higher-order functor, lift it to sums of higher-order. Example:
--   <tt>class HShowF f where ...</tt> is lifted as <tt>instance (HShowF f,
--   HShowF g) =&gt; HShowF (f :+: g) where ... </tt>.
liftSum :: Name -> Q [Dec]


-- | This module defines showing of (higher-order) signatures, which lifts
--   to showing of (higher-order) terms and contexts. All definitions are
--   generalised versions of those in <a>Data.Comp.Show</a>.
module Data.Comp.Multi.Show

-- | Signature printing. An instance <tt>ShowHF f</tt> gives rise to an
--   instance <tt>KShow (HTerm f)</tt>.
class ShowHF f where showHF = K . showHF' showHF' = unK . showHF
showHF :: ShowHF f => Alg f (K String)
showHF' :: ShowHF f => f (K String) :=> String
instance (ShowHF f, ShowHF g) => ShowHF (f :+: g)
instance (ShowHF f, Show p) => ShowHF (f :&: p)
instance KShow (Cxt h f a) => Show (Cxt h f a i)
instance (ShowHF f, HFunctor f, KShow a) => KShow (Cxt h f a)
instance (ShowHF f, HFunctor f) => ShowHF (Cxt h f)
instance KShow (K ())
instance KShow (K String)


-- | This module defines an abstract notion of (bound) variables in
--   compositional data types, and scoped substitution. Capture-avoidance
--   is <i>not</i> taken into account. All definitions are generalised
--   versions of those in <a>Data.Comp.Variables</a>.
module Data.Comp.Multi.Variables

-- | This multiparameter class defines functors with variables. An instance
--   <tt>HasVar f v</tt> denotes that values over <tt>f</tt> might contain
--   and bind variables of type <tt>v</tt>.
class HasVars (f :: (* -> *) -> * -> *) v where isVar _ = Nothing bindsVars _ = empty
isVar :: HasVars f v => f a :=> Maybe v
bindsVars :: (HasVars f v, Mapping m a) => f a :=> m (Set v)
type GSubst v a = Map v (A a)
type CxtSubst h a f v = GSubst v (Cxt h f a)
type Subst f v = CxtSubst NoHole (K ()) f v
varsToHoles :: (HTraversable f, HasVars f v, Ord v) => Term f :-> Context f (K v)

-- | This function checks whether a variable is contained in a context.
containsVar :: (Ord v, HasVars f v, HTraversable f, HFunctor f) => v -> Cxt h f a :=> Bool

-- | This function computes the set of variables occurring in a context.
variables :: (Ord v, HasVars f v, HTraversable f, HFunctor f) => Cxt h f a :=> Set v

-- | This function computes the list of variables occurring in a context.
variableList :: (HasVars f v, HTraversable f, HFunctor f, Ord v) => Cxt h f a :=> [v]

-- | This function computes the set of variables occurring in a context.
variables' :: (Ord v, HasVars f v, HFoldable f, HFunctor f) => Const f :=> Set v
appSubst :: (Ord v, SubstVars v t a) => GSubst v t -> a :-> a

-- | This function composes two substitutions <tt>s1</tt> and <tt>s2</tt>.
--   That is, applying the resulting substitution is equivalent to first
--   applying <tt>s2</tt> and then <tt>s1</tt>.
compSubst :: (Ord v, HasVars f v, HTraversable f) => CxtSubst h a f v -> CxtSubst h a f v -> CxtSubst h a f v

-- | This combinator pairs every argument of a given constructor with the
--   set of (newly) bound variables according to the corresponding
--   <a>HasVars</a> type class instance.
getBoundVars :: (HasVars f v, HTraversable f) => f a i -> f (a :*: K (Set v)) i

-- | left-biased union of two mappings.
(&) :: Mapping m k => m v -> m v -> m v

-- | This operator constructs a singleton mapping.
(|->) :: Mapping m k => k i -> v -> m v

-- | This is the empty mapping.
empty :: Mapping m k => m v
instance [overlap ok] (SubstVars v t a, HFunctor f) => SubstVars v t (f a)
instance [overlap ok] (Ord v, HasVars f v, HTraversable f) => SubstVars v (Cxt h f a) (Cxt h f a)
instance [overlap ok] (HasVars f v0, HasVars g v0) => HasVars (f :+: g) v0


-- | This module provides a generic projection function <a>pr</a> for
--   arbitrary nested binary products.
module Data.Comp.Multi.Projection

-- | This function projects the component of type <tt>e</tt> out or the
--   compound value of type <tt>p</tt>.
pr :: p :< q => q a -> p a

-- | The constraint <tt>e :&lt; p</tt> expresses that <tt>e</tt> is a
--   component of the type <tt>p</tt>. That is, <tt>p</tt> is formed by
--   binary products using the type <tt>e</tt>. The occurrence of
--   <tt>e</tt> must be unique. For example we have <tt>Int :&lt;
--   (Bool,(Int,Bool))</tt> but not <tt>Bool :&lt; (Bool,(Int,Bool))</tt>.
type (:<) f g = Proj (ComprEmb (Elem f g)) f g

-- | Formal product of signatures (functors).
data (:*:) f g a
(:*:) :: f a -> g a -> (:*:) f g a
ffst :: (f :*: g) a -> f a
fsnd :: (f :*: g) a -> g a
instance (Proj ('Found p1) f1 g, Proj ('Found p2) f2 g) => Proj ('Found ('Sum p1 p2)) (f1 :*: f2) g
instance Proj ('Found p) f g => Proj ('Found ('Ri p)) f (g' :*: g)
instance Proj ('Found p) f g => Proj ('Found ('Le p)) f (g :*: g')
instance Proj ('Found 'Here) f f


-- | This module defines the central notion of <i>terms</i> and its
--   generalisation to contexts.
module Data.Comp.Term

-- | This data type represents contexts over a signature. Contexts are
--   terms containing zero or more holes. The first type parameter is
--   supposed to be one of the phantom types <a>Hole</a> and <a>NoHole</a>.
--   The second parameter is the signature of the context. The third
--   parameter is the type of the holes.
data Cxt :: * -> (* -> *) -> * -> *
Term :: f (Cxt h f a) -> Cxt h f a
Hole :: a -> Cxt Hole f a

-- | Phantom type that signals that a <a>Cxt</a> might contain holes.
data Hole

-- | Phantom type that signals that a <a>Cxt</a> does not contain holes.
data NoHole
type Context = Cxt Hole

-- | A term is a context with no holes.
type Term f = Cxt NoHole f ()

-- | Polymorphic definition of a term. This formulation is more natural
--   than <a>Term</a>, it leads to impredicative types in some cases,
--   though.
type PTerm f = forall h a. Cxt h f a
type Const f = f ()

-- | This function unravels the given term at the topmost layer.
unTerm :: Cxt NoHole f a -> f (Cxt NoHole f a)

-- | Convert a functorial value into a context.
simpCxt :: Functor f => f a -> Context f a

-- | Cast a term over a signature to a context over the same signature.
toCxt :: Functor f => Term f -> Cxt h f a

-- | This function converts a constant to a term. This assumes that the
--   argument is indeed a constant, i.e. does not have a value for the
--   argument type of the functor <tt>f</tt>.
constTerm :: Functor f => Const f -> Term f
instance Traversable f => Traversable (Cxt h f)
instance Foldable f => Foldable (Cxt h f)
instance Functor f => Monad (Context f)
instance Functor f => Applicative (Context f)
instance Functor f => Functor (Cxt h f)


-- | This module defines equality for signatures, which lifts to equality
--   for terms and contexts.
module Data.Comp.Equality

-- | Signature equality. An instance <tt>EqF f</tt> gives rise to an
--   instance <tt>Eq (Term f)</tt>.
class EqF f
eqF :: (EqF f, Eq a) => f a -> f a -> Bool

-- | This function implements equality of values of type <tt>f a</tt>
--   modulo the equality of <tt>a</tt> itself. If two functorial values are
--   equal in this sense, <a>eqMod</a> returns a <a>Just</a> value
--   containing a list of pairs consisting of corresponding components of
--   the two functorial values.
eqMod :: (EqF f, Functor f, Foldable f) => f a -> f b -> Maybe [(a, b)]
instance (Eq a0, Eq b0, Eq c0, Eq d0, Eq e0, Eq f0, Eq g0, Eq h0, Eq i0) => EqF ((,,,,,,,,,) a0 b0 c0 d0 e0 f0 g0 h0 i0)
instance (Eq a0, Eq b0, Eq c0, Eq d0, Eq e0, Eq f0, Eq g0, Eq h0) => EqF ((,,,,,,,,) a0 b0 c0 d0 e0 f0 g0 h0)
instance (Eq a0, Eq b0, Eq c0, Eq d0, Eq e0, Eq f0, Eq g0) => EqF ((,,,,,,,) a0 b0 c0 d0 e0 f0 g0)
instance (Eq a0, Eq b0, Eq c0, Eq d0, Eq e0, Eq f0) => EqF ((,,,,,,) a0 b0 c0 d0 e0 f0)
instance (Eq a0, Eq b0, Eq c0, Eq d0, Eq e0) => EqF ((,,,,,) a0 b0 c0 d0 e0)
instance (Eq a0, Eq b0, Eq c0, Eq d0) => EqF ((,,,,) a0 b0 c0 d0)
instance (Eq a0, Eq b0, Eq c0) => EqF ((,,,) a0 b0 c0)
instance (Eq a0, Eq b0) => EqF ((,,) a0 b0)
instance Eq a0 => EqF ((,) a0)
instance EqF []
instance EqF Maybe
instance (EqF f, EqF g) => EqF (f :+: g)
instance EqF f => EqF (Cxt h f)
instance (EqF f, Eq a) => Eq (Cxt h f a)


-- | This module defines the notion of algebras and catamorphisms, and
--   their generalizations to e.g. monadic versions and other (co)recursion
--   schemes.
module Data.Comp.Algebra

-- | This type represents an algebra over a functor <tt>f</tt> and carrier
--   <tt>a</tt>.
type Alg f a = f a -> a

-- | Construct a catamorphism for contexts over <tt>f</tt> with holes of
--   type <tt>a</tt>, from the given algebra.
free :: Functor f => Alg f b -> (a -> b) -> Cxt h f a -> b

-- | Construct a catamorphism from the given algebra.
cata :: Functor f => Alg f a -> Term f -> a

-- | A generalisation of <a>cata</a> from terms over <tt>f</tt> to contexts
--   over <tt>f</tt>, where the holes have the type of the algebra carrier.
cata' :: Functor f => Alg f a -> Cxt h f a -> a

-- | This function applies a whole context into another context.
appCxt :: Functor f => Context f (Cxt h f a) -> Cxt h f a

-- | This type represents a monadic algebra. It is similar to <a>Alg</a>
--   but the return type is monadic.
type AlgM m f a = f a -> m a

-- | Convert a monadic algebra into an ordinary algebra with a monadic
--   carrier.
algM :: (Traversable f, Monad m) => AlgM m f a -> Alg f (m a)

-- | Construct a monadic catamorphism for contexts over <tt>f</tt> with
--   holes of type <tt>a</tt>, from the given monadic algebra.
freeM :: (Traversable f, Monad m) => AlgM m f b -> (a -> m b) -> Cxt h f a -> m b

-- | Construct a monadic catamorphism from the given monadic algebra.
cataM :: (Traversable f, Monad m) => AlgM m f a -> Term f -> m a

-- | A generalisation of <a>cataM</a> from terms over <tt>f</tt> to
--   contexts over <tt>f</tt>, where the holes have the type of the monadic
--   algebra carrier.
cataM' :: (Traversable f, Monad m) => AlgM m f a -> Cxt h f a -> m a

-- | This type represents a context function.
type CxtFun f g = forall a h. Cxt h f a -> Cxt h g a

-- | This type represents a signature function.
type SigFun f g = forall a. f a -> g a

-- | This type represents a term homomorphism.
type Hom f g = SigFun f (Context g)

-- | This function applies the given term homomorphism to a term/context.
appHom :: (Functor f, Functor g) => Hom f g -> CxtFun f g

-- | Apply a term homomorphism recursively to a term/context. This is a
--   top-down variant of <a>appHom</a>.
appHom' :: Functor g => Hom f g -> CxtFun f g

-- | Compose two term homomorphisms.
compHom :: (Functor g, Functor h) => Hom g h -> Hom f g -> Hom f h

-- | This function applies a signature function to the given context.
appSigFun :: Functor f => SigFun f g -> CxtFun f g

-- | This function applies a signature function to the given context. This
--   is a top-down variant of <a>appSigFun</a>.
appSigFun' :: Functor g => SigFun f g -> CxtFun f g

-- | This function composes two signature functions.
compSigFun :: SigFun g h -> SigFun f g -> SigFun f h

-- | This function composes a signature function with a term homomorphism.
compSigFunHom :: Functor g => SigFun g h -> Hom f g -> Hom f h

-- | This function composes a term homomorphism with a signature function.
compHomSigFun :: Hom g h -> SigFun f g -> Hom f h

-- | This function composes an algebra with a signature function.
compAlgSigFun :: Alg g a -> SigFun f g -> Alg f a

-- | Lifts the given signature function to the canonical term homomorphism.
hom :: Functor g => SigFun f g -> Hom f g

-- | Compose an algebra with a term homomorphism to get a new algebra.
compAlg :: Functor g => Alg g a -> Hom f g -> Alg f a

-- | Compose a term homomorphism with a coalgebra to get a cv-coalgebra.
compCoalg :: Hom f g -> Coalg f a -> CVCoalg' g a

-- | Compose a term homomorphism with a cv-coalgebra to get a new
--   cv-coalgebra.
compCVCoalg :: (Functor f, Functor g) => Hom f g -> CVCoalg' f a -> CVCoalg' g a

-- | This type represents a monadic context function.
type CxtFunM m f g = forall a h. Cxt h f a -> m (Cxt h g a)

-- | This type represents a monadic signature function.
type SigFunM m f g = forall a. f a -> m (g a)

-- | This type represents a monadic term homomorphism.
type HomM m f g = SigFunM m f (Context g)

-- | This type represents a monadic signature function. It is similar to
--   <a>SigFunM</a> but has monadic values also in the domain.
type SigFunMD m f g = forall a. f (m a) -> m (g a)

-- | This type represents a monadic term homomorphism. It is similar to
--   <a>HomM</a> but has monadic values also in the domain.
type HomMD m f g = SigFunMD m f (Context g)

-- | Lift the given signature function to a monadic signature function.
--   Note that term homomorphisms are instances of signature functions.
--   Hence this function also applies to term homomorphisms.
sigFunM :: Monad m => SigFun f g -> SigFunM m f g

-- | Lift the give monadic signature function to a monadic term
--   homomorphism.
hom' :: (Functor f, Functor g, Monad m) => SigFunM m f g -> HomM m f g

-- | Apply a monadic term homomorphism recursively to a term/context.
appHomM :: (Traversable f, Functor g, Monad m) => HomM m f g -> CxtFunM m f g

-- | Apply a monadic term homomorphism recursively to a term/context. This
--   a top-down variant of <a>appHomM</a>.
appHomM' :: (Traversable g, Monad m) => HomM m f g -> CxtFunM m f g

-- | Lift the given signature function to a monadic term homomorphism.
homM :: (Functor g, Monad m) => SigFunM m f g -> HomM m f g

-- | This function constructs the unique monadic homomorphism from the
--   initial term algebra to the given term algebra.
homMD :: (Traversable f, Functor g, Monad m) => HomMD m f g -> CxtFunM m f g

-- | This function applies a monadic signature function to the given
--   context.
appSigFunM :: (Traversable f, Monad m) => SigFunM m f g -> CxtFunM m f g

-- | This function applies a monadic signature function to the given
--   context. This is a top-down variant of <a>appSigFunM</a>.
appSigFunM' :: (Traversable g, Monad m) => SigFunM m f g -> CxtFunM m f g

-- | This function applies a signature function to the given context.
appSigFunMD :: (Traversable f, Functor g, Monad m) => SigFunMD m f g -> CxtFunM m f g

-- | Compose two monadic term homomorphisms.
compHomM :: (Traversable g, Functor h, Monad m) => HomM m g h -> HomM m f g -> HomM m f h

-- | This function composes two monadic signature functions.
compSigFunM :: Monad m => SigFunM m g h -> SigFunM m f g -> SigFunM m f h
compSigFunHomM :: (Traversable g, Functor h, Monad m) => SigFunM m g h -> HomM m f g -> HomM m f h

-- | This function composes two monadic signature functions.
compHomSigFunM :: Monad m => HomM m g h -> SigFunM m f g -> HomM m f h

-- | This function composes two monadic signature functions.
compAlgSigFunM :: Monad m => AlgM m g a -> SigFunM m f g -> AlgM m f a

-- | Compose a monadic algebra with a monadic term homomorphism to get a
--   new monadic algebra.
compAlgM :: (Traversable g, Monad m) => AlgM m g a -> HomM m f g -> AlgM m f a

-- | Compose a monadic algebra with a term homomorphism to get a new
--   monadic algebra.
compAlgM' :: (Traversable g, Monad m) => AlgM m g a -> Hom f g -> AlgM m f a

-- | This type represents a coalgebra over a functor <tt>f</tt> and carrier
--   <tt>a</tt>.
type Coalg f a = a -> f a

-- | Construct an anamorphism from the given coalgebra.
ana :: Functor f => Coalg f a -> a -> Term f

-- | Shortcut fusion variant of <a>ana</a>.
ana' :: Functor f => Coalg f a -> a -> Term f

-- | This type represents a monadic coalgebra over a functor <tt>f</tt> and
--   carrier <tt>a</tt>.
type CoalgM m f a = a -> m (f a)

-- | Construct a monadic anamorphism from the given monadic coalgebra.
anaM :: (Traversable f, Monad m) => CoalgM m f a -> a -> m (Term f)

-- | This type represents an r-algebra over a functor <tt>f</tt> and
--   carrier <tt>a</tt>.
type RAlg f a = f (Term f, a) -> a

-- | Construct a paramorphism from the given r-algebra.
para :: Functor f => RAlg f a -> Term f -> a

-- | This type represents a monadic r-algebra over a functor <tt>f</tt> and
--   carrier <tt>a</tt>.
type RAlgM m f a = f (Term f, a) -> m a

-- | Construct a monadic paramorphism from the given monadic r-algebra.
paraM :: (Traversable f, Monad m) => RAlgM m f a -> Term f -> m a

-- | This type represents an r-coalgebra over a functor <tt>f</tt> and
--   carrier <tt>a</tt>.
type RCoalg f a = a -> f (Either (Term f) a)

-- | Construct an apomorphism from the given r-coalgebra.
apo :: Functor f => RCoalg f a -> a -> Term f

-- | This type represents a monadic r-coalgebra over a functor <tt>f</tt>
--   and carrier <tt>a</tt>.
type RCoalgM m f a = a -> m (f (Either (Term f) a))

-- | Construct a monadic apomorphism from the given monadic r-coalgebra.
apoM :: (Traversable f, Monad m) => RCoalgM m f a -> a -> m (Term f)

-- | This type represents a cv-algebra over a functor <tt>f</tt> and
--   carrier <tt>a</tt>.
type CVAlg f a f' = f (Term f') -> a

-- | Construct a histomorphism from the given cv-algebra.
histo :: (Functor f, DistAnn f a f') => CVAlg f a f' -> Term f -> a

-- | This type represents a monadic cv-algebra over a functor <tt>f</tt>
--   and carrier <tt>a</tt>.
type CVAlgM m f a f' = f (Term f') -> m a

-- | Construct a monadic histomorphism from the given monadic cv-algebra.
histoM :: (Traversable f, Monad m, DistAnn f a f') => CVAlgM m f a f' -> Term f -> m a

-- | This type represents a cv-coalgebra over a functor <tt>f</tt> and
--   carrier <tt>a</tt>.
type CVCoalg f a = a -> f (Context f a)

-- | Construct a futumorphism from the given cv-coalgebra.
futu :: Functor f => CVCoalg f a -> a -> Term f

-- | This type represents a generalised cv-coalgebra over a functor
--   <tt>f</tt> and carrier <tt>a</tt>.
type CVCoalg' f a = a -> Context f a

-- | Construct a futumorphism from the given generalised cv-coalgebra.
futu' :: Functor f => CVCoalg' f a -> a -> Term f

-- | This type represents a monadic cv-coalgebra over a functor <tt>f</tt>
--   and carrier <tt>a</tt>.
type CVCoalgM m f a = a -> m (f (Context f a))

-- | Construct a monadic futumorphism from the given monadic cv-coalgebra.
futuM :: (Traversable f, Monad m) => CVCoalgM m f a -> a -> m (Term f)


-- | This module defines annotations on signatures.
module Data.Comp.Annotation

-- | This data type adds a constant product (annotation) to a signature.
data (:&:) f a e
(:&:) :: f e -> a -> (:&:) f a e

-- | Formal product of signatures (functors).
data (:*:) f g a
(:*:) :: f a -> g a -> (:*:) f g a

-- | This class defines how to distribute an annotation over a sum of
--   signatures.
class DistAnn s p s' | s' -> s, s' -> p
injectA :: DistAnn s p s' => p -> s a -> s' a
projectA :: DistAnn s p s' => s' a -> (s a, p)
class RemA s s' | s -> s'
remA :: RemA s s' => s a -> s' a

-- | Transform a function with a domain constructed from a functor to a
--   function with a domain constructed with the same functor, but with an
--   additional annotation.
liftA :: RemA s s' => (s' a -> t) -> s a -> t

-- | Transform a function with a domain constructed from a functor to a
--   function with a domain constructed with the same functor, but with an
--   additional annotation.
liftA' :: (DistAnn s' p s, Functor s') => (s' a -> Cxt h s' a) -> s a -> Cxt h s a

-- | Strip the annotations from a term over a functor with annotations.
stripA :: (RemA g f, Functor g) => CxtFun g f

-- | Lift a term homomorphism over signatures <tt>f</tt> and <tt>g</tt> to
--   a term homomorphism over the same signatures, but extended with
--   annotations.
propAnn :: (DistAnn f p f', DistAnn g p g', Functor g) => Hom f g -> Hom f' g'

-- | Lift a monadic term homomorphism over signatures <tt>f</tt> and
--   <tt>g</tt> to a monadic term homomorphism over the same signatures,
--   but extended with annotations.
propAnnM :: (DistAnn f p f', DistAnn g p g', Functor g, Monad m) => HomM m f g -> HomM m f' g'

-- | Annotate each node of a term with a constant value.
ann :: (DistAnn f p g, Functor f) => p -> CxtFun f g

-- | This function is similar to <tt>project</tt> but applies to signatures
--   with an annotation which is then ignored.
project' :: (RemA f f', s :<: f') => Cxt h f a -> Maybe (s (Cxt h f a))


-- | This module provides the infrastructure to extend signatures.
module Data.Comp.Sum

-- | A constraint <tt>f :&lt;: g</tt> expresses that the signature
--   <tt>f</tt> is subsumed by <tt>g</tt>, i.e. <tt>f</tt> can be used to
--   construct elements in <tt>g</tt>.
type (:<:) f g = Subsume (ComprEmb (Elem f g)) f g
type (:=:) f g = (f :<: g, g :<: f)

-- | Formal sum of signatures (functors).
data (:+:) f g e

-- | Utility function to case on a functor sum, without exposing the
--   internal representation of sums.
caseF :: (f a -> b) -> (g a -> b) -> (f :+: g) a -> b
proj :: f :<: g => g a -> Maybe (f a)

-- | Project the outermost layer of a term to a sub signature. If the
--   signature <tt>g</tt> is compound of <i>n</i> atomic signatures, use
--   <tt>project</tt><i>n</i> instead.
project :: g :<: f => Cxt h f a -> Maybe (g (Cxt h f a))

-- | Tries to coerce a term<i>context to a term</i>context over a
--   sub-signature. If the signature <tt>g</tt> is compound of <i>n</i>
--   atomic signatures, use <tt>deepProject</tt><i>n</i> instead.
deepProject :: (Traversable g, g :<: f) => CxtFunM Maybe f g

-- | Project the outermost layer of a term to a sub signature. If the
--   signature <tt>g</tt> is compound of <i>n</i> atomic signatures, use
--   <tt>project</tt><i>n</i> instead.
project_ :: SigFunM Maybe f g -> Cxt h f a -> Maybe (g (Cxt h f a))

-- | Tries to coerce a term<i>context to a term</i>context over a
--   sub-signature. If the signature <tt>g</tt> is compound of <i>n</i>
--   atomic signatures, use <tt>deepProject</tt><i>n</i> instead.
deepProject_ :: Traversable g => (SigFunM Maybe f g) -> CxtFunM Maybe f g
inj :: f :<: g => f a -> g a

-- | Inject a term where the outermost layer is a sub signature. If the
--   signature <tt>g</tt> is compound of <i>n</i> atomic signatures, use
--   <tt>inject</tt><i>n</i> instead.
inject :: g :<: f => g (Cxt h f a) -> Cxt h f a

-- | Inject a term over a sub signature to a term over larger signature. If
--   the signature <tt>g</tt> is compound of <i>n</i> atomic signatures,
--   use <tt>deepInject</tt><i>n</i> instead.
deepInject :: (Functor g, g :<: f) => CxtFun g f

-- | Inject a term where the outermost layer is a sub signature. If the
--   signature <tt>g</tt> is compound of <i>n</i> atomic signatures, use
--   <tt>inject</tt><i>n</i> instead.
inject_ :: SigFun g f -> g (Cxt h f a) -> Cxt h f a

-- | Inject a term over a sub signature to a term over larger signature. If
--   the signature <tt>g</tt> is compound of <i>n</i> atomic signatures,
--   use <tt>deepInject</tt><i>n</i> instead.
deepInject_ :: Functor g => SigFun g f -> CxtFun g f
split :: f :=: (f1 :+: f2) => (f1 (Term f) -> a) -> (f2 (Term f) -> a) -> Term f -> a
injectConst :: (Functor g, g :<: f) => Const g -> Cxt h f a
projectConst :: (Functor g, g :<: f) => Cxt h f a -> Maybe (Const g)

-- | This function injects a whole context into another context.
injectCxt :: (Functor g, g :<: f) => Cxt h' g (Cxt h f a) -> Cxt h f a

-- | This function lifts the given functor to a context.
liftCxt :: (Functor f, g :<: f) => g a -> Context f a

-- | This function applies the given context with hole type <tt>a</tt> to a
--   family <tt>f</tt> of contexts (possibly terms) indexed by <tt>a</tt>.
--   That is, each hole <tt>h</tt> is replaced by the context <tt>f h</tt>.
substHoles :: (Functor f, Functor g, f :<: g) => Cxt h' f v -> (v -> Cxt h g a) -> Cxt h g a
substHoles' :: (Functor f, Functor g, f :<: g, Ord v) => Cxt h' f v -> Map v (Cxt h g a) -> Cxt h g a
instance (Eq (f a), Eq (g a)) => Eq ((:+:) f g a)
instance (Ord (f a), Ord (g a)) => Ord ((:+:) f g a)
instance (Show (f a), Show (g a)) => Show ((:+:) f g a)


-- | This module defines type generic functions and recursive schemes along
--   the lines of the Uniplate library.
module Data.Comp.Generic

-- | This function returns the subterm of a given term at the position
--   specified by the given path or <tt>Nothing</tt> if the input term has
--   no such subterm
getSubterm :: (Functor g, Foldable g) => [Int] -> Term g -> Maybe (Term g)

-- | This function returns a list of all subterms of the given term. This
--   function is similar to Uniplate's <tt>universe</tt> function.
subterms :: Foldable f => Term f -> [Term f]

-- | This function returns a list of all subterms of the given term that
--   are constructed from a particular functor.
subterms' :: (Foldable f, g :<: f) => Term f -> [g (Term f)]

-- | This function transforms every subterm according to the given function
--   in a bottom-up manner. This function is similar to Uniplate's
--   <tt>transform</tt> function.
transform :: Functor f => (Term f -> Term f) -> Term f -> Term f
transform' :: Functor f => (Term f -> Maybe (Term f)) -> Term f -> Term f

-- | Monadic version of <a>transform</a>.
transformM :: (Traversable f, Monad m) => (Term f -> m (Term f)) -> Term f -> m (Term f)
query :: Foldable f => (Term f -> r) -> (r -> r -> r) -> Term f -> r
gsize :: Foldable f => Term f -> Int

-- | This function computes the generic size of the given term, i.e. the
--   its number of subterm occurrences.
size :: Foldable f => Cxt h f a -> Int

-- | This function computes the generic height of the given term.
height :: Foldable f => Cxt h f a -> Int


-- | This modules defines terms &amp; contexts with thunks, with deferred
--   monadic computations.
module Data.Comp.Thunk

-- | This type represents terms with thunks.
type TermT m f = Term (m :+: f)

-- | This type represents contexts with thunks.
type CxtT m h f a = Cxt h (m :+: f) a

-- | This function turns a monadic computation into a thunk.
thunk :: m (CxtT m h f a) -> CxtT m h f a

-- | This function evaluates all thunks until a non-thunk node is found.
whnf :: Monad m => TermT m f -> m (f (TermT m f))
whnf' :: Monad m => TermT m f -> m (TermT m f)

-- | This function first evaluates the argument term into whnf via
--   <a>whnf</a> and then projects the top-level signature to the desired
--   subsignature. Failure to do the projection is signalled as a failure
--   in the monad.
whnfPr :: (Monad m, g :<: f) => TermT m f -> m (g (TermT m f))

-- | This function evaluates all thunks.
nf :: (Monad m, Traversable f) => TermT m f -> m (Term f)

-- | This function evaluates all thunks while simultaneously projecting the
--   term to a smaller signature. Failure to do the projection is signalled
--   as a failure in the monad as in <a>whnfPr</a>.
nfPr :: (Monad m, Traversable g, g :<: f) => TermT m f -> m (Term g)

-- | This function inspects the topmost non-thunk node (using <a>whnf</a>)
--   according to the given function.
eval :: Monad m => (f (TermT m f) -> TermT m f) -> TermT m f -> TermT m f

-- | This function inspects the topmost non-thunk nodes of two terms (using
--   <a>whnf</a>) according to the given function.
eval2 :: Monad m => (f (TermT m f) -> f (TermT m f) -> TermT m f) -> TermT m f -> TermT m f -> TermT m f

-- | This function inspects a term (using <a>nf</a>) according to the given
--   function.
deepEval :: (Traversable f, Monad m) => (Term f -> TermT m f) -> TermT m f -> TermT m f

-- | This function inspects two terms (using <a>nf</a>) according to the
--   given function.
deepEval2 :: (Monad m, Traversable f) => (Term f -> Term f -> TermT m f) -> TermT m f -> TermT m f -> TermT m f

-- | Variant of <a>eval</a> with flipped argument positions
(#>) :: Monad m => TermT m f -> (f (TermT m f) -> TermT m f) -> TermT m f

-- | Variant of <a>deepEval</a> with flipped argument positions
(#>>) :: (Monad m, Traversable f) => TermT m f -> (Term f -> TermT m f) -> TermT m f

-- | This type represents algebras which have terms with thunks as carrier.
type AlgT m f g = Alg f (TermT m g)

-- | This combinator runs a catamorphism on a term with thunks.
cataT :: (Traversable f, Monad m) => Alg f a -> TermT m f -> m a

-- | This combinator runs a monadic catamorphism on a term with thunks
cataTM :: (Traversable f, Monad m) => AlgM m f a -> TermT m f -> m a

-- | This function decides equality of terms with thunks.
eqT :: (EqF f, Foldable f, Functor f, Monad m) => TermT m f -> TermT m f -> m Bool

-- | This combinator makes the evaluation of the given functor application
--   strict by evaluating all thunks of immediate subterms.
strict :: (f :<: g, Traversable f, Monad m) => f (TermT m g) -> TermT m g

-- | This combinator is a variant of <a>strict</a> that only makes a subset
--   of the arguments of a functor application strict. The first argument
--   of this combinator specifies which positions are supposed to be
--   strict.
strictAt :: (f :<: g, Traversable f, Monad m) => Pos f -> f (TermT m g) -> TermT m g


-- | This module contains functionality for automatically deriving
--   boilerplate code using Template Haskell. Examples include instances of
--   <a>Functor</a>, <a>Foldable</a>, and <a>Traversable</a>.
module Data.Comp.Derive

-- | Helper function for generating a list of instances for a list of named
--   signatures. For example, in order to derive instances <a>Functor</a>
--   and <tt>ShowF</tt> for a signature <tt>Exp</tt>, use derive as follows
--   (requires Template Haskell):
--   
--   <pre>
--   $(derive [makeFunctor, makeShowF] [''Exp])
--   </pre>
derive :: [Name -> Q [Dec]] -> [Name] -> Q [Dec]

-- | Signature printing. An instance <tt>ShowF f</tt> gives rise to an
--   instance <tt>Show (Term f)</tt>.
class ShowF f
showF :: ShowF f => f String -> String

-- | Derive an instance of <a>ShowF</a> for a type constructor of any
--   first-order kind taking at least one argument.
makeShowF :: Name -> Q [Dec]

-- | Constructor printing.
class ShowConstr f
showConstr :: ShowConstr f => f a -> String

-- | Derive an instance of <a>showConstr</a> for a type constructor of any
--   first-order kind taking at least one argument.
makeShowConstr :: Name -> Q [Dec]

-- | Signature equality. An instance <tt>EqF f</tt> gives rise to an
--   instance <tt>Eq (Term f)</tt>.
class EqF f
eqF :: (EqF f, Eq a) => f a -> f a -> Bool

-- | Derive an instance of <a>EqF</a> for a type constructor of any
--   first-order kind taking at least one argument.
makeEqF :: Name -> Q [Dec]

-- | Signature ordering. An instance <tt>OrdF f</tt> gives rise to an
--   instance <tt>Ord (Term f)</tt>.
class EqF f => OrdF f
compareF :: (OrdF f, Ord a) => f a -> f a -> Ordering

-- | Derive an instance of <a>OrdF</a> for a type constructor of any
--   first-order kind taking at least one argument.
makeOrdF :: Name -> Q [Dec]

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)

-- | Derive an instance of <a>Functor</a> for a type constructor of any
--   first-order kind taking at least one argument.
makeFunctor :: Name -> Q [Dec]

-- | Data structures that can be folded.
--   
--   Minimal complete definition: <a>foldMap</a> or <a>foldr</a>.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
class Foldable (t :: * -> *)

-- | Derive an instance of <a>Foldable</a> for a type constructor of any
--   first-order kind taking at least one argument.
makeFoldable :: Name -> Q [Dec]

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   Minimal complete definition: <a>traverse</a> or <a>sequenceA</a>.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Indentity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: * -> *)

-- | Derive an instance of <a>Traversable</a> for a type constructor of any
--   first-order kind taking at least one argument.
makeTraversable :: Name -> Q [Dec]

-- | Derive an instance of <a>HaskellStrict</a> for a type constructor of
--   any first-order kind taking at least one argument.
makeHaskellStrict :: Name -> Q [Dec]
haskellStrict :: (Monad m, HaskellStrict f, f :<: (m :+: g)) => f (TermT m g) -> TermT m g
haskellStrict' :: (Monad m, HaskellStrict f, f :<: (m :+: g)) => f (TermT m g) -> TermT m g

-- | Signature arbitration. An instance <tt>ArbitraryF f</tt> gives rise to
--   an instance <tt>Arbitrary (Term f)</tt>.
class ArbitraryF f where arbitraryF' = [(1, arbitraryF)] arbitraryF = frequency arbitraryF' shrinkF _ = []
arbitraryF' :: (ArbitraryF f, Arbitrary v) => [(Int, Gen (f v))]
arbitraryF :: (ArbitraryF f, Arbitrary v) => Gen (f v)
shrinkF :: (ArbitraryF f, Arbitrary v) => f v -> [f v]

-- | Derive an instance of <a>ArbitraryF</a> for a type constructor of any
--   first-order kind taking at least one argument. It is necessary that
--   all types that are used by the data type definition are themselves
--   instances of <a>Arbitrary</a>.
makeArbitraryF :: Name -> Q [Dec]

-- | Random generation and shrinking of values.
class Arbitrary a
arbitrary :: Arbitrary a => Gen a
shrink :: Arbitrary a => a -> [a]

-- | Derive an instance of <a>Arbitrary</a> for a type constructor.
makeArbitrary :: Name -> Q [Dec]

-- | A class of types that can be fully evaluated.
--   
--   <i>Since: 1.1.0.0</i>
class NFData a
rnf :: NFData a => a -> ()

-- | Derive an instance of <a>NFData</a> for a type constructor.
makeNFData :: Name -> Q [Dec]

-- | Signature normal form. An instance <tt>NFDataF f</tt> gives rise to an
--   instance <tt>NFData (Term f)</tt>.
class NFDataF f
rnfF :: (NFDataF f, NFData a) => f a -> ()

-- | Derive an instance of <a>NFDataF</a> for a type constructor of any
--   first-order kind taking at least one argument.
makeNFDataF :: Name -> Q [Dec]

-- | Derive smart constructors for a type constructor of any first-order
--   kind taking at least one argument. The smart constructors are similar
--   to the ordinary constructors, but an <a>inject</a> is automatically
--   inserted.
smartConstructors :: Name -> Q [Dec]

-- | Derive smart constructors with products for a type constructor of any
--   parametric kind taking at least one argument. The smart constructors
--   are similar to the ordinary constructors, but an <a>injectA</a> is
--   automatically inserted.
smartAConstructors :: Name -> Q [Dec]

-- | Given the name of a type class, where the first parameter is a
--   functor, lift it to sums of functors. Example: <tt>class ShowF f where
--   ...</tt> is lifted as <tt>instance (ShowF f, ShowF g) =&gt; ShowF (f
--   :+: g) where ... </tt>.
liftSum :: Name -> Q [Dec]


-- | This module defines ordering of signatures, which lifts to ordering of
--   terms and contexts.
module Data.Comp.Ordering

-- | Signature ordering. An instance <tt>OrdF f</tt> gives rise to an
--   instance <tt>Ord (Term f)</tt>.
class EqF f => OrdF f
compareF :: (OrdF f, Ord a) => f a -> f a -> Ordering
instance (Ord a0, Ord b0, Ord c0, Ord d0, Ord e0, Ord f0, Ord g0, Ord h0, Ord i0) => OrdF ((,,,,,,,,,) a0 b0 c0 d0 e0 f0 g0 h0 i0)
instance (Ord a0, Ord b0, Ord c0, Ord d0, Ord e0, Ord f0, Ord g0, Ord h0) => OrdF ((,,,,,,,,) a0 b0 c0 d0 e0 f0 g0 h0)
instance (Ord a0, Ord b0, Ord c0, Ord d0, Ord e0, Ord f0, Ord g0) => OrdF ((,,,,,,,) a0 b0 c0 d0 e0 f0 g0)
instance (Ord a0, Ord b0, Ord c0, Ord d0, Ord e0, Ord f0) => OrdF ((,,,,,,) a0 b0 c0 d0 e0 f0)
instance (Ord a0, Ord b0, Ord c0, Ord d0, Ord e0) => OrdF ((,,,,,) a0 b0 c0 d0 e0)
instance (Ord a0, Ord b0, Ord c0, Ord d0) => OrdF ((,,,,) a0 b0 c0 d0)
instance (Ord a0, Ord b0, Ord c0) => OrdF ((,,,) a0 b0 c0)
instance (Ord a0, Ord b0) => OrdF ((,,) a0 b0)
instance Ord a0 => OrdF ((,) a0)
instance OrdF []
instance OrdF Maybe
instance (OrdF f, OrdF g) => OrdF (f :+: g)
instance OrdF f => OrdF (Cxt h f)
instance (OrdF f, Ord a) => Ord (Cxt h f a)


-- | This module defines full evaluation of signatures, which lifts to full
--   evaluation of terms and contexts.
module Data.Comp.DeepSeq

-- | Signature normal form. An instance <tt>NFDataF f</tt> gives rise to an
--   instance <tt>NFData (Term f)</tt>.
class NFDataF f
rnfF :: (NFDataF f, NFData a) => f a -> ()
instance NFData a0 => NFDataF ((,) a0)
instance NFDataF []
instance NFDataF Maybe
instance (NFDataF f, NFDataF g) => NFDataF (f :+: g)
instance (NFDataF f, NFData a) => NFDataF (f :&: a)
instance (NFDataF f, NFData a) => NFData (Cxt h f a)


-- | This module defines generation of arbitrary values for signatures,
--   which lifts to generating arbitrary terms.
module Data.Comp.Arbitrary

-- | Signature arbitration. An instance <tt>ArbitraryF f</tt> gives rise to
--   an instance <tt>Arbitrary (Term f)</tt>.
class ArbitraryF f where arbitraryF' = [(1, arbitraryF)] arbitraryF = frequency arbitraryF' shrinkF _ = []
arbitraryF' :: (ArbitraryF f, Arbitrary v) => [(Int, Gen (f v))]
arbitraryF :: (ArbitraryF f, Arbitrary v) => Gen (f v)
shrinkF :: (ArbitraryF f, Arbitrary v) => f v -> [f v]
instance (Arbitrary b0, Arbitrary c0, Arbitrary d0, Arbitrary e0, Arbitrary f0, Arbitrary g0, Arbitrary h0, Arbitrary i0, Arbitrary j0) => ArbitraryF ((,,,,,,,,,) b0 c0 d0 e0 f0 g0 h0 i0 j0)
instance (Arbitrary b0, Arbitrary c0, Arbitrary d0, Arbitrary e0, Arbitrary f0, Arbitrary g0, Arbitrary h0, Arbitrary i0) => ArbitraryF ((,,,,,,,,) b0 c0 d0 e0 f0 g0 h0 i0)
instance (Arbitrary b0, Arbitrary c0, Arbitrary d0, Arbitrary e0, Arbitrary f0, Arbitrary g0, Arbitrary h0) => ArbitraryF ((,,,,,,,) b0 c0 d0 e0 f0 g0 h0)
instance (Arbitrary b0, Arbitrary c0, Arbitrary d0, Arbitrary e0, Arbitrary f0, Arbitrary g0) => ArbitraryF ((,,,,,,) b0 c0 d0 e0 f0 g0)
instance (Arbitrary b0, Arbitrary c0, Arbitrary d0, Arbitrary e0, Arbitrary f0) => ArbitraryF ((,,,,,) b0 c0 d0 e0 f0)
instance (Arbitrary b0, Arbitrary c0, Arbitrary d0, Arbitrary e0) => ArbitraryF ((,,,,) b0 c0 d0 e0)
instance (Arbitrary b0, Arbitrary c0, Arbitrary d0) => ArbitraryF ((,,,) b0 c0 d0)
instance (Arbitrary b0, Arbitrary c0) => ArbitraryF ((,,) b0 c0)
instance Arbitrary b0 => ArbitraryF ((,) b0)
instance ArbitraryF []
instance ArbitraryF Maybe
instance (ArbitraryF f, ArbitraryF g) => ArbitraryF (f :+: g)
instance (ArbitraryF f, Arbitrary a) => Arbitrary (Context f a)
instance ArbitraryF f => ArbitraryF (Context f)
instance (ArbitraryF f, Arbitrary p) => ArbitraryF (f :&: p)
instance ArbitraryF f => Arbitrary (Term f)


-- | This module defines showing of signatures, which lifts to showing of
--   terms and contexts.
module Data.Comp.Show

-- | Signature printing. An instance <tt>ShowF f</tt> gives rise to an
--   instance <tt>Show (Term f)</tt>.
class ShowF f
showF :: ShowF f => f String -> String
instance (ShowConstr f, ShowConstr g) => ShowConstr (f :+: g)
instance (ShowConstr f, Show p) => ShowConstr (f :&: p)
instance Show a0 => ShowF ((,) a0)
instance ShowF []
instance ShowF Maybe
instance (ShowF f, ShowF g) => ShowF (f :+: g)
instance (ShowF f, Show p) => ShowF (f :&: p)
instance (Functor f, ShowF f, Show a) => Show (Cxt h f a)
instance (Functor f, ShowF f) => ShowF (Cxt h f)


-- | This module defines an abstract notion of (bound) variables in
--   compositional data types, and scoped substitution. Capture-avoidance
--   is <i>not</i> taken into account.
module Data.Comp.Variables

-- | This multiparameter class defines functors with variables. An instance
--   <tt>HasVar f v</tt> denotes that values over <tt>f</tt> might contain
--   and bind variables of type <tt>v</tt>.
class HasVars f v where isVar _ = Nothing bindsVars _ = empty
isVar :: HasVars f v => f a -> Maybe v
bindsVars :: (HasVars f v, Mapping m a) => f a -> m (Set v)

-- | This type represents substitutions of terms, i.e. finite mappings from
--   variables to terms.
type Subst f v = CxtSubst NoHole () f v

-- | This type represents substitutions of contexts, i.e. finite mappings
--   from variables to contexts.
type CxtSubst h a f v = Map v (Cxt h f a)

-- | Convert variables to holes, except those that are bound.
varsToHoles :: (Traversable f, HasVars f v, Ord v) => Term f -> Context f v

-- | This function checks whether a variable is contained in a context.
containsVar :: (Eq v, HasVars f v, Traversable f, Ord v) => v -> Cxt h f a -> Bool

-- | This function computes the set of variables occurring in a context.
variables :: (Ord v, HasVars f v, Traversable f) => Cxt h f a -> Set v

-- | This function computes the list of variables occurring in a context.
variableList :: (Ord v, HasVars f v, Traversable f) => Cxt h f a -> [v]

-- | This function computes the set of variables occurring in a constant.
variables' :: (Ord v, HasVars f v, Foldable f, Functor f) => Const f -> Set v
substVars :: SubstVars v t a => (v -> Maybe t) -> a -> a

-- | Apply the given substitution.
appSubst :: (Ord v, SubstVars v t a) => Map v t -> a -> a

-- | This function composes two substitutions <tt>s1</tt> and <tt>s2</tt>.
--   That is, applying the resulting substitution is equivalent to first
--   applying <tt>s2</tt> and then <tt>s1</tt>.
compSubst :: (Ord v, HasVars f v, Traversable f) => CxtSubst h a f v -> CxtSubst h a f v -> CxtSubst h a f v

-- | This combinator pairs every argument of a given constructor with the
--   set of (newly) bound variables according to the corresponding
--   <a>HasVars</a> type class instance.
getBoundVars :: (HasVars f v, Traversable f) => f a -> f (Set v, a)

-- | left-biased union of two mappings.
(&) :: Mapping m k => m v -> m v -> m v

-- | This operator constructs a singleton mapping.
(|->) :: Mapping m k => k -> v -> m v

-- | This is the empty mapping.
empty :: Mapping m k => m v
instance [overlap ok] (SubstVars v t a, Functor f) => SubstVars v t (f a)
instance [overlap ok] (Ord v, HasVars f v, Traversable f) => SubstVars v (Cxt h f a) (Cxt h f a)
instance [overlap ok] HasVars f v => HasVars (f :&: a) v
instance [overlap ok] (HasVars f v0, HasVars g v0) => HasVars (f :+: g) v0


-- | This module implements matching of contexts or terms with variables
--   againts terms
module Data.Comp.Matching

-- | This function takes a context <tt>c</tt> as the first argument and
--   tries to match it against the term <tt>t</tt> (or in general a context
--   with holes in <tt>a</tt>). The context <tt>c</tt> matches the term
--   <tt>t</tt> if there is a <i>matching substitution</i> <tt>s</tt> that
--   maps holes to terms (resp. contexts in general) such that if the holes
--   in the context <tt>c</tt> are replaced according to the substitution
--   <tt>s</tt>, the term <tt>t</tt> is obtained. Note that the context
--   <tt>c</tt> might be non-linear, i.e. has multiple holes that are
--   equal. According to the above definition this means that holes with
--   equal holes have to be instantiated by equal terms!
matchCxt :: (Ord v, EqF f, Eq (Cxt h f a), Functor f, Foldable f) => Context f v -> Cxt h f a -> Maybe (CxtSubst h a f v)

-- | This function is similar to <a>matchCxt</a> but instead of a context
--   it matches a term with variables against a context.
matchTerm :: (Ord v, EqF f, Eq (Cxt h f a), Traversable f, HasVars f v) => Term f -> Cxt h f a -> Maybe (CxtSubst h a f v)


-- | This module defines term rewriting systems (TRSs) using compositional
--   data types.
module Data.Comp.TermRewriting

-- | This type represents <i>recursive program schemes</i>.
type RPS f g = Hom f g

-- | This type represents variables.
type Var = Int

-- | This type represents term rewrite rules from signature <tt>f</tt> to
--   signature <tt>g</tt> over variables of type <tt>v</tt>
type Rule f g v = (Context f v, Context g v)

-- | This type represents term rewriting systems (TRSs) from signature
--   <tt>f</tt> to signature <tt>g</tt> over variables of type <tt>v</tt>.
type TRS f g v = [Rule f g v]

-- | This type represents a potential single step reduction from any input.
type Step t = t -> Maybe t

-- | This type represents a potential single step reduction from any input.
--   If there is no single step then the return value is the input together
--   with <tt>False</tt>. Otherwise, the successor is returned together
--   with <tt>True</tt>.
type BStep t = t -> (t, Bool)

-- | This function tries to match the given rule against the given term
--   (resp. context in general) at the root. If successful, the function
--   returns the right hand side of the rule and the matching substitution.
matchRule :: (Ord v, EqF f, Eq a, Functor f, Foldable f) => Rule f g v -> Cxt h f a -> Maybe (Context g v, Map v (Cxt h f a))

-- | This function tries to match the rules of the given TRS against the
--   given term (resp. context in general) at the root. The first rule in
--   the TRS that matches is then used and the corresponding right-hand
--   side as well the matching substitution is returned.
matchRules :: (Ord v, EqF f, Eq a, Functor f, Foldable f) => TRS f g v -> Cxt h f a -> Maybe (Context g v, Map v (Cxt h f a))

-- | This function tries to apply the given rule at the root of the given
--   term (resp. context in general). If successful, the function returns
--   the result term of the rewrite step; otherwise <tt>Nothing</tt>.
appRule :: (Ord v, EqF f, Eq a, Functor f, Foldable f) => Rule f f v -> Step (Cxt h f a)

-- | This function tries to apply one of the rules in the given TRS at the
--   root of the given term (resp. context in general) by trying each rule
--   one by one using <a>appRule</a> until one rule is applicable. If no
--   rule is applicable <tt>Nothing</tt> is returned.
appTRS :: (Ord v, EqF f, Eq a, Functor f, Foldable f) => TRS f f v -> Step (Cxt h f a)

-- | This is an auxiliary function that turns function <tt>f</tt> of type
--   <tt>(t -&gt; Maybe t)</tt> into functions <tt>f'</tt> of type <tt>t
--   -&gt; (t,Bool)</tt>. <tt>f' x</tt> evaluates to <tt>(y,True)</tt> if
--   <tt>f x</tt> evaluates to <tt>Just y</tt>, and to <tt>(x,False)</tt>
--   if <tt>f x</tt> evaluates to <tt>Nothing</tt>. This function is useful
--   to change the output of functions that apply rules such as
--   <a>appTRS</a>.
bStep :: Step t -> BStep t

-- | This function performs a parallel reduction step by trying to apply
--   rules of the given system to all outermost redexes. If the given term
--   contains no redexes, <tt>Nothing</tt> is returned.
parTopStep :: (Ord v, EqF f, Eq a, Foldable f, Functor f) => TRS f f v -> Step (Cxt h f a)

-- | This function performs a parallel reduction step by trying to apply
--   rules of the given system to all outermost redexes and then
--   recursively in the variable positions of the redexes. If the given
--   term does not contain any redexes, <tt>Nothing</tt> is returned.
parallelStep :: (Ord v, EqF f, Eq a, Foldable f, Functor f) => TRS f f v -> Step (Cxt h f a)

-- | This function applies the given reduction step repeatedly until a
--   normal form is reached.
reduce :: Step t -> t -> t


-- | This module implements the decomposition of terms into function
--   symbols and arguments resp. variables.
module Data.Comp.Decompose

-- | This type represents decompositions of functorial values.
data Decomp f v a
Var :: v -> Decomp f v a
Fun :: (Const f) -> [a] -> Decomp f v a

-- | This type represents decompositions of terms.
type DecompTerm f v = Decomp f v (Term f)

-- | This class specifies the decomposability of a functorial value.
class (HasVars f v, Functor f, Foldable f) => Decompose f v where decomp t = case isVar t of { Just v -> Var v Nothing -> Fun sym args where sym = fmap (const ()) t args = arguments t }
decomp :: Decompose f v => f a -> Decomp f v a

-- | This function computes the structure of a functorial value.
structure :: Functor f => f a -> Const f

-- | This function computes the arguments of a functorial value.
arguments :: Foldable f => f a -> [a]

-- | This function decomposes a term.
decompose :: Decompose f v => Term f -> DecompTerm f v
instance (HasVars f v, Functor f, Foldable f) => Decompose f v


-- | This module implements a simple unification algorithm using
--   compositional data types.
module Data.Comp.Unification

-- | This type represents equations between terms over a specific
--   signature.
type Equation f = (Term f, Term f)

-- | This type represents list of equations.
type Equations f = [Equation f]

-- | This type represents errors that might occur during the unification.
data UnifError f v
FailedOccursCheck :: v -> (Term f) -> UnifError f v
HeadSymbolMismatch :: (Term f) -> (Term f) -> UnifError f v
UnifError :: String -> UnifError f v

-- | This is used in order to signal a failed occurs check during
--   unification.
failedOccursCheck :: MonadError (UnifError f v) m => v -> Term f -> m a

-- | This is used in order to signal a head symbol mismatch during
--   unification.
headSymbolMismatch :: MonadError (UnifError f v) m => Term f -> Term f -> m a

-- | This function applies a substitution to each term in a list of
--   equations.
appSubstEq :: (Ord v, HasVars f v, Traversable f) => Subst f v -> Equation f -> Equation f

-- | This function returns the most general unifier of the given equations
--   using the algorithm of Martelli and Montanari.
unify :: (MonadError (UnifError f v) m, Decompose f v, Ord v, Eq (Const f), Traversable f) => Equations f -> m (Subst f v)

-- | This type represents the state for the unification algorithm.
data UnifyState f v
UnifyState :: Equations f -> Subst f v -> UnifyState f v
usEqs :: UnifyState f v -> Equations f
usSubst :: UnifyState f v -> Subst f v

-- | This is the unification monad that is used to run the unification
--   algorithm.
type UnifyM f v m a = StateT (UnifyState f v) m a

-- | This function runs a unification monad with the given initial list of
--   equations.
runUnifyM :: MonadError (UnifError f v) m => UnifyM f v m a -> Equations f -> m (Subst f v)
withNextEq :: Monad m => (Equation f -> UnifyM f v m ()) -> UnifyM f v m ()
putEqs :: Monad m => Equations f -> UnifyM f v m ()
putBinding :: (Monad m, Ord v, HasVars f v, Traversable f) => (v, Term f) -> UnifyM f v m ()
runUnify :: (MonadError (UnifError f v) m, Decompose f v, Ord v, Eq (Const f), Traversable f) => UnifyM f v m ()
unifyStep :: (MonadError (UnifError f v) m, Decompose f v, Ord v, Eq (Const f), Traversable f) => Equation f -> UnifyM f v m ()


-- | This module defines the infrastructure necessary to use
--   <i>Compositional Data Types</i>. Compositional Data Types is an
--   extension of Wouter Swierstra's Functional Pearl: <i>Data types a la
--   carte</i>. Examples of usage are bundled with the package in the
--   library <tt>examples/Examples</tt>.
module Data.Comp

module Data.Comp.Render

-- | The <a>stringTree</a> algebra of a functor. The default instance
--   creates a tree with the same structure as the term.
class (Functor f, Foldable f, ShowConstr f) => Render f where stringTreeAlg f = Node (showConstr f) $ toList f
stringTreeAlg :: Render f => Alg f (Tree String)

-- | Convert a term to a <a>Tree</a>
stringTree :: Render f => Term f -> Tree String

-- | Show a term using ASCII art
showTerm :: Render f => Term f -> String

-- | Print a term using ASCII art
drawTerm :: Render f => Term f -> IO ()

-- | Write a term to an HTML file with foldable nodes
writeHtmlTerm :: Render f => FilePath -> Term f -> IO ()
instance (Render f, Render g) => Render (f :+: g)


-- | This modules defines the <a>Desugar</a> type class for desugaring of
--   terms.
module Data.Comp.Desugar

-- | The desugaring term homomorphism.
class (Functor f, Functor g) => Desugar f g where desugHom = desugHom' . fmap Hole desugHom' x = appCxt (desugHom x)
desugHom :: Desugar f g => Hom f g
desugHom' :: Desugar f g => Alg f (Context g a)

-- | Desugar a term.
desugar :: Desugar f g => Term f -> Term g

-- | Lift desugaring to annotated terms.
desugarA :: (Functor f', Functor g', DistAnn f p f', DistAnn g p g', Desugar f g) => Term f' -> Term g'

-- | Default desugaring instance.
instance [overlap ok] (Functor f, Functor g, f :<: g) => Desugar f g
instance [overlap ok] (Desugar f h, Desugar g h) => Desugar (f :+: g) h
