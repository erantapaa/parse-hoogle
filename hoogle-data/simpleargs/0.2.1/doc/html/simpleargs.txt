-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides a more flexible getArgs function with better error reporting.
--   
--   The provided getArgs returns an arbitrary tuple of values instead of a
--   list of Strings. This means that the number and type (i.e.
--   parseability) of parameters are checked, and reported to the user. The
--   module is not a substitute for proper error handling (use
--   <a>System.Console.GetOpt</a> for that), but is useful for making quick
--   and dirty command line tools a bit less dirty, without sacrificing the
--   quick part.
@package simpleargs
@version 0.2.1


-- | Provide a <tt>getArgs</tt> function that is slightly more advanced
--   than the default, without going the entire
--   <tt>System.Console.GetOpt</tt> route.
--   
--   The idea is to return a tuple (including the 0-tuple <tt>()</tt> or
--   1-tuple) if the supplied arguments match the demands of the program
--   (in number and in type) or a sensible error message if not. The
--   returned tuple must contain elements that are in the <tt>Typeable</tt>
--   and <tt>Read</tt> classes.
--   
--   As an examle, here's a simple line counting program. Here
--   <tt>getArgs</tt> makes the program take a single parameter, and
--   returns it as a <tt>String</tt>:
--   
--   <pre>
--   main = getArgs &gt;&gt;= readFile &gt;&gt;= print . length . lines
--   </pre>
--   
--   This program will take two parameters, a <tt>Char</tt> and a
--   <tt>String</tt>:
--   
--   <pre>
--   main = do
--      (ch,name) &lt;- getArgs
--      putStrLn (ch:"Name is: "++name)
--   </pre>
module System.SimpleArgs
class Args a
getArgs :: Args a => IO a
instance [overlap ok] (Read t1, Typeable t1, Read t2, Typeable t2, Read t3, Typeable t3, Read t4, Typeable t4, Read t5, Typeable t5) => Args (t1, t2, t3, t4, t5)
instance [overlap ok] (Read t1, Typeable t1, Read t2, Typeable t2, Read t3, Typeable t3, Read t4, Typeable t4) => Args (t1, t2, t3, t4)
instance [overlap ok] (Read t1, Typeable t1, Read t2, Typeable t2, Read t3, Typeable t3) => Args (t1, t2, t3)
instance [overlap ok] (Read x, Typeable x, Read y, Typeable y) => Args (x, y)
instance [overlap ok] (Read b, Typeable b) => Args b
instance [overlap ok] Args ()
