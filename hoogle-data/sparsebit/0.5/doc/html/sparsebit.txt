-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sparse bitmaps for pattern match coverage
--   
--   Pattern matching coverage over Algebraic Data Types(ADTs) has most
--   often been studied in the context of pattern compilation algorithms.
--   However, it is worth considering the pattern matching coverage problem
--   in isolation, since general solutions will be independent of the
--   specifics of any implementation or language. We define an intuitive
--   and mathematically well-established bit masking semantics for pattern
--   match coverage. We design and implement a sparse bitmap data
--   structure, which realizes this semantics in a compact and flexible
--   manner. This bitmap data structure supports computing coverage
--   solutions of large programs incrementally from coverage solutions of
--   sub-programs. It can also be used as a common data representation for
--   pattern coverage shared between different tools (e.g., compilers,
--   linting tools, software analysis tools) that need pattern match
--   coverage information.
@package sparsebit
@version 0.5


-- | This library packages the functional peal paper 'Sparse Bitmaps for
--   Pattern Match Coverage' submitted to ICFP 2009 by Ki Yung Ahn and Tim
--   Sheard. You can look up the tutorial-like paper and the talk slides,
--   which are availabel at:
--   
--   <a>http://kyagrd.dyndns.org/wiki/SparseBitmapsForPatternMatchCoverage
--   </a>
--   
--   Abstract:
--   
--   Pattern matching coverage over Algebraic Data Types(ADTs) has most
--   often been studied in the context of pattern compilation algorithms.
--   However, it is worth considering the pattern matching coverage problem
--   in isolation, since general solutions will be independent of the
--   specifics of any implementation or language.
--   
--   We define an intuitive and mathematically well-established bit masking
--   semantics for pattern match coverage. We design and implement a sparse
--   bitmap data structure, which realizes this semantics in a compact and
--   flexible manner. This bitmap data structure supports computing
--   coverage solutions of large programs incrementally from coverage
--   solutions of sub-programs. It can also be used as a common data
--   representation for pattern coverage shared between different tools
--   (e.g., compilers, linting tools, software analysis tools) that need
--   pattern match coverage information.
module Data.SparseBIT
class Expand t
(*.) :: Expand t => t -> t -> t
unit :: Expand t => t
expand :: Expand t => t -> [t]
data BIT t

-- | all 0 bits (identity on (<a>.|</a>))
O :: t -> BIT t

-- | all 1 bits (identity on (<a>.&amp;</a>))
I :: t -> BIT t

-- | sequence of bits (possibley nested)
Bs :: [BIT t] -> t -> BIT t

-- | extract the type information of a given bit
--   
--   For example,
--   
--   <pre>
--   typeof (O Bool) = Bool 
--   typeof (I Bool) = Int
--   typeof (Bs [O unit,I unit] Bool) = Bool
--   </pre>
typeof :: BIT t -> t

-- | turn bits into strings without the type information
--   
--   For example,
--   
--   <pre>
--   showB (Bs [O unit,I unit] Bool) = "[01]"
--   </pre>
showB :: BIT t -> String

-- | same as <a>showB</a> but takes off the outermost square bracket
--   
--   For example,
--   
--   <pre>
--   showB' (Bs [O unit,I unit] Bool) = "01"
--   </pre>
showB' :: BIT t -> String

-- | print a newline ended string produced from <a>showB'</a> on the
--   standard output
printB :: BIT t -> IO ()

-- | bitwise-and
(.&) :: BIT t -> BIT t -> BIT t
(.&.) :: [BIT t] -> [BIT t] -> [BIT t]

-- | bitwise-or
(.|) :: BIT t -> BIT t -> BIT t
(.|.) :: [BIT t] -> [BIT t] -> [BIT t]

-- | bitwise negation
neg :: BIT t -> BIT t

-- | reduce <a>BIT</a>s to canonical forms
reduce :: BIT t -> BIT t

-- | tensor product
(.**) :: Expand t => BIT t -> BIT t -> BIT t

-- | congruence modulo <a>reduce</a>
(=:=) :: Eq t => BIT t -> BIT t -> Bool
instance Eq t => Eq (BIT t)
instance Show t => Show (BIT t)
