-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Human exchangable identifiers and locators
--   
--   Human exchangable identifiers and locators
@package locators
@version 0.2.4.2


-- | <i>Background</i>
--   
--   We had a need for identifiers that could be used by humans.
--   
--   The requirement to be able to say these over the phone complicates
--   matters. Most people have approached this problem by using a phonetic
--   alphabet. The trouble comes when you hear people saying stuff like "A
--   as in ... uh, Apple?" (should be Alpha, of course) and "U as in ...
--   um, what's a word that starts with U?" It gets worse. Ever been to a
--   GPG keysigning? Listen to people attempt to read out the digits of
--   their key fingerprints. ...C 3 E D 0 0 0 0 0 0 0 2 B D B D... "Did you
--   say 'C' or 'D'?" and "how many zeros was that?" Brutal.
--   
--   So what we need is a symbol set where each digit is unambigious and
--   doesn't collide with the phonetics of another symbol. This package
--   provides Locator16, a set of 16 letters and numbers that, when spoken
--   in English, have unique pronounciation.
--   
--   Also included is code to work in base 62, which is simply
--   <tt>['0'</tt>-<tt>'9'</tt>, <tt>'A'</tt>-<tt>'Z'</tt>, and
--   <tt>'a'</tt>-<tt>'z']</tt>. These are frequently used to express short
--   codes in URL redirectors; you may find them a more useful encoding for
--   expressing numbers than base 16 hexidecimal.
module Data.Locator
class (Ord α, Enum α, Bounded α) => Locator α
locatorToDigit :: Locator α => α -> Char
digitToLocator :: Locator α => Char -> α

-- | A symbol set with sixteen uniquely pronounceable digits.
--   
--   The fact there are sixteen symbols is more an indication of a certain
--   degree of bullheaded-ness on the part of the author, and less of any
--   kind of actual requirement. We might have a slighly better readback
--   score if we dropped to 15 or 14 unique characters. It does mean you
--   can match up with hexidecimal, which is not entirely without merit.
--   
--   The grouping of letters and numbers was the hard part; having come up
--   with the set and deconflicted the choices, the ordering is then
--   entirely arbitrary. Since there are some numbers, might as well have
--   them at the same place they correspond to in base 10; the letters were
--   then allocated in alpha order in the remaining slots.
data English16

-- | <tt>'0'</tt> <i>0th</i>
Zero :: English16

-- | <tt>'1'</tt> <i>1st</i>
One :: English16

-- | <tt>'2'</tt> <i>2nd</i>
Two :: English16

-- | <tt>'C'</tt> <i>3rd</i>
Charlie :: English16

-- | <tt>'4'</tt> <i>4th</i>
Four :: English16

-- | <tt>'F'</tt> <i>5th</i>
Foxtrot :: English16

-- | <tt>'H'</tt> <i>6th</i>
Hotel :: English16

-- | <tt>'7'</tt> <i>7th</i>
Seven :: English16

-- | <tt>'8'</tt> <i>8th</i>
Eight :: English16

-- | <tt>'9'</tt> <i>9th</i>
Nine :: English16

-- | <tt>'K'</tt> <i>10th</i>
Kilo :: English16

-- | <tt>'L'</tt> <i>11th</i>
Lima :: English16

-- | <tt>'M'</tt> <i>12th</i>
Mike :: English16

-- | <tt>'R'</tt> <i>13th</i>
Romeo :: English16

-- | <tt>'X'</tt> <i>14th</i>
XRay :: English16

-- | <tt>'Y'</tt> <i>15th</i>
Yankee :: English16

-- | Given a number encoded in Locator16, convert it back to an integer.
fromLocator16 :: String -> Int

-- | Given a number, convert it to a string in the Locator16 base 16 symbol
--   alphabet. You can use this as a replacement for the standard '0'-'9'
--   'A'-'F' symbols traditionally used to express hexidemimal, though
--   really the fact that we came up with 16 total unique symbols was a
--   nice co-incidence, not a requirement.
toLocator16 :: Int -> String

-- | Represent a number in Locator16a format. This uses the Locator16
--   symbol set, and additionally specifies that no symbol can be repeated.
--   The <i>a</i> in Locator16a represents that this transformation is done
--   on the cheap; when converting if we end up with '9' '9' we simply pick
--   the subsequent digit in the enum, in this case getting you '9' 'K'.
--   
--   Note that the transformation is <i>not</i> reversible. A number like
--   <tt>4369</tt> (which is <tt>0x1111</tt>, incidentally) encodes as
--   <tt>12C4</tt>. So do <tt>4370</tt>, <tt>4371</tt>, and <tt>4372</tt>.
--   The point is not uniqueness, but readibility in adverse conditions. So
--   while you can count locators, they don't map continuously to base10
--   integers.
--   
--   The first argument is the number of digits you'd like in the locator;
--   if the number passed in is less than 16^limit, then the result will be
--   padded.
--   
--   <pre>
--   &gt;&gt;&gt; toLocator16a 6 4369
--   12C40F
--   </pre>
toLocator16a :: Int -> Int -> String

-- | Take an arbitrary sequence of bytes, hash it with SHA1, then format as
--   a short <tt>digits</tt>-long Locator16 string.
--   
--   <pre>
--   &gt;&gt;&gt; hashStringToLocator16a 6 "Hello World"
--   M48HR0
--   </pre>
hashStringToLocator16a :: Int -> ByteString -> ByteString
toBase62 :: Integer -> String
fromBase62 :: String -> Integer

-- | Utility function to prepend '0' characters to a string representing a
--   number. This allows you to ensure a fixed width for numbers that are
--   less than the desired width in size. This comes up frequently when
--   representing numbers in other bases greater than 10 as they are
--   inevitably presented as text, and not having them evenly justified can
--   (at best) be ugly and (at worst) actually lead to parsing and
--   conversion bugs.
padWithZeros :: Int -> String -> String

-- | Take an arbitrary string, hash it, then pad it with zeros up to be a
--   <tt>digits</tt>-long string in base 62.
--   
--   You may be interested to know that the 160-bit SHA1 hash used here can
--   be expressed without loss as 27 digits of base 62, for example:
--   
--   <pre>
--   &gt;&gt;&gt; hashStringToBase62 27 "Hello World"
--   1T8Sj4C5jVU6iQXCwCwJEPSWX6u
--   </pre>
hashStringToBase62 :: Int -> ByteString -> ByteString
