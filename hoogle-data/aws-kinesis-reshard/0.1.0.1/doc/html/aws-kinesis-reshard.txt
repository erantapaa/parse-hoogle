-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reshard AWS Kinesis streams in response to Cloud Watch metrics
--   
--   Reshard AWS Kinesis streams in response to Cloud Watch metrics
@package aws-kinesis-reshard
@version 0.1.0.1

module Aws.Kinesis.Reshard.Options
data Options
Options :: !Text -> !Text -> !Text -> !Text -> !Integer -> !Double -> !Int -> !Int -> Options
_oAccessKey :: Options -> !Text
_oSecretAccessKey :: Options -> !Text
_oRegion :: Options -> !Text
_oStreamName :: Options -> !Text
_oSampleDuration :: Options -> !Integer
_oShardCapacityThreshold :: Options -> !Double
_oMaximumShardCount :: Options -> !Int
_oReshardingInterval :: Options -> !Int
oStreamName :: Lens' Options Text
oShardCapacityThreshold :: Lens' Options Double
oSecretAccessKey :: Lens' Options Text
oSampleDuration :: Lens' Options Integer
oReshardingInterval :: Lens' Options Int
oRegion :: Lens' Options Text
oMaximumShardCount :: Lens' Options Int
oAccessKey :: Lens' Options Text
accessKeyParser :: Parser Text
secretAccessKeyParser :: Parser Text
regionParser :: Parser Text
streamNameParser :: Parser Text
sampleDurationParser :: Parser Integer
capacityThresholdReader :: ReadM Double
capacityThresholdParser :: Parser Double
maximumShardCountReader :: ReadM Int
maximumShardCountParser :: Parser Int
reshardingIntervalParser :: Parser Int
optionsParser :: Parser Options
parserInfo :: ParserInfo Options
instance Show Options

module Aws.Kinesis.Reshard.Exception
data InvalidRegionException
InvalidRegionException :: !Text -> !Text -> InvalidRegionException
_InvalidRegionException :: Iso' InvalidRegionException (Text, Text)
ireProposedRegion :: Lens' InvalidRegionException Text
ireParsingError :: Lens' InvalidRegionException Text
data InvalidStreamNameException
InvalidStreamNameException :: !Text -> !Text -> InvalidStreamNameException
_InvalidStreamNameException :: Iso' InvalidStreamNameException (Text, Text)
isnProposedStreamName :: Lens' InvalidStreamNameException Text
isnParsingError :: Lens' InvalidStreamNameException Text
newtype NoShardsFoundException
NoShardsFoundException :: StreamName -> NoShardsFoundException
_NoShardsFoundException :: Iso' NoShardsFoundException StreamName
nsfeStreamName :: Iso' NoShardsFoundException StreamName
data InvalidPartitionHashException
InvalidPartitionHashRange :: (PartitionHash, PartitionHash) -> InvalidPartitionHashException
InvalidPartitionHash :: Integer -> Text -> InvalidPartitionHashException
_InvalidPartitionHashRange :: Prism' InvalidPartitionHashException (PartitionHash, PartitionHash)
_InvalidPartitionHash :: Prism' InvalidPartitionHashException (Integer, Text)
instance Exception InvalidPartitionHashException
instance Typeable InvalidPartitionHashException
instance Eq InvalidPartitionHashException
instance Show InvalidPartitionHashException
instance Typeable NoShardsFoundException
instance Eq NoShardsFoundException
instance Show NoShardsFoundException
instance Exception NoShardsFoundException
instance Typeable InvalidStreamNameException
instance Eq InvalidStreamNameException
instance Show InvalidStreamNameException
instance Exception InvalidStreamNameException
instance Typeable InvalidRegionException
instance Eq InvalidRegionException
instance Show InvalidRegionException
instance Exception InvalidRegionException

module Aws.Kinesis.Reshard.Monad
type MonadReshard m = (MonadError SomeException m, MonadReader Options m, MonadIO m, MonadBaseControl IO m, MonadResource m)

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>Error</a> and/or <a>MonadError</a> classes.
class Monad m => MonadError e (m :: * -> *) | m -> e
throwError :: MonadError e m => e -> m a
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: * -> *) | m -> r
ask :: MonadReader r m => m r
local :: MonadReader r m => (r -> r) -> m a -> m a
reader :: MonadReader r m => (r -> a) -> m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)
liftIO :: MonadIO m => IO a -> m a
class MonadBase b m => MonadBaseControl (b :: * -> *) (m :: * -> *) | m -> b where data family StM (m :: * -> *) $a
liftBaseWith :: MonadBaseControl b m => (RunInBase m b -> b a) -> m a
restoreM :: MonadBaseControl b m => StM m a -> m a

-- | A <tt>Monad</tt> which allows for safe resource allocation. In theory,
--   any monad transformer stack included a <tt>ResourceT</tt> can be an
--   instance of <tt>MonadResource</tt>.
--   
--   Note: <tt>runResourceT</tt> has a requirement for a
--   <tt>MonadBaseControl IO m</tt> monad, which allows control operations
--   to be lifted. A <tt>MonadResource</tt> does not have this requirement.
--   This means that transformers such as <tt>ContT</tt> can be an instance
--   of <tt>MonadResource</tt>. However, the <tt>ContT</tt> wrapper will
--   need to be unwrapped before calling <tt>runResourceT</tt>.
--   
--   Since 0.3.0
class (MonadThrow m, MonadIO m, Applicative m, MonadBase IO m) => MonadResource (m :: * -> *)
liftResourceT :: MonadResource m => ResourceT IO a -> m a

module Aws.Kinesis.Reshard.Common
kinesisStreamName :: MonadReshard m => m StreamName
runKinesis :: (MonadReshard m, Transaction r α, ServiceConfiguration r ~ KinesisConfiguration, AsMemoryResponse α) => r -> m (MemoryResponse α)

module Aws.Kinesis.Reshard.Metrics
getBytesPerSecond :: MonadReshard m => m Double

module Aws.Kinesis.Reshard.Shards
fetchOpenShards :: MonadReshard m => m [Shard]
countOpenShards :: (MonadReshard m, Integral i) => m i
awaitStreamActive :: MonadReshard m => m ()
data ReshardingAction
SplitShardsAction :: ReshardingAction
MergeShardsAction :: ReshardingAction
performReshardingAction :: MonadReshard m => ReshardingAction -> m ()
instance Eq ReshardingAction
instance Show ReshardingAction

module Aws.Kinesis.Reshard.Analysis
analyzeStream :: MonadReshard m => m (Maybe ReshardingAction)
