-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Self-optimizing unboxed sets using view patterns and data families
--   
--   Self-optimizing unboxed sets using view patterns and data families
@package unboxed-containers
@version 0.0.1

module Data.Set.Unboxed
class US a where { data family USet a; { balance x l r | sizeL + sizeR <= 1 = bin sizeX x l r | sizeR >= delta * sizeL = case viewBin r of { (# v, ly, ry #) | size ly < ratio * size ry -> bin_ v (bin_ x l ly) ry | (# x3, t2, t3 #) <- viewBin ly -> bin_ x3 (bin_ x l t2) (bin_ v t3 ry) } | sizeL >= delta * sizeR = case viewBin l of { (# v, ly, ry #) | size ry < ratio * size ly -> bin_ v ly (bin_ x ry r) | (# x3, t2, t3 #) <- viewBin ry -> bin_ x3 (bin_ v ly t2) (bin_ x t3 r) } | otherwise = bin sizeX x l r where sizeL = size l sizeR = size r sizeX = sizeL + sizeR + 1 null x = size x == 0 size = viewk 0 size' where size' s _ _ _ = s viewBin x = case view x of { Bin _ i l r -> (# i, l, r #) Tip -> error "Data.Set.Unboxed.viewBin" } viewk f k x = case view x of { Bin s i l r -> k s i l r Tip -> f } } }
size :: (US a) => USet a -> Size
null :: (US a) => USet a -> Bool
newtype Boxed a
Boxed :: a -> Boxed a

-- | <i>O(n+m)</i>. See <a>difference</a>.
(\\) :: (US a, Ord a) => USet a -> USet a -> USet a

-- | <i>O(log n)</i>. Is the element in the set?
member :: (US a, Ord a) => a -> USet a -> Bool

-- | <i>O(log n)</i>. Is the element not in the set?
notMember :: (US a, Ord a) => a -> USet a -> Bool

-- | <i>O(n+m)</i>. Is this a subset? <tt>(s1 <a>isSubsetOf</a> s2)</tt>
--   tells whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: (US a, Ord a) => USet a -> USet a -> Bool

-- | <i>O(n+m)</i>. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: (US a, Ord a) => USet a -> USet a -> Bool

-- | <i>O(1)</i>. The empty set.
empty :: (US a) => USet a

-- | <i>O(1)</i>. Create a singleton set.
singleton :: (US a) => a -> USet a

-- | <i>O(log n)</i>. Insert an element in a set. If the set already
--   contains an element equal to the given value, it is replaced with the
--   new value.
insert :: (US a, Ord a) => a -> USet a -> USet a

-- | <i>O(log n)</i>. Delete an element from a set.
delete :: (US a, Ord a) => a -> USet a -> USet a

-- | <i>O(n+m)</i>. The union of two sets, preferring the first set when
--   equal elements are encountered. The implementation uses the efficient
--   <i>hedge-union</i> algorithm. Hedge-union is more efficient on (bigset
--   <a>union</a> smallset).
union :: (US a, Ord a) => USet a -> USet a -> USet a

-- | The union of a list of sets: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unions :: (US a, Ord a) => [USet a] -> USet a

-- | <i>O(n+m)</i>. Difference of two sets. The implementation uses an
--   efficient <i>hedge</i> algorithm comparable with <i>hedge-union</i>.
difference :: (US a, Ord a) => USet a -> USet a -> USet a

-- | <i>O(n+m)</i>. The intersection of two sets. Elements of the result
--   come from the first set, so for example
--   
--   <pre>
--   import qualified Data.Set as S
--   data AB = A | B deriving Show
--   instance Ord AB where compare _ _ = EQ
--   instance Eq AB where _ == _ = True
--   main = print (S.singleton A `S.intersection` S.singleton B,
--                 S.singleton B `S.intersection` S.singleton A)
--   </pre>
--   
--   prints <tt>(fromList [A],fromList [B])</tt>.
intersection :: (US a, Ord a) => USet a -> USet a -> USet a

-- | <i>O(n)</i>. Filter all elements that satisfy the predicate.
filter :: (US a, Ord a) => (a -> Bool) -> USet a -> USet a

-- | <i>O(n)</i>. Partition the set into two sets, one with all elements
--   that satisfy the predicate and one with all elements that don't
--   satisfy the predicate. See also <a>split</a>.
partition :: (US a, Ord a) => (a -> Bool) -> USet a -> (USet a, USet a)

-- | <i>O(log n)</i>. The expression (<tt><a>split</a> x set</tt>) is a
--   pair <tt>(set1,set2)</tt> where <tt>set1</tt> comprises the elements
--   of <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt> comprises the
--   elements of <tt>set</tt> greater than <tt>x</tt>.
split :: (US a, Ord a) => a -> USet a -> (USet a, USet a)

-- | <i>O(log n)</i>. Performs a <a>split</a> but also returns whether the
--   pivot element was found in the original set.
splitMember :: (US a, Ord a) => a -> USet a -> (USet a, Bool, USet a)

-- | <i>O(n*log n)</i>. <tt><a>map</a> f s</tt> is the set obtained by
--   applying <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (US a, US b, Ord a, Ord b) => (a -> b) -> USet a -> USet b

-- | <i>O(n)</i>. The
--   
--   <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>, but works only
--   when <tt>f</tt> is monotonic. <i>The precondition is not checked.</i>
--   Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls] 
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = toList s
--   </pre>
mapMonotonic :: (US a, US b) => (a -> b) -> USet a -> USet b

-- | <i>O(n)</i>. Fold over the elements of a set in an unspecified order.
fold :: (US a) => (a -> b -> b) -> b -> USet a -> b

-- | <i>O(log n)</i>. The minimal element of a set.
findMin :: (US a) => USet a -> a

-- | <i>O(log n)</i>. The maximal element of a set.
findMax :: (US a) => USet a -> a

-- | <i>O(log n)</i>. Delete the minimal element.
deleteMin :: (US a) => USet a -> USet a

-- | <i>O(log n)</i>. Delete the maximal element.
deleteMax :: (US a) => USet a -> USet a

-- | <i>O(log n)</i>. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: (US a) => USet a -> (a, USet a)

-- | <i>O(log n)</i>. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: (US a) => USet a -> (a, USet a)

-- | <i>O(log n)</i>. Retrieves the maximal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
maxView :: (US a) => USet a -> Maybe (a, USet a)

-- | <i>O(log n)</i>. Retrieves the minimal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
minView :: (US a) => USet a -> Maybe (a, USet a)

-- | <i>O(n)</i>. The elements of a set.
elems :: (US a) => USet a -> [a]

-- | <i>O(n)</i>. Convert the set to a list of elements.
toList :: (US a) => USet a -> [a]

-- | <i>O(n*log n)</i>. Create a set from a list of elements.
fromList :: (US a, Ord a) => [a] -> USet a

-- | <i>O(n)</i>. Convert the set to an ascending list of elements.
toAscList :: (US a) => USet a -> [a]

-- | <i>O(n)</i>. Build a set from an ascending list in linear time. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: (US a, Eq a) => [a] -> USet a

-- | <i>O(n)</i>. Build a set from an ascending list of distinct elements
--   in linear time. <i>The precondition (input list is strictly ascending)
--   is not checked.</i>
fromDistinctAscList :: (US a) => [a] -> USet a

-- | <i>O(n)</i>. Show the tree that implements the set. The tree is shown
--   in a compressed, hanging format.
showTree :: (US a, Show a) => USet a -> String

-- | <i>O(n)</i>. The expression (<tt>showTreeWith hang wide map</tt>)
--   shows the tree that implements the set. If <tt>hang</tt> is
--   <tt>True</tt>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
--   
--   <pre>
--   Set&gt; putStrLn $ showTreeWith True False $ fromDistinctAscList [1..5]
--   4
--   +--2
--   |  +--1
--   |  +--3
--   +--5
--   
--   Set&gt; putStrLn $ showTreeWith True True $ fromDistinctAscList [1..5]
--   4
--   |
--   +--2
--   |  |
--   |  +--1
--   |  |
--   |  +--3
--   |
--   +--5
--   
--   Set&gt; putStrLn $ showTreeWith False True $ fromDistinctAscList [1..5]
--   +--5
--   |
--   4
--   |
--   |  +--3
--   |  |
--   +--2
--      |
--      +--1
--   </pre>
showTreeWith :: (US a, Show a) => Bool -> Bool -> USet a -> String

-- | <i>O(n)</i>. Test if the internal set structure is valid.
valid :: (US a, Ord a) => USet a -> Bool
instance (Eq a) => Eq (Boxed a)
instance (Ord a) => Ord (Boxed a)
instance (Show a) => Show (Boxed a)
instance (Read a) => Read (Boxed a)
instance (Bounded a) => Bounded (Boxed a)
instance US (Boxed a)
instance US Integer
instance US Float
instance US Double
instance US Word64
instance US Word32
instance US Word16
instance US Word8
instance US Int64
instance US Int32
instance US Int16
instance US Int8
instance US Char
instance US Int
instance (US a, Read a, Ord a) => Read (USet a)
instance (US a, Show a) => Show (USet a)
instance (US a, Ord a) => Ord (USet a)
instance (US a, Eq a) => Eq (USet a)
instance (US a, Ord a) => Monoid (USet a)
