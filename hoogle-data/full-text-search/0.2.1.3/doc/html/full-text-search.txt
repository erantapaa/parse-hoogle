-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | In-memory full text search engine
--   
@package full-text-search
@version 0.2.1.3


-- | An implementation of BM25F ranking. See:
--   
--   <ul>
--   <li>A quick overview:
--   <a>http://en.wikipedia.org/wiki/Okapi_BM25</a></li>
--   <li><i>The Probabilistic Relevance Framework: BM25 and Beyond</i>
--   <a>http://www.soi.city.ac.uk/~ser/papers/foundations_bm25_review.pdf</a></li>
--   <li><i>An Introduction to Information Retrieval</i>
--   <a>http://nlp.stanford.edu/IR-book/pdf/irbookonlinereading.pdf</a></li>
--   </ul>
module Data.SearchEngine.BM25F

-- | The BM25F score for a document for a given set of terms.
score :: (Ix field, Bounded field, Ix feature, Bounded feature) => Context term field feature -> Doc term field feature -> [term] -> Float
data Context term field feature
Context :: !Int -> (field -> Float) -> (term -> Int) -> !Float -> (field -> Float) -> (field -> Float) -> (feature -> Float) -> (feature -> FeatureFunction) -> Context term field feature
numDocsTotal :: Context term field feature -> !Int
avgFieldLength :: Context term field feature -> field -> Float
numDocsWithTerm :: Context term field feature -> term -> Int
paramK1 :: Context term field feature -> !Float
paramB :: Context term field feature -> field -> Float
fieldWeight :: Context term field feature -> field -> Float
featureWeight :: Context term field feature -> feature -> Float
featureFunction :: Context term field feature -> feature -> FeatureFunction
data FeatureFunction

-- | <pre>
--   log (lambda_i + f_i)
--   </pre>
LogarithmicFunction :: Float -> FeatureFunction

-- | <pre>
--   f_i / (lambda_i + f_i)
--   </pre>
RationalFunction :: Float -> FeatureFunction

-- | <pre>
--   1 / (lambda + exp(-(lambda' * f_i))
--   </pre>
SigmoidFunction :: Float -> Float -> FeatureFunction
data Doc term field feature
Doc :: (field -> Int) -> (field -> term -> Int) -> (feature -> Float) -> Doc term field feature
docFieldLength :: Doc term field feature -> field -> Int
docFieldTermFrequency :: Doc term field feature -> field -> term -> Int
docFeatureValue :: Doc term field feature -> feature -> Float

-- | Most of the time we want to score several different documents for the
--   same set of terms, but sometimes we want to score one document for
--   many terms and in that case we can save a bit of work by doing it in
--   bulk. It lets us calculate once and share things that depend only on
--   the document, and not the term.
--   
--   To take advantage of the sharing you must partially apply and name the
--   per-doc score functon, e.g.
--   
--   <pre>
--   let score :: term -&gt; (field -&gt; Int) -&gt; Float
--       score = BM25.bulkScorer ctx doc
--    in sum [ score t (\f -&gt; counts ! (t, f)) | t &lt;- ts ]
--   </pre>
scoreTermsBulk :: (Ix field, Bounded field) => Context term field feature -> Doc term field feature -> (term -> (field -> Int) -> Float)

-- | A breakdown of the BM25F score, to explain somewhat how it relates to
--   the inputs, and so you can compare the scores of different documents.
data Explanation field feature term
Explanation :: Float -> [(term, Float)] -> [(feature, Float)] -> [(term, [(field, Float)])] -> Explanation field feature term

-- | The overall score is the sum of the <a>termScores</a>,
--   <tt>positionScore</tt> and <tt>nonTermScore</tt>
overallScore :: Explanation field feature term -> Float

-- | There is a score contribution from each query term. This is the score
--   for the term across all fields in the document (but see
--   <a>termFieldScores</a>).
termScores :: Explanation field feature term -> [(term, Float)]

-- | The document can have an inate bonus score independent of the terms in
--   the query. For example this might be a popularity score.
nonTermScores :: Explanation field feature term -> [(feature, Float)]

-- | This does <i>not</i> contribute to the <a>overallScore</a>. It is an
--   indication of how the <a>termScores</a> relates to per-field scores.
--   Note however that the term score for all fields is <i>not</i> simply
--   sum of the per-field scores. The point of the BM25F scoring function
--   is that a linear combination of per-field scores is wrong, and BM25F
--   does a more cunning non-linear combination.
--   
--   However, it is still useful as an indication to see scores for each
--   field for a term, to see how the compare.
termFieldScores :: Explanation field feature term -> [(term, [(field, Float)])]
explain :: (Ix field, Bounded field, Ix feature, Bounded feature) => Context term field feature -> Doc term field feature -> [term] -> Explanation field feature term
instance (Show field, Show feature, Show term) => Show (Explanation field feature term)
instance Functor (Explanation field feature)

module Data.SearchEngine

-- | Terms are short strings, usually whole words.
type Term = Text

-- | Execute a normal query. Find the documents in which one or more of the
--   search terms appear and return them in ranked order.
--   
--   The number of documents returned is limited by the
--   <a>paramResultsetSoftLimit</a> and <a>paramResultsetHardLimit</a>
--   paramaters. This also limits the cost of the query (which is primarily
--   the cost of scoring each document).
--   
--   The given terms are all assumed to be complete (as opposed to prefixes
--   like with <tt>queryAutosuggest</tt>).
query :: (Ix field, Bounded field, Ix feature, Bounded feature) => SearchEngine doc key field feature -> [Term] -> [key]

-- | Execute an "auto-suggest" query. This is where one of the search terms
--   is an incomplete prefix and we are looking for possible completions of
--   that search term, and result documents to go with the possible
--   completions.
--   
--   An auto-suggest query only gives useful results when the
--   <a>SearchEngine</a> is configured to use a non-term feature score.
--   That is, when we can give documents an importance score independent of
--   what terms we are looking for. This is because an auto-suggest query
--   is backwards from a normal query: we are asking for relevant terms
--   occurring in important or popular documents so we need some notion of
--   important or popular. Without this we would just be ranking based on
--   term frequency which while it makes sense for normal "forward" queries
--   is pretty meaningless for auto-suggest "reverse" queries. Indeed for
--   single-term auto-suggest queries the ranking function we use will
--   assign 0 for all documents and completions if there is no non-term
--   feature scores.
queryAutosuggest :: (Ix field, Bounded field, Ix feature, Bounded feature) => SearchEngine doc key field feature -> ResultsFilter key -> [Term] -> Term -> ([(Term, Float)], [(key, Float)])

-- | In some applications it is necessary to enforce some security or
--   visibility rule about the query results (e.g. in a typical DB-based
--   application different users can see different data items). Typically
--   it would be too expensive to build different search indexes for the
--   different contexts and so the strategy is to use one index containing
--   everything and filter for visibility in the results. This means the
--   filter condition is different for different queries (e.g. performed on
--   behalf of different users).
--   
--   Filtering the results after a query is possible but not the most
--   efficient thing to do because we've had to score all the not-visible
--   documents. The better thing to do is to filter as part of the query,
--   this way we can filter before the expensive scoring.
--   
--   We provide one further optimisation: bulk predicates. In some
--   applications it can be quicker to check the security/visibility of a
--   whole bunch of results all in one go.
data ResultsFilter key
NoFilter :: ResultsFilter key
FilterPredicate :: (key -> Bool) -> ResultsFilter key
FilterBulkPredicate :: ([key] -> [Bool]) -> ResultsFilter key
initSearchEngine :: (Ix field, Bounded field, Ix feature, Bounded feature) => SearchConfig doc key field feature -> SearchRankParameters field feature -> SearchEngine doc key field feature
data SearchEngine doc key field feature
data SearchConfig doc key field feature
SearchConfig :: (doc -> key) -> (doc -> field -> [Term]) -> (Term -> field -> Term) -> (doc -> feature -> Float) -> SearchConfig doc key field feature
documentKey :: SearchConfig doc key field feature -> doc -> key
extractDocumentTerms :: SearchConfig doc key field feature -> doc -> field -> [Term]
transformQueryTerm :: SearchConfig doc key field feature -> Term -> field -> Term
documentFeatureValue :: SearchConfig doc key field feature -> doc -> feature -> Float
data SearchRankParameters field feature
SearchRankParameters :: !Float -> (field -> Float) -> (field -> Float) -> (feature -> Float) -> (feature -> FeatureFunction) -> !Int -> !Int -> !Int -> !Int -> SearchRankParameters field feature
paramK1 :: SearchRankParameters field feature -> !Float
paramB :: SearchRankParameters field feature -> field -> Float
paramFieldWeights :: SearchRankParameters field feature -> field -> Float
paramFeatureWeights :: SearchRankParameters field feature -> feature -> Float
paramFeatureFunctions :: SearchRankParameters field feature -> feature -> FeatureFunction
paramResultsetSoftLimit :: SearchRankParameters field feature -> !Int
paramResultsetHardLimit :: SearchRankParameters field feature -> !Int
paramAutosuggestPrefilterLimit :: SearchRankParameters field feature -> !Int
paramAutosuggestPostfilterLimit :: SearchRankParameters field feature -> !Int
data FeatureFunction

-- | <pre>
--   log (lambda_i + f_i)
--   </pre>
LogarithmicFunction :: Float -> FeatureFunction

-- | <pre>
--   f_i / (lambda_i + f_i)
--   </pre>
RationalFunction :: Float -> FeatureFunction

-- | <pre>
--   1 / (lambda + exp(-(lambda' * f_i))
--   </pre>
SigmoidFunction :: Float -> Float -> FeatureFunction
data NoFeatures
noFeatures :: NoFeatures -> a
insertDoc :: (Ord key, Ix field, Bounded field, Ix feature, Bounded feature) => doc -> SearchEngine doc key field feature -> SearchEngine doc key field feature
insertDocs :: (Ord key, Ix field, Bounded field, Ix feature, Bounded feature) => [doc] -> SearchEngine doc key field feature -> SearchEngine doc key field feature
deleteDoc :: (Ord key, Ix field, Bounded field) => key -> SearchEngine doc key field feature -> SearchEngine doc key field feature
queryExplain :: (Ix field, Bounded field, Ix feature, Bounded feature) => SearchEngine doc key field feature -> [Term] -> [(Explanation field feature Term, key)]

-- | A breakdown of the BM25F score, to explain somewhat how it relates to
--   the inputs, and so you can compare the scores of different documents.
data Explanation field feature term
Explanation :: Float -> [(term, Float)] -> [(feature, Float)] -> [(term, [(field, Float)])] -> Explanation field feature term

-- | The overall score is the sum of the <a>termScores</a>,
--   <tt>positionScore</tt> and <tt>nonTermScore</tt>
overallScore :: Explanation field feature term -> Float

-- | There is a score contribution from each query term. This is the score
--   for the term across all fields in the document (but see
--   <a>termFieldScores</a>).
termScores :: Explanation field feature term -> [(term, Float)]

-- | The document can have an inate bonus score independent of the terms in
--   the query. For example this might be a popularity score.
nonTermScores :: Explanation field feature term -> [(feature, Float)]

-- | This does <i>not</i> contribute to the <a>overallScore</a>. It is an
--   indication of how the <a>termScores</a> relates to per-field scores.
--   Note however that the term score for all fields is <i>not</i> simply
--   sum of the per-field scores. The point of the BM25F scoring function
--   is that a linear combination of per-field scores is wrong, and BM25F
--   does a more cunning non-linear combination.
--   
--   However, it is still useful as an indication to see scores for each
--   field for a term, to see how the compare.
termFieldScores :: Explanation field feature term -> [(term, [(field, Float)])]
setRankParams :: SearchRankParameters field feature -> SearchEngine doc key field feature -> SearchEngine doc key field feature
invariant :: (Ord key, Ix field, Bounded field) => SearchEngine doc key field feature -> Bool
