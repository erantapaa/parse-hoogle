-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for implementing a Deck of Cards
--   
--   HCard provides a standard interface to a deck of cards -- providing
--   shuffling, permutation irrelevant equality of hands, etc.
@package HCard
@version 0.0


-- | Author : Joe Fredette License : BSD3 Copyright : Joe Fredette
--   
--   Maintainer : Joe Fredette <a>jfredett.at.gmail.dot.com</a> Stability :
--   Unstable Portability : portable
module Data.HCard.Instances

-- | The Suits of the so-called <a>French</a> deck, the most common
--   American deck of cards.
data Suit
H :: Suit
D :: Suit
C :: Suit
S :: Suit

-- | The Indices of the french deck
data Index
Ace :: Index
Jack :: Index
Queen :: Index
King :: Index
V :: Int -> Index

-- | Type synonyms to make using the polymorphic bits easier
type Classic = CardT Suit Index
type ClassicDeck = Deck Suit Index
type ClassicDeckST = DeckST Suit Index
type ClassicHand = Hand Suit Index

-- | Wrapper which forces the polymorphic dealHands to work with
--   French-deck cards only.
deal :: Int -> Int -> ClassicDeckST [ClassicHand]


-- | Author : Joe Fredette License : BSD3 Copyright : Joe Fredette
--   
--   Maintainer : Joe Fredette <a>jfredett.at.gmail.dot.com</a> Stability :
--   Unstable Portability : portable
module Data.HCard

-- | The Main class, this is -- effectively -- a type-indexed record.
--   Specifically, it requires two types, one representing the suit, the
--   other representing the index/rank. The suit, index, and construct
--   functions are generic forms of the record accessors.
--   
--   The bulk of the implementation takes place in generic type instances,
--   supporting equality irrelevant of ordering, ordering, parsing from a
--   <a>normal form</a> (<a>index</a>-<a>suit</a>) and enum/bounded
--   
--   TODO: Write deriving instance?
class (Eq s, Eq i, Show s, Show i) => Card s i where { data family CardT s i :: *; { x @@ y = construct x y } }
suit :: Card s i => CardT s i -> s
index :: Card s i => CardT s i -> i
construct :: Card s i => i -> s -> CardT s i
(@@) :: Card s i => i -> s -> CardT s i
type Cards s i = [CardT s i]
class Parse a
parse :: Parse a => String -> a

-- | Separate Deck from Hand, even though the types are isomorphic, we
--   don't want shuffling to be to liberal.
--   
--   TODO: Make Deck clever enough to support reshuffling when the deck
--   runs out -- it should store cards it has already seen till it runs out
--   of the main deck, reshuffle, redeal.
newtype Deck s i
Deck :: (Cards s i) -> Deck s i

-- | Type wrapper for stateful decks, useful for sorting
type DeckST s i = State (Deck s i)

-- | Creates a deck, used as in: `mkDeck::<a>your deck type here</a>`, or
--   w/ inference.
mkDeck :: (Bounded s, Bounded i, Enum s, Enum i, Card s i) => Deck s i

-- | Shuffles a deck given a generator
shuffleDeck :: (Card s i, RandomGen g) => Deck s i -> g -> Deck s i

-- | Shuffles using the standard generator
shuffleDeckIO :: Card s i => Deck s i -> IO (Deck s i)

-- | Deals <tt>n</tt> hands of <tt>qty</tt> cards, written in the state
--   monad.
dealHands :: Card s i => Int -> Int -> (DeckST s i) [Hand s i]

-- | Helper for dealHands, also somewhat useful, equiv. to `dealHands 1
--   qty`
dealHand :: Card s i => Int -> (DeckST s i) (Hand s i)

-- | A type to separate Hands from Decks.
newtype Hand s i
Hand :: (Cards s i) -> Hand s i


-- | Author : Joe Fredette License : BSD3 Copyright : Joe Fredette
--   
--   Maintainer : Joe Fredette <a>jfredett.at.gmail.dot.com</a> Stability :
--   Unstable Portability : portable
module Data.HCard.Examples
cribbageScore :: Classic -> ClassicHand -> Int
toValue :: Classic -> Int
filterSuits :: ClassicHand -> [ClassicHand]
allKTups :: [a] -> [[a]]
uniqPairs :: Eq a => [a] -> [(a, a)]
