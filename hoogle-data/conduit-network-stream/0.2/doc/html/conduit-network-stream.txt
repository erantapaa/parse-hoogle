-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A base layer for network protocols using Conduits
--   
--   A base layer for network protocols using Conduits
@package conduit-network-stream
@version 0.2

module Data.Conduit.Network.Stream.Exceptions
data StreamException
UnexpectedHeader :: Header -> StreamException
ClosedStream :: StreamException
data Header
ConduitSTART :: Header
ConduitEND :: Header
VarInt :: Int -> Header
InvalidHeader :: [Word8] -> Header
EndOfInput :: Header
instance Typeable StreamException
instance Show StreamException
instance Exception StreamException


-- | Easy to use network streaming with conduits. This library properly
--   encodes conduit blocks over a network connection such that
--   
--   <ul>
--   <li>each <a>await</a> corresponds to exactly one <a>yield</a> and</li>
--   <li>each <a>receive</a> corresponds to exactly one <a>send</a>.</li>
--   </ul>
--   
--   It also supports sending and receiving of custom data types via the
--   <a>Sendable</a> and <a>Receivable</a> instances.
--   
--   A simple server/client example (using <tt>-XOverloadedStrings</tt>):
--   
--   <pre>
--   import           Control.Monad.Trans
--   import qualified Data.ByteString             as Strict
--   import qualified Data.ByteString.Lazy        as Lazy
--   import           Data.Conduit
--   import qualified Data.Conduit.List           as CL
--   import           Data.Conduit.Network
--   import           Data.Conduit.Network.Stream
--   
--   client :: IO ()
--   client = runResourceT $ runTCPClient (clientSettings ..) $ \appData -&gt; do       
--   
--       streamData &lt;- toStreamData appData
--   
--       send streamData $ mapM_ yield (["ab", "cd", "ef"] :: [Strict.ByteString])
--       send streamData $ mapM_ yield (["123", "456"]     :: [Strict.ByteString])
--   
--       closeStream streamData
--   
--   server :: IO ()
--   server = runResourceT $ runTCPServer (serverSettings ..) $ \appData -&gt; do
--   
--       streamData &lt;- toStreamData appData
--   
--       bs  &lt;- receive streamData $ CL.consume
--       liftIO $ print (bs  :: [Lazy.ByteString])
--   
--       bs' &lt;- receive streamData $ CL.consume
--       liftIO $ print (bs' :: [Lazy.ByteString])
--   
--       closeStream streamData
--   </pre>
module Data.Conduit.Network.Stream
data StreamData m
toStreamData :: MonadIO n => AppData m -> n (StreamData m)

-- | Close current stream. In order to guarantee process resource
--   finalization, you <i>must</i> use this operator after using
--   <a>receive</a>.
closeStream :: MonadResource m => StreamData m -> m ()

-- | Send one conduit block.
send :: (Monad m, Sendable m a) => StreamData m -> Source m a -> m ()

-- | To define your own <a>Sendable</a> instances, reuse the instances for
--   strict and lazy bytestrings, for example for <a>Data.Text</a>:
--   
--   <pre>
--   instance (Monad m, Sendable m Data.ByteString.ByteString) =&gt; Sendable m Text where
--       encode = Data.Conduit.List.map encodeUtf8 =$= encode
--   </pre>
class Sendable m a
encode :: Sendable m a => Conduit a m EncodedBS

-- | Newtype for properly encoded bytestrings.
data EncodedBS

-- | Receive the next conduit block. Might fail with the
--   <a>ClosedStream</a> exception if used on a stream that has been closed
--   by <a>closeStream</a>.
receive :: (MonadResource m, Receivable a m) => StreamData m -> Sink a m b -> m b

-- | <a>decode</a> is used after receiving the individual conduit block
--   elements. It is therefore not necessary to reuse other <a>decode</a>
--   instances (in contrast to <a>Sendable</a> instance definitions).
class Receivable a m
decode :: Receivable a m => Conduit ByteString m a

-- | For bi-directional conversations you sometimes need the sink of the
--   current stream, since you can't use <a>send</a> within another
--   <a>receive</a>.
--   
--   A simple example:
--   
--   <pre>
--   receive streamData $
--       myConduit =$ streamSink streamData
--   </pre>
--   
--   Note, that each <a>streamSink</a> marks its own conduit block. If you
--   want to sink single block elements, use <a>withElementSink</a>
--   instead.
streamSink :: (Monad m, Sendable m a) => StreamData m -> Sink a m ()

-- | Sink single elements inside the same conduit block. Example:
--   
--   <pre>
--   receive streamData $ withElementSink $ \sinkElem -&gt; do
--       yield singleElem =$ sinkElem
--       mapM_ yield moreElems =$ sinkElem
--   </pre>
withElementSink :: (Monad m, Sendable m a) => StreamData m -> (Sink a m () -> Sink b m c) -> Sink b m c
instance Monad m => Sendable m ByteString
instance Monad m => Sendable m (Int, ByteString)
instance Monad m => Sendable m ByteString
instance Monad m => Receivable ByteString m
instance Monad m => Receivable ByteString m
