-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell To ECMAScript compiler
--   
@package haste-compiler
@version 0.4.4.4


-- | Home-grown parser, just because.
module Haste.Parsing
data Parse a
runParser :: Parse a -> String -> Maybe a

-- | Require a specific character.
char :: Char -> Parse Char

-- | Parse a character that matches a given predicate.
charP :: (Char -> Bool) -> Parse Char

-- | Require a specific string.
string :: String -> Parse String

-- | Apply the first matching parser.
oneOf :: [Parse a] -> Parse a

-- | Invoke a parser with the possibility of failure.
possibly :: Parse a -> Parse (Maybe a)

-- | Invoke a parser at least n times.
atLeast :: Int -> Parse a -> Parse [a]

-- | Parse zero or more characters of whitespace.
whitespace :: Parse String

-- | Parse a non-empty word. A word is a string of at least one
--   non-whitespace character.
word :: Parse String

-- | Parse several words, separated by whitespace.
words :: Parse [String]

-- | Parse an Int.
int :: Parse Int

-- | Parse a floating point number.
double :: Parse Double

-- | Parse a non-negative floating point number.
positiveDouble :: Parse Double

-- | Fail on unwanted input.
suchThat :: Parse a -> (a -> Bool) -> Parse a

-- | A string quoted with the given quotation mark. Strings can contain
--   escaped quotation marks; escape characters are stripped from the
--   returned string.
quotedString :: Char -> Parse String

-- | Skip n characters from the input.
skip :: Int -> Parse ()

-- | Read the rest of the input.
rest :: Parse String

-- | Run a parser with the current parsing state, but don't consume any
--   input.
lookahead :: Parse a -> Parse a

-- | Read one character. Fails if end of stream.
anyChar :: Parse Char
instance Applicative Parse
instance Functor Parse
instance MonadPlus Parse
instance Monad Parse


-- | Yo dawg we heard you like Haste, so we let yo Haste programs compile
--   yo Haste programs!
--   
--   Currently, this API calls the hastec binary. In the future it should
--   probably be the other way around.
module Haste.Compiler
data OptLevel
None :: OptLevel
Basic :: OptLevel
WholeProgram :: OptLevel
data ProgStart
ASAP :: ProgStart
OnLoad :: ProgStart
Custom :: String -> ProgStart
data HasteTarget
TargetFile :: FilePath -> HasteTarget
TargetString :: HasteTarget

-- | Flags to pass to the compiler. Defaults are the same as when invoking
--   hastec directly. Consult hastec --help for more detailed descriptions.
data CompileFlags

-- | How much should the given program be optimized? Default: Basic
cfOptimize :: CompileFlags -> OptLevel

-- | Should the output be debuggable? Debug information will be stripped if
--   the program is minified using Closure. Default: False
cfDebug :: CompileFlags -> Bool

-- | Should the program be minified? This will strip any debug information
--   from the resulting program. Default: False
cfMinify :: CompileFlags -> Bool

-- | Use full Unicode compatibility for Data.Char and friends? Default:
--   False
cfFullUnicode :: CompileFlags -> Bool

-- | Put generated code in a separate namespace? Default: False
cfOwnNamespace :: CompileFlags -> Bool

-- | How should the program be started? Default: OnLoad
cfStart :: CompileFlags -> ProgStart

-- | Javascript files to include in the final program. Default: []
cfJSFiles :: CompileFlags -> [FilePath]

-- | Where to place the compilation output. Default: TargetString
cfTarget :: CompileFlags -> HasteTarget
data CompileResult
Success :: HasteOutput -> CompileResult
Failure :: String -> CompileResult
data HasteOutput
OutFile :: FilePath -> HasteOutput
OutString :: String -> HasteOutput
data HasteInput
InFile :: FilePath -> HasteInput
InString :: String -> HasteInput

-- | Compile a Haste program using the given compiler flags and source
--   directory. Calling this function from the client will always result in
--   failure.
compile :: CompileFlags -> FilePath -> HasteInput -> IO CompileResult
instance Show HasteOutput
instance Show CompileResult
instance Show HasteInput

module Haste.Prim

-- | JSStrings are represented as normal strings server-side; should
--   probably be changed to ByteString or Text.
data JSString
type URL = String
toJSStr :: String -> JSString
fromJSStr :: JSString -> String

-- | Concatenate a series of JSStrings using the specified separator.
catJSStr :: JSString -> [JSString] -> JSString
type JSAny = Ptr Any

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a :: * -> *
toPtr :: a -> Ptr a
fromPtr :: Ptr a -> a
instance [overlap ok] Show JSString
instance [overlap ok] Ord JSString
instance [overlap ok] Eq JSString
instance [overlap ok] IsString JSString


-- | Create functions on the fly from JS strings. Slower but more flexible
--   alternative to the standard FFI.
module Haste.Foreign
class FFI a
class Pack a where pack = unsafePack
pack :: Pack a => Unpacked -> a
class Unpack a where unpack = unsafeUnpack
unpack :: Unpack a => a -> Unpacked

-- | Class for marshallable types. Pack takes an opaque JS value and turns
--   it into the type's proper Haste representation, and unpack is its
--   inverse. The default instances make an effort to prevent wrongly typed
--   values through, but you could probably break them with enough
--   creativity.
class (Pack a, Unpack a) => Marshal a

-- | Opaque type representing a raw, unpacked JS value. The constructors
--   have no meaning, but are only there to make sure GHC doesn't optimize
--   the low level hackery in this module into oblivion.
data Unpacked

-- | The Opaque type is inhabited by values that can be passed to
--   Javascript using their raw Haskell representation. Opaque values are
--   completely useless to Javascript code, and should not be inspected.
--   This is useful for, for instance, storing data in some
--   Javascript-native data structure for later retrieval.
data Opaque a

-- | Creates a function based on the given string of Javascript code. If
--   this code is not well typed or is otherwise incorrect, your program
--   may crash or misbehave in mystifying ways. Haste makes a best-effort
--   try to save you from poorly typed JS here, but there are no
--   guarantees.
--   
--   For instance, the following WILL cause crazy behavior due to wrong
--   types: ffi "(function(x) {return x+1;})" :: Int -&gt; Int -&gt; IO Int
--   
--   In other words, this function is completely unsafe - use with caution.
--   
--   ALWAYS use type signatures for functions defined using this function,
--   as the argument marshalling is decided by the type signature.
ffi :: FFI a => JSString -> a

-- | Export a symbol. That symbol may then be accessed from Javascript
--   through Haste.name() as a normal function. Remember, however, that if
--   you are using --with-js to include your JS, in conjunction with
--   --opt-google-closure or any option that implies it, you will instead
--   need to access your exports through Haste['name'](), or Closure will
--   mangle your function names.
export :: Unpack a => JSString -> a -> IO ()
toOpaque :: a -> Opaque a
fromOpaque :: Opaque a -> a
instance [overlap ok] IOFun (a -> b) => Unpack (a -> b)
instance [overlap ok] Unpack a => Unpack (IO a)
instance [overlap ok] (Pack a, IOFun b) => IOFun (a -> b)
instance [overlap ok] Unpack a => IOFun (IO a)
instance [overlap ok] (Unpack a, FFI b) => FFI (a -> b)
instance [overlap ok] Pack a => FFI (IO a)
instance [overlap ok] (Unpack a, Unpack b, Unpack c, Unpack d, Unpack e, Unpack f, Unpack g, Unpack h, Unpack i, Unpack j) => Unpack (a, b, c, d, e, f, g, h, i, j)
instance [overlap ok] (Unpack a, Unpack b, Unpack c, Unpack d, Unpack e, Unpack f, Unpack g, Unpack h, Unpack i) => Unpack (a, b, c, d, e, f, g, h, i)
instance [overlap ok] (Unpack a, Unpack b, Unpack c, Unpack d, Unpack e, Unpack f, Unpack g, Unpack h) => Unpack (a, b, c, d, e, f, g, h)
instance [overlap ok] (Unpack a, Unpack b, Unpack c, Unpack d, Unpack e, Unpack f, Unpack g) => Unpack (a, b, c, d, e, f, g)
instance [overlap ok] (Unpack a, Unpack b, Unpack c, Unpack d, Unpack e, Unpack f) => Unpack (a, b, c, d, e, f)
instance [overlap ok] (Unpack a, Unpack b, Unpack c, Unpack d, Unpack e) => Unpack (a, b, c, d, e)
instance [overlap ok] (Unpack a, Unpack b, Unpack c, Unpack d) => Unpack (a, b, c, d)
instance [overlap ok] (Unpack a, Unpack b, Unpack c) => Unpack (a, b, c)
instance [overlap ok] (Unpack a, Unpack b) => Unpack (a, b)
instance [overlap ok] Unpack a => Unpack (Maybe a)
instance [overlap ok] Unpack a => Unpack [a]
instance [overlap ok] Unpack Bool
instance [overlap ok] Unpack (Opaque a)
instance [overlap ok] Unpack Unpacked
instance [overlap ok] Unpack String
instance [overlap ok] Unpack ()
instance [overlap ok] Unpack Word32
instance [overlap ok] Unpack Word16
instance [overlap ok] Unpack Word8
instance [overlap ok] Unpack Word
instance [overlap ok] Unpack Int32
instance [overlap ok] Unpack Int16
instance [overlap ok] Unpack Int8
instance [overlap ok] Unpack Int
instance [overlap ok] Unpack JSString
instance [overlap ok] Unpack JSAny
instance [overlap ok] Unpack Double
instance [overlap ok] Unpack Float
instance [overlap ok] (Pack a, Pack b, Pack c, Pack d, Pack e, Pack f, Pack g, Pack h, Pack i, Pack j) => Pack (a, b, c, d, e, f, g, h, i, j)
instance [overlap ok] (Pack a, Pack b, Pack c, Pack d, Pack e, Pack f, Pack g, Pack h, Pack i) => Pack (a, b, c, d, e, f, g, h, i)
instance [overlap ok] (Pack a, Pack b, Pack c, Pack d, Pack e, Pack f, Pack g, Pack h) => Pack (a, b, c, d, e, f, g, h)
instance [overlap ok] (Pack a, Pack b, Pack c, Pack d, Pack e, Pack f, Pack g) => Pack (a, b, c, d, e, f, g)
instance [overlap ok] (Pack a, Pack b, Pack c, Pack d, Pack e, Pack f) => Pack (a, b, c, d, e, f)
instance [overlap ok] (Pack a, Pack b, Pack c, Pack d, Pack e) => Pack (a, b, c, d, e)
instance [overlap ok] (Pack a, Pack b, Pack c, Pack d) => Pack (a, b, c, d)
instance [overlap ok] (Pack a, Pack b, Pack c) => Pack (a, b, c)
instance [overlap ok] (Pack a, Pack b) => Pack (a, b)
instance [overlap ok] Pack a => Pack (Maybe a)
instance [overlap ok] Pack a => Pack [a]
instance [overlap ok] Pack Bool
instance [overlap ok] Pack (Opaque a)
instance [overlap ok] Pack Unpacked
instance [overlap ok] Pack String
instance [overlap ok] Pack ()
instance [overlap ok] Pack Word32
instance [overlap ok] Pack Word16
instance [overlap ok] Pack Word8
instance [overlap ok] Pack Word
instance [overlap ok] Pack Int32
instance [overlap ok] Pack Int16
instance [overlap ok] Pack Int8
instance [overlap ok] Pack Int
instance [overlap ok] Pack JSString
instance [overlap ok] Pack JSAny
instance [overlap ok] Pack Double
instance [overlap ok] Pack Float
instance [overlap ok] (Pack a, Unpack a) => Marshal a

module Haste.DOM
newtype Elem
Elem :: JSAny -> Elem
type PropID = String
type ElemID = String
type QuerySelector = String
type ElemClass = String

-- | A key/value pair representing the value of an attribute. May represent
--   a property, an HTML attribute or a style attribute.
data Attribute

-- | The name of an attribute. May be either a common property, an HTML
--   attribute or a style attribute.
data AttrName
type AttrValue = String

-- | Set a number of <a>Attribute</a>s on an element.
set :: MonadIO m => Elem -> [Attribute] -> m ()

-- | Create a style attribute name.
style :: String -> AttrName

-- | Create an HTML attribute name.
attr :: String -> AttrName

-- | Set a number of <a>Attribute</a>s on the element produced by an IO
--   action. Gives more convenient syntax when creating elements:
--   
--   newElem "div" <a>with</a> [ style "border" := "1px solid black", ... ]
with :: MonadIO m => m Elem -> [Attribute] -> m Elem

-- | Create an <a>Attribute</a>.
(=:) :: AttrName -> AttrValue -> Attribute

-- | Create an element.
newElem :: MonadIO m => String -> m Elem

-- | Create a text node.
newTextElem :: MonadIO m => String -> m Elem

-- | Get an element by its HTML ID attribute.
elemById :: MonadIO m => ElemID -> m (Maybe Elem)

-- | Get all children elements matching a query selector.
elemsByQS :: MonadIO m => Elem -> QuerySelector -> m [Elem]

-- | Get all elements of the given class.
elemsByClass :: MonadIO m => ElemClass -> m [Elem]

-- | Set a property of the given element.
setProp :: MonadIO m => Elem -> PropID -> String -> m ()

-- | Get a property of an element.
getProp :: MonadIO m => Elem -> PropID -> m String

-- | Set an attribute of the given element.
setAttr :: MonadIO m => Elem -> PropID -> String -> m ()

-- | Get an attribute of an element.
getAttr :: MonadIO m => Elem -> PropID -> m String

-- | Set a property of the given element, JSString edition.
setProp' :: MonadIO m => Elem -> JSString -> JSString -> m ()

-- | Get a property of an element, JSString edition.
getProp' :: MonadIO m => Elem -> JSString -> m JSString

-- | Get the value property of an element; a handy shortcut.
getValue :: (MonadIO m, JSType a) => Elem -> m (Maybe a)

-- | Perform an IO action on an element.
withElem :: MonadIO m => ElemID -> (Elem -> m a) -> m a

-- | Perform an IO action over several elements. Throws an error if some of
--   the elements are not found.
withElems :: MonadIO m => [ElemID] -> ([Elem] -> m a) -> m a

-- | Perform an IO action over the a list of elements matching a query
--   selector.
withElemsQS :: MonadIO m => Elem -> QuerySelector -> ([Elem] -> m a) -> m a

-- | Map an IO computation over the list of elements matching a query
--   selector.
mapQS :: MonadIO m => Elem -> QuerySelector -> (Elem -> m a) -> m [a]

-- | Like <tt>mapQS</tt> but returns no value.
mapQS_ :: MonadIO m => Elem -> QuerySelector -> (Elem -> m a) -> m ()

-- | Append the first element as a child of the second element.
addChild :: MonadIO m => Elem -> Elem -> m ()

-- | Insert the first element as a child into the second, before the third.
--   For instance: <tt> addChildBefore childToAdd theContainer olderChild
--   </tt>
addChildBefore :: MonadIO m => Elem -> Elem -> Elem -> m ()

-- | Remove the first element from the second's children.
removeChild :: MonadIO m => Elem -> Elem -> m ()

-- | Remove all children from the given element.
clearChildren :: MonadIO m => Elem -> m ()

-- | Get the sibling before the given one, if any.
getChildBefore :: MonadIO m => Elem -> m (Maybe Elem)

-- | Get the first of an element's children.
getFirstChild :: MonadIO m => Elem -> m (Maybe Elem)

-- | Get the last of an element's children.
getLastChild :: MonadIO m => Elem -> m (Maybe Elem)

-- | Get a list of all children belonging to a certain element.
getChildren :: MonadIO m => Elem -> m [Elem]

-- | Clear the given element's list of children, and append all given
--   children to it.
setChildren :: MonadIO m => Elem -> [Elem] -> m ()

-- | Get a CSS style property of an element.
getStyle :: MonadIO m => Elem -> PropID -> m String

-- | Set a CSS style property on an element.
setStyle :: MonadIO m => Elem -> PropID -> String -> m ()

-- | Get a CSS style property of an element, JSString style.
getStyle' :: MonadIO m => Elem -> JSString -> m JSString

-- | Set a CSS style property on an element, JSString style.
setStyle' :: MonadIO m => Elem -> JSString -> JSString -> m ()

-- | Get a file from a file input element.
getFileData :: MonadIO m => Elem -> Int -> m (Maybe Blob)

-- | Get the name of the currently selected file from a file input element.
--   Any directory information is stripped, and only the actual file name
--   is returned, as the directory information is useless (and faked)
--   anyway.
getFileName :: MonadIO m => Elem -> m String

-- | Add or remove a class from an element's class list.
setClass :: MonadIO m => Elem -> String -> Bool -> m ()

-- | Toggle the existence of a class within an elements class list.
toggleClass :: MonadIO m => Elem -> String -> m ()

-- | Does the given element have a particular class?
hasClass :: MonadIO m => Elem -> String -> m Bool

-- | Generate a click event on an element.
click :: MonadIO m => Elem -> m ()

-- | Generate a focus event on an element.
focus :: MonadIO m => Elem -> m ()

-- | Generate a blur event on an element.
blur :: MonadIO m => Elem -> m ()

-- | The DOM node corresponding to document.
document :: Elem

-- | The DOM node corresponding to document.body.
documentBody :: Elem
instance Pack Elem
instance Unpack Elem
instance IsString AttrName


-- | Haste's companion to the Prelude.
--   
--   Note that this module should *not* be imported together with
--   <a>Haste.App</a>, which provides the same functionality but slightly
--   modified for automatic program slicing.
module Haste

-- | JSStrings are represented as normal strings server-side; should
--   probably be changed to ByteString or Text.
data JSString
type JSAny = Ptr Any
type URL = String
class GenericCallback a m where type family CB a
mkcb :: GenericCallback a m => (m () -> IO ()) -> a -> CB a
mkIOfier :: GenericCallback a m => a -> m (m () -> IO ())

-- | Javascript alert() function.
alert :: MonadIO m => String -> m ()

-- | Javascript prompt() function.
prompt :: MonadIO m => String -> m String

-- | Javascript eval() function.
eval :: MonadIO m => JSString -> m JSString

-- | Use console.log to write a message.
writeLog :: MonadIO m => String -> m ()

-- | Concatenate a series of JSStrings using the specified separator.
catJSStr :: JSString -> [JSString] -> JSString
fromJSStr :: JSString -> String
class JSType a
toJSString :: JSType a => a -> JSString
fromJSString :: JSType a => JSString -> Maybe a

-- | (Almost) all numeric types can be efficiently converted to and from
--   Double, which is the internal representation for most of them.
class JSNum a
toNumber :: JSNum a => a -> Double
fromNumber :: JSNum a => Double -> a
toString :: JSType a => a -> String
fromString :: JSType a => String -> Maybe a
convert :: (JSNum a, JSNum b) => a -> b
class GenericCallback a m where type family CB a
mkcb :: GenericCallback a m => (m () -> IO ()) -> a -> CB a
mkIOfier :: GenericCallback a m => a -> m (m () -> IO ())

-- | Turn a function of type a -&gt; ... -&gt; m () into a function of type
--   a -&gt; ... -&gt; IO (), for use with generic JS callbacks.
toCallback :: (Monad m, GenericCallback a m) => a -> m (CB a)

-- | Set a callback for the given event.
setCallback :: MonadIO m => Elem -> Event IO a -> a -> m Bool

-- | Like <tt>setCallback</tt>, but takes a callback in the CIO monad
--   instead of IO.
setCallback' :: (ToConcurrent a, MonadIO m) => Elem -> Event CIO a -> Async a -> m Bool
newtype JSFun a
JSFun :: (Ptr a) -> JSFun a

-- | Turn a computation into a callback that can be passed to a JS
--   function.
mkCallback :: a -> JSFun a

-- | These constructors correspond to their namesake DOM events. Mouse
--   related callbacks receive the coordinates of the mouse pointer at the
--   time the event was fired, relative to the top left corner of the
--   element that fired the event. The click events also receive the mouse
--   button that was pressed.
--   
--   The key up<i>down</i>press events receive the character code of the
--   key that was pressed.
data Event m a
OnLoad :: Event m (m ())
OnUnload :: Event m (m ())
OnChange :: Event m (m ())
OnFocus :: Event m (m ())
OnBlur :: Event m (m ())
OnMouseMove :: Event m ((Int, Int) -> m ())
OnMouseOver :: Event m ((Int, Int) -> m ())
OnMouseOut :: Event m (m ())
OnClick :: Event m (Int -> (Int, Int) -> m ())
OnDblClick :: Event m (Int -> (Int, Int) -> m ())
OnMouseDown :: Event m (Int -> (Int, Int) -> m ())
OnMouseUp :: Event m (Int -> (Int, Int) -> m ())
OnKeyPress :: Event m (Int -> m ())
OnKeyUp :: Event m (Int -> m ())
OnKeyDown :: Event m (Int -> m ())
OnSubmit :: Event m (m ())
OnWheel :: Event m ((Int, Int) -> (Double, Double, Double) -> m ())

-- | Wrapper for window.setTimeout; execute the given computation after a
--   delay given in milliseconds.
setTimeout :: MonadIO m => Int -> IO () -> m ()

-- | Like <a>setTimeout</a>, but takes a callback in the CIO monad instead
--   of IO.
setTimeout' :: MonadIO m => Int -> CIO () -> m ()
class Callback a
constCallback :: Callback a => IO () -> a

-- | Friendlier name for <tt>setCallback</tt>.
onEvent :: MonadIO m => Elem -> Event IO a -> a -> m Bool

-- | Friendlier name for <tt>setCallback'</tt>.
onEvent' :: (ToConcurrent a, MonadIO m) => Elem -> Event CIO a -> Async a -> m Bool
jsSetCB :: Elem -> JSString -> JSFun a -> IO Bool
jsSetTimeout :: Int -> JSFun a -> IO ()

-- | The name of a given event.
evtName :: IsString s => Event m a -> s
class Random a where randomRs bounds seed = unfoldr (Just . randomR bounds) seed
randomR :: Random a => (a, a) -> Seed -> (a, Seed)
randomRs :: Random a => (a, a) -> Seed -> [a]
data Seed

-- | Generate the next seed in the sequence.
next :: Seed -> Seed

-- | Create a new seed from an integer.
mkSeed :: Int -> Seed

-- | Generate a new seed using Javascript's PRNG.
newSeed :: MonadIO m => m Seed

-- | Register a callback to be run whenever the URL hash changes. The two
--   arguments of the callback are the new and old hash respectively.
onHashChange :: (MonadIO m, GenericCallback (m ()) m, CB (m ()) ~ IO ()) => (String -> String -> m ()) -> m ()

-- | JSString version of <tt>onHashChange</tt>.
onHashChange' :: (MonadIO m, GenericCallback (m ()) m, CB (m ()) ~ IO ()) => (JSString -> JSString -> m ()) -> m ()

-- | Set the hash part of the current URL.
setHash :: MonadIO m => String -> m ()

-- | Read the hash part of the currunt URL.
getHash :: MonadIO m => m String

-- | Set the hash part of the current URL - JSString version.
setHash' :: MonadIO m => JSString -> m ()

-- | Read the hash part of the currunt URL - JSString version.
getHash' :: MonadIO m => m JSString


-- | Haste-specific JSON library. JSON is common enough that it's a good
--   idea to create as fast and small an implementation as possible. To
--   that end, the parser is implemented entirely in Javascript, and works
--   with any browser that supports JSON.parse; IE does this from version 8
--   and up, and everyone else has done it since just about forever.
module Haste.JSON
data JSON
Num :: {-# UNPACK #-} !Double -> JSON
Str :: {-# UNPACK #-} !JSString -> JSON
Bool :: {-# UNPACK #-} !Bool -> JSON
Arr :: ![JSON] -> JSON
Dict :: ![(JSString, JSON)] -> JSON
Null :: JSON
encodeJSON :: JSON -> JSString
decodeJSON :: JSString -> Either String JSON

-- | Create a Javascript object from a JSON object. Only makes sense in a
--   browser context, obviously.
toObject :: JSON -> JSAny

-- | Look up a JSON object from a JSON dictionary. Panics if the dictionary
--   isn't a dictionary, or if it doesn't contain the given key.
(!) :: JSON -> JSString -> JSON

-- | Look up a key in a JSON dictionary. Return Nothing if the key can't be
--   found for some reason.
(~>) :: JSONLookup a => a -> JSString -> Maybe JSON
instance Show JSON
instance JSONLookup (Maybe JSON)
instance JSONLookup JSON
instance Num JSON
instance IsString JSON


-- | Low level XMLHttpRequest support. IE6 and older are not supported.
module Haste.Ajax
data Method
GET :: Method
POST :: Method
type URL = String
type Key = String
type Val = String

-- | Make an AJAX request to a URL, treating the response as plain text.
textRequest :: MonadIO m => Method -> URL -> [(Key, Val)] -> (Maybe String -> IO ()) -> m ()

-- | Same as <a>textRequest</a> but deals with JSStrings instead of
--   Strings.
textRequest_ :: MonadIO m => Method -> JSString -> [(JSString, JSString)] -> (Maybe JSString -> IO ()) -> m ()

-- | Make an AJAX request to a URL, interpreting the response as JSON.
jsonRequest :: MonadIO m => Method -> URL -> [(Key, Val)] -> (Maybe JSON -> IO ()) -> m ()

-- | Does the same thing as <a>jsonRequest</a> but uses <a>JSString</a>s
--   instead of Strings.
jsonRequest_ :: MonadIO m => Method -> JSString -> [(JSString, JSString)] -> (Maybe JSON -> IO ()) -> m ()
instance Show Method


-- | Concurrency for Haste. Includes MVars, forking, Ajax and more.
module Haste.Concurrent
data MVar a

-- | Concurrent IO monad. The normal IO monad does not have concurrency
--   capabilities with Haste. This monad is basically IO plus concurrency.
data CIO a

-- | Embed concurrent computations into non-concurrent ones.
class ToConcurrent a where type family Async a
async :: ToConcurrent a => Async a -> a

-- | Any monad which supports concurrency.
class Monad m => MonadConc m
liftConc :: MonadConc m => CIO a -> m a
fork :: MonadConc m => m () -> m ()

-- | Spawn a new thread.
forkIO :: CIO () -> CIO ()

-- | Spawn several threads at once.
forkMany :: [CIO ()] -> CIO ()

-- | Create a new MVar with an initial value.
newMVar :: MonadIO m => a -> m (MVar a)

-- | Create a new empty MVar.
newEmptyMVar :: MonadIO m => m (MVar a)

-- | Read an MVar. Blocks if the MVar is empty. Only the first writer in
--   the write queue, if any, is woken.
takeMVar :: MVar a -> CIO a

-- | Write an MVar. Blocks if the MVar is already full. Only the first
--   reader in the read queue, if any, is woken.
putMVar :: MVar a -> a -> CIO ()

-- | Perform an IO action over an MVar.
withMVarIO :: MVar a -> (a -> IO b) -> CIO b

-- | Peek at the value inside a given MVar, if any, without removing it.
peekMVar :: MonadIO m => MVar a -> m (Maybe a)

-- | Perform an IO action over an MVar, then write the MVar back.
modifyMVarIO :: MVar a -> (a -> IO (a, b)) -> CIO b

-- | Read an MVar then put it back. As Javascript is single threaded, this
--   function is atomic. If this ever changes, this function will only be
--   atomic as long as no other thread attempts to write to the MVar.
readMVar :: MVar a -> CIO a

-- | Run a concurrent computation. Two different concurrent computations
--   may share MVars; if this is the case, then a call to <a>concurrent</a>
--   may return before all the threads it spawned finish executing.
concurrent :: CIO () -> IO ()

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a
data Recv
data Send
type Inbox = MBox Recv
type Outbox = MBox Send

-- | An MBox is a read/write-only MVar, depending on its first type
--   parameter. Used to communicate with server processes.
data MBox t a

-- | Block until a message arrives in a mailbox, then return it.
receive :: MonadConc m => Inbox a -> m a

-- | Creates a generic process and returns a MBox which may be used to pass
--   messages to it. While it is possible for a process created using spawn
--   to transmit its inbox to someone else, this is a very bad idea; don't
--   do it.
spawn :: MonadConc m => (Inbox a -> m ()) -> m (Outbox a)

-- | Creates a generic stateful process. This process is a function taking
--   a state and an event argument, returning an updated state or Nothing.
--   <tt>statefully</tt> creates a <tt>MBox</tt> that is used to pass
--   events to the process. Whenever a value is written to this MBox, that
--   value is passed to the process function together with the function's
--   current state. If the process function returns Nothing, the process
--   terminates. If it returns a new state, the process again blocks on the
--   event MBox, and will use the new state to any future calls to the
--   server function.
statefully :: MonadConc m => st -> (st -> evt -> m (Maybe st)) -> m (Outbox evt)

-- | Write a value to a MBox. Named after the Erlang message sending
--   operator, as both are intended for passing messages to processes. This
--   operation does not block until the message is delivered, but returns
--   immediately.
(!) :: MonadConc m => Outbox a -> a -> m ()

-- | Perform a Client computation, then write its return value to the given
--   pipe. Mnemonic: the operator is a combination of &lt;- and !. Just
--   like <tt>(!)</tt>, this operation is non-blocking.
(<!) :: MonadConc m => Outbox a -> m a -> m ()

-- | Wait for n milliseconds.
wait :: Int -> CIO ()
instance GenericCallback (CIO ()) CIO


-- | Handling of Javascript-native binary blobs.
--   
--   Generics borrowed from the binary package by Lennart Kolmodin
--   (released under BSD3)
module Haste.Binary
type Put = PutM ()
data PutM a
putWord8 :: Word8 -> Put
putWord16le :: Word16 -> Put
putWord32le :: Word32 -> Put
putInt8 :: Int8 -> Put
putInt16le :: Int16 -> Put
putInt32le :: Int32 -> Put
putFloat32le :: Float -> Put
putFloat64le :: Double -> Put
putBlob :: Blob -> Put
runPut :: Put -> Blob
data Get a
getWord8 :: Get Word8
getWord16le :: Get Word16
getWord32le :: Get Word32
getInt8 :: Get Int8
getInt16le :: Get Int16
getInt32le :: Get Int32
getFloat32le :: Get Float
getFloat64le :: Get Double
getBytes :: Int -> Get BlobData

-- | Skip n bytes of input.
skip :: Int -> Get ()
runGet :: Get a -> BlobData -> Either String a
class Monad m => MonadBlob m
getBlobData :: MonadBlob m => Blob -> m BlobData
getBlobText' :: MonadBlob m => Blob -> m JSString

-- | Somewhat efficient serialization<i>deserialization to</i>from binary
--   Blobs. The layout of the binaries produced<i>read by get</i>put and
--   encode/decode may change between versions. If you need a stable binary
--   format, you should make your own using the primitives in
--   Haste.Binary.Get/Put.
class Binary a where put = gput . from get = to `fmap` gget
get :: Binary a => Get a
put :: Binary a => a -> Put

-- | Interpret a blob as UTF-8 text.
getBlobText :: MonadBlob m => Blob -> m String
data Blob
data BlobData

-- | The size, in bytes, of the contents of the given blob.
blobSize :: Blob -> Int

-- | The size, in bytes, of the contents of the given blob data.
blobDataSize :: BlobData -> Int

-- | Convert a BlobData to a ByteString. Only usable server-side.
toByteString :: BlobData -> ByteString

-- | Convert a piece of BlobData back into a Blob.
toBlob :: BlobData -> Blob

-- | Create a Blob from a JSString.
strToBlob :: JSString -> Blob
encode :: Binary a => a -> Blob
decode :: Binary a => BlobData -> Either String a
instance [overlap ok] SumSize (C1 c a)
instance [overlap ok] (SumSize a, SumSize b) => SumSize (a :+: b)
instance [overlap ok] GBinary a => GSum (C1 c a)
instance [overlap ok] (GSum a, GSum b, GBinary a, GBinary b) => GSum (a :+: b)
instance [overlap ok] (GSum a, GSum b, GBinary a, GBinary b, SumSize a, SumSize b) => GBinary (a :+: b)
instance [overlap ok] Binary a => GBinary (K1 i a)
instance [overlap ok] GBinary a => GBinary (M1 i c a)
instance [overlap ok] (GBinary a, GBinary b) => GBinary (a :*: b)
instance [overlap ok] GBinary U1
instance [overlap ok] GBinary V1
instance [overlap ok] Binary Char
instance [overlap ok] Binary Blob
instance [overlap ok] Binary a => Binary [a]
instance [overlap ok] Binary ()
instance [overlap ok] (Binary a, Binary b) => Binary (Either a b)
instance [overlap ok] Binary a => Binary (Maybe a)
instance [overlap ok] (Binary a, Binary b) => Binary (a, b)
instance [overlap ok] Binary Double
instance [overlap ok] Binary Float
instance [overlap ok] Binary Int
instance [overlap ok] Binary Int32
instance [overlap ok] Binary Int16
instance [overlap ok] Binary Int8
instance [overlap ok] Binary Word32
instance [overlap ok] Binary Word16
instance [overlap ok] Binary Word8
instance [overlap ok] MonadBlob CIO


-- | JSON serialization and de-serialization for Haste.
module Haste.Serialize
class Serialize a where listToJSON = Arr . map toJSON parseJSONList (Arr xs) = mapM parseJSON xs parseJSONList _ = fail "Tried to deserialie a non-array to a list!"
toJSON :: Serialize a => a -> JSON
listToJSON :: Serialize a => [a] -> JSON
parseJSON :: Serialize a => JSON -> Parser a
parseJSONList :: Serialize a => JSON -> Parser [a]

-- | Type for JSON parser.
data Parser a
fromJSON :: Serialize a => JSON -> Either String a

-- | Look up a key in a JSON object.
(.:) :: Serialize a => JSON -> JSString -> Parser a
(.:?) :: Serialize a => JSON -> JSString -> Parser (Maybe a)
instance Applicative Parser
instance Functor Parser
instance Monad Parser
instance (Serialize a, Serialize b) => Serialize (Either a b)
instance Serialize a => Serialize [a]
instance Serialize a => Serialize (Maybe a)
instance (Serialize a, Serialize b) => Serialize (a, b)
instance Serialize JSString
instance Serialize Char
instance Serialize ()
instance Serialize Bool
instance Serialize Int32
instance Serialize Int16
instance Serialize Int8
instance Serialize Int
instance Serialize Double
instance Serialize Float
instance Serialize JSON


-- | Basic Canvas graphics library.
module Haste.Graphics.Canvas

-- | A bitmap, backed by an IMG element. JS representation is a reference
--   to the backing IMG element.
data Bitmap

-- | A canvas; a viewport into which a picture can be rendered. The origin
--   of the coordinate system used by the canvas is the top left corner of
--   the canvas element. JS representation is a reference to the backing
--   canvas element.
data Canvas

-- | A shape which can be either stroked or filled to yield a picture.
data Shape a

-- | A picture that can be drawn onto a canvas.
data Picture a

-- | A point in the plane.
type Point = (Double, Double)

-- | A two dimensional vector.
type Vector = (Double, Double)

-- | An angle, given in radians.
type Angle = Double

-- | A rectangle.
data Rect
Rect :: !Double -> !Double -> !Double -> !Double -> Rect
rect_x :: Rect -> !Double
rect_y :: Rect -> !Double
rect_w :: Rect -> !Double
rect_h :: Rect -> !Double

-- | A color, specified using its red, green and blue components, with an
--   optional alpha component.
data Color
RGB :: !Int -> !Int -> !Int -> Color
RGBA :: !Int -> !Int -> !Int -> !Double -> Color

-- | A drawing context; part of a canvas. JS representation is the drawing
--   context object itself.
data Ctx
data AnyImageBuffer
AnyImageBuffer :: a -> AnyImageBuffer

-- | Any type that contains a buffered image which can be drawn onto a
--   canvas.
class ImageBuffer a
draw :: ImageBuffer a => a -> Point -> Picture ()
drawClipped :: ImageBuffer a => a -> Point -> Rect -> Picture ()

-- | Any type that can be used to obtain a bitmap.
class BitmapSource src
loadBitmap :: (BitmapSource src, MonadIO m) => src -> m Bitmap

-- | Create a 2D drawing context from a DOM element identified by its ID.
getCanvasById :: MonadIO m => ElemID -> m (Maybe Canvas)

-- | Create a 2D drawing context from a DOM element.
getCanvas :: MonadIO m => Elem -> m (Maybe Canvas)

-- | Create an off-screen buffer of the specified size.
createCanvas :: Int -> Int -> IO (Maybe Canvas)

-- | Get the DOM node backing a given canvas.
canvasElem :: Canvas -> Elem

-- | Get the HTML element associated with the given bitmap.
bitmapElem :: Bitmap -> Elem

-- | Clear a canvas, then draw a picture onto it.
render :: MonadIO m => Canvas -> Picture a -> m a

-- | Draw a picture onto a canvas without first clearing it.
renderOnTop :: MonadIO m => Canvas -> Picture a -> m a

-- | Create a new off-screen buffer and store the given picture in it.
buffer :: MonadIO m => Int -> Int -> Picture () -> m Bitmap

-- | Generate a data URL from the contents of a canvas.
toDataURL :: MonadIO m => Canvas -> m URL

-- | Set a new color for strokes.
setStrokeColor :: Color -> Picture ()

-- | Set a new fill color.
setFillColor :: Color -> Picture ()

-- | Draw the given Picture using the specified Color for both stroke and
--   fill, then restore the previous stroke and fill colors.
color :: Color -> Picture () -> Picture ()

-- | Draw a picture with the given opacity.
opacity :: Double -> Picture () -> Picture ()

-- | Draw the given picture using a new line width.
lineWidth :: Double -> Picture () -> Picture ()

-- | Draw the specified picture using the given point as the origin.
translate :: Vector -> Picture () -> Picture ()

-- | Draw the specified picture scaled as specified by the scale vector.
scale :: Vector -> Picture () -> Picture ()

-- | Draw the specified picture rotated <tt>r</tt> radians clockwise.
rotate :: Double -> Picture () -> Picture ()

-- | Draw the contours of a shape.
stroke :: Shape () -> Picture ()

-- | Draw a filled shape.
fill :: Shape () -> Picture ()

-- | Draw a picture clipped to the given path.
clip :: Shape () -> Picture () -> Picture ()

-- | Draw a line between two points.
line :: Point -> Point -> Shape ()

-- | Draw a path along the specified points.
path :: [Point] -> Shape ()

-- | Draw a rectangle between the two given points.
rect :: Point -> Point -> Shape ()

-- | Draw a circle shape.
circle :: Point -> Double -> Shape ()

-- | Draw an arc. An arc is specified as a drawn portion of an imaginary
--   circle with a center point, a radius, a starting angle and an ending
--   angle. For instance, <tt>arc (0, 0) 10 0 pi</tt> will draw a half
--   circle centered at (0, 0), with a radius of 10 pixels.
arc :: Point -> Double -> Angle -> Angle -> Shape ()

-- | Draw a picture using a certain font. Obviously only affects text.
font :: String -> Picture () -> Picture ()

-- | Draw some text onto the canvas.
text :: Point -> String -> Picture ()

-- | Perform a computation over the drawing context of the picture. This is
--   handy for operations which are either impossible, hard or inefficient
--   to express using the Haste.Graphics.Canvas API.
withContext :: (Ctx -> IO a) -> Picture a
instance Pack Bitmap
instance Unpack Bitmap
instance Pack Ctx
instance Unpack Ctx
instance Monad Shape
instance Applicative Shape
instance Functor Shape
instance Monad Picture
instance Applicative Picture
instance Functor Picture
instance Unpack Canvas
instance Pack Canvas
instance ImageBuffer AnyImageBuffer
instance BitmapSource Elem
instance BitmapSource URL
instance ImageBuffer Bitmap
instance ImageBuffer Canvas


-- | WebSockets API for Haste.
module Haste.WebSockets
data WebSocket

-- | Run a computation with a web socket. The computation will not be
--   executed until a connection to the server has been established.
withWebSocket :: URL -> (WebSocket -> JSString -> CIO ()) -> CIO a -> (WebSocket -> CIO a) -> CIO a

-- | Run a computation with a web socket. The computation will not be
--   executed until a connection to the server has been established.
withBinaryWebSocket :: URL -> (WebSocket -> Blob -> CIO ()) -> CIO a -> (WebSocket -> CIO a) -> CIO a

-- | Send a string over a WebSocket.
wsSend :: WebSocket -> JSString -> CIO ()

-- | Send a Blob over a WebSocket.
wsSendBlob :: WebSocket -> Blob -> CIO ()
instance Unpack WSOnError
instance Unpack WSComputation
instance Unpack WSOnBinMsg
instance Unpack WSOnMsg
instance Unpack WebSocket
instance Pack WSOnError
instance Pack WSComputation
instance Pack WSOnBinMsg
instance Pack WSOnMsg
instance Pack WebSocket


-- | Type-safe client-server communication framework for Haste.
--   
--   In addition to the Haste.App extras, this module exports the same API
--   as <a>Haste</a>, modified slightly to work better with the automatic
--   program slicing Haste.App provides. This means that you should import
--   either this module *or* Haste, but *not* both.
module Haste.App

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)
liftIO :: MonadIO m => IO a -> m a

-- | An exportable function is of the type (Serialize a, ..., Serialize
--   result) =&gt; a -&gt; ... -&gt; IO result
class Remotable a

-- | Application monad; allows for exporting functions, limited liftIO,
--   forkIO and launching the client.
data App a

-- | Server monad for Haste.App. Allows redeeming remote values, lifting IO
--   actions, and not much more.
data Server a
data Remote a
data Done
type Sessions = Set SessionID
type SessionID = Word64

-- | Lift an IO action into the Server monad, the result of which can only
--   be used server-side.
liftServerIO :: IO a -> App (Server a)

-- | Fork off a Server computation not bound an API call. This may be
--   useful for any tasks that will keep running for as long as the server
--   is running.
--   
--   Calling <tt>getSessionID</tt> inside this computation will return 0,
--   which will never be generated for an actual session.
--   <tt>getActiveSessions</tt> works as expected.
forkServerIO :: Server () -> App (Server ThreadId)

-- | Make a function available to the client as an API call.
remote :: Remotable a => a -> App (Remote a)

-- | Run a Haste.App application. runApp never returns before the program
--   terminates.
--   
--   Note that <tt>runApp</tt> is single-entry, and that its argument must
--   not depend on any external IO. It is *strongly* recommended that the
--   main function of any Haste.App program *only* consists of a single
--   call to <tt>runApp</tt>.
runApp :: AppCfg -> App Done -> IO ()

-- | Apply an exported function to an argument. TODO: look into making this
--   Applicative.
(<.>) :: Binary a => Remote (a -> b) -> a -> Remote b

-- | Returns the ID of the current session.
getSessionID :: Server SessionID

-- | Return all currently active sessions.
getActiveSessions :: Server Sessions

-- | Register a handler to be run whenever a session terminates. Several
--   handlers can be registered at the same time; they will be run in the
--   order they were registered.
onSessionEnd :: (SessionID -> Server ()) -> App ()
data AppCfg
cfgURL :: AppCfg -> String
cfgPort :: AppCfg -> Int

-- | Create a default configuration from an URL and a port number.
mkConfig :: String -> Int -> AppCfg

-- | A client-side computation. See it as Haste.App's version of the IO
--   monad.
data Client a

-- | Launch a client from a Server computation. runClient never returns
--   before the program terminates.
runClient :: Client () -> App Done

-- | Perform a server-side computation, blocking the client thread until
--   said computation returns.
onServer :: Binary a => Remote (Server a) -> Client a

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | JSStrings are represented as normal strings server-side; should
--   probably be changed to ByteString or Text.
data JSString
type JSAny = Ptr Any
type URL = String

-- | Javascript alert() function.
alert :: MonadIO m => String -> m ()

-- | Javascript prompt() function.
prompt :: MonadIO m => String -> m String

-- | Javascript eval() function.
eval :: MonadIO m => JSString -> m JSString

-- | Use console.log to write a message.
writeLog :: MonadIO m => String -> m ()

-- | Concatenate a series of JSStrings using the specified separator.
catJSStr :: JSString -> [JSString] -> JSString
fromJSStr :: JSString -> String

-- | Bake a value of type a -&gt; ... -&gt; Client b into a -&gt; ... -&gt;
--   IO b
class ClientCallback a

-- | These constructors correspond to their namesake DOM events. Mouse
--   related callbacks receive the coordinates of the mouse pointer at the
--   time the event was fired, relative to the top left corner of the
--   element that fired the event. The click events also receive the mouse
--   button that was pressed.
--   
--   The key up<i>down</i>press events receive the character code of the
--   key that was pressed.
data Event m a
OnLoad :: Event m (m ())
OnUnload :: Event m (m ())
OnChange :: Event m (m ())
OnFocus :: Event m (m ())
OnBlur :: Event m (m ())
OnMouseMove :: Event m ((Int, Int) -> m ())
OnMouseOver :: Event m ((Int, Int) -> m ())
OnMouseOut :: Event m (m ())
OnClick :: Event m (Int -> (Int, Int) -> m ())
OnDblClick :: Event m (Int -> (Int, Int) -> m ())
OnMouseDown :: Event m (Int -> (Int, Int) -> m ())
OnMouseUp :: Event m (Int -> (Int, Int) -> m ())
OnKeyPress :: Event m (Int -> m ())
OnKeyUp :: Event m (Int -> m ())
OnKeyDown :: Event m (Int -> m ())
OnSubmit :: Event m (m ())
OnWheel :: Event m ((Int, Int) -> (Double, Double, Double) -> m ())

-- | Set a handler for a given event.
onEvent :: ClientCallback a => Elem -> Event Client a -> a -> Client ()

-- | Wrapper for window.setTimeout; execute the given computation after a
--   delay given in milliseconds.
setTimeout :: Int -> Client () -> Client ()

-- | The name of a given event.
evtName :: IsString s => Event m a -> s
class Random a where randomRs bounds seed = unfoldr (Just . randomR bounds) seed
randomR :: Random a => (a, a) -> Seed -> (a, Seed)
randomRs :: Random a => (a, a) -> Seed -> [a]
data Seed

-- | Generate the next seed in the sequence.
next :: Seed -> Seed

-- | Create a new seed from an integer.
mkSeed :: Int -> Seed

-- | Generate a new seed using Javascript's PRNG.
newSeed :: MonadIO m => m Seed
class JSType a
toJSString :: JSType a => a -> JSString
fromJSString :: JSType a => JSString -> Maybe a

-- | (Almost) all numeric types can be efficiently converted to and from
--   Double, which is the internal representation for most of them.
class JSNum a
toNumber :: JSNum a => a -> Double
fromNumber :: JSNum a => Double -> a
toString :: JSType a => a -> String
fromString :: JSType a => String -> Maybe a
convert :: (JSNum a, JSNum b) => a -> b

-- | Register a callback to be run whenever the URL hash changes. The two
--   arguments of the callback are the new and old hash respectively.
onHashChange :: (MonadIO m, GenericCallback (m ()) m, CB (m ()) ~ IO ()) => (String -> String -> m ()) -> m ()

-- | JSString version of <tt>onHashChange</tt>.
onHashChange' :: (MonadIO m, GenericCallback (m ()) m, CB (m ()) ~ IO ()) => (JSString -> JSString -> m ()) -> m ()

-- | Set the hash part of the current URL.
setHash :: MonadIO m => String -> m ()

-- | Read the hash part of the currunt URL.
getHash :: MonadIO m => m String

-- | Set the hash part of the current URL - JSString version.
setHash' :: MonadIO m => JSString -> m ()

-- | Read the hash part of the currunt URL - JSString version.
getHash' :: MonadIO m => m JSString


-- | Wraps Haste.Concurrent to work with Haste.App. Task switching happens
--   whenever a thread is blocked in an MVar, so things like polling an
--   IORef in a loop will starve all other threads.
--   
--   This will likely be the state of Haste concurrency until Javascript
--   gains decent native concurrency support.
module Haste.App.Concurrent
data MVar a

-- | An MBox is a read/write-only MVar, depending on its first type
--   parameter. Used to communicate with server processes.
data MBox t a
data Send
data Recv
type Inbox = MBox Recv
type Outbox = MBox Send

-- | Any monad which supports concurrency.
class Monad m => MonadConc m
liftConc :: MonadConc m => CIO a -> m a
fork :: MonadConc m => m () -> m ()

-- | Spawn several concurrent computations.
forkMany :: [Client ()] -> Client ()

-- | Create a new MVar with the specified contents.
newMVar :: a -> Client (MVar a)

-- | Create a new empty MVar.
newEmptyMVar :: Client (MVar a)

-- | Read the value of an MVar. If the MVar is empty, <tt>takeMVar</tt>
--   blocks until a value arrives. <tt>takeMVar</tt> empties the MVar.
takeMVar :: MVar a -> Client a

-- | Put a value into an MVar. If the MVar is full, <tt>putMVar</tt> will
--   block until the MVar is empty.
putMVar :: MVar a -> a -> Client ()

-- | Read an MVar without affecting its contents. If the MVar is empty,
--   <tt>peekMVar</tt> immediately returns <tt>Nothing</tt>.
peekMVar :: MVar a -> Client (Maybe a)

-- | Read an MVar then put it back. As Javascript is single threaded, this
--   function is atomic. If this ever changes, this function will only be
--   atomic as long as no other thread attempts to write to the MVar.
readMVar :: MVar a -> Client a

-- | Creates a generic process and returns a MBox which may be used to pass
--   messages to it. While it is possible for a process created using spawn
--   to transmit its inbox to someone else, this is a very bad idea; don't
--   do it.
spawn :: MonadConc m => (Inbox a -> m ()) -> m (Outbox a)

-- | Block until a message arrives in a mailbox, then return it.
receive :: MonadConc m => Inbox a -> m a

-- | Creates a generic stateful process. This process is a function taking
--   a state and an event argument, returning an updated state or Nothing.
--   <tt>statefully</tt> creates a <tt>MBox</tt> that is used to pass
--   events to the process. Whenever a value is written to this MBox, that
--   value is passed to the process function together with the function's
--   current state. If the process function returns Nothing, the process
--   terminates. If it returns a new state, the process again blocks on the
--   event MBox, and will use the new state to any future calls to the
--   server function.
statefully :: MonadConc m => st -> (st -> evt -> m (Maybe st)) -> m (Outbox evt)

-- | Write a value to a MBox. Named after the Erlang message sending
--   operator, as both are intended for passing messages to processes. This
--   operation does not block until the message is delivered, but returns
--   immediately.
(!) :: MonadConc m => Outbox a -> a -> m ()

-- | Perform a Client computation, then write its return value to the given
--   pipe. Mnemonic: the operator is a combination of &lt;- and !. Just
--   like <tt>(!)</tt>, this operation is non-blocking.
(<!) :: MonadConc m => Outbox a -> m a -> m ()

-- | <tt><a>forever</a> act</tt> repeats the action infinitely.
forever :: Monad m => m a -> m b
instance MonadConc Client


-- | Basic bindings to HTML5 WebStorage.
module Haste.LocalStorage

-- | Locally store a serializable value.
setItem :: Serialize a => String -> a -> IO ()

-- | Load a serializable value from local storage. Will fail if the given
--   key does not exist or if the value stored at the key does not match
--   the requested type.
getItem :: Serialize a => String -> IO (Either String a)

-- | Remove a value from local storage.
removeItem :: String -> IO ()
