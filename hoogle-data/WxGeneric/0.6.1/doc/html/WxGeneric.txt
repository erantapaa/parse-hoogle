-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic (SYB3) construction of wxHaskell widgets
--   
--   Using an algebraic data types structure and field names, this library
--   constructs widgets for wxHaskell. It can handle data types with single
--   or multiple constructors, as well as recursive data types.
--   
--   The library is designed to integrate smoothly with wxHaskell. First,
--   by making it easy to integrate WxGeneric-widgets into existing
--   wxHaskell programs. Second, by letting a user extend WxGeneric using
--   mostly wxHaskell function.
@package WxGeneric
@version 0.6.1


-- | Handles joining of many <a>Layout</a> into one <a>Layout</a>.
module Graphics.UI.WxGeneric.Layout
smartLayout :: JoinLayout
oneColumnLayout :: JoinLayout

-- | Makes a layout in two columns. If there is less than two Layout's to
--   join, it will diverge to <a>oneColumnLayout</a>.
twoColumnLayout :: JoinLayout
type JoinLayout = String -> FromWxGenLayout Layout
type SizedLayout = (Int, Layout)
toSizedLayout :: (Widget w, Dimensions w) => w -> IO SizedLayout


-- | Module to ease composing zero-to-many widgets to a larger composite
--   widget.
module Graphics.UI.WxGeneric.Composite

-- | Data type which contains a composite widget
data Composite user

-- | Contains the widget, which this Composite represent. The term widget
--   is used broadly here. It can either refer to some basic widget, like a
--   text-box, or to a panel containing multiple sub-widgets.
pickPanel :: Composite user -> Window w
pickLayout :: Composite user -> Layout
pickUser :: Composite user -> user

-- | Composes zero-to-many widgets to a larger composite widget
--   
--   The composite will automatically implement the following classes:
--   
--   <ul>
--   <li>Widget</li>
--   <li>Able</li>
--   <li>Bordered</li>
--   <li>Child</li>
--   <li>Dimensions</li>
--   <li>Identity</li>
--   <li>Literate</li>
--   <li>Parent</li>
--   <li>Sized</li>
--   <li>Visible</li>
--   <li>Reactive (event class)</li>
--   </ul>
--   
--   if the user type = (Inherit x) and x implements one of the following
--   classes, then so will the Composite:
--   
--   <ul>
--   <li>Items</li>
--   <li>Observable</li>
--   <li>Selection</li>
--   <li>Selections</li>
--   <li>Textual</li>
--   <li>Commanding (event class)</li>
--   <li>Selecting (event class)</li>
--   <li>ValuedWidget</li>
--   </ul>
--   
--   if the composite needs to implement more classes it should be done as
--   follows:
--   
--   <pre>
--   type MyComposite = Composite user
--   
--   instance Foo MyComposite where
--      ...
--   </pre>
compose :: (Panel () -> IO (Layout, user)) -> Window w -> [Prop (Composite user)] -> IO (Composite user)

-- | Encapsulate a single 'Window w' in the composite type
singleComposite :: Window w -> user -> Composite user

-- | Encapsulate a single 'Window w' in the composite type
singleCompositeEx :: Window w -> Layout -> user -> Composite user

-- | Used when an attribute should apply to the panel
mapPanelAttr :: (forall w. Attr (Window w) attr) -> Attr (Composite user) attr

-- | Used when an attribute should apply to the panel and all of its
--   children
forAllChildren :: Attr (Window ()) attr -> (forall w. Attr (Window w) attr) -> Attr (Composite user) attr

-- | Used when an attribute should apply to the <a>usertype</a>
mapUserAttr :: Attr user attr -> Attr (Composite user) attr

-- | Used when an attribute should apply to the inherited <a>usertype</a>
mapInheritedAttr :: Attr super attr -> Attr (CompositeInherit super) attr

-- | Mapping events using a mapper function
mapEventF :: (to -> from) -> Event from event -> Event to event

-- | Mapping events from the Panel ()
mapPanelEvent :: (forall w. Event (Window w) event) -> Event (Composite user) event

-- | Mapping events from the inherited <a>usertype</a>
mapInheritedEvent :: Event super event -> Event (CompositeInherit super) event

-- | <a>propagateFutureEvents</a> is an easy to use wrapper around
--   <a>propagateFutureEvents</a>.
--   
--   <a>propagateFutureEvents</a> propagates future events from one widget
--   to another, based on a list of <a>EventToken</a>s. The from widget
--   will usually be a normal wxHaskell widget or some <a>Composite</a>.
--   The to widget will usually be a panel or a frame.
propagateFutureEvents :: (Reactive from, Reactive to) => [EventToken] -> from -> to -> IO ()
data EventToken
Mouse :: EventToken
Keyboard :: EventToken
Focus :: EventToken
allEvents :: [EventToken]

-- | Transmit future events from one wxHaskell widget to a parent-widget.
--   All events, where <tt>propagateThisEvent</tt> returns <a>True</a> is
--   propagated to the parent-widget. If <a>False</a> is returned, then we
--   call <tt>Graphics.UI.WX.Events.propagateEvent</tt>, so the
--   form-widgets normal event handling code will recieve the event. E.g. a
--   button should not propagate click-events to the parent-widget, but the
--   button should handle the click-event itself.
--   
--   However, it is essential to note that <tt>propagateThisEvent</tt>
--   _cannot_ be used to decide if the from-widget should have some events
--   blocked. It is only usefull for deciding if events should be
--   propagated to the parent 'Window w'. Even if an event is propagated to
--   a parent-widget, then the parent-widget's event handling code may call
--   <tt>Graphics.UI.WX.Events.propagateEvent</tt>, and then propagate the
--   event back to the from-widget.
--   
--   Note that we need two Event inputs, otherwise the <tt>fromWidget</tt>
--   and <tt>toWidget</tt> must be of the same type.
--   
--   See <a>propagateFutureEvents</a> for an easier to use version of
--   <a>propagateFutureEventsEx</a>.
propagateFutureEventsEx :: (t -> Bool) -> fromWidget -> toWidget -> Event fromWidget (t -> IO ()) -> Event toWidget (t -> IO ()) -> IO ()

-- | Propagate an event to a 'Window w'.
propagateWxEvent :: toWindow -> Event toWindow (inEvt -> IO a) -> inEvt -> IO a
isEnterOrLeave :: EventMouse -> Bool
isMouseMotion :: EventMouse -> Bool
isMouseWheel :: EventMouse -> Bool
class ValuedWidget value widget | widget -> value
widgetValue :: (ValuedWidget value widget) => Attr widget value
updateUser :: (user -> user') -> Composite user -> Composite user'
updateInherited :: (super -> super') -> CompositeInherit super -> CompositeInherit super'

-- | A marker type, which indicates that we want to derive or inherit all
--   wxHaskell type classes possible.
newtype Inherit super
Inherit :: super -> Inherit super
unInherit :: Inherit super -> super
type CompositeInherit super = Composite (Inherit super)
instance Reactive (Composite user)
instance (Commanding super) => Commanding (CompositeInherit super)
instance (Selecting super) => Selecting (CompositeInherit super)
instance (ValuedWidget a (super a)) => ValuedWidget a (Composite (Inherit (super a)))
instance (Textual super) => Textual (CompositeInherit super)
instance (Selections super) => Selections (CompositeInherit super)
instance (Selection super) => Selection (CompositeInherit super)
instance (Items super String) => Items (CompositeInherit super) String
instance (Tipped super) => Tipped (CompositeInherit super)
instance (Observable super) => Observable (CompositeInherit super)
instance (Help super) => Help (CompositeInherit super)
instance (Checkable super) => Checkable (CompositeInherit super)
instance Visible (Composite user)
instance Sized (Composite user)
instance Parent (Composite user)
instance Literate (Composite user)
instance Identity (Composite user)
instance Dimensions (Composite user)
instance Colored (Composite user)
instance Child (Composite user)
instance Bordered (Composite user)
instance Able (Composite user)
instance Widget (Composite user)


-- | Contains GenWid, which is the type used for the inner widget in
--   WxGeneric. Plus functions to create GenWid.
--   
--   GenWid contains a valued version of <tt>Composite</tt>.
module Graphics.UI.WxGeneric.GenericWidget

-- | Composing multiple widgets into a composite GenWid. It is similar to
--   <a>compose</a>.
valuedCompose :: (Parms (CPanel ()) -> IO (Layout, IO a, a -> IO (), IO (IO ()), IO () -> IO (), IO WidTree)) -> GenWidIO a

-- | Creates a GenWid using monadic actions.
mkGenWid :: Window w -> IO a -> (a -> IO ()) -> IO (IO ()) -> (IO () -> IO ()) -> (IO WidTree) -> GenWid a

-- | Creates a GenWid using an Observable widget, a get-value action and a
--   set-value action.
mkSingleObservable :: (Observable (Window w)) => Window w -> IO a -> (a -> IO ()) -> IO WidTree -> GenWid a

-- | Creates a GenWid using an Observable widget, a get-value action and a
--   set-value action.
mkSingleObservableEx :: (Observable (Window w)) => Window w -> (Layout -> Layout) -> IO a -> (a -> IO ()) -> IO WidTree -> GenWid a
data GenWid a
type GenWidIO a = forall w. Parms w -> IO (GenWid a)
class MapValue valued :: (* -> *)
mapValue :: (MapValue valued) => (old -> new) -> (old -> new -> old) -> valued old -> valued new
data Parms w

-- | When a <tt>GenWid</tt> has sub-<tt>GenWid</tt> use this function to
--   update <tt>GenWidParms</tt>.
--   
--   Currently, only GenericClass.singleConstr uses this function. But, in
--   principle, it should be called by functions using sub-widget.
subParms :: Parms w -> Parms w

-- | Use this parent when constructing new widgets.
getParent :: Parms w -> Window w
setParent :: Window w -> Parms w' -> Parms w
getJoinLayout :: Parms w -> JoinLayout
transformLabel :: Parms w -> String -> IO String
data GenWidParameters
GenWidParameters :: JoinLayout -> TransformLabel -> GenWidParameters
joinLayout :: GenWidParameters -> JoinLayout
labelTransform :: GenWidParameters -> TransformLabel
defaultParms :: (GenWidParameters -> GenWidParameters) -> GenWidParameters

-- | Initial parameters. Should only be called at the top-level. If already
--   in a <tt>GenWid</tt> function then use <a>subParms</a>.
toParms :: Window w -> GenWidParameters -> IO (Parms w)
data TransformLabel
mkTransformLabel :: s -> (String -> State s String) -> TransformLabel
idLabel :: TransformLabel
greedyShortcuts :: [Char] -> TransformLabel
data WidTree
data WxWindow
WxWindow :: (Window w) -> WxWindow
class WidgetTree w
widgetTree :: (WidgetTree w) => ReadAttr w WidTree

-- | Construct <a>WidTree</a>
mkWidTree :: [WxWindow] -> [WidTree] -> WidTree

-- | Construct <a>WidTree</a> from a single WxHaskell widget.
singleChild :: Window w -> IO WidTree

-- | Construct <a>WidTree</a> leaf node.
leafWidTree :: [WxWindow] -> IO WidTree
getChildren :: WidTree -> [WxWindow]
updateChildren :: Update [WxWindow] -> Update WidTree
getSubTrees :: WidTree -> [WidTree]
updateSubTrees :: Update [WidTree] -> Update WidTree

-- | Depth first traversal of <a>WidTree</a> FIXME: Is not really, or
--   atleast do not seem like a depth first traversal to the the user of
--   WxGeneric.
depthFirstTraversal :: WidTree -> [Window ()]
instance Widget (GenWid a)
instance Able (GenWid a)
instance Bordered (GenWid a)
instance Child (GenWid a)
instance Dimensions (GenWid a)
instance Identity (GenWid a)
instance Literate (GenWid a)
instance Visible (GenWid a)
instance Reactive (GenWid a)
instance Parent (GenWid a)
instance Sized (GenWid a)
instance Observable (GenWid a)
instance ValuedWidget a (GenWid a)
instance WidgetTree (GenWid a)
instance MapValue GenWid
instance ValuedWidget a (ValuedCmds a)
instance Observable (ValuedCmds a)

module Graphics.UI.WxGeneric

-- | Creates a widget from any type that implements WxGen.
genericWidget :: (WxGen a) => Window w -> a -> IO (GenWid a)

-- | Creates a widget from any type that implements WxGen.
genericWidgetEx :: (WxGen a) => (GenWidParameters -> GenWidParameters) -> (Outer a -> Outer a) -> Window w -> a -> IO (GenWid a)

-- | Creates a modal dialog containing the <tt>x</tt> value, an ok-buuton
--   and a cancel-button.
modalValuedDialog :: (WxGen a) => Window w -> String -> String -> a -> IO (Maybe a)
data Outer a
Outer :: PriLabel -> (Either (GenWidIO a) (String -> GenWidIO a)) -> Outer a

-- | Creates an <a>Outer</a> type. The encapsulated widget is labelless.
toOuter :: (WxGen a) => GenWidIO a -> Outer a

-- | Creates an <a>Outer</a> type. The encapsulated widget has a label.
withLabel :: (WxGen a) => (String -> GenWidIO a) -> Outer a

-- | Unpacks an <a>Outer</a> type and returns the encapsulated
--   <a>GenWid</a>.
fromOuter :: Parms w -> Outer a -> IO (GenWid a)

-- | Returns label if the widget do not show it itself
getUnlabeld :: Outer a -> Maybe String

-- | Sets the label on an <a>Outer</a> type.
setOuterLabel :: PriLabel -> Outer a -> Outer a
replacePoorConstrLabel :: String -> Outer a -> Outer a
class (Data WxGenD a) => WxGen a
mkWid :: (WxGen a) => a -> Outer a
generateLabel :: (WxGen a) => a -> PriLabel

-- | The dictionary type for the WxEcCreator class
data WxGenD a
WxGenD :: (a -> Outer a) -> WxGenD a
mkWidD :: WxGenD a -> a -> Outer a

-- | The context for generic autoform
wxGenCtx :: Proxy WxGenD

-- | Creates an <a>Outer</a> type for a type with a single constructor.
singleConstr :: (WxGen a) => Bool -> a -> Outer a

-- | Creates an <a>Outer</a> type for a type with more than one
--   constructor.
polyConstr :: (WxGen a, Data WxGenD a) => a -> Outer a

-- | Makes it possible to choose between competing instances without
--   allowing overlapping instances.
extOuter :: (Typeable a, Typeable b) => (a -> Outer a) -> (b -> Outer b) -> a -> Outer a
