-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | metamorphisms: ana . cata  or  understanding folds and unfolds
--   
--   Metamorphisms are an approach to structured recursion.
--   
--   This package is currently a reorganization and slight adaptation of
--   the original code which was written more than a decade ago (in 1999);
--   it is, however quite a direct and clever way to investigate the
--   concepts involved.
--   
--   The original code and paper can be found here:
--   
--   <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   This code uses unusual layout (in particular, I use very wide columns
--   and lots of spacing) in hopes that it makes the symmetry of the
--   functions manifest. Any mistakes in the code are almost surely mine,
--   and not the original author's.
--   
--   Future updates should include:
--   
--   <ul>
--   <li>documentation</li>
--   <li>an abstract syntax graph version of the included functions</li>
--   <li>diagrams of involved structures</li>
--   <li>examples demonstrated by doctest</li>
--   <li>switch to hierarchical naming</li>
--   <li>switch to available versions of components (SimpleMap, Heap)</li>
--   <li>a more general license</li>
--   </ul>
@package metamorphic
@version 0.1.2.3


-- | Code adapted from: <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   Documentation (and further updates in technique) forthcoming.
module A

-- | A standard Bifunctor, but with a Roman Numeral naming scheme:
--   
--   <ul>
--   <li><i><i>II</i></i> instead of <tt>Bi</tt></li>
--   <li><i><i>fmapII</i></i> instead of <tt>bimap</tt></li>
--   <li><i><i>fmapLI</i></i> instead of <tt>first</tt></li>
--   <li><i><i>fmapIR</i></i> instead of <tt>second</tt></li>
--   </ul>
--   
--   This is to remind us that the other column remains intact when focus
--   on one (L or R).
class IIFunctor f where fmapII f g = fmapLI f . fmapIR g fmapLI f = fmapII f id fmapIR g = fmapII id g
fmapII :: IIFunctor f => (a -> b) -> (c -> d) -> f a c -> f b d
fmapLI :: IIFunctor f => (a -> b) -> f a c -> f b c
fmapIR :: IIFunctor f => (b -> c) -> f a b -> f a c
data Id a
Id :: a -> Id a
fromId :: (a -> b) -> Id a -> b
toId :: (b -> a) -> b -> Id a
fromU :: t -> (a -> t) -> I a -> t
fromB :: t -> (a -> b -> t) -> II a b -> t
fromT :: t -> (a -> b -> b -> t) -> IIV a b -> t
fromP :: t -> (a -> [b] -> t) -> Power a b -> t
toU :: (t -> Bool) -> (t -> a) -> t -> I a
toB :: (t -> Bool) -> (t -> a) -> (t -> b) -> t -> II a b
toT :: (t -> Bool) -> (t -> a) -> (t -> b) -> (t -> b) -> t -> IIV a b
toP :: (t -> Bool) -> (t -> a) -> (t -> [b]) -> t -> Power a b
toP' :: (t -> Bool) -> (t -> (a, [b])) -> t -> Power a b
toB' :: (t -> Bool) -> (t -> (a, b)) -> t -> II a b
data I a
U_I_U :: I a
I :: a -> I a
data II a b
UII_U :: II a b
II :: a -> b -> II a b
data IIV a b
UIIVU :: IIV a b
IIV :: a -> b -> b -> IIV a b
data Power a b
UnitP :: Power a b
Many :: a -> [b] -> Power a b
ntBU :: (a -> b -> c) -> II a b -> I c
ntTB :: (a -> c) -> (b -> b -> d) -> IIV a b -> II c d
ntPB :: (a -> c) -> ([b] -> d) -> Power a b -> II c d
data A s g t
A :: (s -> t) -> (t -> g t) -> A s g t
con :: A t t1 t2 -> t -> t2
des :: A t t1 t2 -> t2 -> t1 t2
type BinA a t = SymA (II a) t
type PowA a t = SymA (Power a) t
type SymA g t = A (g t) g t
type JoinA a g = A (II [a] (g a)) (II a) (g a)

-- | Equip an A having linear constructor with a join view
joinView :: Functor g => A (II a t) g t -> A (II [a] t) g t
maybeView :: Functor g => A (II a t) g t -> A (II (Maybe a) t) g t
fold :: Functor g => (g u -> u) -> A s g t -> (t -> u)
unfold :: (Functor f, Functor g) => (t -> f t) -> A (f u) g u -> (t -> u)
trans :: (Functor g, Functor h) => (g u -> r) -> A s g t -> A r h u -> (t -> u)
transit :: (Functor g, Functor h) => A s g t -> A (g u) h u -> (t -> u)
via :: (Functor g, Functor h, Functor i) => A s g t -> A (g u) h u -> A (h v) i v -> (t -> v)

-- | Hylomorphisms in binary and triplet form (just for completeness)
hylo :: Functor f => (f b -> b) -> (a -> f a) -> (a -> b)
hylot :: Functor f => (f b -> g b) -> (g b -> b) -> (a -> f a) -> (a -> b)
hhh :: Functor f => (f b -> i b) -> (i b -> g b) -> (g b -> b) -> (a -> f a) -> (a -> b)

-- | A simple Stream ADT
h :: Functor f => (f b -> i b) -> (i b -> j b) -> (j b -> k b) -> (k b -> b) -> (a -> f a) -> (a -> b)
stream :: Functor g => [SymA g t] -> t -> t
instance Functor (Power a)
instance IIFunctor Power
instance IIFunctor IIV
instance IIFunctor II
instance Functor (IIV a)
instance Functor (II a)
instance Functor I
instance Functor Id


-- | Code adapted from: <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   Documentation (and further updates in technique) forthcoming.
module Heap
data Heap a
Empty :: Heap a
Node :: a -> [Heap a] -> Heap a
empty :: Ord a => Heap a
unit :: a -> Heap a
insert :: Ord a => a -> Heap a -> Heap a
merge :: Ord a => Heap a -> Heap a -> Heap a
isEmpty :: Ord a => Heap a -> Bool
findMin :: Ord a => Heap a -> a
deleteMin :: Ord a => Heap a -> Heap a
splitMin :: Ord a => Heap a -> (a, Heap a)
instance Eq a => Eq (Heap a)
instance (Show a, Ord a) => Show (Heap a)


-- | Code adapted from: <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   Documentation (and further updates in technique) forthcoming.
module SimpleMap
data FiniteMap a b
Empty :: FiniteMap a b
Node :: (FiniteMap a b) -> (a, b) -> (FiniteMap a b) -> FiniteMap a b
emptyFM :: Ord a => FiniteMap a b
addToFM :: Ord a => FiniteMap a b -> a -> b -> FiniteMap a b
delFromFM :: Ord a => FiniteMap a b -> a -> FiniteMap a b
updFM :: Ord a => FiniteMap a b -> a -> (b -> b) -> FiniteMap a b
accumFM :: Ord a => FiniteMap a b -> a -> (b -> b -> b) -> b -> FiniteMap a b
splitFM :: Ord a => FiniteMap a b -> a -> Maybe (FiniteMap a b, (a, b))
isEmptyFM :: FiniteMap a b -> Bool
sizeFM :: Ord a => FiniteMap a b -> Int
lookupFM :: Ord a => FiniteMap a b -> a -> Maybe b
elemFM :: Ord a => FiniteMap a b -> a -> Bool
rangeFM :: Ord a => FiniteMap a b -> a -> a -> [b]
minFM :: Ord a => FiniteMap a b -> Maybe (a, b)
maxFM :: Ord a => FiniteMap a b -> Maybe (a, b)
predFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
succFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
splitMinFM :: Ord a => FiniteMap a b -> Maybe (FiniteMap a b, (a, b))
fmToList :: Ord a => FiniteMap a b -> [(a, b)]
instance (Eq a, Eq b) => Eq (FiniteMap a b)
instance (Show a, Show b, Ord a) => Show (FiniteMap a b)


-- | Code adapted from: <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   Documentation (and further updates in technique) forthcoming.
module Thread
type Split t i r = i -> t -> (r, t)
type Thread t i r = (t, Split t i r)
type Collect r c = (r -> c -> c, c)
threadList' :: (Collect r c) -> (Split t i r) -> [i] -> t -> (c, t)
threadList :: (Collect r c) -> (Split t i r) -> [i] -> t -> (c, t)
type SplitM t i r = Split t i (Maybe r)
threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
splitPar :: Split t i r -> Split u j s -> Split (t, u) (i, j) (r, s)
splitParM :: SplitM t i r -> Split u j s -> SplitM (t, u) (i, j) (r, s)


-- | Code adapted from: <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   Documentation (and further updates in technique) forthcoming.
module Graph
type Node = Int
data Graph a b
type Edge b = (Node, Node, b)
type Adj b = [(b, Node)]
type Context a b = (Adj b, Node, a, Adj b)
type MContext a b = Maybe (Context a b)
type Decomp a b = (MContext a b, Graph a b)
empty :: Graph a b
embed :: Context a b -> Graph a b -> Graph a b
match :: Node -> Graph a b -> Decomp a b
isEmpty :: Graph a b -> Bool
matchAny :: Graph a b -> (Context a b, Graph a b)
matchSome :: (Graph a b -> Node -> Bool) -> Graph a b -> (Context a b, Graph a b)
matchThe :: (Graph a b -> Node -> Bool) -> Graph a b -> (Context a b, Graph a b)
context :: Node -> Graph a b -> Context a b
(\\) :: Graph a b -> [Node] -> Graph a b
suc :: Graph a b -> Node -> [Node]
pre :: Graph a b -> Node -> [Node]
neighbors :: Graph a b -> Node -> [Node]
out :: Graph a b -> Node -> [Edge b]
inn :: Graph a b -> Node -> [Edge b]
indeg :: Graph a b -> Node -> Int
outdeg :: Graph a b -> Node -> Int
deg :: Graph a b -> Node -> Int
suc' :: (t, t1, t2, [(a, b)]) -> [b]
pre' :: ([(a, b)], t, t1, t2) -> [b]
neighbors' :: ([(a1, a)], t, t1, [(a2, a)]) -> [a]
out' :: (t, t1, t2, t3) -> t
inn' :: (t, t1, t2, t3) -> t3
indeg' :: ([a], t, t1, t2) -> Int
outdeg' :: (t, t1, t2, [a]) -> Int
deg' :: ([a], t, t1, [a1]) -> Int
node' :: (t, t1, t2, t3) -> t1
lab' :: (t, t1, t2, t3) -> t2
noNodes :: Graph a b -> Int
nodeRange :: Graph a b -> (Node, Node)
nodes :: Graph a b -> [Node]
labNodes :: Graph a b -> [(Node, a)]
edges :: Graph t t1 -> [(Node, Node)]
labEdges :: Graph a b -> [Edge b]
ufold :: ((Context a b) -> c -> c) -> c -> Graph a b -> c
gfold :: (Dir a b) -> (Dagg a b c d) -> (Bagg d c) -> [Node] -> Graph a b -> c
undir :: Graph a () -> Graph a ()
newNodes :: Int -> Graph a b -> [Node]
insNode :: Graph a b -> (Node, a) -> Graph a b
insNodes :: Graph a b -> [(Node, a)] -> Graph a b
insEdge :: Graph a b -> (Node, Node, b) -> Graph a b
insEdges :: Graph a b -> [(Node, Node, b)] -> Graph a b
mkGraph :: [(Node, a)] -> [(Node, Node, b)] -> Graph a b
buildGr :: [Context a b] -> Graph a b
instance (Show a, Show b) => Show (Graph a b)


-- | Code adapted from: <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   Documentation (and further updates in technique) forthcoming.
module GraphData
a :: Graph Char ()
b :: Graph Char ()
c :: Graph Char ()
e :: Graph Char ()
ab :: Graph Char ()
loop :: Graph Char ()
cyc3 :: Graph Char [Char]
dag3 :: Graph Char ()
dag4 :: Graph Integer ()
clr479 :: Graph Char ()
clr486 :: Graph [Char] ()
clr489 :: Graph Char ()
clr528 :: Graph Char Integer
kin248 :: Graph Integer ()


-- | Code adapted from: <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   Documentation (and further updates in technique) forthcoming.
module Tree
data Tree a
Leaf :: Tree a
Branch :: a -> Tree a -> Tree a -> Tree a
key :: Tree a -> a
left :: Tree a -> Tree a
right :: Tree a -> Tree a
showsTree :: Show a => Tree a -> ShowS
isLeaf :: Tree t -> Bool
instance Eq a => Eq (Tree a)
instance Show a => Show (Tree a)


-- | Code adapted from: <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   Documentation (and further updates in technique) forthcoming.
module Alib
cRose :: a
dRose :: a
nat :: SymA I Int
evn :: SymA I Int
halves :: SymA I Int
nat2 :: (IxI -> Bool) -> (IxI -> IxI) -> A () (II Int) IxI
rng :: A (I Int) (II Int) Int
rng' :: A () (II Int) Int
count :: A (II a Int) I Int
prod :: A (II Int Int) I Int
summ :: A (II Int Int) I Int
bool :: BinA Bool Bool
boolAnd :: BinA Bool Bool
set :: (Num a, Eq a) => BinA a [a]
list :: BinA a [a]
queue :: BinA a [a]
pqueue :: Ord a => BinA a [a]
pqueueH :: Ord a => BinA a (Heap a)
jPqueueH :: Ord a => JoinA a Heap
jQueue :: JoinA a []
jList :: JoinA a []
jPqueue :: Ord a => JoinA a []
bag :: Ord a => BinA a (FiniteMap a Int)
arr :: Ord i => (a -> a -> a) -> BinA (i, a) (FiniteMap i a)
fork :: Ord a => A (II a [a]) (IIV [a]) [a]
final :: A (II a (Maybe a)) (Id) (Maybe a)
combine :: A (IIV [a] [a]) (II a) [a]
tree :: SymA (IIV a) (Tree a)
rose :: SymA (Power a) (Rose a)
graph :: BinA (Context a b) (Graph a b)
type LinGraph a b = II (Context a b) (Graph a b)
cGraph :: LinGraph a b -> Graph a b
stack :: BinA a [a]
jStack :: JoinA a []
sel :: (a -> a -> Bool) -> [a] -> [a]
rest :: Eq a => [a] -> [a]
append213 :: [a] -> [a] -> [a] -> [a]
accum :: Ord o => (a -> a -> a) -> (o, a) -> FiniteMap o a -> FiniteMap o a
add :: (Ord o, Num a) => o -> FiniteMap o a -> FiniteMap o a
split_bag :: (Ord o, Eq a, Num a) => FiniteMap o a -> (o, FiniteMap o a)
split_arr :: Ord o => FiniteMap o a -> ((o, a), FiniteMap o a)

-- | construct (resp. destroy) a <a>I</a> of Naturals using <a>Int</a>s.
cNat :: I Int -> Int

-- | construct (resp. destroy) a <a>I</a> of Naturals using <a>Int</a>s. |
--   construct (resp. destroy) a <a>II</a> of <tt>a</tt>s using Lists
dNat :: Int -> I Int
cList :: II a [a] -> [a]

-- | construct (resp. destroy) a <a>II</a> of <tt>a</tt>s using base Lists
dList :: [a] -> II a [a]

-- | destroy priority queue (a <a>II</a> over base Lists)
dPqueue :: Ord a => [a] -> II a [a]

-- | destroy priority queue heap (a <a>II</a> (<tt>Bifunctor</tt>) over
--   <a>Heap</a>s) | construct (resp. destroy) a <a>II</a> of two Naturals
--   using <a>Int</a>s.
dPqueueH :: Ord a => Heap a -> II a (Heap a)
cProd :: II Int Int -> Int

-- | construct (resp. destroy) a <a>II</a> of two Naturals using
--   <a>Int</a>s.
dProd :: Int -> II Int Int
type IxI = (Int, Int)
data Rose a
Null :: Rose a
Nd :: a -> [Rose a] -> Rose a
type Forest a = [Rose a]
forest' :: PowA a (Rose a)
forest :: A (Id [Rose a]) (II [a]) [Rose a]
isNull :: Rose a -> Bool
cut :: Rose a -> (a, [Rose a])
root :: Rose a -> a
kids :: Rose t -> [Rose t]
bufGraph :: (JoinA c f) -> (c -> Node) -> (c -> Context a b -> [c]) -> A () (II (MContext a b)) (f c, Graph a b)
q1 :: (t, x, y, z) -> t
q2 :: (t, x, y, z) -> x
q23 :: (t, x, y, z) -> (x, y)
q4 :: (t, x, y, z) -> z

-- | curried composition
--   
--   o :: forall a f g b. (b -&gt; a) -&gt; (f -&gt; g -&gt; b) -&gt; f
--   -&gt; g -&gt; a
o :: (b1 -> c) -> (a -> b -> b1) -> a -> b -> c
data NoK o
No :: NoK o
OK :: o -> NoK o
(><) :: (t -> t2) -> (t1 -> t3) -> (t, t1) -> (t2, t3)
(/\) :: (t2 -> t) -> (t2 -> t1) -> t2 -> (t, t1)
instance Show a => Show (Rose a)


-- | Code adapted from: <a>http://web.engr.oregonstate.edu/~erwig/meta/</a>
--   
--   Documentation (and further updates in technique) forthcoming.
module Aprog
sum' :: (Eq a, Num a) => [a] -> a
sumset :: (Eq a, Num a) => [a] -> a
fac1 :: Int -> Int
countdown :: Int -> [Int]
fac2 :: Int -> Int
log2 :: Int -> Int
double :: Int -> Int
minus :: Num c => (c, c) -> c
eq0 :: (Eq b, Num b) => (a, b) -> Bool
eq0' :: (Eq b, Num b) => (b, b1) -> Bool
lt0' :: (Ord b, Num b) => (b, b1) -> Bool
mult :: IxI -> Int
power :: IxI -> Int
mod' :: IxI -> Maybe Int
gcd' :: IxI -> Maybe Int
fac3 :: Int -> Int
length1 :: [t] -> Int
length2 :: [a] -> Int
length3 :: [a] -> Int
length4 :: [a] -> Int
card :: (Eq a, Num a) => [a] -> Int
card_alt :: (Eq a, Num a) => [a] -> Int
quicksort :: Ord a => [a] -> [a]
histogram :: Ord a => [a] -> FiniteMap a Int
any2 :: (a -> Bool) -> [a] -> Bool
all2 :: (a -> Bool) -> [a] -> Bool
size :: A s (II a) t -> t -> Int
mapset :: (Eq a, Eq b, Num a, Num b) => (a -> b) -> [a] -> [b]
flipTree :: Tree a -> Tree a
preorder :: Tree a -> [a]
dfsr :: Rose a -> [a]
bfsr :: [Rose a] -> [a]
binSearch :: Ord a => a -> Tree a -> Bool
tree' :: (Tree a -> t) -> (Tree a -> Tree a) -> A () (II t) (Tree a)
rose1 :: Num a => Rose a
rose2 :: Num a => Rose a
build :: [Context a b] -> Graph a b
gmap :: (Context a b -> Context c d) -> Graph a b -> Graph c d
nodes :: Graph a b -> [Node]
labNodes :: Graph a b -> [(Node, a)]
member :: Node -> Graph a b -> Bool
noEdges :: Graph a b -> Int
edges :: Graph a b -> [(Node, Node)]
labEdges :: Graph a b -> [(Node, Node, b)]
mapNodes :: (a -> a') -> Graph a b -> Graph a' b
mapEdges :: (b -> b') -> Graph a b -> Graph a b'
grev :: Graph a b -> Graph a b
mlist :: A (II (Maybe a) [a]) (II a) [a]
nodeId :: II (MContext a b) c -> II (Maybe Node) c
dfsn :: [Node] -> Graph a b -> [Node]
bfs :: Node -> Graph a b -> [Node]
dfs :: Graph a b -> [Node]
sp :: (Num b, Ord b) => Node -> Graph a b -> [Node]
sp1 :: (Num b, Ord b) => Node -> Graph a b -> [Node]
remdup :: (Num a, Eq a) => [a] -> [a]
rev :: [a] -> [a]
heapsort :: Ord a => [a] -> [a]
bucketsort' :: Ord a => [a] -> [a]
bucketsort :: Ord a => [a] -> [a]
l :: [Integer]
nats :: [Integer]
l1 :: [Integer]
l2 :: [Integer]
l3 :: [Integer]
l4 :: [Integer]
forceList :: [a] -> a
listToTree :: [a] -> Tree a
t :: Tree Integer
t1 :: Tree Integer
t2 :: Tree Integer
t3 :: Tree Integer
t4 :: Tree Integer
sucs :: Functor f => t -> (t1, t2, t3, f (a, b)) -> f b
labSucs :: Num t4 => (t4, t) -> (t1, t2, t3, [(t4, t5)]) -> [(t4, t5)]
labnl :: (Enum a, Enum b, Num a) => b -> Int -> [(a, b)]
noLab :: (t, t1) -> (t, t1, ())
