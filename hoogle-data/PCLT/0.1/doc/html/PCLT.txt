-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extension to Show: templating, catalogizing, languages, parameters, etc.
--   
--   "PCLT" is an abbreviation for "Parametric Composable Localizable
--   Templates" - in fact it should also hold Detalizable. Term
--   "Detailizable content (message)" in this package has a following
--   meaning: some content, representing which it is possible to regulate,
--   in how much details it is represented.
--   
--   Conceptually, this package is a powerful extension to the well known
--   Show class, that (extension) is thought to be embeded in any Haskell
--   program, which requires multilanguage support, and/or where messages
--   should be detailizable.
--   
--   The PCLT catalog consists of:
--   
--   <ul>
--   <li>Catalog ID</li>
--   <li>Config, which defines rules and constraints, that are used when
--   catalog gets formed, and when it is used to generate messages.</li>
--   <li>Tempates of messages, possibly related. Each catalog entry is
--   referenced by an ID, and is called "localizable (in languages)
--   template", while it's localization in concrete language is called
--   "localized (in a languages) template".</li>
--   </ul>
--   
--   Each catalog entry (localizable template) consists of
--   
--   <ul>
--   <li>ID</li>
--   <li>A requirement to detailization level (to used by reciever of
--   representation), which if is not statisfied, the template isn't
--   used.</li>
--   <li>A map of localized templates by languages - the different
--   translations of one same message.</li>
--   </ul>
--   
--   Each localized template is a sequence of chunks:
--   
--   <ul>
--   <li>plain texts,</li>
--   <li>named parameters placeholders,</li>
--   <li>placeholders for insertion of other template (reference on other
--   template, also called composites).</li>
--   </ul>
--   
--   To make a message one needs to specify
--   
--   <ul>
--   <li>a catalog,</li>
--   <li>a language,</li>
--   <li>detailization level to orient on</li>
--   <li>a localizable template ID,</li>
--   <li>a map of parameters together with their values.</li>
--   </ul>
--   
--   The last two fields (localizable template ID + a map of parameters
--   together with their values) is called instaniation (of templated
--   message). In the program it wrapped in a PCSI data type.
--   
--   A parameter value may be
--   
--   <ul>
--   <li>plain text</li>
--   <li>newline</li>
--   <li>nothing</li>
--   <li>a reference to other instaniation (localizable template ID + a map
--   of parameters together with their values)</li>
--   <li>a list of other other instaniation</li>
--   <li>a parameter wrapping, where wrapper is an indentation of text (N
--   whitespaces insertion after each newline character)</li>
--   <li>a list of parameter values.</li>
--   </ul>
--   
--   This package comes together with another one - a dependent package
--   PCLT-DB (section Database), which provides
--   
--   <ul>
--   <li>a (PostgreSQL 8.4) DB structure where to keep/manage data used for
--   PCLT catalogs formation,</li>
--   <li>simple interface to read this data in haskell program, and</li>
--   <li>a prototype of a longterm service which regularly updates catalog
--   MVar with data from DB.</li>
--   </ul>
--   
--   IMPORTANT!!! : It is highly recommended to use <i>ISO 639(3)</i>
--   standard for language names, since PCLT-DB package is oriented on 3
--   letters (not bigger) language names. Without modifications PCLT-DB
--   won't work for bigger (then 3-letters) names.
--   
--   ToDo considerations for the next versions:
--   
--   <ol>
--   <li>Consider using state monad in order to put catalog into an
--   implicit context... and maybe also other uses if monads.</li>
--   <li>Rewrite MakeCatalog, so that it uses CatalogMaths functions.
--   Otherwise the both modules do similar work, and keeping double code is
--   a bad style.</li>
--   <li>Introduction of a new parameter value type: "reparsable" wrapping
--   for parameter value.</li>
--   <li>CatalogMaths extension.</li>
--   <li>Enchance required SDLs with min &amp; max functions.</li>
--   <li>Sacrificing ldtSubcompositesMap of LocalizedTemplate, which
--   initially was introduced to enchance speed of messages generation, in
--   favor of making catalogs easier to modify (which curently isn't
--   supported and isn't an easy task).</li>
--   </ol>
@package PCLT
@version 0.1


-- | This module unifies some parts of <tt>bytestring</tt> (as is in
--   <tt>0.9.1.5</tt> version) and <tt>utf8-string</tt> (as is in
--   <tt>0.3.6</tt> version) packages - it exports
--   <a>Data.ByteString.Lazy.Char8</a>, <a>Data.ByteString.Lazy.UTF8</a>
--   and <a>System.IO.UTF8</a>, while hiding from the first everything that
--   is to be found in latter two. Ofcourse <a>System.IO.UTF8</a> routines
--   are wrapped to work with lazy <tt>ByteStrings</tt> instead of
--   <tt>Strings</tt>. This way we get a module an
--   <a>Data.ByteString.Lazy.Char8</a> alternative that won't corrupt
--   Unicode symbols, an that will make a proper IO with them.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with Prelude functions. eg.
--   
--   <pre>
--   import qualified Data.ByteString.Lazy.UTF8.Unified as B
--   </pre>
--   
--   or even
--   
--   <pre>
--   import qualified Data.ByteString.Lazy.UTF8.Unified as Lazy     (ByteString)
--   import qualified Data.ByteString.Lazy.UTF8.Unified as B hiding (ByteString)
--   </pre>
module Data.ByteString.Lazy.UTF8.Unified


-- | Simply saying: with SDL we regulate, how much some Reader (of our
--   generated messages) wishes (is allowed) to see.
--   
--   "SDL" is an abbreviation for "Show Detalization Level". Perhaps it
--   better sound "Representation Detalization Level", but it was too late
--   to change term - too many variables has names <tt>sdl</tt>, and author
--   is too lazy to change them on <tt>rdl</tt>s. However, "Representation
--   Detalization Level" version is sometimes used - it is to be understood
--   as synonym to SDL. Term "Detailizable content (message)" in this
--   package has a following meaning: some content, representing which it
--   is possible to regulate, in how much of details it is to be
--   represented.
module Text.PCLT.SDL

-- | <pre>
--   Zero_SDL &lt; One_SDL &lt; SDL Int &lt; InfinitelyBig_SDL
--   </pre>
data ShowDetalizationLevel
Zero_SDL :: ShowDetalizationLevel
One_SDL :: ShowDetalizationLevel
SDL :: Int -> ShowDetalizationLevel
InfinitelyBig_SDL :: ShowDetalizationLevel

-- | SDL may be seen in two different moduses:
--   
--   <ul>
--   <li>as a requirement for representation by a localizable template:
--   "SDL of repesentation reciever must be equal or bigger then that,
--   orelse message from this template won't be generated"</li>
--   <li>as an allocateion to a repesentation reciever.</li>
--   </ul>
data SDLModus
Allocated_SDLM :: SDLModus
Required_SDLM :: SDLModus

-- | In case, if SDL (of reciever of template requirement) is unclear, and
--   if it is allowed by config - then SDL gets assigned according to
--   margin:
--   
--   <ul>
--   <li>if modus is allocation to reciever - the we give him
--   <tt>Zero_SDL</tt> (minimum)</li>
--   <li>if modus is requirement by template - the we give him
--   <tt>InfinitelyBig_SDL</tt> (maximum)</li>
--   </ul>
marginOfSDLModus :: SDLModus -> ShowDetalizationLevel
strict_str2sdl :: String -> Maybe ShowDetalizationLevel
instance Typeable SDLModus
instance Typeable ShowDetalizationLevel
instance Eq SDLModus
instance Show SDLModus
instance Ord ShowDetalizationLevel
instance Eq ShowDetalizationLevel
instance Show ShowDetalizationLevel

module Text.PCLT.CommonTypes

-- | It is highly recommended to use <i>ISO 639-3</i> here - I mean it was
--   originally intended to do so, and now a related package PCLT-DB works
--   only with 3-letters (not bigger) languages names - there is a
--   constraint in DB for that.
type LanguageName = String
type PCLT_ID = String

-- | Localizable template ID.
type PCLT_ParamKey = String

-- | Here and in many places of package by "composite" is meant "template
--   which is included in composed template".
type PCLT_CompositeKey = PCLT_ID
type PCLT_SuperCompositeKey = PCLT_CompositeKey
type PCLT_SubCompositeKey = PCLT_CompositeKey
type RequiredCompositeKey = PCLT_CompositeKey
type RequirerCompositeKey = PCLT_CompositeKey
type ParamName_LBS = ByteString

module Text.PCLT.Config
data StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets
StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets :: Bool -> [PCLT_ID] -> [PCLT_ID] -> [PCLT_ParamKey] -> [(PCLT_ID, PCLT_ID)] -> [(PCLT_ID, PCLT_ParamKey)] -> StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets

-- | Abbreviation = "SO". The exclusions has opposite roles for different
--   values of this parameter.
--   
--   <ul>
--   <li>if SO is True , be strict with templates (when adding them and to
--   a catalog) in such manner, that set of composite and set of parameters
--   MUST be the same for ALL language localizations under one template ID;
--   if for a template any set (of parameters or of composites) is
--   different from one determined for template in default language, then
--   this template will be discarded (not included in catalog)</li>
--   <li>if SO is False, don't be strict with templates - different
--   language versions of one same template are allowed to have different
--   sets of composites and parameters</li>
--   </ul>
soStrict_IsIt :: StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets -> Bool

-- | <ul>
--   <li>if SO is True , don't be strict with contents of these
--   templates;</li>
--   <li>if SO is False, be strict with contents of ONLY these
--   templates</li>
--   </ul>
soExcludingInComposites :: StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets -> [PCLT_ID]

-- | <ul>
--   <li>if SO is True , don't be strict with occurences of these templates
--   as composites;</li>
--   <li>if SO is False, be strict with occurences of ONLY these templates
--   as composites</li>
--   </ul>
soExcludingComposites :: StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets -> [PCLT_ID]

-- | <ul>
--   <li>if SO is True , don't be strict with these parameters;</li>
--   <li>if SO is False, be strict with ONLY these parameters</li>
--   </ul>
soExcludingParameters :: StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets -> [PCLT_ParamKey]

-- | <ul>
--   <li>if SO is True , don't be strict with these referenced parameters
--   in referenced templates;</li>
--   <li>if SO is False, be strict with ONLY these referenced parameters in
--   referenced templates</li>
--   </ul>
soExcludingCompComposites :: StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets -> [(PCLT_ID, PCLT_ID)]

-- | <ul>
--   <li>if SO is True , don't be strict with these referenced composites
--   in referenced templates;</li>
--   <li>if SO is False, be strict with ONLY these referenced composites in
--   referenced templates</li>
--   </ul>
soExcludingCompParameters :: StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets -> [(PCLT_ID, PCLT_ParamKey)]
type PCLT_InnerConfigID = Int

-- | NOT USED, RESERVED FOR FUTURE VERSIONS OF PCLT!
type ReparsingDepth = Int
data PCLT_InnerConfig
PCLT_InnerConfig :: PCLT_InnerConfigID -> ByteString -> ByteString -> ByteString -> ByteString -> LanguageName -> StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets -> Bool -> Bool -> Bool -> Int64 -> Bool -> Bool -> Bool -> ByteString -> ReparsingDepth -> Int64 -> PCLT_InnerConfig
pcsInnerConfigID :: PCLT_InnerConfig -> PCLT_InnerConfigID

-- | Symbols sequence denoting wrapping parentheses (identical for both -
--   openning ang closing), that are to be put around *composite* name in a
--   template text.
pcsCompositePlaceholderWrapper :: PCLT_InnerConfig -> ByteString

-- | Symbols sequence denoting wrapping parentheses (identical for both -
--   openning ang closing), that are to be put around *parameter* name in a
--   template text.
pcsParameterPlaceholderWrapper :: PCLT_InnerConfig -> ByteString

-- | For case, when representation reciever uses detalization level, that
--   isn't enough to meet requirement specified by the template (from which
--   representation was to be made): symbols sequence, that PCLT engine
--   must place instead of content from template/composite.
pcsInsuficientDetLevelPlaceholder :: PCLT_InnerConfig -> ByteString

-- | Symbols sequence denoting wrapping parentheses (identical for both -
--   openning ang closing), that are to be put (by PCLT engine) in
--   representation, where it failed to make a proper representation from a
--   template piece (composite or parameter).
pcsMarkingErrorPlaceholderWrapper :: PCLT_InnerConfig -> ByteString

-- | Catalog default (primary) language.
pcsDefaultLanguage :: PCLT_InnerConfig -> LanguageName

-- | Object:
--   
--   <ol>
--   <li>Should all localizations of template be strictly oriented on
--   localization in default (primary) language? (in case of such
--   orientation, NO template localized in a nondefault language is allowed
--   to have sets of composites and parameters different from ones
--   specified for template localization in the default language)</li>
--   <li>Exclusions - when not to be strict with templates structures, - if
--   strictness is on; or when to be strict, - if strictness is off.</li>
--   </ol>
pcsStrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets :: PCLT_InnerConfig -> StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets

-- | Is it allowed to demand representations from catalog, when referenced
--   template/composite ID isn't known in given catalog? In case, if
--   allowed, on place of unknown composite the engine (when making
--   representation) will simply put it's (unknown) ID (given that
--   recievers detailization level statisfies a requirement: it must be
--   maximal (infinitely big)), followed by (if enabled by other config
--   parameter) all the parameters used by current instaniation.
pcsAllowUntemplatedMessages :: PCLT_InnerConfig -> Bool

-- | Is it allowed to demand representations from catalog, when referenced
--   template/composite ID is persistent in catalog, but not in
--   representation language? In case, if allowed, on place of unknown
--   composite the engine (when making representation) will simply put it's
--   (unknown) ID (given that recievers detailization level statisfies a
--   requirement: it must be maximal (infinitely big)), followed by (if
--   enabled by other config parameter) all the parameters used by current
--   instaniation.
pcsAllowUntemplatedLocalizationsOfMessages :: PCLT_InnerConfig -> Bool

-- | If it's allowed to require representation of a template/composite (or
--   it's localisation), that is absent in catalog then (given that
--   reciever's detailization level statisfies a requirement: it must be
--   maximal (infinitely big)) together with it's (unknown composite) ID:
--   should there also be put all the parameters (array of name:value
--   pairs), used by current instaniation?
pcsShowAdhocParamsInResultOfUntemplated :: PCLT_InnerConfig -> Bool

-- | DEFAULT maximal allowed size of representation resulting from
--   instaniation of a single PCSI. If user gives on the input his
--   ConstraintedLBS with different constraint on size, then his constraint
--   is used instead.
pcsInstaniationResultMaxSize :: PCLT_InnerConfig -> Int64

-- | Is it allowed to give an empty value to the field "representation
--   detailization level" (<a>Text.PCLT.SDL</a>)? If allowed, then it's
--   value will be chosen automatically by the margin depending on modus:
--   maximal ("+inf") in case, when it's a requirement by a template, or
--   minimal ("zero"), when it's an assigment to a reciever of
--   representation
pcsAllowEmptySDL_parseItByModusMargin :: PCLT_InnerConfig -> Bool

-- | Is it allowed to give an unreadable value to the field "representation
--   detailization level" (<a>Text.PCLT.SDL</a>)? If allowed, then it's
--   value will be chosen automatically by the margin depending on modus:
--   maximal ("+inf") in case, when it's a requirement by a template, or
--   minimal ("zero"), when it's an assigment to a reciever of
--   representation
pcsAllowUnreadableSDL_parseIdByModusMargin :: PCLT_InnerConfig -> Bool

-- | If <tt>pcsi2text</tt> (<a>Text.PCLT.MakeMessage</a>) function fails to
--   determine an SDL requiered by used template (due to referential cycle,
--   missing referenced template, <tt>PCLT_SDL_Errornous</tt> or other
--   reason) - should this failure lead to absolute denial to represent
--   problem template, or should the <tt>pcsi2text</tt> treat it like
--   "+inf" (<tt>PCLT_SDL InfinitelyBig_SDL</tt>)? The error will be
--   returned anyway, but question is purely about output representation.
pcsAllowFailureToDetermineSDL_parseIdByModusMargin :: PCLT_InnerConfig -> Bool

-- | Sequence of symbols used, when representing a specialcase of parameter
--   value - <tt>Newline_PV</tt> (<a>Text.PCLT.PCSI</a>). (Different OSes
--   use different newline strings: in Linux it's #10, in M$ - #13#10,
--   MacOS - #13)
pcsNewlineLBS :: PCLT_InnerConfig -> ByteString

-- | NOT USED, RESERVED FOR FUTURE VERSIONS OF PCLT! Maximal allowed depth
--   of reparsing.
pcsReparsingDepthMax :: PCLT_InnerConfig -> ReparsingDepth

-- | NOT USED, RESERVED FOR FUTURE VERSIONS OF PCLT! Maximal allowed size
--   of representation resuling from instaniating a reparsing result.
pcsReparseParameterContentMaxSize :: PCLT_InnerConfig -> Int64

-- | <pre>
--   PCLT_InnerConfig {
--             pcsInnerConfigID = 0
--           , pcsCompositePlaceholderWrapper = B.pack "##|"
--           , pcsParameterPlaceholderWrapper = B.pack "@@|"
--           , pcsInsuficientDetLevelPlaceholder = B.pack "#x#"
--           , pcsMarkingErrorPlaceholderWrapper = B.pack "/!E!\"
--           , pcsDefaultLanguage                = "eng"
--           , pcsStrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets =
--                     StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets {
--                               soStrict_IsIt = True
--                             , soExcludingInComposites   = []
--                             , soExcludingComposites     = []
--                             , soExcludingParameters     = []
--                             , soExcludingCompComposites = []
--                             , soExcludingCompParameters = []
--                     }
--           , pcsAllowUntemplatedMessages                = True
--           , pcsAllowUntemplatedLocalizationsOfMessages = True
--           , pcsShowAdhocParamsInResultOfUntemplated    = True
--           , pcsInstaniationResultMaxSize               = 10000000
--           , pcsAllowEmptySDL_parseItByModusMargin      = False
--           , pcsAllowUnreadableSDL_parseIdByModusMargin = False
--           , pcsAllowFailureToDetermineSDL_parseIdByModusMargin = False
--           , pcsNewlineLBS                              = B.pack "\n"
--     }
--   </pre>
defaultPCLTInnerConfig :: PCLT_InnerConfig
instance Typeable PCLT_InnerConfig
instance Typeable StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets
instance Show PCLT_InnerConfig
instance Read StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets
instance Show StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets

module Text.PCLT.Parser.AdvancedSepBy
type SeparationMarkerIdx = Int
data SeparatedSectorMarker
Beginning_SSM :: SeparatedSectorMarker
EOF_SSM :: SeparatedSectorMarker
InnerMarker_SSM :: SeparationMarkerIdx -> SeparatedSectorMarker
Error_SSM :: StandartMarkingStrategyError -> SeparatedSectorMarker
type MarkedChunkLength = Int64
manyTill_EOForEitherOf :: Parser Char -> [Parser ByteString] -> Parser (SeparatedSectorMarker, ByteString, MarkedChunkLength)
type New_Active_Sep_SSM = SeparatedSectorMarker
type Previous_Active_Sep_SSM = SeparatedSectorMarker
type Current_Sep_SSM = SeparatedSectorMarker
type Current_Chunk_SSM = SeparatedSectorMarker
type SectorMarkingStrategy = (Previous_Active_Sep_SSM, Current_Sep_SSM) -> (Current_Chunk_SSM, New_Active_Sep_SSM)
sepBySome :: Parser Char -> SectorMarkingStrategy -> [Parser ByteString] -> Parser [(SeparatedSectorMarker, ByteString, MarkedChunkLength)]
data StandartMarkingStrategyError
InputAfterEOF_SMSE :: StandartMarkingStrategyError
BeginningMNotInTheBeginning_SMSE :: StandartMarkingStrategyError
OverlappingMarkedChunks_SMSE :: StandartMarkingStrategyError
UnsupportedMarkersSequence_SMSE :: SeparatedSectorMarker -> SeparatedSectorMarker -> StandartMarkingStrategyError
OpenMarkerAtEOF_SMSE :: SeparationMarkerIdx -> StandartMarkingStrategyError
UnallowedCharacter_SMSE :: Char -> StandartMarkingStrategyError
standardMarkingStrategy :: SectorMarkingStrategy
standardMarkingStrategyFix_StripEmptyChunks :: [(SeparatedSectorMarker, ByteString, MarkedChunkLength)] -> [(SeparatedSectorMarker, ByteString, MarkedChunkLength)]
type ChunkIndexInList_ = Int
retrieveNonPlainMarkingsMap :: [(SeparatedSectorMarker, ByteString, MarkedChunkLength)] -> Map SeparatedSectorMarker [(ByteString, ChunkIndexInList_)]
getListOfMarkings :: Map SeparatedSectorMarker [(ByteString, ChunkIndexInList_)] -> Int -> [(ByteString, ChunkIndexInList_)]
retrieveErrorsMarkingsList :: [(SeparatedSectorMarker, ByteString, MarkedChunkLength)] -> [(SeparatedSectorMarker, ByteString, ChunkIndexInList_)]
insertInsteadOf_inLBS :: (ByteString, ByteString) -> ByteString -> ByteString
instance Eq StandartMarkingStrategyError
instance Ord StandartMarkingStrategyError
instance Eq SeparatedSectorMarker
instance Ord SeparatedSectorMarker
instance Show StandartMarkingStrategyError
instance Show SeparatedSectorMarker


-- | The analogue to ordinary lazy <tt>ByteString</tt>, but with a
--   constraint on size, and some routines, thet respects the constraint.
module Text.ConstraintedLBS

-- | The analogue to ordinary lazy <tt>ByteString</tt>, but with a
--   constraint on size.
data CLBS
CLBS :: ByteString -> Int64 -> Int64 -> Bool -> CLBS
clbsLBS :: CLBS -> ByteString
clbsLen :: CLBS -> Int64
clbsMaxLen :: CLBS -> Int64

-- | Bytestring is finalized, when something is appended to it, that makes
--   <tt>clbsMaxLen</tt> to be reached. The last 3 bytes of a finalized
--   bytestring are always made "..." (by routines of this module, that
--   manage finalization).
clbsFinalized_isit :: CLBS -> Bool
clbsFreeSpaceLeft :: CLBS -> Int64

-- | Make a <a>CLBS</a> with a specified maximum on length.
newCLBS :: Int64 -> CLBS

-- | Append first lazy <tt>ByteString</tt> (given in tuple with it's
--   (trusted) length) to a <a>CLBS</a>. If the result of appending
--   violates clbsMaxLen constraint, then the content gets truncated,
--   tailed with "..." and CLBS is finalized (nothing more can be added to
--   it)
addToCLBS_1 :: (ByteString, Int64) -> CLBS -> CLBS

-- | Produce an empty <a>CLBS</a>, that would have the maximum of length
--   equal to free space left available in specified <a>CLBS</a>.
freeSpaceCLBS :: CLBS -> CLBS

-- | Append first to second. If the result of appending violates clbsMaxLen
--   constraint, then the content gets truncated, tailed with "..." and
--   CLBS is finalized (nothing more can be added to it)
addToCLBS_2 :: CLBS -> CLBS -> CLBS

-- | Make <a>CLBS</a> contain specified <tt>ByteString</tt>, keeping the
--   length constraint. If the specified bytestring violates clbsMaxLen
--   constraint, then the content gets truncated, tailed with "..." and
--   CLBS is finalized (nothing more can be added to it)
adjustCLBS_to :: CLBS -> ByteString -> CLBS

-- | Given <tt>insertInsteadOf_inCLBS (old_separator, new_separator)
--   clbs</tt>, function replaces every occurence of <tt>old_separator</tt>
--   on <tt>new_separator</tt> respecting length constraint (and possibly
--   finalizing <a>CLBS</a>).
insertInsteadOf_inCLBS :: (ByteString, ByteString) -> CLBS -> CLBS

-- | Empify, and if finalized, make not.
resetCLBS :: CLBS -> CLBS
type StdOut_CLBS = CLBS
type StdErr_CLBS = CLBS
type StdOutAndErr_CLBS = CLBS

-- | Append to first lazy bytestring the second one. The available space
--   for append is constrainted by the 3rd argument. Every bytestring must
--   be specified in tuple together with it's length (this is done to speed
--   up by reducing repeating <tt>length</tt> calls), which is trusted. If
--   length of added string is bigger then available for append, the result
--   will be truncated and will have a "..." tail.
--   
--   Function returns resulting ByteString, it's length and boolean
--   indicating if length of added string was bigger than available for
--   append space.
concatTruncedLiteraryLBS :: (ByteString, Int64) -> (ByteString, Int64) -> Int64 -> (ByteString, Int64, Bool)
instance Show CLBS


-- | Here are declared <a>LocalizableTemplate</a> (also called PCLT) and
--   <a>LocalizedTemplate</a>. Here by localization is meant localization
--   in languages. First (localizable template) is above languages, while
--   second (localized template) is a template version in a concrete
--   language.
module Text.PCLT.Template

-- | These are types of template pieces. They are made by <a>ssm2ldtm</a>
--   from <a>SeparatedSectorMarker</a>
data PCS_SpecificMarkings
PlainText_LngTplM :: PCS_SpecificMarkings
Parameter_LngTplM :: PCS_SpecificMarkings
Composite_LngTplM :: PCS_SpecificMarkings
Unsupported_LngTplM :: SeparatedSectorMarker -> PCS_SpecificMarkings
ssm2ldtm :: SeparatedSectorMarker -> PCS_SpecificMarkings

-- | Template content.
type LngTpl_AbstractedString = [(PCS_SpecificMarkings, ByteString, MarkedChunkLength)]

-- | Extract a list of parameter names from a template content.
listOfParams :: LngTpl_AbstractedString -> [ParamName_LBS]
type ParserBadResult = String

-- | These errors are possible only if program is wrong.
data PCLT_ParserLowLevelFailure
UnexpectedParserResult_PLLF_PCLT :: ParserBadResult -> PCLT_ParserLowLevelFailure
BadMarker_PLLF_PCLT :: SeparatedSectorMarker -> ByteString -> ChunkIndexInList_ -> PCLT_ParserLowLevelFailure

-- | The parsing uses parameters
--   <tt>Test.PCLT.Config.pcsParameterPlaceholderWrapper</tt> and
--   <tt>Test.PCLT.Config.pcsCompositePlaceholderWrapper</tt> of
--   <tt>Test.PCLT.Config.PCLT_InnerConfig</tt>. The list
--   <tt>[PCLT_CompositeKey]</tt> in the result is a list of composite keys
--   (template IDs, used by template as inclusions)
doTheParse :: PCLT_InnerConfig -> ByteString -> ([PCLT_ParserLowLevelFailure], Maybe (LngTpl_AbstractedString, [PCLT_CompositeKey]))
type PCLT_CatalogMap = Map PCLT_ID LocalizableTemplate
type LngTpl_SubCompositesMap = PCLT_CatalogMap
data LocalizedTemplate
LocalizedTemplate :: LngTpl_AbstractedString -> LngTpl_SubCompositesMap -> LocalizedTemplate
ldtAbstractedString :: LocalizedTemplate -> LngTpl_AbstractedString

-- | Each composition tree is kept together with each localization. This is
--   done for speedup and is a source of complexities, when forming a
--   catalog and sustaining it's data consistency. So it comes to this:
--   templates are purely-referenced by
--   
--   <ul>
--   <li>catalog (<a>PCLT_CatalogMap</a>) and</li>
--   <li>templates, that uses them as composites
--   (<a>LngTpl_SubCompositesMap</a>).</li>
--   </ul>
--   
--   By "purely-reference" here is meant, that templates are formed only
--   once, they have one instace in memory, but are referenced twice - from
--   composeds and from catalog map
ldtSubcompositesMap :: LocalizedTemplate -> LngTpl_SubCompositesMap
type DefaultLngTpl = LocalizedTemplate
type NondefaultLngTpl = LocalizedTemplate

-- | Carrying strict orientation routines. See description of
--   <a>StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets</a>.
compareStrictOrientationOnDefault :: PCLT_ID -> StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets -> NondefaultLngTpl -> DefaultLngTpl -> Bool
_compareStrictOrientationOnDefault :: PCLT_ID -> StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets -> ([PCLT_ID], [ParamName_LBS]) -> ([PCLT_ID], [ParamName_LBS]) -> Bool

-- | This is an extending wrapper around SDL. It is used for specification
--   of requirement for making representation from template. This
--   specification is attached to every localizable template in PCLT
--   catalog
data PCLT_ShowDetalizationLevel

-- | Plain SDL, nominal. If SDL of representation reciever is less then
--   that, then template cann't be used in representation generation.
PCLT_SDL :: ShowDetalizationLevel -> PCLT_ShowDetalizationLevel

-- | "The requirement is the same as is specified for referenced template".
PCLT_SDL_ToTemplateLink :: PCLT_ID -> PCLT_ShowDetalizationLevel

-- | "The requirement is the same as is specified a for referenced
--   template, which is referenced by a <tt>PCSI_PV</tt> value of
--   referenced parameter (of current template)".
PCLT_SDL_ToParamCompositeLink :: PCLT_ParamKey -> PCLT_ShowDetalizationLevel

-- | In input data for catalog formation the given specification is
--   errornous. If config's (<a>Text.PCLT.Config</a>) parameters
--   <a>pcsAllowEmptySDL_parseItByModusMargin</a> and/or
--   <a>pcsAllowUnreadableSDL_parseIdByModusMargin</a> are positive, then
--   instead of <tt>PCLT_SDL_Errornous</tt> the parser
--   (<a>str2PCLT_SDL</a>) will use <a>marginOfSDLModus</a> to set valid
--   specification. When representation generator meets
--   <tt>PCLT_SDL_Errornous</tt> it won't use template, and return an
--   error.
PCLT_SDL_Errornous :: PCLT_ErrornousSDL -> PCLT_ShowDetalizationLevel
type PCLT_RequiredShowDetalizationLevel = PCLT_ShowDetalizationLevel
type PCLT_AllocatedShowDetalizationLevel = PCLT_ShowDetalizationLevel

-- | Raw templates (both localizeds, and localizables). Input data for
--   catalog formation. Used by <tt>HasStaticRawPCLTs</tt> class (declared
--   in <a>Text.PCLT.HasStaticRawPCLTs</a>)
data PCLT_RawCatalogData
PCLT_RawCatalogData :: (Map PCLT_ID (Map LanguageName ByteString, PCLT_RequiredShowDetalizationLevel)) -> PCLT_RawCatalogData

-- | This is a bad result of parsing some <a>String</a> into
--   <a>PCLT_ShowDetalizationLevel</a>. The second argument is this bad
--   input.
data PCLT_ErrornousSDL
UnreadableSDL_ESDL :: SDLModus -> String -> PCLT_ErrornousSDL

-- | A constant currently set to 25. It is used in a parser
--   <a>str2PCLT_SDL</a>: if the input is errornous, this much symbols of
--   input are saved in <a>UnreadableSDL_ESDL</a>. If input is bigger, then
--   the saved trunc is tailed with "..."
__const_esdl_rawinputshowsize_inShowAsPCSI :: Int

-- | Parse <a>String</a> into <a>PCLT_ShowDetalizationLevel</a>. First of
--   all parser tries <a>strict_str2sdl</a>. Then, if failed, parser uses
--   following config entries:
--   
--   <ul>
--   <li><a>pcsParameterPlaceholderWrapper</a> - if prefix and postfix of
--   input is this (by default it is "@@|"), then it is parsed into
--   <a>PCLT_SDL_ToParamCompositeLink</a></li>
--   <li><a>pcsCompositePlaceholderWrapper</a> - if prefix and postfix of
--   input is this (by default it is "##|"), then it is parsed into
--   <a>PCLT_SDL_ToTemplateLink</a></li>
--   <li><a>pcsAllowEmptySDL_parseItByModusMargin</a> - if it is positive
--   and input is empty, then it gets parsed into (<tt>PCLT_SDL $
--   <a>marginOfSDLModus</a> modus</tt>), where modus is first argument;
--   esle, if parameter is negative and input is empty, it is parsed to
--   <a>PCLT_SDL_Errornous</a></li>
--   <li><a>pcsAllowUnreadableSDL_parseIdByModusMargin</a> - if it is
--   positive and input is unparsable, then it gets parsed into
--   <tt><a>PCLT_SDL</a> $ <a>marginOfSDLModus</a> modus</tt>, where modus
--   is first argument; esle, if parameter is negative and input is
--   unparsable, it is parsed to <a>PCLT_SDL_Errornous</a></li>
--   </ul>
str2PCLT_SDL :: SDLModus -> String -> PCLT_InnerConfig -> PCLT_ShowDetalizationLevel
data LocalizableTemplate
LocalizableTemplate :: Map LanguageName LocalizedTemplate -> PCLT_RequiredShowDetalizationLevel -> LocalizableTemplate
pcltLocalizationsMap :: LocalizableTemplate -> Map LanguageName LocalizedTemplate

-- | If SDL of representation reciever is less then that, then template
--   cann't be used in representation generation.
pcltRequiredSDL :: LocalizableTemplate -> PCLT_RequiredShowDetalizationLevel
instance Typeable LocalizableTemplate
instance Typeable PCLT_ErrornousSDL
instance Typeable PCLT_RawCatalogData
instance Typeable PCLT_ShowDetalizationLevel
instance Typeable LocalizedTemplate
instance Typeable PCLT_ParserLowLevelFailure
instance Typeable PCS_SpecificMarkings
instance Show LocalizableTemplate
instance Eq PCLT_ErrornousSDL
instance Show PCLT_ErrornousSDL
instance Show PCLT_RawCatalogData
instance Eq PCLT_ShowDetalizationLevel
instance Show PCLT_ShowDetalizationLevel
instance Show LocalizedTemplate
instance Show PCLT_ParserLowLevelFailure
instance Eq PCS_SpecificMarkings
instance Show PCS_SpecificMarkings

module Text.PCLT.Catalog
type PCLT_CatalogID = Int
data PCLT_Catalog
PCLT_Catalog :: PCLT_CatalogID -> PCLT_CatalogMap -> PCLT_InnerConfig -> PCLT_Catalog
pcltcCatalogID :: PCLT_Catalog -> PCLT_CatalogID
pcltcCatalogMap :: PCLT_Catalog -> PCLT_CatalogMap

-- | It is highly recommended not to change this param values after catalog
--   is formed, since it's easy to spoil catalog content that way.
pcltcInnerConfig :: PCLT_Catalog -> PCLT_InnerConfig
catInstMaxLen :: PCLT_Catalog -> Int64
catDfltLng :: PCLT_Catalog -> LanguageName
catStrictOrient :: PCLT_Catalog -> StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets
catSize :: PCLT_Catalog -> Int
data TplDefaultLngIsMissing_PCLTE
TplDefaultLngIsMissing_PCLTE :: PCLT_CompositeKey -> TplDefaultLngIsMissing_PCLTE
data DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_PCLTE
DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_PCLTE :: PCLT_CompositeKey -> LanguageName -> DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_PCLTE
data RequiredCompositeIsMissing_PCLTE
RequiredCompositeIsMissing_PCLTE :: RequiredCompositeKey -> RequiredCompositeIsMissing_PCLTE
data RequiredByRequirerCompositeIsMissing_PCLTE
RequiredByRequirerCompositeIsMissing_PCLTE :: RequirerCompositeKey -> RequiredCompositeIsMissing_PCLTE -> RequiredByRequirerCompositeIsMissing_PCLTE
data CompositionCycle_PCLTE
CompositionCycle_PCLTE :: PCLT_CompositeKey -> [PCLT_CompositeKey] -> CompositionCycle_PCLTE
data TplUniquenessViol_PCLTE
TplUniquenessViol_PCLTE :: PCLT_ID -> [LanguageName] -> TplUniquenessViol_PCLTE
type MainUnit_SDL = PCLT_ShowDetalizationLevel
type AddedUnit_SDL = PCLT_ShowDetalizationLevel
data DifferentSDLs_PCLTE
DifferentSDLs_PCLTE :: PCLT_ID -> (MainUnit_SDL, AddedUnit_SDL) -> DifferentSDLs_PCLTE
data ErrorWithPCSCatalog a
ErrorWithPCSCatalog :: PCLT_CatalogID -> a -> ErrorWithPCSCatalog a
instance Typeable1 ErrorWithPCSCatalog
instance Typeable DifferentSDLs_PCLTE
instance Typeable TplUniquenessViol_PCLTE
instance Typeable CompositionCycle_PCLTE
instance Typeable RequiredByRequirerCompositeIsMissing_PCLTE
instance Typeable RequiredCompositeIsMissing_PCLTE
instance Typeable DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_PCLTE
instance Typeable TplDefaultLngIsMissing_PCLTE
instance Typeable PCLT_Catalog
instance Show a => Show (ErrorWithPCSCatalog a)
instance Show DifferentSDLs_PCLTE
instance Show TplUniquenessViol_PCLTE
instance Show CompositionCycle_PCLTE
instance Show RequiredByRequirerCompositeIsMissing_PCLTE
instance Show RequiredCompositeIsMissing_PCLTE
instance Show DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_PCLTE
instance Show TplDefaultLngIsMissing_PCLTE
instance Show PCLT_Catalog


-- | A module around comlex function <a>_readPCLTCatalog</a>.
module Text.PCLT.MakeCatalog
type Parsed_DidWe = Bool

-- | Error type for <a>_readPCLTCatalog</a>.
--   
--   Descriptios for some value constructors:
--   
--   <ul>
--   
--   <li><a>DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_RPCSCE</a>:
--   For more information about this error see
--   <a>StrictOrient_ofParamsAndCmpsts_onDfltLngTplsSets</a></li>
--   <li><a>DifferentSDLs_RPCSCE</a>: This may occur in case when some
--   <a>PCLT_RawCatalogData</a> is added to a nonempty <a>PCLT_Catalog</a>,
--   and same templates in both places has different SDL requirements.</li>
--   <li><a>TplUniquenessViol_RPCSCE</a>: This may occur in case when some
--   <a>PCLT_RawCatalogData</a> is added to a nonempty <a>PCLT_Catalog</a>,
--   and there isan intersection between their {(Template ID, Language)}
--   sets.</li>
--   <li><a>SDL_ToCompositeLinkRefsToNonexistent_RPCSCE</a>: SDL
--   requirement specification (<a>pcltRequiredSDL</a>) for a template is
--   of type <a>PCLT_SDL_ToTemplateLink</a> and references to a template
--   which is not persistant in catalog or raw input data.</li>
--   </ul>
data ReadPCSCatalogError
CompositionCycle_RPCSCE :: CompositionCycle_PCLTE -> ReadPCSCatalogError
RequiredCompositeIsMissing_RPCSCE :: RequiredByRequirerCompositeIsMissing_PCLTE -> ReadPCSCatalogError
RequiredCompositeIsUnparsable_RPCSCE :: RequirerCompositeKey -> RequiredCompositeKey -> ReadPCSCatalogError
ParseFailedForDefaultLng_RPCSCE :: PCLT_CompositeKey -> Parsed_DidWe -> [PCLT_ParserLowLevelFailure] -> ReadPCSCatalogError
TplDefaultLngIsMissing_RPCSCE :: TplDefaultLngIsMissing_PCLTE -> ReadPCSCatalogError
ParseFailedForNondefaultLng_RPCSCE :: PCLT_CompositeKey -> Parsed_DidWe -> LanguageName -> [PCLT_ParserLowLevelFailure] -> ReadPCSCatalogError
DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_RPCSCE :: DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_PCLTE -> ReadPCSCatalogError
DifferentSDLs_RPCSCE :: DifferentSDLs_PCLTE -> ReadPCSCatalogError
TplUniquenessViol_RPCSCE :: TplUniquenessViol_PCLTE -> ReadPCSCatalogError
SDL_ToCompositeLinkRefsToNonexistent_RPCSCE :: RequirerCompositeKey -> RequiredCompositeKey -> ReadPCSCatalogError
DRL_NormalizationError_RPCSCE :: DRL_NormalizationError -> ReadPCSCatalogError

-- | Wrapper around <a>_readPCLTCatalog</a>. To be used when starting with
--   an empty catalog.
readPCLTCatalog :: PCLT_InnerConfig -> PCLT_CatalogID -> PCLT_RawCatalogData -> (PCLT_Catalog, [ErrorWithPCSCatalog ReadPCSCatalogError])

-- | Take a bunch of raw templates, parse them into normal templates and
--   add them to a catalog.
_readPCLTCatalog :: (PCLT_Catalog, [ReadPCSCatalogError]) -> PCLT_RawCatalogData -> (PCLT_Catalog, [ErrorWithPCSCatalog ReadPCSCatalogError])

-- | Error type for <a>normalizeReferentialSDLs</a>.
data DRL_NormalizationError
SDL_ToCompositeLinksCycle_DRLNE :: [PCLT_CompositeKey] -> DRL_NormalizationError
SDL_DetFail_ToCompositeLinkRefsToNonexistent_DRLNE :: RequirerCompositeKey -> RequiredCompositeKey -> DRL_NormalizationError

-- | Under "Referential SDLs normalization" here is understood the
--   following. Now consider paths like:
--   
--   <pre>
--   Tpl_1.<a>pcltRequiredSDL</a> -&gt; Tpl_2.<a>pcltRequiredSDL</a>
--   </pre>
--   
--   which means <a>pcltRequiredSDL</a> of <tt>Tpl_1</tt> is specified
--   (using <a>PCLT_SDL_ToTemplateLink</a>) to be the same as for
--   <tt>Tpl_2</tt>. Here we can reduce the <a>PCLT_SDL_ToTemplateLink</a>
--   of <tt>Tpl_1</tt> by assinging instead of it
--   <tt>Tpl_2.</tt><a>pcltRequiredSDL</a> value. Data consistency is
--   respected. We win in speed of <tt>Tpl_1.</tt><a>pcltRequiredSDL</a>
--   determination. The negative side of this, is that we can't change
--   <tt>Tpl_2.</tt><a>pcltRequiredSDL</a> anymore without spoiling data
--   consistency. That's another reason why a PCLT catalog is so hard to
--   modify. Perhaps the problem will be solved in future versions of PCLT.
--   
--   So this function reduces all <a>PCLT_SDL_ToTemplateLink</a>s in a
--   given <a>PCLT_CatalogMap</a>, BUT, only where they lead to
--   <a>PCLT_SDL</a>s or to other <a>PCLT_SDL_ToTemplateLink</a>s (which
--   recursively gets considered to be reduced), not when it leads to
--   <a>PCLT_SDL_ToParamCompositeLink</a> or <a>PCLT_SDL_Errornous</a>.
normalizeReferentialSDLs :: PCLT_CatalogMap -> (PCLT_CatalogMap, [DRL_NormalizationError])

-- | Error type for <a>adhoc_str2ldt</a>.
data AHSTR2LngTpl_Error
ParseFailure_AHS2PE :: [PCLT_ParserLowLevelFailure] -> AHSTR2LngTpl_Error
RequiredCompositeIsMissing_AHS2PE :: RequiredCompositeIsMissing_PCLTE -> AHSTR2LngTpl_Error

-- | Make a <a>LocalizedTemplate</a> out of a single <tt>ByteString</tt>.
adhoc_str2ldt :: (ByteString, LanguageName) -> PCLT_Catalog -> Either AHSTR2LngTpl_Error LocalizedTemplate

-- | Make a <a>LocalizableTemplate</a> out of a single <tt>ByteString</tt>.
str2pclt :: (PCLT_ID, PCLT_AllocatedShowDetalizationLevel) -> (LanguageName, ByteString) -> PCLT_Catalog -> Either (ErrorWithPCSCatalog ReadPCSCatalogError) LocalizableTemplate

-- | Make a <a>LocalizableTemplate</a> out of list of <tt>ByteString</tt>s.
str_list2pclt :: (PCLT_ID, PCLT_AllocatedShowDetalizationLevel) -> Map LanguageName ByteString -> PCLT_Catalog -> (LocalizableTemplate, [ErrorWithPCSCatalog ReadPCSCatalogError])
instance Typeable AHSTR2LngTpl_Error
instance Typeable DRL_NormalizationError
instance Typeable ReadPCSCatalogError
instance Show AHSTR2LngTpl_Error
instance Show DRL_NormalizationError
instance Show ReadPCSCatalogError


-- | Functions from this module isn't used for catalog formation. It's not
--   very wise to have two similar codes of catalog maths here and in
--   module <a>Text.PCLT.MakeCatalog</a>, since it raises double
--   maintenence problem. Perhaps the problem will be solved in future
--   versions.
--   
--   The math's errors, however, seems to be of use in other modules.
module Text.PCLT.CatalogMaths

-- | Error type for <a>addLngTpl_toPCLT</a>.
data AddLngTpl_toPCLT_Error
TplUniquenessViol_APSTPTE :: TplUniquenessViol_PCLTE -> AddLngTpl_toPCLT_Error
DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_APSTPTE :: DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_PCLTE -> AddLngTpl_toPCLT_Error

-- | Adds localized template as a special case of localizable template.
addLngTpl_toPCLT :: PCLT_ID -> (LanguageName, LocalizedTemplate) -> LocalizableTemplate -> PCLT_InnerConfig -> (LocalizableTemplate, [AddLngTpl_toPCLT_Error])

-- | Error type for <a>addPCLT_toPCLT</a>.
data AddPCLT_toPCLT_Error
AddLngTpl_toPCLT_Error_APTTPTE :: AddLngTpl_toPCLT_Error -> AddPCLT_toPCLT_Error
DifferentSDLs_APTTPTE :: DifferentSDLs_PCLTE -> AddPCLT_toPCLT_Error

-- | Adds up localizable templates, their localized cases.
addPCLT_toPCLT :: PCLT_ID -> LocalizableTemplate -> LocalizableTemplate -> PCLT_InnerConfig -> (LocalizableTemplate, [AddPCLT_toPCLT_Error])
instance Typeable AddPCLT_toPCLT_Error
instance Typeable AddLngTpl_toPCLT_Error
instance Show AddPCLT_toPCLT_Error
instance Show AddLngTpl_toPCLT_Error


-- | A way to store templates is by assigning them to types.
module Text.PCLT.HasStaticRawPCLTs
data RawPCLTsSetWideness
AlgebraicDataType_RPSW :: RawPCLTsSetWideness
Module_RPSW :: RawPCLTsSetWideness
Package_RPSW :: RawPCLTsSetWideness
System_RPSW :: RawPCLTsSetWideness
class HasStaticRawPCLTs t
getStaticRawPCLTs :: HasStaticRawPCLTs t => PCLT_InnerConfig -> t -> (PCLT_RawCatalogData, [AddPCLT_toPCLT_Error])
widenessOfStaticRawPCLTsSet :: HasStaticRawPCLTs t => t -> RawPCLTsSetWideness
mergeRawCatalogDataSets :: Bool -> [PCLT_RawCatalogData] -> (PCLT_RawCatalogData, [AddPCLT_toPCLT_Error])
mergeRawCatalogDataSets2 :: Bool -> [(PCLT_RawCatalogData, [AddPCLT_toPCLT_Error])] -> (PCLT_RawCatalogData, [AddPCLT_toPCLT_Error])
instance Typeable RawPCLTsSetWideness
instance Show RawPCLTsSetWideness


-- | The abbreviation "PCSI" means "Parametric Composable String
--   Instaniation". Agree, not a very clear name, a more apropriate would
--   be something like that: "Input Data for Template Representation", but
--   clear name came to my head when millions (dozens) of ants (variables)
--   were already bearing this name. And I'm a bit lazy to rename
--   everything to sound apropriate, sorry.
module Text.PCLT.PCSI

-- | By these user fills parameters of templates.
data PCLT_ParamVal
PlainText_PV :: String -> PCLT_ParamVal
PlainTextLBS_PV :: ByteString -> PCLT_ParamVal
PCSI_PV :: PCSI -> PCLT_ParamVal

-- | Second argument is a separator between <a>PCSI</a>s in first argument
--   Here representation generator automatically adds to each PCSI in list
--   an implicit parameter <tt>__row_idx</tt>, which holds a value of
--   current PCSI index in list, starting from 1.
PCSIList_PV :: [PCSI] -> PCLT_ParamVal -> PCLT_ParamVal
PVList_PV :: [PCLT_ParamVal] -> PCLT_ParamVal

-- | In message generation procedure this stands for a value of 2nd
--   argument in which every occurence of newline (as is configured in
--   <a>Text.PCLT.Config</a> in config's parameter <tt>pcsNewlineLBS</tt>)
--   is substituded by <tt>newline ++ (replicate n ' ')</tt>, where n is
--   the 1st argument
Indented_PV :: Int -> PCLT_ParamVal -> PCLT_ParamVal

-- | In message generation procedure this stands for a value of
--   <tt>pcsNewlineLBS</tt> parameter declared in <a>Text.PCLT.Config</a>.
--   Different systems means different symbol sequences under "newline"...
NewLine_PV :: PCLT_ParamVal
Nothing_PV :: PCLT_ParamVal
type PCSI_ParamsValuesMap = Map PCLT_ParamKey PCLT_ParamVal

-- | PCSI is an output of our extended Show (to which this package is
--   dedicated). And an input to generate a message using catalog.
data PCSI
PCSI :: PCLT_ID -> PCSI_ParamsValuesMap -> PCSI
pcsiTplID :: PCSI -> PCLT_ID
pcsiParamsValsMap :: PCSI -> PCSI_ParamsValuesMap

-- | PCSI with an empty set of parameters values.
empPCSI :: PCLT_ID -> PCSI
thePCSI :: PCLT_ID -> [(PCLT_ParamKey, PCLT_ParamVal)] -> PCSI
addToPCSI :: [PCSI] -> PCSI -> PCSI
sumPCSI_PVMs :: PCSI_ParamsValuesMap -> PCSI_ParamsValuesMap -> PCSI_ParamsValuesMap
addPVs2PCSI :: [(PCLT_ParamKey, PCLT_ParamVal)] -> PCSI -> PCSI

-- | It's used in some places of package in errors' representations (in
--   instances of <tt>ShowAsPCSI</tt> - class declared in
--   <a>Text.PCLT.ShowAsPCSI</a>). <tt>usualSeparatorInPCSIList = PVList_PV
--   [NewLine_PV, PlainText_PV <a>|----</a>, NewLine_PV]</tt>
usualSeparatorInPCSIList :: PCLT_ParamVal
instance Typeable PCSI
instance Typeable PCLT_ParamVal
instance Show PCSI
instance Show PCLT_ParamVal


-- | Module around <a>pcsi2text</a> function, which generates a message out
--   of <a>PCSI</a> and <a>PCLT_Catalog</a>.
module Text.PCLT.MakeMessage

-- | Error type for <a>pcsi2text</a>.
data PCSI2Text_Error
RequiredCompositeIsMissing_P2TE :: RequiredByRequirerCompositeIsMissing_PCLTE -> PCSI2Text_Error
RequiredCompositeLoclizationIsMissing_P2TE :: RequiredByRequirerCompositeIsMissing_PCLTE -> LanguageName -> PCSI2Text_Error
CompositionCycle_P2TE :: CompositionCycle_PCLTE -> PCSI2Text_Error
SDL_DeterminationFailure_P2TE :: PCLT_ID -> SDL_DeterminationFailure -> PCSI2Text_Error

-- | This error is possible only if program is wrong.
UnsupportedMarker_P2TE :: SeparatedSectorMarker -> ByteString -> PCLT_ID -> LanguageName -> PCSI2Text_Error
NoValueForParameter_P2TE :: PCLT_ID -> LanguageName -> PCLT_ParamKey -> PCSI2Text_Error

-- | Not used, reserved for future versions.
UnderAccordingParamReparsingFailure_P2TE :: PCLT_ID -> LanguageName -> PCLT_ParamKey -> ReadPCSCatalogError -> PCSI2Text_Error

-- | Not used, reserved for future versions.
ReparsingDepthMaxReached_P2TE :: PCLT_ID -> LanguageName -> PCLT_ParamKey -> ReparsingDepth -> PCSI2Text_Error

-- | Not used, reserved for future versions.
ReparsingLengthMaxReached_P2TE :: PCLT_ID -> LanguageName -> PCLT_ParamKey -> ForInstaniationUsedChunkLength -> PCSI2Text_Error

-- | No more free space in resulting <a>CLBS</a>.
InstaniationLengthMaxReached_P2TE :: PCLT_ID -> LanguageName -> ForInstaniationUsedChunkLength -> PCSI2Text_Error

-- | Error type for <a>givenSDL_statisfies</a>.
data SDL_DeterminationFailure
RequiredCompositeIsMissing_SDLDF :: RequiredByRequirerCompositeIsMissing_PCLTE -> SDL_DeterminationFailure

-- | The SDL of template is specified (using
--   <a>PCLT_SDL_ToParamCompositeLink</a>) to be the same as is one of a
--   template, that must have been put under a parameter (using
--   <a>PCSI_PV</a>), but referenced parameter is missing in given
--   <a>PCSI</a>
MissingParam_SDLByParamCompositeLink_SDLDF :: PCLT_CompositeKey -> PCLT_ParamKey -> SDL_DeterminationFailure

-- | The SDL of template is specified (using
--   <a>PCLT_SDL_ToParamCompositeLink</a>) to be the same as is one of a
--   template, that must have been put under a parameter (using
--   <a>PCSI_PV</a>), but referenced parameter value is constructed using
--   not <a>PCSI_PV</a>.
WrongParamType_SDLByParamCompositeLink_SDLDF :: PCLT_CompositeKey -> PCLT_ParamKey -> SDL_DeterminationFailure

-- | The SDL of template is specified (using
--   <a>PCLT_SDL_ToParamCompositeLink</a>) to be the same as is one of a
--   template, that must have been put under a parameter (using
--   <a>PCSI_PV</a>), but the <a>PCSI</a> under this parameter references
--   some unknown (to catalog) template.
UnknownComposite_SDLByParamCompositeLink_SDLDF :: PCLT_CompositeKey -> PCLT_ParamKey -> PCLT_CompositeKey -> SDL_DeterminationFailure
SDLReferentialCycle_SDLDF :: PCLT_CompositeKey -> [PCLT_ID] -> SDL_DeterminationFailure
ErrornousSDL_SDLDF :: PCLT_CompositeKey -> PCLT_ErrornousSDL -> SDL_DeterminationFailure

-- | Type of <a>PCSI2Text_Error</a>. Stripping arguments.
data PCSI2Text_Error_Type
RequiredCompositeIsMissing_P2TET :: PCSI2Text_Error_Type
RequiredCompositeLoclizationIsMissing_P2TET :: PCSI2Text_Error_Type
CompositionCycle_P2TET :: PCSI2Text_Error_Type
SDL_DeterminationFailure_P2TET :: SDL_DeterminationFailure_Type -> PCSI2Text_Error_Type
UnsupportedMarker_P2TET :: PCSI2Text_Error_Type
NoValueForParameter_P2TET :: PCSI2Text_Error_Type
UnderAccordingParamReparsingFailure_P2TET :: PCSI2Text_Error_Type
ReparsingDepthMaxReached_P2TET :: PCSI2Text_Error_Type
ReparsingLengthMaxReached_P2TET :: PCSI2Text_Error_Type
InstaniationLengthMaxReached_P2TET :: PCSI2Text_Error_Type

-- | Type of <a>SDL_DeterminationFailure</a>. Stripping arguments.
data SDL_DeterminationFailure_Type
RequiredCompositeIsMissing_SDLDFT :: SDL_DeterminationFailure_Type
MissingParam_SDLByParamCompositeLink_SDLDFT :: SDL_DeterminationFailure_Type
WrongParamType_SDLByParamCompositeLink_SDLDFT :: SDL_DeterminationFailure_Type
UnknownComposite_SDLByParamCompositeLink_SDLDFT :: SDL_DeterminationFailure_Type
SDLReferentialCycle_SDLDFT :: SDL_DeterminationFailure_Type
ErrornousSDL_SDLDFT :: SDL_DeterminationFailure_Type
p2teType :: PCSI2Text_Error -> PCSI2Text_Error_Type
sdldfType :: SDL_DeterminationFailure -> SDL_DeterminationFailure_Type

-- | Template representation generation errors types abbreviations:
--   
--   <pre>
--   RequiredCompositeIsMissing_P2TET            -&gt; "CM"
--   RequiredCompositeLoclizationIsMissing_P2TET -&gt; "CLM"
--   CompositionCycle_P2TET                      -&gt; "CC"
--   SDL_DeterminationFailure_P2TET       sdldft -&gt; "SF" ++
--       case sdldft of
--           RequiredCompositeIsMissing_SDLDFT               -&gt; "(CM)"
--           MissingParam_SDLByParamCompositeLink_SDLDFT     -&gt; "(LMP)"
--           WrongParamType_SDLByParamCompositeLink_SDLDFT   -&gt; "(LWPT)"
--           UnknownComposite_SDLByParamCompositeLink_SDLDFT -&gt; "(LUC)"
--           SDLReferentialCycle_SDLDFT                      -&gt; "(CC)"
--           ErrornousSDL_SDLDFT                             -&gt; "(ES)"
--   UnsupportedMarker_P2TET                     -&gt; "UM"
--   NoValueForParameter_P2TET                   -&gt; "NV"
--   UnderAccordingParamReparsingFailure_P2TET   -&gt; "RF"
--   ReparsingDepthMaxReached_P2TET              -&gt; "RDM"
--   ReparsingLengthMaxReached_P2TET             -&gt; "RLM"
--   InstaniationLengthMaxReached_P2TET          -&gt; "ILM"
--   </pre>
shortOf_PCSI2Text_Error :: PCSI2Text_Error -> ByteString

-- | Whenever representation generator can't make representation for a
--   template due to some error, it puts there (instead of representation)
--   an error marking (<a>pcsMarkingErrorPlaceholderWrapper</a>) with an
--   abbreviation (see <a>shortOf_PCSI2Text_Error</a>) of error type and
--   template ID.
includeAsAnError :: PCLT_InnerConfig -> PCSI2Text_Error -> String -> (ByteString, ForInstaniationUsedChunkLength)

-- | A test, if a given reciever's detalization level is enough to
--   represent a given <a>PCSI</a>.
givenSDL_statisfies :: ShowDetalizationLevel -> PCSI -> PCLT_ShowDetalizationLevel -> PCLT_CatalogMap -> Either SDL_DeterminationFailure Bool
type SpaceAvailableForPCSIInstaniation = MarkedChunkLength
type ForInstaniationUsedChunkLength = MarkedChunkLength

-- | Wrapper around <a>pcsi2text</a> for cases, when new <a>CLBS</a> for
--   output is to be created. It's maximal length is set to be same as
--   configured in parameter <a>pcsInstaniationResultMaxSize</a>
pcsi2new_text :: PCSI -> (ShowDetalizationLevel, LanguageName) -> PCLT_Catalog -> (StdOut_CLBS, [ErrorWithPCSCatalog PCSI2Text_Error])

-- | Make a representation out of <a>PCSI</a> in specified detailization
--   level, in specified language, using specified catalog. And append
--   result to a specified <a>CLBS</a>.
pcsi2text :: StdOut_CLBS -> PCSI -> (ShowDetalizationLevel, LanguageName) -> PCLT_Catalog -> (StdOut_CLBS, [ErrorWithPCSCatalog PCSI2Text_Error])
instance Typeable SDL_DeterminationFailure
instance Typeable PCSI2Text_Error
instance Show SDL_DeterminationFailure
instance Show PCSI2Text_Error


-- | WARNING: Creating an instance of <a>ShowAsPCSI</a> for <a>String</a>,
--   <tt>ByteString</tt>s and/or other text types is not recommended. Use
--   of such instaniations would dread strictness of templates catalog
--   structure - make it's use workaroundish, less systematic and less
--   strict, which is a way to badmade applications.
module Text.PCLT.ShowAsPCSI

-- | Our extended version of <tt>Show</tt> class
class ShowAsPCSI t
showAsPCSI :: ShowAsPCSI t => t -> PCSI


-- | This is a usual set for modules, that are to be imported by modules
--   dedicated to declaring <a>ShowAsPCSI</a> and <a>HasStaticRawPCLTs</a>
--   instances
module Text.PCLT.SH__


-- | Addition to <a>Text.PCLT.MakeMessage</a> module. Some wrappers around
--   <a>pcsi2text</a> function.
module Text.PCLT.MakeMessage2

-- | Wrapper around <a>pcsi2text_plus_errs_1</a> for cases, when new
--   <a>CLBS</a> is to be created. It's maximal length is set to be same as
--   configured in parameter <a>pcsInstaniationResultMaxSize</a>
pcsi2new_text_plus_errs_1 :: PCSI -> (ShowDetalizationLevel, LanguageName) -> PCLT_Catalog -> StdOutAndErr_CLBS

-- | <ol>
--   <li>generates message from given PCSI</li>
--   <li>generates representation of errors list (that occurred, when doing
--   step (1))</li>
--   <li>generates representation of errors list (that occurred, when doing
--   step (2))</li>
--   <li>appends text result of step (3) to given CLBS</li>
--   <li>appends text result of step (2) to given CLBS</li>
--   <li>appends text result of step (1) to given CLBS</li>
--   </ol>
pcsi2text_plus_errs_1 :: StdOutAndErr_CLBS -> PCSI -> (ShowDetalizationLevel, LanguageName) -> PCLT_Catalog -> StdOutAndErr_CLBS

-- | Wrapper around <a>pcsi2text_plus_errs_2</a> for cases, when new
--   <a>CLBS</a>s are to be created:
--   
--   <ul>
--   <li>One - for representation of normal output. It's maximal length is
--   set to be same as configured in parameter
--   <a>pcsInstaniationResultMaxSize</a></li>
--   <li>Another - for representation of errors. It's maximal size is
--   specified in the first argument of function.</li>
--   </ul>
pcsi2new_text_plus_errs_2 :: Int64 -> PCSI -> (ShowDetalizationLevel, LanguageName) -> PCLT_Catalog -> (StdOut_CLBS, StdErr_CLBS)

-- | <ol>
--   <li>generates message from given PCSI</li>
--   <li>appends text result of step (1) to given CLBS_1</li>
--   <li>generates representation of errors list (that occurred, when doing
--   step (1))</li>
--   <li>generates representation of errors list (that occurred, when doing
--   step (3))</li>
--   <li>appends text result of step (4) to given CLBS_2</li>
--   <li>appends text result of step (3) to given CLBS_2</li>
--   </ol>
pcsi2text_plus_errs_2 :: (StdOut_CLBS, StdErr_CLBS) -> PCSI -> (ShowDetalizationLevel, LanguageName) -> PCLT_Catalog -> (StdOut_CLBS, StdErr_CLBS)


-- | Tools to use <a>HasStaticRawPCLTs</a> class instances in order to
--   build up a catalog. ("FromHSRT" in module name means <a>from a given
--   instance of HasStaticRawPCLTs class</a>)
module Text.PCLT.CatalogFromHSRT
data CatalogFromHSRTInitErrors
CatalogFromHSRTInitErrors :: PCLT_CatalogID -> [ErrorWithPCSCatalog ReadPCSCatalogError] -> [AddPCLT_toPCLT_Error] -> CatalogFromHSRTInitErrors
cfhieCatalogID :: CatalogFromHSRTInitErrors -> PCLT_CatalogID
cfhieCatReadErrs :: CatalogFromHSRTInitErrors -> [ErrorWithPCSCatalog ReadPCSCatalogError]
cfhieCollectionErrs :: CatalogFromHSRTInitErrors -> [AddPCLT_toPCLT_Error]
defaultCatalogFromHSRTInitErrors :: PCLT_CatalogID -> CatalogFromHSRTInitErrors
initCatalogFromHSRT :: HasStaticRawPCLTs a => a -> PCLT_InnerConfig -> PCLT_CatalogID -> (PCLT_Catalog, CatalogFromHSRTInitErrors)

-- | A wrapper around <a>initCatalogFromHSRT</a> function. For case, when
--   all errors are to be represented at once.
initCatalogFromHSRT_2 :: HasStaticRawPCLTs a => a -> PCLT_InnerConfig -> PCLT_CatalogID -> (StdErr_CLBS, ShowDetalizationLevel, LanguageName) -> (PCLT_Catalog, StdErr_CLBS)
addFromHSRTToCatalog :: HasStaticRawPCLTs a => a -> PCLT_Catalog -> (PCLT_Catalog, CatalogFromHSRTInitErrors)

-- | A wrapper around <a>addFromHSRTToCatalog</a> function. For case, when
--   all errors are to be represented at once.
addFromHSRTToCatalog_2 :: HasStaticRawPCLTs a => a -> PCLT_Catalog -> (StdErr_CLBS, ShowDetalizationLevel, LanguageName) -> (PCLT_Catalog, StdErr_CLBS)
instance Typeable CatalogFromHSRTInitErrors
instance Show CatalogFromHSRTInitErrors
instance ShowAsPCSI CatalogFromHSRTInitErrors

module Text.PCLT.InitialDefaultCatalog

-- | This type is a special instance of <a>HasStaticRawPCLTs</a> - it
--   accumulates all other instances of <a>HasStaticRawPCLTs</a> from the
--   whole PCLT package
data PCLTRawCatalog__Text_PCLT_InitialDefaultCatalog
PCLTRawCatalog__Text_PCLT_InitialDefaultCatalog :: PCLTRawCatalog__Text_PCLT_InitialDefaultCatalog
initDefaultCatalog :: PCLT_InnerConfig -> PCLT_CatalogID -> (PCLT_Catalog, CatalogFromHSRTInitErrors)
initDefaultCatalog_2 :: PCLT_InnerConfig -> PCLT_CatalogID -> (StdErr_CLBS, ShowDetalizationLevel, LanguageName) -> (PCLT_Catalog, StdErr_CLBS)
initDefaultCatalog_3 :: PCLT_CatalogID -> (StdErr_CLBS, ShowDetalizationLevel, LanguageName) -> (PCLT_Catalog, StdErr_CLBS)
instance HasStaticRawPCLTs PCLTRawCatalog__Text_PCLT_InitialDefaultCatalog


-- | This is thought to be imported outside of PCLT package by modules,
--   that use PCLT logics (catalog formation routines and messages
--   generation routines)
--   
--   And another briefing on what is PCLT. First is in the top level of
--   Haddock documentation provided for the package.
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.SH__"
--   </pre>
--   
--   This module provides interfaces to the classes <a>ShowAsPCSI</a> and
--   <a>HasStaticRawPCLTs</a> an all the routines, that usually are used
--   for declaration of their instanitations.
--   
--   _______________
--   
--   <pre>
--   export "Text.ConstraintedLBS"
--   </pre>
--   
--   A constrainting (the constraint here is on it's size) wrapper for a
--   lazy <tt>ByteString</tt> (LBS) - this container is used for messages
--   generated from PCLT templates
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.InitialDefaultCatalog"
--   </pre>
--   
--   <pre>
--   initDefaultCatalog_3 :: Text.PCLT.Catalog.PCLT_CatalogID -&gt; (StdErr_CLBS, ShowDetalizationLevel, LanguageName) -&gt; (PCLT_Catalog, StdErr_CLBS)
--   </pre>
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.Catalog"
--   </pre>
--   
--   Catalog is a unit with 3 fields: catalog ID, config, and a map by
--   template_IDs of templates, where each template is: minimal SDL
--   required to represent message from this template, and a maps by
--   languages of localized templates.
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.CatalogFromHSRT"
--   </pre>
--   
--   We want to add to the default catalog some our application specific
--   entries (templates)
--   
--   <pre>
--   addFromHSRTToCatalog_2 :: HasStaticRawPCLTs a =&gt; a -&gt; PCLT_Catalog -&gt; (StdErr_CLBS, ShowDetalizationLevel, LanguageName) -&gt; (PCLT_Catalog, StdErr_CLBS)
--   </pre>
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.CommonTypes"
--   </pre>
--   
--   Some type aliases, like <tt><a>LanguageName</a> = <a>String</a></tt>
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.Config"
--   </pre>
--   
--   Configuration that influences the behaviour of catalog formation
--   routines and messages generation routines.
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.MakeMessage"
--   </pre>
--   
--   PCSI(template_id + params) + language_name + recepient_SDL + catalog
--   &gt;---(Text.PCLT.MakeMessage)---&gt; message
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.MakeMessage2"
--   </pre>
--   
--   Some comfort wrappers for <a>Text.PCLT.MakeMessage</a>
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.SDL"
--   </pre>
--   
--   SDL (Show Detalization Level) is a 1-dimensional variable type, built
--   on Int, but extended with additional values:
--   
--   <tt>Zero_SDL</tt> (absolute minimal level) <tt>&lt; One_SDL</tt>
--   (minimal something) <tt>&lt; SDL Int &lt; InfinitelyBig_SDL</tt>
--   
--   With SDL we regulate, how much some Reader (of our generated messages)
--   wishes (is allowed) to see.
--   
--   _______________
--   
--   <pre>
--   export "Text.PCLT.ShowAsPCSI__"
--   </pre>
--   
--   Some general instances of <a>ShowAsPCSI</a> class are to be found here
--   (Bool, ShowAsPCSI a =&gt; Maybe a, SomeException)
module Text.PCLT
data SeparatedSectorMarker_PCSIWrapped
SeparatedSectorMarker_PCSIWrapped :: SeparatedSectorMarker -> SeparatedSectorMarker_PCSIWrapped
data StandartMarkingStrategyError_PCSIWrapped
StandartMarkingStrategyError_PCSIWrapped :: StandartMarkingStrategyError -> StandartMarkingStrategyError_PCSIWrapped
data PCLTRawCatalog__Text_PCLT_ShowAsPCSI_GeneralCommons
PCLTRawCatalog__Text_PCLT_ShowAsPCSI_GeneralCommons :: PCLTRawCatalog__Text_PCLT_ShowAsPCSI_GeneralCommons
data PCLTRawCatalog__Text_PCLT_ShowAsPCSI
PCLTRawCatalog__Text_PCLT_ShowAsPCSI :: PCLTRawCatalog__Text_PCLT_ShowAsPCSI
