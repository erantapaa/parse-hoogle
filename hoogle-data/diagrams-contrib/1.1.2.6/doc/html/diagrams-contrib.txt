-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Collection of user contributions to diagrams EDSL
--   
@package diagrams-contrib
@version 1.1.2.6

module Diagrams.TwoD.Path.Metafont.Types

-- | A <tt>PathJoin</tt> specifies the directions at both ends of a
--   segment, and a join which describes the control points explicitly or
--   implicitly.
data PathJoin d j
PJ :: d -> j -> d -> PathJoin d j
_d1 :: PathJoin d j -> d
_j :: PathJoin d j -> j
_d2 :: PathJoin d j -> d
j :: Lens (PathJoin d_aa3B j_aa3C) (PathJoin d_aa3B j_acke) j_aa3C j_acke
d2 :: Lens' (PathJoin d_aa3B j_aa3C) d_aa3B
d1 :: Lens' (PathJoin d_aa3B j_aa3C) d_aa3B

-- | A direction can be specified at any point of a path. A <i>curl</i>
--   should only be specified at the endpoints. The endpoints default to
--   curl 1 if not set.
data PathDir
PathDirCurl :: Curl -> PathDir
PathDirDir :: Dir -> PathDir

-- | A predicate to determine the constructor used.
isCurl :: PathDir -> Bool
type Curl = Double
type Dir = R2
type BasicJoin = Either TensionJoin ControlJoin

-- | Higher <i>Tension</i> brings the path closer to a straight line
--   between segments. Equivalently, it brings the control points closer to
--   the endpoints. <tt>TensionAmt</tt> introduces a fixed tension.
--   <tt>TensionAtLeast</tt> introduces a tension which will be increased
--   if by so doing, an inflection point can be eliminated.
data Tension
TensionAmt :: Double -> Tension
TensionAtLeast :: Double -> Tension
getTension :: Tension -> Double

-- | Two tensions and two directions completely determine the control
--   points of a segment.
data TensionJoin
TJ :: Tension -> Tension -> TensionJoin
_t1 :: TensionJoin -> Tension
_t2 :: TensionJoin -> Tension

-- | The two intermediate control points of a segment, specified directly.
data ControlJoin
CJ :: P2 -> P2 -> ControlJoin
_c1 :: ControlJoin -> P2
_c2 :: ControlJoin -> P2
t2 :: Lens' TensionJoin Tension
t1 :: Lens' TensionJoin Tension
c2 :: Lens' ControlJoin P2
c1 :: Lens' ControlJoin P2
data P
data J

-- | <tt>MFPathData</tt> is the type manipulated by the metafont
--   combinators.
data MFPathData a
MFPathCycle :: MFPathData P
MFPathEnd :: P2 -> MFPathData P
MFPathPt :: P2 -> MFPathData J -> MFPathData P
MFPathJoin :: PathJoin (Maybe PathDir) (Maybe BasicJoin) -> MFPathData P -> MFPathData J

-- | <tt>MetafontSegment</tt> is used internally in solving the metafont
--   equations. It represents a segment with two known endpoints, and a
--   <i>join</i>, which may be specified in various ways.
data MetafontSegment d j
MFS :: P2 -> (PathJoin d j) -> P2 -> MetafontSegment d j
_x1 :: MetafontSegment d j -> P2
_pj :: MetafontSegment d j -> (PathJoin d j)
_x2 :: MetafontSegment d j -> P2

-- | <tt>MFPath</tt> is the type used internally in solving the metafont
--   equations. The direction and join types are progressively refined
--   until all control points are known. The <tt>loop</tt> flag affects
--   both the equations to be solved and the type of <tt>Trail</tt> in the
--   result. If constructing an <tt>MFPath</tt> in new code, the
--   responsibility rests on the user to ensure that successive
--   <tt>MetafontSegment</tt>s share an endpoint. If this is not true, the
--   result is undefined.
data MFPath d j
MFP :: Bool -> [MetafontSegment d j] -> MFPath d j
_loop :: MFPath d j -> Bool
_segs :: MFPath d j -> [MetafontSegment d j]

-- | MFP is a type synonym to clarify signatures in Metafont.Internal. Note
--   that the type permits segments which are "overspecified", having one
--   or both directions specified, and also a <a>ControlJoin</a>. In this
--   case, <a>Metafont.Internal</a> ignores the directions.
type MFP = MFPath (Maybe PathDir) BasicJoin

-- | MFS is a type synonym to clarify signatures in
--   <a>Metafont.Internal</a>.
type MFS = MetafontSegment (Maybe PathDir) BasicJoin
x2 :: Lens' (MetafontSegment d_acs0 j_acs1) P2
x1 :: Lens' (MetafontSegment d_acs0 j_acs1) P2
pj :: Lens (MetafontSegment d_acs0 j_acs1) (MetafontSegment d_acJh j_acJi) (PathJoin d_acs0 j_acs1) (PathJoin d_acJh j_acJi)
segs :: Lens (MFPath d_acrY j_acrZ) (MFPath d_acLk j_acLl) [MetafontSegment d_acrY j_acrZ] [MetafontSegment d_acLk j_acLl]
loop :: Lens' (MFPath d_acrY j_acrZ) Bool
instance Semigroup (PathJoin (Maybe PathDir) (Maybe BasicJoin))
instance Monoid (PathJoin (Maybe PathDir) (Maybe BasicJoin))
instance Functor (MetafontSegment d)
instance (Show d, Show j) => Show (MetafontSegment d j)
instance (Show d, Show j) => Show (MFPath d j)
instance Show PathDir
instance Show Tension
instance Show TensionJoin
instance Show ControlJoin
instance Functor (PathJoin d)
instance (Show d, Show j) => Show (PathJoin d j)


-- | Solve equations due to John Hobby, as implemented in Donald Knuth's
--   <i>Metafont</i>, to create (usually) smooth paths from specified
--   points and directions.
module Diagrams.TwoD.Path.Metafont.Internal

-- | Run all the rules required to fully specify all segment directions,
--   but do not replace the Joins with ControlJoin.
solve :: MFP -> MFPath Dir BasicJoin

-- | Take a segment whose endpoint directions have been fully determined,
--   and compute the control points to realize it as a cubic Bézier
--   segment. If the segment already has control points specified, the
--   directions are ignored (they are assumed to match). If the segment
--   tensions are specified as TensionAtLeast, check whether the minimum
--   tension will lead to an inflection point. If so, pick the maximum
--   velocity (equivalent to minimum tension) that avoids the inflection
--   point. Otherwise, calculate the velocity from the tension using
--   <a>hobbyF</a>. Then calculate the control point positions from the
--   direction and the velocity. Afterwards we can forget the direction
--   information (since the control points are what we really want, and the
--   directions can be recovered by subtracting the control points from the
--   endpoints anyway).
computeControls :: MetafontSegment Dir (Either TensionJoin ControlJoin) -> MetafontSegment () ControlJoin

-- | Convert a MetaFont path to a Diagrams Trail, using a Loop or Line as
--   needed
locatedTrail :: MFPath () ControlJoin -> Located (Trail R2)

-- | Convert a path in combinator syntax to the internal representation
--   used for solving.
mfPathToSegments :: MFPathData P -> MFP

module Diagrams.TwoD.Path.Metafont.Parser

-- | Parse a <tt>Text</tt> value in Metafont syntax, as destribed in /The
--   METAFONTbook/.
metafontParser :: Parser (MFPath (Maybe PathDir) BasicJoin)


-- | Combinators to allow writing Metafont-style paths embedded in Haskell,
--   with the usual Diagrams types for points and directions.
module Diagrams.TwoD.Path.Metafont.Combinators

-- | <i>point</i> <tt>.-</tt> <i>join</i> <tt>-.</tt> <i>path</i> adds
--   <i>point</i> to the left end of the metafont <i>path</i>, connected by
--   <i>join</i>.
(.-) :: P2 -> MFPathData J -> MFPathData P

-- | See <tt>.-</tt> above.
(-.) :: Join -> MFPathData P -> MFPathData J

-- | Add a point to the left of a Metafont path using a simple join. That
--   is, neither direction is specified, and both tensions are 1.
(.--.) :: P2 -> MFPathData P -> MFPathData P

-- | Terminate the right-end of a Metafont path at the given point.
endpt :: P2 -> MFPathData P

-- | Wrap the right-end of the Metafont path back to the left-end. When
--   converted to a Diagrams <a>Trail'</a>, this will be a Loop.
cyclePath :: MFPathData P

-- | simpleJoin is the same as mempty, with a more specific type. It is
--   provided for convenience in situations where explicit type signatures
--   would otherwise be needed, such as when building up a join using
--   lenses.
simpleJoin :: Join

-- | A join with both tensions the same.
tension :: Double -> Join

-- | A join with two tension values.
tensions :: Double -> Double -> Join

-- | A join with explicit control points. Note that these are in the same
--   coordinate system as the endpoints, not relative to the latter.
controls :: P2 -> P2 -> Join

-- | A join with the left-end direction specified.
leaving :: R2 -> Join

-- | A join with the right-end direction specified.
arriving :: R2 -> Join


-- | Define Diagrams Paths by specifying points and optionally directions
--   and tension. Calculate control points to maintain smooth curvature at
--   each point, following rules implemented in Donald Knuth's
--   <i>Metafont</i>.
--   
--   This module is intended to be imported qualified.
module Diagrams.TwoD.Path.Metafont

-- | MF.fromString parses a Text value in MetaFont syntax, and attempts to
--   return a TrailLike. Only a subset of Metafont is supported; see the
--   tutorial for details.
fromString :: (TrailLike t, V t ~ R2) => Text -> Either ParseError t

-- | fromStrings takes a list of MetaFont strings, and returns either all
--   errors, or, if there are no parsing errors, a TrailLike for each
--   string. fromStrings is provided as a convenience because the MetaFont
--   &amp;-join is not supported. <a>mconcat</a> (<a>&lt;&gt;</a>) on the
--   TrailLike is equivalent, with clearer semantics.
fromStrings :: (TrailLike t, V t ~ R2) => [Text] -> Either [ParseError] [t]

-- | Should you wish to construct the MFPath in some other fashion,
--   fromPath makes a TrailLike directly from the MFPath
fromPath :: (TrailLike t, V t ~ R2) => MFP -> t

-- | flex ps draws a Trail through the points ps, such that at every point
--   p ∊ ps except the endpoints, the Trail is parallel to the line from
--   the first to the last point. This is the same as the flex command
--   defined in plain MetaFont.
flex :: (TrailLike t, V t ~ R2) => [P2] -> t

-- | metafont converts a path defined in the Metafont combinator synax into
--   a native Diagrams TrailLike.
metafont :: (TrailLike t, V t ~ R2) => MFPathData P -> t

-- | Parse a <tt>Text</tt> value in Metafont syntax, as destribed in /The
--   METAFONTbook/.
metafontParser :: Parser (MFPath (Maybe PathDir) BasicJoin)


-- | Authors : Michael Sloan <a>at gmail</a>, Deepak Jois
--   <a>deepak.jois@gmail.com</a>
--   
--   A module consisting of core types and functions to represent and
--   operate on a "turtle".
--   
--   More info about turtle graphics:
--   <a>http://en.wikipedia.org/wiki/Turtle_graphics</a>
module Diagrams.TwoD.Path.Turtle.Internal

-- | Core turtle data type. A turtle needs to keep track of its current
--   position, like its position, heading etc., and all the paths that it
--   has traversed so far.
--   
--   We need to record a new path, everytime an attribute like style, pen
--   position etc changes, so that we can separately track styles for each
--   portion of the eventual path that the turtle took.
data TurtleState
TurtleState :: Bool -> P2 -> Angle -> Located (Trail' Line R2) -> PenStyle -> [TurtlePath] -> TurtleState

-- | State of the pen. <tt>False</tt> means that turtle movements will not
--   draw anything
isPenDown :: TurtleState -> Bool

-- | Current position. This is updated everytime the turtle moves
penPos :: TurtleState -> P2

-- | Orientation of the turtle in 2D space, given in degrees
heading :: TurtleState -> Angle

-- | Path traversed by the turtle so far, without any style or pen
--   attributes changing
currTrail :: TurtleState -> Located (Trail' Line R2)

-- | Current style of the pen
currPenStyle :: TurtleState -> PenStyle

-- | List of paths along with style information, traversed by the turtle
--   previously
paths :: TurtleState -> [TurtlePath]

-- | Turtle path type that captures a list of paths and the style
--   attributes associated with them
data TurtlePath
TurtlePath :: PenStyle -> Located (Trail R2) -> TurtlePath

-- | Style
penStyle :: TurtlePath -> PenStyle

-- | Path
turtleTrail :: TurtlePath -> Located (Trail R2)

-- | Style attributes associated with the turtle pen
data PenStyle
PenStyle :: Double -> Colour Double -> PenStyle

-- | Width of pen. Default is 1.0
penWidth :: PenStyle -> Double

-- | Color of pen. Default is <tt>black</tt>
penColor :: PenStyle -> Colour Double

-- | Move the turtle forward by <tt>x</tt> units
forward :: Double -> TurtleState -> TurtleState

-- | Move the turtle backward by <tt>x</tt> units
backward :: Double -> TurtleState -> TurtleState

-- | Turn the turtle anti-clockwise (left)
left :: Double -> TurtleState -> TurtleState

-- | Turn the turtle clockwise (right)
right :: Double -> TurtleState -> TurtleState

-- | alias of <tt>setPenColour</tt>
setPenColor :: Colour Double -> TurtleState -> TurtleState

-- | Set a new pen color for turtle.
--   
--   If pen is down, this adds the current trail to <tt>paths</tt> and
--   starts a new empty trail.
setPenColour :: Colour Double -> TurtleState -> TurtleState

-- | Set a new pen width for turtle.
--   
--   If pen is down, this adds the current trail to <tt>paths</tt> and
--   starts a new empty trail.
setPenWidth :: Double -> TurtleState -> TurtleState

-- | The initial state of turtle. The turtle is located at the origin, at
--   an orientation of 0 degrees with its pen position down. The pen style
--   is <tt>defaultPenStyle</tt>.
startTurtle :: TurtleState

-- | Turn the turtle to the given orientation, in degrees
setHeading :: Double -> TurtleState -> TurtleState

-- | Sets the turtle orientation towards a given location.
towards :: P2 -> TurtleState -> TurtleState

-- | Set the turtle X/Y position.
--   
--   If pen is down and the current trail is non-empty, this will also add
--   the current trail to the <tt>paths</tt> field.
setPenPos :: P2 -> TurtleState -> TurtleState

-- | Puts the turtle pen in “Up” mode. Turtle movements will not draw
--   anything
--   
--   Does nothing if the pen was already up. Otherwise, it creates a turtle
--   with the current trail added to <tt>paths</tt>.
penUp :: TurtleState -> TurtleState

-- | Puts the turtle pen in “Down” mode. Turtle movements will cause
--   drawing to happen
--   
--   Does nothing if the pen was already down. Otherwise, starts a new
--   trail starting at the current position.
penDown :: TurtleState -> TurtleState
penHop :: TurtleState -> TurtleState
closeCurrent :: TurtleState -> TurtleState

-- | Prints out turtle representation and returns it. Use for debugging
traceTurtle :: TurtleState -> TurtleState

-- | Creates a diagram from a turtle
--   
--   Applies the styles to each trails in <tt>paths</tt> separately and
--   combines them into a single diagram
getTurtleDiagram :: Renderable (Path R2) b => TurtleState -> Diagram b R2

-- | Creates a path from a turtle, ignoring the styles.
getTurtlePath :: TurtleState -> Path R2
instance Show PenStyle
instance Show TurtlePath
instance Show TurtleState


-- | Generate fractal trails by the "iterated subset" construction,
--   iteratively replacing each segment with a given pattern.
module Diagrams.TwoD.Path.IteratedSubset

-- | Given a "seed pattern", produce a list of successive refinements,
--   where the nth trail in the list has iteratively had all segments
--   replaced by the seed pattern n times, starting from a horizontal line.
--   In other words, the zeroth trail in the output list is a horizontal
--   unit segment, and each subsequent trail is equal to the previous with
--   all segments replaced by the seed pattern.
--   
--   <pre>
--   import Diagrams.TwoD.Path.IteratedSubset
--   iterTrailEx = vcat' (with &amp; sep .~ 0.3) . map strokeLine . take 5
--               $ iterTrail koch
--   </pre>
--   
iterTrail :: Trail' Line R2 -> [Trail' Line R2]

-- | Use a trail to "refine" a segment, returning a scaled and/or rotated
--   copy of the trail with the same endpoint as the segment.
refineSegment :: Trail' Line R2 -> Segment Closed R2 -> Maybe (Trail' Line R2)

-- | Seed for the Koch curve (side of the famous Koch <a>snowflake</a>).
--   
koch :: (TrailLike t, V t ~ R2) => t

-- | Seed for the Lévy dragon curve.
--   
levy :: (TrailLike t, V t ~ R2) => t

-- | Strange zig-zag seed that produces a dense fractal path with lots of
--   triangles.
--   
zag :: (TrailLike t, V t ~ R2) => t

-- | A "square impulse" seed which produces a quadratic von Koch curve.
--   
sqUp :: (TrailLike t, V t ~ R2) => t

-- | A "double square impulse" seed which produces fantastic rectilinear
--   spiral patterns.
--   
sqUpDown :: (TrailLike t, V t ~ R2) => t

-- | Like <a>sqUpDown</a> but with <a>cubicSpline</a> applied to produce a
--   curvy version.
--   
sqUpDown' :: (TrailLike t, V t ~ R2) => t

-- | The famous Koch snowflake, made by putting three Koch curves together.
--   <tt>snowflake n</tt> yields an order-<tt>n</tt> snowflake.
--   
snowflake :: Int -> Trail R2

-- | A cool diagram featuring successive iterations of <tt>sqUpDown'</tt>
--   superimposed atop one another.
--   
sqUpDownOverlay :: Renderable (Path R2) b => Diagram b R2

-- | Parameters to generate an iterated subset fractal.
data IterTrailConfig
ITC :: Trail' Line R2 -> Colour Double -> Int -> IterTrailConfig

-- | The seed trail
seed :: IterTrailConfig -> Trail' Line R2

-- | The line color to use
color :: IterTrailConfig -> Colour Double

-- | Number of iterations
iters :: IterTrailConfig -> Int

-- | Generate a random <a>IterTrailConfig</a>. This features many
--   hard-coded values. If you want to play with it just copy the code and
--   modify it to suit.
randITC :: (MonadRandom m, Applicative m) => m IterTrailConfig

-- | Generate an iterated subset fractal based on the given parameters.
drawITC :: Renderable (Path R2) b => IterTrailConfig -> Diagram b R2

-- | Like <a>drawITC</a>, but also scales, centers, and pads the result so
--   that it fits nicely inside a 4x4 box.
drawITCScaled :: (Renderable (Path R2) b, Backend b R2) => IterTrailConfig -> Diagram b R2

-- | Create a grid of 100 random iterated subset fractals. Impress your
--   friends!
randIterGrid :: (Renderable (Path R2) b, Backend b R2) => IO (Diagram b R2)


-- | Create "calligraphic" strokes by filling between two offset copies of
--   a curve.
module Diagrams.TwoD.Path.Calligraphic

-- | <tt>calligraphic pen t</tt> creates a "calligraphic" variant of
--   <tt>t</tt> by filling between two copies of <tt>t</tt> offset by the
--   <tt>pen</tt> vector.
--   
--   
--   <pre>
--   import Diagrams.Coordinates
--   import Diagrams.TwoD.Path.Calligraphic
--   
--   curve = cubicSpline False [1 ^&amp; 1, 2 ^&amp; 5, 5 ^&amp; 6, 8 ^&amp; 12]
--         # scale 3
--   
--   calligraphicEx =
--     [ circle 15 # calligraphic (2 ^&amp; 1)
--     , curve     # calligraphic (2 ^&amp; 2)
--     ]
--     # map (centerXY . strokeLoop)
--     # fc black
--     # hcat' (with &amp; sep .~ 10)
--   </pre>
calligraphic :: R2 -> Trail' Line R2 -> Trail' Loop R2


-- | A method for laying out diagrams using a circle packing algorithm. For
--   details on the algorithm, see <a>Optimisation.CirclePacking</a> in the
--   module circle-packing.
--   
--   Here is an example:
--   
--   <pre>
--   import Optimisation.CirclePacking
--   import Diagrams.TwoD.Vector       (e)
--   
--   colorize = zipWith fc $
--       cycle [red,blue,yellow,magenta,cyan,bisque,firebrick,indigo]
--   
--   objects = colorize $
--       [ circle r  | r &lt;- [0.1,0.2..1.6] ] ++
--       [ hexagon r | r &lt;- [0.1,0.2..0.7] ] ++
--       [ decagon r | r &lt;- [0.1,0.2..0.7] ]
--   
--   -- Just a approximation, diagram objects do not have an exact radius
--   radiusApproximation o = maximum [ radius (e (alpha @@ turn)) o | alpha &lt;- [0,0.1..1.0]]
--   
--   circlePackingExample =
--       position $ map (\(o,(x,y)) -&gt; (p2 (x,y),o)) $
--       packCircles radiusApproximation objects
--   </pre>
--   
module Diagrams.TwoD.Layout.CirclePacking

-- | Combines the passed objects, whose radius is estimated using the given
--   <a>RadiusFunction</a>, so that they do not overlap (according to the
--   radius function) and otherwise form, as far as possible, a tight
--   circle.
renderCirclePacking :: Monoid' m => RadiusFunction b m -> [QDiagram b R2 m] -> QDiagram b R2 m

-- | More general version of <a>renderCirclePacking</a>. You can use this
--   if you have more information available in the values of type
--   <tt>a</tt> that allows you to calculate the radius better (or even
--   exactly).
createCirclePacking :: Monoid' m => (a -> Double) -> (a -> QDiagram b R2 m) -> [a] -> QDiagram b R2 m

-- | The type of radius-estimating functions for Diagrams such as
--   <a>approxRadius</a> and <a>circleRadius</a>. When you can calculate
--   the radius better, but not any more once you converted your data to a
--   diagram, use <a>createCirclePacking</a>.
type RadiusFunction b m = QDiagram b R2 m -> Double

-- | A safe approximation. Calculates the outer radius of the smallest
--   axis-aligned polygon with the given number of edges that contains the
--   object. A parameter of 4 up to 8 should be sufficient for most
--   applications.
approxRadius :: Monoid' m => Int -> RadiusFunction b m

-- | An unsafe approximation. This is the radius of the largest circle that
--   fits in the rectangular bounding box of the object, so it may be too
--   small. It is, however, exact for circles, and there is no function
--   that is safe for all diagrams and exact for circles.
circleRadius :: Monoid' m => RadiusFunction b m


-- | Generation of Sunburst Partitions. A radial view of a Treemap.
--   
--   The partitions are created without examining the contents of the tree
--   nodes which allows us to create a sunburst for any <tt>Tree a</tt>. As
--   a consequence we cannot base the size or color of the sections on the
--   data in the tree, but only on depth and number of children. Of course
--   the code could easily be adapted to handle more specific tree data.
--   
--   See John Stasko, Richard Catrambone, "An evaluation of space-filling
--   information visualizations for depicting hierarchical structures",
--   2000. <a>http://www.cc.gatech.edu/~john.stasko/papers/ijhcs00.pdf</a>.
module Diagrams.TwoD.Sunburst

-- | Take any <tt>Tree a</tt> and <tt>SunburstOpts</tt> and make a sunburst
--   partition. Basically a treemap with a radial layout. The root is the
--   center of the sunburst and its circumference is divided evenly
--   according to the number of child nodes it has. Then each of those
--   sections is treated the same way.
sunburst' :: Renderable (Path R2) b => SunburstOpts -> Tree a -> Diagram b R2

-- | <tt>sunburst</tt> with default opts
--   
--   <pre>
--   import Diagrams.TwoD.Sunburst
--   import Data.Tree (unfoldTree)
--   aTree = unfoldTree (\n -&gt; (0, replicate n (n-1))) 6
--   sunburstEx = sunburst aTree # pad 1.1
--   </pre>
--   
sunburst :: Renderable (Path R2) b => Tree a -> Diagram b R2
data SunburstOpts
SunburstOpts :: Double -> Double -> [Colour Double] -> SunburstOpts

-- | Relative size of the root circle, usually 1.
_radius :: SunburstOpts -> Double

-- | Relative width of the sections.
_sectionWidth :: SunburstOpts -> Double

-- | Color list one for each ring.
_colors :: SunburstOpts -> [Colour Double]
radius :: Lens' SunburstOpts Double
sectionWidth :: Lens' SunburstOpts Double
colors :: Lens' SunburstOpts [Colour Double]
instance Default SunburstOpts


-- | Tools for generating and drawing plane tilings made of regular
--   polygons.
module Diagrams.TwoD.Tilings

-- | <tt>Q236 a b c d</tt> represents <tt>a + b sqrt(2) + c sqrt(3) + d
--   sqrt(6)</tt>.
data Q236
rt2 :: Q236
rt3 :: Q236
rt6 :: Q236

-- | Convert a <tt>Q236</tt> value to a <tt>Double</tt>.
toDouble :: Q236 -> Double
type Q2 = (Q236, Q236)
toR2 :: Q2 -> R2
toP2 :: Q2 -> P2

-- | Regular polygons which may appear in a tiling of the plane.
data TilingPoly
Triangle :: TilingPoly
Square :: TilingPoly
Hexagon :: TilingPoly
Octagon :: TilingPoly
Dodecagon :: TilingPoly
polySides :: Num a => TilingPoly -> a
polyFromSides :: (Num a, Eq a, Show a) => a -> TilingPoly

-- | Cosine of a polygon's internal angle.
polyCos :: TilingPoly -> Q236

-- | Sine of a polygon's internal angle.
polySin :: TilingPoly -> Q236

-- | Rotate by polygon internal angle.
polyRotation :: TilingPoly -> Q2 -> Q2

-- | Rotate by polygon external angle.
polyExtRotation :: TilingPoly -> Q2 -> Q2

-- | A tiling, represented as a sort of zipper. <tt>curConfig</tt>
--   indicates the polygons around the current vertex, in couterclockwise
--   order starting from the edge along which we entered the vertex.
--   <tt>follow</tt> allows one to move along an edge to an adjacent
--   vertex, where the edges are numbered counterclockwise from zero,
--   beginning with the edge along which we entered the current vertex.
data Tiling
Tiling :: [TilingPoly] -> (Int -> Tiling) -> Tiling
curConfig :: Tiling -> [TilingPoly]
follow :: Tiling -> Int -> Tiling

-- | An edge is represented by a pair of vertices. Do not use the
--   <tt>Edge</tt> constructor directly; use <a>mkEdge</a> instead.
data Edge

-- | Smart constructor for <tt>Edge</tt>, which puts the vertices in a
--   canonical order.
mkEdge :: Q2 -> Q2 -> Edge

-- | A polygon is represented by a list of its vertices, in
--   counterclockwise order. However, the <tt>Eq</tt> and <tt>Ord</tt>
--   instances for polygons ignore the order.
newtype Polygon
Polygon :: [Q2] -> Polygon
polygonVertices :: Polygon -> [Q2]

-- | The state maintained while generating a tiling, recording which
--   vertices have been visited and which edges and polygons have been
--   drawn.
data TilingState
TP :: (Set Q2) -> (Set Edge) -> (Set Polygon) -> TilingState
visitedVertices :: TilingState -> (Set Q2)
visitedEdges :: TilingState -> (Set Edge)
visitedPolygons :: TilingState -> (Set Polygon)
initTilingState :: TilingState

-- | The <tt>TilingM</tt> monad tracks a <tt>TilingState</tt>, and can
--   output elements of some monoid <tt>w</tt> along the way.
type TilingM w a = WriterT w (State TilingState) a
generateTiling :: Monoid w => Tiling -> Q2 -> Q2 -> (Q2 -> Bool) -> (Edge -> w) -> (Polygon -> w) -> w

t3 :: Tiling

t4 :: Tiling

t6 :: Tiling

-- | Create a tiling with the same 3 polygons surrounding each vertex. The
--   argument is the number of sides of the polygons surrounding a vertex.
mk3Tiling :: [Int] -> Tiling

t4612 :: Tiling

t488 :: Tiling

t31212 :: Tiling

t3636 :: Tiling

-- | Create a tiling where every vertex is the same up to rotation and
--   translation (but <i>not</i> reflection). Arbitrarily pick one of the
--   edges emanating from a vertex and number the edges counterclockwise
--   starting with 0 for the chosen edge.
semiregular :: [Int] -> [Int] -> Tiling
rot :: (Num a, Eq a) => a -> [t] -> [t]

t3464 :: Tiling

t33434 :: Tiling

t33344 :: Tiling

t33336L :: Tiling

t33336R :: Tiling

-- | Draw an edge with the given style.
drawEdge :: Renderable (Path R2) b => Style R2 -> Edge -> Diagram b R2

-- | Draw a polygon with the given style.
drawPoly :: Renderable (Path R2) b => (Polygon -> Style R2) -> Polygon -> Diagram b R2
polyColor :: (Floating a, Ord a) => TilingPoly -> Colour a

-- | Draw a tiling, with a given width and height and default colors for
--   the polygons.
drawTiling :: (Renderable (Path R2) b, Backend b R2) => Tiling -> Double -> Double -> Diagram b R2

-- | Draw a tiling with customizable styles for the polygons. This is just
--   an example, which you can use as the basis of your own tiling-drawing
--   routine.
drawTilingStyled :: (Renderable (Path R2) b, Backend b R2) => Style R2 -> (Polygon -> Style R2) -> Tiling -> Double -> Double -> Diagram b R2
instance Eq Q236
instance Ord Q236
instance Show Q236
instance Read Q236
instance Eq TilingPoly
instance Ord TilingPoly
instance Show TilingPoly
instance Read TilingPoly
instance Enum TilingPoly
instance Bounded TilingPoly
instance Eq Edge
instance Ord Edge
instance Show Edge
instance Show Polygon
instance Ord Polygon
instance Eq Polygon
instance VectorSpace Q236
instance AdditiveGroup Q236
instance Num Q236


-- | 
--   The example above is created by the code below which generates a grid,
--   puts points on the interior and the boundary, draws dashed lines
--   around the points to which we wish to draw attention and annotates the
--   points of interest with some text.
--   
--   <pre>
--   {-# LANGUAGE FlexibleContexts      #-}
--   {-# LANGUAGE MultiParamTypeClasses #-}
--   
--   import Diagrams.TwoD.Grid
--   import Diagrams.TwoD.Text
--   
--   example :: (Renderable Text b, Renderable (Path R2) b, Backend b R2) =&gt;
--              Int -&gt; Int -&gt; Diagram b R2
--   example n m =
--   
--     (gridWithHalves n m) #
--   
--     -- Put points on the boundary
--     bndPts [ (1 :: Int,  m + 1     ) | m &lt;- [0,2..2 * m] ] #
--     bndPts [ (n + 1,     1 :: Int  ) | n &lt;- [0,2..2 * n] ] #
--     bndPts [ (2 * n + 1, m + 1     ) | m &lt;- [0,2..2 * m] ] #
--     bndPts [ (n + 1,     2 * m + 1 ) | n &lt;- [0,2..2 * n] ] #
--   
--     intPts [ (n + 1,          m + 1) | n &lt;- [2,4..2 * n - 1] :: [Int]
--                                      , m &lt;- [2,4..2 * m - 1] :: [Int] ] #
--   
--     selectedLines (2 * n - 3) (3 :: Int) #
--   
--     ann (2 * n - 1) (1 :: Int) red  #
--     ann (2 * n + 1) (3 :: Int) red  #
--     ann (2 * n - 1) (3 :: Int) blue #
--     ann (2 * n - 3) (3 :: Int) blue #
--     ann (2 * n - 1) (5 :: Int) blue
--   
--     where
--   
--       ann n m c = annotate ("u_" ++ show (n `div` 2) ++ show (m `div` 2)) txtPt c n m
--   
--       selectedLines n m = gridLines $ selectedPairs n m
--   
--       selectedPairs n m = let pts = selectedList n m
--                           in zip pts (tail pts)
--   
--       selectedList n m = [ (n - 1, m - 1)
--                          , (n - 1, m + 1)
--                          , (n + 1, m + 1)
--                          , (n + 1, m + 3)
--                          , (n + 3, m + 3)
--                          , (n + 3, m + 1)
--                          , (n + 5, m + 1)
--                          , (n + 5, m - 1)
--                          , (n + 3, m - 1)
--                          , (n + 3, m - 3)
--                          , (n + 1, m - 3)
--                          , (n + 1, m - 1)
--                          , (n - 1, m - 1)
--                          ]
--   
--       txtPt t = circle cSize # opacity 0.0 # lw none
--                 ===
--                 text t # fontSize (Local 0.06)
--   
--       intPts = placeDiagramOnGrid (circle (cSize / 2) # fc blue # opacity 0.5 # lw none)
--       bndPts = placeDiagramOnGrid (circle (cSize / 2) # fc red  # opacity 0.5 # lw none)
--   
--       cSize :: Double
--       cSize = 0.03
--   
--   example1 = example 5 5
--   </pre>
module Diagrams.TwoD.Grid

-- | <tt>gridWithHalves</tt> with default opts.
gridWithHalves :: (Renderable Text b, Renderable (Path R2) b, Backend b R2) => Int -> Int -> Diagram b R2

-- | Create a n by m grid. Diagrams can be placed on either the grid points
--   themselves or on points half way between grid points. The latter
--   includes points a half grid length outside of the grid itself.
gridWithHalves' :: (Renderable Text b, Renderable (Path R2) b, Backend b R2) => GridOpts -> Int -> Int -> Diagram b R2
annotate :: (Renderable Text b, Renderable (Path R2) b) => String -> (String -> Diagram b R2) -> Colour Double -> Int -> Int -> Diagram b R2 -> Diagram b R2

-- | Draw a line between two named points on the grid.
gridLine :: (IsName a, IsName b, Renderable Text c, Renderable (Path R2) c) => a -> b -> Diagram c R2 -> Diagram c R2

-- | Draw lines between a list of pairs of named points on the grid.
gridLines :: (Renderable Text c, Renderable (Path R2) c, IsName a, IsName b) => [(a, b)] -> Diagram c R2 -> Diagram c R2

-- | Place a diagram on a grid (which is itself a diagram) at all the
--   co-ordinates specified.
placeDiagramOnGrid :: (IsName n, Renderable Text b, Renderable (Path R2) b) => Diagram b R2 -> [n] -> Diagram b R2 -> Diagram b R2
instance Default HighlightLineOpts
instance Default GridOpts


-- | Factorization diagrams, as seen at
--   <a>http://mathlesstraveled.com/2012/10/05/factorization-diagrams/</a>
--   and
--   <a>http://mathlesstraveled.com/2012/11/05/more-factorization-diagrams/</a>
--   and on the cover of Hacker Monthly
--   (<a>http://hackermonthly.com/issue-31.html</a>): visually represent
--   the prime factorization of n by drawing n dots recursively grouped
--   according to the factors.
--   
module Diagrams.TwoD.Factorization

-- | <tt>primeLayout</tt> takes a positive integer p (the idea is for it to
--   be prime, though it doesn't really matter) and a diagram, and lays out
--   p rotated copies of the diagram in a circular pattern.
--   
--   There is a special case for <tt>p = 2</tt>: if the given diagram is
--   taller than it is wide, then the two copies will be placed beside each
--   other; if wider then tall, they will be placed one above the other.
--   
--   The regular <tt>p</tt>-gon connecting the centers of the laid-out
--   diagrams is also filled in with vertical bars of color representing
--   the number <tt>p</tt>. In particular, there is one color for each
--   decimal digit (the provided list should have length 10 and represents
--   the digits 0-9), and the colors, read left to right, give the decimal
--   expansion of <tt>p</tt>.
--   
--   <pre>
--   import Diagrams.TwoD.Factorization
--   plExample
--     = pad 1.1 . centerXY
--     . hcat' (with &amp; sep .~ 0.5)
--     . map (sized (Width 1))
--     $ [ primeLayout defaultColors 5 (circle 1 # fc black)
--       , primeLayout defaultColors 103 (square 1 # fc green # lw none)
--       , primeLayout (repeat white) 13 (circle 1 # lc orange)
--       ]
--   </pre>
--   
primeLayout :: (Backend b R2, Renderable (Path R2) b) => [Colour Double] -> Integer -> Diagram b R2 -> Diagram b R2

-- | Draw vertical bars of color inside a polygon which represent the
--   decimal expansion of <tt>p</tt>, using the provided list of colors to
--   represent the digits 0-9.
--   
--   <pre>
--   import Diagrams.TwoD.Factorization
--   colorBarsEx = colorBars defaultColors 3526 (square 1)
--   </pre>
--   
colorBars :: Renderable (Path R2) b => [Colour Double] -> Integer -> Path R2 -> Diagram b R2

-- | A default set of digit colors, based very loosely on the color code
--   for resistors
--   (<a>http://en.wikipedia.org/wiki/Electronic_color_code</a>), lightened
--   up a bit by blending with white.
--   
defaultColors :: [Colour Double]

-- | Create a centered factorization diagram from the given list of factors
--   (intended to be primes, but again, any positive integers will do; note
--   how the below example uses 6), by recursively folding according to
--   <a>primeLayout</a>, with the <a>defaultColors</a> and a base case of a
--   black circle.
--   
--   <pre>
--   import Diagrams.TwoD.Factorization
--   factorDiagram'Ex = factorDiagram' [2,5,6]
--   </pre>
--   
factorDiagram' :: (Backend b R2, Renderable (Path R2) b) => [Integer] -> Diagram b R2

-- | Create a default factorization diagram for the given integer, by
--   factoring it and calling <a>factorDiagram'</a> on its prime
--   factorization (with the factors ordered from smallest to biggest).
--   
--   <pre>
--   import Diagrams.TwoD.Factorization
--   factorDiagramEx = factorDiagram 700
--   </pre>
--   
factorDiagram :: (Backend b R2, Renderable (Path R2) b) => Integer -> Diagram b R2

-- | Place a diagram inside a square with the given side length, centering
--   and scaling it to fit with a bit of padding.
--   
--   <pre>
--   import Diagrams.TwoD.Factorization
--   ensquareEx = ensquare 1 (circle 25) ||| ensquare 1 (factorDiagram 30)
--   </pre>
--   
ensquare :: (Backend b R2, Renderable (Path R2) b) => Double -> Diagram b R2 -> Diagram b R2

-- | <tt>fdGrid n</tt> creates a grid of factorization diagrams, given a
--   list of lists of integers: the inner lists represent L-R rows, which
--   are laid out from top to bottom.
--   
--   <pre>
--   import Diagrams.TwoD.Factorization
--   fdGridEx = fdGrid [[7,6,5],[4,19,200],[1,10,50]]
--   </pre>
--   
fdGrid :: (Renderable (Path R2) b, Backend b R2) => [[Integer]] -> Diagram b R2

-- | <tt>fdGridList n</tt> creates a grid containing the factorization
--   diagrams of all the numbers from <tt>1</tt> to <tt>n^2</tt>, ordered
--   left to right, top to bottom (like the grid seen on the cover of
--   Hacker Monthly, <a>http://hackermonthly.com/issue-31.html</a>).
--   
--   <pre>
--   import Diagrams.TwoD.Factorization
--   grid100 = fdGridList 10
--   grid100Big = grid100
--   </pre>
--   
fdGridList :: (Renderable (Path R2) b, Backend b R2) => Integer -> Diagram b R2

-- | <tt>fdTable n</tt> creates a "multiplication table" of factorization
--   diagrams, with the diagrams for <tt>1</tt> to <tt>n</tt> along both
--   the top row and left column, and the diagram for <tt>m*n</tt> in row
--   <tt>m</tt> and column <tt>n</tt>.
--   
--   <pre>
--   import Diagrams.TwoD.Factorization
--   fdMultTableEx = fdMultTable 13
--   </pre>
--   
fdMultTable :: (Renderable (Path R2) b, Backend b R2) => Integer -> Diagram b R2


-- | Generation of Apollonian gaskets. Any three mutually tangent circles
--   uniquely determine exactly two others which are mutually tangent to
--   all three. This process can be repeated, generating a fractal circle
--   packing.
--   
--   See J. Lagarias, C. Mallows, and A. Wilks, "Beyond the Descartes
--   circle theorem", <i>Amer. Math. Monthly</i> 109 (2002), 338--361.
--   <a>http://arxiv.org/abs/math/0101066</a>.
--   
--   A few examples:
--   
--   <pre>
--   import Diagrams.TwoD.Apollonian
--   apollonian1 = apollonianGasket 0.01 2 2 2
--   </pre>
--   
--   
--   <pre>
--   import Diagrams.TwoD.Apollonian
--   apollonian2 = apollonianGasket 0.01 2 3 3
--   </pre>
--   
--   
--   <pre>
--   import Diagrams.TwoD.Apollonian
--   apollonian3 = apollonianGasket 0.01 2 4 7
--   </pre>
--   
module Diagrams.TwoD.Apollonian

-- | Representation for circles that lets us quickly compute an Apollonian
--   gasket.
data Circle
Circle :: Double -> Complex Double -> Circle

-- | The bend is the reciprocal of signed radius: a negative radius means
--   the outside and inside of the circle are switched. The bends of any
--   four mutually tangent circles satisfy Descartes' Theorem.
bend :: Circle -> Double

-- | <i>Product</i> of bend and center represented as a complex number.
--   Amazingly, these products also satisfy the equation of Descartes'
--   Theorem.
cb :: Circle -> Complex Double

-- | Create a <tt>Circle</tt> given a signed radius and a location for its
--   center.
mkCircle :: Double -> P2 -> Circle

-- | Get the center of a circle.
center :: Circle -> P2

-- | Get the (unsigned) radius of a circle.
radius :: Circle -> Double

-- | Descartes' Theorem states that if <tt>b1</tt>, <tt>b2</tt>,
--   <tt>b3</tt> and <tt>b4</tt> are the bends of four mutually tangent
--   circles, then
--   
--   <pre>
--   b1^2 + b2^2 + b3^2 + b4^2 = 1/2 * (b1 + b2 + b3 + b4)^2.
--   
--   </pre>
--   
--   Surprisingly, if we replace each of the <tt>bi</tt> with the
--   <i>product</i> of <tt>bi</tt> and the center of the corresponding
--   circle (represented as a complex number), the equation continues to
--   hold! (See the paper referenced at the top of the module.)
--   
--   <tt>descartes [b1,b2,b3]</tt> solves for <tt>b4</tt>, returning both
--   solutions. Notably, <tt>descartes</tt> works for any instance of
--   <tt>Floating</tt>, which includes both <tt>Double</tt> (for bends),
--   <tt>Complex Double</tt> (for bend/center product), and <tt>Circle</tt>
--   (for both at once).
descartes :: Floating a => [a] -> [a]

-- | If we have <i>four</i> mutually tangent circles we can choose one of
--   them to replace; the remaining three determine exactly one other
--   circle which is mutually tangent. However, in this situation there is
--   no need to apply <a>descartes</a> again, since the two solutions
--   <tt>b4</tt> and <tt>b4'</tt> satisfy
--   
--   <pre>
--   b4 + b4' = 2 * (b1 + b2 + b3)
--   
--   </pre>
--   
--   Hence, to replace <tt>b4</tt> with its dual, we need only sum the
--   other three, multiply by two, and subtract <tt>b4</tt>. Again, this
--   works for bends as well as bend/center products.
other :: Num a => [a] -> a -> a

-- | Generate an initial configuration of four mutually tangent circles,
--   given just the signed bends of three of them.
initialConfig :: Double -> Double -> Double -> [Circle]

-- | Given a threshold radius and a list of <i>four</i> mutually tangent
--   circles, generate the Apollonian gasket containing those circles. Stop
--   the recursion when encountering a circle with an (unsigned) radius
--   smaller than the threshold.
apollonian :: Double -> [Circle] -> [Circle]

-- | Draw a circle.
drawCircle :: Renderable (Path R2) b => Double -> Circle -> Diagram b R2

-- | Draw a generated gasket, using a line width 0.003 times the radius of
--   the largest circle.
drawGasket :: Renderable (Path R2) b => [Circle] -> Diagram b R2

-- | Draw an Apollonian gasket: the first argument is the threshold; the
--   recursion will stop upon reaching circles with radii less than it. The
--   next three arguments are bends of three circles.
apollonianGasket :: Renderable (Path R2) b => Double -> Double -> Double -> Double -> Diagram b R2
instance Eq Circle
instance Show Circle
instance Floating Circle
instance Fractional Circle
instance Num Circle


-- | This module provides utilities for using <a>Control.Lens</a> with
--   diagrams, including orphan instances for the <a>Wrapped</a> class.
module Diagrams.Lens
_P :: Iso (Point v) (Point v') v v'

-- | A singleton <a>Traversal</a> for an envelope vector, where
--   modification of the vector moves the origin appropriately. No vector
--   is traversed when the envelope is empty.
--   
--   This is the same as <a>_alignedVMove</a> with <tt>1</tt> as the
--   interpolation parameter.
_envelopeVMove :: (Monoid a, HasOrigin a, Enveloped a, Num (Scalar (V a))) => V a -> Traversal' a (V a)

-- | A singleton <a>Traversal</a> for an alignment vector, where
--   modification of the vector moves the origin appropriately. No vector
--   is traversed when the envelope is empty.
--   
--   The interface mimics "Diagrams.Align.alignBy" in that the <tt>d</tt>
--   parameter specifies an interpolation between two extremes of the
--   envelope. <tt>d = 1</tt> is on the envelope along the vector, whereas
--   <tt>d = -1</tt> is on the envelope, away from the vector.
--   
--   If you need a <a>Point</a> instead of a vector, then compose with
--   <a>_P</a>.
_alignedVMove :: (Monoid a, HasOrigin a, Enveloped a, Num (Scalar (V a))) => V a -> Scalar (V a) -> Traversal' a (V a)

-- | A traversal that either has 0 (empty box) or 2 points. These points
--   are the lower and upper corners, respectively.
_corners :: (HasBasis v, Ord (Basis v), AdditiveGroup (Scalar v), Ord (Scalar v), HasBasis v', Ord (Basis v'), AdditiveGroup (Scalar v'), Ord (Scalar v')) => Traversal (BoundingBox v) (BoundingBox v') (Point v) (Point v')

-- | A lens that gets the extents of the box. In order to change the
--   extents, this modifies the upper corner.
_boxExtents :: (HasBasis v, Ord (Basis v), AdditiveGroup (Scalar v), Ord (Scalar v)) => Lens' (BoundingBox v) v
_attr :: AttributeClass a => Lens' (Style v) (Maybe a)
_mkAttr :: AttributeClass a => Prism' (Attribute v) a
_mkTAttr :: (AttributeClass a, Transformable a, V a ~ v) => Prism' (Attribute v) a

-- | Gets or set the <a>location</a> of a <a>Subdiagram</a>.
_location :: (HasLinearMap v, InnerSpace v, OrderedField (Scalar v)) => Lens' (Subdiagram b v m) (Point v)
_mkSubdiagram :: (HasLinearMap v, InnerSpace v, OrderedField (Scalar v), Semigroup m) => Iso' (QDiagram b v m) (Subdiagram b v m)
_Loc :: Iso (Located a) (Located a') (Point (V a), a) (Point (V a'), a')
_mkFixedSeg :: (AdditiveGroup v, AdditiveGroup v') => Iso (Located (Segment Closed v)) (Located (Segment Closed v')) (FixedSegment v) (FixedSegment v')

-- | Prism that constructs linear segments. Can also destruct them, if the
--   segment is Linear.
_straight :: Prism' (Segment Closed v) v

-- | Prism that constructs cubic bezier segments. Can also destruct them,
--   if segment is a <a>Cubic</a>.
_bezier3 :: Prism' (Segment Closed v) (v, v, v)
_lineVertices :: (InnerSpace v, OrderedField (Scalar v), InnerSpace v', OrderedField (Scalar v')) => Iso (Located (Trail' Line v)) (Located (Trail' Line v')) [Point v] [Point v']
_lineOffsets :: (InnerSpace v, OrderedField (Scalar v), InnerSpace v', OrderedField (Scalar v')) => Iso (Trail' Line v) (Trail' Line v') [v] [v']
_lineSegments :: (InnerSpace v, OrderedField (Scalar v), InnerSpace v', OrderedField (Scalar v')) => Iso (Trail' Line v) (Trail' Line v') [Segment Closed v] [Segment Closed v']


-- | An algorithm for filling space in a fashion akin to word-wrapping.
module Diagrams.Layout.Wrap

-- | <tt>wrapDiagram</tt> post-processes the results of
--   <tt>wrapOutside</tt> / <tt>wrapInside</tt> into a Diagram of the
--   result. This only works when applying them to a list of diagrams.
wrapDiagram :: (HasLinearMap v, InnerSpace v, OrderedField (Scalar v)) => ([(v, Diagram b v)], [Diagram b v]) -> Diagram b v

-- | <tt>wrapOutside</tt> is the same as <tt>wrapInside</tt>, but with an
--   inverted predicate.
wrapOutside :: (Enveloped a, v ~ V a, InnerSpace v, OrderedField (Scalar v)) => (Point v -> Bool) -> [v] -> Point v -> [a] -> ([(v, a)], [a])

-- | fillInside greedily wraps content to fill a space defined by a
--   predicate. It is passed a list of vectors which express the order of
--   dimensions to be filled. In other words, wrapping RTL text is done by
--   passing in [unitX, unitY], to first exhaust space horizontally, and
--   then vertically.
--   
--   Note that this function does not guarantee that there are not points
--   inside each positioned item for which the predicate is False. Instead,
--   only the corners of the bounds, along each axii, are used.
wrapInside :: (Enveloped a, v ~ V a, InnerSpace v, OrderedField (Scalar v)) => (Point v -> Bool) -> [v] -> Point v -> [a] -> ([(v, a)], [a])


-- | Stateful domain specific language for diagram paths, modelled after
--   the classic "turtle" graphics language.
module Diagrams.TwoD.Path.Turtle
type Turtle = TurtleT Identity
type TurtleT = StateT TurtleState

-- | Run the turtle, yielding the final turtle state.
runTurtle :: Turtle a -> TurtleState

-- | A more general way to run the turtle. Returns a computation in the
--   underlying monad <tt>m</tt> yielding the final turtle state.
runTurtleT :: Monad m => TurtleT m a -> m TurtleState

-- | Run the turtle, yielding a diagram.
drawTurtle :: Renderable (Path R2) b => Turtle a -> Diagram b R2

-- | A more general way to run the turtle. Returns a computation in the
--   underlying monad <tt>m</tt> yielding the final diagram.
drawTurtleT :: (Monad m, Functor m, Renderable (Path R2) b) => TurtleT m a -> m (Diagram b R2)

-- | Run the turtle, ignoring any pen style commands and yielding a 2D
--   path.
sketchTurtle :: Turtle a -> Path R2

-- | A more general way to run the turtle. Returns a computation in the
--   underlying monad <tt>m</tt>, ignoring any pen style commands and
--   yielding a 2D path.
sketchTurtleT :: (Functor m, Monad m) => TurtleT m a -> m (Path R2)

-- | Move the turtle forward, along the current heading.
forward :: Monad m => Double -> TurtleT m ()

-- | Move the turtle backward, directly away from the current heading.
backward :: Monad m => Double -> TurtleT m ()

-- | Modify the current heading to the left by the specified angle in
--   degrees.
left :: Monad m => Double -> TurtleT m ()

-- | Modify the current heading to the right by the specified angle in
--   degrees.
right :: Monad m => Double -> TurtleT m ()

-- | Get the current turtle angle, in degrees.
heading :: Monad m => TurtleT m Double

-- | Set the current turtle angle, in degrees.
setHeading :: Monad m => Double -> TurtleT m ()

-- | Sets the heading towards a given location.
towards :: Monad m => P2 -> TurtleT m ()

-- | Queries whether the pen is currently drawing a path or not.
isDown :: Monad m => TurtleT m Bool

-- | Get the current turtle X/Y position.
pos :: Monad m => TurtleT m P2

-- | Set the current turtle X/Y position.
setPos :: Monad m => P2 -> TurtleT m ()

-- | Sets the pen size
setPenWidth :: Monad m => Double -> TurtleT m ()

-- | Sets the pen color
setPenColor :: Monad m => Colour Double -> TurtleT m ()

-- | Ends the current path, and enters into "penUp" mode
penUp :: Monad m => TurtleT m ()

-- | Ends the current path, and enters into "penDown" mode
penDown :: Monad m => TurtleT m ()

-- | Start a new trail at current position
penHop :: Monad m => TurtleT m ()

-- | Closes the current path , to the starting position of the current
--   trail. Has no effect when the pen position is up.
closeCurrent :: Monad m => TurtleT m ()


-- | Adds compact aliases for turtle operations, to write code that looks
--   even more Turtle-y.
module Diagrams.TwoD.Path.Turtle.Aliases
fd :: Double -> Turtle ()
rt :: Double -> Turtle ()
lt :: Double -> Turtle ()
bk :: Double -> Turtle ()
pu :: Turtle ()
pd :: Turtle ()


-- | A collection of methods for laying out various kinds of trees. This
--   module is still experimental, and more layout methods will probably be
--   added over time.
--   
--   Laying out a rose tree using a symmetric layout:
--   
--   <pre>
--   import Data.Tree
--   import Diagrams.TwoD.Layout.Tree
--   
--   t1 = Node 'A' [Node 'B' (map lf "CDE"), Node 'F' [Node 'G' (map lf "HIJ")]]
--     where lf x = Node x []
--   
--   exampleSymmTree =
--     renderTree ((&lt;&gt; circle 1 # fc white) . text . (:[]))
--                (~~)
--                (symmLayout' (with &amp; slHSep .~ 4 &amp; slVSep .~ 4) t1)
--     # centerXY # pad 1.1
--   </pre>
--   
--   
--   Laying out a rose tree of diagrams, with spacing automatically
--   adjusted for the size of the diagrams:
--   
--   <pre>
--   import Data.Tree
--   import Data.Maybe (fromMaybe)
--   import Diagrams.TwoD.Layout.Tree
--   
--   tD = Node (rect 1 3)
--          [ Node (circle 0.2) []
--          , Node (hcat . replicate 3 $ circle 1) []
--          , Node (eqTriangle 5) []
--          ]
--   
--   exampleSymmTreeWithDs =
--     renderTree id (~~)
--     (symmLayout' (with &amp; slWidth  .~ fromMaybe (0,0) . extentX
--                        &amp; slHeight .~ fromMaybe (0,0) . extentY)
--        tD)
--     # centerXY # pad 1.1
--   </pre>
--   
--   
--   Using a variant symmetric layout algorithm specifically for binary
--   trees:
--   
--   <pre>
--   import Diagrams.TwoD.Layout.Tree
--   
--   drawT = maybe mempty (renderTree (const (circle 0.05 # fc black)) (~~))
--         . symmLayoutBin' (with &amp; slVSep .~ 0.5)
--   
--   tree500 = drawT t # centerXY # pad 1.1 # sized (Width 4)
--     where t = genTree 500 0.05
--           -- genTree 500 0.05 randomly generates trees of size 500 +/- 5%,
--           -- definition not shown
--   </pre>
--   
--   
--   Using force-based layout on a binary tree:
--   
--   <pre>
--   {-# LANGUAGE NoMonomorphismRestriction #-}
--   import Diagrams.Prelude
--   import Diagrams.TwoD.Layout.Tree
--   
--   t 0 = Empty
--   t n = BNode n (t (n-1)) (t (n-1))
--   
--   Just t' = uniqueXLayout 1 1 (t 4)
--   
--   fblEx = renderTree (\n -&gt; (text (show n) # fontSizeL 0.5
--                               &lt;&gt; circle 0.3 # fc white))
--               (~~)
--               (forceLayoutTree t')
--           # centerXY # pad 1.1
--   </pre>
--   
module Diagrams.TwoD.Layout.Tree

-- | Binary trees with data at internal nodes.
data BTree a
Empty :: BTree a
BNode :: a -> (BTree a) -> (BTree a) -> BTree a

-- | Convenient constructor for leaves.
leaf :: a -> BTree a

-- | <tt>uniqueXLayout xSep ySep t</tt> lays out the binary tree <tt>t</tt>
--   using a simple recursive algorithm with the following properties:
--   
--   <ul>
--   <li>Every left subtree is completely to the left of its parent, and
--   similarly for right subtrees.</li>
--   <li>All the nodes at a given depth in the tree have the same
--   y-coordinate. The separation distance between levels is given by
--   <tt>ySep</tt>.</li>
--   <li>Every node has a unique x-coordinate. The separation between
--   successive nodes from left to right is given by <tt>xSep</tt>.</li>
--   </ul>
uniqueXLayout :: Double -> Double -> BTree a -> Maybe (Tree (a, P2))

-- | Run the symmetric rose tree layout algorithm on a given tree using
--   default options, resulting in the same tree annotated with node
--   positions.
symmLayout :: Tree a -> Tree (a, P2)

-- | Run the symmetric rose tree layout algorithm on a given tree,
--   resulting in the same tree annotated with node positions.
symmLayout' :: SymmLayoutOpts a -> Tree a -> Tree (a, P2)

-- | Lay out a binary tree using a slight variant of the symmetric layout
--   algorithm, using default options. In particular, if a node has only a
--   left child but no right child (or vice versa), the child will be
--   offset from the parent horizontally by half the horizontal separation
--   parameter. Note that the result will be <tt>Nothing</tt> if and only
--   if the input tree is <tt>Empty</tt>.
symmLayoutBin :: BTree a -> Maybe (Tree (a, P2))

-- | Lay out a binary tree using a slight variant of the symmetric layout
--   algorithm. In particular, if a node has only a left child but no right
--   child (or vice versa), the child will be offset from the parent
--   horizontally by half the horizontal separation parameter. Note that
--   the result will be <tt>Nothing</tt> if and only if the input tree is
--   <tt>Empty</tt>.
symmLayoutBin' :: SymmLayoutOpts a -> BTree a -> Maybe (Tree (a, P2))

-- | Options for controlling the symmetric tree layout algorithm.
data SymmLayoutOpts a
SLOpts :: Double -> Double -> (a -> (Double, Double)) -> (a -> (Double, Double)) -> SymmLayoutOpts a

-- | Minimum horizontal separation between sibling nodes. The default is 1.
_slHSep :: SymmLayoutOpts a -> Double

-- | Vertical separation between adjacent levels of the tree. The default
--   is 1.
_slVSep :: SymmLayoutOpts a -> Double

-- | A function for measuring the horizontal extent (a pair of
--   x-coordinates) of an item in the tree. The default is <tt>const
--   (0,0)</tt>, that is, the nodes are considered as taking up no space,
--   so the centers of the nodes will be separated according to the
--   <tt>slHSep</tt> and <tt>slVSep</tt>. However, this can be useful,
--   <i>e.g.</i> if you have a tree of diagrams of irregular size and want
--   to make sure no diagrams overlap. In that case you could use
--   <tt>fromMaybe (0,0) . extentX</tt>.
_slWidth :: SymmLayoutOpts a -> a -> (Double, Double)

-- | A function for measuring the vertical extent of an item in the tree.
--   The default is <tt>const (0,0)</tt>. See the documentation for
--   <a>slWidth</a> for more information.
_slHeight :: SymmLayoutOpts a -> a -> (Double, Double)
slHSep :: Lens' (SymmLayoutOpts a_aDZ9) Double
slVSep :: Lens' (SymmLayoutOpts a_aDZ9) Double
slWidth :: Lens' (SymmLayoutOpts a_aDZ9) (a_aDZ9 -> (Double, Double))
slHeight :: Lens' (SymmLayoutOpts a_aDZ9) (a_aDZ9 -> (Double, Double))

-- | Force-directed layout of rose trees, with default parameters (for more
--   options, see <a>forceLayoutTree'</a>). In particular,
--   
--   <ul>
--   <li>edges are modeled as springs</li>
--   <li>nodes are modeled as point charges</li>
--   <li>nodes are constrained to keep the same y-coordinate.</li>
--   </ul>
--   
--   The input could be a tree already laid out by some other method, such
--   as <a>uniqueXLayout</a>.
forceLayoutTree :: Tree (a, P2) -> Tree (a, P2)

-- | Force-directed layout of rose trees, with configurable parameters.
forceLayoutTree' :: ForceLayoutTreeOpts -> Tree (a, P2) -> Tree (a, P2)
data ForceLayoutTreeOpts
FLTOpts :: ForceLayoutOpts R2 -> Double -> Double -> Double -> ForceLayoutTreeOpts

-- | Options to the force layout simulator, including damping.
_forceLayoutOpts :: ForceLayoutTreeOpts -> ForceLayoutOpts R2

-- | How long edges should be, ideally. This will be the resting length for
--   the springs.
_edgeLen :: ForceLayoutTreeOpts -> Double

-- | Spring constant. The bigger the constant, the more the edges push/pull
--   towards their resting length.
_springK :: ForceLayoutTreeOpts -> Double

-- | Coulomb constant. The bigger the constant, the more sibling nodes
--   repel each other.
_staticK :: ForceLayoutTreeOpts -> Double
forceLayoutOpts :: Lens' ForceLayoutTreeOpts (ForceLayoutOpts R2)
edgeLen :: Lens' ForceLayoutTreeOpts Double
springK :: Lens' ForceLayoutTreeOpts Double
staticK :: Lens' ForceLayoutTreeOpts Double

-- | Assign unique ID numbers to the nodes of a tree, and generate an
--   <a>Ensemble</a> suitable for simulating in order to do force-directed
--   layout of the tree. In particular,
--   
--   <ul>
--   <li>edges are modeled as springs</li>
--   <li>nodes are modeled as point charges</li>
--   <li>nodes are constrained to keep the same y-coordinate.</li>
--   </ul>
--   
--   The input to <tt>treeToEnsemble</tt> could be a tree already laid out
--   by some other method, such as <a>uniqueXLayout</a>.
treeToEnsemble :: ForceLayoutTreeOpts -> Tree (a, P2) -> (Tree (a, PID), Ensemble R2)

-- | Assign unique IDs to every node in a tree (or other traversable
--   structure).
label :: Traversable t => t a -> t (a, PID)

-- | Reconstruct a tree (or any traversable structure) from an
--   <a>Ensemble</a>, given unique identifier annotations matching the
--   identifiers used in the <a>Ensemble</a>.
reconstruct :: Functor t => Ensemble R2 -> t (a, PID) -> t (a, P2)

-- | Draw a tree annotated with node positions, given functions specifying
--   how to draw nodes and edges.
renderTree :: Monoid' m => (a -> QDiagram b R2 m) -> (P2 -> P2 -> QDiagram b R2 m) -> Tree (a, P2) -> QDiagram b R2 m

-- | Draw a tree annotated with node positions, given functions specifying
--   how to draw nodes and edges. Unlike <a>renderTree</a>, this version
--   gives the edge-drawing function access to the actual values stored at
--   the nodes rather than just their positions.
renderTree' :: Monoid' m => (a -> QDiagram b R2 m) -> ((a, P2) -> (a, P2) -> QDiagram b R2 m) -> Tree (a, P2) -> QDiagram b R2 m
instance Default ForceLayoutTreeOpts
instance Default (SymmLayoutOpts a)
instance Monoid Extent
instance Semigroup Extent
instance Eq a => Eq (BTree a)
instance Ord a => Ord (BTree a)
instance Read a => Read (BTree a)
instance Show a => Show (BTree a)
instance Functor BTree
instance Foldable BTree
instance Traversable BTree
instance Eq Pos
instance Show Pos


-- | Source code for creating the diagrams logo.
--   
module Diagrams.Example.Logo
d :: Renderable (Path R2) b => Diagram b R2
ico_d :: Renderable (Path R2) b => Diagram b R2
i :: (TrailLike (QDiagram b R2 m), Backend b R2, Monoid m, Semigroup m) => QDiagram b R2 m
sierpinski :: (TrailLike a1, Alignable a1, HasOrigin a1, Juxtaposable a1, Semigroup a1, Num a, Eq a, (~) * (V a1) R2) => a -> a1
a1 :: (TrailLike b, Alignable b, HasOrigin b, Transformable b, HasStyle b, Juxtaposable b, Semigroup b, (~) * (V b) R2) => b
grid :: (TrailLike a, Alignable a, HasOrigin a, Transformable a, Juxtaposable a, Monoid a, Semigroup a, (~) * (V a) R2) => a
gbkg :: (TrailLike (QDiagram b R2 m), Monoid m, Semigroup m) => QDiagram b R2 m
g :: (Renderable (Path R2) b, Renderable Text b) => Diagram b R2
r :: Renderable (Path R2) b => QDiagram b R2 Any
aTree :: BTree ()
a2 :: (TrailLike (QDiagram b R2 m), Monoid m, Semigroup m) => QDiagram b R2 m
m :: (Renderable (Path R2) b, Renderable Text b) => Diagram b R2
ps :: [P2]
s :: (TrailLike b, HasOrigin b, Transformable b, HasStyle b, Monoid b, Semigroup b, (~) * (V b) R2) => b
dot :: (TrailLike b, Transformable b, HasStyle b, (~) * (V b) R2) => Colour Double -> b
logo :: (Renderable (Path R2) b, Renderable Text b, Backend b R2) => Diagram b R2


-- | Utilities for working with color in HSV space.
--   
--   Right now, the only utility is a function for blending colors in HSV
--   space. This has the effect of "travelling around the color wheel",
--   which can be especially nice when one wants to blend smoothly from one
--   color to another (blending in RGB space can tend to travel across some
--   icky brown/grey colors).
module Diagrams.Color.HSV

-- | Blend two colors in HSV space---that is, linearly interpolate between
--   their hues, saturations, and values independently (wrapping around
--   appropriately in the case of hue). In particular, <tt>hsvBlend a c1
--   c2</tt> is like doing <tt>(a-1)*c1 + a*c2</tt> in HSV space. That is,
--   a parameter of <tt>0</tt> results in only the first color; <tt>1</tt>
--   results in only the second color; and anything in between results in a
--   blend.
hsvBlend :: (Floating a, RealFrac a, VectorSpace a) => Scalar a -> Colour a -> Colour a -> Colour a
