-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Graphing library wrapper + assorted useful functions
--   
--   A library of assorted useful functions for working with lists, doing
--   mathematical operations and graphing custom data types.
@package Zora
@version 1.2.0


-- | A typeclass with default implementation for graphing trees with
--   <a>Haskell GraphViz</a>. It is intended to be extremely
--   straightforward to graph your data type; you only need to define one
--   simple function (example implementation below).
module Zora.Graphing.DAGGraphing

-- | A typeclass for tree-like algebraic data types that are able to be
--   graphed.
class DAGGraphable g
expand :: DAGGraphable g => g -> Maybe (Maybe String, [(Maybe String, g)])

-- | Graphs the given <tt>DAGGraphable</tt> data type to a PDF file. Output
--   is written to the specified file. This is a convenience function that
--   is the composition of <tt>render_dotfile</tt> and <tt>to_dotfile</tt>.
render :: (Eq g, Show g, DAGGraphable g) => String -> g -> IO ()

-- | Returns a <tt>String</tt> to be put into a <a>DOT</a> file for the
--   given <tt>DAGGraphable</tt> type.
to_dotfile :: (Eq g, Show g, DAGGraphable g) => g -> String

-- | Graphs the given string as if it were the contents of a <a>DOT</a>
--   file. Output is written to the specified file. The first parameter is
--   the outfile name, and the second is the contents of the dotfile.
render_dotfile :: String -> String -> IO ()


-- | Assorted functions on lists.
module Zora.List

-- | <i>O(n)</i> Partitions the given list into blocks of the specified
--   length. Truncation behaves as follows:
--   
--   <pre>
--   partition_with_block_size 3 [1..10] == [[1,2,3],[4,5,6],[7,8,9],[10]]
--   </pre>
partition_with_block_size :: Int -> [a] -> [[a]]

-- | <i>O(n)</i> Partitions the given list into <i>k</i> blocks. Truncation
--   behavior is best described by example:
--   
--   <pre>
--   partition_into_k  3 [1..9]  == [[1,2,3],[4,5,6],[7,8,9]]
--   partition_into_k  3 [1..10] == [[1,2,3,4],[5,6,7,8],[9,10]]
--   partition_into_k  3 [1..11] == [[1,2,3,4],[5,6,7,8],[9,10,11]]
--   partition_into_k  3 [1..12] == [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
--   partition_into_k  3 [1..13] == [[1,2,3,4,5],[6,7,8,9,10],[11,12,13]]
--   </pre>
partition_into_k :: Int -> [a] -> [[a]]

-- | <i>O(B(n))</i>, where <i>B(n)</i> is the <i>n</i>^th <a>Bell
--   number</a>. Computes all partitions of the given list. For example,
--   
--   <pre>
--   powerpartition [1..3] == [[[1],[2],[3]], [[1,2],[3]], [[2],[1,3]], [[1],[2,3]], [[1,2,3]]]
--   </pre>
powerpartition :: [a] -> [[[a]]]

-- | <i>O(n log(n))</i> Removes duplicate elements. Like <a>nub</a>, but
--   for <a>Ord</a> types, so it can be faster.
uniqueify :: Ord a => [a] -> [a]

-- | <i>O(n)</i> Zips the list up into pairs. For example,
--   
--   <pre>
--   pairify [1..6] == [(1,2), (3,4), (5,6)]
--   pairify [1..5] == [(1,2), (3,4)]
--   </pre>
pairify :: [a] -> [(a, a)]

-- | <i>O(l m)</i>, where <i>l</i> is the cycle length and <i>m</i> is the
--   index of the start of the cycle. If the list contains no cycles, then
--   the runtime is <i>O(n)</i>.
--   
--   NOTE: this function will only find cycles in a list can be the output
--   of an iterated function -- that is, no element may be succeeded by two
--   separate elements (e.g. [2,3,2,4]).
decyclify :: Eq a => [a] -> [a]

-- | <i>O(n log(n))</i> Shuffles the given list. The second parameter is
--   the seed for the random number generator that backs the shuffle.
shuffle :: Eq a => [a] -> Integer -> [a]

-- | <i>O(2^n)</i> Computes the powerset of the given list.
powerset :: [a] -> [[a]]

-- | <i>O(n!)</i> Computes all permutations of the given list.
permutations :: [a] -> [[a]]

-- | <i>O(2^k)</i> Generates all subsets of the given list of size
--   <i>k</i>.
subsets_of_size :: [a] -> Integer -> [[a]]

-- | <i>O(n^m)</i> Computes all sets comprised of elements in the given
--   list, where the elements may be used multiple times, where <tt>n</tt>
--   is the size of the given list and <tt>m</tt> is the size of the sets
--   to generate. For example,
--   
--   <pre>
--   subsets_of_size_with_replacement 3 [1,2] == [[1,1,1],[2,1,1],[1,2,1],[2,2,1],[1,1,2],[2,1,2],[1,2,2],[2,2,2]]
--   </pre>
subsets_of_size_with_replacement :: Integer -> [a] -> [[a]]

-- | <i>O(n)</i> Generates all cycles of a given list. For example,
--   
--   <pre>
--   cycles [1..3] == [[2,3,1],[3,1,2],[1,2,3]]
--   </pre>
cycles :: Eq a => [a] -> [[a]]

-- | <i>O(l m)</i>, where <i>l</i> is the cycle length and <i>m</i> is the
--   index of the start of the cycle. If the list contains no cycles, then
--   the runtime is <i>O(n)</i>.
has_cycles :: Eq a => [a] -> Bool

-- | Given two infinite sorted lists, generates a list of elements in the
--   first but not the second. Implementation from
--   <a>http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)</a>.
diff_infinite :: Ord a => [a] -> [a] -> [a]

-- | <i>O(max(n, m))</i> Merges the two given sorted lists of respective
--   lengths <i>n</i> and <i>m</i>. A special case of <a>merge_by</a> where
--   the comparison function is <a>compare</a>.
merge :: Ord a => [a] -> [a] -> [a]

-- | <i>O(max(n, m))</i> Merges the two given sorted lists of respective
--   lengths <i>n</i> and <i>m</i>, comparing elements in between the two
--   lists with the given comparator function.
merge_by :: (a -> a -> Ordering) -> [a] -> [a] -> [a]

-- | <i>O(min(n, m))</i> Zips the two given lists of respective lengths
--   <i>n</i> and <i>m</i> as long as the pairs satisfy the given predicate
--   function.
zip_while :: (a -> b -> Bool) -> [a] -> [b] -> [(a, b)]

-- | <i>O(n)</i> Removes an element at the specified index in the given
--   list.
remove_at_index :: Integer -> [a] -> [a]

-- | <i>O(n)</i> Returns the subsequence of the given length at starting at
--   index <i>i</i> of length <i>m</i>. For example,
--   
--   <pre>
--   subseq 4 5 [1..20] == [5,6,7,8,9]
--   </pre>
subseq :: Integer -> Integer -> [a] -> [a]

-- | <i>(O(n))</i> Identical to <a>takeWhile</a>, but also contains the
--   first element to satisfy the given predicate function. For example:
--   
--   <pre>
--   take_while_keep_last (&lt;3) [1..] == [1,2,3]
--   </pre>
take_while_keep_last :: (a -> Bool) -> [a] -> [a]

-- | <i>(O(n))</i> Returns a pair where the first element is identical to
--   what <a>takeWhile</a> returns and the second element is the rest of
--   the list
--   
--   <pre>
--   take_while_and_rest (&lt;3) [1..10] == ([1,2],[3,4,5,6,7,8,9,10])
--   </pre>
take_while_and_rest :: (a -> Bool) -> [a] -> ([a], [a])

-- | <i>O(n)</i> Like <tt>Data.List.Find</tt>, but returns a Maybe 2-tuple,
--   instead, where the second element of the pair is the elements in the
--   list after the first element of the pair.
--   
--   <pre>
--   (find_and_rest ((==) 3) [1..10]) == Just (3, [4..10])
--   </pre>
find_and_rest :: (a -> Bool) -> [a] -> Maybe (a, [a])

-- | <i>(O(2^n))</i> Returns all subsequences (contiguous and
--   noncontiguous)
subsequences :: [a] -> [[a]]

-- | <i>(O(n^2))</i> Returns all contiguous subsequences.
contiguous_subsequences :: [a] -> [[a]]

-- | <i>O(n)</i> Retuns all contiguous subsequences of the given length.
--   E.g.:
--   
--   <pre>
--   contiguous_subsequences_of_length 3 "1234567890"
--   </pre>
--   
--   <ul>
--   <li><i>"123","234","345","456","567","678","789","890"</i></li>
--   </ul>
contiguous_subsequences_of_length :: Show a => Integer -> [a] -> [[a]]

-- | <i>O(n)</i> Returns whether the given list is sorted.
is_sorted :: Ord a => [a] -> Bool

-- | <i>O(n log(n))</i> Sorts the given list.
mergesort :: Ord a => [a] -> [a]

-- | <i>O(n)</i> Returns whether the given list is a palindrome.
is_palindrome :: Eq e => [e] -> Bool

-- | <i>O(n log(n))</i> Returns whether the given list contains any element
--   more than once.
contains_duplicates :: Ord a => [a] -> Bool

-- | <i>O(f log k)</i>, where k is the returnvalue, and f is the runtime of
--   the input function on the lowest power of 2 above the returnvalue.
bsearch :: (Integer -> Ordering) -> Maybe Integer

-- | <i>O(f log k)</i>, where k is the returnvalue, and f is the runtime of
--   the input function on the lowest power of 2 above the returnvalue.
bsearch_1st_geq :: (Integer -> Ordering) -> Maybe Integer

-- | <i>O(nlog(n))</i> Counts the number of time each element appears in
--   the given list. For example:
--   
--   <pre>
--   elem_counts [1,2,1,4] == [(1,2),(2,1),(4,1)]
--   </pre>
elem_counts :: Ord a => [a] -> [(a, Integer)]

-- | <i>O(nlog(n))</i> Counts the number of time each element appears in
--   the given list. For example:
--   
--   <pre>
--   elem_counts [1,2,1,4] == [(1,2),(2,1),(4,1)]
--   </pre>
elem_counts_by :: Ord b => (a -> b) -> [a] -> [(a, Integer)]

-- | <i>O(n)</i> Returns the noncontiguous sublist of elements greater than
--   all previous elements. For example:
--   
--   <pre>
--   running_bests [1,3,2,4,6,5] == [1,3,4,6]
--   </pre>
running_bests :: Ord a => [a] -> [a]

-- | <i>O(n)</i> Returns the noncontiguous sublist of elements greater than
--   all previous elements, where "greater" is determined by the provided
--   comparison function. For example:
--   
--   <pre>
--   running_bests_by (Data.Ord.comparing length) [[1],[3,3,3],[2,2]] == [[1],[3,3,3]]
--   </pre>
running_bests_by :: Ord a => (a -> a -> Ordering) -> [a] -> [a]

-- | Shorthand for applicative functors:
--   
--   <pre>
--   f &lt;$*&gt; l = f &lt;$&gt; l &lt;*&gt; l
--   </pre>
(<$*>) :: Applicative f => (a -> a -> b) -> f a -> f b

-- | Shorthand for applying the same parameter twice.
--   
--   <pre>
--   f $$ x = f x x
--   </pre>
($$) :: (a -> a -> b) -> a -> b

-- | <i>O(min(n, m))</i> Interleaves elements from the two given lists of
--   respective lengths <tt>n</tt> and <tt>m</tt> in an alternating
--   fashion. For example:
--   
--   <pre>
--   interleave [1,3,5,7] [2,4,6,8] == [1,2,3,4,5,6,7,8]
--   </pre>
--   
--   <pre>
--   interleave [1,3,5,7] [2,4,6] == [1,2,3,4,5,6,7]
--   </pre>
--   
--   <pre>
--   interleave [1,3,5] [2,4,6,8] == [1,2,3,4,5,6,8]
--   </pre>
interleave :: [a] -> [a] -> [a]

-- | <i>O(nf)</i> Filters a list of length <tt>n</tt> leaving elemnts the
--   indices of which satisfy the given predicate function, which has
--   runtime <tt>f</tt>.
passing_index_elems :: (Int -> Bool) -> [a] -> [a]

-- | <i>O(n)</i> counts the number of elements in a list that satisfy a
--   given predicate function.
count :: (a -> Bool) -> [a] -> Integer

-- | <i>O(n)</i> Maps the given function over the list while keeping the
--   original list. For example:
--   
--   <pre>
--   map_keep chr [97..100] == [(97,'a'),(98,'b'),(99,'c'),(100,'d')]
--   </pre>
map_keep :: (a -> b) -> [a] -> [(a, b)]

-- | <i>O(n)</i> Finds the maximum element of the given list and returns a
--   pair of it and the index at which it occurs (if the maximum element
--   occurs multiple times, behavior is identical to that of
--   <a>maximumBy</a>). The list must be finite and non-empty.
maximum_with_index :: Ord a => [a] -> (a, Integer)

-- | <i>O(n)</i> Finds the minimum element of the given list and returns a
--   pair of it and the index at which it occurs (if the minimum element
--   occurs multiple times, behavior is identical to that of
--   <a>minimumBy</a>). The list must be finite and non-empty.
minimum_with_index :: Ord a => [a] -> (a, Integer)

-- | <i>O(n)</i> Finds all maxima of the given list by the given comparator
--   function. For example, &gt; maxima_by (Data.Ord.comparing length)
--   [[1,2], [1], [3,3], [2]] [[1,2], [3,3]]
maxima_by :: (a -> a -> Ordering) -> [a] -> [a]

-- | <i>O(n)</i> Finds all minima of the given list by the given comparator
--   function. For example, &gt; minima_by (Data.Ord.comparing length)
--   [[1,2], [1], [3,3,3], [2]] [[1], [2]]
minima_by :: (a -> a -> Ordering) -> [a] -> [a]

-- | Like <a>length</a>, but returns an integer.
length' :: [a] -> Integer

-- | Like <a>drop</a>, but takes an integer.
drop' :: Integer -> [a] -> [a]

-- | Like <a>take</a>, but takes an integer.
take' :: Integer -> [a] -> [a]

-- | List pre-pending.
cons :: a -> [a] -> [a]

-- | List appending.
--   
--   <pre>
--   snoc 4 [1,2,3] == [1,2,3,4]
--   </pre>
snoc :: a -> [a] -> [a]

-- | Applies the given function to the first element of the tuple.
map_fst :: (a -> c) -> (a, b) -> (c, b)

-- | Applies the given function to the second element of the tuple.
map_snd :: (b -> c) -> (a, b) -> (a, c)

-- | Applies the given two functions to the respective first and second
--   elements of the tuple.
map_pair :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)

-- | Applies the given function to the first and second elements of the
--   tuple.
map_pair_same :: (a -> b) -> (a, a) -> (b, b)

-- | Applies the given three functions to the respective first, second, and
--   third elements of the tuple.
map_triple :: (a -> d) -> (b -> e) -> (c -> f) -> (a, b, c) -> (d, e, f)

-- | Applies the given function to respectively the first and second
--   elements of the two tuple. For example,
--   
--   <pre>
--   zip_with_pair (*) (^) (2,3) (5,4) == (10,27)
--   </pre>
zip_with_pair :: (a -> c -> e) -> (b -> d -> f) -> (a, b) -> (c, d) -> (e, f)

-- | Like <a>zip_with_pair</a>, but re-using the same function.
zip_with_pair_same :: (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)

-- | Extracts the first element of a 3-tuple.
fst3 :: (a, b, c) -> a

-- | Extracts the second element of a 3-tuple.
snd3 :: (a, b, c) -> b

-- | Extracts the third element of a 3-tuple.
trd3 :: (a, b, c) -> c

-- | Applies the given binary function to both elements of the given tuple.
pair_op :: (a -> b -> c) -> (a, b) -> c

-- | Applies the given ternary function to all three elements of the given
--   tuple.
triple_op :: (a -> b -> c -> d) -> (a, b, c) -> d


-- | Assorted mathematical functions.
module Zora.Math

-- | A complete, monotonically increasing, infinite list of primes.
--   Implementation from
--   <a>http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)</a>.
primes :: [Integer]

-- | A complete, monotonically increasing, infinite list of composite
--   numbers.
composites :: [Integer]

-- | <i>O(k n log(n)^-1)</i>, where <i>k</i> is the number of primes
--   dividing <i>n</i> (double-counting for powers). <i>n log(n)^-1</i> is
--   an approximation for <a>the number of primes below a number</a>.
--   Returns whether the parameter is a prime number.
prime :: Integer -> Bool

-- | <i>O(log^3 n)</i> Uses the <a>Miller-Rabin primality test</a> to
--   determine primality. Always correctly identifies primes, but may
--   misidentify some composites as primes (for most practical input
--   values, this will not happen (~3 below 10^9? 0 below 10^7.).).
prime_miller_rabin :: Integer -> Bool

-- | <i>O(min(n, m) (mod 10))</i> Returns whether the the two parameters
--   are <a>coprime</a>, that is, whether they share any divisors.
coprime :: Integral a => a -> a -> Bool

-- | <i>O(k n log(n)^-1)</i>, where <i>k</i> is the number of primes
--   dividing <i>n</i> (double-counting for powers).
euler_phi :: Integer -> Integer

-- | <i>O(k n log(n)^-1)</i>, where <i>k</i> is the number of primes
--   dividing <i>n</i> (double-counting for powers). <i>n log(n)^-1</i> is
--   an approximation for <a>the number of primes below a number</a>.
factor :: Integer -> [Integer]

-- | <i>O(k n log(n)^-1)</i>, where <i>k</i> is the number of primes
--   dividing <i>n</i> (double-counting for powers). <i>n log(n)^-1</i> is
--   an approximation for <a>the number of primes below a number</a>.
factor_number_is_perfect_square :: Integer -> [Integer]

-- | <i>O(k n log(n)^-1)</i>, where <i>k</i> is the number of primes
--   dividing <i>n</i> (double-counting for powers). <i>n log(n)^-1</i> is
--   an approximation for <a>the number of primes below a number</a>.
--   Essentially, linear in the time it takes to factor the number.
divisors :: Integer -> [Integer]

-- | <i>O(k n log(n)^-1)</i>, where <i>k</i> is the number of primes
--   dividing <i>n</i> (double-counting for powers). <i>n log(n)^-1</i> is
--   an approximation for <a>the number of primes below a number</a>.
--   Essentially, linear in the time it takes to factor the number.
divisors_number_is_perfect_square :: Integer -> [Integer]

-- | <i>O(k n log(n)^-1)</i>, where <i>k</i> is the number of primes
--   dividing <i>n</i> (double-counting for powers). <i>n log(n)^-1</i> is
--   an approximation for <a>the number of primes below a number</a>.
--   Essentially, linear in the time it takes to factor the number.
num_divisors :: Integer -> Integer

-- | <i>O(k n log(n)^-1)</i>, where <i>k</i> is the number of primes
--   dividing <i>n</i> (double-counting for powers). <i>n log(n)^-1</i> is
--   an approximation for <a>the number of primes below a number</a>.
--   Essentially, linear in the time it takes to factor the number.
num_divisors_of_n_squared_leq_n :: Integer -> Integer

-- | An infinite list of integers with irrational square roots.
irrational_squares :: [Integer]

-- | A list of fractions monotonically increasingly accurately
--   approximating the square root of the parameter, where each fraction is
--   represented as a pair of <tt>(numerator, denominator)</tt> See
--   <a>http://en.wikipedia.org/wiki/Convergent_(continued_fraction)</a>.
sqrt_convergents :: Integer -> [(Integer, Integer)]

-- | <i>O(k)</i> The <a>continued fraction</a> representation of the square
--   root of the parameter. <i>k</i> is the length of the continued
--   fraction.
continued_fraction_sqrt :: Integer -> [Integer]

-- | An infinite list of the terms of the continued fraction representation
--   of the square root of the given parameter.
continued_fraction_sqrt_infinite :: Integer -> [Integer]

-- | Determines whether the given integer is a square number.
square :: Integral a => a -> Bool

-- | Adds the second parameter by the third, mod the first. E.g.:
--   
--   <pre>
--   add_mod 5 3 4
--   </pre>
--   
--   <pre>
--   2
--   </pre>
add_mod :: Integral a => a -> a -> a -> a

-- | Subtracts the third parameter from the second, mod the first. E.g.:
--   
--   <pre>
--   sub_mod 5 16 7
--   </pre>
--   
--   <pre>
--   4
--   </pre>
sub_mod :: Integral a => a -> a -> a -> a

-- | Multiplies the second parameter by the third, mod the first. E.g.:
--   
--   <pre>
--   mul_mod 5 2 4
--   </pre>
--   
--   <pre>
--   3
--   </pre>
mul_mod :: Integral a => a -> a -> a -> a

-- | Divides the second parameter by the third, mod the first. More
--   explicitly, it multiplies the second by the multiplicative inverse of
--   the third, mod the first. E.g.:
--   
--   <pre>
--   div_mod 5 16 7
--   </pre>
--   
--   <pre>
--   Just 3
--   </pre>
--   
--   Note that only elements coprime to the modulus will have inverses; in
--   cases that do not match this criterion, we return Nothing.
div_mod :: Integral a => a -> a -> a -> Maybe a

-- | Like <tt>div_mod</tt>, but with the assurance that the modulus is
--   prime (i.e. denominator will have an inverse). Thus, the returnvalue
--   doesn't need to be wrapped in a <tt>Maybe</tt>.
div_mod_prime :: Integral a => a -> a -> a -> a

-- | <i>O(log_2 e)</i> Raises base <i>b</i> (2nd param) to exponent
--   <i>e</i> (3rd param) mod <i>m</i> (1st param). E.g.:
--   
--   <pre>
--   pow_mod 13 2 4
--   </pre>
--   
--   <pre>
--   3 
--   </pre>
pow_mod :: Integral a => a -> a -> a -> a

-- | <i>O(log m)</i> Computes the multiplicative inverse of the second
--   parameter, in the group <i>Z_m</i>, where <i>m</i> is the first
--   parameter. E.g.:
--   
--   <pre>
--   multiplicative_inverse 13 6
--   </pre>
--   
--   <pre>
--   Just 11
--   </pre>
--   
--   That is, 6 * 11 = 66, and 66 <a>mod</a> 13 == 1 . Note that only
--   elements coprime to the modulus will have inverses; in cases that do
--   not match this criterion, we return Nothing.
multiplicative_inverse :: Integral a => a -> a -> Maybe a

-- | An infinite list of the Fibonacci numbers.
fibs :: [Integer]

-- | Takes the square root of a perfect square.
sqrt_perfect_square :: Integer -> Integer

-- | Returns whether a <tt>Double</tt> value is an integer. For example,
--   <tt>16.0 :: Double</tt> is an integer, but not <tt>16.1</tt>.
is_int :: Double -> Bool

-- | <i>O(1)</i> Calculates whether <i>n</i> is the <i>e</i>^th power of
--   any integer, where <i>n</i> is the first parameter and <i>e</i> is the
--   second.
is_power_of_int :: Integer -> Integer -> Bool

-- | Converts a <tt>Double</tt> to an <tt>Integer</tt>.
double_to_int :: Double -> Integer

-- | <i>O(log_10(n))</i> Calculates the number of digits in an integer.
--   Relies on <tt>logBase</tt>, so gives wrong answer for very large
--   <tt>n</tt>.
num_digits :: Integer -> Integer

-- | <i>O(1)</i> Area of a triangle, where the parameters are the edge
--   lengths (Heron's formula).
tri_area :: Integer -> Integer -> Integer -> Double

-- | <i>O(1)</i> Area of a triangle, where the parameters are the edge
--   lengths (Heron's formula).
tri_area_double :: Double -> Double -> Double -> Double

-- | Solves a given system of linear equations. Can be subject to rounding
--   errors. Here's an example:
--   
--   <pre>
--   solve_linear_system [[2, 3, 4],[6, -3, 9],[2, 0, 1]] [20, -6, 8]
--   </pre>
--   
--   <pre>
--   [4.999999999999999,6.0,-2.0]
--   </pre>
solve_linear_system :: [[Double]] -> [Double] -> [Double]
