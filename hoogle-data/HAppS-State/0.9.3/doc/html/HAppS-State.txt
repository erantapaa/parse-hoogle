-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Event-based distributed state.
--   
--   Web framework
@package HAppS-State
@version 0.9.3

module HAppS.State.ComponentSystem
data End
End :: End
data (:+:) h t
(:+:) :: h -> t -> :+: h t
class (Serialize ev, Serialize res) => UpdateEvent ev res | ev -> res
class (Serialize ev, Serialize res) => QueryEvent ev res | ev -> res
data Method st
Update :: (ev -> Update st res) -> Method st
Query :: (ev -> Query st res) -> Method st
class Methods a
methods :: (Methods a) => Proxy a -> [Method a]
data MethodMap
MethodMap :: Map String (Method st) -> MethodMap
type ComponentTree = Map String MethodMap
type ComponentVersions = Map String [ByteString]
class (SubHandlers (Dependencies a), Serialize a) => Component a where { type family Dependencies a; { onLoad _ = return () } }
initialValue :: (Component a) => a
onLoad :: (Component a) => Proxy a -> IO ()
class SubHandlers a
subHandlers :: (SubHandlers a) => a -> Collect ()
data Collection
Collection :: ComponentTree -> ComponentVersions -> [IO ()] -> Collection
type Collect = State Collection
collectHandlers :: (Methods a, Component a) => Proxy a -> (ComponentTree, ComponentVersions, [IO ()])
collectHandlers' :: (Methods a, Component a) => Proxy a -> Collect ()
instance (Methods a, Component a, SubHandlers b) => SubHandlers (a :+: b)
instance SubHandlers End
instance Show MethodMap
instance Show (Method st)

module HAppS.State.ComponentTH
mkMethods :: Name -> [Name] -> Q [Dec]

module HAppS.State.Saver
data ReaderStream a
ReaderStream :: IO () -> IO ([a], Int) -> IO [a] -> ReaderStream a
readerClose :: ReaderStream a -> IO ()
readerGet :: ReaderStream a -> IO ([a], Int)
readerGetUncut :: ReaderStream a -> IO [a]
data WriterStream a
WriterStream :: IO () -> (a -> IO () -> IO ()) -> (a -> IO ()) -> IO Int -> WriterStream a
writerClose :: WriterStream a -> IO ()
writerAdd :: WriterStream a -> a -> IO () -> IO ()
writerAtomicReplace :: WriterStream a -> a -> IO ()
writerCut :: WriterStream a -> IO Int
data Saver

-- | A saver that discards all output
NullSaver :: Saver

-- | A saver that operates on files. The parameter is the prefix for the
--   files. Creates the prefix directory.
FileSaver :: String -> Saver

-- | Enable queueing.
Queue :: Saver -> Saver
Memory :: (MVar Store) -> Saver
createReader :: (Serialize a) => Saver -> String -> Int -> IO (ReaderStream a)
createWriter :: (Serialize a) => Saver -> String -> Int -> IO (WriterStream a)

module HAppS.State.Transaction
type ExceptionT = SomeException
getTime :: (Integral epochTime) => AnyEv epochTime
getEventClockTime :: AnyEv ClockTime
getEventId :: (Integral txId) => AnyEv txId
data GetCheckpointState
GetCheckpointState :: GetCheckpointState
newtype SetCheckpointState
SetCheckpointState :: ByteString -> SetCheckpointState
type TypeString = String
data EventHandler
UpdateHandler :: (TxContext -> ev -> IO ()) -> (ev -> IO res) -> (Object -> ev) -> EventHandler
QueryHandler :: (ev -> IO res) -> (Object -> ev) -> EventHandler
type EventMap = Map TypeString EventHandler
data EmitInternal
EmitInternal :: EventMap -> EmitInternal
emitRef :: IORef EmitInternal
emitFunc :: (Serialize ev, Typeable res) => EventMap -> TypeString -> ev -> IO res
emitEvent' :: (Serialize ev, Typeable res) => TypeString -> ev -> IO res
emitEvent :: (Serialize ev, Typeable res) => ev -> IO res
setNewEventMap :: EventMap -> IO ()
data EventItem
EventItem :: TxContext -> Dynamic -> EventItem
eventContext :: EventItem -> TxContext
eventData :: EventItem -> Dynamic
eventStreamRef :: MVar (Chan EventItem)
initEventStream :: IO ()
pushEventItem :: (Serialize ev) => TxContext -> ev -> IO ()
getEventStream :: IO (IO EventItem)
createEventMap :: (Methods st, Component st) => MVar TxControl -> Proxy st -> IO EventMap
extraEvents :: (Serialize st) => TxRun st -> EventMap
allStateTypes :: (Methods a, Component a) => Proxy a -> [TypeString]
componentVersions :: (Methods a, Component a) => Proxy a -> Map String [ByteString]
componentIO :: (Methods a, Component a) => Proxy a -> [IO ()]
createNewTxRun :: IO (TxRun st)
setNewState :: TypeString -> ByteString -> IO ()
getState :: TypeString -> IO ByteString
data SetNewState st
SetNewState :: ByteString -> SetNewState st
data GetState st
GetState :: GetState st

-- | Schedule an update and wait for it to complete. When this function
--   returns, you're guaranteed the update will be persistent.
update :: (MonadIO m, UpdateEvent ev res) => ev -> m res

-- | Emit a state query and wait for the result.
query :: (MonadIO m, QueryEvent ev res) => ev -> m res
quickQuery' :: (Serialize st) => TxRun st -> HR st -> IO ()
type Runner ev res = IO (IO ev, res -> IO ())
type EH i o = i -> IO o
data Event
Event :: ev -> Event
data IHR st
IHR :: TxContext -> ev -> (RunHandler st ev) -> IHR st
data HR st
HR :: ev -> (RunHandler st ev) -> HR st
type RunHandler st ev = TxContext -> st -> IO (Maybe st, IO ())
data Res a
Ok :: a -> Res a
Error :: ExceptionT -> Res a
type EventQueue st = TChan (HR st)
type ProcessQueue st = TChan (IHR st)
data TxRun st
TxRun :: !ProcessQueue st -> !TVar TxContext -> TxRun st
txProcessQueue :: TxRun st -> !ProcessQueue st
txLastTxContext :: TxRun st -> !TVar TxContext
type EvLoaders' st = Map String (ProcessQueue st -> ByteString -> IO (TxId, ByteString))
type EvLoaders = Map String (ByteString -> IO (TxId, ByteString))
setEvLoadersQueue :: ProcessQueue st -> EvLoaders' st -> EvLoaders
runObjectEvent :: Object -> IO Object
runObjectEventFunc :: Object -> EventMap -> IO Object
runColdEvent :: TxContext -> Object -> IO ()
runColdEventFunc :: TxContext -> Object -> EventMap -> IO ()
lookupEventHandler :: TypeString -> EventMap -> IO EventHandler
eventTString :: (Serialize ev) => ev -> TypeString
handleEvent :: (st -> Env -> Ev m res -> STM intermediate) -> (st -> intermediate -> IO (Maybe st, res)) -> (Either ExceptionT res -> IO ()) -> Ev m res -> RunHandler st ev
handleQuery :: (Either ExceptionT res -> IO ()) -> Query st res -> RunHandler st ev
handleUpdate :: (Either ExceptionT res -> IO ()) -> Update st res -> RunHandler st ev
checkDiff :: a -> a -> IO (Maybe a)
getEpochMilli :: IO EpochMilli
newTxContext :: IO TxContext
addTxId :: TxRun st -> TxContext -> STM TxContext
globalRandomGen :: MVar StdGen
data TxConfig
TxConfig :: Seconds -> OperationMode -> Int -> Int -> Int -> TxConfig

-- | Perform checkpoint at least every N seconds.
txcCheckpointSeconds :: TxConfig -> Seconds
txcOperationMode :: TxConfig -> OperationMode

-- | Number of active nodes in the cluster (not counting this node).
txcClusterSize :: TxConfig -> Int
txcClusterPort :: TxConfig -> Int

-- | Commits per second. Only applies to cluster mode.
txcCommitFrequency :: TxConfig -> Int
data TxControl
TxControl :: Saver -> MVar (WriterStream EventLogEntry) -> [String] -> Map String [ByteString] -> [(ThreadId, MVar ())] -> TxControl

-- | Saver given by the user.
ctlSaver :: TxControl -> Saver
ctlEventSaver :: TxControl -> MVar (WriterStream EventLogEntry)

-- | Types of each component used.
ctlAllComponents :: TxControl -> [String]

-- | Map listing all versions of a component
ctlComponentVersions :: TxControl -> Map String [ByteString]
ctlChildren :: TxControl -> [(ThreadId, MVar ())]
data EventLogEntry
EventLogEntry :: TxContext -> Object -> EventLogEntry
data OperationMode
SingleMode :: OperationMode
ClusterMode :: String -> OperationMode
nullTxConfig :: TxConfig
runTxLoop :: MVar (WriterStream EventLogEntry) -> ProcessQueue st -> st -> IO ()
instance Typeable EventLogEntry
instance Typeable1 GetState
instance Typeable1 SetNewState
instance Show EventLogEntry
instance Serialize EventLogEntry
instance Version EventLogEntry
instance (Typeable st) => QueryEvent (GetState st) ByteString
instance (Typeable st) => UpdateEvent (SetNewState st) ()
instance (Typeable st) => Serialize (GetState st)
instance Version (GetState st)
instance (Typeable st) => Serialize (SetNewState st)
instance Version (SetNewState st)
instance UpdateEvent SetCheckpointState ()
instance QueryEvent GetCheckpointState ByteString
instance Serialize StdGen
instance Version StdGen
instance Serialize SetCheckpointState
instance Typeable SetCheckpointState
instance Version SetCheckpointState
instance Serialize GetCheckpointState
instance Typeable GetCheckpointState
instance Version GetCheckpointState
instance Serialize TxContext
instance Version TxContext

module HAppS.State.Control

-- | Wait for a signal. On unix, a signal is sigINT or sigTERM. On windows,
--   the signal is entering e.
waitForTermination :: IO ()
instance Show Flag
instance Read Target
instance Show Target
instance Eq Target
instance Ord Target
instance LogHandler NullLogger

module HAppS.State

-- | Monad for ACID event handlers.
data Ev m t

-- | ACID computations that work with any state and event types.
type AnyEv a = forall t. (Monad (t STM), MonadTrans t) => Ev (t STM) a
data TxControl

-- | Emit a state query and wait for the result.
query :: (MonadIO m, QueryEvent ev res) => ev -> m res

-- | Schedule an update and wait for it to complete. When this function
--   returns, you're guaranteed the update will be persistent.
update :: (MonadIO m, UpdateEvent ev res) => ev -> m res
type Update state = Ev (StateT state STM)
type Query state = Ev (ReaderT state STM)
type TxId = Int64
type EpochMilli = Int64
data TxConfig
TxConfig :: Seconds -> OperationMode -> Int -> Int -> Int -> TxConfig

-- | Perform checkpoint at least every N seconds.
txcCheckpointSeconds :: TxConfig -> Seconds
txcOperationMode :: TxConfig -> OperationMode

-- | Number of active nodes in the cluster (not counting this node).
txcClusterSize :: TxConfig -> Int
txcClusterPort :: TxConfig -> Int

-- | Commits per second. Only applies to cluster mode.
txcCommitFrequency :: TxConfig -> Int
nullTxConfig :: TxConfig
data Saver

-- | A saver that discards all output
NullSaver :: Saver

-- | A saver that operates on files. The parameter is the prefix for the
--   files. Creates the prefix directory.
FileSaver :: String -> Saver

-- | Enable queueing.
Queue :: Saver -> Saver
Memory :: (MVar Store) -> Saver

-- | Use a proxy to force the type of an update action.
setUpdateType :: Proxy t -> Update t ()

-- | Use a proxy to force the type of a query action.
setQueryType :: Proxy t -> Query t ()

-- | Currying version of <a>setUpdateType</a>.
asUpdate :: Update t a -> Proxy t -> Update t a

-- | Currying version of <a>setQueryType</a>.
asQuery :: Query t a -> Proxy t -> Query t a

-- | Specialized version of <a>ask</a>
askState :: Query st st

-- | Specialized version of <a>get</a>
getState :: Update st st

-- | Specialized version of <a>put</a>.
putState :: st -> Update st ()

-- | Lift an STM action into Ev.
liftSTM :: STM a -> AnyEv a
class CatchEv m
catchEv :: (CatchEv m) => Ev m a -> (SomeException -> a) -> Ev m a

-- | Select a part of the environment.
sel :: (Env -> b) -> AnyEv b

-- | Run a computation with a local environment.
--   
--   Run a computation with local state. Changes to state will be visible
--   to outside.
localState :: (outer -> inner) -> (inner -> outer -> outer) -> Ev (StateT inner STM) a -> Ev (StateT outer STM) a

-- | Run a computation with local state.
localStateReader :: (outer -> inner) -> Ev (ReaderT inner STM) a -> Ev (ReaderT outer STM) a

-- | Execute a Query action in the Update monad.
runQuery :: Query st a -> Update st a
getEventId :: (Integral txId) => AnyEv txId
getTime :: (Integral epochTime) => AnyEv epochTime
getEventClockTime :: AnyEv ClockTime
getEventStream :: IO (IO EventItem)
data EventItem
EventItem :: TxContext -> Dynamic -> EventItem
eventContext :: EventItem -> TxContext
eventData :: EventItem -> Dynamic

-- | Get a random number.
getRandom :: (Random a) => AnyEv a

-- | Get a random number inside the range.
getRandomR :: (Random a) => (a, a) -> AnyEv a

-- | Infer updating functions for a record <tt>a_foo :: component -&gt;
--   record -&gt; record</tt> and <tt>withFoo = localState foo a_foo</tt>.
inferRecordUpdaters :: Name -> Q [Dec]

-- | Run a transaction system
runTxSystem :: (Methods st, Component st) => Saver -> Proxy st -> IO (MVar TxControl)
runTxSystem' :: (Methods st, Component st) => Bool -> Saver -> Proxy st -> IO (MVar TxControl)
shutdownSystem :: MVar TxControl -> IO ()
closeTxControl :: MVar TxControl -> IO ()
createCheckpoint :: MVar TxControl -> IO ()
unsafeIOToEv :: IO a -> AnyEv a
