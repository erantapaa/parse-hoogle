-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer
--   
@package haskell-src-exts
@version 1.16.0.1


-- | A suite of datatypes describing the (semi-concrete) abstract syntax of
--   Haskell 98 <a>http://www.haskell.org/onlinereport/</a> plus registered
--   extensions, including:
--   
--   <ul>
--   <li>multi-parameter type classes with functional dependencies
--   (MultiParamTypeClasses, FunctionalDependencies)</li>
--   <li>parameters of type class assertions are unrestricted
--   (FlexibleContexts)</li>
--   <li><tt>forall</tt> types as universal and existential quantification
--   (RankNTypes, ExistentialQuantification, etc)</li>
--   <li>pattern guards (PatternGuards)</li>
--   <li>implicit parameters (ImplicitParameters)</li>
--   <li>generalised algebraic data types (GADTs)</li>
--   <li>template haskell (TemplateHaskell)</li>
--   <li>empty data type declarations (EmptyDataDecls)</li>
--   <li>unboxed tuples (UnboxedTuples)</li>
--   <li>regular patterns (RegularPatterns)</li>
--   <li>HSP-style XML expressions and patterns (XmlSyntax)</li>
--   </ul>
--   
--   All nodes in the syntax tree are annotated with something of a
--   user-definable data type. When parsing, this annotation will contain
--   information about the source location that the particular node comes
--   from.
module Language.Haskell.Exts.Annotated.Syntax

-- | A complete Haskell source module.
data Module l

-- | an ordinary Haskell module
Module :: l -> (Maybe (ModuleHead l)) -> [ModulePragma l] -> [ImportDecl l] -> [Decl l] -> Module l

-- | a module consisting of a single XML document. The ModuleName never
--   appears in the source but is needed for semantic purposes, it will be
--   the same as the file name.
XmlPage :: l -> (ModuleName l) -> [ModulePragma l] -> (XName l) -> [XAttr l] -> (Maybe (Exp l)) -> [Exp l] -> Module l

-- | a hybrid module combining an XML document with an ordinary module
XmlHybrid :: l -> (Maybe (ModuleHead l)) -> [ModulePragma l] -> [ImportDecl l] -> [Decl l] -> (XName l) -> [XAttr l] -> (Maybe (Exp l)) -> [Exp l] -> Module l

-- | The head of a module, including the name and export specification.
data ModuleHead l
ModuleHead :: l -> (ModuleName l) -> (Maybe (WarningText l)) -> (Maybe (ExportSpecList l)) -> ModuleHead l

-- | Warning text to optionally use in the module header of e.g. a
--   deprecated module.
data WarningText l
DeprText :: l -> String -> WarningText l
WarnText :: l -> String -> WarningText l

-- | An explicit export specification.
data ExportSpecList l
ExportSpecList :: l -> [ExportSpec l] -> ExportSpecList l

-- | An item in a module's export specification.
data ExportSpec l

-- | variable.
EVar :: l -> (Namespace l) -> (QName l) -> ExportSpec l

-- | <tt>T</tt>: a class or datatype exported abstractly, or a type
--   synonym.
EAbs :: l -> (QName l) -> ExportSpec l

-- | <tt>T(..)</tt>: a class exported with all of its methods, or a
--   datatype exported with all of its constructors.
EThingAll :: l -> (QName l) -> ExportSpec l

-- | <tt>T(C_1,...,C_n)</tt>: a class exported with some of its methods, or
--   a datatype exported with some of its constructors.
EThingWith :: l -> (QName l) -> [CName l] -> ExportSpec l

-- | <tt>module M</tt>: re-export a module.
EModuleContents :: l -> (ModuleName l) -> ExportSpec l

-- | An import declaration.
data ImportDecl l
ImportDecl :: l -> ModuleName l -> Bool -> Bool -> Bool -> Maybe String -> Maybe (ModuleName l) -> Maybe (ImportSpecList l) -> ImportDecl l

-- | annotation, used by parser for position of the <tt>import</tt>
--   keyword.
importAnn :: ImportDecl l -> l

-- | name of the module imported.
importModule :: ImportDecl l -> ModuleName l

-- | imported <tt>qualified</tt>?
importQualified :: ImportDecl l -> Bool

-- | imported with <tt>{-# SOURCE #-}</tt>?
importSrc :: ImportDecl l -> Bool

-- | Import <tt>safe</tt>?
importSafe :: ImportDecl l -> Bool

-- | imported with explicit package name
importPkg :: ImportDecl l -> Maybe String

-- | optional alias name in an <tt>as</tt> clause.
importAs :: ImportDecl l -> Maybe (ModuleName l)

-- | optional list of import specifications.
importSpecs :: ImportDecl l -> Maybe (ImportSpecList l)

-- | An explicit import specification list.
data ImportSpecList l
ImportSpecList :: l -> Bool -> [ImportSpec l] -> ImportSpecList l

-- | An import specification, representing a single explicit item imported
--   (or hidden) from a module.
data ImportSpec l

-- | variable
IVar :: l -> (Namespace l) -> (Name l) -> ImportSpec l

-- | <tt>T</tt>: the name of a class, datatype or type synonym.
IAbs :: l -> (Name l) -> ImportSpec l

-- | <tt>T(..)</tt>: a class imported with all of its methods, or a
--   datatype imported with all of its constructors.
IThingAll :: l -> (Name l) -> ImportSpec l

-- | <tt>T(C_1,...,C_n)</tt>: a class imported with some of its methods, or
--   a datatype imported with some of its constructors.
IThingWith :: l -> (Name l) -> [CName l] -> ImportSpec l

-- | Associativity of an operator.
data Assoc l

-- | non-associative operator (declared with <tt>infix</tt>)
AssocNone :: l -> Assoc l

-- | left-associative operator (declared with <tt>infixl</tt>).
AssocLeft :: l -> Assoc l

-- | right-associative operator (declared with <tt>infixr</tt>)
AssocRight :: l -> Assoc l

-- | Namespaces for imports/exports.
data Namespace l
NoNamespace :: l -> Namespace l
TypeNamespace :: l -> Namespace l

-- | A top-level declaration.
data Decl l

-- | A type declaration
TypeDecl :: l -> (DeclHead l) -> (Type l) -> Decl l

-- | A type family declaration
TypeFamDecl :: l -> (DeclHead l) -> (Maybe (Kind l)) -> Decl l

-- | A closed type family declaration
ClosedTypeFamDecl :: l -> (DeclHead l) -> (Maybe (Kind l)) -> [TypeEqn l] -> Decl l

-- | A data OR newtype declaration
DataDecl :: l -> (DataOrNew l) -> (Maybe (Context l)) -> (DeclHead l) -> [QualConDecl l] -> (Maybe (Deriving l)) -> Decl l

-- | A data OR newtype declaration, GADT style
GDataDecl :: l -> (DataOrNew l) -> (Maybe (Context l)) -> (DeclHead l) -> (Maybe (Kind l)) -> [GadtDecl l] -> (Maybe (Deriving l)) -> Decl l

-- | A data family declaration
DataFamDecl :: l -> (Maybe (Context l)) -> (DeclHead l) -> (Maybe (Kind l)) -> Decl l

-- | A type family instance declaration
TypeInsDecl :: l -> (Type l) -> (Type l) -> Decl l

-- | A data family instance declaration
DataInsDecl :: l -> (DataOrNew l) -> (Type l) -> [QualConDecl l] -> (Maybe (Deriving l)) -> Decl l

-- | A data family instance declaration, GADT style
GDataInsDecl :: l -> (DataOrNew l) -> (Type l) -> (Maybe (Kind l)) -> [GadtDecl l] -> (Maybe (Deriving l)) -> Decl l

-- | A declaration of a type class
ClassDecl :: l -> (Maybe (Context l)) -> (DeclHead l) -> [FunDep l] -> (Maybe [ClassDecl l]) -> Decl l

-- | An declaration of a type class instance
InstDecl :: l -> (Maybe (Overlap l)) -> (InstRule l) -> (Maybe [InstDecl l]) -> Decl l

-- | A standalone deriving declaration
DerivDecl :: l -> (Maybe (Overlap l)) -> (InstRule l) -> Decl l

-- | A declaration of operator fixity
InfixDecl :: l -> (Assoc l) -> (Maybe Int) -> [Op l] -> Decl l

-- | A declaration of default types
DefaultDecl :: l -> [Type l] -> Decl l

-- | A Template Haskell splicing declaration
SpliceDecl :: l -> (Exp l) -> Decl l

-- | A type signature declaration
TypeSig :: l -> [Name l] -> (Type l) -> Decl l

-- | A set of function binding clauses
FunBind :: l -> [Match l] -> Decl l

-- | A pattern binding
PatBind :: l -> (Pat l) -> (Rhs l) -> (Maybe (Binds l)) -> Decl l

-- | A foreign import declaration
ForImp :: l -> (CallConv l) -> (Maybe (Safety l)) -> (Maybe String) -> (Name l) -> (Type l) -> Decl l

-- | A foreign export declaration
ForExp :: l -> (CallConv l) -> (Maybe String) -> (Name l) -> (Type l) -> Decl l

-- | A RULES pragma
RulePragmaDecl :: l -> [Rule l] -> Decl l

-- | A DEPRECATED pragma
DeprPragmaDecl :: l -> [([Name l], String)] -> Decl l

-- | A WARNING pragma
WarnPragmaDecl :: l -> [([Name l], String)] -> Decl l

-- | An INLINE pragma
InlineSig :: l -> Bool -> (Maybe (Activation l)) -> (QName l) -> Decl l

-- | An INLINE CONLIKE pragma
InlineConlikeSig :: l -> (Maybe (Activation l)) -> (QName l) -> Decl l

-- | A SPECIALISE pragma
SpecSig :: l -> (Maybe (Activation l)) -> (QName l) -> [Type l] -> Decl l

-- | A SPECIALISE INLINE pragma
SpecInlineSig :: l -> Bool -> (Maybe (Activation l)) -> (QName l) -> [Type l] -> Decl l

-- | A SPECIALISE instance pragma
InstSig :: l -> (InstRule l) -> Decl l

-- | An ANN pragma
AnnPragma :: l -> (Annotation l) -> Decl l

-- | A MINIMAL pragma
MinimalPragma :: l -> (Maybe (BooleanFormula l)) -> Decl l

-- | The head of a type or class declaration, which consists of the type or
--   class name applied to some type variables
--   
--   <tt>class C a b</tt> is represented as
--   
--   <pre>
--   DHApp
--      ()
--      (DHApp
--         () (DHead () (Ident () "C")) (UnkindedVar () (Ident () "a")))
--      (UnkindedVar () (Ident () "b"))
--   </pre>
--   
--   (where the annotation type <tt>l</tt> is instantiated with
--   <tt>()</tt>)
--   
--   <tt>class (a :&lt; b) c</tt> is represented as
--   
--   <pre>
--   DHApp
--      ()
--      (DHParen
--         ()
--         (DHApp
--            ()
--            (DHInfix () (UnkindedVar () (Ident () "a")) (Symbol () ":&lt;"))
--            (UnkindedVar () (Ident () "b"))))
--      (UnkindedVar () (Ident () "c"))
--   </pre>
data DeclHead l

-- | type or class name
DHead :: l -> (Name l) -> DeclHead l

-- | infix application of the type/class name to the left operand
DHInfix :: l -> (TyVarBind l) -> (Name l) -> DeclHead l

-- | parenthesized declaration head
DHParen :: l -> (DeclHead l) -> DeclHead l

-- | application to one more type variable
DHApp :: l -> (DeclHead l) -> (TyVarBind l) -> DeclHead l

-- | The instance declaration rule, which is, roughly, the part of the
--   instance declaration before the <tt>where</tt> keyword.
--   
--   Example: <tt>instance Ord a =&gt; Ord (Maybe a)</tt> is represented as
--   
--   <pre>
--   IRule
--      ()
--      Nothing
--      (Just
--         (CxSingle
--            ()
--            (ClassA
--               () (UnQual () (Ident () "Ord")) [ TyVar () (Ident () "a") ])))
--      (IHApp
--         ()
--         (IHCon () (UnQual () (Ident () "Ord")))
--         (TyParen
--            ()
--            (TyApp
--               ()
--               (TyCon () (UnQual () (Ident () "Maybe")))
--               (TyVar () (Ident () "a")))))
--   </pre>
--   
--   An optional explicit forall after <tt>instance</tt> is supported:
--   <tt>instance forall a . Ord a =&gt; Ord (Maybe a) where</tt> becomes
--   
--   <pre>
--   IRule
--      ()
--      (Just [ UnkindedVar () (Ident () "a") ])
--      ...
--   </pre>
data InstRule l
IRule :: l -> (Maybe [TyVarBind l]) -> (Maybe (Context l)) -> (InstHead l) -> InstRule l
IParen :: l -> (InstRule l) -> InstRule l

-- | The instance head. The split between rule/head allow us to represent
--   <tt>instance (Bounded a =&gt; Bounded [a]) where</tt> faithfully.
--   
--   The structure of <a>InstHead</a> follows one of <a>DeclHead</a>.
--   
--   For example, <tt>instance C (Maybe a) Int where</tt> is represented as
--   
--   <pre>
--   IHApp
--      ()
--      (IHApp
--         ()
--         (IHCon () (UnQual () (Ident () "C")))
--         (TyParen
--            ()
--            (TyApp
--               ()
--               (TyCon () (UnQual () (Ident () "Maybe")))
--               (TyVar () (Ident () "a")))))
--      (TyCon () (UnQual () (Ident () "Int")))))
--   </pre>
data InstHead l

-- | type or class name
IHCon :: l -> (QName l) -> InstHead l

-- | infix application of the type/class name to the left operand
IHInfix :: l -> (Type l) -> (QName l) -> InstHead l

-- | parenthesized instance head
IHParen :: l -> (InstHead l) -> InstHead l

-- | application to one more type
IHApp :: l -> (InstHead l) -> (Type l) -> InstHead l

-- | A binding group inside a <tt>let</tt> or <tt>where</tt> clause.
data Binds l

-- | An ordinary binding group
BDecls :: l -> [Decl l] -> Binds l

-- | A binding group for implicit parameters
IPBinds :: l -> [IPBind l] -> Binds l

-- | A binding of an implicit parameter.
data IPBind l
IPBind :: l -> (IPName l) -> (Exp l) -> IPBind l

-- | Declarations inside a class declaration.
data ClassDecl l

-- | ordinary declaration
ClsDecl :: l -> (Decl l) -> ClassDecl l

-- | declaration of an associated data type
ClsDataFam :: l -> (Maybe (Context l)) -> (DeclHead l) -> (Maybe (Kind l)) -> ClassDecl l

-- | declaration of an associated type synonym
ClsTyFam :: l -> (DeclHead l) -> (Maybe (Kind l)) -> ClassDecl l

-- | default choice for an associated type synonym
ClsTyDef :: l -> (Type l) -> (Type l) -> ClassDecl l

-- | default signature
ClsDefSig :: l -> (Name l) -> (Type l) -> ClassDecl l

-- | Declarations inside an instance declaration.
data InstDecl l

-- | ordinary declaration
InsDecl :: l -> (Decl l) -> InstDecl l

-- | an associated type definition
InsType :: l -> (Type l) -> (Type l) -> InstDecl l

-- | an associated data type implementation
InsData :: l -> (DataOrNew l) -> (Type l) -> [QualConDecl l] -> (Maybe (Deriving l)) -> InstDecl l

-- | an associated data type implemented using GADT style
InsGData :: l -> (DataOrNew l) -> (Type l) -> (Maybe (Kind l)) -> [GadtDecl l] -> (Maybe (Deriving l)) -> InstDecl l

-- | A deriving clause following a data type declaration.
data Deriving l
Deriving :: l -> [InstRule l] -> Deriving l

-- | A flag stating whether a declaration is a data or newtype declaration.
data DataOrNew l
DataType :: l -> DataOrNew l
NewType :: l -> DataOrNew l

-- | Declaration of an ordinary data constructor.
data ConDecl l

-- | ordinary data constructor
ConDecl :: l -> (Name l) -> [Type l] -> ConDecl l

-- | infix data constructor
InfixConDecl :: l -> (Type l) -> (Name l) -> (Type l) -> ConDecl l

-- | record constructor
RecDecl :: l -> (Name l) -> [FieldDecl l] -> ConDecl l

-- | Declaration of a (list of) named field(s).
data FieldDecl l
FieldDecl :: l -> [Name l] -> (Type l) -> FieldDecl l

-- | A single constructor declaration within a data type declaration, which
--   may have an existential quantification binding.
data QualConDecl l
QualConDecl :: l -> (Maybe [TyVarBind l]) -> (Maybe (Context l)) -> (ConDecl l) -> QualConDecl l

-- | A single constructor declaration in a GADT data type declaration.
--   
--   If the GADT is declared using the record syntax, e.g.
--   
--   <pre>
--   data Ty where
--     TCon :: { field1 :: Int, field2 :: Bool } -&gt; Ty
--   </pre>
--   
--   then the fields are stored as a list of <a>FieldDecl</a>s, and the
--   final type (<tt>Ty</tt> in the above example) is stored in the last
--   <a>Type</a> field.
--   
--   If the GADT is declared using the ordinary syntax, e.g.
--   
--   <pre>
--   data Ty where
--     TCon :: Int -&gt; Bool -&gt; Ty
--   </pre>
--   
--   then <tt><a>Maybe</a> [<a>FieldDecl</a> l]</tt> is <a>Nothing</a>, and
--   the whole constructor's type (such as <tt>Int -&gt; Bool -&gt;
--   Ty</tt>) is stored in the last <a>Type</a> field.
data GadtDecl l
GadtDecl :: l -> (Name l) -> (Maybe [FieldDecl l]) -> (Type l) -> GadtDecl l

-- | The type of a constructor argument or field, optionally including a
--   strictness annotation.
data BangType l

-- | strict component, marked with "<tt>!</tt>"
BangedTy :: l -> BangType l

-- | unboxed component, marked with an UNPACK pragma
UnpackedTy :: l -> BangType l

-- | Clauses of a function binding.
data Match l

-- | A clause defined with prefix notation, i.e. the function name followed
--   by its argument patterns, the right-hand side and an optional where
--   clause.
Match :: l -> (Name l) -> [Pat l] -> (Rhs l) -> (Maybe (Binds l)) -> Match l

-- | A clause defined with infix notation, i.e. first its first argument
--   pattern, then the function name, then its following argument(s), the
--   right-hand side and an optional where clause. Note that there can be
--   more than two arguments to a function declared infix, hence the list
--   of pattern arguments.
InfixMatch :: l -> (Pat l) -> (Name l) -> [Pat l] -> (Rhs l) -> (Maybe (Binds l)) -> Match l

-- | The right hand side of a function binding, pattern binding, or a case
--   alternative.
data Rhs l

-- | unguarded right hand side (<i>exp</i>)
UnGuardedRhs :: l -> (Exp l) -> Rhs l

-- | guarded right hand side (<i>gdrhs</i>)
GuardedRhss :: l -> [GuardedRhs l] -> Rhs l

-- | A guarded right hand side <tt>|</tt> <i>stmts</i> <tt>=</tt>
--   <i>exp</i>, or <tt>|</tt> <i>stmts</i> <tt>-&gt;</tt> <i>exp</i> for
--   case alternatives. The guard is a series of statements when using
--   pattern guards, otherwise it will be a single qualifier expression.
data GuardedRhs l
GuardedRhs :: l -> [Stmt l] -> (Exp l) -> GuardedRhs l

-- | A context is a set of assertions
data Context l
CxSingle :: l -> (Asst l) -> Context l
CxTuple :: l -> [Asst l] -> Context l
CxEmpty :: l -> Context l

-- | A functional dependency, given on the form l1 l2 ... ln -&gt; r2 r3 ..
--   rn
data FunDep l
FunDep :: l -> [Name l] -> [Name l] -> FunDep l

-- | Class assertions. In Haskell 98, the argument would be a <i>tyvar</i>,
--   but this definition allows multiple parameters, and allows them to be
--   <i>type</i>s. Also extended with support for implicit parameters and
--   equality constraints.
data Asst l

-- | ordinary class assertion
ClassA :: l -> (QName l) -> [Type l] -> Asst l

-- | constraint kind assertion, <tt>Dict :: cxt =&gt; Dict cxt</tt>
VarA :: l -> (Name l) -> Asst l

-- | class assertion where the class name is given infix
InfixA :: l -> (Type l) -> (QName l) -> (Type l) -> Asst l

-- | implicit parameter assertion
IParam :: l -> (IPName l) -> (Type l) -> Asst l

-- | type equality constraint
EqualP :: l -> (Type l) -> (Type l) -> Asst l

-- | parenthesised class assertion
ParenA :: l -> (Asst l) -> Asst l

-- | A type qualified with a context. An unqualified type has an empty
--   context.
data Type l

-- | qualified type
TyForall :: l -> (Maybe [TyVarBind l]) -> (Maybe (Context l)) -> (Type l) -> Type l

-- | function type
TyFun :: l -> (Type l) -> (Type l) -> Type l

-- | tuple type, possibly boxed
TyTuple :: l -> Boxed -> [Type l] -> Type l

-- | list syntax, e.g. [a], as opposed to [] a
TyList :: l -> (Type l) -> Type l

-- | parallel array syntax, e.g. [:a:]
TyParArray :: l -> (Type l) -> Type l

-- | application of a type constructor
TyApp :: l -> (Type l) -> (Type l) -> Type l

-- | type variable
TyVar :: l -> (Name l) -> Type l

-- | named type or type constructor
TyCon :: l -> (QName l) -> Type l

-- | type surrounded by parentheses
TyParen :: l -> (Type l) -> Type l

-- | infix type constructor
TyInfix :: l -> (Type l) -> (QName l) -> (Type l) -> Type l

-- | type with explicit kind signature
TyKind :: l -> (Type l) -> (Kind l) -> Type l

-- | <tt>'K</tt>, a promoted data type (-XDataKinds).
TyPromoted :: l -> (Promoted l) -> Type l

-- | type equality predicate enabled by ConstraintKinds
TyEquals :: l -> (Type l) -> (Type l) -> Type l

-- | template haskell splice type
TySplice :: l -> (Splice l) -> Type l

-- | Strict type marked with "<tt>!</tt>" or type marked with UNPACK
--   pragma.
TyBang :: l -> (BangType l) -> (Type l) -> Type l

-- | Flag denoting whether a tuple is boxed or unboxed.
data Boxed
Boxed :: Boxed
Unboxed :: Boxed

-- | An explicit kind annotation.
data Kind l

-- | <tt>*</tt>, the kind of types
KindStar :: l -> Kind l

-- | <tt>!</tt>, the kind of unboxed types
KindBang :: l -> Kind l

-- | <tt>-&gt;</tt>, the kind of a type constructor
KindFn :: l -> (Kind l) -> (Kind l) -> Kind l

-- | a parenthesised kind
KindParen :: l -> (Kind l) -> Kind l

-- | <tt>k</tt>, a kind variable (-XPolyKinds)
KindVar :: l -> (QName l) -> Kind l

-- | <pre>
--   k1 k2
--   </pre>
KindApp :: l -> (Kind l) -> (Kind l) -> Kind l

-- | <tt>'(k1,k2,k3)</tt>, a promoted tuple
KindTuple :: l -> [Kind l] -> Kind l

-- | <tt>'[k1,k2,k3]</tt>, a promoted list literal
KindList :: l -> [Kind l] -> Kind l

-- | A type variable declaration, optionally with an explicit kind
--   annotation.
data TyVarBind l

-- | variable binding with kind annotation
KindedVar :: l -> (Name l) -> (Kind l) -> TyVarBind l

-- | ordinary variable binding
UnkindedVar :: l -> (Name l) -> TyVarBind l

-- | Bools here are True if there was a leading quote which may be left
--   out. For example <tt>'[k1,k2]</tt> means the same thing as
--   <tt>[k1,k2]</tt>.
data Promoted l

-- | parsed value and raw string
PromotedInteger :: l -> Integer -> String -> Promoted l

-- | parsed value and raw string
PromotedString :: l -> String -> String -> Promoted l
PromotedCon :: l -> Bool -> (QName l) -> Promoted l
PromotedList :: l -> Bool -> [Promoted l] -> Promoted l
PromotedTuple :: l -> [Promoted l] -> Promoted l
PromotedUnit :: l -> Promoted l

-- | A type equation as found in closed type families.
data TypeEqn l
TypeEqn :: l -> (Type l) -> (Type l) -> TypeEqn l

-- | Haskell expressions.
data Exp l

-- | variable
Var :: l -> (QName l) -> Exp l

-- | implicit parameter variable
IPVar :: l -> (IPName l) -> Exp l

-- | data constructor
Con :: l -> (QName l) -> Exp l

-- | literal constant
Lit :: l -> (Literal l) -> Exp l

-- | infix application
InfixApp :: l -> (Exp l) -> (QOp l) -> (Exp l) -> Exp l

-- | ordinary application
App :: l -> (Exp l) -> (Exp l) -> Exp l

-- | negation expression <tt>-<i>exp</i></tt> (unary minus)
NegApp :: l -> (Exp l) -> Exp l

-- | lambda expression
Lambda :: l -> [Pat l] -> (Exp l) -> Exp l

-- | local declarations with <tt>let</tt> ... <tt>in</tt> ...
Let :: l -> (Binds l) -> (Exp l) -> Exp l

-- | <tt>if</tt> <i>exp</i> <tt>then</tt> <i>exp</i> <tt>else</tt>
--   <i>exp</i>
If :: l -> (Exp l) -> (Exp l) -> (Exp l) -> Exp l

-- | <tt>if</tt> <tt>|</tt> <i>stmts</i> <tt>-&gt;</tt> <i>exp</i> ...
MultiIf :: l -> [GuardedRhs l] -> Exp l

-- | <tt>case</tt> <i>exp</i> <tt>of</tt> <i>alts</i>
Case :: l -> (Exp l) -> [Alt l] -> Exp l

-- | <tt>do</tt>-expression: the last statement in the list should be an
--   expression.
Do :: l -> [Stmt l] -> Exp l

-- | <tt>mdo</tt>-expression
MDo :: l -> [Stmt l] -> Exp l

-- | tuple expression
Tuple :: l -> Boxed -> [Exp l] -> Exp l

-- | tuple section expression, e.g. <tt>(,,3)</tt>
TupleSection :: l -> Boxed -> [Maybe (Exp l)] -> Exp l

-- | list expression
List :: l -> [Exp l] -> Exp l

-- | parallel array expression
ParArray :: l -> [Exp l] -> Exp l

-- | parenthesised expression
Paren :: l -> (Exp l) -> Exp l

-- | left section <tt>(</tt><i>exp</i> <i>qop</i><tt>)</tt>
LeftSection :: l -> (Exp l) -> (QOp l) -> Exp l

-- | right section <tt>(</tt><i>qop</i> <i>exp</i><tt>)</tt>
RightSection :: l -> (QOp l) -> (Exp l) -> Exp l

-- | record construction expression
RecConstr :: l -> (QName l) -> [FieldUpdate l] -> Exp l

-- | record update expression
RecUpdate :: l -> (Exp l) -> [FieldUpdate l] -> Exp l

-- | unbounded arithmetic sequence, incrementing by 1: <tt>[from ..]</tt>
EnumFrom :: l -> (Exp l) -> Exp l

-- | bounded arithmetic sequence, incrementing by 1 <tt>[from .. to]</tt>
EnumFromTo :: l -> (Exp l) -> (Exp l) -> Exp l

-- | unbounded arithmetic sequence, with first two elements given
--   <tt>[from, then ..]</tt>
EnumFromThen :: l -> (Exp l) -> (Exp l) -> Exp l

-- | bounded arithmetic sequence, with first two elements given <tt>[from,
--   then .. to]</tt>
EnumFromThenTo :: l -> (Exp l) -> (Exp l) -> (Exp l) -> Exp l

-- | Parallel array bounded arithmetic sequence, incrementing by 1
--   <tt>[:from .. to:]</tt>
ParArrayFromTo :: l -> (Exp l) -> (Exp l) -> Exp l

-- | bounded arithmetic sequence, with first two elements given <tt>[:from,
--   then .. to:]</tt>
ParArrayFromThenTo :: l -> (Exp l) -> (Exp l) -> (Exp l) -> Exp l

-- | ordinary list comprehension
ListComp :: l -> (Exp l) -> [QualStmt l] -> Exp l

-- | parallel list comprehension
ParComp :: l -> (Exp l) -> [[QualStmt l]] -> Exp l

-- | parallel array comprehension
ParArrayComp :: l -> (Exp l) -> [[QualStmt l]] -> Exp l

-- | expression with explicit type signature
ExpTypeSig :: l -> (Exp l) -> (Type l) -> Exp l

-- | <tt>'x</tt> for template haskell reifying of expressions
VarQuote :: l -> (QName l) -> Exp l

-- | <tt>''T</tt> for template haskell reifying of types
TypQuote :: l -> (QName l) -> Exp l

-- | template haskell bracket expression
BracketExp :: l -> (Bracket l) -> Exp l

-- | template haskell splice expression
SpliceExp :: l -> (Splice l) -> Exp l

-- | quasi-quotaion: <tt>[$<i>name</i>| <i>string</i> |]</tt>
QuasiQuote :: l -> String -> String -> Exp l

-- | xml element, with attributes and children
XTag :: l -> (XName l) -> [XAttr l] -> (Maybe (Exp l)) -> [Exp l] -> Exp l

-- | empty xml element, with attributes
XETag :: l -> (XName l) -> [XAttr l] -> (Maybe (Exp l)) -> Exp l

-- | PCDATA child element
XPcdata :: l -> String -> Exp l

-- | escaped haskell expression inside xml
XExpTag :: l -> (Exp l) -> Exp l

-- | children of an xml element
XChildTag :: l -> [Exp l] -> Exp l

-- | CORE pragma
CorePragma :: l -> String -> (Exp l) -> Exp l

-- | SCC pragma
SCCPragma :: l -> String -> (Exp l) -> Exp l

-- | GENERATED pragma
GenPragma :: l -> String -> (Int, Int) -> (Int, Int) -> (Exp l) -> Exp l

-- | arrows proc: <tt>proc</tt> <i>pat</i> <tt>-&gt;</tt> <i>exp</i>
Proc :: l -> (Pat l) -> (Exp l) -> Exp l

-- | arrow application (from left): <i>exp</i> <tt>-&lt;</tt> <i>exp</i>
LeftArrApp :: l -> (Exp l) -> (Exp l) -> Exp l

-- | arrow application (from right): <i>exp</i> <tt>&gt;-</tt> <i>exp</i>
RightArrApp :: l -> (Exp l) -> (Exp l) -> Exp l

-- | higher-order arrow application (from left): <i>exp</i>
--   <tt>-&lt;&lt;</tt> <i>exp</i>
LeftArrHighApp :: l -> (Exp l) -> (Exp l) -> Exp l

-- | higher-order arrow application (from right): <i>exp</i>
--   <tt>&gt;&gt;-</tt> <i>exp</i>
RightArrHighApp :: l -> (Exp l) -> (Exp l) -> Exp l

-- | <tt>case</tt> <i>alts</i>
LCase :: l -> [Alt l] -> Exp l

-- | A statement, representing both a <i>stmt</i> in a
--   <tt>do</tt>-expression, an ordinary <i>qual</i> in a list
--   comprehension, as well as a <i>stmt</i> in a pattern guard.
data Stmt l

-- | a generator: <i>pat</i> <tt>&lt;-</tt> <i>exp</i>
Generator :: l -> (Pat l) -> (Exp l) -> Stmt l

-- | an <i>exp</i> by itself: in a <tt>do</tt>-expression, an action whose
--   result is discarded; in a list comprehension and pattern guard, a
--   guard expression
Qualifier :: l -> (Exp l) -> Stmt l

-- | local bindings
LetStmt :: l -> (Binds l) -> Stmt l

-- | a recursive binding group for arrows
RecStmt :: l -> [Stmt l] -> Stmt l

-- | A general <i>transqual</i> in a list comprehension, which could
--   potentially be a transform of the kind enabled by TransformListComp.
data QualStmt l

-- | an ordinary statement
QualStmt :: l -> (Stmt l) -> QualStmt l

-- | <tt>then</tt> <i>exp</i>
ThenTrans :: l -> (Exp l) -> QualStmt l

-- | <tt>then</tt> <i>exp</i> <tt>by</tt> <i>exp</i>
ThenBy :: l -> (Exp l) -> (Exp l) -> QualStmt l

-- | <tt>then</tt> <tt>group</tt> <tt>by</tt> <i>exp</i>
GroupBy :: l -> (Exp l) -> QualStmt l

-- | <tt>then</tt> <tt>group</tt> <tt>using</tt> <i>exp</i>
GroupUsing :: l -> (Exp l) -> QualStmt l

-- | <tt>then</tt> <tt>group</tt> <tt>by</tt> <i>exp</i> <tt>using</tt>
--   <i>exp</i>
GroupByUsing :: l -> (Exp l) -> (Exp l) -> QualStmt l

-- | An <i>fbind</i> in a labeled construction or update expression.
data FieldUpdate l

-- | ordinary label-expresion pair
FieldUpdate :: l -> (QName l) -> (Exp l) -> FieldUpdate l

-- | record field pun
FieldPun :: l -> (QName l) -> FieldUpdate l

-- | record field wildcard
FieldWildcard :: l -> FieldUpdate l

-- | An <i>alt</i> alternative in a <tt>case</tt> expression.
data Alt l
Alt :: l -> (Pat l) -> (Rhs l) -> (Maybe (Binds l)) -> Alt l

-- | An xml attribute, which is a name-expression pair.
data XAttr l
XAttr :: l -> (XName l) -> (Exp l) -> XAttr l

-- | A pattern, to be matched against a value.
data Pat l

-- | variable
PVar :: l -> (Name l) -> Pat l

-- | literal constant
PLit :: l -> (Sign l) -> (Literal l) -> Pat l

-- | n+k pattern
PNPlusK :: l -> (Name l) -> Integer -> Pat l

-- | pattern with an infix data constructor
PInfixApp :: l -> (Pat l) -> (QName l) -> (Pat l) -> Pat l

-- | data constructor and argument patterns
PApp :: l -> (QName l) -> [Pat l] -> Pat l

-- | tuple pattern
PTuple :: l -> Boxed -> [Pat l] -> Pat l

-- | list pattern
PList :: l -> [Pat l] -> Pat l

-- | parenthesized pattern
PParen :: l -> (Pat l) -> Pat l

-- | labelled pattern, record style
PRec :: l -> (QName l) -> [PatField l] -> Pat l

-- | <tt>@</tt>-pattern
PAsPat :: l -> (Name l) -> (Pat l) -> Pat l

-- | wildcard pattern: <tt>_</tt>
PWildCard :: l -> Pat l

-- | irrefutable pattern: <tt>~<i>pat</i></tt>
PIrrPat :: l -> (Pat l) -> Pat l

-- | pattern with type signature
PatTypeSig :: l -> (Pat l) -> (Type l) -> Pat l

-- | view patterns of the form <tt>(<i>exp</i> -&gt; <i>pat</i>)</tt>
PViewPat :: l -> (Exp l) -> (Pat l) -> Pat l

-- | regular list pattern
PRPat :: l -> [RPat l] -> Pat l

-- | XML element pattern
PXTag :: l -> (XName l) -> [PXAttr l] -> (Maybe (Pat l)) -> [Pat l] -> Pat l

-- | XML singleton element pattern
PXETag :: l -> (XName l) -> [PXAttr l] -> (Maybe (Pat l)) -> Pat l

-- | XML PCDATA pattern
PXPcdata :: l -> String -> Pat l

-- | XML embedded pattern
PXPatTag :: l -> (Pat l) -> Pat l

-- | XML regular list pattern
PXRPats :: l -> [RPat l] -> Pat l

-- | quasi quote pattern: <tt>[$<i>name</i>| <i>string</i> |]</tt>
PQuasiQuote :: l -> String -> String -> Pat l

-- | strict (bang) pattern: <tt>f !x = ...</tt>
PBangPat :: l -> (Pat l) -> Pat l

-- | An <i>fpat</i> in a labeled record pattern.
data PatField l

-- | ordinary label-pattern pair
PFieldPat :: l -> (QName l) -> (Pat l) -> PatField l

-- | record field pun
PFieldPun :: l -> (QName l) -> PatField l

-- | record field wildcard
PFieldWildcard :: l -> PatField l

-- | An XML attribute in a pattern.
data PXAttr l
PXAttr :: l -> (XName l) -> (Pat l) -> PXAttr l

-- | An entity in a regular pattern.
data RPat l

-- | operator pattern, e.g. pat*
RPOp :: l -> (RPat l) -> (RPatOp l) -> RPat l

-- | choice pattern, e.g. (1 | 2)
RPEither :: l -> (RPat l) -> (RPat l) -> RPat l

-- | sequence pattern, e.g. (| 1, 2, 3 |)
RPSeq :: l -> [RPat l] -> RPat l

-- | guarded pattern, e.g. (| p | p &lt; 3 |)
RPGuard :: l -> (Pat l) -> [Stmt l] -> RPat l

-- | non-linear variable binding, e.g. (foo@:(1 | 2))*
RPCAs :: l -> (Name l) -> (RPat l) -> RPat l

-- | linear variable binding, e.g. foo@(1 | 2)
RPAs :: l -> (Name l) -> (RPat l) -> RPat l

-- | parenthesised pattern, e.g. (2*)
RPParen :: l -> (RPat l) -> RPat l

-- | an ordinary pattern
RPPat :: l -> (Pat l) -> RPat l

-- | A regular pattern operator.
data RPatOp l

-- | <tt>*</tt> = 0 or more
RPStar :: l -> RPatOp l

-- | <tt>*!</tt> = 0 or more, greedy
RPStarG :: l -> RPatOp l

-- | <tt>+</tt> = 1 or more
RPPlus :: l -> RPatOp l

-- | <tt>+!</tt> = 1 or more, greedy
RPPlusG :: l -> RPatOp l

-- | <tt>?</tt> = 0 or 1
RPOpt :: l -> RPatOp l

-- | <tt>?!</tt> = 0 or 1, greedy
RPOptG :: l -> RPatOp l

-- | <i>literal</i> Values of this type hold the abstract value of the
--   literal, along with the precise string representation used. For
--   example, <tt>10</tt>, <tt>0o12</tt> and <tt>0xa</tt> have the same
--   value representation, but each carry a different string
--   representation.
data Literal l

-- | character literal
Char :: l -> Char -> String -> Literal l

-- | string literal
String :: l -> String -> String -> Literal l

-- | integer literal
Int :: l -> Integer -> String -> Literal l

-- | floating point literal
Frac :: l -> Rational -> String -> Literal l

-- | unboxed integer literal
PrimInt :: l -> Integer -> String -> Literal l

-- | unboxed word literal
PrimWord :: l -> Integer -> String -> Literal l

-- | unboxed float literal
PrimFloat :: l -> Rational -> String -> Literal l

-- | unboxed double literal
PrimDouble :: l -> Rational -> String -> Literal l

-- | unboxed character literal
PrimChar :: l -> Char -> String -> Literal l

-- | unboxed string literal
PrimString :: l -> String -> String -> Literal l

-- | An indication whether a literal pattern has been negated or not.
data Sign l
Signless :: l -> Sign l
Negative :: l -> Sign l

-- | The name of a Haskell module.
data ModuleName l
ModuleName :: l -> String -> ModuleName l

-- | This type is used to represent qualified variables, and also qualified
--   constructors.
data QName l

-- | name qualified with a module name
Qual :: l -> (ModuleName l) -> (Name l) -> QName l

-- | unqualified local name
UnQual :: l -> (Name l) -> QName l

-- | built-in constructor with special syntax
Special :: l -> (SpecialCon l) -> QName l

-- | This type is used to represent variables, and also constructors.
data Name l

-- | <i>varid</i> or <i>conid</i>.
Ident :: l -> String -> Name l

-- | <i>varsym</i> or <i>consym</i>
Symbol :: l -> String -> Name l

-- | Possibly qualified infix operators (<i>qop</i>), appearing in
--   expressions.
data QOp l

-- | variable operator (<i>qvarop</i>)
QVarOp :: l -> (QName l) -> QOp l

-- | constructor operator (<i>qconop</i>)
QConOp :: l -> (QName l) -> QOp l

-- | Operators appearing in <tt>infix</tt> declarations are never
--   qualified.
data Op l

-- | variable operator (<i>varop</i>)
VarOp :: l -> (Name l) -> Op l

-- | constructor operator (<i>conop</i>)
ConOp :: l -> (Name l) -> Op l

-- | Constructors with special syntax. These names are never qualified, and
--   always refer to builtin type or data constructors.
data SpecialCon l

-- | unit type and data constructor <tt>()</tt>
UnitCon :: l -> SpecialCon l

-- | list type constructor <tt>[]</tt>
ListCon :: l -> SpecialCon l

-- | function type constructor <tt>-&gt;</tt>
FunCon :: l -> SpecialCon l

-- | <i>n</i>-ary tuple type and data constructors <tt>(,)</tt> etc,
--   possibly boxed <tt>(#,#)</tt>
TupleCon :: l -> Boxed -> Int -> SpecialCon l

-- | list data constructor <tt>(:)</tt>
Cons :: l -> SpecialCon l

-- | unboxed singleton tuple constructor <tt>(# #)</tt>
UnboxedSingleCon :: l -> SpecialCon l

-- | A name (<i>cname</i>) of a component of a class or data type in an
--   <tt>import</tt> or export specification.
data CName l

-- | name of a method or field
VarName :: l -> (Name l) -> CName l

-- | name of a data constructor
ConName :: l -> (Name l) -> CName l

-- | An implicit parameter name.
data IPName l

-- | ?<i>ident</i>, non-linear implicit parameter
IPDup :: l -> String -> IPName l

-- | %<i>ident</i>, linear implicit parameter
IPLin :: l -> String -> IPName l

-- | The name of an xml element or attribute, possibly qualified with a
--   namespace.
data XName l
XName :: l -> String -> XName l
XDomName :: l -> String -> String -> XName l

-- | A template haskell bracket expression.
data Bracket l

-- | expression bracket: <tt>[| ... |]</tt>
ExpBracket :: l -> (Exp l) -> Bracket l

-- | pattern bracket: <tt>[p| ... |]</tt>
PatBracket :: l -> (Pat l) -> Bracket l

-- | type bracket: <tt>[t| ... |]</tt>
TypeBracket :: l -> (Type l) -> Bracket l

-- | declaration bracket: <tt>[d| ... |]</tt>
DeclBracket :: l -> [Decl l] -> Bracket l

-- | A template haskell splice expression
data Splice l

-- | variable splice: <tt>$var</tt>
IdSplice :: l -> String -> Splice l

-- | parenthesised expression splice: <tt>$(<i>exp</i>)</tt>
ParenSplice :: l -> (Exp l) -> Splice l

-- | The safety of a foreign function call.
data Safety l

-- | unsafe
PlayRisky :: l -> Safety l

-- | safe (<a>False</a>) or threadsafe (<a>True</a>)
PlaySafe :: l -> Bool -> Safety l

-- | interruptible
PlayInterruptible :: l -> Safety l

-- | The calling convention of a foreign function call.
data CallConv l
StdCall :: l -> CallConv l
CCall :: l -> CallConv l
CPlusPlus :: l -> CallConv l
DotNet :: l -> CallConv l
Jvm :: l -> CallConv l
Js :: l -> CallConv l
CApi :: l -> CallConv l

-- | A top level options pragma, preceding the module header.
data ModulePragma l

-- | LANGUAGE pragma
LanguagePragma :: l -> [Name l] -> ModulePragma l

-- | OPTIONS pragma, possibly qualified with a tool, e.g. OPTIONS_GHC
OptionsPragma :: l -> (Maybe Tool) -> String -> ModulePragma l

-- | ANN pragma with module scope
AnnModulePragma :: l -> (Annotation l) -> ModulePragma l

-- | Recognised tools for OPTIONS pragmas.
data Tool
GHC :: Tool
HUGS :: Tool
NHC98 :: Tool
YHC :: Tool
HADDOCK :: Tool
UnknownTool :: String -> Tool

-- | Recognised overlaps for overlap pragmas.
data Overlap l

-- | NO_OVERLAP pragma
NoOverlap :: l -> Overlap l

-- | OVERLAP pragma
Overlap :: l -> Overlap l

-- | INCOHERENT pragma
Incoherent :: l -> Overlap l

-- | The body of a RULES pragma.
data Rule l
Rule :: l -> String -> (Maybe (Activation l)) -> (Maybe [RuleVar l]) -> (Exp l) -> (Exp l) -> Rule l

-- | Variables used in a RULES pragma, optionally annotated with types
data RuleVar l
RuleVar :: l -> (Name l) -> RuleVar l
TypedRuleVar :: l -> (Name l) -> (Type l) -> RuleVar l

-- | Activation clause of a RULES pragma.
data Activation l
ActiveFrom :: l -> Int -> Activation l
ActiveUntil :: l -> Int -> Activation l

-- | An annotation through an ANN pragma.
data Annotation l

-- | An annotation for a declared name.
Ann :: l -> (Name l) -> (Exp l) -> Annotation l

-- | An annotation for a declared type.
TypeAnn :: l -> (Name l) -> (Exp l) -> Annotation l

-- | An annotation for the defining module.
ModuleAnn :: l -> (Exp l) -> Annotation l

-- | A boolean formula for MINIMAL pragmas.
data BooleanFormula l

-- | A variable.
VarFormula :: l -> (Name l) -> BooleanFormula l

-- | And boolean formulas.
AndFormula :: l -> [BooleanFormula l] -> BooleanFormula l

-- | Or boolean formulas.
OrFormula :: l -> [BooleanFormula l] -> BooleanFormula l

-- | Parenthesized boolean formulas.
ParenFormula :: l -> (BooleanFormula l) -> BooleanFormula l
prelude_mod :: l -> ModuleName l
main_mod :: l -> ModuleName l
main_name :: l -> Name l
unit_con_name :: l -> QName l
tuple_con_name :: l -> Boxed -> Int -> QName l
list_cons_name :: l -> QName l
unboxed_singleton_con_name :: l -> QName l
unit_con :: l -> Exp l
tuple_con :: l -> Boxed -> Int -> Exp l
unboxed_singleton_con :: l -> Exp l
as_name :: l -> Name l
qualified_name :: l -> Name l
hiding_name :: l -> Name l
minus_name :: l -> Name l
bang_name :: l -> Name l
dot_name :: l -> Name l
star_name :: l -> Name l
export_name :: l -> Name l
safe_name :: l -> Name l
unsafe_name :: l -> Name l
interruptible_name :: l -> Name l
threadsafe_name :: l -> Name l
stdcall_name :: l -> Name l
ccall_name :: l -> Name l
cplusplus_name :: l -> Name l
dotnet_name :: l -> Name l
jvm_name :: l -> Name l
js_name :: l -> Name l
capi_name :: l -> Name l
forall_name :: l -> Name l
family_name :: l -> Name l
unit_tycon_name :: l -> QName l
fun_tycon_name :: l -> QName l
list_tycon_name :: l -> QName l
tuple_tycon_name :: l -> Boxed -> Int -> QName l
unboxed_singleton_tycon_name :: l -> QName l
unit_tycon :: l -> Type l
fun_tycon :: l -> Type l
list_tycon :: l -> Type l
tuple_tycon :: l -> Boxed -> Int -> Type l
unboxed_singleton_tycon :: l -> Type l

-- | AST nodes are annotated, and this class allows manipulation of the
--   annotations.
class Functor ast => Annotated ast
ann :: Annotated ast => ast l -> l
amap :: Annotated ast => (l -> l) -> ast l -> ast l

-- | Test if two AST elements are equal modulo annotations.
(=~=) :: (Annotated a, Eq (a ())) => a l1 -> a l2 -> Bool
instance Typeable ModuleName
instance Typeable Name
instance Typeable IPName
instance Typeable Op
instance Typeable CName
instance Typeable Namespace
instance Typeable ImportSpec
instance Typeable ImportSpecList
instance Typeable ImportDecl
instance Typeable Assoc
instance Typeable BooleanFormula
instance Typeable DataOrNew
instance Typeable BangType
instance Typeable Boxed
instance Typeable SpecialCon
instance Typeable QName
instance Typeable Promoted
instance Typeable ExportSpec
instance Typeable ExportSpecList
instance Typeable QOp
instance Typeable Kind
instance Typeable TyVarBind
instance Typeable DeclHead
instance Typeable FunDep
instance Typeable Literal
instance Typeable Sign
instance Typeable XName
instance Typeable Safety
instance Typeable CallConv
instance Typeable Tool
instance Typeable Overlap
instance Typeable Activation
instance Typeable WarningText
instance Typeable ModuleHead
instance Typeable RPatOp
instance Typeable Alt
instance Typeable Pat
instance Typeable PatField
instance Typeable RPat
instance Typeable Stmt
instance Typeable Exp
instance Typeable FieldUpdate
instance Typeable QualStmt
instance Typeable Splice
instance Typeable Bracket
instance Typeable Type
instance Typeable Context
instance Typeable Asst
instance Typeable Decl
instance Typeable Rule
instance Typeable RuleVar
instance Typeable Rhs
instance Typeable GuardedRhs
instance Typeable InstDecl
instance Typeable GadtDecl
instance Typeable FieldDecl
instance Typeable QualConDecl
instance Typeable ConDecl
instance Typeable Deriving
instance Typeable InstRule
instance Typeable InstHead
instance Typeable ClassDecl
instance Typeable Match
instance Typeable Binds
instance Typeable IPBind
instance Typeable Annotation
instance Typeable TypeEqn
instance Typeable XAttr
instance Typeable PXAttr
instance Typeable ModulePragma
instance Typeable Module
instance Eq l => Eq (ModuleName l)
instance Ord l => Ord (ModuleName l)
instance Show l => Show (ModuleName l)
instance Data l => Data (ModuleName l)
instance Foldable ModuleName
instance Traversable ModuleName
instance Functor ModuleName
instance Generic (ModuleName l)
instance Eq l => Eq (Name l)
instance Ord l => Ord (Name l)
instance Show l => Show (Name l)
instance Data l => Data (Name l)
instance Foldable Name
instance Traversable Name
instance Functor Name
instance Generic (Name l)
instance Eq l => Eq (IPName l)
instance Ord l => Ord (IPName l)
instance Show l => Show (IPName l)
instance Data l => Data (IPName l)
instance Foldable IPName
instance Traversable IPName
instance Functor IPName
instance Generic (IPName l)
instance Eq l => Eq (Op l)
instance Ord l => Ord (Op l)
instance Show l => Show (Op l)
instance Data l => Data (Op l)
instance Foldable Op
instance Traversable Op
instance Functor Op
instance Generic (Op l)
instance Eq l => Eq (CName l)
instance Ord l => Ord (CName l)
instance Show l => Show (CName l)
instance Data l => Data (CName l)
instance Foldable CName
instance Traversable CName
instance Functor CName
instance Generic (CName l)
instance Eq l => Eq (Namespace l)
instance Ord l => Ord (Namespace l)
instance Show l => Show (Namespace l)
instance Data l => Data (Namespace l)
instance Foldable Namespace
instance Traversable Namespace
instance Functor Namespace
instance Generic (Namespace l)
instance Eq l => Eq (ImportSpec l)
instance Ord l => Ord (ImportSpec l)
instance Show l => Show (ImportSpec l)
instance Data l => Data (ImportSpec l)
instance Foldable ImportSpec
instance Traversable ImportSpec
instance Functor ImportSpec
instance Generic (ImportSpec l)
instance Eq l => Eq (ImportSpecList l)
instance Ord l => Ord (ImportSpecList l)
instance Show l => Show (ImportSpecList l)
instance Data l => Data (ImportSpecList l)
instance Foldable ImportSpecList
instance Traversable ImportSpecList
instance Functor ImportSpecList
instance Generic (ImportSpecList l)
instance Eq l => Eq (ImportDecl l)
instance Ord l => Ord (ImportDecl l)
instance Show l => Show (ImportDecl l)
instance Data l => Data (ImportDecl l)
instance Foldable ImportDecl
instance Traversable ImportDecl
instance Functor ImportDecl
instance Generic (ImportDecl l)
instance Eq l => Eq (Assoc l)
instance Ord l => Ord (Assoc l)
instance Show l => Show (Assoc l)
instance Data l => Data (Assoc l)
instance Foldable Assoc
instance Traversable Assoc
instance Functor Assoc
instance Generic (Assoc l)
instance Eq l => Eq (BooleanFormula l)
instance Ord l => Ord (BooleanFormula l)
instance Show l => Show (BooleanFormula l)
instance Data l => Data (BooleanFormula l)
instance Foldable BooleanFormula
instance Traversable BooleanFormula
instance Functor BooleanFormula
instance Generic (BooleanFormula l)
instance Eq l => Eq (DataOrNew l)
instance Ord l => Ord (DataOrNew l)
instance Show l => Show (DataOrNew l)
instance Data l => Data (DataOrNew l)
instance Foldable DataOrNew
instance Traversable DataOrNew
instance Functor DataOrNew
instance Generic (DataOrNew l)
instance Eq l => Eq (BangType l)
instance Ord l => Ord (BangType l)
instance Show l => Show (BangType l)
instance Data l => Data (BangType l)
instance Foldable BangType
instance Traversable BangType
instance Functor BangType
instance Generic (BangType l)
instance Eq Boxed
instance Ord Boxed
instance Show Boxed
instance Data Boxed
instance Generic Boxed
instance Eq l => Eq (SpecialCon l)
instance Ord l => Ord (SpecialCon l)
instance Show l => Show (SpecialCon l)
instance Data l => Data (SpecialCon l)
instance Foldable SpecialCon
instance Traversable SpecialCon
instance Functor SpecialCon
instance Generic (SpecialCon l)
instance Eq l => Eq (QName l)
instance Ord l => Ord (QName l)
instance Show l => Show (QName l)
instance Data l => Data (QName l)
instance Foldable QName
instance Traversable QName
instance Functor QName
instance Generic (QName l)
instance Eq l => Eq (Promoted l)
instance Ord l => Ord (Promoted l)
instance Show l => Show (Promoted l)
instance Data l => Data (Promoted l)
instance Foldable Promoted
instance Traversable Promoted
instance Functor Promoted
instance Generic (Promoted l)
instance Eq l => Eq (ExportSpec l)
instance Ord l => Ord (ExportSpec l)
instance Show l => Show (ExportSpec l)
instance Data l => Data (ExportSpec l)
instance Foldable ExportSpec
instance Traversable ExportSpec
instance Functor ExportSpec
instance Generic (ExportSpec l)
instance Eq l => Eq (ExportSpecList l)
instance Ord l => Ord (ExportSpecList l)
instance Show l => Show (ExportSpecList l)
instance Data l => Data (ExportSpecList l)
instance Foldable ExportSpecList
instance Traversable ExportSpecList
instance Functor ExportSpecList
instance Generic (ExportSpecList l)
instance Eq l => Eq (QOp l)
instance Ord l => Ord (QOp l)
instance Show l => Show (QOp l)
instance Data l => Data (QOp l)
instance Foldable QOp
instance Traversable QOp
instance Functor QOp
instance Generic (QOp l)
instance Eq l => Eq (Kind l)
instance Ord l => Ord (Kind l)
instance Show l => Show (Kind l)
instance Data l => Data (Kind l)
instance Foldable Kind
instance Traversable Kind
instance Functor Kind
instance Generic (Kind l)
instance Eq l => Eq (TyVarBind l)
instance Ord l => Ord (TyVarBind l)
instance Show l => Show (TyVarBind l)
instance Data l => Data (TyVarBind l)
instance Foldable TyVarBind
instance Traversable TyVarBind
instance Functor TyVarBind
instance Generic (TyVarBind l)
instance Eq l => Eq (DeclHead l)
instance Ord l => Ord (DeclHead l)
instance Show l => Show (DeclHead l)
instance Data l => Data (DeclHead l)
instance Foldable DeclHead
instance Traversable DeclHead
instance Functor DeclHead
instance Generic (DeclHead l)
instance Eq l => Eq (FunDep l)
instance Ord l => Ord (FunDep l)
instance Show l => Show (FunDep l)
instance Data l => Data (FunDep l)
instance Foldable FunDep
instance Traversable FunDep
instance Functor FunDep
instance Generic (FunDep l)
instance Eq l => Eq (Literal l)
instance Ord l => Ord (Literal l)
instance Show l => Show (Literal l)
instance Data l => Data (Literal l)
instance Foldable Literal
instance Traversable Literal
instance Functor Literal
instance Generic (Literal l)
instance Eq l => Eq (Sign l)
instance Ord l => Ord (Sign l)
instance Show l => Show (Sign l)
instance Data l => Data (Sign l)
instance Foldable Sign
instance Traversable Sign
instance Functor Sign
instance Generic (Sign l)
instance Eq l => Eq (XName l)
instance Ord l => Ord (XName l)
instance Show l => Show (XName l)
instance Data l => Data (XName l)
instance Foldable XName
instance Traversable XName
instance Functor XName
instance Generic (XName l)
instance Eq l => Eq (Safety l)
instance Ord l => Ord (Safety l)
instance Show l => Show (Safety l)
instance Data l => Data (Safety l)
instance Foldable Safety
instance Traversable Safety
instance Functor Safety
instance Generic (Safety l)
instance Eq l => Eq (CallConv l)
instance Ord l => Ord (CallConv l)
instance Show l => Show (CallConv l)
instance Data l => Data (CallConv l)
instance Foldable CallConv
instance Traversable CallConv
instance Functor CallConv
instance Generic (CallConv l)
instance Eq Tool
instance Ord Tool
instance Show Tool
instance Data Tool
instance Generic Tool
instance Eq l => Eq (Overlap l)
instance Ord l => Ord (Overlap l)
instance Show l => Show (Overlap l)
instance Data l => Data (Overlap l)
instance Foldable Overlap
instance Traversable Overlap
instance Functor Overlap
instance Generic (Overlap l)
instance Eq l => Eq (Activation l)
instance Ord l => Ord (Activation l)
instance Show l => Show (Activation l)
instance Data l => Data (Activation l)
instance Foldable Activation
instance Traversable Activation
instance Functor Activation
instance Generic (Activation l)
instance Eq l => Eq (WarningText l)
instance Ord l => Ord (WarningText l)
instance Show l => Show (WarningText l)
instance Data l => Data (WarningText l)
instance Foldable WarningText
instance Traversable WarningText
instance Functor WarningText
instance Generic (WarningText l)
instance Eq l => Eq (ModuleHead l)
instance Ord l => Ord (ModuleHead l)
instance Show l => Show (ModuleHead l)
instance Data l => Data (ModuleHead l)
instance Foldable ModuleHead
instance Traversable ModuleHead
instance Functor ModuleHead
instance Generic (ModuleHead l)
instance Eq l => Eq (RPatOp l)
instance Ord l => Ord (RPatOp l)
instance Show l => Show (RPatOp l)
instance Data l => Data (RPatOp l)
instance Foldable RPatOp
instance Traversable RPatOp
instance Functor RPatOp
instance Generic (RPatOp l)
instance Eq l => Eq (Alt l)
instance Ord l => Ord (Alt l)
instance Show l => Show (Alt l)
instance Data l => Data (Alt l)
instance Foldable Alt
instance Traversable Alt
instance Functor Alt
instance Generic (Alt l)
instance Eq l => Eq (Pat l)
instance Ord l => Ord (Pat l)
instance Show l => Show (Pat l)
instance Data l => Data (Pat l)
instance Foldable Pat
instance Traversable Pat
instance Functor Pat
instance Generic (Pat l)
instance Eq l => Eq (PatField l)
instance Ord l => Ord (PatField l)
instance Show l => Show (PatField l)
instance Data l => Data (PatField l)
instance Foldable PatField
instance Traversable PatField
instance Functor PatField
instance Generic (PatField l)
instance Eq l => Eq (RPat l)
instance Ord l => Ord (RPat l)
instance Show l => Show (RPat l)
instance Data l => Data (RPat l)
instance Foldable RPat
instance Traversable RPat
instance Functor RPat
instance Generic (RPat l)
instance Eq l => Eq (Stmt l)
instance Ord l => Ord (Stmt l)
instance Show l => Show (Stmt l)
instance Data l => Data (Stmt l)
instance Foldable Stmt
instance Traversable Stmt
instance Functor Stmt
instance Generic (Stmt l)
instance Eq l => Eq (Exp l)
instance Ord l => Ord (Exp l)
instance Show l => Show (Exp l)
instance Data l => Data (Exp l)
instance Foldable Exp
instance Traversable Exp
instance Functor Exp
instance Generic (Exp l)
instance Eq l => Eq (FieldUpdate l)
instance Ord l => Ord (FieldUpdate l)
instance Show l => Show (FieldUpdate l)
instance Data l => Data (FieldUpdate l)
instance Foldable FieldUpdate
instance Traversable FieldUpdate
instance Functor FieldUpdate
instance Generic (FieldUpdate l)
instance Eq l => Eq (QualStmt l)
instance Ord l => Ord (QualStmt l)
instance Show l => Show (QualStmt l)
instance Data l => Data (QualStmt l)
instance Foldable QualStmt
instance Traversable QualStmt
instance Functor QualStmt
instance Generic (QualStmt l)
instance Eq l => Eq (Splice l)
instance Ord l => Ord (Splice l)
instance Show l => Show (Splice l)
instance Data l => Data (Splice l)
instance Foldable Splice
instance Traversable Splice
instance Functor Splice
instance Generic (Splice l)
instance Eq l => Eq (Bracket l)
instance Ord l => Ord (Bracket l)
instance Show l => Show (Bracket l)
instance Data l => Data (Bracket l)
instance Foldable Bracket
instance Traversable Bracket
instance Functor Bracket
instance Generic (Bracket l)
instance Eq l => Eq (Type l)
instance Ord l => Ord (Type l)
instance Show l => Show (Type l)
instance Data l => Data (Type l)
instance Foldable Type
instance Traversable Type
instance Functor Type
instance Generic (Type l)
instance Eq l => Eq (Context l)
instance Ord l => Ord (Context l)
instance Show l => Show (Context l)
instance Data l => Data (Context l)
instance Foldable Context
instance Traversable Context
instance Functor Context
instance Generic (Context l)
instance Eq l => Eq (Asst l)
instance Ord l => Ord (Asst l)
instance Show l => Show (Asst l)
instance Data l => Data (Asst l)
instance Foldable Asst
instance Traversable Asst
instance Functor Asst
instance Generic (Asst l)
instance Eq l => Eq (Decl l)
instance Ord l => Ord (Decl l)
instance Show l => Show (Decl l)
instance Data l => Data (Decl l)
instance Foldable Decl
instance Traversable Decl
instance Functor Decl
instance Generic (Decl l)
instance Eq l => Eq (Rule l)
instance Ord l => Ord (Rule l)
instance Show l => Show (Rule l)
instance Data l => Data (Rule l)
instance Foldable Rule
instance Traversable Rule
instance Functor Rule
instance Generic (Rule l)
instance Eq l => Eq (RuleVar l)
instance Ord l => Ord (RuleVar l)
instance Show l => Show (RuleVar l)
instance Data l => Data (RuleVar l)
instance Foldable RuleVar
instance Traversable RuleVar
instance Functor RuleVar
instance Generic (RuleVar l)
instance Eq l => Eq (Rhs l)
instance Ord l => Ord (Rhs l)
instance Show l => Show (Rhs l)
instance Data l => Data (Rhs l)
instance Foldable Rhs
instance Traversable Rhs
instance Functor Rhs
instance Generic (Rhs l)
instance Eq l => Eq (GuardedRhs l)
instance Ord l => Ord (GuardedRhs l)
instance Show l => Show (GuardedRhs l)
instance Data l => Data (GuardedRhs l)
instance Foldable GuardedRhs
instance Traversable GuardedRhs
instance Functor GuardedRhs
instance Generic (GuardedRhs l)
instance Eq l => Eq (InstDecl l)
instance Ord l => Ord (InstDecl l)
instance Show l => Show (InstDecl l)
instance Data l => Data (InstDecl l)
instance Foldable InstDecl
instance Traversable InstDecl
instance Functor InstDecl
instance Generic (InstDecl l)
instance Eq l => Eq (GadtDecl l)
instance Ord l => Ord (GadtDecl l)
instance Show l => Show (GadtDecl l)
instance Data l => Data (GadtDecl l)
instance Foldable GadtDecl
instance Traversable GadtDecl
instance Functor GadtDecl
instance Generic (GadtDecl l)
instance Eq l => Eq (FieldDecl l)
instance Ord l => Ord (FieldDecl l)
instance Show l => Show (FieldDecl l)
instance Data l => Data (FieldDecl l)
instance Foldable FieldDecl
instance Traversable FieldDecl
instance Functor FieldDecl
instance Generic (FieldDecl l)
instance Eq l => Eq (QualConDecl l)
instance Ord l => Ord (QualConDecl l)
instance Show l => Show (QualConDecl l)
instance Data l => Data (QualConDecl l)
instance Foldable QualConDecl
instance Traversable QualConDecl
instance Functor QualConDecl
instance Generic (QualConDecl l)
instance Eq l => Eq (ConDecl l)
instance Ord l => Ord (ConDecl l)
instance Show l => Show (ConDecl l)
instance Data l => Data (ConDecl l)
instance Foldable ConDecl
instance Traversable ConDecl
instance Functor ConDecl
instance Generic (ConDecl l)
instance Eq l => Eq (Deriving l)
instance Ord l => Ord (Deriving l)
instance Show l => Show (Deriving l)
instance Data l => Data (Deriving l)
instance Foldable Deriving
instance Traversable Deriving
instance Functor Deriving
instance Generic (Deriving l)
instance Eq l => Eq (InstRule l)
instance Ord l => Ord (InstRule l)
instance Show l => Show (InstRule l)
instance Data l => Data (InstRule l)
instance Foldable InstRule
instance Traversable InstRule
instance Functor InstRule
instance Generic (InstRule l)
instance Eq l => Eq (InstHead l)
instance Ord l => Ord (InstHead l)
instance Show l => Show (InstHead l)
instance Data l => Data (InstHead l)
instance Foldable InstHead
instance Traversable InstHead
instance Functor InstHead
instance Generic (InstHead l)
instance Eq l => Eq (ClassDecl l)
instance Ord l => Ord (ClassDecl l)
instance Show l => Show (ClassDecl l)
instance Data l => Data (ClassDecl l)
instance Foldable ClassDecl
instance Traversable ClassDecl
instance Functor ClassDecl
instance Generic (ClassDecl l)
instance Eq l => Eq (Match l)
instance Ord l => Ord (Match l)
instance Show l => Show (Match l)
instance Data l => Data (Match l)
instance Foldable Match
instance Traversable Match
instance Functor Match
instance Generic (Match l)
instance Eq l => Eq (Binds l)
instance Ord l => Ord (Binds l)
instance Show l => Show (Binds l)
instance Data l => Data (Binds l)
instance Foldable Binds
instance Traversable Binds
instance Functor Binds
instance Generic (Binds l)
instance Eq l => Eq (IPBind l)
instance Ord l => Ord (IPBind l)
instance Show l => Show (IPBind l)
instance Data l => Data (IPBind l)
instance Foldable IPBind
instance Traversable IPBind
instance Functor IPBind
instance Generic (IPBind l)
instance Eq l => Eq (Annotation l)
instance Ord l => Ord (Annotation l)
instance Show l => Show (Annotation l)
instance Data l => Data (Annotation l)
instance Foldable Annotation
instance Traversable Annotation
instance Functor Annotation
instance Generic (Annotation l)
instance Eq l => Eq (TypeEqn l)
instance Ord l => Ord (TypeEqn l)
instance Show l => Show (TypeEqn l)
instance Data l => Data (TypeEqn l)
instance Foldable TypeEqn
instance Traversable TypeEqn
instance Functor TypeEqn
instance Generic (TypeEqn l)
instance Eq l => Eq (XAttr l)
instance Ord l => Ord (XAttr l)
instance Show l => Show (XAttr l)
instance Data l => Data (XAttr l)
instance Foldable XAttr
instance Traversable XAttr
instance Functor XAttr
instance Generic (XAttr l)
instance Eq l => Eq (PXAttr l)
instance Ord l => Ord (PXAttr l)
instance Show l => Show (PXAttr l)
instance Data l => Data (PXAttr l)
instance Foldable PXAttr
instance Traversable PXAttr
instance Functor PXAttr
instance Generic (PXAttr l)
instance Eq l => Eq (ModulePragma l)
instance Ord l => Ord (ModulePragma l)
instance Show l => Show (ModulePragma l)
instance Data l => Data (ModulePragma l)
instance Foldable ModulePragma
instance Traversable ModulePragma
instance Functor ModulePragma
instance Generic (ModulePragma l)
instance Eq l => Eq (Module l)
instance Ord l => Ord (Module l)
instance Show l => Show (Module l)
instance Data l => Data (Module l)
instance Foldable Module
instance Traversable Module
instance Functor Module
instance Generic (Module l)
instance Datatype D1ModuleName
instance Constructor C1_0ModuleName
instance Datatype D1Name
instance Constructor C1_0Name
instance Constructor C1_1Name
instance Datatype D1IPName
instance Constructor C1_0IPName
instance Constructor C1_1IPName
instance Datatype D1Op
instance Constructor C1_0Op
instance Constructor C1_1Op
instance Datatype D1CName
instance Constructor C1_0CName
instance Constructor C1_1CName
instance Datatype D1Namespace
instance Constructor C1_0Namespace
instance Constructor C1_1Namespace
instance Datatype D1ImportSpec
instance Constructor C1_0ImportSpec
instance Constructor C1_1ImportSpec
instance Constructor C1_2ImportSpec
instance Constructor C1_3ImportSpec
instance Datatype D1ImportSpecList
instance Constructor C1_0ImportSpecList
instance Datatype D1ImportDecl
instance Constructor C1_0ImportDecl
instance Selector S1_0_0ImportDecl
instance Selector S1_0_1ImportDecl
instance Selector S1_0_2ImportDecl
instance Selector S1_0_3ImportDecl
instance Selector S1_0_4ImportDecl
instance Selector S1_0_5ImportDecl
instance Selector S1_0_6ImportDecl
instance Selector S1_0_7ImportDecl
instance Datatype D1Assoc
instance Constructor C1_0Assoc
instance Constructor C1_1Assoc
instance Constructor C1_2Assoc
instance Datatype D1BooleanFormula
instance Constructor C1_0BooleanFormula
instance Constructor C1_1BooleanFormula
instance Constructor C1_2BooleanFormula
instance Constructor C1_3BooleanFormula
instance Datatype D1DataOrNew
instance Constructor C1_0DataOrNew
instance Constructor C1_1DataOrNew
instance Datatype D1BangType
instance Constructor C1_0BangType
instance Constructor C1_1BangType
instance Datatype D1Boxed
instance Constructor C1_0Boxed
instance Constructor C1_1Boxed
instance Datatype D1SpecialCon
instance Constructor C1_0SpecialCon
instance Constructor C1_1SpecialCon
instance Constructor C1_2SpecialCon
instance Constructor C1_3SpecialCon
instance Constructor C1_4SpecialCon
instance Constructor C1_5SpecialCon
instance Datatype D1QName
instance Constructor C1_0QName
instance Constructor C1_1QName
instance Constructor C1_2QName
instance Datatype D1Promoted
instance Constructor C1_0Promoted
instance Constructor C1_1Promoted
instance Constructor C1_2Promoted
instance Constructor C1_3Promoted
instance Constructor C1_4Promoted
instance Constructor C1_5Promoted
instance Datatype D1ExportSpec
instance Constructor C1_0ExportSpec
instance Constructor C1_1ExportSpec
instance Constructor C1_2ExportSpec
instance Constructor C1_3ExportSpec
instance Constructor C1_4ExportSpec
instance Datatype D1ExportSpecList
instance Constructor C1_0ExportSpecList
instance Datatype D1QOp
instance Constructor C1_0QOp
instance Constructor C1_1QOp
instance Datatype D1Kind
instance Constructor C1_0Kind
instance Constructor C1_1Kind
instance Constructor C1_2Kind
instance Constructor C1_3Kind
instance Constructor C1_4Kind
instance Constructor C1_5Kind
instance Constructor C1_6Kind
instance Constructor C1_7Kind
instance Datatype D1TyVarBind
instance Constructor C1_0TyVarBind
instance Constructor C1_1TyVarBind
instance Datatype D1DeclHead
instance Constructor C1_0DeclHead
instance Constructor C1_1DeclHead
instance Constructor C1_2DeclHead
instance Constructor C1_3DeclHead
instance Datatype D1FunDep
instance Constructor C1_0FunDep
instance Datatype D1Literal
instance Constructor C1_0Literal
instance Constructor C1_1Literal
instance Constructor C1_2Literal
instance Constructor C1_3Literal
instance Constructor C1_4Literal
instance Constructor C1_5Literal
instance Constructor C1_6Literal
instance Constructor C1_7Literal
instance Constructor C1_8Literal
instance Constructor C1_9Literal
instance Datatype D1Sign
instance Constructor C1_0Sign
instance Constructor C1_1Sign
instance Datatype D1XName
instance Constructor C1_0XName
instance Constructor C1_1XName
instance Datatype D1Safety
instance Constructor C1_0Safety
instance Constructor C1_1Safety
instance Constructor C1_2Safety
instance Datatype D1CallConv
instance Constructor C1_0CallConv
instance Constructor C1_1CallConv
instance Constructor C1_2CallConv
instance Constructor C1_3CallConv
instance Constructor C1_4CallConv
instance Constructor C1_5CallConv
instance Constructor C1_6CallConv
instance Datatype D1Tool
instance Constructor C1_0Tool
instance Constructor C1_1Tool
instance Constructor C1_2Tool
instance Constructor C1_3Tool
instance Constructor C1_4Tool
instance Constructor C1_5Tool
instance Datatype D1Overlap
instance Constructor C1_0Overlap
instance Constructor C1_1Overlap
instance Constructor C1_2Overlap
instance Datatype D1Activation
instance Constructor C1_0Activation
instance Constructor C1_1Activation
instance Datatype D1WarningText
instance Constructor C1_0WarningText
instance Constructor C1_1WarningText
instance Datatype D1ModuleHead
instance Constructor C1_0ModuleHead
instance Datatype D1RPatOp
instance Constructor C1_0RPatOp
instance Constructor C1_1RPatOp
instance Constructor C1_2RPatOp
instance Constructor C1_3RPatOp
instance Constructor C1_4RPatOp
instance Constructor C1_5RPatOp
instance Datatype D1Alt
instance Constructor C1_0Alt
instance Datatype D1Pat
instance Constructor C1_0Pat
instance Constructor C1_1Pat
instance Constructor C1_2Pat
instance Constructor C1_3Pat
instance Constructor C1_4Pat
instance Constructor C1_5Pat
instance Constructor C1_6Pat
instance Constructor C1_7Pat
instance Constructor C1_8Pat
instance Constructor C1_9Pat
instance Constructor C1_10Pat
instance Constructor C1_11Pat
instance Constructor C1_12Pat
instance Constructor C1_13Pat
instance Constructor C1_14Pat
instance Constructor C1_15Pat
instance Constructor C1_16Pat
instance Constructor C1_17Pat
instance Constructor C1_18Pat
instance Constructor C1_19Pat
instance Constructor C1_20Pat
instance Constructor C1_21Pat
instance Datatype D1PatField
instance Constructor C1_0PatField
instance Constructor C1_1PatField
instance Constructor C1_2PatField
instance Datatype D1RPat
instance Constructor C1_0RPat
instance Constructor C1_1RPat
instance Constructor C1_2RPat
instance Constructor C1_3RPat
instance Constructor C1_4RPat
instance Constructor C1_5RPat
instance Constructor C1_6RPat
instance Constructor C1_7RPat
instance Datatype D1Stmt
instance Constructor C1_0Stmt
instance Constructor C1_1Stmt
instance Constructor C1_2Stmt
instance Constructor C1_3Stmt
instance Datatype D1Exp
instance Constructor C1_0Exp
instance Constructor C1_1Exp
instance Constructor C1_2Exp
instance Constructor C1_3Exp
instance Constructor C1_4Exp
instance Constructor C1_5Exp
instance Constructor C1_6Exp
instance Constructor C1_7Exp
instance Constructor C1_8Exp
instance Constructor C1_9Exp
instance Constructor C1_10Exp
instance Constructor C1_11Exp
instance Constructor C1_12Exp
instance Constructor C1_13Exp
instance Constructor C1_14Exp
instance Constructor C1_15Exp
instance Constructor C1_16Exp
instance Constructor C1_17Exp
instance Constructor C1_18Exp
instance Constructor C1_19Exp
instance Constructor C1_20Exp
instance Constructor C1_21Exp
instance Constructor C1_22Exp
instance Constructor C1_23Exp
instance Constructor C1_24Exp
instance Constructor C1_25Exp
instance Constructor C1_26Exp
instance Constructor C1_27Exp
instance Constructor C1_28Exp
instance Constructor C1_29Exp
instance Constructor C1_30Exp
instance Constructor C1_31Exp
instance Constructor C1_32Exp
instance Constructor C1_33Exp
instance Constructor C1_34Exp
instance Constructor C1_35Exp
instance Constructor C1_36Exp
instance Constructor C1_37Exp
instance Constructor C1_38Exp
instance Constructor C1_39Exp
instance Constructor C1_40Exp
instance Constructor C1_41Exp
instance Constructor C1_42Exp
instance Constructor C1_43Exp
instance Constructor C1_44Exp
instance Constructor C1_45Exp
instance Constructor C1_46Exp
instance Constructor C1_47Exp
instance Constructor C1_48Exp
instance Constructor C1_49Exp
instance Constructor C1_50Exp
instance Constructor C1_51Exp
instance Datatype D1FieldUpdate
instance Constructor C1_0FieldUpdate
instance Constructor C1_1FieldUpdate
instance Constructor C1_2FieldUpdate
instance Datatype D1QualStmt
instance Constructor C1_0QualStmt
instance Constructor C1_1QualStmt
instance Constructor C1_2QualStmt
instance Constructor C1_3QualStmt
instance Constructor C1_4QualStmt
instance Constructor C1_5QualStmt
instance Datatype D1Splice
instance Constructor C1_0Splice
instance Constructor C1_1Splice
instance Datatype D1Bracket
instance Constructor C1_0Bracket
instance Constructor C1_1Bracket
instance Constructor C1_2Bracket
instance Constructor C1_3Bracket
instance Datatype D1Type
instance Constructor C1_0Type
instance Constructor C1_1Type
instance Constructor C1_2Type
instance Constructor C1_3Type
instance Constructor C1_4Type
instance Constructor C1_5Type
instance Constructor C1_6Type
instance Constructor C1_7Type
instance Constructor C1_8Type
instance Constructor C1_9Type
instance Constructor C1_10Type
instance Constructor C1_11Type
instance Constructor C1_12Type
instance Constructor C1_13Type
instance Constructor C1_14Type
instance Datatype D1Context
instance Constructor C1_0Context
instance Constructor C1_1Context
instance Constructor C1_2Context
instance Datatype D1Asst
instance Constructor C1_0Asst
instance Constructor C1_1Asst
instance Constructor C1_2Asst
instance Constructor C1_3Asst
instance Constructor C1_4Asst
instance Constructor C1_5Asst
instance Datatype D1Decl
instance Constructor C1_0Decl
instance Constructor C1_1Decl
instance Constructor C1_2Decl
instance Constructor C1_3Decl
instance Constructor C1_4Decl
instance Constructor C1_5Decl
instance Constructor C1_6Decl
instance Constructor C1_7Decl
instance Constructor C1_8Decl
instance Constructor C1_9Decl
instance Constructor C1_10Decl
instance Constructor C1_11Decl
instance Constructor C1_12Decl
instance Constructor C1_13Decl
instance Constructor C1_14Decl
instance Constructor C1_15Decl
instance Constructor C1_16Decl
instance Constructor C1_17Decl
instance Constructor C1_18Decl
instance Constructor C1_19Decl
instance Constructor C1_20Decl
instance Constructor C1_21Decl
instance Constructor C1_22Decl
instance Constructor C1_23Decl
instance Constructor C1_24Decl
instance Constructor C1_25Decl
instance Constructor C1_26Decl
instance Constructor C1_27Decl
instance Constructor C1_28Decl
instance Constructor C1_29Decl
instance Datatype D1Rule
instance Constructor C1_0Rule
instance Datatype D1RuleVar
instance Constructor C1_0RuleVar
instance Constructor C1_1RuleVar
instance Datatype D1Rhs
instance Constructor C1_0Rhs
instance Constructor C1_1Rhs
instance Datatype D1GuardedRhs
instance Constructor C1_0GuardedRhs
instance Datatype D1InstDecl
instance Constructor C1_0InstDecl
instance Constructor C1_1InstDecl
instance Constructor C1_2InstDecl
instance Constructor C1_3InstDecl
instance Datatype D1GadtDecl
instance Constructor C1_0GadtDecl
instance Datatype D1FieldDecl
instance Constructor C1_0FieldDecl
instance Datatype D1QualConDecl
instance Constructor C1_0QualConDecl
instance Datatype D1ConDecl
instance Constructor C1_0ConDecl
instance Constructor C1_1ConDecl
instance Constructor C1_2ConDecl
instance Datatype D1Deriving
instance Constructor C1_0Deriving
instance Datatype D1InstRule
instance Constructor C1_0InstRule
instance Constructor C1_1InstRule
instance Datatype D1InstHead
instance Constructor C1_0InstHead
instance Constructor C1_1InstHead
instance Constructor C1_2InstHead
instance Constructor C1_3InstHead
instance Datatype D1ClassDecl
instance Constructor C1_0ClassDecl
instance Constructor C1_1ClassDecl
instance Constructor C1_2ClassDecl
instance Constructor C1_3ClassDecl
instance Constructor C1_4ClassDecl
instance Datatype D1Match
instance Constructor C1_0Match
instance Constructor C1_1Match
instance Datatype D1Binds
instance Constructor C1_0Binds
instance Constructor C1_1Binds
instance Datatype D1IPBind
instance Constructor C1_0IPBind
instance Datatype D1Annotation
instance Constructor C1_0Annotation
instance Constructor C1_1Annotation
instance Constructor C1_2Annotation
instance Datatype D1TypeEqn
instance Constructor C1_0TypeEqn
instance Datatype D1XAttr
instance Constructor C1_0XAttr
instance Datatype D1PXAttr
instance Constructor C1_0PXAttr
instance Datatype D1ModulePragma
instance Constructor C1_0ModulePragma
instance Constructor C1_1ModulePragma
instance Constructor C1_2ModulePragma
instance Datatype D1Module
instance Constructor C1_0Module
instance Constructor C1_1Module
instance Constructor C1_2Module
instance Annotated Promoted
instance Annotated Alt
instance Annotated FieldUpdate
instance Annotated QualStmt
instance Annotated Stmt
instance Annotated PatField
instance Annotated RPat
instance Annotated RPatOp
instance Annotated PXAttr
instance Annotated Pat
instance Annotated WarningText
instance Annotated RuleVar
instance Annotated Rule
instance Annotated Activation
instance Annotated Overlap
instance Annotated ModulePragma
instance Annotated CallConv
instance Annotated Safety
instance Annotated Splice
instance Annotated Bracket
instance Annotated XAttr
instance Annotated XName
instance Annotated Exp
instance Annotated Sign
instance Annotated Literal
instance Annotated Asst
instance Annotated Context
instance Annotated FunDep
instance Annotated Kind
instance Annotated TyVarBind
instance Annotated Type
instance Annotated GuardedRhs
instance Annotated Rhs
instance Annotated BangType
instance Annotated InstDecl
instance Annotated ClassDecl
instance Annotated GadtDecl
instance Annotated FieldDecl
instance Annotated ConDecl
instance Annotated QualConDecl
instance Annotated Match
instance Annotated IPBind
instance Annotated Binds
instance Annotated InstHead
instance Annotated InstRule
instance Annotated DeclHead
instance Annotated DataOrNew
instance Annotated BooleanFormula
instance Annotated Annotation
instance Annotated Decl
instance Annotated TypeEqn
instance Annotated Deriving
instance Annotated Assoc
instance Annotated ImportSpec
instance Annotated ImportSpecList
instance Annotated ImportDecl
instance Annotated Namespace
instance Annotated ExportSpec
instance Annotated ExportSpecList
instance Annotated ModuleHead
instance Annotated Module
instance Annotated CName
instance Annotated Op
instance Annotated QOp
instance Annotated IPName
instance Annotated Name
instance Annotated QName
instance Annotated SpecialCon
instance Annotated ModuleName


-- | This module contains combinators to use when building Haskell source
--   trees programmatically, as opposed to parsing them from a string. The
--   contents here are quite experimental and will likely receive a lot of
--   attention when the rest has stabilised.
module Language.Haskell.Exts.Annotated.Build

-- | An identifier with the given string as its name. The string should be
--   a valid Haskell identifier.
name :: l -> String -> Name l

-- | A symbol identifier. The string should be a valid Haskell symbol
--   identifier.
sym :: l -> String -> Name l

-- | A local variable as expression.
var :: l -> Name l -> Exp l

-- | Use the given identifier as an operator.
op :: l -> Name l -> QOp l

-- | A qualified variable as expression.
qvar :: l -> ModuleName l -> Name l -> Exp l

-- | A pattern variable.
pvar :: l -> Name l -> Pat l

-- | Application of expressions by juxtaposition.
app :: l -> Exp l -> Exp l -> Exp l

-- | Apply an operator infix.
infixApp :: l -> Exp l -> QOp l -> Exp l -> Exp l

-- | Apply a function to a list of arguments.
appFun :: [l] -> Exp l -> [Exp l] -> Exp l

-- | A constructor pattern, with argument patterns.
pApp :: l -> Name l -> [Pat l] -> Pat l

-- | A tuple expression.
tuple :: l -> [Exp l] -> Exp l

-- | A tuple pattern.
pTuple :: l -> [Pat l] -> Pat l

-- | A tuple expression consisting of variables only.
varTuple :: l -> [Name l] -> Exp l

-- | A tuple pattern consisting of variables only.
pvarTuple :: l -> [Name l] -> Pat l

-- | A function with a given name.
function :: l -> String -> Exp l

-- | A literal string expression.
strE :: l -> String -> Exp l

-- | A literal character expression.
charE :: l -> Char -> Exp l

-- | A literal integer expression.
intE :: l -> Integer -> Exp l

-- | A literal string pattern.
strP :: l -> String -> Pat l

-- | A literal character pattern.
charP :: l -> Char -> Pat l

-- | A literal integer pattern.
intP :: l -> Integer -> Pat l

-- | A do block formed by the given statements. The last statement in the
--   list should be a <a>Qualifier</a> expression.
doE :: l -> [Stmt l] -> Exp l

-- | Lambda abstraction, given a list of argument patterns and an
--   expression body.
lamE :: l -> [Pat l] -> Exp l -> Exp l

-- | A <tt>let</tt> ... <tt>in</tt> block.
letE :: l -> [Decl l] -> Exp l -> Exp l

-- | A <tt>case</tt> expression.
caseE :: l -> Exp l -> [Alt l] -> Exp l

-- | An unguarded alternative in a <tt>case</tt> expression.
alt :: l -> Pat l -> Exp l -> Alt l

-- | An alternative with a single guard in a <tt>case</tt> expression.
altGW :: l -> Pat l -> [Stmt l] -> Exp l -> Binds l -> Alt l

-- | A list expression.
listE :: l -> [Exp l] -> Exp l

-- | The empty list expression.
eList :: l -> Exp l

-- | The empty list pattern.
peList :: l -> Pat l

-- | Put parentheses around an expression.
paren :: l -> Exp l -> Exp l

-- | Put parentheses around a pattern.
pParen :: l -> Pat l -> Pat l

-- | A qualifier expression statement.
qualStmt :: l -> Exp l -> Stmt l

-- | A generator statement: <i>pat</i> <tt>&lt;-</tt> <i>exp</i>
genStmt :: l -> Pat l -> Exp l -> Stmt l

-- | A <tt>let</tt> binding group as a statement.
letStmt :: l -> [Decl l] -> Stmt l

-- | Hoist a set of declarations to a binding group.
binds :: l -> [Decl l] -> Binds l

-- | An empty binding group.
noBinds :: l -> Binds l

-- | The wildcard pattern: <tt>_</tt>
wildcard :: l -> Pat l

-- | Generate k names by appending numbers 1 through k to a given string.
genNames :: l -> String -> Int -> [Name l]

-- | A function with a single clause
sfun :: l -> Name l -> [Name l] -> Rhs l -> Maybe (Binds l) -> Decl l

-- | A function with a single clause, a single argument, no guards and no
--   where declarations
simpleFun :: l -> Name l -> Name l -> Exp l -> Decl l

-- | A pattern bind where the pattern is a variable, and where there are no
--   guards and no 'where' clause.
patBind :: l -> Pat l -> Exp l -> Decl l

-- | A pattern bind where the pattern is a variable, and where there are no
--   guards, but with a 'where' clause.
patBindWhere :: l -> Pat l -> Exp l -> [Decl l] -> Decl l

-- | Bind an identifier to an expression.
nameBind :: l -> Name l -> Exp l -> Decl l

-- | Apply function of a given name to a list of arguments.
metaFunction :: l -> String -> [Exp l] -> Exp l

-- | Apply a constructor of a given name to a list of pattern arguments,
--   forming a constructor pattern.
metaConPat :: l -> String -> [Pat l] -> Pat l


-- | This module defines various data types representing source location
--   information, of varying degree of preciseness.
module Language.Haskell.Exts.SrcLoc

-- | A single position in the source.
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
srcFilename :: SrcLoc -> String
srcLine :: SrcLoc -> Int
srcColumn :: SrcLoc -> Int
noLoc :: SrcLoc

-- | A portion of the source, spanning one or more lines and zero or more
--   columns.
data SrcSpan
SrcSpan :: String -> Int -> Int -> Int -> Int -> SrcSpan
srcSpanFilename :: SrcSpan -> String
srcSpanStartLine :: SrcSpan -> Int
srcSpanStartColumn :: SrcSpan -> Int
srcSpanEndLine :: SrcSpan -> Int
srcSpanEndColumn :: SrcSpan -> Int

-- | Returns <a>srcSpanStartLine</a> and <a>srcSpanStartColumn</a> in a
--   pair.
srcSpanStart :: SrcSpan -> (Int, Int)

-- | Returns <a>srcSpanEndLine</a> and <a>srcSpanEndColumn</a> in a pair.
srcSpanEnd :: SrcSpan -> (Int, Int)

-- | Combine two locations in the source to denote a span.
mkSrcSpan :: SrcLoc -> SrcLoc -> SrcSpan

-- | Merge two source spans into a single span from the start of the first
--   to the end of the second. Assumes that the two spans relate to the
--   same source file.
mergeSrcSpan :: SrcSpan -> SrcSpan -> SrcSpan

-- | Test if a given span starts and ends at the same location.
isNullSpan :: SrcSpan -> Bool
spanSize :: SrcSpan -> (Int, Int)

-- | An entity located in the source.
data Loc a
Loc :: SrcSpan -> a -> Loc a
loc :: Loc a -> SrcSpan
unLoc :: Loc a -> a

-- | A portion of the source, extended with information on the position of
--   entities within the span.
data SrcSpanInfo
SrcSpanInfo :: SrcSpan -> [SrcSpan] -> SrcSpanInfo
srcInfoSpan :: SrcSpanInfo -> SrcSpan
srcInfoPoints :: SrcSpanInfo -> [SrcSpan]

-- | Generate a <a>SrcSpanInfo</a> with no positional information for
--   entities.
noInfoSpan :: SrcSpan -> SrcSpanInfo

-- | Generate a <a>SrcSpanInfo</a> with the supplied positional information
--   for entities.
infoSpan :: SrcSpan -> [SrcSpan] -> SrcSpanInfo

-- | Combine two <a>SrcSpanInfo</a>s into one that spans the combined
--   source area of the two arguments, leaving positional information
--   blank.
combSpanInfo :: SrcSpanInfo -> SrcSpanInfo -> SrcSpanInfo

-- | Short name for <a>combSpanInfo</a>
(<++>) :: SrcSpanInfo -> SrcSpanInfo -> SrcSpanInfo

-- | Optionally combine the first argument with the second, or return it
--   unchanged if the second argument is <a>Nothing</a>.
(<+?>) :: SrcSpanInfo -> Maybe SrcSpanInfo -> SrcSpanInfo

-- | Optionally combine the second argument with the first, or return it
--   unchanged if the first argument is <a>Nothing</a>.
(<?+>) :: Maybe SrcSpanInfo -> SrcSpanInfo -> SrcSpanInfo

-- | Add more positional information for entities of a span.
(<**) :: SrcSpanInfo -> [SrcSpan] -> SrcSpanInfo

-- | Merge two <a>SrcSpan</a>s and lift them to a <tt>SrcInfoSpan</tt> with
--   no positional information for entities.
(<^^>) :: SrcSpan -> SrcSpan -> SrcSpanInfo

-- | A class to work over all kinds of source location information.
class SrcInfo si where getPointLoc si = SrcLoc (fileName si) (startLine si) (startColumn si)
toSrcInfo :: SrcInfo si => SrcLoc -> [SrcSpan] -> SrcLoc -> si
fromSrcInfo :: SrcInfo si => SrcSpanInfo -> si
getPointLoc :: SrcInfo si => si -> SrcLoc
fileName :: SrcInfo si => si -> String
startLine :: SrcInfo si => si -> Int
startColumn :: SrcInfo si => si -> Int
instance Typeable SrcLoc
instance Typeable SrcSpan
instance Typeable SrcSpanInfo
instance Eq SrcLoc
instance Ord SrcLoc
instance Data SrcLoc
instance Generic SrcLoc
instance Eq SrcSpan
instance Ord SrcSpan
instance Data SrcSpan
instance Eq a => Eq (Loc a)
instance Ord a => Ord (Loc a)
instance Show a => Show (Loc a)
instance Eq SrcSpanInfo
instance Ord SrcSpanInfo
instance Show SrcSpanInfo
instance Data SrcSpanInfo
instance Datatype D1SrcLoc
instance Constructor C1_0SrcLoc
instance Selector S1_0_0SrcLoc
instance Selector S1_0_1SrcLoc
instance Selector S1_0_2SrcLoc
instance SrcInfo SrcSpanInfo
instance SrcInfo SrcSpan
instance SrcInfo SrcLoc
instance Show SrcSpan
instance Show SrcLoc

module Language.Haskell.Exts.Comments

-- | A Haskell comment. The <a>Bool</a> is <a>True</a> if the comment is
--   multi-line, i.e. <tt>{- -}</tt>.
data Comment
Comment :: Bool -> SrcSpan -> String -> Comment

-- | An unknown pragma.
data UnknownPragma
UnknownPragma :: SrcSpan -> String -> UnknownPragma
instance Typeable Comment
instance Typeable UnknownPragma
instance Eq Comment
instance Show Comment
instance Data Comment
instance Eq UnknownPragma
instance Show UnknownPragma
instance Data UnknownPragma


-- | Exact-printer for Haskell abstract syntax. The input is a
--   (semi-concrete) abstract syntax tree, annotated with exact source
--   information to enable printing the tree exactly as it was parsed.
module Language.Haskell.Exts.Annotated.ExactPrint

-- | Print an AST exactly as specified by the annotations on the nodes in
--   the tree.
exactPrint :: ExactP ast => ast SrcSpanInfo -> [Comment] -> String
class Annotated ast => ExactP ast
instance Functor GuardedAlts
instance Show l => Show (GuardedAlts l)
instance Functor GuardedAlt
instance Show l => Show (GuardedAlt l)
instance ExactP IPBind
instance ExactP FieldDecl
instance ExactP Activation
instance ExactP Overlap
instance ExactP RuleVar
instance ExactP Rule
instance ExactP Safety
instance ExactP CallConv
instance ExactP Binds
instance ExactP XName
instance ExactP PXAttr
instance ExactP RPatOp
instance ExactP RPat
instance ExactP PatField
instance ExactP Pat
instance ExactP GuardedAlt
instance ExactP GuardedAlts
instance Annotated GuardedAlt
instance Annotated GuardedAlts
instance ExactP GuardedRhs
instance ExactP Rhs
instance ExactP Match
instance ExactP Alt
instance ExactP XAttr
instance ExactP Bracket
instance ExactP QualStmt
instance ExactP Stmt
instance ExactP FieldUpdate
instance ExactP Exp
instance ExactP Splice
instance ExactP BangType
instance ExactP GadtDecl
instance ExactP ConDecl
instance ExactP QualConDecl
instance ExactP FunDep
instance ExactP InstDecl
instance ExactP ClassDecl
instance ExactP Deriving
instance ExactP Asst
instance ExactP Context
instance ExactP Promoted
instance ExactP Type
instance ExactP Kind
instance ExactP TyVarBind
instance ExactP InstHead
instance ExactP InstRule
instance ExactP DeclHead
instance ExactP BooleanFormula
instance ExactP Annotation
instance ExactP Decl
instance ExactP TypeEqn
instance ExactP DataOrNew
instance ExactP Assoc
instance ExactP WarningText
instance ExactP ModulePragma
instance ExactP ModuleHead
instance ExactP Module
instance ExactP ImportDecl
instance ExactP ImportSpec
instance ExactP ImportSpecList
instance ExactP ExportSpecList
instance ExactP ExportSpec
instance ExactP Namespace
instance ExactP CName
instance ExactP Op
instance ExactP QOp
instance ExactP IPName
instance ExactP Name
instance ExactP QName
instance ExactP SpecialCon
instance ExactP ModuleName
instance ExactP Sign
instance ExactP Literal
instance Monad EP
instance Applicative EP
instance Functor EP


-- | This module defines the list of recognized modular features of
--   Haskell, most often (sloppily) referred to as "extensions".
--   
--   Closely mimicking the Language.Haskell.Extension module from the Cabal
--   library, this package also includes functionality for "computing"
--   languages as sets of features. Also, we make no promise not to add
--   extensions not yet recognized by Cabal.
module Language.Haskell.Exts.Extension
data Language

-- | The Haskell 98 language as defined by the Haskell 98 report.
--   <a>http://haskell.org/onlinereport/</a>
Haskell98 :: Language

-- | The Haskell 2010 language as defined by the Haskell 2010 report.
--   <a>http://www.haskell.org/onlinereport/haskell2010</a>
Haskell2010 :: Language

-- | The minimal language resulting from disabling all recognized
--   extensions - including ones that are part of all known language
--   definitions e.g. MonomorphismRestriction.
HaskellAllDisabled :: Language

-- | An unknown language, identified by its name.
UnknownLanguage :: String -> Language
knownLanguages :: [Language]
classifyLanguage :: String -> Language
prettyLanguage :: Language -> String

-- | This represents language extensions beyond a base <a>Language</a>
--   definition (such as <a>Haskell98</a>) that are supported by some
--   implementations, usually in some special mode.
data Extension

-- | Enable a known extension
EnableExtension :: KnownExtension -> Extension

-- | Disable a known extension
DisableExtension :: KnownExtension -> Extension

-- | An unknown extension, identified by the name of its <tt>LANGUAGE</tt>
--   pragma.
UnknownExtension :: String -> Extension
data KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.4</i> Allow overlapping class instances, provided
--   there is a unique most specific instance for each use.</li>
--   </ul>
OverlappingInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.3</i> Ignore structural rules guaranteeing the
--   termination of class instance resolution. Termination is guaranteed by
--   a fixed-depth recursion stack, and compilation may fail if this depth
--   is exceeded.</li>
--   </ul>
UndecidableInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.4</i> Implies <a>OverlappingInstances</a>. Allow
--   the implementation to choose an instance even when it is possible that
--   further instantiation of types will lead to a more specific instance
--   being applicable.</li>
--   </ul>
IncoherentInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.5</i> Allow type signatures in instances.</li>
--   </ul>
InstanceSigs :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.8</i> Allows recursive bindings in <tt>do</tt>
--   blocks, using the <tt>rec</tt> keyword.</li>
--   </ul>
DoRec :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.8.2</i> Deprecated in GHC. Allows recursive bindings
--   using <tt>mdo</tt>, a variant of <tt>do</tt>. <tt>DoRec</tt> provides
--   a different, preferred syntax.</li>
--   </ul>
RecursiveDo :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.9</i> Provide syntax for writing list comprehensions
--   which iterate over several lists together, like the <a>zipWith</a>
--   family of functions.</li>
--   </ul>
ParallelListComp :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.1.1</i> Allow multiple parameters in a type
--   class.</li>
--   </ul>
MultiParamTypeClasses :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.17</i> Enable the dreaded monomorphism
--   restriction.</li>
--   </ul>
MonomorphismRestriction :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.2</i> Allow a specification attached to a
--   multi-parameter type class which indicates that some parameters are
--   entirely determined by others. The implementation will check that this
--   property holds for the declared instances, and will use this property
--   to reduce ambiguity in instance resolution.</li>
--   </ul>
FunctionalDependencies :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.5</i> Like <a>RankNTypes</a> but does not allow a
--   higher-rank type to itself appear on the left of a function
--   arrow.</li>
--   </ul>
Rank2Types :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.5</i> Allow a universally-quantified type to occur on
--   the left of a function arrow.</li>
--   </ul>
RankNTypes :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.5</i> Allow data constructors to have polymorphic
--   arguments. Unlike <a>RankNTypes</a>, does not allow this for ordinary
--   functions.</li>
--   </ul>
PolymorphicComponents :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.4</i> Allow existentially-quantified data
--   constructors.</li>
--   </ul>
ExistentialQuantification :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.7</i> Cause a type variable in a signature, which has
--   an explicit <tt>forall</tt> quantifier, to scope over the definition
--   of the accompanying value declaration.</li>
--   </ul>
ScopedTypeVariables :: KnownExtension

-- | Deprecated, use <a>ScopedTypeVariables</a> instead.
PatternSignatures :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.3</i> Enable implicit function parameters with
--   dynamic scope.</li>
--   </ul>
ImplicitParams :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.2</i> Relax some restrictions on the form of the
--   context of a type signature.</li>
--   </ul>
FlexibleContexts :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.2</i> Relax some restrictions on the form of the
--   context of an instance declaration.</li>
--   </ul>
FlexibleInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.1</i> Allow data type declarations with no
--   constructors.</li>
--   </ul>
EmptyDataDecls :: KnownExtension

-- | <ul>
--   <li><i>GHC § 4.10.3</i> Run the C preprocessor on Haskell source
--   code.</li>
--   </ul>
CPP :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.4</i> Allow an explicit kind signature giving the
--   kind of types over which a type variable ranges.</li>
--   </ul>
KindSignatures :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.11</i> Enable a form of pattern which forces evaluation
--   before an attempted match, and a form of strict
--   <tt>let</tt>/<tt>where</tt> binding.</li>
--   </ul>
BangPatterns :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.1</i> Allow type synonyms in instance heads.</li>
--   </ul>
TypeSynonymInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.9</i> Enable Template Haskell, a system for
--   compile-time metaprogramming.</li>
--   </ul>
TemplateHaskell :: KnownExtension

-- | <ul>
--   <li><i>GHC § 8</i> Enable the Foreign Function Interface. In GHC,
--   implements the standard Haskell 98 Foreign Function Interface
--   Addendum, plus some GHC-specific extensions.</li>
--   </ul>
ForeignFunctionInterface :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.10</i> Enable arrow notation.</li>
--   </ul>
Arrows :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.16</i> Enable generic type classes, with default
--   instances defined in terms of the algebraic structure of a type.</li>
--   </ul>
Generics :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.11</i> Enable the implicit importing of the module
--   <tt>Prelude</tt>. When disabled, when desugaring certain built-in
--   syntax into ordinary identifiers, use whatever is in scope rather than
--   the <tt>Prelude</tt> -- version.</li>
--   </ul>
ImplicitPrelude :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.15</i> Enable syntax for implicitly binding local
--   names corresponding to the field names of a record. Puns bind specific
--   names, unlike <a>RecordWildCards</a>.</li>
--   </ul>
NamedFieldPuns :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.5</i> Enable a form of guard which matches a pattern
--   and binds variables.</li>
--   </ul>
PatternGuards :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.5.4</i> Allow a type declared with <tt>newtype</tt> to
--   use <tt>deriving</tt> for any class with an instance for the
--   underlying type.</li>
--   </ul>
GeneralizedNewtypeDeriving :: KnownExtension

-- | <ul>
--   <li><i>Hugs § 7.1</i> Enable the "Trex" extensible records
--   system.</li>
--   </ul>
ExtensibleRecords :: KnownExtension

-- | <ul>
--   <li><i>Hugs § 7.2</i> Enable type synonyms which are transparent in
--   some definitions and opaque elsewhere, as a way of implementing
--   abstract datatypes.</li>
--   </ul>
RestrictedTypeSynonyms :: KnownExtension

-- | <ul>
--   <li><i>Hugs § 7.3</i> Enable an alternate syntax for string literals,
--   with string templating.</li>
--   </ul>
HereDocuments :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.2</i> Allow the character <tt>#</tt> as a postfix
--   modifier on identifiers. Also enables literal syntax for unboxed
--   values.</li>
--   </ul>
MagicHash :: KnownExtension

-- | Binary integer literals
BinaryLiterals :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.7</i> Allow data types and type synonyms which are
--   indexed by types, i.e. ad-hoc polymorphism for types.</li>
--   </ul>
TypeFamilies :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.5.2</i> Allow a standalone declaration which invokes
--   the type class <tt>deriving</tt> mechanism.</li>
--   </ul>
StandaloneDeriving :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.1</i> Allow certain Unicode characters to stand for
--   certain ASCII character sequences, e.g. keywords and punctuation.</li>
--   </ul>
UnicodeSyntax :: KnownExtension

-- | <ul>
--   <li><i>GHC § 8.1.1</i> Allow the use of unboxed types as foreign
--   types, e.g. in <tt>foreign import</tt> and <tt>foreign
--   export</tt>.</li>
--   </ul>
UnliftedFFITypes :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.3</i> Defer validity checking of types until after
--   expanding type synonyms, relaxing the constraints on how synonyms may
--   be used.</li>
--   </ul>
LiberalTypeSynonyms :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.2</i> Allow the name of a type constructor, type
--   class, or type variable to be an infix operator.</li>
--   </ul>
TypeOperators :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.26.5</i> Parallel arrays for Data Parallel
--   Haskell.</li>
--   </ul>
ParallelArrays :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.16</i> Enable syntax for implicitly binding local
--   names corresponding to the field names of a record. A wildcard binds
--   all unmentioned names, unlike <a>NamedFieldPuns</a>.</li>
--   </ul>
RecordWildCards :: KnownExtension

-- | Deprecated, use <a>NamedFieldPuns</a> instead.
RecordPuns :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.14</i> Allow a record field name to be disambiguated
--   by the type of the record it's in.</li>
--   </ul>
DisambiguateRecordFields :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.4</i> Enable overloading of string literals using a
--   type class, much like integer literals.</li>
--   </ul>
OverloadedStrings :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.6</i> Enable generalized algebraic data types, in
--   which type variables may be instantiated on a per-constructor basis.
--   Implies GADTSyntax.</li>
--   </ul>
GADTs :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.17.2</i> Make pattern bindings monomorphic.</li>
--   </ul>
MonoPatBinds :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.8</i> Relax the requirements on mutually-recursive
--   polymorphic functions.</li>
--   </ul>
RelaxedPolyRec :: KnownExtension

-- | <ul>
--   <li><i>GHC § 2.4.5</i> Allow default instantiation of polymorphic
--   types in more situations.</li>
--   </ul>
ExtendedDefaultRules :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.2.2</i> Enable unboxed tuples.</li>
--   </ul>
UnboxedTuples :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.5.3</i> Enable <tt>deriving</tt> for classes
--   <tt>Data.Typeable.Typeable</tt> and <tt>Data.Generics.Data</tt>.</li>
--   </ul>
DeriveDataTypeable :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.1.3</i> Allow a class method's type to place
--   additional constraints on a class type variable.</li>
--   </ul>
ConstrainedClassMethods :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.18</i> Allow imports to be qualified by the package
--   name the module is intended to be imported from, e.g.</li>
--   </ul>
--   
--   <pre>
--   import "network" Network.Socket
--   </pre>
PackageImports :: KnownExtension
LambdaCase :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.6</i> Deprecated in GHC 6.12 and will be removed in
--   GHC 7. Allow a type variable to be instantiated at a polymorphic
--   type.</li>
--   </ul>
ImpredicativeTypes :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.3</i> Change the syntax for qualified infix
--   operators.</li>
--   </ul>
NewQualifiedOperators :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.12</i> Relax the interpretation of left operator
--   sections to allow unary postfix operators.</li>
--   </ul>
PostfixOperators :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.9.5</i> Enable quasi-quotation, a mechanism for
--   defining new concrete syntax for expressions and patterns.</li>
--   </ul>
QuasiQuotes :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.10</i> Enable generalized list comprehensions,
--   supporting operations such as sorting and grouping.</li>
--   </ul>
TransformListComp :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.6</i> Enable view patterns, which match a value by
--   applying a function and matching on the result.</li>
--   </ul>
ViewPatterns :: KnownExtension

-- | Allow concrete XML syntax to be used in expressions and patterns, as
--   per the Haskell Server Pages extension language:
--   <a>http://www.haskell.org/haskellwiki/HSP</a>. The ideas behind it are
--   discussed in the paper "Haskell Server Pages through Dynamic Loading"
--   by Niklas Broberg, from Haskell Workshop '05.
XmlSyntax :: KnownExtension

-- | Allow regular pattern matching over lists, as discussed in the paper
--   "Regular Expression Patterns" by Niklas Broberg, Andreas Farre and
--   Josef Svenningsson, from ICFP '04.
RegularPatterns :: KnownExtension

-- | Enables the use of tuple sections, e.g. <tt>(, True)</tt> desugars
--   into <tt>x -&gt; (x, True)</tt>.
TupleSections :: KnownExtension

-- | Allows GHC primops, written in C--, to be imported into a Haskell
--   file.
GHCForeignImportPrim :: KnownExtension

-- | Support for patterns of the form <tt>n + k</tt>, where <tt>k</tt> is
--   an integer literal.
NPlusKPatterns :: KnownExtension

-- | Improve the layout rule when <tt>if</tt> expressions are used in a
--   <tt>do</tt> block.
DoAndIfThenElse :: KnownExtension

-- | Makes much of the Haskell sugar be desugared into calls to the
--   function with a particular name that is in scope.
RebindableSyntax :: KnownExtension

-- | Make <tt>forall</tt> a keyword in types, which can be used to give the
--   generalisation explicitly.
ExplicitForAll :: KnownExtension

-- | Allow contexts to be put on datatypes, e.g. the <tt>Eq a</tt> in
--   <tt>data Eq a =&gt; Set a = NilSet | ConsSet a (Set a)</tt>.
DatatypeContexts :: KnownExtension

-- | Local (<tt>let</tt> and <tt>where</tt>) bindings are monomorphic.
MonoLocalBinds :: KnownExtension

-- | Enable <tt>deriving</tt> for the <tt>Data.Functor.Functor</tt> class.
DeriveFunctor :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.5.3</i> Enable <tt>deriving</tt> for the
--   <tt>Generic</tt> and <tt>Generic1</tt> classes.</li>
--   </ul>
DeriveGeneric :: KnownExtension

-- | Enable <tt>deriving</tt> for the <tt>Data.Traversable.Traversable</tt>
--   class.
DeriveTraversable :: KnownExtension

-- | Enable <tt>deriving</tt> for the <tt>Data.Foldable.Foldable</tt>
--   class.
DeriveFoldable :: KnownExtension

-- | Enable non-decreasing indentation for 'do' blocks.
NondecreasingIndentation :: KnownExtension

-- | <ul>
--   <li><i>GHC § 8.1.4</i> Enable interruptible FFI.</li>
--   </ul>
InterruptibleFFI :: KnownExtension

-- | <ul>
--   <li><i>GHC § 8.1.5</i> Enable the <tt>capi</tt> calling convention in
--   the foreign function interface.</li>
--   </ul>
CApiFFI :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.27</i> Enable explicit namespaces in
--   import/export.</li>
--   </ul>
ExplicitNamespaces :: KnownExtension
DataKinds :: KnownExtension
PolyKinds :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.16</i> Enable the multi-way if-expressions extension
--   to accept conditional expressions with multiple branches.</li>
--   </ul>
MultiWayIf :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.20.3</i> Allow imports to be qualified with a safe
--   keyword that requires the imported module be trusted as according to
--   the Safe Haskell definition of trust.</li>
--   </ul>
--   
--   <pre>
--   import safe Network.Socket
--   </pre>
SafeImports :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.20</i> Compile a module in the Safe, Safe Haskell mode
--   -- a restricted form of the Haskell language to ensure type
--   safety.</li>
--   </ul>
Safe :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.20</i> Compile a module in the Trustworthy, Safe
--   Haskell mode -- no restrictions apply but the module is marked as
--   trusted as long as the package the module resides in is trusted.</li>
--   </ul>
Trustworthy :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.1.4</i> Allow default signatures in class
--   definitions. They apply to default methods implemented in this
--   class.</li>
--   </ul>
DefaultSignatures :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.40</i> Allow type class<i>implicit
--   parameter</i>equality constraints to be used as types with the special
--   kind Constraint. Also generalise the (ctxt =&gt; ty) syntax so that
--   any type of kind Constraint can occur before the arrow.</li>
--   </ul>
ConstraintKinds :: KnownExtension

-- | A clever version of read that returns an <a>UnknownExtension</a> if
--   the string is not recognised.
classifyExtension :: String -> Extension

-- | Parse an enabled or disabled extension; returns
--   <a>UnknownExtension</a> if the parse fails.
parseExtension :: String -> Extension

-- | Pretty print an extension. Disabled extensions are prefixed with 'No'.
prettyExtension :: Extension -> String
ghcDefault :: [Extension]

-- | The list of extensions enabled by GHC's portmanteau -fglasgow-exts
--   flag.
glasgowExts :: [Extension]

-- | List of all known extensions, both "yes" and "no" versions.
knownExtensions :: [Extension]

-- | Extensions that have been deprecated, possibly paired with another
--   extension that replaces it.
deprecatedExtensions :: [(Extension, Maybe Extension)]

-- | Certain extensions imply other extensions, and this function makes the
--   implication explicit. This also handles deprecated extensions, which
--   imply their replacements. The returned value is the transitive closure
--   of implied extensions.
impliesExts :: [KnownExtension] -> [KnownExtension]
toExtensionList :: Language -> [Extension] -> [KnownExtension]
instance Typeable Language
instance Typeable KnownExtension
instance Show Language
instance Read Language
instance Eq Language
instance Ord Language
instance Data Language
instance Show KnownExtension
instance Read KnownExtension
instance Eq KnownExtension
instance Ord KnownExtension
instance Enum KnownExtension
instance Bounded KnownExtension
instance Data KnownExtension
instance Show Extension
instance Read Extension
instance Eq Extension
instance Ord Extension


-- | A suite of datatypes describing the abstract syntax of Haskell 98
--   <a>http://www.haskell.org/onlinereport/</a> plus registered
--   extensions, including:
--   
--   <ul>
--   <li>multi-parameter type classes with functional dependencies
--   (MultiParamTypeClasses, FunctionalDependencies)</li>
--   <li>parameters of type class assertions are unrestricted
--   (FlexibleContexts)</li>
--   <li><tt>forall</tt> types as universal and existential quantification
--   (RankNTypes, ExistentialQuantification, etc)</li>
--   <li>pattern guards (PatternGuards)</li>
--   <li>implicit parameters (ImplicitParameters)</li>
--   <li>generalised algebraic data types (GADTs)</li>
--   <li>template haskell (TemplateHaskell)</li>
--   <li>empty data type declarations (EmptyDataDecls)</li>
--   <li>unboxed tuples (UnboxedTuples)</li>
--   <li>regular patterns (RegularPatterns)</li>
--   <li>HSP-style XML expressions and patterns (XmlSyntax)</li>
--   </ul>
module Language.Haskell.Exts.Syntax

-- | A complete Haskell source module.
data Module
Module :: SrcLoc -> ModuleName -> [ModulePragma] -> (Maybe WarningText) -> (Maybe [ExportSpec]) -> [ImportDecl] -> [Decl] -> Module

-- | Warning text to optionally use in the module header of e.g. a
--   deprecated module.
data WarningText
DeprText :: String -> WarningText
WarnText :: String -> WarningText

-- | An item in a module's export specification.
data ExportSpec

-- | variable.
EVar :: Namespace -> QName -> ExportSpec

-- | <tt>T</tt>: a class or datatype exported abstractly, or a type
--   synonym.
EAbs :: QName -> ExportSpec

-- | <tt>T(..)</tt>: a class exported with all of its methods, or a
--   datatype exported with all of its constructors.
EThingAll :: QName -> ExportSpec

-- | <tt>T(C_1,...,C_n)</tt>: a class exported with some of its methods, or
--   a datatype exported with some of its constructors.
EThingWith :: QName -> [CName] -> ExportSpec

-- | <tt>module M</tt>: re-export a module.
EModuleContents :: ModuleName -> ExportSpec

-- | An import declaration.
data ImportDecl
ImportDecl :: SrcLoc -> ModuleName -> Bool -> Bool -> Bool -> Maybe String -> Maybe ModuleName -> Maybe (Bool, [ImportSpec]) -> ImportDecl

-- | position of the <tt>import</tt> keyword.
importLoc :: ImportDecl -> SrcLoc

-- | name of the module imported.
importModule :: ImportDecl -> ModuleName

-- | imported <tt>qualified</tt>?
importQualified :: ImportDecl -> Bool

-- | imported with <tt>{-# SOURCE #-}</tt>?
importSrc :: ImportDecl -> Bool

-- | Import <tt>safe</tt>?
importSafe :: ImportDecl -> Bool

-- | imported with explicit package name
importPkg :: ImportDecl -> Maybe String

-- | optional alias name in an <tt>as</tt> clause.
importAs :: ImportDecl -> Maybe ModuleName

-- | optional list of import specifications. The <a>Bool</a> is <a>True</a>
--   if the names are excluded by <tt>hiding</tt>.
importSpecs :: ImportDecl -> Maybe (Bool, [ImportSpec])

-- | An import specification, representing a single explicit item imported
--   (or hidden) from a module.
data ImportSpec

-- | variable.
IVar :: Namespace -> Name -> ImportSpec

-- | <tt>T</tt>: the name of a class, datatype or type synonym.
IAbs :: Name -> ImportSpec

-- | <tt>T(..)</tt>: a class imported with all of its methods, or a
--   datatype imported with all of its constructors.
IThingAll :: Name -> ImportSpec

-- | <tt>T(C_1,...,C_n)</tt>: a class imported with some of its methods, or
--   a datatype imported with some of its constructors.
IThingWith :: Name -> [CName] -> ImportSpec

-- | Associativity of an operator.
data Assoc

-- | non-associative operator (declared with <tt>infix</tt>)
AssocNone :: Assoc

-- | left-associative operator (declared with <tt>infixl</tt>).
AssocLeft :: Assoc

-- | right-associative operator (declared with <tt>infixr</tt>)
AssocRight :: Assoc

-- | Namespaces for imports/exports.
data Namespace
NoNamespace :: Namespace
TypeNamespace :: Namespace

-- | A top-level declaration.
data Decl

-- | A type declaration
TypeDecl :: SrcLoc -> Name -> [TyVarBind] -> Type -> Decl

-- | A type family declaration
TypeFamDecl :: SrcLoc -> Name -> [TyVarBind] -> (Maybe Kind) -> Decl

-- | A closed type family declaration
ClosedTypeFamDecl :: SrcLoc -> Name -> [TyVarBind] -> (Maybe Kind) -> [TypeEqn] -> Decl

-- | A data OR newtype declaration
DataDecl :: SrcLoc -> DataOrNew -> Context -> Name -> [TyVarBind] -> [QualConDecl] -> [Deriving] -> Decl

-- | A data OR newtype declaration, GADT style
GDataDecl :: SrcLoc -> DataOrNew -> Context -> Name -> [TyVarBind] -> (Maybe Kind) -> [GadtDecl] -> [Deriving] -> Decl

-- | A data family declaration
DataFamDecl :: SrcLoc -> Context -> Name -> [TyVarBind] -> (Maybe Kind) -> Decl

-- | A type family instance declaration
TypeInsDecl :: SrcLoc -> Type -> Type -> Decl

-- | A data family instance declaration
DataInsDecl :: SrcLoc -> DataOrNew -> Type -> [QualConDecl] -> [Deriving] -> Decl

-- | A data family instance declaration, GADT style
GDataInsDecl :: SrcLoc -> DataOrNew -> Type -> (Maybe Kind) -> [GadtDecl] -> [Deriving] -> Decl

-- | A declaration of a type class
ClassDecl :: SrcLoc -> Context -> Name -> [TyVarBind] -> [FunDep] -> [ClassDecl] -> Decl

-- | An declaration of a type class instance
InstDecl :: SrcLoc -> (Maybe Overlap) -> [TyVarBind] -> Context -> QName -> [Type] -> [InstDecl] -> Decl

-- | A standalone deriving declaration
DerivDecl :: SrcLoc -> (Maybe Overlap) -> [TyVarBind] -> Context -> QName -> [Type] -> Decl

-- | A declaration of operator fixity
InfixDecl :: SrcLoc -> Assoc -> Int -> [Op] -> Decl

-- | A declaration of default types
DefaultDecl :: SrcLoc -> [Type] -> Decl

-- | A Template Haskell splicing declaration
SpliceDecl :: SrcLoc -> Exp -> Decl

-- | A type signature declaration
TypeSig :: SrcLoc -> [Name] -> Type -> Decl

-- | A set of function binding clauses
FunBind :: [Match] -> Decl

-- | A pattern binding
PatBind :: SrcLoc -> Pat -> Rhs -> Binds -> Decl

-- | A foreign import declaration
ForImp :: SrcLoc -> CallConv -> Safety -> String -> Name -> Type -> Decl

-- | A foreign export declaration
ForExp :: SrcLoc -> CallConv -> String -> Name -> Type -> Decl

-- | A RULES pragma
RulePragmaDecl :: SrcLoc -> [Rule] -> Decl

-- | A DEPRECATED pragma
DeprPragmaDecl :: SrcLoc -> [([Name], String)] -> Decl

-- | A WARNING pragma
WarnPragmaDecl :: SrcLoc -> [([Name], String)] -> Decl

-- | An INLINE pragma
InlineSig :: SrcLoc -> Bool -> Activation -> QName -> Decl

-- | An INLINE CONLIKE pragma
InlineConlikeSig :: SrcLoc -> Activation -> QName -> Decl

-- | A SPECIALISE pragma
SpecSig :: SrcLoc -> Activation -> QName -> [Type] -> Decl

-- | A SPECIALISE INLINE pragma
SpecInlineSig :: SrcLoc -> Bool -> Activation -> QName -> [Type] -> Decl

-- | A SPECIALISE instance pragma
InstSig :: SrcLoc -> [TyVarBind] -> Context -> QName -> [Type] -> Decl

-- | An ANN pragma
AnnPragma :: SrcLoc -> Annotation -> Decl

-- | A MINIMAL pragma
MinimalPragma :: SrcLoc -> (Maybe BooleanFormula) -> Decl

-- | A binding group inside a <tt>let</tt> or <tt>where</tt> clause.
data Binds

-- | An ordinary binding group
BDecls :: [Decl] -> Binds

-- | A binding group for implicit parameters
IPBinds :: [IPBind] -> Binds

-- | A binding of an implicit parameter.
data IPBind
IPBind :: SrcLoc -> IPName -> Exp -> IPBind

-- | Declarations inside a class declaration.
data ClassDecl

-- | ordinary declaration
ClsDecl :: Decl -> ClassDecl

-- | declaration of an associated data type
ClsDataFam :: SrcLoc -> Context -> Name -> [TyVarBind] -> (Maybe Kind) -> ClassDecl

-- | declaration of an associated type synonym
ClsTyFam :: SrcLoc -> Name -> [TyVarBind] -> (Maybe Kind) -> ClassDecl

-- | default choice for an associated type synonym
ClsTyDef :: SrcLoc -> Type -> Type -> ClassDecl

-- | default signature
ClsDefSig :: SrcLoc -> Name -> Type -> ClassDecl

-- | Declarations inside an instance declaration.
data InstDecl

-- | ordinary declaration
InsDecl :: Decl -> InstDecl

-- | an associated type definition
InsType :: SrcLoc -> Type -> Type -> InstDecl

-- | an associated data type implementation
InsData :: SrcLoc -> DataOrNew -> Type -> [QualConDecl] -> [Deriving] -> InstDecl

-- | an associated data type implemented using GADT style
InsGData :: SrcLoc -> DataOrNew -> Type -> (Maybe Kind) -> [GadtDecl] -> [Deriving] -> InstDecl

-- | A single derived instance, which may have arguments since it may be a
--   MPTC.
type Deriving = (QName, [Type])

-- | A flag stating whether a declaration is a data or newtype declaration.
data DataOrNew
DataType :: DataOrNew
NewType :: DataOrNew

-- | Declaration of an ordinary data constructor.
data ConDecl

-- | ordinary data constructor
ConDecl :: Name -> [Type] -> ConDecl

-- | infix data constructor
InfixConDecl :: Type -> Name -> Type -> ConDecl

-- | record constructor
RecDecl :: Name -> [([Name], Type)] -> ConDecl

-- | A single constructor declaration within a data type declaration, which
--   may have an existential quantification binding.
data QualConDecl
QualConDecl :: SrcLoc -> [TyVarBind] -> Context -> ConDecl -> QualConDecl

-- | A single constructor declaration in a GADT data type declaration.
data GadtDecl
GadtDecl :: SrcLoc -> Name -> [([Name], Type)] -> Type -> GadtDecl

-- | The type of a constructor argument or field, optionally including a
--   strictness annotation.
data BangType

-- | strict component, marked with "<tt>!</tt>"
BangedTy :: BangType

-- | unboxed component, marked with an UNPACK pragma
UnpackedTy :: BangType

-- | Clauses of a function binding.
data Match
Match :: SrcLoc -> Name -> [Pat] -> (Maybe Type) -> Rhs -> Binds -> Match

-- | The right hand side of a function binding, pattern binding, or a case
--   alternative.
data Rhs

-- | unguarded right hand side (<i>exp</i>)
UnGuardedRhs :: Exp -> Rhs

-- | guarded right hand side (<i>gdrhs</i>)
GuardedRhss :: [GuardedRhs] -> Rhs

-- | A guarded right hand side <tt>|</tt> <i>stmts</i> <tt>=</tt>
--   <i>exp</i>, or <tt>|</tt> <i>stmts</i> <tt>-&gt;</tt> <i>exp</i> for
--   case alternatives. The guard is a series of statements when using
--   pattern guards, otherwise it will be a single qualifier expression.
data GuardedRhs
GuardedRhs :: SrcLoc -> [Stmt] -> Exp -> GuardedRhs

-- | A context is a set of assertions
type Context = [Asst]

-- | A functional dependency, given on the form l1 l2 ... ln -&gt; r2 r3 ..
--   rn
data FunDep
FunDep :: [Name] -> [Name] -> FunDep

-- | Class assertions. In Haskell 98, the argument would be a <i>tyvar</i>,
--   but this definition allows multiple parameters, and allows them to be
--   <i>type</i>s. Also extended with support for implicit parameters and
--   equality constraints.
data Asst

-- | ordinary class assertion
ClassA :: QName -> [Type] -> Asst

-- | constraint kind assertion, <tt>Dict :: cxt =&gt; Dict cxt</tt>
VarA :: Name -> Asst

-- | class assertion where the class name is given infix
InfixA :: Type -> QName -> Type -> Asst

-- | implicit parameter assertion
IParam :: IPName -> Type -> Asst

-- | type equality constraint
EqualP :: Type -> Type -> Asst

-- | parenthesised class assertion
ParenA :: Asst -> Asst

-- | A type qualified with a context. An unqualified type has an empty
--   context.
data Type

-- | qualified type
TyForall :: (Maybe [TyVarBind]) -> Context -> Type -> Type

-- | function type
TyFun :: Type -> Type -> Type

-- | tuple type, possibly boxed
TyTuple :: Boxed -> [Type] -> Type

-- | list syntax, e.g. [a], as opposed to [] a
TyList :: Type -> Type

-- | parallel array syntax, e.g. [:a:]
TyParArray :: Type -> Type

-- | application of a type constructor
TyApp :: Type -> Type -> Type

-- | type variable
TyVar :: Name -> Type

-- | named type or type constructor
TyCon :: QName -> Type

-- | type surrounded by parentheses
TyParen :: Type -> Type

-- | infix type constructor
TyInfix :: Type -> QName -> Type -> Type

-- | type with explicit kind signature
TyKind :: Type -> Kind -> Type

-- | promoted data type (-XDataKinds)
TyPromoted :: Promoted -> Type

-- | type equality predicate enabled by ConstraintKinds
TyEquals :: Type -> Type -> Type

-- | template haskell splice type
TySplice :: Splice -> Type

-- | Strict type marked with "<tt>!</tt>" or type marked with UNPACK
--   pragma.
TyBang :: BangType -> Type -> Type

-- | Flag denoting whether a tuple is boxed or unboxed.
data Boxed
Boxed :: Boxed
Unboxed :: Boxed

-- | An explicit kind annotation.
data Kind

-- | <tt>*</tt>, the kind of types
KindStar :: Kind

-- | <tt>!</tt>, the kind of unboxed types
KindBang :: Kind

-- | <tt>-&gt;</tt>, the kind of a type constructor
KindFn :: Kind -> Kind -> Kind

-- | a kind surrounded by parentheses
KindParen :: Kind -> Kind

-- | a kind variable (as of yet unsupported by compilers)
KindVar :: QName -> Kind

-- | <pre>
--   k1 k2
--   </pre>
KindApp :: Kind -> Kind -> Kind

-- | <tt>'(k1,k2,k3)</tt>, a promoted tuple
KindTuple :: [Kind] -> Kind

-- | <tt>'[k1,k2,k3]</tt>, a promoted list literal
KindList :: [Kind] -> Kind

-- | A type variable declaration, optionally with an explicit kind
--   annotation.
data TyVarBind

-- | variable binding with kind annotation
KindedVar :: Name -> Kind -> TyVarBind

-- | ordinary variable binding
UnkindedVar :: Name -> TyVarBind
data Promoted
PromotedInteger :: Integer -> Promoted
PromotedString :: String -> Promoted
PromotedCon :: Bool -> QName -> Promoted
PromotedList :: Bool -> [Promoted] -> Promoted
PromotedTuple :: [Promoted] -> Promoted
PromotedUnit :: Promoted

-- | A type equation of the form <tt>rhs = lhs</tt> used in closed type
--   families.
data TypeEqn
TypeEqn :: Type -> Type -> TypeEqn

-- | Haskell expressions.
data Exp

-- | variable
Var :: QName -> Exp

-- | implicit parameter variable
IPVar :: IPName -> Exp

-- | data constructor
Con :: QName -> Exp

-- | literal constant
Lit :: Literal -> Exp

-- | infix application
InfixApp :: Exp -> QOp -> Exp -> Exp

-- | ordinary application
App :: Exp -> Exp -> Exp

-- | negation expression <tt>-<i>exp</i></tt> (unary minus)
NegApp :: Exp -> Exp

-- | lambda expression
Lambda :: SrcLoc -> [Pat] -> Exp -> Exp

-- | local declarations with <tt>let</tt> ... <tt>in</tt> ...
Let :: Binds -> Exp -> Exp

-- | <tt>if</tt> <i>exp</i> <tt>then</tt> <i>exp</i> <tt>else</tt>
--   <i>exp</i>
If :: Exp -> Exp -> Exp -> Exp

-- | <tt>if</tt> <tt>|</tt> <i>exp</i> <tt>-&gt;</tt> <i>exp</i> ...
MultiIf :: [GuardedRhs] -> Exp

-- | <tt>case</tt> <i>exp</i> <tt>of</tt> <i>alts</i>
Case :: Exp -> [Alt] -> Exp

-- | <tt>do</tt>-expression: the last statement in the list should be an
--   expression.
Do :: [Stmt] -> Exp

-- | <tt>mdo</tt>-expression
MDo :: [Stmt] -> Exp

-- | tuple expression
Tuple :: Boxed -> [Exp] -> Exp

-- | tuple section expression, e.g. <tt>(,,3)</tt>
TupleSection :: Boxed -> [Maybe Exp] -> Exp

-- | list expression
List :: [Exp] -> Exp

-- | parallel array expression
ParArray :: [Exp] -> Exp

-- | parenthesised expression
Paren :: Exp -> Exp

-- | left section <tt>(</tt><i>exp</i> <i>qop</i><tt>)</tt>
LeftSection :: Exp -> QOp -> Exp

-- | right section <tt>(</tt><i>qop</i> <i>exp</i><tt>)</tt>
RightSection :: QOp -> Exp -> Exp

-- | record construction expression
RecConstr :: QName -> [FieldUpdate] -> Exp

-- | record update expression
RecUpdate :: Exp -> [FieldUpdate] -> Exp

-- | unbounded arithmetic sequence, incrementing by 1: <tt>[from ..]</tt>
EnumFrom :: Exp -> Exp

-- | bounded arithmetic sequence, incrementing by 1 <tt>[from .. to]</tt>
EnumFromTo :: Exp -> Exp -> Exp

-- | unbounded arithmetic sequence, with first two elements given
--   <tt>[from, then ..]</tt>
EnumFromThen :: Exp -> Exp -> Exp

-- | bounded arithmetic sequence, with first two elements given <tt>[from,
--   then .. to]</tt>
EnumFromThenTo :: Exp -> Exp -> Exp -> Exp

-- | bounded arithmetic sequence, incrementing by 1 <tt>[from .. to]</tt>
ParArrayFromTo :: Exp -> Exp -> Exp

-- | bounded arithmetic sequence, with first two elements given <tt>[from,
--   then .. to]</tt>
ParArrayFromThenTo :: Exp -> Exp -> Exp -> Exp

-- | ordinary list comprehension
ListComp :: Exp -> [QualStmt] -> Exp

-- | parallel list comprehension
ParComp :: Exp -> [[QualStmt]] -> Exp

-- | parallel array comprehension
ParArrayComp :: Exp -> [[QualStmt]] -> Exp

-- | expression with explicit type signature
ExpTypeSig :: SrcLoc -> Exp -> Type -> Exp

-- | <tt>'x</tt> for template haskell reifying of expressions
VarQuote :: QName -> Exp

-- | <tt>''T</tt> for template haskell reifying of types
TypQuote :: QName -> Exp

-- | template haskell bracket expression
BracketExp :: Bracket -> Exp

-- | template haskell splice expression
SpliceExp :: Splice -> Exp

-- | quasi-quotaion: <tt>[$<i>name</i>| <i>string</i> |]</tt>
QuasiQuote :: String -> String -> Exp

-- | xml element, with attributes and children
XTag :: SrcLoc -> XName -> [XAttr] -> (Maybe Exp) -> [Exp] -> Exp

-- | empty xml element, with attributes
XETag :: SrcLoc -> XName -> [XAttr] -> (Maybe Exp) -> Exp

-- | PCDATA child element
XPcdata :: String -> Exp

-- | escaped haskell expression inside xml
XExpTag :: Exp -> Exp

-- | children of an xml element
XChildTag :: SrcLoc -> [Exp] -> Exp

-- | CORE pragma
CorePragma :: String -> Exp -> Exp

-- | SCC pragma
SCCPragma :: String -> Exp -> Exp

-- | GENERATED pragma
GenPragma :: String -> (Int, Int) -> (Int, Int) -> Exp -> Exp

-- | arrows proc: <tt>proc</tt> <i>pat</i> <tt>-&gt;</tt> <i>exp</i>
Proc :: SrcLoc -> Pat -> Exp -> Exp

-- | arrow application (from left): <i>exp</i> <tt>-&lt;</tt> <i>exp</i>
LeftArrApp :: Exp -> Exp -> Exp

-- | arrow application (from right): <i>exp</i> <tt>&gt;-</tt> <i>exp</i>
RightArrApp :: Exp -> Exp -> Exp

-- | higher-order arrow application (from left): <i>exp</i>
--   <tt>-&lt;&lt;</tt> <i>exp</i>
LeftArrHighApp :: Exp -> Exp -> Exp

-- | higher-order arrow application (from right): <i>exp</i>
--   <tt>&gt;&gt;-</tt> <i>exp</i>
RightArrHighApp :: Exp -> Exp -> Exp

-- | <tt>case</tt> <i>alts</i>
LCase :: [Alt] -> Exp

-- | A statement, representing both a <i>stmt</i> in a
--   <tt>do</tt>-expression, an ordinary <i>qual</i> in a list
--   comprehension, as well as a <i>stmt</i> in a pattern guard.
data Stmt

-- | a generator: <i>pat</i> <tt>&lt;-</tt> <i>exp</i>
Generator :: SrcLoc -> Pat -> Exp -> Stmt

-- | an <i>exp</i> by itself: in a <tt>do</tt>-expression, an action whose
--   result is discarded; in a list comprehension and pattern guard, a
--   guard expression
Qualifier :: Exp -> Stmt

-- | local bindings
LetStmt :: Binds -> Stmt

-- | a recursive binding group for arrows
RecStmt :: [Stmt] -> Stmt

-- | A general <i>transqual</i> in a list comprehension, which could
--   potentially be a transform of the kind enabled by TransformListComp.
data QualStmt

-- | an ordinary statement
QualStmt :: Stmt -> QualStmt

-- | <tt>then</tt> <i>exp</i>
ThenTrans :: Exp -> QualStmt

-- | <tt>then</tt> <i>exp</i> <tt>by</tt> <i>exp</i>
ThenBy :: Exp -> Exp -> QualStmt

-- | <tt>then</tt> <tt>group</tt> <tt>by</tt> <i>exp</i>
GroupBy :: Exp -> QualStmt

-- | <tt>then</tt> <tt>group</tt> <tt>using</tt> <i>exp</i>
GroupUsing :: Exp -> QualStmt

-- | <tt>then</tt> <tt>group</tt> <tt>by</tt> <i>exp</i> <tt>using</tt>
--   <i>exp</i>
GroupByUsing :: Exp -> Exp -> QualStmt

-- | An <i>fbind</i> in a labeled construction or update expression.
data FieldUpdate

-- | ordinary label-expresion pair
FieldUpdate :: QName -> Exp -> FieldUpdate

-- | record field pun
FieldPun :: QName -> FieldUpdate

-- | record field wildcard
FieldWildcard :: FieldUpdate

-- | An <i>alt</i> alternative in a <tt>case</tt> expression.
data Alt
Alt :: SrcLoc -> Pat -> Rhs -> Binds -> Alt

-- | An xml attribute, which is a name-expression pair.
data XAttr
XAttr :: XName -> Exp -> XAttr

-- | A pattern, to be matched against a value.
data Pat

-- | variable
PVar :: Name -> Pat

-- | literal constant
PLit :: Sign -> Literal -> Pat

-- | n+k pattern
PNPlusK :: Name -> Integer -> Pat

-- | pattern with an infix data constructor
PInfixApp :: Pat -> QName -> Pat -> Pat

-- | data constructor and argument patterns
PApp :: QName -> [Pat] -> Pat

-- | tuple pattern
PTuple :: Boxed -> [Pat] -> Pat

-- | list pattern
PList :: [Pat] -> Pat

-- | parenthesized pattern
PParen :: Pat -> Pat

-- | labelled pattern, record style
PRec :: QName -> [PatField] -> Pat

-- | <tt>@</tt>-pattern
PAsPat :: Name -> Pat -> Pat

-- | wildcard pattern: <tt>_</tt>
PWildCard :: Pat

-- | irrefutable pattern: <tt>~<i>pat</i></tt>
PIrrPat :: Pat -> Pat

-- | pattern with type signature
PatTypeSig :: SrcLoc -> Pat -> Type -> Pat

-- | view patterns of the form <tt>(<i>exp</i> -&gt; <i>pat</i>)</tt>
PViewPat :: Exp -> Pat -> Pat

-- | regular list pattern
PRPat :: [RPat] -> Pat

-- | XML element pattern
PXTag :: SrcLoc -> XName -> [PXAttr] -> (Maybe Pat) -> [Pat] -> Pat

-- | XML singleton element pattern
PXETag :: SrcLoc -> XName -> [PXAttr] -> (Maybe Pat) -> Pat

-- | XML PCDATA pattern
PXPcdata :: String -> Pat

-- | XML embedded pattern
PXPatTag :: Pat -> Pat

-- | XML regular list pattern
PXRPats :: [RPat] -> Pat

-- | quasi quote patter: <tt>[$<i>name</i>| <i>string</i> |]</tt>
PQuasiQuote :: String -> String -> Pat

-- | strict (bang) pattern: <tt>f !x = ...</tt>
PBangPat :: Pat -> Pat

-- | An <i>fpat</i> in a labeled record pattern.
data PatField

-- | ordinary label-pattern pair
PFieldPat :: QName -> Pat -> PatField

-- | record field pun
PFieldPun :: QName -> PatField

-- | record field wildcard
PFieldWildcard :: PatField

-- | An XML attribute in a pattern.
data PXAttr
PXAttr :: XName -> Pat -> PXAttr

-- | An entity in a regular pattern.
data RPat

-- | operator pattern, e.g. pat*
RPOp :: RPat -> RPatOp -> RPat

-- | choice pattern, e.g. (1 | 2)
RPEither :: RPat -> RPat -> RPat

-- | sequence pattern, e.g. (| 1, 2, 3 |)
RPSeq :: [RPat] -> RPat

-- | guarded pattern, e.g. (| p | p &lt; 3 |)
RPGuard :: Pat -> [Stmt] -> RPat

-- | non-linear variable binding, e.g. (foo@:(1 | 2))*
RPCAs :: Name -> RPat -> RPat

-- | linear variable binding, e.g. foo@(1 | 2)
RPAs :: Name -> RPat -> RPat

-- | parenthesised pattern, e.g. (2*)
RPParen :: RPat -> RPat

-- | an ordinary pattern
RPPat :: Pat -> RPat

-- | A regular pattern operator.
data RPatOp

-- | <tt>*</tt> = 0 or more
RPStar :: RPatOp

-- | <tt>*!</tt> = 0 or more, greedy
RPStarG :: RPatOp

-- | <tt>+</tt> = 1 or more
RPPlus :: RPatOp

-- | <tt>+!</tt> = 1 or more, greedy
RPPlusG :: RPatOp

-- | <tt>?</tt> = 0 or 1
RPOpt :: RPatOp

-- | <tt>?!</tt> = 0 or 1, greedy
RPOptG :: RPatOp

-- | <i>literal</i> Values of this type hold the abstract value of the
--   literal, not the precise string representation used. For example,
--   <tt>10</tt>, <tt>0o12</tt> and <tt>0xa</tt> have the same
--   representation.
data Literal

-- | character literal
Char :: Char -> Literal

-- | string literal
String :: String -> Literal

-- | integer literal
Int :: Integer -> Literal

-- | floating point literal
Frac :: Rational -> Literal

-- | unboxed integer literal
PrimInt :: Integer -> Literal

-- | unboxed word literal
PrimWord :: Integer -> Literal

-- | unboxed float literal
PrimFloat :: Rational -> Literal

-- | unboxed double literal
PrimDouble :: Rational -> Literal

-- | unboxed character literal
PrimChar :: Char -> Literal

-- | unboxed string literal
PrimString :: String -> Literal

-- | An indication whether a literal pattern has been negated or not.
data Sign
Signless :: Sign
Negative :: Sign

-- | The name of a Haskell module.
newtype ModuleName
ModuleName :: String -> ModuleName

-- | This type is used to represent qualified variables, and also qualified
--   constructors.
data QName

-- | name qualified with a module name
Qual :: ModuleName -> Name -> QName

-- | unqualified local name
UnQual :: Name -> QName

-- | built-in constructor with special syntax
Special :: SpecialCon -> QName

-- | This type is used to represent variables, and also constructors.
data Name

-- | <i>varid</i> or <i>conid</i>.
Ident :: String -> Name

-- | <i>varsym</i> or <i>consym</i>
Symbol :: String -> Name

-- | Possibly qualified infix operators (<i>qop</i>), appearing in
--   expressions.
data QOp

-- | variable operator (<i>qvarop</i>)
QVarOp :: QName -> QOp

-- | constructor operator (<i>qconop</i>)
QConOp :: QName -> QOp

-- | Operators appearing in <tt>infix</tt> declarations are never
--   qualified.
data Op

-- | variable operator (<i>varop</i>)
VarOp :: Name -> Op

-- | constructor operator (<i>conop</i>)
ConOp :: Name -> Op

-- | Constructors with special syntax. These names are never qualified, and
--   always refer to builtin type or data constructors.
data SpecialCon

-- | unit type and data constructor <tt>()</tt>
UnitCon :: SpecialCon

-- | list type constructor <tt>[]</tt>
ListCon :: SpecialCon

-- | function type constructor <tt>-&gt;</tt>
FunCon :: SpecialCon

-- | <i>n</i>-ary tuple type and data constructors <tt>(,)</tt> etc,
--   possibly boxed <tt>(#,#)</tt>
TupleCon :: Boxed -> Int -> SpecialCon

-- | list data constructor <tt>(:)</tt>
Cons :: SpecialCon

-- | unboxed singleton tuple constructor <tt>(# #)</tt>
UnboxedSingleCon :: SpecialCon

-- | A name (<i>cname</i>) of a component of a class or data type in an
--   <tt>import</tt> or export specification.
data CName

-- | name of a method or field
VarName :: Name -> CName

-- | name of a data constructor
ConName :: Name -> CName

-- | An implicit parameter name.
data IPName

-- | ?<i>ident</i>, non-linear implicit parameter
IPDup :: String -> IPName

-- | %<i>ident</i>, linear implicit parameter
IPLin :: String -> IPName

-- | The name of an xml element or attribute, possibly qualified with a
--   namespace.
data XName
XName :: String -> XName
XDomName :: String -> String -> XName

-- | A template haskell bracket expression.
data Bracket

-- | expression bracket: <tt>[| ... |]</tt>
ExpBracket :: Exp -> Bracket

-- | pattern bracket: <tt>[p| ... |]</tt>
PatBracket :: Pat -> Bracket

-- | type bracket: <tt>[t| ... |]</tt>
TypeBracket :: Type -> Bracket

-- | declaration bracket: <tt>[d| ... |]</tt>
DeclBracket :: [Decl] -> Bracket

-- | A template haskell splice expression
data Splice

-- | variable splice: <tt>$var</tt>
IdSplice :: String -> Splice

-- | parenthesised expression splice: <tt>$(<i>exp</i>)</tt>
ParenSplice :: Exp -> Splice

-- | The safety of a foreign function call.
data Safety

-- | unsafe
PlayRisky :: Safety

-- | safe (<a>False</a>) or threadsafe (<a>True</a>)
PlaySafe :: Bool -> Safety

-- | interruptible
PlayInterruptible :: Safety

-- | The calling convention of a foreign function call.
data CallConv
StdCall :: CallConv
CCall :: CallConv
CPlusPlus :: CallConv
DotNet :: CallConv
Jvm :: CallConv
Js :: CallConv
CApi :: CallConv

-- | A top level options pragma, preceding the module header.
data ModulePragma

-- | LANGUAGE pragma
LanguagePragma :: SrcLoc -> [Name] -> ModulePragma

-- | OPTIONS pragma, possibly qualified with a tool, e.g. OPTIONS_GHC
OptionsPragma :: SrcLoc -> (Maybe Tool) -> String -> ModulePragma

-- | ANN pragma with module scope
AnnModulePragma :: SrcLoc -> Annotation -> ModulePragma

-- | Recognised tools for OPTIONS pragmas.
data Tool
GHC :: Tool
HUGS :: Tool
NHC98 :: Tool
YHC :: Tool
HADDOCK :: Tool
UnknownTool :: String -> Tool

-- | Recognised overlaps for overlap pragmas.
data Overlap

-- | NO_OVERLAP pragma
NoOverlap :: Overlap

-- | OVERLAP pragma
Overlap :: Overlap

-- | INCOHERENT pragma
Incoherent :: Overlap

-- | The body of a RULES pragma.
data Rule
Rule :: String -> Activation -> (Maybe [RuleVar]) -> Exp -> Exp -> Rule

-- | Variables used in a RULES pragma, optionally annotated with types
data RuleVar
RuleVar :: Name -> RuleVar
TypedRuleVar :: Name -> Type -> RuleVar

-- | Activation clause of a RULES pragma.
data Activation
AlwaysActive :: Activation
ActiveFrom :: Int -> Activation
ActiveUntil :: Int -> Activation

-- | An annotation through an ANN pragma.
data Annotation

-- | An annotation for a declared name.
Ann :: Name -> Exp -> Annotation

-- | An annotation for a declared type.
TypeAnn :: Name -> Exp -> Annotation

-- | An annotation for the defining module.
ModuleAnn :: Exp -> Annotation

-- | A boolean formula for MINIMAL pragmas.
data BooleanFormula

-- | A variable.
VarFormula :: Name -> BooleanFormula

-- | And boolean formulas.
AndFormula :: [BooleanFormula] -> BooleanFormula

-- | Or boolean formulas.
OrFormula :: [BooleanFormula] -> BooleanFormula

-- | Parenthesized boolean formulas.
ParenFormula :: BooleanFormula -> BooleanFormula
prelude_mod :: ModuleName
main_mod :: ModuleName
main_name :: Name
unit_con_name :: QName
tuple_con_name :: Boxed -> Int -> QName
list_cons_name :: QName
unboxed_singleton_con_name :: QName
unit_con :: Exp
tuple_con :: Boxed -> Int -> Exp
unboxed_singleton_con :: Exp
as_name :: Name
qualified_name :: Name
hiding_name :: Name
minus_name :: Name
bang_name :: Name
dot_name :: Name
star_name :: Name
export_name :: Name
safe_name :: Name
unsafe_name :: Name
interruptible_name :: Name
threadsafe_name :: Name
stdcall_name :: Name
ccall_name :: Name
cplusplus_name :: Name
dotnet_name :: Name
jvm_name :: Name
js_name :: Name
capi_name :: Name
forall_name :: Name
family_name :: Name
unit_tycon_name :: QName
fun_tycon_name :: QName
list_tycon_name :: QName
tuple_tycon_name :: Boxed -> Int -> QName
unboxed_singleton_tycon_name :: QName
unit_tycon :: Type
fun_tycon :: Type
list_tycon :: Type
tuple_tycon :: Boxed -> Int -> Type
unboxed_singleton_tycon :: Type

-- | A single position in the source.
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
srcFilename :: SrcLoc -> String
srcLine :: SrcLoc -> Int
srcColumn :: SrcLoc -> Int
instance Typeable ModuleName
instance Typeable SpecialCon
instance Typeable Name
instance Typeable QName
instance Typeable IPName
instance Typeable QOp
instance Typeable Op
instance Typeable CName
instance Typeable Namespace
instance Typeable ExportSpec
instance Typeable ImportSpec
instance Typeable ImportDecl
instance Typeable Assoc
instance Typeable BooleanFormula
instance Typeable DataOrNew
instance Typeable BangType
instance Typeable Promoted
instance Typeable Kind
instance Typeable TyVarBind
instance Typeable FunDep
instance Typeable Literal
instance Typeable Sign
instance Typeable XName
instance Typeable Safety
instance Typeable CallConv
instance Typeable Overlap
instance Typeable Activation
instance Typeable WarningText
instance Typeable RPatOp
instance Typeable Alt
instance Typeable Pat
instance Typeable PatField
instance Typeable RPat
instance Typeable Stmt
instance Typeable Exp
instance Typeable FieldUpdate
instance Typeable QualStmt
instance Typeable Splice
instance Typeable Bracket
instance Typeable Type
instance Typeable Asst
instance Typeable Decl
instance Typeable Rule
instance Typeable RuleVar
instance Typeable Rhs
instance Typeable GuardedRhs
instance Typeable InstDecl
instance Typeable GadtDecl
instance Typeable QualConDecl
instance Typeable ConDecl
instance Typeable ClassDecl
instance Typeable Match
instance Typeable Binds
instance Typeable IPBind
instance Typeable Annotation
instance Typeable TypeEqn
instance Typeable XAttr
instance Typeable PXAttr
instance Typeable ModulePragma
instance Typeable Module
instance Eq ModuleName
instance Ord ModuleName
instance Show ModuleName
instance Data ModuleName
instance Generic ModuleName
instance Eq SpecialCon
instance Ord SpecialCon
instance Show SpecialCon
instance Data SpecialCon
instance Generic SpecialCon
instance Eq Name
instance Ord Name
instance Show Name
instance Data Name
instance Generic Name
instance Eq QName
instance Ord QName
instance Show QName
instance Data QName
instance Generic QName
instance Eq IPName
instance Ord IPName
instance Show IPName
instance Data IPName
instance Generic IPName
instance Eq QOp
instance Ord QOp
instance Show QOp
instance Data QOp
instance Generic QOp
instance Eq Op
instance Ord Op
instance Show Op
instance Data Op
instance Generic Op
instance Eq CName
instance Ord CName
instance Show CName
instance Data CName
instance Generic CName
instance Eq Namespace
instance Ord Namespace
instance Show Namespace
instance Data Namespace
instance Generic Namespace
instance Eq ExportSpec
instance Ord ExportSpec
instance Show ExportSpec
instance Data ExportSpec
instance Generic ExportSpec
instance Eq ImportSpec
instance Ord ImportSpec
instance Show ImportSpec
instance Data ImportSpec
instance Generic ImportSpec
instance Eq ImportDecl
instance Ord ImportDecl
instance Show ImportDecl
instance Data ImportDecl
instance Generic ImportDecl
instance Eq Assoc
instance Ord Assoc
instance Show Assoc
instance Data Assoc
instance Generic Assoc
instance Eq BooleanFormula
instance Ord BooleanFormula
instance Show BooleanFormula
instance Data BooleanFormula
instance Generic BooleanFormula
instance Eq DataOrNew
instance Ord DataOrNew
instance Show DataOrNew
instance Data DataOrNew
instance Generic DataOrNew
instance Eq BangType
instance Ord BangType
instance Show BangType
instance Data BangType
instance Generic BangType
instance Eq Promoted
instance Ord Promoted
instance Show Promoted
instance Data Promoted
instance Generic Promoted
instance Eq Kind
instance Ord Kind
instance Show Kind
instance Data Kind
instance Generic Kind
instance Eq TyVarBind
instance Ord TyVarBind
instance Show TyVarBind
instance Data TyVarBind
instance Generic TyVarBind
instance Eq FunDep
instance Ord FunDep
instance Show FunDep
instance Data FunDep
instance Generic FunDep
instance Eq Literal
instance Ord Literal
instance Show Literal
instance Data Literal
instance Generic Literal
instance Eq Sign
instance Ord Sign
instance Show Sign
instance Data Sign
instance Generic Sign
instance Eq XName
instance Ord XName
instance Show XName
instance Data XName
instance Generic XName
instance Eq Safety
instance Ord Safety
instance Show Safety
instance Data Safety
instance Generic Safety
instance Eq CallConv
instance Ord CallConv
instance Show CallConv
instance Data CallConv
instance Generic CallConv
instance Eq Overlap
instance Ord Overlap
instance Show Overlap
instance Data Overlap
instance Generic Overlap
instance Eq Activation
instance Ord Activation
instance Show Activation
instance Data Activation
instance Generic Activation
instance Eq WarningText
instance Ord WarningText
instance Show WarningText
instance Data WarningText
instance Generic WarningText
instance Eq RPatOp
instance Ord RPatOp
instance Show RPatOp
instance Data RPatOp
instance Generic RPatOp
instance Eq Alt
instance Ord Alt
instance Show Alt
instance Data Alt
instance Generic Alt
instance Eq Pat
instance Ord Pat
instance Show Pat
instance Data Pat
instance Generic Pat
instance Eq PatField
instance Ord PatField
instance Show PatField
instance Data PatField
instance Generic PatField
instance Eq RPat
instance Ord RPat
instance Show RPat
instance Data RPat
instance Generic RPat
instance Eq Stmt
instance Ord Stmt
instance Show Stmt
instance Data Stmt
instance Generic Stmt
instance Eq Exp
instance Ord Exp
instance Show Exp
instance Data Exp
instance Generic Exp
instance Eq FieldUpdate
instance Ord FieldUpdate
instance Show FieldUpdate
instance Data FieldUpdate
instance Generic FieldUpdate
instance Eq QualStmt
instance Ord QualStmt
instance Show QualStmt
instance Data QualStmt
instance Generic QualStmt
instance Eq Splice
instance Ord Splice
instance Show Splice
instance Data Splice
instance Generic Splice
instance Eq Bracket
instance Ord Bracket
instance Show Bracket
instance Data Bracket
instance Generic Bracket
instance Eq Type
instance Ord Type
instance Show Type
instance Data Type
instance Eq Asst
instance Ord Asst
instance Show Asst
instance Data Asst
instance Generic Asst
instance Eq Decl
instance Ord Decl
instance Show Decl
instance Data Decl
instance Generic Decl
instance Eq Rule
instance Ord Rule
instance Show Rule
instance Data Rule
instance Generic Rule
instance Eq RuleVar
instance Ord RuleVar
instance Show RuleVar
instance Data RuleVar
instance Generic RuleVar
instance Eq Rhs
instance Ord Rhs
instance Show Rhs
instance Data Rhs
instance Generic Rhs
instance Eq GuardedRhs
instance Ord GuardedRhs
instance Show GuardedRhs
instance Data GuardedRhs
instance Generic GuardedRhs
instance Eq InstDecl
instance Ord InstDecl
instance Show InstDecl
instance Data InstDecl
instance Generic InstDecl
instance Eq GadtDecl
instance Ord GadtDecl
instance Show GadtDecl
instance Data GadtDecl
instance Generic GadtDecl
instance Eq QualConDecl
instance Ord QualConDecl
instance Show QualConDecl
instance Data QualConDecl
instance Generic QualConDecl
instance Eq ConDecl
instance Ord ConDecl
instance Show ConDecl
instance Data ConDecl
instance Generic ConDecl
instance Eq ClassDecl
instance Ord ClassDecl
instance Show ClassDecl
instance Data ClassDecl
instance Generic ClassDecl
instance Eq Match
instance Ord Match
instance Show Match
instance Data Match
instance Generic Match
instance Eq Binds
instance Ord Binds
instance Show Binds
instance Data Binds
instance Generic Binds
instance Eq IPBind
instance Ord IPBind
instance Show IPBind
instance Data IPBind
instance Generic IPBind
instance Eq Annotation
instance Ord Annotation
instance Show Annotation
instance Data Annotation
instance Generic Annotation
instance Eq TypeEqn
instance Ord TypeEqn
instance Show TypeEqn
instance Data TypeEqn
instance Generic TypeEqn
instance Eq XAttr
instance Ord XAttr
instance Show XAttr
instance Data XAttr
instance Generic XAttr
instance Eq PXAttr
instance Ord PXAttr
instance Show PXAttr
instance Data PXAttr
instance Generic PXAttr
instance Eq ModulePragma
instance Ord ModulePragma
instance Show ModulePragma
instance Data ModulePragma
instance Generic ModulePragma
instance Eq Module
instance Ord Module
instance Show Module
instance Data Module
instance Generic Module
instance Datatype D1ModuleName
instance Constructor C1_0ModuleName
instance Datatype D1SpecialCon
instance Constructor C1_0SpecialCon
instance Constructor C1_1SpecialCon
instance Constructor C1_2SpecialCon
instance Constructor C1_3SpecialCon
instance Constructor C1_4SpecialCon
instance Constructor C1_5SpecialCon
instance Datatype D1Name
instance Constructor C1_0Name
instance Constructor C1_1Name
instance Datatype D1QName
instance Constructor C1_0QName
instance Constructor C1_1QName
instance Constructor C1_2QName
instance Datatype D1IPName
instance Constructor C1_0IPName
instance Constructor C1_1IPName
instance Datatype D1QOp
instance Constructor C1_0QOp
instance Constructor C1_1QOp
instance Datatype D1Op
instance Constructor C1_0Op
instance Constructor C1_1Op
instance Datatype D1CName
instance Constructor C1_0CName
instance Constructor C1_1CName
instance Datatype D1Namespace
instance Constructor C1_0Namespace
instance Constructor C1_1Namespace
instance Datatype D1ExportSpec
instance Constructor C1_0ExportSpec
instance Constructor C1_1ExportSpec
instance Constructor C1_2ExportSpec
instance Constructor C1_3ExportSpec
instance Constructor C1_4ExportSpec
instance Datatype D1ImportSpec
instance Constructor C1_0ImportSpec
instance Constructor C1_1ImportSpec
instance Constructor C1_2ImportSpec
instance Constructor C1_3ImportSpec
instance Datatype D1ImportDecl
instance Constructor C1_0ImportDecl
instance Selector S1_0_0ImportDecl
instance Selector S1_0_1ImportDecl
instance Selector S1_0_2ImportDecl
instance Selector S1_0_3ImportDecl
instance Selector S1_0_4ImportDecl
instance Selector S1_0_5ImportDecl
instance Selector S1_0_6ImportDecl
instance Selector S1_0_7ImportDecl
instance Datatype D1Assoc
instance Constructor C1_0Assoc
instance Constructor C1_1Assoc
instance Constructor C1_2Assoc
instance Datatype D1BooleanFormula
instance Constructor C1_0BooleanFormula
instance Constructor C1_1BooleanFormula
instance Constructor C1_2BooleanFormula
instance Constructor C1_3BooleanFormula
instance Datatype D1DataOrNew
instance Constructor C1_0DataOrNew
instance Constructor C1_1DataOrNew
instance Datatype D1BangType
instance Constructor C1_0BangType
instance Constructor C1_1BangType
instance Datatype D1Promoted
instance Constructor C1_0Promoted
instance Constructor C1_1Promoted
instance Constructor C1_2Promoted
instance Constructor C1_3Promoted
instance Constructor C1_4Promoted
instance Constructor C1_5Promoted
instance Datatype D1Kind
instance Constructor C1_0Kind
instance Constructor C1_1Kind
instance Constructor C1_2Kind
instance Constructor C1_3Kind
instance Constructor C1_4Kind
instance Constructor C1_5Kind
instance Constructor C1_6Kind
instance Constructor C1_7Kind
instance Datatype D1TyVarBind
instance Constructor C1_0TyVarBind
instance Constructor C1_1TyVarBind
instance Datatype D1FunDep
instance Constructor C1_0FunDep
instance Datatype D1Literal
instance Constructor C1_0Literal
instance Constructor C1_1Literal
instance Constructor C1_2Literal
instance Constructor C1_3Literal
instance Constructor C1_4Literal
instance Constructor C1_5Literal
instance Constructor C1_6Literal
instance Constructor C1_7Literal
instance Constructor C1_8Literal
instance Constructor C1_9Literal
instance Datatype D1Sign
instance Constructor C1_0Sign
instance Constructor C1_1Sign
instance Datatype D1XName
instance Constructor C1_0XName
instance Constructor C1_1XName
instance Datatype D1Safety
instance Constructor C1_0Safety
instance Constructor C1_1Safety
instance Constructor C1_2Safety
instance Datatype D1CallConv
instance Constructor C1_0CallConv
instance Constructor C1_1CallConv
instance Constructor C1_2CallConv
instance Constructor C1_3CallConv
instance Constructor C1_4CallConv
instance Constructor C1_5CallConv
instance Constructor C1_6CallConv
instance Datatype D1Overlap
instance Constructor C1_0Overlap
instance Constructor C1_1Overlap
instance Constructor C1_2Overlap
instance Datatype D1Activation
instance Constructor C1_0Activation
instance Constructor C1_1Activation
instance Constructor C1_2Activation
instance Datatype D1WarningText
instance Constructor C1_0WarningText
instance Constructor C1_1WarningText
instance Datatype D1RPatOp
instance Constructor C1_0RPatOp
instance Constructor C1_1RPatOp
instance Constructor C1_2RPatOp
instance Constructor C1_3RPatOp
instance Constructor C1_4RPatOp
instance Constructor C1_5RPatOp
instance Datatype D1Alt
instance Constructor C1_0Alt
instance Datatype D1Pat
instance Constructor C1_0Pat
instance Constructor C1_1Pat
instance Constructor C1_2Pat
instance Constructor C1_3Pat
instance Constructor C1_4Pat
instance Constructor C1_5Pat
instance Constructor C1_6Pat
instance Constructor C1_7Pat
instance Constructor C1_8Pat
instance Constructor C1_9Pat
instance Constructor C1_10Pat
instance Constructor C1_11Pat
instance Constructor C1_12Pat
instance Constructor C1_13Pat
instance Constructor C1_14Pat
instance Constructor C1_15Pat
instance Constructor C1_16Pat
instance Constructor C1_17Pat
instance Constructor C1_18Pat
instance Constructor C1_19Pat
instance Constructor C1_20Pat
instance Constructor C1_21Pat
instance Datatype D1PatField
instance Constructor C1_0PatField
instance Constructor C1_1PatField
instance Constructor C1_2PatField
instance Datatype D1RPat
instance Constructor C1_0RPat
instance Constructor C1_1RPat
instance Constructor C1_2RPat
instance Constructor C1_3RPat
instance Constructor C1_4RPat
instance Constructor C1_5RPat
instance Constructor C1_6RPat
instance Constructor C1_7RPat
instance Datatype D1Stmt
instance Constructor C1_0Stmt
instance Constructor C1_1Stmt
instance Constructor C1_2Stmt
instance Constructor C1_3Stmt
instance Datatype D1Exp
instance Constructor C1_0Exp
instance Constructor C1_1Exp
instance Constructor C1_2Exp
instance Constructor C1_3Exp
instance Constructor C1_4Exp
instance Constructor C1_5Exp
instance Constructor C1_6Exp
instance Constructor C1_7Exp
instance Constructor C1_8Exp
instance Constructor C1_9Exp
instance Constructor C1_10Exp
instance Constructor C1_11Exp
instance Constructor C1_12Exp
instance Constructor C1_13Exp
instance Constructor C1_14Exp
instance Constructor C1_15Exp
instance Constructor C1_16Exp
instance Constructor C1_17Exp
instance Constructor C1_18Exp
instance Constructor C1_19Exp
instance Constructor C1_20Exp
instance Constructor C1_21Exp
instance Constructor C1_22Exp
instance Constructor C1_23Exp
instance Constructor C1_24Exp
instance Constructor C1_25Exp
instance Constructor C1_26Exp
instance Constructor C1_27Exp
instance Constructor C1_28Exp
instance Constructor C1_29Exp
instance Constructor C1_30Exp
instance Constructor C1_31Exp
instance Constructor C1_32Exp
instance Constructor C1_33Exp
instance Constructor C1_34Exp
instance Constructor C1_35Exp
instance Constructor C1_36Exp
instance Constructor C1_37Exp
instance Constructor C1_38Exp
instance Constructor C1_39Exp
instance Constructor C1_40Exp
instance Constructor C1_41Exp
instance Constructor C1_42Exp
instance Constructor C1_43Exp
instance Constructor C1_44Exp
instance Constructor C1_45Exp
instance Constructor C1_46Exp
instance Constructor C1_47Exp
instance Constructor C1_48Exp
instance Constructor C1_49Exp
instance Constructor C1_50Exp
instance Constructor C1_51Exp
instance Datatype D1FieldUpdate
instance Constructor C1_0FieldUpdate
instance Constructor C1_1FieldUpdate
instance Constructor C1_2FieldUpdate
instance Datatype D1QualStmt
instance Constructor C1_0QualStmt
instance Constructor C1_1QualStmt
instance Constructor C1_2QualStmt
instance Constructor C1_3QualStmt
instance Constructor C1_4QualStmt
instance Constructor C1_5QualStmt
instance Datatype D1Splice
instance Constructor C1_0Splice
instance Constructor C1_1Splice
instance Datatype D1Bracket
instance Constructor C1_0Bracket
instance Constructor C1_1Bracket
instance Constructor C1_2Bracket
instance Constructor C1_3Bracket
instance Datatype D1Asst
instance Constructor C1_0Asst
instance Constructor C1_1Asst
instance Constructor C1_2Asst
instance Constructor C1_3Asst
instance Constructor C1_4Asst
instance Constructor C1_5Asst
instance Datatype D1Decl
instance Constructor C1_0Decl
instance Constructor C1_1Decl
instance Constructor C1_2Decl
instance Constructor C1_3Decl
instance Constructor C1_4Decl
instance Constructor C1_5Decl
instance Constructor C1_6Decl
instance Constructor C1_7Decl
instance Constructor C1_8Decl
instance Constructor C1_9Decl
instance Constructor C1_10Decl
instance Constructor C1_11Decl
instance Constructor C1_12Decl
instance Constructor C1_13Decl
instance Constructor C1_14Decl
instance Constructor C1_15Decl
instance Constructor C1_16Decl
instance Constructor C1_17Decl
instance Constructor C1_18Decl
instance Constructor C1_19Decl
instance Constructor C1_20Decl
instance Constructor C1_21Decl
instance Constructor C1_22Decl
instance Constructor C1_23Decl
instance Constructor C1_24Decl
instance Constructor C1_25Decl
instance Constructor C1_26Decl
instance Constructor C1_27Decl
instance Constructor C1_28Decl
instance Constructor C1_29Decl
instance Datatype D1Rule
instance Constructor C1_0Rule
instance Datatype D1RuleVar
instance Constructor C1_0RuleVar
instance Constructor C1_1RuleVar
instance Datatype D1Rhs
instance Constructor C1_0Rhs
instance Constructor C1_1Rhs
instance Datatype D1GuardedRhs
instance Constructor C1_0GuardedRhs
instance Datatype D1InstDecl
instance Constructor C1_0InstDecl
instance Constructor C1_1InstDecl
instance Constructor C1_2InstDecl
instance Constructor C1_3InstDecl
instance Datatype D1GadtDecl
instance Constructor C1_0GadtDecl
instance Datatype D1QualConDecl
instance Constructor C1_0QualConDecl
instance Datatype D1ConDecl
instance Constructor C1_0ConDecl
instance Constructor C1_1ConDecl
instance Constructor C1_2ConDecl
instance Datatype D1ClassDecl
instance Constructor C1_0ClassDecl
instance Constructor C1_1ClassDecl
instance Constructor C1_2ClassDecl
instance Constructor C1_3ClassDecl
instance Constructor C1_4ClassDecl
instance Datatype D1Match
instance Constructor C1_0Match
instance Datatype D1Binds
instance Constructor C1_0Binds
instance Constructor C1_1Binds
instance Datatype D1IPBind
instance Constructor C1_0IPBind
instance Datatype D1Annotation
instance Constructor C1_0Annotation
instance Constructor C1_1Annotation
instance Constructor C1_2Annotation
instance Datatype D1TypeEqn
instance Constructor C1_0TypeEqn
instance Datatype D1XAttr
instance Constructor C1_0XAttr
instance Datatype D1PXAttr
instance Constructor C1_0PXAttr
instance Datatype D1ModulePragma
instance Constructor C1_0ModulePragma
instance Constructor C1_1ModulePragma
instance Constructor C1_2ModulePragma
instance Datatype D1Module
instance Constructor C1_0Module


-- | This module contains combinators to use when building Haskell source
--   trees programmatically, as opposed to parsing them from a string. The
--   contents here are quite experimental and will likely receive a lot of
--   attention when the rest has stabilised.
module Language.Haskell.Exts.Build

-- | An identifier with the given string as its name. The string should be
--   a valid Haskell identifier.
name :: String -> Name

-- | A symbol identifier. The string should be a valid Haskell symbol
--   identifier.
sym :: String -> Name

-- | A local variable as expression.
var :: Name -> Exp

-- | Use the given identifier as an operator.
op :: Name -> QOp

-- | A qualified variable as expression.
qvar :: ModuleName -> Name -> Exp

-- | A pattern variable.
pvar :: Name -> Pat

-- | Application of expressions by juxtaposition.
app :: Exp -> Exp -> Exp

-- | Apply an operator infix.
infixApp :: Exp -> QOp -> Exp -> Exp

-- | Apply a function to a list of arguments.
appFun :: Exp -> [Exp] -> Exp

-- | A constructor pattern, with argument patterns.
pApp :: Name -> [Pat] -> Pat

-- | A tuple expression.
tuple :: [Exp] -> Exp

-- | A tuple pattern.
pTuple :: [Pat] -> Pat

-- | A tuple expression consisting of variables only.
varTuple :: [Name] -> Exp

-- | A tuple pattern consisting of variables only.
pvarTuple :: [Name] -> Pat

-- | A function with a given name.
function :: String -> Exp

-- | A literal string expression.
strE :: String -> Exp

-- | A literal character expression.
charE :: Char -> Exp

-- | A literal integer expression.
intE :: Integer -> Exp

-- | A literal string pattern.
strP :: String -> Pat

-- | A literal character pattern.
charP :: Char -> Pat

-- | A literal integer pattern.
intP :: Integer -> Pat

-- | A do block formed by the given statements. The last statement in the
--   list should be a <a>Qualifier</a> expression.
doE :: [Stmt] -> Exp

-- | Lambda abstraction, given a list of argument patterns and an
--   expression body.
lamE :: SrcLoc -> [Pat] -> Exp -> Exp

-- | A <tt>let</tt> ... <tt>in</tt> block.
letE :: [Decl] -> Exp -> Exp

-- | A <tt>case</tt> expression.
caseE :: Exp -> [Alt] -> Exp

-- | An unguarded alternative in a <tt>case</tt> expression.
alt :: SrcLoc -> Pat -> Exp -> Alt

-- | An alternative with a single guard in a <tt>case</tt> expression.
altGW :: SrcLoc -> Pat -> [Stmt] -> Exp -> Binds -> Alt

-- | A list expression.
listE :: [Exp] -> Exp

-- | The empty list expression.
eList :: Exp

-- | The empty list pattern.
peList :: Pat

-- | Put parentheses around an expression.
paren :: Exp -> Exp

-- | Put parentheses around a pattern.
pParen :: Pat -> Pat

-- | A qualifier expression statement.
qualStmt :: Exp -> Stmt

-- | A generator statement: <i>pat</i> <tt>&lt;-</tt> <i>exp</i>
genStmt :: SrcLoc -> Pat -> Exp -> Stmt

-- | A <tt>let</tt> binding group as a statement.
letStmt :: [Decl] -> Stmt

-- | Hoist a set of declarations to a binding group.
binds :: [Decl] -> Binds

-- | An empty binding group.
noBinds :: Binds

-- | The wildcard pattern: <tt>_</tt>
wildcard :: Pat

-- | Generate k names by appending numbers 1 through k to a given string.
genNames :: String -> Int -> [Name]

-- | A function with a single clause
sfun :: SrcLoc -> Name -> [Name] -> Rhs -> Binds -> Decl

-- | A function with a single clause, a single argument, no guards and no
--   where declarations
simpleFun :: SrcLoc -> Name -> Name -> Exp -> Decl

-- | A pattern bind where the pattern is a variable, and where there are no
--   guards and no 'where' clause.
patBind :: SrcLoc -> Pat -> Exp -> Decl

-- | A pattern bind where the pattern is a variable, and where there are no
--   guards, but with a 'where' clause.
patBindWhere :: SrcLoc -> Pat -> Exp -> [Decl] -> Decl

-- | Bind an identifier to an expression.
nameBind :: SrcLoc -> Name -> Exp -> Decl

-- | Apply function of a given name to a list of arguments.
metaFunction :: String -> [Exp] -> Exp

-- | Apply a constructor of a given name to a list of pattern arguments,
--   forming a constructor pattern.
metaConPat :: String -> [Pat] -> Pat


-- | Fixity information to give the parser so that infix operators can be
--   parsed properly.
module Language.Haskell.Exts.Fixity

-- | Operator fixities are represented by their associativity (left, right
--   or none) and their precedence (0-9).
data Fixity
Fixity :: Assoc -> Int -> QName -> Fixity
infix_ :: Int -> [String] -> [Fixity]
infixl_ :: Int -> [String] -> [Fixity]
infixr_ :: Int -> [String] -> [Fixity]

-- | All fixities defined in the Prelude.
preludeFixities :: [Fixity]

-- | All fixities defined in the base package.
--   
--   Note that the <tt>+++</tt> operator appears in both Control.Arrows and
--   Text.ParserCombinators.ReadP. The listed precedence for <tt>+++</tt>
--   in this list is that of Control.Arrows.
baseFixities :: [Fixity]

-- | Built-in fixity for prefix minus
prefixMinusFixity :: (Assoc, Int)

-- | All AST elements that may include expressions which in turn may need
--   fixity tweaking will be instances of this class.
class AppFixity ast
applyFixities :: (AppFixity ast, Monad m) => [Fixity] -> ast -> m ast
instance Typeable Fixity
instance Eq Fixity
instance Ord Fixity
instance Show Fixity
instance Data Fixity
instance AppFixity XAttr
instance AppFixity Splice
instance AppFixity Bracket
instance AppFixity QualStmt
instance AppFixity Alt
instance AppFixity FieldUpdate
instance AppFixity IPBind
instance AppFixity Binds
instance AppFixity Stmt
instance AppFixity PXAttr
instance AppFixity RPat
instance AppFixity PatField
instance AppFixity GuardedRhs
instance AppFixity Rhs
instance AppFixity Match
instance AppFixity InstDecl
instance AppFixity ClassDecl
instance AppFixity Annotation
instance AppFixity Decl
instance AppFixity Module
instance AppFixity Pat
instance AppFixity Exp


-- | Lexer for Haskell with extensions.
module Language.Haskell.Exts.Lexer

-- | Lex a string into a list of Haskell 2010 source tokens.
lexTokenStream :: String -> ParseResult [Loc Token]

-- | Lex a string into a list of Haskell source tokens, using an explicit
--   mode.
lexTokenStreamWithMode :: ParseMode -> String -> ParseResult [Loc Token]
data Token
VarId :: String -> Token
QVarId :: (String, String) -> Token
IDupVarId :: (String) -> Token
ILinVarId :: (String) -> Token
ConId :: String -> Token
QConId :: (String, String) -> Token
DVarId :: [String] -> Token
VarSym :: String -> Token
ConSym :: String -> Token
QVarSym :: (String, String) -> Token
QConSym :: (String, String) -> Token
IntTok :: (Integer, String) -> Token
FloatTok :: (Rational, String) -> Token
Character :: (Char, String) -> Token
StringTok :: (String, String) -> Token
IntTokHash :: (Integer, String) -> Token
WordTokHash :: (Integer, String) -> Token
FloatTokHash :: (Rational, String) -> Token
DoubleTokHash :: (Rational, String) -> Token
CharacterHash :: (Char, String) -> Token
StringHash :: (String, String) -> Token
LeftParen :: Token
RightParen :: Token
LeftHashParen :: Token
RightHashParen :: Token
SemiColon :: Token
LeftCurly :: Token
RightCurly :: Token
VRightCurly :: Token
LeftSquare :: Token
RightSquare :: Token
ParArrayLeftSquare :: Token
ParArrayRightSquare :: Token
Comma :: Token
Underscore :: Token
BackQuote :: Token
Dot :: Token
DotDot :: Token
Colon :: Token
QuoteColon :: Token
DoubleColon :: Token
Equals :: Token
Backslash :: Token
Bar :: Token
LeftArrow :: Token
RightArrow :: Token
At :: Token
Tilde :: Token
DoubleArrow :: Token
Minus :: Token
Exclamation :: Token
Star :: Token
LeftArrowTail :: Token
RightArrowTail :: Token
LeftDblArrowTail :: Token
RightDblArrowTail :: Token
THExpQuote :: Token
THPatQuote :: Token
THDecQuote :: Token
THTypQuote :: Token
THCloseQuote :: Token

-- | ]
THIdEscape :: (String) -> Token
THParenEscape :: Token
THVarQuote :: Token
THTyQuote :: Token
THQuasiQuote :: (String, String) -> Token
RPGuardOpen :: Token
RPGuardClose :: Token

-- | )
RPCAt :: Token
XCodeTagOpen :: Token
XCodeTagClose :: Token
XStdTagOpen :: Token
XStdTagClose :: Token
XCloseTagOpen :: Token
XEmptyTagClose :: Token
XChildTagOpen :: Token
XPCDATA :: String -> Token
XRPatOpen :: Token
XRPatClose :: Token
PragmaEnd :: Token
RULES :: Token
INLINE :: Bool -> Token
INLINE_CONLIKE :: Token
SPECIALISE :: Token
SPECIALISE_INLINE :: Bool -> Token
SOURCE :: Token
DEPRECATED :: Token
WARNING :: Token
SCC :: Token
GENERATED :: Token
CORE :: Token
UNPACK :: Token
OPTIONS :: (Maybe String, String) -> Token
LANGUAGE :: Token
ANN :: Token
MINIMAL :: Token
NO_OVERLAP :: Token
OVERLAP :: Token
INCOHERENT :: Token
KW_As :: Token
KW_By :: Token
KW_Case :: Token
KW_Class :: Token
KW_Data :: Token
KW_Default :: Token
KW_Deriving :: Token
KW_Do :: Token
KW_MDo :: Token
KW_Else :: Token
KW_Family :: Token
KW_Forall :: Token
KW_Group :: Token
KW_Hiding :: Token
KW_If :: Token
KW_Import :: Token
KW_In :: Token
KW_Infix :: Token
KW_InfixL :: Token
KW_InfixR :: Token
KW_Instance :: Token
KW_Let :: Token
KW_Module :: Token
KW_NewType :: Token
KW_Of :: Token
KW_Proc :: Token
KW_Rec :: Token
KW_Then :: Token
KW_Type :: Token
KW_Using :: Token
KW_Where :: Token
KW_Qualified :: Token
KW_Foreign :: Token
KW_Export :: Token
KW_Safe :: Token
KW_Unsafe :: Token
KW_Threadsafe :: Token
KW_Interruptible :: Token
KW_StdCall :: Token
KW_CCall :: Token
KW_CPlusPlus :: Token
KW_DotNet :: Token
KW_Jvm :: Token
KW_Js :: Token
KW_CApi :: Token
EOF :: Token

-- | An entity located in the source.
data Loc a
Loc :: SrcSpan -> a -> Loc a
loc :: Loc a -> SrcSpan
unLoc :: Loc a -> a
showToken :: Token -> String


-- | This module contains code for translating from the annotated complex
--   AST in Language.Haskell.Exts.Annotated.Syntax to the simpler, sparsely
--   annotated AST in Language.Haskell.Exts.Syntax.
--   
--   A function <tt>sXYZ</tt> translates an annotated AST node of type
--   <tt>XYZ l</tt> into a simple AST node of type <tt>XYZ</tt>. I would
--   have prefered to use a MPTC with an fd/type family to get a single
--   exported function name, but I wish to stay Haskell 2010 compliant.
--   Let's hope for Haskell 2011.
module Language.Haskell.Exts.Annotated.Simplify

-- | Translate an annotated AST node representing a Haskell module, into a
--   simpler version that retains (almost) only abstract information. In
--   particular, XML and hybrid XML pages enabled by the XmlSyntax
--   extension are translated into standard Haskell modules with a
--   <tt>page</tt> function.
sModule :: SrcInfo loc => Module loc -> Module

-- | Translate an annotated AST node representing a Haskell declaration
--   into a simpler version. Note that in the simpler version, all
--   declaration nodes are still annotated by <a>SrcLoc</a>s.
sDecl :: SrcInfo loc => Decl loc -> Decl
sTypeEqn :: SrcInfo l => TypeEqn l -> TypeEqn
sAnnotation :: SrcInfo loc => Annotation loc -> Annotation
sBooleanFormula :: SrcInfo loc => BooleanFormula loc -> BooleanFormula
sModuleName :: ModuleName l -> ModuleName
sSpecialCon :: SpecialCon l -> SpecialCon
sQName :: QName l -> QName
sName :: Name l -> Name
sIPName :: IPName l -> IPName
sQOp :: QOp l -> QOp
sOp :: Op l -> Op
sCName :: CName l -> CName
sModuleHead :: Maybe (ModuleHead l) -> (ModuleName, Maybe WarningText, Maybe [ExportSpec])
sExportSpecList :: ExportSpecList l -> [ExportSpec]
sExportSpec :: ExportSpec l -> ExportSpec
sImportDecl :: SrcInfo loc => ImportDecl loc -> ImportDecl
sImportSpecList :: ImportSpecList l -> (Bool, [ImportSpec])
sNamespace :: Namespace l -> Namespace
sImportSpec :: ImportSpec l -> ImportSpec
sAssoc :: Assoc l -> Assoc
sDeclHead :: DeclHead l -> (Name, [TyVarBind])
sInstRule :: SrcInfo l => InstRule l -> ([TyVarBind], [Asst], (QName, [Type]))
sInstHead :: SrcInfo l => InstHead l -> (QName, [Type])
sDataOrNew :: DataOrNew l -> DataOrNew
sDeriving :: SrcInfo l => Deriving l -> [(QName, [Type])]
sBinds :: SrcInfo loc => Binds loc -> Binds
sIPBind :: SrcInfo loc => IPBind loc -> IPBind
sMatch :: SrcInfo loc => Match loc -> Match
sQualConDecl :: SrcInfo loc => QualConDecl loc -> QualConDecl
sConDecl :: SrcInfo l => ConDecl l -> ConDecl
sFieldDecl :: SrcInfo l => FieldDecl l -> ([Name], Type)
sGadtDecl :: SrcInfo loc => GadtDecl loc -> GadtDecl
sClassDecl :: SrcInfo loc => ClassDecl loc -> ClassDecl
sRecFields :: SrcInfo l => [FieldDecl l] -> [([Name], Type)]
sInstDecl :: SrcInfo loc => InstDecl loc -> InstDecl
sBangType :: SrcInfo l => BangType l -> BangType
sRhs :: SrcInfo loc => Rhs loc -> Rhs
sGuardedRhs :: SrcInfo loc => GuardedRhs loc -> GuardedRhs
sType :: SrcInfo l => Type l -> Type
sPromoted :: Promoted l -> Promoted
sTyVarBind :: TyVarBind l -> TyVarBind
sKind :: Kind l -> Kind
sFunDep :: FunDep l -> FunDep
sContext :: SrcInfo l => Context l -> Context
sAsst :: SrcInfo l => Asst l -> Asst
sLiteral :: Literal l -> Literal
sSign :: Sign l -> Sign
sExp :: SrcInfo loc => Exp loc -> Exp
sXName :: XName l -> XName
sXAttr :: SrcInfo loc => XAttr loc -> XAttr
sBracket :: SrcInfo loc => Bracket loc -> Bracket
sSplice :: SrcInfo loc => Splice loc -> Splice
sSafety :: Safety l -> Safety
sCallConv :: CallConv l -> CallConv
sModulePragma :: SrcInfo loc => ModulePragma loc -> ModulePragma
sOverlap :: SrcInfo loc => Overlap loc -> Overlap
sActivation :: Activation l -> Activation
sRule :: SrcInfo loc => Rule loc -> Rule
sRuleVar :: SrcInfo l => RuleVar l -> RuleVar
sWarningText :: WarningText l -> WarningText
sPat :: SrcInfo loc => Pat loc -> Pat
sPXAttr :: SrcInfo loc => PXAttr loc -> PXAttr
sRPatOp :: RPatOp l -> RPatOp
sRPat :: SrcInfo loc => RPat loc -> RPat
sPatField :: SrcInfo loc => PatField loc -> PatField
sStmt :: SrcInfo loc => Stmt loc -> Stmt
sQualStmt :: SrcInfo loc => QualStmt loc -> QualStmt
sFieldUpdate :: SrcInfo loc => FieldUpdate loc -> FieldUpdate
sAlt :: SrcInfo loc => Alt loc -> Alt


-- | Pretty printer for Haskell with extensions.
module Language.Haskell.Exts.Pretty

-- | Things that can be pretty-printed, including all the syntactic objects
--   in <a>Language.Haskell.Exts.Syntax</a> and
--   <a>Language.Haskell.Exts.Annotated.Syntax</a>.
class Pretty a where pretty = prettyPrec 0 prettyPrec _ = pretty

-- | render the document with a given mode. renderWithMode :: PPHsMode
--   -&gt; Doc -&gt; String renderWithMode = renderStyleMode P.style
--   
--   render the document with <a>defaultMode</a>. render :: Doc -&gt;
--   String render = renderWithMode defaultMode
--   
--   pretty-print with a given style and mode.
prettyPrintStyleMode :: Pretty a => Style -> PPHsMode -> a -> String

-- | pretty-print with the default style and a given mode.
prettyPrintWithMode :: Pretty a => PPHsMode -> a -> String

-- | pretty-print with the default style and <a>defaultMode</a>.
prettyPrint :: Pretty a => a -> String

-- | A rendering style.
data Style :: *
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
mode :: Style -> Mode

-- | Length of line, in chars
lineLength :: Style -> Int

-- | Ratio of ribbon length to line length
ribbonsPerLine :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Rendering mode.
data Mode :: *

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | Pretty-printing parameters.
--   
--   <i>Note:</i> the <a>onsideIndent</a> must be positive and less than
--   all other indents.
data PPHsMode
PPHsMode :: Indent -> Indent -> Indent -> Indent -> Indent -> Indent -> Indent -> Bool -> PPLayout -> Bool -> PPHsMode

-- | indentation of a class or instance
classIndent :: PPHsMode -> Indent

-- | indentation of a <tt>do</tt>-expression
doIndent :: PPHsMode -> Indent

-- | indentation of the body of a <tt>case</tt> expression
multiIfIndent :: PPHsMode -> Indent

-- | indentation of the body of a multi-<tt>if</tt> expression
caseIndent :: PPHsMode -> Indent

-- | indentation of the declarations in a <tt>let</tt> expression
letIndent :: PPHsMode -> Indent

-- | indentation of the declarations in a <tt>where</tt> clause
whereIndent :: PPHsMode -> Indent

-- | indentation added for continuation lines that would otherwise be
--   offside
onsideIndent :: PPHsMode -> Indent

-- | blank lines between statements?
spacing :: PPHsMode -> Bool

-- | Pretty-printing style to use
layout :: PPHsMode -> PPLayout

-- | add GHC-style <tt>LINE</tt> pragmas to output?
linePragmas :: PPHsMode -> Bool
type Indent = Int

-- | Varieties of layout we can use.
data PPLayout

-- | classical layout
PPOffsideRule :: PPLayout

-- | classical layout made explicit
PPSemiColon :: PPLayout

-- | inline decls, with newlines between them
PPInLine :: PPLayout

-- | everything on a single line
PPNoLayout :: PPLayout

-- | The default mode: pretty-print using the offside rule and sensible
--   defaults.
defaultMode :: PPHsMode
instance Eq PPLayout
instance SrcInfo loc => Pretty (PType loc)
instance SrcInfo loc => Pretty (PAsst loc)
instance SrcInfo loc => Pretty (PContext loc)
instance SrcInfo loc => Pretty (ParseXAttr loc)
instance SrcInfo loc => Pretty (PFieldUpdate loc)
instance SrcInfo loc => Pretty (PExp loc)
instance SrcInfo l => Pretty (Asst l)
instance SrcInfo l => Pretty (Context l)
instance Pretty (CName l)
instance SrcInfo loc => Pretty (IPBind loc)
instance Pretty (IPName l)
instance Pretty (Name l)
instance Pretty (Op l)
instance Pretty (QName l)
instance Pretty (QOp l)
instance SrcInfo loc => Pretty (FieldUpdate loc)
instance SrcInfo loc => Pretty (QualStmt loc)
instance SrcInfo loc => Pretty (Stmt loc)
instance SrcInfo loc => Pretty (Alt loc)
instance Pretty (RPatOp l)
instance SrcInfo loc => Pretty (RPat loc)
instance SrcInfo loc => Pretty (PatField loc)
instance SrcInfo loc => Pretty (PXAttr loc)
instance SrcInfo loc => Pretty (Pat loc)
instance SrcInfo loc => Pretty (Splice loc)
instance SrcInfo loc => Pretty (Bracket loc)
instance Pretty (XName l)
instance SrcInfo loc => Pretty (XAttr loc)
instance SrcInfo loc => Pretty (Exp loc)
instance Pretty (Literal l)
instance SrcInfo loc => Pretty (GuardedRhs loc)
instance SrcInfo loc => Pretty (Rhs loc)
instance Pretty (FunDep l)
instance Pretty (Kind l)
instance Pretty (TyVarBind l)
instance SrcInfo l => Pretty (Type l)
instance SrcInfo l => Pretty (Deriving l)
instance SrcInfo l => Pretty (BangType l)
instance SrcInfo l => Pretty (FieldDecl l)
instance SrcInfo l => Pretty (ConDecl l)
instance SrcInfo l => Pretty (GadtDecl l)
instance SrcInfo l => Pretty (QualConDecl l)
instance SrcInfo loc => Pretty (Annotation loc)
instance SrcInfo loc => Pretty (ModulePragma loc)
instance SrcInfo l => Pretty (RuleVar l)
instance Pretty (Activation l)
instance SrcInfo loc => Pretty (Rule loc)
instance Pretty (CallConv l)
instance Pretty (Safety l)
instance SrcInfo loc => Pretty (InstDecl loc)
instance SrcInfo loc => Pretty (ClassDecl loc)
instance SrcInfo pos => Pretty (Match pos)
instance Pretty (Assoc l)
instance Pretty (DataOrNew l)
instance SrcInfo l => Pretty (InstHead l)
instance SrcInfo l => Pretty (InstRule l)
instance Pretty (DeclHead l)
instance SrcInfo pos => Pretty (Decl pos)
instance Pretty (ImportSpec l)
instance Pretty (ImportSpecList l)
instance SrcInfo pos => Pretty (ImportDecl pos)
instance Pretty (ExportSpec l)
instance Pretty (ExportSpecList l)
instance Pretty (ModuleName l)
instance Pretty (WarningText l)
instance Pretty (ModuleHead l)
instance SrcInfo pos => Pretty (Module pos)
instance Pretty SrcSpan
instance Pretty SrcLoc
instance Pretty Asst
instance Pretty SpecialCon
instance Pretty CName
instance Pretty IPBind
instance Pretty IPName
instance Pretty Name
instance Pretty Op
instance Pretty QName
instance Pretty QOp
instance Pretty FieldUpdate
instance Pretty QualStmt
instance Pretty Stmt
instance Pretty Alt
instance Pretty RPatOp
instance Pretty RPat
instance Pretty PatField
instance Pretty PXAttr
instance Pretty Pat
instance Pretty Splice
instance Pretty Bracket
instance Pretty XName
instance Pretty XAttr
instance Pretty Exp
instance Pretty Literal
instance Pretty GuardedAlt
instance Pretty GuardedAlts
instance Pretty GuardedRhs
instance Pretty Rhs
instance Pretty FunDep
instance Pretty Kind
instance Pretty TyVarBind
instance Pretty Promoted
instance Pretty Type
instance Pretty BangType
instance Pretty ConDecl
instance Pretty GadtDecl
instance Pretty QualConDecl
instance Pretty Tool
instance Pretty ModulePragma
instance Pretty RuleVar
instance Pretty Overlap
instance Pretty Activation
instance Pretty Rule
instance Pretty CallConv
instance Pretty Safety
instance Pretty InstDecl
instance Pretty ClassDecl
instance Pretty Match
instance Pretty Assoc
instance Pretty DataOrNew
instance Pretty BooleanFormula
instance Pretty Annotation
instance Pretty Decl
instance Pretty TypeEqn
instance Pretty ImportSpec
instance Pretty ImportDecl
instance Pretty ExportSpec
instance Pretty ModuleName
instance Pretty Module
instance Monad (DocM s)
instance Applicative (DocM s)
instance Functor (DocM s)


-- | Fixity information to give the parser so that infix operators can be
--   parsed properly.
module Language.Haskell.Exts.Annotated.Fixity

-- | Operator fixities are represented by their associativity (left, right
--   or none) and their precedence (0-9).
data Fixity
Fixity :: Assoc -> Int -> QName -> Fixity
infix_ :: Int -> [String] -> [Fixity]
infixl_ :: Int -> [String] -> [Fixity]
infixr_ :: Int -> [String] -> [Fixity]

-- | All fixities defined in the Prelude.
preludeFixities :: [Fixity]

-- | All fixities defined in the base package.
--   
--   Note that the <tt>+++</tt> operator appears in both Control.Arrows and
--   Text.ParserCombinators.ReadP. The listed precedence for <tt>+++</tt>
--   in this list is that of Control.Arrows.
baseFixities :: [Fixity]

-- | All AST elements that may include expressions which in turn may need
--   fixity tweaking will be instances of this class.
class AppFixity ast
applyFixities :: (AppFixity ast, Monad m) => [Fixity] -> ast SrcSpanInfo -> m (ast SrcSpanInfo)
instance AppFixity XAttr
instance AppFixity Splice
instance AppFixity Bracket
instance AppFixity QualStmt
instance AppFixity Alt
instance AppFixity FieldUpdate
instance AppFixity IPBind
instance AppFixity Binds
instance AppFixity Stmt
instance AppFixity PXAttr
instance AppFixity RPat
instance AppFixity PatField
instance AppFixity GuardedRhs
instance AppFixity Rhs
instance AppFixity Match
instance AppFixity InstDecl
instance AppFixity ClassDecl
instance AppFixity Annotation
instance AppFixity Decl
instance AppFixity Module
instance AppFixity Pat
instance AppFixity Exp


-- | Parser for Haskell with extensions.
module Language.Haskell.Exts.Parser

-- | Class to reuse the parse function at many different types.
class Parseable ast
parse :: Parseable ast => String -> ParseResult ast
parseWithMode :: Parseable ast => ParseMode -> String -> ParseResult ast
parseWithComments :: Parseable ast => ParseMode -> String -> ParseResult (ast, [Comment])

-- | Static parameters governing a parse. Note that the various parse
--   functions in <a>Language.Haskell.Exts.Parser</a> never look at
--   LANGUAGE pragmas, regardless of what the
--   <tt>ignoreLanguagePragmas</tt> flag is set to. Only the various
--   <tt>parseFile</tt> functions in <a>Language.Haskell.Exts</a> will act
--   on it, when set to <a>False</a>.
data ParseMode
ParseMode :: String -> Language -> [Extension] -> Bool -> Bool -> Maybe [Fixity] -> ParseMode

-- | original name of the file being parsed
parseFilename :: ParseMode -> String

-- | base language (e.g. Haskell98, Haskell2010)
baseLanguage :: ParseMode -> Language

-- | list of extensions enabled for parsing
extensions :: ParseMode -> [Extension]

-- | if <a>True</a>, the parser won't care about further extensions in
--   LANGUAGE pragmas in source files
ignoreLanguagePragmas :: ParseMode -> Bool

-- | if <a>True</a>, the parser won't read line position information from
--   LINE pragmas in source files
ignoreLinePragmas :: ParseMode -> Bool

-- | list of fixities to be aware of
fixities :: ParseMode -> Maybe [Fixity]

-- | Default parameters for a parse. The default is an unknown filename, no
--   extensions (i.e. Haskell 98), don't ignore LANGUAGE pragmas, do ignore
--   LINE pragmas, and be aware of fixities from the <tt>Prelude</tt>.
defaultParseMode :: ParseMode

-- | The result of a parse.
data ParseResult a

-- | The parse succeeded, yielding a value.
ParseOk :: a -> ParseResult a

-- | The parse failed at the specified source location, with an error
--   message.
ParseFailed :: SrcLoc -> String -> ParseResult a

-- | Retrieve the result of a successful parse, throwing an error if the
--   parse is actually not successful.
fromParseResult :: ParseResult a -> a

-- | Parse of a string, which should contain a complete Haskell module.
parseModule :: String -> ParseResult Module

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode.
parseModuleWithMode :: ParseMode -> String -> ParseResult Module

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseModuleWithComments :: ParseMode -> String -> ParseResult (Module, [Comment])

-- | Parse of a string containing a Haskell expression.
parseExp :: String -> ParseResult Exp

-- | Parse of a string containing a Haskell expression, using an explicit
--   mode.
parseExpWithMode :: ParseMode -> String -> ParseResult Exp

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseExpWithComments :: ParseMode -> String -> ParseResult (Exp, [Comment])

-- | Parse of a string containing a Haskell type.
parseStmt :: String -> ParseResult Stmt

-- | Parse of a string containing a Haskell type, using an explicit mode.
parseStmtWithMode :: ParseMode -> String -> ParseResult Stmt

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseStmtWithComments :: ParseMode -> String -> ParseResult (Stmt, [Comment])

-- | Parse of a string containing a Haskell pattern.
parsePat :: String -> ParseResult Pat

-- | Parse of a string containing a Haskell pattern, using an explicit
--   mode.
parsePatWithMode :: ParseMode -> String -> ParseResult Pat

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parsePatWithComments :: ParseMode -> String -> ParseResult (Pat, [Comment])

-- | Parse of a string containing a Haskell top-level declaration.
parseDecl :: String -> ParseResult Decl

-- | Parse of a string containing a Haskell top-level declaration, using an
--   explicit mode.
parseDeclWithMode :: ParseMode -> String -> ParseResult Decl

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseDeclWithComments :: ParseMode -> String -> ParseResult (Decl, [Comment])

-- | Parse of a string containing a Haskell type.
parseType :: String -> ParseResult Type

-- | Parse of a string containing a Haskell type, using an explicit mode.
parseTypeWithMode :: ParseMode -> String -> ParseResult Type

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseTypeWithComments :: ParseMode -> String -> ParseResult (Type, [Comment])
getTopPragmas :: String -> ParseResult [ModulePragma]
instance Parseable Type
instance Parseable Decl
instance Parseable Pat
instance Parseable Exp
instance Parseable Module
instance SrcInfo loc => Parseable (Stmt loc)
instance SrcInfo loc => Parseable (Type loc)
instance SrcInfo loc => Parseable (Decl loc)
instance SrcInfo loc => Parseable (Pat loc)
instance SrcInfo loc => Parseable (Exp loc)
instance SrcInfo loc => Parseable (Module loc)


-- | An umbrella module for the various functionality of the package. Also
--   provides some convenient functionality for dealing directly with
--   source files.
module Language.Haskell.Exts.Annotated

-- | Parse a source file on disk, using the default parse mode.
parseFile :: FilePath -> IO (ParseResult (Module SrcSpanInfo))

-- | Parse a source file on disk, supplying a custom parse mode.
parseFileWithMode :: ParseMode -> FilePath -> IO (ParseResult (Module SrcSpanInfo))

-- | Parse a source file on disk, with an extra set of extensions to know
--   about on top of what the file itself declares.
parseFileWithExts :: [Extension] -> FilePath -> IO (ParseResult (Module SrcSpanInfo))
parseFileWithComments :: ParseMode -> FilePath -> IO (ParseResult (Module SrcSpanInfo, [Comment]))

-- | Parse a source file from a string using the default parse mode.
parseFileContents :: String -> ParseResult (Module SrcSpanInfo)

-- | Parse a source file from a string using a custom parse mode.
parseFileContentsWithMode :: ParseMode -> String -> ParseResult (Module SrcSpanInfo)

-- | Parse a source file from a string, with an extra set of extensions to
--   know about on top of what the file itself declares.
parseFileContentsWithExts :: [Extension] -> String -> ParseResult (Module SrcSpanInfo)
parseFileContentsWithComments :: ParseMode -> String -> ParseResult (Module SrcSpanInfo, [Comment])

-- | Parse of a string, which should contain a complete Haskell module.
parseModule :: String -> ParseResult (Module SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode.
parseModuleWithMode :: ParseMode -> String -> ParseResult (Module SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseModuleWithComments :: ParseMode -> String -> ParseResult (Module SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell expression.
parseExp :: String -> ParseResult (Exp SrcSpanInfo)

-- | Parse of a string containing a Haskell expression, using an explicit
--   mode.
parseExpWithMode :: ParseMode -> String -> ParseResult (Exp SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseExpWithComments :: ParseMode -> String -> ParseResult (Exp SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell statement.
parseStmt :: String -> ParseResult (Stmt SrcSpanInfo)

-- | Parse of a string containing a Haskell type, using an explicit mode.
parseStmtWithMode :: ParseMode -> String -> ParseResult (Stmt SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseStmtWithComments :: ParseMode -> String -> ParseResult (Stmt SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell pattern.
parsePat :: String -> ParseResult (Pat SrcSpanInfo)

-- | Parse of a string containing a Haskell pattern, using an explicit
--   mode.
parsePatWithMode :: ParseMode -> String -> ParseResult (Pat SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parsePatWithComments :: ParseMode -> String -> ParseResult (Pat SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell top-level declaration.
parseDecl :: String -> ParseResult (Decl SrcSpanInfo)

-- | Parse of a string containing a Haskell top-level declaration, using an
--   explicit mode.
parseDeclWithMode :: ParseMode -> String -> ParseResult (Decl SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseDeclWithComments :: ParseMode -> String -> ParseResult (Decl SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell type.
parseType :: String -> ParseResult (Type SrcSpanInfo)

-- | Parse of a string containing a Haskell type, using an explicit mode.
parseTypeWithMode :: ParseMode -> String -> ParseResult (Type SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit mode, retaining comments.
parseTypeWithComments :: ParseMode -> String -> ParseResult (Type SrcSpanInfo, [Comment])

-- | Gather the extensions declared in LANGUAGE pragmas at the top of the
--   file. Returns <a>Nothing</a> if the parse of the pragmas fails.
readExtensions :: String -> Maybe (Maybe Language, [Extension])


-- | An umbrella module for the various functionality of the package. Also
--   provides some convenient functionality for dealing directly with
--   source files.
module Language.Haskell.Exts

-- | Parse a source file on disk, using the default parse mode.
parseFile :: FilePath -> IO (ParseResult Module)

-- | Parse a source file on disk, supplying a custom parse mode.
parseFileWithMode :: ParseMode -> FilePath -> IO (ParseResult Module)

-- | Parse a source file on disk, with an extra set of extensions to know
--   about on top of what the file itself declares.
parseFileWithExts :: [Extension] -> FilePath -> IO (ParseResult Module)

-- | Parse a source file on disk, supplying a custom parse mode, and
--   retaining comments.
parseFileWithComments :: ParseMode -> FilePath -> IO (ParseResult (Module, [Comment]))

-- | Parse a source file on disk, supplying a custom parse mode, and
--   retaining comments as well as unknown pragmas.
parseFileWithCommentsAndPragmas :: ParseMode -> FilePath -> IO (ParseResult (Module, [Comment], [UnknownPragma]))

-- | Parse a source file from a string using the default parse mode.
parseFileContents :: String -> ParseResult Module

-- | Parse a source file from a string using a custom parse mode.
parseFileContentsWithMode :: ParseMode -> String -> ParseResult Module

-- | Parse a source file from a string, with an extra set of extensions to
--   know about on top of what the file itself declares.
parseFileContentsWithExts :: [Extension] -> String -> ParseResult Module

-- | Parse a source file from a string using a custom parse mode and
--   retaining comments.
parseFileContentsWithComments :: ParseMode -> String -> ParseResult (Module, [Comment])

-- | Parse a source file from a string using a custom parse mode retaining
--   comments as well as unknown pragmas.
parseFileContentsWithCommentsAndPragmas :: ParseMode -> String -> ParseResult (Module, [Comment], [UnknownPragma])

-- | Gather the extensions declared in LANGUAGE pragmas at the top of the
--   file. Returns <a>Nothing</a> if the parse of the pragmas fails.
readExtensions :: String -> Maybe (Maybe Language, [Extension])
