-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for the uniform workbench
--   
--   This package contains various miscellaneous utilities used for the old
--   HTk- und uDrawGraph bindings as well as for the MMiSS Workbench. They
--   are kept for compatibility reason and put on hackage to ease
--   installation.
@package uni-util
@version 2.2.1.2


-- | A Store a contains an (a) value which is only to be computed once,
--   when it is first needed.
--   
--   Perhaps we should use laziness and unsafePerformIO?
module Util.Store
data Store a
newStore :: IO (Store a)
takeStore :: IO a -> Store a -> IO a


-- | This module contains code which (supposedly) extracts the full
--   qualified name of the machine on which it is running. (At least it
--   does on the Linux and Solaris implementations I tested.)
module Util.HostName
getFullHostName :: IO String

module Util.VisitedSet
data VisitedSet key
newVisitedSet :: Ord key => IO (VisitedSet key)
isVisited :: Ord key => VisitedSet key -> key -> IO Bool


-- | This defines primitive byte operations, to be used with binary
--   conversion. For the present we use the FFI. There are probably lots of
--   better ways.
module Util.Bytes
data Byte
data Bytes
putByteToBytes :: Byte -> Bytes -> Int -> IO ()
getByteFromBytes :: Bytes -> Int -> IO Byte
putBytesToBytes :: Bytes -> Int -> Bytes -> Int -> Int -> IO ()
hPutByte :: Handle -> Byte -> IO ()
hGetByte :: Handle -> IO Byte
hPutBytes :: Handle -> Bytes -> Int -> IO ()
hGetBytes :: Handle -> Int -> IO Bytes
bytesMalloc :: Int -> IO Bytes
bytesReAlloc :: Bytes -> Int -> IO Bytes
bytesAlloca :: Int -> (Bytes -> IO a) -> IO a
bytesFree :: Bytes -> IO ()
withBytesAsCChars :: Bytes -> (Ptr CChar -> IO a) -> IO a
mkBytes :: Ptr CChar -> Bytes
unMkBytes :: Bytes -> Ptr CChar
compareBytes :: Bytes -> Bytes -> Int -> IO Ordering
instance Eq Byte
instance Ord Byte
instance Num Byte
instance Bits Byte
instance Show Byte
instance Real Byte
instance Enum Byte
instance Integral Byte


-- | Library for converting types to and from binary, so that they can be
--   written to and from files, stored compactly in memory, and so on.
--   
--   This is a preliminary version of the library, hence I have decided
--   <i>not</i> to optimise heavily, beyond putting in strictness
--   annotations in where they seem appropriate.
--   
--   A good place to start optimising would probably be the separate
--   <a>Bytes</a> libary.
--   
--   See also <a>BinaryInstances</a>, which declares instances for the
--   standard types (and one or two others), <a>BinaryUtils</a>, which
--   contains (mostly) material for declaring new instances,
--   <a>BinaryExtras</a>, which contains other miscellaneous utilities, and
--   finally <a>BinaryAll</a> which just imports and reexports everything.
module Util.Binary

-- | Write an (a) to a <a>Handle</a>
hWrite :: HasBinary a IO => Handle -> a -> IO ()

-- | Read an (a) from a <a>Handle</a>
hRead :: HasBinary a IO => Handle -> IO a

-- | Write an (a) to memory. The <a>Int</a> is the length of the area.
writeToBytes :: HasBinary a StateBinArea => a -> IO (Bytes, Int)

-- | Write an (a) to memory. The integer argument is an initial guess at
--   the number of bytes that will be needed. This should be greater than
--   0. If it is too small, there will be unnecessary reallocations; if too
--   large, too much memory will be used.
writeToBytes0 :: HasBinary a StateBinArea => Int -> a -> IO (Bytes, Int)

-- | Read a value from binary data in memory. The <a>Int</a> is the length,
--   and there will be an error if this is either too small or too large.
readFromBytes :: HasBinary a StateBinArea => (Bytes, Int) -> IO a
class HasBinary a m
writeBin :: HasBinary a m => WriteBinary m -> a -> m ()
readBin :: HasBinary a m => ReadBinary m -> m a

-- | A consumer of binary data
data WriteBinary m
WriteBinary :: (Byte -> m ()) -> (Bytes -> Int -> m ()) -> WriteBinary m

-- | write one byte
writeByte :: WriteBinary m -> Byte -> m ()

-- | write multiple bytes
writeBytes :: WriteBinary m -> Bytes -> Int -> m ()

-- | A source of binary data
data ReadBinary m
ReadBinary :: m Byte -> (Int -> m Bytes) -> ReadBinary m

-- | read one byte
readByte :: ReadBinary m -> m Byte

-- | read multiple bytes
readBytes :: ReadBinary m -> Int -> m Bytes
toWriteBinaryHandle :: Handle -> WriteBinary IO
toReadBinaryHandle :: Handle -> ReadBinary IO

-- | Somewhere to where you write binary data in memory.
data BinArea

-- | a state monad containing the BinArea.
type StateBinArea = StateT BinArea IO

-- | Create an empty <a>BinArea</a>, given the initial size.
mkEmptyBinArea :: Int -> IO BinArea

-- | A <a>BinArea</a> as somewhere to put binary data.
writeBinaryBinArea :: WriteBinary StateBinArea

-- | Return all the data currently in the <a>BinArea</a>
closeBinArea :: BinArea -> IO (Bytes, Int)

-- | Turn binary data in memory into a <a>BinArea</a> (so that you can read
--   from it).
mkBinArea :: (Bytes, Int) -> BinArea

-- | A BinArea as a source of binary data.
readBinaryBinArea :: ReadBinary StateBinArea
checkFullBinArea :: BinArea -> IO ()

-- | Transform the monad used by a <a>WriteBinary</a>
liftWriteBinary :: (forall a. m a -> n a) -> WriteBinary m -> WriteBinary n

-- | Transform the monad used by a <a>ReadBinary</a>
liftReadBinary :: (forall a. m a -> n a) -> ReadBinary m -> ReadBinary n


-- | Various functions for declaring new instances of Binary for types.
module Util.BinaryUtils

-- | Given a function which converts an (a) to something we can already
--   convert to binary, return a <a>writeBin</a> function to be used in
--   instances of <a>HasBinary</a> (a).
mapWrite :: HasBinary b m => (a -> b) -> (WriteBinary m -> a -> m ())

-- | Given a function which converts something we can already read from
--   binary to (a), return a <a>readBin</a> function to be used in
--   instances of <a>HasBinary</a> (a).
mapRead :: (Monad m, HasBinary b m) => (b -> a) -> (ReadBinary m -> m a)

-- | Like <a>mapWrite</a>, but the conversion function is also allowed to
--   use <a>IO</a>.
mapWriteIO :: (HasBinary b m, MonadIO m) => (a -> IO b) -> (WriteBinary m -> a -> m ())

-- | LIke <a>mapRead</a>, but the conversion function is also allowed to
--   use <a>IO</a>.
mapReadIO :: (HasBinary b m, MonadIO m) => (b -> IO a) -> (ReadBinary m -> m a)

-- | A monad which hides an additional value which the <a>HasBinary</a>
--   instances should be able to get at. This is used, for example, by
--   <a>CodedValue</a>, to make the <tt>View</tt> available to instances.
data ArgMonad arg m a
mkArgMonad :: (arg -> m a) -> ArgMonad arg m a
toArgMonad :: m a -> ArgMonad arg m a
runArgMonad :: arg -> ArgMonad arg m a -> m a
writeBinaryToArgMonad :: WriteBinary m -> WriteBinary (ArgMonad arg m)
readBinaryToArgMonad :: ReadBinary m -> ReadBinary (ArgMonad arg m)

-- | A wrapper for instances of Binary. This can be written, but not read
--   (since we wouldn't know what type to decode).
data WrappedBinary
WrappedBinary :: v -> WrappedBinary

-- | Write a <a>WrappedBinary</a>
hWriteWrappedBinary :: Handle -> WrappedBinary -> IO ()
data WrapBinary m
WrapBinary :: v -> WrapBinary m
instance HasBinary (WrapBinary m) m
instance MonadIO m => MonadIO (ArgMonad arg m)
instance Monad m => Monad (ArgMonad arg m)
instance Functor m => Functor (ArgMonad arg m)


-- | Instances of the <a>HasBinary</a> class. This includes the standard
--   types (except of course for things like function types and IO) plus a
--   few others.
module Util.BinaryInstances

-- | This is a rather inelegant way of encoding a type with up to 5
--   alternatives. If 5 is too many, use () for the others, if too few use
--   <a>HasWrapper</a>. In fact <a>HasWrapper</a> is probably better
--   anyway.
data Choice5 v1 v2 v3 v4 v5
Choice1 :: v1 -> Choice5 v1 v2 v3 v4 v5
Choice2 :: v2 -> Choice5 v1 v2 v3 v4 v5
Choice3 :: v3 -> Choice5 v1 v2 v3 v4 v5
Choice4 :: v4 -> Choice5 v1 v2 v3 v4 v5
Choice5 :: v5 -> Choice5 v1 v2 v3 v4 v5

-- | A class allowing you to handle types with up to 256 alternatives. If
--   this all seems to complicated, look at the source file and the example
--   for the "Tree" data type.
class HasWrapper wrapper m
wraps :: HasWrapper wrapper m => [Wrap wrapper m]
unWrap :: HasWrapper wrapper m => wrapper -> UnWrap m

-- | Newtype alias you need to wrap around something which instances
--   <a>HasWrapper</a> to get an actual HasBinary instance. You will then
--   need something like this:
--   
--   <pre>
--   instance Monad m =&gt; HasBinary a m where
--     writeBin = mapWrite Wrapped
--     readBin = mapRead wrapped
--   </pre>
newtype Wrapped a
Wrapped :: a -> Wrapped a
wrapped :: Wrapped a -> a

-- | Value the <a>HasWrapper</a> instance generates from <a>unWrap</a> to
--   indicate how we should write some value to binary.
data UnWrap m
UnWrap :: Byte -> val -> UnWrap m

-- | <a>Wrap</a> value for constructor with no arguments.
wrap0 :: Monad m => Byte -> wrapper -> Wrap wrapper m

-- | <a>Wrap</a> value for constructor with 1 argument.
wrap1 :: HasBinary val m => Byte -> (val -> wrapper) -> Wrap wrapper m

-- | <a>Wrap</a> value for constructor with 2 arguments.
wrap2 :: HasBinary (val1, val2) m => Byte -> (val1 -> val2 -> wrapper) -> Wrap wrapper m

-- | <a>Wrap</a> value for constructor with 3 arguments.
wrap3 :: HasBinary (val1, val2, val3) m => Byte -> (val1 -> val2 -> val3 -> wrapper) -> Wrap wrapper m

-- | <a>Wrap</a> value for constructor with 4 arguments.
wrap4 :: HasBinary (val1, val2, val3, val4) m => Byte -> (val1 -> val2 -> val3 -> val4 -> wrapper) -> Wrap wrapper m

-- | Newtype alias for things we want to encode or decode via their
--   <a>Read</a> or <a>Show</a> <a>String</a> representation.
newtype ReadShow a
ReadShow :: a -> ReadShow a
newtype ViaEnum a
ViaEnum :: a -> ViaEnum a
enum :: ViaEnum a -> a

-- | This is an <tt>newtype</tt> alias for integral types where the user
--   promises that the value will be non-negative, and so saves us a bit.
--   This is what we use for character data incidentally, so that ASCII
--   characters with codes &lt;128 can be encoded (as themselves) in just
--   one byte.
newtype Unsigned integral
Unsigned :: integral -> Unsigned integral
instance [overlap ok] (Eq v1, Eq v2, Eq v3, Eq v4, Eq v5) => Eq (Choice5 v1 v2 v3 v4 v5)
instance [overlap ok] (Monad m, Enum a) => HasBinary (ViaEnum a) m
instance [overlap ok] (Read a, Show a, Monad m) => HasBinary (ReadShow a) m
instance [overlap ok] (Monad m, HasWrapper (Tree val) m) => HasBinary (Tree val) m
instance [overlap ok] (Monad m, HasBinary val m) => HasWrapper (Tree val) m
instance [overlap ok] (Monad m, HasWrapper wrapper m) => HasBinary (Wrapped wrapper) m
instance [overlap ok] (Monad m, HasBinary v1 m, HasBinary v2 m, HasBinary v3 m, HasBinary v4 m, HasBinary v5 m) => HasBinary (Choice5 v1 v2 v3 v4 v5) m
instance [overlap ok] Monad m => HasBinary CodedList m
instance [overlap ok] (Monad m, Integral integral, Bits integral) => HasBinary (Unsigned integral) m
instance [overlap ok] Monad m => HasBinary CSize m
instance [overlap ok] Monad m => HasBinary Integer m
instance [overlap ok] Monad m => HasBinary Word32 m
instance [overlap ok] Monad m => HasBinary Int32 m
instance [overlap ok] Monad m => HasBinary Word m
instance [overlap ok] Monad m => HasBinary Int m
instance [overlap ok] (Monad m, HasBinary a m) => HasBinary [a] m
instance [overlap ok] Monad m => HasBinary Char m
instance [overlap ok] Monad m => HasBinary Bool m
instance [overlap ok] (Monad m, HasBinary a m, HasBinary b m) => HasBinary (Either a b) m
instance [overlap ok] (Monad m, HasBinary a m) => HasBinary (Maybe a) m
instance [overlap ok] Monad m => HasBinary (Bytes, Int) m
instance [overlap ok] HasBinary Byte m
instance [overlap ok] (Monad m, HasBinary v1 m, HasBinary (v2, v3, v4, v5, v6, v7) m) => HasBinary (v1, v2, v3, v4, v5, v6, v7) m
instance [overlap ok] (Monad m, HasBinary v1 m, HasBinary (v2, v3, v4, v5, v6) m) => HasBinary (v1, v2, v3, v4, v5, v6) m
instance [overlap ok] (Monad m, HasBinary v1 m, HasBinary (v2, v3, v4, v5) m) => HasBinary (v1, v2, v3, v4, v5) m
instance [overlap ok] (Monad m, HasBinary v1 m, HasBinary (v2, v3, v4) m) => HasBinary (v1, v2, v3, v4) m
instance [overlap ok] (Monad m, HasBinary v1 m, HasBinary (v2, v3) m) => HasBinary (v1, v2, v3) m
instance [overlap ok] (Monad m, HasBinary v1 m, HasBinary v2 m) => HasBinary (v1, v2) m
instance [overlap ok] Monad m => HasBinary () m


-- | Integers augmented with Infinity.
module Util.IntPlus

-- | The Bool is a sign, with True meaning positive infinity.
data IntPlus
infinity :: IntPlus
instance Eq IntPlus
instance Num IntPlus
instance Show IntPlus
instance Ord IntPlus


-- | A simple reference counter
module Util.ReferenceCount
data RefCount
newRefCount :: IO RefCount
newLinkedRefCount :: IO RefCount
addRef :: RefCount -> IO ()
remRef :: RefCount -> IO Bool


-- | Module taken from Dean Harington's post to the Haskell mailing list on
--   Fri, 17 Aug 2001.
--   
--   URL is currently
--   <a>http://www.haskell.org/pipermail/haskell/2001-August/007712.html</a>
--   
--   This module provides <a>deepSeq</a> and <a>$!!</a> which correspond to
--   <a>seq</a> and <a>$!</a> except that they try to evaluate everything
--   in the argument. For example, if a list is provided, the whole list
--   must be evaluated.
--   
--   For purposes of Haddock, empty instance declarations with
--   <tt>where</tt> have had the <tt>where</tt> deleted.
module Util.DeepSeq
class DeepSeq a where deepSeq = seq
deepSeq :: DeepSeq a => a -> b -> b
($!!) :: DeepSeq a => (a -> b) -> a -> b
instance DeepSeq Double
instance DeepSeq Float
instance DeepSeq Int
instance DeepSeq Integer
instance DeepSeq Ordering
instance (DeepSeq a, DeepSeq b) => DeepSeq (Either a b)
instance DeepSeq a => DeepSeq (Maybe a)
instance DeepSeq Char
instance DeepSeq Bool
instance (DeepSeq a, DeepSeq b, DeepSeq c, DeepSeq d, DeepSeq e, DeepSeq f, DeepSeq g) => DeepSeq (a, b, c, d, e, f, g)
instance (DeepSeq a, DeepSeq b, DeepSeq c, DeepSeq d, DeepSeq e, DeepSeq f) => DeepSeq (a, b, c, d, e, f)
instance (DeepSeq a, DeepSeq b, DeepSeq c, DeepSeq d, DeepSeq e) => DeepSeq (a, b, c, d, e)
instance (DeepSeq a, DeepSeq b, DeepSeq c, DeepSeq d) => DeepSeq (a, b, c, d)
instance (DeepSeq a, DeepSeq b, DeepSeq c) => DeepSeq (a, b, c)
instance (DeepSeq a, DeepSeq b) => DeepSeq (a, b)
instance DeepSeq a => DeepSeq [a]
instance DeepSeq ()


-- | QuickReadShow is designed for the rapid manufacture of read/show
--   instances. To create such an instance you need to (a) instance
--   quickRead; (b) instance Read/Show using a particular template. (Before
--   April 2004 (b) was not part of the code; it now has to be added to
--   deal with tougher GHC restrictions on overlapping instances.)
module Util.QuickReadShow
data WrapRead toRead
WrapRead :: (read -> toRead) -> WrapRead toRead
class QuickRead toRead
quickRead :: QuickRead toRead => WrapRead toRead
qRead :: QuickRead toRead => Int -> String -> [(toRead, String)]
data WrapShow toShow
WrapShow :: (toShow -> show) -> WrapShow toShow
class QuickShow toShow
quickShow :: QuickShow toShow => WrapShow toShow
qShow :: QuickShow toShow => Int -> toShow -> String -> String


-- | Little functions connected with IO
module Util.IOExtras
catchEOF :: IO a -> IO (Maybe a)
catchAlreadyExists :: IO a -> IO (Maybe a)
catchDoesNotExist :: IO a -> IO (Maybe a)
catchErrorCalls :: IO a -> IO (Either ErrorCall a)
hGetLineR :: Read a => Handle -> IO a
simpleModifyIORef :: IORef a -> (a -> (a, b)) -> IO b


-- | The Cache module allows us to cache results of expensive stateful
--   computations in memory. Possible improvements - (1) use hashing
--   instead
module Util.Cache
data Ord key => Cache key elt
newCache :: Ord key => (key -> IO elt) -> IO (Cache key elt)
getCached :: Ord key => Cache key elt -> key -> IO elt


-- | The LineShow type is simply a list type except that it has Read and
--   Show instances which put the output line by line, preceded by the
--   number of lines. This is useful for data files stored by CVS and
--   similar systems.
module Util.LineShow
newtype LineShow a
LineShow :: [a] -> LineShow a
instance Read a => Read (LineShow a)
instance Show a => Show (LineShow a)


-- | This file differs from the Einar original (itself automatically
--   produced by decommenting an obsolete GHC source file, apparently) with
--   nearly all the functions removed.
module Util.Maybes
fromMaybes :: [Maybe a] -> Maybe [a]


-- | FileNames contain facilities for manipulating filenames in a hopefully
--   OS-independent manner.
module Util.FileNames
fileSep :: Char
topDir :: String
thisDir :: String
trimDir :: String -> String
splitName :: String -> (String, String)
combineNames :: String -> String -> String
breakName :: String -> [String]
unbreakName :: [String] -> String
splitExtension :: String -> Maybe (String, String)
unsplitExtension :: String -> String -> String
recordSep :: String


-- | Module which generates globally unique <a>ObjectID</a>s.
module Util.Object
newtype ObjectID
ObjectID :: Int -> ObjectID
class Object o
objectID :: Object o => o -> ObjectID
newObject :: IO ObjectID
staticObject :: Int -> ObjectID
newInt :: IO Int
instance Eq ObjectID
instance Ord ObjectID
instance Read ObjectID
instance Show ObjectID


-- | This module contains flags which control compilation.
module Util.CompileFlags
isDebug :: Bool
uniVersion :: String


-- | The WBFiles module is in charge of decoding information from the
--   command line and making it available to the rest of the UniForM
--   workbench.
--   
--   All UniForM options have names beginning with <a>--uni</a>. It is
--   hoped that this won't be a problem for programs that use the UniForM
--   workbench. However, if it is, the function setAlternateArgs should be
--   called before any of the functions in the UniForM workbench, as this
--   will prevent the program arguments being read by UniForM.
--   
--   The <tt> --uni </tt> option prints a help message, as do other options
--   beginning with --uni which are not understood.
--   
--   The <tt> --uni-parameters </tt> option prints the parameters at the
--   given position on the command line.
--   
--   The <tt> --uni-version </tt> option prints the current version of uni.
--   
--   <tt> --uni-<a>option-name</a>:<a>option-value</a> </tt> or
--   equivalently <tt> --uni-<a>option-name</a>=<a>option-value</a> </tt>
--   
--   All options can also be overridden by environment variables. The
--   environment variable corresponding to <a>option-name</a> has the name
--   <tt>UNI<a>OPTION-NAME</a></tt> where <tt><a>OPTION-NAME</a></tt> is
--   the capitalised name of the option.
--   
--   The default set of options are as follows:
--   
--   option-name explanation
--   
--   wish The filename of the wish program daVinci The filename of daVinci
--   gnuclient The filename of gnuclient editor A command to execute the
--   text editor. This uses the CommandStringSub format, with defined
--   substitutions %F =&gt; where the file is to be found and %N =&gt; what
--   the user-visible name (for example, of the buffer) should be. top The
--   directory in which UniForM is installed
--   
--   daVinciIcons The directory containing daVinci icons
--   
--   workingDir The directory used for temporary files.
--   
--   server The host name of the server user The user-id to use connecting
--   to the server password The password to use connecting to the server
--   port The port on the server to connect to xmlPort The port for the XML
--   server (which has a different default)
--   
--   debug Where Debug.debug messages should go
--   
--   serverDir Where Server stores its files serverId The unique identifier
--   of the server. Since this really does have to be globally unique, it
--   is by default constructed from a combination of the machine's hostname
--   and the server port. You had better not change it unless you know what
--   you are doing.
--   
--   MMiSSDTD Location of DTD file for MMiSS.
--   
--   hosts Location of hosts file.
--   
--   toolTimeOut Time-out waiting for responses from a tool when it starts
--   up and we are doing challenge-response verification. windowsTick
--   (Windows only) time in microseconds we wait between polling Wish.
--   
--   The options wish, daVinci, daVinciIcons, top should all be set
--   automatically by the configure procedure. The configure procedure
--   constructs a variable DEFAULTOPTIONS and writes it into the file
--   default_options.c.
--   
--   returns a string with exactly the same syntax as the command line so a
--   typical one might be <tt> --uni-wish:<i>usr</i>bin<i>wish
--   --uni-daVinci:</i>usr<i>bin</i>daVinci </tt> ... (and so on)
--   
--   However one difference is that options which are not understood in the
--   default_options string are simply ignored.
module Util.WBFiles
getWishPath :: IO String
getDaVinciPath :: IO String
getGnuClientPath :: IO String
getToolTimeOut :: IO Int
getTOP :: IO String

-- | Get a path within the top directory.
getTOPPath :: [String] -> IO String
getEditorString :: IO (Maybe String)
getMMiSSDTD :: IO (Maybe String)
getMMiSSAPIDTD :: IO (Maybe String)
getHosts :: IO String
getPort :: IO Int
getXMLPort :: IO Int
getCouplingPort :: IO Int
getWorkingDir :: IO String
getCouplingDir :: IO String
getDebugFileName :: IO String
getDaVinciIcons :: IO (Maybe String)
getServer :: IO (Maybe String)
getUser :: IO (Maybe String)
getPassword :: IO (Maybe String)
getServerFile :: String -> IO String
getServerDir :: IO String
getServerId :: IO (Maybe String)
getArgString :: String -> IO (Maybe String)
getArgBool :: String -> IO (Maybe Bool)
getArgInt :: String -> IO (Maybe Int)
parseArguments :: IO ()
parseArgumentsRequiring :: [String] -> IO ()
data ArgType
STRING :: ArgType
INT :: ArgType
BOOL :: ArgType
data ArgValue
StringValue :: String -> ArgValue
IntValue :: Int -> ArgValue
BoolValue :: Bool -> ArgValue
data ProgramArgument
ProgramArgument :: String -> String -> Maybe ArgValue -> ArgType -> ProgramArgument
optionName :: ProgramArgument -> String
optionHelp :: ProgramArgument -> String
defaultVal :: ProgramArgument -> Maybe ArgValue
argType :: ProgramArgument -> ArgType
usualProgramArguments :: [ProgramArgument]
parseTheseArguments :: [ProgramArgument] -> IO ()
parseTheseArgumentsRequiring :: [ProgramArgument] -> [String] -> IO ()
setAlternateArgs :: [String] -> IO ()


-- | AUTHOR : George Russell University of Bremen DATE : 2000 DESCRIPTION :
--   This module provides a uniform interface for debugging purposes. In
--   final versions of this module it would be best to make the debug
--   function do nothing and force it to be inlined.
--   
--   #
module Util.Debug

-- | show something to log file if debugging is turned on.
debug :: Show a => a -> IO ()

-- | If an action fails print out a message before propagating message.
debugAct :: String -> IO a -> IO a
(@:) :: String -> IO a -> IO a

-- | always show something to the log file
alwaysDebug :: Show a => a -> IO ()

-- | always print out a message if action fails.
alwaysDebugAct :: String -> IO a -> IO a

-- | Send a string to the debug file. This differs from debug, in that
--   debug will Haskell-escape the string and add a newline, while just
--   writes to the file with no interpretation.
debugString :: String -> IO ()
(@@:) :: String -> IO a -> IO a
wrapError :: String -> a -> a


module Util.Computation
type Answer a = Either SomeException a
done :: Monad m => m ()
(#) :: a -> (a -> b) -> b
propagate :: Answer a -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised than it will be propogated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
--   
--   Note that <a>System.IO.Error</a> also exports a function called
--   <a>try</a> with a similar type to <a>try</a>, except that it catches
--   only the IO and user families of exceptions (as required by the
--   Haskell 98 <tt>IO</tt> module).
try :: Exception e => IO a -> IO (Either e a)
tryUntilOK :: IO a -> IO a
raise :: IOError -> IO a

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()

-- | The reverse of <a>when</a>.
unless :: Monad m => Bool -> m () -> m ()
incase :: Maybe a -> (a -> IO b) -> IO ()

-- | <tt><a>forever</a> act</tt> repeats the action infinitely.
forever :: Monad m => m a -> m b
foreverUntil :: Monad m => m Bool -> m ()
foreach :: Monad m => [a] -> (a -> m b) -> m ()
while :: Monad m => m a -> (a -> Bool) -> m a
type Config w = w -> IO w
configure :: w -> [Config w] -> IO w
config :: IO () -> Config w
class HasConfig option configuration
($$) :: HasConfig option configuration => option -> configuration -> configuration
configUsed :: HasConfig option configuration => option -> configuration -> Bool
data WithError a
hasError :: String -> WithError a
hasValue :: a -> WithError a
fromWithError :: WithError a -> Either String a
fromWithError1 :: a -> WithError a -> a
toWithError :: Either String a -> WithError a
isError :: WithError a -> Bool
mapWithError :: (a -> b) -> WithError a -> WithError b
mapWithError' :: (a -> WithError b) -> WithError a -> WithError b
mapWithErrorIO :: (a -> IO b) -> WithError a -> IO (WithError b)
mapWithErrorIO' :: (a -> IO (WithError b)) -> WithError a -> IO (WithError b)
pairWithError :: WithError a -> WithError b -> WithError (a, b)
listWithError :: [WithError a] -> WithError [a]
coerceWithError :: WithError a -> a
coerceWithErrorIO :: WithError a -> IO a
coerceWithErrorStringIO :: String -> WithError a -> IO a

-- | coerce or use the supplied break function (to be used with
--   <a>addFallOut</a>)
--   
--   The first argument is prepended to any error message. The value is
--   evaluated immediately.
coerceWithErrorOrBreakIOPrefix :: String -> (String -> a) -> WithError a -> IO a

-- | coerce or use the supplied break function (to be used with
--   <a>addFallOut</a>)
--   
--   The first argument is prepended to any error message.
coerceWithErrorOrBreakPrefix :: String -> (String -> a) -> WithError a -> a
newtype MonadWithError m a
MonadWithError :: (m (WithError a)) -> MonadWithError m a
monadifyWithError :: Monad m => WithError a -> MonadWithError m a
toMonadWithError :: Monad m => m a -> MonadWithError m a

-- | coerce or use the supplied break function (to be used with
--   <a>addFallOut</a>)
coerceWithErrorOrBreak :: (String -> a) -> WithError a -> a

-- | coerce or use the supplied break function (to be used with
--   <a>addFallOut</a>) The value is evaluated immediately.
coerceWithErrorOrBreakIO :: (String -> a) -> WithError a -> IO a
concatWithError :: [WithError a] -> WithError [a]
swapIOWithError :: WithError (IO a) -> IO (WithError a)
exceptionToError :: Exception e => (e -> Maybe String) -> IO a -> IO (WithError a)
instance Monad m => Monad (MonadWithError m)
instance Monad WithError
instance Functor WithError


-- | We provide a format-string-like way of describing how to call
--   particular tools. Thus the input is (1) a particular format string (2)
--   a partial map from upper-case letters to strings; we call these
--   strings the _insert_ strings. We map the format string to an output
--   string in which combinations of the form %[upper-case-letter] in the
--   format string are replaced by the corresponding insert string; if no
--   such string exists this is an error.
--   
--   We also provide a mechanism for <a>escaping</a> the insert strings.
--   Specifically, there is a fixed partial map from lower-case letters to
--   functions :: String -&gt; String; these functions we call the
--   transformers. For a combination of the form
--   %[lower-case-letter-1]...[lower-case-letter-n][upper-case-letter] we
--   take the insert string corresponding to upper-case-letter, and then
--   pass it through the transformers corresponding to lower-case-letter-n,
--   and so on down to the transformer corresponding to
--   lower-case-letter-1.
--   
--   Instead of [upper-case-letter] we may also write <a>%</a> in which
--   case the insert string is just <a>%</a>; thus <a>%%</a> transforms to
--   <a>%</a>.
--   
--   Sections of the input string not containing % are left untouched.
--   
--   Defined transformers with their corresponding letters: b transformer
--   suitable for escaping bash strings quoted with <a>. e transformer
--   suitable for escaping emacs lisp strings quoted with </a>. None of
--   these transformers insert the closing or end quotes, allowing you to
--   use them in the middle of strings.
--   
--   Other transformers will be added as the need arises.
module Util.CommandStringSub
data CompiledFormatString
compileFormatString :: String -> WithError CompiledFormatString
runFormatString :: CompiledFormatString -> (Char -> Maybe String) -> WithError String
doFormatString :: String -> (Char -> Maybe String) -> String
emacsEscape :: String -> String
bashEscape :: String -> String


-- | Delayers handle delaying of actions; the main purpose is to delay
--   graph redrawing actions during complex updates.
module Util.Delayer
data Delayer
newDelayer :: IO Delayer
class HasDelayer object
toDelayer :: HasDelayer object => object -> Delayer

-- | carry out the given action preventing the Delayer from doing anything.
delay :: HasDelayer object => object -> IO a -> IO a
data DelayedAction
newDelayedAction :: IO () -> IO DelayedAction
delayedAct :: Delayer -> DelayedAction -> IO ()

-- | If this DelayedAction is queued, remove it from the queue.
cancelDelayedAct :: Delayer -> DelayedAction -> IO ()

-- | Instances of HasAddDelayer are event sources to which you can attach a
--   delayer, to indicate you are currently not interested in events.
class HasAddDelayer eventSource
addDelayer :: HasAddDelayer eventSource => Delayer -> eventSource -> eventSource

-- | Like HasAddDelayer, but allows an IO action.
class HasAddDelayerIO eventSource
addDelayerIO :: HasAddDelayerIO eventSource => Delayer -> eventSource -> IO eventSource
instance HasDelayer Delayer
instance Ord DelayedAction
instance Eq DelayedAction


-- | This module contains functions for converting to and from the UTF8
--   representations for Strings.
module Util.UTF8

-- | Converts a String into its UTF8 representation.
toUTF8 :: Enum byte => String -> [byte]

-- | Converts a UTF8 representation of a String back into the String,
--   catching all possible format errors.
--   
--   Example: With the Haskell module Control.Monad.Error, you can instance
--   this as (fromUTF8WE :: String -&gt; Either String String) to get a
--   conversion function which either succeeds (Right) or returns an error
--   message (Left).
fromUTF8WE :: (Enum byte, Monad m) => [byte] -> m String


-- | A wrapper for the new GHC (and Hugs) Dynamic module. The main
--   improvement over the original Dynamic module is that we provide
--   flavours of TypeableXXXX for kinds with arguments other than *, a
--   feature used by <a>DisplayView</a>.
module Util.Dynamics

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable a
typeOf :: Typeable a => a -> TypeRep

-- | A concrete representation of a (monomorphic) type. <a>TypeRep</a>
--   supports reasonably efficient equality.
data TypeRep :: *
type Dyn = Dynamic
toDyn :: Typeable a => a -> Dyn
fromDynamic :: Typeable a => Dyn -> Maybe a

-- | Like <a>fromDynamic</a> but provides an error message indicating what
--   types are getting confused.
fromDynamicWE :: Typeable a => Dyn -> WithError a
coerce :: Typeable a => Dyn -> a
coerceIO :: Typeable a => Dyn -> IO a
typeMismatch :: IOError
dynCast :: (Typeable a, Typeable b) => String -> a -> b
dynCastOpt :: (Typeable a, Typeable b) => a -> Maybe b

-- | Construct a TypeRep for a type or type constructor with no arguments.
--   The first string should be the module name, the second that of the
--   type.
mkTypeRep :: String -> String -> TypeRep
class Typeable1_1 ty
typeOf1_1 :: (Typeable1_1 ty, Typeable1 typeArg) => ty typeArg -> TypeRep
class Typeable2_11 ty
typeOf2_11 :: (Typeable2_11 ty, Typeable1 typeArg1, Typeable1 typeArg2) => ty typeArg1 typeArg2 -> TypeRep
class Typeable3_111 ty
typeOf3_111 :: (Typeable3_111 ty, Typeable1 typeArg1, Typeable1 typeArg2, Typeable1 typeArg3) => ty typeArg1 typeArg2 typeArg3 -> TypeRep
class Typeable4_0111 ty
typeOf4_0111 :: (Typeable4_0111 ty, Typeable ty1, Typeable1 typeArg1, Typeable1 typeArg2, Typeable1 typeArg3) => ty ty1 typeArg1 typeArg2 typeArg3 -> TypeRep
class Typeable5_00111 ty
typeOf5_00111 :: (Typeable5_00111 ty, Typeable ty1, Typeable ty2, Typeable1 typeArg1, Typeable1 typeArg2, Typeable1 typeArg3) => ty ty1 ty2 typeArg1 typeArg2 typeArg3 -> TypeRep
class Typeable6_000111 ty
typeOf6_000111 :: (Typeable6_000111 ty, Typeable ty1, Typeable ty2, Typeable ty3, Typeable1 typeArg1, Typeable1 typeArg2, Typeable1 typeArg3) => ty ty1 ty2 ty3 typeArg1 typeArg2 typeArg3 -> TypeRep
instance (Typeable6_000111 ty, Typeable ty1) => Typeable5_00111 (ty ty1)
instance (Typeable5_00111 ty, Typeable ty1) => Typeable4_0111 (ty ty1)
instance (Typeable4_0111 ty, Typeable ty1) => Typeable3_111 (ty ty1)
instance (Typeable3_111 ty, Typeable1 typeArg1) => Typeable2_11 (ty typeArg1)
instance (Typeable2_11 ty, Typeable1 typeArg1) => Typeable1_1 (ty typeArg1)
instance (Typeable1_1 ty, Typeable1 typeArg) => Typeable (ty typeArg)


-- | Basic string-manipulation and other functions they forgot to put in
--   the standard prelude.
module Util.ExtendedPrelude

-- | Remove trailing spaces (We try to avoid reconstructing the string, on
--   the assumption that there aren't often spaces)
trimTrailing :: String -> String

-- | Remove leading spaces
trimLeading :: String -> String

-- | Remove trailing and leading spaces
trimSpaces :: String -> String

-- | Pad a string if necessary to the given length with leading spaces.
padToLength :: Int -> String -> String

-- | The <a>.</a> operator lifted to monads. So like ., the arguments are
--   given in the reverse order to that in which they should be executed.
monadDot :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
simpleSplit :: (a -> Bool) -> [a] -> [[a]]
findJust :: (a -> Maybe b) -> [a] -> Maybe b
insertOrdLt :: Ord a => a -> [a] -> [a]
insertOrdGt :: Ord a => a -> [a] -> [a]
insertOrd :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | insertOrdAlternate is similar to insertOrd except (1) it takes an
--   Ordering argument; (2) if it finds an argument that matches, it
--   applies the given function to generate a new element, rather than
--   inserting another. The new generated element should be EQ to the old
--   one.
insertOrdAlternate :: (a -> a -> Ordering) -> a -> (a -> a) -> [a] -> [a]
bottom :: a

-- | returns Just a if we can read a, and the rest is just spaces.
readCheck :: Read a => String -> Maybe a
chop :: Int -> [a] -> Maybe [a]
pairList :: a -> [b] -> [(a, b)]
lastOpt :: [a] -> Maybe a

-- | returns remainder if the first list is a prefix of the second one.
isPrefix :: Eq a => [a] -> [a] -> Maybe [a]
class HasCoMapIO option
coMapIO :: HasCoMapIO option => (a -> IO b) -> option b -> option a
class HasMapIO option
mapIO :: HasMapIO option => (a -> IO b) -> option a -> option b
class HasMapMonadic h
mapMonadic :: (HasMapMonadic h, Monad m) => (a -> m b) -> h a -> m (h b)
mapPartialM :: Monad m => (a -> m (Maybe b)) -> [a] -> m [b]
splitByChar :: Char -> String -> [String]
unsplitByChar :: Char -> [String] -> String
unsplitByChar0 :: Char -> [String] -> String

-- | We split at the first occurrence of the character, returning the
--   string before and after.
splitToChar :: Char -> String -> Maybe (String, String)
splitToElem :: (a -> Bool) -> [a] -> Maybe ([a], [a])
splitToElemGeneral :: (a -> Bool) -> [a] -> Maybe ([a], a, [a])
deleteFirst :: (a -> Bool) -> [a] -> [a]
deleteFirstOpt :: (a -> Bool) -> [a] -> [a]
deleteAndFindFirst :: (a -> Bool) -> [a] -> (a, [a])
deleteAndFindFirstOpt :: (a -> Bool) -> [a] -> Maybe (a, [a])
divideList :: (a -> Either b c) -> [a] -> ([b], [c])

-- | node is the tree's node type. state is folded through every node of
--   the tree (and is the result). We search the tree in depth-first order,
--   applying visitNode at each node to update the state. The ancestorInfo
--   information comes from the ancestors of the node. EG if we are
--   visiting node N1 which came from N2 the ancestorInfo given to
--   visitNode for N1 will be that computed from visitNode for N2. For the
--   root node, it will be initialAncestor
treeFold :: (ancestorInfo -> state -> node -> (ancestorInfo, state, [node])) -> ancestorInfo -> state -> node -> state

-- | Like treeFold, but using monads.
treeFoldM :: Monad m => (ancestorInfo -> state -> node -> m (ancestorInfo, state, [node])) -> ancestorInfo -> state -> node -> m state

-- | Produce an equality function for b
mapEq :: Eq a => (b -> a) -> (b -> b -> Bool)

-- | Produce a compare function for b
mapOrd :: Ord a => (b -> a) -> (b -> b -> Ordering)

-- | A function indicating we want to escape from the current computation.
type BreakFn = forall other. String -> other

-- | Intended use, EG addFallOut ( break -&gt; do -- blah blah (normal IO a
--   stuff) -- when (break condition) (break <a>You can't do that there
--   ere</a>) -- more blah blah, not executed if there's an break -- return
--   (value of type a) )
addFallOut :: (BreakFn -> IO a) -> IO (Either String a)

-- | Like addFallOut, but returns a WithError object instead.
addFallOutWE :: (BreakFn -> IO a) -> IO (WithError a)
addSimpleFallOut :: IO a -> IO (Either String a)
simpleFallOut :: BreakFn
mkBreakFn :: ObjectID -> BreakFn
newFallOut :: IO (ObjectID, IO a -> IO (Either String a))
isOurFallOut :: ObjectID -> Dyn -> Maybe String
addGeneralFallOut :: Typeable a => IO (GeneralBreakFn a, GeneralCatchFn a)
data GeneralBreakFn a
GeneralBreakFn :: (forall b. a -> b) -> GeneralBreakFn a
data GeneralCatchFn a
GeneralCatchFn :: (forall c. IO c -> IO (Either a c)) -> GeneralCatchFn a
catchOurExceps :: IO a -> IO (Either String a)
catchAllExceps :: IO a -> IO (Either String a)
errorOurExceps :: IO a -> IO a
ourExcepToMess :: Dyn -> Maybe String
breakOtherExceps :: BreakFn -> IO a -> IO a
showException2 :: Dyn -> String
class EqIO v
eqIO :: EqIO v => v -> v -> IO Bool
class EqIO v => OrdIO v
compareIO :: OrdIO v => v -> v -> IO Ordering

-- | indicates that an Ord or Eq instance really does need to take
--   everything into account.
newtype Full a
Full :: a -> Full a

-- | Remove duplicate elements from a list.
uniqOrd :: Ord a => [a] -> [a]

-- | Like uniqOrd, except that we specify the output order of the list. The
--   resulting list is that obtained by deleting all duplicate elements in
--   the list, except the first, for example [1,2,3,2,1,4] will go to
--   [1,2,3,4].
uniqOrdOrder :: Ord a => [a] -> [a]

-- | Remove duplicate elements from a list where the key function is
--   supplied.
uniqOrdByKey :: Ord b => (a -> b) -> [a] -> [a]

-- | Remove duplicate elements from a list where the key function is
--   supplied. The list order is preserved and of the duplicates, it is the
--   first in the list which is not deleted.
uniqOrdByKeyOrder :: Ord b => (a -> b) -> [a] -> [a]

-- | Return Just True if all the elements give True, Just False if all
--   False, Nothing otherwise (or list is empty).
allSame :: (a -> Bool) -> [a] -> Maybe Bool

-- | If all the elements are equal, return True
allEq :: Eq a => [a] -> Bool

-- | If there are two elements of the list with the same (a), return one,
--   otherwise Nothing.
findDuplicate :: Ord a => (b -> a) -> [b] -> Maybe b

-- | A merge function for combining an input list with some new data, where
--   both are pre-sorted.
generalisedMerge :: Monad m => [a] -> [b] -> (a -> b -> Ordering) -> (Maybe a -> Maybe b -> m (Maybe a, Maybe c)) -> m ([a], [c])
instance Typeable FallOutExcep
instance Typeable1 GeneralFallOutExcep
instance HasMapMonadic []


-- | Implementation of the Myers algorithm, from <a>An O(ND) Difference
--   Algorithm and Its Variations</a>, by Eugene Myers page 6 (figure 2).
--   
--   Specification: if
--   
--   f1 (InBoth v) = Just v f1 (InFirst v) = Just v f1 (InSecond v) =
--   Nothing
--   
--   and
--   
--   f2 (InBoth v) = Just v f2 (InFirst v) = Nothing f2 (InSecond v) = Just
--   v
--   
--   then
--   
--   mapPartial f1 (diff l1 l2) == l1
--   
--   and
--   
--   mapPartial f2 (diff l1 l2) == l2
module Util.Myers
diff :: Eq a => [a] -> [a] -> [DiffElement a]
diff2 :: Eq v => [v] -> [v] -> [DiffElement v]
data DiffElement v
InBoth :: [v] -> DiffElement v
InFirst :: [v] -> DiffElement v
InSecond :: [v] -> DiffElement v
instance Show v => Show (DiffElement v)


-- | Union-Find algorithm.
module Util.UnionFind
data UnionFind a
newElement :: a -> IO (UnionFind a)
toValue :: UnionFind a -> a
union :: UnionFind a -> UnionFind a -> IO ()
isSame :: UnionFind a -> UnionFind a -> IO Bool
sameElements :: UnionFind a -> IO [UnionFind a]
instance Eq (UnionFind a)


-- | This module contains various extra Binary instances, for example ones
--   which are particular GHC or uni-specific.
module Util.BinaryExtras

-- | Read something, but throw an exception if there is an attempt to read
--   too many characters.
hReadLtd :: HasBinary a IO => Int -> Handle -> IO (WithError a)

-- | Time this code was written. We bung this definition in here because
--   this module needs GHC-specific access to ClockTime anyway.
initialClockTime :: ClockTime
instance Monad m => HasBinary ClockTime m


-- | Module which includes all the Binary stuff.
module Util.BinaryAll


-- | This module contains the hooks for displaying messages to the user
--   (errors, alerts, warnings and the like) and getting yes/no responses.
--   
--   The idea is that these are by default textual, and go via
--   <a>stdin</a>, <a>stdout</a> and <a>stderr</a> . However if the
--   DialogWin function <tt>useHTk</tt> is invoked, windows will pop up.
module Util.Messages

-- | Display an alert
alertMess :: String -> IO ()

-- | Display an error
errorMess :: String -> IO ()

-- | Display a warning message
warningMess :: String -> IO ()

-- | Confirm something with the user.
confirmMess :: String -> IO Bool

-- | Display some informational message.
messageMess :: String -> IO ()

-- | If True, indicates that the flag corresponding to a graphical mode has
--   been set. This is used occasionally for deciding whether to ask the
--   user something on stdout, stdin or via a window.
htkPresent :: IO Bool

-- | queries the user on stdout getting the answer from stdin. Leading and
--   trailing spaces are trimmed from the result.
textQuery :: String -> IO String

-- | Display a series of one-line messages, separated by newline
--   characters, attempting to combine them together and eliminate
--   duplicates as much as possible. If other identical messages come in
--   while the error message is being delayed, we throw them away.
errorMess2 :: String -> IO ()
data MessFns
MessFns :: (String -> IO ()) -> (String -> IO ()) -> (String -> IO ()) -> (String -> IO Bool) -> (String -> IO ()) -> Bool -> MessFns
alertFn :: MessFns -> String -> IO ()
errorFn :: MessFns -> String -> IO ()
warningFn :: MessFns -> String -> IO ()
confirmFn :: MessFns -> String -> IO Bool
messageFn :: MessFns -> String -> IO ()
htkPres :: MessFns -> Bool
setMessFns :: MessFns -> IO ()


-- | This module implements displaying ClockTime as a String which does NOT
--   depend on the time-zone.
module Util.ClockTimeToString

-- | Convert a ClockTime to a String. This has the format &lt;optional
--   sign&gt;&lt;digits&gt;+&lt;digits&gt; where the digits encode two
--   integers N1 and N2 (in order) representing the time elapsed since
--   00:00:00 UTC on 1 Jan 1970. This will be N1 + (N2 / 10^12) seconds.
--   0&lt;=N2&lt;10^12.
clockTimeToString :: ClockTime -> String

-- | Convert a validly formatted String to a ClockTime.
stringToClockTime :: String -> ClockTime


-- | AtomString atomises strings. Right now this code is not very efficient
--   but it shouldn't be too hard to improve.
--   
--   This code includes no less that 3 uses of unsafePerformIO. Oh well.
module Util.AtomString
data AtomString
firstAtomString :: AtomString
class StringClass stringClass where fromString s = coerceWithError (fromStringWE s) fromStringWE s = hasValue (fromString s)
toString :: StringClass stringClass => stringClass -> String
fromString :: StringClass stringClass => String -> stringClass
fromStringWE :: StringClass stringClass => String -> WithError stringClass
fromStringWEHacked :: (StringClass stringClass, DeepSeq stringClass) => String -> IO (WithError stringClass)
fromStringError :: String -> a
newtype Str a
Str :: a -> Str a
mkFromStringWE :: Parser stringClass -> String -> (String -> WithError stringClass)
instance [overlap ok] Typeable AtomString
instance [overlap ok] Typeable FromStringExcep
instance [overlap ok] Ord AtomString
instance [overlap ok] Eq AtomString
instance [overlap ok] (Monad m, StringClass a) => HasBinary (Str a) m
instance [overlap ok] StringClass stringClass => QuickShow stringClass
instance [overlap ok] StringClass stringClass => QuickRead stringClass
instance [overlap ok] StringClass AtomString


-- | This module generates short non-empty unique printable strings (IE
--   without funny characters). Quotes and backslashes are not included, so
--   printing should not be too hard. Periods are also not included, for
--   the benefit of NewNames.hs.
module Util.UniqueString
data UniqueStringSource
newUniqueStringSource :: IO UniqueStringSource
newUniqueString :: UniqueStringSource -> IO String
maxUniqueStringSources :: [UniqueStringSource] -> IO UniqueStringSource
data UniqueStringCounter
firstUniqueStringCounter :: UniqueStringCounter
stepUniqueStringCounter :: UniqueStringCounter -> (String, UniqueStringCounter)

-- | readUniqueStringSource is used by types/CodedValue.hs to export
--   values.
readUniqueStringSource :: UniqueStringSource -> IO [Int]

-- | createUniqueStringSource is the inverse of readUniqueStringSource.
createUniqueStringSource :: [Int] -> IO UniqueStringSource

-- | Create non-conflicting string which cannot be produced by
--   newUniqueString. This is useful for exceptional cases. We add this by
--   adding a character with integer value 0 at the end.
newNonUnique :: String -> String
firstUniqueString :: String
instance Typeable UniqueStringSource
instance Ord UniqueStringCounter
instance Eq UniqueStringCounter


-- | This module provides immutable CStrings, which additionally have the
--   property that they are automatically freed when the garbage-collector
--   forgets about them.
module Util.ICStringLen
data ICStringLen
newtype UTF8 bytes
UTF8 :: bytes -> UTF8 bytes

-- | Converts a String into its UTF8 representation.
toUTF8 :: Enum byte => String -> [byte]

-- | Converts a UTF8 representation of a String back into the String,
--   catching all possible format errors.
--   
--   Example: With the Haskell module Control.Monad.Error, you can instance
--   this as (fromUTF8WE :: String -&gt; Either String String) to get a
--   conversion function which either succeeds (Right) or returns an error
--   message (Left).
fromUTF8WE :: (Enum byte, Monad m) => [byte] -> m String
mkICStringLen :: Int -> (CString -> IO ()) -> IO ICStringLen
mkICStringLenExtra :: Int -> (CString -> IO extra) -> IO (ICStringLen, extra)
withICStringLen :: ICStringLen -> (Int -> CString -> IO a) -> IO a
bytesToICStringLen :: (Bytes, Int) -> IO ICStringLen
bytesFromICStringLen :: ICStringLen -> (Bytes, Int)
touchICStringLen :: ICStringLen -> IO ()
readICStringLen :: HasBinary a StateBinArea => ICStringLen -> IO a
writeToICStringLen :: HasBinary a StateBinArea => a -> IO ICStringLen
instance Typeable ICStringLen
instance MonadIO m => HasBinary ICStringLen m
instance Eq ICStringLen
instance EqIO ICStringLen
instance OrdIO ICStringLen
instance Show ICStringLen
instance StringClass (UTF8 ICStringLen)
instance StringClass ICStringLen


-- | Basic Thread operations.
module Util.Thread

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
--   
--   <i>Note</i>: Hugs does not provide any operations on other threads; it
--   defines <a>ThreadId</a> as a synonym for ().
data ThreadId :: *
hashThreadId :: ThreadId -> Int32
forkIODebug :: IO () -> IO ThreadId
forkIOquiet :: String -> IO () -> IO ThreadId
goesQuietly :: IO () -> IO ()
type Duration = Int
mins :: Double -> Duration
secs :: Double -> Duration
msecs :: Double -> Duration
usecs :: Double -> Duration
delay :: Duration -> IO ()
after :: Duration -> IO a -> IO a
every :: Duration -> IO a -> IO ()
mapMConcurrent :: (a -> IO b) -> [a] -> IO [b]
mapMConcurrent_ :: (a -> IO ()) -> [a] -> IO ()
mapMConcurrentExcep :: (a -> IO b) -> [a] -> IO [b]


-- | This module implements per-thread variables
module Util.ThreadDict
data ThreadDict a
newThreadDict :: IO (ThreadDict a)
writeThreadDict :: ThreadDict a -> a -> IO ()
readThreadDict :: ThreadDict a -> IO (Maybe a)
modifyThreadDict :: ThreadDict a -> (Maybe a -> IO (Maybe a, b)) -> IO b


-- | A TSem is an unusual sort of lock in that it only protects the same
--   thread from acquiring it twice. Different threads may acquire the same
--   TSem without problems.
--   
--   The purpose of this is to allow computations which potentially would
--   loop forever by calling themselves to instead fail gracefully. To aid
--   in this process, we also include in each TSem a String. When we
--   attempt to acquire a TSem which is already acquired, we instead return
--   the String for this TSem and the TSems acquired within this one.
module Util.TSem
data TSem
newTSem :: IO String -> IO TSem
synchronizeTSem :: TSem -> IO a -> IO (Either [String] a)


-- | A Registry is a mapping from ordered values. For the Registry type
--   itself, all target values have the same type. For the UntypedRegistry
--   type, the values can have any Typeable type.
module Util.Registry
data Ord from => Registry from to
type UntypedRegistry from = Untyped Registry from
data LockedRegistry from to
type UntypedLockedRegistry from = Untyped LockedRegistry from
data Untyped registry from
data Unsafe registry from
type UnsafeRegistry from = Unsafe Registry from
class NewRegistry registry
newRegistry :: NewRegistry registry => IO registry
emptyRegistry :: NewRegistry registry => registry -> IO ()
class GetSetRegistry registry from to where getValueOpt registry from = transformValue registry from (\ valueOpt -> return (valueOpt, valueOpt)) getValue registry from = do { valueOpt <- getValueOpt registry from; case valueOpt of { Nothing -> error "Registry.getValue  - value undefined" Just value -> return value } } setValue registry from to = transformValue registry from (\ _ -> return (Just to, ()))
transformValue :: GetSetRegistry registry from to => registry -> from -> (Maybe to -> IO (Maybe to, extra)) -> IO extra
getValueOpt :: GetSetRegistry registry from to => registry -> from -> IO (Maybe to)
getValue :: GetSetRegistry registry from to => registry -> from -> IO to
setValue :: GetSetRegistry registry from to => registry -> from -> to -> IO ()
class GetSetRegistryDyn registry from
setValueAsDyn :: GetSetRegistryDyn registry from => registry -> from -> Dyn -> IO ()
getValueAsDyn :: GetSetRegistryDyn registry from => registry -> from -> IO Dyn
class KeyOpsRegistry registry from where deleteFromRegistry registry from = do { deleteFromRegistryBool registry from; return () }
deleteFromRegistryBool :: KeyOpsRegistry registry from => registry -> from -> IO Bool
deleteFromRegistry :: KeyOpsRegistry registry from => registry -> from -> IO ()
listKeys :: KeyOpsRegistry registry from => registry -> IO [from]

-- | ListRegistryContents will not be implemented for the untyped
--   registries.
class ListRegistryContents registry from to
listRegistryContents :: ListRegistryContents registry from to => registry from to -> IO [(from, to)]
listRegistryContentsAndEmptyRegistry :: ListRegistryContents registry from to => registry from to -> IO [(from, to)]
listToNewRegistry :: ListRegistryContents registry from to => [(from, to)] -> IO (registry from to)

-- | look up the element given by the first key, and if it exists delete
--   it, replacing it with the element given by the second key.
changeKey :: Ord from => Registry from to -> from -> from -> IO ()
getRegistryValue :: Ord from => Registry from to -> from -> IO to
getValueDefault :: GetSetRegistry registry from to => to -> registry -> from -> IO to
lockedRegistryCheck :: IO a -> IO (Either String a)
getValue' :: GetSetRegistry registry from to => String -> registry -> from -> IO to
getValueSafe :: GetSetRegistry registry from to => String -> registry -> from -> IO to
getRegistryValueSafe :: Ord from => String -> Registry from to -> from -> IO to
instance Typeable2 Registry
instance Typeable2 LockedRegistry
instance (HasBinary (from, to) m, Ord from, MonadIO m) => HasBinary (Registry from to) m
instance Ord from => KeyOpsRegistry (LockedRegistry from to) from
instance Ord from => GetSetRegistry (LockedRegistry from to) from to
instance Ord from => NewRegistry (LockedRegistry from to)
instance KeyOpsRegistry (registry from Obj) from => KeyOpsRegistry (Unsafe registry from) from
instance GetSetRegistry (registry from Obj) from Obj => GetSetRegistry (Unsafe registry from) from to
instance NewRegistry (registry from Obj) => NewRegistry (Unsafe registry from)
instance GetSetRegistry (registry from Dyn) from Dyn => GetSetRegistryDyn (Untyped registry from) from
instance KeyOpsRegistry (registry from Dyn) from => KeyOpsRegistry (Untyped registry from) from
instance (Typeable to, GetSetRegistry (registry from Dyn) from Dyn) => GetSetRegistry (Untyped registry from) from to
instance NewRegistry (registry from Dyn) => NewRegistry (Untyped registry from)
instance Ord from => ListRegistryContents Registry from to
instance Ord from => KeyOpsRegistry (Registry from to) from
instance Ord from => GetSetRegistry (Registry from to) from to
instance Ord from => NewRegistry (Registry from to)


-- | UniqueFile is used for allocating names for temporary files in a
--   directory. To avoid large numbers of files in the same directory, we
--   create sub- directories where necessary.
module Util.UniqueFile
data UniqueFileCounter
initialUniqueFileCounter :: UniqueFileCounter
stepUniqueFileCounter :: UniqueFileCounter -> (String, UniqueFileCounter)
data UniqueFileStore
newUniqueFileStore :: FilePath -> (FilePath -> IO ()) -> IO UniqueFileStore
ensureDirectories :: UniqueFileStore -> String -> IO ()
getFilePath :: UniqueFileStore -> String -> FilePath
instance Show UniqueFileCounter
instance Read UniqueFileCounter


-- | The TempFile module allocates temporary files
module Util.TempFile
newTempFile :: IO FilePath


-- | Module for generating unique names which correspond to given names (of
--   type ref).
module Util.NameMangle

-- | For now we just do this naively, with a Registry. Since the names are
--   generated sequentially a dynamic array would be more efficient,
--   perhaps.
data NameMangler ref
newNameMangler :: IO (NameMangler ref)
type MangledName = String
newMangledName :: NameMangler ref -> ref -> IO MangledName
readMangledName :: NameMangler ref -> MangledName -> IO ref


-- | This is an implementation of queues inspired by the paper in Software
--   Practice &amp; Experience, ... The queue is divided into two
--   sequences. The first sequence holds the elements in a LIFO order, the
--   second in a FIFO order. The LIFO sequence is the one where elements
--   are added, the FIFO the one from which elements are removed. When the
--   remove operation is called and the FIFO sequence is empty, the LIFO
--   sequence is turned into a FIFO sequence by reversing the order of its
--   elements.
--   
--   Note from GER - as far as I know, we only need the values emptyQ ::
--   Queue a -- new empty queue singletonQ :: a -&gt; Queue a -- new
--   singleton queue insertQ :: Queue a -&gt; a -&gt; Queue a -- add to
--   queue removeQ :: Queue a -&gt; Maybe (a,Queue a) -- pop from queue.
--   insertAtEndQ :: Queue a -&gt; a -&gt; Queue a -- undo the effect of
--   the previous removeQ. isEmptyQ :: Queue a -&gt; Bool queueToList ::
--   Queue a -&gt; [a]
module Util.Queue
data Queue a
emptyQ :: Queue a
singletonQ :: a -> Queue a
isEmptyQ :: Queue a -> Bool
insertQ :: Queue a -> a -> Queue a
removeQ :: Queue a -> Maybe (a, Queue a)
insertAtEndQ :: Queue a -> a -> Queue a

-- | Converts a list to a queue with the first element of the list the
--   first element of the queue.
listToQueue :: [a] -> Queue a

-- | Inverts listToQueue
queueToList :: Queue a -> [a]
instance Functor Queue
instance Eq a => Eq (Queue a)


-- | | Implements locks which can be locked <a>globally</a> or
--   <a>locally</a>. A global lock prevents any other lock; a local lock
--   allows other local locks.
--   
--   There are some subtle decisions to be made about when to give
--   preference to local, and when to global, locks. There are two
--   important cases: (1) When we free a global lock, and there is another
--   queued global lock, we take that global lock (or the earliest for
--   which someone is waiting, if there's a choice), irrespective of
--   whether anyone is waiting for a local lock. (2) When at least one
--   local lock is held, we allow people to acquire further local locks,
--   even if there are queued global locks.
--   
--   A bad consequence of (2) is that a global lock can be indefinitely not
--   satisfied by a carefully-timed sequence of finite local locks:
--   
--   local locks : --- --- --- --- . . . --- --- --- . . . no global lock
--   can be acquired at all.
--   
--   However the alternative, of not permitting any fresh local locks when
--   a global lock is queued, is worse (in my opinion), since if a thread
--   attempts to acquire two local locks, one inside the other, and another
--   attempts to acquire a global lock, the whole thing can deadlock.
--   
--   Thread 1 : acquire local lock attempt to acquire second local lock
--   =&gt; DEADLOCK. Thread 2 : wait for global lock
--   
--   We could deal with this partially by allowing local locks for free to
--   a thread which already holds one, but this is more complicated and I
--   suspect theoretically dodgy.
--   
--   A consequence of this decision is that threads should avoid creating
--   automated repeated sequences of local locks on the same VSem.
module Util.VSem

-- | A lock which can be globally or locally locked. At any time, a
--   <tt>VSem</tt> is either globally locked once, or locally locked zero
--   or more times. Global locks always take priority over local locks.
data VSem

-- | Creates a <a>VSem</a>.
newVSem :: IO VSem

-- | Perform an action while locking a <a>VSem</a> locally.
synchronizeLocal :: VSem -> IO b -> IO b

-- | Perform an action while locking a <a>VSem</a> globally.
synchronizeGlobal :: VSem -> IO b -> IO b

-- | Acquire a local lock on a <a>VSem</a>
acquireLocal :: VSem -> IO ()

-- | Release a local lock on a <a>VSem</a>
releaseLocal :: VSem -> IO ()


-- | Very primitive concurrency, this implements a sink, which passes
--   messages along until the receiver is no longer interested.
module Util.Sink

-- | The HasInvalidate class represents information sources which can be
--   told "No more, I'm not interested."
class HasInvalidate source
invalidate :: HasInvalidate source => source -> IO ()
data SinkID
newSinkID :: IO SinkID
data Sink x

-- | Creates a new sink with its own SinkID
newSink :: (x -> IO ()) -> IO (Sink x)

-- | Creates a new sink with a given SinkID. This allows us to invalidate
--   lots of sinks just by invalidating one sinkID.
newSinkGeneral :: SinkID -> (x -> IO ()) -> IO (Sink x)

-- | Creates a new sink which executes actions in a parallelExec thread.
newParallelSink :: (x -> IO ()) -> IO (Sink x)

-- | Creates a new sink which executes actions in a parallelExec thread,
--   but allow the function generating these actions to be specified later,
--   via the returned command.
newParallelDelayedSink :: IO (Sink x, (x -> IO ()) -> IO ())

-- | Put a value into the sink, returning False if the sink id has been
--   invalidated.
putSink :: Sink x -> x -> IO Bool

-- | Put a list of values into the sink, returning False if the sink id has
--   been invalidated
putSinkMultiple :: Sink x -> [x] -> IO Bool

-- | Convert a sink from one type to another
coMapSink :: (y -> x) -> Sink x -> Sink y

-- | Another version which allows a transformation function to filter
--   certain elements
coMapSink' :: (y -> Maybe x) -> Sink x -> Sink y

-- | A version which allows an IO action, which had better not take too
--   long.
coMapIOSink' :: (y -> IO (Maybe x)) -> Sink x -> Sink y

-- | A class for things (in particular Source and SimpleSource) that can
--   output via sinks. Each sink source is supposed to have a unique x,
--   containing a representation of the current value, and delta,
--   containing the (incremental) updates which are put in the sink. Only
--   the addOrdSink function must be defined by instances.
class CanAddSinks sinkSource x delta | sinkSource -> x, sinkSource -> delta where addNewSink sinkSource action = do { parallelX <- newParallelExec; addNewQuickSink sinkSource (\ delta -> parallelExec parallelX (action delta)) } addNewSinkGeneral sinkSource action sinkID = do { parallelX <- newParallelExec; addNewSinkVeryGeneral sinkSource action sinkID parallelX } addNewSinkVeryGeneral sinkSource action sinkID parallelX = addNewQuickSinkGeneral sinkSource (\ delta -> parallelExec parallelX (do { interested <- isInterested sinkID; if interested then action delta else done })) sinkID addNewSinkWithInitial sinkSource xAction deltaAction sinkID parallelX = do { mVar <- newEmptyMVar; let firstAct = do { x <- takeMVar mVar; xAction x }; parallelExec parallelX firstAct; (returnValue@(x, sink)) <- addNewSinkVeryGeneral sinkSource deltaAction sinkID parallelX; putMVar mVar x; return returnValue } addNewQuickSink sinkSource action = do { sink <- newSink action; x <- addOldSink sinkSource sink; return (x, sink) } addNewQuickSinkGeneral sinkSource action sinkID = do { sink <- newSinkGeneral sinkID action; x <- addOldSink sinkSource sink; return (x, sink) }
addNewSink :: CanAddSinks sinkSource x delta => sinkSource -> (delta -> IO ()) -> IO (x, Sink delta)
addNewSinkGeneral :: CanAddSinks sinkSource x delta => sinkSource -> (delta -> IO ()) -> SinkID -> IO (x, Sink delta)
addNewSinkVeryGeneral :: CanAddSinks sinkSource x delta => sinkSource -> (delta -> IO ()) -> SinkID -> ParallelExec -> IO (x, Sink delta)
addNewSinkWithInitial :: CanAddSinks sinkSource x delta => sinkSource -> (x -> IO ()) -> (delta -> IO ()) -> SinkID -> ParallelExec -> IO (x, Sink delta)
addNewQuickSink :: CanAddSinks sinkSource x delta => sinkSource -> (delta -> IO ()) -> IO (x, Sink delta)
addNewQuickSinkGeneral :: CanAddSinks sinkSource x delta => sinkSource -> (delta -> IO ()) -> SinkID -> IO (x, Sink delta)
addOldSink :: CanAddSinks sinkSource x delta => sinkSource -> Sink delta -> IO x

-- | Add an action to a sinkSource which is performed until the action
--   returns False.
addNewAction :: CanAddSinks sinkSource x delta => sinkSource -> (delta -> IO Bool) -> IO x
data ParallelExec
newParallelExec :: IO ParallelExec
parallelExec :: ParallelExec -> IO () -> IO ()
parallelExecVSem :: VSem
instance HasInvalidate (Sink x)
instance Ord SinkID
instance Eq SinkID
instance HasInvalidate SinkID


-- | We implement the Source type and combinators for it.
module Util.Sources
data Source x d
data Client d
staticSource :: x -> Source x d
staticSourceIO :: IO x -> Source x d
variableSource :: x -> IO (Source x d, (x -> (x, [d])) -> IO ())
variableGeneralSource :: x -> IO (Source x d, Updater x d)
data Updater x d
applyToUpdater :: Updater x d -> (x -> (x, [d], extra)) -> IO extra
attachClient :: Client d -> Source x d -> IO x
map1 :: (x1 -> x2) -> Source x1 d -> Source x2 d
map1IO :: (x1 -> IO x2) -> Source x1 d -> Source x2 d
map2 :: (d1 -> d2) -> Source x d1 -> Source x d2
filter2 :: (d1 -> Maybe d2) -> Source x d1 -> Source x d2
filter2IO :: (d1 -> IO (Maybe d2)) -> Source x d1 -> Source x d2
foldSource :: (x -> state) -> (state -> d1 -> (state, d2)) -> Source x d1 -> Source (state, x) d2

-- | Fold a Source so that it can carry state around.
foldSourceIO :: (x1 -> IO (state, x2)) -> (state -> d1 -> IO (state, d2)) -> Source x1 d1 -> Source (state, x2) d2
stepSource :: (x -> d2) -> (d1 -> d2) -> Source x d1 -> Source x d2
choose :: Source x1 d1 -> Source x2 d2 -> Source (x1, x2) (Either d1 d2)
seqSource :: Source x1 x1 -> (x1 -> Source x2 x2) -> Source x2 x2

-- | A Source combinator which "flattens" lists of updates.
flattenSource :: Source x [d] -> Source x d
newtype SimpleSource x
SimpleSource :: (Source x x) -> SimpleSource x
staticSimpleSource :: x -> SimpleSource x
staticSimpleSourceIO :: IO x -> SimpleSource x
class HasSource hasSource x d | hasSource -> x, hasSource -> d
toSource :: HasSource hasSource x d => hasSource -> Source x d
class HasSimpleSource hasSource x | hasSource -> x
toSimpleSource :: HasSimpleSource hasSource x => hasSource -> SimpleSource x

-- | Get the current contents of the source, but don't specify any other
--   action.
readContents :: HasSource source x d => source -> IO x

-- | For each update d, pairs it with its predecessor (given first). For
--   the very first update, a value is given based on the initial x, mapped
--   by the given function.
mkHistorySource :: (x -> d) -> Source x d -> Source x (d, d)

-- | Like mkHistorySource but for SimpleSource's; the x returns the initial
--   value to compare with.
mkHistorySimpleSource :: x -> SimpleSource x -> SimpleSource (x, x)

-- | filter out consecutive duplicates
uniqSimpleSource :: Eq x => SimpleSource x -> SimpleSource x

-- | Pair two SimpleSource's. This is probably better than using &gt;&gt;=,
--   since it does not require reregistering with the second SimpleSource
pairSimpleSources :: SimpleSource x1 -> SimpleSource x2 -> SimpleSource (x1, x2)

-- | Does a similar job to pairSimpleSources, so that the sources run
--   parallel.
sequenceSimpleSource :: [SimpleSource x] -> SimpleSource [x]

-- | replaces the first value of the SimpleSource.
change1 :: SimpleSource x -> x -> SimpleSource x
mapIOSeq :: SimpleSource a -> (a -> IO (SimpleSource b)) -> SimpleSource b

-- | Run the specified actions for the source, using the given SinkID and
--   in the ParallelExec thread. The x -&gt; IO () action is guaranteed to
--   be performed before any of the d -&gt; IO () actions.
addNewSourceActions :: Source x d -> (x -> IO ()) -> (d -> IO ()) -> SinkID -> ParallelExec -> IO x

-- | Outputs information about what comes through the source, turning it
--   into a String with the supplied function. (This is done once for each
--   active client.)
traceSimpleSource :: (a -> String) -> SimpleSource a -> SimpleSource a

-- | Outputs information about what comes through the source, turning it
--   into a String with the supplied function. (This is done once for each
--   active client.)
traceSource :: (a -> String) -> (d -> String) -> Source a d -> Source a d

-- | Used when we are worried that a SimpleSource recursively constructed
--   by mapIOSeq, &gt;&gt;= and friends may actually try to call itself,
--   and so loop forever. The Strings identify the SimpleSource, and so the
--   [String] is effectively a backtrace of the TSems, revealing what chain
--   of simple sources might have caused the loop.
noLoopSimpleSource :: TSem -> ([String] -> a) -> SimpleSource a -> SimpleSource a
mkIOSimpleSource :: IO (SimpleSource a) -> SimpleSource a

-- | Fold a Simple Source, so that it carries state. The state is
--   recomputed for each client.
foldSimpleSourceIO :: (x1 -> IO (state, x2)) -> (state -> x1 -> IO (state, x2)) -> SimpleSource x1 -> SimpleSource x2
instance HasSource hasSource x d => CanAddSinks hasSource x d
instance HasSource (SimpleSource x) x x
instance HasSimpleSource (SimpleSource x) x
instance HasSource (Source x d) x d
instance Monad SimpleSource
instance HasMapIO SimpleSource
instance Functor SimpleSource


-- | A Broadcaster<i>SimpleBroadcaster is a variable Source</i>SimpleSource
--   paired with its update function
module Util.Broadcaster
data GeneralBroadcaster x d
data Broadcaster x d
data SimpleBroadcaster x
newBroadcaster :: x -> IO (Broadcaster x d)
newSimpleBroadcaster :: x -> IO (SimpleBroadcaster x)
newGeneralBroadcaster :: x -> IO (GeneralBroadcaster x d)
class BroadcasterClass broadcaster value | broadcaster -> value
broadcast :: BroadcasterClass broadcaster value => broadcaster -> value -> IO ()
applySimpleUpdate :: SimpleBroadcaster x -> (x -> x) -> IO ()
applySimpleUpdate' :: SimpleBroadcaster x -> (x -> (x, y)) -> IO y
applyUpdate :: Broadcaster x d -> (x -> (x, [d])) -> IO ()
applyGeneralUpdate :: GeneralBroadcaster x d -> (x -> (x, [d], extra)) -> IO extra

-- | Replace a SimpleSource by another which comes with a switch-off
--   function, which temporarily blocks further updates. The action
--   returned by the switch-off function switches the source back on again.
switchOffSimpleSource :: SimpleSource a -> IO (SimpleSource a, IO (IO ()))

-- | Replace a SimpleSource by another which mirrors it, but only copies
--   from it once, hopefully saving CPU time. The IO action stops the
--   mirroring.
mirrorSimpleSource :: SimpleSource a -> IO (SimpleSource a, IO ())

-- | Replace a SimpleSource by another which mirrors it, but only copies
--   from it once, hopefully saving CPU time. In addition, block all update
--   while the Delayer is delaying things.
mirrorSimpleSourceWithDelayer :: Delayer -> SimpleSource a -> IO (SimpleSource a, IO ())
instance HasSimpleSource (SimpleBroadcaster x) x
instance HasSource (GeneralBroadcaster x d) x d
instance HasSource (SimpleBroadcaster x) x x
instance HasSource (Broadcaster x d) x d
instance BroadcasterClass (SimpleBroadcaster x) x
instance BroadcasterClass (Broadcaster x d) (x, [d])


-- | VariableSet allow us to track changes to an unordered mutable set. The
--   elements of the set are keyed by instancing HasKey with some Ord
--   instance; this allows us to set up a special HasKey instance for this
--   module without committing us to that Ord instance everywhere.
module Util.VariableSet
class Ord key => HasKey x key | x -> key
toKey :: HasKey x key => x -> key
newtype Keyed x
Keyed :: x -> Keyed x

-- | Encodes the updates to a variable set. BeginGroup does not actually
--   alter the set itself, but indicate that a group of updates is about to
--   begin, terminated by EndGroup. This prevents the client from trying to
--   recalculate the state after every single update.
--   
--   BeginGroup/EndGroup may be nested (though I don't have any application
--   for that yet).
data VariableSetUpdate x
AddElement :: x -> VariableSetUpdate x
DelElement :: x -> VariableSetUpdate x
BeginGroup :: VariableSetUpdate x
EndGroup :: VariableSetUpdate x
newtype VariableSet x
VariableSet :: (Broadcaster (VariableSetData x) (VariableSetUpdate x)) -> VariableSet x

-- | Create a new empty variable set.
newEmptyVariableSet :: HasKey x key => IO (VariableSet x)

-- | Create a new variable set with given contents
newVariableSet :: HasKey x key => [x] -> IO (VariableSet x)

-- | Update a variable set in some way.
updateSet :: HasKey x key => VariableSet x -> VariableSetUpdate x -> IO ()

-- | Set the elements of the variable set.
setVariableSet :: HasKey x key => VariableSet x -> [x] -> IO ()
type VariableSetSource x = Source [x] (VariableSetUpdate x)
emptyVariableSetSource :: VariableSetSource x
mapVariableSetSourceIO' :: (x -> IO (Maybe y)) -> VariableSetSource x -> VariableSetSource y
concatVariableSetSource :: VariableSetSource x -> VariableSetSource x -> VariableSetSource x
mapVariableSetSource :: (x -> y) -> VariableSetSource x -> VariableSetSource y
singletonSetSource :: SimpleSource x -> VariableSetSource x

-- | Creates a VariableSetSource whose elements are the same as those of
--   the corresponding list.
listToSetSource :: Ord x => SimpleSource [x] -> VariableSetSource x
instance Typeable1 VariableSet
instance Functor VariableSetUpdate
instance HasKey x key => HasSource (VariableSet x) [x] (VariableSetUpdate x)
instance HasKey x key => Ord (Keyed x)
instance HasKey x key => Eq (Keyed x)


-- | VariableMap is analagous to VariableSet and provides a mutable map
--   ordered by key whose changes can be tracked.
module Util.VariableMap

-- | Describes a map update. For DelUpdate, the second parameter (the one
--   of type elt) is irrelevant and may be undefined.
data VariableMapData key elt

-- | We recycle the VariableSetUpdate type for this.
newtype VariableMapUpdate key elt
VariableMapUpdate :: (VariableSetUpdate (key, elt)) -> VariableMapUpdate key elt
data VariableMap key elt

-- | Create a new empty variable map.
newEmptyVariableMap :: Ord key => IO (VariableMap key elt)

-- | Create a new variable map with given contents
newVariableMap :: Ord key => [(key, elt)] -> IO (VariableMap key elt)
newVariableMapFromFM :: Ord key => Map key elt -> IO (VariableMap key elt)

-- | Update a variable map in some way. Returns True if the update was
--   sucessful (so for insertions, the object is not already there; for
--   deletions the object is not there).
updateMap :: Ord key => VariableMap key elt -> VariableMapUpdate key elt -> IO Bool
lookupMap :: Ord key => VariableMapData key elt -> key -> Maybe elt
lookupWithDefaultMap :: Ord key => VariableMapData key elt -> elt -> key -> elt
mapToList :: Ord key => VariableMapData key elt -> [(key, elt)]
mapToFM :: Ord key => VariableMapData key elt -> Map key elt

-- | Given a variable map and conversion function, produce a
--   VariableSetSource
mapToVariableSetSource :: Ord key => (key -> elt -> element) -> VariableMap key elt -> VariableSetSource element
addToVariableMap :: Ord key => VariableMap key elt -> key -> elt -> IO Bool
delFromVariableMap :: Ord key => VariableMap key elt -> key -> IO Bool
variableMapToList :: Ord key => VariableMap key elt -> IO [(key, elt)]
lookupVariableMap :: Ord key => VariableMap key elt -> key -> IO (Maybe elt)
getVariableMapByKey :: Ord key => VariableMap key elt -> key -> SimpleSource (Maybe elt)
instance Typeable2 VariableMap
instance Ord key => HasSource (VariableMapSet key elt element) [element] (VariableSetUpdate element)
instance Ord key => HasSource (VariableMap key elt) (VariableMapData key elt) (VariableMapUpdate key elt)


-- | This implements a SinkSource with keyed changes.
module Util.KeyedChanges
data KeyedChanges key delta
newKeyedChanges :: Ord key => IO (KeyedChanges key delta)
sendKeyedChanges :: Ord key => key -> delta -> KeyedChanges key delta -> IO ()
deleteKeyedChange :: Ord key => key -> delta -> KeyedChanges key delta -> IO ()
instance Ord key => HasSource (KeyedChanges key delta) [delta] delta

module Util.VariableList
newVariableListFromSet :: Ord a => VariableSetSource a -> VariableList a
newVariableListFromList :: Ord a => SimpleSource [a] -> VariableList a
emptyVariableList :: VariableList a
singletonList :: a -> VariableList a

-- | Return the close action. attachListOp :: ParallelExec -&gt;
--   VariableList a -&gt; ListDrawer a -&gt; IO (IO ())
data VariableList a
data ListDrawer a pos
ListDrawer :: (Maybe pos -> Maybe a -> IO pos) -> (pos -> Maybe a -> IO ()) -> (pos -> IO ()) -> IO () -> ListDrawer a pos
newPos :: ListDrawer a pos -> Maybe pos -> Maybe a -> IO pos
setPos :: ListDrawer a pos -> pos -> Maybe a -> IO ()
delPos :: ListDrawer a pos -> pos -> IO ()
redraw :: ListDrawer a pos -> IO ()
attachListOp :: VariableList a -> forall pos. ParallelExec -> ListDrawer a pos -> IO (IO ())
coMapListDrawer :: (a -> b) -> ListDrawer b pos -> ListDrawer a pos
map2ListDrawer :: (pos1 -> pos2) -> (pos2 -> pos1) -> ListDrawer b pos1 -> ListDrawer b pos2
catVariableLists :: VariableList a -> VariableList a -> VariableList a
instance HasAddDelayerIO (ListDrawer a pos)
instance HasAddDelayer (VariableList a)
instance Functor VariableList


-- | Blockers are used to implement variable set sources which can be
--   turned on and off. They are indexed by a BlockID.
module Util.VariableSetBlocker
data Blocker a
data BlockID
newBlocker :: HasKey a key => VariableSetSource a -> IO (Blocker a)
newBlockID :: IO BlockID
openBlocker :: HasKey a key => Blocker a -> BlockID -> IO ()
closeBlocker :: HasKey a key => Blocker a -> BlockID -> IO ()
blockVariableSet :: HasKey a key => Blocker a -> BlockID -> IO (VariableSetSource a)
newBlockerWithPreAction :: HasKey a key => VariableSetSource a -> ([a] -> IO ()) -> IO (Blocker a)
instance Eq BlockID
instance Ord BlockID


-- | This code does <a>Huffman</a> coding, using the queue implementation.
--   This can be used for constructing Huffman encodings, or for computing
--   factorials efficiently.
module Util.Huffman

-- | huffmanFold op l where op is associative, l is a nonempty
--   monotonically increasing list, and op has the property that
--   (x1&gt;=x2,y1&gt;=y2) =&gt; (op x1 y1&gt;=op x2 y2) computes the fold
--   of l with op, by repeatedly folding the smallest two elements of the
--   list until only one remains.
huffmanFold :: Ord a => (a -> a -> a) -> [a] -> a
instance Show a => Show (PointedList a)
