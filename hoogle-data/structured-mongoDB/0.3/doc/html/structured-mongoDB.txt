-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Structured MongoDB interface
--   
--   This module exports a structured type-safe interface to MongoDB.
@package structured-mongoDB
@version 0.3


-- | This module exports a <tt>Structued</tt> type class which can be used
--   to convert Haskel "record types" to <tt>BSON</tt> objects and vice
--   versa. As a Mongo document has an "_id" field, we impose the
--   requirement a record type have a field whose type is <a>SObjId</a>
--   (corresponding to "_id").
module Database.MongoDB.Structured.Types

-- | Structured class used to convert between a Haskell record type and
--   BSON document.
class Structured a
collection :: Structured a => a -> Collection
toBSON :: Structured a => a -> Document
fromBSON :: Structured a => Document -> Maybe a

-- | Type corresponding to the "_id" field of a document in a structured
--   object.
newtype SObjId
SObjId :: (Maybe ObjectId) -> SObjId

-- | The "_id" field is unset.
noSObjId :: SObjId

-- | Check if the "_id" field is unset.
isNoSObjId :: SObjId -> Bool

-- | Set the "_id" field.
toSObjId :: ObjectId -> SObjId

-- | Get the "_id" field (assumes that it is set0.
unSObjId :: SObjId -> ObjectId
instance Typeable SObjId
instance Show SObjId
instance Read SObjId
instance Eq SObjId
instance Ord SObjId
instance Val SObjId


-- | This module exports several classes and combinators that operated on
--   <a>Structured</a> types. Specifically, we provide the structured
--   versions of <tt>mongoDB</tt>''s combinators, including structured
--   query creation.
module Database.MongoDB.Structured.Query

-- | Inserts document to its corresponding collection and return the "_id"
--   value.
insert :: (MonadIO' m, Structured a) => a -> Action m Value

-- | Same as <a>insert</a> but discarding result.
insert_ :: (MonadIO' m, Structured a) => a -> Action m ()

-- | Inserts documents to their corresponding collection and return their
--   "_id" values.
insertMany :: (MonadIO' m, Structured a) => [a] -> Action m [Value]

-- | Same as <a>insertMany</a> but discarding result.
insertMany_ :: (MonadIO' m, Structured a) => [a] -> Action m ()

-- | Inserts documents to their corresponding collection and return their
--   "_id" values. Unlike <a>insertMany</a>, this function keeps inserting
--   remaining documents even if an error occurs.
insertAll :: (MonadIO' m, Structured a) => [a] -> Action m [Value]

-- | Same as <a>insertAll</a> but discarding result.
insertAll_ :: (MonadIO' m, Structured a) => [a] -> Action m ()

-- | Save document to collection. If the <a>SObjId</a> field is set then
--   the document is updated, otherwise we perform an insert.
save :: (MonadIO' m, Structured a) => a -> Action m ()

-- | Delete all documents that match the selection/query.
delete :: MonadIO m => StructuredSelection -> Action m ()

-- | Delete the first documents that match the selection/query.
deleteOne :: MonadIO m => StructuredSelection -> Action m ()

-- | Sort by field, ascending
asc :: Selectable a f t => f -> OrderExp

-- | Sort by field, descending
desc :: Selectable a f t => f -> OrderExp

-- | Wrapper for <tt>mongoDB</tt>'s <tt>Query</tt> type.
data StructuredQuery

-- | Maximum number of objects to return (default: 0, no limit).
limit :: StructuredQuery -> Word32

-- | Number of matching objects to skip (default: 0).
skip :: StructuredQuery -> Word32

-- | Sortresult by this order.
sort :: StructuredQuery -> [OrderExp]

-- | Find documents satisfying query
find :: (Functor m, MonadIO m, MonadBaseControl IO m) => StructuredQuery -> Action m StructuredCursor

-- | Find documents satisfying query
findOne :: (MonadIO m, Structured a) => StructuredQuery -> Action m (Maybe a)

-- | Same as <a>findOne</a> but throws <a>DocNotFound</a> if none match.
--   Error is thrown if the document cannot e transformed.
fetch :: (MonadIO m, Functor m, Structured a) => StructuredQuery -> Action m a

-- | Count number of documents satisfying query.
count :: MonadIO' m => StructuredQuery -> Action m Int

-- | Wrapper for <tt>mongoDB</tt>'s <tt>Selection</tt> type.
data StructuredSelection

-- | Analog to <tt>mongoDB</tt>'s <tt>Select</tt> class
class StructuredSelect aQorS
select :: (StructuredSelect aQorS, Structured a) => QueryExp a -> aQorS

-- | Class defining a selectable type. Type <tt>a</tt> corresponds to the
--   record type, <tt>f</tt> corresponds to the field or facet, and
--   <tt>t</tt> corresponds to the field/facet type.
class Val t => Selectable a f t | f -> a, f -> t
s :: Selectable a f t => f -> t -> Label

-- | Combining two field names to create a <a>Nested</a> type.
(.!) :: (Selectable r f t, Selectable t f' t') => f -> f' -> Nested f f'

-- | A query expression.
data QueryExp a

-- | Combinator for <tt>==</tt>
(.*) :: Structured a => QueryExp a

-- | Combinator for <tt>==</tt>
(.==) :: (Val t, Selectable a f t) => f -> t -> QueryExp a

-- | Combinator for <tt>$ne</tt>
(./=) :: (Val t, Selectable a f t) => f -> t -> QueryExp a

-- | Combinator for <tt>&lt;</tt>
(.<) :: (Val t, Selectable a f t) => f -> t -> QueryExp a

-- | Combinator for <tt>&lt;=</tt>
(.<=) :: (Val t, Selectable a f t) => f -> t -> QueryExp a

-- | Combinator for <tt>&gt;</tt>
(.>) :: (Val t, Selectable a f t) => f -> t -> QueryExp a

-- | Combinator for <tt>&gt;=</tt>
(.>=) :: (Val t, Selectable a f t) => f -> t -> QueryExp a

-- | Combinator for <tt>$and</tt>
(.&&) :: QueryExp a -> QueryExp a -> QueryExp a

-- | Combinator for <tt>$or</tt>
(.||) :: QueryExp a -> QueryExp a -> QueryExp a

-- | Combinator for <tt>$not</tt>
not_ :: QueryExp a -> QueryExp a

-- | Wrapper for <tt>mongoDB</tt>'s <tt>Cursor</tt>.
data StructuredCursor

-- | Close the cursor.
closeCursor :: (MonadIO m, MonadBaseControl IO m) => StructuredCursor -> Action m ()

-- | Check if the cursor is closed.
isCursorClosed :: (MonadIO m, MonadBase IO m) => StructuredCursor -> Action m Bool

-- | Return next batch of structured documents.
nextBatch :: (Structured a, Functor m, MonadIO m, MonadBaseControl IO m) => StructuredCursor -> Action m [Maybe a]

-- | Return next structured document. If failed return <a>Left</a>,
--   otherwise <a>Right</a> of the deserialized result.
next :: (Structured a, MonadIO m, MonadBaseControl IO m) => StructuredCursor -> Action m (Either () (Maybe a))

-- | Return up to next <tt>N</tt> documents.
nextN :: (Structured a, Functor m, MonadIO m, MonadBaseControl IO m) => Int -> StructuredCursor -> Action m [Maybe a]

-- | Return the remaining documents in query result.
rest :: (Structured a, Functor m, MonadIO m, MonadBaseControl IO m) => StructuredCursor -> Action m [Maybe a]

-- | A BSON value is one of the following types of values
data Value :: *
instance Eq StructuredSelection
instance Show StructuredSelection
instance Eq (QueryExp a)
instance Show (QueryExp a)
instance Eq OrderExp
instance Show OrderExp
instance Eq StructuredQuery
instance Show StructuredQuery
instance (Selectable r f t, Selectable t f' t') => Selectable r (Nested f f') t'
instance StructuredSelect StructuredQuery
instance StructuredSelect StructuredSelection


-- | This module exports a <i>structued</i> interface to MongoDB.
--   Specifically, Haskell record types are used (in place of BSON) to
--   represent documents which can be inserted and retrieved from a
--   MongoDB. Data types corresponding to fields of a document are used in
--   forming well-typed queries, as opposed to strings. This module
--   re-exports the <a>Database.MongoDB.Structured.Types</a> module, which
--   exports a <a>Structured</a> type class --- this class is used to
--   convert Haskell record types to and from BSON documents. The module
--   <a>Database.MongoDB.Structured.Query</a> exports an interface similar
--   to <tt>Database.MongoDB.Query</tt> which can be used to insert, query,
--   update, delete, etc. record types from a Mongo DB.
--   
--   Though users may provide their own instances for <a>Structured</a>
--   (and <a>Selectable</a>, used in composing well-typed queries), we
--   provide a Template Haskell function (<tt>deriveStructured</tt>) that
--   can be used to automatically do this. See
--   <a>Database.MongoDB.Structured.Deriving.TH</a>.
--   
--   The example below shows how to use the structued MongoDB interface:
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   {-# LANGUAGE TypeSynonymInstances #-}
--   {-# LANGUAGE MultiParamTypeClasses #-}
--   {-# LANGUAGE FlexibleInstances #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE DeriveDataTypeable #-}
--   import Database.MongoDB.Structured
--   import Database.MongoDB.Structured.Deriving.TH
--   import Control.Monad.Trans (liftIO)
--   import Data.Typeable
--   import Control.Monad (mapM_)
--   import Control.Monad.IO.Class
--   import Data.Bson (Value)
--   import Data.Maybe (isJust, fromJust)
--   
--   data Address = Address { addrId :: SObjId
--                          , city   :: String
--                          , state  :: String
--                          } deriving (Show, Eq, Typeable)
--   $(deriveStructured ''Address)
--   
--   data Team = Team { teamId :: SObjId
--                    , name   :: String
--                    , home   :: Address
--                    , league :: String
--                    } deriving (Show, Eq, Typeable)
--   $(deriveStructured ''Team)
--   
--   main = do
--      pipe &lt;- runIOE $ connect (host "127.0.0.1")
--      e &lt;- access pipe master "baseball" run
--      close pipe
--      print e
--   
--   run = do
--      clearTeams
--      insertTeams
--      allTeams &gt;&gt;= printDocs "All Teams"
--      nationalLeagueTeams &gt;&gt;= printDocs "National League Teams"
--      newYorkTeams &gt;&gt;= printDocs "New York Teams"
--   
--   -- Delete all teams:
--   clearTeams :: Action IO ()
--   clearTeams = delete (select ( (.*) :: QueryExp Team))
--   
--   insertTeams :: Action IO [Value]
--   insertTeams = insertMany [
--      Team { teamId = noSObjId
--           , name   = "Yankees"
--           , home   = Address { addrId = noSObjId
--                              , city  = "New York"
--                              , state = "NY"
--                              }
--           , league = "American"}
--     , Team { teamId = noSObjId
--            , name   = "Mets"
--            , home   = Address { addrId = noSObjId
--                               , city  = "New York"
--                               , state = "NY"
--                               }
--            , league = "National"}
--     , Team { teamId = noSObjId
--            , name   = "Phillies"
--            , home   = Address { addrId = noSObjId
--                               , city  = "Philadelphia"
--                               , state = "PA"
--                               }
--            , league = "National"}
--     , Team { teamId = noSObjId
--            , name   = "Red Sox"
--            , home   = Address { addrId = noSObjId
--                               , city  = "Boston"
--                               , state = "MA"
--                               }
--            , league = "National"}
--     ]
--   
--   allTeams :: Action IO [Maybe Team]
--   allTeams = let query = (select ((.*) :: QueryExp Team))
--                               { sort = [asc (Home .! City)]}
--              in find query &gt;&gt;= rest
--              
--   nationalLeagueTeams :: Action IO [Maybe Team]
--   nationalLeagueTeams = rest =&lt;&lt; find (select (League .== "National"))
--   
--   newYorkTeams :: Action IO [Maybe Team]
--   newYorkTeams = rest =&lt;&lt; find (select (Home .! State .== "NY"))
--   
--   printDocs :: MonadIO m =&gt; String -&gt; [Maybe Team] -&gt; m ()
--   printDocs title teams' = liftIO $ do
--     let teams = (map fromJust) . filter (isJust) $ teams'
--     putStrLn title 
--     mapM_ (putStrLn . show) teams
--   </pre>
module Database.MongoDB.Structured


-- | This module exports a <tt>Structued</tt> type class which can be used
--   to convert from Haskel "record types" to <tt>BSON</tt> objects and
--   vice versa. We use Templace Haskell to provide a function
--   <a>deriveStructured</a> which can be used to automatically generate an
--   instance of such types for the <a>Structured</a> and BSON's
--   <tt>Val</tt> classes.
--   
--   For instance:
--   
--   <pre>
--   data User = User { userId :: Int
--                    , userFirstName :: String
--                    , userLastName :: String
--                    }
--               deriving(Show, Read, Eq, Ord, Typeable)
--   $(deriveStructured ''User)
--   
--   </pre>
--   
--   <tt>deriveStrctured</tt> used used to create the following instance of
--   <a>Structured</a>:
--   
--   <pre>
--   instance Structured User where
--     toBSON x = [ (u "_id")           := val (userId x)
--                , (u "userFirstName") := val (userFirstName x)
--                , (u "userLastName")  := val (userLastName x)
--                ]
--     
--     fromBSON doc = lookup (u "_id")             doc &gt;&gt;= \val_1 -&gt;
--                    lookup (u "userFirstName")   doc &gt;&gt;= \val_2 -&gt;
--                    lookup (u "userLastName")    doc &gt;&gt;= \val_3 -&gt;
--                    return User { userId        = val_1
--                                , userFirstName = val_2
--                                , userLastname  = val_3
--                                }
--   </pre>
--   
--   To allow for structured and well-typed queies, it also generates types
--   corresponding to each field (which are made an instance of
--   <a>Selectable</a>). Specifically, for the above data type, it creates:
--   
--   <pre>
--   data UserId = UserId deriving (Show, Eq)
--   instance Selectable User UserId SObjId where s _ _ = "_id"
--   
--   data FirstName = FirstName deriving (Show, Eq)
--   instance Selectable User FirstName String where s _ _ = "firstName"
--   
--   data LastName = LastName deriving (Show, Eq)
--   instance Selectable User LastName String where s _ _ = "lastName"
--   </pre>
module Database.MongoDB.Structured.Deriving.TH

-- | This function generates <a>Structured</a> and <tt>Val</tt> instances
--   for record types.
deriveStructured :: Name -> Q [Dec]
