-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple and type safe web framework that generate web API documentation.
--   
@package apiary
@version 1.4.3

module Data.Apiary.Method
data Method
GET :: Method
POST :: Method
HEAD :: Method
PUT :: Method
DELETE :: Method
TRACE :: Method
CONNECT :: Method
OPTIONS :: Method
PATCH :: Method
NonStandard :: ByteString -> Method
renderMethod :: Method -> ByteString
dispatchMethod :: a -> a -> a -> a -> a -> a -> a -> a -> a -> (ByteString -> a) -> ByteString -> a
parseMethod :: ByteString -> Method
instance Eq Method
instance Ord Method
instance Read Method
instance Show Method
instance IsString Method
instance Hashable Method

module Data.Apiary.Param
class Path a
readPath :: Path a => Text -> Maybe a
pathRep :: Path a => proxy a -> TypeRep

-- | readPath providing type using Proxy.
readPathAs :: Path a => proxy a -> Text -> Maybe a
class Query a where queryRep = Strict . qTypeRep
readQuery :: Query a => Maybe ByteString -> Maybe a
queryRep :: Query a => proxy a -> QueryRep
qTypeRep :: Query a => proxy a -> TypeRep
data QueryRep

-- | require value
Strict :: TypeRep -> QueryRep

-- | allow key only value
Nullable :: TypeRep -> QueryRep

-- | check existance
Check :: QueryRep
NoValue :: QueryRep
data File
File :: ByteString -> ByteString -> ByteString -> ByteString -> File
fileParameter :: File -> ByteString
fileName :: File -> ByteString
fileContentType :: File -> ByteString
fileContent :: File -> ByteString
type Param = (ByteString, ByteString)
class ReqParam a
reqParams :: ReqParam a => proxy a -> Query -> [Param] -> [File] -> [(ByteString, Maybe a)]
reqParamRep :: ReqParam a => proxy a -> QueryRep
class Strategy (w :: * -> *) where type family SNext w (k :: Symbol) a (prms :: [KV *]) :: [KV *]
strategy :: (Strategy w, KnownSymbol k, k </ prms, MonadPlus m) => w a -> proxy' k -> [Maybe a] -> Store prms -> m (Store (SNext w k a prms))
strategyRep :: Strategy w => w a -> StrategyRep
newtype StrategyRep
StrategyRep :: Text -> StrategyRep
strategyInfo :: StrategyRep -> Text
data First a
First :: First a
data One a
One :: One a
data Many a
Many :: Many a
data Some a
Some :: Some a
data Option a
Option :: Option a
data Optional a
Optional :: Text -> a -> Optional a
pBool :: Proxy Bool
pInt :: Proxy Int
pWord :: Proxy Word
pDouble :: Proxy Double
pText :: Proxy Text
pLazyText :: Proxy Text
pByteString :: Proxy ByteString
pLazyByteString :: Proxy ByteString
pString :: Proxy String
pMaybe :: proxy a -> Proxy (Maybe a)
pFile :: Proxy File
pFirst :: proxy a -> First a
pOne :: proxy a -> One a
pMany :: proxy a -> Many a
pSome :: proxy a -> Some a
pOption :: proxy a -> Option a
pOptional :: Show a => a -> Optional a
instance Typeable Text
instance Typeable File
instance Show File
instance Eq File
instance Show QueryRep
instance Eq QueryRep
instance Show StrategyRep
instance Eq StrategyRep
instance Strategy Optional
instance Strategy Option
instance Strategy Some
instance Strategy Many
instance Strategy One
instance Strategy First
instance Query a => ReqParam a
instance ReqParam File
instance Query ()
instance Query a => Query (Maybe a)
instance Path Day
instance Query Day
instance Query String
instance Query ByteString
instance Query ByteString
instance Query Text
instance Query Text
instance Query Float
instance Query Double
instance Query Word64
instance Query Word32
instance Query Word16
instance Query Word8
instance Query Word
instance Query Integer
instance Query Int64
instance Query Int32
instance Query Int16
instance Query Int8
instance Query Int
instance Query Bool
instance Path String
instance Path ByteString
instance Path ByteString
instance Path Text
instance Path Text
instance Path Float
instance Path Double
instance Path Word64
instance Path Word32
instance Path Word16
instance Path Word8
instance Path Word
instance Path Integer
instance Path Int64
instance Path Int32
instance Path Int16
instance Path Int8
instance Path Int
instance Path Bool
instance Path Char

module Data.Apiary.Document
data Documents
Documents :: [PathDoc] -> [(Text, [PathDoc])] -> Documents
noGroup :: Documents -> [PathDoc]
groups :: Documents -> [(Text, [PathDoc])]
data Route
Path :: Text -> Route -> Route
Fetch :: Text -> TypeRep -> (Maybe Html) -> Route -> Route

-- | ** with name
Rest :: Text -> (Maybe Html) -> Route

-- | ** without name
Any :: Route
End :: Route
data PathDoc
PathDoc :: Route -> [(Method, [MethodDoc])] -> PathDoc
path :: PathDoc -> Route
methods :: PathDoc -> [(Method, [MethodDoc])]
data MethodDoc
MethodDoc :: [QueryDoc] -> [Html] -> Maybe ByteString -> Text -> MethodDoc
queries :: MethodDoc -> [QueryDoc]
preconditions :: MethodDoc -> [Html]
accept :: MethodDoc -> Maybe ByteString
document :: MethodDoc -> Text

-- | query parameters document
data QueryDoc
QueryDoc :: Text -> StrategyRep -> QueryRep -> (Maybe Html) -> QueryDoc
queryName :: QueryDoc -> Text
queryStrategy :: QueryDoc -> StrategyRep
queryRep :: QueryDoc -> QueryRep
queryDocument :: QueryDoc -> (Maybe Html)

module Data.Apiary.Document.Html
defaultDocumentToHtml :: DefaultDocumentConfig -> Documents -> Html
data DefaultDocumentConfig
DefaultDocumentConfig :: Text -> Maybe Html -> Bool -> Maybe Text -> DefaultDocumentConfig
documentTitle :: DefaultDocumentConfig -> Text
documentDescription :: DefaultDocumentConfig -> Maybe Html
documentUseCDN :: DefaultDocumentConfig -> Bool

-- | google analytics. since 0.17.0.
documentGoogleAnalytics :: DefaultDocumentConfig -> Maybe Text

-- | construct Html as route parameter. since 0.13.0.
rpHtml :: Html -> Html
instance Default DefaultDocumentConfig

module Data.Apiary.Extension
class Has a (as :: [*])
getExtension :: Has a as => proxy a -> Extensions as -> a
class Monad m => MonadExts es m | m -> es
getExts :: MonadExts es m => m (Extensions es)
getExt :: (MonadExts es m, Has e es) => proxy e -> m e
type Middleware' = forall exts. ActionT exts [] IO () -> ActionT exts [] IO ()
class Extension e where extMiddleware _ = id extMiddleware' _ = id
extMiddleware :: Extension e => e -> Middleware
extMiddleware' :: Extension e => e -> Middleware'
data Extensions (es :: [*])
noExtension :: Monad m => Initializer m i i
data Initializer m i o
initializer :: (Extension e, Monad m) => (Extensions es -> m e) -> Initializer m es (e : es)
type Initializer' m a = forall i. Initializer m i (a : i)
initializer' :: (Extension e, Monad m) => m e -> Initializer' m e
initializerBracket :: Extension e => (forall a. Extensions es -> (e -> m a) -> m a) -> Initializer m es (e : es)
initializerBracket' :: Extension e => (forall a. (e -> m a) -> m a) -> Initializer m es (e : es)

-- | combine two Initializer. since 0.16.0.
(+>) :: Monad m => Initializer m i x -> Initializer m x o -> Initializer m i o

module Control.Monad.Apiary.Action
data ActionT exts prms m a

-- | n must be Monad, so cant be MFunctor.
hoistActionT :: (Monad m, Monad n) => (forall b. m b -> n b) -> ActionT exts prms m a -> ActionT exts prms n a

-- | stop handler and send current state. since 0.3.3.0.
stop :: Monad m => ActionT exts prms m a

-- | get parameter. since 1.0.0.
--   
--   example:
--   
--   <pre>
--   param [key|foo|]
--   </pre>
param :: (Member k v prms, Monad m) => proxy k -> ActionT exts prms m v

-- | get parameters. since 1.0.0.
--   
--   <pre>
--   [params|foo,bar|] == do { a &lt;- param [key|foo|]; b &lt;- param [key|bar|]; return (a, b) }
--   </pre>
params :: QuasiQuoter

-- | set status code. since 0.1.0.0.
status :: Monad m => Status -> ActionT exts prms m ()

-- | add response header. since 0.1.0.0.
--   
--   Don't set Content-Type using this function. Use <tt>contentType</tt>.
addHeader :: Monad m => HeaderName -> ByteString -> ActionT exts prms m ()

-- | set response headers. since 0.1.0.0.
--   
--   Don't set Content-Type using this function. Use <tt>contentType</tt>.
setHeaders :: Monad m => ResponseHeaders -> ActionT exts prms m ()

-- | modify response header. since 0.1.0.0.
--   
--   Don't set Content-Type using this function. Use <tt>contentType</tt>.
modifyHeader :: Monad m => (ResponseHeaders -> ResponseHeaders) -> ActionT exts prms m ()

-- | set content-type header.
--   
--   if content-type header already exists, replace it. since 0.1.0.0.
contentType :: Monad m => ContentType -> ActionT exts prms m ()

-- | reset response body to no response. since v0.15.2.
reset :: Monad m => ActionT exts prms m ()

-- | set response body from builder. since 0.1.0.0.
builder :: Monad m => Builder -> ActionT exts prms m ()

-- | set response body from strict bytestring. since 0.15.2.
bytes :: Monad m => ByteString -> ActionT exts prms m ()

-- | set response body from lazy bytestring. since 0.15.2.
lazyBytes :: Monad m => ByteString -> ActionT exts prms m ()

-- | set response body from strict text. encoding UTF-8. since 0.15.2.
text :: Monad m => Text -> ActionT exts prms m ()

-- | set response body from lazy text. encoding UTF-8. since 0.15.2.
lazyText :: Monad m => Text -> ActionT exts prms m ()

-- | set response body from show. encoding UTF-8. since 0.15.2.
showing :: (Monad m, Show a) => a -> ActionT exts prms m ()

-- | set response body from string. encoding UTF-8. since 0.15.2.
string :: Monad m => String -> ActionT exts prms m ()

-- | set response body from char. encoding UTF-8. since 0.15.2.
char :: Monad m => Char -> ActionT exts prms m ()

-- | append response body from builder. since 1.2.0.
appendBuilder :: Monad m => Builder -> ActionT exts prms m ()

-- | append response body from strict bytestring. since 1.2.0.
appendBytes :: Monad m => ByteString -> ActionT exts prms m ()

-- | append response body from lazy bytestring. since 1.2.0.
appendLazyBytes :: Monad m => ByteString -> ActionT exts prms m ()

-- | append response body from strict text. encoding UTF-8. since 1.2.0.
appendText :: Monad m => Text -> ActionT exts prms m ()

-- | append response body from lazy text. encoding UTF-8. since 1.2.0.
appendLazyText :: Monad m => Text -> ActionT exts prms m ()

-- | append response body from show. encoding UTF-8. since 1.2.0.
appendShowing :: (Monad m, Show a) => a -> ActionT exts prms m ()

-- | append response body from string. encoding UTF-8. since 1.2.0.
appendString :: Monad m => String -> ActionT exts prms m ()

-- | append response body from char. encoding UTF-8. since 1.2.0.
appendChar :: Monad m => Char -> ActionT exts prms m ()

-- | set response body file content and detect Content-Type by extension.
--   since 0.1.0.0.
--   
--   file modification check since 0.17.2.
file :: MonadIO m => FilePath -> Maybe FilePart -> ActionT exts prms m ()

-- | set response body file content, without set Content-Type. since
--   0.1.0.0.
file' :: MonadIO m => FilePath -> Maybe FilePart -> ActionT exts prms m ()

-- | redirect with:
--   
--   303 See Other (HTTP/1.1) or 302 Moved Temporarily (Other)
--   
--   since 0.6.2.0.
redirect :: Monad m => ByteString -> ActionT exts prms m ()

-- | redirect with 301 Moved Permanently. since 0.3.3.0.
redirectPermanently :: Monad m => ByteString -> ActionT exts prms m ()

-- | redirect with:
--   
--   307 Temporary Redirect (HTTP/1.1) or 302 Moved Temporarily (Other)
--   
--   since 0.3.3.0.
redirectTemporary :: Monad m => ByteString -> ActionT exts prms m ()

-- | auto generated document.
defaultDocumentationAction :: Monad m => DefaultDocumentConfig -> ActionT exts prms m ()
data DefaultDocumentConfig
DefaultDocumentConfig :: Text -> Maybe Html -> Bool -> Maybe Text -> DefaultDocumentConfig
documentTitle :: DefaultDocumentConfig -> Text
documentDescription :: DefaultDocumentConfig -> Maybe Html
documentUseCDN :: DefaultDocumentConfig -> Bool

-- | google analytics. since 0.17.0.
documentGoogleAnalytics :: DefaultDocumentConfig -> Maybe Text
type ContentType = ByteString

-- | stop with response. since 0.4.2.0.
stopWith :: Monad m => Response -> ActionT exts prms m a
applyDict :: Dict prms -> ActionT exts prms m a -> ActionT exts [] m a

-- | get raw request. since 0.1.0.0.
getRequest :: Monad m => ActionT exts prms m Request

-- | get all request headers. since 0.6.0.0.
getHeaders :: Monad m => ActionT exts prms m RequestHeaders
getParams :: Monad m => ActionT exts prms m (Dict prms)
getQueryParams :: Monad m => ActionT exts prms m Query
data RequestBody

-- | raw body
Unknown :: ByteString -> RequestBody
UrlEncoded :: [Param] -> [File] -> RequestBody

-- | boundary params files
Multipart :: {-# UNPACK #-} !ByteString -> [Param] -> [File] -> RequestBody

-- | parse request body and return it. since 1.2.2.
getReqBody :: MonadIO m => ActionT exts prms m RequestBody

-- | parse request body and return params. since 1.0.0.
getReqBodyParams :: MonadIO m => ActionT exts prms m [Param]

-- | parse request body and return files. since 0.9.0.0.
getReqBodyFiles :: MonadIO m => ActionT exts prms m [File]

-- | send file contents as lazy bytestring response. since v1.1.4.
devFile :: MonadIO m => FilePath -> ActionT exts prms m ()
devFile' :: MonadIO m => FilePath -> ActionT exts prms m ()

-- | set response body source. since 0.9.0.0.
stream :: Monad m => StreamingBody -> ActionT exts prms m ()

-- | set raw response constructor. since 0.10.
--   
--   example(use pipes-wai)
--   
--   <pre>
--   producer :: Monad m =&gt; Producer (Flush Builder) IO () -&gt; ActionT' exts m ()
--   producer = response (s h -&gt; responseProducer s h)
--   </pre>
rawResponse :: Monad m => (Status -> ResponseHeaders -> Response) -> ActionT exts prms m ()

-- | Represents a streaming HTTP response body. It's a function of two
--   parameters; the first parameter provides a means of sending another
--   chunk of data, and the second parameter provides a means of flushing
--   the data to the client.
--   
--   Since 3.0.0
type StreamingBody = (Builder -> IO ()) -> IO () -> IO ()

-- | lookup extensional state. since v1.2.0.
lookupVault :: Key a -> ActionT exts prms m (Maybe a)

-- | modify extensional state. since v1.2.0.
modifyVault :: (Vault -> Vault) -> ActionT exts prms m ()

-- | insert extensional state. since v1.2.0.
insertVault :: Key a -> a -> ActionT exts prms m ()

-- | adjust extensional state. since v1.2.0.
adjustVault :: (a -> a) -> Key a -> ActionT exts prms m ()

-- | delete extensional state. since v1.2.0.
deleteVault :: Key a -> ActionT exts prms m ()

-- | redirect handler
--   
--   set status and add location header. since 0.3.3.0.
--   
--   rename from redirect in 0.6.2.0.
redirectWith :: Monad m => Status -> ByteString -> ActionT exts prms m ()

module Control.Monad.Apiary.Filter.Capture

-- | check first path and drill down. since 0.11.0.
path :: Monad actM => Text -> Filter' exts actM m
fetch :: (k </ prms, KnownSymbol k, Path p, Monad actM) => proxy (k := p) -> Maybe Html -> Filter exts actM m prms ((k := p) : prms)

-- | get first path and drill down. since 0.11.0.
fetch' :: (k </ prms, KnownSymbol k, Path p, Monad actM) => proxy k -> proxy' p -> Maybe Html -> Filter exts actM m prms ((k := p) : prms)
anyPath :: (Monad m, Monad actM) => Filter' exts actM m
restPath :: (k </ prms, KnownSymbol k, Monad m, Monad actM) => proxy k -> Maybe Html -> Filter exts actM m prms ((k := [Text]) : prms)

module Control.Monad.Apiary.Filter

-- | routing filter
type Filter exts actM m inp out = ApiaryT exts out actM m () -> ApiaryT exts inp actM m ()

-- | routing filter(without modify parameter dictionary)
type Filter' exts actM m = forall prms. Filter exts actM m prms prms

-- | filter by HTTP method. since 0.1.0.0.
--   
--   <pre>
--   method GET      -- stdmethod
--   method "HOGE" -- non standard method
--   </pre>
method :: Monad actM => Method -> Filter' exts actM m

-- | http/0.9 only accepted fiter. since 0.5.0.0.
http09 :: Monad actM => Filter' exts actM m

-- | http/1.0 only accepted fiter. since 0.5.0.0.
http10 :: Monad actM => Filter' exts actM m

-- | http/1.1 only accepted fiter. since 0.5.0.0.
http11 :: Monad actM => Filter' exts actM m

-- | filter by <a>rootPattern</a> of <a>ApiaryConfig</a>.
root :: (Monad m, Monad actM) => Filter' exts actM m

-- | capture QuasiQuoter. since 0.1.0.0.
--   
--   example:
--   
--   <pre>
--   [capture|/path|] -- first path == "path"
--   [capture|/int/foo::Int|] -- first path == "int" &amp;&amp; get 2nd path as Int.
--   [capture|/bar::Int/baz::Double|] -- get first path as Int and get 2nd path as Double.
--   [capture|/**baz|] -- feed greedy and get all path as [Text] (since 0.17.0). 
--   </pre>
--   
--   this QQ can convert pure function easily.
--   
--   <pre>
--   [capture|<i>foo</i>foo::Int|]        == path "path" . fetch (Proxy :: Proxy ("foo" := Int)) . endPath
--   [capture|<i>bar</i>bar::Int/**rest|] == path "path" . fetch (Proxy :: Proxy ("foo" := Int)) . restPath (Proxy :: Proxy "rest")
--   </pre>
capture :: QuasiQuoter

-- | add document to query parameter filter.
--   
--   <pre>
--   [key|key|] ?? "document" =: pInt
--   </pre>
(??) :: proxy key -> Html -> QueryKey key

-- | get first matched paramerer. since 0.5.0.0.
--   
--   <pre>
--   [key|key|] =: pInt
--   </pre>
(=:) :: (HasDesc query, MonadIO actM, ReqParam v, KnownSymbol k, k </ prms) => query k -> proxy v -> Filter exts actM m prms ((k := v) : prms)

-- | get one matched paramerer. since 0.5.0.0.
--   
--   when more one parameger given, not matched.
--   
--   <pre>
--   [key|key|] =!: pInt
--   </pre>
(=!:) :: (HasDesc query, MonadIO actM, ReqParam v, KnownSymbol k, k </ prms) => query k -> proxy v -> Filter exts actM m prms ((k := v) : prms)

-- | get optional first paramerer. since 0.5.0.0.
--   
--   when illegal type parameter given, fail match(don't give Nothing).
--   
--   <pre>
--   [key|key|] =?: pInt
--   </pre>
(=?:) :: (HasDesc query, MonadIO actM, ReqParam v, KnownSymbol k, k </ prms) => query k -> proxy v -> Filter exts actM m prms ((k := Maybe v) : prms)

-- | get optional first paramerer with default. since 0.16.0.
--   
--   when illegal type parameter given, fail match(don't give Nothing).
--   
--   <pre>
--   [key|key|] =!?: (0 :: Int)
--   </pre>
(=?!:) :: (HasDesc query, MonadIO actM, Show v, ReqParam v, KnownSymbol k, k </ prms) => query k -> v -> Filter exts actM m prms ((k := v) : prms)

-- | get many paramerer. since 0.5.0.0.
--   
--   <pre>
--   [key|key|] =*: pInt
--   </pre>
(=*:) :: (HasDesc query, MonadIO actM, ReqParam v, KnownSymbol k, k </ prms) => query k -> proxy v -> Filter exts actM m prms ((k := [v]) : prms)

-- | get some paramerer. since 0.5.0.0.
--   
--   <pre>
--   [key|key|] =+: pInt
--   </pre>
(=+:) :: (HasDesc query, MonadIO actM, ReqParam v, KnownSymbol k, k </ prms) => query k -> proxy v -> Filter exts actM m prms ((k := [v]) : prms)

-- | get existance of key only query parameter. since v0.17.0.
switchQuery :: (HasDesc proxy, MonadIO actM, KnownSymbol k, k </ prms) => proxy k -> Filter exts actM m prms ((k := Bool) : prms)

-- | check whether to exists specified valued header or not. since 0.6.0.0.
eqHeader :: (KnownSymbol k, Monad actM) => proxy k -> ByteString -> Filter' exts actM m

-- | filter by header and get first. since 0.6.0.0.
header :: (KnownSymbol k, Monad actM, k </ prms) => proxy k -> Filter exts actM m prms ((k := ByteString) : prms)

-- | require Accept header and set response Content-Type. since 0.16.0.
accept :: Monad actM => ContentType -> Filter' exts actM m

-- | filter by ssl accessed. since 0.1.0.0.
ssl :: Monad actM => Filter' exts actM m
class HasDesc (a :: Symbol -> *)
queryDesc :: HasDesc a => a key -> Maybe Html
newtype QueryKey (key :: Symbol)
QueryKey :: Maybe Html -> QueryKey
queryKeyDesc :: QueryKey -> Maybe Html
query :: (k </ prms, MonadIO actM, KnownSymbol k, ReqParam v, HasDesc query, Strategy strategy) => query k -> strategy v -> Filter exts actM m prms (SNext strategy k v prms)

-- | http version filter. since 0.5.0.0.
httpVersion :: Monad actM => HttpVersion -> Html -> Filter' exts actM m

-- | low level filter function.
function :: Monad actM => (Doc -> Doc) -> (Store prms -> Request -> Maybe (Store prms')) -> Filter exts actM m prms prms'

-- | filter and append argument.
function' :: (KnownSymbol key, Monad actM, key </ prms) => (Doc -> Doc) -> (Request -> Maybe (proxy key, prm)) -> Filter exts actM m prms ((key := prm) : prms)

-- | filter only(not modify arguments).
function_ :: Monad actM => (Doc -> Doc) -> (Request -> Bool) -> Filter' exts actM m

-- | filter by action. since 1.3.0.
focus :: Monad actM => (Doc -> Doc) -> Maybe Method -> (Path prms' (ActionT exts [] actM) () -> Path prms (ActionT exts [] actM) ()) -> Filter exts actM m prms prms'
data Doc
DocRoot :: Doc -> Doc
DocMethod :: Method -> Doc -> Doc
DocQuery :: Text -> StrategyRep -> QueryRep -> (Maybe Html) -> Doc -> Doc
DocPrecondition :: Html -> Doc -> Doc
DocAccept :: ByteString -> Doc -> Doc
instance HasDesc SProxy
instance HasDesc Proxy
instance HasDesc QueryKey

module Control.Monad.Apiary

-- | Apiary monad. since 0.8.0.0.
data ApiaryT exts prms actM m a

-- | run Apiary monad.
runApiaryTWith :: (Monad actM, Monad m) => (forall b. actM b -> IO b) -> (Application -> m a) -> Initializer m [] exts -> ApiaryConfig -> ApiaryT exts [] actM m () -> m a
runApiaryWith :: Monad m => (Application -> m a) -> Initializer m [] exts -> ApiaryConfig -> ApiaryT exts [] IO m () -> m a
runApiary :: Monad m => (Application -> m a) -> ApiaryConfig -> ApiaryT [] [] IO m () -> m a
data ApiaryConfig
ApiaryConfig :: Application -> Status -> ResponseHeaders -> ByteString -> Status -> ResponseHeaders -> [Text] -> (FilePath -> ByteString) -> ApiaryConfig

-- | call when no handler matched.
notFound :: ApiaryConfig -> Application

-- | used unless call <a>status</a> function.
defaultStatus :: ApiaryConfig -> Status

-- | initial headers.
defaultHeaders :: ApiaryConfig -> ResponseHeaders
defaultContentType :: ApiaryConfig -> ByteString
failStatus :: ApiaryConfig -> Status
failHeaders :: ApiaryConfig -> ResponseHeaders

-- | used by <a>root</a> filter.
rootPattern :: ApiaryConfig -> [Text]
mimeType :: ApiaryConfig -> FilePath -> ByteString

-- | splice ActionT to ApiaryT.
action :: Monad actM => ActionT exts prms actM () -> ApiaryT exts prms actM m ()

-- | add middleware.
middleware :: Monad actM => Middleware -> ApiaryT exts prms actM m ()

-- | API document group. since 0.12.0.0.
--   
--   only top level group recognized.
group :: Text -> Filter' exts actM m

-- | add API document. since 0.12.0.0.
--   
--   It use only filters prior document, so you should be placed document
--   directly in front of action.
document :: Text -> Filter' exts actM m

-- | add user defined precondition. since 0.13.0.
precondition :: Html -> Filter' exts actM m

-- | ignore next document.
noDoc :: Filter' exts actM m

-- | get Apiary configuration.
apiaryConfig :: Monad actM => ApiaryT exts prms actM m ApiaryConfig

-- | get Apiary extension.

-- | <i>Deprecated: use getExt</i>
apiaryExt :: (Has e exts, Monad actM) => proxy e -> ApiaryT exts prms actM m e

module Web.Apiary.Heroku
data Heroku
data HerokuConfig
HerokuConfig :: Int -> String -> Maybe String -> ApiaryConfig -> HerokuConfig
defaultPort :: HerokuConfig -> Int
herokuExecutableName :: HerokuConfig -> String
herokuAppName :: HerokuConfig -> Maybe String
herokuApiaryConfig :: HerokuConfig -> ApiaryConfig

-- | use this function instead of runApiary in heroku app. since 0.18.0.
--   
--   this function provide:
--   
--   <ul>
--   <li>set port by PORT environment variable.</li>
--   <li>getHerokuEnv function(get config from environment variable or <tt>
--   heroku config </tt> command).</li>
--   </ul>
runHeroku :: MonadIO m => (Int -> Application -> m a) -> HerokuConfig -> ApiaryT '[Heroku] [] IO m () -> m a
runHerokuWith :: MonadIO m => (Int -> Application -> m a) -> Initializer m '[Heroku] exts -> HerokuConfig -> ApiaryT exts [] IO m () -> m a

-- | use this function instead of serverWith in heroku app. since 0.17.0.
--   
--   <pre>
--   runApiaryTWith id (run 3000) exts def $ foo
--   </pre>
--   
--   to
--   
--   <pre>
--   runHerokuTWith id  run       exts def $ foo
--   </pre>
runHerokuTWith :: (MonadIO m, Monad actM) => (forall b. actM b -> IO b) -> (Int -> Application -> m a) -> Initializer m '[Heroku] exts -> HerokuConfig -> ApiaryT exts [] actM m () -> m a
getHerokuEnv :: Has Heroku exts => Text -> Extensions exts -> IO (Maybe Text)
getHerokuEnv' :: Text -> Heroku -> IO (Maybe Text)
instance Default HerokuConfig
instance Extension Heroku

module Web.Apiary

-- | construct string literal proxy.
--   
--   <pre>
--   [key|foo|] == (Proxy :: Proxy "foo")
--   </pre>
key :: QuasiQuoter


-- | <i>Warning: use Web.Apiary in production.</i>
module Web.Apiary.Develop

-- | send file contents as lazy bytestring response with detect
--   Content-Type. since v1.2.0.
file :: MonadIO m => FilePath -> Maybe FilePart -> ActionT exts prms m ()

-- | send file contents as lazy bytestring response. since v1.2.0.
file' :: MonadIO m => FilePath -> Maybe FilePart -> ActionT exts prms m ()
