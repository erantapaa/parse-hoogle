-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Polymorphic functions to build and combine stringlike values
--   
--   <tt>string-combinators</tt> provides handy polymorphic functions to
--   build and combine string-like values.
--   
--   All functions are polymorphic in their string-like type but usually
--   have a <a>Monoid</a> or <a>IsString</a> constraint.
@package string-combinators
@version 0.6.0.5


module Data.String.Combinators

-- | An infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m

-- | <tt>mid m x y</tt> Puts <tt>x</tt> and <tt>y</tt> around <tt>m</tt>.
--   
--   Note that: <tt>mid m x y = <a>between</a> x y m</tt>.
mid :: Monoid s => s -> (s -> s -> s)

-- | Put two string-likes besides eachother separated by a <a>space</a>.
(<+>) :: (Monoid s, IsString s) => s -> s -> s

-- | Put two string-likes above eachother (separated by a <a>newline</a>).
($$) :: (Monoid s, IsString s) => s -> s -> s

-- | Combine the string-likes with a given function.
--   
--   <pre>
--   intercalate f [s1, ... sn] = s1 `f` (s2 `f` (... (sn-1 `f` sn)))
--   </pre>
intercalate :: Monoid s => (s -> s -> s) -> [s] -> s

-- | List version of <a>&lt;&gt;</a>.
--   
--   Note that: <tt>hcat = <a>intercalate</a> (<a>&lt;&gt;</a>)</tt>.
hcat :: Monoid s => [s] -> s

-- | List version of <a>&lt;+&gt;</a>.
--   
--   Note that: <tt>unwords = <a>intercalate</a> (<a>&lt;+&gt;</a>)</tt>.
unwords :: (Monoid s, IsString s) => [s] -> s

-- | List version of <a>$$</a>.
--   
--   Note that: <tt>unlines = foldr (<a>$$</a>) mempty</tt>
unlines :: (Monoid s, IsString s) => [s] -> s

-- | <tt>punctuate p [s1, ... sn] = [s1 <a>&lt;&gt;</a> p, s2
--   <a>&lt;&gt;</a> p, ... sn-1 <a>&lt;&gt;</a> p, sn]</tt>.
--   
--   (Idea and implementation taken from the <tt>pretty</tt> package.)
punctuate :: Monoid s => s -> [s] -> [s]

-- | <tt>between b c s</tt> wraps the string-like <tt>s</tt> between
--   <tt>b</tt> and <tt>c</tt>.
between :: Monoid s => s -> s -> (s -> s)

-- | Wrap a string-like in <tt>(...)</tt>.
parens :: (Monoid s, IsString s) => s -> s

-- | Like <tt>showParen</tt> conditionally wraps a string-like in
--   <tt>(...)</tt>
--   
--   This function is supposed to be used infix as in:
--   
--   <pre>
--   (precedence &gt;= 10) `thenParens` ("fun" &lt;+&gt; "arg")
--   </pre>
thenParens :: (Monoid s, IsString s) => Bool -> s -> s

-- | Wrap a string-like in <tt>[...]</tt>.
brackets :: (Monoid s, IsString s) => s -> s

-- | Wrap a string-like in <tt>{...}</tt>.
braces :: (Monoid s, IsString s) => s -> s

-- | Wrap a string-like in <tt>&lt;...&gt;</tt>.
angleBrackets :: (Monoid s, IsString s) => s -> s

-- | Wrap a string-like in <tt>'...'</tt>.
quotes :: (Monoid s, IsString s) => s -> s

-- | Wrap a string-like in <tt>"..."</tt>.
doubleQuotes :: (Monoid s, IsString s) => s -> s

-- | Convert a character to a string-like.
char :: IsString s => Char -> s

-- | A ';' character.
semi :: IsString s => s

-- | A <tt>:</tt> character.
colon :: IsString s => s

-- | A ',' character.
comma :: IsString s => s

-- | A ' ' character.
space :: IsString s => s

-- | A '\n' character.
newline :: IsString s => s

-- | A '=' character.
equals :: IsString s => s

-- | A '(' character.
lparen :: IsString s => s

-- | A ')' character.
rparen :: IsString s => s

-- | A '[' character.
lbrack :: IsString s => s

-- | A ']' character.
rbrack :: IsString s => s

-- | A '{' character.
lbrace :: IsString s => s

-- | A '}' character.
rbrace :: IsString s => s

-- | A '&lt;' character.
labrack :: IsString s => s

-- | A '&gt;' character.
rabrack :: IsString s => s

-- | Convert a <tt>Show</tt>able value to a string-like.
fromShow :: (Show a, IsString s) => a -> s

-- | Convert an <tt>Int</tt> to a string-like.
int :: IsString s => Int -> s

-- | Convert an <tt>Integer</tt> to a string-like.
integer :: IsString s => Integer -> s

-- | Convert a <tt>Float</tt> to a string-like.
float :: IsString s => Float -> s

-- | Convert a <tt>Double</tt> to a string-like.
double :: IsString s => Double -> s

-- | Convert a <tt>Rational</tt> to a string-like.
rational :: IsString s => Rational -> s
