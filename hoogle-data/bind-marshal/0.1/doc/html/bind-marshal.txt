-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data marshaling library that uses type level equations to optimize buffering.
--   
--   A (in development) high performance data marshaling layer for haskell.
--   Uses a pair of parameterized monads to represent: Data marshalling
--   actions with static buffering requirements (EG: Needs no more than 100
--   bytes available to succeed) ; Data marshalling actions that are a
--   dynamic composition of actions with static buffering requirements.
@package bind-marshal
@version 0.1

module Bind.Marshal.TypePrelude
data Nil
data Cons t ts
class ReifiesTo t r
reify :: ReifiesTo t r => t -> r
instance ReifiesTo t t


-- | All rights reserved.
--   
--   Redistribution and use in source and binary forms, with or without
--   modification, are permitted provided that the following conditions are
--   met:
--   
--   <ul>
--   <li>Redistributions of source code must retain the above copyright
--   notice, this list of conditions and the following disclaimer. *
--   Redistributions in binary form must reproduce the above copyright
--   notice, this list of conditions and the following disclaimer in the
--   documentation and/or other materials provided with the
--   distribution.</li>
--   </ul>
--   
--   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
--   <a>AS IS</a> AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
--   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
--   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
--   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
--   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
--   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
--   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
--   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
--   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
--   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--   
--   monad-param Maintainer : Edward Kmett <a>ekmett@gmail.com</a>
--   Bind.Marshal Maintainer : Corey O'Connor <a>coreyoconnor@gmail.com</a>
--   Stability : experimental Portability : non-portable (requires the
--   kitchen sink)
--   
--   Implements a notion of parameterized monad by varying the monad
--   itself, this lets us avoid having to carry a parameter around for
--   monads that do not need it, and we can rederive the normal notion of a
--   parameterized monad from this variation for those that do. The
--   signature of <a>&gt;&gt;=</a> costs us type inference for the types of
--   <a>return</a> and <a>mzero</a>, so we restore that by defining
--   <a>return</a> as the unit of the <a>Identity</a> monad and
--   <a>mzero</a> as the unit of the trivial bottom monad, and appealing to
--   the monad laws to allow these to combine with all other monads
--   satisfying the monad laws through <a>&gt;&gt;=</a>
--   
--   This imports and defines the correct instances for a good portion of
--   the <tt>monads-tf</tt>, primarily because it is so awkward to import
--   them all otherwise due to the fact that most of them re-export the
--   <tt>Control.Monad.Monad</tt> syntax. Does not export
--   <a>Control.Monad.ST</a> or <a>Control.Monad.Writer</a> since it is
--   unclear if you want strict or lazy versions in scope
module Bind.Marshal.Control.Monad.Parameterized

-- | The traditional <a>return</a>, note this probably has lost its type
--   inference where you want to use it.
class Return m
returnM :: Return m => a -> m a

-- | Restrict the cases where we allow pattern matching to <a>fail</a>. You
--   have to explicitly supply this for your <a>Monad</a>
class Fail m
fail :: Fail m => String -> m a

-- | Implement parameterized monads like Oleg's restricted monads, but vary
--   the monad itself rather than restrict its parameters
class (Functor m, Functor m', Functor m'') => Bind m m' m'' | m m' -> m''
(>>=) :: Bind m m' m'' => m a -> (a -> m' b) -> (m'' b)
(>>) :: Bind m m' m'' => m a -> m' b -> m'' b
(=<<) :: Bind m m' m'' => (a -> m' b) -> m a -> m'' b

-- | Break out mplus
class MPlus m m' m'' | m m' -> m''
mplus :: MPlus m m' m'' => m a -> m' a -> m'' a

-- | Traditional <tt>Control.Monad.mzero</tt>, note this probably has lost
--   its type inference. You probably want <a>mzero</a>.
class MonadZero m
mzeroM :: MonadZero m => m a

-- | Same trick using with <a>Identity</a> to build a canonical
--   <a>return</a>, here we exploit the <a>MonadPlus</a> laws to make a
--   canonical <a>mzero</a>. Has no members except bottom.
data MZero a

-- | When a parameterized monad can be used without varying its parameter,
--   we can get the ease of use of the original <tt>Monad</tt> class.
class (Fail m, Return m, Bind m m m) => Monad m

-- | Class alias to get back an approximation of the original,
--   easy-to-specify <a>MonadPlus</a> class where available
class (MPlus m m m, MonadZero m) => MonadPlus m

-- | Now of course we can have <a>MZero</a>s and <a>Identity</a>s float to
--   the top of a <tt>do</tt> expression, so we need a way to convert them
--   to any <a>Monad</a> or <a>MonadPlus</a> instance respectively
class Go n m
go :: Go n m => n a -> m a

-- | An inferable version of <tt>Prelude.return</tt>
return :: a -> Identity a

-- | An inferable version of <tt>Control.Monad.mzero</tt>
mzero :: MZero a

-- | <tt><a>mapM</a> f</tt> is equivalent to <tt><a>sequence</a> .
--   <a>map</a> f</tt>.
mapM :: Monad m => (a -> m b) -> [a] -> m [b]

-- | <tt><a>mapM_</a> f</tt> is equivalent to <tt><a>sequence_</a> .
--   <a>map</a> f</tt>.
mapM_ :: Monad m => (a -> m b) -> [a] -> m ()

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped
forM :: Monad m => [a] -> (a -> m b) -> m [b]

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped
forM_ :: Monad m => [a] -> (a -> m b) -> m ()

-- | Evaluate each action in the sequence from left to right, and collect
--   the results.
sequence :: Monad m => [m a] -> m [a]

-- | Evaluate each action in the sequence from left to right, and ignore
--   the results.
sequence_ :: Monad m => [m a] -> m ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
join :: Monad m => m (m a) -> m a

-- | This generalizes the list-based <a>concat</a> function.
msum :: MonadPlus m => [m a] -> m a

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state-transforming monad.
mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   monads.
zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Monad m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Monad m => Int -> m a -> m ()

-- | <tt><a>guard</a> b</tt> is <tt><a>return</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>mzero</a> if <tt>b</tt> is <a>False</a>.
guard :: MonadPlus m => Bool -> m ()

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()

-- | The reverse of <a>when</a>.
unless :: Monad m => Bool -> m () -> m ()

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b
instance [overlap ok] Bind [] IO (ListT IO)
instance [overlap ok] Bind IO STM IO
instance [overlap ok] Bind STM IO IO
instance [overlap ok] Bind [] Maybe []
instance [overlap ok] Bind Maybe [] []
instance [overlap ok] (Functor m, Monad m) => Bind (ContT r m) (ContT r m) (ContT r m)
instance [overlap ok] Monad m => Fail (ContT r m)
instance [overlap ok] Monad m => Return (ContT r m)
instance [overlap ok] (Monad m, Error e) => MPlus (ErrorT e m) (ErrorT e m) (ErrorT e m)
instance [overlap ok] (Monad m, Error e) => MonadZero (ErrorT e m)
instance [overlap ok] (Functor m, Monad m, Error e) => Bind (ErrorT e m) (ErrorT e m) (ErrorT e m)
instance [overlap ok] (Monad m, Error e) => Fail (ErrorT e m)
instance [overlap ok] (Monad m, Error e) => Return (ErrorT e m)
instance [overlap ok] (Functor m, Monad m, Monoid w) => Bind (WriterT w m) (WriterT w m) (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => Fail (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => Return (WriterT w m)
instance [overlap ok] (Functor m, Monad m, Monoid w) => Bind (WriterT w m) (WriterT w m) (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => Fail (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => Return (WriterT w m)
instance [overlap ok] (Functor m, Monad m) => Bind (ReaderT e m) (ReaderT e m) (ReaderT e m)
instance [overlap ok] Monad m => Fail (ReaderT e m)
instance [overlap ok] Monad m => Return (ReaderT e m)
instance [overlap ok] (Functor m, Monad m) => Bind (StateT s m) (StateT s m) (StateT s m)
instance [overlap ok] Monad m => Fail (StateT s m)
instance [overlap ok] Monad m => Return (StateT s m)
instance [overlap ok] Monad m => MPlus (ListT m) (ListT m) (ListT m)
instance [overlap ok] Monad m => MonadZero (ListT m)
instance [overlap ok] (Functor m, Monad m) => Bind (ListT m) (ListT m) (ListT m)
instance [overlap ok] Monad m => Fail (ListT m)
instance [overlap ok] Monad m => Return (ListT m)
instance [overlap ok] Monoid w => Bind (Writer w) (Writer w) (Writer w)
instance [overlap ok] Monoid w => Fail (Writer w)
instance [overlap ok] Monoid w => Return (Writer w)
instance [overlap ok] Monoid w => Bind (Writer w) (Writer w) (Writer w)
instance [overlap ok] Monoid w => Fail (Writer w)
instance [overlap ok] Monoid w => Return (Writer w)
instance [overlap ok] Bind (ST s) (ST s) (ST s)
instance [overlap ok] Fail (ST s)
instance [overlap ok] Return (ST s)
instance [overlap ok] Bind (ST s) (ST s) (ST s)
instance [overlap ok] Fail (ST s)
instance [overlap ok] Return (ST s)
instance [overlap ok] Bind (Cont r) (Cont r) (Cont r)
instance [overlap ok] Fail (Cont r)
instance [overlap ok] Return (Cont r)
instance [overlap ok] Bind (Reader e) (Reader e) (Reader e)
instance [overlap ok] Fail (Reader e)
instance [overlap ok] Return (Reader e)
instance [overlap ok] Bind (State s) (State s) (State s)
instance [overlap ok] Fail (State s)
instance [overlap ok] Return (State s)
instance [overlap ok] Bind IO IO IO
instance [overlap ok] Fail IO
instance [overlap ok] Return IO
instance [overlap ok] Bind STM STM STM
instance [overlap ok] Fail STM
instance [overlap ok] Return STM
instance [overlap ok] MPlus [] [] []
instance [overlap ok] MonadZero []
instance [overlap ok] Bind [] [] []
instance [overlap ok] Fail []
instance [overlap ok] Return []
instance [overlap ok] MPlus Maybe Maybe Maybe
instance [overlap ok] MonadZero Maybe
instance [overlap ok] Bind Maybe Maybe Maybe
instance [overlap ok] Fail Maybe
instance [overlap ok] Return Maybe
instance [overlap ok] (MPlus m m m, MonadZero m) => MonadPlus m
instance [overlap ok] Return MZero
instance [overlap ok] Return Identity
instance [overlap ok] Go a a
instance [overlap ok] MonadZero a => Go MZero a
instance [overlap ok] Return a => Go Identity a
instance [overlap ok] Bind MZero Identity MZero
instance [overlap ok] Bind Identity MZero MZero
instance [overlap ok] Bind MZero MZero MZero
instance [overlap ok] Functor a => Bind MZero a MZero
instance [overlap ok] MPlus MZero MZero MZero
instance [overlap ok] MPlus a MZero a
instance [overlap ok] MPlus MZero a a
instance [overlap ok] Functor MZero
instance [overlap ok] (Fail m, Return m, Bind m m m) => Monad m
instance [overlap ok] Bind Identity Identity Identity
instance [overlap ok] Functor a => Bind a Identity a
instance [overlap ok] Functor a => Bind Identity a a

module Bind.Marshal.Prelude
type Size = Int
data Length
Length :: Size -> Length
unLength :: Length -> Size
type BytePtr = Ptr Word8
instance Show Length
instance Eq Length
instance Ord Length
instance ReifiesTo tSeq Length => ReifiesTo (Cons t tSeq) Length
instance ReifiesTo Nil Length

module Bind.Marshal.DataModel.Base
data StaticModel size

module Bind.Marshal.DataModel
data DynamicModel
DynamicModel :: ActionSeq -> DynamicModel
action_seq :: DynamicModel -> ActionSeq
data ActionSeq
data ActionDesc
DesAction :: Size -> ActionDesc
SerAction :: Size -> ActionDesc
data Model tModel
Model :: DynamicModel -> Model tModel
dynamic_model :: Model tModel -> DynamicModel

module Bind.Marshal.Action.Base

-- | All actions have a buffering requirement. In the case of an action
--   with a static data model the buffer requirement is the memory required
--   by the marshaled data. XXX: All actions? Maybe easier to just have a
--   StaticBufferReq that is only defined for static buffer actions.
data BufferRegion tag
BufferRegion :: {-# UNPACK #-} !BytePtr -> {-# UNPACK #-} !Size -> BufferRegion tag
buffer_region_start :: BufferRegion tag -> {-# UNPACK #-} !BytePtr
buffer_region_size :: BufferRegion tag -> {-# UNPACK #-} !Size
buffer_region_end :: BufferRegion tag -> BytePtr
pop_bytes :: BufferRegion tag -> Size -> BufferRegion tag
type Iter = Ptr Word8
instance NFData (BufferRegion tag)


-- | A memory action that operates on a statically sized buffer. -
module Bind.Marshal.Action.Static
type StaticIter r = Addr# -> IO r

-- | A buffer static memory action. When executed:
newtype StaticMemAction buffer_iter_tag size a
StaticMemAction :: (forall c. (a -> StaticIter c) -> (String -> IO c) -> StaticIter c) -> StaticMemAction buffer_iter_tag size a
static_eval :: StaticMemAction buffer_iter_tag size a -> forall c. (a -> StaticIter c) -> (String -> IO c) -> StaticIter c
io_eval_static :: StaticMemAction tag size a -> Iter -> IO (a, Iter)
static_replicateM :: (Pos n, size_2 ~ (Add size_0 (Mul n size_1)), Bind (StaticMemAction tag size_0) (StaticMemAction tag size_1) (StaticMemAction tag size_2)) => n -> StaticMemAction tag size_1 a -> StaticMemAction tag size_2 [a]
instance Functor (StaticMemAction buffer_iter_tag size)

module Bind.Marshal.Action.Monad.Static
static_return :: a -> StaticMemAction tag D0 a
instance (size_2 ~ Add size_0 size_1, buffer_0 ~ buffer_1, buffer_0 ~ buffer_2) => Bind (StaticMemAction buffer_0 size_0) (StaticMemAction buffer_1 size_1) (StaticMemAction buffer_2 size_2)
instance Fail (StaticMemAction tag m)
instance m ~ D0 => Return (StaticMemAction tag m)

module Bind.Marshal.DesAction.Base
data DesTag
type DesBuffer = BufferRegion DesTag
type DeserializeAction t = Addr# -> IO t
class CanDeserialize t
deserialize :: CanDeserialize t => DeserializeAction t

module Bind.Marshal.DesAction.Static
type StaticDesAction size a = StaticMemAction DesTag size a

-- | <a>des</a> is a deserialization action that has a static buffer
--   requirement. However the resulting action monad of a <a>des</a> can be
--   dynamic or static.
des :: (CanDeserialize t, Nat (BufferReq t)) => StaticDesAction (BufferReq t) t

-- | To execute a deserialization action: - determine the final data model
--   of the deserialization action monad by fixing the initial data model
--   as DMNil. - evaluate the action via CPS
apply_des_to_fixed_buffer :: (NFData out_type, Nat size) => StaticDesAction size out_type -> DesBuffer -> IO (out_type, DesBuffer)
apply_des_to_fixed_buffer_unsafe :: StaticDesAction size out_type -> DesBuffer -> IO (out_type, DesBuffer)

module Bind.Marshal.DesAction.Storable
deserialize_storable :: (NFData t, Storable t) => Addr# -> IO t

module Bind.Marshal.SerAction.Base
data SerTag
type SerBuffer = BufferRegion SerTag
type SerializeAction t = t -> Addr# -> IO ()
class CanSerialize t
serialize :: CanSerialize t => SerializeAction t

module Bind.Marshal.StaticProperties
marshalled_byte_count :: Nat size => StaticMemAction buffer_iter_tag size out_type -> Size

module Bind.Marshal.Action.Dynamic

-- | All Dynamic memory actions have either a sealed buffer size
--   requirement or an open buffer size requirement.
data Sealed

-- | An open buffering requirement means that the pre-buffering or
--   post-buffering requirement is not handled by the dynamic memory
--   action.
data Open n

-- | A dynamic memory action a buffer handler action optionally paired with
--   a statically defined pre buffer action and/or post buffer action.
--   
--   A pre buffer action exists iff the type level pre buffer size
--   requirement is Open n. A post buffer action exists iff the type level
--   post buffer size requirement is Open n.
class BufferDelegate buffer_delegate
gen_region :: BufferDelegate buffer_delegate => Size -> buffer_delegate -> IO (BDIter buffer_delegate)
finalize_region :: BufferDelegate buffer_delegate => BDIter buffer_delegate -> IO buffer_delegate
data BDIter bd
BDIter :: {-# UNPACK #-} !Size -> {-# UNPACK #-} !Size -> !bd -> !Addr# -> !Addr# -> BDIter bd
max_bytes_avail :: BDIter bd -> {-# UNPACK #-} !Size
max_bytes_final :: BDIter bd -> {-# UNPACK #-} !Size
buffer_delegate :: BDIter bd -> !bd
start_addr :: BDIter bd -> !Addr#
curr_addr :: BDIter bd -> !Addr#
bytes_final :: BDIter bd -> Size
instance Functor (DynAction (Open n_1) post_ra (Open n_0) bd tag)
instance Functor (DynAction (Open n) post_ra Sealed bd tag)
instance Functor (DynAction Sealed post_ra (Open n) bd tag)
instance Functor (DynAction Sealed Sealed Sealed bd tag)

module Bind.Marshal.DesAction.Dynamic.Base
type DynamicDesAction pre_s post_sa post_s bd a = DynAction pre_s post_sa post_s bd DesTag a

module Bind.Marshal.Action.Monad
returnM_v_bd :: a -> BDIter bd -> IO (a, BDIter bd)
returnM_v_i :: a -> Iter -> IO (a, Iter)
resolve_iter :: BufferDelegate bd => Size -> BDIter bd -> IO (BDIter bd)
dyn_fail :: BufferDelegate bd => String -> DynAction Sealed Sealed Sealed bd tag a

-- | Converts an action to a sealed dynamic memory action value. Possibly
--   inserts gen_region or finalize_region passes.
class SealedDynAction action :: (* -> *) bd where { type family DynActionTag action; }
dyn_action :: SealedDynAction action bd => action a -> DynAction Sealed Sealed Sealed bd (DynActionTag action) a
instance (post_s ~ post_sa, bd_0 ~ bd_1, Nat pre_s, BufferDelegate bd_0) => SealedDynAction (DynAction (Open pre_s) (Open post_sa) (Open post_s) bd_0 tag) bd_1
instance (bd_0 ~ bd_1, post_s_0 ~ post_sa_0, BufferDelegate bd_1) => SealedDynAction (DynAction Sealed (Open post_sa_0) (Open post_s_0) bd_0 tag) bd_1
instance (bd_0 ~ bd_1, BufferDelegate bd_1, Nat pre_s) => SealedDynAction (DynAction (Open pre_s) Sealed Sealed bd_0 tag) bd_1
instance (BufferDelegate bd, Nat size) => SealedDynAction (StaticMemAction tag size) bd
instance (bd_1 ~ bd_0, BufferDelegate bd_1) => SealedDynAction (DynAction Sealed Sealed Sealed bd_0 tag) bd_1
instance BufferDelegate bd => Fail (DynAction Sealed (Open post_sa_0) (Open post_s_0) bd tag)
instance BufferDelegate bd => Fail (DynAction Sealed Sealed Sealed bd tag)
instance (pre_s_2 ~ pre_s_0, post_sa_2 ~ Add post_sa_0 static_size, post_s_0 ~ post_s_2, tag_0 ~ tag_1, tag_1 ~ tag_2, bd_2 ~ bd_0, BufferDelegate bd_2) => Bind (DynAction (Open pre_s_0) (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (StaticMemAction tag_1 static_size) (DynAction (Open pre_s_2) (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (pre_s_2 ~ pre_s_0, post_sa_2 ~ static_size, tag_0 ~ tag_1, tag_1 ~ tag_2, bd_2 ~ bd_0, Nat post_s_2, BufferDelegate bd_2) => Bind (DynAction (Open pre_s_0) Sealed Sealed bd_0 tag_0) (StaticMemAction tag_1 static_size) (DynAction (Open pre_s_2) (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (post_sa_2 ~ Add post_sa_0 static_size, post_s_0 ~ post_s_2, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, BufferDelegate bd_2) => Bind (DynAction Sealed (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (StaticMemAction tag_1 static_size) (DynAction Sealed (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (post_sa_2 ~ static_size, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, Nat post_s_2, BufferDelegate bd_2) => Bind (DynAction Sealed Sealed Sealed bd_0 tag_0) (StaticMemAction tag_1 static_size) (DynAction Sealed (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (pre_s_2 ~ Add static_size pre_s_1, post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, tag_0 ~ tag_1, tag_1 ~ tag_2, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (StaticMemAction tag_0 static_size) (DynAction (Open pre_s_1) (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction (Open pre_s_2) (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (pre_s_2 ~ pre_s_0, post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, post_s_0 ~ Add post_sa_0 pre_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (DynAction (Open pre_s_0) (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (DynAction (Open pre_s_1) (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction (Open pre_s_2) (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (pre_s_2 ~ pre_s_0, post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, Nat pre_s_1, BufferDelegate bd_2) => Bind (DynAction (Open pre_s_0) Sealed Sealed bd_0 tag_0) (DynAction (Open pre_s_1) (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction (Open pre_s_2) (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, post_s_0 ~ Add post_sa_0 pre_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (DynAction Sealed (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (DynAction (Open pre_s_1) (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction Sealed (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, Nat pre_s_1, BufferDelegate bd_2) => Bind (DynAction Sealed Sealed Sealed bd_0 tag_0) (DynAction (Open pre_s_1) (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction Sealed (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (pre_s_2 ~ Add static_size pre_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (StaticMemAction tag_0 static_size) (DynAction (Open pre_s_1) Sealed Sealed bd_1 tag_1) (DynAction (Open pre_s_2) Sealed Sealed bd_1 tag_1)
instance (pre_s_2 ~ pre_s_0, post_s_0 ~ Add post_sa_0 pre_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (DynAction (Open pre_s_0) (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (DynAction (Open pre_s_1) Sealed Sealed bd_1 tag_1) (DynAction (Open pre_s_2) Sealed Sealed bd_2 tag_2)
instance (pre_s_2 ~ pre_s_0, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, Nat pre_s_1, BufferDelegate bd_2) => Bind (DynAction (Open pre_s_0) Sealed Sealed bd_0 tag_0) (DynAction (Open pre_s_1) Sealed Sealed bd_1 tag_1) (DynAction (Open pre_s_2) Sealed Sealed bd_2 tag_2)
instance (post_s_0 ~ Add post_sa_0 pre_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (DynAction Sealed (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (DynAction (Open pre_s_1) Sealed Sealed bd_1 tag_1) (DynAction Sealed Sealed Sealed bd_2 tag_2)
instance (tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, Nat pre_s_1, BufferDelegate bd_2) => Bind (DynAction Sealed Sealed Sealed bd_0 tag_0) (DynAction (Open pre_s_1) Sealed Sealed bd_1 tag_1) (DynAction Sealed Sealed Sealed bd_2 tag_2)
instance (pre_s_2 ~ static_size, post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (StaticMemAction tag_0 static_size) (DynAction Sealed (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction (Open pre_s_2) (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (pre_s_2 ~ pre_s_0, post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, post_s_0 ~ post_sa_0, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (DynAction (Open pre_s_0) (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (DynAction Sealed (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction (Open pre_s_2) (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (pre_s_2 ~ pre_s_0, post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (DynAction (Open pre_s_0) Sealed Sealed bd_0 tag_0) (DynAction Sealed (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction (Open pre_s_2) (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, post_s_0 ~ post_sa_0, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (DynAction Sealed (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (DynAction Sealed (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction Sealed (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (post_sa_2 ~ post_sa_1, post_s_2 ~ post_s_1, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (DynAction Sealed Sealed Sealed bd_0 tag_0) (DynAction Sealed (Open post_sa_1) (Open post_s_1) bd_1 tag_1) (DynAction Sealed (Open post_sa_2) (Open post_s_2) bd_2 tag_2)
instance (pre_s_2 ~ static_size, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_1, BufferDelegate bd_2) => Bind (StaticMemAction tag_0 static_size) (DynAction Sealed Sealed Sealed bd_1 tag_1) (DynAction (Open pre_s_2) Sealed Sealed bd_2 tag_2)
instance (pre_s_2 ~ pre_s_0, post_s_0 ~ post_sa_0, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1) => Bind (DynAction (Open pre_s_0) (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (DynAction Sealed Sealed Sealed bd_1 tag_1) (DynAction (Open pre_s_2) Sealed Sealed bd_2 tag_2)
instance (pre_s_2 ~ pre_s_0, tag_2 ~ tag_0, tag_2 ~ tag_1, bd_2 ~ bd_0, bd_2 ~ bd_1) => Bind (DynAction (Open pre_s_0) Sealed Sealed bd_0 tag_0) (DynAction Sealed Sealed Sealed bd_1 tag_1) (DynAction (Open pre_s_2) Sealed Sealed bd_2 tag_2)
instance (post_s_0 ~ post_sa_0, bd_2 ~ bd_0, bd_2 ~ bd_1, tag_2 ~ tag_0, tag_2 ~ tag_1, BufferDelegate bd_2) => Bind (DynAction Sealed (Open post_sa_0) (Open post_s_0) bd_0 tag_0) (DynAction Sealed Sealed Sealed bd_1 tag_1) (DynAction Sealed Sealed Sealed bd_2 tag_2)
instance (bd_2 ~ bd_0, bd_2 ~ bd_1, tag_2 ~ tag_0, tag_2 ~ tag_1) => Bind (DynAction Sealed Sealed Sealed bd_0 tag_0) (DynAction Sealed Sealed Sealed bd_1 tag_1) (DynAction Sealed Sealed Sealed bd_2 tag_2)
instance BufferDelegate bd => Monad (DynAction Sealed Sealed Sealed bd tag)
instance BufferDelegate bd => Return (DynAction Sealed Sealed Sealed bd tag)

module Bind.Marshal.StdLib.Dynamic.FixedBuffer
fixed_buffer :: BufferRegion tag -> IO (FixedBufferDelegate tag)
data FixedBufferDelegate tag
FixedBufferDelegate :: {-# UNPACK #-} !BufferRegion tag -> FixedBufferDelegate tag
instance BufferDelegate (FixedBufferDelegate tag)

module Bind.Marshal.DesAction.Dynamic
des_from_buffer_delegate_ :: BufferDelegate buffer_delegate => DynamicDesAction Sealed Sealed Sealed buffer_delegate out_type -> buffer_delegate -> IO out_type
des_from_buffer_delegate :: BufferDelegate buffer_delegate => DynamicDesAction Sealed Sealed Sealed buffer_delegate out_type -> buffer_delegate -> IO (out_type, buffer_delegate)

module Bind.Marshal.DesAction

module Bind.Marshal.SerAction.Dynamic.Base
type DynamicSerAction pre_s post_sa post_s bd a = DynAction pre_s post_sa post_s bd SerTag a

module Bind.Marshal.SerAction.Static
type StaticSerAction size a = StaticMemAction SerTag size a
ser :: (CanSerialize t, Nat (BufferReq t)) => t -> StaticSerAction (BufferReq t) ()

-- | To execute a serialization action: - determine the final data model of
--   the serialization action monad by fixing the initial data model as
--   DMNil. - evaluate the action via CPS
apply_ser_to_fixed_buffer :: Nat size => StaticSerAction size out_type -> SerBuffer -> IO (out_type, SerBuffer)
apply_ser_to_fixed_buffer_unsafe :: StaticSerAction size out_type -> SerBuffer -> IO (out_type, SerBuffer)
apply_ser_to_fixed_buffer_unsafe_ :: StaticSerAction size out_type -> SerBuffer -> IO (out_type)

module Bind.Marshal.SerAction.Dynamic
ser_to_buffer_delegate_ :: BufferDelegate buffer_delegate => DynamicSerAction Sealed Sealed Sealed buffer_delegate out_type -> buffer_delegate -> IO out_type
ser_to_buffer_delegate :: BufferDelegate buffer_delegate => DynamicSerAction Sealed Sealed Sealed buffer_delegate out_type -> buffer_delegate -> IO (out_type, buffer_delegate)

module Bind.Marshal.SerAction.Storable
serialize_storable :: Storable t => t -> Addr# -> IO ()

module Bind.Marshal.SerAction

module Bind.Marshal.StdLib.Types

module Bind.Marshal.StdLib.Des
des_word16_be :: StaticDesAction D2 Word16
des_word32_be :: StaticDesAction D4 Word32
instance CanDeserialize Word8
instance CanDeserialize Word16
instance CanDeserialize Word32
instance CanDeserialize Int32

module Bind.Marshal.StdLib.Utils.Des

module Bind.Marshal.StdLib.Ser
ser_word16_be :: Word16 -> StaticSerAction D2 ()
shiftr_w32 :: Word32 -> Int -> Word32
ser_word32_be :: Word32 -> StaticSerAction D4 ()
instance CanSerialize Word32
instance CanSerialize Word16
instance CanSerialize Word8
instance CanSerialize Int32

module Bind.Marshal.StdLib.Utils.Ser

module Bind.Marshal.StdLib.Utils

module Bind.Marshal.Action

module Bind.Marshal.StaticProperties.DesAction

module Bind.Marshal.StaticProperties.SerAction

module Bind.Marshal.StdLib.Dynamic.ByteString.Lazy.Des
decode :: DynamicDesAction Sealed Sealed Sealed LazyBSDes a -> ByteString -> (a, ByteString)
decode_ :: DynamicDesAction Sealed Sealed Sealed LazyBSDes a -> ByteString -> a
with_bytestring_provider :: ByteString -> (LazyBSDes -> IO (a, LazyBSDes)) -> IO (a, ByteString)
instance BufferDelegate LazyBSDes

module Bind.Marshal.StdLib.Dynamic.ByteString.Lazy.Ser
encode :: DynamicSerAction Sealed Sealed Sealed LazyBSSer a -> (a, ByteString)
encode_ :: DynamicSerAction Sealed Sealed Sealed LazyBSSer () -> ByteString
with_bytestring_handler :: ByteString -> (LazyBSSer -> IO (a, LazyBSSer)) -> IO (a, ByteString)
instance BufferDelegate LazyBSSer

module Bind.Marshal.StdLib.Dynamic.ByteString.Lazy

module Bind.Marshal.StdLib

module Bind.Marshal

module Bind.Marshal.Dynamic
