-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A collection of miscellaneous modules
--   
@package hsmisc
@version 1.1


-- | Some useful additional Parsec Char parsers
module HsMisc.Parsec.Char

-- | Considers end of file and newline to both be end of line
eol :: GenParser Char st Char

-- | Everything up to the end of line (as defined above)
tillEol :: GenParser Char st String


-- | Functions to prepend the current time to a string. Handy convenience
--   functions for logging.
--   
--   Examples:
--   
--   <pre>
--   tsL "foo"
--   tsZ "foo"
--   tsLFmt "%B %e, %Y :  " "bar"
--   tsUFmt "%c " "baz"
--   </pre>
--   
--   you'd get:
--   
--   <pre>
--   "2009-06-07 01:53:22 EDT&gt; foo"
--   "2009-06-07T13:43:23Z&gt; foo"
--   "June  7, 2009 :  bar"
--   "Sun Jun  7 13:15:41 UTC 2009 baz"
--   </pre>
module HsMisc.Data.TimeStamp

-- | Prepend the time right now onto the supplied string in the format
--   specified by the format string. Your local time zone. For formatting
--   string options see Data.Time.Format
tsLFmt :: String -> String -> IO String

-- | Prepend the time right now onto the supplied string in the format
--   specified by the format string. Universal time. For formatting string
--   options see Data.Time.Format
tsUFmt :: String -> String -> IO String

-- | Prepend the time right now onto the supplied string. Your time zone.
--   Time is in a clear, sortable format like: 2009-06-04 17:57:13 EDT&gt;
tsL :: String -> IO String

-- | Prepend the time right now onto the supplied string. Universal time.
--   Time is in a clear, sortable format like: 2009-06-04 21:57:13 UTC&gt;
tsU :: String -> IO String

-- | Prepend the time right now onto the supplied string. Universal time.
--   Time is in an ISO 8601 format, zero UTC offset or <tt>Zulu</tt> time:
--   2009-06-04T21:57:13Z&gt;
tsZ :: String -> IO String


-- | Simple functions for loading config files
--   
--   This module was motived by the desire to factor this repetitive
--   configuration file parsing code out of several of my projects.
--   
--   These functions offer very simple behavior which may be fine for many
--   tasks. For those needing something that does more, including building
--   and saving config data and .ini-style [section]s, may I suggest
--   Data.ConfigFile <a>http://hackage.haskell.org/package/ConfigFile</a>.
module HsMisc.Data.SimpleConf

-- | Convenience type synonym. Config data is just a simple Map
type ConfMap = Map String String

-- | Parse config file data into a simple (Map String String).
--   
--   For example, this:
--   
--   <pre>
--   --- file start ---
--   foo=one
--   # a comment
--   
--   bar
--   baz-blorp=2
--   --- file end ---
--   </pre>
--   
--   becomes:
--   
--   <pre>
--   fromList [("foo","one"),("bar",""),("baz-blorp","2")]
--   </pre>
--   
--   Comments (prefixed with #) and blank lines in the config file are
--   discarded.
parseToMap :: String -> ConfMap

-- | Parse config file data into what looks like long args on a command
--   line.
--   
--   Sometimes it's convenient to be able to supply commonly used long args
--   in a config file. The idea here is you can prepend this [String] to
--   your other command line args and send the whole mess to your
--   System.Console.GetOpt-based code.
--   
--   For example, this:
--   
--   <pre>
--   --- file start ---
--   foo=one
--   # a comment
--   
--   bar
--   baz-blorp=2
--   --- file end ---
--   </pre>
--   
--   becomes:
--   
--   <pre>
--   [ "--foo=one", "--bar", "--baz-blorp=2" ]
--   </pre>
--   
--   As above, comments (prefixed with #) and blank lines in the config
--   file are discarded.
parseToArgs :: String -> [String]


-- | The MonadPlus instance for Maybe works like a logical or:
--   
--   <pre>
--   (Just x) `mplus` _ == Just x
--   Nothing  `mplus` y == y
--   </pre>
--   
--   But the MonadPlus instance for List works like concatination:
--   
--   <pre>
--   [1, 2, 3] `mplus` [10, 20] == [1, 2, 3, 10, 20]
--   [] `mplus` [1, 2, 3]       == [1, 2, 3]
--   </pre>
--   
--   I ran into a situation where I wanted the former behavior for lists,
--   success and failure:
--   
--   <pre>
--   [1, 2, 3] `morelse` [10, 20] == [1, 2, 3]
--   [] `morelse` [10, 20]        == [10, 20]
--   </pre>
--   
--   Perhaps to express a default value:
--   
--   <pre>
--   let x = ""
--   let y = x `morelse` "default value"
--   y == "default value"
--   </pre>
--   
--   To fulfill that need, this module implements a MonadOr typeclass with
--   morelse
module HsMisc.Control.Monad.MonadOr

-- | Example of use for lists:
--   
--   <pre>
--   import HsMisc.Control.Monad.MonadOr
--   instance MonadOr []
--   </pre>
class MonadPlus m => MonadOr m where morelse x y | x == mzero = y | otherwise = x
morelse :: (MonadOr m, Eq (m a)) => m a -> m a -> m a


-- | Convenience function for turning (Maybe a) values into (MonadError e
--   a) actions plus a function for expressing Data.Map lookups as
--   MonadError actions
module HsMisc.Control.Monad.Error

-- | Turn an error value and a (Maybe a) into a (MonadError e a) action
maybeThrow :: MonadError e m => e -> Maybe a -> m a

-- | Look up a key in a Map as an action in (MonadError String), with a
--   default message that the key was not found as the error.
lookupE :: (Ord k, Show k, MonadError String m) => k -> Map k a -> m a
