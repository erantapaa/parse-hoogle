-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simplify static Networking tasks
--   
--   A Networking library for static Networking tasks.
--   
--   To learn about how to use this library in general, see
--   <a>http://github.com/DanBurton/netspec#readme</a>
@package netspec
@version 0.2.0.0


-- | Use <a>Text</a> to send and receive messages. For this module, a
--   message is a single line; the newline character acts as the
--   end-of-message flag.
module Network.NetSpec.Text

-- | Receive a <a>Text</a> message from a <a>Handle</a>.
receive :: MonadIO io => Handle -> io Text

-- | The staple for sending a message. <tt>!</tt> is typeclassed so that
--   you can <a>send</a> or <a>broadcast</a> using the same simple syntax.
--   The <tt>CanSend</tt> typeclass is not exposed. Instances of CanSend
--   include <a>Handle</a> and <tt>Traversable t =&gt; t Handle</tt>.
--   
--   <tt>!</tt> produces an <tt>IO</tt> action lifted into any
--   <a>MonadIO</a>, so can be used without the extra cruft of
--   <a>liftIO</a> for most monad stacks. <tt>!</tt> is declared as
--   <tt>infix 2</tt>.
--   
--   Usage:
--   
--   <pre>
--   destination ! someText
--   </pre>
(!) :: (CanSend h, MonadIO io) => h -> Text -> io ()

-- | Send a <a>Text</a> message to exactly one <a>Handle</a>.
send :: MonadIO io => Handle -> Text -> io ()

-- | Broadcast a <a>Text</a> message to multiple <a>Handle</a>s.
broadcast :: MonadIO io => Foldable f => f Handle -> Text -> io ()
instance Foldable f => CanSend (f Handle)
instance CanSend Handle


-- | Use Lazy <a>ByteString</a>s to send and receive messages. For this
--   module, a message is prefixed by a 64-bit little-endian signed
--   integer, indicating the length in bytes of the remaining message.
module Network.NetSpec.ByteString

-- | Receive a <a>ByteString</a> message from a <a>Handle</a>.
receive :: MonadIO io => Handle -> io ByteString

-- | The staple for sending a message. <tt>!</tt> is typeclassed so that
--   you can <a>send</a> or <a>broadcast</a> using the same simple syntax.
--   The <tt>CanSend</tt> typeclass is not exposed. Instances of CanSend
--   include <a>Handle</a> and <tt>Traversable t =&gt; t Handle</tt>.
--   
--   <tt>!</tt> produces an <tt>IO</tt> action lifted into any
--   <a>MonadIO</a>, so can be used without the extra cruft of
--   <a>liftIO</a> for most monad stacks. <tt>!</tt> is declared as
--   <tt>infix 2</tt>.
--   
--   Usage:
--   
--   <pre>
--   destination ! someByteString
--   </pre>
(!) :: (CanSend h, MonadIO io) => h -> ByteString -> io ()

-- | Send a <a>ByteString</a> message to exactly one <a>Handle</a>.
send :: MonadIO io => Handle -> ByteString -> io ()

-- | Broadcast a <a>ByteString</a> message to multiple <a>Handle</a>s.
broadcast :: MonadIO io => Foldable f => f Handle -> ByteString -> io ()
instance Foldable f => CanSend (f Handle)
instance CanSend Handle


-- | Use Lazy <a>ByteString</a>s of JSON to send and receive messages. For
--   this module, a message is prefixed by a 64-bit little-endian signed
--   integer, indicating the length in bytes of the remaining message,
--   which is encoded in JSON format.
module Network.NetSpec.Json

-- | Receive a JSON message from a <a>Handle</a>. Unlike <a>Text</a> and
--   <a>ByteString</a>, the result of this MonadIO action is wrapped in a
--   <a>Maybe</a>. <a>Nothing</a> means that the data received could not be
--   parsed from JSON to the correct data type. It is up to you to decide
--   whether or not to explicitly handle the <a>Nothing</a> case.
--   
--   Notice that this action is polymorphic in its return type. Type
--   annotations are usually unnecessary, since type inference can usually
--   determine the correct target type. Example usage:
--   
--   <pre>
--   do Just m &lt;- receive h
--      case m of Foo x y -&gt; handleFoo x y
--                Bar z   -&gt; handleBar z
--   </pre>
--   
--   Here <tt>m</tt> is inferred to have whatever type <tt>Foo</tt> and
--   <tt>Bar</tt> belong to. This example code assumes that the JSON parse
--   will succeed. The <a>fail</a> function will be invoked for the Monad
--   you are working in if such a pattern match fails.
receive :: (MonadIO io, FromJSON j) => Handle -> io (Maybe j)

-- | The staple for sending a message. <tt>!</tt> is typeclassed so that
--   you can <a>send</a> or <a>broadcast</a> using the same simple syntax.
--   The <tt>CanSendJson</tt> typeclass is not exposed. Instances of
--   CanSendJson include <a>Handle</a> and <tt>Traversable t =&gt; t
--   Handle</tt>.
--   
--   <tt>!</tt> produces an <tt>IO</tt> action lifted into any
--   <a>MonadIO</a>, so can be used without the extra cruft of
--   <a>liftIO</a> for most monad stacks. <tt>!</tt> is declared as
--   <tt>infix 2</tt>.
--   
--   Usage:
--   
--   <pre>
--   destination ! someData
--   </pre>
--   
--   Anything that is an instance of <a>ToJSON</a> can be used on the
--   right-hand side of <tt>!</tt>.
(!) :: (CanSendJson h, MonadIO io) => ToJSON j => h -> j -> io ()

-- | Send a JSON message to exactly one <a>Handle</a>.
send :: MonadIO io => ToJSON j => Handle -> j -> io ()

-- | Broadcast a JSON message to multiple <a>Handle</a>s.
broadcast :: MonadIO io => (ToJSON j, Foldable f) => f Handle -> j -> io ()

-- | Derives <a>ToJSON</a> and <a>FromJSON</a> instances for your data
--   types. These are necessary in order to use the functions this module
--   provides with your custom data types.
--   
--   Usage:
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   data Foo = Bar | Baz { quux :: Int }
--   $(deriveJson id ''Foo)
--   </pre>
--   
--   Alteratively, you could write your own instances.
deriveJson :: (String -> String) -> Name -> Q [Dec]
instance Foldable f => CanSendJson (f Handle)
instance CanSendJson Handle


-- | Simplify static Networking tasks.
module Network.NetSpec

-- | Define the specification of your networking task as a begin, loop, and
--   end proceedure. Run your NetSpec with <a>runSpec</a>.
--   
--   <tt>t</tt> indicates the <a>Traversable</a> structure used.
--   <tt>[]</tt> is recommended for simplicity, but you are at liberty to
--   use any Traversable you see fit.
--   
--   <tt>s</tt> indicates the type used for state. Use <tt>()</tt> for a
--   stateless specification.
--   
--   A server must specify which ports to listen on, while a client instead
--   specifies tuples of (hostname, port) to connect to.
data NetSpec t s
ServerSpec :: t PortID -> (t Handle -> IO s) -> (t Handle -> s -> IO (SpecState s)) -> (t Handle -> s -> IO ()) -> NetSpec t s
_ports :: NetSpec t s -> t PortID
_begin :: NetSpec t s -> t Handle -> IO s
_loop :: NetSpec t s -> t Handle -> s -> IO (SpecState s)
_end :: NetSpec t s -> t Handle -> s -> IO ()
ClientSpec :: t (String, PortID) -> (t Handle -> IO s) -> (t Handle -> s -> IO (SpecState s)) -> (t Handle -> s -> IO ()) -> NetSpec t s
_conns :: NetSpec t s -> t (String, PortID)
_begin :: NetSpec t s -> t Handle -> IO s
_loop :: NetSpec t s -> t Handle -> s -> IO (SpecState s)
_end :: NetSpec t s -> t Handle -> s -> IO ()

-- | Indicate whether to <tt>Continue</tt> or <tt>Stop</tt> with a given
--   state
data SpecState s
Continue :: s -> SpecState s
Stop :: s -> SpecState s

-- | Run a <a>NetSpec</a>.
--   
--   Running a spec will step through your <a>Traversable</a> of connection
--   descriptions, and replace each one with a <a>Handle</a>, preserving
--   the structure of the Traversable otherwise.
--   
--   Regardless of exceptions, all Handles and Sockets opened by the spec
--   will be closed at the end of the run; you should not need to close any
--   of the Handles given to you by the spec.
--   
--   (Note <tt>runSpec</tt> calls <a>withSocketsDo</a> for you)
runSpec :: Traversable t => NetSpec t s -> IO ()

-- | Continue with a given state
continue :: Monad m => s -> m (SpecState s)

-- | Continue (statless)
continue_ :: Monad m => m (SpecState ())

-- | Conditionally continue with a given state, based on that state and
--   additional given information.
--   
--   Recommended usage:
--   
--   <pre>
--   _loop = \handles -&gt; continueIf f .: runStateT $ do ...
--   </pre>
continueIf :: Monad m => (a -> s -> Bool) -> m (a, s) -> m (SpecState s)

-- | Conditionally continue with a given state, based solely on that state.
--   
--   Recommended usage:
--   
--   <pre>
--   _loop = \handles -&gt; continueIf' f .: execStateT $ do ...
--   </pre>
continueIf' :: Monad m => (s -> Bool) -> m s -> m (SpecState s)

-- | Conditionally continue statelessly, based on given information.
--   
--   Recommended usage
--   
--   <pre>
--   _loop = \handles () -&gt; continueIf_ f $ do ...
--   </pre>
continueIf_ :: Monad m => (a -> Bool) -> m a -> m (SpecState ())

-- | Stop with a given state
stop :: Monad m => s -> m (SpecState s)

-- | Stop (stateless)
stop_ :: Monad m => m (SpecState ())

-- | Conditionally stop with a given state, based on that state and
--   additional given information.
stopIf :: Monad m => (a -> s -> Bool) -> m (a, s) -> m (SpecState s)

-- | Conditionally stop with a given state, based solely on that state.
stopIf' :: Monad m => (s -> Bool) -> m s -> m (SpecState s)

-- | Conditionally stop statlessly, based on given information.
stopIf_ :: Monad m => (a -> Bool) -> m a -> m (SpecState ())

-- | Compose two functions, similar to <tt>.</tt> from <a>Prelude</a>. If
--   <tt>h = f .: g</tt> then <tt>h x y = f (g x y)</tt>.
(.:) :: (a -> b) -> (c -> d -> a) -> c -> d -> b

-- | Lift a state function into a <a>StateT</a> monad stack
stateT :: Monad m => (s -> (a, s)) -> StateT s m a
instance Functor SpecState
