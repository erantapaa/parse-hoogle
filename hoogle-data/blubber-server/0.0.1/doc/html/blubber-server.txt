-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The blubber server, serves blubber clients.
--   
@package blubber-server
@version 0.0.1


module Blubber.Server.Vector
data Vector
Vec :: Double -> Double -> Vector

-- | The x position.
vx :: Vector -> Double

-- | The y position.
vy :: Vector -> Double

-- | <a>Vector</a> uses a <a>Serialize</a> instance to encode its data.

-- | <a>Vector</a> subtraction.
(^-^) :: Vector -> Vector -> Vector

-- | <a>Vector</a> addition.
(^+^) :: Vector -> Vector -> Vector

-- | Multiply a <a>Vector</a> with a scalar.
(^*^) :: Vector -> Double -> Vector

-- | Divide a <a>Vector</a> by a scalar.
(^/^) :: Vector -> Double -> Vector

-- | Calculate the magnitude of a <a>Vector</a>.
magVec :: Vector -> Double

-- | Limit the magnitude of a <a>Vector</a> to a scalar.
vecLimitMag :: Double -> Vector -> Vector
instance Eq Vector
instance Generic Vector
instance Show Vector
instance Datatype D1Vector
instance Constructor C1_0Vector
instance Selector S1_0_0Vector
instance Selector S1_0_1Vector
instance Serialize Vector


module Blubber.Server.Entity

-- | An <a>Entity</a> is a <a>Blub</a> with a position and mass.
data Entity
MkEntity :: Vector -> Double -> Blub -> Entity

-- | The position of the <a>Blub</a>.
position :: Entity -> Vector

-- | The mass of the <a>Blub</a>.
mass :: Entity -> Double

-- | The Blub itself.
entity :: Entity -> Blub

-- | <a>Entity</a>s may be ordered based on their <a>mass</a>.

-- | <a>Entity</a> uses a <a>Serialize</a> instance to encode its data.

-- | The <a>Blub</a> is our hero. It is either a <a>NeutralBlub</a> that
--   may simply be consumed by <a>PlayerBlub</a>, or it is indeed a
--   <a>PlayerBlub</a>. A human-controlled <a>Blub</a> has a velocity and a
--   target position in addition to the usual <a>Entity</a> stuff.
data Blub
NeutralBlub :: Blub
PlayerBlub :: Vector -> Vector -> Blub
velocity :: Blub -> Vector
targetPos :: Blub -> Vector

-- | <a>Blub</a> uses a <a>Serialize</a> instance to encode its data.

-- | The <a>radius</a> of the <a>Entity</a>.
radius :: Entity -> Double

-- | <a>isNeutral</a> is a quick hack to check if an <a>Entity</a> holds a
--   <a>NeutralBlub</a> or not.
isNeutral :: Entity -> Bool

-- | Simple circle-circle-based intersect check of <a>Entity</a>s based on
--   their <a>radius</a>.
intersect :: Entity -> Entity -> Maybe Vector

-- | A <a>fite</a> between the passed in <a>Entity</a>s. The bigger one
--   eats the smaller. If they are equal no one eats each other. They just
--   hug.
fite :: (Entity, Entity) -> (Maybe Entity, Maybe Entity)

-- | Let the first <a>Entity</a> <a>blubber</a> the second <a>Entity</a>.
--   I.e. EAT IT! Omnomnom.
blubber :: Entity -> Entity -> Entity
instance Eq Blub
instance Generic Blub
instance Show Blub
instance Eq Entity
instance Generic Entity
instance Show Entity
instance Datatype D1Blub
instance Constructor C1_0Blub
instance Constructor C1_1Blub
instance Selector S1_1_0Blub
instance Selector S1_1_1Blub
instance Datatype D1Entity
instance Constructor C1_0Entity
instance Selector S1_0_0Entity
instance Selector S1_0_1Entity
instance Selector S1_0_2Entity
instance Serialize Blub
instance Serialize Entity
instance Ord Entity


module Blubber.Server.World

-- | The <a>World</a> in which the <a>Entity</a>s reside.
data World
MkWorld :: Double -> Double -> Map String Entity -> Set Entity -> StdGen -> World

-- | The width of the <a>World</a>.
width :: World -> Double

-- | The height of the <a>World</a>.
height :: World -> Double

-- | The <tt>PlayerBlob</tt>s in the <a>World</a> indexed on their names.
players :: World -> Map String Entity

-- | The <tt>NeutralBlob</tt>s in the <a>World</a>.
neutrals :: World -> Set Entity

-- | The <a>entropy</a> of the <a>World</a>, for randomising things.
entropy :: World -> StdGen

-- | Try to add a <a>NeutralBlub</a> to the <a>World</a>, if there is room
--   for it. But don't try *very* hard.
addNeutral :: World -> World

-- | Add a <a>PlayerBlub</a> belonging to the name in the passed in
--   <a>String</a>, lest it already has a <a>PlayerBlub</a>, in which case
--   it's just ignored.
addPlayer :: World -> String -> World

-- | Delete a <a>PlayerBlub</a> belonging to the name in the passed in
--   <a>String</a>, lest it doesn't exist, in which case it's just ignored.
delPlayer :: World -> String -> World

-- | For use with <a>Entity</a>s that are not yet placed in the
--   <a>World</a>, in order to check that the spot you are attempting to
--   place them in is actually available -- i.e. that it doesn't intersect
--   with already placed out <a>Entity</a>s
available :: World -> Entity -> Bool

-- | <a>clamp</a> stuff between a min and a max.
clamp :: Ord a => a -> a -> a -> a

-- | The initial <a>World</a>.
createWorld :: StdGen -> World

-- | Update the <a>velocity</a> of an <a>Entity</a> based on its
--   <a>targetPos</a>, and limited by its <a>mass</a>.
updateVel :: Double -> Entity -> Entity

-- | Update the 'position of an <a>Entity</a> based on its <a>velocity</a>.
--   Makes sure to <a>clamp</a> the <a>Entity</a> to the <a>World</a>
--   edges.
updatePos :: Double -> World -> Entity -> Entity

-- | Natural decaying of <a>Entity</a> <a>mass</a>, so as to not have too
--   huge <a>Entity</a>s.
decay :: Double -> Entity -> Entity
blubs :: World -> World

-- | Check if any one <a>Entity</a> collides with any one other. If they
--   do, delete them out of the recursion, and keep checking the others
--   until every <a>Entity</a> is checked with every other.
playerBlubbers :: World -> World

-- | Check if any one <a>Entity</a> collides with any one other. If they
--   do, delete them out of the recursion, and keep checking the others
--   until every <a>Entity</a> is checked with every other.
neutralBlubbers :: World -> World

-- | Given an <a>Entity</a> of a <a>PlayerBlub</a> and its id (as a
--   <a>String</a>), and a list of other such things, let the <a>Entity</a>
--   <a>fite</a> all the ones in the passed in the list.
--   
--   It keeps checking until there's a collision. At that point, it figures
--   out which one <tt>blubber</tt>s which. The <tt>blubber</tt>er grows,
--   and the <tt>blubber</tt>ee is deleted. Ruthless.
--   
--   If there is no collision it returns <a>Nothing</a>. If there is one,
--   it returns a <a>Just</a> with two tuples -- one for each <a>Blub</a>.
--   The survivor will be a <a>Just</a>, the other one <a>Nothing</a>.
playerBlubs :: (String, Entity) -> [(String, Entity)] -> Maybe ((String, Maybe Entity), (String, Maybe Entity))

-- | Given an <a>Entity</a> of a <a>PlayerBlub</a> and its id (as a
--   <a>String</a>), and a list of <tt>NeturalBlub</tt>s <a>Entity</a>s,
--   let the <a>PlayerBlub</a> <a>Entity</a> <a>fite</a> all the
--   <tt>NeutralbBlub</tt>s in the passed in list.
--   
--   It keeps checking until there's a collision. At that point, it returns
--   the now rather quiute big <a>PlayerBlub</a> and the poor
--   <a>NeutralBlub</a> it has blubbered. If there is no collision it just
--   returns <a>Nothing</a>.
neutralBlubs :: (String, Entity) -> [Entity] -> Maybe ((String, Entity), Entity)

-- | Check if the client in the passed in <a>String</a> is the owner of an
--   <a>Entity</a>; if so, set its <a>targetPos</a> to the passed in
--   <a>Double</a>s.
setTargetPos :: String -> Double -> Double -> World -> Map String Entity

-- | Update the <a>World</a>. <a>updateVel</a>, <a>updatePos</a>,
--   <a>decay</a>, and check for <tt>blubbers</tt>.
updateWorld :: Double -> World -> World

-- | Checks if a client has a player. If it does, then update the
--   <a>targetPos</a> of the player's <a>Entity</a>.
handleInput :: Ord c => [(c, (Double, Double))] -> Map c String -> World -> World
instance Show World


module Blubber.Server.ViewPort

-- | A <a>ViewPort</a> is the part of the <a>World</a> that a client is
--   privy to.
data ViewPort
MkViewPort :: Vector -> Double -> Double -> Map String Entity -> [Entity] -> ViewPort

-- | The absolute position of the <a>ViewPort</a>
viewPos :: ViewPort -> Vector

-- | The width of the <a>ViewPort</a>.
viewWidth :: ViewPort -> Double

-- | The height of the <a>ViewPort</a>.
viewHeight :: ViewPort -> Double

-- | The visible <tt>PlayerBlob</tt>s in the <a>ViewPort</a>.
visiblePlayers :: ViewPort -> Map String Entity

-- | The visible <tt>NeutralBlob</tt>s in the <a>ViewPort</a>.
visibleNeutrals :: ViewPort -> [Entity]

-- | <a>ViewPort</a> uses a <a>Serialize</a> instance to encode its data.

-- | Make a <a>ViewPort</a> for the passed in client's <a>Entity</a>. If
--   they don't have an <a>Entity</a>, then we'll just give them the entire
--   <a>World</a> via <a>worldViewPort</a>. The <a>ViewPort</a> also
--   includes the <a>mass</a> of the player's own <a>Entity</a>.
mkViewPort :: World -> String -> ViewPort

-- | Figure out which <tt>PlayerBlob</tt>s are visible to a client, based
--   on their <a>position</a> and <a>radius</a>.
getVisiblePlayers :: Map String Entity -> Vector -> Double -> Map String Entity

-- | Figure out which <tt>NeutralBlob</tt>s are visible to a client, based
--   on their <a>position</a> and <a>radius</a>.
getVisibles :: Set Entity -> Vector -> Double -> Set Entity

-- | Make a <a>ViewPort</a> of essentieally the whole <a>World</a> and all
--   its <a>Entity</a>s.
worldViewPort :: World -> ViewPort
viewPort :: World -> String -> ViewPort
instance Eq ViewPort
instance Generic ViewPort
instance Show ViewPort
instance Datatype D1ViewPort
instance Constructor C1_0ViewPort
instance Selector S1_0_0ViewPort
instance Selector S1_0_1ViewPort
instance Selector S1_0_2ViewPort
instance Selector S1_0_3ViewPort
instance Selector S1_0_4ViewPort
instance Serialize ViewPort


module Blubber.Server.Message

-- | The types of messages the blubber server accepts.
data Message

-- | Ask to shake hands.
Connect :: Message

-- | Ask to part ways.
Disconnect :: Message

-- | Ask to add a new player to the world.
AddPlayer :: String -> Message

-- | Ask to update the velocity of a player's <tt>Blub</tt>
UpdateVelocity :: (Double, Double) -> Message

-- | Ask the given IP for the source code.
SrcPls :: String -> Message

-- | The types of replies the blubber server sends.
data Reply

-- | The latest <a>ViewPort</a> for the client.
View :: ViewPort -> Reply

-- | A link to the server's source code.
SrcLink :: String -> Reply

-- | <a>Message</a> uses a <a>Serialize</a> instance to encode its data.
instance Eq Message
instance Generic Message
instance Show Message
instance Eq Reply
instance Generic Reply
instance Show Reply
instance Datatype D1Message
instance Constructor C1_0Message
instance Constructor C1_1Message
instance Constructor C1_2Message
instance Constructor C1_3Message
instance Constructor C1_4Message
instance Datatype D1Reply
instance Constructor C1_0Reply
instance Constructor C1_1Reply
instance Serialize Message
instance Serialize Reply
