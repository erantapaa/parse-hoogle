-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell bindings for libvoyeur
--   
--   Haskell bindings for libvoyeur, a library for observing the private
--   activities of child processes.
@package voyeur
@version 0.1.0.1


-- | This package provides bindings to libvoyeur, a library for observing
--   the private activity of processes. Libvoyeur observes a child process
--   and all of its descendants, so it works even when the child process
--   calls out to other processes to do the actual work.
--   
--   To observe a process, use <a>withVoyeur</a> to create an
--   <a>VoyeurContext</a>, then register handlers for the events you want
--   to observe using functions like <a>observeExec</a>. When you've set up
--   all your handlers, use <a>prepareEnvironment</a> to create a special
--   environment that will inject libvoyeur code into the child process,
--   and pass that environment to a function like <a>runProcess</a>.
--   Finally, pass the resulting <a>ProcessHandle</a> or <a>ProcessID</a>
--   to <a>startObserving</a>, and your handlers will be called as events
--   happen.
--   
--   A simple program that prints a message every time a child process
--   opened a file might look like this:
--   
--   <pre>
--   import Control.Monad
--   import Data.Maybe
--   import System.Environment
--   import System.Process
--   import System.Process.Voyeur
--   
--   main = do
--     (program : args) &lt;- getArgs
--     withVoyeur $ \ctx -&gt; do
--       -- Set up a handler.
--       observeOpen ctx defaultOpenFlags $
--         \path _ _ _ _ pid -&gt; putStrLn $ show pid ++ " opened " ++ show path
--   
--       -- Set up the environment.
--       curEnv &lt;- getEnvironment
--       newEnv &lt;- prepareEnvironment ctx curEnv
--       
--       when (isJust newEnv) $ do
--         -- Start the child process.
--         handle &lt;- runProcess program args Nothing newEnv Nothing Nothing Nothing
--   
--         -- Observe it! startObserving only returns when the child process
--         -- exits, so we don't need to wait.
--         void $ startObserving ctx handle
--   </pre>
--   
--   A larger example program is included with the source code to this
--   package.
module System.Process.Voyeur

-- | Creates a <a>VoyeurContext</a> and runs an IO action that observes a
--   process using it.
withVoyeur :: (VoyeurContext -> IO a) -> IO a

-- | Prepares an environment for a child process you want to observe.
--   <a>prepareEnvironment</a> starts the server component of libvoyeur and
--   adds or modifies environment variables as necessary to inject code
--   into the child process you're about to create and make sure it can
--   connect to the server.
--   
--   Generally after calling <a>prepareEnvironment</a>, you'll want to
--   start the child process using the returned environment, and then call
--   <a>startObserving</a> to begin receiving events.
--   
--   If something goes wrong, <a>prepareEnvironment</a> will return
--   <a>Nothing</a>.
prepareEnvironment :: VoyeurContext -> [(String, String)] -> IO (Maybe [(String, String)])

-- | Start observing a child process. Your handlers will be called while
--   the process runs. Note that no handlers will be called if you didn't
--   start the process with an environment produced by
--   <a>prepareEnvironment</a>.
--   
--   When the child process exits, <a>startObserving</a> will terminate the
--   server component of libvoyeur and return. This means that
--   <a>startObserving</a> implicitly waits for the child process, so you
--   don't need to do this on your own.
startObserving :: HasPid a => VoyeurContext -> a -> IO ExitCode

-- | Flags for observing <tt>exec</tt> calls.
data ObserveExecFlags
ObserveExecFlags :: !Bool -> !Bool -> !Bool -> !Bool -> ObserveExecFlags

-- | True if you want the current working directory.
observeExecCWD :: ObserveExecFlags -> !Bool

-- | True if you want the environment. (Potentially slow.)
observeExecEnv :: ObserveExecFlags -> !Bool

-- | True if you want the value of <tt>PATH</tt>.
observeExecPath :: ObserveExecFlags -> !Bool

-- | True if you want to see calls that fail due to access restrictions.
observeExecNoAccess :: ObserveExecFlags -> !Bool

-- | Default flags which observe the minimum amount of information.
defaultExecFlags :: ObserveExecFlags

-- | A handler for <tt>exec</tt> calls.
type ObserveExecHandler = ByteString -> [ByteString] -> [(ByteString, ByteString)] -> ByteString -> ByteString -> ProcessID -> ProcessID -> IO ()

-- | Observe calls to the <tt>exec</tt> and <tt>posix_spawn</tt> families
--   of functions.
observeExec :: VoyeurContext -> ObserveExecFlags -> ObserveExecHandler -> IO ()

-- | A handler for 'exit' calls.
type ObserveExitHandler = ExitCode -> ProcessID -> ProcessID -> IO ()

-- | Observe calls to the 'exit' family of functions.
observeExit :: VoyeurContext -> ObserveExitHandler -> IO ()

-- | Flags for observing 'open' calls.
data ObserveOpenFlags
ObserveOpenFlags :: !Bool -> ObserveOpenFlags

-- | True if you want the current working directory.
observeOpenCWD :: ObserveOpenFlags -> !Bool

-- | Default flags which observe the minimum amount of information.
defaultOpenFlags :: ObserveOpenFlags

-- | A handler for 'open' calls.
type ObserveOpenHandler = ByteString -> Int -> FileMode -> ByteString -> Int -> ProcessID -> IO ()

-- | Observe calls to 'open'.
observeOpen :: VoyeurContext -> ObserveOpenFlags -> ObserveOpenHandler -> IO ()

-- | A handler for 'close' calls.
type ObserveCloseHandler = Int -> Int -> ProcessID -> IO ()

-- | Observe calls to 'close'.
observeClose :: VoyeurContext -> ObserveCloseHandler -> IO ()

-- | The context libvoyeur uses to store its state.
data VoyeurContext

-- | The class of values that contain a <a>ProcessID</a>. This is used to
--   abstract over the different representations of a process used by the
--   various process libraries.
class HasPid a
instance HasPid ProcessHandle
instance HasPid ProcessID
