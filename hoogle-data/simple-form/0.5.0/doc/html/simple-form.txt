-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Forms that configure themselves based on type
--   
--   Inspired by the RubyGem of the same name, this package allows you to
--   easily build validating forms that infer defaults based on type.
--   
--   Most users will want to both render <a>Html</a> and parse input, and
--   so should use the SimpleForm.Digestive.Combined and
--   SimpleForm.Combined modules.
@package simple-form
@version 0.5.0


-- | Forms that configure themselves based on type
--   
--   This module is for constructing forms that only output to <a>Html</a>.
--   For forms that also parse input, see SimpleForm.Combined
module SimpleForm

-- | The type of a widget renderer
type Widget a = Maybe a -> Maybe Text -> Text -> InputOptions -> Input

-- | Infer a <a>Widget</a> based on type
class DefaultWidget a where wdefList _ _ _ _ = Input $ p $ toHtml "No useful multi-select box for this type."
wdef :: DefaultWidget a => Widget a
wdefList :: DefaultWidget a => Widget [a]

-- | Representation of an input widget in HTML
data Input
Input :: Html -> Input
MultiInput :: [Html] -> Input
SelfLabelInput :: Html -> Input

-- | The setup for rendering an input. Blank is <a>mempty</a>
data InputOptions
InputOptions :: Maybe Label -> Maybe Text -> Bool -> Bool -> [(Text, Text)] -> [(Text, Text)] -> [(Text, Text)] -> [(Text, Text)] -> [(Text, Text)] -> InputOptions
label :: InputOptions -> Maybe Label
hint :: InputOptions -> Maybe Text
required :: InputOptions -> Bool
disabled :: InputOptions -> Bool
input_html :: InputOptions -> [(Text, Text)]
label_html :: InputOptions -> [(Text, Text)]
error_html :: InputOptions -> [(Text, Text)]
hint_html :: InputOptions -> [(Text, Text)]
wrapper_html :: InputOptions -> [(Text, Text)]

-- | A block label, inline label, or implied value label
data Label
Label :: Text -> Label
InlineLabel :: Text -> Label
DefaultLabel :: Label

-- | Wrapper for types that should be rendered using <a>show</a>
newtype ShowRead a
ShowRead :: a -> ShowRead a
unShowRead :: ShowRead a -> a

-- | Wrapper for select boxes on enumerable types
newtype SelectEnum a
SelectEnum :: a -> SelectEnum a
unSelectEnum :: SelectEnum a -> a
button :: Widget Text
hidden :: Widget Text
checkbox :: Widget Bool
file :: Widget Text
text :: Widget Text
textarea :: Widget Text
password :: Widget Text
search :: Widget Text
email :: Widget Text
uri :: Widget Text
tel :: Widget Text
number :: (Num a, Show a) => Widget a
integral :: (Integral a, Show a) => Widget a
boundedNumber :: (Bounded a, Num a, Show a) => Widget a
boundedIntegral :: (Bounded a, Integral a, Show a) => Widget a
date :: FormatTime a => Widget a
time :: FormatTime a => Widget a
datetime :: FormatTime a => Widget a
datetime_local :: FormatTime a => Widget a

-- | Collection of items for the user to choose from, with optional
--   grouping
--   
--   A trivial <a>GroupedCollection</a> (with just one, blankly-named
--   group) should be treated by <a>Widget</a>s as if it were just a
--   <a>Collection</a>
type GroupedCollection = [(Text, [(Text, Text)])]

-- | Collection of items for the user to choose from
type Collection = [(Text, Text)]
select :: GroupedCollection -> Widget Text
multi_select :: GroupedCollection -> Widget [Text]
radio_buttons :: GroupedCollection -> Widget Text
buttons :: GroupedCollection -> Widget Text
checkboxes :: GroupedCollection -> Widget [Text]

-- | &lt;input /&gt;
input_tag :: Text -> Maybe Text -> Text -> [[(Text, Text)]] -> InputOptions -> Html

-- | Derive a collection from an enumerable type
selectEnum :: (Show a, Read a, Bounded a, Enum a) => a -> Collection

-- | Feed a collection <a>Widget</a> from an enumerable type
enum :: (Show a, Read a, Bounded a, Enum a) => (GroupedCollection -> Widget Text) -> Widget a

-- | Push any <a>Collection</a> to a trivial <a>GroupedCollection</a>
group_ :: Collection -> GroupedCollection

-- | Feed a multi-select collection <a>Widget</a> from an enumerable type
multiEnum :: (Show a, Read a, Bounded a, Enum a) => (GroupedCollection -> Widget [Text]) -> Widget [a]

-- | Format identifiers nicely for humans to read
humanize :: Text -> Text
maybeCons :: Bool -> a -> [a] -> [a]

-- | Apply a list of default attributes and user overrides to some
--   <a>Html</a>
applyAttrs :: [(Text, Text)] -> [(Text, Text)] -> Html -> Html
instance Show Label
instance Eq Label
instance Show InputOptions
instance Eq InputOptions
instance Eq a => Eq (ShowRead a)
instance Ord a => Ord (ShowRead a)
instance Eq a => Eq (SelectEnum a)
instance Ord a => Ord (SelectEnum a)
instance (Show a, Read a, Bounded a, Enum a) => DefaultWidget (SelectEnum a)
instance Enum a => Enum (SelectEnum a)
instance Bounded a => Bounded (SelectEnum a)
instance Read a => Read (SelectEnum a)
instance (Show a, Read a) => Show (SelectEnum a)
instance (Show a, Read a) => DefaultWidget (ShowRead a)
instance Read a => Read (ShowRead a)
instance (Show a, Read a) => Show (ShowRead a)
instance DefaultWidget a => DefaultWidget (Maybe a)
instance (DefaultWidget a, DefaultWidget b) => DefaultWidget (a, b)
instance (Integral a, Show a) => DefaultWidget (Ratio a)
instance DefaultWidget TimeOfDay
instance DefaultWidget Day
instance DefaultWidget LocalTime
instance DefaultWidget ZonedTime
instance DefaultWidget UTCTime
instance HasResolution a => DefaultWidget (Fixed a)
instance DefaultWidget Double
instance DefaultWidget Float
instance DefaultWidget Int
instance DefaultWidget Integer
instance DefaultWidget Char
instance DefaultWidget Text
instance DefaultWidget Bool
instance DefaultWidget a => DefaultWidget [a]
instance Monoid InputOptions
instance IsString Label
instance Monoid Input


-- | These utilities are for writing <a>Renderer</a>s
module SimpleForm.Render

-- | The type of a final form-renderer
type Renderer = RenderOptions -> Html

-- | Representation of an input widget in HTML
data Input
Input :: Html -> Input
MultiInput :: [Html] -> Input
SelfLabelInput :: Html -> Input

-- | <a>InputOptions</a> that have been prepped for rendering
data RenderOptions
RenderOptions :: Text -> Input -> [Html] -> InputOptions -> RenderOptions
name :: RenderOptions -> Text
widgetHtml :: RenderOptions -> Input
errors :: RenderOptions -> [Html]
options :: RenderOptions -> InputOptions

-- | Prep <a>InputOptions</a> for rendering
renderOptions :: Maybe a -> Maybe Text -> Text -> Widget a -> [Html] -> InputOptions -> RenderOptions


-- | SimpleForm implementation that works along with digestive-functors
--   
--   This module is for constructing forms that only output to <a>Html</a>.
--   For forms that also parse input, see SimpleForm.Digestive.Combined
module SimpleForm.Digestive

-- | A form for producing something of type r
data SimpleForm r a

-- | Render a <a>SimpleForm</a> to <a>Html</a>
--   
--   This produces the contents of the form, but you must still wrap it in
--   the actual &lt;form&gt; element.
simpleForm :: ToMarkup v => Renderer -> (View v, Maybe a) -> SimpleForm a () -> Html

-- | Render a <a>SimpleForm</a> to <a>Html</a> and get the return value
--   
--   This produces the contents of the form, but you must still wrap it in
--   the actual &lt;form&gt; element.
simpleForm' :: ToMarkup v => Renderer -> (View v, Maybe a) -> SimpleForm a r -> (r, Html)

-- | Create an input element for a <a>SimpleForm</a>
--   
--   <pre>
--   input "username" (Just . username) wdef mempty
--   </pre>
input :: Text -> (r -> Maybe a) -> Widget a -> InputOptions -> SimpleForm r ()

-- | Same as <a>input</a>, but just use the default options
input_ :: DefaultWidget a => Text -> (r -> Maybe a) -> SimpleForm r ()

-- | Like <a>input</a>, but grabs a collection out of the <a>View</a>
choiceInput :: Text -> (r -> Maybe a) -> (GroupedCollection -> Widget a) -> InputOptions -> SimpleForm r ()

-- | Like <a>choiceInput</a>, but chooses defaults for <a>Widget</a> and
--   <a>InputOptions</a>
choiceInput_ :: Text -> (r -> Maybe Text) -> SimpleForm r ()

-- | Add some raw markup to a <a>SimpleForm</a>
toForm :: ToMarkup h => h -> SimpleForm a ()

-- | Project out some part of the parsed data
withFields :: Maybe Text -> (r' -> r) -> SimpleForm r a -> SimpleForm r' a

-- | Wrap a <a>SimpleForm</a> in an <a>Html</a> tag
wrap :: (Html -> Html) -> SimpleForm r a -> SimpleForm r a

-- | Like <a>withFields</a>, but also wrap in fieldset tag
fieldset :: Maybe Text -> (r' -> r) -> SimpleForm r a -> SimpleForm r' a

module SimpleForm.Validation

-- | Either try to parse the submitted values, or have a list of allowed
--   values
data Validation a
Check :: ([Text] -> Maybe a) -> Validation a
Includes :: (GroupedCollection' a) -> Validation a
class DefaultValidation a where vdefList = case vdef of { Check f -> Check (mapM f . return) Includes c -> multi_includes c }
vdef :: DefaultValidation a => Validation a
vdefList :: DefaultValidation a => Validation [a]

-- | Wrapper for types that should be rendered using <a>show</a>
newtype ShowRead a
ShowRead :: a -> ShowRead a
unShowRead :: ShowRead a -> a

-- | Wrapper for select boxes on enumerable types
newtype SelectEnum a
SelectEnum :: a -> SelectEnum a
unSelectEnum :: SelectEnum a -> a
bool :: Validation Bool
text :: Validation Text
textLength :: Int -> Validation Text
read :: Read a => Validation a
email :: Validation EmailAddress
uri :: Validation URI
absoluteUri :: Validation URI
dateFormat :: ParseTime a => String -> Validation a
date :: ParseTime a => Validation a
time :: ParseTime a => Validation a
datetime :: ParseTime a => Validation a
datetime_local :: ParseTime a => Validation a

-- | <a>GroupedCollection</a> including the parsed value
type GroupedCollection' a = [(Text, [(a, (Text, Text))])]

-- | <tt>Collection</tt> including the parsed value
type Collection' a = [(a, (Text, Text))]
includes :: GroupedCollection' a -> Validation a
multi_includes :: GroupedCollection' a -> Validation [a]

-- | Map over a <a>Validation</a> with a partial function
pmap :: (a -> Maybe b) -> Validation a -> Validation b

-- | Derive a collection from an enumerable type
selectEnum :: (Show a, Read a, Bounded a, Enum a) => Collection' a

-- | Derive an indexed collection from an enumerable type
selectEnumIdx :: (Show a, Bounded a, Enum a) => Collection' a

-- | Feed a collection <a>Validation</a> from an enumerable type
enumIdx :: (Show a, Bounded a, Enum a) => (GroupedCollection' a -> Validation a) -> Validation a

-- | Feed a multi-select collection <a>Validation</a> from an enumerable
--   type
multiEnum :: (Show a, Read a, Bounded a, Enum a) => (GroupedCollection' a -> Validation [a]) -> Validation [a]

-- | Feed a multi-select collection <a>Validation</a> from an enumerable
--   type
multiEnumIdx :: (Show a, Bounded a, Enum a) => (GroupedCollection' a -> Validation [a]) -> Validation [a]

-- | Push any <a>Collection'</a> to a trivial <a>GroupedCollection'</a>
group_ :: Collection' a -> GroupedCollection' a

-- | Convert a <a>GroupedCollection'</a> to a <a>GroupedCollection</a> for
--   use in a view
viewGroupedCollection :: GroupedCollection' a -> GroupedCollection
instance (Show a, Read a, Bounded a, Enum a) => DefaultValidation (SelectEnum a)
instance Read a => DefaultValidation (ShowRead a)
instance DefaultValidation URI
instance DefaultValidation EmailAddress
instance DefaultValidation a => DefaultValidation (Maybe a)
instance Integral a => DefaultValidation (Ratio a)
instance DefaultValidation TimeOfDay
instance DefaultValidation Day
instance DefaultValidation LocalTime
instance DefaultValidation ZonedTime
instance DefaultValidation UTCTime
instance HasResolution a => DefaultValidation (Fixed a)
instance DefaultValidation Double
instance DefaultValidation Float
instance DefaultValidation Int
instance DefaultValidation Integer
instance DefaultValidation Char
instance DefaultValidation Text
instance DefaultValidation Bool
instance DefaultValidation a => DefaultValidation [a]
instance Functor Validation


-- | Forms that configure themselves based on type
--   
--   The Combined module both renders to <tt>Html</tt> and also parses
--   input.
module SimpleForm.Combined

-- | The type of a widget renderer
type Widget a = Maybe a -> Maybe Text -> Text -> InputOptions -> Input

-- | Infer a <a>Widget</a> based on type
class DefaultWidget a where wdefList _ _ _ _ = Input $ p $ toHtml "No useful multi-select box for this type."
wdef :: DefaultWidget a => Widget a
wdefList :: DefaultWidget a => Widget [a]

-- | Either try to parse the submitted values, or have a list of allowed
--   values
data Validation a
Check :: ([Text] -> Maybe a) -> Validation a
Includes :: (GroupedCollection' a) -> Validation a
class DefaultValidation a where vdefList = case vdef of { Check f -> Check (mapM f . return) Includes c -> multi_includes c }
vdef :: DefaultValidation a => Validation a
vdefList :: DefaultValidation a => Validation [a]

-- | The setup for rendering an input. Blank is <a>mempty</a>
data InputOptions
InputOptions :: Maybe Label -> Maybe Text -> Bool -> Bool -> [(Text, Text)] -> [(Text, Text)] -> [(Text, Text)] -> [(Text, Text)] -> [(Text, Text)] -> InputOptions
label :: InputOptions -> Maybe Label
hint :: InputOptions -> Maybe Text
required :: InputOptions -> Bool
disabled :: InputOptions -> Bool
input_html :: InputOptions -> [(Text, Text)]
label_html :: InputOptions -> [(Text, Text)]
error_html :: InputOptions -> [(Text, Text)]
hint_html :: InputOptions -> [(Text, Text)]
wrapper_html :: InputOptions -> [(Text, Text)]

-- | A block label, inline label, or implied value label
data Label
Label :: Text -> Label
InlineLabel :: Text -> Label
DefaultLabel :: Label

-- | Wrapper for types that should be rendered using <a>show</a>
newtype ShowRead a
ShowRead :: a -> ShowRead a
unShowRead :: ShowRead a -> a

-- | Wrapper for select boxes on enumerable types
newtype SelectEnum a
SelectEnum :: a -> SelectEnum a
unSelectEnum :: SelectEnum a -> a
button :: (Widget Text, Validation Text)
hidden :: (Widget Text, Validation Text)
checkbox :: (Widget Bool, Validation Bool)
file :: (Widget Text, Validation Text)
text :: (Widget Text, Validation Text)
textarea :: (Widget Text, Validation Text)
password :: (Widget Text, Validation Text)
search :: (Widget Text, Validation Text)
email :: (Widget EmailAddress, Validation EmailAddress)
uri :: (Widget URI, Validation URI)
tel :: (Widget Text, Validation Text)
number :: (Num a, Show a, Read a) => (Widget a, Validation a)
integral :: (Integral a, Show a, Read a) => (Widget a, Validation a)
boundedNumber :: (Bounded a, Num a, Show a, Read a) => (Widget a, Validation a)
boundedIntegral :: (Bounded a, Integral a, Show a, Read a) => (Widget a, Validation a)
date :: (FormatTime a, ParseTime a) => (Widget a, Validation a)
time :: (FormatTime a, ParseTime a) => (Widget a, Validation a)
datetime :: (FormatTime a, ParseTime a) => (Widget a, Validation a)
datetime_local :: (FormatTime a, ParseTime a) => (Widget a, Validation a)

-- | <a>GroupedCollection</a> including the parsed value
type GroupedCollection' a = [(Text, [(a, (Text, Text))])]

-- | <tt>Collection</tt> including the parsed value
type Collection' a = [(a, (Text, Text))]
select :: GroupedCollection' a -> (Widget Text, Validation a)
multi_select :: GroupedCollection' a -> (Widget [Text], Validation [a])
radio_buttons :: GroupedCollection' a -> (Widget Text, Validation a)
buttons :: GroupedCollection' a -> (Widget Text, Validation a)
checkboxes :: GroupedCollection' a -> (Widget [Text], Validation [a])

-- | Derive a collection from an enumerable type
selectEnum :: (Show a, Read a, Bounded a, Enum a) => Collection' a

-- | Feed a collection <a>Widget</a> and <a>Validation</a> from an
--   enumerable type
enum :: (Show a, Read a, Bounded a, Enum a) => (GroupedCollection' a -> (Widget Text, Validation a)) -> (Widget a, Validation a)

-- | Push any <a>Collection'</a> to a trivial <a>GroupedCollection'</a>
group_ :: Collection' a -> GroupedCollection' a

-- | Feed a multi-select collection <a>Widget</a> and <a>Validation</a>
--   from an enumerable type
multiEnum :: (Show a, Read a, Bounded a, Enum a) => (GroupedCollection' a -> (Widget [Text], Validation [a])) -> (Widget [a], Validation [a])

-- | Format identifiers nicely for humans to read
humanize :: Text -> Text
instance DefaultWidget URI
instance DefaultWidget EmailAddress

module SimpleForm.Digestive.Validation
validationToForm :: (Eq a, Monad m) => Text -> Validation a -> Form Html m a
underRef :: (Form v m a -> Form v m b) -> Form v m a -> Form v m b


-- | SimpleForm implementation that works along with digestive-functors
--   
--   The Combined module both renders to <a>Html</a> and also parses input.
module SimpleForm.Digestive.Combined

-- | A form for producing something of type r
data SimpleForm r a

-- | Convenience type synonym for combined forms
type SimpleForm' m a = SimpleForm a (Form Html m a)

-- | Render a <a>SimpleForm</a> to <a>Html</a> in the presence of input
--   
--   This also parses the input to the correct datatype.
--   
--   The <a>Html</a> is the contents of the form, but you must still wrap
--   it in the actual &lt;form&gt; element.
postSimpleForm :: Monad m => Renderer -> m (Env m) -> SimpleForm' m a -> m (Html, Maybe a)

-- | Render a <a>SimpleForm</a> to <a>Html</a>
--   
--   This produces the contents of the form, but you must still wrap it in
--   the actual &lt;form&gt; element.
getSimpleForm :: Monad m => Renderer -> Maybe a -> SimpleForm' m a -> m Html

-- | Render a <a>SimpleForm</a> to <a>Html</a> and get the return value
--   
--   This produces the contents of the form, but you must still wrap it in
--   the actual &lt;form&gt; element.
simpleForm' :: ToMarkup v => Renderer -> (View v, Maybe a) -> SimpleForm a r -> (r, Html)

-- | Create an input element for a <a>SimpleForm</a>
--   
--   <pre>
--   input "username" (Just . username) (wdef,vdef) mempty
--   </pre>
input :: (Eq a, Monad m) => Text -> (r -> Maybe a) -> (Widget a, Validation a) -> InputOptions -> SimpleForm r (Form Html m a)

-- | Same as <a>input</a>, but just use the default options
input_ :: (DefaultWidget a, DefaultValidation a, Eq a, Monad m) => Text -> (r -> Maybe a) -> SimpleForm r (Form Html m a)

-- | Add some raw markup to a <a>SimpleForm</a>
toForm :: ToMarkup h => h -> SimpleForm a ()

-- | Project out some part of the parsed data and name the subview
withFields :: Monad m => Text -> (r' -> r) -> SimpleForm r (Form Html m a) -> SimpleForm r' (Form Html m a)

-- | Project out some part of the parsed data (does not add name to
--   subview)
withFields' :: Maybe Text -> (r' -> r) -> SimpleForm r a -> SimpleForm r' a

-- | Wrap a <a>SimpleForm</a> in an <a>Html</a> tag
wrap :: (Html -> Html) -> SimpleForm r a -> SimpleForm r a

-- | Like <a>withFields</a>, but also wrap in fieldset tag
fieldset :: Monad m => Text -> (r' -> r) -> SimpleForm r (Form Html m a) -> SimpleForm r' (Form Html m a)


-- | Simple XHTML5 form renderer
module SimpleForm.Render.XHTML5
render :: Renderer


-- | Bootstrap3 form renderer
module SimpleForm.Render.Bootstrap3
render :: Renderer
