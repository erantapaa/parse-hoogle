-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | incremental folds
--   
@package foldl-incremental
@version 0.2.0.0


-- | Simple moving average style folds
module Control.Foldl.Incremental.Simple

-- | Incrementalize takes a function and turns it into a <a>Fold</a> where
--   the step is an Increment similar to the typical step in a simple
--   moving average calculation.
incrementalizeSimple :: (a -> Double) -> Int -> Fold a Double

-- | a simple moving average
sma :: Int -> Fold Double Double

-- | simple absolute moving average
sabsma :: Int -> Fold Double Double

-- | simple squared moving average
ssqma :: Int -> Fold Double Double

-- | simple standard deviation
sstd :: Int -> Fold Double Double

module Data.Histogram.Bin.BinDU

-- | Double bins of unequal sizes. Bins are defined by a vector of cuts
--   marking bounadries between bins (The entire range is continuous. There
--   are n+1 cuts for n bins Cuts are assumed to be in ascending order
--   Specialized on Data.Vector.Unboxed TODO: Generic Vector type. Type
--   paramter:
--   
--   <ul>
--   <li><i><tt>v</tt></i> type of vector used to define bin cuts</li>
--   </ul>
data BinDU
BinDU :: !(Vector Double) -> BinDU
binDU :: Vector Double -> BinDU
cuts :: BinDU -> Vector Double

-- | Create bins unsafely
unsafeBinDU :: Vector Double -> BinDU

-- | Binning algorithms which support adaption.
class Bin b => AdaptableBin b
deleteCut :: AdaptableBin b => b -> Int -> b
addCut :: AdaptableBin b => b -> Double -> b
instance Typeable BinDU
instance Data BinDU
instance Eq BinDU
instance AdaptableBin BinDU
instance NFData BinDU
instance Show BinDU
instance BinEq BinDU
instance VariableBin BinDU
instance SliceableBin BinDU
instance Bin1D BinDU
instance IntervalBin BinDU
instance Bin BinDU

module Data.Histogram.Adaptable

-- | Immutable Adaptable histogram.
type HistogramDU = Histogram BinDU Double
sliceAt :: Histogram BinDU Double -> Double -> Histogram BinDU Double

-- | dont interpolate the bin values
insertAt :: Histogram BinDU Double -> Double -> Histogram BinDU Double
mergeAtCut :: HistogramDU -> Int -> HistogramDU
smallestCutContiguous :: (Bin b, Unbox a, Ord a, Num a) => Histogram b a -> Int
smallestCutSingle :: (Bin b, Unbox a, Ord a, Num a) => Histogram b a -> Int
mergeSmallest :: HistogramDU -> HistogramDU
mergeSmallestSingle :: HistogramDU -> HistogramDU


-- | incremental folds of <a>Histogram</a>s from the <a>histogram-fill</a>
--   library.
module Control.Foldl.Incremental.Histogram

-- | incrementalizeHist takes a function governing the input to the
--   histogram.
--   
--   <pre>
--   &gt;&gt;&gt; incrementalizeHist (const 1)
--   </pre>
--   
--   is the usual boiler-plate meaning of histogram.
incrementalizeHist :: BinD -> (Double -> Double) -> Double -> Fold Double (Histogram BinD Double)

-- | 2D version
incrementalizeHist2D :: Bin2D BinD BinD -> ((Double, Double) -> Double) -> Double -> Fold (Double, Double) (Histogram (Bin2D BinD BinD) Double)

-- | incremental histogram with pre-defined bins
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Foldl.Incremental
--   
--   &gt;&gt;&gt; import qualified Control.Foldl as L
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let b = binDn 0 2 12
--   
--   &gt;&gt;&gt; L.fold (incHist b 0.9) [1..10]
--   </pre>
incHist :: BinD -> Double -> Fold Double (Histogram BinD Double)

-- | incremental 2D histogram
incHist2D :: Bin2D BinD BinD -> Double -> Fold (Double, Double) (Histogram (Bin2D BinD BinD) Double)

-- | adaptable histogram fold
--   
--   TODO: integrate Histogram.Adaptable upstream
--   
--   incHist requires a pre-specified bin, which in turn requires an
--   initial pass over the stream to determine the data ranges.
--   
--   For a one pass histogram fold, we require an incremental approach to
--   bin creation, which, in turn, requires some way of creating a
--   histogram from scratch.
--   
--   <a>Adaptable</a> and <a>BinDU</a> is a draft solution to enable a
--   one-pass at histogram creation.
--   
--   This function takes
--   
--   <ul>
--   <li>a maximum frequency (thresh) for a bin, which, when triggered
--   causes a bin to be split (at the moment using a uniform distribution
--   assumption which is pretty bad).</li>
--   <li>a minimum bin size (grain). bins are further constrained to be
--   multiples of this.</li>
--   <li>a maximum number of bins, which, when triggered, causes bins to be
--   merged.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; L.fold (incAdaptiveHist 0.2 1.0 10 1.0) [1..1000]
--   </pre>
--   
--   provides a histogram with no bin more than 20% frequency size, with a
--   minimum bin size of 1, with at most 10 bins, and a decay rate of 1.0
incAdaptiveHist :: Double -> Double -> Int -> Double -> Fold Double (Histogram BinDU Double)
instance Show IncrementHist2D


-- | This module provides incremental statistical folds based upon the
--   foldl library
--   
--   An incremental statsitical fold can be thought of as
--   exponentially-weighting statistics designed to be efficient
--   computations over a Foldable.
--   
--   Some throat clearing is required, however.
--   
--   The common usage term "exponential moving ..." refers to the
--   cumulative effect of the fold referencing the original data. From the
--   point of view of a single step, the algorithm could be better
--   described as "constant proportion" or "geometric" decay. Many other
--   methods are also possible and future versions of the library may
--   introduce some more.
--   
--   A main point of the library is that the traditional simple moving
--   average uses a sliding window of past data and thus requires keeping
--   track of the last n elements in State (in a LIFO queue most likey). It
--   may be simple for the human brain but its a more complex and costly
--   computational than this single-pass version.
--   
--   For clarity, moving average (and moving whatever) below refers to
--   geometric decay rather than the common usage. So with the throat
--   clearing out of the way:
--   
--   To avoid clashes, Control.Foldl should be qualified.
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Foldl.Incremental
--   
--   &gt;&gt;&gt; import qualified Control.Foldl as L
--   </pre>
--   
--   The folds represent incremental statistics such as moving averages`.
--   
--   The stream of moving averages with a forgetting <tt>rate</tt> of 0.9
--   is:
--   
--   <pre>
--   &gt;&gt;&gt; L.scan (ma 0.9) [1..10]
--   [NaN,1.0,1.5263157894736843,2.070110701107011,2.6312881651642916,3.2097140484969837,3.805217699371904,4.4175932632947745,5.046601250122929,5.691970329383086,6.3533993278762955]
--   </pre>
--   
--   or if you just want the moving average at the end.
--   
--   <pre>
--   &gt;&gt;&gt; L.fold (ma 0.9) [1..10]
--   6.3533993278762955
--   </pre>
--   
--   The simple average is obtained via a decay rate of 1.0 (ie no decay)
--   
--   <pre>
--   &gt;&gt;&gt; L.fold (ma 1.0) [1..10]
--   5.5
--   </pre>
--   
--   further reading:
--   
--   <a>Online Algorithms in High-frequency Trading</a> <a>recursive least
--   squares with exponential forgetting</a>
module Control.Foldl.Incremental

-- | Incrementalize takes a function and turns it into a <a>Fold</a> where
--   the step is an Increment similar to the typical step in an exponential
--   moving average calculation.
--   
--   <pre>
--   &gt;&gt;&gt; incrementalize id
--   </pre>
--   
--   is a moving average of a foldable
--   
--   <pre>
--   &gt;&gt;&gt; incrementalize (*2)
--   </pre>
--   
--   is a moving average of the square of a foldable
--   
--   This lets you build an exponential standard deviation computation
--   (using Foldl) as
--   
--   <pre>
--   &gt;&gt;&gt; std r = (\s ss -&gt; sqrt (ss - s**2)) &lt;$&gt; incrementalize id r &lt;*&gt; incrementalize (*2) r
--   </pre>
--   
--   incrementalize works with any function that produces a double. A
--   correlation fold of a tuple is quite intuitive:
--   
--   <pre>
--   &gt;&gt;&gt; cov r = (\xy xbar ybar -&gt; xy - xbar * ybar) &lt;$&gt; incrementalize (uncurry (*)) r &lt;*&gt; incrementalize fst r &lt;*&gt; incrementalize snd r
--   
--   &gt;&gt;&gt; corr r = (\cov' stdx stdy -&gt; cov' / (stdx * stdy)) &lt;$&gt; cov r &lt;*&gt; L.premap fst (std r) &lt;*&gt; L.premap snd (std r)
--   </pre>
--   
--   The rate is the parameter regulating the discount (or forgetting) of
--   current state and the introduction of the current value.
--   
--   <pre>
--   &gt;&gt;&gt; incrementalize id 1
--   </pre>
--   
--   tracks the sum/average of an entire Foldable. In other words, prior
--   values are never forgotten.
--   
--   <pre>
--   &gt;&gt;&gt; incrementalize id 0
--   </pre>
--   
--   produces the latest value (ie current state is discounted (or decays)
--   to zero). In other words, prior values are immediately forgotten.
--   
--   A exponential moving average with an exponetially-weighted length
--   (duration if its a time series) of 10 (the average lag of the values
--   effecting the calculation) is
--   
--   <pre>
--   &gt;&gt;&gt; incrementalize id (1 - 1/10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; L.fold (length 0.9) [1..100]
--   9.999734386011127
--   </pre>
--   
--   There is no particular reason for different parts to have the same
--   rate. A standard deviation where mean is expected to be static (eg
--   equal to the unconditional sample average) would be:
--   
--   <pre>
--   &gt;&gt;&gt; std' r = (\s ss -&gt; sqrt (ss - s**2)) &lt;$&gt; incrementalize id 1 &lt;*&gt; incrementalize (*2) r
--   </pre>
--   
--   and a standard deviation with a prior for the mean (eg ignoring sample
--   averges) would be:
--   
--   <pre>
--   &gt;&gt;&gt; std'' mean r = incrementalize (\x -&gt; x*2 - mean**2) r
--   </pre>
incrementalize :: (a -> Double) -> Double -> Fold a Double

-- | incremental average
ma :: Double -> Fold Double Double

-- | incremental absolute average
absma :: Double -> Fold Double Double

-- | incremental average square
sqma :: Double -> Fold Double Double

-- | incremental standard deviation
std :: Double -> Fold Double Double

-- | incremental covariance
cov :: Double -> Fold (Double, Double) Double

-- | incremental corelation
corr :: Double -> Fold (Double, Double) Double

-- | the exponentially weighted length of a rate, which is 1/(1-rate) at
--   infinity
length :: Double -> Fold a Double

-- | the beta in a simple linear regression of <a>snd</a> on <a>fst</a>
beta :: Double -> Fold (Double, Double) Double

-- | the alpha in a simple linear regression of <a>snd</a> on <a>fst</a>
alpha :: Double -> Fold (Double, Double) Double

-- | autocorrelation is a slippery concept. This method starts with the
--   concept that there is an underlying random error process (e), and
--   autocorrelation is a process on top of that ie for a one-step
--   correlation relationship.
--   
--   value<tt>t = e</tt>t + k * e@t-1
--   
--   where k is the autocorrelation.
--   
--   There are thus two decay rates needed: one for the average being
--   considered to be the dependent variable, and one for the decay of the
--   correlation calculation between the most recent value and the moving
--   average.
--   
--   <pre>
--   &gt;&gt;&gt; L.fold (autoCorr 0 1)
--   </pre>
--   
--   Would estimate the one-step autocorrelation relationship of the
--   previous value and the current value over the entire sample set.
autocorr :: Double -> Double -> Fold Double Double
instance Show Increment
