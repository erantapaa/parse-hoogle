-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | iteratees based upon mutable buffers
--   
--   Provides iteratees backed by mutable buffers. This enables iteratees
--   to run without any extra memory allocations.
@package mutable-iter
@version 0.6.1

module Data.MutableIter.IOBuffer

-- | A mutable buffer to hold storable elements. This data type supports
--   memory recycling.
data IOBuffer r el

-- | Create a buffer from a length and data array.
createIOBuffer :: Storable el => Int -> ForeignPtr Int -> ForeignPtr el -> IOBuffer r el

-- | Check if the buffer is empty.
null :: IOBuffer r el -> IO Bool

-- | Empty buffer.
empty :: Storable el => IOBuffer r el

-- | Copy data from one buffer to another.
copyBuffer :: Storable el => IOBuffer r el -> IO (IOBuffer r el)

-- | Append two buffers. Copies data from both into a new buffer.
append :: Storable el => IOBuffer r el -> IOBuffer r el -> IO (IOBuffer r el)

-- | IOBuffer length.
length :: IOBuffer r el -> IO Int

-- | Retrieve the front element from the buffer and advance the internal
--   pointer. It is an error to call this on an empty buffer.
pop :: Storable el => IOBuffer r el -> IO el

-- | Retrieve the first element, if it exists. This function does not
--   advance the buffer pointer.
lookAtHead :: Storable el => IOBuffer r el -> IO (Maybe el)

-- | Drop n elements from the front of the buffer. if the buffer has fewer
--   elements, all are dropped.
drop :: Int -> IOBuffer r el -> IO ()
dropWhile :: Storable el => (el -> Bool) -> IOBuffer r el -> IO ()

-- | Create a new buffer from the first n elements, sharing data. This
--   function advances the pointer of the original buffer.
take :: Storable el => IOBuffer r el -> Int -> IO (IOBuffer r el)

-- | Split one buffer to two, sharing storage.
splitAt :: Storable el => IOBuffer r el -> Int -> IO (IOBuffer r el, IOBuffer r el)

-- | copy data from one buffer to another with the specified map function.
--   this operation drains the original buffer.
mapBuffer :: (Storable el, Storable el') => (el -> el') -> ForeignPtr Int -> ForeignPtr el' -> IOBuffer r el -> IO (IOBuffer r el')
mapAccumBuffer :: (Storable el, Storable el') => (acc -> el -> (acc, el')) -> ForeignPtr Int -> ForeignPtr el' -> acc -> IOBuffer r el -> IO (acc, IOBuffer r el')
foldl' :: Storable b => (a -> b -> a) -> a -> IOBuffer r b -> IO a
hopfoldl' :: Storable b => Int -> (a -> b -> a) -> a -> IOBuffer r b -> IO a
hopfoldM :: Storable b => Int -> (a -> b -> IO a) -> a -> IOBuffer r b -> IO a

-- | Create a new buffer of every <tt>nth</tt> element. The original buffer
--   is not altered.
decimate :: Storable b => Int -> IOBuffer r b -> IO (IOBuffer r b)

-- | Cast a buffer to a different type. Any extra data is truncated. This
--   is not safe unless the buffer offset is 0.
castBuffer :: (Storable el, Storable el') => IOBuffer r el -> IO (IOBuffer r el')

-- | Safely convert an IOBuffer to a Vector.
freeze :: (Storable el, Vector v el, Vector v Int) => IOBuffer r el -> IO (v el)

-- | Safely convert a Vector to an IOBuffer
thaw :: (Storable el, Vector v el) => v el -> IO (IOBuffer r el)

-- | Write out the contents of the IOBuffer to a handle. This operation
--   drains the buffer.
hPut :: Storable el => Handle -> IOBuffer r el -> IO ()
unsafeToForeignPtr :: IOBuffer r el -> (Int, ForeignPtr Int, ForeignPtr el)
instance Storable el => NullPoint (IOBuffer r el)

module Data.MutableIter
newtype MIteratee s m a
MIteratee :: Iteratee s m a -> MIteratee s m a
unwrap :: MIteratee s m a -> Iteratee s m a

-- | A mutable buffer to hold storable elements. This data type supports
--   memory recycling.
data IOBuffer r el

-- | Create a buffer from a length and data array.
createIOBuffer :: Storable el => Int -> ForeignPtr Int -> ForeignPtr el -> IOBuffer r el
type MEnumerator s m a = MIteratee s m a -> m (MIteratee s m a)
type MEnumeratee sFrom sTo m a = MIteratee sTo m a -> MIteratee sFrom m (MIteratee sTo m a)
joinIob :: (MonadCatchIO m, Storable el) => MIteratee (IOBuffer r el) m (MIteratee s m a) -> MIteratee (IOBuffer r el) m a
joinIM :: Monad m => m (MIteratee (IOBuffer r el) m a) -> MIteratee (IOBuffer r el) m a
wrapEnum :: Monad m => Enumerator s m a -> MEnumerator s m a
liftI :: Monad m => (Stream s -> MIteratee s m a) -> MIteratee s m a
idone :: Monad m => a -> Stream s -> MIteratee s m a
icont :: (Stream s -> MIteratee s m a) -> Maybe SomeException -> MIteratee s m a
guardNull :: (MonadCatchIO m, Storable el) => IOBuffer r el -> MIteratee (IOBuffer r el) m a -> MIteratee (IOBuffer r el) m a -> MIteratee (IOBuffer r el) m a
isStreamFinished :: (MonadCatchIO m, Storable el) => MIteratee (IOBuffer r el) m (Maybe SomeException)
head :: (MonadCatchIO m, Storable el) => MIteratee (IOBuffer r el) m el
heads :: (MonadCatchIO m, Storable el, Eq el) => [el] -> MIteratee (IOBuffer r el) m Int
chunk :: (MonadCatchIO m, Storable el) => MIteratee (IOBuffer r el) m (IOBuffer r el)
peek :: (MonadCatchIO m, Storable el) => MIteratee (IOBuffer r el) m (Maybe el)
drop :: (MonadCatchIO m, Storable el) => Int -> MIteratee (IOBuffer r el) m ()
dropWhile :: (MonadCatchIO m, Storable el) => (el -> Bool) -> MIteratee (IOBuffer r el) m ()
foldl' :: (MonadCatchIO m, Storable el, Show a) => (a -> el -> a) -> a -> MIteratee (IOBuffer r el) m a
hopfoldl' :: (MonadCatchIO m, Storable el, Show a) => Int -> (a -> el -> a) -> a -> MIteratee (IOBuffer r el) m a
mapStream :: (MonadCatchIO pr, Storable elo, Storable eli) => Int -> (eli -> elo) -> MEnumeratee (IOBuffer r eli) (IOBuffer r elo) pr a
mapChunk :: (Storable el, MonadCatchIO m) => (IOBuffer r el -> m s2) -> MEnumeratee (IOBuffer r el) s2 m a
mapAccum :: (MonadCatchIO pr, Storable eli, Storable elo) => Int -> (b -> eli -> (b, elo)) -> b -> MEnumeratee (IOBuffer r eli) (IOBuffer r elo) pr a
convStream :: (MonadCatchIO pr, Storable elo, Storable eli) => MIteratee (IOBuffer r eli) pr (IOBuffer r elo) -> MEnumeratee (IOBuffer r eli) (IOBuffer r elo) pr a

-- | The most general stream converter. Given a function to produce
--   iteratee transformers and an initial state, convert the stream using
--   iteratees generated by the function while continually updating the
--   internal state.
unfoldConvStream :: (MonadCatchIO m, Storable eli, Storable elo) => (acc -> MIteratee (IOBuffer r eli) m (acc, IOBuffer r elo)) -> acc -> MEnumeratee (IOBuffer r eli) (IOBuffer r elo) m a

-- | Decimate a stream by taking every n'th element, starting at element
--   <a>m</a>.
getChannel :: (MonadCatchIO m, Storable el) => Int -> Int -> MEnumeratee (IOBuffer r el) (IOBuffer r el) m a
takeUpTo :: (MonadCatchIO pr, Storable el) => Int -> MEnumeratee (IOBuffer r el) (IOBuffer r el) pr a

-- | Convert a Vector iteratee to an MIteratee. Slower but convenient.
fromUVector :: (Unbox el, Storable el, MonadCatchIO m) => Iteratee (Vector el) m a -> MIteratee (IOBuffer r el) m a
enumHandleRandom :: (MonadCatchIO m, Storable el) => Int -> Handle -> MIteratee (IOBuffer r el) m a -> m (MIteratee (IOBuffer r el) m a)
fileDriverRandom :: (MonadCatchIO m, Storable el) => Int -> (forall r. MIteratee (IOBuffer r el) m a) -> FilePath -> m a
newFp :: Storable a => a -> IO (ForeignPtr a)
instance (Monad m, Functor m) => Functor (MIteratee s m)
instance (MonadCatchIO m, Storable el) => MonadCatchIO (MIteratee (IOBuffer r el) m)
instance (MonadIO m, Storable el) => MonadIO (MIteratee (IOBuffer r el) m)
instance Storable el => MonadTrans (MIteratee (IOBuffer s el))
instance (MonadIO m, Storable el) => Monad (MIteratee (IOBuffer r el) m)


-- | Iteratees for parsing binary data.
module Data.MutableIter.Binary

-- | Indicate endian-ness.
data Endian :: *

-- | Most Significant Byte is first (big-endian)
MSB :: Endian

-- | Least Significan Byte is first (little-endian)
LSB :: Endian
endianRead2 :: MonadCatchIO m => Endian -> MIteratee (IOBuffer r Word8) m Word16

-- | read 3 bytes in an endian manner. If the first bit is set (negative),
--   set the entire first byte so the Word32 can be properly set negative
--   as well.
endianRead3 :: MonadCatchIO m => Endian -> MIteratee (IOBuffer r Word8) m Word32
endianRead4 :: MonadCatchIO m => Endian -> MIteratee (IOBuffer r Word8) m Word32
