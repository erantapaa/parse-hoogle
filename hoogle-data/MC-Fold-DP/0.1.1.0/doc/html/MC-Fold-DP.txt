-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Folding algorithm based on nucleotide cyclic motifs.
--   
--   This is a RNA secondary structure prediction tool based on the idea of
--   combining small motifs, called nucleotide cyclic motifs (NCMs). The
--   algorithm implemented here and described in
--   
--   Hoener zu Siederdissen C, Bernhart SH, Stadler PF, Hofacker IL,
--   
--   <a>A Folding Algorithm for Extended RNA Secondary Structures</a>,
--   
--   Bioinformatics (2011) 27 (13), i129-136
--   
--   <a>http://www.tbi.univie.ac.at/software/rnawolf/</a>
--   
--   has polynomial runtime in O(n^3) and uses a (pseudo-energy) scoring
--   scheme based on
--   
--   Parisien M, Major F.
--   
--   <a>The MC-Fold and MC-Sym pipeline infers RNA structure from sequence
--   data</a>,
--   
--   Nature 2008, 452(7183):51-55. <a>http://www.major.iric.ca/MC-Fold/</a>
--   
--   This program uses the same database as MC-Fold (which has exponential
--   run-time) and aims to be able to produce the same results.
--   
--   The underlying grammar of our implementation is unambiguous and allows
--   the complete evaluation of all structures within an energy band above
--   the ground state, presenting each unique structure just once.
--   Alternatively, the grammar allows partition function calculations.
--   
--   Current status:
--   
--   <ul>
--   <li>comparable prediction accuracy on sequences (compared with
--   MC-Fold)</li>
--   <li>possibility to use sparse data correction</li>
--   <li>handles non-ACGU nucleotides gracefully</li>
--   <li>suboptimals: return all structures within an energy band above the
--   ground state</li>
--   <li>constraint folding (fill partial structures)</li>
--   </ul>
--   
--   Todo:
--   
--   <ul>
--   <li>Boltzmann likelihood calculations</li>
--   <li>pseudoknot calculations (currently aiming for a pknotsRG-like
--   algorithm)</li>
--   </ul>
@package MC-Fold-DP
@version 0.1.1.0


-- | TODO bonus system for matching <a>()</a> bracking still broken?!
module BioInf.MCFoldDP

-- | Folding wrapper
fold :: MotifDB -> Primary -> Constraint -> Tables

-- | Folding in the ST monad. the number of dncm tables is the same as the
--   number of known double NCMs.
foldST :: MotifDB -> Primary -> Constraint -> ST s Tables

-- | Backtracking suboptimal results
backtrack :: MotifDB -> Double -> Primary -> Constraint -> Tables -> [(Double, D1Secondary)]

-- | singleNCM insertion
fncmSingle :: MotifDB -> Primary -> Constraint -> Int -> Int -> Double

-- | double NCM extend single NCM. We do not care that this is
--   comparatively slow as it is called only a few times, anyway.
--   
--   TODO make faster (better lookup system) TODO otherwise case TODO eats
--   another ~10% performance
fncmDS :: MotifDB -> Primary -> Constraint -> Int -> Int -> Int -> Int -> Table2 -> Double

-- | double NCM extending another double NCM.
--   
--   TODO this one could profit from performance improvements. But check
--   first vs. multibranch timings TODO remove otherwise case TODO improve
--   performance, eats ~66% of total time TODO improve: return empty vector
--   on error, write special minimum function that has eInf on empty
fncmDD :: MotifDB -> Primary -> Constraint -> Int -> Int -> Int -> Int -> [Table2] -> Vector (Int, Double)

-- | Add one stem for <a>external</a> calculations
--   
--   TODO make efficient
fStemExt :: [Table2] -> Int -> Int -> Vector (Int, Int, Double)

-- | Combine stems for <a>external</a> calculations
fStemExtExt :: [Table2] -> Table2 -> Int -> Int -> Vector (Int, Int, Double)

-- | Close a multibranched loop with a singleNCM
--   
--   TODO close with singleNCM
fMulti :: MotifDB -> Primary -> Constraint -> Int -> Int -> Table2 -> Table2 -> Vector (Int, Double)

-- | Connect a partial multibranched structure with a hairpin. Note that
--   the <a>dncm</a> hairpin part wants one table, not the list of all
--   tables.
fMMbrStem :: Int -> Int -> Table2 -> Table2 -> Vector (Int, Double)

-- | Add the first stem
fMStem :: Int -> Int -> Table2 -> Vector (Int, Double)

-- | Interior loops of some size
--   
--   TODO this could profit from a log-based scoring function
fInterior :: MotifDB -> Primary -> Constraint -> Int -> Int -> Table2 -> Vector ((Int, Int), Double)

-- | The default two-dim table
mkTable2 :: (Num t, Constants b, PrimArrayOpsM (t, t) b m) => t -> m (PrimArray (t, t) b, PrimArrayM (t, t) b m)

-- | Create a 2-dim table
mkTable2With :: (Num t, PrimArrayOpsM (t, t) b m) => b -> t -> m (PrimArray (t, t) b, PrimArrayM (t, t) b m)

-- | minimum for unboxed vectors, capturing possible 0-length. Vectors in
--   this algorithm always carry positional information.
--   
--   TODO the next version of the vector library should handle <a>VU.map
--   snd</a> better
vuminimumP :: (Ord a, Constants a, Unbox t, Unbox a) => Vector (t, a) -> a
vuminimum :: (Ord a, Constants a, Unbox a) => Vector a -> a
type Table2 = PrimArray (Int, Int) Double
type Table4 = PrimArray (Int, Int, Int, Int) Double
type Tables = (Table2, [Table2], Table2, Table2, Table2)
bonusScore :: Double

-- | Give a certain <a>bonusScore</a> for the constraints that have been
--   fulfilled.
--   
--   TODO should we be more lenient with constraints that would increase
--   the total energy?
giveBonus :: Constraint -> Int -> Int -> Double
