-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Catchy combinators for HUnit
--   
@package hspec-expectations
@version 0.7.0


-- | Experimental combinators, that may become part of the main
--   distribution, if they turn out to be useful for a wider audience.
module Test.Hspec.Expectations.Contrib

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <i>Since: 4.7.0.0</i>
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <i>Since: 4.7.0.0</i>
isRight :: Either a b -> Bool


-- | Introductory documentation:
--   <a>https://github.com/sol/hspec-expectations#readme</a>
module Test.Hspec.Expectations
type Expectation = Assertion

-- | This is just an alias for HUnit's <a>assertFailure</a>.
expectationFailure :: String -> Expectation

-- | <tt>actual `shouldBe` expected</tt> sets the expectation that
--   <tt>actual</tt> is equal to <tt>expected</tt> (this is just an alias
--   for <a>@?=</a>).
shouldBe :: (Show a, Eq a) => a -> a -> Expectation

-- | <tt>v `shouldSatisfy` p</tt> sets the expectation that <tt>p v</tt> is
--   <tt>True</tt>.
shouldSatisfy :: Show a => a -> (a -> Bool) -> Expectation

-- | <tt>list `shouldStartWith` prefix</tt> sets the expectation that
--   <tt>list</tt> starts with <tt>prefix</tt>,
shouldStartWith :: (Show a, Eq a) => [a] -> [a] -> Expectation

-- | <tt>list `shouldEndWith` suffix</tt> sets the expectation that
--   <tt>list</tt> ends with <tt>suffix</tt>,
shouldEndWith :: (Show a, Eq a) => [a] -> [a] -> Expectation

-- | <tt>list `shouldContain` sublist</tt> sets the expectation that
--   <tt>sublist</tt> is contained, wholly and intact, anywhere in
--   <tt>list</tt>.
shouldContain :: (Show a, Eq a) => [a] -> [a] -> Expectation

-- | <tt>xs `shouldMatchList` ys</tt> sets the expectation that <tt>xs</tt>
--   has the same elements that <tt>ys</tt> has, possibly in another order
shouldMatchList :: (Show a, Eq a) => [a] -> [a] -> Expectation

-- | <tt>action `shouldReturn` expected</tt> sets the expectation that
--   <tt>action</tt> returns <tt>expected</tt>.
shouldReturn :: (Show a, Eq a) => IO a -> a -> Expectation

-- | <tt>actual `shouldNotBe` notExpected</tt> sets the expectation that
--   <tt>actual</tt> is not equal to <tt>notExpected</tt>
shouldNotBe :: (Show a, Eq a) => a -> a -> Expectation

-- | <tt>v `shouldNotSatisfy` p</tt> sets the expectation that <tt>p v</tt>
--   is <tt>False</tt>.
shouldNotSatisfy :: Show a => a -> (a -> Bool) -> Expectation

-- | <tt>list `shouldNotContain` sublist</tt> sets the expectation that
--   <tt>sublist</tt> is not contained anywhere in <tt>list</tt>.
shouldNotContain :: (Show a, Eq a) => [a] -> [a] -> Expectation

-- | <tt>action `shouldNotReturn` notExpected</tt> sets the expectation
--   that <tt>action</tt> does not return <tt>notExpected</tt>.
shouldNotReturn :: (Show a, Eq a) => IO a -> a -> Expectation

-- | <tt>action `shouldThrow` selector</tt> sets the expectation that
--   <tt>action</tt> throws an exception. The precise nature of the
--   expected exception is described with a <a>Selector</a>.
shouldThrow :: Exception e => IO a -> Selector e -> Expectation

-- | A <tt>Selector</tt> is a predicate; it can simultaneously constrain
--   the type and value of an exception.
type Selector a = a -> Bool
anyException :: Selector SomeException
anyErrorCall :: Selector ErrorCall
anyIOException :: Selector IOException
anyArithException :: Selector ArithException
errorCall :: String -> Selector ErrorCall
