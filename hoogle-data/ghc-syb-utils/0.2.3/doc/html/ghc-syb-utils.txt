-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Scrap Your Boilerplate utilities for the GHC API.
--   
--   Scrap Your Boilerplate utilities for the GHC API.
@package ghc-syb-utils
@version 0.2.3


-- | <a>GHC.Syb.Utils</a> provides common utilities for the Ghc Api, either
--   based on Data/Typeable or for use with Data.Generics over Ghc Api
--   types.
--   
--   example output of <a>showData</a> on <a>parsedSource</a>,
--   <a>renamedSource</a>, and <a>typecheckedSource</a> for a trivial
--   <tt>HelloWorld</tt> module, compared with <a>ppr</a> output:
--   
--   <pre>
--   ------------------------- pretty-printed parsedSource
--   module HelloWorld where
--   main = putStrLn "Hello, World!"
--   ------------------------- pretty-printed renamedSource
--   Just (HelloWorld.main = System.IO.putStrLn "Hello, World!",
--         [import Prelude],
--         Nothing,
--         Nothing,
--   
--   (HaddockModInfo
--    (Nothing)
--    (Nothing)
--    (Nothing)
--    (Nothing)))
--   ------------------------- pretty-printed typecheckedSource
--   Just &lt;AbsBinds [] [] [HelloWorld.main &lt;= [] main]
--           HelloWorld.main :: GHC.IOBase.IO ()
--           []
--           { main = System.IO.putStrLn "Hello, World!" }&gt;
--   ------------------------- shown parsedSource
--   
--   (L {HelloWorld.hs:1:0}
--    (HsModule
--     (Just
--      (L {HelloWorld.hs:1:7-16} {ModuleName: HelloWorld}))
--     (Nothing)
--     []
--     [
--      (L {HelloWorld.hs:2:0-30}
--       (ValD
--        (FunBind
--         (L {HelloWorld.hs:2:0-3}
--          (Unqual {OccName: main}))
--         (False)
--         (MatchGroup
--          [
--           (L {HelloWorld.hs:2:0-30}
--            (Match
--             []
--             (Nothing)
--             (GRHSs
--              [
--               (L {HelloWorld.hs:2:7-30}
--                (GRHS
--                 []
--                 (L {HelloWorld.hs:2:7-30}
--                  (HsApp
--                   (L {HelloWorld.hs:2:7-14}
--                    (HsVar
--                     (Unqual {OccName: putStrLn})))
--                   (L {HelloWorld.hs:2:16-30}
--                    (HsLit
--                     (HsString {FastString: "Hello, World!"})))))))]
--              (EmptyLocalBinds))))] {!type placeholder here?!})
--         (WpHole) {!NameSet placeholder here!}
--         (Nothing))))]
--     (Nothing)
--     (HaddockModInfo
--      (Nothing)
--      (Nothing)
--      (Nothing)
--      (Nothing))
--     (Nothing)))
--   ------------------------- shown renamedSource
--   
--   ((,,,,)
--    (HsGroup
--     (ValBindsOut
--      [
--       ((,)
--        (NonRecursive) {Bag(Located (HsBind Name)):
--        [
--         (L {HelloWorld.hs:2:0-30}
--          (FunBind
--           (L {HelloWorld.hs:2:0-3} {Name: HelloWorld.main})
--           (False)
--           (MatchGroup
--            [
--             (L {HelloWorld.hs:2:0-30}
--              (Match
--               []
--               (Nothing)
--               (GRHSs
--                [
--                 (L {HelloWorld.hs:2:7-30}
--                  (GRHS
--                   []
--                   (L {HelloWorld.hs:2:7-30}
--                    (HsApp
--                     (L {HelloWorld.hs:2:7-14}
--                      (HsVar {Name: System.IO.putStrLn}))
--                     (L {HelloWorld.hs:2:16-30}
--                      (HsLit
--                       (HsString {FastString: "Hello, World!"})))))))]
--                (EmptyLocalBinds))))] {!type placeholder here?!})
--           (WpHole) {NameSet:
--           [{Name: System.IO.putStrLn}]}
--           (Nothing)))]})]
--      [])
--     []
--     []
--     []
--     []
--     []
--     []
--     []
--     []
--     [])
--    [
--     (L {Implicit import declaration}
--      (ImportDecl
--       (L {Implicit import declaration} {ModuleName: Prelude})
--       (False)
--       (False)
--       (Nothing)
--       (Nothing)))]
--    (Nothing)
--    (Nothing)
--    (HaddockModInfo
--     (Nothing)
--     (Nothing)
--     (Nothing)
--     (Nothing)))
--   ------------------------- shown typecheckedSource
--   {Bag(Located (HsBind Var)):
--   [
--    (L {HelloWorld.hs:2:0-30}
--     (AbsBinds
--      []
--      []
--      [
--       ((,,,)
--        [] {Var: HelloWorld.main} {Var: main}
--        [])] {Bag(Located (HsBind Var)):
--      [
--       (L {HelloWorld.hs:2:0-30}
--        (FunBind
--         (L {HelloWorld.hs:2:0-3} {Var: main})
--         (False)
--         (MatchGroup
--          [
--           (L {HelloWorld.hs:2:0-30}
--            (Match
--             []
--             (Nothing)
--             (GRHSs
--              [
--               (L {HelloWorld.hs:2:7-30}
--                (GRHS
--                 []
--                 (L {HelloWorld.hs:2:7-30}
--                  (HsApp
--                   (L {HelloWorld.hs:2:7-14}
--                    (HsVar {Var: System.IO.putStrLn}))
--                   (L {HelloWorld.hs:2:16-30}
--                    (HsLit
--                     (HsString {FastString: "Hello, World!"})))))))]
--              (EmptyLocalBinds))))] GHC.IOBase.IO ())
--         (WpHole) {!NameSet placeholder here!}
--         (Nothing)))]}))]}
--   </pre>
module GHC.SYB.Utils
nameSetElems :: NameSet -> [Name]
showSDoc_ :: SDoc -> String

-- | Ghc Ast types tend to have undefined holes, to be filled by later
--   compiler phases. We tag Asts with their source, so that we can avoid
--   such holes based on who generated the Asts.
data Stage
Parser :: Stage
Renamer :: Stage
TypeChecker :: Stage

-- | Generic Data-based show, with special cases for GHC Ast types, and
--   simplistic indentation-based layout (the <a>Int</a> parameter);
--   showing abstract types abstractly and avoiding known potholes (based
--   on the <a>Stage</a> that generated the Ast)
showData :: Data a => Stage -> Int -> a -> String

-- | Like <a>everything</a>, but avoid known potholes, based on the
--   <a>Stage</a> that generated the Ast.
everythingStaged :: Stage -> (r -> r -> r) -> r -> GenericQ r -> GenericQ r

-- | A variation of <a>everything</a>, using a 'GenericQ Bool' to skip
--   parts of the input <a>Data</a>. everythingBut :: GenericQ Bool -&gt;
--   (r -&gt; r -&gt; r) -&gt; r -&gt; GenericQ r -&gt; GenericQ r
--   everythingBut q k z f x | q x = z | otherwise = foldl k (f x) (gmapQ
--   (everythingBut q k z f) x)
everythingButStaged :: Stage -> (r -> r -> r) -> r -> GenericQ (r, Bool) -> GenericQ r

-- | Look up a subterm by means of a maybe-typed filter.
somethingStaged :: Stage -> (Maybe u) -> GenericQ (Maybe u) -> GenericQ (Maybe u)

-- | Apply a monadic transformation at least somewhere.
--   
--   The transformation is tried in a top-down manner and descends down if
--   it fails to apply at the root of the term. If the transformation fails
--   to apply anywhere within the the term, the whole operation fails.
somewhereStaged :: MonadPlus m => Stage -> GenericM m -> GenericM m

-- | Monadic variation on everywhere
everywhereMStaged :: Monad m => Stage -> GenericM m -> GenericM m
instance Eq Stage
instance Ord Stage
instance Show Stage
