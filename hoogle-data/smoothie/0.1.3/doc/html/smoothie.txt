-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Smooth curves via several splines and polynomials.
--   
@package smoothie
@version 0.1.3


module Data.Spline.CP

-- | A <a>CP</a> is a *control point*. A curve passes through control
--   points and the shape of the curve is determined by the polynomials
--   used to interpolate values in between.
--   
--   <tt>CP s a</tt> is a control point of sampling type <tt>s</tt> and
--   carried type <tt>a</tt>. In most cases, <tt>s</tt> must be <a>Ord</a>
--   and <tt>a</tt> must be <tt>Additive</tt> and <a>Fractional</a>.
data CP s a
CP :: !s -> !a -> CP s a
instance Functor (CP s)
instance (Eq s, Eq a) => Eq (CP s a)
instance (Ord s, Ord a) => Ord (CP s a)
instance (Show s, Show a) => Show (CP s a)


module Data.Spline.Polynomial

-- | A <a>Polynomial</a> is used to interpolate in between a spline’s
--   control points.
data Polynomial s a

-- | Constant polynomial – a.k.a. <i>no interpolation</i>.
--   
--   Given two control points and a sample value in between, the
--   <a>hold</a> polynomial won’t perform any interpolation but it just
--   <i>holds</i> the value carried by the lower control point along the
--   whole curve between the two control points.
hold :: Ord s => Polynomial s a

-- | 1-degree polynomial – a.k.a. <i>straight line interpolation</i>, or
--   /linear interpolation/.
--   
--   This polynomial connects control points with straight lines.
--   
--   Note: implemented with <tt>linearBy id</tt>.
linear :: (Additive a, Fractional s, Ord s) => Polynomial s (a s)

-- | Parametric linear polynomial.
--   
--   This form applies a pre-filter on the input before performing a linear
--   interpolation. Instead of:
--   
--   <pre>
--   lerp x a b
--   </pre>
--   
--   We have:
--   
--   <pre>
--   lerp (pref x) a b
--   </pre>
--   
--   This can be used to implement 1-degree splines if <tt>pref = id</tt>,
--   basic cubic non-hermitian splines if <tt>pref = (^3)</tt>, cosine
--   splines if <tt>pref = x -&gt; (1 - cos (x*pi)) * 0.5</tt>, and so on
--   and so forth.
linearBy :: (Additive a, Fractional s, Ord s) => (s -> s) -> Polynomial s (a s)

-- | Cosine polynomial.
cosine :: (Additive a, Floating s, Ord s) => Polynomial s (a s)

-- | Helper binary search that search the ceiling index for the value to be
--   searched according to the predicate.
bsearchLower :: (a -> Ordering) -> Vector a -> Maybe Int


-- | A <tt>Spline s a</tt> represents a curve in which <tt>a</tt> is very
--   likely to be <tt>Additive</tt> (see "linear") and <tt>s</tt> is the
--   sampling type.
--   
--   The library exports two useful functions: <a>spline</a> and
--   <a>smooth</a>. The former enables you to create splines while the
--   latter enables you to sample from them using their control points.
module Data.Spline

-- | A <tt>Spline</tt> is a collection of control points with associated
--   polynomials. Given two control points which indices are <i>i</i> and
--   <i>i+1</i>, interpolation on the resulting curve is performed using
--   the polynomial of indice <i>i</i>. Thus, the latest control point is
--   ignored and can be set to whatever the user wants to, even
--   <a>undefined</a> – you should use hold, though. Yeah, don’t go filthy.
data Spline s a

-- | Create a spline using a list of control points and associated
--   polynomials. Since <a>spline</a> sorts the list before creating the
--   <a>Spline</a>, you don’t have to ensure the list is sorted – even
--   though you should, setting control points with no order might be…
--   chaotic.
spline :: (Ord a, Ord s) => [(CP s a, Polynomial s a)] -> Spline s a

-- | Smoothly interpolate a point on a spline.
smooth :: Ord s => Spline s a -> s -> Maybe a
