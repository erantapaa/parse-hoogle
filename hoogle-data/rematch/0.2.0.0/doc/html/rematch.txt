-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple api for matchers
--   
--   Rematch is a simple library of matchers, which express rules that can
--   pass or fail. Matchers also report their failure with human readable
--   output. Custom matchers can be build, and matchers can be combined
--   using several predefined combinators or you can write your own.
--   Matchers are often used in automated tests to provide expressive
--   failure messages. Rematch is very similar to, and very inspired by the
--   hamcrest library for Java
@package rematch
@version 0.2.0.0


-- | This module contains some utility functions for formatting
--   descriptions It is probably only useful when you're writing your own
--   matchers
module Control.Rematch.Formatting
describeList :: String -> [String] -> String

-- | Utility function for formatting a list of strings with a separator
join :: String -> [String] -> String

module Control.Rematch.Run

-- | A type representing a match success or failure.
data Match
MatchSuccess :: Match
MatchFailure :: String -> Match
instance Eq Match
instance Show Match


-- | This module defines an api for matchers: rules that can pass or fail,
--   and describe their failure and success conditions for humans to read.
--   
--   This module also exports some useful matchers for things in the
--   <a>Prelude</a>, and some combinators that are useful for combining
--   several matchers into one.
module Control.Rematch

-- | The basic api for a matcher
data Matcher a
Matcher :: (a -> Bool) -> String -> (a -> String) -> Matcher a

-- | A function that returns True if the matcher should pass, False if it
--   should fail
match :: Matcher a -> a -> Bool

-- | A description of the matcher (usually of its success conditions)
description :: Matcher a -> String

-- | A description to be shown if the match fails.
describeMismatch :: Matcher a -> a -> String

-- | Run a matcher, producing a Match with a good error string
runMatch :: Matcher a -> a -> Match

-- | Matcher on equality
is :: (Show a, Eq a) => a -> Matcher a

-- | Matcher on equality
equalTo :: (Show a, Eq a) => a -> Matcher a

-- | Matches if the input list is empty
isEmpty :: Show a => Matcher [a]

-- | Matches if the input list has the required size
hasSize :: Show a => Int -> Matcher [a]

-- | Matches if every item in the input list passes a matcher
everyItem :: Matcher a -> Matcher [a]

-- | Matches if any of the items in the input list passes the provided
--   matcher
hasItem :: Matcher a -> Matcher [a]

-- | Matches if the input is greater than the required number
greaterThan :: (Ord a, Show a) => a -> Matcher a

-- | Matches if the input is greater than or equal to the required number
greaterThanOrEqual :: (Ord a, Show a) => a -> Matcher a

-- | Matches if the input is less than the required number
lessThan :: (Ord a, Show a) => a -> Matcher a

-- | Matches if the input is less than or equal to the required number
lessThanOrEqual :: (Ord a, Show a) => a -> Matcher a

-- | Matches if the input is (Just a)
isJust :: Show a => Matcher (Maybe a)

-- | Matcher combinator, turns Matcher a to Matcher (Maybe a) Fails if the
--   Maybe is Nothing, otherwise tries the original matcher on the content
--   of the Maybe
hasJust :: Matcher a -> Matcher (Maybe a)

-- | Matches if the input is Nothing
isNothing :: Show a => Matcher (Maybe a)

-- | Matches if an Either is Right
isRight :: (Show a, Show b) => Matcher (Either a b)

-- | Matcher combinator: turns a Matcher b into a Matcher on the Right side
--   of an Either a b
hasRight :: (Show a, Show b) => Matcher b -> Matcher (Either a b)

-- | Matches if an Either is Left
isLeft :: (Show a, Show b) => Matcher (Either a b)

-- | Matcher combinator: turns a Matcher a into a Matcher on the Left side
--   of an Either a b
hasLeft :: (Show a, Show b) => Matcher a -> Matcher (Either a b)

-- | Inverts a matcher, so success becomes failure, and failure becomes
--   success
isNot :: Matcher a -> Matcher a

-- | Matches if all of a list of matchers pass
allOf :: [Matcher a] -> Matcher a

-- | Matches if any of a list of matchers pass
anyOf :: [Matcher a] -> Matcher a

-- | A combinator that translates Matcher a to Matcher b using a function
--   :: (a -&gt; b) Takes a name of the function for better error messages
--   
--   Using this as an infix operator gets you some nice syntax: expect ((is
--   1) <a>on</a> (length, <a>length</a>)) []
on :: Matcher b -> (a -> b, String) -> Matcher a

-- | Builds a Matcher a out of a name and a function from (a -&gt; a -&gt;
--   Bool) Succeeds if the function returns true, fails if the function
--   returns false
matcherOn :: Show a => String -> (a -> a -> Bool) -> a -> Matcher a

-- | Utility function for running a list of matchers
matchList :: [Matcher a] -> a -> [Bool]

-- | A standard mismatch description on (Show a): standardMismatch 1 ==
--   <a>was 1</a>
standardMismatch :: Show a => a -> String
