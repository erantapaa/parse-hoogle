-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Haskore Computer Music System
--   
--   Compose music using programming features. Output in MIDI, CSound,
--   SuperCollider or as an audio signal.
@package haskore
@version 0.2.0.5

module Haskore.Interface.CSound.OrchestraFunction
elemSorted :: Ord a => a -> [a] -> Bool
allowedArgs :: [(String, [Int])] -> String -> Int -> Bool
argCountTable :: [(String, [Int])]

module Haskore.Interface.CSound
newtype Instrument
Instrument :: Int -> Instrument
instrument :: Int -> Instrument
instruments :: [Instrument]
instrumentToNumber :: Instrument -> Int
showInstrumentNumber :: Instrument -> String
type Name = String
type Velocity = Float
type PField = Float
type Time = Float
instance Show Instrument
instance Eq Instrument

module Haskore.Interface.CSound.InstrumentMap
type SoundTable instr = [(instr, Instrument)]
tableFromInstruments :: [instr] -> SoundTable instr
addToTable :: Eq instr => instr -> Instrument -> SoundTable instr -> SoundTable instr
type ToSound instr = instr -> ([PField], Instrument)
lookup :: Eq instr => SoundTable instr -> ToSound instr

module Medium.Controlled
class C medium
control :: C medium => control -> medium control a -> medium control a
switchBinary :: C medium => (a -> b) -> (medium control a -> medium control a -> b) -> (medium control a -> medium control a -> b) -> (control -> medium control a -> b) -> (b -> medium control a -> b)
switchList :: C medium => (a -> b) -> ([medium control a] -> b) -> ([medium control a] -> b) -> (control -> medium control a -> b) -> medium control a -> b
foldList :: C medium => (a -> b) -> ([b] -> b) -> ([b] -> b) -> (c -> b -> b) -> medium c a -> b
foldBin :: C medium => (a -> b) -> (b -> b -> b) -> (b -> b -> b) -> (c -> b -> b) -> b -> medium c a -> b

module Haskore.Basic.Pitch
type T = (Octave, Class)
data Class
Cf :: Class
C :: Class
Cs :: Class
Df :: Class
D :: Class
Ds :: Class
Ef :: Class
E :: Class
Es :: Class
Ff :: Class
F :: Class
Fs :: Class
Gf :: Class
G :: Class
Gs :: Class
Af :: Class
A :: Class
As :: Class
Bf :: Class
B :: Class
Bs :: Class
type Octave = Int
type Absolute = Int
type Relative = Int
toInt :: T -> Absolute
fromInt :: Absolute -> T
classToInt :: Class -> Relative
classParse :: ReadS Class
classFormat :: Class -> ShowS
intToFreq :: Floating a => Absolute -> a
transpose :: Relative -> T -> T
instance Eq Class
instance Ord Class
instance Ix Class
instance Enum Class
instance Show Class
instance Read Class

module Haskore.Basic.Scale
type T = [Absolute]
ionian :: Class -> T
dorian :: Class -> T
phrygian :: Class -> T
lydian :: Class -> T
mixolydian :: Class -> T
aeolian :: Class -> T
lokrian :: Class -> T
altered :: Class -> T
htwt :: Class -> T
wtht :: Class -> T
ionianRel :: Intervals
dorianRel :: Intervals
phrygianRel :: Intervals
lydianRel :: Intervals
mixolydianRel :: Intervals
aeolianRel :: Intervals
lokrianRel :: Intervals
alteredRel :: Intervals
htwtRel :: Intervals
wthtRel :: Intervals
fromOffsets :: [Absolute] -> Class -> T
fromIntervals :: Intervals -> Class -> T
continue :: T -> T

module Haskore.Interface.AutoTrack.ScaleChart
newtype T
Cons :: T -> T

module Haskore.Interface.AutoTrack.Transposeable
class C a
transpose :: C a => Int -> a -> a
instance C Class

module Haskore.Interface.AutoTrack.Instrument
data T
bass :: T
bottomRange :: T -> Class -> T
topRange :: T -> Class -> T

module Haskore.Basic.Interval
unison :: Integral a => a
octaveMajorSeventh :: Integral a => a
octaveMinorSeventh :: Integral a => a
octaveMajorSixth :: Integral a => a
octaveMinorSixth :: Integral a => a
octaveFifth :: Integral a => a
octaveFourth :: Integral a => a
octaveMajorThird :: Integral a => a
octaveMinorThird :: Integral a => a
octaveMajorSecond :: Integral a => a
octaveMinorSecond :: Integral a => a
octave :: Integral a => a
majorSeventh :: Integral a => a
minorSeventh :: Integral a => a
majorSixth :: Integral a => a
minorSixth :: Integral a => a
fifth :: Integral a => a
fourth :: Integral a => a
majorThird :: Integral a => a
minorThird :: Integral a => a
majorSecond :: Integral a => a
minorSecond :: Integral a => a

module Haskore.Basic.Dynamics
type Velocity = Rational
type T = Rational
normal :: Velocity
forteFortissimo :: Velocity
fortissimo :: Velocity
forte :: Velocity
mezzoForte :: Velocity
pianoPianissimo :: Velocity
pianissimo :: Velocity
piano :: Velocity
mezzoPiano :: Velocity
fff :: Velocity
ff :: Velocity
f :: Velocity
mf :: Velocity
ppp :: Velocity
pp :: Velocity
p :: Velocity
mp :: Velocity

module Haskore.Interface.CSound.Generator
data T
Routine :: Number -> [Parameter] -> T
SoundFile :: SFName -> SkipTime -> ChanNum -> T
type SFName = String
type SkipTime = Time
type ChanNum = Float
type Number = Int
type Parameter = Float
soundFile :: SFName -> SkipTime -> ChanNum -> T
tableValues :: [Parameter] -> T
polynomial :: Interval -> Coefficients -> T
type Interval = (Float, Float)
type Coefficients = [Float]
exponential1 :: StartPt -> [(SegLength, EndPt)] -> T
type StartPt = Float
type SegLength = Float
type EndPt = Float
exponential2 :: [Point] -> T
type Point = (Float, Float)
cubic :: StartPt -> [(SegLength, EndPt)] -> T
lineSeg1 :: StartPt -> [(SegLength, EndPt)] -> T
lineSeg2 :: [Point] -> T
cubicSpline :: StartPt -> [(SegLength, EndPt)] -> T
compSine1 :: [PStrength] -> T
type PStrength = Float
compSine2 :: [(PNum, PStrength, PhaseOffset)] -> T
type PNum = Float
type PhaseOffset = Float
compSine3 :: [(PNum, PStrength, PhaseOffset, DCOffset)] -> T
type DCOffset = Float
cosineHarms :: NHarms -> LowestHarm -> Mult -> T
type NHarms = Int
type LowestHarm = Int
type Mult = Float
randomTable :: RandDist -> T
data RandDist
Uniform :: RandDist
Linear :: RandDist
Triangular :: RandDist
Expon :: RandDist
BiExpon :: RandDist
Gaussian :: RandDist
Cauchy :: RandDist
PosCauchy :: RandDist
toStatementWords :: T -> [String]
instance Show T
instance Eq RandDist
instance Ord RandDist
instance Enum RandDist
instance Show RandDist

module Haskore.Interface.CSound.Orchestra
data Output out => T out
Cons :: Header -> [InstrBlock out] -> T out
data InstrBlock a
InstrBlock :: Instrument -> Reverb -> a -> [(GlobalSig, SigExp)] -> InstrBlock a
instrBlockInstr :: InstrBlock a -> Instrument
instrBlockReverb :: InstrBlock a -> Reverb
instrBlockOutput :: InstrBlock a -> a
instrBlockGlobals :: InstrBlock a -> [(GlobalSig, SigExp)]
type Header = (AudRate, CtrlRate)
type AudRate = Int
type CtrlRate = Int
type SigExp = T SigTerm
type DelayLine = DelayLineTerm SigExp
type Boolean = BooleanTerm SigExp
data GlobalSig
Global :: EvalRate -> (SigExp -> SigExp -> SigExp) -> Int -> GlobalSig
class (Show c, Eq c) => Output c
getChannels :: Output c => c -> [SigExp]
getName :: Output c => c -> String
getChannelCount :: Output c => c -> Int
data Mono
Mono :: SigExp -> Mono
data Stereo
Stereo :: SigExp -> SigExp -> Stereo
data Quad
Quad :: SigExp -> SigExp -> SigExp -> SigExp -> Quad
data EvalRate
NR :: EvalRate
CR :: EvalRate
AR :: EvalRate
data Instrument
type Name = String
sigGen :: Function -> EvalRate -> OutCount -> [SigExp] -> SigExp
tableNumber :: Table -> SigExp
readGlobal :: GlobalSig -> SigExp
rec :: (SigExp -> SigExp) -> SigExp
toString :: Output a => T a -> String
saveIA :: Output a => T a -> IO ()
save :: Output a => FilePath -> T a -> IO ()
channelCount :: Output a => T a -> Int
getMultipleOutputs :: SigExp -> [SigExp]
noteDur :: SigExp
notePit :: SigExp
noteVel :: SigExp
p1 :: SigExp
p2 :: SigExp
p3 :: SigExp
p4 :: SigExp
p5 :: SigExp
p6 :: SigExp
p7 :: SigExp
p8 :: SigExp
p9 :: SigExp
pField :: Int -> SigExp
(<*) :: TreeTerm term => T term -> T term -> BooleanTerm (T term)
(<=*) :: TreeTerm term => T term -> T term -> BooleanTerm (T term)
(>*) :: TreeTerm term => T term -> T term -> BooleanTerm (T term)
(>=*) :: TreeTerm term => T term -> T term -> BooleanTerm (T term)
(==*) :: TreeTerm term => T term -> T term -> BooleanTerm (T term)
(/=*) :: TreeTerm term => T term -> T term -> BooleanTerm (T term)
(&&*) :: Boolean -> Boolean -> Boolean
(||*) :: Boolean -> Boolean -> Boolean
ifthen :: TreeTerm term => BooleanTerm (T term) -> T term -> T term -> T term
constInt :: Int -> SigExp
constFloat :: Float -> SigExp
constEnum :: Enum a => a -> SigExp
pchToHz :: SigExp -> SigExp
dbToAmp :: SigExp -> SigExp
line :: EvalRate -> SigExp -> SigExp -> SigExp -> SigExp
expon :: EvalRate -> SigExp -> SigExp -> SigExp -> SigExp
lineSeg :: EvalRate -> SigExp -> SigExp -> SigExp -> [(SigExp, SigExp)] -> SigExp
exponSeg :: EvalRate -> SigExp -> SigExp -> SigExp -> [(SigExp, SigExp)] -> SigExp
env :: EvalRate -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp
phasor :: EvalRate -> SigExp -> SigExp -> SigExp
data IndexMode
RawIndex :: IndexMode
NormalIndex :: IndexMode
tblLookup :: EvalRate -> IndexMode -> SigExp -> SigExp -> SigExp
tblLookupI :: EvalRate -> IndexMode -> SigExp -> SigExp -> SigExp
osc :: EvalRate -> SigExp -> SigExp -> SigExp -> SigExp
oscI :: EvalRate -> SigExp -> SigExp -> SigExp -> SigExp
fmOsc :: SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp
fmOscI :: SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp
sampOsc :: SigExp -> SigExp -> SigExp -> SigExp
random :: EvalRate -> SigExp -> SigExp
randomH :: EvalRate -> SigExp -> SigExp -> SigExp
randomI :: EvalRate -> SigExp -> SigExp -> SigExp
genBuzz :: SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp
buzz :: SigExp -> SigExp -> SigExp -> SigExp -> SigExp
pluck :: SigExp -> SigExp -> PluckDecayMethod -> SigExp -> SigExp -> SigExp
data PluckDecayMethod
PluckSimpleSmooth :: PluckDecayMethod
PluckStretchSmooth :: SigExp -> PluckDecayMethod
PluckSimpleDrum :: SigExp -> PluckDecayMethod
PluckStretchDrum :: SigExp -> SigExp -> PluckDecayMethod
PluckWeightedSmooth :: SigExp -> SigExp -> PluckDecayMethod
PluckFilterSmooth :: PluckDecayMethod
delay :: SigExp -> SigExp -> SigExp
vdelay :: SigExp -> SigExp -> SigExp -> SigExp
comb :: SigExp -> SigExp -> SigExp -> SigExp
alpass :: SigExp -> SigExp -> SigExp -> SigExp
reverb :: SigExp -> SigExp -> SigExp
delTap :: DelayLine -> SigExp -> SigExp
delTapI :: DelayLine -> SigExp -> SigExp
type Orc a b = State (OrcState a) b
mkSignal :: Output a => EvalRate -> (SigExp -> SigExp -> SigExp) -> Orc a GlobalSig
addInstr :: Output a => InstrBlock a -> Orc a ()
mkOrc :: Output a => Header -> Orc a () -> T a
orc1 :: T Stereo
test :: IO ()
test1 :: StatementDefs
instance Show tree => Show (BooleanTerm tree)
instance Eq tree => Eq (BooleanTerm tree)
instance Show tree => Show (DelayLineTerm tree)
instance Eq tree => Eq (DelayLineTerm tree)
instance Show EvalRate
instance Eq EvalRate
instance Ord EvalRate
instance Show tree => Show (SigTerm tree)
instance Eq tree => Eq (SigTerm tree)
instance Show a => Show (InstrBlock a)
instance Eq a => Eq (InstrBlock a)
instance Show IndexMode
instance Eq IndexMode
instance Enum IndexMode
instance Output out => Show (T out)
instance Output out => Eq (T out)
instance Show Mono
instance Eq Mono
instance Show Stereo
instance Eq Stereo
instance Show Quad
instance Eq Quad
instance Show StatementDef
instance Eq StatementDef
instance Show a => Show (OrcState a)
instance Eq a => Eq (OrcState a)
instance Output Quad
instance Output Stereo
instance Output Mono
instance Traversable SigTerm
instance Foldable SigTerm
instance Traversable DelayLineTerm
instance Foldable DelayLineTerm
instance Traversable BooleanTerm
instance Foldable BooleanTerm
instance (CollShow term, CollEq term, Functor term, TreeTerm term) => Floating (T term)
instance (CollShow term, CollEq term, Functor term, TreeTerm term) => Fractional (T term)
instance (CollShow term, CollEq term, Functor term, TreeTerm term) => Num (T term)
instance TreeTerm SigTerm
instance CollEq SigTerm
instance CollShow SigTerm
instance Functor SigTerm
instance Functor DelayLineTerm
instance Functor BooleanTerm
instance Eq GlobalSig
instance Show GlobalSig

module Haskore.Interface.CSound.SoundMap
type SoundId = Instrument
type InstrumentId = SoundId
type DrumId = SoundId
type Attribute = PField
type AttributeList = [Attribute]
type ToSound instr = instr -> (AttributeList, SoundId)
attributeControl :: Int -> SigExp
type InstrumentTable out instr = [(instr, InstrumentSigExp out)]
type InstrumentTableWithAttributes out instr = [InstrumentAssociation out instr]
type InstrumentSigExp out = SigExp -> SigExp -> SigExp -> out
data InstrumentAssociation out instr
InstrumentAssociation :: InstrumentId -> (instr -> Maybe AttributeList) -> out -> InstrumentAssociation out instr
lookupInstrument :: InstrumentTableWithAttributes out instr -> ToSound instr
instrumentTableToInstrBlocks :: InstrumentTableWithAttributes out instr -> [InstrBlock out]
addInstrumentControls :: InstrumentSigExp out -> out
instrumentAssociation :: (parameterTuple -> AttributeList) -> (graph -> InstrumentSigExp out) -> InstrumentId -> (instr -> Maybe parameterTuple) -> graph -> InstrumentAssociation out instr
instrument :: InstrumentId -> (instr -> Maybe ()) -> (InstrumentSigExp out) -> InstrumentAssociation out instr
instrumentEq :: Eq instrument => InstrumentId -> instrument -> (InstrumentSigExp out) -> InstrumentAssociation out instrument
instrument1 :: InstrumentId -> (instr -> Maybe Attribute) -> (SigExp -> InstrumentSigExp out) -> InstrumentAssociation out instr
instrument2 :: InstrumentId -> (instr -> Maybe (Attribute, Attribute)) -> (SigExp -> SigExp -> InstrumentSigExp out) -> InstrumentAssociation out instr
instrument3 :: InstrumentId -> (instr -> Maybe (Attribute, Attribute, Attribute)) -> (SigExp -> SigExp -> SigExp -> InstrumentSigExp out) -> InstrumentAssociation out instr
instrument4 :: InstrumentId -> (instr -> Maybe (Attribute, Attribute, Attribute, Attribute)) -> (SigExp -> SigExp -> SigExp -> SigExp -> InstrumentSigExp out) -> InstrumentAssociation out instr
type DrumTable out drum = [(drum, DrumSigExp out)]
type DrumTableWithAttributes out drum = [DrumAssociation out drum]
type DrumSigExp out = SigExp -> SigExp -> out
data DrumAssociation out drum
DrumAssociation :: DrumId -> (drum -> Maybe AttributeList) -> out -> DrumAssociation out drum
lookupDrum :: DrumTableWithAttributes out drum -> ToSound drum
drumTableToInstrBlocks :: DrumTableWithAttributes out instr -> [InstrBlock out]
addDrumControls :: DrumSigExp out -> out
drumAssociation :: (parameterTuple -> AttributeList) -> (graph -> DrumSigExp out) -> DrumId -> (drum -> Maybe parameterTuple) -> graph -> DrumAssociation out drum
drum :: DrumId -> (drum -> Maybe ()) -> (DrumSigExp out) -> DrumAssociation out drum
drumEq :: Eq drum => DrumId -> drum -> (DrumSigExp out) -> DrumAssociation out drum
drum1 :: DrumId -> (drum -> Maybe Attribute) -> (SigExp -> DrumSigExp out) -> DrumAssociation out drum
drum2 :: DrumId -> (drum -> Maybe (Attribute, Attribute)) -> (SigExp -> SigExp -> DrumSigExp out) -> DrumAssociation out drum
drum3 :: DrumId -> (drum -> Maybe (Attribute, Attribute, Attribute)) -> (SigExp -> SigExp -> SigExp -> DrumSigExp out) -> DrumAssociation out drum
drum4 :: DrumId -> (drum -> Maybe (Attribute, Attribute, Attribute, Attribute)) -> (SigExp -> SigExp -> SigExp -> SigExp -> DrumSigExp out) -> DrumAssociation out drum

module Medium.Temporal
type Dur = Rational
class C a
dur :: C a => a -> Dur
none :: C a => Dur -> a
class Control control
controlDur :: Control control => control -> Dur -> Dur
anticontrolDur :: Control control => control -> Dur -> Dur

module Medium
class Construct medium
prim :: Construct medium => a -> medium a
(+:+, =:=) :: Construct medium => medium a -> medium a -> medium a
serial, parallel :: (Construct medium, C a) => [medium a] -> medium a
serial1, parallel1 :: Construct medium => [medium a] -> medium a
class Construct medium => C medium
switchBinary :: C medium => (a -> b) -> (medium a -> medium a -> b) -> (medium a -> medium a -> b) -> (b -> medium a -> b)
switchList :: C medium => (a -> b) -> ([medium a] -> b) -> ([medium a] -> b) -> medium a -> b
mapList :: (C b, C medium) => (a -> b) -> ([medium b] -> [medium b]) -> ([medium b] -> [medium b]) -> medium a -> medium b
mapListFlat :: (C b, C medium) => (a -> b) -> ([medium a] -> [medium b]) -> ([medium a] -> [medium b]) -> medium a -> medium b
foldList :: C medium => (a -> b) -> ([b] -> b) -> ([b] -> b) -> medium a -> b
foldBin :: C medium => (a -> b) -> (b -> b -> b) -> (b -> b -> b) -> b -> medium a -> b
listMediumFromAny :: (Construct dst, C src, C a) => src a -> dst a
binaryMediumFromAny :: (Construct dst, C src) => dst a -> src a -> dst a

module Medium.Plain.Binary
data T a
Primitive :: a -> T a
(:+:) :: T a -> T a -> T a
(:=:) :: T a -> T a -> T a
errorNone :: a
serialS :: T a -> [T a] -> [T a]
parallelS :: T a -> [T a] -> [T a]
instance Show a => Show (T a)
instance Eq a => Eq (T a)
instance Ord a => Ord (T a)
instance C a => C (T a)
instance Traversable T
instance Foldable T
instance Functor T
instance C T
instance Construct T

module Medium.Plain.List
data T a
Primitive :: a -> T a
Serial :: [T a] -> T a
Parallel :: [T a] -> T a
serialToList :: T a -> [T a]
parallelToList :: T a -> [T a]
instance Show a => Show (T a)
instance Eq a => Eq (T a)
instance Ord a => Ord (T a)
instance C a => C (T a)
instance Traversable T
instance Foldable T
instance Functor T
instance C T
instance Construct T

module Medium.Controlled.List

-- | Medium type with a controller constructor.
data T control content

-- | primitive content
Primitive :: content -> T control content

-- | sequential composition
Serial :: [T control content] -> T control content

-- | parallel composition
Parallel :: [T control content] -> T control content

-- | controller
Control :: control -> (T control content) -> T control content
serialToList :: T control a -> [T control a]
parallelToList :: T control a -> [T control a]
prim :: a -> T control a
serial :: [T control a] -> T control a
parallel :: [T control a] -> T control a
fromMedium :: C src => src a -> T control a
toMediumList :: T control a -> T a
mapList :: (a -> b) -> ([T control b] -> [T control b]) -> ([T control b] -> [T control b]) -> (control -> T control b -> T control b) -> T control a -> T control b
mapListFlat :: (a -> b) -> ([T control a] -> [T control b]) -> ([T control a] -> [T control b]) -> (control -> T control a -> T control b) -> T control a -> T control b
mapControl :: (c0 -> c1) -> T c0 a -> T c1 a
instance (Show control, Show content) => Show (T control content)
instance (Eq control, Eq content) => Eq (T control content)
instance (Ord control, Ord content) => Ord (T control content)
instance (C a, Control control) => C (T control a)
instance Traversable (T control)
instance Foldable (T control)
instance Functor (T control)
instance C T
instance Construct (T control)

module Medium.Plain.ContextFreeGrammar
data Tag key prim
Prim :: prim -> Tag key prim
Call :: key -> Tag key prim
CallMulti :: Int -> key -> Tag key prim
type TagMedium key prim = T (Tag key prim)
type T key prim = [(key, TagMedium key prim)]
fromMedium :: (Ord key, Ord prim) => [key] -> Int -> T prim -> T key prim
toMedium :: (Show key, Ord key, Ord prim) => T key prim -> T prim
expand :: (Show key, Ord key, Ord prim) => T key prim -> [(key, T prim)]
whileM :: Monad m => (a -> Bool) -> [StateT s m a] -> StateT s m [a]
condense :: (Ord key, Ord prim) => key -> T key prim -> (Int, T key prim)
joinTag :: Construct medium => Tag key (medium (Tag key prim)) -> medium (Tag key prim)
replaceInfix :: (Eq a, Eq b) => a -> [b] -> [b] -> [Tag a b]
isCyclic :: Eq a => [a] -> Bool
smallestCycle :: Eq a => [a] -> [a]
maximumCommonInfix :: (Ord a, Ord b) => ([a] -> b) -> [a] -> [a]
maximumCommonInfixMulti :: (Ord a, Ord b) => ([a] -> b) -> [[a]] -> [a]
commonPrefix :: Eq a => [a] -> [a] -> [a]
commonPrefixRec :: Eq a => [a] -> [a] -> [a]
instance (Eq key, Eq prim) => Eq (Tag key prim)
instance (Ord key, Ord prim) => Ord (Tag key prim)
instance (Show key, Show prim) => Show (Tag key prim)

module Medium.Controlled.ContextFreeGrammar
type T key control prim = [(key, TagMedium key control prim)]
data Tag key prim
Prim :: prim -> Tag key prim
Call :: key -> Tag key prim
CallMulti :: Int -> key -> Tag key prim
type TagMedium key control prim = T control (Tag key prim)
fromMedium :: (Ord key, Ord control, Ord prim) => [key] -> Int -> T control prim -> T key control prim
toMedium :: (Show key, Ord key, Ord prim) => T key control prim -> T control prim

module Medium.LabeledControlled.List

-- | Medium type with a label (e.g. the duration of the represented music),
--   a controller constructor and direct support for rests.
data T label control content
Cons :: label -> Structure label control content -> T label control content
label :: T label control content -> label
structure :: T label control content -> Structure label control content
data Structure label control content

-- | primitive content
Primitive :: content -> Structure label control content

-- | sequential composition
Serial :: [T label control content] -> Structure label control content

-- | parallel composition
Parallel :: [T label control content] -> Structure label control content

-- | controller
Control :: control -> (T label control content) -> Structure label control content
class Label label
emptyLabel :: Label label => label
foldLabelSerial :: Label label => [label] -> label
foldLabelParallel :: Label label => [label] -> label
serialLabel :: Label label => [T label control content] -> T label control content
parallelLabel :: Label label => [T label control content] -> T label control content
switchList :: (label -> b -> c) -> (a -> b) -> ([T label control a] -> b) -> ([T label control a] -> b) -> (control -> T label control a -> b) -> (T label control a -> c)
foldList :: (label -> b -> c) -> (a -> b) -> ([c] -> b) -> ([c] -> b) -> (control -> c -> b) -> (T label control a -> c)
fromControlledMediumList :: Label label => (a -> (label, b)) -> (control -> T label control b -> label) -> T control a -> T label control b
mapLabel :: (i -> j) -> (T i control a -> T j control a)
serialToList :: T label control a -> [T label control a]
parallelToList :: T label control a -> [T label control a]
instance (Show label, Show control, Show content) => Show (Structure label control content)
instance (Eq label, Eq control, Eq content) => Eq (Structure label control content)
instance (Ord label, Ord control, Ord content) => Ord (Structure label control content)
instance (Show label, Show control, Show content) => Show (T label control content)
instance (Eq label, Eq control, Eq content) => Eq (T label control content)
instance (Ord label, Ord control, Ord content) => Ord (T label control content)
instance Traversable (T i control)
instance Foldable (T i control)
instance Functor (T i control)
instance Label label => Construct (T label control)

module Haskore.Basic.Duration
type T = Dur
type Ratio = T
type Offset = Rational
(%+) :: Integer -> Integer -> T
fromRatio :: Rational -> T
toRatio :: T -> Rational
toNumber :: Fractional a => T -> a
scale :: Ratio -> T -> T
add :: Offset -> T -> T
divide :: T -> T -> Integer
divisible :: T -> T -> Bool
gcd :: T -> T -> T
dotted :: T -> T
doubleDotted :: T -> T
bn :: T
sfn :: T
tn :: T
sn :: T
en :: T
qn :: T
hn :: T
wn :: T
dwn :: T
dtn :: T
dsn :: T
den :: T
dqn :: T
dhn :: T
ddhn :: T
dden :: T
ddqn :: T
nameDictionary :: Map T String

-- | Converts <tt>1%4</tt> to <tt>"qn"</tt> and so on.
toString :: T -> String
propToString :: Bool

module Haskore.Music
type Dur = T
type Atom note = Maybe note
data Primitive note
Atom :: Dur -> (Atom note) -> Primitive note
data Control
Tempo :: DurRatio -> Control
Transpose :: Relative -> Control
Player :: PlayerName -> Control
Phrase :: PhraseAttribute -> Control
type DurRatio = Dur
type PlayerName = String
atom :: Dur -> Atom note -> T note
control :: Control -> T note -> T note
mkControl :: (a -> Control) -> (a -> T note -> T note)
changeTempo :: DurRatio -> T note -> T note
transpose :: Relative -> T note -> T note
setPlayer :: PlayerName -> T note -> T note
phrase :: PhraseAttribute -> T note -> T note
type T note = T Control (Primitive note)
(+:+) :: T note -> T note -> T note
(=:=) :: T note -> T note -> T note
rest :: Dur -> T note
bnr :: T note
sfnr :: T note
tnr :: T note
snr :: T note
enr :: T note
qnr :: T note
hnr :: T note
wnr :: T note
dwnr :: T note
dtnr :: T note
dsnr :: T note
denr :: T note
dqnr :: T note
dhnr :: T note
ddhnr :: T note
ddenr :: T note
ddqnr :: T note
line :: [T note] -> T note
chord :: [T note] -> T note
delay :: Dur -> T note -> T note
repeat :: T note -> T note
replicate :: Int -> T note -> T note
dur :: T note -> Dur
reverse :: T note -> T note
take :: Dur -> T note -> T note
takeLine :: Dur -> [T note] -> [T note]
take' :: Dur -> T note -> (Dur, T note)
takeLine' :: Dur -> [T note] -> (Dur, [T note])
(/=:) :: T note -> T note -> T note
drop :: Dur -> T note -> T note
dropLine :: Dur -> [T note] -> [T note]
drop' :: Dur -> T note -> (Dur, T note)
dropLine' :: Dur -> [T note] -> (Dur, [T note])
filter :: (note -> Bool) -> T note -> T note
partition :: (note -> Bool) -> T note -> (T note, T note)
partitionMaybe :: (noteA -> Maybe noteB) -> T noteA -> (T noteB, T noteA)
applyPrimitive :: (Dur -> Atom note -> b) -> Primitive note -> b
switchBinary :: (Dur -> Atom note -> b) -> (Control -> T note -> b) -> (T note -> T note -> b) -> (T note -> T note -> b) -> b -> T note -> b
switchList :: (Dur -> Atom note -> b) -> (Control -> T note -> b) -> ([T note] -> b) -> ([T note] -> b) -> T note -> b
foldBin :: (Dur -> Atom note -> b) -> (Control -> b -> b) -> (b -> b -> b) -> (b -> b -> b) -> b -> T note -> b
foldList :: (Dur -> Atom note -> b) -> (Control -> b -> b) -> ([b] -> b) -> ([b] -> b) -> T note -> b
mapListFlat :: (Dur -> Atom noteA -> (Dur, Atom noteB)) -> (Control -> T noteA -> T noteB) -> ([T noteA] -> [T noteB]) -> ([T noteA] -> [T noteB]) -> T noteA -> T noteB
mapList :: (Dur -> Atom noteA -> (Dur, Atom noteB)) -> (Control -> T noteB -> T noteB) -> ([T noteB] -> [T noteB]) -> ([T noteB] -> [T noteB]) -> T noteA -> T noteB
mapNote :: (noteA -> noteB) -> T noteA -> T noteB
mapDurNote :: (Dur -> noteA -> noteB) -> T noteA -> T noteB
data PhraseAttribute
Dyn :: Dynamic -> PhraseAttribute
Tmp :: Tempo -> PhraseAttribute
Art :: Articulation -> PhraseAttribute
Orn :: Ornament -> PhraseAttribute
data Dynamic
Loudness :: Rational -> Dynamic
Accent :: Rational -> Dynamic
Crescendo :: Rational -> Dynamic
Diminuendo :: Rational -> Dynamic
data Tempo
Ritardando :: Rational -> Tempo
Accelerando :: Rational -> Tempo
data Articulation
Staccato :: Dur -> Articulation
Legato :: Dur -> Articulation
Slurred :: Dur -> Articulation
Tenuto :: Articulation
Marcato :: Articulation
Pedal :: Articulation
Fermata :: Articulation
FermataDown :: Articulation
Breath :: Articulation
DownBow :: Articulation
UpBow :: Articulation
Harmonic :: Articulation
Pizzicato :: Articulation
LeftPizz :: Articulation
BartokPizz :: Articulation
Swell :: Articulation
Wedge :: Articulation
Thumb :: Articulation
Stopped :: Articulation
data Ornament
Trill :: Ornament
Mordent :: Ornament
InvMordent :: Ornament
DoubleMordent :: Ornament
Turn :: Ornament
TrilledTurn :: Ornament
ShortTrill :: Ornament
Arpeggio :: Ornament
ArpeggioUp :: Ornament
ArpeggioDown :: Ornament
Instruction :: String -> Ornament
Head :: NoteHead -> Ornament
data NoteHead
DiamondHead :: NoteHead
SquareHead :: NoteHead
XHead :: NoteHead
TriangleHead :: NoteHead
TremoloHead :: NoteHead
SlashHead :: NoteHead
ArtHarmonic :: NoteHead
NoHead :: NoteHead
dynamic :: Dynamic -> T note -> T note
tempo :: Tempo -> T note -> T note
articulation :: Articulation -> T note -> T note
ornament :: Ornament -> T note -> T note
accent :: Rational -> T note -> T note
accelerando :: Rational -> T note -> T note
ritardando :: Rational -> T note -> T note
loudness1 :: Rational -> T note -> T note
diminuendo :: Rational -> T note -> T note
crescendo :: Rational -> T note -> T note
staccato :: Dur -> T note -> T note
legato :: Dur -> T note -> T note
defltLegato :: T note -> T note
bigAccent :: T note -> T note
defltAccent :: T note -> T note
defltStaccato :: T note -> T note
instance Show note => Show (Primitive note)
instance Eq note => Eq (Primitive note)
instance Ord note => Ord (Primitive note)
instance Eq Dynamic
instance Ord Dynamic
instance Show Dynamic
instance Eq Tempo
instance Ord Tempo
instance Show Tempo
instance Eq Articulation
instance Ord Articulation
instance Show Articulation
instance Eq NoteHead
instance Ord NoteHead
instance Show NoteHead
instance Eq Ornament
instance Ord Ornament
instance Show Ornament
instance Eq PhraseAttribute
instance Ord PhraseAttribute
instance Show PhraseAttribute
instance Show Control
instance Eq Control
instance Ord Control
instance Control Control
instance C (Primitive note)

module Haskore.Composition.Trill
trill :: Int -> Dur -> T note -> T note
trill' :: Int -> Dur -> T note -> T note
trillN :: Int -> Integer -> T note -> T note
trillN' :: Int -> Integer -> T note -> T note
roll :: Dur -> T note -> T note
rollN :: Integer -> T note -> T note

module Haskore.Process.Optimization
all :: T note -> T note
volume :: T note -> T note
transpose :: T note -> T note
tempo :: T note -> T note
duration :: T note -> T note
composition :: T note -> T note
rest :: T note -> T note
isZeroRest :: T note -> Bool
mergeControl' :: (Control -> Maybe a) -> (a -> T note -> T note) -> (a -> a -> a) -> T note -> T note
mergeControl :: (Control -> Maybe a) -> (a -> T note -> T note) -> (a -> a -> a) -> T note -> T note
mergeControlCompact :: (Control -> Maybe a) -> (a -> T note -> T note) -> (a -> a -> a) -> T note -> T note
cumulateControllers :: T control a -> T [control] a
flattenControllers :: T [control] a -> T control a
removeNeutral :: (Control -> Bool) -> T note -> T note
singletonMedium :: T control a -> T control a
singleton :: T note -> T note

module Haskore.Melody
data Note attr
Note :: attr -> T -> Note attr
noteAttrs_ :: Note attr -> attr
notePitch_ :: Note attr -> T
type T attr = T (Note attr)
noteAttrs :: T (Note attr) attr
notePitch :: T (Note attr) T
toMelodyNullAttr :: T attr -> T ()
note :: T -> T -> attr -> T attr
note' :: Class -> Octave -> T -> attr -> T attr
cf :: Octave -> T -> attr -> T attr
bs :: Octave -> T -> attr -> T attr
b :: Octave -> T -> attr -> T attr
bf :: Octave -> T -> attr -> T attr
as :: Octave -> T -> attr -> T attr
a :: Octave -> T -> attr -> T attr
af :: Octave -> T -> attr -> T attr
gs :: Octave -> T -> attr -> T attr
g :: Octave -> T -> attr -> T attr
gf :: Octave -> T -> attr -> T attr
fs :: Octave -> T -> attr -> T attr
f :: Octave -> T -> attr -> T attr
ff :: Octave -> T -> attr -> T attr
es :: Octave -> T -> attr -> T attr
e :: Octave -> T -> attr -> T attr
ef :: Octave -> T -> attr -> T attr
ds :: Octave -> T -> attr -> T attr
d :: Octave -> T -> attr -> T attr
df :: Octave -> T -> attr -> T attr
cs :: Octave -> T -> attr -> T attr
c :: Octave -> T -> attr -> T attr
cMaj :: [T ()]
cMajArp :: T ()
cMajChd :: T ()
noteToPitch :: T attr -> T
invertNote :: T -> Note attr -> Note attr
retro :: [(d, Atom (Note attr))] -> [(d, Atom (Note attr))]
invertRetro :: [(d, Atom (Note attr))] -> [(d, Atom (Note attr))]
retroInvert :: [(d, Atom (Note attr))] -> [(d, Atom (Note attr))]
invert :: [(d, Atom (Note attr))] -> [(d, Atom (Note attr))]
instance Show attr => Show (Note attr)
instance Eq attr => Eq (Note attr)
instance Ord attr => Ord (Note attr)

module Haskore.Basic.Tempo
metro :: Fractional a => a -> Dur -> a
largoRange :: Fractional a => (a, a)
prestissimoRange :: Fractional a => (a, a)
prestoRange :: Fractional a => (a, a)
allegroRange :: Fractional a => (a, a)
moderatoRange :: Fractional a => (a, a)
andanteRange :: Fractional a => (a, a)
adagioRange :: Fractional a => (a, a)
larghettoRange :: Fractional a => (a, a)
largo :: Fractional a => a
prestissimo :: Fractional a => a
presto :: Fractional a => a
allegro :: Fractional a => a
moderato :: Fractional a => a
andante :: Fractional a => a
adagio :: Fractional a => a
larghetto :: Fractional a => a
average :: Fractional a => a -> a -> a
pr1 :: T -> T ()
pr2 :: T -> T ()
mkLn :: Int -> T -> Dur -> T ()
pr12 :: T ()
(=/=) :: Dur -> Dur -> T note -> T note

module Haskore.Composition.Chord
type T = [Relative]
pitchToInterval :: T -> T
intervalToPitch :: T -> T
pitchInvert :: T -> T
intervalInvert :: T -> T
samePitch :: T -> T -> Bool
sameInterval :: T -> T -> Bool
majorInt :: [Relative]
sustainedFourthInt :: [Relative]
minorMajorSeventhInt :: [Relative]
dominantSeventhInt :: [Relative]
minorSeventhInt :: [Relative]
majorSeventhInt :: [Relative]
minorInt :: [Relative]
type Inversion = Int
fromIntervals :: [Relative] -> Inversion -> T note -> [T note]
major :: Inversion -> T note -> [T note]
sustainedFourth :: Inversion -> T note -> [T note]
minorMajorSeventh :: Inversion -> T note -> [T note]
dominantSeventh :: Inversion -> T note -> [T note]
minorSeventh :: Inversion -> T note -> [T note]
majorSeventh :: Inversion -> T note -> [T note]
minor :: Inversion -> T note -> [T note]
data Generic attr
Generic :: Class -> T -> Dur -> attr -> Generic attr
genericPitchClass :: Generic attr -> Class
genericIntervals :: Generic attr -> T
genericDur :: Generic attr -> Dur
genericAttr :: Generic attr -> attr
type Boundary = (T, T)
generic :: Class -> T -> Dur -> attr -> Generic attr
leastVaryingInversions :: Boundary -> [Generic attr] -> [[T attr]]
inversionIncrement :: T -> Double
matchingInversion :: Generic attr -> Double -> Double
mean :: [Relative] -> Double
chordCenter :: Generic attr -> Double
boundaryCenter :: (Octave, Inversion) -> Generic attr -> Double
invert :: Inversion -> T -> T
genericToNotes :: Inversion -> Generic attr -> [T attr]
shortestWays :: (Num b, Ord b) => (a -> a -> b) -> [[a]] -> [(b, [a])]
processZone :: (Num b, Ord b) => (a -> a -> b) -> [a] -> [(b, [a])] -> [(b, [a])]
propShortestWays :: Int -> Int -> Bool
leastVaryingInversionsSW :: Boundary -> [Generic attr] -> [[T attr]]
inversionCenters :: Boundary -> [Generic attr] -> [[(Inversion, Double)]]
melodicGen :: attr -> Dur -> [Dur -> attr -> T attr] -> T attr
harmonicGen :: attr -> Dur -> [Dur -> attr -> T attr] -> T attr

module Haskore.Composition.ChordType
data T
toChord :: T -> T
parse :: ReadP T
fromString :: String -> T
toString :: T -> String
instance Show Third
instance Eq Third
instance Ord Third
instance Ix Third
instance Show Fourth
instance Eq Fourth
instance Ord Fourth
instance Ix Fourth
instance Show Fifth
instance Eq Fifth
instance Ord Fifth
instance Ix Fifth
instance Show T
instance Eq T

module Haskore.Interface.AutoTrack.ChordSymbol
data T
Cons :: Class -> Class -> T -> T
toChord :: T -> [T]
toString :: T -> String
parse :: ReadP T
instance Eq T
instance C T
instance Read T
instance Show T

module Haskore.Melody.Standard
type Note = Note NoteAttributes
type T = T NoteAttributes
data NoteAttributes
fromMelodyNullAttr :: T () -> T
na :: NoteAttributes
velocity1 :: T NoteAttributes Rational
vibrato :: T NoteAttributes (Rational, Rational)
tremolo :: T NoteAttributes (Rational, Rational)
cf :: Octave -> T -> attr -> T attr
c :: Octave -> T -> attr -> T attr
cs :: Octave -> T -> attr -> T attr
df :: Octave -> T -> attr -> T attr
d :: Octave -> T -> attr -> T attr
ds :: Octave -> T -> attr -> T attr
ef :: Octave -> T -> attr -> T attr
e :: Octave -> T -> attr -> T attr
es :: Octave -> T -> attr -> T attr
ff :: Octave -> T -> attr -> T attr
f :: Octave -> T -> attr -> T attr
fs :: Octave -> T -> attr -> T attr
gf :: Octave -> T -> attr -> T attr
g :: Octave -> T -> attr -> T attr
gs :: Octave -> T -> attr -> T attr
af :: Octave -> T -> attr -> T attr
a :: Octave -> T -> attr -> T attr
as :: Octave -> T -> attr -> T attr
bf :: Octave -> T -> attr -> T attr
b :: Octave -> T -> attr -> T attr
bs :: Octave -> T -> attr -> T attr
instance Eq NoteAttributes
instance Ord NoteAttributes
instance Show NoteAttributes

module Haskore.Music.Rhythmic
type T drum instr = T (Note drum instr)
data Note drum instr
Note :: Rational -> NoteBody drum instr -> Note drum instr
velocity :: Note drum instr -> Rational
body :: Note drum instr -> NoteBody drum instr
data NoteBody drum instr
Tone :: instr -> T -> NoteBody drum instr
instrument :: NoteBody drum instr -> instr
pitch :: NoteBody drum instr -> T
Drum :: drum -> NoteBody drum instr
drum :: NoteBody drum instr -> drum
maybeInstrument :: NoteBody drum instr -> Maybe instr
noteFromAttrs :: NoteAttributes -> NoteBody drum instr -> Note drum instr
noteFromStdMelodyNote :: instr -> Note -> Note drum instr
noteFromMelodyNote :: (attr -> (Rational, instr)) -> Note attr -> Note drum instr
fromStdMelody :: instr -> T -> T drum instr

-- | ignores the note attributes
fromMelodyNullAttr :: instr -> T () -> T drum instr
fromMelody :: (attr -> (Rational, instr)) -> T attr -> T drum instr
bn :: T
wn :: T
hn :: T
qn :: T
en :: T
sn :: T
tn :: T
sfn :: T
dwn :: T
dhn :: T
dqn :: T
den :: T
dsn :: T
dtn :: T
ddhn :: T
ddqn :: T
dden :: T
bnr :: T note
wnr :: T note
hnr :: T note
qnr :: T note
enr :: T note
snr :: T note
tnr :: T note
sfnr :: T note
dwnr :: T note
dhnr :: T note
dqnr :: T note
denr :: T note
dsnr :: T note
dtnr :: T note
ddhnr :: T note
ddqnr :: T note
ddenr :: T note
line :: [T note] -> T note
chord :: [T note] -> T note
changeTempo :: DurRatio -> T note -> T note
transpose :: Relative -> T note -> T note
phrase :: PhraseAttribute -> T note -> T note
(+:+) :: T note -> T note -> T note
(=:=) :: T note -> T note -> T note
type Dur = T
data PhraseAttribute
Dyn :: Dynamic -> PhraseAttribute
Tmp :: Tempo -> PhraseAttribute
Art :: Articulation -> PhraseAttribute
Orn :: Ornament -> PhraseAttribute
data Dynamic
Loudness :: Rational -> Dynamic
Accent :: Rational -> Dynamic
Crescendo :: Rational -> Dynamic
Diminuendo :: Rational -> Dynamic
data Tempo
Ritardando :: Rational -> Tempo
Accelerando :: Rational -> Tempo
data Articulation
Staccato :: Dur -> Articulation
Legato :: Dur -> Articulation
Slurred :: Dur -> Articulation
Tenuto :: Articulation
Marcato :: Articulation
Pedal :: Articulation
Fermata :: Articulation
FermataDown :: Articulation
Breath :: Articulation
DownBow :: Articulation
UpBow :: Articulation
Harmonic :: Articulation
Pizzicato :: Articulation
LeftPizz :: Articulation
BartokPizz :: Articulation
Swell :: Articulation
Wedge :: Articulation
Thumb :: Articulation
Stopped :: Articulation
data Ornament
Trill :: Ornament
Mordent :: Ornament
InvMordent :: Ornament
DoubleMordent :: Ornament
Turn :: Ornament
TrilledTurn :: Ornament
ShortTrill :: Ornament
Arpeggio :: Ornament
ArpeggioUp :: Ornament
ArpeggioDown :: Ornament
Instruction :: String -> Ornament
Head :: NoteHead -> Ornament
data NoteHead
DiamondHead :: NoteHead
SquareHead :: NoteHead
XHead :: NoteHead
TriangleHead :: NoteHead
TremoloHead :: NoteHead
SlashHead :: NoteHead
ArtHarmonic :: NoteHead
NoHead :: NoteHead
accent :: Rational -> T note -> T note
crescendo :: Rational -> T note -> T note
diminuendo :: Rational -> T note -> T note
loudness1 :: Rational -> T note -> T note
ritardando :: Rational -> T note -> T note
accelerando :: Rational -> T note -> T note
staccato :: Dur -> T note -> T note
legato :: Dur -> T note -> T note
defltLegato :: T note -> T note
defltStaccato :: T note -> T note
defltAccent :: T note -> T note
bigAccent :: T note -> T note
instance (Show drum, Show instr) => Show (NoteBody drum instr)
instance (Eq drum, Eq instr) => Eq (NoteBody drum instr)
instance (Ord drum, Ord instr) => Ord (NoteBody drum instr)
instance (Show drum, Show instr) => Show (Note drum instr)
instance (Eq drum, Eq instr) => Eq (Note drum instr)
instance (Ord instr, Ord drum) => Ord (Note drum instr)

module Haskore.Music.GeneralMIDI
type T = T Drum Instr
type Note = Note Drum Instr
type NoteBody = NoteBody Drum Instr
type Instr = Instrument
velocity :: Note drum instr -> Rational
body :: Note drum instr -> NoteBody drum instr
instrument :: NoteBody drum instr -> instr
pitch :: NoteBody drum instr -> T
drum :: NoteBody drum instr -> drum
noteFromStdMelodyNote :: instr -> Note -> Note drum instr

-- | in contrast to RhyMusic.fromStdMelody it has fixed instrument type
fromStdMelody :: Instr -> T -> T
fromMelodyNullAttr :: Instr -> T () -> T
data Instrument :: *
AcousticGrandPiano :: Instrument
BrightAcousticPiano :: Instrument
ElectricGrandPiano :: Instrument
HonkyTonk :: Instrument
ElectricPiano1 :: Instrument
ElectricPiano2 :: Instrument
Harpsichord :: Instrument
Clavinet :: Instrument
Celesta :: Instrument
Glockenspiel :: Instrument
MusicBox :: Instrument
Vibraphone :: Instrument
Marimba :: Instrument
Xylophone :: Instrument
TubularBells :: Instrument
Dulcimer :: Instrument
DrawbarOrgan :: Instrument
PercussiveOrgan :: Instrument
RockOrgan :: Instrument
ChurchOrgan :: Instrument
ReedOrgan :: Instrument
Accordion :: Instrument
Harmonica :: Instrument
TangoAccordian :: Instrument
AcousticGuitarNylon :: Instrument
AcousticGuitarSteel :: Instrument
ElectricGuitarJazz :: Instrument
ElectricGuitarClean :: Instrument
ElectricGuitarMuted :: Instrument
OverdrivenGuitar :: Instrument
DistortionGuitar :: Instrument
GuitarHarmonics :: Instrument
AcousticBass :: Instrument
ElectricBassFinger :: Instrument
ElectricBassPick :: Instrument
FretlessBass :: Instrument
SlapBass1 :: Instrument
SlapBass2 :: Instrument
SynthBass1 :: Instrument
SynthBass2 :: Instrument
Violin :: Instrument
Viola :: Instrument
Cello :: Instrument
Contrabass :: Instrument
TremoloStrings :: Instrument
PizzicatoStrings :: Instrument
OrchestralHarp :: Instrument
Timpani :: Instrument
StringEnsemble1 :: Instrument
StringEnsemble2 :: Instrument
SynthStrings1 :: Instrument
SynthStrings2 :: Instrument
ChoirAahs :: Instrument
VoiceOohs :: Instrument
SynthVoice :: Instrument
OrchestraHit :: Instrument
Trumpet :: Instrument
Trombone :: Instrument
Tuba :: Instrument
MutedTrumpet :: Instrument
FrenchHorn :: Instrument
BrassSection :: Instrument
SynthBrass1 :: Instrument
SynthBrass2 :: Instrument
SopranoSax :: Instrument
AltoSax :: Instrument
TenorSax :: Instrument
BaritoneSax :: Instrument
Oboe :: Instrument
EnglishHorn :: Instrument
Bassoon :: Instrument
Clarinet :: Instrument
Piccolo :: Instrument
Flute :: Instrument
Recorder :: Instrument
PanFlute :: Instrument
BlownBottle :: Instrument
Skakuhachi :: Instrument
Whistle :: Instrument
Ocarina :: Instrument
Lead1Square :: Instrument
Lead2Sawtooth :: Instrument
Lead3Calliope :: Instrument
Lead4Chiff :: Instrument
Lead5Charang :: Instrument
Lead6Voice :: Instrument
Lead7Fifths :: Instrument
Lead8BassLead :: Instrument
Pad1NewAge :: Instrument
Pad2Warm :: Instrument
Pad3Polysynth :: Instrument
Pad4Choir :: Instrument
Pad5Bowed :: Instrument
Pad6Metallic :: Instrument
Pad7Halo :: Instrument
Pad8Sweep :: Instrument
FX1Rain :: Instrument
FX2Soundtrack :: Instrument
FX3Crystal :: Instrument
FX4Atmosphere :: Instrument
FX5Brightness :: Instrument
FX6Goblins :: Instrument
FX7Echoes :: Instrument
FX8SciFi :: Instrument
Sitar :: Instrument
Banjo :: Instrument
Shamisen :: Instrument
Koto :: Instrument
Kalimba :: Instrument
Bagpipe :: Instrument
Fiddle :: Instrument
Shanai :: Instrument
TinkleBell :: Instrument
Agogo :: Instrument
SteelDrums :: Instrument
Woodblock :: Instrument
TaikoDrum :: Instrument
MelodicTom :: Instrument
SynthDrum :: Instrument
ReverseCymbal :: Instrument
GuitarFretNoise :: Instrument
BreathNoise :: Instrument
Seashore :: Instrument
BirdTweet :: Instrument
TelephoneRing :: Instrument
Helicopter :: Instrument
Applause :: Instrument
Gunshot :: Instrument
data Drum :: *
AcousticBassDrum :: Drum
BassDrum1 :: Drum
SideStick :: Drum
AcousticSnare :: Drum
HandClap :: Drum
ElectricSnare :: Drum
LowFloorTom :: Drum
ClosedHiHat :: Drum
HighFloorTom :: Drum
PedalHiHat :: Drum
LowTom :: Drum
OpenHiHat :: Drum
LowMidTom :: Drum
HiMidTom :: Drum
CrashCymbal1 :: Drum
HighTom :: Drum
RideCymbal1 :: Drum
ChineseCymbal :: Drum
RideBell :: Drum
Tambourine :: Drum
SplashCymbal :: Drum
Cowbell :: Drum
CrashCymbal2 :: Drum
Vibraslap :: Drum
RideCymbal2 :: Drum
HiBongo :: Drum
LowBongo :: Drum
MuteHiConga :: Drum
OpenHiConga :: Drum
LowConga :: Drum
HighTimbale :: Drum
LowTimbale :: Drum
HighAgogo :: Drum
LowAgogo :: Drum
Cabasa :: Drum
Maracas :: Drum
ShortWhistle :: Drum
LongWhistle :: Drum
ShortGuiro :: Drum
LongGuiro :: Drum
Claves :: Drum
HiWoodBlock :: Drum
LowWoodBlock :: Drum
MuteCuica :: Drum
OpenCuica :: Drum
MuteTriangle :: Drum
OpenTriangle :: Drum
toProgram :: Int -> Program
toChannel :: Int -> Channel
bn :: T
wn :: T
hn :: T
qn :: T
en :: T
sn :: T
tn :: T
sfn :: T
dwn :: T
dhn :: T
dqn :: T
den :: T
dsn :: T
dtn :: T
ddhn :: T
ddqn :: T
dden :: T
bnr :: T note
wnr :: T note
hnr :: T note
qnr :: T note
enr :: T note
snr :: T note
tnr :: T note
sfnr :: T note
dwnr :: T note
dhnr :: T note
dqnr :: T note
denr :: T note
dsnr :: T note
dtnr :: T note
ddhnr :: T note
ddqnr :: T note
ddenr :: T note
line :: [T note] -> T note
chord :: [T note] -> T note
changeTempo :: DurRatio -> T note -> T note
transpose :: Relative -> T note -> T note
phrase :: PhraseAttribute -> T note -> T note
(+:+) :: T note -> T note -> T note
(=:=) :: T note -> T note -> T note
type Dur = T
data PhraseAttribute
Dyn :: Dynamic -> PhraseAttribute
Tmp :: Tempo -> PhraseAttribute
Art :: Articulation -> PhraseAttribute
Orn :: Ornament -> PhraseAttribute
data Dynamic
Loudness :: Rational -> Dynamic
Accent :: Rational -> Dynamic
Crescendo :: Rational -> Dynamic
Diminuendo :: Rational -> Dynamic
data Tempo
Ritardando :: Rational -> Tempo
Accelerando :: Rational -> Tempo
data Articulation
Staccato :: Dur -> Articulation
Legato :: Dur -> Articulation
Slurred :: Dur -> Articulation
Tenuto :: Articulation
Marcato :: Articulation
Pedal :: Articulation
Fermata :: Articulation
FermataDown :: Articulation
Breath :: Articulation
DownBow :: Articulation
UpBow :: Articulation
Harmonic :: Articulation
Pizzicato :: Articulation
LeftPizz :: Articulation
BartokPizz :: Articulation
Swell :: Articulation
Wedge :: Articulation
Thumb :: Articulation
Stopped :: Articulation
data Ornament
Trill :: Ornament
Mordent :: Ornament
InvMordent :: Ornament
DoubleMordent :: Ornament
Turn :: Ornament
TrilledTurn :: Ornament
ShortTrill :: Ornament
Arpeggio :: Ornament
ArpeggioUp :: Ornament
ArpeggioDown :: Ornament
Instruction :: String -> Ornament
Head :: NoteHead -> Ornament
data NoteHead
DiamondHead :: NoteHead
SquareHead :: NoteHead
XHead :: NoteHead
TriangleHead :: NoteHead
TremoloHead :: NoteHead
SlashHead :: NoteHead
ArtHarmonic :: NoteHead
NoHead :: NoteHead
accent :: Rational -> T note -> T note
crescendo :: Rational -> T note -> T note
diminuendo :: Rational -> T note -> T note
loudness1 :: Rational -> T note -> T note
ritardando :: Rational -> T note -> T note
accelerando :: Rational -> T note -> T note
staccato :: Dur -> T note -> T note
legato :: Dur -> T note -> T note
defltLegato :: T note -> T note
defltStaccato :: T note -> T note
defltAccent :: T note -> T note
bigAccent :: T note -> T note

module Haskore.Composition.Drum
type T = Drum
data Drum :: *
AcousticBassDrum :: Drum
BassDrum1 :: Drum
SideStick :: Drum
AcousticSnare :: Drum
HandClap :: Drum
ElectricSnare :: Drum
LowFloorTom :: Drum
ClosedHiHat :: Drum
HighFloorTom :: Drum
PedalHiHat :: Drum
LowTom :: Drum
OpenHiHat :: Drum
LowMidTom :: Drum
HiMidTom :: Drum
CrashCymbal1 :: Drum
HighTom :: Drum
RideCymbal1 :: Drum
ChineseCymbal :: Drum
RideBell :: Drum
Tambourine :: Drum
SplashCymbal :: Drum
Cowbell :: Drum
CrashCymbal2 :: Drum
Vibraslap :: Drum
RideCymbal2 :: Drum
HiBongo :: Drum
LowBongo :: Drum
MuteHiConga :: Drum
OpenHiConga :: Drum
LowConga :: Drum
HighTimbale :: Drum
LowTimbale :: Drum
HighAgogo :: Drum
LowAgogo :: Drum
Cabasa :: Drum
Maracas :: Drum
ShortWhistle :: Drum
LongWhistle :: Drum
ShortGuiro :: Drum
LongGuiro :: Drum
Claves :: Drum
HiWoodBlock :: Drum
LowWoodBlock :: Drum
MuteCuica :: Drum
OpenCuica :: Drum
MuteTriangle :: Drum
OpenTriangle :: Drum
data Element
R :: T -> Element
N :: T -> NoteAttributes -> Element
Roll :: T -> T -> NoteAttributes -> Element
Rolln :: Integer -> T -> NoteAttributes -> Element
na :: NoteAttributes
toMusic :: drum -> T -> NoteAttributes -> T drum instr
toMusicDefaultAttr :: drum -> T -> T drum instr
lineToMusic :: T -> [Element] -> T
elementToMusic :: T -> Element -> T
funkGroove :: T

module Haskore.Example.BesondrerTag
noAttr :: [NoteAttributes -> T] -> T
bar0 :: T
bass1 :: T
bass0 :: T
bar1 :: T
melody :: T
bass :: T
song :: T

module Haskore.Example.ChildSong6
fd :: t -> (t -> NoteAttributes -> m) -> m
vel :: (NoteAttributes -> m) -> m
v :: NoteAttributes
lmap :: (a -> T) -> [a] -> T
bassLine :: T
mainVoice :: T
song :: T
b1 :: T
b3 :: T
b2 :: T
v1 :: T
v1b :: T
v1a :: T
v2 :: T
v2f :: T
v2e :: T
v2d :: T
v2c :: T
v2b :: T
v2a :: T


-- | Create chord patterns with controlable level of details.
module Haskore.Example.Detail
levels :: [[T]]
randomItem :: RandomGen g => [a] -> State g a

-- | <a>randomR</a> wrapped in a State monad.
randomRState :: RandomGen g => (Int, Int) -> State g Int
merge :: [a] -> [a] -> [a]
dyadicPattern :: [T]
simpleSong :: T
dyadicLevelPattern :: [(Int, T)]
song :: T

module Haskore.Example.Flip
flipSeq :: Int -> [Int]
flipSeq2 :: [Int]
noteArray :: [() -> T ()] -> Array Int (T ())
makeSong :: [() -> T ()] -> T ()
song :: T ()
core1 :: T ()
core :: T ()
song1 :: T ()
song2 :: T
core2 :: T


-- | Christman song <a>O Heiland, reiß die Himmel auf</a> from <a>Du
--   wurdest meine Sonne - Heft I: Advents- und Weihnachtslieder in
--   einfachen Sätzen</a> Evangelische Verlagsanstalt Berlin
--   
--   fileFromGeneralMIDIMusic <a>heiland.mid</a> song
module Haskore.Example.HeilandHimmel
noAttr :: [NoteAttributes -> T] -> T
melody0 :: T
bass3 :: T
bass2 :: T
bass1 :: T
bass0 :: T
melody3 :: T
melody2 :: T
melody1 :: T
melody :: T
bass :: T
song :: T

module Haskore.Example.Ssf
shortLegato :: T () -> T ()
m1 :: [T ()]
m4 :: [T ()]
m3 :: [T ()]
m2 :: [T ()]
melody :: T ()
song :: T

module Haskore.Example.Raenzlein
vline :: [NoteAttributes -> T] -> T
mel0 :: T
verse :: T
strings :: T
refrain :: T
melody :: T
v :: NoteAttributes
s1 :: [Generic NoteAttributes]
s2 :: [Generic NoteAttributes]
song :: T

module Haskore.Example.WhiteChristmas
vline :: [NoteAttributes -> T] -> T
melody :: T
strings :: T
m1 :: T
m4b :: T
m3b :: T
m4a :: T
m3a :: T
m2 :: T
v :: NoteAttributes
vel :: Velocity -> NoteAttributes
s1 :: [Generic NoteAttributes]
s4b :: [Generic NoteAttributes]
s4a :: [Generic NoteAttributes]
s3 :: [Generic NoteAttributes]
s2 :: [Generic NoteAttributes]
bassdrum :: Dur -> T
hihat :: Dur -> T
snare :: Dur -> T
rhythm :: T
song :: T

module Haskore.Interface.CSound.Note
data T
Cons :: [PField] -> Velocity -> Instrument -> Maybe Absolute -> T
parameters :: T -> [PField]
velocity :: T -> Velocity
instrument :: T -> Instrument
pitch :: T -> Maybe Absolute
fromRhyNote :: RealFrac dyn => ToSound drum -> ToSound instr -> dyn -> Relative -> Note drum instr -> T
velocityFromStd :: RealFrac dyn => dyn -> Rational -> Velocity
pitchFromStd :: Relative -> T -> Absolute
velocityToDb :: Float -> Float
amplitudeToDb :: Float -> Float
zeroKey :: Int

module Haskore.Composition.Rhythm
type T = [Bool]
unit :: Dur
fromString :: String -> T
fromPositions :: [Int] -> T
type ToMusicWithMusic drum instr = T drum instr -> T -> T drum instr
type ToMusicWithDrum drum instr = drum -> T -> T drum instr
toMusicWithMusic :: ToMusicWithMusic drum instr
toMusicWithDrum :: ToMusicWithDrum drum instr
toMusicWithDrumUnit :: Dur -> ToMusicWithDrum drum instr
toShuffledMusicWithDrum :: ToMusicWithDrum drum instr
toShuffledMusicWithDrumUnit :: Dur -> ToMusicWithDrum drum instr
tickR :: T
jazzWaltzHiHatR :: T
jazzWaltzRideR :: T
jazzRideR :: T
clave7 :: T
clave5 :: T
claveBossaR :: T
claveRumbaR :: T
claveR :: T
backBeatR :: T
downBeatR :: T
countInR :: Dur -> T
tickP :: drum -> T drum instr
backBeatP :: drum -> T drum instr
downBeatP :: drum -> T drum instr
jazzWaltzHiHatP :: drum -> T drum instr
jazzWaltzRideP :: drum -> T drum instr
jazzRideP :: drum -> T drum instr
claveBossaP :: drum -> T drum instr
claveRumbaP :: drum -> T drum instr
claveP :: drum -> T drum instr
click :: T
ride :: T
basicHiHat :: T
basicSnare :: T
basicBassDrum :: T
metro7 :: T
metro5 :: T
claveBossa :: T
claveRumba :: T
clave :: T
countIn :: Dur -> T

module Haskore.Example.Fractal
type Vector a = [a]
type Matrix a = [Vector a]
type AT a = Vector a -> Vector a
type IFS a = Array Int (AT a)
vadd :: Num a => Vector a -> Vector a -> Vector a
vvmult :: Num a => Vector a -> Vector a -> a
mvmult :: Num a => Matrix a -> Vector a -> Vector a
cvmult :: Num a => a -> Vector a -> Vector a
w0 :: Fractional a => AT a
w2 :: Fractional a => AT a
w1 :: Fractional a => AT a
init0 :: Num a => Vector a
ws :: Fractional a => IFS a
result :: [Vector Rational]
mkNote :: [Rational] -> T ()
sourceToMusic :: [[Rational]] -> T ()
song :: T ()

module Haskore.Example.Guitar
mapChordToString :: [T] -> [Class] -> [T]
choosePitchForString :: [Class] -> T -> T
stringPitches :: [T]
data Direction
Up :: Direction
Down :: Direction
delayTime :: Dur
dirDelays :: Direction -> [Offset]
type UpDownPattern = [(Dur, Direction)]
udp :: UpDownPattern
udpLast :: UpDownPattern
udpInter :: UpDownPattern
chords :: [([Class], UpDownPattern)]
type DelayedNote = (Offset, (Dur, Maybe T))
chordToPattern :: [Class] -> UpDownPattern -> [[DelayedNote]]
guitarEvents :: [[DelayedNote]]
delayNotes :: [DelayedNote] -> [T ()]
stringMelodies :: [T ()]
parallelSong :: [instr] -> T drum instr
parallelSongMIDI :: T
chordWithLegatoPattern :: [T drum instr] -> UpDownPattern -> T drum instr
legatoSong :: [instr] -> T drum instr
legatoSongMIDI :: T

module Haskore.Performance
type T time dyn note = T time (Event time dyn note)
type Padded time dyn note = T time (Event time dyn note)
data Event time dyn note
Event :: time -> dyn -> Relative -> note -> Event time dyn note
eventDur :: Event time dyn note -> time
eventDynamics :: Event time dyn note -> dyn
eventTranspose :: Event time dyn note -> Relative
eventNote :: Event time dyn note -> note
fromMusic :: (C time, RealFrac time, Ord dyn, Fractional dyn, Ord note) => PlayerMap time dyn note -> Context time dyn note -> T note -> T time dyn note
type PlayerMap time dyn note = PlayerName -> Player time dyn note
data Context time dyn note
Context :: time -> Player time dyn note -> Relative -> dyn -> Context time dyn note
contextDur :: Context time dyn note -> time
contextPlayer :: Context time dyn note -> Player time dyn note
contextTranspose :: Context time dyn note -> Relative
contextDynamics :: Context time dyn note -> dyn
type UpdateContext time dyn note a = (a -> a) -> Context time dyn note -> Context time dyn note
updatePlayer :: UpdateContext time dyn note (Player time dyn note)
updateDur :: UpdateContext time dyn note time
updateTranspose :: UpdateContext time dyn note Relative
updateDynamics :: UpdateContext time dyn note dyn
paddedFromMusic :: (C time, RealFrac time, Ord dyn, Fractional dyn, Ord note) => PlayerMap time dyn note -> Context time dyn note -> T note -> Padded time dyn note
type PaddedWithRests time dyn note = T time (Maybe (Event time dyn note))
type Monad time dyn note = Reader (Context time dyn note) (PaddedWithRests time dyn note, time)
sequenceReader :: [Reader r a] -> Reader r [a]
combine :: ([performance] -> performance, [time] -> time) -> [Reader r (performance, time)] -> Reader r (performance, time)
monadFromMusic :: (C time, RealFrac time, Ord dyn, Fractional dyn, Ord note) => PlayerMap time dyn note -> T note -> Monad time dyn note
data Player time dyn note
PlayerCons :: PlayerName -> NoteFun time dyn note -> PhraseFun time dyn note -> NotateFun -> Player time dyn note
name :: Player time dyn note -> PlayerName
playNote :: Player time dyn note -> NoteFun time dyn note
interpretPhrase :: Player time dyn note -> PhraseFun time dyn note
notatePlayer :: Player time dyn note -> NotateFun
type NoteFun time dyn note = Context time dyn note -> Dur -> note -> T time dyn note
type PhraseFun time dyn note = PhraseAttribute -> Monad time dyn note -> Monad time dyn note
type NotateFun = ()
instance (Eq time, Eq dyn, Eq note) => Eq (Event time dyn note)
instance (Show time, Show dyn, Show note) => Show (Event time dyn note)
instance (Show time, Show dyn) => Show (Context time dyn note)
instance (Show time, Show dyn) => Show (Player time dyn note)
instance (Ord time, Ord dyn, Ord note) => Ord (Event time dyn note)

module Haskore.Performance.BackEnd
type T time note = T time (Event time note)
type Padded time note = T time (Event time note)
data Event time note
Event :: time -> note -> Event time note
eventDur :: Event time note -> time
eventNote :: Event time note -> note
mapTime :: (time0 -> time1) -> T time0 note -> T time1 note
mapTimePadded :: (time0 -> time1) -> Padded time0 note -> Padded time1 note
eventFromPerformanceEvent :: (dyn -> Relative -> note -> backEndNote) -> Event time dyn note -> Event time backEndNote
fromPerformance :: (dyn -> Relative -> note -> backEndNote) -> T time dyn note -> T time backEndNote
fromPaddedPerformance :: (dyn -> Relative -> note -> backEndNote) -> Padded time dyn note -> Padded time backEndNote
toMusic :: T Dur note -> T note
instance (Eq time, Eq note) => Eq (Event time note)
instance (Ord time, Ord note) => Ord (Event time note)
instance (Show time, Show note) => Show (Event time note)
instance Functor (Event time)

module Haskore.Interface.MML
type Accum = (Dur, Octave)
barToMusic :: String -> Accum -> ([T ()], Accum)
toMusicState :: String -> State Accum [T ()]
toMusic :: Octave -> String -> T ()

module Haskore.Interface.AutoTrack.ChartBar
data T
Cons :: Dur -> [Maybe T] -> T
dur :: T -> Dur
chords :: T -> [Maybe T]
readChordSymbol :: Dur -> Maybe T -> ReadS T
length :: Integral a => T -> a
instance Show T
instance C T
instance Read T

module Haskore.Interface.AutoTrack.ChordChart
data T
Cons :: [T] -> T
bars :: T -> [T]
hasChord :: T -> (Dur, [Bool])
length :: Integral a => T -> a
concat :: T -> T -> T
instance Show T
instance C T
instance Read T

module Haskore.Interface.AutoTrack.EventChart
data T e
Cons :: [(Dur, e)] -> T e
events :: T e -> [(Dur, e)]
fromChordChart :: T -> T T
fromChartBar :: T -> T T
instance Show e => Show (T e)
instance Functor T
instance C a => C (T a)

module Haskore.Process.Format
prettyGrammarMedium :: (Show prim, Show control) => T String control prim -> String
prettyGrammarMelody :: T String Control (Primitive Note) -> String
prettyGrammar :: (Int -> control -> (Int -> ShowS) -> ShowS) -> (Int -> prim -> ShowS) -> T String control prim -> String
bind :: (Int -> control -> (Int -> ShowS) -> ShowS) -> (Int -> prim -> ShowS) -> (String, TagMedium String control prim) -> ShowS
tagMedium :: Int -> (Int -> control -> (Int -> ShowS) -> ShowS) -> (Int -> prim -> ShowS) -> TagMedium String control prim -> ShowS
list :: [Int -> ShowS] -> ShowS
listFunc :: String -> [Int -> ShowS] -> Int -> ShowS
prim :: Show p => Int -> p -> ShowS
dummySrcLoc :: SrcLoc
prettyMelody :: T -> String
prettyExp :: String -> String
melody :: Int -> T -> ShowS
primMelody :: Int -> Primitive Note -> ShowS
atom :: Show attr => Int -> T -> Atom (Note attr) -> ShowS
note :: Show attr => Int -> T -> Note attr -> ShowS
rest :: Int -> T -> ShowS
controlGen :: Show control => Int -> control -> (Int -> ShowS) -> ShowS
control :: Int -> Control -> (Int -> ShowS) -> ShowS
durSyntax :: (ShowS -> ShowS) -> String -> T -> ShowS
showDur :: Int -> T -> ShowS
enclose :: Int -> Int -> ShowS -> ShowS


-- | Import Music from text printed by OctaMED. It will be certainly easy
--   to adapt that for other trackers like SoundTracker, NoiseTracker,
--   DigiBooster, FastTracker.
--   
--   Take care that you use B not H note name.
module Haskore.Interface.MED.Text

-- | should be moved to Utility
sieve :: Int -> [a] -> [a]

-- | should be moved to Utility
sliceHoriz :: Int -> [a] -> [[a]]

-- | should be moved to Utility
sliceVert :: Int -> [a] -> [[a]]
type Instrument = Int
splitBlocks :: [String] -> [[String]]
cellToNote :: String -> (Maybe (T, Instrument), String)
parseDigit :: CharParser () Int
parseNote :: CharParser () (Maybe (T, Instrument))
parseCell :: CharParser () (Maybe (T, Instrument), String)
columnToNotes :: [String] -> ([String], [(T, Instrument, [String])])

-- | Convert a block of a song to a list of notes.
linesToNotes :: [String] -> [([String], [(T, Instrument, [String])])]
columnToSimpleSerial :: Integer -> ([String], [(T, Instrument, [String])]) -> ShowS

module Haskore.Music.Standard
type T = T Drum Instr
type Note = Note Drum Instr
type NoteBody = NoteBody Drum Instr
type Instr = String
type Drum = String
velocity :: Note drum instr -> Rational
body :: Note drum instr -> NoteBody drum instr
instrument :: NoteBody drum instr -> instr
pitch :: NoteBody drum instr -> T
drum :: NoteBody drum instr -> drum
noteFromStdMelodyNote :: instr -> Note -> Note drum instr

-- | in contrast to RhyMusic.fromStdMelody it has fixed instrument type
fromStdMelody :: Instr -> T -> T
fromMelodyNullAttr :: Instr -> T () -> T
bn :: T
wn :: T
hn :: T
qn :: T
en :: T
sn :: T
tn :: T
sfn :: T
dwn :: T
dhn :: T
dqn :: T
den :: T
dsn :: T
dtn :: T
ddhn :: T
ddqn :: T
dden :: T
bnr :: T note
wnr :: T note
hnr :: T note
qnr :: T note
enr :: T note
snr :: T note
tnr :: T note
sfnr :: T note
dwnr :: T note
dhnr :: T note
dqnr :: T note
denr :: T note
dsnr :: T note
dtnr :: T note
ddhnr :: T note
ddqnr :: T note
ddenr :: T note
line :: [T note] -> T note
chord :: [T note] -> T note
changeTempo :: DurRatio -> T note -> T note
transpose :: Relative -> T note -> T note
phrase :: PhraseAttribute -> T note -> T note
(+:+) :: T note -> T note -> T note
(=:=) :: T note -> T note -> T note
type Dur = T
data PhraseAttribute
Dyn :: Dynamic -> PhraseAttribute
Tmp :: Tempo -> PhraseAttribute
Art :: Articulation -> PhraseAttribute
Orn :: Ornament -> PhraseAttribute
data Dynamic
Loudness :: Rational -> Dynamic
Accent :: Rational -> Dynamic
Crescendo :: Rational -> Dynamic
Diminuendo :: Rational -> Dynamic
data Tempo
Ritardando :: Rational -> Tempo
Accelerando :: Rational -> Tempo
data Articulation
Staccato :: Dur -> Articulation
Legato :: Dur -> Articulation
Slurred :: Dur -> Articulation
Tenuto :: Articulation
Marcato :: Articulation
Pedal :: Articulation
Fermata :: Articulation
FermataDown :: Articulation
Breath :: Articulation
DownBow :: Articulation
UpBow :: Articulation
Harmonic :: Articulation
Pizzicato :: Articulation
LeftPizz :: Articulation
BartokPizz :: Articulation
Swell :: Articulation
Wedge :: Articulation
Thumb :: Articulation
Stopped :: Articulation
data Ornament
Trill :: Ornament
Mordent :: Ornament
InvMordent :: Ornament
DoubleMordent :: Ornament
Turn :: Ornament
TrilledTurn :: Ornament
ShortTrill :: Ornament
Arpeggio :: Ornament
ArpeggioUp :: Ornament
ArpeggioDown :: Ornament
Instruction :: String -> Ornament
Head :: NoteHead -> Ornament
data NoteHead
DiamondHead :: NoteHead
SquareHead :: NoteHead
XHead :: NoteHead
TriangleHead :: NoteHead
TremoloHead :: NoteHead
SlashHead :: NoteHead
ArtHarmonic :: NoteHead
NoHead :: NoteHead
accent :: Rational -> T note -> T note
crescendo :: Rational -> T note -> T note
diminuendo :: Rational -> T note -> T note
loudness1 :: Rational -> T note -> T note
ritardando :: Rational -> T note -> T note
accelerando :: Rational -> T note -> T note
staccato :: Dur -> T note -> T note
legato :: Dur -> T note -> T note
defltLegato :: T note -> T note
defltStaccato :: T note -> T note
defltAccent :: T note -> T note
bigAccent :: T note -> T note

module Haskore.Interface.MIDI.InstrumentMap
type ChannelTable instr = [(instr, Channel)]
type ChannelProgramTable instr = [(instr, (Channel, Program))]
type ChannelProgramPitchTable instr = [(instr, (Channel, Program, Pitch))]
type ToChannel instr = instr -> Channel
type ToChannelProgram instr = instr -> (Channel, Program)
type ToChannelProgramPitch instr = instr -> (Channel, Program, Pitch)
type FromChannel instr = Channel -> Maybe instr
type FromChannelProgram instr = (Channel, Program) -> Maybe instr
type FromChannelProgramPitch instr = (Channel, Program, Pitch) -> Maybe instr
repair :: [Instr] -> ChannelProgramTable Instr -> ChannelProgramTable Instr
allValid :: ChannelProgramTable Instr -> [Instr] -> Bool
tableFromInstruments :: [Instr] -> ChannelProgramTable Instr
assignChannels :: [Channel] -> [Instr] -> [(Channel, Program)]
fromInstruments :: Ord instr => [instr] -> ToChannel instr
partialMatch :: Instr -> Instr -> Bool
lookupIName :: [(Instr, a)] -> Instr -> a
lookup :: Eq instr => [(instr, a)] -> instr -> a
reverseLookupMaybe :: Eq a => [(instr, a)] -> a -> Maybe instr
reverseLookup :: Eq a => [(instr, a)] -> a -> instr
defltTable :: [(Instr, Channel, Instrument)]
deflt :: ChannelProgramTable Instr
defltGM :: ChannelProgramTable Instrument
defltCMap :: [(Instrument, Channel)]

module Haskore.Interface.MIDI.Note
data T
Cons :: Velocity -> Velocity -> Channel -> Program -> Pitch -> T
velocityOn :: T -> Velocity
velocityOff :: T -> Velocity
channel :: T -> Channel
program :: T -> Program
pitch :: T -> Pitch
fromMIDIEvents :: (T, T) -> Maybe T
toMIDIEvents :: T -> (T, T)
fromRhyNote :: RealFrac dyn => ToChannelProgramPitch drum -> ToChannelProgram instr -> dyn -> Relative -> Note drum instr -> T
fromGMNote :: RealFrac dyn => ToChannel Instr -> dyn -> Relative -> Note -> T
velocityFromStd :: RealFrac dyn => dyn -> Rational -> Velocity
pitchFromStd :: Relative -> T -> Pitch
toRhyNote :: FromChannelProgramPitch drum -> FromChannelProgram instr -> T -> Note drum instr
toGMNote :: T -> Note
velocityToStd :: Fractional a => Velocity -> a
pitchToStd :: Pitch -> T

module Haskore.Performance.Player
type T time dyn note = Player time dyn note
type Name = PlayerName
type Map time dyn note = PlayerMap time dyn note
type PhraseInterpreter time dyn note = PhraseAttribute -> (T time dyn note, time) -> (T time dyn note, time)
type EventModifier time dyn note = Event time dyn note -> Event time dyn note
changeVelocity :: Num dyn => (dyn -> dyn) -> EventModifier time dyn note
changeDur :: Num time => (time -> time) -> EventModifier time dyn note
staccatoRel :: (C time, Fractional time) => T -> Monad time dyn note -> Monad time dyn note
slurredRel :: (C time, Fractional time) => T -> Monad time dyn note -> Monad time dyn note
legatoRel :: (C time, Fractional time) => T -> Monad time dyn note -> Monad time dyn note
mapInitEvents :: (C time, Num time) => EventModifier time dyn note -> Monad time dyn note -> Monad time dyn note
mapEvents :: EventModifier time dyn note -> Monad time dyn note -> Monad time dyn note
staccatoAbs :: (C time, Fractional time) => T -> Monad time dyn note -> Monad time dyn note
slurredAbs :: (C time, Fractional time) => T -> Monad time dyn note -> Monad time dyn note
legatoAbs :: (C time, Fractional time) => T -> Monad time dyn note -> Monad time dyn note
getDurModifier :: Fractional time => (time -> time -> time) -> T -> Reader (Context time dyn note) (EventModifier time dyn note)
accent :: Fractional dyn => Rational -> Monad time dyn note -> Monad time dyn note

module Haskore.Performance.Context
type T time dyn note = Context time dyn note
setPlayer :: SetContext time dyn note (T time dyn note)
setDur :: SetContext time dyn note time
setTranspose :: SetContext time dyn note Relative
setDynamics :: SetContext time dyn note dyn
getPlayer :: GetContext time dyn note (T time dyn note)
getDur :: GetContext time dyn note time
getTranspose :: GetContext time dyn note Relative
getDynamics :: GetContext time dyn note dyn
updatePlayer :: UpdateContext time dyn note (Player time dyn note)
updateDur :: UpdateContext time dyn note time
updateTranspose :: UpdateContext time dyn note Relative
updateDynamics :: UpdateContext time dyn note dyn
contextPlayer :: Context time dyn note -> Player time dyn note
contextDur :: Context time dyn note -> time
contextTranspose :: Context time dyn note -> Relative
contextDynamics :: Context time dyn note -> dyn

module Haskore.Performance.Default
player :: (C time, Fractional time, Real time, Fractional dyn) => T time dyn note
map :: (C time, Fractional time, Real time, Fractional dyn) => Name -> T time dyn note
playNote :: (Fractional time, Real time) => NoteFun time dyn note
interpretPhrase :: (C time, Fractional time, Fractional dyn) => PhraseFun time dyn note
notatePlayer :: () -> NotateFun
context :: (C time, Fractional time, Real time, Fractional dyn) => T time dyn note
fromMusic :: (Ord note, C time, RealFrac time, Fractional dyn, Ord dyn) => T note -> T time dyn note
fromMusicModifyContext :: (Ord note, C time, RealFrac time, Fractional dyn, Ord dyn) => (T time dyn note -> T time dyn note) -> T note -> T time dyn note
floatFromMusic :: Ord note => T note -> T Float Float note
paddedFromMusic :: (Ord note, C time, RealFrac time, Fractional dyn, Ord dyn) => T note -> Padded time dyn note
paddedFromMusicModifyContext :: (Ord note, C time, RealFrac time, Fractional dyn, Ord dyn) => (T time dyn note -> T time dyn note) -> T note -> T time dyn note

module Haskore.Interface.MIDI.Read
toRhyMusic :: (C time, Fractional time, Real time, Fractional dyn) => ChannelProgramPitchTable drum -> ChannelProgramTable instr -> T -> (T time dyn (Note drum instr), T drum instr)
toGMMusic :: (C time, Fractional time, Real time, Fractional dyn) => T -> (ChannelTable Instr, T time dyn Note, T)
retrieveTracks :: T -> [[T]]

module Haskore.Performance.Fancy
player :: (C time, Fractional time, Real time, Fractional dyn) => T time dyn note
map :: (C time, Fractional time, Real time, Fractional dyn) => String -> T time dyn note
processPerformance :: Num time => (time -> (time -> time -> time, time -> Event time dyn note -> Event time dyn note, time)) -> (PaddedWithRests time dyn note, time) -> (PaddedWithRests time dyn note, time)
fancyInterpretDynamic :: (Fractional time, Real time, Fractional dyn) => Dynamic -> Monad time dyn note -> Monad time dyn note
fancyInterpretTempo :: (Fractional time, Real time) => Tempo -> Monad time dyn note -> Monad time dyn note
fancyInterpretArticulation :: (C time, Fractional time) => Articulation -> Monad time dyn note -> Monad time dyn note
fancyInterpretOrnament :: (Fractional time, Real time) => Ornament -> Monad time dyn note -> Monad time dyn note
fancyInterpretPhrase :: (C time, Fractional time, Real time, Fractional dyn) => PhraseFun time dyn note
context :: (C time, Fractional time, Real time, Fractional dyn) => T time dyn note
fromMusic :: (Ord note, C time, RealFrac time, Fractional dyn, Ord dyn) => T note -> T time dyn note
fromMusicModifyContext :: (Ord note, C time, RealFrac time, Fractional dyn, Ord dyn) => (T time dyn note -> T time dyn note) -> T note -> T time dyn note
floatFromMusic :: Ord note => T note -> T Float Float note
paddedFromMusic :: (Ord note, C time, RealFrac time, Fractional dyn, Ord dyn) => T note -> Padded time dyn note
doublePaddedFromMusic :: Ord note => T note -> Padded Double Double note
paddedFromMusicModifyContext :: (Ord note, C time, RealFrac time, Fractional dyn, Ord dyn) => (T time dyn note -> T time dyn note) -> T note -> T time dyn note

module Haskore.Interface.MIDI.Write
fromRhythmicPerformance :: (C time, RealFrac time, RealFrac dyn, Eq drum, Eq instr) => ChannelProgramPitchTable drum -> ChannelProgramTable instr -> Perf time dyn drum instr -> T
fromRhythmicPerformanceMixed :: (C time, RealFrac time, RealFrac dyn, Eq drum, Eq instr) => ChannelProgramPitchTable drum -> ChannelProgramTable instr -> Perf time dyn drum instr -> T
fromGMPerformance :: (C time, RealFrac time, RealFrac dyn) => (Instrument -> Channel) -> T time dyn Note -> T
fromGMPerformanceMixed :: (C time, RealFrac time, RealFrac dyn) => (Instrument -> Channel) -> T time dyn Note -> T
fromGMPerformanceAuto :: (C time, RealFrac time, RealFrac dyn) => T time dyn Note -> T
fromGMPerformanceMixedAuto :: (C time, RealFrac time, RealFrac dyn) => T time dyn Note -> T
fromRhythmicMusic :: (C time, RealFrac time, RealFrac dyn, Ord drum, Ord instr) => (ChannelProgramPitchTable drum, ChannelProgramTable instr, T time dyn (Note drum instr), T drum instr) -> T
fromRhythmicMusicMixed :: (C time, RealFrac time, RealFrac dyn, Ord drum, Ord instr) => (ChannelProgramPitchTable drum, ChannelProgramTable instr, T time dyn (Note drum instr), T drum instr) -> T
fromGMMusic :: (C time, RealFrac time, RealFrac dyn) => (ChannelTable Instr, T time dyn Note, T) -> T
fromGMMusicAuto :: (C time, RealFrac time, RealFrac dyn) => (T time dyn Note, T) -> T
fromGMMusicMixed :: (C time, RealFrac time, RealFrac dyn) => (ChannelTable Instr, T time dyn Note, T) -> T
fromGMMusicMixedAuto :: (C time, RealFrac time, RealFrac dyn) => (T time dyn Note, T) -> T
volumeHaskoreToMIDI :: (RealFrac a, Floating a) => a -> Int
volumeMIDIToHaskore :: Floating a => Int -> a

module Haskore.Example.Kantate147
initOctaves :: [Octave]
songMML :: [(String, String, String, String)]
musicTracks :: [[[T ()]]]
song :: T ()
grammar :: T String Control (Primitive (Note ()))
markovChain :: T ()
markovChainMidi :: T
cm :: ChannelTable Instrument
context :: T Float Float Note
toMidi :: T () -> T
midi :: T
main :: IO ()

module Haskore.Interface.MIDI

module Haskore.Interface.MIDI.Render
fileFromRhythmicMusic :: (Ord instr, Ord drum, C time, RealFrac time, RealFrac dyn) => FilePath -> (ChannelProgramPitchTable drum, ChannelProgramTable instr, T time dyn (Note drum instr), T drum instr) -> IO ()
midi :: T -> T
generalMidi :: T -> T
generalMidiDeflt :: T -> T
mixedMidi :: T -> T
mixedGeneralMidi :: T -> T
fileFromGeneralMIDIMusic :: FilePath -> T -> IO ()
fileName :: FilePath
play :: String -> [String] -> T -> IO ExitCode
playWin95 :: T -> IO ExitCode
playTimidityJack :: T -> IO ExitCode
playTimidity :: T -> IO ExitCode
playAlsa :: T -> IO ExitCode
playLinux :: T -> IO ExitCode
playWinNT :: T -> IO ExitCode
playTest :: IO ExitCode
gmUpm :: ChannelProgramTable Instr
gmTest :: Int -> IO ()

module Haskore.Example.SelfSim
data Cluster
Cl :: SNote -> [Cluster] -> Cluster
type Pat = [SNote]
type SNote = [(Absolute, Dur)]
sim :: Pat -> [Cluster]
addmult :: (Num a, Num b) => [(a, b)] -> [(a, b)] -> [(a, b)]
simFringe :: (Num a, Eq a) => a -> Pat -> [SNote]
fringe :: (Num a, Eq a) => a -> Cluster -> [SNote]
simToHask :: [[(Absolute, Dur)]] -> T ()
sim4 :: Int -> T ()
sim1 :: Int -> T
sim4s :: Int -> T
sim3 :: Int -> T
sim12 :: Int -> T
sim2 :: Int -> T
t6 :: T
t10 :: T
t9 :: T
t8 :: T
t7 :: T
ss :: T
durss :: Dur
pat1 :: [SNote]
pat4' :: [SNote]
pat4 :: [SNote]
pat3 :: [SNote]
pat2 :: [SNote]

module Haskore.Example.Miscellaneous
t0 :: T
ssf0 :: T
cs6 :: T
t14d :: T
t14c :: T
t14b :: T
t14 :: T
t13e :: T
t13d :: T
t13c :: T
t13b :: T
t13a :: T
t13 :: T
t12a :: T
t12 :: T
t10s :: T
t5 :: T
t4 :: T
t3 :: T
t2 :: T
t1 :: T
piano :: Instrument
flute :: Instrument
vibes :: Instrument
cms' :: T ()
cms :: T ()
drumScale :: T
temp :: T
mu2 :: T
rep :: (T note -> T note) -> (T note -> T note) -> Int -> T note -> T note
run :: T ()
cascades :: T ()
cascade :: T ()
t4' :: T () -> T
run' :: T ()
cascades' :: T ()
cascade' :: T ()
drums :: Drum -> Drum -> T
t11 :: Drum -> Drum -> T
t13note :: T
tab :: T -> IO ()
type StdContext = T Float Float (Note Drum Instr)
type MidiArrange = (ChannelTable Instr, StdContext, T)
tad :: T -> MidiArrange
tcb :: FilePath -> IO ()
tcdab :: FilePath -> IO ()
tcd :: FilePath -> IO ()
tc :: FilePath -> IO ()

module Haskore.Interface.AutoTrack.Style
type T = T -> T
playToStream :: Int -> T -> Integer -> Int -> T -> ByteString
jazz :: T
bossa :: T
takeFive :: T
rock :: T
thomasCarib :: T
harmonic :: T

module Haskore.Example.NewResolutions
piano :: Instr
glock :: Instr
vib :: Instr
xylo :: Instr
marimba :: Instr
pattern :: T
endRun :: T
melody3 :: T
vibePart3 :: T
vibeLine3 :: T
melody2 :: T
vibesPart :: T
vibesLine :: T
bellPart :: T
melody1 :: T
melPattern :: T
part1 :: T
harmony3 :: T
ending :: T
bridge :: T
part3 :: T
part2 :: T
comp2 :: (c -> d) -> (a -> b -> c) -> (a -> b -> d)
arpeggio :: [Int] -> T -> Dur -> T
minArpegUp :: T -> Dur -> T
six3ArpegDown :: T -> Dur -> T
majArpegDown :: T -> Dur -> T
minArpegDown :: T -> Dur -> T
cMajorScale :: [T]
dPentMinScale :: [T]
gMajorScale :: [T]
prevNote :: [T] -> T -> T
nextNote :: [T] -> T -> T
nextNote' :: T -> [T] -> T -> T
back2Note :: [T] -> T -> T
nextNR :: T -> T
back2NR :: T -> T
prevNR :: T -> T
makeSN :: T -> T
diddle :: T -> T
run1 :: T -> Dur -> T
run3 :: T -> Dur -> T
run2 :: T -> Dur -> T
part3Pattern :: Num t => ((t, Class) -> Dur -> T) -> T
all3Insts :: T -> T
endEl :: T -> T
song :: T
context :: T Float Float (Note Drum Instr)
midi :: T
main :: IO ()

module Haskore.Interface.CSound.Score
type T = [Statement]
data Statement
Tempo :: Bpm -> Statement
Note :: Instrument -> StartTime -> Duration -> Pch -> Volume -> [PField] -> Statement
Table :: Table -> CreatTime -> TableSize -> Normalize -> T -> Statement
type Bpm = Int
type StartTime = Time
type Duration = Time
data Pch
AbsPch :: Absolute -> Pch
Cps :: Float -> Pch
type Volume = Float
type Table = Int
type CreatTime = Time
type TableSize = Int
type Normalize = Bool
simpleSine :: Table -> Statement
whiteNoise :: Table -> Statement
triangle :: Table -> Statement
sawtooth :: Table -> Statement
square :: Table -> Statement
compSine :: Table -> [PStrength] -> Statement
fromPerformanceBE :: (C time, Num time) => (time -> Time) -> T time T -> T
saveIA :: T -> IO ()
fromRhythmicMusic :: (RealFrac time, C time, RealFrac dyn, Ord drum, Ord instr) => Tables -> (SoundTable drum, SoundTable instr, T time dyn (Note drum instr), T drum instr) -> T
type Tables = T
fromRhythmicPerformance :: (RealFrac time, C time, RealFrac dyn, Ord drum, Ord instr) => SoundTable drum -> SoundTable instr -> T time dyn (Note drum instr) -> T
fromRhythmicPerformanceMap :: (RealFrac time, C time, RealFrac dyn) => ToSound drum -> ToSound instr -> T time dyn (Note drum instr) -> T
fromRhythmicPerformanceWithAttributes :: (RealFrac time, C time, RealFrac dyn) => DrumTableWithAttributes out drum -> InstrumentTableWithAttributes out instr -> T time dyn (Note drum instr) -> T
noteToStatement :: (time -> Time) -> time -> time -> T -> Statement
save :: FilePath -> T -> IO ()
toString :: T -> String
statementToString :: Statement -> String
statementToWords :: Statement -> [String]
pchToString :: Pch -> String
instance Show Pch
instance Show Statement

module Haskore.Interface.CSound.Tutorial
pureToneTN :: Table
pureToneTable :: SigExp
pureTone :: Statement
oscPure :: SigExp -> SigExp -> SigExp
type TutMelody params = T (TutAttr params)
data TutAttr params
TutAttr :: Rational -> params -> TutAttr params
attrVelocity :: TutAttr params -> Rational
attrParameters :: TutAttr params -> params
tune1 :: TutMelody ()
data Instrument
Instr1p0 :: Instrument
Instr2p0 :: Instrument
Instr1p2 :: Float -> Float -> Instrument
Instr1p4 :: Float -> Float -> Float -> Float -> Instrument
musicFromMelody :: (params -> Instrument) -> TutMelody params -> T () Instrument
type Pair = (Float, Float)
type Quadruple = (Float, Float, Float, Float)
attrToInstr1p0 :: () -> Instrument
attrToInstr2p0 :: () -> Instrument
attrToInstr1p2 :: Pair -> Instrument
attrToInstr1p4 :: Quadruple -> Instrument
performanceFromMusic :: T () Instrument -> T Float Float (Note () Instrument)
type TutOrchestra out = (Header, InstrumentTableWithAttributes out Instrument)
instrNum1 :: Instrument
instrNum2 :: Instrument
instrAssoc1p0 :: InstrumentSigExp out -> InstrumentAssociation out Instrument
instrAssoc2p0 :: InstrumentSigExp out -> InstrumentAssociation out Instrument
instrAssoc1p2 :: (SigExp -> SigExp -> InstrumentSigExp out) -> InstrumentAssociation out Instrument
instrAssoc1p4 :: (SigExp -> SigExp -> SigExp -> SigExp -> InstrumentSigExp out) -> InstrumentAssociation out Instrument
scored :: TutOrchestra out -> (params -> Instrument) -> TutMelody params -> T
example :: Name -> (TutOrchestra out -> T) -> TutOrchestra out -> (Name, T, TutOrchestra out)
oe1 :: InstrumentSigExp Mono
hdr :: Header
o1 :: TutOrchestra Mono
o22 :: TutOrchestra Mono
o19 :: TutOrchestra Mono
o15 :: TutOrchestra Mono
o14 :: TutOrchestra Mono
o13 :: TutOrchestra Mono
o9 :: TutOrchestra Mono
o8 :: TutOrchestra Mono
o7 :: TutOrchestra Mono
o4 :: TutOrchestra Mono
o3 :: TutOrchestra Mono
o2 :: TutOrchestra Mono
o5 :: TutOrchestra Stereo
o21 :: TutOrchestra Stereo
o20 :: TutOrchestra Stereo
o18 :: TutOrchestra Stereo
o17 :: TutOrchestra Stereo
o16 :: TutOrchestra Stereo
o12 :: TutOrchestra Stereo
o11 :: TutOrchestra Stereo
o10 :: TutOrchestra Stereo
o6 :: TutOrchestra Stereo
tut1 :: (Name, T, TutOrchestra Mono)
tut22 :: (Name, T, TutOrchestra Mono)
tut19 :: (Name, T, TutOrchestra Mono)
tut15 :: (Name, T, TutOrchestra Mono)
tut14 :: (Name, T, TutOrchestra Mono)
tut13 :: (Name, T, TutOrchestra Mono)
tut9 :: (Name, T, TutOrchestra Mono)
tut8 :: (Name, T, TutOrchestra Mono)
tut7 :: (Name, T, TutOrchestra Mono)
tut4 :: (Name, T, TutOrchestra Mono)
tut3 :: (Name, T, TutOrchestra Mono)
tut2 :: (Name, T, TutOrchestra Mono)
tut5 :: (Name, T, TutOrchestra Stereo)
tut21 :: (Name, T, TutOrchestra Stereo)
tut20 :: (Name, T, TutOrchestra Stereo)
tut18 :: (Name, T, TutOrchestra Stereo)
tut17 :: (Name, T, TutOrchestra Stereo)
tut16 :: (Name, T, TutOrchestra Stereo)
tut12 :: (Name, T, TutOrchestra Stereo)
tut11 :: (Name, T, TutOrchestra Stereo)
tut10 :: (Name, T, TutOrchestra Stereo)
tut6 :: (Name, T, TutOrchestra Stereo)
score1 :: TutOrchestra out -> [Statement]
score9 :: TutOrchestra out -> [Statement]
score8 :: TutOrchestra out -> [Statement]
score7 :: TutOrchestra out -> [Statement]
score6 :: TutOrchestra out -> [Statement]
score5 :: TutOrchestra out -> [Statement]
score4 :: TutOrchestra out -> [Statement]
score3 :: TutOrchestra out -> [Statement]
score2 :: TutOrchestra out -> [Statement]
csoundDir :: Name
twoHarmsTN :: Table
twoHarms :: Statement
oe2 :: InstrumentSigExp Mono
manySinesTN :: Table
manySinesTable :: SigExp
manySines :: Statement
lineCS :: EvalRate -> SigExp -> SigExp -> SigExp -> SigExp
oe3 :: InstrumentSigExp Mono
oe4 :: InstrumentSigExp Mono
coolEnvTN :: Table
coolEnvTable :: SigExp
coolEnv :: Statement
oscCoolEnv :: SigExp -> SigExp -> SigExp
tune2 :: TutMelody Pair
triangleTN :: Table
sawtoothTN :: Table
squareTN :: Table
triangleT :: Statement
sawtoothT :: Statement
squareT :: Statement
oe5 :: SigExp -> SigExp -> InstrumentSigExp Stereo
oe6 :: InstrumentSigExp Stereo
oe7 :: InstrumentSigExp Stereo
oe8 :: InstrumentSigExp Mono
oe9 :: InstrumentSigExp Mono
oe10 :: InstrumentSigExp Mono
oe11 :: SigExp -> SigExp -> SigExp -> SigExp -> InstrumentSigExp Stereo
emChord :: Float -> Float -> Float -> Float -> TutMelody Quadruple
dChord :: Float -> Float -> Float -> Float -> TutMelody Quadruple
gChord :: Float -> Float -> Float -> Float -> TutMelody Quadruple
cChord :: Float -> Float -> Float -> Float -> TutMelody Quadruple
quickChord :: [Dur -> TutAttr Quadruple -> TutMelody Quadruple] -> Float -> Float -> Float -> Float -> TutMelody Quadruple
tune3 :: TutMelody Quadruple
oe12 :: SigExp -> SigExp -> SigExp -> SigExp -> InstrumentSigExp Stereo
oe13 :: SigExp -> SigExp -> SigExp -> SigExp -> InstrumentSigExp Stereo
oe14 :: InstrumentSigExp Mono
oe15 :: InstrumentSigExp Mono
oe16 :: InstrumentSigExp Mono
midHumpTN :: Table
midHump :: Statement
oe17 :: InstrumentSigExp Stereo
ping :: SigExp -> SigExp -> SigExp
oe18 :: InstrumentSigExp Stereo
oe19 :: InstrumentSigExp Stereo
oe20 :: InstrumentSigExp Mono
oe21 :: SigExp -> SigExp -> SigExp -> SigExp -> InstrumentSigExp Stereo
lowPass :: EvalRate -> SigExp -> SigExp -> SigExp
highPass :: EvalRate -> SigExp -> SigExp -> SigExp
oe22 :: InstrumentSigExp Stereo
oe23 :: InstrumentSigExp Mono
test :: Output out => (Name, T, TutOrchestra out) -> IO ExitCode
toOrchestra :: Output out => TutOrchestra out -> T out
play :: Output out => FilePath -> (Name, T, TutOrchestra out) -> IO ExitCode
piano :: (Name, T, TutOrchestra Mono)
flute :: (Name, T, TutOrchestra Mono)
reedy :: (Name, T, TutOrchestra Mono)
pianoOrc :: TutOrchestra Mono
fluteOrc :: TutOrchestra Mono
reedyOrc :: TutOrchestra Mono
pianoScore :: TutOrchestra out -> T
fluteScore :: TutOrchestra out -> T
reedyScore :: TutOrchestra out -> T
pianoEnv :: Statement
fluteWave :: Statement
reedyWave :: Statement
pianoWave :: Statement
fluteEnv :: Statement
reedyEnv :: Statement
pianoEnvTN :: Table
fluteWaveTN :: Table
reedyWaveTN :: Table
pianoWaveTN :: Table
fluteEnvTN :: Table
reedyEnvTN :: Table
pianoEnvTable :: SigExp
fluteWaveTable :: SigExp
reedyWaveTable :: SigExp
pianoWaveTable :: SigExp
fluteEnvTable :: SigExp
reedyEnvTable :: SigExp
pianoOE :: InstrumentSigExp Mono
reedyOE :: InstrumentSigExp Mono
reedy2OE :: InstrumentSigExp Stereo
reedy2Orc :: TutOrchestra Stereo
reedy2 :: (Name, T, TutOrchestra Stereo)
fluteTune :: TutMelody Pair
fluteOE :: SigExp -> SigExp -> InstrumentSigExp Mono
voice' :: SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp
data Phoneme
Eee :: Phoneme
Ihh :: Phoneme
Ehh :: Phoneme
Aaa :: Phoneme
Ahh :: Phoneme
Aww :: Phoneme
Ohh :: Phoneme
Uhh :: Phoneme
Uuu :: Phoneme
Ooo :: Phoneme
Rrr :: Phoneme
Lll :: Phoneme
Mmm :: Phoneme
Nnn :: Phoneme
Nng :: Phoneme
Ngg :: Phoneme
Fff :: Phoneme
Sss :: Phoneme
Thh :: Phoneme
Shh :: Phoneme
Xxx :: Phoneme
Hee :: Phoneme
Hoo :: Phoneme
Hah :: Phoneme
Bbb :: Phoneme
Ddd :: Phoneme
Jjj :: Phoneme
Ggg :: Phoneme
Vvv :: Phoneme
Zzz :: Phoneme
Thz :: Phoneme
Zhh :: Phoneme
voiceTune :: TutMelody Pair
voiceVibWaveTN :: Table
voiceWaveTN :: Table
voiceVibWaveTable :: SigExp
voiceWaveTable :: SigExp
voiceWave :: Statement
voiceVibWave :: Statement
voiceScore :: TutOrchestra out -> T
voiceOE :: SigExp -> SigExp -> InstrumentSigExp Mono
voiceOrc :: TutOrchestra Mono
voice :: (Name, T, TutOrchestra Mono)
instance Eq Instrument
instance Ord Instrument
instance Show Instrument
instance Show Phoneme
instance Eq Phoneme
instance Ord Phoneme
instance Enum Phoneme

module Haskore.Interface.CSound.TutorialCustom
lineCS :: EvalRate -> SigExp -> SigExp -> SigExp -> SigExp
pureToneTN :: Table
pureToneTable :: SigExp
pureTone :: Statement
oscPure :: SigExp -> SigExp -> SigExp
type TutMelody params = T (TutAttr params)
data TutAttr params
TutAttr :: Rational -> params -> TutAttr params
attrVelocity :: TutAttr params -> Rational
attrParameters :: TutAttr params -> params
tune1 :: TutMelody ()
data Instrument
Instr1p0 :: Instrument
Instr2p0 :: Instrument
Instr1p2 :: Float -> Float -> Instrument
Instr1p4 :: Float -> Float -> Float -> Float -> Instrument
musicFromMelody :: (params -> Instrument) -> TutMelody params -> T () Instrument
type Pair = (Float, Float)
type Quadruple = (Float, Float, Float, Float)
attrToInstr1p0 :: () -> Instrument
attrToInstr2p0 :: () -> Instrument
attrToInstr1p2 :: Pair -> Instrument
attrToInstr1p4 :: Quadruple -> Instrument
performanceFromMusic :: T () Instrument -> T Float Float (Note () Instrument)
instrNum1 :: Instrument
instrNum2 :: Instrument
instrToNum :: Instrument -> ([PField], Instrument)
scoreFromPerformance :: TutOrchestra out -> T Float Float (Note () Instrument) -> T
data OutFunc out
OutFunc0 :: out -> OutFunc out
OutFunc2 :: (SigExp -> SigExp -> out) -> OutFunc out
OutFunc4 :: (SigExp -> SigExp -> SigExp -> SigExp -> out) -> OutFunc out
type TutOrchestra out = (Header, [(Instrument, OutFunc out)])
matchInstrOutFunc :: Instrument -> OutFunc out -> Bool
scoreFromPerformanceSafe :: TutOrchestra out -> T Float Float (Note () Instrument) -> T
scored :: TutOrchestra out -> (params -> Instrument) -> TutMelody params -> T
example :: Name -> (TutOrchestra out -> T) -> TutOrchestra out -> (Name, T, TutOrchestra out)
oe1 :: Mono
hdr :: Header
o1 :: TutOrchestra Mono
o22 :: TutOrchestra Mono
o19 :: TutOrchestra Mono
o15 :: TutOrchestra Mono
o14 :: TutOrchestra Mono
o13 :: TutOrchestra Mono
o9 :: TutOrchestra Mono
o8 :: TutOrchestra Mono
o7 :: TutOrchestra Mono
o4 :: TutOrchestra Mono
o3 :: TutOrchestra Mono
o2 :: TutOrchestra Mono
o5 :: TutOrchestra Stereo
o21 :: TutOrchestra Stereo
o20 :: TutOrchestra Stereo
o18 :: TutOrchestra Stereo
o17 :: TutOrchestra Stereo
o16 :: TutOrchestra Stereo
o12 :: TutOrchestra Stereo
o11 :: TutOrchestra Stereo
o10 :: TutOrchestra Stereo
o6 :: TutOrchestra Stereo
tut1 :: (Name, T, TutOrchestra Mono)
tut22 :: (Name, T, TutOrchestra Mono)
tut19 :: (Name, T, TutOrchestra Mono)
tut15 :: (Name, T, TutOrchestra Mono)
tut14 :: (Name, T, TutOrchestra Mono)
tut13 :: (Name, T, TutOrchestra Mono)
tut9 :: (Name, T, TutOrchestra Mono)
tut8 :: (Name, T, TutOrchestra Mono)
tut7 :: (Name, T, TutOrchestra Mono)
tut4 :: (Name, T, TutOrchestra Mono)
tut3 :: (Name, T, TutOrchestra Mono)
tut2 :: (Name, T, TutOrchestra Mono)
tut5 :: (Name, T, TutOrchestra Stereo)
tut21 :: (Name, T, TutOrchestra Stereo)
tut20 :: (Name, T, TutOrchestra Stereo)
tut18 :: (Name, T, TutOrchestra Stereo)
tut17 :: (Name, T, TutOrchestra Stereo)
tut16 :: (Name, T, TutOrchestra Stereo)
tut12 :: (Name, T, TutOrchestra Stereo)
tut11 :: (Name, T, TutOrchestra Stereo)
tut10 :: (Name, T, TutOrchestra Stereo)
tut6 :: (Name, T, TutOrchestra Stereo)
score1 :: TutOrchestra out -> [Statement]
score9 :: TutOrchestra out -> [Statement]
score8 :: TutOrchestra out -> [Statement]
score7 :: TutOrchestra out -> [Statement]
score6 :: TutOrchestra out -> [Statement]
score5 :: TutOrchestra out -> [Statement]
score4 :: TutOrchestra out -> [Statement]
score3 :: TutOrchestra out -> [Statement]
score2 :: TutOrchestra out -> [Statement]
csoundDir :: Name
twoHarmsTN :: Table
twoHarms :: Statement
oe2 :: Mono
manySinesTN :: Table
manySinesTable :: SigExp
manySines :: Statement
oe3 :: Mono
oe4 :: Mono
coolEnvTN :: Table
coolEnvTable :: SigExp
coolEnv :: Statement
oscCoolEnv :: SigExp -> SigExp -> SigExp
tune2 :: TutMelody Pair
triangleTN :: Table
sawtoothTN :: Table
squareTN :: Table
triangleT :: Statement
sawtoothT :: Statement
squareT :: Statement
oe5 :: SigExp -> SigExp -> Stereo
oe6 :: Stereo
oe7 :: Stereo
oe8 :: Mono
oe9 :: Mono
oe10 :: Mono
oe11 :: SigExp -> SigExp -> SigExp -> SigExp -> Stereo
emChord :: Float -> Float -> Float -> Float -> TutMelody Quadruple
dChord :: Float -> Float -> Float -> Float -> TutMelody Quadruple
gChord :: Float -> Float -> Float -> Float -> TutMelody Quadruple
cChord :: Float -> Float -> Float -> Float -> TutMelody Quadruple
quickChord :: [Dur -> TutAttr Quadruple -> TutMelody Quadruple] -> Float -> Float -> Float -> Float -> TutMelody Quadruple
tune3 :: TutMelody Quadruple
oe12 :: SigExp -> SigExp -> SigExp -> SigExp -> Stereo
oe13 :: SigExp -> SigExp -> SigExp -> SigExp -> Stereo
oe14 :: Mono
oe15 :: Mono
oe16 :: Mono
midHumpTN :: Table
midHump :: Statement
oe17 :: Stereo
ping :: SigExp
oe18 :: Stereo
oe19 :: Stereo
oe20 :: Mono
oe21 :: SigExp -> SigExp -> SigExp -> SigExp -> Stereo
lowPass :: EvalRate -> SigExp -> SigExp -> SigExp
highPass :: EvalRate -> SigExp -> SigExp -> SigExp
oe22 :: Stereo
oe23 :: Mono
test :: Output out => (Name, T, TutOrchestra out) -> IO ExitCode
applyOutFunc :: OutFunc out -> out
toOrchestra :: Output out => TutOrchestra out -> T out
play :: Output out => FilePath -> (Name, T, TutOrchestra out) -> IO ExitCode
piano :: (Name, T, TutOrchestra Mono)
flute :: (Name, T, TutOrchestra Mono)
reedy :: (Name, T, TutOrchestra Mono)
pianoOrc :: TutOrchestra Mono
fluteOrc :: TutOrchestra Mono
reedyOrc :: TutOrchestra Mono
pianoScore :: TutOrchestra out -> T
fluteScore :: TutOrchestra out -> T
reedyScore :: TutOrchestra out -> T
pianoEnv :: Statement
fluteWave :: Statement
reedyWave :: Statement
pianoWave :: Statement
fluteEnv :: Statement
reedyEnv :: Statement
pianoEnvTN :: Table
fluteWaveTN :: Table
reedyWaveTN :: Table
pianoWaveTN :: Table
fluteEnvTN :: Table
reedyEnvTN :: Table
pianoEnvTable :: SigExp
fluteWaveTable :: SigExp
reedyWaveTable :: SigExp
pianoWaveTable :: SigExp
fluteEnvTable :: SigExp
reedyEnvTable :: SigExp
pianoOE :: Mono
reedyOE :: Mono
reedy2OE :: Stereo
reedy2Orc :: TutOrchestra Stereo
reedy2 :: (Name, T, TutOrchestra Stereo)
fluteTune :: TutMelody Pair
fluteOE :: SigExp -> SigExp -> Mono
voice' :: SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp -> SigExp
data Phoneme
Eee :: Phoneme
Ihh :: Phoneme
Ehh :: Phoneme
Aaa :: Phoneme
Ahh :: Phoneme
Aww :: Phoneme
Ohh :: Phoneme
Uhh :: Phoneme
Uuu :: Phoneme
Ooo :: Phoneme
Rrr :: Phoneme
Lll :: Phoneme
Mmm :: Phoneme
Nnn :: Phoneme
Nng :: Phoneme
Ngg :: Phoneme
Fff :: Phoneme
Sss :: Phoneme
Thh :: Phoneme
Shh :: Phoneme
Xxx :: Phoneme
Hee :: Phoneme
Hoo :: Phoneme
Hah :: Phoneme
Bbb :: Phoneme
Ddd :: Phoneme
Jjj :: Phoneme
Ggg :: Phoneme
Vvv :: Phoneme
Zzz :: Phoneme
Thz :: Phoneme
Zhh :: Phoneme
voiceTune :: TutMelody Pair
voiceVibWaveTN :: Table
voiceWaveTN :: Table
voiceVibWaveTable :: SigExp
voiceWaveTable :: SigExp
voiceWave :: Statement
voiceVibWave :: Statement
voiceScore :: TutOrchestra out -> T
voiceOE :: SigExp -> SigExp -> Mono
voiceOrc :: TutOrchestra Mono
voice :: (Name, T, TutOrchestra Mono)
instance Eq Instrument
instance Ord Instrument
instance Show Instrument
instance Show Phoneme
instance Eq Phoneme
instance Ord Phoneme
instance Enum Phoneme
