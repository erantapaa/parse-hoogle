-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Web framework
@package HAppS-IxSet
@version 0.9.3

module HAppS.Data.IxSet.Ix
data Ix a
IxDefault :: Ix a
Ix :: (Map key (Set a)) -> Ix a
con_Ix_Data :: Constr
ixType_Data :: DataType
ixDefaultConstr :: Constr
ixConstr :: Constr
ixDataType :: DataType
insert :: (Ord a, Ord k) => k -> a -> Map k (Set a) -> Map k (Set a)
delete :: (Ord a, Ord k) => k -> a -> Map k (Set a) -> Map k (Set a)
instance [overlap ok] Typeable1 Ix
instance [overlap ok] (Data ctx a, Sat (ctx (Ix a))) => Data ctx (Ix a)
instance [overlap ok] (Default a) => Default (Ix a)
instance [overlap ok] (Data a) => Data (Ix a)

module HAppS.Data.IxSet
data IxSet a
ISet :: [a] -> IxSet a
IxSet :: [Ix a] -> IxSet a
iSetConstr :: Constr
ixSetConstr :: Constr
ixSetDataType :: DataType
class (Data b) => Indexable a b | a -> b
empty :: (Indexable a b) => IxSet a
calcs :: (Indexable a b) => a -> b
inferIxSet :: String -> Name -> Name -> [Name] -> Q [Dec]
flatten :: (Typeable a, Data a) => a -> [Dynamic]
type IndexOp = forall k a. (Ord k, Ord a) => k -> a -> Map k (Set a) -> Map k (Set a)
change :: (Data a, Ord a, Data b, Indexable a b) => IndexOp -> a -> IxSet a -> IxSet a
insert :: (Data a, Ord a, Data b, Indexable a b) => a -> IxSet a -> IxSet a
delete :: (Data a, Ord a, Data b, Indexable a b) => a -> IxSet a -> IxSet a
updateIx :: (Indexable a b, Ord a, Data a, Typeable k) => k -> a -> IxSet a -> IxSet a
toSet :: (Ord a) => IxSet a -> Set a
toSet' :: (Ord a) => [Ix a] -> Set a
fromSet :: (Indexable a b, Ord a, Data a) => Set a -> IxSet a
fromSet' :: (Indexable a b, Ord a, Data a) => Set a -> IxSet a
fromList :: (Indexable a b, Ord a, Data a) => [a] -> IxSet a
size :: (Ord a) => IxSet a -> Int
toList :: (Ord a) => IxSet a -> [a]
toList' :: (Ord a) => [Ix a] -> [a]
getOne :: (Ord a) => IxSet a -> Maybe a
getOneOr :: (Ord a) => a -> IxSet a -> a
(&&&) :: (Ord a, Data a, Indexable a b) => IxSet a -> IxSet a -> IxSet a
(|||) :: (Ord a, Data a, Indexable a b) => IxSet a -> IxSet a -> IxSet a
union :: (Ord a, Data a, Indexable a b) => IxSet a -> IxSet a -> IxSet a
intersection :: (Ord a, Data a, Indexable a b) => IxSet a -> IxSet a -> IxSet a
(@<) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> k -> IxSet a
(@>) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> k -> IxSet a
(@<=) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> k -> IxSet a
(@>=) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> k -> IxSet a
(@=) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> k -> IxSet a
(@>=<) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> (k, k) -> IxSet a
(@><=) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> (k, k) -> IxSet a
(@>=<=) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> (k, k) -> IxSet a
(@><) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> (k, k) -> IxSet a
(@*) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> [k] -> IxSet a
(@+) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> [k] -> IxSet a
getEQ :: (Indexable a b, Data a, Ord a, Typeable k) => k -> IxSet a -> IxSet a
getLT :: (Indexable a b, Data a, Ord a, Typeable k) => k -> IxSet a -> IxSet a
getGT :: (Indexable a b, Data a, Ord a, Typeable k) => k -> IxSet a -> IxSet a
getLTE :: (Indexable a b, Data a, Ord a, Typeable k) => k -> IxSet a -> IxSet a
getGTE :: (Indexable a b, Data a, Ord a, Typeable k) => k -> IxSet a -> IxSet a
getRange :: (Indexable a b, Typeable k, Ord a, Data a) => k -> k -> IxSet a -> IxSet a
groupBy :: (Typeable k, Typeable t) => IxSet t -> [(k, [t])]
getOrd :: (Indexable a b, Ord a, Data a, Typeable k) => Ordering -> k -> IxSet a -> IxSet a
instance [overlap ok] Typeable1 IxSet
instance [overlap ok] (Data a) => Data (IxSet a)
instance [overlap ok] (Show a, Indexable a b, Data a, Ord a) => Monoid (IxSet a)
instance [overlap ok] (Ord a, Read a, Data a, Indexable a b) => Read (IxSet a)
instance [overlap ok] (Ord a, Show a) => Show (IxSet a)
instance [overlap ok] (Indexable a b, Data a, Ord a, Default a) => Default (IxSet a)
instance [overlap ok] (Data ctx a, Sat (ctx (IxSet a)), Sat (ctx [a]), Indexable a b, Data a, Ord a) => Data ctx (IxSet a)
instance [overlap ok] (Serialize a, Ord a, Data a, Indexable a b) => Serialize (IxSet a)
instance [overlap ok] Version (IxSet a)

module HAppS.Data.IxSet.Usage
data Test
Test :: String -> Int -> Test
t2 :: Test
t3 :: Test
t1 :: Test
c2 :: IxSet Test
c3 :: IxSet Test
c4 :: IxSet Test
c1 :: IxSet Test
s2 :: IxSet Test
s3 :: IxSet Test
s4 :: IxSet Test
s5 :: IxSet Test
s6 :: IxSet Test
s7 :: IxSet Test
s8 :: IxSet Test
s1 :: IxSet Test
instance [overlap ok] Typeable Test
instance [overlap ok] Data Test
instance [overlap ok] Eq Test
instance [overlap ok] Ord Test
instance [overlap ok] Show Test
instance [overlap ok] Read Test
instance [overlap ok] Indexable Test String
