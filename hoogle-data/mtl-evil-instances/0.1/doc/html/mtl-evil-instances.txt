-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Instances for the mtl classes for all monad transformers.
--   
--   WARNING: THIS PACKAGE IS EVIL. DO NOT USE IT!
--   
--   It is common when defining a monad transformer to define instances for
--   that transformer for each class in the <tt>mtl</tt> library, to allow
--   easy composition with the existing standard monad transformers.
--   However, doing this is very tedious, and actually unnecessary, given
--   that most of these instances across different transformers are
--   identical, and can actually be expressed purely in terms of
--   <tt>MonadTrans</tt>, or <tt>MonadTransControl</tt> (from the
--   <tt>monad-control</tt> package) for the more complicated classes.
--   
--   The reason this is not generally done is because it requires the
--   <tt>OverlappingInstances</tt> extension, which is generally considered
--   evil. However, it does actually work. If you define a monad
--   transformer, and instances for <tt>MonadTrans</tt> and
--   <tt>MonadTransControl</tt>, and import
--   <a>Control.Monad.Instances.Overlapping</a>, your monad transformer
--   will magically have sensible instances for all the <tt>mtl</tt> type
--   classes. And if you don't like one of the instances provided, you can
--   always define your own instance, which will override the "default" one
--   provided by this package, because by the rules for
--   <tt>OverlappingInstances</tt>, your instance is more "specific" than
--   the one exported by <a>Control.Monad.Instances.Overlapping</a>.
--   
--   The main disadvantage of this is that errors in code using
--   <tt>OverlappingInstances</tt> can result in some really strange error
--   messages that are not very helpful. The reason this is evil is because
--   this places an additional burden (of dealing with confusing error
--   messages) not just on those who use this package directly, but anybody
--   who indirectly uses any code that, somewhere down the line, imported
--   <a>Control.Monad.Instances.Overlapping</a>, due to the "viral" nature
--   of instances. Also, if another person were to make a package very
--   similar to this one, and somebody ended up importing both code that
--   used this package, and code that used the other package, than neither
--   of them would work anymore. This is the problem with orphan instances.
--   
--   If you absolutely insist on using this code, you should probably
--   define manual instances for the <tt>mtl</tt> classes the hard way as
--   well, to avoid this kind of breakage (thus defeating the purpose of
--   this package). Of course, realistically, this package is for everyone
--   who wishes to ignore all such advice and do bad things anyway
--   (including myself). This is my gift to you!
@package mtl-evil-instances
@version 0.1


-- | This module exports several very overlapping instances for the type
--   classes defined in the <tt>mtl</tt> library, and should be used with
--   caution, or not at all (see the package description). The instances
--   are defined:
--   
--   <ul>
--   <li><pre>instance (<a>MonadTrans</a> t, <a>Monad</a> (t m),
--   <a>MonadBase</a> b m) =&gt; <a>MonadBase</a> b (t m)</pre></li>
--   <li><pre>instance (<a>MonadTransControl</a> t, <a>Monad</a> (t m),
--   <a>MonadCont</a> m) =&gt; <a>MonadCont</a> (t m)</pre></li>
--   <li><pre>instance (<a>MonadTransControl</a> t, <a>Monad</a> (t m),
--   <a>MonadError</a> e m) =&gt; <a>MonadError</a> e (t m)</pre></li>
--   <li><pre>instance (<a>MonadTransControl</a> t, <a>Monad</a> (t m),
--   <a>MonadFix</a> m) =&gt; <a>MonadFix</a> (t m)</pre></li>
--   <li><pre>instance (<a>MonadTrans</a> t, <a>Monad</a> (t m),
--   <a>MonadIO</a> m) =&gt; <a>MonadIO</a> (t m)</pre></li>
--   <li><pre>instance (<a>MonadTrans</a> t, <a>Monad</a> (t m),
--   <a>MonadReader</a> r m) =&gt; <a>MonadReader</a> r (t m)</pre></li>
--   <li><pre>instance (<a>MonadTrans</a> t, <a>Monad</a> (t m),
--   <a>MonadRWS</a> r w s m) =&gt; <a>MonadRWS</a> r w s (t m)</pre></li>
--   <li><pre>instance (<a>MonadTrans</a> t, <a>Monad</a> (t m),
--   <a>MonadState</a> s m) =&gt; <a>MonadState</a> s (t m)</pre></li>
--   <li><pre>instance (<a>MonadTrans</a> t, <a>Monad</a> (t m),
--   <a>MonadWriter</a> w m) =&gt; <a>MonadWriter</a> w (t m)</pre></li>
--   <li><pre>instance (<a>MonadBaseControl</a> b m, <a>MonadCont</a> b)
--   =&gt; <a>MonadCont</a> m</pre></li>
--   <li><pre>instance (<a>MonadBaseControl</a> b m, <a>MonadError</a> e b)
--   =&gt; <a>MonadError</a> e m</pre></li>
--   <li><pre>instance (<a>MonadBaseControl</a> b m, <a>MonadFix</a> b)
--   =&gt; <a>MonadFix</a> m</pre></li>
--   <li><pre>instance (<a>MonadBase</a> b m, <a>MonadIO</a> b) =&gt;
--   <a>MonadIO</a> m</pre></li>
--   <li><pre>instance (<a>MonadBase</a> b m, <a>MonadReader</a> r b) =&gt;
--   <a>MonadReader</a> r m</pre></li>
--   <li><pre>instance (<a>MonadBase</a> b m, <a>MonadRWS</a> r w s b)
--   =&gt; <a>MonadRWS</a> r w s m</pre></li>
--   <li><pre>instance (<a>MonadBase</a> b m, <a>MonadState</a> s b) =&gt;
--   <a>MonadState</a> s m</pre></li>
--   <li><pre>instance (<a>MonadBase</a> b m, <a>MonadWriter</a> w b) =&gt;
--   <a>MonadWriter</a> w m</pre></li>
--   </ul>
--   
--   Note that the following instance is not included, as currently it
--   cannot be due to GHC bug #4259:
--   
--   <ul>
--   <li><pre>instance (<a>MonadTransControl</a> t, <a>Monad</a> (t m),
--   <a>MonadBaseControl</a> b m) =&gt; <a>MonadBaseControl</a> b (t
--   m)</pre></li>
--   </ul>
module Control.Monad.Instances.Evil
instance [overlap ok] (MonadBase b m, MonadWriter w b) => MonadWriter w m
instance [overlap ok] (MonadTrans t, Monad (t m), MonadWriter w m) => MonadWriter w (t m)
instance [overlap ok] (MonadBase b m, MonadState s b) => MonadState s m
instance [overlap ok] (MonadTrans t, Monad (t m), MonadState s m) => MonadState s (t m)
instance [overlap ok] (MonadBase b m, MonadRWS r w s b) => MonadRWS r w s m
instance [overlap ok] (MonadTrans t, Monad (t m), MonadRWS r w s m) => MonadRWS r w s (t m)
instance [overlap ok] (MonadBase b m, MonadReader r b) => MonadReader r m
instance [overlap ok] (MonadTrans t, Monad (t m), MonadReader r m) => MonadReader r (t m)
instance [overlap ok] (MonadBase b m, MonadIO b) => MonadIO m
instance [overlap ok] (MonadTrans t, Monad (t m), MonadIO m) => MonadIO (t m)
instance [overlap ok] (MonadBaseControl b m, MonadFix b) => MonadFix m
instance [overlap ok] (MonadTransControl t, Monad (t m), MonadFix m) => MonadFix (t m)
instance [overlap ok] (MonadBaseControl b m, MonadError e b) => MonadError e m
instance [overlap ok] (MonadTransControl t, Monad (t m), MonadError e m) => MonadError e (t m)
instance [overlap ok] (MonadBaseControl b m, MonadCont b) => MonadCont m
instance [overlap ok] (MonadTransControl t, Monad (t m), MonadCont m) => MonadCont (t m)
instance [overlap ok] (MonadTrans t, Applicative (t m), Monad (t m), MonadBase b m) => MonadBase b (t m)
