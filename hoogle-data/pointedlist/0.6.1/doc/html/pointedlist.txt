-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A zipper-like comonad which works as a list, tracking a position.
--   
--   A PointedList tracks the position in a non-empty list which works
--   similarly to a zipper. A current item is always required, and
--   therefore the list may never be empty. A circular PointedList wraps
--   around to the other end when progressing past the actual edge.
@package pointedlist
@version 0.6.1


-- | An implementation of a zipper-like non-empty list structure that
--   tracks an index position in the list (the <a>focus</a>).
module Data.List.PointedList

-- | The implementation of the pointed list structure which tracks the
--   current position in the list structure.
data PointedList a
PointedList :: [a] -> a -> [a] -> PointedList a
_reversedPrefix :: PointedList a -> [a]
_focus :: PointedList a -> a
_suffix :: PointedList a -> [a]

-- | Lens compatible with Control.Lens.
reversedPrefix :: Functor f => ([a] -> f [a]) -> PointedList a -> f (PointedList a)

-- | Lens compatible with Control.Lens.
focus :: Functor f => (a -> f a) -> PointedList a -> f (PointedList a)

-- | Lens compatible with Control.Lens.
suffix :: Functor f => ([a] -> f [a]) -> PointedList a -> f (PointedList a)

-- | Lens compatible with Control.Lens. Internally reversing the prefix
--   list.
prefix :: Functor f => ([a] -> f [a]) -> PointedList a -> f (PointedList a)

-- | Create a <a>PointedList</a> with a single element.
singleton :: a -> PointedList a

-- | Possibly create a <tt><a>Just</a> <a>PointedList</a></tt> if the
--   provided list has at least one element; otherwise, return Nothing.
--   
--   The provided list's head will be the focus of the list, and the rest
--   of list will follow on the right side.
fromList :: [a] -> Maybe (PointedList a)

-- | Possibly create a <tt><a>Just</a> <a>PointedList</a></tt> if the
--   provided list has at least one element; otherwise, return Nothing.
--   
--   The provided list's last element will be the focus of the list,
--   following the rest of the list in order, to the left.
fromListEnd :: [a] -> Maybe (PointedList a)

-- | Replace the focus of the list, retaining the prefix and suffix.
replace :: a -> PointedList a -> PointedList a

-- | Possibly move the focus to the next element in the list.
next :: PointedList a -> Maybe (PointedList a)

-- | Attempt to move the focus to the next element, or <a>error</a> if
--   there are no more elements.
tryNext :: PointedList a -> PointedList a

-- | Possibly move the focus to the previous element in the list.
previous :: PointedList a -> Maybe (PointedList a)

-- | Attempt to move the focus to the previous element, or <a>error</a> if
--   there are no more elements.
tryPrevious :: PointedList a -> PointedList a

-- | An alias for <a>insertRight</a>.
insert :: a -> PointedList a -> PointedList a

-- | Insert an element to the left of the focus, then move the focus to the
--   new element.
insertLeft :: a -> PointedList a -> PointedList a

-- | Insert an element to the right of the focus, then move the focus to
--   the new element.
insertRight :: a -> PointedList a -> PointedList a

-- | An alias of <a>deleteRight</a>.
delete :: PointedList a -> Maybe (PointedList a)

-- | Possibly delete the element at the focus, then move the element on the
--   left to the focus. If no element is on the left, focus on the element
--   to the right. If the deletion will cause the list to be empty, return
--   <a>Nothing</a>.
deleteLeft :: PointedList a -> Maybe (PointedList a)

-- | Possibly delete the element at the focus, then move the element on the
--   right to the focus. If no element is on the right, focus on the
--   element to the left. If the deletion will cause the list to be empty,
--   return <a>Nothing</a>.
deleteRight :: PointedList a -> Maybe (PointedList a)

-- | Delete all elements in the list except the focus.
deleteOthers :: PointedList a -> PointedList a

-- | The length of the list.
length :: PointedList a -> Int

-- | Whether the focus is the first element.
atStart :: PointedList a -> Bool

-- | Whether the focus is the last element.
atEnd :: PointedList a -> Bool

-- | Create a <a>PointedList</a> of variations of the provided
--   <a>PointedList</a>, in which each element is focused, with the
--   provided <a>PointedList</a> as the focus of the sets.
positions :: PointedList a -> PointedList (PointedList a)

-- | Map over the <a>PointedList</a>s created via <a>positions</a>, such
--   that <tt>f</tt> is called with each element of the list focused in the
--   provided <a>PointedList</a>. An example makes this easier to
--   understand:
--   
--   <pre>
--   contextMap atStart (fromJust $ fromList [1..5])
--   </pre>
contextMap :: (PointedList a -> b) -> PointedList a -> PointedList b

-- | Create a <tt><a>PointedList</a> a</tt> of <tt>(a, <a>Bool</a>)</tt>,
--   in which the boolean values specify whether the current element has
--   the focus. That is, all of the booleans will be <a>False</a>, except
--   the focused element.
withFocus :: PointedList a -> PointedList (a, Bool)

-- | Move the focus to the specified index. The first element is at index
--   0.
moveTo :: Int -> PointedList a -> Maybe (PointedList a)

-- | Move the focus by <tt>n</tt>, relative to the current index. Negative
--   values move the focus backwards, positive values more forwards through
--   the list.
moveN :: Int -> PointedList a -> Maybe (PointedList a)

-- | Move the focus to the specified element, if it is present.
--   
--   Patch with much faster algorithm provided by Runar Bjarnason for
--   version 0.3.2. Improved again by Runar Bjarnason for version 0.3.3 to
--   support infinite lists on both sides of the focus.
find :: Eq a => a -> PointedList a -> Maybe (PointedList a)

-- | The index of the focus, leftmost is 0.
index :: PointedList a -> Int
instance Eq a => Eq (PointedList a)
instance Traversable PointedList
instance Foldable PointedList
instance Functor PointedList
instance Show a => Show (PointedList a)
instance Binary a => Binary (PointedList a)

module Data.List.PointedList.Circular

-- | Move the focus to the next element in the list. If the last element is
--   currently focused, loop to the first element.
next :: PointedList a -> PointedList a

-- | Move the focus to the previous element in the list. If the first
--   element is currently focused, loop to the last element.
previous :: PointedList a -> PointedList a

-- | An alias of <a>deleteRight</a>.
delete :: PointedList a -> Maybe (PointedList a)

-- | Possibly delete the element at the focus, then move the element on the
--   left to the focus. If no element is on the left, focus on the element
--   to the right. If the deletion will cause the list to be empty, return
--   <tt>Nothing</tt>.
deleteLeft :: PointedList a -> Maybe (PointedList a)

-- | Possibly delete the element at the focus, then move the element on the
--   right to the focus. If no element is on the right, focus on the
--   element to the left. If the deletion will cause the list to be empty,
--   return <tt>Nothing</tt>.
deleteRight :: PointedList a -> Maybe (PointedList a)

-- | Move
moveN :: Int -> PointedList a -> PointedList a
