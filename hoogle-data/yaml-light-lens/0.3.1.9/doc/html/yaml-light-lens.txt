-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lens interface to yaml-light.
--   
@package yaml-light-lens
@version 0.3.1.9


-- | Lenses for working with YAML structures.
module Data.Yaml.YamlLight.Lens

-- | Lens into a sequence.
--   
--   <pre>
--   &gt;&gt;&gt; YSeq [YStr "a", YStr "b", YStr "c"] ^? nth 1
--   Just (YStr "b")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; YSeq [YStr "a", YStr "b", YStr "c"] &amp; nth 1 .~ YStr "B"
--   YSeq [YStr "a",YStr "B",YStr "c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; YSeq [YStr "a", YStr "b", YStr "c"] ^? nth 2 . _Yaml :: Maybe String
--   Just "c"
--   </pre>
nth :: Int -> Traversal' YamlLight YamlLight

-- | Lens into a mapping. <a>ByteString</a>s are used as keys directly. If
--   you wish to use a complex mapping key, see <a>key'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let m = YMap $ Map.fromList [(YStr "name", YStr "Tony Stark"), (YStr "sequels", YStr "2")]
--   
--   &gt;&gt;&gt; m &amp; key "sequels" . _Yaml +~ 1
--   YMap (fromList [(YStr "name",YStr "Tony Stark"),(YStr "sequels",YStr "3")])
--   </pre>
key :: ByteString -> Traversal' YamlLight YamlLight

-- | Lens into a mapping using a complex key.
key' :: YamlLight -> Traversal' YamlLight YamlLight

-- | Convert between YAML values and corresponding common Haskell values.
--   
--   <pre>
--   &gt;&gt;&gt; YStr "-2.3" ^? _Yaml :: Maybe Double
--   Just (-2.3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; YStr "7b.3" ^? _Yaml :: Maybe Double
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; YStr "-23" ^? _Yaml :: Maybe Int
--   Just (-23)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; YStr "Help, I'm trapped in a haddock factory!" ^? _Yaml :: Maybe String
--   Just "Help, I'm trapped in a haddock factory!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; YStr "An integer" ^? _Yaml :: Maybe Integer
--   Nothing
--   </pre>
--   
--   If we just want to pull out those values that were successfully
--   parsed,
--   
--   <pre>
--   &gt;&gt;&gt; let nums = YSeq [YStr "3", YStr "2a", YStr "1"]
--   
--   &gt;&gt;&gt; nums ^.. each._Yaml :: [Int]
--   [3,1]
--   </pre>
--   
--   Alternately, we may want to fail the entire parse if any element fails
--   to parse.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA $ map (preview _Yaml) (nums ^.. each) :: Maybe [Int]
--   Nothing
--   
--   &gt;&gt;&gt; let nums' = YSeq [YStr "3", YStr "2", YStr "1"]
--   
--   &gt;&gt;&gt; sequenceA $ map (preview _Yaml) (nums' ^.. each) :: Maybe [Int]
--   Just [3,2,1]
--   </pre>
_Yaml :: AsYaml a => Prism' YamlLight a

-- | Convert between YAML values and common types of Haskell values.
class AsYaml a
fromYaml :: AsYaml a => YamlLight -> Maybe a
toYaml :: AsYaml a => a -> YamlLight

-- | Try to parse an <a>Integral</a> value from a <a>YamlLight</a>.
yamlInt :: Integral b => YamlLight -> Maybe b

-- | Try to parse a <a>Double</a> from a <a>YamlLight</a>.
yamlReal :: YamlLight -> Maybe Double
instance AsYaml Bool
instance AsYaml Double
instance AsYaml Integer
instance AsYaml Int
instance AsYaml String
instance AsYaml ByteString
instance AsYaml [YamlLight]
instance AsYaml (Map YamlLight YamlLight)
instance Plated YamlLight
instance Each YamlLight YamlLight YamlLight YamlLight
instance At YamlLight
instance Ixed YamlLight
