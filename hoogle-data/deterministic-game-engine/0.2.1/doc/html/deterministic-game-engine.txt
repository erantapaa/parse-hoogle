-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple deterministic game engine
--   
@package deterministic-game-engine
@version 0.2.1


-- | Haskell library for creating simple deterministic games, such as
--   tic-tac-toe. The engine requires a minimal set of actions related to
--   the game, and then will run the game until a terminal state is
--   reached.
--   
--   Simple generic example below. See the specs for a more detailed
--   example.
--   
--   <pre>
--   import GameEngine
--   
--   game :: GameEngine Int Int
--   game = GameEngine gameActions initialState
--   
--   gameActions :: GameActions Int Int
--   gameActions = GameActions {
--      getPlayer  = -- find the next player from a game state,
--      getMove    = -- find a move from the game state,
--      getResult  = -- transitions from a state to another state,
--      isTerminal = -- determines if the game is terminal,
--      getScore   = -- get score from a terminal state
--    }
--   
--   initialState :: GameState Int
--   initialState = GameState 0
--   
--   -- run the game engine until a terminal state is reached
--   playSimple game
--   </pre>
module GameEngine
type Symbol = Char
data GameState a
GameState :: a -> GameState a
data Player
Player :: Symbol -> Player
data Move a
Move :: a -> Move a

-- | Set of actions that defines how the game will be played
data GameActions a b
GameActions :: (GameState a -> Player) -> (GameState a -> Move b) -> (GameState a -> Move b -> GameState a) -> (GameState a -> Bool) -> (GameState a -> Player -> Int) -> GameActions a b

-- | Specifies which player has the move in the state
getPlayer :: GameActions a b -> GameState a -> Player

-- | Returns a legal move in the state
getMove :: GameActions a b -> GameState a -> Move b

-- | The transition model, which determines the result of a move
getResult :: GameActions a b -> GameState a -> Move b -> GameState a

-- | True if game is over, False otherwise
isTerminal :: GameActions a b -> GameState a -> Bool

-- | A utility function to determine the numeric value for a game that ends
--   in a terminal state
getScore :: GameActions a b -> GameState a -> Player -> Int

-- | Holds information about how the game is played, and the current state
--   of the game.
data GameEngine a b
GameEngine :: GameActions a b -> GameState a -> GameEngine a b

-- | Defines how the game will be played
actions :: GameEngine a b -> GameActions a b

-- | The current state of the game
state :: GameEngine a b -> GameState a

-- | Run the provided game engine under a monadic context until a terminal
--   state is reached. Note: provided function should act as an identity
--   only, and should not modify the game state.
play :: Monad m => (GameState a -> m (GameState a)) -> GameEngine a b -> m Int

-- | Run the provided game engine without a context until a terminal state
--   is reached.
playSimple :: GameEngine a b -> Int

-- | Run the provided game engine within an IO context until a terminal
--   state is reached.
playIO :: (GameState a -> IO ()) -> GameEngine a b -> IO Int
