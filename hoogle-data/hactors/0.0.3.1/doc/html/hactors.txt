-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Practical actors for Haskell.
--   
--   This library is about to implement the Erlang-like actor model on top
--   of the GHC's concurrency.
@package hactors
@version 0.0.3.1


-- | Implementation of the actor model on top of the GHC's concurrency.
--   
--   The API mimics Erlang's concurrency primitives, with slight
--   differences.
module Control.Concurrent.Actor

-- | The process is a VM's thread.
type Process = ThreadId

-- | Get the current process.
self :: IO Process

-- | Kill the process.
kill :: IO Process -> IO ()

-- | Finish the current process.
exit :: IO ()

-- | Perform non busy waiting for a given number of microseconds in the
--   current process.
sleep :: Int -> IO ()

-- | Perform an infinite non busy waiting in the current process.
wait :: IO ()

-- | Print string to <tt>stdout</tt> with the current process ID prefix.
say :: String -> IO ()

-- | The message box is represented by the STM's channel.
type MBox m = TChan m

-- | The actor is a process associated with the message box.
--   
--   Note that the actor is parameterized by the type of message that it
--   can accept.
data Actor m
Actor :: Process -> MBox m -> Actor m

-- | Actor's process (a thread).
proc :: Actor m -> Process

-- | Actor's message box (a channel).
mbox :: Actor m -> MBox m

-- | Create a new actor from a function, send the initial argument and the
--   message box to this actor via function arguments.
--   
--   This function calls <tt>forkIO</tt>.
actor :: t -> (t -> MBox m -> IO a) -> IO (Actor m)

-- | Create a new actor from a function, send the message box to this actor
--   via function argument.
--   
--   This function calls <tt>forkIO</tt>.
spawn :: (MBox m -> IO a) -> IO (Actor m)

-- | Wait for an asynchronous message in the message box.
receive :: MBox m -> (m -> IO a) -> IO b

-- | Infix variant of <tt>receive</tt>.
(?) :: MBox m -> (m -> IO a) -> IO b

-- | Variant of (?) with the message box inside the IO.
(<?) :: IO (MBox m) -> (m -> IO a) -> IO b

-- | Send a message to the actor.
send :: Actor m -> m -> IO m

-- | Infix variant of <tt>send</tt>.
(!) :: Actor m -> m -> IO m

-- | Variant of (!) with the actor inside the IO.
(<!) :: IO (Actor m) -> m -> IO m

-- | Variant of (!) with the message inside the IO.
(!>) :: Actor m -> IO m -> IO m

-- | Variant of (!) with the actor and the message inside the IO.
(<!>) :: IO (Actor m) -> IO m -> IO m

-- | Create a new receiving actor.
--   
--   This function calls <tt>forkIO</tt>.
spawn_receive :: (m -> IO a) -> IO (Actor m)

-- | Perform an action, on exceptions perform a given action <tt>f</tt>.
on_exception :: IO a -> IO a -> IO a

-- | Perform an action ignoring any exceptions in it.
tolerant :: IO a -> IO a

-- | Perform an action, do <tt>exit</tt> on exceptions.
--   
--   XXX Bad name?
faultable :: IO () -> IO ()
instance Show (Actor m)
instance Ord (Actor m)
instance Eq (Actor m)


-- | This module reimplement some functions from the
--   <tt>Control.Concurrent.Actor</tt> module with debug features.
module Control.Concurrent.Actor.Debug

-- | Variant of <tt>receive</tt> with the test printing.
receive :: MBox m -> (m -> IO a) -> IO b

-- | Variant of <tt>spawn_receive</tt> with the test printing.
spawn_receive :: (m -> IO a) -> IO (Actor m)

module Control.Concurrent.Actor.Tests
test_receive_1 :: IO ()
test_tolerant_1 :: IO ()

module Control.Concurrent.Actor.Examples

-- | Using <tt>spawn</tt>.
spawn_1 :: IO ()

-- | Make an initial argument type.
data Child
Child :: String -> Process -> Child

-- | Using <tt>actor</tt>.
actor_1 :: IO ()

-- | There is some Erlang code from the "Learn You Some Erlang" book:
--   
--   <pre>
--   dolphin() -&gt;
--     receive
--       do_a_flip -&gt;
--         io:format("How about no?~n");
--       fish -&gt;
--         io:format("So long and thanks for all the fish!~n");
--       _ -&gt;
--         io:format("Heh, we're smarter than you humans.~n")
--     end
--   </pre>
dolphin :: String -> IO ()
test_dolphin :: IO ()
