-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | S-Expression parsing/printing made fun and easy
--   
--   See the <tt>README.md</tt> file and the homepage for details.
@package sexp
@version 0.7


-- | S-Expressions are represented by <a>Sexp</a>. Conversion to and from
--   arbitrary types is done through <a>Sexpable</a>.
--   
--   The encoding and decoding functions from <a>Sexpable</a>,
--   <a>toSexp</a>, and <a>fromSexp</a> all have <a>Generic</a> default
--   implementations. So, if your data-type has a <a>Generic</a> instance
--   (which you can automatically get with the <tt>DeriveGeneric</tt> GHC
--   extension), it also has a <a>Sexpable</a> instance:
--   
--   <pre>
--    {--}
--   
--   data MyType = Foo { unFoo :: Int }
--                deriving ( Generic )
--   
--   instance Sexpable MyType
--      -- the default implementation uses the <a>Generic</a> representation of <tt>MyType</tt>
--   </pre>
--   
--   If you want a specific encoding for your type, just fill in the
--   <a>Sexpable</a> instance methods:
--   
--   <pre>
--    {--}
--   
--   import Control.Applicative ( (<a>$</a>) )
--   
--   data MyType = Foo { unFoo :: Int }
--   
--   instance Sexpable MyType where
--        toSexp (Foo x) = List [Atom <a>this</a>, Atom <a>is</a>, toSexp x]
--   
--   fromSexp (List [Atom <a>this</a>, Atom <a>is</a>, s]) = Foo <a>$</a> fromSexp s
--        fromSexp _                                  = fail <a>invalid MyType sexp</a>
--   </pre>
--   
--   Thank you, <tt>aeson</tt>, for the model code for this module.
module Data.Sexp

-- | A <a>ByteString</a>-based S-Expression. Conceptually, a <a>Sexp</a> is
--   either an single atom represented by a <a>ByteString</a>, or a list of
--   <a>Sexp</a>.
data Sexp
List :: [Sexp] -> Sexp
Atom :: ByteString -> Sexp
class Sexpable a where toSexp = gToSexp . from fromSexp s = to <$> gFromSexp s
toSexp :: Sexpable a => a -> Sexp
fromSexp :: (Sexpable a, Monad m, Applicative m) => Sexp -> m a
escape :: ByteString -> ByteString

-- | The inverse of <a>escape</a>.
unescape :: ByteString -> ByteString
instance [overlap ok] Eq Sexp
instance [overlap ok] Show Sexp
instance [overlap ok] (GToSum a, GToSum b, GFromSum a, GFromSum b) => GSexpable (a :+: b)
instance [overlap ok] (GProductToSexp a, GProductToSexp b, GFromProduct a, GFromProduct b, ProductSize a, ProductSize b) => GSexpable (a :*: b)
instance [overlap ok] (Constructor c, ConsSexpable a) => GSexpable (C1 c a)
instance [overlap ok] GSexpable U1
instance [overlap ok] Sexpable a => GSexpable (K1 i a)
instance [overlap ok] GSexpable a => GSexpable (M1 i c a)
instance [overlap ok] (Constructor c, GSexpable a, ConsSexpable a) => GToSum (C1 c a)
instance [overlap ok] (GToSum a, GToSum b) => GToSum (a :+: b)
instance [overlap ok] (Constructor c, GSexpable a, ConsSexpable a) => GFromSum (C1 c a)
instance [overlap ok] (GFromSum a, GFromSum b) => GFromSum (a :+: b)
instance [overlap ok] GSexpable a => GProductToSexp a
instance [overlap ok] (GProductToSexp a, GProductToSexp b) => GProductToSexp (a :*: b)
instance [overlap ok] GSexpable a => GFromProduct (S1 s a)
instance [overlap ok] (GFromProduct a, GFromProduct b) => GFromProduct (a :*: b)
instance [overlap ok] ProductSize (S1 s a)
instance [overlap ok] (ProductSize a, ProductSize b) => ProductSize (a :*: b)
instance [overlap ok] GSexpable f => ConsSexpable' False f
instance [overlap ok] (GRecordToPairs f, GFromRecord f) => ConsSexpable' True f
instance [overlap ok] (IsRecord f b, ConsSexpable' b f) => ConsSexpable f
instance [overlap ok] (Selector s, GSexpable a) => GFromRecord (S1 s a)
instance [overlap ok] (GFromRecord a, GFromRecord b) => GFromRecord (a :*: b)
instance [overlap ok] (Selector s, GSexpable a) => GRecordToPairs (S1 s a)
instance [overlap ok] (GRecordToPairs a, GRecordToPairs b) => GRecordToPairs (a :*: b)
instance [overlap ok] IsRecord U1 False
instance [overlap ok] IsRecord (K1 i c) True
instance [overlap ok] IsRecord f b => IsRecord (M1 S c f) b
instance [overlap ok] IsRecord (M1 S NoSelector f) False
instance [overlap ok] IsRecord f b => IsRecord (f :*: g) b
instance [overlap ok] Sexpable Sexp
instance [overlap ok] Sexpable a => Sexpable (Maybe a)
instance [overlap ok] (Sexpable a, Sexpable b) => Sexpable (Either a b)
instance [overlap ok] (Sexpable a, Sexpable b, Sexpable c, Sexpable d, Sexpable e) => Sexpable (a, b, c, d, e)
instance [overlap ok] (Sexpable a, Sexpable b, Sexpable c, Sexpable d) => Sexpable (a, b, c, d)
instance [overlap ok] (Sexpable a, Sexpable b, Sexpable c) => Sexpable (a, b, c)
instance [overlap ok] (Sexpable a, Sexpable b) => Sexpable (a, b)
instance [overlap ok] Sexpable v => Sexpable (IntMap v)
instance [overlap ok] (Sexpable k, Sexpable v, Ord k) => Sexpable (Map k v)
instance [overlap ok] (Sexpable a, Ord a) => Sexpable (Set a)
instance [overlap ok] Sexpable a => Sexpable [a]
instance [overlap ok] Sexpable String
instance [overlap ok] Sexpable ByteString
instance [overlap ok] Sexpable ByteString
instance [overlap ok] Sexpable ()
instance [overlap ok] Sexpable Integer
instance [overlap ok] Sexpable Int
instance [overlap ok] Sexpable Float
instance [overlap ok] Sexpable Double
instance [overlap ok] Sexpable Char
instance [overlap ok] Sexpable Bool
instance [overlap ok] IsString Sexp

module Language.Sexp.Parser

-- | A <a>ByteString</a>-based S-Expression. Conceptually, a <a>Sexp</a> is
--   either an single atom represented by a <a>ByteString</a>, or a list of
--   <a>Sexp</a>.
data Sexp
List :: [Sexp] -> Sexp
Atom :: ByteString -> Sexp

-- | A parser for S-Expressions. Ignoring whitespace, we follow the
--   following EBNF:
--   
--   SEXP ::= '(' ATOM* ')' | ATOM ATOM ::= '<a>' ESCAPED_STRING* '</a>' |
--   [^ tn()]+ ESCAPED_STRING ::= ...
sexpParser :: Parser Sexp
data ParseException
ParseException :: String -> ByteString -> ParseException

-- | Parse S-Expressions from a lazy <a>ByteString</a>. If the parse was
--   successful, <tt>Right sexps</tt> is returned; otherwise, <tt>Left
--   (errorMsg, leftover)</tt> is returned.
parse :: ByteString -> Either (String, ByteString) [Sexp]

-- | A variant of <a>parse</a> that throws a <a>ParseException</a> if the
--   parse fails.
parseExn :: ByteString -> [Sexp]

-- | A variant of <a>parse</a> that returns <a>Nothing</a> if the parse
--   fails.
parseMaybe :: ByteString -> Maybe [Sexp]
instance Typeable ParseException
instance Show ParseException
instance Exception ParseException

module Language.Sexp.Printer

-- | Pretty print a <a>Sexp</a> in a human-friendly way.
printHum :: Sexp -> ByteString

-- | Pretty print a <a>Sexp</a> with minimal formatting. Suitable for
--   machine processing.
printMach :: Sexp -> ByteString

module Language.Sexp
