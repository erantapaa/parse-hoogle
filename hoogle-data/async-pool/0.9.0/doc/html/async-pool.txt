-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A modified version of async that supports worker groups and many-to-many task dependencies
--   
@package async-pool
@version 0.9.0


-- | This module provides a set of operations for running IO operations
--   asynchronously and waiting for their results. It is a thin layer over
--   the basic concurrency operations provided by
--   <a>Control.Concurrent</a>. The main additional functionality it
--   provides is the ability to wait for the return value of a thread, plus
--   functions for managing task pools, work groups, and many-to-many
--   dependencies between tasks. The interface also provides some
--   additional safety and robustness over using threads and <tt>MVar</tt>
--   directly.
--   
--   The basic type is <tt><a>Async</a> a</tt>, which represents an
--   asynchronous <tt>IO</tt> action that will return a value of type
--   <tt>a</tt>, or die with an exception. An <tt>Async</tt> corresponds to
--   either a thread, or a <tt>Handle</tt> to an action waiting to be
--   spawned. This makes it possible to submit very large numbers of tasks,
--   with only N threads active at one time.
--   
--   For example, to fetch two web pages at the same time, we could do this
--   (assuming a suitable <tt>getURL</tt> function):
--   
--   <pre>
--   withTaskGroup 4 $ \g -&gt; do
--      a1 &lt;- async g (getURL url1)
--      a2 &lt;- async g (getURL url2)
--      page1 &lt;- wait a1
--      page2 &lt;- wait a2
--      ...
--   </pre>
--   
--   where <a>async</a> submits the operation to the worker group (and from
--   which it is spawned in a separate thread), and <a>wait</a> waits for
--   and returns the result. The number 4 indicates the maximum number of
--   threads which may be spawned at one time. If the operation throws an
--   exception, then that exception is re-thrown by <a>wait</a>. This is
--   one of the ways in which this library provides some additional safety:
--   it is harder to accidentally forget about exceptions thrown in child
--   threads.
--   
--   A slight improvement over the previous example is this:
--   
--   <pre>
--   withTaskGroup 4 $ \g -&gt; do
--      withAsync g (getURL url1) $ \a1 -&gt; do
--      withAsync g (getURL url2) $ \a2 -&gt; do
--      page1 &lt;- wait a1
--      page2 &lt;- wait a2
--      ...
--   </pre>
--   
--   <a>withAsync</a> is like <a>async</a>, except that the <a>Async</a> is
--   automatically killed (or unscheduled, using <a>cancel</a>) if the
--   enclosing IO operation returns before it has completed. Consider the
--   case when the first <a>wait</a> throws an exception; then the second
--   <a>Async</a> will be automatically killed rather than being left to
--   run in the background, possibly indefinitely. This is the second way
--   that the library provides additional safety: using <a>withAsync</a>
--   means we can avoid accidentally leaving threads running. Furthermore,
--   <a>withAsync</a> allows a tree of threads to be built, such that
--   children are automatically killed if their parents die for any reason.
--   
--   The pattern of performing two IO actions concurrently and waiting for
--   their results is packaged up in a combinator <a>concurrently</a>, so
--   we can further shorten the above example to:
--   
--   <pre>
--   withTaskGroup 4 $ \g -&gt; do
--      (page1, page2) &lt;- concurrently g (getURL url1) (getURL url2)
--      ...
--   </pre>
--   
--   The <a>Functor</a> instance can be used to change the result of an
--   <a>Async</a>. For example:
--   
--   <pre>
--   ghci&gt; a &lt;- async g (return 3)
--   ghci&gt; wait a
--   3
--   ghci&gt; wait (fmap (+1) a)
--   4
--   </pre>
module Control.Concurrent.Async.Pool

-- | An asynchronous action spawned by <a>async</a> or <a>withAsync</a>.
--   Asynchronous actions are executed in a separate thread, and operations
--   are provided for waiting for asynchronous actions to complete and
--   obtaining their results (see e.g. <a>wait</a>).
data Async a

-- | Create both a pool, and a task group with a given number of execution
--   slots.
withTaskGroup :: Int -> (TaskGroup -> IO b) -> IO b

-- | Create a task group within the given pool having a specified number of
--   execution slots, but with a bounded lifetime. Leaving the block
--   cancels every task still executing in the group.
withTaskGroupIn :: Pool -> Int -> (TaskGroup -> IO b) -> IO b

-- | A <a>Pool</a> manages a collection of possibly interdependent tasks,
--   such that tasks await execution until the tasks they depend on have
--   finished (and tasks may depend on an arbitrary number of other tasks),
--   while independent tasks execute concurrently up to the number of
--   available resource slots in the pool.
--   
--   Results from each task are available until the status of the task is
--   polled or waited on. Further, the results are kept until that occurs,
--   so failing to ever wait will result in a memory leak.
--   
--   Tasks may be cancelled, in which case all dependent tasks are
--   unscheduled.
data Pool

-- | Create a task pool for managing many-to-many acyclic dependencies
--   among tasks.
createPool :: IO Pool
data TaskGroup

-- | Create a task group for executing interdependent tasks concurrently.
--   The number of available slots governs how many tasks may run at one
--   time.
createTaskGroup :: Pool -> Int -> IO TaskGroup

-- | Execute tasks in a given task group. The number of slots determines
--   how many threads may execute concurrently.
runTaskGroup :: TaskGroup -> IO ()

-- | Spawn an asynchronous action in a separate thread.
async :: TaskGroup -> IO a -> IO (Async a)

-- | Like <a>async</a> but using <a>forkOS</a> internally.
asyncBound :: TaskGroup -> IO a -> IO (Async a)

-- | Like <a>async</a> but using <a>forkOn</a> internally.
asyncOn :: TaskGroup -> Int -> IO a -> IO (Async a)

-- | Like <a>async</a> but using <a>forkIOWithUnmask</a> internally. The
--   child thread is passed a function that can be used to unmask
--   asynchronous exceptions.
asyncWithUnmask :: TaskGroup -> ((forall b. IO b -> IO b) -> IO a) -> IO (Async a)

-- | Like <a>asyncOn</a> but using <a>forkOnWithUnmask</a> internally. The
--   child thread is passed a function that can be used to unmask
--   asynchronous exceptions.
asyncOnWithUnmask :: TaskGroup -> Int -> ((forall b. IO b -> IO b) -> IO a) -> IO (Async a)

-- | Equivalent to <a>async</a>, but acts in STM so that
--   <a>makeDependent</a> may be called after the task is created, but
--   before it begins executing.
asyncSTM :: TaskGroup -> IO a -> STM (Async a)
taskHandle :: Async a -> Handle

-- | Submit a task that begins execution only after its parent has
--   completed. This is equivalent to submitting a new task with
--   <a>asyncSTM</a> and linking it to its parent using
--   <a>makeDependent</a>.
asyncAfter :: TaskGroup -> Async b -> IO a -> IO (Async a)

-- | Submit a task which begins execution after all its parents have
--   completed. This is equivalent to submitting a new task with
--   <a>asyncSTM</a> and linking it to its parents using 'mapM
--   makeDependent'.
asyncAfterAll :: TaskGroup -> [Handle] -> IO a -> IO (Async a)

-- | Given parent and child tasks, link them so the child cannot execute
--   until the parent has finished.
makeDependent :: Pool -> Handle -> Handle -> STM ()

-- | Given parent and child tasks, link them so the child cannot execute
--   until the parent has finished. This function does not check for
--   introduction of cycles into the dependency graph, which would prevent
--   the child from ever running.
unsafeMakeDependent :: Pool -> Handle -> Handle -> STM ()

-- | Spawn an asynchronous action in a separate thread, and pass its
--   <tt>Async</tt> handle to the supplied function. When the function
--   returns or throws an exception, <a>cancel</a> is called on the
--   <tt>Async</tt>.
--   
--   <pre>
--   withAsync action inner = bracket (async action) cancel inner
--   </pre>
--   
--   This is a useful variant of <a>async</a> that ensures an
--   <tt>Async</tt> is never left running unintentionally.
--   
--   Since <a>cancel</a> may block, <a>withAsync</a> may also block; see
--   <a>cancel</a> for details.
withAsync :: TaskGroup -> IO a -> (Async a -> IO b) -> IO b

-- | Like <a>withAsync</a> but uses <a>forkOS</a> internally.
withAsyncBound :: TaskGroup -> IO a -> (Async a -> IO b) -> IO b

-- | Like <a>withAsync</a> but uses <a>forkOn</a> internally.
withAsyncOn :: TaskGroup -> Int -> IO a -> (Async a -> IO b) -> IO b

-- | Like <a>withAsync</a> but uses <a>forkIOWithUnmask</a> internally. The
--   child thread is passed a function that can be used to unmask
--   asynchronous exceptions.
withAsyncWithUnmask :: TaskGroup -> ((forall c. IO c -> IO c) -> IO a) -> (Async a -> IO b) -> IO b

-- | Like <a>withAsyncOn</a> but uses <a>forkOnWithUnmask</a> internally.
--   The child thread is passed a function that can be used to unmask
--   asynchronous exceptions
withAsyncOnWithUnmask :: TaskGroup -> Int -> ((forall c. IO c -> IO c) -> IO a) -> (Async a -> IO b) -> IO b

-- | Wait for an asynchronous action to complete, and return its value. If
--   the asynchronous action threw an exception, then the exception is
--   re-thrown by <a>wait</a>.
--   
--   <pre>
--   wait = atomically . waitSTM
--   </pre>
wait :: Async a -> IO a

-- | Check whether an <a>Async</a> has completed yet. If it has not
--   completed yet, then the result is <tt>Nothing</tt>, otherwise the
--   result is <tt>Just e</tt> where <tt>e</tt> is <tt>Left x</tt> if the
--   <tt>Async</tt> raised an exception <tt>x</tt>, or <tt>Right a</tt> if
--   it returned a value <tt>a</tt>.
--   
--   <pre>
--   poll = atomically . pollSTM
--   </pre>
poll :: Async a -> IO (Maybe (Either SomeException a))

-- | Wait for an asynchronous action to complete, and return either
--   <tt>Left e</tt> if the action raised an exception <tt>e</tt>, or
--   <tt>Right a</tt> if it returned a value <tt>a</tt>.
--   
--   <pre>
--   waitCatch = atomically . waitCatchSTM
--   </pre>
waitCatch :: Async a -> IO (Either SomeException a)

-- | Cancel an asynchronous action by throwing the <tt>ThreadKilled</tt>
--   exception to it. Has no effect if the <a>Async</a> has already
--   completed.
--   
--   <pre>
--   cancel a = throwTo (asyncThreadId a) ThreadKilled
--   </pre>
--   
--   Note that <a>cancel</a> is synchronous in the same sense as
--   <a>throwTo</a>. It does not return until the exception has been thrown
--   in the target thread, or the target thread has completed. In
--   particular, if the target thread is making a foreign call, the
--   exception will not be thrown until the foreign call returns, and in
--   this case <a>cancel</a> may block indefinitely. An asynchronous
--   <a>cancel</a> can of course be obtained by wrapping <a>cancel</a>
--   itself in <a>async</a>.
cancel :: Async a -> IO ()
cancelWith :: Exception e => Async a -> e -> IO ()

-- | A version of <a>wait</a> that can be used inside an STM transaction.
waitSTM :: Async a -> STM a

-- | A version of <a>poll</a> that can be used inside an STM transaction.
pollSTM :: Async a -> STM (Maybe (Either SomeException a))

-- | A version of <a>waitCatch</a> that can be used inside an STM
--   transaction.
waitCatchSTM :: Async a -> STM (Either SomeException a)

-- | Wait for any of the supplied <tt>Async</tt>s to complete. If the first
--   to complete throws an exception, then that exception is re-thrown by
--   <a>waitAny</a>.
--   
--   If multiple <a>Async</a>s complete or have completed, then the value
--   returned corresponds to the first completed <a>Async</a> in the list.
waitAny :: [Async a] -> IO (Async a, a)

-- | Wait for any of the supplied asynchronous operations to complete. The
--   value returned is a pair of the <a>Async</a> that completed, and the
--   result that would be returned by <a>wait</a> on that <a>Async</a>.
--   
--   If multiple <a>Async</a>s complete or have completed, then the value
--   returned corresponds to the first completed <a>Async</a> in the list.
waitAnyCatch :: [Async a] -> IO (Async a, Either SomeException a)

-- | Like <a>waitAny</a>, but also cancels the other asynchronous
--   operations as soon as one has completed.
waitAnyCancel :: [Async a] -> IO (Async a, a)

-- | Like <a>waitAnyCatch</a>, but also cancels the other asynchronous
--   operations as soon as one has completed.
waitAnyCatchCancel :: [Async a] -> IO (Async a, Either SomeException a)

-- | Wait for the first of two <tt>Async</tt>s to finish. If the
--   <tt>Async</tt> that finished first raised an exception, then the
--   exception is re-thrown by <a>waitEither</a>.
waitEither :: Async a -> Async b -> IO (Either a b)

-- | Wait for the first of two <tt>Async</tt>s to finish.
waitEitherCatch :: Async a -> Async b -> IO (Either (Either SomeException a) (Either SomeException b))

-- | Like <a>waitEither</a>, but also <a>cancel</a>s both <tt>Async</tt>s
--   before returning.
waitEitherCancel :: Async a -> Async b -> IO (Either a b)

-- | Like <a>waitEitherCatch</a>, but also <a>cancel</a>s both
--   <tt>Async</tt>s before returning.
waitEitherCatchCancel :: Async a -> Async b -> IO (Either (Either SomeException a) (Either SomeException b))

-- | Like <a>waitEither</a>, but the result is ignored.
waitEither_ :: Async a -> Async b -> IO ()

-- | Waits for both <tt>Async</tt>s to finish, but if either of them throws
--   an exception before they have both finished, then the exception is
--   re-thrown by <a>waitBoth</a>.
waitBoth :: Async a -> Async b -> IO (a, b)

-- | Link the given <tt>Async</tt> to the current thread, such that if the
--   <tt>Async</tt> raises an exception, that exception will be re-thrown
--   in the current thread.
link :: Async a -> IO ()

-- | Link two <tt>Async</tt>s together, such that if either raises an
--   exception, the same exception is re-thrown in the other
--   <tt>Async</tt>.
link2 :: Async a -> Async b -> IO ()

-- | Execute a group of tasks within the given task group, returning the
--   results in order. The order of execution is random, but the results
--   are returned in order.
mapTasks :: Traversable t => TaskGroup -> t (IO a) -> IO (t a)

-- | Execute a group of tasks within the given task group, ignoring
--   results.
mapTasks_ :: Foldable t => TaskGroup -> t (IO a) -> IO ()

-- | Execute a group of tasks within the given task group, returning the
--   results in order as an Either type to represent exceptions from
--   actions. The order of execution is random, but the results are
--   returned in order.
mapTasksE :: Traversable t => TaskGroup -> t (IO a) -> IO (t (Either SomeException a))

-- | Execute a group of tasks within the given task group, ignoring
--   results, but returning a list of all exceptions.
mapTasksE_ :: Traversable t => TaskGroup -> t (IO a) -> IO (t (Maybe SomeException))

-- | Execute a group of tasks, but return the first result or failure and
--   cancel the remaining tasks.
mapRace :: Foldable t => TaskGroup -> t (IO a) -> IO (Async a, Either SomeException a)

-- | Given a list of actions yielding <a>Monoid</a> results, execute the
--   actions concurrently (up to N at a time, based on available slots),
--   and <tt>mappend</tt> each pair of results concurrently as they become
--   ready. The immediate result of this function is an <a>Async</a>
--   representing the final value.
--   
--   This is similar to the following: <tt>mconcat <a>$</a> mapTasks n
--   actions</tt>, except that intermediate results can be garbage
--   collected as soon as they've been merged. Also, the value returned
--   from this function is an <a>Async</a> which may be polled for the
--   final result.
--   
--   Lastly, if an <tt>Exception</tt> occurs in any subtask, the final
--   result will also yield an exception -- but not necessarily the first
--   or last that was caught.
mapReduce :: (Foldable t, Monoid a) => TaskGroup -> t (IO a) -> STM (Async a)

-- | Execute a group of tasks concurrently (using up to N active threads,
--   depending on the task group), and feed results to a continuation as
--   soon as they become available, in random order. The continuation
--   function may return a monoid value which is accumulated to yield a
--   final result. If no such value is needed, simply provide `()`.
scatterFoldMapM :: (Foldable t, Monoid b, MonadBaseControl IO m) => TaskGroup -> t (IO a) -> (Either SomeException a -> m b) -> m b

-- | The <a>Task</a> Applicative and Monad allow for task dependencies to
--   be built using Applicative and do notation. Monadic evaluation is
--   sequenced, while applicative Evaluation is concurrent for each
--   argument. In this way, mixing the two builds a dependency graph via
--   ordinary Haskell code.
data Task a

-- | Run a value in the <a>Task</a> monad and block until the final result
--   is computed.
runTask :: TaskGroup -> Task a -> IO a

-- | Lift any <a>IO</a> action into a <a>Task</a>. This is a synonym for
--   <a>liftIO</a>.
task :: IO a -> Task a

-- | Run two <tt>IO</tt> actions concurrently, and return the first to
--   finish. The loser of the race is <a>cancel</a>led.
--   
--   <pre>
--   race left right =
--     withAsync left $ \a -&gt;
--     withAsync right $ \b -&gt;
--     waitEither a b
--   </pre>
race :: TaskGroup -> IO a -> IO b -> IO (Either a b)

-- | Like <a>race</a>, but the result is ignored.
race_ :: TaskGroup -> IO a -> IO b -> IO ()

-- | Run two <tt>IO</tt> actions concurrently, and return both results. If
--   either action throws an exception at any time, then the other action
--   is <a>cancel</a>led, and the exception is re-thrown by
--   <a>concurrently</a>.
--   
--   <pre>
--   concurrently left right =
--     withAsync left $ \a -&gt;
--     withAsync right $ \b -&gt;
--     waitBoth a b
--   </pre>
concurrently :: TaskGroup -> IO a -> IO b -> IO (a, b)

-- | maps an <tt>IO</tt>-performing function over any <tt>Traversable</tt>
--   data type, performing all the <tt>IO</tt> actions concurrently, and
--   returning the original data structure with the arguments replaced by
--   the results.
--   
--   For example, <tt>mapConcurrently</tt> works with lists:
--   
--   <pre>
--   pages &lt;- mapConcurrently getURL ["url1", "url2", "url3"]
--   </pre>
mapConcurrently :: Traversable t => TaskGroup -> (a -> IO b) -> t a -> IO (t b)

-- | A value of type <tt>Concurrently a</tt> is an <tt>IO</tt> operation
--   that can be composed with other <tt>Concurrently</tt> values, using
--   the <tt>Applicative</tt> and <tt>Alternative</tt> instances.
--   
--   Calling <tt>runConcurrently</tt> on a value of type <tt>Concurrently
--   a</tt> will execute the <tt>IO</tt> operations it contains
--   concurrently, before delivering the result of type <tt>a</tt>.
--   
--   For example
--   
--   <pre>
--   (page1, page2, page3)
--       &lt;- runConcurrently $ (,,)
--       &lt;$&gt; Concurrently (getURL "url1")
--       &lt;*&gt; Concurrently (getURL "url2")
--       &lt;*&gt; Concurrently (getURL "url3")
--   </pre>
newtype Concurrently a
Concurrently :: (TaskGroup -> IO a) -> Concurrently a
runConcurrently :: Concurrently a -> TaskGroup -> IO a
