-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Javascript Monadic Writer base package.
--   
--   An EDSL inspired in part by HJ(ava)Script and HSP aimed at coding in
--   typed Javascript. It uses WebBits as the underlying representation of
--   Javascript.
--   
--   This package provides the basic API sufficient to create simple
--   dynamic web pages.
--   
--   Below is a simple example of a program that increments or decrements a
--   value in an input field depending on whether <i>Enter</i> or
--   <i>Shift-Enter</i> was pressed.
--   
--   Save this program in a file, and run <tt>runghc</tt> on the file.
--   Javascript will be output to be placed into HEAD element of a blank
--   HTML page. Give the page body attribute:
--   
--   <pre>
--   &lt;body onload="javascript:main()"&gt;
--   </pre>
--   
--   to run the script when the page loads.
--   
--   A live example of this program is available here:
--   
--   <a>http://code.haskell.org/yc2js/examples/ex1.html</a>
--   
--   <pre>
--   module Main where
--   
--   import Prelude hiding (putStrLn)
--   import System.IO.UTF8
--   import BrownPLT.JavaScript
--   import BrownPLT.JavaScript.PrettyPrint
--   import Control.Monad
--   import Language.JSMW
--   import Data.DOM
--   import Data.DOM.Dom
--   import Data.DOM.Html2
--   import Data.DOM.Events
--   import Data.DOM.KeyEvent
--   import Data.DOM.HTMLHRElement
--   import Data.DOM.HTMLInputElement
--   
--   main = putStrLn $ show $ stmt $
--     FunctionStmt undefined (Id undefined "main") [] (getBlock ( runJSMW 0 q))
--   
--   
--   q = do
--     passive (mkText $ string
--       "Example 1: Press Enter to increase value, Shift-Enter to decrease value")
--     passive mkHr
--     mkInput `container` (do
--       setHandler "keypress" plusOne
--       ask &gt;&gt;= set'value (string "0") &gt;&gt;= focus)
--   
--   plusOne :: OnHandler TKeyEvent THTMLInputElement
--   
--   plusOne e = do
--     c &lt;- getm'keyCode e
--     switch (c) $ do
--       cDOM_VK_ENTER --&gt; do i &lt;- ask
--                            v &lt;- getm'value i
--                            vv &lt;- switch v $ do
--                              "" --&gt; stringM "0"
--                              none (return v)
--                            n &lt;- parseInt vv 0
--                            shft &lt;- get'shiftKey e
--                            n2 &lt;- switch shft $ do
--                              True --&gt; return (n - number 1)
--                              False --&gt; return (n + number 1)
--                            once =&lt;&lt; (toString n2 &gt;&gt;= flip set'value i)
--                            return false
--       none (return true)
--   </pre>
@package jsmw
@version 0.1


-- | A special monad: the core of the Writer.
module Language.JSMW.Monad

-- | A type of the writer: based on the <a>RWS</a> Monad. The Reader part
--   holds an expression to reference the curent HTML container element.
--   The Writer part is the list of Javascript statements being formed.
--   Container may be any DOM Element, but not a Text node or anything
--   else.
type JSMW e a = RWS (Expression e) [Statement ()] Int a

-- | Run the code writer (raw way, returns both state and log). Container
--   will be initialized into the body of the current HTML document. Same
--   as <tt> <a>runJSMWWith</a> <a>currDocBody</a> </tt>
runJSMW :: Int -> JSMW THTMLBodyElement (Expression a) -> (Expression a, Int, [Statement ()])

-- | Run the code writer (raw way, returns both state and log) with
--   explicitly specified container.
runJSMWWith :: CElement e => (Expression e) -> Int -> JSMW e (Expression a) -> (Expression a, Int, [Statement ()])

-- | Obtain a block statement from the result of <tt>runJSWM</tt>. The last
--   expression forms a 'return' statement, so the resulting block may be
--   used as a function's body.
getBlock :: (Expression a, Int, [Statement ()]) -> Statement ()

-- | Body of the current document: use it to start the toplevel instance of
--   the Writer as a container for <a>runJSMWWith</a>.
currDocBody :: Expression THTMLBodyElement

-- | The JSMW code consists of monadic smart constructors forming
--   Javascript method calls. These constructors are inlined each time they
--   are referenced. The <a>once</a> combinator causes a variable
--   assignment statement to be formed with the variable assigned to the
--   expression returned. All future references will be to the variable
--   rather than to the expression. Since the expression will be evaluated
--   when assigned to the variable, referencing the variable will reference
--   the result, and possible effect will not be repeated.
once :: Expression a -> JSMW e (Expression a)

-- | Create a unique variable name. This function increments the internal
--   state of the monad and produces a string consisting of the letter 'v'
--   and a unique number.
mkNewVar :: JSMW e String

-- | Write out a statement. This function utilizes the Writer part of the
--   monad, and adds the Javascript statement provided to the Writer's log.
writeStmt :: Statement () -> JSMW e ()

-- | Create a Javascript string literal out of a string, monadic version.
stringM :: String -> JSMW e (Expression String)

-- | Create a Javascript numeric literal out of a numeric value, monadic
--   version.
numberM :: Integral n => n -> JSMW e (Expression Double)

-- | Create a Javascript boolean literal out of a Boolean, monadic version.
boolM :: Bool -> JSMW e (Expression Bool)

-- | Type of a function creating HTML elements, e. g. <tt>mkButton</tt>,
--   <tt>mkDiv</tt>
type ECRF e n = Expression THTMLDocument -> JSMW e (Expression n)

-- | Insert a passive element into the current container.
passive :: (CNode n, CElement e) => ECRF e n -> JSMW e (Expression ())

-- | Nest an element inside another element via monadic composition.
--   Example usage:
--   
--   <pre>
--   <a>ask</a> &gt;&gt;= <a>nest</a> <tt>mkButton</tt> &gt;&gt;= <a>nest</a> (<a>mkText</a> $ <a>string</a> "Foo")
--   </pre>
--   
--   inserts a button with text "Foo" into the current container.
--   
--   The type system makes sure that only an instance of a DOM Element can
--   nest other elements, e. g.
--   
--   <pre>
--   ... mkText (string "Foo") &gt;&gt;= nest mkDiv
--   </pre>
--   
--   would not typecheck.
--   
--   Example: a text, a newline, and two buttons: <tt><a>ask</a></tt>
--   retrieves the current container.
--   
--   <pre>
--   q = do
--     passive (mkText $ string "Hello")
--     passive mkBr
--     ask &gt;&gt;= nest mkButton &gt;&gt;= nest (mkText $ string "Foo")
--     ask &gt;&gt;= nest mkButton &gt;&gt;= nest (mkText $ string "Bar")
--   </pre>
nest :: (CNode n, CElement e, CElement p) => ECRF e n -> Expression p -> JSMW e (Expression n)

-- | Specify a new container that in nested into the current one. As long
--   as the container is active, all subsequently defined elements will be
--   inserted into it.
--   
--   Example: a Button with two text labels separated with a newline:
--   
--   <pre>
--   mkButton `container` (do
--     passive (mkText $ string "Hello") 
--     passive mkBr
--     passive (mkText $ string "GoodBye"))
--   </pre>
--   
--   Everything defined within a <tt>do</tt> expression is inserted into
--   the button which is the new container.
container :: (CElement n, CElement e) => ECRF e n -> JSMW n (Expression x) -> JSMW e (Expression ())

-- | Create an element for future use, and return a reference to it. The
--   element may be inserted into a container different from one it was
--   created with (when <a>ref</a> was called). But it should be used
--   within the same document it was created inside.
ref :: (CNode e, CElement n) => ECRF e n -> JSMW e (Expression n)

-- | Turn an element reference into element creation function. It can be
--   useful when an element created earlier has to be used as a container,
--   or a passive element, or nested. The type signature of <a>ref2ecrf</a>
--   reflects the fact that the element was created when one container was
--   current, but may be used with another container.
ref2ecrf :: (CElement e1, CElement e2, CNode n) => Expression n -> JSMW e1 (ECRF e2 n)

-- | Essentially same as <a>container</a> except that a reference to an
--   element has to be supplied rather than an element creation function.
--   Another difference from <a>container</a>: element referenced is not
--   added as a child to the current container.
inside :: (CElement n, CElement e) => Expression n -> JSMW n (Expression x) -> JSMW e (Expression ())

-- | Data type for building inline style assignment expressions.
data CSSDeco
(:=) :: String -> String -> CSSDeco

-- | An action to use within a container to update its inline style.
--   <a>setStyle</a> called with an empty list does not change the inline
--   style. Note that style settings are compile-time only.
--   
--   Example: a DIV element with style settings applied and a text:
--   
--   <pre>
--   mkDiv `container` (do
--     setStyle ["display" := "inline"
--              ,"float" := "right"
--              ,"width" := "45%"
--              ,"text-align" := "center"
--              ,"background-color" := "green"
--              ,"color" := "white"
--              ,"font-weight" := "bold"]
--     passive (mkText $ string "Styled"))
--   </pre>
setStyle :: CHTMLElement e => [CSSDeco] -> JSMW e (Expression ())

-- | A type for a on-style event handler. It represents a function which
--   takes an event and returns a boolean.
type OnHandler e c = Expression e -> JSMW c (Expression Bool)

-- | Set a on-style (e. g. onclick) event handler on the current container.
--   
--   Example: a button with a click handler which shows the X coordinate of
--   the click.
--   
--   <pre>
--   mkButton `container` (do
--     passive (mkText $ string "Click Me")
--     setHandler "click" clickHandler)
--   ...
--   clickHandler :: OnHandler TMouseEvent THTMLButtonElement
--   clickHandler e = do
--     getm'clientX e &gt;&gt;= toString &gt;&gt;= alert
--     return true
--   </pre>
--   
--   A handler function has one argument which gets the reference to the
--   event caught. The handler function also may implicitly address the
--   container it was set on by calling <a>ask</a> or <a>passive</a>. For
--   example, calling <tt>passive (mkText $ string "x")</tt> within a
--   handler will result in a text node being added to the container.
--   
--   Also note that the <a>OnHandler</a> type may be parameterized by the
--   type of containers it can be set on. In the example above, the handler
--   may only be set on buttons.
--   
--   The MSIE-specific code to obtain event from the static attribute of
--   the current window is inserted in the beginning of the handler
--   automatically.
setHandler :: (CHTMLElement c, CEvent e) => String -> OnHandler e c -> JSMW c (Expression ())

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r


-- | Encoding of Javascript conditionals.
module Language.JSMW.Cond

-- | Encode a <tt>switch</tt> statement.
switch :: (Switchable s r, CElement c) => Expression r -> Switch s r c e a -> JSMW c (Expression e)

-- | Encode a case label. The first (left) argument is a literal describing
--   the value of the label. Note that the left argument must be a Haskell
--   literal, not a Javascript expression. In other words, for boolean
--   labels, use <a>True</a> rather than <a>true</a>. The second (right)
--   argument is a JSMW monadic expression matching the label.
--   <tt>Break</tt> statements are inserted automatically (that is,
--   fall-through case labels are not permitted).
(-->) :: (Switchable s r, CElement c) => s -> JSMW c (Expression e) -> Switch s r c e ()

-- | Encode a <tt>default:</tt> case label, that is, what action should be
--   taken if none of the case labels matches the scrutinee.
--   
--   In both <a>none</a> and <a>--&gt;</a>, JSMW monadic expression should
--   be of the same type. Also note that if no case label matches the
--   scrutinee value, and no default label has been defined, an exception
--   will be thrown showing the scrutinee name that did not match.
none :: (Switchable s r, CElement c) => JSMW c (Expression e) -> Switch s r c e ()
instance Switchable String String
instance Switchable Bool Bool
instance Integral a => Switchable a Double


-- | Encoding of Javascript arithmetic and mathematic operations.
module Language.JSMW.Arith
lt :: Expression a -> Expression a -> Expression Bool
le :: Expression a -> Expression a -> Expression Bool
gt :: Expression a -> Expression a -> Expression Bool
ge :: Expression a -> Expression a -> Expression Bool
eq :: Expression a -> Expression a -> Expression Bool
ne :: Expression a -> Expression a -> Expression Bool
(===) :: Expression a -> Expression a -> Expression Bool
(=/=) :: Expression a -> Expression a -> Expression Bool
land :: Expression Bool -> Expression Bool -> Expression Bool
lor :: Expression Bool -> Expression Bool -> Expression Bool

-- | Test if a given value is a number.
isNAN :: Expression Double -> JSMW e (Expression Bool)

-- | Obtain a string representation of an arbitrary Javascript expression.
toString :: Expression a -> JSMW e (Expression String)

-- | Parse an integer.
parseInt :: Expression String -> Expression Double -> JSMW e (Expression Double)

-- | Parse a floating point number.
parseFloat :: Expression String -> JSMW e (Expression Double)
instance Fractional (Expression Double)
instance Num (Expression String)
instance Num (Expression Double)


-- | Mutable Javascript reference objects
module Data.JSRef

-- | An opaque data type parameterized by the type of the stored value.
data JSRef a

-- | Create a mutable Javascript reference object and initialize it.
newJSRef :: Expression a -> JSMW e (Expression (JSRef a))

-- | Retrieve a value from a mutable Javascript reference object.
readJSRef :: Expression (JSRef a) -> JSMW e (Expression a)

-- | Store a value in a mutable Javascript reference object.
writeJSRef :: Expression (JSRef a) -> Expression a -> JSMW e (Expression (JSRef a))


-- | DOM extensions specific to JSMW
module Data.DOM.JSMWExt

-- | Add multiple children to a node. Unlike <a>addChild</a>, this function
--   returns the parent element.
addChildren :: (CNode p, CNode c) => [Expression c] -> Expression p -> JSMW e (Expression p)

-- | Pop up an alert window.
alert :: Expression String -> JSMW e (Expression ())

-- | Update window status line.
status :: Expression String -> JSMW e (Expression ())


-- | Re-export commonly used modules.
module Language.JSMW
