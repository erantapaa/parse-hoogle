-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Safety for the pipes ecosystem
--   
@package pipes-safe
@version 2.2.2


-- | This module provides an orphan <a>MonadCatch</a> instance for
--   <a>Proxy</a> of the form:
--   
--   <pre>
--   instance (MonadCatch m, MonadIO m) =&gt; MonadCatch (Proxy a' a b' b m) where
--   </pre>
--   
--   ... so you can throw and catch exceptions within pipes using all
--   <a>MonadCatch</a> operations.
--   
--   This module also provides generalized versions of some
--   <a>MonadCatch</a> operations so that you can also protect against
--   premature termination of connected components. For example, if you
--   protect a <a>readFile</a> computation using <a>bracket</a> from this
--   module:
--   
--   <pre>
--   -- readFile.hs
--   import Pipes
--   import qualified Pipes.Prelude as P
--   import Pipes.Safe
--   import qualified System.IO as IO
--   import Prelude hiding (readFile)
--   
--   readFile :: FilePath -&gt; Producer' String (SafeT IO) ()
--   readFile file = bracket
--       (do h &lt;- IO.openFile file IO.ReadMode
--           putStrLn $ "{" ++ file ++ " open}"
--           return h )
--       (\h -&gt; do
--           IO.hClose h
--           putStrLn $ "{" ++ file ++ " closed}" )
--       P.fromHandle
--   </pre>
--   
--   ... then this generalized <a>bracket</a> will guard against both
--   exceptions and premature termination of other pipes:
--   
--   <pre>
--   &gt;&gt;&gt; runSafeT $ runEffect $ readFile "readFile.hs" &gt;-&gt; P.take 4 &gt;-&gt; P.stdoutLn
--   {readFile.hs open}
--   -- readFile.hs
--   import Pipes
--   import qualified Pipes.Prelude as P
--   import Pipes.Safe
--   {readFile.hs closed}
--   </pre>
--   
--   Note that the <a>MonadCatch</a> instance for <a>Proxy</a> provides
--   weaker versions of <a>mask</a> and <a>uninterruptibleMask</a> that do
--   not completely prevent asynchronous exceptions. Instead, they provide
--   a weaker guarantee that asynchronous exceptions will only occur during
--   <a>await</a>s or <a>yield</a>s and nowhere else. For example, if you
--   write:
--   
--   <pre>
--   mask_ $ do
--       x &lt;- await
--       lift $ print x
--       lift $ print x
--   </pre>
--   
--   ... then you may receive an asynchronous exception during the
--   <a>await</a>, but you will not receive an asynchronous exception
--   during or in between the two <a>print</a> statements. This weaker
--   guarantee suffices to provide asynchronous exception safety.
module Pipes.Safe

-- | <a>SafeT</a> is a monad transformer that extends the base monad with
--   the ability to <a>register</a> and <a>release</a> finalizers.
--   
--   All unreleased finalizers are called at the end of the <a>SafeT</a>
--   block, even in the event of exceptions.
data SafeT m r

-- | Run the <a>SafeT</a> monad transformer, executing all unreleased
--   finalizers at the end of the computation
runSafeT :: (MonadMask m, MonadIO m) => SafeT m r -> m r

-- | Run <a>SafeT</a> in the base monad, executing all unreleased
--   finalizers at the end of the computation
--   
--   Use <a>runSafeP</a> to safely flush all unreleased finalizers and
--   ensure prompt finalization without exiting the <a>Proxy</a> monad.
runSafeP :: (MonadMask m, MonadIO m) => Effect (SafeT m) r -> Effect' m r

-- | Token used to <a>release</a> a previously <a>register</a>ed finalizer
data ReleaseKey

-- | <a>MonadSafe</a> lets you <a>register</a> and <a>release</a>
--   finalizers that execute in a <a>Base</a> monad
class (MonadCatch m, MonadMask m, MonadIO m, MonadIO (Base m)) => MonadSafe m where type family Base (m :: * -> *) :: * -> *
liftBase :: MonadSafe m => Base m r -> m r
register :: MonadSafe m => Base m () -> m ReleaseKey
release :: MonadSafe m => ReleaseKey -> m ()

-- | Analogous to <a>onException</a> from <tt>Control.Monad.Catch</tt>,
--   except this also protects against premature termination
--   
--   <tt>(`onException` io)</tt> is a monad morphism.
onException :: MonadSafe m => m a -> Base m b -> m a

-- | Analogous to <a>finally</a> from <tt>Control.Monad.Catch</tt>, except
--   this also protects against premature termination
finally :: MonadSafe m => m a -> Base m b -> m a

-- | Analogous to <a>bracket</a> from <tt>Control.Monad.Catch</tt>, except
--   this also protects against premature termination
bracket :: MonadSafe m => Base m a -> (a -> Base m b) -> (a -> m c) -> m c

-- | Analogous to <a>bracket_</a> from <tt>Control.Monad.Catch</tt>, except
--   this also protects against premature termination
bracket_ :: MonadSafe m => Base m a -> Base m b -> m c -> m c

-- | Analogous to <a>bracketOnError</a> from <tt>Control.Monad.Catch</tt>,
--   except this also protects against premature termination
bracketOnError :: MonadSafe m => Base m a -> (a -> Base m b) -> (a -> m c) -> m c
instance (MonadSafe m, Monoid w) => MonadSafe (RWST i w s m)
instance (MonadSafe m, Monoid w) => MonadSafe (RWST i w s m)
instance (MonadSafe m, Monoid w) => MonadSafe (WriterT w m)
instance (MonadSafe m, Monoid w) => MonadSafe (WriterT w m)
instance MonadSafe m => MonadSafe (StateT s m)
instance MonadSafe m => MonadSafe (StateT s m)
instance MonadSafe m => MonadSafe (ReaderT i m)
instance MonadSafe m => MonadSafe (CatchT m)
instance MonadSafe m => MonadSafe (IdentityT m)
instance MonadSafe m => MonadSafe (Proxy a' a b' b m)
instance (MonadIO m, MonadCatch m, MonadMask m) => MonadSafe (SafeT m)
instance MonadTrans SafeT
instance MonadMask m => MonadMask (SafeT m)
instance MonadCatch m => MonadCatch (SafeT m)
instance MonadThrow m => MonadThrow (SafeT m)
instance MonadIO m => MonadIO (SafeT m)
instance Monad m => Monad (SafeT m)
instance Monad m => Applicative (SafeT m)
instance Monad m => Functor (SafeT m)
instance (MonadMask m, MonadIO m) => MonadMask (Proxy a' a b' b m)
instance MonadCatch m => MonadCatch (Proxy a' a b' b m)
instance MonadThrow m => MonadThrow (Proxy a' a b' b m)


-- | Simple resource management functions
module Pipes.Safe.Prelude

-- | Acquire a <a>Handle</a> within <a>MonadSafe</a>
withFile :: MonadSafe m => FilePath -> IOMode -> (Handle -> m r) -> m r

-- | Read lines from a file, automatically opening and closing the file as
--   necessary
readFile :: MonadSafe m => FilePath -> Producer' String m ()

-- | Write lines to a file, automatically opening and closing the file as
--   necessary
writeFile :: MonadSafe m => FilePath -> Consumer' String m r
