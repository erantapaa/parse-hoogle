-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A device independent module music mixer
--   
--   Hemkay (An M.K. Player Whose Name Starts with an H) is a simple music
--   module player that performs all the mixing in Haskell. It supports the
--   popular ProTracker format and some of its variations with different
--   numbers of channels.
--   
--   This package contains the mixing routines, which can be reused in any
--   application. The output can be written into a file or played back in
--   real time.
@package hemkay-core
@version 0.1.4


-- | This module contains the song structure definitions.
module Sound.Hemkay.Music
data Song
Song :: String -> [Instrument] -> [Pattern] -> Song

-- | Song title.
title :: Song -> String

-- | Instruments.
instruments :: Song -> [Instrument]

-- | Patterns in the order of playback.
patterns :: Song -> [Pattern]

-- | The number of channels in a song.
numChannels :: Song -> Int
type Pattern = [[Note]]
data Note
Note :: Int -> Maybe Instrument -> [Effect] -> Note

-- | Period of the note (0 for none); the corresponding frequency is
--   3546894.6/period.
period :: Note -> Int

-- | The instrument of the note, if any.
instrument :: Note -> Maybe Instrument

-- | Special effects, at most two per note.
effect :: Note -> [Effect]
periodName :: Int -> [Char]
data Effect
Arpeggio :: Float -> Float -> Effect
Portamento :: PortaParam -> Effect
TonePortamento :: (Maybe Int) -> Effect
Vibrato :: (Maybe Int) -> (Maybe Int) -> Effect
Tremolo :: (Maybe Int) -> (Maybe Int) -> Effect
FinePanning :: Float -> Effect
SampleOffset :: Int -> Effect
VolumeSlide :: (Maybe Float) -> Effect
OrderJump :: Int -> Effect
SetVolume :: Float -> Effect
PatternBreak :: Int -> Effect
FinePortamento :: PortaParam -> Effect
SetVibratoWaveform :: Waveform -> Effect
FineTuneControl :: Float -> Effect
PatternLoop :: (Maybe Int) -> Effect
SetTremoloWaveform :: Waveform -> Effect
RetrigNote :: Int -> Effect
FineVolumeSlide :: (Maybe Float) -> Effect
NoteCut :: Int -> Effect
NoteDelay :: Int -> Effect
PatternDelay :: Int -> Effect
SetTempo :: Int -> Effect
SetBPM :: Int -> Effect
data PortaParam
LastUp :: PortaParam
LastDown :: PortaParam
Porta :: Int -> PortaParam

-- | The possible waveforms of the vibrato and tremolo effects.
data Waveform
SineWave :: Waveform
SawtoothWave :: Waveform
SquareWave :: Waveform

-- | Waveforms needed for vibrato and tremolo effects. The lists are
--   infinite.
waveForms :: [(Waveform, [Float])]
data Instrument
Instrument :: Int -> String -> WaveData -> Float -> Float -> Instrument

-- | Instrument number, needed for equality check.
ident :: Instrument -> Int

-- | Instrument name.
name :: Instrument -> String

-- | List of samples; infinite for looped instruments.
wave :: Instrument -> WaveData

-- | Default volume (0..1).
volume :: Instrument -> Float

-- | Fine tune (-log_12 2..log_12 2).
fineTune :: Instrument -> Float

-- | A silent instrument that's not equal to any other in a loaded song.
emptyInstrument :: Instrument
type WaveData = [Float]
instance Eq Waveform
instance Show PortaParam
instance Show Effect
instance Show Waveform
instance Show Note
instance Show Instrument
instance Eq Instrument
instance Show Song


-- | This module contains the loading function. The supported formats are
--   the following 31-instrument ProTracker variants: M.K., M!K!, FLT4,
--   FLT8, 4CHN, 6CHN, 8CHN, 16CH, 32CH.
module Sound.Hemkay.Loader

-- | Load a song. Some exception is thrown in case of failure.
loadModule :: FilePath -> IO Song


-- | This module contains the routines to turn a song into a stream of
--   floating point samples. Some intermediate structures are also made
--   available to allow more fine-grain control over playback.
module Sound.Hemkay.Mixer

-- | The frequency at which mixer output should be played back. For the
--   time being, this is a fixed value.
sampleFrequency :: Float
data Sample
Smp :: !Float -> !Float -> Sample
leftChannel :: Sample -> !Float
rightChannel :: Sample -> !Float

-- | The state of the player upon entering a tick.
data PlayState
PS :: Int -> Int -> Maybe [Note] -> [ChannelState] -> PlayState

-- | The current tempo
psTempo :: PlayState -> Int

-- | The current BPM
psBPM :: PlayState -> Int

-- | The current row during its first tick, <a>Nothing</a> in subsequent
--   ticks
psRow :: PlayState -> Maybe [Note]

-- | The state of the channels
psChannels :: PlayState -> [ChannelState]

-- | The initial state of the player given the number of channels.
startState :: Int -> PlayState

-- | The state of a channel upon entering a tick.
data ChannelState
CS :: WaveData -> Int -> Float -> Float -> Float -> Float -> Instrument -> [Effect] -> Float -> Int -> Int -> Int -> Int -> Int -> Float -> Float -> Int -> Float -> [Float] -> Int -> Float -> [Float] -> Float -> Int -> Instrument -> ChannelState
csWaveData :: ChannelState -> WaveData
csPeriod :: ChannelState -> Int
csFineTune :: ChannelState -> Float
csSubSample :: ChannelState -> Float
csSampleStep :: ChannelState -> Float
csVolume :: ChannelState -> Float
csInstrument :: ChannelState -> Instrument
csEffect :: ChannelState -> [Effect]
csPanning :: ChannelState -> Float
csPortaDown :: ChannelState -> Int
csPortaUp :: ChannelState -> Int
csFinePorta :: ChannelState -> Int
csTonePortaEnd :: ChannelState -> Int
csTonePortaSpeed :: ChannelState -> Int
csVolumeSlide :: ChannelState -> Float
csFineVolumeSlide :: ChannelState -> Float
csVibratoSpeed :: ChannelState -> Int
csVibratoAmp :: ChannelState -> Float
csVibratoWave :: ChannelState -> [Float]
csTremoloSpeed :: ChannelState -> Int
csTremoloAmp :: ChannelState -> Float
csTremoloWave :: ChannelState -> [Float]
csTremoloDiff :: ChannelState -> Float
csDelayedPeriod :: ChannelState -> Int
csDelayedInstrument :: ChannelState -> Instrument
type ChunkMixState = (Int, [(WaveData, Float, Int, Float, Float, Float)])
type SongMixState = [ChunkMixState]

-- | Create a mixer state from a player state. This basically strips away a
--   lot of unnecessary information and throws away the channels that don't
--   contribute to the output in the given chunk.
prepareMix :: PlayState -> ChunkMixState

-- | Given a pointer to a float buffer and a number of samples desired (n),
--   mix the appropriate amount of the song and return the mix state for
--   the remainder or <a>Nothing</a> if finished. This is the most
--   efficient way to render a song. Note that each sample consists of two
--   floats, so the buffer has to be able to hold 2*n floats. The initial
--   song mix state can be simply created by <tt><a>map</a>
--   <a>prepareMix</a> . <a>performSong</a></tt>.
mixToBuffer :: Ptr Float -> Int -> SongMixState -> IO (Maybe SongMixState)

-- | Mix a single sample given a chunk mix state. Returns <a>Nothing</a> at
--   the end of the chunk.
nextSample :: ChunkMixState -> Maybe (Sample, ChunkMixState)

-- | Mix a whole song in chunks, pairing up the play states with the
--   respective chunks.
mixSong :: Song -> [(PlayState, [Sample])]

-- | Mix a single chunk given a play state. It's equivalent to
--   <tt><a>unfoldr</a> <a>nextSample</a> . <a>prepareMix</a></tt>.
mixChunk :: PlayState -> [Sample]

-- | Turn a song into a series of play states, one for each tick. It's a
--   shorthand for <tt><a>performTicks</a> . <a>flattenSong</a></tt>.
performSong :: Song -> [PlayState]

-- | Turn a song into a series of pattern rows. This includes handling
--   control structures like pattern breaks, delays and loops. Order jumps
--   are ignored.
flattenSong :: Song -> [[Note]]

-- | Turn a list of rows into a list of play states. Each row gives birth
--   to a number of play states equal to the tempo on that row.
performTicks :: [[Note]] -> [PlayState]
instance Show ChannelState
instance Show PlayState


-- | Hemkay (An M.K. Player Whose Name Starts with an H) is a simple music
--   module player that performs all the mixing in Haskell. It supports the
--   popular ProTracker format and some of its variations with different
--   numbers of channels. This package contains all the device independent
--   mixing routines of the player.
--   
--   Import this module to gain access to all the functionality, i.e. the
--   ability to load MOD files and serialise them into sound samples in
--   various ways.
module Sound.Hemkay
