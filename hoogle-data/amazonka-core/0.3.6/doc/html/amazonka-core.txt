-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core functionality and data types for Amazonka libraries.
--   
@package amazonka-core
@version 0.3.6


-- | Serialisation classes and primitives for the various formats used to
--   communicate with AWS.
module Network.AWS.Data
type LazyByteString = ByteString
class ToByteString a where toBS = encodeUtf8 . toText
toBS :: ToByteString a => a -> ByteString
class ToBuilder a where build = build . toBS
build :: ToBuilder a => a -> Builder
showBS :: ToByteString a => a -> String
buildBS :: ToBuilder a => a -> LazyByteString
stripBS :: ByteString -> ByteString

-- | Base64 encoded binary data.
--   
--   Encoding<i>decoding is deferred to serialisation</i>deserialisation
--   respectively.
newtype Base64
Base64 :: ByteString -> Base64
unBase64 :: Base64 -> ByteString
class FromText a
parser :: FromText a => Parser a
fromText :: FromText a => Text -> Either String a
takeLowerText :: Parser Text
matchCI :: Text -> a -> Parser a
class ToText a
toText :: ToText a => a -> Text
showText :: ToText a => a -> String
newtype Nat
Nat :: Natural -> Nat
unNat :: Nat -> Natural
_Nat :: Iso' Nat Natural
data Format
RFC822Format :: Format
ISO8601Format :: Format
BasicFormat :: Format
AWSFormat :: Format
POSIXFormat :: Format
data Time :: Format -> *
Time :: UTCTime -> Time a
_Time :: Iso' (Time a) UTCTime

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data UTCTime :: *
type RFC822 = Time RFC822Format
type ISO8601 = Time ISO8601Format
type BasicTime = Time BasicFormat
type AWSTime = Time AWSFormat
type POSIX = Time POSIXFormat

-- | Parses a time value given a format string. Supports the same %-codes
--   as <tt>formatTime</tt>, including <tt>%-</tt>, <tt>%_</tt> and
--   <tt>%0</tt> modifiers. Leading and trailing whitespace is accepted.
--   Case is not significant. Some variations in the input are accepted:
--   
--   <ul>
--   <li><i><tt>%z</tt></i> accepts any of <tt>-HHMM</tt> or
--   <tt>-HH:MM</tt>.</li>
--   <li><i><tt>%Z</tt></i> accepts any string of letters, or any of the
--   formats accepted by <tt>%z</tt>.</li>
--   <li><i><tt>%0Y</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0G</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0C</tt></i> accepts exactly two digits.</li>
--   <li><i><tt>%0f</tt></i> accepts exactly two digits.</li>
--   </ul>
parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
defaultTimeLocale :: TimeLocale

-- | Construct format string according to <a>ISO-8601</a>.
--   
--   The <tt>Maybe String</tt> argument allows to supply an optional time
--   specification. E.g.:
--   
--   <pre>
--   <a>iso8601DateFormat</a> Nothing            == "%Y-%m-%d"           -- i.e. <tt><i>YYYY-MM-DD</i></tt>
--   <a>iso8601DateFormat</a> (Just "%H:%M:%S")  == "%Y-%m-%dT%H:%M:%S"  -- i.e. <tt><i>YYYY-MM-DD</i>T<i>HH:MM:SS</i></tt>
--   </pre>
iso8601DateFormat :: Maybe String -> String

-- | read . show /= isomorphic
newtype Sensitive a
Sensitive :: a -> Sensitive a
desensitise :: Sensitive a -> a
_Sensitive :: Iso' (Sensitive a) a
data RsBody
RsBody :: (ResumableSource (ResourceT IO) ByteString) -> RsBody
_RsBody :: Iso' RsBody (ResumableSource (ResourceT IO) ByteString)
connectBody :: MonadResource m => RsBody -> Sink ByteString m a -> m a
data RqBody
RqBody :: Digest SHA256 -> RequestBody -> RqBody
_bdyHash :: RqBody -> Digest SHA256
_bdyBody :: RqBody -> RequestBody
bdyHash :: Lens' RqBody (Digest SHA256)
bdyBody :: Lens' RqBody RequestBody
bodyHash :: RqBody -> ByteString
isStreaming :: RqBody -> Bool
class ToBody a where toBody = const (RqBody (hash "") (RequestBodyLBS mempty))
toBody :: ToBody a => a -> RqBody
(~:) :: FromText a => ResponseHeaders -> HeaderName -> Either String a
(~:?) :: FromText a => ResponseHeaders -> HeaderName -> Either String (Maybe a)
class ToHeaders a where toHeaders = const mempty
toHeaders :: ToHeaders a => a -> [Header]
(=:) :: ToHeader a => HeaderName -> a -> [Header]
hdr :: HeaderName -> ByteString -> [Header] -> [Header]
hdrs :: [Header] -> [Header] -> [Header]
toHeaderText :: ToText a => HeaderName -> a -> [Header]
class ToHeader a where toHeader k = toHeader k . toText
toHeader :: ToHeader a => HeaderName -> a -> [Header]
hHost :: HeaderName
hAMZToken :: HeaderName
hAMZTarget :: HeaderName
hAMZAlgorithm :: HeaderName
hAMZCredential :: HeaderName
hAMZExpires :: HeaderName
hAMZSignedHeaders :: HeaderName
hAMZContentSHA256 :: HeaderName
hAMZAuth :: HeaderName
hAMZDate :: HeaderName
hMetaPrefix :: HeaderName
class ToPath a where toPath = const mempty
toPath :: ToPath a => a -> Text
class ToQuery a where toQuery = toQuery . toText
toQuery :: ToQuery a => a -> Query
renderQuery :: Query -> ByteString
data Query
valuesOf :: Traversal' Query (Maybe ByteString)
(=?) :: ToQuery a => ByteString -> a -> Query
pair :: ToQuery a => ByteString -> a -> Query -> Query
toQueryList :: (IsList a, ToQuery (Item a)) => ByteString -> a -> Query
collapsePath :: ByteString -> ByteString
class FromXML a
parseXML :: FromXML a => [Node] -> Either String a
decodeXML :: LazyByteString -> Either String [Node]
parseXMLText :: FromText a => String -> [Node] -> Either String a
childNodes :: Text -> Node -> Maybe [Node]
findElement :: Text -> [Node] -> Either String [Node]
withContent :: String -> [Node] -> Either String (Maybe Text)
withElement :: Text -> ([Node] -> Either String a) -> [Node] -> Either String a
localName :: Node -> Maybe Text
(.@) :: FromXML a => [Node] -> Text -> Either String a
(.@?) :: FromXML a => [Node] -> Text -> Either String (Maybe a)
(.!@) :: Either String (Maybe a) -> a -> Either String a
class ToXML a where toXML = maybeToList . fmap NodeElement . toXMLRoot
toXML :: ToXML a => a -> [Node]
class ToXMLRoot a
toXMLRoot :: ToXMLRoot a => a -> Maybe Element
encodeXML :: ToXMLRoot a => a -> LazyByteString
toXMLText :: ToText a => a -> [Node]
namespaced :: Text -> Text -> [Node] -> Maybe Element
element :: Name -> [Node] -> Element
nodes :: Name -> [Node] -> [Node]
(=@) :: ToXML a => Name -> a -> Node
extractRoot :: Text -> [Node] -> Maybe Element

-- | <i>Caution:</i> This is for use with types which are
--   <tt>flattened</tt> in AWS service model terminology.
--   
--   It is applied by the generator/templating in safe contexts only.
unsafeToXML :: (Show a, ToXML a) => a -> Node

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = Coord    <tt>&lt;$&gt;</tt>
--                            v <tt>.:</tt> "x" <tt>&lt;*&gt;</tt>
--                            v <tt>.:</tt> "y"
--   
--     -- A non-<a>Object</a> value is of the wrong type, so use <tt>mzero</tt> to fail.
--     parseJSON _          = <tt>mzero</tt>
--   </pre>
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord
--   </pre>
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONText :: FromText a => String -> Value -> Parser a

-- | Like <a>decode'</a> but returns an error message when decoding fails.
eitherDecode' :: FromJSON a => ByteString -> Either String a

-- | <tt>withObject expected f value</tt> applies <tt>f</tt> to the
--   <a>Object</a> when <tt>value</tt> is an <tt>Object</tt> and fails
--   using <tt><a>typeMismatch</a> expected</tt> otherwise.
withObject :: String -> (Object -> Parser a) -> Value -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>empty</a> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use '(.:?)' instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <a>empty</a> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use '(.:)' instead.
(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use '(.:)'
--   instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a
(.:>) :: FromJSON a => Object -> Text -> Either String a
(.:?>) :: FromJSON a => Object -> Text -> Either String (Maybe a)

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where toJSON (Coord x y) = <a>object</a> ["x"
--   <tt>.=</tt> x, "y" <tt>.=</tt> y] @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>toJSON</tt>
--   function that accepts any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (GHC 7.2 and newer),
--   <tt>toJSON</tt> will have a default generic implementation.</li>
--   </ul>
--   
--   To use the latter option, simply add a <tt>deriving
--   <a>Generic</a></tt> clause to your datatype and declare a
--   <tt>ToJSON</tt> instance for your datatype without giving a definition
--   for <tt>toJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic encoding using
--   <a>genericToJSON</a> applied to your encoding/decoding <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON = <a>genericToJSON</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a
toJSON :: ToJSON a => a -> Value
toJSONText :: ToText a => a -> Value

-- | A JSON "object" (key/value map).
type Object = HashMap Text Value

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | Construct a <a>Pair</a> from a key and a value.
(.=) :: ToJSON a => Text -> a -> Pair
newtype List (e :: Symbol) a
List :: [a] -> List a
list :: List a -> [a]
newtype List1 (e :: Symbol) a
List1 :: NonEmpty a -> List1 a
list1 :: List1 a -> NonEmpty a
_List :: (Coercible a b, Coercible b a) => Iso' (List e a) [b]
_List1 :: (Coercible a b, Coercible b a) => Iso' (List1 e a) (NonEmpty b)
fromList1 :: List1 e a -> List e a
toList1 :: List e a -> Either String (List1 e a)
newtype Map k v
Map :: HashMap k v -> Map k v
fromMap :: Map k v -> HashMap k v
_Map :: (Coercible a b, Coercible b a) => Iso' (Map k a) (HashMap k b)
(~::) :: ResponseHeaders -> CI Text -> Either String (Map (CI Text) Text)
newtype EMap (e :: Symbol) (i :: Symbol) (j :: Symbol) k v
EMap :: HashMap k v -> EMap k v
fromEMap :: EMap k v -> HashMap k v
_EMap :: (Coercible a b, Coercible b a) => Iso' (EMap e i j k a) (HashMap k b)

module Network.AWS.Types

-- | Access key credential.
newtype AccessKey
AccessKey :: ByteString -> AccessKey

-- | Secret key credential.
newtype SecretKey
SecretKey :: ByteString -> SecretKey

-- | A security token used by STS to temporarily authorise access to an AWS
--   resource.
newtype SecurityToken
SecurityToken :: ByteString -> SecurityToken

-- | The authorisation environment.
data AuthEnv
AuthEnv :: !AccessKey -> !SecretKey -> Maybe SecurityToken -> Maybe UTCTime -> AuthEnv
_authAccess :: AuthEnv -> !AccessKey
_authSecret :: AuthEnv -> !SecretKey
_authToken :: AuthEnv -> Maybe SecurityToken
_authExpiry :: AuthEnv -> Maybe UTCTime

-- | An authorisation environment containing AWS credentials, and
--   potentially a reference which can be refreshed out-of-band as
--   temporary credentials expire.
data Auth
Ref :: ThreadId -> (IORef AuthEnv) -> Auth
Auth :: AuthEnv -> Auth
withAuth :: MonadIO m => Auth -> (AuthEnv -> m a) -> m a

-- | The properties (such as endpoint) for a service, as well as it's
--   associated signing algorithm and error types.
class (AWSSigner (Sg a), Show (Er a)) => AWSService a where type family Sg a :: * type family Er a :: *
service :: AWSService a => Service a

-- | Abbreviated service name.
type Abbrev = Text

-- | Attributes specific to an AWS service.
data Service a
Service :: !Text -> !ByteString -> !ByteString -> Maybe ByteString -> Maybe ByteString -> (Status -> Maybe (LazyByteString -> ServiceError (Er a))) -> Retry a -> Service a
_svcAbbrev :: Service a -> !Text
_svcPrefix :: Service a -> !ByteString
_svcVersion :: Service a -> !ByteString
_svcTargetPrefix :: Service a -> Maybe ByteString
_svcJSONVersion :: Service a -> Maybe ByteString
_svcHandle :: Service a -> Status -> Maybe (LazyByteString -> ServiceError (Er a))
_svcRetry :: Service a -> Retry a
serviceOf :: AWSService (Sv a) => Request a -> Service (Sv a)

-- | Constants and predicates used to create a <tt>RetryPolicy</tt>.
data Retry a
Exponential :: !Double -> !Int -> !Int -> (Status -> Er a -> Bool) -> Retry a
_retryBase :: Retry a -> !Double
_retryGrowth :: Retry a -> !Int
_retryAttempts :: Retry a -> !Int
_retryCheck :: Retry a -> Status -> Er a -> Bool
data Endpoint
Endpoint :: ByteString -> ByteString -> Endpoint
_endpointHost :: Endpoint -> ByteString
_endpointScope :: Endpoint -> ByteString

-- | Determine the full host address and credential scope for a
--   <a>Service</a> within the specified <a>Region</a>.
endpoint :: Service a -> Region -> Endpoint

-- | An error type representing the subset of errors that can be directly
--   attributed to this library.
data ServiceError a
HttpError :: HttpException -> ServiceError a
SerializerError :: Abbrev -> String -> ServiceError a
ServiceError :: Abbrev -> Status -> a -> ServiceError a
Errors :: [ServiceError a] -> ServiceError a
_HttpError :: Prism' (ServiceError a_avh9) HttpException
_SerializerError :: Prism' (ServiceError a_avh9) (Abbrev, String)
_ServiceError :: Prism' (ServiceError a_avh9) (Abbrev, Status, a_avh9)
_Errors :: Prism' (ServiceError a_avh9) [ServiceError a_avh9]
class AWSSigner v
signed :: (AWSSigner v, AWSService (Sv a), v ~ Sg (Sv a)) => AuthEnv -> Region -> Request a -> UTCTime -> Signed a v
class AWSPresigner v
presigned :: (AWSPresigner v, AWSService (Sv a), v ~ Sg (Sv a)) => AuthEnv -> Region -> Request a -> UTCTime -> Integer -> Signed a v

-- | A signed <a>ClientRequest</a> and associated metadata specific to the
--   signing algorithm that was used.
data Signed a v
Signed :: Meta v -> ClientRequest -> Signed a v
_sgMeta :: Signed a v -> Meta v
_sgRequest :: Signed a v -> ClientRequest

-- | Signing metadata data specific to a signing algorithm.
--   
--   <i>Note:</i> this is used for test and debug purposes, or is otherwise
--   ignored.
sgMeta :: Lens' (Signed a v) (Meta v)
sgRequest :: Lens' (Signed a v) ClientRequest

-- | Specify how a request can be de/serialised.
class (AWSService (Sv a), AWSSigner (Sg (Sv a))) => AWSRequest a where type family Sv a :: * type family Rs a :: *
request :: AWSRequest a => a -> Request a
response :: (AWSRequest a, MonadResource m) => Logger -> Request a -> Either HttpException ClientResponse -> m (Response' a)

-- | Specify how an <a>AWSRequest</a> and it's associated <a>Rs</a>
--   response can generate a subsequent request, if available.
class AWSRequest a => AWSPager a
page :: AWSPager a => a -> Rs a -> Maybe a

-- | An unsigned request.
data Request a
Request :: !StdMethod -> !ByteString -> Query -> [Header] -> RqBody -> Request a
_rqMethod :: Request a -> !StdMethod
_rqPath :: Request a -> !ByteString
_rqQuery :: Request a -> Query
_rqHeaders :: Request a -> [Header]
_rqBody :: Request a -> RqBody
rqMethod :: Lens (Request a_avgl) (Request a_awmY) StdMethod StdMethod
rqHeaders :: Lens (Request a_avgl) (Request a_awmX) [Header] [Header]
rqPath :: Lens (Request a_avgl) (Request a_awmZ) ByteString ByteString
rqQuery :: Lens (Request a_avgl) (Request a_awn0) Query Query
rqBody :: Lens (Request a_avgl) (Request a_awmW) RqBody RqBody

-- | An alias for the common response <a>Either</a> containing a service
--   error in the <a>Left</a> case, or the expected response in the
--   <a>Right</a>.
type Response a = Either (ServiceError (Er (Sv a))) (Rs a)
type Response' a = Either (ServiceError (Er (Sv a))) (Status, Rs a)
data Empty
Empty :: Empty
data LogLevel

-- | Informational messages supplied by the user, not used by the library.
Info :: LogLevel

-- | Info level + debug messages + non-streaming response bodies.
Debug :: LogLevel

-- | Debug level + potentially sensitive signing metadata.
Trace :: LogLevel
type Logger = LogLevel -> Builder -> IO ()

-- | The sum of available AWS regions.
data Region

-- | Europe / eu-west-1
Ireland :: Region

-- | Europe / eu-central-1
Frankfurt :: Region

-- | Asia Pacific / ap-northeast-1
Tokyo :: Region

-- | Asia Pacific / ap-southeast-1
Singapore :: Region

-- | Asia Pacific / ap-southeast-2
Sydney :: Region

-- | China / cn-north-1
Beijing :: Region

-- | US / us-east-1
NorthVirginia :: Region

-- | US / us-west-1
NorthCalifornia :: Region

-- | US / us-west-2
Oregon :: Region

-- | AWS GovCloud / us-gov-west-1
GovCloud :: Region

-- | AWS GovCloud (FIPS 140-2) S3 Only / fips-us-gov-west-1
GovCloudFIPS :: Region

-- | South America / sa-east-1
SaoPaulo :: Region

-- | A service's query action.
newtype Action
Action :: Text -> Action

-- | A convenience alias to avoid type ambiguity.
type ClientRequest = Request

-- | A convenience alias encapsulating the common <a>Response</a>.
type ClientResponse = Response ResponseBody

-- | A convenience alias encapsulating the common <a>Response</a> body.
type ResponseBody = ResumableSource (ResourceT IO) ByteString

-- | Construct a <a>ClientRequest</a> using common parameters such as TLS
--   and prevent throwing errors when receiving erroneous status codes in
--   respones.
clientRequest :: ClientRequest
instance Typeable ServiceError
instance Show a => Show (ServiceError a)
instance Eq LogLevel
instance Ord LogLevel
instance Enum LogLevel
instance Show LogLevel
instance Eq AccessKey
instance Show AccessKey
instance IsString AccessKey
instance ToText AccessKey
instance ToByteString AccessKey
instance ToBuilder AccessKey
instance Eq SecretKey
instance IsString SecretKey
instance ToText SecretKey
instance ToByteString SecretKey
instance Eq SecurityToken
instance IsString SecurityToken
instance ToText SecurityToken
instance ToByteString SecurityToken
instance Eq Endpoint
instance Show Endpoint
instance Eq Region
instance Ord Region
instance Read Region
instance Show Region
instance Generic Region
instance Eq Action
instance Ord Action
instance Show Action
instance IsString Action
instance ToText Action
instance ToByteString Action
instance Eq Empty
instance Show Empty
instance Datatype D1Region
instance Constructor C1_0Region
instance Constructor C1_1Region
instance Constructor C1_2Region
instance Constructor C1_3Region
instance Constructor C1_4Region
instance Constructor C1_5Region
instance Constructor C1_6Region
instance Constructor C1_7Region
instance Constructor C1_8Region
instance Constructor C1_9Region
instance Constructor C1_10Region
instance Constructor C1_11Region
instance ToJSON Empty
instance ToXML Region
instance FromXML Region
instance ToBuilder Region
instance ToByteString Region
instance ToText Region
instance FromText Region
instance Default Region
instance Hashable Region
instance ToBuilder (Request a)
instance Default (Request a)
instance ToBuilder Auth
instance ToBuilder AuthEnv
instance FromJSON AuthEnv
instance Monoid (ServiceError a)
instance (Show a, Typeable a) => Exception (ServiceError a)

module Network.AWS.Error
statusSuccess :: Status -> Bool
class AWSError a
awsError :: AWSError a => a -> ServiceError String
class AWSErrorCode a
awsErrorCode :: AWSErrorCode a => a -> Maybe ErrorCode
newtype ErrorCode
ErrorCode :: Text -> ErrorCode
data ErrorType
Receiver :: ErrorType
Sender :: ErrorType

-- | An error type representing the subset of errors that can be directly
--   attributed to this library.
data ServiceError a
HttpError :: HttpException -> ServiceError a
SerializerError :: Abbrev -> String -> ServiceError a
ServiceError :: Abbrev -> Status -> a -> ServiceError a
Errors :: [ServiceError a] -> ServiceError a
data RESTError
restRequestId :: Lens' RESTError Text
restType :: Lens' RESTError (Maybe ErrorType)
restCode :: Lens' RESTError (Maybe ErrorCode)
restMessage :: Lens' RESTError Text
restError :: FromXML (Er a) => (Status -> Bool) -> Service a -> Status -> Maybe (ByteString -> ServiceError (Er a))
data JSONError
jsonType :: Lens' JSONError (Maybe Text)
jsonCode :: Lens' JSONError (Maybe ErrorCode)
jsonMessage :: Lens' JSONError Text
jsonError :: FromJSON (Er a) => (Status -> Bool) -> Service a -> Status -> Maybe (ByteString -> ServiceError (Er a))
instance FromJSON JSONError
instance AWSErrorCode JSONError
instance Eq JSONError
instance Show JSONError
instance Generic JSONError
instance Datatype D1JSONError
instance Constructor C1_0JSONError
instance Selector S1_0_0JSONError
instance Selector S1_0_1JSONError
instance Selector S1_0_2JSONError
instance FromXML RESTError
instance AWSErrorCode RESTError
instance Eq ErrorCode
instance Ord ErrorCode
instance Show ErrorCode
instance FromXML ErrorCode
instance FromJSON ErrorCode
instance IsString ErrorCode
instance Generic ErrorCode
instance Eq ErrorType
instance Ord ErrorType
instance Enum ErrorType
instance Show ErrorType
instance Generic ErrorType
instance Eq RESTError
instance Show RESTError
instance Generic RESTError
instance Datatype D1ErrorCode
instance Constructor C1_0ErrorCode
instance Datatype D1ErrorType
instance Constructor C1_0ErrorType
instance Constructor C1_1ErrorType
instance Datatype D1RESTError
instance Constructor C1_0RESTError
instance Selector S1_0_0RESTError
instance Selector S1_0_1RESTError
instance Selector S1_0_2RESTError
instance Selector S1_0_3RESTError
instance FromXML ErrorType
instance FromText ErrorType
instance Show a => AWSError (ServiceError a)

module Network.AWS.Pagination
more :: AWSMore a => a -> Bool
stop :: AWSMore a => a -> Bool
index :: ToText c => Getter a [b] -> Getter b c -> Getter a (Maybe Text)
choice :: Alternative f => (a -> f b) -> (a -> f b) -> a -> f b
instance AWSMore (HashMap k v)
instance AWSMore [a]
instance AWSMore (Maybe Text)
instance AWSMore (Maybe Bool)
instance AWSMore Bool

module Network.AWS.Response
nullResponse :: (MonadResource m, AWSService (Sv a)) => Rs a -> Logger -> Request a -> Either HttpException ClientResponse -> m (Response' a)
headerResponse :: (MonadResource m, AWSService (Sv a)) => (ResponseHeaders -> Either String (Rs a)) -> Logger -> Request a -> Either HttpException ClientResponse -> m (Response' a)
xmlResponse :: (MonadResource m, AWSService (Sv a), FromXML (Rs a)) => Logger -> Request a -> Either HttpException ClientResponse -> m (Response' a)
xmlHeaderResponse :: (MonadResource m, AWSService (Sv a)) => (ResponseHeaders -> [Node] -> Either String (Rs a)) -> Logger -> Request a -> Either HttpException ClientResponse -> m (Response' a)
jsonResponse :: (MonadResource m, AWSService (Sv a), FromJSON (Rs a)) => Logger -> Request a -> Either HttpException ClientResponse -> m (Response' a)
jsonHeaderResponse :: (MonadResource m, AWSService (Sv a)) => (ResponseHeaders -> Int -> Object -> Either String (Rs a)) -> Logger -> Request a -> Either HttpException ClientResponse -> m (Response' a)
bodyResponse :: (MonadResource m, AWSService (Sv a)) => (ResponseHeaders -> Int -> ResponseBody -> Either String (Rs a)) -> Logger -> Request a -> Either HttpException ClientResponse -> m (Response' a)

module Network.AWS.Prelude

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString :: *

-- | A <tt>CI s</tt> provides <i>C</i>ase <i>I</i>nsensitive comparison for
--   the string-like type <tt>s</tt> (for example: <tt>String</tt>,
--   <a>Text</a>, <a>ByteString</a>, etc.).
--   
--   Note that <tt>CI s</tt> has an instance for <a>IsString</a> which
--   together with the <tt>OverloadedStrings</tt> language extension allows
--   you to write case insensitive string literals as in:
--   
--   <pre>
--   &gt; ("Content-Type" :: <a>CI</a> <a>Text</a>) == ("CONTENT-TYPE" :: <a>CI</a> <a>Text</a>)
--   True
--   </pre>
data CI s :: * -> *

-- | A convenience alias to avoid type ambiguity.
type ClientRequest = Request

-- | A convenience alias encapsulating the common <a>Response</a>.
type ClientResponse = Response ResponseBody

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable * e, Show e) => Exception e

-- | A map from keys to values. A map cannot contain duplicate keys; each
--   key can map to at most one value.
data HashMap k v :: * -> * -> *
data HttpException :: *

-- | Type representing arbitrary-precision non-negative integers.
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>.
--   
--   The <a>Natural</a> type has become part of <tt>base</tt> starting with
--   `base-4.8.0.0`.
data Natural :: *
data NonEmpty a :: * -> *
(:|) :: a -> [a] -> NonEmpty a

-- | When using one of the <a>RequestBodyStream</a> /
--   <a>RequestBodyStreamChunked</a> constructors, you must ensure that the
--   <a>GivesPopper</a> can be called multiple times. Usually this is not a
--   problem.
--   
--   The <a>RequestBodyStreamChunked</a> will send a chunked request body.
--   Note that not all servers support this. Only use
--   <a>RequestBodyStreamChunked</a> if you know the server you're sending
--   to supports chunked request bodies.
--   
--   Since 0.1.0
data RequestBody :: *

-- | An alias for the common response <a>Either</a> containing a service
--   error in the <a>Left</a> case, or the expected response in the
--   <a>Right</a>.
type Response a = Either (ServiceError (Er (Sv a))) (Rs a)

-- | A space efficient, packed, unboxed Unicode text type.
data Text :: *

-- | Specify how an <a>AWSRequest</a> and it's associated <a>Rs</a>
--   response can generate a subsequent request, if available.
class AWSRequest a => AWSPager a
page :: AWSPager a => a -> Rs a -> Maybe a

-- | Specify how a request can be de/serialised.
class (AWSService (Sv a), AWSSigner (Sg (Sv a))) => AWSRequest a where type family Sv a :: * type family Rs a :: *
request :: AWSRequest a => a -> Request a
response :: (AWSRequest a, MonadResource m) => Logger -> Request a -> Either HttpException ClientResponse -> m (Response' a)

-- | The properties (such as endpoint) for a service, as well as it's
--   associated signing algorithm and error types.
class (AWSSigner (Sg a), Show (Er a)) => AWSService a where type family Sg a :: * type family Er a :: *
service :: AWSService a => Service a

-- | Representable types of kind *. This class is derivable in GHC with the
--   DeriveGeneric flag on.
class Generic a

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a
class Semigroup a

-- | Constants and predicates used to create a <tt>RetryPolicy</tt>.
data Retry a
Exponential :: !Double -> !Int -> !Int -> (Status -> Er a -> Bool) -> Retry a
_retryBase :: Retry a -> !Double
_retryGrowth :: Retry a -> !Int
_retryAttempts :: Retry a -> !Int
_retryCheck :: Retry a -> Status -> Er a -> Bool
class AWSError a
awsError :: AWSError a => a -> ServiceError String
class AWSErrorCode a
awsErrorCode :: AWSErrorCode a => a -> Maybe ErrorCode

-- | An error type representing the subset of errors that can be directly
--   attributed to this library.
data ServiceError a
HttpError :: HttpException -> ServiceError a
SerializerError :: Abbrev -> String -> ServiceError a
ServiceError :: Abbrev -> Status -> a -> ServiceError a
Errors :: [ServiceError a] -> ServiceError a
data RESTError
restError :: FromXML (Er a) => (Status -> Bool) -> Service a -> Status -> Maybe (ByteString -> ServiceError (Er a))
data JSONError
jsonError :: FromJSON (Er a) => (Status -> Bool) -> Service a -> Status -> Maybe (ByteString -> ServiceError (Er a))
statusSuccess :: Status -> Bool
data Empty
Empty :: Empty

-- | Attributes specific to an AWS service.
data Service a
Service :: !Text -> !ByteString -> !ByteString -> Maybe ByteString -> Maybe ByteString -> (Status -> Maybe (LazyByteString -> ServiceError (Er a))) -> Retry a -> Service a
_svcAbbrev :: Service a -> !Text
_svcPrefix :: Service a -> !ByteString
_svcVersion :: Service a -> !ByteString
_svcTargetPrefix :: Service a -> Maybe ByteString
_svcJSONVersion :: Service a -> Maybe ByteString
_svcHandle :: Service a -> Status -> Maybe (LazyByteString -> ServiceError (Er a))
_svcRetry :: Service a -> Retry a

-- | HTTP standard method (as defined by RFC 2616, and PATCH which is
--   defined by RFC 5789).
data StdMethod :: *
GET :: StdMethod
POST :: StdMethod
HEAD :: StdMethod
PUT :: StdMethod
DELETE :: StdMethod
TRACE :: StdMethod
CONNECT :: StdMethod
OPTIONS :: StdMethod
PATCH :: StdMethod

-- | HTTP Status.
--   
--   Only the <a>statusCode</a> is used for comparisons.
--   
--   Please use <a>mkStatus</a> to create status codes from code and
--   message, or the <a>Enum</a> instance or the status code constants
--   (like <a>ok200</a>). There might be additional record members in the
--   future.
--   
--   Note that the Show instance is only for debugging.
data Status :: *
Status :: Int -> ByteString -> Status
statusCode :: Status -> Int
statusMessage :: Status -> ByteString

module Network.AWS.Request.JSON
post :: (AWSService (Sv a), ToQuery a, ToPath a, ToHeaders a, ToJSON a) => Action -> a -> Request a

module Network.AWS.Request.Query
post :: (AWSService (Sv a), ToQuery a, ToPath a, ToHeaders a) => Action -> a -> Request a

module Network.AWS.Request.RestJSON
get :: (ToPath a, ToQuery a, ToHeaders a) => a -> Request a
delete :: (ToPath a, ToQuery a, ToHeaders a) => a -> Request a
post :: (AWSService (Sv a), ToQuery a, ToPath a, ToHeaders a, ToJSON a) => a -> Request a
put :: (AWSService (Sv a), ToQuery a, ToPath a, ToHeaders a, ToJSON a) => a -> Request a
stream :: (AWSService (Sv a), ToPath a, ToQuery a, ToHeaders a, ToBody a) => StdMethod -> a -> Request a

module Network.AWS.Request.RestXML
get :: (ToPath a, ToQuery a, ToHeaders a) => a -> Request a
head :: (ToPath a, ToQuery a, ToHeaders a) => a -> Request a
delete :: (ToPath a, ToQuery a, ToHeaders a) => a -> Request a
post :: (ToPath a, ToQuery a, ToHeaders a, ToXMLRoot a) => a -> Request a
put :: (ToPath a, ToQuery a, ToHeaders a, ToXMLRoot a) => a -> Request a

module Network.AWS.Request.S3
get :: (ToPath a, ToQuery a, ToHeaders a) => a -> Request a
head :: (ToPath a, ToQuery a, ToHeaders a) => a -> Request a
delete :: (ToPath a, ToQuery a, ToHeaders a) => a -> Request a
post :: (ToPath a, ToQuery a, ToHeaders a, ToXMLRoot a) => a -> Request a
put :: (ToPath a, ToQuery a, ToHeaders a, ToXMLRoot a) => a -> Request a
stream :: (ToPath a, ToQuery a, ToHeaders a, ToBody a) => StdMethod -> a -> Request a

module Network.AWS.Signing
data V2
data V4
sign :: (MonadIO m, AWSRequest a, AWSSigner (Sg (Sv a))) => Auth -> Region -> Request a -> UTCTime -> m (Signed a (Sg (Sv a)))
presign :: (MonadIO m, AWSRequest a, AWSPresigner (Sg (Sv a))) => Auth -> Region -> Request a -> UTCTime -> Integer -> m (Signed a (Sg (Sv a)))

module Network.AWS.Waiters
type Acceptor a = Request a -> Response' a -> Maybe Accept
data Accept
AcceptSuccess :: Accept
AcceptFailure :: Accept
AcceptRetry :: Accept

-- | Timing and acceptance criteria to check fulfillment of a remote
--   operation.
data Wait a
Wait :: !ByteString -> !Int -> !Int -> [Acceptor a] -> Wait a
_waitName :: Wait a -> !ByteString
_waitAttempts :: Wait a -> !Int
_waitDelay :: Wait a -> !Int
_waitAcceptors :: Wait a -> [Acceptor a]
accept :: Wait a -> Acceptor a
matchAll :: Eq b => b -> Accept -> Fold (Rs a) b -> Acceptor a
matchAny :: Eq b => b -> Accept -> Fold (Rs a) b -> Acceptor a
matchError :: AWSErrorCode (Er (Sv a)) => ErrorCode -> Accept -> Acceptor a
matchStatus :: Int -> Accept -> Acceptor a
nonEmpty :: Fold a Text -> Fold a Bool
instance Eq Accept
instance Show Accept
instance ToBuilder Accept
