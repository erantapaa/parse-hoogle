-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A functional embedded language for DSP and parallelism
--   
--   Feldspar (Functional Embedded Language for DSP and PARallelism) is an
--   embedded DSL for describing digital signal processing algorithms. This
--   package contains the language front-end and an interpreter.
@package feldspar-language
@version 0.7


-- | General interfaces to collections of data
module Feldspar.Core.Collection

-- | Collection element type

-- | Collection index type

-- | Collection size type

-- | Data structures that support indexing
class Indexed a
(!) :: Indexed a => a -> CollIndex a -> Elem a

-- | Sized data structures
class Sized a
collSize :: Sized a => a -> CollSize a
setCollSize :: Sized a => CollSize a -> a -> a

-- | Mapping over collections
class CollMap a b
collMap :: CollMap a b => (Elem a -> Elem b) -> a -> b


-- | General operations on sets
module Feldspar.Lattice

-- | Lattice types
class Eq a => Lattice a
bot :: Lattice a => a
top :: Lattice a => a
(\/) :: Lattice a => a -> a -> a
(/\) :: Lattice a => a -> a -> a
empty :: Lattice a => a
universal :: Lattice a => a

-- | Accumulated join
unions :: Lattice a => [a] -> a

-- | Accumulated meet
intersections :: Lattice a => [a] -> a

-- | Generalization of <a>fixedPoint</a> to functions whose argument and
--   result contain (i.e has a lens to) a common lattice
lensedFixedPoint :: Lattice lat => Lens a lat -> Lens b lat -> (a -> b) -> (a -> b)

-- | Generalization of <a>indexedFixedPoint</a> to functions whose argument
--   and result contain (i.e has a lens to) a common lattice
lensedIndexedFixedPoint :: Lattice lat => Lens a lat -> Lens b lat -> (Int -> a -> b) -> (a -> (b, Int))

-- | Take the fixed point of a function. The second argument is an initial
--   element. A sensible default for the initial element is <a>bot</a>.
--   
--   The function is not required to be monotonic. It is made monotonic
--   internally by always taking the union of the result and the previous
--   value.
fixedPoint :: Lattice a => (a -> a) -> a -> a

-- | Much like <a>fixedPoint</a> but keeps track of the number of
--   iterations in the fixed point iteration. Useful for defining widening
--   operators.
indexedFixedPoint :: Lattice a => (Int -> a -> a) -> a -> (a, Int)

-- | The type of widening operators. A widening operator modifies a
--   function that is subject to fixed point analysis. A widening operator
--   introduces approximations in order to guarantee (fast) termination of
--   the fixed point analysis.
type Widening a = (Int -> a -> a) -> (Int -> a -> a)

-- | A widening operator which defaults to <a>top</a> when the number of
--   iterations goes over the specified value.
cutOffAt :: Lattice a => Int -> Widening a

-- | A bounded version of <a>lensedFixedPoint</a>. It will always do at
--   least one iteration regardless of the provided bound (in order to
--   return something of the right type).
boundedLensedFixedPoint :: Lattice lat => Int -> Lens a lat -> Lens b lat -> (a -> b) -> (a -> (b, Int))
instance (Lattice a, Lattice b, Lattice c, Lattice d, Lattice e, Lattice f, Lattice g) => Lattice (a, b, c, d, e, f, g)
instance (Lattice a, Lattice b, Lattice c, Lattice d, Lattice e, Lattice f) => Lattice (a, b, c, d, e, f)
instance (Lattice a, Lattice b, Lattice c, Lattice d, Lattice e) => Lattice (a, b, c, d, e)
instance (Lattice a, Lattice b, Lattice c, Lattice d) => Lattice (a, b, c, d)
instance (Lattice a, Lattice b, Lattice c) => Lattice (a, b, c)
instance (Lattice a, Lattice b) => Lattice (a, b)
instance Lattice ()


-- | Bounded integer ranges
module Feldspar.Range

-- | A bounded range of values of type <tt>a</tt>
data Range a
Range :: a -> a -> Range a
lowerBound :: Range a -> a
upperBound :: Range a -> a

-- | Convenience alias for bounded integers
type BoundedInt a = (BoundedSuper a, BoundedSuper (UnsignedRep a))

-- | Super class to <a>BoundedInt</a>
class (Ord a, Num a, Bounded a, Integral a, Bits a) => BoundedSuper a
finiteBitSize :: Bits b => b -> Int

-- | Type famliy to determine the bit representation of a type

-- | Convert an <a>Integral</a> to its unsigned representation while
--   preserving bit width
unsigned :: (Integral a, Integral (UnsignedRep a)) => a -> UnsignedRep a

-- | A convenience function for defining range propagation. <tt>handleSign
--   propU propS</tt> chooses <tt>propU</tt> for unsigned types and
--   <tt>propS</tt> for signed types.
handleSign :: BoundedInt a => (Range a -> b) -> (Range a -> b) -> (Range a -> b)

-- | Shows a bound.
showBound :: (Show a, BoundedInt a) => a -> String

-- | A textual representation of ranges.
showRange :: (Show a, BoundedInt a) => Range a -> String

-- | Requires a monotonic function
mapMonotonic :: (a -> b) -> Range a -> Range b

-- | Requires a monotonic function
mapMonotonic2 :: (a -> b -> c) -> Range a -> Range b -> Range c

-- | The range containing no elements
emptyRange :: BoundedInt a => Range a

-- | The range containing all elements of a type
fullRange :: BoundedInt a => Range a

-- | Construct a range
range :: Ord a => a -> a -> Range a

-- | The range containing one element
singletonRange :: a -> Range a

-- | The range from <tt>0</tt> to the maximum element
naturalRange :: BoundedInt a => Range a

-- | The range from <tt>1</tt> to the maximum element
positiveRange :: BoundedInt a => Range a

-- | The range from the smallest negative element to <tt>-1</tt>. Undefined
--   for unsigned types
negativeRange :: BoundedInt a => Range a

-- | The size of a range. Beware that the size may not always be
--   representable for signed types. For instance <tt>rangeSize (range
--   minBound maxBound) :: Int</tt> gives a nonsense answer.
rangeSize :: BoundedInt a => Range a -> a

-- | Checks if the range is empty
isEmpty :: BoundedInt a => Range a -> Bool

-- | Checks if the range contains all values of the type
isFull :: BoundedInt a => Range a -> Bool

-- | Checks is the range contains exactly one element
isSingleton :: BoundedInt a => Range a -> Bool

-- | <tt>r1 `isSubRangeOf` r2</tt> checks is all the elements in
--   <tt>r1</tt> are included in <tt>r2</tt>
isSubRangeOf :: BoundedInt a => Range a -> Range a -> Bool

-- | Checks whether a range is a sub-range of the natural numbers.
isNatural :: BoundedInt a => Range a -> Bool

-- | Checks whether a range is a sub-range of the positive numbers.
isPositive :: BoundedInt a => Range a -> Bool

-- | Checks whether a range is a sub-range of the negative numbers.
isNegative :: BoundedInt a => Range a -> Bool

-- | <tt>a `inRange` r</tt> checks is <tt>a</tt> is an element of the range
--   <tt>r</tt>.
inRange :: BoundedInt a => a -> Range a -> Bool

-- | A convenience function for defining range propagation. If the input
--   range is empty then the result is also empty.
rangeOp :: BoundedInt a => (Range a -> Range a) -> (Range a -> Range a)

-- | See <a>rangeOp</a>.
rangeOp2 :: BoundedInt a => (Range a -> Range a -> Range a) -> (Range a -> Range a -> Range a)

-- | Union on ranges.
rangeUnion :: BoundedInt a => Range a -> Range a -> Range a

-- | Intersection on ranges.
rangeIntersection :: BoundedInt a => Range a -> Range a -> Range a

-- | <tt>disjoint r1 r2</tt> returns true when <tt>r1</tt> and <tt>r2</tt>
--   have no elements in common.
disjoint :: BoundedInt a => Range a -> Range a -> Bool

-- | <tt>rangeByRange ra rb</tt>: Computes the range of the following set
--   
--   <pre>
--   {x | a &lt;- ra, b &lt;- rb, x &lt;- Range a b}
--   </pre>
rangeByRange :: BoundedInt a => Range a -> Range a -> Range a

-- | <tt>rangeGap r1 r2</tt> returns a range of all the elements between
--   <tt>r1</tt> and <tt>r2</tt> including the boundary elements. If
--   <tt>r1</tt> and <tt>r2</tt> have elements in common the result is an
--   empty range.
rangeGap :: BoundedInt a => Range a -> Range a -> Range a

-- | <pre>
--   r1 `rangeLess` r2:
--   </pre>
--   
--   Checks if all elements of <tt>r1</tt> are less than all elements of
--   <tt>r2</tt>.
rangeLess :: BoundedInt a => Range a -> Range a -> Bool

-- | <pre>
--   r1 `rangeLessEq` r2:
--   </pre>
--   
--   Checks if all elements of <tt>r1</tt> are less than or equal to all
--   elements of <tt>r2</tt>.
rangeLessEq :: BoundedInt a => Range a -> Range a -> Bool

-- | Propagates range information through <tt>abs</tt>.
rangeAbs :: BoundedInt a => Range a -> Range a

-- | Propagates range information through <a>signum</a>.
rangeSignum :: BoundedInt a => Range a -> Range a

-- | Signed case for <a>rangeSignum</a>.
rangeSignumSigned :: BoundedInt a => Range a -> Range a

-- | Unsigned case for <a>rangeSignum</a>.
rangeSignumUnsigned :: BoundedInt a => Range a -> Range a

-- | Propagates range information through negation.
rangeNeg :: BoundedInt a => Range a -> Range a

-- | Unsigned case for <a>rangeNeg</a>.
rangeNegUnsigned :: BoundedInt a => Range a -> Range a

-- | Signed case for <a>rangeNeg</a>.
rangeNegSigned :: BoundedInt a => Range a -> Range a

-- | Propagates range information through addition.
rangeAdd :: BoundedInt a => Range a -> Range a -> Range a

-- | Unsigned case for <a>rangeAdd</a>.
rangeAddUnsigned :: BoundedInt a => Range a -> Range a -> Range a

-- | Signed case for <a>rangeAdd</a>.
rangeAddSigned :: BoundedInt a => Range a -> Range a -> Range a

-- | Propagates range information through subtraction.
rangeSub :: BoundedInt a => Range a -> Range a -> Range a

-- | Unsigned case for <a>rangeSub</a>.
rangeSubUnsigned :: BoundedInt a => Range a -> Range a -> Range a
rangeSubSigned :: BoundedInt a => Range a -> Range a -> Range a

-- | Saturating unsigned subtraction
subSat :: BoundedInt a => a -> a -> a

-- | Range propagation for <a>subSat</a>
rangeSubSat :: BoundedInt a => Range a -> Range a -> Range a

-- | Propagates range information through multiplication
rangeMul :: BoundedInt a => Range a -> Range a -> Range a

-- | Signed case for <a>rangeMul</a>.
rangeMulSigned :: BoundedInt a => Range a -> Range a -> Range a

-- | Unsigned case for <a>rangeMul</a>.
rangeMulUnsigned :: BoundedInt a => Range a -> Range a -> Range a

-- | Returns the position of the highest bit set to 1. Counting starts at
--   1.
bits :: BoundedInt b => b -> Int

-- | Propagates range information through exponentiation.
rangeExp :: BoundedInt a => Range a -> Range a -> Range a

-- | Unsigned case for <a>rangeExp</a>.
rangeExpUnsigned :: BoundedInt a => Range a -> Range a -> Range a

-- | Sigend case for <a>rangeExp</a>
rangeExpSigned :: BoundedInt a => Range a -> Range a -> Range a

-- | <tt>a `maxPlus` b</tt> adds <tt>a</tt> and <tt>b</tt> but if the
--   addition overflows then <a>maxBound</a> is returned.
maxPlus :: BoundedInt a => a -> a -> a

-- | Accurate lower bound for <a>.|.</a> on unsigned numbers.
minOrUnsigned :: BoundedInt a => a -> a -> a -> a -> a
minOr :: BoundedSuper a => a -> a -> a -> a -> a

-- | Accurate upper bound for <a>.|.</a> on unsigned numbers.
maxOrUnsigned :: BoundedInt a => a -> a -> a -> a -> a
maxOr :: BoundedSuper a => a -> a -> a -> a -> a

-- | Accurate lower bound for <a>.&amp;.</a> on unsigned numbers
minAndUnsigned :: BoundedInt a => a -> a -> a -> a -> a

-- | Accurate upper bound for <a>.&amp;.</a> on unsigned numbers
maxAndUnsigned :: BoundedInt a => a -> a -> a -> a -> a

-- | Accurate lower bound for <a>xor</a> on unsigned numbers
minXorUnsigned :: BoundedInt a => a -> a -> a -> a -> a

-- | Accurate upper bound for <a>xor</a> on unsigned numbers
maxXorUnsigned :: BoundedInt a => a -> a -> a -> a -> a
minOrSigned :: BoundedInt a => a -> a -> a -> a -> a
maxOrSigned :: BoundedInt a => a -> a -> a -> a -> a
minAndSigned :: BoundedInt a => a -> a -> a -> a -> a
maxAndSigned :: BoundedInt a => a -> a -> a -> a -> a

-- | Propagates range information through <a>.|.</a>.
rangeOr :: BoundedInt a => Range a -> Range a -> Range a

-- | Accurate range propagation through <a>.|.</a> for unsigned types.
rangeOrUnsignedAccurate :: BoundedInt a => Range a -> Range a -> Range a
rangeOrSignedAccurate :: BoundedInt a => Range a -> Range a -> Range a

-- | Propagating range information through <a>.&amp;.</a>.
rangeAnd :: BoundedInt a => Range a -> Range a -> Range a

-- | Accurate range propagation through <a>.&amp;.</a> for unsigned types
rangeAndUnsignedAccurate :: BoundedInt a => Range a -> Range a -> Range a
rangeAndSignedAccurate :: BoundedInt a => Range a -> Range a -> Range a

-- | Propagating range information through <a>xor</a>.
rangeXor :: BoundedInt a => Range a -> Range a -> Range a

-- | Accurate range propagation through <a>xor</a> for unsigned types
rangeXorUnsignedAccurate :: BoundedInt a => Range a -> Range a -> Range a

-- | | Propagating range information through <tt>shiftLU</tt>.
rangeShiftLU :: (BoundedInt a, BoundedInt b) => Range a -> Range b -> Range a

-- | Unsigned case for <a>rangeShiftLU</a>.
rangeShiftLUUnsigned :: (BoundedInt a, Integral b) => Range a -> Range b -> Range a

-- | Propagating range information through <tt>shiftRU</tt>.
rangeShiftRU :: (BoundedInt a, BoundedInt b) => Range a -> Range b -> Range a

-- | Unsigned case for <a>rangeShiftRU</a>.
rangeShiftRUUnsigned :: (BoundedInt a, BoundedInt b) => Range a -> Range b -> Range a

-- | This is a replacement fror Haskell's shiftR. If we carelessly use
--   Haskell's variant then we will get left shifts for very large shift
--   values.
correctShiftRU :: (Num a, Bits a, BoundedInt b) => a -> b -> a

-- | Propagating range information through <a>complement</a>
rangeComplement :: (Bits a, BoundedInt a) => Range a -> Range a

-- | Propagates range information through <a>max</a>.
rangeMax :: BoundedInt a => Range a -> Range a -> Range a

-- | Analogous to <a>rangeMax</a>
rangeMin :: BoundedInt a => Range a -> Range a -> Range a

-- | Propagates range information through <a>mod</a>. Note that we assume
--   Haskell semantics for <a>mod</a>.
rangeMod :: BoundedInt a => Range a -> Range a -> Range a

-- | Propagates range information through <a>rem</a>. Note that we assume
--   Haskell semantics for <a>rem</a>.
rangeRem :: BoundedInt a => Range a -> Range a -> Range a
predAbs :: (Bounded a, Eq a, Num a, Enum a) => a -> a

-- | Propagates range information through <a>div</a>
rangeDiv :: BoundedInt a => Range a -> Range a -> Range a

-- | Unsigned case for <a>rangeDiv</a>
rangeDivU :: BoundedInt a => Range a -> Range a -> Range a

-- | Propagates range information through <a>quot</a>.
rangeQuot :: BoundedInt a => Range a -> Range a -> Range a

-- | Unsigned case for <a>rangeQuot</a>.
rangeQuotU :: BoundedInt a => Range a -> Range a -> Range a

-- | Writing <tt>d `rangeLess` abs r</tt> doesn't mean what you think it
--   does because <tt>r</tt> may contain minBound which doesn't have a
--   positive representation. Instead, this function should be used.
rangeLessAbs :: BoundedInt a => Range a -> Range a -> Bool

-- | Similar to <a>rangeLessAbs</a> but replaces the expression <tt>abs d
--   `rangeLess` abs r</tt> instead.
absRangeLessAbs :: BoundedInt a => Range a -> Range a -> Bool
liftR :: (BoundedInt b, BoundedInt c, BoundedInt d) => (forall a. BoundedInt a => Range a) -> (Range b, Range c, Range d)
binopR :: (BoundedInt a, BoundedInt b, BoundedInt c) => (forall d. BoundedInt d => Range d -> Range d -> Range d) -> (Range a, Range b, Range c) -> (Range a, Range b, Range c) -> (Range a, Range b, Range c)
mapR :: (BoundedInt a, BoundedInt b, BoundedInt c) => (forall d. BoundedInt d => Range d -> Range d) -> (Range a, Range b, Range c) -> (Range a, Range b, Range c)
approx :: (BoundedInt a, BoundedInt b, BoundedInt c, BoundedInt d) => (Range a, Range b, Range c) -> Range d
instance Eq a => Eq (Range a)
instance Show a => Show (Range a)
instance (BoundedInt a, BoundedInt b, BoundedInt c) => Num (Range a, Range b, Range c)
instance (BoundedInt a) => Ord (Range a)
instance (BoundedInt a) => Num (Range a)
instance (BoundedInt a) => Lattice (Range a)
instance (Ord a, Num a, Bounded a, Integral a, Bits a) => BoundedSuper a

module Feldspar.Core.Types

-- | Heterogeneous list
data (:>) a b
(:>) :: a -> b -> :> a b

-- | Target-dependent unsigned integers
newtype WordN
WordN :: Word32 -> WordN

-- | Target-dependent signed integers
newtype IntN
IntN :: Int32 -> IntN

-- | Type representation of 8 bits
data N8

-- | Type representation of 16 bits
data N16

-- | Type representation of 32 bits
data N32

-- | Type representation of 64 bits
data N64

-- | Type representation of the native number of bits on the target
data NNative

-- | Witness for <a>N8</a>, <a>N16</a>, <a>N32</a>, <a>N64</a> or
--   <a>NNative</a>
data BitWidth n
N8 :: BitWidth N8
N16 :: BitWidth N16
N32 :: BitWidth N32
N64 :: BitWidth N64
NNative :: BitWidth NNative
bitWidth :: BitWidth n -> String

-- | Type representation of "unsigned"
data U

-- | Type representation of "signed"
data S

-- | Witness for <a>U</a> or <a>S</a>
data Signedness s
U :: Signedness U
S :: Signedness S
signedness :: Signedness s -> String

-- | A generalization of unsigned and signed integers. The first parameter
--   represents the signedness and the sectond parameter the number of
--   bits.
fromWordN :: BitWidth n -> WordN -> GenericInt U n
fromIntN :: BitWidth n -> IntN -> GenericInt S n
genericLen :: BitWidth n -> [a] -> GenericInt U n
type Length = WordN
type Index = WordN

-- | Array whose length is represented by an <tt>n</tt>-bit word
data TargetArr n a
TargetArr :: (GenericInt U n) -> [a] -> TargetArr n a

-- | This class is used to allow constructs to be abstract in the monad
class MonadType m
voidTypeRep :: MonadType m => TypeRep (m ())

-- | Monad for manipulation of mutable data
type Mut = IO

-- | Mutable arrays
type MArr a = IOArray Index a

-- | Monad for parallel constructs
type Par = Par

-- | Immutable references
type IV = IVar
newtype FVal a
FVal :: a -> FVal a
unFVal :: FVal a -> a

-- | Representation of supported types
data TypeRep a
UnitType :: TypeRep ()
BoolType :: TypeRep Bool
IntType :: Signedness s -> BitWidth n -> TypeRep (GenericInt s n)
FloatType :: TypeRep Float
DoubleType :: TypeRep Double
ComplexType :: TypeRep a -> TypeRep (Complex a)
ArrayType :: TypeRep a -> TypeRep [a]
TargetArrType :: BitWidth n -> TypeRep a -> TypeRep (TargetArr n a)
Tup2Type :: TypeRep a -> TypeRep b -> TypeRep (a, b)
Tup3Type :: TypeRep a -> TypeRep b -> TypeRep c -> TypeRep (a, b, c)
Tup4Type :: TypeRep a -> TypeRep b -> TypeRep c -> TypeRep d -> TypeRep (a, b, c, d)
Tup5Type :: TypeRep a -> TypeRep b -> TypeRep c -> TypeRep d -> TypeRep e -> TypeRep (a, b, c, d, e)
Tup6Type :: TypeRep a -> TypeRep b -> TypeRep c -> TypeRep d -> TypeRep e -> TypeRep f -> TypeRep (a, b, c, d, e, f)
Tup7Type :: TypeRep a -> TypeRep b -> TypeRep c -> TypeRep d -> TypeRep e -> TypeRep f -> TypeRep g -> TypeRep (a, b, c, d, e, f, g)
FunType :: TypeRep a -> TypeRep b -> TypeRep (a -> b)
MutType :: TypeRep a -> TypeRep (Mut a)
RefType :: TypeRep a -> TypeRep (IORef a)
MArrType :: TypeRep a -> TypeRep (MArr a)
ParType :: TypeRep a -> TypeRep (Par a)
IVarType :: TypeRep a -> TypeRep (IV a)
FValType :: TypeRep a -> TypeRep (FVal a)
argType :: TypeRep (a -> b) -> TypeRep a
resType :: TypeRep (a -> b) -> TypeRep b

-- | Type equality witness
data TypeEq a b
TypeEq :: TypeEq a a
defaultSize :: TypeRep a -> Size a

-- | Type equality on <a>Signedness</a>
signEq :: Signedness s1 -> Signedness s2 -> Maybe (TypeEq s1 s2)

-- | Type equality on <a>BitWidth</a>
widthEq :: BitWidth n1 -> BitWidth n2 -> Maybe (TypeEq n1 n2)

-- | Type equality on <a>TypeRep</a>
typeEq :: TypeRep a -> TypeRep b -> Maybe (TypeEq a b)
showTup :: [String] -> String

-- | The set of supported types
class (Eq a, Show a, Typeable a, Show (Size a), Lattice (Size a)) => Type a
typeRep :: Type a => TypeRep a
sizeOf :: Type a => a -> Size a
toTarget :: Type a => BitWidth n -> a -> TargetType n a
typeRepByProxy :: Type a => Proxy a -> TypeRep a
data AnySize
AnySize :: AnySize
anySizeFun :: AnySize -> AnySize
anySizeFun2 :: AnySize -> AnySize -> AnySize

-- | A generalization of <a>Range</a> that serves two purposes: (1) Adding
--   an extra <a>Universal</a> constructor to support unbounded types
--   (<a>Range</a> can only represent bounded ranges), and (2) pack a
--   <a>BoundedInt</a> constraint with the <a>RangeSet</a> constructor.
--   This is what allows <a>sizeToRange</a> to be defined as a total
--   function with <a>Type</a> as the only constraint.
data RangeSet a
RangeSet :: Range a -> RangeSet a
Universal :: RangeSet a

-- | Cast a <a>Size</a> to a <a>RangeSet</a>
sizeToRange :: Type a => Size a -> RangeSet a
tIntN :: Patch IntN IntN
tWordN :: Patch WordN WordN
tIndex :: Patch Index Index
tLength :: Patch Length Length
tArr :: Patch a a -> Patch [a] [a]
instance Typeable WordN
instance Typeable IntN
instance Show a => Show (RangeSet a)
instance Typeable1 FVal
instance Typeable1 IVar
instance Typeable1 Par
instance (Eq a, Eq b) => Eq (a :> b)
instance (Ord a, Ord b) => Ord (a :> b)
instance (Show a, Show b) => Show (a :> b)
instance Eq WordN
instance Ord WordN
instance Num WordN
instance Enum WordN
instance Ix WordN
instance Real WordN
instance Integral WordN
instance Bits WordN
instance Bounded WordN
instance Arbitrary WordN
instance Random WordN
instance Storable WordN
instance NFData WordN
instance Default WordN
instance Eq IntN
instance Ord IntN
instance Num IntN
instance Enum IntN
instance Ix IntN
instance Real IntN
instance Integral IntN
instance Bits IntN
instance Bounded IntN
instance Arbitrary IntN
instance Random IntN
instance Storable IntN
instance NFData IntN
instance Default IntN
instance Eq AnySize
instance Show AnySize
instance Ord AnySize
instance Lattice AnySize
instance Num AnySize
instance Type a => Type (FVal a)
instance Type a => Type (IV a)
instance Type a => Type (MArr a)
instance (Type a, Show (IORef a)) => Type (IORef a)
instance (Type a, Type b, Type c, Type d, Type e, Type f, Type g) => Type (a, b, c, d, e, f, g)
instance (Type a, Type b, Type c, Type d, Type e, Type f) => Type (a, b, c, d, e, f)
instance (Type a, Type b, Type c, Type d, Type e) => Type (a, b, c, d, e)
instance (Type a, Type b, Type c, Type d) => Type (a, b, c, d)
instance (Type a, Type b, Type c) => Type (a, b, c)
instance (Type a, Type b) => Type (a, b)
instance Type a => Type [a]
instance (Type a, RealFloat a) => Type (Complex a)
instance Type Double
instance Type Float
instance Type IntN
instance Type WordN
instance Type Int64
instance Type Word64
instance Type Int32
instance Type Word32
instance Type Int16
instance Type Word16
instance Type Int8
instance Type Word8
instance Type Bool
instance Type ()
instance Show (TypeRep a)
instance Eq a => Eq (FVal a)
instance Show (FVal a)
instance MonadType Par
instance Show (IV a)
instance MonadType Mut
instance Show (MArr a)
instance Show (IORef a)
instance Show IntN
instance Show WordN
instance (Lattice a, Lattice b) => Lattice (a :> b)


-- | Witness <a>Type</a> constraints
module Feldspar.Core.Interpretation.Typed

-- | Class representing a possible dictionary to witness a <a>Type</a>
--   constraint.
class Typed dom where typeDictSym _ = Nothing
typeDictSym :: Typed dom => dom a -> Maybe (Dict (Type (DenResult a)))

-- | Extract a possible <a>Type</a> constraint witness from an <a>AST</a>
typeDict :: Typed dom => ASTF dom a -> Maybe (Dict (Type a))
instance [overlap ok] Typed dom
instance [overlap ok] Typed Empty
instance [overlap ok] Typed sub => Typed (Decor info sub)
instance [overlap ok] (Typed sub, Typed sup) => Typed (sub :+: sup)
instance [overlap ok] Typed (SubConstr2 c sub Type Top)
instance [overlap ok] Typed sub => Typed (sub :| pred)
instance [overlap ok] Typed sub => Typed (sub :|| pred)
instance [overlap ok] Typed (sub :|| Type)


-- | Defines different interpretations of Feldspar programs
module Feldspar.Core.Interpretation

-- | Specialize the program for a target platform with the given native bit
--   width
targetSpecialization :: BitWidth n -> ASTF dom a -> ASTF dom a

-- | Indication whether a symbol is sharable or not
class Sharable dom where sharable _ = True hoistOver _ = True
sharable :: Sharable dom => dom a -> Bool
hoistOver :: Sharable dom => dom a -> Bool

-- | Forwards size propagation
class SizeProp feature
sizeProp :: SizeProp feature => feature a -> Args (WrapFull Info) a -> Size (DenResult a)

-- | Convenient default implementation of <a>sizeProp</a>
sizePropDefault :: Type (DenResult a) => feature a -> Args (WrapFull Info) a -> Size (DenResult a)

-- | Compute a type representation of a symbol's result type
resultType :: Type (DenResult a) => c a -> TypeRep (DenResult a)

-- | Information about the source code of an expression
type SourceInfo = String

-- | Type and size information of a Feldspar program
data Info a
Info :: TypeRep a -> Size a -> VarInfo -> SourceInfo -> Info a
infoType :: Info a -> TypeRep a
infoSize :: Info a -> Size a
infoVars :: Info a -> VarInfo
infoSource :: Info a -> SourceInfo
mkInfo :: Type a => Size a -> Info a
mkInfoTy :: (Show (Size a), Lattice (Size a)) => TypeRep a -> Info a
infoRange :: Type a => Info a -> RangeSet a

-- | This class is used to allow constructs to be abstract in the monad.
--   Its purpose is similar to that of <a>MonadType</a>.
class LatticeSize1 m
mergeSize :: (LatticeSize1 m, Lattice (Size a)) => Info (m a) -> Size (m a) -> Size (m a) -> Size (m a)

-- | It the expression is a literal, its value is returned, otherwise
--   <a>Nothing</a>
viewLiteral :: (Literal :|| Type) :<: dom => ASTF (Decor info (dom :|| Typeable)) a -> Maybe a

-- | Construct a <a>Literal</a>
literal :: (Type a, (Literal :|| Type) :<: dom) => a -> ASTF (dom :|| Typeable) a

-- | Construct a <a>Literal</a> decorated with <a>Info</a>
literalDecor :: (Type a, (Literal :|| Type) :<: dom) => a -> ASTF (Decor Info (dom :|| Typeable)) a

-- | Replaces an expression with a literal if the type permits, otherwise
--   returns the expression unchanged.
constFold :: (Typed dom, (Literal :|| Type) :<: dom) => SourceInfo -> ASTF (Decor Info (dom :|| Typeable)) a -> a -> ASTF (Decor Info (dom :|| Typeable)) a

-- | <a>Info</a> with hidden result type
data SomeInfo
SomeInfo :: Info a -> SomeInfo
data SomeType
SomeType :: TypeRep a -> SomeType
data Env
Env :: [(VarId, SomeInfo)] -> SourceInfo -> Env
varEnv :: Env -> [(VarId, SomeInfo)]
sourceEnv :: Env -> SourceInfo

-- | A record with options for explicit passing in rewrite rules.
data FeldOpts
FeldOpts :: [Target] -> FeldOpts
targets :: FeldOpts -> [Target]

-- | Possible compilation targets.
data Target
RegionInf :: Target
SICS :: Target

-- | Decide whether a Target is enabled in FeldOpts.
inTarget :: Target -> FeldOpts -> Bool

-- | Default options.
defaultFeldOpts :: FeldOpts

-- | Insert a variable into the environment
localVar :: Typeable b => VarId -> Info b -> Opt a -> Opt a

-- | Change the <a>SourceInfo</a> environment
localSource :: SourceInfo -> Opt a -> Opt a

-- | Environment for optimization
type Opt = Reader Env

-- | Basic optimization of a feature
--   
--   This optimization is similar to <a>Optimize</a>, but it also performs
--   size inference. Size inference has to be done simultaneously with
--   other optimizations in order to avoid iterating the phases. (Size
--   information may help optimization and optimization may help size
--   inference.)
class Optimize feature dom where optimizeFeat = optimizeFeatDefault constructFeatOpt = constructFeatUnOpt
optimizeFeat :: (Optimize feature dom, Typeable (DenResult a), OptimizeSuper dom) => FeldOpts -> feature a -> Args (AST (dom :|| Typeable)) a -> Opt (ASTF (Decor Info (dom :|| Typeable)) (DenResult a))
constructFeatOpt :: (Optimize feature dom, Typeable (DenResult a)) => FeldOpts -> feature a -> Args (AST (Decor Info (dom :|| Typeable))) a -> Opt (ASTF (Decor Info (dom :|| Typeable)) (DenResult a))
constructFeatUnOpt :: (Optimize feature dom, Typeable (DenResult a)) => FeldOpts -> feature a -> Args (AST (Decor Info (dom :|| Typeable))) a -> Opt (ASTF (Decor Info (dom :|| Typeable)) (DenResult a))
class (AlphaEq dom dom (dom :|| Typeable) [(VarId, VarId)], AlphaEq dom dom (Decor Info (dom :|| Typeable)) [(VarId, VarId)], EvalBind dom, (Literal :|| Type) :<: dom, Typed dom, Render dom, Constrained dom, Optimize dom dom) => OptimizeSuper dom

-- | Optimized construction of an expression from a symbol and its
--   optimized arguments
constructFeat :: (Typeable (DenResult a), Optimize feature dom) => FeldOpts -> feature a -> Args (AST (Decor Info (dom :|| Typeable))) a -> Opt (ASTF (Decor Info (dom :|| Typeable)) (DenResult a))

-- | Optimization of an expression
--   
--   In addition to running <a>optimizeFeat</a>, this function performs
--   constant folding on all closed expressions, provided that the type
--   permits making a literal.
optimizeM :: OptimizeSuper dom => FeldOpts -> ASTF (dom :|| Typeable) a -> Opt (ASTF (Decor Info (dom :|| Typeable)) a)

-- | Optimization of an expression. This function runs <a>optimizeM</a> and
--   extracts the result.
optimize :: (Typeable a, OptimizeSuper dom) => FeldOpts -> ASTF (dom :|| Typeable) a -> ASTF (Decor Info (dom :|| Typeable)) a

-- | Convenient default implementation of <a>constructFeatUnOpt</a>. Uses
--   <a>sizeProp</a> to propagate size.
constructFeatUnOptDefaultTyp :: (feature :<: dom, SizeProp feature, Typeable (DenResult a), Show (Size (DenResult a)), Lattice (Size (DenResult a))) => FeldOpts -> TypeRep (DenResult a) -> feature a -> Args (AST (Decor Info (dom :|| Typeable))) a -> Opt (ASTF (Decor Info (dom :|| Typeable)) (DenResult a))

-- | Like <a>constructFeatUnOptDefaultTyp</a> but without an explicit
--   <a>TypeRep</a>
constructFeatUnOptDefault :: (feature :<: dom, SizeProp feature, Type (DenResult a)) => FeldOpts -> feature a -> Args (AST (Decor Info (dom :|| Typeable))) a -> Opt (ASTF (Decor Info (dom :|| Typeable)) (DenResult a))

-- | Convenient default implementation of <a>optimizeFeat</a>
optimizeFeatDefault :: (Optimize feature dom, Typeable (DenResult a), OptimizeSuper dom) => FeldOpts -> feature a -> Args (AST (dom :|| Typeable)) a -> Opt (ASTF (Decor Info (dom :|| Typeable)) (DenResult a))
prjF :: Project (sub :|| Type) sup => sup sig -> Maybe ((sub :|| Type) sig)
c' :: Type (DenResult sig) => feature sig -> (feature :|| Type) sig

-- | The <a>Monotonic</a> class represents (weak) monotonicity
class Monotonic feature where monotonicInc _ _ = [] monotonicDec _ _ = []
monotonicInc :: Monotonic feature => feature a -> Args (AST (Decor Info (dom :|| Typeable))) a -> [ASTF (Decor Info (dom :|| Typeable)) (DenResult a)]
monotonicDec :: Monotonic feature => feature a -> Args (AST (Decor Info (dom :|| Typeable))) a -> [ASTF (Decor Info (dom :|| Typeable)) (DenResult a)]

-- | Extract sub-expressions for which the expression is (weak) monotonic
--   increasing
viewMonotonicInc :: Monotonic dom => ASTF (Decor Info (dom :|| Typeable)) a -> [ASTF (Decor Info (dom :|| Typeable)) a]

-- | Extract sub-expressions for which the expression is (weak) monotonic
--   decreasing
viewMonotonicDec :: Monotonic dom => ASTF (Decor Info (dom :|| Typeable)) a -> [ASTF (Decor Info (dom :|| Typeable)) a]
instance Eq Target
instance Monotonic Empty
instance Monotonic dom => Monotonic (Decor Info dom)
instance Monotonic sym => Monotonic (SubConstr2 c sym p1 p2)
instance Monotonic sym => Monotonic (sym :|| pred)
instance (Monotonic sub1, Monotonic sub2) => Monotonic (sub1 :+: sub2)
instance (Optimize sub1 dom, Optimize sub2 dom) => Optimize (sub1 :+: sub2) dom
instance (AlphaEq dom dom (dom :|| Typeable) [(VarId, VarId)], AlphaEq dom dom (Decor Info (dom :|| Typeable)) [(VarId, VarId)], EvalBind dom, (Literal :|| Type) :<: dom, Typed dom, Render dom, Constrained dom, Optimize dom dom) => OptimizeSuper dom
instance Optimize Empty dom
instance LatticeSize1 Mut
instance Show (Info a)
instance Sharable Empty
instance Sharable dom => Sharable (Decor Info dom)
instance Sharable sym => Sharable (SubConstr2 c sym p1 p2)
instance Sharable sym => Sharable (sym :|| pred)
instance (Sharable sub1, Sharable sub2) => Sharable (sub1 :+: sub2)

module Feldspar.Core.Constructs.Complex
data COMPLEX a
MkComplex :: COMPLEX (a :-> (a :-> Full (Complex a)))
RealPart :: COMPLEX (Complex a :-> Full a)
ImagPart :: COMPLEX (Complex a :-> Full a)
Conjugate :: COMPLEX (Complex a :-> Full (Complex a))
MkPolar :: COMPLEX (a :-> (a :-> Full (Complex a)))
Magnitude :: COMPLEX (Complex a :-> Full a)
Phase :: COMPLEX (Complex a :-> Full a)
Cis :: COMPLEX (a :-> Full (Complex a))
instance ((COMPLEX :|| Type) :<: dom, OptimizeSuper dom) => Optimize (COMPLEX :|| Type) dom
instance SizeProp (COMPLEX :|| Type)
instance Monotonic COMPLEX
instance Sharable COMPLEX
instance AlphaEq dom dom dom env => AlphaEq COMPLEX COMPLEX dom env
instance EvalBind COMPLEX
instance Eval COMPLEX
instance StringTree COMPLEX
instance Render COMPLEX
instance Equality COMPLEX
instance Semantic COMPLEX


-- | Implementation of ordering constructs
module Feldspar.Core.Constructs.Ord

-- | Ordering constructs
data ORD a
LTH :: ORD (a :-> (a :-> Full Bool))
GTH :: ORD (a :-> (a :-> Full Bool))
LTE :: ORD (a :-> (a :-> Full Bool))
GTE :: ORD (a :-> (a :-> Full Bool))
Min :: ORD (a :-> (a :-> Full a))
Max :: ORD (a :-> (a :-> Full a))
instance ((ORD :|| Type) :<: dom, Monotonic dom, OptimizeSuper dom) => Optimize (ORD :|| Type) dom
instance SizeProp (ORD :|| Type)
instance Monotonic ORD
instance Sharable ORD
instance AlphaEq dom dom dom env => AlphaEq ORD ORD dom env
instance EvalBind ORD
instance Eval ORD
instance StringTree ORD
instance Render ORD
instance Equality ORD
instance Semantic ORD


-- | Implementation of Equality constructs
module Feldspar.Core.Constructs.Eq

-- | Equality constructs
data EQ a
Equal :: EQ (a :-> (a :-> Full Bool))
NotEqual :: EQ (a :-> (a :-> Full Bool))
instance ((EQ :|| Type) :<: dom, OptimizeSuper dom) => Optimize (EQ :|| Type) dom
instance SizeProp (EQ :|| Type)
instance Monotonic EQ
instance Sharable EQ
instance AlphaEq dom dom dom env => AlphaEq EQ EQ dom env
instance EvalBind EQ
instance Eval EQ
instance StringTree EQ
instance Render EQ
instance Equality EQ
instance Semantic EQ


-- | Implementation of Logic constructs
module Feldspar.Core.Constructs.Logic

-- | Logic constructs
data Logic a
And :: Logic (Bool :-> (Bool :-> Full Bool))
Or :: Logic (Bool :-> (Bool :-> Full Bool))
Not :: Logic (Bool :-> Full Bool)
instance ((Logic :|| Type) :<: dom, (EQ :|| Type) :<: dom, (ORD :|| Type) :<: dom, Monotonic dom, OptimizeSuper dom) => Optimize (Logic :|| Type) dom
instance SizeProp (Logic :|| Type)
instance Monotonic Logic
instance Sharable Logic
instance AlphaEq dom dom dom env => AlphaEq Logic Logic dom env
instance EvalBind Logic
instance Eval Logic
instance StringTree Logic
instance Render Logic
instance Equality Logic
instance Semantic Logic


-- | Implementation of constructs and operations on <a>Bits</a>
module Feldspar.Core.Constructs.Bits

-- | Bits constructs
data BITS a
BAnd :: BITS (a :-> (a :-> Full a))
BOr :: BITS (a :-> (a :-> Full a))
BXor :: BITS (a :-> (a :-> Full a))
Complement :: BITS (a :-> Full a)
Bit :: BITS (Index :-> Full a)
SetBit :: BITS (a :-> (Index :-> Full a))
ClearBit :: BITS (a :-> (Index :-> Full a))
ComplementBit :: BITS (a :-> (Index :-> Full a))
TestBit :: BITS (a :-> (Index :-> Full Bool))
ShiftLU :: BITS (a :-> (Index :-> Full a))
ShiftRU :: BITS (a :-> (Index :-> Full a))
ShiftL :: BITS (a :-> (IntN :-> Full a))
ShiftR :: BITS (a :-> (IntN :-> Full a))
RotateLU :: BITS (a :-> (Index :-> Full a))
RotateRU :: BITS (a :-> (Index :-> Full a))
RotateL :: BITS (a :-> (IntN :-> Full a))
RotateR :: BITS (a :-> (IntN :-> Full a))
ReverseBits :: BITS (a :-> Full a)
BitScan :: BITS (a :-> Full Index)
BitCount :: BITS (a :-> Full Index)
instance ((BITS :|| Type) :<: dom, (Logic :|| Type) :<: dom, (EQ :|| Type) :<: dom, (ORD :|| Type) :<: dom, Monotonic dom, OptimizeSuper dom) => Optimize (BITS :|| Type) dom
instance SizeProp (BITS :|| Type)
instance Monotonic BITS
instance Sharable BITS
instance AlphaEq dom dom dom env => AlphaEq BITS BITS dom env
instance EvalBind BITS
instance Eval BITS
instance StringTree BITS
instance Render BITS
instance Equality BITS
instance Semantic BITS

module Feldspar.Core.Constructs.Integral
data INTEGRAL a
Quot :: INTEGRAL (a :-> (a :-> Full a))
Rem :: INTEGRAL (a :-> (a :-> Full a))
Div :: INTEGRAL (a :-> (a :-> Full a))
Mod :: INTEGRAL (a :-> (a :-> Full a))
Exp :: INTEGRAL (a :-> (a :-> Full a))
instance ((INTEGRAL :|| Type) :<: dom, (BITS :|| Type) :<: dom, (EQ :|| Type) :<: dom, (ORD :|| Type) :<: dom, (COMPLEX :|| Type) :<: dom, (Condition :|| Type) :<: dom, (Logic :|| Type) :<: dom, Monotonic dom, OptimizeSuper dom, Optimize (Condition :|| Type) dom) => Optimize (INTEGRAL :|| Type) dom
instance SizeProp (INTEGRAL :|| Type)
instance Monotonic INTEGRAL
instance Sharable INTEGRAL
instance AlphaEq dom dom dom env => AlphaEq INTEGRAL INTEGRAL dom env
instance EvalBind INTEGRAL
instance Eval INTEGRAL
instance StringTree INTEGRAL
instance Render INTEGRAL
instance Equality INTEGRAL
instance Semantic INTEGRAL

module Feldspar.Core.Constructs.ConditionM
data ConditionM m a
ConditionM :: ConditionM m (Bool :-> (m a :-> (m a :-> Full (m a))))
instance (ConditionM m :<: dom, (Logic :|| Type) :<: dom, OptimizeSuper dom, LatticeSize1 m) => Optimize (ConditionM m) dom
instance LatticeSize1 m => SizeProp (ConditionM m)
instance AlphaEq dom dom dom env => AlphaEq (ConditionM m) (ConditionM m) dom env
instance Monotonic (ConditionM m)
instance Sharable (ConditionM m)
instance EvalBind (ConditionM m)
instance Eval (ConditionM m)
instance StringTree (ConditionM m)
instance Render (ConditionM m)
instance Equality (ConditionM m)
instance Semantic (ConditionM m)

module Feldspar.Core.Constructs.Error
data Error a
Undefined :: Error (Full a)
Assert :: String -> Error (Bool :-> (a :-> Full a))
instance ((Error :|| Type) :<: dom, Optimize dom dom) => Optimize (Error :|| Type) dom
instance AlphaEq dom dom dom env => AlphaEq Error Error dom env
instance SizeProp (Error :|| Type)
instance Monotonic Error
instance Sharable Error
instance EvalBind Error
instance Eval Error
instance StringTree Error
instance Equality Error
instance Render Error
instance Semantic Error

module Feldspar.Core.Constructs.Floating
data FLOATING a
Pi :: FLOATING (Full a)
Exp :: FLOATING (a :-> Full a)
Sqrt :: FLOATING (a :-> Full a)
Log :: FLOATING (a :-> Full a)
Pow :: FLOATING (a :-> (a :-> Full a))
LogBase :: FLOATING (a :-> (a :-> Full a))
Sin :: FLOATING (a :-> Full a)
Tan :: FLOATING (a :-> Full a)
Cos :: FLOATING (a :-> Full a)
Asin :: FLOATING (a :-> Full a)
Atan :: FLOATING (a :-> Full a)
Acos :: FLOATING (a :-> Full a)
Sinh :: FLOATING (a :-> Full a)
Tanh :: FLOATING (a :-> Full a)
Cosh :: FLOATING (a :-> Full a)
Asinh :: FLOATING (a :-> Full a)
Atanh :: FLOATING (a :-> Full a)
Acosh :: FLOATING (a :-> Full a)
instance ((FLOATING :|| Type) :<: dom, OptimizeSuper dom) => Optimize (FLOATING :|| Type) dom
instance SizeProp (FLOATING :|| Type)
instance Monotonic FLOATING
instance Sharable FLOATING
instance AlphaEq dom dom dom env => AlphaEq FLOATING FLOATING dom env
instance EvalBind FLOATING
instance Eval FLOATING
instance StringTree FLOATING
instance Render FLOATING
instance Equality FLOATING
instance Semantic FLOATING


-- | Interpretation of basic syntactic constructs
module Feldspar.Core.Constructs.Literal
instance ((Literal :|| Type) :<: dom, OptimizeSuper dom) => Optimize (Literal :|| Type) dom
instance SizeProp (Literal :|| Type)
instance Monotonic Literal
instance Sharable Literal

module Feldspar.Core.Constructs.Num
data NUM a
Abs :: NUM (a :-> Full a)
Sign :: NUM (a :-> Full a)
Add :: NUM (a :-> (a :-> Full a))
Sub :: NUM (a :-> (a :-> Full a))
Mul :: NUM (a :-> (a :-> Full a))
instance ((NUM :|| Type) :<: dom, (Literal :|| Type) :<: dom, (INTEGRAL :|| Type) :<: dom, (COMPLEX :|| Type) :<: dom, OptimizeSuper dom) => Optimize (NUM :|| Type) dom
instance SizeProp (NUM :|| Type)
instance Monotonic NUM
instance Sharable NUM
instance AlphaEq dom dom dom env => AlphaEq NUM NUM dom env
instance EvalBind NUM
instance Eval NUM
instance StringTree NUM
instance Render NUM
instance Equality NUM
instance Semantic NUM

module Feldspar.Core.Constructs.Fractional
data FRACTIONAL a
DivFrac :: FRACTIONAL (a :-> (a :-> Full a))
instance ((FRACTIONAL :|| Type) :<: dom, (NUM :|| Type) :<: dom, OptimizeSuper dom) => Optimize (FRACTIONAL :|| Type) dom
instance AlphaEq dom dom dom env => AlphaEq FRACTIONAL FRACTIONAL dom env
instance Monotonic FRACTIONAL
instance Sharable FRACTIONAL
instance SizeProp (FRACTIONAL :|| Type)
instance EvalBind FRACTIONAL
instance Eval FRACTIONAL
instance StringTree FRACTIONAL
instance Render FRACTIONAL
instance Equality FRACTIONAL
instance Semantic FRACTIONAL

module Feldspar.Core.Constructs.NoInline
data NoInline a
NoInline :: NoInline (a :-> Full a)
instance ((NoInline :|| Type) :<: dom, OptimizeSuper dom) => Optimize (NoInline :|| Type) dom
instance SizeProp (NoInline :|| Type)
instance Monotonic NoInline
instance Sharable NoInline
instance AlphaEq dom dom dom env => AlphaEq NoInline NoInline dom env
instance EvalBind NoInline
instance Eval NoInline
instance StringTree NoInline
instance Render NoInline
instance Equality NoInline
instance Semantic NoInline

module Feldspar.Core.Constructs.SourceInfo

-- | Kind <tt>* -&gt; *</tt> version of <a>SourceInfo</a>
data SourceInfo1 a
SourceInfo1 :: SourceInfo -> SourceInfo1 a
instance ((Decor SourceInfo1 Identity :|| Type) :<: dom, Optimize dom dom) => Optimize (Decor SourceInfo1 Identity :|| Type) dom
instance SizeProp (Decor SourceInfo1 Identity :|| Type)
instance SizeProp Identity
instance Monotonic Identity
instance Monotonic (Decor SourceInfo1 Identity)
instance Sharable (Decor SourceInfo1 Identity)

module Feldspar.Core.Constructs.RealFloat
data REALFLOAT a
Atan2 :: REALFLOAT (a :-> (a :-> Full a))
instance ((REALFLOAT :|| Type) :<: dom, OptimizeSuper dom) => Optimize (REALFLOAT :|| Type) dom
instance SizeProp (REALFLOAT :|| Type)
instance Monotonic REALFLOAT
instance Sharable REALFLOAT
instance AlphaEq dom dom dom env => AlphaEq REALFLOAT REALFLOAT dom env
instance EvalBind REALFLOAT
instance Eval REALFLOAT
instance StringTree REALFLOAT
instance Render REALFLOAT
instance Equality REALFLOAT
instance Semantic REALFLOAT

module Feldspar.Core.Constructs.Trace
data Trace a
Trace :: Trace (IntN :-> (a :-> Full a))
instance ((Trace :|| Type) :<: dom, OptimizeSuper dom) => Optimize (Trace :|| Type) dom
instance SizeProp (Trace :|| Type)
instance Monotonic Trace
instance Sharable Trace
instance AlphaEq dom dom dom env => AlphaEq Trace Trace dom env
instance EvalBind Trace
instance Eval Trace
instance StringTree Trace
instance Render Trace
instance Equality Trace
instance Constrained Trace
instance Semantic Trace

module Feldspar.Core.Constructs.FFI
data FFI a
ForeignImport :: String -> Denotation a -> FFI a
instance ((FFI :|| Type) :<: dom, OptimizeSuper dom) => Optimize (FFI :|| Type) dom
instance SizeProp (FFI :|| Type)
instance Monotonic FFI
instance Sharable FFI
instance AlphaEq dom dom dom env => AlphaEq FFI FFI dom env
instance EvalBind FFI
instance Eval FFI
instance StringTree FFI
instance Render FFI
instance Equality FFI
instance Semantic FFI

module Feldspar.Core.Constructs.Save
data Save a
Save :: Save (a :-> Full a)
instance ((Save :|| Type) :<: dom, OptimizeSuper dom) => Optimize (Save :|| Type) dom
instance SizeProp (Save :|| Type)
instance Monotonic Save
instance Sharable Save
instance AlphaEq dom dom dom env => AlphaEq Save Save dom env
instance EvalBind Save
instance Eval Save
instance StringTree Save
instance Render Save
instance Equality Save
instance Semantic Save


-- | Interpretation of binding constructs
module Feldspar.Core.Constructs.Binding
optimizeLambda :: (CLambda Type :<: dom, OptimizeSuper dom) => FeldOpts -> (ASTF (dom :|| Typeable) b -> Opt (ASTF (Decor Info (dom :|| Typeable)) b)) -> Info a -> CLambda Type (b :-> Full (a -> b)) -> Args (AST (dom :|| Typeable)) (b :-> Full (a -> b)) -> Opt (ASTF (Decor Info (dom :|| Typeable)) (a -> b))

-- | Assumes that the expression is a <a>Lambda</a>
optimizeFunction :: ((Variable :|| Type) :<: dom, CLambda Type :<: dom, Let :<: dom, OptimizeSuper dom) => FeldOpts -> (ASTF (dom :|| Typeable) b -> Opt (ASTF (Decor Info (dom :|| Typeable)) b)) -> Info a -> (ASTF (dom :|| Typeable) (a -> b) -> Opt (ASTF (Decor Info (dom :|| Typeable)) (a -> b)))
subst :: (Constrained dom, CLambda Type :<: dom, (Variable :|| Type) :<: dom) => VarId -> ASTF (dom :|| Typeable) a -> ASTF (dom :|| Typeable) b -> ASTF (dom :|| Typeable) b
betaReduce :: (Constrained dom, CLambda Type :<: dom, (Variable :|| Type) :<: dom) => ASTF (dom :|| Typeable) a -> ASTF (dom :|| Typeable) (a -> b) -> ASTF (dom :|| Typeable) b
prjLambda :: Project (CLambda Type) dom => dom sig -> Maybe (CLambda Type sig)
cLambda :: Type a => VarId -> CLambda Type (b :-> Full (a -> b))

-- | Allow an existing binding to be used with a body of a different type
reuseCLambda :: CLambda Type (b :-> Full (a -> b)) -> CLambda Type (c :-> Full (a -> c))

-- | Collects the immediate let bindings in a list and returns the first
--   non-let expression
--   
--   This function can be useful when let bindings get in the way of
--   pattern matching on a sub-expressions.
collectLetBinders :: (Project Let dom, Project (CLambda Type) dom, ConstrainedBy dom Typeable) => ASTF dom a -> ([(VarId, ASTB dom Type)], ASTF dom a)
instance (Let :<: dom, (Variable :|| Type) :<: dom, CLambda Type :<: dom, OptimizeSuper dom) => Optimize Let dom
instance SizeProp Let
instance (CLambda Type :<: dom, OptimizeSuper dom) => Optimize (CLambda Type) dom
instance ((Variable :|| Type) :<: dom, OptimizeSuper dom) => Optimize (Variable :|| Type) dom
instance Monotonic Let
instance Monotonic Lambda
instance Monotonic Variable
instance Sharable Let
instance Sharable Lambda
instance Sharable Variable

module Feldspar.Core.Constructs.Array
data Array a
Parallel :: Array (Length :-> ((Index -> a) :-> Full [a]))
Sequential :: Array (Length :-> (st :-> ((Index -> st -> (a, st)) :-> Full [a])))
Append :: Array ([a] :-> ([a] :-> Full [a]))
GetIx :: Array ([a] :-> (Index :-> Full a))
SetIx :: Array ([a] :-> (Index :-> (a :-> Full [a])))
GetLength :: Array ([a] :-> Full Length)
SetLength :: Array (Length :-> ([a] :-> Full [a]))
instance ((Array :|| Type) :<: dom, (NUM :|| Type) :<: dom, Let :<: dom, (ORD :|| Type) :<: dom, (INTEGRAL :|| Type) :<: dom, (COMPLEX :|| Type) :<: dom, (Variable :|| Type) :<: dom, CLambda Type :<: dom, OptimizeSuper dom) => Optimize (Array :|| Type) dom
instance SizeProp (Array :|| Type)
instance Monotonic Array
instance Sharable Array
instance AlphaEq dom dom dom env => AlphaEq Array Array dom env
instance EvalBind Array
instance Eval Array
instance StringTree Array
instance Render Array
instance Equality Array
instance Semantic Array

module Feldspar.Core.Constructs.Future
data FUTURE a
MkFuture :: FUTURE (a :-> Full (FVal a))
Await :: FUTURE (FVal a :-> Full a)
instance ((FUTURE :|| Type) :<: dom, OptimizeSuper dom) => Optimize (FUTURE :|| Type) dom
instance SizeProp (FUTURE :|| Type)
instance Monotonic FUTURE
instance Sharable FUTURE
instance AlphaEq dom dom dom env => AlphaEq FUTURE FUTURE dom env
instance EvalBind FUTURE
instance Eval FUTURE
instance StringTree FUTURE
instance Render FUTURE
instance Equality FUTURE
instance Semantic FUTURE

module Feldspar.Core.Constructs.Mutable
data Mutable a
Run :: Mutable (Mut a :-> Full a)
monadProxy :: P Mut
instance (Mutable :<: dom, MONAD Mut :<: dom, OptimizeSuper dom) => Optimize Mutable dom
instance (MONAD Mut :<: dom, (Variable :|| Type) :<: dom, CLambda Type :<: dom, Let :<: dom, OptimizeSuper dom) => Optimize (MONAD Mut) dom
instance SizeProp Mutable
instance Monotonic Mutable
instance Sharable Mutable
instance SizeProp (MONAD Mut)
instance Monotonic (MONAD Mut)
instance Sharable (MONAD Mut)
instance AlphaEq dom dom dom env => AlphaEq Mutable Mutable dom env
instance EvalBind Mutable
instance Eval Mutable
instance StringTree Mutable
instance Render Mutable
instance Equality Mutable
instance Typed Mutable
instance Semantic Mutable

module Feldspar.Core.Constructs.Tuple
instance ((Select :|| Type) :<: dom, CLambda Type :<: dom, (Tuple :|| Type) :<: dom, Let :<: dom, (Variable :|| Type) :<: dom, OptimizeSuper dom) => Optimize (Select :|| Type) dom
instance ((Tuple :|| Type) :<: dom, (Select :|| Type) :<: dom, OptimizeSuper dom) => Optimize (Tuple :|| Type) dom
instance SizeProp (Select :|| Type)
instance Monotonic Select
instance Sharable Select
instance SizeProp (Tuple :|| Type)
instance Monotonic Tuple
instance Sharable Tuple

module Feldspar.Core.Constructs.Condition
instance ((Condition :|| Type) :<: dom, (Logic :|| Type) :<: dom, (EQ :|| Type) :<: dom, (ORD :|| Type) :<: dom, (Variable :|| Type) :<: dom, CLambda Type :<: dom, Monotonic dom, OptimizeSuper dom) => Optimize (Condition :|| Type) dom
instance SizeProp (Condition :|| Type)
instance Monotonic Condition
instance Sharable Condition

module Feldspar.Core.Constructs.Switch
data Switch a
Switch :: Switch (b :-> Full b)
isTree :: ((EQ :|| Type) :<: dom, (Condition :|| Type) :<: dom, AlphaEq dom dom (Decor Info (dom :|| Typeable)) [(VarId, VarId)]) => ASTF (Decor Info (dom :|| Typeable)) a -> ASTF (Decor Info (dom :|| Typeable)) b -> Bool
instance ((Switch :|| Type) :<: dom, (EQ :|| Type) :<: dom, (Condition :|| Type) :<: dom, OptimizeSuper dom) => Optimize (Switch :|| Type) dom
instance SizeProp (Switch :|| Type)
instance Monotonic Switch
instance Sharable Switch
instance AlphaEq dom dom dom env => AlphaEq Switch Switch dom env
instance EvalBind Switch
instance Eval Switch
instance StringTree Switch
instance Render Switch
instance Equality Switch
instance Semantic Switch

module Feldspar.Core.Constructs.Conversion
data Conversion a
F2I :: Conversion (b :-> Full a)
I2N :: Conversion (a :-> Full b)
B2I :: Conversion (Bool :-> Full a)
Round :: Conversion (b :-> Full a)
Ceiling :: Conversion (b :-> Full a)
Floor :: Conversion (b :-> Full a)
instance ((Conversion :|| Type) :<: dom, OptimizeSuper dom) => Optimize (Conversion :|| Type) dom
instance SizeProp (Conversion :|| Type)
instance Monotonic Conversion
instance Sharable Conversion
instance AlphaEq dom dom dom env => AlphaEq Conversion Conversion dom env
instance EvalBind Conversion
instance Eval Conversion
instance StringTree Conversion
instance Render Conversion
instance Equality Conversion
instance Semantic Conversion

module Feldspar.Core.Constructs.MutableReference
data MutableReference a
NewRef :: MutableReference (a :-> Full (Mut (IORef a)))
GetRef :: MutableReference (IORef a :-> Full (Mut a))
SetRef :: MutableReference (IORef a :-> (a :-> Full (Mut ())))
ModRef :: MutableReference (IORef a :-> ((a -> a) :-> Full (Mut ())))
instance (MutableReference :<: dom, MONAD Mut :<: dom, Project (CLambda Type) dom, Project (Variable :|| Type) dom, OptimizeSuper dom) => Optimize MutableReference dom
instance SizeProp MutableReference
instance Monotonic MutableReference
instance Sharable MutableReference
instance AlphaEq dom dom dom env => AlphaEq MutableReference MutableReference dom env
instance EvalBind MutableReference
instance Eval MutableReference
instance StringTree MutableReference
instance Render MutableReference
instance Equality MutableReference
instance Semantic MutableReference

module Feldspar.Core.Constructs.Loop
data LoopM m a
While :: LoopM m (m Bool :-> (m a :-> Full (m ())))
For :: LoopM m (Length :-> ((Index -> m a) :-> Full (m ())))
data Loop a
ForLoop :: Loop (Length :-> (a :-> ((Index -> a -> a) :-> Full a)))
WhileLoop :: Loop (a :-> ((a -> Bool) :-> ((a -> a) :-> Full a)))
instance ((Literal :|| Type) :<: dom, (Loop :|| Type) :<: dom, (Variable :|| Type) :<: dom, CLambda Type :<: dom, Let :<: dom, OptimizeSuper dom) => Optimize (Loop :|| Type) dom
instance (LoopM Mut :<: dom, (Variable :|| Type) :<: dom, CLambda Type :<: dom, MONAD Mut :<: dom, MutableReference :<: dom, Let :<: dom, Optimize (CLambda Type) dom, Optimize (MONAD Mut) dom, Optimize dom dom) => Optimize (LoopM Mut) dom
instance SizeProp (Loop :|| Type)
instance SizeProp (LoopM m)
instance Monotonic Loop
instance Sharable Loop
instance AlphaEq dom dom dom env => AlphaEq Loop Loop dom env
instance (AlphaEq dom dom dom env, Monad m) => AlphaEq (LoopM m) (LoopM m) dom env
instance EvalBind Loop
instance Eval Loop
instance StringTree Loop
instance Render Loop
instance Equality Loop
instance Monotonic (LoopM m)
instance Sharable (LoopM m)
instance Monad m => EvalBind (LoopM m)
instance Monad m => Eval (LoopM m)
instance Monad m => StringTree (LoopM m)
instance Monad m => Render (LoopM m)
instance Monad m => Equality (LoopM m)
instance Semantic Loop
instance Monad m => Semantic (LoopM m)

module Feldspar.Core.Constructs.MutableArray
data MutableArray a
NewArr :: MutableArray (Length :-> (a :-> Full (Mut (MArr a))))
NewArr_ :: MutableArray (Length :-> Full (Mut (MArr a)))
GetArr :: MutableArray (MArr a :-> (Index :-> Full (Mut a)))
SetArr :: MutableArray (MArr a :-> (Index :-> (a :-> Full (Mut ()))))
ArrLength :: MutableArray (MArr a :-> Full (Mut Length))
instance (MutableArray :<: dom, Optimize dom dom) => Optimize MutableArray dom
instance SizeProp MutableArray
instance Monotonic MutableArray
instance Sharable MutableArray
instance AlphaEq dom dom dom env => AlphaEq MutableArray MutableArray dom env
instance EvalBind MutableArray
instance Eval MutableArray
instance StringTree MutableArray
instance Render MutableArray
instance Equality MutableArray
instance Semantic MutableArray

module Feldspar.Core.Constructs.MutableToPure
data MutableToPure a
RunMutableArray :: MutableToPure (Mut (MArr a) :-> Full [a])
WithArray :: MutableToPure (MArr a :-> (([a] -> Mut b) :-> Full (Mut b)))
instance (MutableToPure :<: dom, Optimize dom dom) => Optimize MutableToPure dom
instance SizeProp MutableToPure
instance Monotonic MutableToPure
instance Sharable MutableToPure
instance AlphaEq dom dom dom env => AlphaEq MutableToPure MutableToPure dom env
instance EvalBind MutableToPure
instance Eval MutableToPure
instance StringTree MutableToPure
instance Render MutableToPure
instance Equality MutableToPure
instance Typed MutableToPure
instance Semantic MutableToPure

module Feldspar.Core.Constructs.Par
data ParFeature a
ParRun :: ParFeature (Par a :-> Full a)
ParNew :: ParFeature (Full (Par (IV a)))
ParGet :: ParFeature (IV a :-> Full (Par a))
ParPut :: ParFeature (IV a :-> (a :-> Full (Par ())))
ParFork :: ParFeature (Par () :-> Full (Par ()))
ParYield :: ParFeature (Full (Par ()))
monadProxy :: P Par
instance (MONAD Par :<: dom, (Variable :|| Type) :<: dom, CLambda Type :<: dom, Let :<: dom, OptimizeSuper dom) => Optimize (MONAD Par) dom
instance SizeProp (MONAD Par)
instance (MONAD Par :<: dom, ParFeature :<: dom, Optimize dom dom) => Optimize ParFeature dom
instance SizeProp ParFeature
instance Monotonic (MONAD Par)
instance Monotonic ParFeature
instance Sharable (MONAD Par)
instance Sharable ParFeature
instance AlphaEq dom dom dom env => AlphaEq ParFeature ParFeature dom env
instance EvalBind ParFeature
instance Eval ParFeature
instance StringTree ParFeature
instance Render ParFeature
instance Equality ParFeature
instance Semantic ParFeature

module Feldspar.Core.Constructs.SizeProp
data PropSize a
PropSize :: (Size a -> Size b) -> PropSize (a :-> (b :-> Full b))
instance ((PropSize :|| Type) :<: dom, OptimizeSuper dom) => Optimize (PropSize :|| Type) dom
instance AlphaEq dom dom dom env => AlphaEq PropSize PropSize dom env
instance Monotonic PropSize
instance Sharable PropSize
instance SizeProp (PropSize :|| Type)
instance EvalBind PropSize
instance Eval PropSize
instance StringTree PropSize
instance Render PropSize
instance Equality PropSize
instance Semantic PropSize

module Feldspar.Core.Constructs
type FeldSymbols = (Decor SourceInfo1 Identity :|| Type) :+: ((Condition :|| Type) :+: ((FFI :|| Type) :+: ((Literal :|| Type) :+: ((Select :|| Type) :+: ((Tuple :|| Type) :+: ((Array :|| Type) :+: ((BITS :|| Type) :+: ((COMPLEX :|| Type) :+: ((Conversion :|| Type) :+: ((EQ :|| Type) :+: ((Error :|| Type) :+: ((FLOATING :|| Type) :+: ((REALFLOAT :|| Type) :+: ((FRACTIONAL :|| Type) :+: ((FUTURE :|| Type) :+: ((INTEGRAL :|| Type) :+: ((Logic :|| Type) :+: ((Loop :|| Type) :+: ((NUM :|| Type) :+: ((NoInline :|| Type) :+: ((ORD :|| Type) :+: ((PropSize :|| Type) :+: ((Save :|| Type) :+: ((Switch :|| Type) :+: ((Trace :|| Type) :+: (Let :+: (ConditionM Mut :+: (LoopM Mut :+: (MONAD Mut :+: (Mutable :+: (MutableArray :+: (MutableReference :+: (MutableToPure :+: (MONAD Par :+: (ParFeature :+: Empty)))))))))))))))))))))))))))))))))))
type FeldDom = FODomain FeldSymbols Typeable Type
newtype FeldDomain a
FeldDomain :: HODomain FeldSymbols Typeable Type a -> FeldDomain a
getFeldDomain :: FeldDomain a -> HODomain FeldSymbols Typeable Type a
toFeld :: ASTF (HODomain FeldSymbols Typeable Type) a -> ASTF FeldDomain a
fromFeld :: ASTF FeldDomain a -> ASTF (HODomain FeldSymbols Typeable Type) a
newtype Data a
Data :: ASTF FeldDomain a -> Data a
unData :: Data a -> ASTF FeldDomain a
type SyntacticFeld a = (Syntactic a, Domain a ~ FeldDomain, Typeable (Internal a))

-- | Specialization of the <a>Syntactic</a> class for the Feldspar domain
class (SyntacticFeld a, Type (Internal a)) => Syntax a
reifyF :: SyntacticFeld a => a -> ASTF FeldDom (Internal a)
sugarSymF :: (ApplySym sig b FeldDomain, SyntacticN c b, InjectC (feature :|| Type) (HODomain FeldSymbols Typeable Type) (DenResult sig), Type (DenResult sig)) => feature sig -> c
instance Typeable1 Data
instance Project sym FeldSymbols => Project sym FeldDomain
instance Type a => Show (Data a)
instance Type a => Eq (Data a)
instance (SyntacticFeld a, Type (Internal a)) => Syntax a
instance Type a => Syntactic (Data a)
instance IsHODomain FeldDomain Typeable Type
instance (InjectC sym FeldSymbols a, Typeable a) => InjectC sym FeldDomain a
instance Constrained FeldDomain

module Feldspar.Core.Frontend.Tuple
instance TupleSat FeldDomain Type

module Feldspar.Core.Frontend.Array
parallel :: Type a => Data Length -> (Data Index -> Data a) -> Data [a]
sequential :: (Type a, Syntax s) => Data Length -> s -> (Data Index -> s -> (Data a, s)) -> Data [a]
append :: Type a => Data [a] -> Data [a] -> Data [a]
getLength :: Type a => Data [a] -> Data Length

-- | Change the length of the vector to the supplied value. If the supplied
--   length is greater than the old length, the new elements will have
--   undefined value.
setLength :: Type a => Data Length -> Data [a] -> Data [a]
getIx :: Type a => Data [a] -> Data Index -> Data a
setIx :: Type a => Data [a] -> Data Index -> Data a -> Data [a]

-- | Array patch
(|>) :: (Sized a, CollMap a a) => Patch (CollSize a) (CollSize a) -> Patch (Elem a) (Elem a) -> Patch a a
instance (Type a, Type b) => CollMap (Data [a]) (Data [b])
instance Type a => Sized (Data [a])
instance Type a => Indexed (Data [a])

module Feldspar.Core.Frontend.Binding

-- | Share an expression in the scope of a function
share :: (Syntax a, Syntax b) => a -> (a -> b) -> b

-- | Share the intermediate result when composing functions
(.<) :: (Syntax b, Syntax c) => (b -> c) -> (a -> b) -> a -> c

-- | Share an expression in the scope of a function
($<) :: (Syntax a, Syntax b) => (a -> b) -> a -> b

module Feldspar.Core.Frontend.Literal
value :: Syntax a => Internal a -> a
false :: Data Bool
true :: Data Bool
instance Syntactic ()

module Feldspar.Core.Frontend.Num
class (Type a, Num a, Num (Size a)) => Numeric a where fromIntegerNum = value . fromInteger absNum = sugarSymF Abs signumNum = sugarSymF Sign addNum = sugarSymF Add subNum = sugarSymF Sub mulNum = sugarSymF Mul
fromIntegerNum :: Numeric a => Integer -> Data a
absNum :: Numeric a => Data a -> Data a
signumNum :: Numeric a => Data a -> Data a
addNum :: Numeric a => Data a -> Data a -> Data a
subNum :: Numeric a => Data a -> Data a -> Data a
mulNum :: Numeric a => Data a -> Data a -> Data a
instance Numeric a => Num (Data a)
instance (Type a, RealFloat a) => Numeric (Complex a)
instance Numeric Double
instance Numeric Float
instance Numeric IntN
instance Numeric Int64
instance Numeric Int32
instance Numeric Int16
instance Numeric Int8
instance Numeric WordN
instance Numeric Word64
instance Numeric Word32
instance Numeric Word16
instance Numeric Word8

module Feldspar.Core.Frontend.Complex
complex :: (Numeric a, RealFloat a) => Data a -> Data a -> Data (Complex a)
realPart :: (Numeric a, RealFloat a) => Data (Complex a) -> Data a
imagPart :: (Numeric a, RealFloat a) => Data (Complex a) -> Data a
conjugate :: (Numeric a, RealFloat a) => Data (Complex a) -> Data (Complex a)
mkPolar :: (Numeric a, RealFloat a) => Data a -> Data a -> Data (Complex a)
cis :: (Numeric a, RealFloat a) => Data a -> Data (Complex a)
magnitude :: (Numeric a, RealFloat a) => Data (Complex a) -> Data a
phase :: (Numeric a, RealFloat a) => Data (Complex a) -> Data a
polar :: (Numeric a, RealFloat a) => Data (Complex a) -> (Data a, Data a)
(+.) :: (Numeric a, RealFloat a) => Data a -> Data a -> Data (Complex a)
iunit :: (Numeric a, RealFloat a) => Data (Complex a)

module Feldspar.Core.Frontend.Condition
condition :: Syntax a => Data Bool -> a -> a -> a

-- | Condition operator. Use as follows:
--   
--   <pre>
--   cond1 ? ex1 $
--   cond2 ? ex2 $
--   cond3 ? ex3 $
--     exDefault
--   </pre>
(?) :: Syntax a => Data Bool -> a -> a -> a

module Feldspar.Core.Frontend.Error
undef :: Syntax a => a

-- | Assert that the condition holds or fail with message
assertMsg :: Syntax a => String -> Data Bool -> a -> a

-- | Assert that the condition holds, the conditions string representation
--   is used as the message
assert :: Syntax a => Data Bool -> a -> a
err :: Syntax a => String -> a

module Feldspar.Core.Frontend.Fractional

-- | Fractional types. The relation to the standard <a>Fractional</a> class
--   is
--   
--   <pre>
--   instance <a>Fraction</a> a =&gt; <a>Fractional</a> (<a>Data</a> a)
--   </pre>
class (Fractional a, Numeric a) => Fraction a where fromRationalFrac = value . fromRational divFrac = sugarSymF DivFrac
fromRationalFrac :: Fraction a => Rational -> Data a
divFrac :: Fraction a => Data a -> Data a -> Data a
instance Fraction a => Fractional (Data a)
instance (Fraction a, RealFloat a) => Fraction (Complex a)
instance Fraction Double
instance Fraction Float

module Feldspar.Core.Frontend.Floating
class (Fraction a, Floating a) => Floating a where pi = sugarSymF Pi exp = sugarSymF Exp sqrt = sugarSymF Sqrt log = sugarSymF Log ** = sugarSymF Pow logBase = sugarSymF LogBase sin = sugarSymF Sin tan = sugarSymF Tan cos = sugarSymF Cos asin = sugarSymF Asin atan = sugarSymF Atan acos = sugarSymF Acos sinh = sugarSymF Sinh tanh = sugarSymF Tanh cosh = sugarSymF Cosh asinh = sugarSymF Asinh atanh = sugarSymF Atanh acosh = sugarSymF Acosh
pi :: Floating a => Data a
exp :: Floating a => Data a -> Data a
sqrt :: Floating a => Data a -> Data a
log :: Floating a => Data a -> Data a
(**) :: Floating a => Data a -> Data a -> Data a
logBase :: Floating a => Data a -> Data a -> Data a
sin :: Floating a => Data a -> Data a
tan :: Floating a => Data a -> Data a
cos :: Floating a => Data a -> Data a
asin :: Floating a => Data a -> Data a
atan :: Floating a => Data a -> Data a
acos :: Floating a => Data a -> Data a
sinh :: Floating a => Data a -> Data a
tanh :: Floating a => Data a -> Data a
cosh :: Floating a => Data a -> Data a
asinh :: Floating a => Data a -> Data a
atanh :: Floating a => Data a -> Data a
acosh :: Floating a => Data a -> Data a
π :: Floating a => Data a
instance (Fraction a, RealFloat a) => Floating (Complex a)
instance Floating Double
instance Floating Float


-- | Tracing execution of Feldspar expressions
module Feldspar.Core.Frontend.Save

-- | An identity function that guarantees that the result will be computed
--   as a sub-result of the whole program. This is useful to prevent
--   certain optimizations.
--   
--   Exception: Currently constant folding does not respect <a>save</a>.
save :: Syntax a => a -> a

-- | Equivalent to <a>save</a>. When applied to a lazy data structure,
--   <a>force</a> (and <a>save</a>) has the effect of forcing evaluation of
--   the whole structure.
force :: Syntax a => a -> a

module Feldspar.Core.Frontend.Future
newtype Future a
Future :: Data (FVal (Internal a)) -> Future a
unFuture :: Future a -> Data (FVal (Internal a))
later :: (Syntax a, Syntax b) => (a -> b) -> Future a -> Future b
pval :: (Syntax a, Syntax b) => (a -> b) -> a -> b
future :: Syntax a => a -> Future a
await :: Syntax a => Future a -> a
instance Syntax a => Syntactic (Future a)

module Feldspar.Core.Frontend.Logic
not :: Data Bool -> Data Bool
(&&) :: Data Bool -> Data Bool -> Data Bool
(||) :: Data Bool -> Data Bool -> Data Bool

-- | Lazy conjunction, second argument only evaluated if necessary
(&&*) :: Data Bool -> Data Bool -> Data Bool

-- | Lazy disjunction, second argument only evaluated if necessary
(||*) :: Data Bool -> Data Bool -> Data Bool

module Feldspar.Core.Frontend.Mutable
newtype M a
M :: Mon FeldDomain Mut a -> M a
unM :: M a -> Mon FeldDomain Mut a
runMutable :: Syntax a => M a -> a
when :: Data Bool -> M () -> M ()
unless :: Data Bool -> M () -> M ()
instance Functor M
instance Applicative M
instance Monad M
instance Syntax a => Syntactic (M a)

module Feldspar.Core.Frontend.ConditionM
ifM :: Syntax a => Data Bool -> M a -> M a -> M a
whenM :: Data Bool -> M () -> M ()
unlessM :: Data Bool -> M () -> M ()

module Feldspar.Core.Frontend.Loop
forLoop :: Syntax a => Data Length -> a -> (Data Index -> a -> a) -> a
whileLoop :: Syntax a => a -> (a -> Data Bool) -> (a -> a) -> a
forM :: Syntax a => Data Length -> (Data Index -> M a) -> M ()
whileM :: Syntax a => M (Data Bool) -> M a -> M ()

module Feldspar.Core.Frontend.MutableArray

-- | Create a new <tt>Mutable</tt> Array and intialize all elements
newArr :: Type a => Data Length -> Data a -> M (Data (MArr a))

-- | Create a new <tt>Mutable</tt> Array but leave the elements
--   un-initialized
newArr_ :: Type a => Data Length -> M (Data (MArr a))

-- | Create a new <tt>Mutable</tt> Array and initialize with elements from
--   the list
newListArr :: Type a => [Data a] -> M (Data (MArr a))

-- | Extract the element at index
getArr :: Type a => Data (MArr a) -> Data Index -> M (Data a)

-- | Replace the value at index
setArr :: Type a => Data (MArr a) -> Data Index -> Data a -> M ()

-- | Modify the element at index
modifyArr :: Type a => Data (MArr a) -> Data Index -> (Data a -> Data a) -> M ()

-- | Query the length of the array
arrLength :: Type a => Data (MArr a) -> M (Data Length)

-- | Modify all elements
mapArray :: Type a => (Data a -> Data a) -> Data (MArr a) -> M (Data (MArr a))
forArr :: Syntax a => Data Length -> (Data Index -> M a) -> M ()

-- | Swap two elements
swap :: Type a => Data (MArr a) -> Data Index -> Data Index -> M ()

module Feldspar.Core.Frontend.MutableReference
newtype Ref a
Ref :: Data (IORef (Internal a)) -> Ref a
unRef :: Ref a -> Data (IORef (Internal a))
newRef :: Syntax a => a -> M (Ref a)
getRef :: Syntax a => Ref a -> M a
setRef :: Syntax a => Ref a -> a -> M ()
modifyRef :: Syntax a => Ref a -> (a -> a) -> M ()
instance Syntax a => Syntactic (Ref a)

module Feldspar.Core.Frontend.MutableToPure
withArray :: (Type a, Syntax b) => Data (MArr a) -> (Data [a] -> M b) -> M b
runMutableArray :: Type a => M (Data (MArr a)) -> Data [a]
freezeArray :: Type a => Data (MArr a) -> M (Data [a])
thawArray :: Type a => Data [a] -> M (Data (MArr a))

module Feldspar.Core.Frontend.NoInline
noInline :: Syntax a => a -> a

module Feldspar.Core.Frontend.Par
newtype P a
P :: Mon FeldDomain Par a -> P a
unP :: P a -> Mon FeldDomain Par a
newtype IVar a
IVar :: Data (IV (Internal a)) -> IVar a
unIVar :: IVar a -> Data (IV (Internal a))
instance Functor P
instance Applicative P
instance Monad P
instance Syntax a => Syntactic (IVar a)
instance Syntax a => Syntactic (P a)


-- | Source-code annotations
module Feldspar.Core.Frontend.SourceInfo

-- | Annotate an expression with information about its source code
sourceData :: Type a => SourceInfo1 a -> Data a -> Data a

module Feldspar.Core.Frontend.RealFloat
class (Type a, RealFloat a) => RealFloat a where atan2 = sugarSymF Atan2
atan2 :: RealFloat a => Data a -> Data a -> Data a
instance RealFloat Double
instance RealFloat Float


-- | Tracing execution of Feldspar expressions
module Feldspar.Core.Frontend.Trace

-- | Tracing execution of an expression. Semantically, this is the identity
--   function, but a back end may treat this function specially, for
--   example write its arguments to a log.
trace :: Numeric a => Int -> Data a -> Data a

module Feldspar.Core.Frontend.FFI
foreignImport :: (Type (DenResult a), SyntacticN c b, ApplySym a b FeldDomain) => String -> Denotation a -> c

module Feldspar.Par
data P a
data IVar a
runPar :: Syntax a => P a -> a
new :: Syntax a => P (IVar a)
get :: Syntax a => IVar a -> P a
put :: Syntax a => IVar a -> a -> P ()
fork :: P () -> P ()
yield :: P ()
spawn :: Syntax a => P a -> P (IVar a)
pval :: Syntax a => a -> P (IVar a)
parMap :: Syntax b => (a -> b) -> [a] -> P [b]
parMapM :: Syntax b => (a -> P b) -> [a] -> P [b]
divConq :: Syntax b => (a -> Bool) -> (a -> [a]) -> ([b] -> b) -> (a -> b) -> a -> P b


-- | The functions in this module can be used to help size inference
--   (which, in turn, helps deriving upper bounds of array sizes and helps
--   optimization).
module Feldspar.Core.Frontend.SizeProp

-- | An identity function affecting the abstract size information used
--   during optimization. The application of a <a>SizeCap</a> is a
--   <i>guarantee</i> (by the caller) that the argument is within a certain
--   size (determined by the creator of the <a>SizeCap</a>, e.g.
--   <a>sizeProp</a>).
--   
--   <i>Warning: If the guarantee is not fulfilled, optimizations become
--   unsound!</i>
--   
--   In general, the size of the resulting value is the intersection of the
--   cap size and the size obtained by ordinary size inference. That is, a
--   <a>SizeCap</a> can only make the size more precise, not less precise.
type SizeCap a = Data a -> Data a

-- | <tt>sizeProp prop a b</tt>: A guarantee that <tt>b</tt> is within the
--   size <tt>(prop sa)</tt>, where <tt>sa</tt> is the size of <tt>a</tt>.
sizeProp :: (Syntax a, Type b) => (Size (Internal a) -> Size b) -> a -> SizeCap b

-- | A guarantee that the argument is within the given size
cap :: Type a => Size a -> SizeCap a

-- | <tt>notAbove a b</tt>: A guarantee that <tt>b &lt;= a</tt> holds
notAbove :: (Type a, Bounded a, Size a ~ Range a) => Data a -> SizeCap a

-- | <tt>notBelow a b</tt>: A guarantee that <tt>b &gt;= a</tt> holds
notBelow :: (Type a, Bounded a, Size a ~ Range a) => Data a -> SizeCap a

-- | <tt>between l u a</tt>: A guarantee that <tt>l &lt;= a &lt;= u</tt>
--   holds
between :: (Type a, Bounded a, Size a ~ Range a) => Data a -> Data a -> SizeCap a


-- | Reexports a small subset of the <a>Prelude</a> to open up for reusing
--   <a>Prelude</a> identifiers in Feldspar
module Feldspar.Prelude

module Feldspar.Core.Frontend.Eq

-- | Redefinition of the standard <a>Eq</a> class for Feldspar
class Type a => Eq a where == = sugarSymF Equal /= = sugarSymF NotEqual
(==) :: Eq a => Data a -> Data a -> Data Bool
(/=) :: Eq a => Data a -> Data a -> Data Bool
instance (Eq a, RealFloat a) => Eq (Complex a)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) => Eq (a, b, c, d, e, f, g)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => Eq (a, b, c, d, e, f)
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e)
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
instance (Eq a, Eq b, Eq c) => Eq (a, b, c)
instance (Eq a, Eq b) => Eq (a, b)
instance Eq IntN
instance Eq Int64
instance Eq Int32
instance Eq Int16
instance Eq Int8
instance Eq WordN
instance Eq Word64
instance Eq Word32
instance Eq Word16
instance Eq Word8
instance Eq Double
instance Eq Float
instance Eq Bool
instance Eq ()

module Feldspar.Core.Frontend.Switch

-- | Select between the cases based on the value of the scrutinee.

-- | <i>Deprecated: select will generate a tree of if-statements. Use
--   switch instead </i>
select :: (Eq a, Syntax b) => Data a -> [(Data a, b)] -> b -> b

-- | Select between the cases based on the value of the scrutinee. If no
--   match is found return the first argument
switch :: (Eq (Internal a), Syntax a, Syntax b) => b -> [(a, b)] -> a -> b

module Feldspar.Core.Frontend.Ord

-- | Redefinition of the standard <a>Ord</a> class for Feldspar
class (Eq a, Ord a, Ord (Size a)) => Ord a where < = sugarSymF LTH > = sugarSymF GTH <= = sugarSymF LTE >= = sugarSymF GTE min = sugarSymF Min max = sugarSymF Max
(<) :: Ord a => Data a -> Data a -> Data Bool
(>) :: Ord a => Data a -> Data a -> Data Bool
(<=) :: Ord a => Data a -> Data a -> Data Bool
(>=) :: Ord a => Data a -> Data a -> Data Bool
min :: Ord a => Data a -> Data a -> Data a
max :: Ord a => Data a -> Data a -> Data a
instance Ord Double
instance Ord Float
instance Ord IntN
instance Ord WordN
instance Ord Int64
instance Ord Word64
instance Ord Int32
instance Ord Word32
instance Ord Int16
instance Ord Word16
instance Ord Int8
instance Ord Word8
instance Ord Bool
instance Ord ()

module Feldspar.Core.Frontend.Integral
class (Ord a, Numeric a, BoundedInt a, Integral a, Size a ~ Range a) => Integral a where quot = sugarSymF Quot rem = sugarSymF Rem div = sugarSymF Div mod = sugarSymF Mod ^ = sugarSymF Exp
quot :: Integral a => Data a -> Data a -> Data a
rem :: Integral a => Data a -> Data a -> Data a
div :: Integral a => Data a -> Data a -> Data a
mod :: Integral a => Data a -> Data a -> Data a
(^) :: Integral a => Data a -> Data a -> Data a
divSem :: Integral a => Data a -> Data a -> Data a
instance Integral IntN
instance Integral Int64
instance Integral Int32
instance Integral Int16
instance Integral Int8
instance Integral WordN
instance Integral Word64
instance Integral Word32
instance Integral Word16
instance Integral Word8

module Feldspar.Core.Frontend.Bits
class (Type a, Bits a, Integral a, Bounded a, Size a ~ Range a) => Bits a where .&. = sugarSymF BAnd .|. = sugarSymF BOr xor = sugarSymF BXor complement = sugarSymF Complement bit = sugarSymF Bit setBit = sugarSymF SetBit clearBit = sugarSymF ClearBit complementBit = sugarSymF ComplementBit testBit = sugarSymF TestBit shiftLU = sugarSymF ShiftLU shiftRU = sugarSymF ShiftRU shiftL = sugarSymF ShiftL shiftR = sugarSymF ShiftR rotateLU = sugarSymF RotateLU rotateRU = sugarSymF RotateRU rotateL = sugarSymF RotateL rotateR = sugarSymF RotateR reverseBits = sugarSymF ReverseBits bitScan = sugarSymF BitScan bitCount = sugarSymF BitCount bitSize = value . bitSize' bitSize' = const $ fromIntegral $ finiteBitSize (undefined :: a) isSigned = value . isSigned' isSigned' = const $ isSigned (undefined :: a)
(.&.) :: Bits a => Data a -> Data a -> Data a
(.|.) :: Bits a => Data a -> Data a -> Data a
xor :: Bits a => Data a -> Data a -> Data a
complement :: Bits a => Data a -> Data a
bit :: Bits a => Data Index -> Data a
setBit :: Bits a => Data a -> Data Index -> Data a
clearBit :: Bits a => Data a -> Data Index -> Data a
complementBit :: Bits a => Data a -> Data Index -> Data a
testBit :: Bits a => Data a -> Data Index -> Data Bool
shiftLU :: Bits a => Data a -> Data Index -> Data a
shiftRU :: Bits a => Data a -> Data Index -> Data a
shiftL :: Bits a => Data a -> Data IntN -> Data a
shiftR :: Bits a => Data a -> Data IntN -> Data a
rotateLU :: Bits a => Data a -> Data Index -> Data a
rotateRU :: Bits a => Data a -> Data Index -> Data a
rotateL :: Bits a => Data a -> Data IntN -> Data a
rotateR :: Bits a => Data a -> Data IntN -> Data a
reverseBits :: Bits a => Data a -> Data a
bitScan :: Bits a => Data a -> Data Index
bitCount :: Bits a => Data a -> Data Index
bitSize :: Bits a => Data a -> Data Index
bitSize' :: Bits a => Data a -> Index
isSigned :: Bits a => Data a -> Data Bool
isSigned' :: Bits a => Data a -> Bool
finiteBitSize :: Bits b => b -> Int
(⊕) :: Bits a => Data a -> Data a -> Data a
(.<<.) :: Bits a => Data a -> Data Index -> Data a
(.>>.) :: Bits a => Data a -> Data Index -> Data a

-- | Set all bits to one
allOnes :: Bits a => Data a

-- | Set the <tt>n</tt> lowest bits to one
oneBits :: Bits a => Data Index -> Data a

-- | Extract the <tt>k</tt> lowest bits
lsbs :: Bits a => Data Index -> Data a -> Data a
instance Bits IntN
instance Bits Int64
instance Bits Int32
instance Bits Int16
instance Bits Int8
instance Bits WordN
instance Bits Word64
instance Bits Word32
instance Bits Word16
instance Bits Word8

module Feldspar.Core.Frontend.Conversion
i2f :: (Integral a, Numeric b, RealFloat b) => Data a -> Data b
f2i :: (Integral a, Numeric b, RealFloat b) => Data b -> Data a
i2n :: (Integral a, Numeric b) => Data a -> Data b
b2i :: Integral a => Data Bool -> Data a
truncate :: (Integral a, Numeric b, RealFloat b) => Data b -> Data a
round :: (Integral a, Numeric b, RealFloat b) => Data b -> Data a
ceiling :: (Integral a, Numeric b, RealFloat b) => Data b -> Data a
floor :: (Integral a, Numeric b, RealFloat b) => Data b -> Data a

module Feldspar.Core.Frontend
class Syntactic a where type family Internal a1 :: *
data FeldDomain a
data Data a

-- | Specialization of the <a>Syntactic</a> class for the Feldspar domain
class (SyntacticFeld a, Type (Internal a)) => Syntax a

-- | A record with options for explicit passing in rewrite rules.
data FeldOpts

-- | Default options.
defaultFeldOpts :: FeldOpts

-- | Reification and optimization of a Feldspar program
reifyFeld :: SyntacticFeld a => FeldOpts -> BitWidth n -> a -> ASTF (Decor Info FeldDom) (Internal a)

-- | Reification of a Feldspar program
reifyFeldUnOpt :: SyntacticFeld a => FeldOpts -> BitWidth n -> a -> ASTF FeldDom (Internal a)
showExpr :: SyntacticFeld a => a -> String

-- | Print an optimized expression
printExpr :: SyntacticFeld a => a -> IO ()

-- | Print an optimized expression with options
printExprWith :: SyntacticFeld a => FeldOpts -> a -> IO ()

-- | Print an unoptimized expression
printExprUnOpt :: SyntacticFeld a => a -> IO ()

-- | Show the syntax tree using Unicode art
showAST :: SyntacticFeld a => a -> String

-- | Draw the syntax tree on the terminal using Unicode art
drawAST :: SyntacticFeld a => a -> IO ()

-- | Convert the syntax tree to an HTML file with foldable nodes
writeHtmlAST :: SyntacticFeld a => FilePath -> a -> IO ()

-- | Draw a syntax tree decorated with type and size information
showDecor :: SyntacticFeld a => a -> String

-- | Draw a syntax tree decorated with type and size information
drawDecor :: SyntacticFeld a => a -> IO ()
eval :: SyntacticFeld a => a -> Internal a
evalTarget :: (SyntacticFeld a, BoundedInt (GenericInt U n), BoundedInt (GenericInt S n)) => BitWidth n -> a -> Internal a
desugar :: Syntax a => a -> Data (Internal a)
sugar :: Syntax a => Data (Internal a) -> a
resugar :: (Syntax a, Syntax b, Internal a ~ Internal b) => a -> b
(===>) :: Testable prop => Data Bool -> prop -> Property
(====) :: Equal a => a -> a -> Property
tData :: Patch a a -> Patch (Data a) (Data a)
tArr1 :: Patch a a -> Patch (Data [a]) (Data [a])
tArr2 :: Patch a a -> Patch (Data [[a]]) (Data [[a]])
tM :: Patch a a -> Patch (M a) (M a)

-- | Integer logarithm in base 2 Based on an algorithm in Hacker's Delight
ilog2 :: Bits a => Data a -> Data Index

-- | Count leading zeros Based on an algorithm in Hacker's Delight
nlz :: Bits a => Data a -> Data Index
instance [overlap ok] (Show a, Arbitrary a, Equal b) => Equal (a -> b)
instance [overlap ok] (Eq a, Show a) => Equal a
instance [overlap ok] Testable (Data Bool)
instance [overlap ok] (Type a, Arbitrary a) => Arbitrary (Data a)


-- | The Feldspar core language
module Feldspar.Core

-- | Complex numbers are an algebraic type.
--   
--   For a complex number <tt>z</tt>, <tt><a>abs</a> z</tt> is a number
--   with the magnitude of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the phase of
--   <tt>z</tt>, but unit magnitude.
data Complex a :: * -> *

-- | forms a complex number from its real and imaginary rectangular
--   components.
(:+) :: !a -> !a -> Complex a

-- | A bounded range of values of type <tt>a</tt>
data Range a
Range :: a -> a -> Range a
lowerBound :: Range a -> a
upperBound :: Range a -> a

-- | Convenience alias for bounded integers
type BoundedInt a = (BoundedSuper a, BoundedSuper (UnsignedRep a))


-- | Interface to the essential parts of the Feldspar language. High-level
--   libraries have to be imported separately.
module Feldspar

module Feldspar.Vector.Internal

-- | Symbolic vector
data Vector a
Empty :: Vector a
Indexed :: Data Length -> (Data Index -> a) -> Vector a -> Vector a
segmentLength :: Vector a -> Data Length
segmentIndex :: Vector a -> Data Index -> a
continuation :: Vector a -> Vector a

-- | Non-nested vector
type Vector1 a = Vector (Data a)

-- | Two-level nested vector
type Vector2 a = Vector (Vector (Data a))
indexed :: Data Length -> (Data Index -> a) -> Vector a

-- | Breaks up a segmented vector into a list of single-segment vectors.
segments :: Vector a -> [Vector a]
length :: Vector a -> Data Length

-- | Converts a segmented vector to a vector with a single segment.
mergeSegments :: Syntax a => Vector a -> Vector a

-- | Converts a non-nested vector to a core vector.
freezeVector :: Type a => Vector (Data a) -> Data [a]

-- | Converts a non-nested core array to a vector.
thawVector :: Type a => Data [a] -> Vector (Data a)
thawVector' :: Type a => Length -> Data [a] -> Vector (Data a)

-- | Change the length of the vector to the supplied value. If the supplied
--   length is greater than the old length, the new elements will have
--   undefined value. The resulting vector has only one segment.
newLen :: Syntax a => Data Length -> Vector a -> Vector a

-- | Change the length of the vector before and after calling the function.
withLen :: (Syntax a, Syntax b) => Data Length -> (Vector a -> Vector b) -> Vector a -> Vector b
(++) :: Vector a -> Vector a -> Vector a
take :: Data Length -> Vector a -> Vector a
drop :: Data Length -> Vector a -> Vector a
splitAt :: Data Index -> Vector a -> (Vector a, Vector a)
head :: Syntax a => Vector a -> a
last :: Syntax a => Vector a -> a
tail :: Vector a -> Vector a
init :: Vector a -> Vector a
tails :: Vector a -> Vector (Vector a)
inits :: Vector a -> Vector (Vector a)
inits1 :: Vector a -> Vector (Vector a)

-- | Permute a single-segment vector
permute' :: (Data Length -> Data Index -> Data Index) -> (Vector a -> Vector a)

-- | Permute a vector
permute :: Syntax a => (Data Length -> Data Index -> Data Index) -> (Vector a -> Vector a)
reverse :: Syntax a => Vector a -> Vector a
rotateVecL :: Syntax a => Data Index -> Vector a -> Vector a
rotateVecR :: Syntax a => Data Index -> Vector a -> Vector a
replicate :: Data Length -> a -> Vector a

-- | <tt>enumFromTo m n</tt>: Enumerate the integers from <tt>m</tt> to
--   <tt>n</tt>
enumFromTo :: Integral a => Data a -> Data a -> Vector (Data a)

-- | <tt>enumFrom m</tt>: Enumerate the indexes from <tt>m</tt> to
--   <a>maxBound</a>
enumFrom :: Integral a => Data a -> Vector (Data a)

-- | See <a>enumFromTo</a>
(...) :: Integral a => Data a -> Data a -> Vector (Data a)

-- | <a>map</a> <tt>f v</tt> is the <a>Vector</a> obtained by applying f to
--   each element of <tt>f</tt>.
map :: (a -> b) -> Vector a -> Vector b

-- | Zipping two <a>Vector</a>s
zip :: (Syntax a, Syntax b) => Vector a -> Vector b -> Vector (a, b)

-- | Zipping three <a>Vector</a>s
zip3 :: (Syntax a, Syntax b, Syntax c) => Vector a -> Vector b -> Vector c -> Vector (a, b, c)

-- | Zipping four <a>Vector</a>s
zip4 :: (Syntax a, Syntax b, Syntax c, Syntax d) => Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)

-- | Zipping five <a>Vector</a>s
zip5 :: (Syntax a, Syntax b, Syntax c, Syntax d, Syntax e) => Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)

-- | Unzip to two <a>Vector</a>s
unzip :: Vector (a, b) -> (Vector a, Vector b)

-- | Unzip to three <a>Vector</a>s
unzip3 :: Vector (a, b, c) -> (Vector a, Vector b, Vector c)

-- | Unzip to four <a>Vector</a>s
unzip4 :: Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)

-- | Unzip to five <a>Vector</a>s
unzip5 :: Vector (a, b, c, d, e) -> (Vector a, Vector b, Vector c, Vector d, Vector e)

-- | Generalization of <a>zip</a> using the supplied function instead of
--   tupling to combine the elements
zipWith :: (Syntax a, Syntax b) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Generalization of <a>zip3</a> using the supplied function instead of
--   tupling to combine the elements
zipWith3 :: (Syntax a, Syntax b, Syntax c) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d

-- | Generalization of <a>zip4</a> using the supplied function instead of
--   tupling to combine the elements
zipWith4 :: (Syntax a, Syntax b, Syntax c, Syntax d) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e

-- | Generalization of <a>zip5</a> using the supplied function instead of
--   tupling to combine the elements
zipWith5 :: (Syntax a, Syntax b, Syntax c, Syntax d, Syntax e) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f

-- | Corresponds to the standard <tt>foldl</tt>.
fold :: Syntax a => (a -> b -> a) -> a -> Vector b -> a

-- | Corresponds to the standard <tt>foldl1</tt>.
fold1 :: Syntax a => (a -> a -> a) -> Vector a -> a
sum :: (Syntax a, Num a) => Vector a -> a
maximum :: Ord a => Vector (Data a) -> Data a
minimum :: Ord a => Vector (Data a) -> Data a
or :: Vector (Data Bool) -> Data Bool
and :: Vector (Data Bool) -> Data Bool
any :: (a -> Data Bool) -> Vector a -> Data Bool
all :: (a -> Data Bool) -> Vector a -> Data Bool
eqVector :: Eq a => Vector (Data a) -> Vector (Data a) -> Data Bool

-- | Scalar product of two vectors
scalarProd :: (Syntax a, Num a) => Vector a -> Vector a -> a
scan :: (Syntax a, Syntax b) => (a -> b -> a) -> a -> Vector b -> Vector a
tVec :: Patch a a -> Patch (Vector a) (Vector a)
tVec1 :: Patch a a -> Patch (Vector (Data a)) (Vector (Data a))
tVec2 :: Patch a a -> Patch (Vector (Vector (Data a))) (Vector (Vector (Data a)))
instance (Arbitrary (Internal a), Syntax a) => Arbitrary (Vector a)
instance CollMap (Vector a) (Vector b)
instance Syntax a => Sized (Vector a)
instance Syntax a => Indexed (Vector a)
instance (Syntax a, Show (Internal a)) => Show (Vector a)
instance Syntax a => Syntactic (Vector a)


-- | A module for <i>virtual vectors</i>. Many of the functions defined
--   here are imitations of Haskell's list operations, and to a first
--   approximation they behave accordingly.
--   
--   A virtual vector is normally guaranteed not to be present in the
--   generated code. The only exceptions are:
--   
--   <ul>
--   <li>when it is explicitly forced using the functions <tt>force</tt> or
--   <tt>desugar</tt></li>
--   <li>when it is the input or output of a program</li>
--   <li>when it is accessed by a function outside the
--   <a>Feldspar.Vector</a> API, for example, <tt>condition</tt> or
--   <tt>forLoop</tt></li>
--   </ul>
--   
--   Note also that most operations only introduce a small constant
--   overhead on the vector. The exceptions are
--   
--   <ul>
--   <li><a>fold</a></li>
--   <li><a>fold1</a></li>
--   <li>Functions that introduce storage (see above)</li>
--   <li>"Folding" functions: <a>sum</a>, <a>maximum</a>, etc.</li>
--   </ul>
--   
--   These functions introduce overhead that is linear in the length of the
--   vector.
module Feldspar.Vector


-- | A <tt>Vector</tt> interface to packed sequences of bits
module Feldspar.BitVector

-- | A <a>Unit</a> is the internal representation of a <a>BitVector</a>
class (Type w, Numeric w, Bits w, Integral w) => Unit w
width :: Unit w => Proxy w -> Length
data BitVector w
BitVector :: [Segment w] -> BitVector w
segments :: BitVector w -> [Segment w]
data Segment w
Segment :: Data Length -> (Data Index -> Data w) -> Segment w
numUnits :: Segment w -> Data Length
elements :: Segment w -> Data Index -> Data w
length :: Unit w => BitVector w -> Data Length
numOfUnits :: Unit w => BitVector w -> Data Length
freezeBitVector :: Unit w => BitVector w -> Data [w]
unfreezeBitVector :: Unit w => Data [w] -> BitVector w

-- | Transforms a bool vector to a bitvector. Length of the vector has to
--   be divisible by the wordlength, otherwise booleans at the end will be
--   dropped.
fromVector :: (Unit w, Size w ~ Range w) => Vector (Data Bool) -> BitVector w
toVector :: (Unit w, Size w ~ Range w) => BitVector w -> Vector (Data Bool)
fromBits :: Unit w => [Bool] -> BitVector w
fromUnits :: Unit w => [w] -> BitVector w
replUnit :: Unit w => Data Length -> w -> BitVector w
indexed :: (Unit w, Size w ~ Range w) => Data Length -> (Data Index -> Data Bool) -> BitVector w
map :: (Unit w, Size w ~ Range w) => (Data Bool -> Data Bool) -> BitVector w -> BitVector w
takeUnits :: Unit w => Data Length -> BitVector w -> BitVector w
dropUnits :: Unit w => Data Length -> BitVector w -> BitVector w
(++) :: Unit w => BitVector w -> BitVector w -> BitVector w
drop :: (Unit w, Size w ~ Range w) => Data Length -> Data w -> BitVector w -> BitVector w
fold :: (Syntax a, Unit w, Size w ~ Range w) => (a -> Data Bool -> a) -> a -> BitVector w -> a
zipWith :: (Unit w, Size w ~ Range w) => (Data Bool -> Data Bool -> Data Bool) -> BitVector w -> BitVector w -> BitVector w
head :: (Unit w, Size w ~ Range w) => BitVector w -> Data Bool
tail :: (Unit w, Size w ~ Range w) => Data Bool -> BitVector w -> BitVector w
boolFun1 :: (Syntax t, Unit w, Size w ~ Range w) => (Data Bool -> Data Bool) -> ((Data w -> Data w) -> t) -> t
boolFun2 :: (Syntax t, Unit w, Size w ~ Range w) => (Data Bool -> Data Bool -> Data Bool) -> ((Data w -> Data w -> Data w) -> t) -> t
tBV :: Patch w w -> Patch (BitVector w) (BitVector w)
instance (Unit w, Size w ~ Range w) => Indexed (BitVector w)
instance Unit a => Syntactic (BitVector a)
instance Unit Word32
instance Unit Word16
instance Unit Word8

module Feldspar.FixedPoint

-- | Abstract real number type with exponent and mantissa
data Fix a
Fix :: Data IntN -> Data a -> Fix a
exponent :: Fix a -> Data IntN
mantissa :: Fix a -> Data a

-- | Operations to get and set exponent
class Splittable t => Fixable t
fix :: Fixable t => Data IntN -> t -> t
getExp :: Fixable t => t -> Data IntN

-- | Converts an abstract real number to a pair of exponent and mantissa
freezeFix :: Type a => Fix a -> (Data IntN, Data a)

-- | Converts an abstract real number to fixed point integer with given
--   exponent
freezeFix' :: Bits a => IntN -> Fix a -> Data a

-- | Converts a pair of exponent and mantissa to an abstract real number
unfreezeFix :: Type a => (Data IntN, Data a) -> Fix a

-- | Converts a fixed point integer with given exponent to an abstract real
--   number
unfreezeFix' :: IntN -> Data a -> Fix a

-- | A version of branching for fixed point algorithms
(?!) :: (Syntax a, Splittable a) => Data Bool -> (a, a) -> a

-- | A version of vector fold for fixed point algorithms
fixFold :: Splittable a => (a -> b -> a) -> a -> Vector b -> a
instance Type a => Eq (Fix a)
instance Type a => Show (Fix a)
instance Bits a => Splittable (Fix a)
instance Type a => Splittable (Data a)
instance Fixable (Data Float)
instance Bits a => Fixable (Fix a)
instance Type a => Syntactic (Fix a)
instance (Integral a, Bits a, Floating a) => Fractional (Fix a)
instance (Integral a, Bits a) => Num (Fix a)

module Feldspar.Future
withFuture :: (Syntax a, Syntax b) => a -> (Future a -> b) -> b
withFutures :: (Syntax a, Syntax b) => Vector a -> (Vector (Future a) -> b) -> b


-- | Operations on matrices (doubly-nested parallel vectors). All
--   operations in this module assume rectangular matrices.
module Feldspar.Matrix
type Matrix a = Vector2 a
tMat :: Patch a a -> Patch (Matrix a) (Matrix a)

-- | Converts a matrix to a core array.
freezeMatrix :: Type a => Matrix a -> Data [[a]]

-- | Converts a core array to a matrix.
thawMatrix :: Type a => Data [[a]] -> Matrix a

-- | Converts a core array to a matrix. The first length argument is the
--   number of rows (outer vector), and the second argument is the number
--   of columns (inner vector).
thawMatrix' :: Type a => Length -> Length -> Data [[a]] -> Matrix a

-- | Constructs a matrix. The elements are stored in a core array.
matrix :: Type a => [[a]] -> Matrix a

-- | Constructing a matrix from an index function.
--   
--   <tt>indexedMat m n ixf</tt>:
--   
--   <ul>
--   <li><tt>m</tt> is the number of rows.</li>
--   <li><tt>n</tt> is the number of columns.</li>
--   <li><tt>ifx</tt> is a function mapping indexes to elements (first
--   argument is row index; second argument is column index).</li>
--   </ul>
indexedMat :: Data Length -> Data Length -> (Data Index -> Data Index -> a) -> Vector (Vector a)

-- | Transpose of a matrix. Assumes that the number of rows is &gt; 0.
transpose :: Syntax a => Vector (Vector a) -> Vector (Vector a)

-- | Concatenates the rows of a matrix.
flatten :: Type a => Matrix a -> Vector (Data a)

-- | The diagonal vector of a square matrix. It happens to work if the
--   number of rows is less than the number of columns, but not the other
--   way around (this would require some overhead).
diagonal :: Type a => Matrix a -> Vector (Data a)
distributeL :: (a -> b -> c) -> a -> Vector b -> Vector c
distributeR :: (a -> b -> c) -> Vector a -> b -> Vector c
class Mul a b where type family Prod a b
(***) :: Mul a b => a -> b -> Prod a b

-- | Matrix multiplication
mulMat :: Numeric a => Matrix a -> Matrix a -> Matrix a
class Syntax a => ElemWise a where type family Scalar a
elemWise :: ElemWise a => (Scalar a -> Scalar a -> Scalar a) -> a -> a -> a
(.+) :: (ElemWise a, Num (Scalar a)) => a -> a -> a
(.-) :: (ElemWise a, Num (Scalar a)) => a -> a -> a
(.*) :: (ElemWise a, Num (Scalar a)) => a -> a -> a
instance (ElemWise a, Syntax (Vector a)) => ElemWise (Vector a)
instance Type a => ElemWise (Data a)
instance Numeric a => Mul (Matrix a) (Matrix a)
instance Numeric a => Mul (Matrix a) (Vector1 a)
instance Numeric a => Mul (Vector1 a) (Matrix a)
instance Numeric a => Mul (Vector1 a) (Vector1 a)
instance Numeric a => Mul (Matrix a) (Data a)
instance Numeric a => Mul (Data a) (Matrix a)
instance Numeric a => Mul (Vector1 a) (Data a)
instance Numeric a => Mul (Data a) (Vector1 a)
instance Numeric a => Mul (Data a) (Data a)

module Feldspar.Memoize

-- | Accelerate the function <tt>f</tt> using a lookup table. The table
--   will span all possible input values.
tabulate :: (Bits i, Integral i, Syntax a) => (Data i -> a) -> Data i -> a

-- | Accelerate the function <tt>f</tt> by creating a lookup table of the
--   results for the <tt>len</tt> first argument values
--   
--   Note. To really get a table the function must be closed after the
--   application to <tt>i</tt>
tabulateLen :: (Integral i, Syntax a) => Data Length -> (Data i -> a) -> Data i -> a

module Feldspar.Option
data Option a
Option :: Data Bool -> a -> Option a
isSome :: Option a -> Data Bool
fromSome :: Option a -> a

-- | One-layer desugaring of <a>Option</a>
desugarOption :: Type a => Option (Data a) -> Data (Bool, a)

-- | One-layer sugaring of <a>Option</a>
sugarOption :: Type a => Data (Bool, a) -> Option (Data a)
some :: a -> Option a
none :: Syntax a => Option a
option :: Syntax b => b -> (a -> b) -> Option a -> b
oplus :: Syntax a => Option a -> Option a -> Option a

-- | Conditional choice operator. Can be used together with <a>&lt;?</a> to
--   write guarded choices as follows:
--   
--   <pre>
--   prog :: Data Index -&gt; Data Index
--   prog a
--       =  a+1 &lt;? a==0
--       ?&gt; a+2 &lt;? a==1
--       ?&gt; a+3 &lt;? a==2
--       ?&gt; a+4 &lt;? a==3
--       ?&gt; a+5
--   </pre>
(?>) :: Data Bool -> a -> Option a
(<?) :: Syntax a => a -> Option a -> a
instance Monad Option
instance Applicative Option
instance Functor Option
instance Syntax a => Syntactic (Option a)

module Feldspar.Repa

-- | <ul>
--   <li>Shapes</li>
--   </ul>
data Z
Z :: Z
data (:.) tail head
(:.) :: tail -> head -> :. tail head
type DIM0 = Z
type DIM1 = DIM0 :. Data Length
type DIM2 = DIM1 :. Data Length
type DIM3 = DIM2 :. Data Length
class Shape sh
dim :: Shape sh => sh -> Int
zeroDim :: Shape sh => sh
unitDim :: Shape sh => sh
size :: Shape sh => sh -> Data Length
toIndex :: Shape sh => sh -> sh -> Data Index
fromIndex :: Shape sh => sh -> Data Index -> sh
intersectDim :: Shape sh => sh -> sh -> sh
inRange :: Shape sh => sh -> sh -> sh -> Data Bool
toList :: Shape sh => sh -> [Data Length]
toShape :: Shape sh => Int -> Data [Length] -> sh

-- | <ul>
--   <li>Slices</li>
--   </ul>
data All
All :: All
data Any sh
Any :: Any sh
class Slice ss
sliceOfFull :: Slice ss => ss -> FullShape ss -> SliceShape ss
fullOfSlice :: Slice ss => ss -> SliceShape ss -> FullShape ss

-- | <ul>
--   <li>Vectors</li>
--   </ul>
data Vector sh a
Vector :: sh -> (sh -> a) -> Vector sh a
type DVector sh a = Vector sh (Data a)

-- | <ul>
--   <li>Fuctions</li>
--   </ul>
--   
--   Store a vector in an array.
fromVector :: (Shape sh, Type a) => DVector sh a -> Data [a]

-- | Restore a vector from an array
toVector :: (Shape sh, Type a) => sh -> Data [a] -> DVector sh a
freezeVector :: (Shape sh, Type a) => DVector sh a -> (Data [Length], Data [a])
fromList :: Type a => [Data a] -> Data [a]
thawVector :: (Shape sh, Type a) => (Data [Length], Data [a]) -> DVector sh a

-- | Store a vector in memory. Use this function instead of <a>force</a> if
--   possible as it is both much more safe and faster.
memorize :: (Shape sh, Type a) => DVector sh a -> DVector sh a

-- | The shape and size of the vector
extent :: Vector sh a -> sh

-- | Change the extent of the vector to the supplied value. If the supplied
--   extent will contain more elements than the old extent, the new
--   elements will have undefined value.
newExtent :: sh -> Vector sh a -> Vector sh a

-- | Change shape and transform elements of a vector. This function is the
--   most general way of manipulating a vector.
traverse :: (Shape sh, Shape sh') => Vector sh a -> (sh -> sh') -> ((sh -> a) -> sh' -> a') -> Vector sh' a'

-- | Duplicates part of a vector along a new dimension.
replicate :: (Slice sl, Shape (FullShape sl), Shape (SliceShape sl)) => sl -> Vector (SliceShape sl) a -> Vector (FullShape sl) a

-- | Extracts a slice from a vector.
slice :: (Slice sl, Shape (FullShape sl), Shape (SliceShape sl)) => Vector (FullShape sl) a -> sl -> Vector (SliceShape sl) a

-- | Change the shape of a vector. This function is potentially unsafe, the
--   new shape need to have fewer or equal number of elements compared to
--   the old shape.
reshape :: (Shape sh, Shape sh') => sh -> Vector sh' a -> Vector sh a

-- | A scalar (zero dimensional) vector
unit :: a -> Vector Z a

-- | Index into a vector
(!:) :: Shape sh => Vector sh a -> sh -> a

-- | Extract the diagonal of a two dimensional vector
diagonal :: Vector DIM2 a -> Vector DIM1 a

-- | Change the shape of a vector.
backpermute :: (Shape sh, Shape sh') => sh' -> (sh' -> sh) -> Vector sh a -> Vector sh' a

-- | Map a function on all the elements of a vector
map :: (a -> b) -> Vector sh a -> Vector sh b

-- | Combines the elements of two vectors. The size of the resulting vector
--   will be the intersection of the two argument vectors.
zip :: Shape sh => Vector sh a -> Vector sh b -> Vector sh (a, b)

-- | Combines the elements of two vectors pointwise using a function. The
--   size of the resulting vector will be the intersection of the two
--   argument vectors.
zipWith :: Shape sh => (a -> b -> c) -> Vector sh a -> Vector sh b -> Vector sh c

-- | Reduce a vector along its last dimension
fold :: (Shape sh, Syntax a) => (a -> a -> a) -> a -> Vector (sh :. Data Length) a -> Vector sh a

-- | A generalization of <a>fold</a> which allows for different initial
--   values when starting to fold.
fold' :: (Shape sh, Syntax a) => (a -> a -> a) -> Vector sh a -> Vector (sh :. Data Length) a -> Vector sh a

-- | Summing a vector along its last dimension
sum :: (Shape sh, Type a, Numeric a) => DVector (sh :. Data Length) a -> DVector sh a

-- | Enumerating a vector
(...) :: Data Index -> Data Index -> DVector DIM1 Index
stencil :: DVector DIM2 Float -> DVector DIM2 Float
laplace :: Data Length -> DVector DIM2 Float -> DVector DIM2 Float
transpose2D :: Vector DIM2 e -> Vector DIM2 e

-- | Matrix multiplication
mmMult :: (Type e, Numeric e) => DVector DIM2 e -> DVector DIM2 e -> DVector DIM2 e
mapDIM1 :: (Data Index -> Data Index) -> DIM1 -> DIM1
indexed :: Data Length -> (Data Index -> a) -> Vector DIM1 a
length :: Vector DIM1 a -> Data Length

-- | Change the length of the vector to the supplied value. If the supplied
--   length is greater than the old length, the new elements will have
--   undefined value. The resulting vector has only one segment.
newLen :: Syntax a => Data Length -> Vector DIM1 a -> Vector DIM1 a
(++) :: Syntax a => Vector DIM1 a -> Vector DIM1 a -> Vector DIM1 a
take :: Data Length -> Vector DIM1 a -> Vector DIM1 a
drop :: Data Length -> Vector DIM1 a -> Vector DIM1 a
splitAt :: Data Index -> Vector DIM1 a -> (Vector DIM1 a, Vector DIM1 a)
head :: Syntax a => Vector DIM1 a -> a
last :: Syntax a => Vector DIM1 a -> a
tail :: Vector DIM1 a -> Vector DIM1 a
init :: Vector DIM1 a -> Vector DIM1 a
tails :: Vector DIM1 a -> Vector DIM1 (Vector DIM1 a)
inits :: Vector DIM1 a -> Vector DIM1 (Vector DIM1 a)
inits1 :: Vector DIM1 a -> Vector DIM1 (Vector DIM1 a)

-- | Permute a vector
permute :: (Data Length -> Data Index -> Data Index) -> (Vector DIM1 a -> Vector DIM1 a)
reverse :: Syntax a => Vector DIM1 a -> Vector DIM1 a
rotateVecL :: Syntax a => Data Index -> Vector DIM1 a -> Vector DIM1 a
rotateVecR :: Syntax a => Data Index -> Vector DIM1 a -> Vector DIM1 a
replicate1 :: Data Length -> a -> Vector DIM1 a

-- | <tt>enumFromTo m n</tt>: Enumerate the indexes from <tt>m</tt> to
--   <tt>n</tt>
--   
--   In order to enumerate a different type, use <a>i2n</a>, e.g:
--   
--   <pre>
--   map i2n (10...20) :: Vector1 Word8
--   </pre>
enumFromTo :: Data Index -> Data Index -> Vector DIM1 (Data Index)

-- | <tt>enumFrom m</tt>: Enumerate the indexes from <tt>m</tt> to
--   <a>maxBound</a>
enumFrom :: Data Index -> Vector DIM1 (Data Index)
unzip :: Vector DIM1 (a, b) -> (Vector DIM1 a, Vector DIM1 b)

-- | Corresponds to the standard <a>foldl</a>.
foldl :: Syntax a => (a -> b -> a) -> a -> Vector DIM1 b -> a

-- | Corresponds to the standard <tt>foldl1</tt>.
fold1 :: Syntax a => (a -> a -> a) -> Vector DIM1 a -> a
sum1 :: (Syntax a, Num a) => Vector DIM1 a -> a
maximum :: Ord a => Vector DIM1 (Data a) -> Data a
minimum :: Ord a => Vector DIM1 (Data a) -> Data a

-- | Scalar product of two vectors
scalarProd :: (Syntax a, Num a) => Vector DIM1 a -> Vector DIM1 a -> a
tVec :: Patch a a -> Patch (Vector DIM1 a) (Vector DIM1 a)
tVec1 :: Patch a a -> Patch (Vector DIM1 (Data a)) (Vector DIM1 (Data a))
tVec2 :: Patch a a -> Patch (Vector DIM2 (Data a)) (Vector DIM2 (Data a))
instance CollMap (Vector sh a) (Vector sh a)
instance (Syntax a, Shape sh) => Sized (Vector sh a)
instance Syntax a => Indexed (Vector sh a)
instance (Shape sh, Syntax a) => Syntactic (Vector sh a)
instance Slice sl => Slice (sl :. All)
instance Slice sl => Slice (sl :. Data Length)
instance Slice (Any sh)
instance Slice Z
instance Shape sh => Shape (sh :. Data Length)
instance Shape Z

module Feldspar.Stream

-- | Infinite streams.
data Stream a

-- | Take the first element of a stream
head :: Syntax a => Stream a -> a

-- | Drop the first element of a stream
tail :: Syntax a => Stream a -> Stream a

-- | 'map f str' transforms every element of the stream <tt>str</tt> using
--   the function <tt>f</tt>
map :: (Syntax a, Syntax b) => (a -> b) -> Stream a -> Stream b

-- | 'mapNth f n k str' transforms every <tt>n</tt>th element with offset
--   <tt>k</tt> of the stream <tt>str</tt> using the function <tt>f</tt>
mapNth :: Syntax a => (a -> a) -> Data Index -> Data Index -> Stream a -> Stream a

-- | 'maps fs str' uses one of the functions from <tt>fs</tt> successively
--   to modify the elements of <tt>str</tt>
maps :: Syntax a => [a -> a] -> Stream a -> Stream a

-- | 'intersperse a str' inserts an <tt>a</tt> between each element of the
--   stream <tt>str</tt>.
intersperse :: Syntax a => a -> Stream a -> Stream a

-- | Create a new stream by alternating between the elements from the two
--   input streams
interleave :: Syntax a => Stream a -> Stream a -> Stream a

-- | 'downsample n str' takes every <tt>n</tt>th element of the input
--   stream
downsample :: Syntax a => Data Index -> Stream a -> Stream a

-- | 'duplicate n str' stretches the stream by duplicating the elements
--   <tt>n</tt> times
duplicate :: Syntax a => Data Index -> Stream a -> Stream a

-- | 'scan f a str' produces a stream by successively applying <tt>f</tt>
--   to each element of the input stream <tt>str</tt> and the previous
--   element of the output stream.
scan :: Syntax a => (a -> b -> a) -> a -> Stream b -> Stream a

-- | A scan but without an initial element.
scan1 :: Syntax a => (a -> a -> a) -> Stream a -> Stream a

-- | Maps a function over a stream using an accumulator.
mapAccum :: (Syntax acc, Syntax b) => (acc -> a -> (acc, b)) -> acc -> Stream a -> Stream b

-- | Iteratively applies a function to a starting element. All the
--   successive results are used to create a stream.
--   
--   <pre>
--   iterate f a == [a, f a, f (f a), f (f (f a)) ...]
--   </pre>
iterate :: Syntax a => (a -> a) -> a -> Stream a

-- | Repeat an element indefinitely.
--   
--   <pre>
--   repeat a = [a, a, a, ...]
--   </pre>
repeat :: Syntax a => a -> Stream a

-- | <tt>unfold f acc</tt> creates a new stream by successively applying
--   <tt>f</tt> to to the accumulator <tt>acc</tt>.
unfold :: (Syntax a, Syntax c) => (c -> (a, c)) -> c -> Stream a

-- | Drop a number of elements from the front of a stream
drop :: Syntax a => Data Length -> Stream a -> Stream a

-- | Pairs together two streams into one.
zip :: Stream a -> Stream b -> Stream (a, b)

-- | Pairs together two streams using a function to combine the
--   corresponding elements.
zipWith :: (a -> b -> c) -> Stream a -> Stream b -> Stream c

-- | Given a stream of pairs, split it into two stream.
unzip :: (Syntax a, Syntax b) => Stream (a, b) -> (Stream a, Stream b)

-- | 'take n str' allocates <tt>n</tt> elements from the stream
--   <tt>str</tt> into a core array.
take :: Syntax a => Data Length -> Stream a -> Data [Internal a]

-- | 'splitAt n str' allocates <tt>n</tt> elements from the stream
--   <tt>str</tt> into a core array and returns the rest of the stream
--   continuing from element 'n+1'.
splitAt :: Syntax a => Data Length -> Stream a -> (Data [Internal a], Stream a)

-- | Loops through a vector indefinitely to produce a stream.
cycle :: Syntax a => Vector a -> Stream a

-- | A convenience function for translating an algorithm on streams to an
--   algorithm on vectors. The result vector will have the same length as
--   the input vector. It is important that the stream function doesn't
--   drop any elements of the input stream.
--   
--   This function allocates memory for the output vector.
streamAsVector :: (Syntax a, Syntax b) => (Stream a -> Stream b) -> (Vector a -> Vector b)

-- | Similar to <a>streamAsVector</a> except the size of the output array
--   is computed by the second argument which is given the size of the
--   input vector as a result.
streamAsVectorSize :: (Syntax a, Syntax b) => (Stream a -> Stream b) -> (Data Length -> Data Length) -> (Vector a -> Vector b)

-- | A combinator for descibing recurrence equations, or feedback loops.
--   The recurrence equation may refer to previous outputs of the stream,
--   but only as many as the length of the input stream It uses memory
--   proportional to the input vector.
--   
--   For exaple one can define the fibonacci sequence as follows:
--   
--   <pre>
--   fib = recurrenceO (vector [0,1]) (\fib -&gt; fib!0 + fib!1)
--   </pre>
--   
--   The expressions <tt>fib!0</tt> and <tt>fib!1</tt> refer to previous
--   elements in the stream defined one step back and two steps back
--   respectively.
recurrenceO :: Type a => Vector1 a -> (Vector1 a -> Data a) -> Stream (Data a)

-- | A recurrence combinator with input. The function <a>recurrenceI</a> is
--   similar to <a>recurrenceO</a>. The difference is that that it has an
--   input stream, and that the recurrence equation may only refer to
--   previous inputs, it may not refer to previous outputs.
--   
--   The sliding average of a stream can easily be implemented using
--   <a>recurrenceI</a>.
--   
--   <pre>
--   slidingAvg :: Data WordN -&gt; Stream (Data WordN) -&gt; Stream (Data WordN)
--   slidingAvg n str = recurrenceI (replicate n 0) str
--                      (\input -&gt; sum input `quot` n)
--   </pre>
recurrenceI :: (Type a, Type b) => Vector1 a -> Stream (Data a) -> (Vector1 a -> Data b) -> Stream (Data b)

-- | <a>recurrenceIO</a> is a combination of <a>recurrenceO</a> and
--   <a>recurrenceI</a>. It has an input stream and the recurrence equation
--   may refer both to previous inputs and outputs.
--   
--   <a>recurrenceIO</a> is used when defining the <a>iir</a> filter.
recurrenceIO :: (Type a, Type b) => Vector1 a -> Stream (Data a) -> Vector1 b -> (Vector1 a -> Vector1 b -> Data b) -> Stream (Data b)

-- | Similar to <a>recurrenceIO</a> but takes two input streams.
recurrenceIIO :: (Type a, Type b, Type c) => Vector1 a -> Stream (Data a) -> Vector1 b -> Stream (Data b) -> Vector1 c -> (Vector1 a -> Vector1 b -> Vector1 c -> Data c) -> Stream (Data c)
slidingAvg :: Data WordN -> Stream (Data WordN) -> Stream (Data WordN)

-- | An iir filter on streams
iir :: Data Float -> Vector1 Float -> Vector1 Float -> Stream (Data Float) -> Stream (Data Float)

-- | A fir filter on streams
fir :: Vector1 Float -> Stream (Data Float) -> Stream (Data Float)
instance Syntax a => Indexed (Stream a)

module Feldspar.Vector.Push
data PushVector a
Push :: ((Data Index -> a -> M ()) -> M ()) -> Data Length -> PushVector a
type PushVector1 a = PushVector (Data a)

-- | Store push vectors in memory.
freezePush :: Syntax a => PushVector a -> Data [Internal a]

-- | Store a push vector to memory and return it as an ordinary vector.
freezeToVector :: Syntax a => PushVector a -> Vector a

-- | Create a push vector from an array stored in memory.
thawPush :: Syntax a => Data [Internal a] -> PushVector a

-- | Any kind of vector, push or pull, can cheaply be converted to a push
--   vector
class Pushy arr
toPush :: (Pushy arr, Syntax a) => arr a -> PushVector a

-- | Concatenating two arrays.
(++) :: (Pushy arr1, Pushy arr2, Syntax a) => arr1 a -> arr2 a -> PushVector a

-- | Given an array of pairs, flatten the array so that the elements of the
--   pairs end up next to each other in the resulting vector.
unpair :: (Pushy arr, Syntax a) => arr (a, a) -> PushVector a
unpairWith :: (Pushy arr, Syntax a) => ((Data Index -> a -> M ()) -> Data Index -> (a, a) -> M ()) -> arr (a, a) -> PushVector a
everyOther :: (Data Index -> a -> M b) -> Data Index -> (a, a) -> M b

-- | Interleaves the elements of two vectors.
zipUnpair :: Syntax a => Vector a -> Vector a -> PushVector a

-- | An overloaded function for reordering elements of a vector.
class Ixmap arr
ixmap :: (Ixmap arr, Syntax a) => (Data Index -> Data Index) -> arr a -> arr a

-- | Reverse a vector. Works for both push and pull vectors.
reverse :: (Ixmap arr, Len arr, Syntax a) => arr a -> arr a

-- | Split a pull vector in half.
--   
--   If the input vector has an odd length the second result vector will be
--   one element longer than the first.
halve :: Syntax a => Vector a -> (Vector a, Vector a)

-- | Split a vector in half and interleave the two two halves.
riffle :: Syntax a => Vector a -> PushVector a

-- | A class for overloading <a>length</a> for both pull and push vectors
class Len arr
length :: Len arr => arr a -> Data Length

-- | This function can distribute array computations on chunks of a large
--   pull vector. A call `chunk l f g v` will split the vector <tt>v</tt>
--   into chunks of size <tt>l</tt> and apply <tt>f</tt> to these chunks.
--   In case the length of <tt>v</tt> is not a multiple of <tt>l</tt> then
--   the rest of <tt>v</tt> will be processed by <tt>g</tt>.
chunk :: (Pushy arr1, Pushy arr2, Syntax b) => Data Length -> (Vector a -> arr1 b) -> (Vector a -> arr2 b) -> Vector a -> PushVector b

-- | <a>scanl</a> is similar to <tt>fold</tt>, but returns a
--   <a>PushVector</a> of successive reduced values from the left.
scanl :: (Syntax a, Syntax b) => (a -> b -> a) -> a -> Vector b -> PushVector a

-- | The empty push vector.
empty :: PushVector a

-- | Flattens a pull vector containing push vectors into an unnested push
--   vector
--   
--   Note that there are no restrictions on the lengths of the push vectors
--   inside the pull vector.
flatten :: Syntax a => Vector (PushVector a) -> PushVector a
instance Len PushVector
instance Len Vector
instance Ixmap PushVector
instance Ixmap Vector
instance Functor PushVector
instance Pushy Vector
instance Pushy PushVector
instance Syntax a => Syntactic (PushVector a)

module Feldspar.Algorithm.CRC
tstBit :: Bits a => Data a -> Data Index -> Data Bool
makeCrcTable :: Bits a => Data a -> Vector1 a

-- | Calculate the normal form CRC using a table
crcNormal :: Bits a => Vector1 a -> Data a -> Vector1 Word8 -> Data a

-- | Calculate the reflected form CRC using a table needs reflected tables
crcReflected :: Bits a => Vector1 a -> Data a -> Vector1 Word8 -> Data a

-- | Calculate normal form CRC from a polynominal
crcNaive :: Bits a => Data a -> Data a -> Vector1 Word8 -> Data a
data CRC a
CRC :: String -> Index -> a -> a -> Bool -> Bool -> a -> CRC a
name :: CRC a -> String
width :: CRC a -> Index
poly :: CRC a -> a
init :: CRC a -> a
reflectIn :: CRC a -> Bool
reflectOut :: CRC a -> Bool
xorOut :: CRC a -> a
crc16 :: CRC (Data Word16)

-- | Reflect the bottom b bits of value t
reflect :: Bits a => Data a -> Data Length -> Data a

module Feldspar.Algorithm.FFT

-- | Radix-2 Decimation-In-Frequeny Fast Fourier Transformation of the
--   given complex vector The given vector must be power-of-two sized, (for
--   example 2, 4, 8, 16, 32, etc.)
fft :: Vector1 (Complex Float) -> Vector1 (Complex Float)

-- | Radix-2 Decimation-In-Frequeny Inverse Fast Fourier Transformation of
--   the given complex vector The given vector must be power-of-two sized,
--   (for example 2, 4, 8, 16, 32, etc.)
ifft :: Vector1 (Complex Float) -> Vector1 (Complex Float)
