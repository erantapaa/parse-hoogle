-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Binary fixed-point arithmetic
--   
--   This package defines a type for binary fixed-precision arithmetic. The
--   main differences between this and Data.Fixed are that this is binary
--   fixed-point and it's polymorphic in the underlying representation.
--   When is this more appropriate than floating point? You'll mainly want
--   to use this when you need to be able to represent fractional values
--   within a bounded range. Fixed-point numbers have the advantage of
--   uniformity in these cases. On the downside, you lose precision
--   relative to floating point numbers as you approach zero, and you lose
--   the ability to express very large (but imprecise) values that floating
--   point can express. On some architectures, fixed-point arithmetic might
--   be faster than floating-point arithmetic, but this is probably not the
--   case on x86.
@package fixed-point
@version 0.5.0.1


-- | This module defines a type for binary fixed-point arithmetic. The main
--   advantage this provides over decimal fixed-point arithmetic is that
--   the point is maintained using fast bit shifts instead of slow
--   <a>div</a> operations. This type is also polymorphic on the underlying
--   representation, so you can use whatever size and signedness you want.
module Data.Fixed.Binary

-- | generalisation of <a>div</a> to any instance of Real
div' :: (Real a, Integral b) => a -> a -> b

-- | generalisation of <a>mod</a> to any instance of Real
mod' :: Real a => a -> a -> a

-- | generalisation of <a>divMod</a> to any instance of Real
divMod' :: (Real a, Integral b) => a -> a -> (b, a)

-- | The first type parameter represents the number of bits to devote to
--   the fractional part of the number. The second type parameter is the
--   underlying representation. For example, <tt>Fixed E8 Int16</tt> uses
--   eight bits for the integer component (of which one bit is used for the
--   sign) and eight bits for the fractional component.
data Fixed r a

-- | Instances of <a>SuperTypeable</a> can be cast up to and down from a
--   supertype. If the type is bounded, the supertype must be able to hold
--   at least twice as much information to be a valid instance.
class SuperTypeable a where { type family Super a; }
superCast :: SuperTypeable a => a -> Super a
subCast :: SuperTypeable a => Super a -> a

-- | Instances of this class are useful as the first parameter of
--   <a>Fixed</a>.
class HasResolution r
resolution :: (HasResolution r, Num a) => Fixed r a -> Int
data E0
type E1 = S E0
type E2 = E1 :+ E1
type E4 = E2 :+ E2
type E8 = E4 :+ E4
type E10 = S (S E8)
type E16 = E8 :+ E8
type E20 = E10 :+ E10
type E30 = E20 :+ E10
type E32 = E16 :+ E16
type E64 = E32 :+ E32

-- | Increment a resolution
data S n

-- | Decrement a resolution

-- | Fast conversion between fixed-point numbers with the same fractional
--   size.
fixedRadix :: (Integral a, Num b) => Fixed r a -> Fixed r b

-- | Fast conversion between fixed-point numbers with the same
--   representation size.
fixedSize :: (HasResolution r, HasResolution s, Bits a) => Fixed r a -> Fixed s a

-- | Fast conversion from floating-point to fixed-point.
fromRealFloat :: (RealFloat a, HasResolution r, Num b) => a -> Fixed r b

-- | Add resolutions

-- | Multiplication without throwing away fractional information.
(*.) :: (Num (Super a), SuperTypeable a) => Fixed r a -> Fixed s a -> Fixed (r :+ s) a

-- | Perform a multiplication without adding any extra bits for the
--   intermediate steps. This may be faster (especially when you are
--   already working with native-sized integer data), but it's only safe to
--   use if you are sure that the multiplication won't overflow. Normal
--   multiplication is equivalent to <tt>x y -&gt; subCast (superCast x *!
--   superCast y)</tt>.
(*!) :: (HasResolution r, Bits a, Num a) => Fixed r a -> Fixed r a -> Fixed r a

-- | Subtract resolutions

-- | Division while removing unnecessary bits in the result's fractional
--   part.
(/.) :: Integral a => Fixed r a -> Fixed s a -> Fixed (r :- s) a

-- | Perform a division without adding any extra bits for the intermediate
--   steps. This may be faster if supercasting brings it up to a non-native
--   size, but you need to be sure that the shifting before the division
--   won't cause an overflow.
(/!) :: (HasResolution r, Bits a, Integral a) => Fixed r a -> Fixed r a -> Fixed r a
instance Typeable2 Fixed
instance Bounded a => Bounded (Fixed r a)
instance Enum a => Enum (Fixed r a)
instance Eq a => Eq (Fixed r a)
instance Ord a => Ord (Fixed r a)
instance SuperTypeable Integer
instance SuperTypeable Int
instance SuperTypeable Int64
instance SuperTypeable Int32
instance SuperTypeable Int16
instance SuperTypeable Int8
instance SuperTypeable Word
instance SuperTypeable Word64
instance SuperTypeable Word32
instance SuperTypeable Word16
instance SuperTypeable Word8
instance (SuperTypeable a, Num a, Num (Super a), Integral a, Integral (Super a)) => SuperTypeable (Fixed r a)
instance HasResolution E0
instance HasResolution n => HasResolution (S n)
instance (HasResolution r, Bits a, Bits (Super a), Integral a, Integral (Super a), SuperTypeable a) => RealFrac (Fixed r a)
instance (HasResolution r, Bits a, Bits (Super a), Integral a, Integral (Super a), SuperTypeable a) => Fractional (Fixed r a)
instance (HasResolution r, Bits a, Bits (Super a), Integral a, Integral (Super a), SuperTypeable a) => Real (Fixed r a)
instance (HasResolution r, Bits a, Bits (Super a), Integral a, Num (Super a), Integral (Super a), SuperTypeable a) => Num (Fixed r a)
instance (HasResolution r, Bits a, Bits (Super a), Integral a, Integral (Super a), SuperTypeable a) => Show (Fixed r a)
instance (HasResolution r, Bits a, Bits (Super a), Integral a, Integral (Super a), SuperTypeable a) => Read (Fixed r a)
