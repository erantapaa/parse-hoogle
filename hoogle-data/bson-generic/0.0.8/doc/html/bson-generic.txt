-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic functionality for BSON
--   
--   This package offers easy conversion from and to BSON data type for
--   most of user defined data types. The interface may change at will.
@package bson-generic
@version 0.0.8


-- | Examples
--   
--   <pre>
--   data Test0 = A | B | C deriving (Generic, Typeable, Show, Eq)
--   instance ToBSON Test0
--   instance FromBSON Test0
--   
--   (fromBSON $ toBSON A) :: Maybe Test0
--   </pre>
--   
--   <pre>
--   data Test1 = Test1 String String deriving (Generic, Typeable, Show, Eq)
--   instance ToBSON Test1
--   instance FromBSON Test1
--   
--   (fromBSON $ toBSON $ Test1 "aa" "bb") :: Maybe Test1
--   </pre>
--   
--   <pre>
--   data Test2 = Test2 { test20 :: String, test21 :: String } deriving (Generic, Typeable, Show, Eq)
--   instance ToBSON Test2
--   instance FromBSON Test2
--   
--   (fromBSON $ toBSON $ Test2 "aa" "bb") :: Maybe Test2
--   </pre>
--   
--   <pre>
--   data Test3 = Test3 { test30 :: Test2, test31 :: String } deriving (Generic, Typeable, Show, Eq)
--   instance ToBSON Test3
--   instance FromBSON Test3
--   
--   (fromBSON $ toBSON $ Test3 (Test2 "aa" "bb") "cc") :: Maybe Test3
--   </pre>
--   
--   <pre>
--   data Test4 = Test4 { test4Key :: ObjectKey, test4 :: String } deriving (Generic, Typeable, Show, Eq)
--   instance ToBSON Test4
--   instance FromBSON Test4
--   
--   (fromBSON $ toBSON $ Test4 (ObjectKey . Just $ unsafePerformIO genObjectId) "something") :: Maybe Test4
--   (fromBSON $ toBSON $ Test4 (ObjectKey Nothing) "something") :: Maybe Test4
--   </pre>
--   
--   <pre>
--   data Comment = Comment { author :: String, comments :: [Comment] } deriving (Generic, Typeable, Show, Eq)
--   instance ToBSON Comment
--   instance FromBSON Comment
--   
--   (fromBSON $ toBSON $ Comment "Joe1" [Comment "Joe2" [], Comment "Joe3" [Comment "Joe4" [], Comment "Joe5" []]]) :: Maybe Comment
--   </pre>
--   
--   Representation
--   
--   <pre>
--   toBSON $ Test2 "aa" "bb"
--   
--   [ test20: "aa", test21: "bb" ]
--   </pre>
--   
--   <pre>
--   toBSON $ Test3 (Test2 "aa" "bb") "cc"
--   
--   [ test30: [ test20: "aa", test21: "bb"], test31: "cc" ]
--   </pre>
--   
--   <pre>
--   toBSON $ Test4 (ObjectKey . Just $ unsafePerformIO genObjectId) "something"
--   
--   [ _id: 4f226c27900faa06ab000001, test4: "something" ]
--   </pre>
--   
--   <pre>
--   toBSON $ Test4 (ObjectKey Nothing) "something"
--   
--   [ test4: "something" ]
--   </pre>
--   
--   <pre>
--   toBSON $ Comment "Joe1" [ Comment "Joe2" []
--                           , Comment "Joe3" [ Comment "Joe4" []
--                                            , Comment "Joe5" []
--                                            ]
--                           ]
--   
--   [ author: "Joe1", comments: [ [ author: "Joe2", comments: []]
--                               , [ author: "Joe3", comments: [ [ author: "Joe4", comments: []]
--                                                             , [ author: "Joe5", comments: []]
--                                                             ]]
--                               ]]
--   </pre>
module Data.Bson.Generic
class ToBSON a where toBSON a = genericToBSON (constructorCount a) (from a)
toBSON :: ToBSON a => a -> Document
class FromBSON a where fromBSON doc = maybe Nothing (Just . to) (genericFromBSON (constructorCount (undefined :: a)) doc)
fromBSON :: FromBSON a => Document -> Maybe a
newtype ObjectKey
ObjectKey :: Maybe ObjectId -> ObjectKey
unObjectKey :: ObjectKey -> Maybe ObjectId
keyLabel :: Label
constructorLabel :: Label
instance [overlap ok] Typeable ObjectKey
instance [overlap ok] Generic ObjectKey
instance [overlap ok] Show ObjectKey
instance [overlap ok] Eq ObjectKey
instance Datatype D1ObjectKey
instance Constructor C1_0ObjectKey
instance Selector S1_0_0ObjectKey
instance [overlap ok] (GConstructorCount a, GConstructorCount b) => GConstructorCount (a :+: b)
instance [overlap ok] Constructor c => GConstructorCount (C1 c a)
instance [overlap ok] GConstructorCount a => GConstructorCount (D1 d a)
instance [overlap ok] GConstructorCount V1
instance [overlap ok] Selector s => GFromBSON (S1 s (K1 i ObjectKey))
instance [overlap ok] (Val a, Selector s) => GFromBSON (S1 s (K1 i a))
instance [overlap ok] GFromBSON a => GFromBSON (M1 D c a)
instance [overlap ok] (GFromBSON a, Constructor c) => GFromBSON (C1 c a)
instance [overlap ok] (GFromBSON a, GFromBSON b) => GFromBSON (a :+: b)
instance [overlap ok] (GFromBSON a, GFromBSON b) => GFromBSON (a :*: b)
instance [overlap ok] GFromBSON U1
instance [overlap ok] ToBSON a => GToBSON (K1 i a)
instance [overlap ok] Selector s => GToBSON (S1 s (K1 i ObjectKey))
instance [overlap ok] (Val a, Selector s) => GToBSON (S1 s (K1 i a))
instance [overlap ok] (GToBSON a, Constructor c) => GToBSON (C1 c a)
instance [overlap ok] GToBSON a => GToBSON (D1 c a)
instance [overlap ok] (GToBSON a, GToBSON b) => GToBSON (a :+: b)
instance [overlap ok] (GToBSON a, GToBSON b) => GToBSON (a :*: b)
instance [overlap ok] GToBSON U1
instance [overlap ok] (FromBSON a, ToBSON a, Typeable a, Show a, Eq a) => Val a
instance [overlap ok] ToBSON ObjectKey
instance [overlap ok] FromBSON ObjectKey
