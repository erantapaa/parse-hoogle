-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Creation of type-safe, RESTful web applications.
--   
@package yesod-core
@version 1.4.12


-- | Warning! This module is considered internal and may have breaking
--   changes
module Yesod.Routes.TH.Types
data Resource typ
Resource :: String -> [Piece typ] -> Dispatch typ -> [String] -> CheckOverlap -> Resource typ
resourceName :: Resource typ -> String
resourcePieces :: Resource typ -> [Piece typ]
resourceDispatch :: Resource typ -> Dispatch typ
resourceAttrs :: Resource typ -> [String]
resourceCheck :: Resource typ -> CheckOverlap
data ResourceTree typ
ResourceLeaf :: (Resource typ) -> ResourceTree typ
ResourceParent :: String -> CheckOverlap -> [Piece typ] -> [ResourceTree typ] -> ResourceTree typ
data Piece typ
Static :: String -> Piece typ
Dynamic :: typ -> Piece typ
data Dispatch typ
Methods :: Maybe typ -> [String] -> Dispatch typ

-- | type of the multi piece at the end
methodsMulti :: Dispatch typ -> Maybe typ

-- | supported request methods
methodsMethods :: Dispatch typ -> [String]
Subsite :: typ -> String -> Dispatch typ
subsiteType :: Dispatch typ -> typ
subsiteFunc :: Dispatch typ -> String
type CheckOverlap = Bool
data FlatResource a
FlatResource :: [(String, [Piece a])] -> String -> [Piece a] -> Dispatch a -> Bool -> FlatResource a
frParentPieces :: FlatResource a -> [(String, [Piece a])]
frName :: FlatResource a -> String
frPieces :: FlatResource a -> [Piece a]
frDispatch :: FlatResource a -> Dispatch a
frCheck :: FlatResource a -> Bool
resourceMulti :: Resource typ -> Maybe typ
resourceTreePieces :: ResourceTree typ -> [Piece typ]
resourceTreeName :: ResourceTree typ -> String
flatten :: [ResourceTree a] -> [FlatResource a]
instance Show typ => Show (Piece typ)
instance Show typ => Show (Dispatch typ)
instance Show typ => Show (Resource typ)
instance Functor Resource
instance Functor ResourceTree
instance Lift t => Lift (Dispatch t)
instance Functor Dispatch
instance Lift t => Lift (Piece t)
instance Functor Piece
instance Lift t => Lift (Resource t)
instance Lift t => Lift (ResourceTree t)

module Yesod.Core.Types
type SessionMap = Map Text ByteString
type SaveSession = SessionMap -> IO [Header]
newtype SessionBackend
SessionBackend :: (Request -> IO (SessionMap, SaveSession)) -> SessionBackend

-- | Return the session data and a function to save the session
sbLoadSession :: SessionBackend -> Request -> IO (SessionMap, SaveSession)
data SessionCookie
SessionCookie :: (Either UTCTime ByteString) -> ByteString -> SessionMap -> SessionCookie
data ClientSessionDateCache
ClientSessionDateCache :: !UTCTime -> !UTCTime -> !ByteString -> ClientSessionDateCache
csdcNow :: ClientSessionDateCache -> !UTCTime
csdcExpires :: ClientSessionDateCache -> !UTCTime
csdcExpiresSerialized :: ClientSessionDateCache -> !ByteString

-- | The parsed request information. This type augments the standard WAI
--   <a>Request</a> with additional information.
data YesodRequest
YesodRequest :: ![(Text, Text)] -> ![(Text, Text)] -> !Request -> ![Text] -> !(Maybe Text) -> !SessionMap -> ![ContentType] -> YesodRequest

-- | Same as <a>queryString</a>, but decoded to <tt>Text</tt>.
reqGetParams :: YesodRequest -> ![(Text, Text)]
reqCookies :: YesodRequest -> ![(Text, Text)]
reqWaiRequest :: YesodRequest -> !Request

-- | Languages which the client supports. This is an ordered list by
--   preference.
reqLangs :: YesodRequest -> ![Text]

-- | A random, session-specific token used to prevent CSRF attacks.
reqToken :: YesodRequest -> !(Maybe Text)

-- | Initial session sent from the client.
--   
--   Since 1.2.0
reqSession :: YesodRequest -> !SessionMap

-- | An ordered list of the accepted content types.
--   
--   Since 1.2.0
reqAccept :: YesodRequest -> ![ContentType]

-- | An augmented WAI <a>Response</a>. This can either be a standard
--   <tt>Response</tt>, or a higher-level data structure which Yesod will
--   turn into a <tt>Response</tt>.
data YesodResponse
YRWai :: !Response -> YesodResponse
YRWaiApp :: !Application -> YesodResponse
YRPlain :: !Status -> ![Header] -> !ContentType -> !Content -> !SessionMap -> YesodResponse

-- | A tuple containing both the POST parameters and submitted files.
type RequestBodyContents = ([(Text, Text)], [(Text, FileInfo)])
data FileInfo
FileInfo :: !Text -> !Text -> !(Source (ResourceT IO) ByteString) -> !(FilePath -> IO ()) -> FileInfo
fileName :: FileInfo -> !Text
fileContentType :: FileInfo -> !Text
fileSourceRaw :: FileInfo -> !(Source (ResourceT IO) ByteString)
fileMove :: FileInfo -> !(FilePath -> IO ())
data FileUpload
FileUploadMemory :: !(BackEnd ByteString) -> FileUpload
FileUploadDisk :: !(InternalState -> BackEnd FilePath) -> FileUpload
FileUploadSource :: !(BackEnd (Source (ResourceT IO) ByteString)) -> FileUpload

-- | How to determine the root of the application for constructing URLs.
--   
--   Note that future versions of Yesod may add new constructors without
--   bumping the major version number. As a result, you should <i>not</i>
--   pattern match on <tt>Approot</tt> values.
data Approot master

-- | No application root.
ApprootRelative :: Approot master
ApprootStatic :: !Text -> Approot master
ApprootMaster :: !(master -> Text) -> Approot master
ApprootRequest :: !(master -> Request -> Text) -> Approot master
type ResolvedApproot = Text
data AuthResult
Authorized :: AuthResult
AuthenticationRequired :: AuthResult
Unauthorized :: Text -> AuthResult
data ScriptLoadPosition master
BottomOfBody :: ScriptLoadPosition master
BottomOfHeadBlocking :: ScriptLoadPosition master
BottomOfHeadAsync :: (BottomOfHeadAsync master) -> ScriptLoadPosition master
type BottomOfHeadAsync master = [Text] -> Maybe (HtmlUrl (Route master)) -> (HtmlUrl (Route master))
type Texts = [Text]

-- | Wrap up a normal WAI application as a Yesod subsite.
newtype WaiSubsite
WaiSubsite :: Application -> WaiSubsite
runWaiSubsite :: WaiSubsite -> Application
data RunHandlerEnv site
RunHandlerEnv :: !(Route site -> [(Text, Text)] -> Text) -> !(Maybe (Route site)) -> !site -> !(RequestBodyLength -> FileUpload) -> !(Loc -> LogSource -> LogLevel -> LogStr -> IO ()) -> !(ErrorResponse -> YesodApp) -> IO Text -> RunHandlerEnv site
rheRender :: RunHandlerEnv site -> !(Route site -> [(Text, Text)] -> Text)
rheRoute :: RunHandlerEnv site -> !(Maybe (Route site))
rheSite :: RunHandlerEnv site -> !site
rheUpload :: RunHandlerEnv site -> !(RequestBodyLength -> FileUpload)
rheLog :: RunHandlerEnv site -> !(Loc -> LogSource -> LogLevel -> LogStr -> IO ())
rheOnError :: RunHandlerEnv site -> !(ErrorResponse -> YesodApp)

-- | How to respond when an error is thrown internally.
--   
--   Since 1.2.0
rheGetMaxExpires :: RunHandlerEnv site -> IO Text
data HandlerData site parentRoute
HandlerData :: !YesodRequest -> !(RunHandlerEnv site) -> !(IORef GHState) -> !(Route site -> parentRoute) -> !InternalState -> HandlerData site parentRoute
handlerRequest :: HandlerData site parentRoute -> !YesodRequest
handlerEnv :: HandlerData site parentRoute -> !(RunHandlerEnv site)
handlerState :: HandlerData site parentRoute -> !(IORef GHState)
handlerToParent :: HandlerData site parentRoute -> !(Route site -> parentRoute)
handlerResource :: HandlerData site parentRoute -> !InternalState
data YesodRunnerEnv site
YesodRunnerEnv :: !Logger -> !site -> !(Maybe SessionBackend) -> !GenIO -> YesodRunnerEnv site
yreLogger :: YesodRunnerEnv site -> !Logger
yreSite :: YesodRunnerEnv site -> !site
yreSessionBackend :: YesodRunnerEnv site -> !(Maybe SessionBackend)
yreGen :: YesodRunnerEnv site -> !GenIO
data YesodSubRunnerEnv sub parent parentMonad
YesodSubRunnerEnv :: !(ParentRunner parent parentMonad) -> !(parent -> sub) -> !(Route sub -> Route parent) -> !(YesodRunnerEnv parent) -> YesodSubRunnerEnv sub parent parentMonad
ysreParentRunner :: YesodSubRunnerEnv sub parent parentMonad -> !(ParentRunner parent parentMonad)
ysreGetSub :: YesodSubRunnerEnv sub parent parentMonad -> !(parent -> sub)
ysreToParentRoute :: YesodSubRunnerEnv sub parent parentMonad -> !(Route sub -> Route parent)
ysreParentEnv :: YesodSubRunnerEnv sub parent parentMonad -> !(YesodRunnerEnv parent)
type ParentRunner parent m = m TypedContent -> YesodRunnerEnv parent -> Maybe (Route parent) -> Application

-- | A generic handler monad, which can have a different subsite and master
--   site. We define a newtype for better error message.
newtype HandlerT site m a
HandlerT :: (HandlerData site (MonadRoute m) -> m a) -> HandlerT site m a
unHandlerT :: HandlerT site m a -> HandlerData site (MonadRoute m) -> m a
data GHState
GHState :: SessionMap -> Maybe RequestBodyContents -> Int -> TypeMap -> KeyedTypeMap -> Endo [Header] -> GHState
ghsSession :: GHState -> SessionMap
ghsRBC :: GHState -> Maybe RequestBodyContents
ghsIdent :: GHState -> Int
ghsCache :: GHState -> TypeMap
ghsCacheBy :: GHState -> KeyedTypeMap
ghsHeaders :: GHState -> Endo [Header]

-- | An extension of the basic WAI <a>Application</a> datatype to provide
--   extra features needed by Yesod. Users should never need to use this
--   directly, as the <a>HandlerT</a> monad and template haskell code
--   should hide it away.
type YesodApp = YesodRequest -> ResourceT IO YesodResponse

-- | A generic widget, allowing specification of both the subsite and
--   master site datatypes. While this is simply a <tt>WriterT</tt>, we
--   define a newtype for better error messages.
newtype WidgetT site m a
WidgetT :: (HandlerData site (MonadRoute m) -> m (a, GWData (Route site))) -> WidgetT site m a
unWidgetT :: WidgetT site m a -> HandlerData site (MonadRoute m) -> m (a, GWData (Route site))
type RY master = Route master -> [(Text, Text)] -> Text

-- | Newtype wrapper allowing injection of arbitrary content into CSS.
--   
--   Usage:
--   
--   <pre>
--   toWidget $ CssBuilder "p { color: red }"
--   </pre>
--   
--   Since: 1.1.3
newtype CssBuilder
CssBuilder :: Builder -> CssBuilder
unCssBuilder :: CssBuilder -> Builder

-- | Content for a web page. By providing this datatype, we can easily
--   create generic site templates, which would have the type signature:
--   
--   <pre>
--   PageContent url -&gt; HtmlUrl url
--   </pre>
data PageContent url
PageContent :: Html -> HtmlUrl url -> HtmlUrl url -> PageContent url
pageTitle :: PageContent url -> Html
pageHead :: PageContent url -> HtmlUrl url
pageBody :: PageContent url -> HtmlUrl url
data Content

-- | The content and optional content length.
ContentBuilder :: !Builder -> !(Maybe Int) -> Content
ContentSource :: !(Source (ResourceT IO) (Flush Builder)) -> Content
ContentFile :: !FilePath -> !(Maybe FilePart) -> Content
ContentDontEvaluate :: !Content -> Content
data TypedContent
TypedContent :: !ContentType -> !Content -> TypedContent

-- | <i>Deprecated: Please use Html instead</i>
type RepHtml = Html
newtype RepJson
RepJson :: Content -> RepJson
newtype RepPlain
RepPlain :: Content -> RepPlain
newtype RepXml
RepXml :: Content -> RepXml
type ContentType = ByteString

-- | Prevents a response body from being fully evaluated before sending the
--   request.
--   
--   Since 1.1.0
newtype DontFullyEvaluate a
DontFullyEvaluate :: a -> DontFullyEvaluate a
unDontFullyEvaluate :: DontFullyEvaluate a -> a

-- | Responses to indicate some form of an error occurred.
data ErrorResponse
NotFound :: ErrorResponse
InternalError :: Text -> ErrorResponse
InvalidArgs :: [Text] -> ErrorResponse
NotAuthenticated :: ErrorResponse
PermissionDenied :: Text -> ErrorResponse
BadMethod :: Method -> ErrorResponse

-- | Headers to be added to a <tt>Result</tt>.
data Header
AddCookie :: SetCookie -> Header
DeleteCookie :: ByteString -> ByteString -> Header
Header :: ByteString -> ByteString -> Header
data Location url
Local :: url -> Location url
Remote :: Text -> Location url

-- | A diff list that does not directly enforce uniqueness. When creating a
--   widget Yesod will use nub to make it unique.
newtype UniqueList x
UniqueList :: ([x] -> [x]) -> UniqueList x
data Script url
Script :: Location url -> [(Text, Text)] -> Script url
scriptLocation :: Script url -> Location url
scriptAttributes :: Script url -> [(Text, Text)]
data Stylesheet url
Stylesheet :: Location url -> [(Text, Text)] -> Stylesheet url
styleLocation :: Stylesheet url -> Location url
styleAttributes :: Stylesheet url -> [(Text, Text)]
newtype Title
Title :: Html -> Title
unTitle :: Title -> Html
newtype Head url
Head :: (HtmlUrl url) -> Head url
newtype Body url
Body :: (HtmlUrl url) -> Body url
type CssBuilderUrl a = (a -> [(Text, Text)] -> Text) -> Builder
data GWData a
GWData :: !(Body a) -> !(Last Title) -> !(UniqueList (Script a)) -> !(UniqueList (Stylesheet a)) -> !(Map (Maybe Text) (CssBuilderUrl a)) -> !(Maybe (JavascriptUrl a)) -> !(Head a) -> GWData a
gwdBody :: GWData a -> !(Body a)
gwdTitle :: GWData a -> !(Last Title)
gwdScripts :: GWData a -> !(UniqueList (Script a))
gwdStylesheets :: GWData a -> !(UniqueList (Stylesheet a))
gwdCss :: GWData a -> !(Map (Maybe Text) (CssBuilderUrl a))
gwdJavascript :: GWData a -> !(Maybe (JavascriptUrl a))
gwdHead :: GWData a -> !(Head a)
data HandlerContents
HCContent :: Status -> !TypedContent -> HandlerContents
HCError :: ErrorResponse -> HandlerContents
HCSendFile :: ContentType -> FilePath -> (Maybe FilePart) -> HandlerContents
HCRedirect :: Status -> Text -> HandlerContents
HCCreated :: Text -> HandlerContents
HCWai :: Response -> HandlerContents
HCWaiApp :: Application -> HandlerContents

-- | Note: although we provide a <tt>MonadBaseControl</tt> instance,
--   <tt>lifted-base</tt>'s <tt>fork</tt> function is incompatible with the
--   underlying <tt>ResourceT</tt> system. Instead, if you must fork a
--   separate thread, you should use <tt>resourceForkIO</tt>.
--   
--   Using fork usually leads to an exception that says
--   "Control.Monad.Trans.Resource.register': The mutable state is being
--   accessed after cleanup. Please contact the maintainers."
data Logger
Logger :: !LoggerSet -> !DateCacheGetter -> Logger
loggerSet :: Logger -> !LoggerSet
loggerDate :: Logger -> !DateCacheGetter
loggerPutStr :: Logger -> LogStr -> IO ()
instance Typeable ErrorResponse
instance Typeable HandlerContents
instance Show SessionCookie
instance Read SessionCookie
instance Eq ClientSessionDateCache
instance Show ClientSessionDateCache
instance Eq AuthResult
instance Show AuthResult
instance Read AuthResult
instance Show ErrorResponse
instance Eq ErrorResponse
instance Eq Header
instance Show Header
instance Show url => Show (Location url)
instance Eq url => Eq (Location url)
instance Show url => Show (Script url)
instance Eq url => Eq (Script url)
instance Show url => Show (Stylesheet url)
instance Eq url => Eq (Stylesheet url)
instance Monoid (Head url)
instance Monoid (Body url)
instance Show (Route WaiSubsite)
instance Eq (Route WaiSubsite)
instance Read (Route WaiSubsite)
instance Ord (Route WaiSubsite)
instance ParseRoute WaiSubsite
instance RenderRoute WaiSubsite
instance IsString Content
instance Semigroup (UniqueList x)
instance Monoid (UniqueList x)
instance MonadIO m => MonadLoggerIO (HandlerT site m)
instance MonadIO m => MonadLogger (HandlerT site m)
instance (MonadIO m, MonadBase IO m, MonadThrow m) => MonadResource (HandlerT site m)
instance MonadThrow m => MonadThrow (HandlerT site m)
instance MonadBaseControl b m => MonadBaseControl b (HandlerT site m)
instance Monad m => MonadReader site (HandlerT site m)
instance MonadBase b m => MonadBase b (HandlerT site m)
instance MonadIO m => MonadIO (HandlerT site m)
instance Monad m => Monad (HandlerT site m)
instance Monad m => Applicative (HandlerT site m)
instance Monad m => Functor (HandlerT site m)
instance MonadTrans (HandlerT site)
instance MonadActive m => MonadActive (HandlerT site m)
instance MonadActive m => MonadActive (WidgetT site m)
instance MonadIO m => MonadLoggerIO (WidgetT site m)
instance MonadIO m => MonadLogger (WidgetT site m)
instance (Applicative m, MonadIO m, MonadBase IO m, MonadThrow m) => MonadResource (WidgetT site m)
instance MonadMask m => MonadMask (WidgetT site m)
instance MonadCatch m => MonadCatch (WidgetT site m)
instance MonadMask m => MonadMask (HandlerT site m)
instance MonadCatch m => MonadCatch (HandlerT site m)
instance MonadThrow m => MonadThrow (WidgetT site m)
instance MonadTrans (WidgetT site)
instance Monad m => MonadReader site (WidgetT site m)
instance MonadBaseControl b m => MonadBaseControl b (WidgetT site m)
instance MonadBase b m => MonadBase b (WidgetT site m)
instance MonadIO m => MonadIO (WidgetT site m)
instance Monad m => Monad (WidgetT site m)
instance Monad m => Applicative (WidgetT site m)
instance Monad m => Functor (WidgetT site m)
instance Exception HandlerContents
instance Show HandlerContents
instance Semigroup (GWData a)
instance Monoid (GWData a)
instance Semigroup (Body a)
instance Semigroup (Head a)
instance NFData Header
instance (a ~ (), Monad m) => Semigroup (WidgetT site m a)
instance (a ~ (), Monad m) => Monoid (WidgetT site m a)
instance Serialize SessionCookie

module Yesod.Core.Content
data Content

-- | The content and optional content length.
ContentBuilder :: !Builder -> !(Maybe Int) -> Content
ContentSource :: !(Source (ResourceT IO) (Flush Builder)) -> Content
ContentFile :: !FilePath -> !(Maybe FilePart) -> Content
ContentDontEvaluate :: !Content -> Content

-- | Zero-length enumerator.
emptyContent :: Content

-- | Anything which can be converted into <a>Content</a>. Most of the time,
--   you will want to use the <a>ContentBuilder</a> constructor. An easier
--   approach will be to use a pre-defined <a>toContent</a> function, such
--   as converting your data into a lazy bytestring and then calling
--   <a>toContent</a> on that.
--   
--   Please note that the built-in instances for lazy data structures
--   (<a>String</a>, lazy <a>ByteString</a>, lazy <a>Text</a> and
--   <a>Html</a>) will not automatically include the content length for the
--   <a>ContentBuilder</a> constructor.
class ToContent a
toContent :: ToContent a => a -> Content

-- | A class for all data which can be sent in a streaming response. Note
--   that for textual data, instances must use UTF-8 encoding.
--   
--   Since 1.2.0
class ToFlushBuilder a
toFlushBuilder :: ToFlushBuilder a => a -> Flush Builder
type ContentType = ByteString
typeHtml :: ContentType
typePlain :: ContentType
typeJson :: ContentType
typeXml :: ContentType
typeAtom :: ContentType
typeRss :: ContentType
typeJpeg :: ContentType
typePng :: ContentType
typeGif :: ContentType
typeSvg :: ContentType
typeJavascript :: ContentType
typeCss :: ContentType
typeFlv :: ContentType
typeOgv :: ContentType
typeOctet :: ContentType

-- | Removes "extra" information at the end of a content type string. In
--   particular, removes everything after the semicolon, if present.
--   
--   For example, "text/html; charset=utf-8" is commonly used to specify
--   the character encoding for HTML data. This function would return
--   "text/html".
simpleContentType :: ContentType -> ContentType
contentTypeTypes :: ContentType -> (ByteString, ByteString)

-- | Prevents a response body from being fully evaluated before sending the
--   request.
--   
--   Since 1.1.0
newtype DontFullyEvaluate a
DontFullyEvaluate :: a -> DontFullyEvaluate a
unDontFullyEvaluate :: DontFullyEvaluate a -> a
data TypedContent
TypedContent :: !ContentType -> !Content -> TypedContent

-- | Any type which can be converted to <a>TypedContent</a>.
--   
--   Since 1.2.0
class ToContent a => ToTypedContent a
toTypedContent :: ToTypedContent a => a -> TypedContent
class ToTypedContent a => HasContentType a
getContentType :: (HasContentType a, Monad m) => m a -> ContentType

-- | <i>Deprecated: Please use Html instead</i>
type RepHtml = Html
newtype RepJson
RepJson :: Content -> RepJson
newtype RepPlain
RepPlain :: Content -> RepPlain
newtype RepXml
RepXml :: Content -> RepXml
repJson :: ToContent a => a -> RepJson
repPlain :: ToContent a => a -> RepPlain
repXml :: ToContent a => a -> RepXml
instance ToContent RepXml
instance ToContent RepPlain
instance ToContent RepJson
instance ToTypedContent Javascript
instance ToTypedContent Css
instance ToTypedContent a => ToTypedContent (DontFullyEvaluate a)
instance ToTypedContent Text
instance ToTypedContent [Char]
instance ToTypedContent Text
instance ToTypedContent Html
instance ToTypedContent Value
instance ToTypedContent RepXml
instance ToTypedContent RepPlain
instance ToTypedContent RepJson
instance ToTypedContent (ContentType, Content)
instance ToTypedContent ()
instance ToTypedContent TypedContent
instance HasContentType Javascript
instance HasContentType Css
instance HasContentType Text
instance HasContentType Text
instance HasContentType Html
instance HasContentType Value
instance ToContent Value
instance ToContent a => ToContent (DontFullyEvaluate a)
instance HasContentType a => HasContentType (DontFullyEvaluate a)
instance HasContentType RepXml
instance HasContentType RepPlain
instance HasContentType RepJson
instance ToFlushBuilder Html
instance ToFlushBuilder (Flush Html)
instance ToFlushBuilder String
instance ToFlushBuilder (Flush String)
instance ToFlushBuilder Text
instance ToFlushBuilder (Flush Text)
instance ToFlushBuilder Text
instance ToFlushBuilder (Flush Text)
instance ToFlushBuilder ByteString
instance ToFlushBuilder (Flush ByteString)
instance ToFlushBuilder ByteString
instance ToFlushBuilder (Flush ByteString)
instance ToFlushBuilder Builder
instance ToFlushBuilder (Flush Builder)
instance ToFlushBuilder builder => ToContent (ResumableSource (ResourceT IO) builder)
instance ToFlushBuilder builder => ToContent (Source (ResourceT IO) builder)
instance ToFlushBuilder builder => ToContent (Pipe () () builder () (ResourceT IO) ())
instance ToContent Javascript
instance ToContent Css
instance ToContent TypedContent
instance ToContent (ContentType, Content)
instance ToContent ()
instance ToContent Html
instance ToContent String
instance ToContent Text
instance ToContent Text
instance ToContent ByteString
instance ToContent ByteString
instance ToContent Builder
instance ToContent Content


-- | Exposed mostly for testing. These functions provide an unstable API
--   and should not be relied upon.
module Yesod.Core.Internal

module Yesod.Core.Handler

-- | A generic handler monad, which can have a different subsite and master
--   site. We define a newtype for better error message.
data HandlerT site m a

-- | Get the master site application argument.
getYesod :: MonadHandler m => m (HandlerSite m)

-- | Get the URL rendering function.
getUrlRender :: MonadHandler m => m (Route (HandlerSite m) -> Text)

-- | The URL rendering function with query-string parameters.
getUrlRenderParams :: MonadHandler m => m (Route (HandlerSite m) -> [(Text, Text)] -> Text)

-- | Get the route requested by the user. If this is a 404 response- where
--   the user requested an invalid route- this function will return
--   <a>Nothing</a>.
getCurrentRoute :: MonadHandler m => m (Maybe (Route (HandlerSite m)))
getRequest :: MonadHandler m => m YesodRequest

-- | Get the request's <a>Request</a> value.
waiRequest :: MonadHandler m => m Request
runRequestBody :: MonadHandler m => m RequestBodyContents

-- | Stream in the raw request body without any parsing.
--   
--   Since 1.2.0
rawRequestBody :: MonadHandler m => Source m ByteString

-- | A tuple containing both the POST parameters and submitted files.
type RequestBodyContents = ([(Text, Text)], [(Text, FileInfo)])

-- | The parsed request information. This type augments the standard WAI
--   <a>Request</a> with additional information.
data YesodRequest
YesodRequest :: ![(Text, Text)] -> ![(Text, Text)] -> !Request -> ![Text] -> !(Maybe Text) -> !SessionMap -> ![ContentType] -> YesodRequest

-- | Same as <a>queryString</a>, but decoded to <tt>Text</tt>.
reqGetParams :: YesodRequest -> ![(Text, Text)]
reqCookies :: YesodRequest -> ![(Text, Text)]
reqWaiRequest :: YesodRequest -> !Request

-- | Languages which the client supports. This is an ordered list by
--   preference.
reqLangs :: YesodRequest -> ![Text]

-- | A random, session-specific token used to prevent CSRF attacks.
reqToken :: YesodRequest -> !(Maybe Text)

-- | Initial session sent from the client.
--   
--   Since 1.2.0
reqSession :: YesodRequest -> !SessionMap

-- | An ordered list of the accepted content types.
--   
--   Since 1.2.0
reqAccept :: YesodRequest -> ![ContentType]
data FileInfo
fileName :: FileInfo -> Text
fileContentType :: FileInfo -> Text

-- | Stream the data from the file. Since Yesod 1.2, this has been
--   generalized to work in any <tt>MonadResource</tt>.
fileSource :: MonadResource m => FileInfo -> Source m ByteString
fileMove :: FileInfo -> (FilePath -> IO ())

-- | Get the list of supported languages supplied by the user.
--   
--   Languages are determined based on the following three (in descending
--   order of preference):
--   
--   <ul>
--   <li>The _LANG get parameter.</li>
--   <li>The _LANG cookie.</li>
--   <li>The _LANG user session variable.</li>
--   <li>Accept-Language HTTP header.</li>
--   </ul>
--   
--   Yesod will seek the first language from the returned list matched with
--   languages supporting by your application. This language will be used
--   to render i18n templates. If a matching language is not found the
--   default language will be used.
--   
--   This is handled by parseWaiRequest (not exposed).
languages :: MonadHandler m => m [Text]

-- | Lookup for GET parameters.
lookupGetParam :: MonadHandler m => Text -> m (Maybe Text)
lookupPostParam :: (MonadResource m, MonadHandler m) => Text -> m (Maybe Text)

-- | Lookup for cookie data.
lookupCookie :: MonadHandler m => Text -> m (Maybe Text)

-- | Lookup for POSTed files.
lookupFile :: (MonadHandler m, MonadResource m) => Text -> m (Maybe FileInfo)

-- | Lookup a request header.
--   
--   Since 1.2.2
lookupHeader :: MonadHandler m => CI ByteString -> m (Maybe ByteString)

-- | Lookup basic authentication data from <b>Authorization</b> header of
--   request. Returns user name and password
--   
--   Since 1.4.9
lookupBasicAuth :: MonadHandler m => m (Maybe (Text, Text))

-- | Lookup bearer authentication datafrom <b>Authorization</b> header of
--   request. Returns bearer token value
--   
--   Since 1.4.9
lookupBearerAuth :: MonadHandler m => m (Maybe Text)

-- | Lookup for GET parameters.
lookupGetParams :: MonadHandler m => Text -> m [Text]

-- | Lookup for POST parameters.
lookupPostParams :: (MonadResource m, MonadHandler m) => Text -> m [Text]

-- | Lookup for cookie data.
lookupCookies :: MonadHandler m => Text -> m [Text]

-- | Lookup for POSTed files.
lookupFiles :: (MonadHandler m, MonadResource m) => Text -> m [FileInfo]

-- | Lookup a request header.
--   
--   Since 1.2.2
lookupHeaders :: MonadHandler m => CI ByteString -> m [ByteString]

-- | Provide a pure value for the response body.
--   
--   <pre>
--   respond ct = return . TypedContent ct . toContent
--   </pre>
--   
--   Since 1.2.0
respond :: (Monad m, ToContent a) => ContentType -> a -> m TypedContent

-- | Use a <tt>Source</tt> for the response body.
--   
--   Note that, for ease of use, the underlying monad is a
--   <tt>HandlerT</tt>. This implies that you can run any <tt>HandlerT</tt>
--   action. However, since a streaming response occurs after the response
--   headers have already been sent, some actions make no sense here. For
--   example: short-circuit responses, setting headers, changing status
--   codes, etc.
--   
--   Since 1.2.0
respondSource :: ContentType -> Source (HandlerT site IO) (Flush Builder) -> HandlerT site IO TypedContent

-- | In a streaming response, send a single chunk of data. This function
--   works on most datatypes, such as <tt>ByteString</tt> and
--   <tt>Html</tt>.
--   
--   Since 1.2.0
sendChunk :: Monad m => ToFlushBuilder a => a -> Producer m (Flush Builder)

-- | In a streaming response, send a flush command, causing all buffered
--   data to be immediately sent to the client.
--   
--   Since 1.2.0
sendFlush :: Monad m => Producer m (Flush Builder)

-- | Type-specialized version of <a>sendChunk</a> for strict
--   <tt>ByteString</tt>s.
--   
--   Since 1.2.0
sendChunkBS :: Monad m => ByteString -> Producer m (Flush Builder)

-- | Type-specialized version of <a>sendChunk</a> for lazy
--   <tt>ByteString</tt>s.
--   
--   Since 1.2.0
sendChunkLBS :: Monad m => ByteString -> Producer m (Flush Builder)

-- | Type-specialized version of <a>sendChunk</a> for strict
--   <tt>Text</tt>s.
--   
--   Since 1.2.0
sendChunkText :: Monad m => Text -> Producer m (Flush Builder)

-- | Type-specialized version of <a>sendChunk</a> for lazy <tt>Text</tt>s.
--   
--   Since 1.2.0
sendChunkLazyText :: Monad m => Text -> Producer m (Flush Builder)

-- | Type-specialized version of <a>sendChunk</a> for <tt>Html</tt>s.
--   
--   Since 1.2.0
sendChunkHtml :: Monad m => Html -> Producer m (Flush Builder)

-- | Some value which can be turned into a URL for redirects.
class RedirectUrl master a
toTextUrl :: (RedirectUrl master a, MonadHandler m, HandlerSite m ~ master) => a -> m Text

-- | Redirect to the given route. HTTP status code 303 for HTTP 1.1 clients
--   and 302 for HTTP 1.0 This is the appropriate choice for a
--   get-following-post technique, which should be the usual use case.
--   
--   If you want direct control of the final status code, or need a
--   different status code, please use <a>redirectWith</a>.
redirect :: (MonadHandler m, RedirectUrl (HandlerSite m) url) => url -> m a

-- | Redirect to the given URL with the specified status code.
redirectWith :: (MonadHandler m, RedirectUrl (HandlerSite m) url) => Status -> url -> m a

-- | Redirect to a POST resource.
--   
--   This is not technically a redirect; instead, it returns an HTML page
--   with a POST form, and some Javascript to automatically submit the
--   form. This can be useful when you need to post a plain link somewhere
--   that needs to cause changes on the server.
redirectToPost :: (MonadHandler m, RedirectUrl (HandlerSite m) url) => url -> m a

-- | Add a fragment identifier to a route to be used when redirecting. For
--   example:
--   
--   <pre>
--   redirect (NewsfeedR :#: storyId)
--   </pre>
--   
--   Since 1.2.9.
data Fragment a b
(:#:) :: a -> b -> Fragment a b

-- | Return a 404 not found page. Also denotes no handler available.
notFound :: MonadHandler m => m a

-- | Return a 405 method not supported page.
badMethod :: MonadHandler m => m a

-- | Return a 401 status code
notAuthenticated :: MonadHandler m => m a

-- | Return a 403 permission denied page.
permissionDenied :: MonadHandler m => Text -> m a

-- | Return a 403 permission denied page.
permissionDeniedI :: (RenderMessage (HandlerSite m) msg, MonadHandler m) => msg -> m a

-- | Return a 400 invalid arguments page.
invalidArgs :: MonadHandler m => [Text] -> m a

-- | Return a 400 invalid arguments page.
invalidArgsI :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => [msg] -> m a

-- | Bypass remaining handler code and output the given file.
--   
--   For some backends, this is more efficient than reading in the file to
--   memory, since they can optimize file sending via a system call to
--   sendfile.
sendFile :: MonadHandler m => ContentType -> FilePath -> m a

-- | Same as <a>sendFile</a>, but only sends part of a file.
sendFilePart :: MonadHandler m => ContentType -> FilePath -> Integer -> Integer -> m a

-- | Bypass remaining handler code and output the given content with a 200
--   status code.
sendResponse :: (MonadHandler m, ToTypedContent c) => c -> m a

-- | Bypass remaining handler code and output the given content with the
--   given status code.
sendResponseStatus :: (MonadHandler m, ToTypedContent c) => Status -> c -> m a

-- | Send a 201 <a>Created</a> response with the given route as the
--   Location response header.
sendResponseCreated :: MonadHandler m => Route (HandlerSite m) -> m a

-- | Send a <a>Response</a>. Please note: this function is rarely
--   necessary, and will <i>disregard</i> any changes to response headers
--   and session that you have already specified. This function
--   short-circuits. It should be considered only for very specific needs.
--   If you are not sure if you need it, you don't.
sendWaiResponse :: MonadHandler m => Response -> m b

-- | Switch over to handling the current request with a WAI
--   <tt>Application</tt>.
--   
--   Since 1.2.17
sendWaiApplication :: MonadHandler m => Application -> m b

-- | Send a raw response. This is used for cases such as WebSockets.
--   Requires WAI 2.1 or later, and a web server which supports raw
--   responses (e.g., Warp).
--   
--   Since 1.2.7
sendRawResponse :: (MonadHandler m, MonadBaseControl IO m) => (Source IO ByteString -> Sink ByteString IO () -> m ()) -> m a

-- | Send a raw response without conduit. This is used for cases such as
--   WebSockets. Requires WAI 3.0 or later, and a web server which supports
--   raw responses (e.g., Warp).
--   
--   Since 1.2.16
sendRawResponseNoConduit :: (MonadHandler m, MonadBaseControl IO m) => (IO ByteString -> (ByteString -> IO ()) -> m ()) -> m a

-- | Send a 304 not modified response immediately. This is a
--   short-circuiting action.
--   
--   Since 1.4.4
notModified :: MonadHandler m => m a

-- | Select a representation to send to the client based on the
--   representations provided inside this do-block. Should be used together
--   with <a>provideRep</a>.
--   
--   Since 1.2.0
selectRep :: MonadHandler m => Writer (Endo [ProvidedRep m]) () -> m TypedContent

-- | Provide a single representation to be used, based on the request of
--   the client. Should be used together with <a>selectRep</a>.
--   
--   Since 1.2.0
provideRep :: (Monad m, HasContentType a) => m a -> Writer (Endo [ProvidedRep m]) ()

-- | Same as <a>provideRep</a>, but instead of determining the content type
--   from the type of the value itself, you provide the content type
--   separately. This can be a convenience instead of creating newtype
--   wrappers for uncommonly used content types.
--   
--   <pre>
--   provideRepType "application/x-special-format" "This is the content"
--   </pre>
--   
--   Since 1.2.0
provideRepType :: (Monad m, ToContent a) => ContentType -> m a -> Writer (Endo [ProvidedRep m]) ()

-- | Internal representation of a single provided representation.
--   
--   Since 1.2.0
data ProvidedRep m

-- | Set the cookie on the client.
setCookie :: MonadHandler m => SetCookie -> m ()

-- | Helper function for setCookieExpires value
getExpires :: MonadIO m => Int -> m UTCTime

-- | Unset the cookie on the client.
--   
--   Note: although the value used for key and path is <a>Text</a>, you
--   should only use ASCII values to be HTTP compliant.
deleteCookie :: MonadHandler m => Text -> Text -> m ()

-- | Set an arbitrary response header.
--   
--   Note that, while the data type used here is <a>Text</a>, you must
--   provide only ASCII value to be HTTP compliant.
--   
--   Since 1.2.0
addHeader :: MonadHandler m => Text -> Text -> m ()

-- | Deprecated synonym for addHeader.

-- | <i>Deprecated: Please use addHeader instead</i>
setHeader :: MonadHandler m => Text -> Text -> m ()

-- | Set the language in the user session. Will show up in <a>languages</a>
--   on the next request.
setLanguage :: MonadHandler m => Text -> m ()

-- | Set the Cache-Control header to indicate this response should be
--   cached for the given number of seconds.
cacheSeconds :: MonadHandler m => Int -> m ()

-- | Set the Expires header to some date in 2037. In other words, this
--   content is never (realistically) expired.
neverExpires :: MonadHandler m => m ()

-- | Set an Expires header in the past, meaning this content should not be
--   cached.
alreadyExpired :: MonadHandler m => m ()

-- | Set an Expires header to the given date.
expiresAt :: MonadHandler m => UTCTime -> m ()

-- | Check the if-none-match header and, if it matches the given value,
--   return a 304 not modified response. Otherwise, set the etag header to
--   the given value.
--   
--   Note that it is the responsibility of the caller to ensure that the
--   provided value is a value etag value, no sanity checking is performed
--   by this function.
--   
--   Since 1.4.4
setEtag :: MonadHandler m => Text -> m ()
type SessionMap = Map Text ByteString

-- | Lookup for session data.
lookupSession :: MonadHandler m => Text -> m (Maybe Text)

-- | Lookup for session data in binary format.
lookupSessionBS :: MonadHandler m => Text -> m (Maybe ByteString)

-- | Get all session variables.
getSession :: MonadHandler m => m SessionMap

-- | Set a variable in the user's session.
--   
--   The session is handled by the clientsession package: it sets an
--   encrypted and hashed cookie on the client. This ensures that all data
--   is secure and not tampered with.
setSession :: MonadHandler m => Text -> Text -> m ()

-- | Same as <a>setSession</a>, but uses binary data for the value.
setSessionBS :: MonadHandler m => Text -> ByteString -> m ()

-- | Unsets a session variable. See <a>setSession</a>.
deleteSession :: MonadHandler m => Text -> m ()

-- | Clear all session variables.
--   
--   Since: 1.0.1
clearSession :: MonadHandler m => m ()

-- | Sets the ultimate destination variable to the given route.
--   
--   An ultimate destination is stored in the user session and can be
--   loaded later by <a>redirectUltDest</a>.
setUltDest :: (MonadHandler m, RedirectUrl (HandlerSite m) url) => url -> m ()

-- | Same as <a>setUltDest</a>, but uses the current page.
--   
--   If this is a 404 handler, there is no current page, and then this call
--   does nothing.
setUltDestCurrent :: MonadHandler m => m ()

-- | Sets the ultimate destination to the referer request header, if
--   present.
--   
--   This function will not overwrite an existing ultdest.
setUltDestReferer :: MonadHandler m => m ()

-- | Redirect to the ultimate destination in the user's session. Clear the
--   value from the session.
--   
--   The ultimate destination is set with <a>setUltDest</a>.
--   
--   This function uses <a>redirect</a>, and thus will perform a temporary
--   redirect to a GET request.
redirectUltDest :: (RedirectUrl (HandlerSite m) url, MonadHandler m) => url -> m a

-- | Remove a previously set ultimate destination. See <a>setUltDest</a>.
clearUltDest :: MonadHandler m => m ()

-- | Sets a message in the user's session.
--   
--   See <a>getMessage</a>.
setMessage :: MonadHandler m => Html -> m ()

-- | Sets a message in the user's session.
--   
--   See <a>getMessage</a>.
setMessageI :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => msg -> m ()

-- | Gets the message in the user's session, if available, and then clears
--   the variable.
--   
--   See <a>setMessage</a>.
getMessage :: MonadHandler m => m (Maybe Html)

-- | Wraps the <a>Content</a> generated by <tt>hamletToContent</tt> in a
--   <a>RepHtml</a>.

-- | <i>Deprecated: Use withUrlRenderer instead</i>
hamletToRepHtml :: MonadHandler m => HtmlUrl (Route (HandlerSite m)) -> m Html

-- | Deprecated synonym for <a>withUrlRenderer</a>.
--   
--   Since 1.2.0

-- | <i>Deprecated: Use withUrlRenderer instead</i>
giveUrlRenderer :: MonadHandler m => ((Route (HandlerSite m) -> [(Text, Text)] -> Text) -> output) -> m output

-- | Provide a URL rendering function to the given function and return the
--   result. Useful for processing Shakespearean templates.
--   
--   Since 1.2.20
withUrlRenderer :: MonadHandler m => ((Route (HandlerSite m) -> [(Text, Text)] -> Text) -> output) -> m output

-- | Get a unique identifier.
newIdent :: MonadHandler m => m Text

-- | Returns a function that runs <a>HandlerT</a> actions inside
--   <tt>IO</tt>.
--   
--   Sometimes you want to run an inner <a>HandlerT</a> action outside the
--   control flow of an HTTP request (on the outer <a>HandlerT</a> action).
--   For example, you may want to spawn a new thread:
--   
--   <pre>
--   getFooR :: Handler RepHtml
--   getFooR = do
--     runInnerHandler &lt;- handlerToIO
--     liftIO $ forkIO $ runInnerHandler $ do
--       <i>Code here runs inside GHandler but on a new thread.</i>
--       <i>This is the inner GHandler.</i>
--       ...
--     <i>Code here runs inside the request's control flow.</i>
--     <i>This is the outer GHandler.</i>
--     ...
--   </pre>
--   
--   Another use case for this function is creating a stream of server-sent
--   events using <tt>GHandler</tt> actions (see
--   <tt>yesod-eventsource</tt>).
--   
--   Most of the environment from the outer <tt>GHandler</tt> is preserved
--   on the inner <tt>GHandler</tt>, however:
--   
--   <ul>
--   <li>The request body is cleared (otherwise it would be very difficult
--   to prevent huge memory leaks).</li>
--   <li>The cache is cleared (see <tt>CacheKey</tt>).</li>
--   </ul>
--   
--   Changes to the response made inside the inner <tt>GHandler</tt> are
--   ignored (e.g., session variables, cookies, response headers). This
--   allows the inner <tt>GHandler</tt> to outlive the outer
--   <tt>GHandler</tt> (e.g., on the <tt>forkIO</tt> example above, a
--   response may be sent to the client without killing the new thread).
handlerToIO :: (MonadIO m1, MonadIO m2) => HandlerT site m1 (HandlerT site IO a -> m2 a)

-- | forkIO for a Handler (run an action in the background)
--   
--   Uses <a>handlerToIO</a>, liftResourceT, and resourceForkIO for
--   correctness and efficiency
--   
--   Since 1.2.8
forkHandler :: (SomeException -> HandlerT site IO ()) -> HandlerT site IO () -> HandlerT site IO ()
getMessageRender :: (MonadHandler m, RenderMessage (HandlerSite m) message) => m (message -> Text)

-- | Use a per-request cache to avoid performing the same action multiple
--   times. Values are stored by their type, the result of typeOf from
--   Typeable. Therefore, you should use different newtype wrappers at each
--   cache site.
--   
--   For example, yesod-auth uses an un-exported newtype, CachedMaybeAuth
--   and exports functions that utilize it such as maybeAuth. This means
--   that another module can create its own newtype wrapper to cache the
--   same type from a different action without any cache conflicts.
--   
--   See the original announcement:
--   <a>http://www.yesodweb.com/blog/2013/03/yesod-1-2-cleaner-internals</a>
--   
--   Since 1.2.0
cached :: (MonadHandler m, Typeable a) => m a -> m a

-- | a per-request cache. just like <a>cached</a>. <a>cached</a> can only
--   cache a single value per type. <a>cachedBy</a> stores multiple values
--   per type by usage of a ByteString key
--   
--   <a>cached</a> is ideal to cache an action that has only one value of a
--   type, such as the session's current user <a>cachedBy</a> is required
--   if the action has parameters and can return multiple values per type.
--   You can turn those parameters into a ByteString cache key. For
--   example, caching a lookup of a Link by a token where multiple token
--   lookups might be performed.
--   
--   Since 1.4.0
cachedBy :: (MonadHandler m, Typeable a) => ByteString -> m a -> m a

-- | Converts a child handler to a parent handler
--   
--   Exported since 1.4.11
stripHandlerT :: HandlerT child (HandlerT parent m) a -> (parent -> child) -> (Route child -> Route parent) -> Maybe (Route child) -> HandlerT parent m a
instance Typeable Fragment
instance (Show a, Show b) => Show (Fragment a b)
instance (RedirectUrl master a, PathPiece b) => RedirectUrl master (Fragment a b)
instance (key ~ Text, val ~ Text) => RedirectUrl master (Route master, Map key val)
instance (key ~ Text, val ~ Text) => RedirectUrl master (Route master, [(key, val)])
instance RedirectUrl master (Route master)
instance RedirectUrl master String
instance RedirectUrl master Text


-- | Widgets combine HTML with JS and CSS dependencies with a unique
--   identifier generator, allowing you to create truly modular HTML
--   components.
module Yesod.Core.Widget

-- | A generic widget, allowing specification of both the subsite and
--   master site datatypes. While this is simply a <tt>WriterT</tt>, we
--   define a newtype for better error messages.
data WidgetT site m a

-- | Content for a web page. By providing this datatype, we can easily
--   create generic site templates, which would have the type signature:
--   
--   <pre>
--   PageContent url -&gt; HtmlUrl url
--   </pre>
data PageContent url
PageContent :: Html -> HtmlUrl url -> HtmlUrl url -> PageContent url
pageTitle :: PageContent url -> Html
pageHead :: PageContent url -> HtmlUrl url
pageBody :: PageContent url -> HtmlUrl url
whamlet :: QuasiQuoter
whamletFile :: FilePath -> Q Exp

-- | Wraps the <a>Content</a> generated by <tt>hamletToContent</tt> in a
--   <a>RepHtml</a>.

-- | <i>Deprecated: Please use ihamletToHtml instead</i>
ihamletToRepHtml :: (MonadHandler m, RenderMessage (HandlerSite m) message) => HtmlUrlI18n message (Route (HandlerSite m)) -> m Html

-- | Wraps the <a>Content</a> generated by <tt>hamletToContent</tt> in a
--   <a>RepHtml</a>.
--   
--   Since 1.2.1
ihamletToHtml :: (MonadHandler m, RenderMessage (HandlerSite m) message) => HtmlUrlI18n message (Route (HandlerSite m)) -> m Html
class ToWidget site a
toWidget :: (ToWidget site a, MonadWidget m, HandlerSite m ~ site) => a -> m ()
class ToWidgetHead site a
toWidgetHead :: (ToWidgetHead site a, MonadWidget m, HandlerSite m ~ site) => a -> m ()
class ToWidgetBody site a
toWidgetBody :: (ToWidgetBody site a, MonadWidget m, HandlerSite m ~ site) => a -> m ()

-- | Allows adding some CSS to the page with a specific media type.
--   
--   Since 1.2
class ToWidgetMedia site a
toWidgetMedia :: (ToWidgetMedia site a, MonadWidget m, HandlerSite m ~ site) => Text -> a -> m ()

-- | Set the page title. Calling <a>setTitle</a> multiple times overrides
--   previously set values.
setTitle :: MonadWidget m => Html -> m ()

-- | Set the page title. Calling <a>setTitle</a> multiple times overrides
--   previously set values.
setTitleI :: (MonadWidget m, RenderMessage (HandlerSite m) msg) => msg -> m ()

-- | Link to the specified local stylesheet.
addStylesheet :: MonadWidget m => Route (HandlerSite m) -> m ()

-- | Link to the specified local stylesheet.
addStylesheetAttrs :: MonadWidget m => Route (HandlerSite m) -> [(Text, Text)] -> m ()

-- | Link to the specified remote stylesheet.
addStylesheetRemote :: MonadWidget m => Text -> m ()

-- | Link to the specified remote stylesheet.
addStylesheetRemoteAttrs :: MonadWidget m => Text -> [(Text, Text)] -> m ()
addStylesheetEither :: MonadWidget m => Either (Route (HandlerSite m)) Text -> m ()

-- | Newtype wrapper allowing injection of arbitrary content into CSS.
--   
--   Usage:
--   
--   <pre>
--   toWidget $ CssBuilder "p { color: red }"
--   </pre>
--   
--   Since: 1.1.3
newtype CssBuilder
CssBuilder :: Builder -> CssBuilder
unCssBuilder :: CssBuilder -> Builder

-- | Link to the specified local script.
addScript :: MonadWidget m => Route (HandlerSite m) -> m ()

-- | Link to the specified local script.
addScriptAttrs :: MonadWidget m => Route (HandlerSite m) -> [(Text, Text)] -> m ()

-- | Link to the specified remote script.
addScriptRemote :: MonadWidget m => Text -> m ()

-- | Link to the specified remote script.
addScriptRemoteAttrs :: MonadWidget m => Text -> [(Text, Text)] -> m ()
addScriptEither :: MonadWidget m => Either (Route (HandlerSite m)) Text -> m ()
widgetToParentWidget :: MonadIO m => WidgetT child IO a -> HandlerT child (HandlerT parent m) (WidgetT parent m a)
handlerToWidget :: Monad m => HandlerT site m a -> WidgetT site m a
whamletFileWithSettings :: HamletSettings -> FilePath -> Q Exp
asWidgetT :: WidgetT site m () -> WidgetT site m ()
instance ToWidgetHead site Html
instance ToWidgetHead site Javascript
instance render ~ RY site => ToWidgetHead site (render -> Javascript)
instance ToWidgetHead site CssBuilder
instance render ~ RY site => ToWidgetHead site (render -> CssBuilder)
instance ToWidgetHead site Css
instance render ~ RY site => ToWidgetHead site (render -> Css)
instance render ~ RY site => ToWidgetHead site (render -> Html)
instance ToWidgetBody site Html
instance ToWidgetBody site Javascript
instance render ~ RY site => ToWidgetBody site (render -> Javascript)
instance render ~ RY site => ToWidgetBody site (render -> Html)
instance ToWidgetMedia site CssBuilder
instance render ~ RY site => ToWidgetMedia site (render -> CssBuilder)
instance ToWidgetMedia site Css
instance render ~ RY site => ToWidgetMedia site (render -> Css)
instance ToWidget site Html
instance (site' ~ site, IO ~ m, a ~ ()) => ToWidget site' (WidgetT site m a)
instance ToWidget site Javascript
instance render ~ RY site => ToWidget site (render -> Javascript)
instance ToWidget site CssBuilder
instance render ~ RY site => ToWidget site (render -> CssBuilder)
instance ToWidget site Css
instance render ~ RY site => ToWidget site (render -> Css)
instance render ~ RY site => ToWidget site (render -> Html)

module Yesod.Core.Json

-- | Provide both an HTML and JSON representation for a piece of data,
--   using the default layout for the HTML output (<a>defaultLayout</a>).
--   
--   <i>Since: 0.3.0</i>
defaultLayoutJson :: (Yesod site, ToJSON a) => WidgetT site IO () -> HandlerT site IO a -> HandlerT site IO TypedContent

-- | Wraps a data type in a <tt>RepJson</tt>. The data type must support
--   conversion to JSON via <a>ToJSON</a>.
--   
--   <i>Since: 0.3.0</i>

-- | <i>Deprecated: Use returnJson instead</i>
jsonToRepJson :: (Monad m, ToJSON a) => a -> m Value

-- | Convert a value to a JSON representation via aeson's <a>toJSON</a>
--   function.
--   
--   Since 1.2.1
returnJson :: (Monad m, ToJSON a) => a -> m Value

-- | Provide a JSON representation for usage with <tt>selectReps</tt>,
--   using aeson's <a>toJSON</a> function to perform the conversion.
--   
--   Since 1.2.1
provideJson :: (Monad m, ToJSON a) => a -> Writer (Endo [ProvidedRep m]) ()

-- | Parse the request body to a data type as a JSON value. The data type
--   must support conversion from JSON via <a>FromJSON</a>. If you want the
--   raw JSON value, just ask for a <tt><a>Result</a> <a>Value</a></tt>.
--   
--   Note that this function will consume the request body. As such,
--   calling it twice will result in a parse error on the second call,
--   since the request body will no longer be available.
--   
--   <i>Since: 0.3.0</i>
parseJsonBody :: (MonadHandler m, FromJSON a) => m (Result a)

-- | Same as <a>parseJsonBody</a>, but return an invalid args response on a
--   parse error.

-- | <i>Deprecated: Use requireJsonBody instead</i>
parseJsonBody_ :: (MonadHandler m, FromJSON a) => m a

-- | Same as <a>parseJsonBody</a>, but return an invalid args response on a
--   parse error.
requireJsonBody :: (MonadHandler m, FromJSON a) => m a

-- | A JSON value represented as a Haskell value.
data Value :: *
Object :: SrictNotUnpackedObject -> Value
Array :: SrictNotUnpackedArray -> Value
String :: SrictNotUnpackedText -> Value
Number :: SrictNotUnpackedScientific -> Value
Bool :: SrictNotUnpackedBool -> Value
Null :: Value

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where toJSON (Coord x y) = <a>object</a> ["x"
--   <tt>.=</tt> x, "y" <tt>.=</tt> y] @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>toJSON</tt>
--   function that accepts any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (GHC 7.2 and newer),
--   <tt>toJSON</tt> will have a default generic implementation.</li>
--   </ul>
--   
--   To use the latter option, simply add a <tt>deriving
--   <a>Generic</a></tt> clause to your datatype and declare a
--   <tt>ToJSON</tt> instance for your datatype without giving a definition
--   for <tt>toJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic encoding using
--   <a>genericToJSON</a> applied to your encoding/decoding <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON = <a>genericToJSON</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a
toJSON :: ToJSON a => a -> Value

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = Coord    <tt>&lt;$&gt;</tt>
--                            v <tt>.:</tt> "x" <tt>&lt;*&gt;</tt>
--                            v <tt>.:</tt> "y"
--   
--     -- A non-<a>Object</a> value is of the wrong type, so use <tt>mzero</tt> to fail.
--     parseJSON _          = <tt>mzero</tt>
--   </pre>
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord
--   </pre>
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a

-- | Convert a list of values to an <a>Array</a>.
array :: ToJSON a => [a] -> Value

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | Construct a <a>Pair</a> from a key and a value.
(.=) :: ToJSON a => Text -> a -> Pair

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>empty</a> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use '(.:?)' instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | jsonOrRedirect simplifies the scenario where a POST handler sends a
--   different response based on Accept headers:
--   
--   <ol>
--   <li>200 with JSON data if the client prefers <tt>application/json</tt>
--   (e.g. AJAX, see <tt>acceptsJSON</tt>).<ol><li>3xx otherwise, following
--   the PRG pattern.</li></ol></li>
--   </ol>
jsonOrRedirect :: (MonadHandler m, ToJSON a) => Route (HandlerSite m) -> a -> m Value

-- | Returns <tt>True</tt> if the client prefers <tt>application/json</tt>
--   as indicated by the <tt>Accept</tt> HTTP header.
acceptsJson :: MonadHandler m => m Bool


-- | This is designed to be used as
--   
--   <pre>
--   qualified import Yesod.Core.Unsafe as Unsafe
--   </pre>
--   
--   This serves as a reminder that the functions are unsafe to use in many
--   situations.
module Yesod.Core.Unsafe

-- | Run a <a>HandlerT</a> completely outside of Yesod. This function comes
--   with many caveats and you shouldn't use it unless you fully understand
--   what it's doing and how it works.
--   
--   As of now, there's only one reason to use this function at all: in
--   order to run unit tests of functions inside <a>HandlerT</a> but that
--   aren't easily testable with a full HTTP request. Even so, it's better
--   to use <tt>wai-test</tt> or <tt>yesod-test</tt> instead of using this
--   function.
--   
--   This function will create a fake HTTP request (both <tt>wai</tt>'s
--   <a>Request</a> and <tt>yesod</tt>'s <a>Request</a>) and feed it to the
--   <tt>HandlerT</tt>. The only useful information the <tt>HandlerT</tt>
--   may get from the request is the session map, which you must supply as
--   argument to <tt>runFakeHandler</tt>. All other fields contain fake
--   information, which means that they can be accessed but won't have any
--   useful information. The response of the <tt>HandlerT</tt> is
--   completely ignored, including changes to the session, cookies or
--   headers. We only return you the <tt>HandlerT</tt>'s return value.
runFakeHandler :: (Yesod site, MonadIO m) => SessionMap -> (site -> Logger) -> site -> HandlerT site IO a -> m (Either ErrorResponse a)

-- | designed to be used as
--   
--   <pre>
--   unsafeHandler = Unsafe.fakeHandlerGetLogger appLogger
--   </pre>
fakeHandlerGetLogger :: (Yesod site, MonadIO m) => (site -> Logger) -> site -> HandlerT site IO a -> m a

module Yesod.Core.Dispatch

-- | A quasi-quoter to parse a string into a list of <a>Resource</a>s.
--   Checks for overlapping routes, failing if present; use
--   <a>parseRoutesNoCheck</a> to skip the checking. See documentation site
--   for details on syntax.
parseRoutes :: QuasiQuoter

-- | Same as <a>parseRoutes</a>, but performs no overlap checking.
parseRoutesNoCheck :: QuasiQuoter
parseRoutesFile :: FilePath -> Q Exp
parseRoutesFileNoCheck :: FilePath -> Q Exp

-- | Generates URL datatype and site function for the given
--   <a>Resource</a>s. This is used for creating sites, <i>not</i>
--   subsites. See <tt>mkYesodSub</tt> for the latter. Use
--   <a>parseRoutes</a> to create the <a>Resource</a>s.
mkYesod :: String -> [ResourceTree String] -> Q [Dec]

-- | Sometimes, you will want to declare your routes in one file and define
--   your handlers elsewhere. For example, this is the only way to break up
--   a monolithic file into smaller parts. Use this function, paired with
--   <a>mkYesodDispatch</a>, to do just that.
mkYesodData :: String -> [ResourceTree String] -> Q [Dec]
mkYesodSubData :: String -> [ResourceTree String] -> Q [Dec]

-- | See <a>mkYesodData</a>.
mkYesodDispatch :: String -> [ResourceTree String] -> Q [Dec]
mkYesodSubDispatch :: [ResourceTree a] -> Q Exp
class PathPiece s
fromPathPiece :: PathPiece s => Text -> Maybe s
toPathPiece :: PathPiece s => s -> Text
class PathMultiPiece s
fromPathMultiPiece :: PathMultiPiece s => [Text] -> Maybe s
toPathMultiPiece :: PathMultiPiece s => s -> [Text]
type Texts = [Text]

-- | Same as <a>toWaiAppPlain</a>, but provides a default set of
--   middlewares. This set may change with future releases, but currently
--   covers:
--   
--   <ul>
--   <li>Logging</li>
--   <li>GZIP compression</li>
--   <li>Automatic HEAD method handling</li>
--   <li>Request method override with the _method query string
--   parameter</li>
--   <li>Accept header override with the _accept query string
--   parameter</li>
--   </ul>
toWaiApp :: YesodDispatch site => site -> IO Application

-- | Convert the given argument into a WAI application, executable with any
--   WAI handler. This function will provide no middlewares; if you want
--   commonly used middlewares, please use <a>toWaiApp</a>.
toWaiAppPlain :: YesodDispatch site => site -> IO Application

-- | A convenience method to run an application using the Warp webserver on
--   the specified port. Automatically calls <a>toWaiApp</a>. Provides a
--   default set of middlewares. This set may change at any point without a
--   breaking version number. Currently, it includes:
--   
--   If you need more fine-grained control of middlewares, please use
--   <a>toWaiApp</a> directly.
--   
--   Since 1.2.0
warp :: YesodDispatch site => Int -> site -> IO ()

-- | Deprecated synonym for <a>warp</a>.

-- | <i>Deprecated: Please use warp instead</i>
warpDebug :: YesodDispatch site => Int -> site -> IO ()

-- | Runs your application using default middlewares (i.e., via
--   <a>toWaiApp</a>). It reads port information from the PORT environment
--   variable, as used by tools such as Keter and the FP Complete School of
--   Haskell.
--   
--   Note that the exact behavior of this function may be modified slightly
--   over time to work correctly with external tools, without a change to
--   the type signature.
warpEnv :: YesodDispatch site => site -> IO ()

-- | A default set of middlewares.
--   
--   Since 1.2.0
mkDefaultMiddlewares :: Logger -> IO Middleware

-- | All of the default middlewares, excluding logging.
--   
--   Since 1.2.12
defaultMiddlewaresNoLogging :: Middleware

-- | Wrap up a normal WAI application as a Yesod subsite.
newtype WaiSubsite
WaiSubsite :: Application -> WaiSubsite
runWaiSubsite :: WaiSubsite -> Application

-- | A helper function for creating YesodSubDispatch instances, used by the
--   internal generated code. This function has been exported since 1.4.11.
--   It promotes a subsite handler to a wai application.
subHelper :: Monad m => HandlerT child (HandlerT parent m) TypedContent -> YesodSubRunnerEnv child parent (HandlerT parent m) -> Maybe (Route child) -> Application

module Yesod.Core

-- | Define settings for a Yesod applications. All methods have intelligent
--   defaults, and therefore no implementation is required.
class RenderRoute site => Yesod site where approot = ApprootRelative errorHandler = defaultErrorHandler defaultLayout w = do { p <- widgetToPageContent w; mmsg <- getMessage; withUrlRenderer (\ _render_aIu7 -> do { id ((preEscapedText . pack) "<!DOCTYPE html>\n\ \<html><head><title>"); id (toHtml (pageTitle p)); id ((preEscapedText . pack) "</title>"); asHtmlUrl (pageHead p) _render_aIu7; id ((preEscapedText . pack) "</head><body>"); maybeH mmsg (\ msg_aIu8 -> do { id ((preEscapedText . pack) "<p class=\"message\">"); id (toHtml msg_aIu8); id ((preEscapedText . pack) "</p>") }) Nothing; asHtmlUrl (pageBody p) _render_aIu7; id ((preEscapedText . pack) "</body></html>") }) } urlRenderOverride _ _ = Nothing isAuthorized _ _ = return Authorized isWriteRequest _ = do { wai <- waiRequest; return $ requestMethod wai `notElem` ["GET", "HEAD", "OPTIONS", "TRACE"] } authRoute _ = Nothing cleanPath _ s = if corrected == s then Right $ map dropDash s else Left corrected where corrected = filter (not . null) s dropDash t | all (== '-') t = drop 1 t | otherwise = t joinPath _ ar pieces' qs' = fromText ar `mappend` encodePath pieces qs where pieces = if null pieces' then [""] else map addDash pieces' qs = map (encodeUtf8 *** go) qs' go "" = Nothing go x = Just $ encodeUtf8 x addDash t | all (== '-') t = cons '-' t | otherwise = t addStaticContent _ _ _ = return Nothing maximumContentLength _ _ = Just $ 2 * 1024 * 1024 makeLogger _ = defaultMakeLogger messageLoggerSource site = defaultMessageLoggerSource $ shouldLogIO site jsLoader _ = BottomOfBody makeSessionBackend _ = fmap Just $ defaultClientSessionBackend 120 defaultKeyFile fileUpload _ (KnownLength size) | size <= 50000 = FileUploadMemory lbsBackEnd fileUpload _ _ = FileUploadDisk tempFileBackEnd shouldLog _ = defaultShouldLog shouldLogIO a b c = return (shouldLog a b c) yesodMiddleware = defaultYesodMiddleware yesodWithInternalState _ _ = bracket createInternalState closeInternalState
approot :: Yesod site => Approot site
errorHandler :: Yesod site => ErrorResponse -> HandlerT site IO TypedContent
defaultLayout :: Yesod site => WidgetT site IO () -> HandlerT site IO Html
urlRenderOverride :: Yesod site => site -> Route site -> Maybe Builder
isAuthorized :: Yesod site => Route site -> Bool -> HandlerT site IO AuthResult
isWriteRequest :: Yesod site => Route site -> HandlerT site IO Bool
authRoute :: Yesod site => site -> Maybe (Route site)
cleanPath :: Yesod site => site -> [Text] -> Either [Text] [Text]
joinPath :: Yesod site => site -> Text -> [Text] -> [(Text, Text)] -> Builder
addStaticContent :: Yesod site => Text -> Text -> ByteString -> HandlerT site IO (Maybe (Either Text (Route site, [(Text, Text)])))
maximumContentLength :: Yesod site => site -> Maybe (Route site) -> Maybe Word64
makeLogger :: Yesod site => site -> IO Logger
messageLoggerSource :: Yesod site => site -> Logger -> Loc -> LogSource -> LogLevel -> LogStr -> IO ()
jsLoader :: Yesod site => site -> ScriptLoadPosition site
makeSessionBackend :: Yesod site => site -> IO (Maybe SessionBackend)
fileUpload :: Yesod site => site -> RequestBodyLength -> FileUpload
shouldLog :: Yesod site => site -> LogSource -> LogLevel -> Bool
shouldLogIO :: Yesod site => site -> LogSource -> LogLevel -> IO Bool
yesodMiddleware :: (Yesod site, ToTypedContent res) => HandlerT site IO res -> HandlerT site IO res
yesodWithInternalState :: Yesod site => site -> Maybe (Route site) -> (InternalState -> IO a) -> IO a

-- | This class is automatically instantiated when you use the template
--   haskell mkYesod function. You should never need to deal with it
--   directly.
class Yesod site => YesodDispatch site
yesodDispatch :: YesodDispatch site => YesodRunnerEnv site -> Application
class YesodSubDispatch sub m
yesodSubDispatch :: YesodSubDispatch sub m => YesodSubRunnerEnv sub (HandlerSite m) m -> Application
class Eq (Route a) => RenderRoute a where data family Route a
renderRoute :: RenderRoute a => Route a -> ([Text], [(Text, Text)])
class RenderRoute a => ParseRoute a
parseRoute :: ParseRoute a => ([Text], [(Text, Text)]) -> Maybe (Route a)
class RenderRoute a => RouteAttrs a
routeAttrs :: RouteAttrs a => Route a -> Set Text

-- | A type-safe, concise method of creating breadcrumbs for pages. For
--   each resource, you declare the title of the page and the parent
--   resource (if present).
class YesodBreadcrumbs site
breadcrumb :: YesodBreadcrumbs site => Route site -> HandlerT site IO (Text, Maybe (Route site))

-- | Gets the title of the current page and the hierarchy of parent pages,
--   along with their respective titles.
breadcrumbs :: YesodBreadcrumbs site => HandlerT site IO (Text, [(Route site, Text)])

-- | How to determine the root of the application for constructing URLs.
--   
--   Note that future versions of Yesod may add new constructors without
--   bumping the major version number. As a result, you should <i>not</i>
--   pattern match on <tt>Approot</tt> values.
data Approot master

-- | No application root.
ApprootRelative :: Approot master
ApprootStatic :: !Text -> Approot master
ApprootMaster :: !(master -> Text) -> Approot master
ApprootRequest :: !(master -> Request -> Text) -> Approot master
data FileUpload
FileUploadMemory :: !(BackEnd ByteString) -> FileUpload
FileUploadDisk :: !(InternalState -> BackEnd FilePath) -> FileUpload
FileUploadSource :: !(BackEnd (Source (ResourceT IO) ByteString)) -> FileUpload

-- | Responses to indicate some form of an error occurred.
data ErrorResponse
NotFound :: ErrorResponse
InternalError :: Text -> ErrorResponse
InvalidArgs :: [Text] -> ErrorResponse
NotAuthenticated :: ErrorResponse
PermissionDenied :: Text -> ErrorResponse
BadMethod :: Method -> ErrorResponse

-- | Return the same URL if the user is authorized to see it.
--   
--   Built on top of <a>isAuthorized</a>. This is useful for building page
--   that only contain links to pages the user is allowed to see.
maybeAuthorized :: Yesod site => Route site -> Bool -> HandlerT site IO (Maybe (Route site))

-- | Convert a widget to a <a>PageContent</a>.
widgetToPageContent :: (Eq (Route site), Yesod site) => WidgetT site IO () -> HandlerT site IO (PageContent (Route site))

-- | The default error handler for <a>errorHandler</a>.
defaultErrorHandler :: Yesod site => ErrorResponse -> HandlerT site IO TypedContent

-- | Default implementation of <a>yesodMiddleware</a>. Adds the response
--   header "Vary: Accept, Accept-Language" and performs authorization
--   checks.
--   
--   Since 1.2.0
defaultYesodMiddleware :: Yesod site => HandlerT site IO res -> HandlerT site IO res

-- | Check if a given request is authorized via <a>isAuthorized</a> and
--   <a>isWriteRequest</a>.
--   
--   Since 1.2.0
authorizationCheck :: Yesod site => HandlerT site IO ()
data AuthResult
Authorized :: AuthResult
AuthenticationRequired :: AuthResult
Unauthorized :: Text -> AuthResult

-- | Return an <a>Unauthorized</a> value, with the given i18n message.
unauthorizedI :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => msg -> m AuthResult

-- | Default implementation of <a>makeLogger</a>. Sends to stdout and
--   automatically flushes on each write.
--   
--   Since 1.4.10
defaultMakeLogger :: IO Logger

-- | Default implementation of <a>messageLoggerSource</a>. Checks if the
--   message should be logged using the provided function, and if so,
--   formats using <a>formatLogMessage</a>. You can use
--   <a>defaultShouldLogIO</a> as the provided function.
--   
--   Since 1.4.10
defaultMessageLoggerSource :: (LogSource -> LogLevel -> IO Bool) -> Logger -> Loc -> LogSource -> LogLevel -> LogStr -> IO ()

-- | Default implementation of <a>shouldLog</a>. Logs everything at or
--   above <a>LevelInfo</a>.
--   
--   Since 1.4.10
defaultShouldLog :: LogSource -> LogLevel -> Bool

-- | A default implementation of <a>shouldLogIO</a> that can be used with
--   <a>defaultMessageLoggerSource</a>. Just uses <a>defaultShouldLog</a>.
--   
--   Since 1.4.10
defaultShouldLogIO :: LogSource -> LogLevel -> IO Bool

-- | Default formatting for log messages. When you use the template haskell
--   logging functions for to log with information about the source
--   location, that information will be appended to the end of the log.
--   When you use the non-TH logging functions, like <tt>logDebugN</tt>,
--   this function does not include source information. This currently
--   works by checking to see if the package name is the string
--   "&lt;unknown&gt;". This is a hack, but it removes some of the visual
--   clutter from non-TH logs.
--   
--   Since 1.4.10
formatLogMessage :: IO ZonedDate -> Loc -> LogSource -> LogLevel -> LogStr -> IO LogStr
data LogLevel :: *
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: Text -> LogLevel

-- | Generates a function that takes a <a>Text</a> and logs a
--   <a>LevelDebug</a> message. Usage:
--   
--   <pre>
--   $(logDebug) "This is a debug log message"
--   </pre>
logDebug :: Q Exp

-- | See <a>logDebug</a>
logInfo :: Q Exp

-- | See <a>logDebug</a>
logWarn :: Q Exp

-- | See <a>logDebug</a>
logError :: Q Exp

-- | Generates a function that takes a <a>Text</a> and logs a
--   <a>LevelOther</a> message. Usage:
--   
--   <pre>
--   $(logOther "My new level") "This is a log message"
--   </pre>
logOther :: Text -> Q Exp

-- | Generates a function that takes a <a>LogSource</a> and <a>Text</a> and
--   logs a <a>LevelDebug</a> message. Usage:
--   
--   <pre>
--   $logDebugS "SomeSource" "This is a debug log message"
--   </pre>
logDebugS :: Q Exp

-- | See <a>logDebugS</a>
logInfoS :: Q Exp

-- | See <a>logDebugS</a>
logWarnS :: Q Exp

-- | See <a>logDebugS</a>
logErrorS :: Q Exp

-- | Generates a function that takes a <a>LogSource</a>, a level name and a
--   <a>Text</a> and logs a <a>LevelOther</a> message. Usage:
--   
--   <pre>
--   $logOtherS "SomeSource" "My new level" "This is a log message"
--   </pre>
logOtherS :: Q Exp
newtype SessionBackend
SessionBackend :: (Request -> IO (SessionMap, SaveSession)) -> SessionBackend

-- | Return the session data and a function to save the session
sbLoadSession :: SessionBackend -> Request -> IO (SessionMap, SaveSession)

-- | Customize the cookies used by the session backend. You may use this
--   function on your definition of <a>makeSessionBackend</a>.
--   
--   For example, you could set the cookie domain so that it would work
--   across many subdomains:
--   
--   <pre>
--   makeSessionBackend site =
--       (fmap . fmap) (customizeSessionCookies addDomain) ...
--     where
--       addDomain cookie = cookie { <a>setCookieDomain</a> = Just ".example.com" }
--   </pre>
--   
--   Default: Do not customize anything (<a>id</a>).
customizeSessionCookies :: (SetCookie -> SetCookie) -> (SessionBackend -> SessionBackend)
defaultClientSessionBackend :: Int -> FilePath -> IO SessionBackend

-- | Create a <tt>SessionBackend</tt> which reads the session key from the
--   named environment variable.
--   
--   This can be useful if:
--   
--   <ol>
--   <li>You can't rely on a persistent file system (e.g. Heroku)</li>
--   <li>Your application is open source (e.g. you can't commit the
--   key)</li>
--   </ol>
--   
--   By keeping a consistent value in the environment variable, your users
--   will have consistent sessions without relying on the file system.
--   
--   Note: A suitable value should only be obtained in one of two ways:
--   
--   <ol>
--   <li>Run this code without the variable set, a value will be generated
--   and printed on <tt><i>dev</i>stdout/</tt></li>
--   <li>Use <tt>clientsession-generate</tt></li>
--   </ol>
--   
--   Since 1.4.5
envClientSessionBackend :: Int -> String -> IO SessionBackend
clientSessionBackend :: Key -> IO ClientSessionDateCache -> SessionBackend

-- | Defends against session hijacking by setting the secure bit on session
--   cookies so that browsers will not transmit them over http. With this
--   setting on, it follows that the server will regard requests made over
--   http as sessionless, because the session cookie will not be included
--   in the request. Use this as part of a total security measure which
--   also includes disabling HTTP traffic to the site or issuing redirects
--   from HTTP urls, and composing <a>sslOnlyMiddleware</a> with the site's
--   <a>yesodMiddleware</a>.
--   
--   Since 1.4.7
sslOnlySessions :: IO (Maybe SessionBackend) -> IO (Maybe SessionBackend)

-- | Apply a Strict-Transport-Security header with the specified timeout to
--   all responses so that browsers will rewrite all http links to https
--   until the timeout expires. For security, the max-age of the STS header
--   should always equal or exceed the client sessions timeout. This
--   defends against hijacking attacks on the sessions of users who attempt
--   to access the site using an http url. This middleware makes a site
--   functionally inaccessible over vanilla http in all standard browsers.
--   
--   Since 1.4.7
sslOnlyMiddleware :: Yesod site => Int -> HandlerT site IO res -> HandlerT site IO res
clientSessionDateCacher :: NominalDiffTime -> IO (IO ClientSessionDateCache, IO ())
loadClientSession :: Key -> IO ClientSessionDateCache -> ByteString -> Request -> IO (SessionMap, SaveSession)

-- | Headers to be added to a <tt>Result</tt>.
data Header
AddCookie :: SetCookie -> Header
DeleteCookie :: ByteString -> ByteString -> Header
Header :: ByteString -> ByteString -> Header
data ScriptLoadPosition master
BottomOfBody :: ScriptLoadPosition master
BottomOfHeadBlocking :: ScriptLoadPosition master
BottomOfHeadAsync :: (BottomOfHeadAsync master) -> ScriptLoadPosition master
type BottomOfHeadAsync master = [Text] -> Maybe (HtmlUrl (Route master)) -> (HtmlUrl (Route master))
class MonadResource m => MonadHandler m where type family HandlerSite m
liftHandlerT :: MonadHandler m => HandlerT (HandlerSite m) IO a -> m a
class MonadHandler m => MonadWidget m
liftWidgetT :: MonadWidget m => WidgetT (HandlerSite m) IO a -> m a
getRouteToParent :: Monad m => HandlerT child (HandlerT parent m) (Route child -> Route parent)
defaultLayoutSub :: Yesod parent => WidgetT child IO () -> HandlerT child (HandlerT parent IO) Html
yesodVersion :: String
yesodRender :: Yesod y => y -> ResolvedApproot -> Route y -> [(Text, Text)] -> Text

-- | <i>Deprecated: import runFakeHandler from Yesod.Core.Unsafe</i>
runFakeHandler :: (Yesod site, MonadIO m) => SessionMap -> (site -> Logger) -> site -> HandlerT site IO a -> m (Either ErrorResponse a)
newtype LiteApp
LiteApp :: (Method -> [Text] -> Maybe (LiteHandler TypedContent)) -> LiteApp
unLiteApp :: LiteApp -> Method -> [Text] -> Maybe (LiteHandler TypedContent)
type LiteHandler = HandlerT LiteApp IO
type LiteWidget = WidgetT LiteApp IO
liteApp :: Writer LiteApp () -> LiteApp
dispatchTo :: ToTypedContent a => LiteHandler a -> Writer LiteApp ()
onMethod :: Method -> Writer LiteApp () -> Writer LiteApp ()
onStatic :: Text -> Writer LiteApp () -> Writer LiteApp ()
withDynamic :: PathPiece p => (p -> Writer LiteApp ()) -> Writer LiteApp ()
withDynamicMulti :: PathMultiPiece ps => (ps -> Writer LiteApp ()) -> Writer LiteApp ()
yesodRunner :: (ToTypedContent res, Yesod site) => HandlerT site IO res -> YesodRunnerEnv site -> Maybe (Route site) -> Application
putTime :: UTCTime -> Put
getTime :: Get UTCTime

-- | Format a <a>UTCTime</a> in W3 format.
formatW3 :: UTCTime -> Text

-- | Format as per RFC 1123.
formatRFC1123 :: UTCTime -> Text

-- | Format as per RFC 822.
formatRFC822 :: UTCTime -> Text

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: (* -> *) -> * -> *)
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)
liftIO :: MonadIO m => IO a -> m a
class (Applicative b, Applicative m, Monad b, Monad m) => MonadBase (b :: * -> *) (m :: * -> *) | m -> b
liftBase :: MonadBase b m => b  -> m 
class MonadBase b m => MonadBaseControl (b :: * -> *) (m :: * -> *) | m -> b

-- | A <tt>Monad</tt> which allows for safe resource allocation. In theory,
--   any monad transformer stack included a <tt>ResourceT</tt> can be an
--   instance of <tt>MonadResource</tt>.
--   
--   Note: <tt>runResourceT</tt> has a requirement for a
--   <tt>MonadBaseControl IO m</tt> monad, which allows control operations
--   to be lifted. A <tt>MonadResource</tt> does not have this requirement.
--   This means that transformers such as <tt>ContT</tt> can be an instance
--   of <tt>MonadResource</tt>. However, the <tt>ContT</tt> wrapper will
--   need to be unwrapped before calling <tt>runResourceT</tt>.
--   
--   Since 0.3.0
class (MonadThrow m, MonadIO m, Applicative m, MonadBase IO m) => MonadResource (m :: * -> *)
liftResourceT :: MonadResource m => ResourceT IO a -> m a

-- | A <tt>Monad</tt> which has the ability to log messages in some manner.
class Monad m => MonadLogger (m :: * -> *)

-- | The WAI application.
--   
--   Note that, since WAI 3.0, this type is structured in continuation
--   passing style to allow for proper safe resource handling. This was
--   handled in the past via other means (e.g., <tt>ResourceT</tt>). As a
--   demonstration:
--   
--   <pre>
--   app :: Application
--   app req respond = bracket_
--       (putStrLn "Allocating scarce resource")
--       (putStrLn "Cleaning up")
--       (respond $ responseLBS status200 [] "Hello World")
--   </pre>
type Application = Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
showIntegral :: Integral a => a -> String
readIntegral :: Num a => String -> Maybe a
hamlet :: QuasiQuoter
shamlet :: QuasiQuoter
xhamlet :: QuasiQuoter

-- | A function generating an <a>Html</a> given a URL-rendering function.
type HtmlUrl url = Render url -> Html
julius :: QuasiQuoter

-- | Return type of template-reading functions.
type JavascriptUrl url = (url -> [(Text, Text)] -> Text) -> Javascript

-- | render with route interpolation. If using this module standalone,
--   apart from type-safe routes, a dummy renderer can be used:
--   
--   <pre>
--   renderJavascriptUrl (\_ _ -&gt; undefined) javascriptUrl
--   </pre>
--   
--   When using Yesod, a renderer is generated for you, which can be
--   accessed within the GHandler monad: <a>getUrlRenderParams</a>.
renderJavascriptUrl :: (url -> [(Text, Text)] -> Text) -> JavascriptUrl url -> Text
cassius :: QuasiQuoter

-- | <pre>
--   &gt;&gt;&gt; renderCss ([lucius|foo{bar:baz}|] undefined)
--   "foo{bar:baz}"
--   </pre>
lucius :: QuasiQuoter
type CssUrl url = (url -> [(Text, Text)] -> Text) -> Css
renderCssUrl :: (url -> [(Text, Text)] -> Text) -> CssUrl url -> Text
