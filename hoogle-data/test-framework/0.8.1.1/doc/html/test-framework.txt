-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Framework for running and organising tests, with HUnit and QuickCheck support
--   
--   Allows tests such as QuickCheck properties and HUnit test cases to be
--   assembled into test groups, run in parallel (but reported in
--   deterministic order, to aid diff interpretation) and filtered and
--   controlled by command line options. All of this comes with colored
--   test output, progress reporting and test statistics output.
@package test-framework
@version 0.8.1.1

module Test.Framework.Runners.TestPattern
data TestPattern
parseTestPattern :: String -> TestPattern
testPatternMatches :: TestPattern -> [String] -> Bool
instance Eq Token
instance Read TestPattern

module Test.Framework.Seed
data Seed
FixedSeed :: Int -> Seed
RandomSeed :: Seed

-- | Given a <a>Seed</a>, returns a new random number generator based on
--   that seed and the actual numeric seed that was used to build that
--   generator, so it can be recreated.
newSeededStdGen :: Seed -> IO (StdGen, Int)
newStdGenWithKnownSeed :: IO (StdGen, Int)
instance Read Seed
instance Show Seed

module Test.Framework.Options
type TestOptions = TestOptions' Maybe
type CompleteTestOptions = TestOptions' K
data TestOptions' f
TestOptions :: f Seed -> f Int -> f Int -> f Int -> f Int -> f (Maybe Int) -> TestOptions' f

-- | Seed that should be used to create random numbers for generated tests
topt_seed :: TestOptions' f -> f Seed

-- | Maximum number of tests to generate when using something like
--   QuickCheck
topt_maximum_generated_tests :: TestOptions' f -> f Int

-- | Maximum number of unsuitable tests to consider before giving up when
--   using something like QuickCheck
topt_maximum_unsuitable_generated_tests :: TestOptions' f -> f Int

-- | Maximum size of generated tests when using something like QuickCheck
topt_maximum_test_size :: TestOptions' f -> f Int

-- | Maximum depth of generated tests when using something like SmallCheck
topt_maximum_test_depth :: TestOptions' f -> f Int

-- | The number of microseconds to run tests for before considering them a
--   failure
topt_timeout :: TestOptions' f -> f (Maybe Int)
instance Monoid (TestOptions' Maybe)

module Test.Framework.Runners.Options
data ColorMode
ColorAuto :: ColorMode
ColorNever :: ColorMode
ColorAlways :: ColorMode
type RunnerOptions = RunnerOptions' Maybe
type CompleteRunnerOptions = RunnerOptions' K
data RunnerOptions' f
RunnerOptions :: f Int -> f TestOptions -> f [TestPattern] -> f (Maybe FilePath) -> f Bool -> f ColorMode -> f Bool -> f Bool -> RunnerOptions' f
ropt_threads :: RunnerOptions' f -> f Int
ropt_test_options :: RunnerOptions' f -> f TestOptions
ropt_test_patterns :: RunnerOptions' f -> f [TestPattern]
ropt_xml_output :: RunnerOptions' f -> f (Maybe FilePath)
ropt_xml_nested :: RunnerOptions' f -> f Bool
ropt_color_mode :: RunnerOptions' f -> f ColorMode
ropt_hide_successes :: RunnerOptions' f -> f Bool
ropt_list_only :: RunnerOptions' f -> f Bool
data TestPattern
instance Monoid (RunnerOptions' Maybe)


-- | This module exports everything that you need to be able to create your
--   own framework test provider. To create a provider you need to:
--   
--   <ul>
--   <li>Create an instance of the <a>Testlike</a> class</li>
--   <li>Create an instance of the <a>TestResultlike</a> class</li>
--   <li>Expose a function that lets people construct <a>Test</a> values
--   using your new instances</li>
--   </ul>
module Test.Framework.Providers.API

-- | Something like the result of a test: works in concert with
--   <a>Testlike</a>. The type parameters are the type that is used for
--   progress reports and the type of the final output of the test
--   respectively.
class (Show i, Show r) => TestResultlike i r | r -> i
testSucceeded :: TestResultlike i r => r -> Bool

-- | Something test-like in its behaviour. The type parameters are the type
--   that is used for progress reports, the type of the final output of the
--   test and the data type encapsulating the whole potential to do a test
--   respectively.
class TestResultlike i r => Testlike i r t | t -> i r, r -> i
runTest :: Testlike i r t => CompleteTestOptions -> t -> IO (i :~> r, IO ())
testTypeName :: Testlike i r t => t -> TestTypeName

-- | Test names or descriptions. These are shown to the user
type TestName = String

-- | The name of a type of test, such as <a>Properties</a> or "Test Cases".
--   Tests of types of the same names will be grouped together in the test
--   run summary.
type TestTypeName = String

-- | Main test data type: builds up a list of tests to be run. Users should
--   use the utility functions in e.g. the test-framework-hunit and
--   test-framework-quickcheck packages to create instances of <a>Test</a>,
--   and then build them up into testsuites by using <a>testGroup</a> and
--   lists.
--   
--   For an example of how to use test-framework, please see
--   <a>http://github.com/batterseapower/test-framework/raw/master/example/Test/Framework/Example.lhs</a>
data Test

-- | A single test of some particular type
Test :: TestName -> t -> Test

-- | Assemble a number of tests into a cohesive group
TestGroup :: TestName -> [Test] -> Test

-- | Add some options to child tests
PlusTestOptions :: TestOptions -> Test -> Test

-- | Convenience for creating tests from an <a>IO</a> action, with cleanup
BuildTestBracketed :: (IO (Test, IO ())) -> Test

-- | Assemble a number of tests into a cohesive group
testGroup :: TestName -> [Test] -> Test

-- | Add some options to child tests
plusTestOptions :: TestOptions -> Test -> Test

-- | Convenience for creating tests from an <a>IO</a> action
buildTest :: IO Test -> Test

-- | Convenience for creating tests from an <a>IO</a> action, with a
--   cleanup handler for when tests are finished
buildTestBracketed :: IO (Test, IO ()) -> Test
data MutuallyExcluded t
ME :: (MVar ()) -> t -> MutuallyExcluded t

-- | Mark all tests in this portion of the tree as mutually exclusive, so
--   only one runs at a time
mutuallyExclusive :: Test -> Test
data (:~>) i f
Finished :: f -> (:~>) i f
Improving :: i -> (i :~> f) -> (:~>) i f
bimapImproving :: (a -> c) -> (b -> d) -> (a :~> b) -> (c :~> d)
improvingLast :: (a :~> b) -> b
consumeImproving :: (a :~> b) -> [(a :~> b)]
data ImprovingIO i f a
yieldImprovement :: i -> ImprovingIO i f ()
runImprovingIO :: ImprovingIO i f f -> IO (i :~> f, IO ())
tunnelImprovingIO :: ImprovingIO i f (ImprovingIO i f a -> IO a)
liftIO :: IO a -> ImprovingIO i f a

-- | Given a number of microseconds and an improving IO action, run that
--   improving IO action only for at most the given period before giving
--   up. See also <a>timeout</a>.
timeoutImprovingIO :: Int -> ImprovingIO i f a -> ImprovingIO i f (Maybe a)

-- | As <a>timeoutImprovingIO</a>, but don't bother applying a timeout to
--   the action if <tt>Nothing</tt> is given as the number of microseconds
--   to apply the time out for.
maybeTimeoutImprovingIO :: Maybe Int -> ImprovingIO i f a -> ImprovingIO i f (Maybe a)
newtype K a
K :: a -> K a
unK :: K a -> a
secondsToMicroseconds :: Num a => a -> a
microsecondsToPicoseconds :: Num a => a -> a
listToMaybeLast :: [a] -> Maybe a
mappendBy :: Monoid b => (a -> b) -> a -> a -> b
orElse :: Maybe a -> a -> a
onLeft :: (a -> c) -> (a, b) -> (c, b)
onRight :: (b -> c) -> (a, b) -> (a, c)

-- | Like <a>unlines</a>, but does not append a trailing newline if there
--   is at least one line. For example:
--   
--   <pre>
--   unlinesConcise ["A", "B"] == "A\nB"
--   unlinesConcise [] == ""
--   </pre>
--   
--   Whereas:
--   
--   <pre>
--   unlines ["A", "B"] == "A\nB\n"
--   unlines [] == ""
--   </pre>
--   
--   This is closer to the behaviour of <a>unwords</a>, which does not
--   append a trailing space.
unlinesConcise :: [String] -> String
mapAccumLM :: Monad m => (acc -> x -> m (acc, y)) -> acc -> [x] -> m (acc, [y])
padRight :: Int -> String -> String
dropLast :: Int -> [a] -> [a]


-- | This module exports everything that you need to be able to create your
--   own test runner.
module Test.Framework.Runners.API

-- | <a>TestRunner</a> class simplifies folding a <a>Test</a>. You need to
--   specify the important semantic actions by instantiating this class,
--   and <a>runTestTree</a> will take care of recursion and test filtering.
class TestRunner b
runSimpleTest :: (TestRunner b, Testlike i r t, Typeable t) => TestOptions -> TestName -> t -> b
skipTest :: TestRunner b => b
runIOTest :: TestRunner b => IO (b, IO ()) -> b
runGroup :: TestRunner b => TestName -> [b] -> b

-- | Run the test tree using a <a>TestRunner</a>
runTestTree :: TestRunner b => TestOptions -> [TestPattern] -> Test -> b

module Test.Framework.Runners.Console
defaultMain :: [Test] -> IO ()

-- | A version of <a>defaultMain</a> that lets you ignore the command line
--   arguments in favour of another list of <a>String</a>s.
defaultMainWithArgs :: [Test] -> [String] -> IO ()

-- | A version of <a>defaultMain</a> that lets you ignore the command line
--   arguments in favour of an explicit set of <a>RunnerOptions</a>.
defaultMainWithOpts :: [Test] -> RunnerOptions -> IO ()

-- | <tt>Nothing</tt> signifies that usage information should be displayed.
--   <tt>Just</tt> simply gives us the contribution to overall options by
--   the command line option.
type SuppliedRunnerOptions = Maybe RunnerOptions

-- | Options understood by test-framework. This can be used to add more
--   options to the tester executable.
optionsDescription :: [OptDescr SuppliedRunnerOptions]

-- | Parse the specified command line arguments into a <a>RunnerOptions</a>
--   and some remaining arguments, or return a reason as to why we can't.
interpretArgs :: [String] -> IO (Either String (RunnerOptions, [String]))

-- | A version of <a>interpretArgs</a> that ends the process if it fails.
interpretArgsOrExit :: [String] -> IO RunnerOptions


-- | A generic test framework for all types of Haskell test.
--   
--   For an example of how to use test-framework, please see
--   <a>http://github.com/batterseapower/test-framework/raw/master/example/Test/Framework/Example.lhs</a>
module Test.Framework

-- | Something like the result of a test: works in concert with
--   <a>Testlike</a>. The type parameters are the type that is used for
--   progress reports and the type of the final output of the test
--   respectively.
class (Show i, Show r) => TestResultlike i r | r -> i
testSucceeded :: TestResultlike i r => r -> Bool

-- | Something test-like in its behaviour. The type parameters are the type
--   that is used for progress reports, the type of the final output of the
--   test and the data type encapsulating the whole potential to do a test
--   respectively.
class TestResultlike i r => Testlike i r t | t -> i r, r -> i
runTest :: Testlike i r t => CompleteTestOptions -> t -> IO (i :~> r, IO ())
testTypeName :: Testlike i r t => t -> TestTypeName

-- | Test names or descriptions. These are shown to the user
type TestName = String

-- | The name of a type of test, such as <a>Properties</a> or "Test Cases".
--   Tests of types of the same names will be grouped together in the test
--   run summary.
type TestTypeName = String

-- | Main test data type: builds up a list of tests to be run. Users should
--   use the utility functions in e.g. the test-framework-hunit and
--   test-framework-quickcheck packages to create instances of <a>Test</a>,
--   and then build them up into testsuites by using <a>testGroup</a> and
--   lists.
--   
--   For an example of how to use test-framework, please see
--   <a>http://github.com/batterseapower/test-framework/raw/master/example/Test/Framework/Example.lhs</a>
data Test

-- | A single test of some particular type
Test :: TestName -> t -> Test

-- | Assemble a number of tests into a cohesive group
TestGroup :: TestName -> [Test] -> Test

-- | Add some options to child tests
PlusTestOptions :: TestOptions -> Test -> Test

-- | Convenience for creating tests from an <a>IO</a> action, with cleanup
BuildTestBracketed :: (IO (Test, IO ())) -> Test

-- | Assemble a number of tests into a cohesive group
testGroup :: TestName -> [Test] -> Test

-- | Add some options to child tests
plusTestOptions :: TestOptions -> Test -> Test

-- | Convenience for creating tests from an <a>IO</a> action
buildTest :: IO Test -> Test

-- | Convenience for creating tests from an <a>IO</a> action, with a
--   cleanup handler for when tests are finished
buildTestBracketed :: IO (Test, IO ()) -> Test
data MutuallyExcluded t
ME :: (MVar ()) -> t -> MutuallyExcluded t

-- | Mark all tests in this portion of the tree as mutually exclusive, so
--   only one runs at a time
mutuallyExclusive :: Test -> Test
