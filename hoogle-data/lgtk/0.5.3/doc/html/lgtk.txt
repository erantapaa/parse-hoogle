-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | lens-based API for Gtk
--   
--   The main interface module of LGtk is <a>LGtk</a>.
@package lgtk
@version 0.5.3


-- | Main LGtk interface.
module LGtk

-- | A class for categories. id and (.) must form a monoid.
class Category (cat :: * -> * -> *)
id :: Category cat => cat a a
(.) :: Category cat => cat b c -> cat a b -> cat a c
class Category c => Tensor (c :: * -> * -> *)
(***) :: Tensor c => c w x -> c y z -> c (w, y) (x, z)
first :: Tensor c => c w x -> c (w, z) (x, z)
second :: Tensor c => c y z -> c (w, y) (w, z)

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()
newtype Lens a b :: * -> * -> *
Lens :: (a -> Store b a) -> Lens a b
runLens :: Lens a b -> a -> Store b a

-- | build a lens out of a getter and setter
lens :: (a -> b) -> (b -> a -> a) -> Lens a b

-- | build a lens out of an isomorphism
iso :: (a -> b) -> (b -> a) -> Lens a b
runLens :: Lens a b -> a -> Store b a

-- | Gets the getter function from a lens.
getL :: Lens a b -> a -> b

-- | Gets the setter function from a lens.
setL :: Lens a b -> b -> a -> a

-- | Gets the modifier function from a lens.
modL :: Lens a b -> (b -> b) -> a -> a
fstLens :: Lens (a, b) a
sndLens :: Lens (a, b) b
listLens :: Lens (Bool, (a, [a])) [a]
maybeLens :: Lens (Bool, a) (Maybe a)
showLens :: (Show a, Read a) => Lens a String

-- | Monad morphism. Think as <tt>m</tt> is a submonad of <tt>n</tt>.
type Morph m n = forall a. m a -> n a

-- | <tt>m</tt> has a submonad <tt>(ReadPart m)</tt> which is isomorphic to
--   <a>Reader</a>.
class (Monad m, Monad (ReadPart m)) => HasReadPart m where type family ReadPart m :: * -> *
liftReadPart :: HasReadPart m => Morph (ReadPart m) m

-- | A reference <tt>(r a)</tt> is isomorphic to <tt>(<a>Lens</a> s a)</tt>
--   for some fixed state <tt>s</tt>.
--   
--   <tt>r</tt> === <tt>Lens s</tt>
class HasReadPart (RefMonad r) => Reference r where type family RefMonad r :: * -> *
readRef :: Reference r => r a -> ReadRefMonad r a
writeRef :: Reference r => r a -> a -> RefMonad r ()
lensMap :: Reference r => Lens a b -> r a -> r b
joinRef :: Reference r => ReadRefMonad r (r a) -> r a
unitRef :: Reference r => r ()
type ReadRefMonad m = ReadPart (RefMonad m)

-- | Monad for reference creation. Reference creation is not a method of
--   the <a>Reference</a> type class to make possible to create the same
--   type of references in multiple monads.
--   
--   <tt>(Extref m) === (StateT s m)</tt>, where <tt>s</tt> is an
--   extendible state.
--   
--   For basic usage examples, look into the source of
--   <tt>Control.Monad.ExtRef.Pure.Test</tt>.
class (Monad m, Reference (Ref m)) => ExtRef m where type family Ref m :: * -> * newRef = extRef unitRef $ lens (const ()) (const id)
extRef :: ExtRef m => Ref m b -> Lens a b -> a -> m (Ref m a)
newRef :: ExtRef m => a -> m (Ref m a)
type ReadRef m = ReadRefMonad (Ref m)
type WriteRef m = RefMonad (Ref m)

-- | <tt>ReadRef</tt> lifted to the reference creation class.
--   
--   Note that we do not lift <tt>WriteRef</tt> to the reference creation
--   class, which a crucial restriction in the LGtk interface; this is a
--   feature.
liftReadRef :: ExtRef m => Morph (ReadRef m) m

-- | <tt>modRef r f</tt> === <tt>liftReadPart (readRef r) &gt;&gt;=
--   writeRef r . f</tt>
modRef :: Reference r => r a -> (a -> a) -> RefMonad r ()

-- | <tt>readRef</tt> lifted to the reference creation class.
--   
--   <tt>readRef'</tt> === <tt>liftReadRef . readRef</tt>
readRef' :: ExtRef m => Ref m a -> m a

-- | Lazy monadic evaluation. In case of <tt>y &lt;- memoRead x</tt>,
--   invoking <tt>y</tt> will invoke <tt>x</tt> at most once.
--   
--   Laws:
--   
--   <ul>
--   <li><tt>(memoRead x &gt;&gt; return ())</tt> === <tt>return
--   ()</tt></li>
--   <li><tt>(memoRead x &gt;&gt;= id)</tt> === <tt>x</tt></li>
--   <li><tt>(memoRead x &gt;&gt;= y -&gt; liftM2 (,) y y)</tt> ===
--   <tt>liftM (a -&gt; (a, a)) y</tt></li>
--   <li><tt>(memoRead x &gt;&gt;= y -&gt; liftM3 (,) y y y)</tt> ===
--   <tt>liftM (a -&gt; (a, a, a)) y</tt></li>
--   <li>...</li>
--   </ul>
memoRead :: ExtRef m => m a -> m (m a)

-- | Undo-redo state transformation.
undoTr :: ExtRef m => (a -> a -> Bool) -> Ref m a -> m (ReadRef m (Maybe (WriteRef m ())), ReadRef m (Maybe (WriteRef m ())))

-- | References with inherent equivalence.
class Reference r => EqReference r
hasEffect :: EqReference r => r a -> (a -> a) -> ReadRefMonad r Bool

-- | References with inherent equivalence.
--   
--   <tt>EqRef r a</tt> === <tt>ReadRefMonad r (exist b . Eq b =&gt; (Lens
--   b a, r b))</tt>
--   
--   As a reference, <tt>(m :: EqRef r a)</tt> behaves as
--   
--   <pre>
--   joinRef $ liftM (uncurry lensMap) m
--   </pre>
data EqRef r a

-- | <tt>EqRef</tt> construction.
eqRef :: (Reference r, Eq a) => r a -> EqRef r a
newEqRef :: (ExtRef m, Eq a) => a -> m (EqRef (Ref m) a)

-- | An <tt>EqRef</tt> is a normal reference if we forget about the
--   equality.
--   
--   <tt>toRef m</tt> === <tt>joinRef $ liftM (uncurry lensMap) m</tt>
toRef :: Reference r => EqRef r a -> r a

-- | Monad for dynamic actions
class ExtRef m => EffRef m
onChange :: (EffRef m, Eq a) => Bool -> ReadRef m a -> (a -> m (m ())) -> m ()

-- | Type class for effectless, synchronous <tt>IO</tt> actions.
class Monad m => SafeIO m
getArgs :: SafeIO m => m [String]
getProgName :: SafeIO m => m String
lookupEnv :: SafeIO m => String -> m (Maybe String)

-- | Type class for IO actions.
class (EffRef m, SafeIO m, SafeIO (ReadRef m)) => EffIORef m
asyncWrite :: (EffIORef m, Eq a) => Int -> (a -> WriteRef m ()) -> a -> m ()
fileRef :: EffIORef m => FilePath -> m (Ref m (Maybe String))
putStr_ :: EffIORef m => String -> m ()
getLine_ :: EffIORef m => (String -> WriteRef m ()) -> m ()

-- | <tt>putStrLn_</tt> === <tt>putStr_ . (++ <a>n</a>)</tt>
putStrLn_ :: EffIORef m => String -> m ()

-- | Gtk widget descriptions. Construction of a <tt>(w :: forall m .
--   EffIORef m =&gt; Widget m)</tt> value is side-effect free,
--   side-effects happen at running <tt>(<a>runWidget</a> w)</tt>.
--   
--   <tt>Widget</tt> should be abstract data type, but it is also safe to
--   keep it as a type synonym because the operations of the revealed
--   implementation are hidden.
type Widget m = Widget (EffectM m) m

-- | Run a Gtk widget description.
--   
--   The widget is shown in a window and the thread enters into the Gtk
--   event cycle. It leaves the event cycle when the window is closed.
runWidget :: (forall m. EffIORef m => Widget m) -> IO ()

-- | Dynamic label.
label :: EffRef m => ReadRef m String -> Widget m

-- | Checkbox.
checkbox :: EffRef m => Ref m Bool -> Widget m

-- | Simple combo box.
combobox :: EffRef m => [String] -> Ref m Int -> Widget m

-- | Text entry.
entry :: (EffRef m, Reference r, RefMonad r ~ RefMonad (Ref m)) => r String -> Widget m

-- | Vertical composition of widgets.
vcat :: [Widget m] -> Widget m

-- | Horizontal composition of widgets.
hcat :: [Widget m] -> Widget m

-- | Low-level button.
button_ :: EffRef m => ReadRef m String -> ReadRef m Bool -> WriteRef m () -> Widget m

-- | Color
--   
--   <ul>
--   <li>Specifies a color with three integer values for red, green and
--   blue. All values range from 0 (least intense) to 65535 (highest
--   intensity).</li>
--   </ul>
data Color :: *
Color :: Word16 -> Word16 -> Word16 -> Color

-- | Notebook (tabs).
--   
--   The tabs are created lazily.
notebook :: EffRef m => [(String, Widget m)] -> Widget m

-- | Dynamic cell.
--   
--   The monadic action for inner widget creation is memoised in the first
--   monad layer.
cell_ :: (EffRef m, Eq a) => ReadRef m a -> (forall x. (Widget m -> m x) -> a -> m (m x)) -> Widget m

-- | <tt>action</tt> makes possible to do any <a>EffRef</a> action while
--   creating the widget.
action :: EffRef m => m (Widget m) -> Widget m

-- | Empty widget.
empty :: Widget m

-- | Text entry.
entryShow :: (EffRef m, Show a, Read a, Reference r, RefMonad r ~ RefMonad (Ref m)) => r a -> Widget m
button :: EffRef m => ReadRef m String -> ReadRef m (Maybe (WriteRef m ())) -> Widget m
smartButton :: (EffRef m, EqReference r, RefMonad r ~ RefMonad (Ref m)) => ReadRef m String -> r a -> (a -> a) -> Widget m

-- | Dynamic cell.
--   
--   The inner widgets are memoised.
cell :: (EffRef m, Eq a) => ReadRef m a -> (a -> Widget m) -> Widget m

-- | Dynamic cell.
--   
--   The inner widgets are not memoised.
cellNoMemo :: (EffRef m, Eq a) => ReadRef m a -> (a -> Widget m) -> Widget m

-- | Low-level button with changeable background color.
button__ :: EffRef m => ReadRef m String -> ReadRef m Bool -> ReadRef m Color -> WriteRef m () -> Widget m


-- | A generic ADT editor defined on top of the main LGtk interface,
--   <a>LGtk</a>.
module LGtk.ADTEditor

-- | Type-level lists
data List a
Nil :: List a
Cons :: a -> (List a) -> List a

-- | Heterogeneous lists
data Elems (xs :: List *)
ElemsNil :: Elems Nil
ElemsCons :: a -> Elems as -> Elems (Cons a as)

-- | Lens for editable ADTs with support of shared record fields between
--   constructors.
--   
--   Suppose we have the data type
--   
--   <pre>
--   data X
--       = X1 { a :: Int, b :: Bool }
--       | X2 { a :: Int, c :: Char }
--   </pre>
--   
--   We can build an editor which can switch between two editor for the
--   constructors. If the field <tt>a</tt> is edited in one editor, it will
--   be updated in the other.
class ADTLens a where type family ADTEls a :: List *
adtLens :: ADTLens a => ([(String, [Int])], Elems (ADTEls a), Lens (Int, Elems (ADTEls a)) a)

-- | A generic ADT editor
adtEditor :: (EffRef m, ADTLens a) => Ref m a -> m (Widget m)


-- | An editor for integers x, y, z such that x + y = z always hold and the
--   last edited value change.
module LGtk.Demos.Tri

-- | Information pieces: what is known?
data S
X :: Int -> S
Y :: Int -> S
XY :: Int -> S

-- | Getter
getX :: [S] -> Int

-- | Getter
getXY :: [S] -> Int

-- | Getter
getY :: [S] -> Int

-- | Setter
setX :: Int -> [S] -> [S]

-- | Setter
setXY :: Int -> [S] -> [S]

-- | Setter
setY :: Int -> [S] -> [S]

-- | The editor
tri :: EffRef m => Widget m


-- | An integer list editor
module LGtk.Demos.IntListEditor
intListEditor :: (EffRef m, Read a, Show a, Integral a) => (a, Bool) -> Int -> Ref m [(a, Bool)] -> Ref m Bool -> Widget m
listEditor :: EffRef m => a -> [Ref m a -> m (Widget m)] -> Ref m [a] -> m (Widget m)

module LGtk.Demos.TEditor

-- | Binary tree shapes
data T
Leaf :: T
Node :: T -> T -> T

-- | Lens for <tt>T</tt>
tLens :: Lens (Bool, (T, T)) T

-- | <tt>T</tt> editor with comboboxes, as an ADTEditor
tEditor1 :: EffRef m => Widget m

-- | <tt>T</tt> editor with checkboxes, given directly
tEditor3 :: EffRef m => Ref m T -> m (Widget m)
instance Show T
instance ADTLens T

module LGtk.Demos.Main
main :: IO ()
