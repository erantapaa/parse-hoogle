-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Advanced notions of computation
--   
@package computations
@version 0.0.0.0

module Control.Computation
class ArrowChoice p => Computation p where type family Unit p :: * type family Pair p :: * -> * -> * type family Function p :: * -> * -> * type family DropResult p a :: Constraint
(###) :: Computation p => (a `p` c) -> (b `p` d) -> (Pair p a b `p` Pair p c d)
assocLeft :: Computation p => Pair p a (Pair p b c) `p` Pair p (Pair p a b) c
assocRight :: Computation p => Pair p (Pair p a b) c `p` Pair p a (Pair p b c)
padFst :: Computation p => a `p` (Pair p (Unit p) a)
padSnd :: Computation p => a `p` (Pair p a (Unit p))
dropFst :: (Computation p, DropResult p a) => Pair p (Unit p) a `p` a
dropSnd :: (Computation p, DropResult p a) => Pair p a (Unit p) `p` a
swap :: Computation p => Pair p a b `p` Pair p b a
curry :: Computation p => Pair p a b `p` c -> a `p` Function p b c
apply :: Computation p => Pair p (Function p a b) a `p` b
mapFst :: Computation p => a `p` b -> Pair p a c `p` Pair p b c
mapSnd :: Computation p => b `p` c -> Pair p a b `p` Pair p a c
precomp :: Computation p => a `p` b -> Function p b c `p` Function p a c
postcomp :: Computation p => b `p` c -> Function p a b `p` Function p a c
uncurry :: Computation p => a `p` Function p b c -> Pair p a b `p` c
inFst :: Computation p => a `p` Function p b c -> Pair p a b `p` c
inSnd :: Computation p => b `p` Function p a c -> Pair p a b `p` c
outFst :: Computation p => Pair p a b `p` c -> a `p` Function p b c
outSnd :: Computation p => Pair p a b `p` c -> b `p` Function p a c
map1 :: Computation p => a `p` b -> Pair p a t `p` Pair p b t
map2 :: Computation p => b `p` c -> Pair p a (Pair p b t) `p` Pair p a (Pair p c t)
map3 :: Computation p => c `p` d -> Pair p a (Pair p b (Pair p c t)) `p` Pair p a (Pair p b (Pair p d t))
map4 :: Computation p => d `p` e -> Pair p a (Pair p b (Pair p c (Pair p d t))) `p` Pair p a (Pair p b (Pair p c (Pair p e t)))
in1 :: Computation p => a `p` Function p t r -> Pair p a t `p` r
in2 :: Computation p => b `p` Function p t (Function p a r) -> Pair p a (Pair p b t) `p` r
in3 :: Computation p => c `p` Function p t (Function p b (Function p a r)) -> Pair p a (Pair p b (Pair p c t)) `p` r
in4 :: Computation p => d `p` Function p t (Function p c (Function p b (Function p a r))) -> Pair p a (Pair p b (Pair p c (Pair p d t))) `p` r
out1 :: Computation p => Pair p a t `p` r -> a `p` Function p t r
out2 :: Computation p => Pair p a (Pair p b t) `p` r -> b `p` Function p t (Function p a r)
out3 :: Computation p => Pair p a (Pair p b (Pair p c t)) `p` r -> c `p` Function p t (Function p b (Function p a r))
out4 :: Computation p => Pair p a (Pair p b (Pair p c (Pair p d t))) `p` r -> d `p` Function p t (Function p c (Function p b (Function p a r)))
construct :: Computation p => (Unit p `p` a) -> (b `p` Pair p a b)
destruct :: (Computation p, DropResult p b) => (a `p` Unit p) -> (Pair p a b `p` b)
(+:+) :: Computation p => (Unit p `p` a) -> (b `p` t) -> (b `p` Pair p a t)
(-:-) :: (Computation p, DropResult p t) => (a `p` Unit p) -> (t `p` b) -> (Pair p a t `p` b)
type Pure = (->)
class (Computation (Source l), Computation (Target l)) => Link l where type family Source l :: * -> * -> * type family Target l :: * -> * -> *
linkMap :: Link l => Source l a b -> Target l (l a) (l b)
unitInside :: Link l => Target l (Unit (Target l)) (l (Unit (Source l)))
pairInside :: Link l => Target l (Pair (Target l) (l a) (l b)) (l (Pair (Source l) a b))
class (Link (p ==> q), Source (p ==> q) ~ p, Target (p ==> q) ~ q, Link (p <== q), Source (p <== q) ~ q, Target (p <== q) ~ p) => Connected p q where data family (==>) p q :: * -> * data family (<==) p q :: * -> *
inject :: Connected p q => a `p` (p <== q) ((p ==> q) a)
extract :: Connected p q => (p ==> q) ((p <== q) b) `q` b
up :: Connected p q => a `p` (p <== q) b -> (p ==> q) a `q` b
down :: Connected p q => (p ==> q) a `q` b -> a `p` (p <== q) b
instance Typeable Computation
instance Typeable Link
instance Typeable Connected
instance Computation p => Link (p <== p)
instance Computation p => Link (p ==> p)
instance Computation p => Connected p p
instance Computation Pure

module Control.Computation.Resourceful
data (~>) a b
type Resourceful = (~>)
data Blank
data (**) a b
data (-:) a b
class ResourceFunction a => Resource a
anchor :: Resource a => Anchor a
data Anchor a
Anchor :: (a ~> AtomicResource h) -> (AtomicResource h ~> a) -> Anchor a
type Attr a v = Property a a v
unsafeToAttr :: (h -> IO v) -> Attr (AtomicResource h) v
newtype Property a b v
Property :: (forall h. (v -> (b ~> AtomicResource h)) -> (a ~> AtomicResource h)) -> Property a b v
(^>) :: (a -> b) -> Property b c v -> Property a c v
(>^) :: Property a b v -> (b -> c) -> Property a c v
(^^>) :: (a ~> b) -> Property b c v -> Property a c v
(>^^) :: Property a b v -> (b ~> c) -> Property a c v
unsafeToProperty :: (h -> IO (v, k)) -> Property (AtomicResource h) (AtomicResource k) v
class ResourceFunction r
get :: ResourceFunction r => Property a b v -> (v -> (b ~> r)) -> (a ~> r)
class ResourceValue a where annotate = pure
annotate :: ResourceValue a => a -> Annotator a
data Annotator a
data AtomicResource h
unsafeToResourceConv :: (h -> IO k) -> (AtomicResource h ~> AtomicResource k)
fromResourceConv :: (AtomicResource h ~> AtomicResource k) -> (h -> IO k)
toUnitResource :: Blank ~> AtomicResource ()
fromUnitResource :: AtomicResource () ~> Blank
toPairResource :: (AtomicResource h ** AtomicResource k) ~> AtomicResource (h, k)
fromPairResource :: AtomicResource (h, k) ~> (AtomicResource h ** AtomicResource k)
instance Typeable (**)
instance Typeable (-:)
instance Typeable Gen
instance Typeable AtomicResource
instance Typeable Property
instance Typeable ResourceFunction
instance Typeable Anchor
instance Typeable Resource
instance Typeable Shredder
instance Typeable ResourceValue
instance Typeable Blank
instance Category (~>)
instance Arrow (~>)
instance ArrowChoice (~>)
instance Functor Annotator
instance Applicative Annotator
instance Monoid Shredder
instance Applicative Gen
instance Functor Gen
instance (ResourceValue a, ResourceValue b) => ResourceValue (a -> b)
instance (ResourceValue a, ResourceValue b, ResourceValue c, ResourceValue d, ResourceValue e, ResourceValue f) => ResourceValue (a, b, c, d, e, f)
instance (ResourceValue a, ResourceValue b, ResourceValue c, ResourceValue d, ResourceValue e) => ResourceValue (a, b, c, d, e)
instance (ResourceValue a, ResourceValue b, ResourceValue c, ResourceValue d) => ResourceValue (a, b, c, d)
instance (ResourceValue a, ResourceValue b, ResourceValue c) => ResourceValue (a, b, c)
instance (ResourceValue a, ResourceValue b) => ResourceValue (a, b)
instance ResourceValue ()
instance ResourceValue a => ResourceValue [a]
instance ResourceValue Rational
instance ResourceValue Double
instance ResourceValue Float
instance ResourceValue Integer
instance ResourceValue Int
instance ResourceValue Char
instance ResourceValue Ordering
instance (ResourceValue a, ResourceValue b) => ResourceValue (Either a b)
instance ResourceValue a => ResourceValue (Maybe a)
instance ResourceValue Bool
instance ResourceValue ((==>) Pure Resourceful a)
instance ResourceValue b => ResourceValue (a -: b)
instance ResourceValue a => ResourceValue (a ** b)
instance ResourceValue Blank
instance ResourceValue (AtomicResource h)
instance ResourceFunction b => ResourceFunction (a -: b)
instance (Resource a, Resource b) => ResourceFunction (a ** b)
instance ResourceFunction Blank
instance ResourceFunction (AtomicResource h)
instance Functor (Property a b)
instance (Resource a, Resource b) => Resource (a ** b)
instance Resource Blank
instance Resource (AtomicResource h)
instance Link (Pure <== Resourceful)
instance Link (Pure ==> Resourceful)
instance Connected Pure Resourceful
instance Computation Resourceful
