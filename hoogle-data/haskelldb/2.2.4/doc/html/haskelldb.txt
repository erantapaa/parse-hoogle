-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library of combinators for generating and executing SQL statements.
--   
@package haskelldb
@version 2.2.4

module Database.HaskellDB.Version
version :: String


-- | Various functions used when pretty printing stuff
module Database.HaskellDB.DBSpec.PPHelpers
newline :: Doc
ppComment :: [[Char]] -> Doc
fileName :: [Char] -> [Char]
data MakeIdentifiers
MakeIdentifiers :: (String -> String) -> (String -> String) -> (String -> String) -> MakeIdentifiers
moduleName :: MakeIdentifiers -> String -> String
identifier :: MakeIdentifiers -> String -> String
toType :: MakeIdentifiers -> String -> String
mkIdentPreserving :: MakeIdentifiers
mkIdentCamelCase :: MakeIdentifiers
toLowerCamelCase :: [Char] -> [Char]
toUpperCamelCase :: [Char] -> [Char]

-- | Generalization of <a>words</a> and <a>lines</a> to any separating
--   character set.
split :: Eq a => (a -> Bool) -> [a] -> [[a]]
checkChars :: [Char] -> [Char]
checkKeyword :: [Char] -> [Char]
checkUpper :: [Char] -> [Char]
checkLower :: [Char] -> [Char]
checkUpperDef :: Char -> [Char] -> [Char]
checkLowerDef :: Char -> [Char] -> [Char]


-- | The main idea of bounded lists is to create lists with predetermined
--   maximum size.
--   
--   BoundedList is a simple, fast and type safe approach to implementing
--   this idea. The implementation is based on inductive instances, making
--   it very easy to expand with new bounds. A new bound only requires one
--   instance of size and two instances of Less.
--   
--   BoundedList works as follows. Every bound is build up by declaring a
--   data-type representing the new bound. The instance of size only
--   returns the size as an Int. The first instance of Less is for telling
--   the typechecker that this bound is greater than the largest smaller
--   bound. The second instance of Less is used by the typechecker to
--   construct a chain of instances if there is no hardcoded instance
--   available. This way the type checker can determine if a bound is
--   smaller/greater then any other bound.
--   
--   This inductive approach gives the complexity O(n) on the number of
--   instances and very short type checking times compared to an O(n^2)
--   implementation.
--   
--   BoundedList also comes with a few utility function for manipulation an
--   contructing bounded lists.
--   
--   To be noted: Since each bound is a unique type: Explicit shrink and/or
--   grow is needed before using (==). BoundedList does not have an
--   instance of Ordering. (This might change)
module Database.HaskellDB.BoundedList

-- | Shrinks the <a>BoundedList</a> supplied if it can do so without
--   truncating the list. Returns Nothing if the list inside was to long.
shrink :: (Size n, Size m) => BoundedList a n -> Maybe (BoundedList a m)

-- | Takes a <a>BoundedList</a> add grows it size.
grow :: LessEq n m => BoundedList a n -> BoundedList a m

-- | Takes a list and transforms it to a <a>BoundedList</a>. If the list
--   doesn'n fit, the list is truncated to make it fit into the bounded
--   list.
trunc :: Size n => [a] -> BoundedList a n

-- | Returns the length of a <a>BoundedList</a>.
listBound :: Size n => BoundedList a n -> Int

-- | Takes a list and transforms it to a <a>BoundedList</a>. If the list
--   doesn't fit, Nothing is returned.
toBounded :: Size n => [a] -> Maybe (BoundedList a n)

-- | Takes a <a>BoundedList</a> and return the list inside.
fromBounded :: Size n => BoundedList a n -> [a]
class Size n
data BoundedList a n
data N0
data N1
data N2
data N3
data N4
data N5
data N6
data N7
data N8
data N9
data N10
data N11
data N12
data N13
data N14
data N15
data N16
data N17
data N18
data N19
data N20
data N21
data N22
data N23
data N24
data N25
data N26
data N27
data N28
data N29
data N30
data N31
data N32
data N33
data N34
data N35
data N36
data N37
data N38
data N39
data N40
data N41
data N42
data N43
data N44
data N45
data N46
data N47
data N48
data N49
data N50
data N51
data N52
data N53
data N54
data N55
data N56
data N57
data N58
data N59
data N60
data N61
data N62
data N63
data N64
data N65
data N66
data N67
data N68
data N69
data N70
data N71
data N72
data N73
data N74
data N75
data N76
data N77
data N78
data N79
data N80
data N81
data N82
data N83
data N84
data N85
data N86
data N87
data N88
data N89
data N90
data N91
data N92
data N93
data N94
data N95
data N96
data N97
data N98
data N99
data N100
data N101
data N102
data N103
data N104
data N105
data N106
data N107
data N108
data N109
data N110
data N111
data N112
data N113
data N114
data N115
data N116
data N117
data N118
data N119
data N120
data N121
data N122
data N123
data N124
data N125
data N126
data N127
data N128
data N129
data N130
data N131
data N132
data N133
data N134
data N135
data N136
data N137
data N138
data N139
data N140
data N141
data N142
data N143
data N144
data N145
data N146
data N147
data N148
data N149
data N150
data N151
data N152
data N153
data N154
data N155
data N156
data N157
data N158
data N159
data N160
data N161
data N162
data N163
data N164
data N165
data N166
data N167
data N168
data N169
data N170
data N171
data N172
data N173
data N174
data N175
data N176
data N177
data N178
data N179
data N180
data N181
data N182
data N183
data N184
data N185
data N186
data N187
data N188
data N189
data N190
data N191
data N192
data N193
data N194
data N195
data N196
data N197
data N198
data N199
data N200
data N201
data N202
data N203
data N204
data N205
data N206
data N207
data N208
data N209
data N210
data N211
data N212
data N213
data N214
data N215
data N216
data N217
data N218
data N219
data N220
data N221
data N222
data N223
data N224
data N225
data N226
data N227
data N228
data N229
data N230
data N231
data N232
data N233
data N234
data N235
data N236
data N237
data N238
data N239
data N240
data N241
data N242
data N243
data N244
data N245
data N246
data N247
data N248
data N249
data N250
data N251
data N252
data N253
data N254
data N255
data N65535
instance [overlap ok] Typeable BoundedList
instance [overlap ok] (Size n, Eq a) => Eq (BoundedList a n)
instance [overlap ok] (Show a, Size n) => Show (BoundedList a n)
instance [overlap ok] Less a N255 => Less a N65535
instance [overlap ok] Less N255 N65535
instance [overlap ok] Size N65535
instance [overlap ok] Less a N254 => Less a N255
instance [overlap ok] Less N254 N255
instance [overlap ok] Size N255
instance [overlap ok] Less a N253 => Less a N254
instance [overlap ok] Less N253 N254
instance [overlap ok] Size N254
instance [overlap ok] Less a N252 => Less a N253
instance [overlap ok] Less N252 N253
instance [overlap ok] Size N253
instance [overlap ok] Less a N251 => Less a N252
instance [overlap ok] Less N251 N252
instance [overlap ok] Size N252
instance [overlap ok] Less a N250 => Less a N251
instance [overlap ok] Less N250 N251
instance [overlap ok] Size N251
instance [overlap ok] Less a N249 => Less a N250
instance [overlap ok] Less N249 N250
instance [overlap ok] Size N250
instance [overlap ok] Less a N248 => Less a N249
instance [overlap ok] Less N248 N249
instance [overlap ok] Size N249
instance [overlap ok] Less a N247 => Less a N248
instance [overlap ok] Less N247 N248
instance [overlap ok] Size N248
instance [overlap ok] Less a N246 => Less a N247
instance [overlap ok] Less N246 N247
instance [overlap ok] Size N247
instance [overlap ok] Less a N245 => Less a N246
instance [overlap ok] Less N245 N246
instance [overlap ok] Size N246
instance [overlap ok] Less a N244 => Less a N245
instance [overlap ok] Less N244 N245
instance [overlap ok] Size N245
instance [overlap ok] Less a N243 => Less a N244
instance [overlap ok] Less N243 N244
instance [overlap ok] Size N244
instance [overlap ok] Less a N242 => Less a N243
instance [overlap ok] Less N242 N243
instance [overlap ok] Size N243
instance [overlap ok] Less a N241 => Less a N242
instance [overlap ok] Less N241 N242
instance [overlap ok] Size N242
instance [overlap ok] Less a N240 => Less a N241
instance [overlap ok] Less N240 N241
instance [overlap ok] Size N241
instance [overlap ok] Less a N239 => Less a N240
instance [overlap ok] Less N239 N240
instance [overlap ok] Size N240
instance [overlap ok] Less a N238 => Less a N239
instance [overlap ok] Less N238 N239
instance [overlap ok] Size N239
instance [overlap ok] Less a N237 => Less a N238
instance [overlap ok] Less N237 N238
instance [overlap ok] Size N238
instance [overlap ok] Less a N236 => Less a N237
instance [overlap ok] Less N236 N237
instance [overlap ok] Size N237
instance [overlap ok] Less a N235 => Less a N236
instance [overlap ok] Less N235 N236
instance [overlap ok] Size N236
instance [overlap ok] Less a N234 => Less a N235
instance [overlap ok] Less N234 N235
instance [overlap ok] Size N235
instance [overlap ok] Less a N233 => Less a N234
instance [overlap ok] Less N233 N234
instance [overlap ok] Size N234
instance [overlap ok] Less a N232 => Less a N233
instance [overlap ok] Less N232 N233
instance [overlap ok] Size N233
instance [overlap ok] Less a N231 => Less a N232
instance [overlap ok] Less N231 N232
instance [overlap ok] Size N232
instance [overlap ok] Less a N230 => Less a N231
instance [overlap ok] Less N230 N231
instance [overlap ok] Size N231
instance [overlap ok] Less a N229 => Less a N230
instance [overlap ok] Less N229 N230
instance [overlap ok] Size N230
instance [overlap ok] Less a N228 => Less a N229
instance [overlap ok] Less N228 N229
instance [overlap ok] Size N229
instance [overlap ok] Less a N227 => Less a N228
instance [overlap ok] Less N227 N228
instance [overlap ok] Size N228
instance [overlap ok] Less a N226 => Less a N227
instance [overlap ok] Less N226 N227
instance [overlap ok] Size N227
instance [overlap ok] Less a N225 => Less a N226
instance [overlap ok] Less N225 N226
instance [overlap ok] Size N226
instance [overlap ok] Less a N224 => Less a N225
instance [overlap ok] Less N224 N225
instance [overlap ok] Size N225
instance [overlap ok] Less a N223 => Less a N224
instance [overlap ok] Less N223 N224
instance [overlap ok] Size N224
instance [overlap ok] Less a N222 => Less a N223
instance [overlap ok] Less N222 N223
instance [overlap ok] Size N223
instance [overlap ok] Less a N221 => Less a N222
instance [overlap ok] Less N221 N222
instance [overlap ok] Size N222
instance [overlap ok] Less a N220 => Less a N221
instance [overlap ok] Less N220 N221
instance [overlap ok] Size N221
instance [overlap ok] Less a N219 => Less a N220
instance [overlap ok] Less N219 N220
instance [overlap ok] Size N220
instance [overlap ok] Less a N218 => Less a N219
instance [overlap ok] Less N218 N219
instance [overlap ok] Size N219
instance [overlap ok] Less a N217 => Less a N218
instance [overlap ok] Less N217 N218
instance [overlap ok] Size N218
instance [overlap ok] Less a N216 => Less a N217
instance [overlap ok] Less N216 N217
instance [overlap ok] Size N217
instance [overlap ok] Less a N215 => Less a N216
instance [overlap ok] Less N215 N216
instance [overlap ok] Size N216
instance [overlap ok] Less a N214 => Less a N215
instance [overlap ok] Less N214 N215
instance [overlap ok] Size N215
instance [overlap ok] Less a N213 => Less a N214
instance [overlap ok] Less N213 N214
instance [overlap ok] Size N214
instance [overlap ok] Less a N212 => Less a N213
instance [overlap ok] Less N212 N213
instance [overlap ok] Size N213
instance [overlap ok] Less a N211 => Less a N212
instance [overlap ok] Less N211 N212
instance [overlap ok] Size N212
instance [overlap ok] Less a N210 => Less a N211
instance [overlap ok] Less N210 N211
instance [overlap ok] Size N211
instance [overlap ok] Less a N209 => Less a N210
instance [overlap ok] Less N209 N210
instance [overlap ok] Size N210
instance [overlap ok] Less a N208 => Less a N209
instance [overlap ok] Less N208 N209
instance [overlap ok] Size N209
instance [overlap ok] Less a N207 => Less a N208
instance [overlap ok] Less N207 N208
instance [overlap ok] Size N208
instance [overlap ok] Less a N206 => Less a N207
instance [overlap ok] Less N206 N207
instance [overlap ok] Size N207
instance [overlap ok] Less a N205 => Less a N206
instance [overlap ok] Less N205 N206
instance [overlap ok] Size N206
instance [overlap ok] Less a N204 => Less a N205
instance [overlap ok] Less N204 N205
instance [overlap ok] Size N205
instance [overlap ok] Less a N203 => Less a N204
instance [overlap ok] Less N203 N204
instance [overlap ok] Size N204
instance [overlap ok] Less a N202 => Less a N203
instance [overlap ok] Less N202 N203
instance [overlap ok] Size N203
instance [overlap ok] Less a N201 => Less a N202
instance [overlap ok] Less N201 N202
instance [overlap ok] Size N202
instance [overlap ok] Less a N200 => Less a N201
instance [overlap ok] Less N200 N201
instance [overlap ok] Size N201
instance [overlap ok] Less a N199 => Less a N200
instance [overlap ok] Less N199 N200
instance [overlap ok] Size N200
instance [overlap ok] Less a N198 => Less a N199
instance [overlap ok] Less N198 N199
instance [overlap ok] Size N199
instance [overlap ok] Less a N197 => Less a N198
instance [overlap ok] Less N197 N198
instance [overlap ok] Size N198
instance [overlap ok] Less a N196 => Less a N197
instance [overlap ok] Less N196 N197
instance [overlap ok] Size N197
instance [overlap ok] Less a N195 => Less a N196
instance [overlap ok] Less N195 N196
instance [overlap ok] Size N196
instance [overlap ok] Less a N194 => Less a N195
instance [overlap ok] Less N194 N195
instance [overlap ok] Size N195
instance [overlap ok] Less a N193 => Less a N194
instance [overlap ok] Less N193 N194
instance [overlap ok] Size N194
instance [overlap ok] Less a N192 => Less a N193
instance [overlap ok] Less N192 N193
instance [overlap ok] Size N193
instance [overlap ok] Less a N191 => Less a N192
instance [overlap ok] Less N191 N192
instance [overlap ok] Size N192
instance [overlap ok] Less a N190 => Less a N191
instance [overlap ok] Less N190 N191
instance [overlap ok] Size N191
instance [overlap ok] Less a N189 => Less a N190
instance [overlap ok] Less N189 N190
instance [overlap ok] Size N190
instance [overlap ok] Less a N188 => Less a N189
instance [overlap ok] Less N188 N189
instance [overlap ok] Size N189
instance [overlap ok] Less a N187 => Less a N188
instance [overlap ok] Less N187 N188
instance [overlap ok] Size N188
instance [overlap ok] Less a N186 => Less a N187
instance [overlap ok] Less N186 N187
instance [overlap ok] Size N187
instance [overlap ok] Less a N185 => Less a N186
instance [overlap ok] Less N185 N186
instance [overlap ok] Size N186
instance [overlap ok] Less a N184 => Less a N185
instance [overlap ok] Less N184 N185
instance [overlap ok] Size N185
instance [overlap ok] Less a N183 => Less a N184
instance [overlap ok] Less N183 N184
instance [overlap ok] Size N184
instance [overlap ok] Less a N182 => Less a N183
instance [overlap ok] Less N182 N183
instance [overlap ok] Size N183
instance [overlap ok] Less a N181 => Less a N182
instance [overlap ok] Less N181 N182
instance [overlap ok] Size N182
instance [overlap ok] Less a N180 => Less a N181
instance [overlap ok] Less N180 N181
instance [overlap ok] Size N181
instance [overlap ok] Less a N179 => Less a N180
instance [overlap ok] Less N179 N180
instance [overlap ok] Size N180
instance [overlap ok] Less a N178 => Less a N179
instance [overlap ok] Less N178 N179
instance [overlap ok] Size N179
instance [overlap ok] Less a N177 => Less a N178
instance [overlap ok] Less N177 N178
instance [overlap ok] Size N178
instance [overlap ok] Less a N176 => Less a N177
instance [overlap ok] Less N176 N177
instance [overlap ok] Size N177
instance [overlap ok] Less a N175 => Less a N176
instance [overlap ok] Less N175 N176
instance [overlap ok] Size N176
instance [overlap ok] Less a N174 => Less a N175
instance [overlap ok] Less N174 N175
instance [overlap ok] Size N175
instance [overlap ok] Less a N173 => Less a N174
instance [overlap ok] Less N173 N174
instance [overlap ok] Size N174
instance [overlap ok] Less a N172 => Less a N173
instance [overlap ok] Less N172 N173
instance [overlap ok] Size N173
instance [overlap ok] Less a N171 => Less a N172
instance [overlap ok] Less N171 N172
instance [overlap ok] Size N172
instance [overlap ok] Less a N170 => Less a N171
instance [overlap ok] Less N170 N171
instance [overlap ok] Size N171
instance [overlap ok] Less a N169 => Less a N170
instance [overlap ok] Less N169 N170
instance [overlap ok] Size N170
instance [overlap ok] Less a N168 => Less a N169
instance [overlap ok] Less N168 N169
instance [overlap ok] Size N169
instance [overlap ok] Less a N167 => Less a N168
instance [overlap ok] Less N167 N168
instance [overlap ok] Size N168
instance [overlap ok] Less a N166 => Less a N167
instance [overlap ok] Less N166 N167
instance [overlap ok] Size N167
instance [overlap ok] Less a N165 => Less a N166
instance [overlap ok] Less N165 N166
instance [overlap ok] Size N166
instance [overlap ok] Less a N164 => Less a N165
instance [overlap ok] Less N164 N165
instance [overlap ok] Size N165
instance [overlap ok] Less a N163 => Less a N164
instance [overlap ok] Less N163 N164
instance [overlap ok] Size N164
instance [overlap ok] Less a N162 => Less a N163
instance [overlap ok] Less N162 N163
instance [overlap ok] Size N163
instance [overlap ok] Less a N161 => Less a N162
instance [overlap ok] Less N161 N162
instance [overlap ok] Size N162
instance [overlap ok] Less a N160 => Less a N161
instance [overlap ok] Less N160 N161
instance [overlap ok] Size N161
instance [overlap ok] Less a N159 => Less a N160
instance [overlap ok] Less N159 N160
instance [overlap ok] Size N160
instance [overlap ok] Less a N158 => Less a N159
instance [overlap ok] Less N158 N159
instance [overlap ok] Size N159
instance [overlap ok] Less a N157 => Less a N158
instance [overlap ok] Less N157 N158
instance [overlap ok] Size N158
instance [overlap ok] Less a N156 => Less a N157
instance [overlap ok] Less N156 N157
instance [overlap ok] Size N157
instance [overlap ok] Less a N155 => Less a N156
instance [overlap ok] Less N155 N156
instance [overlap ok] Size N156
instance [overlap ok] Less a N154 => Less a N155
instance [overlap ok] Less N154 N155
instance [overlap ok] Size N155
instance [overlap ok] Less a N153 => Less a N154
instance [overlap ok] Less N153 N154
instance [overlap ok] Size N154
instance [overlap ok] Less a N152 => Less a N153
instance [overlap ok] Less N152 N153
instance [overlap ok] Size N153
instance [overlap ok] Less a N151 => Less a N152
instance [overlap ok] Less N151 N152
instance [overlap ok] Size N152
instance [overlap ok] Less a N150 => Less a N151
instance [overlap ok] Less N150 N151
instance [overlap ok] Size N151
instance [overlap ok] Less a N149 => Less a N150
instance [overlap ok] Less N149 N150
instance [overlap ok] Size N150
instance [overlap ok] Less a N148 => Less a N149
instance [overlap ok] Less N148 N149
instance [overlap ok] Size N149
instance [overlap ok] Less a N147 => Less a N148
instance [overlap ok] Less N147 N148
instance [overlap ok] Size N148
instance [overlap ok] Less a N146 => Less a N147
instance [overlap ok] Less N146 N147
instance [overlap ok] Size N147
instance [overlap ok] Less a N145 => Less a N146
instance [overlap ok] Less N145 N146
instance [overlap ok] Size N146
instance [overlap ok] Less a N144 => Less a N145
instance [overlap ok] Less N144 N145
instance [overlap ok] Size N145
instance [overlap ok] Less a N143 => Less a N144
instance [overlap ok] Less N143 N144
instance [overlap ok] Size N144
instance [overlap ok] Less a N142 => Less a N143
instance [overlap ok] Less N142 N143
instance [overlap ok] Size N143
instance [overlap ok] Less a N141 => Less a N142
instance [overlap ok] Less N141 N142
instance [overlap ok] Size N142
instance [overlap ok] Less a N140 => Less a N141
instance [overlap ok] Less N140 N141
instance [overlap ok] Size N141
instance [overlap ok] Less a N139 => Less a N140
instance [overlap ok] Less N139 N140
instance [overlap ok] Size N140
instance [overlap ok] Less a N138 => Less a N139
instance [overlap ok] Less N138 N139
instance [overlap ok] Size N139
instance [overlap ok] Less a N137 => Less a N138
instance [overlap ok] Less N137 N138
instance [overlap ok] Size N138
instance [overlap ok] Less a N136 => Less a N137
instance [overlap ok] Less N136 N137
instance [overlap ok] Size N137
instance [overlap ok] Less a N135 => Less a N136
instance [overlap ok] Less N135 N136
instance [overlap ok] Size N136
instance [overlap ok] Less a N134 => Less a N135
instance [overlap ok] Less N134 N135
instance [overlap ok] Size N135
instance [overlap ok] Less a N133 => Less a N134
instance [overlap ok] Less N133 N134
instance [overlap ok] Size N134
instance [overlap ok] Less a N132 => Less a N133
instance [overlap ok] Less N132 N133
instance [overlap ok] Size N133
instance [overlap ok] Less a N131 => Less a N132
instance [overlap ok] Less N131 N132
instance [overlap ok] Size N132
instance [overlap ok] Less a N130 => Less a N131
instance [overlap ok] Less N130 N131
instance [overlap ok] Size N131
instance [overlap ok] Less a N129 => Less a N130
instance [overlap ok] Less N129 N130
instance [overlap ok] Size N130
instance [overlap ok] Less a N128 => Less a N129
instance [overlap ok] Less N128 N129
instance [overlap ok] Size N129
instance [overlap ok] Less a N127 => Less a N128
instance [overlap ok] Less N127 N128
instance [overlap ok] Size N128
instance [overlap ok] Less a N126 => Less a N127
instance [overlap ok] Less N126 N127
instance [overlap ok] Size N127
instance [overlap ok] Less a N125 => Less a N126
instance [overlap ok] Less N125 N126
instance [overlap ok] Size N126
instance [overlap ok] Less a N124 => Less a N125
instance [overlap ok] Less N124 N125
instance [overlap ok] Size N125
instance [overlap ok] Less a N123 => Less a N124
instance [overlap ok] Less N123 N124
instance [overlap ok] Size N124
instance [overlap ok] Less a N122 => Less a N123
instance [overlap ok] Less N122 N123
instance [overlap ok] Size N123
instance [overlap ok] Less a N121 => Less a N122
instance [overlap ok] Less N121 N122
instance [overlap ok] Size N122
instance [overlap ok] Less a N120 => Less a N121
instance [overlap ok] Less N120 N121
instance [overlap ok] Size N121
instance [overlap ok] Less a N119 => Less a N120
instance [overlap ok] Less N119 N120
instance [overlap ok] Size N120
instance [overlap ok] Less a N118 => Less a N119
instance [overlap ok] Less N118 N119
instance [overlap ok] Size N119
instance [overlap ok] Less a N117 => Less a N118
instance [overlap ok] Less N117 N118
instance [overlap ok] Size N118
instance [overlap ok] Less a N116 => Less a N117
instance [overlap ok] Less N116 N117
instance [overlap ok] Size N117
instance [overlap ok] Less a N115 => Less a N116
instance [overlap ok] Less N115 N116
instance [overlap ok] Size N116
instance [overlap ok] Less a N114 => Less a N115
instance [overlap ok] Less N114 N115
instance [overlap ok] Size N115
instance [overlap ok] Less a N113 => Less a N114
instance [overlap ok] Less N113 N114
instance [overlap ok] Size N114
instance [overlap ok] Less a N112 => Less a N113
instance [overlap ok] Less N112 N113
instance [overlap ok] Size N113
instance [overlap ok] Less a N111 => Less a N112
instance [overlap ok] Less N111 N112
instance [overlap ok] Size N112
instance [overlap ok] Less a N110 => Less a N111
instance [overlap ok] Less N110 N111
instance [overlap ok] Size N111
instance [overlap ok] Less a N109 => Less a N110
instance [overlap ok] Less N109 N110
instance [overlap ok] Size N110
instance [overlap ok] Less a N108 => Less a N109
instance [overlap ok] Less N108 N109
instance [overlap ok] Size N109
instance [overlap ok] Less a N107 => Less a N108
instance [overlap ok] Less N107 N108
instance [overlap ok] Size N108
instance [overlap ok] Less a N106 => Less a N107
instance [overlap ok] Less N106 N107
instance [overlap ok] Size N107
instance [overlap ok] Less a N105 => Less a N106
instance [overlap ok] Less N105 N106
instance [overlap ok] Size N106
instance [overlap ok] Less a N104 => Less a N105
instance [overlap ok] Less N104 N105
instance [overlap ok] Size N105
instance [overlap ok] Less a N103 => Less a N104
instance [overlap ok] Less N103 N104
instance [overlap ok] Size N104
instance [overlap ok] Less a N102 => Less a N103
instance [overlap ok] Less N102 N103
instance [overlap ok] Size N103
instance [overlap ok] Less a N101 => Less a N102
instance [overlap ok] Less N101 N102
instance [overlap ok] Size N102
instance [overlap ok] Less a N100 => Less a N101
instance [overlap ok] Less N100 N101
instance [overlap ok] Size N101
instance [overlap ok] Less a N99 => Less a N100
instance [overlap ok] Less N99 N100
instance [overlap ok] Size N100
instance [overlap ok] Less a N98 => Less a N99
instance [overlap ok] Less N98 N99
instance [overlap ok] Size N99
instance [overlap ok] Less a N97 => Less a N98
instance [overlap ok] Less N97 N98
instance [overlap ok] Size N98
instance [overlap ok] Less a N96 => Less a N97
instance [overlap ok] Less N96 N97
instance [overlap ok] Size N97
instance [overlap ok] Less a N95 => Less a N96
instance [overlap ok] Less N95 N96
instance [overlap ok] Size N96
instance [overlap ok] Less a N94 => Less a N95
instance [overlap ok] Less N94 N95
instance [overlap ok] Size N95
instance [overlap ok] Less a N93 => Less a N94
instance [overlap ok] Less N93 N94
instance [overlap ok] Size N94
instance [overlap ok] Less a N92 => Less a N93
instance [overlap ok] Less N92 N93
instance [overlap ok] Size N93
instance [overlap ok] Less a N91 => Less a N92
instance [overlap ok] Less N91 N92
instance [overlap ok] Size N92
instance [overlap ok] Less a N90 => Less a N91
instance [overlap ok] Less N90 N91
instance [overlap ok] Size N91
instance [overlap ok] Less a N89 => Less a N90
instance [overlap ok] Less N89 N90
instance [overlap ok] Size N90
instance [overlap ok] Less a N88 => Less a N89
instance [overlap ok] Less N88 N89
instance [overlap ok] Size N89
instance [overlap ok] Less a N87 => Less a N88
instance [overlap ok] Less N87 N88
instance [overlap ok] Size N88
instance [overlap ok] Less a N86 => Less a N87
instance [overlap ok] Less N86 N87
instance [overlap ok] Size N87
instance [overlap ok] Less a N85 => Less a N86
instance [overlap ok] Less N85 N86
instance [overlap ok] Size N86
instance [overlap ok] Less a N84 => Less a N85
instance [overlap ok] Less N84 N85
instance [overlap ok] Size N85
instance [overlap ok] Less a N83 => Less a N84
instance [overlap ok] Less N83 N84
instance [overlap ok] Size N84
instance [overlap ok] Less a N82 => Less a N83
instance [overlap ok] Less N82 N83
instance [overlap ok] Size N83
instance [overlap ok] Less a N81 => Less a N82
instance [overlap ok] Less N81 N82
instance [overlap ok] Size N82
instance [overlap ok] Less a N80 => Less a N81
instance [overlap ok] Less N80 N81
instance [overlap ok] Size N81
instance [overlap ok] Less a N79 => Less a N80
instance [overlap ok] Less N79 N80
instance [overlap ok] Size N80
instance [overlap ok] Less a N78 => Less a N79
instance [overlap ok] Less N78 N79
instance [overlap ok] Size N79
instance [overlap ok] Less a N77 => Less a N78
instance [overlap ok] Less N77 N78
instance [overlap ok] Size N78
instance [overlap ok] Less a N76 => Less a N77
instance [overlap ok] Less N76 N77
instance [overlap ok] Size N77
instance [overlap ok] Less a N75 => Less a N76
instance [overlap ok] Less N75 N76
instance [overlap ok] Size N76
instance [overlap ok] Less a N74 => Less a N75
instance [overlap ok] Less N74 N75
instance [overlap ok] Size N75
instance [overlap ok] Less a N73 => Less a N74
instance [overlap ok] Less N73 N74
instance [overlap ok] Size N74
instance [overlap ok] Less a N72 => Less a N73
instance [overlap ok] Less N72 N73
instance [overlap ok] Size N73
instance [overlap ok] Less a N71 => Less a N72
instance [overlap ok] Less N71 N72
instance [overlap ok] Size N72
instance [overlap ok] Less a N70 => Less a N71
instance [overlap ok] Less N70 N71
instance [overlap ok] Size N71
instance [overlap ok] Less a N69 => Less a N70
instance [overlap ok] Less N69 N70
instance [overlap ok] Size N70
instance [overlap ok] Less a N68 => Less a N69
instance [overlap ok] Less N68 N69
instance [overlap ok] Size N69
instance [overlap ok] Less a N67 => Less a N68
instance [overlap ok] Less N67 N68
instance [overlap ok] Size N68
instance [overlap ok] Less a N66 => Less a N67
instance [overlap ok] Less N66 N67
instance [overlap ok] Size N67
instance [overlap ok] Less a N65 => Less a N66
instance [overlap ok] Less N65 N66
instance [overlap ok] Size N66
instance [overlap ok] Less a N64 => Less a N65
instance [overlap ok] Less N64 N65
instance [overlap ok] Size N65
instance [overlap ok] Less a N63 => Less a N64
instance [overlap ok] Less N63 N64
instance [overlap ok] Size N64
instance [overlap ok] Less a N62 => Less a N63
instance [overlap ok] Less N62 N63
instance [overlap ok] Size N63
instance [overlap ok] Less a N61 => Less a N62
instance [overlap ok] Less N61 N62
instance [overlap ok] Size N62
instance [overlap ok] Less a N60 => Less a N61
instance [overlap ok] Less N60 N61
instance [overlap ok] Size N61
instance [overlap ok] Less a N59 => Less a N60
instance [overlap ok] Less N59 N60
instance [overlap ok] Size N60
instance [overlap ok] Less a N58 => Less a N59
instance [overlap ok] Less N58 N59
instance [overlap ok] Size N59
instance [overlap ok] Less a N57 => Less a N58
instance [overlap ok] Less N57 N58
instance [overlap ok] Size N58
instance [overlap ok] Less a N56 => Less a N57
instance [overlap ok] Less N56 N57
instance [overlap ok] Size N57
instance [overlap ok] Less a N55 => Less a N56
instance [overlap ok] Less N55 N56
instance [overlap ok] Size N56
instance [overlap ok] Less a N54 => Less a N55
instance [overlap ok] Less N54 N55
instance [overlap ok] Size N55
instance [overlap ok] Less a N53 => Less a N54
instance [overlap ok] Less N53 N54
instance [overlap ok] Size N54
instance [overlap ok] Less a N52 => Less a N53
instance [overlap ok] Less N52 N53
instance [overlap ok] Size N53
instance [overlap ok] Less a N51 => Less a N52
instance [overlap ok] Less N51 N52
instance [overlap ok] Size N52
instance [overlap ok] Less a N50 => Less a N51
instance [overlap ok] Less N50 N51
instance [overlap ok] Size N51
instance [overlap ok] Less a N49 => Less a N50
instance [overlap ok] Less N49 N50
instance [overlap ok] Size N50
instance [overlap ok] Less a N48 => Less a N49
instance [overlap ok] Less N48 N49
instance [overlap ok] Size N49
instance [overlap ok] Less a N47 => Less a N48
instance [overlap ok] Less N47 N48
instance [overlap ok] Size N48
instance [overlap ok] Less a N46 => Less a N47
instance [overlap ok] Less N46 N47
instance [overlap ok] Size N47
instance [overlap ok] Less a N45 => Less a N46
instance [overlap ok] Less N45 N46
instance [overlap ok] Size N46
instance [overlap ok] Less a N44 => Less a N45
instance [overlap ok] Less N44 N45
instance [overlap ok] Size N45
instance [overlap ok] Less a N43 => Less a N44
instance [overlap ok] Less N43 N44
instance [overlap ok] Size N44
instance [overlap ok] Less a N42 => Less a N43
instance [overlap ok] Less N42 N43
instance [overlap ok] Size N43
instance [overlap ok] Less a N41 => Less a N42
instance [overlap ok] Less N41 N42
instance [overlap ok] Size N42
instance [overlap ok] Less a N40 => Less a N41
instance [overlap ok] Less N40 N41
instance [overlap ok] Size N41
instance [overlap ok] Less a N39 => Less a N40
instance [overlap ok] Less N39 N40
instance [overlap ok] Size N40
instance [overlap ok] Less a N38 => Less a N39
instance [overlap ok] Less N38 N39
instance [overlap ok] Size N39
instance [overlap ok] Less a N37 => Less a N38
instance [overlap ok] Less N37 N38
instance [overlap ok] Size N38
instance [overlap ok] Less a N36 => Less a N37
instance [overlap ok] Less N36 N37
instance [overlap ok] Size N37
instance [overlap ok] Less a N35 => Less a N36
instance [overlap ok] Less N35 N36
instance [overlap ok] Size N36
instance [overlap ok] Less a N34 => Less a N35
instance [overlap ok] Less N34 N35
instance [overlap ok] Size N35
instance [overlap ok] Less a N33 => Less a N34
instance [overlap ok] Less N33 N34
instance [overlap ok] Size N34
instance [overlap ok] Less a N32 => Less a N33
instance [overlap ok] Less N32 N33
instance [overlap ok] Size N33
instance [overlap ok] Less a N31 => Less a N32
instance [overlap ok] Less N31 N32
instance [overlap ok] Size N32
instance [overlap ok] Less a N30 => Less a N31
instance [overlap ok] Less N30 N31
instance [overlap ok] Size N31
instance [overlap ok] Less a N29 => Less a N30
instance [overlap ok] Less N29 N30
instance [overlap ok] Size N30
instance [overlap ok] Less a N28 => Less a N29
instance [overlap ok] Less N28 N29
instance [overlap ok] Size N29
instance [overlap ok] Less a N27 => Less a N28
instance [overlap ok] Less N27 N28
instance [overlap ok] Size N28
instance [overlap ok] Less a N26 => Less a N27
instance [overlap ok] Less N26 N27
instance [overlap ok] Size N27
instance [overlap ok] Less a N25 => Less a N26
instance [overlap ok] Less N25 N26
instance [overlap ok] Size N26
instance [overlap ok] Less a N24 => Less a N25
instance [overlap ok] Less N24 N25
instance [overlap ok] Size N25
instance [overlap ok] Less a N23 => Less a N24
instance [overlap ok] Less N23 N24
instance [overlap ok] Size N24
instance [overlap ok] Less a N22 => Less a N23
instance [overlap ok] Less N22 N23
instance [overlap ok] Size N23
instance [overlap ok] Less a N21 => Less a N22
instance [overlap ok] Less N21 N22
instance [overlap ok] Size N22
instance [overlap ok] Less a N20 => Less a N21
instance [overlap ok] Less N20 N21
instance [overlap ok] Size N21
instance [overlap ok] Less a N19 => Less a N20
instance [overlap ok] Less N19 N20
instance [overlap ok] Size N20
instance [overlap ok] Less a N18 => Less a N19
instance [overlap ok] Less N18 N19
instance [overlap ok] Size N19
instance [overlap ok] Less a N17 => Less a N18
instance [overlap ok] Less N17 N18
instance [overlap ok] Size N18
instance [overlap ok] Less a N16 => Less a N17
instance [overlap ok] Less N16 N17
instance [overlap ok] Size N17
instance [overlap ok] Less a N15 => Less a N16
instance [overlap ok] Less N15 N16
instance [overlap ok] Size N16
instance [overlap ok] Less a N14 => Less a N15
instance [overlap ok] Less N14 N15
instance [overlap ok] Size N15
instance [overlap ok] Less a N13 => Less a N14
instance [overlap ok] Less N13 N14
instance [overlap ok] Size N14
instance [overlap ok] Less a N12 => Less a N13
instance [overlap ok] Less N12 N13
instance [overlap ok] Size N13
instance [overlap ok] Less a N11 => Less a N12
instance [overlap ok] Less N11 N12
instance [overlap ok] Size N12
instance [overlap ok] Less a N10 => Less a N11
instance [overlap ok] Less N10 N11
instance [overlap ok] Size N11
instance [overlap ok] Less a N9 => Less a N10
instance [overlap ok] Less N9 N10
instance [overlap ok] Size N10
instance [overlap ok] Less a N8 => Less a N9
instance [overlap ok] Less N8 N9
instance [overlap ok] Size N9
instance [overlap ok] Less a N7 => Less a N8
instance [overlap ok] Less N7 N8
instance [overlap ok] Size N8
instance [overlap ok] Less a N6 => Less a N7
instance [overlap ok] Less N6 N7
instance [overlap ok] Size N7
instance [overlap ok] Less a N5 => Less a N6
instance [overlap ok] Less N5 N6
instance [overlap ok] Size N6
instance [overlap ok] Less a N4 => Less a N5
instance [overlap ok] Less N4 N5
instance [overlap ok] Size N5
instance [overlap ok] Less a N3 => Less a N4
instance [overlap ok] Less N3 N4
instance [overlap ok] Size N4
instance [overlap ok] Less a N2 => Less a N3
instance [overlap ok] Less N2 N3
instance [overlap ok] Size N3
instance [overlap ok] Less a N1 => Less a N2
instance [overlap ok] Less N1 N2
instance [overlap ok] Size N2
instance [overlap ok] Less N0 N1
instance [overlap ok] Size N1
instance [overlap ok] Size N0
instance [overlap ok] (Size a, Size b, Less a b) => LessEq a b
instance [overlap ok] Size a => LessEq a a


-- | BoundedString represents the sql types; CHARACTER and CHARACTER
--   VARYING both defined in SQL 1992. BoundedString supports sizes in the
--   range [0,255] and 65535. Greater sizes and the sql type SQL_TEXT (SQL
--   1992) will might be supported in the future.
--   
--   The use of BoundedString together with HaskellDB enables feedback when
--   the length of a string exceeds the bound of a certain database field.
--   BoundedString also provides a layer of type safety against loss of
--   data due to sql string truncation when extracting and re-insert data
--   into fields with smaller bound.
module Database.HaskellDB.BoundedString
type BoundedString n = BoundedList Char n
type BStr0 = BoundedString N0
type BStr1 = BoundedString N1
type BStr2 = BoundedString N2
type BStr3 = BoundedString N3
type BStr4 = BoundedString N4
type BStr5 = BoundedString N5
type BStr6 = BoundedString N6
type BStr7 = BoundedString N7
type BStr8 = BoundedString N8
type BStr9 = BoundedString N9
type BStr10 = BoundedString N10
type BStr11 = BoundedString N11
type BStr12 = BoundedString N12
type BStr13 = BoundedString N13
type BStr14 = BoundedString N14
type BStr15 = BoundedString N15
type BStr16 = BoundedString N16
type BStr17 = BoundedString N17
type BStr18 = BoundedString N18
type BStr19 = BoundedString N19
type BStr20 = BoundedString N20
type BStr21 = BoundedString N21
type BStr22 = BoundedString N22
type BStr23 = BoundedString N23
type BStr24 = BoundedString N24
type BStr25 = BoundedString N25
type BStr26 = BoundedString N26
type BStr27 = BoundedString N27
type BStr28 = BoundedString N28
type BStr29 = BoundedString N29
type BStr30 = BoundedString N30
type BStr31 = BoundedString N31
type BStr32 = BoundedString N32
type BStr33 = BoundedString N33
type BStr34 = BoundedString N34
type BStr35 = BoundedString N35
type BStr36 = BoundedString N36
type BStr37 = BoundedString N37
type BStr38 = BoundedString N38
type BStr39 = BoundedString N39
type BStr40 = BoundedString N40
type BStr41 = BoundedString N41
type BStr42 = BoundedString N42
type BStr43 = BoundedString N43
type BStr44 = BoundedString N44
type BStr45 = BoundedString N45
type BStr46 = BoundedString N46
type BStr47 = BoundedString N47
type BStr48 = BoundedString N48
type BStr49 = BoundedString N49
type BStr50 = BoundedString N50
type BStr51 = BoundedString N51
type BStr52 = BoundedString N52
type BStr53 = BoundedString N53
type BStr54 = BoundedString N54
type BStr55 = BoundedString N55
type BStr56 = BoundedString N56
type BStr57 = BoundedString N57
type BStr58 = BoundedString N58
type BStr59 = BoundedString N59
type BStr60 = BoundedString N60
type BStr61 = BoundedString N61
type BStr62 = BoundedString N62
type BStr63 = BoundedString N63
type BStr64 = BoundedString N64
type BStr65 = BoundedString N65
type BStr66 = BoundedString N66
type BStr67 = BoundedString N67
type BStr68 = BoundedString N68
type BStr69 = BoundedString N69
type BStr70 = BoundedString N70
type BStr71 = BoundedString N71
type BStr72 = BoundedString N72
type BStr73 = BoundedString N73
type BStr74 = BoundedString N74
type BStr75 = BoundedString N75
type BStr76 = BoundedString N76
type BStr77 = BoundedString N77
type BStr78 = BoundedString N78
type BStr79 = BoundedString N79
type BStr80 = BoundedString N80
type BStr81 = BoundedString N81
type BStr82 = BoundedString N82
type BStr83 = BoundedString N83
type BStr84 = BoundedString N84
type BStr85 = BoundedString N85
type BStr86 = BoundedString N86
type BStr87 = BoundedString N87
type BStr88 = BoundedString N88
type BStr89 = BoundedString N89
type BStr90 = BoundedString N90
type BStr91 = BoundedString N91
type BStr92 = BoundedString N92
type BStr93 = BoundedString N93
type BStr94 = BoundedString N94
type BStr95 = BoundedString N95
type BStr96 = BoundedString N96
type BStr97 = BoundedString N97
type BStr98 = BoundedString N98
type BStr99 = BoundedString N99
type BStr100 = BoundedString N100
type BStr101 = BoundedString N101
type BStr102 = BoundedString N102
type BStr103 = BoundedString N103
type BStr104 = BoundedString N104
type BStr105 = BoundedString N105
type BStr106 = BoundedString N106
type BStr107 = BoundedString N107
type BStr108 = BoundedString N108
type BStr109 = BoundedString N109
type BStr110 = BoundedString N110
type BStr111 = BoundedString N111
type BStr112 = BoundedString N112
type BStr113 = BoundedString N113
type BStr114 = BoundedString N114
type BStr115 = BoundedString N115
type BStr116 = BoundedString N116
type BStr117 = BoundedString N117
type BStr118 = BoundedString N118
type BStr119 = BoundedString N119
type BStr120 = BoundedString N120
type BStr121 = BoundedString N121
type BStr122 = BoundedString N122
type BStr123 = BoundedString N123
type BStr124 = BoundedString N124
type BStr125 = BoundedString N125
type BStr126 = BoundedString N126
type BStr127 = BoundedString N127
type BStr128 = BoundedString N128
type BStr129 = BoundedString N129
type BStr130 = BoundedString N130
type BStr131 = BoundedString N131
type BStr132 = BoundedString N132
type BStr133 = BoundedString N133
type BStr134 = BoundedString N134
type BStr135 = BoundedString N135
type BStr136 = BoundedString N136
type BStr137 = BoundedString N137
type BStr138 = BoundedString N138
type BStr139 = BoundedString N139
type BStr140 = BoundedString N140
type BStr141 = BoundedString N141
type BStr142 = BoundedString N142
type BStr143 = BoundedString N143
type BStr144 = BoundedString N144
type BStr145 = BoundedString N145
type BStr146 = BoundedString N146
type BStr147 = BoundedString N147
type BStr148 = BoundedString N148
type BStr149 = BoundedString N149
type BStr150 = BoundedString N150
type BStr151 = BoundedString N151
type BStr152 = BoundedString N152
type BStr153 = BoundedString N153
type BStr154 = BoundedString N154
type BStr155 = BoundedString N155
type BStr156 = BoundedString N156
type BStr157 = BoundedString N157
type BStr158 = BoundedString N158
type BStr159 = BoundedString N159
type BStr160 = BoundedString N160
type BStr161 = BoundedString N161
type BStr162 = BoundedString N162
type BStr163 = BoundedString N163
type BStr164 = BoundedString N164
type BStr165 = BoundedString N165
type BStr166 = BoundedString N166
type BStr167 = BoundedString N167
type BStr168 = BoundedString N168
type BStr169 = BoundedString N169
type BStr170 = BoundedString N170
type BStr171 = BoundedString N171
type BStr172 = BoundedString N172
type BStr173 = BoundedString N173
type BStr174 = BoundedString N174
type BStr175 = BoundedString N175
type BStr176 = BoundedString N176
type BStr177 = BoundedString N177
type BStr178 = BoundedString N178
type BStr179 = BoundedString N179
type BStr180 = BoundedString N180
type BStr181 = BoundedString N181
type BStr182 = BoundedString N182
type BStr183 = BoundedString N183
type BStr184 = BoundedString N184
type BStr185 = BoundedString N185
type BStr186 = BoundedString N186
type BStr187 = BoundedString N187
type BStr188 = BoundedString N188
type BStr189 = BoundedString N189
type BStr190 = BoundedString N190
type BStr191 = BoundedString N191
type BStr192 = BoundedString N192
type BStr193 = BoundedString N193
type BStr194 = BoundedString N194
type BStr195 = BoundedString N195
type BStr196 = BoundedString N196
type BStr197 = BoundedString N197
type BStr198 = BoundedString N198
type BStr199 = BoundedString N199
type BStr200 = BoundedString N200
type BStr201 = BoundedString N201
type BStr202 = BoundedString N202
type BStr203 = BoundedString N203
type BStr204 = BoundedString N204
type BStr205 = BoundedString N205
type BStr206 = BoundedString N206
type BStr207 = BoundedString N207
type BStr208 = BoundedString N208
type BStr209 = BoundedString N209
type BStr210 = BoundedString N210
type BStr211 = BoundedString N211
type BStr212 = BoundedString N212
type BStr213 = BoundedString N213
type BStr214 = BoundedString N214
type BStr215 = BoundedString N215
type BStr216 = BoundedString N216
type BStr217 = BoundedString N217
type BStr218 = BoundedString N218
type BStr219 = BoundedString N219
type BStr220 = BoundedString N220
type BStr221 = BoundedString N221
type BStr222 = BoundedString N222
type BStr223 = BoundedString N223
type BStr224 = BoundedString N224
type BStr225 = BoundedString N225
type BStr226 = BoundedString N226
type BStr227 = BoundedString N227
type BStr228 = BoundedString N228
type BStr229 = BoundedString N229
type BStr230 = BoundedString N230
type BStr231 = BoundedString N231
type BStr232 = BoundedString N232
type BStr233 = BoundedString N233
type BStr234 = BoundedString N234
type BStr235 = BoundedString N235
type BStr236 = BoundedString N236
type BStr237 = BoundedString N237
type BStr238 = BoundedString N238
type BStr239 = BoundedString N239
type BStr240 = BoundedString N240
type BStr241 = BoundedString N241
type BStr242 = BoundedString N242
type BStr243 = BoundedString N243
type BStr244 = BoundedString N244
type BStr245 = BoundedString N245
type BStr246 = BoundedString N246
type BStr247 = BoundedString N247
type BStr248 = BoundedString N248
type BStr249 = BoundedString N249
type BStr250 = BoundedString N250
type BStr251 = BoundedString N251
type BStr252 = BoundedString N252
type BStr253 = BoundedString N253
type BStr254 = BoundedString N254
type BStr255 = BoundedString N255
type BStr65535 = BoundedString N65535


-- | A data type for SQL.
module Database.HaskellDB.Sql
type SqlTable = String
type SqlColumn = String

-- | A valid SQL name for a parameter.
type SqlName = String
data SqlOrder
SqlAsc :: SqlOrder
SqlDesc :: SqlOrder
data SqlType
SqlType :: String -> SqlType
SqlType1 :: String -> Int -> SqlType
SqlType2 :: String -> Int -> Int -> SqlType

-- | Data type for SQL SELECT statements.
data SqlSelect
SqlSelect :: [String] -> [(SqlColumn, SqlExpr)] -> [(SqlTable, SqlSelect)] -> [SqlExpr] -> Maybe Mark -> [(SqlExpr, SqlOrder)] -> [String] -> SqlSelect

-- | DISTINCT, ALL etc.
options :: SqlSelect -> [String]

-- | result
attrs :: SqlSelect -> [(SqlColumn, SqlExpr)]

-- | FROM
tables :: SqlSelect -> [(SqlTable, SqlSelect)]

-- | WHERE
criteria :: SqlSelect -> [SqlExpr]

-- | GROUP BY
groupby :: SqlSelect -> Maybe Mark

-- | ORDER BY
orderby :: SqlSelect -> [(SqlExpr, SqlOrder)]

-- | TOP n, etc.
extra :: SqlSelect -> [String]

-- | Binary relational operator
SqlBin :: String -> SqlSelect -> SqlSelect -> SqlSelect

-- | Select a whole table.
SqlTable :: SqlTable -> SqlSelect

-- | Empty select.
SqlEmpty :: SqlSelect

-- | Data type for SQL UPDATE statements.
data SqlUpdate
SqlUpdate :: SqlTable -> [(SqlColumn, SqlExpr)] -> [SqlExpr] -> SqlUpdate

-- | Data type for SQL DELETE statements.
data SqlDelete
SqlDelete :: SqlTable -> [SqlExpr] -> SqlDelete

-- | Data type for SQL INSERT statements.
data SqlInsert
SqlInsert :: SqlTable -> [SqlColumn] -> [SqlExpr] -> SqlInsert
SqlInsertQuery :: SqlTable -> [SqlColumn] -> SqlSelect -> SqlInsert

-- | Data type for SQL CREATE statements.
data SqlCreate

-- | Create a database
SqlCreateDB :: String -> SqlCreate

-- | Create a table.
SqlCreateTable :: SqlTable -> [(SqlColumn, (SqlType, Bool))] -> SqlCreate

-- | Data type representing the SQL DROP statement.
data SqlDrop

-- | Delete a database
SqlDropDB :: String -> SqlDrop

-- | Delete a table named SqlTable
SqlDropTable :: SqlTable -> SqlDrop

-- | Expressions in SQL statements.
data SqlExpr
ColumnSqlExpr :: SqlColumn -> SqlExpr
BinSqlExpr :: String -> SqlExpr -> SqlExpr -> SqlExpr
PrefixSqlExpr :: String -> SqlExpr -> SqlExpr
PostfixSqlExpr :: String -> SqlExpr -> SqlExpr
FunSqlExpr :: String -> [SqlExpr] -> SqlExpr

-- | Aggregate functions separate from normal functions.
AggrFunSqlExpr :: String -> [SqlExpr] -> SqlExpr
ConstSqlExpr :: String -> SqlExpr
CaseSqlExpr :: [(SqlExpr, SqlExpr)] -> SqlExpr -> SqlExpr
ListSqlExpr :: [SqlExpr] -> SqlExpr
ExistsSqlExpr :: SqlSelect -> SqlExpr
ParamSqlExpr :: (Maybe SqlName) -> SqlExpr -> SqlExpr
PlaceHolderSqlExpr :: SqlExpr
ParensSqlExpr :: SqlExpr -> SqlExpr
CastSqlExpr :: String -> SqlExpr -> SqlExpr
data Mark
All :: Mark
Columns :: [(SqlColumn, SqlExpr)] -> Mark
newSelect :: SqlSelect

-- | Transform a SqlExpr value.
foldSqlExpr :: (SqlColumn -> t, String -> t -> t -> t, String -> t -> t, String -> t -> t, String -> [t] -> t, String -> [t] -> t, String -> t, [(t, t)] -> t -> t, [t] -> t, SqlSelect -> t, (Maybe SqlName) -> t -> t, t, t -> t, String -> t -> t) -> SqlExpr -> t

-- | Transform a SqlSelect value.
foldSqlSelect :: ([String] -> [(SqlColumn, SqlExpr)] -> [(SqlTable, t)] -> [SqlExpr] -> Maybe Mark -> [(SqlExpr, SqlOrder)] -> [String] -> t, String -> t -> t -> t, SqlTable -> t, t) -> SqlSelect -> t
instance [overlap ok] Show SqlOrder
instance [overlap ok] Show SqlType
instance [overlap ok] Show SqlExpr
instance [overlap ok] Show SqlSelect
instance [overlap ok] Show Mark


-- | Pretty-print SQL
module Database.HaskellDB.Sql.Print

-- | Pretty prints a <a>SqlSelect</a>
ppSql :: SqlSelect -> Doc

-- | Pretty prints a <a>SqlUpdate</a>
ppUpdate :: SqlUpdate -> Doc

-- | Pretty prints a <a>SqlDelete</a>
ppDelete :: SqlDelete -> Doc
ppInsert :: SqlInsert -> Doc

-- | Pretty prints a <a>SqlCreate</a>.
ppCreate :: SqlCreate -> Doc

-- | Pretty prints a <a>SqlDrop</a>.
ppDrop :: SqlDrop -> Doc

-- | Pretty prints a <a>SqlExpr</a>
ppSqlExpr :: SqlExpr -> Doc


-- | PrimQuery defines the datatype of relational expressions
--   (<a>PrimQuery</a>) and some useful functions on PrimQuery's
module Database.HaskellDB.PrimQuery
type TableName = String
type Attribute = String
type Scheme = [Attribute]
type Assoc = [(Attribute, PrimExpr)]
type Name = String
data PrimQuery
BaseTable :: TableName -> Scheme -> PrimQuery
Project :: Assoc -> PrimQuery -> PrimQuery
Restrict :: PrimExpr -> PrimQuery -> PrimQuery
Group :: Assoc -> PrimQuery -> PrimQuery
Binary :: RelOp -> PrimQuery -> PrimQuery -> PrimQuery
Special :: SpecialOp -> PrimQuery -> PrimQuery
Empty :: PrimQuery
data RelOp
Times :: RelOp
Union :: RelOp
UnionAll :: RelOp
Intersect :: RelOp
Divide :: RelOp
Difference :: RelOp
data SpecialOp
Order :: [OrderExpr] -> SpecialOp
Top :: Int -> SpecialOp
Offset :: Int -> SpecialOp
data PrimExpr
AttrExpr :: Attribute -> PrimExpr
BinExpr :: BinOp -> PrimExpr -> PrimExpr -> PrimExpr
UnExpr :: UnOp -> PrimExpr -> PrimExpr
AggrExpr :: AggrOp -> PrimExpr -> PrimExpr
ConstExpr :: Literal -> PrimExpr
CaseExpr :: [(PrimExpr, PrimExpr)] -> PrimExpr -> PrimExpr
ListExpr :: [PrimExpr] -> PrimExpr
ParamExpr :: (Maybe Name) -> PrimExpr -> PrimExpr
FunExpr :: Name -> [PrimExpr] -> PrimExpr

-- | Cast an expression to a given type.
CastExpr :: Name -> PrimExpr -> PrimExpr
data OrderExpr
OrderExpr :: OrderOp -> PrimExpr -> OrderExpr
data BinOp
OpEq :: BinOp
OpLt :: BinOp
OpLtEq :: BinOp
OpGt :: BinOp
OpGtEq :: BinOp
OpNotEq :: BinOp
OpAnd :: BinOp
OpOr :: BinOp
OpLike :: BinOp
OpIn :: BinOp
OpOther :: String -> BinOp
OpCat :: BinOp
OpPlus :: BinOp
OpMinus :: BinOp
OpMul :: BinOp
OpDiv :: BinOp
OpMod :: BinOp
OpBitNot :: BinOp
OpBitAnd :: BinOp
OpBitOr :: BinOp
OpBitXor :: BinOp
OpAsg :: BinOp
data UnOp
OpNot :: UnOp
OpIsNull :: UnOp
OpIsNotNull :: UnOp
OpLength :: UnOp
UnOpOther :: String -> UnOp
data OrderOp
OpAsc :: OrderOp
OpDesc :: OrderOp
data AggrOp
AggrCount :: AggrOp
AggrSum :: AggrOp
AggrAvg :: AggrOp
AggrMin :: AggrOp
AggrMax :: AggrOp
AggrStdDev :: AggrOp
AggrStdDevP :: AggrOp
AggrVar :: AggrOp
AggrVarP :: AggrOp
AggrOther :: String -> AggrOp
data Literal
NullLit :: Literal

-- | represents a default value
DefaultLit :: Literal
BoolLit :: Bool -> Literal
StringLit :: String -> Literal
IntegerLit :: Integer -> Literal
DoubleLit :: Double -> Literal
DateLit :: CalendarTime -> Literal

-- | used for hacking in custom SQL
OtherLit :: String -> Literal

-- | Creates a projection of some attributes while keeping all other
--   attributes in the relation visible too.
extend :: Assoc -> PrimQuery -> PrimQuery

-- | Takes the cartesian product of two queries.
times :: PrimQuery -> PrimQuery -> PrimQuery

-- | Returns the schema (the attributes) of a query
attributes :: PrimQuery -> Scheme

-- | Returns all attributes in an expression.
attrInExpr :: PrimExpr -> Scheme

-- | Returns all attributes in a list of ordering expressions.
attrInOrder :: [OrderExpr] -> Scheme

-- | Substitute attribute names in an expression.
substAttr :: Assoc -> PrimExpr -> PrimExpr
isAggregate :: PrimExpr -> Bool

-- | Determines if a primitive expression represents a constant or is an
--   expression only involving constants.
isConstant :: PrimExpr -> Bool

-- | Fold on <a>PrimQuery</a>
foldPrimQuery :: (t, TableName -> Scheme -> t, Assoc -> t -> t, PrimExpr -> t -> t, RelOp -> t -> t -> t, Assoc -> t -> t, SpecialOp -> t -> t) -> PrimQuery -> t

-- | Fold on <a>PrimExpr</a>
foldPrimExpr :: (Attribute -> t, Literal -> t, BinOp -> t -> t -> t, UnOp -> t -> t, AggrOp -> t -> t, [(t, t)] -> t -> t, [t] -> t, Maybe Name -> t -> t, Name -> [t] -> t, Name -> t -> t) -> PrimExpr -> t
instance [overlap ok] Show RelOp
instance [overlap ok] Show OrderOp
instance [overlap ok] Read Literal
instance [overlap ok] Show Literal
instance [overlap ok] Show BinOp
instance [overlap ok] Read BinOp
instance [overlap ok] Show UnOp
instance [overlap ok] Read UnOp
instance [overlap ok] Show AggrOp
instance [overlap ok] Read AggrOp
instance [overlap ok] Read PrimExpr
instance [overlap ok] Show PrimExpr
instance [overlap ok] Show OrderExpr
instance [overlap ok] Show SpecialOp
instance [overlap ok] Show PrimQuery


-- | Defines standard optimizations performed on PrimQuery's (relational
--   expressions).
module Database.HaskellDB.Optimize

-- | Optimize a PrimQuery
optimize :: PrimQuery -> PrimQuery

-- | Optimize a set of criteria.
optimizeCriteria :: [PrimExpr] -> [PrimExpr]


-- | This is a replacement for some of TREX.
module Database.HaskellDB.HDBRec

-- | The empty record.
data RecNil
RecNil :: RecNil

-- | Constructor that adds a field to a record. f is the field tag, a is
--   the field value and b is the rest of the record.
data RecCons f a b
RecCons :: a -> b -> RecCons f a b

-- | The type used for records. This is a function that takes a
--   <a>RecNil</a> so that the user does not have to put a <a>RecNil</a> at
--   the end of every record.
type Record r = RecNil -> r

-- | The empty record
emptyRecord :: Record RecNil

-- | Creates one-field record from a label and a value
(.=.) :: l f a -> a -> Record (RecCons f a RecNil)

-- | Adds the field from a one-field record to another record.
(#) :: Record (RecCons f a RecNil) -> (b -> c) -> (b -> RecCons f a c)

-- | Class for field labels.
class FieldTag f
fieldName :: FieldTag f => f -> String

-- | The record <tt>r</tt> has the field <tt>f</tt> if there is an instance
--   of <tt>HasField f r</tt>.
class HasField f r
class Select f r a | f r -> a
(!) :: Select f r a => r -> f -> a
class SetField f r a
setField :: SetField f r a => l f a -> a -> r -> r
class RecCat r1 r2 r3 | r1 r2 -> r3
recCat :: RecCat r1 r2 r3 => r1 -> r2 -> r3
class ShowLabels r
recordLabels :: ShowLabels r => r -> [String]

-- | Convert a record to a list of label names and field values.
class ShowRecRow r
showRecRow :: ShowRecRow r => r -> [(String, ShowS)]
class ReadRecRow r
readRecRow :: ReadRecRow r => [(String, String)] -> [(r, [(String, String)])]
instance [overlap ok] Eq RecNil
instance [overlap ok] Ord RecNil
instance [overlap ok] (Eq a, Eq b) => Eq (RecCons f a b)
instance [overlap ok] (Ord a, Ord b) => Ord (RecCons f a b)
instance [overlap ok] (FieldTag a, Read b, ReadRecRow c) => Read (RecCons a b c)
instance [overlap ok] Read RecNil
instance [overlap ok] ReadRecRow r => Read (Record r)
instance [overlap ok] (FieldTag a, Read b, ReadRecRow c) => ReadRecRow (RecCons a b c)
instance [overlap ok] ReadRecRow RecNil
instance [overlap ok] (FieldTag a, Show b, ShowRecRow c) => Show (RecCons a b c)
instance [overlap ok] Show RecNil
instance [overlap ok] Show r => Show (Record r)
instance [overlap ok] ShowRecRow r => ShowRecRow (Record r)
instance [overlap ok] (FieldTag a, Show b, ShowRecRow c) => ShowRecRow (RecCons a b c)
instance [overlap ok] ShowRecRow RecNil
instance [overlap ok] ShowLabels r => ShowLabels (Record r)
instance [overlap ok] (FieldTag f, ShowLabels r) => ShowLabels (RecCons f a r)
instance [overlap ok] ShowLabels RecNil
instance [overlap ok] Ord r => Ord (Record r)
instance [overlap ok] Eq r => Eq (Record r)
instance [overlap ok] SetField f r a => SetField f (Record r) a
instance [overlap ok] SetField f r a => SetField f (RecCons g b r) a
instance [overlap ok] SetField f (RecCons f a r) a
instance [overlap ok] SelectField f r a => SelectField f (Record r) a
instance [overlap ok] SelectField f r a => SelectField f (RecCons g b r) a
instance [overlap ok] SelectField f (RecCons f a r) a
instance [overlap ok] SelectField f r a => Select (l f a) (Record r) a
instance [overlap ok] RecCat r1 r2 r3 => RecCat (Record r1) (Record r2) (Record r3)
instance [overlap ok] RecCat r1 r2 r3 => RecCat (RecCons f a r1) r2 (RecCons f a r3)
instance [overlap ok] RecCat RecNil r r
instance [overlap ok] HasField f r => HasField f (Record r)
instance [overlap ok] HasField f r => HasField f (RecCons g a r)
instance [overlap ok] HasField f (RecCons f a r)


-- | Basic combinators for building type-safe queries. The Query monad
--   constructs a relational expression (<a>PrimQuery</a>).
module Database.HaskellDB.Query

-- | Type of relations, contains the attributes of the relation and an
--   <a>Alias</a> to which the attributes are renamed in the
--   <a>PrimQuery</a>.
data Rel r
Rel :: Alias -> Scheme -> Rel r

-- | Typed attributes
data Attr f a
Attr :: Attribute -> Attr f a

-- | Basic tables, contains table name and an association from attributes
--   to attribute names in the real table.
data Table r
Table :: TableName -> Assoc -> Table r
data Query a

-- | Type of normal expressions, contains the untyped PrimExpr.
newtype Expr a
Expr :: PrimExpr -> Expr a
data OrderExpr
class ToPrimExprs r

-- | Converts records w/o Expr (usually from database queries) to records
--   with Expr types.
class ConstantRecord r cr | r -> cr
constantRecord :: ConstantRecord r cr => r -> cr
class ShowConstant a
showConstant :: ShowConstant a => a -> Literal

-- | Class of expression types.
class ExprC e
primExpr :: ExprC e => e a -> PrimExpr

-- | Class of expressions that can be used with <a>project</a>.
class ExprC e => ProjectExpr e

-- | Class of records that can be used with <a>project</a>. All all the
--   values must be instances of <a>ProjectExpr</a> for the record to be an
--   instance of <a>ProjectRec</a>.
class ProjectRec r er | r -> er

-- | Class of records that can be used with <tt>insert</tt>. All all the
--   values must be instances of <a>InsertExpr</a> for the record to be an
--   instance of <a>InsertRec</a>.
class InsertRec r er | r -> er

-- | Type of aggregate expressions.
newtype ExprAggr a
ExprAggr :: PrimExpr -> ExprAggr a

-- | The type of default expressions.
newtype ExprDefault a
ExprDefault :: PrimExpr -> ExprDefault a

-- | Creates a single-field record from an attribute and a table. Useful
--   for building projections that will re-use the same attribute name.
--   <tt>copy attr tbl</tt> is equivalent to:
--   
--   <pre>
--   attr .=. (tbl .!. attr)
--   </pre>
copy :: HasField f r => Attr f a -> Rel r -> Record (RecCons f (Expr a) RecNil)

-- | Copies all columns in the relation given. Useful for appending the
--   remaining columns in a table to a projection. For example:
--   
--   <pre>
--   query = do
--     tbl &lt;- table some_table
--     project $ copyAll tbl
--   </pre>
--   
--   will add all columns in "some_table" to the query.
copyAll :: RelToRec r => Rel r -> Record r

-- | Helper class which gives a polymorphic copy function that can turn a
--   Rel into a Record.
class RelToRec a

-- | Equality comparison on Exprs, = in SQL.
(.==.) :: Eq a => Expr a -> Expr a -> Expr Bool

-- | Inequality on Exprs, &lt;&gt; in SQL.
(.<>.) :: Eq a => Expr a -> Expr a -> Expr Bool
(.<.) :: Ord a => Expr a -> Expr a -> Expr Bool
(.<=.) :: Ord a => Expr a -> Expr a -> Expr Bool
(.>.) :: Ord a => Expr a -> Expr a -> Expr Bool
(.>=.) :: Ord a => Expr a -> Expr a -> Expr Bool

-- | "Logical and" on <a>Expr</a>, AND in SQL.
(.&&.) :: Expr Bool -> Expr Bool -> Expr Bool

-- | "Logical or" on <a>Expr</a>. OR in SQL.
(.||.) :: Expr Bool -> Expr Bool -> Expr Bool

-- | Multiplication
(.*.) :: Num a => Expr a -> Expr a -> Expr a

-- | Division
(./.) :: Num a => Expr a -> Expr a -> Expr a

-- | Addition
(.+.) :: Num a => Expr a -> Expr a -> Expr a

-- | Subtraction
(.-.) :: Num a => Expr a -> Expr a -> Expr a

-- | Modulo
(.%.) :: Num a => Expr a -> Expr a -> Expr a

-- | Concatenates two String-expressions.
(.++.) :: Expr String -> Expr String -> Expr String

-- | Creates a record field. Similar to '(.=.)', but gets the field label
--   from an <a>Attr</a>.
(<<) :: Attr f a -> e a -> Record (RecCons f (e a) RecNil)

-- | Convenience operator for constructing records of constants. Useful
--   primarily with <tt>insert</tt>. <tt>f &lt;&lt;- x</tt> is the same as
--   <tt>f &lt;&lt; constant x</tt>
(<<-) :: ShowConstant a => Attr f a -> a -> Record (RecCons f (Expr a) RecNil)

-- | Specifies a subset of the columns in the table.
project :: (ShowLabels r, ToPrimExprs r, ProjectRec r er) => Record r -> Query (Rel er)

-- | Restricts the records to only those who evaluates the expression to
--   True.
restrict :: Expr Bool -> Query ()

-- | Return all records from a specific table.
table :: ShowRecRow r => Table r -> Query (Rel r)

-- | Restricts the relation given to only return unique records. Upshot is
--   all projected attributes will be <tt>grouped</tt>.
unique :: Query ()

-- | Return all records which are present in at least one of the relations.
union :: Query (Rel r) -> Query (Rel r) -> Query (Rel r)

-- | UNION ALL
unionAll :: Query (Rel r) -> Query (Rel r) -> Query (Rel r)

-- | Return all records which are present in both relations.
intersect :: Query (Rel r) -> Query (Rel r) -> Query (Rel r)

-- | Not in SQL92.
divide :: Query (Rel r) -> Query (Rel r) -> Query (Rel r)

-- | Return all records from the first relation that are not present in the
--   second relation.
minus :: Query (Rel r) -> Query (Rel r) -> Query (Rel r)

-- | The inverse of an Expr Bool.
_not :: Expr Bool -> Expr Bool

-- | The HaskellDB counterpart to the SQL LIKE keyword. In the expresions,
--   % is a wildcard representing any characters in the same position
--   relavtive to the given characters and _ is a wildcard representing one
--   character e.g.
--   
--   <pre>
--   like (constant "ABCDEFFF") (constant "AB%F_F")
--   </pre>
--   
--   is true while
--   
--   <pre>
--   like (constant "ABCDEF") (constant "AC%F") 
--   </pre>
--   
--   is false.
--   
--   Note that SQL92 does not specify whether LIKE is case-sensitive or
--   not. Different database systems implement this differently.
like :: Expr String -> Expr String -> Expr Bool

-- | Returns true if the value of the first operand is equal to the value
--   of any of the expressions in the list operand.
_in :: Eq a => Expr a -> [Expr a] -> Expr Bool

-- | Produces the concatenation of two String-expressions.
cat :: Expr String -> Expr String -> Expr String

-- | Gets the length of a string.
_length :: Expr String -> Expr Int

-- | Returns true if the expression is Null.
isNull :: Expr a -> Expr Bool

-- | The inverse of <a>isNull</a>, returns false if the expression supplied
--   is Null.
notNull :: Expr a -> Expr Bool

-- | Takes a default value a and a nullable value. If the value is NULL,
--   the default value is returned, otherwise the value itself is returned.
--   Simliar to <tt>fromMaybe</tt>
fromNull :: Expr a -> Expr (Maybe a) -> Expr a

-- | Similar to fromNull, but takes a value argument rather than an Expr.
fromVal :: ShowConstant a => a -> Expr (Maybe a) -> Expr a

-- | Creates a constant expression from a haskell value.
constant :: ShowConstant a => a -> Expr a

-- | Turn constant data into a nullable expression. Same as <tt>constant .
--   Just</tt>
constVal :: ShowConstant a => a -> Expr (Maybe a)

-- | Represents a null value.
constNull :: Expr (Maybe a)

-- | Turn constant data into a nullable expression. Same as <tt>constant .
--   Just</tt>
constExpr :: Expr a -> Expr (Maybe a)

-- | Create an anonymous parameter with a default value.
param :: Expr a -> Expr a

-- | Create a named parameter with a default value.
namedParam :: Name -> Expr a -> Expr a

-- | Used to implement variable length arguments to <tt>func</tt>, below.
class Args a

-- | Can be used to define SQL functions which will appear in queries. Each
--   argument for the function is specified by its own Expr value. Examples
--   include:
--   
--   <pre>
--   lower :: Expr a -&gt; Expr (Maybe String) 
--   lower str = func "lower" str
--   </pre>
--   
--   The arguments to the function do not have to be Expr if they can be
--   converted to Expr:
--   
--   <pre>
--   data DatePart = Day | Century deriving Show 
--   </pre>
--   
--   <pre>
--   datePart :: DatePart -&gt; Expr (Maybe CalendarTime) -&gt; Expr (Maybe Int) 
--   datePart date col = func "date_part" (constant $ show date) col
--   </pre>
--   
--   Aggregate functions can also be defined. For example:
--   
--   <pre>
--   every :: Expr Bool -&gt; ExprAggr Bool 
--   every col = func "every" col
--   </pre>
--   
--   Aggregates are implemented to always take one argument, so any attempt
--   to define an aggregate with any more or less arguments will result in
--   an error.
--   
--   Note that type signatures are usually required for each function
--   defined, unless the arguments can be inferred.
func :: Args a => String -> a

-- | Generates a <tt>CAST</tt> expression for the given expression, using
--   the argument given as the destination type.
cast :: String -> Expr a -> Expr b

-- | Convert a bounded string to a real string.
toStr :: BStrToStr s d => s -> d

-- | Coerce the type of an expression to another type. Does not affect the
--   actual primitive value - only the <tt>phantom</tt> type.
coerce :: Expr a -> Expr b
select :: HasField f r => Attr f a -> Rel r -> Expr a

-- | Returns the number of records (=rows) in a query.
count :: Expr a -> ExprAggr Int

-- | Returns the total sum of a column.
_sum :: Num a => Expr a -> ExprAggr a

-- | Returns the highest value of a column.
_max :: Ord a => Expr a -> ExprAggr a

-- | Returns the lowest value of a column.
_min :: Ord a => Expr a -> ExprAggr a

-- | Returns the average of a column.
avg :: Num a => Expr a -> ExprAggr a

-- | Inserts the string literally - no escaping, no quoting.
literal :: String -> Expr a

-- | Returns the standard deviation of a column.
stddev :: Num a => Expr a -> ExprAggr a
stddevP :: Num a => Expr a -> ExprAggr a

-- | Returns the standard variance of a column.
variance :: Num a => Expr a -> ExprAggr a
varianceP :: Num a => Expr a -> ExprAggr a

-- | Use this together with the function <a>order</a> to order the results
--   of a query in ascending order. Takes a relation and an attribute of
--   that relation, which is used for the ordering.
asc :: HasField f r => Rel r -> Attr f a -> OrderExpr

-- | Use this together with the function <a>order</a> to order the results
--   of a query in descending order. Takes a relation and an attribute of
--   that relation, which is used for the ordering.
desc :: HasField f r => Rel r -> Attr f a -> OrderExpr

-- | Order the results of a query. Use this with the <a>asc</a> or
--   <a>desc</a> functions.
order :: [OrderExpr] -> Query ()

-- | Return the n topmost records.
top :: Int -> Query ()

-- | Skip the n topmost records.
offset :: Int -> Query ()

-- | Creates a conditional expression. Returns the value of the expression
--   corresponding to the first true condition. If none of the conditions
--   are true, the value of the else-expression is returned.
_case :: [(Expr Bool, Expr a)] -> Expr a -> Expr a

-- | The default value of the column. Only works with <tt>insert</tt>.
_default :: ExprDefault a
runQuery :: Query (Rel r) -> PrimQuery
runQueryRel :: Query (Rel r) -> (PrimQuery, Rel r)
unQuery :: Query a -> a

-- | Allows a subquery to be created between another query and this query.
--   Normally query definition is associative and query definition is
--   interleaved. This combinator ensures the given query is added as a
--   whole piece.
subQuery :: Query (Rel r) -> Query (Rel r)
attribute :: String -> Expr a
attributeName :: Attr f a -> Attribute

-- | Get the name of a table.
tableName :: Table t -> TableName
baseTable :: (ShowLabels r, ToPrimExprs r) => TableName -> Record r -> Table r

-- | For queries against fake tables, such as
--   'information_schema.information_schema_catalog_name'. Useful for
--   constructing queries that contain constant data (and do not select
--   from columns) but need a table to select from.
emptyTable :: TableName -> Table (Record RecNil)
exprs :: ToPrimExprs r => Record r -> [PrimExpr]
labels :: ShowLabels r => r -> [String]
tableRec :: Table (Record r) -> Record r
instance [overlap ok] Read (Expr a)
instance [overlap ok] Show (Expr a)
instance [overlap ok] Read (ExprAggr a)
instance [overlap ok] Show (ExprAggr a)
instance [overlap ok] Read (ExprDefault a)
instance [overlap ok] Show (ExprDefault a)
instance [overlap ok] (ExprC e, ToPrimExprs r) => ToPrimExprs (RecCons l (e a) r)
instance [overlap ok] ToPrimExprs RecNil
instance [overlap ok] Applicative Query
instance [overlap ok] Monad Query
instance [overlap ok] Functor Query
instance [overlap ok] (ShowConstant a, ConstantRecord r cr) => ConstantRecord (RecCons f a r) (RecCons f (Expr a) cr)
instance [overlap ok] ConstantRecord RecNil RecNil
instance [overlap ok] ConstantRecord r cr => ConstantRecord (Record r) (Record cr)
instance [overlap ok] Size n => ShowConstant (BoundedString n)
instance [overlap ok] ShowConstant a => ShowConstant (Maybe a)
instance [overlap ok] ShowConstant CalendarTime
instance [overlap ok] ShowConstant Bool
instance [overlap ok] ShowConstant Double
instance [overlap ok] ShowConstant Integer
instance [overlap ok] ShowConstant Int
instance [overlap ok] ShowConstant String
instance [overlap ok] Args (Expr a -> ExprAggr c)
instance [overlap ok] Args (Expr a)
instance [overlap ok] (IsExpr tail, Args tail) => Args (Expr a -> tail)
instance [overlap ok] IsExpr (Expr a)
instance [overlap ok] IsExpr tail => IsExpr (Expr a -> tail)
instance [overlap ok] BStrToStr (Expr String) (Expr String)
instance [overlap ok] BStrToStr (Expr (Maybe String)) (Expr (Maybe String))
instance [overlap ok] Size n => BStrToStr (Expr (Maybe (BoundedString n))) (Expr (Maybe String))
instance [overlap ok] Size n => BStrToStr (Expr (BoundedString n)) (Expr String)
instance [overlap ok] HasField f r => Select (Attr f a) (Rel r) (Expr a)
instance [overlap ok] (RelToRec rest, FieldTag f) => RelToRec (RecCons f (Expr a) rest)
instance [overlap ok] RelToRec RecNil
instance [overlap ok] (ProjectExpr e, ProjectRec r er) => ProjectRec (RecCons f (e a) r) (RecCons f (Expr a) er)
instance [overlap ok] ProjectRec RecNil RecNil
instance [overlap ok] ProjectExpr ExprAggr
instance [overlap ok] ProjectExpr Expr
instance [overlap ok] (InsertExpr e, InsertRec r er) => InsertRec (RecCons f (e a) r) (RecCons f (Expr a) er)
instance [overlap ok] InsertRec RecNil RecNil
instance [overlap ok] InsertExpr ExprDefault
instance [overlap ok] InsertExpr Expr
instance [overlap ok] ExprC ExprDefault
instance [overlap ok] ExprC ExprAggr
instance [overlap ok] ExprC Expr


-- | Defines the types of database columns, and functions for converting
--   these between HSQL and internal formats
module Database.HaskellDB.FieldType

-- | The type and <tt>nullable</tt> flag of a database column
type FieldDesc = (FieldType, Bool)

-- | A database column type
data FieldType
StringT :: FieldType
IntT :: FieldType
IntegerT :: FieldType
DoubleT :: FieldType
BoolT :: FieldType
CalendarTimeT :: FieldType
LocalTimeT :: FieldType
BStrT :: Int -> FieldType
toHaskellType :: FieldType -> String

-- | Class which retrieves a field description from a given type. Instances
--   are provided for most concrete types. Instances for Maybe
--   automatically make the field nullable, and instances for all (Expr a)
--   types where a has an ExprType instance allows type information to be
--   recovered from a given column expression.
class ExprType e
fromHaskellType :: ExprType e => e -> FieldDesc

-- | Class which returns a list of field descriptions. Gets the
--   descriptions of all columns in a Record/query. Most useful when the
--   columns associated with each field in a (Rel r) type must be
--   recovered. Note that this occurs at the type level only and no values
--   are inspected.
class ExprTypes r
fromHaskellTypes :: ExprTypes r => r -> [FieldDesc]

-- | Given a query, returns a list of the field names and their types used
--   by the query. Useful for recovering field information once a query has
--   been built up.
queryFields :: (ShowLabels r, ExprTypes r) => Query (Rel r) -> [(String, FieldDesc)]
instance [overlap ok] Typeable CalendarTime
instance [overlap ok] Eq FieldType
instance [overlap ok] Ord FieldType
instance [overlap ok] Show FieldType
instance [overlap ok] Read FieldType
instance [overlap ok] ExprTypes r => ExprTypes (Rel r)
instance [overlap ok] ExprTypes r => ExprTypes (Record r)
instance [overlap ok] (ExprType e, ExprTypes r) => ExprTypes (RecCons f e r)
instance [overlap ok] ExprTypes RecNil
instance [overlap ok] Size n => ExprType (BoundedString n)
instance [overlap ok] ExprType LocalTime
instance [overlap ok] ExprType CalendarTime
instance [overlap ok] ExprType Double
instance [overlap ok] ExprType Integer
instance [overlap ok] ExprType Int
instance [overlap ok] ExprType String
instance [overlap ok] ExprType Bool
instance [overlap ok] ExprType a => ExprType (Rel a)
instance [overlap ok] ExprType a => ExprType (Expr a)
instance [overlap ok] ExprType a => ExprType (Maybe a)


-- | The type of SQL generators.
module Database.HaskellDB.Sql.Generate
data SqlGenerator
SqlGenerator :: (PrimQuery -> SqlSelect) -> (TableName -> [PrimExpr] -> Assoc -> SqlUpdate) -> (TableName -> [PrimExpr] -> SqlDelete) -> (TableName -> Assoc -> SqlInsert) -> (TableName -> PrimQuery -> SqlInsert) -> (String -> SqlCreate) -> (TableName -> [(Attribute, FieldDesc)] -> SqlCreate) -> (String -> SqlDrop) -> (TableName -> SqlDrop) -> SqlSelect -> (TableName -> Scheme -> SqlSelect) -> (Assoc -> SqlSelect -> SqlSelect) -> (Assoc -> SqlSelect -> SqlSelect) -> (PrimExpr -> SqlSelect -> SqlSelect) -> (RelOp -> SqlSelect -> SqlSelect -> SqlSelect) -> (SpecialOp -> SqlSelect -> SqlSelect) -> (PrimExpr -> SqlExpr) -> (Literal -> String) -> (FieldType -> SqlType) -> (String -> String) -> SqlGenerator
sqlQuery :: SqlGenerator -> PrimQuery -> SqlSelect
sqlUpdate :: SqlGenerator -> TableName -> [PrimExpr] -> Assoc -> SqlUpdate
sqlDelete :: SqlGenerator -> TableName -> [PrimExpr] -> SqlDelete
sqlInsert :: SqlGenerator -> TableName -> Assoc -> SqlInsert
sqlInsertQuery :: SqlGenerator -> TableName -> PrimQuery -> SqlInsert
sqlCreateDB :: SqlGenerator -> String -> SqlCreate
sqlCreateTable :: SqlGenerator -> TableName -> [(Attribute, FieldDesc)] -> SqlCreate
sqlDropDB :: SqlGenerator -> String -> SqlDrop
sqlDropTable :: SqlGenerator -> TableName -> SqlDrop
sqlEmpty :: SqlGenerator -> SqlSelect
sqlTable :: SqlGenerator -> TableName -> Scheme -> SqlSelect
sqlProject :: SqlGenerator -> Assoc -> SqlSelect -> SqlSelect

-- | Ensures non-aggregate expressions in the select are included in group
--   by clause.
sqlGroup :: SqlGenerator -> Assoc -> SqlSelect -> SqlSelect
sqlRestrict :: SqlGenerator -> PrimExpr -> SqlSelect -> SqlSelect
sqlBinary :: SqlGenerator -> RelOp -> SqlSelect -> SqlSelect -> SqlSelect
sqlSpecial :: SqlGenerator -> SpecialOp -> SqlSelect -> SqlSelect
sqlExpr :: SqlGenerator -> PrimExpr -> SqlExpr
sqlLiteral :: SqlGenerator -> Literal -> String
sqlType :: SqlGenerator -> FieldType -> SqlType

-- | Turn a string into a quoted string. Quote characters and any escaping
--   are handled by this function.
sqlQuote :: SqlGenerator -> String -> String


-- | Default SQL generation.
module Database.HaskellDB.Sql.Default
mkSqlGenerator :: SqlGenerator -> SqlGenerator
defaultSqlGenerator :: SqlGenerator

-- | Creates a <a>SqlSelect</a> based on the <a>PrimQuery</a> supplied.
--   Corresponds to the SQL statement SELECT.
defaultSqlQuery :: SqlGenerator -> PrimQuery -> SqlSelect

-- | Creates a <a>SqlUpdate</a>. Corresponds to the SQL statement UPDATE
--   which updates data in a table.
defaultSqlUpdate :: SqlGenerator -> TableName -> [PrimExpr] -> Assoc -> SqlUpdate

-- | Creates a <a>SqlDelete</a>. Corresponds to the SQL statement DELETE
--   which deletes rows in a table.
defaultSqlDelete :: SqlGenerator -> TableName -> [PrimExpr] -> SqlDelete

-- | Creates a <a>SqlInsert</a>.
defaultSqlInsert :: SqlGenerator -> TableName -> Assoc -> SqlInsert

-- | Creates a <a>SqlInsert</a>. Corresponds to the SQL statement INSERT
--   INTO which is used to insert new rows in a table.
defaultSqlInsertQuery :: SqlGenerator -> TableName -> PrimQuery -> SqlInsert

-- | Use this to create a <a>SqlCreate</a> data type corresponding to the
--   SQL statement CREATE DATABASE which creates a new database.
defaultSqlCreateDB :: SqlGenerator -> String -> SqlCreate

-- | Use this to create a <a>SqlCreate</a> data type corresponding to the
--   SQL statement CREATE which creates a new table.
defaultSqlCreateTable :: SqlGenerator -> TableName -> [(Attribute, FieldDesc)] -> SqlCreate

-- | Creates a <a>SqlDrop</a> that delete the database with the name given
--   as the first argument.
defaultSqlDropDB :: SqlGenerator -> String -> SqlDrop

-- | Creates a <a>SqlDrop</a> that delete the database named in the first
--   argument.
defaultSqlDropTable :: SqlGenerator -> TableName -> SqlDrop
defaultSqlEmpty :: SqlGenerator -> SqlSelect
defaultSqlTable :: SqlGenerator -> TableName -> Scheme -> SqlSelect
defaultSqlProject :: SqlGenerator -> Assoc -> SqlSelect -> SqlSelect
defaultSqlRestrict :: SqlGenerator -> PrimExpr -> SqlSelect -> SqlSelect
defaultSqlBinary :: SqlGenerator -> RelOp -> SqlSelect -> SqlSelect -> SqlSelect

-- | Ensures the groupby value on the SqlSelect either preserves existing
--   grouping or that it will group on all columns (i.e, Mark == All).
defaultSqlGroup :: SqlGenerator -> Assoc -> SqlSelect -> SqlSelect
defaultSqlSpecial :: SqlGenerator -> SpecialOp -> SqlSelect -> SqlSelect
defaultSqlExpr :: SqlGenerator -> PrimExpr -> SqlExpr
defaultSqlLiteral :: SqlGenerator -> Literal -> String
defaultSqlType :: SqlGenerator -> FieldType -> SqlType
defaultSqlQuote :: SqlGenerator -> String -> String

-- | Make sure our SqlSelect statement is really a SqlSelect and not
--   another constructor.
toSqlSelect :: SqlSelect -> SqlSelect


-- | Author : Justin Bailey (jgbailey AT gmail DOT com) Pretty printing for
--   Query, PrimQuery, and SqlSelect values. Useful for debugging the
--   library.
module Database.HaskellDB.PrintQuery

-- | Optimize the query and pretty print the primitive representation.
ppQuery :: Query (Rel r) -> Doc

-- | Pretty print the primitive representation of an unoptimized query.
ppQueryUnOpt :: Query (Rel r) -> Doc

-- | Take a query, turn it into a SqlSelect and print it.
ppSelect :: Query (Rel r) -> Doc

-- | Take a query, turn it into a SqlSelect and print it, with
--   optimizations.
ppSelectUnOpt :: Query (Rel r) -> Doc
ppSqlSelect :: SqlSelect -> Doc

-- | Pretty print a PrimQuery value.
ppPrim :: PrimQuery -> Doc

-- | Take a query, turn it into a SqlSelect and print it.
ppSql :: Query (Rel r) -> Doc

-- | Take a query, turn it into a SqlSelect and print it.
ppSqlUnOpt :: Query (Rel r) -> Doc


-- | SQL generation for MySQL.
module Database.HaskellDB.Sql.MySQL
generator :: SqlGenerator


-- | SQL generation for SQLite. See <a>http://www.sqlite.org/lang.html</a>
--   for documentation.
module Database.HaskellDB.Sql.SQLite
generator :: SqlGenerator


-- | Defines standard database operations and the primitive hooks that a
--   particular database binding must provide.
module Database.HaskellDB.Database

-- | The (!.) operator selects over returned records from the database (=
--   rows) Non-overloaded version of <a>!</a>. For backwards compatibility.
(!.) :: Select f r a => r -> f -> a
data Database
Database :: (forall er vr. GetRec er vr => PrimQuery -> Rel er -> IO [Record vr]) -> (TableName -> Assoc -> IO ()) -> (TableName -> PrimQuery -> IO ()) -> (TableName -> [PrimExpr] -> IO ()) -> (TableName -> [PrimExpr] -> Assoc -> IO ()) -> IO [TableName] -> (TableName -> IO [(Attribute, FieldDesc)]) -> (forall a. IO a -> IO a) -> (String -> IO ()) -> (TableName -> [(Attribute, FieldDesc)] -> IO ()) -> (String -> IO ()) -> (TableName -> IO ()) -> IO () -> Database
dbQuery :: Database -> forall er vr. GetRec er vr => PrimQuery -> Rel er -> IO [Record vr]
dbInsert :: Database -> TableName -> Assoc -> IO ()
dbInsertQuery :: Database -> TableName -> PrimQuery -> IO ()
dbDelete :: Database -> TableName -> [PrimExpr] -> IO ()
dbUpdate :: Database -> TableName -> [PrimExpr] -> Assoc -> IO ()
dbTables :: Database -> IO [TableName]
dbDescribe :: Database -> TableName -> IO [(Attribute, FieldDesc)]
dbTransaction :: Database -> forall a. IO a -> IO a
dbCreateDB :: Database -> String -> IO ()
dbCreateTable :: Database -> TableName -> [(Attribute, FieldDesc)] -> IO ()
dbDropDB :: Database -> String -> IO ()
dbDropTable :: Database -> TableName -> IO ()
dbCommit :: Database -> IO ()
class GetRec er vr | er -> vr, vr -> er
getRec :: GetRec er vr => GetInstances s -> Rel er -> Scheme -> s -> IO (Record vr)

-- | Functions for getting values of a given type. Database drivers need to
--   implement these functions and pass this record to <a>getRec</a> when
--   getting query results.
--   
--   All these functions should return <a>Nothing</a> if the value is NULL.
data GetInstances s
GetInstances :: (s -> String -> IO (Maybe String)) -> (s -> String -> IO (Maybe Int)) -> (s -> String -> IO (Maybe Integer)) -> (s -> String -> IO (Maybe Double)) -> (s -> String -> IO (Maybe Bool)) -> (s -> String -> IO (Maybe CalendarTime)) -> (s -> String -> IO (Maybe LocalTime)) -> GetInstances s

-- | Get a <a>String</a> value.
getString :: GetInstances s -> s -> String -> IO (Maybe String)

-- | Get an <a>Int</a> value.
getInt :: GetInstances s -> s -> String -> IO (Maybe Int)

-- | Get an <a>Integer</a> value.
getInteger :: GetInstances s -> s -> String -> IO (Maybe Integer)

-- | Get a <a>Double</a> value.
getDouble :: GetInstances s -> s -> String -> IO (Maybe Double)

-- | Get a <a>Bool</a> value.
getBool :: GetInstances s -> s -> String -> IO (Maybe Bool)

-- | Get a <a>CalendarTime</a> value.
getCalendarTime :: GetInstances s -> s -> String -> IO (Maybe CalendarTime)

-- | Get a <a>LocalTime</a> value.
getLocalTime :: GetInstances s -> s -> String -> IO (Maybe LocalTime)
class GetValue a
getValue :: GetValue a => GetInstances s -> s -> String -> IO a

-- | performs a query on a database
query :: GetRec er vr => Database -> Query (Rel er) -> IO [Record vr]

-- | Inserts a record into a table
insert :: (ToPrimExprs r, ShowRecRow r, InsertRec r er) => Database -> Table er -> Record r -> IO ()

-- | deletes a bunch of records
delete :: ShowRecRow r => Database -> Table r -> (Rel r -> Expr Bool) -> IO ()

-- | Updates records
update :: (ShowLabels s, ToPrimExprs s) => Database -> Table r -> (Rel r -> Expr Bool) -> (Rel r -> Record s) -> IO ()

-- | Inserts values from a query into a table
insertQuery :: ShowRecRow r => Database -> Table r -> Query (Rel r) -> IO ()

-- | List all tables in the database
tables :: Database -> IO [TableName]

-- | List all columns in a table, along with their types
describe :: Database -> TableName -> IO [(Attribute, FieldDesc)]

-- | Performs some database action in a transaction. If no exception is
--   thrown, the changes are committed.
transaction :: Database -> IO a -> IO a

-- | Commit any pending data to the database.
commit :: Database -> IO ()

-- | Is not very useful. You need to be root to use it. We suggest you
--   solve this in another way
createDB :: Database -> String -> IO ()
createTable :: Database -> TableName -> [(Attribute, FieldDesc)] -> IO ()
dropDB :: Database -> String -> IO ()
dropTable :: Database -> TableName -> IO ()
instance [overlap ok] Size n => GetValue (Maybe (BoundedString n))
instance [overlap ok] GetValue (Maybe LocalTime)
instance [overlap ok] GetValue (Maybe CalendarTime)
instance [overlap ok] GetValue (Maybe Bool)
instance [overlap ok] GetValue (Maybe Double)
instance [overlap ok] GetValue (Maybe Integer)
instance [overlap ok] GetValue (Maybe Int)
instance [overlap ok] GetValue (Maybe String)
instance [overlap ok] Size n => GetValue (BoundedString n)
instance [overlap ok] GetValue LocalTime
instance [overlap ok] GetValue CalendarTime
instance [overlap ok] GetValue Bool
instance [overlap ok] GetValue Double
instance [overlap ok] GetValue Integer
instance [overlap ok] GetValue Int
instance [overlap ok] GetValue String
instance [overlap ok] (GetValue a, GetRec er vr) => GetRec (RecCons f (Expr a) er) (RecCons f a vr)
instance [overlap ok] GetRec RecNil RecNil


-- | This is the "core" file of the DBSpec files. It defines a DBInfo and
--   important functions on it.
module Database.HaskellDB.DBSpec.DBInfo

-- | Defines a database layout, top level
data DBInfo
DBInfo :: String -> DBOptions -> [TInfo] -> DBInfo

-- | The name of the database
dbname :: DBInfo -> String

-- | Any options (i.e whether to use Bounded Strings)
opts :: DBInfo -> DBOptions

-- | Tables this database contains
tbls :: DBInfo -> [TInfo]
data TInfo
TInfo :: String -> [CInfo] -> TInfo

-- | The name of the table
tname :: TInfo -> String

-- | The columns in this table
cols :: TInfo -> [CInfo]
data CInfo
CInfo :: String -> FieldDesc -> CInfo

-- | The name of this column
cname :: CInfo -> String

-- | The description of this column
descr :: CInfo -> FieldDesc
data DBOptions
DBOptions :: Bool -> MakeIdentifiers -> DBOptions

-- | Use Bounded Strings?
useBString :: DBOptions -> Bool

-- | Conversion routines from Database identifiers to Haskell identifiers
makeIdent :: DBOptions -> MakeIdentifiers

-- | Creates a DBInfo
makeDBSpec :: String -> DBOptions -> [TInfo] -> DBInfo

-- | Creates a TInfo
makeTInfo :: String -> [CInfo] -> TInfo

-- | Creates a CInfo
makeCInfo :: String -> FieldDesc -> CInfo

-- | Pretty prints a DBInfo
ppDBInfo :: DBInfo -> Doc
ppTInfo :: TInfo -> Doc
ppCInfo :: CInfo -> Doc
ppDBOptions :: DBOptions -> Doc

-- | Creates a valid declaration of a DBInfo. The variable name will be the
--   same as the database name
dbInfoToDoc :: DBInfo -> Doc

-- | Does a final "touching up" of a DBInfo before it is used by i.e
--   DBDirect. This converts any Bounded Strings to ordinary strings if
--   that flag is set.
finalizeSpec :: DBInfo -> DBInfo

-- | Constructs a DBInfo that doesn't cause nameclashes
constructNonClashingDBInfo :: DBInfo -> DBInfo
instance [overlap ok] Eq CInfo
instance [overlap ok] Show CInfo
instance [overlap ok] Eq TInfo
instance [overlap ok] Show TInfo
instance [overlap ok] Show DBInfo
instance [overlap ok] Show DBOptions


-- | Converts a DBSpec-generated database to a set of (FilePath,Doc), that
--   can be used to generate definition files usable in HaskellDB (the
--   generation itself is done in DBDirect)
module Database.HaskellDB.DBSpec.DBSpecToDBDirect

-- | Converts a database specification to a set of module names and module
--   contents. The first element of the returned list is the top-level
--   module.
specToHDB :: String -> DBInfo -> [(String, Doc)]

-- | Create module files in the given directory for the given DBInfo
dbInfoToModuleFiles :: FilePath -> String -> DBInfo -> IO ()


-- | Connects to a Database and generates a DBSpec specification from it.
module Database.HaskellDB.DBSpec.DatabaseToDBSpec

-- | Connects to a database and generates a specification from it
dbToDBSpec :: Bool -> MakeIdentifiers -> String -> Database -> IO DBInfo


-- | Connects to a database and generates stuff in it according to what's
--   inside the DBSpec.
module Database.HaskellDB.DBSpec.DBSpecToDatabase

-- | Converts a DBInfo to a real life Database, note that the database must
--   exist for this to work
dbSpecToDatabase :: Database -> DBInfo -> IO ()

-- | Create a database table specified by a <a>TInfo</a>.
tInfoToTable :: Database -> TInfo -> IO ()


-- | DBSpec is the new and improved way of specifying databases. It is
--   designed to be able to describe a database in such a way that it can
--   easily be converted to a DBDirect-spec OR directly into a database
module Database.HaskellDB.DBSpec

-- | Defines a database layout, top level
data DBInfo
DBInfo :: String -> DBOptions -> [TInfo] -> DBInfo

-- | The name of the database
dbname :: DBInfo -> String

-- | Any options (i.e whether to use Bounded Strings)
opts :: DBInfo -> DBOptions

-- | Tables this database contains
tbls :: DBInfo -> [TInfo]
data TInfo
TInfo :: String -> [CInfo] -> TInfo

-- | The name of the table
tname :: TInfo -> String

-- | The columns in this table
cols :: TInfo -> [CInfo]
data CInfo
CInfo :: String -> FieldDesc -> CInfo

-- | The name of this column
cname :: CInfo -> String

-- | The description of this column
descr :: CInfo -> FieldDesc
data DBOptions
DBOptions :: Bool -> MakeIdentifiers -> DBOptions

-- | Use Bounded Strings?
useBString :: DBOptions -> Bool

-- | Conversion routines from Database identifiers to Haskell identifiers
makeIdent :: DBOptions -> MakeIdentifiers

-- | The type and <tt>nullable</tt> flag of a database column
type FieldDesc = (FieldType, Bool)

-- | A database column type
data FieldType
StringT :: FieldType
IntT :: FieldType
IntegerT :: FieldType
DoubleT :: FieldType
BoolT :: FieldType
CalendarTimeT :: FieldType
LocalTimeT :: FieldType
BStrT :: Int -> FieldType

-- | Creates a DBInfo
makeDBSpec :: String -> DBOptions -> [TInfo] -> DBInfo

-- | Creates a TInfo
makeTInfo :: String -> [CInfo] -> TInfo

-- | Creates a CInfo
makeCInfo :: String -> FieldDesc -> CInfo

-- | Constructs a DBInfo that doesn't cause nameclashes
constructNonClashingDBInfo :: DBInfo -> DBInfo

-- | Pretty prints a DBInfo
ppDBInfo :: DBInfo -> Doc
ppTInfo :: TInfo -> Doc
ppCInfo :: CInfo -> Doc
ppDBOptions :: DBOptions -> Doc

-- | Creates a valid declaration of a DBInfo. The variable name will be the
--   same as the database name
dbInfoToDoc :: DBInfo -> Doc

-- | Does a final "touching up" of a DBInfo before it is used by i.e
--   DBDirect. This converts any Bounded Strings to ordinary strings if
--   that flag is set.
finalizeSpec :: DBInfo -> DBInfo

-- | Connects to a database and generates a specification from it
dbToDBSpec :: Bool -> MakeIdentifiers -> String -> Database -> IO DBInfo

-- | Converts a DBInfo to a real life Database, note that the database must
--   exist for this to work
dbSpecToDatabase :: Database -> DBInfo -> IO ()


-- | Exports every function needed by DBDirect generated files
module Database.HaskellDB.DBLayout

-- | <a>CalendarTime</a> is a user-readable and manipulable representation
--   of the internal <a>ClockTime</a> type.
data CalendarTime :: *

-- | A simple day and time aggregate, where the day is of the specified
--   parameter, and the time is a TimeOfDay. Conversion of this (as local
--   civil time) to UTC depends on the time zone. Conversion of this (as
--   local mean time) to UT1 depends on the longitude.
data LocalTime :: *

-- | Type of normal expressions, contains the untyped PrimExpr.
data Expr a

-- | Basic tables, contains table name and an association from attributes
--   to attribute names in the real table.
data Table r

-- | Typed attributes
data Attr f a
baseTable :: (ShowLabels r, ToPrimExprs r) => TableName -> Record r -> Table r

-- | Constructor that adds a field to a record. f is the field tag, a is
--   the field value and b is the rest of the record.
data RecCons f a b

-- | The empty record.
data RecNil

-- | Class for field labels.
class FieldTag f
fieldName :: FieldTag f => f -> String

-- | Constructs a table entry from a field tag
hdbMakeEntry :: FieldTag f => f -> Record (RecCons f (Expr a) RecNil)

-- | Make an <a>Attr</a> for a field.
mkAttr :: FieldTag f => f -> Attr f a

-- | Adds the field from a one-field record to another record.
(#) :: Record (RecCons f a RecNil) -> (b -> c) -> (b -> RecCons f a c)

-- | For queries against fake tables, such as
--   'information_schema.information_schema_catalog_name'. Useful for
--   constructing queries that contain constant data (and do not select
--   from columns) but need a table to select from.
emptyTable :: TableName -> Table (Record RecNil)


-- | SQL generation for PostgreSQL.
module Database.HaskellDB.Sql.PostgreSQL
generator :: SqlGenerator


-- | This exports an API that all drivers must conform to. It is used by
--   the end user to load drivers either dynamically or statically.
module Database.HaskellDB.DriverAPI

-- | Interface which drivers should implement. The <a>connect</a> function
--   takes some driver specific name, value pairs use to setup the database
--   connection, and a database action to run. <a>requiredOptions</a> lists
--   all required options with a short description, that is printed as help
--   in the DBDirect program.
data DriverInterface
DriverInterface :: (forall m a. MonadIO m => [(String, String)] -> (Database -> m a) -> m a) -> [(String, String)] -> DriverInterface
connect :: DriverInterface -> forall m a. MonadIO m => [(String, String)] -> (Database -> m a) -> m a
requiredOptions :: DriverInterface -> [(String, String)]

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)

-- | Default dummy driver, real drivers should overload this
defaultdriver :: DriverInterface

-- | Can be used by drivers to get option values from the given list of
--   name, value pairs.
getOptions :: Monad m => [String] -> [(String, String)] -> m [String]

-- | Can be used by drivers to get option values from the given list of
--   name, value pairs. It is intended for use with the
--   <a>requiredOptions</a> value of the driver.
getAnnotatedOptions :: Monad m => [(String, String)] -> [(String, String)] -> m [String]

-- | Gets an <a>SqlGenerator</a> from the "generator" option in the given
--   list. Currently available generators: "mysql", "postgresql", "sqlite",
--   "default"
getGenerator :: Monad m => [(String, String)] -> m SqlGenerator


-- | HaskellDB is a Haskell library for expressing database queries and
--   operations in a type safe and declarative way. HaskellDB compiles a
--   relational algebra-like syntax into SQL, submits the operations to the
--   database for processing, and returns the results as ordinary Haskell
--   values.
--   
--   This is the main module that the user should import. Beside this
--   module, the user should import a particular database binding (ie.
--   <a>Database.HaskellDB.HSQL.ODBC</a>) and database definitions.
--   
--   HaskellDB was originally written by Daan Leijen and it's design is
--   described in the paper Domain Specific Embedded Compilers, Daan Leijen
--   and Erik Meijer. 2nd USENIX Conference on Domain-Specific Languages
--   (DSL), Austin, USA, October 1999
--   (<a>http://www.usenix.org/events/dsl99/</a>).
--   
--   This new version of HaskellDB was produced as a student project at
--   Chalmers University of Technology in Gothenburg, Sweden. The aim of
--   the project was to make HaskellDB a practically useful database
--   library. That work is described in Student Paper: HaskellDB Improved,
--   Bjrn Bringert, Anders Hckersten, Conny Andersson, Martin Andersson,
--   Mary Bergman, Victor Blomqvist and Torbjrn Martin. In Proceedings of
--   the ACM SIGPLAN 2004 Haskell Workshop, Snowbird, Utah, USA, September
--   22, 2004. (<a>http://haskelldb.sourceforge.net/haskelldb.pdf</a>)
module Database.HaskellDB

-- | Type of relations, contains the attributes of the relation and an
--   <a>Alias</a> to which the attributes are renamed in the
--   <a>PrimQuery</a>.
data Rel r

-- | Typed attributes
data Attr f a

-- | Type of normal expressions, contains the untyped PrimExpr.
data Expr a

-- | Type of aggregate expressions.
data ExprAggr a

-- | Basic tables, contains table name and an association from attributes
--   to attribute names in the real table.
data Table r
data Query a
data OrderExpr

-- | The record <tt>r</tt> has the field <tt>f</tt> if there is an instance
--   of <tt>HasField f r</tt>.
class HasField f r

-- | The type used for records. This is a function that takes a
--   <a>RecNil</a> so that the user does not have to put a <a>RecNil</a> at
--   the end of every record.
type Record r = RecNil -> r
class Select f r a | f r -> a
(!) :: Select f r a => r -> f -> a

-- | Adds the field from a one-field record to another record.
(#) :: Record (RecCons f a RecNil) -> (b -> c) -> (b -> RecCons f a c)

-- | Creates a record field. Similar to '(.=.)', but gets the field label
--   from an <a>Attr</a>.
(<<) :: Attr f a -> e a -> Record (RecCons f (e a) RecNil)

-- | Convenience operator for constructing records of constants. Useful
--   primarily with <tt>insert</tt>. <tt>f &lt;&lt;- x</tt> is the same as
--   <tt>f &lt;&lt; constant x</tt>
(<<-) :: ShowConstant a => Attr f a -> a -> Record (RecCons f (Expr a) RecNil)

-- | The (!.) operator selects over returned records from the database (=
--   rows) Non-overloaded version of <a>!</a>. For backwards compatibility.
(!.) :: Select f r a => r -> f -> a

-- | Restricts the records to only those who evaluates the expression to
--   True.
restrict :: Expr Bool -> Query ()

-- | Return all records from a specific table.
table :: ShowRecRow r => Table r -> Query (Rel r)

-- | Specifies a subset of the columns in the table.
project :: (ShowLabels r, ToPrimExprs r, ProjectRec r er) => Record r -> Query (Rel er)

-- | Restricts the relation given to only return unique records. Upshot is
--   all projected attributes will be <tt>grouped</tt>.
unique :: Query ()

-- | Return all records which are present in at least one of the relations.
union :: Query (Rel r) -> Query (Rel r) -> Query (Rel r)

-- | Return all records which are present in both relations.
intersect :: Query (Rel r) -> Query (Rel r) -> Query (Rel r)

-- | Not in SQL92.
divide :: Query (Rel r) -> Query (Rel r) -> Query (Rel r)

-- | Return all records from the first relation that are not present in the
--   second relation.
minus :: Query (Rel r) -> Query (Rel r) -> Query (Rel r)

-- | Creates a single-field record from an attribute and a table. Useful
--   for building projections that will re-use the same attribute name.
--   <tt>copy attr tbl</tt> is equivalent to:
--   
--   <pre>
--   attr .=. (tbl .!. attr)
--   </pre>
copy :: HasField f r => Attr f a -> Rel r -> Record (RecCons f (Expr a) RecNil)

-- | Copies all columns in the relation given. Useful for appending the
--   remaining columns in a table to a projection. For example:
--   
--   <pre>
--   query = do
--     tbl &lt;- table some_table
--     project $ copyAll tbl
--   </pre>
--   
--   will add all columns in "some_table" to the query.
copyAll :: RelToRec r => Rel r -> Record r

-- | Allows a subquery to be created between another query and this query.
--   Normally query definition is associative and query definition is
--   interleaved. This combinator ensures the given query is added as a
--   whole piece.
subQuery :: Query (Rel r) -> Query (Rel r)

-- | Equality comparison on Exprs, = in SQL.
(.==.) :: Eq a => Expr a -> Expr a -> Expr Bool

-- | Inequality on Exprs, &lt;&gt; in SQL.
(.<>.) :: Eq a => Expr a -> Expr a -> Expr Bool
(.<.) :: Ord a => Expr a -> Expr a -> Expr Bool
(.<=.) :: Ord a => Expr a -> Expr a -> Expr Bool
(.>.) :: Ord a => Expr a -> Expr a -> Expr Bool
(.>=.) :: Ord a => Expr a -> Expr a -> Expr Bool

-- | "Logical and" on <a>Expr</a>, AND in SQL.
(.&&.) :: Expr Bool -> Expr Bool -> Expr Bool

-- | "Logical or" on <a>Expr</a>. OR in SQL.
(.||.) :: Expr Bool -> Expr Bool -> Expr Bool

-- | Multiplication
(.*.) :: Num a => Expr a -> Expr a -> Expr a

-- | Division
(./.) :: Num a => Expr a -> Expr a -> Expr a

-- | Addition
(.+.) :: Num a => Expr a -> Expr a -> Expr a

-- | Subtraction
(.-.) :: Num a => Expr a -> Expr a -> Expr a

-- | Modulo
(.%.) :: Num a => Expr a -> Expr a -> Expr a

-- | Concatenates two String-expressions.
(.++.) :: Expr String -> Expr String -> Expr String

-- | The inverse of an Expr Bool.
_not :: Expr Bool -> Expr Bool

-- | The HaskellDB counterpart to the SQL LIKE keyword. In the expresions,
--   % is a wildcard representing any characters in the same position
--   relavtive to the given characters and _ is a wildcard representing one
--   character e.g.
--   
--   <pre>
--   like (constant "ABCDEFFF") (constant "AB%F_F")
--   </pre>
--   
--   is true while
--   
--   <pre>
--   like (constant "ABCDEF") (constant "AC%F") 
--   </pre>
--   
--   is false.
--   
--   Note that SQL92 does not specify whether LIKE is case-sensitive or
--   not. Different database systems implement this differently.
like :: Expr String -> Expr String -> Expr Bool

-- | Returns true if the value of the first operand is equal to the value
--   of any of the expressions in the list operand.
_in :: Eq a => Expr a -> [Expr a] -> Expr Bool

-- | Produces the concatenation of two String-expressions.
cat :: Expr String -> Expr String -> Expr String

-- | Gets the length of a string.
_length :: Expr String -> Expr Int

-- | Returns true if the expression is Null.
isNull :: Expr a -> Expr Bool

-- | The inverse of <a>isNull</a>, returns false if the expression supplied
--   is Null.
notNull :: Expr a -> Expr Bool

-- | Takes a default value a and a nullable value. If the value is NULL,
--   the default value is returned, otherwise the value itself is returned.
--   Simliar to <tt>fromMaybe</tt>
fromNull :: Expr a -> Expr (Maybe a) -> Expr a

-- | Similar to fromNull, but takes a value argument rather than an Expr.
fromVal :: ShowConstant a => a -> Expr (Maybe a) -> Expr a

-- | Creates a constant expression from a haskell value.
constant :: ShowConstant a => a -> Expr a

-- | Turn constant data into a nullable expression. Same as <tt>constant .
--   Just</tt>
constVal :: ShowConstant a => a -> Expr (Maybe a)

-- | Represents a null value.
constNull :: Expr (Maybe a)

-- | Turn constant data into a nullable expression. Same as <tt>constant .
--   Just</tt>
constExpr :: Expr a -> Expr (Maybe a)

-- | Create an anonymous parameter with a default value.
param :: Expr a -> Expr a

-- | Create a named parameter with a default value.
namedParam :: Name -> Expr a -> Expr a

-- | Used to implement variable length arguments to <tt>func</tt>, below.
class Args a

-- | Can be used to define SQL functions which will appear in queries. Each
--   argument for the function is specified by its own Expr value. Examples
--   include:
--   
--   <pre>
--   lower :: Expr a -&gt; Expr (Maybe String) 
--   lower str = func "lower" str
--   </pre>
--   
--   The arguments to the function do not have to be Expr if they can be
--   converted to Expr:
--   
--   <pre>
--   data DatePart = Day | Century deriving Show 
--   </pre>
--   
--   <pre>
--   datePart :: DatePart -&gt; Expr (Maybe CalendarTime) -&gt; Expr (Maybe Int) 
--   datePart date col = func "date_part" (constant $ show date) col
--   </pre>
--   
--   Aggregate functions can also be defined. For example:
--   
--   <pre>
--   every :: Expr Bool -&gt; ExprAggr Bool 
--   every col = func "every" col
--   </pre>
--   
--   Aggregates are implemented to always take one argument, so any attempt
--   to define an aggregate with any more or less arguments will result in
--   an error.
--   
--   Note that type signatures are usually required for each function
--   defined, unless the arguments can be inferred.
func :: Args a => String -> a

-- | Get paramaters from a query in order.
queryParams :: Query (Rel r) -> [Param]

-- | Represents a query parameter. Left parameters are indexed by position,
--   while right parameters are named.
type Param = Either Int String

-- | Generates a <tt>CAST</tt> expression for the given expression, using
--   the argument given as the destination type.
cast :: String -> Expr a -> Expr b

-- | Coerce the type of an expression to another type. Does not affect the
--   actual primitive value - only the <tt>phantom</tt> type.
coerce :: Expr a -> Expr b

-- | Inserts the string literally - no escaping, no quoting.
literal :: String -> Expr a

-- | Convert a bounded string to a real string.
toStr :: BStrToStr s d => s -> d

-- | Returns the number of records (=rows) in a query.
count :: Expr a -> ExprAggr Int

-- | Returns the total sum of a column.
_sum :: Num a => Expr a -> ExprAggr a

-- | Returns the highest value of a column.
_max :: Ord a => Expr a -> ExprAggr a

-- | Returns the lowest value of a column.
_min :: Ord a => Expr a -> ExprAggr a

-- | Returns the average of a column.
avg :: Num a => Expr a -> ExprAggr a

-- | Returns the standard deviation of a column.
stddev :: Num a => Expr a -> ExprAggr a
stddevP :: Num a => Expr a -> ExprAggr a

-- | Returns the standard variance of a column.
variance :: Num a => Expr a -> ExprAggr a
varianceP :: Num a => Expr a -> ExprAggr a

-- | Use this together with the function <a>order</a> to order the results
--   of a query in ascending order. Takes a relation and an attribute of
--   that relation, which is used for the ordering.
asc :: HasField f r => Rel r -> Attr f a -> OrderExpr

-- | Use this together with the function <a>order</a> to order the results
--   of a query in descending order. Takes a relation and an attribute of
--   that relation, which is used for the ordering.
desc :: HasField f r => Rel r -> Attr f a -> OrderExpr

-- | Order the results of a query. Use this with the <a>asc</a> or
--   <a>desc</a> functions.
order :: [OrderExpr] -> Query ()

-- | Return the n topmost records.
top :: Int -> Query ()

-- | Skip the n topmost records.
offset :: Int -> Query ()

-- | Creates a conditional expression. Returns the value of the expression
--   corresponding to the first true condition. If none of the conditions
--   are true, the value of the else-expression is returned.
_case :: [(Expr Bool, Expr a)] -> Expr a -> Expr a

-- | The default value of the column. Only works with <tt>insert</tt>.
_default :: ExprDefault a
data Database

-- | performs a query on a database
query :: GetRec er vr => Database -> Query (Rel er) -> IO [Record vr]

-- | Concatenates two records.
recCat :: RecCat r1 r2 r3 => r1 -> r2 -> r3

-- | Inserts a record into a table
insert :: (ToPrimExprs r, ShowRecRow r, InsertRec r er) => Database -> Table er -> Record r -> IO ()

-- | deletes a bunch of records
delete :: ShowRecRow r => Database -> Table r -> (Rel r -> Expr Bool) -> IO ()

-- | Updates records
update :: (ShowLabels s, ToPrimExprs s) => Database -> Table r -> (Rel r -> Expr Bool) -> (Rel r -> Record s) -> IO ()

-- | Inserts values from a query into a table
insertQuery :: ShowRecRow r => Database -> Table r -> Query (Rel r) -> IO ()

-- | List all tables in the database
tables :: Database -> IO [TableName]

-- | List all columns in a table, along with their types
describe :: Database -> TableName -> IO [(Attribute, FieldDesc)]

-- | Performs some database action in a transaction. If no exception is
--   thrown, the changes are committed.
transaction :: Database -> IO a -> IO a

-- | Shows the optimized <a>PrimQuery</a>.
showQuery :: Query (Rel r) -> String

-- | Shows the unoptimized <a>PrimQuery</a>.
showQueryUnOpt :: Query (Rel r) -> String

-- | Shows the optimized SQL query.
showSql :: Query (Rel r) -> String

-- | Shows the unoptimized SQL query.
showSqlUnOpt :: Query (Rel r) -> String
instance [overlap ok] Show (Query (Rel r))


-- | DBDirect generates a Haskell module from a database. It first reads
--   the system catalog of the database into a <tt>Catalog</tt> data type.
--   After that it pretty prints that data structure in an appropiate
--   Haskell module which can be used to perform queries on the database.
module Database.HaskellDB.DBDirect
dbdirect :: DriverInterface -> IO ()
