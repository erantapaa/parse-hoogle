-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sql interpolating quasiquote plus some kind of primitive ORM
using it
--   
@package postgresql-query
@version 1.4.0

module Database.PostgreSQL.Query.SqlBuilder

-- | Builder wich can be effectively concatenated. Requires
--   <a>Connection</a> inside for string quoting implemented in
--   <b>libpq</b>
newtype SqlBuilder
SqlBuilder :: (Connection -> IO Builder) -> SqlBuilder
sqlBuild :: SqlBuilder -> Connection -> IO Builder

-- | Things which always can be transformed to <a>SqlBuilder</a>
class ToSqlBuilder a
toSqlBuilder :: ToSqlBuilder a => a -> SqlBuilder

-- | Special constructor to perform old-style query interpolation
data Qp
Qp :: Query -> row -> Qp

-- | Typed synonym of <a>mempty</a>
emptyB :: SqlBuilder

-- | Performs parameters interpolation and return ready to execute query
--   
--   <pre>
--   &gt;&gt;&gt; let val = 10
--   
--   &gt;&gt;&gt; let name = "field"
--   
--   &gt;&gt;&gt; runSqlBuilder c $ "SELECT * FROM tbl WHERE " &lt;&gt; mkIdent name &lt;&gt; " = " &lt;&gt; mkValue val
--   "SELECT * FROM tbl WHERE \"field\" = 10"
--   </pre>
runSqlBuilder :: Connection -> SqlBuilder -> IO Query

-- | Shorthand function to convert identifier name to builder
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder c $ mkIdent "simple\"ident"
--   "\"simple\"\"ident\""
--   </pre>
--   
--   Note correct string quoting made by <b>libpq</b>
mkIdent :: Text -> SqlBuilder

-- | Shorthand function to convert single value to builder
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder c $ mkValue "some ' value"
--   "'some '' value'"
--   </pre>
--   
--   Note correct string quoting
mkValue :: ToField a => a -> SqlBuilder

-- | Lift pure bytestring builder to <a>SqlBuilder</a>
sqlBuilderPure :: Builder -> SqlBuilder
sqlBuilderFromField :: ToField a => Query -> a -> SqlBuilder
instance Typeable SqlBuilder
instance Generic SqlBuilder
instance Datatype D1SqlBuilder
instance Constructor C1_0SqlBuilder
instance Selector S1_0_0SqlBuilder
instance Monoid SqlBuilder
instance ToSqlBuilder Text
instance ToSqlBuilder Text
instance ToSqlBuilder String
instance ToSqlBuilder ByteString
instance ToSqlBuilder ByteString
instance ToSqlBuilder Builder
instance ToSqlBuilder SqlBuilder
instance IsString SqlBuilder
instance ToSqlBuilder Qp

module Database.PostgreSQL.Query.TH.SqlExp

-- | Maybe the main feature of all library. Quasiquoter which builds
--   <tt>SqlBuilder</tt> from string query. Removes line comments and block
--   comments (even nested) and sequences of spaces. Correctly works
--   handles string literals and quoted identifiers. Here is examples of
--   usage
--   
--   <pre>
--   &gt;&gt;&gt; let name = "name"
--   
--   &gt;&gt;&gt; let val = "some 'value'"
--   
--   &gt;&gt;&gt; runSqlBuilder c [sqlExp|SELECT * FROM tbl WHERE ^{mkIdent name} = #{val}|]
--   "SELECT * FROM tbl WHERE \"name\" = 'some ''value'''"
--   </pre>
--   
--   And more comples example:
--   
--   <pre>
--   &gt;&gt;&gt; let name = Just "name"
--   
--   &gt;&gt;&gt; let size = Just 10
--   
--   &gt;&gt;&gt; let active = Nothing :: Maybe Bool
--   
--   &gt;&gt;&gt; let condlist = catMaybes [ fmap (\a -&gt; [sqlExp|name = #{a}|]) name, fmap (\a -&gt; [sqlExp|size = #{a}|]) size, fmap (\a -&gt; [sqlExp|active = #{a}|]) active]
--   
--   &gt;&gt;&gt; let cond = if L.null condlist then mempty else [sqlExp| WHERE ^{mconcat $ L.intersperse " AND " $ condlist} |]
--   
--   &gt;&gt;&gt; runSqlBuilder c [sqlExp|SELECT *   FROM tbl ^{cond} -- line comment|]
--   "SELECT * FROM tbl  WHERE name = 'name' AND size = 10  "
--   </pre>
sqlExp :: QuasiQuoter

-- | Internal type. Result of parsing sql string
data Rope

-- | Part of raw sql
RLit :: Text -> Rope

-- | Sql comment
RComment :: Text -> Rope

-- | Sequence of spaces
RSpaces :: Int -> Rope

-- | String with haskell expression inside <b>#{..}</b>
RInt :: Text -> Rope

-- | String with haskell expression inside <b>^{..}</b>
RPaste :: Text -> Rope
ropeParser :: Parser [Rope]
parseRope :: String -> [Rope]

-- | Removes sequential occurencies of <a>RLit</a> constructors. Also
--   removes commentaries and squash sequences of spaces to single space
--   symbol
squashRope :: [Rope] -> [Rope]

-- | Build <a>Query</a> expression from row
buildQ :: [Rope] -> Q Exp

-- | Build expression of type <tt>SqlBuilder</tt> from SQL query with
--   interpolation
sqlQExp :: String -> Q Exp

-- | Embed sql template and perform interpolation
--   
--   <pre>
--   let name = "name"
--       foo = "bar"
--       query = $(sqlExpEmbed "sql<i>foo</i>bar.sql") -- using <tt>foo</tt> and <tt>bar</tt> inside
--   </pre>
sqlExpEmbed :: String -> Q Exp

-- | Just like <a>sqlExpEmbed</a> but uses pattern instead of file name.
--   So, code
--   
--   <pre>
--   let query = $(sqlExpFile "foo/bar")
--   </pre>
--   
--   is just the same as
--   
--   <pre>
--   let query = $(sqlExpEmbed "sql<i>foo</i>bar.sql")
--   </pre>
--   
--   This function inspired by Yesod's <tt>widgetFile</tt>
sqlExpFile :: String -> Q Exp
instance Ord Rope
instance Eq Rope
instance Show Rope

module Database.PostgreSQL.Query.Types

-- | Instances of this typeclass can acquire connection and pass it to
--   computation. It can be reader of pool of connections or just reader of
--   connection
class MonadBase IO m => HasPostgres m
withPGConnection :: HasPostgres m => (Connection -> m a) -> m a

-- | Empty typeclass signing monad in which transaction is safe. i.e.
--   <a>PgMonadT</a> have this instance, but some other monad giving
--   connection from e.g. connection pool is not.
class TransactionSafe (m :: * -> *)

-- | Reader of connection. Has instance of <a>HasPostgres</a>. So if you
--   have a connection you can run queries in this monad using
--   <a>runPgMonadT</a>. Or you can use this transformer to run sequence of
--   queries using same connection with <a>launchPG</a>.
newtype PgMonadT m a
PgMonadT :: ReaderT Connection m a -> PgMonadT m a
unPgMonadT :: PgMonadT m a -> ReaderT Connection m a
runPgMonadT :: Connection -> PgMonadT m a -> m a

-- | If your monad have instance of <a>HasPostgres</a> you maybe dont need
--   this function, unless your instance use <tt>withPGPool</tt> which
--   acquires connection from pool for each query. If you want to run
--   sequence of queries using same connection you need this function
launchPG :: HasPostgres m => PgMonadT m a -> m a

-- | type to put and get from db <tt>inet</tt> and <tt>cidr</tt> typed
--   postgresql fields. This should be in postgresql-simple in fact.
newtype InetText
InetText :: Text -> InetText
unInetText :: InetText -> Text

-- | Dot-separated field name. Each element in nested list will be properly
--   quoted and separated by dot. It also have instance of
--   <a>ToSqlBuilder</a> and <a>IsString</a> so you can:
--   
--   <pre>
--   &gt;&gt;&gt; let a = "hello" :: FN
--   
--   &gt;&gt;&gt; a
--   FN ["hello"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let b = "user.name" :: FN
--   
--   &gt;&gt;&gt; b
--   FN ["user","name"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let n = "u.name" :: FN
--   
--   &gt;&gt;&gt; runSqlBuilder c $ toSqlBuilder n
--   "\"u\".\"name\""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("user" &lt;&gt; "name") :: FN
--   FN ["user","name"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a = "name" :: FN
--   
--   &gt;&gt;&gt; let b = "email" :: FN
--   
--   &gt;&gt;&gt; runSqlBuilder c [sqlExp|^{"u" &lt;&gt; a} = 'name', ^{"e" &lt;&gt; b} = 'email'|]
--   "\"u\".\"name\" = 'name', \"e\".\"email\" = 'email'"
--   </pre>
newtype FN
FN :: [Text] -> FN

-- | Single field to <a>FN</a>
--   
--   <pre>
--   &gt;&gt;&gt; textFN "hello"
--   FN ["hello"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; textFN "user.name"
--   FN ["user.name"]
--   </pre>
--   
--   Note that it does not split string to parts by point like instance of
--   <a>IsString</a> does
textFN :: Text -> FN

-- | Marked row is list of pairs of field name and some sql expression.
--   Used to generate queries like:
--   
--   <pre>
--   name = <tt>name</tt> AND size = 10 AND length = 20
--   </pre>
--   
--   or
--   
--   <pre>
--   UPDATE tbl SET name = <tt>name</tt>, size = 10, lenght = 20
--   </pre>
newtype MarkedRow
MR :: [(FN, SqlBuilder)] -> MarkedRow
unMR :: MarkedRow -> [(FN, SqlBuilder)]

-- | Turns marked row to query intercalating it with other builder
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder c $ mrToBuilder "AND" $ MR [("name", mkValue "petr"), ("email", mkValue "foo@bar.com")]
--   " \"name\" = 'petr' AND \"email\" = 'foo@bar.com' "
--   </pre>
mrToBuilder :: SqlBuilder -> MarkedRow -> SqlBuilder
class ToMarkedRow a
toMarkedRow :: ToMarkedRow a => a -> MarkedRow
instance Typeable InetText
instance Typeable FN
instance Typeable MarkedRow
instance IsString InetText
instance Eq InetText
instance Ord InetText
instance Read InetText
instance Show InetText
instance Monoid InetText
instance ToField InetText
instance Ord FN
instance Eq FN
instance Show FN
instance Monoid FN
instance Generic FN
instance Monoid MarkedRow
instance Generic MarkedRow
instance Functor m => Functor (PgMonadT m)
instance Applicative m => Applicative (PgMonadT m)
instance Monad m => Monad (PgMonadT m)
instance MonadWriter w m => MonadWriter w (PgMonadT m)
instance MonadState s m => MonadState s (PgMonadT m)
instance MonadError e m => MonadError e (PgMonadT m)
instance MonadTrans PgMonadT
instance Alternative m => Alternative (PgMonadT m)
instance MonadFix m => MonadFix (PgMonadT m)
instance MonadPlus m => MonadPlus (PgMonadT m)
instance MonadIO m => MonadIO (PgMonadT m)
instance MonadCont m => MonadCont (PgMonadT m)
instance MonadThrow m => MonadThrow (PgMonadT m)
instance MonadCatch m => MonadCatch (PgMonadT m)
instance MonadMask m => MonadMask (PgMonadT m)
instance MonadBase b m => MonadBase b (PgMonadT m)
instance MonadLogger m => MonadLogger (PgMonadT m)
instance Datatype D1FN
instance Constructor C1_0FN
instance Datatype D1MarkedRow
instance Constructor C1_0MarkedRow
instance Selector S1_0_0MarkedRow
instance TransactionSafe (PgMonadT m)
instance MonadBase IO m => HasPostgres (PgMonadT m)
instance MonadReader r m => MonadReader r (PgMonadT m)
instance MonadTransControl PgMonadT
instance MonadBaseControl b m => MonadBaseControl b (PgMonadT m)
instance (TransactionSafe m, Monoid w) => TransactionSafe (WriterT w m)
instance (TransactionSafe m, Monoid w) => TransactionSafe (WriterT w m)
instance TransactionSafe m => TransactionSafe (ContT r m)
instance TransactionSafe m => TransactionSafe (StateT s m)
instance TransactionSafe m => TransactionSafe (StateT s m)
instance TransactionSafe m => TransactionSafe (ReaderT r m)
instance TransactionSafe m => TransactionSafe (MaybeT m)
instance TransactionSafe m => TransactionSafe (IdentityT m)
instance TransactionSafe m => TransactionSafe (ExceptT e m)
instance TransactionSafe m => TransactionSafe (EitherT e m)
instance (MonadBase IO m, MonadBaseControl IO m, HGetable els (Pool Connection)) => HasPostgres (HReaderT els m)
instance (HasPostgres m, Monoid w) => HasPostgres (WriterT w m)
instance (HasPostgres m, Monoid w) => HasPostgres (WriterT w m)
instance HasPostgres m => HasPostgres (ContT r m)
instance HasPostgres m => HasPostgres (StateT s m)
instance HasPostgres m => HasPostgres (StateT s m)
instance HasPostgres m => HasPostgres (ReaderT r m)
instance HasPostgres m => HasPostgres (MaybeT m)
instance HasPostgres m => HasPostgres (IdentityT m)
instance HasPostgres m => HasPostgres (ExceptT e m)
instance HasPostgres m => HasPostgres (EitherT e m)
instance ToMarkedRow MarkedRow
instance IsString FN
instance ToSqlBuilder FN
instance FromField InetText

module Database.PostgreSQL.Query.Entity

-- | Auxiliary typeclass for data types which can map to rows of some
--   table. This typeclass is used inside functions like
--   <tt>pgSelectEntities</tt> to generate queries.
class Entity a where data family EntityId a :: *
tableName :: Entity a => Proxy a -> Text
fieldNames :: Entity a => Proxy a -> [Text]

-- | Entity with it's id
type Ent a = (EntityId a, a)
instance Typeable EntityId

module Database.PostgreSQL.Query.TH

-- | Derive <a>FromRow</a> instance. i.e. you have type like that
--   
--   <pre>
--   data Entity = Entity
--                 { eField :: Text
--                 , eField2 :: Int
--                 , efield3 :: Bool }
--   </pre>
--   
--   then <a>deriveFromRow</a> will generate this instance: instance
--   FromRow Entity where
--   
--   <pre>
--   instance FromRow Entity where
--       fromRow = Entity
--                 &lt;$&gt; field
--                 &lt;*&gt; field
--                 &lt;*&gt; field
--   </pre>
--   
--   Datatype must have just one constructor with arbitrary count of fields
deriveFromRow :: Name -> Q [Dec]

-- | derives <a>ToRow</a> instance for datatype like
--   
--   <pre>
--   data Entity = Entity
--                 { eField :: Text
--                 , eField2 :: Int
--                 , efield3 :: Bool }
--   </pre>
--   
--   it will derive instance like that:
--   
--   <pre>
--   instance ToRow Entity where
--        toRow (Entity e1 e2 e3) =
--            [ toField e1
--            , toField e2
--            , toField e3 ]
--   </pre>
deriveToRow :: Name -> Q [Dec]

-- | Derives instance for <a>Entity</a> using type name and field names.
--   Also generates type synonim for ID. E.g. code like this:
--   
--   <pre>
--   data Agent = Agent
--       { aName          :: !Text
--       , aAttributes    :: !HStoreMap
--       , aLongWeirdName :: !Int
--       } deriving (Ord, Eq, Show)
--   
--   $(deriveEntity
--     def { eoIdType        = ''Id
--         , eoTableName     = toUnderscore
--         , eoColumnNames   = toUnderscore . drop 1
--         , eoDeriveClasses =
--           [''Show, ''Read, ''Ord, ''Eq
--           , ''FromField, ''ToField, ''PathPiece]
--         }
--     ''Agent )
--   </pre>
--   
--   Will generate code like this:
--   
--   <pre>
--   instance Database.PostgreSQL.Query.Entity Agent where
--       newtype EntityId Agent
--           = AgentId {getAgentId :: Id}
--           deriving (Show, Read, Ord, Eq, FromField, ToField, PathPiece)
--       tableName _ = "agent"
--       fieldNames _ = ["name", "attributes", "long_weird_name"]
--   type AgentId = EntityId Agent
--   </pre>
--   
--   So, you dont need to write it by hands any more.
--   
--   NOTE: <tt>toUnderscore</tt> is from package <tt>inflections</tt> here
deriveEntity :: EntityOptions -> Name -> Q [Dec]

-- | Calls sequently <a>deriveFromRow</a> <a>deriveToRow</a>
--   <a>deriveEntity</a>. E.g. code like this:
--   
--   <pre>
--   data Agent = Agent
--       { aName          :: !Text
--       , aAttributes    :: !HStoreMap
--       , aLongWeirdName :: !Int
--       } deriving (Ord, Eq, Show)
--   
--   $(deriveEverything
--     def { eoIdType        = ''Id
--         , eoTableName     = toUnderscore
--         , eoColumnNames   = toUnderscore . drop 1
--         , eoDeriveClasses =
--           [''Show, ''Read, ''Ord, ''Eq
--           , ''FromField, ''ToField, ''PathPiece]
--         }
--     ''Agent )
--   </pre>
--   
--   will generate that:
--   
--   <pre>
--   instance ToRow Agent where
--       toRow (Agent a_aE3w a_aE3x a_aE3y)
--           = [toField a_aE3w, toField a_aE3x, toField a_aE3y]
--   instance FromRow Agent where
--     fromRow
--         = Agent <a>$</a> Database.PostgreSQL.Simple.FromRow.field
--           <a>*</a> Database.PostgreSQL.Simple.FromRow.field
--           <a>*</a> Database.PostgreSQL.Simple.FromRow.field
--   instance Database.PostgreSQL.Query.Entity Agent where
--       newtype EntityId Agent
--           = AgentId {getAgentId :: Id}
--           deriving (Show, Read, Ord, Eq, FromField, ToField, PathPiece)
--       tableName _ = "agent"
--       fieldNames _ = ["name", "attributes", "long_weird_name"]
--   type AgentId = EntityId Agent
--   </pre>
deriveEverything :: EntityOptions -> Name -> Q [Dec]

-- | Options for deriving <a>Entity</a>
data EntityOptions
EntityOptions :: (String -> String) -> (String -> String) -> [Name] -> Name -> EntityOptions

-- | Type name to table name converter
eoTableName :: EntityOptions -> String -> String

-- | Record field to column name converter
eoColumnNames :: EntityOptions -> String -> String

-- | Typeclasses to derive for Id
eoDeriveClasses :: EntityOptions -> [Name]

-- | Base type for Id
eoIdType :: EntityOptions -> Name

-- | <i>Deprecated: use <a>sqlExpEmbed</a> instead</i>
embedSql :: String -> Q Exp

-- | <i>Deprecated: use <a>sqlExpFile</a> instead</i>
sqlFile :: String -> Q Exp

-- | Maybe the main feature of all library. Quasiquoter which builds
--   <tt>SqlBuilder</tt> from string query. Removes line comments and block
--   comments (even nested) and sequences of spaces. Correctly works
--   handles string literals and quoted identifiers. Here is examples of
--   usage
--   
--   <pre>
--   &gt;&gt;&gt; let name = "name"
--   
--   &gt;&gt;&gt; let val = "some 'value'"
--   
--   &gt;&gt;&gt; runSqlBuilder c [sqlExp|SELECT * FROM tbl WHERE ^{mkIdent name} = #{val}|]
--   "SELECT * FROM tbl WHERE \"name\" = 'some ''value'''"
--   </pre>
--   
--   And more comples example:
--   
--   <pre>
--   &gt;&gt;&gt; let name = Just "name"
--   
--   &gt;&gt;&gt; let size = Just 10
--   
--   &gt;&gt;&gt; let active = Nothing :: Maybe Bool
--   
--   &gt;&gt;&gt; let condlist = catMaybes [ fmap (\a -&gt; [sqlExp|name = #{a}|]) name, fmap (\a -&gt; [sqlExp|size = #{a}|]) size, fmap (\a -&gt; [sqlExp|active = #{a}|]) active]
--   
--   &gt;&gt;&gt; let cond = if L.null condlist then mempty else [sqlExp| WHERE ^{mconcat $ L.intersperse " AND " $ condlist} |]
--   
--   &gt;&gt;&gt; runSqlBuilder c [sqlExp|SELECT *   FROM tbl ^{cond} -- line comment|]
--   "SELECT * FROM tbl  WHERE name = 'name' AND size = 10  "
--   </pre>
sqlExp :: QuasiQuoter

-- | Embed sql template and perform interpolation
--   
--   <pre>
--   let name = "name"
--       foo = "bar"
--       query = $(sqlExpEmbed "sql<i>foo</i>bar.sql") -- using <tt>foo</tt> and <tt>bar</tt> inside
--   </pre>
sqlExpEmbed :: String -> Q Exp

-- | Just like <a>sqlExpEmbed</a> but uses pattern instead of file name.
--   So, code
--   
--   <pre>
--   let query = $(sqlExpFile "foo/bar")
--   </pre>
--   
--   is just the same as
--   
--   <pre>
--   let query = $(sqlExpEmbed "sql<i>foo</i>bar.sql")
--   </pre>
--   
--   This function inspired by Yesod's <tt>widgetFile</tt>
sqlExpFile :: String -> Q Exp
instance Default EntityOptions

module Database.PostgreSQL.Query.Internal

-- | Build entity fields
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { fName :: Text, fSize :: Int }
--   
--   &gt;&gt;&gt; instance Entity Foo where {newtype EntityId Foo = FooId Int ; fieldNames _ = ["name", "size"] ; tableName _ = "foo"}
--   
--   &gt;&gt;&gt; runSqlBuilder con $ entityFields id id (Proxy :: Proxy Foo)
--   "\"name\", \"size\""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ entityFields ("id":) id (Proxy :: Proxy Foo)
--   "\"id\", \"name\", \"size\""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ entityFields (\l -&gt; ("id":l) ++ ["created"]) id (Proxy :: Proxy Foo)
--   "\"id\", \"name\", \"size\", \"created\""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ entityFields id ("f"&lt;&gt;) (Proxy :: Proxy Foo)
--   "\"f\".\"name\", \"f\".\"size\""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ entityFields ("f.id":) ("f"&lt;&gt;) (Proxy :: Proxy Foo)
--   "\"f\".\"id\", \"f\".\"name\", \"f\".\"size\""
--   </pre>
entityFields :: Entity a => ([FN] -> [FN]) -> (FN -> FN) -> Proxy a -> SqlBuilder

-- | Same as <a>entityFields</a> but prefixes list of names with <b>id</b>
--   field. This is shorthand function for often usage.
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { fName :: Text, fSize :: Int }
--   
--   &gt;&gt;&gt; instance Entity Foo where {newtype EntityId Foo = FooId Int ; fieldNames _ = ["name", "size"] ; tableName _ = "foo"}
--   
--   &gt;&gt;&gt; runSqlBuilder con $ entityFieldsId id (Proxy :: Proxy Foo)
--   "\"id\", \"name\", \"size\""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ entityFieldsId ("f"&lt;&gt;) (Proxy :: Proxy Foo)
--   "\"f\".\"id\", \"f\".\"name\", \"f\".\"size\""
--   </pre>
entityFieldsId :: Entity a => (FN -> FN) -> Proxy a -> SqlBuilder

-- | Generate SELECT query string for entity
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { fName :: Text, fSize :: Int }
--   
--   &gt;&gt;&gt; instance Entity Foo where {newtype EntityId Foo = FooId Int ; fieldNames _ = ["name", "size"] ; tableName _ = "foo"}
--   
--   &gt;&gt;&gt; runSqlBuilder con $ selectEntity (entityFieldsId id) (Proxy :: Proxy Foo)
--   "SELECT \"id\", \"name\", \"size\" FROM \"foo\""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ selectEntity (entityFieldsId ("f"&lt;&gt;)) (Proxy :: Proxy Foo)
--   "SELECT \"f\".\"id\", \"f\".\"name\", \"f\".\"size\" FROM \"foo\""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ selectEntity (entityFields id id) (Proxy :: Proxy Foo)
--   "SELECT \"name\", \"size\" FROM \"foo\""
--   </pre>
selectEntity :: Entity a => (Proxy a -> SqlBuilder) -> Proxy a -> SqlBuilder

-- | Generates SELECT FROM WHERE query with most used conditions
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { fName :: Text, fSize :: Int }
--   
--   &gt;&gt;&gt; instance Entity Foo where {newtype EntityId Foo = FooId Int ; fieldNames _ = ["name", "size"] ; tableName _ = "foo"}
--   
--   &gt;&gt;&gt; runSqlBuilder con $ selectEntitiesBy id (Proxy :: Proxy Foo) $ MR []
--   "SELECT \"name\", \"size\" FROM \"foo\""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ selectEntitiesBy id (Proxy :: Proxy Foo) $ MR [("name", mkValue "fooname")]
--   "SELECT \"name\", \"size\" FROM \"foo\" WHERE  \"name\" = 'fooname' "
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ selectEntitiesBy id (Proxy :: Proxy Foo) $ MR [("name", mkValue "fooname"), ("size", mkValue 10)]
--   "SELECT \"name\", \"size\" FROM \"foo\" WHERE  \"name\" = 'fooname' AND \"size\" = 10 "
--   </pre>
selectEntitiesBy :: (Entity a, ToMarkedRow b) => ([FN] -> [FN]) -> Proxy a -> b -> SqlBuilder

-- | Generates <b>INSERT INTO</b> query for any instance of <a>Entity</a>
--   and <a>ToRow</a>
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { fName :: Text, fSize :: Int }
--   
--   &gt;&gt;&gt; instance Entity Foo where {newtype EntityId Foo = FooId Int ; fieldNames _ = ["name", "size"] ; tableName _ = "foo"}
--   
--   &gt;&gt;&gt; instance ToRow Foo where { toRow Foo{..} = [toField fName, toField fSize] }
--   
--   &gt;&gt;&gt; runSqlBuilder con $ insertEntity $ Foo "Enterprise" 910
--   "INSERT INTO \"foo\" (\"name\", \"size\") VALUES ('Enterprise', 910)"
--   </pre>
insertEntity :: (Entity a, ToRow a) => a -> SqlBuilder

-- | Same as <a>insertEntity</a> but generates query to insert many queries
--   at same time
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { fName :: Text, fSize :: Int }
--   
--   &gt;&gt;&gt; instance Entity Foo where {newtype EntityId Foo = FooId Int ; fieldNames _ = ["name", "size"] ; tableName _ = "foo"}
--   
--   &gt;&gt;&gt; instance ToRow Foo where { toRow Foo{..} = [toField fName, toField fSize] }
--   
--   &gt;&gt;&gt; runSqlBuilder con $ insertManyEntities $ NL.fromList [Foo "meter" 1, Foo "table" 2, Foo "earth" 151930000000]
--   "INSERT INTO \"foo\" (\"name\",\"size\") VALUES ('meter',1),('table',2),('earth',151930000000)"
--   </pre>
insertManyEntities :: (Entity a, ToRow a) => NonEmpty a -> SqlBuilder

-- | Convert entity instance to marked row to perform inserts updates and
--   same stuff
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { fName :: Text, fSize :: Int }
--   
--   &gt;&gt;&gt; instance Entity Foo where {newtype EntityId Foo = FooId Int ; fieldNames _ = ["name", "size"] ; tableName _ = "foo"}
--   
--   &gt;&gt;&gt; instance ToRow Foo where { toRow Foo{..} = [toField fName, toField fSize] }
--   
--   &gt;&gt;&gt; runSqlBuilder con $ mrToBuilder ", " $ entityToMR $ Foo "Enterprise" 610
--   " \"name\" = 'Enterprise' ,  \"size\" = 610 "
--   </pre>
entityToMR :: (Entity a, ToRow a) => a -> MarkedRow

-- | Generates comma separated list of field names
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ buildFields ["u" &lt;&gt; "name", "u" &lt;&gt; "phone", "e" &lt;&gt; "email"]
--   "\"u\".\"name\", \"u\".\"phone\", \"e\".\"email\""
--   </pre>
buildFields :: [FN] -> SqlBuilder

-- | generates <b>UPDATE</b> query
--   
--   <pre>
--   &gt;&gt;&gt; let name = "%vip%"
--   
--   &gt;&gt;&gt; runSqlBuilder con $ updateTable "ships" (MR [("size", mkValue 15)]) [sqlExp|WHERE size &gt; 15 AND name NOT LIKE #{name}|]
--   "UPDATE \"ships\" SET  \"size\" = 15  WHERE size &gt; 15 AND name NOT LIKE '%vip%'"
--   </pre>
updateTable :: (ToSqlBuilder q, ToMarkedRow flds) => Text -> flds -> q -> SqlBuilder

-- | Generate INSERT INTO query for entity
--   
--   <pre>
--   &gt;&gt;&gt; runSqlBuilder con $ insertInto "foo" $ MR [("name", mkValue "vovka"), ("hobby", mkValue "president")]
--   "INSERT INTO \"foo\" (\"name\", \"hobby\") VALUES ('vovka', 'president')"
--   </pre>
insertInto :: ToMarkedRow b => Text -> b -> SqlBuilder

module Database.PostgreSQL.Query.Functions

-- | Execute query generated by <tt>SqlBuilder</tt>. Typical use case:
--   
--   <pre>
--   let userName = "Vovka Erohin" :: Text
--   pgQuery [sqlExp| SELECT id, name FROM users WHERE name = #{userName}|]
--   </pre>
--   
--   Or
--   
--   <pre>
--   let userName = "Vovka Erohin" :: Text
--   pgQuery $ Qp "SELECT id, name FROM users WHERE name = ?" [userName]
--   </pre>
--   
--   Which is almost the same. In both cases proper value escaping is
--   performed so you stay protected from sql injections.
pgQuery :: (HasPostgres m, MonadLogger m, ToSqlBuilder q, FromRow r) => q -> m [r]

-- | Execute arbitrary query and return count of affected rows
pgExecute :: (HasPostgres m, MonadLogger m, ToSqlBuilder q) => q -> m Int64

-- | Executes arbitrary query and parses it as entities and their ids
pgQueryEntities :: (ToSqlBuilder q, HasPostgres m, MonadLogger m, Entity a, FromRow a, FromField (EntityId a)) => q -> m [Ent a]

-- | Execute all queries inside one transaction. Rollback transaction on
--   exceptions
pgWithTransaction :: (HasPostgres m, MonadBaseControl IO m, TransactionSafe m) => m a -> m a

-- | Same as <a>pgWithTransaction</a> but executes queries inside savepoint
pgWithSavepoint :: (HasPostgres m, MonadBaseControl IO m, TransactionSafe m) => m a -> m a

-- | Wrapper for <a>withTransactionMode</a>: Execute an action inside a SQL
--   transaction with a given transaction mode.
pgWithTransactionMode :: (HasPostgres m, MonadBaseControl IO m, TransactionSafe m) => TransactionMode -> m a -> m a

-- | Wrapper for <a>withTransactionModeRetry</a>: Like
--   <a>pgWithTransactionMode</a>, but also takes a custom callback to
--   determine if a transaction should be retried if an SqlError occurs. If
--   the callback returns True, then the transaction will be retried. If
--   the callback returns False, or an exception other than an SqlError
--   occurs then the transaction will be rolled back and the exception
--   rethrown.
pgWithTransactionModeRetry :: (HasPostgres m, MonadBaseControl IO m, TransactionSafe m) => TransactionMode -> (SqlError -> Bool) -> m a -> m a

-- | Wrapper for <a>withTransactionSerializable</a>: Execute an action
--   inside of a <a>Serializable</a> transaction. If a serialization
--   failure occurs, roll back the transaction and try again. Be warned
--   that this may execute the IO action multiple times.
--   
--   A Serializable transaction creates the illusion that your program has
--   exclusive access to the database. This means that, even in a
--   concurrent setting, you can perform queries in sequence without having
--   to worry about what might happen between one statement and the next.
pgWithTransactionSerializable :: (HasPostgres m, MonadBaseControl IO m, TransactionSafe m) => m a -> m a

-- | Insert new entity and return it's id
pgInsertEntity :: (HasPostgres m, MonadLogger m, Entity a, ToRow a, FromField (EntityId a)) => a -> m (EntityId a)

-- | Insert many entities without returning list of id like
--   <a>pgInsertManyEntitiesId</a> does
pgInsertManyEntities :: (Entity a, HasPostgres m, MonadLogger m, ToRow a) => [a] -> m Int64

-- | Same as <a>pgInsertEntity</a> but insert many entities at one action.
--   Returns list of id's of inserted entities
pgInsertManyEntitiesId :: (Entity a, HasPostgres m, MonadLogger m, ToRow a, FromField (EntityId a)) => [a] -> m [EntityId a]

-- | Select entities as pairs of (id, entity).
--   
--   <pre>
--   handler :: Handler [Ent a]
--   handler = do
--       now &lt;- liftIO getCurrentTime
--       let back = addUTCTime (days  (-7)) now
--       pgSelectEntities id
--           [sqlExp|WHERE created BETWEEN #{now} AND #{back}
--                  ORDER BY created|]
--   
--   handler2 :: Text -&gt; Handler [Ent Foo]
--   handler2 fvalue = do
--       pgSelectEntities ("t"&lt;&gt;)
--           [sqlExp|AS t INNER JOIN table2 AS t2
--                   ON t.t2_id = t2.id
--                   WHERE t.field = #{fvalue}
--                   ORDER BY t2.field2|]
--      -- Here the query will be: SELECT ... FROM tbl AS t INNER JOIN ...
--   </pre>
pgSelectEntities :: (Functor m, HasPostgres m, MonadLogger m, Entity a, FromRow a, ToSqlBuilder q, FromField (EntityId a)) => (FN -> FN) -> q -> m [Ent a]

-- | Same as <a>pgSelectEntities</a> but do not select id
pgSelectJustEntities :: (Functor m, HasPostgres m, MonadLogger m, Entity a, FromRow a, ToSqlBuilder q) => (FN -> FN) -> q -> m [a]

-- | Select entities by condition formed from <a>MarkedRow</a>. Usefull
--   function when you know
pgSelectEntitiesBy :: (Functor m, HasPostgres m, MonadLogger m, Entity a, ToMarkedRow b, FromRow a, FromField (EntityId a)) => b -> m [Ent a]

-- | Select entity by id
--   
--   <pre>
--   getUser :: EntityId User -&gt;  Handler User
--   getUser uid = do
--       pgGetEntity uid
--           &gt;&gt;= maybe notFound return
--   </pre>
pgGetEntity :: (ToField (EntityId a), Entity a, HasPostgres m, MonadLogger m, FromRow a, Functor m) => EntityId a -> m (Maybe a)

-- | Get entity by some fields constraint
--   
--   <pre>
--   getUser :: UserName -&gt; Handler User
--   getUser name = do
--       pgGetEntityBy
--           (MR [("name", mkValue name),
--                ("active", mkValue True)])
--           &gt;&gt;= maybe notFound return
--   </pre>
--   
--   The query here will be like
--   
--   <pre>
--   pgQuery [sqlExp|SELECT id, name, phone ... FROM users WHERE name = {True}|]
--   </pre>
pgGetEntityBy :: (Entity a, HasPostgres m, MonadLogger m, ToMarkedRow b, FromField (EntityId a), FromRow a, Functor m) => b -> m (Maybe (Ent a))

-- | Delete entity.
--   
--   <pre>
--   rmUser :: EntityId User -&gt; Handler ()
--   rmUser uid = do
--       pgDeleteEntity uid
--   </pre>
--   
--   Return <a>True</a> if row was actually deleted.
pgDeleteEntity :: (Entity a, HasPostgres m, MonadLogger m, ToField (EntityId a), Functor m) => EntityId a -> m Bool

-- | Update entity using <a>ToMarkedRow</a> instanced value. Requires
--   <a>Proxy</a> while <a>EntityId</a> is not a data type.
--   
--   <pre>
--   fixUser :: Text -&gt; EntityId User -&gt; Handler ()
--   fixUser username uid = do
--       pgGetEntity uid
--           &gt;&gt;= maybe notFound run
--     where
--       run user =
--           pgUpdateEntity uid
--           $ MR [("active", mkValue True)
--                 ("name", mkValue username)]
--   </pre>
--   
--   Returns <a>True</a> if record was actually updated and <a>False</a> if
--   there was not row with such id (or was more than 1, in fact)
pgUpdateEntity :: (ToMarkedRow b, Entity a, HasPostgres m, MonadLogger m, ToField (EntityId a), Functor m, Typeable a, Typeable b) => EntityId a -> b -> m Bool

-- | Select count of entities with given query
--   
--   <pre>
--   activeUsers :: Handler Integer
--   activeUsers = do
--       pgSelectCount (Proxy :: Proxy User)
--           [sqlExp|WHERE active = #{True}|]
--   </pre>
pgSelectCount :: (Entity a, HasPostgres m, MonadLogger m, ToSqlBuilder q) => Proxy a -> q -> m Integer

-- | Perform repsert of the same row, first trying "update where" then
--   "insert" with concatenated fields. Which means that if you run
--   
--   <pre>
--   pgRepsertRow "emails" (MR [("user_id", mkValue uid)]) (MR [("email", mkValue email)])
--   </pre>
--   
--   Then firstly will be performed
--   
--   <pre>
--   UPDATE "emails" SET email = 'foo@bar.com' WHERE "user_id" = 1234
--   </pre>
--   
--   And if no one row is affected (which is returned by <a>pgExecute</a>),
--   then
--   
--   <pre>
--   INSERT INTO "emails" ("user_id", "email") VALUES (1234, 'foo@bar.com')
--   </pre>
--   
--   will be performed
pgRepsertRow :: (HasPostgres m, MonadLogger m, ToMarkedRow wrow, ToMarkedRow urow) => Text -> wrow -> urow -> m ()

module Database.PostgreSQL.Query
data Connection :: *

-- | Connect with the given username to the given database. Will throw an
--   exception if it cannot connect.
connect :: ConnectInfo -> IO Connection

-- | Default information for setting up a connection.
--   
--   Defaults are as follows:
--   
--   <ul>
--   <li>Server on <tt>localhost</tt></li>
--   <li>Port on <tt>5432</tt></li>
--   <li>User <tt>postgres</tt></li>
--   <li>No password</li>
--   <li>Database <tt>postgres</tt></li>
--   </ul>
--   
--   Use as in the following example:
--   
--   <pre>
--   connect defaultConnectInfo { connectHost = "db.example.com" }
--   </pre>
defaultConnectInfo :: ConnectInfo

-- | Attempt to make a connection based on a libpq connection string. See
--   <a>http://www.postgresql.org/docs/9.3/static/libpq-connect.html#LIBPQ-CONNSTRING</a>
--   for more information. Here is an example with some of the most
--   commonly used parameters:
--   
--   <pre>
--   host='db.somedomain.com' port=5432 ...
--   </pre>
--   
--   This attempts to connect to <tt>db.somedomain.com:5432</tt>. Omitting
--   the port will normally default to 5432.
--   
--   On systems that provide unix domain sockets, omitting the host
--   parameter will cause libpq to attempt to connect via unix domain
--   sockets. The default filesystem path to the socket is constructed from
--   the port number and the <tt>DEFAULT_PGSOCKET_DIR</tt> constant defined
--   in the <tt>pg_config_manual.h</tt> header file. Connecting via unix
--   sockets tends to use the <tt>peer</tt> authentication method, which is
--   very secure and does not require a password.
--   
--   On Windows and other systems without unix domain sockets, omitting the
--   host will default to <tt>localhost</tt>.
--   
--   <pre>
--   ... dbname='postgres' user='postgres' password='secret \' \\ pw'
--   </pre>
--   
--   This attempts to connect to a database named <tt>postgres</tt> with
--   user <tt>postgres</tt> and password <tt>secret ' \ pw</tt>. Backslash
--   characters will have to be double-quoted in literal Haskell strings,
--   of course. Omitting <tt>dbname</tt> and <tt>user</tt> will both
--   default to the system username that the client process is running as.
--   
--   Omitting <tt>password</tt> will default to an appropriate password
--   found in the <tt>pgpass</tt> file, or no password at all if a matching
--   line is not found. See
--   <a>http://www.postgresql.org/docs/9.3/static/libpq-pgpass.html</a> for
--   more information regarding this file.
--   
--   As all parameters are optional and the defaults are sensible, the
--   empty connection string can be useful for development and exploratory
--   use, assuming your system is set up appropriately.
--   
--   On Unix, such a setup would typically consist of a local postgresql
--   server listening on port 5432, as well as a system user, database
--   user, and database sharing a common name, with permissions granted to
--   the user on the database.
--   
--   On Windows, in addition you will either need <tt>pg_hba.conf</tt> to
--   specify the use of the <tt>trust</tt> authentication method for the
--   connection, which may not be appropriate for multiuser or production
--   machines, or you will need to use a <tt>pgpass</tt> file with the
--   <tt>password</tt> or <tt>md5</tt> authentication methods.
--   
--   See
--   <a>http://www.postgresql.org/docs/9.3/static/client-authentication.html</a>
--   for more information regarding the authentication process.
--   
--   SSL/TLS will typically "just work" if your postgresql server supports
--   or requires it. However, note that libpq is trivially vulnerable to a
--   MITM attack without setting additional SSL parameters in the
--   connection string. In particular, <tt>sslmode</tt> needs to set be
--   <tt>require</tt>, <tt>verify-ca</tt>, or <tt>verify-full</tt> to
--   perform certificate validation. When <tt>sslmode</tt> is
--   <tt>require</tt>, then you will also need to have a
--   <tt>sslrootcert</tt> file, otherwise no validation of the server's
--   identity will be performed. Client authentication via certificates is
--   also possible via the <tt>sslcert</tt> and <tt>sslkey</tt> parameters.
connectPostgreSQL :: ByteString -> IO Connection
data ConnectInfo :: *
ConnectInfo :: String -> Word16 -> String -> String -> String -> ConnectInfo
connectHost :: ConnectInfo -> String
connectPort :: ConnectInfo -> Word16
connectUser :: ConnectInfo -> String
connectPassword :: ConnectInfo -> String
connectDatabase :: ConnectInfo -> String

-- | A type that may be used as a single parameter to a SQL query.
class ToField a
toField :: ToField a => a -> Action

-- | A collection type that can be turned into a list of rendering
--   <a>Action</a>s.
--   
--   Instances should use the <a>toField</a> method of the <a>ToField</a>
--   class to perform conversion of each element of the collection.
class ToRow a
toRow :: ToRow a => a -> [Action]

-- | A type that may be converted from a SQL type.
class FromField a
fromField :: FromField a => FieldParser a

-- | A collection type that can be converted from a sequence of fields.
--   Instances are provided for tuples up to 10 elements and lists of any
--   length.
--   
--   Note that instances can be defined outside of postgresql-simple, which
--   is often useful. For example, here's an instance for a user-defined
--   pair:
--   
--   @data User = User { name :: String, fileQuota :: Int }
--   
--   instance <a>FromRow</a> User where fromRow = User &lt;$&gt;
--   <a>field</a> &lt;*&gt; <a>field</a> @
--   
--   The number of calls to <a>field</a> must match the number of fields
--   returned in a single row of the query result. Otherwise, a
--   <a>ConversionFailed</a> exception will be thrown.
--   
--   Note that <a>field</a> evaluates it's result to WHNF, so the caveats
--   listed in mysql-simple and very early versions of postgresql-simple no
--   longer apply. Instead, look at the caveats associated with
--   user-defined implementations of <a>fromField</a>.
class FromRow a
fromRow :: FromRow a => RowParser a

-- | A query string. This type is intended to make it difficult to
--   construct a SQL query by concatenating string fragments, as that is an
--   extremely common way to accidentally introduce SQL injection
--   vulnerabilities into an application.
--   
--   This type is an instance of <a>IsString</a>, so the easiest way to
--   construct a query is to enable the <tt>OverloadedStrings</tt> language
--   extension and then simply write the query in double quotes.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Database.PostgreSQL.Simple
--   
--   q :: Query
--   q = "select ?"
--   </pre>
--   
--   The underlying type is a <a>ByteString</a>, and literal Haskell
--   strings that contain Unicode characters will be correctly transformed
--   to UTF-8.
newtype Query :: *
Query :: ByteString -> Query
fromQuery :: Query -> ByteString

-- | A single-value "collection".
--   
--   This is useful if you need to supply a single parameter to a SQL
--   query, or extract a single column from a SQL result.
--   
--   Parameter example:
--   
--   <pre>
--   query c "select x from scores where x &gt; ?" (<a>Only</a> (42::Int))
--   </pre>
--   
--   Result example:
--   
--   <pre>
--   xs &lt;- query_ c "select id from users"
--   forM_ xs $ \(<a>Only</a> id) -&gt; {- ... -}
--   </pre>
newtype Only a :: * -> *
Only :: a -> Only a
fromOnly :: Only a -> a

-- | Wrap a list of values for use in an <tt>IN</tt> clause. Replaces a
--   single "<tt>?</tt>" character with a parenthesized list of rendered
--   values.
--   
--   Example:
--   
--   <pre>
--   query c "select * from whatever where id in ?" (Only (In [3,4,5]))
--   </pre>
newtype In a :: * -> *
In :: a -> In a
newtype Oid :: *
Oid :: CUInt -> Oid

-- | Represents a <tt>VALUES</tt> table literal, usable as an alternative
--   to <tt>executeMany</tt> and <tt>returning</tt>. The main advantage is
--   that you can parametrize more than just a single <tt>VALUES</tt>
--   expression. For example, here's a query to insert a thing into one
--   table and some attributes of that thing into another, returning the
--   new id generated by the database:
--   
--   <pre>
--   query c [sql|
--       WITH new_thing AS (
--         INSERT INTO thing (name) VALUES (?) RETURNING id
--       ), new_attributes AS (
--         INSERT INTO thing_attributes
--            SELECT new_thing.id, attrs.*
--              FROM new_thing JOIN ? attrs
--       ) SELECT * FROM new_thing
--    |] ("foo", Values [  "int4", "text"    ]
--                      [ ( 1    , "hello" )
--                      , ( 2    , "world" ) ])
--   </pre>
--   
--   (Note this example uses writable common table expressions, which were
--   added in PostgreSQL 9.1)
--   
--   The second parameter gets expanded into the following SQL syntax:
--   
--   <pre>
--   (VALUES (1::"int4",'hello'::"text"),(2,'world'))
--   </pre>
--   
--   When the list of attributes is empty, the second parameter expands to:
--   
--   <pre>
--   (VALUES (null::"int4",null::"text") LIMIT 0)
--   </pre>
--   
--   By contrast, <tt>executeMany</tt> and <tt>returning</tt> don't issue
--   the query in the empty case, and simply return <tt>0</tt> and
--   <tt>[]</tt> respectively. This behavior is usually correct given their
--   intended use cases, but would certainly be wrong in the example above.
--   
--   The first argument is a list of postgresql type names. Because this is
--   turned into a properly quoted identifier, the type name is case
--   sensitive and must be as it appears in the <tt>pg_type</tt> table.
--   Thus, you must write <tt>timestamptz</tt> instead of <tt>timestamp
--   with time zone</tt>, <tt>int4</tt> instead of <tt>integer</tt>,
--   <tt>_int8</tt> instead of <tt>bigint[]</tt>, etcetera.
--   
--   You may omit the type names, however, if you do so the list of values
--   must be non-empty, and postgresql must be able to infer the types of
--   the columns from the surrounding context. If the first condition is
--   not met, postgresql-simple will throw an exception without issuing the
--   query. In the second case, the postgres server will return an error
--   which will be turned into a <tt>SqlError</tt> exception.
--   
--   See <a>http://www.postgresql.org/docs/9.3/static/sql-values.html</a>
--   for more information.
data Values a :: * -> *
Values :: [QualifiedIdentifier] -> [a] -> Values a

-- | A composite type to parse your custom data structures without having
--   to define dummy newtype wrappers every time.
--   
--   <pre>
--   instance FromRow MyData where ...
--   </pre>
--   
--   <pre>
--   instance FromRow MyData2 where ...
--   </pre>
--   
--   then I can do the following for free:
--   
--   <pre>
--   res &lt;- query' c "..."
--   forM res $ \(MyData{..} :. MyData2{..}) -&gt; do
--     ....
--   </pre>
data (:.) h t :: * -> * -> *
(:.) :: h -> t -> (:.) h t

-- | Wrap a list for use as a PostgreSQL array.
newtype PGArray a :: * -> *
PGArray :: [a] -> PGArray a
fromPGArray :: PGArray a -> [a]
newtype HStoreList :: *
HStoreList :: [(Text, Text)] -> HStoreList
fromHStoreList :: HStoreList -> [(Text, Text)]
newtype HStoreMap :: *
HStoreMap :: Map Text Text -> HStoreMap
fromHStoreMap :: HStoreMap -> Map Text Text
class ToHStore a
toHStore :: ToHStore a => a -> HStoreBuilder

-- | Represents valid hstore syntax.
data HStoreBuilder :: *
hstore :: (ToHStoreText a, ToHStoreText b) => a -> b -> HStoreBuilder
parseHStoreList :: ByteString -> Either String HStoreList
class ToHStoreText a
toHStoreText :: ToHStoreText a => a -> HStoreText

-- | Represents escape text, ready to be the key or value to a hstore value
data HStoreText :: *

-- | <i>Deprecated: Use <a>sqlExp</a> instead</i>
sqlQQ :: QuasiQuoter
