-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | This library will help you generate Haskell empty Generic instances  and deriving type instances from the top automatically to the bottom for composited data types.
--   
@package derive-topdown
@version 0.0.0.2

module Data.Derive.TopDown.Utils
getCxtTyVarCons :: Name -> Q (Cxt, [TyVarBndr], [Con])
getCxtTyVarCons' :: Type -> Q (Cxt, [TyVarBndr], [Con])
applyContext :: Name -> [Name] -> Q [Pred]


-- | <pre>
--   data A a b = A a (B b) deriving (Show)
--   data B a = B a deriving (Show)
--   
--   derivings ''Eq makeEq ''A 
--   </pre>
--   
--   If you enable -ddump-splices, you will get:
--   
--   <pre>
--   
--   Data\Derive\TopDown\Test.hs:1:1: Splicing declarations
--      derives ''Eq makeEq ''A
--    ======&gt;
--      Data\Derive\TopDown\Test.hs:18:1-25
--      instance Eq a_1627720873 =&gt; Eq (B a_1627720873) where
--        (==) (B x1) (B y1) = (x1 == y1)
--      instance (Eq a_1627720874, Eq b_1627720875) =&gt;
--               Eq (A a_1627720874 b_1627720875) where
--        (==) (A x1 x2) (A y1 y2) = ((x1 == y1) &amp;&amp; (x2 == y2))
--   </pre>
--   
--   This will make sense if you have a deep composited data types, nomally
--   an AST of a language. For now, you have to specify both of ''Eq and
--   makeEq, I suppose ''Eq will be enough. To look what typeclasses you
--   can derive, see <a>derive</a> library on hackage.
module Data.Derive.TopDown.Derive

-- | deriving from top
derivings :: Name -> Derivation -> Name -> Q [Dec]
instance Lift Name


-- | An example to generate Out class for Person, Name and Address. Out
--   class has to provide a default implementation for the function it
--   declears.
--   
--   <pre>
--   data Person = Person Names Address 
--               | Student Names Address 
--                 deriving (Show, Generic, Eq, Ord , Data,Typeable)
--   data Names  = Names String 
--                 deriving (Show, Generic, Eq, Ord, Data, Typeable)
--   data Address = Address Gate
--                 deriving (Show, Generic, Eq, Ord, Typeable, Data)
--   
--   type Gate = PF
--   
--   data PF = PF String deriving (Data, Typeable, Generic, Ord,Eq,Show)
--   </pre>
--   
--   For generating 4 empty instances
--   
--   <pre>
--   instance Out Person
--   instnace Out Nmads
--   instance Out Address
--   instance Out Gate
--   </pre>
--   
--   you just write:
--   
--   <pre>
--   instances ''Out ''Person
--   </pre>
--   
--   It will generate all instances that form Person and including Person.
--   
--   If you use :set -ddump-splices, you will get
--   
--   <pre>
--    instances ''Out  ''Person
--    ======&gt;
--    ~\Test.hs:13:1-18
--      instance Out Names
--      instance Out Gate
--      instance Out Address
--      instance Out Person
--   Ok, modules loaded: CompositeDataInstancesGen, Main.
--   </pre>
--   
--   You can also use instnaceList to generate a list of class.
module Data.Derive.TopDown.Generic
(-->) :: Name -> Name -> Q [Dec]

-- | Synatx sugar
instances :: Name -> Name -> Q [Dec]

-- | Generate instances for a list of classes with default implementation
instanceList :: Name -> [Name] -> Q [Dec]
