-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The LDAP Data Interchange Format (LDIF) tools
--   
--   LDIF files parser implementation using Parsec. The LDAP Data
--   Interchange Format (LDIF) is defined by RFC 2849.
--   
--   Current implementation is not complete and compliant with RFC.
--   
--   Package includes following command line tools:
--   
--   <ul>
--   <li>ldifdiff - calculates delta LDIF between two content LDIF
--   files.</li>
--   <li>ldif2html - produces HTML/browsable LDIF file.</li>
--   <li>ldifmodify - replays delta LDIF operations on content LDIF
--   (similar to ldapmodify).</li>
--   <li>ldifundo - produces delta LDIF which rollbacks operations in input
--   LDIF.</li>
--   </ul>
@package ldif
@version 0.0.13

module Text.LDIF.Preproc

-- | Preprocessing of LDIF file, concat wrapped lines and remove comment
--   lines
preproc :: ByteString -> (ByteString, PosTable)

-- | Convert error position to original text before preprocessing
transposePos :: PosTable -> ParseError -> ParseError

-- | Opaque data necessary for relation between text after preprocessing
--   and original
type PosTable = [PosOp]
instance Show PosOp

module Text.LDIF.Consts

-- | Chars with special meaning in DN
specialDNChars :: [Char]

-- | Chars necessary to be escaped in DN when they are part of value
escapedDNChars :: [Char]


-- | LDIF related types
module Text.LDIF.Types

-- | Represents LDIF structure, it can be either simply LDIF data dump or
--   changes LDIF with LDAP operations
data LDIF
LDIF :: Maybe ByteString -> ![LDIFRecord] -> LDIF
lcVersion :: LDIF -> Maybe ByteString
lcEntries :: LDIF -> ![LDIFRecord]
data LDIFRecord

-- | Represents one data record within LDIF file with DN and content
ContentRecord :: !DN -> ![AttrValue] -> LDIFRecord
reDN :: LDIFRecord -> !DN
coAttrVals :: LDIFRecord -> ![AttrValue]

-- | Represents one change record within LDIF file with DN and content
ChangeRecord :: !DN -> !Change -> LDIFRecord
reDN :: LDIFRecord -> !DN
chOp :: LDIFRecord -> !Change

-- | Represents one LDAP operation within changes LDIF
data Change
ChangeAdd :: ![AttrValue] -> Change
chAttrVals :: Change -> ![AttrValue]
ChangeDelete :: Change
ChangeModify :: ![Modify] -> Change
chMods :: Change -> ![Modify]
ChangeModDN :: Change

-- | Represents ChangeModify operations upon one entry within given DN
data Modify
ModAdd :: !Attribute -> ![Value] -> Modify
modAttr :: Modify -> !Attribute
modAttrVals :: Modify -> ![Value]
ModDelete :: !Attribute -> ![Value] -> Modify
modAttr :: Modify -> !Attribute
modAttrVals :: Modify -> ![Value]
ModReplace :: !Attribute -> ![Value] -> Modify
modAttr :: Modify -> !Attribute
modAttrVals :: Modify -> ![Value]

-- | Represents Distinguished Name (DN)
data DN
DN :: ![AttrValue] -> DN
dnAttrVals :: DN -> ![AttrValue]

-- | Enumeration LDIF Types
data LDIFType

-- | LDIF with Content Records
LDIFContentType :: LDIFType

-- | LDIF with Changes Records
LDIFChangesType :: LDIFType

-- | LDIF with both Content and Changes Records
LDIFMixedType :: LDIFType

-- | Attribute name is case-insensitive string
data Attribute
Attribute :: ByteString -> Attribute
aName :: Attribute -> ByteString

-- | Attribute value is either case sensitive or insensitive string
data Value
Value :: ByteString -> Value
aVal :: Value -> ByteString
ValueI :: ByteString -> Value
aVal :: Value -> ByteString

-- | Pair of Atribute and Value
type AttrValue = (Attribute, Value)

-- | Check if LDIFRecord is Content Record
isContentRecord :: LDIFRecord -> Bool

-- | Check if LDIFRecord is Change Record
isChangeRecord :: LDIFRecord -> Bool

-- | Dettect from LDIF content the Type (Content, Changes, Mixed)
getLDIFType :: LDIF -> LDIFType
instance Show Attribute
instance Show Value
instance Eq LDIFType
instance Show Modify
instance Eq Modify
instance Show Change
instance Eq Change
instance Eq DN
instance Show DN
instance Show LDIFRecord
instance Eq LDIFRecord
instance Show LDIF
instance Eq LDIF
instance Ord DN
instance Show LDIFType
instance Ord Value
instance Eq Value
instance Ord Attribute
instance Eq Attribute

module Text.LDIF.Parser

-- | Parse LDIF content
parseLDIFStr :: LDIFParserConfig -> FilePath -> ByteString -> Either ParseError LDIF

-- | Parse LDIF file
parseLDIFFile :: LDIFParserConfig -> FilePath -> IO (Either ParseError LDIF)

-- | Parse DN
parseDNStr :: LDIFParserConfig -> ByteString -> Either ParseError DN

-- | Preprocessing of LDIF file, concat wrapped lines and remove comment
--   lines
preproc :: ByteString -> (ByteString, PosTable)

-- | Default configuration for parser (Any LDIF Type, Case Sensitive)
defaulLDIFConf :: LDIFParserConfig

-- | LDIF Parser configuration
data LDIFParserConfig

-- | Parse as Case Sensitive LDIF
LDIFParserConfig :: Maybe LDIFType -> Bool -> LDIFParserConfig

-- | Type of LDIF expected
lpExpectedType :: LDIFParserConfig -> Maybe LDIFType
lpCaseSensitive :: LDIFParserConfig -> Bool
instance Show LDIFParserConfig


-- | LDIF serializers
module Text.LDIF.Printer

-- | Serialize LDIF in LDIF Format
ldif2str :: LDIF -> ByteString

-- | Serialize version to LDIF Format Lines
ver2str :: Maybe ByteString -> [ByteString]

-- | Serialize DN to LDIF Format
dn2str :: DN -> ByteString

-- | Serialize Content Record in LDIF Format
record2str :: LDIFRecord -> ByteString


-- | LDIF related operations
module Text.LDIF.Utils
type LDIFCache = Map DN LDIFRecord
createLookupTable :: LDIF -> LDIFCache

-- | Find all Contents with given DN
findRecordsByDN :: LDIF -> DN -> [LDIFRecord]

-- | Find first Content with given DN
findRecordByDN :: LDIFCache -> DN -> Maybe LDIFRecord

-- | Find fist Attribute within attributes pairs list
lookupAttr :: ByteString -> [AttrValue] -> Maybe Value

-- | Filter Attribute Value list according Attribute name
filterAttr :: ByteString -> [AttrValue] -> [AttrValue]

-- | Change record without any impact
isDummyRecord :: LDIFRecord -> Bool
leafOfDN :: DN -> AttrValue
rootOfDN :: DN -> AttrValue
lengthOfDN :: DN -> Int
getDNValue :: DN -> Int -> AttrValue
takeDNPrefix :: DN -> Int -> DN

-- | Check if the dn1 is prefix of dn2
isDNPrefixOf :: DN -> DN -> Bool
isParentRecordOf :: LDIFRecord -> LDIFRecord -> Bool

-- | Make LDIF Values case-insensitive
ldif2ldifI :: LDIF -> LDIF

module Text.LDIF.Diff

-- | Calculate Change LDIF between two LDIF contents. If there is not
--   difference the empty change list is returned.
diffLDIF :: LDIF -> LDIF -> Either String LDIF

-- | Calculate difference between two LDIF Records
diffRecord :: LDIFRecord -> LDIFRecord -> Maybe LDIFRecord

-- | Compare two LDIFs and provide list of the Records for each input LDIF,
--   which are different or not present in the other LDIF.
compareLDIF :: LDIF -> LDIF -> ([LDIFRecord], [LDIFRecord])

module Text.LDIF.Apply

-- | Apply operations in second LDIF on content of first LDIF. The
--   destination LDIF has to be Content LDIF.
applyLDIF :: LDIF -> LDIF -> LDIF


-- | LDIF representation in Data.Tree structure
module Text.LDIF.Tree

-- | Convert LDIF to Tree of Records using their DNs. Can insert dummy
--   parents.
toTree :: LDIF -> Bool -> Tree LDIFRecord

-- | Flatten Tree of Records to LDIF
fromTree :: Tree LDIFRecord -> LDIF

-- | Sort recursively children Records by DNs
sortTreeByName :: Tree LDIFRecord -> Tree LDIFRecord

module Text.LDIF.Undo

-- | Calculate undo LDIF
undoLDIF :: LDIF -> (LDIF, [[Warning]])

module Text.LDIF
