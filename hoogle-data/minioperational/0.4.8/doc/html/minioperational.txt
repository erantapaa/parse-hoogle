-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | fast and simple operational monad
--   
@package minioperational
@version 0.4.8

module Control.Monad.Operational.TH
makeSingletons :: Name -> Q [Dec]


-- | Just for compatibility
module Control.Monad.Operational.Class
type (:!) t m = Elevate t m
singleton :: Elevate f g => f a -> g a


-- | Simple operational monad
module Control.Monad.Operational.Mini

-- | Program t is a <a>Monad</a> that represents a sequence of imperatives.
--   To construct imperatives, use <a>singleton</a> :: t a -&gt; Program t
--   a.
newtype Program t a
Program :: (forall r. (a -> r) -> (forall x. t x -> (x -> r) -> r) -> r) -> Program t a
unProgram :: Program t a -> forall r. (a -> r) -> (forall x. t x -> (x -> r) -> r) -> r

-- | Interpret a <a>Program</a> using the given transformation.
interpret :: Monad m => (forall x. t x -> m x) -> Program t a -> m a
cloneProgram :: (Monad m, Elevate t m) => Program t a -> m a

-- | Reified version of <a>Program</a>. It is useful for testing.
data ReifiedProgram t a
Return :: a -> ReifiedProgram t a
(:>>=) :: t a -> (a -> ReifiedProgram t b) -> ReifiedProgram t b
fromReified :: ReifiedProgram t a -> Program t a
instance Tower (ReifiedProgram t)
instance Monad (ReifiedProgram t)
instance Applicative (ReifiedProgram t)
instance Functor (ReifiedProgram t)
instance Tower (Program t)
instance Monad (Program t)
instance Applicative (Program t)
instance Functor (Program t)


-- | Simple operational monad transformer
module Control.Monad.Trans.Operational.Mini
newtype ProgramT t m a
ProgramT :: (forall r. (a -> r) -> (m r -> r) -> (forall x. t x -> (x -> r) -> r) -> r) -> ProgramT t m a
unProgramT :: ProgramT t m a -> forall r. (a -> r) -> (m r -> r) -> (forall x. t x -> (x -> r) -> r) -> r
unProgram :: Monad m => ProgramT t m a -> (a -> m r) -> (forall x. t x -> (x -> m r) -> m r) -> m r
cloneProgramT :: (Monad n, Elevate t n, Elevate m n) => ProgramT t m a -> n a

-- | Interpret a <tt>Program</tt> using the given transformation.
interpret :: Monad m => (forall x. t x -> m x) -> ProgramT t m a -> m a
data ReifiedProgramT t (m :: * -> *) a
Return :: a -> ReifiedProgramT t m a
(:>>=) :: t a -> (a -> ReifiedProgramT t m b) -> ReifiedProgramT t m b
Lift :: m a -> (a -> ReifiedProgramT t m b) -> ReifiedProgramT t m b
fromReifiedT :: Monad m => ReifiedProgramT t m a -> ProgramT t m a
transReifiedT :: Monad m => (forall x. m x -> n x) -> ReifiedProgramT t m a -> ReifiedProgramT t n a
hoistReifiedT :: Monad m => (forall x. t x -> s x) -> ReifiedProgramT t m a -> ReifiedProgramT s m a
instance MonadTrans (ReifiedProgramT t)
instance (Monad m, Tower m) => Tower (ReifiedProgramT t m)
instance Monad m => Monad (ReifiedProgramT t m)
instance Monad m => Applicative (ReifiedProgramT t m)
instance Monad m => Functor (ReifiedProgramT t m)
instance MonadTrans (ProgramT t)
instance (Monad m, Tower m) => Tower (ProgramT t m)
instance Monad (ProgramT t m)
instance Applicative (ProgramT t m)
instance Functor (ProgramT t m)
