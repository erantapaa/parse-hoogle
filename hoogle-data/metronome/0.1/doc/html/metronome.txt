-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Time Synchronized execution.
--   
--   Metronome and tracks, useful to execute IO actions at regular
--   intervals. State exposed via STM.
@package metronome
@version 0.1


-- | Unifying functions of TVar's and TChans in STM and IO via atomically.
module Control.Concurrent.STMOrIO

-- | uniforming class for STM or IO
class (Functor m, Monad m) => STMOrIO m
stmorio :: STMOrIO m => STM a -> m a

-- | class to uniform reading and writing
class RW m z
rd :: RW m z => z a -> m a
wr :: RW m z => z a -> a -> m ()

-- | modify a cell z under STM or IO
md :: (Monad m, RW m z) => z a -> (a -> a) -> m ()

-- | new TVar
var :: STMOrIO m => a -> m (TVar a)

-- | new TChan
chan :: STMOrIO m => a -> m (TChan a)
instance STMOrIO t => RW t TChan
instance STMOrIO t => RW t TVar
instance STMOrIO STM
instance STMOrIO IO


-- | <i>Synchronized execution of sequences of actions, controlled in
--   STM</i>
--   
--   All data structures are made accessible via <a>Data.Lens</a>
--   abstraction.
--   
--   Actions to be executed are of type <a>Action</a> = STM (IO ()). At
--   each tick, the scheduled actions are ordered by priority, binded as
--   STM actions ignoring the retrying ones. The results, being IO actions
--   are executed in that order.
--   
--   Every <a>Track</a> and <a>Metronome</a> lives in its own thread and
--   can be stopped or killed as such, setting a flag in its state.
--   
--   Track and metronome state are exposed in TVar value to be modified at
--   will. The only closed and inaccessible value is the synchronizing
--   channel, written by the metronome and waited by tracks. The
--   <a>TrackForker</a> returned by a metronome function is closing this
--   channel and it's the only way to fork a track.
--   
--   See <a>System.Metronome.Practical</a> for an simple wrapper around
--   this module.
module System.Metronome

-- | State of a track.
data Track
Track :: Ticks -> Frequency -> [Action] -> Priority -> Bool -> Track

-- | the number of ticks elapsed from the track fork
_sync :: Track -> Ticks

-- | calling frequency relative to metronome ticks frequency
_frequency :: Track -> Frequency

-- | the actions left to be run
_actions :: Track -> [Action]

-- | priority of this track among its peers
_priority :: Track -> Priority

-- | muted flag, when True, actions are not scheduled, just skipped
_muted :: Track -> Bool

-- | supporting values with <a>running</a> and <a>alive</a> flag
data Thread a
Thread :: Bool -> Bool -> a -> Thread a

-- | stopped or running flag
_running :: Thread a -> Bool

-- | set to false to require kill thread
_alive :: Thread a -> Bool

-- | core data
_core :: Thread a -> a

-- | State of a metronome
data Metronome
Metronome :: [MTime] -> [(Priority, Action)] -> Metronome

-- | next ticking times
_ticks :: Metronome -> [MTime]

-- | actions scheduled for the tick to come
_schedule :: Metronome -> [(Priority, Action)]
sync :: Lens Track Ticks
frequency :: Lens Track Frequency
actions :: Lens Track [Action]
priority :: Lens Track Priority
muted :: Lens Track Bool
running :: Lens (Thread a_a3ME) Bool
alive :: Lens (Thread a_a3ME) Bool
core :: Lens (Thread a_a3ME) a_a3ME
ticks :: Lens Metronome [MTime]
schedule :: Lens Metronome [(Priority, Action)]

-- | A Thread value cell in STM
type Control a = TVar (Thread a)

-- | Priority values between tracks under the same metronome.
type Priority = Double

-- | Number of metronome ticks between two track ticks
type Frequency = Integer

-- | Number of elapsed ticks
type Ticks = Integer

-- | Track effect interface. Write in STM the collective and spit out the
--   IO action to be executed when all STMs for this tick are done or
--   retried
type Action = STM (IO ())

-- | Time, in seconds
type MTime = Double

-- | The action to fork a new track from a track state.
type TrackForker = Control Track -> IO ()

-- | Fork a metronome from its initial state
metronome :: Control Metronome -> IO TrackForker


-- | A wrapper module around <a>System.Metronome</a> with easy functions.
--   
--   In this snippet we run a metronome and attach 4 tracks to it.
--   
--   First track ticks every 2 metronome ticks printing "." 5 times.
--   
--   Second track ticks at each metronome tick. Forever it reads a string
--   from a variable, it checks first track for actions finished, and push
--   other 5 actions on the first, each printing the string read.
--   
--   Third track ticks every 14 metronome ticks and forever modifies the
--   string in the variable.
--   
--   Fourth track ticks every 100 metronome ticks , it does nothing on
--   first action , kill all tracks , including itself and the metronome,
--   and wake up main thread on the second.
--   
--   <pre>
--   {-# LANGUAGE DoRec #-}
--   
--   import System.IO
--   import System.Metronome.Practical
--   import Control.Concurrent.STMOrIO
--   import Control.Monad
--   
--   main = do
--         hSetBuffering stdout NoBuffering
--         (m,f) &lt;- dummyMetronome 0.1
--         c &lt;- dummyTrack f 2 0 $ replicate 5 $ return $ putStr "."
--         v &lt;- var "!"  
--         c2 &lt;- dummyTrack f 1 0 . repeat . noIO $ do
--                   as &lt;- getActions c
--                   vl &lt;- rd v
--                   when (null as) . setActions c . replicate 5 . return $ putStr vl
--         c3 &lt;- dummyTrack f 14 0 . repeat . noIO . md v $ map succ
--         end &lt;- chan ()
--         rec {c4 &lt;- dummyTrack f 100 0 . map noIO $ [return (), mapM_ kill [c,c2,c3,c4] &gt;&gt; kill m &gt;&gt; wr end ()]}
--         mapM_ run [c,c2,c3,c4]
--         rd end
--         hSetBuffering stdout LineBuffering 
--   </pre>
module System.Metronome.Practical

-- | kill a thread
kill :: STMOrIO m => Control a -> m ()

-- | stop a thread
stop :: STMOrIO m => Control a -> m ()

-- | run a thread
run :: STMOrIO m => Control a -> m ()

-- | invert the running flag of a thread
modRunning :: STMOrIO m => Control a -> m ()

-- | set the next ticking times for a metronome
setTicks :: STMOrIO m => Control Metronome -> [MTime] -> m ()

-- | change the actions scheduled for the next metronome tick
modScheduled :: STMOrIO m => Control Metronome -> ([(Priority, Action)] -> [(Priority, Action)]) -> m ()

-- | modify the ticks count from track start, shifting the next ticks
--   relative to metronome ticks
modPhase :: STMOrIO m => Control Track -> (Ticks -> Ticks) -> m ()

-- | set the track frequency
setFrequency :: STMOrIO m => Control Track -> Frequency -> m ()

-- | read the remaining actions of a track
getActions :: STMOrIO m => Control Track -> m [Action]

-- | set the track actions
setActions :: STMOrIO m => Control Track -> [Action] -> m ()

-- | set a track priority
setPriority :: STMOrIO m => Control Track -> Priority -> m ()

-- | mute / unmute a track
modMute :: STMOrIO m => Control Track -> m ()

-- | create and fork a running metronome.
dummyMetronome :: MTime -> IO (Control Metronome, TrackForker)

-- | create and fork a stopped track by a metronome
dummyTrack :: TrackForker -> Frequency -> Priority -> [Action] -> IO (Control Track)

-- | no IO as result of the STM action
noIO :: STM () -> STM (IO ())
