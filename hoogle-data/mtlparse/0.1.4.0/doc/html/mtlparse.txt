-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | parse library using mtl package
--   
--   parse library on mtl package
--   
--   Parse and ParseT is like State and StateT
--   
--   The package ease implementation of look-ahead look-behind and so on.
@package mtlparse
@version 0.1.4.0

module Text.ParserCombinators.MTLParse
class Monad m => MonadParse a m | m -> a
spot :: MonadParse a m => (a -> Bool) -> m a
spotBack :: MonadParse a m => (a -> Bool) -> m a
still :: MonadParse a m => m b -> m b
parseNot :: MonadParse a m => c -> m b -> m c
getHere :: MonadParse a m => m ([a], [a])
putHere :: MonadParse a m => ([a], [a]) -> m ()
noBacktrack :: MonadParse a m => m b -> m b
token :: (Eq a, MonadParse a m) => a -> m a
tokenBack :: (Eq a, MonadParse a m) => a -> m a
getsHere :: MonadParse a m => (([a], [a]) -> b) -> m b
modifyHere :: MonadParse a m => (([a], [a]) -> ([a], [a])) -> m ()
getForward :: MonadParse a m => m [a]
getsForward :: MonadParse a m => ([a] -> [a]) -> m [a]
putForward :: MonadParse a m => [a] -> m ()
modifyForward :: MonadParse a m => ([a] -> [a]) -> m ()
getBack :: MonadParse a m => m [a]
getsBack :: MonadParse a m => ([a] -> [a]) -> m [a]
putBack :: MonadParse a m => [a] -> m ()
modifyBack :: MonadParse a m => ([a] -> [a]) -> m ()

-- | A parse monad where <i>a</i> is the type of the token to parse and
--   <i>b</i> is the type of the <i>return value</i>.
newtype Parse a b
Parse :: (([a], [a]) -> [(b, ([a], [a]))]) -> Parse a b
runParse :: Parse a b -> ([a], [a]) -> [(b, ([a], [a]))]
evalParse :: Parse a b -> ([a], [a]) -> [b]
execParse :: Parse a b -> ([a], [a]) -> [([a], [a])]
mapParse :: ((b, ([a], [a])) -> (c, ([a], [a]))) -> Parse a b -> Parse a c
withParse :: (([a], [a]) -> ([a], [a])) -> Parse a b -> Parse a b

-- | A parse monad for encaplulating an inner monad.
newtype ParseT a m b
ParseT :: (([a], [a]) -> m [(b, ([a], [a]))]) -> ParseT a m b
runParseT :: ParseT a m b -> ([a], [a]) -> m [(b, ([a], [a]))]
evalParseT :: Monad m => ParseT a m b -> ([a], [a]) -> m [b]
execParseT :: Monad m => ParseT a m b -> ([a], [a]) -> m [([a], [a])]
mapParseT :: (m [(b, ([a], [a]))] -> n [(c, ([a], [a]))]) -> ParseT a m b -> ParseT a n c
withParseT :: (([a], [a]) -> ([a], [a])) -> ParseT a m b -> ParseT a m b
tokens :: (Eq a, MonadParse a m) => [a] -> m [a]
tokensBack :: (Eq a, MonadParse a m) => [a] -> m [a]
build :: Monad m => m a -> (a -> b) -> m b
repeatParse :: MonadPlus m => Int -> Maybe Int -> m b -> m [b]
optional :: MonadPlus m => m a -> m [a]
list :: MonadPlus m => m a -> m [a]
neList :: MonadPlus m => m a -> m [a]
greedyRepeatParse :: MonadPlus m => Int -> Maybe Int -> m b -> m [b]
greedyOptional :: MonadPlus m => m a -> m [a]
greedyList :: MonadPlus m => m a -> m [a]
greedyNeList :: MonadPlus m => m a -> m [a]
beginningOfInput :: (MonadPlus m, MonadParse a m) => b -> m b
endOfInput :: (MonadPlus m, MonadParse a m) => b -> m b
apply2M :: Monad m => (a -> b -> c) -> m a -> m b -> m c
(>++>) :: Monad m => m [a] -> m [a] -> m [a]
(>:>) :: Monad m => m a -> m [a] -> m [a]
