-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A crude interface between Haskell and Unix-like operating systems
--   
@package Unixutils
@version 1.53

module System.Unix.Files

-- | calls <a>createSymbolicLink</a> but will remove the target and retry
--   if <a>createSymbolicLink</a> raises EEXIST.
forceSymbolicLink :: FilePath -> FilePath -> IO ()


-- | Construct an ADT representing block and character devices (but mostly
--   block devices) by interpreting the contents of the Linux sysfs
--   filesystem.
module System.Unix.SpecialDevice
data SpecialDevice

-- | FIXME: We should really get this value from the mount table.
sysMountPoint :: FilePath

-- | Return the device represented by a device node, such as /dev/sda2.
--   Returns Nothing if there is an exception trying to stat the node, or
--   if the node turns out not to be a special device.
ofNode :: FilePath -> IO (Maybe SpecialDevice)
ofNodeStatus :: FileStatus -> Maybe SpecialDevice
ofPath :: FilePath -> IO (Maybe SpecialDevice)
rootPart :: IO (Maybe SpecialDevice)
ofDevNo :: (DeviceID -> SpecialDevice) -> Int -> SpecialDevice
ofSysName :: String -> IO (Maybe SpecialDevice)
ofSysPath :: (DeviceID -> SpecialDevice) -> FilePath -> IO (Maybe SpecialDevice)
toDevno :: SpecialDevice -> DeviceID
ofMajorMinor :: (DeviceID -> SpecialDevice) -> Int -> Int -> SpecialDevice
node :: SpecialDevice -> IO (Maybe FilePath)
nodes :: SpecialDevice -> IO [FilePath]
sysName :: SpecialDevice -> IO (Maybe String)
splitPart :: String -> (String, Int)
sysDir :: SpecialDevice -> IO (Maybe FilePath)
diskOfPart :: SpecialDevice -> IO (Maybe SpecialDevice)
getAllDisks :: IO [SpecialDevice]
getAllPartitions :: IO [SpecialDevice]
getAllCdroms :: IO [SpecialDevice]
getAllRemovable :: IO [SpecialDevice]
instance Show SpecialDevice
instance Ord SpecialDevice
instance Eq SpecialDevice


-- | functions for mounting, umounting, parsing /proc/mounts, etc
module System.Unix.Mount

-- | <a>umountBelow</a> - unmounts all mount points below <i>belowPath</i>
--   /proc/mounts must be present and readable. Because of the way linux
--   handles changeroots, we can't trust everything we see in /proc/mounts.
--   However, we make the following assumptions:
--   
--   <ol>
--   <li>there is a one-to-one correspondence between the entries in
--   /proc/mounts and the actual mounts, and</li>
--   <li>every mount point we might encounter is a suffix of one of the
--   mount points listed in /proc/mounts (because being in a a chroot
--   doesn't affect /proc/mounts.)</li>
--   </ol>
--   
--   So we can search /proc/mounts for an entry has the mount point we are
--   looking for as a substring, then add the extra text on the right to
--   our path and try to unmount that. Then we start again since nested
--   mounts might have been revealed.
--   
--   For example, suppose we are chrooted into /home/david/environments/sid
--   and we call "umountBelow /proc". We might see the mount point
--   /home/david/environments/sid/proc/bus/usb in /proc/mounts, which means
--   we need to run "umount /proc/bus/usb".
--   
--   See also: <a>umountSucceeded</a>
umountBelow :: Bool -> FilePath -> IO [(FilePath, (ExitCode, String, String))]

-- | <a>umount</a> - run umount with the specified args NOTE: this function
--   uses exec, so you do <i>not</i> need to shell-escape NOTE: we don't
--   use the umount system call because the system call is not smart enough
--   to update /etc/mtab
umount :: [String] -> IO (ExitCode, String, String)
isMountPoint :: FilePath -> IO Bool

-- | Do an IO task with a file system remounted using mount --bind. This
--   was written to set up a build environment.
withMount :: (MonadIO m, MonadMask m) => FilePath -> FilePath -> m a -> m a

-- | Monad transformer to ensure that <i>proc and </i>sys are mounted
--   during a computation.
data WithProcAndSys m a

-- | Mount <i>proc and </i>sys in the specified build root and execute a
--   task. Typically, the task would start with a chroot into the build
--   root. If the build root given is "/" it is assumed that the file
--   systems are already mounted, no mounting or unmounting is done.
withProcAndSys :: (MonadIO m, MonadMask m) => FilePath -> WithProcAndSys m a -> m a

-- | Do an IO task with /tmp remounted. This could be used to share /tmp
--   with a build root.
withTmp :: (MonadIO m, MonadMask m) => FilePath -> m a -> m a
instance Functor m => Functor (WithProcAndSys m)
instance Monad m => Monad (WithProcAndSys m)
instance Applicative m => Applicative (WithProcAndSys m)
instance MonadIO m => MonadIO (WithProcAndSys m)
instance MonadTrans WithProcAndSys


-- | Wrappers around some handy unix shell commands. Please let me know if
--   you think of better module names to hold these functions. -dsf
module System.Unix.Misc

-- | Deprecated: Use <tt>Data.ByteString.Lazy.Char8.readFile path &gt;&gt;=
--   return . show . Data.Digest.Pure.MD5.md5</tt>

-- | <i>Deprecated: Use Data.ByteString.Lazy.Char8.readFile path &gt;&gt;=
--   return . show . Data.Digest.Pure.MD5.md5</i>
md5sum :: FilePath -> IO String

-- | Deprecated: Use <tt>Data.ByteString.Lazy.Char8.readFile path &gt;&gt;=
--   Data.ByteString.Lazy.Char8.writeFile (path ++ ".gz")</tt>

-- | <i>Deprecated: Use Data.ByteString.Lazy.Char8.readFile path &gt;&gt;=
--   Data.ByteString.Lazy.Char8.writeFile (path ++ ".gz")</i>
gzip :: FilePath -> IO ()


-- | A place to collect and hopefully retire all the random ways of running
--   shell commands that have accumulated over the years.
module System.Unix.KillByCwd

-- | Kill the processes whose working directory is in or under the given
--   directory.
killByCwd :: FilePath -> IO [(String, Maybe String)]


-- | The function splitFileName is taken from missingh, at the moment
--   missingh will not build under sid.
module System.Unix.FilePath

-- | Use dropFileName
dirName :: FilePath -> FilePath

-- | Use takeFileName
baseName :: FilePath -> String

-- | resolve all references to <i>.</i>, <i>..</i>, extra slashes, and
--   symlinks
realpath :: FilePath -> IO FilePath

-- | Concatenate two paths, making sure there is exactly one path
--   separator.
(<++>) :: FilePath -> FilePath -> FilePath

module System.Unix.Directory

-- | Traverse a directory and return a list of all the (path, fileStatus)
--   pairs.
find :: FilePath -> IO [(FilePath, FileStatus)]

-- | Recursively remove a directory contents on a single file system. The
--   adjective "Safely" refers to these features: 1. It will not follow
--   symlinks 2. If it finds a directory that seems to be a mount point, it
--   will attempt to unmount it up to five times. If it still seems to be a
--   mount point it gives up 3. It doesn't use <i>proc</i>mounts, which is
--   ambiguous or wrong when you are inside a chroot.
removeRecursiveSafely :: FilePath -> IO ()

-- | Like removeRecursiveSafely but doesn't remove any files, just unmounts
--   anything it finds mounted. Note that this can be much slower than
--   Mount.umountBelow, use that instead.
unmountRecursiveSafely :: FilePath -> IO ()

-- | Rename src to dst, and if dst already exists move it to dst~. If dst~
--   exists it is removed.
renameFileWithBackup :: FilePath -> FilePath -> IO ()

-- | temporarily change the working directory to |dir| while running
--   |action|
withWorkingDirectory :: FilePath -> IO a -> IO a

-- | create a temporary directory, run the action, remove the temporary
--   directory the first argument is a template for the temporary directory
--   name the directory will be created as a subdirectory of the directory
--   returned by getTemporaryDirectory the temporary directory will be
--   automatically removed afterwards. your working directory is not
--   altered
withTemporaryDirectory :: FilePath -> (FilePath -> IO a) -> IO a
mkdtemp :: FilePath -> IO FilePath


-- | support for crypt() and <i>etc</i>shadow
module System.Unix.Crypt

-- | calls crypt(3)
crypt :: String -> String -> IO String


-- | This module, except for useEnv, is copied from the build-env package.
module System.Unix.Chroot

-- | fchroot runs an IO action inside a chroot fchroot performs a chroot,
--   runs the action, and then restores the original root and working
--   directory. This probably affects the chroot and working directory of
--   all the threads in the process, so... NOTE: will throw IOError if
--   internal chroot fails
fchroot :: FilePath -> IO a -> IO a

-- | The ssh inside of the chroot needs to be able to talk to the running
--   ssh-agent. Therefore we mount --bind the ssh agent socket dir inside
--   the chroot (and umount it when we exit the chroot.
useEnv :: FilePath -> (a -> IO a) -> IO a -> IO a
