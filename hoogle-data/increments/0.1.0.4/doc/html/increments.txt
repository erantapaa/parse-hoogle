-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | type classes for incremental updates to data
--   
--   incremental updates to large data structures
@package increments
@version 0.1.0.4


-- | Internal functions; typically unneeded by users.
--   
--   One common case is defining certain Incremental instances. Sometimes
--   instead of deriving an Incremental instance you want to always send
--   new data if it has changed. This is easily supported with the
--   <a>DPrim</a> type and helper functions:
--   
--   <pre>
--   import Data.Increments.Internal
--   
--   instance Incremental Foo where
--    type Increment Foo = DPrim Foo
--    changes = iprimDiff
--    applyChanges = iprimApply
--   </pre>
--   
--   This is especially useful with large types that do not change often,
--   when attempting to calculate the difference may be very expensive.
module Data.Increments.Internal

-- | Calculate differences between data structures.
class Incremental a where type family Increment a :: * type instance Increment a = GIncrement (Rep a) () changes a b = gchanges (from a) (from b) applyChanges a d_a = to $ gapplyChanges (from a) d_a
changes :: Incremental a => a -> a -> Increment a
applyChanges :: Incremental a => a -> Increment a -> a

-- | Determine if a Increment representation contains a real change.
--   Unchanging changes may be omitted.
class Changed a
didChange :: Changed a => a -> Bool

-- | A useful type constraint synonym for writing instances
type IncrementalCnstr a = (Incremental a, Changed (Increment a))
data DPrim a
DPrim :: a -> DPrim a
DPrim_NoChange :: DPrim a
iprimDiff :: Eq a => a -> a -> DPrim a
iprimApply :: a -> DPrim a -> a
instance Show (Increment a) => Show (GIncrement_K1 a p)
instance (Show (a p), Show (b p), Show (GIncrement b p), Show (GIncrement a p)) => Show (PSum a b p)
instance Eq a => Eq (DPrim a)
instance Show a => Show (DPrim a)
instance Generic (DPrim a)
instance Show a => Show (P2 a p)
instance Generic (P2 a p)
instance (Show (a p), Show (b p)) => Show (PProd a b p)
instance Generic (PProd a b p)
instance Generic (PSum a b p)
instance Generic (GIncrement_K1 a p)
instance Datatype D1DPrim
instance Constructor C1_0DPrim
instance Constructor C1_1DPrim
instance Datatype D1P2
instance Constructor C1_0P2
instance Datatype D1PProd
instance Constructor C1_0PProd
instance Constructor C1_1PProd
instance Constructor C1_2PProd
instance Constructor C1_3PProd
instance Datatype D1PSum
instance Constructor C1_0PSum
instance Constructor C1_1PSum
instance Constructor C1_2PSum
instance Constructor C1_3PSum
instance Constructor C1_4PSum
instance Datatype D1GIncrement_K1
instance Constructor C1_0GIncrement_K1
instance (Beamable (a x), Beamable (b x)) => Beamable ((:+:) a b x)
instance (Beamable (a x), Beamable (b x)) => Beamable ((:*:) a b x)
instance Beamable (a x) => Beamable (M1 s c a x)
instance Beamable a => Beamable (K1 i a x)
instance Beamable (U1 x)
instance GIncremental a => GIncremental (M1 S c a)
instance (Datatype d, GIncremental a, GIncremental b) => GIncremental (M1 D d (a :+: b))
instance (GIncremental a, Constructor c) => GIncremental (M1 C c a)
instance (GIncremental a, Datatype d, Constructor c) => GIncremental (M1 D d (M1 C c a))
instance (Incremental a, Changed (Increment a)) => GIncremental (K1 i a)
instance Changed (Increment a) => GChanged (GIncrement_K1 a)
instance Changed (Increment a) => Changed (GIncrement_K1 a p)
instance Beamable (Increment a) => Beamable (GIncrement_K1 a p)
instance (GIncremental a, GIncremental b) => GIncremental (a :+: b)
instance (GIncremental a, GIncremental b) => GIncremental (a :*: b)
instance GIncremental U1
instance (GChanged a, GChanged b) => GChanged (PProd a b)
instance (GChanged (GIncrement a), GChanged (GIncrement b)) => GChanged (PSum a b)
instance Changed a => GChanged (P2 a)
instance (Beamable (a p), Beamable (b p), Beamable (GIncrement a p), Beamable (GIncrement b p)) => Beamable (PSum a b p)
instance (Beamable (a p), Beamable (b p)) => Beamable (PProd a b p)
instance Changed (PProd a b p)
instance Changed (PSum a b p)
instance Changed a => Changed (P2 a p)
instance Beamable a => Beamable (P2 a p)
instance Monoid (DPrim a)
instance Changed (DPrim a)
instance Beamable a => Beamable (DPrim a)
instance (IncrementalCnstr a, IncrementalCnstr b, IncrementalCnstr c, IncrementalCnstr d, IncrementalCnstr e, IncrementalCnstr f, IncrementalCnstr g) => Incremental (a, b, c, d, e, f, g)
instance (IncrementalCnstr a, IncrementalCnstr b, IncrementalCnstr c, IncrementalCnstr d, IncrementalCnstr e, IncrementalCnstr f) => Incremental (a, b, c, d, e, f)
instance (IncrementalCnstr a, IncrementalCnstr b, IncrementalCnstr c, IncrementalCnstr d, IncrementalCnstr e) => Incremental (a, b, c, d, e)
instance (IncrementalCnstr a, IncrementalCnstr b, IncrementalCnstr c, IncrementalCnstr d) => Incremental (a, b, c, d)
instance (IncrementalCnstr a, IncrementalCnstr b, IncrementalCnstr c) => Incremental (a, b, c)
instance (IncrementalCnstr l, IncrementalCnstr r) => Incremental (l, r)
instance (Incremental l, Incremental r, Changed (Increment l), Changed (Increment r)) => Incremental (Either l r)
instance (Incremental a, Changed (Increment a)) => Incremental (Maybe a)
instance Incremental Bool
instance Incremental Ordering
instance Incremental ()
instance Changed ()
instance Incremental ByteString
instance Incremental ByteString
instance Incremental Char
instance Eq x => Incremental [x]
instance Incremental Double
instance Incremental Float
instance Incremental Word64
instance Incremental Word32
instance Incremental Word16
instance Incremental Word8
instance Incremental Word
instance Incremental Int64
instance Incremental Int32
instance Incremental Int16
instance Incremental Int8
instance Incremental Int
instance Incremental Integer


-- | <a>Incremental</a> instances for containers, and useful functions for
--   defining new instances.
module Data.Increments.Containers

-- | The <a>Increment</a> of a map-like (key-value) container.
type MapLikeIncrement k a = ([AddItem k a], [RemItem k], [ModItem k a])

-- | The <a>Increment</a> of a set.
type SetLikeIncrement a = ([AddItem () a], [RemItem a])

-- | a generic <a>changes</a> function, useful for defining instances for
--   sets.
changesSetLike :: (c -> [a]) -> (c -> c -> c) -> c -> c -> SetLikeIncrement a

-- | a generic <a>applyChanges</a> function, useful for defining instances
--   for sets.
applySetLike :: (a -> c -> c) -> (a -> c -> c) -> c -> SetLikeIncrement a -> c

-- | a generic <a>changes</a> function, useful for defining instances for
--   maps.
changesMapLike :: (Ord k, IncrementalCnstr a) => (c -> [(k, a)]) -> c -> c -> MapLikeIncrement k a

-- | a generic <a>applyChanges</a> function, useful for defining instances
--   for maps.
applyMapLike :: Incremental a => (k -> a -> c -> c) -> (k -> c -> c) -> (k -> Increment a -> c -> c) -> c -> MapLikeIncrement k a -> c
instance (Show (Increment a), Show key) => Show (ModItem key a)
instance (Eq (Increment a), Eq key) => Eq (ModItem key a)
instance (Eq k, Eq a) => Eq (AddItem k a)
instance (Show k, Show a) => Show (AddItem k a)
instance Generic (AddItem k a)
instance Eq a => Eq (RemItem a)
instance Show a => Show (RemItem a)
instance Generic (RemItem a)
instance Generic (ModItem k a)
instance Datatype D1AddItem
instance Constructor C1_0AddItem
instance Datatype D1RemItem
instance Constructor C1_0RemItem
instance Datatype D1ModItem
instance Constructor C1_0ModItem
instance Changed (Increment e) => Changed ([AddItem a b], [RemItem c], [ModItem d e])
instance Changed ([AddItem a b], [RemItem c])
instance Incremental IntSet
instance Ord a => Incremental (Set a)
instance (IncrementalCnstr a) => Incremental (IntMap a)
instance (Ord k, IncrementalCnstr a) => Incremental (Map k a)
instance (Beamable k, Beamable (Increment a)) => Beamable (ModItem k a)
instance Beamable a => Beamable (RemItem a)
instance (Beamable k, Beamable a) => Beamable (AddItem k a)


-- | Calculate incremental changes of data structures.
--   
--   The <a>Incremental</a> class provides a set of functions that work
--   like the unix utilities <tt>diff</tt> and <tt>patch</tt>.
--   <a>changes</a> generates an incremental diff between two data values.
--   The incremental diff can then be applied by the <a>applyChanges</a>
--   function.
--   
--   The primary intention of this library is to support efficient
--   serialization. As such, default <a>Increment</a> types are
--   automatically provided with <tt>Beamable</tt> instances.
--   
--   <pre>
--   {-# LANGUAGE DeriveGenerics #-}
--   {-# LANGUAGE ConstraintKinds #-}
--   {-# LANGUAGE FlexibleContexts #-}
--   {-# LANGUAGE UndecidableInstances #-}
--   
--   import GHC.Generics
--   import Data.Beamable
--   import Data.ByteString as B
--   
--   data Foo a b = Foo Int (Maybe a) b deriving (Generic, Eq, Show)
--   
--   -- If a 'Generic' instance is available, the default definition is
--   -- fine, after adding some constraints.
--   instance (IncrementalCnstr a, IncrementalCnstr b) =&gt; Incremental (Foo a b)
--   
--   -- generate some test data
--   foo1 = Foo 1 Nothing "foo1"
--   foo2 = Foo 1 (Just "foo2") "foo1"
--   
--   -- the 'changes' function calculates an incremental changeset from
--   -- 'foo1' to 'foo2'
--   diff = changes foo1 foo2
--   
--   -- 'applyChanges' applies the changes in an incremental patch to some data
--   -- applyChanges foo1 diff == foo2
--   -- True
--   
--   -- incremental changes can be smaller (sometimes significantly smaller)
--   -- than the data source
--   -- B.length $ encode diff
--   -- 8
--   -- B.length $ encode foo2
--   -- 12
--   </pre>
--   
--   Incremental changes are not in general commutative or optional, and it
--   can be an error to apply a change to a data structure that doesn't
--   match the originating structure. For example:
--   
--   <pre>
--   *Data.Increments&gt; let diff = changes (Left 1) (Left 2 :: Either Int Char)
--   *Data.Increments&gt; applyChanges (Right 'a') diff
--   *** Exception: Data.Increments: malformed Increment Rep
--   </pre>
module Data.Increments

-- | Calculate differences between data structures.
class Incremental a where type family Increment a :: * type instance Increment a = GIncrement (Rep a) () changes a b = gchanges (from a) (from b) applyChanges a d_a = to $ gapplyChanges (from a) d_a
changes :: Incremental a => a -> a -> Increment a
applyChanges :: Incremental a => a -> Increment a -> a

-- | Determine if a Increment representation contains a real change.
--   Unchanging changes may be omitted.
class Changed a
didChange :: Changed a => a -> Bool

-- | A useful type constraint synonym for writing instances
type IncrementalCnstr a = (Incremental a, Changed (Increment a))
