-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lighweight algorithmic debugging based on observing intermediate values and the cost centre stack.
--   
@package Hoed
@version 0.2.2


-- | Hoed is a tracer and debugger for the programming language Haskell.
--   You can trace a program by annotating functions in suspected modules
--   and linking your program against standard profiling libraries.
--   
--   After running the program a computation tree is constructed and
--   displayed in a web browser. You can freely browse this tree to get a
--   better understanding of your program. If your program misbehaves, you
--   can judge the computation statements in the tree as <tt>right</tt> or
--   <tt>wrong</tt> according to your intention. When enough statements are
--   judged the debugger tells you the location of the fault in your code.
--   
--   
--   I work on this debugger in the context of my Ph.D. research. Read more
--   about the theory behind Hoed at <a>http://maartenfaddegon.nl/#pub</a>.
--   
--   To use Hoed on your own program, annotate your program as described
--   below. For best results profiling is enabled and optimization
--   disabled. If you use cabal to build your project, this is be done
--   with:
--   
--   <pre>
--   cabal configure --disable-optimization --enable-profiling
--   </pre>
--   
--   I am keen to hear about your experience with Hoed: where did you find
--   it useful and where would you like to see improvement? You can send me
--   an e-mail at hoed@maartenfaddegon.nl, or use the github issue tracker
--   <a>https://github.com/MaartenFaddegon/hoed/issues</a>.
module Debug.Hoed.Stk

-- | Functions which you suspect of misbehaving are annotated with observe
--   and should have a cost centre set. The name of the function, the label
--   of the cost centre and the label given to observe need to be the same.
--   
--   Consider the following function:
--   
--   <pre>
--   triple x = x + x
--   </pre>
--   
--   This function is annotated as follows:
--   
--   <pre>
--   triple y = (observe "triple" (\x -&gt; {# SCC "triple" #}  x + x)) y
--   </pre>
--   
--   To produce computation statements like:
--   
--   <pre>
--   triple 3 = 6
--   </pre>
--   
--   To observe a value its type needs to be of class Observable. We
--   provided instances for many types already. If you have defined your
--   own type, and want to observe a function that takes a value of this
--   type as argument or returns a value of this type, an Observable
--   instance can be derived as follows:
--   
--   <pre>
--   data MyType = MyNumber Int | MyName String deriving Generic
--   
--   instance Observable MyType
--   </pre>
observe :: Observable a => String -> a -> a

-- | The main entry point; run some IO code, and debug inside it. After the
--   IO action is completed, an algorithmic debugging session is started at
--   <tt><a>http://localhost:10000/</a></tt> to which you can connect with
--   your webbrowser.
--   
--   For example:
--   
--   <pre>
--   main = runO $ do print (triple 3)
--                    print (triple 2)
--   </pre>
runO :: IO a -> IO ()

-- | Short for <tt>runO . print</tt>.
printO :: Show a => a -> IO ()
observeTempl :: String -> Q Exp
observedTypes :: String -> [Q Type] -> Q [Dec]
observeCC :: Observable a => String -> a -> a
observe' :: Observable a => String -> Identifier -> a -> (a, Int)
data Identifier
UnknownId :: Identifier
DependsJustOn :: Int -> Identifier
InSequenceAfter :: Int -> Identifier
(*>>=) :: Monad m => m a -> (Identifier -> (a -> m b, Int)) -> (m b, Identifier)
(>>==) :: Monad m => (m a, Identifier) -> (Identifier -> (a -> m b, Int)) -> (m b, Identifier)
(>>=*) :: Monad m => (m a, Identifier) -> (Identifier -> (a -> m b, Int)) -> m b
logO :: FilePath -> IO a -> IO ()
newtype Observer
O :: (forall a. Observable a => String -> a -> a) -> Observer
class Observable a where observer x c = to (gdmobserver (from x) c)
observer :: Observable a => a -> Parent -> a
(<<) :: Observable a => ObserverM (a -> b) -> a -> ObserverM b
thunk :: (a -> Parent -> a) -> a -> ObserverM a
nothunk :: a -> ObserverM a
send :: String -> ObserverM a -> Parent -> a
observeBase :: Show a => a -> Parent -> a
observeOpaque :: String -> a -> Parent -> a

-- | run some code and return the CDS structure (for when you want to write
--   your own debugger).
debugO :: IO a -> IO [Event]
data CDS

-- | Representable types of kind *. This class is derivable in GHC with the
--   DeriveGeneric flag on.
class Generic a
