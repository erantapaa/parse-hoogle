-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Browser interface to the http-conduit package
--   
@package http-conduit-browser
@version 2.0.0.0


-- | This module is designed to work similarly to the Network.Browser
--   module in the HTTP package. The idea is that there are two new types
--   defined: <a>BrowserState</a> and <a>BrowserAction</a>. The purpose of
--   this module is to make it easy to describe a browsing session,
--   including navigating to multiple pages, and have things like cookie
--   jar updates work as expected as you browse around.
--   
--   BrowserAction is a monad that handles all your browser-related
--   activities. This monad is actually implemented as a specialization of
--   the State monad, over the BrowserState type. The BrowserState type has
--   various bits of information that a web browser keeps, such as a
--   current cookie jar, the number of times to retry a request on failure,
--   HTTP proxy information, etc. In the BrowserAction monad, there is one
--   BrowserState at any given time, and you can modify it by using the
--   convenience functions in this module.
--   
--   A special kind of modification of the current browser state is the
--   action of making a HTTP request. This will do the request according to
--   the params in the current BrowserState, as well as modifying the
--   current state with, for example, an updated cookie jar and location.
--   
--   To use this module, you would bind together a series of BrowserActions
--   (This simulates the user clicking on links or using a settings
--   dialogue etc.) to describe your browsing session. When you've
--   described your session, you call <a>browse</a> on your top-level
--   BrowserAction to actually convert your actions into the ResourceT IO
--   monad.
--   
--   Here is an example program:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import qualified Data.ByteString.Lazy as LB
--   import qualified Data.Text.Encoding as TE
--   import qualified Data.Text.Lazy.Encoding as TLE
--   import qualified Data.Text.Lazy.IO as TLIO
--   import           Data.Conduit
--   import           Network.HTTP.Conduit
--   import           Network.HTTP.Conduit.Browser
--   
--   -- The web request to log in to a service
--   req1 :: IO (Request)
--   req1 = do
--     req &lt;- parseUrl "http://www.myurl.com/login.php"
--     return $ urlEncodedBody [ (TE.encodeUtf8 "name", TE.encodeUtf8 "litherum")
--                             , (TE.encodeUtf8 "pass", TE.encodeUtf8 "S33kRe7")
--                             ] req
--   
--   -- Once authenticated, run this request
--   req2 :: IO (Request m')
--   req2 = parseUrl "http://www.myurl.com/main.php"
--   
--   -- Bind two BrowserActions together
--   action :: Request -&gt; Request -&gt; BrowserAction (Response LB.ByteString)
--   action r1 r2 = do
--     _ &lt;- makeRequestLbs r1
--     makeRequestLbs r2
--   
--   main :: IO ()
--   main = do
--     man &lt;- newManager def
--     r1 &lt;- req1
--     r2 &lt;- req2
--     out &lt;- runResourceT $ browse man $ do
--       setDefaultHeader "User-Agent" $ Just "A very popular browser"
--       action r1 r2
--     TLIO.putStrLn $ TLE.decodeUtf8 $ responseBody out
--   </pre>
module Network.HTTP.Conduit.Browser
type BrowserAction = GenericBrowserAction (ResourceT IO)
type GenericBrowserAction m = StateT BrowserState m

-- | Do the browser action with the given manager
browse :: Monad m => Manager -> GenericBrowserAction m a -> m a

-- | Convert an URL relative to current Location into a <a>Request</a>
--   
--   Will throw <a>InvalidUrlException</a> on parse failures or if your
--   Location is <a>Nothing</a> (e.g. you haven't made any requests before)
parseRelativeUrl :: MonadThrow m => String -> GenericBrowserAction m Request

-- | Make a request, using all the state in the current BrowserState
makeRequest :: (MonadBaseControl IO m, MonadIO m, MonadResource m) => Request -> GenericBrowserAction m (Response (ResumableSource (ResourceT IO) ByteString))

-- | Make a request and pack the result as a lazy bytestring.
--   
--   Note: Even though this function returns a lazy bytestring, it does not
--   utilize lazy I/O, and therefore the entire response body will live in
--   memory. If you want constant memory usage, you'll need to use the
--   conduit package and <a>makeRequest</a> directly.
makeRequestLbs :: (MonadIO m, MonadResource m, MonadBaseControl IO m) => Request -> GenericBrowserAction m (Response ByteString)
data BrowserState
defaultState :: Manager -> BrowserState
getBrowserState :: Monad m => GenericBrowserAction m BrowserState
setBrowserState :: Monad m => BrowserState -> GenericBrowserAction m ()
withBrowserState :: Monad m => BrowserState -> GenericBrowserAction m a -> GenericBrowserAction m a
getManager :: Monad m => GenericBrowserAction m Manager
setManager :: Monad m => Manager -> GenericBrowserAction m ()
getLocation :: Monad m => GenericBrowserAction m (Maybe URI)
setLocation :: Monad m => (Maybe URI) -> GenericBrowserAction m ()
withLocation :: Monad m => (Maybe URI) -> GenericBrowserAction m a -> GenericBrowserAction m a
getCookieJar :: Monad m => GenericBrowserAction m (CookieJar)
setCookieJar :: Monad m => (CookieJar) -> GenericBrowserAction m ()
withCookieJar :: Monad m => (CookieJar) -> GenericBrowserAction m a -> GenericBrowserAction m a
getCookieFilter :: Monad m => GenericBrowserAction m (Request -> Cookie -> IO Bool)
setCookieFilter :: Monad m => (Request -> Cookie -> IO Bool) -> GenericBrowserAction m ()
withCookieFilter :: Monad m => (Request -> Cookie -> IO Bool) -> GenericBrowserAction m a -> GenericBrowserAction m a
getCurrentProxy :: Monad m => GenericBrowserAction m (Maybe Proxy)
setCurrentProxy :: Monad m => (Maybe Proxy) -> GenericBrowserAction m ()
withCurrentProxy :: Monad m => (Maybe Proxy) -> GenericBrowserAction m a -> GenericBrowserAction m a
getMaxRedirects :: Monad m => GenericBrowserAction m (Maybe Int)
setMaxRedirects :: Monad m => (Maybe Int) -> GenericBrowserAction m ()
withMaxRedirects :: Monad m => (Maybe Int) -> GenericBrowserAction m a -> GenericBrowserAction m a
getMaxRetryCount :: Monad m => GenericBrowserAction m (Int)
setMaxRetryCount :: Monad m => (Int) -> GenericBrowserAction m ()
withMaxRetryCount :: Monad m => (Int) -> GenericBrowserAction m a -> GenericBrowserAction m a
getTimeout :: Monad m => GenericBrowserAction m (Maybe Int)
setTimeout :: Monad m => (Maybe Int) -> GenericBrowserAction m ()
withTimeout :: Monad m => (Maybe Int) -> GenericBrowserAction m a -> GenericBrowserAction m a
getAuthorities :: Monad m => GenericBrowserAction m (Request -> Maybe (ByteString, ByteString))
setAuthorities :: Monad m => (Request -> Maybe (ByteString, ByteString)) -> GenericBrowserAction m ()
withAuthorities :: Monad m => (Request -> Maybe (ByteString, ByteString)) -> GenericBrowserAction m a -> GenericBrowserAction m a
getDefaultHeaders :: Monad m => GenericBrowserAction m RequestHeaders
setDefaultHeaders :: Monad m => RequestHeaders -> GenericBrowserAction m ()
withDefaultHeaders :: Monad m => RequestHeaders -> GenericBrowserAction m a -> GenericBrowserAction m a
getDefaultHeader :: Monad m => HeaderName -> GenericBrowserAction m (Maybe ByteString)
setDefaultHeader :: Monad m => HeaderName -> Maybe ByteString -> GenericBrowserAction m ()
insertDefaultHeader :: Monad m => Header -> GenericBrowserAction m ()
deleteDefaultHeader :: Monad m => HeaderName -> GenericBrowserAction m ()
withDefaultHeader :: Monad m => Header -> GenericBrowserAction m a -> GenericBrowserAction m a
getOverrideHeaders :: Monad m => GenericBrowserAction m RequestHeaders
setOverrideHeaders :: Monad m => RequestHeaders -> GenericBrowserAction m ()
withOverrideHeaders :: Monad m => RequestHeaders -> GenericBrowserAction m a -> GenericBrowserAction m a
getOverrideHeader :: Monad m => HeaderName -> GenericBrowserAction m (Maybe ByteString)
setOverrideHeader :: Monad m => HeaderName -> Maybe ByteString -> GenericBrowserAction m ()
insertOverrideHeader :: Monad m => Header -> GenericBrowserAction m ()
deleteOverrideHeader :: Monad m => HeaderName -> GenericBrowserAction m ()
withOverrideHeader :: Monad m => Header -> GenericBrowserAction m a -> GenericBrowserAction m a
getCheckStatus :: Monad m => GenericBrowserAction m (Maybe (Status -> ResponseHeaders -> CookieJar -> Maybe SomeException))
setCheckStatus :: Monad m => (Maybe (Status -> ResponseHeaders -> CookieJar -> Maybe SomeException)) -> GenericBrowserAction m ()
withCheckStatus :: Monad m => (Maybe (Status -> ResponseHeaders -> CookieJar -> Maybe SomeException)) -> GenericBrowserAction m a -> GenericBrowserAction m a
