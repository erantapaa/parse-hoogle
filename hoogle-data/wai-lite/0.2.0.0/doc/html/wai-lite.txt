-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | DEPCRECATED (use package "simple" instead) A minimalist web framework for WAI web applications
--   
--   A minimalist web framework for WAI web applications
@package wai-lite
@version 0.2.0.0


-- | This module defines some convenience functions for creating responses.

-- | <i>Deprecated: Use Web.Simple.Responses</i>
module Network.Wai.Responses

-- | Creates a 200 (OK) <a>Response</a> with the given content-type and
--   resposne body
ok :: ContentType -> ByteString -> Response

-- | Creates a 200 (OK) <a>Response</a> with content-type "text/html" and
--   the given resposne body
okHtml :: ByteString -> Response

-- | Given a URL returns a 301 (Moved Permanently) <a>Response</a>
--   redirecting to that URL.
movedTo :: String -> Response

-- | Given a URL returns a 303 (See Other) <a>Response</a> redirecting to
--   that URL.
redirectTo :: String -> Response

-- | Returns a 400 (Bad Request) <a>Response</a>.
badRequest :: Response

-- | Returns a 401 (Authorization Required) <a>Response</a> requiring basic
--   authentication in the given realm.
requireBasicAuth :: String -> Response

-- | Returns a 403 (Forbidden) <a>Response</a>.
forbidden :: Response

-- | Returns a 404 (Not Found) <a>Response</a>.
notFound :: Response

-- | Returns a 500 (Server Error) <a>Response</a>.
serverError :: Response


-- | Conceptually, a route is function that, given an HTTP request, may
--   return an action (something that would return a response for the
--   client if run). Routes can be concatenated--where each route is
--   evaluated until one matches--and nested. Routes are expressed through
--   the <a>Routeable</a> type class. <a>runRoute</a> transforms an
--   instance of <a>Routeable</a> to a function from <a>Request</a> to a
--   monadic action (in the <a>ResourceT</a> monad) that returns a
--   <a>Maybe</a> <a>Response</a>. The return type was chosen to be monadic
--   so routing decisions can depend on side-effects (e.g. a random number
--   or counter for A/B testing, IP geolocation lookup etc').

-- | <i>Deprecated: Use Simple.Web.Router</i>
module Network.Wai.Router

-- | <a>Routeable</a> types can be converted into a route function using
--   <a>runRoute</a>. If the route is matched it returns a <a>Response</a>,
--   otherwise <a>Nothing</a>.
--   
--   In general, <a>Routeable</a>s are data-dependant (on the
--   <a>Request</a>), but don't have to be. For example, <a>Application</a>
--   is an instance of <a>Routeable</a> that always returns a
--   <a>Response</a>:
--   
--   <pre>
--   instance Routeable Application where
--     runRoute app req = app req &gt;&gt;= return . Just
--   </pre>
class Routeable r
runRoute :: Routeable r => r -> Request -> ResourceT IO (Maybe Response)

-- | Converts any <a>Routeable</a> into an <a>Application</a> that can be
--   passed directly to a WAI server.
mkRouter :: Routeable r => r -> Application

-- | The <a>Route</a> type is a basic instance of <a>Routeable</a> that
--   simply holds the routing function and an arbitrary additional data
--   parameter. The power is derived from the instances of <a>Monad</a> and
--   <a>Monoid</a>, which allow the simple construction of complex routing
--   rules using either lists (<a>Monoid</a>) or do-notation. Moreover,
--   because of it's simple type, any <a>Routeable</a> can be used as a
--   <a>Route</a> (using <a>routeAll</a> or by applying it to
--   <a>runRoute</a>), making it possible to leverage the monadic or monoid
--   syntax for any <a>Routeable</a>.
--   
--   Commonly, route functions that construct a <a>Route</a> only inspect
--   the <a>Request</a> and other parameters. For example, <a>routeHost</a>
--   looks at the hostname:
--   
--   <pre>
--   routeHost :: Routeable r =&gt; S.ByteString -&gt; r -&gt; Route ()
--   routeHost host route = Route func ()
--     where func req = if host == serverName req
--                        then runRoute route req
--                        else return Nothing
--   </pre>
--   
--   However, because the result of a route is in the <a>ResourceT</a>
--   monad, routes have all the power of an <a>Application</a> and can make
--   state-dependant decisions. For example, it is trivial to implement a
--   route that succeeds for every other request (perhaps for A/B testing):
--   
--   <pre>
--   routeEveryOther :: (Routeable r1, Routeable r2)
--                   =&gt; TVar Int -&gt; r1 -&gt; r2 -&gt; Route ()
--   routeEveryOther counter r1 r2 = Route func ()
--     where func req = do
--             i &lt;- liftIO . atomically $ do
--                     i' &lt;- readTVar counter
--                     writeTVar counter (i' + 1)
--                     return i'
--             if i <a>mod</a> 2 == 0
--               then runRoute r1 req
--               else runRoute r2 req
--   </pre>
data Route a
Route :: (Request -> ResourceT IO (Maybe Response)) -> a -> Route a

-- | A route that always matches (useful for converting a <a>Routeable</a>
--   into a <a>Route</a>).
routeAll :: Routeable r => r -> Route ()

-- | Matches on the hostname from the <a>Request</a>. The route only
--   successeds on exact matches.
routeHost :: Routeable r => ByteString -> r -> Route ()

-- | Matches if the path is empty. Note that this route checks that
--   <a>pathInfo</a> is empty, so it works as expected when nested under
--   namespaces or other routes that pop the <a>pathInfo</a> list.
routeTop :: Routeable r => r -> Route ()

-- | Matches on the HTTP request method (e.g. <a>GET</a>, <a>POST</a>,
--   <a>PUT</a>)
routeMethod :: Routeable r => StdMethod -> r -> Route ()

-- | Routes the given URL pattern. Patterns can include directories as well
--   as variable patterns (prefixed with <tt>:</tt>) to be added to
--   <a>queryString</a> (see <a>routeVar</a>)
--   
--   <ul>
--   <li>/posts/:id</li>
--   <li>/posts/:id/new</li>
--   <li>/:date/posts/:category/new</li>
--   </ul>
routePattern :: Routeable r => ByteString -> r -> Route ()

-- | Matches if the first directory in the path matches the given
--   <tt>ByteString</tt>
routeName :: Routeable r => ByteString -> r -> Route ()

-- | Always matches if there is at least one directory in <a>pathInfo</a>
--   but and adds a parameter to <a>queryString</a> where the key is the
--   first parameter and the value is the directory consumed from the path.
routeVar :: Routeable r => ByteString -> r -> Route ()
instance Routeable (Route a)
instance Monoid (Route ())
instance Monad Route
instance Routeable Response
instance Routeable Application


-- | <a>Controller</a> provides a convenient syntax for writting
--   <a>Application</a> code as a Monadic action with access to an HTTP
--   request, rather than a function that takes the request as an argument.
--   This module also defines some helper functions that leverage this
--   feature. For example, <a>redirectBack</a> reads the underlying request
--   to extract the referer and returns a redirect response:
--   
--   <pre>
--   myController = do
--     ...
--     if badLogin then
--       redirectBack
--       else
--         ...
--   </pre>

-- | <i>Deprecated: Use Web.Simple.Controller</i>
module Network.Wai.Controller

-- | A <a>Controller</a> is a <a>Reader</a> monad that contains the HTTP
--   request in its environment. A <a>Controller</a> is <a>Routeable</a>
--   simply by running the <a>Reader</a>.
type Controller = ReaderT ControllerState (ResourceT IO)

-- | Redirect back to the referer. If the referer header is not present
--   redirect to root (i.e., <tt>/</tt>).
redirectBack :: Controller Response

-- | Redirect back to the referer. If the referer header is not present
--   fallback on the given <a>Response</a>.
redirectBackOr :: Response -> Controller Response

-- | Looks up the parameter name in the request's query string and returns
--   the value as a <a>ByteString</a> or <a>Nothing</a>.
--   
--   For example, for a request with query string: "?foo=bar&amp;baz=7",
--   <tt> queryParam "foo" </tt>
--   
--   would return <i>Just "bar"</i>, but
--   
--   <pre>
--   queryParam "zap"
--   </pre>
--   
--   would return <i>Nothing</i>
queryParam :: ByteString -> Controller (Maybe ByteString)

-- | Parses a HTML form from the request body. It returns a list of
--   <a>Param</a>s as well as a list of <a>File</a>s, which are pairs
--   mapping the name of a <i>file</i> form field to a <a>FileInfo</a>
--   pointing to a temporary file with the contents of the upload.
--   
--   <pre>
--   myController = do
--     (prms, files) &lt;- parseForm
--     let mPicFile = lookup "profile_pic" files
--     case mPicFile of
--       Just (picFile) -&gt; do
--         sourceFile (fileContent picFile) $$
--           sinkFile ("images/" ++ (fileName picFile))
--         respond $ redirectTo "/"
--       Nothing -&gt; redirectBack
--   </pre>
parseForm :: Controller ([Param], [(ByteString, FileInfo FilePath)])

-- | An alias for <a>return</a> that's helps the the compiler type a code
--   block as a <a>Controller</a>. For example, when using the <a>Frank</a>
--   routing DSL to define a simple route that justs returns a
--   <a>Response</a>, <a>respond</a> can be used to avoid explicit typing
--   of the argument:
--   
--   <pre>
--   get "/" $ do
--     someSideEffect
--     respond $ okHtml "Hello World"
--   </pre>
--   
--   instead of:
--   
--   <pre>
--   get "/" $ (do
--     someSideEffect
--     return $ okHtml "Hello World") :: Controller Response
--   </pre>
respond :: Routeable r => r -> Controller r

-- | Reads the underlying <a>Request</a>
request :: Controller Request

-- | Reads and returns the body of the HTTP request.
body :: Controller ByteString
instance Routeable (Controller Response)


-- | Frank is a Sinatra-inspired DSL (see <a>http://www.sinatrarb.com</a>)
--   for creating routes. It is composable with all <a>Routeable</a> types,
--   but is designed to be used with <a>Controller</a>s. Each verb
--   (<a>get</a>, <a>post</a>, <a>put</a>, etc') takes a URL pattern of the
--   form "/dir/:paramname/dir" (see <a>routePattern</a> for details) and a
--   <a>Routeable</a>:
--   
--   <pre>
--   main :: IO ()
--   main = runSettings defaultSettings $ mkRouter $ do
--     get "/" $ do
--       req &lt;- request
--       return $ okHtml $ fromString $
--         "Welcome Home " ++ (show $ serverName req)
--     get "/user/:id" $ do
--       userId &lt;- queryParam "id" &gt;&gt;= fromMaybe ""
--       return $ ok "text/json" $ fromString $
--         "{\"myid\": " ++ (show userId) ++ "}"
--     put "/user/:id" $ do
--       ...
--   </pre>

-- | <i>Deprecated: Use Web.Frank</i>
module Network.Wai.Frank

-- | Matches the GET method on the given URL pattern
get :: Routeable r => ByteString -> r -> Route ()

-- | Matches the POST method on the given URL pattern
post :: Routeable r => ByteString -> r -> Route ()

-- | Matches the PUT method on the given URL pattern
put :: Routeable r => ByteString -> r -> Route ()

-- | Matches the DELETE method on the given URL pattern
delete :: Routeable r => ByteString -> r -> Route ()

-- | Matches the OPTIONS method on the given URL pattern
options :: Routeable r => ByteString -> r -> Route ()


-- | <i>Deprecated: Use Web.REST</i>
module Network.Wai.REST
type RESTController = RESTControllerM ()
index :: Routeable r => r -> RESTController
show :: Routeable r => r -> RESTController
create :: Routeable r => r -> RESTController
update :: Routeable r => r -> RESTController
delete :: Routeable r => r -> RESTController
edit :: Routeable r => r -> RESTController
new :: Routeable r => r -> RESTController
instance Routeable (RESTControllerM a)
instance Routeable RESTControllerState


-- | This module defines some convenience functions for creating responses.
module Web.Simple.Responses

-- | Creates a 200 (OK) <a>Response</a> with the given content-type and
--   resposne body
ok :: ContentType -> ByteString -> Response

-- | Creates a 200 (OK) <a>Response</a> with content-type "text/html" and
--   the given resposne body
okHtml :: ByteString -> Response

-- | Given a URL returns a 301 (Moved Permanently) <a>Response</a>
--   redirecting to that URL.
movedTo :: String -> Response

-- | Given a URL returns a 303 (See Other) <a>Response</a> redirecting to
--   that URL.
redirectTo :: String -> Response

-- | Returns a 400 (Bad Request) <a>Response</a>.
badRequest :: Response

-- | Returns a 401 (Authorization Required) <a>Response</a> requiring basic
--   authentication in the given realm.
requireBasicAuth :: String -> Response

-- | Returns a 403 (Forbidden) <a>Response</a>.
forbidden :: Response

-- | Returns a 404 (Not Found) <a>Response</a>.
notFound :: Response

-- | Returns a 500 (Server Error) <a>Response</a>.
serverError :: Response


-- | Conceptually, a route is function that, given an HTTP request, may
--   return an action (something that would return a response for the
--   client if run). Routes can be concatenated--where each route is
--   evaluated until one matches--and nested. Routes are expressed through
--   the <a>Routeable</a> type class. <a>runRoute</a> transforms an
--   instance of <a>Routeable</a> to a function from <a>Request</a> to a
--   monadic action (in the <a>ResourceT</a> monad) that returns a
--   <a>Maybe</a> <a>Response</a>. The return type was chosen to be monadic
--   so routing decisions can depend on side-effects (e.g. a random number
--   or counter for A/B testing, IP geolocation lookup etc').
module Web.Simple.Router

-- | <a>Routeable</a> types can be converted into a route function using
--   <a>runRoute</a>. If the route is matched it returns a <a>Response</a>,
--   otherwise <a>Nothing</a>.
--   
--   In general, <a>Routeable</a>s are data-dependant (on the
--   <a>Request</a>), but don't have to be. For example, <a>Application</a>
--   is an instance of <a>Routeable</a> that always returns a
--   <a>Response</a>:
--   
--   <pre>
--   instance Routeable Application where
--     runRoute app req = app req &gt;&gt;= return . Just
--   </pre>
class Routeable r
runRoute :: Routeable r => r -> Request -> ResourceT IO (Maybe Response)

-- | Converts any <a>Routeable</a> into an <a>Application</a> that can be
--   passed directly to a WAI server.
mkRouter :: Routeable r => r -> Application

-- | The <a>Route</a> type is a basic instance of <a>Routeable</a> that
--   simply holds the routing function and an arbitrary additional data
--   parameter. The power is derived from the instances of <a>Monad</a> and
--   <a>Monoid</a>, which allow the simple construction of complex routing
--   rules using either lists (<a>Monoid</a>) or do-notation. Moreover,
--   because of it's simple type, any <a>Routeable</a> can be used as a
--   <a>Route</a> (using <a>routeAll</a> or by applying it to
--   <a>runRoute</a>), making it possible to leverage the monadic or monoid
--   syntax for any <a>Routeable</a>.
--   
--   Commonly, route functions that construct a <a>Route</a> only inspect
--   the <a>Request</a> and other parameters. For example, <a>routeHost</a>
--   looks at the hostname:
--   
--   <pre>
--   routeHost :: Routeable r =&gt; S.ByteString -&gt; r -&gt; Route ()
--   routeHost host route = Route func ()
--     where func req = if host == serverName req
--                        then runRoute route req
--                        else return Nothing
--   </pre>
--   
--   However, because the result of a route is in the <a>ResourceT</a>
--   monad, routes have all the power of an <a>Application</a> and can make
--   state-dependant decisions. For example, it is trivial to implement a
--   route that succeeds for every other request (perhaps for A/B testing):
--   
--   <pre>
--   routeEveryOther :: (Routeable r1, Routeable r2)
--                   =&gt; TVar Int -&gt; r1 -&gt; r2 -&gt; Route ()
--   routeEveryOther counter r1 r2 = Route func ()
--     where func req = do
--             i &lt;- liftIO . atomically $ do
--                     i' &lt;- readTVar counter
--                     writeTVar counter (i' + 1)
--                     return i'
--             if i <a>mod</a> 2 == 0
--               then runRoute r1 req
--               else runRoute r2 req
--   </pre>
data Route a
Route :: (Request -> ResourceT IO (Maybe Response)) -> a -> Route a

-- | A route that always matches (useful for converting a <a>Routeable</a>
--   into a <a>Route</a>).
routeAll :: Routeable r => r -> Route ()

-- | Matches on the hostname from the <a>Request</a>. The route only
--   successeds on exact matches.
routeHost :: Routeable r => ByteString -> r -> Route ()

-- | Matches if the path is empty. Note that this route checks that
--   <a>pathInfo</a> is empty, so it works as expected when nested under
--   namespaces or other routes that pop the <a>pathInfo</a> list.
routeTop :: Routeable r => r -> Route ()

-- | Matches on the HTTP request method (e.g. <a>GET</a>, <a>POST</a>,
--   <a>PUT</a>)
routeMethod :: Routeable r => StdMethod -> r -> Route ()

-- | Routes the given URL pattern. Patterns can include directories as well
--   as variable patterns (prefixed with <tt>:</tt>) to be added to
--   <a>queryString</a> (see <a>routeVar</a>)
--   
--   <ul>
--   <li>/posts/:id</li>
--   <li>/posts/:id/new</li>
--   <li>/:date/posts/:category/new</li>
--   </ul>
routePattern :: Routeable r => ByteString -> r -> Route ()

-- | Matches if the first directory in the path matches the given
--   <tt>ByteString</tt>
routeName :: Routeable r => ByteString -> r -> Route ()

-- | Always matches if there is at least one directory in <a>pathInfo</a>
--   but and adds a parameter to <a>queryString</a> where the key is the
--   first parameter and the value is the directory consumed from the path.
routeVar :: Routeable r => ByteString -> r -> Route ()
instance Routeable (Route a)
instance Monoid (Route ())
instance Monad Route
instance Routeable Response
instance Routeable Application


-- | <a>Controller</a> provides a convenient syntax for writting
--   <a>Application</a> code as a Monadic action with access to an HTTP
--   request, rather than a function that takes the request as an argument.
--   This module also defines some helper functions that leverage this
--   feature. For example, <a>redirectBack</a> reads the underlying request
--   to extract the referer and returns a redirect response:
--   
--   <pre>
--   myController = do
--     ...
--     if badLogin then
--       redirectBack
--       else
--         ...
--   </pre>
module Web.Simple.Controller

-- | A <a>Controller</a> is a <a>Reader</a> monad that contains the HTTP
--   request in its environment. A <a>Controller</a> is <a>Routeable</a>
--   simply by running the <a>Reader</a>.
type Controller = ReaderT ControllerState (ResourceT IO)

-- | Redirect back to the referer. If the referer header is not present
--   redirect to root (i.e., <tt>/</tt>).
redirectBack :: Controller Response

-- | Redirect back to the referer. If the referer header is not present
--   fallback on the given <a>Response</a>.
redirectBackOr :: Response -> Controller Response

-- | Looks up the parameter name in the request's query string and returns
--   the value as a <a>ByteString</a> or <a>Nothing</a>.
--   
--   For example, for a request with query string: "?foo=bar&amp;baz=7",
--   <tt> queryParam "foo" </tt>
--   
--   would return <i>Just "bar"</i>, but
--   
--   <pre>
--   queryParam "zap"
--   </pre>
--   
--   would return <i>Nothing</i>
queryParam :: ByteString -> Controller (Maybe ByteString)

-- | Parses a HTML form from the request body. It returns a list of
--   <a>Param</a>s as well as a list of <a>File</a>s, which are pairs
--   mapping the name of a <i>file</i> form field to a <a>FileInfo</a>
--   pointing to a temporary file with the contents of the upload.
--   
--   <pre>
--   myController = do
--     (prms, files) &lt;- parseForm
--     let mPicFile = lookup "profile_pic" files
--     case mPicFile of
--       Just (picFile) -&gt; do
--         sourceFile (fileContent picFile) $$
--           sinkFile ("images/" ++ (fileName picFile))
--         respond $ redirectTo "/"
--       Nothing -&gt; redirectBack
--   </pre>
parseForm :: Controller ([Param], [(ByteString, FileInfo FilePath)])

-- | An alias for <a>return</a> that's helps the the compiler type a code
--   block as a <a>Controller</a>. For example, when using the <a>Frank</a>
--   routing DSL to define a simple route that justs returns a
--   <a>Response</a>, <a>respond</a> can be used to avoid explicit typing
--   of the argument:
--   
--   <pre>
--   get "/" $ do
--     someSideEffect
--     respond $ okHtml "Hello World"
--   </pre>
--   
--   instead of:
--   
--   <pre>
--   get "/" $ (do
--     someSideEffect
--     return $ okHtml "Hello World") :: Controller Response
--   </pre>
respond :: Routeable r => r -> Controller r

-- | Reads the underlying <a>Request</a>
request :: Controller Request

-- | Reads and returns the body of the HTTP request.
body :: Controller ByteString
instance Routeable (Controller Response)


-- | Frank is a Sinatra-inspired DSL (see <a>http://www.sinatrarb.com</a>)
--   for creating routes. It is composable with all <a>Routeable</a> types,
--   but is designed to be used with <a>Controller</a>s. Each verb
--   (<a>get</a>, <a>post</a>, <a>put</a>, etc') takes a URL pattern of the
--   form "/dir/:paramname/dir" (see <a>routePattern</a> for details) and a
--   <a>Routeable</a>:
--   
--   <pre>
--   main :: IO ()
--   main = runSettings defaultSettings $ mkRouter $ do
--     get "/" $ do
--       req &lt;- request
--       return $ okHtml $ fromString $
--         "Welcome Home " ++ (show $ serverName req)
--     get "/user/:id" $ do
--       userId &lt;- queryParam "id" &gt;&gt;= fromMaybe ""
--       return $ ok "text/json" $ fromString $
--         "{\"myid\": " ++ (show userId) ++ "}"
--     put "/user/:id" $ do
--       ...
--   </pre>
module Web.Frank

-- | Matches the GET method on the given URL pattern
get :: Routeable r => ByteString -> r -> Route ()

-- | Matches the POST method on the given URL pattern
post :: Routeable r => ByteString -> r -> Route ()

-- | Matches the PUT method on the given URL pattern
put :: Routeable r => ByteString -> r -> Route ()

-- | Matches the DELETE method on the given URL pattern
delete :: Routeable r => ByteString -> r -> Route ()

-- | Matches the OPTIONS method on the given URL pattern
options :: Routeable r => ByteString -> r -> Route ()

module Web.REST
type RESTController = RESTControllerM ()
index :: Routeable r => r -> RESTController
show :: Routeable r => r -> RESTController
create :: Routeable r => r -> RESTController
update :: Routeable r => r -> RESTController
delete :: Routeable r => r -> RESTController
edit :: Routeable r => r -> RESTController
new :: Routeable r => r -> RESTController
instance Routeable (RESTControllerM a)
instance Routeable RESTControllerState

module Web.Simple
