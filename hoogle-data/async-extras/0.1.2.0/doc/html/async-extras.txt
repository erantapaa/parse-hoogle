-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extra Utilities for the Async Library
--   
--   Extra Utilities for the Async Library
@package async-extras
@version 0.1.2.0

module Control.Concurrent.Async.Lifted.Extra

-- | Implementation derived from Petr Pudl치k's answer on StackOverflow
--   <a>http://stackoverflow.com/a/18898822/230050</a>
sequencePool :: (Traversable t, MonadBaseControl IO m) => Int -> t (m a) -> m (t a)

-- | Implementation copied from Petr Pudl치k's answer on StackOverflow
--   <a>http://stackoverflow.com/a/18898822/230050</a>
mapPool :: (Traversable t, MonadBaseControl IO m) => Int -> (a -> m b) -> t a -> m (t b)
sequenceConcurrently :: (Traversable t, MonadBaseControl IO m) => t (m a) -> m (t a)

-- | Create an <a>Async</a> and pass it to itself.
fixAsync :: (MonadFix m, MonadBaseControl IO m) => (Async (StM m a) -> m a) -> m (Async (StM m a))

-- | Like <a>fixAsync</a> but using <a>forkOS</a> internally.
fixAsyncBound :: (MonadFix m, MonadBaseControl IO m) => (Async (StM m a) -> m a) -> m (Async (StM m a))

-- | Like <a>fixAsync</a> but using <a>forkOn</a> internally.
fixAsyncOn :: (MonadFix m, MonadBaseControl IO m) => Int -> (Async (StM m a) -> m a) -> m (Async (StM m a))

-- | Like <a>fixAsync</a> but using <a>forkIOWithUnmask</a> internally. The
--   child thread is passed a function that can be used to unmask
--   asynchronous exceptions.
fixAsyncWithUnmask :: (MonadFix m, MonadBaseControl IO m) => (Async (StM m a) -> (forall b. m b -> m b) -> m a) -> m (Async (StM m a))

-- | Like <a>fixAsyncOn</a> but using <a>forkOnWithUnmask</a> internally.
--   The child thread is passed a function that can be used to unmask
--   asynchronous exceptions.
fixAsyncOnWithUnmask :: (MonadFix m, MonadBaseControl IO m) => Int -> (Async (StM m a) -> (forall b. m b -> m b) -> m a) -> m (Async (StM m a))

-- | Create an async that is linked to a parent. If the parent dies so does
--   this async
withParent :: MonadBaseControl IO m => Async (StM m a) -> m b -> m (Async (StM m b))

-- | <a>Promise</a> is like <a>Concurrently</a> but includes a sequential
--   monad instance
newtype Promise (b :: * -> *) m a
Promise :: m a -> Promise m a
unPromise :: Promise m a -> m a
instance (b ~ IO, MonadBaseControl b m) => MonadPlus (Promise b m)
instance (b ~ IO, MonadBaseControl b m) => Monad (Promise b m)
instance (b ~ IO, MonadBaseControl b m) => Alternative (Promise b m)
instance (b ~ IO, MonadBaseControl b m) => Applicative (Promise b m)
instance (b ~ IO, Functor m) => Functor (Promise b m)

module Control.Concurrent.Async.Extra

-- | Implementation derived from Petr Pudl치k's answer on StackOverflow
--   <a>http://stackoverflow.com/a/18898822/230050</a>
sequencePool :: Traversable t => Int -> t (IO a) -> IO (t a)

-- | Implementation copied from Petr Pudl치k's answer on StackOverflow
--   <a>http://stackoverflow.com/a/18898822/230050</a>
mapPool :: Traversable t => Int -> (a -> IO b) -> t a -> IO (t b)
sequenceConcurrently :: Traversable t => t (IO a) -> IO (t a)

-- | Create an <a>Async</a> and pass it to itself.
fixAsync :: (Async a -> IO a) -> IO (Async a)

-- | Like <a>fixAsync</a> but using <a>forkOS</a> internally.
fixAsyncBound :: (Async a -> IO a) -> IO (Async a)

-- | Like <a>fixAsync</a> but using <a>forkOn</a> internally.
fixAsyncOn :: Int -> (Async a -> IO a) -> IO (Async a)

-- | Like <a>fixAsync</a> but using <a>forkIOWithUnmask</a> internally. The
--   child thread is passed a function that can be used to unmask
--   asynchronous exceptions.
fixAsyncWithUnmask :: (Async a -> (forall b. IO b -> IO b) -> IO a) -> IO (Async a)

-- | Like <a>fixAsyncOn</a> but using <a>forkOnWithUnmask</a> internally.
--   The child thread is passed a function that can be used to unmask
--   asynchronous exceptions.
fixAsyncOnWithUnmask :: Int -> (Async a -> (forall b. IO b -> IO b) -> IO a) -> IO (Async a)

-- | Create an async that is linked to a parent. If the parent dies so does
--   this async
withParent :: Async a -> IO b -> IO (Async b)

-- | <a>Promise</a> is like <a>Concurrently</a> but includes a sequential
--   monad instance
newtype Promise a
Promise :: IO a -> Promise a
unPromise :: Promise a -> IO a
instance Functor Promise
instance MonadPlus Promise
instance Monad Promise
instance Alternative Promise
instance Applicative Promise
