-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | REdis Serialization Protocol (RESP) implementation.
--   
@package redis-resp
@version 0.3.1

module Data.Redis.Resp

-- | <a>Resp</a> defines the various RESP constructors.
data Resp

-- | RESP simple strings
Str :: !ByteString -> Resp

-- | RESP errors
Err :: !ByteString -> Resp

-- | RESP integers
Int :: !Int64 -> Resp

-- | RESP bulk strings
Bulk :: !ByteString -> Resp

-- | RESP arrays
Array :: !Int -> [Resp] -> Resp
NullArray :: Resp
NullBulk :: Resp

-- | An attoparsec parser to parse a single <a>Resp</a> value.
resp :: Parser Resp
encode :: Resp -> ByteString
decode :: ByteString -> Either String Resp
instance Eq Resp
instance Ord Resp
instance Show Resp

module Data.Redis.Command
type Redis = ProgramT Command
type PubSub = ProgramT PubSubCommand

-- | Redis commands.
data Command :: * -> *
Ping :: Resp -> Command ()
Echo :: Resp -> Command a
Auth :: Resp -> Command ()
Quit :: Resp -> Command ()
Select :: Resp -> Command ()
BgRewriteAOF :: Resp -> Command ()
BgSave :: Resp -> Command ()
Save :: Resp -> Command ()
DbSize :: Resp -> Command Int64
FlushAll :: Resp -> Command ()
FlushDb :: Resp -> Command ()
LastSave :: Resp -> Command Int64
Multi :: Resp -> Command ()
Watch :: Resp -> Command ()
Unwatch :: Resp -> Command ()
Discard :: Resp -> Command ()
Exec :: Resp -> Command [a]
ExecRaw :: Resp -> Command Resp
Del :: Resp -> Command Int64
Dump :: Resp -> Command (Maybe ByteString)
Exists :: Resp -> Command Bool
Expire :: Resp -> Command Bool
ExpireAt :: Resp -> Command Bool
Persist :: Resp -> Command Bool
Keys :: Resp -> Command [Key]
RandomKey :: Resp -> Command (Maybe Key)
Rename :: Resp -> Command ()
RenameNx :: Resp -> Command Bool
Sort :: Resp -> Command [a]
Ttl :: Resp -> Command (Maybe TTL)
Type :: Resp -> Command (Maybe RedisType)
Scan :: Resp -> Command (Cursor, [a])
Append :: Resp -> Command Int64
Get :: Resp -> Command (Maybe a)
GetRange :: Resp -> Command a
GetSet :: Resp -> Command (Maybe a)
MGet :: Resp -> Command [Maybe a]
MSet :: Resp -> Command ()
MSetNx :: Resp -> Command Bool
Set :: Resp -> Command Bool
SetRange :: Resp -> Command Int64
StrLen :: Resp -> Command Int64
BitAnd :: Resp -> Command Int64
BitCount :: Resp -> Command Int64
BitNot :: Resp -> Command Int64
BitOr :: Resp -> Command Int64
BitPos :: Resp -> Command Int64
BitXOr :: Resp -> Command Int64
GetBit :: Resp -> Command Int64
SetBit :: Resp -> Command Int64
Decr :: Resp -> Command Int64
DecrBy :: Resp -> Command Int64
Incr :: Resp -> Command Int64
IncrBy :: Resp -> Command Int64
IncrByFloat :: Resp -> Command Double
HDel :: Resp -> Command Int64
HExists :: Resp -> Command Bool
HGet :: Resp -> Command (Maybe a)
HGetAll :: Resp -> Command [(Field, a)]
HIncrBy :: Resp -> Command Int64
HIncrByFloat :: Resp -> Command Double
HKeys :: Resp -> Command [Field]
HLen :: Resp -> Command Int64
HMGet :: Resp -> Command [Maybe a]
HMSet :: Resp -> Command ()
HSet :: Resp -> Command Bool
HSetNx :: Resp -> Command Bool
HVals :: Resp -> Command [a]
HScan :: Resp -> Command (Cursor, [a])
BLPop :: Int64 -> Resp -> Command (Maybe (Key, a))
BRPop :: Int64 -> Resp -> Command (Maybe (Key, a))
BRPopLPush :: Int64 -> Resp -> Command (Maybe a)
LIndex :: Resp -> Command (Maybe a)
LInsert :: Resp -> Command Int64
LLen :: Resp -> Command Int64
LPop :: Resp -> Command (Maybe a)
LPush :: Resp -> Command Int64
LPushX :: Resp -> Command Int64
LRange :: Resp -> Command [a]
LRem :: Resp -> Command Int64
LSet :: Resp -> Command ()
LTrim :: Resp -> Command ()
RPop :: Resp -> Command (Maybe a)
RPopLPush :: Resp -> Command (Maybe a)
RPush :: Resp -> Command Int64
RPushX :: Resp -> Command Int64
SAdd :: Resp -> Command Int64
SCard :: Resp -> Command Int64
SDiff :: Resp -> Command [a]
SDiffStore :: Resp -> Command Int64
SInter :: Resp -> Command [a]
SInterStore :: Resp -> Command Int64
SIsMember :: Resp -> Command Bool
SMembers :: Resp -> Command [a]
SMove :: Resp -> Command Bool
SPop :: Resp -> Command (Maybe a)
SRandMember :: Choose -> Resp -> Command [a]
SRem :: Resp -> Command Int64
SScan :: Resp -> Command (Cursor, [a])
SUnion :: Resp -> Command [a]
SUnionStore :: Resp -> Command Int64
ZAdd :: Resp -> Command Int64
ZCard :: Resp -> Command Int64
ZCount :: Resp -> Command Int64
ZIncrBy :: Resp -> Command Double
ZInterStore :: Resp -> Command Int64
ZLexCount :: Resp -> Command Int64
ZRange :: Bool -> Resp -> Command (ScoreList a)
ZRangeByLex :: Resp -> Command [a]
ZRangeByScore :: Bool -> Resp -> Command (ScoreList a)
ZRank :: Resp -> Command (Maybe Int64)
ZRem :: Resp -> Command Int64
ZRemRangeByLex :: Resp -> Command Int64
ZRemRangeByRank :: Resp -> Command Int64
ZRemRangeByScore :: Resp -> Command Int64
ZRevRange :: Bool -> Resp -> Command (ScoreList a)
ZRevRangeByScore :: Bool -> Resp -> Command (ScoreList a)
ZRevRank :: Resp -> Command (Maybe Int64)
ZScan :: Resp -> Command (Cursor, [a])
ZScore :: Resp -> Command (Maybe Double)
ZUnionStore :: Resp -> Command Int64
PfAdd :: Resp -> Command Bool
PfCount :: Resp -> Command Int64
PfMerge :: Resp -> Command ()
Publish :: Resp -> Command Int64

-- | Pub/Sub commands.
data PubSubCommand r
Subscribe :: Resp -> PubSubCommand ()
Unsubscribe :: Resp -> PubSubCommand ()
PSubscribe :: Resp -> PubSubCommand ()
PUnsubscribe :: Resp -> PubSubCommand ()

-- | Messages which are published to subscribers.
data PushMessage
SubscribeMessage :: !ByteString -> !Int64 -> PushMessage
channel :: PushMessage -> !ByteString
subscriptions :: PushMessage -> !Int64
UnsubscribeMessage :: !ByteString -> !Int64 -> PushMessage
channel :: PushMessage -> !ByteString
subscriptions :: PushMessage -> !Int64
Message :: !ByteString -> !ByteString -> PushMessage
channel :: PushMessage -> !ByteString
message :: PushMessage -> !ByteString
PMessage :: !ByteString -> !ByteString -> !ByteString -> PushMessage
pattern :: PushMessage -> !ByteString
channel :: PushMessage -> !ByteString
message :: PushMessage -> !ByteString
type Result = Either RedisError

-- | Redis error type.
data RedisError

-- | General error case.
RedisError :: !ByteString -> RedisError

-- | The received response is invalid or unexpected (e.g. a bulk string
--   instead of an integer).
InvalidResponse :: !String -> RedisError

-- | ByteString conversion using <a>FromByteString</a> failed.
InvalidConversion :: !String -> RedisError

-- | The types redis reports via <a>type</a>.
data RedisType
RedisString :: RedisType
RedisList :: RedisType
RedisSet :: RedisType
RedisZSet :: RedisType
RedisHash :: RedisType

-- | A type representing time-to-live values.
data TTL
NoTTL :: TTL
TTL :: !Int64 -> TTL

-- | Used in <a>linsert</a> to specify the insertion point.
data Side
Before :: Side
After :: Side
data Choose

-- | Exactly one element
One :: Choose

-- | <tt>n</tt> distint elements
Dist :: !Int64 -> Choose

-- | <tt>n</tt> arbitrary (i.e. potentially repeated) elements
Arb :: !Int64 -> Choose
data Aggregate

-- | no aggregation
None :: Aggregate

-- | take the minimum score
Min :: Aggregate

-- | take the maximum score
Max :: Aggregate

-- | addition of scores
Sum :: Aggregate
data Min

-- | lower bound (inclusive)
MinIncl :: !ByteString -> Min

-- | lower bound (exclusive)
MinExcl :: !ByteString -> Min

-- | infinite lower bound
MinInf :: Min
data Max

-- | upper bound (inclusive)
MaxIncl :: !ByteString -> Max

-- | upper bound (exclusive)
MaxExcl :: !ByteString -> Max

-- | infinite upper bound
MaxInf :: Max
data ScoreList a
ScoreList :: [Double] -> [a] -> ScoreList a
scores :: ScoreList a -> [Double]
elements :: ScoreList a -> [a]
newtype Seconds
Seconds :: Int64 -> Seconds
newtype Timestamp
Timestamp :: Int64 -> Timestamp
type Field = ByteString
type Index = Int64

-- | Redis key type
newtype Key
Key :: ByteString -> Key
key :: Key -> ByteString
data Cursor
zero :: Cursor
one :: a -> NonEmpty a

-- | Command options
data Opts (a :: Symbol)
none :: Monoid m => m
data BitStart
data BitEnd
start :: Int64 -> BitStart
end :: Int64 -> BitEnd
auth :: Monad m => ByteString -> Redis m ()
echo :: (Monad m, ToByteString a, FromByteString a) => a -> Redis m a
ping :: Monad m => Redis m ()
quit :: Monad m => Redis m ()
select :: Monad m => Int64 -> Redis m ()
bgrewriteaof :: Monad m => Redis m ()
bgsave :: Monad m => Redis m ()
dbsize :: Monad m => Redis m Int64
flushall :: Monad m => Redis m ()
flushdb :: Monad m => Redis m ()
lastsave :: Monad m => Redis m Int64
save :: Monad m => Redis m ()
discard :: Monad m => Redis m ()
exec :: (Monad m, FromByteString a) => Redis m [a]
execRaw :: Monad m => Redis m Resp
multi :: Monad m => Redis m ()
unwatch :: Monad m => Redis m ()
watch :: Monad m => NonEmpty Key -> Redis m ()
del :: Monad m => NonEmpty Key -> Redis m Int64
dump :: Monad m => Key -> Redis m (Maybe ByteString)
exists :: Monad m => Key -> Redis m Bool
expire :: Monad m => Key -> Seconds -> Redis m Bool
expireat :: Monad m => Key -> Timestamp -> Redis m Bool
keys :: Monad m => ByteString -> Redis m [Key]
persist :: Monad m => Key -> Redis m Bool
randomkey :: Monad m => Redis m (Maybe Key)
rename :: Monad m => Key -> Key -> Redis m ()
renamenx :: Monad m => Key -> Key -> Redis m Bool
ttl :: Monad m => Key -> Redis m (Maybe TTL)
typeof :: Monad m => Key -> Redis m (Maybe RedisType)
append :: (Monad m, ToByteString a) => Key -> a -> Redis m Int64
decr :: Monad m => Key -> Redis m Int64
decrby :: Monad m => Key -> Int64 -> Redis m Int64
get :: (Monad m, FromByteString a) => Key -> Redis m (Maybe a)
getrange :: (Monad m, FromByteString a) => Key -> Int64 -> Int64 -> Redis m a
getset :: (Monad m, ToByteString a, FromByteString b) => Key -> a -> Redis m (Maybe b)
incr :: Monad m => Key -> Redis m Int64
incrby :: Monad m => Key -> Int64 -> Redis m Int64
incrbyfloat :: Monad m => Key -> Double -> Redis m Double
mget :: (Monad m, FromByteString a) => NonEmpty Key -> Redis m [Maybe a]
mset :: (Monad m, ToByteString a) => NonEmpty (Key, a) -> Redis m ()
msetnx :: (Monad m, ToByteString a) => NonEmpty (Key, a) -> Redis m Bool
set :: (Monad m, ToByteString a) => Key -> a -> Opts "SET" -> Redis m Bool
ex :: Int64 -> Opts "SET"
px :: Int64 -> Opts "SET"
xx :: Opts "SET"
nx :: Opts "SET"
setrange :: (Monad m, ToByteString a) => Key -> Int64 -> a -> Redis m Int64
strlen :: Monad m => Key -> Redis m Int64
bitand :: Monad m => Key -> NonEmpty Key -> Redis m Int64
bitcount :: Monad m => Key -> Opts "RANGE" -> Redis m Int64
range :: Int64 -> Int64 -> Opts "RANGE"
bitnot :: Monad m => Key -> Key -> Redis m Int64
bitor :: Monad m => Key -> NonEmpty Key -> Redis m Int64
bitpos :: Monad m => Key -> Bool -> BitStart -> BitEnd -> Redis m Int64
bitxor :: Monad m => Key -> NonEmpty Key -> Redis m Int64
getbit :: Monad m => Key -> Int64 -> Redis m Int64
setbit :: Monad m => Key -> Int64 -> Bool -> Redis m Int64
hdel :: Monad m => Key -> NonEmpty Field -> Redis m Int64
hexists :: Monad m => Key -> Field -> Redis m Bool
hget :: (Monad m, FromByteString a) => Key -> Field -> Redis m (Maybe a)
hgetall :: (Monad m, FromByteString a) => Key -> Redis m [(Field, a)]
hincrby :: Monad m => Key -> Field -> Int64 -> Redis m Int64
hincrbyfloat :: Monad m => Key -> Field -> Double -> Redis m Double
hkeys :: Monad m => Key -> Redis m [Field]
hlen :: Monad m => Key -> Redis m Int64
hmget :: (Monad m, FromByteString a) => Key -> NonEmpty Field -> Redis m [Maybe a]
hmset :: (Monad m, ToByteString a) => Key -> NonEmpty (Field, a) -> Redis m ()
hset :: (Monad m, ToByteString a) => Key -> Field -> a -> Redis m Bool
hsetnx :: (Monad m, ToByteString a) => Key -> Field -> a -> Redis m Bool
hvals :: (Monad m, FromByteString a) => Key -> Redis m [a]
blpop :: (Monad m, FromByteString a) => NonEmpty Key -> Seconds -> Redis m (Maybe (Key, a))
brpop :: (Monad m, FromByteString a) => NonEmpty Key -> Seconds -> Redis m (Maybe (Key, a))
brpoplpush :: (Monad m, FromByteString a) => Key -> Key -> Seconds -> Redis m (Maybe a)
lindex :: (Monad m, FromByteString a) => Key -> Index -> Redis m (Maybe a)
linsert :: (Monad m, ToByteString a) => Key -> Side -> a -> a -> Redis m Int64
llen :: Monad m => Key -> Redis m Int64
lpop :: (Monad m, FromByteString a) => Key -> Redis m (Maybe a)
lpush :: (Monad m, ToByteString a) => Key -> NonEmpty a -> Redis m Int64
lpushx :: (Monad m, ToByteString a) => Key -> a -> Redis m Int64
lrange :: (Monad m, FromByteString a) => Key -> Int64 -> Int64 -> Redis m [a]
lrem :: (Monad m, ToByteString a) => Key -> Int64 -> a -> Redis m Int64
lset :: (Monad m, ToByteString a) => Key -> Int64 -> a -> Redis m ()
ltrim :: Monad m => Key -> Int64 -> Int64 -> Redis m ()
rpop :: (Monad m, FromByteString a) => Key -> Redis m (Maybe a)
rpoplpush :: (Monad m, FromByteString a) => Key -> Key -> Redis m (Maybe a)
rpush :: (Monad m, ToByteString a) => Key -> NonEmpty a -> Redis m Int64
rpushx :: (Monad m, ToByteString a) => Key -> a -> Redis m Int64
sadd :: (Monad m, ToByteString a) => Key -> NonEmpty a -> Redis m Int64
scard :: Monad m => Key -> Redis m Int64
sdiff :: (Monad m, FromByteString a) => NonEmpty Key -> Redis m [a]
sdiffstore :: Monad m => Key -> NonEmpty Key -> Redis m Int64
sinter :: (Monad m, FromByteString a) => NonEmpty Key -> Redis m [a]
sinterstore :: Monad m => Key -> NonEmpty Key -> Redis m Int64
sismember :: (Monad m, ToByteString a) => Key -> a -> Redis m Bool
smembers :: (Monad m, FromByteString a) => Key -> Redis m [a]
smove :: (Monad m, ToByteString a) => Key -> Key -> a -> Redis m Bool
spop :: (Monad m, FromByteString a) => Key -> Redis m (Maybe a)
srandmember :: (Monad m, FromByteString a) => Key -> Choose -> Redis m [a]
srem :: (Monad m, ToByteString a) => Key -> NonEmpty a -> Redis m Int64
sunion :: (Monad m, FromByteString a) => NonEmpty Key -> Redis m [a]
sunionstore :: Monad m => Key -> NonEmpty Key -> Redis m Int64
zadd :: (Monad m, ToByteString a) => Key -> NonEmpty (Double, a) -> Redis m Int64
zcard :: Monad m => Key -> Redis m Int64
zcount :: Monad m => Key -> Double -> Double -> Redis m Int64
zincrby :: (Monad m, ToByteString a) => Key -> Double -> a -> Redis m Double
zinterstore :: Monad m => Key -> NonEmpty Key -> [Int64] -> Aggregate -> Redis m Int64
zlexcount :: Monad m => Key -> Min -> Max -> Redis m Int64
zrange :: (Monad m, FromByteString a) => Key -> Int64 -> Int64 -> Bool -> Redis m (ScoreList a)
zrangebylex :: (Monad m, FromByteString a) => Key -> Min -> Max -> Opts "LIMIT" -> Redis m [a]
zrangebyscore :: (Monad m, FromByteString a) => Key -> Double -> Double -> Bool -> Opts "LIMIT" -> Redis m (ScoreList a)
zrank :: (Monad m, ToByteString a) => Key -> a -> Redis m (Maybe Int64)
zrem :: (Monad m, ToByteString a) => Key -> NonEmpty a -> Redis m Int64
zremrangebylex :: Monad m => Key -> Min -> Max -> Redis m Int64
zremrangebyrank :: Monad m => Key -> Int64 -> Int64 -> Redis m Int64
zremrangebyscore :: Monad m => Key -> Double -> Double -> Redis m Int64
zrevrangebyscore :: (Monad m, FromByteString a) => Key -> Double -> Double -> Bool -> Opts "LIMIT" -> Redis m (ScoreList a)
zrevrange :: (Monad m, FromByteString a) => Key -> Int64 -> Int64 -> Bool -> Redis m (ScoreList a)
zrevrank :: (Monad m, ToByteString a) => Key -> a -> Redis m (Maybe Int64)
zscore :: (Monad m, ToByteString a) => Key -> a -> Redis m (Maybe Double)
zunionstore :: Monad m => Key -> NonEmpty Key -> [Int64] -> Aggregate -> Redis m Int64
pfadd :: (Monad m, ToByteString a) => Key -> NonEmpty a -> Redis m Bool
pfcount :: Monad m => NonEmpty Key -> Redis m Int64
pfmerge :: Monad m => Key -> NonEmpty Key -> Redis m ()
scan :: (Monad m, FromByteString a) => Cursor -> Opts "SCAN" -> Redis m (Cursor, [a])
match :: ByteString -> Opts "SCAN"
count :: Int64 -> Opts "SCAN"
hscan :: (Monad m, FromByteString a) => Key -> Cursor -> Opts "SCAN" -> Redis m (Cursor, [a])
sscan :: (Monad m, FromByteString a) => Key -> Cursor -> Opts "SCAN" -> Redis m (Cursor, [a])
zscan :: (Monad m, FromByteString a) => Key -> Cursor -> Opts "SCAN" -> Redis m (Cursor, [a])
sort :: (Monad m, FromByteString a) => Key -> Opts "SORT" -> Redis m [a]
by :: ByteString -> Opts "SORT"
limit :: Int64 -> Int64 -> Opts o
getkey :: NonEmpty ByteString -> Opts "SORT"
asc :: Opts "SORT"
desc :: Opts "SORT"
alpha :: Opts "SORT"
store :: Key -> Opts "SORT"
publish :: (Monad m, ToByteString a) => ByteString -> a -> Redis m Int64
subscribe :: Monad m => NonEmpty ByteString -> PubSub m ()
psubscribe :: Monad m => NonEmpty ByteString -> PubSub m ()
unsubscribe :: Monad m => [ByteString] -> PubSub m ()
punsubscribe :: Monad m => [ByteString] -> PubSub m ()
readInt :: String -> Resp -> Result Int64
readInt'Null :: String -> Resp -> Result (Maybe Int64)
readBool :: String -> Resp -> Result Bool
readTTL :: String -> Resp -> Result (Maybe TTL)
readBulk'Null :: FromByteString a => String -> Resp -> Result (Maybe a)
readBulk :: FromByteString a => String -> Resp -> Result a
readListOfMaybes :: FromByteString a => String -> Resp -> Result [Maybe a]
readList :: FromByteString a => String -> Resp -> Result [a]
readScoreList :: FromByteString a => String -> Bool -> Resp -> Result (ScoreList a)
readFields :: FromByteString a => String -> Resp -> Result [(Field, a)]
readKeyValue :: FromByteString a => String -> Resp -> Result (Maybe (Key, a))
readBulk'Array :: FromByteString a => String -> Choose -> Resp -> Result [a]
readScan :: FromByteString a => String -> Resp -> Result (Cursor, [a])
matchStr :: String -> ByteString -> Resp -> Result ()
readType :: String -> Resp -> Result (Maybe RedisType)
fromSet :: Resp -> Result Bool
anyStr :: String -> Resp -> Result ()
readPushMessage :: Resp -> Result PushMessage
data NonEmpty a :: * -> *
(:|) :: a -> [a] -> NonEmpty a

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)
instance Typeable RedisError
instance Eq RedisError
instance Ord RedisError
instance Show RedisError
instance Eq PushMessage
instance Ord PushMessage
instance Show PushMessage
instance Eq RedisType
instance Ord RedisType
instance Show RedisType
instance Eq TTL
instance Ord TTL
instance Show TTL
instance Eq Side
instance Ord Side
instance Show Side
instance Eq Choose
instance Ord Choose
instance Show Choose
instance Eq Aggregate
instance Ord Aggregate
instance Show Aggregate
instance Eq Min
instance Ord Min
instance Show Min
instance Eq Max
instance Ord Max
instance Show Max
instance Eq a => Eq (ScoreList a)
instance Ord a => Ord (ScoreList a)
instance Show a => Show (ScoreList a)
instance Eq Cursor
instance Ord Cursor
instance Show Cursor
instance FromByteString Cursor
instance Eq Key
instance Ord Key
instance Show Key
instance FromByteString Key
instance Monoid BitEnd
instance Monoid BitStart
instance Monoid (Opts a)
instance IsString Key
instance Exception RedisError

module Data.Redis
