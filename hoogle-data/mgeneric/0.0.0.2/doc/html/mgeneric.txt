-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generics with multiple parameters
--   
@package mgeneric
@version 0.0.0.2

module Data.Nat
data Nat
NZ :: Nat
NS :: Nat -> Nat

module Data.HList
data HList as
HNil :: HList []
HCons :: a -> HList as -> HList (a : as)
class HNth as n
hnth :: HNth as n => HList as -> Proxy n -> as :!: n
class HMap (as :: [k]) (f :: k -> *) (g :: k -> *)
hmap :: HMap as f g => Proxy as -> (forall (i :: k). f i -> g i) -> HList (Map f as) -> HList (Map g as)
class HLookup n as
hlookup :: HLookup n as => Proxy n -> Proxy as -> HList as -> as :!: n
instance HLookup n as => HLookup ('NS n) (a : as)
instance HLookup 'NZ (a : as)
instance HMap as f g => HMap (a : as) f g
instance HMap '[] f g
instance HNth (a : as) 'NZ
instance HNth as n => HNth (b : as) ('NS n)

module Data.HList.TH
hlist :: ExpQ -> ExpQ

module Data.MGeneric

-- | Type level application
--   
--   <pre>
--   f :$: '[a, b, ...] ~ f a b ...
--   </pre>

-- | Universe kind
--   
--   The s parameter should always be *
data Un s

-- | Empty universe
UV :: Un s

-- | Trivial universe
UT :: Un s

-- | Lifts from the field universe
UF :: (Field s) -> Un s

-- | Product universe
(:**:) :: Un s -> Un s -> Un s

-- | Sum universe
(:++:) :: Un s -> Un s -> Un s

-- | Field kind
--   
--   The s parameter should always be *
--   
--   (FK a) can be replaced by (a :@: []), but the empty application case
--   is often handled differently in generic type classes
data Field s

-- | Constant field
FK :: s -> Field s

-- | Parameter field
FP :: Nat -> Field s

-- | Application field
(:@:) :: k -> [Field s] -> Field s

-- | Universe <tt>u</tt> inhabitation with parameters <tt>ps</tt>
data In (u :: Un *) (ps :: [*]) :: *
InT :: In UT ps
InF :: InField f ps -> In (UF f) ps
InL :: In u ps -> In (u :++: v) ps
InR :: In v ps -> In (u :++: v) ps
(:*:) :: In u ps -> In v ps -> In (u :**: v) ps

-- | Field <tt>f</tt> inhabitation with parameters <tt>ps</tt>
data InField (f :: Field *) (ps :: [*]) :: *
InK :: a -> InField (FK a) ps
InP :: ps :!: n -> InField (FP n) ps
InA :: f :$: ExpandFields as ps -> InField (f :@: as) ps

-- | Representable types with parameters
class MGeneric (a :: *) where type family Rep a :: Un * type family Pars a :: [*]
from :: MGeneric a => a -> In (Rep a) (Pars a)
to :: MGeneric a => In (Rep a) (Pars a) -> a

module Data.MGeneric.TH

-- | <a>deriveMGeneric</a> derives a <a>MGeneric</a> instance for a type,
--   when possible. (for ADT types with parameters of kind *)
deriveMGeneric :: Name -> Q [Dec]

module Data.Unapply
class f ~ (f' :$: as) => Unapply (f :: *) (f' :: k') (as :: [*]) | f' as -> f, f -> f' as
instance Unapply (a -> b) (->) '[a, b]
instance Unapply (Sum a) Sum '[a]
instance Unapply (Product a) Product '[a]
instance Unapply (First a) First '[a]
instance Unapply (Last a) Last '[a]
instance Unapply (a, b, c, d, e, f, g, h, i) (,,,,,,,,) '[a, b, c, d, e, f, g, h, i]
instance Unapply (a, b, c, d, e, f, g, h) (,,,,,,,) '[a, b, c, d, e, f, g, h]
instance Unapply (a, b, c, d, e, f, g) (,,,,,,) '[a, b, c, d, e, f, g]
instance Unapply (a, b, c, d, e, f) (,,,,,) '[a, b, c, d, e, f]
instance Unapply (a, b, c, d, e) (,,,,) '[a, b, c, d, e]
instance Unapply (a, b, c, d) (,,,) '[a, b, c, d]
instance Unapply (a, b, c) (,,) '[a, b, c]
instance Unapply (a, b) (,) '[a, b]
instance Unapply () () '[]
instance Unapply Ordering Ordering '[]
instance Unapply Bool Bool '[]
instance Unapply (Either a b) Either '[a, b]
instance Unapply (Maybe a) Maybe '[a]
instance Unapply [a] [] '[a]

module Data.MFunctor

-- | <a>Variance</a> kind used in <a>MFunctor</a>
data Variance

-- | <a>Variance</a> for covariant parameters
CoV :: Variance

-- | <a>Variance</a> for contravariant parameters
ContraV :: Variance

-- | <pre>
--   Domain (a -&gt; b) CoV ~ a
--   Domain (a -&gt; b) ContraV ~ b
--   Domains fs vs ~ Map (Uncurry Domain) (Zip fs vs)
--   </pre>

-- | <pre>
--   Codomain (a -&gt; b) CoV ~ b
--   Codomain (a -&gt; b) ContraV ~ a
--   Codomains fs vs ~ Map (Uncurry Codomain) (Zip fs vs)
--   </pre>

-- | <a>MFunctor</a> type class, generalisation of <a>Functor</a>,
--   <a>Bifunctor</a>, <a>Contravariant</a>, <a>Profunctor</a>, etc.
--   
--   If <tt>f</tt> has a <a>MGeneric</a> instance, and types that appear in
--   <tt>f</tt> have a <a>MFunctor</a> instance, it is possible to derive a
--   <a>MFunctor</a> instance for f.
--   
--   <pre>
--   &gt;&gt;&gt; instance MFunctor [] '[a -&gt; a'] '[CoV]
--   
--   &gt;&gt;&gt; instance MFunctor (-&gt;) '[a' -&gt; a, b -&gt; b'] '[ContraV, CoV]
--   </pre>
class MFunctor (f :: k) (fs :: [*]) (vs :: [Variance]) | f -> vs, fs -> k, vs -> k where mmapP _ pv fs = to . mmapG pv fs . from
mmapP :: MFunctor f fs vs => Proxy f -> Proxy vs -> HList fs -> f :$: Domains fs vs -> f :$: Codomains fs vs

-- | Proxy-less <a>mmapP</a>, generalisation of <a>fmap</a>, <a>bimap</a>,
--   <a>contramap</a>, <a>dimap</a>, etc.
--   
--   If f is covariant in all its parameters (its variances are '[CoV, CoV,
--   ..., CoV]) :
--   
--   <pre>
--   mmap :: HList '[a1 -&gt; b1, ..., an -&gt; bn] -&gt; f a1 ... an -&gt; f b1 ... bn
--   </pre>
--   
--   e.g. when f is contravariant in some parameters (variances of (-&gt;)
--   are '[ContraV, CoV])
--   
--   <pre>
--   mmap :: HList '[b1 -&gt; a1, a2 -&gt; b2] -&gt; (a1 -&gt; a2) -&gt; (b1 -&gt; b2)
--   </pre>
mmap :: (Unapply a f (Domains fs vs), Unapply b f (Codomains fs vs), MFunctor f fs vs) => HList fs -> a -> b
instance (MFunctor f (ExpandFieldFunction as vs' ps vs) vs', ExpandFields as (Codomains ps vs) ~ Codomains (ExpandFieldFunction as vs' ps vs) vs', ExpandFields as (Domains ps vs) ~ Domains (ExpandFieldFunction as vs' ps vs) vs', AdaptFieldFunction as vs' ps vs) => GFMFunctor (f ':@: as) ps vs
instance (MFunctor f (ExpandFieldFunction bs (FlipVariance vs') ps vs) vs', ExpandFields bs (Domains ps vs) ~ Codomains (ExpandFieldFunction bs (FlipVariance vs') ps vs) vs', ExpandFields bs (Codomains ps vs) ~ Domains (ExpandFieldFunction bs (FlipVariance vs') ps vs) vs', AdaptFieldFunction bs (FlipVariance vs') ps vs, AdaptFieldFunction as vfs ps vs) => AdaptFieldFunction ((f ':@: bs) : as) ('ContraV : vfs) ps vs
instance (MFunctor f (ExpandFieldFunction bs vs' ps vs) vs', ExpandFields bs (Codomains ps vs) ~ Codomains (ExpandFieldFunction bs vs' ps vs) vs', ExpandFields bs (Domains ps vs) ~ Domains (ExpandFieldFunction bs vs' ps vs) vs', AdaptFieldFunction bs vs' ps vs, AdaptFieldFunction as vfs ps vs) => AdaptFieldFunction ((f ':@: bs) : as) ('CoV : vfs) ps vs
instance (GFPMFunctor n ps vs, AdaptFieldFunction as vfs ps vs, Flip (ps :!: n) ~ ((Domains ps vs :!: n) -> Codomains ps vs :!: n)) => AdaptFieldFunction ('FP n : as) ('ContraV : vfs) ps vs
instance (GFPMFunctor n ps vs, AdaptFieldFunction as vfs ps vs, (ps :!: n) ~ ((Domains ps vs :!: n) -> Codomains ps vs :!: n)) => AdaptFieldFunction ('FP n : as) ('CoV : vfs) ps vs
instance AdaptFieldFunction as vfs ps vs => AdaptFieldFunction ('FK a : as) (v : vfs) ps vs
instance AdaptFieldFunction '[] '[] ps vs
instance GFPMFunctor n as vs => GFPMFunctor ('NS n) ((a -> b) : as) ('ContraV : vs)
instance GFPMFunctor n as vs => GFPMFunctor ('NS n) ((a -> b) : as) ('CoV : vs)
instance GFPMFunctor 'NZ ((a -> b) : as) (v : vs)
instance (GFPMFunctor n fs vs, (fs :!: n) ~ ((Domains fs vs :!: n) -> Codomains fs vs :!: n)) => GFMFunctor ('FP n) fs vs
instance GFMFunctor ('FK a) fs vs
instance GFMFunctor f fs vs => GMFunctor ('UF f) fs vs
instance (GMFunctor u fs vs, GMFunctor v fs vs) => GMFunctor (u ':**: v) fs vs
instance (GMFunctor u fs vs, GMFunctor v fs vs) => GMFunctor (u ':++: v) fs vs
instance GMFunctor 'UT fs vs
instance GMFunctor 'UV fs vs

module Data.MFoldable

-- | <pre>
--   MonoidMap as m ~ Map (\a -&gt; (a -&gt; m)) as
--   </pre>

-- | <a>MFoldable</a> type class, generalisation of <a>Foldable</a>,
--   <a>Bifoldable</a>, etc.
--   
--   <pre>
--   &gt;&gt;&gt; instance MFoldable (,,) '[a, b, c]
--   
--   &gt;&gt;&gt; mfoldMap (Sum `HCons` (Sum . length) `HCons` const mempty `HCons` HNil) (1, "foobar", 5) = 7
--   </pre>
class MFoldable (f :: k) (as :: [*]) | as -> k where mfoldMapP _ _ fs = mfoldMapG fs . from
mfoldMapP :: (MFoldable f as, Monoid m) => Proxy f -> Proxy as -> HList (MonoidMap as m) -> f :$: as -> m

-- | Map elements of each parameter type of a structure to a monoid, and
--   combine the results.
--   
--   Proxy-less version of <a>mfoldMapP</a>
--   
--   <pre>
--   mfoldMap :: HList '[a1 -&gt; m, ..., an -&gt; m] -&gt; f :$: '[a1, ..., an] -&gt; m
--   </pre>
mfoldMap :: (Monoid m, Unapply a f as, MFoldable f as) => HList (MonoidMap as m) -> a -> m

-- | Combine the elements of a structure when all its parameters are the
--   same monoid.
mfold :: (Monoid m, Repeat m as, MFoldable f as, Unapply a f as) => a -> m
instance (MFoldable f (ExpandFields as bs), AdaptFieldMonoid as bs) => GFMFoldable (f ':@: as) bs
instance (MFoldable f (ExpandFields bs fs), AdaptFieldMonoid bs fs, AdaptFieldMonoid as fs) => AdaptFieldMonoid ((f ':@: bs) : as) fs
instance (GFPMFoldable n fs, AdaptFieldMonoid as fs) => AdaptFieldMonoid ('FP n : as) fs
instance AdaptFieldMonoid as fs => AdaptFieldMonoid ('FK a : as) fs
instance AdaptFieldMonoid '[] fs
instance GFPMFoldable n as => GFPMFoldable ('NS n) (a : as)
instance GFPMFoldable 'NZ (a : as)
instance GFPMFoldable n as => GFMFoldable ('FP n) as
instance GFMFoldable ('FK a) as
instance GFMFoldable f as => GMFoldable ('UF f) as
instance (GMFoldable u as, GMFoldable v as) => GMFoldable (u ':**: v) as
instance (GMFoldable u as, GMFoldable v as) => GMFoldable (u ':++: v) as
instance GMFoldable 'UT fs
instance GMFoldable 'UV fs
instance Repeat m as => Repeat m (m : as)
instance Repeat m '[]

module Data.MTraversable

-- | <pre>
--   AppMap ((a1 -&gt; b1) : ...) t ~ (a1 -&gt; t b1) : ...
--   </pre>

-- | <pre>
--   Domain (a -&gt; b) ~ a
--   Domains fs ~ Map Domain fs
--   </pre>

-- | <pre>
--   Codomain (a -&gt; b) ~ b
--   Codomains fs ~ Map Codomain fs 
--   </pre>

-- | <tt>Traversable</tt> type class, generalisation of <a>Traversable</a>,
--   <a>Bitraversable</a>, etc.
class MTraversable (f :: k) (fs :: [*]) t | fs -> k where mtraverseP _ pf _ fs = fmap to . mtraverseG pf fs . from
mtraverseP :: (MTraversable f fs t, Applicative t) => Proxy f -> Proxy fs -> Proxy t -> HList (AppMap fs t) -> f :$: Domains fs -> t (f :$: Codomains fs)

-- | Map elements of all type parameters of a structure to an action,
--   evaluate these actions from left to right, and collect the results.
--   
--   Proxy-less version of <a>mtraverseP</a>
--   
--   Generalisation of <a>traverse</a>, <a>bitraverse</a>, etc.
--   
--   <pre>
--   mtraverse :: HList '[a1 -&gt; f b1, ..., an -&gt; f bn] -&gt; f a1 ... an -&gt; t (f b1 ... bn)
--   </pre>
mtraverse :: (Applicative t, Unapply a f (Domains fs), Unapply b f (Codomains fs), UnAppMap fs t fs', MTraversable f fs t) => HList fs' -> a -> t b

-- | <pre>
--   msequence :: f (t a1) ... (t an) -&gt; t (f a1 ... an)
--   </pre>
msequence :: (Applicative t, Unapply a f (Map t as), Unapply b f as, Map t as ~ Domains (SequenceMap as t), as ~ Codomains (SequenceMap as t), MTraversable f (SequenceMap as t) t, SequenceMapId as t) => a -> t b
instance (MTraversable f (ExpandFieldFunction as fs) t, (f :$: ExpandFields as (Codomains fs)) ~ (f :$: Codomains (ExpandFieldFunction as fs)), (f :$: ExpandFields as (Domains fs)) ~ (f :$: Domains (ExpandFieldFunction as fs)), AdaptFieldFunction as fs t) => GFMTraversable (f ':@: as) fs t
instance (MTraversable f (ExpandFieldFunction bs fs) t, (f :$: ExpandFields bs (Codomains fs)) ~ (f :$: Codomains (ExpandFieldFunction bs fs)), (f :$: ExpandFields bs (Domains fs)) ~ (f :$: Domains (ExpandFieldFunction bs fs)), AdaptFieldFunction bs fs t, AdaptFieldFunction as fs t) => AdaptFieldFunction ((f ':@: bs) : as) fs t
instance (GFPMTraversable n fs t, AdaptFieldFunction as fs t, AppMap ((fs :!: n) : ExpandFieldFunction as fs) t ~ (((Domains fs :!: n) -> t (Codomains fs :!: n)) : AppMap (ExpandFieldFunction as fs) t)) => AdaptFieldFunction ('FP n : as) fs t
instance AdaptFieldFunction as fs t => AdaptFieldFunction ('FK a : as) fs t
instance AdaptFieldFunction '[] fs t
instance GFPMTraversable n as t => GFPMTraversable ('NS n) ((a -> b) : as) t
instance GFPMTraversable 'NZ ((a -> b) : as) t
instance GFPMTraversable n fs t => GFMTraversable ('FP n) fs t
instance GFMTraversable ('FK a) fs t
instance GFMTraversable f fs t => GMTraversable ('UF f) fs t
instance (GMTraversable u fs t, GMTraversable v fs t) => GMTraversable (u ':**: v) fs t
instance (GMTraversable u fs t, GMTraversable v fs t) => GMTraversable (u ':++: v) fs t
instance GMTraversable 'UT fs t
instance GMTraversable 'UV fs t
instance SequenceMapId as t => SequenceMapId (a : as) t
instance SequenceMapId '[] t
instance UnAppMap fs t fs' => UnAppMap ((a -> b) : fs) t ((a -> t b) : fs')
instance UnAppMap '[] t '[]

module Data.MZip

-- | <a>mzipWith</a> zips n structures together if they have the same
--   shape, or fails (with <a>Nothing</a>) if the shapes do not match.
--   
--   <pre>
--   mzipWith :: HList '[a11 -&gt; ... -&gt; an1 -&gt; b1, ...] -&gt; f a11 ... a1m -&gt; f an1 ... anm -&gt; f b1 ... bm
--   </pre>
mzipWith :: (MZipWith n f fs, MakeZipInputs n fs, ZipWithTypeC n f fs b, ZipInputsC n fs (ZipInputs n fs)) => HList fs -> b
instance (GFAMZipWith n f as fs, MZipWith n f (ExpandFieldFunction n as fs), AdaptFieldFunction n as fs) => GFMZipWith n (f ':@: as) fs
instance (ExpandFieldFunction n as (Codoms fs) ~ Codoms (ExpandFieldFunction ('NS n) as fs), Doms (ExpandFieldFunction ('NS n) as fs) ~ ExpandFields as (Doms fs), GFAMZipWith n f as (Codoms fs)) => GFAMZipWith ('NS n) f as fs
instance ExpandFields as fs ~ ExpandFieldFunction 'NZ as fs => GFAMZipWith 'NZ f as fs
instance (MZipWith n f (ExpandFieldFunction n bs ps), ZipInput n (ZipWithType' n f (ExpandFieldFunction n bs ps)) ~ ZipWithType n f (ExpandFieldFunction n bs ps), AdaptFieldFunction n bs ps, AdaptFieldFunction n as ps) => AdaptFieldFunction n ((f ':@: bs) : as) ps
instance (HLookup m (ZipInputs n ps), ZipInput n (ps :!: m) ~ (ZipInputs n ps :!: m), AdaptFieldFunction n as ps) => AdaptFieldFunction n ('FP m : as) ps
instance AdaptFieldFunction n '[] ps
instance (GFPMZipWith n m fs, HLookup m (ZipInputs n fs)) => GFMZipWith n ('FP m) fs
instance ((ZipInputs ('NS n) fs :!: m) ~ ((Doms fs :!: m) -> ZipInputs n (Codoms fs) :!: m), GFPMZipWith n m (Codoms fs)) => GFPMZipWith ('NS n) m fs
instance Maybe (fs :!: m) ~ (ZipInputs 'NZ fs :!: m) => GFPMZipWith 'NZ m fs
instance (GFMZipWith n f fs, GMZipWithF n f fs) => GMZipWith n ('UF f) fs
instance GMZipWithF n f (Codoms fs) => GMZipWithF ('NS n) f fs
instance GMZipWithF 'NZ f fs
instance (GMZipWith n u fs, GMZipWith n v fs, GPiMZipWith n u v fs) => GMZipWith n (u ':**: v) fs
instance GPiMZipWith n u v (Codoms fs) => GPiMZipWith ('NS n) u v fs
instance GPiMZipWith 'NZ u v fs
instance (GMZipWith ('NS n) u fs, GMZipWith ('NS n) v fs, GMLZipWith n u v (Codoms fs), GMRZipWith n u v (Codoms fs)) => GMZipWith ('NS n) (u ':++: v) fs
instance (GMRZipWith n u v (Codoms fs), GMZipWithFail n (u ':++: v) (Codoms fs)) => GMRZipWith ('NS n) u v fs
instance GMRZipWith 'NZ u v fs
instance (GMLZipWith n u v (Codoms fs), GMZipWithFail n (u ':++: v) (Codoms fs)) => GMLZipWith ('NS n) u v fs
instance GMLZipWith 'NZ u v fs
instance GMZipWithFail 'NZ u fs
instance GMTZipWith n fs => GMZipWith n 'UT fs
instance GMTZipWith n (Codoms fs) => GMTZipWith ('NS n) fs
instance GMTZipWith 'NZ fs
instance GMZipWith n 'UV fs
instance (MakeZipInput n f, MakeZipInputs n fs, ZipInputsC n fs (ZipInputs n fs)) => MakeZipInputs n (f : fs)
instance MakeZipInputs n '[]
instance MakeZipInput n b => MakeZipInput ('NS n) (a -> b)
instance MakeZipInput 'NZ a
instance (Unapply a f (Doms fs), ZipWithTypeC n f (Codoms fs) b) => ZipWithTypeC ('NS n) f fs (a -> b)
instance Unapply a f fs => ZipWithTypeC 'NZ f fs (Maybe a)
instance (ZipInputC n f c, ZipInputsC n fs b) => ZipInputsC n (f : fs) (c : b)
instance ZipInputsC n '[] '[]
instance ZipInputC n b c => ZipInputC ('NS n) (a -> b) (a -> c)
instance ZipInputC 'NZ a (Maybe a)
instance (MZipWithG n f rf (Codoms fs), rf ~ Rep (f :$: Doms fs), Doms fs ~ Pars (f :$: Doms fs), MGeneric (f :$: Doms fs)) => MZipWithG ('NS n) f rf fs
instance (fs ~ Pars (f :$: fs), rf ~ Rep (f :$: fs), MGeneric (f :$: fs)) => MZipWithG 'NZ f rf fs

module Data.MGeneric.Instances
instance (MZipWithG n First (Rep (First :$: LCodoms n '[f])) '[f], GMZipWith n (Rep (First :$: LCodoms n '[f])) '[f]) => MZipWith n First '[f]
instance (MZipWithG n Last (Rep (Last :$: LCodoms n '[f])) '[f], GMZipWith n (Rep (Last :$: LCodoms n '[f])) '[f]) => MZipWith n Last '[f]
instance (MZipWithG n Sum (Rep (Sum :$: LCodoms n '[f])) '[f], GMZipWith n (Rep (Sum :$: LCodoms n '[f])) '[f]) => MZipWith n Sum '[f]
instance (MZipWithG n Product (Rep (Product :$: LCodoms n '[f])) '[f], GMZipWith n (Rep (Product :$: LCodoms n '[f])) '[f]) => MZipWith n Product '[f]
instance (MZipWithG n (,,,,,,,,) (Rep ((,,,,,,,,) :$: LCodoms n '[f, g, h, i, j, k, l, m, o])) '[f, g, h, i, j, k, l, m, o], GMZipWith n (Rep ((,,,,,,,,) :$: LCodoms n '[f, g, h, i, j, k, l, m, o])) '[f, g, h, i, j, k, l, m, o]) => MZipWith n (,,,,,,,,) '[f, g, h, i, j, k, l, m, o]
instance (MZipWithG n (,,,,,,,) (Rep ((,,,,,,,) :$: LCodoms n '[f, g, h, i, j, k, l, m])) '[f, g, h, i, j, k, l, m], GMZipWith n (Rep ((,,,,,,,) :$: LCodoms n '[f, g, h, i, j, k, l, m])) '[f, g, h, i, j, k, l, m]) => MZipWith n (,,,,,,,) '[f, g, h, i, j, k, l, m]
instance (MZipWithG n (,,,,,,) (Rep ((,,,,,,) :$: LCodoms n '[f, g, h, i, j, k, l])) '[f, g, h, i, j, k, l], GMZipWith n (Rep ((,,,,,,) :$: LCodoms n '[f, g, h, i, j, k, l])) '[f, g, h, i, j, k, l]) => MZipWith n (,,,,,,) '[f, g, h, i, j, k, l]
instance (MZipWithG n (,,,,,) (Rep ((,,,,,) :$: LCodoms n '[f, g, h, i, j, k])) '[f, g, h, i, j, k], GMZipWith n (Rep ((,,,,,) :$: LCodoms n '[f, g, h, i, j, k])) '[f, g, h, i, j, k]) => MZipWith n (,,,,,) '[f, g, h, i, j, k]
instance (MZipWithG n (,,,,) (Rep ((,,,,) :$: LCodoms n '[f, g, h, i, j])) '[f, g, h, i, j], GMZipWith n (Rep ((,,,,) :$: LCodoms n '[f, g, h, i, j])) '[f, g, h, i, j]) => MZipWith n (,,,,) '[f, g, h, i, j]
instance (MZipWithG n (,,,) (Rep ((,,,) :$: LCodoms n '[f, g, h, i])) '[f, g, h, i], GMZipWith n (Rep ((,,,) :$: LCodoms n '[f, g, h, i])) '[f, g, h, i]) => MZipWith n (,,,) '[f, g, h, i]
instance (MZipWithG n (,,) (Rep ((,,) :$: LCodoms n '[f, g, h])) '[f, g, h], GMZipWith n (Rep ((,,) :$: LCodoms n '[f, g, h])) '[f, g, h]) => MZipWith n (,,) '[f, g, h]
instance (MZipWithG n (,) (Rep ((,) :$: LCodoms n '[f, g])) '[f, g], GMZipWith n (Rep ((,) :$: LCodoms n '[f, g])) '[f, g]) => MZipWith n (,) '[f, g]
instance (MZipWithG n () (Rep (() :$: LCodoms n '[])) '[], GMZipWith n (Rep (() :$: LCodoms n '[])) '[]) => MZipWith n () '[]
instance (MZipWithG n Ordering (Rep (Ordering :$: LCodoms n '[])) '[], GMZipWith n (Rep (Ordering :$: LCodoms n '[])) '[]) => MZipWith n Ordering '[]
instance (MZipWithG n Bool (Rep (Bool :$: LCodoms n '[])) '[], GMZipWith n (Rep (Bool :$: LCodoms n '[])) '[]) => MZipWith n Bool '[]
instance (MZipWithG n Either (Rep (Either :$: LCodoms n '[f, g])) '[f, g], GMZipWith n (Rep (Either :$: LCodoms n '[f, g])) '[f, g]) => MZipWith n Either '[f, g]
instance (MZipWithG n Maybe (Rep (Maybe :$: LCodoms n '[f])) '[f], GMZipWith n (Rep (Maybe :$: LCodoms n '[f])) '[f]) => MZipWith n Maybe '[f]
instance (MZipWithG n [] (Rep ([] :$: LCodoms n '[f])) '[f], GMZipWith n (Rep ([] :$: LCodoms n '[f])) '[f]) => MZipWith n [] '[f]
instance MTraversable Sum '[a -> b] t
instance MTraversable Product '[a -> b] t
instance MTraversable First '[a -> b] t
instance MTraversable Last '[a -> b] t
instance MTraversable (,,,,,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e', f -> f', g -> g', h -> h', i -> i'] t
instance MTraversable (,,,,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e', f -> f', g -> g', h -> h'] t
instance MTraversable (,,,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e', f -> f', g -> g'] t
instance MTraversable (,,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e', f -> f'] t
instance MTraversable (,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e'] t
instance MTraversable (,,,) '[a -> a', b -> b', c -> c', d -> d'] t
instance MTraversable (,,) '[a -> a', b -> b', c -> c'] t
instance MTraversable (,) '[a -> a', b -> b'] t
instance MTraversable () '[] t
instance MTraversable Ordering '[] t
instance MTraversable Bool '[] t
instance MTraversable Either '[a -> a', b -> b'] t
instance MTraversable Maybe '[a -> a'] t
instance MTraversable [] '[a -> a'] t
instance MFoldable Identity '[a]
instance MFoldable Sum '[a]
instance MFoldable Product '[a]
instance MFoldable First '[a]
instance MFoldable Last '[a]
instance MFoldable (,,,,,,,,) '[a, b, c, d, e, f, g, h, i]
instance MFoldable (,,,,,,,) '[a, b, c, d, e, f, g, h]
instance MFoldable (,,,,,,) '[a, b, c, d, e, f, g]
instance MFoldable (,,,,,) '[a, b, c, d, e, f]
instance MFoldable (,,,,) '[a, b, c, d, e]
instance MFoldable (,,,) '[a, b, c, d]
instance MFoldable (,,) '[a, b, c]
instance MFoldable (,) '[a, b]
instance MFoldable () '[]
instance MFoldable Ordering '[]
instance MFoldable Bool '[]
instance MFoldable Either '[a, b]
instance MFoldable Maybe '[a]
instance MFoldable [] '[a]
instance MFunctor (->) '[a' -> a, b -> b'] '['ContraV, 'CoV]
instance MFunctor Sum '[a -> b] '['CoV]
instance MFunctor Product '[a -> b] '['CoV]
instance MFunctor First '[a -> b] '['CoV]
instance MFunctor Last '[a -> b] '['CoV]
instance MFunctor (,,,,,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e', f -> f', g -> g', h -> h', i -> i'] '['CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV]
instance MFunctor (,,,,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e', f -> f', g -> g', h -> h'] '['CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV]
instance MFunctor (,,,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e', f -> f', g -> g'] '['CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV]
instance MFunctor (,,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e', f -> f'] '['CoV, 'CoV, 'CoV, 'CoV, 'CoV, 'CoV]
instance MFunctor (,,,,) '[a -> a', b -> b', c -> c', d -> d', e -> e'] '['CoV, 'CoV, 'CoV, 'CoV, 'CoV]
instance MFunctor (,,,) '[a -> a', b -> b', c -> c', d -> d'] '['CoV, 'CoV, 'CoV, 'CoV]
instance MFunctor (,,) '[a -> a', b -> b', c -> c'] '['CoV, 'CoV, 'CoV]
instance MFunctor (,) '[a -> a', b -> b'] '['CoV, 'CoV]
instance MFunctor () '[] '[]
instance MFunctor Ordering '[] '[]
instance MFunctor Bool '[] '[]
instance MFunctor Either '[a -> a', b -> b'] '['CoV, 'CoV]
instance MFunctor Maybe '[a -> a'] '['CoV]
instance MFunctor [] '[a -> a'] '['CoV]
instance MGeneric (Identity a0)
instance MGeneric (Const a0 b0)
instance MGeneric (Endo a0)
instance MGeneric (Sum a0)
instance MGeneric (Product a0)
instance MGeneric (First a0)
instance MGeneric (Last a0)
instance MGeneric (a0, b0, c0, d0, e0, f0, g0, h0, i0)
instance MGeneric (a0, b0, c0, d0, e0, f0, g0, h0)
instance MGeneric (a0, b0, c0, d0, e0, f0, g0)
instance MGeneric (a0, b0, c0, d0, e0, f0)
instance MGeneric (a0, b0, c0, d0, e0)
instance MGeneric (a0, b0, c0, d0)
instance MGeneric (a0, b0, c0)
instance MGeneric (a0, b0)
instance MGeneric ()
instance MGeneric Ordering
instance MGeneric Bool
instance MGeneric (Either a0 b0)
instance MGeneric (Maybe a0)
instance MGeneric [a0]
