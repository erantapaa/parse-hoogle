-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | R5RS Scheme interpreter, compiler, and library.
--   
@package husk-scheme
@version 3.19


-- | This module contains general-purpose utility functions
module Language.Scheme.Util

-- | Count occurences of a letter in a list of strings
countAllLetters :: Char -> [String] -> Int

-- | Count occurences of a letter in a string
countLetters :: Char -> String -> Int

-- | A utility function to escape backslashes in the given string
escapeBackslashes :: String -> String

-- | Take last n elements of a list, from:
--   <a>http://stackoverflow.com/q/17252851/101258</a>
lastN' :: Int -> [a] -> [a]

-- | Remove leading/trailing white space from a string; based on
--   corresponding Python function. Code taken from:
--   
--   
--   <a>http://gimbo.org.uk/blog/2007/04/20/splitting-a-string-in-haskell/</a>
strip :: String -> String


-- | This module contains top-level data type definitions, environments,
--   error types, and associated functions.
module Language.Scheme.Types

-- | A Scheme environment containing variable bindings of form
--   <tt>(namespaceName, variableName), variableValue</tt>
data Env
Environment :: (Maybe Env) -> (IORef (Map String (IORef LispVal))) -> (IORef (Map String (IORef [LispVal]))) -> Env
parentEnv :: Env -> (Maybe Env)
bindings :: Env -> (IORef (Map String (IORef LispVal)))
pointers :: Env -> (IORef (Map String (IORef [LispVal])))

-- | An empty environment
nullEnv :: IO Env

-- | Types of errors that may occur when evaluating Scheme code
data LispError

-- | Invalid number of function arguments
NumArgs :: (Maybe Integer) -> [LispVal] -> LispError

-- | Type error
TypeMismatch :: String -> LispVal -> LispError

-- | Parsing error
Parser :: ParseError -> LispError

-- | Invalid special (built-in) form
BadSpecialForm :: String -> LispVal -> LispError

-- | A referenced variable has not been declared
UnboundVar :: String -> String -> LispError

-- | Divide by Zero error
DivideByZero :: LispError

-- | Feature is not implemented
NotImplemented :: String -> LispError

-- | An internal error within husk; in theory user (Scheme) code should
--   never allow one of these errors to be triggered.
InternalError :: String -> LispError

-- | Default error
Default :: String -> LispError
ErrorWithCallHist :: LispError -> [LispVal] -> LispError

-- | Container used by operations that could throw an error
type ThrowsError = Either LispError

-- | Container used to provide error handling in the IO monad
type IOThrowsError = ErrorT LispError IO

-- | Lift a ThrowsError into the IO monad
liftThrows :: ThrowsError a -> IOThrowsError a

-- | Display call history for an error
showCallHistory :: String -> [LispVal] -> String

-- | Scheme data types
data LispVal

-- | Symbol
Atom :: String -> LispVal

-- | List
List :: [LispVal] -> LispVal

-- | Pair
DottedList :: [LispVal] -> LispVal -> LispVal

-- | Vector
Vector :: (Array Int LispVal) -> LispVal

-- | ByteVector from R7RS
ByteVector :: ByteString -> LispVal

-- | Hash table. Technically this could be a derived data type instead of
--   being built-in to the interpreter. And perhaps in the future it will
--   be. But for now, a hash table is too important of a data type to not
--   be included.
HashTable :: (Map LispVal LispVal) -> LispVal

-- | Integer number
Number :: Integer -> LispVal

-- | Double-precision floating point number
Float :: Double -> LispVal

-- | Complex number
Complex :: (Complex Double) -> LispVal

-- | Rational number
Rational :: Rational -> LispVal

-- | String
String :: String -> LispVal

-- | Character
Char :: Char -> LispVal

-- | Boolean
Bool :: Bool -> LispVal

-- | Primitive function
PrimitiveFunc :: ([LispVal] -> ThrowsError LispVal) -> LispVal

-- | Function written in Scheme
Func :: [String] -> (Maybe String) -> [LispVal] -> Env -> LispVal
params :: LispVal -> [String]
vararg :: LispVal -> (Maybe String)
body :: LispVal -> [LispVal]
closure :: LispVal -> Env

-- | Function formed from a Haskell function
HFunc :: [String] -> (Maybe String) -> (Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal) -> Env -> LispVal
hparams :: LispVal -> [String]
hvararg :: LispVal -> (Maybe String)
hbody :: LispVal -> (Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal)
hclosure :: LispVal -> Env

-- | Primitive function within the IO monad
IOFunc :: ([LispVal] -> IOThrowsError LispVal) -> LispVal

-- | Function within the IO monad with access to the current environment
--   and continuation.
EvalFunc :: ([LispVal] -> IOThrowsError LispVal) -> LispVal

-- | A custom function written by code outside of husk. Any code that uses
--   the Haskell API should define custom functions using this data type.
CustFunc :: ([LispVal] -> IOThrowsError LispVal) -> LispVal

-- | Pointer to an environment variable.
Pointer :: String -> Env -> LispVal
pointerVar :: LispVal -> String
pointerEnv :: LispVal -> Env

-- | Opaque Haskell value.
Opaque :: Dynamic -> LispVal

-- | I/O port
Port :: Handle -> (Maybe Knob) -> LispVal

-- | Continuation
Continuation :: Env -> (Maybe DeferredCode) -> (Maybe LispVal) -> (Maybe [DynamicWinders]) -> [LispVal] -> LispVal
contClosure :: LispVal -> Env
currentCont :: LispVal -> (Maybe DeferredCode)
nextCont :: LispVal -> (Maybe LispVal)
dynamicWind :: LispVal -> (Maybe [DynamicWinders])
contCallHist :: LispVal -> [LispVal]

-- | Type to hold a syntax object that is created by a macro definition.
--   Syntax objects are not used like regular types in that they are not
--   passed around within variables. In other words, you cannot use set! to
--   assign a variable to a syntax object. But they are used during
--   function application. In any case, it is convenient to define the type
--   here because syntax objects are stored in the same environments and
--   manipulated by the same functions as regular variables.
Syntax :: Maybe Env -> Maybe Env -> Bool -> String -> [LispVal] -> [LispVal] -> LispVal

-- | Code env in effect at definition time, if applicable
synClosure :: LispVal -> Maybe Env

-- | Renames (from macro hygiene) in effect at def time; only applicable if
--   this macro defined inside another macro.
synRenameClosure :: LispVal -> Maybe Env

-- | Set if macro is defined within another macro
synDefinedInMacro :: LispVal -> Bool

-- | String to use as the ellipsis identifier
synEllipsis :: LispVal -> String

-- | Literal identifiers from syntax-rules
synIdentifiers :: LispVal -> [LispVal]

-- | Rules from syntax-rules
synRules :: LispVal -> [LispVal]

-- | Syntax for an explicit-renaming macro
SyntaxExplicitRenaming :: LispVal -> LispVal

-- | Wrapper for a scheme environment
LispEnv :: Env -> LispVal

-- | End of file indicator
EOF :: LispVal

-- | Internal use only; do not use this type directly.
Nil :: String -> LispVal

-- | Scheme <i>null</i> value
nullLisp :: LispVal

-- | Convert a Haskell value to an opaque Lisp value.
toOpaque :: Typeable a => a -> LispVal

-- | Convert an opaque Lisp value back into a Haskell value of the
--   appropriate type, or produce a TypeMismatch error.
fromOpaque :: Typeable a => LispVal -> ThrowsError a

-- | Container to hold code that is passed to a continuation for deferred
--   execution
data DeferredCode

-- | A block of Scheme code
SchemeBody :: [LispVal] -> DeferredCode

-- | A Haskell function
HaskellBody :: (Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal) -> (Maybe [LispVal]) -> DeferredCode
contFunction :: DeferredCode -> (Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal)
contFunctionArgs :: DeferredCode -> (Maybe [LispVal])

-- | Container to store information from a dynamic-wind
data DynamicWinders
DynamicWinders :: LispVal -> LispVal -> DynamicWinders

-- | Function to execute when resuming continuation within extent of
--   dynamic-wind
before :: DynamicWinders -> LispVal

-- | Function to execute when leaving extent of dynamic-wind
after :: DynamicWinders -> LispVal

-- | Make an <i>empty</i> continuation that does not contain any code
makeNullContinuation :: Env -> LispVal

-- | Make a continuation that takes a higher-order function (written in
--   Haskell)
makeCPS :: Env -> LispVal -> (Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal) -> LispVal

-- | Make a continuation that stores a higher-order function and arguments
--   to that function
makeCPSWArgs :: Env -> LispVal -> (Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal) -> [LispVal] -> LispVal

-- | Compare two <a>LispVal</a> instances
eqv :: [LispVal] -> ThrowsError LispVal

-- | Compare two lists of haskell values, using the given comparison
--   function
eqvList :: ([LispVal] -> ThrowsError LispVal) -> [LispVal] -> ThrowsError LispVal

-- | A more convenient way to call <i>eqv</i>
eqVal :: LispVal -> LispVal -> Bool

-- | A helper function to make pointer deref code more concise
box :: LispVal -> IOThrowsError [LispVal]

-- | Create a scheme function
makeFunc :: Monad m => Maybe String -> Env -> [LispVal] -> [LispVal] -> m LispVal

-- | Create a normal scheme function
makeNormalFunc :: Monad m => Env -> [LispVal] -> [LispVal] -> m LispVal

-- | Create a scheme function that can receive any number of arguments
makeVarargs :: Monad m => LispVal -> Env -> [LispVal] -> [LispVal] -> m LispVal

-- | Create a haskell function
makeHFunc :: Monad m => Maybe String -> Env -> [String] -> (Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal) -> m LispVal

-- | Create a normal haskell function
makeNormalHFunc :: Monad m => Env -> [String] -> (Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal) -> m LispVal

-- | Create a haskell function that can receive any number of arguments
makeHVarargs :: Monad m => LispVal -> Env -> [String] -> (Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal) -> m LispVal

-- | Validate formal function parameters.
validateFuncParams :: [LispVal] -> Maybe Integer -> IOThrowsError Bool
instance Show LispVal
instance Eq LispVal
instance Ord LispVal
instance Show DynamicWinders
instance Error LispError
instance Show LispError
instance Eq Env


-- | This module contains code for working with Scheme variables, and the
--   environments that contain them.
module Language.Scheme.Variables

-- | Show the contents of an environment
printEnv :: Env -> IO String

-- | Recursively print an environment to string
recPrintEnv :: Env -> IO String

-- | Recursively find all exports from the given environment
recExportsFromEnv :: Env -> IO [LispVal]

-- | Return a list of symbols exported from an environment
exportsFromEnv :: Env -> IO [LispVal]

-- | Create a deep copy of an environment
copyEnv :: Env -> IO Env

-- | Extend given environment by binding a series of values to a new
--   environment.
extendEnv :: Env -> [((Char, String), LispVal)] -> IO Env

-- | Perform a deep copy of an environment's contents into another
--   environment.
--   
--   The destination environment is modified!
importEnv :: Env -> Env -> IO Env

-- | Find the top-most environment
topmostEnv :: Env -> IO Env

-- | Create a null environment with the given environment as its parent.
nullEnvWithParent :: Env -> IO Env

-- | Recursively search environments to find one that contains the given
--   variable.
findNamespacedEnv :: Env -> Char -> String -> IO (Maybe Env)

-- | Internal namespace for macros
macroNamespace :: Char

-- | Internal namespace for variables
varNamespace :: Char

-- | Retrieve the value of a variable defined in the default namespace
getVar :: Env -> String -> IOThrowsError LispVal

-- | Retrieve the value of a variable defined in the default namespace, or
--   Nothing if it is not defined
getVar' :: Env -> String -> IOThrowsError (Maybe LispVal)

-- | Retrieve the value of a variable defined in a given namespace
getNamespacedVar :: Env -> Char -> String -> IOThrowsError LispVal

-- | Retrieve the value of a variable defined in a given namespace, or
--   Nothing if it is not defined
getNamespacedVar' :: Env -> Char -> String -> IOThrowsError (Maybe LispVal)

-- | Retrieve an ioRef defined in a given namespace
getNamespacedRef :: Env -> Char -> String -> IOThrowsError (IORef LispVal)

-- | Bind a variable in the default namespace
defineVar :: Env -> String -> LispVal -> IOThrowsError LispVal

-- | Bind a variable in the given namespace
defineNamespacedVar :: Env -> Char -> String -> LispVal -> IOThrowsError LispVal

-- | Set a variable in the default namespace
setVar :: Env -> String -> LispVal -> IOThrowsError LispVal

-- | Set a variable in a given namespace
setNamespacedVar :: Env -> Char -> String -> LispVal -> IOThrowsError LispVal

-- | A wrapper for updateNamespaceObject that uses the variable namespace.
updateObject :: Env -> String -> LispVal -> IOThrowsError LispVal

-- | This function updates the object that the variable refers to. If it is
--   a pointer, that means this function will update that pointer (or the
--   last pointer in the chain) to point to the given <i>value</i> object.
--   If the variable is not a pointer, the result is the same as a setVar
--   (but without updating any pointer references, see below).
--   
--   Note this function only updates the object, it does not update any
--   associated pointers. So it should probably only be used internally by
--   husk, unless you really know what you are doing!
updateNamespacedObject :: Env -> Char -> String -> LispVal -> IOThrowsError LispVal

-- | Determine if a variable is bound in the default namespace
isBound :: Env -> String -> IO Bool

-- | Determine if a variable is bound in the default namespace, in this
--   environment or one of its parents.
isRecBound :: Env -> String -> IO Bool

-- | Determine if a variable is bound in a given namespace or a parent of
--   the given environment.
isNamespacedRecBound :: Env -> Char -> String -> IO Bool

-- | Return a value with a pointer dereferenced, if necessary
derefPtr :: LispVal -> IOThrowsError LispVal

-- | Recursively process the given data structure, dereferencing any
--   pointers found along the way.
--   
--   This could potentially be expensive on large data structures since it
--   must walk the entire object.
recDerefPtrs :: LispVal -> IOThrowsError LispVal

-- | Attempt to dereference pointers safely, without being caught in a
--   cycle
safeRecDerefPtrs :: [LispVal] -> LispVal -> IOThrowsError LispVal

-- | A helper to recursively dereference all pointers and pass results to a
--   function
recDerefToFnc :: ([LispVal] -> ThrowsError LispVal) -> [LispVal] -> IOThrowsError LispVal


-- | This module implements the numerical tower.
module Language.Scheme.Numerical

-- | Subtract the given numbers
numSub :: [LispVal] -> ThrowsError LispVal

-- | Multiply the given numbers
numMul :: [LispVal] -> ThrowsError LispVal

-- | Divide the given numbers
numDiv :: [LispVal] -> ThrowsError LispVal

-- | Add the given numbers
numAdd :: [LispVal] -> ThrowsError LispVal

-- | Take the modulus of the given numbers
numMod :: [LispVal] -> ThrowsError LispVal

-- | Convert the given number to a rational
numRationalize :: [LispVal] -> ThrowsError LispVal

-- | Numeric equals
numBoolBinopEq :: [LispVal] -> ThrowsError LispVal

-- | Numeric greater than
numBoolBinopGt :: [LispVal] -> ThrowsError LispVal

-- | Numeric greater than equal
numBoolBinopGte :: [LispVal] -> ThrowsError LispVal

-- | Numeric less than
numBoolBinopLt :: [LispVal] -> ThrowsError LispVal

-- | Numeric less than equal
numBoolBinopLte :: [LispVal] -> ThrowsError LispVal

-- | Accept two numbers and cast one of them to the appropriate type, if
--   necessary
numCast :: [LispVal] -> ThrowsError LispVal

-- | Take the denominator of the given number
numDenominator :: [LispVal] -> ThrowsError LispVal

-- | Take the numerator of the given number
numNumerator :: [LispVal] -> ThrowsError LispVal

-- | Convert an inexact number to exact
numInexact2Exact :: [LispVal] -> ThrowsError LispVal

-- | Convert an exact number to inexact
numExact2Inexact :: [LispVal] -> ThrowsError LispVal

-- | Convert a number to a string; radix is optional, defaults to base 10
num2String :: [LispVal] -> ThrowsError LispVal

-- | Extract an integer from the given value, throwing a type error if the
--   wrong type is passed.
unpackNum :: LispVal -> ThrowsError Integer

-- | A helper function to perform a numeric operation on two values
numericBinop :: (Integer -> Integer -> Integer) -> [LispVal] -> ThrowsError LispVal

-- | Floor the given number
numFloor :: [LispVal] -> ThrowsError LispVal

-- | Take the ceiling of the given number
numCeiling :: [LispVal] -> ThrowsError LispVal

-- | Truncate the given number
numTruncate :: [LispVal] -> ThrowsError LispVal

-- | Round the given number
numRound :: [LispVal] -> ThrowsError LispVal

-- | Raise the first number to the power of the second
numExpt :: [LispVal] -> ThrowsError LispVal

-- | Take the square root of the given number
numSqrt :: [LispVal] -> ThrowsError LispVal

-- | Take the exponent of the given number
numExp :: [LispVal] -> ThrowsError LispVal

-- | Compute the log of a given number
numLog :: [LispVal] -> ThrowsError LispVal

-- | Sine
numSin :: [LispVal] -> ThrowsError LispVal

-- | Cosine
numCos :: [LispVal] -> ThrowsError LispVal

-- | Tangent
numTan :: [LispVal] -> ThrowsError LispVal

-- | Arcsine
numAsin :: [LispVal] -> ThrowsError LispVal

-- | Arccosine
numAcos :: [LispVal] -> ThrowsError LispVal

-- | Arctangent
numAtan :: [LispVal] -> ThrowsError LispVal

-- | Create a complex number
buildComplex :: LispVal -> LispVal -> ThrowsError LispVal

-- | Create a complex number from its magnitude and phase (angle)
numMakePolar :: [LispVal] -> ThrowsError LispVal

-- | Retrieve real part of a complex number
numRealPart :: [LispVal] -> ThrowsError LispVal

-- | Retrieve imaginary part of a complex number
numImagPart :: [LispVal] -> ThrowsError LispVal

-- | The nonnegative magnitude of a complex number
numMagnitude :: [LispVal] -> ThrowsError LispVal

-- | The phase of a complex number
numAngle :: [LispVal] -> ThrowsError LispVal

-- | Create a complex number given its real and imaginary parts
numMakeRectangular :: [LispVal] -> ThrowsError LispVal

-- | Predicate to determine if given number is complex. Keep in mind this
--   does not just look at the types
isComplex :: [LispVal] -> ThrowsError LispVal

-- | Predicate to determine if given number is a real. Keep in mind this
--   does not just look at the types
isReal :: [LispVal] -> ThrowsError LispVal

-- | Predicate to determine if given number is a rational. Keep in mind
--   this does not just look at the types
isRational :: [LispVal] -> ThrowsError LispVal

-- | Predicate to determine if given number is an integer. Keep in mind
--   this does not just look at the types; a floating point input value can
--   return true, for example.
isInteger :: [LispVal] -> ThrowsError LispVal

-- | Predicate to determine if given value is a number
isNumber :: [LispVal] -> ThrowsError LispVal

-- | A utility function to determine if given value is a floating point
--   number representing an whole number (integer).
isFloatAnInteger :: LispVal -> Bool

-- | Determine if the given value is not a number
isNumNaN :: [LispVal] -> ThrowsError LispVal

-- | Determine if number is infinite
isNumInfinite :: [LispVal] -> ThrowsError LispVal

-- | Determine if number is not infinite
isNumFinite :: [LispVal] -> ThrowsError LispVal

-- | Determine if number is exact
isNumExact :: [LispVal] -> ThrowsError LispVal

-- | Determine if number is inexact
isNumInexact :: [LispVal] -> ThrowsError LispVal


-- | This module wraps System.CPUTime so that it can be used directly by
--   Scheme code.
--   
--   More importantly, it serves as an example of how to wrap existing
--   Haskell code so that it can be loaded and called by husk.
--   
--   See 'examples/ffi/ffi-cputime.scm' in the husk source tree for an
--   example of how to call into this module from Scheme code.
module Language.Scheme.Plugins.CPUTime

-- | Wrapper for CPUTime.getCPUTime
get :: [LispVal] -> IOThrowsError LispVal

-- | Wrapper for CPUTime.cpuTimePrecision
precision :: [LispVal] -> IOThrowsError LispVal


-- | This module contains utility functions used to support macro
--   processing, by storing and/or manipulating data involving 0-or-many
--   matches.
module Language.Scheme.Macro.Matches

-- | Get an element at given location in the nested list
getData :: LispVal -> [Int] -> LispVal

-- | Add an element to the given nested list
setData :: LispVal -> [Int] -> LispVal -> LispVal


-- | This module implements parsing of Scheme code.
module Language.Scheme.Parser

-- | Language definition for Scheme
lispDef :: LanguageDef ()

-- | Initial parser used by the high-level parse functions
mainParser :: Parser LispVal

-- | Use a parser to parse the given text, throwing an error if there is a
--   problem parsing the text.
readOrThrow :: Parser a -> String -> ThrowsError a

-- | Parse an expression from a string of text
readExpr :: String -> ThrowsError LispVal

-- | Parse many expressions from a string of text
readExprList :: String -> ThrowsError [LispVal]

-- | Parse an expression
parseExpr :: Parser LispVal

-- | Parse an atom (scheme symbol)
parseAtom :: Parser LispVal

-- | Parse a boolean
parseBool :: Parser LispVal

-- | Parse a character
parseChar :: Parser LispVal

-- | Parse an integer in octal notation, base 8
parseOctalNumber :: Parser LispVal

-- | Parse an integer in binary notation, base 2
parseBinaryNumber :: Parser LispVal

-- | Parse an integer in hexadecimal notation, base 16
parseHexNumber :: Parser LispVal

-- | Parser for Integer, base 10
parseDecimalNumber :: Parser LispVal

-- | Parse an integer in any base
parseNumber :: Parser LispVal

-- | Parse a floating point number
parseRealNumber :: Parser LispVal

-- | Parse a rational number
parseRationalNumber :: Parser LispVal

-- | Parse a complex number
parseComplexNumber :: Parser LispVal

-- | Parse an escaped character
parseEscapedChar :: GenParser Char st Char

-- | Parse a string
parseString :: Parser LispVal

-- | Parse a vector
parseVector :: Parser LispVal

-- | Parse a bytevector
parseByteVector :: Parser LispVal

-- | Parse a hash table. The table is either empty or is made up of an
--   alist (associative list)
parseHashTable :: Parser LispVal

-- | Parse a list
parseList :: Parser LispVal

-- | Parse a dotted list (scheme pair)
parseDottedList :: Parser LispVal

-- | Parse a quoted expression
parseQuoted :: Parser LispVal

-- | Parse a quasi-quoted expression
parseQuasiQuoted :: Parser LispVal

-- | Parse an unquoted expression (a quasiquotated expression preceded by a
--   comma)
parseUnquoted :: Parser LispVal

-- | Parse an unquote-spliced expression
parseUnquoteSpliced :: Parser LispVal


-- | This module contains primitive functions written in Haskell. Most of
--   these map directly to an equivalent Scheme function.
module Language.Scheme.Primitives

-- | Retrieve the first item from a list
--   
--   Arguments:
--   
--   <ul>
--   <li>List (or DottedList)</li>
--   </ul>
--   
--   Returns: LispVal - First item in the list
car :: [LispVal] -> IOThrowsError LispVal

-- | Return the <i>tail</i> of a list, with the first element removed
--   
--   Arguments:
--   
--   <ul>
--   <li>List (or DottedList)</li>
--   </ul>
--   
--   Returns: List (or DottedList)
cdr :: [LispVal] -> IOThrowsError LispVal

-- | The LISP <tt>cons</tt> operation - create a list from two values
--   
--   Arguments:
--   
--   <ul>
--   <li>LispVal</li>
--   <li>LispVal</li>
--   </ul>
--   
--   Returns: List (or DottedList) containing new value(s)
cons :: [LispVal] -> IOThrowsError LispVal

-- | Use pointer equality to compare two objects if possible, otherwise
--   fall back to the normal equality comparison
eq :: [LispVal] -> IOThrowsError LispVal

-- | Recursively compare two LispVals for equality
--   
--   Arguments:
--   
--   <ul>
--   <li>LispVal</li>
--   <li>LispVal</li>
--   </ul>
--   
--   Returns: Bool - True if equal, false otherwise
equal :: [LispVal] -> ThrowsError LispVal

-- | Create a new list
--   
--   Arguments
--   
--   <ul>
--   <li>Number - Length of the list</li>
--   <li>LispVal - Object to fill the list with (optional)</li>
--   </ul>
--   
--   Returns: List
makeList :: [LispVal] -> ThrowsError LispVal

-- | Create a copy of a list
--   
--   Arguments
--   
--   <ul>
--   <li>List</li>
--   </ul>
--   
--   Returns: List
listCopy :: [LispVal] -> IOThrowsError LispVal

-- | Create a vector from the given lisp values
--   
--   Arguments:
--   
--   <ul>
--   <li>LispVal (s)</li>
--   </ul>
--   
--   Returns: Vector
buildVector :: [LispVal] -> ThrowsError LispVal

-- | Determine the length of the given vector
--   
--   Arguments:
--   
--   <ul>
--   <li>Vector</li>
--   </ul>
--   
--   Returns: Number
vectorLength :: [LispVal] -> ThrowsError LispVal

-- | Retrieve the object at the given position of a vector
--   
--   Arguments:
--   
--   <ul>
--   <li>Vector</li>
--   <li>Number - Index of the vector to retrieve</li>
--   </ul>
--   
--   Returns: Object at the given index
vectorRef :: [LispVal] -> ThrowsError LispVal

-- | Create a copy of a vector
--   
--   Arguments
--   
--   <ul>
--   <li>Vector</li>
--   <li>Number - Start copying the vector from this element
--   (optional)</li>
--   <li>Number - Stop copying the vector at this element (optional)</li>
--   </ul>
--   
--   Returns: Vector
vectorCopy :: [LispVal] -> IOThrowsError LispVal

-- | Convert the given vector to a list
--   
--   Arguments:
--   
--   <ul>
--   <li>Vector</li>
--   </ul>
--   
--   Returns: List
vectorToList :: [LispVal] -> ThrowsError LispVal

-- | Convert the given list to a vector
--   
--   Arguments:
--   
--   <ul>
--   <li>List to convert</li>
--   </ul>
--   
--   Returns: Vector
listToVector :: [LispVal] -> ThrowsError LispVal

-- | Create a new vector
--   
--   Arguments:
--   
--   <ul>
--   <li>Number - Length of the vector</li>
--   <li>LispVal - Value to fill the vector with</li>
--   </ul>
--   
--   Returns: Vector
makeVector :: [LispVal] -> ThrowsError LispVal

-- | Create a new bytevector
--   
--   Arguments:
--   
--   <ul>
--   <li>Number - Length of the new bytevector</li>
--   <li>Number (optional) - Byte value to fill the bytevector with</li>
--   </ul>
--   
--   Returns: ByteVector - A new bytevector
makeByteVector :: [LispVal] -> ThrowsError LispVal

-- | Create new bytevector containing the given data
--   
--   Arguments:
--   
--   <ul>
--   <li>Objects - Objects to convert to bytes for the bytevector</li>
--   </ul>
--   
--   Returns: ByteVector - A new bytevector
byteVector :: [LispVal] -> ThrowsError LispVal

-- | Find the length of a bytevector
--   
--   Arguments:
--   
--   <ul>
--   <li>ByteVector</li>
--   </ul>
--   
--   Returns: Number - Length of the given bytevector
byteVectorLength :: [LispVal] -> IOThrowsError LispVal

-- | Return object at the given index of a bytevector
--   
--   Arguments:
--   
--   <ul>
--   <li>ByteVector</li>
--   <li>Number - Index of the bytevector to query</li>
--   </ul>
--   
--   Returns: Object at the index
byteVectorRef :: [LispVal] -> IOThrowsError LispVal

-- | Create a copy of the given bytevector
--   
--   Arguments:
--   
--   <ul>
--   <li>ByteVector - Bytevector to copy</li>
--   <li>Number (optional) - Start of the region to copy</li>
--   <li>Number (optional) - End of the region to copy</li>
--   </ul>
--   
--   Returns: ByteVector - A new bytevector containing the copied region
byteVectorCopy :: [LispVal] -> IOThrowsError LispVal

-- | Append many bytevectors into a new bytevector
--   
--   Arguments:
--   
--   <ul>
--   <li>ByteVector (one or more) - Bytevectors to concatenate</li>
--   </ul>
--   
--   Returns: ByteVector - A new bytevector containing the values
byteVectorAppend :: [LispVal] -> IOThrowsError LispVal

-- | Convert a bytevector to a string
--   
--   Arguments:
--   
--   <ul>
--   <li>ByteVector</li>
--   </ul>
--   
--   Returns: String
byteVectorUtf2Str :: [LispVal] -> IOThrowsError LispVal

-- | Convert a string to a bytevector
--   
--   Arguments:
--   
--   <ul>
--   <li>String</li>
--   </ul>
--   
--   Returns: ByteVector
byteVectorStr2Utf :: [LispVal] -> IOThrowsError LispVal

-- | Determine if the given key is found in the hashtable
--   
--   Arguments:
--   
--   <ul>
--   <li>HashTable to search</li>
--   <li>Key to search for</li>
--   </ul>
--   
--   Returns: Bool - True if found, False otherwise
hashTblExists :: [LispVal] -> ThrowsError LispVal

-- | Retrieve the value from the hashtable for the given key. An error is
--   thrown if the key is not found.
--   
--   Arguments:
--   
--   <ul>
--   <li>HashTable to copy</li>
--   <li>Object that is the key to query the table for</li>
--   </ul>
--   
--   Returns: Object containing the key's value
hashTblRef :: [LispVal] -> ThrowsError LispVal

-- | Return the number of key/value associations in the hashtable
--   
--   Arguments:
--   
--   <ul>
--   <li>HashTable</li>
--   </ul>
--   
--   Returns: Number - number of associations
hashTblSize :: [LispVal] -> ThrowsError LispVal

-- | Create a list containing all key/value pairs in the hashtable
--   
--   Arguments:
--   
--   <ul>
--   <li>HashTable</li>
--   </ul>
--   
--   Returns: List of (key, value) pairs
hashTbl2List :: [LispVal] -> ThrowsError LispVal

-- | Create a list containing all keys in the hashtable
--   
--   Arguments:
--   
--   <ul>
--   <li>HashTable</li>
--   </ul>
--   
--   Returns: List containing the keys
hashTblKeys :: [LispVal] -> ThrowsError LispVal

-- | Create a list containing all values in the hashtable
--   
--   Arguments:
--   
--   <ul>
--   <li>HashTable</li>
--   </ul>
--   
--   Returns: List containing the values
hashTblValues :: [LispVal] -> ThrowsError LispVal

-- | Create a new copy of a hashtable
--   
--   Arguments:
--   
--   <ul>
--   <li>HashTable to copy</li>
--   </ul>
--   
--   Returns: HashTable
hashTblCopy :: [LispVal] -> ThrowsError LispVal

-- | Create a new hashtable
--   
--   Arguments: (None)
--   
--   Returns: HashTable
hashTblMake :: [LispVal] -> ThrowsError LispVal

-- | A helper function to allow a pure function to work with pointers, by
--   dereferencing the leading object in the argument list if it is a
--   pointer. This is a special hash-table specific function that will also
--   dereference a hash table key if it is included.
wrapHashTbl :: ([LispVal] -> ThrowsError LispVal) -> [LispVal] -> IOThrowsError LispVal

-- | A helper function to allow a pure function to work with pointers, by
--   dereferencing the leading object in the argument list if it is a
--   pointer.
wrapLeadObj :: ([LispVal] -> ThrowsError LispVal) -> [LispVal] -> IOThrowsError LispVal

-- | Convert a list of characters to a string
--   
--   Arguments:
--   
--   <ul>
--   <li>Character (one or more) - Character(s) to add to the string</li>
--   </ul>
--   
--   Returns: String - new string built from given chars
buildString :: [LispVal] -> ThrowsError LispVal

-- | Make a new string
--   
--   Arguments:
--   
--   <ul>
--   <li>Number - number of characters in the string</li>
--   <li>Char (optional) - Character to fill in each position of string.
--   Defaults to space</li>
--   </ul>
--   
--   Returns: String - new string
makeString :: [LispVal] -> ThrowsError LispVal

-- | Helper function
doMakeString :: (Num a, Eq a) => a -> Char -> String -> LispVal

-- | Determine the length of the given string
--   
--   Arguments:
--   
--   <ul>
--   <li>String - String to examine</li>
--   </ul>
--   
--   Returns: Number - Length of the given string
stringLength :: [LispVal] -> IOThrowsError LispVal

-- | Get character at the given position of a string
--   
--   Arguments:
--   
--   <ul>
--   <li>String - String to examine</li>
--   <li>Number - Get the character at this position</li>
--   </ul>
--   
--   Returns: Char
stringRef :: [LispVal] -> IOThrowsError LispVal

-- | Get a part of the given string
--   
--   Arguments:
--   
--   <ul>
--   <li>String - Original string</li>
--   <li>Number - Starting position of the substring</li>
--   <li>Number - Ending position of the substring</li>
--   </ul>
--   
--   Returns: String - substring of the original string
substring :: [LispVal] -> IOThrowsError LispVal

-- | Perform a case insensitive comparison of the given strings
--   
--   Arguments:
--   
--   <ul>
--   <li>String - String to compare</li>
--   <li>String - String to compare</li>
--   </ul>
--   
--   Returns: Bool - True if strings are equal, false otherwise
stringCIEquals :: [LispVal] -> IOThrowsError LispVal

-- | Helper function
stringCIBoolBinop :: (String -> String -> Bool) -> [LispVal] -> IOThrowsError LispVal

-- | Append all given strings together into a single string
--   
--   Arguments:
--   
--   <ul>
--   <li>String (one or more) - String(s) to concatenate</li>
--   </ul>
--   
--   Returns: String - all given strings appended together as a single
--   string
stringAppend :: [LispVal] -> IOThrowsError LispVal

-- | Convert given string to a number
--   
--   Arguments:
--   
--   <ul>
--   <li>String - String to convert</li>
--   <li>Number (optional) - Number base to convert from, defaults to base
--   10 (decimal)</li>
--   </ul>
--   
--   Returns: Numeric type, actual type will depend upon given string
stringToNumber :: [LispVal] -> IOThrowsError LispVal

-- | Convert the given string to a list of chars
--   
--   Arguments:
--   
--   <ul>
--   <li>String - string to deconstruct</li>
--   </ul>
--   
--   Returns: List - list of characters
stringToList :: [LispVal] -> IOThrowsError LispVal

-- | Convert the given list of characters to a string
--   
--   Arguments:
--   
--   <ul>
--   <li>List - list of chars to convert</li>
--   </ul>
--   
--   Returns: String - Resulting string
listToString :: [LispVal] -> IOThrowsError LispVal

-- | Convert a string to a vector
--   
--   Arguments
--   
--   <ul>
--   <li>String</li>
--   </ul>
--   
--   Returns: Vector
stringToVector :: [LispVal] -> IOThrowsError LispVal

-- | Convert a vector to a string
--   
--   Arguments
--   
--   <ul>
--   <li>Vector</li>
--   </ul>
--   
--   Returns: String
vectorToString :: [LispVal] -> IOThrowsError LispVal

-- | Create a copy of the given string
--   
--   Arguments:
--   
--   <ul>
--   <li>String - String to copy</li>
--   </ul>
--   
--   Returns: String - New copy of the given string
stringCopy :: [LispVal] -> IOThrowsError LispVal

-- | Convert the given symbol to a string
--   
--   Arguments:
--   
--   <ul>
--   <li>Atom - Symbol to convert</li>
--   </ul>
--   
--   Returns: String
symbol2String :: [LispVal] -> ThrowsError LispVal

-- | Convert a string to a symbol
--   
--   Arguments:
--   
--   <ul>
--   <li>String (or pointer) - String to convert</li>
--   </ul>
--   
--   Returns: Atom
string2Symbol :: [LispVal] -> IOThrowsError LispVal

-- | Helper function
charCIBoolBinop :: (Char -> Char -> Bool) -> [LispVal] -> ThrowsError LispVal

-- | Determine if given character satisfies the given predicate
charPredicate :: (Char -> Bool) -> [LispVal] -> ThrowsError LispVal

-- | Convert a character to uppercase
--   
--   Arguments:
--   
--   <ul>
--   <li>Char</li>
--   </ul>
--   
--   Returns: Char - Character in uppercase
charUpper :: [LispVal] -> ThrowsError LispVal

-- | Convert a character to lowercase
--   
--   Arguments:
--   
--   <ul>
--   <li>Char</li>
--   </ul>
--   
--   Returns: Char - Character in lowercase
charLower :: [LispVal] -> ThrowsError LispVal

-- | Return integer value of a char digit
--   
--   Arguments
--   
--   <ul>
--   <li>Char</li>
--   </ul>
--   
--   Returns: Number, or False
charDigitValue :: [LispVal] -> ThrowsError LispVal

-- | Convert from a charater to an integer
--   
--   Arguments:
--   
--   <ul>
--   <li>Char</li>
--   </ul>
--   
--   Returns: Number
char2Int :: [LispVal] -> ThrowsError LispVal

-- | Convert from an integer to a character
--   
--   Arguments:
--   
--   <ul>
--   <li>Number</li>
--   </ul>
--   
--   Returns: Char
int2Char :: [LispVal] -> ThrowsError LispVal

-- | Determine if a given object is a hashtable
--   
--   Arguments:
--   
--   <ul>
--   <li>Object to inspect</li>
--   </ul>
--   
--   Returns: Bool - True if arg was a hashtable, false otherwise
isHashTbl :: [LispVal] -> ThrowsError LispVal

-- | Determine if the given value is a character
--   
--   Arguments:
--   
--   <ul>
--   <li>LispVal to check</li>
--   </ul>
--   
--   Returns: Bool - True if the argument is a character, False otherwise
isChar :: [LispVal] -> ThrowsError LispVal

-- | Determine if the given value is a string
--   
--   Arguments:
--   
--   <ul>
--   <li>LispVal to check</li>
--   </ul>
--   
--   Returns: Bool - True if the argument is a string, False otherwise
isString :: [LispVal] -> IOThrowsError LispVal

-- | Determine if the given value is a boolean
--   
--   Arguments:
--   
--   <ul>
--   <li>LispVal to check</li>
--   </ul>
--   
--   Returns: Bool - True if the argument is a boolean, False otherwise
isBoolean :: [LispVal] -> ThrowsError LispVal

-- | Determine if multiple boolean values are the same
--   
--   Arguments
--   
--   <ul>
--   <li>A list of Bool values</li>
--   </ul>
--   
--   Returns: True if the list contains booleans that are the same, False
--   otherwise
isBooleanEq :: Monad m => [LispVal] -> m LispVal

-- | Determine if multiple symbols values are the same
--   
--   Arguments
--   
--   <ul>
--   <li>A list of Atom values</li>
--   </ul>
--   
--   Returns: True if all of the symbols are the same, False otherwise
isSymbolEq :: Monad m => [LispVal] -> m LispVal

-- | Determine if given object is an improper list
--   
--   Arguments:
--   
--   <ul>
--   <li>Value to check</li>
--   </ul>
--   
--   Returns: Bool - True if improper list, False otherwise
isDottedList :: [LispVal] -> IOThrowsError LispVal

-- | Determine if given object is a procedure
--   
--   Arguments:
--   
--   <ul>
--   <li>Value to check</li>
--   </ul>
--   
--   Returns: Bool - True if procedure, False otherwise
isProcedure :: [LispVal] -> ThrowsError LispVal

-- | Determine if given object is a list
--   
--   Arguments:
--   
--   <ul>
--   <li>Value to check</li>
--   </ul>
--   
--   Returns: Bool - True if list, False otherwise
isList :: LispVal -> IOThrowsError LispVal

-- | Determine if given object is a vector
--   
--   Arguments:
--   
--   <ul>
--   <li>Value to check</li>
--   </ul>
--   
--   Returns: Bool - True if vector, False otherwise
isVector :: LispVal -> IOThrowsError LispVal

-- | Determine if given object is a record
--   
--   Arguments:
--   
--   <ul>
--   <li>Value to check</li>
--   </ul>
--   
--   Returns: Bool - True if record, False otherwise
isRecord :: LispVal -> IOThrowsError LispVal

-- | Determine if given object is a bytevector
--   
--   Arguments:
--   
--   <ul>
--   <li>Value to check</li>
--   </ul>
--   
--   Returns: Bool - True if bytevector, False otherwise
isByteVector :: LispVal -> IOThrowsError LispVal

-- | Determine if given object is the null list
--   
--   Arguments:
--   
--   <ul>
--   <li>Value to check</li>
--   </ul>
--   
--   Returns: Bool - True if null list, False otherwise
isNull :: [LispVal] -> IOThrowsError LispVal

-- | Determine if given object is the EOF marker
--   
--   Arguments:
--   
--   <ul>
--   <li>Value to check</li>
--   </ul>
--   
--   Returns: Bool - True if EOF, False otherwise
isEOFObject :: [LispVal] -> ThrowsError LispVal

-- | Determine if given object is a symbol
--   
--   Arguments:
--   
--   <ul>
--   <li>Value to check</li>
--   </ul>
--   
--   Returns: Bool - True if a symbol, False otherwise
isSymbol :: [LispVal] -> ThrowsError LispVal

-- | Utility type for unpackEquals
data Unpacker

-- | Determine if two lispval's are equal
unpackEquals :: LispVal -> LispVal -> Unpacker -> ThrowsError Bool

-- | Helper function to perform a binary logic operation on two LispVal
--   arguments.
boolBinop :: (LispVal -> ThrowsError a) -> (a -> a -> Bool) -> [LispVal] -> ThrowsError LispVal

-- | Perform the given function against a single LispVal argument
unaryOp :: (LispVal -> ThrowsError LispVal) -> [LispVal] -> ThrowsError LispVal

-- | Same as unaryOp but in the IO monad
unaryOp' :: (LispVal -> IOThrowsError LispVal) -> [LispVal] -> IOThrowsError LispVal

-- | Perform boolBinop against two string arguments
strBoolBinop :: (String -> String -> Bool) -> [LispVal] -> IOThrowsError LispVal

-- | Perform boolBinop against two char arguments
charBoolBinop :: (Char -> Char -> Bool) -> [LispVal] -> ThrowsError LispVal

-- | Perform boolBinop against two boolean arguments
boolBoolBinop :: (Bool -> Bool -> Bool) -> [LispVal] -> ThrowsError LispVal

-- | Unpack a LispVal String
--   
--   Arguments:
--   
--   <ul>
--   <li>String - String to unpack</li>
--   </ul>
unpackStr :: LispVal -> ThrowsError String

-- | Unpack a LispVal boolean
--   
--   Arguments:
--   
--   <ul>
--   <li>Bool - Boolean to unpack</li>
--   </ul>
unpackBool :: LispVal -> ThrowsError Bool

-- | Open the given file
--   
--   LispVal Arguments:
--   
--   <ul>
--   <li>String - filename</li>
--   </ul>
--   
--   Returns: Port
makePort :: (FilePath -> IOMode -> IO Handle) -> IOMode -> [LispVal] -> IOThrowsError LispVal

-- | Create an memory-backed port
makeBufferPort :: Maybe LispVal -> IOThrowsError LispVal

-- | Create a new input string buffer
openInputString :: [LispVal] -> IOThrowsError LispVal

-- | Create a new output string buffer
openOutputString :: [LispVal] -> IOThrowsError LispVal

-- | Get string written to string-output-port
getOutputString :: [LispVal] -> IOThrowsError LispVal

-- | Create a new input bytevector buffer
openInputByteVector :: [LispVal] -> IOThrowsError LispVal

-- | Create a new output bytevector buffer
openOutputByteVector :: [LispVal] -> IOThrowsError LispVal

-- | Get bytevector written to bytevector-output-port
getOutputByteVector :: [LispVal] -> IOThrowsError LispVal

-- | Close the given port
--   
--   Arguments:
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: Bool - True if the port was closed, false otherwise
closePort :: [LispVal] -> IOThrowsError LispVal

-- | Flush the given output port
flushOutputPort :: [LispVal] -> IOThrowsError LispVal

-- | Return the current input port
--   
--   LispVal Arguments: (None)
--   
--   Returns: Port
currentOutputPort :: [LispVal] -> IOThrowsError LispVal

-- | Return the current input port
--   
--   LispVal Arguments: (None)
--   
--   Returns: Port
currentInputPort :: [LispVal] -> IOThrowsError LispVal

-- | Determine if the given port is a text port.
--   
--   Arguments
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: Bool
isTextPort :: [LispVal] -> IOThrowsError LispVal

-- | Determine if the given port is a binary port.
--   
--   Arguments
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: Bool
isBinaryPort :: [LispVal] -> IOThrowsError LispVal

-- | Determine if the given objects is an output port
--   
--   LispVal Arguments:
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: Bool - True if an output port, false otherwise
isOutputPort :: [LispVal] -> IOThrowsError LispVal

-- | Determine if the given objects is an input port
--   
--   LispVal Arguments:
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: Bool - True if an input port, false otherwise
isInputPort :: [LispVal] -> IOThrowsError LispVal

-- | Determine if the given port is open
--   
--   Arguments
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: Bool
isInputPortOpen :: [LispVal] -> IOThrowsError LispVal

-- | Determine if the given port is open
--   
--   Arguments
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: Bool
isOutputPortOpen :: [LispVal] -> IOThrowsError LispVal

-- | Determine if a character is ready on the port
--   
--   LispVal Arguments:
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: Bool
isCharReady :: [LispVal] -> IOThrowsError LispVal

-- | Read from the given port
--   
--   LispVal Arguments:
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: LispVal
readProc :: Bool -> [LispVal] -> IOThrowsError LispVal

-- | Read character from port
--   
--   LispVal Arguments:
--   
--   <ul>
--   <li>Port</li>
--   </ul>
--   
--   Returns: Char
readCharProc :: (Handle -> IO Char) -> [LispVal] -> IOThrowsError LispVal

-- | Read a byte vector from the given port
--   
--   Arguments
--   
--   <ul>
--   <li>Number - Number of bytes to read</li>
--   <li>Port - Port to read from</li>
--   </ul>
--   
--   Returns: ByteVector
readByteVector :: [LispVal] -> IOThrowsError LispVal

-- | Read a string from the given port
--   
--   Arguments
--   
--   <ul>
--   <li>Number - Number of bytes to read</li>
--   <li>Port - Port to read from</li>
--   </ul>
--   
--   Returns: String
readString :: [LispVal] -> IOThrowsError LispVal

-- | Write to the given port
--   
--   LispVal Arguments:
--   
--   <ul>
--   <li>LispVal</li>
--   <li>Port (optional)</li>
--   </ul>
--   
--   Returns: (None)
writeProc :: (Handle -> LispVal -> IO a) -> [LispVal] -> ErrorT LispError IO LispVal

-- | Write character to the given port
--   
--   Arguments:
--   
--   <ul>
--   <li>Char - Value to write</li>
--   <li>Port (optional) - Port to write to, defaults to standard
--   output</li>
--   </ul>
--   
--   Returns: (None)
writeCharProc :: [LispVal] -> IOThrowsError LispVal

-- | Write a byte vector to the given port
--   
--   Arguments
--   
--   <ul>
--   <li>ByteVector</li>
--   <li>Port</li>
--   </ul>
--   
--   Returns: (unspecified)
writeByteVector :: [LispVal] -> IOThrowsError LispVal

-- | Write a string to the given port
--   
--   Arguments
--   
--   <ul>
--   <li>String</li>
--   <li>Port</li>
--   </ul>
--   
--   Returns: (unspecified)
writeString :: [LispVal] -> IOThrowsError LispVal

-- | Read the given file and return the raw string content
--   
--   Arguments:
--   
--   <ul>
--   <li>String - Filename to read</li>
--   </ul>
--   
--   Returns: String - Actual text read from the file
readContents :: [LispVal] -> IOThrowsError LispVal

-- | Parse the given file and return a list of scheme expressions
--   
--   Arguments:
--   
--   <ul>
--   <li>String - Filename to read</li>
--   </ul>
--   
--   Returns: [LispVal] - Raw contents of the file parsed as scheme code
load :: String -> IOThrowsError [LispVal]

-- | Read the contents of the given scheme source file into a list
--   
--   Arguments:
--   
--   <ul>
--   <li>String - Filename to read</li>
--   </ul>
--   
--   Returns: List - Raw contents of the file parsed as scheme code
readAll :: [LispVal] -> IOThrowsError LispVal

-- | Determine if the given file exists
--   
--   Arguments:
--   
--   <ul>
--   <li>String - Filename to check</li>
--   </ul>
--   
--   Returns: Bool - True if file exists, false otherwise
fileExists :: [LispVal] -> IOThrowsError LispVal

-- | Delete the given file
--   
--   Arguments:
--   
--   <ul>
--   <li>String - Filename to delete</li>
--   </ul>
--   
--   Returns: Bool - True if file was deleted, false if an error occurred
deleteFile :: [LispVal] -> IOThrowsError LispVal

-- | Return the EOF object
eofObject :: [LispVal] -> ThrowsError LispVal

-- | Generate a (reasonably) unique symbol, given an optional prefix. This
--   function is provided even though it is not part of R5RS.
--   
--   Arguments:
--   
--   <ul>
--   <li>String - Prefix of the unique symbol</li>
--   </ul>
--   
--   Returns: Atom
gensym :: [LispVal] -> IOThrowsError LispVal

-- | Version of gensym that can be conveniently called from Haskell.
_gensym :: String -> IOThrowsError LispVal

-- | Return the current time, in seconds
--   
--   Arguments: (None)
--   
--   Returns: Current UNIX timestamp in seconds
currentTimestamp :: [LispVal] -> IOThrowsError LispVal

-- | Execute a system command on the underlying OS.
--   
--   Arguments:
--   
--   <ul>
--   <li>String - Command to execute</li>
--   </ul>
--   
--   Returns: Integer - program return status
system :: [LispVal] -> IOThrowsError LispVal

-- | Retrieve all environment variables
--   
--   Arguments: (none)
--   
--   Returns: List - list of key/value alists
getEnvVars :: [LispVal] -> IOThrowsError LispVal


-- | This module contains code for explicit renaming (ER) macros, and is
--   used by the Macro module to provide support for ER macros, both when
--   called directly or when ER macros are found during macro expansion.
--   This ensures both the er-macro-transformer and syntax-rules systems
--   are compatible with each other.
--   
--   Explicit renaming macros are based on the low-level facility from Will
--   Clinger's paper "Hygienic Macros Through Explicit Renaming", which was
--   developed to complement the high level specification language
--   (syntax-rules) from "Macros that Work".
module Language.Scheme.Macro.ExplicitRenaming

-- | Handle an explicit renaming macro
explicitRenamingTransform :: Env -> Env -> Env -> LispVal -> LispVal -> (LispVal -> LispVal -> [LispVal] -> IOThrowsError LispVal) -> IOThrowsError LispVal


-- | This module contains code for hygienic macros.
--   
--   Hygienic macros are implemented using the algorithm from the paper
--   Macros That Work by William Clinger and Jonathan Rees. During
--   transformation, the following components are considered:
--   
--   <ul>
--   <li>Pattern (part of a rule that matches input)</li>
--   <li>Transform (what the macro expands into)</li>
--   <li>Literal Identifiers (from the macro definition)</li>
--   <li>Input (the actual code in the user's program)</li>
--   <li>Environments of macro definition and macro use</li>
--   </ul>
--   
--   At a high level, macro transformation is broken down into the
--   following steps:
--   
--   <ol>
--   <li>Walk the input code looking for a macro definition or macro
--   call.</li>
--   <li>If a macro call is found, search for a rule that matches the
--   input. During this process any pattern variables in the input are
--   loaded into a temporary environment</li>
--   <li>If a rule matches, transcribe the rule's template by walking the
--   template, inserting pattern variables and renaming free identifiers as
--   needed.</li>
--   <li>Walk the expanded code, checking for each of the cases from Macros
--   That Work. If a case is found (such as a macro call or procedure
--   abstraction) then the appropriate handler will be called to deal with
--   it.</li>
--   </ol>
module Language.Scheme.Macro

-- | This function walks the given block of code using the macro expansion
--   algorithm, recursively expanding macro calls as they are encountered.
expand :: Env -> Bool -> LispVal -> (LispVal -> LispVal -> [LispVal] -> IOThrowsError LispVal) -> IOThrowsError LispVal

-- | Examines the input AST to see if it is a macro call. If a macro call
--   is found, the code is expanded. Otherwise the input is returned
--   unchanged.
macroEval :: Env -> LispVal -> (LispVal -> LispVal -> [LispVal] -> IOThrowsError LispVal) -> IOThrowsError LispVal

-- | Helper function to load macros from a let*-syntax expression
loadMacros :: Env -> Env -> Maybe Env -> Bool -> [LispVal] -> IOThrowsError LispVal

-- | Get a list of variables that the macro hygiene subsystem diverted back
--   into the calling environment.
--   
--   This is a specialized function that is only mean to be used by the
--   husk compiler.
getDivertedVars :: Env -> IOThrowsError [LispVal]


-- | This module contains code to handle R7RS libraries. NOTE: Libraries
--   are usually referred to as <i>modules</i> in the husk source code.
module Language.Scheme.Libraries

-- | Get the full path to a module file
findModuleFile :: [LispVal] -> IOThrowsError LispVal

-- | Import definitions from one environment into another
moduleImport :: Env -> Env -> [LispVal] -> IOThrowsError LispVal


module Language.Scheme.Environments

-- | Pure primitive functions
primitives :: [(String, [LispVal] -> ThrowsError LispVal)]

-- | Primitive functions that execute within the IO monad
ioPrimitives :: [(String, [LispVal] -> IOThrowsError LispVal)]


-- | This module contains Core functionality, primarily Scheme expression
--   evaluation.
module Language.Scheme.Core

-- | Evaluate a lisp data structure and return a value for use by husk
evalLisp :: Env -> LispVal -> IOThrowsError LispVal

-- | Evaluate a lisp data structure and return the LispVal or LispError
--   result directly
--   
--   <pre>
--   result &lt;- evalLisp' env $ List [Atom "/", Number 1, Number 0]
--   case result of
--     Left err -&gt; putStrLn $ "Error: " ++ (show err)
--     Right val -&gt; putStrLn $ show val
--   </pre>
evalLisp' :: Env -> LispVal -> IO (ThrowsError LispVal)

-- | Evaluate a string containing Scheme code
--   
--   <pre>
--   env &lt;- primitiveBindings
--   
--   evalString env "(+ x x x)"
--   "3"
--   
--   evalString env "(+ x x x (* 3 9))"
--   "30"
--   
--   evalString env "(* 3 9)"
--   "27"
--   </pre>
evalString :: Env -> String -> IO String

-- | Evaluate a string and print results to console
evalAndPrint :: Env -> String -> IO ()

-- | Call into a Scheme function
apply :: LispVal -> LispVal -> [LispVal] -> IOThrowsError LispVal

-- | A support function for eval; eval calls into this function instead of
--   returning values directly. continueEval then uses the continuation
--   argument to manage program control flow.
continueEval :: Env -> LispVal -> LispVal -> Maybe [LispVal] -> IOThrowsError LispVal

-- | Execute an IO action and return error or Nothing if no error was
--   thrown.
runIOThrows :: IOThrowsError String -> IO (Maybe String)

-- | Execute an IO action and return result or an error message. This is
--   intended for use by a REPL, where a result is always needed regardless
--   of type.
runIOThrowsREPL :: IOThrowsError String -> IO String

-- | An empty environment with the %import function. This is presently just
--   intended for internal use by the compiler.
nullEnvWithImport :: IO Env

-- | Environment containing the primitive forms that are built into the
--   Scheme language. This function only includes forms that are
--   implemented in Haskell; derived forms implemented in Scheme (such as
--   let, list, etc) are available in the standard library which must be
--   pulled into the environment using <i>(load)</i>
--   
--   For the purposes of using husk as an extension language,
--   <i>r5rsEnv</i> will probably be more useful.
primitiveBindings :: IO Env

-- | Load the standard r5rs environment, including libraries
r5rsEnv :: IO Env

-- | Load the standard r5rs environment, including libraries, but do not
--   create the (import) binding
r5rsEnv' :: IO Env

-- | Load the standard r7rs environment, including libraries
--   
--   Note that the only difference between this and the r5rs equivalent is
--   that slightly less Scheme code is loaded initially.
r7rsEnv :: IO Env

-- | Load the standard r7rs environment
r7rsEnv' :: IO Env

-- | Load haskell bindings used for the r7rs time library
r7rsTimeEnv :: IO Env

-- | Husk version number
version :: String

-- | Attempts to find the file both in the current directory and in the
--   husk libraries. If the file is not found in the current directory but
--   exists as a husk library, return the full path to the file in the
--   library. Otherwise just return the given filename.
findFileOrLib :: String -> ErrorT LispError IO String

-- | Get the full path to a data file installed for husk
getDataFileFullPath :: String -> IO String

-- | Replace a list element, by index. Taken from:
--   <a>http://stackoverflow.com/questions/10133361/haskell-replace-element-in-list</a>
replaceAtIndex :: Int -> a -> [a] -> [a]

-- | Register optional SRFI extensions
registerExtensions :: Env -> (FilePath -> IO FilePath) -> IO ()

-- | A utility function to display the husk console banner
showBanner :: IO ()

-- | This is the recommended function to use to display a lisp error,
--   instead of just using show directly.
showLispError :: LispError -> IO String

-- | A helper function for the special form <i>(string-set!)</i>
substr :: (LispVal, LispVal, LispVal) -> IOThrowsError LispVal

-- | A helper function for <i>(list-set!)</i>
updateList :: LispVal -> LispVal -> LispVal -> IOThrowsError LispVal

-- | A helper function for the special form <i>(vector-set!)</i>
updateVector :: LispVal -> LispVal -> LispVal -> IOThrowsError LispVal

-- | A helper function for the special form <i>(bytevector-u8-set!)</i>
updateByteVector :: LispVal -> LispVal -> LispVal -> IOThrowsError LispVal

-- | Add a function to the call history
addToCallHistory :: LispVal -> [LispVal] -> [LispVal]

-- | Rethrow given error with call history, if available
throwErrorWithCallHistory :: LispVal -> LispError -> IOThrowsError LispVal

-- | A wrapper for macroEval and eval
meval :: Env -> LispVal -> LispVal -> IOThrowsError LispVal


-- | This module contains data types used by the compiler.
module Language.Scheme.Compiler.Types

-- | A type to store options passed to compile. Eventually all of this
--   might be able to be integrated into a Compile monad.
data CompOpts
CompileOptions :: String -> Bool -> Bool -> Maybe String -> CompOpts

-- | Immediate name to use when creating a compiled function. Presumably
--   there is other code that is expecting to call into it.
coptsThisFunc :: CompOpts -> String

-- | Whether to include the <i>value</i> parameter in the current function
coptsThisFuncUseValue :: CompOpts -> Bool

-- | Whether to include the <i>args</i> parameter in the current function
coptsThisFuncUseArgs :: CompOpts -> Bool

-- | The name to use for the next function after the current compiler
--   recursion is finished. For example, after compiling a block of code,
--   the control flow would be expected to go to this function.
coptsNextFunc :: CompOpts -> Maybe String

-- | Options passed to the compiler library module
data CompLibOpts
CompileLibraryOptions :: (String -> Maybe String -> Env -> [HaskAST] -> [LispVal] -> IOThrowsError [HaskAST]) -> (Env -> String -> String -> Maybe String -> IOThrowsError [HaskAST]) -> CompLibOpts
compBlock :: CompLibOpts -> String -> Maybe String -> Env -> [HaskAST] -> [LispVal] -> IOThrowsError [HaskAST]
compLisp :: CompLibOpts -> Env -> String -> String -> Maybe String -> IOThrowsError [HaskAST]

-- | The default compiler options
defaultCompileOptions :: String -> CompOpts

-- | A very basic type to store a Haskell AST.
data HaskAST
AstAssignM :: String -> HaskAST -> HaskAST
AstFunction :: String -> String -> [HaskAST] -> HaskAST
astfName :: HaskAST -> String
astfArgs :: HaskAST -> String
astfCode :: HaskAST -> [HaskAST]
AstValue :: String -> HaskAST
AstRef :: String -> HaskAST
AstContinuation :: String -> String -> HaskAST
astcNext :: HaskAST -> String
astcArgs :: HaskAST -> String

-- | Convert abstract syntax tree to a string
ast2Str :: LispVal -> String

-- | Convert a list of abstract syntax trees to a list of strings
asts2Str :: [LispVal] -> String

-- | Create code for a function
createAstFunc :: CompOpts -> [HaskAST] -> HaskAST

-- | Create code for a continutation
createAstCont :: CompOpts -> String -> String -> HaskAST

-- | A utility function to join list members together
joinL :: [[a]] -> [a] -> [a]

-- | Runtime reference to module data structure
moduleRuntimeVar :: String

-- | Generate code based on the given Haskell AST
showValAST :: HaskAST -> String

-- | Block of code used in the header of a Haskell program generated by the
--   compiler.
header :: String -> Bool -> String -> [String]

-- | Header comment used at the top of a Haskell program generated by the
--   compiler
headerComment :: [String]

-- | Main module used in a compiled Haskell program
headerModule :: [String]

-- | Imports used for a compiled program
headerImports :: [String]
instance Show HaskAST


-- | This module contains support for compiling libraries of scheme code.
module Language.Scheme.Compiler.Libraries

-- | Import all given modules and generate code for them
importAll :: Env -> Env -> [LispVal] -> CompLibOpts -> CompOpts -> IOThrowsError [HaskAST]


-- | This module contains a Scheme to Haskell compiler which performs the
--   following transformations:
--   
--   <pre>
--   Scheme AST (LispVal) =&gt; Haskell AST (HaskAST) =&gt; Compiled Code (String)
--   </pre>
--   
--   The GHC compiler is then used to create a native executable. At
--   present, the focus has just been on creating a compiler that will
--   generate correct, working code. Many optimizations could and need to
--   be made for time and space...
--   
--   Note the following type is used for all functions generated by the
--   compiler:
--   
--   <pre>
--   compiledFunc :: 
--     Env -&gt;                  -- Runtime Environment
--     LispVal -&gt;              -- Continuation
--     LispVal -&gt;              -- Value
--     Maybe [LispVal] -&gt;      -- Additional arguments
--     IOThrowsError LispVal   -- Result
--   </pre>
module Language.Scheme.Compiler

-- | Compile a Lisp expression to Haskell. Note this function does not
--   expand macros; mcompile should be used instead if macros may appear in
--   the expression.
compile :: Env -> LispVal -> CompOpts -> IOThrowsError [HaskAST]

-- | Compile a function call
compileApply :: Env -> LispVal -> CompOpts -> IOThrowsError [HaskAST]

-- | Compile a list (block) of Scheme code
compileBlock :: String -> Maybe String -> Env -> [HaskAST] -> [LispVal] -> IOThrowsError [HaskAST]

-- | Take a list of variables diverted into env at compile time, and divert
--   them into the env at runtime
compileDivertedVars :: String -> Env -> [LispVal] -> CompOpts -> IOThrowsError HaskAST

-- | Compile an intermediate expression (such as an arg to if) and call
--   into the next continuation with it's value
compileExpr :: Env -> LispVal -> String -> Maybe String -> IOThrowsError [HaskAST]

-- | Compile the list of arguments for a function
compileLambdaList :: [LispVal] -> IOThrowsError String

-- | Compile a file containing scheme code
compileLisp :: Env -> String -> String -> Maybe String -> IOThrowsError [HaskAST]

-- | Helper function to compile expressions consisting of a scalar
compileScalar :: String -> CompOpts -> IOThrowsError [HaskAST]

-- | Helper function for compiling a special form
compileSpecialForm :: String -> String -> CompOpts -> IOThrowsError HaskAST

-- | A wrapper for each special form that allows the form variable (EG:
--   "if") to be redefined at compile time
compileSpecialFormBody :: Env -> LispVal -> CompOpts -> (Maybe String -> ErrorT LispError IO [HaskAST]) -> ErrorT LispError IO [HaskAST]

-- | Create the function entry point for a special form
compileSpecialFormEntryPoint :: String -> String -> CompOpts -> IOThrowsError HaskAST

-- | Add lambda variables to the compiler's environment
defineLambdaVars :: Env -> [LispVal] -> IOThrowsError LispVal

-- | Find all variables defined at "this" level and load their symbols into
--   the environment. This allows the compiler validation to work even
--   though a variable is used in a sub-form before it is defined further
--   on down in the program
defineTopLevelVars :: Env -> [LispVal] -> IOThrowsError LispVal

-- | Do the actual insertion of diverted variables back to the compiled
--   program.
divertVars :: Env -> LispVal -> CompOpts -> (Env -> LispVal -> CompOpts -> IOThrowsError [HaskAST]) -> IOThrowsError [HaskAST]

-- | Perform one-time initialization of the compiler's environment
initializeCompiler :: Env -> IOThrowsError [HaskAST]

-- | Determines if the given lispval is a primitive function
isPrim :: Env -> LispVal -> IOThrowsError (Maybe LispVal)

-- | Expand macros and compile the resulting code
mcompile :: Env -> LispVal -> CompOpts -> IOThrowsError [HaskAST]

-- | Expand macros and then pass control to the given function
mfunc :: Env -> LispVal -> (Env -> LispVal -> CompOpts -> IOThrowsError [HaskAST]) -> CompOpts -> IOThrowsError [HaskAST]
