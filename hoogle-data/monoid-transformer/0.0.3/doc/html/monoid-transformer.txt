-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monoid counterparts to some ubiquitous monad transformers
--   
--   Monoid transformers: State, Reader
--   
--   There is no Writer transformer. It's vice versa: The Writer monad
--   transforms a monoid to a monad.
@package monoid-transformer
@version 0.0.3

module Data.Monoid.MonadicEndo

-- | Like Data.Monoid.Endo but with monadic result. <a>mempty</a> is
--   <a>return</a> and <a>mappend</a> is <tt>&lt;=&lt;</tt>.
--   
--   Useful e.g. for handling options with GetOpt.
newtype T m a
Cons :: (a -> m a) -> T m a
run :: T m a -> a -> m a
instance Monad m => Monoid (T m a)

module Data.Monoid.Transformer
class C t
lift :: (C t, Monoid m) => m -> t m

module Data.Monoid.Monad

-- | Sequence actions and combine their monadic results with
--   <a>mappend</a>.
--   
--   This type could be omitted, if <a>Monad</a> would be a sub-class of
--   <tt>Applicative</tt>.
newtype T m a
Cons :: m a -> T m a
run :: T m a -> m a
instance Monad m => C (T m)
instance (Monad m, Monoid a) => Monoid (T m a)

module Data.Monoid.Reader

-- | Could also be written as <tt>Monoid.Applicative (Monad.Trans.Reader r)
--   a</tt>.
newtype T r a
Cons :: (r -> a) -> T r a
run :: T r a -> r -> a
pure :: a -> T r a
instance Functor (T r)
instance C (T r)
instance Monoid a => Monoid (T r a)

module Data.Monoid.State

-- | This resembles the pure State monad. However, State in transformers is
--   a StateT and mtl is not Haskell 98.
--   
--   I hope I have the more natural parameter order for <a>evaluate</a> in
--   contrast to <tt>mtl</tt> and <tt>transformers</tt>. However, it is
--   different from the parameter order of <a>run</a>.
--   
--   Could also be written as <tt>Monoid.Applicative (Monad.Trans.State s)
--   a</tt>.
newtype T s a
Cons :: (s -> (a, s)) -> T s a
run :: T s a -> s -> (a, s)
pure :: a -> T s a
evaluate :: s -> T s a -> a
execute :: s -> T s a -> s
put :: Monoid a => s -> T s a
modify :: Monoid a => (s -> s) -> T s a
mapFst :: (a -> c) -> (a, b) -> (c, b)
instance Functor (T s)
instance C (T s)
instance Monoid a => Monoid (T s a)

module Data.Monoid.Applicative

-- | Sequence applicative functors and combine their functorial results
--   with <a>mappend</a>.
newtype T f a
Cons :: f a -> T f a
run :: T f a -> f a
instance Applicative f => C (T f)
instance (Applicative f, Monoid a) => Monoid (T f a)
