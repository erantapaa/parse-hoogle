-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | TigerHash with C implementation
--   
--   This library provides Tiger Hash algorithm implemented in C and built
--   with Haskell interface. As well there is implementation of Merkle Tree
--   known as TTH (Tiger Tree Hash).
@package TigerHash
@version 0.2

module Data.Digest.TigerHash.Internal
data TigerHash
TigerHash :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> TigerHash
class TigerContext c
initContext :: TigerContext c => c -> IO ()
updateContext :: TigerContext c => c -> Ptr a -> Int -> IO ()
resetContext :: TigerContext c => c -> IO ()
finalizeContext :: TigerContext c => c -> IO TigerHash
data TigerState
data TigerTreeState
newTigerContext :: IO (ForeignPtr TigerState)
newTigerTreeContext :: IO (ForeignPtr TigerTreeState)
withTigerContext :: (Ptr TigerState -> IO a) -> IO a
withTigerTreeContext :: (Ptr TigerTreeState -> IO a) -> IO a
instance TigerContext (Ptr a) => TigerContext (ForeignPtr a)
instance TigerContext (Ptr TigerTreeState)
instance TigerContext (Ptr TigerState)


-- | There comes some kind of description how to use this module.
--   
--   Assume next import:
--   
--   <pre>
--   import Data.Digest.TigerHash
--   </pre>
--   
--   Typical instant usage:
--   
--   <pre>
--   instance TigerHashable k =&gt; TigerHashable (k, Message) where
--       tigerHashUpdate ctx_ (key, Message {sender = data0, body = data1}) = do
--           tigerHashUpdate ctx_ key
--           tigerHashUpdate ctx_ data0
--           tigerHashUpdate ctx_ data1
--   
--   signMessage :: TigerHashable k =&gt; k -&gt; Message -&gt; SignedMessage
--   signMessage pkey msg = SignedMessage { message = msg, sign = tigerHash (pkey, msg) }
--   </pre>
--   
--   This is pretty useful when you need to send signed messages over
--   public channel.
--   
--   But using this in a such functional way have its drawbacks. Each time
--   system requires calculation of <tt>hash</tt> it will issue prepearing
--   of new context for each calculation instead of using the same context.
--   
--   To solve that there is function for processing lazy list:
--   
--   <pre>
--   hashMessageSenders :: [Message] -&gt; [(TigerHash, Message)]
--   hashMessageSenders msgs = zip (tigerHashList senders) msgs
--       where senders = map sender msgs
--   </pre>
--   
--   This can be used for building hashed storage, which requires hash of
--   each element.
--   
--   Notice that while you expand each node of the list
--   <a>tigerHashList</a> will calculate it's <tt>head</tt> for you. That's
--   done with intention to loose overhead while hashing files for DC++ .
module Data.Digest.TigerHash
data TigerHash
class TigerHashable a
tigerHashUpdate :: (TigerHashable a, TigerContext (Ptr c)) => Ptr c -> a -> IO ()
tigerHash :: TigerHashable a => a -> TigerHash
tigerTreeHash :: TigerHashable a => a -> TigerHash
tigerHashList :: TigerHashable a => [a] -> [TigerHash]
tigerTreeHashList :: TigerHashable a => [a] -> [TigerHash]

-- | render <a>TigerHash</a> to <a>String</a> as hex-dump
hexTigerHash :: TigerHash -> String

-- | render <a>TigerHash</a> to <a>String</a> using Base32 encoding (as
--   used in magnet-links and etc.)
b32TigerHash :: TigerHash -> String
instance Binary TigerHash
instance Show TigerHash


-- | This module provides nothing, but instances for <a>TigerHashable</a>
module Data.Digest.TigerHash.ByteString
instance TigerHashable [Word8]
instance TigerHashable ByteString
instance TigerHashable ByteString
