-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | IPv4 Network Stack
--   
--   HaNS is a lightweight, pure Haskell network stack that can be used for
--   Haskell networking in the context of the HaLVM, or with a Linux tap
--   device. Currently, HaNS supports 802.3, IPv4, ARP, DHCP (partially),
--   ICMP, UDP, and TCP.
@package hans
@version 2.4.0.0

module Hans.Message.Types
newtype Lifetime
Lifetime :: Word16 -> Lifetime
getLifetime :: Lifetime -> Word16
parseLifetime :: Get Lifetime
renderLifetime :: Putter Lifetime
instance Show Lifetime
instance Eq Lifetime
instance Ord Lifetime
instance Num Lifetime

module Hans.Layer.Tcp.WaitBuffer

-- | The boolean parameter indicates whether or not the wakeup is happening
--   in the event of a shutdown, or if the original request should be
--   re-run, allowing more data to flow.
type Wakeup = Bool -> IO ()

-- | Indicate that the action should be retried.
tryAgain :: Wakeup -> IO ()

-- | Indicate that the original action will never succeed.
abort :: Wakeup -> IO ()

-- | Incoming data.
data Incoming

-- | Outgoing data.
data Outgoing

-- | Data Buffers, in a direction.
data Buffer d

-- | An empty buffer, with a limit.
emptyBuffer :: Int64 -> Buffer d

-- | Run all waiting continuations with a parameter of False,
shutdownWaiting :: Buffer d -> (IO (), Buffer d)

-- | A queue is full when there is no available space.
isFull :: Buffer d -> Bool

-- | A queue is empty when all space is available.
isEmpty :: Buffer d -> Bool

-- | Flush the queue of blocked processes, returning an IO action that
--   negatively acks the waiting processes, and a buffer with an empty wait
--   queue.
flushWaiting :: Buffer d -> (IO (), Buffer d)

-- | Queue bytes in an outgoing buffer. When there's no space available in
--   the buffer, the wakeup action is queued.
writeBytes :: ByteString -> Wakeup -> Buffer Outgoing -> (Maybe Int64, Buffer Outgoing)

-- | Read bytes from an incoming buffer, queueing if there are no bytes to
--   read.
readBytes :: Int64 -> Wakeup -> Buffer Incoming -> (Maybe ByteString, Buffer Incoming)

-- | Take bytes off of a sending queue, making room new data.
takeBytes :: Int64 -> Buffer Outgoing -> Maybe (Maybe Wakeup, ByteString, Buffer Outgoing)

-- | Place bytes on the incoming buffer, provided that there is enough
--   space for all of the bytes.
putBytes :: ByteString -> Buffer Incoming -> Maybe (Maybe Wakeup, Buffer Incoming)

module Hans.Ports
data PortManager i
emptyPortManager :: [i] -> PortManager i
isUsed :: (Eq i, Ord i) => i -> PortManager i -> Bool
reserve :: (Eq i, Ord i, Show i) => i -> PortManager i -> Maybe (PortManager i)
unreserve :: (Eq i, Ord i, Show i) => i -> PortManager i -> Maybe (PortManager i)
nextPort :: (Eq i, Ord i, Show i) => PortManager i -> Maybe (i, PortManager i)
instance Show i => Show (PortManager i)


-- | A module providing checksum computations to other parts of Hans. The
--   checksum here is the standard Internet 16-bit checksum (the one's
--   complement of the one's complement sum of the data).
module Hans.Utils.Checksum

-- | Compute the final checksum, using the given initial value.
computeChecksum :: Word32 -> ByteString -> Word16
finalizeChecksum :: PartialChecksum -> Word16

-- | Compute a partial checksum, yielding a value suitable to be passed to
--   computeChecksum.
computePartialChecksum :: PartialChecksum -> ByteString -> PartialChecksum

-- | Compute the checksum of a lazy bytestring.
computePartialChecksumLazy :: PartialChecksum -> ByteString -> PartialChecksum

-- | Clear the two bytes at the checksum offset of a rendered packet.
clearChecksum :: ByteString -> Int -> IO ByteString

-- | Poke a checksum into a bytestring.
pokeChecksum :: Word16 -> ByteString -> Int -> IO ByteString
emptyPartialChecksum :: PartialChecksum

module Hans.Timers
type Milliseconds = Int

-- | A handle to a scheduled timer.
--   
--   NOTE: This keeps a weak reference to the thread containing the timer,
--   to allow it to still receive exceptions (see mkWeakThreadId).
data Timer

-- | Delay an action, giving back a handle to allow the timer to be
--   cancelled.
delay :: Milliseconds -> IO () -> IO Timer

-- | Delay an action.
delay_ :: Milliseconds -> IO () -> IO ()

-- | Cancel a delayed action.
cancel :: Timer -> IO ()
expired :: Timer -> IO Bool

module Hans.Channel
type Channel a = Chan a
newChannel :: IO (Channel a)
receive :: Channel a -> IO a
send :: Channel a -> a -> IO ()

module Hans.Utils
type DeviceName = String

-- | Pseudo headers are constructed strictly.
type MkPseudoHeader = Int -> ByteString
type Endo a = a -> a

-- | Discard the result of a monadic computation.
void :: Monad m => m a -> m ()

-- | Show a single hex number, padded with a leading 0.
showPaddedHex :: (Integral a, Show a) => a -> ShowS

-- | Lift a maybe into MonadPlus
just :: MonadPlus m => Maybe a -> m a

-- | Make a singleton list.
singleton :: a -> [a]

-- | Make a lazy bytestring from a strict one.
chunk :: ByteString -> ByteString
strict :: ByteString -> ByteString

module Hans.Layer
data LayerState i
LayerState :: POSIXTime -> i -> LayerState i
lsNow :: LayerState i -> POSIXTime
lsState :: LayerState i -> i
data Action
Nop :: Action
Action :: (IO ()) -> Action
runAction :: Action -> IO ()
data Result i a
Error :: Action -> Result i a
Exit :: (LayerState i) -> Action -> Result i a
Result :: (LayerState i) -> a -> Action -> Result i a

-- | Early exit continuation
type Exit i r = LayerState i -> Action -> Result i r

-- | Failure continuation
type Failure i r = Action -> Result i r

-- | Success continuation
type Success a i r = a -> LayerState i -> Action -> Result i r
newtype Layer i a
Layer :: (forall r. LayerState i -> Action -> Exit i r -> Failure i r -> Success a i r -> Result i r) -> Layer i a
getLayer :: Layer i a -> forall r. LayerState i -> Action -> Exit i r -> Failure i r -> Success a i r -> Result i r
runLayer :: LayerState i -> Layer i a -> Result i a
loopLayer :: String -> i -> IO msg -> (msg -> Layer i ()) -> IO ()

-- | Finish early, successfully, with no further processing.
finish :: Layer i a
dropPacket :: Layer i a
time :: Layer i POSIXTime
output :: IO () -> Layer i ()
liftRight :: Either String b -> Layer i b
type Handlers k a = Map k a
emptyHandlers :: Handlers k a
class ProvidesHandlers i k a | i -> k a
getHandlers :: ProvidesHandlers i k a => i -> Handlers k a
setHandlers :: ProvidesHandlers i k a => Handlers k a -> i -> i
getHandler :: (Ord k, ProvidesHandlers i k a) => k -> Layer i a
addHandler :: (Ord k, ProvidesHandlers i k a) => k -> a -> Layer i ()
removeHandler :: (Ord k, ProvidesHandlers i k a) => k -> Layer i ()
instance BaseM (Layer i) (Layer i)
instance StateM (Layer i) i
instance MonadPlus (Layer i)
instance Monad (Layer i)
instance Alternative (Layer i)
instance Applicative (Layer i)
instance Functor (Layer i)
instance Monoid Action

module Hans.Address
class (Ord a, Serialize a) => Address a
addrSize :: Address a => a -> Word8
toBits :: Address a => a -> [Bool]
class Address addr => Mask mask addr | addr -> mask, mask -> addr
masksAddress :: Mask mask addr => mask -> addr -> Bool
withMask :: Mask mask addr => addr -> Int -> mask
getMaskComponents :: Mask mask addr => mask -> (addr, Int)
getMaskRange :: Mask mask addr => mask -> (addr, addr)
broadcastAddress :: Mask mask addr => mask -> addr
isBroadcast :: (Eq addr, Mask mask addr) => mask -> addr -> Bool

module Hans.Address.IP4
data IP4
IP4 :: {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> IP4
broadcastIP4 :: IP4
parseIP4 :: Get IP4
renderIP4 :: Putter IP4
convertToWord32 :: IP4 -> Word32
convertFromWord32 :: Word32 -> IP4
data IP4Mask
IP4Mask :: {-# UNPACK #-} !IP4 -> {-# UNPACK #-} !Word8 -> IP4Mask
modifyAsWord32 :: Endo Word32 -> Endo IP4
clearHostBits :: IP4Mask -> IP4
setHostBits :: IP4Mask -> IP4
instance Typeable IP4
instance Typeable IP4Mask
instance Ord IP4
instance Eq IP4
instance Data IP4
instance Generic IP4
instance Eq IP4Mask
instance Ord IP4Mask
instance Data IP4Mask
instance Show IP4Mask
instance Datatype D1IP4
instance Constructor C1_0IP4
instance Mask IP4Mask IP4
instance Read IP4Mask
instance Serialize IP4Mask
instance Read IP4
instance Show IP4
instance Serialize IP4
instance Address IP4

module Hans.Message.Ip4

-- | source address | +--------+--------+--------+--------+ | destination
--   address | +--------+--------+--------+--------+ | zero |protocol|
--   length | +--------+--------+--------+--------+
mkIP4PseudoHeader :: IP4 -> IP4 -> IP4Protocol -> MkPseudoHeader
newtype Ident
Ident :: Word16 -> Ident
getIdent :: Ident -> Word16
newtype IP4Protocol
IP4Protocol :: Word8 -> IP4Protocol
getIP4Protocol :: IP4Protocol -> Word8
data IP4Header
IP4Header :: !Word8 -> !Word8 -> !Ident -> Bool -> Bool -> !Word16 -> !Word8 -> !IP4Protocol -> !Word16 -> !IP4 -> !IP4 -> [IP4Option] -> IP4Header
ip4Version :: IP4Header -> !Word8
ip4TypeOfService :: IP4Header -> !Word8
ip4Ident :: IP4Header -> !Ident
ip4DontFragment :: IP4Header -> Bool
ip4MoreFragments :: IP4Header -> Bool
ip4FragmentOffset :: IP4Header -> !Word16
ip4TimeToLive :: IP4Header -> !Word8
ip4Protocol :: IP4Header -> !IP4Protocol
ip4Checksum :: IP4Header -> !Word16
ip4SourceAddr :: IP4Header -> !IP4
ip4DestAddr :: IP4Header -> !IP4
ip4Options :: IP4Header -> [IP4Option]
emptyIP4Header :: IP4Header
noMoreFragments :: IP4Header -> IP4Header
moreFragments :: IP4Header -> IP4Header
addOffset :: Word16 -> IP4Header -> IP4Header
setIdent :: Ident -> IP4Header -> IP4Header

-- | Calculate the size of an IP4 packet
ip4PacketSize :: IP4Header -> ByteString -> Int

-- | Calculate the size of an IP4 header
ip4HeaderSize :: IP4Header -> Int

-- | Fragment a single IP packet into one or more, given an MTU to fit
--   into.
splitPacket :: Int -> IP4Header -> ByteString -> [(IP4Header, ByteString)]

-- | Given a fragment size and a packet, fragment the packet into multiple
--   smaller ones.
fragmentPacket :: Int64 -> IP4Header -> ByteString -> [(IP4Header, ByteString)]

-- | Version| IHL |Type of Service| Total Length |
--   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
--   Identification |Flags| Fragment Offset |
--   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
--   Time to Live | Protocol | Header Checksum |
--   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
--   Source Address |
--   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
--   Destination Address |
--   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
getIP4Packet :: Get (IP4Header, Int, Int)
parseIP4Packet :: ByteString -> Either String (IP4Header, Int, Int)
renderIP4Header :: IP4Header -> Int -> ByteString
putIP4Header :: IP4Header -> Int -> Put

-- | The final step to render an IP header and its payload out as a
--   bytestring.
renderIP4Packet :: IP4Header -> ByteString -> IO ByteString
renderOptions :: [IP4Option] -> (ByteString, Word8)
getOptions :: Int -> Get [IP4Option]
data IP4Option
IP4Option :: !Bool -> !Word8 -> !Word8 -> ByteString -> IP4Option
ip4OptionCopied :: IP4Option -> !Bool
ip4OptionClass :: IP4Option -> !Word8
ip4OptionNum :: IP4Option -> !Word8
ip4OptionData :: IP4Option -> ByteString
ip4OptionSize :: IP4Option -> Int
instance Eq Ident
instance Ord Ident
instance Num Ident
instance Show Ident
instance Serialize Ident
instance Integral Ident
instance Real Ident
instance Enum Ident
instance Eq IP4Protocol
instance Ord IP4Protocol
instance Num IP4Protocol
instance Show IP4Protocol
instance Serialize IP4Protocol
instance Eq IP4Option
instance Show IP4Option
instance Eq IP4Header
instance Show IP4Header
instance Serialize IP4Option

module Hans.Message.Udp
udpProtocol :: IP4Protocol
newtype UdpPort
UdpPort :: Word16 -> UdpPort
getUdpPort :: UdpPort -> Word16
parseUdpPort :: Get UdpPort
renderUdpPort :: Putter UdpPort
data UdpHeader
UdpHeader :: !UdpPort -> !UdpPort -> !Word16 -> UdpHeader
udpSourcePort :: UdpHeader -> !UdpPort
udpDestPort :: UdpHeader -> !UdpPort
udpChecksum :: UdpHeader -> !Word16
udpHeaderSize :: Int

-- | Parse out a <tt>UdpHeader</tt>, and the size of the payload.
parseUdpHeader :: Get (UdpHeader, Int)

-- | Render a <tt>UdpHeader</tt>.
renderUdpHeader :: UdpHeader -> Int -> Put
parseUdpPacket :: Get (UdpHeader, ByteString)

-- | Given a way to make the pseudo header, render the UDP packet.
renderUdpPacket :: UdpHeader -> ByteString -> MkPseudoHeader -> IO ByteString

-- | Recreate the UDP checksum, given a rendered packet, and the source and
--   destination.
validateUdpChecksum :: IP4 -> IP4 -> ByteString -> Bool
instance Typeable UdpPort
instance Eq UdpPort
instance Ord UdpPort
instance Num UdpPort
instance Read UdpPort
instance Show UdpPort
instance Enum UdpPort
instance Bounded UdpPort
instance Eq UdpHeader
instance Show UdpHeader

module Hans.Message.Dns
data DNSPacket
DNSPacket :: DNSHeader -> [Query] -> [RR] -> [RR] -> [RR] -> DNSPacket
dnsHeader :: DNSPacket -> DNSHeader
dnsQuestions :: DNSPacket -> [Query]
dnsAnswers :: DNSPacket -> [RR]
dnsAuthorityRecords :: DNSPacket -> [RR]
dnsAdditionalRecords :: DNSPacket -> [RR]
data DNSHeader
DNSHeader :: !Word16 -> Bool -> OpCode -> Bool -> Bool -> Bool -> Bool -> RespCode -> DNSHeader
dnsId :: DNSHeader -> !Word16
dnsQuery :: DNSHeader -> Bool
dnsOpCode :: DNSHeader -> OpCode
dnsAA :: DNSHeader -> Bool
dnsTC :: DNSHeader -> Bool
dnsRD :: DNSHeader -> Bool
dnsRA :: DNSHeader -> Bool
dnsRC :: DNSHeader -> RespCode
data OpCode
OpQuery :: OpCode
OpIQuery :: OpCode
OpStatus :: OpCode
OpReserved :: !Word16 -> OpCode
data RespCode
RespNoError :: RespCode
RespFormatError :: RespCode
RespServerFailure :: RespCode
RespNameError :: RespCode
RespNotImplemented :: RespCode
RespRefused :: RespCode
RespReserved :: !Word16 -> RespCode
data Query
Query :: Name -> QType -> QClass -> Query
qName :: Query -> Name
qType :: Query -> QType
qClass :: Query -> QClass
data QClass
QClass :: Class -> QClass
QAnyClass :: QClass
data QType
QType :: Type -> QType
AFXR :: QType
MAILB :: QType
MAILA :: QType
QTAny :: QType
data RR
RR :: Name -> Class -> !Int32 -> RData -> RR
rrName :: RR -> Name
rrClass :: RR -> Class
rrTTL :: RR -> !Int32
rrRData :: RR -> RData
data Type
A :: Type
NS :: Type
MD :: Type
MF :: Type
CNAME :: Type
SOA :: Type
MB :: Type
MG :: Type
MR :: Type
NULL :: Type
PTR :: Type
HINFO :: Type
MINFO :: Type
MX :: Type
AAAA :: Type
data Class
IN :: Class
CS :: Class
CH :: Class
HS :: Class
data RData
RDA :: IP4 -> RData
RDNS :: Name -> RData
RDMD :: Name -> RData
RDMF :: Name -> RData
RDCNAME :: Name -> RData
RDSOA :: Name -> Name -> !Word32 -> !Int32 -> !Int32 -> !Int32 -> !Word32 -> RData
RDMB :: Name -> RData
RDMG :: Name -> RData
RDMR :: Name -> RData
RDPTR :: Name -> RData
RDHINFO :: ByteString -> ByteString -> RData
RDMINFO :: Name -> Name -> RData
RDMX :: !Word16 -> Name -> RData
RDNULL :: ByteString -> RData
RDUnknown :: Type -> ByteString -> RData
type Name = [ByteString]
parseDNSPacket :: ByteString -> Either String DNSPacket
getDNSPacket :: Get DNSPacket
renderDNSPacket :: DNSPacket -> ByteString
putDNSPacket :: Putter DNSPacket
instance Show OpCode
instance Eq RespCode
instance Show RespCode
instance Show DNSHeader
instance Show Type
instance Show QType
instance Show Class
instance Eq Class
instance Show QClass
instance Show Query
instance Show RData
instance Show RR
instance Show DNSPacket
instance Show RW
instance Show Label

module Hans.Message.Icmp4
data Icmp4Packet
EchoReply :: Identifier -> SequenceNumber -> ByteString -> Icmp4Packet
DestinationUnreachable :: DestinationUnreachableCode -> ByteString -> Icmp4Packet
SourceQuench :: ByteString -> Icmp4Packet
Redirect :: RedirectCode -> IP4 -> ByteString -> Icmp4Packet
Echo :: Identifier -> SequenceNumber -> ByteString -> Icmp4Packet
RouterAdvertisement :: Lifetime -> [RouterAddress] -> Icmp4Packet
RouterSolicitation :: Icmp4Packet
TimeExceeded :: TimeExceededCode -> ByteString -> Icmp4Packet
ParameterProblem :: Word8 -> ByteString -> Icmp4Packet
Timestamp :: Identifier -> SequenceNumber -> Word32 -> Word32 -> Word32 -> Icmp4Packet
TimestampReply :: Identifier -> SequenceNumber -> Word32 -> Word32 -> Word32 -> Icmp4Packet
Information :: Identifier -> SequenceNumber -> Icmp4Packet
InformationReply :: Identifier -> SequenceNumber -> Icmp4Packet
TraceRoute :: TraceRouteCode -> Identifier -> Word16 -> Word16 -> Word32 -> Word32 -> Icmp4Packet
AddressMask :: Identifier -> SequenceNumber -> Icmp4Packet
AddressMaskReply :: Identifier -> SequenceNumber -> Word32 -> Icmp4Packet
noCode :: String -> Get ()
parseIcmp4Packet :: ByteString -> Either String Icmp4Packet
getIcmp4Packet :: Get Icmp4Packet
renderIcmp4Packet :: Icmp4Packet -> ByteString
putIcmp4Packet :: Putter Icmp4Packet
data NoCode
NoCode :: NoCode
data DestinationUnreachableCode
NetUnreachable :: DestinationUnreachableCode
HostUnreachable :: DestinationUnreachableCode
ProtocolUnreachable :: DestinationUnreachableCode
PortUnreachable :: DestinationUnreachableCode
FragmentationUnreachable :: DestinationUnreachableCode
SourceRouteFailed :: DestinationUnreachableCode
DestinationNetworkUnknown :: DestinationUnreachableCode
DestinationHostUnknown :: DestinationUnreachableCode
SourceHostIsolatedError :: DestinationUnreachableCode
AdministrativelyProhibited :: DestinationUnreachableCode
HostAdministrativelyProhibited :: DestinationUnreachableCode
NetworkUnreachableForTOS :: DestinationUnreachableCode
HostUnreachableForTOS :: DestinationUnreachableCode
CommunicationAdministrativelyProhibited :: DestinationUnreachableCode
HostPrecedenceViolation :: DestinationUnreachableCode
PrecedenceCutoffInEffect :: DestinationUnreachableCode
data TimeExceededCode
TimeToLiveExceededInTransit :: TimeExceededCode
FragmentReassemblyTimeExceeded :: TimeExceededCode
data RedirectCode
RedirectForNetwork :: RedirectCode
RedirectForHost :: RedirectCode
RedirectForTypeOfServiceAndNetwork :: RedirectCode
RedirectForTypeOfServiceAndHost :: RedirectCode
data TraceRouteCode
TraceRouteForwarded :: TraceRouteCode
TraceRouteDiscarded :: TraceRouteCode
newtype PreferenceLevel
PreferenceLevel :: Int32 -> PreferenceLevel
data RouterAddress
RouterAddress :: IP4 -> PreferenceLevel -> RouterAddress
raAddr :: RouterAddress -> IP4
raPreferenceLevel :: RouterAddress -> PreferenceLevel
newtype Identifier
Identifier :: Word16 -> Identifier
newtype SequenceNumber
SequenceNumber :: Word16 -> SequenceNumber
getUntilDone :: Serialize a => Get [a]
instance Eq DestinationUnreachableCode
instance Show DestinationUnreachableCode
instance Eq TimeExceededCode
instance Show TimeExceededCode
instance Eq RedirectCode
instance Show RedirectCode
instance Eq TraceRouteCode
instance Show TraceRouteCode
instance Show PreferenceLevel
instance Eq PreferenceLevel
instance Ord PreferenceLevel
instance Num PreferenceLevel
instance Serialize PreferenceLevel
instance Eq RouterAddress
instance Show RouterAddress
instance Show Identifier
instance Eq Identifier
instance Ord Identifier
instance Num Identifier
instance Serialize Identifier
instance Show SequenceNumber
instance Eq SequenceNumber
instance Ord SequenceNumber
instance Num SequenceNumber
instance Serialize SequenceNumber
instance Eq Icmp4Packet
instance Show Icmp4Packet
instance Serialize RouterAddress
instance Serialize TraceRouteCode
instance Serialize RedirectCode
instance Serialize TimeExceededCode
instance Serialize DestinationUnreachableCode
instance Serialize NoCode

module Hans.Message.Tcp
tcpProtocol :: IP4Protocol
newtype TcpPort
TcpPort :: Word16 -> TcpPort
getPort :: TcpPort -> Word16
putTcpPort :: Putter TcpPort
getTcpPort :: Get TcpPort
newtype TcpSeqNum
TcpSeqNum :: Word32 -> TcpSeqNum
getSeqNum :: TcpSeqNum -> Word32
putTcpSeqNum :: Putter TcpSeqNum
getTcpSeqNum :: Get TcpSeqNum

-- | An alias to TcpSeqNum, as these two are used in the same role.
type TcpAckNum = TcpSeqNum
putTcpAckNum :: Putter TcpAckNum
getTcpAckNum :: Get TcpAckNum
data TcpHeader
TcpHeader :: !TcpPort -> !TcpPort -> !TcpSeqNum -> !TcpAckNum -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Word16 -> !Word16 -> !Word16 -> [TcpOption] -> TcpHeader
tcpSourcePort :: TcpHeader -> !TcpPort
tcpDestPort :: TcpHeader -> !TcpPort
tcpSeqNum :: TcpHeader -> !TcpSeqNum
tcpAckNum :: TcpHeader -> !TcpAckNum
tcpCwr :: TcpHeader -> !Bool
tcpEce :: TcpHeader -> !Bool
tcpUrg :: TcpHeader -> !Bool
tcpAck :: TcpHeader -> !Bool
tcpPsh :: TcpHeader -> !Bool
tcpRst :: TcpHeader -> !Bool
tcpSyn :: TcpHeader -> !Bool
tcpFin :: TcpHeader -> !Bool
tcpWindow :: TcpHeader -> !Word16
tcpChecksum :: TcpHeader -> !Word16
tcpUrgentPointer :: TcpHeader -> !Word16
tcpOptions :: TcpHeader -> [TcpOption]
emptyTcpHeader :: TcpHeader

-- | The length of the fixed part of the TcpHeader, in 4-byte octets.
tcpFixedHeaderLength :: Int

-- | Render a TcpHeader. The checksum value is never rendered, as it is
--   expected to be calculated and poked in afterwords.
putTcpHeader :: Putter TcpHeader

-- | Parse out a TcpHeader, and its length. The resulting length is in
--   bytes, and is derived from the data offset.
getTcpHeader :: Get (TcpHeader, Int)

-- | Render out the <tt>Word8</tt> that contains the Control field of the
--   TcpHeader.
putTcpControl :: Putter TcpHeader

-- | Parse out the control flags from the octet that contains them.
setTcpControl :: Word8 -> TcpHeader -> TcpHeader
class HasTcpOptions a
findTcpOption :: HasTcpOptions a => TcpOptionTag -> a -> Maybe TcpOption
setTcpOption :: HasTcpOptions a => TcpOption -> a -> a
setTcpOptions :: HasTcpOptions a => [TcpOption] -> a -> a
data TcpOptionTag
OptTagEndOfOptions :: TcpOptionTag
OptTagNoOption :: TcpOptionTag
OptTagMaxSegmentSize :: TcpOptionTag
OptTagWindowScaling :: TcpOptionTag
OptTagSackPermitted :: TcpOptionTag
OptTagSack :: TcpOptionTag
OptTagTimestamp :: TcpOptionTag
OptTagUnknown :: !Word8 -> TcpOptionTag
getTcpOptionTag :: Get TcpOptionTag
putTcpOptionTag :: Putter TcpOptionTag
data TcpOption
OptEndOfOptions :: TcpOption
OptNoOption :: TcpOption
OptMaxSegmentSize :: !Word16 -> TcpOption
OptWindowScaling :: !Word8 -> TcpOption
OptSackPermitted :: TcpOption
OptSack :: [SackBlock] -> TcpOption
OptTimestamp :: !Word32 -> !Word32 -> TcpOption
OptUnknown :: !Word8 -> !Word8 -> !ByteString -> TcpOption
data SackBlock
SackBlock :: !TcpSeqNum -> !TcpSeqNum -> SackBlock
sbLeft :: SackBlock -> !TcpSeqNum
sbRight :: SackBlock -> !TcpSeqNum
tcpOptionTag :: TcpOption -> TcpOptionTag

-- | Get the rendered length of a list of TcpOptions, in 4-byte words, and
--   the number of padding bytes required. This rounds up to the nearest
--   4-byte word.
tcpOptionsLength :: [TcpOption] -> (Int, Int)
tcpOptionLength :: TcpOption -> Int
putTcpOption :: Putter TcpOption

-- | Parse in known tcp options.
getTcpOptions :: Get [TcpOption]
getTcpOption :: Get TcpOption
getMaxSegmentSize :: Get TcpOption
putMaxSegmentSize :: Putter Word16
getSackPermitted :: Get TcpOption
putSackPermitted :: Put
getSack :: Get TcpOption
putSack :: Putter [SackBlock]
getSackBlock :: Get SackBlock
putSackBlock :: Putter SackBlock
sackLength :: [SackBlock] -> Int
getWindowScaling :: Get TcpOption
putWindowScaling :: Putter Word8
getTimestamp :: Get TcpOption
putTimestamp :: Word32 -> Word32 -> Put
getUnknown :: Word8 -> Get TcpOption
putUnknown :: Word8 -> ByteString -> Put
parseTcpPacket :: ByteString -> Either String (TcpHeader, ByteString)

-- | Parse a TcpPacket.
getTcpPacket :: Get (TcpHeader, ByteString)

-- | Render out a TcpPacket, without calculating its checksum.
putTcpPacket :: TcpHeader -> ByteString -> Put

-- | Calculate the checksum of a TcpHeader, and its body.
renderWithTcpChecksumIP4 :: IP4 -> IP4 -> TcpHeader -> ByteString -> ByteString

-- | Calculate the checksum of a tcp packet, and return its rendered
--   header.
computeTcpChecksumIP4 :: IP4 -> IP4 -> TcpHeader -> ByteString -> (ByteString, Word16)

-- | Re-create the checksum, minimizing duplication of the original,
--   rendered TCP packet.
validateTcpChecksumIP4 :: IP4 -> IP4 -> ByteString -> Bool
instance Eq TcpPort
instance Ord TcpPort
instance Read TcpPort
instance Show TcpPort
instance Num TcpPort
instance Enum TcpPort
instance Bounded TcpPort
instance Eq TcpSeqNum
instance Ord TcpSeqNum
instance Show TcpSeqNum
instance Num TcpSeqNum
instance Bounded TcpSeqNum
instance Enum TcpSeqNum
instance Real TcpSeqNum
instance Integral TcpSeqNum
instance Eq TcpOptionTag
instance Show TcpOptionTag
instance Show SackBlock
instance Eq SackBlock
instance Show TcpOption
instance Eq TcpOption
instance Eq TcpHeader
instance Show TcpHeader
instance HasTcpOptions [TcpOption]
instance HasTcpOptions TcpHeader
instance Monoid TcpSeqNum

module Hans.Layer.Tcp.Window

-- | Remote window management.
data RemoteWindow
RemoteWindow :: OutSegments -> !Word32 -> !Word32 -> !Word16 -> !Int -> RemoteWindow
rwSegments :: RemoteWindow -> OutSegments
rwAvailable :: RemoteWindow -> !Word32
rwSize :: RemoteWindow -> !Word32
rwSndWind :: RemoteWindow -> !Word16
rwSndWindScale :: RemoteWindow -> !Int

-- | The empty window, seeded with an initial size.
emptyRemoteWindow :: Word16 -> Int -> RemoteWindow

-- | Recalculate internal constants of the remote window.
refreshRemoteWindow :: RemoteWindow -> RemoteWindow

-- | Set the Snd.Wind.Scale variable for the remote window.
setSndWindScale :: Int -> RemoteWindow -> RemoteWindow

-- | Set the Snd.Wind variable for the remote window.
setSndWind :: Word16 -> RemoteWindow -> RemoteWindow

-- | Adjust the internal available counter.
releaseSpace :: Word32 -> RemoteWindow -> RemoteWindow

-- | Add a segment to the window.
addSegment :: OutSegment -> RemoteWindow -> RemoteWindow

-- | Process an incoming ack, returning a finalizer, and a new window if
--   there was a matching set of packets waiting for an ack.
receiveAck :: TcpHeader -> RemoteWindow -> Maybe (OutSegment, RemoteWindow)

-- | Update the RTO timer on all segments waiting for an ack. When the
--   timer runs out, output the segment for retransmission.
genRetransmitSegments :: RemoteWindow -> (OutSegments, RemoteWindow)
clearRetransmit :: RemoteWindow -> RemoteWindow
retransmitEmpty :: RemoteWindow -> Bool
type OutSegments = Seq OutSegment

-- | A delivered segment.
data OutSegment
OutSegment :: !TcpSeqNum -> !POSIXTime -> Bool -> !Int -> !TcpHeader -> !ByteString -> OutSegment
outAckNum :: OutSegment -> !TcpSeqNum
outTime :: OutSegment -> !POSIXTime

-- | Whether or not this is a retransmission
outFresh :: OutSegment -> Bool

-- | Retransmit timer for this segment
outRTO :: OutSegment -> !Int
outHeader :: OutSegment -> !TcpHeader
outBody :: OutSegment -> !ByteString
mkOutSegment :: POSIXTime -> Int -> TcpHeader -> ByteString -> OutSegment
ctlLength :: Num len => Bool -> len
outSize :: Num a => OutSegment -> a

-- | The size of a segment body.
outSize' :: Num a => TcpHeader -> ByteString -> a

-- | Decrement the RTO value on a segment by the timer granularity (500ms).
--   Once the RTO value dips below 1, mark the segment as no longer fresh.
decrementRTO :: OutSegment -> OutSegment

-- | Local window, containing a buffer of incoming packets, indexed by
--   their sequence number, relative to RCV.NXT.
--   
--   XXX make this respect the values of size and available
data LocalWindow
LocalWindow :: Seq InSegment -> !TcpSeqNum -> !Word32 -> !Word32 -> !Word16 -> !Int -> LocalWindow
lwBuffer :: LocalWindow -> Seq InSegment
lwRcvNxt :: LocalWindow -> !TcpSeqNum
lwAvailable :: LocalWindow -> !Word32
lwSize :: LocalWindow -> !Word32
lwRcvWind :: LocalWindow -> !Word16
lwRcvWindScale :: LocalWindow -> !Int

-- | Empty local buffer, with an initial sequence number as the next
--   expected sequence number.
emptyLocalWindow :: TcpSeqNum -> Word16 -> Int -> LocalWindow

-- | Produce a sequence of blocks for the sack option.
localWindowSackBlocks :: LocalWindow -> Seq SackBlock

-- | Recalculate internal constants.
refreshLocalWindow :: LocalWindow -> LocalWindow

-- | Update the size of the remote window.
setRcvNxt :: TcpSeqNum -> LocalWindow -> LocalWindow

-- | Add a sequence number to the value of Rcv.Nxt.
addRcvNxt :: TcpSeqNum -> LocalWindow -> LocalWindow

-- | Set the Rcv.Wind variable for the local window.
setRcvWind :: Word16 -> LocalWindow -> LocalWindow

-- | Set the Rcv.Wind.Scale variable in the local window.
setRcvWindScale :: Int -> LocalWindow -> LocalWindow

-- | Process an incoming packet that needs to pass through the incoming
--   queue.
incomingPacket :: TcpHeader -> ByteString -> LocalWindow -> (Seq InSegment, LocalWindow)

-- | Queue an incoming packet in the incoming window.
addInSegment :: TcpHeader -> ByteString -> LocalWindow -> LocalWindow

-- | Advance the window, if there are packets available to be returned.
stepWindow :: LocalWindow -> (Seq InSegment, LocalWindow)
data InSegment
InSegment :: !TcpSeqNum -> !TcpHeader -> !ByteString -> InSegment
inRelSeqNum :: InSegment -> !TcpSeqNum
inHeader :: InSegment -> !TcpHeader
inBody :: InSegment -> !ByteString
inSeqNum :: InSegment -> TcpSeqNum
inLength :: Num a => InSegment -> a

-- | Generate an incoming segment, relative to the value of RCV.NXT
mkInSegment :: TcpSeqNum -> TcpHeader -> ByteString -> InSegment
mkSackBlock :: InSegment -> SackBlock
instance Show OutSegment
instance Show RemoteWindow
instance Show InSegment
instance Show LocalWindow

module Hans.Layer.Tcp.Types
data Host
Host :: Connections -> TimeWaitConnections -> !TcpSeqNum -> !(PortManager TcpPort) -> POSIXTime -> Host
hostConnections :: Host -> Connections
hostTimeWaits :: Host -> TimeWaitConnections
hostInitialSeqNum :: Host -> !TcpSeqNum
hostPorts :: Host -> !(PortManager TcpPort)
hostLastUpdate :: Host -> POSIXTime
emptyHost :: POSIXTime -> Host
takePort :: Host -> Maybe (TcpPort, Host)
releasePort :: TcpPort -> Host -> Host
type Connections = Map SocketId TcpSocket
removeClosed :: Connections -> Connections
data SocketId
SocketId :: !TcpPort -> !TcpPort -> !IP4 -> SocketId
sidLocalPort :: SocketId -> !TcpPort
sidRemotePort :: SocketId -> !TcpPort
sidRemoteHost :: SocketId -> !IP4
emptySocketId :: SocketId
listenSocketId :: TcpPort -> SocketId
incomingSocketId :: IP4 -> TcpHeader -> SocketId
data SocketResult a
SocketResult :: a -> SocketResult a
SocketError :: SomeException -> SocketResult a
socketError :: Exception e => e -> SocketResult a

-- | The socket that's in TimeWait, plus its current 2MSL value.
type TimeWaitConnections = Map SocketId TimeWaitSock
data TimeWaitSock
TimeWaitSock :: !SlowTicks -> !SlowTicks -> !TcpSeqNum -> Maybe Timestamp -> TimeWaitSock

-- | The current 2MSL value
tw2MSL :: TimeWaitSock -> !SlowTicks

-- | The initial 2MSL value
twInit2MSL :: TimeWaitSock -> !SlowTicks

-- | The sequence number to use when responding to messages
twSeqNum :: TimeWaitSock -> !TcpSeqNum

-- | The last timestamp used
twTimestamp :: TimeWaitSock -> Maybe Timestamp
twReset2MSL :: TimeWaitSock -> TimeWaitSock
mkTimeWait :: TcpSocket -> TimeWaitSock

-- | Add a socket to the TimeWait map.
addTimeWait :: TcpSocket -> TimeWaitConnections -> TimeWaitConnections

-- | Take one step, collecting any connections whose 2MSL timer goes to 0.
stepTimeWaitConnections :: TimeWaitConnections -> TimeWaitConnections
type SlowTicks = Int

-- | MSL is 60 seconds, which is slightly more aggressive than the 2
--   minutes from the original RFC.
mslTimeout :: SlowTicks
data TcpTimers
TcpTimers :: !Bool -> !SlowTicks -> !SlowTicks -> !POSIXTime -> !POSIXTime -> !SlowTicks -> !SlowTicks -> TcpTimers
ttDelayedAck :: TcpTimers -> !Bool
tt2MSL :: TcpTimers -> !SlowTicks
ttRTO :: TcpTimers -> !SlowTicks
ttSRTT :: TcpTimers -> !POSIXTime
ttRTTVar :: TcpTimers -> !POSIXTime
ttMaxIdle :: TcpTimers -> !SlowTicks
ttIdle :: TcpTimers -> !SlowTicks
emptyTcpTimers :: TcpTimers

-- | Manage the timestamp values that are in flight between two hosts.
data Timestamp
Timestamp :: !Word32 -> !Word32 -> !POSIXTime -> !POSIXTime -> Timestamp
tsTimestamp :: Timestamp -> !Word32
tsLastTimestamp :: Timestamp -> !Word32

-- | Hz
tsGranularity :: Timestamp -> !POSIXTime
tsLastUpdate :: Timestamp -> !POSIXTime
emptyTimestamp :: POSIXTime -> Timestamp

-- | Update the timestamp value, advancing based on the timestamp
--   granularity. If the number of ticks to advance is 0, don't advance the
--   timestamp.
stepTimestamp :: POSIXTime -> Timestamp -> Timestamp

-- | Generate timestamp option for an outgoing packet.
mkTimestamp :: Timestamp -> TcpOption
type Acceptor = SocketId -> IO ()
type Notify = Bool -> IO ()
type Close = IO ()
data TcpSocket
TcpSocket :: Maybe SocketId -> !SocketId -> !ConnState -> Seq Acceptor -> Maybe Notify -> !TcpSeqNum -> !TcpSeqNum -> !TcpSeqNum -> Bool -> RemoteWindow -> Buffer Outgoing -> !Int64 -> LocalWindow -> Buffer Incoming -> !Int64 -> !TcpTimers -> Maybe Timestamp -> Bool -> Bool -> TcpSocket
tcpParent :: TcpSocket -> Maybe SocketId
tcpSocketId :: TcpSocket -> !SocketId
tcpState :: TcpSocket -> !ConnState
tcpAcceptors :: TcpSocket -> Seq Acceptor
tcpNotify :: TcpSocket -> Maybe Notify
tcpIss :: TcpSocket -> !TcpSeqNum
tcpSndNxt :: TcpSocket -> !TcpSeqNum
tcpSndUna :: TcpSocket -> !TcpSeqNum
tcpUserClosed :: TcpSocket -> Bool
tcpOut :: TcpSocket -> RemoteWindow
tcpOutBuffer :: TcpSocket -> Buffer Outgoing
tcpOutMSS :: TcpSocket -> !Int64
tcpIn :: TcpSocket -> LocalWindow
tcpInBuffer :: TcpSocket -> Buffer Incoming
tcpInMSS :: TcpSocket -> !Int64
tcpTimers :: TcpSocket -> !TcpTimers
tcpTimestamp :: TcpSocket -> Maybe Timestamp
tcpSack :: TcpSocket -> Bool
tcpWindowScale :: TcpSocket -> Bool
emptyTcpSocket :: Word16 -> Int -> TcpSocket
defaultMSS :: Int64
nothingOutstanding :: TcpSocket -> Bool
tcpRcvNxt :: TcpSocket -> TcpSeqNum
inRcvWnd :: TcpSeqNum -> TcpSocket -> Bool
nextSegSize :: TcpSocket -> Int64
isAccepting :: TcpSocket -> Bool
needsDelayedAck :: TcpSocket -> Bool
mkMSS :: TcpSocket -> TcpOption
data ConnState
Closed :: ConnState
Listen :: ConnState
SynSent :: ConnState
SynReceived :: ConnState
Established :: ConnState
CloseWait :: ConnState
FinWait1 :: ConnState
FinWait2 :: ConnState
Closing :: ConnState
LastAck :: ConnState
TimeWait :: ConnState
instance Eq SocketId
instance Show SocketId
instance Ord SocketId
instance Show a => Show (SocketResult a)
instance Show Timestamp
instance Show TimeWaitSock
instance Show ConnState
instance Eq ConnState
instance Ord ConnState

module Hans.Simple

-- | Render a UDP message to an unfragmented IP4 packet.
renderUdp :: Ident -> Maybe MTU -> IP4 -> IP4 -> UdpPort -> UdpPort -> ByteString -> IO [ByteString]

-- | Render an IP4 packet.
renderIp4 :: Ident -> Maybe MTU -> IP4Protocol -> IP4 -> IP4 -> ByteString -> IO [ByteString]
data Ident
newIdent :: IO Ident
nextIdent :: Ident -> IO Ident

module Hans.Address.Mac

-- | Mac addresses.
data Mac
Mac :: {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> Mac
parseMac :: Get Mac
renderMac :: Putter Mac

-- | The broadcast mac address.
broadcastMac :: Mac

-- | Show a Mac address.
showsMac :: Mac -> ShowS

-- | Generates a mask tailored to the given MAC address.
macMask :: Mac -> Mac
instance Eq Mac
instance Ord Mac
instance Generic Mac
instance Datatype D1Mac
instance Constructor C1_0Mac
instance Serialize Mac
instance Address Mac
instance Read Mac
instance Show Mac

module Hans.Message.EthernetFrame
newtype EtherType
EtherType :: Word16 -> EtherType
getEtherType :: EtherType -> Word16
parseEtherType :: Get EtherType
renderEtherType :: Putter EtherType
data EthernetFrame
EthernetFrame :: !Mac -> !Mac -> !EtherType -> EthernetFrame
etherDest :: EthernetFrame -> !Mac
etherSource :: EthernetFrame -> !Mac
etherType :: EthernetFrame -> !EtherType
parseEthernetFrame :: ByteString -> Either String (EthernetFrame, ByteString)
renderEthernetFrame :: EthernetFrame -> ByteString -> ByteString
instance Eq EtherType
instance Num EtherType
instance Ord EtherType
instance Eq EthernetFrame
instance Show EthernetFrame
instance Show EtherType

module Hans.Layer.Ethernet
type EthernetHandle = Channel (Eth ())

-- | Run the ethernet layer.
runEthernetLayer :: EthernetHandle -> IO ()
type Tx = ByteString -> IO ()
type Rx = EthernetHandle -> IO ()
sendEthernet :: EthernetHandle -> EthernetFrame -> ByteString -> IO ()
queueEthernet :: EthernetHandle -> ByteString -> IO ()
addEthernetDevice :: EthernetHandle -> Mac -> Tx -> Rx -> IO ()
removeEthernetDevice :: EthernetHandle -> Mac -> IO ()
addEthernetHandler :: EthernetHandle -> EtherType -> Handler -> IO ()
removeEthernetHandler :: EthernetHandle -> EtherType -> IO ()
startEthernetDevice :: EthernetHandle -> Mac -> IO ()
stopEthernetDevice :: EthernetHandle -> Mac -> IO ()
instance ProvidesHandlers EthernetState EtherType Handler

module Hans.Device.Tap

-- | Open a device by name.
openTapDevice :: DeviceName -> IO (Maybe Fd)

-- | Send an ethernet frame via a tap device.
--   
--   TODO: make more use of the lazy bytestring
tapSend :: Fd -> ByteString -> IO ()

-- | Fork a reciever loop, and return an IO action to kill the running
--   thread.
tapReceiveLoop :: Fd -> EthernetHandle -> IO ()

-- | Recieve an ethernet frame from a tap device.
tapReceive :: Fd -> IO ByteString
c_read' :: Fd -> Ptr Word8 -> CSize -> IO CLong
c_init_tap_device :: CString -> IO Fd
c_write :: Fd -> Ptr Word8 -> CSize -> IO CLong
c_read :: Fd -> Ptr Word8 -> CSize -> IO CLong

module Hans.Layer.Arp.Table
arpEntryTimeout :: POSIXTime
data ArpEntry
ArpEntry :: Mac -> POSIXTime -> ArpEntry
arpMac :: ArpEntry -> Mac
arpTimeout :: ArpEntry -> POSIXTime
ArpPending :: POSIXTime -> ArpEntry
arpTimeout :: ArpEntry -> POSIXTime
data ArpResult
KnownAddress :: Mac -> ArpResult
Pending :: ArpResult
Unknown :: ArpResult
type ArpTable = Map IP4 ArpEntry
stepArpTable :: POSIXTime -> ArpTable -> (ArpTable, [IP4])
addArpEntry :: POSIXTime -> IP4 -> Mac -> ArpTable -> ArpTable

-- | Assumption: there is not already a pending ARP query recorded in the
--   ARP table for the given IP address.
addPending :: POSIXTime -> IP4 -> ArpTable -> ArpTable

-- | If the ARP table has a fully realized entry for the given IP address,
--   then return it. Otherwise return Pending if we're waiting for this
--   info, or Unknown if nothing is currently known about it.
lookupArpEntry :: IP4 -> ArpTable -> ArpResult
instance Show ArpEntry

module Hans.Message.Dhcp4Codec
class CodecAtom a
getAtom :: CodecAtom a => Get a
putAtom :: CodecAtom a => a -> Put
atomSize :: CodecAtom a => a -> Int
newtype SubnetMask
SubnetMask :: Int -> SubnetMask
unmask :: SubnetMask -> Int
word32ToSubnetMask :: Word32 -> Maybe SubnetMask
subnetMaskToWord32 :: SubnetMask -> Word32
computeMask :: Int -> Word32
instance Show SubnetMask
instance Eq SubnetMask
instance CodecAtom SubnetMask
instance CodecAtom Mac
instance CodecAtom IP4Mask
instance CodecAtom IP4
instance CodecAtom Bool
instance CodecAtom Word32
instance CodecAtom Word16
instance CodecAtom Word8
instance (CodecAtom a, CodecAtom b) => CodecAtom (a, b)

module Hans.Message.Dhcp4Options
data MagicCookie
MagicCookie :: MagicCookie
dhcp4MagicCookie :: Word32
data Dhcp4Option
OptSubnetMask :: SubnetMask -> Dhcp4Option
OptTimeOffset :: Word32 -> Dhcp4Option
OptRouters :: [IP4] -> Dhcp4Option
OptTimeServers :: [IP4] -> Dhcp4Option
OptIEN116NameServers :: [IP4] -> Dhcp4Option
OptNameServers :: [IP4] -> Dhcp4Option
OptLogServers :: [IP4] -> Dhcp4Option
OptCookieServers :: [IP4] -> Dhcp4Option
OptLPRServers :: [IP4] -> Dhcp4Option
OptImpressServers :: [IP4] -> Dhcp4Option
OptResourceLocationServers :: [IP4] -> Dhcp4Option
OptHostName :: NVTAsciiString -> Dhcp4Option
OptBootFileSize :: Word16 -> Dhcp4Option
OptMeritDumpFile :: NVTAsciiString -> Dhcp4Option
OptDomainName :: NVTAsciiString -> Dhcp4Option
OptSwapServer :: IP4 -> Dhcp4Option
OptRootPath :: NVTAsciiString -> Dhcp4Option
OptExtensionsPath :: NVTAsciiString -> Dhcp4Option
OptEnableIPForwarding :: Bool -> Dhcp4Option
OptEnableNonLocalSourceRouting :: Bool -> Dhcp4Option
OptPolicyFilters :: [IP4Mask] -> Dhcp4Option
OptMaximumDatagramReassemblySize :: Word16 -> Dhcp4Option
OptDefaultTTL :: Word8 -> Dhcp4Option
OptPathMTUAgingTimeout :: Word32 -> Dhcp4Option
OptPathMTUPlateauTable :: [Word16] -> Dhcp4Option
OptInterfaceMTU :: Word16 -> Dhcp4Option
OptAllSubnetsAreLocal :: Bool -> Dhcp4Option
OptBroadcastAddress :: IP4 -> Dhcp4Option
OptPerformMaskDiscovery :: Bool -> Dhcp4Option
OptShouldSupplyMasks :: Bool -> Dhcp4Option
OptShouldPerformRouterDiscovery :: Bool -> Dhcp4Option
OptRouterSolicitationAddress :: IP4 -> Dhcp4Option
OptStaticRoutes :: [(IP4, IP4)] -> Dhcp4Option
OptShouldNegotiateArpTrailers :: Bool -> Dhcp4Option
OptArpCacheTimeout :: Word32 -> Dhcp4Option
OptUseRFC1042EthernetEncapsulation :: Bool -> Dhcp4Option
OptTcpDefaultTTL :: Word8 -> Dhcp4Option
OptTcpKeepaliveInterval :: Word32 -> Dhcp4Option
OptTcpKeepaliveUseGarbage :: Bool -> Dhcp4Option
OptNisDomainName :: NVTAsciiString -> Dhcp4Option
OptNisServers :: [IP4] -> Dhcp4Option
OptNtpServers :: [IP4] -> Dhcp4Option
OptVendorSpecific :: ByteString -> Dhcp4Option
OptNetBiosNameServers :: [IP4] -> Dhcp4Option
OptNetBiosDistributionServers :: [IP4] -> Dhcp4Option
OptNetBiosNodeType :: NetBiosNodeType -> Dhcp4Option
OptNetBiosScope :: NVTAsciiString -> Dhcp4Option
OptXWindowsFontServer :: [IP4] -> Dhcp4Option
OptXWindowsDisplayManagers :: [IP4] -> Dhcp4Option
OptNisPlusDomain :: NVTAsciiString -> Dhcp4Option
OptNisPlusServers :: [IP4] -> Dhcp4Option
OptSmtpServers :: [IP4] -> Dhcp4Option
OptPopServers :: [IP4] -> Dhcp4Option
OptNntpServers :: [IP4] -> Dhcp4Option
OptWwwServers :: [IP4] -> Dhcp4Option
OptFingerServers :: [IP4] -> Dhcp4Option
OptIrcServers :: [IP4] -> Dhcp4Option
OptStreetTalkServers :: [IP4] -> Dhcp4Option
OptStreetTalkDirectoryAssistanceServers :: [IP4] -> Dhcp4Option
OptFQDN :: NVTAsciiString -> Dhcp4Option
OptRequestIPAddress :: IP4 -> Dhcp4Option
OptIPAddressLeaseTime :: Word32 -> Dhcp4Option
OptOverload :: OverloadOption -> Dhcp4Option
OptTftpServer :: NVTAsciiString -> Dhcp4Option
OptBootfileName :: NVTAsciiString -> Dhcp4Option
OptMessageType :: Dhcp4MessageType -> Dhcp4Option
OptServerIdentifier :: IP4 -> Dhcp4Option
OptParameterRequestList :: [OptionTagOrError] -> Dhcp4Option
OptErrorMessage :: NVTAsciiString -> Dhcp4Option
OptMaxDHCPMessageSize :: Word16 -> Dhcp4Option
OptRenewalTime :: Word32 -> Dhcp4Option
OptRebindingTime :: Word32 -> Dhcp4Option
OptVendorClass :: NVTAsciiString -> Dhcp4Option
OptClientIdentifier :: ByteString -> Dhcp4Option
OptNetWareDomainName :: NVTAsciiString -> Dhcp4Option
OptNetWareInfo :: ByteString -> Dhcp4Option
OptAutoconfiguration :: Bool -> Dhcp4Option
getDhcp4Option :: Get (Either ControlTag Dhcp4Option)
putDhcp4Option :: Dhcp4Option -> Put
data Dhcp4MessageType
Dhcp4Discover :: Dhcp4MessageType
Dhcp4Offer :: Dhcp4MessageType
Dhcp4Request :: Dhcp4MessageType
Dhcp4Decline :: Dhcp4MessageType
Dhcp4Ack :: Dhcp4MessageType
Dhcp4Nak :: Dhcp4MessageType
Dhcp4Release :: Dhcp4MessageType
Dhcp4Inform :: Dhcp4MessageType
data ControlTag
ControlPad :: ControlTag
ControlEnd :: ControlTag
putControlOption :: ControlTag -> Put
data Dhcp4OptionTag
OptTagPad :: Dhcp4OptionTag
OptTagEnd :: Dhcp4OptionTag
OptTagSubnetMask :: Dhcp4OptionTag
OptTagTimeOffset :: Dhcp4OptionTag
OptTagRouters :: Dhcp4OptionTag
OptTagTimeServers :: Dhcp4OptionTag
OptTagIEN116NameServers :: Dhcp4OptionTag
OptTagNameServers :: Dhcp4OptionTag
OptTagLogServers :: Dhcp4OptionTag
OptTagCookieServers :: Dhcp4OptionTag
OptTagLPRServers :: Dhcp4OptionTag
OptTagImpressServers :: Dhcp4OptionTag
OptTagResourceLocationServers :: Dhcp4OptionTag
OptTagHostName :: Dhcp4OptionTag
OptTagBootFileSize :: Dhcp4OptionTag
OptTagMeritDumpFile :: Dhcp4OptionTag
OptTagDomainName :: Dhcp4OptionTag
OptTagSwapServer :: Dhcp4OptionTag
OptTagRootPath :: Dhcp4OptionTag
OptTagExtensionsPath :: Dhcp4OptionTag
OptTagEnableIPForwarding :: Dhcp4OptionTag
OptTagEnableNonLocalSourceRouting :: Dhcp4OptionTag
OptTagPolicyFilters :: Dhcp4OptionTag
OptTagMaximumDatagramReassemblySize :: Dhcp4OptionTag
OptTagDefaultTTL :: Dhcp4OptionTag
OptTagPathMTUAgingTimeout :: Dhcp4OptionTag
OptTagPathMTUPlateauTable :: Dhcp4OptionTag
OptTagInterfaceMTU :: Dhcp4OptionTag
OptTagAllSubnetsAreLocal :: Dhcp4OptionTag
OptTagBroadcastAddress :: Dhcp4OptionTag
OptTagPerformMaskDiscovery :: Dhcp4OptionTag
OptTagShouldSupplyMasks :: Dhcp4OptionTag
OptTagShouldPerformRouterDiscovery :: Dhcp4OptionTag
OptTagRouterSolicitationAddress :: Dhcp4OptionTag
OptTagStaticRoutes :: Dhcp4OptionTag
OptTagShouldNegotiateArpTrailers :: Dhcp4OptionTag
OptTagArpCacheTimeout :: Dhcp4OptionTag
OptTagUseRFC1042EthernetEncapsulation :: Dhcp4OptionTag
OptTagTcpDefaultTTL :: Dhcp4OptionTag
OptTagTcpKeepaliveInterval :: Dhcp4OptionTag
OptTagTcpKeepaliveUseGarbage :: Dhcp4OptionTag
OptTagNisDomainName :: Dhcp4OptionTag
OptTagNisServers :: Dhcp4OptionTag
OptTagNtpServers :: Dhcp4OptionTag
OptTagVendorSpecific :: Dhcp4OptionTag
OptTagNetBiosNameServers :: Dhcp4OptionTag
OptTagNetBiosDistributionServers :: Dhcp4OptionTag
OptTagNetBiosNodeType :: Dhcp4OptionTag
OptTagNetBiosScope :: Dhcp4OptionTag
OptTagXWindowsFontServer :: Dhcp4OptionTag
OptTagXWindowsDisplayManagers :: Dhcp4OptionTag
OptTagNisPlusDomain :: Dhcp4OptionTag
OptTagNisPlusServers :: Dhcp4OptionTag
OptTagSmtpServers :: Dhcp4OptionTag
OptTagPopServers :: Dhcp4OptionTag
OptTagNntpServers :: Dhcp4OptionTag
OptTagWwwServers :: Dhcp4OptionTag
OptTagFingerServers :: Dhcp4OptionTag
OptTagIrcServers :: Dhcp4OptionTag
OptTagStreetTalkServers :: Dhcp4OptionTag
OptTagStreetTalkDirectoryAssistanceServers :: Dhcp4OptionTag
OptTagFQDN :: Dhcp4OptionTag
OptTagRequestIPAddress :: Dhcp4OptionTag
OptTagIPAddressLeaseTime :: Dhcp4OptionTag
OptTagOverload :: Dhcp4OptionTag
OptTagTftpServer :: Dhcp4OptionTag
OptTagBootfileName :: Dhcp4OptionTag
OptTagMessageType :: Dhcp4OptionTag
OptTagServerIdentifier :: Dhcp4OptionTag
OptTagParameterRequestList :: Dhcp4OptionTag
OptTagErrorMessage :: Dhcp4OptionTag
OptTagMaxDHCPMessageSize :: Dhcp4OptionTag
OptTagRenewalTime :: Dhcp4OptionTag
OptTagRebindingTime :: Dhcp4OptionTag
OptTagVendorClass :: Dhcp4OptionTag
OptTagClientIdentifier :: Dhcp4OptionTag
OptTagNetWareDomainName :: Dhcp4OptionTag
OptTagNetWareInfo :: Dhcp4OptionTag
OptTagAutoconfiguration :: Dhcp4OptionTag
data OptionTagOrError
UnknownTag :: Word8 -> OptionTagOrError
KnownTag :: Dhcp4OptionTag -> OptionTagOrError
getOptionTag :: Get OptionTagOrError
putOptionTag :: OptionTagOrError -> Put
data NetBiosNodeType
BNode :: NetBiosNodeType
PNode :: NetBiosNodeType
MNode :: NetBiosNodeType
HNode :: NetBiosNodeType
data OverloadOption
UsedFileField :: OverloadOption
UsedSNameField :: OverloadOption
UsedBothFields :: OverloadOption
getDhcp4Options :: ByteString -> ByteString -> Get (String, String, [Dhcp4Option])
putDhcp4Options :: [Dhcp4Option] -> Put
scrubControls :: (Applicative m, Monad m) => [Either ControlTag Dhcp4Option] -> m [Dhcp4Option]

-- | <a>eatPad</a> fails on any non <a>ControlPad</a> option with an error
--   message.
eatPad :: Monad m => Either ControlTag Dhcp4Option -> m ()
replicateA :: Applicative f => Int -> f a -> f [a]
repeatedly :: Get a -> Get [a]
nullTerminated :: ByteString -> String
lookupOverload :: [Dhcp4Option] -> Maybe OverloadOption
lookupFile :: [Dhcp4Option] -> Maybe NVTAsciiString
lookupSname :: [Dhcp4Option] -> Maybe NVTAsciiString
lookupParams :: [Dhcp4Option] -> Maybe [OptionTagOrError]
lookupMessageType :: [Dhcp4Option] -> Maybe Dhcp4MessageType
lookupRequestAddr :: [Dhcp4Option] -> Maybe IP4
lookupLeaseTime :: [Dhcp4Option] -> Maybe Word32
class Option a
getOption :: Option a => Get a
putOption :: Option a => a -> Put
defaultFixedGetOption :: CodecAtom a => Get a
defaultFixedPutOption :: CodecAtom a => a -> Put
fixedLen :: Int -> Get a -> Get a
getRecord :: CodecAtom a => (Int, Get a)
newtype NVTAsciiString
NVTAsciiString :: String -> NVTAsciiString
getLen :: Get Int
putLen :: Int -> Put
instance Eq Dhcp4MessageType
instance Show Dhcp4MessageType
instance Eq ControlTag
instance Show ControlTag
instance Show Dhcp4OptionTag
instance Eq Dhcp4OptionTag
instance Show OptionTagOrError
instance Eq OptionTagOrError
instance Show NetBiosNodeType
instance Eq NetBiosNodeType
instance Show OverloadOption
instance Eq OverloadOption
instance Eq NVTAsciiString
instance Show NVTAsciiString
instance Show Dhcp4Option
instance Eq Dhcp4Option
instance Option NVTAsciiString
instance CodecAtom OptionTagOrError
instance Option ByteString
instance Option SubnetMask
instance Option IP4
instance Option Word32
instance Option Word16
instance Option Word8
instance Option Bool
instance (CodecAtom a, CodecAtom b) => Option (a, b)
instance CodecAtom a => Option [a]
instance CodecAtom OverloadOption
instance Option OverloadOption
instance CodecAtom NetBiosNodeType
instance Option NetBiosNodeType
instance CodecAtom Dhcp4MessageType
instance Option Dhcp4MessageType
instance CodecAtom MagicCookie


-- | The <a>Dhcp4</a> module defines the various messages and transitions
--   used in the DHCPv4 protocol. This module provides both a high-level
--   view of the message types as well as a low-level intermediate form
--   which is closely tied to the binary format.
--   
--   References: RFC 2131 - Dynamic Host Configuration Protocol
--   http:/<i>www.faqs.org</i>rfcs/rfc2131.html
module Hans.Message.Dhcp4

-- | <a>RequestMessage</a> is a sum of the client request messages.
data RequestMessage
RequestMessage :: Request -> RequestMessage
DiscoverMessage :: Discover -> RequestMessage

-- | <a>Request</a> is used by the client to accept an offered lease.
data Request
Request :: Xid -> Bool -> IP4 -> Mac -> [Dhcp4OptionTag] -> Maybe IP4 -> Request

-- | Transaction ID of offer
requestXid :: Request -> Xid

-- | Set <a>True</a> to instruct server to send to broadcast hardware
--   address
requestBroadcast :: Request -> Bool
requestServerAddr :: Request -> IP4

-- | Hardware address of the client
requestClientHardwareAddress :: Request -> Mac

-- | Used to specify the information that client needs
requestParameters :: Request -> [Dhcp4OptionTag]

-- | Used to specify the address which was accepted
requestAddress :: Request -> Maybe IP4

-- | <a>Discover</a> is used by the client to discover what servers are
--   available. This message is sent to the IPv4 broadcast.
data Discover
Discover :: Xid -> Bool -> Mac -> [Dhcp4OptionTag] -> Discover

-- | Transaction ID of this and subsequent messages
discoverXid :: Discover -> Xid

-- | Set <a>True</a> to instruct the server to send to broadcast hardware
--   address
discoverBroadcast :: Discover -> Bool

-- | Hardware address of the client
discoverClientHardwareAddr :: Discover -> Mac

-- | Used to specify the information that client needs in the offers
discoverParameters :: Discover -> [Dhcp4OptionTag]

-- | <a>ServerSettings</a> define all of the information that would be
--   needed to act as a DHCP server for one client. The server is defined
--   to be able to issue a single "lease" whose parameters are defined
--   below.
data ServerSettings
Settings :: IP4 -> Word32 -> IP4 -> Word32 -> SubnetMask -> IP4 -> [IP4] -> String -> [IP4] -> ServerSettings

-- | The IPv4 address of the DHCP server
staticServerAddr :: ServerSettings -> IP4

-- | Lease: timezone offset in seconds from UTC
staticTimeOffset :: ServerSettings -> Word32

-- | Lease: client IPv4 address on network
staticClientAddr :: ServerSettings -> IP4

-- | Lease: duration in seconds
staticLeaseTime :: ServerSettings -> Word32

-- | Lease: subnet mask on network
staticSubnet :: ServerSettings -> SubnetMask

-- | Lease: broadcast address on network
staticBroadcast :: ServerSettings -> IP4

-- | Lease: gateway routers on network
staticRouters :: ServerSettings -> [IP4]

-- | Lease: client's assigned domain name
staticDomainName :: ServerSettings -> String

-- | Lease: network DNS servers
staticDNS :: ServerSettings -> [IP4]

-- | <a>ReplyMessage</a> is a sum of the server response messages.
data ReplyMessage
AckMessage :: Ack -> ReplyMessage
OfferMessage :: Offer -> ReplyMessage

-- | <a>Ack</a> is sent by the DHCPv4 server to acknowledge a sucessful
--   <a>Request</a> message. Upon receiving this message the client has
--   completed the exchange and has successfully obtained a lease.
data Ack
Ack :: Word8 -> Xid -> IP4 -> IP4 -> IP4 -> Mac -> Word32 -> [Dhcp4Option] -> Ack

-- | The maximum number of relays this message can use.
ackHops :: Ack -> Word8

-- | Transaction ID for this exchange
ackXid :: Ack -> Xid

-- | Lease: assigned client address
ackYourAddr :: Ack -> IP4

-- | DHCP server's IPv4 address
ackServerAddr :: Ack -> IP4

-- | DHCP relay server's address
ackRelayAddr :: Ack -> IP4

-- | Client's hardware address
ackClientHardwareAddr :: Ack -> Mac

-- | Lease: duration of lease in seconds
ackLeaseTime :: Ack -> Word32

-- | Subset of information requested in previous <a>Request</a>
ackOptions :: Ack -> [Dhcp4Option]

-- | <a>Offer</a> is sent by the DHCPv4 server in response to a
--   <a>Discover</a>. This offer is only valid for a short period of time
--   as the client might receive many offers. The client must next request
--   a lease from a specific server using the information in that server's
--   offer.
data Offer
Offer :: Word8 -> Xid -> IP4 -> IP4 -> IP4 -> Mac -> [Dhcp4Option] -> Offer

-- | The maximum number of relays this message can use.
offerHops :: Offer -> Word8

-- | Transaction ID of this exchange
offerXid :: Offer -> Xid

-- | The IPv4 address that this server is willing to lease
offerYourAddr :: Offer -> IP4

-- | The IPv4 address of the DHCPv4 server
offerServerAddr :: Offer -> IP4

-- | The IPv4 address of the DHCPv4 relay server
offerRelayAddr :: Offer -> IP4

-- | The hardware address of the client
offerClientHardwareAddr :: Offer -> Mac

-- | The options that this server would include in a lease
offerOptions :: Offer -> [Dhcp4Option]

-- | <a>Dhcp4Message</a> is a low-level message container that is very
--   close to the binary representation of DHCPv4 message. It is suitable
--   for containing any DHCPv4 message. Values of this type should only be
--   created using the publicly exported functions.
data Dhcp4Message
Dhcp4Message :: Dhcp4Op -> Word8 -> Xid -> Word16 -> Bool -> IP4 -> IP4 -> IP4 -> IP4 -> Mac -> String -> String -> [Dhcp4Option] -> Dhcp4Message

-- | Message op code / message type. 1 = BOOTREQUEST, 2 = BOOTREPLY
dhcp4Op :: Dhcp4Message -> Dhcp4Op

-- | Client sets to zero, optionally used by relay agents when booting via
--   a relay agent.
dhcp4Hops :: Dhcp4Message -> Word8

-- | Transaction ID, a random number chosen by the client, used by the
--   client and server to associate messages and responses between a client
--   and a server.
dhcp4Xid :: Dhcp4Message -> Xid

-- | Filled in by client, seconds elapsed since client began address
--   acquisition or renewal process.
dhcp4Secs :: Dhcp4Message -> Word16

-- | Client requests messages be sent to hardware broadcast address
dhcp4Broadcast :: Dhcp4Message -> Bool

-- | Client IP address; only filled in if client is in BOUND, RENEW or
--   REBINDING state and can respond to ARP requests.
dhcp4ClientAddr :: Dhcp4Message -> IP4

-- | <tt>your</tt> (client) address
dhcp4YourAddr :: Dhcp4Message -> IP4

-- | IP address of next server to use in bootstrap; returned in DHCPOFFER,
--   DHCPACK by server
dhcp4ServerAddr :: Dhcp4Message -> IP4

-- | Relay agent IP address, used in booting via a relay agent
dhcp4RelayAddr :: Dhcp4Message -> IP4

-- | Client hardware address
dhcp4ClientHardwareAddr :: Dhcp4Message -> Mac

-- | Optional server host name, null terminated string
dhcp4ServerHostname :: Dhcp4Message -> String

-- | Boot file name, full terminated string; "generic" name of null in
--   DHCPDISCOVER, fully qualified directory-path name in DHCPOFFER
dhcp4BootFilename :: Dhcp4Message -> String

-- | Optional parameters field.
dhcp4Options :: Dhcp4Message -> [Dhcp4Option]

-- | <a>Xid</a> is a Transaction ID, a random number chosen by the client,
--   used by the client and server to associate messages and responses
--   between a client and a server.
newtype Xid
Xid :: Word32 -> Xid

-- | <a>requestToAck</a> creates <a>Ack</a> messages suitable for
--   responding to <a>Request</a> messages given a static
--   <a>ServerSettings</a> configuration.
requestToAck :: ServerSettings -> Request -> Ack

-- | <a>discoverToOffer</a> creates a suitable <a>Offer</a> in response to
--   a client's <a>Discover</a> message using the configuration settings
--   specified in the given <a>ServerSettings</a>.
discoverToOffer :: ServerSettings -> Discover -> Offer

-- | <a>mkDiscover</a> creates a new <a>Discover</a> message with a set of
--   options suitable for configuring a basic network stack.
mkDiscover :: Xid -> Mac -> Discover

-- | <a>offerToRequest</a> creates a <a>Request</a> message suitable for
--   accepting an <a>Offer</a> from the DHCPv4 server.
offerToRequest :: Offer -> Request

-- | <a>requestToMessage</a> embeds <a>Request</a> messages in the
--   low-level <a>Dhcp4Message</a> type, typically for the purpose of
--   serialization.
requestToMessage :: Request -> Dhcp4Message

-- | <a>ackToMessage</a> embeds <a>Ack</a> messages in the low-level
--   <a>Dhcp4Message</a> type, typically for the purpose of serialization.
ackToMessage :: Ack -> Dhcp4Message

-- | <a>offerToMessage</a> embeds <a>Offer</a> messages in the low-level
--   <a>Dhcp4Message</a> type, typically for the purpose of serialization.
offerToMessage :: Offer -> Dhcp4Message

-- | <a>discoverToMessage</a> embeds <a>Discover</a> messages in the
--   low-level <a>Dhcp4Message</a> type, typically for the purpose of
--   serialization.
discoverToMessage :: Discover -> Dhcp4Message

-- | <a>parseDhcpMessage</a> attempts to find a valid high-level message
--   contained in a low-level message. The <a>Dhcp4Message</a> is a large
--   type and can encode invalid combinations of options.
parseDhcpMessage :: Dhcp4Message -> Maybe (Either RequestMessage ReplyMessage)

-- | <a>getDhcp4Message</a> is the binary decoder for parsing
--   <a>Dhcp4Message</a> values.
getDhcp4Message :: ByteString -> Either String Dhcp4Message

-- | <a>getDhcp4Message</a> is the binary encoder for rendering
--   <a>Dhcp4Message</a> values.
putDhcp4Message :: Dhcp4Message -> ByteString
instance Show ServerSettings
instance Eq Xid
instance Show Xid
instance Show Offer
instance Show Ack
instance Show ReplyMessage
instance Show Discover
instance Show Request
instance Show RequestMessage
instance Eq Dhcp4Op
instance Show Dhcp4Op
instance Eq Dhcp4Message
instance Show Dhcp4Message
instance Eq HardwareType
instance Show HardwareType
instance Show Flags
instance Eq Flags
instance CodecAtom Flags
instance CodecAtom HardwareType
instance CodecAtom Dhcp4Op
instance CodecAtom Xid

module Hans.Message.Arp
data ArpPacket hw p
ArpPacket :: !Word16 -> !Word16 -> ArpOper -> hw -> p -> hw -> p -> ArpPacket hw p
arpHwType :: ArpPacket hw p -> !Word16
arpPType :: ArpPacket hw p -> !Word16
arpOper :: ArpPacket hw p -> ArpOper
arpSHA :: ArpPacket hw p -> hw
arpSPA :: ArpPacket hw p -> p
arpTHA :: ArpPacket hw p -> hw
arpTPA :: ArpPacket hw p -> p

-- | Parse an Arp packet, given a way to parse hardware and protocol
--   addresses.
parseArpPacket :: Get hw -> Get p -> ByteString -> Either String (ArpPacket hw p)

-- | Render an Arp packet, given a way to render hardware and protocol
--   addresses.
renderArpPacket :: (Address hw, Address p) => Putter hw -> Putter p -> ArpPacket hw p -> ByteString

-- | Arp operations.
data ArpOper

-- | 0x1
ArpRequest :: ArpOper

-- | 0x2
ArpReply :: ArpOper

-- | Parse an Arp operation.
parseArpOper :: Get ArpOper

-- | Render an Arp operation.
renderArpOper :: Putter ArpOper
instance Show ArpOper
instance Eq ArpOper
instance (Show hw, Show p) => Show (ArpPacket hw p)

module Hans.Layer.Arp

-- | A handle to a running arp layer.
type ArpHandle = Channel (Arp ())

-- | Start an arp layer.
runArpLayer :: ArpHandle -> EthernetHandle -> IO ()

-- | Lookup the hardware address associated with an IP address.
arpWhoHas :: BaseM m IO => ArpHandle -> IP4 -> m (Maybe Mac)

-- | Send an IP packet via the arp layer, to resolve the underlying
--   hardware addresses.
arpIP4Packet :: ArpHandle -> IP4 -> IP4 -> ByteString -> IO ()

-- | Associate an address with a mac in the Arp layer.
addLocalAddress :: ArpHandle -> IP4 -> Mac -> IO ()

module Hans.Layer.IP4.Fragmentation
type FragmentationTable addr = Map (Ident, addr, addr) Fragments
emptyFragmentationTable :: FragmentationTable IP4
data Fragments
Fragments :: !POSIXTime -> !Int -> [Fragment] -> Fragments
startTime :: Fragments -> !POSIXTime
totalSize :: Fragments -> !Int
fragments :: Fragments -> [Fragment]
data Fragment
Fragment :: !Int -> !Int -> ByteString -> Fragment
fragmentOffset :: Fragment -> !Int
fragmentLength :: Fragment -> !Int
fragmentPayload :: Fragment -> ByteString

-- | The end of a fragment.
fragmentEnd :: Fragment -> Int

-- | Check the ordering of two fragments.
comesBefore :: Fragment -> Fragment -> Bool

-- | Check the ordering of two fragments.
comesAfter :: Fragment -> Fragment -> Bool

-- | Merge two fragments.
--   
--   Note: This doesn't do a validity check to make sure that they're
--   actually adjacent.
combineFragments :: Fragment -> Fragment -> Fragment

-- | Given a group of fragments, a new fragment, and a possible total size,
--   create a new group of fragments that incorporates the new fragment.
expandGroup :: Fragments -> Fragment -> Int -> Fragments

-- | Add a fragment to a list of fragments, in a position that is relative
--   to its offset and length.
addFragment :: Fragment -> [Fragment] -> [Fragment]

-- | Process a packet fragment through the system, potentially returning a
--   fully-processed packet if this fragment completes an existing packet
--   or is itself a fully-complete packet.
processFragment :: Address addr => POSIXTime -> FragmentationTable addr -> Bool -> Int -> addr -> addr -> Ident -> ByteString -> (FragmentationTable addr, Maybe ByteString)
processIP4Packet :: POSIXTime -> FragmentationTable IP4 -> IP4Header -> ByteString -> (FragmentationTable IP4, Maybe ByteString)
instance Eq Fragment
instance Show Fragment
instance Show Fragments
instance Ord Fragment

module Data.PrefixTree
data PrefixTree a
empty :: PrefixTree a
singleton :: Key -> a -> PrefixTree a
insert :: Key -> a -> PrefixTree a -> PrefixTree a
delete :: Key -> PrefixTree a -> PrefixTree a
toList :: PrefixTree a -> [([Bool], a)]
fromList :: [(Key, a)] -> PrefixTree a
lookup :: Key -> PrefixTree a -> Maybe a
member :: Key -> PrefixTree a -> Bool
matches :: Key -> PrefixTree a -> [a]
match :: Key -> PrefixTree a -> Maybe a
elems :: PrefixTree a -> [a]
keys :: Key -> PrefixTree a -> [Key]
key :: Key -> PrefixTree a -> Maybe Key
instance Show a => Show (PrefixTree a)

module Hans.Layer.IP4.Routing
data Rule mask addr
Direct :: mask -> addr -> Mtu -> Rule mask addr
Indirect :: mask -> addr -> Rule mask addr
type Mtu = Int
type RoutingTable addr = PrefixTree (Dest addr)
emptyRoutingTable :: Address addr => RoutingTable addr

-- | Add a rule to the routing table.
addRule :: Mask mask addr => Rule mask addr -> RoutingTable addr -> RoutingTable addr

-- | Discover the source and destination when trying to route an address.
route :: Address addr => addr -> RoutingTable addr -> Maybe (addr, addr, Mtu)

-- | Dump all local addresses.
localAddrs :: Address addr => RoutingTable addr -> [addr]

-- | Find the mask that would be used to route an address.
sourceMask :: Mask mask addr => addr -> RoutingTable addr -> Maybe mask
instance (Show mask, Show addr) => Show (Rule mask addr)
instance Show addr => Show (Dest addr)

module Hans.Layer.IP4
type IP4Handle = Channel (IP ())
runIP4Layer :: IP4Handle -> ArpHandle -> EthernetHandle -> IO ()
data Rule mask addr
Direct :: mask -> addr -> Mtu -> Rule mask addr
Indirect :: mask -> addr -> Rule mask addr
connectEthernet :: IP4Handle -> EthernetHandle -> IO ()
withIP4Source :: IP4Handle -> IP4 -> (IP4 -> IO ()) -> IO ()
sendIP4Packet :: IP4Handle -> IP4Header -> ByteString -> IO ()
addIP4RoutingRule :: IP4Handle -> Rule IP4Mask IP4 -> IO ()
addIP4Handler :: IP4Handle -> IP4Protocol -> Handler -> IO ()
type Handler = IP4Header -> ByteString -> IO ()
removeIP4Handler :: IP4Handle -> IP4Protocol -> IO ()
type Mtu = Int
instance ProvidesHandlers IP4State IP4Protocol Handler

module Hans.Layer.Icmp4
type Icmp4Handle = Channel (Icmp4 ())
runIcmp4Layer :: Icmp4Handle -> IP4Handle -> IO ()

-- | Add a handler for Icmp4 messages that match the provided predicate.
addIcmp4Handler :: Icmp4Handle -> Handler -> IO ()

-- | Send a destination unreachable message to a host, with the given bytes
--   as its body. Don't send the message, if the message was broadcast.
destUnreachable :: Icmp4Handle -> DestinationUnreachableCode -> IP4Header -> Int -> ByteString -> IO ()

module Hans.Layer.Udp
type UdpHandle = Channel (Udp ())
data UdpException
runUdpLayer :: UdpHandle -> IP4Handle -> Icmp4Handle -> IO ()

-- | Queue an incoming udp message from the IP4 layer.
queueUdp :: UdpHandle -> IP4Header -> ByteString -> IO ()

-- | Send a UDP datagram. When the source port is given, this will send
--   using that source port. If the source port is not given, a fresh one
--   is used, and immediately recycled.
--   
--   NOTE: this doesn't prevent you from sending messages on a port that
--   another thread is already using. This is a funky design, and we'd be
--   better suited by introducing a UdpSocket type.
sendUdp :: UdpHandle -> IP4 -> Maybe UdpPort -> UdpPort -> ByteString -> IO ()
type Handler = IP4 -> UdpPort -> ByteString -> IO ()

-- | Add a handler for incoming udp datagrams on a specific port.
addUdpHandler :: UdpHandle -> UdpPort -> Handler -> IO ()

-- | Add a handler for incoming udp datagrams on a freshly allocated port.
addUdpHandlerAnyPort :: UdpHandle -> (UdpPort -> Handler) -> IO UdpPort

-- | Remove a handler present on the port given.
removeUdpHandler :: UdpHandle -> UdpPort -> IO ()
instance Typeable UdpException
instance Show UdpException
instance ProvidesHandlers UdpState UdpPort Handler
instance Exception UdpException

module Hans.Layer.Dns
type DnsHandle = Channel (Dns ())
runDnsLayer :: DnsHandle -> UdpHandle -> IO ()
data DnsException
addNameServer :: DnsHandle -> IP4 -> IO ()
removeNameServer :: DnsHandle -> IP4 -> IO ()
type HostName = String
data HostEntry
HostEntry :: HostName -> [HostName] -> [IP4] -> HostEntry
hostName :: HostEntry -> HostName
hostAliases :: HostEntry -> [HostName]
hostAddresses :: HostEntry -> [IP4]
getHostByName :: DnsHandle -> HostName -> IO HostEntry
getHostByAddr :: DnsHandle -> IP4 -> IO HostEntry
instance Typeable DnsException
instance Show DnsException
instance Show HostEntry
instance Show Source
instance Exception DnsException

module Hans.Layer.Tcp.Monad
type TcpHandle = Channel (Tcp ())
type Tcp = Layer TcpState
data TcpState
TcpState :: TcpHandle -> IP4Handle -> Host -> TcpState
tcpSelf :: TcpState -> TcpHandle
tcpIP4 :: TcpState -> IP4Handle
tcpHost :: TcpState -> Host
emptyTcpState :: TcpHandle -> IP4Handle -> POSIXTime -> TcpState

-- | The handle to this layer.
self :: Tcp TcpHandle

-- | Get the handle to the IP4 layer.
ip4Handle :: Tcp IP4Handle
getHost :: Tcp Host
setHost :: Host -> Tcp ()
modifyHost :: (Host -> Host) -> Tcp ()

-- | Reset the 2MSL timer on the socket in TimeWait.
resetTimeWait2MSL :: SocketId -> Tcp ()
getTimeWait :: IP4 -> TcpHeader -> Tcp (Maybe (SocketId, TimeWaitSock))
removeTimeWait :: SocketId -> Tcp ()
getConnections :: Tcp Connections
setConnections :: Connections -> Tcp ()

-- | Lookup a connection, returning <tt>Nothing</tt> if the connection
--   doesn't exist.
lookupConnection :: SocketId -> Tcp (Maybe TcpSocket)

-- | Retrieve a connection from the host. The computation fails if the
--   connection doesn't exist.
getConnection :: SocketId -> Tcp TcpSocket

-- | Assign a connection to a socket id. If the TcpSocket is in TimeWait,
--   this will do two things:
--   
--   <ol>
--   <li>Remove the corresponding key from the connections map</li>
--   <li>Add the socket to the TimeWait map, using the current value of its
--   2MSL timer (which should be set when the TimeWait state is
--   entered)</li>
--   </ol>
--   
--   The purpose of this is to clean up the memory associated with the
--   connection as soon as possible, and once it's in TimeWait, no data
--   will flow on the socket.
setConnection :: SocketId -> TcpSocket -> Tcp ()

-- | Add a new connection to the host.
addConnection :: SocketId -> TcpSocket -> Tcp ()

-- | Modify an existing connection in the host.
modifyConnection :: SocketId -> (TcpSocket -> TcpSocket) -> Tcp ()

-- | Remove a connection from the host.
remConnection :: SocketId -> Tcp ()

-- | Send out a tcp segment via the IP layer.
sendSegment :: IP4 -> TcpHeader -> ByteString -> Tcp ()

-- | Get the initial sequence number.
initialSeqNum :: Tcp TcpSeqNum

-- | Increment the initial sequence number by a value.
addInitialSeqNum :: TcpSeqNum -> Tcp ()

-- | Allocate a new port for use.
allocatePort :: Tcp TcpPort

-- | Release a used port.
closePort :: TcpPort -> Tcp ()

-- | Tcp operations in the context of a socket.
--   
--   This implementation is a bit ridiculous, and when the eventual rewrite
--   comes this should be one of the first things to be reconsidered. The
--   basic problem is that if you rely on the <tt>finished</tt>
--   implementation for the Layer monad, you exit from the socket context
--   as well, losing any changes that have been made locally. This gives
--   the ability to simulate <tt>finished</tt>, with the benefit of only
--   yielding from the Sock context, not the whole Tcp context.
newtype Sock a
Sock :: (forall r. TcpSocket -> Escape r -> Next a r -> Tcp (TcpSocket, Maybe r)) -> Sock a
unSock :: Sock a -> forall r. TcpSocket -> Escape r -> Next a r -> Tcp (TcpSocket, Maybe r)
type Escape r = TcpSocket -> Tcp (TcpSocket, Maybe r)
type Next a r = TcpSocket -> a -> Tcp (TcpSocket, Maybe r)
inTcp :: Tcp a -> Sock a

-- | Finish early, with no result.
escape :: Sock a
runSock_ :: TcpSocket -> Sock a -> Tcp ()
runSock' :: TcpSocket -> Sock a -> Tcp TcpSocket

-- | Run the socket action, and increment its internal timestamp value.
runSock :: TcpSocket -> Sock a -> Tcp (TcpSocket, Maybe a)

-- | Iterate for each connection, rolling back to its previous state if the
--   computation fails.
eachConnection :: Sock () -> Tcp ()
withConnection :: IP4 -> TcpHeader -> Sock a -> Tcp ()
withConnection' :: IP4 -> TcpHeader -> Sock a -> Tcp () -> Tcp ()
listeningConnection :: SocketId -> Sock a -> Tcp (Maybe a)

-- | Run a socket operation in the context of the socket identified by the
--   socket id.
--   
--   XXX this should really be renamed, as it's not guarding on the state
--   of the socket
establishedConnection :: SocketId -> Sock a -> Tcp ()

-- | Get the parent id of the current socket, and fail if it doesn't exist.
getParent :: Sock (Maybe SocketId)

-- | Run an action in the context of the socket's parent. Returns
--   <a>Nothing</a> if the connection has no parent.
inParent :: Sock a -> Sock (Maybe a)
withChild :: TcpSocket -> Sock a -> Sock (Maybe a)
getTcpSocket :: Sock TcpSocket
setTcpSocket :: TcpSocket -> Sock ()
getTcpTimers :: Sock TcpTimers
modifyTcpSocket :: (TcpSocket -> (a, TcpSocket)) -> Sock a
modifyTcpSocket_ :: (TcpSocket -> TcpSocket) -> Sock ()
modifyTcpTimers :: (TcpTimers -> (a, TcpTimers)) -> Sock a
modifyTcpTimers_ :: (TcpTimers -> TcpTimers) -> Sock ()

-- | Set the state of the current connection.
setState :: ConnState -> Sock ()

-- | Get the state of the current connection.
getState :: Sock ConnState
whenState :: ConnState -> Sock () -> Sock ()
whenStates :: [ConnState] -> Sock () -> Sock ()
pushAcceptor :: Acceptor -> Sock ()

-- | Pop off an acceptor.
popAcceptor :: Sock (Maybe Acceptor)

-- | Send a notification back to a waiting process that the socket has been
--   established, or that it has failed. It's assumed that this will only
--   be called from the context of a user socket, so when the parameter is
--   <tt>False</tt>, the user close field will be set to true.
notify :: Bool -> Sock ()

-- | Output some IO to the Tcp layer.
outputS :: IO () -> Sock ()
advanceRcvNxt :: TcpSeqNum -> Sock ()
advanceSndNxt :: TcpSeqNum -> Sock ()
remoteHost :: Sock IP4

-- | Send a TCP segment in the context of a socket.
tcpOutput :: TcpHeader -> ByteString -> Sock ()

-- | Unblock any waiting processes, in preparation to close.
shutdown :: Sock ()

-- | Set the socket state to closed, and unblock any waiting processes.
closeSocket :: Sock ()
instance Monad Sock
instance Applicative Sock
instance Functor Sock

module Hans.Layer.Tcp.Messages
mkSegment :: TcpSocket -> TcpHeader
mkAck :: TcpSocket -> TcpHeader

-- | Add the Sack option to a tcp packet.
addSackOption :: TcpSocket -> TcpHeader -> TcpHeader

-- | Add the sack permitted tcp option.
addSackPermitted :: TcpSocket -> TcpHeader -> TcpHeader

-- | Add the window scale option on the outgoing header.
addWindowScale :: TcpSocket -> TcpHeader -> TcpHeader

-- | Given a tcp header, generate the next header in the sequence that
--   corresponds to the RST ACK response. As this should only be used in
--   situations in which an ACK was not received, this adds one plus the
--   body length to the ack number.
mkRstAck :: TcpHeader -> Int -> TcpHeader
mkRst :: TcpHeader -> TcpHeader
mkSyn :: TcpSocket -> TcpHeader

-- | Construct a SYN ACK packet, in response to a SYN.
mkSynAck :: TcpSocket -> TcpHeader

-- | Construct a FIN packet.
--   
--   XXX should this include a sack option?
mkFinAck :: TcpSocket -> TcpHeader
mkData :: TcpSocket -> TcpHeader
syn :: Sock ()

-- | Respond to a SYN message with a SYN ACK message.
synAck :: Sock ()

-- | Send an ACK packet.
ack :: Sock ()

-- | Schedule a delayed ACK packet.
delayedAck :: Sock ()

-- | Unschedule a delayed ACK packet.
clearDelayedAck :: Sock ()

-- | Queue an outgoing fin packet in the outgoing window, and send it.
--   
--   NOTE: This uses genSegments, which will pull data out of the waiti
finAck :: Sock ()
rstAck :: TcpHeader -> Int -> Sock ()
rst :: TcpHeader -> Sock ()

-- | Send a segment.
outputSegment :: OutSegment -> Sock ()
type SetFlag = TcpHeader -> Bool
type UnsetFlag = TcpHeader -> Bool
testFlags :: [SetFlag] -> [UnsetFlag] -> TcpHeader -> Bool
isSyn :: TcpHeader -> Bool
isSynAck :: TcpHeader -> Bool
isRstAck :: TcpHeader -> Bool
isAck :: TcpHeader -> Bool
isFin :: TcpHeader -> Bool
isFinAck :: TcpHeader -> Bool

-- | Take data from the output buffer, and turn it into segments. When data
--   was freed from the output buffer, the wakeup actions for any threads
--   currently blocked on writing to the output buffer will be returned.
genSegments :: POSIXTime -> TcpSocket -> (([Wakeup], OutSegments), TcpSocket)

module Hans.Layer.Tcp.Timers

-- | Schedule the timers to run on the fast and slow intervals.
initTimers :: Tcp ()
resetIdle :: Sock ()

-- | Conditionally run an action when the connection has been idle for at
--   least timeout <tt>SlowTick</tt>s.
whenIdleFor :: Int -> Sock () -> Sock ()

-- | Set the value of the 2MSL timer.
set2MSL :: SlowTicks -> Sock ()

-- | Calibrate the RTO timer, as specified by RFC-6298.
calibrateRTO :: POSIXTime -> POSIXTime -> TcpTimers -> TcpTimers

module Hans.Layer.Tcp.Handlers

-- | Process a single incoming tcp packet.
handleIncomingTcp :: IP4Header -> ByteString -> Tcp ()

-- | Fill up the remote window with segments.
outputSegments :: Sock ()

module Hans.Layer.Tcp
type TcpHandle = Channel (Tcp ())
runTcpLayer :: TcpHandle -> IP4Handle -> IO ()

-- | Queue a tcp packet.
queueTcp :: TcpHandle -> IP4Header -> ByteString -> IO ()

module Hans.Layer.Tcp.Socket
data Socket

-- | The remote host of a socket.
sockRemoteHost :: Socket -> IP4

-- | The remote port of a socket.
sockRemotePort :: Socket -> TcpPort

-- | The local port of a socket.
sockLocalPort :: Socket -> TcpPort

-- | Connect to a remote host.
connect :: TcpHandle -> IP4 -> TcpPort -> Maybe TcpPort -> IO Socket

-- | A connect call failed.
data ConnectError
ConnectionRefused :: ConnectError

-- | Open a new listening socket that can be used to accept new
--   connections.
listen :: TcpHandle -> IP4 -> TcpPort -> IO Socket
data ListenError
ListenError :: ListenError

-- | Accept new incoming connections on a listening socket.
accept :: Socket -> IO Socket
data AcceptError
AcceptError :: AcceptError

-- | Close an open socket.
close :: Socket -> IO ()
data CloseError
CloseError :: CloseError

-- | Send bytes over a socket. The number of bytes delivered will be
--   returned, with 0 representing the other side having closed the
--   connection.
sendBytes :: Socket -> ByteString -> IO Int64
canSend :: Socket -> IO Bool

-- | Receive bytes from a socket. A null ByteString represents the other
--   end closing the socket.
recvBytes :: Socket -> Int64 -> IO ByteString

-- | True when there are bytes queued to receive.
canRecv :: Socket -> IO Bool
instance Typeable SocketGenericError
instance Typeable ConnectError
instance Typeable ListenError
instance Typeable AcceptError
instance Typeable CloseError
instance Show SocketGenericError
instance Show ConnectError
instance Show ListenError
instance Show AcceptError
instance Show CloseError
instance Exception CloseError
instance Exception AcceptError
instance Exception ListenError
instance Exception ConnectError
instance Exception SocketGenericError

module Hans.NetworkStack

-- | An example implementation of the whole network stack.
data NetworkStack
NetworkStack :: ArpHandle -> EthernetHandle -> IP4Handle -> Icmp4Handle -> UdpHandle -> TcpHandle -> DnsHandle -> NetworkStack
nsArp :: NetworkStack -> ArpHandle
nsEthernet :: NetworkStack -> EthernetHandle
nsIp4 :: NetworkStack -> IP4Handle
nsIcmp4 :: NetworkStack -> Icmp4Handle
nsUdp :: NetworkStack -> UdpHandle
nsTcp :: NetworkStack -> TcpHandle
nsDns :: NetworkStack -> DnsHandle
newNetworkStack :: IO NetworkStack
class HasEthernet stack
ethernetHandle :: HasEthernet stack => stack -> EthernetHandle

-- | Start the ethernet layer in a network stack.
startEthernetLayer :: HasEthernet stack => stack -> IO ()

-- | Add an ethernet device to the ethernet layer.
addDevice :: HasEthernet stack => stack -> Mac -> Tx -> Rx -> IO ()

-- | Remove a device from the ethernet layer.
removeDevice :: HasEthernet stack => stack -> Mac -> IO ()

-- | Bring an ethernet device in the ethernet layer up.
deviceUp :: HasEthernet stack => stack -> Mac -> IO ()

-- | Bring an ethernet device in the ethernet layer down.
deviceDown :: HasEthernet stack => stack -> Mac -> IO ()
class HasArp stack
arpHandle :: HasArp stack => stack -> ArpHandle

-- | Start the arp layer in a network stack.
startArpLayer :: (HasEthernet stack, HasArp stack) => stack -> IO ()
class HasIcmp4 stack
icmp4Handle :: HasIcmp4 stack => stack -> Icmp4Handle

-- | Start the icmp4 layer in a network stack..
startIcmp4Layer :: (HasIcmp4 stack, HasIP4 stack) => stack -> IO ()
class HasIP4 stack
ip4Handle :: HasIP4 stack => stack -> IP4Handle

-- | Start the IP4 layer in a network stack.
startIP4Layer :: (HasArp stack, HasEthernet stack, HasIP4 stack) => stack -> IO ()
type Mtu = Int

-- | Add an IP4 address to a network stack.
addIP4Addr :: (HasArp stack, HasIP4 stack) => stack -> IP4Mask -> Mac -> Mtu -> IO ()

-- | Add a route for a network, via an address.
routeVia :: HasIP4 stack => stack -> IP4Mask -> IP4 -> IO ()

-- | Register a handler for an IP4 protocol
listenIP4Protocol :: HasIP4 stack => stack -> IP4Protocol -> Handler -> IO ()

-- | Register a handler for an IP4 protocol
ignoreIP4Protocol :: HasIP4 stack => stack -> IP4Protocol -> IO ()
class HasUdp stack
udpHandle :: HasUdp stack => stack -> UdpHandle

-- | Start the UDP layer of a network stack.
startUdpLayer :: (HasIP4 stack, HasIcmp4 stack, HasUdp stack) => stack -> IO ()

-- | Add a handler for a UDP port.
addUdpHandler :: HasUdp stack => stack -> UdpPort -> Handler -> IO ()

-- | Remove a handler for a UDP port.
removeUdpHandler :: HasUdp stack => stack -> UdpPort -> IO ()

-- | Inject a packet into the UDP layer.
queueUdp :: HasUdp stack => stack -> IP4Header -> ByteString -> IO ()

-- | Send a UDP packet.
sendUdp :: HasUdp stack => stack -> IP4 -> Maybe UdpPort -> UdpPort -> ByteString -> IO ()
class HasIP4 stack => HasTcp stack
tcpHandle :: HasTcp stack => stack -> TcpHandle

-- | Start the TCP layer of a network stack.
startTcpLayer :: HasTcp stack => stack -> IO ()

-- | Listen for incoming connections.
listen :: HasTcp stack => stack -> IP4 -> TcpPort -> IO Socket

-- | Make a remote connection.
connect :: HasTcp stack => stack -> IP4 -> TcpPort -> Maybe TcpPort -> IO Socket
class HasUdp stack => HasDns stack
dnsHandle :: HasDns stack => stack -> DnsHandle
startDnsLayer :: HasDns stack => stack -> IO ()
addNameServer :: HasDns stack => stack -> IP4 -> IO ()
removeNameServer :: HasDns stack => stack -> IP4 -> IO ()
getHostByName :: HasDns stack => stack -> HostName -> IO HostEntry
getHostByAddr :: HasDns stack => stack -> IP4 -> IO HostEntry
data UdpPort
data TcpPort
type HostName = String
data HostEntry
HostEntry :: HostName -> [HostName] -> [IP4] -> HostEntry
hostName :: HostEntry -> HostName
hostAliases :: HostEntry -> [HostName]
hostAddresses :: HostEntry -> [IP4]
data Socket

-- | The remote host of a socket.
sockRemoteHost :: Socket -> IP4

-- | The remote port of a socket.
sockRemotePort :: Socket -> TcpPort

-- | The local port of a socket.
sockLocalPort :: Socket -> TcpPort

-- | Accept new incoming connections on a listening socket.
accept :: Socket -> IO Socket

-- | Close an open socket.
close :: Socket -> IO ()

-- | Send bytes over a socket. The number of bytes delivered will be
--   returned, with 0 representing the other side having closed the
--   connection.
sendBytes :: Socket -> ByteString -> IO Int64

-- | Receive bytes from a socket. A null ByteString represents the other
--   end closing the socket.
recvBytes :: Socket -> Int64 -> IO ByteString
data AcceptError
AcceptError :: AcceptError
data CloseError
CloseError :: CloseError

-- | A connect call failed.
data ConnectError
ConnectionRefused :: ConnectError
data ListenError
ListenError :: ListenError
instance HasDns NetworkStack
instance HasUdp NetworkStack
instance HasTcp NetworkStack
instance HasIcmp4 NetworkStack
instance HasIP4 NetworkStack
instance HasEthernet NetworkStack
instance HasArp NetworkStack

module Hans.DhcpClient

-- | Discover a dhcp server, and request an address.
dhcpDiscover :: (HasEthernet stack, HasArp stack, HasIP4 stack, HasUdp stack, HasDns stack) => stack -> Mac -> AckHandler -> IO ()
