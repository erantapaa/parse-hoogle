-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tool for managing probability estimation
--   
--   This library provides data structures for collecting counts and
--   estimating distributions from observed data. It is designed for
--   natural language systems that need to handle large, discrete
--   observation sets and perform smoothing.
@package estimators
@version 0.1.4

module NLP.Probability.SmoothTrie
newtype SmoothTrie map letter holder
SmoothTrie :: (TrieMap map letter holder) -> SmoothTrie map letter holder
addColumn :: (Map map letter, Monoid holder) => [letter] -> holder -> SmoothTrie map letter holder -> SmoothTrie map letter holder
instance (Show letter, Show holder, Map map letter) => Show (SmoothTrie map letter holder)
instance (Binary letter, Binary holder, Map map letter) => Binary (SmoothTrie map letter holder)
instance (Map map letter) => Functor (SmoothTrie map letter)
instance (Monoid holder, Map map letter) => Monoid (SmoothTrie map letter holder)
instance (Map map letter, Pretty holder, Pretty letter) => Pretty (SmoothTrie map letter holder)
instance (Map map letter, Arbitrary letter, Arbitrary holder) => Arbitrary (SmoothTrie map letter holder)
instance (NFData letter, NFData holder, Map map letter) => NFData (SmoothTrie map letter holder)

module NLP.Probability.Observation
type Count = Double

-- | Observations over a set of events. The param event must be an instance
--   of class Event
data Counts event

-- | Trivial type family for events. Just use EventMap = M.Map for most
--   cases. Allows clients to specify the type of map used, when efficiency
--   is important.
class (Map (EventMap event) event) => Event event where { type family EventMap event :: * -> * -> *; }

-- | Observation of a single event
observation :: (Event event) => event -> Counts event
observations :: (Map (EventMap event) event) => event -> Count -> Counts event

-- | Manually increment the count of an event
inc :: (Event e) => Counts e -> e -> Count -> Counts e
data Observed event
Observed :: (EventMap event) event Count -> Double -> Count -> Observed event
observed :: Observed event -> (EventMap event) event Count

-- | Gives the total number of observations sum_a C(a)
total :: Observed event -> Double

-- | Gives the total number of events observed at least once {a | C(a) &gt;
--   1}
unique :: Observed event -> Count

-- | Finish a set of offline observations so that they can be used to
--   estimate likelihood
finish :: (Event event) => Counts event -> Observed event
showObsPretty :: (Event event, Monad m) => (event -> m Doc) -> Counts event -> m Doc
instance (Event event, NFData event) => NFData (Counts event)
instance (Event event, Binary event, Binary (EventMap event event Count)) => Binary (Counts event)
instance (Event event) => Monoid (Counts event)
instance (Event event, Show event) => Show (Counts event)
instance (Event event, Pretty event) => Pretty (Counts event)

module NLP.Probability.Distribution
type Prob = Double
type Distribution event = event -> Prob

-- | Maximum Likelihood Estimation gives out probability by normalizing
--   over observed events. Unseen events are gived zero probabilty.
mle :: (Event event) => Estimator event
laplace :: (Event event) => (Double, Double) -> Estimator event

module NLP.Probability.ConditionalDistribution

-- | The set of observations of event conditioned on context. event must be
--   an instance of Event and context of Context
type CondObserved event context = SmoothTrie (SubMap context) (Sub context) (Counts event)
type CondDistribution event context = context -> Distribution event
condObservation :: (Context context, Event event) => event -> context -> CondObserved event context

-- | A CondObserved set for a single event and context.
condObservations :: (Context context, Event event) => event -> context -> Count -> CondObserved event context
condObservationCounts :: (Context context, Event event) => context -> Counts event -> CondObserved event context

-- | Events are conditioned on Contexts. When Contexts are sparse, we need
--   a way to decompose into simpler SubContexts. This class allows us to
--   separate this decomposition from the collection of larger contexts.
class (Map (SubMap a) (Sub a)) => Context a where { type family Sub a; type family SubMap a :: * -> * -> *; }
decompose :: (Context a) => a -> [Sub a]

-- | General Linear Interpolation. Produces a Conditional Distribution from
--   observations. It requires a GeneralLambda function which tells it how
--   to weight each level of smoothing. The GeneralLambda function can
--   observe the counts of each level of context.
--   
--   Note: We include a final level of backoff where everything is given an
--   epsilon likelihood. To ignore this, just give it lambda = 0.
estimateGeneralLinear :: (Event event, Context context) => Weighting -> CondObserved event context -> DebugDist event context
type Weighting = forall a. [Maybe (Observed a)] -> [Double]

-- | Weight each level by the likelihood that a new event will be seen at
--   that level. t / ((n * d) + t) where t is the total count, d is the
--   number of distinct observations, and n is a user defined constant.
wittenBell :: Int -> Weighting

-- | Weight each level by a fixed predefined amount.
simpleLinear :: [Double] -> Weighting
type DebugDist event context = context -> event -> [(Double, Double)]
mkDist :: DebugDist event context -> CondDistribution event context

module NLP.Probability.EM
randomCounts :: (Bounded event, Enum event, Event event, MonadRandom mr) => mr (Counts event)
randomCondCounts :: (Bounded event, Enum event, Event event, Bounded context, Enum context, Context context, MonadRandom mr) => [context] -> mr (CondObserved event context)

module NLP.Probability.Example.Trigram
instance Ord Word
instance Eq Word
instance Context TrigramContext
instance Event Word

module NLP.Probability.Chain
simpleObserve :: (JointModel a) => FullEvent a -> FullContext a -> Observation a
class JointModel a where { data family FullEvent a; data family FullContext a; data family Probs a; data family Observation a; data family Pairs a; }
chainRule :: (JointModel a) => FullEvent a -> FullContext a -> Pairs a
observe :: (JointModel a) => Pairs a -> Observation a
prob :: (JointModel a) => Probs a -> Pairs a -> Prob
estimate :: (JointModel a) => Observation a -> Probs a
instance Event Int
instance Event String
