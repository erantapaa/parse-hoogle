-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Graphs
--   
--   Graphs toolkit
@package uni-graphs
@version 2.2.1.0


-- | The function in this module finds a cycle in a given directed graph,
--   if one exists.
module Graphs.FindCycle

-- | Find a cycle in a graph. We are given a list of nodes to start from,
--   and a successor function.
findCycle :: Ord a => [a] -> (a -> [a]) -> Maybe [a]

module Graphs.TopSort
topSort :: Ord a => [(a, a)] -> [a]
topSort1 :: Ord a => [(a, a)] -> [a] -> [a]


-- | Given two acyclic graphs G1 and G2 sharing some nodes, and a list V1
--   of nodes in G1, let A be the union of G1 intersect G2 and V1. The
--   function in this module returns a list L of type [(Node,[Node])] such
--   that (1) The first elements in each pair in L are precisely those
--   elements of V1 not in G2. (2) For each element (n,ms) in L, the list
--   ms contains precisely those vertices m of G1 such that (a) m is in A;
--   (b) there is a path from m to n in G1 which has no common vertices
--   with A except at its endpoints. (3) Where the list contains two
--   elements (n1,ms1) and (n2,ms2), such that ms2 contains n1, then
--   (n1,ms1) comes before (n2,ms2) in the list.
--   
--   The purpose of all this is to provide a list of the nodes to be
--   constructed in G2 to extend it by V1 while preserving as much as
--   possible of the path structure in V1. This is used for adding version
--   graph information.
module Graphs.FindCommonParents
findCommonParents :: (Show node1, Show node2, Show nodeKey, Ord nodeKey) => GraphBack node1 nodeKey -> GraphBack node2 nodeKey -> [node1] -> [(node1, [(node1, Maybe node2)])]
data GraphBack node nodeKey
GraphBack :: [node] -> (node -> (Maybe nodeKey)) -> (node -> (Maybe [node])) -> GraphBack node nodeKey

-- | Get all nodes in the graph
getAllNodes :: GraphBack node nodeKey -> [node]

-- | If the node does not exist in the graph <a>Nothing</a>. Otherwise
--   <a>Just</a> key where key is a "nodeKey", an ordered key uniquely
--   distinguishing the node (and used to detect common elements in the two
--   graphs)
getKey :: GraphBack node nodeKey -> node -> (Maybe nodeKey)

-- | If node does not exist Nothing, otherwise immediate parents of node.
getParents :: GraphBack node nodeKey -> node -> (Maybe [node])


-- | NewNames is used for generating new names for Node's, Arc's,
--   NodeType's and ArcType's in a graph on a globally unique basis.
module Graphs.NewNames
data NameSource
data NameSourceBranch
branch :: NameSource -> IO NameSourceBranch
useBranch :: NameSourceBranch -> IO NameSource
initialBranch :: NameSourceBranch
getNewName :: NameSource -> IO String
data FrozenNameSource
freezeNameSource :: NameSource -> IO FrozenNameSource
defrostNameSource :: NameSource -> FrozenNameSource -> IO ()
instance Read FrozenNameSource
instance Show FrozenNameSource
instance Read NameSourceBranch
instance Show NameSourceBranch


-- | Graph defines the Graph class, which defines the basic things a graph
--   must do. Peculiarities: (1) Graphs are directed with labelled nodes
--   and arcs. These nodes and arcs have types. (2) The nodes and arcs are
--   identified by values of type Node and Arc. These values are
--   essentially strings. The strings are provided by the user; there is no
--   mechanism for generating new unique strings. (This is because this is
--   easy in the applications I have in mind.) (3) A necessary feature of
--   these graphs is that it is supposed to be easy generate copies, both
--   on the same system and on others.
module Graphs.Graph
class Graph graph
getNodes :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO [Node]
getArcs :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO [Arc]
getNodeTypes :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO [NodeType]
getArcTypes :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO [ArcType]
getArcsOut :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Node -> IO [Arc]
getArcsIn :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Node -> IO [Arc]
getNodeLabel :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Node -> IO nodeLabel
getNodeType :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Node -> IO NodeType
getNodeTypeLabel :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> NodeType -> IO nodeTypeLabel
getSource :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Arc -> IO Node
getTarget :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Arc -> IO Node
getArcLabel :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Arc -> IO arcLabel
getArcType :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Arc -> IO ArcType
getArcTypeLabel :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> ArcType -> IO arcTypeLabel
shareGraph :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> GraphConnection nodeLabel nodeTypeLabel arcLabel arcTypeLabel
newGraph :: Graph graph => GraphConnection nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO (graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
newNodeType :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> nodeTypeLabel -> IO NodeType
newNode :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> NodeType -> nodeLabel -> IO Node
newArcType :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> arcTypeLabel -> IO ArcType
newArc :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> ArcType -> arcLabel -> Node -> Node -> IO Arc
update :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO ()
newEmptyGraph :: Graph graph => IO (graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
data Node
data Arc
data NodeType
data ArcType
firstNode :: Node
data Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
NewNodeType :: NodeType -> nodeTypeLabel -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
SetNodeTypeLabel :: NodeType -> nodeTypeLabel -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
NewNode :: Node -> NodeType -> nodeLabel -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
DeleteNode :: Node -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
SetNodeLabel :: Node -> nodeLabel -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
SetNodeType :: Node -> NodeType -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
NewArcType :: ArcType -> arcTypeLabel -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
SetArcTypeLabel :: ArcType -> arcTypeLabel -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
NewArc :: Arc -> ArcType -> arcLabel -> Node -> Node -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
DeleteArc :: Arc -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
SetArcLabel :: Arc -> arcLabel -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
SetArcType :: Arc -> ArcType -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
MultiUpdate :: [Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel] -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel
data CannedGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel
CannedGraph :: [Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel] -> CannedGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel
updates :: CannedGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> [Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel]
type GraphConnection nodeLabel nodeTypeLabel arcLabel arcTypeLabel = (Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO ()) -> IO (GraphConnectionData nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
data GraphConnectionData nodeLabel nodeTypeLabel arcLabel arcTypeLabel
GraphConnectionData :: CannedGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO () -> (Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO ()) -> NameSourceBranch -> GraphConnectionData nodeLabel nodeTypeLabel arcLabel arcTypeLabel
graphState :: GraphConnectionData nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> CannedGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel
deRegister :: GraphConnectionData nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO ()
graphUpdate :: GraphConnectionData nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO ()
nameSourceBranch :: GraphConnectionData nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> NameSourceBranch
newtype PartialShow a
PartialShow :: a -> PartialShow a
instance Typeable ArcType
instance Typeable Arc
instance Typeable NodeType
instance Typeable Node
instance (Read nodeLabel, Read nodeTypeLabel, Read arcLabel, Read arcTypeLabel) => Read (CannedGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
instance (Show nodeLabel, Show nodeTypeLabel, Show arcLabel, Show arcTypeLabel) => Show (CannedGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
instance (Read nodeLabel, Read nodeTypeLabel, Read arcLabel, Read arcTypeLabel) => Read (Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
instance (Show nodeLabel, Show nodeTypeLabel, Show arcLabel, Show arcTypeLabel) => Show (Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
instance Eq ArcType
instance Ord ArcType
instance Eq Arc
instance Ord Arc
instance Eq NodeType
instance Ord NodeType
instance Eq Node
instance Ord Node
instance Show (PartialShow (CannedGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel))
instance Show (PartialShow (Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel))
instance Show (PartialShow a) => Show (PartialShow [a])
instance Read ArcType
instance Show ArcType
instance StringClass ArcType
instance Read Arc
instance Show Arc
instance StringClass Arc
instance Read NodeType
instance Show NodeType
instance StringClass NodeType
instance Read Node
instance Show Node
instance StringClass Node


-- | GraphConnection contains various operations on graph connections
module Graphs.GraphConnection
data SubGraph
SubGraph :: (Node -> Bool) -> (NodeType -> Bool) -> SubGraph
nodeIn :: SubGraph -> Node -> Bool
nodeTypeIn :: SubGraph -> NodeType -> Bool
attachSuperGraph :: SubGraph -> GraphConnection nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> GraphConnection nodeLabel nodeTypeLabel arcLabel arcTypeLabel
attachSubGraph :: SubGraph -> GraphConnection nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> GraphConnection nodeLabel nodeTypeLabel arcLabel arcTypeLabel
mapGraphConnection :: (nodeLabel1 -> (nodeLabel2, NodeType)) -> (arcLabel1 -> (arcLabel2, ArcType)) -> [Update nodeLabel2 nodeTypeLabel2 arcLabel2 arcTypeLabel2] -> GraphConnection nodeLabel1 () arcLabel1 () -> GraphConnection nodeLabel2 nodeTypeLabel2 arcLabel2 arcTypeLabel2


-- | The removeAncestors function in this module (actually an IO action)
--   takes a graph G and a list of nodes N and computes N' = { n in N |
--   there does not exist an m in N and a non-trivial path n -&gt; m }.
--   This is required for graph merging.
module Graphs.RemoveAncestors

-- | Takes a graph G and a list of nodes N and computes N' = { n in N |
--   there does not exist an m in N and a non-trivial path n -&gt; m }.
removeAncestors :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> [Node] -> IO [Node]

-- | General removeAncestors function, which takes as argument the action
--   computing a Node's successors.
removeAncestorsBy :: (Ord node, Monad m) => (node -> m [node]) -> [node] -> m [node]

-- | Pure version of <a>removeAncestorsBy</a>.
removeAncestorsByPure :: Ord node => (node -> [node]) -> [node] -> [node]


-- | This module contains various functions for operating on graphs
module Graphs.GraphOps
isAncestor :: Graph graph => graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Node -> Node -> IO Bool
isAncestorBy :: Ord key => (key -> IO [key]) -> key -> key -> IO Bool

module Graphs.GetAncestors
getAncestors :: Graph graph => Bool -> graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> (nodeLabel -> IO Bool) -> Node -> IO [Node]
getDescendants :: Graph graph => Bool -> graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> (nodeLabel -> IO Bool) -> Node -> IO [Node]
getAncestorsGeneric :: Ord node => Bool -> (node -> IO [node]) -> (node -> IO Bool) -> node -> IO [node]

-- | Returns True if first node is ancestor or equal to the second.
isAncestorPure :: Ord node => (node -> [node]) -> node -> node -> Bool

-- | Returns True if first node is ancestor or equal to the second.
isAncestor :: (Monad m, Ord node) => (node -> m [node]) -> node -> node -> m Bool
getAncestorsPure :: Ord node => (node -> [node]) -> node -> [node]


-- | This module implements a simple "pure" graph interface, destined to be
--   used for the complex graph operations required by VersionDag.
--   
--   We instance <a>Show</a> for debugging purposes.
module Graphs.PureGraph

-- | node given with their parent nodes. The parents should always come
--   before their children in the list.
newtype PureGraph nodeInfo arcInfo
PureGraph :: Map nodeInfo (NodeData nodeInfo arcInfo) -> PureGraph nodeInfo arcInfo
nodeDataFM :: PureGraph nodeInfo arcInfo -> Map nodeInfo (NodeData nodeInfo arcInfo)
data NodeData nodeInfo arcInfo
NodeData :: [ArcData nodeInfo arcInfo] -> NodeData nodeInfo arcInfo
parents :: NodeData nodeInfo arcInfo -> [ArcData nodeInfo arcInfo]
data ArcData nodeInfo arcInfo
ArcData :: arcInfo -> nodeInfo -> ArcData nodeInfo arcInfo
arcInfo :: ArcData nodeInfo arcInfo -> arcInfo
target :: ArcData nodeInfo arcInfo -> nodeInfo
emptyPureGraph :: Ord nodeInfo => PureGraph nodeInfo arcInfo

-- | add a node with given parent arcs from it.
addNode :: Ord nodeInfo => PureGraph nodeInfo arcInfo -> nodeInfo -> [(arcInfo, nodeInfo)] -> PureGraph nodeInfo arcInfo

-- | NB. The graph will end up ill-formed if you delete a node which has
--   parent arcs pointing to it.
deleteNode :: Ord nodeInfo => PureGraph nodeInfo arcInfo -> nodeInfo -> PureGraph nodeInfo arcInfo
mapArcInfo :: (arcInfo1 -> arcInfo2) -> PureGraph nodeInfo arcInfo1 -> PureGraph nodeInfo arcInfo2
parentNodes :: NodeData nodeInfo arcInfo -> [nodeInfo]
toAllNodes :: Ord nodeInfo => PureGraph nodeInfo arcInfo -> [nodeInfo]
toNodeParents :: Ord nodeInfo => PureGraph nodeInfo arcInfo -> nodeInfo -> Maybe [nodeInfo]
nodeExists :: Ord nodeInfo => PureGraph nodeInfo arcInfo -> nodeInfo -> Bool
instance (Show nodeInfo, Show arcInfo) => Show (ArcData nodeInfo arcInfo)
instance (Eq nodeInfo, Eq arcInfo) => Eq (ArcData nodeInfo arcInfo)
instance (Ord nodeInfo, Ord arcInfo) => Ord (ArcData nodeInfo arcInfo)
instance (Show nodeInfo, Show arcInfo) => Show (NodeData nodeInfo arcInfo)
instance (Eq nodeInfo, Eq arcInfo) => Eq (NodeData nodeInfo arcInfo)
instance (Ord nodeInfo, Ord arcInfo) => Ord (NodeData nodeInfo arcInfo)
instance Show (PartialShow (NodeData nodeInfo arcInfo))
instance Show (PartialShow (PureGraph nodeInfo arcInfo))
instance (Show nodeInfo, Show arcInfo) => Show (PureGraph nodeInfo arcInfo)


-- | The functions in this module implement pruning of <a>PureGraph</a>s,
--   to remove hidden nodes as far as possible, while still showing the
--   structure between non-hidden nodes.
--   
--   NB. It is assumed the PureGraph is acyclic!
module Graphs.PureGraphPrune

-- | Remove <a>hidden</a> vertices as far as possible from a graph, which
--   must be acyclic, while still preserving the structure as far as
--   possible.
pureGraphPrune :: (Ord nodeInfo, Ord arcInfo) => (nodeInfo -> Bool) -> PureGraph nodeInfo arcInfo -> PureGraph nodeInfo (Maybe arcInfo)

module Graphs.PureGraphMakeConsistent
pureGraphMakeConsistent :: Ord nodeInfo => PureGraph nodeInfo arcInfo -> PureGraph nodeInfo arcInfo


-- | SimpleGraph is, as the name implies, a simple implementation of the
--   Graph interface. For example, we don't bother to sort the arcs going
--   out of a node, meaning that to find out if two nodes are connected
--   requires searching all the arcs out of one of the nodes, or all the
--   arcs into the other.
--   
--   Notes on synchronicity. The Update operations Set*Label are
--   intrinsically unsafe in this implementation since if two communicating
--   SimpleGraphs both execute a Set*Label operation with different label
--   values they may end up with each others values. It is recommended that
--   Set*Label only be used during the initialisation of the object, as a
--   way of tieing the knot.
--   
--   In addition, Update operations which create a value based on a
--   previous value (EG a NewNode creates a Node based on a NodeType), do
--   assume that the previous value has already been created.
--   
--   I realise this is somewhat informal. It may be necessary to replace
--   SimpleGraph by something more complicated later . . .
module Graphs.SimpleGraph
data SimpleGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel
getNameSource :: SimpleGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> NameSource
delayedAction :: SimpleGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> Node -> IO () -> IO ()
data ClientData nodeLabel nodeTypeLabel arcLabel arcTypeLabel
ClientData :: ObjectID -> (Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO ()) -> ClientData nodeLabel nodeTypeLabel arcLabel arcTypeLabel
clientID :: ClientData nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> ObjectID
clientSink :: ClientData nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> (Update nodeLabel nodeTypeLabel arcLabel arcTypeLabel -> IO ())
instance Destroyable (SimpleGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
instance Graph SimpleGraph
instance Eq (ClientData nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
instance Object (SimpleGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel)
instance Synchronized (SimpleGraph nodeLabel nodeTypeLabel arcLabel arcTypeLabel)


-- | This module, given a changing source of <a>PureGraph</a>s, transforms
--   it into a <a>Graph</a>. -}
module Graphs.PureGraphToGraph
pureGraphToGraph :: (Ord nodeKey, Ord arcInfo, Eq nodeInfo) => SimpleSource (PureGraph nodeKey arcInfo, nodeKey -> nodeInfo) -> GraphConnection nodeInfo () arcInfo ()


-- | This module implements a VersionDag, a graph which is used for
--   displaying versions within the Workbench.
--   
--   The main differences between this and normal
--   <tt>SimpleGraph.SimpleGraph'</tt>s are that (1) the parents of a node
--   are fixed when it is created, as are all arc labels and arc type
--   labels. (2) it is possible to selectively <a>hide</a> nodes from being
--   displayed. We intelligently display the structure between these nodes.
--   (3) it is not permitted to delete a node with children. (Though it may
--   be hidden.)
module Graphs.VersionDag
data VersionDag nodeKey nodeInfo arcInfo
newVersionDag :: (Ord nodeKey, Ord arcInfo, Eq nodeInfo) => (nodeInfo -> Bool) -> (nodeInfo -> nodeKey) -> (nodeInfo -> [(arcInfo, nodeKey)]) -> IO (VersionDag nodeKey nodeInfo arcInfo)
addVersion :: (Ord nodeKey, Ord arcInfo, Eq nodeInfo) => VersionDag nodeKey nodeInfo arcInfo -> nodeInfo -> IO ()
addVersions :: (Ord nodeKey, Ord arcInfo, Eq nodeInfo) => VersionDag nodeKey nodeInfo arcInfo -> [nodeInfo] -> IO ()
deleteVersion :: Ord nodeKey => VersionDag nodeKey nodeInfo arcInfo -> nodeKey -> IO ()

-- | Change the nodeInfo of something already added.
setNodeInfo :: (Ord nodeKey, Ord arcInfo, Eq nodeInfo) => VersionDag nodeKey nodeInfo arcInfo -> nodeInfo -> IO ()

-- | Change the hidden function
changeIsHidden :: (Ord nodeKey, Ord arcInfo, Eq nodeInfo) => VersionDag nodeKey nodeInfo arcInfo -> (nodeInfo -> Bool) -> IO ()
toDisplayedGraph :: (Ord nodeKey, Ord arcInfo, Eq nodeInfo) => VersionDag nodeKey nodeInfo arcInfo -> GraphConnection (nodeInfo, Bool) () (Maybe arcInfo) ()
toInputGraph :: (Ord nodeKey, Ord arcInfo, Eq nodeInfo) => VersionDag nodeKey nodeInfo arcInfo -> GraphConnection nodeInfo () arcInfo ()

-- | Get the input graph in the form of FindCommonParents.GraphBack. NB.
--   (1) the confusion in the type variable <a>nodeKey</a> as used in
--   FindCommonParents is not the same as our <a>nodeKey</a>. (2) we get a
--   snapshot of the state of the input graph at a particular time
getInputGraphBack :: (Ord nodeKey, Ord arcInfo, Eq nodeInfo) => VersionDag nodeKey nodeInfo arcInfo -> (nodeKey -> nodeInfo -> graphBackNodeKey) -> IO (GraphBack nodeKey graphBackNodeKey)
nodeKeyExists :: Ord nodeKey => VersionDag nodeKey nodeInfo arcInfo -> nodeKey -> IO Bool
lookupNodeKey :: Ord nodeKey => VersionDag nodeKey nodeInfo arcInfo -> nodeKey -> IO (Maybe nodeInfo)
getNodeInfos :: Ord nodeKey => VersionDag nodeKey nodeInfo arcInfo -> IO [nodeInfo]


-- | In UniForM we need ways of displaying typed directed graphs. In the
--   original UniForM, it was only possible to use the DaVinci
--   encapsulation for displaying directed graphs. While this is very good,
--   in the new UniForM it is intended to factor out this encapsulation so
--   that it will not be too difficult to replace DaVinci by other
--   graph-drawing package (or variants of DaVinci) for particular graphs.
--   Example alternatives that might be considered: (1) some sort of
--   text-only interface. (2) Windows-style displaying of a tree structure
--   using clickable folders. In this module we present the classes that
--   any such "graph-drawing package" is supposed to implement.
--   
--   This module is in two parts.
--   
--   The first part contains the "user-friendly" versions of the functions.
--   For these, it is assumed (as will usually be the case) that there is
--   only one node/nodeType/arc/arcType around for a particular graph. The
--   whole lot is indexed by the GraphAll, which contains ALL the
--   functionality required for accessing the graphs (apart from
--   configuration options). For example, the only daVinci-specific thing
--   you should need to use to write a program which calls daVinci will be
--   the daVinciSort variable.
--   
--   The second part contains the "user-hateful" versions. All the
--   user-hateful functions have names ending in "Prim". Graph display
--   implementations only have to implement the user-hateful versions. The
--   user-hateful versions should only be of interest to other people if
--   the graph display provides more than one implementation of the
--   NodeClass, NodeTypeClass (or whatever) implementation. One
--   disadvantage to the user of using the user-hateful versions of the
--   functions is that because of all the overloading, you have to put in
--   lots of explicit types, or else get the most hideous type errors.
--   
--   Configuring things like graph titles, shape of node boxes, menus, and
--   so on should also be implemented, where possible, by graph display
--   interfaces. The various options are documented in GraphConfigure.hs.
--   They should be applied using the Computation.HasConfig interface.
--   
--   The types which are supposed in various combinations to be instances
--   of the classes are as follows:
--   
--   graph. This corresponds to one graph display. graphConfig. This is
--   configuration information for a graph. This might be a window title or
--   size for example. graphParms. This is a collection of graphConfig's
--   used to construct a graph.
--   
--   Nodes and arcs carry values. Thus all the following carry a type
--   parameter. But, for ease of implementation with, for example, DaVinci,
--   the type parameter is required to be an instance of <a>Typeable</a>.
--   
--   <ul>
--   <li>node. A value of this type is an actual node in a graph. (Will be
--   an instance of <a>Typeable</a> via <a>Typeable1</a>.)</li>
--   <li>nodeType. Nodes are created with a particular UniForM "type" which
--   is a Haskell value of type nodetype. In fact a graph might conceivably
--   have multiply Haskell types corresponding to node and nodeType,
--   meaning that nodes, or their UniForM types, will be distinguished
--   additionally by the Haskell type system.</li>
--   <li>nodeTypeConfig. Configuration information for a nodeType. This
--   might include how a node with this type is to be displayed
--   graphically. This also includes information on what to do when the
--   node is clicked.</li>
--   <li>nodeTypeParms. A collection of nodeTypeConfig's used to construct
--   a nodeType</li>
--   </ul>
--   
--   Similar constructions for arcs . . . arc. arcType. arcTypeConfig.
--   arcTypeParms.
--   
--   There are quite a lot of classes. This is partly because of the need
--   to have a separate class for each subset of the type variables which
--   is actually used in the type of a function.
--   
--   This file is fairly repetitive, mainly because of the need to repeat
--   the configuration machinery over and over again.
--   
--   The functionality provided in this file is inspired by that provided
--   by DaVinci. However we extend it by allowing nodes to have labels.
--   
--   This file should be read in conjunction with <a>GraphConfigure</a>,
--   which contains various configuration options to be used for graph
--   objects.
--   
--   Additional Notes ----------------
--   
--   <ol>
--   <li>At the end of a program using a GraphDisp instance,
--   <tt>shutdown</tt> should be called. For example, in the case of the
--   DaVinci instance this is required to get rid of the DaVinci and HTk
--   processes.</li>
--   <li>It is more cumbersome writing the Graph Editor than I would like
--   because the menu code doesn't give you direct access to the node or
--   arc type. Unfortunately doing this would make the classes in this file
--   even more complicated than they are now.</li>
--   </ol>
module Graphs.GraphDisp

-- | The graph implementation will provide a value of this type to get you
--   started. For example, for daVinci this is called <tt>daVinciSort</tt>.
--   However you then need to use it as an argument to <a>newGraph</a> to
--   construct the actual graph.
newtype GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms => Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms
Graph :: graph -> Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms

-- | Construct a new graph. The input value will be something like
--   <a>DaVinciGraph</a>'s value <tt>daVinciSort</tt>; the resulting graph
--   will be returned.
newGraph :: GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> graphParms -> IO (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms)

-- | Redraw the graph. This is needed when you want to show updates.
redraw :: GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> IO ()

-- | Take over all interaction on the graph, and perform the given action,
--   supplying it with an event which is activated when the user
--   double-clicks a node. This is helpful when you need an interaction
--   selecting several nodes.
getMultipleNodes :: GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> (Event (WrappedNode node) -> IO a) -> IO a
class GraphParms graphParms
emptyGraphParms :: GraphParms graphParms => graphParms

-- | construct a new node.
newNode :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> nodeType value -> value -> IO (node value)

-- | set a node's type
setNodeType :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> node value -> nodeType value -> IO ()

-- | delete a node
deleteNode :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> node value -> IO ()
setNodeFocus :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> node value -> IO ()

-- | get the value associated with a node
getNodeValue :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> node value -> IO value

-- | set the value associated with a node.
setNodeValue :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> node value -> value -> IO ()

-- | construct a node type.
newNodeType :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> nodeTypeParms value -> IO (nodeType value)
class NodeTypeParms nodeTypeParms
emptyNodeTypeParms :: (NodeTypeParms nodeTypeParms, Typeable value) => nodeTypeParms value
coMapNodeTypeParms :: (NodeTypeParms nodeTypeParms, Typeable value1, Typeable value2) => (value2 -> value1) -> nodeTypeParms value1 -> nodeTypeParms value2

-- | construct a new arc.
newArc :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value, Typeable nodeFromValue, Typeable nodeToValue) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> arcType value -> value -> node nodeFromValue -> node nodeToValue -> IO (arc value)
data WrappedNode node
WrappedNode :: (node value) -> WrappedNode node

-- | Given a node, construct a <a>ListDrawer</a> which can be used as a way
--   of drawing ordered sets of out-arcs from that node. (NB. At the moment
--   daVinci does not do this properly, but that is daVinci's fault, not
--   mine.)
newArcListDrawer :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value, Typeable nodeFromValue) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> node nodeFromValue -> ListDrawer (arcType value, value, WrappedNode node) (arc value)

-- | delete an arc
deleteArc :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> arc value -> IO ()

-- | set the value associated with an arc
setArcValue :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> arc value -> value -> IO ()
setArcType :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> arc value -> arcType value -> IO ()

-- | get the value associated with an arc
getArcValue :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> arc value -> IO value

-- | create a new arc type
newArcType :: (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable value) => (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> arcTypeParms value -> IO (arcType value)
class ArcTypeParms arcTypeParms
emptyArcTypeParms :: (ArcTypeParms arcTypeParms, Typeable value) => arcTypeParms value
invisibleArcTypeParms :: (ArcTypeParms arcTypeParms, Typeable value) => arcTypeParms value
coMapArcTypeParms :: (ArcTypeParms arcTypeParms, Typeable value1, Typeable value2) => (value2 -> value1) -> arcTypeParms value1 -> arcTypeParms value2
class Eq1 takesParm
eq1 :: Eq1 takesParm => takesParm value1 -> takesParm value1 -> Bool
class Eq1 takesParm => Ord1 takesParm
compare1 :: Ord1 takesParm => takesParm value1 -> takesParm value1 -> Ordering
class (GraphClass graph, NewGraph graph graphParms, GraphParms graphParms, NewNode graph node nodeType, DeleteNode graph node, SetNodeFocus graph node, NodeClass node, Typeable1 node, NodeTypeClass nodeType, NewNodeType graph nodeType nodeTypeParms, NodeTypeParms nodeTypeParms, NewArc graph node node arc arcType, SetArcType graph arc arcType, DeleteArc graph arc, ArcClass arc, Typeable1 arc, ArcTypeClass arcType, NewArcType graph arcType arcTypeParms) => GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms
displaySort :: GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms => Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms
class (Destructible graph, Ord graph, Typeable graph, HasDelayer graph) => GraphClass graph
redrawPrim :: GraphClass graph => graph -> IO ()
class (GraphClass graph, GraphParms graphParms) => NewGraph graph graphParms
newGraphPrim :: NewGraph graph graphParms => graphParms -> IO graph
class GraphConfig graphConfig
class (GraphClass graph, NodeClass node, NodeTypeClass nodeType) => NewNode graph node nodeType
newNodePrim :: (NewNode graph node nodeType, Typeable value) => graph -> nodeType value -> value -> IO (node value)
setNodeTypePrim :: (NewNode graph node nodeType, Typeable value) => graph -> node value -> nodeType value -> IO ()
class (GraphClass graph, NodeClass node) => DeleteNode graph node
deleteNodePrim :: (DeleteNode graph node, Typeable value) => graph -> node value -> IO ()
getNodeValuePrim :: (DeleteNode graph node, Typeable value) => graph -> node value -> IO value
setNodeValuePrim :: (DeleteNode graph node, Typeable value) => graph -> node value -> value -> IO ()
getMultipleNodesPrim :: DeleteNode graph node => graph -> (Event (WrappedNode node) -> IO a) -> IO a
class (GraphClass graph, NodeClass node) => SetNodeFocus graph node
setNodeFocusPrim :: (SetNodeFocus graph node, Typeable value) => graph -> node value -> IO ()
class (Typeable1 node, Ord1 node) => NodeClass node
class Typeable1 nodeType => NodeTypeClass nodeType
class (GraphClass graph, NodeTypeClass nodeType, NodeTypeParms nodeTypeParms) => NewNodeType graph nodeType nodeTypeParms
newNodeTypePrim :: (NewNodeType graph nodeType nodeTypeParms, Typeable value) => graph -> nodeTypeParms value -> IO (nodeType value)
class Kind1 nodeTypeConfig => NodeTypeConfig nodeTypeConfig
class (GraphClass graph, NodeClass nodeFrom, NodeClass nodeTo, ArcClass arc, ArcTypeClass arcType) => NewArc graph nodeFrom nodeTo arc arcType
newArcPrim :: (NewArc graph nodeFrom nodeTo arc arcType, Typeable value, Typeable nodeFromValue, Typeable nodeToValue) => graph -> arcType value -> value -> nodeFrom nodeFromValue -> nodeTo nodeToValue -> IO (arc value)
newArcListDrawerPrim :: (NewArc graph nodeFrom nodeTo arc arcType, Typeable value, Typeable nodeFromValue) => graph -> nodeFrom nodeFromValue -> ListDrawer (arcType value, value, WrappedNode nodeTo) (arc value)
class (ArcClass arc, ArcTypeClass arcType) => SetArcType graph arc arcType
setArcTypePrim :: (SetArcType graph arc arcType, Typeable value) => graph -> arc value -> arcType value -> IO ()
class (GraphClass graph, ArcClass arc) => DeleteArc graph arc
deleteArcPrim :: (DeleteArc graph arc, Typeable value) => graph -> arc value -> IO ()
setArcValuePrim :: (DeleteArc graph arc, Typeable value) => graph -> arc value -> value -> IO ()
getArcValuePrim :: (DeleteArc graph arc, Typeable value) => graph -> arc value -> IO value
class (Typeable1 arc, Ord1 arc) => ArcClass arc
class (Typeable1 arcType, Ord1 arcType) => ArcTypeClass arcType
invisibleArcType :: (ArcTypeClass arcType, Typeable value) => arcType value
class (GraphClass graph, ArcTypeClass arcType, ArcTypeParms arcTypeParms) => NewArcType graph arcType arcTypeParms
newArcTypePrim :: (NewArcType graph arcType arcTypeParms, Typeable value) => graph -> arcTypeParms value -> IO (arcType value)
class Kind1 arcTypeConfig => ArcTypeConfig arcTypeConfig
instance Eq graph => Eq (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms)
instance Ord graph => Ord (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms)
instance Kind3 takesParms
instance Kind2 takesParms
instance Kind1 takesParm
instance (GraphClass graph, NewGraph graph graphParms, GraphParms graphParms, NewNode graph node nodeType, DeleteNode graph node, SetNodeFocus graph node, NodeClass node, NodeTypeClass nodeType, NewNodeType graph nodeType nodeTypeParms, NodeTypeParms nodeTypeParms, NewArc graph node node arc arcType, SetArcType graph arc arcType, DeleteArc graph arc, ArcClass arc, ArcTypeClass arcType, NewArcType graph arcType arcTypeParms) => GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms
instance GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms => HasDelayer (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms)
instance GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms => Destructible (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms)
instance GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms => Destroyable (Graph graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms)


-- | GraphConfigure contains definitions for the various configuration
--   options for <a>GraphDisp</a> objects. These should be implemented
--   using the <a>HasConfig</a>, <a>HasConfigValue</a> and
--   <a>ModifyHasDef</a>, applied to instances of <a>GraphParms</a>,
--   <a>NodeTypeParms</a> and <a>ArcTypeParms</a>.
module Graphs.GraphConfigure
class (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, HasGraphConfigs graphParms, HasNodeTypeConfigs nodeTypeParms, HasNodeModifies graph node, HasArcTypeConfigs arcTypeParms) => GraphAllConfig graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms
class (GraphParms graphParms, HasConfig GlobalMenu graphParms, HasConfig GraphTitle graphParms, HasConfig GraphGesture graphParms, HasConfig OptimiseLayout graphParms, HasConfig SurveyView graphParms, HasConfig AllowDragging graphParms, HasConfig AllowClose graphParms, HasConfig Orientation graphParms, HasConfig FileMenuAct graphParms, HasConfig ActionWrapper graphParms, HasConfig (SimpleSource GraphTitle) graphParms, HasConfig Delayer graphParms) => HasGraphConfigs graphParms
class (NodeTypeParms nodeTypeParms, HasConfigValue LocalMenu nodeTypeParms, HasConfigValue ValueTitle nodeTypeParms, HasConfigValue ValueTitleSource nodeTypeParms, HasConfigValue FontStyleSource nodeTypeParms, HasConfigValue BorderSource nodeTypeParms, HasConfigValue NodeGesture nodeTypeParms, HasConfigValue NodeDragAndDrop nodeTypeParms, HasConfigValue DoubleClickAction nodeTypeParms, HasConfigValue Shape nodeTypeParms, HasConfigValue Color nodeTypeParms) => HasNodeTypeConfigs nodeTypeParms
class HasModifyValue NodeArcsHidden graph node => HasNodeModifies graph node
class (ArcTypeParms arcTypeParms, HasConfigValue DoubleClickAction arcTypeParms, HasConfigValue LocalMenu arcTypeParms, HasConfigValue ValueTitle arcTypeParms, HasConfigValue Color arcTypeParms, HasConfigValue EdgePattern arcTypeParms, HasConfigValue EdgeDir arcTypeParms, HasConfigValue Head arcTypeParms) => HasArcTypeConfigs arcTypeParms
class HasConfig option configuration
($$) :: HasConfig option configuration => option -> configuration -> configuration
configUsed :: HasConfig option configuration => option -> configuration -> Bool
class HasConfigValue option configuration
($$$) :: (HasConfigValue option configuration, Typeable value) => option value -> configuration value -> configuration value
configUsed' :: (HasConfigValue option configuration, Typeable value) => option value -> configuration value -> Bool
class HasModifyValue option graph object
modify :: (HasModifyValue option graph object, Typeable value) => option -> graph -> object value -> IO ()
newtype LocalMenu value
LocalMenu :: (MenuPrim (Maybe String) (value -> IO ())) -> LocalMenu value
newtype GlobalMenu
GlobalMenu :: (MenuPrim (Maybe String) (IO ())) -> GlobalMenu

-- | As a service to MMiSS we provide a function which combines several
--   GlobalMenus into one.
combineGlobalMenus :: [GlobalMenu] -> GlobalMenu
data MenuPrim subMenuValue value :: * -> * -> *
Button :: String -> value -> MenuPrim subMenuValue value
Menu :: subMenuValue -> [MenuPrim subMenuValue value] -> MenuPrim subMenuValue value
Blank :: MenuPrim subMenuValue value
mapMenuPrim :: (a -> b) -> MenuPrim c a -> MenuPrim c b
mapMenuPrim' :: (c -> d) -> MenuPrim c a -> MenuPrim d a
mapMMenuPrim :: Monad m => (a -> m b) -> MenuPrim c a -> m (MenuPrim c b)
mapMMenuPrim' :: Monad m => (c -> m d) -> MenuPrim c a -> m (MenuPrim d a)
data GraphTitle
GraphTitle :: String -> GraphTitle

-- | Provide a function which computes a node or arc title string to be
--   displayed.
data ValueTitle value
ValueTitle :: (value -> IO String) -> ValueTitle value

-- | Provide a function which computes a source which generates a
--   dynamically- changing title.
data ValueTitleSource value
ValueTitleSource :: (value -> IO (SimpleSource String)) -> ValueTitleSource value

-- | This datatype is based on <a>DaVinciClasses</a>, including several
--   name clashes. However we omit <tt>Textual</tt>, add the file argument
--   to <a>Icon</a> and the shape <a>Triangle</a>. This datatype may get
--   bigger!
data Shape value
Box :: Shape value
Circle :: Shape value
Ellipse :: Shape value
Rhombus :: Shape value
Triangle :: Shape value
Icon :: FilePath -> Shape value

-- | The user is responsible for making sure this String is properly
--   formatted. To quote from the daVinci documentation:
--   
--   <pre>
--   Can be used to define the background color of a node. The value of this
--   attribute may be any X-Window colorname (see file lib/rgb.txt in your X11
--   directory) or any RGB color specification in a format like "#0f331e",
--   where 0f is the hexadecimal value for the red part of the color, 33 is
--   the green part and 1e is the blue.  Hence, a pallet of 16.7 million
--   colors is supported. The default color for nodes is "white".
--   </pre>
--   
--   There is a function for constructing "RGB color specification"s in
--   <a>Colour</a>.
newtype Color value
Color :: String -> Color value

-- | The pattern of an edge
data EdgePattern value
Solid :: EdgePattern value
Dotted :: EdgePattern value
Dashed :: EdgePattern value
Thick :: EdgePattern value
Double :: EdgePattern value

-- | The user is responsible for making sure this String is properly
--   formatted. To quote from the daVinci documentation:
--   
--   <pre>
--    This attribute is used to control the arrow of an edge. In a graph visualization,
--    each edge usually has an arrow pointing to the child node. This attribute can be
--    used to let the arrow be drawn inverse (i.e. pointing to the parent), to get an arrow
--    at both sides of an edge or to suppress arrows for a particular edge. The supported
--    attribute values are: "last" (1 arrow pointing to the child, default), \"first\"
--   (1 arrow to the parent), "both" (2 arrows to the parent and to children) and "none"
--   (no arrows).
--   </pre>
data EdgeDir value
Dir :: String -> EdgeDir value

-- | The user is responsible for making sure this String is properly
--   formatted. To quote from the daVinci documentation:
--   
--   <pre>
--    With this attribute you can control the shape of the edge's arrows.
--   The possible values are: "farrow" (default), "arrow", "fcircle", and "circle",
--   where a leading 'f' means filled.
--   </pre>
data Head value
Head :: String -> Head value

-- | If True, arcs from the node are not displayed.
newtype NodeArcsHidden
NodeArcsHidden :: Bool -> NodeArcsHidden

-- | The border of this node
data Border
NoBorder :: Border
SingleBorder :: Border
DoubleBorder :: Border

-- | Compute a <a>Border</a> which dynamically changes.
data BorderSource value
BorderSource :: (value -> IO (SimpleSource Border)) -> BorderSource value

-- | The font in which the label of this node is displayed.
data FontStyle
NormalFontStyle :: FontStyle
BoldFontStyle :: FontStyle
ItalicFontStyle :: FontStyle
BoldItalicFontStyle :: FontStyle

-- | Compute a <a>FontStyle</a> which dynamically changes.
data FontStyleSource value
FontStyleSource :: (value -> IO (SimpleSource FontStyle)) -> FontStyleSource value
class ModifyHasDef modification
def :: ModifyHasDef modification => modification
isDef :: ModifyHasDef modification => modification -> Bool

-- | Action to be performed after mouse action not involving any node but
--   somewhere on the graph.
--   
--   If you want to use this, the graph parameters need to include
--   <a>AllowDragging</a> <a>True</a>
data GraphGesture
GraphGesture :: (IO ()) -> GraphGesture

-- | Action to be performed when the user drags a node somewhere else, but
--   not onto another node.
--   
--   If you want to use this, the graph parameters need to include
--   <a>AllowDragging</a> <a>True</a>
data NodeGesture value
NodeGesture :: (value -> IO ()) -> NodeGesture value

-- | Action to be performed when the user drags one node onto another. The
--   dragged node's value is passed as a Dyn (since it could have any
--   type).
--   
--   If you want to use this, the graph parameters need to include
--   <a>AllowDragging</a> <a>True</a>
data NodeDragAndDrop value
NodeDragAndDrop :: (Dyn -> value -> IO ()) -> NodeDragAndDrop value

-- | Action to be performed when a node or arc is double-clicked.
newtype DoubleClickAction value
DoubleClickAction :: (value -> IO ()) -> DoubleClickAction value

-- | If <a>True</a>, try hard to optimise the layout of the graph on
--   redrawing it.
newtype OptimiseLayout
OptimiseLayout :: Bool -> OptimiseLayout

-- | If True, add a survey view of the graph; IE display a picture of the
--   whole graph which fits onto the screen (without displaying everything)
--   as well as a picture of the details (which may not fit onto the
--   screen).
--   
--   (The user can do this anyway from daVinci's menus.)
newtype SurveyView
SurveyView :: Bool -> SurveyView

-- | If True, allow Drag-and-Drop operators.
newtype AllowDragging
AllowDragging :: Bool -> AllowDragging

-- | If set, action which is invoked if the user attempts to close the
--   window. If the action returns True, we close it.
--   
--   WARNING. This action is performed in the middle of the event loop, so
--   please don't attempt to do any further graph interactions during it.
--   (But HTk interactions should be fine.)
newtype AllowClose
AllowClose :: (IO Bool) -> AllowClose
defaultAllowClose :: AllowClose
data FileMenuAct
FileMenuAct :: FileMenuOption -> (Maybe (IO ())) -> FileMenuAct

-- | The following options are provided specially by DaVinci (see, for now,
--   <a>http://www.informatik.uni-bremen.de/daVinci/old/docs/reference/api/api_app_menu_cmd.html</a>
--   for the daVinci2.1 documentation. If a <a>FileMenuAct</a> is used as a
--   configuration with a specified action, the corresponding option is
--   enabled in the daVinci File menu, and the action is performed when the
--   option is selected.
--   
--   The <a>AllowClose</a> configuration and <a>CloseMenuOption</a> both
--   set the action to be taken when the user selects a close event, and
--   each overrides the other.
--   
--   By default the Close and Print options are enabled, however these and
--   other options can be disabled by specifing <a>Nothing</a> as the
--   second argument to FileMenuAct.
data FileMenuOption
NewMenuOption :: FileMenuOption
OpenMenuOption :: FileMenuOption
SaveMenuOption :: FileMenuOption
SaveAsMenuOption :: FileMenuOption
PrintMenuOption :: FileMenuOption
CloseMenuOption :: FileMenuOption
ExitMenuOption :: FileMenuOption

-- | Which way up the graph is.
--   
--   We copy the DaVinciTypes constructors, though of course this will mean
--   we have to painfully convert one to the other.
data Orientation
TopDown :: Orientation
BottomUp :: Orientation
LeftRight :: Orientation
RightLeft :: Orientation

-- | Function to be applied to all user actions. This is useful for
--   exception wrappers and so on.
newtype ActionWrapper
ActionWrapper :: (IO () -> IO ()) -> ActionWrapper

-- | $$$? can be a useful abbreviation
($$$?) :: (HasConfigValue option configuration, Typeable value) => Maybe (option value) -> configuration value -> configuration value
instance [overlap ok] Ord FileMenuOption
instance [overlap ok] Eq FileMenuOption
instance [overlap ok] Eq FontStyle
instance [overlap ok] Read (Head value)
instance [overlap ok] Show (Head value)
instance [overlap ok] Read (EdgeDir value)
instance [overlap ok] Show (EdgeDir value)
instance [overlap ok] Read (EdgePattern value)
instance [overlap ok] Show (EdgePattern value)
instance [overlap ok] Read (Color value)
instance [overlap ok] Show (Color value)
instance [overlap ok] Read (Shape value)
instance [overlap ok] Show (Shape value)
instance [overlap ok] (GraphAll graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, HasGraphConfigs graphParms, HasNodeTypeConfigs nodeTypeParms, HasNodeModifies graph node, HasArcTypeConfigs arcTypeParms) => GraphAllConfig graph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms
instance [overlap ok] (ArcTypeParms arcTypeParms, HasConfigValue DoubleClickAction arcTypeParms, HasConfigValue LocalMenu arcTypeParms, HasConfigValue ValueTitle arcTypeParms, HasConfigValue Color arcTypeParms, HasConfigValue EdgePattern arcTypeParms, HasConfigValue EdgeDir arcTypeParms, HasConfigValue Head arcTypeParms) => HasArcTypeConfigs arcTypeParms
instance [overlap ok] HasModifyValue NodeArcsHidden graph node => HasNodeModifies graph node
instance [overlap ok] (NodeTypeParms nodeTypeParms, HasConfigValue LocalMenu nodeTypeParms, HasConfigValue ValueTitle nodeTypeParms, HasConfigValue ValueTitleSource nodeTypeParms, HasConfigValue FontStyleSource nodeTypeParms, HasConfigValue BorderSource nodeTypeParms, HasConfigValue NodeGesture nodeTypeParms, HasConfigValue NodeDragAndDrop nodeTypeParms, HasConfigValue DoubleClickAction nodeTypeParms, HasConfigValue Shape nodeTypeParms, HasConfigValue Color nodeTypeParms) => HasNodeTypeConfigs nodeTypeParms
instance [overlap ok] (GraphParms graphParms, HasConfig GlobalMenu graphParms, HasConfig GraphTitle graphParms, HasConfig GraphGesture graphParms, HasConfig OptimiseLayout graphParms, HasConfig SurveyView graphParms, HasConfig AllowDragging graphParms, HasConfig AllowClose graphParms, HasConfig Orientation graphParms, HasConfig FileMenuAct graphParms, HasConfig ActionWrapper graphParms, HasConfig (SimpleSource GraphTitle) graphParms, HasConfig Delayer graphParms) => HasGraphConfigs graphParms
instance [overlap ok] GraphConfig ActionWrapper
instance [overlap ok] GraphConfig Orientation
instance [overlap ok] GraphConfig AllowClose
instance [overlap ok] GraphConfig Delayer
instance [overlap ok] GraphConfig AllowDragging
instance [overlap ok] GraphConfig FileMenuAct
instance [overlap ok] GraphConfig SurveyView
instance [overlap ok] GraphConfig OptimiseLayout
instance [overlap ok] NodeTypeConfig FontStyleSource
instance [overlap ok] NodeTypeConfig BorderSource
instance [overlap ok] ModifyHasDef NodeArcsHidden
instance [overlap ok] ArcTypeConfig Head
instance [overlap ok] ArcTypeConfig EdgeDir
instance [overlap ok] ArcTypeConfig EdgePattern
instance [overlap ok] ArcTypeConfig Color
instance [overlap ok] NodeTypeConfig Color
instance [overlap ok] NodeTypeConfig Shape
instance [overlap ok] ArcTypeConfig DoubleClickAction
instance [overlap ok] NodeTypeConfig DoubleClickAction
instance [overlap ok] NodeTypeConfig NodeDragAndDrop
instance [overlap ok] HasCoMapIO NodeGesture
instance [overlap ok] NodeTypeConfig NodeGesture
instance [overlap ok] GraphConfig GraphGesture
instance [overlap ok] HasCoMapIO ValueTitle
instance [overlap ok] ArcTypeConfig ValueTitle
instance [overlap ok] NodeTypeConfig ValueTitleSource
instance [overlap ok] NodeTypeConfig ValueTitle
instance [overlap ok] GraphConfig (SimpleSource GraphTitle)
instance [overlap ok] GraphConfig GraphTitle
instance [overlap ok] HasCoMapIO LocalMenu
instance [overlap ok] ArcTypeConfig LocalMenu
instance [overlap ok] NodeTypeConfig LocalMenu
instance [overlap ok] GraphConfig GlobalMenu
instance [overlap ok] HasModifyValue option graph object => HasModifyValue (Maybe option) graph object
instance [overlap ok] (Typeable value, HasConfigValue option configuration) => HasConfig (option value) (configuration value)


-- | GetAttributes is used by the GraphEditor to pop up HTk windows to get
--   information from the user.
module Graphs.GetAttributes
data NodeTypeAttributes nodeLabel
NodeTypeAttributes :: Shape nodeLabel -> String -> NodeTypeAttributes nodeLabel
shape :: NodeTypeAttributes nodeLabel -> Shape nodeLabel
nodeTypeTitle :: NodeTypeAttributes nodeLabel -> String
getNodeTypeAttributes :: IO (Maybe (NodeTypeAttributes nodeLabel))
data NodeAttributes nodeType
NodeAttributes :: nodeType -> String -> NodeAttributes nodeType
nodeType :: NodeAttributes nodeType -> nodeType
nodeTitle :: NodeAttributes nodeType -> String
getNodeAttributes :: (Registry String nodeType) -> IO (Maybe (NodeAttributes nodeType))
data ArcTypeAttributes
ArcTypeAttributes :: String -> ArcTypeAttributes
arcTypeTitle :: ArcTypeAttributes -> String
getArcTypeAttributes :: IO (Maybe ArcTypeAttributes)
data ArcAttributes arcType
ArcAttributes :: arcType -> ArcAttributes arcType
arcType :: ArcAttributes arcType -> arcType
getArcAttributes :: (Registry String arcType) -> IO (Maybe (ArcAttributes arcType))
displayError :: String -> IO ()
instance Typeable CancelException
instance Typeable1 ArcAttributes
instance Typeable ArcTypeAttributes
instance Typeable1 NodeAttributes
instance Typeable1 NodeTypeAttributes
instance Read arcType => Read (ArcAttributes arcType)
instance Show arcType => Show (ArcAttributes arcType)
instance Read ArcTypeAttributes
instance Show ArcTypeAttributes
instance Show NodePreAttributes
instance Read nodeType => Read (NodeAttributes nodeType)
instance Show nodeType => Show (NodeAttributes nodeType)
instance Read (NodeTypeAttributes nodeLabel)
instance Show (NodeTypeAttributes nodeLabel)
instance Enum ShapeSort
instance Read ShapeSort
instance Show ShapeSort
instance GUIValue ShapeSort


-- | <a>displayGraph</a> displays something implementing the <a>Graph</a>
--   interface with something implementing with <a>GraphDisp</a> interface.
--   <a>displayGraph0</a> is a slightly more general version that also
--   returns the actual graph.
module Graphs.DisplayGraph
displayGraph :: (GraphAll dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable nodeLabel, Typeable nodeTypeLabel, Typeable arcLabel, Typeable arcTypeLabel, Graph graph) => (Graph dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> (graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel) -> graphParms -> (DisplayGraph -> NodeType -> nodeTypeLabel -> IO (nodeTypeParms Node)) -> (DisplayGraph -> ArcType -> arcTypeLabel -> IO (arcTypeParms Arc)) -> IO DisplayGraph
displayGraph0 :: (GraphAll dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable nodeLabel, Typeable nodeTypeLabel, Typeable arcLabel, Typeable arcTypeLabel, Graph graph) => (Graph dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> (graph nodeLabel nodeTypeLabel arcLabel arcTypeLabel) -> graphParms -> (DisplayGraph -> NodeType -> nodeTypeLabel -> IO (nodeTypeParms Node)) -> (DisplayGraph -> ArcType -> arcTypeLabel -> IO (arcTypeParms Arc)) -> IO (DisplayGraph, Graph dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms)
displayGraph1 :: (GraphAll dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, Typeable nodeLabel, Typeable nodeTypeLabel, Typeable arcLabel, Typeable arcTypeLabel) => (Graph dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> (GraphConnection nodeLabel nodeTypeLabel arcLabel arcTypeLabel) -> graphParms -> (DisplayGraph -> NodeType -> nodeTypeLabel -> IO (nodeTypeParms (Node, nodeLabel))) -> (DisplayGraph -> ArcType -> arcTypeLabel -> IO (arcTypeParms (Arc, arcLabel))) -> IO (DisplayGraph, Graph dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms)
data DisplayGraph
instance Destructible DisplayGraph
instance Destroyable DisplayGraph
instance Object DisplayGraph


-- | #
--   
--   This Graph Editor is inspired by the one by Einar Karlsen but uses the
--   new graph interface.
--   
--   #
module Graphs.GraphEditor
newGraphEditor :: (GraphAllConfig dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms, HasConfigValue Shape nodeTypeParms, Graph graph) => (Graph dispGraph graphParms node nodeType nodeTypeParms arc arcType arcTypeParms) -> Displayable graph -> IO GraphEditor
data GraphEditor
type Displayable graph = graph String (NodeTypeAttributes Node) () ArcTypeAttributes
type DisplayableUpdate = Update String (NodeTypeAttributes Node) () ArcTypeAttributes
type DisplayableGraphConnection = GraphConnection String (NodeTypeAttributes Node) () ArcTypeAttributes
type DisplayableCannedGraph = CannedGraph String (NodeTypeAttributes Node) () ArcTypeAttributes
instance Destructible GraphEditor
instance Destroyable GraphEditor
instance Object GraphEditor


-- | This module describes an empty display graph sort. In other words, it
--   displays nothing. Not a lot of use you might think, but we use it for
--   the MMiSS API to get a version graph without invoking daVinci.
module Graphs.EmptyGraphSort
emptyGraphSort :: Graph EmptyGraph EmptyGraphParms EmptyNode EmptyNodeType EmptyNodeTypeParms EmptyArc EmptyArcType EmptyArcTypeParms
instance Typeable1 EmptyArcType
instance Typeable1 EmptyArc
instance Typeable1 EmptyNodeType
instance Typeable1 EmptyNode
instance Typeable EmptyGraph
instance ArcTypeConfig arcTypeConfig => HasConfigValue arcTypeConfig EmptyArcTypeParms
instance DeleteArc EmptyGraph EmptyArc
instance SetArcType EmptyGraph EmptyArc EmptyArcType
instance NewArc EmptyGraph EmptyNode EmptyNode EmptyArc EmptyArcType
instance NewArcType EmptyGraph EmptyArcType EmptyArcTypeParms
instance ArcTypeParms EmptyArcTypeParms
instance ArcTypeClass EmptyArcType
instance ArcClass EmptyArc
instance Ord1 EmptyArcType
instance Eq1 EmptyArcType
instance Ord1 EmptyArc
instance Eq1 EmptyArc
instance HasModifyValue NodeArcsHidden EmptyGraph EmptyNode
instance HasModifyValue Border EmptyGraph EmptyNode
instance HasModifyValue FontStyle EmptyGraph EmptyNode
instance NodeTypeConfig nodeTypeConfig => HasConfigValue nodeTypeConfig EmptyNodeTypeParms
instance NewNodeType EmptyGraph EmptyNodeType EmptyNodeTypeParms
instance SetNodeFocus EmptyGraph EmptyNode
instance DeleteNode EmptyGraph EmptyNode
instance NewNode EmptyGraph EmptyNode EmptyNodeType
instance NodeTypeParms EmptyNodeTypeParms
instance NodeTypeClass EmptyNodeType
instance NodeClass EmptyNode
instance Ord1 EmptyNode
instance Eq1 EmptyNode
instance GraphConfig graphConfig => HasConfig graphConfig EmptyGraphParms
instance GraphParms EmptyGraphParms
instance NewGraph EmptyGraph EmptyGraphParms
instance GraphClass EmptyGraph
instance HasDelayer EmptyGraph
instance Destructible EmptyGraph
instance Destroyable EmptyGraph
instance Ord EmptyGraph
instance Eq EmptyGraph
instance GraphAllConfig EmptyGraph EmptyGraphParms EmptyNode EmptyNodeType EmptyNodeTypeParms EmptyArc EmptyArcType EmptyArcTypeParms
