-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | 3d math including quaternions/euler angles/dcms and utility functions
--   
@package spatial-math
@version 0.2.3.0

module SpatialMath

-- | 3-2-1 Euler angle rotation sequence
data Euler a
Euler :: a -> a -> a -> Euler a
eYaw :: Euler a -> a
ePitch :: Euler a -> a
eRoll :: Euler a -> a

-- | Rotate a vector about the X axis
--   
--   <pre>
--   &gt;&gt;&gt; trunc $ rotateXyzAboutX (V3 0 1 0) (pi/2)
--   V3 0.0 0.0 1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; trunc $ rotateXyzAboutX (V3 0 0 1) (pi/2)
--   V3 0.0 (-1.0) 0.0
--   </pre>
rotateXyzAboutX :: Floating a => V3 a -> a -> V3 a

-- | Rotate a vector about the Y axis
--   
--   <pre>
--   &gt;&gt;&gt; trunc $ rotateXyzAboutY (V3 0 0 1) (pi/2)
--   V3 1.0 0.0 0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; trunc $ rotateXyzAboutY (V3 1 0 0) (pi/2)
--   V3 0.0 0.0 (-1.0)
--   </pre>
rotateXyzAboutY :: Floating a => V3 a -> a -> V3 a

-- | Rotate a vector about the Z axis
--   
--   <pre>
--   &gt;&gt;&gt; trunc $ rotateXyzAboutZ (V3 1 0 0) (pi/2)
--   V3 0.0 1.0 0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; trunc $ rotateXyzAboutZ (V3 0 1 0) (pi/2)
--   V3 (-1.0) 0.0 0.0
--   </pre>
rotateXyzAboutZ :: Floating a => V3 a -> a -> V3 a

-- | Convert quaternion to Euler angles
--   
--   <pre>
--   &gt;&gt;&gt; euler321OfQuat (Quaternion 1.0 (V3 0.0 0.0 0.0))
--   Euler {eYaw = 0.0, ePitch = -0.0, eRoll = 0.0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; euler321OfQuat (Quaternion (sqrt(2)/2) (V3 (sqrt(2)/2) 0.0 0.0))
--   Euler {eYaw = 0.0, ePitch = -0.0, eRoll = 1.5707963267948966}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; euler321OfQuat (Quaternion (sqrt(2)/2) (V3 0.0 (sqrt(2)/2) 0.0))
--   Euler {eYaw = 0.0, ePitch = 1.5707963267948966, eRoll = 0.0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; euler321OfQuat (Quaternion (sqrt(2)/2) (V3 0.0 0.0 (sqrt(2)/2)))
--   Euler {eYaw = 1.5707963267948966, ePitch = -0.0, eRoll = 0.0}
--   </pre>
euler321OfQuat :: RealFloat a => Quaternion a -> Euler a

-- | Convert DCM to euler angles
--   
--   <pre>
--   &gt;&gt;&gt; euler321OfDcm $ V3 (V3 1 0 0) (V3 0 1 0) (V3 0 0 1)
--   Euler {eYaw = 0.0, ePitch = -0.0, eRoll = 0.0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; euler321OfDcm $ V3 (V3 0 1 0) (V3 (-1) 0 0) (V3 0 0 1)
--   Euler {eYaw = 1.5707963267948966, ePitch = -0.0, eRoll = 0.0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let s = sqrt(2)/2 in euler321OfDcm $ V3 (V3 s s 0) (V3 (-s) s 0) (V3 0 0 1)
--   Euler {eYaw = 0.7853981633974483, ePitch = -0.0, eRoll = 0.0}
--   </pre>
euler321OfDcm :: RealFloat a => M33 a -> Euler a

-- | Convert Euler angles to quaternion
--   
--   <pre>
--   &gt;&gt;&gt; quatOfEuler321 (Euler 0 0 0)
--   Quaternion 1.0 (V3 0.0 0.0 0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quatOfEuler321 (Euler (pi/2) 0 0)
--   Quaternion 0.7071067811865476 (V3 0.0 0.0 0.7071067811865475)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quatOfEuler321 (Euler 0 (pi/2) 0)
--   Quaternion 0.7071067811865476 (V3 0.0 0.7071067811865475 0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quatOfEuler321 (Euler 0 0 (pi/2))
--   Quaternion 0.7071067811865476 (V3 0.7071067811865475 0.0 0.0)
--   </pre>
quatOfEuler321 :: (Floating a, Ord a) => Euler a -> Quaternion a

-- | convert a quaternion to a DCM
--   
--   <pre>
--   &gt;&gt;&gt; dcmOfQuat $ Quaternion 1.0 (V3 0.0 0.0 0.0)
--   V3 (V3 1.0 0.0 0.0) (V3 0.0 1.0 0.0) (V3 0.0 0.0 1.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let s = sqrt(2)/2 in fmap trunc $ dcmOfQuat $ Quaternion s (V3 0.0 0.0 s)
--   V3 (V3 0.0 1.0 0.0) (V3 (-1.0) 0.0 0.0) (V3 0.0 0.0 1.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dcmOfQuat $ Quaternion 0.9238795325112867 (V3 0.0 0.0 0.3826834323650898)
--   V3 (V3 0.7071067811865475 0.7071067811865476 0.0) (V3 (-0.7071067811865476) 0.7071067811865475 0.0) (V3 0.0 0.0 1.0)
--   </pre>
dcmOfQuat :: Num a => Quaternion a -> M33 a
dcmOfQuatB2A :: (Conjugate a, RealFloat a) => Quaternion a -> M33 a

-- | Convert DCM to euler angles
--   
--   <pre>
--   &gt;&gt;&gt; dcmOfEuler321 $ Euler {eYaw = 0.0, ePitch = 0, eRoll = 0}
--   V3 (V3 1.0 0.0 0.0) (V3 0.0 1.0 0.0) (V3 0.0 0.0 1.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmap trunc $ dcmOfEuler321 $ Euler {eYaw = pi/2, ePitch = 0, eRoll = 0}
--   V3 (V3 0.0 1.0 0.0) (V3 (-1.0) 0.0 0.0) (V3 0.0 0.0 1.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dcmOfEuler321 $ Euler {eYaw = pi/4, ePitch = 0, eRoll = 0}
--   V3 (V3 0.7071067811865475 0.7071067811865476 0.0) (V3 (-0.7071067811865476) 0.7071067811865475 0.0) (V3 0.0 0.0 1.0)
--   </pre>
dcmOfEuler321 :: (Floating a, Ord a) => Euler a -> M33 a

-- | convert a DCM to a quaternion
--   
--   <pre>
--   &gt;&gt;&gt; quatOfDcm $ V3 (V3 1 0 0) (V3 0 1 0) (V3 0 0 1)
--   Quaternion 1.0 (V3 0.0 0.0 0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quatOfDcm $ V3 (V3 0 1 0) (V3 (-1) 0 0) (V3 0 0 1)
--   Quaternion 0.7071067811865476 (V3 0.0 0.0 0.7071067811865475)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let s = sqrt(2)/2 in quatOfDcm $ V3 (V3 s s 0) (V3 (-s) s 0) (V3 0 0 1)
--   Quaternion 0.9238795325112867 (V3 0.0 0.0 0.3826834323650898)
--   </pre>
quatOfDcm :: RealFloat a => M33 a -> Quaternion a
quatOfDcmB2A :: (Conjugate a, RealFloat a) => M33 a -> Quaternion a

-- | vec_b = R_a2b * vec_a
rotVecByDcm :: Num a => M33 a -> V3 a -> V3 a

-- | vec_a = R_a2b^T * vec_b
rotVecByDcmB2A :: Num a => M33 a -> V3 a -> V3 a

-- | vec_b = q_a2b * vec_a * q_a2b^(-1) vec_b = R(q_a2b) * vec_a
rotVecByQuat :: Num a => Quaternion a -> V3 a -> V3 a
rotVecByQuatB2A :: Num a => Quaternion a -> V3 a -> V3 a
rotVecByEuler :: (Floating a, Ord a) => Euler a -> V3 a -> V3 a
rotVecByEulerB2A :: (Floating a, Ord a) => Euler a -> V3 a -> V3 a

-- | A 3x3 matrix with row-major representation
type M33 a = V3 (V3 a)

-- | A 3-dimensional vector
data V3 a :: * -> *
V3 :: SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> V3 a

-- | Quaternions
data Quaternion a :: * -> *
Quaternion :: SrictNotUnpackeda -> SrictNotUnpacked(V3 a) -> Quaternion a

module SpatialMathT
class Rotation p a | p -> a
compose :: Rotation p a => Rot f1 f2 p -> Rot f2 f3 p -> Rot f1 f3 p
rot :: Rotation p a => Rot f1 f2 p -> V3T f1 a -> V3T f2 a
rot' :: Rotation p a => Rot f1 f2 p -> V3T f2 a -> V3T f1 a
toDcm :: Rotation p a => Rot f1 f2 p -> Rot f1 f2 (M33 a)
transpose :: Rotation p a => Rot f1 f2 p -> Rot f2 f1 p
newtype Rot f1 f2 r
Rot :: r -> Rot f1 f2 r
unR :: Rot f1 f2 r -> r
newtype V3T f a
V3T :: V3 a -> V3T f a
unV :: V3T f a -> V3 a
type M33T f1 f2 a = V3T f1 (V3T f2 a)
cross :: Num a => V3T f a -> V3T f a -> V3T f a
orthonormalize :: Floating a => Rot f1 f2 (M33 a) -> Rot f1 f2 (M33 a)
instance Functor (V3T f)
instance Foldable (V3T f)
instance Traversable (V3T f)
instance Applicative (V3T f)
instance Additive (V3T f)
instance Metric (V3T f)
instance Storable a => Storable (V3T f a)
instance Num a => Num (V3T f a)
instance Fractional a => Fractional (V3T f a)
instance Eq a => Eq (V3T f a)
instance Show a => Show (V3T f a)
instance Ord a => Ord (V3T f a)
instance Generic1 (V3T f)
instance Generic (V3T f a)
instance Serialize a => Serialize (V3T f a)
instance Binary a => Binary (V3T f a)
instance Functor (Rot f1 f2)
instance Foldable (Rot f1 f2)
instance Traversable (Rot f1 f2)
instance Storable r => Storable (Rot f1 f2 r)
instance Num r => Num (Rot f1 f2 r)
instance Fractional r => Fractional (Rot f1 f2 r)
instance Eq r => Eq (Rot f1 f2 r)
instance Show r => Show (Rot f1 f2 r)
instance Ord r => Ord (Rot f1 f2 r)
instance Generic1 (Rot f1 f2)
instance Generic (Rot f1 f2 r)
instance Serialize r => Serialize (Rot f1 f2 r)
instance Binary r => Binary (Rot f1 f2 r)
instance Datatype D1V3T
instance Constructor C1_0V3T
instance Selector S1_0_0V3T
instance Datatype D1Rot
instance Constructor C1_0Rot
instance Selector S1_0_0Rot
instance Num a => Rotation (M33 a) a
instance Num a => Rotation (Quaternion a) a
