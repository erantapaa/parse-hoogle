-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | DSMC library for rarefied gas dynamics
--   
--   DSMC library for rarefied gas dynamics
@package dsmc
@version 0.1.0.1


-- | Physical constants.
module DSMC.Util.Constants

-- | Atomic mass unit 1.660538921(73)e-27, inverse to Avogadro's constant.
amu :: Double

-- | Avogadro constant 6.02214129(27)e23
avogadro :: Double

-- | Boltzmann constant 1.3806488(13)e-23
boltzmann :: Double

-- | Universal gas constant.
unigas :: Double


-- | Simple 3-vectors and matrices built atop tuples.
module DSMC.Util.Vector

-- | Vector in <tt>R^3</tt>.
type Vec3 = (Double, Double, Double)

-- | Matrix given by its rows.
type Matrix = (Vec3, Vec3, Vec3)

-- | Point in <tt>R^3</tt>.
type Point = Vec3

-- | Origin point <tt>(0, 0, 0)</tt>.
origin :: Point

-- | Add two vectors.
(<+>) :: Vec3 -> Vec3 -> Vec3

-- | Subtract two vectors.
(<->) :: Vec3 -> Vec3 -> Vec3

-- | Vec3 cross product.
(><) :: Vec3 -> Vec3 -> Vec3

-- | Scale vector.
(.^) :: Vec3 -> Double -> Vec3

-- | Vec3 dot product.
(.*) :: Vec3 -> Vec3 -> Double

-- | Euclidean norm of vector.
norm :: Vec3 -> Double

-- | Produce unit vector with same direction as the original one.
normalize :: Vec3 -> Vec3

-- | Scale vector by -1.
invert :: Vec3 -> Vec3

-- | Euclidean distance between two points.
distance :: Point -> Point -> Double

-- | Move point by velocity vector for given time and return new position.
moveBy :: Point -> Vec3 -> Double -> Point

-- | Multiply matrix (given by row vectors) and vector
mxv :: Matrix -> Vec3 -> Vec3

-- | Transpose vector and multiply it by another vector, producing a
--   matrix.
vxv :: Vec3 -> Vec3 -> Matrix

-- | Generic vector dot product.
--   
--   Multiply transpose of first vector by given matrix, then multiply the
--   result by second vector.
dotM :: Vec3 -> Vec3 -> Matrix -> Double

-- | Produce matrix with diagonal elements equal to given value.
diag :: Double -> Matrix

-- | Add two matrices.
--   
--   We could add Applicative instance for Matrix and lift (+) to it.
addM :: Matrix -> Matrix -> Matrix

-- | Build cartesian axes from yaw and pitch with 0 roll. Angles are in
--   radians.
buildCartesian :: Double -> Double -> (Vec3, Vec3, Vec3)


-- | Gas-surface interaction models.
module DSMC.Surface

-- | A function which takes PRNG state, molecular velocity, surface normal
--   and samples post-collisional wrt to impregnable wall boundary
--   condition.
type Reflector s = GenST s -> Vec3 -> Vec3 -> ST s Vec3

-- | Surface models.
data Surface

-- | Cercignani-Lampis-Lord model.
CLL :: !Double -> !Double -> !Double -> Surface

-- | Absolute temperature of surface.
--   
--   Absolute temperature of surface.
bodyTemperature :: Surface -> !Double

-- | Kinetic energy accomodation for normal velocity component.
alpha :: Surface -> !Double

-- | Accomodation for tangential momentum.
sigma :: Surface -> !Double

-- | Diffuse reflection.
Diffuse :: !Double -> !Double -> Surface

-- | Absolute temperature of surface.
--   
--   Absolute temperature of surface.
bodyTemperature :: Surface -> !Double

-- | Mass of reflected molecules (usually equal to that in incident flow).
mass :: Surface -> !Double

-- | Surface with specular reflection.
Mirror :: Surface

-- | Produce reflector depending on surface type.
makeReflector :: Surface -> Reflector s


-- | Particles, ensembles, flow parameters.
module DSMC.Particles

-- | Gas particle with position and velocity.
type Particle = (Point, Vec3)

-- | Linearly move particle for t time and update its position.
move :: Time -> Particle -> Particle

-- | Repa array of particles.
type Ensemble = Array U DIM1 Particle

-- | Ensemble with zero particles in it.
emptyEnsemble :: Ensemble

-- | Amount of particles in an ensemble.
ensembleSize :: Ensemble -> Int

-- | Filter out those particles which do not satisfy the predicate.
filterEnsemble :: (Particle -> Bool) -> Ensemble -> Ensemble

-- | Print particles, one per row, using the format:
--   
--   <pre>
--   x y z u v w
--   </pre>
--   
--   where <tt>x y z</tt> are position coordinates and <tt>u v w</tt> are
--   velocity components. This is handy for debugging purposes.
printEnsemble :: Ensemble -> IO ()

-- | Flow with given concentration, temperature, mass of molecule and
--   macroscopic velocity.
data Flow
Flow :: !Double -> !Double -> !Double -> !Vec3 -> !Double -> Flow
concentration :: Flow -> !Double
temperature :: Flow -> !Double
mass :: Flow -> !Double
velocity :: Flow -> !Vec3

-- | How many real particles a single simulator represents.
statWeight :: Flow -> !Double

-- | Calculate model concentration to simulate real flow concentration wrt
--   statistical weight of single particle as set in flow options.
modelConcentration :: Flow -> Double
instance Show Flow


-- | Ray-casting routines for constructive solid geometry.
--   
--   This module provides constructors for complex bodies as well as
--   routines to compute intersections of such bodies with ray. In DSMC it
--   is used to calculate points at which particles hit the body surface.
--   
--   Gas-surface interactions are not handled by this module, see
--   <a>Surface</a> instead.
module DSMC.Traceables

-- | CSG body is a recursive composition of primitive objects or other
--   bodies.
data Body

-- | A half-space defined by arbitary point on the boundary plane and
--   outward normal (not necessarily a unit vector).
plane :: Point -> Vec3 -> Body

-- | A sphere defined by center point and radius.
sphere :: Vec3 -> Double -> Body

-- | An infinite circular cylinder defined by two arbitary points on axis
--   and radius.
cylinder :: Point -> Point -> Double -> Body

-- | A finite right circular cylinder defined by two points on its top and
--   bottom and radius.
cylinderFrustum :: Point -> Point -> Double -> Body

-- | An infinite right circular cone defined by outward axis vector, apex
--   point and angle between generatrix and axis (in degrees, less than
--   90).
cone :: Vec3 -> Point -> Double -> Body

-- | A conical frustum given by two points on its axis with radii at that
--   points. One of radii may be zero (in which case one of frustum ends
--   will be the apex).
coneFrustum :: (Point, Double) -> (Point, Double) -> Body

-- | Intersection of two bodies.
intersect :: Body -> Body -> Body

-- | Union of two bodies.
unite :: Body -> Body -> Body

-- | Complement to a body (normals flipped).
complement :: Body -> Body

-- | Time when particle hits the surface with normal at the hit point. If
--   hit is in infinity, then normal is Nothing.
--   
--   Note that this datatype is strict only on first argument: we do not
--   compare normals when classifying traces.
data HitPoint
HitPoint :: !Double -> (Maybe Vec3) -> HitPoint

-- | If the particle has hit the body during last time step, calculate the
--   first corresponding <a>HitPoint</a>. Note that the time at which the
--   hit occured will be negative. This is the primary function to
--   calculate ray-body intersections.
hitPoint :: Time -> Body -> Particle -> Maybe HitPoint

-- | A segment on time line when particle is inside the body.
--   
--   Using strict tuple performs better: 100 traces for 350K particles
--   perform roughly 7s against 8s with common datatypes.
type HitSegment = Pair HitPoint HitPoint

-- | Trace of a linearly-moving particle on a body is a list of time
--   segments/intervals during which the particle is inside the body.
--   
--   <pre>
--                   # - particle
--                    \
--                     \
--                      o------------
--                  ---/ *           \---
--                -/      *              \-
--               /         *               \
--              (           *  - trace      )
--               \           *             /
--                -\          *          /-
--   primitive -  ---\         *     /---
--                      --------o----
--                               \
--                                \
--                                _\/
--                                  \
--   </pre>
--   
--   For example, since a ray intersects a plane only once, a half-space
--   primitive defined by this plane results in a half-interval trace of a
--   particle:
--   
--   <pre>
--                                  /
--                                 /
--                                /
--      #------------------------o*****************&gt;
--      |                       /                  |
--   particle                  /            goes to infinity
--                            /
--                           /
--                          /
--                         / - surface of half-space
--   </pre>
--   
--   Ends of segments or intervals are calculated by intersecting the
--   trajectory ray of a particle and the surface of the primitive. This
--   may be done by substituting the equation of trajectory <tt>X(t) = X_o
--   + V*t</tt> into the equation which defines the surface and solving it
--   for <tt>t</tt>. If the body is a composition, traces from primitives
--   are then classified according to operators used to define the body
--   (union, intersection or complement).
--   
--   Although only convex primitives are used in current implementation,
--   compositions may result in concave bodies, which is why trace is
--   defined as a list of segments.
--   
--   In this example, body is an intersection of a sphere and sphere
--   complement:
--   
--   <pre>
--                               /|\
--                                |
--                                |
--                                |
--                  -----------   |
--             ----/           \--o-
--           -/                   * \-
--         -/               hs2 - *   \
--       -/                       * ---/
--      /                         o/
--     /                        -/|
--    /                        /  |
--    |                       /   |
--   /                        |   |
--   |                       /    |
--   |                       |    |
--   |                       \    |
--   \                        |   |
--    |                       \   |
--    \                        \  |
--     \                        -\|
--      \                         o\
--       -\                       * ---\
--         -\               hs1 - *   /
--           -\                   * /-
--             ----\           /--o-
--                  -----------   |
--                                |
--                                |
--                                # - particle
--   </pre>
--   
--   If only intersections of concave primitives were allowed, then trace
--   type might be simplified to be just single <a>HitSegment</a>.
type Trace = [HitSegment]

-- | Calculate a trace of a particle on a body.
trace :: Body -> Particle -> Trace

-- | True if particle is in inside the body.
inside :: Body -> Particle -> Bool
instance Eq HitPoint
instance Ord HitPoint
instance Show HitPoint
instance Show Body


-- | Parser for body definitions.
--   
--   Body definition contains a number of solid definitions and ends with
--   the top level object definition. RHS of solid equations may reference
--   other solids to compose into complex bodies.
--   
--   Multiple-body compositions are right-associative.
--   
--   <pre>
--   # comment
--   
--   # define few primitives
--   solid b1 = sphere (0, 0, 0; 5);
--   solid p1 = plane (0, 0, 0; 1, 0, 0);
--   
--   # define a composition
--   solid body = b1 and p1;
--   
--   # assign it to be the top level object
--   tlo body;
--   </pre>
--   
--   Statements must end with a semicolon (newlines are optional).
--   Excessive spaces are ignored.
--   
--   Top-level object line must reference a previously defined solid.
--   
--   Syntax for primitives follows the signatures of <tt>Traceables</tt>
--   constructors for <a>plane</a> and <a>sphere</a>, but differs for
--   cylinder and cone, as this module provides access only to frustums
--   (<a>cylinderFrustum</a> and <a>coneFrustum</a>).
--   
--   <ul>
--   <li><i>Half-space</i> <tt>plane (px, py, pz; nx, ny, nz)</tt>, where
--   <tt>(px, py, pz)</tt> is a point on a plane which defines the
--   half-space and <tt>(nx, ny, nz)</tt> is a normal to the plane (outward
--   to the half-space), not necessarily a unit vector.</li>
--   <li><i>Sphere</i> <tt>sphere (cx, cy, cz; r)</tt>, where <tt>(cx, cy,
--   cz)</tt> is a central point of a sphere and <tt>r</tt> is radius.</li>
--   <li><i>Right circular cylinder</i> <tt>cylinder (p1x, p1y, p1z; p2x,
--   p2y, p2z; r)</tt> where <tt>(p1x, p1y, p1z)</tt> and <tt>(p2x, p2y,
--   p2z)</tt> are bottom and top points on axis and <tt>r</tt> is
--   radius.</li>
--   <li><i>Right circular conical frustum</i> <tt>cone (p1x, p1y, p1z; r1;
--   p2x, p2y, p2z; r2)</tt> where <tt>(p1x, p1y, p1z)</tt> and <tt>(p2x,
--   p2y, p2z)</tt> are bottom and top points on cone axis and <tt>r1</tt>,
--   <tt>r2</tt> are the corresponding radii.</li>
--   </ul>
module DSMC.Traceables.Parser

-- | Try to read body definition from bytestring. Return body or error
--   message if parsing fails.
parseBody :: ByteString -> Either String Body

-- | Read body definition from file. If parsing fails or IOError when
--   reading file occurs, return error message.
parseBodyFile :: FilePath -> IO (Either String Body)


-- | Domain operations: defining domains; free flow boundary conditions
--   &amp; clipping for DSMC steps.
--   
--   PRNG required to sample molecular velocities implies monadic interface
--   for most of operations. We use functions specifically typed for
--   <a>ST</a>.
module DSMC.Domain

-- | Domain in which particles are spawned or system evolution is
--   simulated.
data Domain

-- | Rectangular volume, given by min/max value on every dimension.
Domain :: !Double -> !Double -> !Double -> !Double -> !Double -> !Double -> Domain

-- | Calculate width, length and height of a domain, which are dimensions
--   measured by x, y and z axes, respectively.
getDimensions :: Domain -> (Double, Double, Double)

-- | Calculate geometric center of a domain.
getCenter :: Domain -> Point

-- | Create a rectangular domain with center in the given point and
--   dimensions.
makeDomain :: Point -> Double -> Double -> Double -> Domain

-- | Fill the domain with particles for given flow parameters. Particles
--   inside the body are removed.
initializeParticles :: Domain -> Flow -> Body -> Seed -> (Ensemble, Seed)

-- | Sample new particles in 6 interface domains along each side of
--   rectangular simulation domain and add them to existing ensemble.
--   
--   This function implements open boundary condition for three-dimensional
--   simulation domain.
--   
--   Interface domains are built on faces of simulation domain using
--   extrusion along the outward normal of the face.
--   
--   In 2D projection:
--   
--   <pre>
--      +-----------------+
--      |    Interface1   |
--   +--+-----------------+--+
--   |I3|    Simulation   |I4|
--   |  |      domain     |  |
--   +--+-----------------+--+
--      |        I2       |
--      +-----------------+
--   </pre>
--   
--   Particles in every interface domain are spawned in parallel using
--   Strategies.
openBoundaryInjection :: DomainSeeds -> Domain -> Double -> Flow -> Ensemble -> (Ensemble, DomainSeeds)

-- | PRNG seeds used by particle generators.
type DomainSeeds = (Seed, Seed, Seed, Seed, Seed, Seed)

-- | Filter out particles which are outside of the domain.
clipToDomain :: Domain -> Ensemble -> Ensemble

-- | Volume of a domain unoccupied by a given body, in m^3.
--   
--   We use Monte Carlo method to calculate the approximate body volume and
--   then subtract it from the overall domain volume.
freeVolume :: Domain -> Body -> Int -> GenST s -> ST s (Double)

-- | Sequential <a>freeVolume</a> for a vector of domains.
freeVolumes :: Body -> Int -> GenST s -> Vector Domain -> ST s (Vector Double)
instance Show Domain


-- | Particle tracking for spatial grid for DSMC.
--   
--   This module is used to sort (classify) particles into ordered vector
--   of cells for collision step or macroscopic parameter sampling. We do
--   not provide any special cell datatype since it varies which cell data
--   is required on every step, so only particles in every cell are stored.
--   
--   Monad is provided for storing grid options during the whole program
--   run.
module DSMC.Cells

-- | Particles sorted by cells.
--   
--   We store contents of all cells in a single densely packed unboxed
--   vector. Additionally cell count, cell starting positions in vector
--   (<tt>s</tt>) and cell sizes (<tt>l</tt>) are stored.
--   
--   <pre>
--     s1         s2    s3
--     |          |     |
--   {[ooooooooo][oooo][oooooo]...}
--       cell1     c2     c3
--       l1=9      l2=4   l3=6
--   </pre>
--   
--   Note that any extra data about cells (like position or volume) should
--   be maintained separately from cell contents. We use this approach
--   because collision sampling and macroscopic parameter calculation
--   require different
data Cells

-- | Cell contents with particles.
type CellContents = Vector Particle

-- | Fetch contents of n-th cell.
getCell :: Cells -> Int -> Maybe CellContents

-- | Map a function over cell indices and contents of every cell.
cellMap :: (Int -> Maybe CellContents -> a) -> Cells -> Array D DIM1 a

-- | Assuming there's a linear ordering on all cells, Classifier must yield
--   index of cell for given particle.
type Classifier = Particle -> Int

-- | Classify particle ensemble into <tt>N</tt> cells using the classifier
--   function.
--   
--   Classifier's extent must match <tt>N</tt>, yielding numbers between
--   <tt>0</tt> and <tt>N-1</tt>.
classifyParticles :: (Int, Classifier) -> Ensemble -> Cells

-- | Domain divided in uniform grid with given steps by X, Y and Z axes.
data Grid
UniformGrid :: !Domain -> !Double -> !Double -> !Double -> Grid

-- | Return grid cell count and classifier for a grid.
makeUniformClassifier :: Grid -> (Int, Classifier)

-- | Return indexer for a grid.
makeUniformIndexer :: Grid -> Indexer

-- | Monad used to keep grid options and cell volumes. Due to the low-level
--   <a>Cells</a> structure we use to store particles sorted in cells,
--   things may break badly if improper/inconsistent classifier/indexer
--   parameters are used with cells structure. It also helps to maintain
--   precalculated cell volumes. See <tt>MacroSamplingMonad</tt>.
type GridMonad = ReaderT GridWares DSMCRootMonad

-- | Data stored in <a>GridMonad</a>.
data GridWares
GridWares :: (Int, Classifier) -> (Int -> Point) -> !(Vector Double) -> GridWares

-- | Cell count and classifier function.
classifier :: GridWares -> (Int, Classifier)
indexer :: GridWares -> Int -> Point

-- | Vector of cell volumes.
volumes :: GridWares -> !(Vector Double)

-- | Run action using spatial subdivision.
runGrid :: GridMonad a -> ParallelSeeds -> Grid -> Body -> Int -> DSMCRootMonad a

-- | Calculate volumes of grid cells wrt body within the domain. For every
--   cell, <a>freeVolume</a> is called with the domain of cell. Calculation
--   is performed in parallel.
--   
--   Since our grid are static, this is usually done only once when the
--   grid is first defined. We throw away the used seeds.
cellVolumes :: ParallelSeeds -> Grid -> Body -> Int -> (Vector Double)
instance Show Grid


-- | Macroscopic parameters calculation.
--   
--   We use regular spatial grid and time averaging for sampling. Sampling
--   should start after particle system has reached steady state. Samples
--   are then collected in each cell for a certain number of time steps.
--   
--   Sampling is performed in <a>MacroSamplingMonad</a> to ensure
--   consistency of averaging process. During sampling, basic parameters
--   are calculated like number of molecules per cell or mean square of
--   thermal velocity. After sampling these are used to derive final
--   (intensive) parameters like number density or temperature.
module DSMC.Macroscopic

-- | Vector which stores averaged macroscropic parameters in each cell.
--   
--   If samples are collected for M iterations, then this vector is built
--   as a sum of vectors <tt>V1, .. VM</tt>, where <tt>Vi</tt> is vector of
--   parameters sampled on <tt>i</tt>-th time step divided by <tt>M</tt>.
type MacroSamples = Array U DIM1 BasicMacroParameters

-- | Array of central points of grid cells with averaged macroscopic
--   parameters attached to every point.
type MacroField = Array U DIM1 (Point, IntensiveMacroParameters)

-- | Basic macroscopic parameters calculated in every cell: particle count,
--   mean absolute velocity, mean square of thermal velocity.
--   
--   Particle count is non-integer because of averaging.
--   
--   These are then post-processed into number density, flow velocity,
--   pressure and translational temperature.
--   
--   Note the lack of root on thermal velocity!
type BasicMacroParameters = (Double, Vec3, Double)

-- | Intensive macroscopic parameters available after averaging has
--   completed. These are: number density, absolute velocity, pressure and
--   translational temperature.
type IntensiveMacroParameters = (Double, Vec3, Double, Double)

-- | Monad which keeps track of sampling process data and stores options of
--   macroscopic sampling.
--   
--   GridMonad is used to ensure that only safe values for cell count and
--   classifier are used in <a>updateSamples</a> and
--   <tt>averageSamples</tt> (that may otherwise cause unbounded access
--   errors). Note that steady condition is not handled by this monad
--   (instead, caller code should decide when to start averaging).
--   
--   Inner Reader Monad stores averaging steps setting.
type MacroSamplingMonad = StateT SamplingState (ReaderT Int GridMonad)

-- | State of sampling process.
data SamplingState

-- | Sampling has not started yet.
None :: SamplingState

-- | Sampling is in progress, not enough samples yet. Integer field
--   indicates how many steps are left.
Incomplete :: Int -> MacroSamples -> SamplingState

-- | Averaging is complete, use <a>getField</a> to unload the samples.
Complete :: MacroSamples -> SamplingState

-- | Run <a>MacroSamplingMonad</a> action with given sampling options and
--   return final <a>Complete</a> state with macroscopic samples.
runMacroSampling :: MacroSamplingMonad r -> ParallelSeeds -> Grid -> Body -> Int -> Int -> DSMCRootMonad (r, SamplingState)

-- | Gather samples from ensemble. Return True if sampling is finished,
--   False otherwise.
updateSamples :: Ensemble -> MacroSamplingMonad Bool

-- | Fetch macroscopic field of intensive parameters if averaging is
--   complete.
getField :: Double -> Double -> MacroSamplingMonad (Maybe MacroField)


-- | Collisionless motion.
module DSMC.Motion

-- | Collisionless motion step.
motion :: ParallelSeeds -> Body -> Time -> Surface -> Ensemble -> (Ensemble, ParallelSeeds)


-- | DSMC is an algorithm used for simulating rarefied gas flows.
--   
--   You define the simulation domain, the body inside this domain, gas
--   flow parameters and several other options. DSMC iteratively models the
--   behaviour of gas molecules according to time and space decoupling
--   scheme for the Boltzmann equation. The result of simulation is a field
--   of macroscopic parameters across the simulation domain.
module DSMC

-- | Collisionless motion step.
motion :: ParallelSeeds -> Body -> Time -> Surface -> Ensemble -> (Ensemble, ParallelSeeds)

-- | Perform DSMC simulation, return total iterations count, final particle
--   distribution and field of averaged macroscopic parameters.
--   
--   This is an IO action since system entropy source is polled for seeds.
simulate :: Domain -> Body -> Flow -> Time -> Bool -> Double -> Double -> Int -> Surface -> (Double, Double, Double) -> Int -> Int -> IO (Int, Ensemble, MacroField)
