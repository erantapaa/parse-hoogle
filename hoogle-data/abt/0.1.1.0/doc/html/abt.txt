-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Abstract binding trees for Haskell
--   
--   A Haskell port of the Carnegie Mellon ABT library (SML), with some
--   improvements.
@package abt
@version 0.1.1.0

module Abt.Types.Nat
data Nat
Z :: Nat
S :: !Nat -> Nat
instance Typeable Nat
instance Typeable 'S
instance Typeable 'Z

module Abt.Class.HEq1

-- | Essentially, Martin-Löf's identity type.
data (:=:) a b
Refl :: a :=: a

-- | Type constructors are extensional.
cong :: a :=: b -> f a :=: f b

-- | Uniform variant of <a>Eq</a> for indexed types. This is different from
--   <a>Eq1</a> in that it is properly kind polymorphic and crucially
--   heterogeneous, and it places no constraint on the index. Because it is
--   heterogeneous, it is useful to project equality in the base space from
--   equality in the total space.
class HEq1 f where x === y = maybe False (const True) $ heq1 x y
heq1 :: HEq1 f => f i -> f j -> Maybe (i :=: j)
(===) :: HEq1 f => f i -> f j -> Bool
instance HEq1 el => HEq1 (Rec el)

module Abt.Types.View

-- | <tt>v</tt> is the type of variables; <tt>o</tt> is the type of
--   operators parameterized by arities; <tt>n</tt> is the "higher
--   type"/valence of the term (i.e. a term has <tt>n=0</tt>, a single
--   binding has <tt>n=1</tt>, etc.); <tt>φ</tt> is the functor which
--   interprets the inner structure of the view.
data View (v :: *) (o :: [Nat] -> *) (n :: Nat) (φ :: Nat -> *)
V :: v -> View0 v o φ
(:\) :: v -> φ n -> View v o (S n) φ
(:$) :: o ns -> Rec φ ns -> View0 v o φ

-- | First order term views.
type View0 v o φ = View v o Z φ

-- | A prism to extract arguments from a proposed operator.
--   
--   <pre>
--   <a>_ViewOp</a> ∷ <a>HEq1</a> o ⇒ o ns → Prism' (<a>View0</a> v o φ) (<a>Rec</a> φ ns)
--   </pre>
_ViewOp :: (Choice p, Applicative f, HEq1 o) => o ns -> p (Rec φ ns) (f (Rec φ ns)) -> p (View0 v o φ) (f (View0 v o φ))

-- | Views are a (higher) functor.
mapView :: (forall j. φ j -> ψ j) -> View v o n φ -> View v o n ψ
instance Typeable View


-- | The core structures used to define the Abt signatures.
module Abt.Types

module Abt.Class.Show1

-- | Uniform variant of <a>Show</a> for indexed types. This is different
--   from <a>Show1</a> in that it is properly kind polymorphic.
class Show1 f where showsPrec1 _ x = (show1 x ++) show1 x = showsPrec1 0 x ""
showsPrec1 :: Show1 f => Int -> f i -> ShowS
show1 :: Show1 f => f i -> String

module Abt.Class.Monad
class (Ord v, Eq v, Show v, Monad m, Applicative m) => MonadVar v m | m -> v
fresh :: MonadVar v m => m v
named :: MonadVar v m => String -> m v

module Abt.Class.Abt

-- | The <a>Abt</a> signature represents mediation between an arbitrary
--   (possibly nameless) term representaion, and a simple one (the
--   <a>View</a>). Based on the (effectful) ismorphism <tt><a>into</a> /
--   <a>out</a></tt> between representations, many operations can be
--   defined generically for arbitrary operator sets, including
--   substitution and aggregation of free variables.
class (Show1 o, Show v) => Abt (v :: *) (o :: [Nat] -> *) (t :: Nat -> *) | t -> v o where var = into . V v \\ e = into $ v :\ e o $$ es = into $ o :$ es subst e v e' = do { oe' <- out e'; case oe' of { V v' -> return $ if v == v' then e else e' v' :\ e'' -> (v' \\) <$> subst e v e'' o :$ es -> (o $$) <$> subst e v `rtraverse` es } } xe // e' = do { v :\ e <- out xe; subst e' v e } freeVars e = do { oe <- out e; case oe of { V v -> return [v] v :\ e' -> delete v <$> freeVars e' _ :$ es -> fmap concat . sequence . recordToList $ Const . freeVars <<$>> es } } toString e = do { vu <- out e; case vu of { V v -> return $ show v v :\ e' -> do { estr <- toString e'; return $ show v ++ "." ++ estr } o :$ RNil -> return $ show1 o o :$ es -> do { es' <- sequence . recordToList $ Const . toString <<$>> es; return $ show1 o ++ "[" ++ intercalate ";" es' ++ "]" } } }
into :: Abt v o t => View v o n t -> t n
out :: (Abt v o t, MonadVar v m) => t n -> m (View v o n t)
var :: Abt v o t => v -> t Z
(\\) :: Abt v o t => v -> t n -> t (S n)
($$) :: Abt v o t => o ns -> Rec t ns -> t Z
subst :: (Abt v o t, MonadVar v m) => t Z -> v -> t n -> m (t n)
(//) :: (Abt v o t, MonadVar v m) => t (S n) -> t Z -> m (t n)
freeVars :: (Abt v o t, MonadVar v m) => t n -> m [v]
toString :: (Abt v o t, MonadVar v m) => t n -> m String

module Abt.Concrete.LocallyNameless

-- | Locally nameless terms with operators in <tt>o</tt> at order
--   <tt>n</tt>.
data Tm (o :: [Nat] -> *) (n :: Nat)
Free :: Var -> Tm0 o
Bound :: Int -> Tm0 o
Abs :: Tm o n -> Tm o (S n)
App :: o ns -> Rec (Tm o) ns -> Tm0 o

-- | First order terms (i.e. terms not headed by abstractions).
type Tm0 o = Tm o Z

-- | A prism to extract arguments from a proposed operator.
--   
--   <pre>
--   <a>_TmOp</a> ∷ <a>HEq1</a> o ⇒ o ns → Prism' (<a>Tm0</a> o) (<a>Rec</a> (<a>Tm0</a> o) ns)
--   </pre>
_TmOp :: (Choice p, Applicative f, HEq1 o) => o ns -> p (Rec (Tm o) ns) (f (Rec (Tm o) ns)) -> p (Tm0 o) (f (Tm0 o))

-- | A variable is a De Bruijn index, optionally decorated with a display
--   name.
data Var
Var :: !(Maybe String) -> !Int -> Var
_varName :: Var -> !(Maybe String)
_varIndex :: Var -> !Int

-- | A lens for <a>_varName</a>.
--   
--   <pre>
--   <a>varName</a> ∷ Lens' <a>Var</a> (<a>Maybe</a> <a>String</a>)
--   </pre>
varName :: Functor f => (Maybe String -> f (Maybe String)) -> Var -> f Var

-- | A lens for <a>_varIndex</a>.
--   
--   <pre>
--   <a>varIndex</a> ∷ Lens' <a>Var</a> <a>Int</a>
--   </pre>
varIndex :: Functor f => (Int -> f Int) -> Var -> f Var
instance Typeable Var
instance Typeable Tm
instance Show1 o => Abt Var o (Tm o)
instance HEq1 o => HEq1 (Tm o)
instance Ord Var
instance Eq Var
instance Show Var


-- | The core signatures used to define abstract binding trees.
module Abt.Class

module Abt.Tutorial

-- | We'll start off with a monad in which to manipulate ABTs; we'll need
--   some state for fresh variable generation.
newtype M α
M :: State Int α -> M α
_M :: M α -> State Int α

-- | We'll run an ABT computation by starting the variable counter at
--   <tt>0</tt>.
runM :: M α -> α

-- | Check out the source to see fresh variable generation.

-- | Next, we'll define the operators for a tiny lambda calculus as a
--   datatype indexed by arities.
data Lang ns
LAM :: Lang '[S Z]
APP :: Lang '[Z, Z]
PI :: Lang '[Z, S Z]
UNIT :: Lang []
AX :: Lang []
lam :: Tm Lang (S Z) -> Tm0 Lang
app :: Tm0 Lang -> Tm0 Lang -> Tm0 Lang
ax :: Tm0 Lang
unit :: Tm0 Lang
pi :: Tm0 Lang -> Tm Lang (S Z) -> Tm0 Lang

-- | A monad transformer for small step operational semantics.
newtype StepT m α
StepT :: MaybeT m α -> StepT m α
runStepT :: StepT m α -> MaybeT m α

-- | To indicate that a term is in normal form.
stepsExhausted :: Applicative m => StepT m α

-- | A single evaluation step.
step :: Tm0 Lang -> StepT M (Tm0 Lang)

-- | The reflexive-transitive closure of a small-step operational
--   semantics.
star :: Monad m => (α -> StepT m α) -> (α -> m α)

-- | Evaluate a term to normal form
eval :: Tm0 Lang -> Tm0 Lang
newtype JudgeT m α
JudgeT :: ExceptT String m α -> JudgeT m α
runJudgeT :: JudgeT m α -> ExceptT String m α
type Ctx = [(Var, Tm0 Lang)]
raise :: Monad m => String -> JudgeT m α
checkTy :: Ctx -> Tm0 Lang -> Tm0 Lang -> JudgeT M ()
inferTy :: Ctx -> Tm0 Lang -> JudgeT M (Tm0 Lang)

-- | <pre>
--   λx.x
--   </pre>
identityTm :: M (Tm0 Lang)

-- | <pre>
--   (λx.x)(λx.x)
--   </pre>
appTm :: M (Tm0 Lang)

-- | A demonstration of evaluating (and pretty-printing). Output:
--   
--   <pre>
--   ap[lam[@2.@2];lam[@3.@3]] ~&gt;* lam[@4.@4]
--   </pre>
main :: IO ()
instance Functor M
instance Applicative M
instance Monad M
instance Monad m => Monad (StepT m)
instance Functor m => Functor (StepT m)
instance (Monad m, Functor m) => Applicative (StepT m)
instance (Monad m, Functor m) => Alternative (StepT m)
instance Monad m => Monad (JudgeT m)
instance Functor m => Functor (JudgeT m)
instance (Monad m, Functor m) => Applicative (JudgeT m)
instance (Monad m, Functor m) => Alternative (JudgeT m)
instance MonadVar Var m => MonadVar Var (JudgeT m)
instance MonadVar Var m => MonadVar Var (StepT m)
instance HEq1 Lang
instance Show1 Lang
instance MonadVar Var M
