-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Check properties on standard classes and data structures.
--   
@package checkers
@version 0.4.3

module Test.QuickCheck.Instances.Array
instance (Ix a, Integral a, CoArbitrary b) => CoArbitrary (Array a b)
instance (Ix a, Integral a, Arbitrary b) => Arbitrary (Array a b)

module Test.QuickCheck.Instances.Tuple

-- | Generates a 2-tuple using its arguments to generate the parts.
(>*<) :: Gen a -> Gen b -> Gen (a, b)

-- | Generates a 3-tuple using its arguments to generate the parts.
(>**<) :: Gen a -> Gen b -> Gen c -> Gen (a, b, c)

-- | Generates a 4-tuple using its arguments to generate the parts.
(>***<) :: Gen a -> Gen b -> Gen c -> Gen d -> Gen (a, b, c, d)

-- | Generates a 5-tuple using its arguments to generate the parts.
(>****<) :: Gen a -> Gen b -> Gen c -> Gen d -> Gen e -> Gen (a, b, c, d, e)

module Test.QuickCheck.Instances.Ord
greaterThan :: (Ord a, Arbitrary a) => a -> Gen a -> Gen a
lessThan :: (Ord a, Arbitrary a) => a -> Gen a -> Gen a

module Test.QuickCheck.Instances.Num
nonNegative :: (Num a, Arbitrary a) => Gen a
nonPositive :: (Num a, Arbitrary a) => Gen a
negative :: (Eq a, Num a, Arbitrary a) => Gen a
positive :: (Eq a, Num a, Arbitrary a) => Gen a
nonZero :: (Eq a, Num a, Arbitrary a) => Gen a -> Gen a
nonZero_ :: (Eq a, Num a, Arbitrary a) => Gen a

module Test.QuickCheck.Instances.Maybe
maybeGen :: Gen a -> Gen (Maybe a)

module Test.QuickCheck.Instances.List

-- | Generates any list (possibly empty) with the contents generated using
--   its argument.
anyList :: Gen a -> Gen [a]

-- | Generates a non-empty list with the contents generated using its
--   argument.
nonEmpty :: Gen a -> Gen [a]

-- | Generates an infinite list with contents generated using its argument
infiniteList :: Gen a -> Gen [a]

-- | Generates a list with a set length
setLength :: Int -> Gen a -> Gen [a]

-- | Generate increasing towards infinity
increasing :: (Arbitrary a, Eq a, Num a) => Gen [a]

-- | Generate nondecreasing values
nondecreasing :: (Arbitrary a, Num a) => Gen [a]

-- | Generate an infinite list of increasing values
increasingInf :: (Arbitrary a, Eq a, Num a) => Gen [a]

-- | Generate an infinite list of nondecreasing values
nondecreasingInf :: (Arbitrary a, Num a) => Gen [a]

-- | Generate increasing towards infinity
decreasing :: (Arbitrary a, Eq a, Num a) => Gen [a]

-- | Generate nondecreasing values
nonincreasing :: (Arbitrary a, Num a) => Gen [a]

-- | Generate an infinite list of increasing values
decreasingInf :: (Arbitrary a, Eq a, Num a) => Gen [a]

-- | Generate an infinite list of nondecreasing values
nonincreasingInf :: (Arbitrary a, Num a) => Gen [a]

module Test.QuickCheck.Bottoms
bottom :: Gen a
infiniteComp :: Gen a


-- | These are some general purpose utilities for use with QuickCheck.
--   
--   Copied from QuickCheck 1.2.0.0. Doesn't appear in 2.x
module Test.QuickCheck.Utils
isAssociativeBy :: (Show a, Testable prop) => (a -> a -> prop) -> Gen a -> (a -> a -> a) -> Property
isAssociative :: (Arbitrary a, Show a, Eq a) => (a -> a -> a) -> Property
isCommutableBy :: (Show a, Testable prop) => (b -> b -> prop) -> Gen a -> (a -> a -> b) -> Property
isCommutable :: (Arbitrary a, Show a, Eq b) => (a -> a -> b) -> Property
isTotalOrder :: (Arbitrary a, Show a, Ord a) => a -> a -> Property


-- | Some QuickCheck helpers
module Test.QuickCheck.Checkers

-- | Named test
type Test = (String, Property)

-- | Named batch of tests
type TestBatch = (String, [Test])

-- | Flatten a test batch for inclusion in another
unbatch :: TestBatch -> [Test]

-- | Run a batch of tests. See <a>quickBatch</a> and <a>verboseBatch</a>.
checkBatch :: Args -> TestBatch -> IO ()

-- | Check a batch tersely.
quickBatch :: TestBatch -> IO ()

-- | Check a batch verbosely.
verboseBatch :: TestBatch -> IO ()

-- | Unary function, handy for type annotations
type Unop a = a -> a

-- | Binary function, handy for type annotations
type Binop a = a -> a -> a
genR :: Random a => (a, a) -> Gen a

-- | <tt>f</tt> is a left inverse of <tt>g</tt>. See also <a>inverse</a>.
inverseL :: (EqProp b, Arbitrary b, Show b) => (a -> b) -> (b -> a) -> Property

-- | <tt>f</tt> is a left and right inverse of <tt>g</tt>. See also
--   <a>inverseL</a>.
inverse :: (EqProp a, Arbitrary a, Show a, EqProp b, Arbitrary b, Show b) => (a -> b) -> (b -> a) -> Property

-- | Token <a>Fractional</a> type for tests
type FracT = Float

-- | Token <a>Num</a> type for tests
type NumT = Int

-- | Token <a>Ord</a> type for tests
type OrdT = Int

-- | Token uninteresting type for tests
type T = Char

-- | Types of values that can be tested for equality, perhaps through
--   random sampling.
class EqProp a
(=-=) :: EqProp a => a -> a -> Property

-- | For <a>Eq</a> types as <a>EqProp</a> types
eq :: Eq a => a -> a -> Property
type BinRel a = a -> a -> Bool

-- | Reflexive property: <tt>a <tt>rel</tt> a</tt>
reflexive :: (Arbitrary a, Show a) => BinRel a -> Property

-- | Transitive property: <tt>a <tt>rel</tt> b &amp;&amp; b <tt>rel</tt> c
--   ==&gt; a <tt>rel</tt> c</tt>. Generate <tt>a</tt> randomly, but use
--   <tt>gen a</tt> to generate <tt>b</tt> and <tt>gen b</tt> to generate
--   <tt>c</tt>. <tt>gen</tt> ought to satisfy <tt>rel</tt> fairly often.
transitive :: (Arbitrary a, Show a) => BinRel a -> (a -> Gen a) -> Property

-- | Symmetric property: <tt>a <tt>rel</tt> b ==&gt; b <tt>rel</tt> a</tt>.
--   Generate <tt>a</tt> randomly, but use <tt>gen a</tt> to generate
--   <tt>b</tt>. <tt>gen</tt> ought to satisfy <tt>rel</tt> fairly often.
symmetric :: (Arbitrary a, Show a) => BinRel a -> (a -> Gen a) -> Property

-- | Symmetric property: <tt>a <tt>rel</tt> b &amp;&amp; b <tt>rel</tt> a
--   ==&gt; a == b</tt>. Generate <tt>a</tt> randomly, but use <tt>gen
--   a</tt> to generate <tt>b</tt>. <tt>gen</tt> ought to satisfy both
--   <tt>rel</tt> directions fairly often but not always.
antiSymmetric :: (Arbitrary a, Show a, Eq a) => BinRel a -> (a -> Gen a) -> Property

-- | Has a given left identity, according to '(=-=)'
leftId :: (Show a, Arbitrary a, EqProp a) => (i -> a -> a) -> i -> Property

-- | Has a given right identity, according to '(=-=)'
rightId :: (Show a, Arbitrary a, EqProp a) => (a -> i -> a) -> i -> Property

-- | Has a given left and right identity, according to '(=-=)'
bothId :: (Show a, Arbitrary a, EqProp a) => (a -> a -> a) -> a -> Property

-- | Associative, according to '(=-=)'
isAssoc :: (EqProp a, Show a, Arbitrary a) => (a -> a -> a) -> Property

-- | Commutative, according to '(=-=)'
isCommut :: (EqProp a, Show a, Arbitrary a) => (a -> a -> a) -> Property

-- | Commutative, according to '(=-=)'
commutes :: EqProp z => (a -> a -> z) -> a -> a -> Property

-- | Explicit <a>Monoid</a> dictionary. Doesn't have to correspond to an
--   actual <a>Monoid</a> instance, though see <a>monoidD</a>.
data MonoidD a

-- | <a>Monoid</a> dictionary built from the <a>Monoid</a> methods.
monoidD :: Monoid a => MonoidD a

-- | Monoid dictionary for an unwrapped endomorphism. See also
--   <a>monoidD</a> and <a>Endo</a>.
endoMonoidD :: MonoidD (a -> a)

-- | Homomorphism properties with respect to given monoid dictionaries. See
--   also <tt>monoidMorphism</tt>.
homomorphism :: (EqProp b, Show a, Arbitrary a) => MonoidD a -> MonoidD b -> (a -> b) -> [(String, Property)]

-- | The unary function <tt>f</tt> is idempotent, i.e., <tt>f . f == f</tt>
idempotent :: (Show a, Arbitrary a, EqProp a) => (a -> a) -> Property

-- | A binary function <tt>op</tt> is idempotent, i.e., <tt>x <tt>op</tt> x
--   == x</tt>, for all <tt>x</tt>
idempotent2 :: (Show a, Arbitrary a, EqProp a) => (a -> a -> a) -> Property

-- | A binary function <tt>op</tt> is has an idempotent element <tt>x</tt>,
--   i.e., <tt>x <tt>op</tt> x == x</tt>
idemElem :: EqProp a => (a -> a -> a) -> a -> Property
class Model a b | a -> b
model :: Model a b => a -> b
meq :: (Model a b, EqProp b) => a -> b -> Property
meq1 :: (Model a b, Model a1 b1, EqProp b) => (a1 -> a) -> (b1 -> b) -> a1 -> Property
meq2 :: (Model a b, Model a1 b1, Model a2 b2, EqProp b) => (a1 -> a2 -> a) -> (b1 -> b2 -> b) -> a1 -> a2 -> Property
meq3 :: (Model a b, Model a1 b1, Model a2 b2, Model a3 b3, EqProp b) => (a1 -> a2 -> a3 -> a) -> (b1 -> b2 -> b3 -> b) -> a1 -> a2 -> a3 -> Property
meq4 :: (Model a b, Model a1 b1, Model a2 b2, Model a3 b3, Model a4 b4, EqProp b) => (a1 -> a2 -> a3 -> a4 -> a) -> (b1 -> b2 -> b3 -> b4 -> b) -> a1 -> a2 -> a3 -> a4 -> Property
meq5 :: (Model a b, Model a1 b1, Model a2 b2, Model a3 b3, Model a4 b4, Model a5 b5, EqProp b) => (a1 -> a2 -> a3 -> a4 -> a5 -> a) -> (b1 -> b2 -> b3 -> b4 -> b5 -> b) -> a1 -> a2 -> a3 -> a4 -> a5 -> Property
eqModels :: (Model a b, EqProp b) => a -> a -> Property

-- | Like <a>Model</a> but for unary type constructors.
class Model1 f g | f -> g
model1 :: Model1 f g => f a -> g a

-- | Generate n arbitrary values
arbs :: Arbitrary a => Int -> IO [a]

-- | Produce n values from a generator
gens :: Int -> Gen a -> IO [a]

-- | Nondeterministic choice: <tt>p1</tt> <a>.&amp;.</a> <tt>p2</tt> picks
--   randomly one of <tt>p1</tt> and <tt>p2</tt> to test. If you test the
--   property 100 times it makes 100 random choices.
(.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
arbitrarySatisfying :: Arbitrary a => (a -> Bool) -> Gen a
instance (Testable a, Testable b) => Testable (a, b)
instance Testable a => Testable [a]
instance (Model a b, Model a' b') => Model (a, a') (b, b')
instance Model String String
instance Model Double Double
instance Model Float Float
instance Model Int Int
instance Model Char Char
instance Model Bool Bool
instance (Show a, Arbitrary a, EqProp b) => EqProp (a -> b)
instance (EqProp a, EqProp b) => EqProp (Either a b)
instance (EqProp a, EqProp b, EqProp c, EqProp d) => EqProp (a, b, c, d)
instance (EqProp a, EqProp b, EqProp c) => EqProp (a, b, c)
instance (EqProp a, EqProp b) => EqProp (a, b)
instance EqProp a => EqProp (Maybe a)
instance EqProp a => EqProp [a]
instance EqProp Double
instance EqProp Float
instance EqProp Int
instance EqProp Char
instance EqProp Bool

module Test.QuickCheck.Instances.Eq
notEqualTo :: (Eq a, Arbitrary a) => a -> Gen a -> Gen a
notOneof :: (Eq a, Arbitrary a) => [a] -> Gen a

module Test.QuickCheck.Instances.Char

-- | Generates a 'non space' character, i.e. any ascii except ' ', '\t',
--   '\n' and '\r'.
nonSpace :: Gen Char

-- | Generates any whitespace character, including new lines.
whitespace :: Gen Char

-- | Generates a whitespace charecter, not a newline.
space :: Gen Char

-- | Generates either a '\n' or '\r'.
newline :: Gen Char

-- | Generates any lower case alpha character.
lowerAlpha :: Gen Char

-- | Generates any upper case alpha character.
upperAlpha :: Gen Char

-- | Generates a digit character.
numeric :: Gen Char

-- | Generates one or other of '(' and ')'.
parenthesis :: Gen Char

-- | Generates one or other of '[' and ']'.
bracket :: Gen Char

-- | Generates one or other of '{' and '}'.
brace :: Gen Char

-- | Generates one of <a>*</a>, <a>/</a>, <a>-</a>, <a>+</a>, <a>&lt;</a>,
--   <a>&gt;</a>, '|' and '#'.
operator :: Gen Char


-- | Some QuickCheck properties for standard type classes
module Test.QuickCheck.Classes

-- | Total ordering. <tt>gen a</tt> ought to generate values <tt>b</tt>
--   satisfying <tt>a <tt>rel</tt> b</tt> fairly often.
ordRel :: (Ord a, Show a, Arbitrary a, EqProp a) => BinRel a -> (a -> Gen a) -> TestBatch

-- | Total ordering
ord :: (Ord a, Show a, Arbitrary a, EqProp a) => (a -> Gen a) -> TestBatch

-- | <a>Ord</a> morphism properties. <tt>h</tt> is an <a>Ord</a> morphism
--   iff:
--   
--   <pre>
--   a &lt;= b = h a &lt;= h b
--   
--   h (a `min` b) = h a `min` h b
--   h (a `max` b) = h a `max` h b
--   </pre>
ordMorphism :: (Ord a, Ord b, EqProp b, Show a, Arbitrary a) => (a -> b) -> TestBatch

-- | The semantic function (<a>model</a>) for <tt>a</tt> is an
--   <a>ordMorphism</a>.
semanticOrd :: (Model a b, Ord a, Ord b, Show a, Arbitrary a, EqProp b) => a -> TestBatch

-- | Properties to check that the <a>Monoid</a> <tt>a</tt> satisfies the
--   monoid properties. The argument value is ignored and is present only
--   for its type.
monoid :: (Monoid a, Show a, Arbitrary a, EqProp a) => a -> TestBatch

-- | Monoid homomorphism properties. See also <a>homomorphism</a>.
monoidMorphism :: (Monoid a, Monoid b, EqProp b, Show a, Arbitrary a) => (a -> b) -> TestBatch

-- | The semantic function (<a>model</a>) for <tt>a</tt> is a
--   <a>monoidMorphism</a>.
semanticMonoid :: (Model a b, Monoid a, Monoid b, Show a, Arbitrary a, EqProp b) => a -> TestBatch

-- | Properties to check that the <a>Functor</a> <tt>m</tt> satisfies the
--   functor properties.
functor :: (Functor m, Arbitrary a, Arbitrary b, Arbitrary c, CoArbitrary a, CoArbitrary b, Show (m a), Arbitrary (m a), EqProp (m a), EqProp (m c)) => m (a, b, c) -> TestBatch

-- | <a>Functor</a> morphism (natural transformation) properties
functorMorphism :: (Functor f, Functor g, Arbitrary (f NumT), Show (f NumT), EqProp (g T)) => (forall a. f a -> g a) -> TestBatch

-- | The semantic function (<a>model1</a>) for <tt>f</tt> is a
--   <a>functorMorphism</a>.
semanticFunctor :: (Model1 f g, Functor f, Functor g, Arbitrary (f NumT), Show (f NumT), EqProp (g T)) => f () -> TestBatch
functorMonoid :: (Functor m, Monoid (m a), Monoid (m b), Arbitrary (a -> b), Arbitrary (m a), Show (m a), EqProp (m b)) => m (a, b) -> TestBatch

-- | Properties to check that the <a>Applicative</a> <tt>m</tt> satisfies
--   the monad properties
applicative :: (Applicative m, Arbitrary a, CoArbitrary a, Arbitrary b, Arbitrary (m a), Arbitrary (m (b -> c)), Show (m (b -> c)), Arbitrary (m (a -> b)), Show (m (a -> b)), Show a, Show (m a), EqProp (m a), EqProp (m b), EqProp (m c)) => m (a, b, c) -> TestBatch

-- | <a>Applicative</a> morphism properties
applicativeMorphism :: (Applicative f, Applicative g, Show (f NumT), Arbitrary (f NumT), EqProp (g NumT), EqProp (g T), Show (f (NumT -> T)), Arbitrary (f (NumT -> T))) => (forall a. f a -> g a) -> TestBatch

-- | The semantic function (<a>model1</a>) for <tt>f</tt> is an
--   <a>applicativeMorphism</a>.
semanticApplicative :: (Model1 f g, Applicative f, Applicative g, Arbitrary (f NumT), Arbitrary (f (NumT -> T)), EqProp (g NumT), EqProp (g T), Show (f NumT), Show (f (NumT -> T))) => f () -> TestBatch

-- | Properties to check that the <a>Monad</a> <tt>m</tt> satisfies the
--   monad properties
monad :: (Monad m, Show a, Arbitrary a, CoArbitrary a, Arbitrary b, CoArbitrary b, Arbitrary (m a), EqProp (m a), Show (m a), Arbitrary (m b), EqProp (m b), Arbitrary (m c), EqProp (m c)) => m (a, b, c) -> TestBatch

-- | <a>Monad</a> morphism properties
--   
--   <a>Applicative</a> morphism properties
monadMorphism :: (Monad f, Monad g, Functor g, Show (f NumT), Show (f (NumT -> T)), Show (f (f (NumT -> T))), Arbitrary (f NumT), Arbitrary (f T), Arbitrary (f (NumT -> T)), Arbitrary (f (f (NumT -> T))), EqProp (g NumT), EqProp (g T), EqProp (g (NumT -> T))) => (forall a. f a -> g a) -> TestBatch

-- | The semantic function (<a>model1</a>) for <tt>f</tt> is a
--   <a>monadMorphism</a>.
semanticMonad :: (Model1 f g, Monad f, Monad g, EqProp (g T), EqProp (g NumT), EqProp (g (NumT -> T)), Arbitrary (f T), Arbitrary (f NumT), Arbitrary (f (f (NumT -> T))), Arbitrary (f (NumT -> T)), Show (f (f (NumT -> T))), Show (f (NumT -> T)), Show (f NumT), Functor g) => f () -> TestBatch

-- | Law for monads that are also instances of <a>Functor</a>.
monadFunctor :: (Functor m, Monad m, Arbitrary a, Arbitrary b, CoArbitrary a, Arbitrary (m a), Show (m a), EqProp (m b)) => m (a, b) -> TestBatch
monadApplicative :: (Applicative m, Monad m, EqProp (m a), EqProp (m b), Show a, Arbitrary a, Show (m a), Arbitrary (m a), Show (m (a -> b)), Arbitrary (m (a -> b))) => m (a, b) -> TestBatch
arrow :: (Arrow a, Show (a d e), Show (a c d), Show (a b c), Show b, Show c, Show d, Show e, Arbitrary (a d e), Arbitrary (a c d), Arbitrary (a b c), Arbitrary b, Arbitrary c, Arbitrary d, Arbitrary e, CoArbitrary b, CoArbitrary c, CoArbitrary d, EqProp (a b e), EqProp (a b d), EqProp (a (b, d) c), EqProp (a (b, d) (c, d)), EqProp (a (b, e) (d, e)), EqProp (a (b, d) (c, e)), EqProp b, EqProp c, EqProp d, EqProp e) => a b (c, d, e) -> TestBatch
arrowChoice :: (ArrowChoice a, Show (a b c), Arbitrary (a b c), Arbitrary b, Arbitrary c, Arbitrary d, Arbitrary e, CoArbitrary b, CoArbitrary d, EqProp (a (Either b d) (Either c e)), EqProp (a (Either b d) (Either c d))) => a b (c, d, e) -> TestBatch
traversable :: (Traversable f, Monoid m, Show (f a), Arbitrary (f a), Arbitrary b, Arbitrary a, Arbitrary m, CoArbitrary a, EqProp (f b), EqProp m) => f (a, b, m) -> TestBatch

-- | Laws for MonadPlus instances with left distribution.
monadPlus :: (MonadPlus m, Show (m a), Arbitrary a, CoArbitrary a, Arbitrary (m a), Arbitrary (m b), EqProp (m a), EqProp (m b)) => m (a, b) -> TestBatch

-- | Laws for MonadPlus instances with left catch.
monadOr :: (MonadPlus m, Show a, Show (m a), Arbitrary a, CoArbitrary a, Arbitrary (m a), Arbitrary (m b), EqProp (m a), EqProp (m b)) => m (a, b) -> TestBatch

-- | Check Alternative Monoid laws
alternative :: (Alternative f, Arbitrary a, Arbitrary (f a), EqProp (f a), Show (f a)) => f a -> TestBatch

module Test.QuickCheck.Instances


-- | Later. Allows for testing of functions that depend on the order of
--   evaluation.
--   
--   TODO: move this functionality to the testing package for Unamb.
module Test.QuickCheck.Later

-- | Is the given function associative when restricted to the same value
--   but possibly different times?
isAssocTimes :: (EqProp a, Arbitrary a, Show a) => Double -> (a -> a -> a) -> Property

-- | Is the given function commutative when restricted to the same value
--   but possibly different times?
isCommutTimes :: (EqProp b, Arbitrary a, Show a) => Double -> (a -> a -> b) -> Property

-- | Delay a value's availability by the given duration in seconds. Note
--   that the delay happens only on the first evaluation.
delay :: RealFrac t => t -> a -> a

-- | A value that is never available. Rerun of <tt>hang</tt> from unamb,
--   but replicated to avoid mutual dependency.
--   
--   TODO: Remove when this module is moved into the unamb-test package.
delayForever :: a
