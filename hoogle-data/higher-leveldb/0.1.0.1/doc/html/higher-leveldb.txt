-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A rich monadic API for working with leveldb databases.
--   
--   A rich monadic API for working with leveldb databases.
@package higher-leveldb
@version 0.1.0.0


-- | Higher LevelDB provides a rich monadic API for working with leveldb
--   (<a>http://code.google.com/p/leveldb</a>) databases. It uses the
--   leveldb-haskell bindings to the C++ library. The LevelDBT transformer
--   is a Reader that maintains a database context with the open database
--   as well as default read and write options. It also manages a concept
--   called a KeySpace, which is a bucket scheme that provides a low
--   (storage) overhead named identifier to segregate data. Finally it
--   wraps a <a>ResourceT</a> which is required for use of leveldb-haskell
--   functions.
--   
--   The other major feature is the scan function and its ScanQuery
--   structure that provides a map / fold abstraction over the Iterator
--   exposed by leveldb-haskell.
module Database.LevelDB.Higher
type Key = ByteString
type Value = ByteString

-- | The basic unit of storage is a Key/Value pair.
type Item = (Key, Value)

-- | A KeySpace is similar concept to a "bucket" in other libraries and
--   database systems. The ByteString for KeySpace can be arbitrarily long
--   without performance impact because the system maps the KeySpace name
--   to a 4-byte KeySpaceId internally which is preprended to each Key.
--   KeySpaces are cheap and plentiful and indeed with this library you
--   cannot escape them (you can supply an empty ByteString to use a
--   default KeySpace, but it is still used). One intended use case is to
--   use the full Key of a <a>parent</a> as the KeySpace of its children
--   (instance data in a time-series for example). This lets you scan over
--   a range-based key without passing over any unneeded items.
type KeySpace = ByteString
type KeySpaceId = ByteString

-- | Get a value from the current DB and KeySpace.
get :: MonadLevelDB m => Key -> m (Maybe Value)

-- | Put a value in the current DB and KeySpace.
put :: MonadLevelDB m => Key -> Value -> m ()

-- | Delete an entry from the current DB and KeySpace.
delete :: MonadLevelDB m => Key -> m ()

-- | Write a batch of operations - use the <tt>write</tt> and
--   <a>deleteB</a> functions to add operations to the batch list.
runBatch :: MonadLevelDB m => WriterT WriteBatch m () -> m ()

-- | Add a <a>Put</a> operation to a WriteBatch -- for use with
--   <a>runBatch</a>.
putB :: MonadLevelDB m => Key -> Value -> WriterT WriteBatch m ()

-- | Add a <a>Del</a> operation to a WriteBatch -- for use with
--   <a>runBatch</a>.
deleteB :: MonadLevelDB m => Key -> WriterT WriteBatch m ()

-- | Scan the keyspace, applying functions and returning results. Look at
--   the documentation for <a>ScanQuery</a> for more information.
--   
--   This is essentially a fold left that will run until the
--   <a>scanWhile</a> condition is met or the iterator is exhausted. All
--   the results will be copied into memory before the function returns.
scan :: MonadLevelDB m => Key -> ScanQuery a b -> m b

-- | Structure containing functions used within the <a>scan</a> function.
--   You may want to start with one of the builder/helper funcions such as
--   <a>queryItems</a>, which is defined as:
--   
--   <pre>
--   queryItems = queryBegins { scanInit = []
--                            , scanMap = id
--                            , scanFold = (:)
--                            }
--   </pre>
data ScanQuery a b
ScanQuery :: b -> (Key -> Item -> b -> Bool) -> (Item -> a) -> (Item -> Bool) -> (a -> b -> b) -> ScanQuery a b

-- | starting value for fold/reduce
scanInit :: ScanQuery a b -> b

-- | scan will continue until this returns false
scanWhile :: ScanQuery a b -> Key -> Item -> b -> Bool

-- | map or transform an item before it is reduced/accumulated
scanMap :: ScanQuery a b -> Item -> a

-- | filter function - return <a>False</a> to leave this <a>Item</a> out of
--   the result
scanFilter :: ScanQuery a b -> Item -> Bool

-- | accumulator/fold function e.g. (:)
scanFold :: ScanQuery a b -> a -> b -> b

-- | A basic ScanQuery helper; this query will find all keys that begin the
--   Key argument supplied to scan, and returns them in a list of
--   <a>Item</a>.
--   
--   Does not require any function overrides.
queryItems :: ScanQuery Item [Item]

-- | a ScanQuery helper with defaults for queryBegins and a list result;
--   requires a map function e.g.:
--   
--   <pre>
--   scan "encoded-values:" queryList { scanMap = \(_, v) -&gt; decode v }
--   </pre>
queryList :: ScanQuery a [a]

-- | A partial ScanQuery helper; this query will find all keys that begin
--   with the Key argument supplied to scan.
--   
--   Requires an <a>scanInit</a>, a <a>scanMap</a> and a <a>scanFold</a>
--   function.
queryBegins :: ScanQuery a b

-- | a ScanQuery helper to count items beginning with Key argument.
queryCount :: Num a => ScanQuery a a

-- | Use a local keyspace for the operation. e.g.:
--   
--   <pre>
--   runCreateLevelDB "/tmp/mydb" "MyKeySpace" $ do
--      put "somekey" "somevalue"
--      withKeySpace "Other KeySpace" $ do
--          put "somekey" "someother value"
--      get "somekey"
--   
--   Just "somevalue"
--   </pre>
withKeySpace :: MonadLevelDB m => KeySpace -> m a -> m a

-- | Local Read/Write Options for the action.
withOptions :: MonadLevelDB m => RWOptions -> m a -> m a

-- | Run a block of get operations based on a single snapshot taken at the
--   beginning of the action. The snapshot will be automatically released
--   when complete.
--   
--   This means that you can do put operations in the same block, but you
--   will not see those changes inside this computation.
withSnapshot :: MonadLevelDB m => m a -> m a

-- | Fork a LevelDBT IO action and return ThreadId into the current monad.
--   This uses <a>resourceForkIO</a> to handle the reference counting and
--   cleanup resources when the last thread exits.
forkLevelDB :: MonadLevelDB m => LevelDB () -> m ThreadId

-- | MonadLevelDB class used by all the public functions in this module.
class (Monad m, MonadThrow m, MonadUnsafeIO m, MonadIO m, Applicative m, MonadResource m, MonadBase IO m) => MonadLevelDB m
withDBContext :: MonadLevelDB m => (DBContext -> DBContext) -> m a -> m a
liftLevelDB :: MonadLevelDB m => LevelDBT IO a -> m a

-- | LevelDBT Transformer provides a context for database operations
--   provided in this module.
--   
--   This transformer has the same constraints as <a>ResourceT</a> as it
--   wraps <a>ResourceT</a> along with a <a>DBContext</a> <a>Reader</a>.
--   
--   If you aren't building a custom monad stack you can just use the
--   <a>LevelDB</a> alias.
data LevelDBT m a

-- | alias for LevelDBT IO - useful if you aren't building a custom stack.
type LevelDB a = LevelDBT IO a

-- | Map/transform the monad below the LevelDBT
mapLevelDBT :: (m a -> n b) -> LevelDBT m a -> LevelDBT n b

-- | Build a context and execute the actions; uses a <a>ResourceT</a>
--   internally.
--   
--   tip: you can use the Data.Default (def) method to specify default
--   options e.g.
--   
--   <pre>
--   runLevelDB "/tmp/mydb" def (def, def{sync = true}) "My Keyspace" $ do
--   </pre>
runLevelDB :: MonadResourceBase m => FilePath -> Options -> RWOptions -> KeySpace -> LevelDBT m a -> m a

-- | Same as <a>runLevelDB</a> but doesn't call <a>runResourceT</a>. This
--   gives you the option to manage that yourself
runLevelDB' :: MonadResourceBase m => FilePath -> Options -> RWOptions -> KeySpace -> LevelDBT m a -> ResourceT m a

-- | A helper for runLevelDB using default <a>Options</a> except
--   createIfMissing=True
runCreateLevelDB :: MonadResourceBase m => FilePath -> KeySpace -> LevelDBT m a -> m a
runResourceT :: MonadBaseControl IO m => ResourceT m a -> m a
data Options :: *
Options :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !Maybe Comparator -> !Compression -> !Bool -> !Bool -> {-# UNPACK #-} !Int -> !Bool -> {-# UNPACK #-} !Int -> !Maybe (Either BloomFilter FilterPolicy) -> Options
blockRestartInterval :: Options -> {-# UNPACK #-} !Int
blockSize :: Options -> {-# UNPACK #-} !Int
cacheSize :: Options -> {-# UNPACK #-} !Int
comparator :: Options -> !Maybe Comparator
compression :: Options -> !Compression
createIfMissing :: Options -> !Bool
errorIfExists :: Options -> !Bool
maxOpenFiles :: Options -> {-# UNPACK #-} !Int
paranoidChecks :: Options -> !Bool
writeBufferSize :: Options -> {-# UNPACK #-} !Int
filterPolicy :: Options -> !Maybe (Either BloomFilter FilterPolicy)
data ReadOptions :: *
ReadOptions :: !Bool -> !Bool -> !Maybe Snapshot -> ReadOptions
verifyCheckSums :: ReadOptions -> !Bool
fillCache :: ReadOptions -> !Bool
useSnapshot :: ReadOptions -> !Maybe Snapshot
data WriteOptions :: *
WriteOptions :: !Bool -> WriteOptions
sync :: WriteOptions -> !Bool
type RWOptions = (ReadOptions, WriteOptions)
type WriteBatch = [BatchOp]
def :: Default a => a
class Monad m => MonadUnsafeIO (m :: * -> *)
class Monad m => MonadThrow (m :: * -> *)
type MonadResourceBase (m :: * -> *) = (MonadBaseControl IO m, MonadThrow m, MonadUnsafeIO m, MonadIO m, Applicative m)
instance Functor m => Functor (LevelDBT m)
instance Applicative m => Applicative (LevelDBT m)
instance Monad m => Monad (LevelDBT m)
instance MonadIO m => MonadIO (LevelDBT m)
instance MonadThrow m => MonadThrow (LevelDBT m)
instance (Monoid w, MonadLevelDB m) => MonadLevelDB (RWST r w s m)
instance (Monoid w, MonadLevelDB m) => MonadLevelDB (RWST r w s m)
instance (Monoid w, MonadLevelDB m) => MonadLevelDB (WriterT w m)
instance (Monoid w, MonadLevelDB m) => MonadLevelDB (WriterT w m)
instance (Error e, MonadLevelDB m) => MonadLevelDB (ErrorT e m)
instance (Monad m, MonadLevelDB m) => MonadLevelDB (StateT s m)
instance (Monad m, MonadLevelDB m) => MonadLevelDB (StateT s m)
instance (Monad m, MonadLevelDB m) => MonadLevelDB (ContT r m)
instance (Monad m, MonadLevelDB m) => MonadLevelDB (ListT m)
instance (Monad m, MonadLevelDB m) => MonadLevelDB (IdentityT m)
instance (Monad m, MonadLevelDB m) => MonadLevelDB (MaybeT m)
instance (Monad m, MonadLevelDB m) => MonadLevelDB (ReaderT r m)
instance (MonadResourceBase m) => MonadLevelDB (LevelDBT m)
instance MonadBaseControl b m => MonadBaseControl b (LevelDBT m)
instance MonadTransControl LevelDBT
instance (MonadResourceBase m) => MonadResource (LevelDBT m)
instance MonadTrans LevelDBT
instance MonadBase b m => MonadBase b (LevelDBT m)
instance Show DBContext
