-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An addon to PCLT package: enchance PCLT catalog with PostgreSQL powers.
--   
--   "PCLT" is an abbreviation for "Parametric Composable Localizable
--   Templates" - in fact it should also hold Detalizable. Term
--   "Detailizable content (message)" in this package has a following
--   meaning: some content, representing which it is possible to regulate,
--   in how much details it is represented.
--   
--   Conceptually, this package is a powerful extension to the well known
--   Show class, that (extension) is thought to be embeded in any Haskell
--   program, which requires multilanguage support, and/or where messages
--   should be detailizable.
--   
--   For more information about PCLT, read in it's description in it's own
--   Cabal file.
--   
--   _________
--   
--   By the base package (PCLT
--   <a>http://hackage.haskell.org/package/PCLT</a>) the templates are
--   provided to be stored statically in module declarations using
--   <a>Text.PCLT.HasStaticRawPCLTs.HasStaticRawPCLTs</a> class
--   instaniations.
--   
--   The PCST-DB package adds a possibility to store templates in DB (under
--   PostgreSQL v8.4. (not less)). ER diagram:
--   <a>http://i1.fastpic.ru/big/2009/1212/f0/5b9845716e5a6984e9bc9d62a61928f0.png</a>
--   
--   The following units are storable in DB:
--   
--   <ul>
--   <li>localizable templates</li>
--   <li>localized templates</li>
--   <li>languages</li>
--   <li>collections of localizable templates</li>
--   <li>collections (of localizable templates) compositions</li>
--   <li>catalogs</li>
--   <li>configurations of PCLT catalogs</li>
--   <li>localizable templates detalization policies</li>
--   </ul>
--   
--   For each catalog in DB there is stored a special flag "catalog data or
--   config changed". The flag gets raised by an army of triggers, that
--   watches every table, and is thought to get dropped by a program, which
--   uses DB catalog. Drop the flag right before catalog update from DB.
--   
--   Unfortunately, the current implementation of this flagging system
--   constraints the number of agents that update their catalogs from DB by
--   only one (because, when agent updates it's catalog, it drops the flag,
--   and other agents don't know that flag was risen, so they can't know if
--   version of catalog in their operative memory is older then in DB or
--   not).
--   
--   But this limitation removal is planned as a first ToDo in the next
--   version of PCLT-DB.
@package PCLT-DB
@version 0.1.1


-- | An attemt of generalization of "read from DB" operation.
module Database.ReadableFromDB
type FieldName = String

-- | Type aliase for use by <a>readOneFromDB</a>.
type NoMoreThanOne_shoulditbe = Bool

-- | It's recommended to use newtypes for subject type variable
--   ("readable"), when it is composite (like tuple, Either, Map or other).
--   Reason for that is described near the <tt>ShowAsPCSI</tt> instaniation
--   for <a>AddressedReadFromDBError</a>.
class (Typeable readable, Show pk) => ReadableFromDB readable pk
readFromDB :: ReadableFromDB readable pk => Connection -> pk -> IO [Either AddressedReadFromDBError readable]
parseDBrow :: ReadableFromDB readable pk => Connection -> pk -> Map FieldName SqlValue -> IO (Either AddressedReadFromDBError readable)
readOneFromDB :: ReadableFromDB readable pk => Connection -> pk -> NoMoreThanOne_shoulditbe -> IO (Either AddressedReadFromDBError readable)

-- | Type aliase for use by <a>TooManyResultsFoundInDB_RFDBE</a>.
type AllowedMaximumOfRowsCount = Int

-- | What kind of errors are possible in the result of "read from DB"
--   operation
data ReadFromDBError
RecieveError_RFDBE :: SqlError -> ReadFromDBError
NotFoundInDB_RFDBE :: ReadFromDBError
TooManyResultsFoundInDB_RFDBE :: AllowedMaximumOfRowsCount -> ReadFromDBError
RowParseError_RFDBE :: SomeException -> ReadFromDBError
SubReadError_RFDBE :: AddressedReadFromDBError -> ReadFromDBError

-- | A wrapper around <a>ReadFromDBError</a>, added information about type
--   of read subject and by showing the primary key.
--   
--   ___________
--   
--   If PCLT is to be used for representation of
--   <a>AddressedReadFromDBError</a> then user must declare an additional
--   localizable template in his PCLT catalog with ID of form:
--   
--   <pre>
--   "ARFDBE_SDLR." ++ (show $ <a>arfdbeEntityType</a> err)
--   </pre>
--   
--   , where the <tt>show <a>arfdbeEntityType</a></tt> will include full
--   modules path of type. The templete content if not important - leave it
--   empty, but what is important - is it's SDL requirement. This SDL
--   requirement wil be in effect for the representation of
--   <a>AddressedReadFromDBError</a>.
--   
--   For more information on that, see description for <tt>ShowAsPCSI</tt>
--   instance for <a>AddressedReadFromDBError</a> - in module
--   <a>Database.ReadableFromDB__</a>.
data AddressedReadFromDBError
AddressedReadFromDBError :: TypeRep -> String -> ReadFromDBError -> AddressedReadFromDBError
arfdbeEntityType :: AddressedReadFromDBError -> TypeRep
arfdbePK :: AddressedReadFromDBError -> String
arfdbeErr :: AddressedReadFromDBError -> ReadFromDBError

-- | In case of error it wraps it <a>ReadFromDBError</a> into
--   <a>AddressedReadFromDBError</a>.
wrapParseResult_1row :: (Typeable readable, Show pk) => pk -> Either ReadFromDBError readable -> Either AddressedReadFromDBError readable

-- | Wrapper around <a>wrapParseResult_1row</a>.
wrapParseResult_Nrows :: (Typeable a, Show pk) => pk -> [Either ReadFromDBError a] -> [Either AddressedReadFromDBError a]

-- | Return the <a>TypeRep</a> of what can be under <tt>Right</tt> in
--   <tt>Either</tt>
rightType_formReadResOrErr :: (Typeable left, Typeable right) => Either left right -> TypeRep

-- | This is better than <tt>row ! field_name</tt>, because if an error
--   occurs (field not found), then it returns in error message this field
--   name.
takeFieldValue :: Convertible SqlValue a => FieldName -> Map FieldName SqlValue -> a

-- | Uppercase given field name, and apply it with <a>takeFieldValue</a>.
takeUFieldValue :: Convertible SqlValue a => FieldName -> Map FieldName SqlValue -> a

-- | WARNING !!! HDBC lowercases field names, when using
--   <tt>fetchAllRowsMap</tt>.
uppercaseMapKeys :: Map String a -> Map String a

-- | <pre>
--   liftInList a = a : []
--   </pre>
liftInList :: a -> [a]
instance Typeable AddressedReadFromDBError
instance Typeable ReadFromDBError
instance Show AddressedReadFromDBError
instance Show ReadFromDBError


-- | For representation of <a>AddressedReadFromDBError</a> a special trick
--   is used. SDL requirements for representation of error is referenced to
--   be the same as specified for template with such ID:
--   
--   <pre>
--   "ARFDBE_SDLR." ++ (show $ <a>arfdbeEntityType</a> err)
--   </pre>
--   
--   So, whenever an instance of <a>ReadableFromDB</a> is declared, in
--   order to make <a>AddressedReadFromDBError</a> show correctly,
--   developer must also add an empty template with corresponding ID to
--   PCLT catalog.
--   
--   For example, template with ID
--   <tt>"ARFDBE_SDLR.Text.PCLT.Config.PCLT_InnerConfig"</tt> is to be
--   added, when <tt>PCLT_InnerConfig</tt> is made an instance of
--   <a>ReadableFromDB</a>. The content of this template is not important -
--   just leave it empty, it's never shown. Only it's SDL requirement is
--   important and is used.
--   
--   In order to keep <tt>(show $ <a>arfdbeEntityType</a> err)</tt> string
--   as short as possible it's recommended to use <tt>newtype</tt>, when
--   type is composite, like tuple, Either, Map etc.
module Database.ReadableFromDB__
data PCLTRawCatalog__Database_ReadableFromDB
PCLTRawCatalog__Database_ReadableFromDB :: PCLTRawCatalog__Database_ReadableFromDB
instance HasStaticRawPCLTs PCLTRawCatalog__Database_ReadableFromDB
instance ShowAsPCSI AddressedReadFromDBError
instance ShowAsPCSI SqlError


-- | Some instances of <a>ReadableFromDB</a> for reading PCLT catalog and
--   related objects from DB.
--   
--   DBMS is PostgreSQL v8.4. Not earlier, since PCLT-DB relies on a
--   feature that appeared in PostgresSQL only in v8.4. - the <tt>WITH</tt>
--   clause for <tt>SELECT</tt> query (also <tt>WITH RECURSIVE</tt>).
module Database.PCLT.InterfaceWithDB

-- | Container for data, that is read from DB, that goes on input to
--   catalog formation routine.
newtype RawCatalogDataReadFromDBResult
RawCatalogDataReadFromDBResult :: (PCLT_RawCatalogData, [AddPCLT_toPCLT_Error]) -> RawCatalogDataReadFromDBResult

-- | Container for PCLT catalog, that is read from DB.
newtype CatalogReadFromDBResult
CatalogReadFromDBResult :: (PCLT_Catalog, [ErrorWithPCSCatalog ReadPCSCatalogError], [AddPCLT_toPCLT_Error]) -> CatalogReadFromDBResult

-- | Container for a flag, that is read from DB.
--   
--   For each catalog in DB there is stored a special flag "catalog data or
--   config changed". The flag gets raised by an army of triggers, that
--   watches every table, and is thought to get dropped by a program, which
--   uses DB catalog. Drop the flag right before catalog update from DB.
--   
--   Unfortunately, the current implementation of this flagging system
--   constraints the number of agents that update their catalogs from DB by
--   only one (because, when agent updates it's catalog, it drops the flag,
--   and other agents don't know that flag was risen, so they can't know if
--   version of catalog in their operative memory is older then in DB or is
--   it not).
--   
--   But this limitation removal is planned as a first ToDo in the next
--   version of PCLT-DB.
newtype CatalogNeedsToBeUpdated_DoesIt
CatalogNeedsToBeUpdated_DoesIt :: Bool -> CatalogNeedsToBeUpdated_DoesIt

-- | Errors that may occur, when performing
--   <a>dropFlag_CatalogNeedsToBeUpdated</a>.
data DropFlag_CatalogNeedsToBeUpdated_Error
NotModified_DFCNTBUE :: DropFlag_CatalogNeedsToBeUpdated_Error
DBError_DFCNTBUE :: SqlError -> DropFlag_CatalogNeedsToBeUpdated_Error

-- | Wrapper around <a>DropFlag_CatalogNeedsToBeUpdated_Error</a>, added
--   <a>PCLT_CatalogID</a>, for which "drop flag" operation failed.
data AddressedDropFlag_CatalogNeedsToBeUpdated_Error
AddressedDropFlag_CatalogNeedsToBeUpdated_Error :: DropFlag_CatalogNeedsToBeUpdated_Error -> PCLT_CatalogID -> AddressedDropFlag_CatalogNeedsToBeUpdated_Error

-- | Drop that flag in DB.
dropFlag_CatalogNeedsToBeUpdated :: Connection -> PCLT_CatalogID -> IO (Maybe AddressedDropFlag_CatalogNeedsToBeUpdated_Error)

-- | The container for all types of errors that may result, when trying to
--   update a catalog from DB.
data CatalogUpdateFromDBErrors
CatalogUpdateFromDBErrors :: Maybe AddressedDropFlag_CatalogNeedsToBeUpdated_Error -> Maybe AddressedReadFromDBError -> [ErrorWithPCSCatalog ReadPCSCatalogError] -> [AddPCLT_toPCLT_Error] -> PCLT_CatalogID -> Bool -> CatalogUpdateFromDBErrors
cueDropCNTBUFlag :: CatalogUpdateFromDBErrors -> Maybe AddressedDropFlag_CatalogNeedsToBeUpdated_Error
cueARFDBE :: CatalogUpdateFromDBErrors -> Maybe AddressedReadFromDBError
cueCatReadErrs :: CatalogUpdateFromDBErrors -> [ErrorWithPCSCatalog ReadPCSCatalogError]
cueCollectionErrs :: CatalogUpdateFromDBErrors -> [AddPCLT_toPCLT_Error]
cueCatalogID :: CatalogUpdateFromDBErrors -> PCLT_CatalogID
cueCatalogRead :: CatalogUpdateFromDBErrors -> Bool

-- | Checks if catalog is read without a single error.
emptyCUE :: CatalogUpdateFromDBErrors -> Bool

-- | An empty form to be filled.
defaultCatalogUpdateFromDBErrors :: PCLT_CatalogID -> CatalogUpdateFromDBErrors

-- | There is a one way relation from <a>CatalogFromHSRTInitErrors</a> to
--   <a>CatalogUpdateFromDBErrors</a>. That's because subject operations
--   are similar it their abstractions.
cfhie2cue :: CatalogFromHSRTInitErrors -> CatalogUpdateFromDBErrors

-- | Check if the flag "catalog data or config changed" is up in DB. If so,
--   drop it and try to read from DB
--   
--   <ol>
--   <li><a>PCLT_InnerConfig</a></li>
--   <li><a>RawCatalogDataReadFromDBResult</a></li>
--   <li><a>CatalogReadFromDBResult</a></li>
--   </ol>
considerCatalogUpdate :: Connection -> PCLT_CatalogID -> IO (Maybe PCLT_Catalog, Maybe CatalogUpdateFromDBErrors)
instance Typeable CatalogUpdateFromDBErrors
instance Typeable AddressedDropFlag_CatalogNeedsToBeUpdated_Error
instance Typeable DropFlag_CatalogNeedsToBeUpdated_Error
instance Typeable CatalogNeedsToBeUpdated_DoesIt
instance Typeable CatalogReadFromDBResult
instance Typeable RawCatalogDataReadFromDBResult
instance Show CatalogUpdateFromDBErrors
instance Show AddressedDropFlag_CatalogNeedsToBeUpdated_Error
instance Show DropFlag_CatalogNeedsToBeUpdated_Error
instance Show CatalogNeedsToBeUpdated_DoesIt
instance Show CatalogReadFromDBResult
instance Show RawCatalogDataReadFromDBResult
instance ReadableFromDB CatalogNeedsToBeUpdated_DoesIt PCLT_CatalogID
instance ReadableFromDB CatalogReadFromDBResult PCLT_CatalogID
instance ReadableFromDB RawCatalogDataReadFromDBResult (PCLT_CatalogID, PCLT_InnerConfig)
instance ReadableFromDB PCLT_InnerConfig PCLT_CatalogID


-- | A module around a thread that considers updating catalog, when
--   commanded to do so.
module Database.PCLT.UpdatableCatalog

-- | This type is a special instance of <a>HasStaticRawPCLTs</a> - it
--   accumulates all other instances of <a>HasStaticRawPCLTs</a> from the
--   whole PCLT-DB package, and also from PCLT package.
--   
--   This instance is best to be used as an intial input for the catalog
--   formation in your applications.
data PCLTRawCatalog__Database_PCLT_UpdatableCatalog
PCLTRawCatalog__Database_PCLT_UpdatableCatalog :: PCLTRawCatalog__Database_PCLT_UpdatableCatalog

-- | Input contains current catalog version. If the update failed and
--   returned no new catalog version, or if update isn't needed, then
--   current catalog version is returned.
--   
--   If there appeared any errors, they get acted with. The action is
--   specified by user.
catalogUpdatorIteration :: Connection -> PCLT_CatalogID -> (PCLT_Catalog -> CatalogUpdateFromDBErrors -> IO ()) -> PCLT_Catalog -> IO (Maybe PCLT_Catalog)

-- | Type alias used by <a>runCatalogUpdatorService</a>.
type DisconnectDBConnWhenFinished_shouldwe = Bool

-- | Type alias used by <a>runCatalogUpdatorService</a>.
type MakeIterationAndContinueCycle_shouldwe = Bool

-- | The first version of catalog, that service forms is always from nonDB
--   source, but is from specified in the first triple <i>(catalog ID,
--   config and some instance of HasStaticRawPCLTs)</i>. That way, even if
--   DB never responds, service always has at least this version of catalog
--   available.
--   
--   In the 3rd argument user specifies action, that has a role of errors
--   processor (reporter).
--   
--   The 4th argument is a <tt>Chan</tt>, which this service listens to.
--   
--   <ul>
--   <li>If <tt>True</tt> comes, service makes iteration (reads catalog
--   from DB if needed, and writes new version into the MVar), and
--   continues cycle.</li>
--   <li>If <tt>False</tt> comes, service stops.</li>
--   </ul>
--   
--   The returned MVar is created by service itself and is a container,
--   where it keeps last version of catalog.
runCatalogUpdatorService :: HasStaticRawPCLTs a => (PCLT_CatalogID, PCLT_InnerConfig, a) -> (Connection, DisconnectDBConnWhenFinished_shouldwe) -> (PCLT_Catalog -> CatalogUpdateFromDBErrors -> IO ()) -> Chan MakeIterationAndContinueCycle_shouldwe -> IO (MVar PCLT_Catalog, ThreadId)

-- | Wrapper around <a>runCatalogUpdatorService</a>. The service starts
--   from default config (<a>defaultPCLTInnerConfig</a>) and default set of
--   templates (<a>PCLTRawCatalog__Database_PCLT_UpdatableCatalog</a>). But
--   updates from DB orienting on given <a>PCLT_CatalogID</a>, which may be
--   different set of templates and different config.
runCatalogUpdatorService_wDefaultInitial :: PCLT_CatalogID -> (Connection, DisconnectDBConnWhenFinished_shouldwe) -> (PCLT_Catalog -> CatalogUpdateFromDBErrors -> IO ()) -> Chan MakeIterationAndContinueCycle_shouldwe -> IO (MVar PCLT_Catalog, ThreadId)
instance HasStaticRawPCLTs PCLTRawCatalog__Database_PCLT_UpdatableCatalog

module Database.PCLT
