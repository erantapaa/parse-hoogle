-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Wire-aware hardware description
--   
--   Wired is an extension to the hardware description library Lava
--   targeting (not exclusively) semi-custom VLSI design. A particular aim
--   of Wired is to give the designer more control over on-chip wires'
--   effects on performance.
--   
--   The goal is a system with the following features:
--   
--   <ul>
--   <li>Convenient circuit description in monadic style.</li>
--   <li>Layout/wiring expressed using optional annotations, allowing
--   incremental specification of physical aspects.</li>
--   <li>Export designs to several formats:</li>
--   </ul>
--   
--   <ol>
--   <li>Lava (for e.g. verification)</li>
--   <li>Postscript (for visualizing layout and wiring)</li>
--   <li>Design Exchange Format (for interfacing to standard CAD
--   tools)</li>
--   </ol>
--   
--   <ul>
--   <li>Accurate, wire-aware timing/power analysis within the system.</li>
--   <li>Support for modern standard cell libraries.</li>
--   <li>Automatic compilation of standard cell libraries.</li>
--   </ul>
--   
--   We are not very far from this goal. The missing parts are power
--   analysis and cell library compilation, and sequential circuits are not
--   yet fully supported. Also, there is virtually no documentation. The
--   best place to look for guidance is in the <tt>Examples</tt> directory.
--   The following thesis
--   <a>http://www.cse.chalmers.se/~emax/documents/PhD_thesis.pdf</a> gives
--   more information about the background and some explanation of
--   programming techniques used in Wired. It should also be said that the
--   library is still quite unstable and has not yet been tested in any
--   larger scale.
--   
--   The standard cell library shipped with Wired
--   (<a>Libs.Nangate45.Wired</a>) is an open-source 45nm library from
--   Nangate (<a>http://www.nangate.com</a>) provided for the purposes of
--   testing and exploring EDA flows. It is not intended for fabrication.
--   More information is given in the license agreement in
--   <a>Libs.Nangate45.LICENSE</a>. If anyone is interested in real cell
--   libraries (currently 130nm, 90nm and 65nm from STM), please contact
--   the maintainer of the Wired library.
--   
--   Currently, Wired contains its own version of Lava which is a bit
--   different from the standard version (package
--   <tt>chalmers-lava2000</tt> on Hackage) To make things more
--   complicated, this version of Lava actually uses the standard version
--   for simulation and verification. Ideally there should only be
--   <i>one</i> Lava library, independent of the Wired package. Hopefully,
--   this will happen in a not too distant future.
@package Wired
@version 0.3


-- | <pre>
--   The Open Cell Library is intended for use by universities, other research
--   activities, educational programs and Si2.org members.
--   However allowed, the Open Cell Library is not intended for commercial use.
--   If you use the Open Cell Library for demonstration of commercial EDA tools
--   it is required to mention, indicate that the library was developped by
--   Nangate.
--   
--   If you have questions or concerns then please contact us at
--   openlibrary@nangate.com
--   
--   The Open Cell Library is provided by Nangate under the following License:
--   
--   Nangate Open Cell Library License, Version 1.0. February 20, 2008
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the Open Cell Library and accompanying documentation
--   (the "Library") covered by this license to use, reproduce, display,
--   distribute, execute, and transmit the Library, and to prepare derivative
--   works of the Library, and to permit third-parties to whom the Library is
--   furnished to do so, all subject to the following:
--   
--   The copyright notices in the Library and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Library, in whole or in part, and all
--   derivative works of the Library, unless such copies or derivative works are
--   solely in the form of machine-executable object code generated by a source
--   language processor. The library has been generated using a non-optimized
--   open PDK and is not suited for any commercial purpose. Measuring or
--   benchmarking the Library against any other library or standard cell set is
--   prohibited. Any meaningful library benchmarking must be done in
--   collaboration with Nangate or other providers of optimized and
--   production-ready PDKs.
--   
--   THE LIBRARY IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE LIBRARY BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE LIBRARY OR THE USE OR OTHER
--   DEALINGS IN THE LIBRARY.
--   </pre>
module Libs.Nangate45.LICENSE


-- | This module defines types of a general nature that are used by the
--   <a>Lava</a>, <a>Layout</a> and <a>Wired</a> libraries. It also defines
--   operations on those types.
module Data.Hardware.Internal

-- | The phantom parameter <tt>t</tt> can be used to pass a type constraint
--   to an overloaded function.
data Res t a
R :: !a -> Res t a
result :: Res t a -> !a
(.+) :: ShowS -> ShowS -> ShowS
unwordS :: [ShowS] -> ShowS
unlineS :: [ShowS] -> ShowS
type Name = String
type Tag = String
class Num n => IntCast n
toInt :: IntCast n => n -> Int
fromInt :: IntCast n => Int -> n
class Num n => DoubleCast n
toDouble :: DoubleCast n => n -> Double
fromDouble :: DoubleCast n => Double -> n
icast :: (IntCast m, IntCast n) => m -> n
dcast :: (DoubleCast m, DoubleCast n) => m -> n
class Multiply n1 n2 n3 | n1 n2 -> n3, n1 n3 -> n2, n2 n3 -> n1
(><) :: Multiply n1 n2 n3 => n1 -> n2 -> n3
newtype InPin
InPin :: Int -> InPin
newtype OutPin
OutPin :: Int -> OutPin
newtype PrimInpId
PrimInpId :: Int -> PrimInpId
newtype CellId
CellId :: Int -> CellId
newtype Length
Length :: Integer -> Length
unLength :: Length -> Integer
type XPos = Length
type YPos = Length
type Width = Length
type Height = Length
class Value v
value :: Value v => v -> Rational
addLen :: Length -> Length -> Length
subLen :: Length -> Length -> Length
mulLen :: Integral n => Length -> n -> Length
mulLen2 :: Length -> Length -> Integer
divLen :: Integral n => Length -> n -> Length
newtype Layer_
Layer :: Int -> Layer_
type Layer = Int
newtype Capacitance
Cap :: Double -> Capacitance
newtype Resistance
Res :: Double -> Resistance
newtype Time
Time :: Double -> Time
type Delay = Time
newtype TransitionTime
TransitionTime :: Double -> TransitionTime
class DoubleCast t => IsTime t
timeCast :: (IsTime t1, IsTime t2) => t1 -> t2
type Position = (XPos, YPos)
type Size = (Width, Height)
data Angle
Horizontal :: Angle
Vertical :: Angle
data Direction
Rightwards :: Direction
Leftwards :: Direction
Upwards :: Direction
Downwards :: Direction
type Orientation = (Bool, Direction)
directionAngle :: Direction -> Angle
north :: Orientation

-- | A lookup function that is defined for all keys.
totalLookup :: Ord k => k -> Map k [a] -> [a]

-- | Computes the minimal spanning tree based on the given distance
--   function.
spanning :: ((Position, Position) -> Double) -> [Position] -> [(Position, Position)]
euclidDistance :: (Position, Position) -> Double
rectiDistance :: (Position, Position) -> Double
euclidSpanning :: [Position] -> [(Position, Position)]
rectiSpanning :: [Position] -> [(Position, Position)]
prop_span1 :: ((Position, Position) -> Double) -> [Position] -> Property
prop_span2 :: ((Position, Position) -> Double) -> [Position] -> Property
prop_span3 :: ((Position, Position) -> Double) -> [Position] -> Property
prop_span4 :: ((Position, Position) -> Double) -> [(XPos, YPos)] -> Bool
prop_span5 :: ((Position, Position) -> Double) -> [(Length, Length)] -> Int -> Bool
prop_span6 :: ((Position, Position) -> Double) -> [Position] -> Bool
checkAll :: IO ()
data Table2D i x y q
Table2D :: i -> i -> (i -> x) -> (i -> y) -> (i -> i -> q) -> Table2D i x y q
tableLengthX :: Table2D i x y q -> i
tableLengthY :: Table2D i x y q -> i
tableAxisX :: Table2D i x y q -> i -> x
tableAxisY :: Table2D i x y q -> i -> y
tableValues :: Table2D i x y q -> i -> i -> q
nearestPoints :: (Num i, Eq i, Ord a) => i -> (i -> a) -> a -> ((i, a), (i, a))
bilinInterpolate1 :: (Fractional x, Fractional y, Fractional q, DoubleCast x, DoubleCast y, DoubleCast q) => (x, y) -> (x, y) -> (q, q, q, q) -> x -> y -> q
findPoints :: (Num i, Eq i, Ord x, Ord y) => Table2D i x y q -> x -> y -> ((x, y), (x, y), (q, q, q, q))
bilinInterpolate :: (Num i, Eq i, Ord x, Ord y, Fractional x, Fractional y, Fractional q, DoubleCast x, DoubleCast y, DoubleCast q) => Table2D i x y q -> x -> y -> q
instance [overlap ok] Eq a => Eq (Res t a)
instance [overlap ok] Show a => Show (Res t a)
instance [overlap ok] Eq InPin
instance [overlap ok] Show InPin
instance [overlap ok] Ord InPin
instance [overlap ok] Num InPin
instance [overlap ok] Real InPin
instance [overlap ok] Integral InPin
instance [overlap ok] Enum InPin
instance [overlap ok] IntCast InPin
instance [overlap ok] Eq OutPin
instance [overlap ok] Show OutPin
instance [overlap ok] Ord OutPin
instance [overlap ok] Num OutPin
instance [overlap ok] Real OutPin
instance [overlap ok] Integral OutPin
instance [overlap ok] Enum OutPin
instance [overlap ok] IntCast OutPin
instance [overlap ok] Eq PrimInpId
instance [overlap ok] Show PrimInpId
instance [overlap ok] Ord PrimInpId
instance [overlap ok] Num PrimInpId
instance [overlap ok] Real PrimInpId
instance [overlap ok] Integral PrimInpId
instance [overlap ok] Enum PrimInpId
instance [overlap ok] IntCast PrimInpId
instance [overlap ok] Eq CellId
instance [overlap ok] Show CellId
instance [overlap ok] Ord CellId
instance [overlap ok] Num CellId
instance [overlap ok] Real CellId
instance [overlap ok] Integral CellId
instance [overlap ok] Enum CellId
instance [overlap ok] IntCast CellId
instance [overlap ok] Eq Length
instance [overlap ok] Show Length
instance [overlap ok] Ord Length
instance [overlap ok] Arbitrary Length
instance [overlap ok] Eq Layer_
instance [overlap ok] Show Layer_
instance [overlap ok] Ord Layer_
instance [overlap ok] Num Layer_
instance [overlap ok] Real Layer_
instance [overlap ok] Integral Layer_
instance [overlap ok] Enum Layer_
instance [overlap ok] IntCast Layer_
instance [overlap ok] Eq Capacitance
instance [overlap ok] Show Capacitance
instance [overlap ok] Num Capacitance
instance [overlap ok] Ord Capacitance
instance [overlap ok] Fractional Capacitance
instance [overlap ok] IntCast Capacitance
instance [overlap ok] DoubleCast Capacitance
instance [overlap ok] Eq Resistance
instance [overlap ok] Show Resistance
instance [overlap ok] Num Resistance
instance [overlap ok] Ord Resistance
instance [overlap ok] Fractional Resistance
instance [overlap ok] IntCast Resistance
instance [overlap ok] DoubleCast Resistance
instance [overlap ok] Eq Time
instance [overlap ok] Show Time
instance [overlap ok] Num Time
instance [overlap ok] Ord Time
instance [overlap ok] Fractional Time
instance [overlap ok] IntCast Time
instance [overlap ok] DoubleCast Time
instance [overlap ok] Eq TransitionTime
instance [overlap ok] Show TransitionTime
instance [overlap ok] Num TransitionTime
instance [overlap ok] Ord TransitionTime
instance [overlap ok] Fractional TransitionTime
instance [overlap ok] IntCast TransitionTime
instance [overlap ok] DoubleCast TransitionTime
instance [overlap ok] Eq Angle
instance [overlap ok] Show Angle
instance [overlap ok] Eq Direction
instance [overlap ok] Show Direction
instance [overlap ok] IsTime TransitionTime
instance [overlap ok] IsTime Time
instance [overlap ok] Multiply Capacitance Resistance Time
instance [overlap ok] Multiply Resistance Capacitance Time
instance [overlap ok] Value Length => Fractional Length
instance [overlap ok] Value Length => Num Length
instance [overlap ok] DoubleCast n => Multiply n Double n
instance [overlap ok] DoubleCast n => Multiply Double n n
instance [overlap ok] DoubleCast Integer
instance [overlap ok] DoubleCast Int
instance [overlap ok] DoubleCast Double
instance [overlap ok] IntCast Double
instance [overlap ok] IntCast Integer
instance [overlap ok] IntCast Int
instance [overlap ok] IsString ShowS
instance [overlap ok] Functor (Res t)

module Layout.Internal
data Alignment
BottomLeft :: Alignment
TopRight :: Alignment
newtype Elasticity
Elasticity :: Int -> Elasticity
data Distance
Dist :: Length -> Distance
data Block spaceSize s b
Space :: spaceSize -> (Maybe s) -> Block spaceSize s b
Box :: Size -> Orientation -> Name -> b -> Block spaceSize s b
type RelBlock s b = Block Distance s b
type AbsBlock s b = Block (Angle, Length) s b
data Placement
Unspecified :: Placement
Stack :: Alignment -> Alignment -> Placement
Row :: Direction -> Alignment -> Placement
data Floorplan s b
Block :: (RelBlock s b) -> Floorplan s b
Comb :: Placement -> [Floorplan s b] -> Floorplan s b
type AbsFloorplan s b = [(Position, AbsBlock s b)]
class Transformable a
flipX :: Transformable a => a -> a
flipY :: Transformable a => a -> a
rotate_ :: Transformable a => Int -> a -> a
flipAlignment :: Alignment -> Alignment
rotate :: Transformable a => Int -> a -> a
absolutizeBlock :: Placement -> RelBlock s b -> (AbsBlock s b, Size)
align :: Alignment -> Length -> Length -> Length
translateBlocks :: Position -> AbsFloorplan s b -> AbsFloorplan s b
absolutize_ :: Placement -> Position -> Floorplan s b -> Writer (AbsFloorplan s b) Size
absolutize :: Floorplan s b -> (AbsFloorplan s b, Size)
blockCenter :: (Position, AbsBlock s b) -> Position
type Color = (Float, Float, Float)
black :: Color
blue :: Color
green :: Color
red :: Color
grey :: Color
white :: Color
type Postscript = ShowS
class Show a => PSShow a
psShow :: PSShow a => a -> Postscript
absToPS :: AbsFloorplan s b -> Postscript
floorplanToPS :: Floorplan s b -> (Postscript, Size)
linesToPS :: [([(Position, Position)], Color)] -> Postscript
renderFloorplan_ :: Length -> Name -> Floorplan s b -> [([(Position, Position)], Color)] -> IO ()
renderFloorplan :: Name -> Floorplan s b -> IO ()
ps1 :: Postscript
ps2 :: Postscript
ps3 :: Postscript
newtype Layout s b a
Layout :: (ReaderT Placement (Writer [Floorplan s b]) a) -> Layout s b a
newtype LayoutT s b m a
LayoutT :: (ReaderT Placement (WriterT [Floorplan s b] m) a) -> LayoutT s b m a
runLayout :: Layout s b a -> (a, Floorplan s b)
runLayoutT :: Monad m => LayoutT s b m a -> m (a, Floorplan s b)
renderLayout :: Name -> Layout s b a -> IO ()
renderLayoutT :: Monad m => (forall a. m a -> a) -> Name -> LayoutT s b m a -> IO ()
class Monad m => MonadLayout s b m | m -> s b
currentPlacement :: MonadLayout s b m => m Placement
space_ :: MonadLayout s b m => Length -> Maybe s -> m ()
block_ :: MonadLayout s b m => Width -> Height -> Name -> b -> m ()
subLayout :: MonadLayout s b m => Placement -> m a -> m a
transformFloorplan :: MonadLayout s b m => (Floorplan s b -> Floorplan s b) -> m a -> m a
space :: MonadLayout s b m => Length -> a -> m a
block :: MonadLayout s b m => Width -> Height -> Name -> b -> a -> m a
rightwards :: MonadLayout s b m => m a -> m a
leftwards :: MonadLayout s b m => m a -> m a
upwards :: MonadLayout s b m => m a -> m a
downwards :: MonadLayout s b m => m a -> m a
rightwards' :: MonadLayout s b m => m a -> m a
leftwards' :: MonadLayout s b m => m a -> m a
upwards' :: MonadLayout s b m => m a -> m a
downwards' :: MonadLayout s b m => m a -> m a
unplaced :: MonadLayout s b m => m a -> m a
stacked :: MonadLayout s b m => m a -> m a
translate :: MonadLayout s bl m => XPos -> YPos -> m a -> m a
instance [overlap ok] Functor (Layout s b)
instance [overlap ok] Applicative (Layout s b)
instance [overlap ok] Monad (Layout s b)
instance [overlap ok] MonadFix (Layout s b)
instance [overlap ok] Functor m => Functor (LayoutT s b m)
instance [overlap ok] Applicative m => Applicative (LayoutT s b m)
instance [overlap ok] Monad m => Monad (LayoutT s b m)
instance [overlap ok] MonadFix m => MonadFix (LayoutT s b m)
instance [overlap ok] MonadLayout s b m => Transformable (m a)
instance [overlap ok] Monad m => MonadLayout s b (LayoutT s b m)
instance [overlap ok] MonadLayout s b (Layout s b)
instance [overlap ok] MonadTrans (LayoutT s b)

module Layout
class Transformable a
flipX :: Transformable a => a -> a
flipY :: Transformable a => a -> a
rotate_ :: Transformable a => Int -> a -> a
rotate :: Transformable a => Int -> a -> a
data Layout s b a
data LayoutT s b m a
black :: Color
white :: Color
grey :: Color
red :: Color
green :: Color
blue :: Color
renderLayout :: Name -> Layout s b a -> IO ()
renderLayoutT :: Monad m => (forall a. m a -> a) -> Name -> LayoutT s b m a -> IO ()
class Monad m => MonadLayout s b m | m -> s b
space :: MonadLayout s b m => Length -> a -> m a
rightwards :: MonadLayout s b m => m a -> m a
leftwards :: MonadLayout s b m => m a -> m a
upwards :: MonadLayout s b m => m a -> m a
downwards :: MonadLayout s b m => m a -> m a
rightwards' :: MonadLayout s b m => m a -> m a
leftwards' :: MonadLayout s b m => m a -> m a
upwards' :: MonadLayout s b m => m a -> m a
downwards' :: MonadLayout s b m => m a -> m a
unplaced :: MonadLayout s b m => m a -> m a
stacked :: MonadLayout s b m => m a -> m a
translate :: MonadLayout s bl m => XPos -> YPos -> m a -> m a


-- | This module exports the types that users of <a>Lava</a>, <a>Layout</a>
--   and <a>Wired</a> (not the internal modules) will need.
module Data.Hardware

-- | The phantom parameter <tt>t</tt> can be used to pass a type constraint
--   to an overloaded function.
data Res t a
R :: !a -> Res t a
result :: Res t a -> !a
type Name = String
type Tag = String
newtype Length
Length :: Integer -> Length
unLength :: Length -> Integer
type XPos = Length
type YPos = Length
type Width = Length
type Height = Length
addLen :: Length -> Length -> Length
subLen :: Length -> Length -> Length
mulLen :: Integral n => Length -> n -> Length
mulLen2 :: Length -> Length -> Integer
divLen :: Integral n => Length -> n -> Length
type Layer = Int
data Time
type Delay = Time

module Data.Logical.Knot
data Knot i x a
data KnotT i x m a
class (Monad m, Ord i) => MonadKnot i x m | m -> i x
askKnot :: MonadKnot i x m => i -> m x
askKnotDef :: MonadKnot i x m => x -> i -> m x
(*=) :: MonadKnot i x m => i -> x -> m ()
accKnot :: Ord i => (x -> x -> x) -> Knot i x a -> (a, Map i x)
tieKnot :: Ord i => Knot i x a -> (a, Map i x)
accKnotT :: (Ord i, MonadFix m) => (x -> x -> x) -> KnotT i x m a -> m (a, Map i x)
tieKnotT :: (Ord i, MonadFix m) => KnotT i x m a -> m (a, Map i x)
instance [overlap ok] Functor (Knot i x)
instance [overlap ok] Applicative (Knot i x)
instance [overlap ok] Monad (Knot i x)
instance [overlap ok] MonadFix (Knot i x)
instance [overlap ok] Functor m => Functor (KnotT i x m)
instance [overlap ok] Applicative m => Applicative (KnotT i x m)
instance [overlap ok] Monad m => Monad (KnotT i x m)
instance [overlap ok] MonadFix m => MonadFix (KnotT i x m)
instance [overlap ok] (Monad m, Ord i) => MonadKnot i x (KnotT i x m)
instance [overlap ok] Ord i => MonadKnot i x (Knot i x)
instance [overlap ok] MonadTrans (KnotT i x)

module Data.Logical.Let
data Let x a
data LetT x m a
data Var x
class MonadKnot VarId x m => MonadLet x m | m -> x
free :: MonadLet x m => m (Var x)
val :: Var x -> x
(===) :: MonadLet x m => Var x -> x -> m ()
runLet :: Let x a -> a
runLetT :: MonadFix m => LetT x m a -> m a
instance [overlap ok] Functor (Let x)
instance [overlap ok] Applicative (Let x)
instance [overlap ok] Monad (Let x)
instance [overlap ok] MonadFix (Let x)
instance [overlap ok] MonadKnot VarId x (Let x)
instance [overlap ok] Functor m => Functor (LetT x m)
instance [overlap ok] (Monad m, Functor m) => Applicative (LetT x m)
instance [overlap ok] Monad m => Monad (LetT x m)
instance [overlap ok] MonadFix m => MonadFix (LetT x m)
instance [overlap ok] Monad m => MonadKnot VarId x (LetT x m)
instance [overlap ok] Monad m => MonadLet x (LetT x m)
instance [overlap ok] MonadLet x (Let x)
instance [overlap ok] MonadKnot i x m => MonadKnot i x (StateT s m)
instance [overlap ok] MonadTrans (LetT x)

module Lava.Internal

-- | Identifies a driver in the circuit. A driver is either a primary input
--   or an output pin of a cell.
data Signal
PrimInpSig :: PrimInpId -> Signal
CellSig :: CellId -> OutPin -> Signal
data Declaration lib
PrimInput :: PrimInpId -> Declaration lib
Cell :: CellId -> lib -> [Signal] -> Declaration lib
Label :: Tag -> Signal -> Declaration lib
data DesignDB lib
DesignDB :: Map CellId (lib, [Signal]) -> Map Signal [(CellId, InPin)] -> Map Signal [Tag] -> Map Tag [Signal] -> [Signal] -> DesignDB lib
cellDB :: DesignDB lib -> Map CellId (lib, [Signal])
fanoutDB :: DesignDB lib -> Map Signal [(CellId, InPin)]
sigTagDB :: DesignDB lib -> Map Signal [Tag]
tagSigDB :: DesignDB lib -> Map Tag [Signal]
primIns :: DesignDB lib -> [Signal]
class CellLibrary lib
numIns :: CellLibrary lib => lib -> InPin
numOuts :: CellLibrary lib => lib -> OutPin
inPinName :: CellLibrary lib => lib -> InPin -> Name
inPinId :: CellLibrary lib => lib -> Name -> InPin
outPinName :: CellLibrary lib => lib -> OutPin -> Name
outPinId :: CellLibrary lib => lib -> Name -> OutPin
isFlop :: CellLibrary lib => lib -> Bool
lava2000Interp :: CellLibrary lib => Interpretation lib (Signal Bool)
cellInputs :: CellLibrary lib => CellId -> lib -> [(CellId, InPin)]
cellOutputs :: CellLibrary lib => CellId -> lib -> [Signal]
prop_uniquePrimInputs :: [Declaration t] -> Bool
prop_uniqueCells :: [Declaration t] -> Bool
prop_correctCellInputs :: CellLibrary lib => [Declaration lib] -> Bool
prop_validSignals :: CellLibrary lib => [Declaration lib] -> Bool
prop_validDecls :: CellLibrary lib => [Declaration lib] -> Bool
newtype Lava lib a
Lava :: WriterT [Declaration lib] (State (PrimInpId, CellId)) a -> Lava lib a
unLava :: Lava lib a -> WriterT [Declaration lib] (State (PrimInpId, CellId)) a
runLava :: CellLibrary lib => Lava lib a -> (a, DesignDB lib)
class (Monad m, CellLibrary lib) => MonadLava lib m | m -> lib
newPrimInpId :: MonadLava lib m => m PrimInpId
newCellId :: MonadLava lib m => m CellId
declare :: MonadLava lib m => Declaration lib -> m ()
listenDecls :: MonadLava lib m => m a -> m (a, [Declaration lib])
toLava :: MonadLava lib m => m a -> Lava lib a
inputSig :: MonadLava lib m => m Signal
cellList :: MonadLava lib m => lib -> [Signal] -> m [Signal]
labelSig :: MonadLava lib m => Tag -> Signal -> m Signal
data Interpretation lib x
Interp :: x -> (x -> x -> x) -> (lib -> ([x] -> [Maybe x])) -> Interpretation lib x
defaultVal :: Interpretation lib x -> x
accumulator :: Interpretation lib x -> x -> x -> x
propagator :: Interpretation lib x -> lib -> ([x] -> [Maybe x])
type InterpDesignDB lib x = (DesignDB lib, Map Signal x)
lookupTag :: Tag -> InterpDesignDB lib x -> [x]
depthInterp :: CellLibrary lib => Interpretation lib Int
hasLoopDB :: CellLibrary lib => Bool -> DesignDB lib -> Bool
hasLoop :: MonadLava lib m => m a -> Bool
hasCombLoop :: MonadLava lib m => m a -> Bool
data PortTree s
One :: s -> PortTree s
unOne :: PortTree s -> s
List :: [PortTree s] -> PortTree s
class Port p s | p -> s
port :: Port p s => p -> PortTree s
unport :: Port p s => PortTree s -> p
class Port p s => PortStruct p s t | p -> s t, s t -> p
mapPort :: (PortStruct pa sa t, PortStruct pb sb t) => (sa -> sb) -> (pa -> pb)
mapPortM :: (PortStruct pa sa t, PortStruct pb sb t, Monad m) => (sa -> m sb) -> (pa -> m pb)
class Port p s => PortFixed p s | p -> s
lengthFP :: PortFixed p s => Res p Int
fromListFP :: PortFixed p s => [s] -> p
askSig :: Interpretation lib x -> Signal -> Knot Signal x x
tellSigs :: Interpretation lib x -> [Signal] -> [Maybe x] -> Knot Signal x ()
interpretCells :: CellLibrary lib => Interpretation lib x -> [(Signal, x)] -> [(CellId, (lib, [Signal]))] -> Map Signal x
interpret__ :: CellLibrary lib => Interpretation lib x -> [(Signal, x)] -> (PortTree Signal, DesignDB lib) -> (PortTree x, InterpDesignDB lib x)
interpret_ :: CellLibrary lib => Interpretation lib x -> [(Signal, x)] -> Lava lib (PortTree Signal) -> (PortTree x, InterpDesignDB lib x)
interpret :: (CellLibrary lib, PortStruct ps Signal t, PortStruct px x t) => Interpretation lib x -> Lava lib ps -> (px, InterpDesignDB lib x)
inputToSig :: PortTree x -> PortTree Signal
interpretFuncP :: CellLibrary lib => Interpretation lib x -> (PortTree Signal -> Lava lib (PortTree Signal)) -> (PortTree x -> (PortTree x, InterpDesignDB lib x))
interpretFunc :: (CellLibrary lib, PortStruct pxi x ti, PortStruct psi Signal ti, PortStruct pso Signal to, PortStruct pxo x to) => Interpretation lib x -> (psi -> Lava lib pso) -> (pxi -> (pxo, InterpDesignDB lib x))
input :: (MonadLava lib m, PortFixed p Signal) => m p
inputList :: (MonadLava lib m, PortFixed p Signal) => Int -> m [p]
cell :: (MonadLava lib m, PortFixed pi Signal, PortFixed po Signal) => lib -> pi -> m po
sourceCell :: (MonadLava lib m, PortFixed p Signal) => lib -> m p
sinkCell :: (MonadLava lib m, PortFixed p Signal) => lib -> p -> m ()
physCell :: MonadLava lib m => lib -> (a -> m a)
label :: (MonadLava lib m, PortStruct p Signal t) => Tag -> p -> m p
toLava2000 :: (MonadLava lib m, PortStruct pli (Signal Bool) ti, PortStruct psi Signal ti, PortStruct pso Signal to, PortStruct plo (Signal Bool) to) => (psi -> m pso) -> (pli -> plo)
simulateSeq :: (MonadLava lib m, PortStruct pni Int ti, PortStruct psi Signal ti, PortStruct pso Signal to, PortStruct pno Int to) => (psi -> m pso) -> ([pni] -> [pno])
simulate :: (MonadLava lib m, PortStruct pni Int ti, PortStruct psi Signal ti, PortStruct pso Signal to, PortStruct pno Int to) => (psi -> m pso) -> (pni -> pno)

-- | <pre>
--   encodeBin n x
--   </pre>
--   
--   Encodes the number <tt>x</tt> as a binary number of length <tt>n</tt>.
--   The resulting list contains only zeroes and ones.
encodeBin :: Int -> Int -> [Int]
decodeBin :: [Int] -> Int
prop_encodeBin :: Property
prop_encodeDecodeBin :: Property
checkAll :: IO ()
verify :: (MonadLava lib m, PortFixed ps Signal) => (ps -> m Signal) -> IO ()
depth :: (MonadLava lib m, PortStruct ps Signal t, PortStruct pd Int t) => m ps -> (pd, InterpDesignDB lib Int)
fanout :: MonadLava lib m => m a -> InterpDesignDB lib Int
size :: MonadLava lib m => m p -> Int

module Wired.Model
class CellLibrary lib => WiredLibrary lib
featureSize :: WiredLibrary lib => Res lib Length
guideLength :: WiredLibrary lib => Layer -> Res lib Length
rowHeight :: WiredLibrary lib => Res lib Height
type Guide = (Signal, Layer_, Direction, Length)
type Wired lib = LayoutT Guide CellId (Lava lib)
class (MonadLava lib m, WiredLibrary lib, MonadLayout Guide CellId m) => MonadWired lib m
runWired :: CellLibrary lib => Wired lib a -> (a, (DesignDB lib, Floorplan Guide CellId))
convertGuide :: (Position, AbsBlock Guide CellId) -> (Signal, (Layer_, Position, Position))
mkGuideDB :: Floorplan Guide CellId -> Map Signal [(Layer_, Position, Position)]
renderWired :: WiredLibrary lib => Name -> Wired lib a -> IO ()
fpToLines :: (Signal -> Maybe Color) -> Floorplan Guide CellId -> [([(Position, Position)], Color)]
renderWiredWithNetsCol :: WiredLibrary lib => Maybe Color -> (Tag -> Maybe Color) -> Name -> Wired lib a -> IO ()
renderWiredWithNets :: WiredLibrary lib => Name -> Wired lib a -> IO ()
wire__ :: (MonadWired lib m, PortStruct p Signal t) => Direction -> Length -> Layer_ -> Width -> (p -> m p)
wire_ :: (MonadWired lib m, PortStruct p Signal t) => Direction -> Length -> Layer -> Width -> (p -> m p)
wireN :: (MonadWired lib m, PortStruct p Signal t) => Length -> Layer -> Width -> (p -> m p)
wireE :: (MonadWired lib m, PortStruct p Signal t) => Length -> Layer -> Width -> (p -> m p)
wireW :: (MonadWired lib m, PortStruct p Signal t) => Length -> Layer -> Width -> (p -> m p)
wireS :: (MonadWired lib m, PortStruct p Signal t) => Length -> Layer -> Width -> (p -> m p)
guide__ :: (MonadWired lib m, PortStruct p Signal t) => Direction -> Layer_ -> Width -> (p -> m p)
guide_ :: (MonadWired lib m, PortStruct p Signal t) => Direction -> Layer -> Width -> (p -> m p)

-- | To be used when direction doesn't matter (e.g. when <tt>guideLength =
--   0</tt>).
guide :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)
guideE :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)
guideW :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)
guideS :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)
guideN :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)
mkCell :: MonadWired lib m => Name -> Width -> Height -> m a -> m a
instance [overlap ok] Value Length
instance [overlap ok] MonadLava lib m => MonadLava lib (LayoutT s b m)
instance [overlap ok] (MonadLava lib m, WiredLibrary lib, MonadLayout Guide CellId m) => MonadWired lib m

module Export.DEF
exportDEF :: (CellLibrary lib, Port p Signal) => Name -> Wired lib p -> IO ()

module Lava

-- | Identifies a driver in the circuit. A driver is either a primary input
--   or an output pin of a cell.
data Signal
class CellLibrary lib
data Lava lib a
class (Monad m, CellLibrary lib) => MonadLava lib m | m -> lib
toLava :: MonadLava lib m => m a -> Lava lib a
type InterpDesignDB lib x = (DesignDB lib, Map Signal x)
lookupTag :: Tag -> InterpDesignDB lib x -> [x]
hasLoop :: MonadLava lib m => m a -> Bool
hasCombLoop :: MonadLava lib m => m a -> Bool
class Port p s | p -> s
class Port p s => PortStruct p s t | p -> s t, s t -> p
class Port p s => PortFixed p s | p -> s
input :: (MonadLava lib m, PortFixed p Signal) => m p
inputList :: (MonadLava lib m, PortFixed p Signal) => Int -> m [p]
label :: (MonadLava lib m, PortStruct p Signal t) => Tag -> p -> m p
toLava2000 :: (MonadLava lib m, PortStruct pli (Signal Bool) ti, PortStruct psi Signal ti, PortStruct pso Signal to, PortStruct plo (Signal Bool) to) => (psi -> m pso) -> (pli -> plo)
simulateSeq :: (MonadLava lib m, PortStruct pni Int ti, PortStruct psi Signal ti, PortStruct pso Signal to, PortStruct pno Int to) => (psi -> m pso) -> ([pni] -> [pno])
simulate :: (MonadLava lib m, PortStruct pni Int ti, PortStruct psi Signal ti, PortStruct pso Signal to, PortStruct pno Int to) => (psi -> m pso) -> (pni -> pno)

-- | <pre>
--   encodeBin n x
--   </pre>
--   
--   Encodes the number <tt>x</tt> as a binary number of length <tt>n</tt>.
--   The resulting list contains only zeroes and ones.
encodeBin :: Int -> Int -> [Int]
decodeBin :: [Int] -> Int
verify :: (MonadLava lib m, PortFixed ps Signal) => (ps -> m Signal) -> IO ()
depth :: (MonadLava lib m, PortStruct ps Signal t, PortStruct pd Int t) => m ps -> (pd, InterpDesignDB lib Int)
fanout :: MonadLava lib m => m a -> InterpDesignDB lib Int
size :: MonadLava lib m => m p -> Int

module Wired
type Wired lib = LayoutT Guide CellId (Lava lib)
class CellLibrary lib => WiredLibrary lib
featureSize :: WiredLibrary lib => Res lib Length
guideLength :: WiredLibrary lib => Layer -> Res lib Length
rowHeight :: WiredLibrary lib => Res lib Height
renderWired :: WiredLibrary lib => Name -> Wired lib a -> IO ()
renderWiredWithNetsCol :: WiredLibrary lib => Maybe Color -> (Tag -> Maybe Color) -> Name -> Wired lib a -> IO ()
renderWiredWithNets :: WiredLibrary lib => Name -> Wired lib a -> IO ()
wireN :: (MonadWired lib m, PortStruct p Signal t) => Length -> Layer -> Width -> (p -> m p)
wireS :: (MonadWired lib m, PortStruct p Signal t) => Length -> Layer -> Width -> (p -> m p)
wireW :: (MonadWired lib m, PortStruct p Signal t) => Length -> Layer -> Width -> (p -> m p)
wireE :: (MonadWired lib m, PortStruct p Signal t) => Length -> Layer -> Width -> (p -> m p)

-- | To be used when direction doesn't matter (e.g. when <tt>guideLength =
--   0</tt>).
guide :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)
guideN :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)
guideS :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)
guideW :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)
guideE :: (MonadWired lib m, PortStruct p Signal t) => Layer -> Width -> (p -> m p)

module Analysis.Timing.Library
data Slope
Rising :: Slope
Falling :: Slope
data Timing
Timing :: Time -> TransitionTime -> Timing
arrivalTime :: Timing -> Time
transitionTime :: Timing -> TransitionTime
data LayerProps
LayerProps :: Width -> Double -> Double -> LayerProps
layerWidth :: LayerProps -> Width
capPerArea :: LayerProps -> Double
edgeCap :: LayerProps -> Double
class CellLibrary lib => TimingLibrary lib
loadCaps :: TimingLibrary lib => lib -> [Capacitance]
delay :: TimingLibrary lib => lib -> InPin -> OutPin -> Slope -> Capacitance -> Timing -> Timing
class TimingLibrary lib => WireTimingLibrary lib
layerProps :: WireTimingLibrary lib => Layer_ -> Res lib LayerProps
maximumByArrival :: [Timing] -> Timing
linearDelay :: Delay -> Double -> Double -> Resistance -> Resistance -> Capacitance -> Timing -> Timing
tableDelay :: Table2D CInt TransitionTime Capacitance Time -> Table2D CInt TransitionTime Capacitance TransitionTime -> (Capacitance -> Timing -> Timing)
mkTimingTable :: (Fractional x, Fractional y, Fractional q) => CInt -> CInt -> (CInt -> CDouble) -> (CInt -> CDouble) -> (CInt -> CInt -> CDouble) -> Table2D CInt x y q
wireCap :: WireTimingLibrary lib => Layer_ -> Length -> Res lib Capacitance
instance [overlap ok] Eq Slope
instance [overlap ok] Show Slope
instance [overlap ok] Eq Timing
instance [overlap ok] Show Timing
instance [overlap ok] Eq LayerProps
instance [overlap ok] Show LayerProps

module Analysis.Timing
data TransitionTime
data Timing
Timing :: Time -> TransitionTime -> Timing
arrivalTime :: Timing -> Time
transitionTime :: Timing -> TransitionTime
class CellLibrary lib => TimingLibrary lib
analyzeTiming :: (MonadLava lib m, TimingLibrary lib, PortStruct ps Signal t, PortStruct pd Delay t) => m ps -> (pd, InterpDesignDB lib (Timing, Capacitance))
analyzeTimingW :: (WireTimingLibrary lib, PortStruct ps Signal t, PortStruct pd Delay t) => Wired lib ps -> (pd, InterpDesignDB lib (Timing, Capacitance))
instance [overlap ok] PortStruct Time Time ()
instance [overlap ok] Port Time Time


-- | Lava interface to the Nangate45 library.
--   
--   The data in this file is derived from Nangate's Open Cell Library, and
--   is subject to the license restrictions stated in
--   <a>Libs.Nangate45.LICENSE</a>.
module Libs.Nangate45.Lava
data Nangate45

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = and [A1, A2]
--   </pre>
and2_x1 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = and [A1, A2]
--   </pre>
and2_x2 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = and [A1, A2]
--   </pre>
and2_x4 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x1 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x16 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x2 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x32 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x4 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x8 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   (CI, (A, B)) -&gt; (S, CO)
--   </pre>
--   
--   Function:
--   
--   <pre>
--   S = or [and [or [and [A, B'], and [A', B]], CI'], and [(or [and [A, B'], and [A', B]])', CI]]
--   CO = or [and [A, B], and [A, CI], and [B, CI]]
--   </pre>
fa_x1 :: MonadLava Nangate45 m => (Signal, (Signal, Signal)) -> m (Signal, Signal)
fillcell_x1 :: MonadLava Nangate45 m => a -> m a
fillcell_x16 :: MonadLava Nangate45 m => a -> m a
fillcell_x2 :: MonadLava Nangate45 m => a -> m a
fillcell_x32 :: MonadLava Nangate45 m => a -> m a
fillcell_x4 :: MonadLava Nangate45 m => a -> m a
fillcell_x8 :: MonadLava Nangate45 m => a -> m a

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; (S, CO)
--   </pre>
--   
--   Function:
--   
--   <pre>
--   S = or [and [A, B'], and [A', B]]
--   CO = and [A, B]
--   </pre>
ha_x1 :: MonadLava Nangate45 m => (Signal, Signal) -> m (Signal, Signal)

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x1 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x16 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x2 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x32 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x4 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x8 :: MonadLava Nangate45 m => Signal -> m Signal

-- | Interface:
--   
--   <pre>
--   Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = 0
--   </pre>
logic0_x1 :: MonadLava Nangate45 m => m Signal

-- | Interface:
--   
--   <pre>
--   Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = 1
--   </pre>
logic1_x1 :: MonadLava Nangate45 m => m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (and [A1, A2])'
--   </pre>
nand2_x1 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (and [A1, A2])'
--   </pre>
nand2_x2 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (and [A1, A2])'
--   </pre>
nand2_x4 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [A1, A2])'
--   </pre>
nor2_x1 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [A1, A2])'
--   </pre>
nor2_x2 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [A1, A2])'
--   </pre>
nor2_x4 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = or [A1, A2]
--   </pre>
or2_x1 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = or [A1, A2]
--   </pre>
or2_x2 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = or [A1, A2]
--   </pre>
or2_x4 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [and [A, B'], and [A', B]])'
--   </pre>
xnor2_x1 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [and [A, B'], and [A', B]])'
--   </pre>
xnor2_x2 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = or [and [A, B'], and [A', B]]
--   </pre>
xor2_x1 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = or [and [A, B'], and [A', B]]
--   </pre>
xor2_x2 :: MonadLava Nangate45 m => (Signal, Signal) -> m Signal
instance [overlap ok] Eq Nangate45
instance [overlap ok] Show Nangate45
instance [overlap ok] TimingLibrary Nangate45
instance [overlap ok] CellLibrary Nangate45


-- | Wired interface to the Nangate45 library.
--   
--   The data in this file is derived from Nangate's Open Cell Library, and
--   is subject to the license restrictions stated in
--   <a>Libs.Nangate45.LICENSE</a>.
module Libs.Nangate45.Wired
data Nangate45

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = and [A1, A2]
--   </pre>
and2_x1 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = and [A1, A2]
--   </pre>
and2_x2 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = and [A1, A2]
--   </pre>
and2_x4 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x1 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x16 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x2 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x32 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x4 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = A
--   </pre>
buf_x8 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (CI, (A, B)) -&gt; (S, CO)
--   </pre>
--   
--   Function:
--   
--   <pre>
--   S = or [and [or [and [A, B'], and [A', B]], CI'], and [(or [and [A, B'], and [A', B]])', CI]]
--   CO = or [and [A, B], and [A, CI], and [B, CI]]
--   </pre>
fa_x1 :: (Signal, (Signal, Signal)) -> Wired Nangate45 (Signal, Signal)
fillcell_x1 :: a -> Wired Nangate45 a
fillcell_x16 :: a -> Wired Nangate45 a
fillcell_x2 :: a -> Wired Nangate45 a
fillcell_x32 :: a -> Wired Nangate45 a
fillcell_x4 :: a -> Wired Nangate45 a
fillcell_x8 :: a -> Wired Nangate45 a

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; (S, CO)
--   </pre>
--   
--   Function:
--   
--   <pre>
--   S = or [and [A, B'], and [A', B]]
--   CO = and [A, B]
--   </pre>
ha_x1 :: (Signal, Signal) -> Wired Nangate45 (Signal, Signal)

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x1 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x16 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x2 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x32 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x4 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   A -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = A'
--   </pre>
inv_x8 :: Signal -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = 0
--   </pre>
logic0_x1 :: Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = 1
--   </pre>
logic1_x1 :: Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (and [A1, A2])'
--   </pre>
nand2_x1 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (and [A1, A2])'
--   </pre>
nand2_x2 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (and [A1, A2])'
--   </pre>
nand2_x4 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [A1, A2])'
--   </pre>
nor2_x1 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [A1, A2])'
--   </pre>
nor2_x2 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [A1, A2])'
--   </pre>
nor2_x4 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = or [A1, A2]
--   </pre>
or2_x1 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = or [A1, A2]
--   </pre>
or2_x2 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A1, A2) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = or [A1, A2]
--   </pre>
or2_x4 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [and [A, B'], and [A', B]])'
--   </pre>
xnor2_x1 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; ZN
--   </pre>
--   
--   Function:
--   
--   <pre>
--   ZN = (or [and [A, B'], and [A', B]])'
--   </pre>
xnor2_x2 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = or [and [A, B'], and [A', B]]
--   </pre>
xor2_x1 :: (Signal, Signal) -> Wired Nangate45 Signal

-- | Interface:
--   
--   <pre>
--   (A, B) -&gt; Z
--   </pre>
--   
--   Function:
--   
--   <pre>
--   Z = or [and [A, B'], and [A', B]]
--   </pre>
xor2_x2 :: (Signal, Signal) -> Wired Nangate45 Signal
instance [overlap ok] WireTimingLibrary Nangate45
instance [overlap ok] WiredLibrary Nangate45

module Lava.Patterns
(.<.) :: (b -> c) -> (a -> b) -> (a -> c)
(.>.) :: (a -> b) -> (b -> c) -> (a -> c)
swap :: (a, b) -> (b, a)
swapl :: [a] -> [a]
copy :: a -> (a, a)
halveList :: [a] -> ([a], [a])
zipp :: ([a], [b]) -> [(a, b)]
unzipp :: [(a, b)] -> ([a], [b])
riffle :: [a] -> [a]
unriffle :: [a] -> [a]
pair :: [a] -> [(a, a)]
unpair :: [(a, a)] -> [a]
append :: ([a], [a]) -> [a]
mon :: Monad m => (a -> b) -> (a -> m b)
(->-) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
(-<-) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
serial :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
compose :: Monad m => [a -> m a] -> (a -> m a)
composeN :: Monad m => Int -> (a -> m a) -> (a -> m a)
(-|-) :: Monad m => (a -> m b) -> (c -> m d) -> ((a, c) -> m (b, d))
par :: Monad m => (a -> m b) -> (c -> m d) -> ((a, c) -> m (b, d))
parl :: Monad m => ([a] -> m [b]) -> ([a] -> m [b]) -> ([a] -> m [b])
two :: Monad m => ([a] -> m [b]) -> ([a] -> m [b])
ilv :: Monad m => ([a] -> m [b]) -> ([a] -> m [b])
iter :: Monad m => Int -> ((a -> m b) -> (a -> m b)) -> ((a -> m b) -> (a -> m b))
twoN :: Monad m => Int -> ([a] -> m [b]) -> ([a] -> m [b])
ilvN :: Monad m => Int -> ([a] -> m [b]) -> ([a] -> m [b])
bfly :: Monad m => Int -> ([a] -> m [a]) -> ([a] -> m [a])
pmap :: Monad m => ((a, a) -> m (b, b)) -> ([a] -> m [b])
tri :: Monad m => (a -> m a) -> ([a] -> m [a])
mirror :: Monad m => ((a, b) -> m (c, d)) -> ((b, a) -> m (d, c))
row :: Monad m => ((a, b) -> m (c, a)) -> ((a, [b]) -> m ([c], a))
column :: Monad m => ((a, b) -> m (b, c)) -> (([a], b) -> m (b, [c]))
grid :: Monad m => ((a, b) -> m (b, a)) -> (([a], [b]) -> m ([b], [a]))
