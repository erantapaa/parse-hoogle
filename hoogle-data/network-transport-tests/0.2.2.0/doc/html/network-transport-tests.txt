-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Unit tests for Network.Transport implementations
--   
--   Unit tests for Network.Transport implementations
@package network-transport-tests
@version 0.2.2.0


-- | Add tracing to the IO monad (see examples).
--   
--   <ul>
--   <li><i>Usage</i></li>
--   </ul>
--   
--   <pre>
--   {-# LANGUAGE RebindableSyntax #-}
--   import Prelude hiding (catch, (&gt;&gt;=), (&gt;&gt;), return, fail)
--   import Traced
--   </pre>
--   
--   <ul>
--   <li><i>Example</i></li>
--   </ul>
--   
--   <pre>
--   test1 :: IO Int
--   test1 = do
--     Left x  &lt;- return (Left 1 :: Either Int Int)
--     putStrLn "Hello world"
--     Right y &lt;- return (Left 2 :: Either Int Int)
--     return (x + y)
--   </pre>
--   
--   outputs
--   
--   <pre>
--   Hello world
--   *** Exception: user error (Pattern match failure in do expression at Traced.hs:187:3-9)
--   Trace:
--   0  Left 2
--   1  Left 1
--   </pre>
--   
--   <ul>
--   <li><i>Guards</i></li>
--   </ul>
--   
--   Use the following idiom instead of using <a>guard</a>:
--   
--   <pre>
--   test2 :: IO Int
--   test2 = do
--     Left x &lt;- return (Left 1 :: Either Int Int)
--     True   &lt;- return (x == 3)
--     return x
--   </pre>
--   
--   The advantage of this idiom is that it gives you line number
--   information when the guard fails:
--   
--   <pre>
--   *Traced&gt; test2
--   *** Exception: user error (Pattern match failure in do expression at Traced.hs:193:3-6)
--   Trace:
--   0  Left 1
--   </pre>
module Network.Transport.Tests.Traced

-- | Like <a>Monad</a> but bind is only defined for <tt>Trace</tt>able
--   instances
class MonadS m
returnS :: MonadS m => a -> m a
bindS :: (MonadS m, Traceable a) => m a -> (a -> m b) -> m b
failS :: MonadS m => String -> m a
seqS :: MonadS m => m a -> m b -> m b

-- | Redefinition of <a>return</a>
return :: MonadS m => a -> m a

-- | Redefinition of <a>&gt;&gt;=</a>
(>>=) :: (MonadS m, Traceable a) => m a -> (a -> m b) -> m b

-- | Redefinition of <a>&gt;&gt;</a>
(>>) :: MonadS m => m a -> m b -> m b

-- | Redefinition of <a>fail</a>
fail :: MonadS m => String -> m a

-- | Definition of <a>ifThenElse</a> for use with RebindableSyntax
ifThenElse :: Bool -> a -> a -> a
data Showable
Showable :: a -> Showable
class Traceable a
trace :: Traceable a => a -> Maybe Showable
traceShow :: Show a => a -> Maybe Showable
instance [overlap ok] Typeable TracedException
instance [overlap ok] Show TracedException
instance [overlap ok] MonadS IO
instance [overlap ok] Exception TracedException
instance [overlap ok] Traceable IOException
instance [overlap ok] Traceable [Char]
instance [overlap ok] Traceable (MVar a)
instance [overlap ok] Traceable ByteString
instance [overlap ok] Traceable Bool
instance [overlap ok] Traceable Word64
instance [overlap ok] Traceable Word32
instance [overlap ok] Traceable Int64
instance [overlap ok] Traceable Int32
instance [overlap ok] Traceable Int
instance [overlap ok] Traceable ()
instance [overlap ok] Traceable a => Traceable [a]
instance [overlap ok] Traceable a => Traceable (Maybe a)
instance [overlap ok] (Traceable a, Traceable b, Traceable c) => Traceable (a, b, c)
instance [overlap ok] (Traceable a, Traceable b) => Traceable (a, b)
instance [overlap ok] (Traceable a, Traceable b) => Traceable (Either a b)
instance [overlap ok] Show Showable

module Network.Transport.Tests.Auxiliary

-- | Run the given test, catching timeouts and exceptions
runTest :: String -> IO () -> IO Bool

-- | Run a bunch of tests and throw an exception if any fails
runTests :: [(String, IO ())] -> IO ()

-- | Like fork, but throw exceptions in the child thread to the parent
forkTry :: IO () -> IO ThreadId

-- | Like try, but specialized to SomeException
trySome :: IO a -> IO (Either SomeException a)

-- | Random thread delay between 0 and the specified max
randomThreadDelay :: Int -> IO ()
instance [overlap ok] Traceable Float
instance [overlap ok] Traceable (Chan a)
instance [overlap ok] Traceable ThreadId
instance [overlap ok] Traceable SomeException
instance [overlap ok] Traceable EndPointAddress
instance [overlap ok] Show err => Traceable (TransportError err)
instance [overlap ok] Traceable Event
instance [overlap ok] Traceable Connection
instance [overlap ok] Traceable Transport
instance [overlap ok] Traceable EndPoint

module Network.Transport.Tests.Multicast

-- | Node for the "No confusion" test
noConfusionNode :: Transport -> [MVar MulticastAddress] -> [MVar ()] -> Int -> [ByteString] -> MVar () -> IO ()

-- | Test that distinct multicast groups are not confused
testNoConfusion :: Transport -> Int -> IO ()

-- | Test multicast
testMulticast :: Transport -> IO ()

module Network.Transport.Tests

-- | Server that echoes messages straight back to the origin endpoint.
echoServer :: EndPoint -> IO ()

-- | Ping client used in a few tests
ping :: EndPoint -> EndPointAddress -> Int -> ByteString -> IO ()

-- | Basic ping test
testPingPong :: Transport -> Int -> IO ()

-- | Test that endpoints don't get confused
testEndPoints :: Transport -> Int -> IO ()
testConnections :: Transport -> Int -> IO ()

-- | Test that closing one connection does not close the other
testCloseOneConnection :: Transport -> Int -> IO ()

-- | Test that if A connects to B and B connects to A, B can still send to
--   A after A closes its connection to B (for instance, in the TCP
--   transport, the socket pair connecting A and B should not yet be
--   closed).
testCloseOneDirection :: Transport -> Int -> IO ()

-- | Collect events and order them by connection ID
collect :: EndPoint -> Maybe Int -> Maybe Int -> IO [(ConnectionId, [[ByteString]])]

-- | Open connection, close it, then reopen it (In the TCP transport this
--   means the socket will be closed, then reopened)
--   
--   Note that B cannot expect to receive all of A's messages on the first
--   connection before receiving the messages on the second connection.
--   What might (and sometimes does) happen is that finishes sending all of
--   its messages on the first connection (in the TCP transport, the first
--   socket pair) while B is behind on reading _from_ this connection
--   (socket pair) -- the messages are "in transit" on the network (these
--   tests are done on localhost, so there are in some OS buffer). Then
--   when A opens the second connection (socket pair) B will spawn a new
--   thread for this connection, and hence might start interleaving
--   messages from the first and second connection.
--   
--   This is correct behaviour, however: the transport API guarantees
--   reliability and ordering _per connection_, but not _across_
--   connections.
testCloseReopen :: Transport -> Int -> IO ()

-- | Test lots of parallel connection attempts
testParallelConnects :: Transport -> Int -> IO ()

-- | Test that sending on a closed connection gives an error
testSendAfterClose :: Transport -> Int -> IO ()

-- | Test that closing the same connection twice has no effect
testCloseTwice :: Transport -> Int -> IO ()

-- | Test that we can connect an endpoint to itself
testConnectToSelf :: Transport -> Int -> IO ()

-- | Test that we can connect an endpoint to itself multiple times
testConnectToSelfTwice :: Transport -> Int -> IO ()

-- | Test that we self-connections no longer work once we close our
--   endpoint or our transport
testCloseSelf :: IO (Either String Transport) -> IO ()

-- | Test various aspects of <a>closeEndPoint</a>
testCloseEndPoint :: Transport -> Int -> IO ()
testCloseTransport :: IO (Either String Transport) -> IO ()

-- | Remote node attempts to connect to a closed local endpoint
testConnectClosedEndPoint :: Transport -> IO ()

-- | We should receive an exception when doing a <a>receive</a> after we
--   have been notified that an endpoint has been closed
testExceptionOnReceive :: IO (Either String Transport) -> IO ()

-- | Test what happens when the argument to <a>send</a> is an exceptional
--   value
testSendException :: IO (Either String Transport) -> IO ()

-- | If threads get killed while executing a <a>connect</a>, <a>send</a>,
--   or <a>close</a>, this should not affect other threads.
--   
--   The intention of this test is to see what happens when a asynchronous
--   exception happes _while executing a send_. This is exceedingly
--   difficult to guarantee, however. Hence we run a large number of tests
--   and insert random thread delays -- and even then it might not happen.
--   Moreover, it will only happen when we run on multiple cores.
testKill :: IO (Either String Transport) -> Int -> IO ()

-- | Set up conditions with a high likelyhood of "crossing" (for transports
--   that multiplex lightweight connections across heavyweight connections)
testCrossing :: Transport -> Int -> IO ()
testTransport :: IO (Either String Transport) -> IO ()
testStreams :: Eq a => [a] -> [[a]] -> Bool
