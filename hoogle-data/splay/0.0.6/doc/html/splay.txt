-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic splay-based sequence representation
--   
@package splay
@version 0.0.6


-- | A generic sequence representation with arbitary annotations, for use
--   as a base for implementations of various collection types
--   
--   The empty sequence and the concatenation operation are available in
--   the <tt><a>Monoid</a></tt> instance of <tt><a>Splay</a></tt>
module Data.Splay

-- | A representation of a sequence of values of type <tt>a</tt> using a
--   splay tree, which can also contain measurements of type <tt>s</tt>.
data Splay s a

-- | <tt>s</tt> is a measurement of <tt>a</tt>
class Monoid s => Measured s a | a -> s
measure :: Measured s a => a -> s

-- | Construct a sequence of only one element
singleton :: Measured s a => a -> Splay s a

-- | Split the sequence into two part: the longest prefix whose measure
--   does <i>not</i> satisfy the predicate, and the rest of the sequence
--   
--   The predicate must be monotonic. Note that <tt><a>False</a> &lt;
--   <a>True</a></tt>.
split :: Measured s a => (s -> Bool) -> Splay s a -> (Splay s a, Splay s a)

-- | Traverse the sequence
--   
--   <pre>
--   traverseSplay :: (Measured sa a, Measured sb b)
--                 =&gt; Traversal a b (Splay sa a) (Splay sb b)
--   
--   </pre>
traverseSplay :: (Measured sa a, Measured sb b, Applicative f) => (a -> f b) -> Splay sa a -> f (Splay sb b)
instance Measured s a => Monoid (Splay s a)
instance Measured s a => Measured s (Splay s a)


-- | An example implementation of sequences using splay trees.
--   
--   Some of the names in this module clashes with <a>Prelude</a>
--   functions, so this module should be imported qualified.
module Data.Splay.Sequence

-- | General purpose finite sequences
data Seq a

-- | Construct a sequence of only one element
singleton :: a -> Seq a

-- | Add an element to the left end of a sequence
(<|) :: a -> Seq a -> Seq a

-- | Add an element to the right end of a sequence
(|>) :: Seq a -> a -> Seq a

-- | Construct a sequence from a list
--   
--   <i>Warning</i>: The underlying splay tree created this function will
--   be very unbalanced. However note that the amortized running time of
--   other functions will be unaffected. This is to be fixed in the future.
fromList :: [a] -> Seq a

-- | Is this sequence empty?
null :: Seq a -> Bool

-- | The number of elements in the sequence
length :: Seq a -> Int

-- | <tt><a>splitAt</a> n s</tt> splits <tt>s</tt> into the first
--   <tt>n</tt> elements and the rest. If <tt>n</tt> is larger than the
--   length of <tt>s</tt>, <tt>(s, mempty)</tt> will be returned
splitAt :: Int -> Seq a -> (Seq a, Seq a)
instance Num Size
instance Eq Size
instance Ord Size
instance Show a => Show (Seq a)
instance Ord a => Ord (Seq a)
instance Eq a => Eq (Seq a)
instance Monoid (Seq a)
instance Traversable Seq
instance Foldable Seq
instance Functor Seq
instance Measured Size (Item a)
instance Monoid Size
