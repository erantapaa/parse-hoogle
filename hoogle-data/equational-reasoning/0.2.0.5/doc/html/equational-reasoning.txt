-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Proof assistant for Haskell using DataKinds & PolyKinds
--   
@package equational-reasoning
@version 0.2.0.5

module Proof.Induction

-- | <tt>genInduction ''Type "inductionT"</tt> defines the induction scheme
--   for <tt>Type</tt> named <tt>inductionT</tt>.
genInduction :: Name -> String -> Q [Dec]


-- | Provides type synonyms for logical connectives.
module Proof.Propositional
type (/\) a b = (a, b)
type (\/) a b = Either a b
type Not a = a -> Void
exfalso :: a -> Not a -> b
orIntroL :: a -> a \/ b
orIntroR :: b -> a \/ b
orElim :: a \/ b -> (a -> c) -> (b -> c) -> c
andIntro :: a -> b -> a /\ b
andElimL :: a /\ b -> a
andElimR :: a /\ b -> b
orAssocL :: a \/ (b \/ c) -> (a \/ b) \/ c
orAssocR :: (a \/ b) \/ c -> a \/ (b \/ c)
andAssocL :: a /\ (b /\ c) -> (a /\ b) /\ c
andAssocR :: (a /\ b) /\ c -> a /\ (b /\ c)

module Proof.Equational

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
--   
--   <i>Since: 4.7.0.0</i>
data (:~:) (a :: k) (b :: k) :: k -> k -> *
Refl :: (:~:) k a1 a1
type (:=:) = (:~:)

-- | Symmetry of equality
sym :: (:~:) k a b -> (:~:) k b a

-- | Transitivity of equality
trans :: (:~:) k a b -> (:~:) k b c -> (:~:) k a c
class Preorder eq => Equality (eq :: k -> k -> *)
symmetry :: Equality eq => eq a b -> eq b a
class Preorder (eq :: k -> k -> *)
reflexivity :: Preorder eq => Sing a -> eq a a
transitivity :: Preorder eq => eq a b -> eq b c -> eq a c
reflexivity' :: (SingI x, Preorder r) => r x x
type (:\/:) a b = Either a b
type (:/\:) a b = (a, b)
(=<=) :: Preorder r => r x y -> Reason r y z -> r x z
(=>=) :: Preorder r => r y z -> Reason r x y -> r x z
(=~=) :: Preorder r => r x y -> Sing y -> r x y
data Leibniz a b
Leibniz :: (forall f. f a -> f b) -> Leibniz a b
apply :: Leibniz a b -> forall f. f a -> f b
data Reason eq x y
Because :: Sing y -> eq x y -> Reason eq x y
because :: Sing y -> eq x y -> Reason eq x y
by :: Sing y -> eq x y -> Reason eq x y
(===) :: Equality eq => eq x y -> Reason eq y z -> eq x z
start :: Preorder eq => Sing a -> eq a a
byDefinition :: (SingI a, Preorder eq) => eq a a

-- | <i>Warning: There are some goals left yet unproven.</i>
admitted :: Reason eq x y

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
cong :: Proxy f -> a :=: b -> f a :=: f b
cong' :: (Sing m -> Sing (f m)) -> a :=: b -> f a :=: f b
class Proposition (f :: k -> *) where type family OriginalProp (f :: k -> *) (n :: k) :: *
unWrap :: Proposition f => f n -> OriginalProp f n
wrap :: Proposition f => OriginalProp f n -> f n
class FromBool (c :: *) where type family Predicate c :: Bool type family Args c :: [*]
fromBool :: (FromBool c, Predicate c ~ True) => Args c :~> c
fromRefl :: (Preorder eq, SingI b) => a :=: b -> eq a b
fromLeibniz :: (Preorder eq, SingI a) => Leibniz a b -> eq a b
reflToLeibniz :: a :=: b -> Leibniz a b
leibnizToRefl :: Leibniz a b -> a :=: b

-- | Type coercion. <a>coerce</a> is using <tt>unsafeCoerce a</tt>. So,
--   please, please do not provide the <tt>undefined</tt> as the proof.
--   Using this function instead of pattern-matching on equality proof, you
--   can reduce the overhead introduced by run-time proof.
coerce :: (a :=: b) -> f a -> f b

-- | Coercion for identity types.
coerce' :: a :=: b -> a -> b
instance Equality Leibniz
instance Preorder Leibniz
instance Preorder (->)
instance Equality (:=:)
instance Preorder (:=:)
