-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | "Ties the knot" on a given set of structures that reference each other by
keys.
--   
--   <a>Ties the knot</a> on a given set of structures that reference each
--   other by keys - replaces the keys with their respective values. Takes
--   <tt>Map k (v k)</tt> and converts into <tt>Map k v'</tt> where
--   <tt>v'</tt> is the fixed point of <tt>v</tt>. See the homepage for
--   examples.
@package tie-knot
@version 0.2


-- | Module for tying the knot on data structures that reference each other
--   by some kind of keys. The <a>tie</a> function replaces all such
--   references with the actual value, creating possibly recursive or
--   cyclic data structures.
--   
--   The module re-exports a part of the recursion-schemes package.
--   
--   An example how to construct a structure with circular dependencies:
--   
--   <pre>
--   data Person = Person { name :: String, loves :: [Person] }
--   -- Define a variant of Person where the recursive type
--   -- is given as a parameter and the embedding function.
--   data Loves t = Loves { _name :: String, _loves :: [t] }
--   type instance Base Person = Loves
--   instance Unfoldable Person where
--     embed ~(Loves n ps)    = Person n ps
--   
--   -- The easisest way to get 'Foldable' + 'Functor' is to implement
--   -- 'Traversable' and then just use the default implementations.
--   instance T.Traversable Loves where
--       traverse f (Loves n ns) = Loves n &lt;$&gt; T.traverse f ns
--   
--   instance Functor Loves where
--       fmap = T.fmapDefault
--   instance F.Foldable Loves where
--       foldMap = T.foldMapDefault
--   
--   -- Let's create a person with cicrular dependencies:
--   alice :: Person
--   alice = fromJust . Map.lookup "Alice" .
--               tie' . Map.fromList . map (\l -&gt; (_name l, l)) $ lst
--     where
--       lst = [ Loves "Alice" ["Bob", "cat"]
--             , Loves "Bob"   ["Alice"]
--             -- you may disagree, but the cat thinks of itself as Person
--             , Loves "cat"   ["cat"]
--             ]
--   </pre>
module Data.Knot

-- | Checks consistency by calling <a>isConsistent</a> and then and ties
--   the knot using <a>tie'</a>.
tie :: (Ord k, Foldable (Base v), Unfoldable v) => RefMap k (Base v) -> Either (TieError k) (Map k v)

-- | Ties the knot without checking consistency. If the references are
--   inconsistent, an exception is raised.
tie' :: (Ord k, Unfoldable v) => RefMap k (Base v) -> Map k v

-- | Check the loader for consistency, i.e. if all referenced keys have a
--   corresponding value. Values need to implement <a>Foldable</a> that
--   traverses over all referenced keys.
isConsistent :: (Ord k, Foldable v, Functor v) => RefMap k v -> Either (TieError k) (RefMap k v)

-- | Represents a set of data <tt>v</tt> that reference each other using
--   keys of type <tt>k</tt>.
type RefMap k v = Map k (v k)

-- | Possible errors when tying the knot.
data TieError k

-- | A value with key k1 referenced non-existent key k2.
MissingKey :: k -> k -> TieError k
class Functor (Base t) => Unfoldable t
embed :: Unfoldable t => Base t t -> t
embed :: Unfoldable t => Base t t -> t
instance Show k => Show (TieError k)
instance Eq k => Eq (TieError k)
instance Ord k => Ord (TieError k)
