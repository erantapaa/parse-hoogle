-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utility library for monads, particularly those involving state.
--   
@package monad-state
@version 0.2.0.3

module Control.Monad.Runnable

-- | Monads that can be run in the IO monad
class (Monad m, RunnableContainer (RunContainer m)) => MonadRunnable m where type family RunData m type family ConstructType m :: * -> * type family RunContainer m :: * -> *
run :: MonadRunnable m => m a -> RunData m -> (RunContainer m) ((ConstructType m) a)
runData :: MonadRunnable m => m (RunData m)
construct :: MonadRunnable m => ((ConstructType m) a) -> m a
class RunnableContainer m
rcToIO :: RunnableContainer m => m a -> IO a
instance RunnableContainer Identity
instance RunnableContainer IO

module System.Timeout.Monad

-- | Run an action that is runnable in the IO monad within a time limit
--   
--   The time limit is specified in microseconds, and is subject to the
--   same sas <a>timeout</a>. Finally, the action to be run itself is
--   passed. The result is an IO action, which is normally lifted with
--   <a>liftIO</a> to be run in the same IO (see <a>timeoutM</a>). The
--   action, when run, returns the resulting monadic value if it was run in
--   time. Conceptually, one can think of this as running a local monad,
--   perhaps a copy, in the IO monad; the effects of running in the IO
--   monad are unavoidably irreversible, but the resulting monadic value
--   can be optionally ignored, in which case it is not evaluated in the
--   parent monad and no effects are present in the outer layers of the
--   monad.
timeoutR :: (Integral i, Monad m, MonadRunnable m) => i -> m a -> RunData m -> IO (Maybe (m a))

-- | Equivalent to <a>timeoutM</a>, but the result is the same monad,
--   making passing the data needed to run the monad unnecessary
timeoutM :: (Integral i, Monad m, MonadIO m, MonadRunnable m) => i -> m a -> m (Maybe (m a))

-- | If the void action runs in time, it is run and <a>True</a> is
--   returned; otherwise <a>False</a> is returned when running the action
--   in time does not succeed
--   
--   For example, to run a void action within one second, one might write
--   
--   <pre>
--   succeeded &lt;- timeoutVoid
--   </pre>
--   
--   The effects of "action" will be fully executed if succeeded is
--   <a>True</a>; if succeeded is <a>False</a>, the action could not run in
--   time, and only global IO actions that were performed while the local
--   monad was being evaluated will be run.
timeoutVoid :: (Integral i, Monad m, MonadIO m, MonadRunnable m) => i -> m () -> m Bool

module Control.Monad.Abort.Instances
mapAbortT :: (m (Either r a) -> n (Either r' b)) -> AbortT r m a -> AbortT r' n b
instance MonadWriter m => MonadWriter (AbortT r m)
instance MonadState m => MonadState (AbortT r m)
instance MonadReader m => MonadReader (AbortT r m)
instance MonadRWS m => MonadRWS (AbortT r m)
instance MonadError m => MonadError (AbortT r m)
instance MonadCont m => MonadCont (AbortT r m)

module Control.Monad.Abort.Class

-- | An abort monad, parametrized by the type <tt>r</tt> of the value to
--   return.
type Abort r = AbortT r Identity

-- | An abort monad transformer parametrized by
--   
--   <ul>
--   <li><tt>r</tt> - the value that will ultimately be returned; and</li>
--   <li><tt>m</tt> - the inner monad.</li>
--   </ul>
--   
--   The <a>AbortT</a> type wraps a monadic value that is either
--   
--   <ul>
--   <li><a>Left</a> <tt>r</tt>, which indicates that the monadic
--   computation has terminated with result <tt>r</tt> and so all further
--   steps in the computation should be ignored; or</li>
--   <li><a>Right</a> <tt>a</tt>, which indicates that the computation is
--   proceding normally and that its current value is <tt>a</tt>.</li>
--   </ul>
newtype AbortT r (m :: * -> *) a :: * -> (* -> *) -> * -> *
AbortT :: m (Either r a) -> AbortT r a
unwrapAbortT :: AbortT r a -> m (Either r a)
class Monad m => MonadAbort m where type family AbortResultType m
abort :: MonadAbort m => (AbortResultType m) -> m a
instance (MonadAbort m, Monoid w) => MonadAbort (WriterT w m)
instance (MonadAbort m, Monoid w) => MonadAbort (WriterT w m)
instance MonadAbort m => MonadAbort (StateT s m)
instance MonadAbort m => MonadAbort (StateT s m)
instance (MonadAbort m, Monoid w) => MonadAbort (RWST r w s m)
instance (MonadAbort m, Monoid w) => MonadAbort (RWST r w s m)
instance MonadAbort m => MonadAbort (ReaderT r m)
instance (MonadAbort m, Error e) => MonadAbort (ErrorT e m)
instance MonadAbort m => MonadAbort (MaybeT m)
instance MonadAbort m => MonadAbort (ListT m)
instance MonadAbort m => MonadAbort (IdentityT m)
instance Monad m => MonadAbort (AbortT r m)

module Control.Monad.Abort
class Monad m => MonadAbort m where type family AbortResultType m
abort :: MonadAbort m => (AbortResultType m) -> m a

-- | An abort monad, parametrized by the type <tt>r</tt> of the value to
--   return.
type Abort r = AbortT r Identity

-- | Execute the abort monad computation and return the resulting value.
runAbort :: Abort r r -> r

-- | An abort monad transformer parametrized by
--   
--   <ul>
--   <li><tt>r</tt> - the value that will ultimately be returned; and</li>
--   <li><tt>m</tt> - the inner monad.</li>
--   </ul>
--   
--   The <a>AbortT</a> type wraps a monadic value that is either
--   
--   <ul>
--   <li><a>Left</a> <tt>r</tt>, which indicates that the monadic
--   computation has terminated with result <tt>r</tt> and so all further
--   steps in the computation should be ignored; or</li>
--   <li><a>Right</a> <tt>a</tt>, which indicates that the computation is
--   proceding normally and that its current value is <tt>a</tt>.</li>
--   </ul>
newtype AbortT r (m :: * -> *) a :: * -> (* -> *) -> * -> *
AbortT :: m (Either r a) -> AbortT r a
unwrapAbortT :: AbortT r a -> m (Either r a)

-- | Execute the abort monad computation and return the resulting (monadic)
--   value.
runAbortT :: Monad m => AbortT r m r -> m r
mapAbortT :: (m (Either r a) -> n (Either r' b)) -> AbortT r m a -> AbortT r' n b

module Control.Monad.Record
maybeAbort :: Monad m => r -> Maybe a -> AbortT r m a
maybeAbortM :: (MonadTrans t, Monad m, MonadAbort (t m)) => AbortResultType (t m) -> MaybeT m a -> t m a

-- | Create a lens out of a getter and setter.
lensGS :: (f -> a) -> (a -> f -> f) -> f :-> a
class MLens l a f where type family MLensA l a f type family MLensF l a f
toLens :: MLens l a f => l f a -> (MLensF l a f) :-> Maybe (MLensA l a f)
newtype (:-->) f a
MaybeLens :: f :-> Maybe a -> (:-->) f a
unMaybeLens :: (:-->) f a -> f :-> Maybe a
getM :: MonadState m => (StateType m :-> a) -> m a
setM :: MonadState m => (StateType m :-> a) -> a -> m ()
modM :: MonadState m => (StateType m :-> a) -> (a -> a) -> m ()
getMAbort :: (MonadState m, MLens l b f, MLensF l b f ~ StateType m) => r -> l f b -> (MLensA l b f :-> a) -> AbortT r m a
setMAbort :: (MonadState m, MLens l b f, MLensF l b f ~ StateType m) => l f b -> (MLensA l b f :-> a) -> a -> m ()
modMAbort :: (MonadState m, MLens l b f, MLensF l b f ~ StateType m) => l f b -> (MLensA l b f :-> a) -> (a -> a) -> m ()
askM :: MonadReader m => (EnvType m :-> a) -> m a
liftState :: MonadState m => (StateType m :-> s) -> StateT s m a -> m a
liftSubState :: (Monad m, MonadTrans t, MonadState (t m)) => (StateType (t m) :-> s) -> StateT s m a -> t m a
liftSubMaybeState :: (Monad m, MonadTrans t, MonadState (t m), MLens l b f, MLensF l b f ~ StateType (t m)) => l f b -> StateT (MLensA l b f) m a -> MaybeT (t m) a

-- | <a>get</a>
(<:) :: (f :-> a) -> f -> a

-- | <a>set</a>
(=:) :: (f :-> a) -> a -> f -> f

-- | <a>modify</a>
($:) :: (f :-> a) -> (a -> a) -> f -> f

-- | <a>getM</a>
(<::) :: MonadState m => (StateType m :-> a) -> m a

-- | <a>setM</a>
(=::) :: MonadState m => (StateType m :-> a) -> a -> m ()

-- | <a>modM</a>
($::) :: MonadState m => (StateType m :-> a) -> (a -> a) -> m ()

-- | <a>getMAbort</a>
(<<:) :: (MonadState m, MLens l b f, MLensF l b f ~ StateType m) => r -> l f b -> (MLensA l b f :-> a) -> AbortT r m a

-- | <a>setMAbort</a>
(<=:) :: (MonadState m, MLens l b f, MLensF l b f ~ StateType m) => l f b -> (MLensA l b f :-> a) -> a -> m ()

-- | <a>modMAbort</a>
(<$:) :: (MonadState m, MLens l b f, MLensF l b f ~ StateType m) => l f b -> (MLensA l b f :-> a) -> (a -> a) -> m ()

-- | <a>getMAbort</a> ()
(<<::) :: (MonadState m, MLens l b f, MLensF l b f ~ StateType m) => l f b -> (MLensA l b f :-> a) -> AbortT () m a
(<->) :: (MLens l a f, MLens l' a' f', MLensA l a f ~ MLensF l' a' f') => l' f' a' -> l f a -> MLensF l a f :--> MLensA l' a' f'

-- | <a>askM</a>
(<:<) :: MonadReader m => (EnvType m :-> a) -> m a

-- | <a>liftState</a>
(>$<) :: MonadState m => (StateType m :-> s) -> StateT s m a -> m a

-- | <a>liftSubState</a>
(>$>) :: Monad m => (s :-> s') -> StateT s' m a -> StateT s m a

-- | <a>liftSubMaybeState</a>
(>$$>) :: (Monad m, MonadTrans t, MonadState (t m), MLens l b f, MLensF l b f ~ StateType (t m)) => l f b -> StateT (MLensA l b f) m a -> MaybeT (t m) a
instance Category (:-->)
instance MLens (:-->) a f
instance MLens (Lens Total) (Maybe i -> Maybe i) (Maybe o -> Maybe o)

module Control.Monad.Short
type MonadShortable r m a = AbortT r m a
type MonadErrorShortable m a = MonadShortable String m a
short :: Monad m => m a -> MonadShortable r m a
unShort :: Monad m => MonadShortable r m r -> m r

-- | Minimal complete definition: unError
class Monad m => MonadShort m where unError_ = unError () unErrorShort r = unShort . unError r unErrorShort_ = unShort . unError_
unError :: MonadShort m => r -> MonadErrorShortable m a -> MonadShortable r m a
unError_ :: MonadShort m => MonadErrorShortable m a -> MonadShortable () m a
unErrorShort :: MonadShort m => r -> MonadErrorShortable m r -> m r
unErrorShort_ :: MonadShort m => MonadErrorShortable m () -> m ()
