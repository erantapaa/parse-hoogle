-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monadic take on a 2,500-year-old board game - library.
--   
@package goatee
@version 0.3.0


-- | Common definitions for a renderer that supports failure.
module Game.Goatee.Lib.Renderer

-- | A monad for accumulating string output with the possibility of
--   failure.
type Render = WriterT String (Except String)

-- | Returns either the rendered result on the right, or a message
--   describing a failure on the left.
runRender :: Render a -> Either String String

-- | Wraps a renderer in an exception handler that, when the renderer or
--   something it calls fails, will add context about this renderer's
--   invocation to the failure message.
rendererOf :: Show a => String -> (a -> Render ()) -> a -> Render ()


-- | Base-10 arbitrary-precision floating-point numbers.
module Game.Goatee.Common.Bigfloat

-- | A base-10, infinite-precision, floating-point number. Implemented as
--   an infinite-precision significand together with an exponent, such that
--   the numeric value is equal to <tt><a>significand</a> f * (10 ^
--   <a>exponent</a> f)</tt>. The exponent is a limited-precision
--   <a>Int</a>, because some operations may break if the exponent is
--   larger (specifically <a>show</a> and <a>toDouble</a>). This shouldn't
--   be an issue for Goatee.
--   
--   These values form an integral domain.
--   
--   The <a>Show</a> instance always outputs in decimal notation, never
--   scientific notation. Examples:
--   
--   <pre>
--   300   (never trailing .0 if there's no fractional part)
--   0.1   (never redundant trailing or leading zeros)
--   </pre>
--   
--   Similarly, the <a>Read</a> instance accepts numbers matching the regex
--   <tt>-?\d+(\.\d+)?(e-?\d+)?</tt>. Scientific exponent notation is
--   supported for reading, for ease of converting <a>Double</a>s to
--   <a>Bigfloat</a>s.
data Bigfloat

-- | <tt>encode significand exponent</tt> creates a <a>Bigfloat</a> value
--   whose numeric value is <tt>significand * (10 ^ exponent)</tt>.
encode :: Integer -> Int -> Bigfloat
significand :: Bigfloat -> Integer
exponent :: Bigfloat -> Int

-- | Converts a <a>Double</a> to a <a>Bigfloat</a> (with as much precision
--   as the <a>Double</a> <a>Show</a> instance provides).
fromDouble :: Double -> Bigfloat

-- | Converts a <a>Bigfloat</a> to a <a>Double</a>, lossily.
toDouble :: Bigfloat -> Double
instance Read Bigfloat
instance Show Bigfloat
instance Num Bigfloat
instance Ord Bigfloat
instance Eq Bigfloat


-- | Common utilities used throughout the project.
module Game.Goatee.Common

-- | Drops the element at an index from a list. If the index is out of
--   bounds then the list is returned unmodified.
listDeleteAt :: Int -> [a] -> [a]

-- | Inserts the element into the list before the given position. If the
--   position is less than 0 or greater than the length of the list, then
--   the index is clamped to this range.
listInsertAt :: Int -> a -> [a] -> [a]

-- | <tt>listReplace old new list</tt> replaces all occurrences of
--   <tt>old</tt> with <tt>new</tt> in <tt>list</tt>.
listReplace :: Eq a => a -> a -> [a] -> [a]

-- | Modifies the element at a specific index in a list.
listUpdate :: Show a => (a -> a) -> Int -> [a] -> [a]

-- | If any item is a <a>Left</a>, then the list of <a>Left</a>s is
--   returned, otherwise the list of <a>Right</a>s is returned.
andEithers :: [Either a b] -> Either [a] [b]

-- | <tt>for</tt> is <tt>flip map</tt>.
for :: [a] -> (a -> b) -> [b]

-- | Transforms both values in a homogeneous tuple.
mapTuple :: (a -> b) -> (a, a) -> (b, b)

-- | Inverts a map, collecting all of the keys that map to a single value
--   in one list in the result map. No guarantees are made on the order of
--   the keys in each value's list. If you want the results in ascending
--   order, apply <tt><a>map</a> <a>sort</a></tt> to the result.
mapInvert :: Ord v => Map k v -> Map v [k]

-- | Executes the monadic function if a <a>Maybe</a> contains a value.
whenMaybe :: Monad m => Maybe a -> (a -> m ()) -> m ()

-- | Finds the first tuple whose first element is true, and returns its
--   second element. If all of the first values are false, then the first
--   argument to <tt>cond</tt> is returned instead.
cond :: a -> [(Bool, a)] -> a

-- | A function form of <tt>if</tt> that takes its test last.
if' :: a -> a -> Bool -> a

-- | <a>and</a> in a monad. Executes the actions in the list in order. If
--   any action returns false then the remaining actions are skipped and
--   the result is false. Otherwise all actions returned true, and the
--   result is true. An empty list returns true.
andM :: Monad m => [m Bool] -> m Bool

-- | <a>forM_</a> that also passes in the index of each element.
forIndexM_ :: Monad m => [a] -> (Int -> a -> m ()) -> m ()

-- | <tt>whileM test body</tt> repeatedly evaluates <tt>test</tt> until it
--   returns false. Every time <tt>test</tt> returns true, <tt>body</tt> is
--   executed once.
whileM :: Monad m => m Bool -> m () -> m ()

-- | <tt>whileM' test body</tt> repeatedly evaluates <tt>test</tt> until it
--   returns <a>Nothing</a>. Every time it returns a <a>Just</a>, that
--   value is passed to <tt>body</tt> and the result is executed.
whileM' :: Monad m => m (Maybe a) -> (a -> m ()) -> m ()

-- | <tt>doWhileM init body</tt> repeatedly calls <tt>body</tt> with
--   <tt>init</tt>. As long as <tt>body</tt> returns a <tt>Right</tt>
--   value, it is re-executed with the returned value. When it returns a
--   <tt>Left</tt> value, the loop stops and the value is returned.
doWhileM :: Monad m => a -> (a -> m (Either b a)) -> m b


-- | Constants and data types for property values used in SGF game trees.
module Game.Goatee.Lib.Types

-- | The FF versions supported by Goatee. Currently only 4.
supportedFormatVersions :: [Int]

-- | The default SGF version to use when <tt>FF[]</tt> is not specified in
--   a root node.
--   
--   This value is actually INCORRECT: SGF defines it to be 1, but because
--   we don't support version 1 yet, for the sake of ignoring this issue
--   (for now!) in tests, we fix the default to be 4.
defaultFormatVersion :: Int

-- | SGF supports multiple game types. This list contains the game types
--   that Goatee supports, which is only Go (1).
supportedGameTypes :: [Int]

-- | The default size of the board. The FF[4] SGF spec says that the
--   default Go board is 19x19 square.
boardSizeDefault :: Int

-- | The minimum board size allowed by FF[4], 1.
boardSizeMin :: Int

-- | The maximum board size allowed by FF[4], 52.
boardSizeMax :: Int

-- | A coordinate on a Go board. <tt>(0, 0)</tt> refers to the upper-left
--   corner of the board. The first component is the horizontal position;
--   the second component is the vertical position.
type Coord = (Int, Int)

-- | A structure for compact representation of a list of coordinates.
--   Contains a list of individual points, as well as a list of rectangles
--   of points denoted by an ordered pair of the upper-left point and the
--   lower-right point. The union of the single points and points contained
--   within rectangles make up all of the points a <tt>CoordList</tt>
--   represents. There is no rule saying that adjacent points have to be
--   grouped into rectangles; it's perfectly valid (although possibly
--   inefficient) to never use rectangles.
--   
--   For any <tt>CoordList</tt>, all of the following hold:
--   
--   <ol>
--   <li>Any point may be specified at most once, either in the singles
--   list or in a single rectangle.</li>
--   <li>For a rectangle <tt>((x0,y0), (x1,y1))</tt>, <tt>x0 &lt;= x1</tt>
--   and <tt>y0 &lt;= y1</tt> and <tt>(x0,y0) /= (x1,y1)</tt> (otherwise
--   the point belongs in the singles list).</li>
--   </ol>
data CoordList

-- | Returns the single points in a <a>CoordList</a>.
coordListSingles :: CoordList -> [Coord]

-- | Returns the rectangles in a <a>CoordList</a>.
coordListRects :: CoordList -> [(Coord, Coord)]

-- | Constructs a <a>CoordList</a> containing a single point.
coord1 :: Coord -> CoordList

-- | Constructs a <a>CoordList</a> containing the given single points. For
--   rectangle detection, use <a>buildCoordList</a>.
coords :: [Coord] -> CoordList

-- | Constructs a <a>CoordList</a> containing the given single points and
--   rectangles.
coords' :: [Coord] -> [(Coord, Coord)] -> CoordList

-- | A <a>CoordList</a> that contains no points.
emptyCoordList :: CoordList

-- | Converts a compact <a>CoordList</a> to a list of coordinates.
expandCoordList :: CoordList -> [Coord]

-- | Constructs a <a>CoordList</a> from a list of <a>Coord</a>s, doing some
--   not-completely-stupid rectangle detection. The order of data in the
--   result is unspecified.
buildCoordList :: [Coord] -> CoordList

-- | <tt>starLines width height</tt> returns <a>Just</a> a list of
--   row/column indices that have star points on a board of the given size,
--   or <a>Nothing</a> if the board size does not have star points defined.
starLines :: Int -> Int -> Maybe [Int]

-- | <tt>isStarPoint width height x y</tt> determines whether <tt>(x,
--   y)</tt> is a known star point on a board of the given width and
--   height.
isStarPoint :: Int -> Int -> Int -> Int -> Bool

-- | <tt>handicapStones width height handicap</tt> returns a list of points
--   where handicap stones should be placed for the given handicap, if
--   handicap points are defined for the given board size, otherwise
--   <a>Nothing</a>.
handicapStones :: Int -> Int -> Int -> Maybe [Coord]

-- | A class for SGF data types that are coercable to and from strings.
--   
--   The construction of an SGF value with <a>stringToSgf</a> may process
--   the input, such that the resulting stringlike value does not represent
--   the same string as the input. In other words, the following does *not*
--   necessarily hold:
--   
--   <pre>
--   sgfToString . stringToSgf = id   (does not necessarily hold!)
--   </pre>
--   
--   The following does hold, however, for a single stringlike type:
--   
--   <pre>
--   stringToSgf . sgfToString = id
--   </pre>
--   
--   The <a>String</a> instance is defined with <tt>sgfToString =
--   stringToSgf = id</tt>. For other types, the string returned by
--   <a>sgfToString</a> is in a raw, user-editable format: characters that
--   need to be escaped in serialized SGF aren't escaped, but the returned
--   value is otherwise similar to SGF format.
class Stringlike a
sgfToString :: Stringlike a => a -> String
stringToSgf :: Stringlike a => String -> a

-- | Converts between <a>Stringlike</a> types via a string.
--   
--   <pre>
--   convertStringlike = stringToSgf . sgfToString
--   </pre>
convertStringlike :: (Stringlike a, Stringlike b) => a -> b

-- | An SGF text value.
data Text

-- | Converts an SGF <a>Text</a> to a string.
fromText :: Text -> String

-- | Converts a string to an SGF <a>Text</a>.
toText :: String -> Text

-- | An SGF SimpleText value.
data SimpleText

-- | Converts an SGF <a>SimpleText</a> to a string.
fromSimpleText :: SimpleText -> String

-- | Converts a string to an SGF <a>SimpleText</a>, replacing all
--   whitespaces (including newlines) with spaces.
toSimpleText :: String -> SimpleText

-- | The value type for an <tt>UnknownProperty</tt>. Currently represented
--   as a string.
data UnknownPropertyValue

-- | Returns the string contained within the <tt>UnknownProperty</tt> this
--   value is from.
fromUnknownPropertyValue :: UnknownPropertyValue -> String

-- | Constructs a value for a <tt>UnknownProperty</tt>.
toUnknownPropertyValue :: String -> UnknownPropertyValue

-- | An SGF real value is a decimal number of unspecified precision.
type RealValue = Bigfloat

-- | An SGF double value: either 1 or 2, nothing else.
data DoubleValue
Double1 :: DoubleValue
Double2 :: DoubleValue

-- | Stone color: black or white.
data Color
Black :: Color
White :: Color

-- | Returns the logical negation of a stone color, yang for yin and yin
--   for yang.
cnot :: Color -> Color

-- | SGF flags that control how move variations are to be presented while
--   displaying the game.
data VariationMode
VariationMode :: VariationModeSource -> Bool -> VariationMode

-- | Which moves to display as variations.
variationModeSource :: VariationMode -> VariationModeSource

-- | Whether to overlay variations on the board.
variationModeBoardMarkup :: VariationMode -> Bool

-- | An enumeration that describes which variations are shown.
data VariationModeSource

-- | Show children of the current move.
ShowChildVariations :: VariationModeSource

-- | Show alternatives to the current move.
ShowCurrentVariations :: VariationModeSource

-- | The default variation mode as defined by the SGF spec is
--   <tt>VariationMode ShowChildVariations True</tt>.
defaultVariationMode :: VariationMode

-- | Parses a numeric variation mode, returning nothing if the number is
--   invalid.
toVariationMode :: Int -> Maybe VariationMode

-- | Returns the integer value for a variation mode.
fromVariationMode :: VariationMode -> Int

-- | A list of arrows, each specified as <tt>(startCoord, endCoord)</tt>.
type ArrowList = [(Coord, Coord)]

-- | A list of lines, each specified as <tt>(startCoord, endCoord)</tt>.
type LineList = [Line]

-- | An undirected line between two coordinates.
data Line
Line :: Coord -> Coord -> Line

-- | Converts a <a>Line</a> to a pair of <a>Coord</a>s representing the
--   line's endpoints.
lineToPair :: Line -> (Coord, Coord)

-- | A list of labels, each specified with a string and a coordinate about
--   which to center the string.
type LabelList = [(Coord, SimpleText)]

-- | The markings that SGF supports annotating coordinates with.
data Mark
MarkCircle :: Mark
MarkSquare :: Mark
MarkTriangle :: Mark
MarkX :: Mark
MarkSelected :: Mark
data GameResult
GameResultWin :: Color -> WinReason -> GameResult
GameResultDraw :: GameResult
GameResultVoid :: GameResult
GameResultUnknown :: GameResult
GameResultOther :: SimpleText -> GameResult
data WinReason
WinByScore :: RealValue -> WinReason
WinByResignation :: WinReason
WinByTime :: WinReason
WinByForfeit :: WinReason

-- | A ruleset used for a Go game. Can be one of the rulesets defined by
--   the SGF specification, or a custom string.
data Ruleset
KnownRuleset :: RulesetType -> Ruleset
UnknownRuleset :: String -> Ruleset

-- | The rulesets defined by the SGF specification, for use with
--   <a>Ruleset</a>.
data RulesetType
RulesetAga :: RulesetType
RulesetIng :: RulesetType
RulesetJapanese :: RulesetType
RulesetNewZealand :: RulesetType

-- | Returns the string representation for a ruleset.
fromRuleset :: Ruleset -> String

-- | Parses a string representation of a ruleset.
toRuleset :: String -> Ruleset
instance Show CoordList
instance Eq Text
instance Show Text
instance Eq SimpleText
instance Show SimpleText
instance Eq UnknownPropertyValue
instance Show UnknownPropertyValue
instance Bounded DoubleValue
instance Enum DoubleValue
instance Eq DoubleValue
instance Ord DoubleValue
instance Show DoubleValue
instance Bounded Color
instance Enum Color
instance Eq Color
instance Ord Color
instance Show Color
instance Bounded VariationModeSource
instance Enum VariationModeSource
instance Eq VariationModeSource
instance Ord VariationModeSource
instance Show VariationModeSource
instance Eq VariationMode
instance Show VariationMode
instance Show Line
instance Bounded Mark
instance Enum Mark
instance Eq Mark
instance Ord Mark
instance Show Mark
instance Eq WinReason
instance Show WinReason
instance Eq GameResult
instance Show GameResult
instance Bounded RulesetType
instance Enum RulesetType
instance Eq RulesetType
instance Ord RulesetType
instance Show RulesetType
instance Eq Ruleset
instance Show Ruleset
instance Stringlike Ruleset
instance Stringlike GameResult
instance Eq Line
instance Stringlike UnknownPropertyValue
instance Stringlike SimpleText
instance Stringlike Text
instance Stringlike String
instance Eq CoordList


-- | Parsers of property values.
module Game.Goatee.Lib.Property.Parser
colorParser :: Parser Color
coordElistParser :: Parser CoordList
coordListParser :: Parser CoordList
coordPairListParser :: Parser [(Coord, Coord)]
doubleParser :: Parser DoubleValue
gameResultParser :: Parser GameResult
labelListParser :: Parser [(Coord, SimpleText)]
lineListParser :: Parser [Line]
moveParser :: Parser (Maybe Coord)
noneParser :: Parser ()
integralParser :: (Integral a, Read a) => Parser a
realParser :: Parser RealValue
rulesetParser :: Parser Ruleset
simpleTextPairParser :: Parser (SimpleText, SimpleText)

-- | A parser for SGF SimpleText property values.
simpleTextParser :: Parser SimpleText
sizeParser :: Parser (Int, Int)
textParser :: Parser Text
unknownPropertyParser :: Parser UnknownPropertyValue
variationModeParser :: Parser VariationMode
compose :: Parser a -> Parser b -> Parser (a, b)
line :: Parser Int
simpleText :: Bool -> Parser SimpleText

-- | A parser for SGF text property values. Its argument should be true if
--   the text is inside of a composed property value, so <tt>':'</tt>
--   should terminate the value in addition to <tt>']'</tt>.
text :: Bool -> Parser String
instance Monoid CoordListMonoid


-- | Structures and functions for working with SGF node properties.
module Game.Goatee.Lib.Property

-- | An SGF property that gives a node meaning. A property is <i>known</i>
--   if its meaning is defined by the SGF specification, and <i>unknown</i>
--   otherwise. Known properties each have their own data constructors.
--   Unknown properties are represented by the <a>UnknownProperty</a> data
--   constructor.
data Property

-- | Black move (nothing iff pass).
B :: (Maybe Coord) -> Property

-- | Execute move unconditionally (even if illegal).
KO :: Property

-- | Assign move number.
MN :: Integer -> Property

-- | White move (nothing iff pass).
W :: (Maybe Coord) -> Property

-- | Assign black stones.
AB :: CoordList -> Property

-- | Assign empty stones.
AE :: CoordList -> Property

-- | Assign white stones.
AW :: CoordList -> Property

-- | Player to play.
PL :: Color -> Property

-- | Comment.
C :: Text -> Property

-- | Even position.
DM :: DoubleValue -> Property

-- | Good for black.
GB :: DoubleValue -> Property

-- | Good for white.
GW :: DoubleValue -> Property

-- | Hotspot.
HO :: DoubleValue -> Property

-- | Node name.
N :: SimpleText -> Property

-- | Unclear position.
UC :: DoubleValue -> Property

-- | Node value.
V :: RealValue -> Property

-- | Bad move.
BM :: DoubleValue -> Property

-- | Doubtful move.
DO :: Property

-- | Interesting move.
IT :: Property

-- | Tesuji.
TE :: DoubleValue -> Property

-- | Arrows.
AR :: ArrowList -> Property

-- | Mark points with circles.
CR :: CoordList -> Property

-- | Dim points.
DD :: CoordList -> Property

-- | Label points with text.
LB :: LabelList -> Property

-- | Lines.
LN :: LineList -> Property

-- | Mark points with <tt>X</tt>s.
MA :: CoordList -> Property

-- | Mark points as selected.
SL :: CoordList -> Property

-- | Mark points with squares.
SQ :: CoordList -> Property

-- | Mark points with trianges.
TR :: CoordList -> Property

-- | Application info.
AP :: SimpleText -> SimpleText -> Property

-- | Charset for SimpleText and Text.
CA :: SimpleText -> Property

-- | File format version.
FF :: Int -> Property

-- | Game (must be 1 = Go).
GM :: Int -> Property

-- | Variation display format.
ST :: VariationMode -> Property

-- | Board size, columns then rows.
SZ :: Int -> Int -> Property

-- | Name of annotator.
AN :: SimpleText -> Property

-- | Rank of black player.
BR :: SimpleText -> Property

-- | Name of black team.
BT :: SimpleText -> Property

-- | Copyright info.
CP :: SimpleText -> Property

-- | Dates played.
DT :: SimpleText -> Property

-- | Event name.
EV :: SimpleText -> Property

-- | Game comment, or background, or summary.
GC :: Text -> Property

-- | Game name.
GN :: SimpleText -> Property

-- | Information about the opening.
ON :: SimpleText -> Property

-- | The method used for overtime.
OT :: SimpleText -> Property

-- | Name of black player.
PB :: SimpleText -> Property

-- | Where the game was played.
PC :: SimpleText -> Property

-- | Name of white player.
PW :: SimpleText -> Property

-- | Result of the game.
RE :: GameResult -> Property

-- | Round info.
RO :: SimpleText -> Property

-- | Ruleset used.
RU :: Ruleset -> Property

-- | Source of the game.
SO :: SimpleText -> Property

-- | Time limit, in seconds.
TM :: RealValue -> Property

-- | Name of user or program who entered the game.
US :: SimpleText -> Property

-- | Rank of white player.
WR :: SimpleText -> Property

-- | Name of white team.
WT :: SimpleText -> Property

-- | Black time left.
BL :: RealValue -> Property

-- | Black moves left in byo-yomi period.
OB :: Int -> Property

-- | White moves left in byo-yomi period.
OW :: Int -> Property

-- | White time left.
WL :: RealValue -> Property

-- | Set viewing region.
VW :: CoordList -> Property

-- | Handicap stones (&gt;=2).
HA :: Int -> Property

-- | Komi.
KM :: RealValue -> Property

-- | Black territory.
TB :: CoordList -> Property

-- | White territory.
TW :: CoordList -> Property
UnknownProperty :: String -> UnknownPropertyValue -> Property

-- | The property types that SGF uses to group properties.
data PropertyType

-- | Cannot mix with setup nodes.
MoveProperty :: PropertyType

-- | Cannot mix with move nodes.
SetupProperty :: PropertyType

-- | May only appear in root nodes.
RootProperty :: PropertyType

-- | At most one on any path.
GameInfoProperty :: PropertyType

-- | May appear anywhere in the game tree.
GeneralProperty :: PropertyType

-- | A class for types that contain metadata about a <a>Property</a>. The
--   main instance of this class is <a>Property</a> itself;
--   <a>Property</a>s can be treated as though they have metadata directly.
--   When referring to a property in general rather than a specific
--   instance, use the values of <a>PropertyInfo</a> and
--   <a>ValuedPropertyInfo</a>.
--   
--   See also <a>ValuedDescriptor</a>.
class Descriptor a
propertyName :: Descriptor a => a -> String
propertyType :: Descriptor a => a -> PropertyType
propertyInherited :: Descriptor a => a -> Bool
propertyPredicate :: Descriptor a => a -> Property -> Bool
propertyValueParser :: Descriptor a => a -> Parser Property
propertyValueRenderer :: Descriptor a => a -> Property -> Render ()
propertyValueRendererPretty :: Descriptor a => a -> Property -> Render ()

-- | A class for <a>Descriptor</a>s of properties that also contain values.
class (Descriptor a, Eq v) => ValuedDescriptor v a | a -> v
propertyValue :: ValuedDescriptor v a => a -> Property -> v
propertyBuilder :: ValuedDescriptor v a => a -> v -> Property

-- | An existential type for any property descriptor. <a>AnyDescriptor</a>
--   has a <a>Descriptor</a> instance, so there is no need to extract the
--   value with a pattern match before using <a>Descriptor</a> methods.
data AnyDescriptor
AnyDescriptor :: a -> AnyDescriptor

-- | An existential type for any descriptor of a property that holds a
--   value of a specific type. Has instances for <a>Descriptor</a> and
--   <a>ValuedDescriptor</a>, similar to <a>AnyDescriptor</a>.
data AnyValuedDescriptor v
AnyValuedDescriptor :: a -> AnyValuedDescriptor v
type AnyCoordListDescriptor = AnyValuedDescriptor CoordList

-- | Metadata for a property that does not contain a value. Corresponds to
--   a nullary data constructor of <a>Property</a>.
data PropertyInfo

-- | Metadata for a property that contains a value. Corresponds to a
--   non-nullary data constructor of <a>Property</a>.
data ValuedPropertyInfo v
ValuedPropertyInfo :: String -> PropertyType -> Bool -> (Property -> Bool) -> PropertyValueType v -> (Property -> v) -> (v -> Property) -> ValuedPropertyInfo v

-- | Internal to this module, do not use outside. Template Haskell function
--   to declare a property that does not contain a value.
--   
--   <pre>
--   $(defProperty "KO" 'MoveProperty False)
--   </pre>
--   
--   This example declares a <tt>propertyKO :: <a>PropertyInfo</a></tt>
--   that is a <a>MoveProperty</a> and is not inherited.
defProperty :: String -> Name -> Bool -> DecsQ

-- | Internal to this module, do not use outside. Template Haskell function
--   to declare a property that contains a value.
--   
--   <pre>
--   $(defValuedProperty "B" 'MoveProperty False 'maybeCoordPrinter)
--   </pre>
--   
--   This example declares a <tt>propertyB :: <a>ValuedPropertyInfo</a>
--   (Maybe <a>Coord</a>)</tt> that is a <a>MoveProperty</a> and is not
--   inherited. The value type is automatically inferred.
defValuedProperty :: String -> Name -> Bool -> Name -> DecsQ
propertyB :: ValuedPropertyInfo (Maybe Coord)
propertyKO :: PropertyInfo
propertyMN :: ValuedPropertyInfo Integer
propertyW :: ValuedPropertyInfo (Maybe Coord)
propertyAB :: ValuedPropertyInfo CoordList
propertyAE :: ValuedPropertyInfo CoordList
propertyAW :: ValuedPropertyInfo CoordList
propertyPL :: ValuedPropertyInfo Color
propertyC :: ValuedPropertyInfo Text
propertyDM :: ValuedPropertyInfo DoubleValue
propertyGB :: ValuedPropertyInfo DoubleValue
propertyGW :: ValuedPropertyInfo DoubleValue
propertyHO :: ValuedPropertyInfo DoubleValue
propertyN :: ValuedPropertyInfo SimpleText
propertyUC :: ValuedPropertyInfo DoubleValue
propertyV :: ValuedPropertyInfo RealValue
propertyBM :: ValuedPropertyInfo DoubleValue
propertyDO :: PropertyInfo
propertyIT :: PropertyInfo
propertyTE :: ValuedPropertyInfo DoubleValue
propertyAR :: ValuedPropertyInfo ArrowList
propertyCR :: ValuedPropertyInfo CoordList
propertyDD :: ValuedPropertyInfo CoordList
propertyLB :: ValuedPropertyInfo LabelList
propertyLN :: ValuedPropertyInfo LineList
propertyMA :: ValuedPropertyInfo CoordList
propertySL :: ValuedPropertyInfo CoordList
propertySQ :: ValuedPropertyInfo CoordList
propertyTR :: ValuedPropertyInfo CoordList
propertyAP :: ValuedPropertyInfo (SimpleText, SimpleText)
propertyCA :: ValuedPropertyInfo SimpleText
propertyFF :: ValuedPropertyInfo Int
propertyGM :: ValuedPropertyInfo Int
propertyST :: ValuedPropertyInfo VariationMode
propertySZ :: ValuedPropertyInfo (Int, Int)
propertyAN :: ValuedPropertyInfo SimpleText
propertyBR :: ValuedPropertyInfo SimpleText
propertyBT :: ValuedPropertyInfo SimpleText
propertyCP :: ValuedPropertyInfo SimpleText
propertyDT :: ValuedPropertyInfo SimpleText
propertyEV :: ValuedPropertyInfo SimpleText
propertyGC :: ValuedPropertyInfo Text
propertyGN :: ValuedPropertyInfo SimpleText
propertyON :: ValuedPropertyInfo SimpleText
propertyOT :: ValuedPropertyInfo SimpleText
propertyPB :: ValuedPropertyInfo SimpleText
propertyPC :: ValuedPropertyInfo SimpleText
propertyPW :: ValuedPropertyInfo SimpleText
propertyRE :: ValuedPropertyInfo GameResult
propertyRO :: ValuedPropertyInfo SimpleText
propertyRU :: ValuedPropertyInfo Ruleset
propertySO :: ValuedPropertyInfo SimpleText
propertyTM :: ValuedPropertyInfo RealValue
propertyUS :: ValuedPropertyInfo SimpleText
propertyWR :: ValuedPropertyInfo SimpleText
propertyWT :: ValuedPropertyInfo SimpleText
propertyBL :: ValuedPropertyInfo RealValue
propertyOB :: ValuedPropertyInfo Int
propertyOW :: ValuedPropertyInfo Int
propertyWL :: ValuedPropertyInfo RealValue
propertyVW :: ValuedPropertyInfo CoordList
propertyHA :: ValuedPropertyInfo Int
propertyKM :: ValuedPropertyInfo RealValue
propertyTB :: ValuedPropertyInfo CoordList
propertyTW :: ValuedPropertyInfo CoordList

-- | A list of descriptors for all known <a>Property</a>s.
allKnownDescriptors :: [AnyDescriptor]

-- | Builds a <a>ValuedPropertyInfo</a> for an unknown property with the
--   given name. <i>Does not check that the name is actually unknown.</i>
propertyUnknown :: String -> ValuedPropertyInfo UnknownPropertyValue

-- | Returns a descriptor for any <a>Property</a>, known or unknown.
--   Because a <a>Property</a> has a <a>Descriptor</a> instance, this
--   function is not normally necessary for use outside of this module, but
--   it can be used to throw away a value associated with a <a>Property</a>
--   and retain only the metadata.
propertyInfo :: Property -> AnyDescriptor

-- | Returns a descriptor for the given property name. The name does not
--   have to be for a known property; an unknown property will use
--   <a>propertyUnknown</a>.
descriptorForName :: String -> AnyDescriptor

-- | Returns a descriptor for a known property with the given name, or
--   <a>Nothing</a> if the name does not belong to a known property.
descriptorForName' :: String -> Maybe AnyDescriptor

-- | Descriptors for setup properties that assign stones to the board. For
--   use with <a>stoneAssignmentPropertyToStone</a> and
--   <a>stoneToStoneAssignmentProperty</a>.
stoneAssignmentProperties :: [AnyCoordListDescriptor]

-- | Converts a descriptor in <a>stoneAssignmentProperties</a> to the type
--   of stone it assigns.
stoneAssignmentPropertyToStone :: AnyCoordListDescriptor -> Maybe Color

-- | Converts a type of stone assignment to a descriptor in
--   <a>stoneAssignmentProperties</a>.
stoneToStoneAssignmentProperty :: Maybe Color -> AnyCoordListDescriptor

-- | Returns the descriptor for a mark.
markProperty :: Mark -> ValuedPropertyInfo CoordList


-- | Properties of Goatee the application.
module Game.Goatee.App

-- | A string containing the name of this application, <tt>"Goatee"</tt>.
applicationName :: String

-- | A user-presentable copyright message.
applicationCopyright :: String

-- | The home page for Goatee on the web.
applicationWebsite :: String

-- | A list of contributors to Goatee.
applicationAuthors :: [String]


-- | SGF data structures modelling the hierarchical game tree.
module Game.Goatee.Lib.Tree

-- | An SGF collection of game trees.
data Collection
Collection :: [Node] -> Collection
collectionTrees :: Collection -> [Node]

-- | See <a>NodeWithDeepEquality</a>.
newtype CollectionWithDeepEquality
CollectionWithDeepEquality :: Collection -> CollectionWithDeepEquality
collectionWithDeepEquality :: CollectionWithDeepEquality -> Collection

-- | An SGF game tree node. Unlike in the SGF spec, we represent a game
--   tree with nodes uniformly, rather than having the separation between
--   sequences and nodes.
data Node
Node :: [Property] -> [Node] -> Node
nodeProperties :: Node -> [Property]
nodeChildren :: Node -> [Node]

-- | A wrapper around <a>Node</a> with an <a>Eq</a> instance that considers
--   two nodes equal iff they contain the same properties (not necessarily
--   in the same order), and if they contain children (in the same order)
--   whose nodes are recursively equal.
--   
--   This instance is not on <a>Node</a> directly because it is not the
--   only obvious sense of equality (only comparing properties would be
--   another one), and it's also potentially expensive.
newtype NodeWithDeepEquality
NodeWithDeepEquality :: Node -> NodeWithDeepEquality
nodeWithDeepEquality :: NodeWithDeepEquality -> Node

-- | A node with no properties and no children.
emptyNode :: Node

-- | Returns a fresh root <a>Node</a> with <a>AP</a> set to Goatee and
--   optionally with a board size set via <a>SZ</a>.
rootNode :: Maybe (Int, Int) -> Node

-- | Searches for a matching property in a node's property list.
findProperty :: Descriptor a => a -> Node -> Maybe Property

-- | Searches for a matching property in a property list.
findProperty' :: Descriptor a => a -> [Property] -> Maybe Property

-- | Retrieves the value of a property in a node's property list.
findPropertyValue :: ValuedDescriptor v a => a -> Node -> Maybe v

-- | Retrieves the value of a property in a property list.
findPropertyValue' :: ValuedDescriptor v a => a -> [Property] -> Maybe v

-- | Appends a property to a node's property list.
addProperty :: Property -> Node -> Node

-- | <tt>addChild child parent</tt> appends a child node to a node's child
--   list.
addChild :: Node -> Node -> Node

-- | <tt>addChildAt index child parent</tt> inserts a child node into a
--   node's child list at the given index, shifting all nodes at or after
--   the given index to the right. If the position is less than 0 or
--   greater than the length of the list, then the index is clamped to this
--   range.
addChildAt :: Int -> Node -> Node -> Node

-- | <tt>deleteChildAt index node</tt> deletes the child at the given index
--   from the node. If the index is invalid, <tt>node</tt> is returned.
deleteChildAt :: Int -> Node -> Node

-- | Returns a list of validation errors for the current node, an empty
--   list if no errors are detected.
validateNode :: Bool -> Bool -> Node -> [String]
instance Show Node
instance Show Collection
instance Show CollectionWithDeepEquality
instance Eq NodeWithDeepEquality
instance Eq CollectionWithDeepEquality


-- | Data structures that wrap and provide a higher-level interface to the
--   SGF game tree, including a zipper that navigates the tree and provides
--   the current board state.
module Game.Goatee.Lib.Board

-- | Properties that are specified in the root nodes of game trees.
data RootInfo
RootInfo :: Int -> Int -> VariationMode -> RootInfo
rootInfoWidth :: RootInfo -> Int
rootInfoHeight :: RootInfo -> Int
rootInfoVariationMode :: RootInfo -> VariationMode

-- | Properties that are specified in game info nodes.
data GameInfo
GameInfo :: RootInfo -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe Ruleset -> Maybe RealValue -> Maybe SimpleText -> Maybe GameResult -> Maybe SimpleText -> Maybe Text -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> Maybe SimpleText -> GameInfo
gameInfoRootInfo :: GameInfo -> RootInfo
gameInfoBlackName :: GameInfo -> Maybe SimpleText
gameInfoBlackTeamName :: GameInfo -> Maybe SimpleText
gameInfoBlackRank :: GameInfo -> Maybe SimpleText
gameInfoWhiteName :: GameInfo -> Maybe SimpleText
gameInfoWhiteTeamName :: GameInfo -> Maybe SimpleText
gameInfoWhiteRank :: GameInfo -> Maybe SimpleText
gameInfoRuleset :: GameInfo -> Maybe Ruleset
gameInfoBasicTimeSeconds :: GameInfo -> Maybe RealValue
gameInfoOvertime :: GameInfo -> Maybe SimpleText
gameInfoResult :: GameInfo -> Maybe GameResult
gameInfoGameName :: GameInfo -> Maybe SimpleText
gameInfoGameComment :: GameInfo -> Maybe Text
gameInfoOpeningComment :: GameInfo -> Maybe SimpleText
gameInfoEvent :: GameInfo -> Maybe SimpleText
gameInfoRound :: GameInfo -> Maybe SimpleText
gameInfoPlace :: GameInfo -> Maybe SimpleText
gameInfoDatesPlayed :: GameInfo -> Maybe SimpleText
gameInfoSource :: GameInfo -> Maybe SimpleText
gameInfoCopyright :: GameInfo -> Maybe SimpleText
gameInfoAnnotatorName :: GameInfo -> Maybe SimpleText
gameInfoEntererName :: GameInfo -> Maybe SimpleText

-- | Builds a <a>GameInfo</a> with the given <a>RootInfo</a> and no extra
--   data.
emptyGameInfo :: RootInfo -> GameInfo

-- | Returns whether a node contains any game info properties.
internalIsGameInfoNode :: Node -> Bool

-- | Converts a <a>GameInfo</a> into a list of <a>Property</a>s that can be
--   used to reconstruct the <a>GameInfo</a>.
gameInfoToProperties :: GameInfo -> [Property]

-- | An object that corresponds to a node in some game tree, and represents
--   the state of the game at that node, including board position, player
--   turn and captures, and also board annotations.
data BoardState
BoardState :: [[CoordState]] -> Bool -> Bool -> Bool -> ArrowList -> LineList -> LabelList -> Integer -> Color -> Int -> Int -> GameInfo -> BoardState

-- | The state of individual points on the board. Stored in row-major
--   order. Point <tt>(x, y)</tt> can be accessed via <tt>!! y !! x</tt>
--   (but prefer <a>boardCoordState</a>).
boardCoordStates :: BoardState -> [[CoordState]]

-- | Whether any of the board's <a>CoordState</a>s are invisible. This is
--   an optimization to make it more efficient to set the board to "all
--   visible."
boardHasInvisible :: BoardState -> Bool

-- | Whether any of the board's <a>CoordState</a>s are dimmed. This is an
--   optimization to make it more efficient to clear all dimming from the
--   board.
boardHasDimmed :: BoardState -> Bool

-- | Whether any of the board's <a>CoordState</a>s have a <a>Mark</a> set
--   on them. This is an optimization to make it more efficient to clear
--   marks in the common case where there are no marks set.
boardHasCoordMarks :: BoardState -> Bool
boardArrows :: BoardState -> ArrowList
boardLines :: BoardState -> LineList
boardLabels :: BoardState -> LabelList
boardMoveNumber :: BoardState -> Integer
boardPlayerTurn :: BoardState -> Color
boardBlackCaptures :: BoardState -> Int
boardWhiteCaptures :: BoardState -> Int
boardGameInfo :: BoardState -> GameInfo

-- | Returns the width of the board, in stones.
boardWidth :: BoardState -> Int

-- | Returns the height of the board, in stones.
boardHeight :: BoardState -> Int

-- | Used by <a>BoardState</a> to represent the state of a single point on
--   the board. Records whether a stone is present, as well as annotations
--   and visibility properties.
data CoordState
CoordState :: Bool -> Maybe Color -> Maybe Mark -> Bool -> Bool -> CoordState

-- | Whether this point is a star point.
coordStar :: CoordState -> Bool
coordStone :: CoordState -> Maybe Color
coordMark :: CoordState -> Maybe Mark
coordVisible :: CoordState -> Bool
coordDimmed :: CoordState -> Bool

-- | Creates a <a>BoardState</a> for an empty board of the given width and
--   height.
emptyBoardState :: Int -> Int -> BoardState
rootBoardState :: Node -> BoardState

-- | A <a>CoordState</a> for an empty point on the board.
emptyCoordState :: CoordState

-- | Returns the <a>CoordState</a> for a coordinate on a board.
boardCoordState :: Coord -> BoardState -> CoordState

-- | Modifies a <a>BoardState</a> by updating the <a>CoordState</a> at a
--   single point.
boardCoordModify :: BoardState -> Coord -> (CoordState -> CoordState) -> BoardState

-- | Maps a function over each <a>CoordState</a> in a <a>BoardState</a>,
--   returning a list-of-lists with the function's values. The function is
--   called like <tt>fn y x coordState</tt>.
mapBoardCoords :: (Int -> Int -> CoordState -> a) -> BoardState -> [[a]]

-- | Returns whether it is legal to place a stone of the given color at a
--   point on a board. Accepts out-of-bound coordinates and returns false.
isValidMove :: BoardState -> Color -> Coord -> Bool

-- | Returns whether it is legal for the current player to place a stone at
--   a point on a board. Accepts out-of-bound coordinates and returns
--   false.
isCurrentValidMove :: BoardState -> Coord -> Bool

-- | A pointer to a node in a game tree that also holds information about
--   the current state of the game at that node.
data Cursor

-- | The cursor for the node above this cursor's node in the game tree. The
--   node of the parent cursor is the parent of the cursor's node.
--   
--   This is <tt>Nothing</tt> iff the cursor's node has no parent.
cursorParent :: Cursor -> Maybe Cursor

-- | The index of this cursor's node in its parent's child list. When the
--   cursor's node has no parent, the value in this field is not specified.
cursorChildIndex :: Cursor -> Int

-- | The game tree node about which the cursor stores information.
cursorNode :: Cursor -> Node

-- | The complete board state for the current node.
cursorBoard :: Cursor -> BoardState

-- | Returns a cursor for a root node.
rootCursor :: Node -> Cursor
cursorRoot :: Cursor -> Cursor
cursorChild :: Cursor -> Int -> Cursor
cursorChildren :: Cursor -> [Cursor]
cursorChildCount :: Cursor -> Int
cursorChildPlayingAt :: Maybe Coord -> Cursor -> Maybe Cursor

-- | This is simply <tt><a>nodeProperties</a> . <a>cursorNode</a></tt>.
cursorProperties :: Cursor -> [Property]
cursorModifyNode :: (Node -> Node) -> Cursor -> Cursor

-- | Returns the variations to display for a cursor. The returned list
--   contains the location and color of <a>B</a> and <a>W</a> properties in
--   variation nodes. Variation nodes are either children of the current
--   node, or siblings of the current node, depending on the variation mode
--   source.
cursorVariations :: VariationModeSource -> Cursor -> [(Coord, Color)]
moveToProperty :: Color -> Maybe Coord -> Property
instance Eq RootInfo
instance Show RootInfo
instance Show GameInfo
instance Eq CoordState
instance Show ApplyMoveParams
instance Show ApplyMoveGroup
instance Show CursorNode
instance Show Cursor
instance Show CoordState
instance Show BoardState


-- | A monad for working with game trees.
module Game.Goatee.Lib.Monad

-- | A monad (transformer) for navigating and mutating <a>Cursor</a>s, and
--   remembering previous locations. See <a>GoT</a> and <a>GoM</a>.
--   
--   The monad supports handlers for events raised during actions it takes,
--   such as navigating through the tree and modifying nodes.
class (Functor go, Applicative go, Monad go) => MonadGo go where getCoordState coord = liftM (boardCoordState coord . cursorBoard) getCursor getProperties = liftM cursorProperties getCursor getPropertyValue descriptor = liftM (liftM $ propertyValue descriptor) $ getProperty descriptor putProperty property = modifyProperty property $ const $ Just property deleteProperty descriptor = modifyProperty descriptor $ const Nothing modifyPropertyValue descriptor fn = modifyProperty descriptor $ \ old -> propertyBuilder descriptor <$> fn (propertyValue descriptor <$> old) modifyPropertyString descriptor fn = modifyPropertyValue descriptor $ \ value -> case fn (maybe "" sgfToString value) of { "" -> Nothing str -> let sgf = stringToSgf str in if null $ sgfToString sgf then Nothing else Just sgf } modifyPropertyList descriptor fn = modifyPropertyValue descriptor $ \ value -> case fn $ fromMaybe [] value of { [] -> Nothing value' -> Just value' } modifyPropertyCoords descriptor fn = modifyPropertyValue descriptor $ \ value -> case fn $ maybe [] expandCoordList value of { [] -> Nothing coords -> Just $ buildCoordList coords } getAssignedStone coord = fmap msum $ forM stoneAssignmentProperties $ \ descriptor -> ((\ coords -> if coord `elem` coords then Just $ stoneAssignmentPropertyToStone descriptor else Nothing) <=< fmap expandCoordList) <$> getPropertyValue descriptor getAllAssignedStones = fmap unions $ forM stoneAssignmentProperties $ \ descriptor -> let stone = stoneAssignmentPropertyToStone descriptor in fromList . map (\ coord -> (coord, stone)) . maybe [] expandCoordList <$> getPropertyValue descriptor modifyAssignedStones coords f = do { needChild <- ((&&) <$> notElem SetupProperty <*> elem MoveProperty) . map propertyType <$> getProperties; if needChild then case f Nothing of { Nothing -> return () Just assignedStone -> do { addChild (emptyNode {nodeProperties = [propertyBuilder (stoneToStoneAssignmentProperty assignedStone) $ buildCoordList coords]}); ok <- goDown =<< subtract 1 . length . cursorChildren <$> getCursor; unless ok $ fail "GoT.modifyAssignedStones: Failed to move to new child." } } else do { allAssignedStones <- getAllAssignedStones; let allAssignedStones' = foldr (alter f) allAssignedStones coords byStone, byStone' :: Map (Maybe Color) [Coord] byStone = mapInvert allAssignedStones byStone' = mapInvert allAssignedStones' diff :: Map (Maybe Color) ([Coord], [Coord]) diff = mergeWithKey (\ _ oldCoords newCoords -> if newCoords == oldCoords then Nothing else Just (oldCoords, newCoords)) (map $ \ oldCoords -> (oldCoords, [])) (map $ \ newCoords -> ([], newCoords)) byStone byStone'; forM_ (assocs diff) $ \ (stone, (oldCoords, newCoords)) -> when (newCoords /= oldCoords) $ modifyPropertyCoords (stoneToStoneAssignmentProperty stone) $ const newCoords } } getMark = liftM coordMark . getCoordState modifyMark f coord = do { maybeOldMark <- getMark coord; case (maybeOldMark, f maybeOldMark) of { (Just oldMark, Nothing) -> remove oldMark (Nothing, Just newMark) -> add newMark (Just oldMark, Just newMark) | oldMark /= newMark -> remove oldMark >> add newMark (Just _, Just _) -> return () (Nothing, Nothing) -> return () } } where remove mark = modifyPropertyCoords (markProperty mark) (delete coord) add mark = modifyPropertyCoords (markProperty mark) (coord :) addChild node = do { childCount <- liftM (length . cursorChildren) getCursor; addChildAt childCount node } on0 event handler = on event $ eventHandlerFromAction event handler
getCursor :: MonadGo go => go Cursor
getCoordState :: MonadGo go => Coord -> go CoordState
goUp :: MonadGo go => go Bool
goDown :: MonadGo go => Int -> go Bool
goLeft :: MonadGo go => go Bool
goRight :: MonadGo go => go Bool
goToRoot :: MonadGo go => go ()
goToGameInfoNode :: MonadGo go => Bool -> go Bool
pushPosition :: MonadGo go => go ()
popPosition :: MonadGo go => go ()
dropPosition :: MonadGo go => go ()
getProperties :: MonadGo go => go [Property]
modifyProperties :: MonadGo go => ([Property] -> [Property]) -> go ()
getProperty :: (MonadGo go, Descriptor d) => d -> go (Maybe Property)
getPropertyValue :: (MonadGo go, ValuedDescriptor v d) => d -> go (Maybe v)
putProperty :: MonadGo go => Property -> go ()
deleteProperty :: (MonadGo go, Descriptor d) => d -> go ()
modifyProperty :: (MonadGo go, Descriptor d) => d -> (Maybe Property -> Maybe Property) -> go ()
modifyPropertyValue :: (MonadGo go, ValuedDescriptor v d) => d -> (Maybe v -> Maybe v) -> go ()
modifyPropertyString :: (MonadGo go, Stringlike s, ValuedDescriptor s d) => d -> (String -> String) -> go ()
modifyPropertyList :: (MonadGo go, ValuedDescriptor [v] d) => d -> ([v] -> [v]) -> go ()
modifyPropertyCoords :: (MonadGo go, ValuedDescriptor CoordList d) => d -> ([Coord] -> [Coord]) -> go ()
modifyGameInfo :: MonadGo go => (GameInfo -> GameInfo) -> go GameInfo
modifyVariationMode :: MonadGo go => (VariationMode -> VariationMode) -> go ()
getAssignedStone :: MonadGo go => Coord -> go (Maybe (Maybe Color))
getAllAssignedStones :: MonadGo go => go (Map Coord (Maybe Color))
modifyAssignedStones :: MonadGo go => [Coord] -> (Maybe (Maybe Color) -> Maybe (Maybe Color)) -> go ()
getMark :: MonadGo go => Coord -> go (Maybe Mark)
modifyMark :: MonadGo go => (Maybe Mark -> Maybe Mark) -> Coord -> go ()
addChild :: MonadGo go => Node -> go ()
addChildAt :: MonadGo go => Int -> Node -> go ()
deleteChildAt :: MonadGo go => Int -> go NodeDeleteResult
on :: MonadGo go => Event go h -> h -> go ()
on0 :: MonadGo go => Event go h -> go () -> go ()

-- | The standard monad transformer for <a>MonadGo</a>.
data GoT m a

-- | The standard monad for <a>MonadGo</a>.
type GoM = GoT Identity

-- | Executes a Go monad transformer on a cursor, returning in the
--   underlying monad a tuple that contains the resulting value and the
--   final cursor.
runGoT :: Monad m => GoT m a -> Cursor -> m (a, Cursor)

-- | Runs a Go monad on a cursor. See <a>runGoT</a>.
runGo :: GoM a -> Cursor -> (a, Cursor)

-- | Executes a Go monad transformer on a cursor, returning in the
--   underlying monad the value in the transformer.
evalGoT :: Monad m => GoT m a -> Cursor -> m a

-- | Runs a Go monad on a cursor and returns the value in the monad.
evalGo :: GoM a -> Cursor -> a

-- | Executes a Go monad transformer on a cursor, returning in the
--   underlying monad the final cursor.
execGoT :: Monad m => GoT m a -> Cursor -> m Cursor

-- | Runs a Go monad on a cursor and returns the final cursor.
execGo :: GoM a -> Cursor -> Cursor

-- | A single step along a game tree. Either up or down.
data Step

-- | Represents a step up from a child with the given index.
GoUp :: Int -> Step

-- | Represents a step down to the child with the given index.
GoDown :: Int -> Step

-- | The result of deleting a node.
data NodeDeleteResult

-- | The node was deleted successfully.
NodeDeleteOk :: NodeDeleteResult

-- | The node couldn't be deleted, because an invalid index was given.
NodeDeleteBadIndex :: NodeDeleteResult

-- | The node couldn't be deleted, because it is on the path stack.
NodeDeleteOnPathStack :: NodeDeleteResult

-- | A type of event in a Go monad that can be handled by executing an
--   action. <tt>go</tt> is the type of the Go monad. <tt>h</tt> is the
--   handler type, a function that takes some arguments relating to the
--   event and returns an action in the Go monad. The arguments to the
--   handler are usually things that would be difficult to recover from the
--   state of the monad alone, for example the <a>Step</a> associated with
--   a <a>navigationEvent</a>.
--   
--   The <a>Eq</a>, <a>Ord</a>, and <a>Show</a> instances use events'
--   names, via <a>eventName</a>.
data Event go h

-- | An existential type for any event in a particular Go monad. Like
--   <a>Event</a>, the <a>Eq</a>, <a>Ord</a>, and <a>Show</a> instances use
--   events' names, via <a>eventName</a>.
data AnyEvent go
AnyEvent :: (Event go h) -> AnyEvent go
eventName :: Event go h -> String

-- | Fires all of the handlers for the given event, using the given
--   function to create a Go action from each of the handlers (normally
--   themselves functions that create Go actions, if they're not just Go
--   actions directly, depending on the event).
fire :: Monad m => Event (GoT m) h -> (h -> GoT m ()) -> GoT m ()
eventHandlerFromAction :: Event go h -> go () -> h

-- | An event corresponding to a child node being added to the current
--   node.
childAddedEvent :: Event go (ChildAddedHandler go)

-- | A handler for <a>childAddedEvent</a>s. Called with the index of the
--   child added to the current node.
type ChildAddedHandler go = Int -> go ()

-- | An event corresponding to the deletion of one of the current node's
--   children.
childDeletedEvent :: Event go (ChildDeletedHandler go)

-- | A handler for <a>childDeletedEvent</a>s. It is called with a cursor at
--   the child that was deleted (this cursor is now out of date).
type ChildDeletedHandler go = Cursor -> go ()

-- | An event that is fired when the current game info changes, either by
--   navigating past a node with game info properties, or by modifying the
--   current game info properties.
gameInfoChangedEvent :: Event go (GameInfoChangedHandler go)

-- | A handler for <a>gameInfoChangedEvent</a>s. It is called with the old
--   game info then the new game info.
type GameInfoChangedHandler go = GameInfo -> GameInfo -> go ()

-- | An event that is fired when a single step up or down in a game tree is
--   made.
navigationEvent :: Event go (NavigationHandler go)

-- | A handler for <a>navigationEvent</a>s.
--   
--   A navigation handler may navigate further, but beware infinite
--   recursion. A navigation handler must end on the same node on which it
--   started.
type NavigationHandler go = Step -> go ()

-- | An event corresponding to a modification to the properties list of the
--   current node.
propertiesModifiedEvent :: Event go (PropertiesModifiedHandler go)

-- | A handler for <a>propertiesModifiedEvent</a>s. It is called with the
--   old property list then the new property list.
type PropertiesModifiedHandler go = [Property] -> [Property] -> go ()

-- | An event corresponding to a change in the active <a>VariationMode</a>.
--   This can happen when modifying the <a>ST</a> property, and also when
--   navigating between collections (as they have different root nodes).
variationModeChangedEvent :: Event go (VariationModeChangedHandler go)

-- | A handler for <a>variationModeChangedEvent</a>s. It is called with the
--   old variation mode then the new variation mode.
type VariationModeChangedHandler go = VariationMode -> VariationMode -> go ()
instance Eq Step
instance Show Step
instance Bounded NodeDeleteResult
instance Enum NodeDeleteResult
instance Eq NodeDeleteResult
instance Show NodeDeleteResult
instance Show (AnyEvent go)
instance Ord (AnyEvent go)
instance Eq (AnyEvent go)
instance Show (Event go h)
instance Ord (Event go h)
instance Eq (Event go h)
instance Monad m => MonadGo (GoT m)
instance MonadWriter w m => MonadWriter w (GoT m)
instance MonadState s m => MonadState s (GoT m)
instance MonadIO m => MonadIO (GoT m)
instance MonadTrans GoT
instance Monad m => Monad (GoT m)
instance Monad m => Applicative (GoT m)
instance Monad m => Functor (GoT m)


-- | A parser for reading SGF files.
module Game.Goatee.Lib.Parser

-- | Parses a string in SGF format. Returns an error string if parsing
--   fails.
parseString :: String -> Either String Collection

-- | Parses a file in SGF format. Returns an error string if parsing fails.
parseFile :: String -> IO (Either String Collection)

-- | Parses a node as part of an existing game tree, from textual SGF
--   "GameTree" syntax. The <a>RootInfo</a> is needed to supply necessary
--   information from the existing game tree.
parseSubtree :: RootInfo -> String -> Either String Node
propertyParser :: Parser Property


-- | Functions for serializing SGF trees.
module Game.Goatee.Lib.Renderer.Tree

-- | Renders an SGF <a>Collection</a> to a string.
renderCollection :: Collection -> Render ()

-- | Recursively renders an SGF GameTree (as defined in the spec) rooted at
--   the given node.
renderGameTree :: Node -> Render ()
renderProperty :: Property -> Render ()
