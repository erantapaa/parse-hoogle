-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parallel Parsing Processes
--   
@package parsek
@version 1.0.1.3

module Text.ParserCombinators.Class

-- | Parser class
class (Monad p, Alternative p) => IsParser p where type family SymbolOf p
satisfy :: IsParser p => (SymbolOf p -> Bool) -> p (SymbolOf p)
look :: IsParser p => p [SymbolOf p]
label :: IsParser p => String -> p a -> p a
(<<|>) :: IsParser p => p a -> p a -> p a

-- | Label a parser
(<?>) :: IsParser p => p a -> String -> p a
char :: (IsParser p, Show (SymbolOf p), Eq (SymbolOf p)) => SymbolOf p -> p (SymbolOf p)
noneOf :: (IsParser p, (~) * (SymbolOf p) Char) => [Char] -> p Char
oneOf :: (IsParser p, (~) * (SymbolOf p) Char) => [Char] -> p Char
spaces :: (IsParser p, (~) * (SymbolOf p) Char) => p ()
space :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
newline :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
tab :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
upper :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
lower :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
alphaNum :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
letter :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
digit :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
hexDigit :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
octDigit :: (IsParser p, (~) * (SymbolOf p) Char) => p Char
anySymbol :: IsParser p => p (SymbolOf p)
string :: (IsParser p, SymbolOf p ~ Char) => String -> p String
choice :: Alternative f => [f a] -> f a
option :: Alternative f => a -> f a -> f a
between :: Applicative m => m x -> m y -> m a -> m a

-- | Greedy repetition: match as many occurences as possible of the
--   argument.
manyGreedy :: IsParser m => m a -> m [a]
skipMany1 :: Alternative f => f a -> f ()
skipMany :: Alternative f => f a -> f ()
sepBy :: Alternative f => f a -> f a1 -> f [a]
sepBy1 :: Alternative f => f a -> f a1 -> f [a]
count :: Applicative m => Int -> m a -> m [a]
chainr :: (Monad f, Alternative f) => f a -> f (a -> a -> a) -> a -> f a
chainl :: (Monad f, Alternative f) => f a -> f (a -> a -> a) -> a -> f a
chainr1 :: (Monad m, Alternative m) => m t -> m (t -> t -> t) -> m t
chainl1 :: (Monad m, Alternative m) => m b -> m (b -> b -> b) -> m b
munch :: IsParser m => (SymbolOf m -> Bool) -> m [SymbolOf m]
munch1 :: IsParser m => (SymbolOf m -> Bool) -> m [SymbolOf m]
endOfFile :: (IsParser p, MonadPlus p) => p ()


-- | This module provides the <i>Parsek</i> library developed by Koen
--   Claessen in his functional pearl article <i>Parallel Parsing
--   Processes</i>, Journal of Functional Programming, 14(6), 741Â–757,
--   Cambridge University Press, 2004:
--   
--   <a>http://www.cs.chalmers.se/~koen/pubs/entry-jfp04-parser.html</a>
--   
--   <a>http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/</a>
--   
--   
--   <a>http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/code/week3/Parsek.hs</a>
module Text.ParserCombinators.Parsek
data Parser s a

-- | An intersection (nesting) of things currently expected
type Expect s = [(String, Maybe s)]
type ParseMethod s a r = P s a -> [s] -> ParseResult s r
type ParseResult s r = Either (Err s) r
mapErrR :: (s -> s') -> ParseResult s r -> ParseResult s' r
parseFromFile :: Parser Char a -> ParseMethod Char a r -> FilePath -> IO (ParseResult Char r)
parse :: Parser s a -> ParseMethod s a r -> [s] -> ParseResult s r
shortestResult :: ParseMethod s a a
longestResult :: ParseMethod s a a
longestResults :: ParseMethod s a [a]
allResults :: ParseMethod s a [a]
allResultsStaged :: ParseMethod s a [[a]]
completeResults :: ParseMethod s a [a]
shortestResultWithLeftover :: ParseMethod s a (a, [s])
longestResultWithLeftover :: ParseMethod s a (a, [s])
longestResultsWithLeftover :: ParseMethod s a ([a], Maybe [s])
allResultsWithLeftover :: ParseMethod s a [(a, [s])]
instance IsParser (Parser s)
instance Alternative (Parser s)
instance Applicative (Parser s)
instance MonadPlus (Parser s)
instance Monad (Parser s)
instance Functor (Parser s)

module Text.ParserCombinators.Parsek.Position
data SourcePos
Loc :: !FilePath -> !Int -> !Int -> SourcePos
sourceName :: SourcePos -> !FilePath
sourceLine :: SourcePos -> !Int
sourceCol :: SourcePos -> !Int
EOF :: SourcePos
data Parser a
getPosition :: Parser SourcePos
parse :: FilePath -> Parser a -> (forall s. ParseMethod s a r) -> String -> ParseResult SourcePos r
parseFromFile :: Parser a -> (forall s. ParseMethod s a r) -> FilePath -> IO (ParseResult SourcePos r)
maybePosToPos :: Maybe SourcePos -> SourcePos
anyChar :: IsParser p => p (SymbolOf p)
instance Ord SourcePos
instance Eq SourcePos
instance Alternative Parser
instance Applicative Parser
instance Monad Parser
instance Functor Parser
instance MonadPlus Parser
instance Show SourcePos
instance IsParser Parser
