-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tiny library for concurrent computations
--   
--   Spawn a concurrent <a>IO</a> computation and later demand its result.
--   Tiny API and implementation.
--   
--   New in version 0.3:
--   
--   <ul>
--   <li>Added functions <tt>parMapIO</tt>, <tt>parMapIO_</tt>, and
--   <tt>(|*|)</tt>, which capture common use cases of <tt>spawn</tt>.</li>
--   <li>Updated code to avoid using deprecated functions with
--   <tt>base-4.3</tt> and later (GHC 7.0 and later). The old code is still
--   used with older <tt>base</tt> libraries.</li>
--   <li>Added public GitHub repository.</li>
--   </ul>
@package spawn
@version 0.3

module Control.Concurrent.Spawn

-- | Spawn a concurrent computation. Produces an action which demands the
--   result. Any exception from the original computation is re-thrown when
--   and where the result is demanded.
spawn :: IO a -> IO (IO a)

-- | Two ways a computation of type <tt><a>IO</a> a</tt> can end.
type Result a = Either SomeException a

-- | Spawn a concurrent computation. Produces an action which demands a
--   <tt><a>Result</a></tt>.
spawnTry :: IO a -> IO (IO (Result a))

-- | Execute a separate thread of IO for each element of a list, and
--   collect results.
--   
--   The analogy to <tt>parMap</tt> is misleading. The concurrent execution
--   of these actions is non-deterministic and can affect results. However,
--   <tt><a>parMapIO</a></tt> is expected to be most useful for actions
--   which do not interact.
parMapIO :: (a -> IO b) -> [a] -> IO [b]

-- | Execute a separate thread of IO for each element of a list.
--   
--   Results are discarded, but the <tt><a>parMapIO_</a></tt> action does
--   not complete until all threads have finished.
parMapIO_ :: (a -> IO b) -> [a] -> IO ()

-- | A concurrent version of <tt><a>ap</a></tt> or <tt>(&lt;*&gt;)</tt> for
--   <tt><a>IO</a></tt>.
--   
--   Spawns a thread for the right-hand action, while executing the
--   left-hand action in the current thread.
(|*|) :: IO (a -> b) -> IO a -> IO b

-- | Given <i>n</i>, produces a function to wrap <tt><a>IO</a></tt>
--   actions. No more than <i>n</i> wrapped actions will be in progress at
--   one time.
pool :: Int -> IO (IO a -> IO a)
