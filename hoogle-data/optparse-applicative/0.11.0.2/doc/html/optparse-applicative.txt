-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities and combinators for parsing command line options
--   
@package optparse-applicative
@version 0.11.0.2

module Options.Applicative.Help.Pretty
(.$.) :: Doc -> Doc -> Doc

module Options.Applicative.Help.Chunk
mappendWith :: Monoid a => a -> a -> a -> a

-- | The free monoid on a semigroup <tt>a</tt>.
newtype Chunk a
Chunk :: Maybe a -> Chunk a
unChunk :: Chunk a -> Maybe a

-- | Given a semigroup structure on <tt>a</tt>, return a monoid structure
--   on 'Chunk a'.
--   
--   Note that this is <i>not</i> the same as <a>liftA2</a>.
chunked :: (a -> a -> a) -> Chunk a -> Chunk a -> Chunk a

-- | Concatenate a list into a Chunk. <a>listToChunk</a> satisfies:
--   
--   <pre>
--   isEmpty . listToChunk = null
--   listToChunk = mconcat . fmap pure
--   </pre>
listToChunk :: Monoid a => [a] -> Chunk a

-- | Concatenate two <a>Chunk</a>s with a space in between. If one is
--   empty, this just returns the other one.
--   
--   Unlike <a>&lt;+&gt;</a> for <a>Doc</a>, this operation has a unit
--   element, namely the empty <a>Chunk</a>.
(<<+>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate two <a>Chunk</a>s with a softline in between. This is
--   exactly like <a>&lt;&lt;+&gt;&gt;</a>, but uses a softline instead of
--   a space.
(<</>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically.
vcatChunks :: [Chunk Doc] -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically separated by empty lines.
vsepChunks :: [Chunk Doc] -> Chunk Doc

-- | Whether a <a>Chunk</a> is empty. Note that something like 'pure
--   mempty' is not considered an empty chunk, even though the underlying
--   <a>Doc</a> is empty.
isEmpty :: Chunk a -> Bool

-- | Convert a <a>String</a> into a <a>Chunk</a>. This satisfies:
--   
--   <pre>
--   isEmpty . stringChunk = null
--   extractChunk . stringChunk = string
--   </pre>
stringChunk :: String -> Chunk Doc

-- | Convert a paragraph into a <a>Chunk</a>. The resulting chunk is
--   composed by the words of the original paragraph separated by
--   softlines, so it will be automatically word-wrapped when rendering the
--   underlying document.
--   
--   This satisfies:
--   
--   <pre>
--   isEmpty . paragraph = null . words
--   </pre>
paragraph :: String -> Chunk Doc

-- | Part of a constrained comonad instance.
--   
--   This is the counit of the adjunction between <a>Chunk</a> and the
--   forgetful functor from monoids to semigroups. It satisfies:
--   
--   <pre>
--   extractChunk . pure = id
--   extractChunk . fmap pure = id
--   </pre>
extractChunk :: Monoid a => Chunk a -> a

-- | Display pairs of strings in a table.
tabulate :: [(Doc, Doc)] -> Chunk Doc
instance Eq a => Eq (Chunk a)
instance Show a => Show (Chunk a)
instance Monoid a => Monoid (Chunk a)
instance MonadPlus Chunk
instance Monad Chunk
instance Alternative Chunk
instance Applicative Chunk
instance Functor Chunk

module Options.Applicative.Help.Types
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
helpError :: ParserHelp -> Chunk Doc
helpHeader :: ParserHelp -> Chunk Doc
helpUsage :: ParserHelp -> Chunk Doc
helpBody :: ParserHelp -> Chunk Doc
helpFooter :: ParserHelp -> Chunk Doc

-- | Convert a help text to <a>String</a>.
renderHelp :: Int -> ParserHelp -> String
instance Monoid ParserHelp
instance Show ParserHelp

module Options.Applicative.Types
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> Bool -> ParserInfo a

-- | the option parser for the program
infoParser :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
infoFullDesc :: ParserInfo a -> Bool

-- | brief parser description
infoProgDesc :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
infoHeader :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
infoFooter :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
infoFailureCode :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   True)
infoIntersperse :: ParserInfo a -> Bool

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
prefMultiSuffix :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
prefDisambiguate :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
prefShowHelpOnError :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
prefBacktrack :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
prefColumns :: ParserPrefs -> Int

-- | A single option of a parser.
data Option a
Option :: OptReader a -> OptProperties -> Option a

-- | reader for this option
optMain :: Option a -> OptReader a

-- | properties of this option
optProps :: Option a -> OptProperties
data OptName
OptShort :: !Char -> OptName
OptLong :: !String -> OptName

-- | An <a>OptReader</a> defines whether an option matches an command line
--   argument.
data OptReader a

-- | option reader
OptReader :: [OptName] -> (CReader a) -> ParseError -> OptReader a

-- | flag reader
FlagReader :: [OptName] -> !a -> OptReader a

-- | argument reader
ArgReader :: (CReader a) -> OptReader a

-- | command reader
CmdReader :: [String] -> (String -> Maybe (ParserInfo a)) -> OptReader a

-- | Specification for an individual parser option.
data OptProperties
OptProperties :: OptVisibility -> Chunk Doc -> String -> Maybe String -> OptProperties

-- | whether this flag is shown is the brief description
propVisibility :: OptProperties -> OptVisibility

-- | help text for this option
propHelp :: OptProperties -> Chunk Doc

-- | metavariable for this option
propMetaVar :: OptProperties -> String

-- | what to show in the help text as the default
propShowDefault :: OptProperties -> Maybe String

-- | Visibility of an option in the help text.
data OptVisibility

-- | does not appear in the help text at all
Internal :: OptVisibility

-- | only visible in the full description
Hidden :: OptVisibility

-- | visible both in the full and brief descriptions
Visible :: OptVisibility

-- | A newtype over 'ReaderT String Except', used by option readers.
newtype ReadM a
ReadM :: ReaderT String (Except ParseError) a -> ReadM a
unReadM :: ReadM a -> ReaderT String (Except ParseError) a

-- | Return the value being read.
readerAsk :: ReadM String

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a
data CReader a
CReader :: Completer -> ReadM a -> CReader a
crCompleter :: CReader a -> Completer
crReader :: CReader a -> ReadM a

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a
NilP :: (Maybe a) -> Parser a
OptP :: (Option a) -> Parser a
MultP :: (Parser (x -> a)) -> (Parser x) -> Parser a
AltP :: (Parser a) -> (Parser a) -> Parser a
BindP :: (Parser x) -> (x -> Parser a) -> Parser a
newtype ParserM r
ParserM :: (forall x. (r -> Parser x) -> Parser x) -> ParserM r
runParserM :: ParserM r -> forall x. (r -> Parser x) -> Parser x
newtype Completer
Completer :: (String -> IO [String]) -> Completer
runCompleter :: Completer -> String -> IO [String]
mkCompleter :: (String -> IO [String]) -> Completer
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
execCompletion :: CompletionResult -> String -> IO String
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
execFailure :: ParserFailure h -> String -> (h, ExitCode, Int)

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: (ParserFailure ParserHelp) -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a
type Args = [String]
data ArgPolicy
SkipOpts :: ArgPolicy
AllowOpts :: ArgPolicy
data OptHelpInfo
OptHelpInfo :: Bool -> Bool -> OptHelpInfo
hinfoMulti :: OptHelpInfo -> Bool
hinfoDefault :: OptHelpInfo -> Bool
data OptTree a
Leaf :: a -> OptTree a
MultNode :: [OptTree a] -> OptTree a
AltNode :: [OptTree a] -> OptTree a
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
helpError :: ParserHelp -> Chunk Doc
helpHeader :: ParserHelp -> Chunk Doc
helpUsage :: ParserHelp -> Chunk Doc
helpBody :: ParserHelp -> Chunk Doc
helpFooter :: ParserHelp -> Chunk Doc
fromM :: ParserM a -> Parser a
oneM :: Parser a -> ParserM a
manyM :: Parser a -> ParserM [a]
someM :: Parser a -> ParserM [a]
optVisibility :: Option a -> OptVisibility
optMetaVar :: Option a -> String
optHelp :: Option a -> Chunk Doc
optShowDefault :: Option a -> Maybe String
instance Show ParseError
instance Eq OptName
instance Ord OptName
instance Eq OptVisibility
instance Ord OptVisibility
instance Show a => Show (ParserResult a)
instance Eq ArgPolicy
instance Show a => Show (OptTree a)
instance Monad ParserResult
instance Applicative ParserResult
instance Functor ParserResult
instance Functor ParserFailure
instance Show h => Show (ParserFailure h)
instance Show CompletionResult
instance Monoid Completer
instance Alternative Parser
instance Applicative ParserM
instance Functor ParserM
instance Monad ParserM
instance Applicative Parser
instance Functor Parser
instance Functor OptReader
instance Functor CReader
instance MonadPlus ReadM
instance Monad ReadM
instance Alternative ReadM
instance Applicative ReadM
instance Functor ReadM
instance Functor Option
instance Functor ParserInfo
instance Monoid ParseError

module Options.Applicative.Internal
data P a
data Context
Context :: [String] -> (ParserInfo a) -> Context
NullContext :: Context
class (Alternative m, MonadPlus m) => MonadP m
setContext :: MonadP m => Maybe String -> ParserInfo a -> m ()
getPrefs :: MonadP m => m ParserPrefs
missingArgP :: MonadP m => ParseError -> Completer -> m a
tryP :: MonadP m => m a -> m (Either ParseError a)
errorP :: MonadP m => ParseError -> m a
exitP :: MonadP m => Parser b -> Maybe a -> m a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError
uncons :: [a] -> Maybe (a, [a])
hoistMaybe :: MonadPlus m => Maybe a -> m a
hoistEither :: MonadP m => Either ParseError a -> m a
runReadM :: MonadP m => ReadM a -> String -> m a
withReadM :: (String -> String) -> ReadM a -> ReadM a
runP :: P a -> ParserPrefs -> (Either ParseError a, Context)
data Completion a
runCompletion :: Completion r -> ParserPrefs -> Maybe (Either SomeParser Completer)
data SomeParser
SomeParser :: (Parser a) -> SomeParser
data ComplError
ComplParseError :: String -> ComplError
ComplExit :: ComplError
data ListT m a
takeListT :: Monad m => Int -> ListT m a -> ListT m a
runListT :: Monad m => ListT m a -> m [a]
data NondetT m a
cut :: Monad m => NondetT m ()
(<!>) :: Monad m => NondetT m a -> NondetT m a -> NondetT m a
disamb :: Monad m => Bool -> NondetT m a -> m (Maybe a)
instance MonadTrans NondetT
instance Monad m => Alternative (NondetT m)
instance Monad m => MonadPlus (NondetT m)
instance Monad m => Monad (NondetT m)
instance Monad m => Applicative (NondetT m)
instance Monad m => Functor (NondetT m)
instance Monad m => MonadPlus (ListT m)
instance MonadTrans ListT
instance Monad m => Alternative (ListT m)
instance Monad m => Monad (ListT m)
instance Monad m => Applicative (ListT m)
instance Monad m => Functor (ListT m)
instance MonadP Completion
instance MonadPlus Completion
instance Monad Completion
instance Alternative Completion
instance Applicative Completion
instance Functor Completion
instance Monad ComplResult
instance Applicative ComplResult
instance Functor ComplResult
instance MonadP P
instance Monoid Context
instance MonadPlus P
instance Monad P
instance Alternative P
instance Applicative P
instance Functor P

module Options.Applicative.Builder.Completer
data Completer
mkCompleter :: (String -> IO [String]) -> Completer
listIOCompleter :: IO [String] -> Completer
listCompleter :: [String] -> Completer
bashCompleter :: String -> Completer

module Options.Applicative.Common

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a

-- | Create a parser composed of a single option.
liftOpt :: Option a -> Parser a
showOption :: OptName -> String

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> Bool -> ParserInfo a

-- | the option parser for the program
infoParser :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
infoFullDesc :: ParserInfo a -> Bool

-- | brief parser description
infoProgDesc :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
infoHeader :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
infoFooter :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
infoFailureCode :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   True)
infoIntersperse :: ParserInfo a -> Bool

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
prefMultiSuffix :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
prefDisambiguate :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
prefShowHelpOnError :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
prefBacktrack :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
prefColumns :: ParserPrefs -> Int
runParserInfo :: MonadP m => ParserInfo a -> Args -> m a
runParserFully :: MonadP m => ArgPolicy -> Parser a -> Args -> m a

-- | Apply a <a>Parser</a> to a command line, and return a result and
--   leftover arguments. This function returns an error if any parsing
--   error occurs, or if any options are missing and don't have a default
--   value.
runParser :: MonadP m => ArgPolicy -> Parser a -> Args -> m (a, Args)

-- | The default value of a <a>Parser</a>. This function returns an error
--   if any of the options don't have a default value.
evalParser :: Parser a -> Maybe a

-- | Map a polymorphic function over all the options of a parser, and
--   collect the results in a list.
mapParser :: (forall x. OptHelpInfo -> Option x -> b) -> Parser a -> [b]

-- | Like <a>mapParser</a>, but collect the results in a tree structure.
treeMapParser :: (forall x. OptHelpInfo -> Option x -> b) -> Parser a -> OptTree b
optionNames :: OptReader a -> [OptName]
instance Monoid MatchResult

module Options.Applicative.Builder.Internal

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   You rarely need to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a
Mod :: (f a -> f a) -> (DefaultProp a) -> (OptProperties -> OptProperties) -> Mod f a
class HasName f
name :: HasName f => OptName -> f a -> f a
class HasCompleter f
modCompleter :: HasCompleter f => (Completer -> Completer) -> f a -> f a
class HasValue f
class HasMetavar f
data OptionFields a
OptionFields :: [OptName] -> Completer -> ParseError -> OptionFields a
optNames :: OptionFields a -> [OptName]
optCompleter :: OptionFields a -> Completer
optNoArgError :: OptionFields a -> ParseError
data FlagFields a
FlagFields :: [OptName] -> a -> FlagFields a
flagNames :: FlagFields a -> [OptName]
flagActive :: FlagFields a -> a
data CommandFields a
CommandFields :: [(String, ParserInfo a)] -> CommandFields a
cmdCommands :: CommandFields a -> [(String, ParserInfo a)]
data ArgumentFields a
ArgumentFields :: Completer -> ArgumentFields a
argCompleter :: ArgumentFields a -> Completer
data DefaultProp a
DefaultProp :: (Maybe a) -> (Maybe (a -> String)) -> DefaultProp a
optionMod :: (OptProperties -> OptProperties) -> Mod f a
fieldMod :: (f a -> f a) -> Mod f a

-- | Base default properties.
baseProps :: OptProperties
mkCommand :: Mod CommandFields a -> ([String], String -> Maybe (ParserInfo a))
mkParser :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Parser a
mkOption :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Option a
mkProps :: DefaultProp a -> (OptProperties -> OptProperties) -> OptProperties

-- | Hide this option from the help text
internal :: Mod f a
instance Monoid (Mod f a)
instance Monoid (DefaultProp a)
instance HasMetavar CommandFields
instance HasMetavar ArgumentFields
instance HasMetavar OptionFields
instance HasValue ArgumentFields
instance HasValue OptionFields
instance HasCompleter ArgumentFields
instance HasCompleter OptionFields
instance HasName FlagFields
instance HasName OptionFields

module Options.Applicative.Builder

-- | Builder for a command parser. The <a>command</a> modifier can be used
--   to specify individual commands.
subparser :: Mod CommandFields a -> Parser a

-- | Builder for a <a>String</a> argument.
strArgument :: Mod ArgumentFields String -> Parser String

-- | Builder for an argument parser.
argument :: ReadM a -> Mod ArgumentFields a -> Parser a

-- | Builder for a flag parser.
--   
--   A flag that switches from a "default value" to an "active value" when
--   encountered. For a simple boolean value, use <a>switch</a> instead.
flag :: a -> a -> Mod FlagFields a -> Parser a

-- | Builder for a flag parser without a default value.
--   
--   Same as <a>flag</a>, but with no default value. In particular, this
--   flag will never parse successfully by itself.
--   
--   It still makes sense to use it as part of a composite parser. For
--   example
--   
--   <pre>
--   length &lt;$&gt; many (flag' () (short 't'))
--   </pre>
--   
--   is a parser that counts the number of "-t" arguments on the command
--   line.
flag' :: a -> Mod FlagFields a -> Parser a

-- | Builder for a boolean flag.
--   
--   <pre>
--   switch = flag False True
--   </pre>
switch :: Mod FlagFields Bool -> Parser Bool

-- | An option that always fails.
--   
--   When this option is encountered, the option parser immediately aborts
--   with the given parse error. If you simply want to output a message,
--   use <a>infoOption</a> instead.
abortOption :: ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | An option that always fails and displays a message.
infoOption :: String -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | Builder for an option taking a <a>String</a> argument.
strOption :: Mod OptionFields String -> Parser String

-- | Builder for an option using the given reader.
option :: ReadM a -> Mod OptionFields a -> Parser a

-- | Same as <a>option</a>.

-- | <i>Deprecated: Use <a>option</a> instead</i>
nullOption :: ReadM a -> Mod OptionFields a -> Parser a

-- | Specify a short name for an option.
short :: HasName f => Char -> Mod f a

-- | Specify a long name for an option.
long :: HasName f => String -> Mod f a

-- | Specify the help text for an option.
help :: String -> Mod f a

-- | Specify the help text for an option as a <a>Doc</a> value.
helpDoc :: Maybe Doc -> Mod f a

-- | Specify a default value for an option.
value :: HasValue f => a -> Mod f a

-- | Specify a function to show the default value for an option.
showDefaultWith :: (a -> String) -> Mod f a

-- | Show the default value for this option using its <a>Show</a> instance.
showDefault :: Show a => Mod f a

-- | Specify a metavariable for the argument.
--   
--   Metavariables have no effect on the actual parser, and only serve to
--   specify the symbolic name for an argument to be displayed in the help
--   text.
metavar :: HasMetavar f => String -> Mod f a

-- | Convert a function in the <a>Either</a> monad to a reader.
eitherReader :: (String -> Either String a) -> ReadM a

-- | Specify the error to display when no argument is provided to this
--   option.
noArgError :: ParseError -> Mod OptionFields a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError

-- | Hide this option from the brief description.
hidden :: Mod f a

-- | Hide this option from the help text
internal :: Mod f a

-- | Add a command to a subparser option.
command :: String -> ParserInfo a -> Mod CommandFields a

-- | Add a list of possible completion values.
completeWith :: HasCompleter f => [String] -> Mod f a

-- | Add a bash completion action. Common actions include <tt>file</tt> and
--   <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
action :: HasCompleter f => String -> Mod f a

-- | Add a completer to an argument.
--   
--   A completer is a function String -&gt; IO String which, given a
--   partial argument, returns all possible completions for that argument.
completer :: HasCompleter f => Completer -> Mod f a

-- | Trivial option modifier.
idm :: Monoid m => m

-- | An infix synonym for <a>mappend</a>.
--   
--   <i>Since: 4.5.0.0</i>
(<>) :: Monoid m => m -> m -> m

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | <a>Option</a> reader based on the <a>Read</a> type class.
auto :: Read a => ReadM a

-- | String <a>Option</a> reader.
str :: ReadM String

-- | Null <a>Option</a> reader. All arguments will fail validation.
disabled :: ReadM a

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a

-- | Modifier for <a>ParserInfo</a>.
data InfoMod a

-- | Show a full description in the help text of this parser.
fullDesc :: InfoMod a

-- | Only show a brief description in the help text of this parser.
briefDesc :: InfoMod a

-- | Specify a header for this parser.
header :: String -> InfoMod a

-- | Specify a header for this parser as a <a>Doc</a> value.
headerDoc :: Maybe Doc -> InfoMod a

-- | Specify a footer for this parser.
footer :: String -> InfoMod a

-- | Specify a footer for this parser as a <a>Doc</a> value.
footerDoc :: Maybe Doc -> InfoMod a

-- | Specify a short program description.
progDesc :: String -> InfoMod a

-- | Specify a short program description as a <a>Doc</a> value.
progDescDoc :: Maybe Doc -> InfoMod a

-- | Specify an exit code if a parse error occurs.
failureCode :: Int -> InfoMod a

-- | Disable parsing of regular options after arguments
noIntersperse :: InfoMod a

-- | Create a <a>ParserInfo</a> given a <a>Parser</a> and a modifier.
info :: Parser a -> InfoMod a -> ParserInfo a
data PrefsMod
multiSuffix :: String -> PrefsMod
disambiguate :: PrefsMod
showHelpOnError :: PrefsMod
noBacktrack :: PrefsMod
columns :: Int -> PrefsMod
prefs :: PrefsMod -> ParserPrefs

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   You rarely need to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a

-- | A newtype over 'ReaderT String Except', used by option readers.
data ReadM a
data OptionFields a
data FlagFields a
data ArgumentFields a
data CommandFields a
instance Monoid PrefsMod
instance Monoid (InfoMod a)


-- | You don't need to import this module to enable bash completion.
--   
--   See <a>the wiki</a> for more information on bash completion.
module Options.Applicative.BashCompletion
bashCompletionParser :: ParserInfo a -> ParserPrefs -> Parser CompletionResult

module Options.Applicative.Help.Core

-- | Generate descriptions for commands.
cmdDesc :: Parser a -> Chunk Doc

-- | Generate a brief help text for a parser.
briefDesc :: ParserPrefs -> Parser a -> Chunk Doc

-- | Generate a full help text for a parser.
fullDesc :: ParserPrefs -> Parser a -> Chunk Doc
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
helpError :: ParserHelp -> Chunk Doc
helpHeader :: ParserHelp -> Chunk Doc
helpUsage :: ParserHelp -> Chunk Doc
helpBody :: ParserHelp -> Chunk Doc
helpFooter :: ParserHelp -> Chunk Doc
errorHelp :: Chunk Doc -> ParserHelp
headerHelp :: Chunk Doc -> ParserHelp
usageHelp :: Chunk Doc -> ParserHelp
bodyHelp :: Chunk Doc -> ParserHelp
footerHelp :: Chunk Doc -> ParserHelp

-- | Generate the help text for a program.
parserHelp :: ParserPrefs -> Parser a -> ParserHelp

-- | Generate option summary.
parserUsage :: ParserPrefs -> Parser a -> String -> Doc

module Options.Applicative.Help

module Options.Applicative.Extra

-- | A hidden "helper" option which always fails.
helper :: Parser (a -> a)
hsubparser :: Mod CommandFields a -> Parser a

-- | Run a program description.
--   
--   Parse command line arguments. Display help text and exit if any parse
--   error occurs.
execParser :: ParserInfo a -> IO a

-- | Run a program description in pure code.
--   
--   This function behaves like <a>execParser</a>, but can be called from
--   pure code. Note that, in case of errors, no message is displayed, and
--   this function simply returns <a>Nothing</a>.
--   
--   If you need to keep track of error messages, use <a>execParserPure</a>
--   instead.

-- | <i>Deprecated: Use execParserPure together with getParseResult
--   instead</i>
execParserMaybe :: ParserInfo a -> [String] -> Maybe a

-- | Run a program description with custom preferences.
customExecParser :: ParserPrefs -> ParserInfo a -> IO a

-- | Run a program description with custom preferences in pure code.
--   
--   See <a>execParserMaybe</a> for details.

-- | <i>Deprecated: Use execParserPure together with getParseResult
--   instead</i>
customExecParserMaybe :: ParserPrefs -> ParserInfo a -> [String] -> Maybe a

-- | The most general way to run a program description in pure code.
execParserPure :: ParserPrefs -> ParserInfo a -> [String] -> ParserResult a

-- | Extract the actual result from a <a>ParserResult</a> value.
--   
--   This function returns <a>Nothing</a> in case of errors. Possible error
--   messages or completion actions are simply discarded.
--   
--   If you want to display error messages and invoke completion actions
--   appropriately, use <a>handleParseResult</a> instead.
getParseResult :: ParserResult a -> Maybe a

-- | Handle <a>ParserResult</a>.
handleParseResult :: ParserResult a -> IO a

-- | Generate a <a>ParserFailure</a> from a <a>ParseError</a> in a given
--   <a>Context</a>.
--   
--   This function can be used, for example, to show the help text for a
--   parser:
--   
--   <pre>
--   handleParseResult . Failure $ parserFailure pprefs pinfo ShowHelpText mempty
--   </pre>
parserFailure :: ParserPrefs -> ParserInfo a -> ParseError -> Context -> ParserFailure ParserHelp
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
execFailure :: ParserFailure h -> String -> (h, ExitCode, Int)
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: (ParserFailure ParserHelp) -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
prefMultiSuffix :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
prefDisambiguate :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
prefShowHelpOnError :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
prefBacktrack :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
prefColumns :: ParserPrefs -> Int
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
execCompletion :: CompletionResult -> String -> IO String

module Options.Applicative


-- | This module contains an arrow interface for option parsers, which
--   allows to define and combine parsers using the arrow notation and
--   arrow combinators.
--   
--   The arrow syntax is particularly useful to create parsers of nested
--   structures, or records where the order of fields is different from the
--   order in which the parsers should be applied.
--   
--   For example, an <a>arguments</a> parser often needs to be applied
--   last, and that makes it inconvenient to use it for a field which is
--   not the last one in a record.
--   
--   Using the arrow syntax and the functions in this module, one can
--   write, e.g.:
--   
--   <pre>
--   data Options = Options
--     { optArgs :: [String]
--     , optVerbose :: Bool }
--   
--   opts :: Parser Options
--   opts = runA $ proc () -&gt; do
--     verbose &lt;- asA (switch (short 'v')) -&lt; ()
--     args &lt;- asA (arguments str idm) -&lt; ()
--     returnA -&lt; Options args verbose
--   </pre>
--   
--   Parser arrows, created out of regular <a>Parser</a> values using the
--   <a>asA</a> function, are arrows taking <tt>()</tt> as argument and
--   returning the parsed value.
module Options.Applicative.Arrows

-- | For any <a>Applicative</a> functor <tt>f</tt>, <tt>A f</tt> is the
--   <a>Arrow</a> instance associated to <tt>f</tt>.
--   
--   The <a>A</a> constructor can be used to convert a value of type <tt>f
--   (a -&gt; b)</tt> into an arrow.
newtype A f a b
A :: f (a -> b) -> A f a b
unA :: A f a b -> f (a -> b)

-- | Convert a value of type <tt>f a</tt> into an arrow taking <tt>()</tt>
--   as argument.
--   
--   Applied to a value of type <a>Parser</a>, it turns it into an arrow
--   that can be used inside an arrow command, or passed to arrow
--   combinators.
asA :: Applicative f => f a -> A f () a

-- | Convert an arrow back to an applicative value.
--   
--   This function can be used to return a result of type <a>Parser</a>
--   from an arrow command.
runA :: Applicative f => A f () a -> f a

-- | The type of arrows associated to the applicative <a>Parser</a>
--   functor.
type ParserA = A Parser
instance Applicative f => Arrow (A f)
instance Applicative f => Category (A f)
