-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extensible optionally-pure exceptions
--   
@package exceptions
@version 0.8.0.2


-- | This module supports monads that can throw extensible exceptions. The
--   exceptions are the very same from <a>Control.Exception</a>, and the
--   operations offered very similar, but here they are not limited to
--   <a>IO</a>.
--   
--   This code is in the style of both transformers and mtl, and is
--   compatible with them, though doesn't mimic the module structure or
--   offer the complete range of features in those packages.
--   
--   This is very similar to <a>ErrorT</a> and <tt>MonadError</tt>, but
--   based on features of <a>Control.Exception</a>. In particular, it
--   handles the complex case of asynchronous exceptions by including
--   <a>mask</a> in the typeclass. Note that the extensible extensions
--   feature relies on the RankNTypes language extension.
module Control.Monad.Catch

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow m
throwM :: (MonadThrow m, Exception e) => e -> m a

-- | A class for monads which allow exceptions to be caught, in particular
--   exceptions which were thrown by <a>throwM</a>.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   catch (throwM e) f = f e
--   </pre>
--   
--   Note that the ability to catch an exception does <i>not</i> guarantee
--   that we can deal with all possible exit points from a computation.
--   Some monads, such as continuation-based stacks, allow for more than
--   just a success/failure strategy, and therefore <tt>catch</tt>
--   <i>cannot</i> be used by those monads to properly implement a function
--   such as <tt>finally</tt>. For more information, see <a>MonadMask</a>.
class MonadThrow m => MonadCatch m
catch :: (MonadCatch m, Exception e) => m a -> (e -> m a) -> m a

-- | A class for monads which provide for the ability to account for all
--   possible exit points from a computation, and to mask asynchronous
--   exceptions. Continuation-based monads, and stacks such as <tt>ErrorT e
--   IO</tt> which provide for multiple failure modes, are invalid
--   instances of this class.
--   
--   Note that this package <i>does</i> provide a <tt>MonadMask</tt>
--   instance for <tt>CatchT</tt>. This instance is <i>only</i> valid if
--   the base monad provides no ability to provide multiple exit. For
--   example, <tt>IO</tt> or <tt>Either</tt> would be invalid base monads,
--   but <tt>Reader</tt> or <tt>State</tt> would be acceptable.
--   
--   Instances should ensure that, in the following code:
--   
--   <pre>
--   f `finally` g
--   </pre>
--   
--   The action <tt>g</tt> is called regardless of what occurs within
--   <tt>f</tt>, including async exceptions.
class MonadCatch m => MonadMask m
mask :: MonadMask m => ((forall a. m a -> m a) -> m b) -> m b
uninterruptibleMask :: MonadMask m => ((forall a. m a -> m a) -> m b) -> m b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: MonadMask m => m a -> m a

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: MonadMask m => m a -> m a

-- | Catches all exceptions, and somewhat defeats the purpose of the
--   extensible exception system. Use sparingly.
catchAll :: MonadCatch m => m a -> (SomeException -> m a) -> m a

-- | Catch all <a>IOError</a> (eqv. <tt>IOException</tt>) exceptions. Still
--   somewhat too general, but better than using <a>catchAll</a>. See
--   <a>catchIf</a> for an easy way of catching specific <a>IOError</a>s
--   based on the predicates in <a>System.IO.Error</a>.
catchIOError :: MonadCatch m => m a -> (IOError -> m a) -> m a

-- | A more generalized way of determining which exceptions to catch at run
--   time.
catchJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a

-- | Catch exceptions only if they pass some predicate. Often useful with
--   the predicates for testing <a>IOError</a> values in
--   <a>System.IO.Error</a>.
catchIf :: (MonadCatch m, Exception e) => (e -> Bool) -> m a -> (e -> m a) -> m a

-- | Generalized version of <a>Handler</a>
data Handler m a
Handler :: (e -> m a) -> Handler m a

-- | Catches different sorts of exceptions. See <a>Control.Exception</a>'s
--   <a>catches</a>
catches :: (Foldable f, MonadCatch m) => m a -> f (Handler m a) -> m a

-- | Flipped <a>catch</a>. See <a>Control.Exception</a>'s <a>handle</a>.
handle :: (MonadCatch m, Exception e) => (e -> m a) -> m a -> m a

-- | Flipped <a>catchAll</a>
handleAll :: MonadCatch m => (SomeException -> m a) -> m a -> m a

-- | Flipped <a>catchIOError</a>
handleIOError :: MonadCatch m => (IOError -> m a) -> m a -> m a

-- | Flipped <a>catchJust</a>. See <a>Control.Exception</a>'s
--   <a>handleJust</a>.
handleJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a

-- | Flipped <a>catchIf</a>
handleIf :: (MonadCatch m, Exception e) => (e -> Bool) -> (e -> m a) -> m a -> m a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result. See
--   <a>Control.Exception</a>'s <a>try</a>.
try :: (MonadCatch m, Exception e) => m a -> m (Either e a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught. See <a>Control.Exception</a>'s
--   <a>tryJust</a>
tryJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)

-- | Run an action only if an exception is thrown in the main action. The
--   exception is not caught, simply rethrown.
onException :: MonadCatch m => m a -> m b -> m a

-- | Generalized abstracted pattern of safe resource acquisition and
--   release in the face of exceptions. The first action "acquires" some
--   value, which is "released" by the second action at the end. The third
--   action "uses" the value and its result is the result of the
--   <a>bracket</a>.
--   
--   If an exception occurs during the use, the release still happens
--   before the exception is rethrown.
bracket :: MonadMask m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Version of <a>bracket</a> without any value being passed to the second
--   and third actions.
bracket_ :: MonadMask m => m a -> m b -> m c -> m c

-- | Perform an action with a finalizer action that is run, even if an
--   exception occurs.
finally :: MonadMask m => m a -> m b -> m a

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: MonadMask m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable * e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException :: *
SomeException :: e -> SomeException
instance Monad m => Functor (Handler m)
instance MonadThrow m => MonadThrow (ContT r m)
instance MonadCatch m => MonadCatch (ExceptT e m)
instance MonadThrow m => MonadThrow (ExceptT e m)
instance (Error e, MonadCatch m) => MonadCatch (ErrorT e m)
instance (Error e, MonadThrow m) => MonadThrow (ErrorT e m)
instance MonadCatch m => MonadCatch (MaybeT m)
instance MonadThrow m => MonadThrow (MaybeT m)
instance MonadCatch m => MonadCatch (ListT m)
instance MonadThrow m => MonadThrow (ListT m)
instance (MonadMask m, Monoid w) => MonadMask (RWST r w s m)
instance (MonadCatch m, Monoid w) => MonadCatch (RWST r w s m)
instance (MonadThrow m, Monoid w) => MonadThrow (RWST r w s m)
instance (MonadMask m, Monoid w) => MonadMask (RWST r w s m)
instance (MonadCatch m, Monoid w) => MonadCatch (RWST r w s m)
instance (MonadThrow m, Monoid w) => MonadThrow (RWST r w s m)
instance (MonadMask m, Monoid w) => MonadMask (WriterT w m)
instance (MonadCatch m, Monoid w) => MonadCatch (WriterT w m)
instance (MonadThrow m, Monoid w) => MonadThrow (WriterT w m)
instance (MonadMask m, Monoid w) => MonadMask (WriterT w m)
instance (MonadCatch m, Monoid w) => MonadCatch (WriterT w m)
instance (MonadThrow m, Monoid w) => MonadThrow (WriterT w m)
instance MonadMask m => MonadMask (ReaderT r m)
instance MonadCatch m => MonadCatch (ReaderT r m)
instance MonadThrow m => MonadThrow (ReaderT r m)
instance MonadMask m => MonadMask (StateT s m)
instance MonadCatch m => MonadCatch (StateT s m)
instance MonadThrow m => MonadThrow (StateT s m)
instance MonadMask m => MonadMask (StateT s m)
instance MonadCatch m => MonadCatch (StateT s m)
instance MonadThrow m => MonadThrow (StateT s m)
instance MonadMask m => MonadMask (IdentityT m)
instance MonadCatch m => MonadCatch (IdentityT m)
instance MonadThrow m => MonadThrow (IdentityT m)
instance MonadCatch STM
instance MonadThrow STM
instance MonadMask IO
instance MonadCatch IO
instance MonadThrow IO
instance e ~ SomeException => MonadThrow (Either e)
instance MonadThrow Maybe
instance MonadThrow []


-- | This module supplies a 'pure' monad transformer that can be used for
--   mock-testing code that throws exceptions, so long as those exceptions
--   are always thrown with <a>throwM</a>.
--   
--   Do not mix <a>CatchT</a> with <a>IO</a>. Choose one or the other for
--   the bottom of your transformer stack!
module Control.Monad.Catch.Pure

-- | Add <a>Exception</a> handling abilities to a <a>Monad</a>.
--   
--   This should <i>never</i> be used in combination with <a>IO</a>. Think
--   of <a>CatchT</a> as an alternative base monad for use with mocking
--   code that solely throws exceptions via <a>throwM</a>.
--   
--   Note: that <a>IO</a> monad has these abilities already, so stacking
--   <a>CatchT</a> on top of it does not add any value and can possibly be
--   confusing:
--   
--   <pre>
--   &gt;&gt;&gt; (error "Hello!" :: IO ()) `catch` (\(e :: ErrorCall) -&gt; liftIO $ print e)
--   Hello!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runCatchT $ (error "Hello!" :: CatchT IO ()) `catch` (\(e :: ErrorCall) -&gt; liftIO $ print e)
--   *** Exception: Hello!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runCatchT $ (throwM (ErrorCall "Hello!") :: CatchT IO ()) `catch` (\(e :: ErrorCall) -&gt; liftIO $ print e)
--   Hello!
--   </pre>
newtype CatchT m a
CatchT :: m (Either SomeException a) -> CatchT m a
runCatchT :: CatchT m a -> m (Either SomeException a)
type Catch = CatchT Identity
runCatch :: Catch a -> Either SomeException a

-- | Map the unwrapped computation using the given function.
--   
--   <pre>
--   <a>runCatchT</a> (<a>mapCatchT</a> f m) = f (<a>runCatchT</a> m)
--   </pre>
mapCatchT :: (m (Either SomeException a) -> n (Either SomeException b)) -> CatchT m a -> CatchT n b
instance MonadRWS r w s m => MonadRWS r w s (CatchT m)
instance MonadWriter w m => MonadWriter w (CatchT m)
instance MonadReader e m => MonadReader e (CatchT m)
instance MonadState s m => MonadState s (CatchT m)
instance Monad m => MonadMask (CatchT m)
instance Monad m => MonadCatch (CatchT m)
instance Monad m => MonadThrow (CatchT m)
instance MonadIO m => MonadIO (CatchT m)
instance MonadTrans CatchT
instance Monad m => MonadPlus (CatchT m)
instance Monad m => Alternative (CatchT m)
instance (Monad m, Traversable m) => Traversable (CatchT m)
instance Foldable m => Foldable (CatchT m)
instance MonadFix m => MonadFix (CatchT m)
instance Monad m => Monad (CatchT m)
instance Monad m => Applicative (CatchT m)
instance Monad m => Functor (CatchT m)
