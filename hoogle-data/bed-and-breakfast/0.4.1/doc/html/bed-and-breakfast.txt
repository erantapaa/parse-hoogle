-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient Matrix operations in 100% Haskell.
--   
--   Efficient Matrix operations in 100% Haskell.
--   
--   <ul>
--   <li><i><tt>v0.1</tt></i> Initial version, features <tt>det</tt>, basic
--   arithmetic operations, and instances for <a>Float</a>, <a>Double</a>,
--   <a>Complex</a>, and <a>Rational</a>.</li>
--   <li><i><tt>v0.1.1</tt></i> Fixed wrong algorithm for computing the
--   inverse of a <a>Matrix</a>.</li>
--   <li><i><tt>v0.1.2</tt></i> Added instances for <tt>Num Matrix</tt>,
--   <tt>Fractional Matrix</tt>, and <tt>Eq Matrix</tt>.</li>
--   <li><i><tt>v0.1.3</tt></i> <tt>inv</tt> is now a total function and
--   will no longer call <a>error</a> if a matrix is not invertible. Also
--   <tt>Matrix</tt> derives <a>Data.Typeable</a> now.</li>
--   <li><i><tt>v0.1.4</tt></i> Added <tt>scale</tt>, and methods for
--   joining matrices vertically and horizontally. Corrected a bug in
--   <tt>isUnit</tt> reported by Charles Durham. <tt>isUnit</tt> returned
--   True for any matrix for which <tt>all (== 1) . trace</tt> would have,
--   which is wrong).</li>
--   <li><i><tt>v0.2</tt></i> A little bit more documentation. Also moved
--   some functions (<tt>isXXX</tt>) away from the type class
--   <tt>MatrixElement</tt>. Properly flagged the package as experimental
--   (was improperly marked as <tt>stable</tt>, copied form a
--   template).</li>
--   <li><i><tt>v0.2.1</tt></i> Added <tt>cofactors</tt>,
--   <tt>adjugate</tt>, <tt>minor</tt>, and <tt>minorMatrix</tt>.</li>
--   <li><i><tt>v0.2.2</tt></i> <tt>rank</tt> works now for any Matrix
--   component type.</li>
--   <li><i><tt>v0.2.3</tt></i> Added <a>Read</a> instance for
--   <tt>Matrix</tt>. Improved on documentation.</li>
--   <li><i><tt>v0.3</tt></i> Added a QuickCheck test suite, fixed a bug in
--   <tt>det</tt> (det would crash for singular matrices, where it should
--   return 0).</li>
--   <li><i><tt>v0.3.1</tt></i> Added TemplateHaskell syntactic sugar (see
--   <a>Numeric.Matrix.Sugar</a>). Rewrote multiplication. <tt>matrix</tt>
--   function build an array faster now.</li>
--   <li><i><tt>v0.3.2</tt></i> Numeric.Matrix.Sugar was not mentioned in
--   the cabal file. Improved test suite. Improved documentation.</li>
--   <li><i><tt>v0.4</tt></i> Fixed a bug regarding <tt>empty</tt> and
--   <tt>fromList</tt>. Use unsafe operations where it is safe for speed.
--   Added RULES. Added an instance for binary.</li>
--   <li><i><tt>v0.4.1</tt></i> The unsafe operations used in v0.4 turned
--   out to fatally fail on certain platforms. Revoked this change. Thanks
--   to Marcin Fatyga for pointing at the issue.</li>
--   </ul>
@package bed-and-breakfast
@version 0.4.1


-- | Efficient matrix operations in 100% pure Haskell.
--   
--   This package uses miscellaneous implementations, depending on the type
--   of its components. Typically unboxed arrays will perform best, while
--   unboxed arrays give you certain features such as <a>Rational</a> or
--   <a>Complex</a> components.
--   
--   The following component types are supported by <a>Matrix</a>:
--   
--   <ul>
--   <li><i><tt>Int</tt></i> Uses unboxed arrays internally. <a>inv</a>
--   will always return <a>Nothing</a>.</li>
--   <li><i><tt>Integer</tt></i> Uses boxed arrays internally. <a>inv</a>
--   will always return <a>Nothing</a>.</li>
--   <li><i><tt>Double</tt> and <tt>Float</tt></i> Uses unboxed arrays
--   internally. All matrix operations will work as expected. <tt>Matrix
--   Double</tt> will probably yield the best peformance.</li>
--   <li><i><tt>Rational</tt></i> Best choice if precision is what you aim
--   for. Uses boxed arrays internally. All matrix operations will work as
--   expected.</li>
--   <li><i><tt>Complex</tt></i> Experimental. Uses boxed arrays
--   internally. The current implementation of <a>inv</a> requires an
--   instance of <a>Ord</a> for the component type, therefor it is
--   currently not possible to calculate the inverse of a complex matrix
--   (on my to do list).</li>
--   </ul>
module Numeric.Matrix

-- | Matrices are represented by a type which fits best the component type.
--   For example a <tt>Matrix Double</tt> is represented by unboxed arrays,
--   <tt>Matrix Integer</tt> by boxed arrays.
--   
--   Data instances exist for <a>Int</a>, <a>Float</a>, <a>Double</a>,
--   <a>Integer</a>, <a>Ratio</a>, and <a>Complex</a>. Certain types do
--   have certain disadvantages, like for example you can not compute the
--   inverse matrix of a <tt>Matrix Int</tt>.
--   
--   Every matrix (regardless of the component type) has instances for
--   <a>Show</a>, <a>Read</a>, <a>Num</a>, <a>Fractional</a>, <a>Eq</a>,
--   <a>Typeable</a>, <a>Binary</a>, and <a>NFData</a>. This means that you
--   can use arithmetic operations like <a>+</a>, <a>*</a>, and <a>/</a>,
--   as well as functions like <a>show</a>, <a>read</a>, or <a>typeOf</a>.
--   
--   <ul>
--   <li><i><tt>Show (Matrix e)</tt></i> Note that a Show instance for the
--   component type <tt>e</tt> must exist.</li>
--   <li><i><tt>Read (Matrix e)</tt></i> You can read a matrix like
--   so:</li>
--   </ul>
--   
--   <pre>
--   read "1 0\n0 1\n" :: Matrix Double
--   </pre>
--   
--   <ul>
--   <li><i><tt>Num (Matrix e)</tt></i> <a>+</a>, <a>-</a>, <a>*</a>,
--   <a>negate</a>, <a>abs</a>, <a>signum</a>, and <a>fromInteger</a>.</li>
--   </ul>
--   
--   <a>signum</a> will compute the determinant and return the signum of
--   it.
--   
--   <a>abs</a> applies <tt>map abs</tt> on the matrix (that is, it applies
--   <tt>abs</tt> on every component in the matrix and returns a new matrix
--   without negative components).
--   
--   <tt>fromInteger</tt> yields a 1-x-1-matrix.
--   
--   <ul>
--   <li><i><tt>Fractional (Matrix e)</tt></i> Only available if there
--   exists an instance <tt>Fractional e</tt> (the component type needs to
--   have a <tt>Fractional</tt> instance, too). Note that while the
--   <a>Num</a> operations are safe, <a>recip</a> and <a>/</a> will fail
--   (with an <a>error</a>) if the involved matrix is not invertible or not
--   a square matrix.</li>
--   <li><i><tt>NFData (Matrix e)</tt></i> Matrices have instances for
--   NFData so that you can use a matrix in parallel computations using the
--   <tt>Control.Monad.Par</tt> monad (see the <tt>monad-par</tt> package
--   for details).</li>
--   <li><i><tt>Typeable (Matrix e)</tt></i> Allows you to use matrices as
--   <tt>Dynamic</tt> values.</li>
--   <li><i><tt>Binary (Matrix e)</tt></i> Serialize and unserialize
--   matrices using the <tt>binary</tt> package. See <tt>encode</tt> and
--   <tt>decode</tt>.</li>
--   </ul>
class (Eq e, Num e) => MatrixElement e where unit n = fromList [[if i == j then 1 else 0 | j <- [1 .. n]] | i <- [1 .. n]] zero n = matrix (n, n) (const 0) empty = fromList [] diag xs = matrix (n, n) (\ (i, j) -> if i == j then xs !! (i - 1) else 0) where n = length xs select p m = [at m (i, j) | i <- [1 .. numRows m], j <- [1 .. numCols m], p (i, j)] at m (i, j) = ((!! j) . (!! i) . toList) m row i m = ((!! (i - 1)) . toList) m col i m = (row i . transpose) m numRows = fst . dimensions numCols = snd . dimensions dimensions m = case toList m of { [] -> (0, 0) (x : xs) -> (length xs + 1, length x) } adjugate = transpose . cofactors transpose m = matrix (dimensions m) (\ (i, j) -> m `at` (j, i)) trace = select (uncurry (==)) inv _ = Nothing minorMatrix m (i, j) = matrix (numRows m - 1, numCols m - 1) $ \ (i', j') -> m `at` (if i' >= i then i' + 1 else i', if j' >= j then j' + 1 else j') minor m = det . minorMatrix m cofactors m = matrix (dimensions m) $ \ (i, j) -> fromIntegral ((- 1 :: Int) ^ (i + j)) * minor m (i, j) map f = mapWithIndex (const f) all f = allWithIndex (const f) any f = anyWithIndex (const f) mapWithIndex f m = matrix (dimensions m) (\ x -> f x (m `at` x)) allWithIndex f m = all id [f (i, j) (m `at` (i, j)) | i <- [1 .. numRows m], j <- [1 .. numCols m]] anyWithIndex f m = any id [f (i, j) (m `at` (i, j)) | i <- [1 .. numRows m], j <- [1 .. numCols m]] a plus b | dimensions a /= dimensions b = error "Matrix.plus: dimensions don't match." | otherwise = matrix (dimensions a) (\ x -> a `at` x + b `at` x) a minus b | dimensions a /= dimensions b = error "Matrix.minus: dimensions don't match." | otherwise = matrix (dimensions a) (\ x -> a `at` x - b `at` x) a times b | numCols a /= numRows b = error "Matrix.times: `numRows a' and `numCols b' don't match." | otherwise = _mult a b
matrix :: MatrixElement e => (Int, Int) -> ((Int, Int) -> e) -> Matrix e
select :: MatrixElement e => ((Int, Int) -> Bool) -> Matrix e -> [e]
at :: MatrixElement e => Matrix e -> (Int, Int) -> e
row :: MatrixElement e => Int -> Matrix e -> [e]
col :: MatrixElement e => Int -> Matrix e -> [e]
dimensions :: MatrixElement e => Matrix e -> (Int, Int)
numRows :: MatrixElement e => Matrix e -> Int
numCols :: MatrixElement e => Matrix e -> Int
fromList :: MatrixElement e => [[e]] -> Matrix e
toList :: MatrixElement e => Matrix e -> [[e]]
unit :: MatrixElement e => Int -> Matrix e
zero :: MatrixElement e => Int -> Matrix e
diag :: MatrixElement e => [e] -> Matrix e
empty :: MatrixElement e => Matrix e
minus :: MatrixElement e => Matrix e -> Matrix e -> Matrix e
plus :: MatrixElement e => Matrix e -> Matrix e -> Matrix e
times :: MatrixElement e => Matrix e -> Matrix e -> Matrix e
inv :: MatrixElement e => Matrix e -> Maybe (Matrix e)
det :: MatrixElement e => Matrix e -> e
transpose :: MatrixElement e => Matrix e -> Matrix e
rank :: MatrixElement e => Matrix e -> e
trace :: MatrixElement e => Matrix e -> [e]
minor :: (MatrixElement e, MatrixElement e) => Matrix e -> (Int, Int) -> e
cofactors :: (MatrixElement e, MatrixElement e) => Matrix e -> Matrix e
adjugate :: (MatrixElement e, MatrixElement e) => Matrix e -> Matrix e
minorMatrix :: (MatrixElement e, MatrixElement e) => Matrix e -> (Int, Int) -> Matrix e
map :: (MatrixElement e, MatrixElement f) => (e -> f) -> Matrix e -> Matrix f
all :: MatrixElement e => (e -> Bool) -> Matrix e -> Bool
any :: MatrixElement e => (e -> Bool) -> Matrix e -> Bool
mapWithIndex :: (MatrixElement e, MatrixElement f) => ((Int, Int) -> e -> f) -> Matrix e -> Matrix f
allWithIndex :: MatrixElement e => ((Int, Int) -> e -> Bool) -> Matrix e -> Bool
anyWithIndex :: MatrixElement e => ((Int, Int) -> e -> Bool) -> Matrix e -> Bool

-- | Joins two matrices horizontally.
--   
--   <pre>
--   1 2 3     1 0 0      1 2 3 1 0 0
--   3 4 5 &lt;|&gt; 2 1 0  -&gt;  3 4 5 2 1 0
--   5 6 7     3 2 1      5 6 7 3 2 1
--   </pre>
(<|>) :: MatrixElement e => Matrix e -> Matrix e -> Matrix e

-- | Joins two matrices vertically.
--   
--   <pre>
--   1 2 3     1 0 0      1 2 3
--   3 4 5 &lt;-&gt; 2 1 0  -&gt;  3 4 5
--   5 6 7     3 2 1      5 6 7
--                        1 0 0
--                        2 1 0
--                        3 2 1
--   </pre>
(<->) :: MatrixElement e => Matrix e -> Matrix e -> Matrix e

-- | Scales a matrix by the given factor.
--   
--   <pre>
--   scale s == map (*s)
--   </pre>
scale :: MatrixElement e => Matrix e -> e -> Matrix e

-- | Check whether the matrix is an identity matrix.
--   
--   <pre>
--   1 0 0
--   0 1 0
--   0 0 1 (True)
--   </pre>
isUnit :: MatrixElement e => Matrix e -> Bool

-- | Check whether the matrix consists of all zeros.
--   
--   <pre>
--   isZero == all (== 0)
--   </pre>
isZero :: MatrixElement e => Matrix e -> Bool

-- | Checks whether the matrix is a diagonal matrix.
--   
--   <pre>
--   4 0 0 0
--   0 7 0 0
--   0 0 3 0
--   0 0 0 9 (True)
--   </pre>
isDiagonal :: MatrixElement e => Matrix e -> Bool

-- | Checks whether the matrix is empty.
--   
--   <pre>
--   isEmpty m = numCols == 0 || numRows == 0
--   </pre>
isEmpty :: MatrixElement e => Matrix e -> Bool

-- | Checks whether the matrix is a square matrix.
--   
--   <pre>
--   isSquare == uncurry (==) . dimensions
--   </pre>
isSquare :: MatrixElement e => Matrix e -> Bool
instance (Show a, RealFloat a) => MatrixElement (Complex a)
instance (Show a, Integral a) => MatrixElement (Ratio a)
instance MatrixElement Double
instance MatrixElement Float
instance MatrixElement Integer
instance MatrixElement Int64
instance MatrixElement Int32
instance MatrixElement Int
instance RealFloat a => Division (Complex a)
instance Integral a => Division (Ratio a)
instance Division Double
instance Division Float
instance Division Integer
instance Division Word64
instance Division Word32
instance Division Word16
instance Division Word8
instance Division Int64
instance Division Int32
instance Division Int16
instance Division Int8
instance Division Int
instance (MatrixElement e, Binary e) => Binary (Matrix e)
instance (MatrixElement e, NFData e) => NFData (Matrix e)
instance MatrixElement e => Eq (Matrix e)
instance (MatrixElement e, Fractional e) => Fractional (Matrix e)
instance MatrixElement e => Num (Matrix e)
instance (Read e, MatrixElement e) => Read (Matrix e)
instance (MatrixElement e, Show e) => Show (Matrix e)
instance Typeable a => Typeable (Matrix a)

module Numeric.Matrix.Sugar
iMatrix :: QuasiQuoter
dMatrix :: QuasiQuoter
