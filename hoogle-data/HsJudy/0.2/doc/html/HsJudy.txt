-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Judy bindings, and some nice APIs
--   
--   Judy bindings (a C library that implements fast sparse dynamic arrays)
--   for Haskell presenting APIs conforming as much as possible to the
--   existent Haskell library interfaces, like Data.Map and
--   Data.Array.MArray. This binding for the Judy library includes all its
--   four types: mapping from words to bits (Judy1), from words to values
--   (JudyL), from strings to values (JudyHS) and from array-of-bytes to
--   values (JudyHS).
@package HsJudy
@version 0.2

module Data.Array.Judy.Stringable
class Stringable k
toString :: Stringable k => k -> String
fromString :: Stringable k => String -> k
useAsCS :: Stringable k => k -> (CString -> IO a) -> IO a
useAsCSLen :: Stringable k => k -> (CStringLen -> IO a) -> IO a
copyCS :: Stringable k => CString -> IO k
copyCSLen :: Stringable k => CStringLen -> IO k
instance [incoherent] Stringable ByteString
instance [incoherent] Stringable String

module Data.Array.Judy.CollectionsM
class Monad m => MapM c k a m | c -> k a m
new :: MapM c k a m => m c
delete :: MapM c k a m => k -> c -> m Bool
member :: MapM c k a m => k -> c -> m Bool
lookup :: MapM c k a m => k -> c -> m (Maybe a)
insert :: MapM c k a m => k -> a -> c -> m ()
alter :: (MapM c k a m, Eq a) => (Maybe a -> Maybe a) -> k -> c -> m (Maybe a)
fromList :: MapM c k a m => [(k, a)] -> m c
toList :: MapM c k a m => c -> m [(k, a)]
elems :: MapM c k a m => c -> m [a]
keys :: MapM c k a m => c -> m [k]
mapToList :: MapM c k a m => (k -> a -> b) -> c -> m [b]
swapMaps :: MapM c k a m => c -> c -> m ()
class MapF c k a | c -> k a
memberF :: MapF c k a => k -> c -> Bool
lookupF :: MapF c k a => k -> c -> Maybe a
fromListF :: MapF c k a => [(k, a)] -> c
toListF :: MapF c k a => c -> [(k, a)]
instance [incoherent] MapM (HashTable Int a) Int a IO
instance [incoherent] MapM (HashTable String a) String a IO
instance [incoherent] Ord k => MapM (IORef (Map k a)) k a IO

module Data.Array.Judy.Freeze
data Frozen a
class Freezable a
freeze :: Freezable a => a -> IO (Frozen a)

module Data.Array.Judy.HashIO
class HashIO a
hashIO :: HashIO a => a -> IO Value
class HashIO a => UniqueHashIO a
class UniqueHashIO a => ReversibleHashIO a
unHashIO :: ReversibleHashIO a => Value -> IO a
instance [incoherent] HashIO Integer
instance [incoherent] ReversibleHashIO Value
instance [incoherent] UniqueHashIO Value
instance [incoherent] HashIO Value
instance [incoherent] Enum a => ReversibleHashIO a
instance [incoherent] Enum a => HashIO a
instance [incoherent] Enum a => UniqueHashIO a

module Data.Array.Judy.Refeable
class Refeable a
toRef :: Refeable a => a -> IO Value
fromRef :: Refeable a => Value -> IO a
needGC :: Refeable a => a -> Bool
instance [incoherent] Refeable Int
instance [incoherent] Refeable a

module Data.Array.Judy.Hash
newtype (Stringable k, Refeable a) => Hash k a
Hash :: ForeignPtr JudyHS -> Hash k a
judy :: Hash k a -> ForeignPtr JudyHS
freeze :: Freezable a => a -> IO (Frozen a)
instance [incoherent] Typeable HashIter
instance [incoherent] Typeable2 Hash
instance [incoherent] Eq HashIter
instance [incoherent] Ord HashIter
instance [incoherent] Eq (Hash k a)
instance [incoherent] Ord (Hash k a)
instance [incoherent] Show HashIter
instance [incoherent] Show (Hash k a)
instance [incoherent] (Stringable k, Refeable a) => MapF (Frozen (Hash k a)) k a
instance [incoherent] (Stringable k, Refeable a) => Freezable (Hash k a)
instance [incoherent] (Stringable k, Refeable a) => MapM (Hash k a) k a IO

module Data.Array.Judy.IntMap
newtype (ReversibleHashIO k, Refeable a) => IntMap k a
IntMap :: ForeignPtr JudyL -> IntMap k a
judy :: IntMap k a -> ForeignPtr JudyL
freeze :: Freezable a => a -> IO (Frozen a)
toRevList :: (ReversibleHashIO k, Refeable a) => IntMap k a -> IO [(k, a)]
size :: IntMap k a -> IO Int
takeFirstElems :: Refeable a => Int -> IntMap k a -> IO [a]
takeFirst :: (ReversibleHashIO k, Refeable a) => Int -> IntMap k a -> IO [(k, a)]
takeLastElems :: Refeable a => Int -> IntMap k a -> IO [a]
takeLast :: (ReversibleHashIO k, Refeable a) => Int -> IntMap k a -> IO [(k, a)]
instance [incoherent] Typeable2 IntMap
instance [incoherent] Eq (IntMap k a)
instance [incoherent] Ord (IntMap k a)
instance [incoherent] Show (IntMap k a)
instance [incoherent] (ReversibleHashIO k, Refeable a) => MapF (Frozen (IntMap k a)) k a
instance [incoherent] (ReversibleHashIO k, Refeable a) => Freezable (IntMap k a)
instance [incoherent] (ReversibleHashIO k, Refeable a) => MapM (IntMap k a) k a IO

module Data.Array.Judy.StrMap
newtype (Stringable k, Refeable a) => StrMap k a
StrMap :: ForeignPtr JudySL -> StrMap k a
judy :: StrMap k a -> ForeignPtr JudySL
freeze :: Freezable a => a -> IO (Frozen a)
toRevList :: (Stringable k, Refeable a) => StrMap k a -> IO [(k, a)]
instance [incoherent] Typeable2 StrMap
instance [incoherent] Eq (StrMap k a)
instance [incoherent] Ord (StrMap k a)
instance [incoherent] Show (StrMap k a)
instance [incoherent] (Stringable k, Refeable a) => MapF (Frozen (StrMap k a)) k a
instance [incoherent] (Stringable k, Refeable a) => Freezable (StrMap k a)
instance [incoherent] (Stringable k, Refeable a) => MapM (StrMap k a) k a IO

module Data.Array.Judy.BitSet
newtype HashIO a => BitSet a
BitSet :: ForeignPtr Judy1 -> BitSet a
judy :: BitSet a -> ForeignPtr Judy1

-- | Swap contents of two sets.
swapBitSets :: BitSet a -> BitSet a -> IO ()

-- | Create a set.
new :: HashIO a => IO (BitSet a)

-- | Add a value to the set.
insert :: HashIO a => a -> BitSet a -> IO ()

-- | Delete a value in the set.
delete :: HashIO a => a -> BitSet a -> IO ()

-- | Set value in or out the set and return its old value.
set :: HashIO a => BitSet a -> a -> Bool -> IO Bool
get :: HashIO a => BitSet a -> a -> IO Bool

-- | Is the value a member of the set?
member :: HashIO a => a -> BitSet a -> IO Bool

-- | Is the set empty?
null :: BitSet a -> IO Bool

-- | Cardinality of the set.
size :: BitSet a -> IO Int

-- | Make the set empty.
clear :: HashIO a => BitSet a -> IO ()

-- | Convert the set to a list of elements.
toList :: Enum a => BitSet t -> IO [a]

-- | Create a set from a list of elements. FIXME: should I create the list
--   here maybe?
fromList :: HashIO a => [a] -> BitSet a -> IO ()

-- | Create a frozen, immutable version of a bitset, the original mutable
--   version is cleared.
freezeBitSet :: HashIO a => BitSet a -> IO (Frozen (BitSet a))
memberF :: HashIO a => a -> Frozen (BitSet a) -> Bool
fromListF :: HashIO a => [a] -> Frozen (BitSet a)
toListF :: Enum a => Frozen (BitSet t) -> [a]
instance [incoherent] Typeable1 BitSet
instance [incoherent] Eq (BitSet a)
instance [incoherent] Ord (BitSet a)
instance [incoherent] HashIO a => Freezable (BitSet a)
instance [incoherent] Show (BitSet a)
