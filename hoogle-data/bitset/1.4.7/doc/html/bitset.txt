-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A space-efficient set data structure.
--   
--   A <i>bit set</i> is a compact data structure, which maintains a set of
--   members from a type that can be enumerated (i. e. has an <a>Enum</a>
--   instance).
@package bitset
@version 1.4.7


-- | A space-efficient implementation of set data structure for enumerated
--   data types.
--   
--   <i>Note</i>: Read below the synopsis for important notes on the use of
--   this module.
--   
--   This module is intended to be imported <tt>qualified</tt>, to avoid
--   name clashes with <a>Prelude</a> functions, e.g.
--   
--   <pre>
--   import Data.BitSet.Generic (BitSet)
--   import qualified Data.BitSet.Generic as BS
--   </pre>
--   
--   The implementation is abstract with respect to container type, so any
--   numeric type with <a>Bits</a> instance can be used as a container.
--   However, independent of container choice, the maximum number of
--   elements in a bit set is bounded by <tt>maxBound :: Int</tt>.
module Data.BitSet.Generic

-- | A bit set with unspecified container type.
newtype BitSet c a
BitSet :: c -> BitSet c a
getBits :: BitSet c a -> c

-- | <i>O(max(m, n))</i>. See <a>difference</a>.
(\\) :: Bits c => BitSet c a -> BitSet c a -> BitSet c a

-- | The empty bit set.
empty :: (Enum a, Bits c, Num c) => BitSet c a

-- | O(1). Create a singleton set.
singleton :: (Enum a, Bits c, Num c) => a -> BitSet c a

-- | <i>O(d)</i>. Insert an item into the bit set.
insert :: (Enum a, Bits c) => a -> BitSet c a -> BitSet c a

-- | <i>O(d)</i>. Delete an item from the bit set.
delete :: (Enum a, Bits c) => a -> BitSet c a -> BitSet c a

-- | <i>O(1)</i>. Is the bit set empty?
null :: (Eq c, Num c) => BitSet c a -> Bool

-- | <i>O(1)</i>. The number of elements in the bit set.
size :: Bits c => BitSet c a -> Int

-- | <i>O(d)</i>. Ask whether the item is in the bit set.
member :: (Enum a, Bits c) => a -> BitSet c a -> Bool

-- | <i>O(d)</i>. Ask whether the item is not in the bit set.
notMember :: (Enum a, Bits c) => a -> BitSet c a -> Bool

-- | <i>O(max(n, m))</i>. Is this a subset? (<tt>s1 <a>isSubsetOf</a>
--   s2</tt>) tells whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: (Bits c, Eq c) => BitSet c a -> BitSet c a -> Bool

-- | <i>O(max(n, m)</i>. Is this a proper subset? (ie. a subset but not
--   equal).
isProperSubsetOf :: (Bits c, Eq c) => BitSet c a -> BitSet c a -> Bool

-- | <i>O(max(m, n))</i>. The union of two bit sets.
union :: Bits c => BitSet c a -> BitSet c a -> BitSet c a

-- | <i>O(max(m, n))</i>. Difference of two bit sets.
difference :: Bits c => BitSet c a -> BitSet c a -> BitSet c a

-- | <i>O(max(m, n))</i>. The intersection of two bit sets.
intersection :: Bits c => BitSet c a -> BitSet c a -> BitSet c a

-- | <i>O(d * n)</i> Transform this bit set by applying a function to every
--   value. Resulting bit set may be smaller then the original.
map :: (Enum a, Enum b, Bits c, Num c) => (a -> b) -> BitSet c a -> BitSet c b

-- | <i>O(d * n)</i> Reduce this bit set by applying a binary function to
--   all elements, using the given starting value. Each application of the
--   operator is evaluated before before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (Enum a, Bits c) => (b -> a -> b) -> b -> BitSet c a -> b

-- | <i>O(d * n)</i> Reduce this bit set by applying a binary function to
--   all elements, using the given starting value.
foldr :: (Enum a, Bits c) => (a -> b -> b) -> b -> BitSet c a -> b

-- | <i>O(d * n)</i> Filter this bit set by retaining only elements
--   satisfying predicate.
filter :: (Enum a, Bits c, Num c) => (a -> Bool) -> BitSet c a -> BitSet c a

-- | <i>O(d * n)</i>. Convert this bit set set to a list of elements.
toList :: (Enum a, Bits c, Num c) => BitSet c a -> [a]

-- | <i>O(d * n)</i>. Make a bit set from a list of elements.
fromList :: (Enum a, Bits c, Num c) => [a] -> BitSet c a
instance Typeable2 BitSet
instance Eq c => Eq (BitSet c a)
instance NFData c => NFData (BitSet c a)
instance Storable c => Storable (BitSet c a)
instance Ord c => Ord (BitSet c a)
instance (Enum a, Bits c, Num c) => Monoid (BitSet c a)
instance (Enum a, Show a, Bits c, Num c) => Show (BitSet c a)
instance (Enum a, Read a, Bits c, Num c) => Read (BitSet c a)


-- | A space-efficient implementation of set data structure for enumerated
--   data types.
--   
--   <i>Note</i>: Read below the synopsis for important notes on the use of
--   this module.
--   
--   This module is intended to be imported <tt>qualified</tt>, to avoid
--   name clashes with <a>Prelude</a> functions, e.g.
--   
--   <pre>
--   import Data.BitSet.Word (BitSet)
--   import qualified Data.BitSet.Word as BS
--   </pre>
--   
--   The implementation uses <a>Word</a> as underlying container, thus the
--   maximum number of elements you can store in this bit set is bounded by
--   the number of bits in <a>Word</a> data type. However, due to native
--   bitwise operations <a>Data.BitSet.Word</a> is significantly faster
--   then <a>Data.Set</a> on all operations.
module Data.BitSet.Word
type BitSet = BitSet Word

-- | <i>O(1)</i>. See <a>difference</a>.
(\\) :: BitSet a -> BitSet a -> BitSet a

-- | The empty bit set.
empty :: Enum a => BitSet a

-- | O(1). Create a singleton set.
singleton :: Enum a => a -> BitSet a

-- | <i>O(1)</i>. Insert an item into the bit set.
insert :: Enum a => a -> BitSet a -> BitSet a

-- | <i>O(1)</i>. Delete an item from the bit set.
delete :: Enum a => a -> BitSet a -> BitSet a

-- | <i>O(1)</i>. Is the bit set empty?
null :: BitSet a -> Bool

-- | <i>O(1)</i>. The number of elements in the bit set.
size :: BitSet a -> Int

-- | <i>O(1)</i>. Ask whether the item is in the bit set.
member :: Enum a => a -> BitSet a -> Bool

-- | <i>O(1)</i>. Ask whether the item is in the bit set.
notMember :: Enum a => a -> BitSet a -> Bool

-- | <i>O(1)</i>. Is this a subset? (<tt>s1 isSubsetOf s2</tt>) tells
--   whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: BitSet a -> BitSet a -> Bool

-- | <i>O(1)</i>. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: BitSet a -> BitSet a -> Bool

-- | <i>O(1)</i>. The union of two bit sets.
union :: BitSet a -> BitSet a -> BitSet a

-- | <i>O(1)</i>. Difference of two bit sets.
difference :: BitSet a -> BitSet a -> BitSet a

-- | <i>O(1)</i>. The intersection of two bit sets.
intersection :: BitSet a -> BitSet a -> BitSet a

-- | <i>O(n)</i> Transform this bit set by applying a function to every
--   value. Resulting bit set may be smaller then the original.
map :: (Enum a, Enum b) => (a -> b) -> BitSet a -> BitSet b

-- | <i>O(n)</i> Reduce this bit set by applying a binary function to all
--   elements, using the given starting value. Each application of the
--   operator is evaluated before before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: Enum a => (b -> a -> b) -> b -> BitSet a -> b

-- | <i>O(n)</i> Reduce this bit set by applying a binary function to all
--   elements, using the given starting value.
foldr :: Enum a => (a -> b -> b) -> b -> BitSet a -> b

-- | <i>O(n)</i> Filter this bit set by retaining only elements satisfying
--   a predicate.
filter :: Enum a => (a -> Bool) -> BitSet a -> BitSet a

-- | <i>O(n)</i>. Convert the bit set set to a list of elements.
toList :: Enum a => BitSet a -> [a]

-- | <i>O(n)</i>. Make a bit set from a list of elements.
fromList :: Enum a => [a] -> BitSet a


-- | A space-efficient implementation of set data structure for enumerated
--   data types.
--   
--   <i>Note</i>: Read below the synopsis for important notes on the use of
--   this module.
--   
--   This module is intended to be imported <tt>qualified</tt>, to avoid
--   name clashes with <a>Prelude</a> functions, e.g.
--   
--   <pre>
--   import Data.BitSet.Dynamic (BitSet)
--   import qualified Data.BitSet.Dynamic as BS
--   </pre>
--   
--   The implementation uses <a>Integer</a> as underlying container, thus
--   it grows automatically when more elements are inserted into the bit
--   set.
module Data.BitSet.Dynamic

-- | A wrapper around <a>Integer</a> which provides faster bit-level
--   operations.
newtype FasterInteger
FasterInteger :: Integer -> FasterInteger
type BitSet = BitSet FasterInteger

-- | <i>O(1)</i>. See <a>difference</a>.
(\\) :: BitSet a -> BitSet a -> BitSet a

-- | The empty bit set.
empty :: Enum a => BitSet a

-- | O(1). Create a singleton set.
singleton :: Enum a => a -> BitSet a

-- | <i>O(1)</i>. Insert an item into the bit set.
insert :: Enum a => a -> BitSet a -> BitSet a

-- | <i>O(1)</i>. Delete an item from the bit set.
delete :: Enum a => a -> BitSet a -> BitSet a

-- | <i>O(1)</i>. Is the bit set empty?
null :: BitSet a -> Bool

-- | <i>O(1)</i>. The number of elements in the bit set.
size :: BitSet a -> Int

-- | <i>O(1)</i>. Ask whether the item is in the bit set.
member :: Enum a => a -> BitSet a -> Bool

-- | <i>O(1)</i>. Ask whether the item is in the bit set.
notMember :: Enum a => a -> BitSet a -> Bool

-- | <i>O(max(n, m))</i>. Is this a subset? (<tt>s1 isSubsetOf s2</tt>)
--   tells whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: BitSet a -> BitSet a -> Bool

-- | <i>O(max(n, m)</i>. Is this a proper subset? (ie. a subset but not
--   equal).
isProperSubsetOf :: BitSet a -> BitSet a -> Bool

-- | <i>O(max(m, n))</i>. The union of two bit sets.
union :: BitSet a -> BitSet a -> BitSet a

-- | <i>O(1)</i>. Difference of two bit sets.
difference :: BitSet a -> BitSet a -> BitSet a

-- | <i>O(1)</i>. The intersection of two bit sets.
intersection :: BitSet a -> BitSet a -> BitSet a

-- | <i>O(n)</i> Transform this bit set by applying a function to every
--   value. Resulting bit set may be smaller then the original.
map :: (Enum a, Enum b) => (a -> b) -> BitSet a -> BitSet b

-- | <i>O(n)</i> Reduce this bit set by applying a binary function to all
--   elements, using the given starting value. Each application of the
--   operator is evaluated before before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: Enum a => (b -> a -> b) -> b -> BitSet a -> b

-- | <i>O(n)</i> Reduce this bit set by applying a binary function to all
--   elements, using the given starting value.
foldr :: Enum a => (a -> b -> b) -> b -> BitSet a -> b

-- | <i>O(n)</i> Filter this bit set by retaining only elements satisfying
--   a predicate.
filter :: Enum a => (a -> Bool) -> BitSet a -> BitSet a

-- | <i>O(n)</i>. Convert the bit set set to a list of elements.
toList :: Enum a => BitSet a -> [a]

-- | <i>O(n)</i>. Make a bit set from a list of elements.
fromList :: Enum a => [a] -> BitSet a
instance Read FasterInteger
instance Show FasterInteger
instance Eq FasterInteger
instance Ord FasterInteger
instance Enum FasterInteger
instance Integral FasterInteger
instance Num FasterInteger
instance Real FasterInteger
instance NFData FasterInteger
instance Bits FasterInteger


-- | A space-efficient implementation of set data structure for enumerated
--   data types.
module Data.BitSet
