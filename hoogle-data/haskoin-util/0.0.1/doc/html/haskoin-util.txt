-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utility functions for the Network.Haskoin project
--   
--   This package contains utility functions used across the
--   Network.Haskoin modules such as ByteString and Data.Binary helpers. It
--   also defines a Build monad describing computations that can be
--   Complete, Partial or Broken. Additionally, this package defines
--   constants tied to specific Bitcoin networks such as prodnet and
--   testnet.
@package haskoin-util
@version 0.0.1


-- | Declaration of constant values that depend on the network type (for
--   example: prodnet or testnet). The values exported from this modules
--   are imported from a network-specific sub-module.
module Network.Haskoin.Util.Network

-- | Prefix for base58 PubKey hash address
addrPrefix :: Word8

-- | Prefix for base58 script hash address
scriptPrefix :: Word8

-- | Prefix for private key WIF format
secretPrefix :: Word8

-- | Prefix for extended public keys (BIP32)
extPubKeyPrefix :: Word32

-- | Prefix for extended private keys (BIP32)
extSecretPrefix :: Word32

-- | Wallet database file name
walletFile :: String


-- | The Build type, and associated operations.
module Network.Haskoin.Util.BuildMonad

-- | The Build monad represents computations that can be in one of three
--   states:
--   
--   <ul>
--   <li>Complete</li>
--   <li>Partial</li>
--   <li>Broken</li>
--   </ul>
--   
--   It extends the Either monad with an additional Partial value to
--   describe a valid computation flagged with a Partial context. The Build
--   monad is useful when you describe computations where parts of the
--   computation are either complete, partially complete or broken.
--   Combining only Complete computations will produce a Complete result.
--   However, if one of the computations is Partial, the whole computation
--   will be Partial as well. And if some computation is Broken, the whole
--   computation will be broken as well.
--   
--   The Build monad is used by Haskoin to describe the state of the
--   transaction signing computation. To sign a transaction, all input
--   scripts need to be signed. The whole transaction will be completely
--   signed only if all the input scripts are completely signed. If any of
--   the inputs is partially signed, then the whole transaction will be
--   partially signed as well. And the whole transaction is broken if one
--   of the inputs failed to parse or is broken.
data Build a

-- | Describes a successful complete computation
Complete :: a -> Build a
runBuild :: Build a -> a

-- | Describes a successful but partial computation
Partial :: a -> Build a
runBuild :: Build a -> a

-- | Describes a broken computation
Broken :: String -> Build a
runBroken :: Build a -> String

-- | Returns True if the Build value is Complete
isComplete :: Build a -> Bool

-- | Returns True if the Build value is Partial
isPartial :: Build a -> Bool

-- | Return True if the Build value is Broken
isBroken :: Build a -> Bool

-- | Transforms an Either String value into a Build value. Right is mapped
--   to Complete and Left is mapped to Broken
eitherToBuild :: Either String a -> Build a

-- | Transforms a Build value into an Either String value. Complete and
--   Partial are mapped to Right and Broken is mapped to Left.
buildToEither :: Build a -> Either String a

-- | Binds a Partial value to the computation when the predicate is False.
guardPartial :: Bool -> Build ()

-- | BuildT transformer monad
newtype BuildT m a
BuildT :: m (Build a) -> BuildT m a
runBuildT :: BuildT m a -> m (Build a)

-- | Lift a Build computation into the BuildT monad
liftBuild :: Monad m => Build a -> BuildT m a
instance Eq a => Eq (Build a)
instance MonadIO m => MonadIO (BuildT m)
instance MonadTrans BuildT
instance Monad m => Monad (BuildT m)
instance Functor m => Functor (BuildT m)
instance Monad Build
instance Functor Build
instance Show a => Show (Build a)


-- | QuickCheck Arbitrary instances for various utility data types
module Network.Haskoin.Util.Arbitrary

-- | Generate non-empty strict ByteStrings
nonEmptyBS :: Gen ByteString
instance Arbitrary a => Arbitrary (Build a)
instance Arbitrary ByteString


-- | This module defines various utility functions used across the
--   Network.Haskoin modules.
module Network.Haskoin.Util

-- | Transforms a lazy bytestring into a strict bytestring
toStrictBS :: ByteString -> ByteString

-- | Transforms a strict bytestring into a lazy bytestring
toLazyBS :: ByteString -> ByteString

-- | Transforms a string into a strict bytestring
stringToBS :: String -> ByteString

-- | Transform a strict bytestring to a string
bsToString :: ByteString -> String

-- | Decode a big endian Integer from a bytestring
bsToInteger :: ByteString -> Integer

-- | Encode an Integer to a bytestring as big endian
integerToBS :: Integer -> ByteString

-- | Encode a bytestring to a base16 (HEX) representation
bsToHex :: ByteString -> String

-- | Decode a base16 (HEX) string from a bytestring. This function can fail
--   if the string contains invalid HEX characters
hexToBS :: String -> Maybe ByteString

-- | Strict version of <tt>Data.Binary.encode</tt>
encode' :: Binary a => a -> ByteString

-- | Strict version of <tt>Data.Binary.decode</tt>
decode' :: Binary a => ByteString -> a

-- | Strict version of <tt>Data.Binary.runPut</tt>
runPut' :: Put -> ByteString

-- | Strict version of <tt>Data.Binary.runGet</tt>
runGet' :: Binary a => Get a -> ByteString -> a

-- | Strict version of <tt>Data.Binary.decodeOrFail</tt>
decodeOrFail' :: Binary a => ByteString -> Either (ByteString, ByteOffset, String) (ByteString, ByteOffset, a)

-- | Strict version of <tt>Data.Binary.runGetOrFail</tt>
runGetOrFail' :: Binary a => Get a -> ByteString -> Either (ByteString, ByteOffset, String) (ByteString, ByteOffset, a)

-- | Try to decode a Data.Binary value. If decoding succeeds, apply the
--   function to the result. Otherwise, return the default value.
fromDecode :: Binary a => ByteString -> b -> (a -> b) -> b

-- | Try to run a Data.Binary.Get monad. If decoding succeeds, apply a
--   function to the result. Otherwise, return the default value.
fromRunGet :: Binary a => Get a -> ByteString -> b -> (a -> b) -> b

-- | Decode a Data.Binary value into the Either monad. A Right value is
--   returned with the result upon success. Otherwise a Left value with the
--   error message is returned.
decodeToEither :: Binary a => ByteString -> Either String a

-- | Decode a Data.Binary value into the Maybe monad. A Just value is
--   returned with the result upon success. Otherwise, Nothing is returned.
decodeToMaybe :: Binary a => ByteString -> Maybe a

-- | Isolate a Data.Binary.Get monad for the next <tt>Int</tt> bytes. Only
--   the next <tt>Int</tt> bytes of the input bytestring will be available
--   for the Get monad to consume. This function will fail if the Get monad
--   fails or some of the input is not consumed.
isolate :: Binary a => Int -> Get a -> Get a

-- | Returns True if the Either value is Left
isLeft :: Either a b -> Bool

-- | Returns True if the Either value is Right
isRight :: Either a b -> Bool

-- | Extract the Right value from an Either value. Fails if the value is
--   Left
fromRight :: Either a b -> b

-- | Extract the Left value from an Either value. Fails if the value is
--   Right
fromLeft :: Either a b -> a

-- | Transforms an Either value into a Maybe value. Right is mapped to Just
--   and Left is mapped to Nothing. The value inside Left is lost.
eitherToMaybe :: Either a b -> Maybe b

-- | Transforms a Maybe value into an Either value. Just is mapped to Right
--   and Nothing is mapped to Left. You also pass in an error value in case
--   Left is returned.
maybeToEither :: b -> Maybe a -> Either b a

-- | Applies a function to only one element of a list defined by it's
--   index. If the index is out of the bounds of the list, the original
--   list is returned
updateIndex :: Int -> [a] -> (a -> a) -> [a]

-- | Use the list [b] as a template and try to match the elements of [a]
--   against it. For each element of [b] return the (first) matching
--   element of [a], or Nothing. Output list has same size as [b] and
--   contains results in same order.
matchTemplate :: [a] -> [b] -> (a -> b -> Bool) -> [Maybe a]
