-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parser and pretty printer for the Eiffel language.
--   
--   This package provides a base to analyze and transform the Eiffel
--   language. It is suitable to build parsers.
@package language-eiffel
@version 0.1.2

module Language.Eiffel.Position
data Pos a
Pos :: SourcePos -> a -> Pos a
type Line = Int
type Column = Int

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos :: *

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName
inheritPos :: (Pos a -> b) -> Pos a -> Pos b
attachPos :: SourcePos -> a -> Pos a
attachPosM :: Monad m => m SourcePos -> m a -> m (Pos a)
attachEmptyPos :: a -> Pos a
attachPosBefore :: Parser a -> Parser (Pos a)
attachPosHere :: a -> Parser (Pos a)
takePos :: Pos a -> b -> Pos b
position :: Pos a -> SourcePos
contents :: Pos a -> a
instance NFData a_1627412790 => NFData (Pos a_1627412790)
instance NFData SourcePos
instance Binary a_1627412790 => Binary (Pos a_1627412790)
instance Ord a => Ord (Pos a)
instance Binary SourcePos
instance Functor Pos
instance Show a => Show (Pos a)
instance Eq a => Eq (Pos a)

module Language.Eiffel.Syntax
type Map = HashMap
type Clas = ClasBody Expr
type ClasBody exp = AbsClas (RoutineBody exp) exp
type ClasInterface = AbsClas EmptyBody Expr
type ClasI exp = AbsClas (RoutineBody exp) exp
data AbsClas body exp
AbsClas :: Bool -> Bool -> Bool -> [Note] -> ClassName -> Proc -> [Proc] -> [ProcDecl] -> [Generic] -> Bool -> [Inheritance] -> [CreateClause] -> [ConvertClause] -> FeatureMap body exp -> [Clause exp] -> AbsClas body exp
frozenClass :: AbsClas body exp -> Bool
expandedClass :: AbsClas body exp -> Bool
deferredClass :: AbsClas body exp -> Bool
classNote :: AbsClas body exp -> [Note]
className :: AbsClas body exp -> ClassName
currProc :: AbsClas body exp -> Proc
procGeneric :: AbsClas body exp -> [Proc]
procExpr :: AbsClas body exp -> [ProcDecl]
generics :: AbsClas body exp -> [Generic]
obsoleteClass :: AbsClas body exp -> Bool
inherit :: AbsClas body exp -> [Inheritance]
creates :: AbsClas body exp -> [CreateClause]
converts :: AbsClas body exp -> [ConvertClause]
featureMap :: AbsClas body exp -> FeatureMap body exp
invnts :: AbsClas body exp -> [Clause exp]
data FeatureMap body exp
FeatureMap :: !(Map Text (ExportedFeature (AbsRoutine body exp))) -> Map Text (ExportedFeature (Attribute exp)) -> Map Text (ExportedFeature (Constant exp)) -> FeatureMap body exp
_fmRoutines :: FeatureMap body exp -> !(Map Text (ExportedFeature (AbsRoutine body exp)))
_fmAttrs :: FeatureMap body exp -> Map Text (ExportedFeature (Attribute exp))
_fmConsts :: FeatureMap body exp -> Map Text (ExportedFeature (Constant exp))
data ExportedFeature feat
ExportedFeature :: Set Text -> !feat -> ExportedFeature feat
_exportClass :: ExportedFeature feat -> Set Text
_exportFeat :: ExportedFeature feat -> !feat
data SomeFeature body exp
SomeRoutine :: (AbsRoutine body exp) -> SomeFeature body exp
SomeAttr :: (Attribute exp) -> SomeFeature body exp
SomeConst :: (Constant exp) -> SomeFeature body exp
data Inheritance
Inheritance :: Bool -> [InheritClause] -> Inheritance
inheritNonConform :: Inheritance -> Bool
inheritClauses :: Inheritance -> [InheritClause]
data InheritClause
InheritClause :: Typ -> [RenameClause] -> [ExportClause] -> [Text] -> [Text] -> [Text] -> InheritClause
inheritClass :: InheritClause -> Typ
rename :: InheritClause -> [RenameClause]
export :: InheritClause -> [ExportClause]
undefine :: InheritClause -> [Text]
redefine :: InheritClause -> [Text]
select :: InheritClause -> [Text]
data RenameClause
Rename :: Text -> Text -> Maybe Text -> RenameClause
renameOrig :: RenameClause -> Text
renameNew :: RenameClause -> Text
renameAlias :: RenameClause -> Maybe Text
data ExportList
ExportFeatureNames :: [Text] -> ExportList
ExportAll :: ExportList
data ExportClause
Export :: [ClassName] -> ExportList -> ExportClause
exportTo :: ExportClause -> [ClassName]
exportWhat :: ExportClause -> ExportList
data Generic
Generic :: ClassName -> [Typ] -> Maybe [Text] -> Generic
genericName :: Generic -> ClassName
genericConstType :: Generic -> [Typ]
genericCreate :: Generic -> Maybe [Text]
data CreateClause
CreateClause :: [ClassName] -> [Text] -> CreateClause
createExportNames :: CreateClause -> [ClassName]
createNames :: CreateClause -> [Text]
data ConvertClause
ConvertFrom :: Text -> [Typ] -> ConvertClause
ConvertTo :: Text -> [Typ] -> ConvertClause
data FeatureClause body exp
FeatureClause :: [ClassName] -> [AbsRoutine body exp] -> [Attribute exp] -> [Constant exp] -> FeatureClause body exp
exportNames :: FeatureClause body exp -> [ClassName]
routines :: FeatureClause body exp -> [AbsRoutine body exp]
attributes :: FeatureClause body exp -> [Attribute exp]
constants :: FeatureClause body exp -> [Constant exp]
type RoutineI = AbsRoutine EmptyBody Expr
type RoutineWithBody exp = AbsRoutine (RoutineBody exp) exp
type Routine = RoutineWithBody Expr
data EmptyBody
EmptyBody :: EmptyBody
data Contract exp
Contract :: Bool -> [Clause exp] -> Contract exp
contractInherited :: Contract exp -> Bool
contractClauses :: Contract exp -> [Clause exp]
data AbsRoutine body exp
AbsRoutine :: !Bool -> !Text -> Maybe Text -> [Decl] -> Typ -> Maybe Text -> [Note] -> [Proc] -> Contract exp -> [ProcExpr] -> !body -> Contract exp -> [Proc] -> Maybe [PosAbsStmt exp] -> AbsRoutine body exp
routineFroz :: AbsRoutine body exp -> !Bool
routineName :: AbsRoutine body exp -> !Text
routineAlias :: AbsRoutine body exp -> Maybe Text
routineArgs :: AbsRoutine body exp -> [Decl]
routineResult :: AbsRoutine body exp -> Typ
routineAssigner :: AbsRoutine body exp -> Maybe Text
routineNote :: AbsRoutine body exp -> [Note]
routineProcs :: AbsRoutine body exp -> [Proc]
routineReq :: AbsRoutine body exp -> Contract exp
routineReqLk :: AbsRoutine body exp -> [ProcExpr]
routineImpl :: AbsRoutine body exp -> !body
routineEns :: AbsRoutine body exp -> Contract exp
routineEnsLk :: AbsRoutine body exp -> [Proc]
routineRescue :: AbsRoutine body exp -> Maybe [PosAbsStmt exp]
data RoutineBody exp
RoutineDefer :: RoutineBody exp
RoutineExternal :: Text -> (Maybe Text) -> RoutineBody exp
RoutineBody :: [Decl] -> [ProcDecl] -> PosAbsStmt exp -> RoutineBody exp
routineLocal :: RoutineBody exp -> [Decl]
routineLocalProcs :: RoutineBody exp -> [ProcDecl]
routineBody :: RoutineBody exp -> PosAbsStmt exp
data Attribute exp
Attribute :: Bool -> Decl -> Maybe Text -> [Note] -> Contract exp -> Contract exp -> Attribute exp
attrFroz :: Attribute exp -> Bool
attrDecl :: Attribute exp -> Decl
attrAssign :: Attribute exp -> Maybe Text
attrNotes :: Attribute exp -> [Note]
attrReq :: Attribute exp -> Contract exp
attrEns :: Attribute exp -> Contract exp
data Constant exp
Constant :: Bool -> Decl -> exp -> Constant exp
constFroz :: Constant exp -> Bool
constDecl :: Constant exp -> Decl
constVal :: Constant exp -> exp
type Expr = Pos UnPosExpr
data BinOp
Add :: BinOp
Sub :: BinOp
Mul :: BinOp
Div :: BinOp
Quot :: BinOp
Rem :: BinOp
Pow :: BinOp
Or :: BinOp
OrElse :: BinOp
Xor :: BinOp
And :: BinOp
AndThen :: BinOp
Implies :: BinOp
RelOp :: ROp -> Typ -> BinOp
SymbolOp :: Text -> BinOp
data ROp
Lte :: ROp
Lt :: ROp
Eq :: ROp
TildeEq :: ROp
Neq :: ROp
TildeNeq :: ROp
Gt :: ROp
Gte :: ROp
data UnOp
Not :: UnOp
Neg :: UnOp
Old :: UnOp
data UnPosExpr
UnqualCall :: Text -> [Expr] -> UnPosExpr
QualCall :: Expr -> Text -> [Expr] -> UnPosExpr
Lookup :: Expr -> [Expr] -> UnPosExpr
PrecursorCall :: (Maybe Text) -> [Expr] -> UnPosExpr
BinOpExpr :: BinOp -> Expr -> Expr -> UnPosExpr
UnOpExpr :: UnOp -> Expr -> UnPosExpr
Address :: Expr -> UnPosExpr
Attached :: (Maybe Typ) -> Expr -> (Maybe Text) -> UnPosExpr
AcrossExpr :: Expr -> Text -> Quant -> Expr -> UnPosExpr
Agent :: Expr -> UnPosExpr
CreateExpr :: Typ -> Text -> [Expr] -> UnPosExpr
Tuple :: [Expr] -> UnPosExpr
InlineAgent :: [Decl] -> (Maybe Typ) -> [Stmt] -> [Expr] -> UnPosExpr
ManifestCast :: Typ -> Expr -> UnPosExpr
TypedVar :: Text -> Typ -> UnPosExpr
VarOrCall :: Text -> UnPosExpr
ResultVar :: UnPosExpr
OnceStr :: Text -> UnPosExpr
CurrentVar :: UnPosExpr
StaticCall :: Typ -> Text -> [Expr] -> UnPosExpr
LitArray :: [Expr] -> UnPosExpr
LitString :: Text -> UnPosExpr
LitChar :: Char -> UnPosExpr
LitInt :: Integer -> UnPosExpr
LitBool :: Bool -> UnPosExpr
LitVoid :: UnPosExpr
LitDouble :: Double -> UnPosExpr
LitType :: Typ -> UnPosExpr
data Quant
All :: Quant
Some :: Quant
commaSepShow :: Show a => [a] -> [Char]
argsShow :: Show a => [a] -> [Char]
defaultCreate :: Text
data Typ
ClassType :: ClassName -> [Typ] -> Typ
TupleType :: (Either [Typ] [Decl]) -> Typ
Sep :: (Maybe Proc) -> [Proc] -> Text -> Typ
Like :: Text -> Typ
VoidType :: Typ
NoType :: Typ
data Decl
Decl :: Text -> Typ -> Decl
declName :: Decl -> Text
declType :: Decl -> Typ
data Proc
Dot :: Proc
Proc :: Text -> Proc
unProcGen :: Proc -> Text
type ClassName = Text
type Stmt = PosAbsStmt Expr
type UnPosStmt = AbsStmt Expr
type PosAbsStmt a = Pos (AbsStmt a)
data AbsStmt a
Assign :: a -> a -> AbsStmt a
AssignAttempt :: a -> a -> AbsStmt a
If :: a -> (PosAbsStmt a) -> [ElseIfPart a] -> (Maybe (PosAbsStmt a)) -> AbsStmt a
Malloc :: ClassName -> AbsStmt a
Create :: (Maybe Typ) -> a -> Text -> [a] -> AbsStmt a
Across :: a -> Text -> (PosAbsStmt a) -> AbsStmt a
Loop :: (PosAbsStmt a) -> [Clause a] -> a -> (PosAbsStmt a) -> (Maybe a) -> AbsStmt a
CallStmt :: a -> AbsStmt a
Retry :: AbsStmt a
Inspect :: a -> [([a], PosAbsStmt a)] -> (Maybe (PosAbsStmt a)) -> AbsStmt a
Check :: [Clause a] -> AbsStmt a
CheckBlock :: [Clause a] -> (PosAbsStmt a) -> AbsStmt a
Block :: [PosAbsStmt a] -> AbsStmt a
Debug :: Text -> (PosAbsStmt a) -> AbsStmt a
Print :: a -> AbsStmt a
PrintD :: a -> AbsStmt a
BuiltIn :: AbsStmt a
data ElseIfPart a
ElseIfPart :: a -> (PosAbsStmt a) -> ElseIfPart a
braced :: Show a => Maybe a -> [Char]
showCase :: (Show a, Show a1) => (a, a1) -> [Char]
showDefault :: Show a => Maybe a -> [Char]
data ProcExpr
LessThan :: Proc -> Proc -> ProcExpr
data ProcDecl
SubTop :: Proc -> ProcDecl
CreateLessThan :: Proc -> Proc -> ProcDecl
data Clause a
Clause :: Maybe Text -> a -> Clause a
clauseName :: Clause a -> Maybe Text
clauseExpr :: Clause a -> a
data Note
Note :: Text -> [UnPosExpr] -> Note
noteTag :: Note -> Text
noteContent :: Note -> [UnPosExpr]
exportFeat :: Lens (ExportedFeature feat_aaVy) (ExportedFeature feat_aezt) feat_aaVy feat_aezt
exportClass :: Lens' (ExportedFeature feat_aaVy) (Set Text)
fmRoutines :: Lens (FeatureMap body_aaXg exp_aaXh) (FeatureMap body_aeAg exp_aaXh) (Map Text (ExportedFeature (AbsRoutine body_aaXg exp_aaXh))) (Map Text (ExportedFeature (AbsRoutine body_aeAg exp_aaXh)))
fmConsts :: Lens' (FeatureMap body_aaXg exp_aaXh) (Map Text (ExportedFeature (Constant exp_aaXh)))
fmAttrs :: Lens' (FeatureMap body_aaXg exp_aaXh) (Map Text (ExportedFeature (Attribute exp_aaXh)))
instance (NFData body_1627432068, NFData exp_1627432069) => NFData (AbsClas body_1627432068 exp_1627432069)
instance (NFData body_1627432066, NFData exp_1627432067) => NFData (FeatureMap body_1627432066 exp_1627432067)
instance NFData feat_1627431960 => NFData (ExportedFeature feat_1627431960)
instance (NFData body_1627431958, NFData exp_1627431959) => NFData (SomeFeature body_1627431958 exp_1627431959)
instance NFData Note
instance NFData Inheritance
instance NFData InheritClause
instance NFData CreateClause
instance NFData ConvertClause
instance (NFData body_1627431956, NFData exp_1627431957) => NFData (FeatureClause body_1627431956 exp_1627431957)
instance NFData a_1627431927 => NFData (Clause a_1627431927)
instance NFData Generic
instance NFData ProcDecl
instance NFData Proc
instance NFData exp_1627431954 => NFData (Contract exp_1627431954)
instance NFData EmptyBody
instance NFData exp_1627431951 => NFData (RoutineBody exp_1627431951)
instance (NFData body_1627431952, NFData exp_1627431953) => NFData (AbsRoutine body_1627431952 exp_1627431953)
instance NFData exp_1627431950 => NFData (Attribute exp_1627431950)
instance NFData exp_1627431949 => NFData (Constant exp_1627431949)
instance NFData RenameClause
instance NFData ExportClause
instance NFData ExportList
instance NFData ProcExpr
instance NFData a_1627431946 => NFData (ElseIfPart a_1627431946)
instance NFData a_1627431947 => NFData (AbsStmt a_1627431947)
instance NFData ROp
instance NFData UnOp
instance NFData Decl
instance NFData Quant
instance NFData BinOp
instance NFData UnPosExpr
instance NFData Typ
instance (Binary body_1627432068, Binary exp_1627432069) => Binary (AbsClas body_1627432068 exp_1627432069)
instance Binary feat_1627431960 => Binary (ExportedFeature feat_1627431960)
instance (Binary body_1627432066, Binary exp_1627432067) => Binary (FeatureMap body_1627432066 exp_1627432067)
instance (Binary body_1627431958, Binary exp_1627431959) => Binary (SomeFeature body_1627431958 exp_1627431959)
instance Binary Note
instance Binary Inheritance
instance Binary InheritClause
instance Binary CreateClause
instance Binary ConvertClause
instance (Binary body_1627431956, Binary exp_1627431957) => Binary (FeatureClause body_1627431956 exp_1627431957)
instance Binary a_1627431927 => Binary (Clause a_1627431927)
instance Binary Generic
instance Binary ProcDecl
instance Binary Proc
instance Binary exp_1627431954 => Binary (Contract exp_1627431954)
instance Binary EmptyBody
instance (Binary body_1627431952, Binary exp_1627431953) => Binary (AbsRoutine body_1627431952 exp_1627431953)
instance Binary exp_1627431950 => Binary (Attribute exp_1627431950)
instance Binary exp_1627431949 => Binary (Constant exp_1627431949)
instance Binary RenameClause
instance Binary ExportClause
instance Binary ExportList
instance Binary ProcExpr
instance Binary a_1627431946 => Binary (ElseIfPart a_1627431946)
instance Binary a_1627431947 => Binary (AbsStmt a_1627431947)
instance Binary ROp
instance Binary UnOp
instance Binary Decl
instance Binary Quant
instance Binary BinOp
instance Binary UnPosExpr
instance Binary Typ
instance Eq feat => Eq (ExportedFeature feat)
instance Ord feat => Ord (ExportedFeature feat)
instance Show feat => Show (ExportedFeature feat)
instance Show RenameClause
instance Eq RenameClause
instance Show ExportList
instance Eq ExportList
instance Show EmptyBody
instance Eq EmptyBody
instance Ord EmptyBody
instance Show ROp
instance Ord ROp
instance Eq ROp
instance Show UnOp
instance Ord UnOp
instance Eq UnOp
instance Eq Quant
instance Ord Quant
instance Show Quant
instance Eq Proc
instance Ord Proc
instance Generic Proc
instance Eq Typ
instance Ord Typ
instance Generic Typ
instance Ord Decl
instance Eq Decl
instance Generic Decl
instance Show exp => Show (Constant exp)
instance Eq exp => Eq (Constant exp)
instance Ord exp => Ord (Constant exp)
instance Show BinOp
instance Ord BinOp
instance Eq BinOp
instance Show ConvertClause
instance Eq ConvertClause
instance Show CreateClause
instance Eq CreateClause
instance Show Generic
instance Eq Generic
instance Show ExportClause
instance Eq ExportClause
instance Show InheritClause
instance Eq InheritClause
instance Show Inheritance
instance Eq Inheritance
instance Show ProcExpr
instance Eq ProcExpr
instance Ord ProcExpr
instance Show ProcDecl
instance Eq ProcDecl
instance Ord ProcDecl
instance Show a => Show (Clause a)
instance Ord a => Ord (Clause a)
instance Eq a => Eq (Clause a)
instance Ord a => Ord (AbsStmt a)
instance Eq a => Eq (AbsStmt a)
instance Show a => Show (ElseIfPart a)
instance Ord a => Ord (ElseIfPart a)
instance Eq a => Eq (ElseIfPart a)
instance Ord UnPosExpr
instance Eq UnPosExpr
instance Show exp => Show (RoutineBody exp)
instance Eq exp => Eq (RoutineBody exp)
instance Ord exp => Ord (RoutineBody exp)
instance Show exp => Show (Contract exp)
instance Eq exp => Eq (Contract exp)
instance Ord exp => Ord (Contract exp)
instance Show Note
instance Eq Note
instance Ord Note
instance Show exp => Show (Attribute exp)
instance Eq exp => Eq (Attribute exp)
instance Ord exp => Ord (Attribute exp)
instance (Show body, Show exp) => Show (AbsRoutine body exp)
instance (Eq body, Eq exp) => Eq (AbsRoutine body exp)
instance (Ord body, Ord exp) => Ord (AbsRoutine body exp)
instance (Show body, Show exp) => Show (FeatureClause body exp)
instance (Eq body, Eq exp) => Eq (FeatureClause body exp)
instance (Eq body, Eq exp) => Eq (SomeFeature body exp)
instance (Show body, Show exp) => Show (SomeFeature body exp)
instance (Ord body, Ord exp) => Ord (SomeFeature body exp)
instance (Show body, Show exp) => Show (FeatureMap body exp)
instance (Eq body, Eq exp) => Eq (FeatureMap body exp)
instance (Eq body, Eq exp) => Eq (AbsClas body exp)
instance (Show body, Show exp) => Show (AbsClas body exp)
instance Datatype D1Proc
instance Constructor C1_0Proc
instance Constructor C1_1Proc
instance Selector S1_1_0Proc
instance Datatype D1Typ
instance Constructor C1_0Typ
instance Constructor C1_1Typ
instance Constructor C1_2Typ
instance Constructor C1_3Typ
instance Constructor C1_4Typ
instance Constructor C1_5Typ
instance Datatype D1Decl
instance Constructor C1_0Decl
instance Selector S1_0_0Decl
instance Selector S1_0_1Decl
instance (Eq k, Hashable k, Binary k, Binary v) => Binary (HashMap k v)
instance Binary Text
instance Show a => Show (AbsStmt a)
instance Show Typ
instance Show Proc
instance Hashable Proc
instance Show Decl
instance Hashable Decl
instance Hashable Typ
instance Show UnPosExpr

module Language.Eiffel.Util

-- | A <a>Feature</a> can provide its name, arguments, contract, etc.
class Feature a expr | a -> expr
featureName :: Feature a expr => a -> Text
featureArgs :: Feature a expr => a -> [Decl]
featureResult :: Feature a expr => a -> Typ
featurePre :: Feature a expr => a -> [Clause expr]
featurePost :: Feature a expr => a -> [Clause expr]
featureIsFrozen :: Feature a expr => a -> Bool
featureRename :: Feature a expr => a -> RenameClause -> a

-- | An existential type to aggregate all features (routines, attributes,
--   constants) together.
data FeatureEx expr

-- | Wrap the <a>Feature</a> in the existential type.
FeatureEx :: a -> FeatureEx expr

-- | Wrap up SomeFeature
wrapSomeFeature :: (forall f. Feature f expr => f -> b) -> SomeFeature body expr -> b

-- | A way to extract each type of feature from a class.
class Feature a expr => ClassFeature a body expr | a -> expr, a -> body
allFeatures :: ClassFeature a body expr => AbsClas body expr -> [a]
findFeature :: ClassFeature a body expr => AbsClas body expr -> Text -> Maybe a
findFeature' :: (SomeFeature body expr -> Maybe a) -> AbsClas body expr -> Text -> Maybe a

-- | Convert a constant into an attribute.
constToAttr :: Constant exp -> Attribute Expr

-- | Fetch attributes from all feature clauses.
allAttributes :: AbsClas body exp -> [Attribute exp]

-- | Fetch routines from all feature clauses.
allRoutines :: AbsClas body exp -> [AbsRoutine body exp]

-- | Fetch contants from all feature clauses.
allConstants :: AbsClas body exp -> [Constant exp]
allHelper :: Getting (HashMap k (ExportedFeature a)) (FeatureMap body exp) t (HashMap k (ExportedFeature a)) b -> AbsClas body exp -> [a]

-- | Fetch creation routines from all feature clauses.
allCreates :: AbsClas body exp -> [Text]

-- | Fetch attribute declarations from all feature clauses.
allAttributeDecls :: AbsClas body exp -> [Decl]

-- | Fetch constant declarations from all feature clauses.
allConstantDecls :: AbsClas body exp -> [Decl]

-- | All inheritance clauses.
allInherited :: AbsClas body exp -> [InheritClause]

-- | All inherited classes, as types.
allInheritedTypes :: AbsClas body exp -> [Typ]

-- | Determine if a name is in the creation clause of a class.
isCreateName :: Text -> AbsClas body exp -> Bool
toRoutineMb :: SomeFeature t t1 -> Maybe (AbsRoutine t t1)
toAttrMb :: SomeFeature t t1 -> Maybe (Attribute t1)
toConstMb :: SomeFeature t t1 -> Maybe (Constant t1)

-- | Set the feature clause of a class.
updFeatureMap :: AbsClas body exp -> FeatureMap body exp -> AbsClas body exp

-- | Update a routine body.
updFeatBody :: RoutineBody a -> PosAbsStmt b -> RoutineBody b

-- | These functions will update a class or feature clause with a
--   transformation function.
--   
--   Map a transformation function over the routines in a class, replacing
--   the old routines with the transformed versions within a feature
--   clause. mapRoutines f = Map.map (over exportFeat (onlyRoutine f))
--   
--   Monadic version of <tt>mapRoutines</tt>.
mapRoutinesM :: (Applicative m, Monad m) => (AbsRoutine body exp -> m (AbsRoutine body exp)) -> FeatureMap body exp -> m (FeatureMap body exp)

-- | Map a transformation function over the attributes in a class,
--   replacing the old attributes with the transformed versions within a
--   feature clause.
mapAttributes :: (Attribute exp -> Attribute exp) -> FeatureMap body exp -> FeatureMap body exp

-- | Monadic version of <a>mapAttributes</a>.
mapAttributesM :: (Monad m, Applicative m) => (Attribute exp -> m (Attribute exp)) -> FeatureMap body exp -> m (FeatureMap body exp)

-- | Map a transformation function over the constants in a class, replacing
--   the old constants with the transformed versions within a feature
--   clause. mapConstants f = Map.map (over exportFeat (onlyConst f))
--   
--   Map a transformation function over the contracts in a class, replacing
--   the old contracts with the transformed versions within a feature
--   clause.
mapContract :: (Clause exp1 -> Clause exp) -> Contract exp1 -> Contract exp

-- | Map a transformation function over all expressions in a class. A
--   transformation for features, constants, and attributes must be given
--   as if the type of expressions changes (ie, with a typecheck) then all
--   expressions types must change together.
mapExprs :: (AbsRoutine body exp -> AbsRoutine body' exp') -> (Constant exp -> Constant exp') -> (Clause exp -> Clause exp') -> FeatureMap body exp -> FeatureMap body' exp'

-- | Map a transformation function over the attributes in a class,
--   replacing the old attributes with the transformed versions within a
--   class.
classMapAttributes :: (Attribute exp -> Attribute exp) -> AbsClas body exp -> AbsClas body exp

-- | Monadic version of <a>classMapAttributes</a>.
classMapAttributesM :: (Applicative m, Monad m) => (Attribute exp -> m (Attribute exp)) -> AbsClas body exp -> m (AbsClas body exp)

-- | Map a transformation function over the routines in a class, replacing
--   the old routines with the transformed versions within a class.
classMapRoutines :: (AbsRoutine body exp -> AbsRoutine body exp) -> AbsClas body exp -> AbsClas body exp

-- | Monadic version of <a>classMapRoutines</a>.
classMapRoutinesM :: (Applicative m, Monad m) => (AbsRoutine body exp -> m (AbsRoutine body exp)) -> AbsClas body exp -> m (AbsClas body exp)

-- | Map a transformation function over the constants in a class, replacing
--   the old constants with the transformed versions within a class.
classMapConstants :: (Constant exp -> Constant exp) -> AbsClas body exp -> AbsClas body exp

-- | Map a transformation function over all expressions in a class. A
--   transformation for features, constants, and attributes must be given
--   as if the type of expressions changes (ie, with a typecheck) then all
--   expressions types must change together. This is performed on every
--   feature clause in a class.
classMapExprs :: (AbsRoutine body exp -> AbsRoutine body' exp') -> (Clause exp -> Clause exp') -> (Constant exp -> Constant exp') -> AbsClas body exp -> AbsClas body' exp'

-- | Strip the body from a routine.
makeRoutineIs :: SomeFeature body Expr -> SomeFeature EmptyBody Expr

-- | Strip the contracts from an attribute.
makeAttributeI :: Attribute exp -> Attribute Expr

-- | Strip the bodies from all features.
clasInterface :: AbsClas body Expr -> ClasInterface

-- | Strip the bodies and rescue clause from a routine.
makeRoutineI :: AbsRoutine body Expr -> RoutineI

-- | Turn a list of classes into a map indexed by the class names.
clasMap :: [AbsClas body exp] -> Map ClassName (AbsClas body exp)

-- | Extract a map of attribute names to types given a class.
attrMap :: AbsClas body exp -> Map Text Typ

-- | Find a routine in a class.
findRoutine :: Clas -> Text -> Maybe Routine

-- | Find an operator (symbol sequence) in a class.
findOperator :: AbsClas body Expr -> Text -> Int -> Maybe (AbsRoutine body Expr)

-- | Find the sum-type for all features.
findSomeFeature :: AbsClas body expr -> Text -> Maybe (SomeFeature body expr)

-- | Find an existential <a>FeatureEx</a>.
findFeatureEx :: AbsClas body expr -> Text -> Maybe (FeatureEx expr)

-- | Find a routine by name.
findRoutineInt :: ClasInterface -> Text -> Maybe RoutineI

-- | Find an attribute in a class by name.
findAttrInt :: AbsClas body expr -> Text -> Maybe (Attribute expr)

-- | Find a constant by name in a class.
findConstantInt :: AbsClas body Expr -> Text -> Maybe (Constant Expr)

-- | Given a class and a routine, given a unique name.
fullName :: AbsClas body exp -> RoutineI -> Text

-- | Given to string construct a unique combination.
fullNameStr :: Text -> Text -> Text

-- | Given a class, create a list of generic classes for the formal generic
--   parameters of the class.
genericStubs :: AbsClas body exp -> [AbsClas body' exp']

-- | Given a generic, construct a class for the generic.
makeGenericStub :: Generic -> AbsClas body exp

-- | Rename a declaration.
renameDecl :: RenameClause -> Decl -> Decl

-- | Rename a type, in the case of a like-type.
renameType :: RenameClause -> Typ -> Typ

-- | Rename everything in a class.
renameAll :: [RenameClause] -> AbsClas body exp -> AbsClas body exp

-- | Undefine a single feature in a class.
undefineName :: Text -> AbsClas body exp -> AbsClas body exp

-- | Undefine every specified name for a class.
undefineAll :: InheritClause -> AbsClas body exp -> AbsClas body exp

-- | Specifies whether a class can be merged with another.
mergeableClass :: AbsClas body exp -> Bool

-- | Merge two classes, combining invariants and feature clauses.
mergeClass :: AbsClas body exp -> AbsClas body exp -> AbsClas body exp

-- | Merge a list of classes.
mergeClasses :: [AbsClas body exp] -> AbsClas body exp
fmMapKeys :: (Text -> Text) -> FeatureMap body exp -> FeatureMap body exp
fmKeyFilter :: (Text -> Bool) -> FeatureMap body exp -> FeatureMap body exp
fmUnion :: FeatureMap body exp -> FeatureMap body exp -> FeatureMap body exp
fmEmpty :: FeatureMap body exp
fmUnions :: [FeatureMap body exp] -> FeatureMap body exp

-- | Construct a map from a routine's arguments.
argMap :: RoutineWithBody a -> Map Text Typ

-- | Construct a map from a routine's declarations.
localMap :: RoutineWithBody a -> Map Text Typ

-- | Give the declarations of a routine's locals.
routineDecls :: AbsRoutine (RoutineBody exp1) exp -> [Decl]

-- | Operator aliases for user-level operators, ie, not including =, <i>=,
--   ~, and </i>~
opAlias :: BinOp -> Text

-- | Test if the binary operator is an equality operator.
equalityOp :: BinOp -> Bool

-- | Unary operator aliases for everything except <tt>old</tt>.
unOpAlias :: IsString a => UnOp -> a

-- | Convert a class into its type.
classToType :: AbsClas body exp -> Typ

-- | Whether a type is basic (where basic meaning its an integer, natural,
--   real or boolean).
isBasic :: Typ -> Bool

-- | A list of the number of integer bits (8, 16, ...)
intBits :: [Integer]

-- | The bounds on the range of values a integer or natural type can take.
typeBounds :: Typ -> (Integer, Integer)

-- | Boolean type test.
isBooleanType :: Typ -> Bool

-- | Integer type test.
isIntegerType :: Typ -> Bool

-- | Natural number type test.
isNaturalType :: Typ -> Bool

-- | Real number type test.
isRealType :: Typ -> Bool

-- | Character type test.
isCharType :: Typ -> Bool
isInTypeNames :: [ClassName] -> Typ -> Bool

-- | List of integer type names (ie, INTEGER_32).
integerTypeNames :: [Text]

-- | List of integer type names (ie, NATURAL_32).
naturalTypeNames :: [Text]

-- | List of integer type names (ie, REAL_64).
realTypeNames :: [Text]

-- | List of integer type names (ie, CHARACTER_8).
charTypeNames :: [Text]

-- | Given a type give the name of the class as a string.
classNameType :: Typ -> Text

-- | The default integer type.
intType :: Typ

-- | The default boolean type.
boolType :: Typ

-- | The default real number type.
realType :: Typ

-- | The default character type.
charType :: Typ

-- | The default string type.
stringType :: Typ

-- | The top type, ANY.
anyType :: Typ

-- | Construct a simple type from a classname.
namedType :: ClassName -> Typ

-- | Insert a declaration into a string-type map.
insertDecl :: Decl -> Map Text Typ -> Map Text Typ

-- | Turn a list of declarations into a string-type map.
declsToMap :: [Decl] -> Map Text Typ

-- | Given a processor declaration, extract the processor.
newVar :: ProcDecl -> Proc
instance ClassFeature (FeatureEx expr) body expr
instance ClassFeature (Attribute expr) body expr
instance ClassFeature (AbsRoutine body expr) body expr
instance ClassFeature (Constant expr) body expr
instance Feature (Constant expr) expr
instance Feature (Attribute expr) expr
instance Feature (AbsRoutine body expr) expr
instance Feature (SomeFeature body expr) expr
instance Feature (FeatureEx expr) expr

module Language.Eiffel.Parser
newError :: SourceName -> String -> ParseError
lexThenParse :: Parser a -> String -> Text -> Either ParseError a
lexThenParseFromFile :: Parser a -> String -> IO (Either ParseError a)
countTokens :: String -> IO (Int)
parseStmt :: Text -> Either ParseError Stmt
parseClass :: Text -> Either ParseError Clas
parseInterface :: Text -> Either ParseError ClasInterface
parseClass' :: Text -> Clas
parseFromName :: ClassName -> IO Clas
classNameFile :: ClassName -> String
parseClassFile :: String -> IO (Either ParseError Clas)

module Language.Eiffel.PrettyPrint
ttext :: Text -> Doc
defaultIndent :: Int
nestDef :: Doc -> Doc
renderWithTabs :: Doc -> String
newline :: Doc
emptyLine :: Doc
ups :: Text -> Text
toDoc :: Clas -> Doc
toInterfaceDoc :: ClasInterface -> Doc
interfaceBodyDoc :: EmptyBody -> Doc
toDocWith :: Ord body => Bool -> (body -> Doc) -> AbsClas body Expr -> Doc
inheritance :: [Inheritance] -> Doc
inheritanceClauses :: Inheritance -> Doc
inheritClause :: InheritClause -> Doc
createClause :: CreateClause -> Doc
convertClause :: [ConvertClause] -> Doc
featureClauses :: Ord body => Bool -> (body -> Doc) -> FeatureMap body Expr -> [Doc]
vsep :: [Doc] -> Doc
commaSep :: [Doc] -> Doc
vCommaSep :: [Doc] -> Doc
angles :: Doc -> Doc
langle :: Doc
rangle :: Doc
squareQuotes :: Doc -> Doc
anyStringLiteral :: Text -> Doc
stringLiteral :: Text -> Doc
procDoc :: Proc -> Doc
genericsDoc :: [Generic] -> Doc
notes :: [Note] -> Doc
note :: Note -> Doc
invars :: [Clause Expr] -> Doc
procGenDoc :: [Proc] -> Doc
decl :: Decl -> Doc
typeDoc :: Typ -> Doc
frozen :: Bool -> Doc
require :: Contract Expr -> Doc
ensure :: Contract Expr -> Doc
constDoc :: Constant Expr -> Doc
attrDoc :: Bool -> Attribute Expr -> Doc
type' :: Typ -> Doc
routineDoc :: (body -> Doc) -> AbsRoutine body Expr -> Doc
routineBodyDoc :: RoutineBody Expr -> Doc
locals :: RoutineBody exp -> Doc
procExprs :: AbsRoutine body exp -> Doc
($?$) :: Doc -> Doc -> Doc
(<?>) :: Doc -> Doc -> Doc
clausesDoc :: [Clause Expr] -> Doc
clause :: Clause Expr -> Doc
stmt :: Stmt -> Doc
stmt' :: AbsStmt Expr -> Doc
expr :: Expr -> Doc
exprPrec :: Int -> Expr -> Doc
expr' :: Int -> UnPosExpr -> Doc
quant :: Quant -> Doc
condParens :: Bool -> Doc -> Doc
unop :: IsString a => UnOp -> a
opList :: [(BinOp, (Text, Int))]
binop :: BinOp -> (Text, Int)
relop :: IsString a => ROp -> a
actArgs :: [Expr] -> Doc
formArgs :: [Decl] -> Doc
genDoc :: [Typ] -> Doc
procExprD :: ProcExpr -> Doc
locks :: [Proc] -> Doc
procs :: [Proc] -> Doc
proc :: Proc -> Doc
procM :: Maybe Proc -> Doc
sepDoc :: Doc
instance Hashable a => Hashable (Set a)

module Language.Eiffel.Summary
summaryP :: Parser [ClasInterface]
parseSummary :: String -> IO (Either ParseError [ClasInterface])
writeSummary :: FilePath -> [ClasInterface] -> IO ()
readBinarySummary :: String -> IO [ClasInterface]
writeBinarySummary :: String -> [ClasInterface] -> IO ()
