-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Solve simple simultaneous equations
--   
--   Solve a number of equations simultaneously. This is not Computer
--   Algebra, better think of a kind of type inference algorithm or logic
--   programming with only one allowed solution.
--   
--   Only one solution is computed. Simultaneous equations with multiple
--   solutions are not allowed. However, variables may remain undefined. We
--   do not even check for consistency, since with floating point numbers
--   even simple rules may not be consistent.
--   
--   The modules ordered with respect to abstraction level are:
--   
--   <ul>
--   <li><a>UniqueLogic.ST.System</a>: Construct and solve sets of
--   functional dependencies. Example: <tt>assignment3 (+) a b c</tt>
--   meaning dependency <tt>a+b -&gt; c</tt>.</li>
--   <li><a>UniqueLogic.ST.Rule</a>: Combine functional dependencies to
--   rules that can apply in multiple directions. Example: <tt>add a b
--   c</tt> means relation <tt>a+b = c</tt> which resolves to dependencies
--   <tt>a+b -&gt; c, c-a -&gt; b, c-b -&gt; a</tt>. For an executable
--   example see <a>UniqueLogic.ST.Example.Rule</a>.</li>
--   <li><a>UniqueLogic.ST.Expression</a>: Allows to write rules using
--   arithmetic operators. It creates temporary variables automatically.
--   Example: <tt>(a+b)*c =:= d</tt> resolves to <tt>a+b = x, x*c = d</tt>.
--   For an executable example see
--   <a>UniqueLogic.ST.Example.Expression</a>.</li>
--   <li><a>UniqueLogic.ST.SystemLabel</a>: Provides a new type for named
--   variables. When creating a variable you decide whether and how an
--   assignment to this variable shall be logged. There is an example that
--   shows how to solve a logic system using symbolic expressions. The
--   naming and logging allows us to observe shared intermediate results.
--   For an executable example see
--   <a>UniqueLogic.ST.Example.Label</a>.</li>
--   <li><a>UniqueLogic.ST.SystemLog</a>, <a>UniqueLogic.ST.RuleLog</a>:
--   These modules allow to log an assignment depending on the arguments to
--   an assignment. This is more general than
--   <a>UniqueLogic.ST.SystemLabel</a> which allows only dependencies on
--   the result of an assignment.</li>
--   </ul>
@package unique-logic
@version 0.3

module UniqueLogic.ST.SystemLog
data Variable w s a
globalVariable :: ST s (Variable w s a)
data T w s a
localVariable :: T w s (Variable w s a)
constant :: a -> T w s (Variable w s a)
assignment2 :: Monoid w => (a -> Writer w b) -> Variable w s a -> Variable w s b -> T w s ()
assignment3 :: Monoid w => (a -> b -> Writer w c) -> Variable w s a -> Variable w s b -> Variable w s c -> T w s ()
data Apply w s a

-- | This function allows to generalize <a>assignment2</a> and
--   <a>assignment3</a> to more arguments. You could achieve the same with
--   nested applications of <tt>assignment3 (,)</tt>.
arg :: Monoid w => Variable w s a -> Apply w s a
runApply :: Monoid w => Apply w s (Writer w a) -> Variable w s a -> T w s ()
solve :: Monoid w => T w s a -> WriterT w (ST s) a
query :: Variable w s a -> ST s (Maybe a)
instance Monoid w => Applicative (Apply w s)
instance Monoid w => Functor (Apply w s)
instance Monad (T w s)
instance Applicative (T w s)
instance Functor (T w s)

module UniqueLogic.ST.RuleLog
generic2 :: Monoid w => (b -> Writer w a) -> (a -> Writer w b) -> Variable w s a -> Variable w s b -> T w s ()
generic3 :: Monoid w => (b -> c -> Writer w a) -> (c -> a -> Writer w b) -> (a -> b -> Writer w c) -> Variable w s a -> Variable w s b -> Variable w s c -> T w s ()

module UniqueLogic.ST.System
class Var var
plainVariable :: Var var => var w s a -> Variable w s a
runApply :: (Var var, Monoid w) => Apply w s a -> var w s a -> T w s ()
constant :: (Var var, Monoid w) => a -> T w s (var w s a)
localVariable :: (Var var, Monoid w) => T w s (var w s a)
data Variable w s a
globalVariable :: ST s (Variable w s a)
data T w s a
assignment2 :: (Var var, Monoid w) => (a -> b) -> var w s a -> var w s b -> T w s ()
assignment3 :: (Var var, Monoid w) => (a -> b -> c) -> var w s a -> var w s b -> var w s c -> T w s ()
data Apply w s a
arg :: (Var var, Monoid w) => var w s a -> Apply w s a
solve :: T () s a -> ST s a
query :: (Var var, Monoid w) => var w s a -> ST s (Maybe a)
instance Var Variable

module UniqueLogic.ST.SystemLabel
data Variable w s a
globalVariable :: (a -> Writer w a) -> ST s (Variable w s a)
data T w s a
localVariable :: (Var var, Monoid w) => T w s (var w s a)
constant :: (Var var, Monoid w) => a -> T w s (var w s a)
assignment2 :: (Var var, Monoid w) => (a -> b) -> var w s a -> var w s b -> T w s ()
assignment3 :: (Var var, Monoid w) => (a -> b -> c) -> var w s a -> var w s b -> var w s c -> T w s ()
data Apply w s a
arg :: (Var var, Monoid w) => var w s a -> Apply w s a
runApply :: (Var var, Monoid w) => Apply w s a -> var w s a -> T w s ()
solve :: Monoid w => T w s a -> WriterT w (ST s) a
query :: (Var var, Monoid w) => var w s a -> ST s (Maybe a)
instance Var Variable

module UniqueLogic.ST.Rule
generic2 :: (Var var, Monoid w) => (b -> a) -> (a -> b) -> var w s a -> var w s b -> T w s ()
generic3 :: (Var var, Monoid w) => (b -> c -> a) -> (c -> a -> b) -> (a -> b -> c) -> var w s a -> var w s b -> var w s c -> T w s ()
equ :: (Var var, Monoid w) => var w s a -> var w s a -> T w s ()

-- | You might be tempted to use the <a>pair</a> rule to collect parameters
--   for rules with more than three arguments. This is generally not a good
--   idea since this way you lose granularity. For building rules with more
--   than three arguments, please build according assignments with
--   <a>arg</a> and <a>runApply</a> and bundle these assignments to rules.
--   This is the way, <a>generic2</a> and <a>generic3</a> work.
pair :: (Var var, Monoid w) => var w s a -> var w s b -> var w s (a, b) -> T w s ()
max :: (Ord a, Var var, Monoid w) => var w s a -> var w s a -> var w s a -> T w s ()
add :: (Num a, Var var, Monoid w) => var w s a -> var w s a -> var w s a -> T w s ()
mul :: (Fractional a, Var var, Monoid w) => var w s a -> var w s a -> var w s a -> T w s ()
square :: (Floating a, Var var, Monoid w) => var w s a -> var w s a -> T w s ()
pow :: (Floating a, Var var, Monoid w) => var w s a -> var w s a -> var w s a -> T w s ()

module UniqueLogic.ST.Expression

-- | An expression is defined by a set of equations and the variable at the
--   top-level. The value of the expression equals the value of the top
--   variable.
data T var w s a

-- | Make a constant expression of a simple numeric value.
constant :: (Var var, Monoid w) => a -> T var w s a
fromVariable :: var w s a -> T var w s a
fromRule1 :: (Var var, Monoid w) => (var w s a -> T w s ()) -> (T var w s a)
fromRule2 :: (Var var, Monoid w) => (var w s a -> var w s b -> T w s ()) -> (T var w s a -> T var w s b)
fromRule3 :: (Var var, Monoid w) => (var w s a -> var w s b -> var w s c -> T w s ()) -> (T var w s a -> T var w s b -> T var w s c)
data Apply w s f

-- | This function allows to generalize <a>fromRule2</a> and
--   <a>fromRule3</a> to more arguments using <a>Applicative</a>
--   combinators.
--   
--   Example:
--   
--   <pre>
--   fromRule3 rule x y
--      = runApply $ liftA2 rule (arg x) (arg y)
--      = runApply $ pure rule &lt;*&gt; arg x &lt;*&gt; arg y
--   </pre>
--   
--   Building rules with <a>arg</a> provides more granularity than using
--   auxiliary <a>pair</a> rules!
arg :: T var w s a -> Apply w s (var w s a)
runApply :: (Var var, Monoid w) => Apply w s (var w s a -> T w s ()) -> T var w s a
(=:=) :: (Var var, Monoid w) => T var w s a -> T var w s a -> T w s ()
(=!=) :: (Var var, Monoid w) => T var w s a -> T var w s a -> T var w s a
sqr :: (Floating a, Var var, Monoid w) => T var w s a -> T var w s a
sqrt :: (Floating a, Var var, Monoid w) => T var w s a -> T var w s a

-- | We are not able to implement a full Ord instance including Eq
--   superclass and comparisons, but we need to compute maxima.
max :: (Ord a, Var var, Monoid w) => T var w s a -> T var w s a -> T var w s a
maximum :: (Ord a, Var var, Monoid w) => [T var w s a] -> T var w s a

-- | Construct or decompose a pair.
pair :: (Var var, Monoid w) => T var w s a -> T var w s b -> T var w s (a, b)
instance (Fractional a, Var var, Monoid w) => Fractional (T var w s a)
instance (Fractional a, Var var, Monoid w) => Num (T var w s a)
instance Applicative (Apply w s)
instance Functor (Apply w s)


-- | <i>Deprecated: This module is intended for documentation purposes. Do
--   not import it! </i>
module UniqueLogic.ST.Example.Label
data Assign
Assign :: Name -> Term -> Assign
type Assigns = [Assign]
data Term
Const :: Rational -> Term
Var :: Name -> Term
Max :: Term -> Term -> Term
Add :: Term -> Term -> Term
Sub :: Term -> Term -> Term
Mul :: Term -> Term -> Term
Div :: Term -> Term -> Term
Abs :: Term -> Term
Signum :: Term -> Term
type Name = String
globalVariable :: Name -> ST s (Variable Assigns s Term)
constant :: Rational -> T Assigns s (Variable Assigns s Term)

-- | <pre>
--   x=1
--   y=2
--   z=3
--   </pre>
--   
--   <pre>
--   x+y=3
--   y*z=6
--   z=3
--   </pre>
rule :: ((Maybe Term, Maybe Term, Maybe Term), Assigns)
expression :: ((Maybe Term, Maybe Term), Assigns)
instance Show Term
instance Show Assign
instance Fractional Term
instance Num Term


-- | <i>Deprecated: This module is intended for documentation purposes. Do
--   not import it! </i>
module UniqueLogic.ST.Example.Rule

-- | <pre>
--   x=1
--   y=2
--   z=3
--   w=3
--   </pre>
--   
--   <pre>
--   x+y=3
--   y*z=6
--   z=3
--   y^w=8
--   </pre>
example :: (Maybe Double, Maybe Double, Maybe Double, Maybe Double)


-- | <i>Deprecated: This module is intended for documentation purposes. Do
--   not import it! </i>
module UniqueLogic.ST.Example.Expression
example :: (Maybe Double, Maybe Double)
