-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Base library for bioinformatics
--   
--   Base library for bioinformatics providing the following features:
--   
--   <ul>
--   <li>RNA primary and secondary structure</li>
--   <li>Infernal covariance models</li>
--   <li>Turner and Vienna energy files</li>
--   </ul>
--   
--   RNA sequences and energy files:
--   
--   <ul>
--   <li>efficient format for RNA sequences, based on the vector
--   package</li>
--   <li>import from strings, bytestrings, fasta files (using the bio
--   library)</li>
--   <li>secondary structure manipulation functions, im- and export of
--   Vienna-dotbracket notation</li>
--   <li>import Turner energy files</li>
--   <li>cf. http:<i></i>rna.urmc.rochester.edu<i>NNDB</i>index.html</li>
--   <li>im- and export of Vienna 2.0 energy files</li>
--   </ul>
--   
--   Covariance models:
--   
--   <ul>
--   <li>import covariance models</li>
--   <li>basic manipulation of covariance models</li>
--   <li>Stockholm file format manipulation</li>
--   </ul>
--   
--   Utility classes:
--   
--   <ul>
--   <li>algebraic ring class</li>
--   <li>instances for Gibbs free energy, partition function probabilities,
--   and scores</li>
--   <li>conversion between different entities</li>
--   <li>ready for the vector library</li>
--   </ul>
@package Biobase
@version 0.1.0.1


-- | Algebraic ring structure. Very similar to others found throughout
--   hackage.
--   
--   TODO maybe use on of the already-written packages?
module Biobase.Types.Ring

-- | Define the basic operations on a ring.
class (Eq a, Ord a) => Ring a
(.+.) :: Ring a => a -> a -> a
(.*.) :: Ring a => a -> a -> a
(.^.) :: Ring a => a -> Int -> a
(.^^.) :: Ring a => a -> Double -> a
neg :: Ring a => a -> a
one :: Ring a => a
zero :: Ring a => a
isZero :: Ring a => a -> Bool

module Biobase.Types.Energy

-- | Some default instances. Left out the Num one, so that you have to
--   explicitly instanciate if you want to go around the Ring structure.
newtype Energy
Energy :: Int -> Energy
unEnergy :: Energy -> Int
instance Prim Energy
instance Unbox Energy
instance Vector Vector Energy
instance MVector MVector Energy
instance Show Energy
instance Read Energy
instance Eq Energy
instance Ord Energy
instance Ring Energy

module Biobase.Types.Score

-- | Some default instances. Left out the Num one, so that you have to
--   explicitly instanciate if you want to go around the Ring structure.
newtype Score
Score :: Int -> Score
unScore :: Score -> Int
instance Prim Score
instance Unbox Score
instance Vector Vector Score
instance MVector MVector Score
instance Show Score
instance Read Score
instance Eq Score
instance Ord Score
instance Ring Score

module Biobase.Types.Partition

-- | Some default instances. Left out the Num one, so that you have to
--   explicitly instanciate if you want to go around the Ring structure.
newtype Partition
Partition :: Double -> Partition
unPartition' :: Partition -> Double
mkPartition :: Double -> Partition
unPartition :: Partition -> Double
logSum :: Double -> Double -> Double
log1p :: Double -> Double
expm1 :: Double -> Double
instance Prim Partition
instance Unbox Partition
instance Vector Vector Partition
instance MVector MVector Partition
instance Show Partition
instance Read Partition
instance Eq Partition
instance Ord Partition
instance Ring Partition


-- | Provides a converting function between different types. Most useful
--   conversions are instanced here.
module Biobase.Types.Convert

-- | How to convert between different values.
class Convert a b c
convert :: Convert a b c => a -> b -> c

-- | From (Gibbs free) energy to partition function values.
--   
--   TODO temperature is running around here: move to some library later on
newtype Kelvin
Kelvin :: Double -> Kelvin
unKelvin :: Kelvin -> Double
instance Convert Kelvin Energy Partition


-- | Turner Nearest Neighbor Energy Tables}
module Biobase.Turner.Tables

-- | A data structure describing all fields as used by the Turner 2004
--   parameter set. Some fields are commented out until they are being
--   used.
data Turner2004 a b c
Turner2004 :: PrimArray (a, a) c -> PrimArray (a, b) c -> PrimArray (a, b) c -> PrimArray Int c -> PrimArray (a, b, b) c -> Map [b] c -> PrimArray Int c -> PrimArray (a, a, b, b) c -> PrimArray (a, a, b, b, b) c -> PrimArray (a, a, b, b, b, b) c -> PrimArray (a, b, b) c -> PrimArray (a, b, b) c -> PrimArray (a, b, b) c -> PrimArray Int c -> PrimArray (a, b, b) c -> c -> c -> c -> c -> c -> PrimArray (a, b, b) c -> Double -> c -> c -> Turner2004 a b c
stack :: Turner2004 a b c -> PrimArray (a, a) c
dangle3 :: Turner2004 a b c -> PrimArray (a, b) c
dangle5 :: Turner2004 a b c -> PrimArray (a, b) c
hairpinL :: Turner2004 a b c -> PrimArray Int c
hairpinMM :: Turner2004 a b c -> PrimArray (a, b, b) c
hairpinLookup :: Turner2004 a b c -> Map [b] c
bulgeL :: Turner2004 a b c -> PrimArray Int c
iloop1x1 :: Turner2004 a b c -> PrimArray (a, a, b, b) c
iloop1x2 :: Turner2004 a b c -> PrimArray (a, a, b, b, b) c
iloop2x2 :: Turner2004 a b c -> PrimArray (a, a, b, b, b, b) c
iloopMM :: Turner2004 a b c -> PrimArray (a, b, b) c
iloop2x3MM :: Turner2004 a b c -> PrimArray (a, b, b) c
iloop1xnMM :: Turner2004 a b c -> PrimArray (a, b, b) c
iloopL :: Turner2004 a b c -> PrimArray Int c
multiMM :: Turner2004 a b c -> PrimArray (a, b, b) c
ninio :: Turner2004 a b c -> c
maxNinio :: Turner2004 a b c -> c
multiOffset :: Turner2004 a b c -> c
multiNuc :: Turner2004 a b c -> c
multiHelix :: Turner2004 a b c -> c
extMM :: Turner2004 a b c -> PrimArray (a, b, b) c
largeLoop :: Turner2004 a b c -> Double
termAU :: Turner2004 a b c -> c
intermolecularInit :: Turner2004 a b c -> c


-- | The beginnings of a Stockholm File parser.
module Biobase.Infernal.Stockholm

-- | Stockholm format data. We have a set of sequences with sequence data,
--   a set of column annotations and unknown data (actually: known, but we
--   do not care).
data Stockholm
Stockholm :: [(String, String)] -> [(String, String)] -> [(String, String)] -> [String] -> Stockholm
sequences :: Stockholm -> [(String, String)]
colAnnotations :: Stockholm -> [(String, String)]
exAnnotations :: Stockholm -> [(String, String)]
unknown :: Stockholm -> [String]
instance Show Stockholm


-- | A simple parser for Stockholm data. As we do not interpret most stuff
--   right now, Parsec is not required.
module Biobase.Infernal.Stockholm.Import
fromFile :: String -> IO Stockholm


-- | Encodings for nucleotides and pairs. Currently very ViennaRNA-centric.
--   This might change over time.
--   
--   TODO do not export Nucleotide ctor?
--   
--   TODO consider adding <a>nucAmpersand</a> as a chain seperator. This
--   could make some things easier.
module Biobase.RNA
newtype Nucleotide
Nucleotide :: Int -> Nucleotide
nucCharList :: [(Int, Char)]
charNucList :: [(Char, Int)]
charToNucleotide :: Char -> Nucleotide

-- | Since this function is used rather often.
nucleotideToChar :: Nucleotide -> Char
type Primary = PrimArray Int Nucleotide
class MkPrimary a
mkPrimary :: MkPrimary a => a -> Primary
unPrimary :: MkPrimary a => Primary -> a
newtype ViennaPair
ViennaPair :: Int -> ViennaPair
vpStrList :: [(Int, String)]
strVpList :: [(String, Int)]
toPair :: Nucleotide -> Nucleotide -> ViennaPair
pairs :: Nucleotide -> Nucleotide -> Bool
instance Prim ViennaPair
instance Unbox ViennaPair
instance Vector Vector ViennaPair
instance MVector MVector ViennaPair
instance Unbox Nucleotide
instance Vector Vector Nucleotide
instance MVector MVector Nucleotide
instance Prim Nucleotide
instance Eq ViennaPair
instance Ord ViennaPair
instance Ix ViennaPair
instance Eq Nucleotide
instance Ord Nucleotide
instance Ix Nucleotide
instance Read ViennaPair
instance Show ViennaPair
instance Bounded ViennaPair
instance Enum ViennaPair
instance MkPrimary (Vector Char)
instance MkPrimary String
instance Read Primary
instance Show Primary
instance Eq Primary
instance Read Nucleotide
instance Show Nucleotide
instance Bounded Nucleotide
instance Enum Nucleotide

module Biobase.Structure

-- | A complex of one or more primary and secondary structures
data Complex
Complex :: String -> [(Primary, Secondary)] -> Complex
comments :: Complex -> String
structures :: Complex -> [(Primary, Secondary)]

-- | A secondary structure. It is explicit that we store the length of the
--   sequence. (length n, last index (n-1) problem)
data Secondary
Secondary :: Int -> [(Int, Int)] -> Secondary
len :: Secondary -> Int
pairings :: Secondary -> [(Int, Int)]

-- | secondary structure representation using an explicit tree, SSExt
--   encodes the length of the underlying sequence. Each node can contain
--   additional information under <tt>a</tt>.
data SSTree a
SSTree :: Int -> Int -> a -> [SSTree a] -> SSTree a
SSExt :: Int -> a -> [SSTree a] -> SSTree a

-- | generate an SSTree from a secondary structure
toSSTree :: Secondary -> SSTree ()
instance Read a => Read (SSTree a)
instance Show a => Show (SSTree a)
instance Eq a => Eq (SSTree a)
instance Show Secondary
instance Show Complex

module Biobase.Structure.DotBracket

-- | Given the secondary structure notation, generate the dot-bracket
--   string.
dotbracket :: Secondary -> String

-- | transforms a pseudoknot-free dotbracket string into a pairlist
dotbracketToPairlist :: String -> Secondary

module Biobase.Structure.Shapes

-- | given an SSTree, return the shape representation
toShape5 :: SSTree a -> String
toShape4 :: SSTree a -> String
toShape3 :: SSTree a -> String
toShape2 :: SSTree a -> String
toShape1 :: SSTree a -> String
toShape :: Int -> SSTree a -> String


-- | Mathews / Turner nearest neighbor energy tables for interactions
--   between RNA-RNA and DNA-DNA. Using lazy tables for easy filling of
--   missing data. Transform tables into uvectors for efficient access.
module Biobase.Turner

-- | Data structure containing all necessary tables for the Turner 2004
--   model. Note the temperature, using an additional function, rescaling
--   becomes possible. A Show and a Read instance are automatically derived
--   but one should use the Turner and<i>or Vienna import</i>export
--   facilities. All data uses complete tables, where any base can pair
--   with any other. Missing data (<a>.</a> in tables) is given by
--   <a>Nothing</a>, otherwise we have 'Just Int'.
--   
--   In general, have a look here:
--   url{http:<i></i>rna.urmc.rochester.edu<i>NNDB</i>turner04/index.html}
--   where parameters are explained.
--   
--   Conversion from Turner to Vienna is only possible in one direction as
--   a number of parameters are not used in Vienna RNA Folding.
type TurnerTables = Turner2004 Basepair Nucleotide Double
type TurnerEntropy = TurnerTables
type TurnerEnthalpy = TurnerTables
type Temperature = Double
type TurnerSet = (Temperature, TurnerEntropy, TurnerEnthalpy)
type Basepair = (Nucleotide, Nucleotide)


-- | Turner file parser. Returns a Turner2004 data structure. We store data
--   in the same way it is stored in the ViennaRNA package. Pairs are
--   tuples however.
--   
--   How is <a>stack</a> data stored:
--   
--   AX UY -&gt; ((A,U),(Y,X))
--   
--   How <a>iloop1x1</a> is stored:
--   
--   X A G U C -&gt; ((A,U),(C,G),X,Y) Y
--   
--   Now <a>iloop1x2</a> is stored:
--   
--   X A G U C -&gt; ((A,U),(C,G),X,C,Y), single (X) first, then 5' to 3'
--   YC
--   
--   <a>iloop2x2</a> is stored:
--   
--   XY A G U C -&gt; ((A,U),(C,G),X,Y,y,x), X--&gt;Y then x&lt;--y xy
--   
--   TODO not sure if dangle3/dangle5 are correctly split or if they should
--   switch
module Biobase.Turner.Import
parseTurner :: [Char] -> [Char] -> [Char] -> IO (Turner2004 (Nucleotide, Nucleotide) Nucleotide Double)

module Biobase.Infernal.CM

-- | A complete covariance model. Each node and each state can be tagged
--   with additional data. Typically, say after parsing, the tag will be
--   ().
data CM n s
CM :: Array Int (Node n) -> Array Int (State s) -> [(String, String)] -> Array Int Double -> Array Int Double -> CMType -> Array Nucleotide Double -> CM n s
nodes :: CM n s -> Array Int (Node n)
states :: CM n s -> Array Int (State s)
header :: CM n s -> [(String, String)]
localBegin :: CM n s -> Array Int Double
localEnd :: CM n s -> Array Int Double
cmType :: CM n s -> CMType
nullModel :: CM n s -> Array Nucleotide Double

-- | Describes one node
data Node n
Node :: Int -> NodeType -> [Int] -> [Int] -> [Int] -> n -> Node n
nid :: Node n -> Int
ntype :: Node n -> NodeType
nparents :: Node n -> [Int]
nchildren :: Node n -> [Int]
nstates :: Node n -> [Int]
ntag :: Node n -> n

-- | One state
data State s
State :: Int -> StateType -> Int -> [Int] -> [Transition] -> [Emission] -> s -> State s
sid :: State s -> Int
stype :: State s -> StateType
snode :: State s -> Int
sparents :: State s -> [Int]
schildren :: State s -> [Transition]
semission :: State s -> [Emission]
stag :: State s -> s

-- | CMType is important if we want to set localBegin / localEnd!
data CMType
CMProb :: CMType
CMScore :: CMType

-- | can emit either one nucleotide or a pair
data Emission
EmitS :: Nucleotide -> Double -> Emission
eNuc :: Emission -> Nucleotide
escore :: Emission -> Double
EmitP :: Nucleotide -> Nucleotide -> Double -> Emission
eNucL :: Emission -> Nucleotide
eNucR :: Emission -> Nucleotide
escore :: Emission -> Double

-- | branches are transition without attached probability becaue both
--   branches are always taken
data Transition
Branch :: Int -> Transition
tchild :: Transition -> Int
Transition :: Int -> Double -> Transition
tchild :: Transition -> Int
tscore :: Transition -> Double

-- | the different node types
data NodeType
MATP :: NodeType
MATL :: NodeType
MATR :: NodeType
BIF :: NodeType
ROOT :: NodeType
BEGL :: NodeType
BEGR :: NodeType
END :: NodeType

-- | the different state types
data StateType
MP :: StateType
IL :: StateType
IR :: StateType
D :: StateType
ML :: StateType
MR :: StateType
B :: StateType
S :: StateType
E :: StateType

-- | generate a local model with local begin prob and local end prob
cmMakeLocal :: Double -> Double -> CM n s -> CM n s
cmMakeLocalBegin :: Double -> CM n s -> CM n s
cmMakeLocalEnd :: Double -> CM n s -> CM n s

-- | given a CM in score mode, change it to probability mode
cmScore2Prob :: CM n s -> CM n s

-- | Given a CM in prob mode, change to score mode
cmProb2Score :: CM n s -> CM n s

-- | normalize all PROBabilities in a CM
cmNormalizeProbabilities :: CM n s -> CM n s
statesScore2Prob :: CM n s -> Array Int (State s) -> Array Int (State s)
localBeginScore2Prob :: Array Int Double -> Array Int Double
localEndScore2Prob :: Array Int Double -> Array Int Double
statesProb2Score :: CM n s -> Array Int (State s) -> Array Int (State s)
localBeginProb2Score :: Array Int Double -> Array Int Double
localEndProb2Score :: Array Int Double -> Array Int Double

-- | extract the main state for each node (eg MP state for MATP node)
nodeMainState :: CM n s -> Node n -> State s

-- | Checks for each node, if it can be target of a local begin.
localBeginPossible :: CM n s -> Node n -> Bool

-- | Checks for each node if it can lead to a local end.
localEndPossible :: CM n s -> Node n -> Bool

-- | transform scores into probabilities, given a nullmodel for x
--   
--   back into scores
--   
--   Transform a state, setting probabilities instead of scores. Requires
--   CM knowledge for background model.
stateScore2Prob :: CM n s -> State s -> State s

-- | Transform a state, setting scores instead of probabilities.
stateProb2Score :: CM n s -> State s -> State s
transitionTargets :: [Transition] -> [Int]
nodeMainStateAssocs :: [(NodeType, StateType)]
instance Read StateType
instance Show StateType
instance Eq StateType
instance Ord StateType
instance Enum StateType
instance Bounded StateType
instance Read NodeType
instance Show NodeType
instance Eq NodeType
instance Ord NodeType
instance Enum NodeType
instance Bounded NodeType
instance Show Transition
instance Show Emission
instance Show CMType
instance Eq CMType
instance Show s => Show (State s)
instance Show n => Show (Node n)
instance (Show n, Show s) => Show (CM n s)

module Biobase.Infernal.CM.Import
fromFile :: String -> IO (Either ParseError [CM () ()])
fromString :: [Char] -> Either ParseError [CM () ()]


-- | write an Infernal model. We aim for version 1.0.2 of Infernal but
--   right now, there is no explicit version management! We just return
--   header information as we read it. So we are compatible to all versions
--   that can be parsed but have no safeguards in place.
--   
--   NOTE: exported model can apparently be calibrated.
--   
--   TODO make sure that (Export.toString . Import.fromString == id); the
--   other way around is not absolutely necessary (except if the Infernal
--   parser should require this at some point)
--   
--   TODO put functions like stringS into another module?
module Biobase.Infernal.CM.Export

-- | Main export function for CMs. Creates a string that is accepted by
--   Infernal
toString :: CM n s -> String

-- | export a specific node, used by <a>toString</a>
nodeToString :: CM n s -> Node n -> [String]

-- | export a specific states, used by <a>nodeToString</a>
stateToString :: CM n s -> State s -> String


-- | Define several constants used throughout all libraries depending on
--   Biobase.
module Biobase.Constants

-- | maxBound on Int is problematic, if we try something like maxBound +
--   maxBound which happens very often. <a>eInf</a> is used for settings
--   like lookup tables, etc while comparisons are against <a>eMax</a>.
--   Both values need to be small enough not to overflow in typical
--   situations.
eInf :: Int
eMax :: Int
fInf :: Double


-- | Turner energy data as used in the ViennaRNA package.
--   
--   TODO should use energy type for tables, not int!
module Biobase.Vienna
type ViennaIntTables = Turner2004 ViennaPair Nucleotide Int
type ViennaEnergyTables = Turner2004 ViennaPair Nucleotide Energy
type ViennaPartitionTables = Turner2004 ViennaPair Nucleotide Partition
type Temperature = Double

-- | An empty Turner2004 set, with Vienna-style keys for tables. Unused
--   fields are commented out. Activate them in BiobaseTurner before doing
--   the same here!
emptyTables :: ViennaIntTables

module Biobase.Vienna.Import.ViennaPar

-- | Imports Vienna tables from a given string.
importPar :: String -> (ViennaIntTables, ViennaIntTables)
instance Show Block


-- | Embedding of a default set of parameters. These are encoded in Vienna
--   style and use the Turner2004 set of parameters.
module Biobase.Vienna.Default
turner2004GH :: (Turner2004 ViennaPair Nucleotide Energy, Turner2004 ViennaPair Nucleotide Energy)


-- | Exports the Vienna energy tables as a number of C files (one .c file,
--   a number .h files). For this reason, files are written into a target
--   directory!
module Biobase.Vienna.Export.ViennaC

-- | Export the files required for default values in the ViennaRNA 2.0 C
--   package.
export :: ViennaIntTables -> ViennaIntTables -> Directory -> IO ()

module Biobase.Vienna.Export.ViennaPar
export :: ViennaIntTables -> ViennaIntTables -> String


-- | Import data from a Turner table structure. Those can be imported using
--   the Turner.Import module.
module Biobase.Vienna.Import.Turner

-- | Convert from Turner keys to Vienna keys and all values from Double to
--   Int
fromTurner :: TurnerTables -> ViennaIntTables


-- | This module provides facilities to modify values in the tables and
--   return the modified tables. The main reason for the modules' existence
--   are the <tt>E</tt> nucleotides and <tt>NS</tt> base pairs used by the
--   ViennaRNA package to denote unknown or missing nucleotides. For each
--   table type, we have a small function.
module Biobase.Vienna.Modification.NonStandard

-- | The max operation applied to all relevant tables. (This serves as a
--   pointer, which tables to manipulate).
nonStandardMax :: ViennaEnergyTables -> ViennaEnergyTables


-- | Small module for converting Vienna energy tables to partition function
--   value tables.
--   
--   Temperature scaling should happen on the level of energy tables,
--   followed by conversion here.
--   
--   TODO after the switch to the Energy type, change too, the
--   partitionTables generation
module Biobase.Vienna.Modification.Partition

-- | Create partition tables out of normal energy tables. Note that these
--   values are not normalized. An additional term 1<i>Z(1</i>kt) would be
--   required which is missing until we are done calculating the partition
--   function.
--   
--   All energy contributions are rescaled from dekacals back to kcal/mol.
--   
--   We explicitly set all probabilities =0 where the energy is &gt;= eMax.
partitionTables :: Temperature -> ViennaEnergyTables -> ViennaPartitionTables


-- | Given entropy and enthalpy sets, allow modification of the folding
--   temperature (from the default 37 Celsius)
module Biobase.Vienna.Modification.Temperature
adjustTemperature :: ViennaIntTables -> ViennaIntTables -> Temperature -> ViennaIntTables
