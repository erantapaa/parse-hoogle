-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A compiler front-end generator.
--   
@package BNFC
@version 2.8

module Data.Pair
data Pair a
(:/:) :: a -> a -> Pair a
leftOf :: Pair a -> a
rightOf :: Pair a -> a
instance Show a => Show (Pair a)
instance Applicative Pair
instance Functor Pair

module Algebra.RingUtils
class AbelianGroup a
zero :: AbelianGroup a => a
(+) :: AbelianGroup a => a -> a -> a
class AbelianGroup a => AbelianGroupZ a
isZero :: AbelianGroupZ a => a -> Bool
class AbelianGroupZ a => Ring a
(*) :: Ring a => a -> a -> a
class AbelianGroupZ a => RingP a
mul :: RingP a => Bool -> a -> a -> Pair a
data Pair a
(:/:) :: a -> a -> Pair a
leftOf :: Pair a -> a
rightOf :: Pair a -> a
select :: Bool -> [t] -> Pair [t]
onlyLeft :: [t] -> Pair [t]
onlyRight :: [t] -> Pair [t]
newtype O f g a
O :: f (g a) -> O f g a
fromO :: O f g a -> f (g a)
sum :: AbelianGroup a => [a] -> a
mulDefault :: RingP a => a -> a -> a
instance AbelianGroup (f (g a)) => AbelianGroup (O f g a)
instance AbelianGroupZ (f (g a)) => AbelianGroupZ (O f g a)
instance Show (f (g a)) => Show (O f g a)
instance AbelianGroup Bool
instance Ring Int
instance AbelianGroupZ a => AbelianGroupZ (Pair a)
instance AbelianGroup a => AbelianGroup (Pair a)
instance (Functor f, Functor g) => Functor (O f g)
instance AbelianGroupZ Int
instance AbelianGroup Int

module Data.Matrix.Quad
data Shape
Bin :: Shape -> Shape -> Shape
Leaf :: Shape
data Shape' :: Shape -> *
Bin' :: !Int -> Shape' s -> Shape' s' -> Shape' (Bin s s')
Leaf' :: Shape' Leaf
data SomeShape
S :: Shape' s -> SomeShape
data Mat :: Shape -> Shape -> * -> *
Quad :: !(Mat x1 y1 a) -> !(Mat x2 y1 a) -> !(Mat x1 y2 a) -> !(Mat x2 y2 a) -> Mat (Bin x1 x2) (Bin y1 y2) a
Zero :: Mat x y a
One :: !a -> Mat Leaf Leaf a
Row :: Mat x1 Leaf a -> Mat x2 Leaf a -> Mat (Bin x1 x2) Leaf a
Col :: Mat Leaf y1 a -> Mat Leaf y2 a -> Mat Leaf (Bin y1 y2) a
data Vec :: Shape -> * -> *
Z :: Vec s a
O :: a -> Vec Leaf a
(:!) :: Vec s a -> Vec s' a -> Vec (Bin s s') a
row :: Mat x1 Leaf a -> Mat x2 Leaf a -> Mat (Bin x1 x2) Leaf a
col :: Mat Leaf y1 a -> Mat Leaf y2 a -> Mat Leaf (Bin y1 y2) a
quad :: Mat x1 y1 a -> Mat x2 y1 a -> Mat x1 y2 a -> Mat x2 y2 a -> Mat (Bin x1 x2) (Bin y1 y2) a
one :: AbelianGroupZ a => a -> Mat Leaf Leaf a
(.+.) :: AbelianGroupZ a => Mat x y a -> Mat x y a -> Mat x y a
mult :: RingP a => Bool -> Mat x y a -> Mat z x a -> Mat z y (Pair a)
trav :: AbelianGroupZ a => Mat y x (Pair a) -> Pair (Mat y x a)
q0 :: Mat (Bin x x') (Bin y y') a
closeDisjointP :: RingP a => Bool -> Mat x x a -> Mat y x (Pair a) -> Mat y y a -> Pair (Mat y x a)
showR :: Mat x y a -> String
bin' :: Shape' s -> Shape' s' -> Shape' (Bin s s')
mkShape :: Int -> SomeShape
mkSing :: AbelianGroupZ a => Shape' x -> Shape' y -> a -> Mat x y a
data SomeTri a
T :: Shape' s -> Pair (Mat s s a) -> SomeTri a
type Q a = SomeTri a
mkUpDiag :: AbelianGroupZ a => [a] -> Shape' s -> Mat s s a
close :: RingP a => Bool -> Mat s s (Pair a) -> Pair (Mat s s a)
mkTree :: RingP a => [Pair a] -> SomeTri a
quad' :: Applicative f => f (Mat x1 y1 a) -> f (Mat x2 y1 a) -> f (Mat x1 y2 a) -> f (Mat x2 y2 a) -> f (Mat (Bin x1 x2) (Bin y1 y2) a)
mergein :: RingP a => Bool -> SomeTri a -> Pair a -> SomeTri a -> SomeTri a

-- | A variant of zipWith on vectors
zw :: (AbelianGroup a, AbelianGroup b) => (a -> b -> c) -> Vec y a -> Vec y b -> Vec y c

-- | Lookup in a vector
lk :: AbelianGroup a => Int -> Shape' x -> Vec x a -> a

-- | Linearize a matrix
lin' :: AbelianGroup a => Mat x y a -> Vec y (Vec x a)

-- | Contents of a vector
contents :: Shape' x -> Vec x a -> [(Int, a)]
first :: (t -> t1) -> (t, t2) -> (t1, t2)
second :: (t -> t2) -> (t1, t) -> (t1, t2)
data Path :: Shape -> *
Here :: Path Leaf
Low :: Path s -> Path (Bin s s')
High :: Path s -> Path (Bin s' s)
(<||>) :: Maybe (a, Path x) -> Maybe (a, Path x') -> Maybe (a, Path (Bin x x'))

-- | What is, and where is the rightmost non-zero element on a given line
--   of the matrix?
rightmostOnLine :: Path y -> Mat x y a -> Maybe (a, Path x)

-- | Is this the rightmost path?
isRightmost :: Path x -> Bool
results' :: AbelianGroup a => Mat y y a -> Path y -> [(Path y, a, Path y)]
results :: AbelianGroupZ a => SomeTri a -> [(Int, a, Int)]
leftMost :: Shape' s -> Path s
fromPath :: Shape' y -> Path y -> Int
root' :: AbelianGroup a => Mat x y a -> a
root :: AbelianGroup t => SomeTri t -> t
single :: AbelianGroupZ a => Pair a -> SomeTri a
square2 :: AbelianGroupZ a => Pair a -> SomeTri a
square3 :: RingP a => Bool -> Pair a -> Pair a -> SomeTri a
sz' :: Shape' s -> Int
(|+|) :: [[a]] -> [[a]] -> [[a]]
(-+-) :: [a] -> [a] -> [a]
lin :: AbelianGroup a => Shape' x -> Shape' y -> Mat x y a -> [[a]]
sparse :: AbelianGroup a => Shape' x -> Shape' y -> Mat x y a -> [(Int, Int, a)]
shiftX :: Shape' s -> [(Int, t, t1)] -> [(Int, t, t1)]
shiftY :: Shape' s -> [(t, Int, t1)] -> [(t, Int, t1)]
fingerprint :: AbelianGroupZ t => SomeTri t -> [[Char]]
scatterplot :: AbelianGroup t => SomeTri t -> [Char]
instance AbelianGroup a => AbelianGroup (Vec x a)
instance AbelianGroupZ a => AbelianGroup (Mat x y a)

module Data.Matrix.Class
fingerprint :: (Matrix m, AbelianGroupZ a) => m a -> [[Char]]
(***) :: (t -> t2) -> (t1 -> t3) -> (t, t1) -> (t2, t3)
data Dimension
XD :: Dimension
YD :: Dimension
quad :: (Matrix m, AbelianGroup a) => m a -> m a -> m a -> m a -> m a
nextDim :: Dimension -> Dimension
type Extent = (Int, Int)
ext :: Dimension -> (t, t) -> t
glueExt :: (AbelianGroup t1, AbelianGroup t) => Dimension -> (t, t1) -> (t, t1) -> (t, t1)
splitExt :: Num t => Dimension -> t -> (t, t) -> ((t, t), (t, t))
class Matrix m
at :: (Matrix m, AbelianGroupZ a) => Int -> Int -> m a -> a
extent :: Matrix m => m a -> Extent
singleton :: (Matrix m, AbelianGroupZ a) => a -> m a
glue :: (Matrix m, AbelianGroup a) => Dimension -> m a -> m a -> m a
split :: (Matrix m, AbelianGroupZ a) => Dimension -> Int -> m a -> (m a, m a)
zeroMatrix :: (Matrix m, AbelianGroup a) => Int -> Int -> m a
(<|>) :: (AbelianGroup a, Matrix m) => m a -> m a -> m a
(<->) :: (AbelianGroup a, Matrix m) => m a -> m a -> m a
countColumns :: Matrix m => m a -> Int
countRows :: Matrix m => m a -> Int
chopLastColumn :: (AbelianGroupZ a, Matrix m) => m a -> m a
firstRow :: (AbelianGroupZ a, Matrix m) => m a -> m a
lastColumn :: (AbelianGroupZ a, Matrix m) => m a -> m a
chopLastRow :: (AbelianGroupZ a, Matrix m) => m a -> m a
chopFirstColumn :: (AbelianGroupZ a, Matrix m) => m a -> m a
chopFirstRow :: (AbelianGroupZ a, Matrix m) => m a -> m a
instance Eq Dimension
instance Show Dimension
instance Matrix m => Matrix (O Pair m)

module Parsing.Chart
fingerprint :: AbelianGroupZ t => SomeTri t -> [[Char]]
mkTree2 :: RingP a => Bool -> [Pair a] -> Q a
mkTree :: RingP a => [Pair a] -> Q a
mkTree' :: RingP a => [Pair a] -> Q a
type Set a = [a]
type MT2 a = Q a
genXPM :: [[Char]] -> String
root :: AbelianGroup t => SomeTri t -> t
mergein :: RingP a => Bool -> SomeTri a -> Pair a -> SomeTri a -> SomeTri a
single :: AbelianGroupZ a => Pair a -> SomeTri a
instance AbelianGroupZ (Set a)
instance AbelianGroup (Set a)

module Parsing.TestProgram
type Verbosity = Int
putStrV :: Verbosity -> String -> IO ()
mainTest :: (RingP [(category, Any)], Eq category) => ((category, Any) -> String) -> (Bool -> token -> Pair [(category, Any)]) -> (String -> [token]) -> (token -> (Int, Int)) -> (category -> String) -> (category -> [category]) -> IO ()
pairs :: [t] -> [(t, t)]
resSz :: Num a => (a, t, a) -> a
