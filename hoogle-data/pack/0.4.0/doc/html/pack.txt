-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bidirectional fast ByteString packer/unpacker
--   
@package pack
@version 0.4.0


-- | IEEE-754 parsing, lifted from the cereal package by Christian Marie
--   <a>pingu@ponies.io</a>
--   
--   Implementation is described here:
--   <a>http://stackoverflow.com/questions/6976684/converting-ieee-754-floating-point-in-haskell-word32-64-to-and-from-haskell-float/7002812#7002812</a>
module Data.Pack.IEEE754
wordToDouble :: Word64 -> Double
wordToFloat :: Word32 -> Float
doubleToWord :: Double -> Word64
floatToWord :: Float -> Word32


module Data.Pack.Endianness

-- | 16 bit little endian to host endian.
le16Host :: Word16 -> Word16

-- | 32 bit little endian to host endian.
le32Host :: Word32 -> Word32

-- | 64 bit little endian to host endian.
le64Host :: Word64 -> Word64

-- | 16 bit big endian to host endian.
be16Host :: Word16 -> Word16

-- | 32 bit big endian to host endian.
be32Host :: Word32 -> Word32

-- | 64 bit big endian to host endian.
be64Host :: Word64 -> Word64


module Data.Pack.Packet

-- | A <a>Packer</a> recieves one value to pack and returns one
--   <a>Packet</a> which is used to unpack the value of same type.
type Packer a = a -> Packet String a

-- | Bidirectional packing/unpacking Monad.
newtype Packet e a
Packet :: (ByteString -> Ptr () -> Ptr () -> IO (Ptr (), Either e a), Int -> Int, ByteString -> Ptr () -> Ptr () -> IO (Ptr ())) -> Packet e a
unPacket :: Packet e a -> (ByteString -> Ptr () -> Ptr () -> IO (Ptr (), Either e a), Int -> Int, ByteString -> Ptr () -> Ptr () -> IO (Ptr ()))

-- | Derived from lens package. Bidirectional mapping.
dimapP :: (b -> a) -> (a -> b) -> (a -> Packet e a) -> b -> Packet e b

-- | <a>fixedPacket</a> for Storable types.
simple :: Storable a => Int -> (a -> b) -> (b -> a) -> Packer b

-- | Generate a fixed-length <a>Packer</a>.
fixedPacket :: (ByteString -> Ptr a -> IO a) -> (Ptr a -> a -> IO ()) -> Int -> (a -> b) -> (b -> a) -> Packer b

-- | Generate a variable-length <a>Packer</a>.
asymmPacket :: (ByteString -> IO (Int, Either String a)) -> (Ptr a -> IO ()) -> Int -> Packet String a

-- | Unpackers should not read out of memory, so check the border here.
checkBdr :: Int -> Ptr () -> Ptr () -> IO a -> IO (Either String a)

-- | Get a pointer to the head of given <a>ByteString</a>.
getTop :: ByteString -> IO (Ptr a)
instance Monad (Packet e)
instance Applicative (Packet e)
instance Functor (Packet e)


-- | The pack package provides bidirectional packing and unpacking (aka.
--   (de)serialise) Haskell values to and from strict <a>ByteString</a>s.
--   Both operations are faster than binary and cereal package so that it
--   can be used in performance sensible operations. Bytestring allocation
--   is batched and done before packing any values to avoid performance
--   loss. The pack package does not provide specific typeclasses (it's a
--   good idea, though) to clear out ambiguity of serialisation format.
--   
--   <ul>
--   <li>Migration Sheet from binary, cereal and packer</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>encode, runPacking</tt></i> <a>packing</a> (packer).</li>
--   <li><i><tt>decode, runUnpacking</tt></i> <a>unpacking</a>
--   (packer).</li>
--   <li><i><tt>getWord8, putWord8</tt></i> <a>i8</a> (put value) and
--   <a>u8</a> (put value).</li>
--   <li><i><tt>getWord*, putWord*</tt></i> {i,u}{8,16,32,64}{,b,host} (put
--   value).</li>
--   <li><i><tt>skip</tt></i> <a>unused</a>, or <a>pad</a>.</li>
--   <li><i><tt>isEmpty, bytesRead</tt></i> <a>isFull</a> and
--   <a>getPosition</a>.</li>
--   <li><i><tt>getByteString</tt></i> <a>bytes</a>.</li>
--   <li><i><tt>getLazyByteStringNul</tt></i> <a>cstring</a>.</li>
--   <li><i><tt>getWordhost</tt></i> <a>uptrsize</a> and
--   <a>iptrsize</a>.</li>
--   </ul>
--   
--   <ul>
--   <li>Example</li>
--   </ul>
--   
--   <pre>
--   pactest = do
--     putStrLn . show $ packing i8 100
--     let i8i8i8 ~(v,w,x) = do -- `~` is important!
--           a &lt;- i8 v
--           b &lt;- i8 w
--           c &lt;- i8 x
--           return (a,b,c)
--         {-# INLINE i8i8i8 #-} -- For efficiency
--     putStrLn . show $ packing i8i8i8 (-90,-80,100)
--     putStrLn . show $ unpacking i8i8i8 $ packing i8i8i8 (-90,-80,100)
--   </pre>
--   
--   <ul>
--   <li>Output</li>
--   </ul>
--   
--   <pre>
--   "d"
--   "\166\176d"
--   Right (-90,-80,100)
--   </pre>
module Data.Pack

-- | Pack with a monadic action (<a>Packer</a> a) and return the
--   <a>ByteString</a>.
packing :: (a -> Packet e a) -> a -> ByteString

-- | Unpack a <a>ByteString</a> using a <a>Packer</a>.
unpacking :: (a -> Packet e a) -> ByteString -> Either e a

-- | Prism from lens package.
packet :: Packer a -> Prism' ByteString a

-- | Readme.
pactest :: IO ()

-- | A <a>Packer</a> recieves one value to pack and returns one
--   <a>Packet</a> which is used to unpack the value of same type.
type Packer a = a -> Packet String a

-- | Bidirectional packing/unpacking Monad.
data Packet e a

-- | A <a>Int8</a> <a>Packet</a>.
i8 :: Packer Int8

-- | A <a>Int16</a> <a>Packet</a> serialized in little endian.
i16 :: Packer Int16

-- | A <a>Int32</a> <a>Packet</a> serialized in little endian.
i32 :: Packer Int32

-- | A <a>Int64</a> <a>Packet</a> serialized in little endian.
i64 :: Packer Int64

-- | A <a>Word8</a> <a>Packet</a>.
u8 :: Packer Word8

-- | A <a>Word16</a> <a>Packet</a> serialized in little endian.
u16 :: Packer Word16

-- | A <a>Word32</a> <a>Packet</a> serialized in little endian.
u32 :: Packer Word32

-- | A <a>Word64</a> <a>Packet</a> serialized in little endian.
u64 :: Packer Word64

-- | A <a>Int16</a> <a>Packet</a> serialized in big endian.
i16b :: Packer Int16

-- | A <a>Int32</a> <a>Packet</a> serialized in big endian.
i32b :: Packer Int32

-- | A <a>Int64</a> <a>Packet</a> serialized in big endian.
i64b :: Packer Int64

-- | A <a>Word16</a> <a>Packet</a> serialized in big endian.
u16b :: Packer Word16

-- | A <a>Word32</a> <a>Packet</a> serialized in big endian.
u32b :: Packer Word32

-- | A <a>Word64</a> <a>Packet</a> serialized in big endian.
u64b :: Packer Word64

-- | A <a>Int16</a> <a>Packet</a> in the host endianness.
i16host :: Packer Int16

-- | A <a>Int32</a> <a>Packet</a> in the host endianness.
i32host :: Packer Int32

-- | A <a>Int64</a> <a>Packet</a> in the host endianness.
i64host :: Packer Int64

-- | A host pointer-sized <a>Int</a> <a>Packet</a> in the host endianness.
iptrsize :: Packer Word

-- | A <a>Word16</a> <a>Packet</a> in the host endianness.
u16host :: Packer Word16

-- | A <a>Word32</a> <a>Packet</a> in the host endianness.
u32host :: Packer Word32

-- | A <a>Word64</a> <a>Packet</a> in the host endianness.
u64host :: Packer Word64

-- | A host pointer-sized <a>Word</a> <a>Packet</a> in the host endianness.
uptrsize :: Packer Word

-- | A IEEE754-<a>Float</a> <a>Packet</a> serialized in little endian.
f32 :: Packer Float

-- | A IEEE754-<a>Double</a> <a>Packet</a> serialized in little endian.
f64 :: Packer Double

-- | A IEEE754-<a>Float</a> <a>Packet</a> serialized in big endian.
f32b :: Packer Float

-- | A IEEE754-<a>Double</a> <a>Packet</a> serialized in big endian.
f64b :: Packer Double

-- | A IEEE754-<a>Float</a> <a>Packet</a> in the host endianness.
f32host :: Packer Float

-- | A IEEE754-<a>Double</a> <a>Packet</a> in the host endianness.
f64host :: Packer Double

-- | Slice a number of bytes from the source <a>ByteString</a>. The
--   original block of memory is expected to live for the life of this
--   ByteString.
bytes :: Int -> Packer ByteString

-- | Copy a number of bytes from the source <a>ByteString</a>. Similar to
--   <a>bytes</a> but this allow the original block of memory to go away.
bytesCopy :: Int -> Packer ByteString

-- | <a>bytesWhile</a>, applied to a predicate p, returns the longest
--   prefix (possibly empty) of bytes that satisfy p.
bytesWhile :: (Word8 -> Bool) -> Packer ByteString

-- | <a>bytesUntil</a> slices remaining ByteString at the first occurence
--   of the specified byte. It is more efficient than <a>bytesWhile</a> as
--   it is implemented with memchr(3).
bytesUntil :: Word8 -> Packer ByteString

-- | Variable-length NUL terminated string.
cstring :: Packer ByteString

-- | Fixed-length (possibly) NUL terminated string field. Longer string
--   will be trimmed and shorter one will be padded out with NUL.
varchar :: Int -> Packer ByteString

-- | Constant block of packet. Similar to <tt>unused</tt> but specified
--   ByteString will be used to fill out rather than NUL bytes.
--   Additionally, read content is compared to the value and mismatch is
--   reported.
signature :: ByteString -> Packet String (Maybe ByteString)

-- | Slice the remaining bytes.
remainingBytes :: Packer ByteString

-- | Similar to <a>remainingBytes</a> but copy the remaining bytes.
remainingBytesCopy :: Packer ByteString

-- | A <a>Data.Vector.Generic</a> <a>Packet</a>. Get and put an array of
--   arbitary type of <a>Packet</a>s.
vector :: Vector v a => Packer a -> Int -> Packer (v a)

-- | A <a>Data.Vector.Storable</a> <a>Packet</a>. Read operation is
--   copy-free.
array :: Storable a => Int -> Packer (Vector a)

-- | Similar to <a>array</a> but copy the bytes.
arrayCopy :: Storable a => Int -> Packer (Vector a)

-- | A <a>Storable</a> <a>Packet</a>. Note that <a>Storable</a> must not be
--   used to store variable sized structures.
storable :: Storable a => Packer a

-- | Represent a simple enum field.
enumOf :: (Integral a, Enum b) => Packer a -> Packer b

-- | Derived from lens package. Bidirectional mapping.
dimapP :: (b -> a) -> (a -> b) -> (a -> Packet e a) -> b -> Packet e b

-- | A dirty hack to handle unions.
--   
--   <pre>
--   tag &lt;- i32 (getTagId dat)
--   let getcase tag = case tag of
--     0 -&gt; A &lt;$&gt; i32 undefined
--     1 -&gt; B &lt;$&gt; f32 undefined
--   let putcase dat = case dat of
--     A i -&gt; i32 i
--     B f -&gt; f32 f
--   val &lt;- dicase (getcase tag) (putcase data)
--   </pre>
dicase :: Packet e a -> Packet e' a -> Packet e a

-- | Skip bytes, filling with NUL bytes.
unused :: Int -> Packet String ()

-- | Skip bytes, filling with specified byte.
pad :: Word8 -> Int -> Packet String ()

-- | (Unpacker only) Adjust alignment, filling with NUL bytes.
alignedTo :: Int -> Packet String ()

-- | (Unpacker only) Adjust alignment, filling with specified byte.
alignedWith :: Word8 -> Int -> Packet String ()

-- | (Unpacker only) Get the position in the memory block.
getPosition :: Packet e Int

-- | (Unpacker only) Get the total size of the memory block.
getTotalSize :: Packet e Int

-- | (Unpacker only) Get a number of bytes to go in the memory block.
getRemaining :: Packet e Int

-- | (Unpacker only) Return True if source ByteString is fully consumed or
--   target ByteString is full.
isFull :: Packet e Bool
