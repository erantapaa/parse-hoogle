-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Heterogeneous maps keyed by StableNames
--   
--   Provides an unsafe API for inserting heterogeneous data in a
--   collection keyed by StableNames and for later retrieving it.
@package stable-maps
@version 0.0.4


-- | Dynamic stable names are a way of performing fast (O(1)),
--   not-quite-exact comparison between objects.
--   
--   Dynamic stable names solve the following problem: suppose you want to
--   build a hash table with Haskell objects as keys, but you want to use
--   pointer equality for comparison; maybe because the keys are large and
--   hashing would be slow, or perhaps because the keys are infinite in
--   size. We can't build a hash table using the address of the object as
--   the key, because objects get moved around by the garbage collector,
--   meaning a re-hash would be necessary after every garbage collection.
module System.Mem.StableName.Dynamic

-- | An abstract name for an object, that supports equality and hashing.
--   
--   Dynamic stable names have the following property:
--   
--   <ul>
--   <li>If <tt>sn1 :: DynamicStableName</tt> and <tt>sn2 ::
--   DynamicStableName</tt> and <tt>sn1 == sn2</tt> then <tt>sn1</tt> and
--   <tt>sn2</tt> were created by calls to <tt>makeStableName</tt> on the
--   same object.</li>
--   </ul>
--   
--   The reverse is not necessarily true: if two dynamic stable names are
--   not equal, then the objects they name may still be equal. Note in
--   particular that <a>makeDynamicStableName</a> may return a different
--   <a>DynamicStableName</a> after an object is evaluated.
--   
--   Dynamic Stable Names are similar to Stable Pointers
--   (<a>Foreign.StablePtr</a>), but differ in the following ways:
--   
--   <ul>
--   <li>There is no <tt>freeDynamicStableName</tt> operation, unlike
--   <a>Foreign.StablePtr</a>s. Dynamic Stable Names are reclaimed by the
--   runtime system when they are no longer needed.</li>
--   <li>There is no <tt>deRefDynamicStableName</tt> operation. You can't
--   get back from a dynamic stable name to the original Haskell object.
--   The reason for this is that the existence of a stable name for an
--   object does not guarantee the existence of the object itself; it can
--   still be garbage collected.</li>
--   </ul>
newtype DynamicStableName
DynamicStableName :: (StableName Any) -> DynamicStableName

-- | Convert a <a>DynamicStableName</a> to an <a>Int</a>. The <a>Int</a>
--   returned is not necessarily unique; several <a>DynamicStableName</a>s
--   may map to the same <a>Int</a> (in practice however, the chances of
--   this are small, so the result of <a>hashDynamicStableName</a> makes a
--   good hash key).
hashDynamicStableName :: DynamicStableName -> Int

-- | Makes a <a>DynamicStableName</a> for an arbitrary object. The object
--   passed as the first argument is not evaluated by
--   <a>makeDynamicStableName</a>.
makeDynamicStableName :: t -> IO DynamicStableName
wrapStableName :: StableName a -> DynamicStableName
instance Eq DynamicStableName

module System.Mem.StableName.Dynamic.Map
data Map a
empty :: Map a
null :: Map a -> Bool
singleton :: DynamicStableName -> a -> Map a
member :: DynamicStableName -> Map a -> Bool
notMember :: DynamicStableName -> Map a -> Bool
insert :: DynamicStableName -> a -> Map a -> Map a

-- | <i>O(log n)</i>. Insert with a function for combining the new value
--   and old value. <tt><a>insertWith</a> f key value mp</tt> will insert
--   the pair (key, value) into <tt>mp</tt> if the key does not exist in
--   the map. If the key does exist, the function will insert the pair
--   <tt>(key, f new_value old_value)</tt>
insertWith :: (a -> a -> a) -> DynamicStableName -> a -> Map a -> Map a

-- | Same as <a>insertWith</a>, but with the combining function applied
--   strictly.
insertWith' :: (a -> a -> a) -> DynamicStableName -> a -> Map a -> Map a

-- | <i>O(log n)</i>. Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as a <tt>(<a>Just</a>
--   value)</tt> or <a>Nothing</a> if the key isn't in the map.
lookup :: DynamicStableName -> Map v -> Maybe v
find :: DynamicStableName -> Map v -> v

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns the default
--   value <tt>def</tt> when the key is not in the map.
findWithDefault :: v -> DynamicStableName -> Map v -> v

module System.Mem.StableName.Map
data Map f
empty :: Map f
null :: Map f -> Bool
singleton :: StableName a -> f a -> Map f
member :: StableName a -> Map f -> Bool
notMember :: StableName a -> Map f -> Bool
insert :: StableName a -> f a -> Map f -> Map f

-- | <i>O(log n)</i>. Insert with a function for combining the new value
--   and old value. <tt><a>insertWith</a> f key value mp</tt> will insert
--   the pair (key, value) into <tt>mp</tt> if the key does not exist in
--   the map. If the key does exist, the function will insert the pair
--   <tt>(key, f new_value old_value)</tt>
insertWith :: (f a -> f a -> f a) -> StableName a -> f a -> Map f -> Map f

-- | Same as <a>insertWith</a>, but with the combining function applied
--   strictly.
insertWith' :: (f a -> f a -> f a) -> StableName a -> f a -> Map f -> Map f
adjust :: (f a -> f a) -> StableName a -> Map f -> Map f

-- | <i>O(log n)</i>. Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as a <tt>(<a>Just</a>
--   value)</tt> or <a>Nothing</a> if the key isn't in the map.
lookup :: StableName a -> Map f -> Maybe (f a)
find :: StableName a -> Map f -> f a

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns the default
--   value <tt>def</tt> when the key is not in the map.
findWithDefault :: f a -> StableName a -> Map f -> f a
