-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | abstract implementation of typed and untyped web routing
--   
@package reroute
@version 0.2.3.0

module Web.Routing.AbstractRouter
class AbstractRouter r where data family Registry r :: * data family RoutePath r :: [*] -> * type family RouteAction r :: [*] -> * type family RouteAppliedAction r
subcompCombine :: AbstractRouter r => RoutePath r [] -> RoutePath r as -> RoutePath r as
emptyRegistry :: AbstractRouter r => Registry r
rootPath :: AbstractRouter r => RoutePath r []
defRoute :: AbstractRouter r => RoutePath r as -> RouteAction r as -> Registry r -> Registry r
fallbackRoute :: AbstractRouter r => ([Text] -> RouteAppliedAction r) -> Registry r -> Registry r
matchRoute :: AbstractRouter r => Registry r -> [Text] -> [(ParamMap, RouteAppliedAction r)]
type ParamMap = HashMap CaptureVar Text
newtype CaptureVar
CaptureVar :: Text -> CaptureVar
unCaptureVar :: CaptureVar -> Text
newtype RegistryT r middleware reqTypes (m :: * -> *) a
RegistryT :: RWST (RoutePath r []) [middleware] (RegistryState r reqTypes) m a -> RegistryT r middleware reqTypes a
runRegistryT :: RegistryT r middleware reqTypes a -> RWST (RoutePath r []) [middleware] (RegistryState r reqTypes) m a
data RegistryState r reqTypes
RegistryState :: HashMap reqTypes (Registry r) -> RegistryState r reqTypes
rs_registry :: RegistryState r reqTypes -> HashMap reqTypes (Registry r)
hookAny :: (Monad m, AbstractRouter r, Eq reqTypes, Hashable reqTypes) => reqTypes -> ([Text] -> RouteAppliedAction r) -> RegistryT r middleware reqTypes m ()
hookRoute :: (Monad m, AbstractRouter r, Eq reqTypes, Hashable reqTypes) => reqTypes -> RoutePath r as -> RouteAction r as -> RegistryT r middleware reqTypes m ()
middleware :: Monad m => middleware -> RegistryT r middleware reqTypes m ()
subcomponent :: (Monad m, AbstractRouter r) => RoutePath r [] -> RegistryT r middleware reqTypes m a -> RegistryT r middleware reqTypes m a
runRegistry :: (Monad m, AbstractRouter r, Hashable reqTypes, Eq reqTypes) => r -> RegistryT r middleware reqTypes m a -> m (a, reqTypes -> [Text] -> [(ParamMap, RouteAppliedAction r)], [middleware])
instance Show CaptureVar
instance Eq CaptureVar
instance Hashable CaptureVar
instance NFData CaptureVar
instance Monad m => Monad (RegistryT r middleware reqTypes m)
instance Functor m => Functor (RegistryT r middleware reqTypes m)
instance (Monad m, Functor m) => Applicative (RegistryT r middleware reqTypes m)
instance MonadIO m => MonadIO (RegistryT r middleware reqTypes m)
instance Monad m => MonadReader (RoutePath r '[]) (RegistryT r middleware reqTypes m)
instance Monad m => MonadWriter [middleware] (RegistryT r middleware reqTypes m)
instance Monad m => MonadState (RegistryState r reqTypes) (RegistryT r middleware reqTypes m)
instance MonadTrans (RegistryT r middleware reqTypes)

module Web.Routing.TextRouting

-- | Combine two routes, ensuring that the slashes don't get messed up
combineRoute :: Text -> Text -> Text
type TextAction m r = TAction m r []
newtype TPath (a :: ())
TPath :: Text -> TPath
unTPath :: TPath -> Text
newtype TAction m r (p :: [*])
TAction :: (m r) -> TAction m r
newtype TActionAppl m r
TActionAppl :: (m r) -> TActionAppl m r
data TextRouter (m :: * -> *) a
TextRouter :: TextRouter a
data RegexWrapper
RegexWrapper :: !Regex -> !Text -> RegexWrapper
rw_regex :: RegexWrapper -> !Regex
rw_original :: RegexWrapper -> !Text
data RouteNode
RouteNodeRegex :: !CaptureVar -> !RegexWrapper -> RouteNode
RouteNodeCapture :: !CaptureVar -> RouteNode
RouteNodeText :: !Text -> RouteNode
RouteNodeRoot :: RouteNode
data RouteData a
RouteData :: !RouteNode -> !(Vector a) -> RouteData a
rd_node :: RouteData a -> !RouteNode
rd_data :: RouteData a -> !(Vector a)
data RoutingTree a
RoutingTree :: Graph -> Vector (RouteData a) -> Node -> RoutingTree a
rm_graph :: RoutingTree a -> Graph
rm_nodeManager :: RoutingTree a -> Vector (RouteData a)
rm_rootNode :: RoutingTree a -> Node
emptyRoutingTree :: RoutingTree a
spawnNode :: Node -> RouteData a -> RoutingTree a -> (Node, RoutingTree a)
addActionToNode :: Node -> a -> RoutingTree a -> RoutingTree a
addToRoutingTree :: Text -> a -> RoutingTree a -> RoutingTree a
matchRoute :: Text -> RoutingTree a -> [(ParamMap, a)]
matchRoute' :: [Text] -> RoutingTree a -> [(ParamMap, a)]
buildRegex :: Text -> RegexWrapper
parseRouteNode :: Text -> RouteNode
emptyParamMap :: ParamMap
matchNode :: Text -> RouteNode -> (Bool, Maybe (CaptureVar, Text))
instance Show (TPath a)
instance Eq (TPath a)
instance IsString (TPath a)
instance Read (TPath a)
instance Ord (TPath a)
instance Show RouteNode
instance Eq RouteNode
instance Show a => Show (RouteData a)
instance Eq a => Eq (RouteData a)
instance Show a => Show (RoutingTree a)
instance Eq a => Eq (RoutingTree a)
instance NFData a => NFData (RoutingTree a)
instance NFData a => NFData (RouteData a)
instance NFData RouteNode
instance NFData RegexWrapper
instance Show RegexWrapper
instance Eq RegexWrapper
instance AbstractRouter (TextRouter m a)

module Data.PolyMap
data PolyMap (c :: * -> Constraint) (f :: * -> *) (a :: *)
empty :: PolyMap c f a
rnfHelper :: (forall p. c p => f (p -> a) -> ()) -> PolyMap c f a -> ()
lookup :: Typeable p => PolyMap c f a -> Maybe (f (p -> a))
lookupApply :: (Typeable p, Functor f) => p -> PolyMap c f a -> Maybe (f a)
lookupApplyAll :: Functor f => (forall p. c p => Maybe p) -> PolyMap c f a -> [f a]
lookupConcat :: (Monoid m, Functor f) => (forall p. c p => Maybe p) -> (forall p. c p => p -> f (p -> a) -> m) -> PolyMap c f a -> m
alter :: (Typeable p, c p) => (Maybe (f (p -> a)) -> Maybe (f (p -> a))) -> PolyMap c f a -> PolyMap c f a
updateAll :: (forall p. c p => f (p -> a) -> g (p -> b)) -> PolyMap c f a -> PolyMap c g b
insertWith :: (Typeable p, c p) => (f (p -> a) -> f (p -> a) -> f (p -> a)) -> f (p -> a) -> PolyMap c f a -> PolyMap c f a
unionWith :: (forall p. c p => f (p -> a) -> f (p -> a) -> f (p -> a)) -> PolyMap c f a -> PolyMap c f a -> PolyMap c f a
union :: Alternative f => PolyMap c f a -> PolyMap c f a -> PolyMap c f a
zipWith' :: (forall p. c p => Maybe (f (p -> a)) -> Maybe (f (p -> b)) -> Maybe (f (p -> d))) -> PolyMap c f a -> PolyMap c f b -> PolyMap c f d
zipWith :: Applicative f => (a -> b -> d) -> PolyMap c f a -> PolyMap c f b -> PolyMap c f d
zip :: Applicative f => PolyMap c f a -> PolyMap c f b -> PolyMap c f (a, b)
ap :: Applicative f => PolyMap c f (a -> b) -> PolyMap c f a -> PolyMap c f b
instance Alternative f => Monoid (PolyMap c f a)
instance Functor f => Functor (PolyMap c f)

module Data.HVect
data HVect (ts :: [*])
HNil :: HVect []
HCons :: t -> HVect ts -> HVect (t : ts)
hVectAppend :: HVect as -> HVect bs -> HVect (Append as bs)
type Reverse as = ReverseLoop as []
hVectReverse :: HVect as -> HVect (Reverse as)
hVectUncurry :: HVectElim ts a -> HVect ts -> a
data Rep (ts :: [*])
RNil :: Rep []
RCons :: Rep ts -> Rep (t : ts)
class HasRep (ts :: [*])
hasRep :: HasRep ts => Rep ts
hVectCurryExpl :: Rep ts -> (HVect ts -> a) -> HVectElim ts a
hVectCurry :: HasRep ts => (HVect ts -> a) -> HVectElim ts a
packExpl :: Rep ts -> (forall a. HVectElim ts a -> a) -> HVect ts
pack :: HasRep ts => (forall a. HVectElim ts a -> a) -> HVect ts
instance HasRep ts => HasRep (t : ts)
instance HasRep '[]

module Web.Routing.SafeRouting
data RouteHandle m a
RouteHandle :: (Path as) -> (HVectElim as (m a)) -> RouteHandle m a
newtype HVectElim' x ts
HVectElim' :: HVectElim ts x -> HVectElim' x ts
flipHVectElim :: HVectElim' x ts -> HVectElim ts x
data SafeRouter (m :: * -> *) a
SafeRouter :: SafeRouter a
data Path (as :: [*])
Empty :: Path []
StaticCons :: Text -> Path as -> Path as
VarCons :: Path as -> Path (a : as)
pathToRep :: Path as -> Rep as
data PathMap x
PathMap :: [x] -> HashMap Text (PathMap x) -> PolyMap PathPiece PathMap x -> PathMap x
pm_here :: PathMap x -> [x]
pm_staticMap :: PathMap x -> HashMap Text (PathMap x)
pm_polyMap :: PathMap x -> PolyMap PathPiece PathMap x
emptyPathMap :: PathMap x
insertPathMap' :: Path ts -> (HVect ts -> x) -> PathMap x -> PathMap x
singleton :: Path ts -> HVectElim ts x -> PathMap x
insertPathMap :: RouteHandle m a -> PathMap (m a) -> PathMap (m a)
match :: PathMap x -> [Text] -> [x]

-- | A route parameter
var :: (Typeable a, PathPiece a) => Path (a : [])
type Var a = Path (a : [])

-- | A static route piece
static :: String -> Path []

-- | The root of a path piece. Use to define a handler for "/"
root :: Path []
(</>) :: Path as -> Path bs -> Path (Append as bs)
renderRoute :: Path as -> HVect as -> Text
renderRoute' :: Path as -> HVect as -> [Text]
parse :: Path as -> [Text] -> Maybe (HVect as)
instance a ~ '[] => IsString (Path a)
instance Monoid (PathMap x)
instance NFData x => NFData (PathMap x)
instance Alternative PathMap
instance Applicative PathMap
instance Functor PathMap
instance AbstractRouter (SafeRouter m a)
