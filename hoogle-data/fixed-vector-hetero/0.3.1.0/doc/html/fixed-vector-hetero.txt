-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic heterogeneous vectors
--   
@package fixed-vector-hetero
@version 0.3.1.0


-- | Type functions
module Data.Vector.HFixed.TypeFuns

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
proxy :: t -> Proxy t
unproxy :: Proxy t -> t

-- | Concaternation of type level lists.

-- | Length of type list expressed as type level naturals from
--   <tt>fixed-vector</tt>.

-- | Head of type list

-- | Homogeneous type list with length <i>n</i> and element of type
--   <i>a</i>. It uses type level natural defined in <tt>fixed-vector</tt>.

-- | Wrap every element of list into type constructor

module Data.Vector.HFixed.Class

-- | Successor of n
data S n :: * -> *

-- | Type level zero
data Z :: *

-- | Isomorphism between two representations of natural numbers
class ((~) Nat (ToNat a) b, (~) * (ToPeano b) a) => NatIso a (b :: Nat)

-- | Convert Nat number to Peano represenation

-- | Convert Peano number to Nat

-- | Type family for N-ary function. Types of function parameters are
--   encoded as the list of types.

-- | Newtype wrapper to work around of type families' lack of injectivity.
newtype Fun (as :: [*]) b
Fun :: Fn as b -> Fun b
unFun :: Fun b -> Fn as b

-- | Newtype wrapper for function where all type parameters have same type
--   constructor. This type is required for writing function which works
--   with monads, appicatives etc.
newtype TFun f as b
TFun :: Fn (Wrap f as) b -> TFun f as b
unTFun :: TFun f as b -> Fn (Wrap f as) b

-- | Cast <i>Fun</i> to equivalent <i>TFun</i>
funToTFun :: Fun (Wrap f xs) b -> TFun f xs b

-- | Cast <i>TFun</i> to equivalent <i>Fun</i>
tfunToFun :: TFun f xs b -> Fun (Wrap f xs) b

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy

-- | Concaternation of type level lists.

-- | Length of type list expressed as type level naturals from
--   <tt>fixed-vector</tt>.

-- | Wrap every element of list into type constructor

-- | Homogeneous type list with length <i>n</i> and element of type
--   <i>a</i>. It uses type level natural defined in <tt>fixed-vector</tt>.

-- | Type class for dealing with N-ary function in generic way. Both
--   <a>accum</a> and <a>apply</a> work with accumulator data types which
--   are polymorphic. So it's only possible to write functions which
--   rearrange elements in vector using plain ADT. It's possible to get
--   around it by using GADT as accumulator (See <a>ArityC</a> and function
--   which use it)
--   
--   This is also somewhat a kitchen sink module. It contains witnesses
--   which could be used to prove type equalities or to bring instance in
--   scope.
class Arity (Len xs) => Arity (xs :: [*])
accum :: Arity xs => (forall a as. t (a : as) -> a -> t as) -> (t [] -> b) -> t xs -> Fn xs b
apply :: Arity xs => (forall a as. t (a : as) -> (a, t as)) -> t xs -> ContVec xs
applyM :: (Arity xs, Monad m) => (forall a as. t (a : as) -> m (a, t as)) -> t xs -> m (ContVec xs)
accumTy :: Arity xs => (forall a as. t (a : as) -> f a -> t as) -> (t [] -> b) -> t xs -> Fn (Wrap f xs) b
applyTy :: Arity xs => (forall a as. t (a : as) -> (f a, t as)) -> t xs -> ContVecF xs f
arity :: Arity xs => p xs -> Int
witWrapped :: Arity xs => WitWrapped f xs
witConcat :: (Arity xs, Arity ys) => WitConcat xs ys
witNestedFun :: Arity xs => WitNestedFun xs ys r
witLenWrap :: Arity xs => WitLenWrap f xs

-- | Declares that every type in list satisfy constraint <tt>c</tt>
class Arity xs => ArityC c xs
witAllInstances :: ArityC c xs => WitAllInstances c xs

-- | Type class for heterogeneous vectors. Instance should specify way to
--   construct and deconstruct itself
--   
--   Note that this type class is extremely generic. Almost any single
--   constructor data type could be made instance. It could be monomorphic,
--   it could be polymorphic in some or all fields it doesn't matter. Only
--   law instance should obey is:
--   
--   <pre>
--   inspect v construct = v
--   </pre>
--   
--   Default implementation which uses <a>Generic</a> is provided.
class Arity (Elems v) => HVector v where type family Elems v :: [*] type instance Elems v = GElems (Rep v) construct = fmap to gconstruct inspect v = ginspect (from v)
construct :: HVector v => Fun (Elems v) v
inspect :: HVector v => v -> Fun (Elems v) a -> a

-- | Type class for partially homogeneous vector where every element in the
--   vector have same type constructor. Vector itself is parametrized by
--   that constructor
class Arity (ElemsF v) => HVectorF (v :: (* -> *) -> *) where type family ElemsF v :: [*]
inspectF :: HVectorF v => v f -> TFun f (ElemsF v) a -> a
constructF :: HVectorF v => TFun f (ElemsF v) (v f)

-- | Witness that observe fact that if we have instance <tt>Arity xs</tt>
--   than we have instance <tt>Arity (Wrap f xs)</tt>.
data WitWrapped f xs
WitWrapped :: WitWrapped f xs

-- | Witness that observe fact that <tt>(Arity xs, Arity ys)</tt> implies
--   <tt>Arity (xs++ys)</tt>
data WitConcat xs ys
WitConcat :: WitConcat xs ys

-- | Observes fact that <tt>Fn (xs++ys) r ~ Fn xs (Fn ys r)</tt>
data WitNestedFun xs ys r
WitNestedFun :: WitNestedFun xs ys r

-- | Observe fact than <tt>Len xs ~ Len (Wrap f xs)</tt>
data WitLenWrap f xs
WitLenWrap :: WitLenWrap f xs

-- | Proofs for the indexing of wrapped type lists.
data WitWrapIndex f n xs
WitWrapIndex :: WitWrapIndex f n xs

-- | Witness that all elements of type list satisfy predicate <tt>c</tt>.
data WitAllInstances c xs
WitAllInstancesNil :: WitAllInstances c []
WitAllInstancesCons :: WitAllInstances c xs -> WitAllInstances c (x : xs)

-- | CPS-encoded heterogeneous vector.
newtype ContVec xs
ContVec :: (forall r. Fun xs r -> r) -> ContVec xs
runContVec :: ContVec xs -> forall r. Fun xs r -> r

-- | CPS-encoded partially heterogeneous vector.
newtype ContVecF xs f
ContVecF :: (forall r. TFun f xs r -> r) -> ContVecF xs f
toContVec :: ContVecF xs f -> ContVec (Wrap f xs)
toContVecF :: ContVec (Wrap f xs) -> ContVecF xs f

-- | Cons element to the vector
cons :: x -> ContVec xs -> ContVec (x : xs)

-- | Cons element to the vector
consF :: f x -> ContVecF xs f -> ContVecF (x : xs) f

-- | Conversion between homogeneous and heterogeneous N-ary functions.
class (Arity n, Arity (HomList n a)) => HomArity n a
toHeterogeneous :: HomArity n a => Fun n a r -> Fun (HomList n a) r
toHomogeneous :: HomArity n a => Fun (HomList n a) r -> Fun n a r

-- | Default implementation of <a>inspect</a> for homogeneous vector.
homInspect :: (Vector v a, HomArity (Dim v) a) => v a -> Fun (HomList (Dim v) a) r -> r

-- | Default implementation of <a>construct</a> for homogeneous vector.
homConstruct :: (Vector v a, HomArity (Dim v) a) => Fun (HomList (Dim v) a) (v a)

-- | Apply single parameter to function
curryFun :: Fun (x : xs) r -> x -> Fun xs r

-- | Uncurry N-ary function.
uncurryFun :: (x -> Fun xs r) -> Fun (x : xs) r
uncurryFun2 :: Arity xs => (x -> y -> Fun xs (Fun ys r)) -> Fun (x : xs) (Fun (y : ys) r)

-- | Curry first <i>n</i> arguments of N-ary function.
curryMany :: Arity xs => Fun (xs ++ ys) r -> Fun xs (Fun ys r)

-- | Add one parameter to function which is ignored.
constFun :: Fun xs r -> Fun (x : xs) r

-- | Transform function but leave outermost parameter untouched.
stepFun :: (Fun xs a -> Fun ys b) -> Fun (x : xs) a -> Fun (x : ys) b

-- | Apply single parameter to function
curryTFun :: TFun f (x : xs) r -> f x -> TFun f xs r

-- | Uncurry single parameter
uncurryTFun :: (f x -> TFun f xs r) -> TFun f (x : xs) r

-- | Uncurry two parameters for nested TFun.
uncurryTFun2 :: (Arity xs, Arity ys) => (f x -> f y -> TFun f xs (TFun f ys r)) -> TFun f (x : xs) (TFun f (y : ys) r)

-- | Move first argument of function to its result. This function is useful
--   for implementation of lens.
shuffleTF :: Arity xs => (x -> TFun f xs r) -> TFun f xs (x -> r)

-- | Concatenate n-ary functions. This function combine results of both
--   N-ary functions and merge their parameters into single list.
concatF :: (Arity xs, Arity ys) => (a -> b -> c) -> Fun xs a -> Fun ys b -> Fun (xs ++ ys) c

-- | Move first argument of function to its result. This function is useful
--   for implementation of lens.
shuffleF :: Arity xs => (x -> Fun xs r) -> Fun xs (x -> r)

-- | Helper for lens implementation.
lensWorkerF :: (Functor f, Arity xs) => (x -> f y) -> Fun (y : xs) r -> Fun (x : xs) (f r)

-- | Indexing of vectors
class Arity n => Index (n :: *) (xs :: [*]) where type family ValueAt n xs :: * type family NewElems n xs a :: [*]
getF :: Index n xs => n -> Fun xs (ValueAt n xs)
putF :: Index n xs => n -> ValueAt n xs -> Fun xs r -> Fun xs r
lensF :: (Index n xs, Functor f, v ~ ValueAt n xs) => n -> (v -> f v) -> Fun xs r -> Fun xs (f r)
lensChF :: (Index n xs, Functor f) => n -> (ValueAt n xs -> f a) -> Fun (NewElems n xs a) r -> Fun xs (f r)
witWrapIndex :: Index n xs => WitWrapIndex f n xs
instance GHVector U1
instance GHVector (K1 R x)
instance (GHVector f, GHVector g, Arity (GElems f), Arity (GElems g)) => GHVector (f :*: g)
instance (GHVector f, Arity (GElems f)) => GHVector (M1 i c f)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a', b', c', d', e', f')
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a', b', c', d', e')
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a', b', c', d')
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a', b', c')
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a', b')
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a')
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance HVector (a, b, c, d, e, f, g, h, i, j, k, l)
instance HVector (a, b, c, d, e, f, g, h, i, j, k)
instance HVector (a, b, c, d, e, f, g, h, i, j)
instance HVector (a, b, c, d, e, f, g, h, i)
instance HVector (a, b, c, d, e, f, g, h)
instance HVector (a, b, c, d, e, f, g)
instance HVector (a, b, c, d, e, f)
instance HVector (a, b, c, d, e)
instance HVector (a, b, c, d)
instance HVector (a, b, c)
instance HVector (a, b)
instance HVector (Complex a)
instance HVector ()
instance Index n xs => Index (S n) (x : xs)
instance Arity xs => Index Z (x : xs)
instance Arity xs => Monad (TFun f xs)
instance Arity xs => Applicative (TFun f xs)
instance Arity xs => Functor (TFun f xs)
instance Arity xs => Monad (Fun xs)
instance Arity xs => Applicative (Fun xs)
instance Arity xs => Functor (Fun xs)
instance Arity xs => HVectorF (ContVecF xs)
instance Arity xs => HVector (ContVec xs)
instance (Prim a, HomArity n a) => HVector (Vec n a)
instance (Storable a, HomArity n a) => HVector (Vec n a)
instance (Unbox n a, HomArity n a) => HVector (Vec n a)
instance HomArity n a => HVector (Vec n a)
instance HomArity n a => HomArity (S n) a
instance HomArity Z a
instance Arity xs => Arity (x : xs)
instance Arity '[]
instance (c x, ArityC c xs) => ArityC c (x : xs)
instance ArityC c '[]


-- | CPS encoded heterogeneous vectors.
module Data.Vector.HFixed.Cont

-- | Type family for N-ary function. Types of function parameters are
--   encoded as the list of types.

-- | Newtype wrapper to work around of type families' lack of injectivity.
newtype Fun (as :: [*]) b
Fun :: Fn as b -> Fun b
unFun :: Fun b -> Fn as b

-- | Newtype wrapper for function where all type parameters have same type
--   constructor. This type is required for writing function which works
--   with monads, appicatives etc.
newtype TFun f as b
TFun :: Fn (Wrap f as) b -> TFun f as b
unTFun :: TFun f as b -> Fn (Wrap f as) b

-- | Type class for dealing with N-ary function in generic way. Both
--   <a>accum</a> and <a>apply</a> work with accumulator data types which
--   are polymorphic. So it's only possible to write functions which
--   rearrange elements in vector using plain ADT. It's possible to get
--   around it by using GADT as accumulator (See <a>ArityC</a> and function
--   which use it)
--   
--   This is also somewhat a kitchen sink module. It contains witnesses
--   which could be used to prove type equalities or to bring instance in
--   scope.
class Arity (Len xs) => Arity (xs :: [*])
accum :: Arity xs => (forall a as. t (a : as) -> a -> t as) -> (t [] -> b) -> t xs -> Fn xs b
apply :: Arity xs => (forall a as. t (a : as) -> (a, t as)) -> t xs -> ContVec xs
applyM :: (Arity xs, Monad m) => (forall a as. t (a : as) -> m (a, t as)) -> t xs -> m (ContVec xs)
accumTy :: Arity xs => (forall a as. t (a : as) -> f a -> t as) -> (t [] -> b) -> t xs -> Fn (Wrap f xs) b
applyTy :: Arity xs => (forall a as. t (a : as) -> (f a, t as)) -> t xs -> ContVecF xs f
arity :: Arity xs => p xs -> Int
witWrapped :: Arity xs => WitWrapped f xs
witConcat :: (Arity xs, Arity ys) => WitConcat xs ys
witNestedFun :: Arity xs => WitNestedFun xs ys r
witLenWrap :: Arity xs => WitLenWrap f xs

-- | Type class for heterogeneous vectors. Instance should specify way to
--   construct and deconstruct itself
--   
--   Note that this type class is extremely generic. Almost any single
--   constructor data type could be made instance. It could be monomorphic,
--   it could be polymorphic in some or all fields it doesn't matter. Only
--   law instance should obey is:
--   
--   <pre>
--   inspect v construct = v
--   </pre>
--   
--   Default implementation which uses <a>Generic</a> is provided.
class Arity (Elems v) => HVector v where type family Elems v :: [*] type instance Elems v = GElems (Rep v) construct = fmap to gconstruct inspect v = ginspect (from v)
construct :: HVector v => Fun (Elems v) v
inspect :: HVector v => v -> Fun (Elems v) a -> a

-- | Type class for partially homogeneous vector where every element in the
--   vector have same type constructor. Vector itself is parametrized by
--   that constructor
class Arity (ElemsF v) => HVectorF (v :: (* -> *) -> *) where type family ElemsF v :: [*]
inspectF :: HVectorF v => v f -> TFun f (ElemsF v) a -> a
constructF :: HVectorF v => TFun f (ElemsF v) (v f)

-- | Indexing of vectors
class Arity n => Index (n :: *) (xs :: [*]) where type family ValueAt n xs :: *

-- | Wrap every element of list into type constructor

-- | CPS-encoded heterogeneous vector.
newtype ContVec xs
ContVec :: (forall r. Fun xs r -> r) -> ContVec xs
runContVec :: ContVec xs -> forall r. Fun xs r -> r

-- | CPS-encoded partially heterogeneous vector.
newtype ContVecF xs f
ContVecF :: (forall r. TFun f xs r -> r) -> ContVecF xs f
toContVec :: ContVecF xs f -> ContVec (Wrap f xs)
toContVecF :: ContVec (Wrap f xs) -> ContVecF xs f

-- | List like heterogeneous vector.
data VecList :: [*] -> *
Nil :: VecList []
Cons :: x -> VecList xs -> VecList (x : xs)

-- | List-like vector
data VecListF xs f
NilF :: VecListF [] f
ConsF :: f x -> VecListF xs f -> VecListF (x : xs) f

-- | Convert heterogeneous vector to CPS form
cvec :: (HVector v, Elems v ~ xs) => v -> ContVec xs

-- | Convert CPS-vector to heterogeneous vector
vector :: (HVector v, Elems v ~ xs) => ContVec xs -> v
cvecF :: HVectorF v => v f -> ContVecF (ElemsF v) f
vectorF :: HVectorF v => ContVecF (ElemsF v) f -> v f

-- | Head of vector
head :: Arity xs => ContVec (x : xs) -> x

-- | Tail of CPS-encoded vector
tail :: ContVec (x : xs) -> ContVec xs

-- | Cons element to the vector
cons :: x -> ContVec xs -> ContVec (x : xs)

-- | Cons element to the vector
consF :: f x -> ContVecF xs f -> ContVecF (x : xs) f

-- | Concatenate two vectors
concat :: Arity xs => ContVec xs -> ContVec ys -> ContVec (xs ++ ys)

-- | Get value at <tt>n</tt>th position.
index :: Index n xs => ContVec xs -> n -> ValueAt n xs

-- | Set value on nth position.
set :: Index n xs => n -> ValueAt n xs -> ContVec xs -> ContVec xs
mk0 :: ContVec []
mk1 :: a -> ContVec '[a]
mk2 :: a -> b -> ContVec '[a, b]
mk3 :: a -> b -> c -> ContVec '[a, b, c]
mk4 :: a -> b -> c -> d -> ContVec '[a, b, c, d]
mk5 :: a -> b -> c -> d -> e -> ContVec '[a, b, c, d, e]

-- | Left fold over vector
foldl :: ArityC c xs => Proxy c -> (forall a. c a => b -> a -> b) -> b -> ContVec xs -> b

-- | Right fold over vector
foldr :: ArityC c xs => Proxy c -> (forall a. c a => a -> b -> b) -> b -> ContVec xs -> b

-- | Unfold vector.
unfoldr :: ArityC c xs => Proxy c -> (forall a. c a => b -> (a, b)) -> b -> ContVec xs

-- | Replicate polymorphic value n times. Concrete instance for every
--   element is determined by their respective types.
replicate :: ArityC c xs => Proxy c -> (forall x. c x => x) -> ContVec xs

-- | Replicate monadic action n times.
replicateM :: (ArityC c xs, Monad m) => Proxy c -> (forall x. c x => m x) -> m (ContVec xs)
replicateF :: Arity xs => (forall a. f a) -> ContVecF xs f

-- | Zip two heterogeneous vectors
zipMono :: ArityC c xs => Proxy c -> (forall a. c a => a -> a -> a) -> ContVec xs -> ContVec xs -> ContVec xs

-- | Zip two heterogeneous vectors
zipMonoF :: ArityC c xs => Proxy c -> (forall a. c a => f a -> g a -> h a) -> ContVecF xs f -> ContVecF xs g -> ContVecF xs h

-- | Zip vector and fold result using monoid
zipFold :: (ArityC c xs, Monoid m) => Proxy c -> (forall a. c a => a -> a -> m) -> ContVec xs -> ContVec xs -> m

-- | Convert heterogeneous vector to homogeneous
monomorphize :: ArityC c xs => Proxy c -> (forall x. c x => x -> a) -> ContVec xs -> ContVec (Len xs) a

-- | Convert heterogeneous vector to homogeneous
monomorphizeF :: ArityC c xs => Proxy c -> (forall x. c x => f x -> a) -> ContVecF xs f -> ContVec (Len xs) a

-- | Map functor.
mapFunctor :: Arity xs => (forall a. f a -> g a) -> ContVecF xs f -> ContVecF xs g

-- | Sequence vector's elements
sequence :: (Arity xs, Monad m) => ContVecF xs m -> m (ContVec xs)

-- | Sequence vector's elements
sequenceA :: (Arity xs, Applicative f) => ContVecF xs f -> f (ContVec xs)

-- | Sequence vector's elements
sequenceF :: (Arity xs, Monad m) => ContVecF xs (m `Compose` f) -> m (ContVecF xs f)

-- | Sequence vector's elements
sequenceAF :: (Arity xs, Applicative f) => ContVecF xs (f `Compose` g) -> f (ContVecF xs g)
distribute :: (Arity xs, Functor f) => f (ContVec xs) -> ContVecF xs f
distributeF :: (Arity xs, Functor f) => f (ContVecF xs g) -> ContVecF xs (f `Compose` g)

-- | Wrap every value in the vector into type constructor.
wrap :: Arity xs => (forall a. a -> f a) -> ContVec xs -> ContVecF xs f

-- | Unwrap every value in the vector from the type constructor.
unwrap :: Arity xs => (forall a. f a -> a) -> ContVecF xs f -> ContVec xs
instance Arity xs => HVectorF (VecListF xs)
instance Arity xs => HVector (VecList xs)


-- | Heterogeneous vectors.
module Data.Vector.HFixed

-- | Type class for dealing with N-ary function in generic way. Both
--   <a>accum</a> and <a>apply</a> work with accumulator data types which
--   are polymorphic. So it's only possible to write functions which
--   rearrange elements in vector using plain ADT. It's possible to get
--   around it by using GADT as accumulator (See <a>ArityC</a> and function
--   which use it)
--   
--   This is also somewhat a kitchen sink module. It contains witnesses
--   which could be used to prove type equalities or to bring instance in
--   scope.
class Arity (Len xs) => Arity (xs :: [*])

-- | Declares that every type in list satisfy constraint <tt>c</tt>
class Arity xs => ArityC c xs

-- | Type class for heterogeneous vectors. Instance should specify way to
--   construct and deconstruct itself
--   
--   Note that this type class is extremely generic. Almost any single
--   constructor data type could be made instance. It could be monomorphic,
--   it could be polymorphic in some or all fields it doesn't matter. Only
--   law instance should obey is:
--   
--   <pre>
--   inspect v construct = v
--   </pre>
--   
--   Default implementation which uses <a>Generic</a> is provided.
class Arity (Elems v) => HVector v where type family Elems v :: [*] type instance Elems v = GElems (Rep v) construct = fmap to gconstruct inspect v = ginspect (from v)
construct :: HVector v => Fun (Elems v) v
inspect :: HVector v => v -> Fun (Elems v) a -> a

-- | Type class for partially homogeneous vector where every element in the
--   vector have same type constructor. Vector itself is parametrized by
--   that constructor
class Arity (ElemsF v) => HVectorF (v :: (* -> *) -> *) where type family ElemsF v :: [*]
inspectF :: HVectorF v => v f -> TFun f (ElemsF v) a -> a
constructF :: HVectorF v => TFun f (ElemsF v) (v f)

-- | Wrap every element of list into type constructor

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy

-- | CPS-encoded heterogeneous vector.
data ContVec xs

-- | Restrict type of vector to <a>ContVec</a>. This function is useful for
--   resolving type ambiguity when composing functions. For example
--   following code would not compile because intermediate type is
--   ambiguous:
--   
--   <pre>
--   cons 'a' . tail
--   </pre>
--   
--   GHC cannot guess what type should be produced by <tt>tail</tt>.
--   However we can fix type of intermediate vector with <tt>asCVec</tt>,
--   so code below will work just fine:
--   
--   <pre>
--   cons 'a' . asCVec . tail
--   </pre>
asCVec :: ContVec xs -> ContVec xs

-- | We can convert between any two vector which have same structure but
--   different representations.
convert :: (HVector v, HVector w, Elems v ~ Elems w) => v -> w

-- | Head of the vector
head :: (HVector v, Elems v ~ (a : as), Arity as) => v -> a

-- | Tail of the vector
--   
--   <pre>
--   &gt;&gt;&gt; case tail ('a',"aa",()) of x@(_,_) -&gt; x
--   ("aa",())
--   </pre>
tail :: (HVector v, HVector w, (a : Elems w) ~ Elems v) => v -> w

-- | Prepend element to the list. Note that it changes type of vector so it
--   either must be known from context of specified explicitly
cons :: (HVector v, HVector w, Elems w ~ (a : Elems v)) => a -> v -> w

-- | Concatenate two vectors
concat :: (HVector v, HVector u, HVector w, Elems w ~ (Elems v ++ Elems u)) => v -> u -> w

-- | Indexing of vectors
class Arity n => Index (n :: *) (xs :: [*]) where type family ValueAt n xs :: *

-- | Index heterogeneous vector
index :: (Index n (Elems v), HVector v) => v -> n -> ValueAt n (Elems v)

-- | Set element in the vector
set :: (Index n (Elems v), HVector v) => n -> ValueAt n (Elems v) -> v -> v

-- | Twan van Laarhoven's lens for i'th element.
element :: (Index n (Elems v), ValueAt n (Elems v) ~ a, HVector v, Functor f) => n -> (a -> f a) -> (v -> f v)

-- | Type changing Twan van Laarhoven's lens for i'th element.
elementCh :: (Index n (Elems v), a ~ ValueAt n (Elems v), HVector v, HVector w, Elems w ~ NewElems n (Elems v) b, Functor f) => n -> (a -> f b) -> (v -> f w)

-- | Twan van Laarhoven's lens for i'th element. GHC &gt;= 7.8
elementTy :: (Index (ToPeano n) (Elems v), ValueAt (ToPeano n) (Elems v) ~ a, NatIso (ToPeano n) n, HVector v, Functor f) => proxy n -> (a -> f a) -> (v -> f v)

-- | Type changing Twan van Laarhoven's lens for i'th element.
elementChTy :: (Index (ToPeano n) (Elems v), a ~ ValueAt (ToPeano n) (Elems v), HVector v, HVector w, Elems w ~ NewElems (ToPeano n) (Elems v) b, Functor f) => proxy n -> (a -> f b) -> (v -> f w)
mk0 :: (HVector v, Elems v ~ []) => v
mk1 :: (HVector v, Elems v ~ '[a]) => a -> v
mk2 :: (HVector v, Elems v ~ '[a, b]) => a -> b -> v
mk3 :: (HVector v, Elems v ~ '[a, b, c]) => a -> b -> c -> v
mk4 :: (HVector v, Elems v ~ '[a, b, c, d]) => a -> b -> c -> d -> v
mk5 :: (HVector v, Elems v ~ '[a, b, c, d, e]) => a -> b -> c -> d -> e -> v

-- | Most generic form of fold which doesn't constrain elements id use of
--   <a>inspect</a>. Or in more convenient form below:
--   
--   <pre>
--   &gt;&gt;&gt; fold (12::Int,"Str") (\a s -&gt; show a ++ s)
--   "12Str"
--   </pre>
fold :: HVector v => v -> Fn (Elems v) r -> r

-- | Right fold over heterogeneous vector
foldr :: (HVector v, ArityC c (Elems v)) => Proxy c -> (forall a. c a => a -> b -> b) -> b -> v -> b

-- | Left fold over heterogeneous vector
foldl :: (HVector v, ArityC c (Elems v)) => Proxy c -> (forall a. c a => b -> a -> b) -> b -> v -> b

-- | Apply monadic action to every element in the vector
mapM_ :: (HVector v, ArityC c (Elems v), Monad m) => Proxy c -> (forall a. c a => a -> m ()) -> v -> m ()

-- | Unfold vector.
unfoldr :: (HVector v, ArityC c (Elems v)) => Proxy c -> (forall a. c a => b -> (a, b)) -> b -> v

-- | Replicate polymorphic value n times. Concrete instance for every
--   element is determined by their respective types.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.HFixed as H
--   
--   &gt;&gt;&gt; H.replicate (Proxy :: Proxy Monoid) mempty :: ((),String)
--   ((),"")
--   </pre>
replicate :: (HVector v, ArityC c (Elems v)) => Proxy c -> (forall x. c x => x) -> v

-- | Replicate monadic action n times.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.HFixed as H
--   
--   &gt;&gt;&gt; H.replicateM (Proxy :: Proxy Read) (fmap read getLine) :: IO (Int,Char)
--   &gt; 12
--   &gt; 'a'
--   (12,'a')
--   </pre>
replicateM :: (HVector v, Monad m, ArityC c (Elems v)) => Proxy c -> (forall x. c x => m x) -> m v
replicateF :: (HVectorF v, Arity (ElemsF v)) => (forall a. f a) -> v f

-- | Zip two heterogeneous vectors
zipMono :: (HVector v, ArityC c (Elems v)) => Proxy c -> (forall a. c a => a -> a -> a) -> v -> v -> v

-- | Zip two heterogeneous vectors
zipMonoF :: (HVectorF v, ArityC c (ElemsF v)) => Proxy c -> (forall a. c a => f a -> g a -> h a) -> v f -> v g -> v h
zipFold :: (HVector v, ArityC c (Elems v), Monoid m) => Proxy c -> (forall a. c a => a -> a -> m) -> v -> v -> m

-- | Convert heterogeneous vector to homogeneous
monomorphize :: (HVector v, ArityC c (Elems v)) => Proxy c -> (forall a. c a => a -> x) -> v -> ContVec (Len (Elems v)) x

-- | Convert heterogeneous vector to homogeneous
monomorphizeF :: (HVectorF v, ArityC c (ElemsF v)) => Proxy c -> (forall a. c a => f a -> x) -> v f -> ContVec (Len (ElemsF v)) x
mapFunctor :: HVectorF v => (forall a. f a -> g a) -> v f -> v g

-- | Sequence effects for every element in the vector
sequence :: (Monad m, HVectorF v, HVector w, ElemsF v ~ Elems w) => v m -> m w

-- | Sequence effects for every element in the vector
sequenceA :: (Applicative f, HVectorF v, HVector w, ElemsF v ~ Elems w) => v f -> f w

-- | Sequence effects for every element in the vector
sequenceF :: (Monad m, HVectorF v) => v (m `Compose` f) -> m (v f)

-- | Sequence effects for every element in the vector
sequenceAF :: (Applicative f, HVectorF v) => v (f `Compose` g) -> f (v g)

-- | Wrap every value in the vector into type constructor.
wrap :: (HVector v, HVectorF w, Elems v ~ ElemsF w) => (forall a. a -> f a) -> v -> w f

-- | Unwrap every value in the vector from the type constructor.
unwrap :: (HVectorF v, HVector w, ElemsF v ~ Elems w) => (forall a. f a -> a) -> v f -> w

-- | Analog of <i>distribute</i> from <i>Distributive</i> type class.
distribute :: (Functor f, HVector v, HVectorF w, Elems v ~ ElemsF w) => f v -> w f

-- | Analog of <i>distribute</i> from <i>Distributive</i> type class.
distributeF :: (Functor f, HVectorF v) => f (v g) -> v (f `Compose` g)

-- | Generic equality for heterogeneous vectors
eq :: (HVector v, ArityC Eq (Elems v)) => v -> v -> Bool

-- | Generic comparison for heterogeneous vectors
compare :: (HVector v, ArityC Ord (Elems v)) => v -> v -> Ordering

-- | Reduce vector to normal form
rnf :: (HVector v, ArityC NFData (Elems v)) => v -> ()


-- | Heterogeneous vector parametric in its elements
module Data.Vector.HFixed.HVec

-- | Generic heterogeneous vector
data HVec (xs :: [*])

-- | Generic mutable heterogeneous vector.
data MutableHVec s (xs :: [*])

-- | Create new uninitialized heterogeneous vector.
newMutableHVec :: (PrimMonad m, Arity xs) => m (MutableHVec (PrimState m) xs)

-- | Convert mutable vector to immutable one. Mutable vector must not be
--   modified after that.
unsafeFreezeHVec :: PrimMonad m => MutableHVec (PrimState m) xs -> m (HVec xs)

-- | Read value at statically known index.
readMutableHVec :: (PrimMonad m, Index n xs, Arity xs) => MutableHVec (PrimState m) xs -> n -> m (ValueAt n xs)

-- | Write value at statically known index
writeMutableHVec :: (PrimMonad m, Index n xs, Arity xs) => MutableHVec (PrimState m) xs -> n -> ValueAt n xs -> m ()

-- | Apply function to value at statically known index.
modifyMutableHVec :: (PrimMonad m, Index n xs, Arity xs) => MutableHVec (PrimState m) xs -> n -> (ValueAt n xs -> ValueAt n xs) -> m ()

-- | Strictly apply function to value at statically known index.
modifyMutableHVec' :: (PrimMonad m, Index n xs, Arity xs) => MutableHVec (PrimState m) xs -> n -> (ValueAt n xs -> ValueAt n xs) -> m ()
instance Arity xs => HVector (HVec xs)
instance ArityC NFData xs => NFData (HVec xs)
instance ArityC Monoid xs => Monoid (HVec xs)
instance (ArityC Ord xs, Eq (HVec xs)) => Ord (HVec xs)
instance ArityC Eq xs => Eq (HVec xs)
instance ArityC Show xs => Show (HVec xs)


module Data.Vector.HFixed.Functor.HVecF

-- | Partially heterogeneous vector which can hold elements of any type.
newtype HVecF xs f
HVecF :: HVec (Wrap f xs) -> HVecF xs f
getHVecF :: HVecF xs f -> HVec (Wrap f xs)
instance (Arity xs, ArityC NFData (Wrap f xs)) => NFData (HVecF xs f)
instance (Arity xs, ArityC Eq (Wrap f xs), ArityC Ord (Wrap f xs)) => Ord (HVecF xs f)
instance (Arity xs, ArityC Eq (Wrap f xs)) => Eq (HVecF xs f)
instance Arity xs => HVectorF (HVecF xs)
instance (Arity (Wrap f xs), Arity xs) => HVector (HVecF xs f)
