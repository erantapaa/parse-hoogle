-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | EDSL for Procmail scripts
--   
--   Autoproc is a utility which allows you to write an email filterer in
--   an Haskell EDSL (embedded domain specific language); autoproc will
--   then compile it down to a Procmail configuration file (.procmailrc).
--   This file can then be used with Procmail to sort and filter your email
--   before you see it.
@package autoproc
@version 0.1.2

module Autoproc.Procmail
data PExp
PExp :: [RecipeFlag] -> [Condition] -> Action -> PExp
data RecipeFlag
CheckHeader :: RecipeFlag
CheckBody :: RecipeFlag
CaseSensitive :: RecipeFlag
Chain :: RecipeFlag
ElseIf :: RecipeFlag
PipeAsFilter :: RecipeFlag
Copy :: RecipeFlag
Wait :: RecipeFlag
IgnoreErrors :: RecipeFlag
RawWrite :: RecipeFlag
NeedLock :: Bool -> RecipeFlag
data Condition
Condition :: ConditionFlag -> String -> Condition
data ConditionFlag
Normal :: ConditionFlag
Invert :: ConditionFlag
Eval :: ConditionFlag
UseExitCode :: ConditionFlag
LessThan :: ConditionFlag
GreaterThan :: ConditionFlag
Var :: String -> ConditionFlag
data Action
Forward :: [String] -> Action
Pipe :: String -> Action
File :: String -> Action
Nest :: [PExp] -> Action
showLn :: Show a => a -> String
instance Eq RecipeFlag
instance Ord RecipeFlag
instance Show Action
instance Show ConditionFlag
instance Show Condition
instance Show RecipeFlag
instance Show PExp

module Autoproc.Configuration
boxPrefix :: String
lockDefault :: Bool
defaultVariables :: [(String, String)]
showVars :: [(String, String)] -> String

module Autoproc.Classifier
data EmailAddress
Addr :: String -> EmailAddress
data Mailbox
Mailbox :: String -> Mailbox
data CExp
CExp :: [Flag] -> Cond -> Act -> CExp
data Flag
Copy :: Flag
Wait :: Flag
IgnoreErrors :: Flag
RawWrite :: Flag
NeedLock :: Bool -> Flag
Chain :: Flag
CaseSensitive :: Flag
data Cond
And :: Cond -> Cond -> Cond
Or :: Cond -> Cond -> Cond
Not :: Cond -> Cond
Always :: Cond
Never :: Cond
CheckMatch :: String -> Cond
CheckHeader :: String -> Cond
CheckBody :: String -> Cond
data Act
File :: String -> Act
Fwd :: [EmailAddress] -> Act
Filter :: String -> Act
Nest :: [CExp] -> Act
(.&&.) :: Cond -> Cond -> Cond
(.||.) :: Cond -> Cond -> Cond
body :: String -> Cond
said :: String -> Cond
subject :: String -> Cond
to :: EmailAddress -> Cond
to_ :: EmailAddress -> Cond
from :: EmailAddress -> Cond
when :: Cond -> Act -> Writer [CExp] ()
whenWithOptions :: [Flag] -> Cond -> Act -> Writer [CExp] ()
placeIn :: Mailbox -> Act
also :: Act -> Act -> Act
flagAllButLast :: Flag -> [CExp] -> [CExp]
addFlag :: Flag -> CExp -> CExp
removeFlag :: Flag -> CExp -> CExp
forwardTo :: [EmailAddress] -> Act
isSpam :: Cond
spamLevel :: Int -> Cond
data Match a
Match :: a -> Match a
match :: Match String
whenMatch :: Match Cond -> Match Act -> Writer [CExp] ()
whenMatchWithOptions :: [Flag] -> Match Cond -> Match Act -> Writer [CExp] ()
placeInUsingMatch :: Match Mailbox -> Match Act
(%) :: Cond -> String -> Match Cond
refineBy :: Match Cond -> Match Cond -> Match Cond
alsoUsingMatch :: Match Act -> Match Act -> Match Act
sortBy :: (a -> Cond) -> a -> Mailbox -> Writer [CExp] ()
sortByTo :: EmailAddress -> Mailbox -> Writer [CExp] ()
sortByFrom :: EmailAddress -> Mailbox -> Writer [CExp] ()
sortByTo_ :: EmailAddress -> Mailbox -> Writer [CExp] ()
sortBySubject :: String -> Mailbox -> Writer [CExp] ()

-- | If the email address (the String argument) contains <a>foo</a>, then
--   place the email into a folder by the name <a>foo</a>. Actually, the
--   name of the mailbox is created by appending boxPrefix which is defined
--   in the Configuration module.
simpleSortByFrom :: String -> Writer [CExp] ()
simpleSortByTo :: String -> Writer [CExp] ()
simpleSortByTo_ :: String -> Writer [CExp] ()
mailbox :: String -> Mailbox
mailBoxFromMatch :: Match String -> Match Mailbox
lock :: Flag
type Class = (String, [Cond])
type Trigger = (String, Int, Act)
type Classifier = Writer [CExp] ()
mkTrigger :: Trigger -> Classifier
mkClassifiers :: Class -> Writer [CExp] ()
incrementHeader :: String -> Int -> [CExp]
mkHeader :: String -> String
classify :: [Class] -> [Trigger] -> Writer [CExp] ()
classifyBy :: (String, Cond) -> Act -> Writer [CExp] ()
classifyByAddress :: (EmailAddress -> Cond) -> EmailAddress -> Mailbox -> Writer [CExp] ()
classifyByTo :: EmailAddress -> Mailbox -> Writer [CExp] ()
classifyByFrom :: EmailAddress -> Mailbox -> Writer [CExp] ()
classifyByTo_ :: EmailAddress -> Mailbox -> Writer [CExp] ()
classifyByFromAddr :: String -> String -> Writer [CExp] ()
classifyBySubject :: String -> Mailbox -> Writer [CExp] ()
simpleClassifyBySubject :: String -> Writer [CExp] ()
simpleClassifyByTo_ :: String -> Writer [CExp] ()
simpleClassifyByTo :: String -> Writer [CExp] ()
simpleClassifyByFrom :: String -> Writer [CExp] ()
defaultRule :: String -> Writer [CExp] ()

-- | If the subject line contains a certain string, send it to a certain
--   mailbox.
subjectToMbox :: String -> String -> Writer [CExp] ()

-- | As with <a>subjectToMbox</a>, except by email address.
addressToMbox :: String -> String -> Writer [CExp] ()

-- | <a>addressToMbox</a> is fine, but may not work well for mailing lists.
toAddressToMbox :: String -> String -> Writer [CExp] ()

-- | <a>stuffToMbox</a> is a very general filtering statement, which is
--   intended for specialization by other functions.
--   
--   The idea is to take a logical operator and fold it over a list of
--   strings. If the result is <tt>True</tt>, then the email gets dropped
--   into a specified mailbox. So if you wanted to insist that only an
--   email which has strings <tt>x</tt>, <tt>y</tt>, and <tt>z</tt> in the
--   subject-line could appear in the xyz mailbox, you'd use .&amp;&amp;.
--   as the logical operator, <a>xyz</a> as the <tt>mbox</tt> argument, [x,
--   y, z] as the list, and a seed value of True. You also need the
--   <a>subject</a> operator, which will map over the list and turn it into
--   properly typed stuff.
stuffToMbox :: Cond -> (a1 -> a) -> (a -> Cond -> Cond) -> String -> [a1] -> Writer [CExp] ()

-- | If all the strings appear in the subject line, deposit the email in
--   the specified mailbox
subjectsToMbox :: [String] -> String -> Writer [CExp] ()

-- | If any of the strings appear in the subject line, send it to the mbox
--   This is currently a bit of a null-op, and I'm not sure it works.
anySubjectsToMbox :: [String] -> String -> Writer [CExp] ()
insertMbox :: String -> Act
instance Show Act
instance Eq Cond
instance Show Cond
instance Eq Flag
instance Show Flag
instance Show CExp
instance Show EmailAddress
instance Monad Match

module Autoproc.Transform
generate :: CExp -> [PExp]

module Autoproc.Run
showProcmailrc :: [(String, String)] -> [PExp] -> String
autoprocMessage :: IO ()
autoprocMain :: [(String, String)] -> Writer [CExp] a -> IO ()

module Autoproc.Rules.Dagit

-- | Any rules that you create need to end up in the rules list. Other than
--   that, feel free to define your own rules using these rules an
--   examples.
--   
--   A rule is something of the form:
--   
--   <pre>
--   when condition action
--   </pre>
--   
--   Examples of condition might include:
--   
--   <pre>
--   (from (Addr "foo@bar"))
--   (subject "Hi again")
--   </pre>
--   
--   And example actions are things like:
--   
--   <pre>
--   (insertMbox "steve")@, @(forward [Addr "friend@yahoo.com"])
--   </pre>
--   
--   I have created some aliases for commonly used constructions For
--   example, <tt>simpleSortByFrom <a>joe</a></tt>, is equivalent to:
--   
--   <pre>
--   when (from (Addr "joe")) (insertMbox "joe")
--   </pre>
--   
--   For a full list of what is possible, check the
--   <a>Autoproc.Classifier</a> module.
dagitRules :: Writer [CExp] ()

-- | I use this rule to make sure any mail that is not sorted goes into my
--   mail spool. It uses <a>Autoproc.Classifier</a>'s <a>defaultRule</a>
dagitDefaultRule :: Writer [CExp] ()

-- | If the email address contains <a>sparish</a>, then place the email
--   into a folder by the name <a>sparish</a>. Actually, the name of the
--   mailbox is created by appending boxPrefix which is defined in the
--   Configuration module.
sarah :: Writer [CExp] ()

-- | Similar to <a>sarah</a>, except we are sorting based on the subject
--   line, and giving the mailbox. As above, boxPrefix will be added to
--   <a>nwn</a>.
nwn :: Writer [CExp] ()
mom :: Writer [CExp] ()
dad :: Writer [CExp] ()
rogan :: Writer [CExp] ()
lkm :: Writer [CExp] ()
cvsupdates :: Writer [CExp] ()
cdspaper :: Writer [CExp] ()
bugs :: Writer [CExp] ()
forms3Tech :: Writer [CExp] ()
forms3 :: Writer [CExp] ()
euses :: Writer [CExp] ()
darcsUsers :: Writer [CExp] ()
darcsDevel :: Writer [CExp] ()
sbclDevel :: Writer [CExp] ()
ogi :: Writer [CExp] ()
clispDevel :: Writer [CExp] ()
csGradTalk :: Writer [CExp] ()
debian :: Writer [CExp] ()
csmaillist :: Writer [CExp] ()
classes :: Writer [CExp] ()

-- | A filter is a special action that transforms the email for the benefit
--   of future rules. This particular rule, hands the email off to spam
--   assassin so that it can be checked for signs of spam.
spamc :: Writer [CExp] ()
spamcheck :: Writer [CExp] ()
momentum :: Writer [CExp] ()

-- | An example that demonstrates forwarding an email.
sharing :: Writer [CExp] ()

-- | This rules <a>fixes</a> the reply-to header of a mailing list. I don't
--   recommend doing this unless you know what you are doing.
fixReplyTo :: Writer [CExp] ()
notTest :: Writer [CExp] ()

-- | Sometimes we want just one condition, but we have multiple actions. In
--   this case, use the also syntax. It allows multiple action for one
--   rule.
alsoTest :: Writer [CExp] ()
sarah' :: Writer [CExp] ()
nwn' :: Writer [CExp] ()
mom' :: Writer [CExp] ()
dad' :: Writer [CExp] ()
rogan' :: Writer [CExp] ()
lkm' :: Writer [CExp] ()
ogi' :: Writer [CExp] ()
debian' :: Writer [CExp] ()
cvsupdates' :: Writer [CExp] ()
bugs' :: Writer [CExp] ()
csmaillist' :: Writer [CExp] ()
euses' :: Writer [CExp] ()
forms3Tech' :: Writer [CExp] ()
forms3' :: Writer [CExp] ()
darcsUsers' :: Writer [CExp] ()
darcsDevel' :: Writer [CExp] ()
sbclDevel' :: Writer [CExp] ()
clispDevel' :: Writer [CExp] ()
csGradTalk' :: Writer [CExp] ()
momentum' :: Writer [CExp] ()
orTest :: Writer [CExp] ()
notOrTest :: Writer [CExp] ()
