-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Firing rules semantic of CSPM
--   
@package CSPM-FiringRules
@version 0.4.3.0


-- | Reflect the version number of this library.
module CSPM.FiringRules.Version

-- | The version of the CSPM-FiringRules library.
firingRulesVersion :: Version


-- | Definition of the Search Monad. Currently just a small wrapper around
--   the tree-monad package
module CSPM.FiringRules.Search
type Search a = Search a

-- | Run the search monad.
runSearch :: Search a -> [a]

-- | Lift a list to the search monad.
anyOf :: [a] -> Search a


-- | This module defines data types for (CSP) proof trees. A proof tree
--   shows that a particular transition is valid with respect to the firing
--   rules semantics.
--   
--   (For more info on the firing rule semantics see: The Theory and
--   Practice of Concurrency A.W. Roscoe 1999.)
--   
--   We use three separate data types: <a>RuleTau</a> stores a proof tree
--   for a tau rule, <a>RuleTick</a> stores a proof tree for a tick rule
--   and <a>RuleEvent</a> stores a proof tree for an event from Sigma.
--   
--   There is a one-to-one correspondence between each constructor of the
--   data types <a>RuleTau</a>, <a>RuleTick</a>, <a>RuleEvent</a> and one
--   fireing rule.
module CSPM.FiringRules.Rules

-- | A sum-type for tau, tick and regular proof trees.
data Rule i
TauRule :: (RuleTau i) -> Rule i
TickRule :: (RuleTick i) -> Rule i
EventRule :: (RuleEvent i) -> Rule i

-- | Is this a proof tree for a tau-transition ?
isTauRule :: Rule i -> Bool

-- | Representation of tau proof trees.
data RuleTau i
Hidden :: (EventSet i) -> (RuleEvent i) -> RuleTau i
HideTau :: (EventSet i) -> (RuleTau i) -> RuleTau i
SeqTau :: (RuleTau i) -> (Process i) -> RuleTau i
SeqTick :: (RuleTick i) -> (Process i) -> RuleTau i
InternalChoiceL :: (Process i) -> (Process i) -> RuleTau i
InternalChoiceR :: (Process i) -> (Process i) -> RuleTau i
ChaosStop :: (EventSet i) -> RuleTau i
TimeoutOccurs :: (Process i) -> (Process i) -> RuleTau i
TimeoutTauR :: (RuleTau i) -> (Process i) -> RuleTau i
ExtChoiceTauL :: (RuleTau i) -> (Process i) -> RuleTau i
ExtChoiceTauR :: (Process i) -> (RuleTau i) -> RuleTau i
InterleaveTauL :: (RuleTau i) -> (Process i) -> RuleTau i
InterleaveTauR :: (Process i) -> (RuleTau i) -> RuleTau i
InterleaveTickL :: (RuleTick i) -> (Process i) -> RuleTau i
InterleaveTickR :: (Process i) -> (RuleTick i) -> RuleTau i
ShareTauL :: (EventSet i) -> (RuleTau i) -> (Process i) -> RuleTau i
ShareTauR :: (EventSet i) -> (Process i) -> (RuleTau i) -> RuleTau i
ShareTickL :: (EventSet i) -> (RuleTick i) -> (Process i) -> RuleTau i
ShareTickR :: (EventSet i) -> (Process i) -> (RuleTick i) -> RuleTau i
AParallelTauL :: (EventSet i) -> (EventSet i) -> (RuleTau i) -> (Process i) -> RuleTau i
AParallelTauR :: (EventSet i) -> (EventSet i) -> (Process i) -> (RuleTau i) -> RuleTau i
AParallelTickL :: (EventSet i) -> (EventSet i) -> (RuleTick i) -> (Process i) -> RuleTau i
AParallelTickR :: (EventSet i) -> (EventSet i) -> (Process i) -> (RuleTick i) -> RuleTau i
InterruptTauL :: (RuleTau i) -> (Process i) -> RuleTau i
InterruptTauR :: (Process i) -> (RuleTau i) -> RuleTau i
TauRepAParallel :: [Either (EventSet i, Process i) (EventSet i, RuleTau i)] -> RuleTau i
RenamingTau :: (RenamingRelation i) -> (RuleTau i) -> RuleTau i
LinkLinked :: (RenamingRelation i) -> (RuleEvent i) -> (RuleEvent i) -> RuleTau i
LinkTauL :: (RenamingRelation i) -> (RuleTau i) -> (Process i) -> RuleTau i
LinkTauR :: (RenamingRelation i) -> (Process i) -> (RuleTau i) -> RuleTau i
LinkTickL :: (RenamingRelation i) -> (RuleTick i) -> (Process i) -> RuleTau i
LinkTickR :: (RenamingRelation i) -> (Process i) -> (RuleTick i) -> RuleTau i
ExceptionTauL :: (EventSet i) -> (RuleTau i) -> (Process i) -> RuleTau i
ExceptionTauR :: (EventSet i) -> (Process i) -> (RuleTau i) -> RuleTau i
TraceSwitchOn :: (Process i) -> RuleTau i

-- | Representation of tick proof trees.
data RuleTick i
SkipTick :: RuleTick i
HiddenTick :: (EventSet i) -> (RuleTick i) -> RuleTick i
InterruptTick :: (RuleTick i) -> (Process i) -> RuleTick i
TimeoutTick :: (RuleTick i) -> (Process i) -> RuleTick i
ShareOmega :: (EventSet i) -> RuleTick i
AParallelOmega :: (EventSet i) -> (EventSet i) -> RuleTick i
RepAParallelOmega :: [EventSet i] -> RuleTick i
InterleaveOmega :: RuleTick i
ExtChoiceTickL :: (RuleTick i) -> (Process i) -> RuleTick i
ExtChoiceTickR :: (Process i) -> (RuleTick i) -> RuleTick i
RenamingTick :: (RenamingRelation i) -> (RuleTick i) -> RuleTick i
LinkParallelTick :: (RenamingRelation i) -> RuleTick i

-- | Representation of regular proof trees.
data RuleEvent i
HPrefix :: (Event i) -> (Prefix i) -> RuleEvent i
ExtChoiceL :: (RuleEvent i) -> (Process i) -> RuleEvent i
ExtChoiceR :: (Process i) -> (RuleEvent i) -> RuleEvent i
InterleaveL :: (RuleEvent i) -> (Process i) -> RuleEvent i
InterleaveR :: (Process i) -> (RuleEvent i) -> RuleEvent i
SeqNormal :: (RuleEvent i) -> (Process i) -> RuleEvent i
NotHidden :: (EventSet i) -> (RuleEvent i) -> RuleEvent i
NotShareL :: (EventSet i) -> (RuleEvent i) -> (Process i) -> RuleEvent i
NotShareR :: (EventSet i) -> (Process i) -> (RuleEvent i) -> RuleEvent i
Shared :: (EventSet i) -> (RuleEvent i) -> (RuleEvent i) -> RuleEvent i
AParallelL :: (EventSet i) -> (EventSet i) -> (RuleEvent i) -> (Process i) -> RuleEvent i
AParallelR :: (EventSet i) -> (EventSet i) -> (Process i) -> (RuleEvent i) -> RuleEvent i
AParallelBoth :: (EventSet i) -> (EventSet i) -> (RuleEvent i) -> (RuleEvent i) -> RuleEvent i
RepAParallelEvent :: [EventRepAPart i] -> RuleEvent i
NoInterrupt :: (RuleEvent i) -> (Process i) -> RuleEvent i
InterruptOccurs :: (Process i) -> (RuleEvent i) -> RuleEvent i
TimeoutNo :: (RuleEvent i) -> (Process i) -> RuleEvent i
Rename :: (RenamingRelation i) -> (Event i) -> (RuleEvent i) -> RuleEvent i
RenameNotInDomain :: (RenamingRelation i) -> (RuleEvent i) -> RuleEvent i
ChaosEvent :: (EventSet i) -> (Event i) -> RuleEvent i
LinkEventL :: (RenamingRelation i) -> (RuleEvent i) -> (Process i) -> RuleEvent i
LinkEventR :: (RenamingRelation i) -> (Process i) -> (RuleEvent i) -> RuleEvent i
NoException :: (EventSet i) -> (RuleEvent i) -> (Process i) -> RuleEvent i
ExceptionOccurs :: (EventSet i) -> (Process i) -> (RuleEvent i) -> RuleEvent i
type EventRepAPart i = Either (EventSet i, Process i) (EventSet i, RuleEvent i)
instance Typeable Rule
instance (Eq (RuleEvent i), Eq (RuleTick i), Eq (RuleTau i)) => Eq (Rule i)
instance (Show (RuleEvent i), Show (RuleTick i), Show (RuleTau i)) => Show (Rule i)
instance (Ord (RuleEvent i), Ord (RuleTick i), Ord (Process i), Ord (EventSet i), Ord (ExtProcess i), Ord (Prefix i), Ord (Event i), Ord (RenamingRelation i)) => Ord (RuleTau i)
instance (Eq (RuleEvent i), Eq (RuleTick i), Eq (Process i), Eq (EventSet i), Eq (RenamingRelation i)) => Eq (RuleTau i)
instance (Show (RuleEvent i), Show (RuleTick i), Show (Process i), Show (EventSet i), Show (RenamingRelation i)) => Show (RuleTau i)
instance (Ord (Process i), Ord (EventSet i), Ord (Prefix i), Ord (ExtProcess i), Ord (RenamingRelation i)) => Ord (RuleTick i)
instance (Eq (Process i), Eq (EventSet i), Eq (Prefix i), Eq (ExtProcess i), Eq (RenamingRelation i)) => Eq (RuleTick i)
instance (Show (Process i), Show (EventSet i), Show (Prefix i), Show (ExtProcess i), Show (RenamingRelation i)) => Show (RuleTick i)
instance (Ord (Event i), Ord (Prefix i), Ord (Process i), Ord (ExtProcess i), Ord (EventSet i), Ord (RenamingRelation i)) => Ord (RuleEvent i)
instance (Eq (Event i), Eq (Prefix i), Eq (Process i), Eq (ExtProcess i), Eq (EventSet i), Eq (RenamingRelation i)) => Eq (RuleEvent i)
instance (Show (Event i), Show (Prefix i), Show (Process i), Show (ExtProcess i), Show (EventSet i), Show (RenamingRelation i)) => Show (RuleEvent i)


-- | A checker for the firing rules semantics of CSPM.
--   
--   <a>viewRuleMaybe</a> checks that a proof tree is valid with respect to
--   the firing rules semantics of CSPM. It checks that the proof tree is
--   syntactically valid and that all side conditions hold.
--   
--   The <a>Rule</a> data type stores proof trees in a compressed form.
--   <a>viewRuleMaybe</a> constructs an explicit representation of the
--   transition.
--   
--   <a>viewRule</a> calls <a>viewRuleMaybe</a> and throws an exception if
--   the proof tree was not valid. The proof tree generators in this
--   package only generate valid proof trees. <a>viewRule</a> is used to
--   check that assertion.
module CSPM.FiringRules.Verifier

-- | This function constructs an explict representation of the transition
--   from the proof tree of the transition. The transition as a triple
--   (predecessor <a>Process</a>, Event, successor <a>Process</a>). If the
--   proof tree is invalid it throws an exception.
viewRule :: BL i => Rule i -> (Process i, TTE i, Process i)

-- | Like <a>viewRule</a> but just return the predecessor process.
viewProcBefore :: BL i => Rule i -> Process i

-- | Like <a>viewRule</a> but just return the event.
viewEvent :: BL i => Rule i -> TTE i

-- | Like <a>viewRule</a> but just return the successor process.
viewProcAfter :: BL i => Rule i -> Process i

-- | Like <a>viewRule</a> but returns <a>Nothing</a> in case of an invalid
--   proof tree.
viewRuleMaybe :: BL i => Rule i -> Maybe (Process i, TTE i, Process i)

-- | Check a tau rule.
viewRuleTau :: BL i => RuleTau i -> Maybe (Process i, Process i)

-- | Check a tick rule.
viewRuleTick :: BL i => RuleTick i -> Maybe (Process i)

-- | Check a regular rule
viewRuleEvent :: BL i => RuleEvent i -> Maybe (Process i, Event i, Process i)


-- | Brute-force computation of all possible transitions of a process.
--   Enumerates all events in <a>Sigma</a>.
module CSPM.FiringRules.EnumerateEvents

-- | Compute all possible transitions (via an event from Sigma) for a
--   process.
computeTransitions :: BL i => Sigma i -> Process i -> Search (Rule i)
eventTransitions :: BL i => Sigma i -> Process i -> Search (RuleEvent i)
tauTransitions :: BL i => Process i -> Search (RuleTau i)
tickTransitions :: BL i => Process i -> Search (RuleTick i)


-- | Reexport of the functions from EnumerateEvents with a List interface.
module CSPM.FiringRules.EnumerateEventsList

-- | Compute all possible transitions (via an event from Sigma) for a
--   Process.
computeTransitions :: BL i => Sigma i -> Process i -> [Rule i]
eventTransitions :: BL i => Sigma i -> Process i -> [RuleEvent i]
tauTransitions :: BL i => Process i -> [RuleTau i]
tickTransitions :: BL i => Process i -> [RuleTick i]


-- | Field-wise generation of transitions. Uses some kind of abstract
--   interpretation/constraint propagation to avoid enumeration of
--   <tt>Sigma</tt> in some cases.
module CSPM.FiringRules.FieldConstraintsSearch
computeTransitions :: BF i => Sigma i -> Process i -> Search (Rule i)
eventTransitions :: BF i => EventSet i -> Process i -> Search (RuleEvent i)
tauTransitions :: BF i => Process i -> Search (RuleTau i)
tickTransitions :: BL i => Process i -> Search (RuleTick i)
instance Show (RepAP i)


-- | Reexport of the functions from FieldConstraintsSearch with a List
--   interface.
module CSPM.FiringRules.FieldConstraints

-- | Compute all possible transitions of the process.
computeTransitions :: BF i => Sigma i -> Process i -> [Rule i]

-- | Compute all (event)- transitions of the process.
eventTransitions :: BF i => Sigma i -> Process i -> [RuleEvent i]

-- | Compute all tau-transitions of the process
tauTransitions :: BF i => Process i -> [RuleTau i]

-- | Compute all tick-transitions of the process
tickTransitions :: BF i => Process i -> [RuleTick i]


-- | Some helper classes. (Might be deleted or moved somewhere else some
--   time.)
module CSPM.FiringRules.HelperClasses

-- | Implementation i supports <a>Eq</a> and <a>Ord</a>.
class (Eq (Process i), Eq (RuleTick i), Eq (RuleTau i), Eq (RuleEvent i), Eq (EventSet i), Eq (ExtProcess i), Eq (Prefix i), Eq (Event i), Eq (RenamingRelation i), Ord (Process i), Ord (RuleTick i), Ord (RuleTau i), Ord (RuleEvent i), Ord (EventSet i), Ord (ExtProcess i), Ord (Prefix i), Ord (Event i), Ord (RenamingRelation i)) => EqOrd i

-- | Implementation i supports <a>Show</a>.
class (Show (TTE i), Show (Rule i), Show (Process i), Show (RuleTick i), Show (RuleTau i), Show (RuleEvent i)) => FShow i

-- | <a>CSP1</a> means that implementation i supports the base language.
class (EqOrd i, BL i) => CSP1 i

-- | <a>CSP2</a> means that implementation i supports the base language and
--   multi-field events.
class (EqOrd i, BF i, CSP1 i) => CSP2 i


-- | A very rudimentary process tracer for debugging and testing. Prints
--   the current process and the possible transitions to stdout and lets
--   the user select a transition by typing to stdin.
module CSPM.FiringRules.Trace

-- | A simplistic interactive CSP-M tracer. It prints all events offered by
--   a Proccess to stdout and promts the user for the event to perform.
trace :: (FShow i, ShowTTE e, CSP2 i, e ~ TTE i) => Sigma i -> Process i -> IO ()


-- | QuickCheck tests for the proof tree generators in module
--   CSPM.FiringRules.EnumerateEvents and
--   CSPM.FiringRules.FieldConstraints. These QuickCheck properties check
--   for soundness, completeness and that both proof tree generators yield
--   the same result.
module CSPM.FiringRules.Test.Test

-- | Run a number of QuickCheck tests (with fixed seed).
main :: IO ()
