-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sculpt mutable recursive data with reference equality; bake it using a data kiln into an immutable lazy structure
--   
--   We functional programmers know that mutable state is unglamorous, but
--   sometimes useful. Data.Kiln lets you create and manipulate mutable
--   recursive structures (Clay) in the Squishy monad (built over ST), then
--   once you're finished with mutation, bake them into immutable, pure,
--   lazy data. The library is polymorphic in the shape of each mutable
--   node in the graph, requiring only that it be Traversable, which means
--   that all sorts of structures, from cons-cells to tagged state
--   diagrams, can be represented and manipulated safely and efficiently,
--   with an ultimately pure output.
@package data-kiln
@version 0.1.0.0

module Control.Monad.Squishy

-- | The Squishy monad is a monad with mutable references and optional
--   reference identity
data Squishy s a

-- | Runs a Squishy computation, returning a pure value
runSquishy :: (forall s. Squishy s a) -> a

-- | A unique identifier. Only possible to create while making a Distinct
--   value.
data Identifier s

-- | Data with faked reference equality; the interface provided guarantees
--   that every Distinct value has a unique Identifier.
data Distinct s a

-- | The only way to create a Distinct value is to generate a new
--   identifier for it in the Squishy monad.
distinguish :: a -> Squishy s (Distinct s a)

-- | Extracts the value stored in a Distinct
conflate :: Distinct s a -> a

-- | Extracts the unique identifier for a Distinct
identify :: Distinct s a -> Identifier s

-- | A mutable reference in the <tt>Squishy</tt> monad.
data Ref s a

-- | Make a new reference.
newRef :: a -> Squishy s (Ref s a)

-- | Read the value of a reference.
readRef :: Ref s a -> Squishy s a

-- | Write a new value to a reference.
writeRef :: Ref s a -> a -> Squishy s ()

-- | Use the provided function to modify the contained value in a
--   reference.
modifyRef :: Ref s a -> (a -> a) -> Squishy s ()
instance Eq (Identifier s)
instance Ord (Identifier s)
instance Functor (Squishy s)
instance Applicative (Squishy s)
instance Monad (Squishy s)
instance Ord (Distinct s a)
instance Eq (Distinct s a)

module Data.Kiln

-- | A <tt>Clay s f</tt> is a recursive structure with a
--   uniquely-identified mutable reference at each node. It cannot escape
--   the <tt>Squishy</tt> monad, by means of the same mechanism as used in
--   <tt>Control.Monad.ST</tt>.
data Clay s f

-- | Take a container <tt>f (Clay s f)</tt>, and wrap it in a new mutable
--   reference and distinct tag, returning a new <tt>Clay s f</tt>.
newClay :: f (Clay s f) -> Squishy s (Clay s f)

-- | Takes a <tt>Clay s f</tt> and exposes the first level of <tt>f (Clay s
--   f)</tt> inside it.
readClay :: Clay s f -> Squishy s (f (Clay s f))

-- | Use the provided function to destructively update the value at this
--   node of a <tt>Clay s f</tt>.
modifyClay :: Clay s f -> (f (Clay s f) -> f (Clay s f)) -> Squishy s ()

-- | Set a piece of <tt>Clay</tt> to a particular value.
writeClay :: Clay s f -> f (Clay s f) -> Squishy s ()

-- | Get the unique <tt>Identifier</tt> for a piece of <tt>Clay</tt>.
identifyClay :: Clay s f -> Identifier s

-- | Freeze a Clay using the identity transformation, so that a Clay s f
--   turns into a Fix f.
kiln :: Traversable f => Clay s f -> Squishy s (Fix f)

-- | Given a <tt>Clay s f</tt>, use a natural transformation <tt>(forall a.
--   f a -&gt; g a)</tt> to convert it into the fixed-point of a the
--   functor <tt>g</tt> by eliminating the indirection of the mutable
--   references and using the distinct tags on the structure's parts to tie
--   knots where there are cycles in the original graph of references. TThe
--   result is an immutable cyclic lazy data structure.
kilnWith :: Traversable f => (forall a. f a -> g a) -> Clay s f -> Squishy s (Fix g)

-- | Given a <tt>Squishy</tt> monad action which returns a <tt>Clay s
--   f</tt>, run the action and use the provided natural transformation
--   during baking (see <a>kilnWith</a>).
runKilningWith :: Traversable f => (forall a. f a -> g a) -> (forall s. Squishy s (Clay s f)) -> Fix g

-- | Given a <tt>Squishy</tt> monad action which returns a <tt>Clay s
--   f</tt>, run the action and kiln the result.
runKilning :: Traversable f => (forall s. Squishy s (Clay s f)) -> Fix f

module Data.Kiln.Examples

-- | Apply a function to the value inside a Compose.
composedly :: (f (g a) -> f' (g' a')) -> Compose f g a -> Compose f' g' a'
type MSLL s a = Clay s (Compose ((,) a) Maybe)
type SLL a = Fix (Compose ((,) a) Maybe)
cons :: a -> Maybe (MSLL s a) -> Squishy s (MSLL s a)
setCar :: MSLL s a -> a -> Squishy s ()
setCdr :: MSLL s a -> Maybe (MSLL s a) -> Squishy s ()
list1 :: SLL Char
sllToList :: SLL a -> [a]
type MNode s n e = Clay s (Compose (Compose ((,) n) []) ((,) e))
type Node n e = Fix (Compose (Compose ((,) n) []) ((,) e))
node :: n -> [(e, MNode s n e)] -> Squishy s (MNode s n e)
emptyNode :: n -> Squishy s (MNode s n e)
readNode :: MNode s n e -> Squishy s (n, [(e, MNode s n e)])
relabelNode :: n -> MNode s n e -> Squishy s ()
editEdges :: ([(e, MNode s n e)] -> [(e, MNode s n e)]) -> MNode s n e -> Squishy s ()
addEdge :: e -> MNode s n e -> MNode s n e -> Squishy s ()
graph1 :: Node String String
