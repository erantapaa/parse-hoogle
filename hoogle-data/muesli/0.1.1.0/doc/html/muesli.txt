-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple document-oriented database
--   
--   <tt>muesli</tt> is a simple <a>MVCC</a> <a>document-oriented
--   database</a> featuring ACID transactions, automatic index management
--   and minimal boilerplate.
--   
--   Import the <a>Database.Muesli.Types</a> module to mark up your types
--   for indexing, <a>Database.Muesli.Query</a> for writing and running
--   queries, and <a>Database.Muesli.Handle</a> for database management.
--   The rest of the modules are internal, but exposed just in case.
--   
--   See the README.md file for an usage example.
@package muesli
@version 0.1.1.0


-- | LRU cache implementation using the <a>psqueues</a> package.
--   
--   This module should be imported qualified.
module Database.Muesli.Cache

-- | Holds a <a>Dynamic</a> and the size of the corresponding serialized
--   data.
data DynValue
[DynValue] :: !Dynamic -> !Int -> DynValue
[dynValue] :: DynValue -> !Dynamic
[dynSize] :: DynValue -> !Int

-- | A LRU cache that uses a lower capacity in periods of inactivity. This
--   behaviour would be useful for things like long lived Android services.
data LRUCache
[LRUCache] :: !Int -> !Int -> !NominalDiffTime -> !Int -> !(IntPSQ UTCTime DynValue) -> LRUCache

-- | Minimum capacity under which <a>maxAge</a> is ignored
[minCapacity] :: LRUCache -> !Int

-- | Maximum capacity above which oldest items are removed
[maxCapacity] :: LRUCache -> !Int
[maxAge] :: LRUCache -> !NominalDiffTime

-- | Current size (in bytes) of the cache
[size] :: LRUCache -> !Int
[queue] :: LRUCache -> !(IntPSQ UTCTime DynValue)

-- | Creates an empty cache.
empty :: Int -> Int -> NominalDiffTime -> LRUCache

-- | Adds a new item to the cache, and <a>trim</a>s.
insert :: Typeable a => UTCTime -> Int -> a -> Int -> LRUCache -> LRUCache

-- | Looks up an item into the cache. If found, it updates the access time
--   for the item, and then <a>trim</a>s.
lookup :: Typeable a => UTCTime -> Int -> LRUCache -> Maybe (a, Int, LRUCache)

-- | Deletes an item from the cache.
delete :: Int -> LRUCache -> LRUCache

-- | Apply cache's policy and removes items if necessary.
trim :: UTCTime -> LRUCache -> LRUCache
instance Show DynValue


-- | Muesli markup types and typeclasses.
--   
--   Normally, with the <tt>DeriveAnyClass</tt> and <tt>DeriveGeneric</tt>
--   extensions enabled, types can be marked up as documents with a
--   
--   <pre>
--   deriving (Generic, Serialize)
--   </pre>
--   
--   clause, and a separate empty <a>Document</a> instance.
--   
--   For structured field types, the following will suffice:
--   
--   <pre>
--   deriving (Generic, Serialize, Indexable)
--   </pre>
--   
--   Then <a>Reference</a>, <a>Sortable</a> and <a>Unique</a> can be used
--   inside document types to mark up the fields that should be
--   automatically indexed, becoming queryable with the primitives in
--   <a>Database.Muesli.Query</a>.
--   
--   The record syntax must be used, and the accesor name will become the
--   <a>Property</a> name used in queries.
module Database.Muesli.Types

-- | <a>Reference</a> fields are pointers to other <a>Document</a>s. They
--   are indexed automatically and can be queried with <a>filter</a>.
--   
--   To ensure type safety, use and store only references returned by the
--   primitive queries, like <a>insert</a>, <a>range</a> or <a>filter</a>.
--   Numerical instances like <a>Num</a> or <a>Integral</a> are provided to
--   support generic database programs that take the responsibility of
--   maintaining invariants upon themselves. In this context, type safety
--   means that it is impossible in normal operation to try and deserialize
--   a document at a wrong type or address (note that all primitive query
--   functions are polymorphic), and risk getting bogus data without errors
--   being reported.
newtype Reference a
[Reference] :: IxKey -> Reference a
[unReference] :: Reference a -> IxKey

-- | Marks a field available for sorting and <tt>range</tt> queries.
--   
--   Indexing requires a <a>ToKey</a> instance. Apart from the provided
--   <a>Bool</a>, <a>Int</a> and <a>DateTime</a> instances, there is an
--   overlappable fallback instance based on converting the <a>Show</a>
--   string representation to an <a>IxKey</a> by taking the first 4 or 8
--   bytes. This is good enough for primitive string sorting.
newtype Sortable a
[Sortable] :: a -> Sortable a
[unSortable] :: Sortable a -> a

-- | <a>Unique</a> fields act as primary keys, and can be queried with
--   <a>unique</a> and <a>updateUnique</a>. The <a>Hashable</a> instance is
--   used to generate the key.
--   
--   For fields that need to be both unique and sortable, use <a>Unique</a>
--   (<a>Sortable</a> a) rather then the other way around.
newtype Unique a
[Unique] :: a -> Unique a
[unUnique] :: Unique a -> a

-- | This class is used by the generic scrapper to extract indexable keys
--   from the fields of a <a>Document</a>. There are instances for
--   <a>Reference</a>, <a>Sortable</a> and <a>Unique</a>, a general
--   <a>Foldable</a> instance, and a special one for <a>Maybe</a> that
--   converts <a>Nothing</a> into 0, such that null values will be indexed
--   too, and become queryable with <a>filter</a>.
--   
--   Users are not expected to need writing instances for this class. They
--   can rather be generated automatically with the <tt>DeriveAnyClass</tt>
--   extension.
class Indexable a where getIxValues _ = [] isReference _ = False getUnique _ = Nothing
getIxValues :: Indexable a => a -> [IxKey]
isReference :: Indexable a => Proxy a -> Bool
getUnique :: Indexable a => a -> Maybe UniqueKey

-- | Class used by the generic key scrapper to extract indexing information
--   from user types. Only an empty instance needs to be added in user
--   code.
class (Typeable a, Generic a, Serialize a) => Document a where getIndexables = ggetIndexables "" . from
getIndexables :: Document a => a -> Indexables

-- | Data type used by the key scrapper to collect keys while traversing
--   generically user types.
data Indexables
[Indexables] :: [(String, DocumentKey)] -> [(String, SortableKey)] -> [(String, UniqueKey)] -> Indexables
[ixReferences] :: Indexables -> [(String, DocumentKey)]
[ixSortables] :: Indexables -> [(String, SortableKey)]
[ixUniques] :: Indexables -> [(String, UniqueKey)]

-- | Used inside indexes and as arguments to query primitives.
newtype IxKey
[IxKey] :: Int -> IxKey
[unIxKey] :: IxKey -> Int

-- | Class used to convert indexable field &amp; query argument values to
--   keys.
--   
--   It is possibly needed for users to write instances for
--   <a>IxKey</a>-convertible primitive types, other then the provided
--   <a>Bool</a>, <a>Int</a> and <a>DateTime</a>.
class ToKey a
toKey :: ToKey a => a -> IxKey

-- | Primary key for a document.
--   
--   Allocated by functions in the <a>Database.Muesli.IdSupply</a> module.
type DocumentKey = IxKey

-- | Key extracted from non-reference fields for building a
--   <a>SortIndex</a>.
type SortableKey = IxKey

-- | Key extracted from unique fields for building a <a>UniqueIndex</a>
type UniqueKey = IxKey

-- | Key generated by <a>Property</a> for building a <a>SortIndex</a> or a
--   <a>FilterIndex</a>.
type PropertyKey = IxKey

-- | With the <tt>OverloadedStrings</tt> extension, or directly using the
--   <a>IsString</a> instance, field names specified in query arguments are
--   converted to <a>Property</a>. An <a>IxKey</a> is computed by hashing
--   the property name together with the <a>TypeRep</a> of the phantom
--   argument. This key is used in indexes.
newtype Property a
[Property] :: (PropertyKey, String) -> Property a
[unProperty] :: Property a -> (PropertyKey, String)

-- | A <tt>newtype</tt> wrapper around <a>UTCTime</a> that has <a>Show</a>,
--   <a>Serialize</a> and <a>ToKey</a> instances.
newtype DateTime
[DateTime] :: UTCTime -> DateTime
[unDateTime] :: DateTime -> UTCTime

-- | Type for exceptions thrown by the database. During normal operation
--   these should never be thrown.
data DatabaseError

-- | Thrown when the log file is corrupted.
[LogParseError] :: String -> DatabaseError

-- | Thrown after deserialization errors. Holds starting position, size,
--   and a message.
[DataParseError] :: DocAddress -> DocSize -> String -> DatabaseError

-- | ID allocation failure. For instance, full address space on a 32 bit
--   machine.
[IdAllocationError] :: String -> DatabaseError

-- | Data allocation failure. Containes the size requested, the biggest
--   available gap, and a message.
[DataAllocationError] :: DocSize -> (Maybe DocSize) -> String -> DatabaseError

-- | Transaction ids are auto-incremented globally. See
--   <a>mkNewTransactionId</a>.
type TransactionId = Word64

-- | Address in the abstract data file of a serialized document's data.
--   
--   These addresses are allocated by functions in the module
--   <a>Database.Muesli.Allocator</a>.
type DocAddress = Word64

-- | Size of a serialized document's data.
type DocSize = Word64
instance Show Indexables
instance Serialize a => Serialize (Unique a)
instance Eq a => Eq (Unique a)
instance Serialize a => Serialize (Sortable a)
instance Bounded a => Bounded (Sortable a)
instance Ord a => Ord (Sortable a)
instance Eq a => Eq (Sortable a)
instance Serialize (Reference a)
instance Integral (Reference a)
instance Real (Reference a)
instance Enum (Reference a)
instance Num (Reference a)
instance Bounded (Reference a)
instance Ord (Reference a)
instance Eq (Reference a)
instance Serialize IxKey
instance Storable IxKey
instance FiniteBits IxKey
instance Bits IxKey
instance Integral IxKey
instance Real IxKey
instance Enum IxKey
instance Num IxKey
instance Bounded IxKey
instance Ord IxKey
instance Eq IxKey
instance Show DatabaseError
instance FormatTime DateTime
instance ParseTime DateTime
instance Data DateTime
instance Ord DateTime
instance Eq DateTime
instance Show DateTime
instance Serialize DateTime
instance Exception DatabaseError
instance Show IxKey
instance Eq (Property a)
instance Show (Property a)
instance Typeable a => IsString (Property a)
instance Show (Reference a)
instance Show a => Show (Sortable a)
instance ToKey (Sortable IxKey)
instance ToKey (Sortable Bool)
instance ToKey (Sortable Int)
instance ToKey (Sortable DateTime)
instance [overlappable] Show a => ToKey (Sortable a)
instance Show a => Show (Unique a)
instance Hashable a => ToKey (Unique (Sortable a))
instance [overlappable] Hashable a => ToKey (Unique a)
instance Indexable (Reference a)
instance Indexable (Maybe (Reference a))
instance [overlappable] (Indexable a, Foldable f) => Indexable (f a)
instance Indexable Bool
instance Indexable Int
instance Indexable String
instance ToKey (Sortable a) => Indexable (Sortable a)
instance (Hashable a, Indexable (Sortable a)) => Indexable (Unique (Sortable a))
instance [overlappable] Hashable a => Indexable (Unique a)
instance GetIndexables U1
instance (GetIndexables a, GetIndexables b) => GetIndexables (a :*: b)
instance (GetIndexables a, GetIndexables b) => GetIndexables (a :+: b)
instance GetIndexables a => GetIndexables (M1 D c a)
instance GetIndexables a => GetIndexables (M1 C c a)
instance (GetIndexables a, Selector c) => GetIndexables (M1 S c a)
instance Indexable a => GetIndexables (K1 i a)


-- | Generic backend interface types and classes.
--   
--   This module is re-exported by other modules, like
--   <a>Database.Muesli.Handle</a>.
module Database.Muesli.Backend.Types

-- | This type represents a line in the transaction log file. There can be
--   multiple lines for a single transaction, and the last one must be a
--   <a>Completed</a> one. Other than that, the lines from multiple
--   transactions can be mixed.
data TransRecord
[Pending] :: LogRecord -> TransRecord
[Completed] :: TransactionId -> TransRecord

-- | Holds the metadata for a given document version.
--   
--   Keys collected by the generic scrapper are stored in
--   <a>recReferences</a>, <a>recSortables</a>, and <a>recUniques</a>. The
--   <a>recDocumentKey</a> is generated by an <a>IdSupply</a>, while the
--   <a>recAddress</a> and <a>recSize</a> are allocated by <a>alloc</a>.
--   This work is done either by the primitive queries in
--   <a>Database.Muesli.Query</a>, or by <a>runQuery</a>.
data LogRecord
[LogRecord] :: !TransactionId -> !DocumentKey -> ![(PropertyKey, DocumentKey)] -> ![(PropertyKey, SortableKey)] -> ![(PropertyKey, UniqueKey)] -> !DocAddress -> !DocSize -> !Bool -> LogRecord
[recTransactionId] :: LogRecord -> !TransactionId
[recDocumentKey] :: LogRecord -> !DocumentKey
[recReferences] :: LogRecord -> ![(PropertyKey, DocumentKey)]
[recSortables] :: LogRecord -> ![(PropertyKey, SortableKey)]
[recUniques] :: LogRecord -> ![(PropertyKey, UniqueKey)]
[recAddress] :: LogRecord -> !DocAddress
[recSize] :: LogRecord -> !DocSize
[recDeleted] :: LogRecord -> !Bool

-- | Provides stateful access to an abstract log file handle.
class (Show a, DbHandle (LogHandleOf a), DataHandle (DataHandleOf a)) => LogState a where type family LogHandleOf a :: * type family DataHandleOf a :: *
logHandle :: LogState a => a -> LogHandleOf a
logInit :: (LogState a, MonadIO m) => LogHandleOf a -> m a
logAppend :: (LogState a, MonadIO m) => a -> [TransRecord] -> m a
logRead :: (LogState a, MonadIO m) => a -> m (Maybe TransRecord)

-- | Handle used to access serialized document data in the generic data
--   file.
class DbHandle a => DataHandle a
readDocument :: (DataHandle a, MonadIO m) => a -> LogRecord -> m ByteString
writeDocument :: (DataHandle a, MonadIO m) => LogRecord -> ByteString -> a -> m ()

-- | Generic path type. For instance, this can be a file path or an url.
type DbPath = String

-- | Generic handle interface.
class DbHandle a
openDb :: (DbHandle a, MonadIO m) => DbPath -> m a
closeDb :: (DbHandle a, MonadIO m) => a -> m ()
withDb :: (DbHandle a, MonadIO m) => DbPath -> (a -> IO b) -> m b
swapDb :: (DbHandle a, MonadIO m) => DbPath -> DbPath -> m a
instance Show TransRecord
instance Show LogRecord


-- | Binary seekable file backend that uses <tt>Prelude</tt> functions.
--   
--   Only one process at a time can safely use the files, but file locking
--   is not yet implemented.
module Database.Muesli.Backend.File

-- | <tt>newtype</tt> wrapper around <a>Handle</a>, so that we can
--   accomodate other instances.
data FileHandle

-- | Implements a stateful binary log file backend.
--   
--   It uses a <a>FileHandle</a> for both the log and data files.
data FileLogState
[FileLogState] :: FileHandle -> DocAddress -> DocSize -> FileLogState

-- | The <a>Handle</a> for the log file
[flogHandle] :: FileLogState -> FileHandle

-- | Current valid position in the (quasi)append-only log file. Located at
--   address 0 of the log file, it is the last write performd as part of a
--   batch <a>logAppend</a> operation, which makes it atomic.
[flogPos] :: FileLogState -> DocAddress

-- | Current size of the log file. <a>logAppend</a> first checks the file
--   size and increases it with minimum 4KB if necessary, then writes the
--   records, and then updates the <a>flogPos</a>.
[flogSize] :: FileLogState -> DocSize
instance Show FileLogState
instance Show FileHandle
instance Eq FileHandle
instance DbHandle FileHandle
instance DataHandle FileHandle
instance LogState FileLogState


-- | Unique <a>DocumentKey</a> allocation functions.
--   
--   Since we use <a>IntMap</a>s for our indexes, a (faster)
--   auto-incremented key will be exhausted on 32 bit machines before we
--   reach a <a>maxBound</a> number of documents, because deleted keys
--   cannot be reused.
--   
--   This module should be imported qualified.
module Database.Muesli.IdSupply

-- | A map from keys to gap sizes.
type IdSupply = IntMap Int

-- | Holds a single gap of size <a>maxBound</a> - 1, starting at address 1.
empty :: IdSupply

-- | Removes a key from the supply. Used during log loading.
reserve :: DocumentKey -> IdSupply -> IdSupply

-- | Allocates a fresh key from the supply.
--   
--   Favours smallest numbers. For instance, after a document is deleted
--   and garbage collected, the <a>DocumentKey</a> of that document
--   typically becomes the smallest, and thus the first available. For this
--   reason, <a>IdSupply</a> will normally be small and efficient.
alloc :: IdSupply -> (DocumentKey, IdSupply)


-- | The internal state of the database.
module Database.Muesli.State

-- | Handle used for database management operations.
--   
--   The <tt>l</tt> parameter stands for a <a>LogState</a> backend.
newtype Handle l
[Handle] :: DBState l -> Handle l
[unHandle] :: Handle l -> DBState l

-- | The internal state of the database.
data DBState l
[DBState] :: DbPath -> DbPath -> Int -> MVar (MasterState l) -> MVar (DataState l) -> MVar Bool -> MVar GCState -> DBState l
[logDbPath] :: DBState l -> DbPath
[dataDbPath] :: DBState l -> DbPath
[commitDelay] :: DBState l -> Int
[masterState] :: DBState l -> MVar (MasterState l)
[dataState] :: DBState l -> MVar (DataState l)

-- | Used to send the kill signal to the <a>commitThread</a>
[commitSgn] :: DBState l -> MVar Bool

-- | Used to communicate with the <a>gcThread</a>
[gcState] :: DBState l -> MVar GCState

-- | Type of the master state, holding all indexes.
--   
--   When talking about <i>master lock</i> in other parts, we mean taking
--   the <a>masterState</a> <a>MVar</a>.
data MasterState l
[MasterState] :: !l -> !TransactionId -> !IdSupply -> !Bool -> !GapsIndex -> !PendingIndex -> !CompletedIndex -> !MainIndex -> !UniqueIndex -> !SortIndex -> !FilterIndex -> MasterState l

-- | The <a>LogState</a> backend.
[logState] :: MasterState l -> !l

-- | Auto-incremented global value for generating <a>TransactionId</a>s.
[topTid] :: MasterState l -> !TransactionId

-- | Suppy for generating unique <a>DocumentKey</a>s.
[idSupply] :: MasterState l -> !IdSupply

-- | This flag is set during GC, so that <a>logComp</a> is not cleared as
--   normal, since we need at the end of the GC to find the transactions
--   that completed in the mean time, and we don't want to do log file IO
--   for that.
[keepTrans] :: MasterState l -> !Bool
[gaps] :: MasterState l -> !GapsIndex
[logPend] :: MasterState l -> !PendingIndex
[logComp] :: MasterState l -> !CompletedIndex
[mainIdx] :: MasterState l -> !MainIndex
[unqIdx] :: MasterState l -> !UniqueIndex
[sortIdx] :: MasterState l -> !SortIndex
[refIdx] :: MasterState l -> !FilterIndex

-- | The state coresponding to the data file.
data DataState l
[DataState] :: !(DataHandleOf l) -> !LRUCache -> DataState l
[dataHandle] :: DataState l -> !(DataHandleOf l)
[dataCache] :: DataState l -> !LRUCache

-- | Type for the state of the GC thread used for messaging.
data GCState
[IdleGC] :: GCState
[PerformGC] :: GCState
[KillGC] :: GCState

-- | Type of the allocation table of the database.
--   
--   The key of the <a>IntMap</a> is the <a>DocumentKey</a> of the
--   corresponding document.
type MainIndex = IntMap [LogRecord]

-- | A map from gap size to a list of addresses where gaps of that size
--   start.
type GapsIndex = Map DocSize [DocAddress]

-- | Type of the sort index, which an <a>inverted index</a>.
--   
--   First key is <a>PropertyKey</a>, second is <a>SortableKey</a>, and the
--   <a>IntSet</a> contains all <a>DocumentKey</a>s for the documents whose
--   fields have the values specified by the first two keys.
type SortIndex = IntMap (IntMap IntSet)

-- | Type of the filter index, which is a 2-level nested <a>inverted
--   index</a>.
--   
--   First key is the <a>PropertyKey</a> for the filter field, second is
--   the <a>DocumentKey</a> of the filter field value, and then an entire
--   <a>SortIndex</a> containing the ordered subset for all sortable
--   fields.
type FilterIndex = IntMap (IntMap SortIndex)

-- | Type of the unique index, which is a simpler <a>inverted index</a>.
--   
--   First key is <a>PropertyKey</a>, second is the <a>UniqueKey</a>, and
--   then the unique <a>DocumentKey</a> corresponding to that
--   <a>UniqueKey</a>.
type UniqueIndex = IntMap (IntMap Int)

-- | The type of the pending transaction log.
--   
--   <a>update</a> serializes the document before adding it to
--   <a>transUpdateList</a>, and later <a>commitThread</a> moves it in the
--   pending log.
type PendingIndex = Map TransactionId [(LogRecord, ByteString)]

-- | The type of the completed transaction log.
type CompletedIndex = Map TransactionId [LogRecord]

-- | Standard <a>bracket</a> function for the <a>masterState</a> lock.
withMasterLock :: MonadIO m => Handle l -> (MasterState l -> IO a) -> m a

-- | Standard <a>bracket</a> function for the <a>masterState</a> lock that
--   also allows updating the <a>MasterState</a>.
withMaster :: MonadIO m => Handle l -> (MasterState l -> IO (MasterState l, a)) -> m a

-- | Standard <a>bracket</a> function for the <a>dataState</a> lock.
withDataLock :: MonadIO m => Handle l -> (DataState l -> IO a) -> m a

-- | Standard <a>bracket</a> function for the <a>dataState</a> lock that
--   also allows updating the <a>DataState</a>.
withData :: MonadIO m => Handle l -> (DataState l -> IO (DataState l, a)) -> m a

-- | Standard <a>bracket</a> function for the <a>gcState</a> lock that also
--   allows updating the <a>GCState</a>.
withGC :: MonadIO m => Handle l -> (GCState -> IO (GCState, a)) -> m a

-- | Standard <a>bracket</a> function for the <a>commitSgn</a> lock that
--   also allows updating the <a>Bool</a>.
withCommitSgn :: MonadIO m => Handle l -> (Bool -> IO (Bool, a)) -> m a

-- | Generates a new <a>TransactionId</a> by incrementing the <a>topTid</a>
--   under master lock.
mkNewTransactionId :: MonadIO m => Handle l -> m TransactionId

-- | Generates a new <a>DocumentKey</a> by calling <a>alloc</a> under
--   master lock.
mkNewDocumentKey :: MonadIO m => Handle l -> m DocumentKey

-- | Utility function for searching into a list of <a>LogRecord</a>s and
--   into their <a>recUniques</a> for a particular <a>UniqueKey</a>.
findUnique :: PropertyKey -> UniqueKey -> [(LogRecord, a)] -> Maybe DocumentKey
instance Eq (Handle l)
instance Eq GCState
instance Show (Handle l)
instance Eq (DBState l)


-- | Document data allocator.
--   
--   This module should be imported qualified.
module Database.Muesli.Allocator

-- | Creates an index holding a single gap starting at the given address.
empty :: DocAddress -> GapsIndex

-- | Adds a gap to the index.
add :: DocSize -> DocAddress -> GapsIndex -> GapsIndex

-- | Builds the index from the <a>LogRecord</a> data held in an
--   <a>MainIndex</a>.
--   
--   <b>O(n*log(n))</b> operation used by <a>open</a> after loading the
--   log.
build :: MainIndex -> GapsIndex

-- | Builds the index from a set of <a>LogRecord</a>s, with all space
--   before the given address considered reserved.
--   
--   Used by the garbage collector (see module <a>Database.Muesli.GC</a>).
buildExtra :: DocAddress -> [LogRecord] -> GapsIndex

-- | Allocates a new slot of the given size. The smallest available size in
--   the index is preferred.
--   
--   Throws <a>DataAllocationError</a> if no gap big enough is found.
alloc :: GapsIndex -> DocSize -> (DocAddress, GapsIndex)


-- | Incremental database index update functions. Except for
--   <a>updateMainIndex</a>, these functions first search for the previous
--   version for each record and, if found, remove the old references from
--   the index, then add the new ones.
--   
--   Used during loading, query evaluation, and GC.
module Database.Muesli.Indexes

-- | Updates the <a>MainIndex</a> (allocation table).
updateMainIndex :: MainIndex -> [LogRecord] -> MainIndex

-- | Updates the <a>FilterIndex</a>.
--   
--   Calls <a>updateSortIndex</a> for the internal sorted indexes.
updateFilterIndex :: MainIndex -> FilterIndex -> [LogRecord] -> FilterIndex

-- | Updates the main <a>SortIndex</a>, and also the <a>SortIndex</a>es
--   inside a <a>FilterIndex</a>.
updateSortIndex :: MainIndex -> SortIndex -> [LogRecord] -> SortIndex

-- | Updates the <a>UniqueIndex</a>.
updateUniqueIndex :: MainIndex -> UniqueIndex -> [LogRecord] -> UniqueIndex


-- | <a>Transaction</a> evaluation inside <a>MonadIO</a>.
module Database.Muesli.Commit

-- | Abstract monad for writing and evaluating queries under ACID
--   semantics.
--   
--   The <tt>l</tt> parameter stands for a <a>LogState</a> backend,
--   <tt>m</tt> is a <a>MonadIO</a> that gets lifted, so users can run
--   arbitrary IO inside queries, and <tt>a</tt> is the result.
newtype Transaction l m a
[Transaction] :: StateT (TransactionState l) m a -> Transaction l m a
[unTransaction] :: Transaction l m a -> StateT (TransactionState l) m a

-- | State held inside a <a>Transaction</a>.
data TransactionState l
[TransactionState] :: !(Handle l) -> !TransactionId -> ![DocumentKey] -> ![(LogRecord, ByteString)] -> TransactionState l
[transHandle] :: TransactionState l -> !(Handle l)

-- | Allocated by <a>runQuery</a> with <a>mkNewTransactionId</a>
--   (auto-incremental)
[transId] :: TransactionState l -> !TransactionId

-- | Accumulates all documents' keys that have been read as part of the
--   transaction. It is considered that all updates in the transaction may
--   depend of these, so the transaction is aborted if concurrent
--   transactions update any of them.
[transReadList] :: TransactionState l -> ![DocumentKey]

-- | Accumulates all updated or deleted documents' keys together with the
--   serialized data.
[transUpdateList] :: TransactionState l -> ![(LogRecord, ByteString)]

-- | <a>Transaction</a> evaluation inside a <a>MonadIO</a>.
--   
--   Lookups are executed directly, targeting a specific version
--   (<a>TransactionId</a>) , while the keys of both read and written
--   documents are collected in the <a>TransactionState</a>.
--   
--   At the end various consistency checks are performed, and the
--   transaction is aborted in case any fails. See <a>TransactionAbort</a>
--   for details.
--   
--   Otherwise, under master lock, space in the data (abstract) file is
--   allocated with <a>alloc</a>, and the transaction records are written
--   in the <a>logPend</a>, and also in the log file, with
--   <a>logAppend</a>.
--   
--   Writing the serialized data to the data file, updating indexes and
--   completing the transaction is then left for the <a>commitThread</a>.
--   Note that transactions are only durable after <a>commitThread</a>
--   finishes. In the future we may add a blocking version of
--   <a>runQuery</a>.
runQuery :: (MonadIO m, LogState l) => Handle l -> Transaction l m a -> m (Either TransactionAbort a)

-- | Error returned by <a>runQuery</a> for aborted transactions.
--   
--   It is an instance of <a>Exception</a> solely for user convenience, as
--   the database never throws it.
data TransactionAbort

-- | Returned when trying to update an <a>Unique</a> field with a
--   preexisting value.
[AbortUnique] :: String -> TransactionAbort

-- | Returned when there is a conflict with concurrent transactions. This
--   happenes when the <a>transUpdateList</a> of transactions in
--   <a>logPend</a> or <a>logComp</a> with <a>transId</a> &gt; then our own
--   <a>transId</a> has any keys that we also have in either
--   <a>transReadList</a>, or <a>transUpdateList</a>.
--   
--   The second part could be relaxed in the future based on a user policy,
--   since overwriting updates are sometimes acceptable.
[AbortConflict] :: String -> TransactionAbort

-- | Returned when trying to delete a document that is still referenced by
--   other documents.
--   
--   TODO: Current implementation is not completely safe in this regard, as
--   updates should also be checked. The reason is that the check is
--   performed on indexes and on the pending log. So there is a small
--   window in which it is possible for a concurrent transaction to update
--   a record deleted by the current one, before adding it to the pending
--   log, without any error.
[AbortDelete] :: String -> TransactionAbort

-- | Code for the commit thread forked by <a>open</a>.
--   
--   It periodically checks for new records in the <a>logPend</a>, and
--   processes them, by adding a <a>Completed</a> record to the log file
--   with <a>logAppend</a>, and updating indexes with
--   <a>updateMainIndex</a>, <a>updateFilterIndex</a>,
--   <a>updateSortIndex</a> and <a>updateUniqueIndex</a>, after writing
--   (without master lock) the serialized documents in the data file with
--   <a>writeDocument</a>. It also moves the records from <a>logPend</a> to
--   <a>logComp</a>.
commitThread :: LogState l => Handle l -> Bool -> IO ()
instance Show TransactionAbort
instance Monad m => Monad (Transaction l m)
instance Monad m => Applicative (Transaction l m)
instance Functor m => Functor (Transaction l m)
instance MonadIO m => MonadIO (Transaction l m)
instance Exception TransactionAbort


-- | The <a>Transaction</a> monad and its primitive queries.
--   
--   All queries in this module are run on indexes and perform an <b>O(log
--   n)</b> worst case operation.
--   
--   Functions whose name end in ' do the same operation as their
--   counterparts, but return only the keys, without performing any I/O.
--   They can be used to implement various kinds of joins not supported by
--   the primitive operations.
module Database.Muesli.Query

-- | Abstract monad for writing and evaluating queries under ACID
--   semantics.
--   
--   The <tt>l</tt> parameter stands for a <a>LogState</a> backend,
--   <tt>m</tt> is a <a>MonadIO</a> that gets lifted, so users can run
--   arbitrary IO inside queries, and <tt>a</tt> is the result.
data Transaction l m a

-- | <a>Transaction</a> evaluation inside a <a>MonadIO</a>.
--   
--   Lookups are executed directly, targeting a specific version
--   (<a>TransactionId</a>) , while the keys of both read and written
--   documents are collected in the <a>TransactionState</a>.
--   
--   At the end various consistency checks are performed, and the
--   transaction is aborted in case any fails. See <a>TransactionAbort</a>
--   for details.
--   
--   Otherwise, under master lock, space in the data (abstract) file is
--   allocated with <a>alloc</a>, and the transaction records are written
--   in the <a>logPend</a>, and also in the log file, with
--   <a>logAppend</a>.
--   
--   Writing the serialized data to the data file, updating indexes and
--   completing the transaction is then left for the <a>commitThread</a>.
--   Note that transactions are only durable after <a>commitThread</a>
--   finishes. In the future we may add a blocking version of
--   <a>runQuery</a>.
runQuery :: (MonadIO m, LogState l) => Handle l -> Transaction l m a -> m (Either TransactionAbort a)

-- | Error returned by <a>runQuery</a> for aborted transactions.
--   
--   It is an instance of <a>Exception</a> solely for user convenience, as
--   the database never throws it.
data TransactionAbort

-- | Returned when trying to update an <a>Unique</a> field with a
--   preexisting value.
[AbortUnique] :: String -> TransactionAbort

-- | Returned when there is a conflict with concurrent transactions. This
--   happenes when the <a>transUpdateList</a> of transactions in
--   <a>logPend</a> or <a>logComp</a> with <a>transId</a> &gt; then our own
--   <a>transId</a> has any keys that we also have in either
--   <a>transReadList</a>, or <a>transUpdateList</a>.
--   
--   The second part could be relaxed in the future based on a user policy,
--   since overwriting updates are sometimes acceptable.
[AbortConflict] :: String -> TransactionAbort

-- | Returned when trying to delete a document that is still referenced by
--   other documents.
--   
--   TODO: Current implementation is not completely safe in this regard, as
--   updates should also be checked. The reason is that the check is
--   performed on indexes and on the pending log. So there is a small
--   window in which it is possible for a concurrent transaction to update
--   a record deleted by the current one, before adding it to the pending
--   log, without any error.
[AbortDelete] :: String -> TransactionAbort

-- | Dereferences the given key. Returns <a>Nothing</a> if the key is not
--   found.
lookup :: (Document a, LogState l, MonadIO m) => Reference a -> Transaction l m (Maybe a)

-- | Inserts a new document and returns its key.
--   
--   The primary key is generated with <a>mkNewDocumentKey</a>.
insert :: (Document a, MonadIO m) => a -> Transaction l m (Reference a)

-- | Updates a document.
--   
--   Note that since <tt>muesli</tt> is a MVCC database, this means
--   inserting a new version of the document. The version number is the
--   <a>TransactionId</a> of the current transaction. This fact is
--   transparent to the user though.
update :: (Document a, MonadIO m) => Reference a -> a -> Transaction l m ()

-- | Deletes a document.
--   
--   Note that since <tt>muesli</tt> is a MVCC database, this means
--   inserting a new version with the <a>recDeleted</a> flag set to
--   <a>True</a>. But this fact is transparent to the user, since the
--   indexes are updated as if the record was really deleted.
--   
--   It will be the job of the <a>gcThread</a> to actually clean the
--   transaction log and compact the data file.
delete :: MonadIO m => Reference a -> Transaction l m ()

-- | Sort order for range queries.
data SortOrder
[SortAsc] :: SortOrder
[SortDesc] :: SortOrder

-- | Runs a range query on a <a>Sortable</a> field.
--   
--   It can be used as a cursor, for precise and efficient paging through a
--   large dataset. For this purpose you should remember the last
--   <a>Reference</a> from the previous page and give it as the
--   <i>sortKey</i> argument below. This is needed since the sortable field
--   may not have unique values, so remembering just the <i>sortVal</i> is
--   insufficient.
--   
--   The corresponding SQL is:
--   
--   <pre>
--   SELECT TOP page * FROM table
--   WHERE (sortVal = NULL OR sortFld &lt; sortVal) AND (sortKey = NULL OR ID &lt; sortKey)
--   ORDER BY sortFld, ID sortOrder
--   </pre>
range :: (Document a, ToKey (Sortable b), LogState l, MonadIO m) => Int -> Property a -> Maybe (Sortable b) -> Maybe (Reference a) -> SortOrder -> Transaction l m [(Reference a, a)]

-- | Like <a>range</a>, but returns only the keys.
range' :: (Document a, ToKey (Sortable b), MonadIO m) => Int -> Property a -> Maybe (Sortable b) -> Maybe (Reference a) -> SortOrder -> Transaction l m [Reference a]

-- | Runs a filter-and-range query on a <a>Reference</a> field, with
--   results sorted on a different <a>Sortable</a> field.
--   
--   Sending <a>Nothing</a> for <tt>filterVal</tt> filters for
--   <tt>NULL</tt> values, which correspond to a <a>Nothing</a> in a field
--   of type <a>Maybe</a> (<a>Reference</a> a). This uses the special
--   <a>Maybe</a> instance mentioned at the <a>Indexable</a> documentation.
--   
--   The paging behaviour is the same as for <a>range</a>.
--   
--   The corresponding SQL is:
--   
--   <pre>
--   SELECT TOP page * FROM table
--   WHERE (filterFld = filterVal) AND
--         (sortVal = NULL OR sortFld &lt; sortVal) AND (sortKey = NULL OR ID &lt; sortKey)
--   ORDER BY sortFld, ID sortOrder
--   </pre>
filterRange :: (Document a, ToKey (Sortable b), LogState l, MonadIO m) => Int -> Property a -> Maybe (Reference c) -> Property a -> Maybe (Sortable b) -> Maybe (Reference a) -> SortOrder -> Transaction l m [(Reference a, a)]

-- | Like <a>filterRange</a>, but returns only the keys.
filterRange' :: (Document a, ToKey (Sortable b), LogState l, MonadIO m) => Int -> Property a -> Maybe (Reference c) -> Property a -> Maybe (Sortable b) -> Maybe (Reference a) -> SortOrder -> Transaction l m [Reference a]

-- | Runs a filter query on a <a>Reference</a> field, with results sorted
--   on a different <a>Sortable</a> field.
--   
--   Like <a>filterRange</a>, but returns all documents, not just a range.
filter :: (Document a, LogState l, MonadIO m) => Property a -> Maybe (Reference b) -> Property a -> SortOrder -> Transaction l m [(Reference a, a)]

-- | Like <a>filter</a>, but returns only the keyes.
filter' :: (Document a, LogState l, MonadIO m) => Property a -> Maybe (Reference b) -> Property a -> SortOrder -> Transaction l m [Reference a]

-- | Returns a document uniquely determined by the given <a>Unique</a> key
--   value, or <a>Nothing</a> if the key is not found.
unique :: (Document a, LogState l, ToKey (Unique b), MonadIO m) => Property a -> Unique b -> Transaction l m (Maybe (Reference a, a))

-- | Returns a <a>Reference</a> to a document uniquely determined by the
--   given <a>Unique</a> key value, or <a>Nothing</a> if the key is not
--   found.
unique' :: (ToKey (Unique b), MonadIO m) => Property a -> Unique b -> Transaction l m (Maybe (Reference a))

-- | Performs a <a>unique'</a> and then, depending whether the key exists
--   or not, either <a>insert</a>s or <a>update</a>s the respective
--   document.
updateUnique :: (Document a, ToKey (Unique b), MonadIO m) => Property a -> Unique b -> a -> Transaction l m (Reference a)

-- | Returns the number of documents of type <tt>a</tt> in the database.
size :: (Document a, MonadIO m) => Property a -> Transaction l m Int
instance Show SortOrder
instance Eq SortOrder


-- | Asynchronous garbage collector for the database.
--   
--   The GC creates fresh copies of both the log and the data (abstract)
--   files, fully <i>cleaned</i>, respectively <i>compacted</i>, and
--   finally takes a master lock, appends the transaction data that was
--   added in the mean time, and uses the <a>swapDb</a> function to make
--   the new files current. No expensive lock needs to be taken in the
--   beginning, since all indexes are purely functional and we just take
--   some pointers.
--   
--   <i>Cleaning</i> means removal of all versions of deleted records, and
--   all but the most recent version for the rest.
--   
--   <i>Compacting</i> means all records are reallocated contiguously
--   starting from <a>DocAddress</a> 0. In particular, it creates a fresh
--   empty <a>gaps</a> index with the help of <a>buildExtra</a>.
--   
--   The complete operation takes <b>O(n*log(n))</b> time, but the lock is
--   held only for <b>O(k*log(n))</b> at the end, where k represents the
--   number of new records, which is similar to a normal query. For this
--   reason it is safe to run the GC at any time.
--   
--   The database does not call <a>performGC</a> by itself, but leaves this
--   to the user. Programs that only rarely <a>delete</a> or <a>update</a>
--   records don't even need to run the GC, or they can make it an admin
--   action.
module Database.Muesli.GC

-- | Code for the GC thread forked by <a>open</a>.
--   
--   It listens for messages sent by <a>performGC</a> through
--   <a>gcState</a>, and performs the GC operation.
gcThread :: LogState l => Handle l -> IO ()


-- | Database resource management.
module Database.Muesli.Handle

-- | Handle used for database management operations.
--   
--   The <tt>l</tt> parameter stands for a <a>LogState</a> backend.
data Handle l

-- | Opens a database, reads the transaction log and builds the in-memory
--   indexes.
--   
--   The <tt>l</tt> parameter of the resulting <a>Handle</a> should be
--   instantiated by the user in order to specify a backend. For example,
--   to use the file backend:
--   
--   <pre>
--   import qualified Database.Muesli.Handle as DB
--   
--   openDataBase :: FilePath -&gt; FilePath -&gt; IO (DB.Handle DB.FileLogState)
--   openDataBase logPath dataPath = open (Just logPath) (Just dataPath) Nothing Nothing
--   </pre>
open :: (MonadIO m, LogState l) => Maybe DbPath -> Maybe DbPath -> Maybe (Int, Int, NominalDiffTime) -> Maybe Int -> m (Handle l)

-- | Closes the database.
--   
--   Since the database is ACID, calling <a>close</a> is not really
--   necessary for consistency purposes.
close :: (MonadIO m, LogState l) => Handle l -> m ()

-- | Sends a message to the <a>gcThread</a> requesting GC.
performGC :: MonadIO m => Handle l -> m ()

-- | A debug function that traces the internal <a>DBState</a>.
debug :: (MonadIO m, LogState l) => Handle l -> Bool -> Bool -> m String
