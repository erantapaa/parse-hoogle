-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A backend agnostic, concurrent BTree
--   
--   A backend agnostic, concurrent BTree
@package btree-concurrent
@version 0.1.5

module Data.BTree.KVBackend.Util
atomicFileWrite :: [Char] -> ByteString -> IO ()
safeWriteFile :: [Char] -> ByteString -> IO ()
safeReadFile :: FilePath -> IO ByteString


-- | A hashtable in STM.
module Data.BTree.HashTable.STM
data HashTableSTM k v

-- | Create a new HashTable with fixed size
newSized :: Int -> IO (HashTableSTM k v)

-- | <i>O(log n)</i>. Insert a key/value pair into HashTable.
insert :: (Hashable k, Ord k) => HashTableSTM k v -> k -> v -> STM ()

-- | <i>O(log n)</i>. Lookup a key in HashTable.
lookup :: (Hashable k, Ord k) => HashTableSTM k v -> k -> STM (Maybe v)

-- | <i>O(log n)</i>. Delete a key from HashTable.
delete :: (Hashable k, Ord k) => HashTableSTM k v -> k -> STM ()

-- | <i>O(1)</i>. Grab the size of the hash table.
size :: HashTableSTM k v -> STM Int

-- | <i>O(n)</i>. Get a list of keys.
keys :: HashTableSTM k v -> STM [k]

-- | <i>O(n)</i>. Get a list of key/value pairs.
toList :: HashTableSTM k v -> STM [(k, v)]

module Data.BTree.KVBackend.Class
class Monad m => KVBackend m k v | m -> k, m -> v
store :: KVBackend m k v => k -> v -> m ()
fetch :: KVBackend m k v => k -> m (Maybe v)
remove :: KVBackend m k v => k -> m ()

module Data.BTree.KVBackend.Files
type Param = FilePath
newtype FilesKV a
FilesKV :: ReaderT Param IO a -> FilesKV a
runFilesKV :: FilesKV a -> ReaderT Param IO a
evalFilesKV :: FilePath -> FilesKV a -> IO a
traceThis :: Show b => b -> b
filePath :: Serialize k => k -> FilesKV FilePath
store :: (Serialize a, Serialize k) => k -> a -> FilesKV ()
fetch :: (Serialize k, Serialize a) => k -> FilesKV (Maybe a)
remove :: Serialize k => k -> FilesKV ()
instance Monad FilesKV
instance MonadIO FilesKV
instance MonadReader Param FilesKV
instance (Show k, Serialize k, Serialize v) => KVBackend FilesKV k v

module Data.BTree.Cache.Class
data R b
Inter :: (IO a) -> (a -> STM ()) -> R b
Final :: b -> R b
class Monad m => Cache m p k v | m -> p, p -> k, p -> v, p -> m
store :: Cache m p k v => Maybe k -> k -> v -> m ()
fetch :: Cache m p k v => k -> m (Maybe v)
remove :: Cache m p k v => Maybe k -> k -> m ()
sync :: Cache m p k v => p -> IO ()
eval :: Cache m p k v => p -> m a -> IO a

module Data.BTree.Cache.STM
data State k v
Read :: !(Maybe v) -> State k v
Write :: !(Maybe k) -> !(Maybe v) -> State k v
mtoS :: Maybe a -> [Char]
type AccessTime = UTCTime
data Exist
Exist :: Exist
NoExist :: Exist
data Ref k v
Ref :: TVar (Either (State k v) (State k v, Int, State k v)) -> TVar Exist -> Ref k v
refST :: Ref k v -> TVar (Either (State k v) (State k v, Int, State k v))
refExt :: Ref k v -> TVar Exist
data Param m k v
Param :: Int -> HashTableSTM k (Ref k (Either ByteString v)) -> (forall a. m a -> IO a) -> TVar [(k, Ref k v)] -> UTCTime -> TVar Int -> TVar Int -> Param m k v
cacheSize :: Param m k v -> Int
table :: Param m k v -> HashTableSTM k (Ref k (Either ByteString v))
toIO :: Param m k v -> forall a. m a -> IO a
flushQ :: Param m k v -> TVar [(k, Ref k v)]
timestamp :: Param m k v -> UTCTime
genId :: Param m k v -> TVar Int
genActive :: Param m k v -> TVar Int
trace :: a -> a
newtype CacheSTM m k v a
CacheSTM :: ReaderT (Param m k v) (ErrorT (IO ()) STM) a -> CacheSTM m k v a
runCacheSTM :: CacheSTM m k v a -> ReaderT (Param m k v) (ErrorT (IO ()) STM) a
stm :: (Monad (t1 m), Monad m, MonadTrans t, MonadTrans t1) => m a -> t (t1 m) a
evalCacheSTM :: Param m k v -> CacheSTM m k v a -> IO a
sizedParam :: Int -> (forall a. m a -> IO a) -> IO (Param m k v)
getRef :: (Monad (t1 STM), Ord k, Hashable k, MonadTrans t, MonadTrans t1, MonadError (IO ()) (t (t1 STM)), MonadReader (Param m k b) (t (t1 STM)), KVBackend m k ByteString) => k -> t (t1 STM) (Ref k (Either ByteString b))
newRef :: (Monad (t1 STM), Ord k, Hashable k, MonadTrans t, MonadTrans t1, MonadError (IO ()) (t (t1 STM)), MonadReader (Param m k v) (t (t1 STM)), KVBackend m k ByteString) => Maybe k -> k -> Maybe (Either ByteString v) -> t (t1 STM) ()
maybeQueue :: (Monad (t1 STM), MonadTrans t, MonadTrans t1, MonadReader (Param m k v) (t (t1 STM))) => Bool -> TVar (Either (State t2 t3) (State t6 t7, t4, t5)) -> (k, Ref k v) -> t (t1 STM) ()
store :: (Ord k, Hashable k, KVBackend m k ByteString) => Maybe k -> k -> v -> CacheSTM m k v ()
fetch :: (Ord k, Serialize v, Hashable k, KVBackend m k ByteString) => k -> CacheSTM m k v (Maybe v)
fetchGen :: (Ord k, Serialize v, Hashable k, KVBackend m k ByteString) => Int -> k -> CacheSTM m k v (Maybe v)
remove :: (Ord k, Hashable k, KVBackend m k ByteString) => Maybe k -> k -> CacheSTM m k v ()
updateTag :: (Ord k, Hashable k) => Maybe k -> k -> CacheSTM m k v ()
keys :: CacheSTM m k v [k]
debug :: (Show a, MonadIO m) => a -> m ()
getGen :: Eq a => a -> Either t (t, a, t) -> t
flipWrite :: Eq v => Maybe v -> Either (State k v) (State k1 v, t, State t1 v) -> Either (State k v) (State k1 v, t, State t1 v)
equals :: (Eq b, Serialize b) => State t (Either ByteString b) -> State t1 (Either ByteString b) -> Bool
value :: Serialize b => State t (Either ByteString b) -> Maybe b
withGeneration :: MonadIO m => Param m1 k v -> (Int -> m b) -> m b
flush :: (Ord t, Serialize a, Hashable t) => Param m t a -> IO ()
flushKey :: (Ord k1, Serialize a, Hashable k1) => HashTableSTM k1 v1 -> (k1, Ref t (Either ByteString a)) -> CacheSTM m k v (Maybe (Either (State t (Either ByteString a)) (State t (Either ByteString a), Int, State t (Either ByteString a))))
sync :: (Eq b, Ord t, Serialize b, KVBackend m t ByteString) => Param m t b -> IO ()
liftSTM :: STM a -> CacheSTM m k v a
fail :: IO () -> CacheSTM m k v a
instance (Eq k, Eq v) => Eq (State k v)
instance Eq Exist
instance Monad (CacheSTM m k v)
instance MonadReader (Param m k v) (CacheSTM m k v)
instance MonadError (IO ()) (CacheSTM m k v)
instance Functor (CacheSTM m k v)
instance (Show k, Serialize k, Serialize v, Ord k, Eq k, Eq v, Hashable k, KVBackend m k ByteString) => Cache (CacheSTM m k v) (Param m k v) k v
instance Error (IO ())
instance Show (State k v)

module Data.BTree.Types
newtype Ref a
Ref :: Word64 -> Ref a
data Node k v
Leaf :: (Map k v) -> Node k v
Branch :: [k] -> [Ref (Node k v)] -> Node k v
data Param st k v
Param :: Int -> TVar (Ref (Node k v)) -> st -> TChan k -> TVar [Ref (Node k v)] -> Param st k v
order :: Param st k v -> Int
root :: Param st k v -> TVar (Ref (Node k v))
state :: Param st k v -> st
marked :: Param st k v -> TChan k
unused :: Param st k v -> TVar [Ref (Node k v)]
newtype BTreeM m st k v a
BTreeM :: ReaderT (Param st k v) m a -> BTreeM m st k v a
runBTreeM :: BTreeM m st k v a -> ReaderT (Param st k v) m a
instance Show (Ref a)
instance Ord (Ref a)
instance Eq (Ref a)
instance Hashable (Ref a)
instance Num (Ref a)
instance (Eq k, Eq v) => Eq (Node k v)
instance Monad m => Monad (BTreeM m st k v)
instance MonadIO m => MonadIO (BTreeM m st k v)
instance Monad m => MonadReader (Param st k v) (BTreeM m st k v)
instance Functor m => Functor (BTreeM m st k v)
instance (Ord k, Serialize k, Serialize v) => Serialize (Node k v)
instance Serialize (Ref a)


-- | Concurrent BTree with relaxed balance.
--   
--   This module is inspired by the paper <i>B-Trees with Relaxed
--   Balance</i>, Kim S. Larsen and Rolf Fagerberg, 1993 Department of
--   Mathematics and Computer Science, Odense University, Denmark.
--   
--   This implementation is not full, and has some serious limitations:
--   
--   <ol>
--   <li>The rebalance logic to handle underful leafs has not been
--   implemented.</li>
--   <li><a>toList</a>, <a>foldli</a>, <a>foldri</a>, <a>search</a>,
--   <a>findMin</a> and <a>findMax</a> may fail if run in parallel with
--   <a>rebalanceProcess</a>. The current implementations of these
--   operations are therefore considered unsafe.</li>
--   <li><a>findMin</a> and <a>findMax</a> may fail in the case where the
--   outer leaf is empty.</li>
--   </ol>
--   
--   It is important to note, that these limitations are limitations of the
--   current implementation and not of the original design. They are solely
--   due to lack of time.
--   
--   To clarify: <tt>Safe operations</tt> are those that support
--   rebalancing during the operations, while <tt>unsafe operations</tt>
--   may fail if run during rebalancing.
module Data.BTree.BTree

-- | Make a new tree parameter from order, root node and cache parameter.
--   When no root node is given, <a>Ref</a> 0 will be used and a new tree
--   initialised here. This may overwrite an existing tree. Is used
--   together with <a>execTree</a>.
makeParam :: (MonadIO mIO, Cache m p (Ref a) (Node k v)) => Int -> Maybe (Ref (Node k1 v1)) -> p -> mIO (Param p k1 v1)

-- | <a>execTree</a> takes a tree parameter and a group of operations in a
--   BTreeM monad and exectures the operations.
execTree :: Param st k v -> BTreeM m st k v a -> m a

-- | Some type-fu. Context (Key k) gives the context (Ord k, Serialize k,
--   ...)
class (Ord k, Serialize k, Interval k) => Key k

-- | Some type-fu. Context (Value v) gives the context (Eq v, Serialize v,
--   ...)
class (Eq v, Serialize v) => Value v

-- | Needed to generate the split-keys used in branch nodes.
class Interval k where between = const
between :: Interval k => k -> k -> k

-- | Type aliases to shorten cache type.
type TreeBackend mc k v = KVBackend mc (Ref (Node k v)) ByteString

-- | Type aliases to shorten result types.
type TreeResult m mc k v a = BTreeM m (Param mc (Ref (Node k v)) (Node k v)) k v a

-- | <i>O(log n)</i>. Insert key-value pair into current tree. After this
--   operation <a>lookup</a> <tt>k</tt> will yield <tt>Just v</tt>. If the
--   key already exists it is overridden. If you want the overridden value,
--   or want different behaviour when the key exists see <a>modify</a>.
--   
--   <a>insert</a> may leave the tree <i>unbalanced</i>, skewed or with
--   underfull nodes. The tree can be re-balanced by starting a
--   <a>rebalanceProcess</a>.
--   
--   <pre>
--   execTree p $ insert 42 "foobar"
--   </pre>
insert :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => k -> v -> TreeResult m mc k v ()

-- | <i>O(log n)</i>. Delete a key from the tree. The deleted value is
--   returned as <tt>Just v</tt> if present, otherwise <tt>Nothing</tt> is
--   returned.
--   
--   <pre>
--   execTree p $ delete 42
--   </pre>
delete :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => k -> TreeResult m mc k v (Maybe v)

-- | <i>O(log n)</i>. Lookup key in current tree.
--   
--   <pre>
--   execTree p $ do insert 42 "foo"      -- ()
--                   a &lt;- lookup 42       -- Just "foo"
--                   insert 42 "bar"      -- ()
--                   b &lt;- lookup 42       -- Just "bar"
--                   delete 42            -- Just "bar"
--                   c &lt;- lookup 42       -- Nothing
--                   return (a, b, c)     -- (Just "foo", Just "bar", Nothing)
--   </pre>
lookup :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => k -> TreeResult m mc k v (Maybe v)

-- | <i>O(log n)</i>. Replace the value of <tt>k</tt> with <tt>f v v'</tt>,
--   where <tt>v'</tt> is the current value. The old value <tt>v'</tt> is
--   returned after the replacement. If no current value exist, <tt>v</tt>
--   is inserted.
--   
--   The semantics is the same as <tt><a>insertLookupWithKey</a> .
--   const</tt>.
--   
--   <pre>
--   execTree p $ do delete 42
--                   modify subtract 42 1    -- inserts    (42,  1)
--                   modify subtract 42 1    -- updates to (42,  0)
--                   modify subtract 42 1    -- updates to (42, -1)
--   </pre>
modify :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => (v -> v -> v) -> k -> v -> TreeResult m mc k v (Maybe v)

-- | Save the tree by flushing the underlying cache to the permanent store
--   and return a ref to the root node.
save :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => TreeResult m mc k v (Ref (Node k v))

-- | A process for background rebalancing. Start inside its own thread,
--   since this will run forever. Stop by killing the thread.
--   
--   <pre>
--   pid &lt;- forkIO $ rebalanceProcess p
--   -- Perform safe tree operations
--   killThread pid
--   </pre>
rebalanceProcess :: (MonadIO m, TreeBackend m2 k v, Key k, Value v) => Param (CacheSTMP m2 k v) k v -> m (MVar ThreadId)

-- | Convert the tree into a list of key-value pairs. This function may
--   crash if used together with <a>rebalanceProcess</a>.
toList :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => TreeResult m mc k v [(k, v)]

-- | Fold with key in left to right order.
foldli :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => (a -> k -> v -> a) -> a -> TreeResult m mc k v a

-- | Fold with key in right to left order.
foldri :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => (k -> v -> a -> a) -> a -> TreeResult m mc k v a

-- | A generalised way of querying the tree. Given two keys <tt>a &lt;=
--   b</tt> the function needs to answer <tt>True</tt> or <tt>False</tt> as
--   to whether the interval <tt>[a, b]</tt> contains interesting keys. No
--   all keys in the interval need be interesting. This function will then
--   return all interesting keys in an efficient way.
search :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => ((k, k) -> Bool) -> TreeResult m mc k v [(k, v)]
search_ :: (MonadIO m, TreeBackend mc k v, Key k, Value v) => ((k, k) -> Bool) -> TreeResult m mc k v ()

-- | Lookup minimum key
findMin :: (Ord k, MonadIO m, Cache mc p (Ref (Node k v)) (Node k v)) => BTreeM m p k v (k, v)

-- | Lookup maximum key
findMax :: (Ord k, MonadIO m, Cache mc p (Ref (Node k v)) (Node k v)) => BTreeM m p k v (k, v)

-- | Calculate the height of the tree, i.e. the longest node path from root
--   to leaf.
height :: (MonadIO m, Cache m1 p (Ref (Node k v)) (Node k v)) => BTreeM m p k v Int
instance Interval ByteString
instance (Eq v, Serialize v) => Value v
instance (Ord k, Serialize k, Interval k) => Key k

module Data.BTree.Class
class (Functor m, MonadIO m) => Tree m k v | m -> v, m -> k where modify_ f k = void . modify f k modifyMany fks = mapM_ (\ (f, k, v) -> modify_ f k v) fks delete_ = void . delete member k = isJust `fmap` lookup k toList = reverse `fmap` (foldli (\ l k v -> (k, v) : l) [])
modify :: Tree m k v => (v -> v -> v) -> k -> v -> m (Maybe v)
modify_ :: Tree m k v => (v -> v -> v) -> k -> v -> m ()
modifyMany :: Tree m k v => [(v -> v -> v, k, v)] -> m ()
delete :: Tree m k v => k -> m (Maybe v)
delete_ :: Tree m k v => k -> m ()
lookup :: Tree m k v => k -> m (Maybe v)
member :: Tree m k v => k -> m Bool
search :: Tree m k v => ((k, k) -> Bool) -> m [(k, v)]
foldli :: Tree m k v => (a -> k -> v -> a) -> a -> m a
toList :: Tree m k v => m [(k, v)]
type N k v = Node k v
type R k v = Ref (N k v)
type Cp m k v = Param m (R k v) (N k v)
type S m k v = Param m (R k v) (N k v)
