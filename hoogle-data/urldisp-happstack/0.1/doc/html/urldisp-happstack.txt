-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple, declarative, expressive URL routing -- on happstack.
--   
--   UrlDisp combinators ported over happstack, as well as a lifted catch.
@package urldisp-happstack
@version 0.1

module Happstack.UrlDisp

-- | Unpacks a UrlDisp into a plain old ServerMonad. Used as a top-level
--   wrapper.
runUrlDisp :: (ServerMonad m) => UrlDisp m a -> m a

-- | Filters on and consumes the next element of the url path. <tt> path
--   "str" </tt> will match requests whose next path element is "str"
--   Consumption of the path element backtracks on failure.
path :: (MonadState UrlS m, Alternative m) => String -> m ()

-- | Filters on the request method. <tt> meth "GET" </tt> will match
--   requests made using get.
meth :: (ServerMonad m, MonadPlus m) => String -> m ()

-- | Filters on any parameter (via put or get). <tt> param ("cmd", "foo")
--   </tt> will match on ?cmd=foo
param :: (ServerMonad m, Alternative m) => (String, String) -> m ()

-- | Combinator that consumes the next element of the path and passes it as
--   an unparsed string into the following lambda expression. <tt> h
--   <a>takePath</a> \x -&gt; output (x++"99") </tt> will match on "/12"
--   and output "1299" Consumption of the path element backtracks on
--   failure.
takePath :: (MonadState UrlS m, Alternative m) => m String

-- | Matches and consumes the next element of the path if that element can
--   be successfully read as the proper type. The parsed element is
--   returned.
readPath :: (Read a, MonadState UrlS m, Alternative m) => m a

-- | Only matches if the remaining path is empty.
endPath :: (MonadState UrlS m, Alternative m) => m ()

-- | Returns a string representation of a parameter, if available.
--   Otherwise fails.
getInput :: (ServerMonad f, Alternative f) => String -> f String

-- | Returns Just a string representation of a parameter, or Nothing.
getInputMay :: (ServerMonad f, Alternative f) => String -> f (Maybe String)

-- | A null CGI action, used to begin a string of path combinators
h :: (ServerMonad m) => m ()

-- | Combinator that filters on and consumes the next element of the url
--   path. <tt> h |/ "dir" |/ "subdir" </tt> will match "/dir/subdir".
--   Consumtion of the path element backtracks on failure.
(|/) :: (MonadState UrlS m, Alternative m) => m a -> String -> m ()

-- | Combinator that filters on the request method. <tt> h |// "GET" </tt>
--   will match requests made using get.
(|//) :: (ServerMonad m, MonadPlus m) => m a -> String -> m ()

-- | Combinator that filters on any parameter (via put or get). <tt> h |?
--   ("cmd","foo") </tt> will match on ?cmd=foo
(|?) :: (ServerMonad m, Alternative m) => m a -> (String, String) -> m ()

-- | Combinator that matches and consumes the next element of the path if
--   path element can be successfully read as the proper type and passed to
--   the following lambda expression. <tt> h |\ \x -&gt; output (x +
--   (1.5::Float)) </tt> will match on "/12" and output "13.5". Consumption
--   of the path element backtracks on failure.
(|\) :: (Read x, MonadState UrlS m, Alternative m) => m a -> (x -> m b) -> m b

-- | Combinator that consumes the next element of the path and passes it as
--   an unparsed string into the following lambda expression. <tt> h |\\ \x
--   -&gt; output (x++"99") </tt> will match on "/12" and output "1299"
--   Consumtion of the path element backtracks on failure.
(|\\) :: (MonadState UrlS m, Alternative m) => m a -> (String -> m b) -> m b

-- | Combinator that only matches if the remaining path is empty.
(|.) :: (MonadState UrlS m, Alternative m) => m a -> m b -> m b
data UrlS
UrlS :: [String] -> UrlS
pPath :: UrlS -> [String]
newtype UrlDisp m a
UrlDisp :: (StateT UrlS m a) -> UrlDisp m a
unUrlDisp :: UrlDisp m a -> (StateT UrlS m a)
spCatch :: (Exception e) => ServerPartT IO a -> (e -> ServerPartT IO a) -> ServerPartT IO a
instance (Monad m) => Functor (UrlDisp m)
instance (Monad m) => Monad (UrlDisp m)
instance (Monad m) => MonadState UrlS (UrlDisp m)
instance (ServerMonad m) => ServerMonad (UrlDisp m)
instance (MonadIO m) => MonadIO (UrlDisp m)
instance (Monad m) => Applicative (UrlDisp m)
instance (MonadPlus m) => MonadPlus (UrlDisp m)
instance Alternative (ServerPartT IO)
instance (Monad m, MonadPlus m, Functor m) => Alternative (UrlDisp m)
instance (Monad m) => Applicative (StateT UrlS m)
instance (ServerMonad m) => ServerMonad (StateT UrlS m)
instance MonadTrans UrlDisp
instance (FilterMonad Response m, Monad m) => FilterMonad Response (UrlDisp m)
instance (FilterMonad Response m, Monad m) => FilterMonad Response (StateT UrlS m)
instance (Monad m) => WebMonad Response (UrlDisp (ServerPartT m))
