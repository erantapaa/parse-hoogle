-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Depth-typed functor-based trees, both top-down and bottom-up
--   
@package ftree
@version 0.1.3


-- | Top-down, depth-typed functor trees. In other words, right-associated
--   n-ary functor composition. See
--   <a>http://conal.net/blog/posts/a-trie-for-length-typed-vectors/</a>.
module Data.FTree.BottomUp
data T :: (* -> *) -> * -> (* -> *)
L :: a -> T f Z a
B :: T f n (f a) -> T f (S n) a
type (:^) = T
unL :: (f :^ Z) a -> a
unB :: (f :^ S n) a -> (f :^ n) (f a)
foldT :: Functor f => (a -> z) -> (f a -> a) -> (f :^ n) a -> z
inT :: (a -> b) -> (forall n. IsNat n => (f :^ n) (f a) -> (f :^ n) (f b)) -> (forall n. (f :^ n) a -> (f :^ n) b)
inT2 :: (a -> b -> c) -> (forall n. IsNat n => (f :^ n) (f a) -> (f :^ n) (f b) -> (f :^ n) (f c)) -> (forall n. (f :^ n) a -> (f :^ n) b -> (f :^ n) c)
inL :: (a -> b) -> ((f :^ Z) a -> (f :^ Z) b)
inB :: ((f :^ n) (f a) -> (f :^ n) (f b)) -> ((f :^ (S n)) a -> (f :^ (S n)) b)
inL2 :: (a -> b -> c) -> ((f :^ Z) a -> (f :^ Z) b -> (f :^ Z) c)
inB2 :: ((f :^ n) (f a) -> (f :^ n) (f b) -> (f :^ n) (f c)) -> ((f :^ (S n)) a -> (f :^ (S n)) b -> (f :^ (S n)) c)
instance (Foldable f, Applicative f, IsNat n, Ord a) => Ord ((:^) f n a)
instance (Foldable f, Applicative f, IsNat n, Eq a) => Eq ((:^) f n a)
instance (IsNat n, Applicative f, Monoid m) => Monoid ((:^) f n m)
instance Traversable f => Traversable (f :^ n)
instance (Functor f, Foldable f) => Foldable (f :^ n)
instance (IsNat n, Applicative f) => Applicative (f :^ n)
instance Functor f => Functor (f :^ n)
instance (Functor f, ShowF f) => ShowF (f :^ n)
instance (Functor f, ShowF f, Show a) => Show ((:^) f n a)


-- | Top-down, depth-typed functor trees. In other words, right-associated
--   n-ary functor composition. See
--   <a>http://conal.net/blog/posts/a-trie-for-length-typed-vectors/</a>.
module Data.FTree.TopDown
data T :: (* -> *) -> * -> (* -> *)
L :: a -> T f Z a
B :: f (T f n a) -> T f (S n) a
type (:^) = T
unL :: (f :^ Z) a -> a
unB :: (f :^ S n) a -> f ((f :^ n) a)
foldT :: Functor f => (a -> z) -> (f z -> z) -> (f :^ n) a -> z
inT :: (a -> b) -> (forall n. IsNat n => f ((f :^ n) a) -> f ((f :^ n) b)) -> (forall n. (f :^ n) a -> (f :^ n) b)
inT2 :: (a -> b -> c) -> (forall n. IsNat n => f ((f :^ n) a) -> f ((f :^ n) b) -> f ((f :^ n) c)) -> (forall n. (f :^ n) a -> (f :^ n) b -> (f :^ n) c)
inL :: (a -> b) -> ((f :^ Z) a -> (f :^ Z) b)
inB :: (f ((f :^ n) a) -> f ((f :^ n) b)) -> ((f :^ (S n)) a -> (f :^ (S n)) b)
inL2 :: (a -> b -> c) -> ((f :^ Z) a -> (f :^ Z) b -> (f :^ Z) c)
inB2 :: (f ((f :^ n) a) -> f ((f :^ n) b) -> f ((f :^ n) c)) -> ((f :^ (S n)) a -> (f :^ (S n)) b -> (f :^ (S n)) c)
instance (Foldable f, Applicative f, IsNat n, Ord a) => Ord ((:^) f n a)
instance (Foldable f, Applicative f, IsNat n, Eq a) => Eq ((:^) f n a)
instance (IsNat n, Applicative f, Monoid m) => Monoid ((:^) f n m)
instance Traversable f => Traversable (f :^ n)
instance (Functor f, Foldable f) => Foldable (f :^ n)
instance (IsNat n, Applicative f) => Applicative (f :^ n)
instance Functor f => Functor (f :^ n)
instance ShowF f => ShowF (f :^ n)
instance (ShowF f, Show a) => Show ((:^) f n a)
