-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extensible double-entry accounting system
--   
--   Penny is a double-entry accounting system. You keep your records in a
--   plain-text file, and Penny gives you useful reports in your UNIX
--   shell.
--   
--   For more information, please see
--   
--   <a>http://www.github.com/massysett/penny</a>
@package penny
@version 0.32.0.10


-- | Steel - independent Penny utilities
--   
--   Currently there are no modules in Steel, as they have been shipped off
--   in separate packages such as anonymous-sums and prednote; however,
--   Steel remains if needed in the future.
module Penny.Steel

module Penny.Lincoln.Serial
data Serial
forward :: Serial -> Int
backward :: Serial -> Int
serialItems :: (Serial -> a -> b) -> [a] -> [b]
serialSomeItems :: (a -> Either b (Serial -> b)) -> [a] -> [b]

-- | Adds serials to items that are nested within other items.
serialNestedItems :: Traversable f => (a -> Either b (f c, Serial -> c -> d, f d -> b)) -> [a] -> [b]
instance Show SerialSt
instance Eq Serial
instance Show Serial
instance Ord Serial
instance Monad GenSerial
instance Applicative GenSerial
instance Functor GenSerial


-- | Natural numbers, either positive or non-zero. These wrap Int rather
--   than Integers so do not use them were unlimited precision is needed.
module Penny.Lincoln.Natural
data NonNegative
nonNegative :: Int -> Maybe NonNegative
data Positive
positive :: Int -> Maybe Positive
instance Eq NonNegative
instance Show NonNegative
instance Ord NonNegative
instance Eq Positive
instance Show Positive
instance Ord Positive


-- | Type synonyms for functions dealing with text matching.
module Penny.Lincoln.Matchers

-- | A function that makes Matchers.
type Factory = CaseSensitive -> Text -> Either Text (Predbox Text)

module Penny.Lincoln.Equivalent

-- | Comparisons for equivalency. Two items are equivalent if they have the
--   same semantic meaning, even if the data in the two items is different.
class Equivalent a
equivalent :: Equivalent a => a -> a -> Bool
compareEv :: Equivalent a => a -> a -> Ordering
(==~) :: Equivalent a => a -> a -> Bool
instance (Equivalent a, Equivalent b) => Equivalent (Either a b)
instance (Equivalent a, Equivalent b, Equivalent c) => Equivalent (a, b, c)
instance (Equivalent a, Equivalent b) => Equivalent (a, b)
instance Equivalent a => Equivalent (Maybe a)


-- | These are the bits that are <a>open</a>; that is, their constructors
--   are exported. This includes most bits. Some bits that have open
--   constructors are not in this module because they include other bits
--   that do not have exported constructors.
module Penny.Lincoln.Bits.Open
newtype SubAccount
SubAccount :: Text -> SubAccount
unSubAccount :: SubAccount -> Text
newtype Account
Account :: [SubAccount] -> Account
unAccount :: Account -> [SubAccount]
data Amount q
Amount :: q -> Commodity -> Amount q
qty :: Amount q -> q
commodity :: Amount q -> Commodity
newtype Commodity
Commodity :: Text -> Commodity
unCommodity :: Commodity -> Text
data DrCr
Debit :: DrCr
Credit :: DrCr

-- | Debit returns Credit; Credit returns Debit
opposite :: DrCr -> DrCr
data Entry q
Entry :: DrCr -> Amount q -> Entry q
drCr :: Entry q -> DrCr
amount :: Entry q -> Amount q
newtype Flag
Flag :: Text -> Flag
unFlag :: Flag -> Text

-- | There is one item in the list for each line of the memo. Do not
--   include newlines in the texts themselves. However there is nothing to
--   enforce this convention.
newtype Memo
Memo :: [Text] -> Memo
unMemo :: Memo -> [Text]
newtype Number
Number :: Text -> Number
unNumber :: Number -> Text
newtype Payee
Payee :: Text -> Payee
unPayee :: Payee -> Text
newtype Tag
Tag :: Text -> Tag
unTag :: Tag -> Text
newtype Tags
Tags :: [Tag] -> Tags
unTags :: Tags -> [Tag]

-- | The line number that the TopLine starts on (excluding the memo
--   accompanying the TopLine).
newtype TopLineLine
TopLineLine :: Int -> TopLineLine
unTopLineLine :: TopLineLine -> Int

-- | The line number that the memo accompanying the TopLine starts on.
newtype TopMemoLine
TopMemoLine :: Int -> TopMemoLine
unTopMemoLine :: TopMemoLine -> Int

-- | The commodity and and the quantity may appear with the commodity on
--   the left (e.g. USD 2.14) or with the commodity on the right (e.g. 2.14
--   USD).
data Side
CommodityOnLeft :: Side
CommodityOnRight :: Side

-- | There may or may not be a space in between the commodity and the
--   quantity.
data SpaceBetween
SpaceBetween :: SpaceBetween
NoSpaceBetween :: SpaceBetween

-- | The name of the file in which a transaction appears.
newtype Filename
Filename :: Text -> Filename
unFilename :: Filename -> Text

-- | The line number on which a price appears.
newtype PriceLine
PriceLine :: Int -> PriceLine
unPriceLine :: PriceLine -> Int

-- | The line number on which a posting appears.
newtype PostingLine
PostingLine :: Int -> PostingLine
unPostingLine :: PostingLine -> Int

-- | All postings are numbered in order, beginning with the first posting
--   in the first file and ending with the last posting in the last file.
newtype GlobalPosting
GlobalPosting :: Serial -> GlobalPosting
unGlobalPosting :: GlobalPosting -> Serial

-- | The postings in each file are numbered in order.
newtype FilePosting
FilePosting :: Serial -> FilePosting
unFilePosting :: FilePosting -> Serial

-- | All transactions are numbered in order, beginning with the first
--   transaction in the first file and ending with the last transaction in
--   the last file.
newtype GlobalTransaction
GlobalTransaction :: Serial -> GlobalTransaction
unGlobalTransaction :: GlobalTransaction -> Serial

-- | The transactions in each file are numbered in order.
newtype FileTransaction
FileTransaction :: Serial -> FileTransaction
unFileTransaction :: FileTransaction -> Serial
instance Eq SubAccount
instance Ord SubAccount
instance Show SubAccount
instance Eq Account
instance Show Account
instance Ord Account
instance Eq Commodity
instance Ord Commodity
instance Show Commodity
instance Eq q => Eq (Amount q)
instance Show q => Show (Amount q)
instance Ord q => Ord (Amount q)
instance Eq DrCr
instance Show DrCr
instance Ord DrCr
instance Eq q => Eq (Entry q)
instance Show q => Show (Entry q)
instance Ord q => Ord (Entry q)
instance Eq Flag
instance Show Flag
instance Ord Flag
instance Eq Memo
instance Show Memo
instance Ord Memo
instance Eq Number
instance Show Number
instance Ord Number
instance Eq Payee
instance Show Payee
instance Ord Payee
instance Eq Tag
instance Show Tag
instance Ord Tag
instance Eq Tags
instance Show Tags
instance Ord Tags
instance Eq TopLineLine
instance Show TopLineLine
instance Eq TopMemoLine
instance Show TopMemoLine
instance Eq Side
instance Show Side
instance Ord Side
instance Eq SpaceBetween
instance Show SpaceBetween
instance Ord SpaceBetween
instance Eq Filename
instance Show Filename
instance Eq PriceLine
instance Show PriceLine
instance Eq PostingLine
instance Show PostingLine
instance Eq GlobalPosting
instance Show GlobalPosting
instance Eq FilePosting
instance Show FilePosting
instance Eq GlobalTransaction
instance Show GlobalTransaction
instance Eq FileTransaction
instance Show FileTransaction
instance Equivalent SpaceBetween
instance Equivalent Side
instance Equivalent Tags
instance Equivalent q => Equivalent (Entry q)
instance Functor Entry
instance Equivalent q => Equivalent (Amount q)
instance Functor Amount

module Penny.Lincoln.Bits.DateTime

-- | The number of minutes that this timezone is offset from UTC. Can be
--   positive, negative, or zero.
data TimeZoneOffset

-- | Convert minutes to a time zone offset. I'm having a hard time deciding
--   whether to be liberal or strict in what to accept here. Currently it
--   is somewhat strict in that it will fail if absolute value is greater
--   than 840 minutes; currently the article at
--   http:<i></i>en.wikipedia.org<i>wiki</i>List_of_time_zones_by_UTC_offset
--   says there is no offset greater than 14 hours, or 840 minutes.
minsToOffset :: Int -> Maybe TimeZoneOffset
noOffset :: TimeZoneOffset
data Hours

-- | succeeds if 0 &lt;= x &lt; 24
intToHours :: Int -> Maybe Hours
zeroHours :: Hours
data Minutes

-- | succeeds if 0 &lt;= x &lt; 60
intToMinutes :: Int -> Maybe Minutes
zeroMinutes :: Minutes
data Seconds

-- | succeeds if 0 &lt;= x &lt; 61 (to allow for leap seconds)
intToSeconds :: Int -> Maybe Seconds
zeroSeconds :: Seconds
midnight :: (Hours, Minutes, Seconds)

-- | A DateTime is a a local date and time, along with a time zone offset.
--   The Eq and Ord instances are derived; therefore, two DateTime
--   instances will not be equivalent if the time zone offsets are
--   different, even if they are the same instant. To compare one DateTime
--   to another, you probably want to use <a>toUTC</a> and compare those.
--   To see if two DateTime are the same instant, use <a>sameInstant</a>.
data DateTime
DateTime :: Day -> Hours -> Minutes -> Seconds -> TimeZoneOffset -> DateTime
day :: DateTime -> Day
hours :: DateTime -> Hours
minutes :: DateTime -> Minutes
seconds :: DateTime -> Seconds
timeZone :: DateTime -> TimeZoneOffset
dateTimeMidnightUTC :: Day -> DateTime
toUTC :: DateTime -> UTCTime
toZonedTime :: DateTime -> ZonedTime
fromZonedTime :: ZonedTime -> Maybe DateTime

-- | Are these DateTimes the same instant in time, after adjusting for
--   local timezones?
sameInstant :: DateTime -> DateTime -> Bool

-- | Shows a DateTime in a pretty way.
showDateTime :: DateTime -> String
instance Eq TimeZoneOffset
instance Ord TimeZoneOffset
instance Show TimeZoneOffset
instance Eq Hours
instance Ord Hours
instance Show Hours
instance Eq Minutes
instance Ord Minutes
instance Show Minutes
instance Eq Seconds
instance Ord Seconds
instance Show Seconds
instance Eq DateTime
instance Ord DateTime
instance Show DateTime
instance Equivalent DateTime


-- | Independent executables
--   
--   Code for standalone executables is here. Modules in Denver may depend
--   on any other module in Penny. No module outside of Denver has any
--   dependencies on any Denver module.
module Penny.Denver

module Penny.Copper.Terminals
invalid :: Char -> Bool
unicode :: Char -> Bool
newline :: Char -> Bool
space :: Char -> Bool
tab :: Char -> Bool
white :: Char -> Bool
nonNewline :: Char -> Bool
nonNewlineNonSpace :: Char -> Bool
upperCaseAscii :: Char -> Bool
lowerCaseAscii :: Char -> Bool
digit :: Char -> Bool
nonAscii :: Char -> Bool
letter :: Char -> Bool
dollar :: Char -> Bool
colon :: Char -> Bool
openCurly :: Char -> Bool
closeCurly :: Char -> Bool
openSquare :: Char -> Bool
closeSquare :: Char -> Bool
doubleQuote :: Char -> Bool
period :: Char -> Bool
hash :: Char -> Bool
thinSpace :: Char -> Bool
dateSep :: Char -> Bool
plus :: Char -> Bool
minus :: Char -> Bool
lessThan :: Char -> Bool
greaterThan :: Char -> Bool
openParen :: Char -> Bool
closeParen :: Char -> Bool
semicolon :: Char -> Bool
apostrophe :: Char -> Bool
tilde :: Char -> Bool
underscore :: Char -> Bool
asterisk :: Char -> Bool
lvl1AcctChar :: Char -> Bool
lvl2AcctOtherChar :: Char -> Bool
lvl1CmdtyChar :: Char -> Bool
lvl2CmdtyFirstChar :: Char -> Bool
lvl2CmdtyOtherChar :: Char -> Bool
lvl3CmdtyChar :: Char -> Bool
flagChar :: Char -> Bool
numberChar :: Char -> Bool
quotedPayeeChar :: Char -> Bool
tagChar :: Char -> Bool
atSign :: Char -> Bool


-- | Penny quantities. A quantity is simply a count (possibly fractional)
--   of something. It does not have a commodity or a Debit/Credit.
--   
--   Quantities are always greater than zero, even if infinitesimally so.
--   
--   There are two main types in this module: a quantity representation, or
--   <a>QtyRep</a>, and a quantity, or <a>Qty</a>. To understand the
--   difference, consider these numbers:
--   
--   <pre>
--   1364.25
--   1,364.25
--   1 364.25
--   1.364,25
--   1364,25
--   </pre>
--   
--   These are all different ways to represent the same quantity. Each is a
--   different quantity representation, or <a>QtyRep</a>. A <a>QtyRep</a>
--   stores information about each digit, each digit grouping character
--   (which may be a comma, thin space, or period) and the radix point, if
--   present (which may be a period or a comma.)
--   
--   A <a>QtyRep</a> can be converted to a <a>Qty</a> with <a>toQty</a>. A
--   <a>Qty</a> is a quantity stripped of attributes related to its
--   representation. No floating point types are in a <a>Qty</a>;
--   internally, a <a>Qty</a> consists of an integral significand and an
--   integer representing the number of decimal places. Though each
--   <a>QtyRep</a> is convertible to one and only one <a>Qty</a>, a single
--   <a>Qty</a> can correspond to several <a>QtyRep</a>. For example, each
--   of the quantity representations shown above would return identical
--   <a>Qty</a> after being converted with <a>toQty</a>.
--   
--   You can only perform arithmetic using <a>Qty</a>, not <a>QtyRep</a>.
--   You can add or multiply <a>Qty</a>, which yields the result you would
--   expect. You cannot perform ordinary subtraction on <a>Qty</a>, as this
--   might yield a result which is less than or equal to zero; remember
--   that <a>Qty</a> and <a>QtyRep</a> are always greater than zero, even
--   if infinitesimally so. Instead, <a>difference</a> will tell you if
--   there is a difference between two <a>Qty</a> and, if so, which is
--   greater and by how much.
module Penny.Lincoln.Bits.Qty
data Digit
D0 :: Digit
D1 :: Digit
D2 :: Digit
D3 :: Digit
D4 :: Digit
D5 :: Digit
D6 :: Digit
D7 :: Digit
D8 :: Digit
D9 :: Digit
newtype DigitList
DigitList :: NonEmpty Digit -> DigitList
unDigitList :: DigitList -> NonEmpty Digit
class Digits a
digits :: Digits a => a -> DigitList

-- | Converting a type that represents a digit grouping character to the
--   underlying character itself.
class Grouper a
groupChar :: Grouper a => a -> Char

-- | The digit grouping character when the radix is a period.
data PeriodGrp

-- | ASCII space
PGSpace :: PeriodGrp

-- | Unicode code point 0x2009
PGThinSpace :: PeriodGrp

-- | Comma
PGComma :: PeriodGrp

-- | The digit grouping character when the radix is a comma.
data CommaGrp

-- | ASCII space
CGSpace :: CommaGrp

-- | Unicode code point 0x2009
CGThinSpace :: CommaGrp

-- | Period
CGPeriod :: CommaGrp

-- | All of the digits on a single side of a radix point. Typically this is
--   parameterized on a type that represents the grouping character.
data GroupedDigits a
GroupedDigits :: DigitList -> [(a, DigitList)] -> GroupedDigits a

-- | The first chunk of digits
dsFirstPart :: GroupedDigits a -> DigitList

-- | Optional subsequent chunks of digits. Each is a grouping character
--   followed by additional digits.
dsNextParts :: GroupedDigits a -> [(a, DigitList)]

-- | A quantity representation that has both a whole number and a
--   fractional part. Abstract because there must be a non-zero digit in
--   here somewhere, which <a>wholeFrac</a> checks for. Typically this is
--   parameterized on an instance of the Digits class, such as DigitList or
--   GroupedDigits. This allows separate types for values that cannot be
--   grouped as well as those that can.
data WholeFrac a
whole :: WholeFrac a -> a
frac :: WholeFrac a -> a
wholeFrac :: Digits a => a -> a -> Maybe (WholeFrac a)
wholeOrFrac :: GroupedDigits a -> Maybe (GroupedDigits a) -> Maybe (WholeOrFracResult a)
type WholeOrFracResult a = Either (WholeOrFrac DigitList) (WholeOrFrac (GroupedDigits a))
wholeOrFracToQtyRep :: Either (WholeOrFracResult PeriodGrp) (WholeOrFracResult CommaGrp) -> QtyRep

-- | A quantity representation that has a whole part only. Abstract because
--   there must be a non-zero digit in here somewhere, which
--   <a>wholeOnly</a> checks for. Typically this is parameterized on an
--   instance of the Digits class, such as DigitList or GroupedDigits.
data WholeOnly a
unWholeOnly :: WholeOnly a -> a
wholeOnly :: Digits a => a -> Maybe (WholeOnly a)

-- | Typically this is parameterized on an instance of the Digits class,
--   such as DigitList or GroupedDigits.
newtype WholeOrFrac a
WholeOrFrac :: Either (WholeOnly a) (WholeFrac a) -> WholeOrFrac a
unWholeOrFrac :: WholeOrFrac a -> Either (WholeOnly a) (WholeFrac a)
data Radix
Period :: Radix
Comma :: Radix
showRadix :: Radix -> Text
data QtyRep
QNoGrouping :: (WholeOrFrac DigitList) -> Radix -> QtyRep
QGrouped :: (Either (WholeOrFrac (GroupedDigits PeriodGrp)) (WholeOrFrac (GroupedDigits CommaGrp))) -> QtyRep
qtyToRep :: S3 Radix PeriodGrp CommaGrp -> Qty -> QtyRep
qtyToRepNoGrouping :: Qty -> WholeOrFrac DigitList
qtyToRepGrouped :: g -> Qty -> WholeOrFrac (GroupedDigits g)
showQtyRep :: QtyRep -> Text

-- | Given a list of QtyRep, determine the most common radix and grouping
--   that are used. If a single QtyRep is grouped, then the result is also
--   grouped. The most common grouping character determines which grouping
--   character is used.
--   
--   If no QtyRep are grouped, then the most common radix point is used and
--   the result is not grouped.
--   
--   If there is no radix point found, returns Nothing.
bestRadGroup :: [QtyRep] -> Maybe (S3 Radix PeriodGrp CommaGrp)

-- | A quantity is always greater than zero. Various odd questions happen
--   if quantities can be zero. For instance, what if you have a debit
--   whose quantity is zero? Does it require a balancing credit that is
--   also zero? And how can you have a debit of zero anyway?
--   
--   <i>WARNING</i> - before doing comparisons or equality tests
--   
--   The Eq instance is derived. Therefore q1 == q2 only if q1 and q2 have
--   both the same significand and the same number of places. You may
--   instead want <a>equivalent</a>. Similarly, the Ord instance is
--   derived. It compares based on the integral value of the significand
--   and of the exponent. You may instead want <a>compareQty</a>, which
--   compares after equalizing the exponents.
data Qty
class HasQty a
toQty :: HasQty a => a -> Qty

-- | The significand.
signif :: Qty -> Integer

-- | The number of decimal places. For instance, in <tt>1.500</tt>, the
--   significand is 1500 and the number of places is 3.
places :: Qty -> Integer

-- | Compares Qty after equalizing their exponents.
--   
--   <pre>
--   compareQty (newQty 15 1) (newQty 1500 3) == EQ
--   </pre>
compareQty :: Qty -> Qty -> Ordering

-- | Ensures that the significand is greater than zero and the number of
--   decimal places is at least zero.
newQty :: Signif -> Places -> Maybe Qty
type Signif = Integer
type Places = Integer
add :: Qty -> Qty -> Qty

-- | Multiplication
mult :: Qty -> Qty -> Qty

-- | Division. There can be no division by zero errors, as a Qty is never
--   zero. Converting to a floating-point number destroys precision, so be
--   sure this is what you want. Sometimes it is useful where precision is
--   not needed (e.g. percentages).
divide :: Fractional a => Qty -> Qty -> a
data Difference
LeftBiggerBy :: Qty -> Difference
RightBiggerBy :: Qty -> Difference
Equal :: Difference

-- | Subtract the second Qty from the first, after equalizing their
--   exponents.
difference :: Qty -> Qty -> Difference

-- | Allocate a Qty proportionally so that the sum of the results adds up
--   to a given Qty. Fails if the allocation cannot be made (e.g. if it is
--   impossible to allocate without overflowing Decimal.) The result will
--   always add up to the given sum.
allocate :: Qty -> (Qty, [Qty]) -> (Qty, [Qty])
type TotSeats = Integer
type PartyVotes = Integer
type SeatsWon = Integer

-- | Allocates integers using the largest remainder method. This is the
--   method used to allocate parliamentary seats in many countries, so the
--   types are named accordingly.
largestRemainderMethod :: TotSeats -> [PartyVotes] -> [SeatsWon]

-- | Significand 1, exponent 0
qtyOne :: Qty
instance Eq Digit
instance Ord Digit
instance Show Digit
instance Enum Digit
instance Bounded Digit
instance Eq PeriodGrp
instance Show PeriodGrp
instance Ord PeriodGrp
instance Enum PeriodGrp
instance Bounded PeriodGrp
instance Eq CommaGrp
instance Show CommaGrp
instance Ord CommaGrp
instance Enum CommaGrp
instance Bounded CommaGrp
instance Eq DigitList
instance Show DigitList
instance Ord DigitList
instance Eq a => Eq (GroupedDigits a)
instance Show a => Show (GroupedDigits a)
instance Ord a => Ord (GroupedDigits a)
instance Eq a => Eq (WholeFrac a)
instance Show a => Show (WholeFrac a)
instance Ord a => Ord (WholeFrac a)
instance Eq a => Eq (WholeOnly a)
instance Show a => Show (WholeOnly a)
instance Ord a => Ord (WholeOnly a)
instance Eq a => Eq (WholeOrFrac a)
instance Show a => Show (WholeOrFrac a)
instance Ord a => Ord (WholeOrFrac a)
instance Eq Radix
instance Show Radix
instance Ord Radix
instance Enum Radix
instance Bounded Radix
instance Eq QtyRep
instance Show QtyRep
instance Ord QtyRep
instance Eq Qty
instance Show Qty
instance Ord Qty
instance Eq Difference
instance Show Difference
instance Equivalent Qty
instance HasQty Qty
instance HasQty QtyRep
instance Ord a => Ord (Down a)
instance Eq a => Eq (Down a)
instance Equivalent QtyRep
instance Digits (GroupedDigits a)
instance Digits DigitList
instance Semigroup DigitList
instance Grouper CommaGrp
instance Grouper PeriodGrp

module Penny.Lincoln.Bits.Price
newtype From
From :: Commodity -> From
unFrom :: From -> Commodity
newtype To
To :: Commodity -> To
unTo :: To -> Commodity
newtype CountPerUnit
CountPerUnit :: QtyRep -> CountPerUnit
unCountPerUnit :: CountPerUnit -> QtyRep
data Price

-- | Succeeds only if From and To are different commodities.
newPrice :: From -> To -> CountPerUnit -> Maybe Price
instance Eq From
instance Ord From
instance Show From
instance Eq To
instance Ord To
instance Show To
instance Eq CountPerUnit
instance Ord CountPerUnit
instance Show CountPerUnit
instance Eq Price
instance Ord Price
instance Show Price
instance Equivalent Price
instance Equivalent CountPerUnit


-- | Essential data types used to make Transactions and Postings.
module Penny.Lincoln.Bits
data PricePoint
PricePoint :: DateTime -> Price -> Maybe Side -> Maybe SpaceBetween -> Maybe PriceLine -> PricePoint
dateTime :: PricePoint -> DateTime
price :: PricePoint -> Price
ppSide :: PricePoint -> Maybe Side
ppSpaceBetween :: PricePoint -> Maybe SpaceBetween
priceLine :: PricePoint -> Maybe PriceLine

-- | Every TopLine has this data.
data TopLineCore
TopLineCore :: DateTime -> Maybe Number -> Maybe Flag -> Maybe Payee -> Maybe Memo -> TopLineCore
tDateTime :: TopLineCore -> DateTime
tNumber :: TopLineCore -> Maybe Number
tFlag :: TopLineCore -> Maybe Flag
tPayee :: TopLineCore -> Maybe Payee
tMemo :: TopLineCore -> Maybe Memo
emptyTopLineCore :: DateTime -> TopLineCore

-- | TopLines from files have this metadata.
data TopLineFileMeta
TopLineFileMeta :: Filename -> TopLineLine -> Maybe TopMemoLine -> FileTransaction -> TopLineFileMeta
tFilename :: TopLineFileMeta -> Filename
tTopLineLine :: TopLineFileMeta -> TopLineLine
tTopMemoLine :: TopLineFileMeta -> Maybe TopMemoLine
tFileTransaction :: TopLineFileMeta -> FileTransaction

-- | All the data that a TopLine might have.
data TopLineData
TopLineData :: TopLineCore -> Maybe TopLineFileMeta -> Maybe GlobalTransaction -> TopLineData
tlCore :: TopLineData -> TopLineCore
tlFileMeta :: TopLineData -> Maybe TopLineFileMeta
tlGlobal :: TopLineData -> Maybe GlobalTransaction
emptyTopLineData :: DateTime -> TopLineData

-- | All Postings have this data.
data PostingCore
PostingCore :: Maybe Payee -> Maybe Number -> Maybe Flag -> Account -> Tags -> Maybe Memo -> Maybe Side -> Maybe SpaceBetween -> PostingCore
pPayee :: PostingCore -> Maybe Payee
pNumber :: PostingCore -> Maybe Number
pFlag :: PostingCore -> Maybe Flag
pAccount :: PostingCore -> Account
pTags :: PostingCore -> Tags
pMemo :: PostingCore -> Maybe Memo
pSide :: PostingCore -> Maybe Side
pSpaceBetween :: PostingCore -> Maybe SpaceBetween
emptyPostingCore :: Account -> PostingCore

-- | Postings from files have this additional data.
data PostingFileMeta
PostingFileMeta :: PostingLine -> FilePosting -> PostingFileMeta
pPostingLine :: PostingFileMeta -> PostingLine
pFilePosting :: PostingFileMeta -> FilePosting

-- | All the data that a Posting might have.
data PostingData
PostingData :: PostingCore -> Maybe PostingFileMeta -> Maybe GlobalPosting -> PostingData
pdCore :: PostingData -> PostingCore
pdFileMeta :: PostingData -> Maybe PostingFileMeta
pdGlobal :: PostingData -> Maybe GlobalPosting
emptyPostingData :: Account -> PostingData
instance Eq PricePoint
instance Show PricePoint
instance Eq TopLineCore
instance Show TopLineCore
instance Eq TopLineFileMeta
instance Show TopLineFileMeta
instance Eq TopLineData
instance Show TopLineData
instance Eq PostingCore
instance Show PostingCore
instance Eq PostingFileMeta
instance Show PostingFileMeta
instance Eq PostingData
instance Show PostingData
instance Equivalent PostingCore
instance Equivalent TopLineCore
instance Equivalent PricePoint

module Penny.Lincoln.HasText
class HasText a
text :: HasText a => a -> Text
class HasTextList a
textList :: HasTextList a => a -> [Text]

-- | Wraps instances of HasTextList and provides a delimiter; the result is
--   an instance of HasText.
data Delimited a
Delimited :: Text -> a -> Delimited a
delimiter :: Delimited a -> Text
delimited :: Delimited a -> a
instance Eq a => Eq (Delimited a)
instance Show a => Show (Delimited a)
instance HasTextList Memo
instance HasTextList Tags
instance HasTextList Account
instance HasTextList a => HasText (Delimited a)
instance HasTextList a => HasTextList (Delimited a)
instance HasText Filename
instance HasText Tag
instance HasText Payee
instance HasText Number
instance HasText Commodity
instance HasText Flag
instance HasText SubAccount
instance HasText Text


-- | A database of price information. A PricePoint has a DateTime, a From
--   commodity, a To commodity, and a QtyPerUnit. The PriceDb holds this
--   information for several prices. You can query the database by
--   supplying a from commodity, a to commodity, and a DateTime, and the
--   database will give you the QtyPerUnit, if there is one.
module Penny.Lincoln.PriceDb

-- | The PriceDb holds information about prices. Create an empty one using
--   <a>emptyDb</a> then fill it with values using foldl or similar.
data PriceDb

-- | An empty PriceDb
emptyDb :: PriceDb

-- | Add a single price to the PriceDb.
addPrice :: PriceDb -> PricePoint -> PriceDb

-- | Looks up values from the PriceDb. Throws <a>Error</a> if something
--   fails.
--   
--   The DateTime is the time at which to find a price. If a price exists
--   for that exact DateTime, that price is returned. If no price exists
--   for that exact DateTime, but there is a price for an earlier DateTime,
--   the latest possible price is returned. If there are no earlier prices,
--   CpuNotFound is thrown.
getPrice :: PriceDb -> From -> To -> DateTime -> Either PriceDbError CountPerUnit

-- | Getting prices can fail; if it fails, an Error is returned.
data PriceDbError
FromNotFound :: PriceDbError
ToNotFound :: PriceDbError
CpuNotFound :: PriceDbError

-- | Given an Amount and a Commodity to convert the amount to, converts the
--   Amount to the given commodity. If the Amount given is already in the
--   To commodity, simply returns what was passed in. Can fail and throw
--   PriceDbError. Internally uses <a>getPrice</a>, so read its
--   documentation for details on how price lookup works.
convertAsOf :: HasQty q => PriceDb -> DateTime -> To -> Amount q -> Either PriceDbError Qty

module Penny.Cabin.TextFormat
data Lines
Lines :: Seq Words -> Lines
unLines :: Lines -> Seq Words
data Words
Words :: Seq Text -> Words
unWords :: Words -> Seq Text
data CharsPerLine

-- | Splits a blank-separated text into words.
txtWords :: Text -> Words

-- | Wraps a sequence of words into a sequence of lines, where each line is
--   no more than a given maximum number of characters long.
--   
--   If the maximum number of characters per line is less than 1, returns a
--   Lines that is empty.
--   
--   An individual word will be split across multiple lines only if that
--   word is too long to fit into a single line. No hyphenation is done;
--   the word is simply broken across two lines.
wordWrap :: Int -> Words -> Lines
newtype Target
Target :: Int -> Target
unTarget :: Target -> Int
newtype Shortest
Shortest :: Int -> Shortest
unShortest :: Shortest -> Int

-- | Takes a list of words and shortens it so that it fits in the space
--   allotted. You specify the minimum length for each word, x. It will
--   shorten the farthest left word first, until it is only x characters
--   long; then it will shorten the next word until it is only x characters
--   long, etc. This proceeds until all words are just x characters long.
--   Then words are shortened to one character. Then the leftmost words are
--   deleted as necessary.
--   
--   Assumes that the words will be printed with a separator, which matters
--   when lengths are calculated.
shorten :: Shortest -> Target -> Words -> Words
instance Show Words
instance Show Lines
instance Show CharsPerLine
instance Show Target
instance Show Shortest

module Penny.Cabin.Posts.Types
newtype ReportWidth
ReportWidth :: Int -> ReportWidth
unReportWidth :: ReportWidth -> Int
instance Eq ReportWidth
instance Show ReportWidth
instance Ord ReportWidth

module Penny.Lincoln.Balance

-- | A balance summarizes several entries. You do not create a Balance
--   directly. Instead, use <a>entryToBalance</a>.
data Balance

-- | Returns a map where the keys are the commodities in the balance and
--   the values are the balance for each commodity. If there is no balance
--   at all, this map can be empty.
unBalance :: Balance -> Map Commodity BottomLine

-- | Returned by <a>balanced</a>.
data Balanced
Balanced :: Balanced
Inferable :: (Entry Qty) -> Balanced
NotInferable :: Balanced

-- | Computes whether a Balance map is Balanced.
--   
--   <pre>
--   balanced mempty == Balanced
--   </pre>
balanced :: Balance -> Balanced
isInferable :: Balanced -> Bool

-- | Converts an Entry to a Balance.
entryToBalance :: HasQty q => Entry q -> Balance

-- | Converts multiple Entries to a Balanced.
entriesToBalanced :: HasQty q => [Entry q] -> Balanced

-- | Removes zero balances from a Balance.
removeZeroCommodities :: Balance -> Balance
data BottomLine
Zero :: BottomLine
NonZero :: Column -> BottomLine
data Column
Column :: DrCr -> Qty -> Column
colDrCr :: Column -> DrCr
colQty :: Column -> Qty
instance Show Balanced
instance Eq Balanced
instance Show Column
instance Eq Column
instance Show BottomLine
instance Eq BottomLine
instance Show Balance
instance Eq Balance
instance Monoid Balance
instance Monoid BottomLine


-- | Containers for entries.
--   
--   This module is the key guardian of the core principle of double-entry
--   accounting, which is that debits and credits must always balance. An
--   <a>Ent</a> is a container for an <tt>Entry</tt>. An <tt>Entry</tt>
--   holds a <tt>DrCr</tt> and an <tt>Amount</tt> which, in turn, holds a
--   <tt>Commodity</tt> and a <tt>Qty</tt>. For a given <tt>Commodity</tt>
--   in a particular transaction, the sum of the debits must always be
--   equal to the sum of the credits.
--   
--   In addition to the <tt>Entry</tt>, the <a>Ent</a> holds information
--   about whether the particular <tt>Entry</tt> it holds is inferred or
--   not. An Ent is <tt>inferred</tt> if the user did not supply the entry,
--   but Penny was able to deduce its <tt>Entry</tt> because proper entries
--   were supplied for all the other postings in the transaction. The
--   <a>Ent</a> also holds arbitrary metadata--which will typically be
--   other information about the particular posting, such as the payee,
--   account, etc.
--   
--   A collection of <a>Ent</a> is an <a>Ents</a>. This module will only
--   create an <a>Ent</a> as part of an <a>Ents</a> (though you can later
--   separate the <a>Ent</a> from its other <a>Ents</a> if you like.) In
--   any given <a>Ents</a>, all of the <a>Ent</a> collectively have a zero
--   balance.
--   
--   This module also contains type synonyms used to represent a Posting,
--   which is an Ent bundled with its sibling Ents, and a Transaction.
module Penny.Lincoln.Ents

-- | Information about an entry, along with whether it is inferred and its
--   metadata.
data Ent m

-- | The entry from an Ent. If the Ent is inferred--that is, if the user
--   did not supply an entry for it and Penny was able to infer the
--   entry--this will be a Right with the inferred Entry.
entry :: Ent m -> Either (Entry QtyRep) (Entry Qty)

-- | The metadata accompanying an Ent
meta :: Ent m -> m

-- | True if the entry was inferred.
inferred :: Ent m -> Bool
data Ents m
unEnts :: Ents m -> [Ent m]

-- | Every Ents alwas contains at least two ents, and possibly additional
--   ones.
tupleEnts :: Ents m -> (Ent m, Ent m, [Ent m])

-- | Alter the metadata Ents, while examining the Ents themselves. If you
--   only want to change the metadata and you don't need to examine the
--   other contents of the Ent, use the Functor instance. You cannot change
--   non-metadata aspects of the Ent.
mapEnts :: (Ent a -> b) -> Ents a -> Ents b

-- | Alter the metadata of Ents while examing their contents. If you do not
--   need to examine their contents, use the Traversable instance.
traverseEnts :: Applicative f => (Ent a -> f b) -> Ents a -> f (Ents b)

-- | Creates an <a>Ents</a>. At most, one of the Maybe Entry can be Nothing
--   and this function will infer the remaining Entry. This function fails
--   if it cannot create a balanced Ents.
ents :: [(Maybe (Either (Entry QtyRep) (Entry Qty)), m)] -> Maybe (Ents m)

-- | Creates <a>Ents</a>. Unlike <a>ents</a> this function never fails
--   because you are restricted in the inputs that you can give it. It will
--   always infer the last Entry. All Entries except one will have the same
--   DrCr; the last, inferred one will have the opposite DrCr.
rEnts :: Commodity -> DrCr -> (Either QtyRep Qty, m) -> [(Either QtyRep Qty, m)] -> m -> Ents m

-- | Get information from the head posting in the View, which is the one
--   you are most likely interested in. This never fails, as every Ents has
--   at least two postings.
headEnt :: Ents m -> Ent m

-- | Get information on sibling Ents.
tailEnts :: Ents m -> (Ent m, [Ent m])

-- | In a Posting, the Ent yielded by <a>headEnt</a> will be the posting of
--   interest. The other sibling postings are also available for
--   inspection.
newtype Posting
Posting :: (TopLineData, Ents PostingData) -> Posting
unPosting :: Posting -> (TopLineData, Ents PostingData)

-- | A Transaction and a Posting are identical on the inside, but they have
--   different semantic meanings so they are wrapped in newtypes.
newtype Transaction
Transaction :: (TopLineData, Ents PostingData) -> Transaction
unTransaction :: Transaction -> (TopLineData, Ents PostingData)

-- | Splits a Transaction into Postings.
transactionToPostings :: Transaction -> [Posting]

-- | In a Posting, the Ent at the front of the list of Ents is the main
--   posting. There are additional postings. This function rearranges the
--   Ents multiple times so that each posting is at the head of the list
--   exactly once.
views :: Ents m -> [Ents m]

-- | <pre>
--   unrollSnd (undefined, []) == []
--   unrollSnd (1, [1,2,3]) = [(1,1), (1,2), (1,3)]
--   </pre>
unrollSnd :: (a, [b]) -> [(a, b)]
instance Eq m => Eq (Ent m)
instance Ord m => Ord (Ent m)
instance Show m => Show (Ent m)
instance Eq m => Eq (Ents m)
instance Ord m => Ord (Ents m)
instance Show m => Show (Ents m)
instance Functor Ents
instance Eq Transaction
instance Show Transaction
instance Eq Posting
instance Show Posting
instance Traversable Ents
instance Foldable Ents
instance Equivalent m => Equivalent (Ents m)
instance Functor Ent
instance Equivalent m => Equivalent (Ent m)


-- | Like <a>Queries</a> but instead of querying the main posting of the
--   PostFam, queries the siblings. Therefore, these functions return a
--   list, with each entry in the list containing the best answer for each
--   sibling. There is one item in the list for each sibling, even if all
--   these items contain the same data (for instance, a posting might have
--   five siblings, but all five siblings might have the same payee.
--   Nonetheless the <a>payee</a> function will return a list of five
--   items.)
module Penny.Lincoln.Queries.Siblings

-- | For all siblings, uses information from the Posting if it is set;
--   otherwise, uses data from the TopLine.
bestSibs :: (PostingCore -> Maybe a) -> (TopLineCore -> Maybe a) -> Posting -> [Maybe a]

-- | For all siblings, get the information from the Posting if it exists;
--   otherwise Nothing.
sibs :: (Ent PostingData -> a) -> Posting -> [a]
payee :: Posting -> [Maybe Payee]
number :: Posting -> [Maybe Number]
flag :: Posting -> [Maybe Flag]
postingMemo :: Posting -> [Maybe Memo]
account :: Posting -> [Account]
tags :: Posting -> [Tags]
entry :: Posting -> [Either (Entry QtyRep) (Entry Qty)]
balance :: Posting -> [Balance]
drCr :: Posting -> [DrCr]
amount :: Posting -> [Either (Amount QtyRep) (Amount Qty)]
qty :: Posting -> [Qty]
commodity :: Posting -> [Commodity]
postingLine :: Posting -> [Maybe PostingLine]
side :: Posting -> [Maybe Side]
spaceBetween :: Posting -> [Maybe SpaceBetween]
globalPosting :: Posting -> [Maybe GlobalPosting]
filePosting :: Posting -> [Maybe FilePosting]
globalTransaction :: Posting -> [Maybe GlobalTransaction]


-- | Functions that return a boolean based upon some criterion that matches
--   something, often a PostFam. Useful when filtering Postings.
module Penny.Lincoln.Predicates.Siblings
type LPdct = Predbox Posting
type MakePdct = Predbox Text -> LPdct
payee :: MakePdct
number :: MakePdct
flag :: MakePdct
postingMemo :: MakePdct

-- | A Pdct that returns True if <tt>compare subject qty</tt> returns the
--   given Ordering.
qty :: Ordering -> Qty -> LPdct
parseQty :: Text -> Maybe (Qty -> LPdct)
drCr :: DrCr -> LPdct
debit :: LPdct
credit :: LPdct
commodity :: Predbox Text -> LPdct
account :: Predbox Text -> LPdct
accountLevel :: Int -> Predbox Text -> LPdct
accountAny :: Predbox Text -> LPdct
tag :: Predbox Text -> LPdct

-- | True if a posting is reconciled; that is, its flag is exactly
--   <tt>R</tt>.
reconciled :: LPdct

-- | Makes Pdct based on comparisons against a particular serial.
serialPdct :: Text -> ((TopLineData, Ent PostingData) -> Maybe Int) -> Int -> Ordering -> Predbox Posting
type MakeSerialPdct = Int -> Ordering -> Predbox Posting
fwdGlobalPosting :: MakeSerialPdct
backGlobalPosting :: MakeSerialPdct
fwdFilePosting :: MakeSerialPdct
backFilePosting :: MakeSerialPdct
fwdGlobalTransaction :: MakeSerialPdct
backGlobalTransaction :: MakeSerialPdct
fwdFileTransaction :: MakeSerialPdct
backFileTransaction :: MakeSerialPdct


-- | Examining a Posting for a particular component of the main posting (as
--   opposed to the sibling postings) in the Posting. For some components,
--   such as the payee, the posting might have one piece of data while the
--   TopLine has something else. These functions will examine the Posting
--   first and, if it has no information, use the data from the TopLine if
--   it is there.
module Penny.Lincoln.Queries

-- | Uses the data from the Posting if it is set; otherwise, use the data
--   from the TopLine.
best :: (TopLineData -> Maybe a) -> (Ents PostingData -> Maybe a) -> Posting -> Maybe a
payee :: Posting -> Maybe Payee
number :: Posting -> Maybe Number
flag :: Posting -> Maybe Flag
postingMemo :: Posting -> Maybe Memo
transactionMemo :: Posting -> Maybe Memo
dateTime :: Posting -> DateTime
localDay :: Posting -> Day
account :: Posting -> Account
tags :: Posting -> Tags
entry :: Posting -> Either (Entry QtyRep) (Entry Qty)
balance :: Posting -> Balance
drCr :: Posting -> DrCr
amount :: Posting -> Either (Amount QtyRep) (Amount Qty)
eiQty :: Posting -> Either QtyRep Qty

-- | Every Posting either has a Qty or it can be computed from its QtyRep.
qty :: Posting -> Qty
commodity :: Posting -> Commodity
topMemoLine :: Posting -> Maybe TopMemoLine
topLineLine :: Posting -> Maybe TopLineLine
globalTransaction :: Posting -> Maybe GlobalTransaction
fileTransaction :: Posting -> Maybe FileTransaction
globalPosting :: Posting -> Maybe GlobalPosting
filePosting :: Posting -> Maybe FilePosting
postingLine :: Posting -> Maybe PostingLine
side :: Posting -> Maybe Side
spaceBetween :: Posting -> Maybe SpaceBetween
filename :: Posting -> Maybe Filename


-- | Functions that return a boolean based upon some criterion that matches
--   something, often a PostFam. Useful when filtering Postings.
module Penny.Lincoln.Predicates
type LPdct = Predbox Posting
type MakePdct = Predbox Text -> LPdct
payee :: MakePdct
number :: MakePdct
flag :: MakePdct
postingMemo :: MakePdct
transactionMemo :: MakePdct
date :: Ordering -> UTCTime -> LPdct
qty :: Ordering -> Qty -> LPdct
drCr :: DrCr -> LPdct
debit :: LPdct
credit :: LPdct
commodity :: Predbox Text -> LPdct
account :: Predbox Text -> LPdct
accountLevel :: Int -> Predbox Text -> LPdct
accountAny :: Predbox Text -> LPdct
tag :: Predbox Text -> LPdct

-- | True if a posting is reconciled; that is, its flag is exactly
--   <tt>R</tt>.
reconciled :: LPdct
filename :: Predbox Text -> LPdct

-- | Makes Pdct based on comparisons against a particular serial.
serialPdct :: Text -> (a -> Maybe Int) -> Int -> Ordering -> Predbox a
type MakeSerialPdct = Int -> Ordering -> Predbox Posting
fwdGlobalPosting :: MakeSerialPdct
backGlobalPosting :: MakeSerialPdct
fwdFilePosting :: MakeSerialPdct
backFilePosting :: MakeSerialPdct
fwdGlobalTransaction :: MakeSerialPdct
backGlobalTransaction :: MakeSerialPdct
fwdFileTransaction :: MakeSerialPdct
backFileTransaction :: MakeSerialPdct


-- | Partial functions that make common types in Lincoln. Some data types
--   in Lincoln are deeply nested, with TextNonEmpty nested inside of a
--   newtype, nested inside of a NonEmptyList, nested inside of... :) All
--   the nesting ensures to the maximum extent possible that the type
--   system reflects the restrictions that exist on Penny's data. For
--   example, it would make no sense to have an empty account (that is, an
--   account with no sub-accounts) or a sub-account whose name is an empty
--   Text.
--   
--   The disadvantage of the nesting is that building these data types can
--   be tedious if, for example, you want to build some data within a short
--   custom Haskell program. Thus, this module.
module Penny.Lincoln.Builders

-- | Create an Account. You supply a single Text, with colons to separate
--   the different sub-accounts.
account :: Text -> Account


-- | Shield - the Penny runtime environment
--   
--   Both Cabin and Copper can benefit from knowing information about the
--   Penny runtime environment, such as environment variables and whether
--   standard output is a terminal. That information is provided by the
--   Runtime type. In the future this module may also provide information
--   about the POSIX locale configuration. For now, that information would
--   require reaching into the FFI and so it is not implemented.
module Penny.Shield
data ScreenLines
unScreenLines :: ScreenLines -> Int
data ScreenWidth
unScreenWidth :: ScreenWidth -> Int
data Output
IsTTY :: Output
NotTTY :: Output

-- | Information about the runtime environment.
data Runtime
environment :: Runtime -> [(String, String)]
currentTime :: Runtime -> DateTime
output :: Runtime -> Output
screenLines :: Runtime -> Maybe ScreenLines
screenWidth :: Runtime -> Maybe ScreenWidth
data Term
term :: Runtime -> Maybe Term
runtime :: IO Runtime

-- | Determines which Chunk Term to use based on the TERM environment
--   variable, regardless of whether standard output is a terminal. Uses
--   Dumb if TERM is not set.
termFromEnv :: Runtime -> Term

-- | Determines which Chunk Term to use based on whether standard output is
--   a terminal. Uses Dumb if standard output is not a terminal; otherwise,
--   uses the TERM environment variable.
autoTerm :: Runtime -> Term
instance Show ScreenLines
instance Show ScreenWidth
instance Eq Output
instance Ord Output
instance Show Output
instance Show Term


-- | Lincoln - the Penny core
--   
--   Penny's core types and classes are here. This module re-exports the
--   most useful things. For more details you will want to look at the
--   sub-modules. Also, not all types and functions are re-exported due to
--   naming conflicts. In particular, neither
--   <a>Penny.Lincoln.Predicates</a> nor <a>Penny.Lincoln.Queries</a> is
--   exported from here due to the blizzard of name conflicts that would
--   result.
module Penny.Lincoln

-- | Displays a PostFam in a one line format.
--   
--   Format:
--   
--   File LineNo Date Payee Acct DrCr Cmdty Qty
display :: (Amount Qty -> Text) -> Posting -> Text

module Penny.Brenner.Types

-- | The date reported by the financial institution.
newtype Date
Date :: Day -> Date
unDate :: Date -> Day

-- | Reports changes in account balances. Avoids using <i>debit</i> and
--   <i>credit</i> as these terms are used differently by the bank than in
--   your ledger (that is, the bank reports it from their perspective, not
--   yours) so instead the terms <i>increase</i> and <i>decrease</i> are
--   used. IncDec is used to record the bank's transactions so
--   <i>increase</i> and <i>decrease</i> are used in the same way you would
--   see them on a bank statement, whether it's a credit card, loan,
--   checking account, etc.
data IncDec

-- | Increases the account balance. For a checking or savings account, this
--   is a deposit. For a credit card, this is a purchase.
Increase :: IncDec

-- | Decreases the account balance. On a credit card, this is a payment. On
--   a checking account, this is a withdrawal.
Decrease :: IncDec

-- | A unique number assigned by Brenner to identify each posting. This is
--   unique within a particular financial institution account only.
newtype UNumber
UNumber :: Integer -> UNumber
unUNumber :: UNumber -> Integer

-- | For Brenner to work, the bank has to assign unique identifiers to each
--   transaction that it gives you for download. This is the easiest
--   reliable way to ensure duplicates are not processed multiple times.
--   (There are other ways to accomplish this, but they are much harder and
--   less reliable.) If the bank does not do this, you can't use Brenner.
newtype FitId
FitId :: Text -> FitId
unFitId :: FitId -> Text

-- | Some financial institutions assign a separate Payee in addition to a
--   description. Others just have a single Description field. If this
--   institution uses both, put something here. Brenner will prefer the
--   Payee if it is not zero length; then it will use the Desc.
newtype Payee
Payee :: Text -> Payee
unPayee :: Payee -> Text

-- | The transaction description. Some institutions assign only a
--   description (sometimes muddling a payee with long codes, some dates,
--   etc). Brenner prefers the Payee if there is one, and uses a Desc
--   otherwise.
newtype Desc
Desc :: Text -> Desc
unDesc :: Desc -> Text

-- | The amount of the transaction. Do not include any leading plus or
--   minus signs; this should be only digits and a decimal point.
data Amount

-- | Ensures that incoming Amounts have only digits and (up to) one decimal
--   point.
mkAmount :: String -> Maybe Amount
translate :: IncDec -> Translator -> DrCr
type DbMap = Map UNumber Posting
type DbList = [(UNumber, Posting)]
data Posting
Posting :: Date -> Desc -> IncDec -> Amount -> Payee -> FitId -> Posting
date :: Posting -> Date
desc :: Posting -> Desc
incDec :: Posting -> IncDec
amount :: Posting -> Amount
payee :: Posting -> Payee
fitId :: Posting -> FitId

-- | Where is the database of postings?
newtype DbLocation
DbLocation :: Text -> DbLocation
unDbLocation :: DbLocation -> Text

-- | A name used to refer to a batch of settings.
newtype FitAcctName
FitAcctName :: Text -> FitAcctName
unFitAcctName :: FitAcctName -> Text

-- | Text description of the financial institution account.
newtype FitAcctDesc
FitAcctDesc :: Text -> FitAcctDesc
unFitAcctDesc :: FitAcctDesc -> Text

-- | Text description of the parser itself.
newtype ParserDesc
ParserDesc :: Text -> ParserDesc
unParserDesc :: ParserDesc -> Text

-- | The Penny account holding postings for this financial institution. For
--   instance it might be <tt>Assets:Checking</tt> if this is your checking
--   account, <tt>Liabilities:Credit Card</tt>, or whatever.
newtype PennyAcct
PennyAcct :: Account -> PennyAcct
unPennyAcct :: PennyAcct -> Account

-- | What the financial institution shows as an increase or decrease has to
--   be recorded as a debit or credit in the PennyAcct.
data Translator

-- | That is, when the financial institution shows a posting that increases
--   your account balance, you record a debit. You will probably use this
--   for deposit accounts, like checking and savings. These are asset
--   accounts so if the balance goes up you record a debit in your ledger.
IncreaseIsDebit :: Translator

-- | That is, when the financial institution shows a posting that increases
--   your account balance, you record a credit. You will probably use this
--   for liabilities, such as credit cards and other loans.
IncreaseIsCredit :: Translator

-- | The default account to place unclassified postings in. For instance
--   <tt>Expenses:Unclassified</tt>.
newtype DefaultAcct
DefaultAcct :: Account -> DefaultAcct
unDefaultAcct :: DefaultAcct -> Account

-- | The currency for all transactions, e.g. <tt>$</tt>.
newtype Currency
Currency :: Commodity -> Currency
unCurrency :: Currency -> Commodity

-- | A batch of settings representing a single financial institution
--   account.
data FitAcct
FitAcct :: FitAcctName -> FitAcctDesc -> DbLocation -> PennyAcct -> DefaultAcct -> Currency -> S3 Radix PeriodGrp CommaGrp -> Translator -> Side -> SpaceBetween -> (ParserDesc, FitFileLocation -> IO (Either String [Posting])) -> (Desc -> Payee -> Payee) -> FitAcct
fitAcctName :: FitAcct -> FitAcctName
fitAcctDesc :: FitAcct -> FitAcctDesc
dbLocation :: FitAcct -> DbLocation
pennyAcct :: FitAcct -> PennyAcct
defaultAcct :: FitAcct -> DefaultAcct
currency :: FitAcct -> Currency

-- | How to turn Qty into QtyRep.
qtySpec :: FitAcct -> S3 Radix PeriodGrp CommaGrp
translator :: FitAcct -> Translator

-- | When creating new transactions, the commodity will be on this side
side :: FitAcct -> Side

-- | When creating new transactions, is there a space between the commodity
--   and the quantity
spaceBetween :: FitAcct -> SpaceBetween

-- | Parses a file of transactions from the financial institution. The
--   function must open the file and parse it. This is in the IO monad not
--   only because the function must open the file itself, but also so the
--   function can perform arbitrary IO (run pdftotext, maybe?) If there is
--   failure, the function can return an Exceptional String, which is the
--   error message. Alternatively the function can raise an exception in
--   the IO monad (currently Brenner makes no attempt to catch these) so if
--   any of the IO functions throw you can simply not handle the
--   exceptions.
--   
--   The first element of the pair gives information about the parser.
parser :: FitAcct -> (ParserDesc, FitFileLocation -> IO (Either String [Posting]))

-- | Sometimes the financial institution provides Payee information,
--   sometimes it does not. Sometimes the Desc might have additional
--   information that you might want to remove. This function can be used
--   to do that. The resulting Lincoln Payee is used for any transactions
--   that are created by the merge command. The resulting payee is also
--   used when comparing new financial institution postings to already
--   existing ledger transactions in order to guess at which payee and
--   accounts to create in the transactions created by the merge command.
toLincolnPayee :: FitAcct -> Desc -> Payee -> Payee

-- | Configuration for the Brenner program. You can optionally have a
--   default FitAcct, which is used if you do not specify any FitAcct on
--   the command line. You can also name any number of additional FitAccts.
--   If you do not specify a default FitAcct, you must specify a FitAcct on
--   the command line.
data Config
Config :: Maybe FitAcct -> [FitAcct] -> Config
defaultFitAcct :: Config -> Maybe FitAcct
moreFitAccts :: Config -> [FitAcct]
newtype FitFileLocation
FitFileLocation :: String -> FitFileLocation
unFitFileLocation :: FitFileLocation -> String
newtype AllowNew
AllowNew :: Bool -> AllowNew
unAllowNew :: AllowNew -> Bool

-- | All parsers must be of this type.
type ParserFn = FitFileLocation -> IO (Either String [Posting])

-- | The type of all Brenner MultiArg modes.
type Mode = Maybe FitAcct -> Mode (ProgName -> String) (IO ())
instance Eq Date
instance Show Date
instance Ord Date
instance Read Date
instance Eq IncDec
instance Show IncDec
instance Read IncDec
instance Eq UNumber
instance Show UNumber
instance Ord UNumber
instance Read UNumber
instance Eq FitId
instance Show FitId
instance Ord FitId
instance Read FitId
instance Eq Payee
instance Show Payee
instance Ord Payee
instance Read Payee
instance Eq Desc
instance Show Desc
instance Ord Desc
instance Read Desc
instance Eq Amount
instance Show Amount
instance Ord Amount
instance Read Amount
instance Read Posting
instance Show Posting
instance Eq DbLocation
instance Show DbLocation
instance Eq FitAcctDesc
instance Show FitAcctDesc
instance Eq ParserDesc
instance Show ParserDesc
instance Eq FitAcctName
instance Show FitAcctName
instance Eq PennyAcct
instance Show PennyAcct
instance Eq Translator
instance Show Translator
instance Eq DefaultAcct
instance Show DefaultAcct
instance Eq Currency
instance Show Currency
instance Show FitFileLocation
instance Eq FitFileLocation
instance Show AllowNew
instance Eq AllowNew
instance HasText Currency
instance HasTextList DefaultAcct
instance HasTextList PennyAcct
instance HasText FitAcctName
instance HasText ParserDesc
instance HasText FitAcctDesc
instance HasText DbLocation
instance Serialize Posting
instance Serialize Amount
instance Serialize Desc
instance Serialize Payee
instance Serialize FitId
instance Serialize UNumber
instance Serialize IncDec
instance Serialize Date


-- | Parses any OFX 1.0-series file. Uses the parser from the ofx package.
--   
--   The Postings that this module returns <i>always</i> have an empty
--   Description field. Information from the OFX Payee field is placed into
--   the Payee field of the Posting record.
module Penny.Brenner.OFX

-- | Parser for OFX files.
parser :: (ParserDesc, ParserFn)

-- | Parser for OFX files. Any incoming data is first filtered through the
--   given function. This allows you to correct broken OFX statements. For
--   example, Bank of America issues OFX files that do not properly escape
--   ampersands. Using this function you can change every ampersand to
--   something properly escaped (or just change it to the word "and".)
prepassParser :: (String -> String) -> (ParserDesc, ParserFn)

module Penny.Brenner.Info
mode :: Config -> Mode (ProgName -> String) (IO ())


-- | Metadata that is specific to Cabin.
module Penny.Cabin.Meta

-- | Each row that is visible on screen is assigned a VisibleNum. This is
--   used to number the rows in the report for the user's benefit. It is
--   also used to determine whether the row is even or odd for the purpose
--   of assigning the background color (this way the background colors can
--   alternate, like a checkbook register.)
newtype VisibleNum
VisibleNum :: Serial -> VisibleNum
unVisibleNum :: VisibleNum -> Serial
instance Eq VisibleNum
instance Show VisibleNum

module Penny.Copper.Interface
data ParsedTopLine
ParsedTopLine :: DateTime -> Maybe Number -> Maybe Flag -> Maybe Payee -> Maybe (Memo, TopMemoLine) -> TopLineLine -> ParsedTopLine
ptlDateTime :: ParsedTopLine -> DateTime
ptlNumber :: ParsedTopLine -> Maybe Number
ptlFlag :: ParsedTopLine -> Maybe Flag
ptlPayee :: ParsedTopLine -> Maybe Payee
ptlMemo :: ParsedTopLine -> Maybe (Memo, TopMemoLine)
ptlTopLineLine :: ParsedTopLine -> TopLineLine
toTopLineCore :: ParsedTopLine -> TopLineCore
type ParsedTxn = (ParsedTopLine, Ents (PostingCore, PostingLine))
data BlankLine
BlankLine :: BlankLine
newtype Comment
Comment :: Text -> Comment
unComment :: Comment -> Text
type ParsedItem = S4 ParsedTxn PricePoint Comment BlankLine
type LedgerItem = S4 Transaction PricePoint Comment BlankLine
type Parser = String -> IO (Filename, [ParsedItem])

-- | Changes a ledger item to remove metadata.
stripMeta :: LedgerItem -> S4 (TopLineCore, Ents PostingCore) PricePoint Comment BlankLine
instance Show ParsedTopLine
instance Eq BlankLine
instance Show BlankLine
instance Eq Comment
instance Show Comment


-- | Renders Penny data in a format that can be parsed by
--   <a>Penny.Copper.Parsec</a>. These functions render text that is
--   compliant with the EBNF grammar which is at
--   <tt>doc/ledger-grammar.org</tt>.
module Penny.Copper.Render

-- | Merges a list of words into one Text; however, if any given Text is
--   empty, that Text is first dropped from the list.
txtWords :: [Text] -> Text

-- | Takes a field that may or may not be present and a function that
--   renders it. If the field is not present at all, returns an empty Text.
--   Otherwise will succeed or fail depending upon whether the rendering
--   function succeeds or fails.
renMaybe :: Maybe a -> (a -> Maybe Text) -> Maybe Text

-- | Is True if a sub account can be rendered at Level 1; False otherwise.
isSubAcctLvl1 :: SubAccount -> Bool
isAcctLvl1 :: Account -> Bool
quotedLvl1Acct :: Account -> Maybe Text
isFirstSubAcctLvl2 :: SubAccount -> Bool
isOtherSubAcctLvl2 :: SubAccount -> Bool
isAcctLvl2 :: Account -> Bool
lvl2Acct :: Account -> Maybe Text

-- | Shows an account, with the minimum level of quoting possible. Fails
--   with an error if any one of the characters in the account name does
--   not satisfy the <tt>lvl1Char</tt> predicate. Otherwise returns a
--   rendered account, quoted if necessary.
ledgerAcct :: Account -> Maybe Text

-- | Render a quoted Level 1 commodity. Fails if any character does not
--   satisfy lvl1Char.
quotedLvl1Cmdty :: Commodity -> Maybe Text

-- | Render a Level 2 commodity. Fails if the first character is not a
--   letter or a symbol, or if any other character is a space.
lvl2Cmdty :: Commodity -> Maybe Text

-- | Render a Level 3 commodity. Fails if any character is not a letter or
--   a symbol.
lvl3Cmdty :: Commodity -> Maybe Text

-- | Gets the characters necessary to quote a qtyRep.
quoteQtyRep :: QtyRep -> (Text, Text)
qtyRep :: QtyRep -> Text
hasSpace :: WholeOrFrac (GroupedDigits PeriodGrp) -> Bool

-- | Render an Amount. The Format is required so that the commodity can be
--   displayed in the right place.
amount :: Maybe (Amount Qty -> S3 Radix PeriodGrp CommaGrp) -> Maybe Side -> Maybe SpaceBetween -> Either (Amount QtyRep) (Amount Qty) -> Maybe Text
comment :: Comment -> Maybe Text

-- | Render a DateTime. The day is always printed. If the time zone offset
--   is not zero, then the time and time zone offset are both printed. If
--   the time zone offset is zero, then the hours and minutes are printed,
--   but only if the time is not midnight. If the seconds are not zero,
--   they are also printed.
dateTime :: DateTime -> Text
pad2 :: Text -> Text
pad4 :: Text -> Text
showX :: Show a => a -> Text
hoursMinsSecsZone :: Hours -> Minutes -> Seconds -> TimeZoneOffset -> Text
entry :: Maybe (Amount Qty -> S3 Radix PeriodGrp CommaGrp) -> Maybe Side -> Maybe SpaceBetween -> Either (Entry QtyRep) (Entry Qty) -> Maybe Text
flag :: Flag -> Maybe Text

-- | Renders a postingMemoLine, optionally with trailing whitespace. The
--   trailing whitespace allows the next line to be indented properly if is
--   also a postingMemoLine. This is handled using trailing whitespace
--   rather than leading whitespace because leading whitespace is
--   inconsistent with the grammar.
postingMemoLine :: Int -> Text -> Maybe Text

-- | Renders a postingMemo. Fails if the postingMemo is empty, as the
--   grammar requires that they have at least one line.
--   
--   If the boolean is True, inserts padding after the last postingMemoLine
--   so that the next line is indented by four columns. Use this if the
--   posting memo is followed by another posting. If the last boolean if
--   False, there is no indenting after the last postingMemoLine.
postingMemo :: Bool -> Memo -> Maybe Text
transactionMemoLine :: Text -> Maybe Text
transactionMemo :: Memo -> Maybe Text
number :: Number -> Maybe Text
quotedLvl1Payee :: Payee -> Maybe Text
lvl2Payee :: Payee -> Maybe Text
payee :: Payee -> Maybe Text
price :: PricePoint -> Maybe Text
tag :: Tag -> Maybe Text
tags :: Tags -> Maybe Text

-- | Renders the TopLine. Emits trailing whitespace after the newline so
--   that the first posting is properly indented.
topLine :: TopLineCore -> Maybe Text

-- | Renders a Posting. Fails if any of the components fail to render. In
--   addition, if the unverified Posting has an Entry, a Format must be
--   provided, otherwise render fails.
--   
--   The columns look like this. Column numbers begin with 0 (like they do
--   in Emacs) rather than with column 1 (like they do in Vim). (Really
--   Emacs is the strange one; most CLI utilities seem to start with column
--   1 too...)
--   
--   <pre>
--   ID COLUMN WIDTH WHAT
--   ---------------------------------------------------
--   A    0      4     Blank spaces for indentation
--   B    4      50    Flag, Number, Payee, Account, Tags
--   C    54     2     Blank spaces for padding
--   D    56     NA    Entry
--   </pre>
--   
--   Omit the padding after column B if there is no entry; also omit
--   columns C and D entirely if there is no Entry. (It is annoying to have
--   extraneous blank space in a file).
--   
--   This table is a bit of a lie, because the blank spaces for indentation
--   are emitted either by the posting previous to this one (either after
--   the posting itself or after its postingMemo) or by the TopLine.
--   
--   Also emits an additional eight spaces after the trailing newline if
--   the posting has a memo. That way the memo will be indented properly.
--   (There are trailing spaces here, as opposed to leading spaces in the
--   posting memo, because the latter would be inconsistent with the
--   grammar.)
--   
--   Emits an extra four spaces after the first line if the first paramter
--   is True. However, this is overriden if there is a memo, in which case
--   eight spaces will be emitted. (This allows the next posting to be
--   indented properly.)
posting :: Maybe (Amount Qty -> S3 Radix PeriodGrp CommaGrp) -> Bool -> Ent PostingCore -> Maybe Text
formatter :: Bool -> Text -> Text -> Text -> Text -> Text -> Text -> Text -> Text
transaction :: Maybe (Amount Qty -> S3 Radix PeriodGrp CommaGrp) -> (TopLineCore, Ents PostingCore) -> Maybe Text
item :: Maybe (Amount Qty -> S3 Radix PeriodGrp CommaGrp) -> S4 (TopLineCore, Ents PostingCore) PricePoint Comment BlankLine -> Maybe Text


-- | Parsec parsers for the ledger file format.
module Penny.Copper.Parsec
nonEmpty :: Parser a -> Parser (NonEmpty a)
lvl1SubAcct :: Parser SubAccount
lvl1FirstSubAcct :: Parser SubAccount
lvl1OtherSubAcct :: Parser SubAccount
lvl1Acct :: Parser Account
quotedLvl1Acct :: Parser Account
lvl2FirstSubAcct :: Parser SubAccount
lvl2OtherSubAcct :: Parser SubAccount
lvl2Acct :: Parser Account
ledgerAcct :: Parser Account
lvl1Cmdty :: Parser Commodity
quotedLvl1Cmdty :: Parser Commodity
lvl2Cmdty :: Parser Commodity
lvl3Cmdty :: Parser Commodity
digit :: Parser Digit
digitList :: Parser DigitList
groupPart :: Parser a -> Parser (a, DigitList)
groupedDigits :: Parser a -> Parser (GroupedDigits a)

-- | Parses a sequence of grouped digits, followed by an optional radix
--   point, followed by an optional additional sequence of grouped digits.
--   Numbers such as .25 are not allowed; instead, the user must enter
--   0.25. Also not allowed is something like <a>25.</a>. Intsead, if the
--   user enters a radix, there must be a character after it.
digitsRadDigits :: Parser a -> Parser void -> Parser (GroupedDigits a, Maybe (GroupedDigits a))

-- | Parses an unquoted QtyRep.
unquotedQtyRep :: Parser QtyRep

-- | Parses an unquoted QtyRep that also has spaces. Use only when parsing
--   command line items.
unquotedQtyRepWithSpaces :: Parser QtyRep

-- | Parses a QtyRep that is quoted with square braces. This is a QtyRep
--   that uses a comma as the radix point.
quotedCommaQtyRep :: Parser QtyRep

-- | Parses a QtyRep that is quoted with curly braces. This is a QtyRep
--   that uses a period as the radix point. Unlike an unquoted QtyRep this
--   can include spaces.
quotedPeriodQtyRep :: Parser QtyRep
qtyRep :: Parser QtyRep
spaceBetween :: Parser SpaceBetween
leftCmdtyLvl1Amt :: Parser (Amount QtyRep, Side, SpaceBetween)
leftCmdtyLvl3Amt :: Parser (Amount QtyRep, Side, SpaceBetween)
leftSideCmdtyAmt :: Parser (Amount QtyRep, Side, SpaceBetween)
rightSideCmdty :: Parser Commodity
rightSideCmdtyAmt :: Parser (Amount QtyRep, Side, SpaceBetween)
amount :: Parser (Amount QtyRep, Side, SpaceBetween)
comment :: Parser Comment
year :: Parser Integer
month :: Parser Int
day :: Parser Int
date :: Parser Day
hours :: Parser Hours
minutes :: Parser Minutes
seconds :: Parser Seconds
time :: Parser (Hours, Minutes, Maybe Seconds)
tzSign :: Parser (Int -> Int)
tzNumber :: Parser Int
timeZone :: Parser TimeZoneOffset
timeWithZone :: Parser (Hours, Minutes, Maybe Seconds, Maybe TimeZoneOffset)
dateTime :: Parser DateTime
debit :: Parser DrCr
credit :: Parser DrCr
drCr :: Parser DrCr
entry :: Parser (Entry QtyRep, Side, SpaceBetween)
flag :: Parser Flag
postingMemoLine :: Parser Text
postingMemo :: Parser Memo
transactionMemoLine :: Parser Text
transactionMemo :: Parser (TopMemoLine, Memo)
number :: Parser Number
lvl1Payee :: Parser Payee
quotedLvl1Payee :: Parser Payee
lvl2Payee :: Parser Payee
fromCmdty :: Parser From
lineNum :: Parser Int
price :: Parser PricePoint
tag :: Parser Tag
tags :: Parser Tags
topLinePayee :: Parser Payee
topLineFlagNum :: Parser (Maybe Flag, Maybe Number)
skipWhite :: Parser ()
topLine :: Parser ParsedTopLine
flagNumPayee :: Parser (Maybe Flag, Maybe Number, Maybe Payee)
postingAcct :: Parser Account
posting :: Parser (PostingCore, PostingLine, Maybe (Entry QtyRep))
transaction :: Parser ParsedTxn
blankLine :: Parser ()
item :: Parser ParsedItem
parse :: Text -> Either String [ParsedItem]
getStdin :: IO Text
getFileContentsStdin :: String -> IO (Filename, Text)
parseStdinOnly :: IO (Filename, [ParsedItem])
parseFromFilename :: String -> IO (Filename, [ParsedItem])
handleParseError :: String -> String -> IO a


-- | Liberty - Penny command line parsing utilities
--   
--   Both Cabin and Zinc share various functions that aid in parsing
--   command lines. For instance both the Postings report and the Zinc
--   postings filter use common command-line options. However, Zinc already
--   depends on Cabin. To avoid a cyclic dependency whereby Cabin would
--   also depend on Zinc, functions formerly in Zinc that Cabin will also
--   find useful are relocated here, to Liberty.
module Penny.Liberty
type MatcherFactory = CaseSensitive -> Text -> Either Text (Predbox Text)

-- | A serial indicating how a post relates to all other postings that made
--   it through the filtering phase.
newtype FilteredNum
FilteredNum :: Serial -> FilteredNum
unFilteredNum :: FilteredNum -> Serial

-- | A serial indicating how a posting relates to all other postings that
--   have been sorted.
newtype SortedNum
SortedNum :: Serial -> SortedNum
unSortedNum :: SortedNum -> Serial

-- | All metadata from Liberty.
data LibertyMeta

-- | Takes a list of transactions, splits them into PostingChild instances,
--   filters them, post-filters them, sorts them, and places them in Box
--   instances with Filtered serials. Also returns Chunks containing a
--   description of the evalutation process.
xactionsToFiltered :: LPdct -> [PostFilterFn] -> (Posting -> Posting -> Ordering) -> [Transaction] -> ((Amount Qty -> Text) -> [Chunk], [(LibertyMeta, Posting)])
newtype ListLength
ListLength :: Int -> ListLength
unListLength :: ListLength -> Int
newtype ItemIndex
ItemIndex :: Int -> ItemIndex
unItemIndex :: ItemIndex -> Int

-- | Specifies options for the post-filter stage.
type PostFilterFn = ListLength -> ItemIndex -> Bool

-- | Parses comparers given on command line to a function. Fails if the
--   string given is invalid.
parseComparer :: String -> (Ordering -> Predbox a) -> Either InputError (Predbox a)
processPostFilters :: [PostFilterFn] -> [a] -> [a]

-- | Parses a list of tokens to obtain a predicate. Deals with an empty
--   list of tokens by returning a predicate that is always True. Fails if
--   the list of tokens is not empty and the parse fails.
parsePredicate :: ExprDesc -> [Token a] -> Either Error (Predbox a)

-- | Parses exactly one integer; fails if it cannot read exactly one.
parseInt :: String -> Either Error Int
parseIntMA :: String -> Either InputError Int
parseInfix :: OptSpec ExprDesc
parseRPN :: OptSpec ExprDesc

-- | Both Infix and RPN options.
exprDesc :: [OptSpec ExprDesc]
showExpression :: OptSpec ()
verboseFilter :: OptSpec ()
type Operand = Predbox Posting

-- | All operand OptSpec.
operandSpecs :: DateTime -> [OptSpec (CaseSensitive -> MatcherFactory -> Either Error Operand)]
postFilterSpecs :: (OptSpec PostFilterFn, OptSpec PostFilterFn)
matcherSelectSpecs :: [OptSpec MatcherFactory]
caseSelectSpecs :: [OptSpec CaseSensitive]
operatorSpecs :: [OptSpec (Token a)]

-- | Prints the binary's version and the version of the library, and exits
--   successfully.
version :: Version -> String -> String

-- | An option for where the user would like to send output.
output :: OptSpec (Text -> IO ())

-- | Given a list of output options, returns a single IO action to write to
--   all given files. If the list was empty, returns an IO action that
--   writes to standard output.
processOutput :: [Text -> IO ()] -> Text -> IO ()

-- | A multiline Text that holds an error message.
type Error = Text
instance Show FilteredNum
instance Show SortedNum
instance Show LibertyMeta
instance Eq ListLength
instance Ord ListLength
instance Show ListLength
instance Eq ItemIndex
instance Ord ItemIndex
instance Show ItemIndex
instance Show BadHeadTailError

module Penny.Brenner.Util

-- | Print an error message and exit.
errExit :: String -> IO a

-- | Gets the FitAcct, if it was provided. If it was not provided, exit
--   with an error message.
getFitAcct :: Maybe FitAcct -> IO FitAcct

-- | Loads the database from disk. If allowNew is True, then does not fail
--   if the file was not found.
loadDb :: AllowNew -> DbLocation -> IO DbList

-- | File version. Increment this when anything in the file format changes.
version :: Int
brenner :: String
readDbTuple :: ByteString -> Either String DbList
saveDbTuple :: DbList -> ByteString

-- | Writes a new database to disk.
saveDb :: DbLocation -> DbList -> IO ()

-- | Parses quantities from amounts. All amounts should be verified as
--   having only digits, optionally followed by a point and then more
--   digits. All these values should parse. So if there is a problem it is
--   a programmer error. Apply error.
parseQty :: Amount -> Qty
label :: String -> Text -> String

-- | Shows a Posting in human readable format.
showPosting :: Posting -> String
showDbPair :: (UNumber, Posting) -> String

module Penny.Brenner.Database
mode :: Mode

module Penny.Brenner.Import
mode :: Mode


-- | Prints parsed transactions.
--   
--   TODO add support to this and other Brenner components for reading from
--   stdin.
module Penny.Brenner.Print
mode :: Mode


-- | Copper - the Penny parser.
--   
--   The parse functions in this module only accept lists of files rather
--   than individual files because in order to correctly assign the global
--   serials a single function must be able to see all the transactions,
--   not just the transactions in a single file.
--   
--   Some notes about Copper and performance:
--   
--   Running Penny on the datasets I typically use takes about two seconds.
--   This does not seem very long on paper, and indeed it isn't very long,
--   but it would be nice if this were instantaneous. Profiles consistently
--   show that the most time-consuming part of running Penny is the Parsec
--   parse of the incoming data. After eliminating the Parsec phase, the
--   profile is not showing any parts of the program whose runtime could be
--   shortened easily--the time is spent scattered amongst many functions.
--   
--   So the clear place to hunt for performance improvements is in the
--   Parsec phase. And, indeed, I have tried many things to improve this
--   phase. I tried using a parser based on Happy and Alex rather than
--   Parsec; this code is tagged in the Git repository, though it is so old
--   that many of the other data structures in Penny have since changed.
--   Happy and Alex did not yield any significant performance improvement.
--   As I recall, between Parsec and Happy/Alex, one was a little faster
--   but used more memory, though I can't remember which was which.
--   
--   The problem with using Happy and Alex is that it is a bit harder to
--   test and to maintain. Each Parsec parser is freestanding and can be
--   tested on its own; doing this with Happy would be harder. Happy
--   parsers also are not written in Haskell, though I'm not sure this is a
--   disadvantage. And, of course an advantage to Happy is that it warns
--   you if your grammar is ambiguous; Parsec will only reveal this through
--   usage or through meticulous testing.
--   
--   It isn't worth using Happy/Alex in Penny because of the negligible
--   performance difference. Parsec has much better error messages than
--   Happy/Alex, which turns out to be critically important.
--   
--   Another thing I tried was using Attoparsec, which bills itself as
--   being faster. The speed improvements were negligible, and Parsec error
--   messages are much better than those in Attoparsec. I would have been
--   willing to maintain a Parsec and an Attoparsec parser if the latter
--   were faster. Penny could parse with Attoparsec first and, if that
--   fails, use Parsec and use its error message. But Attoparsec was so
--   negligibly faster that I did not think this worthwhile.
--   
--   Another thing I tried was using the <tt>binary</tt> package to
--   serialize the data in binary form. This shaved off a fair amont of run
--   time. But Penny still did not feel instantaneous--run time probably
--   dropped by about 40 percent, which is significant. The big
--   disadvantage to using binary is that you then need to get plain-text
--   ledger files into binary form, save them, and then use the binary form
--   if it is up to date. Doing this manually imposes a big burden on the
--   user to convert plain text to binary. Doing it automatically could
--   work but would be a lot of code. And then, you would need to factor
--   converstion time into the performance comparison. Again, not worth it
--   for the performance improvement involved.
--   
--   Probably the best performance improvement would come from putting the
--   whole ledger into SQLite. This would, however, run into the same
--   problems that exist with using a binary format: you need to convert
--   from plain text, or perhaps write an editor to change the binary
--   natively. I'm not eager to write an editor (we already have Emacs).
--   Furthermore, using SQLite would likely require a significant
--   re-engineering of Penny.
--   
--   So, Penny continues to use the simplest, most obvious solution--a
--   Parsec parser--not from inertia or because Parsec is the default
--   choice; rather, Parsec so far has proven to be the best solution to
--   this problem.
module Penny.Copper

-- | Reads and parses the given files. If any of the files is <tt>-</tt>,
--   reads standard input. If the list of files is empty, reads standard
--   input. IO errors are not caught. Parse errors are printed to standard
--   error and the program will exit with a failure.
open :: [String] -> IO [LedgerItem]
item :: Maybe (Amount Qty -> S3 Radix PeriodGrp CommaGrp) -> S4 (TopLineCore, Ents PostingCore) PricePoint Comment BlankLine -> Maybe Text

module Penny.Brenner.Clear
mode :: Mode

module Penny.Brenner.Merge
mode :: Mode
instance Eq Arg


-- | Brenner - Penny financial institution interfaces
--   
--   Brenner provides a uniform way to interact with downloaded data from
--   financial Given a parser, Brenner will import the transactions and
--   store them in a database. From there it is easy to merge the
--   transactions (without duplicates) into a ledger file, and then to
--   clear transactions from statements in an automated fashion.
module Penny.Brenner

-- | Information to configure a single financial institution account.
data FitAcct
FitAcct :: String -> String -> String -> String -> String -> String -> S3 Radix PeriodGrp CommaGrp -> Translator -> Side -> SpaceBetween -> (ParserDesc, FitFileLocation -> IO (Either String [Posting])) -> (Desc -> Payee -> Payee) -> FitAcct

-- | Name for this financial institution account, e.g. <tt>House
--   Checking</tt> or <tt>Megabank</tt>.
fitAcctName :: FitAcct -> String

-- | Additional information about this financial institution account. Here
--   I put information on where to find the statments for download on the
--   website.
fitAcctDesc :: FitAcct -> String

-- | Path and filename to where the database is kept. You can use an
--   absolute or relative path (if it is relative, it will be resolved
--   relative to the current directory at runtime.)
dbLocation :: FitAcct -> String

-- | The account that you use in your Penny file to hold transactions for
--   this card. Separate each sub-account with colons (as you do in the
--   Penny file.)
pennyAcct :: FitAcct -> String

-- | When new transactions are created, one of the postings will be in the
--   amexAcct given above. The other posting will be in this account.
defaultAcct :: FitAcct -> String

-- | The commodity for the currency of your card (e.g. <tt>$</tt>).
currency :: FitAcct -> String

-- | How to group digits when printing the resulting ledger.
--   
--   Penny remembers the formatting of quantities entered in your ledger.
--   However, quantities imported from your bank statement do not have
--   formatting to remember, so you have to tell Penny how to format them.
qtySpec :: FitAcct -> S3 Radix PeriodGrp CommaGrp

-- | See the documentation under the <tt>Translator</tt> type for details.
translator :: FitAcct -> Translator

-- | When creating new transactions, the commodity will be on this side
side :: FitAcct -> Side

-- | When creating new transactions, is there a space between the commodity
--   and the quantity
spaceBetween :: FitAcct -> SpaceBetween

-- | Parses a file of transactions from the financial institution. The
--   function must open the file and parse it. This is in the IO monad not
--   only because the function must open the file itself, but also so the
--   function can perform arbitrary IO (run pdftotext, maybe?) If there is
--   failure, the function can return an Exceptional String, which is the
--   error message. Alternatively the function can raise an exception in
--   the IO monad (currently Brenner makes no attempt to catch these) so if
--   any of the IO functions throw you can simply not handle the
--   exceptions.
--   
--   The first element of the pair is a help string which should indicate
--   how to download the data, as a helpful reminder.
parser :: FitAcct -> (ParserDesc, FitFileLocation -> IO (Either String [Posting]))

-- | Sometimes the financial institution provides Payee information,
--   sometimes it does not. Sometimes the Desc might have additional
--   information that you might want to remove. This function can be used
--   to do that. The resulting Lincoln Payee is used for any transactions
--   that are created by the merge command. The resulting payee is also
--   used when comparing new financial institution postings to already
--   existing ledger transactions in order to guess at which payee and
--   accounts to create in the transactions created by the merge command.
toLincolnPayee :: FitAcct -> Desc -> Payee -> Payee
data Config
Config :: Maybe FitAcct -> [FitAcct] -> Config
defaultFitAcct :: Config -> Maybe FitAcct
moreFitAccts :: Config -> [FitAcct]
data S3 a b c :: * -> * -> * -> *
S3a :: a -> S3 a b c
S3b :: b -> S3 a b c
S3c :: c -> S3 a b c
data Radix
Period :: Radix
Comma :: Radix

-- | The digit grouping character when the radix is a period.
data PeriodGrp

-- | ASCII space
PGSpace :: PeriodGrp

-- | Unicode code point 0x2009
PGThinSpace :: PeriodGrp

-- | Comma
PGComma :: PeriodGrp

-- | The digit grouping character when the radix is a comma.
data CommaGrp

-- | ASCII space
CGSpace :: CommaGrp

-- | Unicode code point 0x2009
CGThinSpace :: CommaGrp

-- | Period
CGPeriod :: CommaGrp

-- | What the financial institution shows as an increase or decrease has to
--   be recorded as a debit or credit in the PennyAcct.
data Translator

-- | That is, when the financial institution shows a posting that increases
--   your account balance, you record a debit. You will probably use this
--   for deposit accounts, like checking and savings. These are asset
--   accounts so if the balance goes up you record a debit in your ledger.
IncreaseIsDebit :: Translator

-- | That is, when the financial institution shows a posting that increases
--   your account balance, you record a credit. You will probably use this
--   for liabilities, such as credit cards and other loans.
IncreaseIsCredit :: Translator

-- | The commodity and and the quantity may appear with the commodity on
--   the left (e.g. USD 2.14) or with the commodity on the right (e.g. 2.14
--   USD).
data Side
CommodityOnLeft :: Side
CommodityOnRight :: Side

-- | There may or may not be a space in between the commodity and the
--   quantity.
data SpaceBetween
SpaceBetween :: SpaceBetween
NoSpaceBetween :: SpaceBetween

-- | A simple function to use for <a>toLincolnPayee</a>. Uses the financial
--   institution payee if it is available; otherwise, uses the financial
--   institution description.
usePayeeOrDesc :: Desc -> Payee -> Payee

-- | Brenner, with a pre-compiled configuration.
brennerMain :: Version -> Config -> IO ()

-- | Parser for OFX data.
ofxParser :: (ParserDesc, ParserFn)

-- | Parser for OFX data, with a prepass phase. Any incoming data is first
--   filtered through the given function. This allows you to correct broken
--   OFX statements. For example, Bank of America issues OFX files that do
--   not properly escape ampersands. Using this function you can change
--   every ampersand to something properly escaped (or just change it to
--   the word "and".)
ofxPrepassParser :: (String -> String) -> (ParserDesc, ParserFn)

module Penny.Denver.Diff
main :: IO ()
instance Eq File
instance Show File
instance Eq Args
instance Show Args

module Penny.Denver.Reprint
main :: IO ()

module Penny.Denver.Reconcile
main :: IO ()


-- | Wheat - Penny ledger tests
--   
--   Wheat helps you build tests to check all the postings in your ledger.
--   Perhaps you want to make sure all the account names are valid, or that
--   your checking account has no unreconciled transactions. With Wheat you
--   can easily build a command line program that will check all the
--   postings in a ledger for you against criteria that you specify.
module Penny.Wheat

-- | Record holding all data to configure Wheat.
data WheatConf
WheatConf :: String -> [String] -> [UTCTime -> Test Posting] -> IndentAmt -> Maybe TestVerbosity -> (Name -> Bool) -> Bool -> Bool -> UTCTime -> ([LedgerItem] -> Amount Qty -> Text) -> WheatConf

-- | This is displayed at the beginning of the online help. It should be a
--   one-line description of what this program does--for example, what it
--   checks for.
briefDescription :: WheatConf -> String

-- | Displayed at the end of the online help. It should be a list of lines,
--   wich each line not terminated by a newline character. It is displayed
--   at the end of the online help.
moreHelp :: WheatConf -> [String]

-- | The actual tests to run. The UTCTime is the <tt>base time</tt>. Each
--   test may decide what to do with the base time--for example, the test
--   might say that all postings have to have a date on or before that
--   date. Or the test might just ignore the base time.
tests :: WheatConf -> [UTCTime -> Test Posting]

-- | How many spaces to indent each level in a tree of tests.
indentAmt :: WheatConf -> IndentAmt

-- | If Just, use this verbosity. If Nothing, use the default verbosity
--   provided by the tests themselves.
verbosity :: WheatConf -> Maybe TestVerbosity

-- | Test names are filtered with this function; a test is only run if this
--   function returns True.
testPred :: WheatConf -> Name -> Bool

-- | If True, then tests will stop running immediately after a single test
--   fails. If False, all tests are always run.
stopOnFail :: WheatConf -> Bool

-- | Use colors even if stdout is not a file?
colorToFile :: WheatConf -> Bool

-- | Tests may use this date and time as they wish; see <a>tests</a>.
--   Typically you will set this to the current instant.
baseTime :: WheatConf -> UTCTime

-- | How to format quantities
formatQty :: WheatConf -> [LedgerItem] -> Amount Qty -> Text

-- | Passes only if each posting is True.
eachPostingMustBeTrue :: Name -> Predbox Posting -> Test Posting

-- | Passes if at least a particular number of postings is True.
atLeastNPostings :: Int -> Name -> Predbox Posting -> Test Posting

-- | A non-terminating list of starting with the first day of the first
--   month following the given day, followed by successive first days of
--   the month.
futureFirstsOfTheMonth :: Day -> [Day]

-- | Runs Wheat tests. Prints the result to standard output. Exits
--   unsuccessfully if the user gave bad command line options or if at
--   least a single test failed; exits successfully if all tests succeeded.
--   Shows the version number and exits successfully if that was requested.
main :: Version -> (Runtime -> WheatConf) -> IO ()


-- | Cabin color schemes
--   
--   Each element of a Cabin report identifies what it is--a debit on an
--   even line, a credit on an odd line, etc. The user can have several
--   color schemes; the scheme contains color assignments for 8 and 256
--   color terminals. This allows the use of different schemes for light
--   and dark terminals or for any other reason.
module Penny.Cabin.Scheme
data Label
Debit :: Label
Credit :: Label
Zero :: Label
Other :: Label
data EvenOdd
Even :: EvenOdd
Odd :: EvenOdd
data Labels a
Labels :: a -> a -> a -> a -> Labels a
debit :: Labels a -> a
credit :: Labels a -> a
zero :: Labels a -> a
other :: Labels a -> a
getLabelValue :: Label -> Labels a -> a
data EvenAndOdd a
EvenAndOdd :: a -> a -> EvenAndOdd a
eoEven :: EvenAndOdd a -> a
eoOdd :: EvenAndOdd a -> a
type Changers = Labels (EvenAndOdd (Chunk -> Chunk))
data Scheme
Scheme :: String -> String -> Changers -> Scheme

-- | The name of this scheme. How it will be identified on the command
--   line.
name :: Scheme -> String

-- | A brief (one-line) description of what this scheme is, such as <tt>for
--   dark background terminals</tt>
description :: Scheme -> String
changers :: Scheme -> Changers
getEvenOdd :: EvenOdd -> EvenAndOdd a -> a
getEvenOddLabelValue :: Label -> EvenOdd -> Labels (EvenAndOdd a) -> a
fromVisibleNum :: VisibleNum -> EvenOdd
dcToLbl :: DrCr -> Label
bottomLineToDrCr :: Maybe DrCr -> EvenOdd -> Changers -> Chunk
balancesToCmdtys :: Changers -> EvenOdd -> [(Commodity, BottomLine)] -> [Chunk]
bottomLineToCmdty :: Changers -> EvenOdd -> (Commodity, BottomLine) -> Chunk
balanceToQtys :: Changers -> (Amount Qty -> Text) -> EvenOdd -> [(Commodity, BottomLine)] -> [Chunk]
bottomLineToQty :: Changers -> (Amount Qty -> Text) -> EvenOdd -> (Commodity, BottomLine) -> Chunk
instance Eq Label
instance Ord Label
instance Show Label
instance Eq EvenOdd
instance Ord EvenOdd
instance Show EvenOdd
instance Show a => Show (Labels a)
instance Show a => Show (EvenAndOdd a)


-- | Displays a single on-screen row. A row may contain multiple screen
--   lines and multiple columns.
--   
--   This module only deals with a single row at a time. Each cell in the
--   row can have more than one screen line; this module will make sure
--   that the cells have appropriate padding on the bottom so that the row
--   appears nicely. This module will also justify each cell so that its
--   left side or right side is ragged; however, you first have to specify
--   how wide you want the cell to be.
--   
--   This module is a little dumber than you might first think it could be.
--   For instance it would be possible to write a function that takes a
--   number of rows and automatically justifies all the cells by finding
--   the widest cell in a column. Indeed I might eventually write such a
--   function because it might be useful in, for example, the
--   multi-commodity balance report. However, such a function would not be
--   useful in all cases; in particular, the Posts report is very
--   complicated to lay out, and the automatic function described above
--   would not do the right thing.
--   
--   So this module offers some useful automation, even if it is at a level
--   that is apparently lower that what is possible. Thus the present
--   <a>row</a> function likely will not change, even if eventually I add a
--   <tt>table</tt> function that automatically justifies many rows.
module Penny.Cabin.Row

-- | How to justify cells. LeftJustify leaves the right side ragged.
--   RightJustify leaves the left side ragged.
data Justification
LeftJustify :: Justification
RightJustify :: Justification

-- | A cell of text output. You tell the cell how to justify itself and how
--   wide it is. You also tell it the background colors to use. The cell
--   will be appropriately justified (that is, text aligned between left
--   and right margins) and padded (with lines of blank text added on the
--   bottom as needed) when joined with other cells into a Row.
data ColumnSpec
ColumnSpec :: Justification -> Width -> (Label, EvenOdd) -> [Chunk] -> ColumnSpec
justification :: ColumnSpec -> Justification
width :: ColumnSpec -> Width
padSpec :: ColumnSpec -> (Label, EvenOdd)
bits :: ColumnSpec -> [Chunk]
newtype Width
Width :: Int -> Width
unWidth :: Width -> Int
row :: Changers -> [ColumnSpec] -> [Chunk]
instance Show Justification
instance Eq Width
instance Ord Width
instance Show Width
instance Show Height
instance Eq Height
instance Ord Height


-- | Creates the output Chunks for the Balance report for multi-commodity
--   reports only.
module Penny.Cabin.Balance.Convert.Chunker

-- | Displays a single account in a Balance report. In a single-commodity
--   report, this account will only be one screen line long. In a
--   multi-commodity report, it might be multiple lines long, with one
--   screen line for each commodity.
data MainRow
MainRow :: Int -> Text -> BottomLine -> MainRow

-- | Indent the account name by this many levels (not by this many spaces;
--   this number is multiplied by another number in the Chunker source to
--   arrive at the final indentation amount)
mrIndentation :: MainRow -> Int

-- | Text for the name of the account
mrText :: MainRow -> Text

-- | Commodity balances. If this list is empty, dashes are displayed for
--   the DrCr and Qty.
mrBottomLine :: MainRow -> BottomLine

-- | Displays a one-column row.
data OneColRow
OneColRow :: Int -> Text -> OneColRow

-- | Indent the text by this many levels (not by this many spaces; this
--   number is multiplied by another number in the Chunker source to arrive
--   at the final indentation amount)
ocIndentation :: OneColRow -> Int

-- | Text for the left column
ocText :: OneColRow -> Text
data Row
RMain :: MainRow -> Row
ROneCol :: OneColRow -> Row
rowsToChunks :: Changers -> (Qty -> Text) -> [Row] -> [Chunk]
instance Show a => Show (Columns a)
instance Applicative Columns
instance Functor Columns


-- | Some schemes you can use.
module Penny.Cabin.Scheme.Schemes

-- | The light color scheme. You can change various values below to affect
--   the color scheme.
light :: Scheme
lightLabels :: Labels (EvenAndOdd (Chunk -> Chunk))
lightEvenTextSpec :: Chunk -> Chunk
lightOddTextSpec :: Chunk -> Chunk
lightDebit :: (Chunk -> Chunk) -> Chunk -> Chunk
lightCredit :: (Chunk -> Chunk) -> Chunk -> Chunk
lightZero :: (Chunk -> Chunk) -> Chunk -> Chunk

-- | The dark color scheme. You can change various values below to affect
--   the color scheme.
dark :: Scheme
darkLabels :: Labels (EvenAndOdd (Chunk -> Chunk))
darkEvenTextSpec :: Chunk -> Chunk
darkOddTextSpec :: Chunk -> Chunk
darkDebit :: (Chunk -> Chunk) -> Chunk -> Chunk
darkCredit :: (Chunk -> Chunk) -> Chunk -> Chunk
darkZero :: (Chunk -> Chunk) -> Chunk -> Chunk

-- | Plain scheme has no colors at all.
plain :: Scheme
plainLabels :: Labels (EvenAndOdd (Chunk -> Chunk))


-- | Creates the output Chunks for the Balance report for both
--   multi-commodity reports.
module Penny.Cabin.Balance.MultiCommodity.Chunker

-- | Displays a single account in a Balance report. In a single-commodity
--   report, this account will only be one screen line long. In a
--   multi-commodity report, it might be multiple lines long, with one
--   screen line for each commodity.
data Row
Row :: Int -> Text -> [(Commodity, BottomLine)] -> Row

-- | Indent the account name by this many levels (not by this many spaces;
--   this number is multiplied by another number in the Chunker source to
--   arrive at the final indentation amount)
indentation :: Row -> Int

-- | Text for the name of the account
accountTxt :: Row -> Text

-- | Commodity balances. If this list is empty, dashes are displayed for
--   the DrCr, Commodity, and Qty.
balances :: Row -> [(Commodity, BottomLine)]
rowsToChunks :: Changers -> (Amount Qty -> Text) -> [Row] -> [Chunk]
instance Show a => Show (Columns a)
instance Applicative Columns
instance Functor Columns


-- | Spacer fields in the report. They don't contain any data; they just
--   provide whitespace. Each spacer immediately follows the named field.
module Penny.Cabin.Posts.Spacers
data Spacers a
Spacers :: a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Spacers a
globalTransaction :: Spacers a -> a
revGlobalTransaction :: Spacers a -> a
globalPosting :: Spacers a -> a
revGlobalPosting :: Spacers a -> a
fileTransaction :: Spacers a -> a
revFileTransaction :: Spacers a -> a
filePosting :: Spacers a -> a
revFilePosting :: Spacers a -> a
filtered :: Spacers a -> a
revFiltered :: Spacers a -> a
sorted :: Spacers a -> a
revSorted :: Spacers a -> a
visible :: Spacers a -> a
revVisible :: Spacers a -> a
lineNum :: Spacers a -> a
date :: Spacers a -> a
flag :: Spacers a -> a
number :: Spacers a -> a
payee :: Spacers a -> a
account :: Spacers a -> a
postingDrCr :: Spacers a -> a
postingCmdty :: Spacers a -> a
postingQty :: Spacers a -> a
totalDrCr :: Spacers a -> a
totalCmdty :: Spacers a -> a
instance Show a => Show (Spacers a)
instance Eq a => Eq (Spacers a)


-- | Fields that can appear in the Posts report.
module Penny.Cabin.Posts.Fields
data Fields a
Fields :: a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Fields a
globalTransaction :: Fields a -> a
revGlobalTransaction :: Fields a -> a
globalPosting :: Fields a -> a
revGlobalPosting :: Fields a -> a
fileTransaction :: Fields a -> a
revFileTransaction :: Fields a -> a
filePosting :: Fields a -> a
revFilePosting :: Fields a -> a
filtered :: Fields a -> a
revFiltered :: Fields a -> a
sorted :: Fields a -> a
revSorted :: Fields a -> a
visible :: Fields a -> a
revVisible :: Fields a -> a
lineNum :: Fields a -> a
date :: Fields a -> a
flag :: Fields a -> a
number :: Fields a -> a
payee :: Fields a -> a
account :: Fields a -> a
postingDrCr :: Fields a -> a
postingCmdty :: Fields a -> a
postingQty :: Fields a -> a
totalDrCr :: Fields a -> a
totalCmdty :: Fields a -> a
totalQty :: Fields a -> a
tags :: Fields a -> a
memo :: Fields a -> a
filename :: Fields a -> a
fieldNames :: Fields String
instance Show a => Show (Fields a)
instance Eq a => Eq (Fields a)
instance Foldable Fields
instance Applicative Fields
instance Functor Fields


-- | Options applicable to multiple Cabin reports.
module Penny.Cabin.Options

-- | Whether to show zero balances in reports.
newtype ShowZeroBalances
ShowZeroBalances :: Bool -> ShowZeroBalances
unShowZeroBalances :: ShowZeroBalances -> Bool

-- | Converts an ordering to a descending order.
descending :: (a -> a -> Ordering) -> a -> a -> Ordering
instance Show ShowZeroBalances
instance Eq ShowZeroBalances


-- | Command line parsers that are common to various Cabin reports.
module Penny.Cabin.Parsers
zeroBalances :: OptSpec ShowZeroBalances
data SortOrder
Ascending :: SortOrder
Descending :: SortOrder
order :: OptSpec SortOrder
help :: OptSpec ()
instance Eq SortOrder
instance Ord SortOrder
instance Show SortOrder

module Penny.Cabin.Posts.Meta

-- | Each row that is visible on screen is assigned a VisibleNum. This is
--   used to number the rows in the report for the user's benefit. It is
--   also used to determine whether the row is even or odd for the purpose
--   of assigning the background color (this way the background colors can
--   alternate, like a checkbook register.)
data VisibleNum
data PostMeta

-- | Adds appropriate metadata, including the running balance, to a list of
--   Box. Because all posts are incorporated into the running balance,
--   first calculates the running balance for all posts. Then, removes
--   posts we're not interested in by applying the predicate and the
--   post-filter. Finally, adds on the metadata, which will include the
--   VisibleNum.
toBoxList :: ShowZeroBalances -> Predbox (LibertyMeta, Posting) -> [PostFilterFn] -> [(LibertyMeta, Posting)] -> [(PostMeta, Posting)]
instance Show PostMeta


-- | Calculates cells that <a>grow to fit.</a> These cells grow to fit the
--   widest cell in the column. No information is ever truncated from these
--   cells (what use is a truncated dollar amount?)
module Penny.Cabin.Posts.Growers

-- | All the options needed to grow the cells.
data GrowOpts
GrowOpts :: ((PostMeta, Posting) -> Text) -> (Amount Qty -> Text) -> Fields Bool -> GrowOpts
dateFormat :: GrowOpts -> (PostMeta, Posting) -> Text
qtyFormat :: GrowOpts -> Amount Qty -> Text
fields :: GrowOpts -> Fields Bool

-- | Grows the cells that will be GrowToFit cells in the report. First this
--   function fills in all visible cells with text, but leaves the width
--   undetermined. Then it determines the widest line in each column.
--   Finally it adjusts each cell in the column so that it is that maximum
--   width.
--   
--   Returns a list of rows, and a Fields holding the width of each cell.
--   Each of these widths will be at least 1; fields that were in the
--   report but that ended up having no width are changed to Nothing.
growCells :: Changers -> GrowOpts -> [(PostMeta, Posting)] -> Fields (Maybe ([ColumnSpec], Int))

-- | All growing fields.
data Fields a
Fields :: a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Fields a
globalTransaction :: Fields a -> a
revGlobalTransaction :: Fields a -> a
globalPosting :: Fields a -> a
revGlobalPosting :: Fields a -> a
fileTransaction :: Fields a -> a
revFileTransaction :: Fields a -> a
filePosting :: Fields a -> a
revFilePosting :: Fields a -> a
filtered :: Fields a -> a
revFiltered :: Fields a -> a
sorted :: Fields a -> a
revSorted :: Fields a -> a
visible :: Fields a -> a
revVisible :: Fields a -> a

-- | The line number from the posting's metadata
lineNum :: Fields a -> a
date :: Fields a -> a
flag :: Fields a -> a
number :: Fields a -> a
postingDrCr :: Fields a -> a
postingCmdty :: Fields a -> a
postingQty :: Fields a -> a
totalDrCr :: Fields a -> a
totalCmdty :: Fields a -> a
totalQty :: Fields a -> a

-- | Compute the width of all Grown cells, including any applicable spacer
--   cells.
grownWidth :: Fields (Maybe Int) -> Spacers Int -> Int

-- | Returns a Fields where each record has its corresponding EField.
eFields :: Fields EFields

-- | All growing fields, as an ADT.
data EFields
EGlobalTransaction :: EFields
ERevGlobalTransaction :: EFields
EGlobalPosting :: EFields
ERevGlobalPosting :: EFields
EFileTransaction :: EFields
ERevFileTransaction :: EFields
EFilePosting :: EFields
ERevFilePosting :: EFields
EFiltered :: EFields
ERevFiltered :: EFields
ESorted :: EFields
ERevSorted :: EFields
EVisible :: EFields
ERevVisible :: EFields
ELineNum :: EFields
EDate :: EFields
EFlag :: EFields
ENumber :: EFields
EPostingDrCr :: EFields
EPostingCmdty :: EFields
EPostingQty :: EFields
ETotalDrCr :: EFields
ETotalCmdty :: EFields
ETotalQty :: EFields

-- | Pairs data from a Fields with its matching spacer field. The spacer
--   field is returned in a Maybe because the TotalQty field does not have
--   a spacer.
pairWithSpacer :: Fields a -> Spacers b -> Fields (a, Maybe b)
instance Show EFields
instance Eq EFields
instance Ord EFields
instance Enum EFields
instance Show a => Show (Fields a)
instance Eq a => Eq (Fields a)
instance Applicative Fields
instance Functor Fields
instance Foldable Fields


-- | Calculates the allocated cells -- the Payee cell and the Account cell.
--   Here is the logic for this process:
--   
--   <ol>
--   <li>If neither Payee nor Account appears, do nothing.</li>
--   <li>Obtain the width of the growing cells, including the spacers. One
--   of the spacers attached to a field might be omitted:</li>
--   </ol>
--   
--   a. If the rightmost growing field is TotalQty, include all spacers.
--   
--   b. If the rightmost growing field is to the left of Payee, include all
--   spacers.
--   
--   c. If the rightmost growing field is to the right of Account but is
--   not TotalQty, omit its spacer.
--   
--   <ol>
--   <li>Obtain the width of the Payee and Account spacers. Include each
--   spacer if its corresponding field appears in the report.</li>
--   <li>Subtract from the total report width the width of the the growing
--   cells and the width of the Payee and Account spacers. This gives the
--   total width available for the Payee and Account fields. If there are
--   not at least two columns available, return without including the Payee
--   and Account fields.</li>
--   <li>Determine the total width that the Payee and Account fields would
--   obtain if they had all the space they could ever need. This is the
--   <a>requested width</a>.</li>
--   <li>Split up the available width for the Payee and Account fields
--   depending on which fields appear:</li>
--   </ol>
--   
--   a. If only the one field appears, then it shall be as wide as the
--   total available width or the its requested width, whichever is
--   smaller.
--   
--   b. If both fields appear, then calculate the allocated width for each
--   field. If either field's requested width is less than its allocated
--   width, then that field is only as wide as its requested width. The
--   other field is then as wide as (the sum of its allocated width and the
--   leftover width from the other field) or its requested width, whichever
--   is smaller. If neither field's requested width is less than its
--   allocated width, then each field gets ts allocated width.
--   
--   <ol>
--   <li>Fill cell contents; return filled cells.</li>
--   </ol>
module Penny.Cabin.Posts.Allocated

-- | Creates Payee and Account cells. The user must have requested the
--   cells. In addition, no cells are created if there is not enough space
--   for them in the report. Returns a Fields; each element of the Fields
--   is Nothing if no cells were created (either because the user did not
--   ask for them, or because there was no room) or Just cs i, where cs is
--   a list of all the cells, and i is the width of all the cells.
payeeAndAcct :: Changers -> AllocatedOpts -> [(PostMeta, Posting)] -> Fields (Maybe ([ColumnSpec], Int))

-- | All the information needed for allocated cells.
data AllocatedOpts
AllocatedOpts :: Fields Bool -> SubAccountLength -> Fields Alloc -> Spacers Int -> Fields (Maybe Int) -> ReportWidth -> AllocatedOpts
fields :: AllocatedOpts -> Fields Bool
subAccountLength :: AllocatedOpts -> SubAccountLength
allocations :: AllocatedOpts -> Fields Alloc
spacers :: AllocatedOpts -> Spacers Int
growerWidths :: AllocatedOpts -> Fields (Maybe Int)
reportWidth :: AllocatedOpts -> ReportWidth
data Fields a
Fields :: a -> a -> Fields a
payee :: Fields a -> a
account :: Fields a -> a
newtype SubAccountLength
SubAccountLength :: Int -> SubAccountLength
unSubAccountLength :: SubAccountLength -> Int
data Alloc
alloc :: Int -> Alloc
unAlloc :: Alloc -> Int
instance Eq a => Eq (Fields a)
instance Show a => Show (Fields a)
instance Show SubAccountLength
instance Show Alloc
instance Eq AvailableWidth
instance Ord AvailableWidth
instance Show AvailableWidth
instance Eq Request
instance Ord Request
instance Show Request
instance Eq Final
instance Ord Final
instance Show Final
instance Traversable Fields
instance Foldable Fields
instance Applicative Fields
instance Functor Fields


-- | Fills the bottom rows, which contain the tags, memo, and filename.
--   These rows are formatted as follows:
--   
--   <ul>
--   <li>If the columns for TotalDrCr, TotalCmdty, and TotalQty are all
--   present, AND if there are at least TWO other columns present, then
--   there will be a hanging indent. The bottom rows will begin at the
--   SECOND column and end with the last column to the left of TotalDrCr.
--   In this case, each bottom row will have three cells: one padding on
--   the left, one main content, and one padding on the right.</li>
--   <li>Otherwise, if there are NO columns in the top row, these rows will
--   take the entire width of the report. Each bottom row will have one
--   cell.</li>
--   <li>Otherwise, the bottom rows are as wide as all the top cells
--   combined. Each bottom row will have one cell.</li>
--   </ul>
module Penny.Cabin.Posts.BottomRows
data BottomOpts
BottomOpts :: Fields (Maybe Int) -> Fields (Maybe Int) -> Fields Bool -> ReportWidth -> Spacers Int -> BottomOpts
growingWidths :: BottomOpts -> Fields (Maybe Int)
allocatedWidths :: BottomOpts -> Fields (Maybe Int)
fields :: BottomOpts -> Fields Bool
reportWidth :: BottomOpts -> ReportWidth
spacers :: BottomOpts -> Spacers Int
bottomRows :: Changers -> BottomOpts -> [(PostMeta, Posting)] -> Fields (Maybe [[Chunk]])
data Fields a
Fields :: a -> a -> a -> Fields a
tags :: Fields a -> a
memo :: Fields a -> a
filename :: Fields a -> a
data TopRowCells a
TopRowCells :: a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> TopRowCells a
globalTransaction :: TopRowCells a -> a
revGlobalTransaction :: TopRowCells a -> a
globalPosting :: TopRowCells a -> a
revGlobalPosting :: TopRowCells a -> a
fileTransaction :: TopRowCells a -> a
revFileTransaction :: TopRowCells a -> a
filePosting :: TopRowCells a -> a
revFilePosting :: TopRowCells a -> a
filtered :: TopRowCells a -> a
revFiltered :: TopRowCells a -> a
sorted :: TopRowCells a -> a
revSorted :: TopRowCells a -> a
visible :: TopRowCells a -> a
revVisible :: TopRowCells a -> a

-- | The line number from the posting's metadata
lineNum :: TopRowCells a -> a
date :: TopRowCells a -> a
flag :: TopRowCells a -> a
number :: TopRowCells a -> a
payee :: TopRowCells a -> a
account :: TopRowCells a -> a
postingDrCr :: TopRowCells a -> a
postingCmdty :: TopRowCells a -> a
postingQty :: TopRowCells a -> a
totalDrCr :: TopRowCells a -> a
totalCmdty :: TopRowCells a -> a
totalQty :: TopRowCells a -> a

-- | Merges a TopRowCells with a Spacers. Returns Maybes because totalQty
--   has no spacer.
mergeWithSpacers :: TopRowCells a -> Spacers b -> TopRowCells (a, Maybe b)
topRowCells :: Fields a -> Fields a -> TopRowCells a
instance Show a => Show (Fields a)
instance Eq a => Eq (Fields a)
instance Show a => Show (Hanging a)
instance Eq a => Eq (Hanging a)
instance Show SpacerWidth
instance Eq SpacerWidth
instance Show ContentWidth
instance Eq ContentWidth
instance Show a => Show (TopRowCells a)
instance Eq a => Eq (TopRowCells a)
instance Show ETopRowCells
instance Eq ETopRowCells
instance Enum ETopRowCells
instance Traversable TopRowCells
instance Foldable TopRowCells
instance Applicative TopRowCells
instance Functor TopRowCells
instance Applicative Fields
instance Functor Fields
instance Foldable Fields

module Penny.Cabin.Posts.Chunk
data ChunkOpts
ChunkOpts :: ((PostMeta, Posting) -> Text) -> (Amount Qty -> Text) -> Fields Bool -> SubAccountLength -> Alloc -> Alloc -> Spacers Int -> ReportWidth -> ChunkOpts
dateFormat :: ChunkOpts -> (PostMeta, Posting) -> Text
qtyFormat :: ChunkOpts -> Amount Qty -> Text
fields :: ChunkOpts -> Fields Bool
subAccountLength :: ChunkOpts -> SubAccountLength
payeeAllocation :: ChunkOpts -> Alloc
accountAllocation :: ChunkOpts -> Alloc
spacers :: ChunkOpts -> Spacers Int
reportWidth :: ChunkOpts -> ReportWidth
makeChunk :: Changers -> ChunkOpts -> [(PostMeta, Posting)] -> [Chunk]


-- | Grab bag of utility functions.
module Penny.Cabin.Balance.Util

-- | Places items into a tiered forest.
tieredForest :: Ord b => (a -> [b]) -> [a] -> ([a], Forest ([a], b))

-- | Takes a list of postings and puts them into a Forest. Each level of
--   each of the trees corresponds to a sub account. The label of the node
--   tells you the sub account name and gives you a list of the postings at
--   that level.
tieredPostings :: [(a, Posting)] -> ([(a, Posting)], Forest (SubAccount, [(a, Posting)]))

-- | Keeps only Trees that match a given condition. First examines child
--   trees to determine whether they should be retained. If a child tree is
--   retained, does not delete the parent tree.
filterForest :: (a -> Bool) -> Forest a -> Forest a

-- | Puts all Boxes into a Tree and sums the balances. Removes accounts
--   that have empty balances if requested. Does NOT sum balances from the
--   bottom up.
balances :: ShowZeroBalances -> [(a, Posting)] -> (Balance, Forest (SubAccount, Balance))

-- | Takes a tree of Balances (like what is produced by the <a>balances</a>
--   function) and produces a flat list of accounts with the balance of
--   each account. Also adds in the first balance, which is for Accounts
--   that have no sub-accounts.
flatten :: (Balance, Forest (SubAccount, Balance)) -> [(Account, Balance)]

-- | Takes a Tree and returns a Tree where each node has information about
--   its parent Nodes. The list of parent nodes has the most immediate
--   parent first and the most distant parent last.
treeWithParents :: Tree a -> Tree (a, [a])

-- | Takes a Forest and returns a Forest where each node has information
--   about its parent Nodes.
forestWithParents :: Forest a -> Forest (a, [a])

-- | Sums a forest from the bottom up. Returns a pair, where the first
--   element is the forest, but with the second element of each node
--   replaced with the sum of that node and all its children. The second
--   element is the sum of all the second elements in the forest.
sumForest :: Monoid s => Forest (a, s) -> (Forest (a, s), s)

-- | Sums a tree from the bottom up.
sumTree :: Monoid s => Tree (a, s) -> Tree (a, s)
boxesBalance :: [(a, Posting)] -> Balance

-- | Label each level of a Tree with an integer indicating how deep it is.
--   The top node of the tree is level 0.
labelLevels :: Tree a -> Tree (Int, a)

-- | Sorts each level of a Forest.
sortForest :: (a -> a -> Ordering) -> Forest a -> Forest a

-- | Sorts each level of a Tree.
sortTree :: (a -> a -> Ordering) -> Tree a -> Tree a

-- | Like lastModeBy but using Ord.
lastMode :: Ord a => [a] -> Maybe a

module Penny.Cabin.Posts.Parser
data State
State :: CaseSensitive -> Factory -> [Token (LibertyMeta, Posting)] -> [PostFilterFn] -> Fields Bool -> ReportWidth -> ShowZeroBalances -> ExprDesc -> VerboseFilter -> ShowExpression -> State
sensitive :: State -> CaseSensitive
factory :: State -> Factory
tokens :: State -> [Token (LibertyMeta, Posting)]
postFilter :: State -> [PostFilterFn]
fields :: State -> Fields Bool
width :: State -> ReportWidth
showZeroBalances :: State -> ShowZeroBalances
exprDesc :: State -> ExprDesc
verboseFilter :: State -> VerboseFilter
showExpression :: State -> ShowExpression
allSpecs :: Runtime -> [OptSpec (State -> Either Error State)]
type Error = Text
newtype VerboseFilter
VerboseFilter :: Bool -> VerboseFilter
unVerboseFilter :: VerboseFilter -> Bool
newtype ShowExpression
ShowExpression :: Bool -> ShowExpression
unShowExpression :: ShowExpression -> Bool
instance Eq VerboseFilter
instance Show VerboseFilter
instance Eq ShowExpression
instance Show ShowExpression
instance Show BadFieldError


-- | An interface for other Penny components to use. A report is anything
--   that is a <a>Report</a>.
module Penny.Cabin.Interface

-- | The function that will print the report, and the positional arguments.
--   If there was a problem parsing the command line options, return an
--   Exception with an error message.
--   
--   Parsing the filter options can have one of two results: a help string,
--   or a list of positional arguments and a function that prints a report.
--   Or, the parse might fail.
type PosArg = String
type HelpStr = String
type ArgsAndReport = ([PosArg], PrintReport)

-- | The result of parsing the arguments to a report. Failures are
--   indicated with a Text. The name of the executable and the word
--   <tt>error</tt> will be prepended to this Text; otherwise, it is
--   printed as-is, so be sure to include any trailing newline if needed.
type ParseResult = Either Text ArgsAndReport
type PrintReport = (Amount Qty -> Text) -> [Transaction] -> [PricePoint] -> Either Text [Chunk]
type Report = Runtime -> (HelpStr, MkReport)
type MkReport = CaseSensitive -> (CaseSensitive -> Text -> Either Text (Predbox Text)) -> Changers -> ExprDesc -> ([Transaction] -> [(LibertyMeta, Posting)]) -> Mode (ProgName -> String) ParseResult


-- | The Penny Postings report
--   
--   The Postings report displays postings in a tabular format designed to
--   be read by humans. Some terminology used in the Postings report:
--   
--   <ul>
--   <li><i><tt>row</tt></i> The smallest unit that spans from left to
--   right. A row, however, might consist of more than one screen line. For
--   example, the running balance is shown on the far right side of the
--   Postings report. The running balance might consist of more than one
--   commodity. Each commodity is displayed on its own screen line.
--   However, all these lines put together are displayed in a single
--   row.</li>
--   <li><i><tt>column</tt></i> The smallest unit that spans from top to
--   bottom.</li>
--   <li><i><tt>tranche</tt></i> Each posting is displayed in several rows.
--   The group of rows that is displayed for a single posting is called a
--   tranche.</li>
--   <li><i><tt>tranche row</tt></i> Each tranche has a particular number
--   of rows (currently four); each of these rows is known as a tranche
--   row.</li>
--   <li><i><tt>field</tt></i> Corresponds to a particular element of the
--   posting, such as whether it is a debit or credit or its payee. The
--   user can select which fields to see.</li>
--   <li><i><tt>allocation</tt></i> The width of the Payee and Account
--   fields is variable. Generally their width will adjust to fill the
--   entire width of the screen. The allocations of the Payee and Account
--   fields determine how much of the remaining space each field will
--   receive.</li>
--   </ul>
--   
--   The Postings report is easily customized from the command line to show
--   various fields. However, the order of the fields is not configurable
--   without editing the source code (sorry).
module Penny.Cabin.Posts

-- | All information needed to make a Posts report. This function never
--   fails.
postsReport :: Changers -> ShowZeroBalances -> (Predbox (LibertyMeta, Posting)) -> [PostFilterFn] -> ChunkOpts -> [(LibertyMeta, Posting)] -> [Chunk]
zincReport :: ZincOpts -> Report
defaultOptions :: Runtime -> ZincOpts

-- | All the information to configure the postings report if the options
--   will be parsed in from the command line.
data ZincOpts
ZincOpts :: Fields Bool -> ReportWidth -> ShowZeroBalances -> ((PostMeta, Posting) -> Text) -> SubAccountLength -> Alloc -> Alloc -> Spacers Int -> ZincOpts

-- | Default fields to show in the report.
fields :: ZincOpts -> Fields Bool

-- | Gives the default report width. This can be overridden on the command
--   line. You can use the information from the Runtime to make this as
--   wide as the current terminal.
width :: ZincOpts -> ReportWidth

-- | Are commodities that have no balance shown in the Total fields of the
--   report?
showZeroBalances :: ZincOpts -> ShowZeroBalances

-- | How to display dates. This function is applied to the a PostingInfo so
--   it has lots of information, but it should return a date for use in the
--   Date field.
dateFormat :: ZincOpts -> (PostMeta, Posting) -> Text

-- | When shortening the names of sub accounts to make them fit, they will
--   be this long.
subAccountLength :: ZincOpts -> SubAccountLength

-- | This and accountAllocation determine how much space payees and
--   accounts receive. They divide up the remaining space after everything
--   else is displayed. For instance if payeeAllocation is 60 and
--   accountAllocation is 40, the payee takes about 60 percent of the
--   remaining space and the account takes about 40 percent.
payeeAllocation :: ZincOpts -> Alloc

-- | See payeeAllocation above
accountAllocation :: ZincOpts -> Alloc

-- | Default width for spacer fields. If any of these Ints are less than or
--   equal to zero, there will be no spacer. There is never a spacer for
--   fields that do not appear in the report.
spacers :: ZincOpts -> Spacers Int
data Alloc
newtype SubAccountLength
SubAccountLength :: Int -> SubAccountLength
unSubAccountLength :: SubAccountLength -> Int
alloc :: Int -> Alloc

-- | Shows the date of a posting in YYYY-MM-DD format.
yearMonthDay :: (PostMeta, Posting) -> Text

-- | The default width for the report.
defaultWidth :: ReportWidth

-- | Applied to the value of the COLUMNS environment variable, returns an
--   appropriate ReportWidth.
columnsVarToWidth :: Maybe String -> ReportWidth

-- | Given the Runtime, use the defaultWidth given above to calculate the
--   report's width if COLUMNS does not yield a value. Otherwise, use what
--   is in COLUMNS.
widthFromRuntime :: Runtime -> ReportWidth

-- | Default fields to show in the Postings report.
defaultFields :: Fields Bool

-- | Default width of spacers; most are one character wide, but the spacer
--   after payee is 4 characters wide.
defaultSpacerWidth :: Spacers Int
newtype ReportWidth
ReportWidth :: Int -> ReportWidth
unReportWidth :: ReportWidth -> Int


-- | Zinc - the Penny command-line interface
module Penny.Zinc
data Defaults
Defaults :: CaseSensitive -> Matcher -> ColorToFile -> Maybe Scheme -> [Scheme] -> [(SortField, SortOrder)] -> ExprDesc -> ([LedgerItem] -> Amount Qty -> Text) -> Defaults
sensitive :: Defaults -> CaseSensitive
matcher :: Defaults -> Matcher
colorToFile :: Defaults -> ColorToFile

-- | If Nothing, no default scheme. If the user does not pick a scheme, no
--   colors are used.
defaultScheme :: Defaults -> Maybe Scheme
moreSchemes :: Defaults -> [Scheme]

-- | For example, to sort by date and then by payee if the dates are equal,
--   use
--   
--   <pre>
--   [(Date, Ascending), (Payee, Ascending)]
--   </pre>
sorter :: Defaults -> [(SortField, SortOrder)]
exprDesc :: Defaults -> ExprDesc
formatQty :: Defaults -> [LedgerItem] -> Amount Qty -> Text

-- | Whether to use color when standard output is not a terminal.
newtype ColorToFile
ColorToFile :: Bool -> ColorToFile
unColorToFile :: ColorToFile -> Bool
data Matcher
Within :: Matcher
Exact :: Matcher
PCRE :: Matcher
data SortField
Payee :: SortField
Date :: SortField
Flag :: SortField
Number :: SortField
Account :: SortField
DrCr :: SortField
Qty :: SortField
Commodity :: SortField
PostingMemo :: SortField
TransactionMemo :: SortField
runZinc :: Version -> Defaults -> Runtime -> [Report] -> IO ()
instance Eq ColorToFile
instance Show ColorToFile
instance Eq Matcher
instance Show Matcher
instance Eq SortField
instance Show SortField
instance Ord SortField
instance Show ShowExpression
instance Eq ShowExpression
instance Show VerboseFilter
instance Eq VerboseFilter


-- | Cabin - Penny reports
--   
--   Cabin contains reports, or functions that take a list of postings and
--   return a formatted Text to display data in a human-readable format.
module Penny.Cabin

module Penny.Cabin.Balance.MultiCommodity.Parser

-- | Options for the Balance report that have been parsed from the command
--   line.
data ParseOpts
ParseOpts :: ShowZeroBalances -> SortOrder -> ParseOpts
showZeroBalances :: ParseOpts -> ShowZeroBalances
order :: ParseOpts -> SortOrder
allSpecs :: [OptSpec (ParseOpts -> ParseOpts)]


-- | The multi-commodity Balance report. This is the simpler balance report
--   because it does not allow for commodities to be converted.
module Penny.Cabin.Balance.MultiCommodity

-- | Options for making the balance report. These are the only options
--   needed to make the report if the options are not being parsed in from
--   the command line.
data Opts
Opts :: (Amount Qty -> Text) -> ShowZeroBalances -> (SubAccount -> SubAccount -> Ordering) -> Changers -> Opts
balanceFormat :: Opts -> Amount Qty -> Text
showZeroBalances :: Opts -> ShowZeroBalances
order :: Opts -> SubAccount -> SubAccount -> Ordering
textFormats :: Opts -> Changers
defaultOpts :: (Amount Qty -> Text) -> Opts
defaultParseOpts :: ParseOpts

-- | The MultiCommodity report with configurable options that have been
--   parsed from the command line.
parseReport :: ParseOpts -> Report

-- | The MultiCommodity report, with default options.
defaultReport :: Report

-- | This report is what to use if you already have your options (that is,
--   you are not parsing them in from the command line.)
report :: Opts -> [(a, Posting)] -> [Chunk]


-- | Parsing options for the Convert report from the command line.
module Penny.Cabin.Balance.Convert.Parser

-- | Default starting options for the Convert report. After considering
--   what is parsed in from the command line and price data, a Convert.Opts
--   will be generated.
data Opts
Opts :: ShowZeroBalances -> Target -> DateTime -> SortOrder -> SortBy -> Maybe RoundTo -> Opts
showZeroBalances :: Opts -> ShowZeroBalances
target :: Opts -> Target
dateTime :: Opts -> DateTime
sortOrder :: Opts -> SortOrder
sortBy :: Opts -> SortBy

-- | If the user wants a percentage report, set this.
percentRpt :: Opts -> Maybe RoundTo

-- | Is the target commodity determined by the user or automatically?
data Target
AutoTarget :: Target
ManualTarget :: To -> Target
data SortBy
SortByQty :: SortBy
SortByName :: SortBy

-- | Round to this many decimal places in the Percent report.
newtype RoundTo
RoundTo :: NonNegative -> RoundTo
unRoundTo :: RoundTo -> NonNegative

-- | Do not be tempted to change the setup in this module so that the
--   individual functions such as parseColor and parseBackground return
--   parsers rather than OptSpec. Such an arrangement breaks the correct
--   parsing of abbreviated long options.
allOptSpecs :: [OptSpec (Opts -> Opts)]
instance Eq RoundTo
instance Show RoundTo
instance Ord RoundTo
instance Eq SortBy
instance Show SortBy
instance Ord SortBy


-- | Default options for the Convert report when used from the command
--   line.
module Penny.Cabin.Balance.Convert.Options

-- | Default options for the Convert report. This record is used as the
--   starting point when parsing in options from the command line. You
--   don't need to use it if you are setting the options for the Convert
--   report directly from your own code.
data DefaultOpts
DefaultOpts :: ShowZeroBalances -> Target -> SortOrder -> SortBy -> DefaultOpts
showZeroBalances :: DefaultOpts -> ShowZeroBalances
target :: DefaultOpts -> Target
sortOrder :: DefaultOpts -> SortOrder
sortBy :: DefaultOpts -> SortBy
toParserOpts :: DefaultOpts -> Runtime -> Opts
defaultOptions :: DefaultOpts

module Penny.Cabin.Balance.Convert.ChunkerPct

-- | Displays a single account in a Balance report. In a single-commodity
--   report, this account will only be one screen line long. In a
--   multi-commodity report, it might be multiple lines long, with one
--   screen line for each commodity.
data MainRow
MainRow :: Int -> Text -> Maybe Percent -> MainRow

-- | Indent the account name by this many levels (not by this many spaces;
--   this number is multiplied by another number in the Chunker source to
--   arrive at the final indentation amount)
mrIndentation :: MainRow -> Int

-- | Text for the name of the account
mrText :: MainRow -> Text

-- | If Nothing, display dashes for the percent.
mrPercent :: MainRow -> Maybe Percent

-- | Displays a one-column row.
data OneColRow
OneColRow :: Int -> Text -> OneColRow

-- | Indent the text by this many levels (not by this many spaces; this
--   number is multiplied by another number in the Chunker source to arrive
--   at the final indentation amount)
ocIndentation :: OneColRow -> Int

-- | Text for the left column
ocText :: OneColRow -> Text
data Row
RMain :: MainRow -> Row
ROneCol :: OneColRow -> Row
data Percent
Percent :: DrCr -> Double -> Percent
pctDrCr :: Percent -> DrCr
pctAmount :: Percent -> Double
rowsToChunks :: Changers -> RoundTo -> [Row] -> [Chunk]
instance Show a => Show (Columns a)
instance Eq Percent
instance Show Percent
instance Applicative Columns
instance Functor Columns


-- | The Convert report. This report converts all account balances to a
--   single commodity, which must be specified.
module Penny.Cabin.Balance.Convert

-- | Options for the Convert report. These are the only options you need to
--   use if you are supplying options programatically (as opposed to
--   parsing them in from the command line.)
data Opts
Opts :: Either (Amount Qty -> Text) RoundTo -> ShowZeroBalances -> Sorter -> To -> DateTime -> Changers -> Opts

-- | If you want a convert report that shows a single commodity, pass a
--   Left showing how to display each amount. If you want a convert report
--   that shows percentages, pass a Right here with how many places to
--   round to.
format :: Opts -> Either (Amount Qty -> Text) RoundTo
showZeroBalances :: Opts -> ShowZeroBalances
sorter :: Opts -> Sorter
target :: Opts -> To
dateTime :: Opts -> DateTime
textFormats :: Opts -> Changers

-- | How to sort each line of the report. Each subaccount has only one
--   BottomLine (unlike in the MultiCommodity report, where each subaccount
--   may have more than one BottomLine, one for each commodity.)
type Sorter = (SubAccount, BottomLine) -> (SubAccount, BottomLine) -> Ordering

-- | The function for the Convert report. Use this function if you are
--   setting the options from a program (as opposed to parsing them in from
--   the command line.) Will fail if the balance conversions fail.
report :: Opts -> [PricePoint] -> [(a, Posting)] -> Either Text [Chunk]

-- | Creates a report respecting the standard interface for reports whose
--   options are parsed in from the command line.
cmdLineReport :: DefaultOpts -> Report

-- | Returns a function usable to sort pairs of SubAccount and BottomLine
--   depending on how you want them sorted.
getSorter :: SortOrder -> SortBy -> Sorter


-- | Penny balance reports. Currently there are two balance reports: the
--   MultiCommodity report, which cannot convert commodities and which
--   therefore might show more than one commodity in a single report, and
--   the Convert report, which uses price data in the Penny file to convert
--   all commodities to a single commodity. The Convert report always
--   displays only one commodity per account and this one commodity for the
--   whole report.
module Penny.Cabin.Balance

-- | The default multi-commodity balance report.
multiCommodity :: Report

-- | The default converting balance report.
convert :: Report


-- | Penny - extensible double-entry accounting system
module Penny

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version :: *
Version :: [Int] -> [String] -> Version

-- | The numeric branch for this version. This reflects the fact that most
--   software versions are tree-structured; there is a main trunk which is
--   tagged with versions at various points (1,2,3...), and the first
--   branch off the trunk after version 3 is 3.1, the second branch off the
--   trunk after version 3 is 3.2, and so on. The tree can be branched
--   arbitrarily, just by adding more digits.
--   
--   We represent the branch as a list of <a>Int</a>, so version 3.2.1
--   becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of
--   <a>Ord</a> for <tt>[Int]</tt>) gives the natural ordering of branches.
versionBranch :: Version -> [Int]

-- | A version can be tagged with an arbitrary list of strings. The
--   interpretation of the list of tags is entirely dependent on the entity
--   that this version applies to.
versionTags :: Version -> [String]

-- | This type contains settings for all the reports, as well as default
--   settings for the global options. Some of these can be overridden on
--   the command line.
data Defaults
Defaults :: Bool -> Matcher -> Bool -> ExprDesc -> Maybe Scheme -> [Scheme] -> [(SortField, SortOrder)] -> FormatQty -> Bool -> SortOrder -> Bool -> Target -> SortOrder -> SortBy -> Fields Bool -> Int -> Bool -> ((PostMeta, Posting) -> Text) -> Int -> Int -> Int -> Spacers Int -> Defaults

-- | Whether the matcher is case sensitive by default
caseSensitive :: Defaults -> Bool

-- | Which matcher to use
matcher :: Defaults -> Matcher

-- | Use colors when standard output is not a terminal?
colorToFile :: Defaults -> Bool

-- | Use RPN or infix expressions? This affects both the posting filter and
--   the filter for the Postings report.
expressionType :: Defaults -> ExprDesc

-- | Default color scheme. If Nothing, there is no default color scheme. If
--   there is no default color scheme and the user does not pick one on the
--   command line, no colors will be used.
defaultScheme :: Defaults -> Maybe Scheme

-- | Additional color schemes the user can pick from on the command line.
additionalSchemes :: Defaults -> [Scheme]

-- | Postings are sorted in this order by default. For example, if the
--   first pair is (Date, Ascending), then postings are first sorted by
--   date in ascending order. If the second pair is (Payee, Ascending),
--   then postings with the same date are then sorted by payee.
--   
--   If this list is empty, then by default postings are left in the same
--   order as they appear in the ledger files.
sorter :: Defaults -> [(SortField, SortOrder)]

-- | How to format quantities. This affects only quantities that are not
--   parsed from the ledger. Examples include calculated totals and
--   inferred quantities. Affects all reports.
formatQty :: Defaults -> FormatQty

-- | Show zero balances in the balance report? If True, show them; if
--   False, hide them.
balanceShowZeroBalances :: Defaults -> Bool

-- | Whether to sort the accounts in ascending or descending order by
--   account name in the balance report.
balanceOrder :: Defaults -> SortOrder

-- | Show zero balances in the convert report? If True, show them; if
--   False, hide them.
convertShowZeroBalances :: Defaults -> Bool

-- | The commodity to which to convert the commodities in the convert
--   report.
convertTarget :: Defaults -> Target

-- | Sort the convert report in ascending or descending order.
convertOrder :: Defaults -> SortOrder

-- | Sort by account or by quantity in the convert report.
convertSortBy :: Defaults -> SortBy

-- | Fields to show by default in the postings report.
postingsFields :: Defaults -> Fields Bool

-- | The postings report is roughly this wide by default. Typically this
--   will be as wide as your terminal.
postingsWidth :: Defaults -> Int

-- | Show zero balances in the postings report? If True, show them; if
--   False, hide them.
postingsShowZeroBalances :: Defaults -> Bool

-- | How to format dates in the postings report.
postingsDateFormat :: Defaults -> (PostMeta, Posting) -> Text

-- | Account names in the postings report are shortened if necessary in
--   order to help the report fit within the allotted width (see
--   postingsWidth). Account names are only shortened as much as is
--   necessary for them to fit; however, each sub-account name will not be
--   shortened any more than the amount given here.
postingsSubAccountLength :: Defaults -> Int

-- | postingsPayeeAllocation and postingsAccountAllocation determine how
--   much space is allotted to the payee and account fields in the postings
--   report. These fields are variable width. After space for most other
--   fields is allotted, space is allotted for these two fields. The two
--   fields divide the space proportionally depending on
--   postingsPayeeAllocation and postingsAccountAllocation. For example, if
--   postingsPayeeAllocation is 60 and postingsAccountAllocation is 40,
--   then the payee field gets 60 percent of the leftover space and the
--   account field gets 40 percent of the leftover space.
--   
--   Both postingsPayeeAllocation and postingsAccountAllocation must be
--   positive integers; if either one is less than 1, your program will
--   crash at runtime.
postingsPayeeAllocation :: Defaults -> Int

-- | See postingsPayeeAllocation above for an explanation
postingsAccountAllocation :: Defaults -> Int

-- | Determines the number of spaces that appears to the right of each
--   named field; for example, sPayee indicates how many spaces will appear
--   to the right of the payee field. Each field of the Spacers should be a
--   non-negative integer (although currently the absolute value of the
--   field is taken.)
postingsSpacers :: Defaults -> Spacers Int
data Matcher
Within :: Matcher
Exact :: Matcher
PCRE :: Matcher
data Scheme
Scheme :: String -> String -> Changers -> Scheme

-- | The name of this scheme. How it will be identified on the command
--   line.
name :: Scheme -> String

-- | A brief (one-line) description of what this scheme is, such as <tt>for
--   dark background terminals</tt>
description :: Scheme -> String
changers :: Scheme -> Changers
type Changers = Labels (EvenAndOdd (Chunk -> Chunk))
data Labels a
Labels :: a -> a -> a -> a -> Labels a
debit :: Labels a -> a
credit :: Labels a -> a
zero :: Labels a -> a
other :: Labels a -> a
data EvenAndOdd a
EvenAndOdd :: a -> a -> EvenAndOdd a
eoEven :: EvenAndOdd a -> a
eoOdd :: EvenAndOdd a -> a
data SortField
Payee :: SortField
Date :: SortField
Flag :: SortField
Number :: SortField
Account :: SortField
DrCr :: SortField
Qty :: SortField
Commodity :: SortField
PostingMemo :: SortField
TransactionMemo :: SortField
data SortOrder
Ascending :: SortOrder
Descending :: SortOrder

-- | Is this an infix or RPN expression?
data ExprDesc :: *
Infix :: ExprDesc
RPN :: ExprDesc

-- | The commodity to which to convert the commodities in the convert
--   report.
data Target

-- | Selects a target commodity automatically, based on which commodity is
--   the most common target commodity in the prices in your ledger files.
--   If there is a tie for most common target commodity, the target that
--   appears later in your ledger files is used.
AutoTarget :: Target

-- | Always uses the commodity named by the string given.
ManualTarget :: String -> Target
data SortBy
SortByQty :: SortBy
SortByName :: SortBy
data Fields a
Fields :: a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Fields a
fGlobalTransaction :: Fields a -> a
fRevGlobalTransaction :: Fields a -> a
fGlobalPosting :: Fields a -> a
fRevGlobalPosting :: Fields a -> a
fFileTransaction :: Fields a -> a
fRevFileTransaction :: Fields a -> a
fFilePosting :: Fields a -> a
fRevFilePosting :: Fields a -> a
fFiltered :: Fields a -> a
fRevFiltered :: Fields a -> a
fSorted :: Fields a -> a
fRevSorted :: Fields a -> a
fVisible :: Fields a -> a
fRevVisible :: Fields a -> a
fLineNum :: Fields a -> a
fDate :: Fields a -> a
fFlag :: Fields a -> a
fNumber :: Fields a -> a
fPayee :: Fields a -> a
fAccount :: Fields a -> a
fPostingDrCr :: Fields a -> a
fPostingCmdty :: Fields a -> a
fPostingQty :: Fields a -> a
fTotalDrCr :: Fields a -> a
fTotalCmdty :: Fields a -> a
fTotalQty :: Fields a -> a
fTags :: Fields a -> a
fMemo :: Fields a -> a
fFilename :: Fields a -> a
data Spacers a
Spacers :: a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Spacers a
sGlobalTransaction :: Spacers a -> a
sRevGlobalTransaction :: Spacers a -> a
sGlobalPosting :: Spacers a -> a
sRevGlobalPosting :: Spacers a -> a
sFileTransaction :: Spacers a -> a
sRevFileTransaction :: Spacers a -> a
sFilePosting :: Spacers a -> a
sRevFilePosting :: Spacers a -> a
sFiltered :: Spacers a -> a
sRevFiltered :: Spacers a -> a
sSorted :: Spacers a -> a
sRevSorted :: Spacers a -> a
sVisible :: Spacers a -> a
sRevVisible :: Spacers a -> a
sLineNum :: Spacers a -> a
sDate :: Spacers a -> a
sFlag :: Spacers a -> a
sNumber :: Spacers a -> a
sPayee :: Spacers a -> a
sAccount :: Spacers a -> a
sPostingDrCr :: Spacers a -> a
sPostingCmdty :: Spacers a -> a
sPostingQty :: Spacers a -> a
sTotalDrCr :: Spacers a -> a
sTotalCmdty :: Spacers a -> a

-- | Gets the current screen width from the runtime. If the COLUMNS
--   environment variable is not set, uses 80.
widthFromRuntime :: Runtime -> Int

-- | Shows the date of a posting in YYYY-MM-DD format.
yearMonthDay :: (PostMeta, Posting) -> Text
data S3 a b c :: * -> * -> * -> *
S3a :: a -> S3 a b c
S3b :: b -> S3 a b c
S3c :: c -> S3 a b c

-- | A function used to format quantities.
type FormatQty = [LedgerItem] -> Amount Qty -> Text

-- | Provides a function to use in the <a>formatQty</a> field. This formats
--   quantities that were not parsed in the ledger. It first consults a
--   list of all items that were parsed from the ledger. It examines these
--   items to determine if another item with the same commodity already
--   exists in the ledger.
--   
--   If other items with the same commodity exist in the ledger, the radix
--   point most frequently occurring amongst those items is used. If at
--   least one of these items (with this radix point) also has grouped
--   digits, then the quantity will be formatted with grouped digits;
--   otherwise, no digit grouping is performed. If digit grouping is
--   performed, it is done according to the following rules:
--   
--   <ul>
--   <li>only digits to the left of the radix point are grouped</li>
--   <li>grouping is performed only if the number has at least five digits.
--   Therefore, 1234 is not grouped, but 1,234.5 is grouped, as is
--   12,345</li>
--   <li>the character most frequently appearing as a grouping character
--   (for this particular commodity and radix point) is used to perform
--   grouping</li>
--   <li>digits are grouped into groups of 3 digits</li>
--   </ul>
--   
--   If a radix point cannot be determined from the quantities for a given
--   commodity, then the radix point appearing most frequently for all
--   commodities is used. If it's impossible to determine a radix point
--   from all commodities, then the given default radix point and digit
--   grouping (if desired) is used.
--   
--   This function builds a map internally which holds all the formatting
--   information; it might be expensive to build, so the function is
--   written to be partially applied.
qtyFormatter :: S3 Radix PeriodGrp CommaGrp -> FormatQty

-- | Obtains radix and grouping information for a particular commodity and
--   quantity, but does not actually perform the formatting.
getQtyFormat :: S3 Radix PeriodGrp CommaGrp -> [LedgerItem] -> Amount Qty -> S3 Radix PeriodGrp CommaGrp
data Radix
Period :: Radix
Comma :: Radix

-- | The digit grouping character when the radix is a period.
data PeriodGrp

-- | ASCII space
PGSpace :: PeriodGrp

-- | Unicode code point 0x2009
PGThinSpace :: PeriodGrp

-- | Comma
PGComma :: PeriodGrp

-- | The digit grouping character when the radix is a comma.
data CommaGrp

-- | ASCII space
CGSpace :: CommaGrp

-- | Unicode code point 0x2009
CGThinSpace :: CommaGrp

-- | Period
CGPeriod :: CommaGrp

-- | Information about the runtime environment.
data Runtime
environment :: Runtime -> [(String, String)]

-- | A space efficient, packed, unboxed Unicode text type.
data Text :: *

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>Text</a>. Subject to
--   fusion. Performs replacement on invalid scalar values.
pack :: String -> Text

-- | Creates an IO action that you can use for the main function.
runPenny :: Version -> (Runtime -> Defaults) -> IO ()
instance Show Target
instance Show a => Show (Spacers a)
instance Eq a => Eq (Spacers a)
instance Show a => Show (Fields a)
instance Eq a => Eq (Fields a)


-- | The selloff binary
module Penny.Denver.Selloff
main :: IO ()
instance Show Error
instance Show ProceedsAcct
instance Eq InputFilename
instance Show InputFilename
instance Show Group
instance Eq Group
instance Show SaleDate
instance Eq SaleDate
instance Show SelloffStock
instance Eq SelloffStock
instance Show SelloffCurrency
instance Eq SelloffCurrency
instance Show SelloffInfo
instance Show PurchaseDate
instance Eq PurchaseStockQty
instance Show PurchaseStockQty
instance Eq PurchaseCurrencyQty
instance Show PurchaseCurrencyQty
instance Show PurchaseInfo
instance Eq RealizedStockQty
instance Show RealizedStockQty
instance Eq RealizedCurrencyQty
instance Show RealizedCurrencyQty
instance Eq CostSharesSold
instance Show CostSharesSold
instance Eq StillToRealize
instance Show StillToRealize
instance Show BasisRealiztn
instance Show CapitalChange
instance Eq GainOrLoss
instance Show GainOrLoss
instance Show WithCapitalChanges
