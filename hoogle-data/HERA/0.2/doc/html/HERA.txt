-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package HERA
@version 0.2

module Data.Number.MPFR
type Dyadic = MPFR_T
type Precision = Word
data RoundMode
Near :: RoundMode
Zero :: RoundMode
Up :: RoundMode
Down :: RoundMode
add :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic
sub :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic
mul :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic
div :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic
inverse :: Dyadic -> Dyadic
add_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> (Dyadic, Int)
sub_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> (Dyadic, Int)
mul_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> (Dyadic, Int)
div_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> (Dyadic, Int)
addw :: RoundMode -> Precision -> Dyadic -> Word -> Dyadic
addi :: RoundMode -> Precision -> Dyadic -> Int -> Dyadic
mulw :: RoundMode -> Precision -> Dyadic -> Word -> Dyadic
muli :: RoundMode -> Precision -> Dyadic -> Int -> Dyadic
divw :: RoundMode -> Precision -> Dyadic -> Word -> Dyadic
divi :: RoundMode -> Precision -> Dyadic -> Int -> Dyadic
wdiv :: RoundMode -> Precision -> Word -> Dyadic -> Dyadic
idiv :: RoundMode -> Precision -> Int -> Dyadic -> Dyadic
subw :: RoundMode -> Precision -> Dyadic -> Word -> Dyadic
subi :: RoundMode -> Precision -> Dyadic -> Int -> Dyadic
wsub :: RoundMode -> Precision -> Word -> Dyadic -> Dyadic
isub :: RoundMode -> Precision -> Int -> Dyadic -> Dyadic
addw_ :: RoundMode -> Precision -> Dyadic -> Word -> (Dyadic, Int)
addi_ :: RoundMode -> Precision -> Dyadic -> Int -> (Dyadic, Int)
mulw_ :: RoundMode -> Precision -> Dyadic -> Word -> (Dyadic, Int)
muli_ :: RoundMode -> Precision -> Dyadic -> Int -> (Dyadic, Int)
divw_ :: RoundMode -> Precision -> Dyadic -> Word -> (Dyadic, Int)
divi_ :: RoundMode -> Precision -> Dyadic -> Int -> (Dyadic, Int)
wdiv_ :: RoundMode -> Precision -> Word -> Dyadic -> (Dyadic, Int)
idiv_ :: RoundMode -> Precision -> Int -> Dyadic -> (Dyadic, Int)
subw_ :: RoundMode -> Precision -> Dyadic -> Word -> (Dyadic, Int)
subi_ :: RoundMode -> Precision -> Dyadic -> Int -> (Dyadic, Int)
wsub_ :: RoundMode -> Precision -> Word -> Dyadic -> (Dyadic, Int)
isub_ :: RoundMode -> Precision -> Int -> Dyadic -> (Dyadic, Int)
mul2w :: RoundMode -> Precision -> Dyadic -> Word -> Dyadic
mul2i :: RoundMode -> Precision -> Dyadic -> Int -> Dyadic
div2w :: RoundMode -> Precision -> Dyadic -> Word -> Dyadic
div2i :: RoundMode -> Precision -> Dyadic -> Int -> Dyadic
mul2w_ :: RoundMode -> Precision -> Dyadic -> Word -> (Dyadic, Int)
mul2i_ :: RoundMode -> Precision -> Dyadic -> Int -> (Dyadic, Int)
div2w_ :: RoundMode -> Precision -> Dyadic -> Word -> (Dyadic, Int)
div2i_ :: RoundMode -> Precision -> Dyadic -> Int -> (Dyadic, Int)
int2i :: RoundMode -> Precision -> Int -> Int -> Dyadic
int2w :: RoundMode -> Precision -> Word -> Int -> Dyadic
int2i_ :: RoundMode -> Precision -> Int -> Int -> (Dyadic, Int)
int2w_ :: RoundMode -> Precision -> Word -> Int -> (Dyadic, Int)
fma :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic -> Dyadic
fms :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic -> Dyadic
fma_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic -> (Dyadic, Int)
fms_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic -> (Dyadic, Int)
nextBelow :: Dyadic -> Dyadic
sqr :: RoundMode -> Precision -> Dyadic -> Dyadic
sqrt :: RoundMode -> Precision -> Dyadic -> Dyadic
root :: RoundMode -> Precision -> Dyadic -> Word -> Dyadic
pow :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic
poww :: RoundMode -> Precision -> Dyadic -> Word -> Dyadic
powi :: RoundMode -> Precision -> Dyadic -> Int -> Dyadic
wpoww :: RoundMode -> Precision -> Word -> Word -> Dyadic
wpow :: RoundMode -> Precision -> Word -> Dyadic -> Dyadic
sqr_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
sqrt_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
root_ :: RoundMode -> Precision -> Dyadic -> Word -> (Dyadic, Int)
pow_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> (Dyadic, Int)
poww_ :: RoundMode -> Precision -> Dyadic -> Word -> (Dyadic, Int)
powi_ :: RoundMode -> Precision -> Dyadic -> Int -> (Dyadic, Int)
wpoww_ :: RoundMode -> Precision -> Word -> Word -> (Dyadic, Int)
wpow_ :: RoundMode -> Precision -> Word -> Dyadic -> (Dyadic, Int)
exp :: RoundMode -> Precision -> Dyadic -> Dyadic
exp2 :: RoundMode -> Precision -> Dyadic -> Dyadic
exp10 :: RoundMode -> Precision -> Dyadic -> Dyadic
log :: RoundMode -> Precision -> Dyadic -> Dyadic
log2 :: RoundMode -> Precision -> Dyadic -> Dyadic
log10 :: RoundMode -> Precision -> Dyadic -> Dyadic
sinh :: RoundMode -> Precision -> Dyadic -> Dyadic
cosh :: RoundMode -> Precision -> Dyadic -> Dyadic
tanh :: RoundMode -> Precision -> Dyadic -> Dyadic
exp_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
exp2_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
exp10_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
log_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
log2_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
log10_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
sinh_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
cosh_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
tanh_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
neg :: RoundMode -> Precision -> Dyadic -> Dyadic
absD :: RoundMode -> Precision -> Dyadic -> Dyadic
dim :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic
neg_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
absD_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
dim_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> (Dyadic, Int)
isNaN :: Dyadic -> Bool
isInfinite :: Dyadic -> Bool
isNumber :: Dyadic -> Bool
isZero :: Dyadic -> Bool
greater :: Dyadic -> Dyadic -> Bool
greatereq :: Dyadic -> Dyadic -> Bool
less :: Dyadic -> Dyadic -> Bool
lesseq :: Dyadic -> Dyadic -> Bool
equal :: Dyadic -> Dyadic -> Bool
maxD :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic
minD :: RoundMode -> Precision -> Dyadic -> Dyadic -> Dyadic
maxD_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> (Dyadic, Int)
minD_ :: RoundMode -> Precision -> Dyadic -> Dyadic -> (Dyadic, Int)
sgn :: Dyadic -> Int
dyadicToDouble :: RoundMode -> Dyadic -> Double
dyadicToWord :: RoundMode -> Dyadic -> Word
dyadicToInt :: RoundMode -> Dyadic -> Int
dyadicToString :: RoundMode -> Word -> Word -> Dyadic -> (String, Int)
decompose :: Dyadic -> (Integer, Int)
toStringExp :: Word -> Dyadic -> String
toString :: Word -> Dyadic -> String
pi :: RoundMode -> Precision -> Dyadic
log2c :: RoundMode -> Precision -> Dyadic
euler :: RoundMode -> Precision -> Dyadic
catalan :: RoundMode -> Precision -> Dyadic
pi_ :: RoundMode -> Precision -> (Dyadic, Int)
log2c_ :: RoundMode -> Precision -> (Dyadic, Int)
euler_ :: RoundMode -> Precision -> (Dyadic, Int)
catalan_ :: RoundMode -> Precision -> (Dyadic, Int)
set :: RoundMode -> Precision -> Dyadic -> Dyadic
set_ :: RoundMode -> Precision -> Dyadic -> (Dyadic, Int)
fromDouble :: RoundMode -> Precision -> Double -> Dyadic
fromInt :: RoundMode -> Precision -> Int -> Dyadic
fromWord :: RoundMode -> Precision -> Word -> Dyadic
fromDouble_ :: RoundMode -> Precision -> Double -> (Dyadic, Int)
fromInt_ :: RoundMode -> Precision -> Int -> (Dyadic, Int)
fromWord_ :: RoundMode -> Precision -> Word -> (Dyadic, Int)
fromIntegerA :: RoundMode -> Precision -> Integer -> Dyadic
compose :: RoundMode -> Precision -> (Integer, Int) -> Dyadic
fromString :: String -> Precision -> Word -> Dyadic
getPrec :: Dyadic -> Precision

-- | getMantissa and getExp return values such that
--   
--   <pre>
--   d = getMantissa d * 2^(getExp d - ceiling ((getPrec d) / bitsPerMPLimb)* bitsPerMPLimb )
--   </pre>
getMantissa :: Dyadic -> Integer
getExp :: Dyadic -> Int
minPrec :: Precision
one :: Dyadic
zero :: Dyadic
addPrec :: Dyadic -> Dyadic -> Precision
instance Num Dyadic
instance Show Dyadic
instance Ord Dyadic
instance Eq Dyadic

module Data.Order

-- | Partial ordering.
data POrdering
Less :: POrdering
Greater :: POrdering
Incomparable :: POrdering

-- | Partial booleans
data PBool

-- | equivalent to True
PTrue :: PBool

-- | equivalent to False
PFalse :: PBool

-- | neither True nor False.
Indeterminate :: PBool
instance Eq PBool
instance Show PBool
instance Ord PBool
instance Eq POrdering
instance Show POrdering
instance Ord POrdering

module Data.Number.Dyadic
pow2 :: Int -> Dyadic

module Data.Number.Ball

-- | Ball represents a closed interval <tt>[center-radius, center+radius]
--   </tt>
data Ball
Ball :: !Dyadic -> !Dyadic -> Ball

-- | center of the ball
center :: Ball -> !Dyadic

-- | radius of the ball
radius :: Ball -> !Dyadic

-- | Make a ball from endpoints
makeA :: Precision -> Dyadic -> Dyadic -> Ball

-- | Make a ball from endpoints so that no precision is lost.
make :: Dyadic -> Dyadic -> Ball

-- | Normalize the given ball's center to the specified precision.
--   Resulting ball might be larger.
normalizeBall :: Precision -> Ball -> Ball

-- | Lower endpoint of the ball rounded down to specified precision.
lower :: Precision -> Ball -> Dyadic

-- | Upper endpoint of the ball rounded up to specified precision.
upper :: Precision -> Ball -> Dyadic

-- | Lower endpoint with precision of the center
lower_ :: Ball -> Dyadic

-- | Upper endpoint with precision of the center
upper_ :: Ball -> Dyadic

-- | Sign of lower endpoint of the ball. This should be faster than using
--   <tt> signum (center b - radius b) </tt>
sgnLower :: Ball -> Int

-- | Analogous to sgnLower.
sgnUpper :: Ball -> Int

-- | Upper bound on the width of the ball. <tt> 2 * radius b </tt> rounded
--   up.
width :: Ball -> Dyadic

-- | Compare two balls.
--   
--   <ul>
--   <li>if upper a &lt; lower b then Less</li>
--   <li>if upper b &lt; lower a then Greater</li>
--   <li>otherwise balls are incomparable.</li>
--   </ul>
compareB :: Ball -> Ball -> POrdering

-- | Check if second ball is included in the first
below :: Ball -> Ball -> Bool

-- | Check if dyadic is element of the ball.
contains :: Ball -> Dyadic -> Bool

-- | Returns an intersection of two balls. If balls are disjoint then
--   computation fails with fail.
intersectA :: (Monad m) => Precision -> Ball -> Ball -> m Ball

-- | Intersection of two balls exactly (no precision is lost).
intersect :: (Monad m) => Ball -> Ball -> m Ball

-- | Addition of two balls.
--   
--   <ul>
--   <li><pre> center = center a + center b</pre></li>
--   <li><pre> radius = radius a + radius b</pre></li>
--   </ul>
--   
--   Rounding errors are added to the radius.
add :: Precision -> Ball -> Ball -> Ball

-- | Subtraction of two balls.
--   
--   <ul>
--   <li><pre> center = center a - center b</pre></li>
--   <li><pre> radius = radius a + radius b</pre></li>
--   </ul>
--   
--   Rounding errors are added to the radius.
sub :: Precision -> Ball -> Ball -> Ball

-- | Negation of the ball.
--   
--   <ul>
--   <li>center = - center b rounded to specified precision.</li>
--   <li>radius is only modified for the rounding error.</li>
--   </ul>
neg :: Precision -> Ball -> Ball
absB :: Precision -> Ball -> Ball

-- | Multiplication of two balls. (centers of both balls are assumed
--   positive)
--   
--   <ul>
--   <li>If none of the balls contains 0 then</li>
--   </ul>
--   
--   <pre>
--   center = center a * center b + radius a * radius b
--   </pre>
--   
--   <pre>
--   radius = center a * radius b + radius a * center b
--   </pre>
--   
--   <ul>
--   <li>If one of the operands (left) contains 0</li>
--   </ul>
--   
--   <pre>
--   center = center a * upper b
--   </pre>
--   
--   <pre>
--   radius = radius a * upper b
--   </pre>
--   
--   <ul>
--   <li>If both of the balls contain 0</li>
--   </ul>
--   
--   <pre>
--   lower =  min ((lower a) * (upper b)) ((lower b) * (upper a))
--   </pre>
--   
--   <pre>
--   upper =  max ((lower a) * (lower b)) ((upper b) * (upper a))
--   </pre>
--   
--   Rounding errors are added to the radius.
mul :: Precision -> Ball -> Ball -> Ball

-- | Division of two balls
--   
--   <ul>
--   <li>If radius is "large" then divide endpoints and makeA a ball from
--   them.</li>
--   <li>If radius is "small" then division can be optimized</li>
--   <li><pre> center = center a / center b</pre></li>
--   <li><tt> (radius = radius a * center b + center a * radius b) /
--   (center b * center b) + 2 * 2 ^ (e1 - e2 - p)</tt> where <tt> p </tt>
--   is precision of the result, <tt> e1 = getExp c1, e2 = getExp c2 </tt>.
--   This way the resulting interval is guaranteed to be correct.</li>
--   </ul>
--   
--   Rounding errors are added to the radius.
--   
--   If divisor ball contains zero compuatation fails with fail.
div :: (Monad m) => Precision -> Ball -> Ball -> m Ball

-- | Square root of a ball. If interval contains 0 then computation fails.
sqrt :: (Monad m) => Precision -> Ball -> m Ball

-- | <pre>
--   e ^ b
--   </pre>
exp :: Precision -> Ball -> Ball

-- | Natural logarithm of a ball. If interval contains 0 then computation
--   fails.
log :: (Monad m) => Precision -> Ball -> m Ball

-- | Maximum of two balls, meaning:
--   
--   <ul>
--   <li>lower = max (lower a) (lower b) rounded down</li>
--   <li>upper = max (upper a) (upper b) rounded up</li>
--   </ul>
maxB :: Precision -> Ball -> Ball -> Ball

-- | Analogous to maxB.
minB :: Precision -> Ball -> Ball -> Ball

-- | MakeA a ball from dyadic. Radius is 0 if desired precision is not
--   smaller than precision of dyadic.
fromDyadic :: Precision -> Dyadic -> Ball

-- | Similar to fromDyadic.
fromString :: Precision -> String -> Ball

-- | Similar to fromDyadic.
fromInt :: Precision -> Int -> Ball

-- | Similar to fromInt.
fromWord :: Precision -> Word -> Ball
instance Show Ball

module Data.Number.DyadicInterval

-- | A wrapper around Ball allowing the results of operations like division
--   by interval containing zero to be represented and do not cause errors.
--   
--   Nothing represents undefined interval.
type Interval = Maybe Ball

-- | Make an interval from a ball and normalize it to specified precision.
fromBallA :: Precision -> Ball -> Interval

-- | Just make an interval from a ball.
fromBall :: Ball -> Interval

-- | Make an interval from two endpoints so that no precision is lost.
make :: Dyadic -> Dyadic -> Interval

-- | Make an interval from two endpoints.
makeA :: Precision -> Dyadic -> Dyadic -> Interval

-- | Checks if second interval is inside the first. _|_ is above all.
below :: Interval -> Interval -> Bool

-- | Checks if interval contains dyadic. _|_ contains everything.
contains :: Interval -> Dyadic -> Bool

-- | Returns Below if second interval is inside first, Above if converse,
--   NoInclusion otherwise.
includes :: Interval -> Interval -> Inclusion

-- | Return the intersection of two intervals. The resulting interval's
--   center has specified precision.
--   
--   If one of the intervals is _|_ then just return the other (even if it
--   is _|_).
intersectA :: Precision -> Interval -> Interval -> Interval

-- | Return the intersection of two intervals so that no precision is lost.
intersect :: Interval -> Interval -> Interval

-- | Negate the interval. neg _|_ = _|_.
neg :: Precision -> Interval -> Interval

-- | Addition. If one of the arguments is _|_, so is the result.
add :: Precision -> Interval -> Interval -> Interval

-- | Multiplication. If one of the arguments is _|_, so is the result
mul :: Precision -> Interval -> Interval -> Interval

-- | Subtraction. If one of the arguments is _|_, so is the result
sub :: Precision -> Interval -> Interval -> Interval

-- | Division. If one of the arguments is _|_ or divisor contains 0 then
--   result is _|_.
div :: Precision -> Interval -> Interval -> Interval

-- | Square root. If one argument is _|_ or interval contains 0 then result
--   is _|_.
sqrt :: Precision -> Interval -> Interval

-- | <tt> e ^ i </tt> If argument is _|_ so is the result.
exp :: Precision -> Interval -> Interval

-- | Natural logarithm. If one argument is _|_ or interval contains 0 then
--   result is _|_.
log :: Precision -> Interval -> Interval

-- | Compare two intervals. If one of them is _|_ the result is
--   incomparable, otherwise result is comparison of balls.
compareI :: Interval -> Interval -> POrdering

-- | Maximum of intervals. If one interval is _|_ so is the result.
maxI :: Precision -> Interval -> Interval -> Interval

-- | Similar to maxI.
minI :: Precision -> Interval -> Interval -> Interval

-- | Center of interval. Center on _|_ will result in fail.
center :: (Monad m) => Interval -> m Dyadic

-- | Radius of interval. Radius on _|_ will result in fail.
radius :: (Monad m) => Interval -> m Dyadic

-- | Lower endpoint of interval with precision of the center. Lower on _|_
--   will result in fail.
lower :: (Monad m) => Interval -> m Dyadic

-- | Upper endpoint of interval with precision of the center. Upper on _|_
--   will result in fail.
upper :: (Monad m) => Interval -> m Dyadic

-- | Width of the interval. Widht on _|_ will result in fail.
width :: (Monad m) => Interval -> m Dyadic
fromDyadic :: Precision -> Dyadic -> Interval
fromString :: Precision -> String -> Interval
fromInt :: Precision -> Int -> Interval
fromWord :: Precision -> Word -> Interval
toString :: Interval -> String

module Data.Number.Real

-- | Real number is represented as a chain of dyadic intervals which are
--   neither necessarily nested nor bounded away from 0.
--   
--   On n-th stage computations are performed with precision of n bits.
data CReal
type Nat = Word
type Chain = Nat -> Interval

-- | Partial booleans
data PBool

-- | equivalent to True
PTrue :: PBool

-- | equivalent to False
PFalse :: PBool

-- | neither True nor False.
Indeterminate :: PBool
min :: CReal -> CReal -> CReal
max :: CReal -> CReal -> CReal

-- | A basic general limit which takes as arguments a sequence of reals and
--   a sequence of error bounds.
lim :: (Nat -> CReal) -> (Nat -> CReal) -> CReal

-- | Similar to lim, but can sometimes be more convenient for some
--   sequences
limRec :: CReal -> (CReal -> Nat -> (CReal, CReal)) -> CReal

-- | Limit of a sequence of rationals.
limRat :: (Nat -> Dyadic) -> (Nat -> Dyadic) -> CReal

-- | Computes an infinite sum of a series
infSum :: (Nat -> CReal) -> (Nat -> CReal) -> CReal

-- | Similar to infSum but can sometimes be more convenient Second argument
--   is a_0
infSumRec :: CReal -> (CReal -> Nat -> (CReal, CReal)) -> CReal

-- | <tt> approx x n </tt> tries to compute a dyadic approximation to x so
--   than <tt> |x - d| &lt;= 10^(-n) </tt> If it succeeds it returns <tt>
--   Right d </tt> where d is a dyadic rational, otherwise it returns Left
--   (d, n) where d is a dyadic rational and n is the number of accurate
--   decimal places
--   
--   Approx succeeds if result can be computed with precision less than the
--   square of the number of required bits of precision.
approx :: CReal -> Nat -> Either (Dyadic, Word) Dyadic

-- | <tt> pCompare x y </tt> returns a function <tt> Nat -&gt; POrdering
--   </tt> which when applied to some <tt> n </tt> computes approximates
--   with precision <tt> n </tt> and then compares the resulting intervals
pCompare :: CReal -> CReal -> Nat -> POrdering

-- | <tt> x &lt;. y </tt> is a function <tt> Nat -&gt; PBool </tt> which,
--   when applied to some <tt> n </tt>, computes the approximation with
--   precision <tt> n </tt> and then compares the intervals. If intervals
--   are disjoint then result is either PTrue or PFalse, otherwise result
--   is Indeterminate.
(<.) :: CReal -> CReal -> Nat -> PBool

-- | Similar to (&lt;.)
(>.) :: CReal -> CReal -> Nat -> PBool
sqrt :: CReal -> CReal
exp :: CReal -> CReal
log :: CReal -> CReal
fromDyadic :: Dyadic -> CReal

-- | fromInt should be preferred over fromIntegral where applicable
fromInt :: Int -> CReal

-- | fromWord should be preferred over fromIntegral where applicable
fromWord :: Word -> CReal
fromString :: String -> CReal

-- | toString computes the result with specified precision.
toString :: Nat -> CReal -> String

-- | toStringDec tries to compute the result to the number of specified
--   significand digits
toStringDec :: Nat -> CReal -> String
instance Fractional CReal
instance Num CReal
instance Read CReal
instance Show CReal
instance Eq CReal
