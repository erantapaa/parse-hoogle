-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Convert Cabal files into Nix build instructions
--   
--   The cabal2nix utility converts Cabal files into Nix build
--   instructions. The commandline syntax is:
--   
--   <pre>
--   Usage: cabal2nix [options] url-to-cabal-file
--     -h             --help                   show this help text
--                    --sha256=HASH            sha256 hash of source tarball
--     -m MAINTAINER  --maintainer=MAINTAINER  maintainer of this package (may be specified multiple times)
--     -p PLATFORM    --platform=PLATFORM      supported build platforms (may be specified multiple times)
--   
--   Recognized URI schemes:
--   
--     cabal://pkgname-pkgversion       download the specified package from Hackage
--     http://host/path                 fetch the Cabel file via HTTP
--     file:///local/path               load the Cabal file from the local disk
--     /local/path                      abbreviated version of file URI
--   </pre>
--   
--   The only required argument is the path to the cabal file. For example:
--   
--   <pre>
--   cabal2nix http://hackage.haskell.org/packages/archive/cabal2nix/1.9/cabal2nix.cabal
--   cabal2nix cabal://cabal2nix-1.9
--   </pre>
--   
--   If the <tt>--sha256</tt> option has not been specified, cabal2nix
--   calls <tt>nix-prefetch-url</tt> to determine the hash automatically.
--   This causes network traffic, obviously.
@package cabal2nix
@version 1.11

module Distribution.NixOS.Derivation.License
data License
GPL2 :: License
GPL3 :: License
LGPL21 :: License
LGPL3 :: License
BSD3 :: License
BSD4 :: License
MIT :: License
PublicDomain :: License
Proprietary :: License
Unknown :: (Maybe String) -> License
fromCabalLicense :: License -> License
instance Eq License
instance Ord License
instance Text License
instance Show License

module Distribution.NixOS.Derivation.Meta
data Meta
Meta :: String -> String -> License -> [String] -> [String] -> Meta
homepage :: Meta -> String
description :: Meta -> String
license :: Meta -> License
platforms :: Meta -> [String]
maintainers :: Meta -> [String]
instance Show Meta
instance Eq Meta
instance Ord Meta
instance Text Meta

module Distribution.NixOS.Derivation.Cabal
data Derivation
MkDerivation :: PackageName -> Version -> String -> Bool -> Bool -> [String] -> [String] -> [String] -> [String] -> Bool -> Meta -> Derivation
pname :: Derivation -> PackageName
version :: Derivation -> Version
sha256 :: Derivation -> String
isLibrary :: Derivation -> Bool
isExecutable :: Derivation -> Bool
buildDepends :: Derivation -> [String]
buildTools :: Derivation -> [String]
extraLibs :: Derivation -> [String]
pkgConfDeps :: Derivation -> [String]
runHaddock :: Derivation -> Bool
metaSection :: Derivation -> Meta
parseDerivation :: String -> Maybe Derivation

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version :: *
Version :: [Int] -> [String] -> Version

-- | The numeric branch for this version. This reflects the fact that most
--   software versions are tree-structured; there is a main trunk which is
--   tagged with versions at various points (1,2,3...), and the first
--   branch off the trunk after version 3 is 3.1, the second branch off the
--   trunk after version 3 is 3.2, and so on. The tree can be branched
--   arbitrarily, just by adding more digits.
--   
--   We represent the branch as a list of <a>Int</a>, so version 3.2.1
--   becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of
--   <a>Ord</a> for <tt>[Int]</tt>) gives the natural ordering of branches.
versionBranch :: Version -> [Int]

-- | A version can be tagged with an arbitrary list of strings. The
--   interpretation of the list of tags is entirely dependent on the entity
--   that this version applies to.
versionTags :: Version -> [String]
newtype PackageName :: *
PackageName :: String -> PackageName
instance Show Derivation
instance Eq Derivation
instance Ord Derivation
instance Text Derivation
