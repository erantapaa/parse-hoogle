-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Warm and fuzzy creation of XML documents.
--   
--   “It can scarcely be denied that the supreme goal of all theory is to
--   make the irreducible basic elements as simple and as few as possible
--   without having to surrender the adequate representation of a single
--   datum of experience.” ­— Albert Einstein
--   
--   Check out more examples in test/Main.hs and look at the results with
--   --enable-tests.
@package xml-conduit-writer
@version 0.1.1.1


-- | Overcome XML insanity, node by node.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   let doc = document "root" $ do
--       element "hello" $ content "world"
--       element "hierarchy" $ do
--           element "simple" True
--           element "as" ("it should be" :: Text)
--           toXML $ Just . T.pack $ "like this"
--       comment "that's it!"
--   </pre>
module Text.XML.Writer

-- | Create a simple Document starting with a root element.
document :: Name -> XML -> Document

-- | Generate a SOAPv1.1 document.
--   
--   Empty header will be ignored. Envelope uses a <tt>soapenv</tt> prefix.
--   Works great with <a>ToXML</a> class.
--   
--   <pre>
--   data BigData = BigData { webScale :: Bool }
--   instance ToXML BigData where
--       toXML (BigData ws) = element ("v" !: "{vendor:uri}bigData") $ toXML ws
--   let doc = soap () (BigData True)
--   </pre>
soap :: (ToXML h, ToXML b) => h -> b -> Document

-- | Render document using xml-conduit's pretty-printer.
pprint :: Document -> IO ()

-- | Node container to be rendered as children nodes.
type XML = Writer (DList Node) ()

-- | Insert one node.
node :: Node -> XML

-- | Insert an <a>Instruction</a> node.
instruction :: Text -> Text -> XML

-- | Insert a text comment node.
comment :: Text -> XML

-- | Insert an <a>Element</a> node constructed with name and children.
element :: ToXML a => Name -> a -> XML

-- | Insert an <a>Element</a> node converted from Maybe value or do
--   nothing.
elementMaybe :: ToXML a => Name -> Maybe a -> XML

-- | Insert an <a>Element</a> node constructed with name, attributes and
--   children.
elementA :: ToXML a => Name -> [(Name, Text)] -> a -> XML

-- | Insert text content node.
content :: Text -> XML

-- | Do nothing.
empty :: XML

-- | Mass-convert to nodes.
--   
--   <pre>
--   let array = element "container" $ many "wrapper" [1..3]
--   </pre>
--   
--   Which gives:
--   
--   <pre>
--   &lt;container&gt;
--       &lt;wrapper&gt;1&lt;/wrapper&gt;
--       &lt;wrapper&gt;2&lt;/wrapper&gt;
--       &lt;wrapper&gt;3&lt;/wrapper&gt;
--   &lt;/container&gt;
--   </pre>
--   
--   Use `mapM_ toXML xs` to convert a list without wrapping each item in
--   separate element.
--   
--   <pre>
--   let mess = element "container" $ mapM_ toXML ["chunky", "chunk"]
--   </pre>
--   
--   Content nodes tend to glue together:
--   
--   <pre>
--   &lt;container&gt;chunkychunk&lt;/container&gt;
--   </pre>
many :: ToXML a => Name -> [a] -> XML

-- | Convert collected nodes to a list of child nodes.
render :: XML -> [Node]

-- | Attach a prefix to a Name.
--   
--   Because simply placing a colon in an element name yields
--   <a>Nothing</a> as a prefix and children will revert to en empty
--   namespace.
(!:) :: Text -> Name -> Name

-- | Provide instances for this class to use your data as <a>XML</a> nodes.
class ToXML a
toXML :: ToXML a => a -> XML
instance IsString XML
instance ToXML a => ToXML (Maybe a)
instance ToXML Char
instance ToXML Integer
instance ToXML Int
instance ToXML Double
instance ToXML Float
instance ToXML Bool
instance ToXML Text
instance ToXML Text
instance ToXML XML
instance ToXML ()
