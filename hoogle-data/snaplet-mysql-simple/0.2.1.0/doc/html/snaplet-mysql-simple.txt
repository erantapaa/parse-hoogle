-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | mysql-simple snaplet for the Snap Framework
--   
@package snaplet-mysql-simple
@version 0.2.1.0


-- | This snaplet makes it simple to use a MariaDB or MySQL database from
--   your Snap application and is a literal translation of
--   snaplet-postgresql-simple by Doug Beardsley
--   (<a>https://github.com/mightybyte/snaplet-postgresql-simple</a>). It
--   uses the excellent mysql-simple library
--   (<a>http://hackage.haskell.org/package/mysql-simple</a>) by Bryan
--   O'Sullivan. Now, adding a database to your web app takes just two
--   simple steps.
--   
--   First, include this snaplet in your application's state.
--   
--   <pre>
--   data App = App
--       { ... -- Other state needed in your app
--       , _db :: Snaplet Mysql
--       }
--   </pre>
--   
--   Next, call the mysqlInit from your application's initializer.
--   
--   <pre>
--   appInit = makeSnaplet ... $ do
--       ...
--       d &lt;- nestSnaplet "db" db mysqlInit
--       return $ App ... d
--   </pre>
--   
--   Now you can use any of the mysql-simple wrapper functions defined in
--   this module anywhere in your application handlers. For instance:
--   
--   <pre>
--   postHandler :: Handler App App ()
--   postHandler = do
--       posts &lt;- with db $ query_ "select * from blog_post"
--       ...
--   </pre>
--   
--   Optionally, if you find yourself doing many database queries, you can
--   eliminate some of the boilerplate by defining a HasMysql instance for
--   your application.
--   
--   <pre>
--   instance HasMysql (Handler b App) where
--     getMysqlState = with db get
--   </pre>
--   
--   With this code, our postHandler example no longer requires the
--   <a>with</a> function:
--   
--   <pre>
--   postHandler :: Handler App App ()
--   postHandler = do
--       posts &lt;- query_ "select * from blog_post"
--       ...
--   </pre>
--   
--   The first time you run an application with the mysql-simple snaplet, a
--   configuration file <tt>devel.cfg</tt> is created in the
--   <tt>snaplets/mysql-simple</tt> directory underneath your project root.
--   It specifies how to connect to your MySQL or MariaDB server and what
--   user, password, and database to use. Edit this file and modify the
--   values appropriately and you'll be off and running.
--   
--   If you want to have out-of-the-box authentication, look at the
--   documentation for the <a>Snap.Snaplet.Auth.Backends.MysqlSimple</a>
--   module.
module Snap.Snaplet.MysqlSimple

-- | The state for the mysql-simple snaplet. To use it in your app include
--   this in your application state and use mysqlInit to initialize it.
data Mysql
Mysql :: Pool Connection -> Mysql

-- | Function for retrieving the connection pool
mysqlPool :: Mysql -> Pool Connection

-- | Instantiate this typeclass on 'Handler b YourAppState' so this snaplet
--   can find the connection source. If you need to have multiple instances
--   of the mysql snaplet in your application, then don't provide this
--   instance and leverage the default instance by using "<tt>with
--   dbLens</tt>" in front of calls to snaplet-mysql-simple functions.
class MonadCatchIO m => HasMysql m
getMysqlState :: HasMysql m => m Mysql

-- | Initialize the snaplet
mysqlInit :: SnapletInit b Mysql

-- | Initialize the snaplet
mysqlInit' :: Config -> SnapletInit b Mysql

-- | Produce a connection info from a config
getConnectionInfo :: MonadIO m => Config -> m ConnectInfo

-- | See <a>query</a>
query :: (HasMysql m, QueryParams q, QueryResults r) => Query -> q -> m [r]

-- | See <a>query_</a>
query_ :: (HasMysql m, QueryResults r) => Query -> m [r]
fold :: (HasMysql m, QueryResults row, QueryParams params, MonadCatchIO m) => Query -> params -> b -> (b -> row -> IO b) -> m b
fold_ :: (HasMysql m, QueryResults row, MonadCatchIO m) => Query -> b -> (b -> row -> IO b) -> m b
forEach :: (HasMysql m, QueryResults r, QueryParams q, MonadCatchIO m) => Query -> q -> (r -> IO ()) -> m ()
forEach_ :: (HasMysql m, QueryResults r, MonadCatchIO m) => Query -> (r -> IO ()) -> m ()
execute :: (HasMysql m, QueryParams q, MonadCatchIO m) => Query -> q -> m Int64
execute_ :: (HasMysql m, MonadCatchIO m) => Query -> m Int64
executeMany :: (HasMysql m, QueryParams q, MonadCatchIO m) => Query -> [q] -> m Int64
rollback :: (HasMysql m, MonadCatchIO m) => m ()
commit :: (HasMysql m, MonadCatchIO m) => m ()
formatMany :: (QueryParams q, HasMysql m, MonadCatchIO m) => Query -> [q] -> m ByteString
formatQuery :: (QueryParams q, HasMysql m, MonadCatchIO m) => Query -> q -> m ByteString

-- | A query string. This type is intended to make it difficult to
--   construct a SQL query by concatenating string fragments, as that is an
--   extremely common way to accidentally introduce SQL injection
--   vulnerabilities into an application.
--   
--   This type is an instance of <a>IsString</a>, so the easiest way to
--   construct a query is to enable the <tt>OverloadedStrings</tt> language
--   extension and then simply write the query in double quotes.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Database.MySQL.Simple
--   
--   q :: Query
--   q = "select ?"
--   </pre>
--   
--   The underlying type is a <a>ByteString</a>, and literal Haskell
--   strings that contain Unicode characters will be correctly transformed
--   to UTF-8.
data Query :: *

-- | Wrap a list of values for use in an <tt>IN</tt> clause. Replaces a
--   single "<tt>?</tt>" character with a parenthesized list of rendered
--   values.
--   
--   Example:
--   
--   <pre>
--   query c "select * from whatever where id in ?" (In [3,4,5])
--   </pre>
newtype In a :: * -> *
In :: a -> In a

-- | Wrap a mostly-binary string to be escaped in hexadecimal.
newtype Binary a :: * -> *
Binary :: a -> Binary a

-- | A single-value "collection".
--   
--   This is useful if you need to supply a single parameter to a SQL
--   query, or extract a single column from a SQL result.
--   
--   Parameter example:
--   
--   <pre>
--   query c "select x from scores where x &gt; ?" (<a>Only</a> (42::Int))
--   </pre>
--   
--   Result example:
--   
--   <pre>
--   xs &lt;- query_ c "select id from users"
--   forM_ xs $ \(<a>Only</a> id) -&gt; {- ... -}
--   </pre>
newtype Only a :: * -> *
Only :: a -> Only a
fromOnly :: Only a -> a

-- | Exception thrown if a <a>Query</a> could not be formatted correctly.
--   This may occur if the number of '<tt>?</tt>' characters in the query
--   string does not match the number of parameters provided.
data FormatError :: *

-- | Exception thrown if <a>query</a> is used to perform an
--   <tt>INSERT</tt>-like operation, or <a>execute</a> is used to perform a
--   <tt>SELECT</tt>-like operation.
data QueryError :: *

-- | Exception thrown if conversion from a SQL value to a Haskell value
--   fails.
data ResultError :: *
data MySQLError :: *

-- | A collection type that can be converted from a list of strings.
--   
--   Instances should use the <a>convert</a> method of the <a>Result</a>
--   class to perform conversion of each element of the collection.
--   
--   This example instance demonstrates how to convert a two-column row
--   into a Haskell pair. Each field in the metadata is paired up with each
--   value from the row, and the two are passed to <a>convert</a>.
--   
--   <pre>
--   instance (<a>Result</a> a, <a>Result</a> b) =&gt; <a>QueryResults</a> (a,b) where
--       <a>convertResults</a> [fa,fb] [va,vb] = (a,b)
--           where !a = <a>convert</a> fa va
--                 !b = <a>convert</a> fb vb
--       <a>convertResults</a> fs vs  = <a>convertError</a> fs vs 2
--   </pre>
--   
--   Notice that this instance evaluates each element to WHNF before
--   constructing the pair. By doing this, we guarantee two important
--   properties:
--   
--   <ul>
--   <li>Keep resource usage under control by preventing the construction
--   of potentially long-lived thunks.</li>
--   <li>Ensure that any <a>ResultError</a> that might arise is thrown
--   immediately, rather than some place later in application code that
--   cannot handle it.</li>
--   </ul>
--   
--   You can also declare Haskell types of your own to be instances of
--   <a>QueryResults</a>.
--   
--   <pre>
--   data User = User { firstName :: String, lastName :: String }
--   
--   instance <a>QueryResults</a> User where
--       <a>convertResults</a> [fa,fb] [va,vb] = User <a>$</a> a <a>*</a> b
--           where !a = <a>convert</a> fa va
--                 !b = <a>convert</a> fb vb
--       <a>convertResults</a> fs vs  = <a>convertError</a> fs vs 2
--    
--   </pre>
class QueryResults a
convertResults :: QueryResults a => [Field] -> [Maybe ByteString] -> a

-- | A collection type that can be turned into a list of rendering
--   <a>Action</a>s.
--   
--   Instances should use the <a>render</a> method of the <a>Param</a>
--   class to perform conversion of each element of the collection.
class QueryParams a
renderParams :: QueryParams a => a -> [Action]

-- | Default information for setting up a connection.
--   
--   Defaults are as follows:
--   
--   <ul>
--   <li>Server on <tt>localhost</tt></li>
--   <li>User <tt>root</tt></li>
--   <li>No password</li>
--   <li>Database <tt>test</tt></li>
--   <li>Character set <tt>utf8</tt></li>
--   </ul>
--   
--   Use as in the following example:
--   
--   <pre>
--   connect defaultConnectInfo { connectHost = "db.example.com" }
--   </pre>
defaultConnectInfo :: ConnectInfo
instance MonadCatchIO m => HasMysql (ReaderT Mysql m)
instance MonadCatchIO m => HasMysql (ReaderT (Snaplet Mysql) m)
instance HasMysql (Handler b Mysql)


-- | This module allows you to use the auth snaplet with your user database
--   stored in a MySQL database. When you run your application with this
--   snaplet, a config file will be copied into the the
--   <tt>snaplets/mysql-auth</tt> directory. This file contains all of the
--   configurable options for the snaplet and allows you to change them
--   without recompiling your application.
--   
--   To use this snaplet in your application enable the session, mysql, and
--   auth snaplets as follows:
--   
--   <pre>
--   data App = App
--       { ... -- your own application state here
--       , _sess :: Snaplet SessionManager
--       , _db   :: Snaplet Mysql
--       , _auth :: Snaplet (AuthManager App)
--       }
--   </pre>
--   
--   Then in your initializer you'll have something like this:
--   
--   <pre>
--   d &lt;- nestSnaplet "db" db mysqlInit
--   a &lt;- nestSnaplet "auth" auth $ initMysqlAuth sess d
--   </pre>
--   
--   If you have not already created the database table for users, it will
--   automatically be created for you the first time you run your
--   application.
module Snap.Snaplet.Auth.Backends.MysqlSimple

-- | Initializer for the mysql backend to the auth snaplet.
initMysqlAuth :: SnapletLens b SessionManager -> Snaplet Mysql -> SnapletInit b (AuthManager b)
instance IAuthBackend MysqlAuthManager
instance Param Password
instance QueryResults AuthUser
instance Result Password
instance Result UserId
