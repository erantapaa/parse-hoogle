-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Collection of numerical tools for integration, differentiation etc.
--   
--   Package provides function to perform numeric integration and
--   differentiation, function interpolation.
--   
--   Changes in 0.2.0.0
--   
--   <ul>
--   <li>Equation solvers now use custom return type.</li>
--   <li>Function to solve equations using Ridder and Newton methods.</li>
--   <li>New function to test approximate equality for doubles.</li>
--   <li>QuadRes contains best approximation achieved even if required
--   accuracy is not obtained</li>
--   <li>Improve convergence test when integral converges to zero.
--   Convergence is still poor</li>
--   </ul>
@package numeric-tools
@version 0.2.0.0


-- | Funtions for numerical integration. <a>quadRomberg</a> or
--   <a>quadSimpson</a> are reasonable choices in most cases. For
--   non-smooth function they converge poorly and <a>quadTrapezoid</a>
--   should be used then.
--   
--   For example this code intergrates exponent from 0 to 1:
--   
--   <pre>
--   &gt;&gt;&gt; let res = quadRomberg defQuad (0, 1) exp
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quadRes res     -- Integration result
--   Just 1.718281828459045
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quadPrecEst res -- Estimate of precision
--   2.5844957590474064e-16
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quadNIter res   -- Number of iterations performed
--   6
--   </pre>
module Numeric.Tools.Integration

-- | Integration parameters for numerical routines. Note that each
--   additional iteration doubles number of function evaluation required to
--   compute integral.
--   
--   Number of iterations is capped at 30.
data QuadParam
QuadParam :: Double -> Int -> QuadParam

-- | Relative precision of answer
quadPrecision :: QuadParam -> Double

-- | Maximum number of iterations
quadMaxIter :: QuadParam -> Int

-- | Default parameters for integration functions
--   
--   <ul>
--   <li>Maximum number of iterations = 20</li>
--   <li>Precision is 10⁻⁹</li>
--   </ul>
defQuad :: QuadParam

-- | Result of numeric integration.
data QuadRes
QuadRes :: Maybe Double -> Double -> Double -> Int -> QuadRes

-- | Integraion result
quadRes :: QuadRes -> Maybe Double

-- | Best estimate of integral
quadBestEst :: QuadRes -> Double

-- | Rough estimate of attained precision
quadPrecEst :: QuadRes -> Double

-- | Number of iterations
quadNIter :: QuadRes -> Int

-- | Integration of using trapezoids. This is robust algorithm and place
--   and useful for not very smooth. But it is very slow. It hundreds times
--   slower then <a>quadRomberg</a> if function is sufficiently smooth.
quadTrapezoid :: QuadParam -> (Double, Double) -> (Double -> Double) -> QuadRes

-- | Integration using Simpson rule. It should be more efficient than
--   <a>quadTrapezoid</a> if function being integrated have finite fourth
--   derivative.
quadSimpson :: QuadParam -> (Double, Double) -> (Double -> Double) -> QuadRes

-- | Integration using Romberg rule. For sufficiently smooth functions
--   (e.g. analytic) it's a fastest of three.
quadRomberg :: QuadParam -> (Double, Double) -> (Double -> Double) -> QuadRes
instance Typeable QuadParam
instance Typeable QuadRes
instance Show QuadParam
instance Eq QuadParam
instance Data QuadParam
instance Show QuadRes
instance Eq QuadRes
instance Data QuadRes


-- | Numerical differentiation. <a>diffRichardson</a> is preferred way to
--   calculate derivative.
module Numeric.Tools.Differentiation

-- | Differentiation result
data DiffRes
DiffRes :: Double -> Double -> DiffRes

-- | Derivative value
diffRes :: DiffRes -> Double

-- | Rough error estimate
diffPrecision :: DiffRes -> Double

-- | Calculate derivative using Richaradson's deferred approach to limit.
--   This is a preferred method for numeric differentiation since it's most
--   precise. Function could be evaluated up to 20 times.
--   
--   Initial step size should be chosen fairly big. Too small one will
--   result reduced precision, too big one in nonsensical answer.
diffRichardson :: (Double -> Double) -> Double -> Double -> DiffRes

-- | Simplest form of differentiation. Should be used only when function
--   evaluation is prohibitively expensive and already computed value at
--   point <tt>x</tt> should be reused.
--   
--   <pre>
--   f'(x) = f(x+h) - f(x) / h
--   </pre>
diffSimple :: (Double -> Double) -> Double -> (Double, Double) -> Double

-- | Simple differentiation. It uses simmetric rule and provide reasonable
--   accuracy. It's suitable when function evaluation is expensive and
--   precision could be traded for speed.
--   
--   <pre>
--   f'(x) = f(x-h) + f(x+h) / 2h
--   </pre>
diffSimmetric :: (Double -> Double) -> Double -> Double -> Double

-- | For number <tt>x</tt> and small <tt>h</tt> return such <tt>h'</tt>
--   that <tt>x+h'</tt> and <tt>x</tt> differ by representable number
representableDelta :: Double -> Double -> Double
instance Typeable DiffRes
instance Show DiffRes
instance Eq DiffRes
instance Data DiffRes


module Numeric.Classes.Indexing

-- | Type class for array-like data type which support <tt>O(1)</tt> access
--   by integer index starting from zero.
class Indexable a where { type family IndexVal a :: *; { x ! i | i < 0 || i > size x = error "Numeric.Classes.Indexing.!: index is out of range" | otherwise = unsafeIndex x i } }
size :: Indexable a => a -> Int
unsafeIndex :: Indexable a => a -> Int -> IndexVal a
(!) :: Indexable a => a -> Int -> IndexVal a

-- | Check that index is valid
validIndex :: Indexable a => a -> Int -> Bool
instance Storable a => Indexable (Vector a)
instance Unbox a => Indexable (Vector a)
instance Indexable (Vector a)


-- | 1-dimensional meshes. Used by <tt>Numeric.Tools.Interpolation</tt>.
module Numeric.Tools.Mesh

-- | Class for 1-dimensional meshes. Mesh is ordered set of points. Each
--   instance must guarantee that every next point is greater that previous
--   and there is at least 2 points in mesh.
class Indexable a => Mesh a
meshLowerBound :: Mesh a => a -> Double
meshUpperBound :: Mesh a => a -> Double
meshFindIndex :: Mesh a => a -> Double -> Int

-- | Uniform mesh
data UniformMesh

-- | Create uniform mesh
uniformMesh :: (Double, Double) -> Int -> UniformMesh

-- | Distance between points
uniformMeshStep :: UniformMesh -> Double
instance Typeable UniformMesh
instance Eq UniformMesh
instance Show UniformMesh
instance Data UniformMesh
instance Mesh UniformMesh
instance Indexable UniformMesh


-- | Different implementations of approximate equality for floating point
--   values. There are multiple ways to implement approximate equality.
--   They have different semantics and it's up to programmer to choose
--   right one.
module Numeric.ApproxEq

-- | Relative difference between two numbers are less than predefined
--   value. For example 1 is approximately equal to 1.0001 with 1e-4
--   precision. Same is true for 10000 and 10001.
--   
--   This method of camparison doesn't work for numbers which are
--   approximately 0. <a>eqAbsolute</a> should be used instead.
eqRelative :: (Fractional a, Ord a) => a -> a -> a -> Bool

-- | Relative equality for comlex numbers.
eqRelCompl :: (RealFloat a, Ord a) => a -> Complex a -> Complex a -> Bool

-- | Difference between values is less than specified precision.
eqAbsolute :: (Num a, Ord a) => a -> a -> a -> Bool

-- | Compare two <a>Double</a> values for approximate equality, using
--   Dawson's method.
--   
--   The required accuracy is specified in ULPs (units of least precision).
--   If the two numbers differ by the given number of ULPs or less, this
--   function returns <tt>True</tt>.
--   
--   Algorithm is based on Bruce Dawson's "Comparing floating point
--   numbers":
--   <a>http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm</a>
within :: Int -> Double -> Double -> Bool


-- | Numerical solution of ordinary equations.
module Numeric.Tools.Equation

-- | The result of searching for a root of a mathematical function.
data Root a

-- | The function does not have opposite signs when evaluated at the lower
--   and upper bounds of the search.
NotBracketed :: Root a

-- | The search failed to converge to within the given error tolerance
--   after the given number of iterations.
SearchFailed :: Root a

-- | A root was successfully found.
Root :: a -> Root a

-- | Returns either the result of a search for a root, or the default value
--   if the search failed.
fromRoot :: a -> Root a -> a

-- | Use bisection method to compute root of function.
--   
--   The function must have opposite signs when evaluated at the lower and
--   upper bounds of the search (i.e. the root must be bracketed).
solveBisection :: Double -> (Double, Double) -> (Double -> Double) -> Root Double

-- | Use the method of Ridders to compute a root of a function.
--   
--   The function must have opposite signs when evaluated at the lower and
--   upper bounds of the search (i.e. the root must be bracketed).
solveRidders :: Double -> (Double, Double) -> (Double -> Double) -> Root Double

-- | Solve equation using Newton-Raphson method. Root must be bracketed. If
--   Newton's step jumps outside of bracket or do not converge sufficiently
--   fast function reverts to bisection.
solveNewton :: Double -> (Double, Double) -> (Double -> Double) -> (Double -> Double) -> Root Double
instance Typeable1 Root
instance Eq a => Eq (Root a)
instance Read a => Read (Root a)
instance Show a => Show (Root a)
instance Alternative Root
instance Applicative Root
instance MonadPlus Root
instance Monad Root
instance Functor Root


-- | Function useful for writing numeric code which works with mutable
--   data.
module Control.Monad.Numeric

-- | For function which act much like for loop in the C
forGen :: Monad m => a -> (a -> Bool) -> (a -> a) -> (a -> m ()) -> m ()

-- | Specialized for loop. Akin to:
--   
--   <pre>
--   for( i = 0; i &lt; 10; i++) { ...
--   </pre>
for :: Monad m => Int -> Int -> (Int -> m ()) -> m ()


-- | Function interpolation.
--   
--   Sine interpolation using cubic splines:
--   
--   <pre>
--   &gt;&gt;&gt; let tbl = cubicSpline $ tabulateFun (uniformMesh (0,10) 100) sin
--   
--   &gt;&gt;&gt; tbl `at` 1.786
--   0.9769239849844867
--   </pre>
module Numeric.Tools.Interpolation

-- | Interpolation for arbitraty meshes
class Interpolation a
at :: (Interpolation a, (IndexVal m) ~ Double, Mesh m) => a m -> Double -> Double
tabulateFun :: (Interpolation a, (IndexVal m) ~ Double, Mesh m) => m -> (Double -> Double) -> a m
unsafeTabulate :: (Interpolation a, (IndexVal m) ~ Double, Mesh m, Vector v Double) => m -> v Double -> a m
interpolationMesh :: Interpolation a => a m -> m
interpolationTable :: Interpolation a => a m -> Vector Double

-- | Use table of already evaluated function and mesh. Sizes of mesh and
--   table must coincide.
tabulate :: (Interpolation a, (IndexVal m) ~ Double, Mesh m, Vector v Double) => m -> v Double -> a m

-- | Data for linear interpolation
data LinearInterp a

-- | Function used to fix types
linearInterp :: LinearInterp a -> LinearInterp a

-- | Natural cubic splines
data CubicSpline a

-- | Function used to fix types
cubicSpline :: CubicSpline a -> CubicSpline a
instance Typeable1 LinearInterp
instance Typeable1 CubicSpline
instance Show a => Show (LinearInterp a)
instance Eq a => Eq (LinearInterp a)
instance Data a => Data (LinearInterp a)
instance Eq a => Eq (CubicSpline a)
instance Show a => Show (CubicSpline a)
instance Data a => Data (CubicSpline a)
instance Interpolation CubicSpline
instance Interpolation LinearInterp
instance Mesh a => Indexable (LinearInterp a)
