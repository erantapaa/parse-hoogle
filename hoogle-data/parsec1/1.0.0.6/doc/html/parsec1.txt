-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Portable monadic parser combinators
--   
@package parsec1
@version 1.0.0.6


-- | Textual source positions.
module Text.ParserCombinators.Parsec.Pos
type SourceName = String
type Line = Int
type Column = Int

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName

-- | Increments the line number of a source position.
incSourceLine :: SourcePos -> Line -> SourcePos

-- | Increments the column number of a source position.
incSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the line number of a source position.
setSourceLine :: SourcePos -> Line -> SourcePos

-- | Set the column number of a source position.
setSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the name of the source.
setSourceName :: SourcePos -> SourceName -> SourcePos

-- | Create a new <a>SourcePos</a> with the given source name, line number
--   and column number.
newPos :: SourceName -> Line -> Column -> SourcePos

-- | Create a new <a>SourcePos</a> with the given source name, and line
--   number and column number set to 1, the upper left.
initialPos :: SourceName -> SourcePos
updatePosChar :: SourcePos -> Char -> SourcePos

-- | The expression <tt>updatePosString pos s</tt> updates the source
--   position <tt>pos</tt> by calling <a>updatePosChar</a> on every
--   character in <tt>s</tt>, ie. <tt>foldl updatePosChar pos string</tt>.
updatePosString :: SourcePos -> String -> SourcePos
instance Eq SourcePos
instance Ord SourcePos
instance Show SourcePos


-- | Parse errors
module Text.ParserCombinators.Parsec.Error

-- | This abstract data type represents parse error messages. There are
--   four kinds of messages:
--   
--   <pre>
--   data Message = SysUnExpect String
--                | UnExpect String
--                | Expect String
--                | Message String
--   </pre>
--   
--   The fine distinction between different kinds of parse errors allows
--   the system to generate quite good error messages for the user. It also
--   allows error messages that are formatted in different languages. Each
--   kind of message is generated by different combinators:
--   
--   <ul>
--   <li>A <a>SysUnExpect</a> message is automatically generated by the
--   <a>satisfy</a> combinator. The argument is the unexpected
--   input.<ul><li>A <a>UnExpect</a> message is generated by the
--   <a>unexpected</a> combinator. The argument describes the unexpected
--   item.</li><li>A <a>Expect</a> message is generated by the
--   <a>&lt;?&gt;</a> combinator. The argument describes the expected
--   item.</li><li>A <a>Message</a> message is generated by the <a>fail</a>
--   combinator. The argument is some general parser
--   message.</li></ul></li>
--   </ul>
data Message
SysUnExpect :: !String -> Message
UnExpect :: !String -> Message
Expect :: !String -> Message
Message :: !String -> Message

-- | Extract the message string from an error message
messageString :: Message -> String
messageCompare :: Message -> Message -> Ordering
messageEq :: Message -> Message -> Bool

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <a>parse</a>. <tt>ParseError</tt> is an
--   instance of the <a>Show</a> class.
data ParseError

-- | Extracts the source position from the parse error
errorPos :: ParseError -> SourcePos

-- | Extracts the list of error messages from the parse error
errorMessages :: ParseError -> [Message]
errorIsUnknown :: ParseError -> Bool

-- | Language independent show function
showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
newErrorMessage :: Message -> SourcePos -> ParseError
newErrorUnknown :: SourcePos -> ParseError
addErrorMessage :: Message -> ParseError -> ParseError
setErrorPos :: SourcePos -> ParseError -> ParseError
setErrorMessage :: Message -> ParseError -> ParseError
mergeError :: ParseError -> ParseError -> ParseError
instance Show ParseError


-- | The primitive parser combinators.
module Text.ParserCombinators.Parsec.Prim

-- | The parser <tt>p <a>?</a> msg</tt> behaves as parser <tt>p</tt>, but
--   whenever the parser <tt>p</tt> fails <i>without consuming any
--   input</i>, it replaces expect error messages with the expect error
--   message <tt>msg</tt>.
--   
--   This is normally used at the end of a set alternatives where we want
--   to return an error message in terms of a higher level construct rather
--   than returning all possible characters. For example, if the
--   <tt>expr</tt> parser from the <a>try</a> example would fail, the error
--   message is: '...: expecting expression'. Without the
--   <tt>(&lt;?&gt;)</tt> combinator, the message would be like '...:
--   expecting "let" or letter', which is less friendly.
(<?>) :: GenParser tok st a -> String -> GenParser tok st a

-- | An associative binary operation
(<|>) :: Alternative f => forall a. f a -> f a -> f a
type Parser a = GenParser Char () a
data GenParser tok st a

-- | The most general way to run a parser. <tt>runParser p state filePath
--   input</tt> runs parser <tt>p</tt> on the input list of tokens
--   <tt>input</tt>, obtained from source <tt>filePath</tt> with the
--   initial user state <tt>st</tt>. The <tt>filePath</tt> is only used in
--   error messages and may be the empty string. Returns either a
--   <a>ParseError</a> (<a>Left</a>) or a value of type <tt>a</tt>
--   (<a>Right</a>).
--   
--   <pre>
--   parseFromFile p fname
--     = do{ input &lt;- readFile fname
--         ; return (runParser p () fname input)
--         }
--   </pre>
runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a

-- | <tt>parse p filePath input</tt> runs a parser <tt>p</tt> without user
--   state. The <tt>filePath</tt> is only used in error messages and may be
--   the empty string. Returns either a <a>ParseError</a> (<a>Left</a>) or
--   a value of type <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   main    = case (parse numbers "" "11, 2, 43") of
--              Left err  -&gt; print err
--              Right xs  -&gt; print (sum xs)
--   
--   numbers = commaSep integer
--   </pre>
parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)

-- | The expression <tt>parseTest p input</tt> applies a parser <tt>p</tt>
--   against input <tt>input</tt> and prints the result to stdout. Used for
--   testing parsers.
parseTest :: Show a => GenParser tok () a -> [tok] -> IO ()

-- | The parser <tt>token showTok posFromTok testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The source position of the <tt>t</tt>
--   should be returned by <tt>posFromTok t</tt> and the token can be shown
--   using <tt>showTok t</tt>.
--   
--   This combinator is expressed in terms of <a>tokenPrim</a>. It is used
--   to accept user defined token streams. For example, suppose that we
--   have a stream of basic tokens tupled with source positions. We can
--   than define a parser that accepts single tokens as:
--   
--   <pre>
--   mytoken x
--     = token showTok posFromTok testTok
--     where
--       showTok (pos,t)     = show t
--       posFromTok (pos,t)  = pos
--       testTok (pos,t)     = if x == t then Just t else Nothing
--   </pre>
token :: (tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a
tokens :: Eq tok => ([tok] -> String) -> (SourcePos -> [tok] -> SourcePos) -> [tok] -> GenParser tok st [tok]

-- | The parser <tt>token showTok nextPos testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The token can be shown using
--   <tt>showTok t</tt>. The position of the <i>next</i> token should be
--   returned when <tt>nextPos</tt> is called with the current source
--   position <tt>pos</tt>, the current token <tt>t</tt> and the rest of
--   the tokens <tt>toks</tt>, <tt>nextPos pos t toks</tt>.
--   
--   This is the most primitive combinator for accepting tokens. For
--   example, the <a>char</a> parser could be implemented as:
--   
--   <pre>
--   char c
--     = tokenPrim showChar nextPos testChar
--     where
--       showChar x        = "'" ++ x ++ "'"
--       testChar x        = if x == c then Just x else Nothing
--       nextPos pos x xs  = updatePosChar pos x
--   </pre>
tokenPrim :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a

-- | The most primitive token recogniser. The expression <tt>tokenPrimEx
--   show nextpos mbnextstate test</tt>, recognises tokens when
--   <tt>test</tt> returns <tt>Just x</tt> (and returns the value
--   <tt>x</tt>). Tokens are shown in error messages using <tt>show</tt>.
--   The position is calculated using <tt>nextpos</tt>, and finally,
--   <tt>mbnextstate</tt>, can hold a function that updates the user state
--   on every token recognised (nice to count tokens :-). The function is
--   packed into a <a>Maybe</a> type for performance reasons.
tokenPrimEx :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> Maybe (SourcePos -> tok -> [tok] -> st -> st) -> (tok -> Maybe a) -> GenParser tok st a

-- | The parser <tt>try p</tt> behaves like parser <tt>p</tt>, except that
--   it pretends that it hasn't consumed any input when an error occurs.
--   
--   This combinator is used whenever arbitrary look ahead is needed. Since
--   it pretends that it hasn't consumed any input when <tt>p</tt> fails,
--   the (<a>&lt;|&gt;</a>) combinator will try its second alternative even
--   when the first parser failed while consuming input.
--   
--   The <tt>try</tt> combinator can for example be used to distinguish
--   identifiers and reserved words. Both reserved words and identifiers
--   are a sequence of letters. Whenever we expect a certain reserved word
--   where we can also expect an identifier we have to use the <tt>try</tt>
--   combinator. Suppose we write:
--   
--   <pre>
--   expr        = letExpr &lt;|&gt; identifier &lt;?&gt; "expression"
--   
--   letExpr     = do{ string "let"; ... }
--   identifier  = many1 letter
--   </pre>
--   
--   If the user writes "lexical", the parser fails with: <tt>unexpected
--   'x', expecting 't' in "let"</tt>. Indeed, since the (<a>&lt;|&gt;</a>)
--   combinator only tries alternatives when the first alternative hasn't
--   consumed input, the <tt>identifier</tt> parser is never tried (because
--   the prefix "le" of the <tt>string "let"</tt> parser is already
--   consumed). The right behaviour can be obtained by adding the
--   <tt>try</tt> combinator:
--   
--   <pre>
--   expr        = letExpr &lt;|&gt; identifier &lt;?&gt; "expression"
--   
--   letExpr     = do{ try (string "let"); ... }
--   identifier  = many1 letter
--   </pre>
try :: GenParser tok st a -> GenParser tok st a
label :: GenParser tok st a -> String -> GenParser tok st a
labels :: GenParser tok st a -> [String] -> GenParser tok st a

-- | <tt>lookAhead p</tt> parses <tt>p</tt> without consuming any input.
lookAhead :: GenParser tok st a -> GenParser tok st a

-- | The parser <tt>unexpected msg</tt> always fails with an unexpected
--   error message <tt>msg</tt> without consuming any input.
--   
--   The parsers <a>fail</a>, (<a>&lt;?&gt;</a>) and <tt>unexpected</tt>
--   are the three parsers used to generate error messages. Of these, only
--   (<a>&lt;?&gt;</a>) is commonly used. For an example of the use of
--   <tt>unexpected</tt>, see the definition of <a>notFollowedBy</a>.
unexpected :: String -> GenParser tok st a
pzero :: GenParser tok st a

-- | Zero or more.
many :: Alternative f => forall a. f a -> f [a]

-- | <tt>skipMany p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times, skipping its result.
--   
--   <pre>
--   spaces  = skipMany space
--   </pre>
skipMany :: GenParser tok st a -> GenParser tok st ()

-- | Returns the current user state.
getState :: GenParser tok st st

-- | <tt>setState st</tt> set the user state to <tt>st</tt>.
setState :: st -> GenParser tok st ()

-- | <tt>updateState f</tt> applies function <tt>f</tt> to the user state.
--   Suppose that we want to count identifiers in a source, we could use
--   the user state as:
--   
--   <pre>
--   expr  = do{ x &lt;- identifier
--             ; updateState (+1)
--             ; return (Id x)
--             }
--   </pre>
updateState :: (st -> st) -> GenParser tok st ()

-- | Returns the current source position. See also <a>SourcePos</a>.
getPosition :: GenParser tok st SourcePos

-- | <tt>setPosition pos</tt> sets the current source position to
--   <tt>pos</tt>.
setPosition :: SourcePos -> GenParser tok st ()

-- | Returns the current input
getInput :: GenParser tok st [tok]

-- | <tt>setInput input</tt> continues parsing with <tt>input</tt>.
setInput :: [tok] -> GenParser tok st ()
data State tok st
State :: [tok] -> !SourcePos -> !st -> State tok st
stateInput :: State tok st -> [tok]
statePos :: State tok st -> !SourcePos
stateUser :: State tok st -> !st

-- | Returns the full parser state as a <a>State</a> record.
getParserState :: GenParser tok st (State tok st)

-- | <tt>setParserState st</tt> set the full parser state to <tt>st</tt>.
setParserState :: State tok st -> GenParser tok st (State tok st)
instance Alternative (GenParser tok st)
instance MonadPlus (GenParser tok st)
instance Applicative (GenParser tok st)
instance Monad (GenParser tok st)
instance Functor (GenParser tok st)


-- | Commonly used character parsers.
module Text.ParserCombinators.Parsec.Char
type CharParser st a = GenParser Char st a

-- | Skips <i>zero</i> or more white space characters. See also
--   <a>skipMany</a>.
spaces :: CharParser st ()

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: CharParser st Char

-- | Parses a newline character ('\n'). Returns a newline character.
newline :: CharParser st Char

-- | Parses a tab character ('\t'). Returns a tab character.
tab :: CharParser st Char

-- | Parses an upper case letter (a character between 'A' and 'Z'). Returns
--   the parsed character.
upper :: CharParser st Char

-- | Parses a lower case character (a character between 'a' and 'z').
--   Returns the parsed character.
lower :: CharParser st Char

-- | Parses a letter or digit (a character between '0' and '9'). Returns
--   the parsed character.
alphaNum :: CharParser st Char

-- | Parses a letter (an upper case or lower case character). Returns the
--   parsed character.
letter :: CharParser st Char

-- | Parses a digit. Returns the parsed character.
digit :: CharParser st Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: CharParser st Char

-- | Parses an octal digit (a character between '0' and '7'). Returns the
--   parsed character.
octDigit :: CharParser st Char

-- | <tt>char c</tt> parses a single character <tt>c</tt>. Returns the
--   parsed character (i.e. <tt>c</tt>).
--   
--   <pre>
--   semiColon  = char ';'
--   </pre>
char :: Char -> CharParser st Char

-- | <tt>string s</tt> parses a sequence of characters given by <tt>s</tt>.
--   Returns the parsed string (i.e. <tt>s</tt>).
--   
--   <pre>
--   divOrMod    =   string "div"
--               &lt;|&gt; string "mod"
--   </pre>
string :: String -> CharParser st String

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: CharParser st Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character. See also
--   <a>satisfy</a>.
--   
--   <pre>
--   vowel  = oneOf "aeiou"
--   </pre>
oneOf :: [Char] -> CharParser st Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
--   
--   <pre>
--   consonant = noneOf "aeiou"
--   </pre>
noneOf :: [Char] -> CharParser st Char

-- | The parser <tt>satisfy f</tt> succeeds for any character for which the
--   supplied function <tt>f</tt> returns <a>True</a>. Returns the
--   character that is actually parsed.
--   
--   <pre>
--   digit     = satisfy isDigit
--   oneOf cs  = satisfy (\c -&gt; c `elem` cs)
--   </pre>
satisfy :: (Char -> Bool) -> CharParser st Char


-- | Commonly used generic combinators
module Text.ParserCombinators.Parsec.Combinator

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: [GenParser tok st a] -> GenParser tok st a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>. If
--   <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt>return []</tt>. Returns a list of <tt>n</tt> values returned by
--   <tt>p</tt>.
count :: Int -> GenParser tok st a -> GenParser tok st [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces  = between (symbol "{") (symbol "}")
--   </pre>
between :: GenParser tok st open -> GenParser tok st close -> GenParser tok st a -> GenParser tok st a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (do{ d &lt;- digit
--                           ; return (digitToInt d)
--                           })
--   </pre>
option :: a -> GenParser tok st a -> GenParser tok st a

-- | <tt>optionMaybe p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it return <a>Nothing</a>, otherwise it
--   returns <a>Just</a> the value returned by <tt>p</tt>.
optionMaybe :: GenParser tok st a -> GenParser tok st (Maybe a)

-- | <tt>optional p</tt> tries to apply parser <tt>p</tt>. It will parse
--   <tt>p</tt> or nothing. It only fails if <tt>p</tt> fails after
--   consuming input. It discards the result of <tt>p</tt>.
optional :: GenParser tok st a -> GenParser tok st ()

-- | <tt>skipMany1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times, skipping its result.
skipMany1 :: GenParser tok st a -> GenParser tok st ()

-- | <tt>many1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: GenParser tok st a -> GenParser tok st [a]

-- | <tt>sepBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (symbol ",")
--   </pre>
sepBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>endBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, seperated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
--   
--   <pre>
--   cStatements  = cStatement `endBy` semi
--   </pre>
endBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>endBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, seperated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>sepEndBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>, ie.
--   haskell style statements. Returns a list of values returned by
--   <tt>p</tt>.
--   
--   <pre>
--   haskellStatements  = haskellStatement `sepEndBy` semi
--   </pre>
sepEndBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>sepEndBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns a
--   list of values returned by <tt>p</tt>.
sepEndBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>chainl p op x</tt> parser <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt>. Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are zero
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainl :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a

-- | <tt>chainl1 p op x</tt> parser <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. . This parser can
--   for example be used to eliminate left recursion which typically occurs
--   in expression grammars.
--   
--   <pre>
--   expr    = term   `chainl1` addop
--   term    = factor `chainl1` mulop
--   factor  = parens expr &lt;|&gt; integer
--   
--   mulop   =   do{ symbol "*"; return (*)   }
--           &lt;|&gt; do{ symbol "/"; return (div) }
--   
--   addop   =   do{ symbol "+"; return (+) }
--           &lt;|&gt; do{ symbol "-"; return (-) }
--   </pre>
chainl1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a

-- | <tt>chainr p op x</tt> parser <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>right</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are no
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainr :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a

-- | <tt>chainr1 p op x</tt> parser <i>one</i> or more occurrences of |p|,
--   separated by <tt>op</tt> Returns a value obtained by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt> to
--   the values returned by <tt>p</tt>.
chainr1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a

-- | This parser only succeeds at the end of the input. This is not a
--   primitive parser but it is defined using <a>notFollowedBy</a>.
--   
--   <pre>
--   eof  = notFollowedBy anyToken &lt;?&gt; "end of input"
--   </pre>
eof :: Show tok => GenParser tok st ()

-- | <tt>notFollowedBy p</tt> only succeeds when parser <tt>p</tt> fails.
--   This parser does not consume any input. This parser can be used to
--   implement the 'longest match' rule. For example, when recognizing
--   keywords (for example <tt>let</tt>), we want to make sure that a
--   keyword is not followed by a legal identifier character, in which case
--   the keyword is actually an identifier (for example <tt>lets</tt>). We
--   can program this behaviour as follows:
--   
--   <pre>
--   keywordLet  = try (do{ string "let"
--                        ; notFollowedBy alphaNum
--                        })
--   </pre>
notFollowedBy :: Show a => GenParser tok st a -> GenParser tok st ()

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>. This parser can be used to scan comments:
--   
--   <pre>
--   simpleComment   = do{ string "&lt;!--"
--                       ; manyTill anyChar (try (string "--&gt;"))
--                       }
--   </pre>
--   
--   Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "&lt;!--"</tt>, and therefore the use of the <a>try</a> combinator.
manyTill :: GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]

-- | <tt>lookAhead p</tt> parses <tt>p</tt> without consuming any input.
lookAhead :: GenParser tok st a -> GenParser tok st a

-- | The parser <tt>anyToken</tt> accepts any kind of token. It is for
--   example used to implement <a>eof</a>. Returns the accepted token.
anyToken :: Show tok => GenParser tok st tok


-- | Parsec, the Fast Monadic Parser combinator library, see
--   <a>http://www.cs.uu.nl/people/daan/parsec.html</a>.
--   
--   Inspired by:
--   
--   <ul>
--   <li>Graham Hutton and Erik Meijer: Monadic Parser Combinators.
--   Technical report NOTTCS-TR-96-4. Department of Computer Science,
--   University of Nottingham, 1996.
--   <a>http://www.cs.nott.ac.uk/~gmh/monparsing.ps</a></li>
--   <li>Andrew Partridge, David Wright: Predictive parser combinators need
--   four values to report errors. Journal of Functional Programming 6(2):
--   355-364, 1996</li>
--   </ul>
--   
--   This helper module exports elements from the basic libraries.
module Text.ParserCombinators.Parsec

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <a>parse</a>. <tt>ParseError</tt> is an
--   instance of the <a>Show</a> class.
data ParseError

-- | Extracts the source position from the parse error
errorPos :: ParseError -> SourcePos

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos
type SourceName = String
type Line = Int
type Column = Int

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Increments the line number of a source position.
incSourceLine :: SourcePos -> Line -> SourcePos

-- | Increments the column number of a source position.
incSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the line number of a source position.
setSourceLine :: SourcePos -> Line -> SourcePos

-- | Set the column number of a source position.
setSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the name of the source.
setSourceName :: SourcePos -> SourceName -> SourcePos
