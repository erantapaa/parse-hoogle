-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Yet another option parser
--   
--   A simple wrapper over the standard System.Console.GetOpt to make
--   options defining more convenient.
@package yaop
@version 0.1.2.1


-- | YAOP is a library for options parsings that uses base <a>GetOpt</a> as
--   a backend.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   
--   import System
--   import System.Environment
--   import System.Console.YAOP
--   
--   import Data.List
--   import Data.Maybe
--   
--   -- | Options that are not mapped to data
--   withoutData = dummy =: option [] ["action"] NoA "Do some action" (\_ _ -&gt; putStrLn "IO Action")
--   
--   -- | Options data structure. Should use record syntax, may have more than one constructor
--   data Options = Options { optFileName :: FilePath
--                          , optCount :: Int
--                          , optStuff :: [Either Int String]
--                          } deriving (Show)
--   
--   -- | Default options
--   defOptions = Options {optFileName = "default.txt", optCount = 0, optStuff = []}
--   
--   -- | This triggers YAOP's accessors generator, e.g.
--   -- @modM_optFileName :: Monad m =&gt; (FilePath -&gt; m FilePath) -&gt; Options -&gt; m Options@
--   $(deriveModM ''Options)
--   
--   -- | Here we define a list of options that are mapped to Options
--   optDesc = do
--     modM_optFileName =: option ['f'] ["filename"] (ReqA "FN")
--                         "Set some filename"
--                         (\arg x -&gt; print arg &gt;&gt; return (fromMaybe "" arg))
--     modM_optCount    =: option ['c'] ["count"] (OptA "N")
--                         "Set some count"
--                         (\arg x -&gt; return $ fromMaybe 100 (read `fmap` arg))
--     modM_optStuff    =: option ['s'] ["stuff"] NoA
--                         "Push \"foo\" to a list"
--                          (\arg x -&gt; return (Right "foo" : x))
--   
--   bothDesc = withoutData &gt;&gt; optDesc
--   
--   main = do
--     (opts,args) &lt;- parseOptions bothDesc defOptions defaultParsingConf =&lt;&lt; getArgs
--     print opts
--     print args
--   </pre>
module System.Console.YAOP

-- | Generate functions with <tt>(a -&gt; m a) -&gt; rec -&gt; rec</tt>
--   type for all fields of the specified record.
deriveModM :: Name -> Q [Dec]

-- | Specifies if argument is required, optional or not necessary
data ArgReq
NoA :: ArgReq
OptA :: String -> ArgReq
ReqA :: String -> ArgReq
data Opt a
data OptM a r

-- | Smart option constructor
option :: String -> [String] -> ArgReq -> String -> (Maybe String -> a -> IO a) -> OptM a ()

-- | Apply selector to options combinator
(=:) :: MonadWriter [Opt t] (OptM t) => ((t -> IO t) -> a -> IO a) -> OptM t () -> OptM a ()

-- | Dummy selector, selects nothing. Useful for some <tt>--help</tt>
--   options.
dummy :: Monad m => (() -> m a) -> b -> m b

-- | Monadic action over the first element, useful as selector.
firstM :: Monad m => (t -> m t1) -> (t, t2) -> m (t1, t2)

-- | Monadic action over the second element, useful as selector.
secondM :: Monad m => (t -> m t2) -> (t1, t) -> m (t1, t2)
data ParsingConf
ParsingConf :: String -> Maybe String -> String -> Bool -> ParsingConf

-- | Usage message header
pcUsageHeader :: ParsingConf -> String

-- | Name of help message flag, default: <tt>"help"</tt>
pcHelpFlag :: ParsingConf -> Maybe String

-- | Extra help information
pcHelpExtraInfo :: ParsingConf -> String

-- | <tt>True</tt> means <a>GetOpt</a>'s <tt>Permute</tt>, <tt>False</tt>
--   means <tt>RequireOrder</tt>
pcPermuteArgs :: ParsingConf -> Bool

-- | Default option parsing configuration
defaultParsingConf :: ParsingConf

-- | Run parser, return configured options environment and arguments
parseOptions :: OptM t () -> t -> ParsingConf -> [String] -> IO (t, [String])
instance Show ArgReq
instance Monad (OptM a)
instance MonadWriter [Opt a] (OptM a)
instance Show (Opt a)

module System.Console.YAOP.Actions
data Application g
Application :: String -> [Action g] -> OptM g () -> g -> String -> Application g
appName :: Application g -> String
appActions :: Application g -> [Action g]
appGlobalDesc :: Application g -> OptM g ()
appGlobalDefs :: Application g -> g
appLongDesc :: Application g -> String
data Action g
Action :: String -> (OptM l ()) -> l -> (g -> l -> [String] -> IO ()) -> String -> String -> Action g
actName :: Action g -> String
actOptDesc :: Action g -> (OptM l ())
actDefOpts :: Action g -> l
actAction :: Action g -> (g -> l -> [String] -> IO ())
actShortDesc :: Action g -> String
actLongDesc :: Action g -> String

-- | Runs application: parses args, looks up an action and runs it
runApplication :: Application g -> [String] -> IO ()
