-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple CRUD classes for easy view creation for Yesod
--   
--   Simple CRUD classes for easy view creation for Yesod. See
--   <tt>Yesod.VEND</tt> for more informations and description how to use
--   it.
@package yesod-vend
@version 0.1


-- | This module provides simple typeclass <a>CRUD</a> which implements
--   CRUD (or VEND: View Edit New Delete) functionality for Yesod.
--   
--   There are default implementations that are unfortunately filtered out
--   by Haddock. The implementation uses DefaultSignatures extension to not
--   force a specific implementation on a library user.
--   
--   An example is given below.
--   
--   Suppose we have a User entity defined as config/models:
--   
--   <pre>
--   User
--       ident Text
--       name Text Maybe
--       address Text Maybe
--       telephone Text Maybe
--   </pre>
--   
--   Our module would then start with:
--   
--   <pre>
--   {-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
--   module Handler.User where
--    
--   import Import
--   import Yesod.VEND
--    
--   import Data.Maybe
--   </pre>
--   
--   Define helper datatype.
--   
--   <pre>
--   data UserP = UserP
--   </pre>
--   
--   Provide routing. This assumes that config/routes reads:
--   
--   <pre>
--   /user/new                    UserNewR    
--   /user/edit/#UserId           UserEditR   
--   /user/delete/#UserId         UserDeleteR 
--   /user/view/all               UserViewAllR   
--   /user/view/single/#UserId    UserViewR   
--   </pre>
--   
--   Methods:
--   
--   <pre>
--   handleUserNewR = newR UserP
--   handleUserDeleteR = deleteR UserP
--   handleUserEditR = editR UserP
--   handleUserViewR = viewR UserP
--   handleUserViewAllR = viewAllR UserP
--   </pre>
--   
--   Define <a>EntityDeep</a> instance for UserId. We use default
--   implementations.
--   
--   <pre>
--   instance EntityDeep UserId where
--       type EntT UserId = User
--       type FullEntT UserId = User
--   </pre>
--   
--   Define <a>CRUD</a> instance for our helper type UserP. Define
--   <a>ValT</a> and <a>KeyT</a> types.
--   
--   <pre>
--   instance CRUD UserP where
--       type ValT UserP = User
--       type KeyT UserP = UserId
--    
--   </pre>
--   
--   Wire routing information in:
--   
--   <pre>
--   newRt _ = UserNewR
--   editRt _ = UserEditR
--   deleteRt _ = UserDeleteR
--   viewRt _ = UserViewR
--   viewAllRt _ = UserViewAllR
--   
--   </pre>
--   
--   Define which <tt>parameters</tt> will be displayed for entity and how:
--   
--   <pre>
--   params _ = [(EntityParam "Ident" userIdent id markupToWidget)
--              ,(EntityParam "Name" userName mns mnsw)
--              ,(EntityParam "Address" userAddress mns mnsw)
--              ,(EntityParam "Telephone" userTelephone mns mnsw)
--              ] where mns = fromMaybe "not set"
--                      mnsw = maybe [whamlet|&lt;i&gt;not set&lt;/i&gt;|] markupToWidget
--   
--   </pre>
--   
--   Specify sorting in 'view all' view:
--   
--   <pre>
--   viewAllOptions _ = [Asc UserId]
--   
--   </pre>
--   
--   Define entity name:
--   
--   <pre>
--   entName _ = "User"
--   </pre>
--   
--   Form for creating/editing entity:
--   
--   <pre>
--   form _ proto = return $ renderDivs $  
--                   User
--                     &lt;$&gt; areq textField "Identifier" (fmap userIdent proto)
--                     &lt;*&gt; aopt textField "Name" (fmap userName proto)
--                     &lt;*&gt; aopt textField "Address" (fmap userAddress proto)
--                     &lt;*&gt; aopt textField "Telephone" (fmap userTelephone proto)
--   </pre>
module Yesod.VEND

-- | Datatype for providing different views on specific datatype.
--   Transforms the parameter into intermediate datatype b from which one
--   can use <a>epToText</a> to get <a>Text</a> or <a>epToWidget</a> to get
--   a <a>GWidget</a>.
data EntityParam master sub a
EntityParam :: Text -> (a -> b) -> (b -> Text) -> (b -> GWidget master sub ()) -> EntityParam master sub a
epName :: EntityParam master sub a -> Text
epGet :: EntityParam master sub a -> (a -> b)
epToText :: EntityParam master sub a -> (b -> Text)
epToWidget :: EntityParam master sub a -> (b -> GWidget master sub ())

-- | We cannot use record syntax to access fields of existential types.
--   Instead we have:
--   
--   <pre>
--   epGetText (EntityParam _ pGet pToText _) = pToText . pGet
--   </pre>
epGetText :: EntityParam t t1 t2 -> t2 -> Text

-- | We cannot use record syntax to access fields of existential types.
--   Instead we have:
--   
--   <pre>
--   epGetWidget (EntityParam _ pGet _ pToWidget) = pToWidget . pGet
--   </pre>
epGetWidget :: EntityParam t t1 t2 -> t2 -> GWidget t t1 ()

-- | Class for accessing entities referenced by <tt>a</tt> entity type. For
--   example for entities Foo, Bar:
--   
--   <pre>
--   Foo
--       name Text
--   Bar
--       size Int
--       foo  FooId
--   </pre>
--   
--   We would have this for Bar:
--   
--   <pre>
--   instance EntityDeep BarId where
--       type EntT = Bar
--       type FullEntT = (Bar,Foo)
--    
--       get404Full key = runDB $ do
--                      v1 &lt;- get404 key
--                      v2 &lt;- get404 (barFoo v1)
--                      return (v1,v2)
--    
--       entityCore _ = fst
--       paramsFull _ = [(EntityParam "Size" (barSize . fst) id markupToWidget)
--                      ,(EntityParam "Foo's name" (fooName . snd) id markupToWidget)]
--         
--   </pre>
class EntityDeep a where type family EntT a :: * type family FullEntT a :: * type instance EntT a = a type instance FullEntT a = a entityCore _ = id paramsFull = params get404Full key = runDB (get404 key)
get404Full :: EntityDeep a => a -> GHandler master sub (FullEntT a)
entityCore :: EntityDeep a => a -> (FullEntT a) -> (EntT a)
paramsFull :: EntityDeep a => a -> [EntityParam master sub (FullEntT a)]

-- | Given description of entity parameters (<a>EntityParam</a> list) and
--   terse/not terse option return a widget displaying the entity.
displayEntityWidget :: a -> [EntityParam master sub a] -> Bool -> GWidget master sub ()

-- | Core typeclass of this package. Default implementations of handlers
--   use other methods to provide sensible default views. They can be all
--   overriden if needed.
class EntityDeep (KeyT a) => CRUD a where type family ValT a type family KeyT a getSomeKey _ = undefined getSomeVal _ = undefined viewAllOptions _ = [] params _ = [EntityParam "shown" show pack markupToWidget] displayHeaderWidget this terse | terse = let pars = paramsFull (getSomeKey this) in do { toWidget ((preEscapedText . pack) "<tr><th colspan=\"20\"> "); toWidget (toHtml (entName this)); toWidget ((preEscapedText . pack) "</th></tr><tr><th>Actions</th>"); mapM_ (\ ep_a891 -> do { toWidget ((preEscapedText . pack) "<th> "); toWidget (toHtml (epName ep_a891)); toWidget ((preEscapedText . pack) "</th>") }) pars; toWidget ((preEscapedText . pack) "</tr>") } | otherwise = do { toWidget ((preEscapedText . pack) "<p> "); toWidget (toHtml (entName this)); toWidget ((preEscapedText . pack) " </p>") } displayWidget this a terse | terse = mapM_ (\ ep_a89b -> do { toWidget ((preEscapedText . pack) "<td> "); toWidget (toHtml (epGetText ep_a89b a)); toWidget ((preEscapedText . pack) " </td>") }) (params this) | otherwise = do { toWidget ((preEscapedText . pack) "<p> "); toWidget (toHtml (entName this)); toWidget ((preEscapedText . pack) "</p>"); mapM_ (\ ep_a89f -> do { toWidget ((preEscapedText . pack) "<p> "); toWidget (toHtml (epName ep_a89f)); toWidget ((preEscapedText . pack) ": <span class=\"param\"> "); toWidget (toHtml (epGetText ep_a89f a)); toWidget ((preEscapedText . pack) "</span></p>") }) (params this) } dForm _this = return $ renderDivs (areq areYouSureField "Are you sure?" (Just False)) where areYouSureField = check isSure boolField isSure False = Left ("You must be sure." :: Text) isSure True = Right True newR this = do { ((result, wg), et) <- runFormPost =<< (form this Nothing); let newForm = (wg, et); case result of { FormSuccess val -> do { key <- runDB $ insert val; setMessage "Entity created."; defaultLayout $ do { setTitle $ toHtml $ "Created: " ++ show (entName this) ++ show key; do { toWidget ((preEscapedText . pack) "Creation completed. ID="); toWidget (toHtml (show key)); toWidget ((preEscapedText . pack) ". <a href="); ((liftW getUrlRenderParams) >>= (\ urender_a89L -> toWidget (toHtml (\ u_a89M -> urender_a89L u_a89M [] (viewRt this key))))); toWidget ((preEscapedText . pack) ">View here</a>. <br>"); toWidget (displayWidget this val False); toWidget ((preEscapedText . pack) " ") } } } _ -> defaultLayout $ do { setTitle $ toHtml $ "New: " ++ show (entName this); do { toWidget ((preEscapedText . pack) "<p class=\"message\"> New: "); toWidget (toHtml (entName this)); toWidget ((preEscapedText . pack) "</p><form method=\"post\" action=\"\" enctype=\""); toWidget (toHtml (snd newForm)); toWidget ((preEscapedText . pack) "\">"); toWidget (fst newForm); toWidget ((preEscapedText . pack) "<input type=\"submit\"> </input></form>") } } } } viewAllR this = do { values <- runDB $ selectList [] (viewAllOptions this); values'full <- mapM (\ k -> fmap (\ v -> (k, v)) (get404Full k)) (map entityKey values); terse <- getTerse; defaultLayout $ do { setTitle $ id ((preEscapedText . pack) "All items "); do { toWidget ((preEscapedText . pack) "Choose view: <a href=\"?terse=1\">Terse</a> <a href=\"?terse=0\">Wide</a><br><strong><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8a3 -> toWidget (toHtml (\ u_a8a4 -> urender_a8a3 u_a8a4 [] (newRt this))))); toWidget ((preEscapedText . pack) "\"> Create new</a></strong><br><br>"); condH [(terse,  do { toWidget ((preEscapedText . pack) "<table class=\"terse table-striped table table-condensed\"><thead>"); toWidget (displayHeaderWidget this terse); toWidget ((preEscapedText . pack) "</thead><tbody>"); mapM_ (\ (key_a8a5, val'full_a8a6) -> do { toWidget ((preEscapedText . pack) "<tr><td><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8a7 -> toWidget (toHtml (\ u_a8a8 -> urender_a8a7 u_a8a8 [] (viewRt this key_a8a5))))); toWidget ((preEscapedText . pack) "\"> View</a><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8a9 -> toWidget (toHtml (\ u_a8aa -> urender_a8a9 u_a8aa [] (editRt this key_a8a5))))); toWidget ((preEscapedText . pack) "\"> Edit</a><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8ab -> toWidget (toHtml (\ u_a8ac -> urender_a8ab u_a8ac [] (deleteRt this key_a8a5))))); toWidget ((preEscapedText . pack) "\"> <strong> Delete </strong></a></td>"); toWidget (displayEntityWidget val'full_a8a6 (paramsFull key_a8a5) terse); toWidget ((preEscapedText . pack) "</tr>") }) values'full; toWidget ((preEscapedText . pack) "</tbody></table>") })] (Just (do { toWidget (displayHeaderWidget this terse); mapM_ (\ (key_a8ad, val'full_a8ae) -> do { toWidget ((preEscapedText . pack) "<hr class=\"listsep\"> </hr>"); toWidget (displayEntityWidget val'full_a8ae (paramsFull key_a8ad) terse); toWidget ((preEscapedText . pack) "<p class=\"actions\"> Actions:<a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8af -> toWidget (toHtml (\ u_a8ag -> urender_a8af u_a8ag [] (viewRt this key_a8ad))))); toWidget ((preEscapedText . pack) "\"> View</a><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8ah -> toWidget (toHtml (\ u_a8ai -> urender_a8ah u_a8ai [] (editRt this key_a8ad))))); toWidget ((preEscapedText . pack) "\"> Edit</a><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8aj -> toWidget (toHtml (\ u_a8ak -> urender_a8aj u_a8ak [] (deleteRt this key_a8ad))))); toWidget ((preEscapedText . pack) "\"> <strong> Delete </strong></a></p>") }) values'full })) } } } viewR this key = do { val'full <- get404Full key; defaultLayout $ do { setTitle $ toHtml $ "View: " ++ show (entName this) ++ show key; do { toWidget (displayEntityWidget val'full (paramsFull key) False); toWidget ((preEscapedText . pack) "<p class=\"actions\"> Actions:<a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8ar -> toWidget (toHtml (\ u_a8as -> urender_a8ar u_a8as [] (newRt this))))); toWidget ((preEscapedText . pack) "\"> New</a><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8at -> toWidget (toHtml (\ u_a8au -> urender_a8at u_a8au [] (editRt this key))))); toWidget ((preEscapedText . pack) "\"> Edit</a><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8av -> toWidget (toHtml (\ u_a8aw -> urender_a8av u_a8aw [] (deleteRt this key))))); toWidget ((preEscapedText . pack) "\"> <strong> Delete </strong></a></p>") } } } editR this key = do { val <- runDB $ get404 key; ((result, fwidget), enctype) <- runFormPost =<< (form this (Just val)); case result of { FormSuccess new'val -> do { runDB $ replace key new'val; return () } _ -> return () }; defaultLayout $ do { setTitle $ toHtml $ "Edit: " ++ show (entName this) ++ show key; do { toWidget ((preEscapedText . pack) "<p class=\"actions\"> Actions:<a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8aH -> toWidget (toHtml (\ u_a8aI -> urender_a8aH u_a8aI [] (newRt this))))); toWidget ((preEscapedText . pack) "\"> New</a><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8aJ -> toWidget (toHtml (\ u_a8aK -> urender_a8aJ u_a8aK [] (viewRt this key))))); toWidget ((preEscapedText . pack) "\"> View</a><a href=\""); ((liftW getUrlRenderParams) >>= (\ urender_a8aL -> toWidget (toHtml (\ u_a8aM -> urender_a8aL u_a8aM [] (deleteRt this key))))); toWidget ((preEscapedText . pack) "\"> <strong> Delete </strong></a></p><p class=\"message\"> Edit: "); toWidget (toHtml (entName this)); toWidget ((preEscapedText . pack) "</p><form method=\"post\" action=\"\" enctype=\""); toWidget (toHtml enctype); toWidget ((preEscapedText . pack) "\">"); toWidget fwidget; toWidget ((preEscapedText . pack) "<input type=\"submit\"> </input></form>") } } } deleteR this key = do { val'full <- get404Full key; ((result, fwidget), enctype) <- runFormPost =<< (dForm this); case result of { FormSuccess _ -> do { runDB $ delete key; setMessage $ do { id ((preEscapedText . pack) "Deleted: "); id (toHtml (entName this)); id ((preEscapedText . pack) " "); id (toHtml (show key)); id ((preEscapedText . pack) " ") }; defaultLayout $ do { setTitle $ do { id ((preEscapedText . pack) "Deleted: "); id (toHtml (entName this)); id ((preEscapedText . pack) " "); id (toHtml (show key)); id ((preEscapedText . pack) " ") }; toWidget ((preEscapedText . pack) "Delete completed. ") } } _ -> defaultLayout $ do { setTitle $ toHtml $ "Delete: " ++ show (entName this) ++ show key; do { toWidget ((preEscapedText . pack) "<p class=\"message\"> Delete: "); toWidget (toHtml (entName this)); toWidget ((preEscapedText . pack) "</p>"); toWidget (displayEntityWidget val'full (paramsFull key) False); toWidget ((preEscapedText . pack) "<form method=\"post\" action=\"\" enctype=\""); toWidget (toHtml enctype); toWidget ((preEscapedText . pack) "\">"); toWidget fwidget; toWidget ((preEscapedText . pack) "<input type=\"submit\"> </input></form>") } } } }
getSomeKey :: CRUD a => a -> KeyT a
getSomeVal :: CRUD a => a -> ValT a
viewAllOptions :: CRUD a => a -> [SelectOpt (ValT a)]
newRt :: CRUD a => a -> Route site
viewAllRt :: CRUD a => a -> Route site
viewRt :: CRUD a => a -> (KeyT a) -> Route site
deleteRt :: CRUD a => a -> (KeyT a) -> Route site
editRt :: CRUD a => a -> (KeyT a) -> Route site
displayWidget :: CRUD a => a -> (ValT a) -> Bool -> GWidget master sub ()
displayHeaderWidget :: CRUD a => a -> Bool -> GWidget master sub ()
params :: CRUD a => a -> [EntityParam master sub (ValT a)]
entName :: CRUD a => a -> Text
form :: CRUD a => a -> (Maybe (ValT a)) -> GHandler master sub (Html -> MForm master sub (FormResult (ValT a), GWidget master sub ()))
dForm :: CRUD a => a -> GHandler master sub (Html -> MForm master sub (FormResult Bool, GWidget master sub ()))
viewR :: CRUD a => a -> (KeyT a) -> GHandler master sub RepHtml
editR :: CRUD a => a -> (KeyT a) -> GHandler master sub RepHtml
newR :: CRUD a => a -> GHandler master sub RepHtml
deleteR :: CRUD a => a -> (KeyT a) -> GHandler master sub RepHtml
viewAllR :: CRUD a => a -> GHandler master sub RepHtml

-- | Check if the view should be "terse" or not. Checks for "terse" in GET
--   parameters. Default is True. 1 means True, 0 means False.
getTerse :: GHandler master sub Bool

-- | make <a>GWidget</a> from any type that implements <a>ToMarkup</a>
markupToWidget :: ToMarkup a => a -> GWidget sub master ()
