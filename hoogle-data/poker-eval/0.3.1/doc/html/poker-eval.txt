-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Binding to libpoker-eval
--   
--   Performance oriented functions for judging poker hands and related
--   tasks.
--   
--   Haddock documentation can be found here:
--   <a>http://mirror.seize.it/poker-eval/documentation/</a>
--   
--   C library can be found here:
--   <a>http://pokersource.sourceforge.net/</a>
@package poker-eval
@version 0.3.1


-- | Importing this module gives you access to the inner workings of
--   Data.Poker. Use with care.
module Data.Poker.Internal

-- | Isomorphic to <a>HandValue</a> but computed much more efficiently.
--   
--   If possible, this is the structure to use.
newtype NumericalHandValue
NumericalHandValue :: Word -> NumericalHandValue
unNumericalHandValue :: NumericalHandValue -> Word

-- | Isomorphic to <a>HandValue</a> but stored more efficiently.
--   
--   This structure has the special property of being bounded and an enum.
--   It is especially useful as an Array index.
newtype ConsecutiveHandValue
ConsecutiveHandValue :: Int -> ConsecutiveHandValue
unConsecutiveHandValue :: ConsecutiveHandValue -> Int

-- | Abstract representation of a card consisting of a <a>Rank</a> and a
--   <a>Suit</a>
newtype Card
Card :: CInt -> Card

-- | A set of cards.
newtype CardSet
CardSet :: StdDeck_CardMask -> CardSet
unmask :: CardSet -> StdDeck_CardMask
type StdDeck_CardMask = CLLong
distHandValue :: CardSet -> UArray ConsecutiveHandValue Int
allHandValues :: [HandValue]


module Data.Poker

-- | Find the strongest possible hand using the given cards.
handValue :: CardSet -> HandValue

-- | Find the strongest possible hand using the given cards. This function
--   is significantly faster than <a>handValue</a> if the size of the card
--   set is constant.
handValue_n :: Int -> CardSet -> HandValue

-- | Find the strongest possible hand using the given cards.
--   
--   It is significantly faster to compute a <a>NumericalHandValue</a> than
--   a <a>HandValue</a>. Use this function instead of <a>handValue</a> when
--   possible.
numericalHandValue :: CardSet -> NumericalHandValue

-- | Find the strongest possible hand using the given cards. This function
--   is significantly faster than <a>numericalHandValue</a> if the size of
--   the card set is constant.
--   
--   It is significantly faster to compute a <a>NumericalHandValue</a> than
--   a <a>HandValue</a>. Use this function instead of <a>handValue_n</a>
--   when possible.
numericalHandValue_n :: Int -> CardSet -> NumericalHandValue

-- | Strict left-fold over all 7 card combinations excluding the dead
--   cards.
foldlSevenCards :: (CardSet -> a -> a) -> a -> CardSet -> a

-- | Strict left-fold over all 5 card combinations excluding the dead
--   cards.
foldlFiveCards :: (CardSet -> a -> a) -> a -> CardSet -> a

-- | Strict left-fold over all 4 card combinations excluding the dead
--   cards.
foldlFourCards :: (CardSet -> a -> a) -> a -> CardSet -> a

-- | Strict left-fold over all 3 card combinations excluding the dead
--   cards.
foldlThreeCards :: (CardSet -> a -> a) -> a -> CardSet -> a

-- | Strict left-fold over all 2 card combinations excluding the dead
--   cards.
foldlTwoCards :: (CardSet -> a -> a) -> a -> CardSet -> a

-- | Strict left-fold over all 1 card combinations excluding the dead
--   cards.
foldlOneCard :: (CardSet -> a -> a) -> a -> CardSet -> a

-- | Given a set of dead cards, enumerate over all possible selections of
--   five cards. The generated card sets do not contain the dead cards.
enumerateFiveCards :: Monad m => CardSet -> (CardSet -> m ()) -> m ()

-- | This structure represents the value of a poker hand as a high-level
--   ADT.
--   
--   The following must be true for a HandValue to be valid:
--   
--   <ul>
--   <li>All kickers must be in decending order.</li>
--   <li>No <a>Rank</a> may not occur twice.</li>
--   <li>The kickers may not construct higher-value hands.</li>
--   </ul>
--   
--   For example, <tt><a>NoPair</a> <a>Six</a> <a>Five</a> <a>Four</a>
--   <a>Three</a> <a>Two</a></tt> is not a valid HandValue.
data HandValue
NoPair :: Kicker -> Kicker -> Kicker -> Kicker -> Kicker -> HandValue
OnePair :: Rank -> Kicker -> Kicker -> Kicker -> HandValue
TwoPair :: Rank -> Rank -> Kicker -> HandValue
ThreeOfAKind :: Rank -> Kicker -> Kicker -> HandValue
Straight :: Rank -> HandValue
Flush :: Kicker -> Kicker -> Kicker -> Kicker -> Kicker -> HandValue
FullHouse :: Rank -> Rank -> HandValue
FourOfAKind :: Rank -> Kicker -> HandValue
StraightFlush :: Rank -> HandValue

-- | Isomorphic to <a>HandValue</a> but computed much more efficiently.
--   
--   If possible, this is the structure to use.
data NumericalHandValue

-- | Isomorphic to <a>HandValue</a> but stored more efficiently.
--   
--   This structure has the special property of being bounded and an enum.
--   It is especially useful as an Array index.
data ConsecutiveHandValue

-- | Abstract representation of a card consisting of a <a>Rank</a> and a
--   <a>Suit</a>
data Card
data Rank
Two :: Rank
Three :: Rank
Four :: Rank
Five :: Rank
Six :: Rank
Seven :: Rank
Eight :: Rank
Nine :: Rank
Ten :: Rank
Jack :: Rank
Queen :: Rank
King :: Rank
Ace :: Rank
data Suit
Hearts :: Suit
Diamonds :: Suit
Clubs :: Suit
Spades :: Suit
type Kicker = Rank

-- | Construct a card with the given rank and suit.
mkCard :: Rank -> Suit -> Card

-- | Inspect the rank of a card.
cardRank :: Card -> Rank

-- | Inspect the suit of a card.
cardSuit :: Card -> Suit

-- | A set of cards.
data CardSet

-- | O(n). Convert the set to a list of cards.
toList :: CardSet -> [Card]

-- | O(n). Create a set from a list of cards.
fromList :: [Card] -> CardSet

-- | O(1). Create a singleton set.
singleton :: Card -> CardSet

-- | O(n). The number of cards in the set.
--   
--   Performance note: Try to avoid using this function in an inner loop.
size :: CardSet -> Int

-- | O(1). The empty set.
empty :: CardSet

-- | O(1). Is this the empty set?
isEmpty :: CardSet -> Bool

-- | O(1). The union of two sets.
union :: CardSet -> CardSet -> CardSet

-- | O(1). The intersection of two sets.
intersection :: CardSet -> CardSet -> CardSet

-- | O(1). Find the inverse set such that <tt>set <a>intersection</a>
--   inverse = empty</tt> and <tt>set <a>union</a> inverse set = fromList
--   [minBound ..]</tt>.
inverse :: CardSet -> CardSet

-- | O(1). Is the card in the set?
member :: CardSet -> Card -> Bool

-- | O(n). Count the number of cards with a specific <a>Rank</a> in a set.
countRank :: CardSet -> Rank -> Int

-- | O(n). Count the number of cards with a specific <a>Suit</a> in a set.
countSuit :: CardSet -> Suit -> Int

-- | True for all NoPair hands.
isNoPair :: HandValue -> Bool

-- | True for all OnePair hands.
isOnePair :: HandValue -> Bool

-- | True for all TwoPair hands.
isTwoPair :: HandValue -> Bool

-- | True for all ThreeOfAKind hands.
isThreeOfAKind :: HandValue -> Bool

-- | True for all Straight hands.
isStraight :: HandValue -> Bool

-- | True for all Flush hands.
isFlush :: HandValue -> Bool

-- | True for all FullHouse hands.
isFullHouse :: HandValue -> Bool

-- | True for all FourOfAKind hands.
isFourOfAKind :: HandValue -> Bool

-- | True for all StraightFlush hands.
isStraightFlush :: HandValue -> Bool
