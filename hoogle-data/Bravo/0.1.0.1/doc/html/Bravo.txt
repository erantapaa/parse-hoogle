-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Static text template generation library
--   
--   Bravo is a text template library that provides parsing and generation
--   of templates at compile time. Templates can be read from strings or
--   files and for each a new record data type is created, allowing
--   convenient access to all template variables in a type-safe manner.
--   Since all templates are processed at compile time, no extra file
--   access or error handling at runtime is necessary.
--   
--   Additional features include the definition of multiple templates per
--   file, conditional template evaluation, embedding of Haskell
--   expressions and customized data type generation.
@package Bravo
@version 0.1.0.1


-- | Bravo templates can be read from strings via the <a>mkTemplates</a>,
--   or from files via the <a>mkTemplatesFromFile</a> Template Haskell
--   functions, so you need to enable the TemplateHaskell language
--   extension when using Bravo in your Haskell application. Each read
--   string or file can contain multiple templates and additional comments.
--   A single template is delimitated by an opening splice <tt>{{ tpl
--   <i>name</i> }}</tt> and a closing splice <tt>{{ endtpl }}</tt> where
--   <i>name</i> is an identifier starting with a lowercase letter.
--   Characters before and after these splices are considered to be
--   template comments and therefore are ignored. Between these delimiters
--   multiple inner splices are allowed, which are:
--   
--   <ul>
--   <li>Normal text, i.e. character sequences not including <tt>{{</tt> or
--   <tt>}}</tt>.</li>
--   <li>Comment splices <tt>{{- <i>comment text</i> -}}</tt>. These
--   splices are only for documentary purposes and will not occur in the
--   produced template text.</li>
--   <li>Expression splices <tt>{{: <i>expression</i> }}</tt>. Here
--   <i>expression</i> can be an arbitrary Haskell expression that does not
--   require any language extensions to be parsed. The expression itself is
--   not evaluated at compile time but rather at runtime and the result of
--   evaluation will be included in the produced template text. Note that
--   the evaluated expression must be of type <a>String</a>, otherwise
--   compile errors will occur in the produced declarations. Additionally,
--   template variables of the form <tt>$<i>name</i></tt> or
--   <tt>$(<i>name</i>)</tt> can be used within an expression.</li>
--   <li>Conditional splices <tt>{{ if <i>condition_1</i> }} ... [ {{
--   elseif <i>condition_2</i> }} ... ]* [ {{ else }} ... ] {{ endif
--   }}</tt> where each <tt>...</tt> stands for an arbitrary number of
--   inner splices. Multiple <tt>elseif</tt> splices and/or a single
--   <tt>else</tt> splice are optional. <i>condition_n</i> are Haskell
--   expressions similar to <i>expression</i> in expression splices, except
--   that they have to evaluate to a value of type <a>Bool</a>. All
--   conditions will be evaluated in sequence and if one condition
--   evaluates to <tt>True</tt>, the subsequent template splices are added
--   to the resulting template text; all other inner splices are
--   discarded.</li>
--   </ul>
--   
--   After successful parsing, a new record data type with a single data
--   constructor and a corresponding instance of class <a>Show</a> is
--   created for each template. Also each used template variable is
--   transformed to a new record field of the data constructor. When parsed
--   with default options, the simple template
--   
--   <pre>
--   {{tpl simple}}{{:$name}}'s favourite song is "{{:$song}}"{{endtpl}}
--   </pre>
--   
--   will be translated to the record data type
--   
--   <pre>
--   data TplSimple = TplSimple {
--                       simpleName :: String,
--                       simpleSong :: String
--                    }.
--   </pre>
--   
--   To customize the created data types, the <a>mkTemplatesWithOptions</a>
--   or <a>mkTemplatesFromFileWithOptions</a> functions can be used.
--   Finally, use the <a>show</a> function on a value of the created data
--   type to convert it into a string.
module Text.Bravo

-- | Transforms a string into a list of template declarations.
mkTemplates :: String -> Q [Dec]

-- | Transforms a string into a list of template declarations, using custom
--   options for the data type generation.
mkTemplatesWithOptions :: TplOptions -> String -> Q [Dec]

-- | Reads a file and transforms the read file content into a list of
--   template declarations.
mkTemplatesFromFile :: FilePath -> Q [Dec]

-- | Reads a file and transforms the read file content into a list of
--   template declarations, using custom options for the data type
--   generation.
mkTemplatesFromFileWithOptions :: TplOptions -> FilePath -> Q [Dec]

-- | A set of functions to change the style of the generated templates.
data TplOptions
TplOptions :: (String -> String) -> (String -> String -> String) -> (String -> String) -> TplOptions

-- | Creates the data type and constructor name for a given template name.
tplMkName :: TplOptions -> String -> String

-- | Creates the record field name for a given template name and field
--   name.
tplMkFieldName :: TplOptions -> String -> String -> String

-- | This function is applied to each template text splice, allowing e.g.
--   the removal of extra whitespace etc.
tplModifyText :: TplOptions -> String -> String

-- | The default template generation options used by <a>mkTemplates</a> and
--   <a>mkTemplatesFromFile</a>. An example:
--   
--   <pre>
--   tplMkName defaultTplOptions "example"              == "TplExample"
--   tplMkFieldName defaultTplOptions "example" "field" == "exampleField"
--   tplModifyText defaultTplOptions                    == id
--   </pre>
defaultTplOptions :: TplOptions
