-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A word search solver library and executable
--   
--   A word search solver library and executable
@package wordsearch
@version 1.0.1


-- | A word search solver library
--   
--   This solver is case sensitive; users should map data consistently to
--   one case before using this library when such behavior is desired.
module Text.WordSearchSolver

-- | Abstract container of a word search puzzle
--   
--   This can be created either from a <a>Search</a> and a <a>Grid</a> by
--   the <a>wordSearch</a> function or from a properly formatted
--   <a>String</a> by the <a>readWordSearch</a> function.
data WordSearch a
ws_grid :: :-> (WordSearch a[a1Pa]) (Grid a[a1Pa])
ws_search :: :-> (WordSearch a[a1Pa]) (Search a[a1Pa])

-- | A grid in which to search
--   
--   Constructors of this container usually assume that the grid is
--   rectangular and properly sized; this precondition is not checked.
data Grid a

-- | A set of words or lists to search
data Search a

-- | A position of a grid
newtype Pos
Pos :: (PosIndex, PosIndex) -> Pos

-- | The integral type used for <a>Pos</a>
type PosIndex = Integer

-- | An individual value describing a match
data Match
Match :: Dir -> Integer -> Pos -> Match
_m_dir :: Match -> Dir
_m_len :: Match -> Integer
_m_pos :: Match -> Pos
m_dir :: :-> Match Dir
m_len :: :-> Match Integer
m_pos :: :-> Match Pos
data Dir
N :: Dir
NW :: Dir
W :: Dir
SW :: Dir
S :: Dir
SE :: Dir
E :: Dir
NE :: Dir

-- | Constructs a <a>WordSearch</a> container from a properly formatted
--   <a>String</a>
--   
--   The <a>String</a> should contain two sections, separated by at least
--   one empty line. The first section represents the grid, and thus is
--   formatted as the String that <a>readGrid</a> expects. The second
--   section represents the search words; it contains each word on its own
--   separate line. In the case that is ill-formed, Nothing is returned.
--   The precondition that each grid row has equal length is not checked.
readWordSearch :: String -> Maybe (WordSearch Char)

-- | Constructs a <a>WordSearch</a> container from a <a>Grid</a> and a
--   <a>Search</a>
wordSearch :: Grid a -> Search a -> WordSearch a

-- | Solves a <a>WordSearch</a> and returns a set of matches together with
--   a set of search terms for which a match was not found in a tuple
--   
--   This algorithm solves word search puzzles by looking at the first cell
--   of each search term, and looking for a match by checking each
--   direction from each position whose cell contains the starting cell of
--   the search term until a match is found. The dictionary of individual
--   cell values and sets of positions is part of the <a>Grid</a>
--   container; <a>arrayToGrid</a> creates this dictionary automatically.
solveWordSearch :: (Eq a, Ord a) => WordSearch a -> (Set Match, Search a)

-- | Determines whether a given <a>Search</a> term can be matched at a
--   given position of a grid
--   
--   This is done by trying each direction for a match from the given
--   location.
search :: (Eq a) => Grid a -> [a] -> Pos -> Maybe Match

-- | If the location and the direction matches the <a>Search</a> term,
--   returns the <a>Match</a>; otherwise, returns Nothing
tryMatch :: (Eq a) => Grid a -> [a] -> Pos -> Dir -> Maybe Match

-- | Constructs a <a>Grid</a> from a formatted list of <a>String</a>s
--   
--   The <a>String</a> should be formatted as expected:
--   
--   <pre>
--   ["aoaoenxrcoedxncd",
--    "aoesnitdaoeusntd",
--    "itenohtneahuoteh"]
--   </pre>
--   
--   The precondition that each row has equal length is not checked.
readGrid :: [String] -> Grid Char

-- | Constructs a <a>Grid</a> from an <a>Array</a>
--   
--   A grid array is indexed by (column, row) or (x, y), so users should be
--   careful that a list is in the proper order if listArray is used.
arrayToGrid :: (Ord a) => Array Pos a -> Grid a

-- | Constructs a <a>Search</a> from a set of lists
setToSearch :: Set [a] -> Search a

-- | Returns the set of search terms from a <a>Search</a> container
searchToSet :: Search a -> Set [a]

-- | Creates a <a>Grid</a> in which every cell that does not match is set
--   to a default value
fillMatches :: (Foldable t, Ord e) => e -> Grid e -> t Match -> Grid e

-- | Renders a <a>Grid</a>, appending a cell, usually a newline character,
--   after every row
showGridInsert :: a -> Grid a -> [a]

-- | Complete set of possible <a>Grid</a> <a>Match</a> directions
dirs :: [Dir]

-- | More efficient (and real, unordered) <tt>Set</tt> of <a>dirs</a>
dirs' :: Set Dir

-- | <tt>Map</tt> of directions and <a>Pos</a> offsets
dirsPos :: Map Dir Pos

-- | Bidirectional <tt>Map</tt> of opposite directions
dirsOpposite :: Map Dir Dir

-- | Returns the appropriate offset of a direction
dirToOffset :: Dir -> Pos

-- | Returns the opposite direction
dirOpposite :: Dir -> Dir

-- | Updates a position by one step in the given direction
dirUpdatePos :: Dir -> Pos -> Pos

-- | Determines whether an index is within the range of the bounds of an
--   array
inRangeOf :: (Ix a) => a -> Array a e -> Bool

-- | Adds two positions
posPlus :: Pos -> Pos -> Pos
instance Typeable Dir
instance Typeable Match
instance Typeable Pos
instance Typeable1 Search
instance Typeable1 GridIndex
instance Typeable1 Grid
instance Typeable1 WordSearch
instance Data Dir
instance Eq Dir
instance Enum Dir
instance Ord Dir
instance Ix Dir
instance Show Dir
instance Read Dir
instance Data Match
instance Eq Match
instance Ord Match
instance Show Match
instance Read Match
instance Data Pos
instance Eq Pos
instance Ord Pos
instance Ix Pos
instance Show Pos
instance Read Pos
instance (Data a, Ord a) => Data (Search a)
instance (Eq a) => Eq (Search a)
instance (Ord a) => Ord (Search a)
instance (Show a) => Show (Search a)
instance (Ord a, Read a) => Read (Search a)
instance (Data a, Ord a) => Data (GridIndex a)
instance (Eq a) => Eq (GridIndex a)
instance (Ord a) => Ord (GridIndex a)
instance (Show a) => Show (GridIndex a)
instance (Ord a, Read a) => Read (GridIndex a)
instance (Data a, Ord a) => Data (Grid a)
instance (Eq a) => Eq (Grid a)
instance (Ord a) => Ord (Grid a)
instance (Show a) => Show (Grid a)
instance (Ord a, Read a) => Read (Grid a)
instance (Data a, Ord a) => Data (WordSearch a)
instance (Eq a) => Eq (WordSearch a)
instance (Ord a) => Ord (WordSearch a)
instance (Show a) => Show (WordSearch a)
instance (Ord a, Read a) => Read (WordSearch a)
