-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | 32-bit non-cryptographic hashing
--   
--   MurmurHash is a family of non-cryptographic hash functions suitable
--   for general hash-based lookup. This implementation uses the
--   MurmurHash3 algorithm and provides a type class for computing 32-bit
--   hashes from all prevalent data types in the Haskell 2010 Standard.
@package murmurhash3
@version 1.0


-- | For details of the implementation of MurmurHash3, see the following
--   webpages:
--   
--   <ul>
--   <li><a>http://code.google.com/p/smhasher/</a></li>
--   <li><a>http://en.wikipedia.org/wiki/MurmurHash</a></li>
--   </ul>
module Data.Digest.Murmur

-- | A 32-bit hash.
type Hash = Word32

-- | Computes a 32-bit hash from a <i>hashable</i> value.
hash :: Hashable a => a -> Hash

-- | Type class for computing hash generators from values.
--   
--   Making custom data types instantiate <a>Hashable</a> is
--   straightforward; given the following tree data structure:
--   
--   <pre>
--   data Tree a
--     = Tip
--     | Bin a (Tree a) (Tree a)
--   </pre>
--   
--   ...we make it instantiate <a>Hashable</a> like this:
--   
--   <pre>
--   instance Hashable a =&gt; Hashable (Tree a) where
--     hashGen Tip         = salt 0x0
--     hashGen (Bin x l r) = hashGen x `combine` hashGen l `combine` hashGen r
--   </pre>
--   
--   For sum data types such as <a>Either</a> we typically want to avoid
--   that
--   
--   <pre>
--   Left "foo"
--   </pre>
--   
--   hashes to the same hash as
--   
--   <pre>
--   Right "foo"
--   </pre>
--   
--   ...hence we add some <a>salt</a> for each constructor:
--   
--   <pre>
--   instance (Hashable a, Hashable b) =&gt; Hashable (Either a b) where
--     hashGen (Left  x) = salt 0x1 `combine` hashGen x
--     hashGen (Right y) = salt 0x2 `combine` hashGen y
--   </pre>
class Hashable a
hashGen :: Hashable a => a -> HashGen

-- | A hash generator is a function that maps a hash state into a new hash
--   state. The internal representation of hash states is kept transparent.
data HashGen

-- | Returns a hash generator that mixes its input with a 32-bit word. Is
--   typically used for enumerating constructors when deriving
--   <a>Hashable</a>.
salt :: Word32 -> HashGen

-- | Combines two hash generators such that the output of the first
--   generator is piped into the next. This works similar to function
--   composition. Indeed, for all <i>f</i>, <i>g</i>, <i>h</i>, we have
--   that
--   
--   <pre>
--   f `combine` (g `combine` h) == (f `combine` g) `combine` h
--   </pre>
combine :: HashGen -> HashGen -> HashGen
instance (Hashable a, RealFloat a) => Hashable (Complex a)
instance Hashable Double
instance Hashable Float
instance (Hashable a, Integral a) => Hashable (Ratio a)
instance (Hashable a, Hashable b, Hashable c, Hashable d) => Hashable (a, b, c, d)
instance (Hashable a, Hashable b, Hashable c) => Hashable (a, b, c)
instance (Hashable a, Hashable b) => Hashable (a, b)
instance (Hashable a, Ix i) => Hashable (Array i a)
instance Hashable a => Hashable [a]
instance (Hashable a, Hashable b) => Hashable (Either a b)
instance Hashable a => Hashable (Maybe a)
instance Hashable Bool
instance Hashable ()
instance Hashable Integer
instance Hashable Int64
instance Hashable Int32
instance Hashable Int16
instance Hashable Int8
instance Hashable Word64
instance Hashable Word32
instance Hashable Word16
instance Hashable Word8
instance Hashable Int
instance Hashable Word
instance Hashable Char
