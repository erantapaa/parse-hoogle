-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast combinator parsing for bytestrings and text
--   
@package picoparsec
@version 0.1.2.2


-- | A tiny, highly specialized combinator parser for monoidal inputs.
--   
--   While the main Picoparsec module generally performs well, this module
--   is particularly fast for simple non-recursive loops that should not
--   normally result in failed parses.
--   
--   <i>Warning</i>: on more complex inputs involving recursion or failure,
--   parsers based on this module may be as much as <i>ten times slower</i>
--   than regular Picoparsec! You should <i>only</i> use this module when
--   you have benchmarks that prove that its use speeds your code up.
module Data.Picoparsec.Zepto

-- | A simple parser.
--   
--   This monad is strict in its state, and the monadic bind operator
--   (<a>&gt;&gt;=</a>) evaluates each result to weak head normal form
--   before passing it along.
data Parser t a

-- | Run a parser.
parse :: Parser t a -> t -> Either String a

-- | Indicate whether the end of the input has been reached.
atEnd :: MonoidNull t => Parser t Bool

-- | Match a string exactly.
string :: LeftReductiveMonoid t => t -> Parser t ()

-- | Consume <tt>n</tt> prime tokens of input.
take :: FactorialMonoid t => Int -> Parser t t

-- | Consume input while the predicate returns <a>True</a>.
takeCharsWhile :: TextualMonoid t => (Char -> Bool) -> Parser t t

-- | Consume input while the predicate returns <a>True</a>.
takeWhile :: FactorialMonoid t => (t -> Bool) -> Parser t t
instance Alternative (Parser t)
instance Applicative (Parser t)
instance MonadPlus (Parser t)
instance Monad (Parser t)
instance Functor (Parser t)


-- | Simple, efficient parser combinators for strings, loosely based on the
--   Parsec library.
module Data.Picoparsec.Types

-- | The core parser type. This is parameterised over the type <tt>t</tt>
--   of string being processed.
--   
--   This type is an instance of the following classes:
--   
--   <ul>
--   <li><a>Monad</a>, where <a>fail</a> throws an exception (i.e. fails)
--   with an error message.</li>
--   <li><a>Functor</a> and <a>Applicative</a>, which follow the usual
--   definitions.</li>
--   <li><a>MonadPlus</a>, where <a>mzero</a> fails (with no error message)
--   and <a>mplus</a> executes the right-hand parser if the left-hand one
--   fails. When the parser on the right executes, the input is reset to
--   the same state as the parser on the left started with. (In other
--   words, Picoparsec is a backtracking parser that supports arbitrary
--   lookahead.)</li>
--   <li><a>Alternative</a>, which follows <a>MonadPlus</a>.</li>
--   </ul>
data Parser t a

-- | The result of a parse. This is parameterised over the type <tt>t</tt>
--   of string that was processed.
--   
--   This type is an instance of <a>Functor</a>, where <a>fmap</a>
--   transforms the value in a <a>Done</a> result.
data IResult i r

-- | The parse failed. The <tt>i</tt> parameter is the input that had not
--   yet been consumed when the failure occurred. The
--   <tt>[</tt><a>String</a><tt>]</tt> is a list of contexts in which the
--   error occurred. The <a>String</a> is the message describing the error,
--   if any.
Fail :: i -> [String] -> String -> IResult i r

-- | Supply this continuation with more input so that the parser can
--   resume. To indicate that no more input is available, pass an empty
--   string to the continuation.
--   
--   <b>Note</b>: if you get a <a>Partial</a> result, do not call its
--   continuation more than once.
Partial :: (i -> IResult i r) -> IResult i r

-- | The parse succeeded. The <tt>i</tt> parameter is the input that had
--   not yet been consumed (if any) when the parse succeeded.
Done :: i -> r -> IResult i r


-- | Useful parser combinators, similar to those provided by Parsec.
module Data.Picoparsec.Combinator

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   This combinator is provided for compatibility with Parsec. Picoparsec
--   parsers always backtrack on failure.
try :: Parser i a -> Parser i a

-- | Name the parser, in case failure occurs.
(<?>) :: Parser i a -> String -> Parser i a

-- | <tt>choice ps</tt> tries to apply the actions in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding action.
choice :: Alternative f => [f a] -> f a

-- | Apply the given action repeatedly, returning every result.
count :: Monad m => Int -> m a -> m [a]

-- | <tt>option x p</tt> tries to apply action <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative f => a -> f a -> f a

-- | <tt>many' p</tt> applies the action <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many' letter
--   </pre>
many' :: MonadPlus m => m a -> m [a]

-- | <tt>many1 p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Alternative f => f a -> f [a]

-- | <tt>many1' p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many1' letter
--   </pre>
many1' :: MonadPlus m => m a -> m [a]

-- | <tt>manyTill p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
manyTill :: Alternative f => f a -> f b -> f [a]

-- | <tt>manyTill' p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill' anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
--   
--   The value returned by <tt>p</tt> is forced to WHNF.
manyTill' :: MonadPlus m => m a -> m b -> m [a]

-- | <tt>sepBy p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (char ',')
--   </pre>
sepBy :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy' p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy'` (char ',')
--   </pre>
sepBy' :: MonadPlus m => m a -> m s -> m [a]

-- | <tt>sepBy1 p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy1` (char ',')
--   </pre>
sepBy1 :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy1' p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy1'` (char ',')
--   </pre>
sepBy1' :: MonadPlus m => m a -> m s -> m [a]

-- | Skip zero or more instances of an action.
skipMany :: Alternative f => f a -> f ()

-- | Skip one or more instances of an action.
skipMany1 :: Alternative f => f a -> f ()

-- | Combine two alternatives.
eitherP :: Alternative f => f a -> f b -> f (Either a b)

-- | If a parser has returned a <a>Partial</a> result, supply it with more
--   input.
feed :: Monoid i => IResult i r -> i -> IResult i r

-- | Match only if all input has been consumed.
endOfInput :: MonoidNull t => Parser t ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: MonoidNull t => Parser t Bool

-- | Apply a parser without consuming any input.
lookAhead :: Monoid i => Parser i a -> Parser i a

-- | Apply a parser without consuming any input, and succeed if and only if
--   the parser fails.
notFollowedBy :: (Monoid i, Show a) => Parser i a -> Parser i ()


-- | Simple, efficient combinator parsing for <a>LeftGCDMonoid</a> and
--   <a>FactorialMonoid</a> inputs, loosely based on Parsec and derived
--   from Attoparsec.
module Data.Picoparsec

-- | The core parser type. This is parameterised over the type <tt>t</tt>
--   of string being processed.
--   
--   This type is an instance of the following classes:
--   
--   <ul>
--   <li><a>Monad</a>, where <a>fail</a> throws an exception (i.e. fails)
--   with an error message.</li>
--   <li><a>Functor</a> and <a>Applicative</a>, which follow the usual
--   definitions.</li>
--   <li><a>MonadPlus</a>, where <a>mzero</a> fails (with no error message)
--   and <a>mplus</a> executes the right-hand parser if the left-hand one
--   fails. When the parser on the right executes, the input is reset to
--   the same state as the parser on the left started with. (In other
--   words, Picoparsec is a backtracking parser that supports arbitrary
--   lookahead.)</li>
--   <li><a>Alternative</a>, which follows <a>MonadPlus</a>.</li>
--   </ul>
data Parser t a
type Result = IResult

-- | The result of a parse. This is parameterised over the type <tt>t</tt>
--   of string that was processed.
--   
--   This type is an instance of <a>Functor</a>, where <a>fmap</a>
--   transforms the value in a <a>Done</a> result.
data IResult i r

-- | The parse failed. The <tt>i</tt> parameter is the input that had not
--   yet been consumed when the failure occurred. The
--   <tt>[</tt><a>String</a><tt>]</tt> is a list of contexts in which the
--   error occurred. The <a>String</a> is the message describing the error,
--   if any.
Fail :: i -> [String] -> String -> IResult i r

-- | Supply this continuation with more input so that the parser can
--   resume. To indicate that no more input is available, pass an empty
--   string to the continuation.
--   
--   <b>Note</b>: if you get a <a>Partial</a> result, do not call its
--   continuation more than once.
Partial :: (i -> IResult i r) -> IResult i r

-- | The parse succeeded. The <tt>i</tt> parameter is the input that had
--   not yet been consumed (if any) when the parse succeeded.
Done :: i -> r -> IResult i r

-- | Compare two <a>IResult</a> values for equality.
--   
--   If both <a>IResult</a>s are <a>Partial</a>, the result will be
--   <a>Nothing</a>, as they are incomplete and hence their equality cannot
--   be known. (This is why there is no <a>Eq</a> instance for
--   <a>IResult</a>.)
compareResults :: (Eq i, Eq r) => IResult i r -> IResult i r -> Maybe Bool

-- | Run a parser.
parse :: Monoid t => Parser t a -> t -> IResult t a

-- | If a parser has returned a <a>Partial</a> result, supply it with more
--   input.
feed :: Monoid i => IResult i r -> i -> IResult i r

-- | Run a parser that cannot be resupplied via a <a>Partial</a> result.
parseOnly :: Monoid t => Parser t a -> t -> Either String a

-- | Run a parser with an initial input string, and a monadic action that
--   can supply more input if needed.
parseWith :: (Monoid t, Monad m) => m t -> Parser t a -> t -> m (Result t a)

-- | Run a parser and print its result to standard output.
parseTest :: (Monoid t, Show t, Show a) => Parser t a -> t -> IO ()

-- | Convert a <a>Result</a> value to a <a>Maybe</a> value. A
--   <a>Partial</a> result is treated as failure.
maybeResult :: Result t r -> Maybe r

-- | Convert a <a>Result</a> value to an <a>Either</a> value. A
--   <a>Partial</a> result is treated as failure.
eitherResult :: Result t r -> Either String r

-- | Match any prime input token.
anyToken :: FactorialMonoid t => Parser t t

-- | Match any prime input token except the given one.
notToken :: (Eq t, FactorialMonoid t) => t -> Parser t t

-- | Match any prime input token. Returns <a>mempty</a> if end of input has
--   been reached. Does not consume any input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
peekToken :: FactorialMonoid t => Parser t t

-- | The parser <tt>satisfy p</tt> succeeds for any prime input token for
--   which the predicate <tt>p</tt> returns <a>True</a>. Returns the token
--   that is actually parsed.
--   
--   <pre>
--   digit = satisfy isDigit
--       where isDigit w = w &gt;= "0" &amp;&amp; w &lt;= "9"
--   </pre>
satisfy :: FactorialMonoid t => (t -> Bool) -> Parser t t

-- | The parser <tt>satisfyWith f p</tt> transforms an input token, and
--   succeeds if the predicate <tt>p</tt> returns <a>True</a> on the
--   transformed value. The parser returns the transformed token that was
--   parsed.
satisfyWith :: FactorialMonoid t => (t -> a) -> (a -> Bool) -> Parser t a

-- | The parser <tt>skip p</tt> succeeds for any prime input token for
--   which the predicate <tt>p</tt> returns <a>True</a>.
--   
--   <pre>
--   skipDigit = skip isDigit
--       where isDigit w = w &gt;= "0" &amp;&amp; w &lt;= "9"
--   </pre>
skip :: FactorialMonoid t => (t -> Bool) -> Parser t ()

-- | Match any character.
anyChar :: TextualMonoid t => Parser t Char

-- | Match a specific character.
char :: TextualMonoid t => Char -> Parser t Char

-- | Match any character except the given one.
notChar :: TextualMonoid t => Char -> Parser t Char

-- | Match any input character, if available. Does not consume any input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
peekChar :: TextualMonoid t => Parser t (Maybe Char)

-- | Match any input character, failing if the input doesn't start with
--   any. Does not consume any input.
peekChar' :: TextualMonoid t => Parser t Char

-- | The parser <tt>satisfyChar p</tt> succeeds for any input character for
--   which the predicate <tt>p</tt> returns <a>True</a>. Returns the
--   character that is actually parsed.
--   
--   <pre>
--   digit = satisfyChar isDigit
--       where isDigit w = w &gt;= '0' &amp;&amp; w &lt;= '9'
--   </pre>
satisfyChar :: TextualMonoid t => (Char -> Bool) -> Parser t Char

-- | The parser <tt>satisfyCharInput p</tt> succeeds for any input
--   character for which the predicate <tt>p</tt> returns <a>True</a>.
--   Returns the parsed input token representing the character.
--   <tt>satisfyCharInput p</tt> is a faster version of <tt>singleton
--   <a>$</a> satisfyChar p</tt> and of <tt>satisfy (fromMaybe False p .
--   characterPrefix)</tt>.
satisfyCharInput :: TextualMonoid t => (Char -> Bool) -> Parser t t

-- | A stateful scanner. The predicate consumes and transforms a state
--   argument, and each transformed state is passed to successive
--   invocations of the predicate on each token of the input until one
--   returns <a>Nothing</a> or the input ends.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>Nothing</a> on the first prime input factor.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
scan :: FactorialMonoid t => s -> (s -> t -> Maybe s) -> Parser t t

-- | <tt>string s</tt> parses a prefix of input that identically matches
--   <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>). This parser
--   consumes no input if it fails (even if a partial match).
--   
--   <i>Note</i>: The behaviour of this parser is different to that of the
--   similarly-named parser in Parsec, as this one is all-or-nothing. To
--   illustrate the difference, the following parser will fail under Parsec
--   given an input of <tt>"for"</tt>:
--   
--   <pre>
--   string "foo" &lt;|&gt; string "for"
--   </pre>
--   
--   The reason for its failure is that the first branch is a partial
--   match, and will consume the letters <tt>'f'</tt> and <tt>'o'</tt>
--   before failing. In Attoparsec, the above parser will <i>succeed</i> on
--   that input, because the failed first branch will consume nothing.
string :: (LeftGCDMonoid t, MonoidNull t) => t -> Parser t t

-- | Skip past input for as long as the predicate returns <a>True</a>.
skipWhile :: FactorialMonoid t => (t -> Bool) -> Parser t ()

-- | Consume exactly <tt>n</tt> prime input tokens.
take :: FactorialMonoid t => Int -> Parser t t

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>False</a> on the first input token.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeWhile :: FactorialMonoid t => (t -> Bool) -> Parser t t

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser requires the predicate to succeed on at least one input
--   token: it will fail if the predicate never returns <a>True</a> or if
--   there is no input left.
takeWhile1 :: FactorialMonoid t => (t -> Bool) -> Parser t t

-- | Consume input as long as the predicate returns <a>False</a> (i.e.
--   until it returns <a>True</a>), and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first input token.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeTill :: FactorialMonoid t => (t -> Bool) -> Parser t t

-- | A stateful scanner. The predicate consumes and transforms a state
--   argument, and each transformed state is passed to successive
--   invocations of the predicate on each token of the input until one
--   returns <a>Nothing</a> or the input ends.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>Nothing</a> on the first prime input factor.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
scanChars :: TextualMonoid t => s -> (s -> Char -> Maybe s) -> Parser t t

-- | Skip past input characters for as long as the predicate returns
--   <a>True</a>.
skipCharsWhile :: TextualMonoid t => (Char -> Bool) -> Parser t ()

-- | Consume input characters as long as the predicate returns <a>True</a>,
--   and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>False</a> on the first input token.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeCharsWhile :: TextualMonoid t => (Char -> Bool) -> Parser t t
takeCharsWhile1 :: TextualMonoid t => (Char -> Bool) -> Parser t t

-- | Consume input characters as long as the predicate returns <a>False</a>
--   (i.e. until it returns <a>True</a>), and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first input token.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeCharsTill :: TextualMonoid t => (Char -> Bool) -> Parser t t

-- | Consume all input until the character for which the predicate returns
--   <a>True</a> and return the consumed input.
--   
--   The only difference between <a>takeCharsTill</a> and
--   <a>takeTillChar</a> is in their handling of non-character data: The
--   former never consumes it, the latter always does.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first input token.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeTillChar :: TextualMonoid t => (Char -> Bool) -> Parser t t

-- | Consume all input until the character for which the predicate returns
--   <a>True</a> and return the consumed input.
--   
--   This parser always consumes at least one token: it will fail if the
--   input starts with a character for which the predicate returns
--   <a>True</a> or if there is no input left.
takeTillChar1 :: TextualMonoid t => (Char -> Bool) -> Parser t t

-- | Consume all remaining input and return it as a single string.
takeRest :: MonoidNull t => Parser t t

-- | Match either a single newline character <tt>'\n'</tt>, or a carriage
--   return followed by a newline character <tt>"\r\n"</tt>.
endOfLine :: (Eq t, TextualMonoid t) => Parser t ()

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   This combinator is provided for compatibility with Parsec. Picoparsec
--   parsers always backtrack on failure.
try :: Parser i a -> Parser i a

-- | Name the parser, in case failure occurs.
(<?>) :: Parser i a -> String -> Parser i a

-- | <tt>choice ps</tt> tries to apply the actions in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding action.
choice :: Alternative f => [f a] -> f a

-- | Apply the given action repeatedly, returning every result.
count :: Monad m => Int -> m a -> m [a]

-- | <tt>option x p</tt> tries to apply action <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative f => a -> f a -> f a

-- | <tt>many' p</tt> applies the action <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many' letter
--   </pre>
many' :: MonadPlus m => m a -> m [a]

-- | <tt>many1 p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Alternative f => f a -> f [a]

-- | <tt>many1' p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many1' letter
--   </pre>
many1' :: MonadPlus m => m a -> m [a]

-- | <tt>manyTill p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
manyTill :: Alternative f => f a -> f b -> f [a]

-- | <tt>manyTill' p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill' anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
--   
--   The value returned by <tt>p</tt> is forced to WHNF.
manyTill' :: MonadPlus m => m a -> m b -> m [a]

-- | <tt>sepBy p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (char ',')
--   </pre>
sepBy :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy' p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy'` (char ',')
--   </pre>
sepBy' :: MonadPlus m => m a -> m s -> m [a]

-- | <tt>sepBy1 p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy1` (char ',')
--   </pre>
sepBy1 :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy1' p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy1'` (char ',')
--   </pre>
sepBy1' :: MonadPlus m => m a -> m s -> m [a]

-- | Skip zero or more instances of an action.
skipMany :: Alternative f => f a -> f ()

-- | Skip one or more instances of an action.
skipMany1 :: Alternative f => f a -> f ()

-- | Combine two alternatives.
eitherP :: Alternative f => f a -> f b -> f (Either a b)

-- | Match only if all input has been consumed.
endOfInput :: MonoidNull t => Parser t ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: MonoidNull t => Parser t Bool


-- | This module is deprecated, and both the module and <a>Number</a> type
--   will be removed in the next major release. Use the <a>scientific</a>
--   package and the <a>Scientific</a> type instead.
--   
--   A simple number type, useful for parsing both exact and inexact
--   quantities without losing much precision.
module Data.Picoparsec.Number

-- | A numeric type that can represent integers accurately, and floating
--   point numbers to the precision of a <a>Double</a>.
data Number
I :: !Integer -> Number
D :: {-# UNPACK #-} !Double -> Number

-- | Parse and decode an unsigned decimal number.
decimal :: (TextualMonoid t, Integral a) => Parser t a

-- | Parse and decode an unsigned hexadecimal number. The hex digits
--   <tt>'a'</tt> through <tt>'f'</tt> may be upper or lower case.
--   
--   This parser does not accept a leading <tt>"0x"</tt> string.
hexadecimal :: (TextualMonoid t, Integral a, Bits a) => Parser t a

-- | Parse a number with an optional leading <tt>'+'</tt> or <tt>'-'</tt>
--   sign character.
signed :: (TextualMonoid t, Num a) => Parser t a -> Parser t a

-- | Parse a rational number.
--   
--   The syntax accepted by this parser is the same as for <a>rational</a>.
--   
--   <i>Note</i>: This function is almost ten times faster than
--   <a>rational</a>, but is slightly less accurate.
--   
--   The <a>Double</a> type supports about 16 decimal places of accuracy.
--   For 94.2% of numbers, this function and <a>rational</a> give identical
--   results, but for the remaining 5.8%, this function loses precision
--   around the 15th decimal place. For 0.001% of numbers, this function
--   will lose precision at the 13th or 14th decimal place.
--   
--   This function does not accept string representations of "NaN" or
--   "Infinity".
double :: TextualMonoid t => Parser t Double

-- | Parse a number, attempting to preserve both speed and precision.
--   
--   The syntax accepted by this parser is the same as for <a>rational</a>.
--   
--   <i>Note</i>: This function is almost ten times faster than
--   <a>rational</a>. On integral inputs, it gives perfectly accurate
--   answers, and on floating point inputs, it is slightly less accurate
--   than <a>rational</a>.
--   
--   This function does not accept string representations of "NaN" or "
number :: TextualMonoid t => Parser t Number

-- | Parse a rational number.
--   
--   This parser accepts an optional leading sign character, followed by at
--   least one decimal digit. The syntax similar to that accepted by the
--   <a>read</a> function, with the exception that a trailing <tt>'.'</tt>
--   or <tt>'e'</tt> <i>not</i> followed by a number is not consumed.
--   
--   Examples with behaviour identical to <a>read</a>, if you feed an empty
--   continuation to the first result:
--   
--   <pre>
--   rational "3"     == Done 3.0 ""
--   rational "3.1"   == Done 3.1 ""
--   rational "3e4"   == Done 30000.0 ""
--   rational "3.1e4" == Done 31000.0, ""
--   </pre>
--   
--   Examples with behaviour identical to <a>read</a>:
--   
--   <pre>
--   rational ".3"    == Fail "input does not start with a digit"
--   rational "e3"    == Fail "input does not start with a digit"
--   </pre>
--   
--   Examples of differences from <a>read</a>:
--   
--   <pre>
--   rational "3.foo" == Done 3.0 ".foo"
--   rational "3e"    == Done 3.0 "e"
--   </pre>
--   
--   This function does not accept string representations of "NaN" or
--   "Infinity".
rational :: (TextualMonoid t, Fractional a) => Parser t a

-- | Parse a scientific number.
--   
--   The syntax accepted by this parser is the same as for <a>rational</a>.
scientific :: TextualMonoid t => Parser t Scientific
instance Typeable Number
instance Data Number
instance RealFrac Number
instance Fractional Number
instance Real Number
instance Num Number
instance Ord Number
instance Eq Number
instance NFData Number
instance Show Number


-- | This module provides the basic support for parsing state.
--   
--   To support state, the parser input must be a <a>Stateful</a> monoid.
--   The parsing state thus becomes the final part of the input, accessible
--   and modifiable during the parse. Be careful to account for the
--   presence of state before the <a>endOfInput</a>! The following parser,
--   for example, would loop forever:
--   
--   <pre>
--   many (setState "more" *&gt; anyToken)
--   </pre>
module Data.Picoparsec.State

-- | Returns the current user state.
getState :: Parser (Stateful s t) s

-- | Sets the current state.
putState :: s -> Parser (Stateful s t) ()

-- | Modifies the current state.
modifyState :: (s -> s) -> Parser (Stateful s t) ()
