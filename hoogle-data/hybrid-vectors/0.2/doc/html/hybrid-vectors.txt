-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hybrid vectors e.g. Mixed Boxed/Unboxed vectors
--   
@package hybrid-vectors
@version 0.2

module Data.Vector.Hybrid.Internal
data MVector :: (* -> * -> *) -> (* -> * -> *) -> * -> * -> *
MV :: !(u s a) -> !(v s b) -> MVector u v s (a, b)
data Vector :: (* -> *) -> (* -> *) -> * -> *
V :: !(u a) -> !(v b) -> Vector u v (a, b)
instance Typeable MVector
instance Typeable Vector
instance (Vector u a, Vector v b, Ord a, Ord b, c ~ (a, b)) => Ord (Vector u v c)
instance (Vector u a, Vector v b, Eq a, Eq b, c ~ (a, b)) => Eq (Vector u v c)
instance (Data a, Data b, Typeable u, Typeable v, Vector u a, Vector v b, c ~ (a, b)) => Data (Vector u v c)
instance (Vector u a, Vector v b, Read a, Read b, c ~ (a, b)) => Read (Vector u v c)
instance (Vector u a, Vector v b, Show a, Show b, c ~ (a, b)) => Show (Vector u v c)
instance (Vector u a, Vector v b, c ~ (a, b)) => Monoid (Vector u v c)
instance (Vector u a, Vector v b) => Vector (Vector u v) (a, b)
instance (MVector u a, MVector v b) => MVector (MVector u v) (a, b)

module Data.Vector.Hybrid.Mutable
data MVector :: (* -> * -> *) -> (* -> * -> *) -> * -> * -> *
type IOVector u v = MVector u v RealWorld
type STVector = MVector

-- | Length of the mutable vector.
length :: MVector u a => MVector u v s (a, b) -> Int

-- | Check whether the vector is empty
null :: MVector u a => MVector u v s (a, b) -> Bool

-- | Yield a part of the mutable vector without copying it.
slice :: (MVector u a, MVector v b) => Int -> Int -> MVector u v s (a, b) -> MVector u v s (a, b)
init :: (MVector u a, MVector v b) => MVector u v s (a, b) -> MVector u v s (a, b)
tail :: (MVector u a, MVector v b) => MVector u v s (a, b) -> MVector u v s (a, b)
take :: (MVector u a, MVector v b) => Int -> MVector u v s (a, b) -> MVector u v s (a, b)
drop :: (MVector u a, MVector v b) => Int -> MVector u v s (a, b) -> MVector u v s (a, b)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: (MVector u a, MVector v b) => Int -> Int -> MVector u v s (a, b) -> MVector u v s (a, b)
unsafeInit :: (MVector u a, MVector v b) => MVector u v s (a, b) -> MVector u v s (a, b)
unsafeTail :: (MVector u a, MVector v b) => MVector u v s (a, b) -> MVector u v s (a, b)
unsafeTake :: (MVector u a, MVector v b) => Int -> MVector u v s (a, b) -> MVector u v s (a, b)
unsafeDrop :: (MVector u a, MVector v b) => Int -> MVector u v s (a, b) -> MVector u v s (a, b)
overlaps :: (MVector u a, MVector v b) => MVector u v s (a, b) -> MVector u v s (a, b) -> Bool

-- | Create a mutable vector of the given length.
new :: (PrimMonad m, MVector u a, MVector v b) => Int -> m (MVector u v (PrimState m) (a, b))

-- | Create a mutable vector of the given length. The length is not
--   checked.
unsafeNew :: (PrimMonad m, MVector u a, MVector v b) => Int -> m (MVector u v (PrimState m) (a, b))

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: (PrimMonad m, MVector u a, MVector v b) => Int -> (a, b) -> m (MVector u v (PrimState m) (a, b))

-- | Create a copy of a mutable vector.
clone :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> m (MVector u v (PrimState m) (a, b))

-- | Grow a vector by the given number of elements. The number must be
--   positive.
grow :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> Int -> m (MVector u v (PrimState m) (a, b))

-- | Grow a vector by the given number of elements. The number must be
--   positive but this is not checked.
unsafeGrow :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> Int -> m (MVector u v (PrimState m) (a, b))

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors.
clear :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> m ()

-- | Yield the element at the given position.
read :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> Int -> m (a, b)

-- | Replace the element at the given position.
write :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> Int -> (a, b) -> m ()

-- | Swap the elements at the given positions.
swap :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> Int -> Int -> m ()

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> Int -> m (a, b)

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> Int -> (a, b) -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> Int -> Int -> m ()

-- | Set all elements of the vector to the given value.
set :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> (a, b) -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> MVector u v (PrimState m) (a, b) -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap. This is not checked.
unsafeCopy :: (PrimMonad m, MVector u a, MVector v b) => MVector u v (PrimState m) (a, b) -> MVector u v (PrimState m) (a, b) -> m ()

-- | The mutable vectors are assumed to be of the same length and to not
--   overlap. This is not checked.
unsafeZip :: u s a -> v s b -> MVector u v s (a, b)
projectFst :: MVector u v s (a, b) -> u s a
projectSnd :: MVector u v s (a, b) -> v s b

-- | <i>DEPRECATED</i> Use <a>replicate</a> instead

-- | <i>Deprecated: Use replicate instead</i>
newWith :: (PrimMonad m, MVector u a, MVector v b) => Int -> (a, b) -> m (MVector u v (PrimState m) (a, b))

-- | <i>DEPRECATED</i> Use <a>replicate</a> instead

-- | <i>Deprecated: Use replicate instead</i>
unsafeNewWith :: (PrimMonad m, MVector u a, MVector v b) => Int -> (a, b) -> m (MVector u v (PrimState m) (a, b))


-- | A hybrid <a>Vector</a> lets you make a <a>Vector</a> which is
--   'partially unboxed', by making a <a>Vector</a> out of two other
--   <a>Vector</a> types and using each for its corresponding side of a
--   <a>Vector</a> of pairs.
--   
--   This enables you to work with a mixture of boxed and unboxed data when
--   you go to use something <tt>like vector-algorithms</tt>
module Data.Vector.Hybrid
data Vector :: (* -> *) -> (* -> *) -> * -> *
data MVector :: (* -> * -> *) -> (* -> * -> *) -> * -> * -> *

-- | <i>O(1)</i> Yield the length of the vector.
length :: Vector u a => Vector u v (a, b) -> Int

-- | <i>O(1)</i> Test whether a vector if empty
null :: Vector u a => Vector u v (a, b) -> Bool

-- | O(1) Indexing
(!) :: (Vector u a, Vector v b) => Vector u v (a, b) -> Int -> (a, b)

-- | O(1) Safe indexing
(!?) :: (Vector u a, Vector v b) => Vector u v (a, b) -> Int -> Maybe (a, b)

-- | <i>O(1)</i> First element
head :: (Vector u a, Vector v b) => Vector u v (a, b) -> (a, b)

-- | <i>O(1)</i> Last element
last :: (Vector u a, Vector v b) => Vector u v (a, b) -> (a, b)

-- | <i>O(1)</i> Unsafe indexing without bounds checking
unsafeIndex :: (Vector u a, Vector v b) => Vector u v (a, b) -> Int -> (a, b)

-- | <i>O(1)</i> First element without checking if the vector is empty
unsafeHead :: (Vector u a, Vector v b) => Vector u v (a, b) -> (a, b)

-- | <i>O(1)</i> Last element without checking if the vector is empty
unsafeLast :: (Vector u a, Vector v b) => Vector u v (a, b) -> (a, b)

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the elements) is evaluated eagerly.
indexM :: (Vector u a, Vector v b, Monad m) => Vector u v (a, b) -> Int -> m (a, b)

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: (Vector u a, Vector v b, Monad m) => Vector u v (a, b) -> m (a, b)

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: (Vector u a, Vector v b, Monad m) => Vector u v (a, b) -> m (a, b)

-- | <i>O(1)</i> Indexing in a monad without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: (Vector u a, Vector v b, Monad m) => Vector u v (a, b) -> Int -> m (a, b)

-- | <i>O(1)</i> First element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: (Vector u a, Vector v b, Monad m) => Vector u v (a, b) -> m (a, b)

-- | <i>O(1)</i> Last element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: (Vector u a, Vector v b, Monad m) => Vector u v (a, b) -> m (a, b)

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: (Vector u a, Vector v b) => Int -> Int -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: (Vector u a, Vector v b) => Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: (Vector u a, Vector v b) => Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Yield at the first <tt>n</tt> elements without copying.
--   The vector may contain less than <tt>n</tt> elements in which case it
--   is returned unchanged.
take :: (Vector u a, Vector v b) => Int -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements in which
--   case an empty vector is returned.
drop :: (Vector u a, Vector v b) => Int -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt> but slightly more
--   efficient.
splitAt :: (Vector u a, Vector v b) => Int -> Vector u v (a, b) -> (Vector u v (a, b), Vector u v (a, b))

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements but this is not checked.
unsafeSlice :: (Vector u a, Vector v b) => Int -> Int -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty but this is not checked.
unsafeInit :: (Vector u a, Vector v b) => Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty but this is not checked.
unsafeTail :: (Vector u a, Vector v b) => Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements but this is not
--   checked.
unsafeTake :: (Vector u a, Vector v b) => Int -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements but this
--   is not checked.
unsafeDrop :: (Vector u a, Vector v b) => Int -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(1)</i> Empty vector
empty :: (Vector u a, Vector v b) => Vector u v (a, b)

-- | <i>O(1)</i> Vector with exactly one element
singleton :: (Vector u a, Vector v b) => (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Vector of the given length with the same value in each
--   position
replicate :: (Vector u a, Vector v b) => Int -> (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index
generate :: (Vector u a, Vector v b) => Int -> (Int -> (a, b)) -> Vector u v (a, b)

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
iterateN :: (Vector u a, Vector v b) => Int -> ((a, b) -> (a, b)) -> (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: (Monad m, Vector u a, Vector v b) => Int -> m (a, b) -> m (Vector u v (a, b))

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index
generateM :: (Monad m, Vector u a, Vector v b) => Int -> (Int -> m (a, b)) -> m (Vector u v (a, b))

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- new 2; write v 0 'a'; write v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: (Vector u a, Vector v b) => (forall s. ST s (Mutable (Vector u v) s (a, b))) -> Vector u v (a, b)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <a>Just</a> the next
--   element and the new seed or <a>Nothing</a> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: (Vector u a, Vector v b) => (c -> Maybe ((a, b), c)) -> c -> Vector u v (a, b)

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> by repeatedly
--   applying the generator function to the a seed. The generator function
--   yields <a>Just</a> the next element and the new seed or <a>Nothing</a>
--   if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: (Vector u a, Vector v b) => Int -> (c -> Maybe ((a, b), c)) -> c -> Vector u v (a, b)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in f &lt;a,b,c&gt;
--   </pre>
constructN :: (Vector u a, Vector v b) => Int -> (Vector u v (a, b) -> (a, b)) -> Vector u v (a, b)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in f &lt;c,b,a&gt;
--   </pre>
constructrN :: (Vector u a, Vector v b) => Int -> (Vector u v (a, b) -> (a, b)) -> Vector u v (a, b)

-- | <i>O(n)</i> Prepend an element
cons :: (Vector u a, Vector v b) => (a, b) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Append an element
snoc :: (Vector u a, Vector v b) => Vector u v (a, b) -> (a, b) -> Vector u v (a, b)

-- | <i>O(m+n)</i> Concatenate two vectors
(++) :: (Vector u a, Vector v b) => Vector u v (a, b) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Concatenate all vectors in the list
concat :: (Vector u a, Vector v b) => [Vector u v (a, b)] -> Vector u v (a, b)

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: (Vector u a, Vector v b) => Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: (Vector u a, Vector v b) => Vector u v (a, b) -> [(Int, (a, b))] -> Vector u v (a, b)

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: (Vector u a, Vector v b) => Vector u v (a, b) -> [(Int, (a, b))] -> Vector u v (a, b)

-- | <i>O(m+n)</i> For each pair <tt>(i,c)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a c</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: (Vector u a, Vector v b) => ((a, b) -> c -> (a, b)) -> Vector u v (a, b) -> [(Int, c)] -> Vector u v (a, b)

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: (Vector u a, Vector v b) => ((a, b) -> c -> (a, b)) -> Vector u v (a, b) -> [(Int, c)] -> Vector u v (a, b)

-- | <i>O(n)</i> Reverse a vector
reverse :: (Vector u a, Vector v b) => Vector u v (a, b) -> Vector u v (a, b)

-- | Apply a destructive operation to a vector. The operation will be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise.
--   
--   <pre>
--   modify (\v -&gt; write v 0 'x') (<a>replicate</a> 3 'a') = &lt;'x','a','a'&gt;
--   </pre>
modify :: (Vector u a, Vector v b) => (forall s. Mutable (Vector u v) s (a, b) -> ST s ()) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Map a function over a vector
map :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d)) -> Vector u v (a, b) -> Vector u v (c, d)

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index
imap :: (Vector u a, Vector v b, Vector u c, Vector v d) => (Int -> (a, b) -> (c, d)) -> Vector u v (a, b) -> Vector u v (c, d)

-- | Map a function over a vector and concatenate the results.
concatMap :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> Vector u v (c, d)) -> Vector u v (a, b) -> Vector u v (c, d)

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results
mapM :: (Monad m, Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> m (c, d)) -> Vector u v (a, b) -> m (Vector u v (c, d))

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results
mapM_ :: (Monad m, Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> m (c, d)) -> Vector u v (a, b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equvalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Vector u a, Vector v b, Vector u c, Vector v d) => Vector u v (a, b) -> ((a, b) -> m (c, d)) -> m (Vector u v (c, d))

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Vector u a, Vector v b, Vector u c, Vector v d) => Vector u v (a, b) -> ((a, b) -> m (c, d)) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c') => ((a, a') -> (b, b') -> (c, c')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c')

-- | Zip three vectors with the given function.
zipWith3 :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c', Vector u d, Vector v d') => ((a, a') -> (b, b') -> (c, c') -> (d, d')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c') -> Vector u v (d, d')
zipWith4 :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c', Vector u d, Vector v d', Vector u e, Vector v e') => ((a, a') -> (b, b') -> (c, c') -> (d, d') -> (e, e')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c') -> Vector u v (d, d') -> Vector u v (e, e')
zipWith5 :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c', Vector u d, Vector v d', Vector u e, Vector v e', Vector u f, Vector v f') => ((a, a') -> (b, b') -> (c, c') -> (d, d') -> (e, e') -> (f, f')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c') -> Vector u v (d, d') -> Vector u v (e, e') -> Vector u v (f, f')
zipWith6 :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c', Vector u d, Vector v d', Vector u e, Vector v e', Vector u f, Vector v f', Vector u g, Vector v g') => ((a, a') -> (b, b') -> (c, c') -> (d, d') -> (e, e') -> (f, f') -> (g, g')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c') -> Vector u v (d, d') -> Vector u v (e, e') -> Vector u v (f, f') -> Vector u v (g, g')

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c') => (Int -> (a, a') -> (b, b') -> (c, c')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c')

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c', Vector u d, Vector v d') => (Int -> (a, a') -> (b, b') -> (c, c') -> (d, d')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c') -> Vector u v (d, d')
izipWith4 :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c', Vector u d, Vector v d', Vector u e, Vector v e') => (Int -> (a, a') -> (b, b') -> (c, c') -> (d, d') -> (e, e')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c') -> Vector u v (d, d') -> Vector u v (e, e')
izipWith5 :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c', Vector u d, Vector v d', Vector u e, Vector v e', Vector u f, Vector v f') => (Int -> (a, a') -> (b, b') -> (c, c') -> (d, d') -> (e, e') -> (f, f')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c') -> Vector u v (d, d') -> Vector u v (e, e') -> Vector u v (f, f')
izipWith6 :: (Vector u a, Vector v a', Vector u b, Vector v b', Vector u c, Vector v c', Vector u d, Vector v d', Vector u e, Vector v e', Vector u f, Vector v f', Vector u g, Vector v g') => (Int -> (a, a') -> (b, b') -> (c, c') -> (d, d') -> (e, e') -> (f, f') -> (g, g')) -> Vector u v (a, a') -> Vector u v (b, b') -> Vector u v (c, c') -> Vector u v (d, d') -> Vector u v (e, e') -> Vector u v (f, f') -> Vector u v (g, g')

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results
zipWithM :: (Monad m, Vector u a, Vector v b, Vector u c, Vector v d, Vector u e, Vector v f) => ((a, b) -> (c, d) -> m (e, f)) -> Vector u v (a, b) -> Vector u v (c, d) -> m (Vector u v (e, f))

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results
zipWithM_ :: (Monad m, Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> m e) -> Vector u v (a, b) -> Vector u v (c, d) -> m ()

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate
filter :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate which is
--   applied to values and their indices
ifilter :: (Vector u a, Vector v b) => (Int -> (a, b) -> Bool) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate
filterM :: (Monad m, Vector u a, Vector v b) => ((a, b) -> m Bool) -> Vector u v (a, b) -> m (Vector u v (a, b))

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate without copying.
takeWhile :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> (Vector u v (a, b), Vector u v (a, b))

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> (Vector u v (a, b), Vector u v (a, b))

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> (Vector u v (a, b), Vector u v (a, b))

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> (Vector u v (a, b), Vector u v (a, b))

-- | <i>O(n)</i> Check if the vector contains an element
elem :: (Vector u a, Vector v b, Eq a, Eq b) => (a, b) -> Vector u v (a, b) -> Bool

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>)
notElem :: (Vector u a, Vector v b, Eq a, Eq b) => (a, b) -> Vector u v (a, b) -> Bool

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> Maybe (a, b)

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> Maybe Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: (Vector u a, Vector v b, Eq a, Eq b) => (a, b) -> Vector u v (a, b) -> Maybe Int

-- | <i>O(n)</i> Left fold
foldl :: (Vector u a, Vector v b) => (r -> (a, b) -> r) -> r -> Vector u v (a, b) -> r

-- | <i>O(n)</i> Left fold on non-empty vectors
foldl1 :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> (a, b)) -> Vector u v (a, b) -> (a, b)

-- | <i>O(n)</i> Left fold with strict accumulator
foldl' :: (Vector u a, Vector v b) => (r -> (a, b) -> r) -> r -> Vector u v (a, b) -> r

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator
foldl1' :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> (a, b)) -> Vector u v (a, b) -> (a, b)

-- | <i>O(n)</i> Right fold
foldr :: (Vector u a, Vector v b) => ((a, b) -> r -> r) -> r -> Vector u v (a, b) -> r

-- | <i>O(n)</i> Right fold on non-empty vectors
foldr1 :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> (a, b)) -> Vector u v (a, b) -> (a, b)

-- | <i>O(n)</i> Right fold with a strict accumulator
foldr' :: (Vector u a, Vector v b) => ((a, b) -> r -> r) -> r -> Vector u v (a, b) -> r

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator
foldr1' :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> (a, b)) -> Vector u v (a, b) -> (a, b)

-- | <i>O(n)</i> Left fold (function applied to each element and its index)
ifoldl :: (Vector u a, Vector v b) => (r -> Int -> (a, b) -> r) -> r -> Vector u v (a, b) -> r

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index)
ifoldl' :: (Vector u a, Vector v b) => (r -> Int -> (a, b) -> r) -> r -> Vector u v (a, b) -> r

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index)
ifoldr :: (Vector u a, Vector v b) => (Int -> (a, b) -> r -> r) -> r -> Vector u v (a, b) -> r

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index)
ifoldr' :: (Vector u a, Vector v b) => (Int -> (a, b) -> r -> r) -> r -> Vector u v (a, b) -> r

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: (Vector u a, Vector v b) => ((a, b) -> Bool) -> Vector u v (a, b) -> Bool

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty.
maximum :: (Vector u a, Vector v b, Ord a, Ord b) => Vector u v (a, b) -> (a, b)

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty.
maximumBy :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> Ordering) -> Vector u v (a, b) -> (a, b)

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty.
minimum :: (Vector u a, Vector v b, Ord a, Ord b) => Vector u v (a, b) -> (a, b)

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty.
minimumBy :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> Ordering) -> Vector u v (a, b) -> (a, b)

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: (Vector u a, Vector v b, Ord a, Ord b) => Vector u v (a, b) -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
minIndexBy :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> Ordering) -> Vector u v (a, b) -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: (Vector u a, Vector v b, Ord a, Ord b) => Vector u v (a, b) -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
maxIndexBy :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> Ordering) -> Vector u v (a, b) -> Int

-- | <i>O(n)</i> Monadic fold
foldM :: (Monad m, Vector u a, Vector v b) => (r -> (a, b) -> m r) -> r -> Vector u v (a, b) -> m r

-- | <i>O(n)</i> Monadic fold with strict accumulator
foldM' :: (Monad m, Vector u a, Vector v b) => (r -> (a, b) -> m r) -> r -> Vector u v (a, b) -> m r

-- | <i>O(n)</i> Monadic fold over non-empty vectors
fold1M :: (Monad m, Vector u a, Vector v b) => ((a, b) -> (a, b) -> m (a, b)) -> Vector u v (a, b) -> m (a, b)

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator
fold1M' :: (Monad m, Vector u a, Vector v b) => ((a, b) -> (a, b) -> m (a, b)) -> Vector u v (a, b) -> m (a, b)

-- | <i>O(n)</i> Monadic fold that discards the result
foldM_ :: (Monad m, Vector u a, Vector v b) => (r -> (a, b) -> m r) -> r -> Vector u v (a, b) -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result
foldM'_ :: (Monad m, Vector u a, Vector v b) => (r -> (a, b) -> m r) -> r -> Vector u v (a, b) -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result
fold1M_ :: (Monad m, Vector u a, Vector v b) => ((a, b) -> (a, b) -> m (a, b)) -> Vector u v (a, b) -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator that discards the result
fold1M'_ :: (Monad m, Vector u a, Vector v b) => ((a, b) -> (a, b) -> m (a, b)) -> Vector u v (a, b) -> m ()

-- | <i>O(n)</i> Prescan
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (a, b)) -> (a, b) -> Vector u v (c, d) -> Vector u v (a, b)

-- | <i>O(n)</i> Prescan with strict accumulator
prescanl' :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (a, b)) -> (a, b) -> Vector u v (c, d) -> Vector u v (a, b)

-- | <i>O(n)</i> Scan
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>postscanl (+) 0 &lt;1,2,3,4&gt; = &lt;1,3,6,10&gt;</tt>
postscanl :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (a, b)) -> (a, b) -> Vector u v (c, d) -> Vector u v (a, b)

-- | <i>O(n)</i> Scan with strict accumulator
postscanl' :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (a, b)) -> (a, b) -> Vector u v (c, d) -> Vector u v (a, b)

-- | <i>O(n)</i> Haskell-style scan
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   Example: <tt>scanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6,10&gt;</tt>
scanl :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (a, b)) -> (a, b) -> Vector u v (c, d) -> Vector u v (a, b)

-- | <i>O(n)</i> Haskell-style scan with strict accumulator
scanl' :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (a, b)) -> (a, b) -> Vector u v (c, d) -> Vector u v (a, b)

-- | <i>O(n)</i> Scan over a non-empty vector
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
scanl1 :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> (a, b)) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator
scanl1' :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> (a, b)) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Right-to-left prescan
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (c, d)) -> (c, d) -> Vector u v (a, b) -> Vector u v (c, d)

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator
prescanr' :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (c, d)) -> (c, d) -> Vector u v (a, b) -> Vector u v (c, d)

-- | <i>O(n)</i> Right-to-left scan
postscanr :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (c, d)) -> (c, d) -> Vector u v (a, b) -> Vector u v (c, d)

-- | <i>O(n)</i> Right-to-left scan with strict accumulator
postscanr' :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (c, d)) -> (c, d) -> Vector u v (a, b) -> Vector u v (c, d)

-- | <i>O(n)</i> Right-to-left Haskell-style scan
scanr :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (c, d)) -> (c, d) -> Vector u v (a, b) -> Vector u v (c, d)

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator
scanr' :: (Vector u a, Vector v b, Vector u c, Vector v d) => ((a, b) -> (c, d) -> (c, d)) -> (c, d) -> Vector u v (a, b) -> Vector u v (c, d)

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector
scanr1 :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> (a, b)) -> Vector u v (a, b) -> Vector u v (a, b)

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator
scanr1' :: (Vector u a, Vector v b) => ((a, b) -> (a, b) -> (a, b)) -> Vector u v (a, b) -> Vector u v (a, b)
projectFst :: Vector u v (a, b) -> u a
projectSnd :: Vector u v (a, b) -> v b

-- | Warning: The vectors are assumed to have the same length. This is not
--   checked!
unsafeZip :: u a -> v b -> Vector u v (a, b)

-- | <i>O(n)</i> Convert a vector to a list
toList :: (Vector u a, Vector v b) => Vector u v (a, b) -> [(a, b)]

-- | <i>O(n)</i> Convert a list to a vector
fromList :: (Vector u a, Vector v b) => [(a, b)] -> Vector u v (a, b)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
fromListN :: (Vector u a, Vector v b) => Int -> [(a, b)] -> Vector u v (a, b)

-- | <i>O(n)</i> Convert different vector types
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: (Vector u a, Vector v b, PrimMonad m) => Mutable (Vector u v) (PrimState m) (a, b) -> m (Vector u v (a, b))

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: (Vector u a, Vector v b, PrimMonad m) => Vector u v (a, b) -> m (Mutable (Vector u v) (PrimState m) (a, b))

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: (Vector u a, Vector v b, PrimMonad m) => Mutable (Vector u v) (PrimState m) (a, b) -> Vector u v (a, b) -> m ()

-- | <i>O(1)</i> Unsafe convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: (Vector u a, Vector v b, PrimMonad m) => Mutable (Vector u v) (PrimState m) (a, b) -> m (Vector u v (a, b))

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: (Vector u a, Vector v b, PrimMonad m) => Vector u v (a, b) -> m (Mutable (Vector u v) (PrimState m) (a, b))

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: (Vector u a, Vector v b, PrimMonad m) => Mutable (Vector u v) (PrimState m) (a, b) -> Vector u v (a, b) -> m ()
