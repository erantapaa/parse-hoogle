-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A pagination approach for yesod
--   
--   Paginate a list showing a per-item widget and links to other pages
@package yesod-paginator
@version 0.9

module Yesod.Paginator.Widget

-- | looks up the "p" GET param and converts it to an Int. returns a
--   default of 1 when conversion fails.
getCurrentPage :: Yesod m => HandlerT m IO Int

-- | A widget showing pagination links. Follows bootstrap principles.
--   Utilizes a "p" GET param but leaves all other GET params intact.
paginationWidget :: Yesod m => PageWidgetConfig -> PageWidget m
defaultWidget :: Yesod m => PageWidget m

-- | Default widget config provided for easy overriding of only some
--   fields.
defaultPageWidgetConfig :: PageWidgetConfig

-- | currentPage, itemsPerPage, totalItems -&gt; widget
type PageWidget m = Int -> Int -> Int -> WidgetT m IO ()
data PageWidgetConfig
PageWidgetConfig :: Text -> Text -> Int -> Bool -> Bool -> [Text] -> PageWidgetConfig

-- | The text for the 'previous page' link.
prevText :: PageWidgetConfig -> Text

-- | The text for the 'next page' link.
nextText :: PageWidgetConfig -> Text

-- | The number of page links to show
pageCount :: PageWidgetConfig -> Int

-- | Whether to list pages in ascending order.
ascending :: PageWidgetConfig -> Bool

-- | Whether to show an ellipsis if there are more pages than pageCount
showEllipsis :: PageWidgetConfig -> Bool

-- | Additional classes for top level list
listClasses :: PageWidgetConfig -> [Text]


-- | Inspiration from a concept by ajdunlap:
--   <a>http://hackage.haskell.org/package/yesod-paginate</a>
--   
--   But uses an entirely different approach.
--   
--   There are two pagination functions. One for arbitrary items where you
--   provide the list of things to be paginated:
--   
--   <pre>
--   getSomeRoute = do
--       things' &lt;- getAllThings
--   
--       (things, widget) &lt;- paginate 10 things'
--   
--       defaultLayout $ do
--           [whamlet|
--               $forall thing &lt;- things
--                   ^{showThing thing}
--   
--               &lt;div .pagination&gt;
--                    ^{widget}
--               |]
--   </pre>
--   
--   And another for paginating directly out of the database, you provide
--   the same filters as you would to <tt>selectList</tt>.
--   
--   <pre>
--   getSomeRoute something = do
--       -- note: things is [Entity val] just like selectList returns
--       (things, widget) &lt;- runDB $ selectPaginated 10 [SomeThing ==. something] []
--   
--       defaultLayout $ do
--           [whamlet|
--               $forall thing &lt;- things
--                   ^{showThing $ entityVal thing}
--   
--               &lt;div .pagination&gt;
--                    ^{widget}
--               |]
--   </pre>
--   
--   Both functions return a tuple: the first element being the list of
--   items (or Entities) to display on this page and the second being a
--   widget showing the pagination navagation links.
module Yesod.Paginator
paginate :: Yesod m => Int -> [a] -> HandlerT m IO ([a], WidgetT m IO ())
paginateWith :: Yesod m => PageWidget m -> Int -> [a] -> HandlerT m IO ([a], WidgetT m IO ())
selectPaginated :: (PersistEntity val, PersistQuery (YesodPersistBackend m (HandlerT m IO)), PersistMonadBackend (YesodPersistBackend m (HandlerT m IO)) ~ PersistEntityBackend val, MonadTrans (YesodPersistBackend m), Yesod m) => Int -> [Filter val] -> [SelectOpt val] -> YesodDB m ([Entity val], WidgetT m IO ())
selectPaginatedWith :: (PersistEntity val, PersistQuery (YesodPersistBackend m (HandlerT m IO)), PersistMonadBackend (YesodPersistBackend m (HandlerT m IO)) ~ PersistEntityBackend val, MonadTrans (YesodPersistBackend m), Yesod m) => PageWidget m -> Int -> [Filter val] -> [SelectOpt val] -> YesodDB m ([Entity val], WidgetT m IO ())
