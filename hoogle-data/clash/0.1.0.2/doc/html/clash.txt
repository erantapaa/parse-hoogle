-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | CAES Language for Synchronous Hardware (CLaSH)
--   
--   CLaSH is a tool-chain/language to translate subsets of Haskell to
--   synthesizable VHDL. It does this by translating the intermediate
--   System Fc (GHC Core) representation to a VHDL AST, which is then
--   written to file.
@package clash
@version 0.1.0.2

module CLasH.Translator.Annotations
data CLasHAnn
TopEntity :: CLasHAnn
InitState :: Name -> CLasHAnn
TestInput :: CLasHAnn
TestCycles :: CLasHAnn
isTopEntity :: CLasHAnn -> Bool
isInitState :: CLasHAnn -> Bool
isTestInput :: CLasHAnn -> Bool
isTestCycles :: CLasHAnn -> Bool
instance Typeable CLasHAnn
instance Show CLasHAnn
instance Data CLasHAnn

module CLasH.Translator

-- | Turn Haskell to VHDL, Using the Annotations for Top Entity, Initial
--   State and Test Inputs found in the Files.
makeVHDLAnnotations :: FilePath -> [FilePath] -> IO ()

module CLasH.HardwareTypes
data (NaturalT s) => Vector s a
empty :: Vector D0 a
(+>) :: a -> Vector s a -> Vector (Succ s) a
singleton :: a -> Vector D1 a
vectorTH :: (Lift a) => [a] -> ExpQ
unsafeVector :: (NaturalT s) => s -> [a] -> Vector s a
readVector :: (Read a, NaturalT s) => String -> Vector s a
length :: (NaturalT s) => Vector s a -> Int
lengthT :: (NaturalT s) => Vector s a -> s
fromVector :: (NaturalT s) => Vector s a -> [a]
null :: Vector D0 a -> Bool
(!) :: (PositiveT s, NaturalT u, (s :>: u) ~ True) => Vector s a -> Index u -> a
replace :: (PositiveT s, NaturalT u, (s :>: u) ~ True) => Vector s a -> Index u -> a -> Vector s a
head :: (PositiveT s) => Vector s a -> a
last :: (PositiveT s) => Vector s a -> a
init :: (PositiveT s) => Vector s a -> Vector (Pred s) a
tail :: (PositiveT s) => Vector s a -> Vector (Pred s) a
take :: (NaturalT i) => i -> Vector s a -> Vector (Min s i) a
drop :: (NaturalT i) => i -> Vector s a -> Vector (s :-: (Min s i)) a
select :: (NaturalT f, NaturalT s, NaturalT n, (f :<: i) ~ True, (((s :*: n) :+: f) :<=: i) ~ True) => f -> s -> n -> Vector i a -> Vector n a
(<+) :: Vector s a -> a -> Vector (Succ s) a
(++) :: Vector s a -> Vector s2 a -> Vector (s :+: s2) a
map :: (a -> b) -> Vector s a -> Vector s b
zipWith :: (a -> b -> c) -> Vector s a -> Vector s b -> Vector s c
foldl :: (a -> b -> a) -> a -> Vector s b -> a
foldr :: (b -> a -> a) -> a -> Vector s b -> a
zip :: Vector s a -> Vector s b -> Vector s (a, b)
unzip :: Vector s (a, b) -> (Vector s a, Vector s b)
shiftl :: (PositiveT s, NaturalT n, n ~ (Pred s), s ~ (Succ n)) => Vector s a -> a -> Vector s a
shiftr :: (PositiveT s, NaturalT n, n ~ (Pred s), s ~ (Succ n)) => Vector s a -> a -> Vector s a
rotl :: (NaturalT s) => Vector s a -> Vector s a
rotr :: (NaturalT s) => Vector s a -> Vector s a
concat :: Vector s1 (Vector s2 a) -> Vector (s1 :*: s2) a
reverse :: Vector s a -> Vector s a
iterate :: (NaturalT s) => (a -> a) -> a -> Vector s a
iteraten :: (NaturalT s) => s -> (a -> a) -> a -> Vector s a
generate :: (NaturalT s) => (a -> a) -> a -> Vector s a
generaten :: (NaturalT s) => s -> (a -> a) -> a -> Vector s a
copy :: (NaturalT s) => a -> Vector s a
copyn :: (NaturalT s) => s -> a -> Vector s a
split :: (NaturalT s) => Vector s a -> (Vector (Div2 s) a, Vector (Div2 s) a)
data (NaturalT upper) => Index upper
fromNaturalT :: (NaturalT n, NaturalT upper, (n :<=: upper) ~ True) => n -> Index upper
fromUnsigned :: (NaturalT nT, Integral (Unsigned nT)) => Unsigned nT -> Index ((Pow2 nT) :-: D1)
rangeT :: Index nT -> nT
data (NaturalT nT) => Signed nT
resize :: (NaturalT nT, NaturalT nT') => Signed nT -> Signed nT'
data (NaturalT nT) => Unsigned nT
resize :: (NaturalT nT, NaturalT nT') => Unsigned nT -> Unsigned nT'
fromIndex :: (NaturalT nT, NaturalT nT', ((Pow2 nT') :>: nT) ~ True, Integral (Index nT)) => Index nT -> Unsigned nT'
data Bit
High :: Bit
Low :: Bit
newtype State s
State :: s -> State s
resizeInt :: (NaturalT nT, NaturalT nT') => Signed nT -> Signed nT'
resizeWord :: (NaturalT nT, NaturalT nT') => Unsigned nT -> Unsigned nT'
hwand :: Bit -> Bit -> Bit
hwor :: Bit -> Bit -> Bit
hwxor :: Bit -> Bit -> Bit
hwnot :: Bit -> Bit
type RAM s a = Vector (s :+: D1) a
type MemState s a = State (RAM s a)
blockRAM :: (NaturalT s, PositiveT (s :+: D1), ((s :+: D1) :>: s) ~ True) => (MemState s a) -> a -> Index s -> Index s -> Bool -> (MemState s a, a)
instance Lift Bit
instance Typeable Bit
instance Show Bit
instance Eq Bit
instance Read Bit
instance (Show s) => Show (State s)
