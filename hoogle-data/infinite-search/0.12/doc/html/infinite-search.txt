-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Exhaustively searchable infinite sets.
--   
--   An implementation of Martin Escardo's exhaustively searchable sets.
@package infinite-search
@version 0.12


-- | An implementation of nonempty searchable (compact and overt) sets,
--   i.e. sets s which admit a total operation <tt>search s :: (a -&gt;
--   Bool) -&gt; Maybe a</tt>.
--   
--   Example usage:
--   
--   <pre>
--   bit = pair True False
--   cantor = sequence (repeat bit)
--   take 5 $ search cantor (\s -&gt; not (s !! 3) &amp;&amp; (s !! 4))
--      -- gives [True, True, True, False, True]
--   </pre>
--   
--   This module is based on the paper "Exhaustible sets in higher-type
--   computation" by Martin Escardo, and is almost identical to the code in
--   his his expository blog post on the subject:
--   <tt>http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/</tt>
module Data.Searchable

-- | <tt>Set a</tt> is a nonempty searchable set of a's. There is no Monoid
--   or MonadPlus instance, since we lack the ability to represent the
--   empty set, which would be the units of those structures.
data Set a

-- | Choose a member of the set satisfying a predicate. If <tt>search s p =
--   Just x</tt> then <tt>p x = True</tt>.
search :: Set a -> (a -> Bool) -> Maybe a

-- | <tt>bigUnion ss</tt> is the union of all the elemens of <tt>ss</tt>.
--   In other words, <tt>x `member` bigUnion ss</tt> iff <tt>forsome ss (s
--   -&gt; x `member` s)</tt>.
bigUnion :: Set (Set a) -> Set a

-- | Tests whether the set contains an element. <tt>contains s x = forsome
--   s (== x)</tt>.
contains :: Eq a => Set a -> a -> Bool

-- | <pre>
--   member = flip contains
--   </pre>
member :: Eq a => a -> Set a -> Bool

-- | <tt>forsome s p</tt> returns True iff there is some element <tt>x</tt>
--   of <tt>s</tt> such that <tt>p x = True</tt>.
forsome :: Set a -> (a -> Bool) -> Bool

-- | <tt>forevery s p</tt> returns True iff every element <tt>x</tt> of
--   <tt>s</tt> satisfies <tt>p x = True</tt>.
forevery :: Set a -> (a -> Bool) -> Bool

-- | <tt>singleton x</tt> is the set <tt>{x}</tt>.
singleton :: a -> Set a

-- | <tt>pair x y</tt> is the set <tt>{x,y}</tt>.
doubleton :: a -> a -> Set a

-- | <tt>x `member` union s t</tt> iff <tt>(x `member` s) || (x `member`
--   t)</tt>.
union :: Set a -> Set a -> Set a
instance Applicative Set
instance Monad Set
instance Functor Set
