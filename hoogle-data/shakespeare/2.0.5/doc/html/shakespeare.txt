-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A toolkit for making compile-time interpolated templates
--   
@package shakespeare
@version 2.0.5


-- | General parsers, functions and datatypes for all Shakespeare
--   languages.
module Text.Shakespeare.Base
data Deref
DerefModulesIdent :: [String] -> Ident -> Deref
DerefIdent :: Ident -> Deref
DerefIntegral :: Integer -> Deref
DerefRational :: Rational -> Deref
DerefString :: String -> Deref
DerefBranch :: Deref -> Deref -> Deref
DerefList :: [Deref] -> Deref
DerefTuple :: [Deref] -> Deref
newtype Ident
Ident :: String -> Ident
type Scope = [(Ident, Exp)]
parseDeref :: UserParser a Deref
parseHash :: UserParser a (Either String Deref)
parseVar :: Char -> UserParser a (Either String Deref)
parseVarString :: Char -> UserParser a (Either String String)
parseAt :: UserParser a (Either String (Deref, Bool))
parseUrl :: Char -> Char -> UserParser a (Either String (Deref, Bool))
parseUrlString :: Char -> Char -> UserParser a (Either String String)
parseCaret :: UserParser a (Either String Deref)
parseUnder :: UserParser a (Either String Deref)
parseInt :: Char -> UserParser a (Either String Deref)
parseIntString :: Char -> UserParser a (Either String String)
derefToExp :: Scope -> Deref -> Exp
flattenDeref :: Deref -> Maybe [String]
readUtf8File :: FilePath -> IO Text
instance Typeable Ident
instance Typeable Deref
instance Show Ident
instance Eq Ident
instance Read Ident
instance Data Ident
instance Ord Ident
instance Show Deref
instance Eq Deref
instance Read Deref
instance Data Deref
instance Ord Deref
instance Lift Deref
instance Lift Ident

module Text.Hamlet
type Html = Markup
shamlet :: QuasiQuoter
shamletFile :: FilePath -> Q Exp
xshamlet :: QuasiQuoter
xshamletFile :: FilePath -> Q Exp

-- | A function generating an <a>Html</a> given a URL-rendering function.
type HtmlUrl url = Render url -> Html
hamlet :: QuasiQuoter
hamletFile :: FilePath -> Q Exp
hamletFileReload :: FilePath -> Q Exp
ihamletFileReload :: FilePath -> Q Exp
xhamlet :: QuasiQuoter
xhamletFile :: FilePath -> Q Exp

-- | A function generating an <a>Html</a> given a message translator and a
--   URL rendering function.
type HtmlUrlI18n msg url = Translate msg -> Render url -> Html
ihamlet :: QuasiQuoter
ihamletFile :: FilePath -> Q Exp

-- | Convert some value to a list of attribute pairs.
class ToAttributes a
toAttributes :: ToAttributes a => a -> [(Text, Text)]

-- | Settings for parsing of a hamlet document.
data HamletSettings
HamletSettings :: String -> NewlineStyle -> (String -> CloseStyle) -> [(String, String)] -> HamletSettings

-- | The value to replace a "!!!" with. Do not include the trailing
--   newline.
hamletDoctype :: HamletSettings -> String

-- | Should we add newlines to the output, making it more human-readable?
--   Useful for client-side debugging but may alter browser page layout.
hamletNewlines :: HamletSettings -> NewlineStyle

-- | How a tag should be closed. Use this to switch between HTML, XHTML or
--   even XML output.
hamletCloseStyle :: HamletSettings -> String -> CloseStyle

-- | Mapping from short names in "$doctype" statements to full doctype.
hamletDoctypeNames :: HamletSettings -> [(String, String)]
data NewlineStyle

-- | never add newlines
NoNewlines :: NewlineStyle

-- | add newlines between consecutive text lines
NewlinesText :: NewlineStyle

-- | add newlines everywhere
AlwaysNewlines :: NewlineStyle
DefaultNewlineStyle :: NewlineStyle
hamletWithSettings :: Q HamletRules -> HamletSettings -> QuasiQuoter
hamletFileWithSettings :: Q HamletRules -> HamletSettings -> FilePath -> Q Exp

-- | Defaults settings: HTML5 doctype and HTML-style empty tags.
defaultHamletSettings :: HamletSettings
xhtmlHamletSettings :: HamletSettings
data Env
Env :: Maybe ((Exp -> Q Exp) -> Q Exp) -> Maybe ((Exp -> Q Exp) -> Q Exp) -> Env
urlRender :: Env -> Maybe ((Exp -> Q Exp) -> Q Exp)
msgRender :: Env -> Maybe ((Exp -> Q Exp) -> Q Exp)
data HamletRules
HamletRules :: Exp -> ((Env -> Q Exp) -> Q Exp) -> (Env -> Exp -> Q Exp) -> HamletRules
hrFromHtml :: HamletRules -> Exp
hrWithEnv :: HamletRules -> (Env -> Q Exp) -> Q Exp
hrEmbed :: HamletRules -> Env -> Exp -> Q Exp
hamletRules :: Q HamletRules
ihamletRules :: Q HamletRules
htmlRules :: Q HamletRules
data CloseStyle
NoClose :: CloseStyle
CloseInside :: CloseStyle
CloseSeparate :: CloseStyle

-- | Checks for truth in the left value in each pair in the first argument.
--   If a true exists, then the corresponding right action is performed.
--   Only the first is performed. In there are no true values, then the
--   second argument is performed, if supplied.
condH :: Monad m => [(Bool, m ())] -> Maybe (m ()) -> m ()

-- | Runs the second argument with the value in the first, if available.
--   Otherwise, runs the third argument, if available.
maybeH :: Monad m => Maybe v -> (v -> m ()) -> Maybe (m ()) -> m ()
asHtmlUrl :: HtmlUrl url -> HtmlUrl url
attrsToHtml :: [(Text, Text)] -> Html
instance Show (VarExp msg url)
instance ToAttributes [(String, String)]
instance ToAttributes [(Text, Text)]
instance ToAttributes (String, String)
instance ToAttributes (Text, Text)


-- | Most everything exported here is exported also by <a>Text.Hamlet</a>.
--   The exceptions to that rule should not be necessary for normal usage.
module Text.Hamlet.RT
newtype HamletRT
HamletRT :: [SimpleDoc] -> HamletRT
data HamletData url
HDHtml :: Html -> HamletData url
HDUrl :: url -> HamletData url
HDUrlParams :: url -> [(Text, Text)] -> HamletData url
HDTemplate :: HamletRT -> HamletData url
HDBool :: Bool -> HamletData url
HDMaybe :: (Maybe (HamletMap url)) -> HamletData url
HDList :: [HamletMap url] -> HamletData url
type HamletMap url = [([String], HamletData url)]
data HamletException
HamletParseException :: String -> HamletException
HamletUnsupportedDocException :: Doc -> HamletException
HamletRenderException :: String -> HamletException
parseHamletRT :: MonadThrow m => HamletSettings -> String -> m HamletRT
renderHamletRT :: MonadThrow m => HamletRT -> HamletMap url -> UrlRenderer url -> m Html
renderHamletRT' :: MonadThrow m => Bool -> HamletRT -> HamletMap url -> (url -> [(Text, Text)] -> Text) -> m Html
data SimpleDoc
SDRaw :: String -> SimpleDoc
SDVar :: [String] -> SimpleDoc
SDUrl :: Bool -> [String] -> SimpleDoc
SDTemplate :: [String] -> SimpleDoc
SDForall :: [String] -> String -> [SimpleDoc] -> SimpleDoc
SDMaybe :: [String] -> String -> [SimpleDoc] -> [SimpleDoc] -> SimpleDoc
SDCond :: [([String], [SimpleDoc])] -> [SimpleDoc] -> SimpleDoc
instance Typeable HamletException
instance Show HamletException
instance Exception HamletException


-- | This module provides a type-based system for providing translations
--   for text strings.
--   
--   It is similar in purpose to gettext or Java message bundles.
--   
--   The core idea is to create simple data type where each constructor
--   represents a phrase, sentence, paragraph, etc. For example:
--   
--   <pre>
--   data AppMessages = Hello | Goodbye
--   </pre>
--   
--   The <a>RenderMessage</a> class is used to retrieve the appropriate
--   translation for a message value:
--   
--   <pre>
--   class RenderMessage master message where
--     renderMessage :: master  -- ^ type that specifies which set of translations to use
--                   -&gt; [Lang]  -- ^ acceptable languages in descending order of preference
--                   -&gt; message -- ^ message to translate
--                   -&gt; Text
--   </pre>
--   
--   Defining the translation type and providing the <a>RenderMessage</a>
--   instance in Haskell is not very translator friendly. Instead,
--   translations are generally provided in external translations files.
--   Then the <a>mkMessage</a> Template Haskell function is used to read
--   the external translation files and automatically create the
--   translation type and the <tt>RenderMessage</tt> instance.
--   
--   A full description of using this module to create translations for
--   <tt>Hamlet</tt> can be found here:
--   
--   <a>http://www.yesodweb.com/book/internationalization</a>
--   
--   A full description of using the module to create translations for
--   <tt>HSP</tt> can be found here:
--   
--   <a>http://happstack.com/docs/crashcourse/Templates.html#hsp-i18n</a>
--   
--   You can also adapt those instructions for use with other systems.
module Text.Shakespeare.I18N

-- | generate translations from translation files
--   
--   This function will:
--   
--   <ol>
--   <li>look in the supplied subdirectory for files ending in
--   <tt>.msg</tt></li>
--   <li>generate a type based on the constructors found</li>
--   <li>create a <a>RenderMessage</a> instance</li>
--   </ol>
mkMessage :: String -> FilePath -> Lang -> Q [Dec]

-- | create <a>RenderMessage</a> instance for an existing data-type
mkMessageFor :: String -> String -> FilePath -> Lang -> Q [Dec]

-- | create an additional set of translations for a type created by
--   <a>mkMessage</a>
mkMessageVariant :: String -> String -> FilePath -> Lang -> Q [Dec]

-- | the <a>RenderMessage</a> is used to provide translations for a message
--   types
--   
--   The <tt>master</tt> argument exists so that it is possible to provide
--   more than one set of translations for a <tt>message</tt> type. This is
--   useful if a library provides a default set of translations, but the
--   user of the library wants to provide a different set of translations.
class RenderMessage master message
renderMessage :: RenderMessage master message => master -> [Lang] -> message -> Text

-- | <a>ToMessage</a> is used to convert the value inside #{ } to
--   <a>Text</a>
--   
--   The primary purpose of this class is to allow the value in #{ } to be
--   a <a>String</a> or <a>Text</a> rather than forcing it to always be
--   <a>Text</a>.
class ToMessage a
toMessage :: ToMessage a => a -> Text
data SomeMessage master
SomeMessage :: msg -> SomeMessage master

-- | an RFC1766 / ISO 639-1 language code (eg, <tt>fr</tt>, <tt>en-GB</tt>,
--   etc).
type Lang = Text
instance master ~ master' => RenderMessage master (SomeMessage master')
instance IsString (SomeMessage master)
instance RenderMessage master Text
instance ToMessage String
instance ToMessage Text


-- | NOTE: This module should be considered internal, and will be hidden in
--   future releases.
module Text.Shakespeare
data ShakespeareSettings
ShakespeareSettings :: Char -> Char -> Char -> Exp -> Exp -> Exp -> Bool -> Maybe PreConvert -> Maybe Exp -> ShakespeareSettings
varChar :: ShakespeareSettings -> Char
urlChar :: ShakespeareSettings -> Char
intChar :: ShakespeareSettings -> Char
toBuilder :: ShakespeareSettings -> Exp
wrap :: ShakespeareSettings -> Exp
unwrap :: ShakespeareSettings -> Exp
justVarInterpolation :: ShakespeareSettings -> Bool
preConversion :: ShakespeareSettings -> Maybe PreConvert

-- | A transformation applied to the final expression. Most often, this
--   would be used to force the type of the expression to help make more
--   meaningful error messages.
modifyFinalValue :: ShakespeareSettings -> Maybe Exp

-- | Coffeescript, TypeScript, and other languages compiles down to
--   Javascript. Previously we waited until the very end, at the rendering
--   stage to perform this compilation. Lets call is a post-conversion This
--   had the advantage that all Haskell values were inserted first: for
--   example a value could be inserted that Coffeescript would compile into
--   Javascript. While that is perhaps a safer approach, the advantage is
--   not used in practice: it was that way mainly for ease of
--   implementation. The down-side is the template must be compiled down to
--   Javascript during every request. If instead we do a pre-conversion to
--   compile down to Javascript, we only need to perform the compilation
--   once.
--   
--   The problem then is the insertion of Haskell values: we need a hole
--   for them. This can be done with variables known to the language.
--   During the pre-conversion we first modify all Haskell insertions So
--   #{a} is change to shakespeare_var_a Then we can place the Haskell
--   values in a function wrapper that exposes those variables:
--   (function(shakespeare_var_a){ ... shakespeare_var_a ...}) TypeScript
--   can compile that, and then we tack an application of the Haskell
--   values onto the result: (#{a})
--   
--   preEscapeIgnoreBalanced is used to not insert backtacks for variable
--   already inside strings or backticks. coffeescript will happily ignore
--   the interpolations, and backticks would not be treated as escaping in
--   that context. preEscapeIgnoreLine was added to ignore comments (which
--   in Coffeescript begin with a '#')
data PreConvert
PreConvert :: PreConversion -> [Char] -> [Char] -> Maybe WrapInsertion -> PreConvert
preConvert :: PreConvert -> PreConversion
preEscapeIgnoreBalanced :: PreConvert -> [Char]
preEscapeIgnoreLine :: PreConvert -> [Char]
wrapInsertion :: PreConvert -> Maybe WrapInsertion
data WrapInsertion
WrapInsertion :: Maybe String -> String -> String -> String -> String -> Bool -> WrapInsertion
wrapInsertionIndent :: WrapInsertion -> Maybe String
wrapInsertionStartBegin :: WrapInsertion -> String
wrapInsertionSeparator :: WrapInsertion -> String
wrapInsertionStartClose :: WrapInsertion -> String
wrapInsertionEnd :: WrapInsertion -> String
wrapInsertionAddParens :: WrapInsertion -> Bool
data PreConversion
ReadProcess :: String -> [String] -> PreConversion
Id :: PreConversion
defaultShakespeareSettings :: ShakespeareSettings
shakespeare :: ShakespeareSettings -> QuasiQuoter
shakespeareFile :: ShakespeareSettings -> FilePath -> Q Exp
shakespeareFileReload :: ShakespeareSettings -> FilePath -> Q Exp
shakespeareFromString :: ShakespeareSettings -> String -> Q Exp

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
shakespeareUsedIdentifiers :: ShakespeareSettings -> String -> [(Deref, VarType)]
type RenderUrl url = url -> QueryParameters -> Text
data VarType
VTPlain :: VarType
VTUrl :: VarType
VTUrlParam :: VarType
VTMixin :: VarType
data Deref

-- | A parser with a user state of [String]
type Parser = Parsec String [String]
preFilter :: Maybe FilePath -> ShakespeareSettings -> String -> IO String
shakespeareRuntime :: ShakespeareSettings -> FilePath -> [(Deref, VarExp url)] -> Shakespeare url
pack' :: String -> Text
instance Typeable VarType
instance Show Content
instance Eq Content
instance Show VarType
instance Eq VarType
instance Ord VarType
instance Enum VarType
instance Bounded VarType
instance Data VarType
instance Generic VarType
instance Datatype D1VarType
instance Constructor C1_0VarType
instance Constructor C1_1VarType
instance Constructor C1_2VarType
instance Constructor C1_3VarType
instance Lift ShakespeareSettings
instance Lift PreConversion
instance Lift WrapInsertion
instance Lift PreConvert

module Text.Shakespeare.Text
type TextUrl url = RenderUrl url -> Builder
class ToText a
toText :: ToText a => a -> Builder
renderTextUrl :: RenderUrl url -> TextUrl url -> Text
stext :: QuasiQuoter
text :: QuasiQuoter
textFile :: FilePath -> Q Exp

-- | <i>Deprecated: Please use textFileReload instead</i>
textFileDebug :: FilePath -> Q Exp
textFileReload :: FilePath -> Q Exp
st :: QuasiQuoter
lt :: QuasiQuoter
sbt :: QuasiQuoter
lbt :: QuasiQuoter

-- | codegen is designed for generating Yesod code, including templates So
--   it uses different interpolation characters that won't clash with
--   templates. You can use the normal text quasiquoters to generate code
codegen :: QuasiQuoter

-- | Generates strict Text codegen is designed for generating Yesod code,
--   including templates So it uses different interpolation characters that
--   won't clash with templates.
codegenSt :: QuasiQuoter
codegenFile :: FilePath -> Q Exp
codegenFileReload :: FilePath -> Q Exp
instance ToText Int
instance ToText Int64
instance ToText Int32
instance ToText Text
instance ToText Text
instance ToText [Char]
instance ToText Builder


-- | A Shakespearean module for Javascript templates, introducing
--   type-safe, compile-time variable and url interpolation.--
--   
--   You might consider trying <a>Typescript</a> or <a>Coffee</a> which
--   compile down to Javascript.
--   
--   Further reading:
--   <a>http://www.yesodweb.com/book/shakespearean-templates</a>
module Text.Julius
js :: QuasiQuoter
julius :: QuasiQuoter
juliusFile :: FilePath -> Q Exp
jsFile :: FilePath -> Q Exp

-- | <i>Deprecated: Please use juliusFileReload instead.</i>
juliusFileDebug :: FilePath -> Q Exp

-- | <i>Deprecated: Please use jsFileReload instead.</i>
jsFileDebug :: FilePath -> Q Exp
juliusFileReload :: FilePath -> Q Exp
jsFileReload :: FilePath -> Q Exp

-- | Return type of template-reading functions.
type JavascriptUrl url = (url -> [(Text, Text)] -> Text) -> Javascript

-- | Newtype wrapper of <a>Builder</a>.
newtype Javascript
Javascript :: Builder -> Javascript
unJavascript :: Javascript -> Builder
newtype RawJavascript
RawJavascript :: Builder -> RawJavascript

-- | A typeclass for types that can be interpolated in CoffeeScript
--   templates.
class ToJavascript a
toJavascript :: ToJavascript a => a -> Javascript
class RawJS a
rawJS :: RawJS a => a -> RawJavascript
renderJavascript :: Javascript -> Text

-- | render with route interpolation. If using this module standalone,
--   apart from type-safe routes, a dummy renderer can be used:
--   
--   <pre>
--   renderJavascriptUrl (\_ _ -&gt; undefined) javascriptUrl
--   </pre>
--   
--   When using Yesod, a renderer is generated for you, which can be
--   accessed within the GHandler monad: <a>getUrlRenderParams</a>.
renderJavascriptUrl :: (url -> [(Text, Text)] -> Text) -> JavascriptUrl url -> Text
javascriptSettings :: Q ShakespeareSettings

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
juliusUsedIdentifiers :: String -> [(Deref, VarType)]
asJavascriptUrl :: JavascriptUrl url -> JavascriptUrl url
instance Monoid Javascript
instance RawJS Bool
instance RawJS Builder
instance RawJS Text
instance RawJS Text
instance RawJS [Char]
instance ToJavascript RawJavascript
instance ToJavascript Value
instance ToJavascript Bool


-- | A Shakespearean module for Roy, introducing type-safe, compile-time
--   variable and url interpolation. It is exactly the same as
--   <a>Text.Julius</a>, except that the template is first compiled to
--   Javascript with the system tool <tt>roy</tt>.
--   
--   To use this module, <tt>roy</tt> must be installed on your system.
--   
--   If you interpolate variables, the template is first wrapped with a
--   function containing javascript variables representing shakespeare
--   variables, then compiled with <tt>roy</tt>, and then the value of the
--   variables are applied to the function. This means that in production
--   the template can be compiled once at compile time and there will be no
--   dependency in your production system on <tt>roy</tt>.
--   
--   Your code:
--   
--   <pre>
--   let b = 1
--   console.log(#{a} + b)
--   </pre>
--   
--   Final Result:
--   
--   <pre>
--   ;(function(shakespeare_var_a){
--     var b = 1;
--     console.log(shakespeare_var_a + b);
--   })(#{a});
--   </pre>
--   
--   Further reading:
--   
--   <ol>
--   <li>Shakespearean templates:
--   <a>http://www.yesodweb.com/book/templates</a></li>
--   <li>Roy: <a>http://roy.brianmckenna.org/</a></li>
--   </ol>
module Text.Roy

-- | Read inline, quasiquoted Roy.
roy :: QuasiQuoter

-- | Read in a Roy template file. This function reads the file once, at
--   compile time.
royFile :: FilePath -> Q Exp

-- | Read in a Roy template file. This impure function uses unsafePerformIO
--   to re-read the file on every call, allowing for rapid iteration.
royFileReload :: FilePath -> Q Exp


-- | A Shakespearean module for CoffeeScript, introducing type-safe,
--   compile-time variable and url interpolation. It is exactly the same as
--   <a>Text.Julius</a>, except that the template is first compiled to
--   Javascript with the system tool <tt>coffee</tt>.
--   
--   To use this module, <tt>coffee</tt> must be installed on your system.
--   
--   <tt>#{...}</tt> is the Shakespearean standard for variable
--   interpolation, but CoffeeScript already uses that sequence for string
--   interpolation. Therefore, Shakespearean interpolation is introduced
--   with <tt>%{...}</tt>.
--   
--   If you interpolate variables, the template is first wrapped with a
--   function containing javascript variables representing shakespeare
--   variables, then compiled with <tt>coffee</tt>, and then the value of
--   the variables are applied to the function. This means that in
--   production the template can be compiled once at compile time and there
--   will be no dependency in your production system on <tt>coffee</tt>.
--   
--   Your code:
--   
--   <pre>
--   b = 1
--   console.log(#{a} + b)
--   </pre>
--   
--   Function wrapper added to your coffeescript code:
--   
--   <pre>
--   ((shakespeare_var_a) =&gt;
--     b = 1
--     console.log(shakespeare_var_a + b)
--   )
--   </pre>
--   
--   This is then compiled down to javascript, and the variables are
--   applied:
--   
--   <pre>
--   ;(function(shakespeare_var_a){
--     var b = 1;
--     console.log(shakespeare_var_a + b);
--   })(#{a});
--   </pre>
--   
--   Further reading:
--   
--   <ol>
--   <li>Shakespearean templates:
--   <a>http://www.yesodweb.com/book/templates</a></li>
--   <li>CoffeeScript: <a>http://coffeescript.org/</a></li>
--   </ol>
module Text.Coffee

-- | Read inline, quasiquoted CoffeeScript.
coffee :: QuasiQuoter

-- | Read in a CoffeeScript template file. This function reads the file
--   once, at compile time.
coffeeFile :: FilePath -> Q Exp

-- | Read in a CoffeeScript template file. This impure function uses
--   unsafePerformIO to re-read the file on every call, allowing for rapid
--   iteration.
coffeeFileReload :: FilePath -> Q Exp

-- | Deprecated synonym for <a>coffeeFileReload</a>

-- | <i>Deprecated: Please use coffeeFileReload instead.</i>
coffeeFileDebug :: FilePath -> Q Exp

module Text.Lucius

-- | <pre>
--   &gt;&gt;&gt; renderCss ([lucius|foo{bar:baz}|] undefined)
--   "foo{bar:baz}"
--   </pre>
lucius :: QuasiQuoter
luciusFile :: FilePath -> Q Exp
luciusFileDebug :: FilePath -> Q Exp
luciusFileReload :: FilePath -> Q Exp
luciusMixin :: QuasiQuoter
data Mixin
luciusRT :: Text -> [(Text, Text)] -> Either String Text
luciusRT' :: Text -> Either String ([(Text, Text)] -> Either String [TopLevel Resolved])

-- | Same as <a>luciusRT</a>, but output has no added whitespace.
--   
--   Since 1.0.3
luciusRTMinified :: Text -> [(Text, Text)] -> Either String Text

-- | Runtime Lucius with mixin support.
--   
--   Since 1.0.6
luciusRTMixin :: Text -> Bool -> [(Text, RTValue)] -> Either String Text
data RTValue
RTVRaw :: Text -> RTValue
RTVMixin :: Mixin -> RTValue
data Css
type CssUrl url = (url -> [(Text, Text)] -> Text) -> Css
class ToCss a
toCss :: ToCss a => a -> Builder
renderCss :: Css -> Text
renderCssUrl :: (url -> [(Text, Text)] -> Text) -> CssUrl url -> Text
data Color
Color :: Word8 -> Word8 -> Word8 -> Color
colorRed :: Color
colorBlack :: Color

-- | Create a CSS size, e.g. $(mkSize "100px").
mkSize :: String -> ExpQ

-- | Absolute size units.
data AbsoluteUnit
Centimeter :: AbsoluteUnit
Inch :: AbsoluteUnit
Millimeter :: AbsoluteUnit
Pica :: AbsoluteUnit
Point :: AbsoluteUnit

-- | Not intended for direct use, see <a>mkSize</a>.
data AbsoluteSize
AbsoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize

-- | Units used for text formatting.
absoluteSizeUnit :: AbsoluteSize -> AbsoluteUnit

-- | Normalized value in centimeters.
absoluteSizeValue :: AbsoluteSize -> Rational

-- | Constructs <a>AbsoluteSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
absoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize
data EmSize
EmSize :: Rational -> EmSize
data ExSize
ExSize :: Rational -> ExSize

-- | Not intended for direct use, see <a>mkSize</a>.
data PercentageSize
PercentageSize :: Rational -> PercentageSize

-- | Normalized value, 1 == 100%.
percentageSizeValue :: PercentageSize -> Rational

-- | Constructs <a>PercentageSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
percentageSize :: Rational -> PercentageSize
data PixelSize
PixelSize :: Rational -> PixelSize
parseTopLevels :: Parser [TopLevel Unresolved]

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
luciusUsedIdentifiers :: String -> [(Deref, VarType)]

module Text.Cassius
data Css
type CssUrl url = (url -> [(Text, Text)] -> Text) -> Css
class ToCss a
toCss :: ToCss a => a -> Builder
renderCss :: Css -> Text
renderCssUrl :: (url -> [(Text, Text)] -> Text) -> CssUrl url -> Text
cassius :: QuasiQuoter
cassiusFile :: FilePath -> Q Exp
cassiusFileDebug :: FilePath -> Q Exp
cassiusFileReload :: FilePath -> Q Exp

-- | Create a mixin with Cassius syntax.
--   
--   Since 2.0.3
cassiusMixin :: QuasiQuoter
data Mixin
data Color
Color :: Word8 -> Word8 -> Word8 -> Color
colorRed :: Color
colorBlack :: Color

-- | Create a CSS size, e.g. $(mkSize "100px").
mkSize :: String -> ExpQ

-- | Absolute size units.
data AbsoluteUnit
Centimeter :: AbsoluteUnit
Inch :: AbsoluteUnit
Millimeter :: AbsoluteUnit
Pica :: AbsoluteUnit
Point :: AbsoluteUnit

-- | Not intended for direct use, see <a>mkSize</a>.
data AbsoluteSize
AbsoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize

-- | Units used for text formatting.
absoluteSizeUnit :: AbsoluteSize -> AbsoluteUnit

-- | Normalized value in centimeters.
absoluteSizeValue :: AbsoluteSize -> Rational

-- | Constructs <a>AbsoluteSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
absoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize
data EmSize
EmSize :: Rational -> EmSize
data ExSize
ExSize :: Rational -> ExSize

-- | Not intended for direct use, see <a>mkSize</a>.
data PercentageSize
PercentageSize :: Rational -> PercentageSize

-- | Normalized value, 1 == 100%.
percentageSizeValue :: PercentageSize -> Rational

-- | Constructs <a>PercentageSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
percentageSize :: Rational -> PercentageSize
data PixelSize
PixelSize :: Rational -> PixelSize

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
cassiusUsedIdentifiers :: String -> [(Deref, VarType)]


-- | A Shakespearean module for TypeScript, introducing type-safe,
--   compile-time variable and url interpolation. It is exactly the same as
--   <a>Text.Julius</a>, except that the template is first compiled to
--   Javascript with the system tool <tt>tsc</tt>.
--   
--   To use this module, <tt>tsc</tt> must be installed on your system.
--   
--   If you interpolate variables, the template is first wrapped with a
--   function containing javascript variables representing shakespeare
--   variables, then compiled with <tt>tsc</tt>, and then the value of the
--   variables are applied to the function. This means that in production
--   the template can be compiled once at compile time and there will be no
--   dependency in your production system on <tt>tsc</tt>.
--   
--   Your code:
--   
--   <pre>
--   var b = 1
--   console.log(#{a} + b)
--   </pre>
--   
--   Final Result:
--   
--   <pre>
--   ;(function(shakespeare_var_a){
--     var b = 1;
--     console.log(shakespeare_var_a + b);
--   })(#{a});
--   </pre>
--   
--   Important Warnings! This integration is not ideal.
--   
--   Due to the function wrapper, all type declarations must be in separate
--   .d.ts files. However, if you don't interpolate variables, no function
--   wrapper will be created, and you can make type declarations in the
--   same file.
--   
--   This does not work cross-platform!
--   
--   Unfortunately tsc does not support stdin and stdout. So a hack of
--   writing to temporary files using the mktemp command is used. This
--   works on my version of Linux, but not for windows unless perhaps you
--   install a mktemp utility, which I have not tested. Please vote up this
--   bug: <a>http://typescript.codeplex.com/workitem/600</a>
--   
--   Making this work on Windows would not be very difficult, it will just
--   require a new package with a dependency on a package like temporary.
--   
--   Further reading:
--   
--   <ol>
--   <li>Shakespearean templates:
--   <a>http://www.yesodweb.com/book/templates</a></li>
--   <li>TypeScript: <a>http://typescript.codeplex.com/</a></li>
--   </ol>
module Text.TypeScript

-- | Read inline, quasiquoted TypeScript
tsc :: QuasiQuoter

-- | Read in a TypeScript template file. This function reads the file once,
--   at compile time.
typeScriptFile :: FilePath -> Q Exp

-- | Read in a TypeScript template file. This impure function uses
--   unsafePerformIO to re-read the file on every call, allowing for rapid
--   iteration.
typeScriptFileReload :: FilePath -> Q Exp
