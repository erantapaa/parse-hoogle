-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Model-view-controller
--   
@package mvc
@version 1.1.0


-- | Use the <a>Model</a> - <a>View</a> - <a>Controller</a> pattern to
--   separate impure inputs and outputs from pure application logic so that
--   you can:
--   
--   <ul>
--   <li>Equationally reason about your model<ul><li>Exercise your model
--   with property-based testing (like
--   <tt>QuickCheck</tt>)</li><li>Reproducibly replay your
--   model</li></ul>The <tt>mvc</tt> library uses the type system to
--   statically enforce the separation of impure <a>View</a>s and
--   <a>Controller</a>s from the pure <a>Model</a>.Here's a small example
--   program written using the <tt>mvc</tt> library to illustrate the core
--   types and concepts:</li>
--   </ul>
--   
--   <pre>
--   import MVC
--   import qualified MVC.Prelude as MVC
--   import qualified Pipes.Prelude as Pipes
--   
--   external :: Managed (View String, Controller String)
--   external = do
--       c1 &lt;- MVC.stdinLines
--       c2 &lt;- MVC.tick 1
--       return (MVC.stdoutLines, c1 &lt;&gt; fmap show c2)
--   
--   model :: Model () String String
--   model = asPipe (Pipes.takeWhile (/= "quit"))
--       
--   main :: IO ()
--   main = runMVC () model external
--   </pre>
--   
--   This program has three components:
--   
--   <ul>
--   <li>A <a>Controller</a> that interleaves lines from standard input
--   with periodic ticks<ul><li>A <a>View</a> that writes lines to standard
--   output</li><li>A pure <a>Model</a>, which forwards lines until the
--   user inputs "quit"</li></ul><a>runMVC</a> connects them into a
--   complete program, which outputs a <tt>()</tt> every second and also
--   echoes standard input to standard output until the user enters
--   "quit":</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; main
--   ()
--   Test&lt;Enter&gt;
--   Test
--   ()
--   ()
--   42&lt;Enter&gt;
--   42
--   ()
--   quit&lt;enter&gt;
--   
--   &gt;&gt;&gt; 
--   </pre>
--   
--   The following sections give extended guidance for how to structure
--   <tt>mvc</tt> programs. Additionally, there is an <a>MVC.Prelude</a>
--   module, which provides several utilities and provides a more elaborate
--   code example using the <tt>sdl</tt> library.
module MVC

-- | A concurrent source
--   
--   <pre>
--   fmap f (c1 &lt;&gt; c2) = fmap f c1 &lt;&gt; fmap f c2
--   
--   fmap f mempty = mempty
--   </pre>
data Controller a

-- | Create a <a>Controller</a> from an <a>Input</a>
asInput :: Input a -> Controller a

-- | Think of the type as one of the following types:
--   
--   <pre>
--   keeps :: Prism'     a b -&gt; Controller a -&gt; Controller b
--   keeps :: Traversal' a b -&gt; Controller a -&gt; Controller b
--   </pre>
--   
--   <tt>(keeps prism controller)</tt> only emits values if the
--   <tt>prism</tt> matches the <tt>controller</tt>'s output.
--   
--   <pre>
--   keeps (p1 . p2) = keeps p2 . keeps p1
--   
--   keeps id = id
--   </pre>
--   
--   <pre>
--   keeps p (c1 &lt;&gt; c2) = keeps p c1 &lt;&gt; keeps p c2
--   
--   keeps p mempty = mempty
--   </pre>
keeps :: ((b -> Constant (First b) b) -> (a -> Constant (First b) a)) -> Controller a -> Controller b

-- | An effectful sink
--   
--   <pre>
--   contramap f (v1 &lt;&gt; v2) = contramap f v1 &lt;&gt; contramap f v2
--   
--   contramap f mempty = mempty
--   </pre>
data View a

-- | Create a <a>View</a> from a sink
asSink :: (a -> IO ()) -> View a

-- | Create a <a>View</a> from a <a>FoldM</a>
asFold :: FoldM IO a () -> View a

-- | Think of the type as one of the following types:
--   
--   <pre>
--   handles :: Prism'     a b -&gt; View b -&gt; View a
--   handles :: Traversal' a b -&gt; View b -&gt; View a
--   </pre>
--   
--   <tt>(handles prism view)</tt> only runs the <tt>view</tt> if the
--   <tt>prism</tt> matches the input.
--   
--   <pre>
--   handles (p1 . p2) = handles p1 . handles p2
--   
--   handles id = id
--   </pre>
--   
--   <pre>
--   handles p (v1 &lt;&gt; v2) = handles p v1 &lt;&gt; handles p v2
--   
--   handles p mempty = mempty
--   </pre>
handles :: HandlerM IO a b -> View b -> View a

-- | A <tt>(Model s a b)</tt> converts a stream of <tt>(a)</tt>s into a
--   stream of <tt>(b)</tt>s while interacting with a state <tt>(s)</tt>
data Model s a b

-- | Create a <a>Model</a> from a <a>Pipe</a>
--   
--   <pre>
--   asPipe (p1 &lt;-&lt; p2) = asPipe p1 . asPipe p2
--   
--   asPipe cat = id
--   </pre>
asPipe :: Pipe a b (State s) () -> Model s a b

-- | Connect a <a>Model</a>, <a>View</a>, and <a>Controller</a> and initial
--   state into a complete application.
runMVC :: s -> Model s a b -> Managed (View b, Controller a) -> IO s

-- | A managed resource that you acquire using <a>with</a>
data Managed a :: * -> *

-- | Build a <a>Managed</a> value
managed :: (forall r. (a -> IO r) -> IO r) -> Managed a

-- | Create a <a>Pipe</a> from a <a>ListT</a> transformation
--   
--   <pre>
--   loop (k1 &gt;=&gt; k2) = loop k1 &gt;-&gt; loop k2
--   
--   loop return = cat
--   </pre>
loop :: Monad m => (a -> ListT m b) -> Pipe a b m r
instance Category (Model s)
instance Contravariant View
instance Monoid (View a)
instance Monoid (Controller a)
instance Functor Controller


-- | Simple utilities
--   
--   The "Example" section at the bottom of this module contains an
--   extended example of how to interact with the <tt>sdl</tt> library
--   using the <tt>mvc</tt> library
module MVC.Prelude

-- | Create a <a>Controller</a> from a <a>Producer</a>, using the given
--   <a>Buffer</a>
--   
--   If you're not sure what <a>Buffer</a> to use, try <a>Single</a>
producer :: Buffer a -> Producer a IO () -> Managed (Controller a)

-- | Read lines from standard input
stdinLines :: Managed (Controller String)

-- | Read lines from a file
inLines :: FilePath -> Managed (Controller String)

-- | <a>read</a> values from a file, one value per line, skipping failed
--   parses
inRead :: Read a => FilePath -> Managed (Controller a)

-- | Emit empty values spaced by a delay in seconds
tick :: Double -> Managed (Controller ())

-- | Create a <a>View</a> from a <a>Consumer</a>
consumer :: Consumer a IO () -> Managed (View a)

-- | Write lines to standard output
stdoutLines :: View String

-- | Write lines to a file
outLines :: FilePath -> Managed (View String)

-- | <a>show</a> values to a file, one value per line
outShow :: Show a => FilePath -> Managed (View a)

-- | Read from a <a>FilePath</a> using a <a>Managed</a> <a>Handle</a>
inHandle :: FilePath -> Managed Handle

-- | Write to a <a>FilePath</a> using a <a>Managed</a> <a>Handle</a>
outHandle :: FilePath -> Managed Handle
