-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Emulation of subkinds and subkind polymorphism
--   
--   Subkinds are the kind-level analog to subtypes. A kind denotes a set
--   of types, and a subkind of some base kind denotes a subset of the base
--   kind’s set of types. Haskell has no support for subkinds and subkind
--   polymorphism. However, this package can be used to emulate subkinds of
--   kind <tt>*</tt> and subkind variables.
--   
--   To define a new subkind, the user declares a type that represents the
--   subkind, and instantiates some classes. Afterwards, the user can
--   declare types to be of that subkind and universally quantify over the
--   inhabitants of the subkind. Since subkinds are represented by types,
--   type-level polymorphism can be used to emulate kind-level
--   polymorphism.
--   
--   For detailed information, please refer to Section 6 of the paper
--   <i>Generic Record Combinators with Static Type Checking</i>.
@package kinds
@version 0.0.1.5


-- | Support for subkinds of kind <tt>*</tt>, including subkind
--   polymorphism.
--   
--   Imagine, we had a language extension for declaring subkinds of kind
--   <tt>*</tt> where a subkind declaration would be written as follows:
--   
--   <pre>
--   subkind <i>K</i> = <i>C_1</i> =&gt; <i>t_1</i> | ... | <i>C_n</i> =&gt; <i>t_n</i>
--   </pre>
--   
--   Thereby, <tt><i>K</i></tt> would be a kind identifier, the
--   <tt><i>t_i</i></tt> would be types and the <tt><i>C_i</i></tt> would
--   be contexts. This subkind declaration would introduce a subkind
--   <tt><i>K</i></tt> that covers all types that match one of the
--   <tt><i>t_i</i></tt> and fulfill the corresponding context. For
--   example, the declaration
--   
--   <pre>
--   subkind Map = (Ord key) =&gt; Map key val | IntMap val
--   </pre>
--   
--   would declare the subkind <tt>Map</tt> of all types whose values are
--   maps. Note that the subkind <tt>Map</tt> would be different from the
--   type <tt>Map</tt>.
--   
--   We will now see how a subkind declaration
--   
--   <pre>
--   subkind <i>K</i> = <i>C_1</i> =&gt; <i>t_1</i> | ... | <i>C_n</i> =&gt; <i>t_n</i>
--   </pre>
--   
--   can be emulated using this module. First, we declare a type
--   <tt>Kind<i>K</i></tt> with a nullary data constructor of the same name
--   for representing the subkind. Then we add the following instance
--   declaration:
--   
--   <pre>
--   instance Kind Kind<i>K</i> where
--    
--       data All Kind<i>K</i> item = All<i>K</i> (forall <i>A_1</i>. <i>C_1</i> =&gt; item <i>t_1</i>)
--                                  ...
--                                  (forall <i>A_n</i>. <i>C_n</i> =&gt; item <i>t_n</i>)
--    
--       closed item = All<i>K</i> item ... item
--   </pre>
--   
--   Thereby, each <tt><i>A_i</i></tt> stands for a whitespace-separated
--   sequence of the free variables of <tt><i>t_i</i></tt>. Finally, we add
--   the following instance declaration for every <tt><i>i</i></tt> between
--   <tt>1</tt> and <tt><i>n</i></tt>:
--   
--   <pre>
--   instance <i>C_i</i> =&gt; Inhabitant Kind<i>K</i> <i>t_i</i> where
--    
--       specialize (All<i>K</i> _ ... _ item _ ... _) = item
--   </pre>
--   
--   Thereby, the number of wildcard patterns before and after
--   <tt>item</tt> is <tt><i>i</i> - 1</tt> and <tt><i>n</i> -
--   <i>i</i></tt>, respectively. The above subkind declaration for
--   <tt>Map</tt> can be emulated with the following code:
--   
--   <pre>
--   data KindMap = KindMap
--    
--   instance Kind KindMap where
--    
--       data All KindMap item = AllMap (forall key val. (Ord key) =&gt; item (Map key val))
--                                      (forall val.                  item (IntMap val))
--    
--       closed item = AllMap item item
--    
--   instance (Ord key) =&gt; Inhabitant KindMap (Map key val) where
--    
--       specialize (AllMap item _) = item
--    
--   instance Inhabitant KindMap (IntMap val) where
--    
--       specialize (AllMap _ item) = item
--   </pre>
module Data.Kind

-- | The class of subkind representations.
class Kind kind where { data family All kind :: (* -> *) -> *; }
closed :: Kind kind => (forall inhabitant. Inhabitant kind inhabitant => item inhabitant) -> All kind item

-- | Specifies what types are inhabitants of what subkinds.
class Kind kind => Inhabitant kind inhabitant
specialize :: Inhabitant kind inhabitant => All kind item -> item inhabitant

-- | Represents kind <tt>*</tt> itself.
data KindStar
KindStar :: KindStar
instance Inhabitant KindStar val
instance Kind KindStar
