-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A pretty printing library inspired by the llvm binding.
--   
--   A pretty printing library that was inspired by the LLVM binding by
--   Lennart Augustsson. The library provides a monadic interface to a
--   pretty printer, that allows functions to be defined and called,
--   generating the corresponding LLVM assemblly when run.
@package llvm-pretty
@version 0.3.1.1

module Text.LLVM.AST
commas :: [Doc] -> Doc
colons :: [Doc] -> Doc
breaks :: (a -> Bool) -> [a] -> [[a]]
uncons :: MonadPlus m => [a] -> m (a, [a])
int32 :: Int32 -> Doc
angles :: Doc -> Doc
structBraces :: Doc -> Doc
ppMaybe :: (a -> Doc) -> Maybe a -> Doc
opt :: Bool -> Doc -> Doc
data Module
Module :: DataLayout -> [TypeDecl] -> [NamedMd] -> [UnnamedMd] -> [Global] -> [Declare] -> [Define] -> InlineAsm -> [GlobalAlias] -> Module
modDataLayout :: Module -> DataLayout
modTypes :: Module -> [TypeDecl]
modNamedMd :: Module -> [NamedMd]
modUnnamedMd :: Module -> [UnnamedMd]
modGlobals :: Module -> [Global]
modDeclares :: Module -> [Declare]
modDefines :: Module -> [Define]
modInlineAsm :: Module -> InlineAsm
modAliases :: Module -> [GlobalAlias]
emptyModule :: Module
ppModule :: Module -> Doc
data NamedMd
NamedMd :: String -> [Int] -> NamedMd
nmName :: NamedMd -> String
nmValues :: NamedMd -> [Int]
ppNamedMd :: NamedMd -> Doc
data UnnamedMd
UnnamedMd :: !Int -> [Typed Value] -> UnnamedMd
umIndex :: UnnamedMd -> !Int
umValues :: UnnamedMd -> [Typed Value]
ppUnnamedMd :: UnnamedMd -> Doc
data GlobalAlias
GlobalAlias :: Symbol -> Type -> Value -> GlobalAlias
aliasName :: GlobalAlias -> Symbol
aliasType :: GlobalAlias -> Type
aliasTarget :: GlobalAlias -> Value
ppGlobalAlias :: GlobalAlias -> Doc
type DataLayout = [LayoutSpec]

-- | Pretty print a data layout specification.
ppDataLayout :: DataLayout -> Doc
data LayoutSpec
BigEndian :: LayoutSpec
LittleEndian :: LayoutSpec
PointerSize :: !Int -> !Int -> (Maybe Int) -> LayoutSpec
IntegerSize :: !Int -> !Int -> (Maybe Int) -> LayoutSpec
VectorSize :: !Int -> !Int -> (Maybe Int) -> LayoutSpec
FloatSize :: !Int -> !Int -> (Maybe Int) -> LayoutSpec
AggregateSize :: !Int -> !Int -> (Maybe Int) -> LayoutSpec
StackObjSize :: !Int -> !Int -> (Maybe Int) -> LayoutSpec
NativeIntSize :: [Int] -> LayoutSpec
StackAlign :: !Int -> LayoutSpec
Mangling :: Mangling -> LayoutSpec
data Mangling
ElfMangling :: Mangling
MipsMangling :: Mangling
MachOMangling :: Mangling
WindowsCoffMangling :: Mangling

-- | Pretty print a single layout specification.
ppLayoutSpec :: LayoutSpec -> Doc

-- | Pretty-print the common case for data layout specifications.
ppLayoutBody :: Int -> Int -> Maybe Int -> Doc
ppMangling :: Mangling -> Doc

-- | Parse the data layout string.
parseDataLayout :: MonadPlus m => String -> m DataLayout

-- | Parse a single layout specification from a string.
parseLayoutSpec :: MonadPlus m => String -> m LayoutSpec
type InlineAsm = [String]

-- | Pretty-print the inline assembly block.
ppInlineAsm :: InlineAsm -> Doc
newtype Ident
Ident :: String -> Ident
ppIdent :: Ident -> Doc
newtype Symbol
Symbol :: String -> Symbol
ppSymbol :: Symbol -> Doc
data PrimType
Label :: PrimType
Void :: PrimType
Integer :: Int32 -> PrimType
FloatType :: FloatType -> PrimType
X86mmx :: PrimType
Metadata :: PrimType
ppPrimType :: PrimType -> Doc
data FloatType
Float :: FloatType
Double :: FloatType
Fp128 :: FloatType
X86_fp80 :: FloatType
PPC_fp128 :: FloatType
ppFloatType :: FloatType -> Doc
type Type = Type' Ident
data Type' ident
PrimType :: PrimType -> Type' ident
Alias :: ident -> Type' ident
Array :: Int32 -> (Type' ident) -> Type' ident
FunTy :: (Type' ident) -> [Type' ident] -> Bool -> Type' ident
PtrTo :: (Type' ident) -> Type' ident
Struct :: [Type' ident] -> Type' ident
PackedStruct :: [Type' ident] -> Type' ident
Vector :: Int32 -> (Type' ident) -> Type' ident
Opaque :: Type' ident

-- | Traverse a type, updating or removing aliases.
updateAliases :: (a -> Type' b) -> (Type' a -> Type' b)
ppType :: Type -> Doc
isFloatingPoint :: PrimType -> Bool
isAlias :: Type -> Bool
isPrimTypeOf :: (PrimType -> Bool) -> Type -> Bool
isLabel :: PrimType -> Bool
isInteger :: PrimType -> Bool
isVector :: Type -> Bool
isVectorOf :: (Type -> Bool) -> Type -> Bool
isArray :: Type -> Bool
isPointer :: Type -> Bool

-- | Build a variable-argument argument list.
ppArgList :: Bool -> [Doc] -> Doc
data NullResult lab
HasNull :: (Value' lab) -> NullResult lab
ResolveNull :: Ident -> NullResult lab
primTypeNull :: PrimType -> Value' lab
floatTypeNull :: FloatType -> Value' lab
typeNull :: Type -> NullResult lab
elimFunTy :: MonadPlus m => Type -> m (Type, [Type], Bool)
elimAlias :: MonadPlus m => Type -> m Ident
elimPtrTo :: MonadPlus m => Type -> m Type
elimVector :: MonadPlus m => Type -> m (Int32, Type)
elimArray :: MonadPlus m => Type -> m (Int32, Type)
elimFunPtr :: MonadPlus m => Type -> m (Type, [Type], Bool)
elimPrimType :: MonadPlus m => Type -> m PrimType
elimFloatType :: MonadPlus m => PrimType -> m FloatType

-- | Eliminator for array, pointer and vector types.
elimSequentialType :: MonadPlus m => Type -> m Type
data TypeDecl
TypeDecl :: Ident -> Type -> TypeDecl
typeName :: TypeDecl -> Ident
typeValue :: TypeDecl -> Type
ppTypeDecl :: TypeDecl -> Doc
data Global
Global :: Symbol -> GlobalAttrs -> Type -> Value -> Maybe Align -> Global
globalSym :: Global -> Symbol
globalAttrs :: Global -> GlobalAttrs
globalType :: Global -> Type
globalValue :: Global -> Value
globalAlign :: Global -> Maybe Align
ppGlobal :: Global -> Doc
addGlobal :: Global -> Module -> Module
data GlobalAttrs
GlobalAttrs :: Maybe Linkage -> Bool -> GlobalAttrs
gaLinkage :: GlobalAttrs -> Maybe Linkage
gaConstant :: GlobalAttrs -> Bool
ppGlobalAttrs :: GlobalAttrs -> Doc
data Declare
Declare :: Type -> Symbol -> [Type] -> Bool -> Declare
decRetType :: Declare -> Type
decName :: Declare -> Symbol
decArgs :: Declare -> [Type]
decVarArgs :: Declare -> Bool
ppDeclare :: Declare -> Doc
data Define
Define :: FunAttrs -> Type -> Symbol -> [Typed Ident] -> Bool -> Maybe String -> [BasicBlock] -> Define
defAttrs :: Define -> FunAttrs
defRetType :: Define -> Type
defName :: Define -> Symbol
defArgs :: Define -> [Typed Ident]
defVarArgs :: Define -> Bool
defSection :: Define -> Maybe String
defBody :: Define -> [BasicBlock]
ppDefine :: Define -> Doc
addDefine :: Define -> Module -> Module
data FunAttrs
FunAttrs :: Maybe Linkage -> Maybe GC -> FunAttrs
funLinkage :: FunAttrs -> Maybe Linkage
funGC :: FunAttrs -> Maybe GC
emptyFunAttrs :: FunAttrs
data BlockLabel
Named :: Ident -> BlockLabel
Anon :: Int -> BlockLabel
ppLabelDef :: BlockLabel -> Doc
ppLabel :: BlockLabel -> Doc
data BasicBlock' lab
BasicBlock :: lab -> [Stmt] -> BasicBlock' lab
bbLabel :: BasicBlock' lab -> lab
bbStmts :: BasicBlock' lab -> [Stmt]
type BasicBlock = BasicBlock' (Maybe BlockLabel)
ppBasicBlock :: BasicBlock -> Doc
brTargets :: BasicBlock' lab -> [BlockLabel]

-- | Symbol Linkage
data Linkage
Private :: Linkage
LinkerPrivate :: Linkage
LinkerPrivateWeak :: Linkage
LinkerPrivateWeakDefAuto :: Linkage
Internal :: Linkage
AvailableExternally :: Linkage
Linkonce :: Linkage
Weak :: Linkage
Common :: Linkage
Appending :: Linkage
ExternWeak :: Linkage
LinkonceODR :: Linkage
WeakODR :: Linkage
External :: Linkage
DLLImport :: Linkage
DLLExport :: Linkage
ppLinkage :: Linkage -> Doc
newtype GC
GC :: String -> GC
getGC :: GC -> String
ppGC :: GC -> Doc
data Typed a
Typed :: Type -> a -> Typed a
typedType :: Typed a -> Type
typedValue :: Typed a -> a
mapMTyped :: Monad m => (a -> m b) -> Typed a -> m (Typed b)
ppTyped :: (a -> Doc) -> Typed a -> Doc
data ArithOp
Add :: Bool -> Bool -> ArithOp
FAdd :: ArithOp
Sub :: Bool -> Bool -> ArithOp
FSub :: ArithOp
Mul :: Bool -> Bool -> ArithOp
FMul :: ArithOp
UDiv :: Bool -> ArithOp
SDiv :: Bool -> ArithOp
FDiv :: ArithOp
URem :: ArithOp
SRem :: ArithOp
FRem :: ArithOp
ppSignBits :: Bool -> Bool -> Doc
ppExact :: Bool -> Doc
ppArithOp :: ArithOp -> Doc
isIArith :: ArithOp -> Bool
isFArith :: ArithOp -> Bool
data BitOp
Shl :: Bool -> Bool -> BitOp
Lshr :: Bool -> BitOp
Ashr :: Bool -> BitOp
And :: BitOp
Or :: BitOp
Xor :: BitOp
ppBitOp :: BitOp -> Doc
data ConvOp
Trunc :: ConvOp
ZExt :: ConvOp
SExt :: ConvOp
FpTrunc :: ConvOp
FpExt :: ConvOp
FpToUi :: ConvOp
FpToSi :: ConvOp
UiToFp :: ConvOp
SiToFp :: ConvOp
PtrToInt :: ConvOp
IntToPtr :: ConvOp
BitCast :: ConvOp
ppConvOp :: ConvOp -> Doc
type Align = Int
data Instr' lab
Ret :: (Typed (Value' lab)) -> Instr' lab
RetVoid :: Instr' lab
Arith :: ArithOp -> (Typed (Value' lab)) -> (Value' lab) -> Instr' lab
Bit :: BitOp -> (Typed (Value' lab)) -> (Value' lab) -> Instr' lab
Conv :: ConvOp -> (Typed (Value' lab)) -> Type -> Instr' lab
Call :: Bool -> Type -> (Value' lab) -> [Typed (Value' lab)] -> Instr' lab
Alloca :: Type -> (Maybe (Typed (Value' lab))) -> (Maybe Int) -> Instr' lab
Load :: (Typed (Value' lab)) -> (Maybe Align) -> Instr' lab
Store :: (Typed (Value' lab)) -> (Typed (Value' lab)) -> (Maybe Align) -> Instr' lab
ICmp :: ICmpOp -> (Typed (Value' lab)) -> (Value' lab) -> Instr' lab
FCmp :: FCmpOp -> (Typed (Value' lab)) -> (Value' lab) -> Instr' lab
Phi :: Type -> [(Value' lab, lab)] -> Instr' lab
GEP :: Bool -> (Typed (Value' lab)) -> [Typed (Value' lab)] -> Instr' lab
Select :: (Typed (Value' lab)) -> (Typed (Value' lab)) -> (Value' lab) -> Instr' lab
ExtractValue :: (Typed (Value' lab)) -> [Int32] -> Instr' lab
InsertValue :: (Typed (Value' lab)) -> (Typed (Value' lab)) -> [Int32] -> Instr' lab
ExtractElt :: (Typed (Value' lab)) -> (Value' lab) -> Instr' lab
InsertElt :: (Typed (Value' lab)) -> (Typed (Value' lab)) -> (Value' lab) -> Instr' lab
ShuffleVector :: (Typed (Value' lab)) -> (Value' lab) -> (Typed (Value' lab)) -> Instr' lab
Jump :: lab -> Instr' lab
Br :: (Typed (Value' lab)) -> lab -> lab -> Instr' lab
Invoke :: Type -> (Value' lab) -> [Typed (Value' lab)] -> lab -> lab -> Instr' lab
Comment :: String -> Instr' lab
Unreachable :: Instr' lab
Unwind :: Instr' lab
VaArg :: (Typed (Value' lab)) -> Type -> Instr' lab
IndirectBr :: (Typed (Value' lab)) -> [lab] -> Instr' lab
Switch :: (Typed (Value' lab)) -> lab -> [(Integer, lab)] -> Instr' lab
LandingPad :: Type -> (Typed (Value' lab)) -> Bool -> [Clause' lab] -> Instr' lab
Resume :: (Typed (Value' lab)) -> Instr' lab
type Instr = Instr' BlockLabel
data Clause' lab
Catch :: (Typed (Value' lab)) -> Clause' lab
Filter :: (Typed (Value' lab)) -> Clause' lab
type Clause = Clause' BlockLabel
isTerminator :: Instr' lab -> Bool
isComment :: Instr' lab -> Bool
isPhi :: Instr' lab -> Bool
ppInstr :: Instr -> Doc
ppClauses :: Bool -> [Clause] -> Doc
ppClause :: Clause -> Doc
ppTypedLabel :: BlockLabel -> Doc
ppSwitchEntry :: Type -> (Integer, BlockLabel) -> Doc
ppVectorIndex :: Value -> Doc
ppAlign :: Maybe Align -> Doc
ppAlloca :: Type -> Maybe (Typed Value) -> Maybe Int -> Doc
ppCall :: Bool -> Type -> Value -> [Typed Value] -> Doc
ppCallSym :: Type -> Value -> Doc
ppGEP :: Bool -> Typed Value -> [Typed Value] -> Doc
ppInvoke :: Type -> Value -> [Typed Value] -> BlockLabel -> BlockLabel -> Doc
ppPhiArg :: (Value, BlockLabel) -> Doc
data ICmpOp
Ieq :: ICmpOp
Ine :: ICmpOp
Iugt :: ICmpOp
Iuge :: ICmpOp
Iult :: ICmpOp
Iule :: ICmpOp
Isgt :: ICmpOp
Isge :: ICmpOp
Islt :: ICmpOp
Isle :: ICmpOp
ppICmpOp :: ICmpOp -> Doc
data FCmpOp
Ffalse :: FCmpOp
Foeq :: FCmpOp
Fogt :: FCmpOp
Foge :: FCmpOp
Folt :: FCmpOp
Fole :: FCmpOp
Fone :: FCmpOp
Ford :: FCmpOp
Fueq :: FCmpOp
Fugt :: FCmpOp
Fuge :: FCmpOp
Fult :: FCmpOp
Fule :: FCmpOp
Fune :: FCmpOp
Funo :: FCmpOp
Ftrue :: FCmpOp
ppFCmpOp :: FCmpOp -> Doc
data Value' lab
ValInteger :: Integer -> Value' lab
ValBool :: Bool -> Value' lab
ValFloat :: Float -> Value' lab
ValDouble :: Double -> Value' lab
ValIdent :: Ident -> Value' lab
ValSymbol :: Symbol -> Value' lab
ValNull :: Value' lab
ValArray :: Type -> [Value' lab] -> Value' lab
ValVector :: Type -> [Value' lab] -> Value' lab
ValStruct :: [Typed (Value' lab)] -> Value' lab
ValPackedStruct :: [Typed (Value' lab)] -> Value' lab
ValString :: String -> Value' lab
ValConstExpr :: (ConstExpr' lab) -> Value' lab
ValUndef :: Value' lab
ValLabel :: lab -> Value' lab
ValZeroInit :: Value' lab
ValAsm :: Bool -> Bool -> String -> String -> Value' lab
ValMd :: (ValMd' lab) -> Value' lab
type Value = Value' BlockLabel
data ValMd' lab
ValMdString :: String -> ValMd' lab
ValMdNode :: [Typed (Value' lab)] -> ValMd' lab
ValMdRef :: Int -> ValMd' lab
ValMdLoc :: (DebugLoc' lab) -> ValMd' lab
type ValMd = ValMd' BlockLabel
data DebugLoc' lab
DebugLoc :: Int32 -> Int32 -> ValMd' lab -> Maybe (ValMd' lab) -> DebugLoc' lab
dlLine :: DebugLoc' lab -> Int32
dlCol :: DebugLoc' lab -> Int32
dlScope :: DebugLoc' lab -> ValMd' lab
dlIA :: DebugLoc' lab -> Maybe (ValMd' lab)
type DebugLoc = DebugLoc' BlockLabel
isConst :: Value' lab -> Bool
ppValue :: Value -> Doc
ppValMd :: ValMd -> Doc
ppDebugLoc :: DebugLoc -> Doc
ppTypedValMd :: ValMd -> Doc
ppMetadata :: Doc -> Doc
ppMetadataNode :: [Typed Value] -> Doc
ppBool :: Bool -> Doc
ppStringLiteral :: String -> Doc
ppAsm :: Bool -> Bool -> String -> String -> Doc
elimValSymbol :: MonadPlus m => Value' lab -> m Symbol
elimValInteger :: MonadPlus m => Value' lab -> m Integer
data Stmt' lab
Result :: Ident -> (Instr' lab) -> [(String, ValMd' lab)] -> Stmt' lab
Effect :: (Instr' lab) -> [(String, ValMd' lab)] -> Stmt' lab
type Stmt = Stmt' BlockLabel
stmtInstr :: Stmt' lab -> Instr' lab
stmtMetadata :: Stmt' lab -> [(String, ValMd' lab)]
extendMetadata :: (String, ValMd' lab) -> Stmt' lab -> Stmt' lab
ppStmt :: Stmt -> Doc
ppAttachedMetadata :: [(String, ValMd)] -> Doc
data ConstExpr' lab
ConstGEP :: Bool -> [Typed (Value' lab)] -> ConstExpr' lab
ConstConv :: ConvOp -> (Typed (Value' lab)) -> Type -> ConstExpr' lab
ConstSelect :: (Typed (Value' lab)) -> (Typed (Value' lab)) -> (Typed (Value' lab)) -> ConstExpr' lab
ConstBlockAddr :: Symbol -> lab -> ConstExpr' lab
type ConstExpr = ConstExpr' BlockLabel
ppConstExpr :: ConstExpr -> Doc
data IndexResult

-- | An invalid use of GEP
Invalid :: IndexResult

-- | A resolved type
HasType :: Type -> IndexResult

-- | Continue, after resolving an alias
Resolve :: Ident -> (Type -> IndexResult) -> IndexResult
isInvalid :: IndexResult -> Bool

-- | Resolve the type of a GEP instruction. Note that the type produced is
--   the type of the result, not necessarily a pointer.
resolveGep :: Type -> [Typed (Value' lab)] -> IndexResult

-- | Resolve the type of a GEP instruction. This assumes that the input has
--   already been processed as a pointer.
resolveGepBody :: Type -> [Typed (Value' lab)] -> IndexResult
isGepIndex :: Typed (Value' lab) -> Bool
isGepStructIndex :: Typed (Value' lab) -> Maybe Integer
resolveValueIndex :: Type -> [Int32] -> IndexResult
instance Show NamedMd
instance Show Mangling
instance Eq Mangling
instance Show LayoutSpec
instance Show Ident
instance Eq Ident
instance Ord Ident
instance Show Symbol
instance Eq Symbol
instance Ord Symbol
instance Eq FloatType
instance Ord FloatType
instance Show FloatType
instance Eq PrimType
instance Ord PrimType
instance Show PrimType
instance Eq ident => Eq (Type' ident)
instance Ord ident => Ord (Type' ident)
instance Show ident => Show (Type' ident)
instance Functor Type'
instance Show TypeDecl
instance Show Declare
instance Eq BlockLabel
instance Ord BlockLabel
instance Show BlockLabel
instance Eq Linkage
instance Show Linkage
instance Show GlobalAttrs
instance Show GC
instance Show FunAttrs
instance Show a => Show (Typed a)
instance Functor Typed
instance Eq ArithOp
instance Show ArithOp
instance Show BitOp
instance Show ConvOp
instance Show ICmpOp
instance Show FCmpOp
instance Show lab => Show (ConstExpr' lab)
instance Functor ConstExpr'
instance Show lab => Show (Value' lab)
instance Functor Value'
instance Show lab => Show (ValMd' lab)
instance Functor ValMd'
instance Show lab => Show (DebugLoc' lab)
instance Functor DebugLoc'
instance Show Global
instance Show GlobalAlias
instance Show UnnamedMd
instance Show lab => Show (Clause' lab)
instance Functor Clause'
instance Show lab => Show (Instr' lab)
instance Functor Instr'
instance Show lab => Show (Stmt' lab)
instance Functor Stmt'
instance Show lab => Show (BasicBlock' lab)
instance Show Define
instance Show Module
instance Traversable Typed
instance Foldable Typed
instance IsString BlockLabel
instance IsString Symbol
instance IsString Ident
instance Monoid Module

module Text.LLVM.Labels
class Functor f => HasLabel f
relabel :: (HasLabel f, Applicative m, Monad m) => (Maybe Symbol -> a -> m b) -> f a -> m (f b)
instance HasLabel ConstExpr'
instance HasLabel DebugLoc'
instance HasLabel ValMd'
instance HasLabel Value'
instance HasLabel Clause'
instance HasLabel Instr'
instance HasLabel Stmt'

module Text.LLVM
data LLVM a
runLLVM :: LLVM a -> (a, Module)
emitTypeDecl :: TypeDecl -> LLVM ()
emitGlobal :: Global -> LLVM ()
emitDeclare :: Declare -> LLVM ()
emitDefine :: Define -> LLVM ()
alias :: Ident -> Type -> LLVM ()
freshSymbol :: LLVM Symbol
data (:>) a b
(:>) :: a -> b -> (:>) a b

-- | Define a function.
define :: DefineArgs sig k => FunAttrs -> Type -> Symbol -> sig -> k -> LLVM (Typed Value)

-- | A combination of define and <tt>freshSymbol</tt>.
defineFresh :: DefineArgs sig k => FunAttrs -> Type -> sig -> k -> LLVM (Typed Value)

-- | Types that can be used to define the body of a function.
class DefineArgs a k | a -> k

-- | Function definition when the argument list isn't statically known.
--   This is useful when generating code.
define' :: FunAttrs -> Type -> Symbol -> [Type] -> Bool -> ([Typed Value] -> BB ()) -> LLVM (Typed Value)

-- | Emit a declaration.
declare :: Type -> Symbol -> [Type] -> Bool -> LLVM ()

-- | Emit a global declaration.
global :: Symbol -> Typed Value -> LLVM ()
iT :: Int32 -> Type
ptrT :: Type -> Type
voidT :: Type
arrayT :: Int32 -> Type -> Type
(=:) :: Type -> a -> Typed a
(-:) :: IsValue a => Type -> a -> Typed Value
class IsValue a
toValue :: IsValue a => a -> Value
int :: Int -> Value
integer :: Integer -> Value
struct :: Bool -> [Typed Value] -> Typed Value
array :: Type -> [Value] -> Typed Value

-- | Output a somewhat clunky representation for a string global, that
--   deals well with escaping in the haskell-source string.
string :: Symbol -> String -> LLVM ()
data BB a
freshLabel :: BB Ident

-- | Force termination of the current basic block, and start a new one with
--   the given label. If the previous block had no instructions defined, it
--   will just be thrown away.
label :: Ident -> BB ()
comment :: String -> BB ()

-- | Emit an assignment that uses the given identifier to name the result
--   of the BB operation.
--   
--   WARNING: this can throw errors.
assign :: IsValue a => Ident -> BB (Typed a) -> BB (Typed Value)

-- | Emit the ``ret'' instruction and terminate the current basic block.
ret :: IsValue a => Typed a -> BB ()

-- | Emit ``ret void'' and terminate the current basic block.
retVoid :: BB ()
jump :: Ident -> BB ()
br :: IsValue a => Typed a -> Ident -> Ident -> BB ()
unreachable :: BB ()
unwind :: BB ()
add :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
fadd :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
sub :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
fsub :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
mul :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
fmul :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
udiv :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
sdiv :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
fdiv :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
urem :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
srem :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
frem :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
shl :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
lshr :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
ashr :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
band :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
bor :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
bxor :: (IsValue a, IsValue b) => Typed a -> b -> BB (Typed Value)
trunc :: IsValue a => Typed a -> Type -> BB (Typed Value)
zext :: IsValue a => Typed a -> Type -> BB (Typed Value)
sext :: IsValue a => Typed a -> Type -> BB (Typed Value)
fptrunc :: IsValue a => Typed a -> Type -> BB (Typed Value)
fpext :: IsValue a => Typed a -> Type -> BB (Typed Value)
fptoui :: IsValue a => Typed a -> Type -> BB (Typed Value)
fptosi :: IsValue a => Typed a -> Type -> BB (Typed Value)
uitofp :: IsValue a => Typed a -> Type -> BB (Typed Value)
sitofp :: IsValue a => Typed a -> Type -> BB (Typed Value)
ptrtoint :: IsValue a => Typed a -> Type -> BB (Typed Value)
inttoptr :: IsValue a => Typed a -> Type -> BB (Typed Value)
bitcast :: IsValue a => Typed a -> Type -> BB (Typed Value)

-- | Returns the value stored in the member field of an aggregate value.
extractValue :: IsValue a => Typed a -> Int32 -> BB (Typed Value)

-- | Inserts a value into the member field of an aggregate value, and
--   returns the new value.
insertValue :: (IsValue a, IsValue b) => Typed a -> Typed b -> Int32 -> BB (Typed Value)
alloca :: Type -> Maybe (Typed Value) -> Maybe Int -> BB (Typed Value)
load :: IsValue a => Typed a -> Maybe Align -> BB (Typed Value)
store :: (IsValue a, IsValue b) => a -> Typed b -> Maybe Align -> BB ()
getelementptr :: IsValue a => Type -> Typed a -> [Typed Value] -> BB (Typed Value)
nullPtr :: Type -> Typed Value
icmp :: (IsValue a, IsValue b) => ICmpOp -> Typed a -> b -> BB (Typed Value)
fcmp :: (IsValue a, IsValue b) => FCmpOp -> Typed a -> b -> BB (Typed Value)
phi :: Type -> [PhiArg] -> BB (Typed Value)
data PhiArg
from :: IsValue a => a -> BlockLabel -> PhiArg
select :: (IsValue a, IsValue b, IsValue c) => Typed a -> Typed b -> Typed c -> BB (Typed Value)

-- | Emit a call instruction, and generate a new variable for its result.
call :: IsValue a => Typed a -> [Typed Value] -> BB (Typed Value)

-- | Emit a call instruction, but don't generate a new variable for its
--   result.
call_ :: IsValue a => Typed a -> [Typed Value] -> BB ()

-- | Emit an invoke instruction, and generate a new variable for its
--   result.
invoke :: IsValue a => Type -> a -> [Typed Value] -> Ident -> Ident -> BB (Typed Value)
shuffleVector :: (IsValue a, IsValue b, IsValue c) => Typed a -> b -> c -> BB (Typed Value)
instance Functor LLVM
instance Applicative LLVM
instance Monad LLVM
instance MonadFix LLVM
instance (Show a, Show b) => Show (a :> b)
instance Show RW
instance Functor BB
instance Applicative BB
instance Monad BB
instance MonadFix BB
instance IsValue Symbol
instance IsValue Ident
instance IsValue Int64
instance IsValue Int32
instance IsValue Int16
instance IsValue Int8
instance IsValue Int
instance IsValue Integer
instance IsValue a => IsValue (Typed a)
instance IsValue Value
instance IsString (BB a)
instance DefineArgs (Type, Type, Type) (Typed Value -> Typed Value -> Typed Value -> BB ())
instance DefineArgs (Type, Type) (Typed Value -> Typed Value -> BB ())
instance DefineArgs Type (Typed Value -> BB ())
instance DefineArgs as k => DefineArgs (Type :> as) (Typed Value -> k)
instance DefineArgs () (BB ())
