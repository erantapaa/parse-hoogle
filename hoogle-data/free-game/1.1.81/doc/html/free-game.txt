-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Create games for free
--   
@package free-game
@version 1.1.81

module FreeGame.Internal.Finalizer

-- | An action with explicit releasing action.
newtype FinalizerT m a
FinalizerT :: (forall r. (a -> m r) -> (IO () -> r -> m r) -> m r) -> FinalizerT m a
unFinalizerT :: FinalizerT m a -> forall r. (a -> m r) -> (IO () -> r -> m r) -> m r

-- | Add a finalizer.
finalizer :: Monad m => IO () -> FinalizerT m ()

-- | Run the action and run all associated finalizers.
runFinalizerT :: Monad m => FinalizerT m a -> m (a, IO ())
execFinalizerT :: MonadIO m => FinalizerT m a -> m a
mapFinalizerT :: (Monad m, Monad n) => (forall x. m x -> n x) -> FinalizerT m a -> FinalizerT n a
instance MonadTrans FinalizerT
instance MonadIO m => MonadIO (FinalizerT m)
instance Monad (FinalizerT m)
instance Applicative (FinalizerT m)
instance Functor (FinalizerT m)


-- | Manipulating bitmaps
module FreeGame.Data.Bitmap
data Bitmap
Bitmap :: Image PixelRGBA8 -> Int -> Bitmap
bitmapImage :: Bitmap -> Image PixelRGBA8
bitmapHash :: Bitmap -> Int

-- | Get the size of the <a>Bitmap</a>.
bitmapSize :: Bitmap -> (Int, Int)
liftBitmapIO :: MonadIO m => Image PixelRGBA8 -> m Bitmap

-- | Load an image file.
readBitmap :: MonadIO m => FilePath -> m Bitmap

-- | Save <a>Bitmap</a> into a file.
writeBitmap :: MonadIO m => FilePath -> Bitmap -> m ()

-- | Extract a <a>Bitmap</a> from the specified range.
cropBitmap :: Bitmap -> (Int, Int) -> (Int, Int) -> Bitmap
clipBitmap :: Bitmap -> Box V2 Int -> Bitmap
sizeBitmap :: Bitmap -> V2 Int


module FreeGame.Types
data WindowMode
Windowed :: WindowMode
Resizable :: WindowMode
FullScreen :: WindowMode
type Vec2 = V2 Double
type BoundingBox2 = Box V2 Double
data Key
KeyUnknown :: Key
KeySpace :: Key
KeyApostrophe :: Key
KeyComma :: Key
KeyMinus :: Key
KeyPeriod :: Key
KeySlash :: Key
Key0 :: Key
Key1 :: Key
Key2 :: Key
Key3 :: Key
Key4 :: Key
Key5 :: Key
Key6 :: Key
Key7 :: Key
Key8 :: Key
Key9 :: Key
KeySemicolon :: Key
KeyEqual :: Key
KeyA :: Key
KeyB :: Key
KeyC :: Key
KeyD :: Key
KeyE :: Key
KeyF :: Key
KeyG :: Key
KeyH :: Key
KeyI :: Key
KeyJ :: Key
KeyK :: Key
KeyL :: Key
KeyM :: Key
KeyN :: Key
KeyO :: Key
KeyP :: Key
KeyQ :: Key
KeyR :: Key
KeyS :: Key
KeyT :: Key
KeyU :: Key
KeyV :: Key
KeyW :: Key
KeyX :: Key
KeyY :: Key
KeyZ :: Key
KeyLeftBracket :: Key
KeyBackslash :: Key
KeyRightBracket :: Key
KeyGraveAccent :: Key
KeyWorld1 :: Key
KeyWorld2 :: Key
KeyEscape :: Key
KeyEnter :: Key
KeyTab :: Key
KeyBackspace :: Key
KeyInsert :: Key
KeyDelete :: Key
KeyRight :: Key
KeyLeft :: Key
KeyDown :: Key
KeyUp :: Key
KeyPageUp :: Key
KeyPageDown :: Key
KeyHome :: Key
KeyEnd :: Key
KeyCapsLock :: Key
KeyScrollLock :: Key
KeyNumLock :: Key
KeyPrintScreen :: Key
KeyPause :: Key
KeyF1 :: Key
KeyF2 :: Key
KeyF3 :: Key
KeyF4 :: Key
KeyF5 :: Key
KeyF6 :: Key
KeyF7 :: Key
KeyF8 :: Key
KeyF9 :: Key
KeyF10 :: Key
KeyF11 :: Key
KeyF12 :: Key
KeyF13 :: Key
KeyF14 :: Key
KeyF15 :: Key
KeyF16 :: Key
KeyF17 :: Key
KeyF18 :: Key
KeyF19 :: Key
KeyF20 :: Key
KeyF21 :: Key
KeyF22 :: Key
KeyF23 :: Key
KeyF24 :: Key
KeyF25 :: Key
KeyPad0 :: Key
KeyPad1 :: Key
KeyPad2 :: Key
KeyPad3 :: Key
KeyPad4 :: Key
KeyPad5 :: Key
KeyPad6 :: Key
KeyPad7 :: Key
KeyPad8 :: Key
KeyPad9 :: Key
KeyPadDecimal :: Key
KeyPadDivide :: Key
KeyPadMultiply :: Key
KeyPadSubtract :: Key
KeyPadAdd :: Key
KeyPadEnter :: Key
KeyPadEqual :: Key
KeyLeftShift :: Key
KeyLeftControl :: Key
KeyLeftAlt :: Key
KeyLeftSuper :: Key
KeyRightShift :: Key
KeyRightControl :: Key
KeyRightAlt :: Key
KeyRightSuper :: Key
KeyMenu :: Key
data BlendMode
Normal :: BlendMode
Inverse :: BlendMode
Add :: BlendMode
Multiply :: BlendMode
Screen :: BlendMode
instance Typeable Key
instance Typeable BlendMode
instance Show WindowMode
instance Eq WindowMode
instance Ord WindowMode
instance Read WindowMode
instance Enum Key
instance Eq Key
instance Ord Key
instance Read Key
instance Show Key
instance Bounded Key
instance Enum BlendMode
instance Eq BlendMode
instance Ord BlendMode
instance Read BlendMode
instance Show BlendMode


module FreeGame.Class
class Functor p => Affine p where rotateR = rotateD . (* 180) . (/ pi) rotateD = rotateR . (/ 180) . (* pi)
rotateR :: Affine p => Double -> p a -> p a
rotateD :: Affine p => Double -> p a -> p a
scale :: Affine p => Vec2 -> p a -> p a
translate :: Affine p => Vec2 -> p a -> p a

-- | The class of types that can be regarded as a kind of picture.
class Affine p => Picture2D p
bitmap :: Picture2D p => Bitmap -> p ()
bitmapOnce :: Picture2D p => Bitmap -> p ()
line :: Picture2D p => [Vec2] -> p ()
polygon :: Picture2D p => [Vec2] -> p ()
polygonOutline :: Picture2D p => [Vec2] -> p ()
circle :: Picture2D p => Double -> p ()
circleOutline :: Picture2D p => Double -> p ()
thickness :: Picture2D p => Float -> p a -> p a
color :: Picture2D p => Color Float -> p a -> p a
blendMode :: Picture2D p => BlendMode -> p a -> p a
class Affine p => Local p
getLocation :: Local p => p (Location a)
data Location a
Location :: (Vec2 -> Vec2) -> (Vec2 -> Vec2) -> Location a
coerceLocation :: Location a -> Location b
flipLocation :: Location a -> Location b
localize :: Local f => Vec2 -> f Vec2
globalize :: Local f => Vec2 -> f Vec2
rot2 :: Floating a => a -> V2 a -> V2 a
data ButtonState
Down :: ButtonState
Press :: ButtonState
Up :: ButtonState
Release :: ButtonState
ChatterDown :: ButtonState
ChatterUp :: ButtonState
buttonDown :: ButtonState -> ButtonState
buttonUp :: ButtonState -> ButtonState
buttonStay :: ButtonState -> ButtonState
isDown :: ButtonState -> Bool
isUp :: ButtonState -> Bool
isPressed :: ButtonState -> Bool
class Functor f => Keyboard f
keyStates_ :: Keyboard f => f (Map Key ButtonState)
keyStates :: Keyboard f => f (Map Key Bool)
keyPress :: Keyboard f => Key -> f Bool
keyDown :: Keyboard f => Key -> f Bool
keyUp :: Keyboard f => Key -> f Bool
class Functor f => Mouse f
globalMousePosition :: Mouse f => f Vec2
mouseButtons_ :: Mouse f => f (Map Int ButtonState)
mouseInWindow :: Mouse f => f Bool
mouseScroll :: Mouse f => f Vec2

-- | Returns the relative coordinate of the cursor.
mousePosition :: (Applicative f, Mouse f, Local f) => f Vec2
mousePositionMay :: (Applicative f, Mouse f, Local f) => f (Maybe Vec2)
mouseButtons :: Mouse f => f (Map Int Bool)
mouseButton :: Mouse f => Int -> f Bool
mouseDown :: Mouse f => Int -> f Bool
mouseUp :: Mouse f => Int -> f Bool
mouseButtonL :: Mouse f => f Bool
mouseButtonR :: Mouse f => f Bool
mouseButtonM :: Mouse f => f Bool
mouseDownL :: Mouse f => f Bool
mouseDownR :: Mouse f => f Bool
mouseDownM :: Mouse f => f Bool
mouseUpL :: Mouse f => f Bool
mouseUpR :: Mouse f => f Bool
mouseUpM :: Mouse f => f Bool
class FromFinalizer m
fromFinalizer :: FromFinalizer m => FinalizerT IO a -> m a

-- | <a>liftIO</a> variety for <a>FromFinalizer</a>.
embedIO :: FromFinalizer m => IO a -> m a
instance Functor Location
instance FromFinalizer (FinalizerT IO)
instance Affine Location


-- | Rendering characters
module FreeGame.Data.Font

-- | Font object
data Font

-- | Create a <a>Font</a> from the given file.
loadFontFromFile :: MonadIO m => FilePath -> m Font
loadFont :: MonadIO m => FilePath -> m Font

-- | Get the font's boundingbox.
fontBoundingBox :: Font -> Box V2 Double

-- | Get the font's metrics.
metricsAscent :: Font -> Double

-- | Get the font's metrics.
metricsDescent :: Font -> Double
charToBitmap :: FromFinalizer m => Font -> Double -> Char -> m RenderedChar
data RenderedChar
RenderedChar :: Bitmap -> V2 Double -> Double -> RenderedChar
charBitmap :: RenderedChar -> Bitmap
charOffset :: RenderedChar -> V2 Double
charAdvance :: RenderedChar -> Double

module FreeGame.Internal.GLFW
data System
System :: IORef Int -> IORef Double -> IORef (Seq Double) -> IORef Int -> IORef Double -> IORef BoundingBox2 -> Window -> System
refFrameCounter :: System -> IORef Int
theFPS :: System -> IORef Double
frameTimes :: System -> IORef (Seq Double)
currentFPS :: System -> IORef Int
startTime :: System -> IORef Double
refRegion :: System -> IORef BoundingBox2
theWindow :: System -> Window
trim1 :: Seq Double -> Seq Double
type Texture = (TextureObject, Double, Double)
runVertices :: MonadIO m => [V2 Double] -> m ()
preservingMatrix' :: MonadIO m => m a -> m a
drawTexture :: Texture -> IO ()
drawTextureAt :: TextureObject -> V2 Double -> V2 Double -> V2 Double -> V2 Double -> IO ()
mkVertex2 :: V2 Double -> Vertex2 GLdouble
gf :: Float -> GLfloat
gd :: Double -> GLdouble
gsizei :: Int -> GLsizei
translate :: V2 Double -> IO a -> IO a
rotateD :: Double -> IO a -> IO a
scale :: V2 Double -> IO a -> IO a
circle :: Double -> IO ()
circleOutline :: Double -> IO ()
color :: Color Float -> IO a -> IO a
polygon :: [V2 Double] -> IO ()
polygonOutline :: [V2 Double] -> IO ()
line :: [V2 Double] -> IO ()
thickness :: Float -> IO a -> IO a
installTexture :: Image PixelRGBA8 -> IO Texture
releaseTexture :: Texture -> IO ()
beginFrame :: System -> IO ()
endFrame :: System -> IO Bool
withGLFW :: WindowMode -> BoundingBox2 -> (System -> IO a) -> IO a
screenshotFlipped :: System -> IO (Image PixelRGBA8)
screenshot :: System -> IO (Image PixelRGBA8)
blendMode2BlendingFactors :: BlendMode -> (BlendingFactor, BlendingFactor)
blendMode :: BlendMode -> IO a -> IO a


-- | Provides the "free" embodiment.
module FreeGame.UI
data UI a
Draw :: (forall m. Drawable m => m a) -> UI a
PreloadBitmap :: Bitmap -> a -> UI a
FromFinalizer :: (FinalizerT IO a) -> UI a
KeyStates :: (Map Key ButtonState -> a) -> UI a
MouseButtons :: (Map Int ButtonState -> a) -> UI a
MousePosition :: (Vec2 -> a) -> UI a
MouseInWindow :: (Bool -> a) -> UI a
MouseScroll :: (Vec2 -> a) -> UI a
TakeScreenshot :: (Bitmap -> a) -> UI a
Bracket :: (Frame a) -> UI a
SetFPS :: Double -> a -> UI a
SetTitle :: String -> a -> UI a
ShowCursor :: a -> UI a
HideCursor :: a -> UI a
ClearColor :: (Color Float) -> a -> UI a
GetFPS :: (Int -> a) -> UI a
ForkFrame :: (Frame ()) -> a -> UI a
GetBoundingBox :: (BoundingBox2 -> a) -> UI a
SetBoundingBox :: BoundingBox2 -> a -> UI a
class (Applicative f, Monad f, Picture2D f, Local f) => Drawable f
reUI :: FreeGame f => UI a -> f a

-- | Generalize <a>Frame</a> to any monad based on <a>FreeGame</a>.
reFrame :: (FreeGame m, Monad m) => Frame a -> m a

-- | Generalize <a>Game</a> to any monad based on <a>FreeGame</a>.
reGame :: (FreeGame m, Monad m) => Game a -> m a
type Frame = F UI
type Game = IterT Frame
class (Picture2D m, Local m, Keyboard m, Mouse m, FromFinalizer m) => FreeGame m
draw :: FreeGame m => (forall f. Drawable f => f a) -> m a
preloadBitmap :: FreeGame m => Bitmap -> m ()
bracket :: FreeGame m => Frame a -> m a
forkFrame :: FreeGame m => Frame () -> m ()
takeScreenshot :: FreeGame m => m Bitmap
setFPS :: FreeGame m => Double -> m ()
setTitle :: FreeGame m => String -> m ()
showCursor :: FreeGame m => m ()
hideCursor :: FreeGame m => m ()
clearColor :: FreeGame m => Color Float -> m ()
getFPS :: FreeGame m => m Int
getBoundingBox :: FreeGame m => m BoundingBox2
setBoundingBox :: FreeGame m => BoundingBox2 -> m ()
instance Functor UI
instance Mouse UI
instance Keyboard UI
instance FromFinalizer UI
instance Local UI
instance Picture2D UI
instance Affine UI
instance FreeGame UI
instance (Applicative f, Monad f, Picture2D f, Local f) => Drawable f


module FreeGame.Util

-- | Delimit the computation to yield a frame.
tick :: (Monad f, MonadFree f m) => m ()

-- | An infinite loop that run <a>tick</a> every frame after the given
--   action.
foreverTick :: (Monad f, MonadFree f m) => m a -> m any

-- | <pre>
--   foreverFrame :: Frame a -&gt; Game any
--   </pre>
foreverFrame :: (Monad f, Monad m, MonadTrans t, MonadFree f (t m)) => m a -> t m any

-- | Extract the next frame of the action.
untick :: (Monad m, FreeGame m) => IterT Frame a -> m (Either (IterT Frame a) a)

-- | An infinite version of <a>untick</a>.
untickInfinite :: (Monad m, FreeGame m) => IterT Frame Void -> m (IterT Frame Void)

-- | Get a given range of value.
randomness :: (Random r, FromFinalizer m) => (r, r) -> m r

-- | Convert radians to degrees.
degrees :: Floating a => a -> a

-- | Convert degrees to radians.
radians :: Floating a => a -> a

-- | An unit vector with the specified angle.
unitV2 :: Floating a => a -> V2 a

-- | An angle of the given vector.
angleV2 :: RealFloat a => V2 a -> a

-- | Create a <tt>Picture</tt> from the given file.
loadPictureFromFile :: (Picture2D p, FromFinalizer m) => FilePath -> m (p ())

-- | Load and define all pictures in the specified directory. On base &gt;=
--   4.6, file paths to actually load will be respect to the directory of
--   the executable. Otherwise it will be based on the current directory.
loadBitmaps :: FilePath -> Q [Dec]

-- | The type of the given <a>ExpQ</a> must be <tt>FilePath -&gt; IO
--   FilePath</tt> FIXME: This may cause name duplication if there are
--   multiple non-alphanumeric file names.
loadBitmapsWith :: ExpQ -> FilePath -> Q [Dec]
charToKey :: Char -> Key
keyChar :: Keyboard f => Char -> f Bool

-- | <i>Deprecated: use keyPress instead</i>
keySpecial :: Keyboard f => Key -> f Bool

module FreeGame.Instances
instance (FreeGame m, Monad m) => FreeGame (ContT r m)
instance (FreeGame m, Monad m) => FreeGame (ExceptT e m)
instance (FreeGame m, Monad m) => FreeGame (ListT m)
instance (FreeGame m, Monad m) => FreeGame (MaybeT m)
instance (FreeGame m, Monad m) => FreeGame (IdentityT m)
instance (FreeGame m, Monad m, Monoid w) => FreeGame (RWST r w s m)
instance (FreeGame m, Monad m, Monoid w) => FreeGame (RWST r w s m)
instance (FreeGame m, Monad m, Monoid w) => FreeGame (WriterT w m)
instance (FreeGame m, Monad m, Monoid w) => FreeGame (WriterT w m)
instance (FreeGame m, Monad m) => FreeGame (StateT s m)
instance (FreeGame m, Monad m) => FreeGame (StateT s m)
instance (FreeGame m, Monad m) => FreeGame (IterT m)
instance (FreeGame m, Functor m) => FreeGame (Free m)
instance (FreeGame m, Functor m) => FreeGame (F m)
instance (FromFinalizer m, Monad m) => FromFinalizer (ContT r m)
instance (FromFinalizer m, Monad m) => FromFinalizer (ExceptT e m)
instance (FromFinalizer m, Monad m) => FromFinalizer (ListT m)
instance (FromFinalizer m, Monad m) => FromFinalizer (MaybeT m)
instance (FromFinalizer m, Monad m) => FromFinalizer (IdentityT m)
instance (FromFinalizer m, Monad m, Monoid w) => FromFinalizer (RWST r w s m)
instance (FromFinalizer m, Monad m, Monoid w) => FromFinalizer (RWST r w s m)
instance (FromFinalizer m, Monad m, Monoid w) => FromFinalizer (WriterT w m)
instance (FromFinalizer m, Monad m, Monoid w) => FromFinalizer (WriterT w m)
instance (FromFinalizer m, Monad m) => FromFinalizer (StateT s m)
instance (FromFinalizer m, Monad m) => FromFinalizer (StateT s m)
instance (FromFinalizer m, Monad m) => FromFinalizer (IterT m)
instance (FromFinalizer m, Functor m) => FromFinalizer (Free m)
instance (FromFinalizer m, Functor m) => FromFinalizer (F m)
instance (Mouse m, Monad m) => Mouse (ContT r m)
instance (Mouse m, Monad m) => Mouse (ExceptT e m)
instance (Mouse m, Monad m) => Mouse (ListT m)
instance (Mouse m, Monad m) => Mouse (MaybeT m)
instance (Mouse m, Monad m) => Mouse (IdentityT m)
instance (Mouse m, Monad m, Monoid w) => Mouse (RWST r w s m)
instance (Mouse m, Monad m, Monoid w) => Mouse (RWST r w s m)
instance (Mouse m, Monad m, Monoid w) => Mouse (WriterT w m)
instance (Mouse m, Monad m, Monoid w) => Mouse (WriterT w m)
instance (Mouse m, Monad m) => Mouse (StateT s m)
instance (Mouse m, Monad m) => Mouse (StateT s m)
instance (Mouse m, Monad m) => Mouse (ReaderT r m)
instance (Mouse m, Monad m) => Mouse (IterT m)
instance (Mouse m, Functor m) => Mouse (Free m)
instance (Mouse m, Functor m) => Mouse (F m)
instance (Keyboard m, Monad m) => Keyboard (ContT r m)
instance (Keyboard m, Monad m) => Keyboard (ExceptT e m)
instance (Keyboard m, Monad m) => Keyboard (ListT m)
instance (Keyboard m, Monad m) => Keyboard (MaybeT m)
instance (Keyboard m, Monad m) => Keyboard (IdentityT m)
instance (Keyboard m, Monad m, Monoid w) => Keyboard (RWST r w s m)
instance (Keyboard m, Monad m, Monoid w) => Keyboard (RWST r w s m)
instance (Keyboard m, Monad m, Monoid w) => Keyboard (WriterT w m)
instance (Keyboard m, Monad m, Monoid w) => Keyboard (WriterT w m)
instance (Keyboard m, Monad m) => Keyboard (StateT s m)
instance (Keyboard m, Monad m) => Keyboard (StateT s m)
instance (Keyboard m, Monad m) => Keyboard (ReaderT s m)
instance (Keyboard m, Monad m) => Keyboard (IterT m)
instance (Keyboard m, Functor m) => Keyboard (Free m)
instance (Keyboard m, Functor m) => Keyboard (F m)
instance (Local m, Monad m) => Local (ContT r m)
instance (Local m, Monad m) => Local (ExceptT e m)
instance (Local m, Monad m) => Local (ListT m)
instance (Local m, Monad m) => Local (MaybeT m)
instance (Local m, Monad m) => Local (IdentityT m)
instance (Local m, Monad m, Monoid w) => Local (RWST r w s m)
instance (Local m, Monad m, Monoid w) => Local (RWST r w s m)
instance (Local m, Monad m, Monoid w) => Local (WriterT w m)
instance (Local m, Monad m, Monoid w) => Local (WriterT w m)
instance (Local m, Monad m) => Local (StateT s m)
instance (Local m, Monad m) => Local (StateT s m)
instance (Local m, Monad m) => Local (ReaderT s m)
instance (Local m, Monad m) => Local (IterT m)
instance (Local m, Functor m) => Local (Free m)
instance (Local m, Functor m) => Local (F m)
instance (Picture2D m, Monad m) => Picture2D (ContT r m)
instance (Picture2D m, Monad m) => Picture2D (ExceptT e m)
instance (Picture2D m, Monad m) => Picture2D (ListT m)
instance (Picture2D m, Monad m) => Picture2D (MaybeT m)
instance (Picture2D m, Monad m) => Picture2D (IdentityT m)
instance (Picture2D m, Monad m, Monoid w) => Picture2D (RWST r w s m)
instance (Picture2D m, Monad m, Monoid w) => Picture2D (RWST r w s m)
instance (Picture2D m, Monad m, Monoid w) => Picture2D (WriterT w m)
instance (Picture2D m, Monad m, Monoid w) => Picture2D (WriterT w m)
instance (Picture2D m, Monad m) => Picture2D (StateT s m)
instance (Picture2D m, Monad m) => Picture2D (StateT s m)
instance (Picture2D m, Monad m) => Picture2D (ReaderT r m)
instance (Picture2D m, Monad m) => Picture2D (IterT m)
instance (Picture2D m, Functor m) => Picture2D (Free m)
instance (Picture2D m, Functor m) => Picture2D (F m)
instance (Affine m, Monad m) => Affine (ContT r m)
instance (Affine m, Monad m) => Affine (ExceptT e m)
instance (Affine m, Monad m) => Affine (ListT m)
instance (Affine m, Monad m) => Affine (MaybeT m)
instance (Affine m, Monad m) => Affine (IdentityT m)
instance (Affine m, Monad m, Monoid w) => Affine (RWST r w s m)
instance (Affine m, Monad m, Monoid w) => Affine (RWST r w s m)
instance (Affine m, Monad m, Monoid w) => Affine (WriterT w m)
instance (Affine m, Monad m, Monoid w) => Affine (WriterT w m)
instance (Affine m, Monad m) => Affine (StateT s m)
instance (Affine m, Monad m) => Affine (StateT s m)
instance (Affine m, Monad m) => Affine (ReaderT r m)
instance (Affine m, Monad m) => Affine (IterT m)
instance (Affine m, Functor m) => Affine (Free m)
instance (Affine m, Functor m) => Affine (F m)

module FreeGame.Text
data TextF a
TypeChar :: Char -> a -> TextF a
type TextT = FreeT TextF

-- | Render a <a>TextT</a>.
runTextT :: (FromFinalizer m, Monad m, Picture2D m) => Maybe (Box V2 Double) -> Font -> Double -> TextT m a -> m a
runTextT_ :: (FromFinalizer m, Monad m, Picture2D m) => Maybe (Box V2 Double) -> Font -> Double -> TextT m () -> m ()

-- | Render a <a>String</a>.
text :: (FromFinalizer m, Monad m, Picture2D m) => Font -> Double -> String -> m ()
instance Functor TextF
instance Monad m => IsString (TextT m ())


module FreeGame.Backend.GLFW
runGame :: WindowMode -> BoundingBox2 -> IterT (F UI) a -> IO (Maybe a)
instance Local DrawM
instance (Given Context, Given TextureStorage) => Picture2D DrawM
instance Affine DrawM


module FreeGame
type Game = IterT Frame

-- | <a>Game</a> is a kind of procedure but you can also use it like a
--   value. free-game's design is based on free structures, however, you
--   don't have to mind it -- Just apply <a>runGame</a>, and enjoy.
--   
--   
--   For more examples, see
--   <a>https://github.com/fumieval/free-game/tree/master/examples</a>.
runGame :: WindowMode -> BoundingBox2 -> Game a -> IO (Maybe a)
runGameDefault :: Game a -> IO (Maybe a)

-- | Generalize <a>Game</a> to any monad based on <a>FreeGame</a>.
reGame :: (FreeGame m, Monad m) => Game a -> m a
data WindowMode
Windowed :: WindowMode
Resizable :: WindowMode
FullScreen :: WindowMode
type BoundingBox2 = Box V2 Double

-- | The type of bounding box for arbitrary vector <tt>f</tt>. The
--   functions for this type assume that <tt>f</tt> is a "zipping"
--   <a>Applicative</a>.
data Box (f :: * -> *) a :: (* -> *) -> * -> *
Box :: f a -> f a -> Box a

-- | check whether the point is in the box.
isInside :: (Applicative f, Foldable f, Ord a) => f a -> Box f a -> Bool

-- | Adds an extra layer to a free monad value.
--   
--   In particular, for the iterative monad <a>Iter</a>, this makes the
--   computation require one more step, without changing its final result.
--   
--   <pre>
--   runIter (delay ma) == Right ma
--   </pre>
delay :: (Monad f, MonadFree f m) => m a -> m a

-- | Delimit the computation to yield a frame.
tick :: (Monad f, MonadFree f m) => m ()

-- | <pre>
--   foreverFrame :: Frame a -&gt; Game any
--   </pre>
foreverFrame :: (Monad f, Monad m, MonadTrans t, MonadFree f (t m)) => m a -> t m any

-- | Extract the next frame of the action.
untick :: (Monad m, FreeGame m) => IterT Frame a -> m (Either (IterT Frame a) a)

-- | An infinite version of <a>untick</a>.
untickInfinite :: (Monad m, FreeGame m) => IterT Frame Void -> m (IterT Frame Void)
type Frame = F UI

-- | Generalize <a>Frame</a> to any monad based on <a>FreeGame</a>.
reFrame :: (FreeGame m, Monad m) => Frame a -> m a
class (Picture2D m, Local m, Keyboard m, Mouse m, FromFinalizer m) => FreeGame m
draw :: FreeGame m => (forall f. Drawable f => f a) -> m a
preloadBitmap :: FreeGame m => Bitmap -> m ()
bracket :: FreeGame m => Frame a -> m a
forkFrame :: FreeGame m => Frame () -> m ()
takeScreenshot :: FreeGame m => m Bitmap
setFPS :: FreeGame m => Double -> m ()
setTitle :: FreeGame m => String -> m ()
showCursor :: FreeGame m => m ()
hideCursor :: FreeGame m => m ()
clearColor :: FreeGame m => Color Float -> m ()
getFPS :: FreeGame m => m Int
getBoundingBox :: FreeGame m => m BoundingBox2
setBoundingBox :: FreeGame m => BoundingBox2 -> m ()
type Vec2 = V2 Double
class Functor p => Affine p where rotateR = rotateD . (* 180) . (/ pi) rotateD = rotateR . (/ 180) . (* pi)
rotateR :: Affine p => Double -> p a -> p a
rotateD :: Affine p => Double -> p a -> p a
scale :: Affine p => Vec2 -> p a -> p a
translate :: Affine p => Vec2 -> p a -> p a
class Affine p => Local p
globalize :: Local f => Vec2 -> f Vec2
localize :: Local f => Vec2 -> f Vec2
class (Applicative f, Monad f, Picture2D f, Local f) => Drawable f

-- | The class of types that can be regarded as a kind of picture.
class Affine p => Picture2D p
bitmap :: Picture2D p => Bitmap -> p ()
bitmapOnce :: Picture2D p => Bitmap -> p ()
line :: Picture2D p => [Vec2] -> p ()
polygon :: Picture2D p => [Vec2] -> p ()
polygonOutline :: Picture2D p => [Vec2] -> p ()
circle :: Picture2D p => Double -> p ()
circleOutline :: Picture2D p => Double -> p ()
thickness :: Picture2D p => Float -> p a -> p a
color :: Picture2D p => Color Float -> p a -> p a
blendMode :: Picture2D p => BlendMode -> p a -> p a
data BlendMode
Normal :: BlendMode
Inverse :: BlendMode
Add :: BlendMode
Multiply :: BlendMode
Screen :: BlendMode
data Bitmap

-- | Get the size of the <a>Bitmap</a>.
bitmapSize :: Bitmap -> (Int, Int)

-- | Load an image file.
readBitmap :: MonadIO m => FilePath -> m Bitmap

-- | Extract a <a>Bitmap</a> from the specified range.
cropBitmap :: Bitmap -> (Int, Int) -> (Int, Int) -> Bitmap
clipBitmap :: Bitmap -> Box V2 Int -> Bitmap

-- | Load and define all pictures in the specified directory. On base &gt;=
--   4.6, file paths to actually load will be respect to the directory of
--   the executable. Otherwise it will be based on the current directory.
loadBitmaps :: FilePath -> Q [Dec]

-- | The type of the given <a>ExpQ</a> must be <tt>FilePath -&gt; IO
--   FilePath</tt> FIXME: This may cause name duplication if there are
--   multiple non-alphanumeric file names.
loadBitmapsWith :: ExpQ -> FilePath -> Q [Dec]

-- | Save <a>Bitmap</a> into a file.
writeBitmap :: MonadIO m => FilePath -> Bitmap -> m ()

-- | Font object
data Font
loadFont :: MonadIO m => FilePath -> m Font

-- | Render a <a>String</a>.
text :: (FromFinalizer m, Monad m, Picture2D m) => Font -> Double -> String -> m ()
class Functor f => Keyboard f
keyStates_ :: Keyboard f => f (Map Key ButtonState)
data Key
KeyUnknown :: Key
KeySpace :: Key
KeyApostrophe :: Key
KeyComma :: Key
KeyMinus :: Key
KeyPeriod :: Key
KeySlash :: Key
Key0 :: Key
Key1 :: Key
Key2 :: Key
Key3 :: Key
Key4 :: Key
Key5 :: Key
Key6 :: Key
Key7 :: Key
Key8 :: Key
Key9 :: Key
KeySemicolon :: Key
KeyEqual :: Key
KeyA :: Key
KeyB :: Key
KeyC :: Key
KeyD :: Key
KeyE :: Key
KeyF :: Key
KeyG :: Key
KeyH :: Key
KeyI :: Key
KeyJ :: Key
KeyK :: Key
KeyL :: Key
KeyM :: Key
KeyN :: Key
KeyO :: Key
KeyP :: Key
KeyQ :: Key
KeyR :: Key
KeyS :: Key
KeyT :: Key
KeyU :: Key
KeyV :: Key
KeyW :: Key
KeyX :: Key
KeyY :: Key
KeyZ :: Key
KeyLeftBracket :: Key
KeyBackslash :: Key
KeyRightBracket :: Key
KeyGraveAccent :: Key
KeyWorld1 :: Key
KeyWorld2 :: Key
KeyEscape :: Key
KeyEnter :: Key
KeyTab :: Key
KeyBackspace :: Key
KeyInsert :: Key
KeyDelete :: Key
KeyRight :: Key
KeyLeft :: Key
KeyDown :: Key
KeyUp :: Key
KeyPageUp :: Key
KeyPageDown :: Key
KeyHome :: Key
KeyEnd :: Key
KeyCapsLock :: Key
KeyScrollLock :: Key
KeyNumLock :: Key
KeyPrintScreen :: Key
KeyPause :: Key
KeyF1 :: Key
KeyF2 :: Key
KeyF3 :: Key
KeyF4 :: Key
KeyF5 :: Key
KeyF6 :: Key
KeyF7 :: Key
KeyF8 :: Key
KeyF9 :: Key
KeyF10 :: Key
KeyF11 :: Key
KeyF12 :: Key
KeyF13 :: Key
KeyF14 :: Key
KeyF15 :: Key
KeyF16 :: Key
KeyF17 :: Key
KeyF18 :: Key
KeyF19 :: Key
KeyF20 :: Key
KeyF21 :: Key
KeyF22 :: Key
KeyF23 :: Key
KeyF24 :: Key
KeyF25 :: Key
KeyPad0 :: Key
KeyPad1 :: Key
KeyPad2 :: Key
KeyPad3 :: Key
KeyPad4 :: Key
KeyPad5 :: Key
KeyPad6 :: Key
KeyPad7 :: Key
KeyPad8 :: Key
KeyPad9 :: Key
KeyPadDecimal :: Key
KeyPadDivide :: Key
KeyPadMultiply :: Key
KeyPadSubtract :: Key
KeyPadAdd :: Key
KeyPadEnter :: Key
KeyPadEqual :: Key
KeyLeftShift :: Key
KeyLeftControl :: Key
KeyLeftAlt :: Key
KeyLeftSuper :: Key
KeyRightShift :: Key
KeyRightControl :: Key
KeyRightAlt :: Key
KeyRightSuper :: Key
KeyMenu :: Key
charToKey :: Char -> Key
keyPress :: Keyboard f => Key -> f Bool
keyUp :: Keyboard f => Key -> f Bool
keyDown :: Keyboard f => Key -> f Bool
class Functor f => Mouse f
mouseInWindow :: Mouse f => f Bool
mouseScroll :: Mouse f => f Vec2
mousePositionMay :: (Applicative f, Mouse f, Local f) => f (Maybe Vec2)

-- | Returns the relative coordinate of the cursor.
mousePosition :: (Applicative f, Mouse f, Local f) => f Vec2
mouseButtonL :: Mouse f => f Bool
mouseButtonR :: Mouse f => f Bool
mouseButtonM :: Mouse f => f Bool
mouseDownL :: Mouse f => f Bool
mouseDownR :: Mouse f => f Bool
mouseDownM :: Mouse f => f Bool
mouseUpL :: Mouse f => f Bool
mouseUpR :: Mouse f => f Bool
mouseUpM :: Mouse f => f Bool
class FromFinalizer m

-- | <a>liftIO</a> variety for <a>FromFinalizer</a>.
embedIO :: FromFinalizer m => IO a -> m a

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Get a given range of value.
randomness :: (Random r, FromFinalizer m) => (r, r) -> m r

-- | An unit vector with the specified angle.
unitV2 :: Floating a => a -> V2 a

-- | An angle of the given vector.
angleV2 :: RealFloat a => V2 a -> a

-- | Convert radians to degrees.
degrees :: Floating a => a -> a

-- | Convert degrees to radians.
radians :: Floating a => a -> a
keyChar :: Keyboard f => Char -> f Bool

-- | <i>Deprecated: use keyPress instead</i>
keySpecial :: Keyboard f => Key -> f Bool
instance MonadIO Frame
