-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Symbolic computations in strict monoidal categories with LaTeX output.
--   
--   Symbolic computations in strict monoidal categories with LaTeX output.
--   See 'monocle-usage.pdf' and 'monocle-test.hs' included in package. One
--   of goals of this project is to develop the tool for automatic drawing
--   diagrams of morphisms and proofs in form suitable for LaTeX (e.g. for
--   XY-pic).
@package Monocle
@version 0.0.4

module Monocle.Utils
class Monoid monoid => MStack stack monoid
pop :: MStack stack monoid => stack -> (stack, monoid)
push :: MStack stack monoid => monoid -> stack -> stack
tappend :: MStack stack monoid => monoid -> stack -> stack
tcombine :: MStack stack monoid => (monoid -> monoid) -> stack -> stack
class Printable a
str :: Printable a => a -> String
data Wrap a
Wrap :: a -> Wrap a
instance Show a => Printable (Wrap a)
instance (Printable a, Printable b) => Printable (a, b)
instance Printable String
instance Monoid monoid => MStack [monoid] monoid

module Monocle.Core

-- | Class of morphisms.
class Eq a => Morphism a
dom :: Morphism a => a -> a
cod :: Morphism a => a -> a
isId :: Morphism a => a -> Bool
(\.) :: Morphism a => a -> a -> a
(\*) :: Morphism a => a -> a -> a

-- | Types of the functional modifier.
data FuncT

-- | Function on objects
Function :: FuncT

-- | Covariant functor
Functor :: FuncT

-- | Contravariant functor
Cofunctor :: FuncT

-- | Morphism data type
data Mor a

-- | Atomary morphism
Arrow :: a -> (ArrowData a) -> Mor a

-- | Identity morphism
Id :: a -> Mor a

-- | Tensor product of morphisms
Tensor :: [Mor a] -> Mor a

-- | Composition of morphisms
Composition :: [Mor a] -> Mor a

-- | Functionional modifier
Func :: String -> [Mor a] -> FuncT -> Mor a

-- | Naturally transformational modifier
Transform :: String -> (Mor a) -> [Mor a] -> Mor a

-- | Normalizes the term representing morphism, e.g. turns <tt>((a \* b) \*
--   c)</tt> to <tt>(a \* b \* c)</tt>
nrm :: Eq t => Mor t -> Mor t

-- | Checks whether morphism is an atomary formula.
atomary :: Eq t => Mor t -> Bool

-- | Creates <a>Arrow</a> by morphism information (e.g. name), domain and
--   codomain.
arrow :: a -> Mor a -> Mor a -> Mor a

-- | Creates generalized element, i.e. an arrow from the identity object to
--   the given object.
element :: a -> Mor a -> Mor a

-- | Creates generalized coelement, i.e. an arrow from the the given object
--   to the identity object.
coelement :: a -> Mor a -> Mor a

-- | Creates object (actually its id). Same as <a>objectId</a>.
object :: a -> Mor a

-- | Creates object id. Same as <a>object</a>.
objectId :: a -> Mor a

-- | Identity object, <tt>tid \* f == f</tt> in strict monoidal category.
tid :: Mor a

-- | Turns recursively <tt>(a \* b) \. (c \* d)</tt> to <tt>(a \. c) \* (b
--   \. d)</tt>.
vert :: Eq a => Mor a -> Mor a

-- | Turns recursively <tt>(a \. c) \* (b \. d)</tt> to <tt>(a \* b) \. (c
--   \* d)</tt>.
horz :: Eq a => Mor a -> Mor a

-- | Collects atomary subterms of the given arrow as keys of the map.
collect :: (Num b, Ord a) => Mor a -> Map (Mor a) b

-- | Rule type
data Rule a

-- | Declares equality of two morphisms
DefEqual :: (Mor a) -> (Mor a) -> Rule a

-- | <tt>x \== y</tt> is the same as <tt><a>DefEqual</a> x y</tt>
(\==) :: Mor a -> Mor a -> Rule a

-- | Applies the <a>Rule</a> to the given morphism
apply :: Eq a => Rule String -> Mor a -> Mor a
instance Eq a => Eq (Mor a)
instance Ord a => Ord (Mor a)
instance Eq FuncT
instance Ord FuncT
instance Eq a => Eq (ArrowData a)
instance Ord a => Ord (ArrowData a)
instance (Printable a, Eq a) => Show (Rule a)
instance (Printable a, Eq a) => Show (Mor a)
instance (Printable a, Eq a) => Printable (Mor a)
instance Eq a => Morphism (Mor a)

module Monocle.Markup

-- | Labelled arrow data type.
data Lab a
MArrow :: (Mor a) -> String -> Lab a
MId :: (Mor a) -> String -> Lab a
MTensor :: [Lab a] -> String -> Lab a
MComposition :: [Lab a] -> String -> Lab a
MFunc :: String -> [Lab a] -> FuncT -> String -> Lab a
MTransform :: String -> (Lab a) -> [Mor a] -> String -> Lab a

-- | Returns the given morphism marked up.
markup :: Mor a -> Lab a

-- | Removes labels and returns corresponding <a>Mor</a>.
unmark :: Eq a => Lab a -> Mor a

-- | <pre>
--   modif s lf op == <a>unmark</a> $ <a>modif'</a> s lf op
--   </pre>
modif :: Eq a => String -> Lab a -> (Mor a -> Mor a) -> Mor a

-- | Applies operation to the marked subterm of the given morphism.
modif' :: Eq a => String -> Lab a -> (Mor a -> Mor a) -> Lab a

-- | Applies operation to the marked subterm of the given morphism.
modifLab :: String -> Lab a -> (Lab a -> Lab a) -> Lab a

-- | Chooses subterm of an associative operation (composition or tensor
--   product).
choose :: String -> Int -> Int -> Lab a -> Lab a

-- | Returns the label of the given marked morphism.
getLabel :: Lab a -> String
instance Eq a => Eq (Lab a)
instance Ord a => Ord (Lab a)
instance Eq a => Morphism (Lab a)

module Monocle.Tex

-- | Class providing information in LaTeX form.
class Texified a
tex :: Texified a => a -> String
doc :: Texified a => a -> String

-- | Returns LaTeX description of an object of category
texObj :: Printable t => Mor t -> String

-- | <pre>
--   ptex f = do <a>putStrLn</a> $ <a>tex</a> f
--   </pre>
ptex :: Texified a => a -> IO ()

-- | <pre>
--   pobj f = do <a>putStrLn</a> $ <a>texObj</a> f
--   </pre>
pobj :: Printable t => Mor t -> IO ()

-- | <pre>
--   pdoc f = do <a>putStrLn</a> $ <a>doc</a> f
--   </pre>
pdoc :: Texified a => a -> IO ()
instance (Printable a, Ord a) => Texified (Lab a)
instance (Printable a, Ord a) => Texified (Rule a)
instance (Printable a, Ord a) => Texified (Mor a)

module Monocle.Rules

-- | For given object create it's left dual:
--   <a>http://en.wikipedia.org/wiki/Dual_object</a>.
ldual'of :: Mor a -> Mor a

-- | Same as <a>ldual'of</a>, for usage in calculations.
ldual :: Mor a -> Mor a

-- | Same as <a>ldual'of</a>, for usage in rule descriptions.
ldual'r :: Mor a -> Mor a

-- | For given object create it's right dual:
--   <a>http://en.wikipedia.org/wiki/Dual_object</a>.
rdual'of :: Mor a -> Mor a

-- | Same as <a>rdual'of</a>, for usage in calculations.
rdual :: Mor a -> Mor a

-- | Same as <a>rdual'of</a>, for usage in rule descriptions.
rdual'r :: Mor a -> Mor a

-- | For given dual pair of objects <tt>(x, y)</tt> and name <tt>nm</tt>
--   call <tt>unit'of nm x y</tt> to create named duality unit arrow.
--   Generates error if <tt>(x, y)</tt> is not a dual pair.
unit'of :: Eq a => a -> Mor a -> Mor a -> Mor a

-- | Same as <tt><a>unit'of</a> "\\eta"</tt>, for usage in calculations.
unit :: Mor String -> Mor String -> Mor String

-- | Same as <tt><a>unit'of</a> "*\\eta"</tt>, except that it does not
--   check duality. For usage in rule descriptions.
unit'r :: Mor String -> Mor String -> Mor String

-- | For given dual pair of objects <tt>(x, y)</tt> and name <tt>nm</tt>
--   call <tt>counit'of nm x y</tt> to create named duality counit arrow.
--   Generates error if <tt>(x, y)</tt> is not a dual pair.
counit'of :: Eq a => a -> Mor a -> Mor a -> Mor a

-- | Same as <tt><a>counit'of</a> "\\epsilon"</tt>, for usage in
--   calculations.
counit :: Mor String -> Mor String -> Mor String

-- | Same as <tt><a>counit'of</a> "*\\epsilon"</tt>, except that it does
--   not check duality. For usage in rule descriptions.
counit'r :: Mor String -> Mor String -> Mor String

-- | One of "zigzag rules" for duality.
zigzag'rule'Left :: Rule String

-- | One of "zigzag rules" for duality.
zigzag'rule'Right :: Rule String

-- | For given pair of objects <tt>(x, y)</tt> and name <tt>nm</tt> call
--   <tt>braid'of nm x y</tt> to create named braid arrow:
--   <a>http://en.wikipedia.org/wiki/Braided_monoidal_category</a>
braid'of :: Eq a => a -> Mor a -> Mor a -> Mor a

-- | Same as <tt><a>braid'of</a> "\\beta"</tt>, for usage in calculations.
braid :: Mor String -> Mor String -> Mor String

-- | Same as <tt><a>braid'of</a> "*\\beta"</tt>, for usage in rule
--   descriptions.
braid'r :: Mor String -> Mor String -> Mor String

-- | For given pair of objects <tt>(x, y)</tt> and name <tt>nm</tt> call
--   <tt>unbraid'of nm x y</tt> to create named unbraid arrow (inverse of
--   braid arrow).
unbraid'of :: Eq a => a -> Mor a -> Mor a -> Mor a

-- | Same as <tt><a>unbraid'of</a> "\\beta^{-1}"</tt>, for usage in
--   calculations.
unbraid :: Mor String -> Mor String -> Mor String

-- | Same as <tt><a>unbraid'of</a> "*\\beta^{-1}"</tt>, for usage in rule
--   descriptions.
unbraid'r :: Mor String -> Mor String -> Mor String

-- | Isomorphism rule: <a>unbraid</a> as inverse of <a>braid</a>.
braid'rule'Iso'Left :: Rule String

-- | Isomorphism rule: <a>braid</a> as inverse of <a>unbraid</a>.
braid'rule'Iso'Right :: Rule String

-- | Naturality rule on the "left wire".
braid'rule'Nat'Left :: Rule String

-- | Naturality rule on the "right wire".
braid'rule'Nat'Right :: Rule String

-- | Hexagon identity for <a>braid</a>, strict monoidal case.
braid'rule'Hex'Braid :: Rule String

-- | Hexagon identity for <a>unbraid</a>, strict monoidal case.
braid'rule'Hex'Unbraid :: Rule String

-- | Rule for the "cross" arrow: it's simply self-inverse braid.
cross'rule :: Rule String

-- | For given object <tt>x</tt> and name <tt>nm</tt> call <tt>twist'of nm
--   x</tt> to create named twist arrow.
twist'of :: Eq a => a -> Mor a -> Mor a

-- | Same as <tt><a>twist'of</a> "\\theta"</tt>, for usage in calculations.
twist :: Mor String -> Mor String

-- | Same as <tt><a>twist'of</a> "*\\theta"</tt>, for usage in rule
--   descriptions.
twist'r :: Mor String -> Mor String

-- | For given object <tt>x</tt> and name <tt>nm</tt> call <tt>untwist'of
--   nm x</tt> to create named untwist arrow.
untwist'of :: Eq a => a -> Mor a -> Mor a

-- | Same as <tt><a>untwist'of</a> "\\theta^{-1}"</tt>, for usage in
--   calculations.
untwist :: Mor String -> Mor String

-- | Same as <tt><a>untwist'of</a> "*\\theta^{-1}"</tt>, for usage in rule
--   descriptions.
untwist'r :: Mor String -> Mor String

-- | Isomorphism rule: <a>untwist</a> as inverse of <a>twist</a>.
twist'rule'Iso'Left :: Rule String

-- | Isomorphism rule: <a>twist</a> as inverse of <a>untwist</a>.
twist'rule'Iso'Right :: Rule String

-- | Twisting the identity object changes nothing.
twist'rule'Id :: Rule String

-- | Twisting naturality.
twist'rule'Natural :: Rule String

-- | Twist/braid interaction.
twist'rule'Braid :: Rule String

-- | <tt>dagger'of f</tt> creates daggered version of the arrow <tt>f</tt>.
dagger'of :: Eq a => Mor a -> Mor a

-- | Same as <a>dagger'of</a>, for usage in calculations.
dagger :: Eq a => Mor a -> Mor a

-- | Same as <a>dagger'of</a>, for usage in rule descriptions.
dagger'r :: Eq a => Mor a -> Mor a

-- | As contravariant functor <a>dagger</a> maps id's to id's.
dagger'rule'Id :: Rule String

-- | <a>dagger</a> is contravariant functor, i.e. inverts composition
--   order.
dagger'rule'Cofunctor :: Rule String

-- | <a>dagger</a> involution rule.
dagger'rule'Inv :: Rule String

module Monocle
