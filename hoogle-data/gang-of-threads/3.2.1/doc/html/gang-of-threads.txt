-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Non-deterministic parallelism with bags
--   
--   Package implementing a bag-of-tasks approach to parallelism. This is
--   an approach to non-deterministic parallelism, where non-deterministic
--   means that the order of multiple values from the same set depends on
--   the scheduling.
@package gang-of-threads
@version 3.2.1


-- | This module only contains the type <a>BufferType</a>.
module Control.Concurrent.Bag.BufferType

-- | The type of a buffer. At this time you can only select between
--   <a>Queue</a> and <a>Stack</a>.
data BufferType

-- | A first in first out (FIFO) buffer.
Queue :: BufferType

-- | A last in first out (LIFO) buffer.
Stack :: BufferType


-- | A simple stack implementation with an concurrent access functions
--   similar to that of <a>Chan</a>. In contrast to <a>Chan</a>, which is a
--   FIFO buffer, this type is a LIFO buffer.
module Control.Concurrent.Stack

-- | Concurrent stack.
data Stack a

-- | Build and return a new instance of <a>Stack</a>.
newStack :: IO (Stack a)

-- | Read the next value from the <a>Stack</a>.
readStack :: Stack a -> IO a

-- | Write a value into the <a>Stack</a>.
writeStack :: Stack a -> a -> IO ()


-- | A simple stack implementation with an concurrent STM access functions
--   similar to that of <tt>TChan</tt>. In contrast to <tt>TChan</tt>,
--   which is a FIFO buffer, <a>TStack</a> is a LIFO buffer.
module Control.Concurrent.STM.TStack

-- | Concurrent STM stakc.
data TStack a

-- | Build and return a new instance of <a>TStack</a>.
newTStack :: STM (TStack a)

-- | Write a value into the <a>TStack</a>.
writeTStack :: TStack a -> a -> STM ()

-- | Read the next value from the <a>TStack</a>.
readTStack :: TStack a -> STM a

-- | Check whether the <a>TStack</a> is empty.
isEmptyTStack :: TStack a -> STM Bool

-- | Try to read the next value from the <a>TStack</a>.
tryReadTStack :: TStack a -> STM (Maybe a)


-- | This module contains the definition of a task buffer in the <a>STM</a>
--   monad, <a>TaskBufferSTM</a>, and possible split functions besides the
--   functions to create a <a>Stack</a> and a <a>Queue</a> buffer.
module Control.Concurrent.Bag.TaskBufferSTM

-- | A buffer holding tasks.
--   
--   For this type, all access functions are using the <a>STM</a> monad.
--   
--   Note, that this is not a type class because we want to allow the user
--   to select between multiple buffers other than on type level.
data TaskBufferSTM a
TaskBufferSTM :: (a -> STM ()) -> (a -> STM ()) -> STM a -> STM (Maybe a) -> STM Bool -> TaskBufferSTM a

-- | Function to write an item into the buffer in the normal way.
writeBufferSTM :: TaskBufferSTM a -> a -> STM ()

-- | Function to write an item into the buffer at the read end.
unGetBufferSTM :: TaskBufferSTM a -> a -> STM ()

-- | Function to read item from the buffer. Blocks if empty.
readBufferSTM :: TaskBufferSTM a -> STM a

-- | Function to try to read an item from the buffer. Returns
--   <a>Nothing</a> if empty.
tryReadBufferSTM :: TaskBufferSTM a -> STM (Maybe a)

-- | Check whether the buffer is empty.
isEmptyBufferSTM :: TaskBufferSTM a -> STM Bool

-- | The type of a buffer. At this time you can only select between
--   <a>Queue</a> and <a>Stack</a>.
data BufferType

-- | A first in first out (FIFO) buffer.
Queue :: BufferType

-- | A last in first out (LIFO) buffer.
Stack :: BufferType

-- | Split functions are used to split the contents of the source buffer
--   into two parts. One part is left in this buffer or put back later; the
--   other part is written into the sink buffer. One element of this part
--   is returned in the STM monad. This is why the source buffer should
--   always have at least one item available. If it has not, the action
--   will suspend.
type SplitFunction r = TaskBufferSTM (IO (Maybe r)) -> TaskBufferSTM (IO (Maybe r)) -> STM (IO (Maybe r))

-- | Just take the first item from the source buffer.
takeFirst :: SplitFunction r

-- | Split the buffer vertically. Every other element of the source remains
--   there. All other elements are put into the sink buffer.
splitVertical :: SplitFunction r

-- | Split the buffer in two halves. Takes one half out of the source
--   buffer and puts it into the sink buffer.
splitHalf :: SplitFunction r

-- | Create a new Queue buffer from a <a>TChan</a>.
newChanBufferSTM :: STM (TaskBufferSTM r)

-- | Create a new Stack buffer from a <a>TStack</a>.
newStackBufferSTM :: STM (TaskBufferSTM r)


-- | This is a low-level interface to the bag of tasks, which should only
--   be used if it is not possible to use
--   <a>Control.Concurrent.Bag.Safe</a> for your task. This module allows
--   more control but it also requires a deeper knowledge about the
--   implementation.
module Control.Concurrent.Bag.Basic

-- | The bag of tasks type.
data Bag r

-- | Build and return a new bag of tasks
newBag :: MonadIO m => BufferType -> Maybe (SplitFunction r) -> Int -> m (Bag r)

-- | Build and return a new bag of tasks with a default number of worker
--   threads.
newBag_ :: MonadIO m => BufferType -> Maybe (SplitFunction r) -> m (Bag r)

-- | Add the evaluation of a haskell expression.
--   
--   The given expression will be evaluated to weak head normal form.
addEval :: MonadIO m => Bag r -> r -> m ()

-- | Add a task to the given bag of tasks.
addTask :: MonadIO m => Bag r -> IO (Maybe r) -> m ()

-- | Get the next result written by <a>writeResult</a>.
getResult :: MonadIO m => Bag r -> m (Maybe r)

-- | Write back a result to be read by <a>getResult</a>.
writeResult :: MonadIO m => Bag r -> r -> m ()

-- | Terminates all threads running in the thread pool. <a>terminateBag</a>
--   is non-blocking and therefore does not guarantee that all threads are
--   terminated after its executions. Additionally it is not guaranteed
--   that the treads are terminated promptly. It is implemented using
--   asynchronous exceptions and therefore it terminates a thread once it
--   uses a <i>safe point</i>. A safe point is where memory allocation
--   occurs. Although most tasks will have some point of memory allocation
--   now and the, there are loops that will never reach a safe point.
terminateBag :: MonadIO m => Bag r -> m ()

-- | Tell the bag that there will be no more tasks from the outside,
--   however, queued tasks may still add new tasks.
noMoreTasks :: MonadIO m => Bag r -> m ()


-- | A monad transformer implementation for processing the results of a bag
--   of tasks computation. Using a processor based on the <a>BagT</a>
--   transformer allows the calculation of values to be aborted immediately
--   after running the processor.
--   
--   This can be use by some of the bag of tasks interfaces such as
--   <a>Control.Concurrent.Bag.Safe</a> and
--   <a>Control.Concurrent.Bag.SafeConcurrent</a>.
module Control.Concurrent.Bag.BagT

-- | A monad transformer for processing the results of the bag
--   sequencially. In addition to the actions available in the base monad,
--   which has to be an instance of MonadIO in all functions, it provides
--   the action <a>getResult</a> to get a result of the bag.
newtype BagT r m a
BagT :: ReaderT (m (Maybe r)) m a -> BagT r m a
getBagReader :: BagT r m a -> ReaderT (m (Maybe r)) m a

-- | Get a result of the bag if there is one. If it returns Nothing, all
--   tasks have been processed and there are no results left.
--   <tt>getResults</tt> blocks until a task has been evaluated to a result
--   or all tasks are processed. Therefore it may block forever.
getResult :: MonadIO m => BagT r m (Maybe r)

-- | Convenience function to get all results from the bag of tasks.
getAllResults :: MonadIO m => BagT a m [a]
instance MonadIO m => MonadIO (BagT r m)
instance MonadTrans (BagT r)
instance Monad m => Monad (BagT r m)
instance Monad m => Applicative (BagT r m)
instance Monad m => Functor (BagT r m)


-- | This module contains the definition of a task buffer in the <a>IO</a>
--   monad, <a>TaskBuffer</a>, and the functions to create a <a>Stack</a>
--   and a <a>Queue</a> buffer.
module Control.Concurrent.Bag.TaskBuffer

-- | A buffer holding tasks.
--   
--   For this type, all access functions use the <a>IO</a> monad.
data TaskBuffer a
TaskBuffer :: (a -> IO ()) -> IO a -> TaskBuffer a
writeBuffer :: TaskBuffer a -> a -> IO ()
readBuffer :: TaskBuffer a -> IO a

-- | The type of a buffer. At this time you can only select between
--   <a>Queue</a> and <a>Stack</a>.
data BufferType

-- | A first in first out (FIFO) buffer.
Queue :: BufferType

-- | A last in first out (LIFO) buffer.
Stack :: BufferType

-- | Create a new Queue buffer from a <a>Chan</a>.
newChanBuffer :: IO (TaskBuffer r)

-- | Create a new Stack buffer from a <a>Stack</a>.
newStackBuffer :: IO (TaskBuffer r)


-- | This is a low-level interface to the bag of tasks. This implementation
--   does not use stm in contrast to the other implementation. This
--   implementation is provided for performance comparision. This
--   implementation should only be used if it is not possible to use
--   <i>Control.Concurrent.Bag.SafeConcurrent</i> for your task. This
--   module allows more control but it also requires a deeper knowledge
--   about the implementation.
module Control.Concurrent.Bag.Concurrent

-- | The bag of tasks type.
data Bag r

-- | Build and return a new bag of tasks.
newBag :: MonadIO m => BufferType -> Int -> m (Bag r)

-- | Create a new bag and use the number of capabilities as the thread
--   count.
newBag_ :: MonadIO m => BufferType -> m (Bag r)

-- | Add the evaluation of a haskell expression.
--   
--   The given expression will be evaluated to weak head normal form.
addEval :: MonadIO m => Bag r -> r -> m ()

-- | Add a task to the given bag of tasks.
addTask :: MonadIO m => Bag r -> IO (Maybe r) -> m ()

-- | Get the next result written by <a>writeResult</a>.
getResult :: MonadIO m => Bag r -> m (Maybe r)

-- | Write back a result to be read by <a>getResult</a>.
writeResult :: MonadIO m => Bag r -> r -> m ()

-- | Terminates all threads running in the thread pool. <a>terminateBag</a>
--   is non-blocking and therefore does not guarantee that all threads are
--   terminated after its executions. Additionally it is not guaranteed
--   that the treads are terminated promptly. It is implemented using
--   asynchronous exceptions and therefore it terminates a thread once it
--   uses a <i>safe point</i>. A safe point is where memory allocation
--   occurs. Although most tasks will have some point of memory allocation
--   now and the, there are loops that will never reach a safe point.
terminateBag :: MonadIO m => Bag r -> m ()

-- | Tell the bag that there will be no more tasks from the outside,
--   however, queued tasks may still add new tasks.
noMoreTasks :: MonadIO m => Bag r -> m ()


-- | Task implementations <a>Interruptible</a> and <a>TaskIO</a>. These can
--   be use by some of the bag of tasks interfaces such as
--   <a>Control.Concurrent.Bag.Implicit</a> and
--   <a>Control.Concurrent.Bag.ImplicitConcurrent</a>.
module Control.Concurrent.Bag.Task

-- | A monad in which tasks can be specified. Task is instancing
--   <a>MonadIO</a> and it therefore has the function <a>liftIO</a> to
--   perform arbitrary IO actions. Tasks may or may not return a value. If
--   it returns a value, this value is written back as a result.
--   Additionally there is a function <tt>addTask</tt> to add new tasks to
--   the bag. The parameter <i>r</i> is the result type of the
--   corresponding bag. In contrast to <a>Interruptible</a> the evaluation
--   order is simililar to that of the IO monad and tasks added by
--   addTaskIO are added immediately.
data TaskIO r a

-- | Run a task as an <a>IO</a> action.
runTaskIO :: TaskIO r (Maybe r) -> AddTask r -> WriteResult r -> IO (Maybe r)

-- | Add a task to the bag of tasks from another task. The task will be
--   added immediately.
addTaskIO :: TaskIO r (Maybe r) -> TaskIO r ()

-- | Write back a result from a task.
writeResult :: r -> TaskIO r ()

-- | A type to specify interruptible tasks. Interruptible tasks are tasks
--   that can be interrupted and resumed later. Basically this means that
--   the evaluating thread may be killed in between. Side-effects in this
--   code are not allowed, and therefore all interrupted tasks have to be
--   pure functional in contrast to <a>TaskIO</a> tasks. Otherwise this is
--   similar to <a>TaskIO</a>.
data Interruptible r
NoResult :: Interruptible r
OneResult :: r -> Interruptible r
AddInterruptibles :: [Interruptible r] -> Interruptible r

-- | Run the given interruptible task with interruptions.
--   
--   Note: When using this function, it may be possible that some tasks are
--   never completed, because the time to produce an intermediate result is
--   longer than the interruption frequency.
runInterrupted :: Interruptible r -> TaskIO r (Maybe r)

-- | Run the given interruptible task.
--   
--   Run with this function, the task will not be interrupted.
runInterruptible :: Interruptible r -> TaskIO r (Maybe r)

-- | Function to write back a result.
type WriteResult r = r -> IO ()

-- | Function to add a task to the bag of tasks.
type AddTask r = IO (Maybe r) -> IO ()
instance MonadIO (TaskIO r)
instance Monad (TaskIO r)
instance Applicative (TaskIO r)
instance Functor (TaskIO r)


-- | High level bag of tasks interface based on
--   <a>Control.Concurrent.Concurrent</a>. Tasks can only return results
--   and add new tasks as intended and it is not possible to add new tasks
--   from the outside or from the action processing the results. This way
--   it is possible to ensure that <tt>getResults</tt> returns only
--   <a>Nothing</a> if it is safe to say that there will be no results
--   anymore.
module Control.Concurrent.Bag.SafeConcurrent

-- | A monad transformer for processing the results of the bag
--   sequencially. In addition to the actions available in the base monad,
--   which has to be an instance of MonadIO in all functions, it provides
--   the action <a>getResult</a> to get a result of the bag.
data BagT r m a

-- | Initializes a new bag of tasks and starts a gang of workers threads.
--   The number of worker threads is equal to the number of capabilities of
--   the Haskell runtime (see <a>getNumCapabilities</a>).
--   
--   __WARNING__: If it may be necessary to terminate the thread pool, i.e.
--   because the result processing function does not always request all
--   values, you have to make sure that the task can be stopped.
--   Terminating the tasks is done with asynchronous exceptions which can
--   only be received at a emph{safe point}. Safe points are all points
--   where memory allocation is requested, but there are calculations and
--   also loops which never need any new memory. These calculations cannot
--   be terminated and may run forever, see the documentation of
--   <a>throwTo</a>.
newTaskBag :: MonadIO m => BufferType -> [TaskIO r (Maybe r)] -> BagT r m a -> m a

-- | Like <a>newTaskBag</a>, but it takes a list of expressions that will
--   be evaluated to weak head normal form using <a>seq</a>.
--   
--   __WARNING__: This does not evaluate to normal form, but only to weak
--   head normal form.
newEvalBag :: MonadIO m => BufferType -> [r] -> BagT r m a -> m a

-- | Similar to <a>newTaskBag</a>, but taking a list of
--   <a>Interruptible</a> instead of tasks.
newInterruptibleBag :: MonadIO m => BufferType -> [Interruptible r] -> BagT r m a -> m a

-- | Similar to <a>newInterruptibleBag</a>, but interrupts the tasks in
--   certain intervals. Using a <a>TChan</a> as buffer, this ensures
--   completeness: all tasks that have a result will get their time to
--   evaluate it. Note, that calculations, that do no memory allocation,
--   cannot be interrupted.
newInterruptingBag :: MonadIO m => BufferType -> [Interruptible r] -> BagT r m a -> m a

-- | Get a result of the bag if there is one. If it returns Nothing, all
--   tasks have been processed and there are no results left.
--   <tt>getResults</tt> blocks until a task has been evaluated to a result
--   or all tasks are processed. Therefore it may block forever.
getResult :: MonadIO m => BagT r m (Maybe r)

-- | Convenience function to get all results from the bag of tasks.
getAllResults :: MonadIO m => BagT a m [a]

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Lift a computation from the argument monad to the constructed monad.
lift :: MonadTrans t => forall (m :: * -> *) a. Monad m => m a -> t m a

-- | The type of a buffer. At this time you can only select between
--   <a>Queue</a> and <a>Stack</a>.
data BufferType

-- | A first in first out (FIFO) buffer.
Queue :: BufferType

-- | A last in first out (LIFO) buffer.
Stack :: BufferType


-- | High level bag of tasks interface based on
--   <a>Control.Concurrent.Bag.Basic</a>. Tasks can only return results and
--   add new tasks as intended and it is not possible to add new tasks from
--   the outside or from the action processing the results. This way it is
--   possible to ensure that <tt>getResults</tt> returns only
--   <a>Nothing</a> if it is safe to say that there will be no results
--   anymore.
module Control.Concurrent.Bag.Safe

-- | A monad transformer for processing the results of the bag
--   sequencially. In addition to the actions available in the base monad,
--   which has to be an instance of MonadIO in all functions, it provides
--   the action <a>getResult</a> to get a result of the bag.
data BagT r m a

-- | Initializes a new bag of tasks and starts a gang of workers threads.
--   The number of worker threads is equal to the number of capabilities of
--   the Haskell runtime (see <a>getNumCapabilities</a>).
--   
--   __WARNING__: If it may be necessary to terminate the thread pool, i.e.
--   because the result processing function does not always request all
--   values, you have to make sure that the task can be stopped.
--   Terminating the tasks is done with asynchronous exceptions which can
--   only be received at a emph{safe point}. Safe points are all points
--   where memory allocation is requested, but there are calculations and
--   also loops which never need any new memory. These calculations cannot
--   be terminated and may run forever, see the documentation of
--   <a>throwTo</a>.
newTaskBag :: MonadIO m => BufferType -> Maybe (SplitFunction r) -> [TaskIO r (Maybe r)] -> BagT r m a -> m a

-- | Like <a>newTaskBag</a>, but it takes a list of expressions that will
--   be evaluated to weak head normal form using <a>seq</a>.
--   
--   __WARNING__: This does not evaluate to normal form, but only to weak
--   head normal form.
newEvalBag :: MonadIO m => BufferType -> Maybe (SplitFunction r) -> [r] -> BagT r m a -> m a

-- | Similar to <a>newTaskBag</a>, but taking a list of
--   <a>Interruptible</a> instead of tasks.
newInterruptibleBag :: MonadIO m => BufferType -> Maybe (SplitFunction r) -> [Interruptible r] -> BagT r m a -> m a

-- | Similar to <a>newInterruptibleBag</a>, but interrupts the tasks in
--   certain intervals. Using a <a>TChan</a> as buffer, this ensures
--   completeness: all tasks that have a result will get their time to
--   evaluate it. Note, that calculations, that do no memory allocation,
--   cannot be interrupted.
newInterruptingBag :: MonadIO m => BufferType -> Maybe (SplitFunction r) -> [Interruptible r] -> BagT r m a -> m a

-- | Get a result of the bag if there is one. If it returns Nothing, all
--   tasks have been processed and there are no results left.
--   <tt>getResults</tt> blocks until a task has been evaluated to a result
--   or all tasks are processed. Therefore it may block forever.
getResult :: MonadIO m => BagT r m (Maybe r)

-- | Convenience function to get all results from the bag of tasks.
getAllResults :: MonadIO m => BagT a m [a]

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Lift a computation from the argument monad to the constructed monad.
lift :: MonadTrans t => forall (m :: * -> *) a. Monad m => m a -> t m a

-- | A buffer holding tasks.
--   
--   For this type, all access functions are using the <a>STM</a> monad.
--   
--   Note, that this is not a type class because we want to allow the user
--   to select between multiple buffers other than on type level.
data TaskBufferSTM a
TaskBufferSTM :: (a -> STM ()) -> (a -> STM ()) -> STM a -> STM (Maybe a) -> STM Bool -> TaskBufferSTM a

-- | Function to write an item into the buffer in the normal way.
writeBufferSTM :: TaskBufferSTM a -> a -> STM ()

-- | Function to write an item into the buffer at the read end.
unGetBufferSTM :: TaskBufferSTM a -> a -> STM ()

-- | Function to read item from the buffer. Blocks if empty.
readBufferSTM :: TaskBufferSTM a -> STM a

-- | Function to try to read an item from the buffer. Returns
--   <a>Nothing</a> if empty.
tryReadBufferSTM :: TaskBufferSTM a -> STM (Maybe a)

-- | Check whether the buffer is empty.
isEmptyBufferSTM :: TaskBufferSTM a -> STM Bool

-- | Split functions are used to split the contents of the source buffer
--   into two parts. One part is left in this buffer or put back later; the
--   other part is written into the sink buffer. One element of this part
--   is returned in the STM monad. This is why the source buffer should
--   always have at least one item available. If it has not, the action
--   will suspend.
type SplitFunction r = TaskBufferSTM (IO (Maybe r)) -> TaskBufferSTM (IO (Maybe r)) -> STM (IO (Maybe r))

-- | Just take the first item from the source buffer.
takeFirst :: SplitFunction r

-- | The type of a buffer. At this time you can only select between
--   <a>Queue</a> and <a>Stack</a>.
data BufferType

-- | A first in first out (FIFO) buffer.
Queue :: BufferType

-- | A last in first out (LIFO) buffer.
Stack :: BufferType


-- | High level bag of tasks interface based on
--   <a>Control.Concurrent.Bag.Basic</a>. Tasks can only return results and
--   add new tasks as intended and it is not possible to add new tasks from
--   the outside or from the action processing the results.
module Control.Concurrent.Bag.Implicit

-- | Build and start a new task bag.
--   
--   The returned list is not evaluated yet, but will be evaluated on
--   demand later. Already computed results will be kept in a buffer until
--   the result list is evaluated. If the result list gets garbage
--   collected, the bag of tasks will be stopped automatically.
newTaskBag :: BufferType -> Maybe (SplitFunction r) -> [TaskIO r (Maybe r)] -> IO [r]

-- | Like <a>newTaskBag</a>, but it takes a list of expressions that will
--   be evaluated to weak head normal form using <a>seq</a>.
--   
--   __WARNING__: This does not evaluate to normal form, but only to weak
--   head normal form.
newEvalBag :: BufferType -> Maybe (SplitFunction r) -> [r] -> IO [r]

-- | Split functions are used to split the contents of the source buffer
--   into two parts. One part is left in this buffer or put back later; the
--   other part is written into the sink buffer. One element of this part
--   is returned in the STM monad. This is why the source buffer should
--   always have at least one item available. If it has not, the action
--   will suspend.
type SplitFunction r = TaskBufferSTM (IO (Maybe r)) -> TaskBufferSTM (IO (Maybe r)) -> STM (IO (Maybe r))

-- | Just take the first item from the source buffer.
takeFirst :: SplitFunction r

-- | Similar to <a>newInterruptibleBag</a>, but interrupts the tasks in
--   certain intervals. Using a <a>TChan</a> as buffer, this ensures
--   completeness: all tasks that have a result will get their time to
--   evaluate it. Note, that calculations, that do no memory allocation,
--   cannot be interrupted.
newInterruptingBag :: BufferType -> Maybe (SplitFunction r) -> [Interruptible r] -> IO [r]

-- | Similar to <a>newTaskBag</a>, but taking a list of
--   <a>Interruptible</a> instead of tasks.
newInterruptibleBag :: BufferType -> Maybe (SplitFunction r) -> [Interruptible r] -> IO [r]

-- | The type of a buffer. At this time you can only select between
--   <a>Queue</a> and <a>Stack</a>.
data BufferType

-- | A first in first out (FIFO) buffer.
Queue :: BufferType

-- | A last in first out (LIFO) buffer.
Stack :: BufferType


-- | High level bag of tasks interface based on
--   <a>Control.Concurrent.Bag.Concurrent</a>. Tasks can only return
--   results and add new tasks as intended and it is not possible to add
--   new tasks from the outside or from the action processing the results.
module Control.Concurrent.Bag.ImplicitConcurrent

-- | Build and start a new task bag.
--   
--   The returned list is not evaluated yet, but will be evaluated on
--   demand later. Already computed results will be kept in a buffer until
--   the result list is evaluated. If the result list gets garbage
--   collected, the bag of tasks will be stopped automatically.
newTaskBag :: BufferType -> [TaskIO r (Maybe r)] -> IO [r]

-- | Like <a>newTaskBag</a>, but it takes a list of expressions that will
--   be evaluated to weak head normal form using <a>seq</a>.
--   
--   __WARNING__: This does not evaluate to normal form, but only to weak
--   head normal form.
newEvalBag :: BufferType -> [r] -> IO [r]

-- | Similar to <a>newTaskBag</a>, but interrupts the tasks in certain
--   intervals. Using a <a>TChan</a> as buffer, this ensures completeness:
--   all tasks that have a result will get their time to evaluate it. Note,
--   that calculations, that do no memory allocation, cannot be
--   interrupted.
newInterruptingBag :: BufferType -> [Interruptible r] -> IO [r]

-- | Similar to <a>newTaskBag</a>, but taking a list of
--   <a>Interruptible</a> instead of tasks.
newInterruptibleBag :: BufferType -> [Interruptible r] -> IO [r]

-- | The type of a buffer. At this time you can only select between
--   <a>Queue</a> and <a>Stack</a>.
data BufferType

-- | A first in first out (FIFO) buffer.
Queue :: BufferType

-- | A last in first out (LIFO) buffer.
Stack :: BufferType
