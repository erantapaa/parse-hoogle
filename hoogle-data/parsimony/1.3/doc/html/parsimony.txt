-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monadic parser combinators derived from Parsec
--   
--   Parsimony is a generalized and simplified version of the
--   industrial-strength parser combinator library Parsec. Like Parsec, it
--   is simple, safe, well documented, convenient, with good error
--   messages, and fast. In addition, Parsimony adds support for working
--   with differet types of input such as byte strings (for compat input
--   representation) and lazy byte strings (for parsing large amounts of
--   data). It also supports working with text in different character
--   encodings such as UTF8.
@package parsimony
@version 1.3


-- | Textual source positions.
module Parsimony.Pos
type SourceName = String
type Line = Int
type Column = Int
data SourcePos
sourceLine :: SourcePos -> Line
sourceColumn :: SourcePos -> Column
sourceName :: SourcePos -> SourceName
incSourceLine :: SourcePos -> Line -> SourcePos
incSourceColumn :: SourcePos -> Column -> SourcePos
setSourceLine :: SourcePos -> Line -> SourcePos
setSourceColumn :: SourcePos -> Column -> SourcePos
setSourceName :: SourcePos -> SourceName -> SourcePos
newPos :: SourceName -> Line -> Column -> SourcePos
initialPos :: SourceName -> SourcePos
updatePosChar :: SourcePos -> Char -> SourcePos
updatePosString :: SourcePos -> String -> SourcePos
instance Eq SourcePos
instance Ord SourcePos
instance Show SourcePos


-- | Parse errors
module Parsimony.Error
data Message
SysUnExpect :: !String -> Message
UnExpect :: !String -> Message
Expect :: !String -> Message
Message :: !String -> Message
messageString :: Message -> String
messageCompare :: Message -> Message -> Ordering
messageEq :: Message -> Message -> Bool
data ParseError
errorPos :: ParseError -> SourcePos
errorMessages :: ParseError -> [Message]
errorIsUnknown :: ParseError -> Bool

-- | Language independent show function
showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
newErrorMessage :: Message -> SourcePos -> ParseError
newErrorUnknown :: SourcePos -> ParseError
addErrorMessage :: Message -> ParseError -> ParseError
setErrorPos :: SourcePos -> ParseError -> ParseError
setErrorMessage :: Message -> ParseError -> ParseError
mergeError :: ParseError -> ParseError -> ParseError
instance Show ParseError


-- | A generic way to extract tokens from a stream.
module Parsimony.Stream

-- | A class describing useful token operations.
class Token token
updatePos :: Token token => token -> SourcePos -> SourcePos
showToken :: Token token => token -> String

-- | Streams of tokens.
class Token token => Stream stream token | stream -> token
getToken :: Stream stream token => PrimParser stream token
instance Stream Text Char
instance Stream Text Char
instance Stream ByteString Word8
instance Stream ByteString Word8
instance Token a => Stream [a] a
instance Token Word8
instance Token Char


-- | Commonly used character parsers.
module Parsimony.Char
spaces :: Stream s Char => Parser s ()
space :: Stream s Char => Parser s Char
newline, tab :: Stream s Char => Parser s ()
upper, octDigit, hexDigit, digit, letter, alphaNum, lower :: Stream s Char => Parser s Char
char :: Stream s Char => Char -> Parser s ()
string :: Stream s Char => String -> Parser s ()
anyChar :: Stream s Char => Parser s Char
oneOf, noneOf :: Stream s Char => [Char] -> Parser s Char
satisfy :: Stream s Char => (Char -> Bool) -> Parser s Char


-- | Support for parsers with custom state.
module Parsimony.UserState

-- | The type of parsers with a user state.
type ParserU u s = Parser (UserState u s)

-- | An input stream annotated with some user state.
data UserState user stream
UserState :: !user -> !stream -> UserState user stream
userState :: UserState user stream -> !user
parserStream :: UserState user stream -> !stream

-- | Turn a parser without user space into ine that supports user state
--   manipulation.
lifted :: Parser s a -> ParserU u s a

-- | Get the user state.
getUserState :: ParserU u s u

-- | Set the user state.
setUserState :: u -> ParserU u s ()

-- | Update the user state.
updateUserState :: (u -> u) -> ParserU u s ()
uparse :: ParserU u s a -> u -> s -> Either ParseError a
uparseSource :: ParserU u s a -> u -> SourceName -> s -> Either ParseError a
instance Stream stream token => Stream (UserState user stream) token


-- | Utilities for parsing content from files.
module Parsimony.IO

-- | Parse a text file in one go. This functions loads the whole file in
--   memory.
parseFile :: FilePath -> Parser Text a -> IO (Either ParseError a)

-- | Parse a text file in chunks. This functions loads the file in chunks.
parseLargeFile :: FilePath -> Parser Text a -> IO (Either ParseError a)

-- | Parse a binary file in one go. This functions loads the whole file in
--   memory.
parseBinaryFile :: FilePath -> Parser ByteString a -> IO (Either ParseError a)

-- | Parse a text file in chunks. This functions loads the file in chunks.
parseLargeBinaryFile :: FilePath -> Parser ByteString a -> IO (Either ParseError a)

-- | Parse a text file in one go, using user state. This functions loads
--   the whole file in memory.
uparseFile :: FilePath -> ParserU u Text a -> u -> IO (Either ParseError a)

-- | Parse a text file in chunks, using user state. This functions loads
--   the file in chunks.
uparseLargeFile :: FilePath -> ParserU u Text a -> u -> IO (Either ParseError a)

-- | Parse a binary file in one go, using user state. This functions loads
--   the whole file in memory.
uparseBinaryFile :: FilePath -> ParserU u ByteString a -> u -> IO (Either ParseError a)

-- | Parse a text file in chunks, using user state. This functions loads
--   the file in chunks.
uparseLargeBinaryFile :: FilePath -> ParserU u ByteString a -> u -> IO (Either ParseError a)


-- | The basics of the Parsimony library.
module Parsimony

-- | A parser constructing values of type <tt>a</tt>, with an input buffer
--   of type <tt>t</tt>.
data Parser t a

-- | Apply a parser to the given input.
parse :: Parser t a -> t -> Either ParseError a

-- | Apply a parser to the given named input.
parseSource :: Parser t a -> SourceName -> t -> Either ParseError a

-- | Convert a parser into a <a>PrimParser</a>.
runParser :: Parser t a -> PrimParser t a

-- | An associative binary operation
(<|>) :: Alternative f => forall a. f a -> f a -> f a

-- | Allow a parser to back-track. The resulting parser behaves like the
--   input parser unless it fails. In that case, we backtrack without
--   consuming any input. Because we may have to back-track, we keep a hold
--   of the parser input so over-use of this function may result in memory
--   leaks.
try :: Parser t a -> Parser t a

-- | The resulting parser behaves like one of the parsers in the list. The
--   chosen parser is the first one that (i) consumes some input, or (ii)
--   succeeds with a result.
choice :: [Parser t a] -> Parser t a

-- | Apply a parser repeatedly, and collect the results in a list.
many :: Parser t a -> Parser t [a]

-- | Apply a parser repeatedly, and collect the results in a list. The
--   resulting list is guaranteed to be at leats of length one.
many1 :: Parser t a -> Parser t [a]

-- | Apply a parser repeatedly, ignoring the results. We stop when an
--   application of the parser fails without consuming any input. If the
--   parser fails after it has consumed some input, then the repeated
--   parser will also fail.
skipMany :: Parser t a -> Parser t ()

-- | Skip at leats one occurance of input recognized by the parser.
skipMany1 :: Parser t a -> Parser t ()

-- | Produces a parser that succeeds if it can extract the list of values
--   specified by the list. The function argument specifies how to show the
--   expectations in error messages.
match :: Eq a => (a -> String) -> [a] -> Parser t a -> Parser t ()
sepBy :: Parser t a -> Parser t sep -> Parser t [a]
sepBy1 :: Parser t a -> Parser t sep -> Parser t [a]
endBy1, endBy :: Parser t a -> Parser t sep -> Parser t [a]
sepEndBy :: Parser t a -> Parser t sep -> Parser t [a]
sepEndBy1 :: Parser t a -> Parser t sep -> Parser t [a]

-- | Parse a list of values recognized by the given parser. The sequence of
--   values should be terminated by a pattern recognized by the terminator
--   patser. The terminator is tried before the value pattern, so if there
--   is overlap between the two, the terminator is recognized.
manyTill :: Parser t a -> Parser t end -> Parser t [a]
count :: Int -> Parser t a -> Parser t [a]

-- | Apply a parser repeatedly, combining the results with the given
--   functions. This function is similar to the strict <a>foldl</a>. We
--   stop when an application of the parser fails without consuming any
--   input. If the parser fails after it has consumed some input, then the
--   repeated parser will also fail.
foldMany :: (b -> a -> b) -> b -> Parser t a -> Parser t b

-- | Behaves like the parameter parser, unless it fails without consuming
--   any input. In that case we succeed with the given value.
option :: a -> Parser t a -> Parser t a

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | Sequential application.
(<*>) :: Applicative f => forall a b. f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => forall a b. f a -> f b -> f a

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => forall a b. f a -> f b -> f b

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => forall a b. a -> f b -> f a

-- | Lift a value.
pure :: Applicative f => forall a. a -> f a
between :: Parser t open -> Parser t close -> Parser t a -> Parser t a
skip :: Parser t a -> Parser t ()

-- | Matches the end of the input (i.e., when there are no more tokens to
--   extract).
eof :: Stream s t => Parser s ()

-- | Succeeds if the given parser fails. Uses the <a>Show</a> instance of
--   the result type in error messages.
notFollowedBy :: Show a => Parser t a -> Parser t ()

-- | Succeeds if the given parser fails. The function is used to display
--   the result in error messages.
notFollowedBy' :: (a -> String) -> Parser t a -> Parser t ()

-- | Applies the given parser without consuming any input.
lookAhead :: Parser t a -> Parser t a

-- | Matches any token. Fails if there are no more tokens left.
anyToken :: Stream s t => Parser s t
data ParseError
errorPos :: ParseError -> SourcePos

-- | Specify the name to be used if the given parser fails.
(<?>) :: Parser t a -> String -> Parser t a
unexpected :: String -> Parser t a

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => forall a. f a

-- | Fail with the given parser error without consuming any input. The
--   error is applied to the current source position.
parseError :: (SourcePos -> ParseError) -> Parser t a

-- | The resulting parser behaves like the input parser, except that in
--   case of failure we use the given expectation messages.
labels :: Parser t a -> [String] -> Parser t a

-- | The parser state.
data State t
State :: !t -> !SourcePos -> State t

-- | Token source
stateInput :: State t -> !t

-- | Current position
statePos :: State t -> !SourcePos
setState :: State t -> Parser t ()

-- | Modify the current parser state. Returns the old state. Does not
--   consume input.
updateState :: (State s -> State s) -> Parser s ()

-- | Change the input stream of a parser. This is useful for extending the
--   input stream with extra information. The first function splits the
--   extended state into a state suitable for use by the given parser and
--   some additional information. The second function combines the extra
--   infomration of the original state with the new partial state, to
--   compute a new extended state.
mapState :: (State big -> (State small, extra)) -> (State small -> extra -> State big) -> Parser small a -> Parser big a
getInput :: Parser t t
setInput :: t -> Parser t ()
updateInput :: (t -> t) -> Parser t ()
data SourcePos
type SourceName = String
type Line = Int
type Column = Int
getPosition :: Parser t SourcePos
setPosition :: SourcePos -> Parser t ()
updatePosition :: (SourcePos -> SourcePos) -> Parser t ()
type PrimParser s a = State s -> Reply s a
data Reply s a
Ok :: !a -> !State s -> Reply s a
Error :: !ParseError -> Reply s a

-- | Define a primitive parser. Consumes input on success.
primParser :: PrimParser t a -> Parser t a
