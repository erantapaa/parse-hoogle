-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple streaming I/O library based on monadic folds
--   
--   <tt>simple-conduit</tt> follows a similar UI to the more capable
--   <tt>conduit</tt> library, but reduces the scope of what it can solve
--   down to what can be expressed by chaining monadic folds that allow for
--   early termination. This allows for more predictable resource
--   management behavior, at the cost of not allowing scenarios that
--   <tt>conduit</tt> is better designed.
@package simple-conduit
@version 0.5.1


-- | Please see the project README for more details:
--   
--   
--   https:<i></i>github.com<i>jwiegley</i>simple-conduit<i>blob</i>master/README.md
--   
--   Also see this blog article:
--   
--   https:<i></i>www.newartisans.com<i>2014</i>06/simpler-conduit-library
module Conduit.Simple.Core

-- | A Source is a short-circuiting monadic fold.
--   
--   <a>Source</a> forms a Monad that behaves as <tt>ListT</tt>; for
--   example:
--   
--   <pre>
--   do x &lt;- yieldMany [1..3]
--      line &lt;- sourceFile <a>foo.txt</a>
--      return (x, line)
--   </pre>
--   
--   This yields the cross-product of [3] and the lines in the files, but
--   only reading chunks from the file as needed by the sink.
--   
--   To skip to the next value in a Source, use the function <a>skip</a> or
--   <a>mempty</a>; to close the source, use <a>close</a>. For example:
--   
--   <pre>
--   do x &lt;- yieldMany [1..10]
--      if x == 2 || x == 9
--      then return x
--      else if x &lt; 5
--           then skip
--           else close
--   </pre>
--   
--   This outputs the list <tt>[2]</tt>.
--   
--   A key difference from the <tt>conduit</tt> library is that monadic
--   chaining of sources with <a>&gt;&gt;</a> follows <tt>ListT</tt>, and
--   not concatenation as in conduit. To achieve conduit-style behavior,
--   use the Monoid instance:
--   
--   <pre>
--   &gt;&gt;&gt; sinkList $ yieldMany [1..3] &lt;&gt; yieldMany [4..6]
--   [1,2,3,4,5,6]
--   </pre>
newtype Source m a
Source :: (forall r. Cont (r -> EitherT r m r) a) -> Source m a
getSource :: Source m a -> forall r. Cont (r -> EitherT r m r) a

-- | A <a>Conduit</a> is a <a>Source homomorphism</a>, or simple a mapping
--   between sources. There is no need for it to be a type synonym, except
--   to save repetition across type signatures.
type Conduit a m b = Source m a -> Source m b

-- | A <a>Sink</a> folds a <a>Source</a> down to its result value. It is
--   simply a convenient type synonym for functions mapping a <a>Source</a>
--   to some result type.
type Sink a m r = Source m a -> m r

-- | Promote any sink to a source. This can be used as if it were a source
--   transformer (aka, a conduit):
--   
--   <pre>
--   &gt;&gt;&gt; sinkList $ returnC $ sumC $ mapC (+1) $ yieldMany [1..10]
--   [65]
--   </pre>
--   
--   Note that <a>returnC</a> is a synonym for <a>lift</a>.
returnC :: Monad m => m a -> Source m a
prod :: Source m (Cont (r -> EitherT r m r) (Source m a)) -> Cont (r -> EitherT r m r) (Source m a)
close :: Monad m => Source m a
skip :: Monad m => Source m a
runSource :: Source m a -> r -> (r -> a -> EitherT r m r) -> EitherT r m r
lowerSource :: (Monad m, Monoid a) => Source m a -> m a
source :: (forall r. r -> (r -> a -> EitherT r m r) -> EitherT r m r) -> Source m a
conduit :: (forall r. r -> (r -> b -> EitherT r m r) -> a -> EitherT r m r) -> Conduit a m b

-- | Most of the time conduits pass the fold variable through unmolested,
--   but sometimes you need to ignore that variable and use your own within
--   a stage of the pipeline. This is done by wrapping the fold variable in
--   a tuple and then unwrapping it when the conduit is done.
--   <a>conduitWith</a> makes this transparent.
conduitWith :: Monad m => s -> (forall r. (r, s) -> (r -> b -> EitherT (r, s) m (r, s)) -> a -> EitherT (r, s) m (r, s)) -> Conduit a m b
unwrap :: Monad m => EitherT a m a -> m a
rewrap :: Monad m => (a -> b) -> EitherT a m a -> EitherT b m b
sink :: Monad m => r -> (r -> a -> EitherT r m r) -> Sink a m r
awaitForever :: (a -> Source m b) -> Conduit a m b
instance Functor (Source m)
instance Foldable (Source Identity)
instance MonadMask m => MonadMask (Source m)
instance MonadCatch m => MonadCatch (Source m)
instance MonadThrow m => MonadThrow (Source m)
instance MonadError e m => MonadError e (Source m)
instance MonadWriter w m => MonadWriter w (Source m)
instance MonadState s m => MonadState s (Source m)
instance MonadReader r m => MonadReader r (Source m)
instance (Functor f, MonadFree f m) => MonadFree f (Source m)
instance MonadTrans Source
instance MonadIO m => MonadIO (Source m)
instance MMonad Source
instance MFunctor Source
instance Monad (Source m)
instance Applicative (Source m)
instance Monad m => MonadPlus (Source m)
instance Monad m => Alternative (Source m)
instance Monad m => Monoid (Source m a)
instance Monad m => Semigroup (Source m a)

module Conduit.Simple.Compat

-- | Compose a <a>Source</a> and a <a>Conduit</a> into a new <a>Source</a>.
--   Note that this is just flipped function application, so ($) can be
--   used to achieve the same thing.
($=) :: a -> (a -> b) -> b

-- | Compose a <a>Conduit</a> and a <a>Sink</a> into a new <a>Sink</a>.
--   Note that this is just function composition, so (.) can be used to
--   achieve the same thing.
(=$) :: (a -> b) -> (b -> c) -> a -> c

-- | Compose two <a>Conduit</a>. This is also just function composition.
(=$=) :: (a -> b) -> (b -> c) -> a -> c

-- | Compose a <a>Source</a> and a <a>Sink</a> and compute the result. Note
--   that this is just flipped function application, so ($) can be used to
--   achieve the same thing.
($$) :: a -> (a -> b) -> b

-- | Sequence a collection of sources.
--   
--   <pre>
--   &gt;&gt;&gt; sinkList $ sequenceSources [yieldOne 1, yieldOne 2, yieldOne 3]
--   [[1,2,3]]
--   </pre>
sequenceSources :: (Traversable f, Monad m) => f (Source m a) -> Source m (f a)


-- | Please see the project README for more details:
--   
--   
--   https:<i></i>github.com<i>jwiegley</i>simple-conduit<i>blob</i>master/README.md
--   
--   Also see this blog article:
--   
--   https:<i></i>www.newartisans.com<i>2014</i>06/simpler-conduit-library
module Conduit.Simple

-- | A Source is a short-circuiting monadic fold.
--   
--   <a>Source</a> forms a Monad that behaves as <tt>ListT</tt>; for
--   example:
--   
--   <pre>
--   do x &lt;- yieldMany [1..3]
--      line &lt;- sourceFile <a>foo.txt</a>
--      return (x, line)
--   </pre>
--   
--   This yields the cross-product of [3] and the lines in the files, but
--   only reading chunks from the file as needed by the sink.
--   
--   To skip to the next value in a Source, use the function <a>skip</a> or
--   <a>mempty</a>; to close the source, use <a>close</a>. For example:
--   
--   <pre>
--   do x &lt;- yieldMany [1..10]
--      if x == 2 || x == 9
--      then return x
--      else if x &lt; 5
--           then skip
--           else close
--   </pre>
--   
--   This outputs the list <tt>[2]</tt>.
--   
--   A key difference from the <tt>conduit</tt> library is that monadic
--   chaining of sources with <a>&gt;&gt;</a> follows <tt>ListT</tt>, and
--   not concatenation as in conduit. To achieve conduit-style behavior,
--   use the Monoid instance:
--   
--   <pre>
--   &gt;&gt;&gt; sinkList $ yieldMany [1..3] &lt;&gt; yieldMany [4..6]
--   [1,2,3,4,5,6]
--   </pre>
newtype Source m a
Source :: (forall r. Cont (r -> EitherT r m r) a) -> Source m a
getSource :: Source m a -> forall r. Cont (r -> EitherT r m r) a

-- | A <a>Conduit</a> is a <a>Source homomorphism</a>, or simple a mapping
--   between sources. There is no need for it to be a type synonym, except
--   to save repetition across type signatures.
type Conduit a m b = Source m a -> Source m b

-- | A <a>Sink</a> folds a <a>Source</a> down to its result value. It is
--   simply a convenient type synonym for functions mapping a <a>Source</a>
--   to some result type.
type Sink a m r = Source m a -> m r
runSource :: Source m a -> r -> (r -> a -> EitherT r m r) -> EitherT r m r
lowerSource :: (Monad m, Monoid a) => Source m a -> m a
source :: (forall r. r -> (r -> a -> EitherT r m r) -> EitherT r m r) -> Source m a
conduit :: (forall r. r -> (r -> b -> EitherT r m r) -> a -> EitherT r m r) -> Conduit a m b

-- | Most of the time conduits pass the fold variable through unmolested,
--   but sometimes you need to ignore that variable and use your own within
--   a stage of the pipeline. This is done by wrapping the fold variable in
--   a tuple and then unwrapping it when the conduit is done.
--   <a>conduitWith</a> makes this transparent.
conduitWith :: Monad m => s -> (forall r. (r, s) -> (r -> b -> EitherT (r, s) m (r, s)) -> a -> EitherT (r, s) m (r, s)) -> Conduit a m b
sink :: Monad m => r -> (r -> a -> EitherT r m r) -> Sink a m r

-- | Promote any sink to a source. This can be used as if it were a source
--   transformer (aka, a conduit):
--   
--   <pre>
--   &gt;&gt;&gt; sinkList $ returnC $ sumC $ mapC (+1) $ yieldMany [1..10]
--   [65]
--   </pre>
--   
--   Note that <a>returnC</a> is a synonym for <a>lift</a>.
returnC :: Monad m => m a -> Source m a
close :: Monad m => Source m a
skip :: Monad m => Source m a
awaitForever :: (a -> Source m b) -> Conduit a m b
yieldMany :: (Monad m, MonoFoldable mono) => mono -> Source m (Element mono)
sourceList :: Monad m => [a] -> Source m a
unfoldC :: Monad m => (b -> Maybe (a, b)) -> b -> Source m a
enumFromToC :: (Monad m, Enum a, Eq a) => a -> a -> Source m a
iterateC :: Monad m => (a -> a) -> a -> Source m a
repeatC :: Monad m => a -> Source m a
replicateC :: Monad m => Int -> a -> Source m a
sourceLazy :: (Monad m, LazySequence lazy strict) => lazy -> Source m strict
repeatMC :: Monad m => m a -> Source m a
repeatWhileMC :: Monad m => m a -> (a -> Bool) -> Source m a
replicateMC :: Monad m => Int -> m a -> Source m a
sourceHandle :: (MonadIO m, IOData a) => Handle -> Source m a
sourceFile :: (MonadBaseControl IO m, MonadIO m, IOData a) => FilePath -> Source m a
sourceIOHandle :: (MonadBaseControl IO m, MonadIO m, IOData a) => IO Handle -> Source m a
stdinC :: (MonadBaseControl IO m, MonadIO m, IOData a) => Source m a
initRepeat :: Monad m => m seed -> (seed -> m a) -> Source m a
initReplicate :: Monad m => m seed -> (seed -> m a) -> Int -> Source m a
sourceRandom :: (Variate a, MonadIO m) => Source m a
sourceRandomN :: (Variate a, MonadIO m) => Int -> Source m a
sourceRandomGen :: (Variate a, MonadBase base m, PrimMonad base) => Gen (PrimState base) -> Source m a
sourceRandomNGen :: (Variate a, MonadBase base m, PrimMonad base) => Gen (PrimState base) -> Int -> Source m a
sourceDirectory :: MonadBaseControl IO m => FilePath -> Source m FilePath
sourceDirectoryDeep :: MonadBaseControl IO m => Bool -> FilePath -> Source m FilePath
dropC :: Monad m => Int -> Conduit a m a
dropCE :: (Monad m, IsSequence seq) => Index seq -> Conduit seq m seq
dropWhileC :: Monad m => (a -> Bool) -> Conduit a m a
dropWhileCE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> Conduit seq m seq
foldC :: (Monad m, Monoid a) => Sink a m a
foldCE :: (Monad m, MonoFoldable mono, Monoid (Element mono)) => Sink mono m (Element mono)
foldlC :: Monad m => (a -> b -> a) -> a -> Sink b m a
foldlCE :: (Monad m, MonoFoldable mono) => (a -> Element mono -> a) -> a -> Sink mono m a
foldMapC :: (Monad m, Monoid b) => (a -> b) -> Sink a m b
foldMapCE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> Sink mono m w
allC :: Monad m => (a -> Bool) -> Sink a m Bool
allCE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> Sink mono m Bool
anyC :: Monad m => (a -> Bool) -> Sink a m Bool
anyCE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> Sink mono m Bool
andC :: Monad m => Sink Bool m Bool
andCE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => Sink mono m Bool
orC :: Monad m => Sink Bool m Bool
orCE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => Sink mono m Bool
elemC :: (Monad m, Eq a) => a -> Sink a m Bool
elemCE :: (Monad m, EqSequence seq) => Element seq -> Sink seq m Bool
notElemC :: (Monad m, Eq a) => a -> Sink a m Bool
notElemCE :: (Monad m, EqSequence seq) => Element seq -> Sink seq m Bool
sinkLazy :: (Monad m, LazySequence lazy strict) => Sink strict m lazy
sinkList :: Monad m => Sink a m [a]
sinkVector :: (MonadBase base m, Vector v a, PrimMonad base) => Sink a m (v a)
sinkBuilder :: (Monad m, Monoid builder, ToBuilder a builder) => Sink a m builder
sinkLazyBuilder :: (Monad m, Monoid builder, ToBuilder a builder, Builder builder lazy) => Sink a m lazy
sinkNull :: Monad m => Sink a m ()
awaitNonNull :: (Monad m, MonoFoldable a) => Conduit a m (Maybe (NonNull a))
headCE :: (Monad m, IsSequence seq) => Sink seq m (Maybe (Element seq))
lastC :: Monad m => Sink a m (Maybe a)
lastCE :: (Monad m, IsSequence seq) => Sink seq m (Maybe (Element seq))
lengthC :: (Monad m, Num len) => Sink a m len
lengthCE :: (Monad m, Num len, MonoFoldable mono) => Sink mono m len
lengthIfC :: (Monad m, Num len) => (a -> Bool) -> Sink a m len
lengthIfCE :: (Monad m, Num len, MonoFoldable mono) => (Element mono -> Bool) -> Sink mono m len
maximumC :: (Monad m, Ord a) => Sink a m (Maybe a)
maximumCE :: (Monad m, OrdSequence seq) => Sink seq m (Maybe (Element seq))
minimumC :: (Monad m, Ord a) => Sink a m (Maybe a)
minimumCE :: (Monad m, OrdSequence seq) => Sink seq m (Maybe (Element seq))
sumC :: (Monad m, Num a) => Sink a m a
sumCE :: (Monad m, MonoFoldable mono, Num (Element mono)) => Sink mono m (Element mono)
productC :: (Monad m, Num a) => Sink a m a
productCE :: (Monad m, MonoFoldable mono, Num (Element mono)) => Sink mono m (Element mono)
findC :: Monad m => (a -> Bool) -> Sink a m (Maybe a)
mapM_C :: Monad m => (a -> m ()) -> Sink a m ()
mapM_CE :: (Monad m, MonoFoldable mono) => (Element mono -> m ()) -> Sink mono m ()
foldMC :: Monad m => (a -> b -> m a) -> a -> Sink b m a
foldMCE :: (Monad m, MonoFoldable mono) => (a -> Element mono -> m a) -> a -> Sink mono m a
foldMapMC :: (Monad m, Monoid w) => (a -> m w) -> Sink a m w
foldMapMCE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> m w) -> Sink mono m w
sinkFile :: (MonadBaseControl IO m, MonadIO m, IOData a) => FilePath -> Sink a m ()
sinkHandle :: (MonadIO m, IOData a) => Handle -> Sink a m ()
sinkIOHandle :: (MonadBaseControl IO m, MonadIO m, IOData a) => IO Handle -> Sink a m ()
printC :: (Show a, MonadIO m) => Sink a m ()
stdoutC :: (MonadIO m, IOData a) => Sink a m ()
stderrC :: (MonadIO m, IOData a) => Sink a m ()
mapC :: Monad m => (a -> b) -> Conduit a m b
mapCE :: (Monad m, Functor f) => (a -> b) -> Conduit (f a) m (f b)
omapCE :: (Monad m, MonoFunctor mono) => (Element mono -> Element mono) -> Conduit mono m mono
concatMapC :: (Monad m, MonoFoldable mono) => (a -> mono) -> Conduit a m (Element mono)
concatMapCE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> Conduit mono m w
takeC :: Monad m => Int -> Conduit a m a
takeCE :: (Monad m, IsSequence seq) => Index seq -> Conduit seq m seq

-- | This function reads one more element than it yields, which would be a
--   problem if Sinks were monadic, as they are in conduit or pipes. There
--   is no such concept as <a>resuming where the last conduit left off</a>
--   in this library.
takeWhileC :: Monad m => (a -> Bool) -> Conduit a m a
takeWhileCE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> Conduit seq m seq
takeExactlyC :: Monad m => Int -> Conduit a m b -> Conduit a m b
takeExactlyCE :: (Monad m, IsSequence a) => Index a -> Conduit a m b -> Conduit a m b
concatC :: (Monad m, MonoFoldable mono) => Conduit mono m (Element mono)
filterC :: Monad m => (a -> Bool) -> Conduit a m a
filterCE :: (IsSequence seq, Monad m) => (Element seq -> Bool) -> Conduit seq m seq
mapWhileC :: Monad m => (a -> Maybe b) -> Conduit a m b

-- | Collect elements into a vector until the size <tt>maxSize</tt> is
--   reached, then yield that vector downstream.
conduitVector :: (MonadBase base m, Vector v a, PrimMonad base) => Int -> Conduit a m (v a)
scanlC :: Monad m => (a -> b -> a) -> a -> Conduit b m a
concatMapAccumC :: Monad m => (a -> accum -> (accum, [b])) -> accum -> Conduit a m b
intersperseC :: Monad m => a -> Source m a -> Source m a
encodeBase64C :: Monad m => Conduit ByteString m ByteString
decodeBase64C :: Monad m => Conduit ByteString m ByteString
encodeBase64URLC :: Monad m => Conduit ByteString m ByteString
decodeBase64URLC :: Monad m => Conduit ByteString m ByteString
encodeBase16C :: Monad m => Conduit ByteString m ByteString
decodeBase16C :: Monad m => Conduit ByteString m ByteString
mapMC :: Monad m => (a -> m b) -> Conduit a m b
mapMCE :: (Monad m, Traversable f) => (a -> m b) -> Conduit (f a) m (f b)
omapMCE :: (Monad m, MonoTraversable mono) => (Element mono -> m (Element mono)) -> Conduit mono m mono
concatMapMC :: (Monad m, MonoFoldable mono) => (a -> m mono) -> Conduit a m (Element mono)
filterMC :: Monad m => (a -> m Bool) -> Conduit a m a
filterMCE :: (Monad m, IsSequence seq) => (Element seq -> m Bool) -> Conduit seq m seq
iterMC :: Monad m => (a -> m ()) -> Conduit a m a
scanlMC :: Monad m => (a -> b -> m a) -> a -> Conduit b m a
concatMapAccumMC :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> Conduit a m b
encodeUtf8C :: (Monad m, Utf8 text binary) => Conduit text m binary
decodeUtf8C :: MonadThrow m => Conduit ByteString m Text
lineC :: (Monad m, IsSequence seq, Element seq ~ Char) => Conduit seq m o -> Conduit seq m o
lineAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => Conduit seq m o -> Conduit seq m o
unlinesC :: (Monad m, IsSequence seq, Element seq ~ Char) => Conduit seq m seq
unlinesAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => Conduit seq m seq
linesUnboundedC_ :: (Monad m, IsSequence seq, Eq (Element seq)) => Element seq -> Conduit seq m seq
linesUnboundedC :: (Monad m, IsSequence seq, Element seq ~ Char) => Conduit seq m seq
linesC :: (Monad m, IsSequence seq, Element seq ~ Char) => Conduit seq m seq
linesUnboundedAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => Conduit seq m seq
linesAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => Conduit seq m seq

-- | Keep taking from an <tt>MVar (Maybe a)</tt> until it yields
--   <a>Nothing</a>.
sourceMaybeMVar :: MonadIO m => MVar (Maybe a) -> Source m a

-- | Keep taking from an <tt>TMVar (Maybe a)</tt> until it yields
--   <a>Nothing</a>.
sourceMaybeTMVar :: TMVar (Maybe a) -> Source STM a
asyncC :: (MonadBaseControl IO m, Monad m) => (a -> m b) -> Conduit a m (Async (StM m b))

-- | A Source for exhausting a TChan, but blocks if it is initially empty.
sourceTChan :: TChan a -> Source STM a
sourceTQueue :: TQueue a -> Source STM a
sourceTBQueue :: TBQueue a -> Source STM a
untilMC :: Monad m => m a -> m Bool -> Source m a
whileMC :: Monad m => m Bool -> m a -> Source m a
zipSinks :: (MonadBaseControl IO m, MonadIO m) => Sink a m r -> Sink a m r' -> Sink a m (r, r')

-- | Compose a <a>Source</a> and a <a>Conduit</a> into a new <a>Source</a>.
--   Note that this is just flipped function application, so ($) can be
--   used to achieve the same thing.
($=) :: a -> (a -> b) -> b

-- | Compose a <a>Conduit</a> and a <a>Sink</a> into a new <a>Sink</a>.
--   Note that this is just function composition, so (.) can be used to
--   achieve the same thing.
(=$) :: (a -> b) -> (b -> c) -> a -> c

-- | Compose two <a>Conduit</a>. This is also just function composition.
(=$=) :: (a -> b) -> (b -> c) -> a -> c

-- | Compose a <a>Source</a> and a <a>Sink</a> and compute the result. Note
--   that this is just flipped function application, so ($) can be used to
--   achieve the same thing.
($$) :: a -> (a -> b) -> b

-- | Sequence a collection of sources.
--   
--   <pre>
--   &gt;&gt;&gt; sinkList $ sequenceSources [yieldOne 1, yieldOne 2, yieldOne 3]
--   [[1,2,3]]
--   </pre>
sequenceSources :: (Traversable f, Monad m) => f (Source m a) -> Source m (f a)
