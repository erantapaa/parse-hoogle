-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Instantiate structural induction schemas for algebraic data types
--   
@package structural-induction
@version 0.3


-- | This package aims to perform the fiddly details of instantiating
--   induction schemas for algebraic data types. The library is
--   parameterised over the type of variables (<tt>v</tt>), constructors
--   (<tt>c</tt>) and types (<tt>t</tt>).
--   
--   Let's see how it looks if you instantiate all these three with String
--   and want to do induction over natural numbers. First, one needs to
--   create a type environment, a <a>TyEnv</a>. For every type (we only
--   have one), we need to list its constructors. For each constructor, we
--   need to list its arguments and whether they are recursive or not.
--   
--   <pre>
--   testEnv :: TyEnv String String
--   testEnv "Nat" = Just [ ("zero",[]) , ("succ",[Rec "Nat"]) ]
--   testEnv _ = Nothing
--   </pre>
--   
--   Now, we can use the <a>subtermInduction</a> to get induction
--   hypotheses which are just subterms of the conclusion. Normally, you
--   would translate the <a>Term</a>s from the proof <a>Obligation</a>s to
--   some other representation, but there is also linearisation functions
--   included (<a>linObligations</a>, for instance.)
--   
--   <pre>
--   natInd :: [String] -&gt; [Int] -&gt; IO ()
--   natInd vars coords = putStrLn
--       $ render
--       $ linObligations strStyle
--       $ unTag (\(x :~ i) -&gt; x ++ show i)
--       $ subtermInduction testEnv typed_vars coords
--     where
--       typed_vars = zip vars (repeat "Nat")
--   </pre>
--   
--   The library will create fresh variables for you (called <a>Tagged</a>
--   variables), but you need to remove them, using for instance
--   <a>unTag</a>. If you want to sync it with your own name supply, use
--   <a>unTagM</a> or <a>unTagMapM</a>.
--   
--   An example invocation:
--   
--   <pre>
--   *Mini&gt; natInd ["X"] [0]
--   P(zero).
--   ! [X1 : Nat] : (P(X1) =&gt; P(succ(X1))).
--   </pre>
--   
--   This means to do induction on the zeroth coord (hence the <tt>0</tt>),
--   and the variable is called <a>X</a>. When using the library, it is up
--   to you to translate the abstract <tt>P</tt> predicate to something
--   meaningful.
--   
--   We can also do induction on several variables:
--   
--   <pre>
--   *Mini&gt; natInd ["X","Y"] [0,1]
--   P(zero,zero).
--   ! [Y3 : Nat] : (P(zero,Y3) =&gt; P(zero,succ(Y3))).
--   ! [X1 : Nat] : (P(X1,zero) =&gt; P(succ(X1),zero)).
--   ! [X1 : Nat,Y3 : Nat] :
--       (P(X1,Y3) &amp;
--       P(X1,succ(Y3)) &amp;
--       P(succ(X1),Y3)
--        =&gt; P(succ(X1),succ(Y3))).
--   </pre>
--   
--   In the last step case, all proper subterms of
--   <tt>succ(X1),succ(Y3)</tt> are used as hypotheses.
--   
--   A bigger example is in <tt>example/Example.hs</tt> in the
--   distribution.
module Induction.Structural

-- | Subterm induction: the induction hypotheses will contain the proper
--   subterms of the conclusion.
subtermInduction :: Ord c => TyEnv c t -> [(v, t)] -> [Int] -> [TaggedObligation c v t]

-- | Does case analysis on a list of typed variables. This function is
--   equal to removing all the hypotheses from <a>subtermInduction</a>.
caseAnalysis :: TyEnv c t -> [(v, t)] -> [Int] -> [TaggedObligation c v t]

-- | Quantifier lists are represented as tuples of variables and their
--   type.
--   
--   Example:
--   
--   <pre>
--   Obligation
--       { implicit   = [(x,t1),(y,t2)]
--       , hypotheses = [([],[htm1,htm2])
--                      ,([(z,t3)],[htm3,htm4])
--                      ]
--       , conclusion = [tm1,tm2]
--       }
--   </pre>
--   
--   Corresponds to the formula:
--   
--   <i>forall (x : t1) (y : t2) . (P(htm1,htm2) &amp; (forall (z : t3) .
--   P(htm3,htm4)) =&gt; P(tm1,tm2))</i>
--   
--   The implicit variables (<i>x</i> and <i>y</i>) can be viewed as
--   skolemised, and use these three formulae instead:
--   
--   <i>P(htm1,htm2).</i>
--   
--   <i>forall (z : t3) . P(htm3,htm4).</i>
--   
--   <i>~ P(tm1,tm2).</i>
data Obligation c v t
Obligation :: [(v, t)] -> [Hypothesis c v t] -> Predicate c v -> Obligation c v t

-- | Implicitly quantified variables (skolemised)
implicit :: Obligation c v t -> [(v, t)]

-- | Hypotheses, with explicitly quantified variables
hypotheses :: Obligation c v t -> [Hypothesis c v t]

-- | The induction conclusion
conclusion :: Obligation c v t -> Predicate c v

-- | Obligations with tagged variables (see <a>Tagged</a> and <a>unTag</a>)
type TaggedObligation c v t = Obligation c (Tagged v) t

-- | A list of terms.
--   
--   Example: <tt>[tm1,tm2]</tt> corresponds to the formula
--   <i>P(tm1,tm2)</i>
type Predicate c v = [Term c v]

-- | Quantifier lists are represented as tuples of variables and their
--   type.
--   
--   Example:
--   
--   <pre>
--   ([(x,t1),(y,t2)],[tm1,tm2])
--   </pre>
--   
--   corresponds to the formula
--   
--   <i>forall (x : t1) (y : t2) . P(tm1,tm2)</i>
type Hypothesis c v t = ([(v, t)], Predicate c v)

-- | The simple term language only includes variables, constructors and
--   functions.
data Term c v
Var :: v -> Term c v
Con :: c -> [Term c v] -> Term c v

-- | Induction on exponential data types yield assumptions with functions
Fun :: v -> [Term c v] -> Term c v

-- | Given a type, return either that you cannot do induction on is type
--   (<a>Nothing</a>), or <a>Just</a> the constructors and a description of
--   their arguments (see <a>Arg</a>).
--   
--   The function <i>should instantiate type variables</i>. For instance,
--   if you look up the type <tt>[Nat]</tt>, you should return the cons
--   constructor with arguments <tt>Nat</tt> and <tt>[Nat]</tt> (see
--   <a>Arg</a>).
--   
--   Examples of types not possible to do induction on are function spaces
--   and type variables. For these, return <a>Nothing</a>.
type TyEnv c t = t -> Maybe [(c, [Arg t])]

-- | An argument to a constructor can be recursive (<a>Rec</a>) or
--   non-recursive (<a>NonRec</a>). Induction hypotheses will be asserted
--   for <a>Rec</a> arguments.
--   
--   For instance, when doing induction on <tt>[a]</tt>, then <tt>(:)</tt>
--   has two arguments, <tt>NonRec a</tt> and <tt>Rec [a]</tt>. On the
--   other hand, if doing induction on <tt>[Nat]</tt>, then <tt>(:)</tt>
--   has <tt>NonRec Nat</tt> and <tt>Rec [Nat]</tt>.
--   
--   Data types can also be exponential. Consider
--   
--   <pre>
--   data Ord = Zero | Succ Ord | Lim (Nat -&gt; Ord)
--   </pre>
--   
--   Here, the <tt>Lim</tt> constructor is exponential. If we describe
--   types and constructors with strings, the constructors for this data
--   type is:
--   
--   <pre>
--   [ ("Zero",[])
--   , ("Succ",[Rec "Ord"])
--   , ("Lim",[Exp ("Nat -&gt; Ord") ["Nat"])
--   ]
--   </pre>
--   
--   The first argument to <a>Exp</a> is the type of the function, and the
--   second argument are the arguments to the function.
data Arg t
Rec :: t -> Arg t
NonRec :: t -> Arg t
Exp :: t -> [t] -> Arg t

-- | Cheap way of introducing fresh variables. The <a>Eq</a> and <a>Ord</a>
--   instances only uses the <a>Integer</a> tag.
data Tagged v
(:~) :: v -> Integer -> Tagged v

-- | The <a>Integer</a> tag
tag :: Tagged v -> Integer

-- | Removing tagged (fresh) variables
unTag :: (Tagged v -> v') -> [TaggedObligation c v t] -> [Obligation c v' t]

-- | Removing tagged (fresh) variables in a monad. The remove function is
--   exectued at <i>every occurence</i> of a tagged variable. This is
--   useful if you want to sync it with your own name supply monad.
unTagM :: Applicative m => (Tagged v -> m v') -> [TaggedObligation c v t] -> m [Obligation c v' t]

-- | Remove tagged (fresh) variables in a monad. The remove function is
--   exectued <i>only once</i> for each tagged variable, and a <a>Map</a>
--   of renamings is returned. This is useful if you want to sync it with
--   your own name supply monad.
unTagMapM :: (Functor m, Monad m) => (Tagged v -> m v') -> [TaggedObligation c v t] -> m ([Obligation c v' t], Map (Tagged v) v')

-- | Linearises a list of <a>Obligation</a>, using a given <a>Style</a>.
linObligations :: Style c v t -> [Obligation c v t] -> Doc

-- | Linearises an <a>Obligation</a> using a given <a>Style</a>. The output
--   format is inspired by TPTP, but with typed quantifiers.
linObligation :: Style c v t -> Obligation c v t -> Doc

-- | Linearises a <a>Term</a> using a given <a>Style</a>.
linTerm :: Style c v t -> Term c v -> Doc

-- | Functions for linearising constructors (<a>linc</a>), variables
--   (<a>linv</a>) and types (<a>lint</a>).
data Style c v t
Style :: (c -> Doc) -> (v -> Doc) -> (t -> Doc) -> Style c v t
linc :: Style c v t -> c -> Doc
linv :: Style c v t -> v -> Doc
lint :: Style c v t -> t -> Doc

-- | An example style where constructors, variables and types are
--   represented as <a>String</a>.
strStyle :: Style String String String

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>.
render :: Doc -> String

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc
