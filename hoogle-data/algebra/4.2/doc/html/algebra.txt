-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Constructive abstract algebra
--   
@package algebra
@version 4.2

module Numeric.Partial.Semigroup
class PartialSemigroup a
padd :: PartialSemigroup a => a -> a -> Maybe a
instance (PartialSemigroup a, PartialSemigroup b) => PartialSemigroup (Either a b)
instance (PartialSemigroup a, PartialSemigroup b, PartialSemigroup c, PartialSemigroup d, PartialSemigroup e) => PartialSemigroup (a, b, c, d, e)
instance (PartialSemigroup a, PartialSemigroup b, PartialSemigroup c, PartialSemigroup d) => PartialSemigroup (a, b, c, d)
instance (PartialSemigroup a, PartialSemigroup b, PartialSemigroup c) => PartialSemigroup (a, b, c)
instance (PartialSemigroup a, PartialSemigroup b) => PartialSemigroup (a, b)
instance PartialSemigroup ()
instance PartialSemigroup Bool
instance PartialSemigroup a => PartialSemigroup (Maybe a)
instance PartialSemigroup Word64
instance PartialSemigroup Word32
instance PartialSemigroup Word16
instance PartialSemigroup Word8
instance PartialSemigroup Word
instance PartialSemigroup Int64
instance PartialSemigroup Int32
instance PartialSemigroup Int16
instance PartialSemigroup Int8
instance PartialSemigroup Natural
instance PartialSemigroup Integer
instance PartialSemigroup Int

module Numeric.Partial.Monoid
class PartialSemigroup a => PartialMonoid a
pzero :: PartialMonoid a => a
instance (PartialMonoid a, PartialMonoid b, PartialMonoid c, PartialMonoid d, PartialMonoid e) => PartialMonoid (a, b, c, d, e)
instance (PartialMonoid a, PartialMonoid b, PartialMonoid c, PartialMonoid d) => PartialMonoid (a, b, c, d)
instance (PartialMonoid a, PartialMonoid b, PartialMonoid c) => PartialMonoid (a, b, c)
instance (PartialMonoid a, PartialMonoid b) => PartialMonoid (a, b)
instance PartialSemigroup a => PartialMonoid (Maybe a)
instance PartialMonoid ()
instance PartialMonoid Word64
instance PartialMonoid Word32
instance PartialMonoid Word16
instance PartialMonoid Word8
instance PartialMonoid Word
instance PartialMonoid Int64
instance PartialMonoid Int32
instance PartialMonoid Int16
instance PartialMonoid Int8
instance PartialMonoid Natural
instance PartialMonoid Integer
instance PartialMonoid Int
instance PartialMonoid Bool

module Numeric.Partial.Group
class PartialMonoid a => PartialGroup a where pnegate = pminus pzero pminus a b = padd a =<< pnegate b psubtract a b = pnegate a >>= (`padd` b)
pnegate :: PartialGroup a => a -> Maybe a
pminus :: PartialGroup a => a -> a -> Maybe a
psubtract :: PartialGroup a => a -> a -> Maybe a
instance (PartialGroup a, PartialGroup b, PartialGroup c, PartialGroup d, PartialGroup e) => PartialGroup (a, b, c, d, e)
instance (PartialGroup a, PartialGroup b, PartialGroup c, PartialGroup d) => PartialGroup (a, b, c, d)
instance (PartialGroup a, PartialGroup b, PartialGroup c) => PartialGroup (a, b, c)
instance (PartialGroup a, PartialGroup b) => PartialGroup (a, b)
instance PartialGroup ()
instance PartialGroup Natural
instance PartialGroup Word64
instance PartialGroup Word32
instance PartialGroup Word16
instance PartialGroup Word8
instance PartialGroup Word
instance PartialGroup Int64
instance PartialGroup Int32
instance PartialGroup Int16
instance PartialGroup Int8
instance PartialGroup Integer
instance PartialGroup Int

module Numeric.Order.Class
class Order a where a <~ b = maybe False (<= EQ) (order a b) a < b = order a b == Just LT a >~ b = b <~ a a > b = order a b == Just GT a ~~ b = order a b == Just EQ a /~ b = order a b /= Just EQ order a b | a <~ b = Just $ if b <~ a then EQ else LT | b <~ a = Just GT | otherwise = Nothing comparable a b = maybe False (const True) (order a b)
(<~) :: Order a => a -> a -> Bool
(<) :: Order a => a -> a -> Bool
(>~) :: Order a => a -> a -> Bool
(>) :: Order a => a -> a -> Bool
(~~) :: Order a => a -> a -> Bool
(/~) :: Order a => a -> a -> Bool
order :: Order a => a -> a -> Maybe Ordering
comparable :: Order a => a -> a -> Bool
orderOrd :: Ord a => a -> a -> Maybe Ordering
instance (Order a, Order b, Order c, Order d, Order e) => Order (a, b, c, d, e)
instance (Order a, Order b, Order c, Order d) => Order (a, b, c, d)
instance (Order a, Order b, Order c) => Order (a, b, c)
instance (Order a, Order b) => Order (a, b)
instance Order ()
instance Ord a => Order (Set a)
instance Order Word64
instance Order Word32
instance Order Word16
instance Order Word8
instance Order Word
instance Order Natural
instance Order Int64
instance Order Int32
instance Order Int16
instance Order Int8
instance Order Int
instance Order Integer
instance Order Bool

module Numeric.Additive.Class

-- | <pre>
--   (a + b) + c = a + (b + c)
--   sinnum 1 a = a
--   sinnum (2 * n) a = sinnum n a + sinnum n a
--   sinnum (2 * n + 1) a = sinnum n a + sinnum n a + a
--   </pre>
class Additive r where sinnum1p y0 x0 = f x0 (1 + y0) where f x y | even y = f (x + x) (y `quot` 2) | y == 1 = x | otherwise = g (x + x) (pred y `quot` 2) x g x y z | even y = g (x + x) (y `quot` 2) z | y == 1 = x + z | otherwise = g (x + x) (pred y `quot` 2) (x + z) sumWith1 f = maybe (error "Numeric.Additive.Semigroup.sumWith1: empty structure") id . foldl' mf Nothing where mf Nothing y = Just $! f y mf (Just x) y = Just $! x + f y
(+) :: Additive r => r -> r -> r
sinnum1p :: Additive r => Natural -> r -> r
sumWith1 :: (Additive r, Foldable1 f) => (a -> r) -> f a -> r
sum1 :: (Foldable1 f, Additive r) => f r -> r

-- | an additive abelian semigroup
--   
--   a + b = b + a
class Additive r => Abelian r

-- | An additive semigroup with idempotent addition.
--   
--   <pre>
--   a + a = a
--   </pre>
class Additive r => Idempotent r
sinnum1pIdempotent :: Natural -> r -> r
class Additive m => Partitionable m
partitionWith :: Partitionable m => (m -> m -> r) -> m -> NonEmpty r
instance (Idempotent a, Idempotent b, Idempotent c, Idempotent d, Idempotent e) => Idempotent (a, b, c, d, e)
instance (Idempotent a, Idempotent b, Idempotent c, Idempotent d) => Idempotent (a, b, c, d)
instance (Idempotent a, Idempotent b, Idempotent c) => Idempotent (a, b, c)
instance (Idempotent a, Idempotent b) => Idempotent (a, b)
instance Idempotent r => Idempotent (e -> r)
instance Idempotent Bool
instance Idempotent ()
instance (Abelian a, Abelian b, Abelian c, Abelian d, Abelian e) => Abelian (a, b, c, d, e)
instance (Abelian a, Abelian b, Abelian c, Abelian d) => Abelian (a, b, c, d)
instance (Abelian a, Abelian b, Abelian c) => Abelian (a, b, c)
instance (Abelian a, Abelian b) => Abelian (a, b)
instance Abelian Word64
instance Abelian Word32
instance Abelian Word16
instance Abelian Word8
instance Abelian Word
instance Abelian Int64
instance Abelian Int32
instance Abelian Int16
instance Abelian Int8
instance Abelian Int
instance Abelian Natural
instance Abelian Integer
instance Abelian Bool
instance Abelian ()
instance Abelian r => Abelian (e -> r)
instance (Partitionable a, Partitionable b, Partitionable c, Partitionable d, Partitionable e) => Partitionable (a, b, c, d, e)
instance (Partitionable a, Partitionable b, Partitionable c, Partitionable d) => Partitionable (a, b, c, d)
instance (Partitionable a, Partitionable b, Partitionable c) => Partitionable (a, b, c)
instance (Partitionable a, Partitionable b) => Partitionable (a, b)
instance Partitionable ()
instance Partitionable Natural
instance Partitionable Bool
instance (Additive a, Additive b, Additive c, Additive d, Additive e) => Additive (a, b, c, d, e)
instance (Additive a, Additive b, Additive c, Additive d) => Additive (a, b, c, d)
instance (Additive a, Additive b, Additive c) => Additive (a, b, c)
instance (Additive a, Additive b) => Additive (a, b)
instance Additive ()
instance Additive Word64
instance Additive Word32
instance Additive Word16
instance Additive Word8
instance Additive Word
instance Additive Int64
instance Additive Int32
instance Additive Int16
instance Additive Int8
instance Additive Int
instance Additive Integer
instance Additive Natural
instance Additive Bool
instance Additive r => Additive (b -> r)

module Numeric.Algebra.Class

-- | A multiplicative semigroup
class Multiplicative r where pow1p x0 y0 = f x0 (y0 + 1) where f x y | even y = f (x * x) (y `quot` 2) | y == 1 = x | otherwise = g (x * x) ((y - 1) `quot` 2) x g x y z | even y = g (x * x) (y `quot` 2) z | y == 1 = x * z | otherwise = g (x * x) ((y - 1) `quot` 2) (x * z) productWith1 f = maybe (error "Numeric.Multiplicative.Semigroup.productWith1: empty structure") id . foldl' mf Nothing where mf Nothing y = Just $! f y mf (Just x) y = Just $! x * f y
(*) :: Multiplicative r => r -> r -> r
pow1p :: Multiplicative r => r -> Natural -> r
productWith1 :: (Multiplicative r, Foldable1 f) => (a -> r) -> f a -> r
pow1pIntegral :: (Integral r, Integral n) => r -> n -> r
product1 :: (Foldable1 f, Multiplicative r) => f r -> r

-- | A pair of an additive abelian semigroup, and a multiplicative
--   semigroup, with the distributive laws:
--   
--   <pre>
--   a(b + c) = ab + ac -- left distribution (we are a LeftNearSemiring)
--   (a + b)c = ac + bc -- right distribution (we are a [Right]NearSemiring)
--   </pre>
--   
--   Common notation includes the laws for additive and multiplicative
--   identity in semiring.
--   
--   If you want that, look at <tt>Rig</tt> instead.
--   
--   Ideally we'd use the cyclic definition:
--   
--   <pre>
--   class (LeftModule r r, RightModule r r, Additive r, Abelian r, Multiplicative r) =&gt; Semiring r
--   </pre>
--   
--   to enforce that every semiring r is an r-module over itself, but
--   Haskell doesn't like that.
class (Additive r, Abelian r, Multiplicative r) => Semiring r
class (Semiring r, Additive m) => LeftModule r m
(.*) :: LeftModule r m => r -> m -> m
class (Semiring r, Additive m) => RightModule r m
(*.) :: RightModule r m => m -> r -> m
class (LeftModule r m, RightModule r m) => Module r m

-- | An additive monoid
--   
--   <pre>
--   zero + a = a = a + zero
--   </pre>
class (LeftModule Natural m, RightModule Natural m) => Monoidal m where sinnum 0 _ = zero sinnum n x0 = f x0 n where f x y | even y = f (x + x) (y `quot` 2) | y == 1 = x | otherwise = g (x + x) (pred y `quot` 2) x g x y z | even y = g (x + x) (y `quot` 2) z | y == 1 = x + z | otherwise = g (x + x) (pred y `quot` 2) (x + z) sumWith f = foldl' (\ b a -> b + f a) zero
zero :: Monoidal m => m
sinnum :: Monoidal m => Natural -> m -> m
sumWith :: (Monoidal m, Foldable f) => (a -> m) -> f a -> m
sum :: (Foldable f, Monoidal m) => f m -> m
sinnumIdempotent :: (Integral n, Idempotent r, Monoidal r) => n -> r -> r

-- | An associative algebra built with a free module over a semiring
class Semiring r => Algebra r a
mult :: Algebra r a => (a -> a -> r) -> a -> r
class Semiring r => Coalgebra r c
comult :: Coalgebra r c => (c -> r) -> c -> c -> r
instance (Monoidal a, Monoidal b, Monoidal c, Monoidal d, Monoidal e) => Monoidal (a, b, c, d, e)
instance (Monoidal a, Monoidal b, Monoidal c, Monoidal d) => Monoidal (a, b, c, d)
instance (Monoidal a, Monoidal b, Monoidal c) => Monoidal (a, b, c)
instance (Monoidal a, Monoidal b) => Monoidal (a, b)
instance Monoidal ()
instance Monoidal r => Monoidal (e -> r)
instance Monoidal Word64
instance Monoidal Word32
instance Monoidal Word16
instance Monoidal Word8
instance Monoidal Word
instance Monoidal Int64
instance Monoidal Int32
instance Monoidal Int16
instance Monoidal Int8
instance Monoidal Int
instance Monoidal Integer
instance Monoidal Natural
instance Monoidal Bool
instance (LeftModule r m, RightModule r m) => Module r m
instance (RightModule r a, RightModule r b, RightModule r c, RightModule r d, RightModule r e) => RightModule r (a, b, c, d, e)
instance (RightModule r a, RightModule r b, RightModule r c, RightModule r d) => RightModule r (a, b, c, d)
instance (RightModule r a, RightModule r b, RightModule r c) => RightModule r (a, b, c)
instance (RightModule r a, RightModule r b) => RightModule r (a, b)
instance Additive m => RightModule () m
instance RightModule r m => RightModule r (e -> m)
instance Semiring r => RightModule r ()
instance RightModule Integer Word64
instance RightModule Natural Word64
instance RightModule Integer Word32
instance RightModule Natural Word32
instance RightModule Integer Word16
instance RightModule Natural Word16
instance RightModule Integer Word8
instance RightModule Natural Word8
instance RightModule Integer Word
instance RightModule Natural Word
instance RightModule Integer Int64
instance RightModule Natural Int64
instance RightModule Integer Int32
instance RightModule Natural Int32
instance RightModule Integer Int16
instance RightModule Natural Int16
instance RightModule Integer Int8
instance RightModule Natural Int8
instance RightModule Integer Int
instance RightModule Natural Int
instance RightModule Integer Integer
instance RightModule Natural Integer
instance RightModule Natural Natural
instance RightModule Natural Bool
instance (LeftModule r a, LeftModule r b, LeftModule r c, LeftModule r d, LeftModule r e) => LeftModule r (a, b, c, d, e)
instance (LeftModule r a, LeftModule r b, LeftModule r c, LeftModule r d) => LeftModule r (a, b, c, d)
instance (LeftModule r a, LeftModule r b, LeftModule r c) => LeftModule r (a, b, c)
instance (LeftModule r a, LeftModule r b) => LeftModule r (a, b)
instance Additive m => LeftModule () m
instance LeftModule r m => LeftModule r (e -> m)
instance Semiring r => LeftModule r ()
instance LeftModule Integer Word64
instance LeftModule Natural Word64
instance LeftModule Integer Word32
instance LeftModule Natural Word32
instance LeftModule Integer Word16
instance LeftModule Natural Word16
instance LeftModule Integer Word8
instance LeftModule Natural Word8
instance LeftModule Integer Word
instance LeftModule Natural Word
instance LeftModule Integer Int64
instance LeftModule Natural Int64
instance LeftModule Integer Int32
instance LeftModule Natural Int32
instance LeftModule Integer Int16
instance LeftModule Natural Int16
instance LeftModule Integer Int8
instance LeftModule Natural Int8
instance LeftModule Integer Int
instance LeftModule Natural Int
instance LeftModule Integer Integer
instance LeftModule Natural Integer
instance LeftModule Natural Natural
instance LeftModule Natural Bool
instance (Semiring r, Additive b) => Coalgebra r (IntMap b)
instance (Semiring r, Ord a, Additive b) => Coalgebra r (Map a b)
instance Semiring r => Coalgebra r IntSet
instance (Semiring r, Ord a) => Coalgebra r (Set a)
instance Semiring r => Coalgebra r (Seq a)
instance Semiring r => Coalgebra r [a]
instance (Coalgebra r a, Coalgebra r b, Coalgebra r c, Coalgebra r d, Coalgebra r e) => Coalgebra r (a, b, c, d, e)
instance (Coalgebra r a, Coalgebra r b, Coalgebra r c, Coalgebra r d) => Coalgebra r (a, b, c, d)
instance (Coalgebra r a, Coalgebra r b, Coalgebra r c) => Coalgebra r (a, b, c)
instance (Coalgebra r a, Coalgebra r b) => Coalgebra r (a, b)
instance Semiring r => Coalgebra r ()
instance Algebra r m => Coalgebra r (m -> r)
instance (Algebra r a, Algebra r b, Algebra r c, Algebra r d, Algebra r e) => Algebra r (a, b, c, d, e)
instance (Algebra r a, Algebra r b, Algebra r c, Algebra r d) => Algebra r (a, b, c, d)
instance (Algebra r a, Algebra r b, Algebra r c) => Algebra r (a, b, c)
instance (Algebra r a, Algebra r b) => Algebra r (a, b)
instance (Semiring r, Monoidal r, Partitionable a) => Algebra r (IntMap a)
instance (Semiring r, Monoidal r, Ord a, Partitionable b) => Algebra r (Map a b)
instance Semiring r => Algebra r IntSet
instance (Semiring r, Ord a) => Algebra r (Set a)
instance Semiring r => Algebra r ()
instance Semiring r => Algebra r (Seq a)
instance Semiring r => Algebra r [a]
instance Algebra () a
instance Algebra r a => Semiring (a -> r)
instance (Semiring a, Semiring b, Semiring c, Semiring d, Semiring e) => Semiring (a, b, c, d, e)
instance (Semiring a, Semiring b, Semiring c, Semiring d) => Semiring (a, b, c, d)
instance (Semiring a, Semiring b, Semiring c) => Semiring (a, b, c)
instance (Semiring a, Semiring b) => Semiring (a, b)
instance Semiring ()
instance Semiring Word64
instance Semiring Word32
instance Semiring Word16
instance Semiring Word8
instance Semiring Word
instance Semiring Int64
instance Semiring Int32
instance Semiring Int16
instance Semiring Int8
instance Semiring Int
instance Semiring Bool
instance Semiring Natural
instance Semiring Integer
instance Algebra r a => Multiplicative (a -> r)
instance (Multiplicative a, Multiplicative b, Multiplicative c, Multiplicative d, Multiplicative e) => Multiplicative (a, b, c, d, e)
instance (Multiplicative a, Multiplicative b, Multiplicative c, Multiplicative d) => Multiplicative (a, b, c, d)
instance (Multiplicative a, Multiplicative b, Multiplicative c) => Multiplicative (a, b, c)
instance (Multiplicative a, Multiplicative b) => Multiplicative (a, b)
instance Multiplicative ()
instance Multiplicative Word64
instance Multiplicative Word32
instance Multiplicative Word16
instance Multiplicative Word8
instance Multiplicative Word
instance Multiplicative Int64
instance Multiplicative Int32
instance Multiplicative Int16
instance Multiplicative Int8
instance Multiplicative Int
instance Multiplicative Integer
instance Multiplicative Natural
instance Multiplicative Bool

module Numeric.Additive.Group
class (LeftModule Integer r, RightModule Integer r, Monoidal r) => Group r where times y0 x0 = case compare y0 0 of { LT -> f (negate x0) (negate y0) EQ -> zero GT -> f x0 y0 } where f x y | even y = f (x + x) (y `quot` 2) | y == 1 = x | otherwise = g (x + x) ((y - 1) `quot` 2) x g x y z | even y = g (x + x) (y `quot` 2) z | y == 1 = x + z | otherwise = g (x + x) ((y - 1) `quot` 2) (x + z) negate a = zero - a a - b = a + negate b subtract a b = negate a + b
(-) :: Group r => r -> r -> r
negate :: Group r => r -> r
subtract :: Group r => r -> r -> r
times :: (Group r, Integral n) => n -> r -> r
instance (Group a, Group b, Group c, Group d, Group e) => Group (a, b, c, d, e)
instance (Group a, Group b, Group c, Group d) => Group (a, b, c, d)
instance (Group a, Group b, Group c) => Group (a, b, c)
instance (Group a, Group b) => Group (a, b)
instance Group ()
instance Group Word64
instance Group Word32
instance Group Word16
instance Group Word8
instance Group Word
instance Group Int64
instance Group Int32
instance Group Int16
instance Group Int8
instance Group Int
instance Group Integer
instance Group r => Group (e -> r)

module Numeric.Algebra.Factorable

-- | `factorWith f c` returns a non-empty list containing `f a b` for all
--   `a, b` such that `a * b = c`.
--   
--   Results of factorWith f 0 are undefined and may result in either an
--   error or an infinite list.
class Multiplicative m => Factorable m
factorWith :: Factorable m => (m -> m -> r) -> m -> NonEmpty r
instance (Factorable a, Factorable b, Factorable c, Factorable d, Factorable e) => Factorable (a, b, c, d, e)
instance (Factorable a, Factorable b, Factorable c, Factorable d) => Factorable (a, b, c, d)
instance (Factorable a, Factorable b, Factorable c) => Factorable (a, b, c)
instance (Factorable a, Factorable b) => Factorable (a, b)
instance Factorable ()
instance Factorable Bool

module Numeric.Algebra.Unital
class Multiplicative r => Unital r where pow _ 0 = one pow x0 y0 = f x0 y0 where f x y | even y = f (x * x) (y `quot` 2) | y == 1 = x | otherwise = g (x * x) ((y - 1) `quot` 2) x g x y z | even y = g (x * x) (y `quot` 2) z | y == 1 = x * z | otherwise = g (x * x) ((y - 1) `quot` 2) (x * z) productWith f = foldl' (\ b a -> b * f a) one
one :: Unital r => r
pow :: Unital r => r -> Natural -> r
productWith :: (Unital r, Foldable f) => (a -> r) -> f a -> r
product :: (Foldable f, Unital r) => f r -> r

-- | An associative unital algebra over a semiring, built using a free
--   module
class Algebra r a => UnitalAlgebra r a
unit :: UnitalAlgebra r a => r -> a -> r
class Coalgebra r c => CounitalCoalgebra r c
counit :: CounitalCoalgebra r c => (c -> r) -> r

-- | A bialgebra is both a unital algebra and counital coalgebra where the
--   <a>mult</a> and <a>unit</a> are compatible in some sense with the
--   <a>comult</a> and <a>counit</a>. That is to say that <a>mult</a> and
--   <a>unit</a> are a coalgebra homomorphisms or (equivalently) that
--   <a>comult</a> and <a>counit</a> are an algebra homomorphisms.
class (UnitalAlgebra r a, CounitalCoalgebra r a) => Bialgebra r a
instance (Monoidal r, Semiring r) => Bialgebra r (Seq a)
instance (Monoidal r, Semiring r) => Bialgebra r [a]
instance (Bialgebra r a, Bialgebra r b, Bialgebra r c, Bialgebra r d, Bialgebra r e) => Bialgebra r (a, b, c, d, e)
instance (Bialgebra r a, Bialgebra r b, Bialgebra r c, Bialgebra r d) => Bialgebra r (a, b, c, d)
instance (Bialgebra r a, Bialgebra r b, Bialgebra r c) => Bialgebra r (a, b, c)
instance (Bialgebra r a, Bialgebra r b) => Bialgebra r (a, b)
instance Semiring r => Bialgebra r ()
instance Semiring r => CounitalCoalgebra r (Seq a)
instance Semiring r => CounitalCoalgebra r [a]
instance (CounitalCoalgebra r a, CounitalCoalgebra r b, CounitalCoalgebra r c, CounitalCoalgebra r d, CounitalCoalgebra r e) => CounitalCoalgebra r (a, b, c, d, e)
instance (CounitalCoalgebra r a, CounitalCoalgebra r b, CounitalCoalgebra r c, CounitalCoalgebra r d) => CounitalCoalgebra r (a, b, c, d)
instance (CounitalCoalgebra r a, CounitalCoalgebra r b, CounitalCoalgebra r c) => CounitalCoalgebra r (a, b, c)
instance (CounitalCoalgebra r a, CounitalCoalgebra r b) => CounitalCoalgebra r (a, b)
instance Semiring r => CounitalCoalgebra r ()
instance (Unital r, UnitalAlgebra r m) => CounitalCoalgebra r (m -> r)
instance (Monoidal r, Semiring r) => UnitalAlgebra r (Seq a)
instance (Monoidal r, Semiring r) => UnitalAlgebra r [a]
instance (UnitalAlgebra r a, UnitalAlgebra r b, UnitalAlgebra r c, UnitalAlgebra r d, UnitalAlgebra r e) => UnitalAlgebra r (a, b, c, d, e)
instance (UnitalAlgebra r a, UnitalAlgebra r b, UnitalAlgebra r c, UnitalAlgebra r d) => UnitalAlgebra r (a, b, c, d)
instance (UnitalAlgebra r a, UnitalAlgebra r b, UnitalAlgebra r c) => UnitalAlgebra r (a, b, c)
instance (UnitalAlgebra r a, UnitalAlgebra r b) => UnitalAlgebra r (a, b)
instance Semiring r => UnitalAlgebra r ()
instance (Unital r, UnitalAlgebra r a) => Unital (a -> r)
instance (Unital a, Unital b, Unital c, Unital d, Unital e) => Unital (a, b, c, d, e)
instance (Unital a, Unital b, Unital c, Unital d) => Unital (a, b, c, d)
instance (Unital a, Unital b, Unital c) => Unital (a, b, c)
instance (Unital a, Unital b) => Unital (a, b)
instance Unital ()
instance Unital Word64
instance Unital Word32
instance Unital Word16
instance Unital Word8
instance Unital Word
instance Unital Natural
instance Unital Int64
instance Unital Int32
instance Unital Int16
instance Unital Int8
instance Unital Int
instance Unital Integer
instance Unital Bool

module Numeric.Algebra.Idempotent

-- | An multiplicative semigroup with idempotent multiplication.
--   
--   <pre>
--   a * a = a
--   </pre>
class Multiplicative r => Band r
pow1pBand :: r -> Natural -> r
powBand :: Unital r => r -> Natural -> r
class Algebra r a => IdempotentAlgebra r a
class Coalgebra r c => IdempotentCoalgebra r c
class (Bialgebra r h, IdempotentAlgebra r h, IdempotentCoalgebra r h) => IdempotentBialgebra r h
instance (Bialgebra r h, IdempotentAlgebra r h, IdempotentCoalgebra r h) => IdempotentBialgebra r h
instance (IdempotentCoalgebra r a, IdempotentCoalgebra r b, IdempotentCoalgebra r c, IdempotentCoalgebra r d, IdempotentCoalgebra r e) => IdempotentCoalgebra r (a, b, c, d, e)
instance (IdempotentCoalgebra r a, IdempotentCoalgebra r b, IdempotentCoalgebra r c, IdempotentCoalgebra r d) => IdempotentCoalgebra r (a, b, c, d)
instance (IdempotentCoalgebra r a, IdempotentCoalgebra r b, IdempotentCoalgebra r c) => IdempotentCoalgebra r (a, b, c)
instance (IdempotentCoalgebra r a, IdempotentCoalgebra r b) => IdempotentCoalgebra r (a, b)
instance (Semiring r, Band r) => IdempotentCoalgebra r ()
instance (Semiring r, Band r) => IdempotentCoalgebra r IntSet
instance (Semiring r, Band r, Ord c) => IdempotentCoalgebra r (Set c)
instance (IdempotentAlgebra r a, IdempotentAlgebra r b, IdempotentAlgebra r c, IdempotentAlgebra r d, IdempotentAlgebra r e) => IdempotentAlgebra r (a, b, c, d, e)
instance (IdempotentAlgebra r a, IdempotentAlgebra r b, IdempotentAlgebra r c, IdempotentAlgebra r d) => IdempotentAlgebra r (a, b, c, d)
instance (IdempotentAlgebra r a, IdempotentAlgebra r b, IdempotentAlgebra r c) => IdempotentAlgebra r (a, b, c)
instance (IdempotentAlgebra r a, IdempotentAlgebra r b) => IdempotentAlgebra r (a, b)
instance (Semiring r, Band r) => IdempotentAlgebra r ()
instance (Semiring r, Band r) => IdempotentAlgebra r IntSet
instance (Semiring r, Band r, Ord a) => IdempotentAlgebra r (Set a)
instance (Band a, Band b, Band c, Band d, Band e) => Band (a, b, c, d, e)
instance (Band a, Band b, Band c, Band d) => Band (a, b, c, d)
instance (Band a, Band b, Band c) => Band (a, b, c)
instance (Band a, Band b) => Band (a, b)
instance Band Bool
instance Band ()

module Numeric.Band.Class

-- | An multiplicative semigroup with idempotent multiplication.
--   
--   <pre>
--   a * a = a
--   </pre>
class Multiplicative r => Band r
pow1pBand :: r -> Natural -> r
powBand :: Unital r => r -> Natural -> r

module Numeric.Algebra.Division
class Unital r => Division r where recip a = one / a a / b = a * recip b a \\ b = recip a * b x0 ^ y0 = case compare y0 0 of { LT -> f (recip x0) (negate y0) EQ -> one GT -> f x0 y0 } where f x y | even y = f (x * x) (y `quot` 2) | y == 1 = x | otherwise = g (x * x) ((y - 1) `quot` 2) x g x y z | even y = g (x * x) (y `quot` 2) z | y == 1 = x * z | otherwise = g (x * x) ((y - 1) `quot` 2) (x * z)
recip :: Division r => r -> r
(/) :: Division r => r -> r -> r
(\\) :: Division r => r -> r -> r
(^) :: (Division r, Integral n) => r -> n -> r
class UnitalAlgebra r a => DivisionAlgebra r a
recipriocal :: DivisionAlgebra r a => (a -> r) -> a -> r
instance (Unital r, DivisionAlgebra r a) => Division (a -> r)
instance (Division a, Division b, Division c, Division d, Division e) => Division (a, b, c, d, e)
instance (Division a, Division b, Division c, Division d) => Division (a, b, c, d)
instance (Division a, Division b, Division c) => Division (a, b, c)
instance (Division a, Division b) => Division (a, b)
instance Division ()

module Numeric.Algebra.Hopf

-- | A HopfAlgebra algebra on a semiring, where the module is free.
--   
--   When <tt>antipode . antipode = id</tt> and antipode is an
--   antihomomorphism then we are an InvolutiveBialgebra with <tt>inv =
--   antipode</tt> as well
class Bialgebra r h => HopfAlgebra r h
antipode :: HopfAlgebra r h => (h -> r) -> h -> r
instance (HopfAlgebra r a, HopfAlgebra r b, HopfAlgebra r c, HopfAlgebra r d, HopfAlgebra r e) => HopfAlgebra r (a, b, c, d, e)
instance (HopfAlgebra r a, HopfAlgebra r b, HopfAlgebra r c, HopfAlgebra r d) => HopfAlgebra r (a, b, c, d)
instance (HopfAlgebra r a, HopfAlgebra r b, HopfAlgebra r c) => HopfAlgebra r (a, b, c)
instance (HopfAlgebra r a, HopfAlgebra r b) => HopfAlgebra r (a, b)

module Numeric.Decidable.Associates
class Unital r => DecidableAssociates r
isAssociate :: DecidableAssociates r => r -> r -> Bool
isAssociateIntegral :: (Eq n, Num n) => n -> n -> Bool
isAssociateWhole :: Eq n => n -> n -> Bool
instance (DecidableAssociates a, DecidableAssociates b, DecidableAssociates c, DecidableAssociates d, DecidableAssociates e) => DecidableAssociates (a, b, c, d, e)
instance (DecidableAssociates a, DecidableAssociates b, DecidableAssociates c, DecidableAssociates d) => DecidableAssociates (a, b, c, d)
instance (DecidableAssociates a, DecidableAssociates b, DecidableAssociates c) => DecidableAssociates (a, b, c)
instance (DecidableAssociates a, DecidableAssociates b) => DecidableAssociates (a, b)
instance DecidableAssociates ()
instance DecidableAssociates Word64
instance DecidableAssociates Word32
instance DecidableAssociates Word16
instance DecidableAssociates Word8
instance DecidableAssociates Word
instance DecidableAssociates Natural
instance DecidableAssociates Int64
instance DecidableAssociates Int32
instance DecidableAssociates Int16
instance DecidableAssociates Int8
instance DecidableAssociates Int
instance DecidableAssociates Integer
instance DecidableAssociates Bool

module Numeric.Decidable.Units
class Unital r => DecidableUnits r where isUnit = isJust . recipUnit x0 ^? y0 = case compare y0 0 of { LT -> fmap (`f` negate y0) (recipUnit x0) EQ -> Just one GT -> Just (f x0 y0) } where f x y | even y = f (x * x) (y `quot` 2) | y == 1 = x | otherwise = g (x * x) ((y - 1) `quot` 2) x g x y z | even y = g (x * x) (y `quot` 2) z | y == 1 = x * z | otherwise = g (x * x) ((y - 1) `quot` 2) (x * z)
recipUnit :: DecidableUnits r => r -> Maybe r
isUnit :: (DecidableUnits r, DecidableUnits r) => r -> Bool
(^?) :: (DecidableUnits r, Integral n) => r -> n -> Maybe r
recipUnitIntegral :: Integral r => r -> Maybe r
recipUnitWhole :: Integral r => r -> Maybe r
instance (DecidableUnits a, DecidableUnits b, DecidableUnits c, DecidableUnits d, DecidableUnits e) => DecidableUnits (a, b, c, d, e)
instance (DecidableUnits a, DecidableUnits b, DecidableUnits c, DecidableUnits d) => DecidableUnits (a, b, c, d)
instance (DecidableUnits a, DecidableUnits b, DecidableUnits c) => DecidableUnits (a, b, c)
instance (DecidableUnits a, DecidableUnits b) => DecidableUnits (a, b)
instance DecidableUnits ()
instance DecidableUnits Word64
instance DecidableUnits Word32
instance DecidableUnits Word16
instance DecidableUnits Word8
instance DecidableUnits Word
instance DecidableUnits Natural
instance DecidableUnits Int64
instance DecidableUnits Int32
instance DecidableUnits Int16
instance DecidableUnits Int8
instance DecidableUnits Int
instance DecidableUnits Integer
instance DecidableUnits Bool

module Numeric.Decidable.Zero
class Monoidal r => DecidableZero r
isZero :: DecidableZero r => r -> Bool
instance (DecidableZero a, DecidableZero b, DecidableZero c, DecidableZero d, DecidableZero e) => DecidableZero (a, b, c, d, e)
instance (DecidableZero a, DecidableZero b, DecidableZero c, DecidableZero d) => DecidableZero (a, b, c, d)
instance (DecidableZero a, DecidableZero b, DecidableZero c) => DecidableZero (a, b, c)
instance (DecidableZero a, DecidableZero b) => DecidableZero (a, b)
instance DecidableZero ()
instance DecidableZero Word64
instance DecidableZero Word32
instance DecidableZero Word16
instance DecidableZero Word8
instance DecidableZero Word
instance DecidableZero Natural
instance DecidableZero Int64
instance DecidableZero Int32
instance DecidableZero Int16
instance DecidableZero Int8
instance DecidableZero Int
instance DecidableZero Integer
instance DecidableZero Bool

module Numeric.Rig.Class

-- | A Ring without (n)egation
class (Semiring r, Unital r, Monoidal r) => Rig r where fromNatural n = sinnum n one
fromNatural :: Rig r => Natural -> r
instance (Rig a, Rig b, Rig c, Rig d, Rig e) => Rig (a, b, c, d, e)
instance (Rig a, Rig b, Rig c, Rig d) => Rig (a, b, c, d)
instance (Rig a, Rig b, Rig c) => Rig (a, b, c)
instance (Rig a, Rig b) => Rig (a, b)
instance Rig ()
instance Rig Word64
instance Rig Word32
instance Rig Word16
instance Rig Word8
instance Rig Word
instance Rig Int64
instance Rig Int32
instance Rig Int16
instance Rig Int8
instance Rig Int
instance Rig Bool
instance Rig Natural
instance Rig Integer

module Numeric.Rig.Characteristic
class Rig r => Characteristic r
char :: Characteristic r => proxy r -> Natural
charInt :: (Integral s, Bounded s) => proxy s -> Natural
charWord :: (Integral s, Bounded s) => proxy s -> Natural
instance (Characteristic a, Characteristic b, Characteristic c, Characteristic d, Characteristic e) => Characteristic (a, b, c, d, e)
instance (Characteristic a, Characteristic b, Characteristic c, Characteristic d) => Characteristic (a, b, c, d)
instance (Characteristic a, Characteristic b, Characteristic c) => Characteristic (a, b, c)
instance (Characteristic a, Characteristic b) => Characteristic (a, b)
instance Characteristic ()
instance Characteristic Word64
instance Characteristic Word32
instance Characteristic Word16
instance Characteristic Word8
instance Characteristic Word
instance Characteristic Int64
instance Characteristic Int32
instance Characteristic Int16
instance Characteristic Int8
instance Characteristic Int
instance Characteristic Natural
instance Characteristic Integer
instance Characteristic Bool

module Numeric.Rng.Class

-- | A Ring without an <i>i</i>dentity.
class (Group r, Semiring r) => Rng r
instance (Group r, Semiring r) => Rng r

module Numeric.Ring.Class
class (Rig r, Rng r) => Ring r where fromInteger n = times n one
fromInteger :: Ring r => Integer -> r
fromIntegral :: (Integral n, Ring r) => n -> r
instance (Ring a, Ring b, Ring c, Ring d, Ring e) => Ring (a, b, c, d, e)
instance (Ring a, Ring b, Ring c, Ring d) => Ring (a, b, c, d)
instance (Ring a, Ring b, Ring c) => Ring (a, b, c)
instance (Ring a, Ring b) => Ring (a, b)
instance Ring ()
instance Ring Word64
instance Ring Word32
instance Ring Word16
instance Ring Word8
instance Ring Word
instance Ring Int64
instance Ring Int32
instance Ring Int16
instance Ring Int8
instance Ring Int
instance Ring Integer

module Numeric.Ring.Local
class Ring r => LocalRing r

module Numeric.Ring.Division
class (Division r, Ring r) => DivisionRing r
instance (Division r, Ring r) => DivisionRing r

module Numeric.Band.Rectangular

-- | a rectangular band is a nowhere commutative semigroup. That is to say,
--   if ab = ba then a = b. From this it follows classically that aa = a
--   and that such a band is isomorphic to the following structure
data Rect i j
Rect :: i -> j -> Rect i j
instance (Eq i, Eq j) => Eq (Rect i j)
instance (Ord i, Ord j) => Ord (Rect i j)
instance (Show i, Show j) => Show (Rect i j)
instance (Read i, Read j) => Read (Rect i j)
instance Band (Rect i j)
instance Multiplicative (Rect i j)
instance Semigroupoid Rect

module Numeric.Semiring.Integral

-- | An integral semiring has no zero divisors
--   
--   <pre>
--   a * b = 0 implies a == 0 || b == 0
--   </pre>
class (Monoidal r, Semiring r) => IntegralSemiring r
instance IntegralSemiring Bool
instance IntegralSemiring Natural
instance IntegralSemiring Integer

module Numeric.Domain.Class

-- | (Integral) domain is the integral semiring.
class (IntegralSemiring d, Ring d) => Domain d
instance (IntegralSemiring d, Ring d) => Domain d

module Numeric.Domain.Euclidean
class (Ring r, DecidableZero r, DecidableUnits r, Domain r) => Euclidean r where quot a b = fst $ a `divide` b rem a b = snd $ a `divide` b gcd a b = let (g, _, _) : _ = euclid a b in g euclid f g = let (ug, g') = splitUnit g Just t' = recipUnit ug (uf, f') = splitUnit f Just s = recipUnit uf in step [(g', 0, t'), (f', s, 0)] where step acc@((r', s', t') : (r, s, t) : _) | isZero r' = tail acc | otherwise = let q = r `quot` r' (ur, r'') = splitUnit $ r - q * r' Just u = recipUnit ur s'' = (s - q * s') * u t'' = (t - q * t') * u in step ((r'', s'', t'') : acc) step _ = error "cannot happen!"
splitUnit :: Euclidean r => r -> (r, r)
degree :: Euclidean r => r -> Maybe Natural
divide :: Euclidean r => r -> r -> (r, r)
quot :: Euclidean r => r -> r -> r
rem :: Euclidean r => r -> r -> r
gcd :: Euclidean r => r -> r -> r
euclid :: Euclidean r => r -> r -> [(r, r, r)]
prs :: Euclidean r => r -> r -> [(r, r, r)]
normalize :: Euclidean r => r -> r
gcd' :: Euclidean r => [r] -> r
leadingUnit :: Euclidean r => r -> r
chineseRemainder :: Euclidean r => [(r, r)] -> r
instance Euclidean Integer

module Numeric.Module.Class
class (Semiring r, Additive m) => LeftModule r m
(.*) :: LeftModule r m => r -> m -> m
class (Semiring r, Additive m) => RightModule r m
(*.) :: RightModule r m => m -> r -> m
class (LeftModule r m, RightModule r m) => Module r m

module Numeric.Algebra.Commutative

-- | A commutative multiplicative semigroup
class Multiplicative r => Commutative r
class Algebra r a => CommutativeAlgebra r a
class Coalgebra r c => CocommutativeCoalgebra r c
class (Bialgebra r h, CommutativeAlgebra r h, CocommutativeCoalgebra r h) => CommutativeBialgebra r h
instance (Bialgebra r h, CommutativeAlgebra r h, CocommutativeCoalgebra r h) => CommutativeBialgebra r h
instance (Commutative r, Semiring r, Abelian b) => CocommutativeCoalgebra r (IntMap b)
instance (Commutative r, Semiring r, Ord a, Abelian b) => CocommutativeCoalgebra r (Map a b)
instance (Commutative r, Semiring r) => CocommutativeCoalgebra r IntSet
instance (Commutative r, Semiring r, Ord a) => CocommutativeCoalgebra r (Set a)
instance (CocommutativeCoalgebra r a, CocommutativeCoalgebra r b, CocommutativeCoalgebra r c, CocommutativeCoalgebra r d, CocommutativeCoalgebra r e) => CocommutativeCoalgebra r (a, b, c, d, e)
instance (CocommutativeCoalgebra r a, CocommutativeCoalgebra r b, CocommutativeCoalgebra r c, CocommutativeCoalgebra r d) => CocommutativeCoalgebra r (a, b, c, d)
instance (CocommutativeCoalgebra r a, CocommutativeCoalgebra r b, CocommutativeCoalgebra r c) => CocommutativeCoalgebra r (a, b, c)
instance (CocommutativeCoalgebra r a, CocommutativeCoalgebra r b) => CocommutativeCoalgebra r (a, b)
instance (Commutative r, Semiring r) => CocommutativeCoalgebra r ()
instance CommutativeAlgebra r m => CocommutativeCoalgebra r (m -> r)
instance (Commutative r, Monoidal r, Semiring r, Abelian b, Partitionable b) => CommutativeAlgebra r (IntMap b)
instance (Commutative r, Monoidal r, Semiring r, Ord a, Abelian b, Partitionable b) => CommutativeAlgebra r (Map a b)
instance (Commutative r, Semiring r) => CommutativeAlgebra r IntSet
instance (Commutative r, Semiring r, Ord a) => CommutativeAlgebra r (Set a)
instance (CommutativeAlgebra r a, CommutativeAlgebra r b, CommutativeAlgebra r c, CommutativeAlgebra r d, CommutativeAlgebra r e) => CommutativeAlgebra r (a, b, c, d, e)
instance (CommutativeAlgebra r a, CommutativeAlgebra r b, CommutativeAlgebra r c, CommutativeAlgebra r d) => CommutativeAlgebra r (a, b, c, d)
instance (CommutativeAlgebra r a, CommutativeAlgebra r b, CommutativeAlgebra r c) => CommutativeAlgebra r (a, b, c)
instance (CommutativeAlgebra r a, CommutativeAlgebra r b) => CommutativeAlgebra r (a, b)
instance (Commutative r, Semiring r) => CommutativeAlgebra r ()
instance CommutativeAlgebra r a => Commutative (a -> r)
instance (Commutative a, Commutative b, Commutative c, Commutative d, Commutative e) => Commutative (a, b, c, d, e)
instance (Commutative a, Commutative b, Commutative c, Commutative d) => Commutative (a, b, c, d)
instance (Commutative a, Commutative b, Commutative c) => Commutative (a, b, c)
instance (Commutative a, Commutative b) => Commutative (a, b)
instance Commutative Word64
instance Commutative Word32
instance Commutative Word16
instance Commutative Word8
instance Commutative Word
instance Commutative Natural
instance Commutative Int64
instance Commutative Int32
instance Commutative Int16
instance Commutative Int8
instance Commutative Int
instance Commutative Integer
instance Commutative Bool
instance Commutative ()

module Numeric.Algebra.Involutive

-- | An semigroup with involution
--   
--   <pre>
--   adjoint a * adjoint b = adjoint (b * a)
--   </pre>
class Multiplicative r => InvolutiveMultiplication r
adjoint :: InvolutiveMultiplication r => r -> r

-- | adjoint (x + y) = adjoint x + adjoint y
class (Semiring r, InvolutiveMultiplication r) => InvolutiveSemiring r
class (InvolutiveSemiring r, Algebra r a) => InvolutiveAlgebra r a
inv :: InvolutiveAlgebra r a => (a -> r) -> a -> r
class (InvolutiveSemiring r, Coalgebra r c) => InvolutiveCoalgebra r c
coinv :: InvolutiveCoalgebra r c => (c -> r) -> c -> r
class (Bialgebra r h, InvolutiveAlgebra r h, InvolutiveCoalgebra r h) => InvolutiveBialgebra r h

-- | <pre>
--   adjoint = id
--   </pre>
class (Commutative r, InvolutiveMultiplication r) => TriviallyInvolutive r
class (CommutativeAlgebra r a, TriviallyInvolutive r, InvolutiveAlgebra r a) => TriviallyInvolutiveAlgebra r a
class (CocommutativeCoalgebra r a, TriviallyInvolutive r, InvolutiveCoalgebra r a) => TriviallyInvolutiveCoalgebra r a
class (InvolutiveBialgebra r h, TriviallyInvolutiveAlgebra r h, TriviallyInvolutiveCoalgebra r h) => TriviallyInvolutiveBialgebra r h
instance (InvolutiveBialgebra r h, TriviallyInvolutiveAlgebra r h, TriviallyInvolutiveCoalgebra r h) => TriviallyInvolutiveBialgebra r h
instance (Bialgebra r h, InvolutiveAlgebra r h, InvolutiveCoalgebra r h) => InvolutiveBialgebra r h
instance (TriviallyInvolutiveCoalgebra r a, TriviallyInvolutiveCoalgebra r b, TriviallyInvolutiveCoalgebra r c, TriviallyInvolutiveCoalgebra r d, TriviallyInvolutiveCoalgebra r e) => TriviallyInvolutiveCoalgebra r (a, b, c, d, e)
instance (TriviallyInvolutiveCoalgebra r a, TriviallyInvolutiveCoalgebra r b, TriviallyInvolutiveCoalgebra r c, TriviallyInvolutiveCoalgebra r d) => TriviallyInvolutiveCoalgebra r (a, b, c, d)
instance (TriviallyInvolutiveCoalgebra r a, TriviallyInvolutiveCoalgebra r b, TriviallyInvolutiveCoalgebra r c) => TriviallyInvolutiveCoalgebra r (a, b, c)
instance (TriviallyInvolutiveCoalgebra r a, TriviallyInvolutiveCoalgebra r b) => TriviallyInvolutiveCoalgebra r (a, b)
instance (TriviallyInvolutive r, InvolutiveSemiring r) => TriviallyInvolutiveCoalgebra r ()
instance (InvolutiveCoalgebra r a, InvolutiveCoalgebra r b, InvolutiveCoalgebra r c, InvolutiveCoalgebra r d, InvolutiveCoalgebra r e) => InvolutiveCoalgebra r (a, b, c, d, e)
instance (InvolutiveCoalgebra r a, InvolutiveCoalgebra r b, InvolutiveCoalgebra r c, InvolutiveCoalgebra r d) => InvolutiveCoalgebra r (a, b, c, d)
instance (InvolutiveCoalgebra r a, InvolutiveCoalgebra r b, InvolutiveCoalgebra r c) => InvolutiveCoalgebra r (a, b, c)
instance (InvolutiveCoalgebra r a, InvolutiveCoalgebra r b) => InvolutiveCoalgebra r (a, b)
instance InvolutiveSemiring r => InvolutiveCoalgebra r ()
instance (TriviallyInvolutiveAlgebra r a, TriviallyInvolutiveAlgebra r b, TriviallyInvolutiveAlgebra r c, TriviallyInvolutiveAlgebra r d, TriviallyInvolutiveAlgebra r e) => TriviallyInvolutiveAlgebra r (a, b, c, d, e)
instance (TriviallyInvolutiveAlgebra r a, TriviallyInvolutiveAlgebra r b, TriviallyInvolutiveAlgebra r c, TriviallyInvolutiveAlgebra r d) => TriviallyInvolutiveAlgebra r (a, b, c, d)
instance (TriviallyInvolutiveAlgebra r a, TriviallyInvolutiveAlgebra r b, TriviallyInvolutiveAlgebra r c) => TriviallyInvolutiveAlgebra r (a, b, c)
instance (TriviallyInvolutiveAlgebra r a, TriviallyInvolutiveAlgebra r b) => TriviallyInvolutiveAlgebra r (a, b)
instance (TriviallyInvolutive r, InvolutiveSemiring r) => TriviallyInvolutiveAlgebra r ()
instance (InvolutiveAlgebra r a, InvolutiveAlgebra r b, InvolutiveAlgebra r c, InvolutiveAlgebra r d, InvolutiveAlgebra r e) => InvolutiveAlgebra r (a, b, c, d, e)
instance (InvolutiveAlgebra r a, InvolutiveAlgebra r b, InvolutiveAlgebra r c, InvolutiveAlgebra r d) => InvolutiveAlgebra r (a, b, c, d)
instance (InvolutiveAlgebra r a, InvolutiveAlgebra r b, InvolutiveAlgebra r c) => InvolutiveAlgebra r (a, b, c)
instance (InvolutiveAlgebra r a, InvolutiveAlgebra r b) => InvolutiveAlgebra r (a, b)
instance InvolutiveSemiring r => InvolutiveAlgebra r ()
instance (TriviallyInvolutive r, TriviallyInvolutiveAlgebra r a) => TriviallyInvolutive (a -> r)
instance (TriviallyInvolutive a, TriviallyInvolutive b, TriviallyInvolutive c, TriviallyInvolutive d, TriviallyInvolutive e) => TriviallyInvolutive (a, b, c, d, e)
instance (TriviallyInvolutive a, TriviallyInvolutive b, TriviallyInvolutive c, TriviallyInvolutive d) => TriviallyInvolutive (a, b, c, d)
instance (TriviallyInvolutive a, TriviallyInvolutive b, TriviallyInvolutive c) => TriviallyInvolutive (a, b, c)
instance (TriviallyInvolutive a, TriviallyInvolutive b) => TriviallyInvolutive (a, b)
instance TriviallyInvolutive ()
instance TriviallyInvolutive Word64
instance TriviallyInvolutive Word32
instance TriviallyInvolutive Word16
instance TriviallyInvolutive Word8
instance TriviallyInvolutive Natural
instance TriviallyInvolutive Word
instance TriviallyInvolutive Int64
instance TriviallyInvolutive Int32
instance TriviallyInvolutive Int16
instance TriviallyInvolutive Int8
instance TriviallyInvolutive Integer
instance TriviallyInvolutive Int
instance TriviallyInvolutive Bool
instance (InvolutiveSemiring a, InvolutiveSemiring b, InvolutiveSemiring c, InvolutiveSemiring d, InvolutiveSemiring e) => InvolutiveSemiring (a, b, c, d, e)
instance (InvolutiveSemiring a, InvolutiveSemiring b, InvolutiveSemiring c, InvolutiveSemiring d) => InvolutiveSemiring (a, b, c, d)
instance (InvolutiveSemiring a, InvolutiveSemiring b, InvolutiveSemiring c) => InvolutiveSemiring (a, b, c)
instance (InvolutiveSemiring a, InvolutiveSemiring b) => InvolutiveSemiring (a, b)
instance InvolutiveSemiring Word64
instance InvolutiveSemiring Word32
instance InvolutiveSemiring Word16
instance InvolutiveSemiring Word8
instance InvolutiveSemiring Word
instance InvolutiveSemiring Natural
instance InvolutiveSemiring Int64
instance InvolutiveSemiring Int32
instance InvolutiveSemiring Int16
instance InvolutiveSemiring Int8
instance InvolutiveSemiring Int
instance InvolutiveSemiring Integer
instance InvolutiveSemiring Bool
instance InvolutiveSemiring ()
instance InvolutiveAlgebra r h => InvolutiveMultiplication (h -> r)
instance (InvolutiveMultiplication a, InvolutiveMultiplication b, InvolutiveMultiplication c, InvolutiveMultiplication d, InvolutiveMultiplication e) => InvolutiveMultiplication (a, b, c, d, e)
instance (InvolutiveMultiplication a, InvolutiveMultiplication b, InvolutiveMultiplication c, InvolutiveMultiplication d) => InvolutiveMultiplication (a, b, c, d)
instance (InvolutiveMultiplication a, InvolutiveMultiplication b, InvolutiveMultiplication c) => InvolutiveMultiplication (a, b, c)
instance (InvolutiveMultiplication a, InvolutiveMultiplication b) => InvolutiveMultiplication (a, b)
instance InvolutiveMultiplication ()
instance InvolutiveMultiplication Word64
instance InvolutiveMultiplication Word32
instance InvolutiveMultiplication Word16
instance InvolutiveMultiplication Word8
instance InvolutiveMultiplication Natural
instance InvolutiveMultiplication Word
instance InvolutiveMultiplication Bool
instance InvolutiveMultiplication Int64
instance InvolutiveMultiplication Int32
instance InvolutiveMultiplication Int16
instance InvolutiveMultiplication Int8
instance InvolutiveMultiplication Integer
instance InvolutiveMultiplication Int

module Numeric.Semiring.Involutive

-- | adjoint (x + y) = adjoint x + adjoint y
class (Semiring r, InvolutiveMultiplication r) => InvolutiveSemiring r

module Numeric.Field.Class
class (Commutative r, DivisionRing r) => Field r
instance (Commutative r, DivisionRing r) => Field r

module Numeric.Coalgebra.Categorical
newtype Morphism a
Morphism :: a -> Morphism a
instance Typeable Morphism
instance Eq a => Eq (Morphism a)
instance Ord a => Ord (Morphism a)
instance Show a => Show (Morphism a)
instance Read a => Read (Morphism a)
instance PartialSemigroup a => PartialSemigroup (Morphism a)
instance PartialMonoid a => PartialMonoid (Morphism a)
instance PartialGroup a => PartialGroup (Morphism a)
instance Data a => Data (Morphism a)
instance (Commutative r, Monoidal r, Semiring r, PartialMonoid a) => CounitalCoalgebra r (Morphism a)
instance (Commutative r, Monoidal r, Semiring r, PartialSemigroup a) => Coalgebra r (Morphism a)

module Numeric.Covector

-- | Linear functionals from elements of an (infinite) free module to a
--   scalar
newtype Covector r a
Covector :: ((a -> r) -> r) -> Covector r a
($*) :: Covector r a -> (a -> r) -> r
counitM :: UnitalAlgebra r a => a -> Covector r ()
unitM :: CounitalCoalgebra r c => Covector r c
comultM :: Algebra r a => a -> Covector r (a, a)
multM :: Coalgebra r c => c -> c -> Covector r c
invM :: InvolutiveAlgebra r h => h -> Covector r h
coinvM :: InvolutiveCoalgebra r h => h -> Covector r h

-- | convolveM antipodeM return = convolveM return antipodeM = comultM
--   &gt;=&gt; uncurry joinM
antipodeM :: HopfAlgebra r h => h -> Covector r h
convolveM :: (Algebra r c, Coalgebra r a) => (c -> Covector r a) -> (c -> Covector r a) -> c -> Covector r a
instance RightModule r s => RightModule r (Covector s m)
instance Coalgebra r m => RightModule (Covector r m) (Covector r m)
instance LeftModule r s => LeftModule r (Covector s m)
instance Coalgebra r m => LeftModule (Covector r m) (Covector r m)
instance Group s => Group (Covector s a)
instance Abelian s => Abelian (Covector s a)
instance Monoidal s => Monoidal (Covector s a)
instance (Idempotent r, IdempotentCoalgebra r a) => Band (Covector r a)
instance Idempotent r => Idempotent (Covector r a)
instance (Ring r, CounitalCoalgebra r m) => Ring (Covector r m)
instance (Rig r, CounitalCoalgebra r m) => Rig (Covector r m)
instance CounitalCoalgebra r m => Unital (Covector r m)
instance Coalgebra r m => Semiring (Covector r m)
instance (Commutative m, Coalgebra r m) => Commutative (Covector r m)
instance Coalgebra r m => Multiplicative (Covector r m)
instance Additive r => Additive (Covector r a)
instance Monoidal r => MonadPlus (Covector r)
instance Monoidal r => Alternative (Covector r)
instance Monoidal r => Plus (Covector r)
instance Additive r => Alt (Covector r)
instance Monad (Covector r)
instance Bind (Covector r)
instance Applicative (Covector r)
instance Apply (Covector r)
instance Functor (Covector r)

module Numeric.Algebra.Distinguished.Class
class Distinguished t
e :: Distinguished t => t
instance Distinguished a => Distinguished (Covector r a)

module Numeric.Algebra.Complex.Class
class Distinguished r => Complicated r
i :: Complicated r => r
instance Complicated a => Complicated (Covector r a)

module Numeric.Algebra.Quaternion.Class
class Complicated t => Hamiltonian t
j :: Hamiltonian t => t
k :: Hamiltonian t => t
instance Hamiltonian a => Hamiltonian (Covector r a)

module Numeric.Algebra.Dual.Class
class Distinguished t => Infinitesimal t
d :: Infinitesimal t => t
instance Infinitesimal a => Infinitesimal (Covector r a)

module Numeric.Coalgebra.Hyperbolic.Class
class Hyperbolic r
cosh :: Hyperbolic r => r
sinh :: Hyperbolic r => r
instance Hyperbolic a => Hyperbolic (Covector r a)

module Numeric.Coalgebra.Trigonometric.Class
class Trigonometric r
cos :: Trigonometric r => r
sin :: Trigonometric r => r
instance Trigonometric a => Trigonometric (Covector r a)

module Numeric.Dioid.Class
class (Semiring r, Idempotent r) => Dioid r
instance (Semiring r, Idempotent r) => Dioid r

module Numeric.Module.Representable

-- | `Additive.(+)` default definition
addRep :: (Applicative m, Additive r) => m r -> m r -> m r

-- | <a>sinnum1p</a> default definition
sinnum1pRep :: (Functor m, Additive r) => Natural -> m r -> m r

-- | <a>zero</a> default definition
zeroRep :: (Applicative m, Monoidal r) => m r

-- | <a>sinnum</a> default definition
sinnumRep :: (Functor m, Monoidal r) => Natural -> m r -> m r

-- | <a>negate</a> default definition
negateRep :: (Functor m, Group r) => m r -> m r

-- | `Group.(-)` default definition
minusRep :: (Applicative m, Group r) => m r -> m r -> m r

-- | <a>subtract</a> default definition
subtractRep :: (Applicative m, Group r) => m r -> m r -> m r

-- | <a>times</a> default definition
timesRep :: (Integral n, Functor m, Group r) => n -> m r -> m r

-- | `Multiplicative.(*)` default definition
mulRep :: (Representable m, Algebra r (Rep m)) => m r -> m r -> m r

-- | <a>one</a> default definition
oneRep :: (Representable m, Unital r, UnitalAlgebra r (Rep m)) => m r

-- | <a>fromNatural</a> default definition
fromNaturalRep :: (UnitalAlgebra r (Rep m), Representable m, Rig r) => Natural -> m r

-- | <a>fromInteger</a> default definition
fromIntegerRep :: (UnitalAlgebra r (Rep m), Representable m, Ring r) => Integer -> m r

module Numeric.Order.Additive

-- | z + x &lt;= z + y = x &lt;= y = x + z &lt;= y + z
class (Additive r, Order r) => AdditiveOrder r
instance (AdditiveOrder a, AdditiveOrder b, AdditiveOrder c, AdditiveOrder d, AdditiveOrder e) => AdditiveOrder (a, b, c, d, e)
instance (AdditiveOrder a, AdditiveOrder b, AdditiveOrder c, AdditiveOrder d) => AdditiveOrder (a, b, c, d)
instance (AdditiveOrder a, AdditiveOrder b, AdditiveOrder c) => AdditiveOrder (a, b, c)
instance (AdditiveOrder a, AdditiveOrder b) => AdditiveOrder (a, b)
instance AdditiveOrder ()
instance AdditiveOrder Bool
instance AdditiveOrder Natural
instance AdditiveOrder Integer

module Numeric.Rig.Ordered
class (AdditiveOrder r, Rig r) => OrderedRig r
instance (OrderedRig a, OrderedRig b, OrderedRig c, OrderedRig d, OrderedRig e) => OrderedRig (a, b, c, d, e)
instance (OrderedRig a, OrderedRig b, OrderedRig c, OrderedRig d) => OrderedRig (a, b, c, d)
instance (OrderedRig a, OrderedRig b, OrderedRig c) => OrderedRig (a, b, c)
instance (OrderedRig a, OrderedRig b) => OrderedRig (a, b)
instance OrderedRig ()
instance OrderedRig Bool
instance OrderedRig Natural
instance OrderedRig Integer

module Numeric.Order.LocallyFinite
class Order a => LocallyFiniteOrder a where moebiusInversion x y = case order x y of { Just EQ -> one Just LT -> sumWith (\ z -> if z < y then moebiusInversion x z else zero) $ range x y _ -> zero }
range :: LocallyFiniteOrder a => a -> a -> [a]
rangeSize :: LocallyFiniteOrder a => a -> a -> Natural
moebiusInversion :: (LocallyFiniteOrder a, Ring r) => a -> a -> r
instance (LocallyFiniteOrder a, LocallyFiniteOrder b, LocallyFiniteOrder c, LocallyFiniteOrder d, LocallyFiniteOrder e) => LocallyFiniteOrder (a, b, c, d, e)
instance (LocallyFiniteOrder a, LocallyFiniteOrder b, LocallyFiniteOrder c, LocallyFiniteOrder d) => LocallyFiniteOrder (a, b, c, d)
instance (LocallyFiniteOrder a, LocallyFiniteOrder b, LocallyFiniteOrder c) => LocallyFiniteOrder (a, b, c)
instance (LocallyFiniteOrder a, LocallyFiniteOrder b) => LocallyFiniteOrder (a, b)
instance LocallyFiniteOrder ()
instance LocallyFiniteOrder Word64
instance LocallyFiniteOrder Word32
instance LocallyFiniteOrder Word16
instance LocallyFiniteOrder Word8
instance LocallyFiniteOrder Word
instance LocallyFiniteOrder Int64
instance LocallyFiniteOrder Int32
instance LocallyFiniteOrder Int16
instance LocallyFiniteOrder Int8
instance LocallyFiniteOrder Int
instance LocallyFiniteOrder Bool
instance Ord a => LocallyFiniteOrder (Set a)
instance LocallyFiniteOrder Integer
instance LocallyFiniteOrder Natural

module Numeric.Algebra.Incidence
data Interval a
Interval :: a -> a -> Interval a
zeta :: Unital r => Interval a -> r
moebius :: (Ring r, LocallyFiniteOrder a) => Interval a -> r
instance Typeable Interval
instance Eq a => Eq (Interval a)
instance Ord a => Ord (Interval a)
instance Show a => Show (Interval a)
instance Read a => Read (Interval a)
instance Data a => Data (Interval a)
instance (Commutative r, Monoidal r, Semiring r, LocallyFiniteOrder a) => UnitalAlgebra r (Interval a)
instance (Commutative r, Monoidal r, Semiring r, LocallyFiniteOrder a) => Algebra r (Interval a)

module Numeric.Coalgebra.Incidence

-- | the dual incidence algebra basis
data Interval' a
Interval' :: a -> a -> Interval' a
zeta' :: Unital r => Interval' a -> r
moebius' :: (Ring r, LocallyFiniteOrder a) => Interval' a -> r
instance Typeable Interval'
instance Eq a => Eq (Interval' a)
instance Ord a => Ord (Interval' a)
instance Show a => Show (Interval' a)
instance Read a => Read (Interval' a)
instance Data a => Data (Interval' a)
instance (Eq a, Bounded a, Commutative r, Monoidal r, Semiring r) => CounitalCoalgebra r (Interval' a)
instance (Eq a, Commutative r, Monoidal r, Semiring r) => Coalgebra r (Interval' a)

module Numeric.Quadrance.Class
class Additive r => Quadrance r m
quadrance :: Quadrance r m => m -> r
instance Rig r => Quadrance r Word64
instance Rig r => Quadrance r Word32
instance Rig r => Quadrance r Word16
instance Rig r => Quadrance r Word8
instance Rig r => Quadrance r Int64
instance Rig r => Quadrance r Int32
instance Rig r => Quadrance r Int16
instance Rig r => Quadrance r Int8
instance Rig r => Quadrance r Integer
instance Rig r => Quadrance r Natural
instance Rig r => Quadrance r Word
instance Rig r => Quadrance r Int
instance Rig r => Quadrance r Bool
instance (Quadrance r a, Quadrance r b, Quadrance r c, Quadrance r d, Quadrance r e) => Quadrance r (a, b, c, d, e)
instance (Quadrance r a, Quadrance r b, Quadrance r c, Quadrance r d) => Quadrance r (a, b, c, d)
instance (Quadrance r a, Quadrance r b, Quadrance r c) => Quadrance r (a, b, c)
instance (Quadrance r a, Quadrance r b) => Quadrance r (a, b)
instance Monoidal r => Quadrance r ()
instance Quadrance () a

module Numeric.Algebra

-- | <pre>
--   (a + b) + c = a + (b + c)
--   sinnum 1 a = a
--   sinnum (2 * n) a = sinnum n a + sinnum n a
--   sinnum (2 * n + 1) a = sinnum n a + sinnum n a + a
--   </pre>
class Additive r where sinnum1p y0 x0 = f x0 (1 + y0) where f x y | even y = f (x + x) (y `quot` 2) | y == 1 = x | otherwise = g (x + x) (pred y `quot` 2) x g x y z | even y = g (x + x) (y `quot` 2) z | y == 1 = x + z | otherwise = g (x + x) (pred y `quot` 2) (x + z) sumWith1 f = maybe (error "Numeric.Additive.Semigroup.sumWith1: empty structure") id . foldl' mf Nothing where mf Nothing y = Just $! f y mf (Just x) y = Just $! x + f y
(+) :: Additive r => r -> r -> r
sinnum1p :: Additive r => Natural -> r -> r
sumWith1 :: (Additive r, Foldable1 f) => (a -> r) -> f a -> r
sum1 :: (Foldable1 f, Additive r) => f r -> r

-- | an additive abelian semigroup
--   
--   a + b = b + a
class Additive r => Abelian r

-- | An additive semigroup with idempotent addition.
--   
--   <pre>
--   a + a = a
--   </pre>
class Additive r => Idempotent r
sinnum1pIdempotent :: Natural -> r -> r
sinnumIdempotent :: (Integral n, Idempotent r, Monoidal r) => n -> r -> r
class Additive m => Partitionable m
partitionWith :: Partitionable m => (m -> m -> r) -> m -> NonEmpty r

-- | An additive monoid
--   
--   <pre>
--   zero + a = a = a + zero
--   </pre>
class (LeftModule Natural m, RightModule Natural m) => Monoidal m where sinnum 0 _ = zero sinnum n x0 = f x0 n where f x y | even y = f (x + x) (y `quot` 2) | y == 1 = x | otherwise = g (x + x) (pred y `quot` 2) x g x y z | even y = g (x + x) (y `quot` 2) z | y == 1 = x + z | otherwise = g (x + x) (pred y `quot` 2) (x + z) sumWith f = foldl' (\ b a -> b + f a) zero
zero :: Monoidal m => m
sinnum :: Monoidal m => Natural -> m -> m
sumWith :: (Monoidal m, Foldable f) => (a -> m) -> f a -> m
sum :: (Foldable f, Monoidal m) => f m -> m
class (LeftModule Integer r, RightModule Integer r, Monoidal r) => Group r where times y0 x0 = case compare y0 0 of { LT -> f (negate x0) (negate y0) EQ -> zero GT -> f x0 y0 } where f x y | even y = f (x + x) (y `quot` 2) | y == 1 = x | otherwise = g (x + x) ((y - 1) `quot` 2) x g x y z | even y = g (x + x) (y `quot` 2) z | y == 1 = x + z | otherwise = g (x + x) ((y - 1) `quot` 2) (x + z) negate a = zero - a a - b = a + negate b subtract a b = negate a + b
(-) :: Group r => r -> r -> r
negate :: Group r => r -> r
subtract :: Group r => r -> r -> r
times :: (Group r, Integral n) => n -> r -> r

-- | A multiplicative semigroup
class Multiplicative r where pow1p x0 y0 = f x0 (y0 + 1) where f x y | even y = f (x * x) (y `quot` 2) | y == 1 = x | otherwise = g (x * x) ((y - 1) `quot` 2) x g x y z | even y = g (x * x) (y `quot` 2) z | y == 1 = x * z | otherwise = g (x * x) ((y - 1) `quot` 2) (x * z) productWith1 f = maybe (error "Numeric.Multiplicative.Semigroup.productWith1: empty structure") id . foldl' mf Nothing where mf Nothing y = Just $! f y mf (Just x) y = Just $! x * f y
(*) :: Multiplicative r => r -> r -> r
pow1p :: Multiplicative r => r -> Natural -> r
productWith1 :: (Multiplicative r, Foldable1 f) => (a -> r) -> f a -> r
product1 :: (Foldable1 f, Multiplicative r) => f r -> r

-- | A commutative multiplicative semigroup
class Multiplicative r => Commutative r
class Multiplicative r => Unital r where pow _ 0 = one pow x0 y0 = f x0 y0 where f x y | even y = f (x * x) (y `quot` 2) | y == 1 = x | otherwise = g (x * x) ((y - 1) `quot` 2) x g x y z | even y = g (x * x) (y `quot` 2) z | y == 1 = x * z | otherwise = g (x * x) ((y - 1) `quot` 2) (x * z) productWith f = foldl' (\ b a -> b * f a) one
one :: Unital r => r
pow :: Unital r => r -> Natural -> r
productWith :: (Unital r, Foldable f) => (a -> r) -> f a -> r
product :: (Foldable f, Unital r) => f r -> r

-- | An multiplicative semigroup with idempotent multiplication.
--   
--   <pre>
--   a * a = a
--   </pre>
class Multiplicative r => Band r
pow1pBand :: r -> Natural -> r
powBand :: Unital r => r -> Natural -> r
class Unital r => Division r where recip a = one / a a / b = a * recip b a \\ b = recip a * b x0 ^ y0 = case compare y0 0 of { LT -> f (recip x0) (negate y0) EQ -> one GT -> f x0 y0 } where f x y | even y = f (x * x) (y `quot` 2) | y == 1 = x | otherwise = g (x * x) ((y - 1) `quot` 2) x g x y z | even y = g (x * x) (y `quot` 2) z | y == 1 = x * z | otherwise = g (x * x) ((y - 1) `quot` 2) (x * z)
recip :: Division r => r -> r
(/) :: Division r => r -> r -> r
(\\) :: Division r => r -> r -> r
(^) :: (Division r, Integral n) => r -> n -> r

-- | `factorWith f c` returns a non-empty list containing `f a b` for all
--   `a, b` such that `a * b = c`.
--   
--   Results of factorWith f 0 are undefined and may result in either an
--   error or an infinite list.
class Multiplicative m => Factorable m
factorWith :: Factorable m => (m -> m -> r) -> m -> NonEmpty r

-- | An semigroup with involution
--   
--   <pre>
--   adjoint a * adjoint b = adjoint (b * a)
--   </pre>
class Multiplicative r => InvolutiveMultiplication r
adjoint :: InvolutiveMultiplication r => r -> r

-- | <pre>
--   adjoint = id
--   </pre>
class (Commutative r, InvolutiveMultiplication r) => TriviallyInvolutive r

-- | A pair of an additive abelian semigroup, and a multiplicative
--   semigroup, with the distributive laws:
--   
--   <pre>
--   a(b + c) = ab + ac -- left distribution (we are a LeftNearSemiring)
--   (a + b)c = ac + bc -- right distribution (we are a [Right]NearSemiring)
--   </pre>
--   
--   Common notation includes the laws for additive and multiplicative
--   identity in semiring.
--   
--   If you want that, look at <tt>Rig</tt> instead.
--   
--   Ideally we'd use the cyclic definition:
--   
--   <pre>
--   class (LeftModule r r, RightModule r r, Additive r, Abelian r, Multiplicative r) =&gt; Semiring r
--   </pre>
--   
--   to enforce that every semiring r is an r-module over itself, but
--   Haskell doesn't like that.
class (Additive r, Abelian r, Multiplicative r) => Semiring r

-- | adjoint (x + y) = adjoint x + adjoint y
class (Semiring r, InvolutiveMultiplication r) => InvolutiveSemiring r
class (Semiring r, Idempotent r) => Dioid r

-- | A Ring without an <i>i</i>dentity.
class (Group r, Semiring r) => Rng r

-- | A Ring without (n)egation
class (Semiring r, Unital r, Monoidal r) => Rig r where fromNatural n = sinnum n one
fromNatural :: Rig r => Natural -> r
class (Rig r, Rng r) => Ring r where fromInteger n = times n one
fromInteger :: Ring r => Integer -> r
class Ring r => LocalRing r
class (Division r, Ring r) => DivisionRing r
class (Commutative r, DivisionRing r) => Field r
class (Semiring r, Additive m) => LeftModule r m
(.*) :: LeftModule r m => r -> m -> m
class (Semiring r, Additive m) => RightModule r m
(*.) :: RightModule r m => m -> r -> m
class (LeftModule r m, RightModule r m) => Module r m

-- | An associative algebra built with a free module over a semiring
class Semiring r => Algebra r a
mult :: Algebra r a => (a -> a -> r) -> a -> r
class Semiring r => Coalgebra r c
comult :: Coalgebra r c => (c -> r) -> c -> c -> r

-- | An associative unital algebra over a semiring, built using a free
--   module
class Algebra r a => UnitalAlgebra r a
unit :: UnitalAlgebra r a => r -> a -> r
class Coalgebra r c => CounitalCoalgebra r c
counit :: CounitalCoalgebra r c => (c -> r) -> r

-- | A bialgebra is both a unital algebra and counital coalgebra where the
--   <a>mult</a> and <a>unit</a> are compatible in some sense with the
--   <a>comult</a> and <a>counit</a>. That is to say that <a>mult</a> and
--   <a>unit</a> are a coalgebra homomorphisms or (equivalently) that
--   <a>comult</a> and <a>counit</a> are an algebra homomorphisms.
class (UnitalAlgebra r a, CounitalCoalgebra r a) => Bialgebra r a
class (InvolutiveSemiring r, Algebra r a) => InvolutiveAlgebra r a
inv :: InvolutiveAlgebra r a => (a -> r) -> a -> r
class (InvolutiveSemiring r, Coalgebra r c) => InvolutiveCoalgebra r c
coinv :: InvolutiveCoalgebra r c => (c -> r) -> c -> r
class (Bialgebra r h, InvolutiveAlgebra r h, InvolutiveCoalgebra r h) => InvolutiveBialgebra r h
class (CommutativeAlgebra r a, TriviallyInvolutive r, InvolutiveAlgebra r a) => TriviallyInvolutiveAlgebra r a
class (CocommutativeCoalgebra r a, TriviallyInvolutive r, InvolutiveCoalgebra r a) => TriviallyInvolutiveCoalgebra r a
class (InvolutiveBialgebra r h, TriviallyInvolutiveAlgebra r h, TriviallyInvolutiveCoalgebra r h) => TriviallyInvolutiveBialgebra r h
class Algebra r a => IdempotentAlgebra r a
class (Bialgebra r h, IdempotentAlgebra r h, IdempotentCoalgebra r h) => IdempotentBialgebra r h
class Algebra r a => CommutativeAlgebra r a
class (Bialgebra r h, CommutativeAlgebra r h, CocommutativeCoalgebra r h) => CommutativeBialgebra r h
class Coalgebra r c => CocommutativeCoalgebra r c
class UnitalAlgebra r a => DivisionAlgebra r a
recipriocal :: DivisionAlgebra r a => (a -> r) -> a -> r

-- | A HopfAlgebra algebra on a semiring, where the module is free.
--   
--   When <tt>antipode . antipode = id</tt> and antipode is an
--   antihomomorphism then we are an InvolutiveBialgebra with <tt>inv =
--   antipode</tt> as well
class Bialgebra r h => HopfAlgebra r h
antipode :: HopfAlgebra r h => (h -> r) -> h -> r
class Rig r => Characteristic r
char :: Characteristic r => proxy r -> Natural
charInt :: (Integral s, Bounded s) => proxy s -> Natural
charWord :: (Integral s, Bounded s) => proxy s -> Natural
class Order a where a <~ b = maybe False (<= EQ) (order a b) a < b = order a b == Just LT a >~ b = b <~ a a > b = order a b == Just GT a ~~ b = order a b == Just EQ a /~ b = order a b /= Just EQ order a b | a <~ b = Just $ if b <~ a then EQ else LT | b <~ a = Just GT | otherwise = Nothing comparable a b = maybe False (const True) (order a b)
(<~) :: Order a => a -> a -> Bool
(<) :: Order a => a -> a -> Bool
(>~) :: Order a => a -> a -> Bool
(>) :: Order a => a -> a -> Bool
(~~) :: Order a => a -> a -> Bool
(/~) :: Order a => a -> a -> Bool
order :: Order a => a -> a -> Maybe Ordering
comparable :: Order a => a -> a -> Bool
class (AdditiveOrder r, Rig r) => OrderedRig r

-- | z + x &lt;= z + y = x &lt;= y = x + z &lt;= y + z
class (Additive r, Order r) => AdditiveOrder r
class Order a => LocallyFiniteOrder a where moebiusInversion x y = case order x y of { Just EQ -> one Just LT -> sumWith (\ z -> if z < y then moebiusInversion x z else zero) $ range x y _ -> zero }
class Monoidal r => DecidableZero r
class Unital r => DecidableUnits r where isUnit = isJust . recipUnit x0 ^? y0 = case compare y0 0 of { LT -> fmap (`f` negate y0) (recipUnit x0) EQ -> Just one GT -> Just (f x0 y0) } where f x y | even y = f (x * x) (y `quot` 2) | y == 1 = x | otherwise = g (x * x) ((y - 1) `quot` 2) x g x y z | even y = g (x * x) (y `quot` 2) z | y == 1 = x * z | otherwise = g (x * x) ((y - 1) `quot` 2) (x * z)
class Unital r => DecidableAssociates r

-- | Type representing arbitrary-precision non-negative integers.
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>.
--   
--   The <a>Natural</a> type has become part of <tt>base</tt> starting with
--   `base-4.8.0.0`.
data Natural :: *

-- | `Additive.(+)` default definition
addRep :: (Applicative m, Additive r) => m r -> m r -> m r

-- | <a>sinnum1p</a> default definition
sinnum1pRep :: (Functor m, Additive r) => Natural -> m r -> m r

-- | <a>zero</a> default definition
zeroRep :: (Applicative m, Monoidal r) => m r

-- | <a>sinnum</a> default definition
sinnumRep :: (Functor m, Monoidal r) => Natural -> m r -> m r

-- | <a>negate</a> default definition
negateRep :: (Functor m, Group r) => m r -> m r

-- | `Group.(-)` default definition
minusRep :: (Applicative m, Group r) => m r -> m r -> m r

-- | <a>subtract</a> default definition
subtractRep :: (Applicative m, Group r) => m r -> m r -> m r

-- | <a>times</a> default definition
timesRep :: (Integral n, Functor m, Group r) => n -> m r -> m r

-- | `Multiplicative.(*)` default definition
mulRep :: (Representable m, Algebra r (Rep m)) => m r -> m r -> m r

-- | <a>one</a> default definition
oneRep :: (Representable m, Unital r, UnitalAlgebra r (Rep m)) => m r

-- | <a>fromNatural</a> default definition
fromNaturalRep :: (UnitalAlgebra r (Rep m), Representable m, Rig r) => Natural -> m r

-- | <a>fromInteger</a> default definition
fromIntegerRep :: (UnitalAlgebra r (Rep m), Representable m, Ring r) => Integer -> m r
class Additive r => Quadrance r m
quadrance :: Quadrance r m => m -> r

-- | Linear functionals from elements of an (infinite) free module to a
--   scalar
newtype Covector r a
Covector :: ((a -> r) -> r) -> Covector r a
($*) :: Covector r a -> (a -> r) -> r
counitM :: UnitalAlgebra r a => a -> Covector r ()
unitM :: CounitalCoalgebra r c => Covector r c
comultM :: Algebra r a => a -> Covector r (a, a)
multM :: Coalgebra r c => c -> c -> Covector r c
invM :: InvolutiveAlgebra r h => h -> Covector r h
coinvM :: InvolutiveCoalgebra r h => h -> Covector r h

-- | convolveM antipodeM return = convolveM return antipodeM = comultM
--   &gt;=&gt; uncurry joinM
antipodeM :: HopfAlgebra r h => h -> Covector r h
convolveM :: (Algebra r c, Coalgebra r a) => (c -> Covector r a) -> (c -> Covector r a) -> c -> Covector r a

module Numeric.Algebra.Complex
class Distinguished t
e :: Distinguished t => t
class Distinguished r => Complicated r
i :: Complicated r => r
data ComplexBasis
E :: ComplexBasis
I :: ComplexBasis
data Complex a
Complex :: a -> a -> Complex a
realPart :: (Representable f, Rep f ~ ComplexBasis) => f a -> a
imagPart :: (Representable f, Rep f ~ ComplexBasis) => f a -> a

-- | half of the Cayley-Dickson quaternion isomorphism
uncomplicate :: Hamiltonian q => ComplexBasis -> ComplexBasis -> q
instance Typeable ComplexBasis
instance Typeable Complex
instance Eq ComplexBasis
instance Ord ComplexBasis
instance Show ComplexBasis
instance Read ComplexBasis
instance Enum ComplexBasis
instance Ix ComplexBasis
instance Bounded ComplexBasis
instance Data ComplexBasis
instance Eq a => Eq (Complex a)
instance Show a => Show (Complex a)
instance Read a => Read (Complex a)
instance Data a => Data (Complex a)
instance (Commutative r, InvolutiveSemiring r, DivisionRing r) => Division (Complex r)
instance (Commutative r, Rng r, InvolutiveSemiring r) => Quadrance r (Complex r)
instance (Commutative r, Rng r, InvolutiveSemiring r) => InvolutiveSemiring (Complex r)
instance (Commutative r, Rng r, InvolutiveMultiplication r) => InvolutiveMultiplication (Complex r)
instance (Commutative r, Rng r) => RightModule (Complex r) (Complex r)
instance (Commutative r, Rng r) => LeftModule (Complex r) (Complex r)
instance (Commutative r, Ring r) => Ring (Complex r)
instance (Commutative r, Ring r) => Rig (Complex r)
instance (Commutative r, Ring r) => Unital (Complex r)
instance (Commutative r, Rng r) => Semiring (Complex r)
instance (TriviallyInvolutive r, Rng r) => Commutative (Complex r)
instance (Commutative r, Rng r) => Multiplicative (Complex r)
instance (InvolutiveSemiring k, Rng k) => HopfAlgebra k ComplexBasis
instance (InvolutiveSemiring k, Rng k) => InvolutiveCoalgebra k ComplexBasis
instance (InvolutiveSemiring k, Rng k) => InvolutiveAlgebra k ComplexBasis
instance Rng k => Bialgebra k ComplexBasis
instance Rng k => CounitalCoalgebra k ComplexBasis
instance Rng k => Coalgebra k ComplexBasis
instance Rng k => UnitalAlgebra k ComplexBasis
instance Rng k => Algebra k ComplexBasis
instance Partitionable r => Partitionable (Complex r)
instance Idempotent r => Idempotent (Complex r)
instance Abelian r => Abelian (Complex r)
instance Group r => Group (Complex r)
instance Monoidal r => Monoidal (Complex r)
instance RightModule r s => RightModule r (Complex s)
instance LeftModule r s => LeftModule r (Complex s)
instance Additive r => Additive (Complex r)
instance Traversable1 Complex
instance Foldable1 Complex
instance Traversable Complex
instance Foldable Complex
instance MonadReader ComplexBasis Complex
instance Monad Complex
instance Bind Complex
instance Applicative Complex
instance Apply Complex
instance Functor Complex
instance Distributive Complex
instance Representable Complex
instance Rig r => Complicated (ComplexBasis -> r)
instance Rig r => Distinguished (ComplexBasis -> r)
instance Rig r => Complicated (Complex r)
instance Rig r => Distinguished (Complex r)
instance Complicated ComplexBasis
instance Distinguished ComplexBasis

module Numeric.Algebra.Quaternion
class Distinguished t
e :: Distinguished t => t
class Distinguished r => Complicated r
i :: Complicated r => r
class Complicated t => Hamiltonian t
j :: Hamiltonian t => t
k :: Hamiltonian t => t
data QuaternionBasis
E :: QuaternionBasis
I :: QuaternionBasis
J :: QuaternionBasis
K :: QuaternionBasis
data Quaternion a
Quaternion :: a -> a -> a -> a -> Quaternion a

-- | Cayley-Dickson quaternion isomorphism (one way)
complicate :: Complicated c => QuaternionBasis -> (c, c)
vectorPart :: (Representable f, Rep f ~ QuaternionBasis) => f r -> (r, r, r)
scalarPart :: (Representable f, Rep f ~ QuaternionBasis) => f r -> r
instance Typeable QuaternionBasis
instance Typeable Quaternion
instance Eq QuaternionBasis
instance Ord QuaternionBasis
instance Enum QuaternionBasis
instance Read QuaternionBasis
instance Show QuaternionBasis
instance Bounded QuaternionBasis
instance Ix QuaternionBasis
instance Data QuaternionBasis
instance Eq a => Eq (Quaternion a)
instance Show a => Show (Quaternion a)
instance Read a => Read (Quaternion a)
instance Data a => Data (Quaternion a)
instance (TriviallyInvolutive r, Ring r, Division r) => Division (Quaternion r)
instance (TriviallyInvolutive r, Rng r) => Quadrance r (Quaternion r)
instance (TriviallyInvolutive r, Rng r) => InvolutiveMultiplication (Quaternion r)
instance (TriviallyInvolutive r, Rng r) => RightModule (Quaternion r) (Quaternion r)
instance (TriviallyInvolutive r, Rng r) => LeftModule (Quaternion r) (Quaternion r)
instance (TriviallyInvolutive r, Ring r) => Ring (Quaternion r)
instance (TriviallyInvolutive r, Ring r) => Rig (Quaternion r)
instance (TriviallyInvolutive r, Ring r) => Unital (Quaternion r)
instance (TriviallyInvolutive r, Rng r) => Semiring (Quaternion r)
instance (TriviallyInvolutive r, Rng r) => Multiplicative (Quaternion r)
instance (TriviallyInvolutive r, InvolutiveSemiring r, Rng r) => HopfAlgebra r QuaternionBasis
instance (TriviallyInvolutive r, InvolutiveSemiring r, Rng r) => InvolutiveCoalgebra r QuaternionBasis
instance (TriviallyInvolutive r, InvolutiveSemiring r, Rng r) => InvolutiveAlgebra r QuaternionBasis
instance (TriviallyInvolutive r, Rng r) => Bialgebra r QuaternionBasis
instance (TriviallyInvolutive r, Rng r) => CounitalCoalgebra r QuaternionBasis
instance (TriviallyInvolutive r, Rng r) => Coalgebra r QuaternionBasis
instance (TriviallyInvolutive r, Rng r) => UnitalAlgebra r QuaternionBasis
instance (TriviallyInvolutive r, Rng r) => Algebra r QuaternionBasis
instance Partitionable r => Partitionable (Quaternion r)
instance Idempotent r => Idempotent (Quaternion r)
instance Abelian r => Abelian (Quaternion r)
instance Group r => Group (Quaternion r)
instance Monoidal r => Monoidal (Quaternion r)
instance RightModule r s => RightModule r (Quaternion s)
instance LeftModule r s => LeftModule r (Quaternion s)
instance Additive r => Additive (Quaternion r)
instance Traversable1 Quaternion
instance Foldable1 Quaternion
instance Traversable Quaternion
instance Foldable Quaternion
instance MonadReader QuaternionBasis Quaternion
instance Monad Quaternion
instance Bind Quaternion
instance Applicative Quaternion
instance Apply Quaternion
instance Functor Quaternion
instance Distributive Quaternion
instance Representable Quaternion
instance Rig r => Hamiltonian (QuaternionBasis -> r)
instance Rig r => Complicated (QuaternionBasis -> r)
instance Rig r => Distinguished (QuaternionBasis -> r)
instance Rig r => Hamiltonian (Quaternion r)
instance Rig r => Complicated (Quaternion r)
instance Rig r => Distinguished (Quaternion r)
instance Hamiltonian QuaternionBasis
instance Complicated QuaternionBasis
instance Distinguished QuaternionBasis

module Numeric.Algebra.Dual
class Distinguished t
e :: Distinguished t => t
class Distinguished t => Infinitesimal t
d :: Infinitesimal t => t

-- | dual number basis, D^2 = 0. D /= 0.
data DualBasis
E :: DualBasis
D :: DualBasis
data Dual a
Dual :: a -> a -> Dual a
instance Typeable DualBasis
instance Typeable Dual
instance Eq DualBasis
instance Ord DualBasis
instance Show DualBasis
instance Read DualBasis
instance Enum DualBasis
instance Ix DualBasis
instance Bounded DualBasis
instance Data DualBasis
instance Eq a => Eq (Dual a)
instance Show a => Show (Dual a)
instance Read a => Read (Dual a)
instance Data a => Data (Dual a)
instance (Commutative r, InvolutiveSemiring r, DivisionRing r) => Division (Dual r)
instance (Commutative r, Rng r, InvolutiveSemiring r) => Quadrance r (Dual r)
instance (Commutative r, Rng r, InvolutiveSemiring r) => InvolutiveSemiring (Dual r)
instance (Commutative r, Rng r, InvolutiveSemiring r) => InvolutiveMultiplication (Dual r)
instance (Commutative r, Rng r) => RightModule (Dual r) (Dual r)
instance (Commutative r, Rng r) => LeftModule (Dual r) (Dual r)
instance (Commutative r, Ring r) => Ring (Dual r)
instance (Commutative r, Ring r) => Rig (Dual r)
instance (Commutative r, Ring r) => Unital (Dual r)
instance (Commutative r, Rng r) => Semiring (Dual r)
instance (TriviallyInvolutive r, Rng r) => Commutative (Dual r)
instance (Commutative r, Rng r) => Multiplicative (Dual r)
instance (InvolutiveSemiring k, Rng k) => HopfAlgebra k DualBasis
instance (InvolutiveSemiring k, Rng k) => InvolutiveCoalgebra k DualBasis
instance (InvolutiveSemiring k, Rng k) => InvolutiveAlgebra k DualBasis
instance Rng k => Bialgebra k DualBasis
instance Rng k => CounitalCoalgebra k DualBasis
instance Rng k => Coalgebra k DualBasis
instance Rng k => UnitalAlgebra k DualBasis
instance Rng k => Algebra k DualBasis
instance Partitionable r => Partitionable (Dual r)
instance Idempotent r => Idempotent (Dual r)
instance Abelian r => Abelian (Dual r)
instance Group r => Group (Dual r)
instance Monoidal r => Monoidal (Dual r)
instance RightModule r s => RightModule r (Dual s)
instance LeftModule r s => LeftModule r (Dual s)
instance Additive r => Additive (Dual r)
instance Traversable1 Dual
instance Foldable1 Dual
instance Traversable Dual
instance Foldable Dual
instance MonadReader DualBasis Dual
instance Monad Dual
instance Bind Dual
instance Applicative Dual
instance Apply Dual
instance Functor Dual
instance Distributive Dual
instance Representable Dual
instance Rig r => Infinitesimal (DualBasis -> r)
instance Rig r => Distinguished (DualBasis -> r)
instance Rig r => Infinitesimal (Dual r)
instance Rig r => Distinguished (Dual r)
instance Infinitesimal DualBasis
instance Distinguished DualBasis

module Numeric.Algebra.Hyperbolic
class Hyperbolic r
cosh :: Hyperbolic r => r
sinh :: Hyperbolic r => r
data HyperBasis'
Cosh' :: HyperBasis'
Sinh' :: HyperBasis'
data Hyper' a
Hyper' :: a -> a -> Hyper' a
instance Typeable HyperBasis'
instance Typeable Hyper'
instance Eq HyperBasis'
instance Ord HyperBasis'
instance Show HyperBasis'
instance Read HyperBasis'
instance Enum HyperBasis'
instance Ix HyperBasis'
instance Bounded HyperBasis'
instance Data HyperBasis'
instance Eq a => Eq (Hyper' a)
instance Show a => Show (Hyper' a)
instance Read a => Read (Hyper' a)
instance Data a => Data (Hyper' a)
instance (Commutative r, InvolutiveSemiring r, DivisionRing r) => Division (Hyper' r)
instance (Commutative r, InvolutiveSemiring r, Rng r) => Quadrance r (Hyper' r)
instance (Commutative r, InvolutiveSemiring r, Rng r) => InvolutiveSemiring (Hyper' r)
instance (Commutative r, InvolutiveSemiring r, Rng r) => InvolutiveMultiplication (Hyper' r)
instance (Commutative r, Semiring r) => RightModule (Hyper' r) (Hyper' r)
instance (Commutative r, Semiring r) => LeftModule (Hyper' r) (Hyper' r)
instance (Commutative r, Ring r) => Ring (Hyper' r)
instance (Commutative r, Rig r) => Rig (Hyper' r)
instance (Commutative k, Rig k) => Unital (Hyper' k)
instance (Commutative k, Semiring k) => Semiring (Hyper' k)
instance (Commutative k, Semiring k) => Commutative (Hyper' k)
instance (Commutative k, Semiring k) => Multiplicative (Hyper' k)
instance (Commutative k, Group k, InvolutiveSemiring k) => HopfAlgebra k HyperBasis'
instance (Commutative k, Group k, InvolutiveSemiring k) => InvolutiveCoalgebra k HyperBasis'
instance (Commutative k, Group k, InvolutiveSemiring k) => InvolutiveAlgebra k HyperBasis'
instance (Commutative k, Monoidal k, Semiring k) => Bialgebra k HyperBasis'
instance (Commutative k, Monoidal k, Semiring k) => CounitalCoalgebra k HyperBasis'
instance (Commutative k, Monoidal k, Semiring k) => Coalgebra k HyperBasis'
instance (Commutative k, Monoidal k, Semiring k) => UnitalAlgebra k HyperBasis'
instance (Commutative k, Semiring k) => Algebra k HyperBasis'
instance Partitionable r => Partitionable (Hyper' r)
instance Idempotent r => Idempotent (Hyper' r)
instance Abelian r => Abelian (Hyper' r)
instance Group r => Group (Hyper' r)
instance Monoidal r => Monoidal (Hyper' r)
instance RightModule r s => RightModule r (Hyper' s)
instance LeftModule r s => LeftModule r (Hyper' s)
instance Additive r => Additive (Hyper' r)
instance Traversable1 Hyper'
instance Foldable1 Hyper'
instance Traversable Hyper'
instance Foldable Hyper'
instance MonadReader HyperBasis' Hyper'
instance Monad Hyper'
instance Bind Hyper'
instance Applicative Hyper'
instance Apply Hyper'
instance Functor Hyper'
instance Distributive Hyper'
instance Representable Hyper'
instance Rig r => Hyperbolic (HyperBasis' -> r)
instance Rig r => Hyperbolic (Hyper' r)
instance Hyperbolic HyperBasis'

module Numeric.Coalgebra.Hyperbolic
class Hyperbolic r
cosh :: Hyperbolic r => r
sinh :: Hyperbolic r => r
data HyperBasis
Cosh :: HyperBasis
Sinh :: HyperBasis
data Hyper a
Hyper :: a -> a -> Hyper a
instance Typeable HyperBasis
instance Typeable Hyper
instance Eq HyperBasis
instance Ord HyperBasis
instance Show HyperBasis
instance Read HyperBasis
instance Enum HyperBasis
instance Ix HyperBasis
instance Bounded HyperBasis
instance Data HyperBasis
instance Eq a => Eq (Hyper a)
instance Show a => Show (Hyper a)
instance Read a => Read (Hyper a)
instance Data a => Data (Hyper a)
instance (Commutative r, Group r, InvolutiveSemiring r) => InvolutiveSemiring (Hyper r)
instance (Commutative r, Group r, InvolutiveSemiring r) => InvolutiveMultiplication (Hyper r)
instance (Commutative r, Semiring r) => RightModule (Hyper r) (Hyper r)
instance (Commutative r, Semiring r) => LeftModule (Hyper r) (Hyper r)
instance (Commutative r, Ring r) => Ring (Hyper r)
instance (Commutative r, Rig r) => Rig (Hyper r)
instance (Commutative k, Rig k) => Unital (Hyper k)
instance (Commutative k, Semiring k) => Semiring (Hyper k)
instance (Commutative k, Semiring k) => Commutative (Hyper k)
instance (Commutative k, Semiring k) => Multiplicative (Hyper k)
instance (Commutative k, Group k, InvolutiveSemiring k) => HopfAlgebra k HyperBasis
instance (Commutative k, Group k, InvolutiveSemiring k) => InvolutiveCoalgebra k HyperBasis
instance (Commutative k, Group k, InvolutiveSemiring k) => InvolutiveAlgebra k HyperBasis
instance (Commutative k, Semiring k) => Bialgebra k HyperBasis
instance (Commutative k, Semiring k) => CounitalCoalgebra k HyperBasis
instance (Commutative k, Semiring k) => Coalgebra k HyperBasis
instance Semiring k => UnitalAlgebra k HyperBasis
instance Semiring k => Algebra k HyperBasis
instance Partitionable r => Partitionable (Hyper r)
instance Idempotent r => Idempotent (Hyper r)
instance Abelian r => Abelian (Hyper r)
instance Group r => Group (Hyper r)
instance Monoidal r => Monoidal (Hyper r)
instance RightModule r s => RightModule r (Hyper s)
instance LeftModule r s => LeftModule r (Hyper s)
instance Additive r => Additive (Hyper r)
instance Traversable1 Hyper
instance Foldable1 Hyper
instance Traversable Hyper
instance Foldable Hyper
instance MonadReader HyperBasis Hyper
instance Monad Hyper
instance Bind Hyper
instance Applicative Hyper
instance Apply Hyper
instance Functor Hyper
instance Distributive Hyper
instance Representable Hyper
instance Rig r => Hyperbolic (HyperBasis -> r)
instance Rig r => Hyperbolic (Hyper r)
instance Hyperbolic HyperBasis

module Numeric.Coalgebra.Dual
class Distinguished t
e :: Distinguished t => t
class Distinguished t => Infinitesimal t
d :: Infinitesimal t => t

-- | dual number basis, D^2 = 0. D /= 0.
data DualBasis'
E :: DualBasis'
D :: DualBasis'
data Dual' a
Dual' :: a -> a -> Dual' a
instance Typeable DualBasis'
instance Typeable Dual'
instance Eq DualBasis'
instance Ord DualBasis'
instance Show DualBasis'
instance Read DualBasis'
instance Enum DualBasis'
instance Ix DualBasis'
instance Bounded DualBasis'
instance Data DualBasis'
instance Eq a => Eq (Dual' a)
instance Show a => Show (Dual' a)
instance Read a => Read (Dual' a)
instance Data a => Data (Dual' a)
instance (Commutative r, InvolutiveSemiring r, DivisionRing r) => Division (Dual' r)
instance (Commutative r, Rng r, InvolutiveSemiring r) => Quadrance r (Dual' r)
instance (Commutative r, Rng r, InvolutiveSemiring r) => InvolutiveSemiring (Dual' r)
instance (Commutative r, Rng r, InvolutiveSemiring r) => InvolutiveMultiplication (Dual' r)
instance (Commutative r, Rng r) => RightModule (Dual' r) (Dual' r)
instance (Commutative r, Rng r) => LeftModule (Dual' r) (Dual' r)
instance (Commutative r, Ring r) => Ring (Dual' r)
instance (Commutative r, Ring r) => Rig (Dual' r)
instance (Commutative r, Ring r) => Unital (Dual' r)
instance (Commutative r, Rng r) => Semiring (Dual' r)
instance (TriviallyInvolutive r, Rng r) => Commutative (Dual' r)
instance (Commutative r, Rng r) => Multiplicative (Dual' r)
instance (InvolutiveSemiring k, Rng k) => HopfAlgebra k DualBasis'
instance (InvolutiveSemiring k, Rng k) => InvolutiveCoalgebra k DualBasis'
instance (InvolutiveSemiring k, Rng k) => InvolutiveAlgebra k DualBasis'
instance Rng k => Bialgebra k DualBasis'
instance Rng k => CounitalCoalgebra k DualBasis'
instance Rng k => Coalgebra k DualBasis'
instance Semiring k => UnitalAlgebra k DualBasis'
instance Semiring k => Algebra k DualBasis'
instance Partitionable r => Partitionable (Dual' r)
instance Idempotent r => Idempotent (Dual' r)
instance Abelian r => Abelian (Dual' r)
instance Group r => Group (Dual' r)
instance Monoidal r => Monoidal (Dual' r)
instance RightModule r s => RightModule r (Dual' s)
instance LeftModule r s => LeftModule r (Dual' s)
instance Additive r => Additive (Dual' r)
instance Traversable1 Dual'
instance Foldable1 Dual'
instance Traversable Dual'
instance Foldable Dual'
instance MonadReader DualBasis' Dual'
instance Monad Dual'
instance Bind Dual'
instance Applicative Dual'
instance Apply Dual'
instance Functor Dual'
instance Distributive Dual'
instance Representable Dual'
instance Rig r => Infinitesimal (DualBasis' -> r)
instance Rig r => Distinguished (DualBasis' -> r)
instance Rig r => Infinitesimal (Dual' r)
instance Rig r => Distinguished (Dual' r)
instance Infinitesimal DualBasis'
instance Distinguished DualBasis'

module Numeric.Coalgebra.Geometric
newtype BasisCoblade m
BasisCoblade :: Word64 -> BasisCoblade m
runBasisCoblade :: BasisCoblade m -> Word64
type Comultivector r m = Covector r (BasisCoblade m)
class Eigenbasis m
euclidean :: Eigenbasis m => proxy m -> Bool
antiEuclidean :: Eigenbasis m => proxy m -> Bool
v :: Eigenbasis m => m -> BasisCoblade m
e :: Eigenbasis m => Int -> m
class (Ring r, Eigenbasis m) => Eigenmetric r m
metric :: Eigenmetric r m => m -> r
newtype Euclidean
Euclidean :: Int -> Euclidean
grade :: BasisCoblade m -> Int
filterGrade :: Monoidal r => BasisCoblade m -> Int -> Comultivector r m
reverse :: Group r => BasisCoblade m -> Comultivector r m
gradeInversion :: Group r => BasisCoblade m -> Comultivector r m
cliffordConjugate :: Group r => BasisCoblade m -> Comultivector r m
geometric :: Eigenmetric r m => BasisCoblade m -> BasisCoblade m -> Comultivector r m
outer :: Eigenmetric r m => BasisCoblade m -> BasisCoblade m -> Comultivector r m
contractL :: Eigenmetric r m => BasisCoblade m -> BasisCoblade m -> Comultivector r m
contractR :: Eigenmetric r m => BasisCoblade m -> BasisCoblade m -> Comultivector r m
hestenes :: Eigenmetric r m => BasisCoblade m -> BasisCoblade m -> Comultivector r m
dot :: Eigenmetric r m => BasisCoblade m -> BasisCoblade m -> Comultivector r m
liftProduct :: (BasisCoblade m -> BasisCoblade m -> Comultivector r m) -> Comultivector r m -> Comultivector r m -> Comultivector r m
instance Typeable Euclidean
instance Eq (BasisCoblade m)
instance Ord (BasisCoblade m)
instance Num (BasisCoblade m)
instance Bits (BasisCoblade m)
instance Enum (BasisCoblade m)
instance Ix (BasisCoblade m)
instance Bounded (BasisCoblade m)
instance Show (BasisCoblade m)
instance Read (BasisCoblade m)
instance Real (BasisCoblade m)
instance Integral (BasisCoblade m)
instance Additive (BasisCoblade m)
instance Abelian (BasisCoblade m)
instance LeftModule Natural (BasisCoblade m)
instance RightModule Natural (BasisCoblade m)
instance Monoidal (BasisCoblade m)
instance Multiplicative (BasisCoblade m)
instance Unital (BasisCoblade m)
instance Commutative (BasisCoblade m)
instance Semiring (BasisCoblade m)
instance Rig (BasisCoblade m)
instance DecidableZero (BasisCoblade m)
instance DecidableAssociates (BasisCoblade m)
instance DecidableUnits (BasisCoblade m)
instance Eq Euclidean
instance Ord Euclidean
instance Show Euclidean
instance Read Euclidean
instance Num Euclidean
instance Ix Euclidean
instance Enum Euclidean
instance Real Euclidean
instance Integral Euclidean
instance Data Euclidean
instance Additive Euclidean
instance LeftModule Natural Euclidean
instance RightModule Natural Euclidean
instance Monoidal Euclidean
instance Abelian Euclidean
instance LeftModule Integer Euclidean
instance RightModule Integer Euclidean
instance Group Euclidean
instance Multiplicative Euclidean
instance TriviallyInvolutive Euclidean
instance InvolutiveMultiplication Euclidean
instance InvolutiveSemiring Euclidean
instance Unital Euclidean
instance Commutative Euclidean
instance Semiring Euclidean
instance Rig Euclidean
instance Ring Euclidean
instance Eigenmetric r m => CounitalCoalgebra r (BasisCoblade m)
instance Eigenmetric r m => Coalgebra r (BasisCoblade m)
instance Ring r => Eigenmetric r Euclidean
instance Eigenbasis Euclidean

module Numeric.Coalgebra.Quaternion
class Distinguished t
e :: Distinguished t => t
class Distinguished r => Complicated r
i :: Complicated r => r
class Complicated t => Hamiltonian t
j :: Hamiltonian t => t
k :: Hamiltonian t => t
data QuaternionBasis'
E' :: QuaternionBasis'
I' :: QuaternionBasis'
J' :: QuaternionBasis'
K' :: QuaternionBasis'
data Quaternion' a
Quaternion' :: a -> a -> a -> a -> Quaternion' a

-- | Cayley-Dickson quaternion isomorphism (one way)
complicate' :: Complicated c => QuaternionBasis' -> (c, c)
vectorPart' :: (Representable f, Rep f ~ QuaternionBasis') => f r -> (r, r, r)
scalarPart' :: (Representable f, Rep f ~ QuaternionBasis') => f r -> r
instance Typeable QuaternionBasis'
instance Typeable Quaternion'
instance Eq QuaternionBasis'
instance Ord QuaternionBasis'
instance Enum QuaternionBasis'
instance Read QuaternionBasis'
instance Show QuaternionBasis'
instance Bounded QuaternionBasis'
instance Ix QuaternionBasis'
instance Data QuaternionBasis'
instance Eq a => Eq (Quaternion' a)
instance Show a => Show (Quaternion' a)
instance Read a => Read (Quaternion' a)
instance Data a => Data (Quaternion' a)
instance (TriviallyInvolutive r, Ring r, Division r) => Division (Quaternion' r)
instance (TriviallyInvolutive r, Rng r) => Quadrance r (Quaternion' r)
instance (TriviallyInvolutive r, Rng r) => InvolutiveMultiplication (Quaternion' r)
instance (TriviallyInvolutive r, Rng r) => RightModule (Quaternion' r) (Quaternion' r)
instance (TriviallyInvolutive r, Rng r) => LeftModule (Quaternion' r) (Quaternion' r)
instance (TriviallyInvolutive r, Ring r) => Ring (Quaternion' r)
instance (TriviallyInvolutive r, Ring r) => Rig (Quaternion' r)
instance (TriviallyInvolutive r, Ring r) => Unital (Quaternion' r)
instance (TriviallyInvolutive r, Semiring r) => Semiring (Quaternion' r)
instance (TriviallyInvolutive r, Semiring r) => Multiplicative (Quaternion' r)
instance (TriviallyInvolutive r, InvolutiveSemiring r, Rng r) => HopfAlgebra r QuaternionBasis'
instance (TriviallyInvolutive r, InvolutiveSemiring r, Rng r) => InvolutiveCoalgebra r QuaternionBasis'
instance (TriviallyInvolutive r, InvolutiveSemiring r, Rng r) => InvolutiveAlgebra r QuaternionBasis'
instance (TriviallyInvolutive r, Rng r) => Bialgebra r QuaternionBasis'
instance (TriviallyInvolutive r, Rng r) => CounitalCoalgebra r QuaternionBasis'
instance (TriviallyInvolutive r, Rng r) => Coalgebra r QuaternionBasis'
instance (TriviallyInvolutive r, Semiring r) => UnitalAlgebra r QuaternionBasis'
instance (TriviallyInvolutive r, Semiring r) => Algebra r QuaternionBasis'
instance Partitionable r => Partitionable (Quaternion' r)
instance Idempotent r => Idempotent (Quaternion' r)
instance Abelian r => Abelian (Quaternion' r)
instance Group r => Group (Quaternion' r)
instance Monoidal r => Monoidal (Quaternion' r)
instance RightModule r s => RightModule r (Quaternion' s)
instance LeftModule r s => LeftModule r (Quaternion' s)
instance Additive r => Additive (Quaternion' r)
instance Traversable1 Quaternion'
instance Foldable1 Quaternion'
instance Traversable Quaternion'
instance Foldable Quaternion'
instance MonadReader QuaternionBasis' Quaternion'
instance Monad Quaternion'
instance Bind Quaternion'
instance Applicative Quaternion'
instance Apply Quaternion'
instance Functor Quaternion'
instance Distributive Quaternion'
instance Representable Quaternion'
instance Rig r => Hamiltonian (QuaternionBasis' -> r)
instance Rig r => Complicated (QuaternionBasis' -> r)
instance Rig r => Distinguished (QuaternionBasis' -> r)
instance Rig r => Hamiltonian (Quaternion' r)
instance Rig r => Complicated (Quaternion' r)
instance Rig r => Distinguished (Quaternion' r)
instance Hamiltonian QuaternionBasis'
instance Complicated QuaternionBasis'
instance Distinguished QuaternionBasis'

module Numeric.Coalgebra.Trigonometric
class Trigonometric r
cos :: Trigonometric r => r
sin :: Trigonometric r => r
data TrigBasis
Cos :: TrigBasis
Sin :: TrigBasis
data Trig a
Trig :: a -> a -> Trig a
instance Typeable TrigBasis
instance Typeable Trig
instance Eq TrigBasis
instance Ord TrigBasis
instance Show TrigBasis
instance Read TrigBasis
instance Enum TrigBasis
instance Ix TrigBasis
instance Bounded TrigBasis
instance Data TrigBasis
instance Eq a => Eq (Trig a)
instance Show a => Show (Trig a)
instance Read a => Read (Trig a)
instance Data a => Data (Trig a)
instance (Commutative r, Rng r, InvolutiveSemiring r) => InvolutiveSemiring (Trig r)
instance (Commutative r, Rng r, InvolutiveMultiplication r) => InvolutiveMultiplication (Trig r)
instance (Commutative r, Rng r) => RightModule (Trig r) (Trig r)
instance (Commutative r, Rng r) => LeftModule (Trig r) (Trig r)
instance (Commutative r, Ring r) => Ring (Trig r)
instance (Commutative r, Ring r) => Rig (Trig r)
instance (Commutative k, Ring k) => Unital (Trig k)
instance (Commutative k, Rng k) => Semiring (Trig k)
instance (Commutative k, Rng k) => Commutative (Trig k)
instance (Commutative k, Rng k) => Multiplicative (Trig k)
instance (Commutative k, Rng k) => CounitalCoalgebra k TrigBasis
instance (Commutative k, Group k, InvolutiveSemiring k) => HopfAlgebra k TrigBasis
instance (Commutative k, Group k, InvolutiveSemiring k) => InvolutiveCoalgebra k TrigBasis
instance (Commutative k, Group k, InvolutiveSemiring k) => InvolutiveAlgebra k TrigBasis
instance (Commutative k, Rng k) => Bialgebra k TrigBasis
instance (Commutative k, Rng k) => Coalgebra k TrigBasis
instance (Commutative k, Rng k) => UnitalAlgebra k TrigBasis
instance (Commutative k, Rng k) => Algebra k TrigBasis
instance Partitionable r => Partitionable (Trig r)
instance Idempotent r => Idempotent (Trig r)
instance Abelian r => Abelian (Trig r)
instance Group r => Group (Trig r)
instance Monoidal r => Monoidal (Trig r)
instance RightModule r s => RightModule r (Trig s)
instance LeftModule r s => LeftModule r (Trig s)
instance Additive r => Additive (Trig r)
instance Traversable1 Trig
instance Foldable1 Trig
instance Traversable Trig
instance Foldable Trig
instance MonadReader TrigBasis Trig
instance Monad Trig
instance Bind Trig
instance Applicative Trig
instance Apply Trig
instance Functor Trig
instance Distributive Trig
instance Representable Trig
instance Rig r => Trigonometric (TrigBasis -> r)
instance Rig r => Complicated (TrigBasis -> r)
instance Rig r => Distinguished (TrigBasis -> r)
instance Rig r => Trigonometric (Trig r)
instance Rig r => Complicated (Trig r)
instance Rig r => Distinguished (Trig r)
instance Trigonometric TrigBasis
instance Complicated TrigBasis
instance Distinguished TrigBasis

module Numeric.Exp
newtype Exp r
Exp :: r -> Exp r
runExp :: Exp r -> r
instance Partitionable r => Factorable (Exp r)
instance Idempotent r => Band (Exp r)
instance Abelian r => Commutative (Exp r)
instance Group r => Division (Exp r)
instance Monoidal r => Unital (Exp r)
instance Additive r => Multiplicative (Exp r)

module Numeric.Log
newtype Log r
Log :: r -> Log r
runLog :: Log r -> r
instance Factorable r => Partitionable (Log r)
instance Band r => Idempotent (Log r)
instance Commutative r => Abelian (Log r)
instance Division r => Group (Log r)
instance Division r => RightModule Integer (Log r)
instance Division r => LeftModule Integer (Log r)
instance Unital r => Monoidal (Log r)
instance Unital r => RightModule Natural (Log r)
instance Unital r => LeftModule Natural (Log r)
instance Multiplicative r => Additive (Log r)

module Numeric.Map

-- | linear maps from elements of a free module to another free module over
--   r
--   
--   <pre>
--   f $# x + y = (f $# x) + (f $# y)
--   f $# (r .* x) = r .* (f $# x)
--   </pre>
--   
--   <tt>Map r b a</tt> represents a linear mapping from a free module with
--   basis <tt>a</tt> over <tt>r</tt> to a free module with basis
--   <tt>b</tt> over <tt>r</tt>.
--   
--   Note well the reversed direction of the arrow, due to the
--   contravariance of change of basis!
--   
--   This way enables we can employ arbitrary pure functions as linear maps
--   by lifting them using <a>arr</a>, or build them by using the monad
--   instance for Map r b. As a consequence Map is an instance of, well,
--   almost everything.
newtype Map r b a
Map :: ((a -> r) -> b -> r) -> Map r b a

-- | extract a linear functional from a linear map
($@) :: Map r b a -> b -> Covector r a
multMap :: Coalgebra r c => Map r (c, c) c
unitMap :: CounitalCoalgebra r c => Map r () c

-- | (inefficiently) combine a linear combination of basis vectors to make
--   a map. arrMap :: (Monoidal r, Semiring r) =&gt; (b -&gt; [(r, a)])
--   -&gt; Map r b a arrMap f = Map $ k b -&gt; sum [ r * k a | (r, a)
--   &lt;- f b ]
comultMap :: Algebra r a => Map r a (a, a)
counitMap :: UnitalAlgebra r a => Map r a ()
invMap :: InvolutiveCoalgebra r c => Map r c c
coinvMap :: InvolutiveAlgebra r a => Map r a a
antipodeMap :: HopfAlgebra r h => Map r h h

-- | convolution given an associative algebra and coassociative coalgebra
convolveMap :: (Algebra r a, Coalgebra r c) => Map r a c -> Map r a c -> Map r a c
instance (Ring r, CounitalCoalgebra r m) => Ring (Map r a m)
instance (Rig r, CounitalCoalgebra r m) => Rig (Map r b m)
instance (Commutative m, Coalgebra r m) => Commutative (Map r b m)
instance Group s => Group (Map s b a)
instance Abelian s => Abelian (Map s b a)
instance Monoidal s => Monoidal (Map s b a)
instance Monoidal r => MonadPlus (Map r b)
instance Monoidal r => Alternative (Map r b)
instance Monoidal r => Plus (Map r b)
instance Additive r => Alt (Map r b)
instance RightModule r s => RightModule r (Map s b m)
instance Coalgebra r m => RightModule (Map r b m) (Map r b m)
instance LeftModule r s => LeftModule r (Map s b m)
instance Coalgebra r m => LeftModule (Map r b m) (Map r b m)
instance Coalgebra r m => Semiring (Map r b m)
instance CounitalCoalgebra r m => Unital (Map r b m)
instance Coalgebra r m => Multiplicative (Map r b m)
instance Additive r => Additive (Map r b a)
instance ArrowChoice (Map r)
instance Monoidal r => ArrowPlus (Map r)
instance Monoidal r => ArrowZero (Map r)
instance MonadReader b (Map r b)
instance ArrowApply (Map r)
instance Arrow (Map r)
instance Monad (Map r b)
instance Bind (Map r b)
instance Applicative (Map r b)
instance Apply (Map r b)
instance Functor (Map r b)
instance Semigroupoid (Map r)
instance Category (Map r)

module Numeric.Ring.Endomorphism

-- | The endomorphism ring of an abelian group or the endomorphism semiring
--   of an abelian monoid
--   
--   <a>http://en.wikipedia.org/wiki/Endomorphism_ring</a>
newtype End a
End :: (a -> a) -> End a
appEnd :: End a -> a -> a
toEnd :: Multiplicative r => r -> End r
fromEnd :: Unital r => End r -> r
frobenius :: Characteristic r => End r
instance RightModule r m => RightModule r (End m)
instance LeftModule r m => LeftModule r (End m)
instance (Monoidal m, Abelian m) => RightModule (End m) (End m)
instance (Monoidal m, Abelian m) => LeftModule (End m) (End m)
instance (Abelian r, Group r) => Ring (End r)
instance (Abelian r, Monoidal r) => Rig (End r)
instance (Abelian r, Monoidal r) => Semiring (End r)
instance (Abelian r, Commutative r) => Commutative (End r)
instance Unital (End r)
instance Multiplicative (End r)
instance Group r => Group (End r)
instance Monoidal r => Monoidal (End r)
instance Abelian r => Abelian (End r)
instance Additive r => Additive (End r)
instance Monoid (End r)

module Numeric.Ring.Opposite

-- | <a>http://en.wikipedia.org/wiki/Opposite_ring</a>
newtype Opposite r
Opposite :: r -> Opposite r
runOpposite :: Opposite r -> r
instance Show r => Show (Opposite r)
instance Read r => Read (Opposite r)
instance Ring r => Ring (Opposite r)
instance Rig r => Rig (Opposite r)
instance Semiring r => Semiring (Opposite r)
instance Division r => Division (Opposite r)
instance Unital r => Unital (Opposite r)
instance Band r => Band (Opposite r)
instance Idempotent r => Idempotent (Opposite r)
instance Commutative r => Commutative (Opposite r)
instance Multiplicative r => Multiplicative (Opposite r)
instance DecidableAssociates r => DecidableAssociates (Opposite r)
instance DecidableUnits r => DecidableUnits (Opposite r)
instance DecidableZero r => DecidableZero (Opposite r)
instance Abelian r => Abelian (Opposite r)
instance Group r => Group (Opposite r)
instance Semiring r => RightModule (Opposite r) (Opposite r)
instance LeftModule r s => RightModule r (Opposite s)
instance RightModule r s => LeftModule r (Opposite s)
instance Semiring r => LeftModule (Opposite r) (Opposite r)
instance Monoidal r => Monoidal (Opposite r)
instance Additive r => Additive (Opposite r)
instance Traversable1 Opposite
instance Foldable1 Opposite
instance Traversable Opposite
instance Foldable Opposite
instance Functor Opposite
instance Ord r => Ord (Opposite r)
instance Eq r => Eq (Opposite r)

module Numeric.Ring.Rng

-- | The free Ring given a Rng obtained by adjoining Z, such that
--   
--   <pre>
--   RngRing r = n*1 + r
--   </pre>
--   
--   This ring is commonly denoted r^.
data RngRing r
RngRing :: !Integer -> r -> RngRing r

-- | The rng homomorphism from r to RngRing r
rngRingHom :: r -> RngRing r

-- | given a rng homomorphism from a rng r into a ring s, liftRngHom yields
--   a ring homomorphism from the ring `r^` into <tt>s</tt>.
liftRngHom :: Ring s => (r -> s) -> RngRing r -> s
instance Show r => Show (RngRing r)
instance Read r => Read (RngRing r)
instance Rng r => Ring (RngRing r)
instance Rng r => Rig (RngRing r)
instance Rng r => Semiring (RngRing r)
instance (Rng r, Division r) => Division (RngRing r)
instance Rng r => Unital (RngRing r)
instance Rng s => RightModule (RngRing s) (RngRing s)
instance Rng s => LeftModule (RngRing s) (RngRing s)
instance (Commutative r, Rng r) => Commutative (RngRing r)
instance Rng r => Multiplicative (RngRing r)
instance (Abelian r, Group r) => Group (RngRing r)
instance (Abelian r, Group r) => RightModule Integer (RngRing r)
instance (Abelian r, Group r) => LeftModule Integer (RngRing r)
instance (Abelian r, Monoidal r) => Monoidal (RngRing r)
instance (Abelian r, Monoidal r) => RightModule Natural (RngRing r)
instance (Abelian r, Monoidal r) => LeftModule Natural (RngRing r)
instance Abelian r => Abelian (RngRing r)
instance Abelian r => Additive (RngRing r)

module Numeric.Rng.Zero
newtype ZeroRng r
ZeroRng :: r -> ZeroRng r
runZeroRng :: ZeroRng r -> r
instance Eq r => Eq (ZeroRng r)
instance Ord r => Ord (ZeroRng r)
instance Show r => Show (ZeroRng r)
instance Read r => Read (ZeroRng r)
instance Group r => RightModule Integer (ZeroRng r)
instance Group r => LeftModule Integer (ZeroRng r)
instance Monoidal r => RightModule Natural (ZeroRng r)
instance Monoidal r => LeftModule Natural (ZeroRng r)
instance (Group r, Abelian r) => Rng (ZeroRng r)
instance Monoidal r => Commutative (ZeroRng r)
instance (Monoidal r, Abelian r) => Semiring (ZeroRng r)
instance Monoidal r => Multiplicative (ZeroRng r)
instance Group r => Group (ZeroRng r)
instance Monoidal r => Monoidal (ZeroRng r)
instance Abelian r => Abelian (ZeroRng r)
instance Idempotent r => Idempotent (ZeroRng r)
instance Additive r => Additive (ZeroRng r)

module Numeric.Field.Fraction

-- | Fraction field <tt>k(D)</tt> of <a>Euclidean</a> domain <tt>D</tt>.
data Fraction d
numerator :: Fraction t -> t
denominator :: Fraction t -> t

-- | Convenient synonym for <a>Fraction</a>.
type Ratio = Fraction
(%) :: Euclidean d => d -> d -> Fraction d
lcm :: Euclidean r => r -> r -> r
instance (Characteristic d, Euclidean d) => Characteristic (Fraction d)
instance Euclidean d => Rig (Fraction d)
instance Euclidean d => Multiplicative (Fraction d)
instance Euclidean d => Unital (Fraction d)
instance Euclidean d => Additive (Fraction d)
instance Euclidean d => RightModule Natural (Fraction d)
instance Euclidean d => LeftModule Natural (Fraction d)
instance Euclidean d => RightModule Integer (Fraction d)
instance Euclidean d => LeftModule Integer (Fraction d)
instance Euclidean d => Monoidal (Fraction d)
instance Euclidean d => Group (Fraction d)
instance Euclidean d => Semiring (Fraction d)
instance Euclidean d => Abelian (Fraction d)
instance Euclidean d => Ring (Fraction d)
instance Euclidean d => DecidableUnits (Fraction d)
instance Euclidean d => DecidableZero (Fraction d)
instance (Commutative d, Euclidean d) => Commutative (Fraction d)
instance Euclidean d => Division (Fraction d)
instance (Ord d, Multiplicative d) => Ord (Fraction d)
instance (Eq d, Multiplicative d) => Eq (Fraction d)
instance Euclidean d => IntegralSemiring (Fraction d)
instance (Eq d, Show d, Unital d) => Show (Fraction d)
