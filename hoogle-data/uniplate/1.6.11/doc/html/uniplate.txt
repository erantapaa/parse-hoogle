-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Help writing simple, concise and fast generic operations.
--   
--   Uniplate is library for writing simple and concise generic operations.
--   Uniplate has similar goals to the original Scrap Your Boilerplate
--   work, but is substantially simpler and faster. The Uniplate manual is
--   available at
--   <a>http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm</a>.
--   
--   To get started with Uniplate you should import one of the three
--   following modules:
--   
--   <ul>
--   <li><a>Data.Generics.Uniplate.Data</a> - to quickly start writing
--   generic functions. Most users should start by importing this
--   module.</li>
--   <li><a>Data.Generics.Uniplate.Direct</a> - a replacement for
--   <a>Data.Generics.Uniplate.Data</a> with substantially higher
--   performance (around 5 times), but requires writing instance
--   declarations.</li>
--   <li><a>Data.Generics.Uniplate.Operations</a> - definitions of all the
--   operations defined by Uniplate. Both the above two modules re-export
--   this module.</li>
--   </ul>
--   
--   In addition, some users may want to make use of the following modules:
--   
--   <ul>
--   <li><a>Data.Generics.Uniplate.Zipper</a> - a zipper built on top of
--   Uniplate instances.</li>
--   <li><a>Data.Generics.SYB</a> - users transitioning from the Scrap Your
--   Boilerplate library.</li>
--   <li><a>Data.Generics.Compos</a> - users transitioning from the Compos
--   library.</li>
--   <li><a>Data.Generics.Uniplate.DataOnly</a> - users making use of both
--   <tt>Data</tt> and <tt>Direct</tt> to avoid getting instance
--   conflicts.</li>
--   </ul>
@package uniplate
@version 1.6.11


-- | In some cases, <a>Data</a> instances for abstract types are incorrect,
--   and fail to work correctly with Uniplate. This module defines three
--   helper types (<a>Hide</a>, <a>Trigger</a> and <a>Invariant</a>) to
--   assist when writing instances for abstract types. The <a>Hide</a> type
--   is useful when you want to mark some part of your data type as being
--   ignored by <a>Data.Generics.Uniplate.Data</a> (and any other
--   <a>Data</a> based generics libraries, such as <tt>syb</tt>).
--   
--   Using the helper types, this module defines wrappers for types in the
--   <tt>containers</tt> package, namely <a>Map</a>, <a>Set</a>,
--   <a>IntMap</a> and <a>IntSet</a>. The standard <tt>containers</tt>
--   <a>Data</a> instances all treat the types as abstract, but the wrapper
--   types allow you to traverse within the data types, ensuring the
--   necessary invariants are maintained. In particular, if you do not
--   modify the keys reconstruct will be <i>O(n)</i> instead of <i>O(n log
--   n)</i>.
--   
--   As an example of how to implement your own abstract type wrappers, the
--   <a>Map</a> data type is defined as:
--   
--   <pre>
--   newtype Map k v = Map (<a>Invariant</a> (<a>Trigger</a> [k], <a>Trigger</a> [v], Hide (Map.Map k v)))
--      deriving (Data, Typeable)
--   </pre>
--   
--   The <a>Map</a> type is defined as an <a>Invariant</a> of three
--   components - the keys, the values, and the underlying <tt>Map</tt>. We
--   use <a>Invariant</a> to ensure that the keys<i>values</i>map always
--   remain in sync. We use <a>Trigger</a> on the keys and values to ensure
--   that whenever the keys or values change we rebuild the <tt>Map</tt>,
--   but if they don't, we reuse the previous <tt>Map</tt>. The
--   <a>fromMap</a> function is implemented by pattern matching on the
--   <a>Map</a> type:
--   
--   <pre>
--   <a>fromMap</a> (<a>Map</a> (<a>Invariant</a> _ (_,_,<a>Hide</a> x))) = x
--   </pre>
--   
--   The <a>toMap</a> function is slightly harder, as we need to come up
--   with an invariant restoring function:
--   
--   <pre>
--   toMap :: Ord k =&gt; Map.Map k v -&gt; Map k v
--   toMap x = Map $ Invariant inv $ create x
--       where
--           create x = (Trigger False ks, Trigger False vs, Hide x)
--               where (ks,vs) = unzip $ Map.toAscList x
--   
--           inv (ks,vs,x)
--               | trigger ks = create $ Map.fromList $ zip (fromTrigger ks) (fromTrigger vs)
--               | trigger vs = create $ Map.fromDistinctAscList $ zip (fromTrigger ks) (fromTrigger vs)
--               | otherwise = (ks,vs,x)
--   </pre>
--   
--   The <tt>create</tt> function creates a value from a <tt>Map</tt>,
--   getting the correct keys and values. The <tt>inv</tt> function looks
--   at the triggers on the keys/values. If the keys trigger has been
--   tripped, then we reconstruct the <tt>Map</tt> using <tt>fromList</tt>.
--   If the values trigger has been tripped, but they keys trigger has not,
--   we can use <tt>fromDistinctAscList</tt>, reducing the complexity of
--   constructing the <tt>Map</tt>. If nothing has changed we can reuse the
--   previous value.
--   
--   The end result is that all Uniplate (or <tt>syb</tt>) traversals over
--   <a>Map</a> result in a valid value, which has had all appropriate
--   transformations applied.
module Data.Generics.Uniplate.Data.Instances

-- | The <a>Hide</a> data type has a <a>Data</a> instance which reports
--   having no constructors, as though the type was defined as using the
--   extension <tt>EmptyDataDecls</tt>:
--   
--   <pre>
--   data Hide a
--   </pre>
--   
--   This type is suitable for defining regions that are avoided by
--   Uniplate traversals. As an example:
--   
--   <pre>
--   transformBi (+1) (1, 2, Hide 3, Just 4) == (2, 3, Hide 3, Just 4)
--   </pre>
--   
--   As a result of having no constructors, any calls to the methods
--   <a>toConstr</a> or <a>gunfold</a> will raise an error.
newtype Hide a
Hide :: a -> Hide a
fromHide :: Hide a -> a

-- | The <a>Trigger</a> data type has a <a>Data</a> instance which reports
--   as being defined:
--   
--   <pre>
--   data Trigger a = Trigger a
--   </pre>
--   
--   However, whenever a <a>gfoldl</a> or <a>gunfold</a> constructs a new
--   value, it will have the <a>trigger</a> field set to <a>True</a>. The
--   trigger information is useful to indicate whether any invariants have
--   been broken, and thus need fixing. As an example:
--   
--   <pre>
--   data SortedList a = SortedList (Trigger [a]) deriving (Data,Typeable)
--   toSortedList xs = SortedList $ Trigger False $ sort xs
--   fromSortedList (SortedList (Trigger t xs)) = if t then sort xs else xs
--   </pre>
--   
--   This data type represents a sorted list. When constructed the items
--   are initially sorted, but operations such as <a>gmapT</a> could break
--   that invariant. The <a>Trigger</a> type is used to detect when the
--   Data operations have been performed, and resort the list.
--   
--   The <a>Trigger</a> type is often used in conjunction with
--   <a>Invariant</a>, which fixes the invariants.
data Trigger a
Trigger :: Bool -> a -> Trigger a
trigger :: Trigger a -> Bool
fromTrigger :: Trigger a -> a

-- | The <a>Invariant</a> data type as a <a>Data</a> instance which reports
--   as being defined:
--   
--   <pre>
--   data Invariant a = Invariant a
--   </pre>
--   
--   However, whenever a <a>gfoldl</a> constructs a new value, it will have
--   the function in the <a>invariant</a> field applied to it. As an
--   example:
--   
--   <pre>
--   data SortedList a = SortedList (Invariant [a]) deriving (Data,Typeable)
--   toSortedList xs = SortedList $ Invariant sort (sort xs)
--   fromSortedList (SortedList (Invariant _ xs)) = xs
--   </pre>
--   
--   Any time an operation such as <a>gmapT</a> is applied to the data
--   type, the <a>invariant</a> function is applied to the result. The
--   <tt>fromSortedList</tt> function can then rely on this invariant.
--   
--   The <a>gunfold</a> method is partially implemented - all constructed
--   values will have an undefined value for all fields, regardless of
--   which function is passed to <a>fromConstrB</a>. If you only use
--   <a>fromConstr</a> (as Uniplate does) then the <a>gunfold</a> method is
--   sufficient.
data Invariant a
Invariant :: (a -> a) -> a -> Invariant a
invariant :: Invariant a -> a -> a
fromInvariant :: Invariant a -> a

-- | Invariant preserving version of <tt>Map</tt> from the
--   <tt>containers</tt> packages, suitable for use with <tt>Uniplate</tt>.
--   Use <a>toMap</a> to construct values, and <a>fromMap</a> to
--   deconstruct values.
data Map k v

-- | Deconstruct a value of type <a>Map</a>.
fromMap :: Map k v -> Map k v

-- | Construct a value of type <a>Map</a>.
toMap :: Ord k => Map k v -> Map k v

-- | Invariant preserving version of <tt>Set</tt> from the
--   <tt>containers</tt> packages, suitable for use with <tt>Uniplate</tt>.
--   Use <a>toSet</a> to construct values, and <a>fromSet</a> to
--   deconstruct values.
data Set k

-- | Deconstruct a value of type <a>Set</a>.
fromSet :: Set k -> Set k

-- | Construct a value of type <a>Set</a>.
toSet :: Ord k => Set k -> Set k

-- | Invariant preserving version of <tt>IntMap</tt> from the
--   <tt>containers</tt> packages, suitable for use with <tt>Uniplate</tt>.
--   Use <a>toIntMap</a> to construct values, and <a>fromIntMap</a> to
--   deconstruct values.
data IntMap v

-- | Deconstruct a value of type <a>IntMap</a>.
fromIntMap :: IntMap v -> IntMap v

-- | Construct a value of type <a>IntMap</a>.
toIntMap :: IntMap v -> IntMap v

-- | Invariant preserving version of <tt>IntSet</tt> from the
--   <tt>containers</tt> packages, suitable for use with <tt>Uniplate</tt>.
--   Use <a>toIntSet</a> to construct values, and <a>fromIntSet</a> to
--   deconstruct values.
data IntSet

-- | Deconstruct a value of type <a>IntSet</a>.
fromIntSet :: IntSet -> IntSet

-- | Construct a value of type <a>IntSet</a>.
toIntSet :: IntSet -> IntSet
instance Typeable1 Hide
instance Typeable1 Trigger
instance Typeable1 Invariant
instance Typeable2 Map
instance Typeable1 Set
instance Typeable1 IntMap
instance Typeable IntSet
instance Read a => Read (Hide a)
instance Ord a => Ord (Hide a)
instance Eq a => Eq (Hide a)
instance Read a => Read (Trigger a)
instance Ord a => Ord (Trigger a)
instance Eq a => Eq (Trigger a)
instance Show a => Show (Trigger a)
instance (Data k, Data v) => Data (Map k v)
instance Data k => Data (Set k)
instance Data v => Data (IntMap v)
instance Data IntSet
instance Ord IntSet
instance Eq IntSet
instance Show IntSet
instance Ord v => Ord (IntMap v)
instance Eq v => Eq (IntMap v)
instance Show v => Show (IntMap v)
instance Ord k => Ord (Set k)
instance Eq k => Eq (Set k)
instance Show k => Show (Set k)
instance (Ord k, Ord v) => Ord (Map k v)
instance (Eq k, Eq v) => Eq (Map k v)
instance (Show k, Show v) => Show (Map k v)
instance (Data a, Typeable a) => Data (Invariant a)
instance Show a => Show (Invariant a)
instance (Data a, Typeable a) => Data (Trigger a)
instance Functor Trigger
instance Typeable a => Data (Hide a)
instance Functor Hide
instance Show a => Show (Hide a)


-- | <i>DEPRECATED</i> Use <a>Data.Generics.Uniplate.Operations</a>
--   instead.
--   
--   This is the main Uniplate module, which defines all the essential
--   operations in a Haskell 98 compatible manner.
--   
--   Most functions have an example of a possible use for the function. To
--   illustate, I have used the <tt>Expr</tt> type as below:
--   
--   <pre>
--   data Expr = Val Int
--             | Neg Expr
--             | Add Expr Expr
--   </pre>
module Data.Generics.Uniplate

-- | The type of replacing all the children of a node
--   
--   Taking a value, the function should return all the immediate children
--   of the same type, and a function to replace them.
type UniplateType on = on -> ([on], [on] -> on)

-- | The standard Uniplate class, all operations require this
class Uniplate on
uniplate :: Uniplate on => UniplateType on

-- | Get all the children of a node, including itself and all children.
--   
--   <pre>
--   universe (Add (Val 1) (Neg (Val 2))) =
--       [Add (Val 1) (Neg (Val 2)), Val 1, Neg (Val 2), Val 2]
--   </pre>
--   
--   This method is often combined with a list comprehension, for example:
--   
--   <pre>
--   vals x = [i | Val i &lt;- universe x]
--   </pre>
universe :: Uniplate on => on -> [on]

-- | Get the direct children of a node. Usually using <a>universe</a> is
--   more appropriate.
--   
--   <pre>
--   children = fst . <a>uniplate</a>
--   </pre>
children :: Uniplate on => on -> [on]

-- | Transform every element in the tree, in a bottom-up manner.
--   
--   For example, replacing negative literals with literals:
--   
--   <pre>
--   negLits = transform f
--      where f (Neg (Lit i)) = Lit (negate i)
--            f x = x
--   </pre>
transform :: Uniplate on => (on -> on) -> on -> on

-- | Monadic variant of <a>transform</a>
transformM :: (Monad m, Uniplate on) => (on -> m on) -> on -> m on

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewrite r x = all (isNothing . r) (universe (rewrite r x))
--   </pre>
--   
--   Usually <a>transform</a> is more appropriate, but <a>rewrite</a> can
--   give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>f <a>mplus</a> g</tt>
--   which performs both rewrites until a fixed point.
rewrite :: Uniplate on => (on -> Maybe on) -> on -> on

-- | Monadic variant of <a>rewrite</a>
rewriteM :: (Monad m, Uniplate on) => (on -> m (Maybe on)) -> on -> m on

-- | Perform a transformation on all the immediate children, then combine
--   them back. This operation allows additional information to be passed
--   downwards, and can be used to provide a top-down transformation.
descend :: Uniplate on => (on -> on) -> on -> on

-- | Monadic variant of <a>descend</a>
descendM :: (Monad m, Uniplate on) => (on -> m on) -> on -> m on

-- | Return all the contexts and holes.
--   
--   <pre>
--   propUniverse x = universe x == map fst (contexts x)
--   propId x = all (== x) [b a | (a,b) &lt;- contexts x]
--   </pre>
contexts :: Uniplate on => on -> [(on, on -> on)]

-- | The one depth version of <a>contexts</a>
--   
--   <pre>
--   propChildren x = children x == map fst (holes x)
--   propId x = all (== x) [b a | (a,b) &lt;- holes x]
--   </pre>
holes :: Uniplate on => on -> [(on, on -> on)]

-- | Perform a fold-like computation on each value, technically a
--   paramorphism
para :: Uniplate on => (on -> [r] -> r) -> on -> r


-- | <i>DEPRECATED</i>: Use <a>Data.Generics.Uniplate.Operations</a>
--   instead.
--   
--   This module retained Haskell 98 compatability, but users who are happy
--   with multi-parameter type classes should look towards
--   <a>Data.Generics.Biplate</a>.
--   
--   The only function missing from <a>Data.Generics.Uniplate</a> is
--   <tt>fold</tt>, as it can be constructed from <a>children</a> and has
--   little meaning in a multi-typed setting.
--   
--   All operations, apart from <a>childrenOn</a> should perform
--   identically to their non <tt>On</tt> counterparts.
module Data.Generics.UniplateOn

-- | Return all the top most children of type <tt>to</tt> within
--   <tt>from</tt>.
--   
--   If <tt>from == to</tt> then this function should return the root as
--   the single child.
type BiplateType from to = from -> ([to], [to] -> from)
universeOn :: Uniplate to => BiplateType from to -> from -> [to]

-- | Return the children of a type. If <tt>to == from</tt> then it returns
--   the original element (in contrast to <a>children</a>)
childrenOn :: Uniplate to => BiplateType from to -> from -> [to]
transformOn :: Uniplate to => BiplateType from to -> (to -> to) -> from -> from
transformOnM :: (Monad m, Uniplate to) => BiplateType from to -> (to -> m to) -> from -> m from
rewriteOn :: Uniplate to => BiplateType from to -> (to -> Maybe to) -> from -> from
rewriteOnM :: (Monad m, Uniplate to) => BiplateType from to -> (to -> m (Maybe to)) -> from -> m from
descendOn :: Uniplate to => BiplateType from to -> (to -> to) -> from -> from
descendOnM :: (Monad m, Uniplate to) => BiplateType from to -> (to -> m to) -> from -> m from
holesOn :: Uniplate to => BiplateType from to -> from -> [(to, to -> from)]
contextsOn :: Uniplate to => BiplateType from to -> from -> [(to, to -> from)]

-- | Used for defining instances <tt>UniplateFoo a =&gt; UniplateFoo
--   [a]</tt>
uniplateOnList :: BiplateType a b -> BiplateType [a] b


-- | This module provides the <a>Str</a> data type, which is used by the
--   underlying <tt>uniplate</tt> and <tt>biplate</tt> methods. It should
--   not be used directly under normal circumstances.
module Data.Generics.Str
data Str a
Zero :: Str a
One :: a -> Str a
Two :: (Str a) -> (Str a) -> Str a
strMap :: (a -> b) -> Str a -> Str b
strMapM :: Monad m => (a -> m b) -> Str a -> m (Str b)

-- | Take the type of the method, will crash if called
strType :: Str a -> a

-- | Convert a <a>Str</a> to a list, assumes the value was created with
--   <a>listStr</a>
strList :: Str a -> [a]

-- | Convert a list to a <a>Str</a>
listStr :: [a] -> Str a

-- | Transform a <a>Str</a> to a list, and back again, in a structure
--   preserving way. The output and input lists must be equal in length.
strStructure :: Str a -> ([a], [a] -> Str a)
instance Show a => Show (Str a)
instance Traversable Str
instance Foldable Str
instance Functor Str
instance Eq a => Eq (Str a)


-- | Definitions of <a>Uniplate</a> and <a>Biplate</a> classes, along with
--   all the standard operations.
--   
--   Import this module directly only if you are defining new Uniplate
--   operations, otherwise import one of
--   <a>Data.Generics.Uniplate.Direct</a>,
--   <a>Data.Generics.Uniplate.Typeable</a> or
--   <a>Data.Generics.Uniplate.Data</a>.
--   
--   Most functions have an example of a possible use for the function. To
--   illustate, I have used the <tt>Expr</tt> type as below:
--   
--   <pre>
--   data Expr = Val Int
--             | Neg Expr
--             | Add Expr Expr
--   </pre>
module Data.Generics.Uniplate.Operations

-- | The standard Uniplate class, all operations require this. All
--   definitions must define <a>uniplate</a>, while <a>descend</a> and
--   <a>descendM</a> are optional.
class Uniplate on where descend f x = case uniplate x of { (current, generate) -> generate $ strMap f current } descendM f x = case uniplate x of { (current, generate) -> liftM generate $ strMapM f current }
uniplate :: Uniplate on => on -> (Str on, Str on -> on)
descend :: Uniplate on => (on -> on) -> on -> on
descendM :: (Uniplate on, Monad m) => (on -> m on) -> on -> m on

-- | Children are defined as the top-most items of type to <i>starting at
--   the root</i>. All instances must define <a>biplate</a>, while
--   <a>descendBi</a> and <a>descendBiM</a> are optional.
class Uniplate to => Biplate from to where descendBi f x = case biplate x of { (current, generate) -> generate $ strMap f current } descendBiM f x = case biplate x of { (current, generate) -> liftM generate $ strMapM f current }
biplate :: Biplate from to => from -> (Str to, Str to -> from)
descendBi :: Biplate from to => (to -> to) -> from -> from
descendBiM :: (Biplate from to, Monad m) => (to -> m to) -> from -> m from

-- | Get all the children of a node, including itself and all children.
--   
--   <pre>
--   universe (Add (Val 1) (Neg (Val 2))) =
--       [Add (Val 1) (Neg (Val 2)), Val 1, Neg (Val 2), Val 2]
--   </pre>
--   
--   This method is often combined with a list comprehension, for example:
--   
--   <pre>
--   vals x = [i | Val i &lt;- universe x]
--   </pre>
universe :: Uniplate on => on -> [on]

-- | Get the direct children of a node. Usually using <a>universe</a> is
--   more appropriate.
children :: Uniplate on => on -> [on]

-- | Transform every element in the tree, in a bottom-up manner.
--   
--   For example, replacing negative literals with literals:
--   
--   <pre>
--   negLits = transform f
--      where f (Neg (Lit i)) = Lit (negate i)
--            f x = x
--   </pre>
transform :: Uniplate on => (on -> on) -> on -> on

-- | Monadic variant of <a>transform</a>
transformM :: (Monad m, Uniplate on) => (on -> m on) -> on -> m on

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewrite r x = all (isNothing . r) (universe (rewrite r x))
--   </pre>
--   
--   Usually <a>transform</a> is more appropriate, but <a>rewrite</a> can
--   give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>f <a>mplus</a> g</tt>
--   which performs both rewrites until a fixed point.
rewrite :: Uniplate on => (on -> Maybe on) -> on -> on

-- | Monadic variant of <a>rewrite</a>
rewriteM :: (Monad m, Uniplate on) => (on -> m (Maybe on)) -> on -> m on

-- | Return all the contexts and holes.
--   
--   <pre>
--   universe x == map fst (contexts x)
--   all (== x) [b a | (a,b) &lt;- contexts x]
--   </pre>
contexts :: Uniplate on => on -> [(on, on -> on)]

-- | The one depth version of <a>contexts</a>
--   
--   <pre>
--   children x == map fst (holes x)
--   all (== x) [b a | (a,b) &lt;- holes x]
--   </pre>
holes :: Uniplate on => on -> [(on, on -> on)]

-- | Perform a fold-like computation on each value, technically a
--   paramorphism
para :: Uniplate on => (on -> [r] -> r) -> on -> r
universeBi :: Biplate from to => from -> [to]

-- | Return the children of a type. If <tt>to == from</tt> then it returns
--   the original element (in contrast to <a>children</a>)
childrenBi :: Biplate from to => from -> [to]
transformBi :: Biplate from to => (to -> to) -> from -> from
transformBiM :: (Monad m, Biplate from to) => (to -> m to) -> from -> m from
rewriteBi :: Biplate from to => (to -> Maybe to) -> from -> from
rewriteBiM :: (Monad m, Biplate from to) => (to -> m (Maybe to)) -> from -> m from
contextsBi :: Biplate from to => from -> [(to, to -> from)]
holesBi :: Biplate from to => from -> [(to, to -> from)]


-- | Compos compatibility layer. This module serves as a drop-in
--   replacement in some situations for some of the Compos operations. Only
--   the single-type traversals are supported, on normal algebraic data
--   types. Users should also import either
--   <a>Data.Generics.Uniplate.Data</a> or
--   <a>Data.Generics.Uniplate.Direct</a>.
--   
--   Compos is described in the paper: "A Pattern for Almost Compositional
--   Functions" by Bjorn Bringert and Aarne Ranta.
--   
--   <ul>
--   <li><a>http://doi.acm.org/10.1145/1159803.1159834</a></li>
--   
--   <li><a>http://www.cs.chalmers.se/~bringert/publ/composOp/composOp.pdf</a></li>
--   </ul>
module Data.Generics.Compos

-- | If you want to keep an existing type class
class Uniplate a => Compos a

-- | <pre>
--   composOp == <a>descend</a>
--   </pre>
composOp :: Uniplate a => (a -> a) -> a -> a

-- | <pre>
--   composOpM == <a>descendM</a>
--   </pre>
composOpM :: (Uniplate a, Monad m) => (a -> m a) -> a -> m a

-- | <pre>
--   composOpM_ == <a>composOpFold</a> (return ()) (&gt;&gt;)
--   </pre>
composOpM_ :: (Uniplate a, Monad m) => (a -> m ()) -> a -> m ()

-- | <pre>
--   composOpMonoid = <a>composOpFold</a> mempty mappend
--   </pre>
composOpMonoid :: (Uniplate a, Monoid m) => (a -> m) -> a -> m

-- | <pre>
--   composOpMPlus = <a>composOpFold</a> mzero mplus
--   </pre>
composOpMPlus :: (Uniplate a, MonadPlus m) => (a -> m b) -> a -> m b

-- | Probably replace with <a>universe</a>, perhaps <a>para</a>
composOpFold :: Uniplate a => b -> (b -> b -> b) -> (a -> b) -> a -> b


-- | SYB compatibility layer. This module serves as a drop-in replacement
--   in some situations for some of the SYB operations. Users should also
--   import <a>Data.Generics.Uniplate.Data</a>.
--   
--   SYB is described in the paper: "Scrap your boilerplate: a practical
--   design pattern for generic programming" by Ralf Lammel and Simon
--   Peyton Jones.
--   
--   <ul>
--   <li><a>http://www.cs.vu.nl/boilerplate/</a></li>
--   <li><a>http://doi.acm.org/10.1145/604174.604179</a></li>
--   <li><a>http://www.cs.vu.nl/boilerplate/tldi03.pdf</a></li>
--   </ul>
module Data.Generics.SYB

-- | <pre>
--   gmapT == <a>descend</a>
--   </pre>
gmapT :: Uniplate a => (a -> a) -> a -> a

-- | Use <a>children</a> and <a>foldl</a>
gmapQl :: Uniplate a => (r -> r' -> r) -> r -> (a -> r') -> a -> r

-- | Use <a>children</a> and <a>foldr</a>
gmapQr :: Uniplate a => (r' -> r -> r) -> r -> (a -> r') -> a -> r

-- | Use <a>children</a>
gmapQ :: Uniplate a => (a -> u) -> a -> [u]

-- | Use <a>children</a> and <a>!!</a>
gmapQi :: Uniplate a => Int -> (a -> u) -> a -> u

-- | <pre>
--   gmapM == <a>descendM</a>
--   </pre>
gmapM :: (Uniplate a, Monad m) => (a -> m a) -> a -> m a

-- | <pre>
--   mkT == <a>id</a>
--   </pre>
mkT :: (a -> a) -> (a -> a)

-- | <pre>
--   everywhere == <a>transformBi</a>
--   </pre>
everywhere :: Biplate b a => (a -> a) -> b -> b

-- | <pre>
--   mkM == id
--   </pre>
mkM :: Monad m => (a -> m a) -> a -> m a

-- | <pre>
--   everywhereM == <a>transformBiM</a>
--   </pre>
everywhereM :: (Biplate b a, Monad m) => (a -> m a) -> b -> m b

-- | Only for use with <a>everything</a>
mkQ :: r -> (a -> r) -> (r, a -> r)

-- | Use <a>universe</a> or <a>universeBi</a>, perhaps followed by a fold.
--   
--   Not an exact equivalent to the SYB <tt>everything</tt>, as the
--   operators may be applied in different orders.
everything :: Biplate b a => (r -> r -> r) -> (r, a -> r) -> b -> r


-- | This module defines <a>Uniplate</a> / <a>Biplate</a> instances for
--   every type with a <a>Data</a> instance. Using GHC, Data can be derived
--   automatically with:
--   
--   <pre>
--   data Expr = Var Int | Neg Expr | Add Expr Expr
--               deriving (Data,Typeable)
--   </pre>
--   
--   All the Uniplate operations defined in
--   <a>Data.Generics.Uniplate.Operations</a> can be used. If you are
--   working with abstract data types, such as <tt>Map</tt> or <tt>Set</tt>
--   from the <tt>containers</tt> package, you may also need to use the
--   data types defined in <a>Data.Generics.Uniplate.Data.Instances</a>.
--   
--   For faster performance (5x faster, but requires writing instances)
--   switch to <a>Data.Generics.Uniplate.Direct</a>. If you get instance
--   conflicts when using both <tt>Data</tt> and <tt>Direct</tt>, switch to
--   <a>Data.Generics.Uniplate.DataOnly</a>.
--   
--   The instances are faster than GHC because they precompute a table of
--   useful information, then use this information when performing the
--   traversals. Sometimes it is not possible to compute the table, in
--   which case this library will perform about the same speed as SYB.
--   
--   Setting the environment variable <tt>$UNIPLATE_VERBOSE</tt> has the
--   following effects:
--   
--   <ul>
--   <li><tt>-1</tt> - raise a program error every time construction of the
--   table fails</li>
--   <li><tt>0</tt> (or unset) - never print any messages or raise any
--   errors</li>
--   <li><tt>1</tt> - give a message every time a table is computed</li>
--   <li><tt>2</tt> - give a message when table computation fails</li>
--   </ul>
--   
--   The <tt>$UNIPLATE_VERBOSE</tt> environment variable must be set before
--   the first call to uniplate.
module Data.Generics.Uniplate.Data

-- | Apply a sequence of transformations in order. This function obeys the
--   equivalence:
--   
--   <pre>
--   transformBis [[transformer f],[transformer g],...] == transformBi f . transformBi g . ...
--   </pre>
--   
--   Each item of type <tt>[Transformer]</tt> is applied in turn, right to
--   left. Within each <tt>[Transformer]</tt>, the individual
--   <tt>Transformer</tt> values may be interleaved.
--   
--   The implementation will attempt to perform fusion, and avoid walking
--   any part of the data structure more than necessary. To further improve
--   performance, you may wish to partially apply the first argument, which
--   will calculate information about the relationship between the
--   transformations.
transformBis :: Data a => [[Transformer]] -> a -> a
data Transformer

-- | Wrap up a <tt>(a -&gt; a)</tt> transformation function, to use with
--   <a>transformBis</a>
transformer :: Data a => (a -> a) -> Transformer
instance (Data a, Data b, Uniplate b) => Biplate a b
instance Data a => Uniplate a


-- | This module functions identically to
--   <a>Data.Generics.Uniplate.Data</a>, but instead of using the standard
--   <a>Uniplate</a> / <a>Biplate</a> classes defined in
--   <a>Data.Generics.Uniplate.Operations</a> it uses a local copy.
--   
--   Only use this module if you are using both <tt>Data</tt> and
--   <tt>Direct</tt> instances in the same project and they are
--   conflicting.
module Data.Generics.Uniplate.DataOnly

-- | The standard Uniplate class, all operations require this. All
--   definitions must define <a>uniplate</a>, while <a>descend</a> and
--   <a>descendM</a> are optional.
class Uniplate on where descend f x = case uniplate x of { (current, generate) -> generate $ strMap f current } descendM f x = case uniplate x of { (current, generate) -> liftM generate $ strMapM f current }
uniplate :: Uniplate on => on -> (Str on, Str on -> on)
descend :: Uniplate on => (on -> on) -> on -> on
descendM :: (Uniplate on, Monad m) => (on -> m on) -> on -> m on

-- | Children are defined as the top-most items of type to <i>starting at
--   the root</i>. All instances must define <a>biplate</a>, while
--   <a>descendBi</a> and <a>descendBiM</a> are optional.
class Uniplate to => Biplate from to where descendBi f x = case biplate x of { (current, generate) -> generate $ strMap f current } descendBiM f x = case biplate x of { (current, generate) -> liftM generate $ strMapM f current }
biplate :: Biplate from to => from -> (Str to, Str to -> from)
descendBi :: Biplate from to => (to -> to) -> from -> from
descendBiM :: (Biplate from to, Monad m) => (to -> m to) -> from -> m from

-- | Get all the children of a node, including itself and all children.
--   
--   <pre>
--   universe (Add (Val 1) (Neg (Val 2))) =
--       [Add (Val 1) (Neg (Val 2)), Val 1, Neg (Val 2), Val 2]
--   </pre>
--   
--   This method is often combined with a list comprehension, for example:
--   
--   <pre>
--   vals x = [i | Val i &lt;- universe x]
--   </pre>
universe :: Uniplate on => on -> [on]

-- | Get the direct children of a node. Usually using <a>universe</a> is
--   more appropriate.
children :: Uniplate on => on -> [on]

-- | Transform every element in the tree, in a bottom-up manner.
--   
--   For example, replacing negative literals with literals:
--   
--   <pre>
--   negLits = transform f
--      where f (Neg (Lit i)) = Lit (negate i)
--            f x = x
--   </pre>
transform :: Uniplate on => (on -> on) -> on -> on

-- | Monadic variant of <a>transform</a>
transformM :: (Monad m, Uniplate on) => (on -> m on) -> on -> m on

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewrite r x = all (isNothing . r) (universe (rewrite r x))
--   </pre>
--   
--   Usually <a>transform</a> is more appropriate, but <a>rewrite</a> can
--   give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>f <a>mplus</a> g</tt>
--   which performs both rewrites until a fixed point.
rewrite :: Uniplate on => (on -> Maybe on) -> on -> on

-- | Monadic variant of <a>rewrite</a>
rewriteM :: (Monad m, Uniplate on) => (on -> m (Maybe on)) -> on -> m on

-- | Return all the contexts and holes.
--   
--   <pre>
--   universe x == map fst (contexts x)
--   all (== x) [b a | (a,b) &lt;- contexts x]
--   </pre>
contexts :: Uniplate on => on -> [(on, on -> on)]

-- | The one depth version of <a>contexts</a>
--   
--   <pre>
--   children x == map fst (holes x)
--   all (== x) [b a | (a,b) &lt;- holes x]
--   </pre>
holes :: Uniplate on => on -> [(on, on -> on)]

-- | Perform a fold-like computation on each value, technically a
--   paramorphism
para :: Uniplate on => (on -> [r] -> r) -> on -> r
universeBi :: Biplate from to => from -> [to]

-- | Return the children of a type. If <tt>to == from</tt> then it returns
--   the original element (in contrast to <a>children</a>)
childrenBi :: Biplate from to => from -> [to]
transformBi :: Biplate from to => (to -> to) -> from -> from
transformBiM :: (Monad m, Biplate from to) => (to -> m to) -> from -> m from
rewriteBi :: Biplate from to => (to -> Maybe to) -> from -> from
rewriteBiM :: (Monad m, Biplate from to) => (to -> m (Maybe to)) -> from -> m from
contextsBi :: Biplate from to => from -> [(to, to -> from)]
holesBi :: Biplate from to => from -> [(to, to -> from)]

-- | Apply a sequence of transformations in order. This function obeys the
--   equivalence:
--   
--   <pre>
--   transformBis [[transformer f],[transformer g],...] == transformBi f . transformBi g . ...
--   </pre>
--   
--   Each item of type <tt>[Transformer]</tt> is applied in turn, right to
--   left. Within each <tt>[Transformer]</tt>, the individual
--   <tt>Transformer</tt> values may be interleaved.
--   
--   The implementation will attempt to perform fusion, and avoid walking
--   any part of the data structure more than necessary. To further improve
--   performance, you may wish to partially apply the first argument, which
--   will calculate information about the relationship between the
--   transformations.
transformBis :: Data a => [[Transformer]] -> a -> a
data Transformer

-- | Wrap up a <tt>(a -&gt; a)</tt> transformation function, to use with
--   <a>transformBis</a>
transformer :: Data a => (a -> a) -> Transformer
instance (Data a, Data b, Uniplate b) => Biplate a b
instance Data a => Uniplate a


-- | This module supplies a method for writing <a>Uniplate</a> and
--   <a>Biplate</a> instances. This moulde gives the highest performance,
--   but requires many instance definitions. The instances can be generated
--   using Derive: <a>http://community.haskell.org/~ndm/derive/</a>.
--   
--   To take an example:
--   
--   <pre>
--   data Expr = Var Int | Pos Expr String | Neg Expr | Add Expr Expr
--   data Stmt = Seq [Stmt] | Sel [Expr] | Let String Expr
--   
--   instance Uniplate Expr where
--       uniplate (Var x  ) = plate Var |- x
--       uniplate (Pos x y) = plate Pos |* x |- y
--       uniplate (Neg x  ) = plate Neg |* x
--       uniplate (Add x y) = plate Add |* x |* y
--   
--   instance Biplate Expr Expr where
--       biplate = plateSelf
--   
--   instance Uniplate Stmt where
--       uniplate (Seq x  ) = plate Seq ||* x
--       uniplate (Sel x  ) = plate Sel ||+ x
--       uniplate (Let x y) = plate Let |-  x |- y
--   
--   instance Biplate Stmt Stmt where
--       biplate = plateSelf
--   
--   instance Biplate Stmt Expr where
--       biplate (Seq x  ) = plate Seq ||+ x
--       biplate (Sel x  ) = plate Sel ||* x
--       biplate (Let x y) = plate Let |-  x |* y
--   </pre>
--   
--   To define instances for abstract data types, such as <tt>Map</tt> or
--   <tt>Set</tt> from the <tt>containers</tt> package, use
--   <a>plateProject</a>.
--   
--   This module provides a few monomorphic instances of <a>Uniplate</a> /
--   <a>Biplate</a> for common types available in the base library, but
--   does not provide any polymorphic instances. Given only monomorphic
--   instances it is trivial to ensure that all instances are disjoint,
--   making it easier to add your own instances.
--   
--   When defining polymorphic instances, be carefully to mention all
--   potential children. Consider <tt>Biplate Int (Int, a)</tt> - this
--   instance cannot be correct because it will fail to return both
--   <tt>Int</tt> values on <tt>(Int,Int)</tt>. There are some legitimate
--   polymorphic instances, such as <tt>Biplate a [a]</tt> and <tt>Biplate
--   a a</tt>, but take care to avoid overlapping instances.
module Data.Generics.Uniplate.Direct

-- | The main combinator used to start the chain.
--   
--   The following rule can be used for optimisation:
--   
--   <pre>
--   plate Ctor |- x == plate (Ctor x)
--   </pre>
plate :: from -> Type from to

-- | Used for <a>Biplate</a> definitions where both types are the same.
plateSelf :: to -> Type to to

-- | The field to the right may contain the target.
(|+) :: Biplate item to => Type (item -> from) to -> item -> Type from to

-- | The field to the right <i>does not</i> contain the target.
(|-) :: Type (item -> from) to -> item -> Type from to

-- | The field to the right is the target.
(|*) :: Type (to -> from) to -> to -> Type from to

-- | The field to the right is a list of types which may contain the target
(||+) :: Biplate item to => Type ([item] -> from) to -> [item] -> Type from to

-- | The field to the right is a list of the type of the target
(||*) :: Type ([to] -> from) to -> [to] -> Type from to

-- | Write an instance in terms of a projection/injection pair. Usually
--   used to define instances for abstract containers such as Map:
--   
--   <pre>
--   instance Biplate (Map.Map [Char] Int) Char where
--       biplate = plateProject Map.toList Map.fromList
--   </pre>
--   
--   If the types ensure that no operations will not change the keys we can
--   use the <tt>fromDistictAscList</tt> function to reconstruct the Map:
--   
--   <pre>
--   instance Biplate (Map.Map [Char] Int) Int where
--       biplate = plateProject Map.toAscList Map.fromDistinctAscList
--   </pre>
plateProject :: Biplate item to => (from -> item) -> (item -> from) -> from -> Type from to
instance Biplate (Ratio Integer) Integer
instance Biplate (Ratio Integer) (Ratio Integer)
instance Uniplate (Ratio Integer)
instance Biplate [Char] [Char]
instance Biplate [Char] Char
instance Uniplate [Char]
instance Uniplate ()
instance Uniplate Float
instance Uniplate Double
instance Uniplate Integer
instance Uniplate Char
instance Uniplate Bool
instance Uniplate Int


-- | <i>RECOMMENDATION:</i> Use <a>Data.Generics.Uniplate.Data</a> instead
--   - it usually performs faster (sometimes significantly so) and requires
--   no special instance declarations.
--   
--   This module supplies a method for writing <a>Uniplate</a> /
--   <a>Biplate</a> instances. One instance declaration is required for
--   each data type you wish to work with. The instances can be generated
--   using Derive: <a>http://community.haskell.org/~ndm/derive/</a>.
--   
--   To take an example:
--   
--   <pre>
--   data Expr = Var Int | Neg Expr | Add Expr Expr
--               deriving Typeable
--   
--   instance (Typeable a, Uniplate a) =&gt; PlateAll Expr a where
--       plateAll (Var x  ) = plate Var |+ x
--       plateAll (Neg x  ) = plate Neg |+ x
--       plateAll (Add x y) = plate Add |+ x |+ y
--   </pre>
module Data.Generics.Uniplate.Typeable

-- | This class should be defined for each data type of interest.
class PlateAll from to
plateAll :: PlateAll from to => from -> Type from to

-- | The main combinator used to start the chain.
plate :: from -> Type from to

-- | The field to the right may contain the target.
(|+) :: (Typeable item, Typeable to, PlateAll item to) => Type (item -> from) to -> item -> Type from to

-- | The field to the right <i>does not</i> contain the target. This can be
--   used as either an optimisation, or more commonly for excluding
--   primitives such as Int.
(|-) :: Type (item -> from) to -> item -> Type from to

-- | Write an instance in terms of a projection/injection pair. Usually
--   used to define instances for abstract containers such as Map:
--   
--   <pre>
--   instance (Ord a, Typeable a, PlateAll a c, Typeable b, PlateAll b c,
--            Typeable c, PlateAll c c) =&gt; PlateAll (Map.Map a b) c where
--       plateAll = plateProject Map.toList Map.fromList
--   </pre>
plateProject :: (Typeable item, Typeable to, PlateAll item to) => (from -> item) -> (item -> from) -> from -> Type from to
instance (Integral a, PlateAll a to, Typeable a, Typeable to, Uniplate to) => PlateAll (Ratio a) to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, PlateAll c to, Typeable c, PlateAll d to, Typeable d, PlateAll e to, Typeable e, Typeable to, Uniplate to) => PlateAll (a, b, c, d, e) to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, PlateAll c to, Typeable c, PlateAll d to, Typeable d, Typeable to, Uniplate to) => PlateAll (a, b, c, d) to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, PlateAll c to, Typeable c, Typeable to, Uniplate to) => PlateAll (a, b, c) to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, Typeable to, Uniplate to) => PlateAll (a, b) to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, Typeable to, Uniplate to) => PlateAll (Either a b) to
instance (PlateAll from to, Typeable from, Typeable to, Uniplate to) => PlateAll (Maybe from) to
instance (PlateAll from to, Typeable from, Typeable to, Uniplate to) => PlateAll [from] to
instance PlateAll () to
instance PlateAll Float to
instance PlateAll Double to
instance PlateAll Integer to
instance PlateAll Char to
instance PlateAll Bool to
instance PlateAll Int to
instance PlateAll a a => Uniplate a
instance (Typeable a, Typeable b, Uniplate b, PlateAll a b) => Biplate a b


-- | A zipper is a structure for walking a value and manipulating it in
--   constant time.
--   
--   This module was inspired by the paper: <i>Michael D. Adams. Scrap Your
--   Zippers: A Generic Zipper for Heterogeneous Types, Workshop on Generic
--   Programming 2010</i>.
module Data.Generics.Uniplate.Zipper

-- | Zipper structure, whose root type is the first type argument, and
--   whose focus type is the second type argument.
data Zipper from to

-- | Create a zipper, focused on the top-left value.
zipper :: Uniplate to => to -> Zipper to to

-- | Create a zipper with a different focus type from the outer type. Will
--   return <tt>Nothing</tt> if there are no instances of the focus type
--   within the original value.
zipperBi :: Biplate from to => from -> Maybe (Zipper from to)

-- | From a zipper take the whole structure, including any modifications.
fromZipper :: Zipper from to -> from

-- | Move one step left from the current position.
left :: Zipper from to -> Maybe (Zipper from to)

-- | Move one step right from the current position.
right :: Zipper from to -> Maybe (Zipper from to)

-- | Move one step up from the current position.
up :: Zipper from to -> Maybe (Zipper from to)

-- | Move one step down from the current position.
down :: Uniplate to => Zipper from to -> Maybe (Zipper from to)

-- | Retrieve the current focus of the zipper..
hole :: Zipper from to -> to

-- | Replace the value currently at the focus of the zipper.
replaceHole :: to -> Zipper from to -> Zipper from to
instance Eq a => Eq (Diff1 a)
instance Eq a => Eq (Zip1 a)
instance Eq x => Eq (ZipN x)
instance (Eq from, Eq to) => Eq (Zipper from to)


-- | <i>DEPRECATED</i>: Use <a>Data.Generics.Uniplate.Operations</a>
--   instead.
--   
--   This is the main Uniplate module, which defines all the essential
--   operations in a Haskell 98 compatible manner.
--   
--   Most functions have an example of a possible use for the function. To
--   illustate, I have used the <tt>Expr</tt> type as below:
--   
--   <pre>
--   data Expr = Val Int
--             | Neg Expr
--             | Add Expr Expr
--   </pre>
module Data.Generics.UniplateStr

-- | The type of replacing all the children of a node
--   
--   Taking a value, the function should return all the immediate children
--   of the same type, and a function to replace them.
type UniplateType on = on -> (Str on, Str on -> on)

-- | The standard Uniplate class, all operations require this.
class Uniplate on
uniplate :: Uniplate on => UniplateType on

-- | Compatibility method, for direct users of the old list-based
--   <a>uniplate</a> function
uniplateList :: Uniplate on => on -> ([on], [on] -> on)

-- | Get all the children of a node, including itself and all children.
--   
--   <pre>
--   universe (Add (Val 1) (Neg (Val 2))) =
--       [Add (Val 1) (Neg (Val 2)), Val 1, Neg (Val 2), Val 2]
--   </pre>
--   
--   This method is often combined with a list comprehension, for example:
--   
--   <pre>
--   vals x = [i | Val i &lt;- universe x]
--   </pre>
universe :: Uniplate on => on -> [on]

-- | Get the direct children of a node. Usually using <a>universe</a> is
--   more appropriate.
--   
--   <pre>
--   children = fst . <a>uniplate</a>
--   </pre>
children :: Uniplate on => on -> [on]

-- | Transform every element in the tree, in a bottom-up manner.
--   
--   For example, replacing negative literals with literals:
--   
--   <pre>
--   negLits = transform f
--      where f (Neg (Lit i)) = Lit (negate i)
--            f x = x
--   </pre>
transform :: Uniplate on => (on -> on) -> on -> on

-- | Monadic variant of <a>transform</a>
transformM :: (Monad m, Uniplate on) => (on -> m on) -> on -> m on

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewrite r x = all (isNothing . r) (universe (rewrite r x))
--   </pre>
--   
--   Usually <a>transform</a> is more appropriate, but <a>rewrite</a> can
--   give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>f <a>mplus</a> g</tt>
--   which performs both rewrites until a fixed point.
rewrite :: Uniplate on => (on -> Maybe on) -> on -> on

-- | Monadic variant of <a>rewrite</a>
rewriteM :: (Monad m, Uniplate on) => (on -> m (Maybe on)) -> on -> m on

-- | Perform a transformation on all the immediate children, then combine
--   them back. This operation allows additional information to be passed
--   downwards, and can be used to provide a top-down transformation.
descend :: Uniplate on => (on -> on) -> on -> on

-- | Monadic variant of <a>descend</a>
descendM :: (Monad m, Uniplate on) => (on -> m on) -> on -> m on

-- | Return all the contexts and holes.
--   
--   <pre>
--   propUniverse x = universe x == map fst (contexts x)
--   propId x = all (== x) [b a | (a,b) &lt;- contexts x]
--   </pre>
contexts :: Uniplate on => on -> [(on, on -> on)]

-- | The one depth version of <a>contexts</a>
--   
--   <pre>
--   propChildren x = children x == map fst (holes x)
--   propId x = all (== x) [b a | (a,b) &lt;- holes x]
--   </pre>
holes :: Uniplate on => on -> [(on, on -> on)]

-- | Perform a fold-like computation on each value, technically a
--   paramorphism
para :: Uniplate on => (on -> [r] -> r) -> on -> r


-- | <i>DEPRECATED</i>: Use <a>Data.Generics.Uniplate.Operations</a>
--   instead.
--   
--   This module retained Haskell 98 compatability, but users who are happy
--   with multi-parameter type classes should look towards
--   <a>Data.Generics.Biplate</a>.
--   
--   The only function missing from <a>Data.Generics.Uniplate</a> is
--   <tt>fold</tt>, as it can be constructed from <a>children</a> and has
--   little meaning in a multi-typed setting.
--   
--   All operations, apart from <a>childrenOn</a>, <a>descendOn</a> and
--   <a>holesOn</a> should perform identically to their non <tt>On</tt>
--   counterparts.
module Data.Generics.UniplateStrOn

-- | Return all the top most children of type <tt>to</tt> within
--   <tt>from</tt>.
--   
--   If <tt>from == to</tt> then this function should return the root as
--   the single child.
type BiplateType from to = from -> (Str to, Str to -> from)
universeOn :: Uniplate to => BiplateType from to -> from -> [to]

-- | Return the children of a type. If <tt>to == from</tt> then it returns
--   the original element (in contrast to <a>children</a>)
childrenOn :: Uniplate to => BiplateType from to -> from -> [to]
transformOn :: Uniplate to => BiplateType from to -> (to -> to) -> from -> from
transformOnM :: (Monad m, Uniplate to) => BiplateType from to -> (to -> m to) -> from -> m from
rewriteOn :: Uniplate to => BiplateType from to -> (to -> Maybe to) -> from -> from
rewriteOnM :: (Monad m, Uniplate to) => BiplateType from to -> (to -> m (Maybe to)) -> from -> m from
descendOn :: Uniplate to => BiplateType from to -> (to -> to) -> from -> from
descendOnM :: (Monad m, Uniplate to) => BiplateType from to -> (to -> m to) -> from -> m from
holesOn :: Uniplate to => BiplateType from to -> from -> [(to, to -> from)]
contextsOn :: Uniplate to => BiplateType from to -> from -> [(to, to -> from)]

-- | Used for defining instances <tt>UniplateFoo a =&gt; UniplateFoo
--   [a]</tt>
uniplateOnList :: BiplateType a b -> BiplateType [a] b


-- | <i>DEPRECATED</i>: Use <a>Data.Generics.Uniplate.Operations</a>
--   instead.
--   
--   Requires multi-parameter type classes, so is no longer Haskell 98.
--   These operations are easier to use and construct than the equivalent
--   <a>Data.Generics.UniplateStrOn</a> methods, but perform the same
--   operation.
--   
--   It is recommended that instead of importing this module, you import
--   one of the following modules, to construct instances:
--   
--   <ul>
--   <li><a>Data.Generics.PlateDirect</a> - does not require overlapping
--   instances, highest performance but requires <i>O(n^2)</i> instances in
--   the worst case.</li>
--   <li><a>Data.Generics.PlateTypeable</a> - requires the
--   <a>Data.Typeable</a> class for all data structures.</li>
--   <li><a>Data.Generics.PlateData</a> - requires <a>Data.Generics</a> and
--   the <tt>Data</tt> class, which is only available on GHC, but
--   automatically infers instances.</li>
--   </ul>
module Data.Generics.Biplate

-- | Children are defined as the top-most items of type to <i>starting at
--   the root</i>.
class Uniplate to => Biplate from to
biplate :: Biplate from to => BiplateType from to

-- | Compatibility method, for direct users of the <a>biplate</a> function
biplateList :: Biplate from to => from -> ([to], [to] -> from)
universeBi :: Biplate from to => from -> [to]
childrenBi :: Biplate from to => from -> [to]
transformBi :: Biplate from to => (to -> to) -> from -> from
transformBiM :: (Monad m, Biplate from to) => (to -> m to) -> from -> m from
rewriteBi :: Biplate from to => (to -> Maybe to) -> from -> from
rewriteBiM :: (Monad m, Biplate from to) => (to -> m (Maybe to)) -> from -> m from
descendBi :: Biplate from to => (to -> to) -> from -> from
descendBiM :: (Monad m, Biplate from to) => (to -> m to) -> from -> m from
contextsBi :: Biplate from to => from -> [(to, to -> from)]
holesBi :: Biplate from to => from -> [(to, to -> from)]


-- | <i>DEPRECATED</i>: Use <a>Data.Generics.Uniplate.Direct</a> instead.
--   
--   This module supplies a method for writing <a>Biplate</a> instances
--   more easily. This module requires fewest extensions, highest
--   performance, and most instance definitions.
--   
--   To take an example:
--   
--   <pre>
--   data Expr = Var Int | Pos Expr String | Neg Expr | Add Expr Expr
--   data Stmt = Seq [Stmt] | Sel [Expr] | Let String Expr
--   
--   instance Uniplate Expr where
--       uniplate (Var x  ) = plate Var |- x
--       uniplate (Pos x y) = plate Pos |* x |- y
--       uniplate (Neg x  ) = plate Neg |* x
--       uniplate (Add x y) = plate Add |* x |* y
--   
--   instance Biplate Expr Expr where
--       biplate = plateSelf
--   
--   instance Uniplate Stmt where
--       uniplate (Seq x  ) = plate Seq ||* x
--       uniplate (Sel x  ) = plate Sel ||+ x
--       uniplate (Let x y) = plate Let |-  x |- y
--   
--   instance Biplate Stmt Stmt where
--       biplate = plateSelf
--   
--   instance Biplate Stmt Expr where
--       biplate (Seq x  ) = plate Seq ||+ x
--       biplate (Sel x  ) = plate Sel ||* x
--       biplate (Let x y) = plate Let |-  x |* y
--   </pre>

-- | <i>Deprecated: Use Data.Generics.Uniplate.Direct instead </i>
module Data.Generics.PlateDirect

-- | The main combinator used to start the chain.
--   
--   The following rule can be used for optimisation:
--   
--   <pre>
--   plate Ctor |- x == plate (Ctor x)
--   </pre>
plate :: from -> Type from to

-- | Used for <tt>PlayAll</tt> definitions where both types are the same.
plateSelf :: to -> Type to to

-- | The field to the right may contain the target.
(|+) :: Biplate item to => Type (item -> from) to -> item -> Type from to

-- | The field to the right <i>does not</i> contain the target.
(|-) :: Type (item -> from) to -> item -> Type from to

-- | The field to the right is the target.
(|*) :: Type (to -> from) to -> to -> Type from to

-- | The field to the right is a list of types which may contain the target
(||+) :: Biplate item to => Type ([item] -> from) to -> [item] -> Type from to

-- | The field to the right is a list of the type of the target
(||*) :: Type ([to] -> from) to -> [to] -> Type from to


-- | <i>DEPRECATED</i>: Use <a>Data.Generics.Uniplate.Typeable</a> instead.
--   
--   This module supplies a method for writing <a>Biplate</a> instances
--   more easily.
--   
--   To take an example:
--   
--   <pre>
--   data Expr = Var Int | Neg Expr | Add Expr Expr
--   
--   instance Typeable Expr where ...
--   
--   instance (Typeable a, Uniplate a) =&gt; PlateAll Expr a where
--     plateAll (Var x  ) = plate Var |- x
--     plateAll (Neg x  ) = plate Neg |+ x
--     plateAll (Add x y) = plate Add |+ x |+ y
--   
--   instance Uniplate Expr where
--     uniplate = uniplateAll
--   </pre>

-- | <i>Deprecated: Use Data.Generics.Uniplate.Typeable instead </i>
module Data.Generics.PlateTypeable

-- | This class represents going from the container type to the target.
--   
--   This class should only be constructed with <a>plate</a>, <a>|+</a> and
--   <a>|-</a>
class PlateAll from to
plateAll :: PlateAll from to => from -> Type from to

-- | This function is used to write a <a>Uniplate</a> instance from a
--   <a>PlateAll</a> one
uniplateAll :: PlateAll a b => a -> (Str b, Str b -> a)

-- | The main combinator used to start the chain.
--   
--   The following rule can be used for optimisation:
--   
--   <pre>
--   plate Ctor |- x == plate (Ctor x)
--   </pre>
plate :: from -> Type from to

-- | the field to the right may contain the target.
(|+) :: (Typeable item, Typeable to, PlateAll item to) => Type (item -> from) to -> item -> Type from to

-- | The field to the right <i>does not</i> contain the target. This can be
--   used as either an optimisation, or more commonly for excluding
--   primitives such as Int.
(|-) :: Type (item -> from) to -> item -> Type from to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, PlateAll c to, Typeable c, PlateAll d to, Typeable d, PlateAll e to, Typeable e, Typeable to, Uniplate to) => PlateAll (a, b, c, d, e) to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, PlateAll c to, Typeable c, PlateAll d to, Typeable d, Typeable to, Uniplate to) => PlateAll (a, b, c, d) to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, PlateAll c to, Typeable c, Typeable to, Uniplate to) => PlateAll (a, b, c) to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, Typeable to, Uniplate to) => PlateAll (a, b) to
instance (PlateAll a to, Typeable a, PlateAll b to, Typeable b, Typeable to, Uniplate to) => PlateAll (Either a b) to
instance (PlateAll from to, Typeable from, Typeable to, Uniplate to) => PlateAll (Maybe from) to
instance (PlateAll from to, Typeable from, Typeable to, Uniplate to) => PlateAll [from] to
instance Uniplate ()
instance PlateAll () to
instance Uniplate Float
instance PlateAll Float to
instance Uniplate Double
instance PlateAll Double to
instance Uniplate Integer
instance PlateAll Integer to
instance Uniplate Char
instance PlateAll Char to
instance Uniplate Bool
instance PlateAll Bool to
instance Uniplate Int
instance PlateAll Int to
instance (Typeable a, Typeable b, Uniplate b, PlateAll a b) => Biplate a b


-- | <i>DEPRECATED</i>: Use <a>Data.Generics.Uniplate.Data</a> instead.
--   
--   This module exports <a>Biplate</a> instances for everything with
--   <a>Data</a> defined. Using GHC the <a>Data</a> instances can be
--   constructed with <tt>deriving Data</tt>.

-- | <i>Deprecated: Use Data.Generics.Uniplate.Data instead </i>
module Data.Generics.PlateData
instance (Data a, Data b, Uniplate b, Typeable a, Typeable b) => Biplate a b
instance (Data a, Typeable a) => Uniplate a
