-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extended Categories
--   
@package extended-categories
@version 0.1.0

module Category

-- | The class of categories <tt>m</tt> with objects of kind <tt>k</tt>
--   which satisfy the constraint <tt>Object m</tt>. For any objects
--   <tt>a</tt> and <tt>b</tt>, the type <tt>m a b</tt> is the type of
--   morphisms with domain <tt>a</tt> and codomain <tt>b</tt>.
class Category (m :: k -> k -> *) where type family Object m (a :: k) :: Constraint
id :: (Category m, Object m a) => m a a
(.) :: Category m => m b c -> m a b -> m a c
observeObjects :: Category m => m a b -> Dict (Object m a, Object m b)

-- | The category Hask of functions between types.

-- | The category of entailment from <tt>constraints</tt>
instance Category (:-)
instance Category (->)

module Terminal
class (Category c, Object c (T c)) => Terminal c where type family T c
term :: (Terminal c, Object c a) => c a (T c)
instance Terminal (->)

module Functor

-- | The class of functors <tt>f</tt> from <tt>Domain f</tt> to
--   <tt>Codomain f</tt>. Rather than indexing functors on the type of
--   their object mapping, Functor is indexed on the phantom type variable
--   <tt>f</tt>. This allows the object mapping to be any type family
--   <tt>FMap f</tt>, and for multiple functors to exist between
--   categories. As a consequence, a proxy <tt>k</tt> for the kind of
--   <tt>FMap f</tt> must be given as a second parameter to Functor.
class (Category (Domain f :: o1 -> o1 -> *), Category (Codomain f :: o2 -> o2 -> *)) => Functor (f :: *) (k :: KProxy (o1 -> o2)) | f -> k where type family FMap f (a :: o1) :: o2 type family Domain f :: o1 -> o1 -> * type family Codomain f :: o2 -> o2 -> *
morphMap :: Functor f k => Tagged f (Domain f (a :: o1) (b :: o1) -> Codomain f (FMap f a :: o2) (FMap f b :: o2))

-- | Proof that functors map objects to objects. Defines a functor from Cat
--   to (:-).
objectMap :: Functor f (KProxy :: KProxy (o1 -> o2)) => Tagged '(f, a) (Object (Domain f) a :- Object (Codomain f) (FMap f a :: o2))
fmap :: Functor f (KProxy :: KProxy (o1 -> o2)) => f -> Domain f a b -> Codomain f (FMap f a :: o2) (FMap f b :: o2)

-- | The composition of functors. The type variable <tt>k</tt> is a proxy
--   for the kind of the objects of the codomain of <tt>g</tt>.
data Comp (k :: KProxy o2) (f :: *) (g :: *)
(:.:) :: f -> g -> Comp (KProxy :: KProxy o2) f g

-- | The identity functor.
data IdentityF c
IdentityF :: IdentityF c

-- | Functors derived from Prelude's Functor.
data CanonicalF (f :: * -> *)
CanonicalF :: CanonicalF f
instance Functor f => Functor (CanonicalF f) 'KProxy
instance Category c => Functor (IdentityF c) 'KProxy
instance (Functor f 'KProxy, Functor g 'KProxy, Domain f ~ Codomain g) => Functor (Comp 'KProxy f g) 'KProxy

module Category.Product
data (:><:) c1 c2 a b
(:><:) :: c1 (L a) (L b) -> c2 (R a) (R b) -> (c1 :><: c2) a b
data Diag c
Diag :: Diag c
instance Category c => Functor (Diag c) 'KProxy
instance (Category c1, Category c2) => Category (c1 :><: c2)

module TerminalMorphism
class (Functor f (KProxy :: KProxy (o1 -> o2)), Object (Domain f) a, Object (Codomain f) x) => TerminalMorphism f (a :: o1) (x :: o2)
terminalMorphism :: TerminalMorphism f a x => Tagged '(f, a) (Codomain f (FMap f a) x)
terminalFactorization :: (TerminalMorphism f a x, Object (Domain f) y) => Tagged f (Codomain f (FMap f y) x -> Domain f y a)

module Monoidal
class (Category c, Functor (Mu c) (KProxy :: KProxy ((k, k) -> k)), Domain (Mu c) ~ (c :><: c), Codomain (Mu c) ~ c, Object c (I c)) => Monoidal (c :: k -> k -> *) where type family Mu c type family I c :: k
(<>) :: Monoidal c => c a1 b1 -> c a2 b2 -> c (FMap (Mu c) '(a1, a2)) (FMap (Mu c) '(b1, b2))

module Product
class Category c => ProductCategory (c :: k -> k -> *) where type family (><) (a :: k) (b :: k) :: k
productObjectMap :: ProductCategory c => Tagged '(c, a, b) ((Object c a, Object c b) :- Object c (a >< b))
univProduct :: ProductCategory c => Tagged '(c, a, b) ((Object c a, Object c b) :- TerminalMorphism (Diag c) (a >< b) '(a, b))
proj1 :: (ProductCategory c, Object c a, Object c b) => Tagged b (c (a >< b) a)
proj2 :: (ProductCategory c, Object c a, Object c b) => Tagged a (c (a >< b) b)
(&&&) :: ProductCategory c => c a b1 -> c a b2 -> c a (b1 >< b2)
(***) :: ProductCategory c => c a1 b1 -> c a2 b2 -> c (a1 >< a2) (b1 >< b2)
data ProductF c
ProductF :: ProductF c
instance ProductCategory (:-)
instance TerminalMorphism (Diag (:-)) (a, b) '(a, b)
instance ProductCategory (->)
instance TerminalMorphism (Diag (->)) (a, b) '(a, b)
instance (ProductCategory c, Terminal c) => Monoidal c
instance ProductCategory c => Functor (ProductF c) 'KProxy

module NaturalTransformation
data NatTr (c1 :: o1 -> o1 -> *) (c2 :: o2 -> o2 -> *) (f :: *) (g :: *)
NatTr :: (forall (a :: o1). Object c1 a => Tagged a (c2 (FMap f a :: o2) (FMap g a :: o2))) -> NatTr (c1 :: o1 -> o1 -> *) (c2 :: o2 -> o2 -> *) f g
data CompFF c1 c2 c3
CompFF :: CompFF c1 c2 c3
compNat :: NatTr c2 c3 f1 g1 -> NatTr c1 c2 f2 g2 -> NatTr c1 c3 (Comp (KProxy :: KProxy o2) f1 f2) (Comp (KProxy :: KProxy o2) g1 g2)
instance Category c => Monoidal (NatTr c c)
instance (Category c1, Category c2, Category c3) => Functor (CompFF c1 c2 c3) 'KProxy
instance (Category c1, Category c2) => Category (NatTr c1 c2)
