-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Haskell Tool Stack
--   
--   Please see the README.md for usage information, and the wiki on Github
--   for more details. Also, note that the API for the library is not
--   currently stable, and may change significantly, even between minor
--   releases. It is currently only intended for use by the executable.
@package stack
@version 0.1.0.0

module Network.HTTP.Download.Verified

-- | Copied and extended version of Network.HTTP.Download.download.
--   
--   Has the following additional features: * Verifies that response
--   content-length header (if present) matches expected length * Limits
--   the download to (close to) the expected # of bytes * Verifies that the
--   expected # bytes were downloaded (not too few) * Verifies md5 if
--   response includes content-md5 header * Verifies the expected hashes
--   
--   Throws VerifiedDownloadException, and whatever else "download" throws.
verifiedDownload :: (MonadReader env m, HasHttpManager env, MonadIO m) => DownloadRequest -> Path Abs File -> Sink ByteString (ReaderT env IO) () -> m Bool

-- | A request together with some checks to perform.
data DownloadRequest
DownloadRequest :: Request -> [HashCheck] -> Maybe LengthCheck -> DownloadRequest
drRequest :: DownloadRequest -> Request
drHashChecks :: DownloadRequest -> [HashCheck]
drLengthCheck :: DownloadRequest -> Maybe LengthCheck
data HashCheck
HashCheck :: a -> CheckHexDigest -> HashCheck
hashCheckAlgorithm :: HashCheck -> a
hashCheckHexDigest :: HashCheck -> CheckHexDigest
data CheckHexDigest
CheckHexDigestString :: String -> CheckHexDigest
CheckHexDigestByteString :: ByteString -> CheckHexDigest
CheckHexDigestHeader :: ByteString -> CheckHexDigest
type LengthCheck = Int

-- | An exception regarding verification of a download.
data VerifiedDownloadException
WrongContentLength :: Request -> Int -> ByteString -> VerifiedDownloadException
WrongStreamLength :: Request -> Int -> Int -> VerifiedDownloadException
WrongDigest :: Request -> String -> CheckHexDigest -> String -> VerifiedDownloadException
instance Typeable VerifiedDownloadException
instance Typeable VerifyFileException
instance Show HashCheck
instance Show CheckHexDigest
instance Show DownloadRequest
instance Show VerifyFileException
instance Exception VerifyFileException
instance Exception VerifiedDownloadException
instance Show VerifiedDownloadException
instance IsString CheckHexDigest


-- | Separate module because TH.
module System.Process.Log

-- | Log running a process with its arguments, for debugging (-v).
logProcessRun :: Q Exp

-- | Show a process arg including speechmarks when necessary. Just for
--   debugging purposes, not functionally important.
showProcessArgDebug :: [Char] -> Text

module Stack.New
newProject :: (MonadIO m, MonadLogger m) => m ()


-- | Reading from external processes.
module System.Process.Read

-- | Produce a strict <a>ByteString</a> from the stdout of a process.
--   Throws a <a>ProcessExitedUnsuccessfully</a> exception if the process
--   fails.
readProcessStdout :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m) => Maybe (Path Abs Dir) -> EnvOverride -> String -> [String] -> m ByteString

-- | Try to produce a strict <a>ByteString</a> from the stdout of a
--   process.
tryProcessStdout :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m) => Maybe (Path Abs Dir) -> EnvOverride -> String -> [String] -> m (Either ReadProcessException ByteString)

-- | Consume the stdout of a process feeding strict <a>ByteString</a>s to a
--   consumer. If the process fails, spits out stdout and stderr as error
--   log level. Should not be used for long-running processes or ones with
--   lots of output; for that use <tt>sinkProcessStdoutLogStderr</tt>.
sinkProcessStdout :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m) => Maybe (Path Abs Dir) -> EnvOverride -> String -> [String] -> Sink ByteString IO a -> m a

-- | <tt>readProcess</tt> forks an external process, reads its standard
--   output strictly, blocking until the process terminates, and returns
--   the output string.
--   
--   If an asynchronous exception is thrown to the thread executing
--   <tt>readProcess</tt>. The forked process will be terminated and
--   <tt>readProcess</tt> will wait (block) until the process has been
--   terminated.
--   
--   Output is returned strictly, so this is not suitable for interactive
--   applications.
--   
--   This function throws an <a>IOError</a> if the process <a>ExitCode</a>
--   is anything other than <a>ExitSuccess</a>.
--   
--   Users of this function should compile with <tt>-threaded</tt> if they
--   want other Haskell threads to keep running while waiting on the result
--   of readProcess.
--   
--   <pre>
--   &gt; readProcess "date" [] []
--   "Thu Feb  7 10:03:39 PST 2008\n"
--   </pre>
--   
--   The arguments are:
--   
--   <ul>
--   <li>The command to run, which must be in the $PATH, or an absolute
--   path</li>
--   <li>A list of separate command line arguments to the program</li>
--   <li>A string to pass on the standard input to the program.</li>
--   </ul>
readProcess :: FilePath -> [String] -> String -> IO String

-- | Override the environment received by a child process
data EnvOverride
EnvOverride :: Map Text Text -> [(String, String)] -> [FilePath] -> IORef (Map FilePath (Either ReadProcessException (Path Abs File))) -> String -> EnvOverride
eoTextMap :: EnvOverride -> Map Text Text
eoStringList :: EnvOverride -> [(String, String)]
eoPath :: EnvOverride -> [FilePath]
eoExeCache :: EnvOverride -> IORef (Map FilePath (Either ReadProcessException (Path Abs File)))
eoExeExtension :: EnvOverride -> String

-- | Get the environment variables from <tt>EnvOverride</tt>
unEnvOverride :: EnvOverride -> Map Text Text

-- | Create a new <tt>EnvOverride</tt>
mkEnvOverride :: MonadIO m => Platform -> Map Text Text -> m EnvOverride

-- | Helper conversion function
envHelper :: EnvOverride -> Maybe [(String, String)]

-- | Check if the given executable exists on the given PATH
doesExecutableExist :: MonadIO m => EnvOverride -> String -> m Bool

-- | Find the complete path for the executable
findExecutable :: (MonadIO m, MonadThrow n) => EnvOverride -> String -> m (n (Path Abs File))

-- | Load up an EnvOverride from the standard environment
getEnvOverride :: MonadIO m => Platform -> m EnvOverride

-- | Get the list of directories searched
envSearchPath :: EnvOverride -> [FilePath]

-- | Perform pre-call-process tasks. Ensure the working directory exists
--   and find the executable path.
preProcess :: MonadIO m => Maybe (Path Abs Dir) -> EnvOverride -> String -> m FilePath

-- | Read from the process, ignoring any output.
readProcessNull :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m) => Maybe (Path Abs Dir) -> EnvOverride -> String -> [String] -> m ()

-- | Run the given command in the given directory. If it exits with
--   anything but success, prints an error and then calls <a>exitWith</a>
--   to exit the program.
readInNull :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m) => Path Abs Dir -> FilePath -> EnvOverride -> [String] -> Maybe Text -> m ()

-- | Log running a process with its arguments, for debugging (-v).
logProcessRun :: Q Exp
data ReadProcessException
ReadProcessException :: CreateProcess -> ExitCode -> ByteString -> ByteString -> ReadProcessException
NoPathFound :: ReadProcessException
ExecutableNotFound :: String -> [FilePath] -> ReadProcessException
instance Typeable ReadProcessException
instance Exception ReadProcessException
instance Show ReadProcessException


-- | Reading from external processes.
module System.Process.Run

-- | Run the given command in the given directory, inheriting stdout and
--   stderr. If it exits with anything but success, prints an error and
--   then calls <a>exitWith</a> to exit the program.
runIn :: (MonadLogger m, MonadIO m) => Path Abs Dir -> FilePath -> EnvOverride -> [String] -> Maybe Text -> m ()

-- | Like as <tt>System.Process.callProcess</tt>, but takes an optional
--   working directory and environment override, and throws
--   ProcessExitedUnsuccessfully if the process exits unsuccessfully.
--   Inherits stdout and stderr.
callProcess :: MonadIO m => Maybe (Path Abs Dir) -> EnvOverride -> String -> [String] -> m ()


-- | Names for packages.
module Stack.Types.PackageName

-- | A package name.
data PackageName

-- | A parse fail.
data PackageNameParseFail
PackageNameParseFail :: ByteString -> PackageNameParseFail
CabalFileNameParseFail :: FilePath -> PackageNameParseFail

-- | Attoparsec parser for a package name from bytestring.
packageNameParser :: Parser PackageName

-- | Convenient way to parse a package name from a bytestring.
parsePackageName :: MonadThrow m => ByteString -> m PackageName

-- | Migration function.
parsePackageNameFromString :: MonadThrow m => String -> m PackageName

-- | Produce a bytestring representation of a package name.
packageNameByteString :: PackageName -> ByteString

-- | Produce a string representation of a package name.
packageNameString :: PackageName -> String

-- | Produce a string representation of a package name.
packageNameText :: PackageName -> Text

-- | Convert from a Cabal package name.
fromCabalPackageName :: PackageName -> PackageName

-- | Convert to a Cabal package name.
toCabalPackageName :: PackageName -> PackageName

-- | Parse a package name from a file path.
parsePackageNameFromFilePath :: MonadThrow m => Path a File -> m PackageName

-- | Make a package name.
mkPackageName :: String -> Q Exp
instance Typeable PackageNameParseFail
instance Typeable PackageName
instance Eq PackageName
instance Ord PackageName
instance Data PackageName
instance Generic PackageName
instance Hashable PackageName
instance Binary PackageName
instance NFData PackageName
instance Datatype D1PackageName
instance Constructor C1_0PackageName
instance FromJSON a => FromJSON (Map PackageName a)
instance ToJSON a => ToJSON (Map PackageName a)
instance FromJSON PackageName
instance ToJSON PackageName
instance Show PackageName
instance Lift PackageName
instance Show PackageNameParseFail
instance Exception PackageNameParseFail


-- | Docker types.
module Stack.Types.Docker

-- | Docker configuration.
data DockerOpts
DockerOpts :: !Bool -> !String -> !Bool -> !(Maybe String) -> !(Maybe String) -> !Bool -> !Bool -> !Bool -> !(Maybe String) -> ![String] -> ![Mount] -> !Bool -> !(Path Abs File) -> DockerOpts

-- | Is using Docker enabled?
dockerEnable :: DockerOpts -> !Bool

-- | Exact Docker image tag or ID. Overrides docker-repo-*/tag.
dockerImage :: DockerOpts -> !String

-- | Does registry require login for pulls?
dockerRegistryLogin :: DockerOpts -> !Bool

-- | Optional username for Docker registry.
dockerRegistryUsername :: DockerOpts -> !(Maybe String)

-- | Optional password for Docker registry.
dockerRegistryPassword :: DockerOpts -> !(Maybe String)

-- | Automatically pull new images.
dockerAutoPull :: DockerOpts -> !Bool

-- | Whether to run a detached container
dockerDetach :: DockerOpts -> !Bool

-- | Create a persistent container (don't remove it when finished). Implied
--   by <a>dockerDetach</a>.
dockerPersist :: DockerOpts -> !Bool

-- | Container name to use, only makes sense from command-line with
--   <a>dockerPersist</a> or <a>dockerDetach</a>.
dockerContainerName :: DockerOpts -> !(Maybe String)

-- | Arguments to pass directly to <tt>docker run</tt>.
dockerRunArgs :: DockerOpts -> ![String]

-- | Volumes to mount in the container.
dockerMount :: DockerOpts -> ![Mount]

-- | Pass Docker daemon connection information into container.
dockerPassHost :: DockerOpts -> !Bool

-- | Location of image usage database.
dockerDatabasePath :: DockerOpts -> !(Path Abs File)

-- | An uninterpreted representation of docker options. Configurations may
--   be "cascaded" using mappend (left-biased).
data DockerOptsMonoid
DockerOptsMonoid :: !(Maybe Bool) -> !(Maybe Bool) -> !(Maybe DockerMonoidRepoOrImage) -> !(Maybe Bool) -> !(Maybe String) -> !(Maybe String) -> !(Maybe Bool) -> !(Maybe Bool) -> !(Maybe Bool) -> !(Maybe String) -> ![String] -> ![Mount] -> !(Maybe Bool) -> !(Maybe String) -> DockerOptsMonoid

-- | Does a <tt>docker:</tt> section exist in the top-level (usually
--   project) config?
dockerMonoidExists :: DockerOptsMonoid -> !(Maybe Bool)

-- | Is using Docker enabled?
dockerMonoidEnable :: DockerOptsMonoid -> !(Maybe Bool)

-- | Docker repository name (e.g. <tt>fpco/stack-build</tt> or
--   <tt>fpco/stack-full:lts-2.8</tt>)
dockerMonoidRepoOrImage :: DockerOptsMonoid -> !(Maybe DockerMonoidRepoOrImage)

-- | Does registry require login for pulls?
dockerMonoidRegistryLogin :: DockerOptsMonoid -> !(Maybe Bool)

-- | Optional username for Docker registry.
dockerMonoidRegistryUsername :: DockerOptsMonoid -> !(Maybe String)

-- | Optional password for Docker registry.
dockerMonoidRegistryPassword :: DockerOptsMonoid -> !(Maybe String)

-- | Automatically pull new images.
dockerMonoidAutoPull :: DockerOptsMonoid -> !(Maybe Bool)

-- | Whether to run a detached container
dockerMonoidDetach :: DockerOptsMonoid -> !(Maybe Bool)

-- | Create a persistent container (don't remove it when finished). Implied
--   by <a>dockerDetach</a>.
dockerMonoidPersist :: DockerOptsMonoid -> !(Maybe Bool)

-- | Container name to use, only makes sense from command-line with
--   <a>dockerPersist</a> or <a>dockerDetach</a>.
dockerMonoidContainerName :: DockerOptsMonoid -> !(Maybe String)

-- | Arguments to pass directly to <tt>docker run</tt>
dockerMonoidRunArgs :: DockerOptsMonoid -> ![String]

-- | Volumes to mount in the container
dockerMonoidMount :: DockerOptsMonoid -> ![Mount]

-- | Pass Docker daemon connection information into container.
dockerMonoidPassHost :: DockerOptsMonoid -> !(Maybe Bool)

-- | Location of image usage database.
dockerMonoidDatabasePath :: DockerOptsMonoid -> !(Maybe String)

-- | Decode uninterpreted docker options from JSON/YAML.

-- | Left-biased combine Docker options

-- | Docker volume mount.
data Mount
Mount :: String -> String -> Mount

-- | For optparse-applicative.

-- | Show instance.

-- | For YAML.

-- | Options for Docker repository or image.
data DockerMonoidRepoOrImage
DockerMonoidRepo :: String -> DockerMonoidRepoOrImage
DockerMonoidImage :: String -> DockerMonoidRepoOrImage

-- | Docker enable argument name.
dockerEnableArgName :: Text

-- | Docker repo arg argument name.
dockerRepoArgName :: Text

-- | Docker image argument name.
dockerImageArgName :: Text

-- | Docker registry login argument name.
dockerRegistryLoginArgName :: Text

-- | Docker registry username argument name.
dockerRegistryUsernameArgName :: Text

-- | Docker registry password argument name.
dockerRegistryPasswordArgName :: Text

-- | Docker auto-pull argument name.
dockerAutoPullArgName :: Text

-- | Docker detach argument name.
dockerDetachArgName :: Text

-- | Docker run args argument name.
dockerRunArgsArgName :: Text

-- | Docker mount argument name.
dockerMountArgName :: Text

-- | Docker container name argument name.
dockerContainerNameArgName :: Text

-- | Docker persist argument name.
dockerPersistArgName :: Text

-- | Docker pass host argument name.
dockerPassHostArgName :: Text

-- | Docker database path argument name.
dockerDatabasePathArgName :: Text
instance Show DockerOpts
instance Show DockerMonoidRepoOrImage
instance Show DockerOptsMonoid
instance FromJSON Mount
instance Show Mount
instance Read Mount
instance Monoid DockerOptsMonoid
instance FromJSON DockerOptsMonoid


-- | Names for flags.
module Stack.Types.FlagName

-- | A flag name.
data FlagName

-- | A parse fail.
data FlagNameParseFail
FlagNameParseFail :: ByteString -> FlagNameParseFail

-- | Attoparsec parser for a flag name from bytestring.
flagNameParser :: Parser FlagName

-- | Convenient way to parse a flag name from a bytestring.
parseFlagName :: MonadThrow m => ByteString -> m FlagName

-- | Migration function.
parseFlagNameFromString :: MonadThrow m => String -> m FlagName

-- | Produce a string representation of a flag name.
flagNameString :: FlagName -> String

-- | Produce a string representation of a flag name.
flagNameText :: FlagName -> Text

-- | Convert from a Cabal flag name.
fromCabalFlagName :: FlagName -> FlagName

-- | Convert to a Cabal flag name.
toCabalFlagName :: FlagName -> FlagName

-- | Make a flag name.
mkFlagName :: String -> Q Exp
instance Typeable FlagNameParseFail
instance Typeable FlagName
instance Eq FlagName
instance Ord FlagName
instance Data FlagName
instance Generic FlagName
instance Hashable FlagName
instance Binary FlagName
instance Datatype D1FlagName
instance Constructor C1_0FlagName
instance FromJSON a => FromJSON (Map FlagName a)
instance ToJSON a => ToJSON (Map FlagName a)
instance FromJSON FlagName
instance Show FlagName
instance Lift FlagName
instance Show FlagNameParseFail
instance Exception FlagNameParseFail


-- | Versions for packages.
module Stack.Types.Version

-- | A package version.
data Version
data VersionRange :: *

-- | The first two components of a version.
data MajorVersion
MajorVersion :: !Word -> !Word -> MajorVersion

-- | Returns the first two components, defaulting to 0 if not present
getMajorVersion :: Version -> MajorVersion

-- | Convert a two-component version into a <tt>Version</tt>
fromMajorVersion :: MajorVersion -> Version

-- | Parse major version from <tt>String</tt>
parseMajorVersionFromString :: MonadThrow m => String -> m MajorVersion

-- | Attoparsec parser for a package version from bytestring.
versionParser :: Parser Version

-- | Convenient way to parse a package version from a bytestring.
parseVersion :: MonadThrow m => ByteString -> m Version

-- | Migration function.
parseVersionFromString :: MonadThrow m => String -> m Version

-- | Get a string representation of a package version.
versionString :: Version -> String

-- | Get a string representation of a package version.
versionText :: Version -> Text

-- | Convert to a Cabal version.
toCabalVersion :: Version -> Version

-- | Convert from a Cabal version.
fromCabalVersion :: Version -> Version

-- | Make a package version.
mkVersion :: String -> Q Exp

-- | Display a version range
versionRangeText :: VersionRange -> Text

-- | Check if a version is within a version range.
withinRange :: Version -> VersionRange -> Bool
instance Typeable Version
instance Typeable VersionParseFail
instance Typeable MajorVersion
instance Eq Version
instance Ord Version
instance Data Version
instance Generic Version
instance Binary Version
instance NFData Version
instance Eq MajorVersion
instance Ord MajorVersion
instance Datatype D1Version
instance Constructor C1_0Version
instance Selector S1_0_0Version
instance FromJSON Version
instance ToJSON Version
instance Show Version
instance Lift Version
instance Hashable Version
instance FromJSON a => FromJSON (Map MajorVersion a)
instance FromJSON MajorVersion
instance ToJSON MajorVersion
instance Show MajorVersion
instance Show VersionParseFail
instance Exception VersionParseFail


-- | Package identifier (name-version).
module Stack.Types.PackageIdentifier

-- | A pkg-ver combination.
data PackageIdentifier
PackageIdentifier :: !PackageName -> !Version -> PackageIdentifier

-- | Convert from a package identifier to a tuple.
toTuple :: PackageIdentifier -> (PackageName, Version)

-- | Convert from a tuple to a package identifier.
fromTuple :: (PackageName, Version) -> PackageIdentifier

-- | Convenient way to parse a package identifier from a bytestring.
parsePackageIdentifier :: MonadThrow m => ByteString -> m PackageIdentifier

-- | Migration function.
parsePackageIdentifierFromString :: MonadThrow m => String -> m PackageIdentifier

-- | Get the version part of the identifier.
packageIdentifierVersion :: PackageIdentifier -> Version

-- | Get the name part of the identifier.
packageIdentifierName :: PackageIdentifier -> PackageName

-- | A parser for a package-version pair.
packageIdentifierParser :: Parser PackageIdentifier

-- | Get a string representation of the package identifier; name-ver.
packageIdentifierString :: PackageIdentifier -> String

-- | Get a Text representation of the package identifier; name-ver.
packageIdentifierText :: PackageIdentifier -> Text
instance Typeable PackageIdentifierParseFail
instance Typeable PackageIdentifier
instance Eq PackageIdentifier
instance Ord PackageIdentifier
instance Generic PackageIdentifier
instance Data PackageIdentifier
instance Datatype D1PackageIdentifier
instance Constructor C1_0PackageIdentifier
instance FromJSON PackageIdentifier
instance ToJSON PackageIdentifier
instance Show PackageIdentifier
instance Binary PackageIdentifier
instance Hashable PackageIdentifier
instance NFData PackageIdentifier
instance Exception PackageIdentifierParseFail
instance Show PackageIdentifierParseFail


-- | A ghc-pkg id.
module Stack.Types.GhcPkgId

-- | A ghc-pkg package identifier.
data GhcPkgId

-- | A parser for a package-version-hash pair.
ghcPkgIdParser :: Parser GhcPkgId

-- | Convenient way to parse a package name from a bytestring.
parseGhcPkgId :: MonadThrow m => ByteString -> m GhcPkgId

-- | Get a string representation of GHC package id.
ghcPkgIdString :: GhcPkgId -> String

-- | Get the package identifier of the GHC package id.
ghcPkgIdPackageIdentifier :: GhcPkgId -> PackageIdentifier
instance Typeable GhcPkgIdParseFail
instance Typeable GhcPkgId
instance Eq GhcPkgId
instance Ord GhcPkgId
instance Data GhcPkgId
instance Generic GhcPkgId
instance Datatype D1GhcPkgId
instance Constructor C1_0GhcPkgId
instance ToJSON GhcPkgId
instance FromJSON GhcPkgId
instance Show GhcPkgId
instance Binary GhcPkgId
instance Hashable GhcPkgId
instance Exception GhcPkgIdParseFail
instance Show GhcPkgIdParseFail


-- | Shared types for various stackage packages.
module Stack.Types.BuildPlan
data BuildPlan
BuildPlan :: SystemInfo -> Vector (PackageName, Version) -> Map PackageName PackagePlan -> Map Text (Set Text) -> BuildPlan
bpSystemInfo :: BuildPlan -> SystemInfo
bpTools :: BuildPlan -> Vector (PackageName, Version)
bpPackages :: BuildPlan -> Map PackageName PackagePlan
bpGithubUsers :: BuildPlan -> Map Text (Set Text)
data PackagePlan
PackagePlan :: Version -> Set Text -> Set PackageName -> PackageConstraints -> SimpleDesc -> PackagePlan
ppVersion :: PackagePlan -> Version
ppGithubPings :: PackagePlan -> Set Text
ppUsers :: PackagePlan -> Set PackageName
ppConstraints :: PackagePlan -> PackageConstraints
ppDesc :: PackagePlan -> SimpleDesc
data PackageConstraints
PackageConstraints :: VersionRange -> Maybe Maintainer -> TestState -> TestState -> Bool -> Map FlagName Bool -> Bool -> PackageConstraints
pcVersionRange :: PackageConstraints -> VersionRange
pcMaintainer :: PackageConstraints -> Maybe Maintainer
pcTests :: PackageConstraints -> TestState
pcHaddocks :: PackageConstraints -> TestState
pcBuildBenchmarks :: PackageConstraints -> Bool
pcFlagOverrides :: PackageConstraints -> Map FlagName Bool
pcEnableLibProfile :: PackageConstraints -> Bool
data TestState
ExpectSuccess :: TestState
ExpectFailure :: TestState

-- | when the test suite will pull in things we don't want
Don'tBuild :: TestState
data SystemInfo
SystemInfo :: Version -> OS -> Arch -> Map PackageName Version -> Set ExeName -> SystemInfo
siGhcVersion :: SystemInfo -> Version
siOS :: SystemInfo -> OS
siArch :: SystemInfo -> Arch
siCorePackages :: SystemInfo -> Map PackageName Version
siCoreExecutables :: SystemInfo -> Set ExeName
newtype Maintainer
Maintainer :: Text -> Maintainer
unMaintainer :: Maintainer -> Text

-- | Name of an executable.
newtype ExeName
ExeName :: ByteString -> ExeName
unExeName :: ExeName -> ByteString

-- | A simplified package description that tracks:
--   
--   <ul>
--   <li>Package dependencies</li>
--   <li>Build tool dependencies</li>
--   <li>Provided executables</li>
--   </ul>
--   
--   It has fully resolved all conditionals
data SimpleDesc
SimpleDesc :: Map PackageName DepInfo -> Map ExeName DepInfo -> Set ExeName -> Set Text -> SimpleDesc
sdPackages :: SimpleDesc -> Map PackageName DepInfo
sdTools :: SimpleDesc -> Map ExeName DepInfo
sdProvidedExes :: SimpleDesc -> Set ExeName

-- | modules exported by the library
sdModules :: SimpleDesc -> Set Text
data DepInfo
DepInfo :: Set Component -> VersionRange -> DepInfo
diComponents :: DepInfo -> Set Component
diRange :: DepInfo -> VersionRange
data Component
CompLibrary :: Component
CompExecutable :: Component
CompTestSuite :: Component
CompBenchmark :: Component

-- | The name of an LTS Haskell or Stackage Nightly snapshot.
data SnapName
LTS :: !Int -> !Int -> SnapName
Nightly :: !Day -> SnapName

-- | A simplified version of the <a>BuildPlan</a> + cabal file.
data MiniBuildPlan
MiniBuildPlan :: !Version -> !(Map PackageName MiniPackageInfo) -> MiniBuildPlan
mbpGhcVersion :: MiniBuildPlan -> !Version
mbpPackages :: MiniBuildPlan -> !(Map PackageName MiniPackageInfo)

-- | Information on a single package for the <a>MiniBuildPlan</a>.
data MiniPackageInfo
MiniPackageInfo :: !Version -> !(Map FlagName Bool) -> !(Set PackageName) -> !(Set ByteString) -> !(Set ExeName) -> !Bool -> MiniPackageInfo
mpiVersion :: MiniPackageInfo -> !Version
mpiFlags :: MiniPackageInfo -> !(Map FlagName Bool)
mpiPackageDeps :: MiniPackageInfo -> !(Set PackageName)

-- | Due to ambiguity in Cabal, it is unclear whether this refers to the
--   executable name, the package name, or something else. We have to guess
--   based on what's available, which is why we store this is an unwrapped
--   <a>ByteString</a>.
mpiToolDeps :: MiniPackageInfo -> !(Set ByteString)

-- | Executables provided by this package
mpiExes :: MiniPackageInfo -> !(Set ExeName)

-- | Is there a library present?
mpiHasLibrary :: MiniPackageInfo -> !Bool

-- | Convert a <a>SnapName</a> into its short representation, e.g.
--   <tt>lts-2.8</tt>, <tt>nightly-2015-03-05</tt>.
renderSnapName :: SnapName -> Text

-- | Parse the short representation of a <a>SnapName</a>.
parseSnapName :: MonadThrow m => Text -> m SnapName
instance Typeable BuildPlanTypesException
instance Show SnapName
instance Eq SnapName
instance Ord SnapName
instance Show TestState
instance Eq TestState
instance Ord TestState
instance Bounded TestState
instance Enum TestState
instance Show Maintainer
instance Eq Maintainer
instance Ord Maintainer
instance Hashable Maintainer
instance ToJSON Maintainer
instance FromJSON Maintainer
instance IsString Maintainer
instance Show PackageConstraints
instance Eq PackageConstraints
instance Show ExeName
instance Eq ExeName
instance Ord ExeName
instance Hashable ExeName
instance IsString ExeName
instance Generic ExeName
instance Show SystemInfo
instance Eq SystemInfo
instance Ord SystemInfo
instance Show Component
instance Read Component
instance Eq Component
instance Ord Component
instance Enum Component
instance Bounded Component
instance Show DepInfo
instance Eq DepInfo
instance Show SimpleDesc
instance Eq SimpleDesc
instance Show PackagePlan
instance Eq PackagePlan
instance Show BuildPlan
instance Eq BuildPlan
instance Generic MiniPackageInfo
instance Show MiniPackageInfo
instance Eq MiniPackageInfo
instance Generic MiniBuildPlan
instance Show MiniBuildPlan
instance Eq MiniBuildPlan
instance Datatype D1ExeName
instance Constructor C1_0ExeName
instance Selector S1_0_0ExeName
instance Datatype D1MiniPackageInfo
instance Constructor C1_0MiniPackageInfo
instance Selector S1_0_0MiniPackageInfo
instance Selector S1_0_1MiniPackageInfo
instance Selector S1_0_2MiniPackageInfo
instance Selector S1_0_3MiniPackageInfo
instance Selector S1_0_4MiniPackageInfo
instance Selector S1_0_5MiniPackageInfo
instance Datatype D1MiniBuildPlan
instance Constructor C1_0MiniBuildPlan
instance Selector S1_0_0MiniBuildPlan
instance Selector S1_0_1MiniBuildPlan
instance Binary MiniPackageInfo
instance BinarySchema MiniBuildPlan
instance Binary MiniBuildPlan
instance FromJSON a => FromJSON (Map ExeName a)
instance ToJSON a => ToJSON (Map ExeName a)
instance FromJSON Component
instance ToJSON Component
instance FromJSON DepInfo
instance ToJSON DepInfo
instance Monoid DepInfo
instance FromJSON SimpleDesc
instance ToJSON SimpleDesc
instance Monoid SimpleDesc
instance FromJSON ExeName
instance ToJSON ExeName
instance Binary ExeName
instance FromJSON SystemInfo
instance ToJSON SystemInfo
instance FromJSON TestState
instance ToJSON TestState
instance FromJSON PackageConstraints
instance ToJSON PackageConstraints
instance Show BuildPlanTypesException
instance Exception BuildPlanTypesException
instance FromJSON PackagePlan
instance ToJSON PackagePlan
instance FromJSON BuildPlan
instance ToJSON BuildPlan


-- | The Config type.
module Stack.Types.Config

-- | The top-level Stackage configuration.
data Config
Config :: !(Path Abs Dir) -> !DockerOpts -> !(EnvSettings -> IO EnvOverride) -> !(Path Abs Dir) -> !Int -> !Bool -> !Platform -> !Text -> ![PackageIndex] -> !Bool -> !Bool -> !(Path Abs Dir) -> !VersionRange -> !Int -> !(Set Text) -> !(Set Text) -> Config

-- | ~/.stack more often than not
configStackRoot :: Config -> !(Path Abs Dir)
configDocker :: Config -> !DockerOpts

-- | Environment variables to be passed to external tools
configEnvOverride :: Config -> !(EnvSettings -> IO EnvOverride)

-- | Path containing local installations (mainly GHC)
configLocalPrograms :: Config -> !(Path Abs Dir)

-- | How many concurrent connections are allowed when downloading
configConnectionCount :: Config -> !Int

-- | Hide the Template Haskell "Loading package ..." messages from the
--   console
configHideTHLoading :: Config -> !Bool

-- | The platform we're building for, used in many directory names
configPlatform :: Config -> !Platform

-- | URL for a JSON file containing information on the latest snapshots
--   available.
configLatestSnapshotUrl :: Config -> !Text

-- | Information on package indices. This is left biased, meaning that
--   packages in an earlier index will shadow those in a later index.
--   
--   Warning: if you override packages in an index vs what's available
--   upstream, you may correct your compiled snapshots, as different
--   projects may have different definitions of what pkg-ver means! This
--   feature is primarily intended for adding local packages, not
--   overriding. Overriding is better accomplished by adding to your list
--   of packages.
--   
--   Note that indices specified in a later config file will override
--   previous indices, <i>not</i> extend them.
--   
--   Using an assoc list instead of a Map to keep track of priority
configPackageIndices :: Config -> ![PackageIndex]

-- | Should we use the system-installed GHC (on the PATH) if available? Can
--   be overridden by command line options.
configSystemGHC :: Config -> !Bool

-- | Should we automatically install GHC if missing or the wrong version is
--   available? Can be overridden by command line options.
configInstallGHC :: Config -> !Bool

-- | Directory we should install executables into
configLocalBin :: Config -> !(Path Abs Dir)

-- | Require a version of stack within this range.
configRequireStackVersion :: Config -> !VersionRange

-- | How many concurrent jobs to run, defaults to number of capabilities
configJobs :: Config -> !Int

-- | <ul>
--   <li>-extra-include-dirs arguments</li>
--   </ul>
configExtraIncludeDirs :: Config -> !(Set Text)

-- | <ul>
--   <li>-extra-lib-dirs arguments</li>
--   </ul>
configExtraLibDirs :: Config -> !(Set Text)

-- | Information on a single package index
data PackageIndex
PackageIndex :: !IndexName -> !IndexLocation -> !Text -> !Bool -> !Bool -> PackageIndex
indexName :: PackageIndex -> !IndexName
indexLocation :: PackageIndex -> !IndexLocation

-- | URL prefix for downloading packages
indexDownloadPrefix :: PackageIndex -> !Text

-- | GPG-verify the package index during download. Only applies to Git
--   repositories for now.
indexGpgVerify :: PackageIndex -> !Bool

-- | Require that hashes and package size information be available for
--   packages in this index
indexRequireHashes :: PackageIndex -> !Bool

-- | Unique name for a package index
newtype IndexName
IndexName :: ByteString -> IndexName
unIndexName :: IndexName -> ByteString
indexNameText :: IndexName -> Text

-- | Location of the package index. This ensures that at least one of Git
--   or HTTP is available.
data IndexLocation
ILGit :: !Text -> IndexLocation
ILHttp :: !Text -> IndexLocation
ILGitHttp :: !Text -> !Text -> IndexLocation

-- | Controls which version of the environment is used
data EnvSettings
EnvSettings :: !Bool -> !Bool -> EnvSettings

-- | include local project bin directory, GHC_PACKAGE_PATH, etc
esIncludeLocals :: EnvSettings -> !Bool

-- | include the GHC_PACKAGE_PATH variable
esIncludeGhcPackagePath :: EnvSettings -> !Bool

-- | A superset of <a>Config</a> adding information on how to build code.
--   The reason for this breakdown is because we will need some of the
--   information from <a>Config</a> in order to determine the values here.
data BuildConfig
BuildConfig :: !Config -> !Resolver -> !Version -> !(Map (Path Abs Dir) Bool) -> !(Map PackageName Version) -> !(Path Abs Dir) -> !(Path Abs File) -> !(Map PackageName (Map FlagName Bool)) -> BuildConfig
bcConfig :: BuildConfig -> !Config

-- | How we resolve which dependencies to install given a set of packages.
bcResolver :: BuildConfig -> !Resolver

-- | Version of GHC we expected for this build
bcGhcVersionExpected :: BuildConfig -> !Version

-- | Local packages identified by a path, Bool indicates whether it is a
--   non-dependency (the opposite of <a>peExtraDep</a>)
bcPackages :: BuildConfig -> !(Map (Path Abs Dir) Bool)

-- | Extra dependencies specified in configuration.
--   
--   These dependencies will not be installed to a shared location, and
--   will override packages provided by the resolver.
bcExtraDeps :: BuildConfig -> !(Map PackageName Version)

-- | Directory containing the project's stack.yaml file
bcRoot :: BuildConfig -> !(Path Abs Dir)

-- | Location of the stack.yaml file.
--   
--   Note: if the STACK_YAML environment variable is used, this may be
--   different from bcRoot <a>/</a> "stack.yaml"
bcStackYaml :: BuildConfig -> !(Path Abs File)

-- | Per-package flag overrides
bcFlags :: BuildConfig -> !(Map PackageName (Map FlagName Bool))

-- | Configuration after the environment has been setup.
data EnvConfig
EnvConfig :: !BuildConfig -> !Version -> !Version -> EnvConfig
envConfigBuildConfig :: EnvConfig -> !BuildConfig
envConfigCabalVersion :: EnvConfig -> !Version
envConfigGhcVersion :: EnvConfig -> !Version
class HasBuildConfig r => HasEnvConfig r
getEnvConfig :: HasEnvConfig r => r -> EnvConfig

-- | Value returned by <a>loadConfig</a>.
data LoadConfig m
LoadConfig :: !Config -> !(Maybe Resolver -> NoBuildConfigStrategy -> m BuildConfig) -> !(Maybe (Path Abs Dir)) -> LoadConfig m

-- | Top-level Stack configuration.
lcConfig :: LoadConfig m -> !Config

-- | Action to load the remaining <a>BuildConfig</a>.
lcLoadBuildConfig :: LoadConfig m -> !(Maybe Resolver -> NoBuildConfigStrategy -> m BuildConfig)

-- | The project root directory, if in a project.
lcProjectRoot :: LoadConfig m -> !(Maybe (Path Abs Dir))
data NoBuildConfigStrategy
ThrowException :: NoBuildConfigStrategy
ExecStrategy :: NoBuildConfigStrategy
data PackageEntry
PackageEntry :: !(Maybe Bool) -> !(Maybe Bool) -> !PackageLocation -> ![FilePath] -> PackageEntry

-- | Is this package a dependency? This means the local package will be
--   treated just like an extra-deps: it will only be built as a dependency
--   for others, and its test suite/benchmarks will not be run.
--   
--   Useful modifying an upstream package, see:
--   https:/<i>github.com</i>commercialhaskell<i>stack</i>issues/219
--   https:/<i>github.com</i>commercialhaskell<i>stack</i>issues/386
peExtraDepMaybe :: PackageEntry -> !(Maybe Bool)

-- | Deprecated name meaning the opposite of peExtraDep. Only present to
--   provide deprecation warnings to users.
peValidWanted :: PackageEntry -> !(Maybe Bool)
peLocation :: PackageEntry -> !PackageLocation
peSubdirs :: PackageEntry -> ![FilePath]

-- | Once peValidWanted is removed, this should just become the field name
--   in PackageEntry.
peExtraDep :: PackageEntry -> Bool
data PackageLocation

-- | Note that we use <tt>FilePath</tt> and not <tt>Path</tt>s. The goal
--   is: first parse the value raw, and then use <tt>canonicalizePath</tt>
--   and <tt>parseAbsDir</tt>.
PLFilePath :: FilePath -> PackageLocation
PLHttpTarball :: Text -> PackageLocation

-- | URL and commit
PLGit :: Text -> Text -> PackageLocation

-- | A project is a collection of packages. We can have multiple stack.yaml
--   files, but only one of them may contain project information.
data Project
Project :: ![PackageEntry] -> !(Map PackageName Version) -> !(Map PackageName (Map FlagName Bool)) -> !Resolver -> Project

-- | Components of the package list
projectPackages :: Project -> ![PackageEntry]

-- | Components of the package list referring to package/version combos,
--   see: https:/<i>github.com</i>fpco<i>stack</i>issues/41
projectExtraDeps :: Project -> !(Map PackageName Version)

-- | Per-package flag overrides
projectFlags :: Project -> !(Map PackageName (Map FlagName Bool))

-- | How we resolve which dependencies to use
projectResolver :: Project -> !Resolver

-- | How we resolve which dependencies to install given a set of packages.
data Resolver

-- | Use an official snapshot from the Stackage project, either an LTS
--   Haskell or Stackage Nightly
ResolverSnapshot :: SnapName -> Resolver

-- | Require a specific GHC major version, but otherwise provide no build
--   plan. Intended for use cases where end user wishes to specify all
--   upstream dependencies manually, such as using a dependency solver.
ResolverGhc :: {-# UNPACK #-} !MajorVersion -> Resolver

-- | Convert a Resolver into its <tt>Text</tt> representation, as will be
--   used by JSON/YAML
renderResolver :: Resolver -> Text

-- | Try to parse a <tt>Resolver</tt>, using same format as
--   JSON<i>YAML</i><a>renderResolver</a>
parseResolver :: MonadThrow m => Text -> m Resolver

-- | Class for environment values which have access to the stack root
class HasStackRoot env where getStackRoot = configStackRoot . getConfig
getStackRoot :: HasStackRoot env => env -> Path Abs Dir

-- | Class for environment values which have a Platform
class HasPlatform env where getPlatform = configPlatform . getConfig
getPlatform :: HasPlatform env => env -> Platform

-- | Class for environment values that can provide a <a>Config</a>.
class (HasStackRoot env, HasPlatform env) => HasConfig env where getConfig = bcConfig . getBuildConfig
getConfig :: HasConfig env => env -> Config

-- | Class for environment values that can provide a <a>BuildConfig</a>.
class HasConfig env => HasBuildConfig env
getBuildConfig :: HasBuildConfig env => env -> BuildConfig
data ConfigMonoid
ConfigMonoid :: !DockerOptsMonoid -> !(Maybe Int) -> !(Maybe Bool) -> !(Maybe Text) -> !(Maybe [PackageIndex]) -> !(Maybe Bool) -> !(Maybe Bool) -> !VersionRange -> !(Maybe String) -> !(Maybe String) -> !(Maybe Int) -> !(Set Text) -> !(Set Text) -> ConfigMonoid

-- | Docker options.
configMonoidDockerOpts :: ConfigMonoid -> !DockerOptsMonoid

-- | See: <a>configConnectionCount</a>
configMonoidConnectionCount :: ConfigMonoid -> !(Maybe Int)

-- | See: <a>configHideTHLoading</a>
configMonoidHideTHLoading :: ConfigMonoid -> !(Maybe Bool)

-- | See: <a>configLatestSnapshotUrl</a>
configMonoidLatestSnapshotUrl :: ConfigMonoid -> !(Maybe Text)

-- | See: <a>configPackageIndices</a>
configMonoidPackageIndices :: ConfigMonoid -> !(Maybe [PackageIndex])

-- | See: <a>configSystemGHC</a>
configMonoidSystemGHC :: ConfigMonoid -> !(Maybe Bool)

-- | See: <a>configInstallGHC</a>
configMonoidInstallGHC :: ConfigMonoid -> !(Maybe Bool)

-- | See: <a>configRequireStackVersion</a>
configMonoidRequireStackVersion :: ConfigMonoid -> !VersionRange

-- | Used for overriding the platform
configMonoidOS :: ConfigMonoid -> !(Maybe String)

-- | Used for overriding the platform
configMonoidArch :: ConfigMonoid -> !(Maybe String)

-- | See: <a>configJobs</a>
configMonoidJobs :: ConfigMonoid -> !(Maybe Int)

-- | See: <a>configExtraIncludeDirs</a>
configMonoidExtraIncludeDirs :: ConfigMonoid -> !(Set Text)

-- | See: <a>configExtraLibDirs</a>
configMonoidExtraLibDirs :: ConfigMonoid -> !(Set Text)

-- | Newtype for non-orphan FromJSON instance.
newtype VersionRangeJSON
VersionRangeJSON :: VersionRange -> VersionRangeJSON
unVersionRangeJSON :: VersionRangeJSON -> VersionRange

-- | Parse VersionRange.
data ConfigException
ParseConfigFileException :: (Path Abs File) -> ParseException -> ConfigException
ParseResolverException :: Text -> ConfigException
NoProjectConfigFound :: (Path Abs Dir) -> (Maybe Text) -> ConfigException
UnexpectedTarballContents :: [Path Abs Dir] -> [Path Abs File] -> ConfigException
BadStackVersionException :: VersionRange -> ConfigException
NoMatchingSnapshot :: [SnapName] -> ConfigException

-- | Helper function to ask the environment and apply getConfig
askConfig :: (MonadReader env m, HasConfig env) => m Config

-- | Get the URL to request the information on the latest snapshots
askLatestSnapshotUrl :: (MonadReader env m, HasConfig env) => m Text

-- | Root for a specific package index
configPackageIndexRoot :: (MonadReader env m, HasConfig env, MonadThrow m) => IndexName -> m (Path Abs Dir)

-- | Location of the 00-index.cache file
configPackageIndexCache :: (MonadReader env m, HasConfig env, MonadThrow m) => IndexName -> m (Path Abs File)

-- | Location of the 00-index.tar file
configPackageIndex :: (MonadReader env m, HasConfig env, MonadThrow m) => IndexName -> m (Path Abs File)

-- | Location of the 00-index.tar.gz file
configPackageIndexGz :: (MonadReader env m, HasConfig env, MonadThrow m) => IndexName -> m (Path Abs File)

-- | Location of a package tarball
configPackageTarball :: (MonadReader env m, HasConfig env, MonadThrow m) => IndexName -> PackageIdentifier -> m (Path Abs File)
workDirRel :: Path Rel Dir

-- | Per-project work dir
configProjectWorkDir :: (HasBuildConfig env, MonadReader env m) => m (Path Abs Dir)

-- | File containing the installed cache, see <a>Stack.PackageDump</a>
configInstalledCache :: (HasBuildConfig env, MonadReader env m) => m (Path Abs File)

-- | Relative directory for the platform identifier
platformRelDir :: (MonadReader env m, HasPlatform env, MonadThrow m) => m (Path Rel Dir)

-- | Path to .shake files.
configShakeFilesDir :: (MonadReader env m, HasBuildConfig env) => m (Path Abs Dir)

-- | Where to unpack packages for local build
configLocalUnpackDir :: (MonadReader env m, HasBuildConfig env) => m (Path Abs Dir)

-- | Directory containing snapshots
snapshotsDir :: (MonadReader env m, HasConfig env, MonadThrow m) => m (Path Abs Dir)

-- | Installation root for dependencies
installationRootDeps :: (MonadThrow m, MonadReader env m, HasEnvConfig env) => m (Path Abs Dir)

-- | Installation root for locals
installationRootLocal :: (MonadThrow m, MonadReader env m, HasEnvConfig env) => m (Path Abs Dir)

-- | Package database for installing dependencies into
packageDatabaseDeps :: (MonadThrow m, MonadReader env m, HasEnvConfig env) => m (Path Abs Dir)

-- | Package database for installing local packages into
packageDatabaseLocal :: (MonadThrow m, MonadReader env m, HasEnvConfig env) => m (Path Abs Dir)

-- | Directory for holding flag cache information
flagCacheLocal :: (MonadThrow m, MonadReader env m, HasEnvConfig env) => m (Path Abs Dir)

-- | Where to store mini build plan caches
configMiniBuildPlanCache :: (MonadThrow m, MonadReader env m, HasStackRoot env, HasPlatform env) => SnapName -> m (Path Abs File)

-- | Suffix applied to an installation root to get the bin dir
bindirSuffix :: Path Rel Dir

-- | Suffix applied to an installation root to get the doc dir
docdirSuffix :: Path Rel Dir

-- | Get the extra bin directories (for the PATH). Puts more local first
--   
--   Bool indicates whether or not to include the locals
extraBinDirs :: (MonadThrow m, MonadReader env m, HasEnvConfig env) => m (Bool -> [Path Abs Dir])

-- | Get the minimal environment override, useful for just calling external
--   processes like git or ghc
getMinimalEnvOverride :: (MonadReader env m, HasConfig env, MonadIO m) => m EnvOverride
data ProjectAndConfigMonoid
ProjectAndConfigMonoid :: !Project -> !ConfigMonoid -> ProjectAndConfigMonoid

-- | A PackageEntry for the current directory, used as a default
packageEntryCurrDir :: PackageEntry
instance Typeable ConfigException
instance Show IndexName
instance Eq IndexName
instance Ord IndexName
instance Hashable IndexName
instance Binary IndexName
instance Show IndexLocation
instance Eq IndexLocation
instance Ord IndexLocation
instance Show PackageIndex
instance Show EnvSettings
instance Eq EnvSettings
instance Ord EnvSettings
instance Show NoBuildConfigStrategy
instance Eq NoBuildConfigStrategy
instance Ord NoBuildConfigStrategy
instance Show PackageLocation
instance Show PackageEntry
instance Show Resolver
instance Show Project
instance Show ConfigMonoid
instance FromJSON ProjectAndConfigMonoid
instance Exception ConfigException
instance Show ConfigException
instance FromJSON VersionRangeJSON
instance FromJSON ConfigMonoid
instance Monoid ConfigMonoid
instance HasBuildConfig BuildConfig
instance HasConfig BuildConfig
instance HasPlatform BuildConfig
instance HasStackRoot BuildConfig
instance HasConfig Config
instance HasPlatform Config
instance HasStackRoot Config
instance HasPlatform Platform
instance FromJSON Resolver
instance ToJSON Resolver
instance ToJSON Project
instance FromJSON PackageLocation
instance ToJSON PackageLocation
instance FromJSON PackageEntry
instance ToJSON PackageEntry
instance HasEnvConfig EnvConfig
instance HasStackRoot EnvConfig
instance HasPlatform EnvConfig
instance HasConfig EnvConfig
instance HasBuildConfig EnvConfig
instance FromJSON IndexName
instance ToJSON IndexName
instance FromJSON PackageIndex


-- | Constants used throughout the project.
module Stack.Constants

-- | The filename used for completed build indicators.
builtConfigFileFromDir :: (MonadThrow m, MonadReader env m, HasPlatform env, HasEnvConfig env) => Path Abs Dir -> m (Path Abs File)

-- | The filename used for completed build indicators.
builtFileFromDir :: (MonadThrow m, MonadReader env m, HasPlatform env, HasEnvConfig env) => Path Abs Dir -> m (Path Abs File)

-- | The filename used for completed configure indicators.
configuredFileFromDir :: (MonadThrow m, MonadReader env m, HasPlatform env, HasEnvConfig env) => Path Abs Dir -> m (Path Abs File)

-- | Default shake thread count for parallel builds.
defaultShakeThreads :: Int

-- | Package's build artifacts directory.
distDirFromDir :: (MonadThrow m, MonadReader env m, HasPlatform env, HasEnvConfig env) => Path Abs Dir -> m (Path Abs Dir)

-- | Relative location of build artifacts.
distRelativeDir :: (MonadThrow m, MonadReader env m, HasPlatform env, HasEnvConfig env) => m (Path Rel Dir)

-- | Extensions used for Haskell files.
haskellFileExts :: [Text]

-- | Docker sandbox from project root.
projectDockerSandboxDir :: Path Abs Dir -> Path Abs Dir

-- | Get a URL for a raw file on Github
rawGithubUrl :: Text -> Text -> Text -> Text -> Text

-- | The filename used for the stack config file.
stackDotYaml :: Path Rel File

-- | Environment variable used to override the '~/.stack' location.
stackRootEnvVar :: String

-- | User documentation directory.
userDocsDir :: Config -> Path Abs Dir

-- | The filename used for dirtiness check of config.
configCacheFile :: (MonadThrow m, MonadReader env m, HasPlatform env, HasEnvConfig env) => Path Abs Dir -> m (Path Abs File)

-- | The filename used for modification check of .cabal
configCabalMod :: (MonadThrow m, MonadReader env m, HasPlatform env, HasEnvConfig env) => Path Abs Dir -> m (Path Abs File)

-- | The filename used for dirtiness check of source files.
buildCacheFile :: (MonadThrow m, MonadReader env m, HasPlatform env, HasEnvConfig env) => Path Abs Dir -> m (Path Abs File)

-- | Name of the <tt>stack</tt> program.
stackProgName :: String
wiredInPackages :: HashSet PackageName

-- | Just to avoid repetition and magic strings.
cabalPackageName :: PackageName

-- | Implicit global directory used when outside of a project.
implicitGlobalDir :: Path Abs Dir -> Path Abs Dir

-- | Directory for HPC work.
hpcDirFromDir :: (MonadThrow m, MonadReader env m, HasPlatform env, HasEnvConfig env) => Path Abs Dir -> m (Path Abs Dir)

-- | Where .mix files go.
dotHpc :: Path Rel Dir


-- | All types.
module Stack.Types


-- | Dealing with Cabal.
module Stack.Package

-- | Reads and exposes the package information
readPackage :: (MonadLogger m, MonadIO m, MonadThrow m, MonadCatch m) => PackageConfig -> Path Abs File -> m Package

-- | Reads and exposes the package information, from a ByteString
readPackageBS :: MonadThrow m => PackageConfig -> ByteString -> m Package

-- | Convenience wrapper around <tt>readPackage</tt> that first finds the
--   cabal file in the given directory.
readPackageDir :: (MonadLogger m, MonadIO m, MonadThrow m, MonadCatch m) => PackageConfig -> Path Abs Dir -> m (Path Abs File, Package)

-- | Read the raw, unresolved package information.
readPackageUnresolved :: (MonadIO m, MonadThrow m) => Path Abs File -> m GenericPackageDescription

-- | Read the raw, unresolved package information from a ByteString.
readPackageUnresolvedBS :: MonadThrow m => Maybe (Path Abs File) -> ByteString -> m GenericPackageDescription

-- | Resolve a parsed cabal file into a <a>Package</a>.
resolvePackage :: PackageConfig -> GenericPackageDescription -> Package

-- | Get the filename for the cabal file in the given directory.
--   
--   If no .cabal file is present, or more than one is present, an
--   exception is thrown via <a>throwM</a>.
getCabalFileName :: (MonadThrow m, MonadIO m) => Path Abs Dir -> m (Path Abs File)

-- | Some package info.
data Package
Package :: !PackageName -> !Version -> !GetPackageFiles -> !(Map PackageName VersionRange) -> ![Dependency] -> !(Set PackageName) -> !(Map FlagName Bool) -> !Bool -> !(Set Text) -> !(Set Text) -> !(Set Text) -> !GetPackageOpts -> !Bool -> !Bool -> Package

-- | Name of the package.
packageName :: Package -> !PackageName

-- | Version of the package
packageVersion :: Package -> !Version
packageFiles :: Package -> !GetPackageFiles

-- | Packages that the package depends on.
packageDeps :: Package -> !(Map PackageName VersionRange)

-- | A build tool name.
packageTools :: Package -> ![Dependency]

-- | Original dependencies (not sieved).
packageAllDeps :: Package -> !(Set PackageName)

-- | Flags used on package.
packageFlags :: Package -> !(Map FlagName Bool)

-- | does the package have a buildable library stanza?
packageHasLibrary :: Package -> !Bool

-- | names of test suites
packageTests :: Package -> !(Set Text)

-- | names of benchmarks
packageBenchmarks :: Package -> !(Set Text)

-- | names of executables
packageExes :: Package -> !(Set Text)

-- | Args to pass to GHC.
packageOpts :: Package -> !GetPackageOpts

-- | Does the package have exposed modules?
packageHasExposedModules :: Package -> !Bool

-- | Does the package of build-type: Simple
packageSimpleType :: Package -> !Bool

-- | Files that the package depends on, relative to package directory.
--   Argument is the location of the .cabal file
newtype GetPackageFiles
GetPackageFiles :: (forall m. (MonadIO m, MonadLogger m, MonadThrow m, MonadCatch m) => CabalFileType -> Path Abs File -> m (Set (Path Abs File))) -> GetPackageFiles
getPackageFiles :: GetPackageFiles -> forall m. (MonadIO m, MonadLogger m, MonadThrow m, MonadCatch m) => CabalFileType -> Path Abs File -> m (Set (Path Abs File))

-- | Files that the package depends on, relative to package directory.
--   Argument is the location of the .cabal file
newtype GetPackageOpts
GetPackageOpts :: (forall env m. (MonadIO m, HasEnvConfig env, HasPlatform env, MonadThrow m, MonadReader env m) => Path Abs File -> m [String]) -> GetPackageOpts
getPackageOpts :: GetPackageOpts -> forall env m. (MonadIO m, HasEnvConfig env, HasPlatform env, MonadThrow m, MonadReader env m) => Path Abs File -> m [String]

-- | Package build configuration
data PackageConfig
PackageConfig :: !Bool -> !Bool -> !(Map FlagName Bool) -> !Version -> !Platform -> PackageConfig

-- | Are tests enabled?
packageConfigEnableTests :: PackageConfig -> !Bool

-- | Are benchmarks enabled?
packageConfigEnableBenchmarks :: PackageConfig -> !Bool

-- | Package config flags.
packageConfigFlags :: PackageConfig -> !(Map FlagName Bool)

-- | GHC version
packageConfigGhcVersion :: PackageConfig -> !Version

-- | host platform
packageConfigPlatform :: PackageConfig -> !Platform

-- | Path for the package's build log.
buildLogPath :: (MonadReader env m, HasBuildConfig env, MonadThrow m) => Package -> m (Path Abs File)

-- | All exceptions thrown by the library.
data PackageException
PackageInvalidCabalFile :: (Maybe (Path Abs File)) -> PError -> PackageException
PackageNoCabalFileFound :: (Path Abs Dir) -> PackageException
PackageMultipleCabalFilesFound :: (Path Abs Dir) -> [Path Abs File] -> PackageException
MismatchedCabalName :: (Path Abs File) -> PackageName -> PackageException

-- | Get all dependencies of a package, including library, executables,
--   tests, benchmarks.
resolvePackageDescription :: PackageConfig -> GenericPackageDescription -> PackageDescription

-- | Get all build tool dependencies of the package (buildable targets
--   only).
packageToolDependencies :: PackageDescription -> Map ByteString VersionRange

-- | Get all dependencies of the package (buildable targets only).
packageDependencies :: PackageDescription -> Map PackageName VersionRange

-- | Get the identifier of the package.
packageIdentifier :: Package -> PackageIdentifier

-- | Files to get for a cabal package.
data CabalFileType
AllFiles :: CabalFileType
Modules :: CabalFileType

-- | Make the autogen dir.
autogenDir :: Path Abs Dir -> Path Abs Dir
instance Typeable PackageException
instance Typeable PackageConfig
instance Typeable Package
instance Show PackageConfig
instance Show Package
instance Eq Package
instance Ord Package
instance Show GetPackageFiles
instance Show GetPackageOpts
instance Show PackageException
instance Exception PackageException


-- | Execute commands within the properly configured Stack environment.
module Stack.Exec

-- | Default <tt>EnvSettings</tt> which includes locals and
--   GHC_PACKAGE_PATH
defaultEnvSettings :: EnvSettings

-- | Execute a process within the Stack configured environment.
exec :: (HasConfig r, MonadReader r m, MonadIO m, MonadLogger m, MonadThrow m) => EnvSettings -> String -> [String] -> m b


-- | All data types.
module Stack.Build.Types
data StackBuildException
Couldn'tFindPkgId :: PackageName -> StackBuildException

-- | Path to the stack.yaml file
GHCVersionMismatch :: (Maybe (Version, Arch)) -> (Version, Arch) -> (Maybe (Path Abs File)) -> StackBuildException
Couldn'tParseTargets :: [Text] -> StackBuildException
UnknownTargets :: (Set PackageName) -> (Map PackageName Version) -> (Path Abs File) -> StackBuildException
TestSuiteFailure :: PackageIdentifier -> (Map Text (Maybe ExitCode)) -> (Maybe (Path Abs File)) -> ByteString -> StackBuildException
ConstructPlanExceptions :: [ConstructPlanException] -> (Path Abs File) -> StackBuildException
CabalExitedUnsuccessfully :: ExitCode -> PackageIdentifier -> (Path Abs File) -> [String] -> (Maybe (Path Abs File)) -> ByteString -> StackBuildException
ExecutionFailure :: [SomeException] -> StackBuildException

-- | A location to install a package into, either snapshot or local
data InstallLocation
Snap :: InstallLocation
Local :: InstallLocation

-- | Used for storage and comparison.
data ModTime

-- | One-way conversion to serialized time.
modTime :: UTCTime -> ModTime
data Installed
Library :: GhcPkgId -> Installed
Executable :: PackageIdentifier -> Installed

-- | Datatype which tells how which version of a package to install and
--   where to install it into
class PackageInstallInfo a
piiVersion :: PackageInstallInfo a => a -> Version
piiLocation :: PackageInstallInfo a => a -> InstallLocation

-- | A task to perform when building
data Task
Task :: !PackageIdentifier -> !TaskType -> !TaskConfigOpts -> !(Set GhcPkgId) -> Task

-- | the package/version to be built
taskProvides :: Task -> !PackageIdentifier

-- | the task type, telling us how to build this
taskType :: Task -> !TaskType
taskConfigOpts :: Task -> !TaskConfigOpts

-- | GhcPkgIds of already-installed dependencies
taskPresent :: Task -> !(Set GhcPkgId)

-- | Information on a locally available package of source code
data LocalPackage
LocalPackage :: !Package -> !Package -> !Bool -> !(Path Abs Dir) -> !(Path Abs File) -> !Bool -> !(Set Text) -> LocalPackage

-- | The <tt>Package</tt> info itself, after resolution with package flags,
--   not including any final actions
lpPackage :: LocalPackage -> !Package

-- | Same as lpPackage, but with any test suites or benchmarks enabled as
--   necessary
lpPackageFinal :: LocalPackage -> !Package

-- | Is this package a "wanted" target based on command line input
lpWanted :: LocalPackage -> !Bool

-- | Directory of the package.
lpDir :: LocalPackage -> !(Path Abs Dir)

-- | The .cabal file
lpCabalFile :: LocalPackage -> !(Path Abs File)

-- | are there files that have changed since the last build?
lpDirtyFiles :: LocalPackage -> !Bool

-- | components to build, passed directly to Setup.hs build
lpComponents :: LocalPackage -> !(Set Text)

-- | Basic information used to calculate what the configure options are
data BaseConfigOpts
BaseConfigOpts :: !(Path Abs Dir) -> !(Path Abs Dir) -> !(Path Abs Dir) -> !(Path Abs Dir) -> !BuildOpts -> BaseConfigOpts
bcoSnapDB :: BaseConfigOpts -> !(Path Abs Dir)
bcoLocalDB :: BaseConfigOpts -> !(Path Abs Dir)
bcoSnapInstallRoot :: BaseConfigOpts -> !(Path Abs Dir)
bcoLocalInstallRoot :: BaseConfigOpts -> !(Path Abs Dir)
bcoBuildOpts :: BaseConfigOpts -> !BuildOpts

-- | A complete plan of what needs to be built and how to do it
data Plan
Plan :: !(Map PackageName Task) -> !(Map PackageName Task) -> !(Map GhcPkgId Text) -> !(Map Text InstallLocation) -> Plan
planTasks :: Plan -> !(Map PackageName Task)

-- | Final actions to be taken (test, benchmark, etc)
planFinals :: Plan -> !(Map PackageName Task)

-- | Text is reason we're unregistering, for display only
planUnregisterLocal :: Plan -> !(Map GhcPkgId Text)

-- | Executables that should be installed after successful building
planInstallExes :: Plan -> !(Map Text InstallLocation)

-- | Run a Setup.hs action after building a package, before installing.
data FinalAction
DoTests :: FinalAction
DoBenchmarks :: FinalAction
DoNothing :: FinalAction

-- | Configuration for building.
data BuildOpts
BuildOpts :: ![Text] -> !Bool -> !Bool -> !(Maybe Bool) -> !Bool -> !(Maybe Bool) -> !FinalAction -> !Bool -> ![Text] -> !(Map (Maybe PackageName) (Map FlagName Bool)) -> !Bool -> !Bool -> ![String] -> !Bool -> !Bool -> BuildOpts
boptsTargets :: BuildOpts -> ![Text]
boptsLibProfile :: BuildOpts -> !Bool
boptsExeProfile :: BuildOpts -> !Bool
boptsEnableOptimizations :: BuildOpts -> !(Maybe Bool)

-- | Build haddocks?
boptsHaddock :: BuildOpts -> !Bool

-- | Build haddocks for dependencies?
boptsHaddockDeps :: BuildOpts -> !(Maybe Bool)
boptsFinalAction :: BuildOpts -> !FinalAction
boptsDryrun :: BuildOpts -> !Bool
boptsGhcOptions :: BuildOpts -> ![Text]
boptsFlags :: BuildOpts -> !(Map (Maybe PackageName) (Map FlagName Bool))

-- | Install executables to user path after building?
boptsInstallExes :: BuildOpts -> !Bool

-- | Fetch all packages immediately
boptsPreFetch :: BuildOpts -> !Bool

-- | Arguments to pass to the test suites if we're running them.
boptsTestArgs :: BuildOpts -> ![String]

-- | Only install packages in the snapshot database, skipping packages
--   intended for the local database.
boptsOnlySnapshot :: BuildOpts -> !Bool

-- | Enable code coverage report generation for test suites.
boptsCoverage :: BuildOpts -> !Bool

-- | The type of a task, either building local code or something from the
--   package index (upstream)
data TaskType
TTLocal :: LocalPackage -> TaskType
TTUpstream :: Package -> InstallLocation -> TaskType

-- | Given the IDs of any missing packages, produce the configure options
data TaskConfigOpts
TaskConfigOpts :: !(Set PackageIdentifier) -> !(Set GhcPkgId -> [Text]) -> TaskConfigOpts

-- | Dependencies for which we don't yet have an GhcPkgId
tcoMissing :: TaskConfigOpts -> !(Set PackageIdentifier)

-- | Produce the list of options given the missing <tt>GhcPkgId</tt>s
tcoOpts :: TaskConfigOpts -> !(Set GhcPkgId -> [Text])

-- | Stored on disk to know whether the flags have changed or any files
--   have changed.
data ConfigCache
ConfigCache :: ![ByteString] -> !(Set GhcPkgId) -> !(Set ByteString) -> !Bool -> ConfigCache

-- | All options used for this package.
configCacheOpts :: ConfigCache -> ![ByteString]

-- | The GhcPkgIds of all of the dependencies. Since Cabal doesn't take the
--   complete GhcPkgId (only a PackageIdentifier) in the configure options,
--   just using the previous value is insufficient to know if dependencies
--   have changed.
configCacheDeps :: ConfigCache -> !(Set GhcPkgId)

-- | The components to be built. It's a bit of a hack to include this in
--   here, as it's not a configure option (just a build option), but this
--   is a convenient way to force compilation when the components change.
configCacheComponents :: ConfigCache -> !(Set ByteString)

-- | Are haddocks to be built?
configCacheHaddock :: ConfigCache -> !Bool
data ConstructPlanException
DependencyCycleDetected :: [PackageName] -> ConstructPlanException
DependencyPlanFailures :: PackageIdentifier -> (Map PackageName (VersionRange, BadDependency)) -> ConstructPlanException

-- | Recommend adding to extra-deps, give a helpful version number?
UnknownPackage :: PackageName -> ConstructPlanException

-- | Render a <tt>BaseConfigOpts</tt> to an actual list of options
configureOpts :: EnvConfig -> BaseConfigOpts -> Set GhcPkgId -> Bool -> InstallLocation -> Package -> [Text]

-- | Reason why a dependency was not used
data BadDependency
NotInBuildPlan :: (Maybe Version) -> BadDependency
Couldn'tResolveItsDependencies :: BadDependency
DependencyMismatch :: Version -> BadDependency

-- | Get set of wanted package names from locals.
wantedLocalPackages :: [LocalPackage] -> Set PackageName
instance Typeable BadDependency
instance Typeable ConstructPlanException
instance Typeable StackBuildException
instance Typeable PkgDepsOracle
instance Eq BadDependency
instance Eq ConstructPlanException
instance Eq FinalAction
instance Bounded FinalAction
instance Enum FinalAction
instance Show FinalAction
instance Show BuildOpts
instance Show PkgDepsOracle
instance Eq PkgDepsOracle
instance Hashable PkgDepsOracle
instance Binary PkgDepsOracle
instance NFData PkgDepsOracle
instance Show InstallLocation
instance Eq InstallLocation
instance Show LocalPackage
instance Generic ConfigCache
instance Eq ConfigCache
instance Show ConfigCache
instance Show TaskType
instance Show Task
instance Show Plan
instance Ord ModTime
instance Show ModTime
instance Generic ModTime
instance Eq ModTime
instance Show Installed
instance Eq Installed
instance Ord Installed
instance Datatype D1ConfigCache
instance Constructor C1_0ConfigCache
instance Selector S1_0_0ConfigCache
instance Selector S1_0_1ConfigCache
instance Selector S1_0_2ConfigCache
instance Selector S1_0_3ConfigCache
instance Datatype D1ModTime
instance Constructor C1_0ModTime
instance Binary ModTime
instance Show TaskConfigOpts
instance Binary ConfigCache
instance Monoid InstallLocation
instance Show ConstructPlanException
instance Exception StackBuildException
instance Show StackBuildException


-- | Functions for the GHC package database.
module Stack.GhcPkg

-- | Get the id of the package e.g.
--   <tt>foo-0.0.0-9c293923c0685761dcff6f8c3ad8f8ec</tt>.
findGhcPkgId :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m, MonadThrow m) => EnvOverride -> [Path Abs Dir] -> PackageName -> m (Maybe GhcPkgId)

-- | Get the global package database
getGlobalDB :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m, MonadThrow m) => EnvOverride -> m (Path Abs Dir)

-- | Override the environment received by a child process
data EnvOverride

-- | Helper conversion function
envHelper :: EnvOverride -> Maybe [(String, String)]

-- | Create a package database in the given directory, if it doesn't exist.
createDatabase :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m, MonadThrow m) => EnvOverride -> Path Abs Dir -> m ()
unregisterGhcPkgId :: (MonadIO m, MonadLogger m, MonadThrow m, MonadCatch m, MonadBaseControl IO m) => EnvOverride -> Path Abs Dir -> GhcPkgId -> m ()

-- | Get the version of Cabal from the global package database.
getCabalPkgVer :: (MonadThrow m, MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m) => EnvOverride -> m Version

-- | Get the Haddock HTML documentation path of the package.
findGhcPkgHaddockHtml :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m, MonadThrow m) => EnvOverride -> [Path Abs Dir] -> PackageIdentifier -> m (Maybe (Path Abs Dir))

-- | Get the dependencies of the package.
findGhcPkgDepends :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m, MonadThrow m) => EnvOverride -> [Path Abs Dir] -> PackageIdentifier -> m [GhcPkgId]


-- | Generate haddocks
module Stack.Build.Haddock

-- | Copy dependencies' haddocks to documentation directory. This way,
--   relative <tt>../$pkg-$ver</tt> links work and it's easy to upload docs
--   to a web server or otherwise view them in a non-local-filesystem
--   context. We copy instead of symlink for two reasons: (1) symlinks
--   aren't reliably supported on Windows, and (2) the filesystem
--   containing dependencies' docs may not be available where viewing the
--   docs (e.g. if building in a Docker container).
copyDepHaddocks :: (MonadIO m, MonadLogger m, MonadThrow m, MonadCatch m, MonadBaseControl IO m) => EnvOverride -> [Path Abs Dir] -> PackageIdentifier -> Set (Path Abs Dir) -> m ()

-- | Generate Haddock index and contents for local packages.
generateHaddockIndex :: (MonadIO m, MonadCatch m, MonadThrow m, MonadLogger m, MonadBaseControl IO m) => EnvOverride -> BaseConfigOpts -> [LocalPackage] -> m ()

-- | Determine whether we should haddock for a package.
shouldHaddockPackage :: BuildOpts -> Set PackageName -> PackageName -> Bool

-- | Determine whether to build haddocks for dependencies.
shouldHaddockDeps :: BuildOpts -> Bool


-- | Cache information about previous builds
module Stack.Build.Cache

-- | Try to read the dirtiness cache for the given package directory.
tryGetBuildCache :: (MonadIO m, MonadReader env m, HasConfig env, MonadThrow m, MonadLogger m, HasEnvConfig env) => Path Abs Dir -> m (Maybe BuildCache)

-- | Try to read the dirtiness cache for the given package directory.
tryGetConfigCache :: (MonadIO m, MonadReader env m, HasConfig env, MonadThrow m, MonadLogger m, HasEnvConfig env) => Path Abs Dir -> m (Maybe ConfigCache)

-- | Try to read the mod time of the cabal file from the last build
tryGetCabalMod :: (MonadIO m, MonadReader env m, HasConfig env, MonadThrow m, MonadLogger m, HasEnvConfig env) => Path Abs Dir -> m (Maybe ModTime)

-- | Get the modified times of all known files in the package, including
--   the package's cabal file itself.
getPackageFileModTimes :: (MonadIO m, MonadLogger m, MonadThrow m, MonadCatch m) => Package -> Path Abs File -> m (Map FilePath ModTime)

-- | Get all of the installed executables
getInstalledExes :: (MonadReader env m, HasEnvConfig env, MonadIO m, MonadThrow m) => InstallLocation -> m [PackageIdentifier]

-- | Modification times of files.
buildCacheTimes :: BuildCache -> (Map FilePath ModTime)

-- | Loads the flag cache for the given installed extra-deps
tryGetFlagCache :: (MonadIO m, MonadThrow m, MonadReader env m, HasEnvConfig env) => Installed -> m (Maybe ConfigCache)

-- | Delete the caches for the project.
deleteCaches :: (MonadIO m, MonadReader env m, HasConfig env, MonadLogger m, MonadThrow m, HasEnvConfig env) => Path Abs Dir -> m ()

-- | Mark the given executable as installed
markExeInstalled :: (MonadReader env m, HasEnvConfig env, MonadIO m, MonadThrow m) => InstallLocation -> PackageIdentifier -> m ()
writeFlagCache :: (MonadIO m, MonadReader env m, HasEnvConfig env, MonadThrow m) => Installed -> ConfigCache -> m ()

-- | Write the dirtiness cache for this package's files.
writeBuildCache :: (MonadIO m, MonadReader env m, HasConfig env, MonadThrow m, MonadLogger m, HasEnvConfig env) => Path Abs Dir -> Map FilePath ModTime -> m ()

-- | Write the dirtiness cache for this package's configuration.
writeConfigCache :: (MonadIO m, MonadReader env m, HasConfig env, MonadThrow m, MonadLogger m, HasEnvConfig env) => Path Abs Dir -> ConfigCache -> m ()

-- | See <a>tryGetCabalMod</a>
writeCabalMod :: (MonadIO m, MonadReader env m, HasConfig env, MonadThrow m, MonadLogger m, HasEnvConfig env) => Path Abs Dir -> ModTime -> m ()
instance Generic BuildCache
instance Eq BuildCache
instance Datatype D1BuildCache
instance Constructor C1_0BuildCache
instance Selector S1_0_0BuildCache
instance Binary BuildCache


-- | Provide ability to upload tarballs to Hackage.
module Stack.Upload

-- | Turn the given settings into an <tt>Uploader</tt>.
--   
--   Since 0.1.0.0
mkUploader :: Config -> UploadSettings -> IO Uploader

-- | The computed value from a <tt>UploadSettings</tt>.
--   
--   Typically, you want to use this with <a>upload</a>.
--   
--   Since 0.1.0.0
data Uploader

-- | Upload a single tarball with the given <tt>Uploader</tt>.
--   
--   Since 0.1.0.0
upload :: Uploader -> FilePath -> IO ()

-- | Settings for creating an <tt>Uploader</tt>.
--   
--   Since 0.1.0.0
data UploadSettings

-- | Default value for <tt>UploadSettings</tt>.
--   
--   Use setter functions to change defaults.
--   
--   Since 0.1.0.0
defaultUploadSettings :: UploadSettings

-- | Change the upload URL.
--   
--   Default: "<a>https://hackage.haskell.org/packages/"</a>
--   
--   Since 0.1.0.0
setUploadUrl :: String -> UploadSettings -> UploadSettings

-- | How to get an HTTP connection manager.
--   
--   Default: <tt>newManager tlsManagerSettings</tt>
--   
--   Since 0.1.0.0
setGetManager :: IO Manager -> UploadSettings -> UploadSettings

-- | How to get the Hackage credentials.
--   
--   Default: <tt>fromAnywhere</tt>
--   
--   Since 0.1.0.0
setCredsSource :: (Config -> HackageCredsSource) -> UploadSettings -> UploadSettings

-- | Save new credentials to the config file.
--   
--   Default: <tt>True</tt>
--   
--   Since 0.1.0.0
setSaveCreds :: Bool -> UploadSettings -> UploadSettings

-- | Username and password to log into Hackage.
--   
--   Since 0.1.0.0
data HackageCreds

-- | Load Hackage credentials from the given source.
--   
--   Since 0.1.0.0
loadCreds :: HackageCredsSource -> IO (HackageCreds, FromFile)

-- | Save the given credentials to the credentials file.
--   
--   Since 0.1.0.0
saveCreds :: Config -> HackageCreds -> IO ()

-- | Whether the Hackage credentials were loaded from a file.
--   
--   This information is useful since, typically, you only want to save the
--   credentials to a file if it wasn't already loaded from there.
--   
--   Since 0.1.0.0
type FromFile = Bool

-- | A source for getting Hackage credentials.
--   
--   Since 0.1.0.0
data HackageCredsSource

-- | Try to load the credentials from the config file. If that fails, ask
--   the user to enter them.
--   
--   Since 0.1.0.0
fromAnywhere :: Config -> HackageCredsSource

-- | Load the Hackage credentials from the prompt, asking the user to type
--   them in.
--   
--   Since 0.1.0.0
fromPrompt :: HackageCredsSource

-- | Load the Hackage credentials from the JSON config file.
--   
--   Since 0.1.0.0
fromFile :: Config -> HackageCredsSource

-- | Load the Hackage credentials from the given arguments.
--   
--   Since 0.1.0.0
fromMemory :: Text -> Text -> HackageCredsSource
instance Typeable HackageCredsExceptions
instance Show HackageCreds
instance Show HackageCredsExceptions
instance Exception HackageCredsExceptions
instance FromJSON HackageCreds
instance ToJSON HackageCreds


-- | Internal types to the library.
module Stack.Types.Internal

-- | Monadic environment.
data Env config
Env :: !config -> !LogLevel -> !Bool -> !Manager -> !Sticky -> Env config
envConfig :: Env config -> !config
envLogLevel :: Env config -> !LogLevel
envTerminal :: Env config -> !Bool
envManager :: Env config -> !Manager
envSticky :: Env config -> !Sticky
class HasLogLevel r
getLogLevel :: HasLogLevel r => r -> LogLevel
class HasTerminal r
getTerminal :: HasTerminal r => r -> Bool
newtype Sticky
Sticky :: Maybe (MVar (Maybe Text)) -> Sticky
unSticky :: Sticky -> Maybe (MVar (Maybe Text))
class HasSticky r
getSticky :: HasSticky r => r -> Sticky
instance HasSticky (Env config)
instance HasTerminal (Env config)
instance HasLogLevel LogLevel
instance HasLogLevel (Env config)
instance HasHttpManager (Env config)
instance HasEnvConfig config => HasEnvConfig (Env config)
instance HasBuildConfig config => HasBuildConfig (Env config)
instance HasConfig config => HasConfig (Env config)
instance HasPlatform config => HasPlatform (Env config)
instance HasStackRoot config => HasStackRoot (Env config)


-- | The monad used for the command-line executable <tt>stack</tt>.
module Stack.Types.StackT

-- | The monad used for the executable <tt>stack</tt>.
data StackT config m a

-- | The monad used for logging in the executable <tt>stack</tt> before
--   anything has been initialized.
data StackLoggingT m a

-- | Run a Stack action.
runStackT :: (MonadIO m, MonadBaseControl IO m) => Manager -> LogLevel -> config -> Bool -> StackT config m a -> m a

-- | Run the logging monad.
runStackLoggingT :: MonadIO m => Manager -> LogLevel -> Bool -> StackLoggingT m a -> m a

-- | Convenience for getting a <a>Manager</a>
newTLSManager :: MonadIO m => m Manager

-- | Write a "sticky" line to the terminal. Any subsequent lines will
--   overwrite this one, and that same line will be repeated below again.
--   In other words, the line sticks at the bottom of the output forever.
--   Running this function again will replace the sticky line with a new
--   sticky line. When you want to get rid of the sticky line, run
--   <a>logStickyDone</a>.
logSticky :: Q Exp

-- | This will print out the given message with a newline and disable any
--   further stickiness of the line until a new call to <a>logSticky</a>
--   happens.
--   
--   It might be better at some point to have a <tt>runSticky</tt> function
--   that encompasses the logSticky-&gt;logStickyDone pairing.
logStickyDone :: Q Exp
instance MonadBase b m => MonadBase b (StackLoggingT m)
instance MonadBase b m => MonadBase b (StackT config m)
instance Functor m => Functor (StackT config m)
instance Applicative m => Applicative (StackT config m)
instance Monad m => Monad (StackT config m)
instance MonadIO m => MonadIO (StackT config m)
instance Monad m => MonadReader (Env config) (StackT config m)
instance MonadThrow m => MonadThrow (StackT config m)
instance MonadCatch m => MonadCatch (StackT config m)
instance MonadMask m => MonadMask (StackT config m)
instance MonadTrans (StackT config)
instance Functor m => Functor (StackLoggingT m)
instance Applicative m => Applicative (StackLoggingT m)
instance Monad m => Monad (StackLoggingT m)
instance MonadIO m => MonadIO (StackLoggingT m)
instance MonadThrow m => MonadThrow (StackLoggingT m)
instance Monad m => MonadReader (LogLevel, Manager, Sticky) (StackLoggingT m)
instance MonadCatch m => MonadCatch (StackLoggingT m)
instance MonadMask m => MonadMask (StackLoggingT m)
instance MonadTrans StackLoggingT
instance HasHttpManager (LogLevel, Manager, Sticky)
instance HasLogLevel (LogLevel, Manager, Sticky)
instance HasSticky (LogLevel, Manager, Sticky)
instance MonadIO m => MonadLogger (StackLoggingT m)
instance MonadTransControl StackLoggingT
instance MonadBaseControl b m => MonadBaseControl b (StackLoggingT m)
instance MonadIO m => MonadLogger (StackT config m)
instance MonadTransControl (StackT config)
instance MonadBaseControl b m => MonadBaseControl b (StackT config m)


-- | Dealing with the 00-index file and all its cabal files.
module Stack.PackageIndex

-- | Update all of the package indices
updateAllIndices :: (MonadIO m, MonadLogger m, MonadThrow m, MonadReader env m, HasHttpManager env, HasConfig env, MonadBaseControl IO m, MonadCatch m) => EnvOverride -> m ()
data PackageDownload
PackageDownload :: !ByteString -> !ByteString -> !Word64 -> PackageDownload
pdSHA512 :: PackageDownload -> !ByteString
pdUrl :: PackageDownload -> !ByteString
pdSize :: PackageDownload -> !Word64
data PackageCache
PackageCache :: !Int64 -> !Int64 -> !(Maybe PackageDownload) -> PackageCache

-- | offset in bytes into the 00-index.tar file for the .cabal file
--   contents
pcOffset :: PackageCache -> !Int64

-- | size in bytes of the .cabal file
pcSize :: PackageCache -> !Int64
pcDownload :: PackageCache -> !(Maybe PackageDownload)

-- | Load the cached package URLs, or created the cache if necessary.
getPackageCaches :: (MonadIO m, MonadLogger m, MonadReader env m, HasConfig env, MonadThrow m, HasHttpManager env, MonadBaseControl IO m, MonadCatch m) => EnvOverride -> m (Map PackageIdentifier (PackageIndex, PackageCache))
instance Typeable PackageIndexException
instance Show PackageDownload
instance Generic PackageDownload
instance Generic PackageCache
instance Binary PackageCacheMap
instance Datatype D1PackageDownload
instance Constructor C1_0PackageDownload
instance Selector S1_0_0PackageDownload
instance Selector S1_0_1PackageDownload
instance Selector S1_0_2PackageDownload
instance Datatype D1PackageCache
instance Constructor C1_0PackageCache
instance Selector S1_0_0PackageCache
instance Selector S1_0_1PackageCache
instance Selector S1_0_2PackageCache
instance FromJSON PackageDownload
instance Binary PackageDownload
instance Show PackageIndexException
instance Exception PackageIndexException
instance BinarySchema PackageCacheMap
instance Binary PackageCache


-- | Functionality for downloading packages securely for cabal's usage.
module Stack.Fetch

-- | Intended to work for the command line command.
unpackPackages :: (MonadIO m, MonadBaseControl IO m, MonadReader env m, HasHttpManager env, HasConfig env, MonadThrow m, MonadLogger m, MonadCatch m) => EnvOverride -> FilePath -> [String] -> m ()

-- | Ensure that all of the given package idents are unpacked into the
--   build unpack directory, and return the paths to all of the
--   subdirectories.
unpackPackageIdents :: (MonadBaseControl IO m, MonadIO m, MonadReader env m, HasHttpManager env, HasConfig env, MonadThrow m, MonadLogger m, MonadCatch m) => EnvOverride -> Path Abs Dir -> Maybe (Path Rel Dir) -> Set PackageIdentifier -> m (Map PackageIdentifier (Path Abs Dir))

-- | Fetch packages into the cache without unpacking
fetchPackages :: (MonadIO m, MonadBaseControl IO m, MonadReader env m, HasHttpManager env, HasConfig env, MonadThrow m, MonadLogger m, MonadCatch m) => EnvOverride -> Set PackageIdentifier -> m ()

-- | Resolve a set of package names and identifiers into
--   <tt>FetchPackage</tt> values.
resolvePackages :: (MonadIO m, MonadReader env m, HasHttpManager env, HasConfig env, MonadLogger m, MonadThrow m, MonadBaseControl IO m, MonadCatch m) => EnvOverride -> Set PackageIdentifier -> Set PackageName -> m (Map PackageIdentifier ResolvedPackage)
resolvePackagesAllowMissing :: (MonadIO m, MonadReader env m, HasHttpManager env, HasConfig env, MonadLogger m, MonadThrow m, MonadBaseControl IO m, MonadCatch m) => EnvOverride -> Set PackageIdentifier -> Set PackageName -> m (Set PackageName, Set PackageIdentifier, Map PackageIdentifier ResolvedPackage)
data ResolvedPackage
ResolvedPackage :: !PackageCache -> !PackageIndex -> ResolvedPackage
rpCache :: ResolvedPackage -> !PackageCache
rpIndex :: ResolvedPackage -> !PackageIndex

-- | Add the cabal files to a list of idents with their caches.
withCabalFiles :: (MonadThrow m, MonadIO m, MonadReader env m, HasConfig env) => IndexName -> [(PackageIdentifier, PackageCache, a)] -> (PackageIdentifier -> a -> ByteString -> IO b) -> m [b]

-- | Provide a function which will load up a cabal <tt>ByteString</tt> from
--   the package indices.
withCabalLoader :: (MonadThrow m, MonadIO m, MonadReader env m, HasConfig env, MonadLogger m, HasHttpManager env, MonadBaseControl IO m, MonadCatch m) => EnvOverride -> ((PackageIdentifier -> IO ByteString) -> m a) -> m a
instance Typeable FetchException
instance Show FetchException
instance Exception FetchException


-- | Global sqlite database shared by all projects. Warning: this is
--   currently only accessible from <b>outside</b> a Docker container.
module Stack.Docker.GlobalDB

-- | Update last used time and project for a Docker image hash.
updateDockerImageLastUsed :: Config -> String -> FilePath -> IO ()

-- | Get a list of Docker image hashes and when they were last used.
getDockerImagesLastUsed :: Config -> IO [DockerImageLastUsed]

-- | Given a list of all existing Docker images, remove any that no longer
--   exist from the database.
pruneDockerImagesLastUsed :: Config -> [String] -> IO ()

-- | Date and project path where Docker image hash last used.
type DockerImageLastUsed = (String, [(UTCTime, FilePath)])
type DockerImageProjectId = Key DockerImageProject
instance Show DockerImageProject
instance Show (Key DockerImageProject)
instance Read (Key DockerImageProject)
instance Eq (Key DockerImageProject)
instance Ord (Key DockerImageProject)
instance PathPiece (Key DockerImageProject)
instance PersistField (Key DockerImageProject)
instance PersistFieldSql (Key DockerImageProject)
instance ToJSON (Key DockerImageProject)
instance FromJSON (Key DockerImageProject)
instance ToBackendKey SqlBackend DockerImageProject
instance PersistEntity DockerImageProject
instance PersistFieldSql DockerImageProject
instance PersistField DockerImageProject


-- | Resolving a build plan for a set of packages in a given Stackage
--   snapshot.
module Stack.BuildPlan
data BuildPlanException
UnknownPackages :: (Path Abs File) -> (Map PackageName (Maybe Version, Set PackageName)) -> (Map PackageName (Set PackageIdentifier)) -> BuildPlanException

-- | A simplified version of the <a>BuildPlan</a> + cabal file.
data MiniBuildPlan
MiniBuildPlan :: !Version -> !(Map PackageName MiniPackageInfo) -> MiniBuildPlan
mbpGhcVersion :: MiniBuildPlan -> !Version
mbpPackages :: MiniBuildPlan -> !(Map PackageName MiniPackageInfo)

-- | Information on a single package for the <a>MiniBuildPlan</a>.
data MiniPackageInfo
MiniPackageInfo :: !Version -> !(Map FlagName Bool) -> !(Set PackageName) -> !(Set ByteString) -> !(Set ExeName) -> !Bool -> MiniPackageInfo
mpiVersion :: MiniPackageInfo -> !Version
mpiFlags :: MiniPackageInfo -> !(Map FlagName Bool)
mpiPackageDeps :: MiniPackageInfo -> !(Set PackageName)

-- | Due to ambiguity in Cabal, it is unclear whether this refers to the
--   executable name, the package name, or something else. We have to guess
--   based on what's available, which is why we store this is an unwrapped
--   <a>ByteString</a>.
mpiToolDeps :: MiniPackageInfo -> !(Set ByteString)

-- | Executables provided by this package
mpiExes :: MiniPackageInfo -> !(Set ExeName)

-- | Is there a library present?
mpiHasLibrary :: MiniPackageInfo -> !Bool

-- | Most recent Nightly and newest LTS version per major release.
data Snapshots
Snapshots :: !Day -> !(IntMap Int) -> Snapshots
snapshotsNightly :: Snapshots -> !Day
snapshotsLts :: Snapshots -> !(IntMap Int)

-- | Download the <a>Snapshots</a> value from stackage.org.
getSnapshots :: (MonadThrow m, MonadIO m, MonadReader env m, HasHttpManager env, HasStackRoot env, HasConfig env) => m Snapshots

-- | Load up a <a>MiniBuildPlan</a>, preferably from cache
loadMiniBuildPlan :: (MonadIO m, MonadThrow m, MonadLogger m, MonadReader env m, HasHttpManager env, HasConfig env, MonadBaseControl IO m, MonadCatch m) => SnapName -> m MiniBuildPlan

-- | Determine the necessary packages to install to have the given set of
--   packages available.
--   
--   This function will not provide test suite and benchmark dependencies.
--   
--   This may fail if a target package is not present in the
--   <tt>BuildPlan</tt>.
resolveBuildPlan :: (MonadThrow m, MonadIO m, MonadReader env m, HasBuildConfig env, MonadLogger m, HasHttpManager env, MonadBaseControl IO m, MonadCatch m) => EnvOverride -> MiniBuildPlan -> (PackageName -> Bool) -> Map PackageName (Set PackageName) -> m (Map PackageName (Version, Map FlagName Bool), Map PackageName (Set PackageName))

-- | Find a snapshot and set of flags that is compatible with the given
--   <a>GenericPackageDescription</a>. Returns <a>Nothing</a> if no such
--   snapshot is found.
findBuildPlan :: (MonadIO m, MonadCatch m, MonadLogger m, MonadReader env m, HasHttpManager env, HasConfig env, MonadBaseControl IO m) => [GenericPackageDescription] -> [SnapName] -> m (Maybe (SnapName, Map PackageName (Map FlagName Bool)))

-- | Look up with packages provide which tools.
type ToolMap = Map ByteString (Set PackageName)

-- | Map from tool name to package providing it
getToolMap :: MiniBuildPlan -> Map ByteString (Set PackageName)
shadowMiniBuildPlan :: MiniBuildPlan -> Set PackageName -> (MiniBuildPlan, Map PackageName MiniPackageInfo)
instance Typeable BuildPlanException
instance Show Snapshots
instance Monoid DepError
instance FromJSON Snapshots
instance Show BuildPlanException
instance Exception BuildPlanException

module Stack.Solver
cabalSolver :: (MonadIO m, MonadLogger m, MonadMask m, MonadBaseControl IO m, MonadReader env m, HasConfig env) => [Path Abs Dir] -> [String] -> m (MajorVersion, Map PackageName (Version, Map FlagName Bool))
getGhcVersion :: (MonadLogger m, MonadCatch m, MonadBaseControl IO m, MonadIO m) => EnvOverride -> m Version

-- | Determine missing extra-deps
solveExtraDeps :: (MonadReader env m, HasEnvConfig env, MonadIO m, MonadMask m, MonadLogger m, MonadBaseControl IO m, HasHttpManager env) => Bool -> m ()

module Stack.Init
findCabalFiles :: MonadIO m => Path Abs Dir -> m [Path Abs File]

-- | Generate stack.yaml
initProject :: (MonadIO m, MonadMask m, MonadReader env m, HasConfig env, HasHttpManager env, MonadLogger m, MonadBaseControl IO m) => InitOpts -> m ()
data InitOpts
InitOpts :: !Method -> InitOpts

-- | Preferred snapshots
ioMethod :: InitOpts -> !Method
initOptsParser :: Parser InitOpts
readResolver :: ReadM Resolver

module Stack.Setup

-- | Modify the environment variables (like PATH) appropriately, possibly
--   doing installation too
setupEnv :: (MonadIO m, MonadMask m, MonadLogger m, MonadReader env m, HasBuildConfig env, HasHttpManager env, MonadBaseControl IO m) => m EnvConfig

-- | Ensure GHC is installed and provide the PATHs to add if necessary
ensureGHC :: (MonadIO m, MonadMask m, MonadLogger m, MonadReader env m, HasConfig env, HasHttpManager env, MonadBaseControl IO m) => SetupOpts -> m (Maybe [FilePath])
data SetupOpts
SetupOpts :: !Bool -> !Bool -> !Version -> !(Maybe (Path Abs File)) -> !Bool -> !Bool -> SetupOpts
soptsInstallIfMissing :: SetupOpts -> !Bool
soptsUseSystem :: SetupOpts -> !Bool
soptsExpected :: SetupOpts -> !Version

-- | If we got the desired GHC version from that file
soptsStackYaml :: SetupOpts -> !(Maybe (Path Abs File))
soptsForceReinstall :: SetupOpts -> !Bool

-- | Run a sanity check on the selected GHC
soptsSanityCheck :: SetupOpts -> !Bool
instance Typeable SetupException
instance Show SetupOpts
instance Show DownloadPair
instance Show SetupInfo
instance FromJSON SetupInfo
instance FromJSON DownloadPair
instance Show SetupException
instance Exception SetupException

module Stack.Build.Source
loadSourceMap :: (MonadIO m, MonadCatch m, MonadReader env m, HasBuildConfig env, MonadBaseControl IO m, HasHttpManager env, MonadLogger m, HasEnvConfig env) => BuildOpts -> m (MiniBuildPlan, [LocalPackage], Set PackageName, SourceMap)
type SourceMap = Map PackageName PackageSource

-- | Where the package's source is located: local directory or package
--   index
data PackageSource
PSLocal :: LocalPackage -> PackageSource

-- | Upstream packages could be installed in either local or snapshot
--   databases; this is what <a>InstallLocation</a> specifies.
PSUpstream :: Version -> InstallLocation -> (Map FlagName Bool) -> PackageSource

-- | All flags for a local package
localFlags :: (Map (Maybe PackageName) (Map FlagName Bool)) -> BuildConfig -> PackageName -> Map FlagName Bool
instance Show PackageSource
instance PackageInstallInfo PackageSource


-- | Run a REPL configured with the user's project(s).
module Stack.Repl

-- | Launch a GHCi REPL for the given local project targets with the given
--   options and configure it with the load paths and extensions of those
--   targets.
repl :: (HasConfig r, HasBuildConfig r, HasEnvConfig r, MonadReader r m, MonadIO m, MonadThrow m, MonadLogger m, MonadCatch m) => [Text] -> [String] -> FilePath -> Bool -> m ()


-- | Run a IDE configured with the user's project(s).
module Stack.Ide

-- | Launch a GHCi IDE for the given local project targets with the given
--   options and configure it with the load paths and extensions of those
--   targets.
ide :: (HasConfig r, HasBuildConfig r, HasEnvConfig r, MonadReader r m, MonadIO m, MonadThrow m, MonadLogger m, MonadCatch m) => [Text] -> [String] -> m ()

module Stack.PackageDump

-- | A single line of input, not including line endings
type Line = ByteString

-- | Apply the given Sink to each section of output, broken by a single
--   line containing ---
eachSection :: Monad m => Sink Line m a -> Conduit ByteString m a

-- | Grab each key/value pair
eachPair :: Monad m => (ByteString -> Sink Line m a) -> Conduit Line m a

-- | Dump information for a single package
data DumpPackage profiling haddock
DumpPackage :: !GhcPkgId -> ![FilePath] -> ![ByteString] -> ![GhcPkgId] -> ![ByteString] -> !profiling -> !haddock -> DumpPackage profiling haddock
dpGhcPkgId :: DumpPackage profiling haddock -> !GhcPkgId
dpLibDirs :: DumpPackage profiling haddock -> ![FilePath]
dpLibraries :: DumpPackage profiling haddock -> ![ByteString]
dpDepends :: DumpPackage profiling haddock -> ![GhcPkgId]
dpHaddockInterfaces :: DumpPackage profiling haddock -> ![ByteString]
dpProfiling :: DumpPackage profiling haddock -> !profiling
dpHaddock :: DumpPackage profiling haddock -> !haddock

-- | Convert a stream of bytes into a stream of <tt>DumpPackage</tt>s
conduitDumpPackage :: MonadThrow m => Conduit ByteString m (DumpPackage () ())

-- | Call ghc-pkg dump with appropriate flags and stream to the given
--   <tt>Sink</tt>, for a single database
ghcPkgDump :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadCatch m, MonadThrow m) => EnvOverride -> Maybe (Path Abs Dir) -> Sink ByteString IO a -> m a

-- | Cached information on whether package have profiling libraries and
--   haddocks.
data InstalledCache

-- | Cached information on whether a package has profiling libraries and
--   haddocks.
data InstalledCacheEntry
InstalledCacheEntry :: !Bool -> !Bool -> InstalledCacheEntry
installedCacheProfiling :: InstalledCacheEntry -> !Bool
installedCacheHaddock :: InstalledCacheEntry -> !Bool

-- | Create a new, empty <tt>InstalledCache</tt>
newInstalledCache :: MonadIO m => m InstalledCache

-- | Load a <tt>InstalledCache</tt> from disk, swallowing any errors and
--   returning an empty cache.
loadInstalledCache :: MonadIO m => Path Abs File -> m InstalledCache

-- | Save a <tt>InstalledCache</tt> to disk
saveInstalledCache :: MonadIO m => Path Abs File -> InstalledCache -> m ()

-- | Add profiling information to the stream of <tt>DumpPackage</tt>s
addProfiling :: MonadIO m => InstalledCache -> Conduit (DumpPackage a b) m (DumpPackage Bool b)

-- | Add haddock information to the stream of <tt>DumpPackage</tt>s
addHaddock :: MonadIO m => InstalledCache -> Conduit (DumpPackage a b) m (DumpPackage a Bool)

-- | Find the package IDs matching the given constraints with all
--   dependencies installed. Packages not mentioned in the provided
--   <tt>Map</tt> are allowed to be present too.
sinkMatching :: Monad m => Bool -> Bool -> Map PackageName Version -> Consumer (DumpPackage Bool Bool) m (Map PackageName (DumpPackage Bool Bool))

-- | Prune a list of possible packages down to those whose dependencies are
--   met.
--   
--   <ul>
--   <li>id uniquely identifies an item</li>
--   <li>There can be multiple items per name</li>
--   </ul>
pruneDeps :: (Ord name, Ord id) => (id -> name) -> (item -> id) -> (item -> [id]) -> (item -> item -> item) -> [item] -> Map name item
instance Typeable PackageDumpException
instance Eq InstalledCacheEntry
instance Generic InstalledCacheEntry
instance Binary InstalledCacheInner
instance (Show profiling, Show haddock) => Show (DumpPackage profiling haddock)
instance (Eq profiling, Eq haddock) => Eq (DumpPackage profiling haddock)
instance (Ord profiling, Ord haddock) => Ord (DumpPackage profiling haddock)
instance Datatype D1InstalledCacheEntry
instance Constructor C1_0InstalledCacheEntry
instance Selector S1_0_0InstalledCacheEntry
instance Selector S1_0_1InstalledCacheEntry
instance Show PackageDumpException
instance Exception PackageDumpException
instance Binary InstalledCacheEntry
instance BinarySchema InstalledCacheInner

module Stack.Build.Installed
type InstalledMap = Map PackageName (Version, InstallLocation, Installed)
data Installed
Library :: GhcPkgId -> Installed
Executable :: PackageIdentifier -> Installed

-- | Options for <a>getInstalled</a>.
data GetInstalledOpts
GetInstalledOpts :: !Bool -> !Bool -> GetInstalledOpts

-- | Require profiling libraries?
getInstalledProfiling :: GetInstalledOpts -> !Bool

-- | Require haddocks?
getInstalledHaddock :: GetInstalledOpts -> !Bool

-- | Returns the new InstalledMap and all of the locally registered
--   packages.
getInstalled :: (M env m, PackageInstallInfo pii) => EnvOverride -> GetInstalledOpts -> Map PackageName pii -> m (InstalledMap, Set GhcPkgId)
instance Show LoadHelper


-- | Construct a <tt>Plan</tt> for how to build
module Stack.Build.ConstructPlan
constructPlan :: (MonadCatch m, MonadReader env m, HasEnvConfig env, MonadIO m, MonadLogger m, MonadBaseControl IO m, HasHttpManager env) => MiniBuildPlan -> BaseConfigOpts -> [LocalPackage] -> Set PackageName -> Set GhcPkgId -> (PackageName -> Version -> Map FlagName Bool -> IO Package) -> SourceMap -> InstalledMap -> m Plan
instance Show AddDepRes
instance HasEnvConfig Ctx
instance HasBuildConfig Ctx
instance HasConfig Ctx
instance HasPlatform Ctx
instance HasStackRoot Ctx

module Stack.Build.Execute
printPlan :: M env m => FinalAction -> Plan -> m ()
preFetch :: M env m => Plan -> m ()

-- | Perform the actual plan
executePlan :: M env m => EnvOverride -> BuildOpts -> BaseConfigOpts -> [LocalPackage] -> SourceMap -> Plan -> m ()

-- | Determine the tests to be run based on the list of components.
compareTestsComponents :: [Text] -> [Text] -> [Text]


-- | Build project(s).
module Stack.Build

-- | Build
build :: M env m => BuildOpts -> m ()

-- | Reset the build (remove Shake database and .gen files).
clean :: M env m => m ()


-- | Accepting arguments to be passed through to a sub-process.
module Options.Applicative.Args

-- | An argument which accepts a list of arguments e.g.
--   <tt>--ghc-options="-X P.hs "this""</tt>.
argsArgument :: Mod ArgumentFields [String] -> Parser [String]

-- | An option which accepts a list of arguments e.g. <tt>--ghc-options="-X
--   P.hs "this""</tt>.
argsOption :: Mod OptionFields [String] -> Parser [String]

-- | Parse from a string.
parseArgsFromString :: String -> Either String [String]


-- | Extra functions for optparse-applicative.
module Options.Applicative.Builder.Extra

-- | Enable/disable flags for a <tt>Bool</tt>.
boolFlags :: Bool -> String -> String -> Mod FlagFields Bool -> Parser Bool

-- | Enable/disable flags for a <tt>Bool</tt>, without a default case (to
--   allow chaining <tt><a>|</a></tt>s).
boolFlagsNoDefault :: String -> String -> Mod FlagFields Bool -> Parser Bool

-- | Enable/disable flags for a <tt>(Maybe Bool)</tt>.
maybeBoolFlags :: String -> String -> Mod FlagFields (Maybe Bool) -> Parser (Maybe Bool)

-- | Enable/disable flags for any type.
enableDisableFlags :: a -> a -> a -> String -> String -> Mod FlagFields a -> Parser a

-- | Enable/disable flags for any type, without a default (to allow
--   chaining <tt><a>|</a></tt>s)
enableDisableFlagsNoDefault :: a -> a -> String -> String -> Mod FlagFields a -> Parser a

-- | Show an extra help option (e.g. <tt>--docker-help</tt> shows help for
--   all <tt>--docker*</tt> args). To actually show have that help appear,
--   use <a>execExtraHelp</a> before executing the main parser.
extraHelpOption :: String -> String -> String -> Parser (a -> a)

-- | Display extra help if extea help option passed in arguments. Since
--   optparse-applicative doesn't allow an arbirary IO action for an
--   <a>abortOption</a>, this was the best way I found that doesn't require
--   manually formatting the help.
execExtraHelp :: [String] -> String -> Parser a -> String -> IO ()


-- | Run commands in Docker containers
module Stack.Docker

-- | Clean-up old docker images and containers.
cleanup :: M env m => CleanupOpts -> m ()

-- | Options for <a>cleanup</a>.
data CleanupOpts
CleanupOpts :: !CleanupAction -> !(Maybe Integer) -> !(Maybe Integer) -> !(Maybe Integer) -> !(Maybe Integer) -> !(Maybe Integer) -> CleanupOpts
dcAction :: CleanupOpts -> !CleanupAction
dcRemoveKnownImagesLastUsedDaysAgo :: CleanupOpts -> !(Maybe Integer)
dcRemoveUnknownImagesCreatedDaysAgo :: CleanupOpts -> !(Maybe Integer)
dcRemoveDanglingImagesCreatedDaysAgo :: CleanupOpts -> !(Maybe Integer)
dcRemoveStoppedContainersCreatedDaysAgo :: CleanupOpts -> !(Maybe Integer)
dcRemoveRunningContainersCreatedDaysAgo :: CleanupOpts -> !(Maybe Integer)

-- | Cleanup action.
data CleanupAction
CleanupInteractive :: CleanupAction
CleanupImmediate :: CleanupAction
CleanupDryRun :: CleanupAction

-- | Command-line argument for <tt>docker cleanup</tt>.
dockerCleanupCmdName :: String

-- | Command-line argument for "docker"
dockerCmdName :: String

-- | Options parser configuration for Docker.
dockerOptsParser :: Bool -> Parser DockerOptsMonoid

-- | Interprets DockerOptsMonoid options.
dockerOptsFromMonoid :: Maybe Project -> Path Abs Dir -> DockerOptsMonoid -> DockerOpts

-- | Command-line argument for <tt>docker pull</tt>.
dockerPullCmdName :: String

-- | Error if running in a container.
preventInContainer :: (MonadIO m, MonadThrow m) => m () -> m ()

-- | Pull latest version of configured Docker image from registry.
pull :: M env m => m ()

-- | If Docker is enabled, re-runs the OS command returned by the second
--   argument in a Docker container. Otherwise, runs the inner action.
rerunCmdWithOptionalContainer :: M env m => Maybe (Path Abs Dir) -> IO (FilePath, [String], Config -> Config) -> IO () -> m ()

-- | If Docker is enabled, re-runs the OS command returned by the second
--   argument in a Docker container. Otherwise, runs the inner action.
rerunCmdWithRequiredContainer :: M env m => Maybe (Path Abs Dir) -> IO (FilePath, [String], Config -> Config) -> m ()

-- | If Docker is enabled, re-runs the currently running OS command in a
--   Docker container. Otherwise, runs the inner action.
rerunWithOptionalContainer :: M env m => Maybe (Path Abs Dir) -> IO () -> m ()

-- | Remove the project's Docker sandbox.
reset :: MonadIO m => Maybe (Path Abs Dir) -> Bool -> m ()
instance Typeable StackDockerException
instance Show CleanupAction
instance Show CleanupOpts
instance Show ImageConfig
instance Show Inspect
instance Show StackDockerException
instance Exception StackDockerException
instance FromJSON ImageConfig
instance FromJSON Inspect


-- | The general Stack configuration that starts everything off. This
--   should be smart to falback if there is no stack.yaml, instead relying
--   on whatever files are available.
--   
--   If there is no stack.yaml, and there is a cabal.config, we read in
--   those constraints, and if there's a cabal.sandbox.config, we read any
--   constraints from there and also find the package database from there,
--   etc. And if there's nothing, we should probably default to behaving
--   like cabal, possibly with spitting out a warning that "you should run
--   `stk init` to make things better".
module Stack.Config

-- | Command-line arguments parser for configuration.
configOptsParser :: Bool -> Parser ConfigMonoid

-- | Load the configuration, using current directory, environment
--   variables, and defaults as necessary.
loadConfig :: (MonadLogger m, MonadIO m, MonadCatch m, MonadThrow m, MonadBaseControl IO m, MonadReader env m, HasHttpManager env) => ConfigMonoid -> m (LoadConfig m)
instance HasPlatform MiniConfig
instance HasHttpManager MiniConfig
instance HasStackRoot MiniConfig
instance HasConfig MiniConfig
