-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Mixing effects of one arrow into another one
--   
--   This package allows one to mix effects of two arrows into a single
--   one, and get them back afterwards.
--   
--   It was inspired by Wolfgang Jeltsch's lax package.
@package mix-arrows
@version 1.2


-- | Various ways of shuffling input and output components. Function types
--   are mostly autogenerated.
module Control.Arrow.Mix.Utilities
swap :: (t1, t) -> (t, t1)
twist :: (t1, (t, t2)) -> (t, (t1, t2))
assocLtoR :: ((t, t1), t2) -> (t, (t1, t2))
assocRtoL :: (t1, (t2, t)) -> ((t1, t2), t)
arrSwap :: Arrow a => a (t, t1) (t2, t3) -> a (t1, t) (t3, t2)
arrTwist :: Arrow a => a (t, (t1, t2)) (t4, (t3, t5)) -> a (t1, (t, t2)) (t3, (t4, t5))
pack :: Either (y, c) (y, d) -> (y, Either c d)
unpack :: (x, Either b d) -> Either (x, b) (x, d)
arrAssocLtoR :: Arrow a => a ((t1, t2), t) ((t3, t4), t5) -> a (t1, (t2, t)) (t3, (t4, t5))
arrAssocRtoL :: Arrow a => a (t, (t1, t2)) (t3, (t4, t5)) -> a ((t, t1), t2) ((t3, t4), t5)
arrCancelUnit :: Arrow a => a (b, ()) (d, ()) -> a b d
arrUnpack :: Arrow a => a (Either (x, b) (x, d)) (Either (y, c) (y, d)) -> a (x, Either b d) (y, Either c d)
(->>) :: Arrow a => a (i1, input) (o1, middle) -> a (i2, middle) (o2, output) -> a (i2, (i1, input)) (o2, (o1, output))

module Control.Arrow.Mix.Category

-- | Sometimes we need to refine our morphism a bit; therefore, we use
--   <tt>Along f i o</tt> instead of just <tt>f</tt>.
type Along f input output i o = f (i, input) (o, output)

-- | Arrow morphism
type :~> f g = forall i o. f i o -> g i o

-- | Refined arrow morphism
type :~~> f g = forall i o. (i -> o) -> f i o -> g i o

-- | Something like a monad - but for arrows
class AlMonad m
alRet :: (AlMonad m, Arrow b) => b :~> m b
alLift :: (AlMonad m, Arrow b, Arrow c) => (Along b i1 o1 :~~> Along (m c) i2 o2) -> (m b i1 o1 -> m c i2 o2)

-- | Most of time we don't need refined morphisms. That's why we would want
--   a simpler combinator.
(~>>=) :: (AlMonad m, Arrow b, Arrow c) => m b i1 o1 -> (Along b i1 o1 :~> Along (m c) i2 o2) -> m c i2 o2

-- | Something like a functor - again, for arrows
class AlFunctor f
alMap :: (AlFunctor f, Arrow b, Arrow c) => (Along b i1 o1 :~> Along c i2 o2) -> (f b i1 o1 -> f c i2 o2)

-- | Just a trick to avoid specifying rank explicitly
type OhNo a b = b

-- | Declarations like <tt>instance Monad m =&gt; Functor m</tt> don't work
--   well in Haskell. That's why we need a newtype.
newtype (:$~) f a input output
Apply :: a input output OhNo f a input output -> :$~ f a input output
runApply :: :$~ f a input output -> a input output OhNo f a input output
instance AlMonad f => AlMonad ((:$~) f)
instance (AlMonad m, ArrowChoice a) => ArrowChoice (m :$~ a)
instance (AlMonad m, ArrowLoop a) => ArrowLoop (m :$~ a)
instance (AlMonad m, Arrow a) => Arrow (m :$~ a)
instance (AlMonad m, Arrow a) => Category (m :$~ a)
instance AlMonad m => AlFunctor ((:$~) m)


-- | We try to mix effects of two completely unrelated arrows <tt>a</tt>
--   and <tt>b</tt>, where <tt>b</tt> is considered pure, and <tt>a</tt> â€”
--   impure. Probably the most common use case would be <tt>a = Kleisli
--   IO</tt>. We perform all the pure calculations first, and do the impure
--   ones later.
--   
--   Usage example:
--   
--   <pre>
--   newtype Test input output = Test {runTest :: (Kleisli IO :+ Kleisli (State String)) input output}
--       deriving (Category, Arrow, ArrowChoice, ArrowLoop)
--   
--   runStateMorphism :: s -&gt; Kleisli (State s) :~&gt; (-&gt;)
--   runStateMorphism s al input = evalState (runKleisli al input) s
--   execTest :: Test input output -&gt; input -&gt; IO output
--   execTest t = runKleisli $ unPlus $ alMap (runStateMorphism "") $ runTest t
--   
--   rd = Test {runTest = liftImpure $ Kleisli $ const getLine}
--   wr = Test {runTest = liftImpure $ Kleisli putStrLn}
--   gt = Test {runTest = liftPure $ Kleisli $ const get}
--   pt = Test {runTest = liftPure $ Kleisli put}
--   
--   test =
--       proc () -&gt;
--           do line &lt;- rd -&lt; ()  -- effect from IO
--              pt -&lt; line        -- effect from State
--              line' &lt;- gt -&lt; () -- effect from State
--              wr -&lt; line'       -- effect from IO
--   </pre>
module Control.Arrow.Mix

-- | <tt>a :+ b</tt> is an arrow incapsulating both <tt>a</tt> and
--   <tt>b</tt> effects. It's functorial (and even monadic) in <tt>b</tt>.
data (:+) a b input output

-- | We can lift impure arrows
liftImpure :: (ArrowChoice a, ArrowLoop a, Arrow b) => a :~> (a :+ b)

-- | Pure arrows can be lifted too
liftPure :: (Arrow a, Arrow b) => b :~> (a :+ b)

-- | We need some way to extract the real computation from this
--   <tt>:+</tt>; fortunately, if we manage to reduce the pure arrow to a
--   function (using <tt>alMap</tt>), we can reduce the type <tt>a :+
--   (-&gt;)</tt> to <tt>a</tt>.
unPlus :: Arrow a => (a :+ (->)) :~> a

-- | If, for some reason, the "pure" arrow is, in fact, as impure as the
--   "impure" one, we still can extract the real computation.
unPlus' :: Arrow a => (a :+ a) :~> a

-- | (:+) is right commutative-associative: a :+ (b :+ c) and b :+ (a :+ c)
--   can be reduced to one another with <tt>plusTwist</tt> function
plusTwist :: (Arrow a, AlFunctor f, Arrow c) => (a :+ f c) :~> f (a :+ c)

-- | (:+) is also associative
plusAssoc :: (Arrow a, Arrow b, Arrow c) => (a :+ (b :+ c)) :~> ((a :+ b) :+ c)

-- | this function is experimental - no idea about how this would interact
--   with other arrow combinators and functions defined in this module
plusCommute :: (Arrow a, ArrowChoice b, ArrowLoop b) => (a :+ b) :~> (b :+ a)
instance Arrow a => AlMonad ((:+) a)
instance Arrow a => AlFunctor ((:+) a)
instance (Arrow a, Arrow b) => Category (a :+ b)
instance (Arrow a, Arrow b) => Arrow (a :+ b)
instance (Arrow a, ArrowLoop b) => ArrowLoop (a :+ b)
instance (Arrow a, ArrowChoice b) => ArrowChoice (a :+ b)
instance Arrow a => AlMonad (Mix a)
