-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | This is an IRC bot for Mafia and Resistance.
--   
@package anticiv
@version 0.1.0.5

module Network.Anticiv.Modules.Mafia.Data
data CardSuit
Club :: CardSuit
Spade :: CardSuit
Heart :: CardSuit
Diamond :: CardSuit
data CardValue
Two :: CardValue
Three :: CardValue
Four :: CardValue
Five :: CardValue
Six :: CardValue
Seven :: CardValue
Eight :: CardValue
Nine :: CardValue
Ten :: CardValue
Jack :: CardValue
Queen :: CardValue
King :: CardValue
Ace :: CardValue
data Card
Card :: CardSuit -> CardValue -> Card
data RoleCard
(:->) :: Card -> Role -> RoleCard
data RoleProposal
Propose :: Int -> RoleCard -> RoleProposal
data Role
CivicK :: CivicF -> Role
MafiaK :: MafiaF -> Role
CoupleK :: CoupleF -> Role
ChurchK :: ChurchF -> Role
VampireK :: VampireF -> Role
JustinK :: JustinF -> Role
TerroristK :: TerroristF -> Role
TriadK :: TriadF -> Role
data Priority
Highest :: Priority
High :: Priority
Medium :: Priority
Low :: Priority
Lowest :: Priority
data Observation
Friend :: Observation
Enemy :: Observation
Transparent :: Observation
class (Eq f, Ord f, Show f) => Faction f
factionKey :: Faction f => f -> Role
winsWith :: Faction f => f -> Role -> Bool
shareFaction :: Faction f => f -> Role -> Bool
getFactionCards :: Faction f => f -> [Card]
getRoleCards :: Faction f => f -> [Card]
proposeCards :: Faction f => f -> Int -> [RoleProposal]
rolePriority :: Faction f => f -> Priority
observation :: Faction f => f -> Observation
proxy :: (forall f. Faction f => f -> a) -> Role -> a
data CivicF
Rop :: CivicF
Dimitri :: CivicF
Detective :: CivicF
Inspector :: CivicF
ZeroDivisor :: CivicF
Gardener :: CivicF
BusDriver :: CivicF
SoulSaver :: CivicF
Hunter :: CivicF
Cupid :: CivicF
Stoiber :: CivicF
Doctor :: CivicF
CitJudge :: CivicF
Tree :: CivicF
NPSOwner :: CivicF
OilTanker :: CivicF
data MafiaF
Rom :: MafiaF
Spy :: MafiaF
MaffJudge :: MafiaF
data CoupleF
InLove :: CoupleF
data ChurchF
Pope :: ChurchF
Monk :: ChurchF
data VampireF
Dracula :: VampireF
Vampire :: VampireF
data JustinF
Justin :: JustinF
data TerroristF
Terrorist :: TerroristF
Pyromanian :: TerroristF
data TriadF
Rot :: TriadF
TriSpy :: TriadF
TriJudge :: TriadF
propose :: Faction f => f -> [Int] -> [RoleProposal]
bogus :: Faction f => (f -> Role) -> Role
instance Eq CardSuit
instance Show CardSuit
instance Ord CardSuit
instance Eq CardValue
instance Show CardValue
instance Ord CardValue
instance Eq Card
instance Show Card
instance Ord Card
instance Eq Priority
instance Ord Priority
instance Eq Observation
instance Ord Observation
instance Show Observation
instance Eq CivicF
instance Ord CivicF
instance Show CivicF
instance Eq MafiaF
instance Ord MafiaF
instance Show MafiaF
instance Eq CoupleF
instance Ord CoupleF
instance Show CoupleF
instance Eq ChurchF
instance Ord ChurchF
instance Show ChurchF
instance Eq VampireF
instance Ord VampireF
instance Show VampireF
instance Eq JustinF
instance Ord JustinF
instance Show JustinF
instance Eq TerroristF
instance Ord TerroristF
instance Show TerroristF
instance Eq TriadF
instance Ord TriadF
instance Show TriadF
instance Eq Role
instance Ord Role
instance Eq RoleCard
instance Show RoleCard
instance Eq RoleProposal
instance Faction TriadF
instance Faction TerroristF
instance Faction JustinF
instance Faction VampireF
instance Faction ChurchF
instance Faction CoupleF
instance Faction MafiaF
instance Faction CivicF
instance Faction Role
instance Show Role

module Network.Anticiv.Config
data ValueRef
StrVal :: (Atom String) -> ValueRef
IntVal :: (Atom Int) -> ValueRef
StrList :: (Atom [String]) -> ValueRef
Ctpl0 :: (Atom String) -> ValueRef
data ValueTemp
StrValT :: String -> ValueTemp
IntValT :: Int -> ValueTemp
StrListT :: [String] -> ValueTemp
CtplT :: String -> ValueTemp
Ctpl0T :: String -> ValueTemp
data Key
RefLeaf :: ValueRef -> Key
TempLeaf :: ValueTemp -> Key
Group :: Config -> Key
Module :: Config -> Key
Vocab :: Config -> Key
type Config = TST Key
parseConf :: ChParser m => m Config
oneOf :: ChParser m => [Char] -> m Char
ident :: ChParser m => m String
parseKey :: ChParser m => m (String, Key)
parseLeaf :: ChParser m => m (String, Key)
parseGroup :: ChParser m => m (String, Key)
parseModule :: ChParser m => m (String, Key)
parseVocab :: ChParser m => m (String, Key)
readConf :: (ChScanner m, ChAtoms m) => m (Maybe Config)
tmap :: Monad m => (a -> m b) -> TST a -> m (TST b)
atomify :: ChAtoms m => Key -> m Key
getKey :: String -> Config -> Maybe Key
mgetKey :: String -> String -> Config -> Maybe Key
getFirstKey :: [String] -> Config -> Maybe Key
mgetFirstKey :: String -> [String] -> Config -> Maybe Key
instance Eq ValueRef
instance Eq ValueTemp
instance Show ValueTemp
instance Functor TST
instance Show ValueRef

module Network.Anticiv.Monad
newtype BotT m a
BotT :: (BotState -> m (a, BotState)) -> BotT m a
runBotT :: BotT m a -> BotState -> m (a, BotState)
data User
User :: String -> String -> String -> Int -> User
userNick :: User -> String
userName :: User -> String
userHost :: User -> String
reauthId :: User -> Int
type UserA = Atom User
data BotState
BotState :: [UserA] -> [UserA] -> [HandlerA] -> [HandlerA] -> [HandlerA] -> [HandlerA] -> [AnticivA ()] -> Config -> [String] -> TST Config -> String -> AVL (UserA, String) -> TST String -> [(String, Packciv [String])] -> NominalDiffTime -> NominalDiffTime -> BotState
channelUsers :: BotState -> [UserA]
orphanedUsers :: BotState -> [UserA]
priorityChanmsg :: BotState -> [HandlerA]
emergencyChanmsg :: BotState -> [HandlerA]
priorityQuerymsg :: BotState -> [HandlerA]
emergencyQuerymsg :: BotState -> [HandlerA]
tickRecipients :: BotState -> [AnticivA ()]
botConfig :: BotState -> Config
moduleStack :: BotState -> [String]
localizations :: BotState -> TST Config
botLingua :: BotState -> String
linguaOverride :: BotState -> AVL (UserA, String)
moduleStereo :: BotState -> TST String
moduleLister :: BotState -> [(String, Packciv [String])]
lastMsg :: BotState -> NominalDiffTime
lastReport :: BotState -> NominalDiffTime
type MonadAnticiv m = (Functor m, Monad m, ChPrinter m, ChScanner m, ChClock m, ChChannelPrinter Target m, MonadBot m, ChAtoms m, ChRandom m)
type Anticiv a = forall m. MonadAnticiv m => m a
newtype Packciv a
Anticiv :: Anticiv a -> Packciv a
runAnticiv :: Packciv a -> Anticiv a
type AnticivA a = Atom (Packciv a)
class Monad m => MonadBot m
bget :: MonadBot m => m BotState
bput :: MonadBot m => BotState -> m ()
bmodify :: MonadBot m => (BotState -> BotState) -> m ()
bgets :: MonadBot m => (BotState -> a) -> m a
sleep :: ChClock m => Int -> m ()
type Handler = UserA -> String -> Packciv Bool
type HandlerA = Atom Handler
data Target
Log :: Target
Target :: String -> Target
Notice :: String -> Target
Address :: User -> Target
Raw :: Target

-- | Directs Log messages through the underlying MonadPrinter, and server
--   communication through the passed handle
newtype OutPlexT m a
OutPlex :: (Handle -> [Target] -> m (a, [Target])) -> OutPlexT m a
runOutPlex :: OutPlexT m a -> Handle -> [Target] -> m (a, [Target])
bkInt :: (MonadBot m, ChAtoms m) => String -> m Int
bkStr :: (MonadBot m, ChAtoms m) => String -> m String
bkStrL :: (MonadBot m, ChAtoms m) => String -> m [String]
bmodule :: MonadBot m => m String
bstereo :: MonadBot m => m String
instance MonadBot Packciv
instance ChRandom Packciv
instance ChCounter Packciv
instance ChAtoms Packciv
instance ChChannelPrinter Target Packciv
instance ChClock Packciv
instance ChScanner Packciv
instance ChPrinter Packciv
instance ChCounter m0 => ChCounter (OutPlexT m0)
instance ChAtoms m0 => ChAtoms (OutPlexT m0)
instance ChClock m0 => ChClock (OutPlexT m0)
instance ChRandom m0 => ChRandom (OutPlexT m0)
instance ChFinalizer m0 => ChFinalizer (OutPlexT m0)
instance ChScanner m0 => ChScanner (OutPlexT m0)
instance ChCounter m0 => ChCounter (BotT m0)
instance ChAtoms m0 => ChAtoms (BotT m0)
instance ChClock m0 => ChClock (BotT m0)
instance ChRandom m0 => ChRandom (BotT m0)
instance ChFinalizer m0 => ChFinalizer (BotT m0)
instance ChScanner m0 => ChScanner (BotT m0)
instance ChPrinter m0 => ChPrinter (BotT m0)
instance Eq User
instance Eq Target
instance MonadBot m => MonadBot (InRedirT m)
instance MonadBot m => MonadBot (OutRedirT m)
instance MonadBot m => MonadBot (OutPlexT m)
instance (MonadIO m, ChPrinter m, MonadBot m, ChClock m, ChAtoms m) => ChChannelPrinter Target (OutPlexT m)
instance (MonadIO m, ChPrinter m, MonadBot m, ChClock m, ChAtoms m) => ChPrinter (OutPlexT m)
instance MonadIO m => MonadIO (OutPlexT m)
instance MonadTrans OutPlexT
instance Monad m => Monad (OutPlexT m)
instance (Functor f, Monad f) => Applicative (OutPlexT f)
instance Functor f => Functor (OutPlexT f)
instance Monad m => MonadBot (BotT m)
instance Functor Packciv
instance Monad Packciv
instance Tuplify (Atom a) (Atom a)
instance Tuplify User User
instance Show User
instance MonadIO m => MonadIO (BotT m)
instance MonadTrans BotT
instance Monad m => Monad (BotT m)
instance (Functor f, Monad f) => Applicative (BotT f)
instance Functor f => Functor (BotT f)

module Network.Anticiv.Masks
class MatchMask mm l | mm -> l
matchmask :: (MatchMask mm l, MonadAnticiv m) => mm -> StateT String m (Maybe l)
verbosemask :: MatchMask mm l => mm -> String
data CatchString
Remaining :: CatchString
RemString :: CatchString
QuotString :: CatchString
ServerHost :: CatchString
data CatchUser
ChannelUser :: CatchUser
UserMask :: CatchUser
data CatchInt
CatchInt :: CatchInt
data Token
Token :: String -> Token
CIToken :: String -> Token
CIString :: String -> Token
newtype Optional a
Optional :: a -> Optional a
newtype Which a
Which :: [a] -> Which a
takeUntil :: (a -> Bool) -> [a] -> [a]
nickfirstchars :: [Char]
nicknextchars :: [Char]
namefirstchars :: [Char]
namenextchars :: [Char]
hostfirstchars :: [Char]
hostnextchars :: [Char]
strEq :: [Char] -> [Char] -> Bool
simul :: (MonadTrans t, Monad (t m), Monad m) => (t1 -> m t2) -> (t1 -> m t3) -> t1 -> t m (t2, t3)
firstSeq :: Monad m => (a -> m (Maybe b)) -> [a] -> m (Maybe (a, b))
trymask :: (MatchMask m r, Tuplify r t) => m -> String -> Anticiv (Maybe t)
(#->) :: (MatchMask m r, Tuplify r t) => m -> (t -> Anticiv ()) -> String -> Anticiv Bool
(#->>) :: (MatchMask m r, Tuplify r t) => m -> Anticiv () -> String -> Anticiv Bool
(#||) :: Monad m => m Bool -> m Bool -> m Bool
(.||) :: Monad m => (a -> m Bool) -> (a -> m Bool) -> (a -> m Bool)
(&) :: b -> (b -> c) -> c
instance (MatchMask x r, MatchMask xs rs, Append r rs rx) => MatchMask (Cons x xs) rx
instance MatchMask Nil Nil
instance (MatchMask a r, Append (Cons a Nil) r ar) => MatchMask (Which a) ar
instance (MatchMask a ar, IntoMaybe ar am, Append am Nil am) => MatchMask (Optional a) am
instance MatchMask CatchUser (Cons UserA Nil)
instance MatchMask CatchString (Cons String Nil)
instance MatchMask CatchInt (Cons Int Nil)
instance MatchMask Token Nil
instance MatchMask String Nil
instance Tuplify Token Token

module Network.Anticiv.Convenience
regPriorityChanmsg :: (Atom Handler -> UserA -> String -> Anticiv Bool) -> Anticiv (Atom Handler)
unregPriorityChanmsg :: Atom Handler -> Anticiv ()
regEmergencyChanmsg :: (Atom Handler -> UserA -> String -> Anticiv Bool) -> Anticiv (Atom Handler)
unregEmergencyChanmsg :: Atom Handler -> Anticiv ()
regPriorityQuerymsg :: (Atom Handler -> UserA -> String -> Anticiv Bool) -> Anticiv (Atom Handler)
unregPriorityQuerymsg :: HandlerA -> Anticiv ()
regEmergencyQuerymsg :: (HandlerA -> UserA -> String -> Anticiv Bool) -> Anticiv (Atom Handler)
unregEmergencyQuerymsg :: HandlerA -> Anticiv ()
regTickRecipient :: (AnticivA () -> Anticiv ()) -> Anticiv (AnticivA ())
unregTickRecipient :: AnticivA () -> Anticiv ()
bchan :: (MonadBot m, ChAtoms m) => m String
bnick :: (MonadBot m, ChAtoms m) => m String
bprefix :: (MonadBot m, ChAtoms m) => m String
switchTo :: MonadBot m => String -> m a -> m a
blStr :: (MonadBot m, ChAtoms m) => String -> m String
blStrL :: (MonadBot m, ChAtoms m) => String -> m [String]
blInt :: (MonadBot m, ChAtoms m) => String -> m Int
blFun :: (MonadBot m, ChAtoms m) => String -> m (String -> String)
bvStr :: (MonadBot m, ChAtoms m, ChRandom m) => String -> String -> m String
private :: UserA -> String -> Anticiv ()
address :: UserA -> String -> Anticiv ()
log :: String -> Anticiv ()
action :: String -> Anticiv ()
notice :: UserA -> String -> Anticiv ()
type Speaker = forall r. PrintlType r => UserA -> String -> r
privatefl :: Speaker
addressfl :: Speaker
actionfl :: PrintlType r => String -> r
noticefl :: Speaker
globalfl :: PrintlType r => String -> r
newtype PrintlArgW
PrintlArgW :: (String -> Anticiv String) -> PrintlArgW
runPrintlArgW :: PrintlArgW -> String -> Anticiv String
class PrintlType t
emitl :: PrintlType t => Maybe UserA -> Anticiv Target -> (String -> Anticiv String) -> String -> [PrintlArgW] -> t
printlargw :: PrintlArg a => a -> PrintlArgW
class PrintlArg a
showl :: PrintlArg a => String -> a -> Anticiv String
data Lookup
Lookup :: String -> Lookup
Lookupf :: String -> [PrintlArgW] -> Lookup
ulang :: UserA -> Anticiv String
repll :: String -> [String] -> Anticiv String
data LocalToken
LocalT :: UserA -> String -> LocalToken
bsetStereo :: MonadBot m => String -> m ()
instance [incoherent] MatchMask LocalToken Nil
instance [incoherent] PrintlArg Lookup
instance [incoherent] PrintlArg Int
instance [incoherent] PrintlArg String
instance [incoherent] (PrintlArg a, PrintlType r) => PrintlType (a -> r)
instance [incoherent] (MonadAnticiv m) => PrintlType (m ())

module Network.Anticiv.Modules.Mafia.Core
data MafiaState
MafiaState :: UserA -> AVL (UserA, PlayerState) -> AVL ((Subject, PlayerId), Int) -> [(Subject, PlayerId)] -> Bool -> Bool -> Int -> AVL Card -> [PlayerId] -> [HandlerA] -> Bool -> Maybe (PlayerId, PlayerId) -> MafiaState
mafiaInitiator :: MafiaState -> UserA
mafiaPlayers :: MafiaState -> AVL (UserA, PlayerState)
voteScore :: MafiaState -> AVL ((Subject, PlayerId), Int)
votedAlready :: MafiaState -> [(Subject, PlayerId)]
mafiaDone :: MafiaState -> Bool
triadDone :: MafiaState -> Bool
partyDay :: MafiaState -> Int
actionsDone :: MafiaState -> AVL Card
safeTonight :: MafiaState -> [PlayerId]
lostHandlers :: MafiaState -> [HandlerA]
isNight :: MafiaState -> Bool
coupledPlayers :: MafiaState -> Maybe (PlayerId, PlayerId)
type MafiaStateA = Atom MafiaState
data PlayerState
PlayerState :: Bool -> [Card] -> [Role] -> Bool -> PlayerState
playerAlive :: PlayerState -> Bool
playerCards :: PlayerState -> [Card]
playerRoles :: PlayerState -> [Role]
playerSaved :: PlayerState -> Bool
NopeNotYet :: PlayerState
data FinishReason
Deathmatch :: FinishReason
JustinWon :: FinishReason
data Subject
Execution :: Subject
MafiaKill :: Subject
TriadKill :: Subject

-- | Phantom type. Just to make sure. If a function gets a <a>PlayerId</a>
--   passed, we're already sure it is contained in <a>mafiaPlayers</a> and
--   don't need to handle the <a>Nothing</a> case any more, as it is
--   already handled in <a>toPID</a>.
newtype PlayerId
UnsafePlayerId :: UserA -> PlayerId
fromPID :: PlayerId -> UserA
toPID :: MafiaStateA -> UserA -> Anticiv (Maybe PlayerId)
withPID :: MafiaStateA -> UserA -> (PlayerId -> Anticiv ()) -> Anticiv ()
withAlivePID :: MafiaStateA -> UserA -> (PlayerId -> Anticiv ()) -> Anticiv ()
withInitiator :: MafiaStateA -> UserA -> (PlayerId -> Anticiv ()) -> Anticiv ()
forAllPlayers_ :: MafiaStateA -> (PlayerId -> Anticiv ()) -> Anticiv ()
forAllPlayers :: MafiaStateA -> (PlayerId -> Anticiv a) -> Anticiv [a]
forAllMafiosi :: MafiaStateA -> (PlayerId -> Anticiv a) -> Anticiv [a]
forAllMafiosi_ :: MafiaStateA -> (PlayerId -> Anticiv ()) -> Anticiv ()
forAllTriadists :: MafiaStateA -> (PlayerId -> Anticiv a) -> Anticiv [a]
forAllTriadists_ :: MafiaStateA -> (PlayerId -> Anticiv ()) -> Anticiv ()
forAllPred :: MafiaStateA -> (Role -> Bool) -> (PlayerId -> Anticiv a) -> Anticiv [a]
forAllPred_ :: MafiaStateA -> (Role -> Bool) -> (PlayerId -> Anticiv ()) -> Anticiv ()

-- | Tries to match a predicate on any of the player's roles
(%|) :: (MafiaStateA, PlayerId) -> (Role -> Bool) -> Anticiv Bool

-- | Runs a function on the most important of the player's roles
(%&) :: (MafiaStateA, PlayerId) -> (Role -> a) -> Anticiv a

-- | Like %&amp;, but makes sure the observation reveals an oblique result
(%|&) :: (MafiaStateA, PlayerId) -> (Role -> a) -> Anticiv a

-- | Like %&amp;, but takes another player
(%&&) :: (MafiaStateA, PlayerId) -> (Role -> Role -> a) -> PlayerId -> Anticiv a
seekRole :: Faction f => MafiaStateA -> f -> Anticiv [PlayerId]
seekUnusedRole :: Faction f => MafiaStateA -> f -> Anticiv [PlayerId]
seekCard :: Faction f => MafiaStateA -> PlayerId -> f -> Anticiv [Card]
seekUnusedCard :: Faction f => MafiaStateA -> PlayerId -> f -> Anticiv [Card]
isMafioso :: MafiaStateA -> PlayerId -> Anticiv Bool
isTriadist :: MafiaStateA -> PlayerId -> Anticiv Bool
pget :: MafiaStateA -> PlayerId -> Anticiv PlayerState
pgets :: MafiaStateA -> PlayerId -> (PlayerState -> a) -> Anticiv a
pput :: MafiaStateA -> PlayerId -> PlayerState -> Anticiv ()
pmodify :: MafiaStateA -> PlayerId -> (PlayerState -> PlayerState) -> Anticiv ()
joinParty :: MafiaStateA -> UserA -> Anticiv PlayerId
(#>) :: a -> Atom a -> Anticiv ()
(#<) :: (a -> b) -> Atom a -> Anticiv b
(<>#) :: Atom a -> (a -> a) -> Anticiv ()
(<>&) :: (MafiaStateA, PlayerId) -> (PlayerState -> PlayerState) -> Anticiv ()
(&>) :: PlayerState -> (MafiaStateA, PlayerId) -> Anticiv ()
(&<) :: (PlayerState -> a) -> (MafiaStateA, PlayerId) -> Anticiv a
selectRoles :: Int -> Anticiv [RoleCard]
chooseN :: Int -> [RoleProposal] -> Anticiv [RoleCard]

-- | That's Fisher-Yates, if I remember correctly
shuffle :: [a] -> Anticiv [a]
assignRoles :: MafiaStateA -> Anticiv ()
hasVoted :: MafiaStateA -> PlayerId -> Subject -> Anticiv Bool
playerVote :: MafiaStateA -> PlayerId -> PlayerId -> Subject -> Speaker -> Anticiv Bool
partyFinished :: MafiaStateA -> Anticiv Bool
actionDone :: Faction f => MafiaStateA -> PlayerId -> f -> Anticiv ()
instance Eq PlayerState
instance Eq FinishReason
instance Ord FinishReason
instance Show FinishReason
instance Eq Subject
instance Ord Subject
instance Show Subject
instance Eq PlayerId
instance Ord PlayerId
instance Indexable Card Card Card
instance Indexable PlayerId PlayerId PlayerId
instance Indexable (Atom a) (Atom a) (Atom a)

module Network.Anticiv.Modules.Mafia
initMafia :: Packciv Lister
listMafia :: ListerA -> Lister

module Network.Anticiv.Modules.Ironforge
initIronforge :: Packciv (Packciv [String])
listIronforge :: Packciv [String]
instance [incoherent] MonadBot m => MonadBot (JoinerT m)
instance [incoherent] MonadBot m => MonadBot (RecorderT m)
instance [incoherent] ChChannelPrinter Target m0 => ChChannelPrinter Target (HereStringT m0)
instance [incoherent] ChChannelPrinter DPlayerId m0 => ChChannelPrinter DPlayerId (MonoPrinterT m0)
instance [incoherent] ChExpanderEnv m0 => ChExpanderEnv (MonoPrinterT m0)
instance [incoherent] ChClock m0 => ChClock (MonoPrinterT m0)
instance [incoherent] ChRandom m0 => ChRandom (MonoPrinterT m0)
instance [incoherent] ChScanner m0 => ChScanner (MonoPrinterT m0)
instance [incoherent] (Functor m, ChExpand m) => ChExpand (MonoPrinterT m)
instance [incoherent] ChPrinter m => ChExtendedPrinter (MonoPrinterT m)
instance [incoherent] ChPrinter m => ChPrinter (MonoPrinterT m)
instance [incoherent] MonadTrans MonoPrinterT
instance [incoherent] Functor m => Functor (MonoPrinterT m)
instance [incoherent] Monad m => Monad (MonoPrinterT m)

module Network.Anticiv.Modules.Base
initBase :: Packciv (Packciv [String])
listBase :: Packciv [String]

module Network.Anticiv.Modules.Barkeeper
initBarkeeper :: Packciv (Packciv [String])
listBarkeeper :: Packciv [String]
