-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The base modules of the Definitive framework.
--   
@package definitive-base
@version 2.3

module Algebra.Core

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle :: *

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle
type Bytes = ByteString
readBytes :: String -> IO Bytes
writeBytes :: String -> Bytes -> IO ()
readHBytes :: Handle -> IO Bytes
writeHBytes :: Handle -> Bytes -> IO ()
type Chunk = ByteString
readChunk :: String -> IO Chunk
writeChunk :: String -> Chunk -> IO ()
readHChunk :: Handle -> IO Chunk
writeHChunk :: Handle -> Chunk -> IO ()
readString :: String -> IO String
writeString :: String -> String -> IO ()
readHString :: Handle -> IO String
writeHString :: Handle -> String -> IO ()
data Void
type (:*:) a b = (a, b)
type (:+:) a b = Either a b

-- | The class of all types that have a binary operation. Note that the
--   operation isn't necesarily commutative (in the case of lists, for
--   example)
class Semigroup m where (+) = (+)
(+) :: Semigroup m => m -> m -> m

-- | A monoid is a semigroup with a null element such that <tt>zero + a ==
--   a + zero == a</tt>
class Semigroup m => Monoid m where zero = 0
zero :: Monoid m => m
class Monoid m => Disjonctive m where negate = (zero -) a - b = a + negate b
negate :: Disjonctive m => m -> m
(-) :: Disjonctive m => m -> m -> m
class Monoid m => Semiring m where (*) = (*)
(*) :: Semiring m => m -> m -> m
class Semiring m => Ring m where one = 1
one :: Ring m => m
class (Ring m, Disjonctive m) => Invertible m where recip = (one /) a / b = a * recip b
recip :: Invertible m => m -> m
(/) :: Invertible m => m -> m -> m
class (Semigroup a, Semigroup b) => SubSemi a b
cast :: SubSemi a b => b -> a
class Unit f
pure :: Unit f => a -> f a

-- | A monoid on category endomorphisms under composition
newtype Endo k a
Endo :: k a a -> Endo k a
runEndo :: Endo k a -> k a a
newtype StrictEndo a
StrictEndo :: (a -> a) -> StrictEndo a
runStrictEndo :: StrictEndo a -> a -> a

-- | The dual of a monoid is the same as the original, with arguments
--   reversed
newtype Dual m
Dual :: m -> Dual m
getDual :: Dual m -> m

-- | The Product monoid
newtype Product a
Product :: a -> Product a
getProduct :: Product a -> a

-- | An ordered list. The semigroup instance merges two lists so that the
--   result remains in ascending order.
newtype OrdList a
OrdList :: [a] -> OrdList a
getOrdList :: OrdList a -> [a]
newtype Interleave a
Interleave :: [a] -> Interleave a
interleave :: Interleave a -> [a]

-- | A monoid on Maybes, where the sum is the leftmost non-Nothing value.
newtype Accum a
Accum :: Maybe a -> Accum a
getAccum :: Accum a -> Maybe a

-- | The Max monoid, where <tt>(+) =~ max</tt>
newtype Max a
Max :: a -> Max a
getMax :: Max a -> a

-- | The Min monoid, where <tt>(+) =~ min</tt>
newtype Min a
Min :: a -> Min a
getMin :: Min a -> a

-- | The Identity Functor
newtype Id a
Id :: a -> Id a
getId :: Id a -> a
class Deductive k
(.) :: Deductive k => k b c -> k a b -> k a c
class Deductive k => Category k
id :: Category k => k a a
(<<<) :: Category k => k b c -> k a b -> k a c
(>>>) :: Category k => k a b -> k b c -> k a c
(+++) :: Split k => (a -> k c c) -> (b -> k d d) -> (a :+: b) -> k (c, d) (c, d)
class Category k => Choice k
(<|>) :: Choice k => k a c -> k b c -> k (a :+: b) c
class Category k => Split k
(<#>) :: Split k => k a c -> k b d -> k (a, b) (c, d)
type Constraint a = a -> a
c'listOf :: Constraint a -> Constraint [a]
c'list :: Constraint [a]
c'int :: Constraint Int
c'char :: Constraint Char
c'string :: Constraint String
c'float :: Constraint Float
c'_ :: Constraint a
const :: Unit m => a -> m a
(&) :: a -> (a -> b) -> b
($^) :: (a -> b -> c) -> b -> a -> c
is :: a -> (a -> Bool) -> Bool
fix :: (a -> a) -> a
first :: Split k => k a b -> k (a, c) (b, c)
second :: Split k => k a b -> k (c, a) (c, b)
ifThenElse :: Bool -> a -> a -> a
bool :: a -> a -> Bool -> a
extreme :: Bounded a => Bool -> a
guard :: (Unit m, Monoid (m ())) => Bool -> m ()
fail :: String -> a
unit :: Unit m => m ()
when :: Unit m => Bool -> m () -> m ()
unless :: Unit m => Bool -> m () -> m ()
tailSafe :: [a] -> [a]
headDef :: a -> [a] -> a
fromMaybe :: a -> Maybe a -> a
rmod :: (RealFloat m, Invertible m) => m -> m -> m
inside :: Ord t => t -> t -> (t -> Bool)
swap :: (a, b) -> (b, a)

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering
inOrder :: Ord t => t -> t -> (t, t, Bool)
insertOrd :: Ord t => t -> [t] -> [t]
invertOrd :: Ordering -> Ordering
data Assoc k a
Assoc :: k -> a -> Assoc k a
assoc :: a -> Assoc a a

-- | A range of shape (min,max) of ordered values.
--   
--   Such ranges may be multiplied to create n-dimensional ranges for which
--   equivalence means sharing an n-dimensional subrange. They may be very
--   useful in creating Maps that partition an n-dimensional space in which
--   we may query for subrange membership with logarithmic complexity for
--   any point P (a point is a subrange of volume 0, or `(pure x0,...,pure
--   xn) where (x0,..,xn) = p`).
--   
--   Indeed, a point is equivalent to a range iff it belongs to that range.
newtype Range a
Range :: (a, a) -> Range a
amb :: IO a -> IO a -> IO a
unamb :: a -> a -> a

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a
instance Monoid (Interleave a)
instance Unit OrdList
instance Ord a => Monoid (OrdList a)
instance Monoid m => Monoid (Dual m)
instance Eq a => Eq (Product a)
instance Ord a => Ord (Product a)
instance Show a => Show (Product a)
instance Eq a => Eq (Max a)
instance Ord a => Ord (Max a)
instance Bounded a => Bounded (Max a)
instance Show a => Show (Max a)
instance Eq a => Eq (Min a)
instance Show a => Show (Min a)
instance Eq a => Eq (OrdList a)
instance Ord a => Ord (OrdList a)
instance Show a => Show (OrdList a)
instance (Show k, Show a) => Show (Assoc k a)
instance Semigroup (Interleave a)
instance Ord a => Eq (Range a)
instance Ord a => Ord (Range a)
instance Unit Range
instance Ord k => Ord (Assoc k a)
instance Ord k => Eq (Assoc k a)
instance Ord a => Semigroup (OrdList a)
instance Ring m => Ring (Dual m)
instance Semiring m => Semiring (Dual m)
instance Semigroup m => Semigroup (Dual m)
instance (Ord a, Bounded a) => Ring (Min a)
instance (Ord a, Bounded a) => Semiring (Min a)
instance (Ord a, Bounded a) => Monoid (Min a)
instance Ord a => Semigroup (Min a)
instance Bounded a => Bounded (Min a)
instance Ord a => Ord (Min a)
instance (Ord a, Bounded a) => Ring (Max a)
instance (Ord a, Bounded a) => Semiring (Max a)
instance (Ord a, Bounded a) => Monoid (Max a)
instance Ord a => Semigroup (Max a)
instance Semigroup (Id a)
instance Unit Id
instance Show a => Show (Id a)
instance Unit Accum
instance Monoid a => Monoid (Accum a)
instance Monoid a => Semigroup (Accum a)
instance Semigroup (StrictEndo a)
instance Category k => Monoid (Endo k a)
instance Category k => Semigroup (Endo k a)
instance Ring a => Monoid (Product a)
instance Ring a => Semigroup (Product a)
instance Split (->)
instance Choice (->)
instance Category (->)
instance Deductive (->)
instance Unit IO
instance Unit Tree
instance Unit []
instance Unit ((->) b)
instance Monoid w => Unit ((,) w)
instance Unit Maybe
instance Unit (Either a)
instance Invertible Double
instance Invertible Float
instance Invertible Rational
instance (Ring a, Ring b) => Ring (a :*: b)
instance (Semiring a, Semiring b) => Semiring (a :*: b)
instance Monoid a => Ring [a]
instance Monoid a => Semiring [a]
instance Ring Double
instance Semiring Double
instance Ring Float
instance Semiring Float
instance Ring Integer
instance Semiring Integer
instance Ring Rational
instance Semiring Rational
instance Ring Int
instance Semiring Int
instance Ring Bool
instance Semiring Bool
instance (Disjonctive a, Disjonctive b) => Disjonctive (a :*: b)
instance Disjonctive Bool
instance Disjonctive Double
instance Disjonctive Float
instance Disjonctive Rational
instance Disjonctive Integer
instance Disjonctive Int
instance Semigroup a => SubSemi a a
instance Monoid a => SubSemi a Void
instance Monoid a => SubSemi a ()
instance Monoid (Maybe a)
instance Monoid Bool
instance (SubSemi b a, Monoid a) => Monoid (a :+: b)
instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)
instance (Monoid a, Monoid b) => Monoid (a :*: b)
instance Monoid [a]
instance Monoid Chunk
instance Monoid Bytes
instance Monoid Double
instance Monoid Float
instance Monoid Rational
instance Monoid Integer
instance Monoid Int
instance Monoid ()
instance Monoid Void
instance Semigroup (Maybe a)
instance SubSemi b a => Semigroup (a :+: b)
instance (Semigroup a, Semigroup b, Semigroup c) => Semigroup (a, b, c)
instance (Semigroup a, Semigroup b) => Semigroup (a :*: b)
instance Semigroup [a]
instance Semigroup Chunk
instance Semigroup Bytes
instance Semigroup Double
instance Semigroup Float
instance Semigroup Rational
instance Semigroup Integer
instance Semigroup Int
instance Semigroup Bool
instance Semigroup ()
instance Semigroup Void

module Algebra.Classes
class Functor f
map :: Functor f => (a -> b) -> f a -> f b
class (Unit f, Functor f) => Applicative f where fs <*> xs = fs >>= \ f -> map f xs
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
class Applicative m => Monad m where join m = m >>= id ma >>= k = join (map k ma)
join :: Monad m => m (m a) -> m a
(>>=) :: Monad m => m a -> (a -> m b) -> m b
class Counit w
extract :: Counit w => w a -> a
class (Functor w, Counit w) => Comonad w where duplicate = (=>> id) wa =>> k = map k (duplicate wa)
duplicate :: Comonad w => w a -> w (w a)
(=>>) :: Comonad w => w a -> (w a -> b) -> w b
class Functor f => Foldable f
fold :: (Foldable f, Monoid m) => f m -> m
class Functor t => Traversable t
sequence :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | The class of all monads that have a fixpoint
class Monad m => MonadFix m
mfix :: MonadFix m => (a -> m a) -> m a
class MonadTrans t
lift :: (MonadTrans t, Monad m) => m a -> t m a
class MonadTrans t => ConcreteMonad t
generalize :: (ConcreteMonad t, Monad m) => t Id a -> t m a
class Monad m => MonadState s m | m -> s where put = modify . const modify f = get >>= put . f
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()
modify :: MonadState s m => (s -> s) -> m ()
class Monad m => MonadReader r m | m -> r
ask :: MonadReader r m => m r
local :: MonadReader r m => (r -> r) -> m a -> m a
class (Monad m, Monoid w) => MonadWriter w m | m -> w
tell :: MonadWriter w m => w -> m ()
listen :: MonadWriter w m => m a -> m (w, a)
censor :: MonadWriter w m => m (a, w -> w) -> m a
class (SubSemi acc w, MonadWriter w m) => MonadCounter w acc m | m -> acc
getCounter :: MonadCounter w acc m => m acc
class Monad m => MonadIO m
liftIO :: MonadIO m => IO a -> m a
class Monad m => MonadList m
fork :: MonadList m => [a] -> m a
class Monad m => MonadCont m
callCC :: MonadCont m => (forall b. (a -> m b) -> m b) -> m a
class Monad m => MonadError e m | m -> e
throw :: MonadError e m => e -> m a
catch :: MonadError e m => (e -> m a) -> m a -> m a
class MonadFix t => MonadFuture m t | t -> m
future :: MonadFuture m t => m a -> t a


-- | A module for functors
module Algebra.Functor
class Functor f
map :: Functor f => (a -> b) -> f a -> f b
class Cofunctor f
comap :: Cofunctor f => (a -> b) -> f b -> f a
class Bifunctor p where dimap f g = promap f . map g
dimap :: Bifunctor p => (c -> a) -> (b -> d) -> p a b -> p c d
class Commutative f
commute :: Commutative f => f a b -> f b a
class Functor t => Contravariant t
collect :: (Contravariant t, Functor f) => f (t a) -> t (f a)
newtype Strict a
Strict :: a -> Strict a
lazy :: Strict a -> a

-- | The Identity Functor
newtype Id a
Id :: a -> Id a
getId :: Id a -> a

-- | The Constant Functor
newtype Const a b
Const :: a -> Const a b
getConst :: Const a b -> a

-- | A motherflippin' functor
newtype Flip f a b
Flip :: f b a -> Flip f a b
unFlip :: Flip f a b -> f b a

-- | The Composition functor
newtype (:.:) f g a
Compose :: f (g a) -> (:.:) f g a
getCompose :: (:.:) f g a -> f (g a)
data (:**:) f g a
(:**:) :: f a -> g a -> (:**:) f g a
newtype (:++:) f g a
Sum :: f a :+: g a -> (:++:) f g a
getSum :: (:++:) f g a -> f a :+: g a

-- | A functor for ordered lists
newtype Increasing k a
Increasing :: ((OrdList :.: Assoc k) a) -> Increasing k a
emerge :: (Functor f, Unit g) => (f :.: g) a -> (f :.: g) (g a)
flip :: (Contravariant c, Functor f) => f (c a) -> c (f a)

-- | The Contravariant version of <tt>traverse</tt>
project :: (Contravariant c, Functor f) => (a -> c b) -> f a -> c (f b)
factor :: (Contravariant c, Unit c, Bifunctor f, Functor (f a)) => f (c a) (c b) -> c (f a b)
(<$>) :: Functor f => (a -> b) -> f a -> f b
(|||) :: (Choice k, Functor (k a), Functor (k b)) => k a c -> k b d -> k (a :+: b) (c :+: d)
(<$) :: Functor f => b -> f a -> f b
(<&>) :: Functor f => f a -> (a -> b) -> f b
void :: Functor f => f a -> f ()
left :: (Choice k, Functor (k a), Functor (k c)) => k a b -> k (a :+: c) (b :+: c)
right :: (Choice k, Functor (k a), Functor (k c)) => k a b -> k (c :+: a) (c :+: b)
promap :: Cofunctor (Flip f c) => (a -> b) -> f b c -> f a c
map2 :: (Functor f, Functor f') => (a -> b) -> f (f' a) -> f (f' b)
map3 :: (Functor f, Functor f', Functor f'') => (a -> b) -> f (f' (f'' a)) -> f (f' (f'' b))
instance Functor OrdList
instance Functor Interleave
instance Semigroup (f b a) => Semigroup (Flip f a b)
instance Monoid (f b a) => Monoid (Flip f a b)
instance Functor (Increasing k)
instance Monad IO
instance Applicative IO
instance Functor IO
instance Functor ((->) a)
instance Functor ((,) b)
instance Functor Maybe
instance Functor (Either b)
instance (Functor f, Functor g) => Functor (f :++: g)
instance (Functor f, Functor g) => Functor (f :**: g)
instance (Contravariant f, Contravariant g) => Contravariant (f :.: g)
instance (Functor f, Functor g) => Functor (f :.: g)
instance (Unit f, Unit g) => Unit (f :.: g)
instance Ord k => Monoid (Increasing k a)
instance Ord k => Semigroup (Increasing k a)
instance Functor (Assoc k)
instance Monoid a => Applicative (Const a)
instance Monoid a => Unit (Const a)
instance Functor (Const a)
instance Monoid a => Monoid (Const a b)
instance Semigroup a => Semigroup (Const a b)
instance Monad Strict
instance Applicative Strict
instance Functor Strict
instance Unit Strict
instance Monad Id
instance Applicative Id
instance Functor Id
instance Functor Tree
instance Functor []
instance Commutative (,)
instance Contravariant ((->) a)
instance Contravariant Strict
instance Contravariant Id
instance Bifunctor (->)
instance Cofunctor (Flip (->) a)
instance (Functor f, Cofunctor g) => Cofunctor (f :.: g)


-- | A module describing applicative functors
module Algebra.Applicative
class (Unit f, Functor f) => Applicative f where fs <*> xs = fs >>= \ f -> map f xs
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | A wrapper type for lists with zipping Applicative instances, such that
--   <tt>Zip [f1,...,fn] <a>&lt;*&gt;</a> Zip [x1,...,xn] == Zip [f1
--   x1,...,fn xn]</tt>
newtype Zip f a
Zip :: f a -> Zip f a
deZip :: Zip f a -> f a

-- | A wrapper for applicative functors with actions executed in the
--   reverse order
newtype Backwards f a
Backwards :: f a -> Backwards f a
forwards :: Backwards f a -> f a
c'zip :: Constraint (f a) -> Constraint (Zip f a)
c'backwards :: Constraint (f a) -> Constraint (Backwards f a)
(*>) :: Applicative f => f b -> f a -> f a
(<*) :: Applicative f => f a -> f b -> f a
(<**>) :: Applicative f => f (a -> b) -> f a -> f b
ap :: Applicative f => f (a -> b) -> f a -> f b
between :: Applicative f => f b -> f c -> f a -> f a
liftA :: Functor f => (a -> b) -> (f a -> f b)
liftA2 :: Applicative f => (a -> b -> c) -> (f a -> f b -> f c)
liftA3 :: Applicative f => (a -> b -> c -> d) -> (f a -> f b -> f c -> f d)
liftA4 :: Applicative f => (a -> b -> c -> d -> e) -> (f a -> f b -> f c -> f d -> f e)
forever :: Applicative f => f a -> f b
zipWith :: Applicative (Zip f) => (a -> b -> c) -> f a -> f b -> f c
zipWith3 :: Applicative (Zip f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
plusA :: (Applicative f, Semigroup a) => f a -> f a -> f a
zeroA :: (Unit f, Monoid a) => f a
instance Functor f => Functor (Backwards f)
instance Unit f => Unit (Backwards f)
instance Ring (f a) => Ring (Backwards f a)
instance Semiring (f a) => Semiring (Backwards f a)
instance Monoid (f a) => Monoid (Backwards f a)
instance Semigroup (f a) => Semigroup (Backwards f a)
instance Foldable f => Foldable (Zip f)
instance Monoid k => Unit (Increasing k)
instance (Applicative f, Monoid (g a)) => Monoid ((:.:) f g a)
instance (Applicative f, Semigroup (g a)) => Semigroup ((:.:) f g a)
instance Applicative f => Applicative (Backwards f)
instance Applicative (Zip Tree)
instance Unit (Zip Tree)
instance Applicative (Zip [])
instance Unit (Zip [])
instance Functor f => Functor (Zip f)
instance (Applicative (Zip f), Monoid a) => Monoid (Zip f a)
instance (Applicative (Zip f), Semigroup a) => Semigroup (Zip f a)
instance (Applicative f, Applicative g) => Applicative (f :.: g)
instance Monad Tree
instance Applicative Tree
instance (Applicative f, Applicative g) => Applicative (f :**: g)
instance (Unit f, Unit g) => Unit (f :**: g)
instance (Monoid k, Ord k) => Monad (Increasing k)
instance (Monoid k, Ord k) => Applicative (Increasing k)
instance Monoid k => Unit (Assoc k)
instance Monoid w => Monad ((,) w)
instance Monoid w => Applicative ((,) w)
instance Monad ((->) a)
instance Ring b => Ring (a -> b)
instance Semiring b => Semiring (a -> b)
instance Monoid b => Monoid (a -> b)
instance Semigroup b => Semigroup (a -> b)
instance Applicative ((->) a)
instance Monad (Either a)
instance Applicative (Either a)


-- | A module providing simple Lens functionality.
--   
--   Lenses are a Haskell abstraction that allows you to access and modify
--   part of a structure, compensating for and improving upon Haskell's
--   horrendous record syntax and giving Haskell a first-class record
--   system.
--   
--   This module defines three kinds of Lenses : Lenses that allow you to
--   access part of a structure; Traversals that allow you to modify part
--   of a structure; and Isos which may be reversed. Lenses of any kind can
--   be composed with <tt>(.)</tt>, yielding a Lens of the most general
--   kind, so that composing a Lens with a Traversal or Iso yields a Lens,
--   and a Traversal with an Iso yields a Traversal.
module Algebra.Lens
type Iso s t a b = forall p f. (Functor f, Bifunctor p) => p s (f t) -> p a (f b)
type Iso' a b = Simple Iso a b
type (:<->:) a b = Iso' a b
type LensLike f s t a b = (s -> f t) -> (a -> f b)
type Fold s t a b = forall f. (Semigroup (f b), Applicative f) => LensLike f s t a b
type Fold' a b = Simple Fold a b
type Getter s t a b = LensLike (Const s) s t a b
type Getter' a b = Simple Getter a b
type Lens s t a b = forall f. Functor f => LensLike f s t a b
type Lens' a b = Simple Lens a b
type Traversal s t a b = forall f. Applicative f => LensLike f s t a b
type Traversal' a b = Simple Traversal a b

-- | Create an <a>Iso</a> from two inverse functions.
iso :: (a -> s) -> (t -> b) -> Iso s t a b

-- | Reverse an <a>Iso</a>
--   
--   <pre>
--   from :: <a>Iso'</a> a b -&gt; <a>Iso'</a> b a
--   </pre>
from :: Iso s t a b -> Iso b a t s

-- | Create a <a>Lens</a> from a getter and setter function.
--   
--   <pre>
--   lens :: (a -&gt; b) -&gt; (a -&gt; b -&gt; a) -&gt; <a>Lens'</a> a b
--   </pre>
lens :: (a -> s) -> (a -> t -> b) -> Lens s t a b
getter :: (a -> b) -> Traversal' a b

-- | Create a <a>Traversal</a> from a maybe getter and setter function.
--   
--   <pre>
--   prism :: (a -&gt; (a:+:b)) -&gt; (a -&gt; b -&gt; a) -&gt; <a>Traversal'</a> a b
--   </pre>
prism :: (a -> (b :+: s)) -> (a -> t -> b) -> Traversal s t a b
sat :: (a -> Bool) -> Traversal' a a
simple :: LensLike f a b a b -> LensLike f a b a b
(.+) :: Fold s t a b -> Fold s t a b -> Fold s t a b
forl :: LensLike f a b c d -> c -> (a -> f b) -> f d
forl_ :: Functor f => LensLike f a a c c -> c -> (a -> f ()) -> f ()

-- | Retrieve a value from a structure using a <a>Lens</a> (or <a>Iso</a>)
(^.) :: a -> Getter b b a a -> b
(^..) :: a -> Iso a a b b -> b
(^?) :: (Unit f, Monoid (f b)) => a -> Fold' a b -> f b
has :: Fold' a b -> a -> Bool
(^??) :: a -> ((b -> Const [b] b) -> a -> Const [b] a) -> [b]
(%~) :: LensLike Id s t a b -> (s -> t) -> (a -> b)
(%-) :: LensLike Id s t a b -> t -> (a -> b)
(%%~) :: Iso s t a b -> (b -> a) -> (t -> s)
(%%-) :: Iso s t a b -> a -> (t -> s)
by :: Getter b u a v -> a -> b
yb :: Iso s t a b -> t -> b
warp :: LensLike Id s t a b -> (s -> t) -> (a -> b)
set :: LensLike Id s t a b -> t -> (a -> b)
(-.) :: Getter c u b v -> (a -> b) -> a -> c
(.-) :: (b -> c) -> Iso a a b b -> a -> c
class Lens1 s t a b | a -> s, a t -> b
l'1 :: Lens1 s t a b => Lens s t a b
class Lens2 s t a b | a -> s, a t -> b
l'2 :: Lens2 s t a b => Lens s t a b
class Lens3 s t a b | a -> s, a t -> b
l'3 :: Lens3 s t a b => Lens s t a b
class Lens4 s t a b | a -> s, a t -> b
l'4 :: Lens4 s t a b => Lens s t a b
class Lens5 s t a b | a -> s, a t -> b
l'5 :: Lens5 s t a b => Lens s t a b
class Trav1 s t a b | a -> s, a t -> b
t'l :: Trav1 s t a b => Traversal s t a b
class Trav2 s t a b | a -> s, a t -> b
t'r :: Trav2 s t a b => Traversal s t a b
class Compound a b s t | s -> a, b s -> t
each :: Compound a b s t => Traversal a b s t
i'list :: [a] :<->: (() :+: (a :*: [a]))
i'pair :: Iso s t a b -> Iso s' t' a' b' -> Iso (s, s') (t, t') (a, a') (b, b')
t'head :: Traversal' [a] a
t'tail :: Traversal' [a] [a]
class Isomorphic b a t s | t -> b, t a -> s
i'_ :: Isomorphic b a t s => Iso s t a b
thunk :: Iso a b (IO a) (IO b)
chunk :: Bytes :<->: Chunk
curried :: Iso (a -> b -> c) (a' -> b' -> c') ((a, b) -> c) ((a', b') -> c')
i'Id :: Iso (Id a) (Id b) a b
i'OrdList :: Iso (OrdList a) (OrdList b) [a] [b]
i'Const :: Iso (Const a c) (Const b c) a b
i'Dual :: Iso (Dual a) (Dual b) a b
i'Endo :: Iso (Endo k a) (Endo k b) (k a a) (k b b)
i'Flip :: Iso (Flip f b a) (Flip f d c) (f a b) (f c d)
i'maybe :: Iso (Maybe Void) (Maybe a) Bool Bool
i'Max :: Iso (Max a) (Max b) a b
i'Compose :: Iso ((f :.: g) a) ((f' :.: g') b) (f (g a)) (f' (g' b))
i'Backwards :: Iso (Backwards f a) (Backwards g b) (f a) (g b)
i'Accum :: Iso (Accum a) (Accum b) (Maybe a) (Maybe b)
negated :: (Disjonctive a, Disjonctive b) => Iso a b a b
commuted :: Commutative f => Iso (f a b) (f c d) (f b a) (f d c)
adding :: (Num n, Semigroup n) => n -> Iso' n n
warp2 :: Iso s t a b -> (s -> s -> t) -> (a -> a -> b)
mapping :: (Functor f, Functor f') => Iso s t a b -> Iso (f s) (f' t) (f a) (f' b)
mapping' :: Functor f => Iso s t a b -> Iso (f s) (f t) (f a) (f b)

-- | promapping :: Bifunctor f =&gt; Iso' a b -&gt; Iso' (f a c) (f b c)
promapping :: Bifunctor f => Iso s t a b -> Iso (f t x) (f s y) (f b x) (f a y)
applying :: Applicative f => Lens s t a b -> Lens (f s) (f t) (f a) (f b)
class IsoFunctor f
mapIso :: IsoFunctor f => Iso s t a b -> Iso (f s) (f t) (f a) (f b)

-- | An infix synonym for <a>mapIso2</a>
(<.>) :: IsoFunctor2 f => (a :<->: c) -> (b :<->: d) -> (f a b :<->: f c d)
class IsoFunctor2 f
mapIso2 :: IsoFunctor2 f => (a :<->: c) -> (b :<->: d) -> (f a b :<->: f c d)
instance Semigroup (Test a)
instance Monoid (Test a)
instance Functor Test
instance Unit Test
instance Applicative Test
instance IsoFunctor2 Either
instance IsoFunctor2 (,)
instance IsoFunctor2 (->)
instance IsoFunctor ((->) a)
instance Isomorphic a b (Void, a) (Void, b)
instance Isomorphic (f (g a)) (f' (g' b)) ((:.:) f g a) ((:.:) f' g' b)
instance Isomorphic Bool Bool (Maybe a) (Maybe Void)
instance Isomorphic (f a b) (f c d) (Flip f b a) (Flip f d c)
instance Isomorphic (k a a) (k b b) (Endo k a) (Endo k b)
instance Isomorphic a b (Max a) (Max b)
instance Isomorphic a b (Product a) (Product b)
instance Isomorphic a b (Dual a) (Dual b)
instance Isomorphic a b (Const a c) (Const b c)
instance Isomorphic [a] [b] (OrdList a) (OrdList b)
instance Isomorphic a b (Id a) (Id b)
instance Compound a b (a :+: a) (b :+: b)
instance Compound a b (a, a, a) (b, b, b)
instance Compound a b (a, a) (b, b)
instance Trav2 a b (Maybe a) (Maybe b)
instance Trav2 a b (c :+: a) (c :+: b)
instance Trav1 a b [a] [b]
instance Trav1 a b (a :+: c) (b :+: c)
instance Lens5 a b (c, d, e, f, a) (c, d, e, f, b)
instance Lens4 a b (c, d, e, a, f) (c, d, e, b, f)
instance Lens4 a b (c, d, e, a) (c, d, e, b)
instance Lens3 a b (c, d, a, e, f) (c, d, b, e, f)
instance Lens3 a b (c, d, a, e) (c, d, b, e)
instance Lens3 a b (c, d, a) (c, d, b)
instance Lens2 a b (c, a, d, e, f) (c, b, d, e, f)
instance Lens2 a b (c, a, d, e) (c, b, d, e)
instance Lens2 a b (c, a, d) (c, b, d)
instance Lens2 a b (c :*: a) (c :*: b)
instance Lens1 a b (a, c, d, e, f) (b, c, d, e, f)
instance Lens1 a b (a, c, d, e) (b, c, d, e)
instance Lens1 a b (a, c, d) (b, c, d)
instance Lens1 a b (a :*: c) (b :*: c)
instance Lens1 a a [a] [a]
instance Bifunctor (IsoT a b)
instance Cofunctor (Flip (IsoT a b) t)
instance Functor (IsoT a b s)

module Algebra.Foldable
foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m
convert :: (Unit f, Monoid (f a), Foldable t) => t a -> f a
concat :: (Monoid m, Foldable t) => t m -> m
sum :: (Monoid m, Foldable t) => t m -> m
product :: (Ring m, Foldable t) => t m -> m
nzsum :: Semigroup m => [m] -> m
size :: (Foldable f, Ring n) => f a -> n
length :: [a] -> Int
maximum :: (Bounded a, Ord a, Foldable t) => t a -> a
maximumBy :: (Ord a, Foldable t) => (b -> a) -> b -> t b -> b
minimum :: (Bounded a, Ord a, Foldable t) => t a -> a
minimumBy :: (Ord a, Foldable t) => (b -> a) -> b -> t b -> b
sequence_ :: (Applicative f, Foldable t) => t (f a) -> f ()
traverse_ :: (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
for_ :: (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
split :: (Foldable t, Monoid b, Monoid c) => t (b :+: c) -> (b, c)
partitionEithers :: (Foldable t, Unit t, Monoid (t a), Monoid (t b)) => t (a :+: b) -> (t a, t b)
partition :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> (f a, f a)
select :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> f a
refuse :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> f a
compose :: (Category k, Foldable t) => t (k a a) -> k a a
composing :: (Category k, Foldable t) => (a -> k b b) -> t a -> k b b
iter :: (Contravariant (k a), Category k, Foldable t) => k a (t (k a a) -> a)
foldr :: Foldable t => (b -> a -> a) -> a -> t b -> a
foldr1 :: (a -> a -> a) -> [a] -> a
foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
foldl1' :: (a -> a -> a) -> [a] -> a
toList :: Foldable t => t a -> [a]
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
or :: Foldable t => t Bool -> Bool
and :: Foldable t => t Bool -> Bool
all :: Foldable t => (a -> Bool) -> t a -> Bool
any :: Foldable t => (a -> Bool) -> t a -> Bool
elem :: (Eq a, Foldable t) => a -> t a -> Bool
empty :: Foldable f => f a -> Bool
nonempty :: Foldable f => f a -> Bool

-- | Lazily counts the number of elements in a structure up to a certain
--   size
sizeTo :: Foldable f => Int -> f a -> Int
instance Unit Interleave
instance Foldable (Increasing k)
instance Foldable OrdList
instance Foldable Interleave
instance Monad Interleave
instance Applicative Interleave
instance Monad Maybe
instance Applicative Maybe
instance Monad []
instance Applicative []
instance (Foldable f, Foldable g) => Foldable (f :++: g)
instance (Foldable f, Foldable g) => Foldable (f :**: g)
instance (Foldable f, Semigroup (f a), Ring n) => SubSemi n (f a)
instance (Foldable f, Foldable g) => Foldable (f :.: g)
instance Foldable (Assoc k)
instance Foldable Tree
instance Foldable []
instance Foldable ((,) a)
instance Foldable Maybe
instance Foldable (Either a)
instance Foldable Strict
instance Foldable Id

module Algebra.Traversable
class Functor t => Traversable t
sequence :: (Traversable t, Applicative f) => t (f a) -> f (t a)
class Functor t => Contravariant t
collect :: (Contravariant t, Functor f) => f (t a) -> t (f a)
traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
for :: (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
transpose :: (Applicative f, Traversable t) => t (f a) -> f (t a)
doTimes :: Applicative f => Int -> f a -> f [a]
converted :: (Unit f, Unit g, Foldable f, Foldable g, Monoid (f a), Monoid (g b)) => Iso (f a) (f b) (g a) (g b)
folded :: (Unit f', Foldable f, Monoid m) => Iso m m' (f m) (f' m')
coerceSeq :: (Applicative f, Traversable t) => (forall b. t b -> t' b) -> (t' (f a) -> f (t' a))
instance Compound a b [a] [b]
instance Traversable Strict
instance Traversable Maybe
instance (Traversable f, Traversable g) => Traversable (f :++: g)
instance (Traversable f, Traversable g) => Traversable (f :**: g)
instance (Traversable f, Traversable g) => Traversable (f :.: g)
instance Traversable Tree
instance Traversable f => Traversable (Zip f)
instance Traversable (Assoc k)
instance Traversable (Increasing k)
instance Traversable OrdList
instance Traversable Interleave
instance Traversable []
instance Traversable (Either a)
instance Traversable ((,) c)

module Algebra.Monad.Base
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
runKleisli :: Kleisli m a b -> a -> m b
i'Kleisli :: Iso (Kleisli m a b) (Kleisli m' c d) (a -> m b) (c -> m' d)
(=<<) :: Monad m => (a -> m b) -> m a -> m b
joinMap :: Monad m => (a -> m b) -> m a -> m b
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
(>>) :: Applicative f => f a -> f b -> f b
(<*=) :: Monad m => m a -> (a -> m b) -> m a
only :: (Monoid (m ()), Monad m) => (a -> Bool) -> m a -> m a
return :: Unit f => a -> f a
foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
foldrM :: (Foldable t, Monad m) => (b -> a -> m a) -> t b -> a -> m a
findM :: (Foldable t, Monad m) => (a -> m (Maybe b)) -> t a -> m (Maybe b)
while :: Monad m => m Bool -> m ()
until :: Monad m => m (Maybe a) -> m a
bind2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c
bind3 :: Monad m => (a -> b -> c -> m d) -> m a -> m b -> m c -> m d
(>>>=) :: Monad m => (m a, m b) -> (a -> b -> m c) -> m c
(>>>>=) :: Monad m => (m a, m b, m c) -> (a -> b -> c -> m d) -> m d
mfix_ :: MonadFix m => (a -> m a) -> m ()
mfixing :: MonadFix f => (b -> f (a, b)) -> f a
type Action s t a b = forall m. Monad m => LensLike m s t a b
type Action' a b = Action b b a a
newtype Compose' f g a
Compose' :: ((g :.: f) a) -> Compose' f g a
i'Compose' :: Iso (Compose' f g a) (Compose' h i b) (g (f a)) (i (h b))
coerceJoin :: Monad m => (forall b. m b -> m' b) -> (m' (m' a) -> m' a)
coerceDuplicate :: Comonad m => (forall b. m b -> m' b) -> (m' a -> m' (m' a))
instance (Traversable f, Monad f, MonadWriter w g) => MonadWriter w (Compose' f g)
instance (Traversable f, Monad f, MonadReader r g) => MonadReader r (Compose' f g)
instance (Traversable f, Monad f, MonadState s g) => MonadState s (Compose' f g)
instance (Semigroup (f a), Applicative g) => Semigroup (Compose' f g a)
instance (Monoid (f a), Applicative g) => Monoid (Compose' f g a)
instance (Unit f, Unit g) => Unit (Compose' f g)
instance (Functor f, Functor g) => Functor (Compose' f g)
instance (Applicative f, Applicative g) => Applicative (Compose' f g)
instance (MonadFix g, Traversable f, Monad f) => MonadFix (Compose' f g)
instance (Foldable f, Foldable g) => Foldable (Compose' f g)
instance (Traversable g, Traversable f) => Traversable (Compose' f g)
instance (Monad f, Monad g, Traversable f) => Monad (Compose' f g)
instance Monad m => ConcreteMonad (Compose' m)
instance Monad m => MonadTrans (Compose' m)
instance Isomorphic (a -> m b) (c -> m' d) (Kleisli m a b) (Kleisli m' c d)
instance Monad m => Split (Kleisli m)
instance Monad m => Choice (Kleisli m)
instance Monad m => Category (Kleisli m)
instance Monad m => Deductive (Kleisli m)
instance Contravariant f => Contravariant (Kleisli f a)
instance Functor f => Functor (Kleisli f a)
instance ConcreteMonad Backwards
instance MonadTrans Backwards
instance MonadFix m => MonadFix (Backwards m)
instance MonadFix m => MonadFuture m (Backwards m)
instance MonadFix m => Monad (Backwards m)
instance (Traversable g, Monad g, MonadReader r f) => MonadReader r (f :.: g)
instance (Traversable g, Monad g, MonadWriter w f) => MonadWriter w (f :.: g)
instance (Traversable g, Monad g, MonadState s f) => MonadState s (f :.: g)
instance Monad m => ConcreteMonad ((:.:) m)
instance Monad m => MonadTrans ((:.:) m)
instance (MonadFix f, Traversable g, Monad g) => MonadFix (f :.: g)
instance (Traversable g, Monad f, Monad g) => Monad (f :.: g)
instance MonadFix IO
instance MonadFix (Either e)
instance MonadFix []
instance MonadFix ((->) b)
instance MonadFix Strict
instance MonadFix Id
instance (MonadIO m, MonadTrans t, Monad (t m)) => MonadIO (t m)
instance MonadIO IO

module Algebra.Monad.RWS
newtype RWST r w s m a
RWST :: ((r, s) -> m (a, s, w)) -> RWST r w s m a
runRWST :: RWST r w s m a -> (r, s) -> m (a, s, w)
type RWS r w s a = RWST r w s Id a
class MonadTrans t => MonadInternal t
internal :: (MonadInternal t, Monad m) => (forall c. m (c, a) -> m (c, b)) -> (t m a -> t m b)
_RWST :: Iso (RWST r w s m a) (RWST r' w' s' m' a') ((r, s) -> m (a, s, w)) ((r', s') -> m' (a', s', w'))
get_ :: (MonadTrans t, MonadState a m) => t m a
put_ :: (MonadTrans t, MonadState s m) => s -> t m ()
modify_ :: (MonadTrans t, MonadState s m) => (s -> s) -> t m ()
local_ :: (MonadInternal t, MonadReader r m) => (r -> r) -> t m a -> t m a
ask_ :: (MonadTrans t, MonadReader a m) => t m a
tell_ :: (MonadWriter w m, MonadTrans t) => w -> t m ()
listen_ :: (MonadInternal t, MonadWriter w m) => t m a -> t m (w, a)
censor_ :: (MonadInternal t, MonadWriter w m) => t m (a, w -> w) -> t m a
getCounter_ :: (MonadTrans t, MonadCounter w acc m) => t m acc
instance Ring (m (a, s, w)) => Ring (RWST r w s m a)
instance Semiring (m (a, s, w)) => Semiring (RWST r w s m a)
instance Monoid (m (a, s, w)) => Monoid (RWST r w s m a)
instance Semigroup (m (a, s, w)) => Semigroup (RWST r w s m a)
instance (Monad m, Monoid w, MonadFuture n m) => MonadFuture n (RWST r w s m)
instance Monoid w => MonadInternal (RWST r w s)
instance Monoid w => ConcreteMonad (RWST r w s)
instance Monoid w => MonadTrans (RWST r w s)
instance (Monoid w, MonadList m) => MonadList (RWST r w s m)
instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m)
instance Traversable m => Traversable (RWST Void w Void m)
instance Foldable m => Foldable (RWST Void w Void m)
instance (Monad m, Monoid w) => MonadWriter w (RWST r w s m)
instance (Monad m, Monoid w) => MonadReader r (RWST r w s m)
instance (Monad m, Monoid w) => MonadState s (RWST r w s m)
instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m)
instance (Monoid w, MonadFix m) => MonadFix (RWST r w s m)
instance (Monoid w, Monad m) => Monad (RWST r w s m)
instance (Monoid w, Monad m) => Applicative (RWST r w s m)
instance Functor f => Functor (RWST r w s f)
instance (Unit f, Monoid w) => Unit (RWST r w s f)

module Algebra.Monad.State
class Monad m => MonadState s m | m -> s where put = modify . const modify f = get >>= put . f
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()
modify :: MonadState s m => (s -> s) -> m ()
data StateT s m a
type State s a = StateT s Id a
stateT :: (Functor m, Functor n) => Iso (StateT s m a) (StateT t n b) (s -> m (s, a)) (t -> n (t, b))
eval :: (s -> (a, b)) -> (s -> b)
exec :: Functor f => f (a, b) -> f a
state :: Iso (State s a) (State t b) (s -> (s, a)) (t -> (t, b))
(=~) :: MonadState s m => Traversal' s a -> (a -> a) -> m ()
(=-) :: MonadState s m => Traversal' s s' -> s' -> m ()
(^>=) :: MonadState s m => LensLike m a a s s -> (a -> m ()) -> m ()
gets :: MonadState s m => (s -> a) -> m a
use :: MonadState s m => Getter' s a -> m a
saving :: MonadState s m => Lens' s s' -> m a -> m a
type Next a = a
type Prev a = a
mapAccum :: Traversable t => (a -> s -> (s, b)) -> t a -> s -> (s, t b)
mapAccum_ :: Traversable t => (a -> s -> (s, b)) -> t a -> s -> t b
mapAccumR :: Traversable t => (a -> s -> (s, b)) -> t a -> s -> (s, t b)
mapAccumR_ :: Traversable t => (a -> s -> (s, b)) -> t a -> s -> t b
push :: Traversable t => t a -> a -> t a
pop :: Traversable t => t a -> a -> t a
withPrev :: Traversable t => a -> t a -> t (Prev a, a)
withNext :: Traversable t => t a -> a -> t (a, Next a)
newtype StateA m s a
StateA :: (StateT s m a) -> StateA m s a
stateA :: Iso (StateA m s a) (StateA m' s' a') (StateT s m a) (StateT s' m' a')
instance (Monad m, MonadFuture n m) => MonadFuture n (StateT s m)
instance Ring (m (a, s, Void)) => Ring (StateT s m a)
instance Semiring (m (a, s, Void)) => Semiring (StateT s m a)
instance Monoid (m (a, s, Void)) => Monoid (StateT s m a)
instance Semigroup (m (a, s, Void)) => Semigroup (StateT s m a)
instance MonadError e m => MonadError e (StateT s m)
instance Unit m => Unit (StateT s m)
instance Functor m => Functor (StateT s m)
instance Monad m => Applicative (StateT s m)
instance MonadFix m => MonadFix (StateT s m)
instance MonadTrans (StateT s)
instance MonadInternal (StateT s)
instance MonadCont m => MonadCont (StateT s m)
instance Monad m => MonadState s (StateT s m)
instance MonadList m => MonadList (StateT s m)
instance Monad m => Choice (StateA m)
instance Monad m => Split (StateA m)
instance Monad m => Category (StateA m)
instance Monad m => Deductive (StateA m)
instance MonadCounter w acc m => MonadCounter w acc (StateT s m)
instance MonadWriter w m => MonadWriter w (StateT s m)
instance MonadReader r m => MonadReader r (StateT s m)
instance Monad m => Monad (StateT s m)
instance MonadState (IO ()) IO

module Algebra.Monad.Reader
class Monad m => MonadReader r m | m -> r
ask :: MonadReader r m => m r
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | A simple Reader monad
data ReaderT r m a
type Reader r a = ReaderT r Id a
readerT :: (Functor m, Functor m') => Iso (ReaderT r m a) (ReaderT r' m' b) (r -> m a) (r' -> m' b)
reader :: Iso (Reader r a) (Reader r' b) (r -> a) (r' -> b)
instance (Monad m, MonadFuture n m) => MonadFuture n (ReaderT r m)
instance Ring (m (a, Void, Void)) => Ring (ReaderT r m a)
instance Semiring (m (a, Void, Void)) => Semiring (ReaderT r m a)
instance Monoid (m (a, Void, Void)) => Monoid (ReaderT r m a)
instance Semigroup (m (a, Void, Void)) => Semigroup (ReaderT r m a)
instance Functor m => Functor (ReaderT r m)
instance Unit m => Unit (ReaderT r m)
instance Monad m => Applicative (ReaderT r m)
instance MonadFix m => MonadFix (ReaderT r m)
instance MonadTrans (ReaderT r)
instance MonadInternal (ReaderT r)
instance Monad m => MonadReader r (ReaderT r m)
instance MonadCont m => MonadCont (ReaderT r m)
instance MonadList m => MonadList (ReaderT r m)
instance MonadCounter w acc m => MonadCounter w acc (ReaderT r m)
instance MonadWriter w m => MonadWriter w (ReaderT r m)
instance MonadState s m => MonadState s (ReaderT r m)
instance Monad m => Monad (ReaderT r m)
instance MonadReader r ((->) r)

module Algebra.Monad.Writer
class (Monad m, Monoid w) => MonadWriter w m | m -> w
tell :: MonadWriter w m => w -> m ()
listen :: MonadWriter w m => m a -> m (w, a)
censor :: MonadWriter w m => m (a, w -> w) -> m a
mute :: (MonadWriter w m, Monoid w) => m a -> m a
intercept :: (MonadWriter w m, Monoid w) => m a -> m (w, a)
intercept' :: (MonadWriter w m, Monoid w) => m a -> m w
eavesdrop :: (MonadWriter w m, Monoid w) => m a -> m w

-- | A simple Writer monad
data WriterT w m a
type Writer w a = WriterT w Id a
writerT :: (Functor m, Functor m') => Iso (WriterT w m a) (WriterT w' m' b) (m (w, a)) (m' (w', b))
writer :: Iso (Writer w a) (Writer w' b) (w, a) (w', b)
pureWriter :: Monoid w => Iso (w, a) (w', b) a b
class (SubSemi acc w, MonadWriter w m) => MonadCounter w acc m | m -> acc
getCounter :: MonadCounter w acc m => m acc

-- | The canonical representsation of a WriterAcc Monad
data CounterT w acc m a
type Counter w acc a = CounterT w acc Id a
i'counterT :: (SubSemi acc w, SubSemi acc' w', Monoid acc, Monoid acc', Functor m) => Iso (CounterT w acc m a) (CounterT w' acc' m' a') (m (a, acc, w)) (m' (a', acc', w'))
i'counter :: (SubSemi acc w, SubSemi acc' w', Monoid acc, Monoid acc', Functor m) => Iso (Counter w acc a) (Counter w' acc' a') (a, acc, w) (a', acc', w')
instance (Monad m, Monoid w, SubSemi acc w, MonadFuture n m) => MonadFuture n (CounterT w acc m)
instance (Monad m, Monoid w, MonadFuture n m) => MonadFuture n (WriterT w m)
instance Ring (m (a, Void, w)) => Ring (WriterT w m a)
instance Semiring (m (a, Void, w)) => Semiring (WriterT w m a)
instance Monoid (m (a, Void, w)) => Monoid (WriterT w m a)
instance Semigroup (m (a, Void, w)) => Semigroup (WriterT w m a)
instance (Unit m, Monoid w) => Unit (WriterT w m)
instance Functor m => Functor (WriterT w m)
instance (Monoid w, Monad m) => Applicative (WriterT w m)
instance (Monoid w, MonadFix m) => MonadFix (WriterT w m)
instance Foldable m => Foldable (WriterT w m)
instance Monoid w => MonadTrans (WriterT w)
instance Monoid w => MonadInternal (WriterT w)
instance (Monoid w, Monad m) => MonadWriter w (WriterT w m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT w m)
instance (Monoid w, MonadList m) => MonadList (WriterT w m)
instance Functor m => Functor (CounterT w acc m)
instance (Unit m, Monoid w) => Unit (CounterT w acc m)
instance (Monoid w, Monad m) => Applicative (CounterT w acc m)
instance (SubSemi acc w, Monoid w, MonadFix m) => MonadFix (CounterT w acc m)
instance Monoid w => MonadTrans (CounterT w acc)
instance (MonadState s m, Monoid w, SubSemi acc w) => MonadState s (CounterT w acc m)
instance (Monad m, Monoid w, SubSemi acc w) => MonadCounter w acc (CounterT w acc m)
instance (Monad m, SubSemi acc w, Monoid w) => MonadWriter w (CounterT w acc m)
instance (Monoid w, SubSemi a w, Monad m) => Monad (CounterT w a m)
instance (Monoid w, MonadState r m) => MonadState r (WriterT w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance Traversable m => Traversable (WriterT e m)
instance (Monoid w, Monad m) => Monad (WriterT w m)
instance Monoid w => MonadWriter w ((,) w)

module Algebra.Monad.Cont
class Monad m => MonadCont m
callCC :: MonadCont m => (forall b. (a -> m b) -> m b) -> m a

-- | A simple continuation monad implementation
newtype ContT m a
ContT :: (forall r. (a -> m r) -> m r) -> ContT m a
runContT :: ContT m a -> forall r. (a -> m r) -> m r
type Cont a = ContT Id a
contT :: (Monad m, Unit m') => Iso (ContT m a) (ContT m' a') (m a) (m' a')
cont :: Iso (Cont a) (Cont a') a a'
(>>~) :: ContT m a -> (a -> m b) -> m b
instance MonadFix m => MonadFix (ContT m)
instance MonadCont (ContT m)
instance MonadTrans ContT
instance Monad (ContT m)
instance Applicative (ContT m)
instance Functor (ContT f)
instance Unit (ContT m)

module Algebra.Monad.Foldable
class Monad m => MonadList m
fork :: MonadList m => [a] -> m a
data ListT m a
listT :: Iso (ListT m a) (ListT m' a') (m [a]) (m' [a'])
newtype TreeT m a
TreeT :: (Compose' Tree m a) -> TreeT m a
treeT :: Iso (TreeT m a) (TreeT n b) (m (Tree a)) (n (Tree b))
newtype MaybeT m a
MaybeT :: (Compose' Maybe m a) -> MaybeT m a
maybeT :: Iso (MaybeT m a) (MaybeT m' b) (m (Maybe a)) (m' (Maybe b))
newtype StrictT m a
StrictT :: (Compose' Strict m a) -> StrictT m a
strictT :: Iso (StrictT m a) (StrictT m' b) (m (Strict a)) (m' (Strict b))
instance Applicative m => Semigroup (ListT m a)
instance Applicative m => Monoid (ListT m a)
instance Functor m => Functor (ListT m)
instance Applicative m => Applicative (ListT m)
instance Unit m => Unit (ListT m)
instance Foldable m => Foldable (ListT m)
instance MonadTrans ListT
instance Functor m => Functor (TreeT m)
instance Unit m => Unit (TreeT m)
instance Applicative m => Applicative (TreeT m)
instance MonadFix m => MonadFix (TreeT m)
instance Foldable m => Foldable (TreeT m)
instance MonadTrans TreeT
instance Functor m => Functor (MaybeT m)
instance Unit m => Unit (MaybeT m)
instance Applicative m => Applicative (MaybeT m)
instance MonadFix m => MonadFix (MaybeT m)
instance Foldable m => Foldable (MaybeT m)
instance MonadTrans MaybeT
instance Functor m => Functor (StrictT m)
instance Unit m => Unit (StrictT m)
instance Applicative m => Applicative (StrictT m)
instance MonadFix m => MonadFix (StrictT m)
instance Foldable m => Foldable (StrictT m)
instance MonadTrans StrictT
instance Traversable m => Traversable (StrictT m)
instance Monad m => Monad (StrictT m)
instance Traversable m => Traversable (MaybeT m)
instance Monad m => Monad (MaybeT m)
instance Traversable m => Traversable (TreeT m)
instance Monad m => Monad (TreeT m)
instance Monad m => MonadError Void (ListT m)
instance MonadWriter w m => MonadWriter w (ListT m)
instance MonadState s m => MonadState s (ListT m)
instance MonadFix m => MonadFix (ListT m)
instance Monad m => MonadList (ListT m)
instance Traversable m => Traversable (ListT m)
instance Monad m => Monad (ListT m)
instance MonadList []

module Algebra.Monad.Error
class Monad m => MonadError e m | m -> e
throw :: MonadError e m => e -> m a
catch :: MonadError e m => (e -> m a) -> m a -> m a
try :: MonadError e m => m a -> m a -> m a
(!+) :: MonadError Void m => m a -> m a -> m a
optional :: MonadError e m => m a -> m (Maybe a)
throwIO :: (MonadError SomeException m, Exception e) => e -> m ()
data EitherT e m a
eitherT :: Functor m => Iso (EitherT e m a) (EitherT f m b) (m (e :+: a)) (m (f :+: b))
instance Unit m => Unit (EitherT e m)
instance Functor m => Functor (EitherT e m)
instance Applicative m => Applicative (EitherT e m)
instance MonadFix m => MonadFix (EitherT e m)
instance Foldable m => Foldable (EitherT e m)
instance MonadTrans (EitherT e)
instance MonadError SomeException IO
instance MonadError Void Maybe
instance Traversable m => Traversable (EitherT e m)
instance Monad m => Monad (EitherT e m)
instance MonadError Void []
instance MonadError e (Either e)

module Algebra.Monad.Free
data Free f a
Join :: (f (Free f a)) -> Free f a
Pure :: a -> Free f a
concrete :: Monad m => Free m a -> m (Free Id a)
unliftF :: Monad m => Free m a -> Free m (m a)
mapF :: (Functor f, Functor g) => (forall a. f a -> g a) -> Free f b -> Free g b
class MonadFree m f | f -> m
step :: (MonadFree m f, Monad m) => f a -> m (f a)
perform :: (MonadFree m f, Monad m) => f a -> m a
liftF :: (MonadFree m f, Functor m) => m a -> f a
coerceStep :: (Monad m, MonadFree m f) => (f a -> g a) -> (g a -> m (g a))
coercePerform :: (Monad m, MonadFree m f) => (f a -> g a) -> (g a -> m a)
coerceLiftF :: (Functor m, MonadFree m f) => (f a -> g a) -> (m a -> g a)
data Cofree w a
Step :: a -> (w (Cofree w a)) -> Cofree w a
type Infinite a = Cofree Id a
type Colist a = Cofree Maybe a
type Bifree f a = Cofree (Free f) a
newtype ContC k a b
ContC :: (forall c. k b c -> k a c) -> ContC k a b
runContC :: ContC k a b -> forall c. k b c -> k a c
contC :: (Category k, Category k') => Iso (ContC k a b) (ContC k' a' b') (k a b) (k' a' b')
instance (Show (f (Free f a)), Show a) => Show (Free f a)
instance Category (ContC k)
instance Deductive (ContC k)
instance Applicative m => Monad (Cofree m)
instance Applicative m => Applicative (Cofree m)
instance Unit m => Unit (Cofree m)
instance Traversable w => Traversable (Cofree w)
instance Foldable w => Foldable (Cofree w)
instance Functor w => Comonad (Cofree w)
instance Counit (Cofree w)
instance Functor w => Functor (Cofree w)
instance MonadFree m (Free m)
instance MonadError e m => MonadError e (Free m)
instance MonadFuture m t => MonadFuture m (Free t)
instance MonadList m => MonadList (Free m)
instance MonadIO m => MonadIO (Free m)
instance MonadCounter w a m => MonadCounter w a (Free m)
instance MonadWriter w m => MonadWriter w (Free m)
instance MonadReader r m => MonadReader r (Free m)
instance MonadState s m => MonadState s (Free m)
instance ConcreteMonad Free
instance MonadTrans Free
instance Traversable f => Traversable (Free f)
instance Foldable f => Foldable (Free f)
instance MonadFix f => MonadFix (Free f)
instance (Ord (f (Free f a)), Ord a, Unit f) => Ord (Free f a)
instance (Ord (f (Free f a)), Ord a, Unit f) => Eq (Free f a)
instance Comonad f => Comonad (Free f)
instance Counit f => Counit (Free f)
instance Functor f => Monad (Free f)
instance Functor f => Applicative (Free f)
instance Unit (Free f)
instance Functor f => Functor (Free f)

module Algebra.Monad.Logic
newtype LogicT m a
LogicT :: (forall r. (a -> m r -> m r) -> m r -> m r) -> LogicT m a
runLogicT :: LogicT m a -> forall r. (a -> m r -> m r) -> m r -> m r
class Monad m => MonadLogic l m | l -> m
deduce :: MonadLogic l m => l a -> m (Maybe (a, l a))
induce :: MonadLogic l m => m (Maybe (a, l a)) -> l a
listLogic :: (MonadLogic l m, MonadLogic l' n) => Iso (l a) (l' b) (m [a]) (n [b])
deduceMany :: MonadLogic l m => Int -> l a -> m [a]
deduceAll :: MonadLogic l m => l a -> m [a]
choose :: MonadLogic l m => [a] -> l a
instance Monad m => MonadLogic (LogicT m) m
instance MonadState s m => MonadState s (LogicT m)
instance Monoid a => Ring (LogicT m a)
instance Semigroup a => Semiring (LogicT m a)
instance Monoid (LogicT m a)
instance Semigroup (LogicT m a)
instance MonadTrans LogicT
instance MonadFix (LogicT m)
instance Monad (LogicT m)
instance Applicative (LogicT m)
instance Unit (LogicT m)
instance Functor (LogicT m)

module Algebra.Monad

module Algebra.Arrow
class (Split k, Choice k) => Arrow k
arr :: Arrow k => (a -> b) -> k a b
(>>^) :: Functor f => f a -> (a -> b) -> f b
(^>>) :: Cofunctor (Flip f c) => (a -> b) -> f b c -> f a c
class Arrow k => Apply k
apply :: Apply k => k (k a b, a) b
comapA :: Arrow arr => (a -> b) -> Flip arr c b -> Flip arr c a
app :: Apply k => k a b -> k a b
dup :: Arrow arr => arr a (a, a)
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
runKleisli :: Kleisli m a b -> a -> m b
newtype ListA k a b
ListA :: k [a] [b] -> ListA k a b
runListA :: ListA k a b -> k [a] [b]
instance Arrow k => Arrow (ListA k)
instance Arrow k => Split (ListA k)
instance Arrow k => Choice (ListA k)
instance Category k => Category (ListA k)
instance Deductive k => Deductive (ListA k)
instance Monad m => Arrow (Kleisli m)
instance Monad m => Apply (Kleisli m)
instance Apply (->)
instance Monad m => Arrow (StateA m)
instance Arrow (->)

module Definitive.Base

module Data.Containers
class Monoid m => DataMap m k a | m -> k a
at :: DataMap m k a => k -> Lens' m (Maybe a)
class Indexed f i | f -> i
keyed :: Indexed f i => Iso (f (i, a)) (f (i, b)) (f a) (f b)
class OrderedMap m k a m' k' a' | m -> k a, m' -> k' a'
ascList :: OrderedMap m k a m' k' a' => Iso [(k, a)] [(k', a')] m m'
class Container c
weight :: Container c => c a -> Int
lookup :: DataMap m k a => k -> m -> Maybe a
resides :: DataMap m k a => k -> m -> Bool
member :: DataMap m k Void => k -> Lens' m Bool
delete :: DataMap m k a => k -> m -> m
touch :: (Monoid a, DataMap m k a) => k -> m -> m
insert :: DataMap m k a => k -> a -> m -> m
singleton :: DataMap m k a => k -> a -> m
singleton' :: (Monoid a, DataMap m k a) => k -> m
fromAList :: DataMap m k a => [(k, a)] -> m
fromKList :: (Monoid a, DataMap m k a) => [k] -> m
(#) :: DataMap m k a => m -> [(k, a)] -> m
(#?) :: (Ord a, Ord b) => Relation a b -> [(a, b)] -> Relation a b
cached :: Ord a => (a -> b) -> a -> b

-- | A set of values <tt>a</tt>.
data Set a :: * -> *

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a :: * -> * -> *
c'setOf :: Constraint a -> Constraint (Set a)
c'set :: Constraint (Set a)
c'mapOf :: Constraint a -> Constraint b -> Constraint (Map a b)
c'map :: Constraint (Map a b)

-- | An invertible map
newtype Bimap a b
Bimap :: (Map a b, Map b a) -> Bimap a b
toMap :: Bimap a b -> Map a b
keysSet :: (Eq k, OrderedMap m k a m k a) => m -> Set k
newtype Relation a b
Relation :: (Map a (Set b), Map b (Set a)) -> Relation a b
i'Relation :: Iso (Relation a b) (Relation c d) (Map a (Set b), Map b (Set a)) (Map c (Set d), Map d (Set c))

-- | Define a Relation from its domain (uses the Commutative instance)
i'domains :: (Ord c, Ord d) => Iso (Map b (Set a)) (Map d (Set c)) (Relation a b) (Relation c d)

-- | Define a Relation from its ranges. O(1) <a>-</a> O(1,n*ln(n))
i'ranges :: (Ord c, Ord d) => Iso (Map a (Set b)) (Map c (Set d)) (Relation a b) (Relation c d)
l'domain :: (Ord a, Ord b) => a -> Lens' (Relation a b) (Set b)
l'range :: (Ord a, Ord b) => b -> Lens' (Relation a b) (Set a)
link :: (Ord a, Ord b) => a -> b -> Lens' (Relation a b) Bool
(*>>>) :: (Ord a, Ord b, Ord c) => Relation a b -> Relation b c -> Relation a c
instance (Ord a, Ord b) => Monoid (Relation a b)
instance (Show a, Show b) => Show (Bimap a b)
instance (Ord a, Ord b) => Semigroup (Bimap a b)
instance (Ord a, Ord b) => Monoid (Bimap a b)
instance (Ord a, Ord b) => Disjonctive (Bimap a b)
instance (Ord a, Ord b, Semigroup a, Semigroup b) => Semiring (Bimap a b)
instance (Show a, Show b) => Show (Relation a b)
instance (Eq a, Eq b) => Eq (Relation a b)
instance (Ord a, Ord b) => Ord (Relation a b)
instance (Ord k, Ord a) => DataMap (Relation k a) k (Set a)
instance Commutative Relation
instance (Ord a, Ord b) => Semiring (Relation a b)
instance (Ord a, Ord b) => Semigroup (Relation a b)
instance (Ord a, Ord b, Ord c, Ord d) => OrderedMap (Bimap a b) a b (Bimap c d) c d
instance (Ord b, Ord a) => DataMap (Flip Bimap b a) b a
instance (Ord a, Ord b) => DataMap (Bimap a b) a b
instance Commutative Bimap
instance Ord k => Applicative (Zip (Map k))
instance Ord k => Unit (Zip (Map k))
instance Indexed (Map k) k
instance Eq k => Traversable (Map k)
instance Foldable (Map k)
instance Functor (Map k)
instance (Ord k, Semigroup a) => Semiring (Map k a)
instance Ord k => Disjonctive (Map k a)
instance Ord k => Monoid (Map k a)
instance Ord k => Semigroup (Map k a)
instance Foldable Set
instance Functor Set
instance Ord a => Semiring (Set a)
instance Ord a => Disjonctive (Set a)
instance Ord a => Monoid (Set a)
instance Ord a => Semigroup (Set a)
instance Eq k' => OrderedMap (Map k a) k a (Map k' a') k' a'
instance Eq k => DataMap [(k, a)] k a
instance Ord k => DataMap (Map k a) k a
instance Eq b => OrderedMap (Set a) a Void (Set b) b Void
instance Ord a => DataMap (Set a) a Void
instance Container (Map k)
instance Container Set
instance Container []
instance Indexed [] Int

module Data.Containers.Sequence
class Monoid t => Sequence t
splitAt :: Sequence t => Int -> t -> (t, t)
class Stream c s | s -> c
uncons :: Stream c s => s -> Maybe (c, s)
cons :: Stream c s => c -> s -> s
i'elems :: (Monoid s', Stream c s, Stream c' s') => Iso [c] [c'] s s'
take :: Sequence t => Int -> t -> t
drop :: Sequence t => Int -> t -> t
type Slice a = Vector a
data Slices a
slice :: (Storable a, Storable b) => Iso (Slice a) (Slice b) [a] [b]
slices :: (Storable a, Storable b) => Iso (Slices a) (Slices b) (Slice a) (Slice b)
i'storables :: (Storable a, Storable b) => Iso (Slice a) (Slice b) Chunk Chunk
_Slices :: Iso (Slices a) (Slices b) [Slice a] [Slice b]
breadth :: Storable a => Slices a -> Int

-- | Pass a pointer to the vector's data to the IO action. The data may not
--   be modified through the 'Ptr.
unsafeWith :: Storable a => Vector a -> (Ptr a -> IO b) -> IO b
sliceElt :: (Storable a, Storable b) => Action a b (Slice a) (Slice b)
span :: Stream c s => (c -> Bool) -> s -> ([c], s)
break :: Stream c s => (c -> Bool) -> s -> ([c], s)
takeWhile :: Stream c s => (c -> Bool) -> s -> [c]
takeUntil :: Stream c s => (c -> Bool) -> s -> [c]
dropWhile :: Stream c s => (c -> Bool) -> s -> s
dropUntil :: Stream c s => (c -> Bool) -> s -> s
pry :: Stream c s => Int -> s -> ([c], s)
(++) :: Stream c s => [c] -> s -> s
instance Semigroup (Slices a)
instance Monoid (Slices a)
instance Stream a (StreamC a)
instance Storable a => DataMap (Slice a) Int a
instance Monad m => Monad (PMonad m)
instance Functor m => Functor (PMonad m)
instance Storable a => Sequence (Slices a)
instance Stream Char Chunk
instance Stream a [a]
instance Storable a => Sequence (Vector a)
instance Sequence Bytes
instance Sequence [a]
instance Storable a => Monoid (Vector a)
instance Storable a => Semigroup (Vector a)

module Definitive
trace :: String -> a -> a
trace2 :: String -> String -> a -> a
mtrace :: Unit f => String -> f ()
debug :: Show a => a -> a
cli :: String -> ((?cliargs :: [String], ?progName :: String) => IO a) -> IO a

module Data.TimeVal

-- | A type wrapper that adds a Bounded instance for types that don't
--   possess one.
data TimeVal t
Always :: TimeVal t
Since :: t -> TimeVal t
Never :: TimeVal t
instance Show t => Show (TimeVal t)
instance Eq t => Eq (TimeVal t)
instance Ord t => Ord (TimeVal t)
instance Ord a => Eq (Boolean a)
instance Ord a => Ord (Boolean a)
instance Functor Boolean
instance Foldable Boolean
instance Unit Boolean
instance Applicative Boolean
instance Traversable Boolean
instance Monad Boolean
instance Ord a => Ord (BoolNode a)
instance Ord a => Eq (BoolNode a)
instance Traversable BoolNode
instance Foldable BoolNode
instance Functor BoolNode
instance Unit BoolNode
instance Bounded (TimeVal t)
instance Traversable TimeVal
instance Foldable TimeVal
instance Monad TimeVal
instance Applicative TimeVal
instance Unit TimeVal
instance Functor TimeVal

module Data.Queue
data Front
data Back
newtype DeQue a
DeQue :: ([a], [a]) -> DeQue a
newtype Queue push pop a
Queue :: DeQue a -> Queue push pop a
deque :: Queue push pop a -> DeQue a
c'queue :: Constraint push -> Constraint pop -> Constraint (Queue push pop a)
c'front :: Constraint Front
c'back :: Constraint Back
queue :: Queue x y a -> Queue s t a
class Direction t
isFront :: Direction t => t -> Bool
instance Monoid (DeQue a)
instance Semigroup (Queue push pop a)
instance Monoid (Queue push pop a)
instance Functor (Queue push pop)
instance Foldable (Queue push pop)
instance (Direction push, Direction pop) => Stream a (Queue push pop a)
instance Direction Back
instance Direction Front
instance Traversable (Queue push pop)
instance Traversable DeQue
instance Foldable DeQue
instance Functor DeQue
instance Semigroup (DeQue a)

module Data.Probability
newtype ProbT t m a
ProbT :: (WriterT (Product t) (ListT m) a) -> ProbT t m a
type Prob t a = ProbT t Id a
i'ProbT :: Iso (ProbT t m a) (ProbT t' m' a') (WriterT (Product t) (ListT m) a) (WriterT (Product t') (ListT m') a')
probT :: (Functor m, Functor m') => Iso (ProbT t m a) (ProbT t' m' a') (m [(t, a)]) (m' [(t', a')])
prob :: Iso (Prob t a) (Prob t' a') [(t, a)] [(t', a')]
c'prob :: Constraint t -> Constraint (Prob t a)
sample :: (Eq a, Monoid t) => a -> Prob t a -> (t, t)
instance (Unit m, Ring t) => Unit (ProbT t m)
instance Functor m => Functor (ProbT t m)
instance (Ring t, Monad m) => Applicative (ProbT t m)
instance Applicative m => Semigroup (ProbT t m a)
instance Applicative m => Monoid (ProbT t m a)
instance (Ring t, MonadFix m) => MonadFix (ProbT t m)
instance (Ring t, Monad m) => MonadWriter (Product t) (ProbT t m)
instance (Monad m, Invertible t) => MonadList (ProbT t m)
instance (Ring t, Monad m) => Monad (ProbT t m)
