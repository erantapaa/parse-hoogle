-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support for programming with names and binders using GHC Generics
--   
@package unbound-generics
@version 0.1.2.1

module Unbound.Generics.LocallyNameless.Internal.Lens
type Getting r s a = (a -> Const r a) -> s -> Const r s
view :: MonadReader s m => Getting a s a -> m a


-- | Some utilities for working with Folds.
--   
--   If you are using <a>lens</a>, you don't need this module.
module Unbound.Generics.LocallyNameless.Internal.Fold
type Fold s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s
type Traversal' s a = forall f. Applicative f => (a -> f a) -> s -> f s
toListOf :: Fold s a -> s -> [a]
filtered :: (a -> Bool) -> Traversal' a a
justFiltered :: (a -> Maybe b) -> Fold a b
foldMapOf :: Getting r s a -> (a -> r) -> s -> r

module Unbound.Generics.LocallyNameless.Internal.Iso
data Exchange a b s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b s t
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
type AnIso s t a b = Exchange a b a (Identity b) -> Exchange a b s (Identity t)
iso :: (s -> a) -> (b -> t) -> Iso s t a b
from :: AnIso s t a b -> Iso b a t s
withIso :: AnIso s t a b -> ((s -> a) -> (b -> t) -> r) -> r
instance Profunctor (Exchange a b)


-- | A slow, but hopefully correct implementation of permutations.
module Unbound.Generics.PermM

-- | A <i>permutation</i> is a bijective function from names to names which
--   is the identity on all but a finite set of names. They form the basis
--   for nominal approaches to binding, but can also be useful in general.
newtype Perm a
Perm :: (Map a a) -> Perm a

-- | <tt><a>permValid</a> p</tt> returns <tt>True</tt> iff the perumation
--   is <i>valid</i>: if each value in the range of the permutation is also
--   a key.
permValid :: Ord a => Perm a -> Bool

-- | Create a permutation which swaps two elements.
single :: Ord a => a -> a -> Perm a

-- | Compose two permutations. The right-hand permutation will be applied
--   first.
compose :: Ord a => Perm a -> Perm a -> Perm a

-- | Apply a permutation to an element of the domain.
apply :: Ord a => Perm a -> a -> a

-- | The <i>support</i> of a permutation is the set of elements which are
--   not fixed.
support :: Ord a => Perm a -> [a]

-- | Is this the identity permutation?
isid :: Ord a => Perm a -> Bool

-- | <i>Join</i> two permutations by taking the union of their relation
--   graphs. Fail if they are inconsistent, i.e. map the same element to
--   two different elements.
join :: Ord a => Perm a -> Perm a -> Maybe (Perm a)

-- | The empty (identity) permutation.
empty :: Perm a

-- | Restrict a permutation to a certain domain.
restrict :: Ord a => Perm a -> [a] -> Perm a

-- | <tt>mkPerm l1 l2</tt> creates a permutation that sends <tt>l1</tt> to
--   <tt>l2</tt>. Fail if there is no such permutation, either because the
--   lists have different lengths or because they are inconsistent (which
--   can only happen if <tt>l1</tt> or <tt>l2</tt> have repeated elements).
mkPerm :: Ord a => [a] -> [a] -> Maybe (Perm a)
instance Show a => Show (PartialPerm a)
instance Ord a => Monoid (Perm a)
instance Show a => Show (Perm a)
instance Ord a => Eq (Perm a)


-- | Names stand for values. They may be bound or free.
module Unbound.Generics.LocallyNameless.Name

-- | An abstract datatype of names <tt>Name a</tt> that stand for terms of
--   type <tt>a</tt>. The type <tt>a</tt> is used as a tag to distinguish
--   these names from names that may stand for other sorts of terms.
--   
--   Two names in a term are consider <a>aeq</a> equal when they are the
--   same name (in the sense of '(==)'). In patterns, however, any two
--   names are equal if they occur in the same place within the pattern.
--   This induces alpha equivalence on terms in general.
--   
--   Names may either be free or bound (see <a>isFreeName</a>). Free names
--   may be extracted from patterns using <a>isPat</a>. Bound names cannot
--   be.
data Name a
Fn :: String -> !Integer -> Name a
Bn :: !Integer -> !Integer -> Name a

-- | Returns <a>True</a> iff the given <tt>Name a</tt> is free.
isFreeName :: Name a -> Bool

-- | Make a free 'Name a' from a <a>String</a>
string2Name :: String -> Name a

-- | Synonym for <a>string2Name</a>.
s2n :: String -> Name a

-- | Make a name from a <a>String</a> and an <a>Integer</a> index
makeName :: String -> Integer -> Name a

-- | Get the string part of a <a>Name</a>.
name2String :: Name a -> String

-- | Get the integer part of a <a>Name</a>.
name2Integer :: Name a -> Integer

-- | An <tt>AnyName</tt> is a name that stands for a term of some
--   (existentially hidden) type.
data AnyName
AnyName :: Name a -> AnyName
instance Typeable Name
instance Eq (Name a)
instance Ord (Name a)
instance Generic (Name a)
instance Datatype D1Name
instance Constructor C1_0Name
instance Constructor C1_1Name
instance Ord AnyName
instance Eq AnyName
instance Show AnyName
instance Show (Name a)


-- | Global freshness monad.
module Unbound.Generics.LocallyNameless.Fresh

-- | The <tt>Fresh</tt> type class governs monads which can generate new
--   globally unique <a>Name</a>s based on a given <a>Name</a>.
class Monad m => Fresh m
fresh :: Fresh m => Name a -> m (Name a)

-- | The <tt>FreshM</tt> monad transformer. Keeps track of the lowest index
--   still globally unused, and increments the index every time it is asked
--   for a fresh name.
newtype FreshMT m a
FreshMT :: StateT Integer m a -> FreshMT m a
unFreshMT :: FreshMT m a -> StateT Integer m a

-- | Run a <a>FreshMT</a> computation (with the global index starting at
--   zero).
runFreshMT :: Monad m => FreshMT m a -> m a

-- | Run a <a>FreshMT</a> computation given a starting index for fresh name
--   generation.
contFreshMT :: Monad m => FreshMT m a -> Integer -> m a

-- | A convenient monad which is an instance of <a>Fresh</a>. It keeps
--   track of a global index used for generating fresh names, which is
--   incremented every time <a>fresh</a> is called.
type FreshM = FreshMT Identity

-- | Run a FreshM computation (with the global index starting at zero).
runFreshM :: FreshM a -> a

-- | Run a FreshM computation given a starting index.
contFreshM :: FreshM a -> Integer -> a
instance Functor m => Functor (FreshMT m)
instance (Monad m, Functor m) => Applicative (FreshMT m)
instance (Functor m, MonadPlus m) => Alternative (FreshMT m)
instance Monad m => Monad (FreshMT m)
instance MonadPlus m => MonadPlus (FreshMT m)
instance MonadIO m => MonadIO (FreshMT m)
instance MonadFix m => MonadFix (FreshMT m)
instance (Monoid w, Fresh m) => Fresh (WriterT w m)
instance (Monoid w, Fresh m) => Fresh (WriterT w m)
instance Fresh m => Fresh (StateT s m)
instance Fresh m => Fresh (StateT s m)
instance Fresh m => Fresh (ReaderT r m)
instance Fresh m => Fresh (MaybeT m)
instance Fresh m => Fresh (ExceptT e m)
instance (Error e, Fresh m) => Fresh (ErrorT e m)
instance Monad m => Fresh (FreshMT m)
instance MonadWriter w m => MonadWriter w (FreshMT m)
instance MonadReader r m => MonadReader r (FreshMT m)
instance MonadState s m => MonadState s (FreshMT m)
instance MonadError e m => MonadError e (FreshMT m)
instance MonadCont m => MonadCont (FreshMT m)
instance MonadTrans FreshMT


-- | Local freshness monad.
module Unbound.Generics.LocallyNameless.LFresh

-- | This is the class of monads that support freshness in an (implicit)
--   local scope. Generated names are fresh for the current local scope,
--   not necessarily globally fresh.
class Monad m => LFresh m
lfresh :: (LFresh m, Typeable a) => Name a -> m (Name a)
avoid :: LFresh m => [AnyName] -> m a -> m a
getAvoids :: LFresh m => m (Set AnyName)

-- | A convenient monad which is an instance of <a>LFresh</a>. It keeps
--   track of a set of names to avoid, and when asked for a fresh one will
--   choose the first unused numerical name.
type LFreshM = LFreshMT Identity

-- | Run a LFreshM computation in an empty context.
runLFreshM :: LFreshM a -> a

-- | Run a LFreshM computation given a set of names to avoid.
contLFreshM :: LFreshM a -> Set AnyName -> a

-- | The LFresh monad transformer. Keeps track of a set of names to avoid,
--   and when asked for a fresh one will choose the first numeric prefix of
--   the given name which is currently unused.
newtype LFreshMT m a
LFreshMT :: ReaderT (Set AnyName) m a -> LFreshMT m a
unLFreshMT :: LFreshMT m a -> ReaderT (Set AnyName) m a

-- | Run an <a>LFreshMT</a> computation in an empty context.
runLFreshMT :: LFreshMT m a -> m a

-- | Run an <a>LFreshMT</a> computation given a set of names to avoid.
contLFreshMT :: LFreshMT m a -> Set AnyName -> m a
instance Functor m => Functor (LFreshMT m)
instance Applicative m => Applicative (LFreshMT m)
instance Alternative m => Alternative (LFreshMT m)
instance Monad m => Monad (LFreshMT m)
instance MonadIO m => MonadIO (LFreshMT m)
instance MonadPlus m => MonadPlus (LFreshMT m)
instance MonadFix m => MonadFix (LFreshMT m)
instance MonadWriter w m => MonadWriter w (LFreshMT m)
instance MonadReader r m => MonadReader r (LFreshMT m)
instance MonadState s m => MonadState s (LFreshMT m)
instance MonadError e m => MonadError e (LFreshMT m)
instance MonadCont m => MonadCont (LFreshMT m)
instance MonadTrans LFreshMT
instance (Monoid w, LFresh m) => LFresh (WriterT w m)
instance (Monoid w, LFresh m) => LFresh (WriterT w m)
instance LFresh m => LFresh (StateT s m)
instance LFresh m => LFresh (StateT s m)
instance LFresh m => LFresh (ReaderT r m)
instance LFresh m => LFresh (MaybeT m)
instance LFresh m => LFresh (ListT m)
instance LFresh m => LFresh (IdentityT m)
instance LFresh m => LFresh (ExceptT e m)
instance (Error e, LFresh m) => LFresh (ErrorT e m)
instance LFresh m => LFresh (ContT r m)
instance Monad m => LFresh (LFreshMT m)


-- | Use the <a>Alpha</a> typeclass to mark types that may contain
--   <a>Name</a>s.
module Unbound.Generics.LocallyNameless.Alpha

-- | Types that are instances of <tt>Alpha</tt> may participate in name
--   representation.
--   
--   Minimal instance is entirely empty, provided that your type is an
--   instance of <a>Generic</a>.
class Show a => Alpha a where aeq' c = (gaeq c) `on` from fvAny' c nfn = fmap to . gfvAny c nfn . from close c b = to . gclose c b . from open c b = to . gopen c b . from isPat = gisPat . from isTerm = gisTerm . from isEmbed _ = False nthPatFind = gnthPatFind . from namePatFind = gnamePatFind . from swaps' ctx perm = to . gswaps ctx perm . from lfreshen' ctx m cont = glfreshen ctx (from m) (cont . to) freshen' ctx = liftM (first to) . gfreshen ctx . from acompare' c = (gacompare c) `on` from
aeq' :: Alpha a => AlphaCtx -> a -> a -> Bool
fvAny' :: (Alpha a, Contravariant f, Applicative f) => AlphaCtx -> (AnyName -> f AnyName) -> a -> f a
close :: (Alpha a, Alpha b) => AlphaCtx -> b -> a -> a
open :: (Alpha a, Alpha b) => AlphaCtx -> b -> a -> a
isPat :: Alpha a => a -> DisjointSet AnyName
isTerm :: Alpha a => a -> Bool
isEmbed :: Alpha a => a -> Bool
nthPatFind :: Alpha a => a -> NthPatFind
namePatFind :: Alpha a => a -> NamePatFind
swaps' :: Alpha a => AlphaCtx -> Perm AnyName -> a -> a
lfreshen' :: (Alpha a, LFresh m) => AlphaCtx -> a -> (a -> Perm AnyName -> m b) -> m b
freshen' :: (Alpha a, Fresh m) => AlphaCtx -> a -> m (a, Perm AnyName)
acompare' :: Alpha a => AlphaCtx -> a -> a -> Ordering

-- | A <tt>DisjointSet a</tt> is a <a>Just</a> a list of distinct
--   <tt>a</tt>s. In addition to a monoidal structure, a disjoint set also
--   has an annihilator <a>inconsistentDisjointSet</a>.
--   
--   <pre>
--   inconsistentDisjointSet &lt;&gt; s == inconsistentDisjointSet
--   s &lt;&gt; inconsistentDisjoinSet == inconsistentDisjointSet
--   </pre>
newtype DisjointSet a
DisjointSet :: (Maybe [a]) -> DisjointSet a

-- | Returns a <tt>DisjointSet a</tt> that is the annihilator element for
--   the <a>Monoid</a> instance of <a>DisjointSet</a>.
inconsistentDisjointSet :: DisjointSet a

-- | <tt>singletonDisjointSet x</tt> a <tt>DisjointSet a</tt> that contains
--   the single element <tt>x</tt>
singletonDisjointSet :: a -> DisjointSet a

-- | <tt>isConsistentDisjointSet</tt> returns <tt>True</tt> iff the given
--   disjoint set is not inconsistent.
isConsistentDisjointSet :: DisjointSet a -> Bool

-- | <tt>isNullDisjointSet</tt> return <tt>True</tt> iff the given disjoint
--   set is <a>mempty</a>.
isNullDisjointSet :: DisjointSet a -> Bool

-- | The result of <tt><a>nthPatFind</a> a i</tt> is <tt>Left k</tt> where
--   <tt>k</tt> is the number of names in pattern <tt>a</tt> with <tt>k
--   &lt; i</tt> or <tt>Right x</tt> where <tt>x</tt> is the <tt>i</tt>th
--   name in <tt>a</tt>
type NthPatFind = Integer -> Either Integer AnyName

-- | The result of <tt><a>namePatFind</a> a x</tt> is either <tt>Left
--   i</tt> if <tt>a</tt> is a pattern that contains <tt>i</tt> free names
--   none of which are <tt>x</tt>, or <tt>Right j</tt> if <tt>x</tt> is the
--   <tt>j</tt>th name in <tt>a</tt>
type NamePatFind = AnyName -> Either Integer Integer

-- | Some <a>Alpha</a> operations need to record information about their
--   progress. Instances should just pass it through unchanged.
--   
--   The context records whether we are currently operating on terms or
--   patterns, and how many binding levels we've descended.
data AlphaCtx

-- | The starting context for alpha operations: we are expecting to work on
--   terms and we are under no binders.
initialCtx :: AlphaCtx

-- | Switches to a context where we expect to operate on patterns.
patternCtx :: AlphaCtx -> AlphaCtx

-- | Switches to a context where we expect to operate on terms.
termCtx :: AlphaCtx -> AlphaCtx

-- | Returns <a>True</a> iff we are in a context where we expect to see
--   terms.
isTermCtx :: AlphaCtx -> Bool

-- | Increment the number of binders that we are operating under.
incrLevelCtx :: AlphaCtx -> AlphaCtx

-- | Decrement the number of binders that we are operating under.
decrLevelCtx :: AlphaCtx -> AlphaCtx

-- | Are we operating under no binders?
isZeroLevelCtx :: AlphaCtx -> Bool
gaeq :: GAlpha f => AlphaCtx -> f a -> f a -> Bool
gfvAny :: (GAlpha f, Contravariant g, Applicative g) => AlphaCtx -> (AnyName -> g AnyName) -> f a -> g (f a)
gclose :: (GAlpha f, Alpha b) => AlphaCtx -> b -> f a -> f a
gopen :: (GAlpha f, Alpha b) => AlphaCtx -> b -> f a -> f a
gisPat :: GAlpha f => f a -> DisjointSet AnyName
gisTerm :: GAlpha f => f a -> Bool
gnthPatFind :: GAlpha f => f a -> NthPatFind
gnamePatFind :: GAlpha f => f a -> NamePatFind
gswaps :: GAlpha f => AlphaCtx -> Perm AnyName -> f a -> f a
gfreshen :: (GAlpha f, Fresh m) => AlphaCtx -> f a -> m (f a, Perm AnyName)
glfreshen :: (GAlpha f, LFresh m) => AlphaCtx -> f a -> (f a -> Perm AnyName -> m b) -> m b
gacompare :: GAlpha f => AlphaCtx -> f a -> f a -> Ordering
instance Eq Mode
instance Alpha AnyName
instance Typeable a => Alpha (Name a)
instance (Alpha a, Alpha b, Alpha c, Alpha d, Alpha e) => Alpha (a, b, c, d, e)
instance (Alpha a, Alpha b, Alpha c, Alpha d) => Alpha (a, b, c, d)
instance (Alpha a, Alpha b, Alpha c) => Alpha (a, b, c)
instance (Alpha a, Alpha b) => Alpha (a, b)
instance (Alpha a, Alpha b) => Alpha (Either a b)
instance Alpha ()
instance Alpha a => Alpha [a]
instance Alpha a => Alpha (Maybe a)
instance Alpha Bool
instance (Integral n, Alpha n) => Alpha (Ratio n)
instance Alpha Double
instance Alpha Float
instance Alpha Integer
instance Alpha Char
instance Alpha Int
instance (GAlpha f, GAlpha g) => GAlpha (f :+: g)
instance (GAlpha f, GAlpha g) => GAlpha (f :*: g)
instance GAlpha V1
instance GAlpha U1
instance GAlpha f => GAlpha (M1 i c f)
instance Alpha c => GAlpha (K1 i c)
instance Foldable DisjointSet
instance Eq a => Monoid (DisjointSet a)


-- | The fundamental binding form. The type <tt><a>Bind</a> p t</tt> allows
--   you to place a pattern <tt>p</tt> in a term <tt>t</tt> such that the
--   names in the pattern scope over the term. Use <a>bind</a> and
--   <a>unbind</a> and <a>lunbind</a> to work with <tt><a>Bind</a> p t</tt>
module Unbound.Generics.LocallyNameless.Bind

-- | A term of type <tt><a>Bind</a> p t</tt> is a term that binds the free
--   variable occurrences of the variables in pattern <tt>p</tt> in the
--   term <tt>t</tt>. In the overall term, those variables are now bound.
--   See also <a>bind</a> and <a>unbind</a> and <a>lunbind</a>
data Bind p t
B :: p -> t -> Bind p t
instance Generic (Bind p t)
instance Datatype D1Bind
instance Constructor C1_0Bind
instance (Alpha p, Alpha t) => Alpha (Bind p t)
instance (Show p, Show t) => Show (Bind p t)


-- | The pattern <tt><a>Embed</a> t</tt> contains a term <tt>t</tt>.
module Unbound.Generics.LocallyNameless.Embed

-- | <tt>Embed</tt> allows for terms to be <i>embedded</i> within patterns.
--   Such embedded terms do not bind names along with the rest of the
--   pattern. For examples, see the tutorial or examples directories.
--   
--   If <tt>t</tt> is a <i>term type</i>, then <tt>Embed t</tt> is a
--   <i>pattern type</i>.
--   
--   <tt>Embed</tt> is not abstract since it involves no binding, and hence
--   it is safe to manipulate directly. To create and destruct
--   <tt>Embed</tt> terms, you may use the <tt>Embed</tt> constructor
--   directly. (You may also use the functions <tt>embed</tt> and
--   <tt>unembed</tt>, which additionally can construct or destruct any
--   number of enclosing <tt>Shift</tt>s at the same time.)
newtype Embed t
Embed :: t -> Embed t
class IsEmbed e where type family Embedded e :: *
embedded :: (IsEmbed e, Profunctor p, Functor f) => p (Embedded e) (f (Embedded e)) -> p e (f e)
instance Eq t => Eq (Embed t)
instance Generic (Embed t)
instance Datatype D1Embed
instance Constructor C1_0Embed
instance Alpha t => Alpha (Embed t)
instance Show a => Show (Embed a)
instance IsEmbed (Embed t)


-- | The pattern <tt><a>Shift</a> e</tt> shifts the scope of the embedded
--   term in <tt>e</tt> one level outwards.
module Unbound.Generics.LocallyNameless.Shift

-- | The type <tt>Shift e</tt> is an embedding pattern that shifts the
--   scope of the free variables of the embedded term <tt><a>Embedded</a>
--   e</tt> up by one level.
newtype Shift e
Shift :: e -> Shift e
instance Alpha e => Alpha (Shift e)
instance Show e => Show (Shift e)
instance IsEmbed e => IsEmbed (Shift e)
instance Functor Shift


-- | The pattern <tt><a>Rebind</a> p1 p2</tt> binds the names in
--   <tt>p1</tt> and <tt>p2</tt> just as <tt>(p1, p2)</tt> would, however
--   it additionally also brings the names of <tt>p1</tt> into scope in
--   <tt>p2</tt>.
module Unbound.Generics.LocallyNameless.Rebind

-- | <tt><a>Rebind</a> p1 p2</tt> is a pattern that binds the names of
--   <tt>p1</tt> and <tt>p2</tt>, and additionally brings the names of
--   <tt>p1</tt> into scope over <tt>p2</tt>.
--   
--   This may be used, for example, to faithfully represent Scheme's
--   <tt>let*</tt> binding form, defined by:
--   
--   <pre>
--   (let* () body) ≙ body
--   (let* ([v1, e1] binds ...) body) ≙ (let ([v1, e1]) (let* (binds ...) body))
--   </pre>
--   
--   using the following AST:
--   
--   <pre>
--   type Var = Name Expr
--   data Lets = EmptyLs
--             | ConsLs (Rebind (Var, Embed Expr) Lets)
--   data Expr = ...
--             | LetStar (Bind Lets Expr)
--             | ...
--   </pre>
data Rebind p1 p2
Rebnd :: p1 -> p2 -> Rebind p1 p2
instance Generic (Rebind p1 p2)
instance (Eq p1, Eq p2) => Eq (Rebind p1 p2)
instance Datatype D1Rebind
instance Constructor C1_0Rebind
instance (Alpha p1, Alpha p2) => Alpha (Rebind p1 p2)
instance (Show p1, Show p2) => Show (Rebind p1 p2)


-- | The pattern <tt><a>Rec</a> p</tt> binds the names in <tt>p</tt> like
--   <tt>p</tt> itself would, but additionally, the names in <tt>p</tt> are
--   scope over <tt>p</tt>.
--   
--   The term <tt><a>TRec</a> p</tt> is shorthand for <tt><a>Bind</a> (Rec
--   p) ()</tt>
module Unbound.Generics.LocallyNameless.Rec

-- | If <tt>p</tt> is a pattern type, then <tt>Rec p</tt> is also a pattern
--   type, which is <i>recursive</i> in the sense that <tt>p</tt> may bind
--   names in terms embedded within itself. Useful for encoding e.g.
--   lectrec and Agda's dot notation.
data Rec p

-- | Constructor for recursive patterns.
rec :: Alpha p => p -> Rec p

-- | Destructor for recursive patterns.
unrec :: Alpha p => Rec p -> p

-- | <tt>TRec</tt> is a standalone variant of <a>Rec</a>: the only
--   difference is that whereas <tt><a>Rec</a> p</tt> is a pattern type,
--   <tt>TRec p</tt> is a <i>term type</i>. It is isomorphic to
--   <tt><a>Bind</a> (<a>Rec</a> p) ()</tt>.
--   
--   Note that <tt>TRec</tt> corresponds to Pottier's <i>abstraction</i>
--   construct from alpha-Caml. In this context, <tt><tt>Embed</tt> t</tt>
--   corresponds to alpha-Caml's <tt>inner t</tt>, and <tt><tt>Shift</tt>
--   (<tt>Embed</tt> t)</tt> corresponds to alpha-Caml's <tt>outer t</tt>.
newtype TRec p
TRec :: (Bind (Rec p) ()) -> TRec p
instance Generic (Rec p)
instance Eq p => Eq (Rec p)
instance Generic (TRec p)
instance Datatype D1Rec
instance Constructor C1_0Rec
instance Datatype D1TRec
instance Constructor C1_0TRec
instance Alpha p => Alpha (TRec p)
instance Alpha p => Alpha (Rec p)
instance Show a => Show (TRec a)
instance Show a => Show (Rec a)


-- | Operations on terms and patterns that contain names.
module Unbound.Generics.LocallyNameless.Operations

-- | <tt><a>aeq</a> t1 t2</tt> returns <tt>True</tt> iff <tt>t1</tt> and
--   <tt>t2</tt> are alpha-equivalent terms.
aeq :: Alpha a => a -> a -> Bool

-- | An alpha-respecting total order on terms involving binders.
acompare :: Alpha a => a -> a -> Ordering

-- | <tt><a>fvAny</a></tt> returns a fold over any names in a term
--   <tt>a</tt>.
--   
--   <pre>
--   fvAny :: Alpha a =&gt; Fold a AnyName
--   </pre>
fvAny :: (Alpha a, Contravariant f, Applicative f) => (AnyName -> f AnyName) -> a -> f a

-- | <tt><a>fv</a></tt> returns the free <tt>b</tt> variables of term
--   <tt>a</tt>.
--   
--   <pre>
--   fv :: (Alpha a, Typeable b) =&gt; Fold a (Name b)
--   </pre>
fv :: (Alpha a, Typeable b, Contravariant f, Applicative f) => (Name b -> f (Name b)) -> a -> f a

-- | Freshen a pattern by replacing all old binding <a>Name</a>s with new
--   fresh <a>Name</a>s, returning a new pattern and a <tt><a>Perm</a>
--   <a>Name</a></tt> specifying how <a>Name</a>s were replaced.
freshen :: (Alpha p, Fresh m) => p -> m (p, Perm AnyName)

-- | "Locally" freshen a pattern, replacing all binding names with new
--   names that are not already "in scope". The second argument is a
--   continuation, which takes the renamed term and a permutation that
--   specifies how the pattern has been renamed. The resulting computation
--   will be run with the in-scope set extended by the names just
--   generated.
lfreshen :: (Alpha p, LFresh m) => p -> (p -> Perm AnyName -> m b) -> m b

-- | Apply the given permutation of variable names to the given term.
swaps :: Alpha t => Perm AnyName -> t -> t

-- | A term of type <tt><a>Bind</a> p t</tt> is a term that binds the free
--   variable occurrences of the variables in pattern <tt>p</tt> in the
--   term <tt>t</tt>. In the overall term, those variables are now bound.
--   See also <a>bind</a> and <a>unbind</a> and <a>lunbind</a>
data Bind p t

-- | <tt><a>bind</a> p t</tt> closes over the variables of pattern
--   <tt>p</tt> in the term <tt>t</tt>
bind :: (Alpha p, Alpha t) => p -> t -> Bind p t

-- | <tt><a>unbind</a> b</tt> lets you descend beneath a binder <tt>b ::
--   <a>Bind</a> p t</tt> by returning the pair of the pattern <tt>p</tt>
--   and the term <tt>t</tt> where the variables in the pattern have been
--   made globally fresh with respect to the freshness monad <tt>m</tt>.
unbind :: (Alpha p, Alpha t, Fresh m) => Bind p t -> m (p, t)

-- | <tt>lunbind</tt> opens a binding in an <a>LFresh</a> monad, ensuring
--   that the names chosen for the binders are <i>locally</i> fresh. The
--   components of the binding are passed to a <i>continuation</i>, and the
--   resulting monadic action is run in a context extended to avoid
--   choosing new names which are the same as the ones chosen for this
--   binding.
--   
--   For more information, see the documentation for the <a>LFresh</a> type
--   class.
lunbind :: (LFresh m, Alpha p, Alpha t) => Bind p t -> ((p, t) -> m c) -> m c

-- | Simultaneously unbind two patterns in two terms, returning
--   <a>Nothing</a> if the two patterns don't bind the same number of
--   variables.
unbind2 :: (Fresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => Bind p1 t1 -> Bind p2 t2 -> m (Maybe (p1, t1, p2, t2))

-- | Simultaneously <a>lunbind</a> two patterns in two terms in the
--   <a>LFresh</a> monad, passing <tt>Just (p1, t1, p2, t2)</tt> to the
--   continuation such that the patterns are permuted such that they
--   introduce the same free names, or <a>Nothing</a> if the number of
--   variables differs.
lunbind2 :: (LFresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => Bind p1 t1 -> Bind p2 t2 -> (Maybe (p1, t1, p2, t2) -> m c) -> m c

-- | Simultaneously unbind two patterns in two terms, returning
--   <a>mzero</a> if the patterns don't bind the same number of variables.
unbind2Plus :: (MonadPlus m, Fresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => Bind p1 t1 -> Bind p2 t2 -> m (p1, t1, p2, t2)

-- | <tt><a>Rebind</a> p1 p2</tt> is a pattern that binds the names of
--   <tt>p1</tt> and <tt>p2</tt>, and additionally brings the names of
--   <tt>p1</tt> into scope over <tt>p2</tt>.
--   
--   This may be used, for example, to faithfully represent Scheme's
--   <tt>let*</tt> binding form, defined by:
--   
--   <pre>
--   (let* () body) ≙ body
--   (let* ([v1, e1] binds ...) body) ≙ (let ([v1, e1]) (let* (binds ...) body))
--   </pre>
--   
--   using the following AST:
--   
--   <pre>
--   type Var = Name Expr
--   data Lets = EmptyLs
--             | ConsLs (Rebind (Var, Embed Expr) Lets)
--   data Expr = ...
--             | LetStar (Bind Lets Expr)
--             | ...
--   </pre>
data Rebind p1 p2

-- | <tt><a>rebind</a> p1 p2</tt> is a smart constructor for <a>Rebind</a>.
--   It captures the variables of pattern <tt>p1</tt> that occur within
--   <tt>p2</tt> in addition to providing binding occurrences for all the
--   variables of <tt>p1</tt> and <tt>p2</tt>
rebind :: (Alpha p1, Alpha p2) => p1 -> p2 -> Rebind p1 p2

-- | <tt><a>unrebind</a> p</tt> is the elimination form for <a>Rebind</a>.
--   It is not monadic (unlike <a>unbind</a>) because a <tt>Rebind</tt>
--   pattern can only occur somewhere in a pattern position of a
--   <a>Bind</a>, and therefore <a>unbind</a> must have already been called
--   and all names apropriately <a>freshen</a>ed.
unrebind :: (Alpha p1, Alpha p2) => Rebind p1 p2 -> (p1, p2)

-- | <tt>Embed</tt> allows for terms to be <i>embedded</i> within patterns.
--   Such embedded terms do not bind names along with the rest of the
--   pattern. For examples, see the tutorial or examples directories.
--   
--   If <tt>t</tt> is a <i>term type</i>, then <tt>Embed t</tt> is a
--   <i>pattern type</i>.
--   
--   <tt>Embed</tt> is not abstract since it involves no binding, and hence
--   it is safe to manipulate directly. To create and destruct
--   <tt>Embed</tt> terms, you may use the <tt>Embed</tt> constructor
--   directly. (You may also use the functions <tt>embed</tt> and
--   <tt>unembed</tt>, which additionally can construct or destruct any
--   number of enclosing <tt>Shift</tt>s at the same time.)
newtype Embed t
Embed :: t -> Embed t
class IsEmbed e where type family Embedded e :: *
embedded :: (IsEmbed e, Profunctor p, Functor f) => p (Embedded e) (f (Embedded e)) -> p e (f e)

-- | Embeds a term in an <a>Embed</a>, or an <a>Embed</a> under some number
--   of <a>Shift</a> constructors.
embed :: IsEmbed e => Embedded e -> e

-- | <tt><a>unembed</a> p</tt> extracts the term embedded in the pattern
--   <tt>p</tt>.
unembed :: IsEmbed e => e -> Embedded e

-- | If <tt>p</tt> is a pattern type, then <tt>Rec p</tt> is also a pattern
--   type, which is <i>recursive</i> in the sense that <tt>p</tt> may bind
--   names in terms embedded within itself. Useful for encoding e.g.
--   lectrec and Agda's dot notation.
data Rec p

-- | Constructor for recursive patterns.
rec :: Alpha p => p -> Rec p

-- | Destructor for recursive patterns.
unrec :: Alpha p => Rec p -> p

-- | <tt>TRec</tt> is a standalone variant of <a>Rec</a>: the only
--   difference is that whereas <tt><a>Rec</a> p</tt> is a pattern type,
--   <tt>TRec p</tt> is a <i>term type</i>. It is isomorphic to
--   <tt><a>Bind</a> (<a>Rec</a> p) ()</tt>.
--   
--   Note that <tt>TRec</tt> corresponds to Pottier's <i>abstraction</i>
--   construct from alpha-Caml. In this context, <tt><tt>Embed</tt> t</tt>
--   corresponds to alpha-Caml's <tt>inner t</tt>, and <tt><tt>Shift</tt>
--   (<tt>Embed</tt> t)</tt> corresponds to alpha-Caml's <tt>outer t</tt>.
newtype TRec p
TRec :: (Bind (Rec p) ()) -> TRec p

-- | Constructor for recursive abstractions.
trec :: Alpha p => p -> TRec p

-- | Destructor for recursive abstractions which picks globally fresh names
--   for the binders.
untrec :: (Alpha p, Fresh m) => TRec p -> m p

-- | Destructor for recursive abstractions which picks <i>locally</i> fresh
--   names for binders (see <a>LFresh</a>).
luntrec :: (Alpha p, LFresh m) => TRec p -> m p


-- | A typeclass for types that may participate in capture-avoiding
--   substitution
--   
--   The minimal definition is empty, provided your type is an instance of
--   <a>Generic</a>
--   
--   <pre>
--   type Var = Name Factor
--   data Expr = SumOf [Summand]
--             deriving (Show, Generic)
--   data Summand = ProductOf [Factor]
--             deriving (Show, Generic)
--   instance Subst Var Expr
--   instance Subst Var Summand
--   </pre>
--   
--   The default instance just propagates the substitution into the
--   constituent factors.
--   
--   If you identify the variable occurrences by implementing the
--   <a>isvar</a> function, the derived <a>subst</a> function will be able
--   to substitute a factor for a variable.
--   
--   <pre>
--   data Factor = V Var
--               | C Int
--               | Subexpr Expr
--             deriving (Show, Generic)
--   instance Subst Var Factor where
--     isvar (V v) = Just (SubstName v)
--     isvar _     = Nothing
--   </pre>
module Unbound.Generics.LocallyNameless.Subst

-- | See <tt>isVar</tt>
data SubstName a b
SubstName :: Name a -> SubstName a b

-- | See <a>isCoerceVar</a>
data SubstCoerce a b
SubstCoerce :: Name b -> (b -> Maybe a) -> SubstCoerce a b

-- | Instances of <tt><a>Subst</a> b a</tt> are terms of type <tt>a</tt>
--   that may contain variables of type <tt>b</tt> that may participate in
--   capture-avoiding substitution.
class Subst b a where isvar _ = Nothing isCoerceVar _ = Nothing subst n u x = if (isFreeName n) then case (isvar x :: Maybe (SubstName a b)) of { Just (SubstName m) -> if m == n then u else x Nothing -> case (isCoerceVar x :: Maybe (SubstCoerce a b)) of { Just (SubstCoerce m f) -> if m == n then maybe x id (f u) else x Nothing -> to $ gsubst n u (from x) } } else error $ "Cannot substitute for bound variable " ++ show n substs ss x | all (isFreeName . fst) ss = case (isvar x :: Maybe (SubstName a b)) of { Just (SubstName m) -> case find ((== m) . fst) ss of { Just (_, u) -> u Nothing -> x } Nothing -> case isCoerceVar x :: Maybe (SubstCoerce a b) of { Just (SubstCoerce m f) -> case find ((== m) . fst) ss of { Just (_, u) -> maybe x id (f u) Nothing -> x } Nothing -> to $ gsubsts ss (from x) } } | otherwise = error $ "Cannot substitute for bound variable in: " ++ show (map fst ss)
isvar :: Subst b a => a -> Maybe (SubstName a b)
isCoerceVar :: Subst b a => a -> Maybe (SubstCoerce a b)
subst :: Subst b a => Name b -> b -> a -> a
substs :: Subst b a => [(Name b, b)] -> a -> a
instance (Alpha p, Subst c p) => Subst c (TRec p)
instance Subst c p => Subst c (Rec p)
instance (Subst c p1, Subst c p2) => Subst c (Rebind p1 p2)
instance (Subst c b, Subst c a, Alpha a, Alpha b) => Subst c (Bind a b)
instance Subst c e => Subst c (Shift e)
instance Subst c a => Subst c (Embed a)
instance Subst b AnyName
instance Generic a => Subst b (Name a)
instance (Subst c a, Subst c b) => Subst c (Either a b)
instance Subst c a => Subst c (Maybe a)
instance Subst c a => Subst c [a]
instance (Subst c a, Subst c b, Subst c d, Subst c e, Subst c f) => Subst c (a, b, d, e, f)
instance (Subst c a, Subst c b, Subst c d, Subst c e) => Subst c (a, b, d, e)
instance (Subst c a, Subst c b, Subst c d) => Subst c (a, b, d)
instance (Subst c a, Subst c b) => Subst c (a, b)
instance Subst b Integer
instance Subst b Double
instance Subst b Float
instance Subst b Char
instance Subst b ()
instance Subst b Bool
instance Subst b Int
instance (GSubst b f, GSubst b g) => GSubst b (f :+: g)
instance (GSubst b f, GSubst b g) => GSubst b (f :*: g)
instance GSubst b V1
instance GSubst b U1
instance GSubst b f => GSubst b (M1 i c f)
instance Subst b c => GSubst b (K1 i c)


-- | Dangerous operations that may disturb the invariants of
--   <a>Unbind.Generics.LocallyNameless</a> or of your AST.
module Unbound.Generics.LocallyNameless.Unsafe

-- | A destructor for binders that does <i>not</i> guarantee fresh names
--   for the binders.
unsafeUnbind :: (Alpha p, Alpha t) => Bind p t -> (p, t)


-- | Template Haskell methods to construct instances of <a>Alpha</a> for
--   datatypes that don't contain any names and don't participate in
--   <a>Alpha</a> operations in any non-trivial way.
module Unbound.Generics.LocallyNameless.TH

-- | Make a trivial <tt>instance <a>Alpha</a> T</tt> for a type <tt>T</tt>
--   that does not contain any bound or free variable names (or any in
--   general any values that are themselves non-trivial instances of
--   <a>Alpha</a>). Use this to write <a>Alpha</a> instances for types that
--   you don't want to traverse via their <tt>GHC.Generics.Rep</tt>
--   representation just to find out that there aren't any names.
--   
--   <pre>
--   newtype T = T Int deriving (Eq, Ord, Show)
--   $(makeClosedAlpha T)
--   -- constructs
--   -- instance Alpha T where
--   --   aeq' _ = (==)
--   --   acompare' _ = compare
--   --   fvAny' _ _ = pure
--   --   close _ _ = id
--   --   open _ _ = id
--   --   isPat _ = mempty
--   --   isTerm _ = True
--   --   nthPatFind _ = Left
--   --   namePatFind _ _ = Left 0
--   --   swaps' _ _ = id
--   --   freshen' _ i = return (i, mempty)
--   --   lfreshen' _ i cont = cont i mempty
--   </pre>
makeClosedAlpha :: Name -> DecsQ


-- | The purpose of <tt>unbound-genrics</tt> is to simplify the
--   construction of data structures with rich variable binding structure
--   by providing generic implementations of alpha-equivalence
--   (<a>aeq</a>), free variable permutation (<a>swaps</a>), local and
--   global variable freshness (<a>lfresh</a>, <a>fresh</a>),
--   
--   See <a>Alpha</a>, <a>Bind</a>,
--   <a>Unbound.Generics.LocallyNameless.Operations</a> for more
--   information.
module Unbound.Generics.LocallyNameless
