-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generates testcases from program-snippets
--   
@package TestExplode
@version 0.1.0.0


-- | With this module you can define a graph of part-testcases
--   (<a>Casepart</a>) and evaluate this graph to a list of strings, where
--   every string is the concatenation of the code of the part-testcases.
module TestExplode.TestExplode

-- | The part-testcase
data Casepart cnf locals
Casepart :: Text -> Text -> Text -> (cnf -> locals -> Text) -> (cnf -> locals -> locals) -> (cnf -> locals -> Bool) -> CPType -> Casepart cnf locals

-- | short description of the part-testcase, currently used a) at top of a
--   testcase to show which path the generated testcase belongs to and b)
--   in the visualised graph as node-label
shortDesc :: Casepart cnf locals -> Text

-- | long description of the part-testcase currently generated in front of
--   the code of the part-testcase
longDesc :: Casepart cnf locals -> Text

-- | description of the condition, under which the part-testcase is valid
--   (if not, the path with this part-testcase will not be generated)
condDesc :: Casepart cnf locals -> Text

-- | the actual code, which forms the part-testcase, dependent of the
--   "configuration" (the "cnf" in 'Casepart cnf locals'), which is the
--   test-data, and local variables, that are changed by a Casepart.
codeFkt :: Casepart cnf locals -> cnf -> locals -> Text

-- | The changes in the local variables
varFkt :: Casepart cnf locals -> cnf -> locals -> locals

-- | the condition under which the part-testcase is valid (if not, the path
--   with this part-testcase will not be generated)
condition :: Casepart cnf locals -> cnf -> locals -> Bool

-- | Type of the Casepart, mainly (up to now only) for visualisation in the
--   graph of Caseparts
cpType :: Casepart cnf locals -> CPType

-- | The part-testcase, internal format of <a>Casepart</a>, with a
--   writer-monad as stringFkt instead of the varFkt and the old stringFkt
data CasepartInternal cnf locals
CasepartInternal :: Text -> Text -> Text -> (cnf -> locals -> Writer (Seq Text) locals) -> (cnf -> locals -> Bool) -> CPType -> CasepartInternal cnf locals
shortDescI :: CasepartInternal cnf locals -> Text
longDescI :: CasepartInternal cnf locals -> Text
condDescI :: CasepartInternal cnf locals -> Text
codeFktI :: CasepartInternal cnf locals -> cnf -> locals -> Writer (Seq Text) locals
conditionI :: CasepartInternal cnf locals -> cnf -> locals -> Bool
cpTypeI :: CasepartInternal cnf locals -> CPType

-- | Types of Caseparts, mainly (up to now only) for visualisation of the
--   graph of Caseparts
data CPType
NormalCP :: CPType
Mark :: CPType

-- | Directed graph with one end, self-invented definition
data DirGraph a

-- | Constructor for a node alone, A node is a graph.
SimpleDG :: a -> DirGraph a

-- | Constructor for one sub-graph after another
Conc :: (DirGraph a) -> (DirGraph a) -> DirGraph a

-- | Constructor for the "splitting" of graphs, comparable with an "if".
--   The <a>Join</a> makes the many ends and begins to one end and one
--   begin
Join :: (SplittedGraph a) -> DirGraph a

-- | A graph with more attributes, importing of a <a>Testgraph</a>, only
--   the part <a>dirGraph</a> is used
StructDG :: (Testgraph a) -> DirGraph a

-- | many disjunct graphs Every part-graph has one end and one begin
data SplittedGraph a
Split :: [DirGraph a] -> SplittedGraph a
data Testgraph a
Testgraph :: DirGraph a -> TGDocuInfo -> Testgraph a
dirGraph :: Testgraph a -> DirGraph a
docuInfo :: Testgraph a -> TGDocuInfo
data TGDocuInfo
TGDocuInfo :: String -> String -> String -> Bool -> Bool -> TGDocuInfo
name :: TGDocuInfo -> String
descForNode :: TGDocuInfo -> String
descForTex :: TGDocuInfo -> String
generic :: TGDocuInfo -> Bool
toExpand :: TGDocuInfo -> Bool
data Expand
Expand :: Expand
NotExpand :: Expand
AsIs :: Expand

-- | The heart of this module, the final function. It takes configurations
--   (<tt>cnf</tt> means testvalues), that is a record of variables with a
--   value, a function that describes the "prelude" of one testcase
--   (without comment chars, which are later added) (a good starting value
--   : the <a>show</a>-function of <tt>cnf</tt>, so that the used
--   test-values are printed on top of the testcase), the graph of
--   testcases and returns
--   
--   voilÃ¡:
--   
--   the list of testcases, ready to printed out in seperate files and to
--   run.
generate :: Text -> [cnf] -> locals -> (cnf -> Text) -> DirGraph (CasepartInternal cnf locals) -> [Text]

-- | An empty testcase, all strings are "". The condition is always
--   <a>True</a>. Shall serve as an starting point for own definitions of
--   <tt>Casepart'</tt>s.
emptyCp :: Casepart cnf locals

-- | Convenience Function to make easily a mark.
markCp :: Text -> Casepart cnf locals

-- | Looks for all embedded <a>Testgraph</a> in a <a>DirGraph</a>, double
--   embedded <a>Testgraph</a> (identified by the attribute <a>name</a>)
--   are ignored.
getSubGraphs :: DirGraph a -> [(String, Testgraph a)] -> [(String, Testgraph a)]

-- | Function to create a node, function for the user. If longDesc = "",
--   shortDesc is used as longDesc.
mkEle :: Casepart cnf locals -> DirGraph (CasepartInternal cnf locals)

-- | Infix synonym for <a>conc</a>
(&-&) :: DirGraph a -> DirGraph a -> DirGraph a

-- | Function to craete a <a>Conc</a> of two sub-graphs
conc :: DirGraph a -> DirGraph a -> DirGraph a

-- | Function to create a splitted graph
split :: [DirGraph a] -> DirGraph a

-- | Function to add a testgraph to a dirgraph with converting-function f
--   of the testdata ("cnfOld" resp. "cnfNew") and a Boolean, that says, if
--   the subgraph should be expanded or not.
mkGraph2Ele :: (cnfNew -> cnfOld) -> (localsInB -> localsInA) -> (localsInB -> localsInA -> localsInB) -> Expand -> Testgraph (CasepartInternal cnfOld localsInA) -> DirGraph (CasepartInternal cnfNew localsInB)

-- | Function to add a testgraph to a dirgraph without converting-function
mkGraph2Ele0 :: Testgraph a -> DirGraph a

-- | Converts a DirGraph, for example our testgraphs. With that function
--   you can import other testgraphs with another set of variables. You
--   need a interpreting from the target data-type to the source data-type
--   (not vice versa)
convertDirGraph :: (cnfB -> cnfA) -> (localsInB -> localsInA) -> (localsInB -> localsInA -> localsInB) -> DirGraph (CasepartInternal cnfA localsInA) -> DirGraph (CasepartInternal cnfB localsInB)

-- | Converts a testgraph, necessary in order to add a different testgraph
--   ( with another type of configuration) to a dirGraph
convertTestgraph :: (cnfB -> cnfA) -> (localsInB -> localsInA) -> (localsInB -> localsInA -> localsInB) -> Testgraph (CasepartInternal cnfA localsInA) -> Testgraph (CasepartInternal cnfB localsInB)
instance Show CPType
instance Eq CPType


-- | The Functions of this module enables you to generate FGL-Graphs for
--   the haskell module graphviz.
module TestExplode.DirGraphCombine

-- | The heart of this module: DirGraph to VizGraph. Runs the state monad
--   <a>mkGraphBeginEnd</a>.
mkVizGraph :: DirGraph a -> VizGraph a

-- | the evaluate-function of the EDSL to generate a VizGraph. Normally the
--   function <a>mkVizGraph</a> should be sufficent for the end-user. The
--   state is a <a>VizGraph</a>, that is used to apply the function
--   <a>newNodes</a> to it, that gives one or more new nodes. In this
--   VizGraph the Nodes are simply added, edges are senseless and not
--   added. The output is the resulting VizGraph and a tuple of the first
--   Node and the last Node (remember: a DirGraph has exactly one begin and
--   one end).
mkGraphBeginEnd :: DirGraph a -> State (VizGraph a) (VizGraph a, (Node, Node))

-- | Graph for Graphviz: a FGL-Graph
type VizGraph a = Gr (Maybe a, Maybe TGDocuInfo) ()
