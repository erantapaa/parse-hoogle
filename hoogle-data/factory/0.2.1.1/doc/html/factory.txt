-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Rational arithmetic in an irrational world.
--   
@package factory
@version 0.2.1.1


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Facilitates representation of
--   <a>Integral</a> values in alternative <a>Integral</a> bases.</li>
--   </ul>
module Factory.Math.Radix

-- | <ul>
--   <li><a>http://mathworld.wolfram.com/DigitSum.html</a>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Digit_sum</a>.</li>
--   </ul>
digitSum :: (Ix decimal, Integral base, Integral decimal, Show base, Show decimal) => base -> decimal -> decimal

-- | <a>http://en.wikipedia.org/wiki/Digital_root</a>.
digitalRoot :: (Ix decimal, Integral decimal, Show decimal) => decimal -> decimal

-- | <ul>
--   <li>Convert the <a>String</a>-representation of a number in the
--   specified base, to a decimal integer.</li>
--   <li>Both negative numbers and negative bases are permissible.</li>
--   </ul>
fromBase :: (Integral base, Integral decimal, Read decimal, Show base) => base -> String -> decimal

-- | <ul>
--   <li>Convert the specified integral decimal quantity, to an alternative
--   base, and represent the result as a <a>String</a>.</li>
--   <li>Both negative decimals and negative bases are permissible.</li>
--   <li>The conversion to <a>Char</a> can only succeed where printable and
--   intelligible characters exist to represent all digits in the chosen
--   base; which in practice means <tt>(-36 &lt;= base &lt;= 36)</tt>.</li>
--   </ul>
toBase :: (Ix decimal, Integral base, Integral decimal, Show base, Show decimal) => base -> decimal -> String


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Exports a common interface for
--   implementations of <i>prime-number</i> generators.</li>
--   </ul>
module Factory.Math.Primes

-- | Defines the methods expected of a <i>prime-number</i> generator.
class Algorithmic algorithm
primes :: (Algorithmic algorithm, NFData i, Ix i, Integral i) => algorithm -> [i]

-- | <ul>
--   <li>Returns the constant list, defining the <i>Primorial</i>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Primorial</a>.</li>
--   <li><a>http://mathworld.wolfram.com/Primorial.html</a>.</li>
--   </ul>
primorial :: (Algorithmic algorithm, NFData i, Ix i, Integral i) => algorithm -> [i]

-- | <ul>
--   <li>Returns the constant ordered infinite list of <i>Mersenne
--   numbers</i>.</li>
--   <li>Only the subset composed from a prime exponent is returned; which
--   is a strict superset of the <i>Mersenne Primes</i>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Mersenne_prime</a>.</li>
--   <li><a>http://mathworld.wolfram.com/MersenneNumber.html</a></li>
--   </ul>
mersenneNumbers :: (Algorithmic algorithm, Integral i) => algorithm -> [i]


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Provides an alternative algorithm for
--   the summation of <i>rational</i> numbers.</li>
--   </ul>
module Factory.Math.Summation

-- | <ul>
--   <li>Sums a list of numbers of arbitrary type.</li>
--   <li>Sparks the summation of <tt>(list-length / chunk-size)</tt> chunks
--   from the list, each of the specified size (thought the last chunk may
--   be smaller), then recursively sums the list of results from each
--   spark.</li>
--   <li>CAVEAT: unless the numbers are large, <a>Rational</a> (requiring
--   <i>cross-multiplication</i>), or the list long, <a>sum</a> is too
--   light-weight for sparking to be productive, therefore it is more
--   likely to be the parallelised deep <i>evaluation</i> of list-elements
--   which saves time.</li>
--   </ul>
sum' :: (Num n, NFData n) => ChunkLength -> [n] -> n

-- | <ul>
--   <li>Sums a list of <i>rational</i> type numbers.</li>
--   <li>CAVEAT: though faster than <a>sum</a>, this algorithm has poor
--   space-complexity, making it unsuitable for unrestricted use.</li>
--   </ul>
sumR' :: Integral i => [Ratio i] -> Ratio i

-- | <ul>
--   <li>Sums a list of <i>rational</i> numbers.</li>
--   <li>Sparks the summation of <tt>(list-length / chunk-length)</tt>
--   chunks from the list, each of the specified size (thought the last
--   chunk may be smaller), then recursively sums the list of results from
--   each spark.</li>
--   <li>CAVEAT: memory-use is proportional to chunk-size.</li>
--   </ul>
sumR :: (Integral i, NFData i) => ChunkLength -> [Ratio i] -> Ratio i


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines a
--   <i>Bailey-Borwein-Plouffe</i> formula;
--   <a>http://mathworld.wolfram.com/PiFormulas.html</a></li>
--   </ul>
module Factory.Math.Implementations.Pi.BBP.Series

-- | Defines a series corresponding to a specific <i>BBP</i>-formula.
data Series
MkSeries :: [Integer] -> (Int -> [Integer]) -> Rational -> Integer -> Series

-- | The constant numerators from which each term in the series is
--   composed.
numerators :: Series -> [Integer]

-- | Generates the term-dependent denominators from which each term in the
--   series is composed.
getDenominators :: Series -> Int -> [Integer]

-- | The ratio by which the sum to infinity of the series, must be scaled
--   to result in <i>Pi</i>.
seriesScalingFactor :: Series -> Rational

-- | The geometric ratio, by which successive terms are scaled.
base :: Series -> Integer


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines <i>Bellard</i>'s
--   nega-base-<tt>2^10</tt> <i>BBP</i>-formula;
--   <a>http://en.wikipedia.org/wiki/Bellard%27s_formula</a></li>
--   </ul>
module Factory.Math.Implementations.Pi.BBP.Bellard

-- | Defines the parameters of this specific series.
series :: Series


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines a specific base-<tt>2^16</tt>
--   <i>BBP</i>-formula;
--   <a>http://mathworld.wolfram.com/PiFormulas.html</a></li>
--   </ul>
module Factory.Math.Implementations.Pi.BBP.Base65536

-- | Defines the parameters of this specific series.
series :: Series


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Exports functions involving integral
--   powers.</li>
--   </ul>
module Factory.Math.Power

-- | Mainly for convenience.
square :: Num n => n -> n

-- | <ul>
--   <li>Iteratively generate sequential <i>squares</i>, from the specified
--   initial value, based on the fact that <tt>(x + 1)^2 = x^2 + 2 * x +
--   1</tt>.</li>
--   <li>The initial value doesn't need to be either positive or
--   integral.</li>
--   </ul>
squaresFrom :: (Enum n, Num n) => n -> [(n, n)]

-- | Just for convenience.
cube :: Num n => n -> n

-- | Just for convenience.
cubeRoot :: Double -> Double

-- | <ul>
--   <li>Raise an arbitrary number to the specified positive integral
--   power, using <i>modular</i> arithmetic.</li>
--   <li>Implements exponentiation as a sequence of either <i>squares</i>
--   or multiplications by the base;
--   <a>http://en.wikipedia.org/wiki/Exponentiation_by_squaring</a>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Modular_exponentiation</a>.</li>
--   </ul>
raiseModulo :: (Integral i, Integral power, Show power) => i -> power -> i -> i


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Exports functions related to
--   <i>perfect powers</i>.</li>
--   </ul>
module Factory.Math.PerfectPower

-- | <ul>
--   <li>Returns <tt>(Just . sqrt)</tt> if the specified integer is a
--   <i>square number</i> (AKA <i>perfect square</i>).</li>
--   <li><a>http://en.wikipedia.org/wiki/Square_number</a>.</li>
--   <li><a>http://mathworld.wolfram.com/SquareNumber.html</a>.</li>
--   <li><tt>(Math.Power.square . sqrt)</tt> is expensive, so the modulus
--   of the operand is tested first, in an attempt to prove it isn't a
--   <i>perfect square</i>. The set of tests, and the valid moduli within
--   each test, are ordered to maximize the rate of failure-detection.</li>
--   </ul>
maybeSquareNumber :: Integral i => i -> Maybe i

-- | <ul>
--   <li>An integer <tt>(&gt; 1)</tt> which can be expressed as an integral
--   power <tt>(&gt; 1)</tt> of a smaller <i>natural</i> number.</li>
--   <li>CAVEAT: <i>zero</i> and <i>one</i> are normally excluded from this
--   set.</li>
--   <li><a>http://en.wikipedia.org/wiki/Perfect_power</a>.</li>
--   <li><a>http://mathworld.wolfram.com/PerfectPower.html</a>.</li>
--   <li>A generalisation of the concept of <i>perfect squares</i>, in
--   which only the exponent '2' is significant.</li>
--   </ul>
isPerfectPower :: Integral i => i -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Exports a common interface for primality-implementations.</li>
--   <li>Provides utilities for these implementations.</li>
--   </ul>
module Factory.Math.Primality

-- | Defines the methods expected of a primality-testing algorithm.
class Algorithmic algorithm
isPrime :: (Algorithmic algorithm, NFData i, Integral i, Show i) => algorithm -> i -> Bool

-- | An ordered list of the <i>Carmichael</i> numbers;
--   <a>http://en.wikipedia.org/wiki/Carmichael_number</a>.
carmichaelNumbers :: (Algorithmic algorithm, NFData i, Integral i, Show i) => algorithm -> [i]

-- | <a>True</a> if the two specified integers are <i>relatively prime</i>,
--   i.e. if they share no common positive factors except one.
--   
--   <ul>
--   <li><tt>1</tt> and <tt>-1</tt> are the only numbers which are
--   <i>coprime</i> to themself.</li>
--   <li><a>http://en.wikipedia.org/wiki/Coprime</a>.</li>
--   <li><a>http://mathworld.wolfram.com/RelativelyPrime.html</a>.</li>
--   </ul>
areCoprime :: Integral i => i -> i -> Bool

-- | <ul>
--   <li>Tests <i>Fermat's Little Theorem</i> for all applicable values, as
--   a probabilistic primality-test.</li>
--   
--   <li><a>http://en.wikipedia.org/wiki/Fermat%27s_little_theorem</a>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Fermat_primality_test</a>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Fermat_pseudoprime</a>.</li>
--   <li>CAVEAT: this primality-test fails for the <i>Carmichael
--   numbers</i>.</li>
--   <li>TODO: confirm that all values must be tested.</li>
--   </ul>
isFermatWitness :: (Integral i, Show i) => i -> Bool

-- | <ul>
--   <li>A <i>Carmichael number</i> is an <i>odd</i> <i>composite</i>
--   number which satisfies <i>Fermat's little theorem</i>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Carmichael_number</a>.</li>
--   <li><a>http://mathworld.wolfram.com/CarmichaelNumber.html</a>.</li>
--   </ul>
isCarmichaelNumber :: (Algorithmic algorithm, NFData i, Integral i, Show i) => algorithm -> i -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Generates the constant, conceptally
--   infinite, list of <i>prime-numbers</i>, using <i>Turner's Sieve</i>;
--   <a>http://www.haskell.org/haskellwiki/Prime_numbers#Turner.27s_sieve_-_Trial_division</a>.</li>
--   </ul>
module Factory.Math.Implementations.Primes.TurnersSieve

-- | <ul>
--   <li>For each <i>prime</i>, the infinite list of candidates greater
--   than its <i>square</i>, is filtered for indivisibility;
--   <a>http://www.haskell.org/haskellwiki/Prime_numbers#Turner.27s_sieve_-_Trial_division</a>.</li>
--   <li>CAVEAT: though one can easily add a <a>PrimeWheel</a>, it proved
--   counterproductive.</li>
--   </ul>
turnersSieve :: Integral prime => [prime]


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Provides various
--   <i>hyperoperations</i>;
--   <a>http://en.wikipedia.org/wiki/Hyperoperation</a>.</li>
--   </ul>
module Factory.Math.Hyperoperation

-- | <ul>
--   <li>Merely to enhance self-documentation.</li>
--   <li>CAVEAT: whilst it may appear that <a>Base</a> could be
--   non-<a>Integral</a>, the recursive definition for
--   <i>hyper-exponents</i> above <a>tetration</a>, prevents this.</li>
--   </ul>
type Base = Integer

-- | <ul>
--   <li>Merely to enhance self-documentation.</li>
--   <li>CAVEAT: whilst <a>Base</a> and <a>HyperExponent</a> can be
--   independent types for both <a>exponentiation</a> and <a>tetration</a>,
--   they interact for other <i>hyper-exponents</i>.</li>
--   </ul>
type HyperExponent = Base
succession :: Int
addition :: Int
multiplication :: Int
exponentiation :: Int
tetration :: Int
pentation :: Int
hexation :: Int

-- | The <i>hyperoperation</i>-sequence;
--   <a>http://en.wikipedia.org/wiki/Hyperoperation</a>.
hyperoperation :: (Integral rank, Show rank) => rank -> Base -> HyperExponent -> Base

-- | The <i>Ackermann-Peter</i>-function;
--   <a>http://en.wikipedia.org/wiki/Ackermann_function#Ackermann_numbers</a>.
ackermannPeter :: (Integral rank, Show rank) => rank -> HyperExponent -> Base

-- | <ul>
--   <li>Returns the <i>power-tower</i> of the specified <i>base</i>;
--   <a>http://mathworld.wolfram.com/PowerTower.html</a>.</li>
--   <li>A synonym for <i>tetration</i>;
--   <a>http://en.wikipedia.org/wiki/Tetration</a>,
--   <a>http://www.tetration.org/Fractals/Atlas/index.html</a>.</li>
--   </ul>
powerTower :: (Integral base, Integral hyperExponent, Show base) => base -> hyperExponent -> base

-- | True if <tt>hyperoperation base hyperExponent</tt> has the same value
--   for each specified <tt>rank</tt>.
areCoincidental :: (Integral rank, Show rank) => Base -> HyperExponent -> [rank] -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i>
--   <a>http://en.wikipedia.org/wiki/Fibonacci_number</a>.</li>
--   </ul>
module Factory.Math.Fibonacci

-- | A constant ordered list of the <i>Fibonacci</i>-numbers.
fibonacci :: Integral i => [i]

-- | <ul>
--   <li>The subset of <a>fibonacci</a>, <i>indexed</i> by a
--   <i>prime</i>-number.</li>
--   
--   <li><a>http://primes.utm.edu/glossary/page.php?sort=FibonacciPrime</a>.</li>
--   </ul>
primeIndexedFibonacci :: Integral i => [i]


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Whilst this particular function is the subject of many
--   introductory examples to Haskell, the simple algorithms appropriate
--   for that forum, leave a large margin for performance-improvement. This
--   module provides the interface for alternative algorithms.</li>
--   <li><a>http://mathworld.wolfram.com/Factorial.html</a>.</li>
--   </ul>
module Factory.Math.Factorial

-- | Defines the methods expected of a <i>factorial</i>-algorithm.
class Algorithmic algorithm
factorial :: (Algorithmic algorithm, Integral i, Show i) => algorithm -> i -> i


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the unit with which precision
--   is measured, and operations on it.</li>
--   </ul>
module Factory.Math.Precision

-- | The <i>order of convergence</i>;
--   <a>http://en.wikipedia.org/wiki/Rate_of_convergence</a>.
type ConvergenceOrder = Int

-- | The <i>rate of convergence</i>;
--   <a>http://en.wikipedia.org/wiki/Rate_of_convergence</a>.
type ConvergenceRate = Double

-- | A number of decimal digits; presumably positive.
type DecimalDigits = Int

-- | <i>Linear</i> convergence-rate; which may be qualified by the <i>rate
--   of convergence</i>.
linearConvergence :: ConvergenceOrder

-- | <i>Quadratic</i> convergence-rate.
quadraticConvergence :: ConvergenceOrder

-- | <i>Cubic</i> convergence-rate.
cubicConvergence :: ConvergenceOrder

-- | <i>Quartic</i> convergence-rate.
quarticConvergence :: ConvergenceOrder

-- | The predicted number of iterations, required to achieve a specific
--   accuracy, at a given <i>order of convergence</i>.
getIterationsRequired :: Integral i => ConvergenceOrder -> DecimalDigits -> DecimalDigits -> i

-- | <ul>
--   <li>The predicted number of terms which must be extracted from a
--   series, if it is to converge to the required accuracy, at the
--   specified linear <i>convergence-rate</i>.</li>
--   <li>The <i>convergence-rate</i> of a series, is the error in the
--   series after summation of <tt>(n+1)th</tt> terms, divided by the error
--   after only <tt>n</tt> terms, as the latter tends to infinity. As such,
--   for a <i>convergent</i> series (in which the error get smaller with
--   successive terms), it's value lies in the range <tt>0 .. 1</tt>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Rate_of_convergence</a>.</li>
--   </ul>
getTermsRequired :: Integral i => ConvergenceRate -> DecimalDigits -> i

-- | Rounds the specified number, to a positive number of
--   <a>DecimalDigits</a>.
roundTo :: (RealFrac a, Fractional f) => DecimalDigits -> a -> f

-- | Promotes the specified number, by a positive number of
--   <a>DecimalDigits</a>.
promote :: Num n => n -> DecimalDigits -> n

-- | <ul>
--   <li>Reduces a <a>Rational</a> to the minimal form required for the
--   specified number of <i>fractional</i> decimal places; irrespective of
--   the number of integral decimal places.</li>
--   <li>A <a>Rational</a> approximation to an irrational number, may be
--   very long, and provide an unknown excess precision. Whilst this
--   doesn't sound harmful, it costs in performance and memory-requirement,
--   and being unpredictable isn't actually useful.</li>
--   </ul>
simplify :: RealFrac operand => DecimalDigits -> operand -> Rational


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Exports a common interface for <i>square-root</i>
--   implementations.</li>
--   <li>Provides utilities for these implementations.</li>
--   </ul>
module Factory.Math.SquareRoot

-- | Defines the methods expected of a <i>square-root</i> algorithm.
class Algorithmic algorithm where squareRoot algorithm decimalDigits operand = squareRootFrom algorithm (getEstimate operand) decimalDigits operand
squareRootFrom :: (Algorithmic algorithm, Real operand, Show operand) => algorithm -> Estimate -> DecimalDigits -> operand -> Result
squareRoot :: (Algorithmic algorithm, Real operand, Show operand) => algorithm -> DecimalDigits -> operand -> Result

-- | The interface required to iterate, from an estimate of the required
--   value, to the next approximation.
class Iterator algorithm
step :: (Iterator algorithm, Real operand) => algorithm -> operand -> Result -> Result
convergenceOrder :: Iterator algorithm => algorithm -> ConvergenceOrder

-- | The result-type; actually, only the concrete return-type of
--   <a>simplify</a>, stops it being a polymorphic instance of
--   <a>Fractional</a>.
type Result = Rational

-- | Contains an estimate for the <i>square-root</i> of a value, and its
--   accuracy.
type Estimate = (Result, DecimalDigits)

-- | <ul>
--   <li>For a given value and an estimate of its <i>square-root</i>,
--   returns the number of decimals digits to which the <i>square-root</i>
--   is accurate; including the integral digits.</li>
--   <li>CAVEAT: the result returned for an exact match has been
--   bodged.</li>
--   </ul>
getAccuracy :: Real operand => operand -> Result -> DecimalDigits

-- | <ul>
--   <li>The signed difference between the <i>square</i> of an estimate for
--   the <i>square-root</i> of a value, and that value.</li>
--   <li>Positive when the estimate is too low.</li>
--   <li>CAVEAT: the magnitude is twice the error in the
--   <i>square-root</i>.</li>
--   </ul>
getDiscrepancy :: Real operand => operand -> Result -> Result

-- | Uses <a>Double</a>-precision floating-point arithmetic, to obtain an
--   initial estimate for the <i>square-root</i>, and its accuracy.
getEstimate :: (Real operand, Show operand) => operand -> Estimate

-- | True if the specified estimate for the <i>square-root</i>, is precise.
isPrecise :: Real operand => operand -> Result -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the classes of
--   <i>Pi</i>-algorithm which have been implemented.</li>
--   </ul>
module Factory.Math.Pi

-- | <ul>
--   <li>Defines the methods expected of a <i>Pi</i>-algorithm.</li>
--   <li>Most of the implementations naturally return a <a>Rational</a>,
--   but the spigot-algorithms naturally produce a <tt>[Int]</tt>; though
--   representing <i>Pi</i> as a big integer with the decimal point removed
--   is clearly incorrect.</li>
--   <li>Since representing <i>Pi</i> as either a <a>Rational</a> or
--   promoted to an <a>Integer</a>, is inconvenient, an alternative decimal
--   <a>String</a>-representation is provided.</li>
--   </ul>
class Algorithmic algorithm where openI _ 1 = 3 openI algorithm decimalDigits | decimalDigits <= 0 = error $ "Factory.Math.Pi.openI:\tinsufficient decimalDigits=" ++ show decimalDigits | otherwise = round . promote (openR algorithm decimalDigits) $ pred decimalDigits openS _ 1 = "3" openS algorithm decimalDigits | decimalDigits <= 0 = "" | decimalDigits <= 16 = take (succ decimalDigits) $ show (pi :: Double) | otherwise = "3." ++ tail (show $ openI algorithm decimalDigits)
openR :: Algorithmic algorithm => algorithm -> DecimalDigits -> Rational
openI :: Algorithmic algorithm => algorithm -> DecimalDigits -> Integer
openS :: Algorithmic algorithm => algorithm -> DecimalDigits -> String

-- | Categorises the various algorithms.
data Category agm bbp borwein ramanujan spigot

-- | Algorithms based on the <i>Arithmetic-geometric Mean</i>.
AGM :: agm -> Category agm bbp borwein ramanujan spigot

-- | 
--   <a>http://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula</a>.
BBP :: bbp -> Category agm bbp borwein ramanujan spigot

-- | <a>http://en.wikipedia.org/wiki/Borwein%27s_algorithm</a>.
Borwein :: borwein -> Category agm bbp borwein ramanujan spigot

-- | <a>http://www.pi314.net/eng/ramanujan.php</a>.
Ramanujan :: ramanujan -> Category agm bbp borwein ramanujan spigot

-- | Algorithms from which the digits of <i>Pi</i> slowly drip, one by one.
Spigot :: spigot -> Category agm bbp borwein ramanujan spigot
instance (Eq agm, Eq bbp, Eq borwein, Eq ramanujan, Eq spigot) => Eq (Category agm bbp borwein ramanujan spigot)
instance (Read agm, Read bbp, Read borwein, Read ramanujan, Read spigot) => Read (Category agm bbp borwein ramanujan spigot)
instance (Show agm, Show bbp, Show borwein, Show ramanujan, Show spigot) => Show (Category agm bbp borwein ramanujan spigot)
instance (Algorithmic agm, Algorithmic bbp, Algorithmic borwein, Algorithmic ramanujan, Algorithmic spigot) => Algorithmic (Category agm bbp borwein ramanujan spigot)
instance (Defaultable agm, Defaultable bbp, Defaultable borwein, Defaultable ramanujan, Defaultable spigot) => Defaultable (Category agm bbp borwein ramanujan spigot)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Implements a <i>Bailey-Borwein-Plouffe</i> formula;
--   <a>http://mathworld.wolfram.com/PiFormulas.html</a></li>
--   <li>Surprisingly, because of the huge size of the <a>Rational</a>
--   quantities, it is a <i>single</i> call to
--   <tt>Factory.Math.Summation.sum'</tt>, rather than the calculation of
--   the many terms in the series, which is the
--   performance-bottleneck.</li>
--   </ul>
module Factory.Math.Implementations.Pi.BBP.Implementation

-- | Returns <i>Pi</i>, accurate to the specified number of decimal digits.
openR :: Series -> DecimalDigits -> Rational


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the set of
--   <i>Bailey-Borwein-Plouffe</i>-type formulae which have been
--   implemented.</li>
--   </ul>
module Factory.Math.Implementations.Pi.BBP.Algorithm

-- | Defines those <i>BBP</i>-type series which have been implemented.
data Algorithm

-- | A <i>base</i>-<tt>2^16</tt> version of the formula.
Base65536 :: Algorithm

-- | A <i>nega-base</i> <tt>2^10</tt> version of the formula.
Bellard :: Algorithm
instance Eq Algorithm
instance Read Algorithm
instance Show Algorithm
instance Algorithmic Algorithm
instance Defaultable Algorithm


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines a
--   <a>http://en.wikipedia.org/wiki/Srinivasa_Borwein</a>-type series for
--   <i>Pi</i>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Borwein.Series

-- | Defines a series corresponding to a specific <i>Borwein</i>-formula.
data Series squareRootAlgorithm factorialAlgorithm
MkSeries :: (squareRootAlgorithm -> factorialAlgorithm -> DecimalDigits -> (Rational, [Rational])) -> ConvergenceRate -> Series squareRootAlgorithm factorialAlgorithm
terms :: Series squareRootAlgorithm factorialAlgorithm -> squareRootAlgorithm -> factorialAlgorithm -> DecimalDigits -> (Rational, [Rational])

-- | The expected number of digits of <i>Pi</i>, per term in the series.
convergenceRate :: Series squareRootAlgorithm factorialAlgorithm -> ConvergenceRate


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines <i>Borwein</i> series for
--   <i>Pi</i>;
--   <a>http://en.wikipedia.org/wiki/Borwein%27s_algorithm</a></li>
--   </ul>
module Factory.Math.Implementations.Pi.Borwein.Implementation

-- | Returns <i>Pi</i>, accurate to the specified number of decimal digits.
openR :: Series squareRootAlgorithm factorialAlgorithm -> squareRootAlgorithm -> factorialAlgorithm -> DecimalDigits -> Rational


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines a
--   <a>http://en.wikipedia.org/wiki/Srinivasa_Ramanujan</a>-type series
--   for <i>Pi</i>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Ramanujan.Series

-- | Defines a series corresponding to a specific <i>Ramanujan</i>-formula.
data Series squareRootAlgorithm factorialAlgorithm
MkSeries :: (factorialAlgorithm -> [Rational]) -> (squareRootAlgorithm -> DecimalDigits -> Rational) -> ConvergenceRate -> Series squareRootAlgorithm factorialAlgorithm

-- | The sequence of terms, the sum to infinity of which defines the
--   series.
terms :: Series squareRootAlgorithm factorialAlgorithm -> factorialAlgorithm -> [Rational]

-- | The ratio by which the sum to infinity of the sequence, must be scaled
--   to result in <i>Pi</i>.
getSeriesScalingFactor :: Series squareRootAlgorithm factorialAlgorithm -> squareRootAlgorithm -> DecimalDigits -> Rational

-- | The expected number of digits of <i>Pi</i>, per term in the series.
convergenceRate :: Series squareRootAlgorithm factorialAlgorithm -> ConvergenceRate


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Implements a <i>Ramanujan</i>-type
--   series for <i>Pi</i>;
--   <a>http://en.wikipedia.org/wiki/Srinivasa_Ramanujan</a>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Ramanujan.Implementation

-- | Returns <i>Pi</i>, accurate to the specified number of decimal digits.
openR :: Series squareRootAlgorithm factorialAlgorithm -> squareRootAlgorithm -> factorialAlgorithm -> DecimalDigits -> Rational


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the parameters of a series
--   used in a <i>Spigot</i>-table to generate <i>Pi</i>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Spigot.Series

-- | <ul>
--   <li>Defines a series composed from a sum of terms, each one of which
--   is the product of a coefficient and a base.</li>
--   <li>The coefficents and bases of the series are described in <i>Horner
--   form</i>; <tt>Pi = c1 + (b1 * (c2 + b2 * (c3 + b3 *
--   (...))))</tt>.</li>
--   </ul>
data Series i
MkSeries :: [i] -> [i] -> [i] -> (DecimalDigits -> Int) -> Series i
coefficients :: Series i -> [i]
baseNumerators :: Series i -> [i]
baseDenominators :: Series i -> [i]

-- | The width of the spigot-table, required to accurately generate the
--   requested number of digits.
nTerms :: Series i -> DecimalDigits -> Int

-- | Combines <a>baseNumerators</a> and <a>baseDenominators</a>, and as a
--   side-effect, expresses the ratio in lowest terms.
bases :: Integral i => Series i -> [Ratio i]


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the <i>Gosper</i> series;
--   <a>http://www.pi314.net/eng/goutte.php</a></li>
--   </ul>
module Factory.Math.Implementations.Pi.Spigot.Gosper

-- | Defines a series which converges to <i>Pi</i>.
series :: Integral i => Series i


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the <i>Rabinowitz-Wagon</i>
--   series;
--   <a>http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf</a>
--   <a>http://www.mathpropress.com/stan/bibliography/spigot.pdf</a>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Spigot.RabinowitzWagon

-- | Defines a series which converges to <i>Pi</i>.
series :: Integral i => Series i


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Implements a <i>spigot</i>-algorithm;
--   <a>http://en.wikipedia.org/wiki/Spigot_algorithm</a>.</li>
--   <li>Uses the traditional algorithm, rather than the <i>unbounded</i>
--   algorithm described by
--   <a>http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/spigot.pdf</a>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Spigot.Spigot

-- | The constant base in which we want the resulting value of <i>Pi</i> to
--   be expressed.
decimal :: I

-- | <ul>
--   <li>Initialises a <i>spigot</i>-table with the row of
--   <a>coefficients</a>.</li>
--   <li>Ensures that the row has suffient terms to accurately generate the
--   required number of digits.</li>
--   <li>Extracts only those digits which are guaranteed to be
--   accurate.</li>
--   <li>CAVEAT: the result is returned as an <a>Integer</a>, i.e. without
--   any decimal point.</li>
--   </ul>
openI :: Series I -> DecimalDigits -> Integer


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the set of
--   <i>Spigot</i>-algorithms which have been implemented.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Spigot.Algorithm

-- | Define those <i>Spigot</i>-algorithms which have been implemented.
data Algorithm

-- | A <i>continued fraction</i> discovered by <i>Gosper</i>.
Gosper :: Algorithm

-- | A <i>continued fraction</i> discovered by <i>Rabinowitz</i> and
--   <i>Wagon</i>.
RabinowitzWagon :: Algorithm
instance Eq Algorithm
instance Read Algorithm
instance Show Algorithm
instance Algorithmic Algorithm
instance Defaultable Algorithm


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Determines the <i>Arithmetic-geometric
--   mean</i>;
--   <a>http://en.wikipedia.org/wiki/Arithmetic-geometric_mean</a>.</li>
--   </ul>
module Factory.Math.ArithmeticGeometricMean

-- | The type of the <i>arithmetic mean</i>;
--   <a>http://en.wikipedia.org/wiki/Arithmetic_mean</a>.
type ArithmeticMean = Rational

-- | The type of the <i>geometric mean</i>;
--   <a>http://en.wikipedia.org/wiki/Geometric_mean</a>.
type GeometricMean = Rational

-- | Encapsulates both <i>arithmetic</i> and <i>geometric</i> means.
type AGM = (ArithmeticMean, GeometricMean)

-- | Returns an infinite list which converges on the
--   <i>Arithmetic-geometric mean</i>.
convergeToAGM :: Algorithmic squareRootAlgorithm => squareRootAlgorithm -> DecimalDigits -> AGM -> [AGM]

-- | Returns the bounds within which the <a>AGM</a> has been constrained.
spread :: AGM -> Rational

-- | Accessor.
getArithmeticMean :: AGM -> ArithmeticMean

-- | Accessor.
getGeometricMean :: AGM -> GeometricMean

-- | Checks that both <i>means</i> are positive, as required for the
--   <i>geometric mean</i> to be consistently <i>real</i>.
isValid :: AGM -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Implements the <i>Brent-Salamin</i> (AKA <i>Gauss-Legendre</i>)
--   algorithm;
--   <a>http://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_algorithm</a>,
--   <a>http://mathworld.wolfram.com/Brent-SalaminFormula.html</a>,
--   <a>http://www.pi314.net/eng/salamin.php</a>.</li>
--   <li>The precision of the result approximately doubles for each
--   iteration.</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>CAVEAT</tt></i> Assumptions on the convergence-rate result
--   in rounding-errors, when only a small number of digits are
--   requested.</li>
--   </ul>
module Factory.Math.Implementations.Pi.AGM.BrentSalamin

-- | <ul>
--   <li>Returns <i>Pi</i>, accurate to the specified number of decimal
--   digits.</li>
--   <li>This algorithm is based on the <i>arithmetic-geometric</i> mean of
--   <tt>1</tt> and <tt>(1 / sqrt 2)</tt>, but there are many confusingly
--   similar formulations. The algorithm I've used here, where <tt>a</tt>
--   is the <i>arithmetic mean</i> and <tt>g</tt> is the <i>geometric
--   mean</i>, is equivalent to other common formulations:</li>
--   </ul>
--   
--   <pre>
--   pi = (a[N-1] + g[N-1])^2 / (1 - sum [2^n * (a[n] - g[n])^2])			where n = [0 .. N-1]
--   =&gt; 4*a[N]^2 / (1 - sum [2^n * (a[n]^2 - 2*a[n]*g[n] + g[n]^2)])
--   =&gt; 4*a[N]^2 / (1 - sum [2^n * (a[n]^2 + 2*a[n]*g[n] + g[n]^2 - 4*a[n]*g[n])])
--   =&gt; 4*a[N]^2 / (1 - sum [2^n * ((a[n] + g[n])^2 - 4*a[n]*g[n])])
--   =&gt; 4*a[N]^2 / (1 - sum [2^(n-1) * 4 * (a[n-1]^2 - g[n-1]^2)])			where n = [1 .. N]
--   =&gt; 4*a[N]^2 / (1 - sum [2^(n+1) * (a[n-1]^2 - g[n-1]^2)])
--   </pre>
openR :: Algorithmic squareRootAlgorithm => squareRootAlgorithm -> DecimalDigits -> Rational


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the set of
--   <i>Arithmetic-geometric Mean</i>-type <i>Pi</i>-algorithms which have
--   been implemented; currently just one.</li>
--   </ul>
module Factory.Math.Implementations.Pi.AGM.Algorithm

-- | Defines the available algorithms.
data Algorithm squareRootAlgorithm
BrentSalamin :: squareRootAlgorithm -> Algorithm squareRootAlgorithm
instance Eq squareRootAlgorithm => Eq (Algorithm squareRootAlgorithm)
instance Read squareRootAlgorithm => Read (Algorithm squareRootAlgorithm)
instance Show squareRootAlgorithm => Show (Algorithm squareRootAlgorithm)
instance Algorithmic squareRootAlgorithm => Algorithmic (Algorithm squareRootAlgorithm)
instance Defaultable squareRootAlgorithm => Defaultable (Algorithm squareRootAlgorithm)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines a <i>prime-wheel</i>, for use
--   in prime-number generation;
--   <a>http://en.wikipedia.org/wiki/Wheel_factorization</a>.</li>
--   </ul>
module Factory.Data.PrimeWheel

-- | Couples a candidate prime with a <i>rolling wheel</i>, to define the
--   distance rolled.
type Distance i = (i, [i])

-- | The size of the <i>wheel</i>, measured by the number of primes from
--   which it is composed.
type NPrimes = Int

-- | An infinite increasing sequence, of the multiples of a specific prime.
type PrimeMultiples i = [i]

-- | <ul>
--   <li>A conceptual <i>wheel</i>, with irregularly spaced spokes;
--   <a>http://www.haskell.org/haskellwiki/Prime_numbers_miscellaneous#Prime_Wheels</a>.</li>
--   <li>On being rolled, the trace of the spokes, identifies candidates
--   which are <i>coprime</i> to those primes from which the <i>wheel</i>
--   was composed.</li>
--   <li>One can alternatively view this as a set of vertical nested rings,
--   each with a <i>prime circumference</i>, and touching at its lowest
--   point. Each has a single mark on its <i>circumference</i>, which when
--   rolled identifies multiples of that <i>circumference</i>. When the
--   complete set is rolled, from the state where all marks are coincident,
--   all multiples of the set of primes, are traced.</li>
--   <li>CAVEAT: The distance required to return to this state (the wheel's
--   <i>circumference</i>), grows rapidly with the number of primes:</li>
--   </ul>
--   
--   <pre>
--   zip [0 ..] . scanl (*) 1 $ [2,3,5,7,11,13,17,19,23,29,31]
--   [(0,1),(1,2),(2,6),(3,30),(4,210),(5,2310),(6,30030),(7,510510),(8,9699690),(9,223092870),(10,6469693230),(11,200560490130)]
--   </pre>
--   
--   <ul>
--   <li>The number of spokes also grows rapidly with the number of
--   primes:</li>
--   </ul>
--   
--   <pre>
--   zip [0 ..] . scanl (*) 1 . map pred $ [2,3,5,7,11,13,17,19,23,29,31]
--   [(0,1),(1,1),(2,2),(3,8),(4,48),(5,480),(6,5760),(7,92160),(8,1658880),(9,36495360),(10,1021870080),(11,30656102400)]
--   </pre>
data PrimeWheel i

-- | <ul>
--   <li>The optimal number of low primes from which to build the
--   <i>wheel</i>, grows with the number of primes required; the
--   <i>circumference</i> should be approximately the <i>square-root</i> of
--   the number of integers it will be required to sieve.</li>
--   <li>CAVEAT: one greater than this is returned, which empirically seems
--   better.</li>
--   </ul>
estimateOptimalSize :: Integral i => i -> NPrimes

-- | <ul>
--   <li>Generates multiples of the specified prime, starting from its
--   <i>square</i>, skipping those multiples of the low primes from which
--   the specified <a>PrimeWheel</a> was composed, and which therefore, the
--   <i>wheel</i> won't generate as candidates. Eg:</li>
--   </ul>
--   
--   <pre>
--   Prime	Rotating PrimeWheel 3	Output
--   =====	=====================	======
--   7	[4,2,4,2,4,6,2,6]	[49,77,91,119,133,161,203,217,259 ..]
--   11	[2,4,2,4,6,2,6,4]	[121,143,187,209,253,319,341,407 ..]
--   13	[4,2,4,6,2,6,4,2]	[169,221,247,299,377,403,481,533,559 ..]
--   </pre>
generateMultiples :: Integral i => i -> [i] -> [i]

-- | Generate an infinite, increasing sequence of candidate primes, from
--   the specified <i>wheel</i>.
roll :: Integral i => PrimeWheel i -> [Distance i]

-- | Generates a new candidate prime, from a <i>rolling wheel</i>, and the
--   current candidate.
rotate :: Integral i => Distance i -> Distance i

-- | Smart constructor for a <i>wheel</i> from the specified number of low
--   primes.
--   
--   <ul>
--   <li>The optimal number of low primes from which to build the
--   <i>wheel</i>, grows with the number of primes required; the
--   <i>circumference</i> should be approximately the <i>square-root</i> of
--   the number of integers it will be required to sieve.</li>
--   <li>The sequence of gaps between spokes on the <i>wheel</i> is
--   <i>symmetrical under reflection</i>; though two values lie <i>on</i>
--   the axis, that aren't part of this symmetry. Eg:</li>
--   </ul>
--   
--   <pre>
--   nPrimes	Gaps
--   ======	====
--   0	[1]
--   1	[2]	-- The terminal gap for all subsequent wheels is '2'; [(succ circumference `mod` circumference) - (pred circumference `mod` circumference)].
--   2	[4,2]	-- Both points are on the axis, so the symmetry isn't yet clear.
--   3	[6,4,2,4,2,4,6,2]
--   4	[10,2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2]
--   </pre>
--   
--   Exploitation of this property has proved counter-productive, probably
--   because it requires <i>strict evaluation</i>, exposing the user to the
--   full cost of inadvertently choosing a <i>wheel</i>, which in practice,
--   is rotated less than once.
mkPrimeWheel :: Integral i => NPrimes -> PrimeWheel i

-- | The <i>circumference</i> of the specified <a>PrimeWheel</a>.
getCircumference :: Integral i => PrimeWheel i -> i

-- | The number of spokes in the specified <a>PrimeWheel</a>.
getSpokeCount :: Integral i => PrimeWheel i -> i
instance Show i => Show (PrimeWheel i)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Generates the constant <i>bounded</i> list of
--   <i>prime-numbers</i>, using the <i>Sieve of Atkin</i>;
--   <a>http://en.wikipedia.org/wiki/Sieve_of_Atkin</a>.</li>
--   <li><a>cr.yp.to/papers/primesieves-19990826.pdf</a>.</li>
--   <li>The implementation; has been optimised using a <i>wheel</i> of
--   static, but parameterised, size; has been parallelized; is
--   polymorphic, but with a specialisation for type <a>Int</a>.</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>CAVEAT</tt></i> The <a>Int</a>-specialisation is
--   implemented by a <i>rewrite-rule</i>, which is <i>very</i>
--   fragile.</li>
--   </ul>
module Factory.Math.Implementations.Primes.SieveOfAtkin

-- | <ul>
--   <li>Generates the constant <i>bounded</i> list of
--   <i>prime-numbers</i>.</li>
--   <li><a>http://cr.yp.to/papers/primesieves-19990826.pdf</a></li>
--   </ul>
sieveOfAtkin :: (NFData i, Ix i, Integral i) => NPrimes -> i -> [i]
instance Eq PolynomialType


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Generates the constant, conceptually infinite, list of
--   <i>prime-numbers</i>, using the <i>Sieve of Eratosthenes</i>;
--   <a>http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a>.</li>
--   <li>Based on
--   <a>http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf</a>.</li>
--   <li>The implementation; has been optimised using a <i>wheel</i> of
--   static, but parameterised, size; is polymorphic, but with a
--   specialisation for type <a>Int</a>.</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>CAVEAT</tt></i> The <a>Int</a>-specialisation is
--   implemented by a <i>rewrite-rule</i>, which is <i>very</i>
--   fragile.</li>
--   </ul>
module Factory.Math.Implementations.Primes.SieveOfEratosthenes

-- | <ul>
--   <li>A refinement of the <i>Sieve Of Eratosthenes</i>, which pre-sieves
--   candidates, selecting only those <i>coprime</i> to the specified short
--   sequence of low prime-numbers.</li>
--   <li>The short sequence of initial primes are represented by a
--   <a>PrimeWheel</a>, of parameterised, but static, size;
--   <a>http://en.wikipedia.org/wiki/Wheel_factorization</a>.</li>
--   <li>The algorithm requires one to record multiples of previously
--   discovered primes, allowing <i>composite</i> candidates to be
--   eliminated by comparison.</li>
--   <li>Because each <i>list</i> of multiples, starts with the
--   <i>square</i> of the prime from which it was generated, the vast
--   majority will be larger than the maximum prime ultimately demanded,
--   and the effort of constructing and storing this list, is consequently
--   wasted. Many implementations solve this, by requiring specification of
--   the maximum prime required, thus allowing the construction of
--   redundant lists of multiples to be avoided.</li>
--   <li>This implementation doesn't impose that constraint, leaving a
--   requirement for <i>rapid</i> storage, which is supported by
--   <i>appending</i> the <i>list</i> of prime-multiples, to a
--   <i>queue</i>. If a large enough candidate is ever generated, to match
--   the <i>head</i> of the <i>list</i> of prime-multiples, at the
--   <i>head</i> of this <i>queue</i>, then the whole <i>list</i> of
--   prime-multiples is dropped from the <i>queue</i>, but the <i>tail</i>
--   of this <i>list</i> of prime-multiples, for which there is now a high
--   likelyhood of a subsequent match, must now be re-recorded. A
--   <i>queue</i> doesn't support efficient random <i>insertion</i>, so a
--   <a>Map</a> is used for these subsequent multiples. This solution is
--   faster than just using a <a>Data.PQueue.Min</a>.</li>
--   <li>CAVEAT: has linear <i>O(n)</i> space-complexity.</li>
--   </ul>
sieveOfEratosthenes :: Integral i => NPrimes -> [i]


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Provides a polymorphic algorithm, to <i>unfold</i> a list into a
--   tree, to which an <i>associative binary operator</i> is then applied
--   to re-<i>fold</i> the tree to a <i>scalar</i>.</li>
--   <li>Implementations of this strategy have been provided for
--   <i>addition</i> and <i>multiplication</i>, though other associative
--   binary operators, like <a>gcd</a> or <a>lcm</a> could also be
--   used.</li>
--   <li>Where the contents of the list are consecutive, a more efficient
--   implementation is available in <i>Factory.Data.Interval</i>.</li>
--   </ul>
module Factory.Math.DivideAndConquer

-- | <ul>
--   <li>The ratio of the original list-length at which to bisect.</li>
--   <li>CAVEAT: the value can overflow.</li>
--   </ul>
type BisectionRatio = Ratio Int

-- | The list-length beneath which to terminate bisection.
type MinLength = Int

-- | <ul>
--   <li>Reduces a list to a single scalar encapsulated in a <a>Monoid</a>,
--   using a <i>divide-and-conquer</i> strategy, bisecting the list and
--   recursively evaluating each part;
--   <a>http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm</a>.</li>
--   <li>By choosing a <tt>bisectionRatio</tt> other than <tt>(1 % 2)</tt>,
--   the bisection can be made asymmetrical. The specified ratio represents
--   the length of the left-hand portion, over the original list-length;
--   eg. <tt>(1 % 3)</tt> results in the first part, half the length of the
--   second.</li>
--   <li>This process of recursive bisection, is terminated beneath the
--   specified minimum list-length, after which the <i>monoid</i>'s binary
--   operator is directly <i>folded</i> over the list.</li>
--   <li>One can view this as a
--   <a>http://en.wikipedia.org/wiki/Hylomorphism_%28computer_science%29</a>,
--   in which the list is exploded into a binary tree-structure (each leaf
--   of which contains a list of up to <tt>minLength</tt> integers, and
--   each node of which contains an associative binary operator), and then
--   collapsed to a scalar, by application of the operators.</li>
--   </ul>
divideAndConquer :: Monoid monoid => BisectionRatio -> MinLength -> [monoid] -> monoid

-- | <ul>
--   <li>Multiplies the specified list of numbers.</li>
--   <li>Since the result can be large, <a>divideAndConquer</a> is used in
--   an attempt to form operands of a similar order of magnitude, which
--   creates scope for the use of more efficient
--   multiplication-algorithms.</li>
--   </ul>
product' :: Num n => BisectionRatio -> MinLength -> [n] -> n

-- | <ul>
--   <li>Sums the specified list of numbers.</li>
--   <li>Since the result can be large, <a>divideAndConquer</a> is used in
--   an attempt to form operands of a similar order of magnitude, which
--   creates scope for the use of more efficient multiplication-algorithms.
--   <i>Multiplication</i> is required for the <i>addition</i> of
--   <a>Rational</a> numbers by cross-multiplication; this function is
--   unlikely to be useful for other numbers.</li>
--   </ul>
sum' :: Num n => BisectionRatio -> MinLength -> [n] -> n


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Describes a <i>ring</i> and operations on its members.</li>
--   <li><a>http://en.wikipedia.org/wiki/Ring_%28mathematics%29</a>.</li>
--   <li><a>http://www.numericana.com/answer/rings.htm</a>.</li>
--   </ul>
module Factory.Data.Ring

-- | <ul>
--   <li>Define both the operations applicable to all members of the
--   <i>ring</i>, and its mandatory members.</li>
--   <li>Minimal definition; <a>=+=</a>, <a>=*=</a>,
--   <a>additiveInverse</a>, <a>multiplicativeIdentity</a>,
--   <a>additiveIdentity</a>.</li>
--   </ul>
class Ring r where l =-= r = l =+= additiveInverse r square r = r =*= r
(=+=) :: Ring r => r -> r -> r
(=*=) :: Ring r => r -> r -> r
additiveInverse :: Ring r => r -> r
multiplicativeIdentity :: Ring r => r
additiveIdentity :: Ring r => r
(=-=) :: Ring r => r -> r -> r
square :: Ring r => r -> r

-- | Returns the <i>product</i> of the list of <i>ring</i>-members.
product' :: Ring r => BisectionRatio -> MinLength -> [r] -> r

-- | Returns the <i>sum</i> of the list of <i>ring</i>-members.
sum' :: Ring r => BisectionRatio -> MinLength -> [r] -> r

-- | <ul>
--   <li>Raise a <i>ring</i>-member to the specified positive integral
--   power.</li>
--   <li>Exponentiation is implemented as a sequence of either squares of,
--   or multiplications by, the <i>ring</i>-member;
--   <a>http://en.wikipedia.org/wiki/Exponentiation_by_squaring</a>.</li>
--   </ul>
(=^) :: (Eq r, Integral power, Ring r, Show power) => r -> power -> r
instance Read p => Read (Product p)
instance Show p => Show (Product p)
instance Read s => Read (Sum s)
instance Show s => Show (Sum s)
instance Ring r => Monoid (Sum r)
instance Ring r => Monoid (Product r)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Describes a <i>Quotient Ring</i>;
--   <a>http://en.wikipedia.org/wiki/Quotient_ring</a>.</li>
--   <li>This is a <i>ring</i> composed from a residue-class resulting from
--   <i>modular</i> division.</li>
--   </ul>
module Factory.Data.QuotientRing

-- | Defines a sub-class of <a>Ring</a>, in which division is implemented.
class Ring q => QuotientRing q
quotRem' :: QuotientRing q => q -> q -> (q, q)

-- | Returns the <i>quotient</i>, after division of the two specified
--   <a>QuotientRing</a>s.
quot' :: QuotientRing q => q -> q -> q

-- | Returns the <i>remainder</i>, after division of the two specified
--   <a>QuotientRing</a>s.
rem' :: QuotientRing q => q -> q -> q

-- | <ul>
--   <li><a>True</a> if the two specified <a>QuotientRing</a>s are
--   <i>congruent</i> in <i>modulo</i>-arithmetic, where the <i>modulus</i>
--   is a third <a>QuotientRing</a>.</li>
--   <li><a>http://www.usna.edu/Users/math/wdj/book/node74.html</a>.</li>
--   </ul>
areCongruentModulo :: (Eq q, QuotientRing q) => q -> q -> q -> Bool

-- | True if the second operand <i>divides</i> the first.
isDivisibleBy :: (Eq q, QuotientRing q) => q -> q -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Describes a <a>http://en.wikipedia.org/wiki/Monomial</a> and
--   operations on it.</li>
--   <li>A <i>monomial</i> is merely a <i>polynomial</i> with a single
--   non-zero term; cf. <i>Binomial</i>.</li>
--   </ul>
module Factory.Data.Monomial

-- | <ul>
--   <li>The type of an arbitrary monomial.</li>
--   <li>CAVEAT: though a <i>monomial</i> has an integral power, this
--   contraint is only imposed at the function-level.</li>
--   </ul>
type Monomial coefficient exponent = (coefficient, exponent)

-- | Double the specified <a>Monomial</a>.
double :: Num c => Monomial c e -> Monomial c e

-- | Reduce the coefficient using <i>modular</i> arithmetic.
mod' :: Integral c => Monomial c e -> c -> Monomial c e

-- | Negate the coefficient.
negateCoefficient :: Num c => Monomial c e -> Monomial c e

-- | Convert the type of the <i>coefficient</i>.
realCoefficientToFrac :: (Real r, Fractional f) => Monomial r e -> Monomial f e

-- | Shift the <i>coefficient</i>, by the specified amount.
shiftCoefficient :: Num c => Monomial c e -> c -> Monomial c e

-- | Shift the <i>exponent</i>, by the specified amount.
shiftExponent :: Num e => Monomial c e -> e -> Monomial c e

-- | Square the specified <a>Monomial</a>.
square :: (Num c, Num e) => Monomial c e -> Monomial c e

-- | Accessor.
getExponent :: Monomial c e -> e

-- | Accessor.
getCoefficient :: Monomial c e -> c

-- | Compares the <i>exponents</i> of the specified <a>Monomial</a>s.
(<=>) :: Ord e => Monomial c e -> Monomial c e -> Ordering

-- | Divide the two specified <a>Monomial</a>s.
(</>) :: (Eq c, Fractional c, Num e) => Monomial c e -> Monomial c e -> Monomial c e

-- | Multiply the two specified <a>Monomial</a>s.
(<*>) :: (Num c, Num e) => Monomial c e -> Monomial c e -> Monomial c e

-- | True if the <i>exponents</i> are equal.
(=~) :: Eq e => Monomial c e -> Monomial c e -> Bool

-- | <ul>
--   <li><a>True</a> if the <i>exponent</i> is both integral and
--   non-<i>negative</i>.</li>
--   <li>CAVEAT: one can't even call this function unless the
--   <i>exponent</i> is integral.</li>
--   </ul>
isMonomial :: Integral e => Monomial c e -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Describes a <a>http://en.wikipedia.org/wiki/Univariate</a>
--   polynomial and operations on it.</li>
--   <li><a>http://en.wikipedia.org/wiki/Polynomial</a>.</li>
--   <li><a>http://mathworld.wolfram.com/Polynomial.html</a>.</li>
--   </ul>
module Factory.Data.Polynomial

-- | <ul>
--   <li>The type of an arbitrary <i>univariate</i> polynomial; actually
--   it's more general, since it permits negative powers
--   (<a>http://en.wikipedia.org/wiki/Laurent_polynomial</a>s). It can't
--   describe <i>multivariate</i> polynomials, which would require a list
--   of <i>exponents</i>. Rather than requiring the <i>exponent</i> to
--   implement the <i>type-class</i> <a>Integral</a>, this is implemented
--   at the function-level, as required.</li>
--   <li>The structure permits gaps between <i>exponents</i>, in which
--   <i>coefficients</i> are inferred to be zero, thus enabling efficient
--   representation of sparse polynomials.</li>
--   <li>CAVEAT: the <a>MonomialList</a> is required to; be ordered by
--   <i>descending</i> exponent (ie. reverse
--   <a>http://en.wikipedia.org/wiki/Monomial_order</a>); have had zero
--   coefficients removed; and to have had <i>like</i> terms merged; so the
--   raw data-constructor isn't exported.</li>
--   </ul>
data Polynomial coefficient exponent

-- | Constructs a <i>polynomial</i> with zero terms.
zero :: Polynomial c e

-- | Constructs a constant <i>monomial</i>, independent of the
--   <i>indeterminate</i>.
one :: (Eq c, Num c, Num e) => Polynomial c e

-- | <ul>
--   <li>Evaluate the <i>polynomial</i> at a specific
--   <i>indeterminate</i>.</li>
--   <li>CAVEAT: requires positive exponents; but it wouldn't really be a
--   <i>polynomial</i> otherwise.</li>
--   <li>If the <i>polynomial</i> is very sparse, this may be inefficient,
--   since it <i>memoizes</i> the complete sequence of powers up to the
--   polynomial's <i>degree</i>.</li>
--   </ul>
evaluate :: (Num n, Integral e, Show e) => n -> Polynomial n e -> n

-- | <ul>
--   <li>Return the <i>degree</i> (AKA <i>order</i>) of the
--   <i>polynomial</i>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Degree_of_a_polynomial</a>.</li>
--   <li><a>http://mathworld.wolfram.com/PolynomialDegree.html</a>.</li>
--   </ul>
getDegree :: Num e => Polynomial c e -> e

-- | Return the highest-degree monomial.
getLeadingTerm :: Polynomial c e -> Monomial c e

-- | <ul>
--   <li>Transforms the data behind the constructor.</li>
--   <li>CAVEAT: similar to <a>fmap</a>, but <a>Polynomial</a> isn't an
--   instance of <a>Functor</a> since we may want to operate on both
--   <i>type-parameters</i>.</li>
--   <li>CAVEAT: the caller is required to re-<a>normalise</a> the
--   resulting polynomial depending on the nature of the transformation of
--   the data.</li>
--   </ul>
lift :: (MonomialList c1 e1 -> MonomialList c2 e2) -> Polynomial c1 e1 -> Polynomial c2 e2

-- | Reduces all the coefficients using <i>modular</i> arithmetic.
mod' :: Integral c => Polynomial c e -> c -> Polynomial c e

-- | Sorts into <i>descending order</i> of exponents, groups <i>like</i>
--   exponents, and calls <a>pruneCoefficients</a>.
normalise :: (Eq c, Num c, Ord e) => Polynomial c e -> Polynomial c e

-- | <ul>
--   <li>Raise a <i>polynomial</i> to the specified positive integral
--   power, but using <i>modulo</i>-arithmetic.</li>
--   <li>Whilst one could naively implement this as <tt>(x Data.Ring.=^ n)
--   <a>mod</a> m</tt>, this will result in arithmetic operatons on
--   unnecessarily big integers.</li>
--   </ul>
raiseModulo :: (Integral c, Integral power, Num e, Ord e, Show power) => Polynomial c e -> power -> c -> Polynomial c e

-- | Convert the type of the <i>coefficient</i>s.
realCoefficientsToFrac :: (Real r, Fractional f) => Polynomial r e -> Polynomial f e

-- | Returns the number of non-zero terms in the polynomial.
terms :: Polynomial c e -> Int

-- | Constructs an arbitrary <i>zeroeth-degree polynomial</i>, ie.
--   independent of the <i>indeterminate</i>.
mkConstant :: (Eq c, Num c, Num e) => c -> Polynomial c e

-- | Constructs an arbitrary <i>first-degree polynomial</i>.
mkLinear :: (Eq c, Num c, Num e) => c -> c -> Polynomial c e

-- | Smart constructor. Constructs an arbitrary <i>polynomial</i>.
mkPolynomial :: (Eq c, Num c, Ord e) => MonomialList c e -> Polynomial c e

-- | <ul>
--   <li>Scale-up the specified <i>polynomial</i> by a constant
--   <i>monomial</i> factor.</li>
--   <li><a>http://en.wikipedia.org/wiki/Scalar_multiplication</a>.</li>
--   </ul>
(*=) :: (Eq c, Num c, Num e) => Polynomial c e -> Monomial c e -> Polynomial c e

-- | <ul>
--   <li><a>True</a> if the two specified <i>polynomials</i> are
--   <i>congruent</i> in <i>modulo</i>-arithmetic.</li>
--   
--   <li><a>http://planetmath.org/encyclopedia/PolynomialCongruence.html</a>.</li>
--   </ul>
areCongruentModulo :: (Integral c, Num e, Ord e) => Polynomial c e -> Polynomial c e -> c -> Bool

-- | True if the <i>exponents</i> of successive terms are in
--   <i>ascending</i> order.
inAscendingOrder :: Ord e => Polynomial c e -> Bool

-- | True if the <i>exponents</i> of successive terms are in
--   <i>descending</i> order.
inDescendingOrder :: Ord e => Polynomial c e -> Bool

-- | <ul>
--   <li><a>True</a> if the <i>leading coefficient</i> is one.</li>
--   
--   <li><a>http://en.wikipedia.org/wiki/Monic_polynomial#Classifications</a>.</li>
--   </ul>
isMonic :: (Eq c, Num c) => Polynomial c e -> Bool

-- | True if there's exactly one term.
isMonomial :: Polynomial c e -> Bool

-- | True if no term has a <i>coefficient</i> of zero and the
--   <i>exponents</i> of successive terms are in <i>descending</i> order.
isNormalised :: (Eq c, Num c, Ord e) => Polynomial c e -> Bool

-- | True if all <i>exponents</i> are <i>positive</i> integers as required.
isPolynomial :: Integral e => Polynomial c e -> Bool

-- | True if there are zero terms.
isZero :: Polynomial c e -> Bool
instance (Eq coefficient, Eq exponent) => Eq (Polynomial coefficient exponent)
instance (Show coefficient, Show exponent) => Show (Polynomial coefficient exponent)
instance (Eq c, Fractional c, Num e, Ord e) => QuotientRing (Polynomial c e)
instance (Eq c, Num c, Num e, Ord e) => Ring (Polynomial c e)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Describes a <i>monic polynomial;
--   &lt;http:</i><i>en.wikipedia.org</i>wiki/Monic_polynomial#Classifications&gt;;
--   ie. in which the <i>coefficient</i> of the <i>leading term</i> is
--   one.</li>
--   </ul>
module Factory.Data.MonicPolynomial

-- | A type of <a>Polynomial</a>, in which the <i>leading term</i> is
--   required to have a <i>coefficient</i> of one.
data MonicPolynomial c e

-- | Smart constructor. Constructs an arbitrary <i>monic polynomial</i>.
mkMonicPolynomial :: (Eq c, Num c, Ord e, Show c, Show e) => Polynomial c e -> MonicPolynomial c e
instance (Eq c, Eq e) => Eq (MonicPolynomial c e)
instance (Show c, Show e) => Show (MonicPolynomial c e)
instance (Eq c, Num c, Num e, Ord e, Show c, Show e) => QuotientRing (MonicPolynomial c e)
instance (Eq c, Num c, Num e, Ord e, Show c, Show e) => Ring (MonicPolynomial c e)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Describes a bounded set of, typically integral, quantities.</li>
--   <li>Operations have been defined, on the list of <i>consecutive</i>
--   quantities delimited by these endpoints.</li>
--   <li>The point is that if the list is composed from <i>consecutive</i>
--   quantities, the intermediate values can be inferred, rather than
--   physically represented.</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>CAVEATS</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>The API was driven top-down by its caller's requirements, rather
--   than a bottom-up attempt to provide a complete interface. consequently
--   there may be omissions from the view point of future callers.</li>
--   <li>Thought similar to the mathematical concept of an <i>interval</i>,
--   the latter technically relates to <i>real</i> numbers;
--   <a>http://en.wikipedia.org/wiki/Interval_%28mathematics%29</a>.</li>
--   <li>No account has been made for <i>semi-closed</i> or <i>open</i>
--   intervals.</li>
--   </ul>
module Factory.Data.Interval

-- | Defines a closed (inclusive) interval of consecutive values.
type Interval endPoint = (endPoint, endPoint)

-- | Construct the <i>unsigned closed unit-interval</i>;
--   <a>http://en.wikipedia.org/wiki/Unit_interval</a>.
closedUnitInterval :: Num n => Interval n

-- | Construct an <i>interval</i> from a bounded type.
mkBounded :: Bounded endPoint => Interval endPoint

-- | True if the specified value is within the inclusive bounds of the
--   <i>interval</i>.
elem' :: Ord endPoint => endPoint -> Interval endPoint -> Bool

-- | Swap the <i>end-points</i> where they were originally reversed, but
--   otherwise do nothing.
normalise :: Ord endPoint => Interval endPoint -> Interval endPoint

-- | <ul>
--   <li>Multiplies the consecutive sequence of integers within
--   <a>Interval</a>.</li>
--   <li>Since the result can be large, <a>divideAndConquer</a> is used to
--   form operands of a similar order of magnitude, thus improving the
--   efficiency of the big-number multiplication.</li>
--   </ul>
product' :: (Integral i, Show i) => Ratio i -> i -> Interval i -> i

-- | Shift of both <i>end-points</i> of the <i>interval</i> by the
--   specified amount.
shift :: Num endPoint => endPoint -> Interval endPoint -> Interval endPoint

-- | Bisect the <i>interval</i> at the specified <i>end-point</i>; which
--   should be between the two existing <i>end-points</i>.
splitAt' :: (Enum endPoint, Num endPoint, Ord endPoint, Show endPoint) => endPoint -> Interval endPoint -> (Interval endPoint, Interval endPoint)

-- | <ul>
--   <li>Converts <a>Interval</a> to a list by enumerating the values.</li>
--   <li>CAVEAT: produces rather odd results for <a>Fractional</a> types,
--   but no stranger than considering such types Enumerable in the first
--   place.</li>
--   </ul>
toList :: Enum endPoint => Interval endPoint -> [endPoint]

-- | Accessor.
getMinBound :: Interval endPoint -> endPoint

-- | Accessor.
getMaxBound :: Interval endPoint -> endPoint

-- | Construct an <i>interval</i> from a single value.
precisely :: endPoint -> Interval endPoint

-- | True if <a>getMinBound</a> exceeds <a>getMaxBound</a> extent.
isReversed :: Ord endPoint => Interval endPoint -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Functions for
--   probability-distributions.</li>
--   <li><i><tt>CAVEAT</tt></i> Because data-constructors are exposed,
--   <a>isValid</a> need not be called.</li>
--   </ul>
module Factory.Math.Probability

-- | Defines a common interface for probability-distributions.
class Distribution probabilityDistribution where getStandardDeviation = sqrt . getVariance getVariance = square . getStandardDeviation
generatePopulation :: (Distribution probabilityDistribution, Fractional sample, RandomGen randomGen) => probabilityDistribution -> randomGen -> [sample]
getMean :: (Distribution probabilityDistribution, Fractional mean) => probabilityDistribution -> mean
getStandardDeviation :: (Distribution probabilityDistribution, Floating standardDeviation) => probabilityDistribution -> standardDeviation
getVariance :: (Distribution probabilityDistribution, Floating variance) => probabilityDistribution -> variance

-- | Describes <i>continuous probability-distributions</i>;
--   <a>http://en.wikipedia.org/wiki/List_of_probability_distributions#Continuous_distributions</a>.
data ContinuousDistribution parameter

-- | Defines an <i>Exponential</i>-distribution with a particular
--   <i>lambda</i>;
--   <a>http://en.wikipedia.org/wiki/Exponential_distribution</a>.
ExponentialDistribution :: parameter -> ContinuousDistribution parameter

-- | Defines a distribution whose logarithm is normally distributed with a
--   particular <i>mean</i> &amp; <i>variance</i>;
--   <a>http://en.wikipedia.org/wiki/Lognormal</a>.
LogNormalDistribution :: parameter -> parameter -> ContinuousDistribution parameter

-- | Defines a <i>Normal</i>-distribution with a particular <i>mean</i>
--   &amp; <i>variance</i>;
--   <a>http://en.wikipedia.org/wiki/Normal_distribution</a>.
NormalDistribution :: parameter -> parameter -> ContinuousDistribution parameter

-- | Defines a <i>Uniform</i>-distribution within a <i>closed interval</i>;
--   <a>http://en.wikipedia.org/wiki/Uniform_distribution</a>.
UniformDistribution :: (Interval parameter) -> ContinuousDistribution parameter

-- | Describes <i>discrete probability-distributions</i>;
--   <a>http://en.wikipedia.org/wiki/List_of_probability_distributions#Discrete_distributions</a>.
data DiscreteDistribution parameter

-- | Defines an <i>Poisson</i>-distribution with a particular
--   <i>lambda</i>;
--   <a>http://en.wikipedia.org/wiki/Poisson_distribution</a>.
PoissonDistribution :: parameter -> DiscreteDistribution parameter

-- | Defines an <i>Geometric</i>-distribution with a particular probability
--   of success;
--   <a>http://en.wikipedia.org/wiki/Geometric_distribution</a>.
ShiftedGeometricDistribution :: parameter -> DiscreteDistribution parameter

-- | The maximum integer which can be accurately represented as a Double.
maxPreciseInteger :: RealFloat a => a -> Integer

-- | <ul>
--   <li>Converts a pair of independent <i>uniformly distributed</i> random
--   numbers, within the <i>semi-closed unit interval</i> <i>(0,1]</i>, to
--   a pair of independent <i>normally distributed</i> random numbers, of
--   standardized <i>mean</i>=0, and <i>variance</i>=1.</li>
--   
--   <li><a>http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform</a>.</li>
--   </ul>
boxMullerTransform :: (Floating f, Ord f, Show f) => (f, f) -> (f, f)

-- | <ul>
--   <li>Uses the supplied random-number generator, to generate a
--   conceptually infinite list, of <i>normally distributed</i> random
--   numbers, with standardized <i>mean</i>=0, and <i>variance</i>=1.</li>
--   <li><a>http://en.wikipedia.org/wiki/Normal_distribution</a>,
--   <a>http://mathworld.wolfram.com/NormalDistribution.html</a>.</li>
--   </ul>
generateStandardizedNormalDistribution :: (RealFloat f, Show f, Random f, RandomGen randomGen) => randomGen -> [f]

-- | Uses the supplied random-number generator, to generate a conceptually
--   infinite population, with the specified continuous
--   probability-distribution.
generateContinuousPopulation :: (RealFloat f, Show f, Random f, RandomGen randomGen) => ContinuousDistribution f -> randomGen -> [f]

-- | Uses the supplied random-number generator, to generate a conceptually
--   infinite population, with the specified discrete
--   probability-distribution.
generateDiscretePopulation :: (Integral sample, Ord parameter, RealFloat parameter, Show parameter, Random parameter, RandomGen randomGen) => DiscreteDistribution parameter -> randomGen -> [sample]
instance Eq parameter => Eq (ContinuousDistribution parameter)
instance Read parameter => Read (ContinuousDistribution parameter)
instance Show parameter => Show (ContinuousDistribution parameter)
instance Eq parameter => Eq (DiscreteDistribution parameter)
instance Read parameter => Read (DiscreteDistribution parameter)
instance Show parameter => Show (DiscreteDistribution parameter)
instance (RealFloat parameter, Show parameter, Random parameter) => Distribution (DiscreteDistribution parameter)
instance (RealFloat parameter, Show parameter, Random parameter) => Distribution (ContinuousDistribution parameter)
instance (Num parameter, Ord parameter, Show parameter) => SelfValidator (DiscreteDistribution parameter)
instance (Floating parameter, Ord parameter, Show parameter) => SelfValidator (ContinuousDistribution parameter)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Describes a simple numeric type, designed to contain an
--   <i>exponential</i> number.</li>
--   <li><a>http://en.wikipedia.org/wiki/Exponentiation</a>.</li>
--   </ul>
module Factory.Data.Exponential

-- | Describes an <i>exponential</i>, in terms of its <i>base</i> and
--   <i>exponent</i>.
type Exponential base exponent = (base, exponent)

-- | Evaluate the specified <a>Exponential</a>, returning the resulting
--   number.
evaluate :: (Num base, Integral exponent) => Exponential base exponent -> base

-- | Invert the value, by negating the exponent.
invert :: Num exponent => Exponential base exponent -> Exponential base exponent

-- | Accessor.
getBase :: Exponential base exponent -> base

-- | Accessor.
getExponent :: Exponential base exponent -> exponent

-- | <ul>
--   <li>Construct an <a>Exponential</a> merely raised to the 1st
--   power.</li>
--   <li>The value of the resulting exponential is the same as specified
--   <tt>base</tt>;
--   <a>http://en.wikipedia.org/wiki/Identity_element</a>.</li>
--   </ul>
rightIdentity :: Num exponent => base -> Exponential base exponent

-- | Raise the specified <a>Exponential</a> to a power.
(<^) :: Num exponent => Exponential base exponent -> exponent -> Exponential base exponent

-- | True if the <i>bases</i> are equal.
(=~) :: Eq base => Exponential base exponent -> Exponential base exponent -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Describes a list of <i>prime factors</i>.</li>
--   <li>The product of this list of prime-factors represents the
--   <i>composite</i> integer from which they were originally
--   extracted.</li>
--   </ul>
module Factory.Data.PrimeFactors

-- | <ul>
--   <li>Each element of this list represents one <i>prime-factor</i>,
--   expressed as an <i>exponential</i> with a <i>prime</i> base, of the
--   original integer.</li>
--   <li>Whilst it only makes sense for both the <i>base</i> and
--   <i>exponent</i> to be integral, these constrains are applied at the
--   function-level as required.</li>
--   </ul>
type Factors base exponent = [Exponential base exponent]

-- | <ul>
--   <li>Insert a <a>Exponential</a>, into a list representing a product of
--   <i>prime factors</i>, multiplying with any incumbent of like
--   <i>base</i>.</li>
--   <li>The list should be sorted by increasing <i>base</i>.</li>
--   <li>Preserves the sort-order.</li>
--   <li>CAVEAT: this is tolerably efficient for sporadic insertion; to
--   insert a list, use <a>&gt;*&lt;</a>.</li>
--   </ul>
insert' :: (Ord base, Num exponent) => Exponential base exponent -> Factors base exponent -> Factors base exponent

-- | Multiply a list of <i>prime factors</i>.
product' :: (Num base, Integral exponent) => BisectionRatio -> MinLength -> Factors base exponent -> base

-- | <ul>
--   <li>Sorts a list representing a product of <i>prime factors</i> by
--   increasing <i>base</i>.</li>
--   <li>Multiplies <a>Exponential</a>s of similar <i>base</i>.</li>
--   </ul>
reduce :: (Ord base, Num exponent, Ord exponent) => Factors base exponent -> Factors base exponent

-- | <ul>
--   <li>Multiplies two lists each representing a product of <i>prime
--   factors</i>, and sorted by increasing <i>base</i>.</li>
--   <li>Preserves the sort-order.</li>
--   </ul>
(>*<) :: (Ord base, Num exponent, Ord exponent) => Factors base exponent -> Factors base exponent -> Factors base exponent

-- | <ul>
--   <li>Divides two lists, each representing a product of <i>prime
--   factors</i>, and sorted by increasing <i>base</i>.</li>
--   <li>Preserves the sort-order.</li>
--   </ul>
(>/<) :: (Integral base, Integral exponent) => Factors base exponent -> Factors base exponent -> (Factors base exponent, Factors base exponent)

-- | <ul>
--   <li>Raise the product of a list <i>prime factors</i> to the specified
--   power.</li>
--   <li>CAVEAT: this merely involves raising each element to the specified
--   power; cf. raising a <i>polynomial</i> to a power.</li>
--   </ul>
(>^) :: Num exponent => Factors base exponent -> exponent -> Factors base exponent


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Provides implementations of the class <a>Algorithmic</a>.</li>
--   <li>Provides additional functions related to <i>factorials</i>, but
--   which depends on a specific implementation, and which therefore can't
--   be accessed throught the class-interface.</li>
--   <li><a>http://en.wikipedia.org/wiki/Factorial</a>.</li>
--   <li><a>http://mathworld.wolfram.com/Factorial.html</a>.</li>
--   
--   <li><a>http://www.luschny.de/math/factorial/FastFactorialFunctions.htm</a>.</li>
--   </ul>
module Factory.Math.Implementations.Factorial

-- | The algorithms by which <i>factorial</i> has been implemented.
data Algorithm

-- | The integers from which the <i>factorial</i> is composed, are
--   multiplied using <tt>Data.Interval.product'</tt>.
Bisection :: Algorithm

-- | The <i>prime factors</i> of the <i>factorial</i> are extracted, then
--   raised to the appropriate power, before multiplication.
PrimeFactorisation :: Algorithm

-- | <ul>
--   <li>Returns the <i>prime factors</i>, of the <i>factorial</i> of the
--   specifed integer.</li>
--   <li>Precisely all the primes less than or equal to the specified
--   integer <i>n</i>, are included in <i>n!</i>; only the multiplicity of
--   each of these known prime components need be determined.</li>
--   <li><a>http://en.wikipedia.org/wiki/Factorial#Number_theory</a>.</li>
--   <li>CAVEAT: currently a hotspot.</li>
--   </ul>
primeFactors :: Integral base => base -> Factors base base

-- | Returns the <i>rising factorial</i>;
--   <a>http://mathworld.wolfram.com/RisingFactorial.html</a>
risingFactorial :: (Integral i, Show i) => i -> i -> i

-- | Returns the <i>falling factorial</i>;
--   <a>http://mathworld.wolfram.com/FallingFactorial.html</a>
fallingFactorial :: (Integral i, Show i) => i -> i -> i

-- | <ul>
--   <li>Returns the ratio of two factorials.</li>
--   <li>It is more efficient than evaluating both factorials, and then
--   dividing.</li>
--   <li>For more complex combinations of factorials, such as in the
--   <i>Binomial coefficient</i>, extract the <i>prime factors</i> using
--   <a>primeFactors</a> then manipulate them using the module
--   <a>Data.PrimeFactors</a>, and evaluate it using by
--   <i>Data.PrimeFactors.product'</i>.</li>
--   </ul>
(!/!) :: (Integral i, Fractional f, Show i) => i -> i -> f
instance Eq Algorithm
instance Read Algorithm
instance Show Algorithm
instance Algorithmic Algorithm
instance Defaultable Algorithm


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the <i>Borwein</i> series for
--   <i>Pi</i>;
--   <a>http://en.wikipedia.org/wiki/Borwein%27s_algorithm#Jonathan_Borwein_and_Peter_Borwein.27s_Version_.281993.29</a></li>
--   </ul>
module Factory.Math.Implementations.Pi.Borwein.Borwein1993

-- | Defines the parameters of the <i>Borwein</i> series.
series :: (Algorithmic squareRootAlgorithm, Algorithmic factorialAlgorithm) => Series squareRootAlgorithm factorialAlgorithm


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the set of <i>Borwein</i>-type
--   algorithms (currently only one) which have been implemented;
--   <a>http://www.pi314.net/eng/borwein.php</a>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Borwein.Algorithm

-- | <ul>
--   <li>Define those <i>Borwein</i>-series which have been
--   implemented.</li>
--   <li>Though currently there's only one, provision has been made for the
--   addition of more.</li>
--   </ul>
data Algorithm squareRootAlgorithm factorialAlgorithm

-- | <a>http://en.wikipedia.org/wiki/Borwein%27s_algorithm</a>.
Borwein1993 :: squareRootAlgorithm -> factorialAlgorithm -> Algorithm squareRootAlgorithm factorialAlgorithm
instance (Eq squareRootAlgorithm, Eq factorialAlgorithm) => Eq (Algorithm squareRootAlgorithm factorialAlgorithm)
instance (Read squareRootAlgorithm, Read factorialAlgorithm) => Read (Algorithm squareRootAlgorithm factorialAlgorithm)
instance (Show squareRootAlgorithm, Show factorialAlgorithm) => Show (Algorithm squareRootAlgorithm factorialAlgorithm)
instance (Algorithmic squareRootAlgorithm, Algorithmic factorialAlgorithm) => Algorithmic (Algorithm squareRootAlgorithm factorialAlgorithm)
instance (Defaultable squareRootAlgorithm, Defaultable factorialAlgorithm) => Defaultable (Algorithm squareRootAlgorithm factorialAlgorithm)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the <i>Chudnovsky</i> series
--   for <i>Pi</i>; <a>http://en.wikipedia.org/wiki/Pi</a>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Ramanujan.Chudnovsky

-- | Defines the parameters of the <i>Chudnovsky</i> series.
series :: (Algorithmic squareRootAlgorithm, Algorithmic factorialAlgorithm) => Series squareRootAlgorithm factorialAlgorithm


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the <i>Ramanujan</i> series
--   for <i>Pi</i>;
--   <a>http://planetmath.org/encyclopedia/RamanujansFormulaForPi.html</a>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Ramanujan.Classic

-- | Defines the parameters of the <i>Ramanujan</i> series.
series :: (Algorithmic squareRootAlgorithm, Algorithmic factorialAlgorithm) => Series squareRootAlgorithm factorialAlgorithm


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines the set of
--   <i>Ramanujan</i>-type algorithms which have been implemented;
--   <a>http://en.wikipedia.org/wiki/Pi</a>.</li>
--   </ul>
module Factory.Math.Implementations.Pi.Ramanujan.Algorithm

-- | Define those <i>Ramanujan</i>-series which have been implemented.
data Algorithm squareRootAlgorithm factorialAlgorithm

-- | The original version.
Classic :: squareRootAlgorithm -> factorialAlgorithm -> Algorithm squareRootAlgorithm factorialAlgorithm

-- | A variant found by the <i>Chudnovsky brothers</i>.
Chudnovsky :: squareRootAlgorithm -> factorialAlgorithm -> Algorithm squareRootAlgorithm factorialAlgorithm
instance (Eq squareRootAlgorithm, Eq factorialAlgorithm) => Eq (Algorithm squareRootAlgorithm factorialAlgorithm)
instance (Read squareRootAlgorithm, Read factorialAlgorithm) => Read (Algorithm squareRootAlgorithm factorialAlgorithm)
instance (Show squareRootAlgorithm, Show factorialAlgorithm) => Show (Algorithm squareRootAlgorithm factorialAlgorithm)
instance (Algorithmic squareRootAlgorithm, Algorithmic factorialAlgorithm) => Algorithmic (Algorithm squareRootAlgorithm factorialAlgorithm)
instance (Defaultable squareRootAlgorithm, Defaultable factorialAlgorithm) => Defaultable (Algorithm squareRootAlgorithm factorialAlgorithm)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Miscellaneous statistics
--   functions.</li>
--   </ul>
module Factory.Math.Statistics

-- | <ul>
--   <li>Determines the <i>mean</i> of the specified numbers;
--   <a>http://en.wikipedia.org/wiki/Mean</a>.</li>
--   <li>Should the caller define the result-type as <a>Rational</a>, then
--   it will be free from rounding-errors.</li>
--   </ul>
getMean :: (Foldable foldable, Fractional result, Real value) => foldable value -> result

-- | <ul>
--   <li>Determines the <i>weighted mean</i> of the specified numbers;
--   <a>http://en.wikipedia.org/wiki/Weighted_arithmetic_mean</a>.</li>
--   <li>The specified value is only evaluated if the corresponding weight
--   is non-zero.</li>
--   <li>Should the caller define the result-type as <a>Rational</a>, then
--   it will be free from rounding-errors.</li>
--   </ul>
getWeightedMean :: (Foldable foldable, Fractional result, Real value, Real weight) => foldable (value, weight) -> result

-- | <ul>
--   <li>Determines the exact <i>variance</i> of the specified numbers;
--   <a>http://en.wikipedia.org/wiki/Variance</a>.</li>
--   <li>Should the caller define the result-type as <a>Rational</a>, then
--   it will be free from rounding-errors.</li>
--   </ul>
getVariance :: (Foldable foldable, Fractional variance, Functor foldable, Real value) => foldable value -> variance

-- | Determines the <i>standard-deviation</i> of the specified numbers;
--   <a>http://en.wikipedia.org/wiki/Standard_deviation</a>.
getStandardDeviation :: (Foldable foldable, Floating result, Functor foldable, Real value) => foldable value -> result

-- | <ul>
--   <li>Determines the <i>average absolute deviation</i> of the specified
--   numbers;
--   <a>http://en.wikipedia.org/wiki/Absolute_deviation#Average_absolute_deviation</a>.</li>
--   <li>Should the caller define the result-type as <a>Rational</a>, then
--   it will be free from rounding-errors.</li>
--   </ul>
getAverageAbsoluteDeviation :: (Foldable foldable, Fractional result, Functor foldable, Real value) => foldable value -> result

-- | Determines the <i>coefficient-of-variance</i> of the specified
--   numbers; <a>http://en.wikipedia.org/wiki/Coefficient_of_variation</a>.
getCoefficientOfVariance :: (Foldable foldable, Eq result, Floating result, Functor foldable, Real value) => foldable value -> result

-- | The number of unordered <i>combinations</i> of <i>r</i> objects taken
--   from <i>n</i>; <a>http://en.wikipedia.org/wiki/Combination</a>.
nCr :: (Algorithmic factorialAlgorithm, Integral i, Show i) => factorialAlgorithm -> i -> i -> i

-- | The number of <i>permutations</i> of <i>r</i> objects taken from
--   <i>n</i>; <a>http://en.wikipedia.org/wiki/Permutations</a>.
nPr :: (Integral i, Show i) => i -> i -> i


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Implements <a>Algorithmic</a> by a
--   variety of methods.</li>
--   <li><i><tt>CAVEAT</tt></i></li>
--   </ul>
--   
--   Caller may benefit from application of <a>simplify</a> before
--   operating on the result; which though of the required accuracy, may
--   not be the most concise rational number satisfying that criterion.
module Factory.Math.Implementations.SquareRoot

-- | The number of terms in a series.
type Terms = Int

-- | The algorithms by which the <i>square-root</i> has been implemented.
data Algorithm

-- | 
--   <a>http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Bakhshali_approximation</a>
BakhshaliApproximation :: Algorithm

-- | 
--   <a>http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Continued_fraction_expansion</a>.
ContinuedFraction :: Algorithm

-- | <a>http://en.wikipedia.org/wiki/Halley%27s_method</a>.
HalleysMethod :: Algorithm

-- | <a>http://en.wikipedia.org/wiki/Newton%27s_method</a>.
NewtonRaphsonIteration :: Algorithm

-- | 
--   <a>http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Taylor_series</a>.
TaylorSeries :: Terms -> Algorithm
instance Eq Algorithm
instance Read Algorithm
instance Show Algorithm
instance Iterator Algorithm
instance Algorithmic Algorithm
instance Defaultable Algorithm


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li><a>http://en.wikipedia.org/wiki/Integer_factorization</a>.</li>
--   <li>Exports a common interface to permit decomposition of positive
--   integers, into the unique combination of <i>prime</i>-factors known to
--   exist according to the <i>Fundamental Theorem of Arithmetic</i>;
--   <a>http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic</a>.</li>
--   <li>Leveraging this abstract capability, it derives the
--   <i>smoothness</i>, <i>power-smoothness</i>, <i>omega</i>-numbers and
--   <i>square-free</i> integers.</li>
--   <li>Filters the list of <i>regular-numbers</i> from the list of
--   <i>smoothness</i>.</li>
--   <li>CAVEAT: to avoid wasting time, it may be advantageous to check
--   <i>Factory.Math.Primality.isPrime</i> first.</li>
--   </ul>
module Factory.Math.PrimeFactorisation

-- | Defines the methods expected of a <i>factorisation</i>-algorithm.
class Algorithmic algorithm
primeFactors :: (Algorithmic algorithm, NFData base, Integral base) => algorithm -> base -> Factors base Int

-- | <ul>
--   <li>The upper limit for a prime to be considered as a candidate factor
--   of the specified number.</li>
--   <li>One might naively think that this limit is <tt>(x <a>div</a>
--   2)</tt> for an even number, but though a prime-factor <i>greater</i>
--   than the <i>square-root</i> of the number can exist, its smaller
--   <i>cofactor</i> decomposes to a prime which must be less than the
--   <i>square-root</i>.</li>
--   <li>NB: rather then using <tt>(primeFactor &lt;= sqrt numerator)</tt>
--   to filter the candidate prime-factors of a given numerator, one can
--   alternatively use <tt>(numerator &gt;= primeFactor ^ 2)</tt> to filter
--   what can potentially be factored by a given prime-factor.</li>
--   <li>CAVEAT: suffers from rounding-errors, though no consequence has
--   been witnessed.</li>
--   </ul>
maxBoundPrimeFactor :: Integral i => i -> i

-- | <ul>
--   <li>A constant, zero-indexed, conceptually infinite, list, of the
--   <i>smooth</i>ness of all positive integers.</li>
--   <li><a>http://en.wikipedia.org/wiki/Smooth_number</a>.</li>
--   <li><a>http://mathworld.wolfram.com/SmoothNumber.html</a>.</li>
--   </ul>
smoothness :: (Algorithmic algorithm, NFData base, Integral base) => algorithm -> [base]

-- | <ul>
--   <li>A constant, zero-indexed, conceptually infinite, list of the
--   <i>power-smooth</i>ness of all positive integers.</li>
--   
--   <li><a>http://en.wikipedia.org/wiki/Smooth_number#Powersmooth_numbers</a>.</li>
--   </ul>
powerSmoothness :: (Algorithmic algorithm, NFData base, Integral base) => algorithm -> [base]

-- | <ul>
--   <li>Filters <a>smoothness</a>, to derive the constant list of
--   <i>Hamming-numbers</i>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Regular_number</a>.</li>
--   </ul>
regularNumbers :: (Algorithmic algorithm, NFData base, Integral base) => algorithm -> [base]

-- | <ul>
--   <li><i>Euler's Totient</i> for a <i>power</i> of a
--   <i>prime</i>-number.</li>
--   <li>By <i>Olofsson</i>; <tt>(phi(n^k) = n^(k - 1) * phi(n))</tt> and
--   since <tt>(phi(prime) = prime - 1)</tt></li>
--   <li>CAVEAT: checks neither the primality nor the bounds of the
--   specified value; therefore for internal use only.</li>
--   </ul>
primePowerTotient :: (Integral base, Integral exponent) => Exponential base exponent -> base

-- | <ul>
--   <li>The number of <i>coprimes</i> less than or equal to the specified
--   positive integer.</li>
--   
--   <li><a>http://en.wikipedia.org/wiki/Euler%27s_totient_function</a>.</li>
--   <li><a>http://mathworld.wolfram.com/TotientFunction.html</a>.</li>
--   <li>AKA <i>EulerPhi</i>.</li>
--   </ul>
eulersTotient :: (Algorithmic algorithm, NFData i, Integral i, Show i) => algorithm -> i -> i

-- | <ul>
--   <li>A constant, zero-indexed, conceptually infinite, list of the
--   <i>small omega</i> numbers (i.e. the number of <i>distinct</i> prime
--   factors); cf. <i>big omega</i>.</li>
--   
--   <li><a>http://oeis.org/wiki/Omega%28n%29,_number_of_distinct_primes_dividing_n</a>.</li>
--   <li><a>http://mathworld.wolfram.com/DistinctPrimeFactors.html</a></li>
--   
--   <li><a>http://planetmath.org/encyclopedia/NumberOfDistinctPrimeFactorsFunction.html</a>.</li>
--   </ul>
omega :: (Algorithmic algorithm, NFData i, Integral i) => algorithm -> [i]

-- | <ul>
--   <li>A constant, conceptually infinite, list of the <i>square-free</i>
--   numbers, i.e. those which aren't divisible by any <i>perfect
--   square</i>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Square-free_integer</a>.</li>
--   </ul>
squareFree :: (Algorithmic algorithm, NFData i, Integral i) => algorithm -> [i]


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Exports the <i>Multiplicative
--   Order</i> of an integer, in a specific <i>modular</i> arithmetic.</li>
--   </ul>
module Factory.Math.MultiplicativeOrder

-- | <ul>
--   <li>The smallest positive integral power to which the specified
--   integral base must be raised, to be congruent with one, in the
--   specified <i>modular</i> arithmetic.</li>
--   <li>Based on
--   <a>http://rosettacode.org/wiki/Multiplicative_order#Haskell</a>.</li>
--   <li><a>http://en.wikipedia.org/wiki/Multiplicative_order</a>.</li>
--   <li><a>http://mathworld.wolfram.com/MultiplicativeOrder.html</a>.</li>
--   </ul>
multiplicativeOrder :: (Algorithmic primeFactorisationAlgorithm, NFData i, Integral i, Show i) => primeFactorisationAlgorithm -> i -> i -> i


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Determines whether an integer is prime.</li>
--   <li><a>http://en.wikipedia.org/wiki/Primality_test</a>.</li>
--   <li><a>http://primes.utm.edu/index.html</a></li>
--   <li>CAVEAT: it doesn't determine the prime-factors of composite
--   numbers, just that they exist.</li>
--   </ul>
module Factory.Math.Implementations.Primality

-- | The algorithms by which <i>primality</i>-testing has been implemented.
data Algorithm factorisationAlgorithm

-- | <a>http://en.wikipedia.org/wiki/AKS_primality_test</a>.
AKS :: factorisationAlgorithm -> Algorithm factorisationAlgorithm

-- | 
--   <a>http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test</a>.
MillerRabin :: Algorithm factorisationAlgorithm
instance Eq factorisationAlgorithm => Eq (Algorithm factorisationAlgorithm)
instance Read factorisationAlgorithm => Read (Algorithm factorisationAlgorithm)
instance Show factorisationAlgorithm => Show (Algorithm factorisationAlgorithm)
instance Algorithmic factorisationAlgorithm => Algorithmic (Algorithm factorisationAlgorithm)
instance Defaultable (Algorithm factorisationAlgorithm)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Generates the constant, conceptually
--   infinite, list of <i>prime-numbers</i>, using <i>Trial
--   Division</i>.</li>
--   </ul>
module Factory.Math.Implementations.Primes.TrialDivision

-- | <ul>
--   <li>For each candidate, confirm indivisibility, by all <i>primes</i>
--   smaller than its <i>square-root</i>.</li>
--   <li>The candidates to sieve, are generated by a <a>PrimeWheel</a>, of
--   parameterised, but static, size;
--   <a>http://en.wikipedia.org/wiki/Wheel_factorization</a>.</li>
--   </ul>
trialDivision :: Integral prime => NPrimes -> [prime]


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Generates the constant list of <i>prime-numbers</i>, by a variety
--   of different algorithms.</li>
--   <li><a>http://www.haskell.org/haskellwiki/Prime_numbers</a>.</li>
--   
--   <li><a>http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.31.3936&amp;rep=rep1&amp;type=pdf</a>.</li>
--   <li><a>http://larc.unt.edu/ian/pubs/sieve.pdf</a>.</li>
--   </ul>
module Factory.Math.Implementations.Primes.Algorithm

-- | The implemented methods by which the primes may be generated.
data Algorithm

-- | The <i>Sieve of Atkin</i>, optimised using a <a>PrimeWheel</a> of
--   optimal size, for primes up to the specified maximum bound;
--   <a>http://en.wikipedia.org/wiki/Sieve_of_Atkin</a>.
SieveOfAtkin :: Integer -> Algorithm

-- | The <i>Sieve of Eratosthenes</i>
--   (<a>http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a>), optimised
--   using a <a>PrimeWheel</a>.
SieveOfEratosthenes :: NPrimes -> Algorithm

-- | For each candidate, confirm indivisibility, by all <i>primes</i>
--   smaller than its <i>square-root</i>, optimised using a
--   <a>PrimeWheel</a>.
TrialDivision :: NPrimes -> Algorithm

-- | For each <i>prime</i>, the infinite list of candidates greater than
--   its <i>square</i>, is filtered for indivisibility;
--   <a>http://www.haskell.org/haskellwiki/Prime_numbers#Turner.27s_sieve_-_Trial_division</a>.
TurnersSieve :: Algorithm

-- | <a>wheelSieve</a>.
WheelSieve :: Int -> Algorithm
instance Eq Algorithm
instance Read Algorithm
instance Show Algorithm
instance Algorithmic Algorithm
instance Defaultable Algorithm


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Implements several different prime-factorisation algorithms.</li>
--   
--   <li><a>http://www.tug.org/texinfohtml/coreutils.html#factor-invocation</a>.</li>
--   </ul>
module Factory.Math.Implementations.PrimeFactorisation

-- | The algorithms by which prime-factorisation has been implemented.
data Algorithm

-- | <a>http://en.wikipedia.org/wiki/Fermat%27s_factorization_method</a>.
FermatsMethod :: Algorithm

-- | <a>http://en.wikipedia.org/wiki/Trial_division</a>.
TrialDivision :: Algorithm
instance Eq Algorithm
instance Read Algorithm
instance Show Algorithm
instance Algorithmic Algorithm
instance Defaultable Algorithm
