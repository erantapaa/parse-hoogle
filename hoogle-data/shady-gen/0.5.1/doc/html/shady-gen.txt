-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functional GPU programming - DSEL & compiler
--   
--   Compile functional specifications for GPU execution. See also
--   shady-render, shady-tv, and shady-examples
--   
--   Copyright 2009-2011 by Conal Elliott; GNU AGPLv3 license (see
--   COPYING). This license is a place-holder. Let me know if you'd like
--   other terms.
@package shady-gen
@version 0.5.1


-- | Memoization based using stable names. WHNFs keys.
module Data.StableMemo

-- | Pointer-based memoization. Evaluates keys to WHNF to improve hit rate.
memo :: (k -> v) -> (k -> v)

-- | Memoized binary function
memo2 :: (k -> l -> v) -> (k -> l -> v)

-- | Memoized ternary function
memo3 :: (k -> l -> m -> v) -> (k -> l -> m -> v)


-- | Misc useful definitions
module Shady.Misc

-- | Real-valued modulo. You can use <a>fmodRF</a> for <a>RealFrac</a>
--   types and <a>fmodViaFrac</a> for <a>Frac</a> types.
class FMod a
fmod :: FMod a => a -> a -> a

-- | Take fractional component(s). Always non-negative. You can use
--   <a>fracRF</a> for <a>RealFrac</a> types and <a>fracViaFmod</a> for
--   <tt>Fmod</tt> types.
class Frac a
frac :: Frac a => a -> a

-- | Fractional modulo. Useful for defining <a>fmod</a> on <a>RealFrac</a>
--   types.
fmodRF :: RealFrac a => a -> a -> a

-- | Fractional component. Useful for defining <a>frac</a> on
--   <a>RealFrac</a> types.
fracRF :: RealFrac a => a -> a

-- | Handy defining <a>fmod</a> on a <a>Frac</a> type.
fmodViaFrac :: (Fractional a, Frac a) => a -> a -> a

-- | Handy defining <a>frac</a> on a <a>FMod</a> type.
fracViaFmod :: (Num a, FMod a) => a -> a

-- | Clamp to a given range
clamp :: Ord a => (a, a) -> a -> a

-- | Variation on <a>clamp</a>, using <a>OrdB</a> instead of <a>Ord</a>
clampB :: (IfB bool a, OrdB bool a) => (a, a) -> a -> a

-- | Smooth, clamped transition
smoothStep :: (Ord a, Num a) => (a, a) -> a -> a

-- | Unary transformation (endomorphism)
type Unop a = a -> a

-- | Binary transformation
type Binop a = a -> a -> a

-- | Pad a string to the given length, adding spaces on the right as
--   needed.
padTo :: Int -> String -> String

-- | Move first argument to first place (for style uniformity)
flip1 :: (a -> b) -> (a -> b)

-- | Move second argument to first place (<a>flip</a> synonym for style
--   uniformity)
flip2 :: (a -> b -> c) -> (b -> a -> c)

-- | Move third argument to first place
flip3 :: (a -> b -> c -> d) -> (c -> a -> b -> d)

-- | Move fourth argument to first place
flip4 :: (a -> b -> c -> d -> e) -> (d -> a -> b -> c -> e)

-- | Sink of information
type Sink a = a -> Action

-- | Synonym for <tt>IO ()</tt>. Obviates some parentheses.
type Action = IO ()

-- | Combine sinks
(>+>) :: Sink a -> Sink b -> Sink (a, b)

-- | Discard a functor value.
forget :: Functor f => f a -> f ()
type R = Float
type EyePos = (R, R, R)
instance Frac s => Frac (u :> s)
instance Frac Float
instance FMod Float


-- | Experiment in length-typed vectors
module Shady.Vec

-- | Type-level representation of zero
data Z

-- | Type-level representation of successor
data S n

-- | Sum of type-level numbers
type ZeroT = Z
type OneT = S ZeroT
type TwoT = S OneT
type ThreeT = S TwoT
type FourT = S ThreeT
data Nat :: * -> *
Zero :: Nat Z
Succ :: Nat n -> Nat (S n)
zero :: Nat ZeroT
one :: Nat OneT
two :: Nat TwoT
three :: Nat ThreeT
four :: Nat FourT
withIsNat :: (IsNat n => Nat n -> a) -> (Nat n -> a)
natSucc :: Nat n -> Nat (S n)
natIsNat :: Nat n -> (IsNat n => Nat n)

-- | Interpret a <a>Nat</a> as an <a>Integer</a>
natToZ :: Nat n -> Integer

-- | Equality test
natEq :: Nat m -> Nat n -> Maybe (m :=: n)

-- | Sum of naturals
natAdd :: Nat m -> Nat n -> Nat (m :+: n)

-- | Proof that <tt>m &lt; n</tt>
data (:<:) m n

-- | A number under the given limit, with proof
data Index lim
Index :: (n :<: lim) -> (Nat n) -> Index lim
succI :: Index m -> Index (S m)
index0 :: Index (S n)
index1 :: Index (S (S n))
index2 :: Index (S (S (S n)))
index3 :: Index (S (S (S (S n))))

-- | Vectors with type-determined length, having empty vector (<a>ZVec</a>)
--   and vector cons ('(:&lt;)').
data Vec :: * -> * -> *
ZVec :: Vec Z a
(:<) :: a -> Vec n a -> Vec (S n) a

-- | <tt>n</tt> a vector length.
class IsNat n
nat :: IsNat n => Nat n
pureV :: IsNat n => a -> Vec n a
elemsV :: IsNat n => [a] -> Vec n a
peekV :: (IsNat n, Storable a) => Ptr a -> IO (Vec n a)
pokeV :: (IsNat n, Storable a) => Ptr a -> Sink (Vec n a)

-- | Concatenation of vectors
(<+>) :: Vec m a -> Vec n a -> Vec (m :+: n) a

-- | Indices under <tt>n</tt>: <a>index0</a> :&lt; <a>index1</a> :&lt; ...
indices :: Nat n -> Vec n (Index n)
type Zero = Vec ZeroT
type One = Vec OneT
type Two = Vec TwoT
type Three = Vec ThreeT
type Four = Vec FourT

-- | Enumerate the elements of a vector. See also <a>elemsV</a> vElems ::
--   Vec n a -&gt; [a] vElems ZVec = [] vElems (a :&lt; as) = a : vElems as
vElems :: Vec n a -> [a]
vec1 :: a -> One a
vec2 :: a -> a -> Two a
vec3 :: a -> a -> a -> Three a
vec4 :: a -> a -> a -> a -> Four a

-- | Extract element
un1 :: One a -> a

-- | Extract elements
un2 :: Two a -> (a, a)

-- | Extract elements
un3 :: Three a -> (a, a, a)

-- | Extract elements
un4 :: Four a -> (a, a, a, a)
get0 :: Vec (S n) a -> One a
get1 :: Vec (S (S n)) a -> One a
get2 :: Vec (S (S (S n))) a -> One a
get3 :: Vec (S (S (S (S n)))) a -> One a

-- | General indexing, taking a proof that the index is within bounds.
get :: Index n -> Vec n a -> One a

-- | Swizzling. Extract multiple elements simultaneously.
swizzle :: Vec n (Index m) -> Vec m a -> Vec n a
instance (IsNat n, Storable a) => Storable (Vec n a)
instance Ord a => Ord (Vec n a)
instance Eq a => Eq (Vec n a)
instance (IsNat n, Num a) => InnerSpace (Vec n a)
instance (IsNat n, Num a) => VectorSpace (Vec n a)
instance (IsNat n, Num a) => AdditiveGroup (Vec n a)
instance Foldable (Vec n)
instance IsNat n => Applicative (Vec n)
instance IsNat n => IsNat (S n)
instance IsNat Z
instance Functor (Vec n)
instance Eq (Index lim)
instance Show (Nat n)


-- | Name supply monad. Non-abstract synonym for <tt>State [String]</tt>
module Data.NameM
type NameM = State [String]
genName :: State [x] x
runNameM :: NameM a -> a
allNames :: [String]


-- | Pretty class with precedence
module Text.PrettyPrint.Leijen.PrettyPrec

-- | Pretty printing with precedence. A cross between <a>Show</a> and
--   <a>Pretty</a>. The <a>prettyPrec</a> method defaults to discarding the
--   context precedence and invoking <a>pretty</a>. The reason
--   <a>PrettyPrec</a> derives from Pretty is that so that this default is
--   possible.
--   
--   To make a <a>Show</a> instance for a <a>PrettyPrec</a> instance
--   <tt>Foo</tt>, define
--   
--   instance Show Foo where showsPrec p e = showsPrec p (prettyPrec p e)
class Pretty a => PrettyPrec a
prettyPrec :: PrettyPrec a => Int -> a -> Doc

-- | Convenient definition for <a>showsPrec</a> in a <a>Show</a> instance.
--   Uses ribbon fraction of 0.9 and width of 80. To set these values, use
--   <a>showsPretty'</a> instead. If you want to take precedence into
--   account, use <a>showsPrettyPrec</a> instead.
showsPretty :: Pretty a => Int -> a -> ShowS

-- | Convenient definition for <a>showsPrec</a> in a <a>Show</a> instance.
--   Arguments are ribbon fraction and line width. To get my defaults, use
--   <a>showsPretty</a> instead. Ignores precedence, which <a>Pretty</a>
--   doesn't understand. If you have a <a>PrettyPrec</a> instance, you can
--   use <a>showsPrettyPrec</a> instead.
showsPretty' :: Pretty a => Float -> Int -> Int -> a -> ShowS

-- | Convenient definition for <a>showsPrec</a> in a <a>Show</a> instance.
--   Uses ribbon fraction of 0.9 and width of 80. To set these values, use
--   <a>showsPrettyPrec'</a> instead. See also <a>showsPretty</a>.
showsPrettyPrec :: PrettyPrec a => Int -> a -> ShowS

-- | Convenient definition for <a>showsPrec</a> in a <a>Show</a> instance.
--   Arguments are ribbon fraction and line width. To get my defaults, use
--   <tt>showsPrettyPretty</tt> instead.
showsPrettyPrec' :: PrettyPrec a => Float -> Int -> Int -> a -> ShowS
instance Integral a => PrettyPrec (Ratio a)
instance PrettyPrec a => PrettyPrec (Maybe a)
instance (Pretty a, Pretty b, Pretty c) => PrettyPrec (a, b, c)
instance (Pretty a, Pretty b) => PrettyPrec (a, b)
instance Pretty a => PrettyPrec [a]
instance Integral a => Pretty (Ratio a)
instance PrettyPrec Double
instance PrettyPrec Float
instance PrettyPrec Integer
instance PrettyPrec Int
instance PrettyPrec Char
instance PrettyPrec Bool
instance PrettyPrec ()
instance PrettyPrec Doc


-- | Variation of Twan van Laarhoven's simple-reflect
--   <a>http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simple-reflect</a>
--   
--   Differences from Twan's version: + Generates pretty-printings instead
--   of strings + No evaluation + Removed overloadings that disagree with
--   semantic versions (e.g., '(==)') + A few stylistic tweaks
module Text.PrettyPrint.Leijen.DocExpr

-- | A reflected expression
data Expr
Expr :: (Int -> Doc) -> Expr

-- | Generate doc, given contextual precedence level
edoc :: Expr -> Int -> Doc

-- | Conversion from <a>Expr</a> to other types
class FromExpr a
fromExpr :: FromExpr a => Expr -> a
lift :: PrettyPrec a => a -> Expr

-- | A variable with the given name
var :: String -> Expr

-- | A generic, overloaded, function variable
fun :: FromExpr a => String -> a
apply :: Expr -> Expr -> Expr

-- | Function application
($$) :: Expr -> Expr -> Expr

-- | This data type specifies the associativity of operators: left, right
--   or none.
data Associativity
InfixL :: Associativity
Infix :: Associativity
InfixR :: Associativity

-- | An infix operator with the given associativity, precedence and name
op :: Associativity -> Int -> String -> Expr -> Expr -> Expr

-- | A lambda expression
lambdaX :: String -> Expr -> Expr

-- | A "let" expression
letX :: String -> Expr -> Expr -> Expr

-- | A tuple expression
tupleX :: [Expr] -> Expr

-- | C-style call
ccall :: String -> [Expr] -> Expr

-- | e.foo
dotX :: String -> Expr -> Expr

-- | Altering the generated Doc
onDoc :: (Doc -> Doc) -> (Expr -> Expr)
class Show a => HasExpr a
expr :: HasExpr a => a -> Expr
class HasExprU h
exprU :: HasExprU h => h a -> Expr

-- | Convenient for defining <a>PrettyPrec</a> when we have a
--   <a>HasExpr</a>.
prettyExpr :: HasExpr a => Int -> a -> Doc

-- | Variant of showParen
docParen :: Bool -> Doc -> Doc
instance Eq Associativity
instance Integral a => HasExpr (Ratio a)
instance (Show a, PrettyPrec a) => HasExpr (Maybe a)
instance (Show a, Show b, Show c, Pretty a, Pretty b, Pretty c) => HasExpr (a, b, c)
instance (Show a, Show b, Pretty a, Pretty b) => HasExpr (a, b)
instance (Show a, PrettyPrec a) => HasExpr [a]
instance HasExpr Double
instance HasExpr Float
instance HasExpr Integer
instance HasExpr Int
instance HasExpr Char
instance HasExpr Bool
instance HasExpr ()
instance HasExpr Doc
instance HasExpr Expr
instance Enum Expr
instance Floating Expr
instance Fractional Expr
instance Integral Expr
instance Real Expr
instance Num Expr
instance Ord Expr
instance Eq Expr
instance (PrettyPrec a, FromExpr b) => FromExpr (a -> b)
instance FromExpr Expr
instance Show Expr
instance PrettyPrec Expr
instance Pretty Expr


-- | Complex numbers. This version is modified from Data.Complex in base.
--   It eliminates the RealFloat requirement by using a more naive
--   definition of <a>magnitude</a>. Also, defines instances for
--   vector-space classes.
module Shady.Complex

-- | Complex numbers are an algebraic type.
--   
--   For a complex number <tt>z</tt>, <tt><a>abs</a> z</tt> is a number
--   with the magnitude of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the phase of
--   <tt>z</tt>, but unit magnitude.
data Complex a

-- | forms a complex number from its real and imaginary rectangular
--   components.
(:+) :: !a -> !a -> Complex a

-- | Extracts the real part of a complex number.
realPart :: Complex a -> a

-- | Extracts the imaginary part of a complex number.
imagPart :: Complex a -> a

-- | Form a complex number from polar components of magnitude and phase.
mkPolar :: Floating a => a -> a -> Complex a

-- | <tt><a>cis</a> t</tt> is a complex value with magnitude <tt>1</tt> and
--   phase <tt>t</tt> (modulo <tt>2*<a>pi</a></tt>).
cis :: Floating a => a -> Complex a

-- | The function <a>polar</a> takes a complex number and returns a
--   (magnitude, phase) pair in canonical form: the magnitude is
--   nonnegative, and the phase in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>; if the magnitude is zero, then so is the phase.
polar :: Floating a => Complex a -> (a, a)

-- | The phase of a complex number, in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>. If the magnitude is zero, then so is the phase.
phase :: Floating a => Complex a -> a

-- | The conjugate of a complex number.
conjugate :: Num a => Unop (Complex a)

-- | Operate on the real &amp; imaginary components
onRI :: Unop a -> Unop (Complex a)

-- | Operate on the real &amp; imaginary components
onRI2 :: Binop a -> Binop (Complex a)
instance Eq a => Eq (Complex a)
instance Show a => Show (Complex a)
instance Read a => Read (Complex a)
instance Data a => Data (Complex a)
instance FMod s => FMod (Complex s)
instance Frac s => Frac (Complex s)
instance HasExpr a => HasExpr (Complex a)
instance Floating a => Floating (Complex a)
instance Floating a => Fractional (Complex a)
instance Floating a => Num (Complex a)
instance Typeable1 Complex
instance Floating a => InnerSpace (Complex a)
instance Floating a => VectorSpace (Complex a)
instance Floating a => AdditiveGroup (Complex a)


-- | Types
module Shady.Language.Type
data ScalarT :: * -> *
Bool :: ScalarT Bool
Int :: ScalarT Int
Float :: ScalarT Float
data VectorT n a
VectorT :: (Nat n) -> (ScalarT a) -> VectorT n a

-- | Extended types. Vector types, samplers, unit, pairing, and functions.
data Type :: * -> *
VecT :: VectorT n a -> Type (Vec n a)
SamplerT :: Nat n -> Type (Sampler n)
UnitT :: Type ()
(:*:) :: Type a -> Type b -> Type (a, b)
(:->:) :: Type a -> Type b -> Type (a -> b)

-- | Encoding of texture ids in values. I'm using <a>Int</a> instead of
--   <tt>GLuint</tt> here to avoid depending on OpenGL in this module &amp;
--   package.
type TextureId = Int

-- | An <tt>n</tt>-dimensional GLSL sampler.
data Sampler n
Sampler :: Nat n -> TextureId -> Sampler n
samplerDim :: Sampler n -> Nat n
samplerTexture :: Sampler n -> TextureId
sampler1 :: TextureId -> Sampler1
sampler2 :: TextureId -> Sampler2
sampler3 :: TextureId -> Sampler3
type Sampler1 = Sampler OneT
type Sampler2 = Sampler TwoT
type Sampler3 = Sampler ThreeT

-- | Has scalar type
class (Storable a, Typeable a, Show a) => IsScalar a
scalarT :: IsScalar a => ScalarT a
vectorT :: (IsNat n, IsScalar a) => VectorT n a

-- | Known types
class Show t => HasType t
typeT :: HasType t => Type t

-- | Reify a type
typeOf :: HasType a => a -> Type a

-- | Reify a type argument
typeOf1 :: HasType a => f a -> Type a

-- | Reify a type argument's argument
typeOf2 :: HasType a => g (f a) -> Type a

-- | Do two values have the same type. If so, return a proof.
compatible :: (HasType a, HasType b) => a -> b -> Maybe (a :=: b)

-- | Do two values have the same argument type. If so, return a proof.
compatible1 :: (HasType a, HasType b) => f a -> g b -> Maybe (a :=: b)

-- | Demonstration that a type argument is a vector type.
data IsVec :: * -> *
IsVec :: IsVec (Vec n a)

-- | Check for a vector type
checkVec :: HasType t => Maybe (IsVec t)

-- | Convenient wrapper around <a>checkVec</a>. Ignores argument.
checkVec' :: HasType t => f t -> Maybe (IsVec t)

-- | Type equality proof
data (:=:) $a $b :: * -> * -> *
Refl :: :=: a a

-- | Try to prove equality of primitive types
ptyEq :: ScalarT a -> ScalarT b -> Maybe (a :=: b)

-- | Try to prove equality of types
vtyEq :: VectorT m a -> VectorT n b -> Maybe (Vec m a :=: Vec n b)

-- | Try to prove equality of types
tyEq :: Type c -> Type c' -> Maybe (c :=: c')

-- | Yields <a>Just</a> <a>Refl</a> if type-compatible <i>and</i> equal.
--   Otherwise <a>Nothing</a>.
(=:=) :: (HasType a, HasType b, SynEq f) => f a -> f b -> Maybe (a :=: b)

-- | Same type and syntactically equal
(===) :: (HasType a, HasType b, SynEq f) => f a -> f b -> Bool
type R = Float

-- | Convenient short-hand
type R1 = One R

-- | Convenient short-hand
type R2 = Two R

-- | Convenient short-hand
type R3 = Three R

-- | Convenient short-hand
type R4 = Four R

-- | Single boolean
type B1 = One Bool

-- | Unary predicate
type Pred1 a = a -> B1

-- | Binary predicate
type Pred2 a = a -> Pred1 a

-- | Syntactic equality. Requires same argument type.
class SynEq f
(=-=) :: (SynEq f, HasType c) => f c -> f c -> Bool

-- | Higher-order variant of <a>SynEq</a>. Can be defined via '(=-=)', or
--   vice versa.
class SynEq2 f
(=--=) :: (SynEq2 f, SynEq v, HasType c) => f v c -> f v c -> Bool
class PairF f
(#) :: (PairF f, HasType a, HasType b) => f a -> f b -> f (a :# b)

-- | Syntactic alternative for pairing. Convenient for right-associative
--   infix use.
type :# a b = (a, b)
class UnitF f
unit :: UnitF f => f ()
instance Eq a => Eq (Const a b)
instance (IsNat n, IsScalar a, FMod a) => FMod (Vec n a)
instance (IsNat n, IsScalar applicative_arg, RealFloat applicative_arg) => RealFloat (Vec n applicative_arg)
instance (IsNat n, IsScalar applicative_arg, RealFrac applicative_arg) => RealFrac (Vec n applicative_arg)
instance (IsNat n, IsScalar applicative_arg, Floating applicative_arg) => Floating (Vec n applicative_arg)
instance (IsNat n, IsScalar applicative_arg, Fractional applicative_arg) => Fractional (Vec n applicative_arg)
instance (IsNat n, IsScalar applicative_arg, Integral applicative_arg) => Integral (Vec n applicative_arg)
instance (IsNat n, IsScalar applicative_arg, Num applicative_arg, Ord applicative_arg) => Real (Vec n applicative_arg)
instance (IsNat n, IsScalar applicative_arg, Num applicative_arg) => Num (Vec n applicative_arg)
instance (IsNat n, IsScalar applicative_arg, Enum applicative_arg) => Enum (Vec n applicative_arg)
instance (IsNat n, IsScalar a, Show a) => HasExpr (Vec n a)
instance (IsNat n, IsScalar a, Pretty a) => PrettyPrec (Vec n a)
instance (IsNat n, IsScalar a, Show a) => Show (Vec n a)
instance (IsNat n, IsScalar a, Pretty a) => Pretty (Vec n a)
instance Eq x => SynEq (Const x)
instance IsNat n => HasType (Sampler n)
instance (HasType a, HasType b) => HasType (a -> b)
instance (HasType a, HasType b) => HasType (a, b)
instance HasType ()
instance (IsNat n, IsScalar a) => HasType (Vec n a)
instance IsScalar Float
instance IsScalar Int
instance IsScalar Bool
instance Show (Type t)
instance Pretty (Type t)
instance PrettyPrec (Type t)
instance HasExprU Type
instance HasExpr (Type t)
instance Pretty (Sampler n)
instance Show (Sampler n)
instance Pretty (VectorT n a)
instance HasExpr (VectorT n a)
instance HasExprU (VectorT n)
instance Show (VectorT n a)
instance HasExpr (ScalarT a)
instance Pretty (ScalarT a)
instance HasExprU ScalarT
instance Show (ScalarT a)


-- | Known constants
module Shady.Language.Operator
data Op :: * -> *
Lit :: a -> Op a
And :: Op (Binop (Vec n Bool))
Or :: Op (Binop (Vec n Bool))
Not :: Op (Unop (Vec n Bool))
EqualV :: Nat n -> Op (Vec n a -> Vec n a -> Vec n Bool)
AllV :: Op (Vec n Bool -> B1)
AnyV :: Op (Vec n Bool -> B1)
Equal :: Op (Pred2 (Vec n a))
Lt :: Nat n -> Op (Vec n a -> Vec n a -> Vec n Bool)
Le :: Nat n -> Op (Vec n a -> Vec n a -> Vec n Bool)
Min :: Op (Binop (Vec n a))
Max :: Op (Binop (Vec n a))
Negate :: Op (Unop (Vec n a))
Add :: Op (Binop (Vec n a))
Sub :: Op (Binop (Vec n a))
Mul :: Op (Binop (Vec n a))
Abs :: Op (Unop (Vec n a))
Signum :: Op (Unop (Vec n a))
Quot :: Op (Binop (Vec n a))
Rem :: Op (Binop (Vec n a))
Div :: Op (Binop (Vec n a))
Mod :: Op (Binop (Vec n a))
Recip :: Op (Unop (Vec n a))
Divide :: Op (Binop (Vec n a))
Sqrt :: Op (Unop (Vec n a))
Exp :: Op (Unop (Vec n a))
Log :: Op (Unop (Vec n a))
Sin :: Op (Unop (Vec n a))
Cos :: Op (Unop (Vec n a))
Asin :: Op (Unop (Vec n a))
Atan :: Op (Unop (Vec n a))
Acos :: Op (Unop (Vec n a))
Sinh :: Op (Unop (Vec n a))
Cosh :: Op (Unop (Vec n a))
Asinh :: Op (Unop (Vec n a))
Atanh :: Op (Unop (Vec n a))
Acosh :: Op (Unop (Vec n a))
Truncate :: Op (Unop (Vec n R))
Round :: Op (Unop (Vec n R))
Ceiling :: Op (Unop (Vec n R))
Floor :: Op (Unop (Vec n R))
FMod :: Op (Binop (Vec n a))
VVec2 :: Op (One a -> One a -> Two a)
VVec3 :: Op (One a -> One a -> One a -> Three a)
VVec4 :: Op (One a -> One a -> One a -> One a -> Four a)
Dot :: Op (Vec n R -> Vec n R -> R1)
Swizzle :: Vec n (Index m) -> Op (Vec m a -> Vec n a)
Unit :: Op ()
Pair :: Op (a -> b -> (a, b))
Fst :: Op ((a, b) -> a)
Snd :: Op ((a, b) -> b)
If :: Op (B1 -> Binop a)
Cat :: Nat m -> Nat n -> VectorT (m :+: n) a -> Op (Vec m a -> Vec n a -> Vec (m :+: n) a)
UniformV :: VectorT n a -> Op (One a -> Vec n a)
Scale :: Op (One a -> Unop (Vec n a))
Texture :: Nat n -> Op (Sampler n -> Vec n R -> R4)
data OpInfo a
OpInfo :: String -> a -> Fixity -> OpInfo a
oiName :: OpInfo a -> String
oiVal :: OpInfo a -> a
oiFix :: OpInfo a -> Fixity
info :: Op a -> OpInfo a

-- | Operator application
opExpr :: Op z -> [Expr] -> Expr
opVal :: Op a -> a
opEq :: Op a -> Op b -> Bool
instance SynEq Op
instance Show (Op t)


-- | Polymorphic memoization based using stable names.
module Data.PolyStableMemo
type :--> k v = forall a. (HasType a, Show a) => k a -> v a

-- | Pointer-based memoization. Evaluates keys to WHNF to improve hit rate.
memo :: (k :--> v) -> (k :--> v)


-- | Typed conglomerate of values
module Shady.Language.Glom

-- | Map a polymorphic function over a conglomerate (preserving structure).
--   The required laws are the same as with <a>Functor</a>.
class FunctorU q
fmapU :: FunctorU q => (forall a. f a -> g a) -> (forall a. q f a -> q g a)
class FunctorU m => MonadU m
returnU :: MonadU m => f a -> m f a
extendU :: MonadU m => (forall a. f a -> m g a) -> (forall a. m f a -> m g a)

-- | A typed conglomerate of values
data Glom f a
BaseG :: f a -> Glom f a
UnitG :: Glom f ()
(:*) :: Glom f a -> Glom f b -> Glom f (a, b)

-- | Fold over a <a>Glom</a>, given handlers for '(:*)', <a>UnitG</a>, and
--   <a>BaseG</a>, respectively.
foldG :: (c -> c -> c) -> c -> (forall b. f b -> c) -> Glom f a -> c

-- | Applicative/monadic map over a <a>Glom</a>.
mapAG :: Applicative m => (forall a. f a -> m (g a)) -> (forall a. Glom f a -> m (Glom g a))
instance (HasExpr a, HasExprU f) => Show (Glom f a)
instance (HasExpr a, HasExprU f) => Pretty (Glom f a)
instance (HasExpr a, HasExprU f) => PrettyPrec (Glom f a)
instance (HasExpr a, HasExprU f) => HasExpr (Glom f a)
instance HasExprU f => HasExprU (Glom f)
instance MonadU Glom
instance FunctorU Glom
instance PairF (Glom f)
instance UnitF (Glom f)


-- | Expressions.
module Shady.Language.Exp

-- | Variable name
type Id = String

-- | Typed variables
data V a
V :: Id -> Type a -> V a
varName :: V a -> Id
varType :: V a -> Type a

-- | Make a variable, inferring the type from context.
var :: HasType a => Id -> V a
genVar :: HasType a => NameM (V a)

-- | Variable patterns
type Pat = Glom V

-- | The type of a pattern
patT :: Pat a -> Type a

-- | Make a variable pattern, inferring the type from context.
pat :: HasType a => String -> Pat a

-- | Type path
data TPath

-- | Empty type path
emptyP :: TPath
fstP :: TPath -> TPath

-- | Extend a type path
sndP :: TPath -> TPath

-- | Augment a variable name with a type path
namePath :: String -> TPath -> String

-- | Simple expressions (no <tt>Let</tt>). Statically typed. Constructors
--   for operator/constant (<a>Op</a>), variable (<a>Var</a>), application
--   ('(:^)'), and abstraction (<a>Lam</a>).
data E :: * -> *
Op :: Op a -> E a
Var :: V a -> E a
(:^) :: E (a -> b) -> E a -> E b
Lam :: V a -> E b -> E (a -> b)

-- | Function from expressions. Nestable.
type :=> a b = E a -> b

-- | Expression to expression. Ends a chain of '(:=&gt;)'
type :=>* a b = a :=> E b

-- | Convenient operator application
op1 :: (HasType a, HasType b) => Op (a -> b) -> a :=>* b

-- | Convenient operator application
op2 :: (HasType a, HasType b, HasType c) => Op (a -> b -> c) -> a :=> (b :=>* c)

-- | Convenient operator application
op3 :: (HasType a, HasType b, HasType c, HasType d) => Op (a -> b -> c -> d) -> a :=> (b :=> (c :=>* d))

-- | Convenient operator application
op4 :: (HasType a, HasType b, HasType c, HasType d, HasType e) => Op (a -> b -> c -> d -> e) -> a :=> (b :=> (c :=> (d :=>* e)))

-- | Literal expression
pureE :: Show a => a -> E a

-- | Apply a unary operator, with constant-folding and simplifications
fmapE :: (HasType a, HasType b) => Op (a -> b) -> a :=>* b

-- | Apply a binary operator, with constant-folding and simplifications
liftE2 :: (HasType a, HasType b, HasType c) => Op (a -> b -> c) -> a :=> (b :=>* c)

-- | Apply a ternary operator, with constant-folding and simplifications
liftE3 :: (HasType a, HasType b, HasType c, HasType d) => Op (a -> b -> c -> d) -> a :=> (b :=> (c :=>* d))

-- | Apply an quaternary operator, with constant-folding and
--   simplifications
liftE4 :: (HasType a, HasType b, HasType c, HasType d, HasType e) => Op (a -> b -> c -> d -> e) -> a :=> (b :=> (c :=> (d :=>* e)))

-- | Transitional synonym for notB
notE :: IsNat n => Vec n Bool :=>* Vec n Bool

-- | Vector equality, resulting in a single Bool. See also '(==*)'.
(==^) :: (IsNat n, IsScalar a, Eq a, Show a) => Vec n a :=> (Vec n a :=>* B1)

-- | Vector inequality, resulting in a single Bool. See also '(/=*)'.
(/=^) :: (IsNat n, IsScalar a, Eq a, Show a) => Vec n a :=> (Vec n a :=>* B1)
truncateE :: IsNat n => Vec n R :=>* Vec n R
roundE :: IsNat n => Vec n R :=>* Vec n R
ceilingE :: IsNat n => Vec n R :=>* Vec n R
floorE :: IsNat n => Vec n R :=>* Vec n R

-- | Are all of the <a>Bool</a>s true?
allV :: IsNat n => Vec n Bool :=>* B1

-- | Is all of the <a>Bool</a>s true?
anyV :: IsNat n => Vec n Bool :=>* B1
type SamplerE n = E (Sampler n)

-- | Texturing
texture :: IsNat n => Sampler n :=> (Vec n R :=>* R4)

-- | Literal value
lit :: Show a => a -> E a

-- | <a>Bool</a>
type BoolE = E B1

-- | <a>Float</a> expression
type FloatE = E R1
type R1E = E R1
type R2E = E R2
type R3E = E R3
type R4E = E R4

-- | Expression vector
type VecE n a = E (Vec n a)
vec2 :: (IsScalar a, Show a) => One a :=> (One a :=>* Two a)
vec3 :: (IsScalar a, Show a) => One a :=> (One a :=> (One a :=>* Three a))
vec4 :: (IsScalar a, Show a) => One a :=> (One a :=> (One a :=> (One a :=>* Four a)))
un2 :: IsScalar a => Two a :=> (E (One a), E (One a))
un3 :: IsScalar a => Three a :=> (E (One a), E (One a), E (One a))
un4 :: IsScalar a => Four a :=> (E (One a), E (One a), E (One a), E (One a))

-- | Extract X component
getX :: (IsNat n, IsScalar a, Show a) => Vec (S n) a :=>* One a

-- | Extract Y component
getY :: (IsNat n, IsScalar a, Show a) => Vec (S (S n)) a :=>* One a

-- | Extract Z component
getZ :: (IsNat n, IsScalar a, Show a) => Vec (S (S (S n))) a :=>* One a

-- | Extract W component
getW :: (IsNat n, IsScalar a, Show a) => Vec (S (S (S (S n)))) a :=>* One a

-- | Extract vector component
get :: (IsNat n, IsScalar a, Show a) => Index n -> (Vec n a) :=>* One a

-- | Concatenation of vectors
(<+>) :: (IsNat m, IsNat n, IsNat (m :+: n), IsScalar a, Show a) => Vec m a :=> (Vec n a :=>* Vec (m :+: n) a)

-- | Expression-lifted '()'
unitE :: E ()

-- | Expression-lifted '(,)'
pairE :: (HasType a, HasType b) => E a -> E b -> E (a, b)

-- | Expression-lifted <a>fst</a>
fstE :: (HasType a, HasType b) => Show a => E (a, b) -> E a

-- | Expression-lifted <a>snd</a>
sndE :: (HasType a, HasType b) => Show b => E (a, b) -> E b

-- | Unpack a pair
unPairE :: (HasType a, HasType b) => E (a, b) -> (E a, E b)

-- | Uniform version of a function on vectors
uniform :: (IsNat n, IsScalar a, Show a) => (E (Vec n a) -> b) -> (E (One a) -> b)

-- | Uniform vector
uniformV :: (IsNat n, IsScalar a, Show a) => One a :=>* Vec n a

-- | Complex-valued expressions
type ComplexE a = Complex (E (One a))

-- | Value convertible to an expression
class ToE w where { type family ExpT w; }
toEN :: ToE w => w -> NameM (E (ExpT w))

-- | Convert to an expression, using fresh name supply
toE :: ToE w => w -> E (ExpT w)

-- | Value convertible from an expression
class ToE w => FromE w
fromE :: FromE w => E (ExpT w) -> w

-- | Construct an <a>E</a> transformer from an <a>ExpT</a> transformer
toFromE :: (FromE v, FromE w) => (v -> w) -> (E (ExpT v) -> E (ExpT w))

-- | Turn a pattern into an expression.
patE :: Pat a -> E a

-- | Short-hand for beta-redex
letE :: (HasType a, HasType b) => V a -> E a -> E b -> E b
instance Monad First
instance Applicative First
instance Functor First
instance Show (V a)
instance (Show a, IsScalar a) => FromE (ComplexE a)
instance (Show a, IsScalar a) => ToE (ComplexE a)
instance ToE (Pat a)
instance (FromE u, ToE v, HasType (ExpT u)) => ToE (u -> v)
instance (FromE u, HasType (ExpT u), FromE v, HasType (ExpT v), FromE w, HasType (ExpT w)) => FromE (u, v, w)
instance (ToE u, HasType (ExpT u), ToE v, HasType (ExpT v), ToE w, HasType (ExpT w)) => ToE (u, v, w)
instance (FromE u, HasType (ExpT u), FromE v, HasType (ExpT v)) => FromE (u, v)
instance (ToE u, Show (ExpT u), HasType (ExpT u), ToE v, Show (ExpT v), HasType (ExpT v)) => ToE (u, v)
instance FromE ()
instance ToE ()
instance FromE (E a)
instance ToE (E a)
instance IsNat n => InnerSpace (E (Vec n R))
instance (IsNat n, IsScalar a, Num a) => VectorSpace (E (Vec n a))
instance (IsNat n, IsScalar a, Num a) => AdditiveGroup (E (Vec n a))
instance PairF E
instance UnitF E
instance (IsNat n, IsScalar a, FMod a, RealFrac a) => Frac (E (Vec n a))
instance (IsNat n, IsScalar a, FMod a) => FMod (E (Vec n a))
instance (IsNat n, IsScalar b, RealFrac b) => RealFrac (E (Vec n b))
instance (IsNat n, IsScalar b, Floating b) => Floating (E (Vec n b))
instance (IsNat n, IsScalar b, Fractional b) => Fractional (E (Vec n b))
instance (IsNat n, IsScalar b, Integral b) => Integral (E (Vec n b))
instance (IsNat n, IsScalar a, Ord a, Num a) => Real (E (Vec n a))
instance (IsNat n, IsScalar a, Num a) => Num (E (Vec n a))
instance Enum a => Enum (E a)
instance (IsNat n, IsScalar a, Ord a, Show a) => OrdB (VecE n Bool) (VecE n a)
instance (IsNat n, IsScalar a, Eq a, Show a) => EqB (VecE n Bool) (VecE n a)
instance (IsNat n, IsScalar a, Show a) => IfB BoolE (VecE n a)
instance IsNat n => Boolean (VecE n Bool)
instance (IsNat n, IsScalar a, Ord a, Show a) => Ord (E (Vec n a))
instance Eq (E a)
instance Show (E a)
instance Pretty (E a)
instance PrettyPrec (E a)
instance HasExpr (E a)
instance SynEq E
instance HasExpr a => Pretty (V a)
instance HasExpr a => PrettyPrec (V a)
instance HasExpr a => HasExpr (V a)
instance HasExprU V
instance SynEq V


-- | Based on a typed variant of Andy Gill's data-reify. After several
--   tries, I wasn't able to reuse data-reify or my typed variant of it.
--   The problem was that I need my <a>HasType</a> class and <a>Type</a>
--   type, but I couldn't parameterize data-reify by the <i>class</i>
--   <a>HasType</a>.
module Shady.Language.Graph

-- | Node Identifiers
type NodeId = Int

-- | Typed variables
data Tid a
Tid :: NodeId -> (Type a) -> Tid a
data N :: * -> *
VN :: V a -> N a
ON :: Op a -> N a
App :: Tid (a -> b) -> Tid a -> N b
mapDeRef :: Applicative m => (forall a. HasType a => E a -> m NodeId) -> (forall a. HasType a => E a -> m (N a))

-- | Binding pair
data Bind
Bind :: NodeId -> (N a) -> Bind

-- | Graph, described by bindings and a root variable
data Graph a
Graph :: [Bind] -> (Tid a) -> Graph a
instance Show (Graph a)
instance Show Bind
instance Show (N a)
instance Show (Tid a)
instance Eq (Tid a)


-- | Discover representation sharing in expressions Variation on Andy
--   Gill's Data.Reify.
module Shady.Language.Reify

-- | <a>reifyGraph</a> takes a data structure that admits <tt>MuRef</tt>,
--   and returns a <a>Graph</a> that contains the dereferenced nodes, with
--   their children as integers rather than recursive values.
reifyGraph :: HasType a => E a -> IO (Graph a)


-- | Common subexpression elimination.
--   
--   TODO: Improve variable names (now "x8" etc).
module Shady.Language.Cse

-- | Common subexpression elimination. Use with care, since it breaks
--   referential transparency on the <i>representation</i> of expressions,
--   but not on their meaning.
cse :: HasType a => E a -> E a


-- | Experiments with sharing recovery on GADT-based expression
--   representations.
module Shady.Language.Share
cse :: HasType a => E a -> E a
instance Ord TExp
instance Eq TExp
instance Show TExp


-- | Test new CSE stuff
module Shady.Play.CseTest
x :: HasExpr a => a -> Expr
type Point = ComplexE R
q :: FloatE
t2 :: FloatE
t1 :: FloatE
a1 :: FloatE
t :: FloatE
v :: FloatE
u :: FloatE
uv :: Point


-- | Test auto vectorization
module Shady.Play.VectorTest
x :: HasExpr a => a -> Expr
m :: FloatE
n :: FloatE
l :: FloatE
r :: R2E
q :: R2E


-- | Abstract syntax for GLSL. Evolving.
module Shady.Language.GLSL

-- | Program: Vertex shader and Fragment shader
data Program
P :: Shader -> Shader -> Program
pVertex :: Program -> Shader
pFragment :: Program -> Shader

-- | Shader
data Shader
Sh :: [Declaration] -> [Definition] -> Shader

-- | Variable declaration/initialization.
data Declaration
D :: [Qualifier] -> (Pat a) -> Declaration

-- | Top-level definition
data Definition
F :: (Maybe (VectorT n a)) -> Id -> [Param] -> Statement -> Definition
data VectorT n a
VectorT :: (Nat n) -> (ScalarT a) -> VectorT n a
data ScalarT :: * -> *
Bool :: ScalarT Bool
Int :: ScalarT Int
Float :: ScalarT Float

-- | formal parameter
data Param
M :: (VectorT n a) -> Id -> Param

-- | Variable name
type Id = String

-- | Variable binding
data Bind
B :: (Pat a) -> (E a) -> Bind

-- | Statement
data Statement
Assign :: Bind -> Statement
LetS :: Bind -> Statement -> Statement
SkipS :: Statement
ThenS :: Statement -> Statement -> Statement

-- | Storage qualifier
data Qualifier
Uniform :: Qualifier
Attribute :: Qualifier
Varying :: Qualifier

-- | Binding with open (exposed) type. Build with '(=::)' and '(#)'.
data BindO a

-- | <a>V</a> specialization of '(=:)'.
(=::) :: HasType a => V a -> E a -> BindO a

-- | Close an open binding
closeB :: HasType a => BindO a -> Statement

-- | Assignment statement
(=:) :: HasType a => Pat a -> E a -> Statement

-- | The standard gl_Position variable, which must be set in a vertex
--   shader
glPosition :: Pat R4

-- | The standard gl_FragColor variable, which must be set in a fragment
--   shader
glFragColor :: Pat R4

-- | Transform a vertex using the standard model/view matrix
vTrans :: E R4 -> E R4

-- | Transform a normal using the standard normal matrix
nTrans :: E R3 -> E R3

-- | <tt>main</tt> in a shader program.
mainDef :: Statement -> Definition
instance Show Qualifier
instance Eq Qualifier
instance Show Program
instance Show Shader
instance Show Definition
instance Show Param
instance Show Declaration
instance Show Statement
instance Show Bind
instance PairF BindO
instance Pretty Program
instance Pretty Shader
instance Pretty Definition
instance Pretty Param
instance Pretty Declaration
instance Pretty Qualifier
instance Pretty Statement
instance Pretty Bind
instance Monoid Statement


-- | Generate and compile vertex and fragment shaders.
--   
--   In this version, shader programs are represented by functions function
--   a single expression to a single expression. See also CompileEs, which
--   allows functions between more flexible representations.
module Shady.CompileE

-- | For gl_Position
type Pos = R4

-- | For building vertex/fragment shader pairs. The idea is that a complete
--   parameterized shader program has type <tt>u :=&gt; a :- v :--&gt;
--   o</tt>, which expands to <tt>u :=&gt; (a :-^&gt; v, v :-* o)</tt>.
--   
--   u == uniform, a == (vertex) attribute, v == varying, o == fragment
--   output.
--   
--   When <tt>o == ()</tt> (color-only output), use the short-hand <tt>u
--   :=&gt; a :-&gt; v</tt>.
--   
--   General vertex/fragment shader pair.
data (:->) a o
ShaderVF :: (a :-^ v) -> (v :-* o) -> :-> a o

-- | Vertex/fragment pair with no extra output besides color
type ShaderVF a = a :-> ()

-- | GLSL vertex program, fragment program, uniform and vertex attribute.
data GLSL u a
GLSL :: String -> String -> (Pat u) -> (Pat a) -> GLSL u a

-- | Compile a parameterized shader program. TODO: generalize to non-()
--   outputs, i.e., to <tt>u :=&gt; a :-&gt; o</tt>.
shaderProgram :: (HasType a, HasExpr a, HasType u, HasExpr u) => (u :=> ShaderVF a) -> GLSL u a
instance (HasExpr u, HasExpr a) => Show (GLSL u a)
instance (HasExpr u, HasExpr a) => Pretty (GLSL u a)


-- | Generate and compile vertex and fragment shaders. Unlike
--   <a>Shady.CompileE</a>, this version allows a looser structure to the
--   inputs &amp; outputs of shaders, according to <a>FromE</a>. You can
--   use the types and <tt>compile</tt> in this module, or just
--   <a>shaders</a>, along with <a>Shady.CompileE</a>, e.g., <tt>compile
--   (shaders sh)</tt>.
module Shady.CompileEs

-- | Convert loosely structured shaders into single-exp shader
shaders :: (FromE u', FromE a', FromE o') => (o ~ (ExpT o'), a ~ (ExpT a'), u ~ (ExpT u')) => (HasExpr o, HasType o, Show o) => (u' -> (a' :-> o')) -> u :=> (a :-> o)

-- | For gl_Position
type Pos = R4

-- | General vertex/fragment shader pair.
data (:->) a' o'
ShaderVF :: (a' :-^ v') -> (v' :-* o') -> :-> a' o'

-- | Vertex/fragment pair with no extra output besides color
type ShaderVF a' = a' :-> ()

-- | GLSL vertex program, fragment program, uniform and vertex attribute.
data GLSL u a

-- | Compile a parameterized shader program. TODO: generalize to non-()
--   outputs, i.e., to <tt>u :=&gt; a :-&gt; o</tt>.
shaderProgram :: (FromE u', u ~ (ExpT u'), FromE a', a ~ (ExpT a')) => (HasType a, HasExpr a, HasType u, HasExpr u) => (u' -> ShaderVF a') -> GLSL u a
