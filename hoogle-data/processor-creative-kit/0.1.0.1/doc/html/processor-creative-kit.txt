-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a creation kit for instruction sets and cpu simulators and development tools
--   
@package processor-creative-kit
@version 0.1.0.1

module Language.Pck.Cpu.Config

-- | the cpu configuration type
data CpuConfig
CpuConfig :: Int -> Int -> Int -> Int -> Int -> CpuConfig

-- | boot(start) pc
cfgStartPc :: CpuConfig -> Int

-- | instruction memory start address
cfgImemStart :: CpuConfig -> Int

-- | instruction memory size
cfgImemSize :: CpuConfig -> Int

-- | data memory start address
cfgDmemStart :: CpuConfig -> Int

-- | data memory size
cfgDmemSize :: CpuConfig -> Int

-- | the default configuration
--   
--   You can change the configuration here.
cpuConfig :: CpuConfig

module Language.Pck.Cpu.Instruction

-- | the instruction definition.
--   
--   You can create instructions as you like :-)
--   
--   Operand order is Intel, ARM, MIPS, PowerPC,... order. (opcode dst src1
--   src2)
data Inst

-- | no operation
NOP :: Inst

-- | halt (stop the processor)
HALT :: Inst

-- | GReg &lt;- Int
MOVI :: GReg -> Int -> Inst

-- | GReg &lt;- GReg
MOV :: GReg -> GReg -> Inst

-- | GReg &lt;- PC
MOVPC :: GReg -> Inst

-- | GReg &lt;- GReg + GReg
ADD :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg - GReg
SUB :: GReg -> GReg -> GReg -> Inst

-- | Flag &lt;- compare(GReg, GReg)
CMP :: GReg -> GReg -> Inst

-- | GReg &lt;- abs(GReg)
ABS :: GReg -> GReg -> Inst

-- | GReg &lt;- GReg &lt;&lt; GReg // arithmetic shift
ASH :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg * GReg
MUL :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg / GReg
DIV :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg &amp; GReg
AND :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg | GReg
OR :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- ~GReg
NOT :: GReg -> GReg -> Inst

-- | GReg &lt;- GReg ^ GReg
XOR :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg &lt;&lt; GReg // logical shift
LSH :: GReg -> GReg -> GReg -> Inst

-- | if (FCond(Flag)) goto (PC + Int) // pc relative addressing
BRI :: FCond -> Int -> Inst

-- | goto (PC + Int) // pc relative addressing
JRI :: Int -> Inst

-- | goto GReg // absolute addressing
J :: GReg -> Inst

-- | goto GReg; R0 &lt;- PC // absolute addressing
CALL :: GReg -> Inst

-- | goto R0
RET :: Inst

-- | GReg &lt;- memory(GReg)
LD :: GReg -> GReg -> Inst

-- | memory(GReg) &lt;- GReg
ST :: GReg -> GReg -> Inst

-- | undefined
UNDEF :: Inst

-- | the general purpose registers.
--   
--   You can create registers as you like :-)
data GReg
R0 :: GReg
R1 :: GReg
R2 :: GReg
R3 :: GReg
R4 :: GReg
R5 :: GReg
R6 :: GReg
R7 :: GReg

-- | the Flag conditions
data FCond

-- | equal
FCEQ :: FCond

-- | not equal
FCNE :: FCond

-- | little than
FCLT :: FCond

-- | little equal
FCLE :: FCond

-- | greater than
FCGT :: FCond

-- | greater equal
FCGE :: FCond
instance Show GReg
instance Eq GReg
instance Ord GReg
instance Ix GReg
instance Enum GReg
instance Bounded GReg
instance Show FCond
instance Eq FCond
instance Show Inst
instance Eq Inst
instance NFData Inst

module Language.Pck.Cpu.Memory

-- | the instruction memory image
--   
--   <pre>
--   [(StartAddress, [Instruction1,  Instruction2, ...])]
--   </pre>
--   
--   Example:
--   
--   <pre>
--   [(0, [MOVI R1 0,  LD R0 R1,  HALT])]
--   </pre>
type InstImage = [(IAddress, [Inst])]

-- | the data memory image
--   
--   <pre>
--   [(StartAddress, [Data1,  Data2, ...])]
--   </pre>
--   
--   Example:
--   
--   <pre>
--   [(0, [1, 5, 7, 0x20])]
--   </pre>
type DataImage = [(DAddress, [DValue])]

-- | the instruction memory array
type ImemArray = Array IAddress Inst

-- | the data memory array
type DmemArray = Array DAddress DValue
type IAddress = Int
type DAddress = Int
type DValue = Int

-- | initialize the instruction memory
initImem :: ImemArray

-- | preset the instruction memory
presetImem :: InstImage -> ImemArray

-- | modify the instruction memory
modifyImems :: ImemArray -> (IAddress, [Inst]) -> ImemArray

-- | fetch an instruction from the instruction memory
fetchImem :: ImemArray -> IAddress -> Inst

-- | get an instruction memory image
getInstImage :: ImemArray -> InstImage

-- | extract instructions from the instruction memory
extractImems :: InstImage -> IAddress -> Int -> [Inst]

-- | initialize the data memory
initDmem :: DmemArray

-- | preset the data memory
presetDmem :: DataImage -> DmemArray

-- | get a data from the data memory
getDmem :: DmemArray -> DAddress -> DValue

-- | modify the data memory
modifyDmem :: DmemArray -> DAddress -> DValue -> DmemArray

-- | modify the data memory by values
modifyDmems :: DmemArray -> (DAddress, [DValue]) -> DmemArray

-- | get a data memory image
getDataImage :: DmemArray -> DataImage

-- | extract data values from the data memory
extractDmems :: DataImage -> DAddress -> Int -> [DValue]

module Language.Pck.Cpu.Register
type GRegArray = Array GReg Int
data Flag

-- | zero flag
FLZ :: Flag

-- | carry flag
FLC :: Flag
type FlagArray = Array Flag Bool

-- | initialize the general purpose registers array
initGReg :: GRegArray

-- | get a value of the general purpose register
getGReg :: GRegArray -> GReg -> Int

-- | get values of the general purpose register pair
getGReg2 :: GRegArray -> GReg -> GReg -> (Int, Int)

-- | get all values of the general purpose registers
getGRegs :: GRegArray -> [Int]

-- | modify general purpose registers
modifyGReg :: GRegArray -> GReg -> Int -> GRegArray

-- | initialize the flag registers array
initFlag :: FlagArray

-- | get a value of the flag register value
getFlag :: FlagArray -> Flag -> Bool

-- | get all values of the flag registers
getFlags :: FlagArray -> [Bool]

-- | modify flag registers
modifyFlag :: FlagArray -> Flag -> Bool -> FlagArray

-- | judge a flag condition
judgeFCond :: FlagArray -> FCond -> Bool
instance Show Flag
instance Eq Flag
instance Ord Flag
instance Ix Flag
instance Enum Flag
instance Bounded Flag

module Language.Pck.Cpu.State

-- | the cpu eval monad
type EvalCpu a = State CpuState a

-- | the cpu state (processor internal state)
--   
--   This is the result type from <a>run</a> function.
--   
--   get each values by <a>pcFromCpuState</a>, <a>grFromCpuState</a>,
--   <a>flFromCpuState</a>, <a>imemFromCpuState</a>,
--   <a>dmemFromCpuState</a>, <a>dumpCpuState</a>
data CpuState

-- | <pre>
--   &gt; pcFromCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   1
--   </pre>
pcFromCpuState :: CpuState -> Int

-- | <pre>
--   &gt; grFromCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   [7,0,0,0,0,0,0,0]
--   </pre>
grFromCpuState :: CpuState -> [Int]

-- | <pre>
--   &gt; flFromCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   [False,False]
--   </pre>
flFromCpuState :: CpuState -> [Bool]

-- | <pre>
--   &gt; imemFromCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   [(0,[MOVI R0 7,HALT,UNDEF,UNDEF,...])]
--   </pre>
imemFromCpuState :: CpuState -> InstImage

-- | <pre>
--   &gt; dmemFromCpuState $ run [(0,[MOVI R0 0, MOVI R1 10, ST R0 R1, HALT])] []
--   [(0,[10,0,0,0,0,...])]
--   </pre>
dmemFromCpuState :: CpuState -> DataImage

-- | dump Cpu state (without instruction image)
--   
--   <pre>
--   &gt; putStr $ dumpCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   pc : 1
--   gr : [7,0,0,0,0,0,0,0]
--   fl : [False,False]
--   dm : [(0,[7,0,0,0,0,...])]
--   </pre>
dumpCpuState :: CpuState -> String

-- | a default CpuState
initCpuState :: CpuState

-- | initialize CpuState by inst and data image
initCpuStateMem :: InstImage -> DataImage -> CpuState

-- | the result state
data ResultStat

-- | normal result
RsNormal :: ResultStat

-- | cpu halt(stop)
RsHalt :: ResultStat

-- | debugger triggered
RsDbgBrk :: ResultStat

-- | execution error
RsErr :: String -> ResultStat

-- | read the pc
readPc :: EvalCpu Int

-- | update the pc
--   
--   Example:
--   
--   <pre>
--   jumpRI :: Int -&gt; EvalCpu ResultStat
--   jumpRI ad = do pc &lt;- readPc
--                  updatePc (pc + ad)
--   </pre>
updatePc :: Int -> EvalCpu ResultStat

-- | increment the pc
incPc :: EvalCpu ResultStat

-- | read a general purpose register
--   
--   Example:
--   
--   <pre>
--   jump :: GReg -&gt; EvalCpu ResultStat
--   jump reg = do ad &lt;- readGReg reg
--                 updatePc ad
--   </pre>
readGReg :: GReg -> EvalCpu Int

-- | read general purpose register pair
readGReg2 :: GReg -> GReg -> EvalCpu (Int, Int)

-- | update a general purpose register
--   
--   Example:
--   
--   <pre>
--   movpc :: GReg -&gt; EvalCpu ResultStat
--   movpc reg = do pc &lt;- readPc
--                  updateGReg reg pc
--   </pre>
updateGReg :: GReg -> Int -> EvalCpu ()

-- | read flag registers
--   
--   Example:
--   
--   <pre>
--   branchRI :: FCond -&gt; Int -&gt; EvalCpu ResultStat
--   branchRI fcond ad  = do flags &lt;- readFlags
--                           if judgeFCond flags fcond
--                              then jumpRI ad
--                              else incPc
--   </pre>
readFlags :: EvalCpu FlagArray

-- | update a flag
--   
--   Example:
--   
--   <pre>
--   cmpRR :: GReg -&gt; GReg -&gt; EvalCpu ResultStat
--   cmpRR ra rb = do (ra', rb') &lt;- readGReg2 ra rb
--                    updateFlag FLZ (ra' == rb')
--                    updateFlag FLC (ra' &lt;  rb')
--   </pre>
updateFlag :: Flag -> Bool -> EvalCpu ()

-- | fetch an instruction from the instruction memory
fetchInst :: EvalCpu Inst

-- | read a data value from the data memory
--   
--   Example:
--   
--   <pre>
--   load :: GReg -&gt; GReg -&gt; EvalCpu ResultStat
--   load ra rb = do rb' &lt;- readGReg rb
--                   ra' &lt;- readDmem rb'
--                   updateGReg ra ra'
--   </pre>
readDmem :: Int -> EvalCpu Int

-- | update the data memory
--   
--   Example:
--   
--   <pre>
--   store :: GReg -&gt; GReg -&gt; EvalCpu ResultStat
--   store ra rb = do (ra', rb') &lt;- readGReg2 ra rb
--                    updateDmem ra' rb' 
--   </pre>
updateDmem :: Int -> Int -> EvalCpu ()
instance Show ResultStat
instance Eq ResultStat
instance Eq CpuState
instance Show CpuState

module Language.Pck.Cpu.Execution

-- | run the processor
--   
--   Example: simple run
--   
--   <pre>
--   &gt; run [(0, [MOVI R0 20, HALT])] []
--   pc : 1
--   gr : [20,0,0,0,0,0,0,0]
--   fl : [False,False]
--   ...
--   </pre>
--   
--   Example: run with initial data
--   
--   <pre>
--   &gt; run [(0, [MOVI R1 0, LD R0 R1, HALT])] [(0,[100])]
--   pc : 2
--   gr : [100,0,0,0,0,0,0,0]
--   fl : [False,False]
--   ...
--   </pre>
run :: InstImage -> DataImage -> CpuState

-- | evaluate a program
--   
--   <pre>
--   run :: InstImage -&gt; DataImage -&gt; CpuState
--   run insts vals = execState (evalProg False) (initCpuStateMem insts vals)
--   </pre>
evalProg :: Bool -> EvalCpu ResultStat

module Language.Pck.Tool.Assembler

-- | parse instructions from a ByteString data
--   
--   Example:
--   
--   <pre>
--   &gt; parseInst (B.pack "mov r0,1\n halt\n")
--   [MOVI R0 1,HALT]
--   </pre>
parseInst :: ByteString -> Either [String] [Inst]

-- | parse instructions from a file
--   
--   Example:
--   
--   <pre>
--   &gt; parseInstFile "examples/test0.asm"
--   [MOVI R0 1,HALT]
--   </pre>
parseInstFile :: FilePath -> IO [Inst]

module Language.Pck.Tool.Debugger

-- | debugging run
--   
--   Example: run with a break condition. (break at pc == 1)
--   
--   <pre>
--   &gt; runDbg [] [(BrkPc BEQ 1)] [(0,[MOVI R0 7, MOVI R1 8, HALT])] []
--   pc : 1
--   gr : [7,0,0,0,0,0,0,0]
--   fl : [False,False]
--   </pre>
--   
--   Example: run with trace output. (instruction trace)
--   
--   <pre>
--   &gt; runDbg [TrcInst] [] [(0,[MOVI R0 7, MOVI R1 8, HALT])] []
--   TrcInst:        pc : 0  MOVI R0 7
--   
--   TrcInst:        pc : 1  MOVI R1 8
--   
--   TrcInst:        pc : 2  HALT
--   </pre>
runDbg :: [DbgTrc] -> [DbgBrk] -> InstImage -> DataImage -> (TrcLog, CpuState)

-- | debugging run for IO output
--   
--   Example: run with trace output. (instruction trace)
--   
--   <pre>
--   &gt; runDbgIO [TrcInst] [] [(0,[MOVI R0 7, MOVI R1 8, HALT])] []
--   TrcInst:        pc : 0  MOVI R0 7
--   
--   TrcInst:        pc : 1  MOVI R1 8
--   
--   TrcInst:        pc : 2  HALT
--   </pre>
runDbgIO :: [DbgTrc] -> [DbgBrk] -> InstImage -> DataImage -> IO ()
evalProgDbg :: [DbgTrc] -> [DbgBrk] -> EvalCpu TrcLog

-- | data type for <a>runDbg</a> log
type TrcLog = ByteString

-- | trace conditions for <a>runDbg</a> or <a>runDbgIO</a>
data DbgTrc

-- | trace instructions
TrcInst :: DbgTrc

-- | trace registers
TrcReg :: DbgTrc

-- | trace pc
TrcPc :: DbgTrc

-- | trace call target address
TrcCall :: DbgTrc

-- | trace branch information
TrcBranch :: DbgTrc

-- | trace memory load
TrcLoad :: DbgTrc

-- | trace memory store
TrcStore :: DbgTrc

-- | break conditions
--   
--   Example:
--   
--   <pre>
--   BrkPc BEQ 3          -- pc == 3
--   BrkPc BGE 0x80       -- pc &gt;= 0x80
--   BrkGReg R0 BEQ 7     -- R0 == 7
--   BrkDmem 0x20 BLT 4   -- *0x20 &lt; 4
--   </pre>
data DbgBrk

-- | no break
BrkNon :: DbgBrk

-- | always one step break
BrkOne :: DbgBrk

-- | pc break
BrkPc :: DbgOrd -> Int -> DbgBrk

-- | register break
BrkGReg :: GReg -> DbgOrd -> Int -> DbgBrk

-- | data memory break
BrkDmem :: Int -> DbgOrd -> Int -> DbgBrk

-- | break operators
data DbgOrd

-- | equal
BEQ :: DbgOrd

-- | not equal
BNE :: DbgOrd

-- | little than
BLT :: DbgOrd

-- | little equal
BLE :: DbgOrd

-- | greater than
BGT :: DbgOrd

-- | greater equal
BGE :: DbgOrd
instance Show DbgTrc
instance Eq DbgTrc
instance Eq DbgOrd
instance Show DbgOrd
instance Eq DbgBrk

module Language.Pck.Tool.Profiler

-- | run the profiler
--   
--   Example: instruction count profile
--   
--   <pre>
--   &gt; runProf [ProfInst] [(0,[MOVI R1 0, MOVI R2 8, ST R1 R2, HALT])] []
--    instruction profile:
--    
--      MOVI  2
--      HALT  1
--      ST    1
--    
--      total 4
--   </pre>
--   
--   Example: memory store profile
--   
--   <pre>
--   &gt; runProf [ProfStore] [(0,insts)] []
--   Memory store address profile:
--   
--     address       count
--     0x00000000    1
--     0x00000001    1
--     0x00000002    1
--     0x00000003    1
--     0x00000004    1
--     0x00000005    1
--     0x00000006    1
--   
--     total         7
--   </pre>
--   
--   Example: branch,jump,call profile
--   
--   <pre>
--   &gt; runProf [ProfBranch] [(0,insts)] []
--   Branch/Jump/Call target profile:
--   
--     address       count
--     0x00000007    6
--   
--     total 6
--   
--   
--   Branch/Jump/Call direction profile:
--   
--     T/N   count
--     Taken 6
--     Not   1
--   
--     total 7
--   </pre>
runProf :: [ProfMode] -> InstImage -> DataImage -> String

-- | run the profiler for IO output
--   
--   Example:
--   
--   <pre>
--   &gt; runProfIO [ProfInst] [(0,[MOVI R1 0, MOVI R2 8, ST R1 R2, HALT])] []
--    instruction profile:
--    
--      MOVI  2
--      HALT  1
--      ST    1
--    
--      total 4
--   </pre>
runProfIO :: [ProfMode] -> InstImage -> DataImage -> IO ()

-- | profile function
--   
--   Example:
--   
--   <pre>
--   &gt; prof [ProfInst] $ fst $ runDbg [TrcInst] [] [(0,insts)] []
--    instruction profile:
--    
--      MOVI  2
--      HALT  1
--      ST    1
--    
--      total 4
--   </pre>
prof :: [ProfMode] -> ByteString -> String

-- | the profile mode for <a>prof</a>, <a>runProf</a> and <a>runProfIO</a>
data ProfMode

-- | instruction profile
ProfInst :: ProfMode

-- | pc profile
ProfPC :: ProfMode

-- | call profile
ProfCall :: ProfMode

-- | branch, jump, call profile
ProfBranch :: ProfMode

-- | memory load profile
ProfLoad :: ProfMode

-- | memory store profile
ProfStore :: ProfMode
instance Eq ProfMode

module Language.Pck.Tool.InteractiveDebugger

-- | interactive debugger driver.
--   
--   Example:
--   
--   <pre>
--   &gt; runIdbIO [TrcInst] []  [(0,insts)] []
--   For help, type "help".
--   (idb) info reg
--   pc : 0
--   gr : [0,0,0,0,0,0,0,0]
--   fl : [False,False]
--   
--   (idb) s
--   TrcInst:        pc : 0  MOVI R0 0
--   
--   (idb) s
--   TrcInst:        pc : 1  MOVI R1 1
--   
--   (idb) b 4
--   Num  Enb What
--   1    y   pc == 4
--   
--   (idb) c
--   TrcInst:        pc : 2  MOVI R2 2
--   
--   TrcInst:        pc : 3  MOVI R3 3
--   
--   (idb) x/10 0
--   0x00000000: 0x00000000 0x00000000 0x00000000 0x00000000
--   0x00000004: 0x00000000 0x00000000 0x00000000 0x00000000
--   0x00000008: 0x00000000 0x00000000
--   
--   (idb) q
--   </pre>
--   
--   please see "help" command
runIdbIO :: [DbgTrc] -> [DbgBrk] -> InstImage -> DataImage -> IO ()
instance Show Cmd
instance Eq Cmd

module Language.Pck.Tool

-- | parse instructions from a ByteString data
--   
--   Example:
--   
--   <pre>
--   &gt; parseInst (B.pack "mov r0,1\n halt\n")
--   [MOVI R0 1,HALT]
--   </pre>
parseInst :: ByteString -> Either [String] [Inst]

-- | parse instructions from a file
--   
--   Example:
--   
--   <pre>
--   &gt; parseInstFile "examples/test0.asm"
--   [MOVI R0 1,HALT]
--   </pre>
parseInstFile :: FilePath -> IO [Inst]

-- | debugging run
--   
--   Example: run with a break condition. (break at pc == 1)
--   
--   <pre>
--   &gt; runDbg [] [(BrkPc BEQ 1)] [(0,[MOVI R0 7, MOVI R1 8, HALT])] []
--   pc : 1
--   gr : [7,0,0,0,0,0,0,0]
--   fl : [False,False]
--   </pre>
--   
--   Example: run with trace output. (instruction trace)
--   
--   <pre>
--   &gt; runDbg [TrcInst] [] [(0,[MOVI R0 7, MOVI R1 8, HALT])] []
--   TrcInst:        pc : 0  MOVI R0 7
--   
--   TrcInst:        pc : 1  MOVI R1 8
--   
--   TrcInst:        pc : 2  HALT
--   </pre>
runDbg :: [DbgTrc] -> [DbgBrk] -> InstImage -> DataImage -> (TrcLog, CpuState)

-- | debugging run for IO output
--   
--   Example: run with trace output. (instruction trace)
--   
--   <pre>
--   &gt; runDbgIO [TrcInst] [] [(0,[MOVI R0 7, MOVI R1 8, HALT])] []
--   TrcInst:        pc : 0  MOVI R0 7
--   
--   TrcInst:        pc : 1  MOVI R1 8
--   
--   TrcInst:        pc : 2  HALT
--   </pre>
runDbgIO :: [DbgTrc] -> [DbgBrk] -> InstImage -> DataImage -> IO ()

-- | trace conditions for <a>runDbg</a> or <a>runDbgIO</a>
data DbgTrc

-- | trace instructions
TrcInst :: DbgTrc

-- | trace registers
TrcReg :: DbgTrc

-- | trace pc
TrcPc :: DbgTrc

-- | trace call target address
TrcCall :: DbgTrc

-- | trace branch information
TrcBranch :: DbgTrc

-- | trace memory load
TrcLoad :: DbgTrc

-- | trace memory store
TrcStore :: DbgTrc

-- | break conditions
--   
--   Example:
--   
--   <pre>
--   BrkPc BEQ 3          -- pc == 3
--   BrkPc BGE 0x80       -- pc &gt;= 0x80
--   BrkGReg R0 BEQ 7     -- R0 == 7
--   BrkDmem 0x20 BLT 4   -- *0x20 &lt; 4
--   </pre>
data DbgBrk

-- | no break
BrkNon :: DbgBrk

-- | always one step break
BrkOne :: DbgBrk

-- | pc break
BrkPc :: DbgOrd -> Int -> DbgBrk

-- | register break
BrkGReg :: GReg -> DbgOrd -> Int -> DbgBrk

-- | data memory break
BrkDmem :: Int -> DbgOrd -> Int -> DbgBrk

-- | break operators
data DbgOrd

-- | equal
BEQ :: DbgOrd

-- | not equal
BNE :: DbgOrd

-- | little than
BLT :: DbgOrd

-- | little equal
BLE :: DbgOrd

-- | greater than
BGT :: DbgOrd

-- | greater equal
BGE :: DbgOrd

-- | data type for <a>runDbg</a> log
type TrcLog = ByteString

-- | interactive debugger driver.
--   
--   Example:
--   
--   <pre>
--   &gt; runIdbIO [TrcInst] []  [(0,insts)] []
--   For help, type "help".
--   (idb) info reg
--   pc : 0
--   gr : [0,0,0,0,0,0,0,0]
--   fl : [False,False]
--   
--   (idb) s
--   TrcInst:        pc : 0  MOVI R0 0
--   
--   (idb) s
--   TrcInst:        pc : 1  MOVI R1 1
--   
--   (idb) b 4
--   Num  Enb What
--   1    y   pc == 4
--   
--   (idb) c
--   TrcInst:        pc : 2  MOVI R2 2
--   
--   TrcInst:        pc : 3  MOVI R3 3
--   
--   (idb) x/10 0
--   0x00000000: 0x00000000 0x00000000 0x00000000 0x00000000
--   0x00000004: 0x00000000 0x00000000 0x00000000 0x00000000
--   0x00000008: 0x00000000 0x00000000
--   
--   (idb) q
--   </pre>
--   
--   please see "help" command
runIdbIO :: [DbgTrc] -> [DbgBrk] -> InstImage -> DataImage -> IO ()

-- | run the profiler
--   
--   Example: instruction count profile
--   
--   <pre>
--   &gt; runProf [ProfInst] [(0,[MOVI R1 0, MOVI R2 8, ST R1 R2, HALT])] []
--    instruction profile:
--    
--      MOVI  2
--      HALT  1
--      ST    1
--    
--      total 4
--   </pre>
--   
--   Example: memory store profile
--   
--   <pre>
--   &gt; runProf [ProfStore] [(0,insts)] []
--   Memory store address profile:
--   
--     address       count
--     0x00000000    1
--     0x00000001    1
--     0x00000002    1
--     0x00000003    1
--     0x00000004    1
--     0x00000005    1
--     0x00000006    1
--   
--     total         7
--   </pre>
--   
--   Example: branch,jump,call profile
--   
--   <pre>
--   &gt; runProf [ProfBranch] [(0,insts)] []
--   Branch/Jump/Call target profile:
--   
--     address       count
--     0x00000007    6
--   
--     total 6
--   
--   
--   Branch/Jump/Call direction profile:
--   
--     T/N   count
--     Taken 6
--     Not   1
--   
--     total 7
--   </pre>
runProf :: [ProfMode] -> InstImage -> DataImage -> String

-- | run the profiler for IO output
--   
--   Example:
--   
--   <pre>
--   &gt; runProfIO [ProfInst] [(0,[MOVI R1 0, MOVI R2 8, ST R1 R2, HALT])] []
--    instruction profile:
--    
--      MOVI  2
--      HALT  1
--      ST    1
--    
--      total 4
--   </pre>
runProfIO :: [ProfMode] -> InstImage -> DataImage -> IO ()

-- | profile function
--   
--   Example:
--   
--   <pre>
--   &gt; prof [ProfInst] $ fst $ runDbg [TrcInst] [] [(0,insts)] []
--    instruction profile:
--    
--      MOVI  2
--      HALT  1
--      ST    1
--    
--      total 4
--   </pre>
prof :: [ProfMode] -> ByteString -> String

-- | the profile mode for <a>prof</a>, <a>runProf</a> and <a>runProfIO</a>
data ProfMode

-- | instruction profile
ProfInst :: ProfMode

-- | pc profile
ProfPC :: ProfMode

-- | call profile
ProfCall :: ProfMode

-- | branch, jump, call profile
ProfBranch :: ProfMode

-- | memory load profile
ProfLoad :: ProfMode

-- | memory store profile
ProfStore :: ProfMode

module Language.Pck.Cpu

-- | run the processor
--   
--   Example: simple run
--   
--   <pre>
--   &gt; run [(0, [MOVI R0 20, HALT])] []
--   pc : 1
--   gr : [20,0,0,0,0,0,0,0]
--   fl : [False,False]
--   ...
--   </pre>
--   
--   Example: run with initial data
--   
--   <pre>
--   &gt; run [(0, [MOVI R1 0, LD R0 R1, HALT])] [(0,[100])]
--   pc : 2
--   gr : [100,0,0,0,0,0,0,0]
--   fl : [False,False]
--   ...
--   </pre>
run :: InstImage -> DataImage -> CpuState

-- | the instruction definition.
--   
--   You can create instructions as you like :-)
--   
--   Operand order is Intel, ARM, MIPS, PowerPC,... order. (opcode dst src1
--   src2)
data Inst

-- | no operation
NOP :: Inst

-- | halt (stop the processor)
HALT :: Inst

-- | GReg &lt;- Int
MOVI :: GReg -> Int -> Inst

-- | GReg &lt;- GReg
MOV :: GReg -> GReg -> Inst

-- | GReg &lt;- PC
MOVPC :: GReg -> Inst

-- | GReg &lt;- GReg + GReg
ADD :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg - GReg
SUB :: GReg -> GReg -> GReg -> Inst

-- | Flag &lt;- compare(GReg, GReg)
CMP :: GReg -> GReg -> Inst

-- | GReg &lt;- abs(GReg)
ABS :: GReg -> GReg -> Inst

-- | GReg &lt;- GReg &lt;&lt; GReg // arithmetic shift
ASH :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg * GReg
MUL :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg / GReg
DIV :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg &amp; GReg
AND :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg | GReg
OR :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- ~GReg
NOT :: GReg -> GReg -> Inst

-- | GReg &lt;- GReg ^ GReg
XOR :: GReg -> GReg -> GReg -> Inst

-- | GReg &lt;- GReg &lt;&lt; GReg // logical shift
LSH :: GReg -> GReg -> GReg -> Inst

-- | if (FCond(Flag)) goto (PC + Int) // pc relative addressing
BRI :: FCond -> Int -> Inst

-- | goto (PC + Int) // pc relative addressing
JRI :: Int -> Inst

-- | goto GReg // absolute addressing
J :: GReg -> Inst

-- | goto GReg; R0 &lt;- PC // absolute addressing
CALL :: GReg -> Inst

-- | goto R0
RET :: Inst

-- | GReg &lt;- memory(GReg)
LD :: GReg -> GReg -> Inst

-- | memory(GReg) &lt;- GReg
ST :: GReg -> GReg -> Inst

-- | undefined
UNDEF :: Inst

-- | the general purpose registers.
--   
--   You can create registers as you like :-)
data GReg
R0 :: GReg
R1 :: GReg
R2 :: GReg
R3 :: GReg
R4 :: GReg
R5 :: GReg
R6 :: GReg
R7 :: GReg

-- | the Flag conditions
data FCond

-- | equal
FCEQ :: FCond

-- | not equal
FCNE :: FCond

-- | little than
FCLT :: FCond

-- | little equal
FCLE :: FCond

-- | greater than
FCGT :: FCond

-- | greater equal
FCGE :: FCond

-- | the instruction memory image
--   
--   <pre>
--   [(StartAddress, [Instruction1,  Instruction2, ...])]
--   </pre>
--   
--   Example:
--   
--   <pre>
--   [(0, [MOVI R1 0,  LD R0 R1,  HALT])]
--   </pre>
type InstImage = [(IAddress, [Inst])]

-- | the data memory image
--   
--   <pre>
--   [(StartAddress, [Data1,  Data2, ...])]
--   </pre>
--   
--   Example:
--   
--   <pre>
--   [(0, [1, 5, 7, 0x20])]
--   </pre>
type DataImage = [(DAddress, [DValue])]

-- | the cpu state (processor internal state)
--   
--   This is the result type from <a>run</a> function.
--   
--   get each values by <a>pcFromCpuState</a>, <a>grFromCpuState</a>,
--   <a>flFromCpuState</a>, <a>imemFromCpuState</a>,
--   <a>dmemFromCpuState</a>, <a>dumpCpuState</a>
data CpuState

-- | <pre>
--   &gt; pcFromCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   1
--   </pre>
pcFromCpuState :: CpuState -> Int

-- | <pre>
--   &gt; grFromCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   [7,0,0,0,0,0,0,0]
--   </pre>
grFromCpuState :: CpuState -> [Int]

-- | <pre>
--   &gt; flFromCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   [False,False]
--   </pre>
flFromCpuState :: CpuState -> [Bool]

-- | <pre>
--   &gt; imemFromCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   [(0,[MOVI R0 7,HALT,UNDEF,UNDEF,...])]
--   </pre>
imemFromCpuState :: CpuState -> InstImage

-- | <pre>
--   &gt; dmemFromCpuState $ run [(0,[MOVI R0 0, MOVI R1 10, ST R0 R1, HALT])] []
--   [(0,[10,0,0,0,0,...])]
--   </pre>
dmemFromCpuState :: CpuState -> DataImage

-- | dump Cpu state (without instruction image)
--   
--   <pre>
--   &gt; putStr $ dumpCpuState $ run [(0,[MOVI R0 7, HALT])] []
--   pc : 1
--   gr : [7,0,0,0,0,0,0,0]
--   fl : [False,False]
--   dm : [(0,[7,0,0,0,0,...])]
--   </pre>
dumpCpuState :: CpuState -> String
