-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An un-SYB framework for transforming heterogenous
data through folds
--   
@package origami
@version 0.0.4


-- | An incomplete implementation of an extension of the <a>Functor</a> and
--   <tt>Traversable</tt> concepts to three type arguments. I've
--   implemented enough for our purposes here.
module Data.Origami.Internal.Trifunctor

-- | Extends the <a>Functor</a> concept to three type arguments. (Note: we
--   are missing analogies to the functions <tt>first</tt> and
--   <tt>second</tt> found in <a>Data.Bifunctor</a>.)
class Trifunctor f
trimap :: Trifunctor f => (a -> a') -> (b -> b') -> (c -> c') -> f a b c -> f a' b' c'

-- | Extends the <tt>Traversable</tt> concept to three type arguments.
--   (Note: we are missing analogies to the functions <tt>bitraverse</tt>,
--   <tt>bisequenceA</tt> and <tt>bimapM</tt> found in
--   <a>Data.Bitraversable</a>.)
class Tritraversable t
trisequence :: (Tritraversable t, Monad m) => t (m a) (m b) (m c) -> m (t a b c)
instance Tritraversable (,,)
instance Trifunctor (,,)


-- | Data structures representing a set of datatypes to be folded.
module Data.Origami.Internal.FoldFamily

-- | Represents a set of datatypes to be folded.
newtype FoldFamily
FoldFamily :: [DataTy] -> FoldFamily

-- | Represents a datatype to be folded.
data DataTy
DataTy :: Name -> [DataCase] -> DataTy

-- | Represents one way to construct a datatype; that is, one of its
--   constructors and its arguments.
data DataCase
DataCase :: Name -> [DataField] -> DataCase

-- | Represents a component of a datatype; that is, an argument to one of
--   its constructors.
data DataField

-- | a type to be taken verbatim, not to be folded
Atomic :: Ty -> DataField

-- | a type to be recursively folded
Nonatomic :: Ty -> DataField

-- | an application of a <a>Functor</a>
Funct :: Name -> DataField -> DataField

-- | an application of a <a>Bifunctor</a>
Bifunct :: Name -> DataField -> DataField -> DataField

-- | an application of a <tt>Trifunctor</tt>
Trifunct :: Name -> DataField -> DataField -> DataField -> DataField

-- | Represents a datatype's name.
newtype Ty
Ty :: Name -> Ty

-- | Access to the <a>Name</a> of a Data structure
class HasName d
name :: HasName d => Lens' d Name

-- | Access to the <a>DataCase</a>s of a datatype
dataCases :: Lens' DataTy [DataCase]

-- | Access to the <tt>DataFields</tt>s of a <a>DataCase</a>
dataFields :: Lens' DataCase [DataField]

-- | Access to the datatypes of a fold family.
dataTys :: Iso' FoldFamily [DataTy]

-- | Provides a <a>Traversal</a> for an atomic <a>Ty</a> in a
--   <a>DataField</a>
_Atomic :: Prism' DataField Ty

-- | Provides a <a>Traversal</a> for an nonatomic <a>Ty</a> in a
--   <a>DataField</a>
_Nonatomic :: Prism' DataField Ty

-- | Provides a <a>Traversal</a> for a <a>Functor</a> application in a
--   <a>DataField</a>
_Funct :: Prism' DataField (Name, DataField)

-- | Provides a <a>Traversal</a> for a <a>Bifunctor</a> application in a
--   <a>DataField</a>
_Bifunct :: Prism' DataField (Name, DataField, DataField)

-- | Provides a <a>Traversal</a> for a <tt>Trifunctor</tt> application in a
--   <a>DataField</a>
_Trifunct :: Prism' DataField (Name, DataField, DataField, DataField)
instance Typeable Ty
instance Typeable DataField
instance Typeable DataCase
instance Typeable DataTy
instance Typeable FoldFamily
instance Eq Ty
instance Ord Ty
instance Show Ty
instance Data Ty
instance Eq DataField
instance Ord DataField
instance Show DataField
instance Data DataField
instance Eq DataCase
instance Ord DataCase
instance Show DataCase
instance Data DataCase
instance Eq DataTy
instance Ord DataTy
instance Show DataTy
instance Data DataTy
instance Eq FoldFamily
instance Ord FoldFamily
instance Show FoldFamily
instance Data FoldFamily
instance HasName Ty
instance HasName DataCase
instance HasName DataTy


-- | Folds over the fold family rooted at <a>FoldFamily</a>.
module Data.Origami.Internal.Fold

-- | The fold. Bundles up the functions used to replace constructors in the
--   fold family.
data Fold dataCase dataField dataTy foldFamily ty
Fold :: (ty -> dataField) -> (Name -> dataField -> dataField -> dataField) -> (Name -> [dataField] -> dataCase) -> (Name -> [dataCase] -> dataTy) -> ([dataTy] -> foldFamily) -> (Name -> dataField -> dataField) -> (ty -> dataField) -> (Name -> dataField -> dataField -> dataField -> dataField) -> (Name -> ty) -> Fold dataCase dataField dataTy foldFamily ty
mkAtomic :: Fold dataCase dataField dataTy foldFamily ty -> ty -> dataField
mkBifunct :: Fold dataCase dataField dataTy foldFamily ty -> Name -> dataField -> dataField -> dataField
mkDataCase :: Fold dataCase dataField dataTy foldFamily ty -> Name -> [dataField] -> dataCase
mkDataTy :: Fold dataCase dataField dataTy foldFamily ty -> Name -> [dataCase] -> dataTy
mkFoldFamily :: Fold dataCase dataField dataTy foldFamily ty -> [dataTy] -> foldFamily
mkFunct :: Fold dataCase dataField dataTy foldFamily ty -> Name -> dataField -> dataField
mkNonatomic :: Fold dataCase dataField dataTy foldFamily ty -> ty -> dataField
mkTrifunct :: Fold dataCase dataField dataTy foldFamily ty -> Name -> dataField -> dataField -> dataField -> dataField
mkTy :: Fold dataCase dataField dataTy foldFamily ty -> Name -> ty

-- | The identity <a>Fold</a>. Intended as a base to be modified.
idFold :: Fold DataCase DataField DataTy FoldFamily Ty

-- | The error <a>Fold</a>. Intended as a base to be modified.
errFold :: String -> Fold dataCase dataField dataTy foldFamily ty

-- | Using the constructors from the base <a>Fold</a>, folds monadically in
--   a bottom-up, left-to-right manner.
monadicFold :: Monad m => Fold dataCase dataField dataTy foldFamily ty -> Fold (m dataCase) (m dataField) (m dataTy) (m foldFamily) (m ty)

-- | Monadically folds over a <a>FoldFamily</a>
foldFoldFamily :: Fold dataCase dataField dataTy foldFamily ty -> FoldFamily -> foldFamily

-- | Monadically folds over a <a>DataTy</a>
foldDataTy :: Fold dataCase dataField dataTy foldFamily ty -> DataTy -> dataTy

-- | Monadically folds over a <a>DataCase</a>
foldDataCase :: Fold dataCase dataField dataTy foldFamily ty -> DataCase -> dataCase

-- | Monadically folds over a <a>DataField</a>
foldDataField :: Fold dataCase dataField dataTy foldFamily ty -> DataField -> dataField

-- | Monadically folds over a <tt>FoldTy</tt>
foldTy :: Fold dataCase dataField dataTy foldFamily ty -> Ty -> ty


-- | Creation of declarations from a <a>FoldFamily</a>
module Data.Origami.Internal.TH

-- | Creates declarations for the * <tt>Fold</tt>, * <tt>idFold</tt>, *
--   <tt>errFold</tt>, * <tt>monadicFold</tt>, * and one <tt>foldXxx</tt>
--   function for each datatype <tt>Xxx</tt> in the <a>FoldFamily</a>.
mkFoldDecs :: FoldFamily -> [Dec]

-- | Returns <tt>True</tt> iff the constructor <a>Name</a>s of the
--   <a>FoldFamily</a> are all unique.
ctorNamesAreUnique :: FoldFamily -> Bool

-- | Returns the set of constructor <a>Name</a>s in the <a>FoldFamily</a>
--   that are repeated.
duplicateCtorNames :: FoldFamily -> Set String

-- | Returns <tt>True</tt> iff the <a>Name</a>s of the datatypes in the
--   <a>FoldFamily</a> are all unique.
typeNamesAreUnique :: FoldFamily -> Bool


-- | Builds fold declarations for a <a>FoldFamily</a>.
module Data.Origami.Internal.Build

-- | Discovers the fold family and builds declarations from it to be
--   spliced into a source file.
--   
--   The fold family includes the root datatypes and the datatypes of all
--   of their components, recursively. Datatypes declared as atomic will
--   not be included, nor their components.
--   
--   In general, the framework does not currently handle parameterized
--   datatypes, but applications of datatypes in <a>Traversable</a>,
--   <a>Bitraversable</a>, or <a>Tritraversable</a> are treated as
--   "transparent" and traversed through.
--   
--   The framework generates:
--   
--   <ul>
--   <li>a type-parameterized <tt>Fold</tt> record datatype. Each type
--   parameter <tt>xxx</tt> corresponds to a non-atomic datatype
--   <tt>Xxx</tt> in the fold family. Each field <tt>mkYyy</tt> of the
--   <tt>Fold</tt> corresponds to a constructor <tt>Yyy</tt> used by some
--   datatype in the fold family.</li>
--   <li>an <tt>idFold</tt> record. Folding over <tt>idFold</tt> is
--   equivalent to applying <tt>id</tt>: it does nothing. <tt>idFold</tt>
--   is useful as a base record to build your own folds upon.</li>
--   <li>an <tt>errFold</tt> function to create a <tt>Fold</tt> record,
--   with undefined fields that give a useful error message when accessed.
--   The <tt>mkXxx</tt> field of <tt>errFold "example"</tt> is defined to
--   contain <tt>error "example.mkXxx"</tt>.</li>
--   <li>a <tt>monadicFold</tt> function that lifts a <tt>Fold a b c</tt>
--   into a <tt>Fold (m a) (m b) (m c)</tt>. It applies the base fold
--   monadically in a bottom-up, left-to-right way.</li>
--   <li>for each datatype <tt>Xxx</tt>, a <tt>foldXxx</tt> function that
--   applies a <tt>Fold</tt> to an <tt>Xxx</tt> value, returning a value of
--   type <tt>xxx</tt>.</li>
--   </ul>
--   
--   The names <tt>Fold</tt>, <tt>idFold</tt>, <tt>errFold</tt>, and
--   <tt>monadicFold</tt> are fixed. They are intended to be imported
--   qualified.
--   
--   You are not expected to understand the structure of the generated code
--   from this generic description. Generate code for your specific case
--   and look at its Haddock documentation.
--   
--   Since the discovery process can automatically collect a very large
--   number of datatypes, and since the user doesn't usually see the
--   spliced code, we require the user to declare what she expects so that
--   there are no surprises. For that reason, any functor classes expected
--   to be appear in the result must be declared, as are datatypes the user
--   wants to treat as atomic.
--   
--   There are a few other restrictions not mentioned here: if you hit any
--   of them, the framework should output a helpful, intelligible error
--   message when generating the declarations and before trying to splice
--   and compile the declarations. You should see no errors from the
--   compiler trying to compile bad generated code. If you do, that's a
--   bug; please let us know. If the error messages are opaque, that's a
--   bug too.
buildFolds :: [Name] -> [Name] -> [Name] -> Q [Dec]

-- | Prints onto standard output the result of running <a>buildFolds</a>
--   but doesn't splice the fold declarations.
buildFoldsDryRun :: [Name] -> [Name] -> [Name] -> Q [Dec]

-- | Errors possible while building a <a>FoldFamily</a>
data BuildErr

-- | Builds a <a>FoldFamily</a> or returns an error. Spliced result is of
--   type <a>Either</a> <a>BuildErr</a> <a>FoldFamily</a>.
buildFoldFamilyMaybe :: [Name] -> [Name] -> [Name] -> Q Exp
instance Typeable BuildErr
instance Data BuildErr
instance Functor Build
instance Applicative Build
instance Monad Build
instance MonadError BuildErr Build
instance MonadReader Stack Build
instance MonadState (Set Name) Build
instance MonadWriter [Data] Build
instance MonadBuild Build
instance Error BuildErr
instance Show BuildErr


-- | Builds fold declarations for a fold family.
module Data.Origami

-- | Discovers the fold family and builds declarations from it to be
--   spliced into a source file.
--   
--   The fold family includes the root datatypes and the datatypes of all
--   of their components, recursively. Datatypes declared as atomic will
--   not be included, nor their components.
--   
--   In general, the framework does not currently handle parameterized
--   datatypes, but applications of datatypes in <a>Traversable</a>,
--   <a>Bitraversable</a>, or <a>Tritraversable</a> are treated as
--   "transparent" and traversed through.
--   
--   The framework generates:
--   
--   <ul>
--   <li>a type-parameterized <tt>Fold</tt> record datatype. Each type
--   parameter <tt>xxx</tt> corresponds to a non-atomic datatype
--   <tt>Xxx</tt> in the fold family. Each field <tt>mkYyy</tt> of the
--   <tt>Fold</tt> corresponds to a constructor <tt>Yyy</tt> used by some
--   datatype in the fold family.</li>
--   <li>an <tt>idFold</tt> record. Folding over <tt>idFold</tt> is
--   equivalent to applying <tt>id</tt>: it does nothing. <tt>idFold</tt>
--   is useful as a base record to build your own folds upon.</li>
--   <li>an <tt>errFold</tt> function to create a <tt>Fold</tt> record,
--   with undefined fields that give a useful error message when accessed.
--   The <tt>mkXxx</tt> field of <tt>errFold "example"</tt> is defined to
--   contain <tt>error "example.mkXxx"</tt>.</li>
--   <li>a <tt>monadicFold</tt> function that lifts a <tt>Fold a b c</tt>
--   into a <tt>Fold (m a) (m b) (m c)</tt>. It applies the base fold
--   monadically in a bottom-up, left-to-right way.</li>
--   <li>for each datatype <tt>Xxx</tt>, a <tt>foldXxx</tt> function that
--   applies a <tt>Fold</tt> to an <tt>Xxx</tt> value, returning a value of
--   type <tt>xxx</tt>.</li>
--   </ul>
--   
--   The names <tt>Fold</tt>, <tt>idFold</tt>, <tt>errFold</tt>, and
--   <tt>monadicFold</tt> are fixed. They are intended to be imported
--   qualified.
--   
--   You are not expected to understand the structure of the generated code
--   from this generic description. Generate code for your specific case
--   and look at its Haddock documentation.
--   
--   Since the discovery process can automatically collect a very large
--   number of datatypes, and since the user doesn't usually see the
--   spliced code, we require the user to declare what she expects so that
--   there are no surprises. For that reason, any functor classes expected
--   to be appear in the result must be declared, as are datatypes the user
--   wants to treat as atomic.
--   
--   There are a few other restrictions not mentioned here: if you hit any
--   of them, the framework should output a helpful, intelligible error
--   message when generating the declarations and before trying to splice
--   and compile the declarations. You should see no errors from the
--   compiler trying to compile bad generated code. If you do, that's a
--   bug; please let us know. If the error messages are opaque, that's a
--   bug too.
buildFolds :: [Name] -> [Name] -> [Name] -> Q [Dec]
