-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | claferIG is an interactive tool that generates instances of Clafer models.
--   
@package claferIG
@version 0.3.10

module Language.Clafer.IG.CommandLineParser

-- | Interactive session commands
data Command
Next :: Command
IncreaseGlobalScope :: Integer -> Command
IncreaseScope :: String -> Integer -> Command
SetGlobalScope :: Integer -> Command
SetScope :: String -> Integer -> Command
SetBitwidth :: Integer -> Command
SetMaxInt :: Integer -> Command
Save :: Command
Quit :: Command
Reload :: Command
Help :: Command
Find :: String -> Command
ShowScopes :: Command
SaveScopes :: Command
LoadScopes :: Command
ShowClaferModel :: Command
ShowAlloyModel :: Command
ShowAlloyInstance :: Command
SetUnsatCoreMinimization :: UnsatCoreMinimization -> Command
data UnsatCoreMinimization
Fastest :: UnsatCoreMinimization
Medium :: UnsatCoreMinimization
Best :: UnsatCoreMinimization
parseCommandLine :: String -> Either ParseError Command

-- | This function uses the expected/unexpected messages to understand what
--   to autocomplete. Any unexpected character means parse did not reach
--   the end of the input, hence cannot autocomplete.
parseCommandLineAutoComplete :: String -> ParseError
commandStrings :: [String]
expectedMessage :: Message -> Maybe String
unexpectedMessage :: Message -> Maybe String

-- | Extracts the list of error messages from the parse error
errorMessages :: ParseError -> [Message]
instance Show UnsatCoreMinimization
instance Show Command

module Language.Clafer.IG.Solution

-- | Alloy solution
data Solution
Solution :: [Sig] -> [Field] -> Solution
s_sigs :: Solution -> [Sig]
s_fields :: Solution -> [Field]

-- | The univ sig does not have a parent
data Sig
Sig :: String -> Int -> Maybe Int -> [Atom] -> Sig
s_label :: Sig -> String
s_id :: Sig -> Int
s_parentId :: Sig -> Maybe Int
s_atoms :: Sig -> [Atom]
data Atom
Atom :: String -> Atom
a_label :: Atom -> String
data Field
Field :: String -> Int -> Int -> [Tuple] -> Field
f_label :: Field -> String
f_id :: Field -> Int
f_parentId :: Field -> Int
f_tuples :: Field -> [Tuple]
data Tuple
Tuple :: Atom -> Int -> Atom -> Int -> Tuple
t_from :: Tuple -> Atom
t_fromType :: Tuple -> Int
t_to :: Tuple -> Atom
t_toType :: Tuple -> Int
parseSolution :: String -> Solution
instance Show Atom
instance Show Sig
instance Show Tuple
instance Show Field
instance Show Solution

module Language.Clafer.IG.Constraints
data Constraint
ExactCardinalityConstraint :: Span -> ClaferInfo -> Constraint
range :: Constraint -> Span
claferInfo :: Constraint -> ClaferInfo
LowerCardinalityConstraint :: Span -> ClaferInfo -> Constraint
range :: Constraint -> Span
claferInfo :: Constraint -> ClaferInfo
UpperCardinalityConstraint :: Span -> ClaferInfo -> Constraint
range :: Constraint -> Span
claferInfo :: Constraint -> ClaferInfo
UserConstraint :: Span -> ConstraintInfo -> Constraint
range :: Constraint -> Span
constraintInfo :: Constraint -> ConstraintInfo
data Cardinality
Cardinality :: Integer -> Maybe Integer -> Cardinality
lower :: Cardinality -> Integer
upper :: Cardinality -> Maybe Integer
data ClaferInfo
ClaferInfo :: String -> Cardinality -> ClaferInfo
uniqueId :: ClaferInfo -> String
cardinality :: ClaferInfo -> Cardinality
data ConstraintInfo
ConstraintInfo :: String -> Span -> String -> ConstraintInfo
pId :: ConstraintInfo -> String
pos :: ConstraintInfo -> Span
syntax :: ConstraintInfo -> String
isLowerCardinalityConstraint :: Constraint -> Bool
isUpperCardinalityConstraint :: Constraint -> Bool
lookupConstraint :: Span -> [Constraint] -> Constraint
parseConstraints :: String -> IModule -> [(Span, IrTrace)] -> [Constraint]
instance Eq Cardinality
instance Eq ClaferInfo
instance Eq ConstraintInfo
instance Show Constraint
instance Eq Constraint
instance Show ConstraintInfo
instance Show ClaferInfo
instance Show Cardinality

module Language.Clafer.IG.ClaferModel

-- | Clafer model instance
data ClaferModel
ClaferModel :: [Clafer] -> ClaferModel
c_topLevel :: ClaferModel -> [Clafer]
data Clafer
Clafer :: Id -> Maybe Value -> [Clafer] -> Clafer
c_id :: Clafer -> Id
c_value :: Clafer -> Maybe Value
c_children :: Clafer -> [Clafer]

-- | The tuple of name and ordinal must be globally unique
data Id
Id :: String -> Int -> Id
i_name :: Id -> String
i_ordinal :: Id -> Int
data Value
AliasValue :: Id -> Value
c_alias :: Value -> Id
IntValue :: Int -> Value
v_value :: Value -> Int
StringValue :: String -> Value
v_str :: Value -> String
c_name :: Clafer -> String
buildClaferModel :: Solution -> ClaferModel
traverseModel :: ClaferModel -> [Clafer]
instance Eq Id
instance Ord Id
instance Show Id
instance Show Value
instance Eq Value
instance Eq Clafer
instance Eq Node
instance Ord Node
instance Show Node
instance Show FamilyTree
instance Show Clafer
instance Show ClaferModel

module Language.Clafer.IG.Sugarer

-- | Rewrite the model into a human-friendlier format
sugarClaferModel :: Bool -> Bool -> UIDIClaferMap -> ClaferModel -> (Map Int String) -> ClaferModel
instance Show Census

module Language.Clafer.IG.JSONGenerator

-- | Generate a representation of the instance in JSON format
generateJSON :: UIDIClaferMap -> ClaferModel -> String

module Language.Clafer.IG.Process
data Process
executableDirectory :: IO FilePath

-- | Wait until the process terminates
waitFor :: Process -> IO ExitCode

-- | Reads the entire output verbatim
getContentsVerbatim :: Process -> IO String

-- | Read the message
getMessage :: MonadIO m => Process -> m String
readMessage :: (Read r, MonadIO m) => Process -> m r

-- | Put the message
putMessage :: MonadIO m => Process -> String -> m ()

-- | Start another process and return the piped std_in, std_out stream
pipeProcess :: FilePath -> [String] -> IO Process

module Language.Clafer.IG.AlloyIGInterface

-- | An interface to the Alloy Analyzer
newtype AlloyIGT m a
AlloyIGT :: (StateT (Maybe AlloyIGEnv) (ReaderT Process m) a) -> AlloyIGT m a
fetch :: Monad m => AlloyIGT m AlloyIGEnv
fetches :: Monad m => (AlloyIGEnv -> a) -> AlloyIGT m a
set :: Monad m => AlloyIGEnv -> AlloyIGT m ()
proc :: Monad m => AlloyIGT m Process

-- | Instance generator's environment
data AlloyIGEnv
AlloyIGEnv :: String -> Map String Sig -> Map String Integer -> Integer -> AlloyIGEnv
alloyModel :: AlloyIGEnv -> String
sigMap :: AlloyIGEnv -> Map String Sig
scopes :: AlloyIGEnv -> Map String Integer
globalScope :: AlloyIGEnv -> Integer
data Sig
Sig :: String -> Multiplicity -> Maybe String -> Maybe Integer -> Sig
s_name :: Sig -> String
s_multiplicity :: Sig -> Multiplicity
s_subset :: Sig -> Maybe String
s_startingScope :: Sig -> Maybe Integer
data Multiplicity
One :: Multiplicity
Lone :: Multiplicity
Some :: Multiplicity
Any :: Multiplicity
data UnsatCore
UnsatCore :: [Span] -> UnsatCore
core :: UnsatCore -> [Span]
withinRange :: Integer -> Multiplicity -> Bool
runAlloyIGT :: MonadIO m => AlloyIGT m a -> m a
getAlloyModel :: MonadIO m => AlloyIGT m String
getSigs :: MonadIO m => AlloyIGT m [String]

-- | Call load before any other commands.
load :: Process -> String -> IO AlloyIGEnv
sendLoadCommand :: MonadIO m => String -> AlloyIGT m ()

-- | Get the next solution from alloyIG
sendNextCommand :: MonadIO m => AlloyIGT m (Maybe String)
getScope :: MonadIO m => String -> AlloyIGT m Integer
getScopes :: MonadIO m => AlloyIGT m [(String, Integer)]

-- | Tell alloyIG to change the scope of a sig
sendSetScopeCommand :: MonadIO m => String -> Integer -> AlloyIGT m (Maybe String)
getGlobalScope :: MonadIO m => AlloyIGT m Integer

-- | Tell alloyIG to change the global scope
sendSetGlobalScopeCommand :: MonadIO m => Integer -> AlloyIGT m ()

-- | Tell alloyIG to recalculate the solution
sendResolveCommand :: MonadIO m => AlloyIGT m ()

-- | Tell alloyIG to save the current state
sendSaveStateCommand :: MonadIO m => AlloyIGT m ()

-- | Tell alloyIG to restore the state
sendRestoreStateCommand :: MonadIO m => AlloyIGT m ()

-- | Tell alloyIG to remove the constraint
sendRemoveConstraintCommand :: MonadIO m => Span -> AlloyIGT m ()

-- | Tell alloyIG to return the unsat core of the previous operation
sendUnsatCoreCommand :: MonadIO m => AlloyIGT m UnsatCore

-- | Tell alloyIG to change the unsat core minimization level. 0 -&gt;
--   Fastest, 1 -&gt; Medium, 2 -&gt; Best
sendSetUnsatCoreMinimizationCommand :: MonadIO m => Integer -> AlloyIGT m ()

-- | Tell alloyIG to change the bitwidth
sendSetBitwidthCommand :: MonadIO m => Integer -> AlloyIGT m ()

-- | Tell alloyIG to quit
sendQuitCommand :: MonadIO m => AlloyIGT m ()
getMsg :: MonadIO m => AlloyIGT m String
readMsg :: (MonadIO m, Read r) => AlloyIGT m r
putMsg :: MonadIO m => String -> AlloyIGT m ()
instance MonadException m => MonadException (AlloyIGT m)
instance Eq Multiplicity
instance Read Multiplicity
instance Show Multiplicity
instance (Monad m, Functor m) => Applicative (AlloyIGT m)
instance Functor m => Functor (AlloyIGT m)
instance Monad m => Monad (AlloyIGT m)
instance MonadIO m => MonadIO (AlloyIGT m)
instance Show UnsatCore
instance MonadTrans AlloyIGT

module Language.Clafer.IG.ClaferIG
claferIGVersion :: String
data IGArgs
IGArgs :: Maybe Integer -> Maybe FilePath -> FilePath -> FilePath -> Integer -> Integer -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> ScopeStrategy -> IGArgs
all :: IGArgs -> Maybe Integer
saveDir :: IGArgs -> Maybe FilePath
claferModelFile :: IGArgs -> FilePath
alloySolution :: IGArgs -> FilePath
bitwidth :: IGArgs -> Integer
maxInt :: IGArgs -> Integer
useUids :: IGArgs -> Bool
addTypes :: IGArgs -> Bool
json :: IGArgs -> Bool
flatten_inheritance_comp :: IGArgs -> Bool
no_layout_comp :: IGArgs -> Bool
check_duplicates_comp :: IGArgs -> Bool
skip_resolver_comp :: IGArgs -> Bool
scope_strategy_comp :: IGArgs -> ScopeStrategy
data ClaferIGEnv
ClaferIGEnv :: ClaferEnv -> IGArgs -> [Constraint] -> String -> QNameMaps -> UIDIClaferMap -> Map Int String -> Map Integer String -> ClaferIGEnv
claferEnv' :: ClaferIGEnv -> ClaferEnv
claferIGArgs :: ClaferIGEnv -> IGArgs
constraints :: ClaferIGEnv -> [Constraint]
claferModel :: ClaferIGEnv -> String
qNameMaps :: ClaferIGEnv -> QNameMaps
info :: ClaferIGEnv -> UIDIClaferMap
strMap :: ClaferIGEnv -> Map Int String
lineNumMap :: ClaferIGEnv -> Map Integer String
getClaferEnv :: Monad m => ClaferIGT m ClaferEnv
getClaferIGArgs :: Monad m => ClaferIGT m IGArgs
getConstraints :: Monad m => ClaferIGT m [Constraint]
getClaferModel :: Monad m => ClaferIGT m String
getStrMap :: Monad m => ClaferIGT m (Map Int String)
getUIDIClaferMap :: Monad m => ClaferIGT m UIDIClaferMap
newtype ClaferIGT m a
ClaferIGT :: (StateT ClaferIGEnv (AlloyIGT m) a) -> ClaferIGT m a
data Instance
Instance :: ClaferModel -> String -> Instance
modelInstance :: Instance -> ClaferModel
alloyModelInstance :: Instance -> String
UnsatCore :: [Constraint] -> Maybe Counterexample -> Instance
unsatConstraints :: Instance -> [Constraint]
counterexample :: Instance -> Maybe Counterexample
NoInstance :: Instance
data Counterexample
Counterexample :: [Constraint] -> ClaferModel -> String -> Counterexample
removedConstraints :: Counterexample -> [Constraint]
counterexampleInstance :: Counterexample -> ClaferModel
counterexampleAlloyInstance :: Counterexample -> String
runClaferIGT :: MonadIO m => IGArgs -> ClaferIGT m a -> m (Either ClaferErrs a)
getAlloyModel :: MonadIO m => ClaferIGT m String
solve :: MonadIO m => ClaferIGT m ()
getClafers :: MonadIO m => ClaferIGT m [String]
getGlobalScope :: MonadIO m => ClaferIGT m Integer
getBitwidth :: MonadIO m => ClaferIGT m Integer
setGlobalScope :: MonadIO m => Integer -> ClaferIGT m ()
getScopes :: MonadIO m => ClaferIGT m [(String, Integer)]
getScope :: MonadIO m => QName -> ClaferIGT m ([String])
getQNameMaps :: MonadIO m => ClaferIGT m (QNameMaps)
valueOfScope :: MonadIO m => String -> ClaferIGT m Integer
increaseScope :: MonadIO m => Integer -> (String, Integer) -> ClaferIGT m (Either String ())
setScope :: MonadIO m => Integer -> (String, Integer) -> ClaferIGT m (Either String ())
setAlloyScope :: MonadIO m => Integer -> String -> ClaferIGT m (Either String ())
next :: MonadIO m => ClaferIGT m Instance
setUnsatCoreMinimization :: MonadIO m => Integer -> ClaferIGT m ()
setBitwidth :: MonadIO m => Integer -> ClaferIGT m ()
quit :: MonadIO m => ClaferIGT m ()
reload :: MonadIO m => ClaferIGT m (Either ClaferErrs ())
findRemovable :: ClaferEnv -> [Span] -> [Constraint] -> [Maybe Constraint]
fst3 :: (t, t1, t2) -> t
getlineNumMap :: Monad m => ClaferIGT m (Map Integer String)
strictReadFile :: FilePath -> IO String
sigToClaferName :: String -> String
instance Typeable IGArgs
instance MonadException m => MonadException (ClaferIGT m)
instance Show IGArgs
instance Data IGArgs
instance (Monad m, Functor m) => Applicative (ClaferIGT m)
instance Functor m => Functor (ClaferIGT m)
instance Monad m => Monad (ClaferIGT m)
instance MonadIO m => MonadIO (ClaferIGT m)
instance MonadTrans ClaferIGT

module Language.Clafer.IG.CommandLine

-- | Interactive session interface
runCommandLine :: ClaferIGT IO ()
printError :: ClaferErrs -> [String]
findNecessaryBitwidth :: IModule -> Integer -> [Integer] -> Integer
intToFloat :: Integer -> Float
pickLargerScope :: [(String, Integer)] -> (String, Integer) -> (String, Integer)

-- | the largest integer allowed by the given bitwidth
allowedMaxInt :: Integer -> Integer

-- | bitwidth required to store the given integer
requiredBitwidth :: Integer -> Integer
instance Show AutoComplete
