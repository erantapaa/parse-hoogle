-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monadic and object-oriented interfaces to DBus
--   
--   Monadic and object-oriented interfaces to DBus
@package dbus-client
@version 0.4.0.4

module DBus.Client

-- | <a>Client</a>s are opaque handles to an open connection and other
--   internal state.
data Client
data Connection :: *
clientName :: Client -> BusName

-- | Create a new <a>Client</a> from an open connection and bus name. The
--   weird signature allows <tt>newClient</tt> to use the computations in
--   <a>DBus.Bus</a> directly, without unpacking:
--   
--   <pre>
--   client &lt;- newClient =&lt;&lt; <a>getSessionBus</a>
--   </pre>
--   
--   Only one client should be created for any given connection. Otherwise,
--   they will compete to receive messages.
newClient :: (Connection, BusName) -> IO Client
data DBus a
data DBusException

-- | Run a DBus computation with the given client callbacks. Errors
--   encountered while running will be thrown as exceptions, using the
--   <a>DBusException</a> type.
--   
--   Use the <a>MonadError</a> instance for <a>DBus</a> to handle errors
--   inside the computation.
runDBus :: Client -> DBus a -> IO a
getClient :: DBus Client

-- | Run message handlers with the received message. If any method reply
--   callbacks or signal handlers are found, they will be run in the
--   current thread.
processMessage :: ReceivedMessage -> DBus ()

-- | A wrapper around <a>send</a>.
send :: Message msg => (Serial -> DBus a) -> msg -> DBus a

-- | A wrapper around <a>send</a>, which does not allow the message serial
--   to be recorded. This is a useful shortcut when sending messages which
--   are not expected to receive a reply.
send_ :: Message msg => msg -> DBus ()

-- | A wrapper around <a>receive</a>.
receive :: DBus ReceivedMessage

-- | Run in a loop forever, processing messages.
--   
--   This is commonly run in a separate thread, ie
--   
--   <pre>
--   client &lt;- newClient =&lt;&lt; getSessionBus
--   forkIO $ runDBus client mainLoop
--   </pre>
mainLoop :: DBus ()

-- | Perform an asynchronous method call. One of the provided computations
--   will be performed depending on what message type the destination sends
--   back.
call :: MethodCall -> (Error -> DBus ()) -> (MethodReturn -> DBus ()) -> DBus ()

-- | Sends a method call, and then blocks until a reply is received. Use
--   this when the receive/process loop is running in a separate thread.
callBlocking :: MethodCall -> DBus (Either Error MethodReturn)

-- | A variant of <a>callBlocking</a>, which throws an exception if the
--   remote client returns <a>Error</a>.
callBlocking_ :: MethodCall -> DBus MethodReturn

-- | Perform some computation every time this client receives a matching
--   signal.
onSignal :: MatchRule -> (BusName -> Signal -> DBus ()) -> DBus ()
data RequestNameFlag :: *
AllowReplacement :: RequestNameFlag
ReplaceExisting :: RequestNameFlag
DoNotQueue :: RequestNameFlag
data RequestNameReply :: *
PrimaryOwner :: RequestNameReply
InQueue :: RequestNameReply
Exists :: RequestNameReply
AlreadyOwner :: RequestNameReply
data ReleaseNameReply :: *
Released :: ReleaseNameReply
NonExistent :: ReleaseNameReply
NotOwner :: ReleaseNameReply
requestName :: BusName -> [RequestNameFlag] -> (Error -> DBus ()) -> (RequestNameReply -> DBus ()) -> DBus ()
releaseName :: BusName -> (Error -> DBus ()) -> (ReleaseNameReply -> DBus ()) -> DBus ()
requestName_ :: BusName -> [RequestNameFlag] -> DBus RequestNameReply
releaseName_ :: BusName -> DBus ReleaseNameReply
newtype Object
Object :: (Map InterfaceName Interface) -> Object
newtype Interface
Interface :: (Map MemberName Member) -> Interface
data Member
MemberMethod :: Method -> Member
MemberSignal :: Signature -> Member
data Method
Method :: Signature -> Signature -> (MethodCtx -> DBus ()) -> Method

-- | Export a set of interfaces on the bus. Whenever a method call is
--   received which matches the object's path, interface, and member name,
--   one of its members will be called.
--   
--   Exported objects automatically implement the
--   <tt>org.freedesktop.DBus.Introspectable</tt> interface.
export :: ObjectPath -> Object -> DBus ()
object :: [(InterfaceName, Interface)] -> Object
interface :: [(MemberName, Member)] -> Interface
method :: Signature -> Signature -> (MethodCtx -> DBus ()) -> Member
data MethodCtx
MethodCtx :: Object -> Method -> Serial -> Maybe BusName -> Set Flag -> [Variant] -> MethodCtx
methodCtxObject :: MethodCtx -> Object
methodCtxMethod :: MethodCtx -> Method
methodCtxSerial :: MethodCtx -> Serial
methodCtxSender :: MethodCtx -> Maybe BusName
methodCtxFlags :: MethodCtx -> Set Flag
methodCtxBody :: MethodCtx -> [Variant]

-- | Send a successful return reply for a method call.
replyReturn :: MethodCtx -> [Variant] -> DBus ()
replyError :: MethodCtx -> ErrorName -> [Variant] -> DBus ()
data Proxy
Proxy :: BusName -> ObjectPath -> InterfaceName -> Proxy
proxyName :: Proxy -> BusName
proxyObjectPath :: Proxy -> ObjectPath
proxyInterface :: Proxy -> InterfaceName

-- | As <a>call</a>, except that the proxy's information is used to build
--   the message.
callProxy :: Proxy -> MemberName -> [Flag] -> [Variant] -> (Error -> DBus ()) -> (MethodReturn -> DBus ()) -> DBus ()

-- | As <a>callBlocking</a>, except that the proxy's information is used to
--   build the message.
callProxyBlocking :: Proxy -> MemberName -> [Flag] -> [Variant] -> DBus (Either Error MethodReturn)

-- | As <a>callBlocking_</a>, except that the proxy's information is used
--   to build the message.
callProxyBlocking_ :: Proxy -> MemberName -> [Flag] -> [Variant] -> DBus MethodReturn

-- | As <tt>onSIgnal</tt>, except that the proxy's information is used to
--   build the match rule.
onProxySignal :: Proxy -> MemberName -> (Signal -> DBus ()) -> DBus ()
instance Typeable DBusException
instance Show Proxy
instance Eq Proxy
instance Show DBusException
instance Eq DBusException
instance MonadError DBus
instance Exception DBusException
instance Applicative DBus
instance Functor DBus
instance MonadIO DBus
instance Monad DBus
