-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Updated version of Yampa: a library for programming hybrid systems.
--   
--   A library for declarative programming of reactive systems. (Currently
--   a fork of Yampa 0.9.2.3)
@package Animas
@version 0.2


-- | Framework for record merging.
--   
--   Idea:
--   
--   MergeableRecord is intended to be a super class for classes providing
--   update operations on records. The ADT induced by such a set of
--   operations can be considered a <a>mergeable record</a>, which can be
--   merged into larger mergeable records essentially by function
--   composition. Finalization turns a mergeable record into a record.
--   
--   Typical use:
--   
--   Given
--   
--   <pre>
--   data Foo = Foo {l1 :: T1, l2 :: T2}
--   </pre>
--   
--   one define a mergeable record type (MR Foo) by the following instance:
--   
--   <pre>
--   instance MergeableRecord Foo where
--       mrDefault = Foo {l1 = v1_dflt, l2 = v2_dflt}
--   </pre>
--   
--   Typically, one would also provide definitions for setting the fields,
--   possibly (but not necessarily) overloaded:
--   
--   <pre>
--   instance HasL1 Foo where
--       setL1 v = mrMake (foo -&gt; foo {l1 = v})
--   </pre>
--   
--   Now Foo records can be created as follows:
--   
--   <pre>
--   let foo1 = setL1 v1
--   ...
--   let foo2 = setL2 v2 ~+~ foo1
--   ...
--   let foo<a>N</a> = setL1 vN ~+~ foo<a>N-1</a>
--   let fooFinal = mrFinalize foo<a>N</a>
--   </pre>
module FRP.Animas.MergeableRecord

-- | Typeclass for mergeable records
class MergeableRecord a
mrDefault :: MergeableRecord a => a

-- | Type constructor for mergeable records.
data MergeableRecord a => MR a

-- | Construction of a mergeable record.
mrMake :: MergeableRecord a => (a -> a) -> MR a

-- | Merge two mergeable records. Left "overrides" in case of conflict.
(~+~) :: MergeableRecord a => MR a -> MR a -> MR a

-- | Equivalent to '(~+~)' above.
mrMerge :: MergeableRecord a => MR a -> MR a -> MR a

-- | Finalization: turn a mergeable record into a record.
mrFinalize :: MergeableRecord a => MR a -> a


-- | Hyperstrict evaluation.
module FRP.Animas.Forceable

-- | Typeclass for values whose entire structure may be made strict
class Forceable a
force :: Forceable a => a -> a
instance Forceable a => Forceable (Maybe a)
instance Forceable a => Forceable [a]
instance (Forceable a, Forceable b, Forceable c, Forceable d, Forceable e) => Forceable (a, b, c, d, e)
instance (Forceable a, Forceable b, Forceable c, Forceable d) => Forceable (a, b, c, d)
instance (Forceable a, Forceable b, Forceable c) => Forceable (a, b, c)
instance (Forceable a, Forceable b) => Forceable (a, b)
instance Forceable Char
instance Forceable ()
instance Forceable Bool
instance Forceable Float
instance Forceable Double
instance Forceable Integer
instance Forceable Int


-- | Collection of entities that really should be part of the Haskell 98
--   prelude or simply have no better home.
--   
--   !!! Reverse function composition should go. !!! Better to use
--   <tt>&lt;&lt;&lt;</tt> and <tt>&gt;&gt;&gt;</tt> for, respectively, !!!
--   function composition and reverse function composition.
module FRP.Animas.Miscellany

-- | Reverse composition
(#) :: (a -> b) -> (b -> c) -> (a -> c)

-- | Duplicate a value into a pair
dup :: a -> (a, a)

-- | Swap the values in a pair
swap :: (a, b) -> (b, a)

-- | Apply a function to the first value in each pair in a list of pairs.
mapFst :: (a -> b) -> [(a, c)] -> [(b, c)]

-- | Above, but apply the function to the second value
mapSnd :: (a -> b) -> [(c, a)] -> [(c, b)]

-- | First value of a triple
sel3_1 :: (a, b, c) -> a

-- | Second value of a triple
sel3_2 :: (a, b, c) -> b

-- | Third value of a triple
sel3_3 :: (a, b, c) -> c

-- | First value of a quadruple
sel4_1 :: (a, b, c, d) -> a

-- | Second value of a quadruple
sel4_2 :: (a, b, c, d) -> b

-- | Third value of a quadruple
sel4_3 :: (a, b, c, d) -> c

-- | Fourth value of a quadruple
sel4_4 :: (a, b, c, d) -> d

-- | First value of a quintuple
sel5_1 :: (a, b, c, d, e) -> a

-- | Second value of a quintuple
sel5_2 :: (a, b, c, d, e) -> b

-- | Third value of a quintuple
sel5_3 :: (a, b, c, d, e) -> c

-- | Fourth value of a quintuple
sel5_4 :: (a, b, c, d, e) -> d

-- | Fifth value of a quintuple
sel5_5 :: (a, b, c, d, e) -> e

-- | Whole integer quotient
fDiv :: RealFrac a => a -> a -> Integer

-- | Remainder after whole integer quotient
fMod :: RealFrac a => a -> a -> a

-- | Whole integer quotient and remainder
fDivMod :: RealFrac a => a -> a -> (Integer, a)


-- | Definition of Animas Event type and functions on that type.
module FRP.Animas.Event

-- | Event type
data Event a
NoEvent :: Event a
Event :: a -> Event a

-- | Not an event
noEvent :: Event a

-- | Force the first item of a pair to not be an event
noEventFst :: (Event a, b) -> (Event c, b)

-- | Force the second item of a pair to not be an event
noEventSnd :: (a, Event b) -> (a, Event c)

-- | Internal: Convert a <a>Maybe</a> value to an event
maybeToEvent :: Maybe a -> Event a

-- | Apply a function to an event, or return a default value
event :: a -> (b -> a) -> Event b -> a

-- | Extract a value from an event. This function will produce an error if
--   applied to a NoEvent function
fromEvent :: Event a -> a

-- | Predicate: is a value an event occurence
isEvent :: Event a -> Bool

-- | Predicate: is a value not an event occurence
isNoEvent :: Event a -> Bool

-- | Replace a possible event occurence with a new occurence carrying a
--   replacement value
tag :: Event a -> b -> Event b

-- | See above
tagWith :: b -> Event a -> Event b

-- | Pair a value with an event occurrence's value, creating a new event
--   occurrence
attach :: Event a -> b -> Event (a, b)

-- | If both inputs are event occurrences, produce the left event.
lMerge :: Event a -> Event a -> Event a

-- | If both inputs are event occurences, produce the right event.
rMerge :: Event a -> Event a -> Event a

-- | If both inputs are event occurences, produce an error.
merge :: Event a -> Event a -> Event a

-- | If both inputs are event occurences, merge them with the supplied
--   function
mergeBy :: (a -> a -> a) -> Event a -> Event a -> Event a

-- | Apply functions to an event occurences from two sources
mapMerge :: (a -> c) -> (b -> c) -> (a -> b -> c) -> Event a -> Event b -> Event c

-- | Produce the event occurence closest to the head of the list, if one
--   exists.
mergeEvents :: [Event a] -> Event a

-- | From a list of event sources produce an event occurence with a list of
--   values of occurrences
catEvents :: [Event a] -> Event [a]

-- | If there is an occurence from both sources, produce an occurence with
--   both values.
joinE :: Event a -> Event b -> Event (a, b)

-- | Create a pair of event occurences from a single event occurence with a
--   pair of values
splitE :: Event (a, b) -> (Event a, Event b)

-- | Apply a predicate to event occurences and forward them only if it
--   matches
filterE :: (a -> Bool) -> Event a -> Event a

-- | Apply a <a>Maybe</a> function to event occurences, producing events
--   only for <a>Just</a> values.
mapFilterE :: (a -> Maybe b) -> Event a -> Event b

-- | Only pass through events if some external condition is true.
gate :: Event a -> Bool -> Event a
instance Forceable a => Forceable (Event a)
instance Functor Event
instance Ord a => Ord (Event a)
instance Eq a => Eq (Event a)


-- | An interface giving access to some of the internal details of the
--   Animas implementation.
--   
--   This interface is indended to be used when the need arises to break
--   abstraction barriers, e.g. for interfacing Animas to the real world,
--   for debugging purposes, or the like. Be aware that the internal
--   details may change. Relying on this interface means that your code is
--   not insulated against such changes.
module FRP.Animas.Internals

-- | Event type
data Event a
NoEvent :: Event a
Event :: a -> Event a
instance Show a => Show (Event a)


-- | Vector space type relation and basic instances.
module FRP.Animas.VectorSpace

-- | Type class for a vector space
class Floating a => VectorSpace v a | v -> a
zeroVector :: VectorSpace v a => v
(*^) :: VectorSpace v a => a -> v -> v
(^/) :: VectorSpace v a => v -> a -> v
negateVector :: VectorSpace v a => v -> v
(^+^) :: VectorSpace v a => v -> v -> v
(^-^) :: VectorSpace v a => v -> v -> v
dot :: VectorSpace v a => v -> v -> a
norm :: VectorSpace v a => v -> a
normalize :: VectorSpace v a => v -> v
instance Floating a => VectorSpace (a, a, a, a, a) a
instance Floating a => VectorSpace (a, a, a, a) a
instance Floating a => VectorSpace (a, a, a) a
instance Floating a => VectorSpace (a, a) a
instance VectorSpace Double Double
instance VectorSpace Float Float


-- | Affine space type relation.
module FRP.Animas.AffineSpace

-- | Typeclass for an Affine space. Minimal complete definition:
--   <a>origin</a>, '(.+^)', '(.-.)'
class (Floating a, VectorSpace v a) => AffineSpace p v a | p -> v, v -> a
origin :: AffineSpace p v a => p
(.+^) :: AffineSpace p v a => p -> v -> p
(.-^) :: AffineSpace p v a => p -> v -> p
(.-.) :: AffineSpace p v a => p -> p -> v
distance :: AffineSpace p v a => p -> p -> a


-- | 2D vector abstraction (R^2).
--   
--   ToDo: Deriving Show, or provide dedicated show instance?
module FRP.Animas.Vector2

-- | 2-dimensional vector type
data RealFloat a => Vector2 a

-- | Create a 2D vector
--   
--   Obtain the X-magnitude of a vector
vector2 :: RealFloat a => a -> a -> Vector2 a

-- | Obtain the Y-magnitude of a vector
vector2X :: RealFloat a => Vector2 a -> a

-- | Obtain the X and Y magnitudes of a vector as an ordered pair
vector2Y :: RealFloat a => Vector2 a -> a

-- | Create a vector from polar coordinates (magnitude<i>rho,
--   direction</i>theta (radians))
vector2XY :: RealFloat a => Vector2 a -> (a, a)

-- | Obtain the magnitude of a vector
vector2Polar :: RealFloat a => a -> a -> Vector2 a

-- | Obtain the direction of a vector
vector2Rho :: RealFloat a => Vector2 a -> a

-- | Obtain the magnitude and direction of a vector as an ordered pair
vector2Theta :: RealFloat a => Vector2 a -> a
vector2RhoTheta :: RealFloat a => Vector2 a -> (a, a)
vector2Rotate :: RealFloat a => a -> Vector2 a -> Vector2 a
instance RealFloat a => Eq (Vector2 a)
instance RealFloat a => Show (Vector2 a)
instance RealFloat a => Forceable (Vector2 a)
instance RealFloat a => VectorSpace (Vector2 a) a


-- | 3D vector abstraction (R^3).
--   
--   ToDo: Deriving Show, or provide dedicated show instance?
module FRP.Animas.Vector3

-- | 3-dimensional vector
data RealFloat a => Vector3 a

-- | Construct a 3 dimensional vector
vector3 :: RealFloat a => a -> a -> a -> Vector3 a

-- | X magnitude of the vector
vector3X :: RealFloat a => Vector3 a -> a

-- | Y magnitude of the vector
vector3Y :: RealFloat a => Vector3 a -> a

-- | Z magnitude of the vector
vector3Z :: RealFloat a => Vector3 a -> a

-- | Ordered pair of magnitudes of the vector
vector3XYZ :: RealFloat a => Vector3 a -> (a, a, a)

-- | Spherical coordinates to vector
vector3Spherical :: RealFloat a => a -> a -> a -> Vector3 a

-- | Magnitude of a vector
vector3Rho :: RealFloat a => Vector3 a -> a

-- | Theta-direction of a vector
vector3Theta :: RealFloat a => Vector3 a -> a

-- | Phi-direction of a vector
vector3Phi :: RealFloat a => Vector3 a -> a

-- | Magnitude and directions of a vector as an ordered triple
vector3RhoThetaPhi :: RealFloat a => Vector3 a -> (a, a, a)

-- | Rotate a vector
vector3Rotate :: RealFloat a => a -> a -> Vector3 a -> Vector3 a
instance RealFloat a => Eq (Vector3 a)
instance RealFloat a => Show (Vector3 a)
instance RealFloat a => Forceable (Vector3 a)
instance RealFloat a => VectorSpace (Vector3 a) a


-- | 2D point abstraction (R^2).
--   
--   ToDo: Deriving Show, or provide dedicated show instance?
module FRP.Animas.Point2

-- | Two-dimensional real-valued point
data RealFloat a => Point2 a
Point2 :: !a -> !a -> Point2 a

-- | X coordinate
point2X :: RealFloat a => Point2 a -> a

-- | Y coordinate
point2Y :: RealFloat a => Point2 a -> a
instance RealFloat a => Eq (Point2 a)
instance RealFloat a => Show (Point2 a)
instance RealFloat a => Forceable (Point2 a)
instance RealFloat a => AffineSpace (Point2 a) (Vector2 a) a


-- | 3D point abstraction (R^3).
module FRP.Animas.Point3

-- | 3-dimensional, real-valued point
data RealFloat a => Point3 a
Point3 :: !a -> !a -> !a -> Point3 a

-- | X coordinate
point3X :: RealFloat a => Point3 a -> a

-- | Y coordinate
point3Y :: RealFloat a => Point3 a -> a

-- | Z coordinate
point3Z :: RealFloat a => Point3 a -> a
instance RealFloat a => Eq (Point3 a)
instance RealFloat a => Forceable (Point3 a)
instance RealFloat a => AffineSpace (Point3 a) (Vector3 a) a


-- | Basic geometrical abstractions.
module FRP.Animas.Geometry


module FRP.Animas

-- | The class <a>RandomGen</a> provides a common interface to random
--   number generators.
--   
--   Minimal complete definition: <a>next</a> and <a>split</a>.
class RandomGen g
next :: RandomGen g => g -> (Int, g)
split :: RandomGen g => g -> (g, g)
genRange :: RandomGen g => g -> (Int, Int)

-- | With a source of random number supply in hand, the <a>Random</a> class
--   allows the programmer to extract random values of a variety of types.
--   
--   Minimal complete definition: <a>randomR</a> and <a>random</a>.
class Random a
randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
random :: (Random a, RandomGen g) => g -> (a, g)
randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
randoms :: (Random a, RandomGen g) => g -> [a]
randomRIO :: Random a => (a, a) -> IO a
randomIO :: Random a => IO a

-- | Reverse composition
(#) :: (a -> b) -> (b -> c) -> (a -> c)

-- | Duplicate a value into a pair
dup :: a -> (a, a)

-- | Swap the values in a pair
swap :: (a, b) -> (b, a)

-- | Time representation for signal functions
type Time = Double
type DTime = Double

-- | A signal function
data SF a b

-- | Event type
data Event a
NoEvent :: Event a
Event :: a -> Event a

-- | Lifts a function to a pure signal function. Use <a>arr</a> from the
--   <a>Arrow</a> class, rather than this function.
arrPrim :: (a -> b) -> SF a b

-- | Lifts a function with an event input to a pure signal function on
--   events. Use <a>arr</a> from the <a>Arrow</a> class, rather than this
--   function.
arrEPrim :: (Event a -> b) -> SF (Event a) b

-- | The identity signal function. Use in place of
--   
--   <pre>
--   arr id
--   </pre>
identity :: SF a a

-- | The constant signal function. Use
--   
--   <pre>
--   constant x
--   </pre>
--   
--   in place of
--   
--   <pre>
--   arr $ const x
--   </pre>
constant :: b -> SF a b

-- | The time of this part of the signal graph. Note that if a signal
--   function is switched in, the time is relative to the moment of
--   switching, not the moment that animation started.
localTime :: SF a Time

-- | identical to <a>localTime</a>
time :: SF a Time

-- | Override the output value for a signal function at the first instant
--   it is processed
(-->) :: b -> SF a b -> SF a b

-- | Override the input value for a signal function at the first instant it
--   is processed.
(>--) :: a -> SF a b -> SF a b

-- | Apply a function to the output at the first instant of a signal
--   function
(-=>) :: (b -> b) -> SF a b -> SF a b

-- | Apply a function to the input at the first instant of a signal
--   function
(>=-) :: (a -> a) -> SF a b -> SF a b

-- | Output a value at the first instant, and forever after pass the input
--   value through
initially :: a -> SF a a

-- | Signal function: apply a function to an accumulator at each instant.
--   Note that the output value is the value of the accumulator at each
--   instant.
sscan :: (b -> a -> b) -> b -> SF a b
sscanPrim :: (c -> a -> Maybe (c, b)) -> c -> b -> SF a b

-- | Never produce an event
never :: SF a (Event b)

-- | Produce an event immediately (at the moment of switching in or
--   animation) and never again.
now :: b -> SF a (Event b)

-- | Produce an event delayed by some time.
after :: Time -> b -> SF a (Event b)

-- | Produce event every so often (but not immediately)
repeatedly :: Time -> b -> SF a (Event b)

-- | Takes a list of time delays and values to a signal function producing
--   events.
afterEach :: [(Time, b)] -> SF a (Event b)
afterEachCat :: [(Time, b)] -> SF a (Event [b])

-- | Produce an event whenever the input goes from <a>False</a> to
--   <a>True</a>
edge :: SF Bool (Event ())
iEdge :: Bool -> SF Bool (Event ())

-- | Produce an event carrying a specified value whenever the input goes
--   from <a>False</a> to <a>True</a>
edgeTag :: a -> SF Bool (Event a)

-- | Produce the value carried by the Maybe whenever the input goes from
--   <a>Nothing</a> to <a>Just</a>
edgeJust :: SF (Maybe a) (Event a)

-- | Compare the input at the current and previous instant and produce an
--   event based on the comparison
edgeBy :: (a -> a -> Maybe b) -> a -> SF a (Event b)

-- | Suppress all but the first event passing through
once :: SF (Event a) (Event a)

-- | Not an event
noEvent :: Event a

-- | Force the first item of a pair to not be an event
noEventFst :: (Event a, b) -> (Event c, b)

-- | Force the second item of a pair to not be an event
noEventSnd :: (a, Event b) -> (a, Event c)

-- | Delay events passing through
delayEvent :: Time -> SF (Event a) (Event a)
delayEventCat :: Time -> SF (Event a) (Event [a])

-- | Only permit a certain number of events
takeEvents :: Int -> SF (Event a) (Event a)

-- | Suppress a certain number of initial events
dropEvents :: Int -> SF (Event a) (Event a)

-- | Suppress a possible event at the instant of animation or switching in
notYet :: SF (Event a) (Event a)

-- | For backwards compatibility only.
old_hold :: a -> SF (Event a) a

-- | Output the initial value or the value of the last event.
hold :: a -> SF (Event a) a

-- | Decoupled version of <a>hold</a>. Begins outputting event value the
--   instant after the event occurence.
dHold :: a -> SF (Event a) a

-- | Hold the value of a <a>Maybe</a> input.
trackAndHold :: a -> SF (Maybe a) a

-- | For backwards compatability only.
old_accum :: a -> SF (Event (a -> a)) (Event a)

-- | For backwards compatibility only.
old_accumBy :: (b -> a -> b) -> b -> SF (Event a) (Event b)

-- | For backwards compatibility only.
old_accumFilter :: (c -> a -> (c, Maybe b)) -> c -> SF (Event a) (Event b)

-- | Apply a function carried by an event to an accumulator, producing an
--   event with the new value of the accumulator.
accum :: a -> SF (Event (a -> a)) (Event a)

-- | As with <a>accum</a> but output the value of the accumulator.
accumHold :: a -> SF (Event (a -> a)) a

-- | Decoupled version of <a>accumHold</a>. Updated accumulator values
--   begin output at the instant <i>after</i> the updating event.
dAccumHold :: a -> SF (Event (a -> a)) a

-- | Provide a function and initial accumulator to process events, produce
--   each new accumulator vale as an event.
accumBy :: (b -> a -> b) -> b -> SF (Event a) (Event b)

-- | As in <a>accumBy</a> but produce the accumulator value as a continuous
--   signal.
accumHoldBy :: (b -> a -> b) -> b -> SF (Event a) b

-- | Decoupled version of <a>accumHoldBy</a>. Output signal changes at the
--   instant <i>after</i> an event.
dAccumHoldBy :: (b -> a -> b) -> b -> SF (Event a) b

-- | Filter events with an accumulator.
accumFilter :: (c -> a -> (c, Maybe b)) -> c -> SF (Event a) (Event b)

-- | Apply a function to an event, or return a default value
event :: a -> (b -> a) -> Event b -> a

-- | Extract a value from an event. This function will produce an error if
--   applied to a NoEvent function
fromEvent :: Event a -> a

-- | Predicate: is a value an event occurence
isEvent :: Event a -> Bool

-- | Predicate: is a value not an event occurence
isNoEvent :: Event a -> Bool

-- | Replace a possible event occurence with a new occurence carrying a
--   replacement value
tag :: Event a -> b -> Event b

-- | See above
tagWith :: b -> Event a -> Event b

-- | Pair a value with an event occurrence's value, creating a new event
--   occurrence
attach :: Event a -> b -> Event (a, b)

-- | If both inputs are event occurrences, produce the left event.
lMerge :: Event a -> Event a -> Event a

-- | If both inputs are event occurences, produce the right event.
rMerge :: Event a -> Event a -> Event a

-- | If both inputs are event occurences, produce an error.
merge :: Event a -> Event a -> Event a

-- | If both inputs are event occurences, merge them with the supplied
--   function
mergeBy :: (a -> a -> a) -> Event a -> Event a -> Event a

-- | Apply functions to an event occurences from two sources
mapMerge :: (a -> c) -> (b -> c) -> (a -> b -> c) -> Event a -> Event b -> Event c

-- | Produce the event occurence closest to the head of the list, if one
--   exists.
mergeEvents :: [Event a] -> Event a

-- | From a list of event sources produce an event occurence with a list of
--   values of occurrences
catEvents :: [Event a] -> Event [a]

-- | If there is an occurence from both sources, produce an occurence with
--   both values.
joinE :: Event a -> Event b -> Event (a, b)

-- | Create a pair of event occurences from a single event occurence with a
--   pair of values
splitE :: Event (a, b) -> (Event a, Event b)

-- | Apply a predicate to event occurences and forward them only if it
--   matches
filterE :: (a -> Bool) -> Event a -> Event a

-- | Apply a <a>Maybe</a> function to event occurences, producing events
--   only for <a>Just</a> values.
mapFilterE :: (a -> Maybe b) -> Event a -> Event b

-- | Only pass through events if some external condition is true.
gate :: Event a -> Bool -> Event a

-- | Switch in a new signal function produced from an event, at the instant
--   of that event.
switch :: SF a (b, Event c) -> (c -> SF a b) -> SF a b

-- | Decoupled version of <a>switch</a>.
dSwitch :: SF a (b, Event c) -> (c -> SF a b) -> SF a b

-- | Switches in new signal functions carried by input events.
rSwitch :: SF a b -> SF (a, Event (SF a b)) b

-- | Decoupled version of <tt>rswitch</tt>
drSwitch :: SF a b -> SF (a, Event (SF a b)) b

-- | Continuation based switching (undocumented)
kSwitch :: SF a b -> SF (a, b) (Event c) -> (SF a b -> c -> SF a b) -> SF a b

-- | Decoupled version of <tt>kswitch</tt>
dkSwitch :: SF a b -> SF (a, b) (Event c) -> (SF a b -> c -> SF a b) -> SF a b

-- | Broadcast the same output to a collection of signal functions,
--   producing a collection of outputs.
parB :: Functor col => col (SF a b) -> SF a (col b)

-- | Take a single input and broadcast it to a collection of functions,
--   until an event is triggered, then switch into another SF producing a
--   collection of outputs
pSwitchB :: Functor col => col (SF a b) -> SF (a, col b) (Event c) -> (col (SF a b) -> c -> SF a (col b)) -> SF a (col b)

-- | <a>pSwitchB</a>, but switched output is visible on the sample frame
--   after the event occurs
dpSwitchB :: Functor col => col (SF a b) -> SF (a, col b) (Event c) -> (col (SF a b) -> c -> SF a (col b)) -> SF a (col b)

-- | Broadcast intput to a collection of signal functions, and transform
--   that collection with mutator functions carried in events
rpSwitchB :: Functor col => col (SF a b) -> SF (a, Event (col (SF a b) -> col (SF a b))) (col b)

-- | <a>rpSwitchB</a>, but switched output is visible on the sample frame
--   after the event occurs
drpSwitchB :: Functor col => col (SF a b) -> SF (a, Event (col (SF a b) -> col (SF a b))) (col b)

-- | Route input to a static collection of signal functions
par :: Functor col => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF a (col c)

-- | Like <a>par</a>, but takes an extra SF which looks at the input and
--   output of the parallel switching combinator and switches in a new SF
--   at that point
pSwitch :: Functor col => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)

-- | <a>pSwitch</a>, but the output from the switched-in signal function is
--   visible | in the sample frame after the event.
dpSwitch :: Functor col => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)

-- | Dynamic collections of signal functions with a routing function
rpSwitch :: Functor col => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, Event (col (SF b c) -> col (SF b c))) (col c)

-- | <a>rpSwitch</a>, but the output of a switched-in SF is visible in the
--   sample frame after the switch
drpSwitch :: Functor col => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, Event (col (SF b c) -> col (SF b c))) (col c)

-- | For backwards compatibility only.
old_pre :: SF a a

-- | For backwards compatibility only.
old_iPre :: a -> SF a a

-- | Uninitialized one-instant delay.
pre :: SF a a

-- | Iniitialized one-instant delay
iPre :: a -> SF a a

-- | Delay a (non-event) signal by a specific time offsent. For events
--   please use <a>delayEvent</a>.
delay :: Time -> a -> SF a a

-- | Integrate a signal with respect to time.
integral :: VectorSpace a s => SF a a
derivative :: VectorSpace a s => SF a a
imIntegral :: VectorSpace a s => a -> SF a a
loopPre :: c -> SF (a, c) (b, c) -> SF a b
loopIntegral :: VectorSpace c s => SF (a, c) (b, c) -> SF a b
noise :: (RandomGen g, Random b) => g -> SF a b
noiseR :: (RandomGen g, Random b) => (b, b) -> g -> SF a b
occasionally :: RandomGen g => g -> Time -> b -> SF a (Event b)
type ReactHandle a b = IORef (ReactState a b)
reactimate :: IO a -> (Bool -> IO (DTime, Maybe a)) -> (Bool -> b -> IO Bool) -> SF a b -> IO ()
reactInit :: IO a -> (ReactHandle a b -> Bool -> b -> IO Bool) -> SF a b -> IO (ReactHandle a b)
react :: ReactHandle a b -> (DTime, Maybe a) -> IO Bool
embed :: SF a b -> (a, [(DTime, Maybe a)]) -> [b]
embedSynch :: SF a b -> (a, [(DTime, Maybe a)]) -> SF Double b
deltaEncode :: Eq a => DTime -> [a] -> (a, [(DTime, Maybe a)])
deltaEncodeBy :: (a -> a -> Bool) -> DTime -> [a] -> (a, [(DTime, Maybe a)])

-- | A step in evaluating a signal function
data Step a b

-- | Initialize a signal function for stepping through
initStep :: a -> SF a b -> (b, Step a b)

-- | Go to the next step of a signal function
step :: DTime -> a -> Step a b -> (b, Step a b)
instance ArrowLoop SF
instance Arrow SF
instance Category SF


-- | Derived utility definitions.
--   
--   ToDo:
--   
--   <ul>
--   <li>Possibly add impulse :: VectorSpace a k =&gt; a -&gt; Event a But
--   to do that, we need access to Event, which we currently do not
--   have.</li>
--   <li>The general arrow utilities should be moved to a module
--   FRP.Animas.Utilities.</li>
--   <li>I'm not sure structuring the Animas "core" according to what is
--   core functionality and what's not is all that useful. There are many
--   cases where we want to implement combinators that fairly easily could
--   be implemented in terms of others as primitives simply because we
--   expect that that implementation is going to be much more efficient,
--   and that the combinators are used sufficiently often to warrant doing
--   this. E.g. <a>switch</a> should be a primitive, even though it could
--   be derived from <a>pSwitch</a>.</li>
--   <li>Reconsider <a>recur</a>. If an event source has an immediate
--   occurrence, we'll get into a loop. For example: recur now. Maybe
--   suppress initial occurrences? Initial occurrences are rather pointless
--   in this case anyway.</li>
--   </ul>
module FRP.Animas.Utilities
arr2 :: Arrow a => (b -> c -> d) -> a (b, c) d
arr3 :: Arrow a => (b -> c -> d -> e) -> a (b, c, d) e
arr4 :: Arrow a => (b -> c -> d -> e -> f) -> a (b, c, d, e) f
arr5 :: Arrow a => (b -> c -> d -> e -> f -> g) -> a (b, c, d, e, f) g
lift0 :: Arrow a => c -> a b c
lift1 :: Arrow a => (c -> d) -> (a b c -> a b d)
lift2 :: Arrow a => (c -> d -> e) -> (a b c -> a b d -> a b e)
lift3 :: Arrow a => (c -> d -> e -> f) -> (a b c -> a b d -> a b e -> a b f)
lift4 :: Arrow a => (c -> d -> e -> f -> g) -> (a b c -> a b d -> a b e -> a b f -> a b g)
lift5 :: Arrow a => (c -> d -> e -> f -> g -> h) -> (a b c -> a b d -> a b e -> a b f -> a b g -> a b h)

-- | Produce an event with the input value at time 0
snap :: SF a (Event a)

-- | Produce an event with the input value at or as soon after the
--   specified time delay.
snapAfter :: Time -> SF a (Event a)

-- | Sample a signal at regular intervals.
sample :: Time -> SF a (Event a)

-- | Restart an event source directly after its first event occurence
recur :: SF a (Event b) -> SF a (Event b)

-- | Start a second event source as soon as the first produces an event.
--   (When used infix, andThen is right associative, so, for instance, x
--   <a>andThen</a> y <a>andThen</a> z will produce the first event of x,
--   then of y, then of z.
andThen :: SF a (Event b) -> SF a (Event b) -> SF a (Event b)
sampleWindow :: Int -> Time -> SF a (Event [a])
parZ :: [SF a b] -> SF [a] [b]
pSwitchZ :: [SF a b] -> SF ([a], [b]) (Event c) -> ([SF a b] -> c -> SF [a] [b]) -> SF [a] [b]
dpSwitchZ :: [SF a b] -> SF ([a], [b]) (Event c) -> ([SF a b] -> c -> SF [a] [b]) -> SF [a] [b]
rpSwitchZ :: [SF a b] -> SF ([a], Event ([SF a b] -> [SF a b])) [b]
drpSwitchZ :: [SF a b] -> SF ([a], Event ([SF a b] -> [SF a b])) [b]

-- | Run one SF if a predicate is true, otherwise run another SF.
provided :: (a -> Bool) -> SF a b -> SF a b -> SF a b
old_dHold :: a -> SF (Event a) a

-- | Decoupled track and hold: on occurence of a <a>Just</a> input, the
--   <i>next</i> output is the value of the <a>Just</a> value.
dTrackAndHold :: a -> SF (Maybe a) a
old_accumHold :: a -> SF (Event (a -> a)) a
old_dAccumHold :: a -> SF (Event (a -> a)) a
old_accumHoldBy :: (b -> a -> b) -> b -> SF (Event a) b
old_dAccumHoldBy :: (b -> a -> b) -> b -> SF (Event a) b

-- | Count the number of event occurences, producing a new event occurence
--   with each updated count.
count :: Integral b => SF (Event a) (Event b)
fby :: b -> SF a b -> SF a b
impulseIntegral :: VectorSpace a k => SF (a, Event a) a
old_impulseIntegral :: VectorSpace a k => SF (a, Event a) a


-- | Task abstraction on top of signal transformers.
module FRP.Animas.Task
data Task a b c
mkTask :: SF a (b, Event c) -> Task a b c
runTask :: Task a b c -> SF a (Either b c)
runTask_ :: Task a b c -> SF a b
taskToSF :: Task a b c -> SF a (b, Event c)
constT :: b -> Task a b c
sleepT :: Time -> b -> Task a b ()
snapT :: Task a b a
timeOut :: Task a b c -> Time -> Task a b (Maybe c)
abortWhen :: Task a b c -> SF a (Event d) -> Task a b (Either c d)
repeatUntil :: Monad m => m a -> (a -> Bool) -> m a
for :: Monad m => a -> (a -> a) -> (a -> Bool) -> m b -> m ()
forAll :: Monad m => [a] -> (a -> m b) -> m ()
forEver :: Monad m => m a -> m b
instance Monad (Task a b)
