-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Graphical modeling tools for sequential teams
--   
--   Graphical modeling tools for sequential teams
@package teams
@version 0.0.2.1


-- | This Haskell library implements the algorithm for simplifying
--   sequential teams presented
--   
--   Aditya Mahajan and Sekhar Tatikonda, A graphical modeling approach to
--   simplifying sequential teams, proceedings of 7th International
--   Symposium on Modeling and Optimization in Mobile, Ad Hoc, and Wireless
--   Networks (WiOpt), Control over Communication Channels (ConCom)
--   Workshop, Seoul, South Korea, June 27, 2009.
--   
--   The paper can be obtained from
--   <a>http://pantheon.yale.edu/~am894/publications.html#concom-2009</a>.
--   See <a>http://pantheon.yale.edu/~am894/code/teams/</a> for a usage
--   example.
--   
--   A team is a multi-agent stochastic control problem in which all agents
--   have a common objective. A team is sequential if and only if there is
--   a partial order between all the system variables. These partial order
--   relationship can be represented using a directed graph, in particular,
--   using a directed factor graph. The variable nodes of the factor graph
--   represent the system variables and the factor nodes represent the
--   system dynamics and control functions. The structural results for
--   these system are equivalent to simplification of the factor graph. An
--   automated algorithm for graph simplification is presented in the
--   <a>Data.Teams.Structure</a> module.
module Data.Teams.Graph

-- | A type class for defining operations on all nodes
class Vertex a
name :: (Vertex a) => a -> String
names :: (Vertex a) => [a] -> String
isReward :: (Vertex a) => a -> Bool
isNonReward :: (Vertex a) => a -> Bool
isVariable :: (Vertex a) => a -> Bool
isStochastic :: (Vertex a) => a -> Bool
isDeterministic :: (Vertex a) => a -> Bool
isControl :: (Vertex a) => a -> Bool
isFactor :: (Vertex a) => a -> Bool
attribute :: (Vertex a) => a -> [Attribute]

-- | Time
type Time = Int

-- | Variable nodes
data Variable

-- | Reward variable node
Reward :: String -> Variable

-- | Non reard variable node
NonReward :: String -> Variable

-- | Factor Vertexs
data Factor

-- | Factor node representing deterministic system dynamics
Deterministic :: String -> Factor

-- | Factor node representing stochastic system dynamics
Stochastic :: String -> Factor

-- | Factor node representing control function
Control :: String -> Factor

-- | A generic node of a graph
type Node = Either Factor Variable

-- | An edge in a graph
type Edge = (Node, Node, EdgeType)

-- | Currently all edges are Influence edges. Future versions will have
--   belief edges.
data EdgeType
Influence :: EdgeType
Belief :: EdgeType

-- | A sequential team as a directed acyclic factor graph (DAFG)
type Team = Gr Node EdgeType

-- | Create a sequence of nodes of a specific type
mkVertex :: (String -> a) -> String -> Time -> a

-- | Create a sequence of reward nodes
mkReward :: String -> Time -> Variable

-- | Create a sequence of non reward nodes
mkNonReward :: String -> Time -> Variable

-- | Create a sequence of control nodes
mkControl :: String -> Time -> Factor

-- | Create a sequence of deterministic system dynamics nodes
mkDeterministic :: String -> Time -> Factor

-- | Create a sequence of stochastic system dynamics nodes
mkStochastic :: String -> Time -> Factor

-- | Used with <tt>(.|.)</tt> to specify relation between the nodes. For
--   example, if <tt>x</tt> is a function of <tt>y</tt> and <tt>z</tt>, we
--   can write
--   
--   <tt>f.$.(x.|.[y,z])</tt>.
(.$.) :: Factor -> (Variable, [Variable]) -> [Edge]

-- | Used with <tt>(.$.)</tt> to specify relation between the nodes. For
--   example, if <tt>x</tt> is a function of <tt>y</tt> and <tt>z</tt>, we
--   can write
--   
--   <tt>f.$.(x.|.[y,z])</tt>.
(.|.) :: Variable -> [Variable] -> (Variable, [Variable])

-- | Construct a DAFG from a set of edges. For example,
--   
--   <pre>
--   f = <a>Control</a> "f"
--   x = <a>Reward</a>  "x"
--   y = <a>NonReward</a> "y"
--   z = <a>NonReward</a> "z"
--   g = mkTeam $ f.$.(x.|.[y,z])
--   </pre>
mkTeam :: [Edge] -> Team

-- | To make a time homogeneous system. As an example, an MDP can be
--   created as follows
--   
--   <pre>
--   x = <a>mkNonReward</a> "x"
--   u = <a>mkNonReward</a> "u"
--   r = <a>mkReward</a>    "r"
--   
--   f = <a>mkStochastic</a>  "f"
--   g = <a>mkControl</a>     "g"
--   d = <a>mkStochastic</a>  "d"
--   
--   dynamics t =  f(t-1).$.( x(t) .|. if t == 1 then [] else [x(t-1), u(t-1)] )
--             ++  g(t)  .$.( u(t) .|. map x[1..t] ++ map u[1..t-1]    )
--             ++  d(t)  .$.( r(t) .|. [ x(t), u(t) ]                  )
--   
--   mdp = <a>mkTeamTime</a> dynamics 3
--   </pre>
mkTeamTime :: (Time -> [Edge]) -> Time -> Team
mkTeamTimeBy :: [Edge] -> (Time -> [Edge]) -> (Time -> [Edge]) -> Time -> Team

-- | Select nodes whose label satisfy a particular predicate
selNodes :: (Graph gr) => (a -> Bool) -> gr a b -> [Node]

-- | All variable nods
variables :: Team -> [Node]

-- | All reward nodes
rewards :: Team -> [Node]

-- | All factors
factors :: Team -> [Node]

-- | All control factors
controls :: Team -> [Node]

-- | find indices of parents from the index of a node
parents :: Team -> Node -> [Node]

-- | find indices of children from the index of a node
children :: Team -> Node -> [Node]

-- | find indices of ancestors from the index of a node
ancestors :: Team -> Node -> [Node]

-- | find the indices of the ancestoral set from the indices of a given
--   set.
ancestoral :: Team -> [Node] -> [Node]

-- | find indices of descendants from the index of a node
descendants :: Team -> Node -> [Node]

-- | find the indices of future nodes that satisfy a particular predicate
futureNodes :: Team -> (Node -> Bool) -> Node -> [Node]

-- | find the indices of past nodes that satisfy a particular predicate
pastNodes :: Team -> (Node -> Bool) -> Node -> [Node]

-- | Pretty print the team specification
printTeam :: Team -> IO ()

-- | Pretty print the team specification
showTeam :: Team -> String

-- | Convert the graph to a dot file
graphToDot :: Team -> DotGraph

-- | Convert the dot file to a pdf
printGraph :: Team -> FilePath -> IO Bool

-- | Extensions of Data.Graph.Inductive
--   
--   Label of a particular node
label :: (Graph gr) => gr a b -> Node -> a

-- | Labels of a list of nodes
labels :: (Graph gr) => gr a b -> [Node] -> [a]
instance Eq EdgeType
instance Ord EdgeType
instance Show EdgeType
instance Eq Factor
instance Ord Factor
instance Show Factor
instance Eq Variable
instance Ord Variable
instance Show Variable
instance (Vertex a, Vertex b) => Vertex (Either a b)
instance Vertex Factor
instance Vertex Variable


-- | This module implments an automated algortihm to simplify sequential
--   teams. The simplification is based on conditional independences.
--   Conditional independence is checked using the Bayes Ball algorithm
--   <a>http://citeseer.ist.psu.edu/old/399661.html</a>
module Data.Teams.Structure

-- | Requisite observations The observation nodes are thouse nodes in the
--   condition that are marked as visited
observations :: Team -> [Node] -> [Node] -> [Node]

-- | Irrelevant nodes The nodes that have not been visited from their
--   parents are irrelevant
irrelevant :: Team -> [Node] -> [Node] -> [Node]

-- | Functionally determined nodes Nodes that are irrelevant when we want
--   to know about all variable nodes
determined :: Team -> [Node] -> [Node]

-- | Effectively observed nodes All the ancestors of the reward nodes that
--   are functionally determined by conditioned nodes.
effective :: Team -> [Node] -> [Node] -> [Node]

-- | The graph restructuring algorithm of the paper.
simplifyAt :: Team -> Node -> Team

-- | Simplify all nodes of the graph once
simplifyOnce :: Team -> Team

-- | The graph simplification aglorithm of the paper I believe that this
--   algorithm will always converge. So, I do not stop the loop after a
--   finite number of iterations. If you find an example that does not
--   converge, please let me know.
simplify :: Team -> Team
instance Eq Marked
instance Ord Marked
instance Show Marked
instance Eq Visit
instance Ord Visit
instance Show Visit
instance Eq Schedule
instance Ord Schedule
instance Show Schedule
instance Eq Mark
instance Ord Mark
instance Show Mark
instance (Initializable a, Initializable b) => Initializable (Either a b)
instance Initializable Factor
instance Initializable Variable


-- | Real time source coding Based on Hans S. Witsenhausen "On the
--   structure of real-time source coders," Bell Systems Technical Journal,
--   vol 58, no 6, pp 1437-1451, July-August 1979
module Data.Teams.Examples.Wit79


-- | Decentralized MDP Based on an email exchange with Ashutosh Nayyar
module Data.Teams.Examples.DecMdp


-- | Multiaccess broadcast Based on the example in Aditya Mahajan, Ashutosh
--   Nayyar, and Demosthenis Teneketzis, "Identifying tractable
--   decentralized problems on the basis of information structures,"
--   Proceedings of the 46th annual Allerton conference on communication,
--   control, and computing, pp. 1440-1449, Monticello, IL, September
--   23-26, 2008.
module Data.Teams.Examples.MAB
