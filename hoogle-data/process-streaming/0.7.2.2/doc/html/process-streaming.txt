-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Streaming interface to system processes.
--   
@package process-streaming
@version 0.7.2.2


-- | Lenses and traversals for <a>CreateProcess</a> and related types.
--   
--   These are provided as a convenience and aren't required to use the
--   other modules of the package.
module System.Process.Lens

-- | <pre>
--   _cmdspec :: Lens' CreateProcess CmdSpec 
--   </pre>
_cmdspec :: Functor f => (CmdSpec -> f CmdSpec) -> CreateProcess -> f CreateProcess

-- | <pre>
--   _ShellCommand :: Prism' CmdSpec String
--   </pre>
_ShellCommand :: Applicative m => (String -> m String) -> CmdSpec -> m CmdSpec

-- | <pre>
--   _RawCommand :: Prism' CmdSpec (FilePath,[String])
--   </pre>
_RawCommand :: Applicative m => ((FilePath, [String]) -> m (FilePath, [String])) -> CmdSpec -> m CmdSpec

-- | <pre>
--   _cwd :: Lens' CreateProcess (Maybe FilePath)
--   </pre>
_cwd :: Functor f => (Maybe FilePath -> f (Maybe FilePath)) -> CreateProcess -> f CreateProcess

-- | <pre>
--   _env :: Lens' CreateProcess (Maybe [(String,String)])
--   </pre>
_env :: Functor f => (Maybe [(String, String)] -> f (Maybe [(String, String)])) -> CreateProcess -> f CreateProcess

-- | A lens for the <tt>(std_in,std_out,std_err)</tt> triplet.
--   
--   <pre>
--   streams :: Lens' CreateProcess (StdStream,StdStream,StdStream)
--   </pre>
streams :: Functor f => ((StdStream, StdStream, StdStream) -> f (StdStream, StdStream, StdStream)) -> CreateProcess -> f CreateProcess
_close_fds :: Functor f => (Bool -> f Bool) -> CreateProcess -> f CreateProcess
_create_group :: Functor f => (Bool -> f Bool) -> CreateProcess -> f CreateProcess
_delegate_ctlc :: Functor f => (Bool -> f Bool) -> CreateProcess -> f CreateProcess

-- | A <tt>Lens</tt> for the return value of <a>createProcess</a> that
--   focuses on the handles.
--   
--   <pre>
--   handles :: Lens' (Maybe Handle, Maybe Handle, Maybe Handle,ProcessHandle) (Maybe Handle, Maybe Handle, Maybe Handle)
--   </pre>
handles :: Functor m => ((Maybe Handle, Maybe Handle, Maybe Handle) -> m (Maybe Handle, Maybe Handle, Maybe Handle)) -> (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle) -> m (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | A <tt>Prism</tt> that matches when none of the standard streams have
--   been piped.
--   
--   <pre>
--   nohandles :: Prism' (Maybe Handle, Maybe Handle, Maybe Handle) ()
--   </pre>
nohandles :: Applicative m => (() -> m ()) -> (Maybe Handle, Maybe Handle, Maybe Handle) -> m (Maybe Handle, Maybe Handle, Maybe Handle)

-- | A <tt>Prism</tt> that matches when only <tt>stdout</tt> has been
--   piped.
--   
--   <pre>
--   handleso :: Prism' (Maybe Handle, Maybe Handle, Maybe Handle) (Handle)
--   </pre>
handleso :: Applicative m => (Handle -> m Handle) -> (Maybe Handle, Maybe Handle, Maybe Handle) -> m (Maybe Handle, Maybe Handle, Maybe Handle)

-- | A <tt>Prism</tt> that matches when only <tt>stderr</tt> has been
--   piped.
--   
--   <pre>
--   handlese :: Prism' (Maybe Handle, Maybe Handle, Maybe Handle) (Handle)
--   </pre>
handlese :: Applicative m => (Handle -> m Handle) -> (Maybe Handle, Maybe Handle, Maybe Handle) -> m (Maybe Handle, Maybe Handle, Maybe Handle)

-- | A <tt>Prism</tt> that matches when only <tt>stdout</tt> and
--   <tt>stderr</tt> have been piped.
--   
--   <pre>
--   handlesoe :: Prism' (Maybe Handle, Maybe Handle, Maybe Handle) (Handle, Handle)
--   </pre>
handlesoe :: Applicative m => ((Handle, Handle) -> m (Handle, Handle)) -> (Maybe Handle, Maybe Handle, Maybe Handle) -> m (Maybe Handle, Maybe Handle, Maybe Handle)

-- | A <tt>Prism</tt> that matches when only <tt>stdin</tt> has been piped.
--   
--   <pre>
--   handlesi :: Prism' (Maybe Handle, Maybe Handle, Maybe Handle) (Handle)
--   </pre>
handlesi :: Applicative m => (Handle -> m Handle) -> (Maybe Handle, Maybe Handle, Maybe Handle) -> m (Maybe Handle, Maybe Handle, Maybe Handle)
handlesio :: Applicative m => ((Handle, Handle) -> m (Handle, Handle)) -> (Maybe Handle, Maybe Handle, Maybe Handle) -> m (Maybe Handle, Maybe Handle, Maybe Handle)
handlesie :: Applicative m => ((Handle, Handle) -> m (Handle, Handle)) -> (Maybe Handle, Maybe Handle, Maybe Handle) -> m (Maybe Handle, Maybe Handle, Maybe Handle)

-- | A <tt>Prism</tt> that matches when all three <tt>stdin</tt>,
--   <tt>stdout</tt> and <tt>stderr</tt> have been piped.
--   
--   <pre>
--   handlesioe :: Prism' (Maybe Handle, Maybe Handle, Maybe Handle) (Handle, Handle, Handle)
--   </pre>
handlesioe :: Applicative m => ((Handle, Handle, Handle) -> m (Handle, Handle, Handle)) -> (Maybe Handle, Maybe Handle, Maybe Handle) -> m (Maybe Handle, Maybe Handle, Maybe Handle)

module System.Process.Streaming.Internal

-- | A <a>Piping</a> determines what standard streams will be piped and
--   what to do with them.
--   
--   The user doesn't need to manually set the <a>std_in</a>,
--   <a>std_out</a> and <a>std_err</a> fields of the <a>CreateProcess</a>
--   record to <a>CreatePipe</a>, this is done automatically.
--   
--   A <a>Piping</a> is parametrized by the type <tt>e</tt> of errors that
--   can abort the processing of the streams.
data Piping e a
PPNone :: a -> Piping e a
PPOutput :: (Producer ByteString IO () -> IO (Either e a)) -> Piping e a
PPError :: (Producer ByteString IO () -> IO (Either e a)) -> Piping e a
PPOutputError :: ((Producer ByteString IO (), Producer ByteString IO ()) -> IO (Either e a)) -> Piping e a
PPInput :: ((Consumer ByteString IO (), IO ()) -> IO (Either e a)) -> Piping e a
PPInputOutput :: ((Consumer ByteString IO (), IO (), Producer ByteString IO ()) -> IO (Either e a)) -> Piping e a
PPInputError :: ((Consumer ByteString IO (), IO (), Producer ByteString IO ()) -> IO (Either e a)) -> Piping e a
PPInputOutputError :: ((Consumer ByteString IO (), IO (), Producer ByteString IO (), Producer ByteString IO ()) -> IO (Either e a)) -> Piping e a

-- | An alternative to <a>Piping</a> for defining what to do with the
--   standard streams. <a>Piap</a> is an instance of <a>Applicative</a>,
--   unlike <a>Piping</a>.
--   
--   With <a>Piap</a>, the standard streams are always piped. The values of
--   <tt>std_in</tt>, <tt>std_out</tt> and <tt>std_err</tt> in the
--   <a>CreateProcess</a> record are ignored.
newtype Piap e a
Piap :: ((Consumer ByteString IO (), IO (), Producer ByteString IO (), Producer ByteString IO ()) -> IO (Either e a)) -> Piap e a
runPiap :: Piap e a -> (Consumer ByteString IO (), IO (), Producer ByteString IO (), Producer ByteString IO ()) -> IO (Either e a)

-- | <a>Pump</a>s are actions that write data into a process'
--   <tt>stdin</tt>.
newtype Pump b e a
Pump :: (Consumer b IO () -> IO (Either e a)) -> Pump b e a
runPump :: Pump b e a -> Consumer b IO () -> IO (Either e a)

-- | A <a>Siphon</a> represents a computation that completely drains a
--   <a>Producer</a>, but which may fail early with an error of type
--   <tt>e</tt>.
newtype Siphon b e a
Siphon :: (Lift (Siphon_ b e) a) -> Siphon b e a
runSiphon :: Siphon b e a -> Producer b IO r -> IO (Either e (a, r))
runSiphonDumb :: Siphon b e a -> Producer b IO () -> IO (Either e a)
data Siphon_ b e a
Exhaustive :: (forall r. Producer b IO r -> IO (Either e (a, r))) -> Siphon_ b e a
Nonexhaustive :: (Producer b IO () -> IO (Either e a)) -> Siphon_ b e a
exhaustive :: Siphon_ b e a -> Producer b IO r -> IO (Either e (a, r))

-- | A configuration parameter used in functions that combine lines of text
--   from multiple streams.
data Lines e
Lines :: ((forall r. Producer Text IO r -> Producer Text IO r) -> (FreeT (Producer Text IO) IO (Producer ByteString IO ()) -> IO (Producer ByteString IO ())) -> Producer ByteString IO () -> IO (Either e ())) -> (forall r. Producer Text IO r -> Producer Text IO r) -> Lines e
teardown :: Lines e -> (forall r. Producer Text IO r -> Producer Text IO r) -> (FreeT (Producer Text IO) IO (Producer ByteString IO ()) -> IO (Producer ByteString IO ())) -> Producer ByteString IO () -> IO (Either e ())
lineTweaker :: Lines e -> forall r. Producer Text IO r -> Producer Text IO r
newtype Splitter b
Splitter :: (forall r. Producer b IO r -> FreeT (Producer b IO) IO r) -> Splitter b
getSplitter :: Splitter b -> forall r. Producer b IO r -> FreeT (Producer b IO) IO r
combined :: Lines e -> Lines e -> (Producer Text IO () -> IO (Either e a)) -> Producer ByteString IO () -> Producer ByteString IO () -> IO (Either e a)
manyCombined :: [(FreeT (Producer Text IO) IO (Producer ByteString IO ()) -> IO (Producer ByteString IO ())) -> IO (Either e ())] -> (Producer Text IO () -> IO (Either e a)) -> IO (Either e a)

-- | An individual stage in a process pipeline.
data Stage e
Stage :: CreateProcess -> Lines e -> (ExitCode -> Either e ()) -> (forall r. Producer ByteString IO r -> Producer ByteString (ExceptT e IO) r) -> Stage e
_processDefinition :: Stage e -> CreateProcess
_stderrLines :: Stage e -> Lines e
_exitCodePolicy :: Stage e -> ExitCode -> Either e ()
_inbound :: Stage e -> forall r. Producer ByteString IO r -> Producer ByteString (ExceptT e IO) r
instance Functor (Piping e)
instance Functor (Pump b e)
instance Functor (Piap e)
instance Functor (Siphon_ b e)
instance Functor (Siphon b e)
instance Functor Stage
instance Functor Lines
instance Monoid a => Monoid (Siphon b e a)
instance Bifunctor (Siphon b)
instance Bifunctor (Siphon_ b)
instance Applicative (Siphon_ b e)
instance Applicative (Siphon b e)
instance Applicative (Piap e)
instance Bifunctor Piap
instance Monoid a => Monoid (Pump b e a)
instance Applicative (Pump b e)
instance Bifunctor (Pump b)
instance Bifunctor Piping


-- | This module contains helper functions and types built on top of
--   <a>System.Process</a> and <a>Pipes</a>.
--   
--   They provide concurrent, streaming access to the inputs and outputs of
--   system processes.
--   
--   Error conditions other than <a>IOException</a>s are made explicit in
--   the types.
--   
--   Regular <a>Consumer</a>s, <a>Parser</a>s from <tt>pipes-parse</tt> and
--   various folds can be used to consume the output streams of the
--   external processes.
module System.Process.Streaming

-- | Executes an external process. The standard streams are piped and
--   consumed in a way defined by the <a>Piping</a> argument.
--   
--   This function re-throws any <a>IOException</a>s it encounters.
--   
--   Besides exceptions, if the consumption of the standard streams fails
--   with <tt>e</tt>, the whole computation is immediately aborted and
--   <tt>e</tt> is returned.
--   
--   If an exception or an error <tt>e</tt> happen, the external process is
--   terminated.
executeFallibly :: Piping e a -> CreateProcess -> IO (Either e (ExitCode, a))

-- | A simplified version of <a>executeFallibly</a> for when the error type
--   unifies with <a>Void</a>. Note however that this function may still
--   throw exceptions.
execute :: Piping Void a -> CreateProcess -> IO (ExitCode, a)

-- | A <a>Piping</a> determines what standard streams will be piped and
--   what to do with them.
--   
--   The user doesn't need to manually set the <a>std_in</a>,
--   <a>std_out</a> and <a>std_err</a> fields of the <a>CreateProcess</a>
--   record to <a>CreatePipe</a>, this is done automatically.
--   
--   A <a>Piping</a> is parametrized by the type <tt>e</tt> of errors that
--   can abort the processing of the streams.
data Piping e a

-- | Do not pipe any standard stream.
nopiping :: Piping e ()

-- | Pipe <tt>stdout</tt>.
pipeo :: Siphon ByteString e a -> Piping e a

-- | Pipe <tt>stderr</tt>.
pipee :: Siphon ByteString e a -> Piping e a

-- | Pipe <tt>stdout</tt> and <tt>stderr</tt>.
pipeoe :: Siphon ByteString e a -> Siphon ByteString e b -> Piping e (a, b)

-- | Pipe <tt>stdout</tt> and <tt>stderr</tt> and consume them combined as
--   <a>Text</a>.
pipeoec :: Lines e -> Lines e -> Siphon Text e a -> Piping e a

-- | Pipe <tt>stdin</tt>.
pipei :: Pump ByteString e i -> Piping e i

-- | Pipe <tt>stdin</tt> and <tt>stdout</tt>.
pipeio :: Pump ByteString e i -> Siphon ByteString e a -> Piping e (i, a)

-- | Pipe <tt>stdin</tt> and <tt>stderr</tt>.
pipeie :: Pump ByteString e i -> Siphon ByteString e a -> Piping e (i, a)

-- | Pipe <tt>stdin</tt>, <tt>stdout</tt> and <tt>stderr</tt>.
pipeioe :: Pump ByteString e i -> Siphon ByteString e a -> Siphon ByteString e b -> Piping e (i, a, b)

-- | Pipe <tt>stdin</tt>, <tt>stdout</tt> and <tt>stderr</tt>, consuming
--   the last two combined as <a>Text</a>.
pipeioec :: Pump ByteString e i -> Lines e -> Lines e -> Siphon Text e a -> Piping e (i, a)

-- | <a>Pump</a>s are actions that write data into a process'
--   <tt>stdin</tt>.
data Pump b e a
fromProducer :: Producer b IO r -> Pump b e ()
fromProducerM :: MonadIO m => (m () -> IO (Either e a)) -> Producer b m r -> Pump b e a
fromSafeProducer :: Producer b (SafeT IO) r -> Pump b e ()
fromFallibleProducer :: Producer b (ExceptT e IO) r -> Pump b e ()
fromFoldable :: Foldable f => f b -> Pump b e ()
fromEnumerable :: Enumerable t => t IO b -> Pump b e ()
fromLazyBytes :: ByteString -> Pump ByteString e ()

-- | A <a>Siphon</a> represents a computation that completely drains a
--   <a>Producer</a>, but which may fail early with an error of type
--   <tt>e</tt>.
data Siphon b e a

-- | Builds a <a>Siphon</a> out of a computation that does something with a
--   <a>Producer</a>, but may fail with an error of type <tt>e</tt>.
--   
--   Even if the original computation doesn't completely drain the
--   <a>Producer</a>, the constructed <a>Siphon</a> will.
siphon :: (Producer b IO () -> IO (Either e a)) -> Siphon b e a

-- | Builds a <a>Siphon</a> out of a computation that drains a
--   <a>Producer</a> completely, but may fail with an error of type
--   <tt>e</tt>.
--   
--   This functions incurs in less overhead than <a>siphon</a>.
siphon' :: (forall r. Producer b IO r -> IO (Either e (a, r))) -> Siphon b e a

-- | Useful in combination with folds from the pipes prelude, or more
--   specialized folds like <a>toLazyM</a> from <tt>pipes-text</tt> and
--   <a>toLazyM</a> from <tt>pipes-bytestring</tt>.
fromFold :: (Producer b IO () -> IO a) -> Siphon b e a

-- | Builds a <a>Siphon</a> out of a computation that folds a
--   <a>Producer</a> and drains it completely.
fromFold' :: (forall r. Producer b IO r -> IO (a, r)) -> Siphon b e a
fromFold'_ :: (forall r. Producer b IO r -> IO r) -> Siphon b e ()
fromConsumer :: Consumer b IO () -> Siphon b e ()

-- | Builds a <a>Siphon</a> out of a <a>Consumer</a> with a polymorphic
--   return type (one example is <a>toHandle</a> from
--   <tt>pipes-bytestring</tt>).
fromConsumer' :: Consumer b IO Void -> Siphon b e ()
fromConsumerM :: MonadIO m => (m () -> IO (Either e a)) -> Consumer b m () -> Siphon b e a
fromConsumerM' :: MonadIO m => (forall r. m r -> IO (Either e (a, r))) -> Consumer b m Void -> Siphon b e a
fromSafeConsumer :: Consumer b (SafeT IO) Void -> Siphon b e ()
fromFallibleConsumer :: Consumer b (ExceptT e IO) Void -> Siphon b e ()

-- | Turn a <a>Parser</a> from <tt>pipes-parse</tt> into a <a>Siphon</a>.
fromParser :: Parser b IO (Either e a) -> Siphon b e a

-- | Turn a <a>Parser</a> from <tt>pipes-parse</tt> into a <a>Siphon</a>.
fromParserM :: MonadIO m => (forall r. m (a, r) -> IO (Either e (c, r))) -> Parser b m a -> Siphon b e c

-- | Builds a <a>Siphon</a> out of a pure fold from the <tt>foldl</tt>
--   package.
fromFoldl :: Fold b a -> Siphon b e a

-- | Builds a <a>Siphon</a> out of a monadic fold from the <tt>foldl</tt>
--   package that works in the IO monad.
fromFoldlIO :: FoldM IO b a -> Siphon b e a

-- | Builds a <a>Siphon</a> out of a monadic fold from the <tt>foldl</tt>
--   package.
fromFoldlM :: MonadIO m => (forall r. m (a, r) -> IO (Either e (c, r))) -> FoldM m b a -> Siphon b e c

-- | Collects incoming <a>ByteString</a> values into a lazy
--   <a>ByteString</a>.
intoLazyBytes :: Siphon ByteString e ByteString

-- | Collects incoming <a>Text</a> values into a lazy <a>Text</a>.
intoLazyText :: Siphon Text e Text
intoList :: Siphon b e [b]

-- | Constructs a <a>Siphon</a> that aborts the computation with an
--   explicit error if the underlying <a>Producer</a> produces anything.
unwanted :: a -> Siphon b b a

-- | See the section <i>Non-lens decoding functions</i> in the
--   documentation for the <tt>pipes-text</tt> package.
type DecodingFunction bytes text = forall r. Producer bytes IO r -> Producer text IO (Producer bytes IO r)

-- | Constructs a <a>Siphon</a> that works on encoded values out of a
--   <a>Siphon</a> that works on decoded values.
encoded :: DecodingFunction bytes text -> Siphon bytes e (a -> b) -> Siphon text e a -> Siphon bytes e b

-- | A newtype wrapper with functions for working on the inputs of a
--   <a>Siphon</a>, instead of the outputs.
newtype SiphonOp e a b
SiphonOp :: Siphon b e a -> SiphonOp e a b
getSiphonOp :: SiphonOp e a b -> Siphon b e a

-- | Useful to weed out unwanted inputs to a <a>Siphon</a>, by returning
--   <tt>[]</tt>.
contramapFoldable :: Foldable f => (a -> f b) -> SiphonOp e r b -> SiphonOp e r a
contramapEnumerable :: Enumerable t => (a -> t IO b) -> SiphonOp e r b -> SiphonOp e r a
contraproduce :: (forall r. Producer a IO r -> Producer b IO r) -> SiphonOp e r b -> SiphonOp e r a

-- | Like encoded, but works on <a>SiphonOp</a>s.
contraencoded :: DecodingFunction bytes text -> Siphon bytes e (a -> b) -> SiphonOp e a text -> SiphonOp e b bytes
data Splitter b

-- | Build a <a>Splitter</a> out of a function that splits a
--   <a>Producer</a> while preserving streaming.
--   
--   See the section <i>FreeT Transformations</i> in the documentation for
--   the <i>pipes-text</i> package, and also the documentation for the
--   <i>pipes-group</i> package.
splitter :: (forall r. Producer b IO r -> FreeT (Producer b IO) IO r) -> Splitter b
splitIntoLines :: Splitter Text

-- | Specifies a transformation that will be applied to each individual
--   split, represented as a <a>Producer</a>.
tweakSplits :: (forall r. Producer b IO r -> Producer b IO r) -> Splitter b -> Splitter b

-- | Flattens the <a>Splitter</a>, returning a function from
--   <a>Producer</a> to <a>Producer</a> which can be passed to functions
--   like <a>contraproduce</a>.
rejoin :: Splitter b -> Producer b IO r -> Producer b IO r

-- | Process each individual split created by a <a>Splitter</a> using a
--   <a>Siphon</a>.
nest :: Splitter b -> Siphon b Void a -> SiphonOp e r a -> SiphonOp e r b

-- | A configuration parameter used in functions that combine lines of text
--   from multiple streams.
data Lines e

-- | Constructs a <a>Lines</a> value.
toLines :: DecodingFunction ByteString Text -> Siphon ByteString e (() -> ()) -> Lines e

-- | Specifies a transformation that will be applied to each line of text,
--   represented as a <a>Producer</a>.
tweakLines :: (forall r. Producer Text IO r -> Producer Text IO r) -> Lines e -> Lines e

-- | Specifies a prefix that will be calculated and appended for each line
--   of text.
prefixLines :: IO Text -> Lines e -> Lines e

-- | Like <a>unwanted</a>, but throws an exception instead of using the
--   explicit error type.
unwantedX :: Exception ex => (b -> ex) -> a -> Siphon b e a

-- | Exception that carries a message and a sample of the leftover data.
data LeftoverException b
LeftoverException :: String -> b -> LeftoverException b

-- | Throws <a>LeftoverException</a> if any data comes out of the
--   underlying producer, and returns <a>id</a> otherwise.
leftoverX :: String -> Siphon ByteString e (a -> a)

-- | Like <a>leftoverX</a>, but doesn't take an error message.
_leftoverX :: Siphon ByteString e (a -> a)

-- | Similar to <a>executeFallibly</a>, but instead of a single process it
--   executes a (possibly branching) pipeline of external processes.
--   
--   This function has a limitation compared to the standard UNIX
--   pipelines. If a downstream process terminates early without error, the
--   upstream processes are not notified and keep going. There is no
--   SIGPIPE-like functionality, in other words.
executePipelineFallibly :: Piping e a -> Tree (Stage e) -> IO (Either e a)

-- | A simplified version of <a>executePipelineFallibly</a> for when the
--   error type unifies with <a>Void</a>. Note however that this function
--   may still throw exceptions.
executePipeline :: Piping Void a -> Tree (Stage Void) -> IO a

-- | An individual stage in a process pipeline.
data Stage e

-- | Builds a <a>Stage</a>.
stage :: Lines e -> (ExitCode -> Either e ()) -> CreateProcess -> Stage e

-- | Converts any <a>ExitFailure</a> to the left side of an <a>Either</a>.
pipefail :: ExitCode -> Either Int ()

-- | Applies a transformation to the stream of bytes flowing into a stage
--   from previous stages.
--   
--   This function is ignored for first stages.
inbound :: (forall r. Producer ByteString (ExceptT e IO) r -> Producer ByteString (ExceptT e IO) r) -> Stage e -> Stage e
decodeUtf8 :: Monad m => Producer ByteString m r -> Producer Text m (Producer ByteString m r)

-- | Reduce a byte stream to a corresponding stream of ascii chars,
--   returning the unused <a>ByteString</a> upon hitting an un-ascii byte.
decodeAscii :: Monad m => Producer ByteString m r -> Producer Text m (Producer ByteString m r)

-- | Reduce a byte stream to a corresponding stream of ascii chars,
--   returning the unused <a>ByteString</a> upon hitting the rare
--   un-latinizable byte.
decodeIso8859_1 :: Monad m => Producer ByteString m r -> Producer Text m (Producer ByteString m r)
instance Typeable LeftoverException
instance Functor CreatePipeline
instance Monoid a => Decidable (SiphonOp e a)
instance Monoid a => Divisible (SiphonOp e a)
instance Contravariant (SiphonOp e a)
instance Typeable b => Show (LeftoverException b)
instance Typeable b => Exception (LeftoverException b)


module System.Process.Streaming.Extended

-- | An alternative to <a>Piping</a> for defining what to do with the
--   standard streams. <a>Piap</a> is an instance of <a>Applicative</a>,
--   unlike <a>Piping</a>.
--   
--   With <a>Piap</a>, the standard streams are always piped. The values of
--   <tt>std_in</tt>, <tt>std_out</tt> and <tt>std_err</tt> in the
--   <a>CreateProcess</a> record are ignored.
data Piap e a

-- | Do stuff with <tt>stdin</tt>.
piapi :: Pump ByteString e a -> Piap e a

-- | Do stuff with <tt>stdout</tt>.
piapo :: Siphon ByteString e a -> Piap e a

-- | Do stuff with <tt>stderr</tt>.
piape :: Siphon ByteString e a -> Piap e a

-- | Do stuff with <tt>stdout</tt> and <tt>stderr</tt> combined as
--   <a>Text</a>.
piapoe :: Lines e -> Lines e -> Siphon Text e a -> Piap e a

-- | Pipe <tt>stdin</tt> to the created process' <tt>stdin</tt>.
samei :: Piap e ()

-- | Pipe the created process' <tt>stdout</tt> to <tt>stdout</tt>.
sameo :: Piap e ()

-- | Pipe the created process' <tt>stderr</tt> to <tt>stderr</tt>.
samee :: Piap e ()
sameioe :: Piap e ()
toPiping :: Piap e a -> Piping e a
pumpFromHandle :: Handle -> Pump ByteString e ()
siphonToHandle :: Handle -> Siphon ByteString e ()


-- | <tt>process-streaming</tt> uses the <a>CreateProcess</a> record to
--   describe the program to be executed. The user doesn't need to set the
--   <a>std_in</a>, <a>std_out</a> and <a>std_err</a> fields, as these are
--   set automatically according to the <a>Piping</a>.
--   
--   <a>Piping</a> is a datatype that specifies what standard streams to
--   pipe and what to do with them. It has several constructors, one for
--   each possible combination of streams.
--   
--   Constructors for <a>Piping</a> usually take <a>Siphon</a>s as
--   parameters. A <a>Siphon</a> specifies what to do with a particular
--   standard stream.
--   
--   <a>Siphon</a>s can be built from each of the typical ways of consuming
--   a <tt>Producer</tt> in the <tt>pipes</tt> ecosystem:
--   
--   <ul>
--   <li>Regular <tt>Consumer</tt>s (with <a>fromConsumer</a>,
--   <a>fromConsumerM</a>).</li>
--   <li>Folds from the <tt>pipes</tt> <a>Prelude</a> or specialized folds
--   from <tt>pipes-bytestring</tt> or <tt>pipes-text</tt> (with
--   <a>fromFold</a>, <a>fromFold'</a>).</li>
--   <li><tt>Parser</tt>s from <tt>pipes-parse</tt> (with <a>fromParser</a>
--   and <a>fromParserM</a>).</li>
--   <li><tt>Applicative</tt> folds from the <tt>foldl</tt> package (with
--   <a>fromFoldl</a>, <a>fromFoldlIO</a> and <a>fromFoldlM</a>).</li>
--   <li>In general, any computation that does something with a
--   <tt>Producer</tt> (with <a>siphon</a> and <a>siphon'</a>).</li>
--   </ul>
--   
--   <a>Siphon</a>s have an explicit error type; when a <a>Siphon</a>
--   reading one of the standard streams fails, the external program is
--   immediately terminated and the error value is returned.
--   
--   A <a>Siphon</a> reading a stream always consumes the whole stream. If
--   the user wants to interrupt the computation early, he can return a
--   failure (or throw an exception).
--   
--   <a>Siphon</a>s have an <tt>Applicative</tt> instance. <tt>pure</tt>
--   creates a <a>Siphon</a> that drains a stream but does nothing with the
--   data.
module System.Process.Streaming.Tutorial
