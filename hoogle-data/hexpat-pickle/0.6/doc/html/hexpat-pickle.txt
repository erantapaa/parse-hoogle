-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | XML picklers based on hexpat, source-code-similar to those of the HXT package
--   
--   A library of combinators that allows Haskell data structures to be
--   pickled (serialized) to/from XML via the Tree datatype defined in the
--   hexpat package. It is source-code-similar to the pickling
--   functionality of the HXT package, to ease the transition between the
--   two libraries. This implementation is faster but less complete than
--   HXT. Unlike some other picklers, it also supports <i>lazy
--   unpickling</i>.
--   
--   This package does not depend on HXT.
--   
--   DARCS repository: <a>http://code.haskell.org/hexpat-pickle/</a>
@package hexpat-pickle
@version 0.6


-- | <i>hexpat-pickle</i> provides XML picklers that plug into the parse
--   tree of the <i>hexpat</i> package, giving XML serialization with
--   excellent performance. Picklers are source code similar to those of
--   the <i>HXT</i> package. The concept and design was lifted entirely
--   from <i>HXT</i>.
--   
--   The API differences between <i>HXT</i> and <i>hexpat-pickle</i> are:
--   
--   <ul>
--   <li><a>PU</a> and <a>XmlPickler</a> take one extra argument,
--   indicating the part of the XML tree we are working with.</li>
--   <li><a>xpElem</a> takes three arguments to <i>HXT</i>'s two, because
--   we treat attributes and child nodes separately, while <i>HXT</i>
--   groups them together.</li>
--   <li>Two type adapters (absent in <i>HXT</i>), <a>xpRoot</a> and
--   <a>xpContent</a> are needed in certain places. See below.</li>
--   <li>These <i>HXT</i> picklers are missing: <tt>xpCondSeq</tt>,
--   <tt>xpSeq</tt>, <tt>xpChoice</tt>, <tt>xpList1</tt>
--   (<a>xpListMinLen</a> may be substituted),
--   <tt>xpElemWithAttrValue</tt></li>
--   </ul>
--   
--   The data type <tt><a>PU</a> t a</tt> represents both a pickler
--   (converting Haskell data to XML) and an unpickler (XML to Haskell
--   data), so your code only needs to be written once for both
--   serialization and deserialization. The <a>PU</a> primitives, such as
--   <a>xpElem</a> for XML elements, may be composed into complex
--   arrangements using <a>xpPair</a> and other combinators.
--   
--   The <tt>t</tt> argument (absent in <i>HXT</i>) represents the part of
--   the XML tree that this <a>PU</a> works on. <tt>t</tt> has <i>three</i>
--   possible values. These are the most general types, and your picklers
--   should not use any other types for <tt>t</tt>. Here they are, assuming
--   we are using the <i>String</i> type for our strings:
--   
--   <ul>
--   <li><tt><a>PU</a> [<a>Node</a> String String] a</tt> <i>(for working
--   with an XML element)</i></li>
--   <li><tt><a>PU</a> String a</tt> <i>(for working with text
--   content)</i></li>
--   <li><tt><a>PU</a> (<a>Attributes</a> String String) a</tt> <i>(for
--   working with attributes)</i></li>
--   </ul>
--   
--   The reason why you a list of <a>Node</a> instead of just one when
--   working with a single element is because the unpickler of
--   <a>xpElem</a> needs to see the whole list of nodes so that it can 1.
--   skip whitespace, and 2. search to match the specified tag name.
--   
--   The top level of the document does not follow this rule, because it is
--   a single <a>Node</a> type. <a>xpRoot</a> is needed to adapt this to
--   type [<a>Node</a>] for your pickler to use. You would typically define
--   a pickler for a whole document with <a>xpElem</a>, then pickle it to a
--   single <a>Node</a> with <tt><a>pickleTree</a> (xpRoot myDocPickler)
--   value</tt>.
--   
--   The type for <i>text content</i> works for attribute values directly,
--   but if you want to use it as the text content of an element, you need
--   to adapt it by wrapping with <a>xpContent</a>.
--   
--   <i>hexpat-pickle</i> can work with the following string types:
--   
--   <ul>
--   <li>String</li>
--   <li>Data.ByteString</li>
--   <li>Data.Text</li>
--   </ul>
--   
--   and it is extensible to any other string type by making it an instance
--   of <a>GenericXMLString</a>. We select the type for XML <i>tag</i> and
--   <i>text</i> separately in our four "tree part" types as follows:
--   
--   <ul>
--   <li><tt><a>PU</a> [Node tag text] a</tt> <i>(for working with an XML
--   element)</i></li>
--   <li><tt><a>PU</a> text a</tt> <i>(for working with text
--   content)</i></li>
--   <li><tt><a>PU</a> (Attributes tag text) a</tt> <i>(for working with
--   attributes)</i></li>
--   </ul>
--   
--   <i>tag</i> may be a string type, or it may be a QName type defined in
--   the <a>Qualified</a> module. (Or you can extend it any way you like.)
--   
--   The <i>Text.XML.Expat.Tree</i> and <i>Text.XML.Expat.Qualified</i>
--   provide the follow useful shortcuts for common cases of <a>Node</a>
--   and <a>Attributes</a>:
--   
--   <ul>
--   <li><a>UNode</a>, <a>UAttributes</a>, <a>QNode</a>,
--   <a>QAttributes</a>.</li>
--   </ul>
--   
--   The type class <a>XmlPickler</a> is used to extend a polymorphic
--   <a>xpickle</a> function to provide a pickler for a new type, in a
--   similar way to <a>Read</a> and <a>Show</a>.
--   
--   Here is a simple and complete example to get you started:
--   
--   <pre>
--   import Text.XML.Expat.Pickle
--   import Text.XML.Expat.Tree
--   import qualified Data.ByteString.Lazy as L
--   
--   -- Person name, age and description
--   data Person = Person String Int String
--   
--   xpPerson :: PU [UNode String] Person
--   xpPerson =
--       -- How to wrap and unwrap a Person
--       xpWrap (\((name, age), descr) -&gt; Person name age descr,
--               \(Person name age descr) -&gt; ((name, age), descr)) $
--       xpElem "person"
--           (xpPair
--               (xpAttr "name" xpText0)
--               (xpAttr "age" xpickle))
--           (xpContent xpText0)
--   
--   people = [
--       Person "Dave" 27 "A fat thin man with long short hair",
--       Person "Jane" 21 "Lives in a white house with green windows"]
--   
--   main = do
--       L.putStrLn $
--           pickleXML (xpRoot $ xpElemNodes "people" $ xpList xpPerson) people
--   </pre>
--   
--   Program output:
--   
--   <pre>
--   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
--   &lt;people&gt;&lt;person name="Dave" age="27"&gt;A fat thin man with long short hair&lt;/person&gt;
--   &lt;person name="Jane" age="21"&gt;Lives in a white house with green windows&lt;/person&gt;&lt;/people&gt;
--   </pre>
module Text.XML.Expat.Pickle

-- | A two-way pickler/unpickler that pickles an arbitrary data type ''a''
--   to a part of an XML tree ''t''. A <a>PU</a> can be composed using the
--   pickler primitives defined in this module.
--   
--   <i>unpickleTree</i>, <i>unpickleTree'</i> and <i>pickleTree</i> should
--   be used directly by the caller.
data PU t a
PU :: (t -> a) -> (t -> Either String a) -> (a -> t) -> PU t a

-- | Lazily convert a <tt>t</tt> XML tree part into a Haskell value of type
--   <tt>a</tt>. In the event of an error, it throws
--   <a>UnpickleException</a>.
unpickleTree :: PU t a -> t -> a

-- | strictly convert a <tt>t</tt> XML tree part into a Haskell value of
--   type <tt>a</tt>, or give an unpickling error message as <tt>Left
--   error</tt>.
unpickleTree' :: PU t a -> t -> Either String a

-- | Convert a Haskell value of type <tt>a</tt> to a <tt>t</tt> XML tree
--   part.
pickleTree :: PU t a -> a -> t

-- | A pure tree representation that uses a list as its container type.
--   
--   In the <tt>hexpat</tt> package, a list of nodes has the type <tt>[Node
--   tag text]</tt>, but note that you can also use the more general type
--   function <a>ListOf</a> to give a list of any node type, using that
--   node's associated list type, e.g. <tt>ListOf (UNode Text)</tt>.
type Node tag text = NodeG [] tag text

-- | Define a generalized pickler for converting a Haskell data of type
--   <tt>a</tt> to/from a <tt>t</tt> tree part, analogous to <a>Read</a> /
--   <a>Show</a>.
class XmlPickler t a
xpickle :: XmlPickler t a => PU t a

-- | An exception indicating an error during unpickling, using by the lazy
--   variants.
data UnpickleException
UnpickleException :: String -> UnpickleException

-- | A helper that combines <tt>parseXML</tt> with <a>unpickleTree</a> to
--   unpickle from an XML document - lazy version. In the event of an
--   error, it throws either <a>XMLParseException</a> or
--   <a>UnpickleException</a>.
unpickleXML :: (GenericXMLString tag, GenericXMLString text) => ParseOptions tag text -> PU (Node tag text) a -> ByteString -> a

-- | A helper that combines <tt>parseXML</tt> with <a>unpickleTree</a> to
--   unpickle from an XML document - strict version.
unpickleXML' :: (GenericXMLString tag, GenericXMLString text) => ParseOptions tag text -> PU (Node tag text) a -> ByteString -> Either String a

-- | A helper that combines <a>pickleTree</a> with <tt>formatXML</tt> to
--   pickle to an XML document. Lazy variant returning lazy ByteString.
pickleXML :: (GenericXMLString tag, GenericXMLString text) => PU (Node tag text) a -> a -> ByteString

-- | A helper that combines <a>pickleTree</a> with <tt>formatXML</tt> to
--   pickle to an XML document. Strict variant returning strict ByteString.
pickleXML' :: (GenericXMLString tag, GenericXMLString text) => PU (Node tag text) a -> a -> ByteString

-- | Type alias for a node with unqualified tag names where tag and text
--   are the same string type.
type UNode text = Node text text

-- | Type alias for a node where qualified names are used for tags
type QNode text = Node (QName text) text

-- | Type alias for a node where namespaced names are used for tags
type NNode text = Node (NName text) text

-- | Type shortcut for attributes
type Attributes tag text = [(tag, text)]

-- | Type shortcut for attributes with unqualified names where tag and text
--   are the same string type.
type UAttributes text = Attributes text text

-- | Type shortcut for attributes with qualified names
type QAttributes text = Attributes (QName text) text

-- | Type shortcut for attributes with namespaced names
type NAttributes text = Attributes (NName text) text
data ParseOptions tag text :: * -> * -> *
ParseOptions :: Maybe Encoding -> Maybe (tag -> Maybe text) -> ParseOptions tag text

-- | The encoding parameter, if provided, overrides the document's encoding
--   declaration.
overrideEncoding :: ParseOptions tag text -> Maybe Encoding

-- | If provided, entity references (i.e. <tt>&amp;nbsp;</tt> and friends)
--   will be decoded into text using the supplied lookup function
entityDecoder :: ParseOptions tag text -> Maybe (tag -> Maybe text)
defaultParseOptions :: ParseOptions tag text

-- | Adapts a list of nodes to a single node. Generally used at the top
--   level of an XML document.
xpRoot :: PU [Node tag text] a -> PU (Node tag text) a

-- | If you have a pickler that works with <i>text</i>, and you want to use
--   it as text content of an XML element, you need to wrap it with
--   <i>xpContent</i>. See the example at the top.
xpContent :: GenericXMLString text => PU text a -> PU [Node tag text] a

-- | Convert nothing &lt;-&gt; (). Does not output or consume any XML text.
xpUnit :: PU [t] ()

-- | The zero pickler
--   
--   Encodes nothing, fails always during unpickling. (Same as
--   <tt><a>xpThrow</a> "got xpZero"</tt>).
xpZero :: PU [t] a

-- | Convert nothing &lt;-&gt; constant value. Does not output or consume
--   any XML text.
xpLift :: a -> PU [t] a

-- | Pickle <tt>(a,b)</tt> to/from an XML element of the specified name,
--   where <tt>a</tt> is passed to a specified pickler for attributes and
--   <tt>b</tt> to a pickler for child nodes. Unpickle fails if an element
--   of this name can't be found at this point in the tree.
--   
--   This implementation differs from <i>HXT</i> in that it unpickles
--   elements of different names in any order, while <i>HXT</i>'s xpElem
--   will fail if the XML order doesn't match the Haskell code.
--   
--   It also differs from <i>HXT</i> in that it takes two pickler
--   arguments, one for attributes and one for child nodes. When migrating
--   from <i>HXT</i>, often you can substitute just <a>xpElemAttrs</a> or
--   <a>xpElemNodes</a> for <i>HXT</i>'s <a>xpElem</a>, but where your
--   element has both attributes and child nodes, you must split your data
--   into a 2-tuple with <a>xpWrap</a>, and separate the child picklers
--   accordingly.
xpElem :: (Eq tag, Show tag) => tag -> PU [(tag, text)] a -> PU [Node tag text] b -> PU [Node tag text] (a, b)

-- | A helper variant of xpElem for elements that contain attributes but no
--   child tags.
xpElemAttrs :: (Eq tag, Show tag) => tag -> PU (Attributes tag text) a -> PU [Node tag text] a

-- | A helper variant of xpElem for elements that contain child nodes but
--   no attributes.
xpElemNodes :: (Eq tag, Show tag) => tag -> PU [Node tag text] a -> PU [Node tag text] a

-- | Create/parse an XML attribute of the specified name. Fails if the
--   attribute can't be found at this point in the tree.
xpAttr :: (Eq tag, Show tag) => tag -> PU text a -> PU (Attributes tag text) a

-- | Optionally add an attribute, unwrapping a Maybe value.
xpAttrImplied :: (Eq tag, Show tag) => tag -> PU text a -> PU (Attributes tag text) (Maybe a)

-- | Pickle an attribute with the specified name and value, fail if the
--   same attribute is not present on unpickle.
xpAttrFixed :: (Eq tag, Show tag, GenericXMLString text) => tag -> text -> PU (Attributes tag text) ()

-- | Add an attribute with a fixed value.
--   
--   Useful e.g. to declare namespaces. Is implemented by
--   <a>xpAttrFixed</a>
xpAddFixedAttr :: (Eq tag, Show tag, GenericXMLString text) => tag -> text -> PU (Attributes tag text) a -> PU (Attributes tag text) a

-- | Convert XML text content &lt;-&gt; String. Handles empty strings.
xpText0 :: PU text text

-- | Convert XML text content &lt;-&gt; String. Empty strings result in
--   unpickle failure (Be warned!).
xpText :: GenericXMLString text => PU text text

-- | Convert XML text content &lt;-&gt; any type that implements
--   <a>Read</a> and <a>Show</a>. Fails on unpickle if <a>read</a> fails.
xpPrim :: (Read n, Show n, GenericXMLString text) => PU text n

-- | Convert XML text &lt;-&gt; a 2-tuple using the two arguments.
xpPair :: PU [t] a -> PU [t] b -> PU [t] (a, b)

-- | Convert XML text &lt;-&gt; a 3-tuple using the three arguments.
xpTriple :: PU [t] a -> PU [t] b -> PU [t] c -> PU [t] (a, b, c)

-- | Convert XML text &lt;-&gt; a 4-tuple using the four arguments.
xp4Tuple :: PU [t] a -> PU [t] b -> PU [t] c -> PU [t] d -> PU [t] (a, b, c, d)

-- | Convert XML text &lt;-&gt; a 5-tuple using the five arguments.
xp5Tuple :: PU [t] a -> PU [t] b -> PU [t] c -> PU [t] d -> PU [t] e -> PU [t] (a, b, c, d, e)

-- | Convert XML text &lt;-&gt; a 6-tuple using the six arguments.
xp6Tuple :: PU [t] a -> PU [t] b -> PU [t] c -> PU [t] d -> PU [t] e -> PU [t] f -> PU [t] (a, b, c, d, e, f)

-- | Convert XML text &lt;-&gt; a list of elements. Unlike <a>xpList</a>,
--   this function uses <i>no more elements</i> as the end of list
--   condition, which means it can evaluate its children lazily.
--   
--   Any error in a child will cause an error to be reported.
xpList0 :: Show tag => PU [Node tag text] a -> PU [Node tag text] [a]

-- | Convert XML text &lt;-&gt; a list of elements. During unpickling,
--   failure of the argument unpickler is the end-of-list condition (and it
--   isn't a failure).
--   
--   Note on lazy unpickle: Because we're using a failure to pickle a child
--   as the end condition it means we're only lazy at the top-level xpList.
--   Children of xpList are evaluated strictly. Use <a>xpList0</a> to fix
--   this.
xpList :: Show tag => PU [Node tag text] a -> PU [Node tag text] [a]

-- | Like xpList, but only succeed during deserialization if at least a
--   minimum number of elements are unpickled.
xpListMinLen :: Show tag => Int -> PU [Node tag text] a -> PU [Node tag text] [a]

-- | Standard pickler for maps
--   
--   This pickler converts a map into a list of pairs of the form
--   
--   <pre>
--   &lt;elt attr="key"&gt;value&lt;/elt&gt;
--   </pre>
xpMap :: (Eq tag, Show tag, Ord k) => tag -> tag -> PU text k -> PU [Node tag text] v -> PU [Node tag text] (Map k v)

-- | Apply a lens to convert the type of your data structure to/from types
--   that the pickler primitives can handle, with the <i>unpickle</i> case
--   first. Mostly this means the tuples used by <a>xpPair</a> and friends.
--   A typical example is:
--   
--   <pre>
--   xpWrap (\(name, address) -&gt; Person name address,
--           \(Person name address) -&gt; (name, address)) $ ...
--   </pre>
xpWrap :: (a -> b, b -> a) -> PU t a -> PU t b

-- | Like xpWrap, but strips Just (and treats Nothing as a failure) during
--   unpickling.
xpWrapMaybe :: (a -> Maybe b, b -> a) -> PU t a -> PU t b

-- | Like xpWrap, but strips Just (and treats Nothing as a failure) during
--   unpickling, with specified error message for Nothing value.
xpWrapMaybe_ :: String -> (a -> Maybe b, b -> a) -> PU t a -> PU t b

-- | Like xpWrap, except it strips Right (and treats Left as a failure)
--   during unpickling.
xpWrapEither :: (a -> Either String b, b -> a) -> PU t a -> PU t b

-- | Convert XML text &lt;-&gt; a Maybe type. During unpickling, Nothing is
--   returned if there's a failure during the unpickling of the first
--   argument. A typical example is:
--   
--   <pre>
--   xpElemAttrs "score" $ xpOption $ xpAttr "value" xpickle
--   </pre>
--   
--   in which <tt>Just 5</tt> would be encoded as <tt>&lt;score
--   value="5"/&gt;</tt> and <tt>Nothing</tt> would be encoded as
--   <tt>&lt;score/&gt;</tt>.
--   
--   Note on lazy unpickle: The argument is evaluated strictly.
xpOption :: PU [t] a -> PU [t] (Maybe a)

-- | Optional conversion with default value
--   
--   Unlike <a>xpWithDefault</a> the default value is not encoded in the
--   XML document, during unpickling the default value is inserted if the
--   pickler fails
--   
--   Note on lazy unpickle: The child is evaluated strictly.
xpDefault :: Eq a => a -> PU [t] a -> PU [t] a

-- | Attempt to use a pickler. On failure, return a default value.
--   
--   Unlike <a>xpDefault</a>, the default value <i>is</i> encoded in the
--   XML document.
--   
--   Note on lazy unpickle: The child is evaluated strictly.
xpWithDefault :: a -> PU t a -> PU t a

-- | Execute one of a list of picklers. The <i>selector function</i> is
--   used during pickling, and the integer returned is taken as a 0-based
--   index to select a pickler from <i>pickler options</i>. Unpickling is
--   done by trying each list element in order until one succeeds (the
--   <i>selector</i> is not used).
--   
--   This is typically used to handle each constructor of a data type.
--   However, it can be used wherever multiple serialization strategies
--   apply to a single type.
--   
--   Note on lazy unpickle: Because we're using a failure to pickle a child
--   as the end condition it means children of xpAlt are evaluated
--   strictly.
xpAlt :: (a -> Int) -> [PU t a] -> PU t a

-- | Pickler that during pickling always uses the first pickler, and during
--   unpickling tries the first, and on failure then tries the second.
--   
--   Note on lazy unpickle: The first argument is evaluated strictly.
xpTryCatch :: PU t a -> PU t a -> PU t a

-- | No output when pickling, always generates an error with the specified
--   message on unpickling.
xpThrow :: String -> PU [t] a

-- | Insert/extract an attribute list literally in the xml stream.
xpAttrs :: PU [(tag, text)] [(tag, text)]

-- | Insert/extract a tree node literally in the xml stream.
xpTree :: PU [Node tag text] (Node tag text)

-- | Insert/extract a list of tree nodes literally in the xml stream.
xpTrees :: PU [Node tag text] [Node tag text]

-- | An abstraction for any string type you want to use as xml text (that
--   is, attribute values or element text content). If you want to use a
--   new string type with <i>hexpat</i>, you must make it an instance of
--   <a>GenericXMLString</a>.
class (Monoid s, Eq s) => GenericXMLString s
gxNullString :: GenericXMLString s => s -> Bool
gxToString :: GenericXMLString s => s -> String
gxFromString :: GenericXMLString s => String -> s
gxFromChar :: GenericXMLString s => Char -> s
gxHead :: GenericXMLString s => s -> Char
gxTail :: GenericXMLString s => s -> s
gxBreakOn :: GenericXMLString s => Char -> s -> (s, s)
gxFromByteString :: GenericXMLString s => ByteString -> s
gxToByteString :: GenericXMLString s => s -> ByteString
instance Typeable UnpickleException
instance Eq UnpickleException
instance Show UnpickleException
instance (XmlPickler [Node tag text] a, Show tag) => XmlPickler [Node tag text] [a]
instance GenericXMLString text => XmlPickler text Integer
instance GenericXMLString text => XmlPickler text Int
instance Exception UnpickleException
