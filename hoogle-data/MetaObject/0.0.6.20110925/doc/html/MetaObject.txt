-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A meta-object system for Haskell based on Perl 6
--   
--   A meta-object system for Haskell based on Perl 6
@package MetaObject
@version 0.0.6.20110925


-- | C3 method resolution order implementation based on algorithm described
--   in <i>The Python 2.3 Method Resolution Order, v1.4</i>, by Michele
--   Simionato available at
--   <a>http://www.python.org/download/releases/2.3/mro/</a>. Some tests
--   also copied from Perl module Algorithm::C3.
--   
--   The <tt>main</tt> function contains the test cases.
module MO.Util.C3

-- | Returns the a linearization using C3 algorithm. Takes a function and
--   an element. We can apply the function in this element to obtain its
--   parents.
linearize :: (Monad m, Eq a) => (a -> m [a]) -> a -> m [a]

module MO.Capture

-- | a Capture is a frozen version of the arguments to an application.
data Capt a
CaptMeth :: a -> Seq (Feed a) -> Capt a
c_invocant :: Capt a -> a
c_feeds :: Capt a -> Seq (Feed a)
CaptSub :: Seq (Feed a) -> Capt a
c_feeds :: Capt a -> Seq (Feed a)

-- | non-invocant arguments.
data Feed a
MkFeed :: Seq a -> AtomMap (Seq a) -> Feed a
f_positionals :: Feed a -> Seq a

-- | maps to [:a:] and not a since if the Sig stipulates <tt>x, <a>x =&gt;
--   1, x =&gt; 2</a> constructs </tt>x = (1, 2).
f_nameds :: Feed a -> AtomMap (Seq a)
emptyFeed :: Feed a
concatFeeds :: Seq (Feed a) -> Feed a
instance [overlap ok] Typeable1 Feed
instance [overlap ok] Typeable1 Capt
instance [overlap ok] Show a => Show (Feed a)
instance [overlap ok] Eq a => Eq (Feed a)
instance [overlap ok] Ord a => Ord (Feed a)
instance [overlap ok] Show a => Show (Capt a)
instance [overlap ok] Eq a => Eq (Capt a)
instance [overlap ok] Ord a => Ord (Capt a)
instance [overlap ok] Monoid (Feed a)

module MO.Util
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
traceShow :: Show a => a -> b -> b
traceM :: Monad m => String -> m ()
(?==?) :: (Eq a, Typeable a, Typeable b) => a -> b -> Bool
(?<=>?) :: (Ord a, Typeable a, Typeable b) => a -> b -> Ordering
addressOf :: a -> Word
data Ord a => Collection a
MkCollection :: Set a -> AtomMap a -> Collection a
c_objects :: Collection a -> Set a
c_names :: Collection a -> AtomMap a
cmap :: (Ord a, Ord b) => (a -> b) -> Collection a -> Collection b
remove :: (Monad m, Ord a) => Atom -> a -> Collection a -> m (Collection a)
add :: (Monad m, Ord a) => Atom -> a -> Collection a -> m (Collection a)
insert :: Ord a => Atom -> a -> Collection a -> Collection a
emptyCollection :: Ord a => Collection a
newCollection :: Ord a => [(Atom, a)] -> Collection a
newCollection' :: Ord a => (a -> Atom) -> [a] -> Collection a
newCollectionMap :: Ord a => AtomMap a -> Collection a
items :: Ord a => Collection a -> [a]
items_named :: Ord a => Collection a -> [(Atom, a)]
includes :: Ord a => Collection a -> a -> Bool
includes_name :: Ord a => Collection a -> Atom -> Bool
includes_any :: Ord a => Collection a -> [a] -> Bool
includes_any_name :: Ord a => Collection a -> [Atom] -> Bool
includes_all :: Ord a => Collection a -> [a] -> Bool
shadow :: Ord a => [Collection a] -> [a]
shadow' :: Ord a => [Collection a] -> AtomMap a
shadow_collection :: Ord a => [Collection a] -> Collection a
merge :: Ord a => [Collection a] -> [a]
merge' :: Ord a => [Collection a] -> AtomMap a
merge_collection :: Ord a => [Collection a] -> Collection a
sym_shadowing :: (Show a, Ord a) => b -> (b -> [b]) -> (b -> Collection a) -> Collection a
sym_merged_parents :: (Show a, Ord a) => b -> (b -> [b]) -> (b -> Collection a) -> Collection a
sym_inheritance :: Ord a => b -> (b -> [b]) -> (b -> (Collection a)) -> Collection a

-- | When called, <a>trace</a> outputs the string in its first argument,
--   before returning the second argument as its result. The <a>trace</a>
--   function is not referentially transparent, and should only be used for
--   debugging, or for monitoring execution. Some implementations of
--   <a>trace</a> may decorate the string that's output to indicate that
--   you're tracing. The function is implemented on top of
--   <a>putTraceMsg</a>.
trace :: String -> a -> a
instance [overlap ok] Typeable1 Collection
instance [overlap ok] Ord a => Eq (Collection a)
instance [overlap ok] Ord a => Ord (Collection a)
instance [overlap ok] (Ord a, Show a) => Show (Collection a)

module MO.Base
data (Typeable1 m, Monad m) => Invocant m
MkInvocant :: a -> (AnyResponder m) -> Invocant m

-- | open type to represent Code
class Monad m => Codeable m c
run :: Codeable m c => c -> Arguments m -> m (Invocant m)

-- | stub code which always return the same
newtype NoCode m
NoCode :: (Invocant m) -> NoCode m

-- | Pure code that works with any monad.
newtype PureCode
PureCode :: (forall m. (Typeable1 m, Monad m) => Arguments m -> Invocant m) -> PureCode

-- | Real monadic primitive code.
newtype Monad m => HsCode m
HsCode :: (Arguments m -> m (Invocant m)) -> HsCode m
type Arguments m = Capt (Invocant m)
withInvocant :: (Typeable1 m, Monad m) => Arguments m -> Invocant m -> Arguments m
getInvocant :: (Typeable1 m, Monad m) => Arguments m -> Maybe (Invocant m)
namedArg :: (Typeable1 m, Monad m) => Arguments m -> Atom -> Maybe (Invocant m)
stubInvocant :: (Typeable1 m, Monad m) => Invocant m
instance [overlap ok] Show (HsCode m)
instance [overlap ok] (Typeable1 m, Monad m) => Codeable m (HsCode m)
instance [overlap ok] Show PureCode
instance [overlap ok] (Typeable1 m, Monad m) => Codeable m PureCode
instance [overlap ok] Show (NoCode m)
instance [overlap ok] (Typeable (NoCode m), Monad m) => Codeable m (NoCode m)

module MO.Compile
type MethodName = Atom
class Monad m => Method m a | a -> m
methodName :: Method m a => a -> MethodName
methodCompile :: Method m a => a -> MethodCompiled m
data SimpleMethod m
MkSimpleMethod :: MethodName -> MethodCompiled m -> SimpleMethod m
sm_name :: SimpleMethod m -> MethodName
sm_definition :: SimpleMethod m -> MethodCompiled m
data AnyMethod m
MkMethod :: !a -> AnyMethod m
newtype MethodCompiled m
MkMethodCompiled :: (Arguments m -> m (Invocant m)) -> MethodCompiled m
runMC :: MethodCompiled m -> Arguments m -> m (Invocant m)
instance [overlap ok] Show (AnyMethod m)
instance [overlap ok] Ord (AnyMethod m)
instance [overlap ok] Eq (AnyMethod m)
instance [overlap ok] Monad m => Method m (SimpleMethod m)
instance [overlap ok] Monad m => Method m (AnyMethod m)

module MO.Run
data MethodInvocation m
MkMethodInvocation :: !MethodName -> !Arguments m -> MethodInvocation m
mi_name :: MethodInvocation m -> !MethodName
mi_arguments :: MethodInvocation m -> !Arguments m
class Monad m => ResponderInterface m a | a -> m
fromMethodList :: ResponderInterface m a => [(MethodName, MethodCompiled m)] -> m a
dispatch :: ResponderInterface m a => a -> Invocant m -> MethodInvocation m -> m (Invocant m)
data Monad m => NoResponse m
NoResponse :: NoResponse m
emptyResponder :: (Typeable1 m, Monad m) => AnyResponder m

-- | This is a static method table.
data MethodTable m
MkMethodTable :: !AtomMap (MethodCompiled m) -> MethodTable m
mt_methods :: MethodTable m -> !AtomMap (MethodCompiled m)
data AnyResponder m
MkResponder :: !m c -> AnyResponder m
fromInvocant :: (Typeable1 m, Monad m, Typeable b) => Arguments m -> m b
ivDispatch :: (Typeable1 m, Monad m) => Invocant m -> MethodInvocation m -> m (Invocant m)
__ :: (Typeable1 m, Monad m, Ord a, Show a, Typeable a) => a -> Invocant m
mkArgs :: (Typeable1 m, Monad m) => [Invocant m] -> Arguments m
instance [overlap ok] (Typeable1 m, Monad m) => Ord (Invocant m)
instance [overlap ok] (Typeable1 m, Monad m) => Eq (Invocant m)
instance [overlap ok] (Typeable1 m, Monad m) => Show (Invocant m)
instance [overlap ok] (Typeable1 m, Monad m) => Typeable (Invocant m)
instance [overlap ok] (Typeable1 m, Monad m) => Typeable (AnyResponder m)
instance [overlap ok] (Typeable1 m, Monad m) => ResponderInterface m (MethodTable m)
instance [overlap ok] Monad m => ResponderInterface m (NoResponse m)

module MO.Compile.Attribute
type AttributeName = Atom
data Monad m => Attribute m
MkAttribute :: AttributeName -> AttributeName -> Bool -> m (Invocant m) -> Attribute m
a_name :: Attribute m -> AttributeName
a_accessor_name :: Attribute m -> AttributeName
a_is_private :: Attribute m -> Bool
a_default :: Attribute m -> m (Invocant m)
mkAttributeMandatory :: Monad m => AttributeName -> Attribute m
mkPrivateAttributeMandatory :: Monad m => AttributeName -> Attribute m
mkAttributeStub :: (Typeable1 m, Monad m) => AttributeName -> Attribute m
mkPrivateAttributeStub :: (Typeable1 m, Monad m) => AttributeName -> Attribute m
mkAttribute :: Monad m => AttributeName -> Invocant m -> Attribute m
mkPrivateAttribute :: Monad m => AttributeName -> Invocant m -> Attribute m
instance [overlap ok] Monad m => Ord (Attribute m)
instance [overlap ok] Monad m => Eq (Attribute m)
instance [overlap ok] Monad m => Show (Attribute m)

module MO.Compile.Role
data Role m
MkRole :: [Role m] -> [Attribute m] -> Collection (AnyMethod m) -> Collection (AnyMethod m) -> Role m
r_roles :: Role m -> [Role m]
r_attributes :: Role m -> [Attribute m]
r_public_methods :: Role m -> Collection (AnyMethod m)
r_private_methods :: Role m -> Collection (AnyMethod m)
emptyRole :: Role m
parent_roles :: Role m -> [Role m]
role_public_methods, role_private_methods :: Role m -> Collection (AnyMethod m)
role_attributes :: Role m -> [Attribute m]
all_using_role_shadowing :: (Show a, Ord a) => Role m -> (Role m -> Collection a) -> Collection a
all_using_role_inheritance :: (Show a, Ord a) => Role m -> (Role m -> Collection a) -> Collection a
instance [overlap ok] Monad m => Eq (Role m)

module MO.Compile.Class
type ClassName = Atom
class (Typeable1 m, Monad m, Typeable c, Eq c) => Class m c | c -> m
class_name :: Class m c => c -> ClassName
superclasses :: Class m c => c -> [AnyClass m]
class_precedence_list :: Class m c => c -> [AnyClass m]
all_attributes :: Class m c => c -> [Attribute m]
all_attribute_methods :: Class m c => c -> [AnyMethod m]
all_methods :: Class m c => c -> [AnyMethod m]
all_regular_methods :: Class m c => c -> [AnyMethod m]
roles :: Class m c => c -> [Role m]
merged_roles :: Class m c => c -> Role m
attributes :: Class m c => c -> [Attribute m]
public_methods :: Class m c => c -> Collection (AnyMethod m)
private_methods :: Class m c => c -> Collection (AnyMethod m)
class_interface :: Class m c => c -> AnyResponder m
data AnyClass m
MkClass :: !c -> AnyClass m
data (Monad m, Typeable1 m) => MOClass m
MkMOClass :: [AnyClass m] -> [Role m] -> [Attribute m] -> Collection (AnyMethod m) -> Collection (AnyMethod m) -> ClassName -> MOClass m
moc_parents :: MOClass m -> [AnyClass m]
moc_roles :: MOClass m -> [Role m]
moc_attributes :: MOClass m -> [Attribute m]
moc_public_methods :: MOClass m -> Collection (AnyMethod m)
moc_private_methods :: MOClass m -> Collection (AnyMethod m)
moc_name :: MOClass m -> ClassName
emptyMOClass :: (Typeable1 m, Monad m) => MOClass m
_bless :: MethodName
newMOClass :: (Typeable1 m, Monad m) => MOClass m -> MOClass m
blessMOClass :: Class m c => c -> AnyMethod m
data MethodAttached m
MkMethodAttached :: !c -> !a -> MethodAttached m
instance [overlap ok] Monad m => Method m (MethodAttached m)
instance [overlap ok] (Typeable1 m, Monad m) => Class m (MOClass m)
instance [overlap ok] (Typeable1 m, Monad m) => Typeable (MOClass m)
instance [overlap ok] (Typeable1 m, Monad m) => Eq (MOClass m)
instance [overlap ok] (Typeable1 m, Monad m) => Ord (MOClass m)
instance [overlap ok] (Typeable1 m, Monad m) => Show (MOClass m)
instance [overlap ok] (Typeable1 m, Monad m) => Class m (AnyClass m)
instance [overlap ok] (Typeable1 m, Monad m) => Show (AnyClass m)
instance [overlap ok] (Typeable1 m, Monad m) => Eq (AnyClass m)
instance [overlap ok] (Typeable1 m, Monad m) => Typeable (AnyClass m)
