-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | XBee ZNet 2.5 (ZigBee) wireless modem communications
--   
--   A protocol library enabling wireless communications via XBee/XBee-PRO
--   (ZibBee) ZNet 2.5 RF modules.
--   
--   The library performs binary encoding/decoding, on-the-wire framing,
--   and error checking of control and data <a>API</a> frames. In other
--   words the library expects to communicate with an XBee modem that has
--   AP parameter = 2, indicating API frames with HDLC-like escape
--   characters. This mode provides for 8-bit transparent operation and is
--   described in Section 6 of
--   <a>ftp://ftp1.digi.com/support/documentation/90000866_C.pdf</a>.
--   
--   The library code is 100% pure; nothing here depends on the IO monad
--   and no particular modem device is assumed. The code depends on the
--   <tt>cereal</tt> package for serialization but is otherwise pretty
--   standard. The test suite is based on <tt>QuickCheck</tt> properties.
@package zigbee-znet25
@version 0.1.1.0


-- | XBee ZNet 2.5 (ZigBee) frame types
module Network.Protocol.ZigBee.ZNet25.Frame

-- | API frame types. See Section 6 of the XBee ZNet 2.5 Product Manual
--   (<a>ftp://ftp1.digi.com/support/documentation/90000866_C.pdf</a>) for
--   frame type-specific documentation.
data Frame
ApiIdNotImplemented :: Word8 -> Frame
ModemStatus :: ModemStatusByte -> Frame
ATCommand :: FrameId -> CommandName -> ByteString -> Frame
ATCommandQueueParameterValue :: FrameId -> CommandName -> ByteString -> Frame
ATCommandResponse :: FrameId -> CommandName -> CommandStatus -> ByteString -> Frame
RemoteCommandRequest :: FrameId -> Address -> NetworkAddress -> CommandOptions -> CommandName -> ByteString -> Frame
RemoteCommandResponse :: FrameId -> Address -> NetworkAddress -> CommandName -> CommandStatus -> ByteString -> Frame
ZigBeeTransmitRequest :: FrameId -> Address -> NetworkAddress -> BroadcastRadius -> TransmitOptions -> ByteString -> Frame
ExplicitAddressingZigBeeCommandFrame :: FrameId -> Address -> NetworkAddress -> SourceEndpoint -> DestinationEndpoint -> ClusterId -> ProfileId -> BroadcastRadius -> TransmitOptions -> ByteString -> Frame
ZigBeeTransmitStatus :: FrameId -> NetworkAddress -> TransmitRetryCount -> DeliveryStatus -> DiscoveryStatus -> Frame
ZigBeeReceivePacket :: Address -> NetworkAddress -> ReceiveOptions -> ByteString -> Frame
ZigBeeExplicitRxIndicator :: Address -> NetworkAddress -> SourceEndpoint -> DestinationEndpoint -> ClusterId -> ProfileId -> ReceiveOptions -> ByteString -> Frame
ZigBeeIODataSampleIndicator :: Address -> NetworkAddress -> ReceiveOptions -> SampleCount -> DigitalChannelMask -> AnalogChannelMask -> ByteString -> Frame
XBeeSensorReadIndicator :: Address -> NetworkAddress -> ReceiveOptions -> XBeeSensorMask -> ByteString -> Frame
NodeIdentificationIndicator :: Address -> NetworkAddress -> ReceiveOptions -> RemoteNetworkAddress -> RemoteAddress -> String -> ParentNetworkAddress -> DeviceType -> SourceAction -> ProfileId -> ManufacturerId -> Frame

-- | <tt>AT</tt> command names. These are limited to two bytes, e.g.
--   <tt>ND</tt> for neightbor discovery.
data CommandName

-- | Construct a <tt>CommandName</tt>. Beware that this function will
--   <a>error</a> if the name is not exactly two bytes long.
commandName :: String -> CommandName

-- | Deconstruct a <tt>CommandName</tt>.
unCommandName :: CommandName -> String

-- | All XBee ZNet 2.5 modules are identified by a unique (and static)
--   64-bit address.
data Address

-- | Construct an <tt>Address</tt>. Beware that this function will
--   <a>error</a> if the address is not exactly eight bytes long.
address :: ByteString -> Address

-- | Deconstruct an <tt>Address</tt>.
unAddress :: Address -> ByteString

-- | When XBee ZNet 2.5 modules join the network they are assigned a 16-bit
--   address. Note that unlike <a>Address</a> which is unique and static
--   for a given node, a node's <tt>NetworkAddress</tt> is dynamic and may
--   change over time.
data NetworkAddress

-- | Construct a <tt>NetworkAddress</tt>. Beware that this function will
--   <a>error</a> if the address is not exactly two bytes long.
networkAddress :: ByteString -> NetworkAddress

-- | Deconstruct a <tt>NetworkAddress</tt>.
unNetworkAddress :: NetworkAddress -> ByteString
type AnalogChannelMask = Word8
type BroadcastRadius = Word8
type ClusterId = Word8
type CommandOptions = Word8
type CommandStatus = Word8
type DeviceType = Word8
type DeliveryStatus = Word8
type DestinationEndpoint = Word8
type DigitalChannelMask = Word16
type DiscoveryStatus = Word8
type FrameId = Word8
type ManufacturerId = Word8
type ModemStatusByte = Word8
type ParentNetworkAddress = NetworkAddress
type ProfileId = Word8
type ReceiveOptions = Word8
type RemoteAddress = Address
type RemoteNetworkAddress = NetworkAddress
type SampleCount = Word8
type SourceAction = Word8
type SourceEndpoint = Word8
type TransmitOptions = Word8
type TransmitRetryCount = Word8
type XBeeSensorMask = Word8
instance Eq CommandName
instance Ord CommandName
instance Eq Address
instance Ord Address
instance Eq NetworkAddress
instance Ord NetworkAddress
instance Eq Frame
instance Show Frame
instance Serialize NetworkAddress
instance Show NetworkAddress
instance Serialize Address
instance Show Address
instance Serialize CommandName
instance Show CommandName
instance Serialize Frame


-- | XBee ZNet 2.5 (ZigBee) frame encoder/decoder functions
module Network.Protocol.ZigBee.ZNet25.Encoder

-- | Serialize a <a>Frame</a>, escape control characters, and wrap the
--   result with framing bytes. Return an array of <a>ByteString</a>
--   suitable for transmission to the XBee modem.
--   
--   Note that this function returns an array of <a>ByteString</a>.
--   Encoding takes place in a piece-wise manner and for efficiency's sake
--   the individual bits are not concatenated to form a single
--   <a>ByteString</a>. Typically this is a non-issue however if you need a
--   single <a>ByteString</a> representation of the <a>Frame</a> you can
--   always obtain it by calling <a>concat</a>.
--   
--   Here's an example that illustrates <a>encode</a> usage as well as the
--   on-the-wire frame format:
--   
--   <pre>
--   import qualified Data.ByteString as B
--   import Network.Protocol.ZigBee.ZNet25
--   import Text.Printf
--   
--   main = hexdump $ B.concat $ encode (ATCommand 0 (commandName "ND") B.empty)
--   
--   hexdump = mapM_ (putStr . printf "%02x ") . B.unpack
--   </pre>
--   
--   This prints:
--   
--   <pre>
--   7e 00 04 08 00 4e 44 65
--   </pre>
--   
--   The leading <tt>7e</tt> byte is the frame delimiter. This is followed
--   by the 16-bit frame length (4 bytes in this case), that many bytes of
--   data (the serialized <a>ATCommand</a> frame), and the final checksum
--   byte.
encode :: Frame -> [ByteString]

-- | <a>decode</a> runs in the <a>State</a> monad. <tt>DecoderState</tt>
--   tracks the decoder's in/out-of frame state, current frame length, and
--   other state variables.
data DecoderState

-- | Initial state needed to run <a>decode</a> in the <a>State</a> monad.
initDecode :: DecoderState

-- | Decode a <a>ByteString</a> in the <a>State</a> monad, reversing the
--   <a>encode</a> process. Once a frame delimiter byte is found, the inner
--   frame payload is unescaped, the checksum is verified, and finally a
--   <a>Frame</a> is deserialized.
--   
--   Note that this function may produce zero or more errors or
--   <a>Frame</a>s depending on the <a>DecoderState</a> and input byte
--   string. Errors will be reported for checksum errors and <a>Frame</a>
--   deserialization failures.
--   
--   Here's a slightly more complex example that <a>encode</a>s two
--   separate frames, runs each array of <a>ByteString</a>s through
--   <tt>decode</tt> and prints the result after running the <a>State</a>
--   monad:
--   
--   <pre>
--   import Control.Monad.State
--   import qualified Data.ByteString as B
--   import Network.Protocol.ZigBee.ZNet25
--   
--   main = putStrLn $ show $ evalState (mapM decode bs) initDecode
--     where
--       bs = concat $ map encode [atndCommand, txRequest]
--       atndCommand = ATCommand 1 (commandName "ND") B.empty
--       txRequest = ZigBeeTransmitRequest 2 addr nwaddr 0 0 $ B.singleton 0x55
--       addr = address $ B.pack [ 0xde, 0xad, 0xbe, 0xef, 0xba, 0xda, 0xba, 0xda ]
--       nwaddr = networkAddress $ B.pack [ 0x55, 0xaa ]
--   </pre>
--   
--   This prints:
--   
--   <pre>
--   [[],[],[],[Right (ATCommand 1 "ND" "")],[],[],[],[Right (ZigBeeTransmitRequest 2 de:ad:be:ef:ba:da:ba:da 55:aa 0 0 "U")]]
--   </pre>
--   
--   Note a few things:
--   
--   <ul>
--   <li>Each call to <a>encode</a> apparently produced four separate
--   <a>ByteString</a>s. This is a by-product of the <a>encode</a>
--   implementation as described above.</li>
--   <li><tt>decode</tt> was only able to produce a result once the final
--   <a>ByteString</a> of each <a>Frame</a> was processed. In this case the
--   result was <a>Right</a> <a>Frame</a>. If an error had occurred, we'd
--   see <a>Left</a> <a>String</a> instead.</li>
--   </ul>
decode :: MonadState DecoderState m => ByteString -> m [Either String Frame]
instance Show FrameState
instance Show DecoderState


-- | A protocol library enabling wireless communications via XBee/XBee-PRO
--   (ZibBee) ZNet 2.5 RF modules.
--   
--   The library performs binary encoding/decoding, on-the-wire framing,
--   and error checking of control and data <a>API</a> frames. In other
--   words the library expects to communicate with an XBee modem that has
--   AP parameter = 2, indicating API frames with HDLC-like escape
--   characters. This mode provides for 8-bit transparent operation and is
--   described in Section 6 of
--   <a>ftp://ftp1.digi.com/support/documentation/90000866_C.pdf</a>.
--   
--   The library code is 100% pure; nothing here depends on the IO monad
--   and no particular modem device is assumed. The code depends on the
--   <tt>cereal</tt> package for serialization but is otherwise pretty
--   standard. The test suite is based on <tt>QuickCheck</tt> properties.
module Network.Protocol.ZigBee.ZNet25
