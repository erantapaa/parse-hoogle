-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shared library used be ide-backend and ide-backend-server
--   
@package ide-backend-common
@version 0.9.1.3


-- | Version on StateT which evaluates the state strictly at every step
module IdeSession.Strict.StateT
newtype StrictStateT s m a
StrictStateT :: (s -> m (a, s)) -> StrictStateT s m a
runStateT :: StrictStateT s m a -> s -> m (a, s)

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()
evalStateT :: Monad m => StrictStateT s m a -> s -> m a
execStateT :: Monad m => StrictStateT s m a -> s -> m s
type StrictState s = StrictStateT s Identity
runState :: StrictState s a -> s -> (a, s)
evalState :: StrictState s a -> s -> a
execState :: StrictState s a -> s -> s
instance MonadTrans (StrictStateT s)
instance Monad m => MonadState s (StrictStateT s m)
instance Monad m => Functor (StrictStateT s m)
instance Monad m => Monad (StrictStateT s m)
instance Monad m => Applicative (StrictStateT s m)

module IdeSession.Strict.IORef
data StrictIORef a
newIORef :: a -> IO (StrictIORef a)
readIORef :: StrictIORef a -> IO a
writeIORef :: StrictIORef a -> a -> IO ()
modifyIORef :: StrictIORef a -> (a -> a) -> IO ()

module IdeSession.Strict.IntervalMap
data StrictIntervalMap v a
dominators :: Ord v => Interval v -> StrictIntervalMap v a -> [(Interval v, a)]
fromList :: Ord v => [(Interval v, a)] -> StrictIntervalMap v a
toList :: Ord v => StrictIntervalMap v a -> [(Interval v, a)]
empty :: Ord v => StrictIntervalMap v a
insert :: Ord v => Interval v -> a -> StrictIntervalMap v a -> StrictIntervalMap v a

-- | A closed interval. The lower bound should be less than or equal to the
--   higher bound.
data Interval v :: * -> *
Interval :: v -> v -> Interval v
low :: Interval v -> v
high :: Interval v -> v
instance (Ord v, PrettyVal v, PrettyVal a) => PrettyVal (StrictIntervalMap v a)
instance (Ord v, Show v, Show a) => Show (StrictIntervalMap v a)


-- | Strict pairs
--   
--   Unfortunately, this doesn't fit into the Strict.Container hierarchy
--   (different kind)
module IdeSession.Strict.Pair
data StrictPair a b
toLazyPair :: StrictPair a b -> (a, b)
fromLazyPair :: (a, b) -> StrictPair a b


-- | Wrapper around binary
module IdeSession.RPC.Stream
data Stream a
newStream :: Binary a => Handle -> IO (Stream a)
nextInStream :: Stream a -> IO a

module IdeSession.RPC.API

-- | Exceptions thrown by the remote server
data ExternalException
ExternalException :: String -> Maybe IOException -> ExternalException

-- | The output from the server on stderr
externalStdErr :: ExternalException -> String

-- | The local exception that was thrown and alerted us to the problem
externalException :: ExternalException -> Maybe IOException

-- | Generic exception thrown if the server gets killed for unknown reason
serverKilledException :: Maybe IOException -> ExternalException
data RpcConversation
RpcConversation :: (forall a. (Typeable a, Binary a) => IO a) -> (forall a. (Typeable a, Binary a) => a -> IO ()) -> RpcConversation
get :: RpcConversation -> forall a. (Typeable a, Binary a) => IO a
put :: RpcConversation -> forall a. (Typeable a, Binary a) => a -> IO ()
data Request
Request :: IncBS -> Request
RequestShutdown :: Request
newtype Response
Response :: IncBS -> Response
newtype IncBS
IncBS :: ByteString -> IncBS
unIncBS :: IncBS -> ByteString

-- | Write a bytestring to a buffer and flush
hPutFlush :: Handle -> ByteString -> IO ()

-- | Ignore IO exceptions
ignoreIOExceptions :: IO () -> IO ()

-- | Open a pipe for writing
--   
--   This is meant to be used together with <a>openPipeForReading</a>
openPipeForWriting :: FilePath -> Int -> IO Handle

-- | Open a pipe for reading
--   
--   This is meant to be used together with <a>openPipeForWriting</a>
openPipeForReading :: FilePath -> Int -> IO Handle
instance Typeable ExternalException
instance Typeable RPCPipeNotCreated
instance Eq ExternalException
instance Show Request
instance Show RPCPipeNotCreated
instance Exception RPCPipeNotCreated
instance Show IncBS
instance Binary IncBS
instance Binary Response
instance Binary Request
instance Exception ExternalException
instance Show ExternalException


-- | (Orphan) PrettyVal instances for various standard datatypes
module IdeSession.Util.PrettyVal

-- | A class for types that may be reified into a value. Instances of this
--   class may be derived automatically, for datatypes that support
--   <tt>Generics</tt>.
class PrettyVal a
prettyVal :: PrettyVal a => a -> Value
instance PrettyVal Text
instance PrettyVal Bool
instance PrettyVal a => PrettyVal (Trie a)
instance (PrettyVal k, PrettyVal a) => PrettyVal (Map k a)
instance PrettyVal a => PrettyVal (IntMap a)
instance PrettyVal ByteString
instance PrettyVal a => PrettyVal (Maybe a)


-- | MVar that always evaluates its argument to WHNF
module IdeSession.Strict.MVar
data StrictMVar a
newEmptyMVar :: IO (StrictMVar a)
newMVar :: a -> IO (StrictMVar a)
takeMVar :: StrictMVar a -> IO a
putMVar :: StrictMVar a -> a -> IO ()
readMVar :: StrictMVar a -> IO a
swapMVar :: StrictMVar a -> a -> IO a
tryTakeMVar :: StrictMVar a -> IO (Maybe a)
tryPutMVar :: StrictMVar a -> a -> IO Bool
isEmptyMVar :: StrictMVar a -> IO Bool
withMVar :: StrictMVar a -> (a -> IO b) -> IO b
modifyMVar_ :: StrictMVar a -> (a -> IO a) -> IO ()
modifyMVar :: StrictMVar a -> (a -> IO (a, b)) -> IO b


-- | Blocking operations such as
--   
--   <pre>
--   readMVar v
--   </pre>
--   
--   may throw an exception such as
--   
--   <pre>
--   thread blocked indefinitely in an MVar operation
--   </pre>
--   
--   Unfortunately, this exception does not give any information of _where_
--   in the code we are blocked indefinitely. Compiling with profiling info
--   and running with +RTC -xc can address this to some extent, but (1) it
--   requires that all profiling libraries are installed and (2) when we
--   are running multithreaded code the resulting stack trace is often
--   difficult to read (and still does not include line numbers). With this
--   module you can replace the above code with
--   
--   <pre>
--   $readMVar v
--   </pre>
--   
--   and the exception that will be thrown is
--   
--   <pre>
--   YourModule:lineNumber: thread blocked indefinitely in an MVar operation
--   </pre>
--   
--   which is a lot more informative. When the CPP flag DEBUGGING is turned
--   off then <tt>$readMVar</tt> just turns into <tt>readMVar</tt>.
--   
--   NOTE: The type of the exception changes when using DEBUGGING mode --
--   in order to be able to add the line number, all exceptions are turned
--   into IOExceptions.
module IdeSession.Util.BlockingOps
lineNumber :: ExpQ
traceOnException :: String -> IO a -> IO a
mapExceptionIO :: (Exception e1, Exception e2) => (e1 -> e2) -> IO a -> IO a
mapExceptionShow :: (String -> String) -> IO a -> IO a
putMVar :: ExpQ
takeMVar :: ExpQ
modifyMVar :: ExpQ
modifyMVar_ :: ExpQ
withMVar :: ExpQ
readMVar :: ExpQ
swapMVar :: ExpQ
putStrictMVar :: ExpQ
takeStrictMVar :: ExpQ
modifyStrictMVar :: ExpQ
modifyStrictMVar_ :: ExpQ
withStrictMVar :: ExpQ
readStrictMVar :: ExpQ
swapStrictMVar :: ExpQ
readChan :: ExpQ
wait :: ExpQ
waitCatch :: ExpQ
waitAny :: ExpQ
waitAnyCatchCancel :: ExpQ

module IdeSession.RPC.Server
rpcServer :: (FilePath -> RpcConversation -> IO ()) -> [String] -> IO ()

-- | Start a concurrent conversation.
concurrentConversation :: FilePath -> FilePath -> FilePath -> (FilePath -> RpcConversation -> IO ()) -> IO ()
data RpcConversation
RpcConversation :: (forall a. (Typeable a, Binary a) => IO a) -> (forall a. (Typeable a, Binary a) => a -> IO ()) -> RpcConversation
get :: RpcConversation -> forall a. (Typeable a, Binary a) => IO a
put :: RpcConversation -> forall a. (Typeable a, Binary a) => a -> IO ()
instance Show ServerEvent

module IdeSession.Strict.Container
class StrictContainer t where data family Strict (t :: * -> *) :: * -> *
force :: StrictContainer t => t a -> Strict t a
project :: StrictContainer t => Strict t a -> t a

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a :: * -> *

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a :: * -> * -> *

-- | A map of integers to values <tt>a</tt>.
data IntMap a :: * -> *

-- | A map from <a>ByteString</a>s to <tt>a</tt>. For all the generic
--   functions, note that tries are strict in the <tt>Maybe</tt> but not in
--   <tt>a</tt>.
--   
--   The <a>Monad</a> instance is strange. If a key <tt>k1</tt> is a prefix
--   of other keys, then results from binding the value at <tt>k1</tt> will
--   override values from longer keys when they collide. If this is useful
--   for anything, or if there's a more sensible instance, I'd be curious
--   to know.
data Trie a :: * -> *
instance Ord a => Ord (Strict Maybe a)
instance Eq a => Eq (Strict Maybe a)
instance Eq a => Eq (Strict Trie a)
instance Show a => Show (Strict Trie a)
instance Show a => Show (Strict Maybe a)
instance (Eq k, Eq v) => Eq (Strict (Map k) v)
instance (Show k, Show v) => Show (Strict (Map k) v)
instance Eq a => Eq (Strict [] a)
instance Show a => Show (Strict [] a)
instance Eq v => Eq (Strict IntMap v)
instance Show v => Show (Strict IntMap v)
instance PrettyVal a => PrettyVal (Strict Trie a)
instance StrictContainer Trie
instance Alternative (Strict Maybe)
instance Applicative (Strict Maybe)
instance PrettyVal a => PrettyVal (Strict Maybe a)
instance Functor (Strict Maybe)
instance Binary a => Binary (Strict Maybe a)
instance StrictContainer Maybe
instance (PrettyVal k, PrettyVal v) => PrettyVal (Strict (Map k) v)
instance (Ord k, Binary k, Binary v) => Binary (Strict (Map k) v)
instance StrictContainer (Map k)
instance PrettyVal a => PrettyVal (Strict [] a)
instance Binary a => Binary (Strict [] a)
instance StrictContainer []
instance PrettyVal v => PrettyVal (Strict IntMap v)
instance Binary v => Binary (Strict IntMap v)
instance StrictContainer IntMap


-- | Wrapper around Data.Map that guarantees elements are evaluated when
--   the Map is. containers-0.5 provides this out of the box, but alas ghc
--   7.4 is built against containers-0.4.
module IdeSession.Strict.Map
toList :: Strict (Map k) v -> [(k, v)]
fromList :: Ord k => [(k, v)] -> Strict (Map k) v
map :: (a -> b) -> Strict (Map k) a -> Strict (Map k) b
mapWithKey :: (k -> a -> b) -> Strict (Map k) a -> Strict (Map k) b
mapKeys :: Ord k' => (k -> k') -> Strict (Map k) v -> Strict (Map k') v
empty :: Strict (Map k) v
insert :: Ord k => k -> v -> Strict (Map k) v -> Strict (Map k) v

-- | Left biased union
union :: Ord k => Strict (Map k) v -> Strict (Map k) v -> Strict (Map k) v
unions :: Ord k => [Strict (Map k) v] -> Strict (Map k) v
filterWithKey :: Ord k => (k -> v -> Bool) -> Strict (Map k) v -> Strict (Map k) v
lookup :: Ord k => k -> Strict (Map k) v -> Maybe v
findWithDefault :: Ord k => v -> k -> Strict (Map k) v -> v
keysSet :: Strict (Map k) v -> Set k
(\\) :: Ord k => Strict (Map k) a -> Strict (Map k) b -> Strict (Map k) a
alter :: Ord k => (Maybe a -> Maybe a) -> k -> Strict (Map k) a -> Strict (Map k) a
adjust :: Ord k => (v -> v) -> k -> Strict (Map k) v -> Strict (Map k) v
member :: Ord k => k -> Strict (Map k) v -> Bool
(!) :: Ord k => Strict (Map k) v -> k -> v
keys :: Strict (Map k) a -> [k]
elems :: Strict (Map k) a -> [a]
delete :: Ord k => k -> Strict (Map k) a -> Strict (Map k) a
accessor :: Ord k => k -> Accessor (Strict (Map k) a) (Maybe a)
accessorDefault :: Ord k => v -> k -> Accessor (Strict (Map k) v) v


-- | Wrapper around Data.IntMap that guarantees elements are evaluated when
--   the Map is. containers-0.5 provides this out of the box, but alas ghc
--   7.4 is built against containers-0.4.
module IdeSession.Strict.IntMap
fromList :: [(Int, v)] -> Strict IntMap v
toList :: Strict IntMap v -> [(Int, v)]
lookup :: Int -> Strict IntMap v -> Maybe v
findWithDefault :: v -> Int -> Strict IntMap v -> v
empty :: Strict IntMap v
adjust :: (v -> v) -> Int -> Strict IntMap v -> Strict IntMap v
insertWith :: (v -> v -> v) -> Int -> v -> Strict IntMap v -> Strict IntMap v
map :: (a -> b) -> Strict IntMap a -> Strict IntMap b
reverseLookup :: Eq v => Strict IntMap v -> v -> Maybe Int
filter :: (v -> Bool) -> Strict IntMap v -> Strict IntMap v
filterWithKey :: (Int -> v -> Bool) -> Strict IntMap v -> Strict IntMap v
union :: Strict IntMap v -> Strict IntMap v -> Strict IntMap v


-- | Strict lists
module IdeSession.Strict.List
nil :: Strict [] a
cons :: a -> Strict [] a -> Strict [] a
singleton :: a -> Strict [] a
map :: (a -> b) -> Strict [] a -> Strict [] b
all :: (a -> Bool) -> Strict [] a -> Bool
any :: (a -> Bool) -> Strict [] a -> Bool
reverse :: Strict [] a -> Strict [] a
(++) :: Strict [] a -> Strict [] a -> Strict [] a
elem :: Eq a => a -> Strict [] a -> Bool
(\\) :: Eq a => Strict [] a -> Strict [] a -> Strict [] a


-- | Version of maybe that is strict in its argument
module IdeSession.Strict.Maybe
nothing :: Strict Maybe a
just :: a -> Strict Maybe a
maybe :: b -> (a -> b) -> Strict Maybe a -> b
fromMaybe :: a -> Strict Maybe a -> a

module IdeSession.Strict.Trie
empty :: Strict Trie a
submap :: ByteString -> Strict Trie a -> Strict Trie a
elems :: Strict Trie a -> [a]
fromListWith :: (a -> a -> a) -> [(ByteString, a)] -> Strict Trie a
toList :: Strict Trie a -> [(ByteString, a)]

module IdeSession.Util

-- | Show an exception together with its most precise type tag.
showExWithClass :: SomeException -> String

-- | Translate record field <tt>_name</tt> to the accessor <tt>name</tt>
accessorName :: String -> Maybe String

-- | Prelude.lookup as an accessor
lookup' :: Eq a => a -> Accessor [(a, b)] (Maybe b)
envWithPathOverride :: [FilePath] -> IO (Maybe [(String, String)])

-- | Writes a file atomically.
--   
--   The file is either written successfully or an IO exception is raised
--   and the original file is left unchanged.
--   
--   On windows it is not possible to delete a file that is open by a
--   process. This case will give an IO exception but the atomic property
--   is not affected.
--   
--   Returns the hash of the file; we are careful not to force the entire
--   input bytestring into memory (we compute the hash as we write the
--   file).
writeFileAtomic :: FilePath -> ByteString -> IO MD5Digest

-- | First restore the environment to the specified initial environment,
--   then apply the given overrides
setupEnv :: [(String, String)] -> [(String, Maybe String)] -> IO ()
relInclToOpts :: FilePath -> [FilePath] -> [String]
parseProgressMessage :: Text -> Either String (Int, Int, Text)

-- | Ignore "does not exist" exception
ignoreDoesNotExist :: IO () -> IO ()

-- | Define interruptiple operations
--   
--   (TODO: Stick in reference to blog post)
interruptible :: IO a -> IO a
data Diff a
Keep :: Diff a
Remove :: Diff a
Insert :: a -> Diff a
applyMapDiff :: Ord k => Strict (Map k) (Diff v) -> Strict (Map k) v -> Strict (Map k) v
swizzleStdout :: Fd -> IO a -> IO a
swizzleStderr :: Fd -> IO a -> IO a
redirectStderr :: FilePath -> IO a -> IO a
captureOutput :: IO a -> IO (String, a)
instance Binary CPid
instance Show a => Show (Diff a)
instance Functor Diff
instance Generic (Diff a)
instance Datatype D1Diff
instance Constructor C1_0Diff
instance Constructor C1_1Diff
instance Constructor C1_2Diff
instance PrettyVal a => PrettyVal (Diff a)
instance Binary a => Binary (Diff a)


-- | The public types
module IdeSession.Types.Public

-- | Identifiers in Haskell are drawn from a number of different name
--   spaces
data IdNameSpace

-- | Variables, including real data constructors
VarName :: IdNameSpace

-- | Source data constructors
DataName :: IdNameSpace

-- | Type variables
TvName :: IdNameSpace

-- | Type constructors and classes
TcClsName :: IdNameSpace

-- | For now we represent types in pretty-printed form
type Type = Text

-- | Variable name
type Name = Text

-- | Information about identifiers
data IdInfo
IdInfo :: {-# UNPACK #-} !IdProp -> !IdScope -> IdInfo
idProp :: IdInfo -> {-# UNPACK #-} !IdProp
idScope :: IdInfo -> !IdScope

-- | Identifier info that is independent of the usage site
data IdProp
IdProp :: !Name -> !IdNameSpace -> !(Maybe Type) -> {-# UNPACK #-} !ModuleId -> !EitherSpan -> !(Maybe ModuleId) -> IdProp

-- | The base name of the identifer at this location. Module prefix is not
--   included.
idName :: IdProp -> !Name

-- | Namespace this identifier is drawn from
idSpace :: IdProp -> !IdNameSpace

-- | The type We don't always know this; in particular, we don't know kinds
--   because the type checker does not give us LSigs for top-level
--   annotations)
idType :: IdProp -> !(Maybe Type)

-- | Module the identifier was defined in
idDefinedIn :: IdProp -> {-# UNPACK #-} !ModuleId

-- | Where in the module was it defined (not always known)
idDefSpan :: IdProp -> !EitherSpan

-- | Haddock home module
idHomeModule :: IdProp -> !(Maybe ModuleId)
data IdScope

-- | This is a binding occurrence (<tt>f x = ..</tt>, <tt>x -&gt; ..</tt>,
--   etc.)
Binder :: IdScope

-- | Defined within this module
Local :: IdScope

-- | Imported from a different module
Imported :: {-# UNPACK #-} !ModuleId -> !EitherSpan -> !Text -> IdScope
idImportedFrom :: IdScope -> {-# UNPACK #-} !ModuleId
idImportSpan :: IdScope -> !EitherSpan

-- | Qualifier used for the import
--   
--   <pre>
--   IMPORTED AS                       idImportQual
--   import Data.List                  ""
--   import qualified Data.List        "Data.List."
--   import qualified Data.List as L   "L."
--   </pre>
idImportQual :: IdScope -> !Text

-- | Wired into the compiler (<tt>()</tt>, <tt>True</tt>, etc.)
WiredIn :: IdScope
data SourceSpan
SourceSpan :: !FilePath -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> SourceSpan
spanFilePath :: SourceSpan -> !FilePath
spanFromLine :: SourceSpan -> {-# UNPACK #-} !Int
spanFromColumn :: SourceSpan -> {-# UNPACK #-} !Int
spanToLine :: SourceSpan -> {-# UNPACK #-} !Int
spanToColumn :: SourceSpan -> {-# UNPACK #-} !Int
data EitherSpan
ProperSpan :: {-# UNPACK #-} !SourceSpan -> EitherSpan
TextSpan :: !Text -> EitherSpan

-- | An error or warning in a source module.
--   
--   Most errors are associated with a span of text, but some have only a
--   location point.
data SourceError
SourceError :: !SourceErrorKind -> !EitherSpan -> !Text -> SourceError
errorKind :: SourceError -> !SourceErrorKind
errorSpan :: SourceError -> !EitherSpan
errorMsg :: SourceError -> !Text

-- | Severity of an error.
data SourceErrorKind
KindError :: SourceErrorKind
KindWarning :: SourceErrorKind
KindServerDied :: SourceErrorKind
type ModuleName = Text
data ModuleId
ModuleId :: !ModuleName -> {-# UNPACK #-} !PackageId -> ModuleId
moduleName :: ModuleId -> !ModuleName
modulePackage :: ModuleId -> {-# UNPACK #-} !PackageId

-- | A package ID in ide-backend consists of a human-readable package name
--   and version (what Cabal calls a source ID) along with ghc's internal
--   package key (primarily for internal use).
data PackageId
PackageId :: !Text -> !(Maybe Text) -> !Text -> PackageId
packageName :: PackageId -> !Text
packageVersion :: PackageId -> !(Maybe Text)
packageKey :: PackageId -> !Text
data ImportEntities
ImportOnly :: ![Text] -> ImportEntities
ImportHiding :: ![Text] -> ImportEntities
ImportAll :: ImportEntities
data Import
Import :: !ModuleId -> !(Maybe Text) -> !Bool -> !Bool -> !(Maybe ModuleName) -> !ImportEntities -> Import
importModule :: Import -> !ModuleId

-- | Used only for ghc's PackageImports extension
importPackage :: Import -> !(Maybe Text)
importQualified :: Import -> !Bool
importImplicit :: Import -> !Bool
importAs :: Import -> !(Maybe ModuleName)
importEntities :: Import -> !ImportEntities

-- | Returned when the IDE asks "what's at this particular location?"
data SpanInfo

-- | Identifier
SpanId :: IdInfo -> SpanInfo

-- | Quasi-quote. The <a>IdInfo</a> field gives the quasi-quoter
SpanQQ :: IdInfo -> SpanInfo

-- | Buffer modes for running code
--   
--   Note that <tt>NoBuffering</tt> means that something like
--   <a>putStrLn</a> will do a syscall per character, and each of these
--   characters will be read and sent back to the client. This results in a
--   large overhead.
--   
--   When using <tt>LineBuffering</tt> or <tt>BlockBuffering</tt>,
--   <tt>runWait</tt> will not report any output from the snippet until it
--   outputs a linebreak/fills the buffer, respectively (or does an
--   explicit flush). However, you can specify a timeout in addition to the
--   buffering mode; if you set this to <tt>Just n</tt>, the buffer will be
--   flushed every <tt>n</tt> microseconds.
--   
--   NOTE: This is duplicated in the IdeBackendRTS (defined in IdeSession)
data RunBufferMode
RunNoBuffering :: RunBufferMode
RunLineBuffering :: Maybe Int -> RunBufferMode
runBufferTimeout :: RunBufferMode -> Maybe Int
RunBlockBuffering :: Maybe Int -> Maybe Int -> RunBufferMode
runBufferBlockSize :: RunBufferMode -> Maybe Int
runBufferTimeout :: RunBufferMode -> Maybe Int

-- | The outcome of running code
data RunResult

-- | The code terminated okay
RunOk :: RunResult

-- | The code threw an exception
RunProgException :: String -> RunResult

-- | GHC itself threw an exception when we tried to run the code
RunGhcException :: String -> RunResult

-- | The session was restarted
RunForceCancelled :: RunResult

-- | Execution was paused because of a breakpoint
RunBreak :: RunResult

-- | Information about a triggered breakpoint
data BreakInfo
BreakInfo :: ModuleName -> SourceSpan -> Type -> VariableEnv -> BreakInfo

-- | Module containing the breakpoint
breakInfoModule :: BreakInfo -> ModuleName

-- | Location of the breakpoint
breakInfoSpan :: BreakInfo -> SourceSpan

-- | Type of the result
breakInfoResultType :: BreakInfo -> Type

-- | Local variables and their values
breakInfoVariableEnv :: BreakInfo -> VariableEnv

-- | We present values only in pretty-printed form
type Value = Text

-- | Variables during execution (in debugging mode)
type VariableEnv = [(Name, Type, Value)]
data Targets
TargetsInclude :: [FilePath] -> Targets
TargetsExclude :: [FilePath] -> Targets

-- | Construct qualified name following Haskell's scoping rules
idInfoQN :: IdInfo -> String

-- | Show approximately a haddock link (without haddock root) for an id.
--   This is an illustration and a test of the id info, but under ideal
--   conditions could perhaps serve to link to documentation without going
--   via Hoogle.
haddockLink :: IdProp -> IdScope -> String
instance PrettyVal Targets
instance PrettyVal BreakInfo
instance PrettyVal RunResult
instance PrettyVal RunBufferMode
instance PrettyVal SpanInfo
instance PrettyVal Import
instance PrettyVal ImportEntities
instance PrettyVal PackageId
instance PrettyVal ModuleId
instance PrettyVal SourceErrorKind
instance PrettyVal SourceError
instance PrettyVal EitherSpan
instance PrettyVal SourceSpan
instance PrettyVal IdScope
instance PrettyVal IdProp
instance PrettyVal IdInfo
instance PrettyVal IdNameSpace
instance FromJSON RunBufferMode
instance ToJSON RunBufferMode
instance FromJSON RunResult
instance ToJSON RunResult
instance FromJSON BreakInfo
instance ToJSON BreakInfo
instance FromJSON SpanInfo
instance ToJSON SpanInfo
instance FromJSON IdInfo
instance ToJSON IdInfo
instance FromJSON PackageId
instance ToJSON PackageId
instance FromJSON ModuleId
instance ToJSON ModuleId
instance FromJSON EitherSpan
instance ToJSON EitherSpan
instance FromJSON SourceSpan
instance ToJSON SourceSpan
instance FromJSON IdScope
instance ToJSON IdScope
instance FromJSON IdProp
instance ToJSON IdProp
instance FromJSON SourceError
instance ToJSON SourceError
instance FromJSON Import
instance ToJSON Import
instance FromJSON ImportEntities
instance ToJSON ImportEntities
instance FromJSON SourceErrorKind
instance ToJSON SourceErrorKind
instance FromJSON IdNameSpace
instance ToJSON IdNameSpace
instance Typeable RunBufferMode
instance Typeable RunResult
instance Typeable BreakInfo
instance Typeable Targets
instance Show IdNameSpace
instance Eq IdNameSpace
instance Generic IdNameSpace
instance Eq SourceSpan
instance Ord SourceSpan
instance Generic SourceSpan
instance Eq EitherSpan
instance Generic EitherSpan
instance Show SourceErrorKind
instance Eq SourceErrorKind
instance Generic SourceErrorKind
instance Show SourceError
instance Eq SourceError
instance Generic SourceError
instance Eq PackageId
instance Ord PackageId
instance Generic PackageId
instance Eq ModuleId
instance Ord ModuleId
instance Generic ModuleId
instance Eq IdScope
instance Generic IdScope
instance Eq IdProp
instance Generic IdProp
instance Eq IdInfo
instance Generic IdInfo
instance Show ImportEntities
instance Eq ImportEntities
instance Ord ImportEntities
instance Generic ImportEntities
instance Show Import
instance Eq Import
instance Ord Import
instance Generic Import
instance Eq SpanInfo
instance Generic SpanInfo
instance Show RunBufferMode
instance Generic RunBufferMode
instance Eq RunBufferMode
instance Show RunResult
instance Eq RunResult
instance Generic RunResult
instance Show BreakInfo
instance Eq BreakInfo
instance Generic BreakInfo
instance Generic Targets
instance Eq Targets
instance Show Targets
instance Datatype D1IdNameSpace
instance Constructor C1_0IdNameSpace
instance Constructor C1_1IdNameSpace
instance Constructor C1_2IdNameSpace
instance Constructor C1_3IdNameSpace
instance Datatype D1SourceSpan
instance Constructor C1_0SourceSpan
instance Selector S1_0_0SourceSpan
instance Selector S1_0_1SourceSpan
instance Selector S1_0_2SourceSpan
instance Selector S1_0_3SourceSpan
instance Selector S1_0_4SourceSpan
instance Datatype D1EitherSpan
instance Constructor C1_0EitherSpan
instance Constructor C1_1EitherSpan
instance Datatype D1SourceErrorKind
instance Constructor C1_0SourceErrorKind
instance Constructor C1_1SourceErrorKind
instance Constructor C1_2SourceErrorKind
instance Datatype D1SourceError
instance Constructor C1_0SourceError
instance Selector S1_0_0SourceError
instance Selector S1_0_1SourceError
instance Selector S1_0_2SourceError
instance Datatype D1PackageId
instance Constructor C1_0PackageId
instance Selector S1_0_0PackageId
instance Selector S1_0_1PackageId
instance Selector S1_0_2PackageId
instance Datatype D1ModuleId
instance Constructor C1_0ModuleId
instance Selector S1_0_0ModuleId
instance Selector S1_0_1ModuleId
instance Datatype D1IdScope
instance Constructor C1_0IdScope
instance Constructor C1_1IdScope
instance Constructor C1_2IdScope
instance Constructor C1_3IdScope
instance Selector S1_2_0IdScope
instance Selector S1_2_1IdScope
instance Selector S1_2_2IdScope
instance Datatype D1IdProp
instance Constructor C1_0IdProp
instance Selector S1_0_0IdProp
instance Selector S1_0_1IdProp
instance Selector S1_0_2IdProp
instance Selector S1_0_3IdProp
instance Selector S1_0_4IdProp
instance Selector S1_0_5IdProp
instance Datatype D1IdInfo
instance Constructor C1_0IdInfo
instance Selector S1_0_0IdInfo
instance Selector S1_0_1IdInfo
instance Datatype D1ImportEntities
instance Constructor C1_0ImportEntities
instance Constructor C1_1ImportEntities
instance Constructor C1_2ImportEntities
instance Datatype D1Import
instance Constructor C1_0Import
instance Selector S1_0_0Import
instance Selector S1_0_1Import
instance Selector S1_0_2Import
instance Selector S1_0_3Import
instance Selector S1_0_4Import
instance Selector S1_0_5Import
instance Datatype D1SpanInfo
instance Constructor C1_0SpanInfo
instance Constructor C1_1SpanInfo
instance Datatype D1RunBufferMode
instance Constructor C1_0RunBufferMode
instance Constructor C1_1RunBufferMode
instance Constructor C1_2RunBufferMode
instance Selector S1_1_0RunBufferMode
instance Selector S1_2_0RunBufferMode
instance Selector S1_2_1RunBufferMode
instance Datatype D1RunResult
instance Constructor C1_0RunResult
instance Constructor C1_1RunResult
instance Constructor C1_2RunResult
instance Constructor C1_3RunResult
instance Constructor C1_4RunResult
instance Datatype D1BreakInfo
instance Constructor C1_0BreakInfo
instance Selector S1_0_0BreakInfo
instance Selector S1_0_1BreakInfo
instance Selector S1_0_2BreakInfo
instance Selector S1_0_3BreakInfo
instance Datatype D1Targets
instance Constructor C1_0Targets
instance Constructor C1_1Targets
instance Binary Targets
instance Binary RunBufferMode
instance Binary IdInfo
instance Binary PackageId
instance Binary ModuleId
instance Binary EitherSpan
instance Binary SourceSpan
instance Binary IdScope
instance Binary IdProp
instance Binary SourceError
instance Binary Import
instance Binary ImportEntities
instance Binary SourceErrorKind
instance Binary IdNameSpace
instance Show SpanInfo
instance Show IdInfo
instance Show PackageId
instance Show ModuleId
instance Show EitherSpan
instance Show IdScope
instance Show IdProp
instance Show SourceSpan


-- | GHC requests
--   
--   GHC requests use <a>IdeSession.Types.Public</a> types.
module IdeSession.GHC.Requests

-- | Initial handshake with the ghc server
--   
--   Ideally we'd send over the entire IdeStaticInfo but this includes some
--   Cabal fields, and the ghc server does -not- compile against Cabal
--   (although this isn't so important anymore now that we use
--   Cabal-ide-backend)
data GhcInitRequest
GhcInitRequest :: Int -> Bool -> [String] -> Bool -> [String] -> FilePath -> GhcInitRequest
ghcInitClientApiVersion :: GhcInitRequest -> Int
ghcInitGenerateModInfo :: GhcInitRequest -> Bool
ghcInitOpts :: GhcInitRequest -> [String]
ghcInitUserPackageDB :: GhcInitRequest -> Bool
ghcInitSpecificPackageDBs :: GhcInitRequest -> [String]
ghcInitSessionDir :: GhcInitRequest -> FilePath
data GhcRequest
ReqCompile :: Bool -> Targets -> GhcRequest
reqCompileGenCode :: GhcRequest -> Bool
reqCompileTargets :: GhcRequest -> Targets
ReqRun :: RunCmd -> GhcRequest
reqRunCmd :: GhcRequest -> RunCmd
ReqSetEnv :: [(String, Maybe String)] -> GhcRequest
reqSetEnv :: GhcRequest -> [(String, Maybe String)]
ReqSetArgs :: [String] -> GhcRequest
reqSetArgs :: GhcRequest -> [String]
ReqBreakpoint :: ModuleName -> SourceSpan -> Bool -> GhcRequest
reqBreakpointModule :: GhcRequest -> ModuleName
reqBreakpointSpan :: GhcRequest -> SourceSpan
reqBreakpointValue :: GhcRequest -> Bool
ReqPrint :: Name -> Bool -> Bool -> GhcRequest
reqPrintVars :: GhcRequest -> Name
reqPrintBind :: GhcRequest -> Bool
reqPrintForce :: GhcRequest -> Bool
ReqLoad :: [FilePath] -> GhcRequest
reqLoad :: GhcRequest -> [FilePath]
ReqUnload :: [FilePath] -> GhcRequest
reqUnload :: GhcRequest -> [FilePath]
ReqSetGhcOpts :: [String] -> GhcRequest
reqSetGhcOpts :: GhcRequest -> [String]

-- | For debugging only! :)
ReqCrash :: Maybe Int -> GhcRequest
reqCrashDelay :: GhcRequest -> Maybe Int
data GhcRunRequest
GhcRunInput :: ByteString -> GhcRunRequest
GhcRunInterrupt :: GhcRunRequest
data RunCmd
RunStmt :: String -> String -> RunBufferMode -> RunBufferMode -> Bool -> RunCmd
runCmdModule :: RunCmd -> String
runCmdFunction :: RunCmd -> String
runCmdStdout :: RunCmd -> RunBufferMode
runCmdStderr :: RunCmd -> RunBufferMode
runCmdPty :: RunCmd -> Bool
Resume :: RunCmd
instance Typeable GhcInitRequest
instance Typeable RunCmd
instance Typeable GhcRequest
instance Typeable GhcRunRequest
instance Generic GhcInitRequest
instance Generic RunCmd
instance Show RunCmd
instance Generic GhcRequest
instance Show GhcRequest
instance Datatype D1GhcInitRequest
instance Constructor C1_0GhcInitRequest
instance Selector S1_0_0GhcInitRequest
instance Selector S1_0_1GhcInitRequest
instance Selector S1_0_2GhcInitRequest
instance Selector S1_0_3GhcInitRequest
instance Selector S1_0_4GhcInitRequest
instance Selector S1_0_5GhcInitRequest
instance Datatype D1RunCmd
instance Constructor C1_0RunCmd
instance Constructor C1_1RunCmd
instance Selector S1_0_0RunCmd
instance Selector S1_0_1RunCmd
instance Selector S1_0_2RunCmd
instance Selector S1_0_3RunCmd
instance Selector S1_0_4RunCmd
instance Datatype D1GhcRequest
instance Constructor C1_0GhcRequest
instance Constructor C1_1GhcRequest
instance Constructor C1_2GhcRequest
instance Constructor C1_3GhcRequest
instance Constructor C1_4GhcRequest
instance Constructor C1_5GhcRequest
instance Constructor C1_6GhcRequest
instance Constructor C1_7GhcRequest
instance Constructor C1_8GhcRequest
instance Constructor C1_9GhcRequest
instance Selector S1_0_0GhcRequest
instance Selector S1_0_1GhcRequest
instance Selector S1_1_0GhcRequest
instance Selector S1_2_0GhcRequest
instance Selector S1_3_0GhcRequest
instance Selector S1_4_0GhcRequest
instance Selector S1_4_1GhcRequest
instance Selector S1_4_2GhcRequest
instance Selector S1_5_0GhcRequest
instance Selector S1_5_1GhcRequest
instance Selector S1_5_2GhcRequest
instance Selector S1_6_0GhcRequest
instance Selector S1_7_0GhcRequest
instance Selector S1_8_0GhcRequest
instance Selector S1_9_0GhcRequest
instance Binary GhcRunRequest
instance Binary RunCmd
instance Binary GhcRequest
instance Binary GhcInitRequest
instance PrettyVal RunCmd
instance PrettyVal GhcRequest
instance PrettyVal GhcInitRequest


-- | The private types
module IdeSession.Types.Private
newtype FilePathPtr
FilePathPtr :: Int -> FilePathPtr
filePathPtr :: FilePathPtr -> Int
newtype IdPropPtr
IdPropPtr :: Int -> IdPropPtr
idPropPtr :: IdPropPtr -> Int
type UseSites = Strict (Map IdPropPtr) [SourceSpan]

-- | Identifiers in Haskell are drawn from a number of different name
--   spaces
data IdNameSpace

-- | Variables, including real data constructors
VarName :: IdNameSpace

-- | Source data constructors
DataName :: IdNameSpace

-- | Type variables
TvName :: IdNameSpace

-- | Type constructors and classes
TcClsName :: IdNameSpace
data IdInfo
IdInfo :: {-# UNPACK #-} !IdPropPtr -> !IdScope -> IdInfo
idProp :: IdInfo -> {-# UNPACK #-} !IdPropPtr
idScope :: IdInfo -> !IdScope
data IdProp
IdProp :: !Text -> !IdNameSpace -> !(Strict Maybe Type) -> {-# UNPACK #-} !ModuleId -> !EitherSpan -> !(Strict Maybe ModuleId) -> IdProp
idName :: IdProp -> !Text
idSpace :: IdProp -> !IdNameSpace
idType :: IdProp -> !(Strict Maybe Type)
idDefinedIn :: IdProp -> {-# UNPACK #-} !ModuleId
idDefSpan :: IdProp -> !EitherSpan
idHomeModule :: IdProp -> !(Strict Maybe ModuleId)
data IdScope

-- | This is a binding occurrence (<tt>f x = ..</tt>, <tt>x -&gt; ..</tt>,
--   etc.)
Binder :: IdScope

-- | Defined within this module
Local :: IdScope

-- | Imported from a different module
Imported :: {-# UNPACK #-} !ModuleId -> !EitherSpan -> !Text -> IdScope
idImportedFrom :: IdScope -> {-# UNPACK #-} !ModuleId
idImportSpan :: IdScope -> !EitherSpan

-- | Qualifier used for the import
--   
--   <pre>
--   IMPORTED AS                       idImportQual
--   import Data.List                  ""
--   import qualified Data.List        "Data.List."
--   import qualified Data.List as L   "L."
--   </pre>
idImportQual :: IdScope -> !Text

-- | Wired into the compiler (<tt>()</tt>, <tt>True</tt>, etc.)
WiredIn :: IdScope
data SourceSpan
SourceSpan :: {-# UNPACK #-} !FilePathPtr -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> SourceSpan
spanFilePath :: SourceSpan -> {-# UNPACK #-} !FilePathPtr
spanFromLine :: SourceSpan -> {-# UNPACK #-} !Int
spanFromColumn :: SourceSpan -> {-# UNPACK #-} !Int
spanToLine :: SourceSpan -> {-# UNPACK #-} !Int
spanToColumn :: SourceSpan -> {-# UNPACK #-} !Int
data EitherSpan
ProperSpan :: {-# UNPACK #-} !SourceSpan -> EitherSpan
TextSpan :: !Text -> EitherSpan
data SourceError
SourceError :: !SourceErrorKind -> !EitherSpan -> !Text -> SourceError
errorKind :: SourceError -> !SourceErrorKind
errorSpan :: SourceError -> !EitherSpan
errorMsg :: SourceError -> !Text

-- | Severity of an error.
data SourceErrorKind
KindError :: SourceErrorKind
KindWarning :: SourceErrorKind
KindServerDied :: SourceErrorKind
type ModuleName = Text
data ModuleId
ModuleId :: !ModuleName -> {-# UNPACK #-} !PackageId -> ModuleId
moduleName :: ModuleId -> !ModuleName
modulePackage :: ModuleId -> {-# UNPACK #-} !PackageId
data PackageId
PackageId :: !Text -> !(Strict Maybe Text) -> !Text -> PackageId
packageName :: PackageId -> !Text
packageVersion :: PackageId -> !(Strict Maybe Text)
packageKey :: PackageId -> !Text

-- | Used before we convert it to an IdMap
type IdList = [(SourceSpan, SpanInfo)]
newtype IdMap
IdMap :: StrictIntervalMap (FilePathPtr, Int, Int) SpanInfo -> IdMap
idMapToMap :: IdMap -> StrictIntervalMap (FilePathPtr, Int, Int) SpanInfo
newtype ExpMap
ExpMap :: StrictIntervalMap (FilePathPtr, Int, Int) Text -> ExpMap
expMapToMap :: ExpMap -> StrictIntervalMap (FilePathPtr, Int, Int) Text
data SpanInfo
SpanId :: IdInfo -> SpanInfo
SpanQQ :: IdInfo -> SpanInfo
SpanInSplice :: IdInfo -> SpanInfo
data ImportEntities
ImportOnly :: !(Strict [] Text) -> ImportEntities
ImportHiding :: !(Strict [] Text) -> ImportEntities
ImportAll :: ImportEntities
data Import
Import :: !ModuleId -> !(Strict Maybe Text) -> !Bool -> !Bool -> !(Strict Maybe ModuleName) -> !ImportEntities -> Import
importModule :: Import -> !ModuleId

-- | Used only for ghc's PackageImports extension
importPackage :: Import -> !(Strict Maybe Text)
importQualified :: Import -> !Bool
importImplicit :: Import -> !Bool
importAs :: Import -> !(Strict Maybe ModuleName)
importEntities :: Import -> !ImportEntities

-- | The outcome of running code
data RunResult

-- | The code terminated okay
RunOk :: RunResult

-- | The code threw an exception
RunProgException :: String -> RunResult

-- | GHC itself threw an exception when we tried to run the code
RunGhcException :: String -> RunResult

-- | Execution was paused because of a breakpoint
RunBreak :: BreakInfo -> RunResult

-- | Information about a triggered breakpoint
data BreakInfo
BreakInfo :: ModuleName -> SourceSpan -> Type -> VariableEnv -> BreakInfo
breakInfoModule :: BreakInfo -> ModuleName
breakInfoSpan :: BreakInfo -> SourceSpan
breakInfoResultType :: BreakInfo -> Type
breakInfoVariableEnv :: BreakInfo -> VariableEnv
data ExplicitSharingCache
ExplicitSharingCache :: !(Strict IntMap ByteString) -> !(Strict IntMap IdProp) -> ExplicitSharingCache
filePathCache :: ExplicitSharingCache -> !(Strict IntMap ByteString)
idPropCache :: ExplicitSharingCache -> !(Strict IntMap IdProp)
unionCache :: ExplicitSharingCache -> ExplicitSharingCache -> ExplicitSharingCache
mkIdMap :: IdList -> IdMap
mkExpMap :: [(SourceSpan, Text)] -> ExpMap
dominators :: SourceSpan -> StrictIntervalMap (FilePathPtr, Int, Int) a -> [(SourceSpan, a)]
instance Typeable IdInfo
instance Typeable BreakInfo
instance Typeable RunResult
instance Eq FilePathPtr
instance Ord FilePathPtr
instance Show FilePathPtr
instance Generic FilePathPtr
instance Eq IdPropPtr
instance Ord IdPropPtr
instance Show IdPropPtr
instance Generic IdPropPtr
instance Eq SourceSpan
instance Ord SourceSpan
instance Show SourceSpan
instance Generic SourceSpan
instance Show EitherSpan
instance Generic EitherSpan
instance Show SourceError
instance Generic SourceError
instance Show PackageId
instance Eq PackageId
instance Ord PackageId
instance Generic PackageId
instance Show ModuleId
instance Eq ModuleId
instance Generic ModuleId
instance Show IdScope
instance Generic IdScope
instance Show IdInfo
instance Generic IdInfo
instance Show IdProp
instance Generic IdProp
instance Show SpanInfo
instance Generic SpanInfo
instance Show IdMap
instance Generic IdMap
instance Show ExpMap
instance Generic ExpMap
instance Show ImportEntities
instance Eq ImportEntities
instance Generic ImportEntities
instance Show Import
instance Eq Import
instance Generic Import
instance Show BreakInfo
instance Generic BreakInfo
instance Show RunResult
instance Generic RunResult
instance Show ExplicitSharingCache
instance Generic ExplicitSharingCache
instance Datatype D1FilePathPtr
instance Constructor C1_0FilePathPtr
instance Selector S1_0_0FilePathPtr
instance Datatype D1IdPropPtr
instance Constructor C1_0IdPropPtr
instance Selector S1_0_0IdPropPtr
instance Datatype D1SourceSpan
instance Constructor C1_0SourceSpan
instance Selector S1_0_0SourceSpan
instance Selector S1_0_1SourceSpan
instance Selector S1_0_2SourceSpan
instance Selector S1_0_3SourceSpan
instance Selector S1_0_4SourceSpan
instance Datatype D1EitherSpan
instance Constructor C1_0EitherSpan
instance Constructor C1_1EitherSpan
instance Datatype D1SourceError
instance Constructor C1_0SourceError
instance Selector S1_0_0SourceError
instance Selector S1_0_1SourceError
instance Selector S1_0_2SourceError
instance Datatype D1PackageId
instance Constructor C1_0PackageId
instance Selector S1_0_0PackageId
instance Selector S1_0_1PackageId
instance Selector S1_0_2PackageId
instance Datatype D1ModuleId
instance Constructor C1_0ModuleId
instance Selector S1_0_0ModuleId
instance Selector S1_0_1ModuleId
instance Datatype D1IdScope
instance Constructor C1_0IdScope
instance Constructor C1_1IdScope
instance Constructor C1_2IdScope
instance Constructor C1_3IdScope
instance Selector S1_2_0IdScope
instance Selector S1_2_1IdScope
instance Selector S1_2_2IdScope
instance Datatype D1IdInfo
instance Constructor C1_0IdInfo
instance Selector S1_0_0IdInfo
instance Selector S1_0_1IdInfo
instance Datatype D1IdProp
instance Constructor C1_0IdProp
instance Selector S1_0_0IdProp
instance Selector S1_0_1IdProp
instance Selector S1_0_2IdProp
instance Selector S1_0_3IdProp
instance Selector S1_0_4IdProp
instance Selector S1_0_5IdProp
instance Datatype D1SpanInfo
instance Constructor C1_0SpanInfo
instance Constructor C1_1SpanInfo
instance Constructor C1_2SpanInfo
instance Datatype D1IdMap
instance Constructor C1_0IdMap
instance Selector S1_0_0IdMap
instance Datatype D1ExpMap
instance Constructor C1_0ExpMap
instance Selector S1_0_0ExpMap
instance Datatype D1ImportEntities
instance Constructor C1_0ImportEntities
instance Constructor C1_1ImportEntities
instance Constructor C1_2ImportEntities
instance Datatype D1Import
instance Constructor C1_0Import
instance Selector S1_0_0Import
instance Selector S1_0_1Import
instance Selector S1_0_2Import
instance Selector S1_0_3Import
instance Selector S1_0_4Import
instance Selector S1_0_5Import
instance Datatype D1BreakInfo
instance Constructor C1_0BreakInfo
instance Selector S1_0_0BreakInfo
instance Selector S1_0_1BreakInfo
instance Selector S1_0_2BreakInfo
instance Selector S1_0_3BreakInfo
instance Datatype D1RunResult
instance Constructor C1_0RunResult
instance Constructor C1_1RunResult
instance Constructor C1_2RunResult
instance Constructor C1_3RunResult
instance Datatype D1ExplicitSharingCache
instance Constructor C1_0ExplicitSharingCache
instance Selector S1_0_0ExplicitSharingCache
instance Selector S1_0_1ExplicitSharingCache
instance PrettyVal ExplicitSharingCache
instance PrettyVal BreakInfo
instance PrettyVal RunResult
instance PrettyVal Import
instance PrettyVal ImportEntities
instance PrettyVal ExpMap
instance PrettyVal IdMap
instance PrettyVal SpanInfo
instance PrettyVal PackageId
instance PrettyVal ModuleId
instance PrettyVal SourceError
instance PrettyVal EitherSpan
instance PrettyVal SourceSpan
instance PrettyVal IdScope
instance PrettyVal IdProp
instance PrettyVal IdInfo
instance PrettyVal IdPropPtr
instance PrettyVal FilePathPtr
instance Binary BreakInfo
instance Binary RunResult
instance Binary SpanInfo
instance Binary ExplicitSharingCache
instance Binary Import
instance Binary ImportEntities
instance Binary IdProp
instance Binary PackageId
instance Binary ModuleId
instance Binary IdPropPtr
instance Binary IdScope
instance Binary IdInfo
instance Binary SourceError
instance Binary EitherSpan
instance Binary SourceSpan
instance Binary FilePathPtr


-- | Translation from the private to the public types
module IdeSession.Types.Translation

-- | The associated type with explicit sharing

-- | Many of the public data types that we export in <a>IdeSession</a> have
--   a corresponding private <tt>XShared</tt> version. For instance, we
--   have <tt>IdProp</tt> and <tt>XShared IdProp</tt>, <tt>SourceError</tt>
--   and <tt>XShared SourceError</tt>, etc. These <tt>XShared</tt> types
--   are abstract; what's important is only that they can be serialized
--   (support <tt>FromJSON</tt> and <tt>ToJSON</tt>). The main difference
--   between the public and the private data types is that the private data
--   types use explicit sharing. This is important for serialization,
--   because there is quite a bit of sharing in the type information that
--   we collect and losing this would be a significant performance hit.
--   (The other difference is that the private data types use specialized
--   types that guarantee strictness.)
--   
--   The <tt>MShared (XShared a) ~ a</tt> condition on the
--   <tt>ExplicitSharing</tt> type class is there for technical reasons
--   only (it convinces GHC that the <tt>XShared</tt> type family is a
--   bijection).
class (MShared (XShared a) ~ a, Binary (XShared a)) => ExplicitSharing a
removeExplicitSharing :: ExplicitSharing a => Proxy a -> ExplicitSharingCache -> XShared a -> a

-- | Introduce explicit sharing
--   
--   This provides the opposite translation to removeExplicitSharing. Note
--   however that this is a partial function -- we never extend the cache,
--   so if a required value is missing from the cache we return
--   <tt>Nothing</tt>.
class IntroduceSharing a
introduceExplicitSharing :: IntroduceSharing a => ExplicitSharingCache -> a -> Maybe (XShared a)
showNormalized :: (Show a, ExplicitSharing a, MShared (XShared a) ~ a) => Proxy a -> ExplicitSharingCache -> XShared a -> String
dereferenceFilePathPtr :: ExplicitSharingCache -> FilePathPtr -> FilePath
instance IntroduceSharing SourceSpan
instance ExplicitSharing BreakInfo
instance ExplicitSharing SpanInfo
instance ExplicitSharing Import
instance ExplicitSharing ImportEntities
instance ExplicitSharing SourceError
instance ExplicitSharing EitherSpan
instance ExplicitSharing SourceSpan
instance ExplicitSharing IdScope
instance ExplicitSharing PackageId
instance ExplicitSharing ModuleId
instance ExplicitSharing IdInfo
instance ExplicitSharing IdProp

module IdeSession.Types.Progress

-- | This type represents intermediate progress information during
--   compilation.
data Progress
Progress :: Int -> Int -> Maybe Text -> Maybe Text -> Progress

-- | The current step number
--   
--   When these Progress messages are generated from progress updates from
--   ghc, it is entirely possible that we might get step 4<i>26, 16</i>26,
--   3/26; the steps may not be continuous, might even be out of order, and
--   may not finish at X/X.
progressStep :: Progress -> Int

-- | The total number of steps
progressNumSteps :: Progress -> Int

-- | The parsed message. For instance, in the case of progress messages
--   during compilation, <a>progressOrigMsg</a> might be
--   
--   <pre>
--   [1 of 2] Compiling M (some/path/to/file.hs, some/other/path/to/file.o)
--   </pre>
--   
--   while <tt>progressMsg</tt> will just be 'Compiling M'
progressParsedMsg :: Progress -> Maybe Text

-- | The full original message (see <tt>progressMsg</tt>)
progressOrigMsg :: Progress -> Maybe Text
instance Eq Progress
instance Ord Progress
instance Generic Progress
instance Datatype D1Progress
instance Constructor C1_0Progress
instance Selector S1_0_0Progress
instance Selector S1_0_1Progress
instance Selector S1_0_2Progress
instance Selector S1_0_3Progress
instance Show Progress
instance Binary Progress
instance PrettyVal Progress


-- | Responses from the GHC server
--   
--   The server responds with <a>IdeSession.Types.Private</a> types
module IdeSession.GHC.Responses
data GhcInitResponse
GhcInitResponse :: GhcVersion -> GhcInitResponse
ghcInitVersion :: GhcInitResponse -> GhcVersion
data GhcCompileResponse
GhcCompileProgress :: Progress -> GhcCompileResponse
GhcCompileDone :: GhcCompileResult -> GhcCompileResponse
data GhcCompileResult
GhcCompileResult :: Strict [] SourceError -> Strict [] ModuleName -> ExplicitSharingCache -> Strict (Map FilePath) ModuleId -> Strict (Map ModuleName) (Diff (Strict [] Import)) -> Strict (Map ModuleName) (Diff (Strict [] IdInfo)) -> Strict (Map ModuleName) (Diff IdList) -> Strict (Map ModuleName) (Diff (Strict [] PackageId)) -> Strict (Map ModuleName) (Diff [(SourceSpan, Text)]) -> Strict (Map ModuleName) (Diff UseSites) -> GhcCompileResult
ghcCompileErrors :: GhcCompileResult -> Strict [] SourceError
ghcCompileLoaded :: GhcCompileResult -> Strict [] ModuleName
ghcCompileCache :: GhcCompileResult -> ExplicitSharingCache
ghcCompileFileMap :: GhcCompileResult -> Strict (Map FilePath) ModuleId
ghcCompileImports :: GhcCompileResult -> Strict (Map ModuleName) (Diff (Strict [] Import))
ghcCompileAuto :: GhcCompileResult -> Strict (Map ModuleName) (Diff (Strict [] IdInfo))
ghcCompileSpanInfo :: GhcCompileResult -> Strict (Map ModuleName) (Diff IdList)
ghcCompilePkgDeps :: GhcCompileResult -> Strict (Map ModuleName) (Diff (Strict [] PackageId))
ghcCompileExpTypes :: GhcCompileResult -> Strict (Map ModuleName) (Diff [(SourceSpan, Text)])
ghcCompileUseSites :: GhcCompileResult -> Strict (Map ModuleName) (Diff UseSites)
data GhcRunResponse
GhcRunOutp :: ByteString -> GhcRunResponse
GhcRunDone :: RunResult -> GhcRunResponse

-- | GHC version
--   
--   NOTE: Defined in such a way that the Ord instance makes sense.
data GhcVersion
GHC_7_4 :: GhcVersion
GHC_7_8 :: GhcVersion
GHC_7_10 :: GhcVersion
instance Typeable GhcCompileResult
instance Typeable GhcCompileResponse
instance Typeable GhcRunResponse
instance Typeable GhcVersion
instance Typeable GhcInitResponse
instance Generic GhcCompileResult
instance Generic GhcCompileResponse
instance Generic GhcRunResponse
instance Show GhcVersion
instance Eq GhcVersion
instance Ord GhcVersion
instance Generic GhcVersion
instance Generic GhcInitResponse
instance Datatype D1GhcCompileResult
instance Constructor C1_0GhcCompileResult
instance Selector S1_0_0GhcCompileResult
instance Selector S1_0_1GhcCompileResult
instance Selector S1_0_2GhcCompileResult
instance Selector S1_0_3GhcCompileResult
instance Selector S1_0_4GhcCompileResult
instance Selector S1_0_5GhcCompileResult
instance Selector S1_0_6GhcCompileResult
instance Selector S1_0_7GhcCompileResult
instance Selector S1_0_8GhcCompileResult
instance Selector S1_0_9GhcCompileResult
instance Datatype D1GhcCompileResponse
instance Constructor C1_0GhcCompileResponse
instance Constructor C1_1GhcCompileResponse
instance Datatype D1GhcRunResponse
instance Constructor C1_0GhcRunResponse
instance Constructor C1_1GhcRunResponse
instance Datatype D1GhcVersion
instance Constructor C1_0GhcVersion
instance Constructor C1_1GhcVersion
instance Constructor C1_2GhcVersion
instance Datatype D1GhcInitResponse
instance Constructor C1_0GhcInitResponse
instance Selector S1_0_0GhcInitResponse
instance Binary GhcVersion
instance Binary GhcRunResponse
instance Binary GhcCompileResult
instance Binary GhcCompileResponse
instance Binary GhcInitResponse
instance PrettyVal GhcVersion
instance PrettyVal GhcRunResponse
instance PrettyVal GhcCompileResult
instance PrettyVal GhcCompileResponse
instance PrettyVal GhcInitResponse


-- | Types for the messages to and fro the GHC server
--   
--   It is important that none of the types here rely on the GHC library.
module IdeSession.GHC.API

-- | For detecting runtime version mismatch between the server and the
--   library
--   
--   We use a Unix timestamp for this so that these API versions have some
--   semantics (http:/<i>www.epochconverter.com</i>, GMT).
ideBackendApiVersion :: Int

-- | Haskell source files
hsExtensions :: [FilePath]

-- | Haskell <tt>.boot</tt> files
hsBootExtensions :: [FilePath]

-- | C source files
cExtensions :: [FilePath]

-- | C header files
cHeaderExtensions :: [FilePath]

-- | Extensions of all source files we keep in our source directory.
sourceExtensions :: [FilePath]
cabalMacrosLocation :: FilePath -> FilePath

-- | The directory to use for managing source files.
ideSessionSourceDir :: FilePath -> FilePath

-- | The directory to use for data files that may be accessed by the
--   running program. The running program will have this as its CWD.
ideSessionDataDir :: FilePath -> FilePath

-- | Cabal "dist" prefix.
ideSessionDistDir :: FilePath -> FilePath

-- | Directory where we store compiled C files (objects)
ideSessionObjDir :: FilePath -> FilePath
