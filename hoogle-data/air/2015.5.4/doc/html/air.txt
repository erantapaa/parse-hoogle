-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | air
--   
@package air
@version 2015.5.4

module Air.Data.Record.SimpleLabel
type Getter s x = s -> x
type Setter s x = x -> s -> s
type Modifier s x = (x -> x) -> s -> s
data Point s x
newtype (:->) s x
Label :: Point s x -> (:->) s x
label :: Getter s x -> Setter s x -> s :-> x

-- | Get the getter function from a label.
get :: (s :-> x) -> s -> x

-- | Get the setter function from a label.
set :: (s :-> x) -> x -> s -> s

-- | Get the modifier function from a label.
mod :: (s :-> x) -> (x -> x) -> s -> s

-- | Get a value out of state pointed to by the specified label.
getM :: MonadState s m => s :-> b -> m b

-- | Set a value somewhere in state pointed to by the specified label.
setM :: MonadState s m => s :-> b -> b -> m ()

-- | Modify a value with a function somewhere in state pointed to by the
--   specified label.
modM :: MonadState s m => s :-> b -> (b -> b) -> m ()

-- | Alias for <a>setM</a> that reads like an assignment.
(=:) :: MonadState s m => s :-> b -> b -> m ()
instance Category (:->)

module Air.Data.Monoid
class Monoid a where mconcat = foldr mappend mempty
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a
(+) :: Monoid a => a -> a -> a
instance Monoid (Seq a)
instance Ord a => Monoid (Set a)
instance Ord a => Monoid (Map a b)
instance Monoid Text
instance Monoid Text
instance Monoid ByteString
instance Monoid ByteString
instance Monoid (Maybe a)
instance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) => Monoid (a, b, c, d, e)
instance (Monoid a, Monoid b, Monoid c, Monoid d) => Monoid (a, b, c, d)
instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)
instance (Monoid a, Monoid b) => Monoid (a, b)
instance Monoid ()
instance Monoid b => Monoid (a -> b)
instance Monoid [a]
instance Monoid Word64
instance Monoid Word32
instance Monoid Word16
instance Monoid Word8
instance Monoid Int64
instance Monoid Int32
instance Monoid Int16
instance Monoid Int8
instance Monoid Float
instance Monoid Double
instance Monoid Integer
instance Monoid Int

module Air.Data.Default

-- | A class for types with a default value.
class Default a
def :: Default a => a
instance Default TimeOfDay
instance Default UTCTime
instance Default DiffTime
instance Default Day
instance (Default a, Default b, Default c, Default d, Default e) => Default (a, b, c, d, e)
instance (Default a, Default b, Default c, Default d) => Default (a, b, c, d)
instance (Default a, Default b, Default c) => Default (a, b, c)
instance Default Bool
instance Default Word64
instance Default Word32
instance Default Word16
instance Default Word8
instance Default Int64
instance Default Int32
instance Default Int16
instance Default Int8
instance Default Text
instance Default Text
instance Default ByteString
instance Default ByteString
instance (Default a, Default b) => Default (a, b)
instance Default a => Default (IO a)
instance Default r => Default (e -> r)
instance Default [a]
instance Default (Maybe a)
instance Integral a => Default (Ratio a)
instance Default Double
instance Default Float
instance Default Integer
instance Default Int
instance Default (Map k v)
instance Default (Set v)
instance Default ()

module Air.Light
(.) :: a -> (a -> b) -> b
(>) :: Category cat => cat a b -> cat b c -> cat a c
(<) :: Category cat => cat b c -> cat a b -> cat a c
(^) :: Functor f => f a -> (a -> b) -> f b
(/) :: FilePath -> FilePath -> FilePath
(-) :: (a -> b) -> a -> b
(<->) :: Num a => a -> a -> a
join :: [a] -> [[a]] -> [a]
at :: Integral i => i -> [a] -> Maybe a
first :: [a] -> Maybe a
fifth :: [a] -> Maybe a
forth :: [a] -> Maybe a
third :: [a] -> Maybe a
second :: [a] -> Maybe a
sixth :: [a] -> Maybe a
tenth :: [a] -> Maybe a
ninth :: [a] -> Maybe a
eighth :: [a] -> Maybe a
seventh :: [a] -> Maybe a
unique :: Ord a => [a] -> [a]
is_unique :: Ord a => [a] -> Bool
same :: Ord a => [a] -> Bool
times :: Integral i => b -> i -> [b]
upto :: Enum a => a -> a -> [a]
downto :: (Num t, Enum t) => t -> t -> [t]
remove_at :: Integral i => i -> [a] -> [a]
insert_at :: Integral i => i -> a -> [a] -> [a]
replace_at :: Integral i => i -> a -> [a] -> [a]
slice :: Integral i => i -> i -> [a] -> [a]
cherry_pick :: Integral i => [i] -> [a] -> [Maybe a]
inject :: Foldable t => a -> (a -> b -> a) -> t b -> a
inject' :: Foldable t => a -> (a -> b -> a) -> t b -> a
reduce :: (Default a, Foldable t) => (a -> a -> a) -> t a -> a
reduce' :: (Default a, Foldable t) => (a -> a -> a) -> t a -> a
select :: (a -> Bool) -> [a] -> [a]
reject :: (a -> Bool) -> [a] -> [a]
label_by :: (a -> c) -> [a] -> [(c, a)]
labeling :: (a -> c') -> [a] -> [(a, c')]
in_group_of :: Integral i => i -> [t] -> [[t]]
split_to :: Integral i => i -> [a] -> [[a]]
belongs_to :: (Foldable t, Eq a) => t a -> a -> Bool
has :: (Foldable t, Eq b) => b -> t b -> Bool
indexed :: (Num t, Enum t) => [b] -> [(t, b)]
ljust :: Integral i => i -> a -> [a] -> [a]
rjust :: Integral i => i -> a -> [a] -> [a]
rsort :: Ord a => [a] -> [a]
concat_map :: (a -> [b]) -> [a] -> [b]
to_list :: Foldable t => t a -> [a]
to_set :: Ord a => [a] -> Set a
to_h :: Ord k => [(k, a)] -> Map k a
to_a :: [a] -> Array Int a
to_a' :: Ix i => (i, i) -> [e] -> Array i e
compare_by :: Ord b => (a -> b) -> a -> a -> Ordering
eq :: Eq a => a -> a -> Bool
aren't :: Eq a => a -> a -> Bool
isn't :: Eq a => a -> a -> Bool
is_not :: Eq a => a -> a -> Bool
is :: Eq a => a -> a -> Bool
swap :: (a, b) -> (b, a)
tuple2 :: [a] -> Maybe (a, a)
tuple3 :: Show a => [a] -> Maybe (a, a, a)
list2 :: (a, a) -> [a]
list3 :: (a, a, a) -> [a]
filter_fst :: (a -> Bool) -> [(a, b)] -> [(a, b)]
filter_snd :: (b -> Bool) -> [(a, b)] -> [(a, b)]
map_fst :: (a -> b) -> [(a, c)] -> [(b, c)]
map_snd :: (a -> b) -> [(c, a)] -> [(c, b)]
splat :: (a -> b -> c) -> (a, b) -> c
splat3 :: (a -> b -> c -> d) -> (a, b, c) -> d
clone :: a -> (a, a)
from_i :: (Integral a, Num b) => a -> b
lower :: String -> String
upper :: String -> String
starts_with :: String -> String -> Bool
ends_with :: String -> String -> Bool
capitalize :: String -> String
to_s :: Show a => a -> String
trace' :: Show a => a -> a
void :: Monad m => m a -> m ()
don't :: Monad m => m a -> m ()
length :: Num i => [a] -> i
drop :: Integral i => i -> [a] -> [a]
take :: Integral i => i -> [a] -> [a]
splitAt :: Integral i => i -> [b] -> ([b], [b])
index :: Integral a => [b] -> a -> b
replicate :: Integral i => i -> a -> [a]
(!!) :: Integral a => [b] -> a -> Maybe b
to_f :: (Real a, Fractional b) => a -> b
sleep :: RealFrac a => a -> IO ()
puts :: String -> IO ()
exit_success :: IO ()
fork :: IO a -> IO ()
insert_unique :: Eq a => a -> [a] -> [a]
end :: Monad m => m ()
io :: MonadIO m => IO a -> m a
l2s :: ByteString -> ByteString
s2l :: ByteString -> ByteString
ap2 :: Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
ap3 :: Applicative f => (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> f b
ap4 :: Applicative f => (a3 -> a2 -> a1 -> a -> b) -> f a3 -> f a2 -> f a1 -> f a -> f b
ap5 :: Applicative f => (a4 -> a3 -> a2 -> a1 -> a -> b) -> f a4 -> f a3 -> f a2 -> f a1 -> f a -> f b
ap6 :: Applicative f => (a5 -> a4 -> a3 -> a2 -> a1 -> a -> b) -> f a5 -> f a4 -> f a3 -> f a2 -> f a1 -> f a -> f b
ap7 :: Applicative f => (a6 -> a5 -> a4 -> a3 -> a2 -> a1 -> a -> b) -> f a6 -> f a5 -> f a4 -> f a3 -> f a2 -> f a1 -> f a -> f b
ap8 :: Applicative f => (a7 -> a6 -> a5 -> a4 -> a3 -> a2 -> a1 -> a -> b) -> f a7 -> f a6 -> f a5 -> f a4 -> f a3 -> f a2 -> f a1 -> f a -> f b
ap9 :: Applicative f => (a8 -> a7 -> a6 -> a5 -> a4 -> a3 -> a2 -> a1 -> a -> b) -> f a8 -> f a7 -> f a6 -> f a5 -> f a4 -> f a3 -> f a2 -> f a1 -> f a -> f b

module Air.Env

module Air.SimpleMath
powerslice :: [a] -> [[a]]
hist :: (Num e, Ix i) => (i, i) -> [i] -> Array i e
explode :: Show a => a -> [Int]

module Air
