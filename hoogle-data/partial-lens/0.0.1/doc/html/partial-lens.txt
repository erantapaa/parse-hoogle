-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell 98 Partial Lenses
--   
--   Haskell 98 Partial Lenses
@package partial-lens
@version 0.0.1

module Data.Lens.Partial.Common
newtype PartialLens a b
PLens :: (a -> Maybe (Store b a)) -> PartialLens a b
runPLens :: PartialLens a b -> a -> (Coproduct Identity (Store b)) a
null :: PartialLens a b
totalLens :: Lens a b -> PartialLens a b
getPL :: PartialLens a b -> a -> Maybe b
trySetPL :: PartialLens a b -> a -> Maybe (b -> a)
setPL :: PartialLens a b -> b -> a -> a
modPL :: PartialLens a b -> (b -> b) -> a -> a
(^=) :: PartialLens a b -> b -> a -> a
(^%=) :: PartialLens a b -> (b -> b) -> a -> a
(^+=, ^*=, ^-=) :: Num b => PartialLens a b -> b -> a -> a
(^/=) :: Fractional b => PartialLens a b -> b -> a -> a
maybeLens :: PartialLens (Maybe a) a
leftLens :: PartialLens (Either a b) a
rightLens :: PartialLens (Either a b) b
headLens :: PartialLens [a] a
tailLens :: PartialLens [a] [a]
instance Category PartialLens

module Data.Lens.Partial.Lazy
maybeZero :: MonadPlus m => Maybe a -> m a
joinMaybe :: MonadPlus m => m (Maybe a) -> m a

-- | get the value of a partial lens into state
access :: Monad m => PartialLens a b -> StateT a m (Maybe b)

-- | returns mzero in case of a null reference
accessPlus :: MonadPlus m => PartialLens a b -> StateT a m b

-- | set a value using a partial lens into state returns <a>Nothing</a> in
--   case of a null reference
(~=) :: Monad m => PartialLens a b -> b -> StateT a m (Maybe b)

-- | infix modification a value through a partial lens into state returns
--   <a>Nothing</a> in case of a null reference
(%=) :: Monad m => PartialLens a b -> (b -> b) -> StateT a m (Maybe b)

-- | infix modification of a value through a partial lens into state with a
--   supplemental response. returns <a>Nothing</a> in case of a null
--   reference
(%%=) :: Monad m => PartialLens a b -> (b -> (c, b)) -> StateT a m (Maybe c)
(+=, *=, -=) :: (Monad m, Num b) => PartialLens a b -> b -> StateT a m (Maybe b)
(//=) :: (Monad m, Fractional b) => PartialLens a b -> b -> StateT a m (Maybe b)
(&&=, ||=) :: Monad m => PartialLens a Bool -> Bool -> StateT a m (Maybe Bool)
