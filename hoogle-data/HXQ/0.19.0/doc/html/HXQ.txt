-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Compiler from XQuery to Haskell
--   
--   HXQ is a fast and space-efficient compiler from XQuery (the standard
--   query language for XML) to embedded Haskell code. The translation is
--   based on Haskell templates. It also provides an interpreter for
--   evaluating XQueries from input and an optional database connectivity
--   using HDBC with MySQL/ODBC or sqlite3.
@package HXQ
@version 0.19.0


-- | HXQ is a fast and space-efficient compiler from XQuery (the standard
--   query language for XML) to embedded Haskell code. The translation is
--   based on Haskell templates. It also provides an interpreter for
--   evaluating ad-hoc XQueries read from input or from files and optional
--   database connectivity using HDBC. For more information, look at
--   <a>http://lambda.uta.edu/HXQ/</a>.
module Text.XML.HXQ.XQuery

-- | Namespace prefix
type Prefix = String

-- | Namespace URI
type URI = String

-- | Local name
type LocalName = String

-- | A qualified name has a namespace prefix, a URI, and a local name
data QName
QName :: !Prefix -> !URI -> !LocalName -> QName
prefix :: QName -> !Prefix
uri :: QName -> !URI
localName :: QName -> !LocalName

-- | XML attributes are bindings from qualified names to values
type Attributes = [(QName, String)]

-- | A rose tree representation of XML data. An XML element is: <tt>XElem
--   tagname atributes preorder parent children</tt>. The preorder
--   numbering is the document order of elements. The parent is a cyclic
--   reference to the parent element.
data XTree

-- | an XML tree node (element)
XElem :: !QName -> !Attributes -> !Int -> XTree -> [XTree] -> XTree

-- | attribute construction
XAttr :: !QName -> !String -> XTree

-- | an XML tree leaf (PCDATA)
XText :: !String -> XTree

-- | an XML tree leaf (int)
XInt :: !Int -> XTree

-- | an XML tree leaf (double)
XFloat :: !Double -> XTree

-- | an XML tree leaf (boolean)
XBool :: !Bool -> XTree

-- | processing instruction
XPI :: String -> String -> XTree

-- | general entity reference
XGERef :: String -> XTree

-- | comment
XComment :: String -> XTree

-- | error message
XError :: String -> XTree

-- | null value
XNull :: XTree

-- | type information
XType :: Type -> XTree

-- | marker for no padding in XSeq
XNoPad :: XTree

-- | A sequence of XML fragments
type XSeq = [XTree]

-- | A type variable
type TVar = Int

-- | Type qualifier: *, +, or ?
type TQualifier = Char

-- | An XQuery type
data Type

-- | type variable (needed for polymorphic type inference)
TVariable :: !TVar -> Type

-- | xs:integer, xs:string, ...
TBase :: !QName -> Type

-- | item(), node(), ...
TItem :: !String -> Type

-- | reference to a user-defined type
TNamed :: !QName -> Type

-- | element tag { t }
TElement :: !String -> !Type -> Type

-- | attribute name { t }
TAttribute :: !String -> !Type -> Type

-- | any element or attribute content
TAny :: Type

-- | ()
TEmpty :: Type

-- | t1, t2
TSequence :: !Type -> !Type -> Type

-- | t1 &amp; t2
TInterleaving :: !Type -> !Type -> Type

-- | t1 | t2
TChoice :: !Type -> !Type -> Type

-- | t*, t+, or t?
TQualified :: !Type -> !TQualifier -> Type

-- | Print the XQuery result (which is a sequence of XML fragments) without
--   buffering.
putXSeq :: XSeq -> IO ()

-- | Compile an XQuery that may perform IO (such as reading an XML document
--   or calling a user function). When the compiled code is evaluated, it
--   returns a value of type <tt>IO XSeq</tt>.
xq :: String -> Q Exp

-- | Compile an XQuery expression that does not perform IO. When the
--   compiled code is evaluated, it returns a value of type <tt>XSeq</tt>.
xe :: String -> Q Exp

-- | Quasi-quotation for HXQ (for ghc 6.09 or later). For example, <tt>[qx|
--   doc("data/cs.xml")//gpa |]</tt> is equivalent to <tt>xq
--   "doc(\"data/cs.xml\")//gpa"</tt>.
qx :: QuasiQuoter

-- | Evaluate the XQuery using the interpreter.
xquery :: String -> IO XSeq

-- | The XQuery interpreter as an XQuery function.
eval :: XSeq -> IO XSeq

-- | The XQuery command line interpreter used by the main program
--   (<tt>xquery</tt>). The program arguments may contain the following
--   command line options:
--   
--   <ul>
--   <li><i><tt>xquery-file</tt></i> Evaluate the XQuery code in
--   <tt>xquery-file</tt> using the interpreter</li>
--   <li><i><tt>-db database-name</tt></i> Use the relational schema
--   <tt>database-name</tt> during querying</li>
--   <li><i><tt>-c xquery-file</tt></i> Compile the XQuery code in
--   <tt>xquery-file</tt> into Haskell code</li>
--   <li><i><tt>-o haskell-file</tt></i> Set the Haskell file for
--   <tt>-c</tt> (default is <tt>Temp.hs</tt>)</li>
--   <li><i><tt>-p XPath-query xml-file</tt></i> Interpret the XPath query
--   against the <tt>xml-file</tt></li>
--   <li><i><tt>-v</tt></i> Print verbose information (the AST and the
--   optimized plan)</li>
--   <li><i><tt>-t</tt></i> Print timing information</li>
--   <li><i><tt>-tp</tt></i> Print typing information (experimental)</li>
--   </ul>
--   
--   Without an <tt>xquery-file</tt>, it reads and evaluates the input
--   using the HXQ interpreter. The input may be a single XQuery or a
--   <tt>declare variable</tt> or a <tt>declare function</tt> expression.
--   To write an XQuery in multiple lines, wrap it in <tt>{ }</tt>.
commandLineInterpreter :: [String] -> IO ()

-- | Validate the XML document against the XML Schema. Also done using the
--   validate XQuery form.
validateFile :: FilePath -> FilePath -> IO Bool

-- | Compile an XQuery that may perform IO and/or queries a database. When
--   the compiled code is evaluated, it returns <tt>Connection -&gt; IO
--   XSeq</tt>.
xqdb :: String -> Q Exp

-- | Evaluate the XQuery with database connectivity using the interpreter.
xqueryDB :: String -> Connection -> IO XSeq

-- | XPath to reach a table/column
type Path = [String]

-- | A relational schema representation
data Table

-- | table-name relative-path mixed-content? components
Table :: String -> Path -> Bool -> [Table] -> Table

-- | column-name relative-path max-byte-size
Column :: String -> Path -> Int -> Table

-- | Create a schema for an XML document into the database under the given
--   name. The excluded tags are HTML tags to be ignored
genSchema :: Connection -> FilePath -> String -> [String] -> IO Table

-- | Store an XML document into the database under the given name.
shred :: Connection -> FilePath -> String -> IO ()

-- | Store an XML document into the database under the given name.
--   Generates Haskell code. It's 3 times faster than shred.
shredC :: String -> FilePath -> String -> Q Exp

-- | True if there is a relational schema stored in the database under the
--   given name
isSchema :: Connection -> String -> IO Bool

-- | Print the relational schema stored in the database under the given
--   name
printSchema :: Connection -> String -> IO ()

-- | Create a secondary index on tagname for the shredded document under
--   the given name..
createIndex :: Connection -> String -> String -> IO ()

-- | Connect to a relational database
connect :: String -> IO Connection

-- | Disconnect from the relational database
disconnect :: Connection -> IO ()

-- | commit the updates to the database
commit :: Connection -> IO ()

-- | rollback the updates from the database
rollback :: Connection -> IO ()
