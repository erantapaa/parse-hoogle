-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Linear Algebra
--   
--   Types and combinators for linear algebra on free vector spaces
@package linear
@version 1.19.1.3


-- | Orphans
module Linear.Instances
instance (Hashable k, Eq k) => Apply (HashMap k)
instance (Hashable k, Eq k) => Bind (HashMap k)
instance Functor Complex
instance Apply Complex
instance Applicative Complex
instance Bind Complex
instance Monad Complex
instance MonadZip Complex
instance MonadFix Complex
instance Foldable Complex
instance Traversable Complex
instance Foldable1 Complex
instance Traversable1 Complex


-- | Operations on free vector spaces.
module Linear.Vector

-- | A vector is an additive group with additional structure.
class Functor f => Additive f where zero = to1 gzero (^+^) = liftU2 (+) x ^-^ y = x ^+^ negated y lerp alpha u v = alpha *^ u ^+^ (1 - alpha) *^ v liftU2 = liftA2 liftI2 = liftA2
zero :: (Additive f, Num a) => f a
(^+^) :: (Additive f, Num a) => f a -> f a -> f a
(^-^) :: (Additive f, Num a) => f a -> f a -> f a
lerp :: (Additive f, Num a) => a -> f a -> f a -> f a
liftU2 :: Additive f => (a -> a -> a) -> f a -> f a -> f a
liftI2 :: Additive f => (a -> b -> c) -> f a -> f b -> f c

-- | Basis element
newtype E t
[E] :: (forall x. Lens' (t x) x) -> E t
[el] :: E t -> forall x. Lens' (t x) x

-- | Compute the negation of a vector
--   
--   <pre>
--   &gt;&gt;&gt; negated (V2 2 4)
--   V2 (-2) (-4)
--   </pre>
negated :: (Functor f, Num a) => f a -> f a

-- | Compute the right scalar product
--   
--   <pre>
--   &gt;&gt;&gt; V2 3 4 ^* 2
--   V2 6 8
--   </pre>
(^*) :: (Functor f, Num a) => f a -> a -> f a

-- | Compute the left scalar product
--   
--   <pre>
--   &gt;&gt;&gt; 2 *^ V2 3 4
--   V2 6 8
--   </pre>
(*^) :: (Functor f, Num a) => a -> f a -> f a

-- | Compute division by a scalar on the right.
(^/) :: (Functor f, Fractional a) => f a -> a -> f a

-- | Sum over multiple vectors
--   
--   <pre>
--   &gt;&gt;&gt; sumV [V2 1 1, V2 3 4]
--   V2 4 5
--   </pre>
sumV :: (Foldable f, Additive v, Num a) => f (v a) -> v a

-- | Produce a default basis for a vector space. If the dimensionality of
--   the vector space is not statically known, see <a>basisFor</a>.
basis :: (Additive t, Traversable t, Num a) => [t a]

-- | Produce a default basis for a vector space from which the argument is
--   drawn.
basisFor :: (Traversable t, Num a) => t b -> [t a]

-- | Produce a diagonal (scale) matrix from a vector.
--   
--   <pre>
--   &gt;&gt;&gt; scaled (V2 2 3)
--   V2 (V2 2 0) (V2 0 3)
--   </pre>
scaled :: (Traversable t, Num a) => t a -> t (t a)

-- | Outer (tensor) product of two vectors
outer :: (Functor f, Functor g, Num a) => f a -> g a -> f (g a)

-- | Create a unit vector.
--   
--   <pre>
--   &gt;&gt;&gt; unit _x :: V2 Int
--   V2 1 0
--   </pre>
unit :: (Additive t, Num a) => ASetter' (t a) a -> t a
instance GAdditive U1
instance (GAdditive f, GAdditive g) => GAdditive (f :*: g)
instance Additive f => GAdditive (Rec1 f)
instance GAdditive f => GAdditive (M1 i c f)
instance GAdditive Par1
instance Additive ZipList
instance Additive Vector
instance Additive Maybe
instance Additive []
instance Additive IntMap
instance Ord k => Additive (Map k)
instance (Eq k, Hashable k) => Additive (HashMap k)
instance Additive ((->) b)
instance Additive Complex
instance Additive Identity


-- | Testing for values "near" zero
module Linear.Epsilon

-- | Provides a fairly subjective test to see if a quantity is near zero.
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-11 :: Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-17 :: Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-5 :: Float)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-7 :: Float)
--   True
--   </pre>
class Num a => Epsilon a
nearZero :: Epsilon a => a -> Bool
instance Epsilon Float
instance Epsilon Double
instance Epsilon CFloat
instance Epsilon CDouble


-- | Free metric spaces
module Linear.Metric

-- | Free and sparse inner product/metric spaces.
class Additive f => Metric f where dot x y = sum $ liftI2 (*) x y quadrance v = dot v v qd f g = quadrance (f ^-^ g) distance f g = norm (f ^-^ g) norm v = sqrt (quadrance v) signorm v = fmap (/ m) v where m = norm v
dot :: (Metric f, Num a) => f a -> f a -> a
quadrance :: (Metric f, Num a) => f a -> a
qd :: (Metric f, Num a) => f a -> f a -> a
distance :: (Metric f, Floating a) => f a -> f a -> a
norm :: (Metric f, Floating a) => f a -> a
signorm :: (Metric f, Floating a) => f a -> f a

-- | Normalize a <a>Metric</a> functor to have unit <a>norm</a>. This
--   function does not change the functor if its <a>norm</a> is 0 or 1.
normalize :: (Floating a, Metric f, Epsilon a) => f a -> f a

-- | <tt>project u v</tt> computes the projection of <tt>v</tt> onto
--   <tt>u</tt>.
project :: (Metric v, Fractional a) => v a -> v a -> v a
instance Metric Identity
instance Metric []
instance Metric Maybe
instance Metric ZipList
instance Metric IntMap
instance Ord k => Metric (Map k)
instance (Hashable k, Eq k) => Metric (HashMap k)
instance Metric Vector


-- | 0-D Vectors
module Linear.V0

-- | A 0-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V0 Int
--   V0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V0 + V0
--   V0
--   </pre>
data V0 a
[V0] :: V0 a
instance Constructor C1_0V0
instance Datatype D1V0
instance Generic1 V0
instance Generic (V0 a)
instance Data a => Data (V0 a)
instance Enum (V0 a)
instance Ix (V0 a)
instance Read (V0 a)
instance Show (V0 a)
instance Ord (V0 a)
instance Eq (V0 a)
instance Serial1 V0
instance Serial (V0 a)
instance Binary (V0 a)
instance Serialize (V0 a)
instance Functor V0
instance Foldable V0
instance Traversable V0
instance Apply V0
instance Applicative V0
instance Additive V0
instance Bind V0
instance Monad V0
instance Num (V0 a)
instance Fractional (V0 a)
instance Floating (V0 a)
instance Metric V0
instance Distributive V0
instance Hashable (V0 a)
instance Epsilon a => Epsilon (V0 a)
instance Storable a => Storable (V0 a)
instance FunctorWithIndex (E V0) V0
instance FoldableWithIndex (E V0) V0
instance TraversableWithIndex (E V0) V0
instance Representable V0
instance Ixed (V0 a)
instance Each (V0 a) (V0 b) a b
instance Unbox (V0 a)
instance MVector MVector (V0 a)
instance Vector Vector (V0 a)
instance MonadZip V0
instance MonadFix V0
instance Bounded (V0 a)
instance NFData (V0 a)
instance Eq1 V0
instance Ord1 V0
instance Show1 V0
instance Read1 V0


-- | 1-D Vectors
module Linear.V1

-- | A 1-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V1 Int
--   V1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 + V1 3
--   V1 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 * V1 3
--   V1 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V1 2)
--   2
--   </pre>
newtype V1 a
[V1] :: a -> V1 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t
_x :: R1 t => Lens' (t a) a
ex :: R1 t => E t
instance Constructor C1_0V1
instance Datatype D1V1
instance Generic1 V1
instance Generic (V1 a)
instance NFData a => NFData (V1 a)
instance Storable a => Storable (V1 a)
instance Epsilon a => Epsilon (V1 a)
instance Traversable V1
instance Foldable V1
instance Functor V1
instance Data a => Data (V1 a)
instance Read a => Read (V1 a)
instance Show a => Show (V1 a)
instance Ord a => Ord (V1 a)
instance Eq a => Eq (V1 a)
instance Foldable1 V1
instance Traversable1 V1
instance Apply V1
instance Applicative V1
instance Additive V1
instance Bind V1
instance Monad V1
instance Num a => Num (V1 a)
instance Fractional a => Fractional (V1 a)
instance Floating a => Floating (V1 a)
instance Hashable a => Hashable (V1 a)
instance Metric V1
instance R1 V1
instance R1 Identity
instance Distributive V1
instance Ix a => Ix (V1 a)
instance Representable V1
instance FunctorWithIndex (E V1) V1
instance FoldableWithIndex (E V1) V1
instance TraversableWithIndex (E V1) V1
instance Ixed (V1 a)
instance Each (V1 a) (V1 b) a b
instance Unbox a => Unbox (V1 a)
instance Unbox a => MVector MVector (V1 a)
instance Unbox a => Vector Vector (V1 a)
instance MonadZip V1
instance MonadFix V1
instance Bounded a => Bounded (V1 a)
instance Serial1 V1
instance Serial a => Serial (V1 a)
instance Binary a => Binary (V1 a)
instance Serialize a => Serialize (V1 a)
instance Eq1 V1
instance Ord1 V1
instance Show1 V1
instance Read1 V1


-- | 2-D Vectors
module Linear.V2

-- | A 2-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V2 Int
--   V2 1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 + V2 3 4
--   V2 4 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 * V2 3 4
--   V2 3 8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V2 1 2)
--   3
--   </pre>
data V2 a
[V2] :: !a -> !a -> V2 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t
_x :: R1 t => Lens' (t a) a

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class R1 t => R2 t where _y = _xy . _y
_y :: R2 t => Lens' (t a) a
_xy :: R2 t => Lens' (t a) (V2 a)

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^. _yx
--   V2 2 1
--   </pre>
_yx :: R2 t => Lens' (t a) (V2 a)
ex :: R1 t => E t
ey :: R2 t => E t

-- | the counter-clockwise perpendicular vector
--   
--   <pre>
--   &gt;&gt;&gt; perp $ V2 10 20
--   V2 (-20) 10
--   </pre>
perp :: Num a => V2 a -> V2 a
angle :: Floating a => a -> V2 a
instance Constructor C1_0V2
instance Datatype D1V2
instance Generic1 V2
instance Generic (V2 a)
instance Data a => Data (V2 a)
instance Read a => Read (V2 a)
instance Show a => Show (V2 a)
instance Ord a => Ord (V2 a)
instance Eq a => Eq (V2 a)
instance Functor V2
instance Foldable V2
instance Traversable V2
instance Foldable1 V2
instance Traversable1 V2
instance Apply V2
instance Applicative V2
instance Hashable a => Hashable (V2 a)
instance Additive V2
instance Bind V2
instance Monad V2
instance Num a => Num (V2 a)
instance Fractional a => Fractional (V2 a)
instance Floating a => Floating (V2 a)
instance Metric V2
instance R1 V2
instance R2 V2
instance Distributive V2
instance Epsilon a => Epsilon (V2 a)
instance Storable a => Storable (V2 a)
instance Ix a => Ix (V2 a)
instance Representable V2
instance FunctorWithIndex (E V2) V2
instance FoldableWithIndex (E V2) V2
instance TraversableWithIndex (E V2) V2
instance Ixed (V2 a)
instance Each (V2 a) (V2 b) a b
instance Unbox a => Unbox (V2 a)
instance Unbox a => MVector MVector (V2 a)
instance Unbox a => Vector Vector (V2 a)
instance MonadZip V2
instance MonadFix V2
instance Bounded a => Bounded (V2 a)
instance NFData a => NFData (V2 a)
instance Serial1 V2
instance Serial a => Serial (V2 a)
instance Binary a => Binary (V2 a)
instance Serialize a => Serialize (V2 a)
instance Eq1 V2
instance Ord1 V2
instance Show1 V2
instance Read1 V2


-- | 3-D Vectors
module Linear.V3

-- | A 3-dimensional vector
data V3 a
[V3] :: !a -> !a -> !a -> V3 a

-- | cross product
cross :: Num a => V3 a -> V3 a -> V3 a

-- | scalar triple product
triple :: Num a => V3 a -> V3 a -> V3 a -> a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t
_x :: R1 t => Lens' (t a) a

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class R1 t => R2 t where _y = _xy . _y
_y :: R2 t => Lens' (t a) a
_xy :: R2 t => Lens' (t a) (V2 a)

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^. _yx
--   V2 2 1
--   </pre>
_yx :: R2 t => Lens' (t a) (V2 a)

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (It may have more)
class R2 t => R3 t
_z :: R3 t => Lens' (t a) a
_xyz :: R3 t => Lens' (t a) (V3 a)
_xz :: R3 t => Lens' (t a) (V2 a)
_yz :: R3 t => Lens' (t a) (V2 a)
_zx :: R3 t => Lens' (t a) (V2 a)
_zy :: R3 t => Lens' (t a) (V2 a)
_xzy :: R3 t => Lens' (t a) (V3 a)
_yxz :: R3 t => Lens' (t a) (V3 a)
_yzx :: R3 t => Lens' (t a) (V3 a)
_zxy :: R3 t => Lens' (t a) (V3 a)
_zyx :: R3 t => Lens' (t a) (V3 a)
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
instance Constructor C1_0V3
instance Datatype D1V3
instance Generic1 V3
instance Generic (V3 a)
instance Data a => Data (V3 a)
instance Read a => Read (V3 a)
instance Show a => Show (V3 a)
instance Ord a => Ord (V3 a)
instance Eq a => Eq (V3 a)
instance Functor V3
instance Foldable V3
instance Traversable V3
instance Foldable1 V3
instance Traversable1 V3
instance Apply V3
instance Applicative V3
instance Additive V3
instance Bind V3
instance Monad V3
instance Num a => Num (V3 a)
instance Fractional a => Fractional (V3 a)
instance Floating a => Floating (V3 a)
instance Hashable a => Hashable (V3 a)
instance Metric V3
instance Distributive V3
instance R1 V3
instance R2 V3
instance R3 V3
instance Storable a => Storable (V3 a)
instance Epsilon a => Epsilon (V3 a)
instance Ix a => Ix (V3 a)
instance Representable V3
instance FunctorWithIndex (E V3) V3
instance FoldableWithIndex (E V3) V3
instance TraversableWithIndex (E V3) V3
instance Ixed (V3 a)
instance Each (V3 a) (V3 b) a b
instance Unbox a => Unbox (V3 a)
instance Unbox a => MVector MVector (V3 a)
instance Unbox a => Vector Vector (V3 a)
instance MonadZip V3
instance MonadFix V3
instance Bounded a => Bounded (V3 a)
instance NFData a => NFData (V3 a)
instance Serial1 V3
instance Serial a => Serial (V3 a)
instance Binary a => Binary (V3 a)
instance Serialize a => Serialize (V3 a)
instance Eq1 V3
instance Ord1 V3
instance Show1 V3
instance Read1 V3


-- | 4-D Vectors
module Linear.V4

-- | A 4-dimensional vector.
data V4 a
[V4] :: !a -> !a -> !a -> !a -> V4 a

-- | Convert a 3-dimensional affine vector into a 4-dimensional homogeneous
--   vector.
vector :: Num a => V3 a -> V4 a

-- | Convert a 3-dimensional affine point into a 4-dimensional homogeneous
--   vector.
point :: Num a => V3 a -> V4 a

-- | Convert 4-dimensional projective coordinates to a 3-dimensional point.
--   This operation may be denoted, <tt>euclidean [x:y:z:w] = (x/w, y/w,
--   z/w)</tt> where the projective, homogenous, coordinate
--   <tt>[x:y:z:w]</tt> is one of many associated with a single point
--   <tt>(x/w, y/w, z/w)</tt>.
normalizePoint :: Fractional a => V4 a -> V3 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t
_x :: R1 t => Lens' (t a) a

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class R1 t => R2 t where _y = _xy . _y
_y :: R2 t => Lens' (t a) a
_xy :: R2 t => Lens' (t a) (V2 a)

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^. _yx
--   V2 2 1
--   </pre>
_yx :: R2 t => Lens' (t a) (V2 a)

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (It may have more)
class R2 t => R3 t
_z :: R3 t => Lens' (t a) a
_xyz :: R3 t => Lens' (t a) (V3 a)
_xz :: R3 t => Lens' (t a) (V2 a)
_yz :: R3 t => Lens' (t a) (V2 a)
_zx :: R3 t => Lens' (t a) (V2 a)
_zy :: R3 t => Lens' (t a) (V2 a)
_xzy :: R3 t => Lens' (t a) (V3 a)
_yxz :: R3 t => Lens' (t a) (V3 a)
_yzx :: R3 t => Lens' (t a) (V3 a)
_zxy :: R3 t => Lens' (t a) (V3 a)
_zyx :: R3 t => Lens' (t a) (V3 a)

-- | A space that distinguishes orthogonal basis vectors <a>_x</a>,
--   <a>_y</a>, <a>_z</a>, <a>_w</a>. (It may have more.)
class R3 t => R4 t
_w :: R4 t => Lens' (t a) a
_xyzw :: R4 t => Lens' (t a) (V4 a)
_xw :: R4 t => Lens' (t a) (V2 a)
_yw :: R4 t => Lens' (t a) (V2 a)
_zw :: R4 t => Lens' (t a) (V2 a)
_wx :: R4 t => Lens' (t a) (V2 a)
_wy :: R4 t => Lens' (t a) (V2 a)
_wz :: R4 t => Lens' (t a) (V2 a)
_xyw :: R4 t => Lens' (t a) (V3 a)
_xzw :: R4 t => Lens' (t a) (V3 a)
_xwy :: R4 t => Lens' (t a) (V3 a)
_xwz :: R4 t => Lens' (t a) (V3 a)
_yxw :: R4 t => Lens' (t a) (V3 a)
_yzw :: R4 t => Lens' (t a) (V3 a)
_ywx :: R4 t => Lens' (t a) (V3 a)
_ywz :: R4 t => Lens' (t a) (V3 a)
_zxw :: R4 t => Lens' (t a) (V3 a)
_zyw :: R4 t => Lens' (t a) (V3 a)
_zwx :: R4 t => Lens' (t a) (V3 a)
_zwy :: R4 t => Lens' (t a) (V3 a)
_wxy :: R4 t => Lens' (t a) (V3 a)
_wxz :: R4 t => Lens' (t a) (V3 a)
_wyx :: R4 t => Lens' (t a) (V3 a)
_wyz :: R4 t => Lens' (t a) (V3 a)
_wzx :: R4 t => Lens' (t a) (V3 a)
_wzy :: R4 t => Lens' (t a) (V3 a)
_xywz :: R4 t => Lens' (t a) (V4 a)
_xzyw :: R4 t => Lens' (t a) (V4 a)
_xzwy :: R4 t => Lens' (t a) (V4 a)
_xwyz :: R4 t => Lens' (t a) (V4 a)
_xwzy :: R4 t => Lens' (t a) (V4 a)
_yxzw :: R4 t => Lens' (t a) (V4 a)
_yxwz :: R4 t => Lens' (t a) (V4 a)
_yzxw :: R4 t => Lens' (t a) (V4 a)
_yzwx :: R4 t => Lens' (t a) (V4 a)
_ywxz :: R4 t => Lens' (t a) (V4 a)
_ywzx :: R4 t => Lens' (t a) (V4 a)
_zxyw :: R4 t => Lens' (t a) (V4 a)
_zxwy :: R4 t => Lens' (t a) (V4 a)
_zyxw :: R4 t => Lens' (t a) (V4 a)
_zywx :: R4 t => Lens' (t a) (V4 a)
_zwxy :: R4 t => Lens' (t a) (V4 a)
_zwyx :: R4 t => Lens' (t a) (V4 a)
_wxyz :: R4 t => Lens' (t a) (V4 a)
_wxzy :: R4 t => Lens' (t a) (V4 a)
_wyxz :: R4 t => Lens' (t a) (V4 a)
_wyzx :: R4 t => Lens' (t a) (V4 a)
_wzxy :: R4 t => Lens' (t a) (V4 a)
_wzyx :: R4 t => Lens' (t a) (V4 a)
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
ew :: R4 t => E t
instance Constructor C1_0V4
instance Datatype D1V4
instance Generic1 V4
instance Generic (V4 a)
instance Data a => Data (V4 a)
instance Read a => Read (V4 a)
instance Show a => Show (V4 a)
instance Ord a => Ord (V4 a)
instance Eq a => Eq (V4 a)
instance Functor V4
instance Foldable V4
instance Traversable V4
instance Foldable1 V4
instance Traversable1 V4
instance Applicative V4
instance Apply V4
instance Additive V4
instance Bind V4
instance Monad V4
instance Num a => Num (V4 a)
instance Fractional a => Fractional (V4 a)
instance Floating a => Floating (V4 a)
instance Metric V4
instance Distributive V4
instance Hashable a => Hashable (V4 a)
instance R1 V4
instance R2 V4
instance R3 V4
instance R4 V4
instance Storable a => Storable (V4 a)
instance Epsilon a => Epsilon (V4 a)
instance Ix a => Ix (V4 a)
instance Representable V4
instance FunctorWithIndex (E V4) V4
instance FoldableWithIndex (E V4) V4
instance TraversableWithIndex (E V4) V4
instance Ixed (V4 a)
instance Each (V4 a) (V4 b) a b
instance Unbox a => Unbox (V4 a)
instance Unbox a => MVector MVector (V4 a)
instance Unbox a => Vector Vector (V4 a)
instance MonadZip V4
instance MonadFix V4
instance Bounded a => Bounded (V4 a)
instance NFData a => NFData (V4 a)
instance Serial1 V4
instance Serial a => Serial (V4 a)
instance Binary a => Binary (V4 a)
instance Serialize a => Serialize (V4 a)
instance Eq1 V4
instance Ord1 V4
instance Show1 V4
instance Read1 V4


-- | Plücker coordinates for lines in 3d homogeneous space.
module Linear.Plucker

-- | Plücker coordinates for lines in a 3-dimensional space.
data Plucker a
[Plucker] :: !a -> !a -> !a -> !a -> !a -> !a -> Plucker a

-- | Valid Plücker coordinates <tt>p</tt> will have <tt><a>squaredError</a>
--   p <a>==</a> 0</tt>
--   
--   That said, floating point makes a mockery of this claim, so you may
--   want to use <a>nearZero</a>.
squaredError :: (Eq a, Num a) => Plucker a -> a

-- | Checks if the line is near-isotropic (isotropic vectors in this
--   quadratic space represent lines in real 3d space).
isotropic :: Epsilon a => Plucker a -> Bool

-- | This isn't th actual metric because this bilinear form gives rise to
--   an isotropic quadratic space
(><) :: Num a => Plucker a -> Plucker a -> a

-- | Given a pair of points represented by homogeneous coordinates generate
--   Plücker coordinates for the line through them, directed from the
--   second towards the first.
plucker :: Num a => V4 a -> V4 a -> Plucker a

-- | Given a pair of 3D points, generate Plücker coordinates for the line
--   through them, directed from the second towards the first.
plucker3D :: Num a => V3 a -> V3 a -> Plucker a

-- | Checks if two lines are parallel.
parallel :: Epsilon a => Plucker a -> Plucker a -> Bool

-- | Checks if two lines intersect (or nearly intersect).
intersects :: (Epsilon a, Ord a) => Plucker a -> Plucker a -> Bool

-- | Describe how two lines pass each other.
data LinePass

-- | The lines are coplanar (parallel or intersecting).
[Coplanar] :: LinePass

-- | The lines pass each other clockwise (right-handed screw)
[Clockwise] :: LinePass

-- | The lines pass each other counterclockwise (left-handed screw).
[Counterclockwise] :: LinePass

-- | Check how two lines pass each other. <tt>passes l1 l2</tt> describes
--   <tt>l2</tt> when looking down <tt>l1</tt>.
passes :: (Epsilon a, Num a, Ord a) => Plucker a -> Plucker a -> LinePass

-- | The minimum squared distance of a line from the origin.
quadranceToOrigin :: Fractional a => Plucker a -> a

-- | The point where a line is closest to the origin.
closestToOrigin :: Fractional a => Plucker a -> V3 a

-- | Not all 6-dimensional points correspond to a line in 3D. This
--   predicate tests that a Plücker coordinate lies on the Grassmann
--   manifold, and does indeed represent a 3D line.
isLine :: Epsilon a => Plucker a -> Bool

-- | Checks if two lines coincide in space. In other words, undirected
--   equality.
coincides :: (Epsilon a, Fractional a) => Plucker a -> Plucker a -> Bool

-- | Checks if two lines coincide in space, and have the same orientation.
coincides' :: (Epsilon a, Fractional a, Ord a) => Plucker a -> Plucker a -> Bool

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p01 :: Lens' (Plucker a) a

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p02 :: Lens' (Plucker a) a

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p03 :: Lens' (Plucker a) a

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p10 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p12 :: Lens' (Plucker a) a

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p13 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p20 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p21 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p23 :: Lens' (Plucker a) a

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p30 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p31 :: Lens' (Plucker a) a

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p32 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)
e01 :: E Plucker
e02 :: E Plucker
e03 :: E Plucker
e12 :: E Plucker
e31 :: E Plucker
e23 :: E Plucker
instance Constructor C1_2LinePass
instance Constructor C1_1LinePass
instance Constructor C1_0LinePass
instance Datatype D1LinePass
instance Constructor C1_0Plucker
instance Datatype D1Plucker
instance Generic LinePass
instance Show LinePass
instance Eq LinePass
instance Generic1 Plucker
instance Generic (Plucker a)
instance Read a => Read (Plucker a)
instance Show a => Show (Plucker a)
instance Ord a => Ord (Plucker a)
instance Eq a => Eq (Plucker a)
instance Functor Plucker
instance Apply Plucker
instance Applicative Plucker
instance Additive Plucker
instance Bind Plucker
instance Monad Plucker
instance Distributive Plucker
instance Representable Plucker
instance Foldable Plucker
instance Traversable Plucker
instance Foldable1 Plucker
instance Traversable1 Plucker
instance Ix a => Ix (Plucker a)
instance Num a => Num (Plucker a)
instance Fractional a => Fractional (Plucker a)
instance Floating a => Floating (Plucker a)
instance Hashable a => Hashable (Plucker a)
instance Storable a => Storable (Plucker a)
instance Metric Plucker
instance Epsilon a => Epsilon (Plucker a)
instance FunctorWithIndex (E Plucker) Plucker
instance FoldableWithIndex (E Plucker) Plucker
instance TraversableWithIndex (E Plucker) Plucker
instance Ixed (Plucker a)
instance Each (Plucker a) (Plucker b) a b
instance Unbox a => Unbox (Plucker a)
instance Unbox a => MVector MVector (Plucker a)
instance Unbox a => Vector Vector (Plucker a)
instance MonadZip Plucker
instance MonadFix Plucker
instance NFData a => NFData (Plucker a)
instance Serial1 Plucker
instance Serial a => Serial (Plucker a)
instance Binary a => Binary (Plucker a)
instance Serialize a => Serialize (Plucker a)
instance Eq1 Plucker
instance Ord1 Plucker
instance Show1 Plucker
instance Read1 Plucker


-- | n-D Vectors
module Linear.V
newtype V n a
[V] :: Vector a -> V n a
[toVector] :: V n a -> Vector a

-- | This can be used to generate a template haskell splice for a type
--   level version of a given <a>int</a>.
--   
--   This does not use GHC TypeLits, instead it generates a numeric type by
--   hand similar to the ones used in the "Functional Pearl: Implicit
--   Configurations" paper by Oleg Kiselyov and Chung-Chieh Shan.
--   
--   <tt>instance Num (Q Exp)</tt> provided in this package allows writing
--   <tt>$(3)</tt> instead of <tt>$(int 3)</tt>. Sometimes the two will
--   produce the same representation (if compiled without the
--   <tt>-DUSE_TYPE_LITS</tt> preprocessor directive).
int :: Int -> TypeQ
dim :: Dim n => V n a -> Int
class Dim n
reflectDim :: Dim n => p n -> Int
reifyDim :: Int -> (forall (n :: *). Dim n => Proxy n -> r) -> r
reifyVector :: Vector a -> (forall (n :: *). Dim n => V n a -> r) -> r
reifyDimNat :: Int -> (forall (n :: Nat). KnownNat n => Proxy n -> r) -> r
reifyVectorNat :: Vector a -> (forall (n :: Nat). KnownNat n => V n a -> r) -> r
fromVector :: Dim n => Vector a -> Maybe (V n a)
instance Selector S1_0_0V
instance Constructor C1_0V
instance Datatype D1V
instance forall (k :: BOX) (n :: k). Generic1 (V n)
instance forall (k :: BOX) (n :: k) a. Generic (V n a)
instance forall (k :: BOX) (n :: k) a. NFData a => NFData (V n a)
instance forall (k :: BOX) (n :: k) a. Read a => Read (V n a)
instance forall (k :: BOX) (n :: k) a. Show a => Show (V n a)
instance forall (k :: BOX) (n :: k) a. Ord a => Ord (V n a)
instance forall (k :: BOX) (n :: k) a. Eq a => Eq (V n a)
instance KnownNat n => Dim n
instance Reifies s Int => Dim (ReifiedDim s)
instance forall (k :: BOX) (n :: k) a. Dim n => Dim (V n a)
instance forall (k :: BOX) (n :: k). Functor (V n)
instance forall (k :: BOX) (n :: k). FunctorWithIndex Int (V n)
instance forall (k :: BOX) (n :: k). Foldable (V n)
instance forall (k :: BOX) (n :: k). FoldableWithIndex Int (V n)
instance forall (k :: BOX) (n :: k). Traversable (V n)
instance forall (k :: BOX) (n :: k). TraversableWithIndex Int (V n)
instance forall (k :: BOX) (n :: k). Apply (V n)
instance forall (k :: BOX) (n :: k). Dim n => Applicative (V n)
instance forall (k :: BOX) (n :: k). Bind (V n)
instance forall (k :: BOX) (n :: k). Dim n => Monad (V n)
instance forall (k :: BOX) (n :: k). Dim n => Additive (V n)
instance forall (k :: BOX) (n :: k) a. (Dim n, Num a) => Num (V n a)
instance forall (k :: BOX) (n :: k) a. (Dim n, Fractional a) => Fractional (V n a)
instance forall (k :: BOX) (n :: k) a. (Dim n, Floating a) => Floating (V n a)
instance forall (k :: BOX) (n :: k). Dim n => Distributive (V n)
instance forall (k :: BOX) (n :: k) a. (Dim n, Storable a) => Storable (V n a)
instance forall (k :: BOX) (n :: k) a. (Dim n, Epsilon a) => Epsilon (V n a)
instance forall (k :: BOX) (n :: k). Dim n => Metric (V n)
instance forall (k :: BOX) (n :: k). Dim n => Representable (V n)
instance forall (k :: BOX) (n :: k) a. Ixed (V n a)
instance forall (k :: BOX) (n :: k). Dim n => MonadZip (V n)
instance forall (k :: BOX) (n :: k). Dim n => MonadFix (V n)
instance forall (k :: BOX) (n :: k) a b. Each (V n a) (V n b) a b
instance forall (k :: BOX) (n :: k) a. (Bounded a, Dim n) => Bounded (V n a)
instance forall (k :: BOX) (n :: k) a. (Typeable (V n), Typeable (V n a), Dim n, Data a) => Data (V n a)
instance forall (k :: BOX) (n :: k). Dim n => Serial1 (V n)
instance forall (k :: BOX) (n :: k) a. (Dim n, Serial a) => Serial (V n a)
instance forall (k :: BOX) (n :: k) a. (Dim n, Binary a) => Binary (V n a)
instance forall (k :: BOX) (n :: k) a. (Dim n, Serialize a) => Serialize (V n a)
instance forall (k :: BOX) (n :: k). Dim n => Eq1 (V n)
instance forall (k :: BOX) (n :: k). Dim n => Ord1 (V n)
instance forall (k :: BOX) (n :: k). Dim n => Show1 (V n)
instance forall (k :: BOX) (n :: k). Dim n => Read1 (V n)


-- | Utility for working with Plücker coordinates for lines in 3d
--   homogeneous space.
module Linear.Plucker.Coincides

-- | When lines are represented as Plücker coordinates, we have the ability
--   to check for both directed and undirected equality. Undirected
--   equality between <a>Line</a>s (or a <a>Line</a> and a <a>Ray</a>)
--   checks that the two lines coincide in 3D space. Directed equality,
--   between two <a>Ray</a>s, checks that two lines coincide in 3D, and
--   have the same direction. To accomodate these two notions of equality,
--   we use an <a>Eq</a> instance on the <a>Coincides</a> data type.
--   
--   For example, to check the <i>directed</i> equality between two lines,
--   <tt>p1</tt> and <tt>p2</tt>, we write, <tt>Ray p1 == Ray p2</tt>.
data Coincides a
[Line] :: Plucker a -> Coincides a
[Ray] :: Plucker a -> Coincides a
instance Eq (Coincides a)


-- | Involutive rings
module Linear.Conjugate

-- | An involutive ring
class Num a => Conjugate a where conjugate = id
conjugate :: Conjugate a => a -> a

-- | Requires and provides a default definition such that
--   
--   <pre>
--   <a>conjugate</a> = <a>id</a>
--   </pre>
class Conjugate a => TrivialConjugate a
instance Conjugate Integer
instance Conjugate Int
instance Conjugate Int64
instance Conjugate Int32
instance Conjugate Int16
instance Conjugate Int8
instance Conjugate Word
instance Conjugate Word64
instance Conjugate Word32
instance Conjugate Word16
instance Conjugate Word8
instance Conjugate Double
instance Conjugate Float
instance Conjugate CFloat
instance Conjugate CDouble
instance (Conjugate a, RealFloat a) => Conjugate (Complex a)
instance TrivialConjugate Integer
instance TrivialConjugate Int
instance TrivialConjugate Int64
instance TrivialConjugate Int32
instance TrivialConjugate Int16
instance TrivialConjugate Int8
instance TrivialConjugate Word
instance TrivialConjugate Word64
instance TrivialConjugate Word32
instance TrivialConjugate Word16
instance TrivialConjugate Word8
instance TrivialConjugate Double
instance TrivialConjugate Float
instance TrivialConjugate CFloat
instance TrivialConjugate CDouble


-- | Quaternions
module Linear.Quaternion

-- | Quaternions
data Quaternion a
[Quaternion] :: !a -> {-# UNPACK #-} !(V3 a) -> Quaternion a

-- | A vector space that includes the basis elements <a>_e</a> and
--   <a>_i</a>
class Complicated t
_e, _i :: Complicated t => Lens' (t a) a

-- | A vector space that includes the basis elements <a>_e</a>, <a>_i</a>,
--   <a>_j</a> and <a>_k</a>
class Complicated t => Hamiltonian t
_j, _k :: Hamiltonian t => Lens' (t a) a
_ijk :: Hamiltonian t => Lens' (t a) (V3 a)
ee :: Complicated t => E t
ei :: Complicated t => E t
ej :: Hamiltonian t => E t
ek :: Hamiltonian t => E t

-- | Spherical linear interpolation between two quaternions.
slerp :: RealFloat a => Quaternion a -> Quaternion a -> a -> Quaternion a

-- | <a>asin</a> with a specified branch cut.
asinq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>acos</a> with a specified branch cut.
acosq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>atan</a> with a specified branch cut.
atanq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>asinh</a> with a specified branch cut.
asinhq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>acosh</a> with a specified branch cut.
acoshq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>atanh</a> with a specified branch cut.
atanhq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | norm of the imaginary component
absi :: Floating a => Quaternion a -> a

-- | raise a <a>Quaternion</a> to a scalar power
pow :: RealFloat a => Quaternion a -> a -> Quaternion a

-- | Apply a rotation to a vector.
rotate :: (Conjugate a, RealFloat a) => Quaternion a -> V3 a -> V3 a

-- | <tt><a>axisAngle</a> axis theta</tt> builds a <a>Quaternion</a>
--   representing a rotation of <tt>theta</tt> radians about <tt>axis</tt>.
axisAngle :: (Epsilon a, Floating a) => V3 a -> a -> Quaternion a
instance Constructor C1_0Quaternion
instance Datatype D1Quaternion
instance Generic1 Quaternion
instance Generic (Quaternion a)
instance Data a => Data (Quaternion a)
instance Show a => Show (Quaternion a)
instance Read a => Read (Quaternion a)
instance Ord a => Ord (Quaternion a)
instance Eq a => Eq (Quaternion a)
instance Functor Quaternion
instance Apply Quaternion
instance Applicative Quaternion
instance Additive Quaternion
instance Bind Quaternion
instance Monad Quaternion
instance Ix a => Ix (Quaternion a)
instance Representable Quaternion
instance FunctorWithIndex (E Quaternion) Quaternion
instance FoldableWithIndex (E Quaternion) Quaternion
instance TraversableWithIndex (E Quaternion) Quaternion
instance Ixed (Quaternion a)
instance Each (Quaternion a) (Quaternion b) a b
instance Foldable Quaternion
instance Traversable Quaternion
instance Storable a => Storable (Quaternion a)
instance RealFloat a => Num (Quaternion a)
instance Hashable a => Hashable (Quaternion a)
instance RealFloat a => Fractional (Quaternion a)
instance Metric Quaternion
instance Complicated Complex
instance Complicated Quaternion
instance Hamiltonian Quaternion
instance Distributive Quaternion
instance (Conjugate a, RealFloat a) => Conjugate (Quaternion a)
instance RealFloat a => Floating (Quaternion a)
instance (RealFloat a, Epsilon a) => Epsilon (Quaternion a)
instance Unbox a => Unbox (Quaternion a)
instance Unbox a => MVector MVector (Quaternion a)
instance Unbox a => Vector Vector (Quaternion a)
instance MonadZip Quaternion
instance MonadFix Quaternion
instance NFData a => NFData (Quaternion a)
instance Serial1 Quaternion
instance Serial a => Serial (Quaternion a)
instance Binary a => Binary (Quaternion a)
instance Serialize a => Serialize (Quaternion a)
instance Eq1 Quaternion
instance Ord1 Quaternion
instance Show1 Quaternion
instance Read1 Quaternion


-- | Simple matrix operation for low-dimensional primitives.
module Linear.Trace
class Functor m => Trace m where trace = sum . diagonal diagonal = join
trace :: (Trace m, Num a) => m (m a) -> a
diagonal :: Trace m => m (m a) -> m a
instance Trace IntMap
instance Ord k => Trace (Map k)
instance (Eq k, Hashable k) => Trace (HashMap k)
instance Dim n => Trace (V n)
instance Trace V0
instance Trace V1
instance Trace V2
instance Trace V3
instance Trace V4
instance Trace Plucker
instance Trace Quaternion
instance Trace Complex
instance (Trace f, Trace g) => Trace (Product f g)
instance (Distributive g, Trace g, Trace f) => Trace (Compose g f)


-- | Simple matrix operation for low-dimensional primitives.
module Linear.Matrix

-- | Matrix product. This can compute any combination of sparse and dense
--   multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !*! V3 (V2 1 2) (V2 3 4) (V2 4 5)
--   V2 (V2 19 25) (V2 43 58)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 (fromList [(1,2)]) (fromList [(2,3)]) !*! fromList [(1,V3 0 0 1), (2, V3 0 0 5)]
--   V2 (V3 0 0 2) (V3 0 0 15)
--   </pre>
(!*!) :: (Functor m, Foldable t, Additive t, Additive n, Num a) => m (t a) -> t (n a) -> m (n a)

-- | Entry-wise matrix addition.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !+! V2 (V3 7 8 9) (V3 1 2 3)
--   V2 (V3 8 10 12) (V3 5 7 9)
--   </pre>
(!+!) :: (Additive m, Additive n, Num a) => m (n a) -> m (n a) -> m (n a)

-- | Entry-wise matrix subtraction.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !-! V2 (V3 7 8 9) (V3 1 2 3)
--   V2 (V3 (-6) (-6) (-6)) (V3 3 3 3)
--   </pre>
(!-!) :: (Additive m, Additive n, Num a) => m (n a) -> m (n a) -> m (n a)

-- | Matrix * column vector
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !* V3 7 8 9
--   V2 50 122
--   </pre>
(!*) :: (Functor m, Foldable r, Additive r, Num a) => m (r a) -> r a -> m a

-- | Row vector * matrix
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 *! V2 (V3 3 4 5) (V3 6 7 8)
--   V3 15 18 21
--   </pre>
(*!) :: (Num a, Foldable t, Additive f, Additive t) => t a -> t (f a) -> f a

-- | Matrix-scalar product
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V2 1 2) (V2 3 4) !!* 5
--   V2 (V2 5 10) (V2 15 20)
--   </pre>
(!!*) :: (Functor m, Functor r, Num a) => m (r a) -> a -> m (r a)

-- | Scalar-matrix product
--   
--   <pre>
--   &gt;&gt;&gt; 5 *!! V2 (V2 1 2) (V2 3 4)
--   V2 (V2 5 10) (V2 15 20)
--   </pre>
(*!!) :: (Functor m, Functor r, Num a) => a -> m (r a) -> m (r a)

-- | Matrix-scalar division
(!!/) :: (Functor m, Functor r, Fractional a) => m (r a) -> a -> m (r a)

-- | This is a generalization of <a>inside</a> to work over any
--   corepresentable <a>Functor</a>.
--   
--   <pre>
--   <a>column</a> :: <a>Representable</a> f =&gt; <a>Lens</a> s t a b -&gt; <a>Lens</a> (f s) (f t) (f a) (f b)
--   </pre>
--   
--   In practice it is used to access a column of a matrix.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) ^._x
--   V3 1 2 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) ^.column _x
--   V2 1 4
--   </pre>
column :: Representable f => LensLike (Context a b) s t a b -> Lens (f s) (f t) (f a) (f b)

-- | Hermitian conjugate or conjugate transpose
--   
--   <pre>
--   &gt;&gt;&gt; adjoint (V2 (V2 (1 :+ 2) (3 :+ 4)) (V2 (5 :+ 6) (7 :+ 8)))
--   V2 (V2 (1.0 :+ (-2.0)) (5.0 :+ (-6.0))) (V2 (3.0 :+ (-4.0)) (7.0 :+ (-8.0)))
--   </pre>
adjoint :: (Functor m, Distributive n, Conjugate a) => m (n a) -> n (m a)

-- | A 2x2 matrix with row-major representation
type M22 a = V2 (V2 a)

-- | A 2x3 matrix with row-major representation
type M23 a = V2 (V3 a)

-- | A 2x3 matrix with row-major representation
type M24 a = V2 (V4 a)

-- | A 3x2 matrix with row-major representation
type M32 a = V3 (V2 a)

-- | A 3x3 matrix with row-major representation
type M33 a = V3 (V3 a)

-- | A 3x4 matrix with row-major representation
type M34 a = V3 (V4 a)

-- | A 4x2 matrix with row-major representation
type M42 a = V4 (V2 a)

-- | A 4x3 matrix with row-major representation
type M43 a = V4 (V3 a)

-- | A 4x4 matrix with row-major representation
type M44 a = V4 (V4 a)

-- | Convert a 3x3 matrix to a 4x4 matrix extending it with 0's in the new
--   row and column.
m33_to_m44 :: Num a => M33 a -> M44 a

-- | Convert from a 4x3 matrix to a 4x4 matrix, extending it with the <tt>[
--   0 0 0 1 ]</tt> column vector
m43_to_m44 :: Num a => M43 a -> M44 a

-- | 2x2 matrix determinant.
--   
--   <pre>
--   &gt;&gt;&gt; det22 (V2 (V2 a b) (V2 c d))
--   a * d - b * c
--   </pre>
det22 :: Num a => M22 a -> a

-- | 3x3 matrix determinant.
--   
--   <pre>
--   &gt;&gt;&gt; det33 (V3 (V3 a b c) (V3 d e f) (V3 g h i))
--   a * (e * i - f * h) - d * (b * i - c * h) + g * (b * f - c * e)
--   </pre>
det33 :: Num a => M33 a -> a

-- | 4x4 matrix determinant.
det44 :: Num a => M44 a -> a

-- | 2x2 matrix inverse.
--   
--   <pre>
--   &gt;&gt;&gt; inv22 $ V2 (V2 1 2) (V2 3 4)
--   Just (V2 (V2 (-2.0) 1.0) (V2 1.5 (-0.5)))
--   </pre>
inv22 :: (Epsilon a, Floating a) => M22 a -> Maybe (M22 a)

-- | 3x3 matrix inverse.
--   
--   <pre>
--   &gt;&gt;&gt; inv33 $ V3 (V3 1 2 4) (V3 4 2 2) (V3 1 1 1)
--   Just (V3 (V3 0.0 0.5 (-1.0)) (V3 (-0.5) (-0.75) 3.5) (V3 0.5 0.25 (-1.5)))
--   </pre>
inv33 :: (Epsilon a, Floating a) => M33 a -> Maybe (M33 a)

-- | 4x4 matrix inverse.
inv44 :: (Epsilon a, Fractional a) => M44 a -> Maybe (M44 a)

-- | The identity matrix for any dimension vector.
--   
--   <pre>
--   &gt;&gt;&gt; identity :: M44 Int
--   V4 (V4 1 0 0 0) (V4 0 1 0 0) (V4 0 0 1 0) (V4 0 0 0 1)
--   
--   &gt;&gt;&gt; identity :: V3 (V3 Int)
--   V3 (V3 1 0 0) (V3 0 1 0) (V3 0 0 1)
--   </pre>
identity :: (Num a, Traversable t, Applicative t) => t (t a)
class Functor m => Trace m where trace = sum . diagonal diagonal = join
trace :: (Trace m, Num a) => m (m a) -> a
diagonal :: Trace m => m (m a) -> m a

-- | Extract the translation vector (first three entries of the last
--   column) from a 3x4 or 4x4 matrix.
translation :: (Representable t, R3 t, R4 v) => Lens' (t (v a)) (V3 a)

-- | <a>transpose</a> is just an alias for <a>distribute</a>
--   
--   <pre>
--   transpose (V3 (V2 1 2) (V2 3 4) (V2 5 6))
--   </pre>
--   
--   V2 (V3 1 3 5) (V3 2 4 6)
transpose :: (Distributive g, Functor f) => f (g a) -> g (f a)

-- | Build a rotation matrix from a unit <a>Quaternion</a>.
fromQuaternion :: Num a => Quaternion a -> M33 a

-- | Build a transformation matrix from a rotation expressed as a
--   <a>Quaternion</a> and a translation vector.
mkTransformation :: Num a => Quaternion a -> V3 a -> M44 a

-- | Build a transformation matrix from a rotation matrix and a translation
--   vector.
mkTransformationMat :: Num a => M33 a -> V3 a -> M44 a

-- | Extract a 2x2 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m22 :: (Representable t, R2 t, R2 v) => Lens' (t (v a)) (M22 a)

-- | Extract a 2x3 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m23 :: (Representable t, R2 t, R3 v) => Lens' (t (v a)) (M23 a)

-- | Extract a 2x4 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m24 :: (Representable t, R2 t, R4 v) => Lens' (t (v a)) (M24 a)

-- | Extract a 3x2 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m32 :: (Representable t, R3 t, R2 v) => Lens' (t (v a)) (M32 a)

-- | Extract a 3x3 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m33 :: (Representable t, R3 t, R3 v) => Lens' (t (v a)) (M33 a)

-- | Extract a 3x4 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m34 :: (Representable t, R3 t, R4 v) => Lens' (t (v a)) (M34 a)

-- | Extract a 4x2 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m42 :: (Representable t, R4 t, R2 v) => Lens' (t (v a)) (M42 a)

-- | Extract a 4x3 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m43 :: (Representable t, R4 t, R3 v) => Lens' (t (v a)) (M43 a)

-- | Extract a 4x4 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m44 :: (Representable t, R4 t, R4 v) => Lens' (t (v a)) (M44 a)


-- | Common projection matrices: e.g. perspective/orthographic
--   transformation matrices.
--   
--   Analytically derived inverses are also supplied, because they can be
--   much more accurate in practice than computing them through general
--   purpose means
module Linear.Projection

-- | Build a look at view matrix
lookAt :: (Epsilon a, Floating a) => V3 a -> V3 a -> V3 a -> M44 a

-- | Build a matrix for a symmetric perspective-view frustum
perspective :: Floating a => a -> a -> a -> a -> M44 a

-- | Build an inverse perspective matrix
inversePerspective :: Floating a => a -> a -> a -> a -> M44 a

-- | Build a matrix for a symmetric perspective-view frustum with a far
--   plane at infinite
infinitePerspective :: Floating a => a -> a -> a -> M44 a
inverseInfinitePerspective :: Floating a => a -> a -> a -> M44 a

-- | Build a perspective matrix per the classic <tt>glFrustum</tt>
--   arguments.
frustum :: Floating a => a -> a -> a -> a -> a -> a -> M44 a
inverseFrustum :: Floating a => a -> a -> a -> a -> a -> a -> M44 a

-- | Build an orthographic perspective matrix from 6 clipping planes. This
--   matrix takes the region delimited by these planes and maps it to
--   normalized device coordinates between [-1,1]
--   
--   This call is designed to mimic the parameters to the OpenGL
--   <tt>glOrtho</tt> call, so it has a slightly strange convention:
--   Notably: the near and far planes are negated.
--   
--   Consequently:
--   
--   <pre>
--   <a>ortho</a> l r b t n f !* <a>V4</a> l b (-n) 1 = <a>V4</a> (-1) (-1) (-1) 1
--   <a>ortho</a> l r b t n f !* <a>V4</a> r t (-f) 1 = <a>V4</a> 1 1 1 1
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; ortho 1 2 3 4 5 6 !* V4 1 3 (-5) 1
--   V4 (-1.0) (-1.0) (-1.0) 1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ortho 1 2 3 4 5 6 !* V4 2 4 (-6) 1
--   V4 1.0 1.0 1.0 1.0
--   </pre>
ortho :: Fractional a => a -> a -> a -> a -> a -> a -> M44 a

-- | Build an inverse orthographic perspective matrix from 6 clipping
--   planes
inverseOrtho :: Fractional a => a -> a -> a -> a -> a -> a -> M44 a


-- | Operations on affine spaces.
module Linear.Affine

-- | An affine space is roughly a vector space in which we have forgotten
--   or at least pretend to have forgotten the origin.
--   
--   <pre>
--   a .+^ (b .-. a)  =  b@
--   (a .+^ u) .+^ v  =  a .+^ (u ^+^ v)@
--   (a .-. b) ^+^ v  =  (a .+^ v) .-. q@
--   </pre>
class Additive (Diff p) => Affine p where type family Diff p :: * -> * p .-^ v = p .+^ negated v
(.-.) :: (Affine p, Num a) => p a -> p a -> Diff p a
(.+^) :: (Affine p, Num a) => p a -> Diff p a -> p a
(.-^) :: (Affine p, Num a) => p a -> Diff p a -> p a

-- | Compute the quadrance of the difference (the square of the distance)
qdA :: (Affine p, Foldable (Diff p), Num a) => p a -> p a -> a

-- | Distance between two points in an affine space
distanceA :: (Floating a, Foldable (Diff p), Affine p) => p a -> p a -> a

-- | A handy wrapper to help distinguish points from vectors at the type
--   level
newtype Point f a
[P] :: (f a) -> Point f a
lensP :: Lens' (Point g a) (g a)
_Point :: Iso' (Point f a) (f a)

-- | Vector spaces have origins.
origin :: (Additive f, Num a) => Point f a

-- | An isomorphism between points and vectors, given a reference point.
relative :: (Additive f, Num a) => Point f a -> Iso' (Point f a) (f a)
instance Constructor C1_0Point
instance Datatype D1Point
instance (Data (f a), Typeable f, Typeable a) => Data (Point f a)
instance Generic1 (Point f)
instance Generic (Point f a)
instance Hashable (f a) => Hashable (Point f a)
instance Epsilon (f a) => Epsilon (Point f a)
instance Storable (f a) => Storable (Point f a)
instance Ix (f a) => Ix (Point f a)
instance Num (f a) => Num (Point f a)
instance Fractional (f a) => Fractional (Point f a)
instance Metric f => Metric (Point f)
instance Additive f => Additive (Point f)
instance Apply f => Apply (Point f)
instance Traversable f => Traversable (Point f)
instance Read1 f => Read1 (Point f)
instance Show1 f => Show1 (Point f)
instance Ord1 f => Ord1 (Point f)
instance Eq1 f => Eq1 (Point f)
instance Foldable f => Foldable (Point f)
instance Applicative f => Applicative (Point f)
instance Functor f => Functor (Point f)
instance Monad f => Monad (Point f)
instance Read (f a) => Read (Point f a)
instance Show (f a) => Show (Point f a)
instance Ord (f a) => Ord (Point f a)
instance Eq (f a) => Eq (Point f a)
instance Affine []
instance Affine Complex
instance Affine ZipList
instance Affine Maybe
instance Affine IntMap
instance Affine Identity
instance Affine Vector
instance Affine V0
instance Affine V1
instance Affine V2
instance Affine V3
instance Affine V4
instance Affine Plucker
instance Affine Quaternion
instance Affine ((->) b)
instance Ord k => Affine (Map k)
instance (Eq k, Hashable k) => Affine (HashMap k)
instance Dim n => Affine (V n)
instance NFData (f a) => NFData (Point f a)
instance Serial1 f => Serial1 (Point f)
instance Serial (f a) => Serial (Point f a)
instance Binary (f a) => Binary (Point f a)
instance Serialize (f a) => Serialize (Point f a)
instance (t ~ Point g b) => Rewrapped (Point f a) t
instance Wrapped (Point f a)
instance Bind f => Bind (Point f)
instance Distributive f => Distributive (Point f)
instance Representable f => Representable (Point f)
instance Ixed (f a) => Ixed (Point f a)
instance Traversable f => Each (Point f a) (Point f b) a b
instance R1 f => R1 (Point f)
instance R2 f => R2 (Point f)
instance R3 f => R3 (Point f)
instance R4 f => R4 (Point f)
instance Additive f => Affine (Point f)


-- | Serialization of statically-sized types with the <a>Data.Binary</a>
--   library.
module Linear.Binary

-- | Serialize a linear type.
putLinear :: (Binary a, Foldable t) => t a -> Put

-- | Deserialize a linear type.
getLinear :: (Binary a, Applicative t, Traversable t) => Get (t a)


module Linear.Algebra

-- | An associative unital algebra over a ring
class Num r => Algebra r m
mult :: Algebra r m => (m -> m -> r) -> m -> r
unital :: Algebra r m => r -> m -> r

-- | A coassociative counital coalgebra over a ring
class Num r => Coalgebra r m
comult :: Coalgebra r m => (m -> r) -> m -> m -> r
counital :: Coalgebra r m => (m -> r) -> r
multRep :: (Representable f, Algebra r (Rep f)) => f (f r) -> f r
unitalRep :: (Representable f, Algebra r (Rep f)) => r -> f r
comultRep :: (Representable f, Coalgebra r (Rep f)) => f r -> f (f r)
counitalRep :: (Representable f, Coalgebra r (Rep f)) => f r -> r
instance Num r => Algebra r Void
instance Num r => Algebra r (E V0)
instance Num r => Algebra r (E V1)
instance Num r => Algebra r ()
instance (Algebra r a, Algebra r b) => Algebra r (a, b)
instance Num r => Algebra r (E Complex)
instance (Num r, TrivialConjugate r) => Algebra r (E Quaternion)
instance Num r => Coalgebra r Void
instance Num r => Coalgebra r ()
instance Num r => Coalgebra r (E V0)
instance Num r => Coalgebra r (E V1)
instance Num r => Coalgebra r (E V2)
instance Num r => Coalgebra r (E V3)
instance Num r => Coalgebra r (E V4)
instance Num r => Coalgebra r (E Complex)
instance (Num r, TrivialConjugate r) => Coalgebra r (E Quaternion)
instance (Coalgebra r m, Coalgebra r n) => Coalgebra r (m, n)


-- | Operations on affine spaces.
module Linear.Covector

-- | Linear functionals from elements of an (infinite) free module to a
--   scalar
newtype Covector r a
[Covector] :: ((a -> r) -> r) -> Covector r a
[runCovector] :: Covector r a -> (a -> r) -> r
($*) :: Representable f => Covector r (Rep f) -> f r -> r
instance Functor (Covector r)
instance Apply (Covector r)
instance Applicative (Covector r)
instance Bind (Covector r)
instance Monad (Covector r)
instance Num r => Alt (Covector r)
instance Num r => Plus (Covector r)
instance Num r => Alternative (Covector r)
instance Num r => MonadPlus (Covector r)
instance Coalgebra r m => Num (Covector r m)


-- | This module simply re-exports everything from the various modules that
--   make up the linear package.
module Linear
