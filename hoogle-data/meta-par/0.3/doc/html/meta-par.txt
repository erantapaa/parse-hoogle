-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides the monad-par interface, but based on modular scheduler "mix-ins".
--   
--   This library provides a composable abstraction for <i>Resources</i>
--   which can be mixed and matched to build <i>Schedulers</i>. A
--   <a>Resource</a> typically corresponds to a specific kind of hardware
--   or to a style of scheduling. This package contains implementations of
--   basic <a>Resource</a>s that implement parallel scheduling on the CPU.
--   To use a complete meta-par Scheduler, import Control.Monad.Par.SMP for
--   example, which will provide a <a>runPar</a> as well as instances for
--   the relevant classes that enable <a>Par</a> programming (e.g.
--   <a>ParFuture</a>).
@package meta-par
@version 0.3


-- | A very simple layer of abstraction for frequently modified shared
--   variables. This additional indirection is only present for
--   benchmarking <a>IORef</a> operations vs. <tt>MVar</tt> or
--   <tt>TVar</tt> implementations.
module Control.Monad.Par.Meta.HotVar.IORef
type HotVar a = IORef a
modifyHotVar :: HotVar a -> (a -> (a, b)) -> IO b
modifyHotVar_ :: HotVar a -> (a -> a) -> IO ()
newHotVar :: a -> IO (HotVar a)
readHotVar :: HotVar a -> IO a
readHotVarRaw :: HotVar a -> IO a
writeHotVar :: HotVar a -> a -> IO ()
writeHotVarRaw :: HotVar a -> a -> IO ()
instance Show (HotVar a)

module Control.Monad.Par.Meta.Resources.Debugging
dbg :: Bool

-- | dbgTaggedMsg is our routine for logging debugging output:
dbgTaggedMsg :: Int -> ByteString -> IO ()
dbgDelay :: ByteString -> IO ()

-- | <a>dbgCharMsg</a> is for printing a small tag like <a>.</a> (with no
--   line termination) which produces a different kind of visual output.
--   dbgCharMsg :: Int -&gt; String -&gt; String -&gt; IO ()
dbgCharMsg :: Int -> ByteString -> ByteString -> IO ()
meaningless_alloc :: IO ()
taggedmsg_global_mode :: IORef ByteString
verbosity :: Int

module Control.Monad.Par.Meta

-- | The Meta-Par monad with its full suite of instances. Note that the
--   <a>MonadIO</a> instance, while essential for building new
--   <a>Resource</a>s, is unsafe in client code when combined with
--   <a>runMetaPar</a>. This type should therefore be exposed to client
--   code as a <tt>newtype</tt> that omits the <a>MonadIO</a> instance.
data Par a

-- | An <a>IVar</a> is a <i>write-once</i>, <i>read-many</i> structure for
--   communication between <a>Par</a> threads.
data IVar a

-- | <tt>ParFuture</tt> captures the class of Par monads which support
--   futures. This level of functionality subsumes
--   <tt>par</tt>/<tt>pseq</tt> and is similar to the
--   <a>Control.Parallel.Strategies.Eval</a> monad.
--   
--   A minimal implementation consists of <a>spawn_</a> and <a>get</a>.
--   However, for monads that are also a member of <a>ParIVar</a> it is
--   typical to simply define <a>spawn</a> in terms of <a>fork</a>,
--   <a>new</a>, and <a>put</a>.
class Monad m => ParFuture (future :: * -> *) (m :: * -> *) | m -> future
spawn :: (ParFuture future m, NFData a) => m a -> m (future a)
spawn_ :: ParFuture future m => m a -> m (future a)
get :: ParFuture future m => future a -> m a
spawnP :: (ParFuture future m, NFData a) => a -> m (future a)

-- | <tt>ParIVar</tt> builds on futures by adding full <i>anyone-writes,
--   anyone-reads</i> IVars. These are more expressive but may not be
--   supported by all distributed schedulers.
--   
--   A minimal implementation consists of <a>fork</a>, <a>put_</a>, and
--   <a>new</a>.
class ParFuture ivar m => ParIVar (ivar :: * -> *) (m :: * -> *) | m -> ivar
fork :: ParIVar ivar m => m () -> m ()
new :: ParIVar ivar m => m (ivar a)
put :: (ParIVar ivar m, NFData a) => ivar a -> a -> m ()
put_ :: ParIVar ivar m => ivar a -> a -> m ()
newFull :: (ParIVar ivar m, NFData a) => a -> m (ivar a)
newFull_ :: ParIVar ivar m => a -> m (ivar a)

-- | Run a <a>Par</a> computation, and return its result as a pure value.
--   If the choice of <a>Resource</a> introduces non-determinism, use
--   <a>runMetaParIO</a> instead, as non-deterministic computations are not
--   referentially-transparent.
runMetaPar :: Resource -> Par a -> a

-- | Run a <a>Par</a> computation in the <a>IO</a> monad, allowing
--   non-deterministic Meta-Par variants to be safely executed.
runMetaParIO :: Resource -> Par a -> IO a
data Sched
Sched :: {-# UNPACK #-} !Int -> HotVar (Set ThreadId) -> WSDeque (Par ()) -> HotVar GenIO -> HotVar Int -> IORef Int -> HotVar Int -> WorkSearch -> Sched

-- | Capability number
no :: Sched -> {-# UNPACK #-} !Int

-- | The <a>ThreadId</a>s of all worker threads on this capability
tids :: Sched -> HotVar (Set ThreadId)

-- | The local <a>WSDeque</a> for this worker. The worker may push and pop
--   from the left of its own <a>workpool</a>, but workers on other threads
--   may only steal from the right.
workpool :: Sched -> WSDeque (Par ())

-- | A <a>GenIO</a> for random work stealing.
rng :: Sched -> HotVar GenIO

-- | A counter of how many extra workers are working on this capability.
--   This situation arises during nested calls to <a>runMetaPar</a>, and
--   the worker loop kills workers as necessary to keep this value at
--   <tt>1</tt>.
mortals :: Sched -> HotVar Int

-- | Tracks the number of consecutive times this worker has invoked a
--   <a>WorkSearch</a> and received <a>Nothing</a>. This is used to
--   implement backoff in <a>Backoff</a>.
consecutiveFailures :: Sched -> IORef Int

-- | A per-thread source of unique identifiers for <a>IVar</a>s. Multiply
--   this value by <a>getNumCapabilities</a> and add <a>no</a> for
--   uniqueness.
ivarUID :: Sched -> HotVar Int

-- | The <a>WorkSearch</a> of this worker's associated <a>Resource</a>.
schedWs :: Sched -> WorkSearch

-- | A <a>GlobalState</a> structure tracks the state of all Meta-Par
--   workers in a program in a <a>Vector</a> indexed by capability number.
type GlobalState = Vector (Maybe Sched)

-- | A <a>Resource</a> provides an abstraction of heterogeneous execution
--   resources, and may be combined using <a>Monoid</a> operations.
--   Composition of resources is left-biased; for example, if
--   <tt>resource1</tt> always returns work from its <a>WorkSearch</a>, the
--   composed resource <tt>resource1 <a>mappend</a> resource2</tt> will
--   never request work from <tt>resource2</tt>.
data Resource
Resource :: Startup -> WorkSearch -> Resource
startup :: Resource -> Startup
workSearch :: Resource -> WorkSearch

-- | The <a>Startup</a> component of a <a>Resource</a> is a callback that
--   implements initialization behavior. For example, the SMP
--   <a>Startup</a> calls <a>spawnWorkerOnCPU</a> a number of times. The
--   arguments to <a>Startup</a> are the combined <a>Resource</a> of the
--   current scheduler and a thread-safe reference to the
--   <a>GlobalState</a>.
newtype Startup
St :: (WorkSearch -> HotVar GlobalState -> IO ()) -> Startup
runSt :: Startup -> WorkSearch -> HotVar GlobalState -> IO ()

-- | The <a>WorkSearch</a> component of a <a>Resource</a> is a callback
--   that responds to requests for work from Meta-Par workers. The
--   arguments to <a>WorkSearch</a> are the <a>Sched</a> for the current
--   thread and a thread-safe reference to the <a>GlobalState</a>.
newtype WorkSearch
WS :: (Sched -> HotVar GlobalState -> IO (Maybe (Par ()))) -> WorkSearch
runWS :: WorkSearch -> Sched -> HotVar GlobalState -> IO (Maybe (Par ()))

-- | Produces a variant of <a>forkOn</a> that allows exceptions from child
--   threads to propagate up to the parent thread.
forkWithExceptions :: (IO () -> IO ThreadId) -> String -> (IO () -> IO ThreadId)

-- | Spawn a Meta-Par worker that will stay on a given capability.
--   
--   Note: this does not check whether workers already exist on the
--   capability, and should be called appropriately. In particular, it is
--   the caller's responsibility to manage things like the <tt>mortal</tt>
--   count of the given capability.
spawnWorkerOnCPU :: WorkSearch -> Int -> IO ThreadId
instance Typeable1 Par
instance Monad Par
instance MonadCont Par
instance MonadReader Sched Par
instance MonadIO Par
instance Applicative Par
instance Functor Par
instance Show Resource
instance ParIVar IVar Par
instance ParFuture IVar Par
instance Show Sched
instance Monoid Resource
instance Monoid WorkSearch
instance Show WorkSearch
instance Monoid Startup
instance Show Startup
instance NFData (IVar a)


-- | This module implements a Meta-Par <a>Resource</a> for SMP parallelism,
--   suitable as a base for combined execution resources (e.g.,
--   <tt>Control.Monad.Par.Meta.AccSMP</tt>).
module Control.Monad.Par.Meta.Resources.SMP

-- | Create an SMP resource for all capabilities.
mkResource :: Int -> Resource

-- | Create an SMP resource for a configurable list of capabilities.
mkResourceOn :: [Int] -> Int -> Resource

-- | <a>Startup</a> for spawning threads on all capabilities, or from a
--   <a>read</a>-able list of capability numbers in the environment
--   variable <tt>SMP_CAPS</tt>.
defaultStartup :: Startup

-- | <a>WorkSearch</a> for all capabilities.
defaultWorkSearch :: Int -> WorkSearch

-- | <a>Startup</a> for spawning threads only on a particular set of
--   capabilities.
startupForCaps :: [Int] -> Startup

-- | Given a set of capabilities and a number of steals to attempt per
--   capability, return a <a>WorkSearch</a>.
wsForCaps :: [Int] -> Int -> WorkSearch

module Control.Monad.Par.Meta.SMP

-- | The Meta-Par monad specialized for SMP parallelism.
data Par a

-- | An <a>IVar</a> is a <i>write-once</i>, <i>read-many</i> structure for
--   communication between <a>Par</a> threads.
data IVar a

-- | <tt>ParFuture</tt> captures the class of Par monads which support
--   futures. This level of functionality subsumes
--   <tt>par</tt>/<tt>pseq</tt> and is similar to the
--   <a>Control.Parallel.Strategies.Eval</a> monad.
--   
--   A minimal implementation consists of <a>spawn_</a> and <a>get</a>.
--   However, for monads that are also a member of <a>ParIVar</a> it is
--   typical to simply define <a>spawn</a> in terms of <a>fork</a>,
--   <a>new</a>, and <a>put</a>.
class Monad m => ParFuture (future :: * -> *) (m :: * -> *) | m -> future
spawn :: (ParFuture future m, NFData a) => m a -> m (future a)
spawn_ :: ParFuture future m => m a -> m (future a)
get :: ParFuture future m => future a -> m a
spawnP :: (ParFuture future m, NFData a) => a -> m (future a)

-- | <tt>ParIVar</tt> builds on futures by adding full <i>anyone-writes,
--   anyone-reads</i> IVars. These are more expressive but may not be
--   supported by all distributed schedulers.
--   
--   A minimal implementation consists of <a>fork</a>, <a>put_</a>, and
--   <a>new</a>.
class ParFuture ivar m => ParIVar (ivar :: * -> *) (m :: * -> *) | m -> ivar
fork :: ParIVar ivar m => m () -> m ()
new :: ParIVar ivar m => m (ivar a)
put :: (ParIVar ivar m, NFData a) => ivar a -> a -> m ()
put_ :: ParIVar ivar m => ivar a -> a -> m ()
newFull :: (ParIVar ivar m, NFData a) => a -> m (ivar a)
newFull_ :: ParIVar ivar m => a -> m (ivar a)
runPar :: Par a -> a
runParIO :: Par a -> IO a
instance Functor Par
instance Applicative Par
instance Monad Par
instance ParFuture IVar Par
instance ParIVar IVar Par


-- | A simple single-threaded <a>Resource</a> that is a useful
--   accompaniment for testing non-CPU resources such as GPU or
--   distributed.
module Control.Monad.Par.Meta.Resources.SingleThreaded

-- | Create a single-threaded resource.
mkResource :: Resource

-- | Spawn a single Meta-Par worker.
defaultStartup :: Startup

-- | A single-threaded resource by itself is not aware of any other sources
--   of work, so its <a>WorkSearch</a> always returns <a>Nothing</a>.
defaultWorkSearch :: WorkSearch

module Control.Monad.Par.Meta.Serial

-- | The Meta-Par monad specialized for single-threaded execution.
data Par a

-- | <tt>ParFuture</tt> captures the class of Par monads which support
--   futures. This level of functionality subsumes
--   <tt>par</tt>/<tt>pseq</tt> and is similar to the
--   <a>Control.Parallel.Strategies.Eval</a> monad.
--   
--   A minimal implementation consists of <a>spawn_</a> and <a>get</a>.
--   However, for monads that are also a member of <a>ParIVar</a> it is
--   typical to simply define <a>spawn</a> in terms of <a>fork</a>,
--   <a>new</a>, and <a>put</a>.
class Monad m => ParFuture (future :: * -> *) (m :: * -> *) | m -> future
spawn :: (ParFuture future m, NFData a) => m a -> m (future a)
spawn_ :: ParFuture future m => m a -> m (future a)
get :: ParFuture future m => future a -> m a
spawnP :: (ParFuture future m, NFData a) => a -> m (future a)

-- | <tt>ParIVar</tt> builds on futures by adding full <i>anyone-writes,
--   anyone-reads</i> IVars. These are more expressive but may not be
--   supported by all distributed schedulers.
--   
--   A minimal implementation consists of <a>fork</a>, <a>put_</a>, and
--   <a>new</a>.
class ParFuture ivar m => ParIVar (ivar :: * -> *) (m :: * -> *) | m -> ivar
fork :: ParIVar ivar m => m () -> m ()
new :: ParIVar ivar m => m (ivar a)
put :: (ParIVar ivar m, NFData a) => ivar a -> a -> m ()
put_ :: ParIVar ivar m => ivar a -> a -> m ()
newFull :: (ParIVar ivar m, NFData a) => a -> m (ivar a)
newFull_ :: ParIVar ivar m => a -> m (ivar a)
runPar :: Par a -> a
runParIO :: Par a -> IO a
instance Functor Par
instance Applicative Par
instance Monad Par
instance ParFuture IVar Par
instance ParIVar IVar Par


-- | This module implements exponential backoff so as to prevent spamming
--   of steal actions. This is always a good idea, and especially so in the
--   distributed case where steal attempts send actual messages.
--   
--   Normally backoff functionality is baked into the scheduler loop. One
--   nice aspect of the Meta scheduler design is that backoff can become
--   <a>just another resource</a>. Most schedulers (compositions) should
--   include this at tho bottom of their stack.
module Control.Monad.Par.Meta.Resources.Backoff
defaultStartup :: Startup

-- | To construct a WorkSearch we need to know the minimum and maximum
--   amount of time (nanoseconds) to sleep. The exponential backoff policy
--   is always the same: it starts at 1ns and doubles.
--   
--   The thing that changes over time is whether sleeping actually
--   *occurs*. For example, `mkWorkSearch 1000 100000` will not sleep for
--   the first ten invocations (until 1024), and then will sleep an amount
--   that doubles each time until it surpasses the maximum, at which point
--   each sleep will be for the maximum: 100ms.
mkWorkSearch :: Word64 -> Word64 -> WorkSearch
mkResource :: Word64 -> Word64 -> Resource
