-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple and comprehensive Haskell parsing library
--   
--   A simple and comprehensive Haskell parsing library
@package JustParse
@version 2.1


-- | The bread and butter of combinatory parsing.
module Data.JustParse.Combinator

-- | Synonym of <a>guard</a>.
assert :: Stream s t => Bool -> Parser s ()

-- | Only succeeds when supplied with <a>Nothing</a>.
eof :: Stream s t => Parser s ()

-- | <tt>eitherP a b</tt> returns the result wrapped in a <a>Left</a> if
--   <tt>a</tt> succeeds or a <a>Right</a> if <tt>b</tt> succeeds
eitherP :: Stream s t => Parser s a -> Parser s b -> Parser s (Either a b)

-- | Modifies a parser so that it will ony return the most consumptive
--   succesful results.
greedy :: Stream s t => Parser s a -> Parser s a

-- | A parser that succeeds on <a>True</a> and fails on <a>False</a>.
guard :: Stream s t => Bool -> Parser s ()

-- | Applies the parser and returns its result, but resets the
--   <a>Stream</a> as if it consumed nothing.
lookAhead :: Stream s t => Parser s a -> Parser s a

-- | Only succeeds when the given parser fails. Consumes no input.
notFollowedBy :: Stream s t => Parser s a -> Parser s ()

-- | Attempts to apply a parser and returns a default value if it fails.
option :: Stream s t => a -> Parser s a -> Parser s a

-- | Attempts to apply the parser, returning <a>Nothing</a> upon failure,
--   or the result wrapped in a <a>Just</a>.
optional :: Stream s t => Parser s a -> Parser s (Maybe a)

-- | Return <a>True</a> if the parser would succeed if one were to apply
--   it, otherwise, it returns <a>False</a>. It does not consume input.
test :: Stream s t => Parser s a -> Parser s Bool

-- | Does nothing -- only used for <tt>Parsec</tt> compatability.
try :: Stream s t => Parser s a -> Parser s a

-- | <tt>a &lt;|&gt; b</tt> is equivalent to <tt><a>choice</a> [a,b]</tt>.
--   That is, first <tt>a</tt> is tried, and if it yields no results,
--   <tt>b</tt> is tried.
(<|>) :: Stream s t => Parser s a -> Parser s a -> Parser s a

-- | Parse any token.
anyToken :: Stream s t => Parser s t

-- | Parse a token that is not a member of the list of tokens.
noneOf :: (Eq t, Stream s t) => [t] -> Parser s t

-- | Parse a token that is a member of the list of tokens.
oneOf :: (Eq t, Stream s t) => [t] -> Parser s t

-- | Parse a token that satisfies a predicate.
satisfy :: Stream s t => (t -> Bool) -> Parser s t

-- | Parse a specific token.
token :: (Eq t, Stream s t) => t -> Parser s t

-- | <tt>chainr p o x</tt> parses zero or more occurences of <tt>p</tt>
--   separated by <tt>o</tt>. The result is the left associative
--   application of the functions to the values. If <tt>p</tt> succeeds
--   zero times, <tt>x</tt> is returned.
chainl :: Stream s t => Parser s a -> Parser s (a -> a -> a) -> a -> Parser s a

-- | Like <a>chainl</a>, but a minimum of one occurence of <tt>p</tt> must
--   be parsed.
chainl1 :: Stream s t => Parser s a -> Parser s (a -> a -> a) -> Parser s a

-- | Like <a>chainl</a>, but right associative.
chainr :: Stream s t => Parser s a -> Parser s (a -> a -> a) -> a -> Parser s a

-- | Like <a>chainl1</a>, but right associative.
chainr1 :: Stream s t => Parser s a -> Parser s (a -> a -> a) -> Parser s a

-- | <tt>count n p</tt> parses exactly <tt>n</tt> occurences of <tt>p</tt>.
count :: Stream s t => Int -> Parser s a -> Parser s [a]

-- | <tt>endBy p s</tt> parses multiple occurences of <tt>p</tt> separated
--   and ended by <tt>s</tt>.
endBy :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | <tt>endBy1 p s</tt> parses one or more occurences of <tt>p</tt>
--   separated and ended by <tt>s</tt>.
endBy1 :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | Synonym of <a>count</a>.
exactly :: Stream s t => Int -> Parser s a -> Parser s [a]

-- | Applies a parser zero or more times.
many :: Stream s t => Parser s a -> Parser s [a]

-- | Applies a parser one or more times.
many1 :: Stream s t => Parser s a -> Parser s [a]

-- | <tt>manyTill a b</tt> parses multiple occurences of <tt>a</tt> until
--   <tt>b</tt> would succeed if tried.
manyTill :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | <tt>mN m n p</tt> parses between <tt>m</tt> and <tt>n</tt> occurences
--   of <tt>p</tt>, inclusive.
mN :: Stream s t => Int -> Int -> Parser s a -> Parser s [a]

-- | <tt>sepBy1 p s</tt> parses many occurences of <tt>p</tt> separated by
--   <tt>s</tt>.
sepBy :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | <tt>sepBy1 p s</tt> parses one or more occurences of <tt>p</tt>
--   separated by <tt>s</tt>.
sepBy1 :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | Identical to <a>many</a> except the result is discarded.
skipMany :: Stream s t => Parser s a -> Parser s ()

-- | Identical to <a>many1</a> except the result is discarded.
skipMany1 :: Stream s t => Parser s a -> Parser s ()

-- | <tt>sepEndBy p s</tt> parses multiple occurences of <tt>p</tt>
--   separated and optionally ended by <tt>s</tt>.
sepEndBy :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | <tt>sepEndBy p s</tt> parses one or more occurences of <tt>p</tt>
--   separated and optionally ended by <tt>s</tt>.
sepEndBy1 :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | Parse tokens while a predicate remains true.
takeWhile :: Stream s t => (t -> Bool) -> Parser s [t]

-- | Parse one or more tokens while a predicate remains true.
takeWhile1 :: Stream s t => (t -> Bool) -> Parser s [t]

-- | Attempt to apply each parser in the list in order until one succeeds.
choice :: Stream s t => [Parser s a] -> Parser s a

-- | Parses a sequence of parsers in any order.
perm :: Stream s t => [Parser s a] -> Parser s [a]

-- | Like <a>choice</a>, but returns the index of the successful parser as
--   well as the result.
select :: Stream s t => [Parser s a] -> Parser s (Int, a)

-- | Splits the current parse branch between the two parsers.
branch :: Parser s a -> Parser s a -> Parser s a

-- | Infix version of <a>branch</a>.
(<||>) :: Parser s a -> Parser s a -> Parser s a

-- | Branches every iteration where one branch stops and one branch
--   continues.
chainl_ :: Stream s t => Parser s a -> Parser s (a -> a -> a) -> a -> Parser s a

-- | Branches every iteration where one branch stops and one branch
--   continues.
chainr_ :: Stream s t => Parser s a -> Parser s (a -> a -> a) -> a -> Parser s a

-- | Branches every iteration where one branch stops and one branch
--   continues.
chainl1_ :: Stream s t => Parser s a -> Parser s (a -> a -> a) -> Parser s a

-- | Branches every iteration where one branch stops and one branch
--   continues.
chainr1_ :: Stream s t => Parser s a -> Parser s (a -> a -> a) -> Parser s a

-- | Given a list of parsers, split off a branch for each one.
choice_ :: Stream s t => [Parser s a] -> Parser s a

-- | Like <a>eitherP</a>, but tries both <tt>a</tt> and <tt>b</tt>.
eitherP_ :: Stream s t => Parser s a -> Parser s b -> Parser s (Either a b)

-- | Branches every iteration where one branch stops and one branch
--   continues.
endBy_ :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | Branches every iteration where one branch stops and one branch
--   continues.
endBy1_ :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | Branches every iteration where one branch stops and one branch
--   continues.
many_ :: Parser s a -> Parser s [a]

-- | Branches every iteration where one branch stops and one branch
--   continues.
many1_ :: Parser s a -> Parser s [a]

-- | Branches every iteration where one branch stops and one branch
--   continues.
mN_ :: Stream s t => Int -> Int -> Parser s a -> Parser s [a]

-- | Splits off two branches, one where the parse is attempted, and one
--   where it is not.
option_ :: Stream s t => a -> Parser s a -> Parser s a

-- | Splits off two branches, one where the parse is attempted, and one
--   where it is not.
optional_ :: Stream s t => Parser s a -> Parser s (Maybe a)

-- | Parses a sequence of parsers in all possible orders.
perm_ :: Stream s t => [Parser s a] -> Parser s [a]

-- | Like <a>choice_</a>, but returns the index of the successful parser.
select_ :: Stream s t => [Parser s a] -> Parser s (Int, a)

-- | Branches every iteration where one branch stops and one branch
--   continues.
sepBy_ :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | Branches every iteration where one branch stops and one branch
--   continues.
sepBy1_ :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | Branches every iteration where one branch stops and one branch
--   continues.
sepEndBy_ :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | Branches every iteration where one branch stops and one branch
--   continues.
sepEndBy1_ :: Stream s t => Parser s a -> Parser s b -> Parser s [a]

-- | Branches every iteration where one branch stops and one branch
--   continues.
skipMany_ :: Stream s t => Parser s a -> Parser s ()

-- | Branches every iteration where one branch stops and one branch
--   continues.
skipMany1_ :: Stream s t => Parser s a -> Parser s ()

-- | Branches every iteration where one branch stops and one branch
--   continues.
takeWhile_ :: Stream s t => (t -> Bool) -> Parser s [t]

-- | Branches every iteration where one branch stops and one branch
--   continues.
takeWhile1_ :: Stream s t => (t -> Bool) -> Parser s [t]


-- | Several useful parsers for dealing with <a>String</a>s.
module Data.JustParse.Char

-- | Parse a specic char.
char :: Stream s Char => Char -> Parser s Char

-- | Parse any char.
anyChar :: Stream s Char => Parser s Char

-- | Parse a specific char, ignoring case.
caseInsensitiveChar :: Stream s Char => Char -> Parser s Char

-- | Parse any char that is ASCII.
ascii :: Stream s Char => Parser s Char

-- | Parse any char that is Latin-1.
latin1 :: Stream s Char => Parser s Char

-- | Parse a control character.
control :: Stream s Char => Parser s Char

-- | Parse a space.
space :: Stream s Char => Parser s Char

-- | Parse a lowercase character.
lower :: Stream s Char => Parser s Char

-- | Parse an uppercase character.
upper :: Stream s Char => Parser s Char

-- | Parse an alphabetic character.
alpha :: Stream s Char => Parser s Char

-- | Parse an alphanumeric character.
alphaNum :: Stream s Char => Parser s Char

-- | Parse a printable (non-control) character.
print :: Stream s Char => Parser s Char

-- | Parse a digit.
digit :: Stream s Char => Parser s Char

-- | Parse an octal digit.
octDigit :: Stream s Char => Parser s Char

-- | Parse a hexadeciaml digit.
hexDigit :: Stream s Char => Parser s Char

-- | Parse a specific string.
string :: Stream s Char => String -> Parser s String

-- | Parse a specfic string, ignoring case.
caseInsensitiveString :: Stream s Char => String -> Parser s String

-- | Parses until a newline, carriage return + newline, or newline +
--   carriage return.
eol :: Stream s Char => Parser s String
instance [safe] Eq t => Stream [t] t


-- | Parsers for dealing with signed and unsigned <a>Int</a>s and
--   <a>Float</a>s.
module Data.JustParse.Numeric

-- | Parse a single decimal digit into an <a>Int</a>.
decDigit :: Stream s Char => Parser s Int

-- | Parse a single hexadecimal digit into an <a>Int</a>.
hexDigit :: Stream s Char => Parser s Int

-- | Parse a series of decimal digits into an <a>Int</a>.
unsignedDecInt :: Stream s Char => Parser s Int

-- | Branching version of <a>unsignedDecInt</a>.
unsignedDecInt_ :: Stream s Char => Parser s Int

-- | Parse a series of hexadecimal digits into an <a>Int</a>.
unsignedHexInt :: Stream s Char => Parser s Int

-- | Branching version of <a>unsignedHexInt</a>.
unsignedHexInt_ :: Stream s Char => Parser s Int

-- | Parse a series of decimal digits into an <a>Int</a> with an optional
--   sign.
decInt :: Stream s Char => Parser s Int

-- | Branching version of <a>decInt</a>.
decInt_ :: Stream s Char => Parser s Int

-- | Parse a series of hexadecimal digits into an <a>Int</a> with an
--   optional sign.
hexInt :: Stream s Char => Parser s Int

-- | Branching versino of <a>hexInt</a>.
hexInt_ :: Stream s Char => Parser s Int

-- | Parse a float. If a decimal point is present, it must have at least
--   one digit before and after the decimal point.
decFloat :: Stream s Char => Parser s Float

-- | Branching version of decFloat.
decFloat_ :: Stream s Char => Parser s Float


module Data.JustParse

-- | Supplies the input to the <a>Parser</a>. Returns all <a>Result</a>
--   types, including <a>Partial</a> results.
runParser :: Parser s a -> s -> [Result s a]

-- | This runs the <a>Parser</a> greedily over the input, <a>finalize</a>s
--   all the results, and returns the first successful result. If there are
--   no successful results, it returns <a>Nothing</a>. This is useful when
--   you are parsing something that you know will have no <a>Partial</a>s
--   and you just want an answer.
parseOnly :: Stream s t => Parser s a -> s -> Maybe a

-- | <tt>extend</tt> takes a <tt><a>Maybe</a> s</tt> as input, and supplies
--   the input to all values in the <a>Result</a> list. For <a>Done</a>
--   values, it appends the <a>Stream</a> to the <a>leftover</a> portion,
--   and for <a>Partial</a> values, it runs the continuation, adding in any
--   new <a>Result</a> values to the output.
extend :: (Eq s, Monoid s) => Maybe s -> [Result s a] -> [Result s a]

-- | <tt>finalize</tt> takes a list of results (presumably returned from a
--   <a>Parser</a> or <a>Partial</a>, and supplies <a>Nothing</a> to any
--   remaining <a>Partial</a> values, so that only <a>Done</a> values
--   remain.
finalize :: (Eq s, Monoid s) => [Result s a] -> [Result s a]
data Parser s a
data Result s a

-- | A <tt>Partial</tt> wraps the same function as a Parser. Supply it with
--   a <a>Just</a> and it will continue parsing, or with a <a>Nothing</a>
--   and it will terminate.
Partial :: (Maybe s -> [Result s a]) -> Result s a
continue :: Result s a -> Maybe s -> [Result s a]

-- | A <tt>Done</tt> contains the resultant <tt>value</tt>, and the
--   <tt>leftover</tt> stream, if any.
Done :: a -> Maybe s -> Result s a
value :: Result s a -> a
leftover :: Result s a -> Maybe s

-- | A <tt>Stream</tt> instance has a stream of type <tt>s</tt>, made up of
--   tokens of type <tt>t</tt>, which must be determinable by the stream. A
--   minimal complete definition only needs to define <tt>uncons</tt>.
class (Eq s, Monoid s) => Stream s t | s -> t where length s = case uncons s of { Nothing -> 0 Just (x, xs) -> 1 + length xs }
uncons :: (Stream s t, Stream s t) => s -> Maybe (t, s)
length :: (Stream s t, Stream s t) => s -> Int


-- | Allows for conversion from a regular expression and a <a>Parser</a>.
module Data.JustParse.Language

-- | The result of a <a>regex</a>
data Match
Match :: String -> [Match] -> Match

-- | The complete text matched within the regex
matched :: Match -> String

-- | Any submatches created by using capture groups
groups :: Match -> [Match]

-- | <tt>regex</tt> takes a regular expression in the form of a
--   <a>String</a> and, if the regex is valid, returns a <a>Parser</a> that
--   parses that regex. If the regex is invalid, it returns a Parser that
--   will always fail. The returned parser is greedy.
regex :: Stream s Char => String -> Parser s Match

-- | Like <a>regex</a>, but returns a branching (non-greedy) parser.
regex_ :: Stream s Char => String -> Parser s Match

-- | The same as <a>regex</a>, but only returns the full matched text.
regex' :: Stream s Char => String -> Parser s String

-- | The same as <a>regex_</a>, but only returns the full matched text.
regex_' :: Stream s Char => String -> Parser s String
instance [safe] Monoid Match
instance [safe] Show Match
