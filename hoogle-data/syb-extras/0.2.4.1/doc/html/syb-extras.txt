-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Higher order versions of the Scrap Your Boilerplate classes
--   
--   Higher order versions of the Scrap Your Boilerplate classes to ease
--   programming with polymorphic recursion and reduce UndecidableInstances
@package syb-extras
@version 0.2.4.1

module Data.Data.Extras
class Typeable1 f => Data1 f where gfoldl1 _ z = z dataCast1_1 _ = Nothing dataCast2_1 _ = Nothing gmapT1 f x0 = unID (gfoldl1 (\ (ID c) x -> ID (c (f x))) ID x0) gmapQl1 o r f = unCONST . gfoldl1 (\ c x -> CONST $ unCONST c `o` f x) (\ _ -> CONST r) gmapQr1 o r0 f x0 = unQr (gfoldl1 (\ (Qr c) x -> Qr (\ r -> c (f x `o` r))) (const (Qr id)) x0) r0 gmapQ1 f = gmapQr1 (:) [] f gmapQi1 i f x = fromJust $ unQi $ gfoldl1 (\ (Qi i' q) a -> Qi (i' + 1) (if i == i' then Just (f a) else q)) (\ _ -> Qi 0 Nothing) x gmapM1 f = gfoldl1 (\ c x -> do { c' <- c; liftM c' (f x) }) return gmapMp1 f x = unMp (gfoldl1 k z x) >>= \ (x', b) -> if b then return x' else mzero where z g = Mp (return (g, False)) k (Mp c) y = Mp (c >>= \ (h, b) -> (f y >>= \ y' -> return (h y', True)) `mplus` return (h y, b)) gmapMo1 f x = unMp (gfoldl1 k z x) >>= \ (x', b) -> if b then return x' else mzero where z g = Mp (return (g, False)) k (Mp c) y = Mp (c >>= \ (h, b) -> if b then return (h y, b) else (f y >>= \ y' -> return (h y', True)) `mplus` return (h y, b))
gfoldl1 :: (Data1 f, Data a) => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> f a -> c (f a)
gunfold1 :: (Data1 f, Data a) => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c (f a)
toConstr1 :: (Data1 f, Data a) => f a -> Constr
dataTypeOf1 :: (Data1 f, Data a) => f a -> DataType
dataCast1_1 :: (Data1 f, Typeable1 t, Data a) => (forall d. Data d => c (t d)) -> Maybe (c (f a))
dataCast2_1 :: (Data1 f, Typeable2 t, Data a) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (f a))
gmapT1 :: (Data1 f, Data a) => (forall b. Data b => b -> b) -> f a -> f a
gmapQl1 :: (Data1 f, Data a) => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> f a -> r
gmapQr1 :: (Data1 f, Data a) => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> f a -> r
gmapQ1 :: (Data1 f, Data a) => (forall d. Data d => d -> u) -> f a -> [u]
gmapQi1 :: (Data1 f, Data a) => Int -> (forall d. Data d => d -> u) -> f a -> u
gmapM1 :: (Data1 f, Monad m, Data a) => (forall d. Data d => d -> m d) -> f a -> m (f a)
gmapMp1 :: (Data1 f, MonadPlus m, Data a) => (forall d. Data d => d -> m d) -> f a -> m (f a)
gmapMo1 :: (Data1 f, MonadPlus m, Data a) => (forall d. Data d => d -> m d) -> f a -> m (f a)
fromConstr1 :: (Data1 f, Data a) => Constr -> f a
fromConstrB1 :: (Data1 f, Data a) => (forall d. Data d => d) -> Constr -> f a
fromConstrM1 :: (Monad m, Data1 f, Data a) => (forall d. Data d => m d) -> Constr -> m (f a)
class Typeable2 f => Data2 f where gfoldl2 _ z = z dataCast1_2 _ = Nothing dataCast2_2 _ = Nothing gmapT2 f x0 = unID (gfoldl2 (\ (ID c) x -> ID (c (f x))) ID x0) gmapQl2 o r f = unCONST . gfoldl2 (\ c x -> CONST $ unCONST c `o` f x) (\ _ -> CONST r) gmapQr2 o r0 f x0 = unQr (gfoldl2 (\ (Qr c) x -> Qr (\ r -> c (f x `o` r))) (const (Qr id)) x0) r0 gmapQ2 f = gmapQr2 (:) [] f gmapQi2 i f x = fromJust $ unQi $ gfoldl2 (\ (Qi i' q) a -> Qi (i' + 2) (if i == i' then Just (f a) else q)) (\ _ -> Qi 0 Nothing) x gmapM2 f = gfoldl2 (\ c x -> do { c' <- c; liftM c' (f x) }) return gmapMp2 f x = unMp (gfoldl2 k z x) >>= \ (x', b) -> if b then return x' else mzero where z g = Mp (return (g, False)) k (Mp c) y = Mp (c >>= \ (h, b) -> (f y >>= \ y' -> return (h y', True)) `mplus` return (h y, b)) gmapMo2 f x = unMp (gfoldl2 k z x) >>= \ (x', b) -> if b then return x' else mzero where z g = Mp (return (g, False)) k (Mp c) y = Mp (c >>= \ (h, b) -> if b then return (h y, b) else (f y >>= \ y' -> return (h y', True)) `mplus` return (h y, b))
gfoldl2 :: (Data2 f, Data a, Data x) => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> f a x -> c (f a x)
gunfold2 :: (Data2 f, Data a, Data x) => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c (f a x)
toConstr2 :: (Data2 f, Data a, Data x) => f a x -> Constr
dataTypeOf2 :: (Data2 f, Data a, Data x) => f a x -> DataType
dataCast1_2 :: (Data2 f, Typeable1 t, Data a, Data x) => (forall d. Data d => c (t d)) -> Maybe (c (f a x))
dataCast2_2 :: (Data2 f, Typeable2 t, Data a, Data x) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (f a x))
gmapT2 :: (Data2 f, Data a, Data x) => (forall b. Data b => b -> b) -> f a x -> f a x
gmapQl2 :: (Data2 f, Data a, Data x) => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> f a x -> r
gmapQr2 :: (Data2 f, Data a, Data x) => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> f a x -> r
gmapQ2 :: (Data2 f, Data a, Data x) => (forall d. Data d => d -> u) -> f a x -> [u]
gmapQi2 :: (Data2 f, Data a, Data x) => Int -> (forall d. Data d => d -> u) -> f a x -> u
gmapM2 :: (Data2 f, Monad m, Data a, Data x) => (forall d. Data d => d -> m d) -> f a x -> m (f a x)
gmapMp2 :: (Data2 f, MonadPlus m, Data a, Data x) => (forall d. Data d => d -> m d) -> f a x -> m (f a x)
gmapMo2 :: (Data2 f, MonadPlus m, Data a, Data x) => (forall d. Data d => d -> m d) -> f a x -> m (f a x)
fromConstr2 :: (Data2 f, Data a, Data x) => Constr -> f a x
fromConstrB2 :: (Data2 f, Data a, Data x) => (forall d. Data d => d) -> Constr -> f a x
fromConstrM2 :: (Monad m, Data2 f, Data a, Data x) => (forall d. Data d => m d) -> Constr -> m (f a x)
liftK :: (Data1 d1, Data a) => (forall d b. Data d => c (d -> b) -> d -> c b) -> c (d1 a -> b') -> d1 a -> c b'
liftK2 :: (Data2 d2, Data a, Data x) => (forall d b. Data d => c (d -> b) -> d -> c b) -> c (d2 a x -> b') -> d2 a x -> c b'
liftF :: (Data1 b1, Data a) => (forall b r. Data b => c (b -> r) -> c r) -> c (b1 a -> r') -> c r'
liftF2 :: (Data2 b2, Data a, Data x) => (forall b r. Data b => c (b -> r) -> c r) -> c (b2 a x -> r') -> c r'
instance Iso (f a) (WrappedData1 f a)
instance Iso (f a b) (WrappedData2 f a b)
instance (Data2 f, Data a, Data b) => Data (WrappedData2 f a b)
instance (Data2 f, Data a) => Data1 (WrappedData2 f a)
instance Data2 f => Data2 (WrappedData2 f)
instance Typeable2 f => Typeable2 (WrappedData2 f)
instance (Data1 f, Data a) => Data (WrappedData1 f a)
instance Data1 f => Data1 (WrappedData1 f)
instance Typeable1 f => Typeable1 (WrappedData1 f)
instance Iso a a
instance Data2 (,)
instance Data2 Either
instance Data a => Data1 ((,) a)
instance Data a => Data1 (Either a)
instance Data1 Maybe
instance Data1 []
