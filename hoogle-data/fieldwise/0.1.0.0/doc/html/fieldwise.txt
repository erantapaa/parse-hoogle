-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides Fieldwise typeclass for operations of fields of records treated as independent components.
--   
--   Provides Fieldwise typeclass for operations of fields of records
--   treated as independent components.
@package fieldwise
@version 0.1.0.0


-- | Module Data.Fieldwise provides <a>Fieldwise</a> typeclass for
--   operations of fields of records treated as independent components.
module Data.Fieldwise

-- | Fieldwise class provides some operations for record fields treated as
--   independent pieces of data. See individual methods.
class Fieldwise r where type family UnliftedRecord r
sequenceR :: (Fieldwise r, Applicative f) => r f -> f (UnliftedRecord r)
hoistR :: Fieldwise r => (forall a. f a -> g a) -> r f -> r g
zipWithR :: Fieldwise r => (forall a. f a -> g a -> h a) -> r f -> r g -> r h
appR :: Fieldwise r => (forall a. f a -> (UnliftedRecord r -> a) -> g a) -> r f -> r g
liftR :: (Fieldwise r, Applicative f) => UnliftedRecord r -> r f

-- | Automatically derive lifted record type and <a>Monoid</a> and
--   <a>Fieldwise</a> instances for it.
--   
--   First argument is the name of Haskell data type that should serve as
--   basis for derivation, second argument tell how to tranform names in
--   that type. Names need to be transformed if you want to derive
--   fieldwise in the same module as original data type.
--   
--   Conceptually for a data type <tt>T</tt> a derived data <tt>T_f</tt>
--   has type for each field wrapped in a type constructor. <tt>T</tt> is
--   semantically equal to <tt>T_f Id</tt>.
--   
--   For example for data type:
--   
--   <pre>
--   data Test1 = Test1 Int String
--              | Test2 { test2Char :: Char, test2IntList :: [Int], test2Func :: (Int -&gt; Int) }
--   </pre>
--   
--   <pre>
--   $(deriveFieldwise ''Test1  (++ "_f"))
--   </pre>
--   
--   Will produce the following splice:
--   
--   <pre>
--   data Test1_f f
--     = Test1_f (f Int) (f String) |
--       Test2_f {test2Char_f :: f Char,
--                test2IntList_f :: f [Int],
--                test2Func_f :: f (Int -&gt; Int)}
--   
--   instance Alternative f =&gt; Monoid (Test1_f f) where
--     mempty = Test1_f empty empty
--     mappend (Test1_f l1 l2) (Test1_f r1 r2)
--       = Test1_f (l1 &lt;|&gt; r1) (l2 &lt;|&gt; r2)
--     mappend (Test2_f l1 l2 l3) (Test2_f r1 r2 r3)
--       = Test2_f (l1 &lt;|&gt; r1) (l2 &lt;|&gt; r2) (l3 &lt;|&gt; r3)
--   
--   instance Fieldwise Test1_f where
--     type instance UnliftedRecord Test1_f = Test1
--     sequenceR (Test1_f l1 l2) = (((pure Test1) &lt;*&gt; l1) &lt;*&gt; l2)
--     hoistR fg (Test1_f l1 l2) = Test1_f (fg l1) (fg l2)
--     hoistR fg (Test2_f l1 l2 l3)
--       = Test2_f (fg l1) (fg l2) (fg l3)
--     zipWithR fg (Test1_f l1 l2) (Test1_f r1 r2)
--       = Test1_f (fg l1 r1) (fg l2 r2)
--     zipWithR fg (Test2_f l1 l2 l3) (Test2_f r1 r2 r3)
--       = Test2_f (fg l1 r1) (fg l2 r2) (fg l3 r3)
--     appR fg (Test1_f l1 l2)
--       = Test1_f
--           (fg l1 (\ (Test1 q_ahwb _) -&gt; q_ahwb))
--           (fg l2 (\ (Test1 _ q_ahwb) -&gt; q_ahwb))
--     appR fg (Test2_f l1 l2 l3)
--       = Test2_f
--           (fg l1 test2Char)
--           (fg l2 test2IntList)
--           (fg l3 test2Func)
--     liftR (Test1 l1 l2) = Test1_f (pure l1) (pure l2)
--     liftR (Test2 l1 l2 l3) = Test2_f (pure l1) (pure l2) (pure l3)
--   </pre>
deriveFieldwise :: Name -> (String -> String) -> Q [Dec]
