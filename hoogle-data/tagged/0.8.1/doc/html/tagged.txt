-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell 98 phantom types to avoid unsafely passing dummy arguments
--   
@package tagged
@version 0.8.1

module Data.Proxy.TH

-- | A proxy value quasiquoter. <tt>[pr|T|]</tt> will splice an expression
--   <tt>Proxy::Proxy T</tt>, while <tt>[pr|A,B,C|]</tt> will splice in a
--   value of <tt>Proxy :: Proxy [A,B,C]</tt>.
pr :: QuasiQuoter

-- | Like <a>pr</a>, but takes a single type, which is used to produce a
--   <tt>Proxy</tt> for a single-element list containing only that type.
--   This is useful for passing a single type to a function that wants a
--   list of types.
pr1 :: QuasiQuoter


module Data.Tagged

-- | A <tt><a>Tagged</a> s b</tt> value is a value <tt>b</tt> with an
--   attached phantom type <tt>s</tt>. This can be used in place of the
--   more traditional but less safe idiom of passing in an undefined value
--   with the type, because unlike an <tt>(s -&gt; b)</tt>, a
--   <tt><a>Tagged</a> s b</tt> can't try to use the argument <tt>s</tt> as
--   a real value.
--   
--   Moreover, you don't have to rely on the compiler to inline away the
--   extra argument, because the newtype is "free"
newtype Tagged s b
Tagged :: b -> Tagged s b
unTagged :: Tagged s b -> b

-- | Some times you need to change the tag you have lying around. Idiomatic
--   usage is to make a new combinator for the relationship between the
--   tags that you want to enforce, and define that combinator using
--   <a>retag</a>.
--   
--   <pre>
--   data Succ n
--   retagSucc :: <a>Tagged</a> n a -&gt; <a>Tagged</a> (Succ n) a
--   retagSucc = <a>retag</a>
--   </pre>
retag :: Tagged s b -> Tagged t b

-- | Alias for <a>unTagged</a>
untag :: Tagged s b -> b

-- | Tag a value with its own type.
tagSelf :: a -> Tagged a a

-- | <a>untagSelf</a> is a type-restricted version of <a>untag</a>.
untagSelf :: Tagged a a -> a

-- | <a>asTaggedTypeOf</a> is a type-restricted version of <a>const</a>. It
--   is usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   tag of the second.
asTaggedTypeOf :: s -> tagged s b -> s
witness :: Tagged a b -> a -> b

-- | Convert from a <a>Tagged</a> representation to a representation based
--   on a <a>Proxy</a>.
proxy :: Tagged s a -> proxy s -> a

-- | Convert from a representation based on a <a>Proxy</a> to a
--   <a>Tagged</a> representation.
unproxy :: (Proxy s -> a) -> Tagged s a

-- | Another way to convert a proxy to a tag.
tagWith :: proxy s -> a -> Tagged s a

-- | Some times you need to change the proxy you have lying around.
--   Idiomatic usage is to make a new combinator for the relationship
--   between the proxies that you want to enforce, and define that
--   combinator using <a>reproxy</a>.
--   
--   <pre>
--   data Succ n
--   reproxySucc :: proxy n -&gt; <a>Proxy</a> (Succ n)
--   reproxySucc = <a>reproxy</a>
--   </pre>
reproxy :: proxy a -> Proxy b
instance Typeable Tagged
instance Eq b => Eq (Tagged s b)
instance Ord b => Ord (Tagged s b)
instance Ix b => Ix (Tagged s b)
instance Bounded b => Bounded (Tagged s b)
instance Generic (Tagged s b)
instance Generic1 (Tagged s)
instance Datatype D1Tagged
instance Constructor C1_0Tagged
instance Selector S1_0_0Tagged
instance RealFloat a => RealFloat (Tagged s a)
instance RealFrac a => RealFrac (Tagged s a)
instance Floating a => Floating (Tagged s a)
instance Fractional a => Fractional (Tagged s a)
instance Integral a => Integral (Tagged s a)
instance Real a => Real (Tagged s a)
instance Num a => Num (Tagged s a)
instance Enum a => Enum (Tagged s a)
instance Traversable (Tagged s)
instance Foldable (Tagged s)
instance Monad (Tagged s)
instance Applicative (Tagged s)
instance Functor (Tagged s)
instance Monoid a => Monoid (Tagged s a)
instance Read b => Read (Tagged s b)
instance Show b => Show (Tagged s b)
instance (Data s, Data b) => Data (Tagged s b)
