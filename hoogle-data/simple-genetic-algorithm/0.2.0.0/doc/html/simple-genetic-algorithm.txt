-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple parallel genetic algorithm implementation
--   
--   Simple parallel genetic algorithm implementation
@package simple-genetic-algorithm
@version 0.2.0.0


-- | Simple parallel genetic algorithm implementation.
--   
--   <pre>
--   import AI.GeneticAlgorithm.Simple
--   import System.Random
--   import Text.Printf
--   import Data.List as L
--   import Control.DeepSeq
--   
--   newtype SinInt = SinInt [Double]
--   
--   instance NFData SinInt where
--       rnf (SinInt xs) = rnf xs `seq` ()
--   
--   instance Show SinInt where
--       show (SinInt []) = "&lt;empty SinInt&gt;"
--       show (SinInt (x:xs)) =
--           let start = printf "%.5f" x
--               end = concat $ zipWith (\c p -&gt; printf "%+.5f" c ++ "X^" ++ show p) xs [1 :: Int ..]
--           in start ++ end
--   
--   polynomialOrder = 4 :: Int
--   
--   err :: SinInt -&gt; Double
--   err (SinInt xs) =
--       let f x = snd $ L.foldl' (\(mlt,s) coeff -&gt; (mlt*x, s + coeff*mlt)) (1,0) xs
--       in maximum [ abs $ sin x - f x | x &lt;- [0.0,0.001 .. pi/2]]
--   
--   instance Chromosome SinInt where
--       crossover g (SinInt xs) (SinInt ys) =
--           ( [ SinInt (L.zipWith (\x y -&gt; (x+y)/2) xs ys) ], g)
--   
--       mutation g (SinInt xs) =
--           let (idx, g') = randomR (0, length xs - 1) g
--               (dx, g'') = randomR (-10.0, 10.0) g'
--               t = xs !! idx
--               xs' = take idx xs ++ [t + t*dx] ++ drop (idx+1) xs
--           in (SinInt xs', g'')
--   
--       fitness int =
--           let max_err = 1000.0 in
--           max_err - (min (err int) max_err)
--   
--   randomSinInt gen = 
--       let (lst, gen') =
--               L.foldl'
--                   (\(xs, g) _ -&gt; let (x, g') = randomR (-10.0,10.0) g in (x:xs,g') )
--                   ([], gen) [0..polynomialOrder]
--       in (SinInt lst, gen')
--   
--   stopf :: SinInt -&gt; Int -&gt; IO Bool
--   stopf best gnum = do
--       let e = err best
--       _ &lt;- printf "Generation: %02d, Error: %.8f\n" gnum e
--       return $ e &lt; 0.0002 || gnum &gt; 20
--   
--   main = do
--       int &lt;- runGAIO 64 0.1 randomSinInt stopf
--       putStrLn ""
--       putStrLn $ "Result: " ++ show int
--   </pre>
module AI.GeneticAlgorithm.Simple

-- | Chromosome interface
class NFData a => Chromosome a
crossover :: (Chromosome a, RandomGen g) => g -> a -> a -> ([a], g)
mutation :: (Chromosome a, RandomGen g) => g -> a -> (a, g)
fitness :: Chromosome a => a -> Double

-- | Pure GA implementation.
runGA :: (RandomGen g, Chromosome a) => g -> Int -> Double -> (g -> (a, g)) -> (a -> Int -> Bool) -> a

-- | Non-pure GA implementation.
runGAIO :: Chromosome a => Int -> Double -> (StdGen -> (a, StdGen)) -> (a -> Int -> IO Bool) -> IO a

-- | Generate zero generation. Use this function only if you are going to
--   implement your own runGA.
zeroGeneration :: RandomGen g => g -> (g -> (a, g)) -> Int -> ([a], g)

-- | Generate next generation (in parallel) using mutation and crossover.
--   Use this function only if you are going to implement your own runGA.
nextGeneration :: (RandomGen g, Chromosome a) => g -> [a] -> Int -> Double -> ([a], g)
