-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | alternative parser for the tagsoup package
--   
--   TagSoup is a package for parsing and extracting information from
--   (possibly malformed) HTML/XHTML documents. Here I present my own
--   parser, which I find (of course) more comprehensible and easier to
--   extend. It also handles XML declarations and CDATA sections correctly.
--   This package is abandoned and will be renamed to Tagchup.
@package tagsoup-ht
@version 0.3

module Text.HTML.TagSoup.HT.Tag

-- | An HTML element, a document is <tt>[T]</tt>. There is no requirement
--   for <a>Open</a> and <a>Close</a> to match.
--   
--   The type parameter <tt>string</tt> lets you choose between
--   <tt>[Char]</tt> for interpreted HTML entity references and
--   <tt>[HTMLChar.T]</tt> for uninterpreted HTML entities. You will most
--   oftenly want plain <tt>Char</tt>, since <tt>HTMLChar.T</tt> is only
--   necessary if you want to know, whether a non-ASCII character was
--   encoded as HTML entity or as non-ASCII Unicode character.
data T name string

-- | An open tag with <a>T</a>s in their original order.
Open :: (Name name) -> [T name string] -> T name string

-- | A closing tag
Close :: (Name name) -> T name string

-- | A text node, guaranteed not to be the empty string
Text :: string -> T name string

-- | A comment
Comment :: String -> T name string

-- | A tag like <tt>&lt;!DOCTYPE ...&gt;</tt>
Special :: (Name name) -> String -> T name string

-- | A tag like <tt>&lt;?xml ...&gt;</tt>
Processing :: (Name name) -> (T name string) -> T name string

-- | Mark a syntax error in the input file
Warning :: String -> T name string
newtype Name ident :: * -> *
Name :: ident -> Name ident
mapName :: (name0 -> name1) -> T name0 string -> T name1 string

-- | Test if a <a>T</a> is a <a>Open</a>
isOpen :: T name string -> Bool
maybeOpen :: T name string -> Maybe (Name name, [T name string])

-- | Test if a <a>T</a> is a <a>Close</a>
isClose :: T name string -> Bool
maybeClose :: T name string -> Maybe (Name name)

-- | Test if a <a>T</a> is a <a>Text</a>
isText :: T name string -> Bool

-- | Extract the string from within <a>Text</a>, otherwise <a>Nothing</a>
maybeText :: T name string -> Maybe string

-- | Extract all text content from tags (similar to Verbatim found in
--   HaXml)
innerText :: (Monoid string) => [T name string] -> string
isComment :: T name string -> Bool
maybeComment :: T name string -> Maybe String
isSpecial :: T name string -> Bool
maybeSpecial :: T name string -> Maybe (Name name, String)
isCData :: (Eq name, Tag name) => T name string -> Bool
maybeCData :: (Eq name, Tag name) => T name string -> Maybe String
isProcessing :: T name string -> Bool
maybeProcessing :: T name string -> Maybe (Name name, T name string)
isWarning :: T name string -> Bool
maybeWarning :: T name string -> Maybe String
formatOpen :: (Tag name, Attribute name, C string) => Bool -> Name name -> [T name string] -> ShowS
formatClose :: (Tag name) => Name name -> ShowS

-- | Replace CDATA sections by plain text.
textFromCData :: (Eq name, Tag name) => T name String -> T name String

-- | Merge adjacent Text sections.
concatTexts :: (Monoid string) => [T name string] -> [T name string]

-- | Modify content of a Text or a CDATA part.
mapText :: (Eq name, Tag name) => (String -> String) -> T name String -> T name String
mapTextA :: (Eq name, Tag name, Applicative f) => (String -> f String) -> T name String -> f (T name String)
instance (Show name, Show string, Attribute name) => Show (T name string)
instance (Eq name, Eq string) => Eq (T name string)
instance (Ord name, Ord string) => Ord (T name string)
instance (Eq name, Tag name, Attribute name, C string) => C (T name string)
instance Traversable (T name)
instance Foldable (T name)
instance Functor (T name)

module Text.HTML.TagSoup.HT.PositionTag
data T name string
Cons :: T -> T name string -> T name string
position_ :: T name string -> T
tag_ :: T name string -> T name string
cons :: T -> T name string -> T name string
position :: T (T name string) T
tag :: T (T name string) (T name string)
lift :: (T name0 string0 -> T name1 string1) -> (T name0 string0 -> T name1 string1)
textFromCData :: (Eq name, Tag name) => T name String -> T name String

-- | Merge adjacent Text sections.
concatTexts :: (Monoid string) => [T name string] -> [T name string]
instance Traversable (T name)
instance Foldable (T name)
instance Functor (T name)
instance (Attribute name, Show string, Show name) => Show (T name string)


-- | Convert a tag soup to its text representation respecting various
--   conventions for merging open and close tags.
module Text.HTML.TagSoup.HT.Format

-- | All tags are formatted as they are.
xml :: (Eq name, Tag name, Attribute name, C string) => [T name string] -> ShowS

-- | Adjacent corresponding open and close tags are merged to a
--   self-closing tag. E.g. <tt><a>a&gt;&lt;/a&gt;@ becomes
--   @&lt;a/</a></tt>.
xmlCondensed :: (Eq name, Tag name, Attribute name, C string) => [T name string] -> ShowS

-- | All tags that are defined being self-closing by the HTML standard are
--   formatted only as open tag. E.g. <tt><a>br</a></tt>.
html :: (Ord name, Tag name, Attribute name, C string) => [T name string] -> ShowS

-- | All tags that are defined being self-closing by the XHTML standard are
--   formatted as self-closing open tag. E.g. <tt><a>br/</a></tt>.
xhtml :: (Ord name, Tag name, Attribute name, C string) => [T name string] -> ShowS

-- | If the first tag is <tt><a>?xml ...?</a></tt> then format in XHTML
--   style, else in HTML style.
htmlOrXhtml :: (Ord name, Tag name, Attribute name, C string) => [T name string] -> ShowS

module Text.HTML.TagSoup.HT.Tag.Match
ignore :: a -> Bool

-- | match an opening tag
open :: (Name name -> Bool) -> ([T name string] -> Bool) -> T name string -> Bool

-- | match an closing tag
close :: (Name name -> Bool) -> T name string -> Bool

-- | match a text
text :: (string -> Bool) -> T name string -> Bool
comment :: (String -> Bool) -> T name string -> Bool
special :: (Name name -> Bool) -> (String -> Bool) -> T name string -> Bool

-- | match a opening tag's name literally
openLit :: (Eq name, Tag name) => String -> ([T name string] -> Bool) -> T name string -> Bool

-- | match a closing tag's name literally
closeLit :: (Eq name, Tag name) => String -> T name string -> Bool
openAttrLit :: (Eq name, Attribute name, Tag name, Eq string) => String -> String -> string -> T name string -> Bool

-- | Match a tag with given name, that contains an attribute with given
--   name, that satisfies a predicate. If an attribute occurs multiple
--   times, all occurrences are checked.
openAttrNameLit :: (Eq name, Attribute name, Tag name) => String -> String -> (string -> Bool) -> T name string -> Bool

-- | Check if the <a>T</a> is <a>Open</a> and matches the given name
openNameLit :: (Eq name, Tag name) => String -> T name string -> Bool

-- | Check if the <a>T</a> is <a>Close</a> and matches the given name
closeNameLit :: (Eq name, Tag name) => String -> T name string -> Bool

module Text.HTML.TagSoup.HT.Process
findMetaEncoding :: (Tag name, Attribute name, Eq name) => [T name String] -> Maybe String

-- | Extract META tags which contain HTTP-EQUIV attribute and present these
--   values like HTTP headers.
getMetaHTTPHeaders :: (Tag name, Attribute name, Eq name) => [T name string] -> [(string, string)]
getHeadTags :: (Tag name, Attribute name, Eq name) => [T name string] -> [T name string]

-- | Modify attributes and tags of certain parts. For limitations, see
--   <a>parts</a>.
partAttrs :: (Eq name) => (Name name -> Bool) -> (([T name string], [T name string]) -> ([T name string], [T name string])) -> [T name string] -> [T name string]

-- | Extract parts from the tag soup that are enclosed in corresponding
--   open and close tags. If a close tag is missing, the soup end is
--   considered as end of the part. However nested tags are not supported,
--   e.g. in <tt><a>a&gt;&lt;a&gt;&lt;/a&gt;&lt;/a&gt;@ the second
--   @&lt;a</a></tt> is considered to be enclosed in the first
--   <tt><a>a&gt;@ and the first @&lt;/a</a></tt> and the second
--   <tt><a>/a</a></tt> is ignored.
parts :: (Eq name) => (Name name -> Bool) -> [T name string] -> [Either ((Name name, [T name string]), [T name string]) [T name string]]


-- | This is a tag soup parser with a custom tag data structure.
--   
--   The parser works only on proper Unicode texts, that is, you must have
--   decoded it before, e.g. using decoding functions from hxt or encoding
--   package.
module Text.HTML.TagSoup.HT.Parser
class CharType char

-- | Like <a>runSoupWithPositions</a> but hides source file positions.
runSoup :: (C source, StringType sink, Attribute name, Tag name, Eq name) => source -> [T name sink]

-- | Parse an HTML document to a list of <a>T</a>. Automatically expands
--   out escape characters.
runSoupWithPositions :: (C source, StringType sink, Attribute name, Tag name, Eq name) => source -> [T name sink]
runSoupWithPositionsName :: (C source, StringType sink, Attribute name, Tag name, Eq name) => FilePath -> source -> [T name sink]

-- | Parse a single tag, throws an error if there is a syntax error. This
--   is useful for parsing a match pattern.
runTag :: (C source, StringType sink, Show sink, Attribute name, Tag name, Eq name, Show name) => source -> T name sink

-- | Parse the inner of a single tag. That is, <tt>runTag
--   "&lt;bla&gt;"</tt> is the same as <tt>runInnerOfTag
--   "&lt;bla&gt;"</tt>.
runInnerOfTag :: (StringType sink, Show sink, Attribute name, Tag name, Eq name, Show name) => String -> T name sink
instance (CharType char) => StringType [char]
instance CharType T
instance CharType Char


-- | This parser emits the data structure of the original tagsoup package
--   by Neil Mitchell.
module Text.HTML.TagSoup.HT.ParserNM
runSoup :: String -> [Tag]
