-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package lambdaBase
@version 0.0.2.0


module Language.LambdaBase.Core

-- | Evaluation scheme, Lazy or Strict
data EVS
Lazy :: EVS
Strict :: EVS

-- | Lambda argument
data Arg
Arg :: !String -> !EVS -> Arg

-- | Infix <i> Prefix </i> LateInfix
--   
--   The LateInfix is a trick used is the eval function.
data Fix
Infix :: Fix
Prefix :: Fix
LateInfix :: Fix

-- | A name is a 'to be' literal In a programme, foo can be a name ( if it
--   is not a lambda argument ). "foo" is also a name but is delimited by
--   double quotes.
data NameType
Naked :: NameType
Delimited :: String -> String -> NameType

-- | An expression of host language a.
data Expr a
Lambda :: !Arg -> !(Expr a) -> !Fix -> Expr a
Expr :: ![Expr a] -> !Fix -> Expr a
Name :: !String -> !NameType -> !Fix -> Expr a
Lit :: !a -> !Fix -> Expr a

-- | Crappy show instance ;(

-- | The Lit class is for the language contained inside lambdaBase.
--   
--   toLit sould take a Name and transform it to a literal of its language.
--   
--   apply is for function application.
--   
--   A programme
--   
--   <pre>
--   add 123 321
--   </pre>
--   
--   will be evaluated by transforming add to a literal.
--   
--   Transforming 123 to a literal.
--   
--   Partially apply add and 123 with the apply function.
--   
--   Transforming 321 to a literal.
--   
--   Apply the "add123" literal and the 321 literal.
--   
--   And if the Lit instance is correct, the result should be a 444
--   literal.
--   
--   See lambdaLit for an example of a Lit instance.
class Lit a
apply :: Lit a => a -> a -> Expr a
fromExpr :: Lit a => Expr a -> a
toLit :: Lit a => Expr a -> Maybe a
getEVS :: Lit a => a -> EVS
instance Show EVS
instance Eq EVS
instance Show Arg
instance Eq Arg
instance Eq Fix
instance Show Fix
instance Eq NameType
instance Show NameType
instance Show a => Show (Expr a)


-- | All you need to parse lambdaBase.
module Language.LambdaBase.Parser

-- | Easy function to parse a string.
parseExpr :: String -> Either ParseError (Expr a)

-- | Parse a valid name
name :: ParsecT [Char] u Identity [Char]

-- | What is a valid char for an operator.
operatorChars :: [Char]

-- | Will be infix if the string is an operator
fixityOf :: String -> Fix


-- | This module is for evaluation of lambdaBase programmes after parsing
--   (see the eval function).
--   
--   The language is simple. There is 2 <tt>thing</tt> : lambda and
--   literals. Lambda are in the form :
--   
--   <pre>
--   \x -&gt; x y z ...
--   </pre>
--   
--   Lambda have only one argument. If you want a multi argument function
--   you can nest lambdas like this :
--   
--   <pre>
--   \x -&gt; \y -&gt; x + y
--   </pre>
--   
--   This mean partial application on lambda is possible.
--   
--   In a programme like "add 123 321" lambdaBase cant execute the add
--   function since it doesn't know what it is. In this case, the toLit
--   function of the Lit class is called. In the presence of "add 123 321"
--   the first 2 tokens ( add and 123 ) will be converted to member of the
--   Lit class an reduced with the apply function.
--   
--   To step to reducing "add 123 321" will be:
--   
--   <pre>
--   add 123 321
--   (toLit add) 123 321
--   (litAdd) (toLit 123) 321
--   (apply lit lit123) 321
--   litAdd123 321
--   litAdd123_321
--   lit444
--   </pre>
--   
--   For an example of an emplementation of the Lit class, see the
--   LambdaLit packaged.
--   
--   By default lambdas are strict in it argument. If you want a lazy one (
--   to define an if function for example ) you can using a ~ like this :
--   
--   <pre>
--   (\x ~&gt; x) -- lazy
--   (\x -&gt; x) -- strict
--   </pre>
--   
--   An if function (lazy on everything but the condition) would look like
--   this :
--   
--   <pre>
--   (\if -&gt; \True -&gt; \False -&gt; if True 123 321) (\c -&gt; \b1 ~&gt; \b2 ~&gt; c b1 b2) (\b1 ~&gt; \b2 ~&gt; b1) (\b1 ~&gt; \b2 ~&gt; b2)
--   </pre>
module Language.LambdaBase.Eval

-- | Reduce an expression. Can return an expression if it can't be reduced
--   more. Ex :
--   
--   <pre>
--   (\x -&gt; x) (\x -&gt; x)
--   </pre>
--   
--   This will reduce to :
--   
--   <pre>
--   (\x -&gt; x)
--   </pre>
--   
--   Since it can't be reduced more.
eval :: (Lit a, Show a, Eq a) => Expr a -> Expr a

-- | Set Prefix<i>Infix</i>LateFix on an expression
setFix :: Expr a -> Fix -> Expr a

-- | Take en expression, a from and a to and replace all from by to and
--   return the new expression.
substituteInExpr :: (Lit a, Show a, Eq a) => Expr a -> Expr a -> Expr a -> Expr a
