-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskeline wrapper for GHCi-like REPL interfaces.
--   
@package repline
@version 0.1.4.0


-- | Repline exposes an additional monad transformer on top of Haskeline
--   called <a>HaskelineT</a>. It simplifies several aspects of composing
--   Haskeline with State and Exception monads in modern versions of mtl.
--   
--   <pre>
--   type Repl a = HaskelineT IO a
--   </pre>
--   
--   The evaluator <a>evalRepl</a> evaluates a <a>HaskelineT</a> monad
--   transformer by constructing a shell with several custom functions and
--   evaluating it inside of IO:
--   
--   <ul>
--   <li>Commands: Handled on ordinary input.</li>
--   <li>Completions: Handled when tab key is pressed.</li>
--   <li>Options: Handled when a command prefixed by a colon is
--   entered.</li>
--   <li>Banner: Text Displayed at initialization.</li>
--   <li>Initializer: Run at initialization.</li>
--   </ul>
--   
--   A simple evaluation function might simply echo the output back to the
--   screen.
--   
--   <pre>
--   -- Evaluation : handle each line user inputs
--   cmd :: String -&gt; Repl ()
--   cmd input = liftIO $ print input
--   </pre>
--   
--   Several tab completion options are available, the most common is the
--   <a>WordCompleter</a> which completes on single words separated by
--   spaces from a list of matches. The internal logic can be whatever is
--   required and can also access a StateT instance to query application
--   state.
--   
--   <pre>
--   -- Tab Completion: return a completion for partial words entered
--   completer :: Monad m =&gt; WordCompleter m
--   completer n = do
--     let names = ["kirk", "spock", "mccoy"]
--     return $ filter (isPrefixOf n) names
--   </pre>
--   
--   Input which is prefixed by a colon (commands like ":type" and ":help")
--   queries an association list of functions which map to custom logic.
--   The function takes a space-separated list of augments in it's first
--   argument. If the entire line is desired then the <a>unwords</a>
--   function can be used to concatenate.
--   
--   <pre>
--   -- Commands
--   help :: [String] -&gt; Repl ()
--   help args = liftIO $ print $ "Help: " ++ show args
--   
--   say :: [String] -&gt; Repl ()
--   say args = do
--     _ &lt;- liftIO $ system $ "cowsay" ++ " " ++ (unwords args)
--     return ()
--   </pre>
--   
--   Now we need only map these functions to their commands.
--   
--   <pre>
--   options :: [(String, [String] -&gt; Repl ())]
--   options = [
--       ("help", help)  -- :help
--     , ("say", say)    -- :say
--     ]
--   </pre>
--   
--   The banner function is simply an IO action that is called at the start
--   of the shell.
--   
--   <pre>
--   ini :: Repl ()
--   ini = liftIO $ putStrLn "Welcome!"
--   </pre>
--   
--   Putting it all together we have a little shell.
--   
--   <pre>
--   main :: IO ()
--   main = evalRepl "&gt;&gt;&gt; " cmd options (Word completer) ini
--   </pre>
--   
--   Putting this in a file we can test out our cow-trek shell.
--   
--   <pre>
--   $ runhaskell Main.hs
--   Welcome!
--   &gt;&gt;&gt; &lt;TAB&gt;
--   kirk spock mccoy
--   
--   &gt;&gt;&gt; k&lt;TAB&gt;
--   kirk
--   
--   &gt;&gt;&gt; spam
--   "spam"
--   
--   &gt;&gt;&gt; :say Hello Haskell
--    _______________
--   &lt; Hello Haskell &gt;
--    ---------------
--           \   ^__^
--            \  (oo)\_______
--               (__)\       )\/\
--                   ||----w |
--                   ||     ||
--   </pre>
--   
--   See <a>https://github.com/sdiehl/repline</a> for more examples.
module System.Console.Repline
data HaskelineT (m :: * -> *) a
runHaskelineT :: MonadException m => Settings m -> HaskelineT m a -> m a
type Cmd m = [String] -> m ()
type Options m = [(String, Cmd m)]
type WordCompleter m = String -> m [String]
type LineCompleter m = String -> String -> m [Completion]
data CompleterStyle m

-- | Completion function takes single word.
Word :: (WordCompleter m) -> CompleterStyle m

-- | Completion function takes single word ( no space ).
Word0 :: (WordCompleter m) -> CompleterStyle m

-- | Completion function takes tuple of full line.
Cursor :: (LineCompleter m) -> CompleterStyle m

-- | Completion function completes files in CWD.
File :: CompleterStyle m

-- | Conditional tab completion based on prefix.
Prefix :: (CompletionFunc m) -> [(String, CompletionFunc m)] -> CompleterStyle m
type Command m = String -> m ()

-- | Performs completions from the given line state.
--   
--   The first <a>String</a> argument is the contents of the line to the
--   left of the cursor, reversed. The second <a>String</a> argument is the
--   contents of the line to the right of the cursor.
--   
--   The output <a>String</a> is the unused portion of the left half of the
--   line, reversed.
type CompletionFunc (m :: * -> *) = (String, String) -> m (String, [Completion])
wordCompleter :: Monad m => WordCompleter m -> CompletionFunc m
listCompleter :: Monad m => [String] -> CompletionFunc m
fileCompleter :: MonadIO m => CompletionFunc m
listWordCompleter :: Monad m => [String] -> WordCompleter m
runMatcher :: Monad m => [(String, CompletionFunc m)] -> CompletionFunc m -> CompletionFunc m

-- | Evaluate the REPL logic into a MonadException context.
evalRepl :: MonadException m => String -> Command (HaskelineT m) -> Options (HaskelineT m) -> CompleterStyle m -> HaskelineT m a -> m ()

-- | Abort the current REPL loop, and continue.
abort :: MonadIO m => HaskelineT m a
trimComplete :: String -> Completion -> Completion
instance Monad m => Monad (HaskelineT m)
instance Monad m => Functor (HaskelineT m)
instance Monad m => Applicative (HaskelineT m)
instance MonadIO m => MonadIO (HaskelineT m)
instance MonadException m => MonadException (HaskelineT m)
instance MonadTrans HaskelineT
instance MonadException m => MonadHaskeline (HaskelineT m)
instance MonadHaskeline m => MonadHaskeline (StateT s m)
instance MonadState s m => MonadState s (HaskelineT m)
instance MonadException m => MonadHaskeline (InputT m)
