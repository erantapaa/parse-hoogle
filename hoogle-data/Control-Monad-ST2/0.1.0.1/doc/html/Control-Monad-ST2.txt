-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A variation on the ST monad with two type parameters.
--   
--   The ST2 monad is like the ST monad, but with finer-grained control
--   over access to mutable state. The phantom type parameters r and w are
--   used to track the read and write dependencies of the computation. If a
--   computation of type ST2 r w a is polymorphic in w then it does not
--   write any external state. If it is also polymorphic in r then it does
--   not read any external state.
@package Control-Monad-ST2
@version 0.1.0.1


-- | The <a>ST2</a> monad is like the <a>ST</a> monad, but with
--   finer-grained control over access to mutable state. The phantom type
--   parameters <tt>r</tt> and <tt>w</tt> are used to track the read and
--   write dependencies of the computation. If a computation of type
--   <tt><a>ST2</a> r w a</tt> is polymorphic in w then it does not write
--   any external state. If it is also polymorphic in <tt>r</tt> then it
--   does not read any external state. Operations which modify state, such
--   as <a>writeST2Ref</a>, are considered to read external state as well
--   as write it, so it is impossible for a computation of type
--   <tt><a>ST2</a> r w a</tt> to be polymorphic in <tt>r</tt> but not in
--   <tt>w</tt>. This means that the <tt>r</tt> type parameter behaves
--   exactly like the <tt>s</tt> type parameter on the <a>ST</a> monad, but
--   the <tt>w</tt> type parameter provides extra information which is not
--   available in the <a>ST</a> monad.
--   
--   Like the <a>ST</a> monad, the <a>ST2</a> monad allows mutable
--   references and arrays to be created, read, and written within a
--   computation. Provided that the mutable state does not escape, it does
--   not affect the type signature of the top-level computation.
module Control.Monad.ST2

-- | The <a>ST2</a> monad is a newtype of <a>IO</a>. The type parameters
--   <tt>r</tt> and <tt>w</tt> are phantom type parameters which are used
--   to track the read and write dependencies of the computation.
data ST2 r w a

-- | This function checks that the sub-computation is polymorphic in both
--   type parameters. This means that the sub-computation does not read or
--   write any state from the enclosing context.
pureST2 :: (forall r w. ST2 r w a) -> ST2 r' w' a

-- | <a>runPureST2</a> is semantically equivalent to pureST2, but uses a
--   newtype to package the <tt>forall</tt>. Sometimes this packaging is
--   convenient when passing a value of type <a>PureST2</a> as an argument
--   because it avoids the need for a nested <tt>forall</tt> in the type
--   signature.
newtype PureST2 a
PureST2 :: (forall r w. ST2 r w a) -> PureST2 a
runPureST2 :: PureST2 a -> forall r w. ST2 r w a

-- | This function checks that the sub-computation is polymorphic in the
--   <tt>w</tt> type parameter. This means that the sub-computation does
--   not write any state from the enclosing context (but read-only
--   operations are permitted).
readOnlyST2 :: (forall w. ST2 r w a) -> ST2 r w' a

-- | <a>runReadOnlyST2</a> is semantically equivalent to readOnlyST2, but
--   uses a newtype to package the <tt>forall</tt>. Sometimes this
--   packaging is convenient when passing a value of type
--   <a>ReadOnlyST2</a> as an argument because it avoids the need for a
--   nested <tt>forall</tt> in the type signature.
newtype ReadOnlyST2 r a
ReadOnlyST2 :: (forall w. ST2 r w a) -> ReadOnlyST2 r a
runReadOnlyST2 :: ReadOnlyST2 r a -> forall w. ST2 r w a

-- | <a>IO</a> computations can be converted to <a>ST2</a> computations,
--   but only with a monomorphic type signature.
ioToST2 :: IO a -> ST2 () () a

-- | <a>ST2</a> computations can be converted to <a>IO</a> computations,
--   but only with a monomorphic type signature.
st2ToIO :: ST2 () () a -> IO a

-- | Mutable reference. <a>ST2Ref</a> is actually just a newtype of an
--   <a>IORef</a>, but the <tt>r</tt> and <tt>w</tt> type parameters allow
--   the read and write dependencies to be tracked by the type system.
data ST2Ref r w a

-- | Create a new reference. The <tt>r</tt> and <tt>w</tt> type parameters
--   of the reference are unified with the <a>ST2</a> monad to indicate
--   that new state is created in the enclosing context.
newST2Ref :: a -> ST2 r w (ST2Ref r w a)

-- | Read a reference. The <tt>w</tt> type parameter of the reference is
--   not unified with the <a>ST2</a> monad to indicate that this access is
--   read-only.
readST2Ref :: ST2Ref r w a -> ST2 r w' a

-- | Write to a reference. The <tt>w</tt> type parameter of the reference
--   is unified with the <a>ST2</a> monad to indicate that state is written
--   in the enclosing context.
writeST2Ref :: ST2Ref r w a -> a -> ST2 r w ()

-- | Modify a reference.
modifyST2Ref :: ST2Ref r w a -> (a -> a) -> ST2 r w ()

-- | Convert an IORef to an ST2Ref.
importST2Ref :: IORef a -> ST2Ref () () a

-- | Convert an ST2Ref to an IORef.
exportST2Ref :: ST2Ref () () a -> IORef a

-- | Mutable array. <a>ST2Array</a> is actually just a newtype of an
--   <a>IOArray</a>, but the <tt>r</tt> and <tt>w</tt> type parameters
--   allow the read and write dependencies to be tracked by the type
--   system.
data ST2Array r w i a

-- | Create an array with an initial value.
newST2Array :: Ix i => (i, i) -> a -> ST2 r w (ST2Array r w i a)

-- | Create an uninitialised array.
newST2Array_ :: Ix i => (i, i) -> ST2 r w (ST2Array r w i a)

-- | Read an index of the array. The <tt>w</tt> type parameter of the
--   reference is not unified with the <a>ST2</a> monad to indicate that
--   this access is read-only.
readST2Array :: Ix i => ST2Array r w i a -> i -> ST2 r w' a

-- | Write an index of the array. The <tt>w</tt> type parameter of the
--   array is unified with the <a>ST2</a> monad to indicate that state is
--   written in the enclosing context.
writeST2Array :: Ix i => ST2Array r w i a -> i -> a -> ST2 r w ()

-- | Read the size of the array. Neither type parameter is unified with the
--   <a>ST2</a> monad because the array itself is not accessed.
--   (Conceptually, an <a>ST2Array</a> is a pair, consisting of the size
--   information and the array. This function only accesses the size
--   information, which is immutable.)
boundsST2Array :: Ix i => ST2Array r w i a -> ST2 r' w' (i, i)

-- | Convert an IOArray to an ST2Array.
importST2Array :: IOArray i a -> ST2Array () () i a

-- | Convert an ST2Array to an IOArray.
exportST2Array :: ST2Array () () i a -> IOArray i a

-- | Read-only array. Existential quantification is used to hide the
--   <tt>w</tt> type parameter. This means that it can escape a
--   <a>ReadOnlyST2</a> context, and can be read in the enclosing context.
--   However, it is impossible for anyone to write to the array outside of
--   the <a>ReadOnlyST2</a> context in which the array was created.
data ST2RArray r i a

-- | Create a read-only array. It is important to note that this function
--   does not make the original <a>ST2Array</a> immutable. It merely
--   creates a read-only reference to the original array. However, the
--   <a>ST2RArray</a> can be returned through a <a>readOnlyST2</a> or
--   <a>ReadOnlyST2</a> context and the typing rules ensure that the
--   original <a>ST2Array</a> cannot be modified outside of the
--   <a>ReadOnlyST2</a> context in which it was created. In other words,
--   the original <a>ST2Array</a> can continue to be modified after the
--   <a>ST2RArray</a> is created, but only until the <a>ST2RArray</a> is
--   returned through a <a>ReadOnlyST2</a> context.
mkST2RArray :: ST2Array r w i a -> ST2RArray r i a

-- | Read an index of the read-only array.
readST2RArray :: Ix i => ST2RArray r i a -> i -> ST2 r w a

-- | Spawn one thread for each index in the range and wait for all the
--   threads to finish. Each thread is parameterised by its index, which is
--   an element of the range.
parallelST2 :: Ix i => (i, i) -> (i -> ST2 r w ()) -> ST2 r w ()
instance [safe] Functor (ST2 r w)
instance [safe] Monad (ST2 r w)
