-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A polymorphic, POSIX, extended regex-engine.
--   
@package regexdot
@version 0.11.1.1


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Defines those options relating to the
--   <a>RegExDot.RegEx</a>-runtime.</li>
--   <li>These tend to be options which don't affect the result, only the
--   means by which it is achieved.</li>
--   <li>Whilst similar structures are present in other
--   regex-implementations, there's no standardisation of the fields.</li>
--   </ul>
module RegExDot.ExecutionOptions

-- | The switches used to control execution of the <i>regex</i>-engine.
data ExecutionOptions
MkExecutionOptions :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> ExecutionOptions

-- | If an <i>alternative</i> can't match, irrespective of the subsequent
--   <i>RegExDot.RegEx.Concatenation</i>, then avoid futile trial
--   <i>RegExDot.Repeatable.Repetitions</i>. The converse of
--   <a>checkForUnconsumableData</a>.
abortTrialRepetitionsOnInherentFailure :: ExecutionOptions -> Bool

-- | Check for zero data-consumption by the <tt>n</tt>-th
--   <i>RegExDot.Repeatable.Repeatable RegExDot.RegEx.CaptureGroup</i>,
--   before attempting <tt>n+1</tt>.
abortTrialRepetitionsOnZeroConsumption :: ExecutionOptions -> Bool

-- | Whether to bypass reading of the input data, if the mapping to
--   specific <i>RegExDot.RegEx.RepeatablePattern</i>s isn't required,
--   &amp; the <i>RegExDot.RegEx.ExtendedRegEx</i> can consume the required
--   quantity of anything.
bypassInputDataForLiberalConsumer :: ExecutionOptions -> Bool

-- | Avoid futile trial solutions, involving repetitions of anchored
--   alternatives, which must consume data.
catchIncompatibleAnchors :: ExecutionOptions -> Bool

-- | If the <i>RegExDot.RegEx.ExtendedRegEx</i> ends in an inelastic (zero
--   <i>Star-height</i>) tail, confirm its existence at the end of the
--   <i>RegExDot.RegEx.InputData</i>.
checkExistenceOfInelasticTail :: ExecutionOptions -> Bool

-- | Check whether there's no possibility of consuming some of the input
--   data. The converse of <a>abortTrialRepetitionsOnInherentFailure</a>.
checkForUnconsumableData :: ExecutionOptions -> Bool

-- | Greedily consume data, only up to the limit beyond which, future
--   requirements would be compromised.
moderateGreed :: ExecutionOptions -> Bool

-- | Permit <i>RegExDot.RegEx.Alternatives</i> to be re-ordered, in an
--   attempt to more quickly locate a result.
permitReorderingOfAlternatives :: ExecutionOptions -> Bool

-- | Within the <i>RegExDot.RegEx.MatchedData</i> from which each candidate
--   <i>RegExDot.RegEx.Match</i> amongst sequences of
--   <i>RegExDot.RegEx.Alternatives</i>, is ultimately composed, prefer
--   <i>RegExDot.ConsumptionBounds.ConsumptionBounds</i> of
--   <i>RegExDot.RegEx.InputData</i>, beyond
--   <i>RegExDot.Repeatable.getFewest</i>, by
--   <i>RegExDot.Repeatable.isGreedy RegExDot.RegEx.RepeatablePattern</i>s.
preferAlternativesWhichFeedTheGreedy :: ExecutionOptions -> Bool

-- | Compare <i>RegExDot.ConsumptionBounds.ConsumptionBounds</i> on
--   successive <i>RegExDot.Repeatable.Repetitions</i> of
--   <i>RegExDot.RegEx.CaptureGroup</i>, between candidate
--   <i>RegExDot.RegEx.Match</i>es, to mimic the behaviour of the unrolled
--   <i>RegExDot.Repeatable.Repetitions</i>.
preferAlternativesWhichMimickUnrolling :: ExecutionOptions -> Bool

-- | Prefer fewer <i>RegExDot.Repeatable.Repetitions</i> of
--   <i>RegExDot.RegEx.Alternatives</i>, to discourage the capture of null
--   lists of <i>RegExDot.RegEx.InputData</i>.
preferFewerRepeatedAlternatives :: ExecutionOptions -> Bool

-- | If merely interested in a <a>Bool</a> result, rather than the optimal
--   mapping of input data to <i>RegExDot.RegEx.RepeatablePattern</i>s,
--   avoid unnecessary evaluation of the <i>RegEx.Match</i>.
requireMatchList :: ExecutionOptions -> Bool

-- | Check whether <i>RegExDot.RegEx.Alternatives</i> consists of just a
--   singleton <i>RegExDot.RegEx.ExtendedRegEx</i>, &amp; has therefore
--   been used merely as a capture-group. Though this doesn't affect the
--   result, it vastly improves efficiency.
unrollRepeatedSingletonAlternative :: ExecutionOptions -> Bool

-- | Rather than performing an exhaustive search for the optimal choice
--   amongst <i>RegExDot.RegEx.Alternatives</i>, merely select the first
--   that matches; conform to <i>Perl</i> rather than <i>POSIX</i>.
useFirstMatchAmongAlternatives :: ExecutionOptions -> Bool

-- | When the number of repetitions of a <i>RegExDot.RegEx.CaptureGroup</i>
--   is precisely specified, check whether the resulting minimum
--   data-requirement is available.
validateMinConsumptionOfAlternatives :: ExecutionOptions -> Bool

-- | Sets those fields which depend crucially on whether the caller wants
--   to retrieve any <i>RegExDot.RegEx.MatchList</i> from the
--   <i>RegExDot.RegEx.Result</i>, or just query whether there is one.
setVerbose :: Bool -> ExecutionOptions -> ExecutionOptions
instance Eq ExecutionOptions
instance Show ExecutionOptions
instance Options ExecutionOptions
instance Defaultable ExecutionOptions


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Defines a specific type of tree-structure, which is composed from
--   either a datum, or a list of Tree-lists;
--   <a>http://en.wikipedia.org/wiki/Rose_Tree</a>.</li>
--   <li>This more general tree-structure has the shape of a
--   regular-expression match.</li>
--   <li>This contrasts with the typical binary-tree, which is either
--   empty, or contains a (left Tree, datum, right Tree).</li>
--   </ul>
module RegExDot.Tree

-- | A general purpose tree-type structure.
data Tree a

-- | The payload.
Leaf :: a -> Tree a

-- | Recurse. NB: a list of lists is required to contain the
--   <i>MatchLists</i> resulting from repeated <i>Alternatives</i>.
Node :: [TreeList a] -> Tree a

-- | Deconstruct the specified <a>Node</a>; i.e. lop the apex from the
--   <a>Tree</a>, leaving a flat top.
pop :: Tree a -> [TreeList a]
instance Eq a => Eq (Tree a)
instance Foldable Tree
instance Functor Tree
instance NFData a => NFData (Tree a)
instance Read a => Read (Tree a)
instance Show a => Show (Tree a)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Describes the bounds of
--   data-consumption.</li>
--   </ul>
module RegExDot.ConsumptionBounds

-- | The minimum &amp; maximum bounds of potential data-consumption.
type ConsumptionBounds = (DataLength, Maybe DataLength)

-- | A measure of the quantity of an unspecified type of data.
type DataLength = Int

-- | Exactly zero consumption.
zero :: ConsumptionBounds

-- | Predicate which is <a>True</a> if only a precise quantity of data is
--   consumable; no more, no less.
isPrecise :: ConsumptionBounds -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Delimits a data-sequence, via its
--   offset &amp; length, within a wider list.</li>
--   </ul>
module RegExDot.Span

-- | <ul>
--   <li>The offset &amp; length of a specific data-sequence, within a
--   wider list.</li>
--   <li>Similar to
--   <a>http://hackage.haskell.org/packages/archive/regex-base/latest/doc/html/Text-Regex-Base-RegexLike.html#t%3AMatchArray</a>.</li>
--   </ul>
type Span = (DataLength, DataLength)

-- | Returns the furthest extent, i.e. the offset just after the end.
after :: Span -> DataLength

-- | An empty instance, located at the specified offset.
empty :: DataLength -> Span

-- | <ul>
--   <li>Condenses a list into a single value.</li>
--   <li>Expects a gap-free, sorted list.</li>
--   </ul>
join :: DataLength -> [Span] -> Span


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Augments a <a>Span</a>, with the
--   specific data concerned.</li>
--   </ul>
module RegExDot.DataSpan

-- | <ul>
--   <li>Augment <a>Span</a> with a copy of the data to which it
--   refers.</li>
--   <li>Similar to
--   <a>http://hackage.haskell.org/packages/archive/regex-base/latest/doc/html/Text-Regex-Base-RegexLike.html#t%3AMatchText</a>.</li>
--   </ul>
type DataSpan a = ([a], Span)

-- | Returns the furthest extent, i.e. the offset just after the end.
after :: DataSpan a -> DataLength

-- | Constructs an empty instance, located at the specified offset.
empty :: DataLength -> DataSpan a

-- | <ul>
--   <li>Condenses a list into a single value.</li>
--   <li>Expects a gap-free, sorted list.</li>
--   </ul>
join :: DataLength -> [DataSpan a] -> DataSpan a


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   A <a>ConsumptionProfile</a> is composed from both a capacity to
--   consume, &amp; an ability to discriminate based on the specific data.
--   The former is described by <a>consumptionBounds</a> &amp; the latter
--   by both <a>hasSpecificRequirement</a> &amp; <a>canConsumeAnything</a>.
module RegExDot.ConsumptionProfile

-- | The <a>ConsumptionProfile</a>s of all the aggregated tails of a list
--   of <tt>Consumer</tt>s.
type AccumulatedConsumptionProfiles = [ConsumptionProfile]

-- | <ul>
--   <li>A <tt>Consumer</tt> is considered to have a
--   <a>ConsumptionProfile</a> composed from both a capacity to consume,
--   &amp; an ability to discriminate.</li>
--   <li>Whilst <a>hasSpecificRequirement</a> &amp;
--   <a>canConsumeAnything</a> look like opposites, they can assume
--   independent values; the instance can be both, but only be neither when
--   empty.</li>
--   </ul>
data ConsumptionProfile
MkConsumptionProfile :: ConsumptionBounds -> Bool -> Bool -> ConsumptionProfile

-- | The permissible quantity of data, which can be consumed.
consumptionBounds :: ConsumptionProfile -> ConsumptionBounds

-- | Whether at least one specific input datum is required.
hasSpecificRequirement :: ConsumptionProfile -> Bool

-- | Whether at least one arbitrary input datum can be consumed.
canConsumeAnything :: ConsumptionProfile -> Bool

-- | Both minimum &amp; maximum set to zero; which can be used as the
--   initial value when accumulating the sum of a list.
zero :: ConsumptionProfile

-- | Accumulate the specified list of <a>ConsumptionProfile</a>s, from the
--   specified initial value.
accumulateFrom :: ConsumptionProfile -> [ConsumptionProfile] -> AccumulatedConsumptionProfiles

-- | The aggregate of the specified concatenation of
--   <a>ConsumptionProfile</a>s.
aggregateFromConcatenation :: [ConsumptionProfile] -> ConsumptionProfile

-- | The net effect of two concatenated <a>ConsumptionProfile</a>s.
(|+|) :: ConsumptionProfile -> ConsumptionProfile -> ConsumptionProfile

-- | The net effect of two alternative <a>ConsumptionProfile</a>s.
(<>) :: ConsumptionProfile -> ConsumptionProfile -> ConsumptionProfile

-- | Predicate, which is <a>True</a> if the specified data-length, falls
--   within the specified <a>ConsumptionBounds</a>.
withinConsumptionBounds :: DataLength -> ConsumptionProfile -> Bool
instance Eq ConsumptionProfile
instance Read ConsumptionProfile
instance Show ConsumptionProfile
instance SelfValidator ConsumptionProfile


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Define the requirements &amp; capabilities of a data-type which is
--   designed to consume data.</li>
--   <li>This module also facilitates investigation of group-behaviour, by
--   defining operations on either concatenations or alternations of
--   <a>Consumer</a>s.</li>
--   <li>This module is specifically for use in a <i>regex</i>-engine, in
--   which the meta-data from which the <i>regex</i> is composed, are
--   considered to <i>consume</i> input data, whilst concatenation &amp;
--   alternation of such elements, behave as a different types of groups of
--   consumer.</li>
--   </ul>
module RegExDot.Consumer

-- | <ul>
--   <li>The interface, to which types, which have a data-requirement, may
--   conform.</li>
--   <li>Regrettably, methods requiring reference to the type of the
--   consumable, would require multi-parameter type-classes.</li>
--   <li><a>consumptionProfile</a> defines the quantity-range of data which
--   may be consumed, &amp; any specific data-requirements.</li>
--   <li><a>starHeight</a> measures the complexity of the
--   <a>Consumer</a>.</li>
--   </ul>
class Consumer c
consumptionProfile :: Consumer c => c -> ConsumptionProfile
starHeight :: Consumer c => c -> StarHeight

-- | Get the <a>ConsumptionProfile</a> for the specified list of
--   <a>Consumer</a>s, then accumulate them.
accumulateConsumptionProfiles :: Consumer c => [c] -> AccumulatedConsumptionProfiles

-- | The aggregate of the specified alternation of
--   <a>ConsumptionProfile</a>s.
aggregateConsumptionProfilesFromAlternatives :: Consumer c => [c] -> ConsumptionProfile

-- | Get the <a>ConsumptionProfile</a>s for the specified list of
--   <a>Consumer</a>s, then find the net effect of concatenating them.
aggregateConsumptionProfilesFromConcatenation :: Consumer c => [c] -> ConsumptionProfile

-- | Convenience-function, to query the <a>ConsumptionBounds</a> of a
--   <a>Consumer</a>.
getConsumptionBounds :: Consumer c => c -> ConsumptionBounds

-- | Determine the minimum acceptable quantity of data.
getFewest :: Consumer c => c -> DataLength

-- | Determine whether the specified <a>Consumer</a>, has a specific
--   requirement.
getHasSpecificRequirement :: Consumer c => c -> Bool
instance Consumer c => Consumer [c]


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>A data-type, which represents the permissible range of instances,
--   of the underlying polymorphic datum.</li>
--   <li>Designed for use in a polymorphic <i>regex</i>-engine, which
--   specifies patterns composed of repeated <i>greedy</i> &amp;
--   <i>non-greedy</i> sequences of <i>Meta</i>-data;</li>
--   </ul>
--   
--   <pre>
--   *	+	?	{fewest, most}	{fewest,}	{fewest}
--   *?	+?	??	{fewest, most}?	{fewest,}?
--   </pre>
--   
--   <ul>
--   <li>In the context of <i>regex</i>es, this concept is known as
--   <i>Quantification</i>.</li>
--   <li><i>regex</i>es evolved from the minimal ability to optionally
--   qualify the datum with a
--   <a>http://en.wikipedia.org/wiki/Kleene_star</a> suffix. More exotic
--   repetition-specifications could be composed by concatenating these
--   atomic building-blocks. Here, I've taken the contrary top-down view,
--   &amp; assumed that all data are qualified by a full
--   <a>RepetitionBounds</a>, which in most cases will degenerate into a
--   simpler form.</li>
--   <li>The type of entity which is being repeated, isn't the domain of
--   this data-type; it's polymorphic.</li>
--   </ul>
module RegExDot.Repeatable

-- | A number of repetitions.
type Repetitions = Int

-- | Defines the bounds of a range of permissible repetitions.
type RepetitionBounds = (Repetitions, Maybe Repetitions)

-- | Declares a polymorphic data-type, which augments the underlying
--   <a>base</a> datum, with the range of times it may be used.
data Repeatable a
MkRepeatable :: a -> RepetitionBounds -> Bool -> Repeatable a

-- | The underlying polymorphic datum.
base :: Repeatable a -> a

-- | The bounds delimiting the range of permissible repetitions, of
--   <a>base</a>.
repetitionBounds :: Repeatable a -> RepetitionBounds

-- | Whether to demand as many matching instances of <a>base</a> as
--   possible; or as few (AKA <i>lazy quantification</i>).
isGreedy :: Repeatable a -> Bool

-- | The token used to denote <a>oneOrMore</a>, when in the
--   <a>String</a>-form.
oneOrMoreToken :: Char

-- | The delimiters of <a>^#-&gt;#</a>, when in the <a>String</a>-form.
rangeDelimiters :: (Char, Char)

-- | The token used to separate <a>RepetitionBounds</a>, when in the
--   <a>String</a>-form.
rangeSeparatorToken :: Char

-- | The set of <a>Char</a> to which a specific meaning is attributed, when
--   reading from <a>String</a>.
tokens :: String

-- | <ul>
--   <li>The token used to denote <a>zeroOrMore</a>, when in the
--   <a>String</a>-form.</li>
--   <li>AKA <i>Kleene Star</i>.</li>
--   </ul>
zeroOrMoreToken :: Char

-- | The token used to denote <a>zeroOrOne</a>, when in the
--   <a>String</a>-form.
zeroOrOneToken :: Char

-- | <ul>
--   <li>Construct a <a>Repeatable</a>, tailored for unrepeated data.</li>
--   <li>A degenerate case of <a>^#</a>.</li>
--   </ul>
one :: a -> Repeatable a

-- | <ul>
--   <li>Construct a greedy <a>Repeatable</a>, from a polymorphic datum,
--   with lower <a>RepetitionBounds</a> == one.</li>
--   <li>A specific case of <a>^#-&gt;</a>.</li>
--   </ul>
oneOrMore :: a -> Repeatable a

-- | Construct a non-greedy version of <a>oneOrMore</a>.
oneOrMore' :: a -> Repeatable a

-- | <ul>
--   <li>Construct a greedy <a>Repeatable</a>, from a polymorphic datum,
--   with <tt>fewest</tt> == 0.</li>
--   <li>A specific case of <a>^#-&gt;</a>.</li>
--   </ul>
zeroOrMore :: a -> Repeatable a

-- | Construct a non-greedy version of <a>zeroOrMore</a>.
zeroOrMore' :: a -> Repeatable a

-- | <ul>
--   <li>Construct a greedy <a>Repeatable</a>, from a polymorphic datum,
--   with <tt>fewest</tt> == 0 &amp; <tt>most</tt> == 1.</li>
--   <li>A specific case of <a>^#-&gt;#</a>.</li>
--   </ul>
zeroOrOne :: a -> Repeatable a

-- | Construct a non-greedy version of <a>zeroOrOne</a>.
zeroOrOne' :: a -> Repeatable a

-- | Builds a parser for a specification of the number of permissible
--   instances of the specified polymorphic parameter.
repeatableParser :: a -> Parser (Repeatable a)

-- | <ul>
--   <li>A <a>ShowS</a>-function for the suffix, denoting the permissible
--   repetitions, of <a>base</a>.</li>
--   <li>This function converts the internal, into the tradition
--   <i>greedy</i> &amp; <i>non-greedy</i> quantifiers of various specific
--   varieties.</li>
--   </ul>
showSuffix :: Repeatable a -> ShowS

-- | Accessor.
getFewest :: Repeatable a -> Repetitions

-- | Accessor.
getMost :: Repeatable a -> Maybe Repetitions

-- | Reduces a <a>Repeatable</a>, with a range of <a>RepetitionBounds</a>,
--   to a precise number of repetitions.
focus :: Repeatable a -> Repetitions -> Repeatable a

-- | <ul>
--   <li>Reduces a <a>Repeatable</a>, with a range of
--   <a>RepetitionBounds</a>, to a singleton.</li>
--   <li>A degenerate case of <a>focus</a>.</li>
--   </ul>
toSingleton :: Repeatable a -> Repeatable a

-- | <ul>
--   <li>Construct a greedy <a>Repeatable</a>, from a polymorphic datum,
--   with the specified range of permissible instances.</li>
--   <li>The <i>#</i>s in the identifier represent the two bounds.</li>
--   <li><i>a{f, m}</i></li>
--   </ul>
(^#->#) :: a -> RepetitionBounds -> Repeatable a

-- | <ul>
--   <li>Construct a non-greedy version of <a>^#-&gt;#</a>.</li>
--   <li><i>a{f, m}?</i></li>
--   </ul>
(^#->#?) :: a -> RepetitionBounds -> Repeatable a

-- | <ul>
--   <li>Construct a greedy <a>Repeatable</a>, tailored for data repeated
--   at least the specified number of times.</li>
--   <li>The <i>#</i> in the identifier represents the single bound.</li>
--   <li><i>a{f,}</i></li>
--   </ul>
(^#->) :: a -> Repetitions -> Repeatable a

-- | <ul>
--   <li>Construct a non-greedy version of <a>^#-&gt;</a>.</li>
--   <li><i>a{f,}?</i></li>
--   </ul>
(^#->?) :: a -> Repetitions -> Repeatable a

-- | <ul>
--   <li>Construct a <a>Repeatable</a>, tailored for data repeated a
--   precise number of times.</li>
--   <li>The <i>#</i> in the identifier represents the single bound.</li>
--   <li><i>a{f}</i></li>
--   </ul>
(^#) :: a -> Repetitions -> Repeatable a

-- | True if there's no choice in the number of repetitions; implemented
--   via <a>isPrecise</a>.
isPrecise :: Repeatable a -> Bool

-- | Predicate which is <a>True</a> if exactly one value is permissible, ie
--   lower &amp; upper bounds on the number of <a>Repetitions</a> are
--   identical.
hasPreciseBounds :: RepetitionBounds -> Bool
instance Eq a => Eq (Repeatable a)
instance NFData a => NFData (Repeatable a)
instance SelfValidator a => SelfValidator (Repeatable a)
instance Consumer a => Consumer (Repeatable a)
instance Show a => Show (Repeatable a)
instance Read a => Read (Repeatable a)
instance Functor Repeatable


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Defines those options relating to compile-time.</li>
--   <li>These tend to be options which affect the result, rather than the
--   means by which it is achieved.</li>
--   <li>Whilst similar structures are present in other
--   regex-implementations, there's no standardisation of the fields.</li>
--   </ul>
module RegExDot.CompilationOptions

-- | The switch(es) used to control compilation of the <i>regex</i>-engine.
data CompilationOptions
MkCompilationOptions :: Bool -> CompilationOptions

-- | Define the offset of captured data, corresponding to a sub-expression
--   which matched zero times, as the artificial value <tt>-1</tt>
--   specified by POSIX.
complyStrictlyWithPosix :: CompilationOptions -> Bool
instance Eq CompilationOptions
instance Show CompilationOptions
instance Options CompilationOptions
instance Defaultable CompilationOptions


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Provides a complete job-specification.</li>
--   <li><a>regEx</a> is polymorphic, allowing use of either
--   <i>RegExDot.RegEx.ExtendedRegEx</i> (which is also polymorphic) or
--   <i>RegExChar.ExtendedRegExChar.ExtendedRegExChar</i>.</li>
--   </ul>
module RegExDot.RegExOpts

-- | Aggregates both <a>ExecutionOptions</a> &amp;
--   <a>CompilationOptions</a> with a polymorphic <i>regex</i>, to form a
--   complete job-description.
data RegExOpts a
MkRegExOpts :: CompilationOptions -> ExecutionOptions -> a -> RegExOpts a

-- | Parameters governing the result, rather than the implementation.
compilationOptions :: RegExOpts a -> CompilationOptions

-- | Parameters governing the implementation, rather than the result.
executionOptions :: RegExOpts a -> ExecutionOptions

-- | Polymorphic, to permit specialisation either of the type of
--   <i>regex</i> or the type of input-data.
regEx :: RegExOpts a -> a

-- | Mutator, which sets an appropriate <a>ExecutionOptions</a>, for the
--   depth to which the caller wants to probe the resulting match.
setVerbose :: Bool -> RegExOpts a -> RegExOpts a

-- | Smart constructor using <a>defaultValue</a>.
mkRegEx :: a -> RegExOpts a
instance Show a => Show (RegExOpts a)
instance Functor RegExOpts


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Used to implement
--   <i>Perl-shortcut</i>s, <i>BracketExpression</i>-ranges &amp; <i>POSIX
--   Character-classes</i>.</li>
--   </ul>
module RegExDot.ShowablePredicate

-- | An arbitrary polymorphic predicate function.
type Predicate a = a -> Bool

-- | Container for both the <i>predicate</i>, &amp; the name used in the
--   implementation of <a>Show</a>.
data ShowablePredicate a
MkShowablePredicate :: String -> Predicate a -> ShowablePredicate a

-- | The identifier of this predicate when in string-form.
name :: ShowablePredicate a -> String

-- | The function used to determine whether an input datum matches.
predicate :: ShowablePredicate a -> Predicate a
instance NFData (ShowablePredicate a)
instance Eq (ShowablePredicate a)
instance Show (ShowablePredicate a)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   Permits <i>Perl-style shortcut</i>s to be canned &amp; assigned a
--   single-<a>Char</a> mnemonic for subsequent reference; the
--   implementation of <a>Read</a> looks for a back-slashed <a>Char</a>,
--   for which it expects there to be a corresponding canned
--   <a>ShowablePredicate</a>.
--   
--   <ul>
--   <li><i><tt>CAVEATS</tt></i></li>
--   </ul>
--   
--   Since the underlying polymorphic data-type isn't required to implement
--   neither <a>Enum</a> nor <a>Ord</a>, the implementation of <a>Read</a>
--   can't cope with range-specifications. Lacking this, Bracket-expression
--   members must be enumerated exhaustively.
module RegExDot.BracketExpressionMember

-- | <ul>
--   <li>The interface via which <i>Perl-style shortcut</i>s are expanded
--   (when they occur within a <i>bracket-expression</i>), in a manner
--   appropriate to the chosen type-parameter.</li>
--   <li>The expansion of <i>Perl-style shortcut</i>s, is more restricted
--   inside than outside, a <i>bracket-expression</i>, &amp; consequently
--   are merely represented here by a <a>ShowablePredicate</a>, rather than
--   providing a more general form suitable also for those <i>Perl-style
--   shortcuts</i> found outside <i>bracket-expression</i>s.</li>
--   <li>This interface is implemented elsewhere, where the specific
--   type-parameter &amp; consequently the appropriate set of <i>Perl-style
--   shortcut</i>s, are defined.</li>
--   </ul>
class ShortcutExpander a
findPredicate :: ShortcutExpander a => Char -> Maybe (ShowablePredicate a)

-- | <ul>
--   <li>A <i>BracketExpression</i> can contain either a literal, a range
--   of literals given <tt>(Enum a, Ord a)</tt>, a <i>Perl-style
--   shortcut</i>, or when <a>Char</a> is the type-parameter, a <i>POSIX
--   Character-class</i>.</li>
--   <li>This data-type reduces the representation of all these
--   possibilities to either a predicate or a literal.</li>
--   </ul>
data Member m

-- | This <a>Member</a> is described using a <i>predicate</i>, which is run
--   to determine whether the datum conforms &amp; is a member of the
--   <a>BracketExpression</a>.
Predicate :: (ShowablePredicate m) -> Member m

-- | This <a>Member</a> is defined literally, using an item of the
--   polymorphic type.
Literal :: m -> Member m

-- | Match-operator.
(=~) :: Eq m => m -> Member m -> Bool
instance Eq m => Eq (Member m)
instance NFData m => NFData (Member m)
instance (ShortcutExpander m, Read m) => Read (Member m)
instance Show m => Show (Member m)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   This concept was traditionally known as a <i>Character-class</i>, but
--   to distinguish it from the more recently introduced &amp; narrower
--   <i>POSIX Character-class</i>, it has been renamed
--   <i>Bracket-expression</i>.
module RegExDot.BracketExpression

-- | A <i>Bracket-expression</i> consists of a list of <a>Member</a>s.
type BracketExpression m = [Member m]

-- | The delimiters of a <i>bracket-expression</i>, when in
--   <a>String</a>-form.
delimiterTokens :: (Char, Char)

-- | Used to denote a negated <i>bracket-expression</i>, when in
--   <a>String</a>-form.
negationToken :: Char

-- | The set of <a>Char</a> to which a specific meaning is attributed, when
--   reading from <a>String</a>.
tokens :: String

-- | True if the specified datum matches any <a>Member</a> of the
--   <a>BracketExpression</a>.
containsMatch :: Eq m => m -> BracketExpression m -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Describes the set of polymorphic data, which can be matched.</li>
--   <li>Only permits a match against exactly one polymorphic datum, which
--   distinguishes it from a <i>zero-width assertion</i>, like an
--   <i>anchor</i>, <i>word-boundary</i>, or <i>look-ahead
--   assertion</i>.</li>
--   <li>Designed to be used by a polymorphic <i>regex</i>-engine, to
--   implement the traditional meta-characters; <tt>. [] [^]</tt>.</li>
--   <li>Permits <i>Perl-style shortcuts</i> for commonly used
--   <a>Meta</a>-data, to be canned &amp; assigned a single-<a>Char</a>
--   mnemonic for subsequent reference; the implementation of <a>Read</a>
--   looks for a back-slashed <a>Char</a>, for which it expects there to be
--   a corresponding canned <a>Meta</a>. Since this class is polymorphic,
--   it has no knowledge of what shortcuts might be appropriate for the
--   chosen type-parameter, so the expansion from the back-slashed
--   <a>Char</a> to corresponding <a>Meta</a>-data, is performed through
--   the <a>expand</a> interface of the <a>ShortcutExpander</a> class,
--   which should be implemented elsewhere.</li>
--   </ul>
module RegExDot.Meta

-- | <ul>
--   <li>The interface via which <i>Perl-style shortcut</i>s are expanded,
--   in a manner appropriate to the chosen type-parameter.</li>
--   <li>Since the expansion of <i>Perl-style shortcut</i>s, is more
--   restricted inside than outside a <a>BracketExpression</a>, the former
--   is considered to be a superclass, providing a base from which to build
--   alternative implementations.</li>
--   </ul>
class ShortcutExpander m => ShortcutExpander m
expand :: ShortcutExpander m => Char -> Meta m

-- | Declares a polymorphic data-type.
data Meta m

-- | Any datum matches. Equivalent to <tt>NoneOf []</tt>, but more
--   efficient. CAVEAT: independent of the type-parameter <tt>a</tt>.
Any :: Meta m

-- | The datum matches, if it's equal to the specified value. Equivalent to
--   <tt>AnyOf [BracketExpression.Literal x]</tt>, but more efficient.
Literal :: m -> Meta m

-- | The datum matches, if <a>containsMatch</a>.
AnyOf :: (BracketExpression m) -> Meta m

-- | The datum matches, if <tt>not BracketExpression.containsMatch</tt>.
NoneOf :: (BracketExpression m) -> Meta m

-- | The datum matches if <a>ShowablePredicate</a>.
Predicate :: (ShowablePredicate m) -> Meta m

-- | The token used to precede a <i>Perl-style shortcut</i>, when in the
--   <a>String</a>-form.
shortcutToken :: Char

-- | The token used to denote <a>Any</a>, when in the <a>String</a>-form.
anyToken :: Char

-- | The set of <a>Char</a> to which a specific meaning is attributed, when
--   reading from <a>String</a>.
tokens :: String

-- | True if the specified datum matches.
isMatch :: Eq m => m -> Meta m -> Bool
instance Eq m => Eq (Meta m)
instance NFData m => NFData (Meta m)
instance Consumer (Meta m)
instance (ShortcutExpander m, Read m) => Read (Meta m)
instance Show m => Show (Meta m)
instance SelfValidator (Meta m)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>A type of <i>zero-width assertion</i>: the <a>Bow</a>-predicate is
--   <a>True</a> if no input-data has yet been consumed; the
--   <a>Stern</a>-predicate is <a>True</a> if no input-data remains to be
--   consumed.</li>
--   <li>Whilst at the top-level of the regex, the <i>absence</i> of an
--   anchor is equivalent to a non-capturing <tt>.*?</tt>, tempting one to
--   implement them using this property, it doesn't apply to those anchors
--   encountered at either end of a sub-expression. So in all cases, an
--   anchor constrains the permissible consumption of input-data, but at
--   the top level it also prevents the regex drifting away from either end
--   of the input-data.</li>
--   </ul>
module RegExDot.Anchor

-- | Defines the types on <i>anchor</i> by which a <i>regex</i> can be
--   moored to a part of the input-data.
data Anchor

-- | Matches only if no input data has yet been consumed. Can only exist at
--   the start of the entire regex, or (in theory) the start of any
--   <i>alternative</i>.
Bow :: Anchor

-- | Matches only if no input data remains to be consumed. Can only exist
--   at the end of the entire regex, or (in theory) the end of any
--   <i>alternative</i>.
Stern :: Anchor

-- | A specification for the anchors required around the expression
type AnchorSpecification = (Maybe Anchor, Maybe Anchor)

-- | The conventional token used to denote a <a>Bow</a>-anchor, when in
--   <a>String</a>-form.
bowToken :: Char

-- | The conventional token used to denote a <a>Stern</a>-anchor, when in
--   <a>String</a>-form.
sternToken :: Char

-- | The set of <a>Char</a> to which a specific meaning is attributed, when
--   reading from <a>String</a>.
tokens :: String

-- | The specification for an unanchored expression.
unanchored :: AnchorSpecification
instance Eq Anchor
instance NFData Anchor
instance Read Anchor
instance Show Anchor


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>This implementation of extended <i>regex</i>es, generalises the
--   familiar concept of pattern-matching of character-strings, to matching
--   lists composed from an arbitrary data-type. The polymorphic data, from
--   which the input data-list is composed, need only support
--   <tt>Eq</tt>.</li>
--   <li>Because of the unknown stringified form of the underlying
--   polymorphic data, the <i>regex</i> must be described by a
--   comparatively verbose bracketed &amp; comma-separated list, rather
--   than the traditional <i>String</i> containing Meta-characters. Each
--   element of this <a>Concatenation</a> is a <a>RepeatablePattern</a>,
--   which describes a permissible match against <a>InputData</a>.</li>
--   <li><a>RepeatablePattern</a> can take one of two forms. In the
--   simplest case, it matches just a single item of the underlying
--   polymorphic type, perhaps literally, though looser specifications also
--   exist: <tt>.</tt> matches any input datum; <tt>[x, y, z]</tt> matches
--   any of <tt>x</tt>, <tt>y</tt>, or <tt>z</tt>; <tt>[^x, y, z]</tt>
--   matches anything but <tt>x</tt>, <tt>y</tt>, or <tt>z</tt>. To support
--   POSIX <i>ERE</i>s, <a>RepeatablePattern</a> can also be a list
--   <a>Alternatives</a>, each of which is recursively defined as an
--   <a>ExtendedRegEx</a>, to form a tree-structure.</li>
--   <li>Each <a>Pattern</a>, can optionally be <i>quantified</i> by either
--   a traditional <i>greedy</i>, or a <i>Perl</i>-style <i>non-greedy</i>,
--   suffix, e.g.; <tt>[*, +, ?, {n, m}, {n,}, {n}, *?, +?, ??, {n, m}?,
--   {n,}?]</tt>.</li>
--   <li>For convenience, common specifications can be canned &amp;
--   assigned a single <a>Char</a> mnemonic, for subsequent reference.
--   Since <a>ExtendedRegEx</a> is polymorphic, the set of abbreviations
--   appropriate in the context of the unspecified base-type, must be
--   implemented externally through the <a>ShortcutExpander</a> interface.
--   This permits the use, when the type-parameter is <a>Char</a>, of
--   <i>Perl-style shortcuts</i> <tt>[\d\D\s\S\w\W]</tt>.</li>
--   <li>The algorithm, is the classic <i>back-tracking</i> one, rather
--   than either a <i>DFA</i> or <i>NFA</i>. This permits construction of
--   <a>Result</a> via which one can discover the deep mapping of
--   <a>InputData</a> into <a>ExtendedRegEx</a>, &amp; provides the
--   flexibility to add the features now expected by modern
--   <i>regex</i>-engines. Since the type-parameter is unknown, &amp; may
--   represent a large object, the exponential space-complexity of creating
--   a <i>DFA</i> may present additional problems. The exponential
--   time-complexity of the <i>back-tracking</i> algorithm is partially
--   tamed by targeting obvious inefficiencies with specific
--   optimisations.</li>
--   <li>Char-based regexen, traditionally overload the delimiters of a set
--   of <a>Alternatives</a> (parentheses), as a request for data-capture.
--   Here, in contrast, all <a>RepeatablePattern</a>s capture data, &amp;
--   repeated sub-expressions capture a list of data, rather than
--   arbitrarily recording just the last
--   (<a>http://www.opengroup.org/onlinepubs/009695399/functions/regcomp.html</a>)
--   item.</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>REFERENCES</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li><a>http://en.wikipedia.org/wiki/Regular_expression</a></li>
--   <li><a>http://swtch.com/~rsc/regexp/regexp1.html</a></li>
--   
--   <li><a>http://docstore.mik.ua/orelly/perl/prog/ch02_04.htm#PERL2-CH-2-SECT-4.1.2</a></li>
--   
--   <li><a>http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies.html</a></li>
--   
--   <li><a>http://hackage.haskell.org/packages/archive/regex-posix/latest/doc/html/Text-Regex-Posix.html</a></li>
--   <li><a>http://www.haskell.org/haskellwiki/Regular_expressions</a></li>
--   
--   <li><a>http://www2.research.att.com/~gsf/testregex/re-interpretation.html</a></li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>CAVEATS</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Because of the definition of mutually recursive data-types, it is
--   difficult to split this annoyingly large module, &amp; preserve
--   compatibility across compilers, but it may be possible to break this
--   cyclic dependency, by defining an interface to which one of the
--   data-types defined here conforms.</li>
--   <li>Doesn't implement <i>Back-references</i>, making the definition of
--   the <a>ExtendedRegEx</a> context-free.</li>
--   <li>There's no integration with the type-classes defined in
--   <a>Text.Regex.Base.RegexLike</a>, which assumes <a>Char</a>-based
--   <a>InputData</a>; though this could be added to a specialised
--   instance.</li>
--   <li>When <a>Alternatives</a> are defined, <a>Result</a> becomes a
--   tree-like structure. Unless the alternative is a singleton, the
--   specific alternative selected in the solution is typically unknown,
--   &amp; therefore the <i>structure</i> of the branch of this tree is
--   also unknown. This lack of clarity is compounded when the
--   <a>Alternatives</a> are <a>Repeatable</a>, since a different one may
--   be selected on each successive repetition. Consequently, the user
--   can't navigate this portion of the structure in a statically defined
--   manner, to acquire the captured data. Despite this, &amp; in contrast
--   to other <i>regex</i>-engines, access to the whole data-structure is
--   available, since it doesn't seem advantage to hide it. The user can
--   then either use <a>extractDataFromMatch</a> for that element of
--   <a>Result</a>, thus aggregating the data from sections of unknown
--   structure, or <a>show</a> it, as an aid to debugging.</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>TODO</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Test parallel-operation, on a 3 or more processor machine. If
--   <tt>rnf</tt> is less effective than <tt>rwhnf</tt>, then the
--   <a>NFData</a> context can be removed, reducing the requirements
--   imposed on the type-parameter <tt>a</tt>.</li>
--   <li>Try <a>Stream</a> (stream-fusion), a faster drop-in replacement
--   for <a>List</a>; possibly integrated in GHC-6.12.</li>
--   <li><a>bypassInputDataForLiberalConsumer</a> is too restrictive. More
--   generally, we can test whether the set of different <tt>a</tt> in
--   <a>InputData</a>, is a subset of those common to all remaining terms
--   in the <a>ExtendedRegEx</a>. Using this rule, we can infer <tt>"aaa
--   ..." =~ MkExtendedRegEx [a,a+,a?,[ab]{2,3}]</tt>, given compatible
--   <a>consumptionBounds</a>.</li>
--   <li>Nested repetitions, where nothing has been added to the
--   expression, result in repeated trials of the same expression, e.g.;
--   <tt>"(x{i,}){j,}"</tt> results in the same expansion for <tt>(i, j) in
--   [(2, 3), (3, 2), (6, 1), (1, 6)]</tt>. The resulting <a>MatchList</a>
--   may be different, but if the first such trial fails, so will all the
--   remainder.</li>
--   <li>Should cope with empty sets of <a>Alternatives</a> &amp; zero
--   repetitions, neither of which can ever match, but the wider pattern
--   can, e.g. <tt>(()|x{0}|y)</tt>.</li>
--   <li>By removing <a>RepeatablePattern</a> from <a>Match</a>, it can be
--   isolated in a new module. This would result in a significant loss of
--   discoverability.</li>
--   <li>Expand repeated <a>Bow</a> with <tt>fewest - 1</tt> null matches
--   followed by recursive <a>findMatch</a>-call with <tt>repetitions =
--   1</tt>.</li>
--   </ul>
module RegExDot.RegEx

-- | <ul>
--   <li>Defines the method required to expand a mnemonic into an
--   <a>ExtendedRegEx</a>.</li>
--   <li>CAVEAT: this interface must be declared locally, since it
--   references <a>ExtendedRegEx</a>, &amp; <a>ExtendedRegEx</a> references
--   it.</li>
--   </ul>
class ShortcutExpander m
expand :: ShortcutExpander m => Char -> ExtendedRegEx m

-- | Represents the <i>concatenation</i> aspect of <a>ExtendedRegEx</a>s.
type Concatenation m = [RepeatablePattern m]

-- | At the top-level of an <a>ExtendedRegEx</a>, the lack of an
--   <a>Anchor</a> allows the <a>ExtendedRegEx</a> to drift away from the
--   corresponding end of the input-data; this data-gap is captured here.
type ExternalMatch m = Maybe (Match m)

-- | <ul>
--   <li>The input-data is just a list.</li>
--   <li>Whilst typically this list is also a <a>String</a>, &amp; could
--   therefore be more efficiently implemented using
--   <a>Data.ByteString</a>, we can't assume that the polymorphic base-type
--   is always <a>Char</a>.</li>
--   </ul>
type InputData m = [m]

-- | Tag the <a>InputData</a> with the <a>RepeatablePattern</a> it matched
--   (which unfortunately confines the definition to this (bloated)
--   module), &amp; the offset from the start of the data;
type MatchedData m = (RepeatablePattern m, DataLength, InputData m)

-- | Describes the manner in which a <a>Concatenation</a> successfully
--   consumed <a>InputData</a>.
type MatchList m = [Match m]

-- | Make <a>Pattern</a>s, <a>Repeatable</a>.
type RepeatablePattern m = Repeatable (Pattern m)

-- | <ul>
--   <li>Represents the <i>alternation</i> feature of
--   <a>ExtendedRegEx</a>s.</li>
--   <li>One could amalgamate this with <a>Pattern</a>, since it seems to
--   exist merely as a peg to hang <i>instance</i>-declarations from.</li>
--   </ul>
newtype Alternatives m
MkAlternatives :: [ExtendedRegEx m] -> Alternatives m

-- | Describes the manner in which a <a>RepeatablePattern</a> successfully
--   consumed <a>InputData</a>.
type Match m = Tree (MatchedData m)

-- | Constructs an <a>ExtendedRegEx</a>, by surrounding a
--   <a>Concatenation</a> with optional <a>Anchor</a>s.
data ExtendedRegEx m
MkExtendedRegEx :: Maybe Anchor -> Concatenation m -> Maybe Anchor -> ExtendedRegEx m

-- | An option to anchor the <i>regex</i> to the start of the
--   <a>InputData</a>.
bowAnchor :: ExtendedRegEx m -> Maybe Anchor

-- | The sequence of <a>RepeatablePattern</a>s defining the
--   <a>Require</a>ments that the <a>InputData</a> must meet.
concatenation :: ExtendedRegEx m -> Concatenation m

-- | An option to anchor the <i>regex</i> to the end of the
--   <a>InputData</a>.
sternAnchor :: ExtendedRegEx m -> Maybe Anchor

-- | Defines either a simple <a>Meta</a>, which can match exactly one
--   datum, or a set of <a>Alternatives</a>, each of which is recursively
--   defined above, as an <a>ExtendedRegEx</a>.
data Pattern m

-- | Describes a requirement for a simple scalar datum of the polymorphic
--   type.
Require :: (Meta m) -> Pattern m

-- | A sub-expression containing a selection of recursively defined
--   alternatives, thus forming a tree-structure.
CaptureGroup :: (Alternatives m) -> Pattern m

-- | Captures the list of input-data consumed by the <a>Concatenation</a>,
--   bracketed by any data-prefix or data-suffix.
type Result m = (ExternalMatch m, Maybe (MatchList m), ExternalMatch m)

-- | The token used to separate alternative <a>ExtendedRegEx</a>s, when in
--   the <a>String</a>-form.
alternativeExtendedRegExSeparatorToken :: Char

-- | The delimiters of <a>Alternatives</a>, when in the <a>String</a>-form.
captureGroupDelimiters :: (Char, Char)

-- | The set of <a>Char</a> to which a specific meaning is attributed, when
--   reading from <a>String</a>.
tokens :: String

-- | Drop <a>Anchor</a>s at both bow &amp; stern of the specified
--   <a>ExtendedRegEx</a>.
dock :: Transformation m

-- | Convenience-function to build a <a>CaptureGroup</a> from a list of
--   alternative <a>ExtendedRegEx</a>s.
captureGroup :: [ExtendedRegEx m] -> Pattern m

-- | Shifts the offsets of all the <a>MatchedData</a> contained in the
--   specified <a>MatchList</a>.
shiftMatchList :: DataLength -> MatchList m -> MatchList m

-- | Shows either the specified <a>Anchor</a>, or a null string where
--   <a>Nothing</a> is specified.
showsMaybeAnchor :: Maybe Anchor -> String -> String

-- | Convenience-function, to build a <a>RepeatablePattern</a> from an
--   unrepeated instance of the specified <a>Meta</a>-datum.
simply :: Meta m -> RepeatablePattern m

-- | Similar to <a>fmap</a>, but operates on <a>Concatenation</a>, rather
--   than just <tt>a</tt>.
transformExtendedRegEx :: (Concatenation m -> Concatenation m) -> Transformation m

-- | Accessor, to expose the guts.
deconstructAlternatives :: Alternatives m -> [ExtendedRegEx m]

-- | <ul>
--   <li>Operator's name was chosen to suggest something more than
--   <a>=~</a>.</li>
--   <li>CAVEAT: much more expensive then <a>=~</a>: in <i>ghci</i>,
--   <a>Just</a> can be observed to be printed <i>long</i> before the
--   <a>MatchList</a> from which <a>Result</a> is constructed, as the lazy
--   algorithm finds the first solution, but not yet necessarily the
--   optimal solution, amongst <a>Alternatives</a>.</li>
--   </ul>
(+~) :: (Eq m, NFData m) => InputData m -> RegExOpts (ExtendedRegEx m) -> Result m

-- | <ul>
--   <li>Pattern-match operator.</li>
--   <li>Identifier &amp; parameter-order follow the lead of <i>Perl</i>'s
--   pattern-match operator.</li>
--   <li>Considerably more efficient than <a>+~</a>, since even though they
--   are both implemented via <a>findMatch</a>, the discovery of <i>any</i>
--   solution is sufficient to generate the return-value; lazy-evaluation
--   avoids the requirement to identify the irrelevant optimal
--   solution.</li>
--   </ul>
(=~) :: (Eq m, NFData m) => InputData m -> RegExOpts (ExtendedRegEx m) -> Bool

-- | Pattern-mismatch operator.
(/~) :: (Eq m, NFData m) => InputData m -> RegExOpts (ExtendedRegEx m) -> Bool

-- | <ul>
--   <li>Represents a black hole, which will greedily consume all
--   data.</li>
--   <li>CAVEAT: nullary, i.e. a constant.</li>
--   </ul>
(.*) :: RepeatablePattern m

-- | A <i>non-greedy</i> version of <a>.*</a>.
(.*?) :: RepeatablePattern m

-- | True if there's at least one <a>RepeatablePattern</a> in the
--   <a>Concatenation</a>, i.e. that it's non-null.
isDefined :: ExtendedRegEx m -> Bool

-- | True if the <a>Pattern</a> was constructed via <a>CaptureGroup</a>.
isCaptureGroup :: Pattern m -> Bool

-- | <a>Alternatives</a> can be employed as a simple <i>capture-group</i>
--   as well as a switch, under which circumstances there's no choice
--   amongst multiple <a>Alternatives</a>.
isSingletonAlternatives :: Alternatives m -> Bool

-- | Returns the length of data consumed by the specified
--   <a>ExternalMatch</a>.
externalMatchLength :: ExternalMatch m -> DataLength

-- | Extract &amp; concatenate, the <a>InputData</a> from a <a>Match</a>.
extractDataFromMatch :: Match m -> InputData m

-- | Extract &amp; concatenate, the <a>InputData</a> from a <a>Match</a>;
--   null if it didn't match any.
extractDataFromMatch' :: Maybe (Match m) -> InputData m

-- | Extract &amp; concatenate, the <a>InputData</a>, from the
--   <a>MatchList</a>.
extractDataFromMatchList :: MatchList m -> InputData m
instance Eq m => Eq (ExtendedRegEx m)
instance Eq m => Eq (Pattern m)
instance Eq m => Eq (Alternatives m)
instance NFData m => NFData (ExtendedRegEx m)
instance SelfValidator (ExtendedRegEx m)
instance Consumer (ExtendedRegEx m)
instance Show m => Show (ExtendedRegEx m)
instance (Eq m, ShortcutExpander m, Read m, ShortcutExpander m) => Read (ExtendedRegEx m)
instance NFData m => NFData (Pattern m)
instance SelfValidator (Pattern m)
instance Consumer (Pattern m)
instance Show m => Show (Pattern m)
instance (Eq m, ShortcutExpander m, Read m, ShortcutExpander m) => Read (Pattern m)
instance NFData m => NFData (Alternatives m)
instance SelfValidator (Alternatives m)
instance Consumer (Alternatives m)
instance Show m => Show (Alternatives m)
instance (ShortcutExpander m, ShortcutExpander m, Eq m, Read m) => Read (Alternatives m)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Permits transformation of
--   <a>MatchList</a>, to facilitate standardisation.</li>
--   </ul>
module RegExDot.DataSpanTree

-- | <ul>
--   <li>POSIX describes the contents of <i>capture-groups</i>, as
--   summarised in
--   <a>http://www2.research.att.com/~gsf/testregex/</a>.</li>
--   <li><a>Result</a>, is a complete description of the match between
--   <a>InputData</a> &amp; RegEx.ExtendedRegEx'; this function extracts a
--   POSIX-conformant list from it.</li>
--   <li>The major differences are, that:</li>
--   </ul>
--   
--   Only data from parenthesized sub-expressions (<a>Alternatives</a>) is
--   captured.
--   
--   Only the <i>last</i> repetition of a repeated sub-expression is
--   returned.
--   <a>http://www.opengroup.org/onlinepubs/009695399/functions/regcomp.html</a>.
--   
--   The data captured within each parenthesized sub-expression, is
--   summarised as a single <a>DataSpan</a>.
--   
--   POSIX specifies a <a>Span</a>-offset of <tt>-1</tt>, for
--   sub-expressions which match zero times; cf sub-expressions which
--   consume nothing, once.
--   <a>http://www.opengroup.org/onlinepubs/009695399/functions/regcomp.html</a>.
--   @ ("ace" Text.Regex.Posix.=~ "a(b)*c(d)?e") ::
--   Text.Regex.Base.RegexLike.MatchArray array (0,2)
--   [(0,(0,3)),(1,(-1,0)),(2,(-1,0))]
--   
--   ("ace" Text.Regex.Posix.=~ "a(b*)c(d?)e") ::
--   Text.Regex.Base.RegexLike.MatchArray array (0,2)
--   [(0,(0,3)),(1,(1,0)),(2,(2,0))] @ I consider this a poor convention,
--   resulting from the focus of POSIX on C, which makes subsequent
--   calculation from the list of <tt>DataSpan</tt>s difficult &amp;
--   error-prone.
extractCaptureGroups :: Bool -> DataSpanTreeList a -> [DataSpan a]

-- | Condenses a <a>DataSpanTreeList</a>s into a list of <a>DataSpan</a>s,
--   using <a>join</a>.
flattenTreeList :: DataLength -> DataSpanTreeList a -> [DataSpan a]

-- | Converts a <a>MatchList</a> into a <a>DataSpanTreeList</a>, by
--   transforming the <a>Leaf</a>s.
toTreeList :: MatchList a -> DataSpanTreeList a


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Provides a default implementation of
--   the type-classes, required for <a>ExtendedRegEx</a> Int.</li>
--   <li><i><tt>CAVEATS</tt></i></li>
--   </ul>
--   
--   In contrast to the traditional regex, there's no reason to escape a
--   <a>Char</a>, other than when referring to a <i>shortcut</i>. Since no
--   <i>shortcuts</i> are defined in this minimal definition, it's always
--   an error to escape a character.
module RegExDot.InstanceInt
instance ShortcutExpander Int
instance ShortcutExpander Int
instance ShortcutExpander Int


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Tools to manipulate a
--   <a>Result</a>.</li>
--   <li><i><tt>CAVEAT</tt></i> The data-definition remains in
--   <a>RegEx</a>, since it references <a>Match</a>.</li>
--   </ul>
module RegExDot.Result

-- | Accessor.
getMatchList :: Result a -> Maybe (MatchList a)

-- | Accessor.
getPreMatch :: Result a -> ExternalMatch a

-- | Accessor.
getPostMatch :: Result a -> ExternalMatch a

-- | True if the <a>InputData</a> matched the <a>ExtendedRegEx</a>.
isMatch :: Result a -> Bool

-- | Counts the number of top-level <a>Match</a>es.
countMatches :: Result a -> Int


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Defines <i>binary</i> operators, to form a <i>Domain-specific
--   Language</i>, by which to compose <a>Concatenations</a> from
--   <a>Pattern</a>s.</li>
--   <li>Each operator quantifies the specified <a>Pattern</a>, &amp;
--   prepends it to the specified <a>Concatenation</a>.</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>TODO</tt></i> Could <tt>[]</tt> &amp; <tt>Meta</tt> be
--   instances of a type-class which has methods (-:) etc., allowing the
--   former to prepend <a>captureGroup</a> &amp; the latter <a>Require</a>
--   ?</li>
--   </ul>
module RegExDot.DSL

-- | Prepend an unrepeated <a>Pattern</a>, to the specified
--   <a>Concatenation</a>.
(-:) :: Pattern a -> Concatenation a -> Concatenation a

-- | Prepend an optional <a>Pattern</a>, to the specified
--   <a>Concatenation</a>.
(?:) :: Pattern a -> Concatenation a -> Concatenation a

-- | A <i>non-greedy</i> version of <a>?:</a>.
(??:) :: Pattern a -> Concatenation a -> Concatenation a

-- | Prepend a <a>Pattern</a>, repeatable zero or more times, to the
--   specified <a>Concatenation</a>.
(*:) :: Pattern a -> Concatenation a -> Concatenation a

-- | A <i>non-greedy</i> version of <a>*:</a>.
(*?:) :: Pattern a -> Concatenation a -> Concatenation a

-- | Prepend a <a>Pattern</a>, repeatable one or more times, to the
--   specified <a>Concatenation</a>.
(+:) :: Pattern a -> Concatenation a -> Concatenation a

-- | A <i>non-greedy</i> version of <a>+:</a>.
(+?:) :: Pattern a -> Concatenation a -> Concatenation a

-- | Prepend a <a>Pattern</a>, repeated a range of times, to the specified
--   <a>Concatenation</a>.
(#->#:) :: (Pattern a, RepetitionBounds) -> Concatenation a -> Concatenation a

-- | A <i>non-greedy</i> version of '#-&gt;#:'.
(#->#?:) :: (Pattern a, RepetitionBounds) -> Concatenation a -> Concatenation a

-- | Prepend a <a>Pattern</a>, repeated at least a specified number of
--   times, to the specified <a>Concatenation</a>.
(#->:) :: (Pattern a, Repetitions) -> Concatenation a -> Concatenation a

-- | A <i>non-greedy</i> version of '#-&gt;:'.
(#->?:) :: (Pattern a, Repetitions) -> Concatenation a -> Concatenation a

-- | Prepend a <a>Pattern</a>, repeated a precise number of times, to the
--   specified <a>Concatenation</a>.
(#:) :: (Pattern a, Repetitions) -> Concatenation a -> Concatenation a

-- | <ul>
--   <li>Sandwiches a <a>Concatenation</a> between optional <a>Anchor</a>s
--   to construct a <a>ExtendedRegEx</a>.</li>
--   <li>Accounts for the unusual requirement to place an <a>Stern</a> at
--   the start of the <a>Concatenation</a>, or an <a>Bow</a> at the
--   end.</li>
--   </ul>
(<~>) :: AnchorSpecification -> Concatenation a -> ExtendedRegEx a
