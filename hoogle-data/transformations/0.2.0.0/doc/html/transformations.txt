-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic representation of tree transformations
--   
@package transformations
@version 0.2.0.0

module Generics.Regular.Functions.GOrd
class GOrd f
comparef :: GOrd f => (a -> a -> Ordering) -> f a -> f a -> Ordering
gcompare :: (Regular a, GOrd (PF a)) => a -> a -> Ordering
instance GOrd f => GOrd (S s f)
instance GOrd f => GOrd (C c f)
instance (GOrd f, GOrd g) => GOrd (f :*: g)
instance (GOrd f, GOrd g) => GOrd (f :+: g)
instance GOrd U
instance Ord a => GOrd (K a)
instance GOrd I

module Generics.Regular.Zipper

-- | Abstract type of locations. A location contains the current focus and
--   its context. A location is parameterized over the family of datatypes
--   and over the type of the complete value.
data Loc :: * -> *
Loc :: a -> [Ctx (PF a) a] -> Loc a

-- | Abstract type of context frames. Not required for the high-level
--   navigation functions.

-- | It is in general not necessary to use the generic navigation functions
--   directly. The functions listed in the ``Interface'' section below are
--   more user-friendly.
class Functor f => Zipper f
cmap :: Zipper f => (a -> b) -> Ctx f a -> Ctx f b
fill :: Zipper f => Ctx f a -> a -> f a
first, last :: Zipper f => f a -> Maybe (a, Ctx f a)
next, prev :: Zipper f => Ctx f a -> a -> Maybe (a, Ctx f a)

-- | Start navigating a datastructure. Returns a location that focuses the
--   entire value and has an empty context.
enter :: (Regular a, Zipper (PF a)) => a -> Loc a

-- | Move down to the leftmost child. Returns <a>Nothing</a> if the current
--   focus is a leaf.
down :: Loc a -> Maybe (Loc a)

-- | Move down to the rightmost child. Returns <a>Nothing</a> if the
--   current focus is a leaf.
down' :: Loc a -> Maybe (Loc a)

-- | Move up to the parent. Returns <a>Nothing</a> if the current focus is
--   the root.
up :: Loc a -> Maybe (Loc a)

-- | Move to the right sibling. Returns <a>Nothing</a> if the current focus
--   is the rightmost sibling.
right :: Loc a -> Maybe (Loc a)

-- | Move to the left sibling. Returns <a>Nothing</a> if the current focus
--   is the leftmost sibling.
left :: Loc a -> Maybe (Loc a)

-- | Return the entire value, independent of the current focus.
leave :: Loc a -> a

-- | Operate on the current focus. This function can be used to extract the
--   current point of focus.
on :: Loc a -> a

-- | Update the current focus without changing its type.
update :: (a -> a) -> Loc a -> Loc a

-- | Update the current focus without changing its type.
updateM :: Monad m => (a -> m a) -> Loc a -> m (Loc a)
instance Zipper f => Zipper (S s f)
instance Zipper f => Zipper (C c f)
instance (Zipper f, Zipper g) => Zipper (f :*: g)
instance (Zipper f, Zipper g) => Zipper (f :+: g)
instance Zipper U
instance Zipper (K a)
instance Zipper I
instance Zipper f => Functor (Ctx f)

module Generics.Regular.Transformations.Main

-- | Find a set of edits to transform the first into the second tree
diff :: Transform a => a -> a -> Transformation a

-- | Apply the edits to the given tree
apply :: Transform a => Transformation a -> a -> Maybe a
type Transformation a = [(Path a, Fix (WithRef a))]
data WithRef a b
InR :: (PF a b) -> WithRef a b
Ref :: (Path a) -> WithRef a b
type Path a = [Dir (PF a)]
class (Regular a, Children (PF a), Functor (PF a), ZipChildren (PF a), SEq (PF a), ExtractP (PF a), MapP (PF a), GMap (PF a), GOrd (PF a), Eq (PF a)) => Transform a
class HasRef a where type family RefRep a
toRef :: HasRef a => WithRef a (RefRep a) -> RefRep a
fromRef :: HasRef a => RefRep a -> WithRef a (RefRep a)
type NiceTransformation a = [(Path a, RefRep a)]
toNiceTransformation :: (Functor (PF a), HasRef a) => Transformation a -> NiceTransformation a
fromNiceTransformation :: (Functor (PF a), HasRef a) => NiceTransformation a -> Transformation a
instance [overlap ok] Eq ConIndex
instance [overlap ok] Num ConIndex
instance [overlap ok] ZipChildren f => ZipChildren (S s f)
instance [overlap ok] ZipChildren f => ZipChildren (C c f)
instance [overlap ok] (ZipChildren f, ZipChildren g) => ZipChildren (f :*: g)
instance [overlap ok] (ZipChildren f, ZipChildren g) => ZipChildren (f :+: g)
instance [overlap ok] ZipChildren U
instance [overlap ok] ZipChildren (K a)
instance [overlap ok] ZipChildren I
instance [overlap ok] Children f => Children (S s f)
instance [overlap ok] Children f => Children (C c f)
instance [overlap ok] (Children f, Children g) => Children (f :*: g)
instance [overlap ok] (Children f, Children g) => Children (f :+: g)
instance [overlap ok] Children U
instance [overlap ok] Children (K a)
instance [overlap ok] Children I
instance [overlap ok] MapP f => MapP (S s f)
instance [overlap ok] MapP f => MapP (C c f)
instance [overlap ok] (MapP f, MapP g) => MapP (f :*: g)
instance [overlap ok] (MapP f, MapP g) => MapP (f :+: g)
instance [overlap ok] MapP U
instance [overlap ok] MapP (K a)
instance [overlap ok] MapP I
instance [overlap ok] ExtractP f => ExtractP (S s f)
instance [overlap ok] ExtractP f => ExtractP (C c f)
instance [overlap ok] (ExtractP f, ExtractP g) => ExtractP (f :*: g)
instance [overlap ok] (ExtractP f, ExtractP g) => ExtractP (f :+: g)
instance [overlap ok] ExtractP U
instance [overlap ok] ExtractP (K a)
instance [overlap ok] ExtractP I
instance [overlap ok] SEq f => SEq (S s f)
instance [overlap ok] SEq f => SEq (C c f)
instance [overlap ok] (SEq f, SEq g) => SEq (f :*: g)
instance [overlap ok] (SEq f, SEq g) => SEq (f :+: g)
instance [overlap ok] Eq a => SEq (K a)
instance [overlap ok] SEq U
instance [overlap ok] SEq I
instance [overlap ok] (Regular a, Eq (PF a), GOrd (PF a)) => Ord (MemoKey a)
instance [overlap ok] (Regular a, Eq (PF a)) => Eq (MemoKey a)
instance [overlap ok] (CountIs f, CountIs g) => CountIs (f :*: g)
instance [overlap ok] (CountIs f, CountIs g) => CountIs (f :+: g)
instance [overlap ok] CountIs f => CountIs (C c f)
instance [overlap ok] CountIs (K a)
instance [overlap ok] CountIs U
instance [overlap ok] CountIs I
instance [overlap ok] (ShowPath (PF a), Functor (PF a), Show (PF a)) => Show (Fix (WithRef a))
instance [overlap ok] ShowPath f => Show [Dir f]
instance [overlap ok] ShowPath I
instance [overlap ok] ShowPath U
instance [overlap ok] ShowPath (K a)
instance [overlap ok] (ShowPath f, Constructor c) => ShowPath (C c f)
instance [overlap ok] (ShowPath f, ShowPath g, CountIs g) => ShowPath (f :*: g)
instance [overlap ok] (ShowPath f, ShowPath g) => ShowPath (f :+: g)
instance [overlap ok] Show ConIndex
instance [overlap ok] Functor (PF a) => Functor (WithRef a)

module Generics.MultiRec.CountIs
class CountIs (f :: (* -> *) -> * -> *)
countIs :: CountIs f => f r ix -> Int
instance (CountIs f, CountIs g) => CountIs (f :*: g)
instance (CountIs f, CountIs g) => CountIs (f :+: g)
instance CountIs f => CountIs (f :>: ix)
instance CountIs f => CountIs (C c f)
instance CountIs U
instance CountIs (K a)
instance CountIs (t :.: f)
instance CountIs (I ix)


-- | The generic zipper.
module Generics.MultiRec.Zipper

-- | Abstract type of locations. A location contains the current focus and
--   its context. A location is parameterized over the family of datatypes
--   and over the type of the complete value.
data Loc :: (* -> *) -> (* -> *) -> * -> *
Loc :: phi ix -> r ix -> Ctxs phi ix r a -> Loc phi r a
data Ctxs :: (* -> *) -> * -> (* -> *) -> * -> *
Empty :: Ctxs phi a r a
Push :: phi a -> Ctx (PF phi) a r ix -> Ctxs phi b r a -> Ctxs phi b r ix

-- | Abstract type of context frames. Not required for the high-level
--   navigation functions.

-- | It is in general not necessary to use the generic navigation functions
--   directly. The functions listed in the ``Interface'' section below are
--   more user-friendly.
class HFunctor phi f => Zipper phi f
cmapA :: (Zipper phi f, Applicative a) => (forall ix. phi ix -> r ix -> a (r' ix)) -> phi ix -> Ctx f b r ix -> a (Ctx f b r' ix)
fill :: Zipper phi f => phi b -> Ctx f b r ix -> r b -> f r ix
first, last :: Zipper phi f => (forall b. phi b -> r b -> Ctx f b r ix -> a) -> f r ix -> Maybe a
next, prev :: Zipper phi f => (forall b. phi b -> r b -> Ctx f b r ix -> a) -> phi b -> Ctx f b r ix -> r b -> Maybe a
impossible :: a -> b
instance (Constructor c, Zipper phi f) => Zipper phi (C c f)
instance Zipper phi f => Zipper phi (f :>: xi)
instance Zipper phi g => Zipper phi (Maybe :.: g)
instance Zipper phi g => Zipper phi ([] :.: g)
instance (Zipper phi f, Zipper phi g) => Zipper phi (f :*: g)
instance (Zipper phi f, Zipper phi g) => Zipper phi (f :+: g)
instance Zipper phi U
instance Zipper phi (K a)
instance El phi xi => Zipper phi (I xi)
instance HFunctor phi (Loc phi)
instance Zipper phi (PF phi) => HFunctor phi (Ctxs phi b)
instance Zipper phi f => HFunctor phi (Ctx f b)

module Generics.MultiRec.Transformations.Path

-- | A path is a list of connecting directions on a datatype. This is
--   equivalent to a zipper context where the recursive positions are
--   ignored (set to a constant type).
type Path phi t i = Ctxs phi t (K0 ()) i

-- | A direction points to a single recursive position in a datatype.
type Dir f t i = Ctx f t (K0 ()) i

-- | The type of pattern functors extended with references
data WithRef phi top r a
InR :: PF phi r a -> WithRef phi top r a
unInR :: WithRef phi top r a -> PF phi r a
Ref :: Path phi a top -> WithRef phi top r a
unRef :: WithRef phi top r a -> Path phi a top

-- | Closed functors extended with references
type HWithRef phi top t = HFix (WithRef phi top) t

-- | Insertions contain a path of where to insert, and what to insert
data Insert phi top ix
Insert :: phi t -> Path phi t ix -> HWithRef phi top t -> Insert phi top ix

-- | Concatenate two paths
(<.>) :: Path phi b a -> Path phi c b -> Path phi c a
newtype ConIndex
CI :: Int -> ConIndex
class ShowPath f
showsPrecPath :: ShowPath f => ShowS -> ConIndex -> Int -> Dir f i t -> ShowS
showsPrecPathC :: ShowPath (PF phi) => ConIndex -> Int -> Path phi t i -> ShowS
showWR :: (HFunctor phi (PF phi), HShow phi (PF phi), ShowPath (PF phi)) => phi ix -> Int -> HWithRef phi top ix -> ShowS
mapP :: (Monad m, Fam phi, MapP phi (PF phi)) => phi i -> Path phi t i -> (phi t -> t -> m t) -> i -> m i
class MapP phi f
mapP' :: (MapP phi f, Monad m) => (phi t -> r t -> m (r t)) -> phi ix -> Dir f t ix -> f r ix -> m (f r ix)
mapPR :: (Fam phi, MapP phi (PF phi)) => phi a -> Path phi t a -> (phi t -> HWithRef phi top t -> Maybe (HWithRef phi top t)) -> HWithRef phi top a -> Maybe (HWithRef phi top a)
mapMwithI :: (Monad m, Traversable t) => (Int -> a -> m b) -> t a -> m (t b)
data Ctxs :: (* -> *) -> * -> (* -> *) -> * -> *
Empty :: Ctxs phi a r a
Push :: phi a -> Ctx (PF phi) a r ix -> Ctxs phi b r a -> Ctxs phi b r ix

-- | Abstract type of context frames. Not required for the high-level
--   navigation functions.
instance Eq ConIndex
instance Num ConIndex
instance MapP phi f => MapP phi ([] :.: f)
instance MapP phi f => MapP phi (Maybe :.: f)
instance MapP phi f => MapP phi (f :>: ix)
instance MapP phi f => MapP phi (C c f)
instance (MapP phi f, MapP phi g) => MapP phi (f :*: g)
instance (MapP phi f, MapP phi g) => MapP phi (f :+: g)
instance El phi ix => MapP phi (I ix)
instance MapP phi (K a)
instance MapP phi U
instance (HFunctor phi (PF phi), HShow phi (PF phi), El phi ix, ShowPath (PF phi)) => Show (Insert phi top ix)
instance (HFunctor phi (PF phi), HShow phi (PF phi), El phi ix, ShowPath (PF phi)) => Show (HWithRef phi top ix)
instance ShowPath (PF phi) => Show (Path phi t i)
instance ShowPath f => ShowPath ([] :.: f)
instance ShowPath f => ShowPath (Maybe :.: f)
instance ShowPath (I ix)
instance ShowPath U
instance ShowPath (K a)
instance (ShowPath f, Constructor c) => ShowPath (C c f)
instance ShowPath f => ShowPath (f :>: ix)
instance (ShowPath f, ShowPath g, CountIs f) => ShowPath (f :*: g)
instance (ShowPath f, ShowPath g) => ShowPath (f :+: g)
instance Show ConIndex

module Generics.MultiRec.Transformations.Children

-- | Get all children with their paths
allChildren :: (Fam phi, Children phi (PF phi) xi) => phi ix -> phi xi -> ix -> [(Path phi xi ix, xi)]
class Children phi (f :: (* -> *) -> * -> *) xi
children :: Children phi f xi => (forall ix'. phi ix' -> phi xi -> Path phi ix' ix -> r ix' -> [(Path phi xi ix, r xi)]) -> phi ix -> phi xi -> (forall xi. phi xi -> Dir f xi ix -> Path phi xi ix) -> f r ix -> [(Path phi xi ix, r xi)]
instance [overlap ok] Children phi f ix => Children phi ([] :.: f) ix
instance [overlap ok] Children phi f ix => Children phi (Maybe :.: f) ix
instance [overlap ok] Children phi f ix => Children phi (f :>: xi) ix
instance [overlap ok] (Constructor c, Children phi f ix) => Children phi (C c f) ix
instance [overlap ok] (Children phi f ix, Children phi g ix, CountIs g) => Children phi (f :*: g) ix
instance [overlap ok] (Children phi f ix, Children phi g ix) => Children phi (f :+: g) ix
instance [overlap ok] Children phi U ix
instance [overlap ok] Children phi (K a) ix
instance [overlap ok] (Fam phi, El phi ix, El phi xi) => Children phi (I xi) ix
instance [overlap ok] (Fam phi, El phi ix) => Children phi (I ix) ix

module Generics.MultiRec.Transformations.MemoTable
data HList (l :: [*])
HNil :: HList []
HCons :: h -> HList t -> HList (h : t)
type MemoTable phi top ixs = HList (MemoTable' One phi top ixs)
data Type
One :: Type
Two :: Type
type MemKey t = (Bool, t, t)
type MemVal phi top t = [Insert phi top t]
data Proxy (t :: k)
Proxy :: Proxy
class Lookup phi (ixs :: [*]) ix
lookupMT :: Lookup phi ixs ix => Proxy '(phi, ixs) -> MemoTable phi top ixs -> MemKey ix -> Maybe (MemVal phi top ix)
insertMT :: Lookup phi ixs ix => Proxy '(phi, ixs) -> MemKey ix -> MemVal phi top ix -> MemoTable phi top ixs -> MemoTable phi top ixs
type Memo phi top a = State (MemoTable phi top (Ixs phi)) a
class EmptyMemo (phi :: * -> *) top (ixs :: [*])
emptyMemo :: EmptyMemo phi top ixs => Proxy '(phi, top, ixs) -> MemoTable phi top ixs
runMemo :: EmptyMemo phi top (Ixs phi) => Proxy '(phi, top) -> Memo phi top a -> a
recMemo :: (Fam phi, Children phi (PF phi) ix, Lookup phi (Ixs phi) ix, Eq ix, GetChildrenTable phi (Ixs phi) ix) => (forall ix. (Children phi (PF phi) ix, Lookup phi (Ixs phi) ix, Eq ix, GetChildrenTable phi (Ixs phi) ix) => Bool -> phi ix -> ix -> ix -> Memo phi top [Insert phi top ix]) -> Bool -> phi ix -> ix -> ix -> Memo phi top [Insert phi top ix]
type ChildTable phi top ixs = MemoTable' Two phi top ixs
class ChildrenTable (phi :: * -> *) top (ixs :: [*])
childrenTable :: ChildrenTable phi top ixs => Proxy '(phi, top, ixs) -> top -> HList (ChildTable phi top ixs)
class GetChildrenTable phi (ixs :: [*]) ix
getChTable :: GetChildrenTable phi ixs ix => Proxy '(phi, top, ixs) -> HList (ChildTable phi top ixs) -> MemCell Two phi top ix
instance [overlap ok] GetChildrenTable phi ts ix => GetChildrenTable phi (t : ts) ix
instance [overlap ok] Ord t => GetChildrenTable phi (t : ts) t
instance [overlap ok] GetChildrenTable phi '[] ix
instance [overlap ok] (Fam phi, El phi h, El phi top, Children phi (PF phi) h, ChildrenTable phi top t) => ChildrenTable phi top (h : t)
instance [overlap ok] (Fam phi, El phi top, Children phi (PF phi) top, ChildrenTable phi top t) => ChildrenTable phi top (top : t)
instance [overlap ok] ChildrenTable phi top '[]
instance [overlap ok] EmptyMemo phi top t => EmptyMemo phi top (h : t)
instance [overlap ok] EmptyMemo phi top '[]
instance [overlap ok] Lookup phi ts ix => Lookup phi (t : ts) ix
instance [overlap ok] Ord t => Lookup phi (t : ts) t
instance [overlap ok] Lookup phi '[] ix

module Generics.MultiRec.Transformations.ZipChildren
zipChildrenM :: (Monad m, Fam phi, ZipChildren phi (PF phi)) => phi ix -> (forall t. (Lookup phi (Ixs phi) t, Children phi (PF phi) t, GetChildrenTable phi (Ixs phi) t, Eq t) => phi t -> Path phi t ix -> t -> t -> m a) -> ix -> ix -> m [a]
class ZipChildren phi (f :: (* -> *) -> * -> *)
zipChildren :: (ZipChildren phi f, Monad m) => phi ix -> (forall t. (Lookup phi (Ixs phi) t, Children phi (PF phi) t, GetChildrenTable phi (Ixs phi) t, Eq t) => phi t -> Path phi t ix -> r t -> r t -> m a) -> (forall t. Dir f t ix -> Path phi t ix) -> f r ix -> f r ix -> m [a]
instance ZipChildren phi f => ZipChildren phi ([] :.: f)
instance ZipChildren phi f => ZipChildren phi (Maybe :.: f)
instance ZipChildren phi f => ZipChildren phi (f :>: ix)
instance (ZipChildren phi f, Constructor c) => ZipChildren phi (C c f)
instance (ZipChildren phi f, ZipChildren phi g, CountIs g) => ZipChildren phi (f :*: g)
instance (ZipChildren phi f, ZipChildren phi g) => ZipChildren phi (f :+: g)
instance ZipChildren phi U
instance ZipChildren phi (K a)
instance (Lookup phi (Ixs phi) xi, El phi xi, Children phi (PF phi) xi, GetChildrenTable phi (Ixs phi) xi, Eq xi) => ZipChildren phi (I xi)

module Generics.MultiRec.ShallowEq
class SEq phi (f :: (* -> *) -> * -> *)
shallowEq :: SEq phi f => phi ix -> f r ix -> f r ix -> Bool
instance (Traversable t, Eq (t ()), SEq phi f) => SEq phi (t :.: f)
instance SEq phi f => SEq phi (C c f)
instance SEq phi f => SEq phi (f :>: ix)
instance (SEq phi f, SEq phi g) => SEq phi (f :*: g)
instance (SEq phi f, SEq phi g) => SEq phi (f :+: g)
instance Eq a => SEq phi (K a)
instance SEq phi U
instance SEq phi (I xi)

module Generics.MultiRec.Transformations.Main

-- | Find a set of insertions to transform the first into the second tree
diff :: (Transform phi, Children phi (PF phi) top, EmptyMemo phi top (Ixs phi), ChildrenTable phi top (Ixs phi), GetChildrenTable phi (Ixs phi) top, Eq top) => phi top -> top -> top -> Transformation phi top

-- | Apply the transformation to the given tree
apply :: Transform phi => phi ix -> ix -> Transformation phi ix -> Maybe ix

-- | Transformations are just sequences of insertions
type Transformation phi top = [Insert phi top top]
instance Extract f => Extract ([] :.: f)
instance Extract f => Extract (Maybe :.: f)
instance Extract f => Extract (C c f)
instance Extract f => Extract (f :>: ix)
instance Extract (K a)
instance Extract U
instance Extract (I ix)
instance (Extract f, Extract g) => Extract (f :*: g)
instance (Extract f, Extract g) => Extract (f :+: g)
