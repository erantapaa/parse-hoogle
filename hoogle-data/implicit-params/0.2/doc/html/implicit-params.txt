-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Named and unnamed implicit parameters with defaults.
--   
--   Named and unnamed implicit parameters with defaults using type classes
--   and constraint hacks. For examples, see <a>Data.Implicit</a>.
@package implicit-params
@version 0.2


-- | <a>Data.Implicit</a> provides both named and unnamed implicit
--   parameters that support default values (given by the <a>Default</a>
--   class from the <tt>data-default</tt> package). It makes no use of the
--   <tt>ImplicitParams</tt> extension and instead everything is done using
--   type classes.
--   
--   Here is an example of unnamed implicit parameters:
--   
--   <pre>
--   {-# LANGUAGE FlexibleContexts #-}
--   import <a>Data.Implicit</a>
--   
--   putParam :: <a>Implicit_</a> String =&gt; IO ()
--   putParam = putStrLn $ "Param was: " ++ show (<a>param_</a> :: String)
--   </pre>
--   
--   We define <tt>putParam</tt>, which is a simple function which takes an
--   implicit parameter of type <tt>String</tt>, and prints it to the
--   screen. The <a>param_</a> function is used to retrieve the unnamed
--   implicit parameter of type <tt>String</tt> from <tt>putParam</tt>'s
--   context. The type signature is necessary to force <a>param_</a> to
--   return a <tt>String</tt>, as this cannot be inferred due to the
--   polymorphism of <tt>show</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; putParam
--   Param was ""
--   </pre>
--   
--   This is how we call <tt>putParam</tt> without specifying its implicit
--   parameters. If an implicit parameter is left unspecified, its value is
--   defaulted to <a>def</a>, assuming that its type has a <a>Default</a>
--   instance. If not, then it is a type error not to specify the value of
--   an implicit parameter.
--   
--   <pre>
--   &gt;&gt;&gt; putParam $~ "hello, world"
--   Param was "hello, world"
--   </pre>
--   
--   The operator <a>$~</a> takes a function <tt>f</tt> and a value to
--   which to set the homotypic implicit parameter on <tt>f</tt>. It
--   applies the implicit parameter to <tt>f</tt> and returns the result.
--   There is also a prefix version of <tt>$~</tt> whose arguments are
--   flipped called <a>setParam_</a>.
--   
--   Here is an example of named implicit parameters:
--   
--   <pre>
--   {-# LANGUAGE DataKinds, FlexibleContexts, RankNTypes #-}
--   import <a>Data.Implicit</a>
--   import <a>Data.Proxy</a>
--   
--   foo :: Proxy "foo"
--   foo = Proxy
--   
--   bar :: Proxy "bar"
--   bar = Proxy
--   
--   putFooBar :: (<a>Implicit</a> "foo" String, <a>Implicit</a> "bar" String) =&gt; IO ()
--   putFooBar = do
--       putStrLn $ "foo was: " ++ show (param foo :: String)
--       putStrLn $ "bar was: " ++ show (param bar :: String)
--   </pre>
--   
--   The <a>Implicit</a> constraint is the named equivalent of
--   <a>Implicit_</a>. It takes an additional argument <tt>s</tt> to
--   specify the name of the implicit parameter. Implicit parameters can be
--   "named" using any type (of any kind, on compilers that support the
--   <tt>PolyKinds</tt> extension). (The above code uses type-level strings
--   of the <tt>Symbol</tt> kind from the <a>GHC.TypeLits</a> module, which
--   is the recommended way to name implicit parameters. However,
--   <tt>Symbol</tt> requires the <tt>DataKinds</tt> extension and at least
--   version 7.8 of GHC (7.6 is broken; see GHC bug #7502), so you are free
--   to use other types of other kinds if you want to support older
--   versions of GHC.) <a>param</a> and <a>setParam</a> work like their
--   unnamed counterparts <a>param_</a> and <a>setParam_</a>, but they also
--   take a proxy argument to specify the name of the implicit parameter.
--   The code above defines <tt>foo</tt> and <tt>bar</tt> to hide away the
--   (slightly ugly) proxy stuff.
--   
--   <pre>
--   &gt;&gt;&gt; putFooBar
--   foo was: ""
--   bar was: ""
--   </pre>
--   
--   Once again, the defaults of unspecified implicit parameters are given
--   by the <a>Default</a> class.
--   
--   <pre>
--   &gt;&gt;&gt; setParam foo "hello, world" putFooBar
--   foo was: "hello, world"
--   bar was: ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setParam bar "goodbye" $ setParam foo "hello, world" putFooBar
--   foo was: "hello, world"
--   bar was: "goodbye"
--   </pre>
--   
--   An infix version of <tt>setParam</tt> is also provided, <a>~$</a>.
--   Using <tt>~$</tt>, the above example would be:
--   
--   <pre>
--   &gt;&gt;&gt; putFooBar ~$ foo ~$ bar $$ "goodbye" $$ "hello, world"
--   foo was: "hello, world"
--   bar was: "goodbye
--   </pre>
module Data.Implicit

-- | The constraint <tt><a>Implicit</a> "foo" String</tt> on a function
--   <tt>f</tt> indicates that an implicit parameter named <tt>"foo"</tt>
--   of type <tt>String</tt> is passed to <tt>f</tt>.
class Implicit s a
param :: Implicit s a => proxy s -> a

-- | <a>setParam</a> supplies a value for an implicit parameter named
--   <tt>s</tt> to a function which takes a homotypic and homonymous
--   implicit parameter. The name <tt>s</tt> is specified by a proxy
--   argument passed to <tt>setParam</tt>.
setParam :: proxy s -> a -> (Implicit s a => b) -> b

-- | An infix version of <a>setParam</a> with flipped arguments.
(~$) :: (Implicit s a => b) -> proxy s -> a -> b

-- | A left-associated version of <a>$</a>.
($$) :: (a -> b) -> a -> b

-- | The constraint <tt><a>Implicit_</a> String</tt> on a function
--   <tt>f</tt> indicates that an unnamed implicit parameter of type
--   <tt>String</tt> is passed to <tt>f</tt>.
class Implicit_ a
param_ :: Implicit_ a => a

-- | <a>setParam_</a> supplies a value for an unnamed implicit parameter to
--   a function which takes a homotypic implicit parameter.
setParam_ :: a -> (Implicit_ a => b) -> b

-- | An infix version of <a>setParam_</a> with flipped arguments.
($~) :: (Implicit_ a => b) -> a -> b
instance Default a => Implicit_ a
instance Default a => Implicit k s a
