-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Arrows for "deep application"
--   
--   This library provides a framework for type-directed composition of
--   value editors (non-syntactic transformations). The tools enable "deep
--   function application" in two senses: deep application of functions and
--   application of deep functions. These tools generalize beyond values
--   and functions, via the <tt>DeepArrow</tt> subclass of the
--   <tt>Arrow</tt> type class.
--   
--   For more information see:
--   
--   <ul>
--   <li>The project wiki page
--   <a>http://haskell.org/haskellwiki/DeepArrow</a></li>
--   <li>Application of deep arrows for composable interfaces in the TV
--   library: <a>http://haskell.org/haskellwiki/TV</a></li>
--   <li>The motivating idea and paper <a>Tangible Functional
--   Programming</a>: <a>http://conal.net/papers/Eros</a></li>
--   </ul>
--   
--   The primary module is <a>Control.Arrow.DeepArrow</a>. Examples in
--   <a>Control.Arrow.DeepArrow.Examples</a>.
--   
--   <i>Note</i>: Many of the type signatures use infix type operators (as
--   in <tt>a~&gt;b</tt>). In reading the documentation and code, be aware
--   that infix operators bind more tightly than <tt>-&gt;</tt>.
--   
--   Â© 2007-2012 by Conal Elliott (<a>http://conal.net</a>); BSD3 license.
@package DeepArrow
@version 0.4.0


-- | Insert parens where necessary in Haskell expressions. Inspired by
--   Sigbjorn Finne's Pan pretty-printer.
module Language.Haskell.Parens
pretty :: HsExp -> String
type Cify a = a -> (Context -> a)
cifyExp :: Cify HsExp
unCify :: (Context -> a) -> a
hasOpInfo :: HsName -> Bool
instance Eq Assoc


-- | Convert values to Haskell abstract syntax
module Language.Haskell.ToHs

-- | Conversion to Haskell expressions
class ToHsExp a
toHsExp :: ToHsExp a => a -> HsExp
varid :: String -> HsExp
varsym :: String -> HsExp
toHsApp1 :: ToHsExp a => String -> a -> HsExp
toHsApp2 :: (ToHsExp a, ToHsExp b) => String -> a -> b -> HsExp
infixApp :: HsName -> HsExp -> HsExp -> HsExp
toHsInfix :: (ToHsExp a, ToHsExp b) => HsName -> a -> b -> HsExp
prettyAsHsExp :: ToHsExp a => a -> String
instance ToHsExp Bool
instance ToHsExp Double
instance ToHsExp Float
instance ToHsExp Int
instance ToHsExp String
instance ToHsExp Char


-- | Conversion between arrow values and wrapped functions.
module Data.FunArr

-- | Convert between an arrow value and a "wrapped function". The "arrow"
--   doesn't really have to be an arrow. I'd appreciate ideas for names
--   &amp; uses.
class FunArr ar w | ar -> w, w -> ar
toArr :: FunArr ar w => w (a -> b) -> (a ar b)
($$) :: FunArr ar w => (a ar b) -> w a -> w b
instance (FunArr ar w, FunArr ar' w') => FunArr (ar ::*:: ar') (w :*: w')
instance FunArr (->) Id


-- | "Deep arrows" as an <a>Arrow</a> subclass.
module Control.Arrow.DeepArrow

-- | Arrows for deep application. Most of these methods could be defined
--   using <a>arr</a>, but <a>arr</a> is not definable for some types. If
--   your <a>DeepArrow</a> instance has <a>arr</a>, you might want to use
--   these implementations
--   
--   <pre>
--   <a>fstA</a>     = <a>arr</a> <a>fst</a>
--   <a>dupA</a>     = <a>arr</a> (\ x -&gt; (x,x))
--   <a>sndA</a>     = <a>arr</a> <a>snd</a>
--   <a>funF</a>     = <a>arr</a> (\ (f,b) -&gt; \ c -&gt; (f c, b))
--   <a>funS</a>     = <a>arr</a> (\ (a,f) -&gt; \ c -&gt; (a, f c))
--   <a>funR</a>     = <a>arr</a> <a>flip</a>
--   <a>curryA</a>   = <a>arr</a> <a>curry</a>
--   <a>uncurryA</a> = <a>arr</a> <a>uncurry</a>
--   <a>swapA</a>    = <a>arr</a> (\ (a,b) -&gt; (b,a))
--   <a>lAssocA</a>  = <a>arr</a> (\ (a,(b,c)) -&gt; ((a,b),c))
--   <a>rAssocA</a>  = <a>arr</a> (\ ((a,b),c) -&gt; (a,(b,c)))
--   </pre>
--   
--   If your <a>DeepArrow</a> instance <i>does not</i> have <a>arr</a>,
--   you'll have to come up with other definitions. In any case, I
--   recommend the following definitions, which mirror <a>Arrow</a>
--   defaults while avoiding <a>arr</a>. Be sure also to define <a>arr</a>
--   or <tt>pure</tt> to yield an error message (rather than ping-ponging
--   infinitely between them via the <a>Arrow</a> default definitions).
--   
--   <pre>
--   <a>second</a> f = <a>swapA</a> <a>.</a> <a>first</a> f <a>.</a> <a>swapA</a>
--   f <a>&amp;&amp;&amp;</a> g  = <a>dupA</a>  <a>&gt;&gt;&gt;</a> f <a>***</a> g
--   </pre>
--   
--   In a few cases, there are default methods, as noted below. The
--   defaults do not use <a>arr</a>.
class Arrow ar => DeepArrow ar where swapA = sndA &&& fstA lAssocA = second fstA &&& (sndA . sndA) rAssocA = (fstA . fstA) &&& first sndA
result :: DeepArrow ar => (b ar b') -> ((a -> b) ar (a -> b'))
dupA :: DeepArrow ar => a ar (a, a)
fstA :: DeepArrow ar => (a, b) ar a
sndA :: DeepArrow ar => (a, b) ar b
funF :: DeepArrow ar => (c -> a, b) ar (c -> (a, b))
funS :: DeepArrow ar => (a, c -> b) ar (c -> (a, b))
funR :: DeepArrow ar => (a -> c -> b) ar (c -> a -> b)
curryA :: DeepArrow ar => ((a, b) -> c) ar (a -> b -> c)
uncurryA :: DeepArrow ar => (a -> b -> c) ar ((a, b) -> c)
swapA :: DeepArrow ar => (a, b) ar (b, a)
lAssocA :: DeepArrow ar => (a, (b, c)) ar ((a, b), c)
rAssocA :: DeepArrow ar => ((a, b), c) ar (a, (b, c))

-- | Promote a function extractor into one that reaches into the first
--   element of a pair.
funFirst :: DeepArrow ar => (a ar (d -> a')) -> ((a, b) ar (d -> (a', b)))

-- | Promote a function extractor into one that reaches into the second
--   element of a pair.
funSecond :: DeepArrow ar => (b ar (d -> b')) -> ((a, b) ar (d -> (a, b')))

-- | Promote a function extractor into one that reaches into the result
--   element of a function.
funResult :: DeepArrow ar => (b ar (d -> b')) -> ((a -> b) ar (d -> (a -> b')))

-- | Extract the first component of a pair input.
inpF :: DeepArrow ar => ((a, b) -> c) ar (a -> (b -> c))

-- | Extract the second component of a pair input.
inpS :: DeepArrow ar => ((a, b) -> c) ar (b -> (a -> c))

-- | Given a way to extract a <tt>d</tt> input from an <tt>a</tt> input,
--   leaving an <tt>a'</tt> residual input, <a>inpFirst</a> yields a way to
--   extract a <tt>d</tt> input from an <tt>(a,b)</tt> input, leaving an
--   <tt>(a',b)</tt> residual input.
inpFirst :: DeepArrow ar => ((a -> c) ar (d -> (a' -> c))) -> (((a, b) -> c) ar (d -> ((a', b) -> c)))

-- | Analogous to <a>inpFirst</a>.
inpSecond :: DeepArrow ar => ((b -> c) ar (d -> (b' -> c))) -> (((a, b) -> c) ar (d -> ((a, b') -> c)))

-- | Flip argument order
flipA :: DeepArrow ar => (a -> c -> b) ar (c -> a -> b)

-- | Like <a>unzip</a> but for <a>DeepArrow</a> arrows instead of lists.
unzipA :: DeepArrow ar => (a ar (b, c)) -> (a ar b, a ar c)

-- | Support needed for a <a>FunA</a> to be a <a>DeepArrow</a> (as
--   <a>FunAble</a> serves <a>Arrow</a>).
class FunAble h => FunDble h
resultFun :: FunDble h => (h b -> h b') -> (h (a -> b) -> h (a -> b'))
dupAFun :: FunDble h => h a -> h (a, a)
fstAFun :: FunDble h => h (a, b) -> h a
sndAFun :: FunDble h => h (a, b) -> h b
funFFun :: FunDble h => h (c -> a, b) -> h (c -> (a, b))
funSFun :: FunDble h => h (a, c -> b) -> h (c -> (a, b))
funRFun :: FunDble h => h (a -> c -> b) -> h (c -> a -> b)
curryAFun :: FunDble h => h ((a, b) -> c) -> h (a -> b -> c)
uncurryAFun :: FunDble h => h (a -> b -> c) -> h ((a, b) -> c)
swapAFun :: FunDble h => h (a, b) -> h (b, a)
lAssocAFun :: FunDble h => h (a, (b, c)) -> h ((a, b), c)
rAssocAFun :: FunDble h => h ((a, b), c) -> h (a, (b, c))

-- | Compose wrapped functions
(->|) :: (DeepArrow ar, FunArr ar w) => w (a -> b) -> w (b -> c) -> w (a -> c)
instance FunDble h => DeepArrow (FunA h)
instance (DeepArrow ar, DeepArrow ar') => DeepArrow (ar ::*:: ar')
instance DeepArrow (->)


-- | "Deep arrows" as a data type. Handy for code generation.
module Data.DDeepArrow

-- | This GADT mirrors the <a>DeepArrow</a> class and part of the
--   <a>FunArr</a> class.
data DArrow :: * -> * -> *
Arr :: DVal (a -> b) -> a DArrow b
Compose :: a DArrow b -> b DArrow c -> a DArrow c
First :: a DArrow a' -> (a, b) DArrow (a', b)
Second :: b DArrow b' -> (a, b) DArrow (a, b')
Result :: b DArrow b' -> (a -> b) DArrow (a -> b')
FunF :: (c -> a, b) DArrow (c -> (a, b))
FunS :: (a, c -> b) DArrow (c -> (a, b))
FunR :: (a -> c -> b) DArrow (c -> a -> b)
CurryA :: ((a, b) -> c) DArrow (a -> b -> c)
UncurryA :: (a -> b -> c) DArrow ((a, b) -> c)
LAssocA :: (a, (b, c)) DArrow ((a, b), c)
RAssocA :: ((a, b), c) DArrow (a, (b, c))
IdA :: a DArrow a
DupA :: a DArrow (a, a)
FstA :: (a, b) DArrow a
SndA :: (a, b) DArrow b
SwapA :: (a, b) DArrow (b, a)

-- | A GADT alternative to terms. Allows generation of Haskell terms and,
--   from there, strings and eval.
data DVal :: * -> *
ExpDV :: HsExp -> DVal a
AppDA :: a DArrow b -> DVal a -> DVal b
ZipDV :: DVal a -> DVal b -> DVal (a, b)
instance Show (DVal a)
instance Show (DArrow a b)
instance FunArr DArrow DVal
instance ToHsExp (DVal a)
instance ToHsExp (DArrow a b)
instance Zip DVal
instance DeepArrow DArrow
instance Arrow DArrow
instance Category DArrow


-- | DeepArrow examples.
--   
--   The types in the source code are formatted for easier reading.
module Control.Arrow.DeepArrow.Examples

-- | Given a value of type <tt>(a -&gt; (f,b -&gt; (c,g)),e)</tt>, apply a
--   function to just the <tt>c</tt> part and leave the rest intact.
--   
--   <pre>
--   deep = <a>first</a> . <a>result</a> . <a>second</a> . <a>result</a> . <a>first</a>
--   </pre>
deep :: DeepArrow ar => (c ar c') -> (a -> (f, b -> (c, g)), e) ar (a -> (f, b -> (c', g)), e)

-- | Given a way to extract a function from a <tt>d</tt> value, create a
--   way to extract a function from a <tt>(e -&gt; (a,d), f)</tt> value.
--   
--   <pre>
--   extF = <a>funFirst</a> . <a>funResult</a> . <a>funSecond</a>
--   </pre>
extF :: DeepArrow ar => (d ar (c -> b)) -> (e -> (a, d), f) ar (c -> (e -> (a, b), f))

-- | To make an extractor, simply apply the extractor-transformer
--   <a>extF</a> to the identity arrow.
--   
--   <pre>
--   <a>extFF</a> = <a>extF</a> <tt>idA</tt>
--   </pre>
extFF :: DeepArrow ar => (e -> (a, c -> b), f) ar (c -> (e -> (a, b), f))

-- | Extract a <tt>b</tt> input from a <tt>((a,(b,e)),c)</tt> argument.
--   
--   <pre>
--   extI = (<a>inpFirst</a> . <a>inpSecond</a>) <a>inpF</a>
--   </pre>
extI :: DeepArrow ar => (((a, (b, e)), c) -> d) ar (b -> ((a, e), c) -> d)

-- | Typically, we will have to combine function and input extractors. For
--   instance, combine <a>extF</a> and <a>extI</a>.
--   
--   <pre>
--   extFI = <a>extF</a> <a>extI</a>
--   </pre>
extFI :: DeepArrow ar => (e -> (g, ((a, (b, e)), c) -> d), f) ar (b -> (e -> (g, ((a, e), c) -> d), f))
