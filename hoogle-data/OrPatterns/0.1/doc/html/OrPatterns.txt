-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A quasiquoter for or-patterns
--   
--   A quasiquoter for or-patterns. It allows one additional form for
--   patterns:
--   
--   <pre>
--   f [o| p1 | p2 | p3 |] = rhs
--   </pre>
--   
--   Above, <tt>p1</tt>, <tt>p2</tt> and <tt>p3</tt> are three arbitrary
--   patterns that bind the same variables. These variables are available
--   in the expression <tt>rhs</tt>. Nesting of or-patterns is not
--   supported yet.
--   
--   See also:
--   
--   <ul>
--   <li>http:<i></i>hackage.haskell.org<i>package</i>first-class-patterns
--   supports <tt>\/</tt> (or). However, variables bound with those
--   patterns are not named. This means:</li>
--   </ul>
--   
--   <pre>
--   g :: Either (x, y) (y, x) -&gt; (x, y)
--   g [o| Left (x,y) | Right (y,x) |] = (x,y)
--   </pre>
--   
--   <pre>
--   -- ends up slightly longer
--   g = elim $ left (pair var var) \/ right flipped -&gt;&gt; (,)
--    where
--     flipped = (\(a,b) -&gt; (b,a)) --&gt; pair var var
--   </pre>
--   
--   <ul>
--   <li>http:<i></i>hackage.haskell.org<i>trac</i>ghc<i>ticket</i>3919 is
--   the feature request for or-patterns in ghc</li>
--   </ul>
@package OrPatterns
@version 0.1


module OrPatterns.Internal

-- | parser used in <a>o</a>
pats :: String -> Either String PatQ
tryParseSplits :: [s] -> ([s] -> Either e r) -> [[s]] -> Either e [r]
combineSplits :: [Pat] -> Either String PatQ


-- | Quasiquoter for <i>or patterns</i> separated by <tt>" | "</tt>, like
--   other languages (ML family).
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XQuasiQuotes -XViewPatterns -w
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   
--   &gt;&gt;&gt; let f :: Either (a,b) (b,a) -&gt; (a,b)
--   
--   &gt;&gt;&gt; f [o| Left (x,y) | Right (y,x) |] = (x,y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map f [Left ('a',0), Right (2, 'b')]
--   [('a',0),('b',2)]
--   </pre>
--   
--   A more confusing example (to show that the string <a> | </a> is
--   interpreted correctly by the parser):
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   
--   &gt;&gt;&gt; let g [o| " | " | "|||" | "  |  " |] = True
--   
--   &gt;&gt;&gt; g _ = False
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map g [ "|", " | " , "|||" , "  |  "]
--   [False,True,True,True]
--   </pre>
--   
--   f is desugared to something like:
--   
--   <pre>
--   f ( (\v -&gt; case v of
--               Left (x,y) -&gt; Just (x,y)
--               Right (y,x) -&gt; Just (x,y)
--               _ -&gt; Nothing
--        ) -&gt; Just (x,y) ) = (x,y)
--   </pre>
--   
--   So failing to match will pass on to the next equation.
--   
--   Limitations include:
--   
--   <ul>
--   <li>compilation could probably be more efficient</li>
--   <li>incorrect patterns, such as those binding the wrong variables or
--   the wrong number of variables could be reported better</li>
--   <li>generated code can have overlapped patterns, and so -Wall doesn't
--   help the above example. Duplicating or using ghc's check for this
--   should be done, in which case the the desugared code should look like
--   <i>f2</i>.</li>
--   </ul>
--   
--   <pre>
--   f2 ( (\v -&gt; case v of
--           Left (x,y) -&gt; (x,y)
--           Right (y,x) -&gt; (x,y))
--          -&gt; a) = a
--   </pre>
module OrPatterns

-- | or pattern quasiquote. See above.
o :: QuasiQuoter
