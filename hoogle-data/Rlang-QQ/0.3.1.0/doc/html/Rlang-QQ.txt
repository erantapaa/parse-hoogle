-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | quasiquoter for inline-R code
--   
@package Rlang-QQ
@version 0.3.1.0

module RlangQQ.ParseKnitted

-- | splits up the contents of the .md file generated by
--   <tt>knitr::knit</tt>
parseKnitted :: String -> [KnitInteraction]
data KnitInteraction
KnitInteraction :: String -> [KnitOutput] -> KnitInteraction
data KnitOutput

-- | has markup to be interpreted
KnitAsIs :: String -> KnitOutput
KnitPrint :: String -> KnitOutput
KnitWarning :: String -> KnitOutput
KnitError :: String -> KnitOutput

-- | <pre>
--   ![caption](pathToImage)
--   </pre>
KnitImage :: String -> FilePath -> KnitOutput
instance Show KnitOutput
instance Show KnitInteraction


-- | functions to help making lists for consumption on the R side
module RlangQQ.MakeRecord

-- | convert a haskell list into a record with labels all of type "". The
--   length of the list is decided by the (type of the) first argument
--   which is a <a>HNat</a>
--   
--   <pre>
--   listToRecN :: _ =&gt; Proxy (n :: HNat) -&gt; [x] -&gt; Record (HReplicateR n (Tagged "" x))
--   </pre>
listToRecN :: (HAllTaggedLV (HReplicateR * n (Tagged Symbol "" x)), SameLabels [*] [*] (HReplicateR * n (Tagged Symbol "" x)) (HReplicateR * n (Tagged Symbol "" x)), SameLength' * * (RecordValuesR (HReplicateR * n (Tagged Symbol "" x))) (RecordValuesR (HReplicateR * n (Tagged Symbol "" x))), SameLength' * * (HReplicateR * n (Tagged Symbol "" x)) (HReplicateR * n (Tagged Symbol "" x)), HList2List (RecordValuesR (HReplicateR * n (Tagged Symbol "" x))) x, HMapAux HList TaggedFn (RecordValuesR (HReplicateR * n (Tagged Symbol "" x))) (HReplicateR * n (Tagged Symbol "" x)), RecordValues (HReplicateR * n (Tagged Symbol "" x))) => Proxy HNat n -> [x] -> Record (HReplicateR * n (Tagged Symbol "" x))

module RlangQQ.NatQQ

-- | HList uses it's own nat, distinct from <a>Nat</a>, for various
--   reasons.
--   
--   Specifying those <a>HNat</a> can be done like:
--   
--   <pre>
--   [n| 5 |]
--   </pre>
--   
--   which is shorter than the equivalent
--   
--   <pre>
--   hSucc $ hSucc $ hSucc $ hSucc $ hSucc hZero
--   </pre>
n :: QuasiQuoter

module RlangQQ.Antiquote
extractAntiquotes :: Parser [Either Exp String]


-- | Conversions between R's RDS/RDA format and haskell data types.
--   
--   tested with R 3.0.1
--   
--   Missing:
--   
--   <ul>
--   <li>Data.Map</li>
--   <li>better error reporting when the format is bad?</li>
--   <li>more tests</li>
--   </ul>
module RlangQQ.Binary
toRDA :: (ToRDS (RDA (RecordValuesR r)), RecordValues r) => Record r -> ByteString
fromRDA :: FromRDA r => ByteString -> Record r

-- | same as Binary but should be compatible with R's <tt>saveRDS</tt>
--   binary mode, which is for single objects
class ToRDS a
toRDS :: ToRDS a => a -> Put
class FromRDS a
fromRDS :: FromRDS a => Get a
type FromRDA r = (Unlabeled' r, FromRDS (RDA (RecordValuesR r)))
type ToRDSRecord __ ___ xs = (RDSHLIST __ ___, ToRDS (LST ___), RecordValues xs, HList ___ ~ (HList (RecordValuesR xs) `HAppendR` HList '[ListStart, Tagged "names" [String]]), RecordLabelsString (LabelsOf xs), HAppend (HList (RecordValuesR xs)) (HList '[ListStart, Tagged "names" [String]]))
type RDSHLIST xs' xs = (HNat2Integral (HLength xs), HFoldr (HSeq FToRDS) Put xs Put)

-- | labels are stored with the variables here. compare with the instance
--   for <a>Record</a> / <a>LST</a> which collects the labels and saves
--   them as an attribute called "names"
data RDA a

-- | given <a>bounds</a> of an array, produce a list of how many elements
--   are in each dimension. For example, a 3x2 array produces [3,2].
--   
--   A single instance for "linear" indices would look like:
--   
--   <pre>
--   instance (A.Ix i, Num i) =&gt; IxSize i where
--       ixSize x = [fromIntegral (A.rangeSize x)]
--       fromIxSize [n] = (0, n-1)
--   </pre>
--   
--   But to avoid overlapping instances all monomorphic index types likely
--   to be used are just repeated here. fromIxSize produces 0-based indexes
--   for instances of <a>Num</a> (<a>Word</a>, <a>Int</a>, <a>Integer</a>),
--   while <a>minBound</a> is used for other types.
--   
--   R supports a dimnames attribute. This could be used but it is not so
--   far.
class Ix i => IxSize i
ixSize :: IxSize i => (i, i) -> [Int32]
fromIxSize :: IxSize i => [Int32] -> (i, i)
instance ToRDS (Map String AnyRDS)
instance ToRDS AnyRDS
instance Shape sh => FromRDS (Array U sh Int32)
instance Shape sh => FromRDS (Array U sh Double)
instance (Source r Int32, Shape sh) => ToRDS (Array r sh Int32)
instance (Source r Double, Shape sh) => ToRDS (Array r sh Double)
instance IxSize i => FromRDS (Array i Int32)
instance IxSize i => FromRDS (Array i Double)
instance IxSize i => ToRDS (Array i Int32)
instance IxSize i => ToRDS (Array i Double)
instance (IxSize a, IxSize b, IxSize c, IxSize d, IxSize e) => IxSize (a, b, c, d, e)
instance (IxSize a, IxSize b, IxSize c, IxSize d) => IxSize (a, b, c, d)
instance (IxSize a, IxSize b, IxSize c) => IxSize (a, b, c)
instance (IxSize a, IxSize b) => IxSize (a, b)
instance IxSize ()
instance IxSize Bool
instance IxSize Char
instance IxSize Ordering
instance IxSize Integer
instance IxSize Int64
instance IxSize Int32
instance IxSize Int16
instance IxSize Int8
instance IxSize Int
instance IxSize Word
instance IxSize Word16
instance IxSize Word32
instance IxSize Word64
instance IxSize Word8
instance FromRDS (RDA '[])
instance ToRDS (RDA '[])
instance (FromRDS t, FromRDS (RDA rs), ShowLabel l2) => FromRDS (RDA (Tagged l2 t : rs))
instance (ToRDS t, ToRDS (RDA rs), ShowLabel l2) => ToRDS (RDA (Tagged l2 t : rs))
instance (FromRDS t, ShowLabel l) => FromRDS (Tagged l t)
instance (ToRDS t, ShowLabel l) => ToRDS (Tagged l t)
instance FromRDS ListStart
instance ToRDS ListStart
instance FromRDS [Integer]
instance ToRDS [Integer]
instance FromRDS [Int]
instance ToRDS [Int]
instance FromRDS [Int32]
instance ToRDS [Int32]
instance FromRDS Integer
instance FromRDS Int
instance FromRDS Double
instance FromRDS Int32
instance ToRDS Int
instance ToRDS Integer
instance ToRDS Int32
instance ToRDS Double
instance FromRDS [Double]
instance ToRDS [Double]
instance (ShowLabel x, RecordLabelsString xs) => RecordLabelsString (Label x : xs)
instance RecordLabelsString '[]
instance (FromRDSRec b d) => FromRDS (Record d)
instance (ToRDSRecord __ ___ xs) => ToRDS (Record xs)
instance (RDSHLIST2 __ l) => FromRDS (LST l)
instance (RDSHLIST xs' xs) => ToRDS (LST xs)
instance (FromRDS b, Get b ~ getB, a ~ ()) => ApplyAB FFromRDS a getB
instance (ToRDS a, putm ~ Put) => ApplyAB FToRDS a putm
instance FromRDS String
instance ToRDS String
instance FromRDS [String]
instance ToRDS [String]
instance FromRDS Text
instance ToRDS Text
instance FromRDS (Vector Text)
instance ToRDS (Vector Text)
instance FromRDS (Vector Int32)
instance ToRDS (Vector Int32)
instance FromRDS (Vector Int32)
instance ToRDS (Vector Int32)
instance FromRDS (Vector Double)
instance FromRDS (Vector Double)
instance ToRDS (Vector Double)
instance ToRDS (Vector Double)
instance Wrapped (RDA a0)
instance RDA a1 ~ t0 => Rewrapped (RDA a0) t0

module RlangQQ.Internal

-- | going via binary serialization (classes from <a>RlangQQ.Binary</a>).
--   This is used in <a>r</a>
quoteRExpression2 :: Int -> Bool -> String -> Q Exp
unlessQ :: Bool -> ExpQ -> ExpQ
whenQ :: Bool -> ExpQ -> ExpQ
splitKnitrHdr :: String -> (String, String)
withRawFile :: String -> (String, ExpQ -> ExpQ)
addLambda :: Map Int (Set String) -> ExpQ -> ExpQ

-- | go from the variable name used on the R-side to the one in the haskell
--   side
dropHS :: [Char] -> [Char]
prefixes :: [[Char]]

-- | HList label
label :: [Char] -> ExpQ
label' :: String -> ExpQ
var :: [Char] -> ExpQ
mkHList :: [ExpQ] -> ExpQ
notOut :: Intent -> Bool
notIn :: Intent -> Bool
parseTree' :: Parser (Tree String)
parseTree :: Parser (Tree String)

-- | gets variables like <tt>abc</tt> provided the R file contained
--   <tt>hs_abc</tt>
hsVars :: Tree String -> [String]
labelTree :: Tree String -> Tree (String, Int)

-- | what is the usage of a <tt>hs_</tt> variable on the R side?
data Intent

-- | only read
In :: Intent

-- | only assigned to
Out :: Intent

-- | both
InOut :: Intent
classifyExp :: Tree String -> Maybe (String, Intent)
hsClassify :: Tree String -> Map String Intent
parseTreeTest2 :: IO ()
parseTreeTest3 :: String -> IO ()
parseTreeTest :: [Char] -> IO ()
getRlangQQ_n :: Q Int
rlangQQ_n :: IORef Int
instance Show Intent
instance Eq Intent


-- | A quasiquoter to help with calling <a>R</a> from ghc.
module RlangQQ

-- | Calls R with the supplied string. Variables in R prefixed hs_ cause
--   the corresponding (un-prefixed) variable to be converted. The
--   variable(s) must be in at least one class <a>FromRDS</a> or
--   <a>ToRDS</a>. Currently the relation between where variables are used
--   and assigned to (using <tt>&lt;-</tt>) determines the <a>Intent</a>.
--   
--   Expressions are also supported. These must be text between $( ), just
--   like template haskell. One condition is that the contents between the
--   parentheses must be parseable by haskell-src-meta/haskell-src-exts. So
--   if you find the hs_ notation unpleasant you can still interpolate
--   using $(x).
--   
--   An example of both styles is
--   
--   <pre>
--   import RlangQQ
--   
--   x = [0 .. 10  :: Double]
--   
--   main = do
--     [r|
--       library(ggplot2)
--       png(file='test.png')
--       plot(qplot( hs_x, $(map (sin . (*pi) . (/10)) x) ))
--       dev.off()
--       |]
--   </pre>
--   
--   You get a plot:
--   
--   While it is only somewhat usable, you can have Rnw/Rmd documents
--   (knitr) that include haskell code. One example is given <a>here</a>. A
--   second option is to use <a>IHaskell</a>, for which there are two
--   example notebooks in the same
--   <a>http://code.haskell.org/~aavogt/Rlang-QQ/examples</a>
r :: QuasiQuoter

-- | <tt>[rChan| |]</tt> does the same as [r| |], except the return value
--   will be a <tt>Chan (Record a)</tt>.
rChan :: QuasiQuoter

-- | same as Binary but should be compatible with R's <tt>saveRDS</tt>
--   binary mode, which is for single objects
class ToRDS a
class FromRDS a

-- | convert a haskell list into a record with labels all of type "". The
--   length of the list is decided by the (type of the) first argument
--   which is a <a>HNat</a>
--   
--   <pre>
--   listToRecN :: _ =&gt; Proxy (n :: HNat) -&gt; [x] -&gt; Record (HReplicateR n (Tagged "" x))
--   </pre>
listToRecN :: (HAllTaggedLV (HReplicateR * n (Tagged Symbol "" x)), SameLabels [*] [*] (HReplicateR * n (Tagged Symbol "" x)) (HReplicateR * n (Tagged Symbol "" x)), SameLength' * * (RecordValuesR (HReplicateR * n (Tagged Symbol "" x))) (RecordValuesR (HReplicateR * n (Tagged Symbol "" x))), SameLength' * * (HReplicateR * n (Tagged Symbol "" x)) (HReplicateR * n (Tagged Symbol "" x)), HList2List (RecordValuesR (HReplicateR * n (Tagged Symbol "" x))) x, HMapAux HList TaggedFn (RecordValuesR (HReplicateR * n (Tagged Symbol "" x))) (HReplicateR * n (Tagged Symbol "" x)), RecordValues (HReplicateR * n (Tagged Symbol "" x))) => Proxy HNat n -> [x] -> Record (HReplicateR * n (Tagged Symbol "" x))

-- | HList uses it's own nat, distinct from <a>Nat</a>, for various
--   reasons.
--   
--   Specifying those <a>HNat</a> can be done like:
--   
--   <pre>
--   [n| 5 |]
--   </pre>
--   
--   which is shorter than the equivalent
--   
--   <pre>
--   hSucc $ hSucc $ hSucc $ hSucc $ hSucc hZero
--   </pre>
n :: QuasiQuoter

-- | <a>newChan</a> with a more restricted type
newRChan :: IO (Chan (a, b -> IO ()))

-- | <tt>newRChan (undefined :: Double)</tt> produces an even more
--   restricted type than <a>newRChan'</a>, which can help make type errors
--   more sensible and/or avoid <tt>ambiguous type variable</tt>
newRChan' :: a -> IO (Chan (a, b -> IO ()))

-- | <tt>y &lt;- sendRcv c x</tt> sends the value <tt>x</tt> using the chan
--   <tt>c</tt>. Provided that an <tt>[r| |]</tt> quasiquote above refers
--   to a <tt>ch_c</tt>, the call to <a>sendRcv</a> will eventually produce
--   a <a>Record</a> <tt>y</tt> which provides a reference to all the
--   output variables that R calculated with the given <tt>x</tt>.
sendRcv :: Chan (t, b -> IO ()) -> t -> IO b
