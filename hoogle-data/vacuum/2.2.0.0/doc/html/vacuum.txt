-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Graph representation of the GHC heap
--   
--   Vacuum is a library for extracting graph representations of values
--   from the GHC heap at runtime. Those graphs may then be further
--   processed or translated to various representations for visualization
--   -- like Graphviz, or Ubigraph.
--   
--   By itself this library is not of much use to most users, unless you
--   want to use the raw graph data to visualize the heap in some (new)
--   way. Most people will want to translate the graph representation to
--   something like GraphViz format, which can then be rendered to a pretty
--   PNG or SVG file for viewing. See the <tt>vacuum-graphviz</tt> package
--   for more.
@package vacuum
@version 2.2.0.0

module GHC.Vacuum.ClosureType.V706
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_STATIC :: ClosureType
CONSTR_NOCAF_STATIC :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_PERM :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_DYN :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN0 :: ClosureType
MUT_ARR_PTRS_FROZEN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
N_CLOSURE_TYPES :: ClosureType
instance Eq ClosureType
instance Ord ClosureType
instance Show ClosureType
instance Read ClosureType
instance Enum ClosureType


-- | Internal vacuum module. You probably shouldn't be here.
module GHC.Vacuum.Internal
type HValue = Any
type HalfWord = Word32
type ItblCode = Word8
data StgInfoTable
StgInfoTable :: HalfWord -> HalfWord -> HalfWord -> HalfWord -> [ItblCode] -> StgInfoTable
ptrs :: StgInfoTable -> HalfWord
nptrs :: StgInfoTable -> HalfWord
tipe :: StgInfoTable -> HalfWord
srtlen :: StgInfoTable -> HalfWord
code :: StgInfoTable -> [ItblCode]

-- | This is currently always True since i'm not sure how to get at the CPP
--   define "" (or equiv) to tell.
ghciTablesNextToCode :: Bool
dataConInfoPtrToNames :: Ptr () -> IO (String, String, String)
wORD_SIZE :: Int
hALF_WORD_SIZE :: Int
newtype S s a
S :: (forall o. (a -> s -> IO o) -> s -> IO o) -> S s a
unS :: S s a -> forall o. (a -> s -> IO o) -> s -> IO o
get :: S s s
gets :: (s -> a) -> S s a
set :: s -> S s ()
io :: IO a -> S s a
modify :: (s -> s) -> S s ()
runS :: S s a -> s -> IO (a, s)
instance MonadFix (S s)
instance Monad (S s)
instance Applicative (S s)
instance Functor (S s)
instance Storable StgInfoTable


-- | This module exports the different kind of closure types there are per
--   GHC version.
--   
--   NOTE: the <a>ClosureType</a> datatype is automatically generated,
--   based on the version of GHC, and the proper one is included for you.
module GHC.Vacuum.ClosureType
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_STATIC :: ClosureType
CONSTR_NOCAF_STATIC :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_PERM :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_DYN :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN0 :: ClosureType
MUT_ARR_PTRS_FROZEN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
N_CLOSURE_TYPES :: ClosureType
isFun :: ClosureType -> Bool
isThunk :: ClosureType -> Bool
isCon :: ClosureType -> Bool


module GHC.Vacuum.Types
type HNodeId = Int
data HNode
HNode :: [HNodeId] -> [Word] -> InfoTab -> HNode
nodePtrs :: HNode -> [HNodeId]
nodeLits :: HNode -> [Word]
nodeInfo :: HNode -> InfoTab
emptyHNode :: ClosureType -> HNode
nodePkg :: HNode -> String
nodeMod :: HNode -> String
nodeName :: HNode -> String
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
trd3 :: (a, b, c) -> c
itabName :: InfoTab -> (String, String, String)
summary :: HNode -> ([String], [HNodeId], [Word])
data InfoTab
ConInfo :: String -> String -> String -> Word -> Word -> ClosureType -> Word -> [Word] -> InfoTab
itabPkg :: InfoTab -> String
itabMod :: InfoTab -> String
itabCon :: InfoTab -> String
itabPtrs :: InfoTab -> Word
itabLits :: InfoTab -> Word
itabType :: InfoTab -> ClosureType
itabSrtLen :: InfoTab -> Word
itabCode :: InfoTab -> [Word]
OtherInfo :: Word -> Word -> ClosureType -> Word -> [Word] -> InfoTab
itabPtrs :: InfoTab -> Word
itabLits :: InfoTab -> Word
itabType :: InfoTab -> ClosureType
itabSrtLen :: InfoTab -> Word
itabCode :: InfoTab -> [Word]
data Closure
Closure :: [HValue] -> [Word] -> InfoTab -> Closure
closPtrs :: Closure -> [HValue]
closLits :: Closure -> [Word]
closITab :: Closure -> InfoTab
data Box a
Box :: a -> Box a
data Env
Env :: HNodeId -> IntMap [(StableName HValue, HNodeId)] -> IntMap (Box HValue) -> IntMap HNode -> Env
uniq :: Env -> HNodeId
seen :: Env -> IntMap [(StableName HValue, HNodeId)]
hvals :: Env -> IntMap (Box HValue)
graph :: Env -> IntMap HNode
emptyEnv :: Env
instance Eq InfoTab
instance Ord InfoTab
instance Read InfoTab
instance Show InfoTab
instance Eq HNode
instance Ord HNode
instance Read HNode
instance Show HNode
instance Show Closure
instance Show HValue


module GHC.Vacuum.Pretty
toAdjPair :: (HNodeId, HNode) -> (Int, [Int])
toAdjList :: IntMap HNode -> [(Int, [Int])]
nameGraph :: IntMap HNode -> [(String, [String])]
data ShowHNode
ShowHNode :: (Int -> HNode -> String) -> (Int -> String) -> ShowHNode
showHNode :: ShowHNode -> Int -> HNode -> String
externHNode :: ShowHNode -> Int -> String
showHNodes :: ShowHNode -> IntMap HNode -> [(String, [String])]

-- | To assist in "rendering" the graph to some source.
data Draw e v m a
Draw :: (Int -> a -> m v) -> (v -> v -> m e) -> (a -> [Int]) -> Draw e v m a
mkV :: Draw e v m a -> Int -> a -> m v
mkE :: Draw e v m a -> v -> v -> m e
succs :: Draw e v m a -> a -> [Int]
newtype G e v
G :: IntMap (v, IntMap e) -> G e v
unG :: G e v -> IntMap (v, IntMap e)
draw :: Monad m => Draw e v m a -> IntMap a -> m (G e v)

-- | An example <tt>Draw</tt>
printDraw :: Draw (Int, Int) Int IO HNode

-- | Build a map to <tt>(preds,succs)</tt>
split :: (a -> [Int]) -> IntMap a -> IntMap ([Int], [Int])
instance (Eq e, Eq v) => Eq (G e v)
instance (Ord e, Ord v) => Ord (G e v)
instance (Read e, Read v) => Read (G e v)
instance (Show e, Show v) => Show (G e v)


module GHC.Vacuum.Q
data Ref a
ref :: a -> IO (Ref a)
(!) :: Ref a -> IO a
(.=) :: Ref a -> a -> IO ()
(!=) :: Ref a -> (a -> (a, b)) -> IO b
data Q a
isEmptyQ :: Q a -> IO Bool
newQ :: IO (Q a)
putQ :: Q a -> a -> IO ()
takeQ :: Q a -> IO a
tryTakeQ :: Q a -> IO (Maybe a)
drainQ :: Q a -> IO [a]
getQContents :: Q a -> IO [a]
takeWhileQ :: (a -> Bool) -> Q a -> IO [a]


-- | <tt>vacuum</tt> is a library that allows you to look at the graph
--   representation of an arbitrary value or expression.
--   
--   Evaluation in Haskell proceeds by <i>graph reduction</i>, where values
--   on the GHC heap are represented in a graph structure, and where nodes
--   in the graph represent things like constructors or regular values.
--   With this library, you can extract the graph representation of said
--   heap values, and display them in meaningful ways to observe properties
--   like sharing, or a birds eye view of how much memory you're using.
--   
--   By itself, this module and package is not very useful to the end user
--   - it is meant to be consumed by those who would want to visualise the
--   abstract graph output in some meaningful way, using graphviz or
--   ubigraph, for example.
--   
--   If you are an end user who wants to visualize their data structures
--   and nothing more, please look at the <tt>vacuum-graphviz</tt> package,
--   which exports convenient APIs for rendering the output graphs into
--   pretty PNG/SVG files.
module GHC.Vacuum
type HNodeId = Int
data HNode
HNode :: [HNodeId] -> [Word] -> InfoTab -> HNode
nodePtrs :: HNode -> [HNodeId]
nodeLits :: HNode -> [Word]
nodeInfo :: HNode -> InfoTab
emptyHNode :: ClosureType -> HNode
summary :: HNode -> ([String], [HNodeId], [Word])

-- | Vacuums the entire reachable heap subgraph rooted at the <tt>a</tt>.
vacuum :: a -> IntMap HNode

-- | Stop after a given depth.
vacuumTo :: Int -> a -> IntMap HNode

-- | Doesn't force anything.
vacuumLazy :: a -> IntMap HNode

-- | Returns nodes as it encounters them.
vacuumStream :: a -> [(HNodeId, HNode)]
vacuumDebug :: a -> IntMap [(StableName HValue, HNodeId)]
dump :: a -> IO (IntMap HNode)
dumpTo :: Int -> a -> IO (IntMap HNode)
dumpLazy :: a -> IO (IntMap HNode)
toAdjList :: IntMap HNode -> [(Int, [Int])]
toAdjPair :: (HNodeId, HNode) -> (Int, [Int])
nameGraph :: IntMap HNode -> [(String, [String])]
data ShowHNode
ShowHNode :: (Int -> HNode -> String) -> (Int -> String) -> ShowHNode
showHNode :: ShowHNode -> Int -> HNode -> String
externHNode :: ShowHNode -> Int -> String
showHNodes :: ShowHNode -> IntMap HNode -> [(String, [String])]

-- | To assist in "rendering" the graph to some source.
data Draw e v m a
Draw :: (Int -> a -> m v) -> (v -> v -> m e) -> (a -> [Int]) -> Draw e v m a
mkV :: Draw e v m a -> Int -> a -> m v
mkE :: Draw e v m a -> v -> v -> m e
succs :: Draw e v m a -> a -> [Int]
newtype G e v
G :: IntMap (v, IntMap e) -> G e v
unG :: G e v -> IntMap (v, IntMap e)
draw :: Monad m => Draw e v m a -> IntMap a -> m (G e v)

-- | An example <tt>Draw</tt>
printDraw :: Draw (Int, Int) Int IO HNode

-- | Build a map to <tt>(preds,succs)</tt>
split :: (a -> [Int]) -> IntMap a -> IntMap ([Int], [Int])
data Closure
Closure :: [HValue] -> [Word] -> InfoTab -> Closure
closPtrs :: Closure -> [HValue]
closLits :: Closure -> [Word]
closITab :: Closure -> InfoTab
data InfoTab
ConInfo :: String -> String -> String -> Word -> Word -> ClosureType -> Word -> [Word] -> InfoTab
itabPkg :: InfoTab -> String
itabMod :: InfoTab -> String
itabCon :: InfoTab -> String
itabPtrs :: InfoTab -> Word
itabLits :: InfoTab -> Word
itabType :: InfoTab -> ClosureType
itabSrtLen :: InfoTab -> Word
itabCode :: InfoTab -> [Word]
OtherInfo :: Word -> Word -> ClosureType -> Word -> [Word] -> InfoTab
itabPtrs :: InfoTab -> Word
itabLits :: InfoTab -> Word
itabType :: InfoTab -> ClosureType
itabSrtLen :: InfoTab -> Word
itabCode :: InfoTab -> [Word]

-- | This is in part borrowed from
--   <tt>RtClosureInspect.getClosureData</tt>.
getClosure :: a -> IO Closure
closureType :: a -> IO ClosureType
getInfoTab :: a -> IO InfoTab
getInfoPtr :: a -> Ptr StgInfoTable
peekInfoTab :: Ptr StgInfoTable -> IO InfoTab
nodePkg :: HNode -> String
nodeMod :: HNode -> String
nodeName :: HNode -> String
itabName :: InfoTab -> (String, String, String)
type HValue = Any
