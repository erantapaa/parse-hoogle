-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shorter, more generic functions for Multiplate.
--   
--   This module provides wrappers around some Multiplate functions to
--   spare the Projector argument. This makes it simpler to use them, and
--   they will work for any data type, but a simple instance definition has
--   to be supplied for each one.
@package multiplate-simplified
@version 0.0.0.2


-- | 0. Given these data types for a simple language:
--   
--   <pre>
--   data Prog a = Prog a [Decl]
--   
--   data Decl = VarDecl Var Expr
--             | FunDecl Var [Var] [Decl]
--             | Return Expr
--   
--   data Expr = Ref String
--             | Number Int
--             | Add Expr Expr
--             | Mul Expr Expr
--   
--   data Var = Var String
--   </pre>
--   
--   ----------------------------------------
--   
--   1. Define a <tt>Plate f</tt> data type
--   
--   The name of the fields should refer to the actual data type: they will
--   be prefixed with a "p" here. These field accessors are called
--   projectors for the given plate and the actual data type (see the
--   <tt>Projector p a</tt> type alias). You have to use projectors to
--   provide definition for the <tt>multiplate</tt> method, and also for
--   functions like <tt>foldFor</tt>. With this module, you only need
--   projectors for the <a>IsProjector</a> instance definition. (However
--   you do have to use projectors anyway if <tt>List, Maybe, (,)</tt>,
--   etc. are not part of the plate, in which case you have to explicitly
--   traverse them to expose their structure to Multiplate. See: point 3.)
--   
--   <pre>
--   data Plate f = Plate
--     { pProg :: forall a. Prog a -&gt; f (Prog a)
--     , pDecl :: Decl -&gt; f Decl
--     , pExpr :: Expr -&gt; f Expr
--     , pVar  :: Var  -&gt; f Var
--     }
--   </pre>
--   
--   ----------------------------------------
--   
--   2. Define <a>IsProjector</a> instances for <tt>Plate</tt> and all the
--   actual data types
--   
--   <pre>
--   instance IsProjector Plate (Prog a) where
--     getProjector _ _ = pProg
--   
--   instance IsProjector Plate Decl where
--     getProjector _ _ = pDecl
--   
--   instance IsProjector Plate Expr where
--     getProjector _ _ = pExpr
--   
--   instance IsProjector Plate Var where
--     getProjector _ _ = pVar
--   </pre>
--   
--   ----------------------------------------
--   
--   3. Define a single <tt>Multiplate</tt> instance for <tt>Plate</tt>
--   
--   Definitions required without this module are given in the comments.
--   (The "b" prefixes in functions stand for "build".)
--   
--   <pre>
--   instance Multiplate Plate where
--     mkPlate build = Plate (build pProg) (build pDecl) (build pExpr) (build pVar)
--     multiplate p  = Plate bProg bDecl bExpr bVar where
--   </pre>
--   
--   <pre>
--   -- you have to define these here to capture the 'p' parameter
--   constr &lt;$&gt;: a = constr &lt;$&gt; (getProjector p a) p a
--   appl   &lt;*&gt;: a = appl   &lt;*&gt; (getProjector p a) p a
--   infixl 4 &lt;$&gt;:
--   infixl 4 &lt;*&gt;:
--   </pre>
--   
--   <pre>
--   -- definitions:
--   </pre>
--   
--   <pre>
--   -- lists, maybe values, etc. have a Traversable instance, which has to be used for these [*]
--   bProg (Prog a decls)           = Prog &lt;$&gt; pure a &lt;*&gt; traverse (pDecl p) decls    
--   </pre>
--   
--   <pre>
--   bDecl (VarDecl var expr)       = VarDecl &lt;$&gt;: var &lt;*&gt;: expr
--   -- bDecl (VarDecl str expr)    = VarDecl &lt;$&gt; pVar p var &lt;*&gt; pExpr p expr
--   bDecl (FunDecl var vars decls) = FunDecl &lt;$&gt;: var &lt;*&gt; traverse (pVar p) vars &lt;*&gt; traverse (pDecl p) decls
--   bDecl (Return expr)            = Return &lt;$&gt;: expr
--   -- bDecl (Return expr)         = Return &lt;$&gt; pExpr p expr
--   </pre>
--   
--   <pre>
--   bExpr (Ref str)                = Ref &lt;$&gt; pure str
--   bExpr (Number int)             = Number &lt;$&gt; pure int
--   bExpr (Add expr expr')         = Add &lt;$&gt;: expr &lt;*&gt;: expr'
--   -- bExpr (Add expr expr')      = Add &lt;$&gt; pExpr p expr &lt;*&gt; pExpr p expr'
--   bExpr (Mul expr expr')         = Mul &lt;$&gt;: expr &lt;*&gt;: expr'
--   -- bExpr (Mul expr expr')      = Mul &lt;$&gt; pExpr p expr &lt;*&gt; pExpr p expr'
--   </pre>
--   
--   <pre>
--   bVar (Var str)                 = Var &lt;$&gt; pure str
--   </pre>
--   
--   [*] However, tuples for example are not <tt>Traversable</tt> (since
--   they don't have the appropriate kind) so instead of <tt>traverse</tt>
--   one can use a function like this:
--   
--   <pre>
--   traverseTuple fa fb (a, b) = (,) &lt;$&gt; fa a &lt;*&gt; fb b
--   
--   bConstr (Constr a b) = Constr &lt;$&gt; traverseTuple (pTypeOfA p) (pTypeOfB p) (a, b)
--   </pre>
--   
--   OR simply add tuples for the plate definition, just like <tt>Expr</tt>
--   or <tt>Decl</tt>. This also can be done for <tt>List, Maybe</tt>,
--   etc., and then the <tt>traverse</tt> functions can be replaced with
--   <tt>&lt;$&gt;:</tt>, <tt>&lt;*&gt;:</tt>, and generic functions
--   defined in this module can be used for these too.
--   
--   ----------------------------------------
--   
--   4. Using multiplate
--   
--   In a given program:
--   
--   <pre>
--   var a = 1;
--   function func(arg1, arg2){
--     return a + arg1
--   }
--   </pre>
--   
--   and its representation:
--   
--   <pre>
--   prog :: Prog ()
--   prog = Prog () [VarDecl (Var "a") (Number 1)
--                  ,FunDecl (Var "func") [(Var "arg1"), (Var "arg2")]
--                       [Return (Add (Ref "a") (Ref "arg1"))]]
--   </pre>
--   
--   to get the list of variables one has to define a plate by updating
--   another plate containing defaults for all types (<tt>purePlate</tt>)
--   by modifying the field that correpsondes to <tt>Var</tt> data type.
--   Then create another plate where the order of traversal is set
--   (<tt>preorderFold</tt>), and finally call <a>gfoldFor</a> with the
--   plate we defined, and then with the actual data type. Without this
--   module instead of <a>gfoldFor</a> one can only use <tt>foldFor</tt>,
--   which requires an extra argument (a projector), which corresponds to
--   the root datatype: in this case it's <tt>pProg</tt> because our
--   program has a <tt>Prog</tt> data type. But <a>gfoldFor</a>,
--   <a>gtraverseFor</a>, etc. can be used with any data type, because in
--   the <a>IsProjector</a> instances we already defined what it's
--   projector is.
--   
--   <pre>
--   variablesPlate :: Plate (Constant [String])
--   variablesPlate = preorderFold purePlate { pVar = ((Var str) -&gt; Constant [str]) }
--   
--   vars :: (IsProjector Plate a) =&gt; a -&gt; [String]
--   vars  x = gfoldFor       variablesPlate x
--   
--   vars' :: Prog a -&gt; [String]
--   vars' x =  foldFor pProg variablesPlate x
--   </pre>
--   
--   <pre>
--   &gt; vars prog
--   ["a","func","arg1","arg2"]
--   </pre>
--   
--   ----------------------------------------
--   
--   All of this code is included in the source at the end of this file for
--   easier copying.
--   
--   Multiplate documentation:
--   <a>http://hackage.haskell.org/package/multiplate</a>
module Data.Generics.Multiplate.Simplified
class Multiplate p => IsProjector p a
getProjector :: IsProjector p a => p appl -> a -> Projector p a
gtraverseFor :: IsProjector p a => p Identity -> a -> a
gtraverseMFor :: (IsProjector p a, Monad m) => p m -> a -> m a
gfoldFor :: IsProjector p a => p (Constant o) -> a -> o
gunwrapFor :: IsProjector p a => (o -> b) -> p (Constant o) -> a -> b
gsumFor :: IsProjector p a => p (Constant (Sum n)) -> a -> n
gproductFor :: IsProjector p a => p (Constant (Product n)) -> a -> n
gallFor :: IsProjector p a => p (Constant All) -> a -> Bool
ganyFor :: IsProjector p a => p (Constant Any) -> a -> Bool
gfirstFor :: IsProjector p a => p (Constant (First b)) -> a -> Maybe b
glastFor :: IsProjector p a => p (Constant (Last b)) -> a -> Maybe b
