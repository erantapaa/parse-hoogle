-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A perfect hashing library for mapping bytestrings to values.
--   
@package PerfectHash
@version 0.1.4


-- | Microbenchmarking can be used to compare the speed of different
--   approaches to the same operation. Since most code is very fast, to get
--   accurate timing information you must run the operation many times and
--   then divide to get the time per operation.
--   
--   This library manages the microbenchmarking process: it finds how many
--   iterations of a function are needed to get a good timing estimate per
--   iteration and prints out a human-readable "Your code takes <i>n</i>
--   nanoseconds to run, and can run <i>n</i> times per second".
--   
--   The only function <a>microbench</a> takes a function that expects an
--   integer parameter (which is the quantity you're trying to measure),
--   and probes the function with increasing parameters until enough time
--   has elapsed to get a good measurement.
--   
--   This may be better understood by some example code:
--   
--   <pre>
--   sum1 n = sum [1..n]
--   sum2 n = foldl (+) 0 [1..n]
--   main = do
--     microbench "Sum using sum" sum1
--     microbench "Sum using foldl" sum2
--   </pre>
--   
--   When run, <tt>sum1</tt> and <tt>sum2</tt> are called with varying
--   values of <tt>n</tt>. The output, then, is an estimate of how many
--   integers these approaches could sum per second.
--   
--   <a>microbench</a> also accepts a parameter of type <tt>IO ()</tt> for
--   benchmarking. It does the same probing process, but manages running
--   the operation in a loop.
module HackedMicrobench

-- | <tt>microbench description target</tt> probes target with different
--   parameters until it's ran enough iterations to have a good estimate at
--   the rate per second of the operation. <tt>description</tt> is a
--   textual description of the thing being benchmarked. Outputs to stdout.
microbench :: Microbenchable a => String -> a -> IO ()

-- | Microbenchmarkable computations. Be very wary of adding your own
--   instances of this class, as it's difficult to force GHC to re-evaluate
--   code in a way that makes benchmarking easy.
class Microbenchable a
instance [overlap ok] Microbenchable (IO ())
instance [overlap ok] Microbenchable (Integer -> a)
instance [overlap ok] Microbenchable (Integer -> IO ())

module Data.PerfectHash
data PerfectHash a
fromList :: Show a => [(ByteString, a)] -> PerfectHash a
lookup :: PerfectHash a -> ByteString -> Maybe a
lookupByIndex :: PerfectHash a -> Word32 -> Maybe ByteString
