-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A collection of auxiliary operations and widgets related to Gtk
--   
@package gtk-helpers
@version 0.0.7

module System.Application
openUrlBySystemTool :: String -> IO Bool

module Graphics.UI.Gtk.Layout.EitherWidget
data EitherWidget a b
EitherWidget :: Notebook -> (IORef EitherWidgetParams) -> EitherWidget a b
type EitherWidgetParams = Bool
eitherWidgetNew :: (WidgetClass a, WidgetClass b) => a -> b -> IO (EitherWidget a b)
eitherWidgetLeftActivated :: Attr (EitherWidget a b) Bool
eitherWidgetRightActivated :: Attr (EitherWidget a b) Bool
eitherWidgetToggle :: EitherWidget a b -> IO ()
instance GObjectClass (EitherWidget a b)
instance ObjectClass (EitherWidget a b)
instance WidgetClass (EitherWidget a b)

module Graphics.UI.Gtk.Layout.DummyBin
data DummyBin
DummyBin :: EventBox -> DummyBin
dummyBinNew :: IO DummyBin
instance ContainerClass DummyBin
instance GObjectClass DummyBin
instance ObjectClass DummyBin
instance WidgetClass DummyBin

module Graphics.UI.Gtk.Layout.BackgroundContainer
data BackgroundContainer
BackgroundContainer :: EventBox -> (IORef (Maybe Pixbuf)) -> BackgroundContainer
backgroundContainerNew :: IO BackgroundContainer
backgroundContainerNewWithPicture :: FilePath -> IO BackgroundContainer
backgroundContainerNewWithPixbuf :: Pixbuf -> IO BackgroundContainer
backgroundExpose :: BackgroundContainer -> IO ()
backgroundSetPicture :: BackgroundContainer -> Maybe FilePath -> IO ()
backgroundSetPixbuf :: BackgroundContainer -> Maybe Pixbuf -> IO ()
instance BinClass BackgroundContainer
instance ContainerClass BackgroundContainer
instance EventBoxClass BackgroundContainer
instance GObjectClass BackgroundContainer
instance ObjectClass BackgroundContainer
instance WidgetClass BackgroundContainer

module Graphics.UI.Gtk.Helpers.TreeView
type TypedTreeView a = (TreeView, ListStore a)
addTextColumn :: (TreeModelClass (model row), TypedTreeModelClass model) => TreeView -> model row -> (row -> Maybe String) -> IO ()
addPixbufColumn :: (TreeModelClass (model row), TypedTreeModelClass model) => TreeView -> model row -> (row -> Maybe Pixbuf) -> IO ()
addPixbufTextDoubleColumn :: (TreeModelClass (model row), TypedTreeModelClass model) => TreeView -> model row -> (row -> (Maybe Pixbuf, Maybe String)) -> IO ()
synchroniseTreeViewAndNotebook :: TreeView -> Notebook -> ([TreePath] -> Maybe Int) -> IO ()
treeViewGetSelectedPath :: TreeViewClass tv => tv -> IO [[Int]]
treeViewGetSelected :: TreeViewClass tv => tv -> ListStore a -> IO (Maybe a)

module Graphics.UI.Gtk.Helpers.Pixbuf
safePixbufComposite :: Pixbuf -> Pixbuf -> Int -> Int -> Int -> Int -> InterpType -> Word8 -> IO ()
safePixbufComposite' :: Pixbuf -> Pixbuf -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> InterpType -> Word8 -> IO ()
pixbufNewEmpty :: Int -> Int -> IO Pixbuf
pixbufNewWithBGColor :: Bool -> Int -> Int -> (Word8, Word8, Word8) -> IO Pixbuf


-- | Auxiliary functions userful to manipulate TextBuffers
module Graphics.UI.Gtk.Helpers.Multiline.TextBuffer

-- | Updates a text buffer only if it's necessary (to avoid extra events)
textBufferUpdateText :: TextBuffer -> String -> IO ()

-- | Gets all the text from a text buffer
textBufferGetAllText :: TextBuffer -> Bool -> IO String

module Graphics.UI.Gtk.Layout.MaybeWidget
data MaybeWidget a
MaybeWidget :: Notebook -> a -> Label -> (IORef MaybeWidgetParams) -> MaybeWidget a
type MaybeWidgetParams = Bool
maybeWidgetNewWithLabel :: WidgetClass a => a -> Maybe String -> IO (MaybeWidget a)
maybeWidgetGetWidget :: MaybeWidget a -> a
maybeWidgetLabelText :: Attr (MaybeWidget a) String
maybeWidgetActivated :: Attr (MaybeWidget a) Bool
maybeWidgetToggle :: MaybeWidget a -> IO ()
instance GObjectClass (MaybeWidget a)
instance ObjectClass (MaybeWidget a)
instance WidgetClass (MaybeWidget a)

module Graphics.UI.Gtk.Helpers.ModelViewPath
class ViewWithPathSelection a b | a -> b
modelViewGetCursor :: ViewWithPathSelection a b => a -> IO (TreePath, Maybe b)
instance ViewWithPathSelection TreeView TreeViewColumn
instance ViewWithPathSelection IconView CellRenderer


-- | This module provides functions to alter the view in a notebook and a
--   maybewidget with a notebook inside based on what is selected in a
--   model view (icon view, list view, tree view)
--   
--   This pattern appears very often in my programs. I like to use model
--   views to let the user choose what to see (instead of using the tab
--   pages).
module Graphics.UI.Gtk.Helpers.ModelViewNotebookSync

-- | Keeps the page of a notebook in sync with the selection in a model
--   view. It uses an auxiliary function to determine which page to select.
modelViewNotebookSync :: (ViewWithPathSelection a c, NotebookClass b) => a -> b -> (TreePath -> Int) -> IO ()

-- | Keeps the page of a notebook in sync with the selection in a model
--   view. It selects the page with the same number as the element selected
--   in the model view. If there's more than one selection, or if the model
--   view is not flat and the selected element is not at the first level,
--   then it selects nothing.
modelViewNotebookSyncId :: (ViewWithPathSelection a c, NotebookClass b) => a -> b -> IO ()

-- | Keeps the page of a notebook inside a maybe widget in sync with the
--   selection in a model view.
--   
--   It uses an auxiliary function to determine which page to select. If
--   the function returns Nothing, then the maybe widget is deactivated.
modelViewMaybeNotebookSync :: (ViewWithPathSelection a c, NotebookClass b) => a -> MaybeWidget b -> (TreePath -> Maybe Int) -> IO ()

-- | Keeps the page of a notebook inside a maybe widget in sync with the
--   selection in a model view.
--   
--   It selects the page with the same number as the element selected in
--   the model view. If there's more than one selection, or if the model
--   view is not flat and the selected element is not at the first level,
--   then it selects nothing.
modelViewMaybeNotebookSyncId :: (ViewWithPathSelection a c, NotebookClass b) => a -> MaybeWidget b -> IO ()

module Graphics.UI.Gtk.Helpers.MessageDialog
popupError :: String -> String -> IO ()

module Graphics.UI.Gtk.Helpers.MenuItem
menuItemGetLabel :: MenuItemClass self => self -> IO (Maybe Label)

module Graphics.UI.Gtk.Helpers.FileDialog
openOpenFileDialog :: String -> [Ext] -> IO (Maybe String)

module Graphics.UI.Gtk.Helpers.Combo
addTextColumn :: (TreeModelClass (model row), TypedTreeModelClass model) => ComboBox -> model row -> (row -> Maybe String) -> IO ()
type TypedComboBox a = (ComboBox, ListStore a)
typedComboBoxCombo :: TypedComboBox a -> ComboBox
typedComboBoxStore :: TypedComboBox a -> ListStore a
typedComboBoxGetSelected :: TypedComboBox a -> IO (Maybe a)
typedComboBoxGetSelectedUnsafe :: TypedComboBox a -> IO a
typedComboBoxSetSelected :: Eq a => TypedComboBox a -> a -> IO ()


-- | A collection of small functions to help retrieve information from
--   Glade files.
module Graphics.UI.Gtk.Extra.Builder

-- | Graphics.UI.Gtk.builderGetObject with the arguments flipped (Builder
--   goes last).
fromBuilder :: GObjectClass cls => (GObject -> cls) -> String -> Builder -> IO cls

-- | Returns a builder from which the objects in this part of the interface
--   can be accessed.
loadInterface :: String -> IO Builder


-- | This module allows you to access Glade objects from a Gtk Builder by
--   providing the builder, the type of the object and the name (the cast
--   operation is deduced automatically from the type name).
--   
--   It uses Graphics.UI.Gtk.Builder.onBuilder to access a glade object
--   using TH.
module Graphics.UI.Gtk.Extra.BuilderTH

-- | Accessor for Glade objects from Gtk Builders by name and type.
gtkBuilderAccessor :: String -> String -> Q [Dec]

-- | Accessor for Glade objects from Gtk Builders encapsulated in Views, by
--   name and -- type.
gtkViewAccessor :: String -> String -> String -> String -> Q [Dec]

-- | Graphics.UI.Gtk.builderGetObject with the arguments flipped (Builder
--   goes last).
fromBuilder :: GObjectClass cls => (GObject -> cls) -> String -> Builder -> IO cls

module Graphics.UI.Gtk.Entry.HighlightedEntry
data HighlightedEntry
highlightedEntryNew :: IO HighlightedEntry
highlightedEntrySetColor :: HighlightedEntry -> Color -> IO ()
highlightedEntryGetColor :: HighlightedEntry -> IO Color
highlightedEntrySetStatus :: HighlightedEntry -> Bool -> IO ()
highlightedEntryGetStatus :: HighlightedEntry -> IO Bool
highlightedEntryColor :: Attr HighlightedEntry Color
highlightedEntryStatus :: Attr HighlightedEntry Bool
instance EntryClass HighlightedEntry
instance WidgetClass HighlightedEntry
instance ObjectClass HighlightedEntry
instance GObjectClass HighlightedEntry

module Graphics.UI.Gtk.Entry.FormatEntry
data FormatEntry
formatEntryNew :: IO FormatEntry
formatEntryNewWithFunction :: (String -> Bool) -> IO FormatEntry
formatEntrySetColor :: FormatEntry -> Color -> IO ()
formatEntryGetColor :: FormatEntry -> IO Color
formatEntrySetCheckFunction :: FormatEntry -> (String -> Bool) -> IO ()
formatEntryGetCheckFunction :: FormatEntry -> IO (String -> Bool)
formatEntryHasCorrectFormat :: FormatEntry -> IO Bool
formatEntryColor :: Attr FormatEntry Color
formatEntryCheckFunction :: Attr FormatEntry (String -> Bool)
instance EditableClass FormatEntry
instance EntryClass FormatEntry
instance WidgetClass FormatEntry
instance ObjectClass FormatEntry
instance GObjectClass FormatEntry

module Game.Board.BasicTurnGame
data GameChange index player piece
AddPiece :: (index, index) -> player -> piece -> GameChange index player piece
RemovePiece :: (index, index) -> GameChange index player piece
MovePiece :: (index, index) -> (index, index) -> GameChange index player piece
hasPiece :: Ix index => GameState index tile player piece -> (index, index) -> Bool
getPieceAt :: Ix index => GameState index tile player piece -> (index, index) -> Maybe (player, piece)
data GameState index tile player piece
GameState :: player -> [(index, index, tile)] -> [(index, index, player, piece)] -> GameState index tile player piece
curPlayer' :: GameState index tile player piece -> player
boardPos :: GameState index tile player piece -> [(index, index, tile)]
boardPieces' :: GameState index tile player piece -> [(index, index, player, piece)]
class PlayableGame a index tile player piece | a -> index, a -> tile, a -> player, a -> piece where moveEnabled _ = False canMove _ _ _ = False canMoveTo _ _ _ _ = False move _ _ _ _ = [] activateEnabled _ = False canActivate _ _ _ = False activate _ _ _ = [] applyChange g _ = g applyChanges a ls = foldl applyChange a ls
curPlayer :: PlayableGame a index tile player piece => a -> player
allPieces :: PlayableGame a index tile player piece => a -> [(index, index, player, piece)]
allPos :: PlayableGame a index tile player piece => a -> [(index, index, tile)]
moveEnabled :: PlayableGame a index tile player piece => a -> Bool
canMove :: PlayableGame a index tile player piece => a -> player -> (index, index) -> Bool
canMoveTo :: PlayableGame a index tile player piece => a -> player -> (index, index) -> (index, index) -> Bool
move :: PlayableGame a index tile player piece => a -> player -> (index, index) -> (index, index) -> [GameChange index player piece]
activateEnabled :: PlayableGame a index tile player piece => a -> Bool
canActivate :: PlayableGame a index tile player piece => a -> player -> (index, index) -> Bool
activate :: PlayableGame a index tile player piece => a -> player -> (index, index) -> [GameChange index player piece]
applyChange :: PlayableGame a index tile player piece => a -> GameChange index player piece -> a
applyChanges :: PlayableGame a index tile player piece => a -> [GameChange index player piece] -> a

module Data.Board.GameBoardIO
data GameBoard index e
GameBoard :: (IOArray (index, index) (Maybe e)) -> GameBoard index e
gameBoardNew :: Ix index => [(index, index, e)] -> IO (GameBoard index e)
gameBoardNewWithBoundaries :: Ix index => ((index, index), (index, index)) -> [(index, index, e)] -> IO (GameBoard index e)
gameBoardNewEmptySquare :: (Num index, Ix index) => index -> index -> IO (GameBoard index e)
gameBoardNewEmpty :: Ix index => [(index, index)] -> IO (GameBoard index e)
listBoundaries :: Ix index => [(index, index)] -> ((index, index), (index, index))
gameBoardSetPiece :: Ix index => (index, index) -> e -> GameBoard index e -> IO ()
gameBoardGetPiece :: Ix index => (index, index) -> GameBoard index e -> IO (Maybe e)
gameBoardRemovePiece :: Ix index => (index, index) -> GameBoard index e -> IO ()
gameBoardMovePiece :: Ix index => (index, index) -> (index, index) -> GameBoard index e -> IO ()
gameBoardFoldM :: Ix index => GameBoard index a -> (b -> ((index, index), a) -> IO b) -> b -> IO b
gameBoardMapM_ :: Ix index => GameBoard index a -> ((index, index) -> a -> IO ()) -> IO ()
arrayMapM_ :: Ix index => IOArray index a -> (index -> a -> IO ()) -> IO ()
gameBoardClear :: Ix index => GameBoard index a -> IO ()
gameBoardGetBoundaries :: Ix index => GameBoard index a -> IO ((index, index), (index, index))
gameBoardClone :: Ix index => GameBoard index a -> IO (GameBoard index a)

module Graphics.UI.Gtk.Board.TiledBoard
data Board index tile piece
Board :: DrawingArea -> GameBoard index tile -> GameBoard index piece -> PixmapsFor tile -> PixmapsFor piece -> (Int, Int) -> IORef (Maybe (Pixbuf, SizeAdjustment)) -> IORef (Maybe (Pixbuf, SizeAdjustment)) -> IORef Bool -> IORef (Maybe (index, index)) -> IORef (Maybe (index, index)) -> IORef (Maybe (Int, Int)) -> IORef (Maybe (Int, Int)) -> IORef (Maybe (MovingStatus index)) -> Board index tile piece
boardDrawingArea :: Board index tile piece -> DrawingArea
boardTiles :: Board index tile piece -> GameBoard index tile
boardPieces :: Board index tile piece -> GameBoard index piece
tilePixmaps :: Board index tile piece -> PixmapsFor tile
piecePixmaps :: Board index tile piece -> PixmapsFor piece
tileSize :: Board index tile piece -> (Int, Int)
background :: Board index tile piece -> IORef (Maybe (Pixbuf, SizeAdjustment))
overlay :: Board index tile piece -> IORef (Maybe (Pixbuf, SizeAdjustment))
dragEnabled :: Board index tile piece -> IORef Bool
draggingFrom :: Board index tile piece -> IORef (Maybe (index, index))
draggingTo :: Board index tile piece -> IORef (Maybe (index, index))
draggingMouseOrig :: Board index tile piece -> IORef (Maybe (Int, Int))
draggingMousePos :: Board index tile piece -> IORef (Maybe (Int, Int))
movingStatus :: Board index tile piece -> IORef (Maybe (MovingStatus index))
data MovingStatus index
MovingStatus :: (index, index) -> (index, index) -> Double -> Double -> Double -> MovingStatus index
movingFrom :: MovingStatus index -> (index, index)
movingTo :: MovingStatus index -> (index, index)
stepsPerUnit :: MovingStatus index -> Double
timePerUnit :: MovingStatus index -> Double
movingStep :: MovingStatus index -> Double
type PixmapsFor a = a -> Pixbuf
data SizeAdjustment
SizeAdjustment :: SizeAdjustment
boardNew :: Ix index => [(index, index, tile)] -> PixmapsFor tile -> PixmapsFor piece -> IO (Board index tile piece)
getTileSize :: [(index, index, tile)] -> PixmapsFor tile -> IO (Int, Int)
boardGetPiece :: Ix index => (index, index) -> Board index tile piece -> IO (Maybe piece)
boardSetPiece :: Ix index => (index, index) -> piece -> Board index tile piece -> IO ()
boardSetPieceNoRefresh :: Ix index => (index, index) -> piece -> Board index tile piece -> IO ()
boardRemovePiece :: Ix index => (index, index) -> Board index tile piece -> IO ()
boardMovePiece :: Ix index => (index, index) -> (index, index) -> Board index tile piece -> IO ()
boardInvalidate :: Ix index => Board index tile piece -> IO ()
boardRefresh :: Ix index => Board index tile piece -> IO ()
adjustPixbuf :: (Int, Int) -> Pixbuf -> SizeAdjustment -> IO ((Int, Int), Pixbuf)
mouseMotionHandler :: Ix index => Board index tile piece -> ((index, index) -> EventM EMotion Bool) -> EventM EMotion Bool
mouseButtonHandler :: Ix index => Board index tile piece -> ((index, index) -> EventM EButton Bool) -> EventM EButton Bool
getMouseCoordinates :: Ix index => Board index tile piece -> (Double, Double) -> IO (Maybe (index, index))
clickHandler :: Ix index => Board index tile piece -> ((index, index) -> IO ()) -> EventM EButton Bool
boardGetPixelSize :: Ix index => Board index tile piece -> IO (Int, Int)
drawPixmaps :: (Ix index, DrawableClass d) => d -> (Int, Int) -> GameBoard index e -> PixmapsFor e -> IO ()
boardFoldM :: Ix index => Board index tile piece -> (b -> ((index, index), piece) -> IO b) -> b -> IO b
boardClear :: Ix index => Board index tile piece -> IO ()
boardLoad :: Ix index => Board index tile piece -> [((index, index), piece)] -> IO ()
boardOnClick :: Ix index => Board index tile piece -> ((index, index) -> IO ()) -> IO ()
boardOnPress :: Ix index => Board index tile piece -> ((index, index) -> EventM EButton Bool) -> IO ()
boardOnRelease :: Ix index => Board index tile piece -> ((index, index) -> EventM EButton Bool) -> IO ()
boardOnMotion :: Ix index => Board index tile piece -> ((index, index) -> EventM EMotion Bool) -> IO ()
boardSetBackground :: Ix index => Board index tile piece -> Maybe (Pixbuf, SizeAdjustment) -> IO ()
boardSetOverlay :: Ix index => Board index tile piece -> Maybe (Pixbuf, SizeAdjustment) -> IO ()
boardEnableDrag :: Ix index => Board index tile piece -> IO ()
boardDisableDrag :: Ix index => Board index tile piece -> IO ()
boardStartDrag :: Ix index => Board index tile piece -> (index, index) -> IO ()
boardStopDrag :: Ix index => Board index tile piece -> IO ()
boardOnPieceDragStart :: Ix index => Board index tile piece -> ((index, index) -> IO Bool) -> IO ()
boardOnPieceDragOver :: Ix index => Board index tile piece -> ((index, index) -> (index, index) -> IO Bool) -> IO ()
boardOnPieceDragDrop :: Ix index => Board index tile piece -> ((index, index) -> (index, index) -> IO ()) -> IO ()
boardIsDragging :: Ix index => Board index tile piece -> IO Bool
relativePos :: Ix index => Board index tile piece -> (index, index) -> (Int, Int) -> (Int, Int)
returning :: Monad m => a -> m b -> m a
instance GObjectClass (Board index tile piece)
instance ObjectClass (Board index tile piece)
instance WidgetClass (Board index tile piece)

module Graphics.UI.Gtk.Board.BoardLink
attachGameRules :: (PlayableGame pg index tile player piece, Ix index) => Game pg index tile player piece -> IO (Board index tile (player, piece))
applyBoardChange :: Ix index => Board index tile (player, piece) -> GameChange index player piece -> IO ()
data VisualGameAspects index tile player piece
VisualGameAspects :: PixmapsFor tile -> PixmapsFor (player, piece) -> (Int, Int, Int) -> Maybe (Pixbuf, SizeAdjustment) -> VisualGameAspects index tile player piece
tileF :: VisualGameAspects index tile player piece -> PixmapsFor tile
pieceF :: VisualGameAspects index tile player piece -> PixmapsFor (player, piece)
bgColor :: VisualGameAspects index tile player piece -> (Int, Int, Int)
bg :: VisualGameAspects index tile player piece -> Maybe (Pixbuf, SizeAdjustment)
data Game pg index tile player piece
Game :: VisualGameAspects index tile player piece -> pg -> Game pg index tile player piece
visual :: Game pg index tile player piece -> VisualGameAspects index tile player piece
gameS :: Game pg index tile player piece -> pg
