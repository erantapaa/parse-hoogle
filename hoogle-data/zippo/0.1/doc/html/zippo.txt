-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple lens-based, generic, heterogenous, type-checked zipper library
--   
--   This light-weight library provides a basic, but fully-type-checked
--   zipper implementation, suitable for any algebraic data structure. Our
--   implementation has no notion of "left" and "right", and instead uses
--   lenses (from the <a>yall</a> package) to indicate directions to
--   "navigate down to".
--   
--   For a similar approach with many more features, but less type-safety
--   see <a>pez</a>.
@package zippo
@version 0.1

module Data.Lens.Zipper

-- | Our zipper type, parameterized by a <a>focus</a> and "history stack",
--   supporting completely type-checked zipper operations.
data Zipper st b
data Top a
data (:>) st b c
class Hist st a c

-- | "enter" a data type. Move the <a>focus</a> with <a>move</a> and
--   <a>moveUp</a>. Exit the zipper with <a>close</a>.
--   
--   <pre>
--   zipper = Zipper Top
--   </pre>
zipper :: a -> Zipper Top a

-- | exit the zipper, rebuilding the structure <tt>a</tt>:
--   
--   <pre>
--   close (Zipper st b) = runHist st b
--   </pre>
close :: Hist st a b => Zipper st b -> a

-- | navigate to a child element indicated by the passed lens, returning
--   the new Zipper in the monad <tt>m</tt>. This will be <a>Maybe</a> when
--   the standard (<a>:~&gt;</a>) Lens is used. For pure lenses, use
--   <a>moveP</a>.
move :: Monad m => LensM m b c -> Zipper st b -> m (Zipper (st :> b) c)

-- | navigate to a child element indicated by the passed pure lens
--   
--   <pre>
--   moveP l = runIdentity . move l
--   </pre>
moveP :: (b :-> c) -> Zipper st b -> Zipper (st :> b) c

-- | navigate up a level in a zipper not already at <a>Top</a>
--   
--   <pre>
--   moveUp (Zipper (Snoc st cont) c) = Zipper st $ cont c
--   </pre>
moveUp :: Zipper (st :> b) c -> Zipper st b

-- | A lens on the focus of the zipper.
focus :: Zipper st b :-> b

-- | Set the zipper focus
--   
--   <pre>
--   setf = set focus
--   </pre>
setf :: Zipper st b -> b -> Zipper st b

-- | Modify the zipper focus
--   
--   <pre>
--   modf = modify focus
--   </pre>
modf :: (b -> b) -> Zipper st b -> Zipper st b
instance Hist st a b => Hist (st :> b) a c
instance a ~ b => Hist Top a b
