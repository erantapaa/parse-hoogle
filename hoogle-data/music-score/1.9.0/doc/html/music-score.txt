-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Musical score and part representation.
--   
@package music-score
@version 1.9.0

module Music.Score.Internal.Util

-- | Divide a list into parts of maximum length n. &gt; category : List
--   &gt; depends : base
divideList :: Int -> [a] -> [[a]]

-- | Group a list into sublists whereever a predicate holds. The matched
--   element is the first in the sublist.
--   
--   <pre>
--   splitWhile isSpace "foo bar baz"
--      ===&gt; ["foo"," bar"," baz"]
--   
--   splitWhile (&gt; 3) [1,5,4,7,0,1,2]
--      ===&gt; [[1],[5],[4],[7,0,1,2]]
--   </pre>
--   
--   <pre>
--   category : List
--   depends : base
--   </pre>
splitWhile :: (a -> Bool) -> [a] -> [[a]]

-- | Break up a list into parts of maximum length n, inserting the given
--   list as separator. Useful for breaking up strings, as in <tt>breakList
--   80 "n" str</tt>.
--   
--   <pre>
--   category : List
--   depends : base
--   </pre>
breakList :: Int -> [a] -> [a] -> [a]

-- | Map over the indices and elements of list. &gt; category : List &gt;
--   depends : base
mapIndexed :: (Int -> a -> b) -> [a] -> [b]

-- | Duplicate an element. &gt; category: Combinator, Tuple &gt; depends:
--   base
dup :: a -> (a, a)

-- | Unfold a partial function. This is a simpler version of
--   <a>unfoldr</a>. &gt; category: Function, List &gt; depends: base
unf :: (a -> Maybe a) -> a -> [a]

-- | Map over first elements of a list. Biased on first element for shorter
--   lists. &gt; category: List &gt; depends: base
mapF :: (b -> b) -> [b] -> [b]

-- | Map over all but the first and last elements of a list. Biased on
--   middle elements for shorter lists. &gt; category: List &gt; depends:
--   base
mapT :: (b -> b) -> [b] -> [b]

-- | Map over last elements of a list. Biased on last element for shorter
--   lists. &gt; category: List &gt; depends: base
mapL :: (b -> b) -> [b] -> [b]

-- | Map over first, middle and last elements of list. Biased on first,
--   then on first and last for short lists.
--   
--   <pre>
--   category: List
--   depends: base
--   </pre>
mapFTL :: (a -> b) -> (a -> b) -> (a -> b) -> [a] -> [b]

-- | Extract the first consecutive sublist for which the predicate returns
--   true, or the empty list if no such sublist exists. &gt; category: List
--   &gt; depends: base
filterOnce :: (a -> Bool) -> [a] -> [a]

-- | Returns all rotations of the given list. Given an infinite list,
--   returns an infinite list of rotated infinite lists. &gt; category:
--   List &gt; depends: base
rots :: [a] -> [[a]]

-- | <pre>
--   category: List
--   depends: base
--   </pre>
rotl :: [a] -> [a]

-- | <pre>
--   category: List
--   depends: base
--   </pre>
rotr :: [a] -> [a]

-- | <pre>
--   category: List
--   depends: base
--   </pre>
rotated :: Int -> [a] -> [a]
curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
untripl :: (a, b, c) -> ((a, b), c)
tripl :: ((a, b), c) -> (a, b, c)
tripr :: (a, (b, c)) -> (a, b, c)
partial2 :: (a -> b -> Bool) -> a -> b -> Maybe b
partial3 :: (a -> b -> c -> Bool) -> a -> b -> c -> Maybe c

-- | Case matching on lists. &gt; category: List &gt; depends: base
list :: r -> ([a] -> r) -> [a] -> r

-- | Merge lists. &gt; category: List &gt; depends: base
merge :: Ord a => [a] -> [a] -> [a]

-- | Merge lists. &gt; category: List &gt; depends: base
mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
mergeBy' :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | Compose all functions. &gt; category: Function &gt; depends: base
composed :: [b -> b] -> b -> b

-- | Separate a ratio. &gt; category: Math &gt; depends: base
unRatio :: Integral a => Ratio a -> (a, a)

-- | Nicer printing of ratio as ordinary fractions. &gt; category: Math
--   &gt; depends: base
showRatio :: (Integral a, Show a) => Ratio a -> String
retainUpdates :: Eq a => [a] -> [Maybe a]
replic :: Integral a => a -> b -> [b]
swap :: (a, b) -> (b, a)
withNext :: [a] -> [(a, Maybe a)]
withPrev :: [a] -> [(Maybe a, a)]
withPrevNext :: [a] -> [(Maybe a, a, Maybe a)]
mapWithNext :: (a -> Maybe a -> b) -> [a] -> [b]
mapWithPrev :: (Maybe a -> a -> b) -> [a] -> [b]
mapWithPrevNext :: (Maybe a -> a -> Maybe a -> b) -> [a] -> [b]
toDouble :: Real a => a -> Double
through :: Applicative f => Lens' s a -> Lens s t a b -> Lens (f s) (f t) (f a) (f b)
single :: Prism' [a] a
floor' :: RealFrac a => a -> a
inspecting :: Eq a => (b -> a) -> b -> b -> Bool


-- | Provides ABC notation export.
--   
--   <i>Warning</i> Experimental module.
module Music.Score.Export.Abc


-- | Provides Lilypond import.
--   
--   <i>Warning</i> Experimental module.
module Music.Score.Import.Lilypond


-- | Provides ABC notation import.
--   
--   <i>Warning</i> Experimental module.
module Music.Score.Import.Abc


module Music.Time.Internal.Util

-- | Nicer printing of ratio as ordinary fractions. &gt; category: Math
--   &gt; depends: base
showRatio :: (Integral a, Show a) => Ratio a -> String

-- | Case matching on lists. &gt; category: List &gt; depends: base
list :: r -> ([a] -> r) -> [a] -> r
single :: Prism' [a] a
inspecting :: Eq a => (b -> a) -> b -> b -> Bool
inspectingBy :: (b -> a) -> (a -> a -> Bool) -> (b -> b -> Bool)
withPrevNext :: [a] -> [(Maybe a, a, Maybe a)]

-- | Rotate a list.
--   
--   <pre>
--   rotate n xs == id iff (n `mod` length xs) == 0
--   rotate (-n) . rotate n == id
--   </pre>
rotate :: Int -> [a] -> [a]
tripped :: Iso ((a, b), c) ((d, e), f) (a, b, c) (d, e, f)
through :: Applicative f => Lens' s a -> Lens s t a b -> Lens (f s) (f t) (f a) (f b)
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d

-- | Convert a predicate to a partial function.
partial :: (a -> Bool) -> a -> Maybe a
partial2 :: (a -> b -> Bool) -> a -> b -> Maybe b
partial3 :: (a -> b -> c -> Bool) -> a -> b -> c -> Maybe c
_zipList :: Iso [a] [b] (ZipList a) (ZipList b)
dependingOn :: Lens s t (x, a) (x, b) -> (x -> Lens a b c d) -> Lens s t c d


-- | Monadic composition.
--   
--   Based on an operator found in <i>Composing Monads</i> by Jones and
--   Duponcheel (1993).
--   
--   Should be moved to a separate package `control-monad-compose`.
module Control.Monad.Compose
mjoin :: (Monad m, Monad n, Functor m, Traversable n) => m (n (m (n a))) -> m (n a)
mbind :: (Monad m, Monad n, Functor m, Traversable n) => (a -> m (n b)) -> m (n a) -> m (n b)

module Data.Semigroup.Instances
instance Functor Sum
instance Functor Product
instance IsPitch a => IsPitch (Product a)
instance IsPitch a => IsPitch (Sum a)
instance IsDynamics a => IsDynamics (Product a)
instance IsDynamics a => IsDynamics (Sum a)
instance AdditiveGroup a => AdditiveGroup (Product a)
instance Fractional a => Fractional (Product a)
instance Real a => Real (Product a)
instance AdditiveGroup a => AdditiveGroup (Sum a)
instance Fractional a => Fractional (Sum a)
instance Real a => Real (Sum a)
instance Applicative Sum
instance Applicative Product
instance AffineSpace a => AffineSpace (Product a)
instance VectorSpace a => VectorSpace (Product a)
instance AffineSpace a => AffineSpace (Sum a)
instance VectorSpace a => VectorSpace (Sum a)

module Data.Functor.Rep.Lens

-- | Index a representable functor.
--   
--   This is an infix alias for <a>index</a>.
(!) :: Representable f => f a -> Rep f -> a

module Data.Functor.Context

-- | A value with a possible predecessor and successor. Can be used to
--   traverse values with their immediate context.
newtype Ctxt a
Ctxt :: (Maybe a, a, Maybe a) -> Ctxt a
getCtxt :: Ctxt a -> (Maybe a, a, Maybe a)
toCtxt :: (Maybe a, a, Maybe a) -> Ctxt a
mapCtxt :: (a -> b) -> Ctxt a -> Ctxt b
extractCtxt :: Ctxt a -> a
addCtxt :: [a] -> [Ctxt a]
instance Functor Ctxt
instance Eq a => Eq (Ctxt a)
instance Ord a => Ord (Ctxt a)
instance Applicative Ctxt
instance Rewrapped (Ctxt a) (Ctxt b)
instance Wrapped (Ctxt a)
instance Show a => Show (Ctxt a)

module Data.AffineSpace.Point.Offsets

-- | Lay out a series of vectors from a given point. Return all
--   intermediate points.
--   
--   <pre>
--   lenght xs + 1 == length (offsetPoints p xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; offsetPoints 0 [1,1,1] :: [Time]
--   [0,1,2,3]
--   </pre>
offsetPoints :: AffineSpace p => p -> [Diff p] -> [p]

-- | Calculate the relative difference between vectors.
--   
--   <pre>
--   lenght xs + 1 == length (offsetPoints p xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; offsetPoints 0 [1,1,1] :: [Time]
--   [0,1,2,3]
--   </pre>
pointOffsets :: AffineSpace p => p -> [p] -> [Diff p]

-- | For all p &gt; offsetVs p . distanceVs p = id &gt; distanceVs p .
--   offsetVs p = id
offsetVs :: AffineSpace p => p -> [Diff p] -> [p]
distanceVs :: AffineSpace p => p -> [p] -> [Diff p]


module Music.Time.Types

-- | <a>Time</a> represents points in time space. The difference between
--   two time points is a <a>Duration</a>, for example in a bar of duration
--   4/4 (that is 1), the difference between the first and third beat 1/2.
--   
--   Time has an origin (zero) which usually represents the beginning of
--   the musical performance, but this may not always be the case, as the
--   modelled music may be infinite, or contain a musical pickup. Hence
--   <a>Time</a> values can be negative.
data Time

-- | Duration, corresponding to note values in standard notation. The
--   standard names can be used: <tt>1/2</tt> for half note <tt>1/4</tt>
--   for a quarter note and so on.
data Duration
type Alignment = Duration

-- | <i>Deprecated: Use <a>Alignment</a></i>
type LocalDuration = Alignment

-- | Interpret as durations from 0.
--   
--   <pre>
--   toAbsoluteTime (toRelativeTime xs) == xs
--   </pre>
--   
--   <pre>
--   lenght xs == length (toRelativeTime xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toAbsoluteTime [1,1,1] :: [Time]
--   [1,2,3]
--   </pre>
toAbsoluteTime :: [Duration] -> [Time]

-- | Duration between 0 and first value and so on until the last.
--   
--   <pre>
--   toAbsoluteTime (toRelativeTime xs) == xs
--   </pre>
--   
--   <pre>
--   lenght xs == length (toRelativeTime xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toRelativeTime [1,2,3]
--   [1,1,1]
--   </pre>
toRelativeTime :: [Time] -> [Duration]
toRelativeTimeN :: [Time] -> [Duration]

-- | Duration between values until the last, then up to the given final
--   value. &gt; lenght xs == length (toRelativeTime xs)
toRelativeTimeN' :: Time -> [Time] -> [Duration]

-- | A <a>Span</a> represents a specific time interval, such as the
--   duration of a note, phrase or musical piece. It can be modelled as two
--   points, or as a point and a vector.
--   
--   Another way of looking at <a>Span</a> is that it represents a time
--   transformation where onset is translation and duration is scaling.
--   
--   This type is known as <tt>Arc</tt> in Tidal and as <tt>Era</tt> in the
--   active package.
data Span

-- | <tt>t &lt;-&gt; u</tt> represents the span between <tt>t</tt> and
--   <tt>u</tt>.
(<->) :: Time -> Time -> Span

-- | <tt>t &gt;-&gt; d</tt> represents the span between <tt>t</tt> and
--   <tt>t .+^ d</tt>.
(>->) :: Time -> Duration -> Span

-- | <tt>d &lt;-&gt; t</tt> represents the span between <tt>t .-^ d</tt>
--   and <tt>t</tt>.
(<-<) :: Duration -> Time -> Span

-- | View a span as a pair of onset and duration.
delta :: Iso' Span (Time, Duration)

-- | View a span as pair of onset and offset.
range :: Iso' Span (Time, Time)

-- | View a span as a pair of duration and offset.
codelta :: Iso' Span (Duration, Time)

-- | Access the stretch component in a span.
stretchComponent :: Span -> Duration

-- | Access the delay component in a span.
delayComponent :: Span -> Time

-- | A prism to the subset of <a>Span</a> that performs a delay but no
--   stretch.
fixedDurationSpan :: Prism' Span Time

-- | A prism to the subset of <a>Span</a> that performs a stretch but no
--   delay.
fixedOnsetSpan :: Prism' Span Duration

-- | Normalize a span, i.e. reverse it if negative, and do nothing
--   otherwise.
--   
--   <pre>
--   abs $ s^.<tt>duration</tt> = abs $ (<a>normalizeSpan</a> s)^.<tt>duration</tt>
--   s^.<tt>midpoint</tt> = (<a>normalizeSpan</a> s)^.<tt>midpoint</tt>
--   </pre>
normalizeSpan :: Span -> Span

-- | Reflect a span through its midpoint.
reverseSpan :: Span -> Span

-- | Reflect a span through an arbitrary point.
reflectSpan :: Time -> Span -> Span

-- | Whether the given span is empty, i.e. whether its <tt>onset</tt> and
--   <tt>offset</tt> are equivalent.
isEmptySpan :: Span -> Bool

-- | Whether the given span has a positive duration, i.e. whether its
--   <tt>onset</tt> is before its <tt>offset</tt>.
isForwardSpan :: Span -> Bool

-- | Whether the given span has a negative duration, i.e. whether its
--   <tt>offset</tt> is before its <tt>onset</tt>.
isBackwardSpan :: Span -> Bool

-- | Whether the given point falls inside the given span (inclusively).
--   
--   Designed to be used infix, for example
--   
--   <pre>
--   &gt;&gt;&gt; 0.5 `inside` 1 &lt;-&gt; 2
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1.5 `inside` 1 &lt;-&gt; 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 `inside` 1 &lt;-&gt; 2
--   True
--   </pre>
inside :: Time -> Span -> Bool

-- | Whether the first given span encloses the second span.
--   
--   <pre>
--   &gt;&gt;&gt; 0 &lt;-&gt; 3 `encloses` 1 &lt;-&gt; 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 0 &lt;-&gt; 2 `encloses` 1 &lt;-&gt; 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;-&gt; 3 `encloses` 1 &lt;-&gt; 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;-&gt; 2 `encloses` 1 &lt;-&gt; 2
--   True
--   </pre>
encloses :: Span -> Span -> Bool

-- | Whether the first given span encloses the second span.
--   
--   <pre>
--   &gt;&gt;&gt; 0 &lt;-&gt; 3 `properlyEncloses` 1 &lt;-&gt; 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 0 &lt;-&gt; 2 `properlyEncloses` 1 &lt;-&gt; 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;-&gt; 3 `properlyEncloses` 1 &lt;-&gt; 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;-&gt; 2 `properlyEncloses` 1 &lt;-&gt; 2
--   False
--   </pre>
properlyEncloses :: Span -> Span -> Bool

-- | Whether the given span overlaps.
overlaps :: Span -> Span -> Bool

-- | Whether the first given span occurs before the second span.
isBefore :: Span -> Span -> Bool
afterOnset :: Time -> Span -> Bool
strictlyAfterOnset :: Time -> Span -> Bool
beforeOnset :: Time -> Span -> Bool
strictlyBeforeOnset :: Time -> Span -> Bool
afterOffset :: Time -> Span -> Bool
strictlyAfterOffset :: Time -> Span -> Bool
beforeOffset :: Time -> Span -> Bool
strictlyBeforeOffset :: Time -> Span -> Bool
startsWhenStarts :: Span -> Span -> Bool
startsWhenStops :: Span -> Span -> Bool
stopsWhenStops :: Span -> Span -> Bool
stopsWhenStarts :: Span -> Span -> Bool
startsBefore :: Span -> Span -> Bool
startsLater :: Span -> Span -> Bool
stopsAtTheSameTime :: Span -> Span -> Bool
stopsBefore :: Span -> Span -> Bool
stopsLater :: Span -> Span -> Bool

-- | Show a span in range notation, i.e. <tt>t1 &lt;-&gt; t2</tt>.
showRange :: Span -> String

-- | Show a span in delta notation, i.e. <tt>t &gt;-&gt; d</tt>.
showDelta :: Span -> String

-- | Show a span in codelta notation, i.e. <tt>t &lt;-&lt; d</tt>.
showCodelta :: Span -> String
instance Typeable Duration
instance Typeable Time
instance Typeable Span
instance Eq Duration
instance Ord Duration
instance Enum Duration
instance Num Duration
instance Fractional Duration
instance Real Duration
instance RealFrac Duration
instance Eq Time
instance Ord Time
instance Enum Time
instance Num Time
instance Fractional Time
instance Real Time
instance RealFrac Time
instance Eq Span
instance Ord Span
instance VectorSpace Span
instance AdditiveGroup Span
instance Monoid Span
instance Semigroup Span
instance ToJSON Span
instance Show Span
instance AffineSpace Time
instance VectorSpace Time
instance AdditiveGroup Time
instance Monoid Time
instance Semigroup Time
instance ToJSON Time
instance Show Time
instance InnerSpace Duration
instance VectorSpace Duration
instance AdditiveGroup Duration
instance Monoid Duration
instance Semigroup Duration
instance ToJSON Duration
instance Show Duration


module Music.Time.Internal.Transform

-- | Class of values that can be transformed (i.e. scaled and moved) in
--   time.
class Transformable a
transform :: Transformable a => Span -> a -> a

-- | View the given value in the context of the given transformation.
transformed :: (Transformable a, Transformable b) => Span -> Iso a b a b

-- | Apply a function under transformation.
--   
--   <pre>
--   &gt;&gt;&gt; stretch 2 `whilst` delaying 2 $ (1 &lt;-&gt; 2)
--   4 &lt;-&gt; 6
--   </pre>
whilst :: (Transformable a, Transformable b) => (a -> b) -> Span -> a -> b
whilstL :: (Functor f, Transformable a, Transformable b) => LensLike f s t a b -> LensLike f (Span, s) (Span, t) a b
whilstLT :: (Functor f, Transformable a, Transformable b) => LensLike f s t a b -> LensLike f (Time, s) (Time, t) a b
whilstLD :: (Functor f, Transformable a, Transformable b) => LensLike f s t a b -> LensLike f (Duration, s) (Duration, t) a b

-- | Transforms a lens of to a <a>Transformable</a> type to act inside a
--   transformation.
--   
--   Designed to be used infix, as in
--   
--   <pre>
--   l <a>onSpan</a> (2 &lt;-&gt; 3)
--   </pre>
onSpan :: (Transformable s, Transformable t, Functor f) => LensLike f s t a b -> Span -> LensLike f s t a b

-- | A transformation that moves a value forward in time.
delaying :: Duration -> Span

-- | A transformation that moves a value backward in time.
undelaying :: Duration -> Span

-- | A transformation that stretches (augments) a value by the given
--   factor.
stretching :: Duration -> Span

-- | A transformation that compresses (diminishes) a value by the given
--   factor.
compressing :: Duration -> Span

-- | Moves a value forward in time.
delay :: Transformable a => Duration -> a -> a

-- | Moves a value backward in time. Equnitvalent to <tt><a>stretch</a> .
--   <a>negate</a></tt>.
undelay :: Transformable a => Duration -> a -> a

-- | Stretches (augments) a value by the given factor.
stretch :: Transformable a => Duration -> a -> a

-- | Compresses (diminishes) a score. Equnitvalent to <tt><a>stretch</a> .
--   <a>recip</a></tt>.
compress :: Transformable a => Duration -> a -> a

-- | Delay relative to <a>origin</a>.
--   
--   Provided for situations when we really want to use <tt>startAt</tt>,
--   but the type does not have an instance for <tt>HasPosition</tt> and we
--   can assume that the value is starting at time zero.
delayTime :: Transformable a => Time -> a -> a
instance (Transformable a, Transformable b) => Transformable (a -> b)
instance (Ord k, Transformable a) => Transformable (Map k a)
instance (Ord a, Transformable a) => Transformable (Set a)
instance Transformable a => Transformable (Seq a)
instance Transformable a => Transformable [a]
instance Transformable a => Transformable (b, a)
instance Transformable a => Transformable (Product a)
instance Transformable a => Transformable (Sum a)
instance Transformable a => Transformable (Last a)
instance Transformable a => Transformable (Option a)
instance Transformable a => Transformable (Maybe a)
instance Transformable Span
instance Transformable Time
instance Transformable Duration
instance Transformable Double
instance Transformable Float
instance Transformable a => Transformable (Ratio a)
instance Transformable Integer
instance Transformable Int
instance Transformable Char
instance Transformable Ordering
instance Transformable Bool
instance Transformable ()


module Music.Time.Transform

-- | Class of values that can be transformed (i.e. scaled and moved) in
--   time.
class Transformable a
transform :: Transformable a => Span -> a -> a

-- | View the given value in the context of the given transformation.
transformed :: (Transformable a, Transformable b) => Span -> Iso a b a b

-- | A transformation that moves a value forward in time.
delaying :: Duration -> Span

-- | A transformation that moves a value backward in time.
undelaying :: Duration -> Span

-- | A transformation that stretches (augments) a value by the given
--   factor.
stretching :: Duration -> Span

-- | A transformation that compresses (diminishes) a value by the given
--   factor.
compressing :: Duration -> Span

-- | Moves a value forward in time.
delay :: Transformable a => Duration -> a -> a

-- | Moves a value backward in time. Equnitvalent to <tt><a>stretch</a> .
--   <a>negate</a></tt>.
undelay :: Transformable a => Duration -> a -> a

-- | Stretches (augments) a value by the given factor.
stretch :: Transformable a => Duration -> a -> a

-- | Compresses (diminishes) a score. Equnitvalent to <tt><a>stretch</a> .
--   <a>recip</a></tt>.
compress :: Transformable a => Duration -> a -> a
(|*) :: Transformable a => a -> Duration -> a
(*|) :: Transformable a => Duration -> a -> a
(|/) :: Transformable a => a -> Duration -> a


module Music.Time.Duration

-- | Class of values that have a duration.
--   
--   Should satisfy
--   
--   <pre>
--   (transform s x)^.duration = transform s (x^.duration)
--   </pre>
class HasDuration a
_duration :: HasDuration a => a -> Duration

-- | Access the duration.
duration :: (Transformable a, HasDuration a) => Lens' a Duration

-- | Stretch a value to have the given duration.
stretchTo :: (Transformable a, HasDuration a) => Duration -> a -> a
instance (HasDuration a, HasDuration b) => HasDuration (Either a b)
instance HasDuration a => HasDuration (Max a)
instance HasDuration a => HasDuration (Min a)
instance HasDuration a => HasDuration (Sum a)
instance HasDuration a => HasDuration (Product a)
instance HasDuration b => HasDuration (a, b, c)
instance HasDuration a => HasDuration (a, b)
instance HasDuration Span
instance HasDuration Duration


-- | This misleadingly named module provide a way to query a value for its
--   <a>duration</a>, <a>onset</a> and <a>offset</a>.
module Music.Time.Position

-- | Class of values that have a position in time.
--   
--   Many values such as notes, envelopes etc can in fact have many
--   positions such as onset, attack point, offset, decay point time etc.
--   Rather than having separate methods for a discrete set of cases, this
--   class provides an interpolation from a <i>local</i> position to a
--   <i>global</i> position. While the local position goes from 0 to 1, the
--   global position goes from the <a>onset</a> to the <a>offset</a> of the
--   value.
--   
--   Should satisfy
--   
--   <pre>
--   x^.duration   = x^.era.duration
--   x^.position n = x^.era.position n
--   (transform s x)^.era = transform s (x^.era)
--   </pre>
class HasDuration a => HasPosition a where _position x = alerp a b where (a, b) = (_era x) ^. range _era x = x `_position` 0 <-> x `_position` 1
_position :: HasPosition a => a -> Duration -> Time
_era :: (HasPosition a, HasPosition a) => a -> Span

-- | Position of the given value.
position :: (HasPosition a, Transformable a) => Duration -> Lens' a Time

-- | A lens to the position
era :: (HasPosition a, Transformable a) => Lens' a Span

-- | Onset of the given value.
onset :: (HasPosition a, Transformable a) => Lens' a Time

-- | Midpoint of the given value, or the value between the decay and
--   sustain phases.
midpoint :: (HasPosition a, Transformable a) => Lens' a Time

-- | Onset of the given value.
offset :: (HasPosition a, Transformable a) => Lens' a Time

-- | Pre-onset of the given value, or the value right before the attack
--   phase.
preOnset :: (HasPosition a, Transformable a) => Lens' a Time

-- | Post-offset of the given value, or the value right after the release
--   phase.
postOffset :: (HasPosition a, Transformable a) => Lens' a Time

-- | <i>Deprecated: Use midpoint</i>
postOnset :: (HasPosition a, Transformable a) => Lens' a Time

-- | Move a value forward in time.
startAt :: (Transformable a, HasPosition a) => Time -> a -> a

-- | Move a value forward in time.
stopAt :: (Transformable a, HasPosition a) => Time -> a -> a

-- | Align a value to a given position.
--   
--   <tt>placeAt p t</tt> places the given thing so that its position p is
--   at time t
--   
--   <pre>
--   <a>placeAt</a> 0 = <a>startAt</a>
--   <a>placeAt</a> 1 = <a>stopAt</a>
--   </pre>
placeAt :: (Transformable a, HasPosition a) => Duration -> Time -> a -> a
stretchRelative :: (HasPosition a, Transformable a) => Duration -> Duration -> a -> a
stretchRelativeOnset :: (HasPosition a, Transformable a) => Duration -> a -> a
stretchRelativeMidpoint :: (HasPosition a, Transformable a) => Duration -> a -> a
stretchRelativeOffset :: (HasPosition a, Transformable a) => Duration -> a -> a
delayRelative :: (HasPosition a, Transformable a) => Duration -> Duration -> a -> a
delayRelativeOnset :: (HasPosition a, Transformable a) => Duration -> a -> a
delayRelativeMidpoint :: (HasPosition a, Transformable a) => Duration -> a -> a
delayRelativeOffset :: (HasPosition a, Transformable a) => Duration -> a -> a
transformRelative :: (HasPosition a, Transformable a) => Duration -> Span -> a -> a
transformRelativeOnset :: (HasPosition a, Transformable a) => Span -> a -> a
transformRelativeMidpoint :: (HasPosition a, Transformable a) => Span -> a -> a
transformRelativeOffset :: (HasPosition a, Transformable a) => Span -> a -> a
instance (HasPosition a, Transformable a) => HasPosition [a]
instance (HasPosition a, Transformable a) => HasDuration [a]
instance HasPosition Span


module Music.Time.Split

-- | Class of values that can be split.
--   
--   For non-positioned values such as <tt>Stretched</tt>, split cuts a
--   value into pieces of the given duration and the rest.
--   
--   For positioned values succh as <tt>Note</tt>, split cuts a value
--   relative to its onset. To split at an absolute position, see
--   <a>splitAbs</a>.
--   
--   Law
--   
--   <pre>
--   (<a>beginning</a> t x)^.<a>duration</a> + (<a>ending</a> t x)^.<a>duration</a> = x^.<a>duration</a>
--   
--   (<a>beginning</a> t x)^.<a>duration</a> = t <a>min</a> x^.<a>duration</a>                    iff t &gt;= 0
--   
--   (<a>ending</a> t x)^.<a>duration</a>    = x^.<a>duration</a> - (t <a>min</a> x^.<a>duration</a>)    iff t &gt;= 0
--   </pre>
--   
--   (Note that any of these three laws can be derived from the other two,
--   so it is sufficient to prove two!).
--   
--   <pre>
--   &gt;&gt;&gt; (\x -&gt; fmap (flip split x) [-2,-1,0,0.5,1,2]) $ (1::Duration)
--   [(0,1),(0,1),(0,1),((1/2),(1/2)),(1,0),(1,0)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (\x -&gt; fmap (flip split x) [-2,-1,0,0.5,1,2]) $ (0&lt;-&gt;1)
--   [(0 &lt;-&gt; 0,0 &lt;-&gt; 1),(0 &lt;-&gt; 0,0 &lt;-&gt; 1),(0 &lt;-&gt; 0,0 &lt;-&gt; 1),(0 &lt;-&gt; (1/2),(1/2) &lt;-&gt; 1),(0 &lt;-&gt; 1,1 &lt;-&gt; 1),(0 &lt;-&gt; 1,1 &lt;-&gt; 1)]
--   </pre>
class HasDuration a => Splittable a where split d x = (beginning d x, ending d x) beginning d = fst . split d ending d = snd . split d
split :: Splittable a => Duration -> a -> (a, a)
beginning :: Splittable a => Duration -> a -> a
ending :: Splittable a => Duration -> a -> a
chunks :: (Splittable a, HasDuration a, Transformable a) => Duration -> a -> [a]
instance Splittable Duration
instance Splittable ()
instance HasDuration ()


-- | Provides reversible values.
module Music.Time.Reverse

-- | Class of values that can be reversed (retrograded).
--   
--   For positioned values succh as <tt>Note</tt>, the value is reversed
--   relative to its middle point, i.e. the onset value becomes the offset
--   value and vice versa.
--   
--   For non-positioned values such as <tt>Stretched</tt>, the value is
--   reversed in-place.
--   
--   FIXME Second law is incompatible with <a>revDefault</a> (and the
--   <a>Span</a> definition below)
--   
--   Law
--   
--   <pre>
--   <a>rev</a> (<a>rev</a> a) = a
--   </pre>
--   
--   <pre>
--   <a>abs</a> (x^.<a>duration</a>) = (<a>rev</a> x)^.<a>duration</a>
--   </pre>
--   
--   <pre>
--   <a>rev</a> s <a>transform</a> a = <a>rev</a> (s <a>transform</a> a)
--   </pre>
--   
--   or equivalently,
--   
--   <pre>
--   <a>transform</a> . <a>rev</a> = <a>fmap</a> <a>rev</a> . <a>transform</a>
--   </pre>
--   
--   For <a>Span</a>
--   
--   <pre>
--   <a>rev</a> = <a>over</a> <a>range</a> <tt>swap</tt>
--   </pre>
class Transformable a => Reversible a
rev :: Reversible a => a -> a

-- | View the reverse of a value.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; reversed %~ Data.List.sort
--   [3,2,1]
--   </pre>
reversed :: Reversible a => Iso' a a

-- | A default implementation of <a>rev</a>
revDefault :: (HasPosition a, Transformable a) => a -> a
newtype NoReverse a
NoReverse :: a -> NoReverse a
getNoReverse :: NoReverse a -> a
instance Typeable NoReverse
instance Eq a => Eq (NoReverse a)
instance Ord a => Ord (NoReverse a)
instance Show a => Show (NoReverse a)
instance Reversible (NoReverse a)
instance Transformable (NoReverse a)
instance Reversible a => Reversible (b, a)
instance Reversible Span
instance Reversible Duration
instance (Ord k, Reversible a) => Reversible (Map k a)
instance Reversible a => Reversible (Seq a)
instance Reversible a => Reversible [a]
instance Reversible Integer
instance Reversible Double
instance Reversible Int
instance Reversible ()


module Music.Time.Juxtapose

-- | <pre>
--   (a <a>lead</a> b)^.<a>offset</a> = b^.<a>onset</a>
--   </pre>
lead :: (HasPosition a, HasPosition b, Transformable a) => a -> b -> a

-- | <pre>
--   a^.<a>offset</a> = (a <a>follow</a> b)^.<a>onset</a>
--   </pre>
follow :: (HasPosition a, HasPosition b, Transformable b) => a -> b -> b
after :: (Semigroup a, Transformable a, HasPosition a) => a -> a -> a
before :: (Semigroup a, Transformable a, HasPosition a) => a -> a -> a

-- | Move a value so that its era is equal to the era of another value.
during :: (HasPosition a, HasPosition b, Transformable a, Transformable b) => a -> b -> a

-- | An infix alias for <a>after</a>.
(|>) :: (Semigroup a, HasPosition a, Transformable a) => a -> a -> a

-- | An infix alias for <a>before</a>.
(<|) :: (Semigroup a, HasPosition a, Transformable a) => a -> a -> a

-- | Like <a>&lt;&gt;</a>, but scaling the second agument to the duration
--   of the first.
sustain :: (Semigroup a, HasPosition a, Transformable a) => a -> a -> a

-- | A value followed by its reverse (retrograde).
palindrome :: (Semigroup a, Reversible a, HasPosition a) => a -> a

-- | Compose a list of sequential objects, with onset and offset tangent to
--   one another.
--   
--   For non-positioned types, this is the often same as <a>mconcat</a> For
--   positioned types, this is the same as <tt>afterAnother</tt>
scat :: (Semigroup a, Monoid a, HasPosition a, Transformable a) => [a] -> a

-- | Compose a list of parallel objects, so that their local origins align.
--   
--   This not possible for non-positioned types, as they have no notion of
--   an origin. For positioned types this is the same as <a>mconcat</a>.
pcat :: (Semigroup a, Monoid a) => [a] -> a

-- | Repeat exact amount of times.
--   
--   <pre>
--   <a>Int</a> -&gt; <tt>Score</tt> a -&gt; <tt>Score</tt> a
--   </pre>
times :: (Semigroup a, Monoid a, HasPosition a, Transformable a) => Int -> a -> a


-- | Many time structures such as <tt>Score</tt> allows for rests between
--   notes. Generally rests are simply treated as blank space, and thus
--   have no duration. Sometimes it is useful to represent rests
--   explicitly, so this module provides an alias for <a>pure</a>
--   <a>Nothing</a> that can be used to that end.
--   
--   To remove rests from a score, use <tt>mcatMaybes</tt>, for example:
--   
--   <pre>
--   open $ mcatMaybes $ scat [c,d,rest^*2,e]^/8
--   </pre>
module Music.Time.Rest
rest :: Applicative f => f (Maybe a)


module Music.Time.Bound

-- | <a>Bound</a> restricts the start and stop time of a value, and
--   prevents access to values outside the bounds.
--   
--   <a>Bound</a> is especially useful to restrict the range of a
--   <tt>Behavior</tt>. If we have a value with can only be reasonably
--   defined for a particular time range, we can represent it as
--   <a>Bound</a> <tt>Behavior</tt>. This is isomorphic to a <tt>Note</tt>
--   <tt>Segment</tt>, and <tt>bounded</tt> whitnesses the isomorphism.
--   
--   <a>Bound</a> is not <tt>Foldable</tt> or <a>Traversable</a>, as that
--   would allow us to access values outside the bounds. However, we can
--   still access values of a <a>Bound</a> <tt>Behavior</tt> in a safe
--   manner using <tt>trim</tt> or <tt>splice</tt>.
newtype Bound a
Bound :: (Span, a) -> Bound a
getBound :: Bound a -> (Span, a)

-- | Add bounds.
bounds :: Time -> Time -> a -> Bound a

-- | Add bounds.
--   
--   <pre>
--   (s,x)^.note = (bounding s . transform s) x
--   </pre>
bounding :: Span -> a -> Bound a
instance Typeable Bound
instance Functor Bound
instance Semigroup a => Semigroup (Bound a)
instance Eq a => Eq (Bound a)
instance Show a => Show (Bound a)
instance (HasPosition a, Transformable a) => HasPosition (Bound a)
instance (HasPosition a, HasDuration a, Transformable a) => HasDuration (Bound a)
instance Transformable a => Transformable (Bound a)
instance Reversible a => Reversible (Bound a)
instance Rewrapped (Bound a) (Bound b)
instance Wrapped (Bound a)

module Data.PairMonad
instance Monoid o => Monad ((,) o)


-- | Defines two variants of <tt>(,)</tt> with lifted instances for the
--   standard type classes.
--   
--   The <a>Functor</a>, <a>Applicative</a> and <a>Comonad</a> instances
--   are the standard instances. The <a>Monad</a> instances are not in base
--   (but should argubly be there). All of these instances are equivalent
--   to <tt>Writer</tt> in transformers.
--   
--   <a>Applicative</a> is used to lift <a>Monoid</a> and the standard
--   numeric classes.
--   
--   The only difference between <a>Twain</a> and <a>Couple</a> is the
--   handling of <a>Eq</a> and <a>Ord</a>: <a>Twain</a> compares only the
--   second value, while <a>Couple</a> compares both. Thus <a>Couple</a>
--   needs an extra <tt>Ord b</tt> constraint for all sub-classes of
--   <a>Ord</a>.
module Data.Functor.Couple

-- | A variant of pair/writer with lifted instances for the numeric
--   classes, using <a>Applicative</a>.
newtype Twain b a
Twain :: (b, a) -> Twain b a
getTwain :: Twain b a -> (b, a)

-- | A variant of pair/writer with lifted instances for the numeric
--   classes, using <a>Applicative</a>.
newtype Couple b a
Couple :: (b, a) -> Couple b a
getCouple :: Couple b a -> (b, a)
instance Typeable Twain
instance Typeable Couple
instance (Show b, Show a) => Show (Twain b a)
instance Functor (Twain b)
instance Traversable (Twain b)
instance Foldable (Twain b)
instance Monoid b => Applicative (Twain b)
instance Monoid b => Monad (Twain b)
instance Comonad (Twain b)
instance (Semigroup b, Semigroup a) => Semigroup (Twain b a)
instance (Monoid b, Monoid a) => Monoid (Twain b a)
instance (Show b, Show a) => Show (Couple b a)
instance Functor (Couple b)
instance Foldable (Couple b)
instance Traversable (Couple b)
instance Monoid b => Applicative (Couple b)
instance Monoid b => Monad (Couple b)
instance Comonad (Couple b)
instance (Semigroup b, Semigroup a) => Semigroup (Couple b a)
instance (Monoid b, Monoid a) => Monoid (Couple b a)
instance (Monoid b, Ord b, RealFrac a) => RealFrac (Couple b a)
instance (Monoid b, Ord b, Real a) => Real (Couple b a)
instance (Monoid b, Ord b, Real a, Enum a, Integral a) => Integral (Couple b a)
instance (Ord b, Ord a) => Ord (Couple b a)
instance (Eq b, Eq a) => Eq (Couple b a)
instance (Monoid b, Bounded a) => Bounded (Couple b a)
instance (Monoid b, Enum a) => Enum (Couple b a)
instance (Monoid b, Floating a) => Floating (Couple b a)
instance (Monoid b, Fractional a) => Fractional (Couple b a)
instance (Monoid b, Num a) => Num (Couple b a)
instance Rewrapped (Couple c a) (Couple c b)
instance Wrapped (Couple b a)
instance (Monoid b, RealFrac a) => RealFrac (Twain b a)
instance (Monoid b, Real a) => Real (Twain b a)
instance (Monoid b, Real a, Enum a, Integral a) => Integral (Twain b a)
instance Ord a => Ord (Twain b a)
instance Eq a => Eq (Twain b a)
instance (Monoid b, Bounded a) => Bounded (Twain b a)
instance (Monoid b, Enum a) => Enum (Twain b a)
instance (Monoid b, Floating a) => Floating (Twain b a)
instance (Monoid b, Fractional a) => Fractional (Twain b a)
instance (Monoid b, Num a) => Num (Twain b a)
instance Rewrapped (Twain c a) (Twain c b)
instance Wrapped (Twain b a)

module Data.List.Ordered
type Positive = Natural
newtype Ordered a
Ordered :: Map a Positive -> Ordered a
getOrdered :: Ordered a -> Map a Positive

-- | Alas, not a functor
map :: (Ord a, Ord b) => (a -> b) -> Ordered a -> Ordered b
toList :: Ordered a -> [a]
unsafeFromList :: Ord a => [a] -> Ordered a
fromList :: Ord a => [a] -> Maybe (Ordered a)
ordered :: Ord a => Prism' [a] (Ordered a)
unsafeOrdered :: Ord a => Iso' [a] (Ordered a)
elem :: Ord a => a -> Ordered a -> Bool
occs :: Ord a => a -> Ordered a -> Int
null :: Ordered k -> Bool
length :: Ordered a -> Int
instance Ord a => Ord (Ordered a)
instance Ord a => Eq (Ordered a)
instance Comonad Max
instance Comonad Min


module Music.Time.Note

-- | A value <a>Note</a> value, representing a suspended stretch of some
--   <a>Transformable</a> value. We can access the value in bothits
--   original and note form using <a>note</a> and <a>notee</a>,
--   respectively.
--   
--   Placing a value inside <a>Note</a> makes it invariant under
--   <a>delay</a>, however the inner value can still be delayed using
--   <tt><a>fmap</a> <a>delay</a></tt>.
data Note a

-- | View a note value as a pair of the original value and a stretch
--   factor.
note :: Iso (Duration, a) (Duration, b) (Note a) (Note b)

-- | Access the note value. Taking a value out carries out the stretch
--   (using the <a>Transformable</a> instance), while putting a value in
--   carries out the reverse transformation.
--   
--   <pre>
--   &gt;&gt;&gt; view notee $ (2,3::Duration)^.note
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set notee 6 $ (2,1::Duration)^.note
--   (2,3)^.note
--   </pre>
notee :: (Transformable a, Transformable b) => Lens (Note a) (Note b) a b

-- | A note value as a duration carrying an associated value. Whitness by
--   picking a trivial value.
--   
--   <pre>
--   &gt;&gt;&gt; 2^.durationNote
--   (2,())^.note
--   </pre>
durationNote :: Iso' Duration (Note ())
instance Typeable Note
instance Eq a => Eq (Note a)
instance Ord a => Ord (Note a)
instance Foldable Note
instance Traversable Note
instance Functor Note
instance Applicative Note
instance Monad Note
instance Num a => Num (Note a)
instance Fractional a => Fractional (Note a)
instance Floating a => Floating (Note a)
instance Real a => Real (Note a)
instance RealFrac a => RealFrac (Note a)
instance ToJSON a => ToJSON (Note a)
instance IsDynamics a => IsDynamics (Note a)
instance IsInterval a => IsInterval (Note a)
instance IsPitch a => IsPitch (Note a)
instance IsString a => IsString (Note a)
instance (Splittable a, Transformable a) => Splittable (Note a)
instance HasDuration (Note a)
instance Transformable (Note a)
instance Rewrapped (Note a) (Note b)
instance Wrapped (Note a)
instance (Show a, Transformable a) => Show (Note a)


module Music.Time.Voice

-- | A <a>Voice</a> is a sequential composition of non-overlapping note
--   values.
--   
--   Both <a>Voice</a> and <a>Note</a> have duration but no position. The
--   difference is that <a>Note</a> sustains a single value throughout its
--   duration, while a voice may contain multiple values. It is called
--   voice because it is generalizes the notation of a voice in choral or
--   multi-part instrumental music.
--   
--   It may be useful to think about <a>Voice</a> and <a>Note</a> as
--   vectors in time space (i.e. <a>Duration</a>), that also happens to
--   carry around other values, such as pitches.
data Voice a

-- | Create a <a>Voice</a> from a list of <a>Note</a>s.
voice :: Getter [Note a] (Voice a)

-- | View a <a>Voice</a> as a list of <a>Note</a> values.
notes :: Lens (Voice a) (Voice b) [Note a] [Note b]

-- | View a score as a list of duration-value pairs. Analogous to
--   <tt>triples</tt>.
pairs :: Lens (Voice a) (Voice b) [(Duration, a)] [(Duration, b)]
durationsVoice :: Iso' [Duration] (Voice ())

-- | A lens to the values in a voice.
valuesV :: Lens (Voice a) (Voice b) [a] [b]

-- | A lens to the durations in a voice.
durationsV :: Lens' (Voice a) [Duration]

-- | Unzip the given voice.
unzipVoice :: Voice (a, b) -> (Voice a, Voice b)

-- | Join the given voices by multiplying durations and pairing values.
zipVoiceScale :: Voice a -> Voice b -> Voice (a, b)

-- | Join the given voices by multiplying durations and pairing values.
zipVoiceScale3 :: Voice a -> Voice b -> Voice c -> Voice (a, (b, c))

-- | Join the given voices by multiplying durations and pairing values.
zipVoiceScale4 :: Voice a -> Voice b -> Voice c -> Voice d -> Voice (a, (b, (c, d)))

-- | Join the given voices by pairing values and selecting the first
--   duration.
zipVoiceNoScale :: Voice a -> Voice b -> Voice (a, b)

-- | Join the given voices by pairing values and selecting the first
--   duration.
zipVoiceNoScale3 :: Voice a -> Voice b -> Voice c -> Voice (a, (b, c))

-- | Join the given voices by pairing values and selecting the first
--   duration.
zipVoiceNoScale4 :: Voice a -> Voice b -> Voice c -> Voice d -> Voice (a, (b, (c, d)))

-- | Join the given voices by multiplying durations and combining values
--   using the given function.
zipVoiceScaleWith :: (a -> b -> c) -> Voice a -> Voice b -> Voice c

-- | Join the given voices without combining durations.
zipVoiceWithNoScale :: (a -> b -> c) -> Voice a -> Voice b -> Voice c

-- | Join the given voices by combining durations and values using the
--   given function.
zipVoiceWith' :: (Duration -> Duration -> Duration) -> (a -> b -> c) -> Voice a -> Voice b -> Voice c

-- | Merge consecutive equal notes.
fuse :: Eq a => Voice a -> Voice a

-- | Merge consecutive notes deemed equal by the given predicate.
fuseBy :: (a -> a -> Bool) -> Voice a -> Voice a

-- | Fuse all rests in the given voice. The resulting voice will have no
--   consecutive rests.
fuseRests :: Voice (Maybe a) -> Voice (Maybe a)

-- | Remove all rests in the given voice by prolonging the previous note.
--   Returns <a>Nothing</a> if and only if the given voice contains rests
--   only.
coverRests :: Voice (Maybe a) -> Maybe (Voice a)

-- | Whether two notes have exactly the same duration pattern. Two empty
--   voices are considered to have the same duration pattern. Voices with
--   an non-equal number of notes differ by default.
sameDurations :: Voice a -> Voice b -> Bool

-- | Pair the values of two voices if and only if they have the same
--   duration pattern (as per <a>sameDurations</a>).
mergeIfSameDuration :: Voice a -> Voice b -> Maybe (Voice (a, b))

-- | Combine the values of two voices using the given function if and only
--   if they have the same duration pattern (as per <a>sameDurations</a>).
mergeIfSameDurationWith :: (a -> b -> c) -> Voice a -> Voice b -> Maybe (Voice c)

-- | Split a homophonic texture into a polyphonic one. The returned voice
--   list will not have as many elements as the chord with the fewest
--   number of notes.
homoToPolyphonic :: Voice [a] -> [Voice a]

-- | Returns the onsets of all notes in a voice given the onset of the
--   first note.
onsetsRelative :: Time -> Voice a -> [Time]

-- | Returns the offsets of all notes in a voice given the onset of the
--   first note.
offsetsRelative :: Time -> Voice a -> [Time]

-- | Returns the midpoints of all notes in a voice given the onset of the
--   first note.
midpointsRelative :: Time -> Voice a -> [Time]

-- | Returns the eras of all notes in a voice given the onset of the first
--   note.
erasRelative :: Time -> Voice a -> [Span]

-- | Decorate all notes in a voice with their context, i.e. previous and
--   following value if present.
withContext :: Voice a -> Voice (Ctxt a)

-- | A voice is a list of notes up to meta-data. To preserve meta-data, use
--   the more restricted <a>voice</a> and <a>notes</a>.
unsafeNotes :: Iso (Voice a) (Voice b) [Note a] [Note b]

-- | A score is a list of (duration-value pairs) up to meta-data. To
--   preserve meta-data, use the more restricted <a>pairs</a>.
unsafePairs :: Iso (Voice a) (Voice b) [(Duration, a)] [(Duration, b)]
instance Typeable Voice
instance Eq a => Eq (Voice a)
instance Ord a => Ord (Voice a)
instance Foldable Voice
instance Traversable Voice
instance Functor Voice
instance Semigroup (Voice a)
instance Monoid (Voice a)
instance Num a => Num (Voice a)
instance Enum a => Enum (Voice a)
instance IsDynamics a => IsDynamics (Voice a)
instance IsInterval a => IsInterval (Voice a)
instance IsPitch a => IsPitch (Voice a)
instance IsString a => IsString (Voice a)
instance (Transformable a, Splittable a) => Splittable (Voice a)
instance Reversible a => Reversible (Voice a)
instance HasDuration (Voice a)
instance Transformable (Voice a)
instance ToJSON a => ToJSON (Voice a)
instance Snoc (Voice a) (Voice b) (Note a) (Note b)
instance Cons (Voice a) (Voice b) (Note a) (Note b)
instance Rewrapped (Voice a) (Voice b)
instance Wrapped (Voice a)
instance MonadPlus Voice
instance Monad Voice
instance Alternative Voice
instance Applicative Voice
instance (Show a, Transformable a) => Show (Voice a)


module Music.Time.Placed

-- | <a>Placed</a> represents a value with an offset in time.
--   
--   A placed value has a known <a>position</a>, but no <a>duration</a>.
--   
--   Placing a value inside <a>Placed</a> does not make it invariant under
--   <a>stretch</a>, as the offset of a placed value may be stretched with
--   respect to the origin. However, in contrast to a note the
--   <i>duration</i> is not stretched.
data Placed a
placed :: Iso (Time, a) (Time, b) (Placed a) (Placed b)
placee :: (Transformable a, Transformable b) => Lens (Placed a) (Placed b) a b
instance Typeable Placed
instance Eq a => Eq (Placed a)
instance Ord a => Ord (Placed a)
instance Foldable Placed
instance Traversable Placed
instance Functor Placed
instance Applicative Placed
instance Monad Placed
instance Comonad Placed
instance IsDynamics a => IsDynamics (Placed a)
instance IsInterval a => IsInterval (Placed a)
instance IsPitch a => IsPitch (Placed a)
instance IsString a => IsString (Placed a)
instance Transformable a => Transformable (Placed a)
instance Rewrapped (Placed a) (Placed b)
instance Wrapped (Placed a)
instance (Show a, Transformable a) => Show (Placed a)


module Music.Time.Track

-- | A <a>Track</a> is a parallel composition of values.
data Track a

-- | Create a track from a list of notes.
track :: Getter [Placed a] (Track a)
placeds :: Lens (Track a) (Track b) [Placed a] [Placed b]
instance Typeable Track
instance Functor Track
instance Foldable Track
instance Traversable Track
instance Semigroup (Track a)
instance Monoid (Track a)
instance (Show a, Transformable a) => Show (Track a)
instance Eq a => Eq (Track a)
instance Transformable a => Transformable (Track a)
instance Rewrapped (Track a) (Track b)
instance Wrapped (Track a)
instance Monad Track
instance Alternative Track
instance Applicative Track


-- | Provides a way to annotate data-types with <a>Transformable</a>
--   meta-data. Inspired by Clojure meta-data and Diagrams styles.
module Music.Time.Meta

-- | Class of values that can be wrapped.
type AttributeClass a = (Typeable a, Monoid a, Semigroup a)

-- | Class of values that can be wrapped and transformed.
type TAttributeClass a = (Transformable a, AttributeClass a)

-- | An existential wrapper type to hold attributes.
data Attribute :: *

-- | Wrap up an attribute.
wrapAttr :: AttributeClass a => a -> Attribute

-- | Wrap up a transformable attribute.
wrapTAttr :: TAttributeClass a => a -> Attribute

-- | Convert something from an attribute. Also works with transformable
--   attributes
unwrapAttr :: AttributeClass a => Attribute -> Maybe a
data Meta

-- | Convert something from meta-data. Also works with transformable
--   attributes
wrapMeta :: AttributeClass a => a -> Meta

-- | Convert something to meta-data.
wrapTMeta :: TAttributeClass a => a -> Meta

-- | Convert something from meta-data.
unwrapMeta :: AttributeClass a => Meta -> Maybe a

-- | Type class for things which have meta-data.
class HasMeta a
meta :: HasMeta a => Lens' a Meta

-- | Extract meta-data.
getMeta :: HasMeta a => a -> Meta

-- | Map over meta-data.
mapMeta :: HasMeta a => (Meta -> Meta) -> a -> a

-- | Update meta-data.
setMeta :: HasMeta a => Meta -> a -> a

-- | Show the types of meta-data attachd to this value. Useful for
--   debugging.
metaTypes :: HasMeta a => a -> [String]

-- | Apply meta-information by combining it with existing meta-information.
applyMeta :: HasMeta a => Meta -> a -> a

-- | Update a meta attribute.
setMetaAttr :: (AttributeClass b, HasMeta a) => b -> a -> a

-- | Update a meta attribute.
setMetaTAttr :: (TAttributeClass b, HasMeta a) => b -> a -> a

-- | Apply a function without affecting meta-data.
preserveMeta :: (HasMeta a, HasMeta b) => (a -> b) -> a -> b

-- | Annotate an arbitrary type with meta-data, preserving instances of all
--   common type classes. In particular <a>Functor</a> and
--   <a>Applicative</a> is lifted and <tt><tt>Compose</tt>
--   <a>AddMeta</a></tt> is semantically equivalent to <a>Identity</a>.
data AddMeta a

-- | Access the annotated value.
--   
--   <pre>
--   over annotated = fmap
--   </pre>
annotated :: Lens (AddMeta a) (AddMeta b) a b

-- | Access the annotated value.
--   
--   <pre>
--   view fromAnnotated = pure
--   </pre>
unannotated :: Getter a (AddMeta a)

-- | Access the annotated value. This is only an isomorphism up to
--   meta-data equivalence. In particular <tt>under unsafeAnnotated</tt>
--   leads to meta-data being thrown away. See <a>annotated</a> and
--   <a>unannotated</a> for safe (but less general) definitions.
--   
--   <pre>
--   over annotated = fmap
--   </pre>
unsafeAnnotated :: Iso (AddMeta a) (AddMeta b) a b
instance Typeable AddMeta
instance Transformable Meta
instance Reversible Meta
instance Show a => Show (AddMeta a)
instance Functor AddMeta
instance Foldable AddMeta
instance Applicative AddMeta
instance Monad AddMeta
instance Comonad AddMeta
instance Semigroup a => Semigroup (AddMeta a)
instance Monoid a => Monoid (AddMeta a)
instance Num a => Num (AddMeta a)
instance Fractional a => Fractional (AddMeta a)
instance Floating a => Floating (AddMeta a)
instance Enum a => Enum (AddMeta a)
instance Bounded a => Bounded (AddMeta a)
instance Integral a => Integral (AddMeta a)
instance Real a => Real (AddMeta a)
instance RealFrac a => RealFrac (AddMeta a)
instance Eq a => Eq (AddMeta a)
instance Ord a => Ord (AddMeta a)
instance HasDuration a => HasDuration (AddMeta a)
instance HasPosition a => HasPosition (AddMeta a)
instance Splittable a => Splittable (AddMeta a)
instance Reversible a => Reversible (AddMeta a)
instance Transformable a => Transformable (AddMeta a)
instance HasMeta (AddMeta a)
instance Rewrapped (AddMeta a) (AddMeta b)
instance Wrapped (AddMeta a)
instance HasMeta a => HasMeta (Twain b a)
instance HasMeta a => HasMeta (b, a)
instance HasMeta a => HasMeta (Maybe a)
instance HasMeta Meta
instance Show Meta
instance Monoid Meta
instance Semigroup Meta
instance Reversible Attribute
instance Transformable Attribute
instance Semigroup Attribute


module Music.Time.Event
data Event a

-- | View a event as a pair of the original value and the transformation
--   (and vice versa).
event :: Iso (Span, a) (Span, b) (Event a) (Event b)

-- | View the value in the event.
eventee :: (Transformable a, Transformable b) => Lens (Event a) (Event b) a b

-- | Event as a span with a trivial value.
spanEvent :: Iso' Span (Event ())

-- | View a event as a <tt>(time, duration, value)</tt> triple.
triple :: Iso (Event a) (Event b) (Time, Duration, a) (Time, Duration, b)
instance Typeable Event
instance Eq a => Eq (Event a)
instance Ord a => Ord (Event a)
instance Foldable Event
instance Applicative Event
instance Monad Event
instance Traversable Event
instance Functor Event
instance Num a => Num (Event a)
instance Fractional a => Fractional (Event a)
instance Floating a => Floating (Event a)
instance Real a => Real (Event a)
instance RealFrac a => RealFrac (Event a)
instance Comonad Event
instance ToJSON a => ToJSON (Event a)
instance (Show a, Transformable a) => Show (Event a)
instance IsDynamics a => IsDynamics (Event a)
instance IsInterval a => IsInterval (Event a)
instance IsPitch a => IsPitch (Event a)
instance IsString a => IsString (Event a)
instance HasMeta (Event a)
instance HasPosition (Event a)
instance HasDuration (Event a)
instance Transformable (Event a)
instance Rewrapped (Event a) (Event b)
instance Wrapped (Event a)
instance (Comonad f, Comonad g) => Comonad (Compose f g)
instance (Functor f, Monad f, Monad g, Traversable g) => Monad (Compose f g)
instance (RealFrac (f (g a)), Ord1 f, Ord1 g, Ord a, Functor f) => RealFrac (Compose f g a)
instance (Real (f (g a)), Ord1 f, Ord1 g, Ord a, Functor f) => Real (Compose f g a)
instance Floating (f (g a)) => Floating (Compose f g a)
instance Fractional (f (g a)) => Fractional (Compose f g a)
instance Num (f (g a)) => Num (Compose f g a)
instance Ord a => Ord1 (Couple a)
instance Ord1 AddMeta
instance Eq a => Eq1 (Couple a)
instance Eq1 AddMeta
instance Traversable AddMeta


module Music.Time.Score

-- | A <a>Score</a> is a sequential or parallel composition of values, and
--   allows overlapping events
data Score a

-- | Create a score from a list of events.
score :: Getter [Event a] (Score a)

-- | View a <a>Score</a> as a list of <a>Event</a> values.
events :: Lens (Score a) (Score b) [Event a] [Event b]

-- | Print all eras of the given score.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf eras $ scat [c,d,e :: Score Integer]
--   [0 &lt;-&gt; 1,1 &lt;-&gt; 2,2 &lt;-&gt; 3]
--   </pre>
eras :: Traversal' (Score a) Span

-- | View a score as a list of time-duration-value triplets.
triples :: Lens (Score a) (Score b) [(Time, Duration, a)] [(Time, Duration, b)]

-- | Map over the values in a score.
mapWithSpan :: (Span -> a -> b) -> Score a -> Score b

-- | Filter the values in a score.
filterWithSpan :: (Span -> a -> Bool) -> Score a -> Score a

-- | Combination of <a>mapTriples</a> and <a>filterTriples</a>.
mapFilterWithSpan :: (Span -> a -> Maybe b) -> Score a -> Score b

-- | Map over the values in a score.
mapTriples :: (Time -> Duration -> a -> b) -> Score a -> Score b

-- | Filter the values in a score.
filterTriples :: (Time -> Duration -> a -> Bool) -> Score a -> Score a

-- | Efficient combination of <a>mapTriples</a> and <a>filterTriples</a>.
mapFilterTriples :: (Time -> Duration -> a -> Maybe b) -> Score a -> Score b
hasOverlappingEvents :: Score a -> Bool

-- | Merge all simultaneous events using their <a>Semigroup</a> instance.
simultaneous :: (Transformable a, Semigroup a) => Score a -> Score a

-- | Normalize a score, assuring its events spans are all forward (as by
--   <a>isForwardSpan</a>), and that its onset is at least zero.
--   Consequently, the onset and offset of each event in the score is at
--   least zero.
normalizeScore :: Score a -> Score a
removeRests :: Score (Maybe a) -> Score a

-- | Print the span of each event, as given by <a>eras</a>.
printEras :: Score a -> IO ()

-- | A score is a list of events up to meta-data. To preserve meta-data,
--   use the more restricted <a>score</a> and <a>events</a>.
unsafeEvents :: Iso (Score a) (Score b) [Event a] [Event b]

-- | A score is a list of (time-duration-value triples) up to meta-data. To
--   preserve meta-data, use the more restricted <a>triples</a>.
unsafeTriples :: Iso (Score a) (Score b) [(Time, Duration, a)] [(Time, Duration, b)]
instance Typeable Score'
instance Typeable Score
instance Functor Score'
instance Foldable Score'
instance Traversable Score'
instance Semigroup (Score' a)
instance Monoid (Score' a)
instance (Show a, Transformable a) => Show (Score' a)
instance Eq a => Eq (Score' a)
instance Functor Score
instance Semigroup (Score a)
instance Monoid (Score a)
instance Foldable Score
instance Traversable Score
instance HasDuration (Score' a)
instance HasPosition (Score' a)
instance Transformable (Score' a)
instance MonadPlus Score'
instance Alternative Score'
instance Monad Score'
instance Applicative Score'
instance Rewrapped (Score' a) (Score' b)
instance Wrapped (Score' a)
instance (Show a, Transformable a) => Show (Score a)
instance HasMeta (Score a)
instance Num a => Num (Score a)
instance Enum a => Enum (Score a)
instance IsDynamics a => IsDynamics (Score a)
instance IsInterval a => IsInterval (Score a)
instance IsPitch a => IsPitch (Score a)
instance IsString a => IsString (Score a)
instance HasDuration (Score a)
instance HasPosition (Score a)
instance Transformable (Score a)
instance ToJSON a => ToJSON (Score a)
instance MonadPlus Score
instance Alternative Score
instance Monad Score
instance Applicative Score
instance Rewrapped (Score a) (Score b)
instance Wrapped (Score a)


module Music.Time.Aligned
class Alignable a
align :: Alignable a => LocalDuration -> a -> a

-- | <a>Aligned</a> places a vector-like object in space, by fixing a local
--   duration interpolating the vector to a specific point in time. The
--   aligned value must be an instance of <a>HasDuration</a>, with
--   <tt><a>view</a> <a>duration</a></tt> providing the size of the vector.
--   
--   This is analogous to alignment in a graphical program. To align
--   something at onset, midpoint or offset, use 0, 0.5 or 1 as the local
--   duration value.
data Aligned v

-- | Align the given value so that its local duration occurs at the given
--   time.
aligned :: Time -> LocalDuration -> v -> Aligned v

-- | Change the alignment of a value without moving it.
--   
--   <pre>
--   x^.<a>era</a> = (<a>realign</a> l x)^.<a>era</a>
--   </pre>
realign :: (HasDuration a, Transformable a) => LocalDuration -> Aligned a -> Aligned a

-- | Render an aligned value. The given span represents the actual span of
--   the aligned value.
renderAligned :: (HasDuration a, Transformable a) => (Span -> a -> b) -> Aligned a -> b

-- | Convert an aligned voice to a score.
renderAlignedVoice :: Aligned (Voice a) -> Score a

-- | Convert an aligned note to an event.
renderAlignedNote :: Aligned (Note a) -> Event a

-- | Convert an aligned duration to a span.
renderAlignedDuration :: Aligned Duration -> Span
instance Functor Aligned
instance Eq v => Eq (Aligned v)
instance Ord v => Ord (Aligned v)
instance Foldable Aligned
instance Traversable Aligned
instance (HasDuration v, Transformable v) => HasPosition (Aligned v)
instance (HasDuration v, Transformable v) => HasDuration (Aligned v)
instance Transformable v => Transformable (Aligned v)
instance ToJSON a => ToJSON (Aligned a)
instance Show a => Show (Aligned a)
instance Rewrapped (Aligned a) (Aligned b)
instance Wrapped (Aligned v)
instance Alignable (Aligned a)
instance Alignable a => Alignable [a]


module Music.Time.Behavior

-- | A <a>Behavior</a> is a value varying over time.
--   
--   Use <tt>focusing</tt> to view a particular <tt>Segment</tt>.
data Behavior a

-- | View a behavior as a time function and vice versa.
--   
--   Note that this is just an alias defined to make the documentation
--   nicer:
--   
--   <pre>
--   <a>behavior</a> = <a>tabulated</a>
--   </pre>
behavior :: Iso (Time -> a) (Time -> b) (Behavior a) (Behavior b)

-- | Instantly switch from one behavior to another.
switch :: Time -> Behavior a -> Behavior a -> Behavior a

-- | Instantly switch from one behavior to another with an optinal
--   intermediate value.
switch' :: Time -> Behavior a -> Behavior a -> Behavior a -> Behavior a

-- | Replace everthing before the given time by <a>mempty</a>.
trimBefore :: Monoid a => Time -> Behavior a -> Behavior a

-- | Replace everthing after the given time by <a>mempty</a>.
trimAfter :: Monoid a => Time -> Behavior a -> Behavior a

-- | A behavior that gives the current time.
--   
--   Should really have the type <a>Behavior</a> <a>Time</a>, but is
--   provided in a more general form for convenience.
line :: Fractional a => Behavior a

-- | A behavior that goes from 0 to 1 repeatedly with a period of 1.
sawtooth :: RealFrac a => Behavior a

-- | A behavior that
sine :: Floating a => Behavior a

-- | A behavior that
cosine :: Floating a => Behavior a

-- | A behavior that varies from 0 to 1 during the same time interval and
--   is 0 before and 1 after that interval.
unit :: Fractional a => Behavior a

-- | A behavior that is 1 at time 0, and 0 at all other times.
impulse :: Num a => Behavior a

-- | A behavior that goes from 0 to 1 at time 0.
turnOn :: Behavior Integer

-- | A behavior that goes from 1 to 0 at time 0.
turnOff :: Behavior Integer
instance Typeable Behavior
instance AdditiveGroup a => AdditiveGroup (Behavior a)
instance Floating a => Floating (Behavior a)
instance Fractional a => Fractional (Behavior a)
instance Num a => Num (Behavior a)
instance Monoid a => Monoid (Behavior a)
instance Semigroup a => Semigroup (Behavior a)
instance Functor Behavior
instance Applicative Behavior
instance Monad Behavior
instance AffineSpace a => AffineSpace (Behavior a)
instance VectorSpace a => VectorSpace (Behavior a)
instance Enum a => Enum (Behavior a)
instance Ord a => Ord (Behavior a)
instance Eq a => Eq (Behavior a)
instance Augmentable a => Augmentable (Behavior a)
instance Alterable a => Alterable (Behavior a)
instance IsDynamics a => IsDynamics (Behavior a)
instance IsInterval a => IsInterval (Behavior a)
instance IsPitch a => IsPitch (Behavior a)
instance IsString a => IsString (Behavior a)
instance Real a => Real (Behavior a)
instance Reversible (Behavior a)
instance Transformable (Behavior a)
instance Representable Behavior
instance Distributive Behavior
instance Show (Behavior a)

module Data.Clipped

-- | A value in the unit interval <i>(0,1)</i>.
data Clipped a
clipped :: (Num a, Ord a) => Prism' a (Clipped a)
fromClipped :: (Ord a, Num a) => Clipped a -> a
unsafeToClipped :: (Ord a, Num a) => a -> Clipped a
instance Eq a => Eq (Clipped a)
instance Ord a => Ord (Clipped a)
instance Show a => Show (Clipped a)
instance (Num a, Ord a, Fractional a) => Fractional (Clipped a)
instance (Num a, Ord a) => Num (Clipped a)
instance Num a => Bounded (Clipped a)


module Music.Time.Segment

-- | A <a>Behavior</a> is a value varying over time.
--   
--   Use <tt>focusing</tt> to view a particular <tt>Segment</tt>.
data Behavior a

-- | View a behavior as a time function and vice versa.
--   
--   Note that this is just an alias defined to make the documentation
--   nicer:
--   
--   <pre>
--   <a>behavior</a> = <a>tabulated</a>
--   </pre>
behavior :: Iso (Time -> a) (Time -> b) (Behavior a) (Behavior b)

-- | A behavior that gives the current time.
--   
--   Should really have the type <a>Behavior</a> <a>Time</a>, but is
--   provided in a more general form for convenience.
line :: Fractional a => Behavior a

-- | A behavior that varies from 0 to 1 during the same time interval and
--   is 0 before and 1 after that interval.
unit :: Fractional a => Behavior a

-- | A behavior that is 1 at time 0, and 0 at all other times.
impulse :: Num a => Behavior a

-- | A behavior that goes from 0 to 1 at time 0.
turnOn :: Behavior Integer

-- | A behavior that goes from 1 to 0 at time 0.
turnOff :: Behavior Integer

-- | A behavior that goes from 0 to 1 repeatedly with a period of 1.
sawtooth :: RealFrac a => Behavior a

-- | A behavior that
sine :: Floating a => Behavior a

-- | A behavior that
cosine :: Floating a => Behavior a

-- | Instantly switch from one behavior to another.
switch :: Time -> Behavior a -> Behavior a -> Behavior a

-- | Instantly switch from one behavior to another with an optinal
--   intermediate value.
switch' :: Time -> Behavior a -> Behavior a -> Behavior a -> Behavior a

-- | Inserts a bounded behavior on top of another behavior.
--   
--   <pre>
--   <a>trim</a> = <a>splice</a> <a>mempty</a>
--   </pre>
--   
--   (Named after the analogous tape-editing technique.)
splice :: Behavior a -> Bound (Behavior a) -> Behavior a

-- | Extract a bounded behavior, replacing all values outside the bound
--   with <a>mempty</a>.
--   
--   <pre>
--   <a>trim</a>   = <a>splice</a> <a>mempty</a>
--   <a>trim</a> x = <a>trimBefore</a> (x^.<a>onset</a>) . <a>trimAfter</a> (x^.<a>offset</a>)
--   </pre>
trim :: Monoid b => Bound (Behavior b) -> Behavior b

-- | Replace everthing before the given time by <a>mempty</a>.
trimBefore :: Monoid a => Time -> Behavior a -> Behavior a

-- | Replace everthing after the given time by <a>mempty</a>.
trimAfter :: Monoid a => Time -> Behavior a -> Behavior a

-- | Concatenate a score of (possibly overlapping) segments.
--   
--   See also <a>concatSegment</a> and <tt>continous</tt>.
concatB :: Monoid a => Score (Behavior a) -> Behavior a

-- | A <a>Segment</a> is a value varying over some unknown time span.
--   Intuitively, a <a>Segment</a> is to a <a>Behavior</a> what a
--   <i>ray</i> is to a <i>line</i>.
--   
--   To give a segment an explicit duration, use <a>Event</a>
--   <a>Segment</a>.
--   
--   To place a segment in a particular time span, use <a>Event</a>
--   <a>Segment</a>.
data Segment a

-- | View a segment as a time function and vice versa.
segment :: Iso (Duration -> a) (Duration -> b) (Segment a) (Segment b)

-- | View part of a <a>Behavior</a> as a <a>Segment</a>.
--   
--   <pre>
--   <a>line</a> &amp; <a>focusing</a> <tt>onSpan</tt> (2 <a>&lt;-&gt;</a> 3) <a>*~</a> 0
--   </pre>
focusing :: Lens' (Behavior a) (Segment a)
apSegments' :: Note (Segment a) -> Note (Segment a) -> Note (Segment a)

-- | Append a voice of segments to a single note segment.
apSegments :: Voice (Segment a) -> Note (Segment a)

-- | <a>Bound</a> restricts the start and stop time of a value, and
--   prevents access to values outside the bounds.
--   
--   <a>Bound</a> is especially useful to restrict the range of a
--   <tt>Behavior</tt>. If we have a value with can only be reasonably
--   defined for a particular time range, we can represent it as
--   <a>Bound</a> <tt>Behavior</tt>. This is isomorphic to a <tt>Note</tt>
--   <tt>Segment</tt>, and <tt>bounded</tt> whitnesses the isomorphism.
--   
--   <a>Bound</a> is not <tt>Foldable</tt> or <a>Traversable</a>, as that
--   would allow us to access values outside the bounds. However, we can
--   still access values of a <a>Bound</a> <tt>Behavior</tt> in a safe
--   manner using <tt>trim</tt> or <tt>splice</tt>.
data Bound a

-- | Add bounds.
bounds :: Time -> Time -> a -> Bound a

-- | Add bounds.
--   
--   <pre>
--   (s,x)^.note = (bounding s . transform s) x
--   </pre>
bounding :: Span -> a -> Bound a

-- | Extract a bounded behavior, replacing all values outside the bound
--   with <a>mempty</a>.
--   
--   <pre>
--   <a>trim</a>   = <a>splice</a> <a>mempty</a>
--   <a>trim</a> x = <a>trimBefore</a> (x^.<a>onset</a>) . <a>trimAfter</a> (x^.<a>offset</a>)
--   </pre>
trim :: Monoid b => Bound (Behavior b) -> Behavior b

-- | Inserts a bounded behavior on top of another behavior.
--   
--   <pre>
--   <a>trim</a> = <a>splice</a> <a>mempty</a>
--   </pre>
--   
--   (Named after the analogous tape-editing technique.)
splice :: Behavior a -> Bound (Behavior a) -> Behavior a

-- | View a <a>Event</a> <a>Segment</a> as a <a>Bound</a> <a>Behavior</a>
--   and vice versa.
--   
--   This can be used to safely turn a behavior into a segment and vice
--   versa. Often <a>focusing</a> is more convenient to use.
bounded' :: Iso' (Event (Segment a)) (Bound (Behavior a))

-- | View a <a>Event</a> <a>Segment</a> as a <a>Bound</a> <a>Behavior</a>
--   and vice versa.
--   
--   This can be used to safely turn a behavior into a segment and vice
--   versa. Often <a>focusing</a> is more convenient to use.
bounded :: Iso (Event (Segment a)) (Event (Segment b)) (Bound (Behavior a)) (Bound (Behavior b))
instance Typeable Segment
instance Functor Segment
instance Applicative Segment
instance Monad Segment
instance Reversible (Segment a)
instance Transformable (Segment a)
instance Representable Segment
instance Distributive Segment
instance Show (Segment a)

module Music.Time.Past

-- | <a>Past</a> represents a value occuring <i>before and at</i> some
--   point in time.
--   
--   It may be seen as a note whose era is a left-open, right-inclusive
--   time interval.
newtype Past a
Past :: (Min (Maybe Time), a) -> Past a
getPast :: Past a -> (Min (Maybe Time), a)

-- | <a>Future</a> represents a value occuring <i>at and after</i> some
--   point in time.
--   
--   It may be seen as a note whose era is a left-open, right-inclusive
--   time interval.
newtype Future a
Future :: (Max (Maybe Time), a) -> Future a
getFuture :: Future a -> (Max (Maybe Time), a)

-- | Query a past value. Semantic function.
past :: Past a -> Time -> Maybe a

-- | Query a future value. Semantic function.
future :: Future a -> Time -> Maybe a
indexPast :: [Past a] -> Time -> Maybe a
firstTrue :: [Maybe a] -> Maybe a

-- | Project a segment (backwards) up to the given point.
pastSeg :: Past (Segment a) -> Behavior (Maybe a)

-- | Project a segment starting from the given point.
futureSeg :: Future (Segment a) -> Behavior (Maybe a)
instance Eq a => Eq (Past a)
instance Ord a => Ord (Past a)
instance Functor Past
instance Eq a => Eq (Future a)
instance Ord a => Ord (Future a)
instance Functor Future


module Music.Time.Future


module Music.Time.Reactive

-- | Forms an applicative as per <a>Behavior</a>, but only switches at
--   discrete points.
data Reactive a

-- | Get the initial value.
initial :: Reactive a -> a

-- | Get the final value.
final :: Reactive a -> a

-- | Get all intermediate values.
intermediate :: Transformable a => Reactive a -> [Event a]

-- | Realize a <a>Reactive</a> value as a discretely changing behavior.
discrete :: Reactive a -> Behavior a

-- | Get the time of all updates and the value switched to at this point.
updates :: Reactive a -> [(Time, a)]
occs :: Reactive a -> [Time]
atTime :: Reactive a -> Time -> a

-- | <tt>switch t a b</tt> behaves as <tt>a</tt> before time <tt>t</tt>,
--   then as <tt>b</tt>.
switchR :: Time -> Reactive a -> Reactive a -> Reactive a
trimR :: Monoid a => Span -> Reactive a -> Reactive a

-- | Split a reactive into events, as well as the values before and after
--   the first/last update
splitReactive :: Reactive a -> Either a ((a, Time), [Event a], (Time, a))

-- | Realize a <a>Reactive</a> value as an continous behavior.
continous :: Reactive (Segment a) -> Behavior a

-- | Realize a <a>Reactive</a> value as an continous behavior.
continousWith :: Segment (a -> b) -> Reactive a -> Behavior b

-- | Sample a <a>Behavior</a> into a reactive.
sample :: [Time] -> Behavior a -> Reactive a
instance Typeable Reactive
instance Functor Reactive
instance Semigroup a => Semigroup (Reactive a)
instance Monoid a => Monoid (Reactive a)
instance Augmentable a => Augmentable (Reactive a)
instance Alterable a => Alterable (Reactive a)
instance IsDynamics a => IsDynamics (Reactive a)
instance IsInterval a => IsInterval (Reactive a)
instance IsPitch a => IsPitch (Reactive a)
instance Applicative Reactive
instance Rewrapped (Reactive a) (Reactive b)
instance Wrapped (Reactive a)
instance Reversible (Reactive a)
instance Transformable (Reactive a)


module Music.Time


-- | Provides a representation for tied notes, and a class to split a
--   single note into a pair of tied notes.
module Music.Score.Ties

-- | Class of types that can be tied. Ties are added to a score by
--   splitting a single note into two and annotating them with a <i>begin
--   tie</i> and <i>end tie</i> mark respectively.
--   
--   Minimal definition: <a>toTied</a>, or both <a>beginTie</a> and
--   <a>endTie</a>.
class Tiable a where beginTie = fst . toTied endTie = snd . toTied toTied a = (beginTie a, endTie a) isTieBeginning = snd . isTieEndBeginning isTieEnd = fst . isTieEndBeginning
beginTie :: Tiable a => a -> a
endTie :: Tiable a => a -> a
toTied :: Tiable a => a -> (a, a)
isTieEndBeginning :: Tiable a => a -> (Bool, Bool)
isTieBeginning :: Tiable a => a -> Bool
isTieEnd :: Tiable a => a -> Bool
newtype TieT a
TieT :: ((Any, Any), a) -> TieT a
getTieT :: TieT a -> ((Any, Any), a)

-- | Split all voice into bars, using the given bar durations. Music that
--   does not fit into the given durations is discarded.
--   
--   Events that cross a barlines are split into tied notes.
splitTiesAt :: Tiable a => [Duration] -> Voice a -> [Voice a]
instance Typeable TieT
instance Eq a => Eq (TieT a)
instance Ord a => Ord (TieT a)
instance Show a => Show (TieT a)
instance Functor TieT
instance Foldable TieT
instance Applicative TieT
instance Monad TieT
instance Comonad TieT
instance (Real a, Enum a, Integral a) => Integral (TieT a)
instance (Num a, Ord a, Real a) => Real (TieT a)
instance Bounded a => Bounded (TieT a)
instance Enum a => Enum (TieT a)
instance Floating a => Floating (TieT a)
instance Fractional a => Fractional (TieT a)
instance Num a => Num (TieT a)
instance Reversible a => Reversible (TieT a)
instance Transformable a => Transformable (TieT a)
instance IsDynamics a => IsDynamics (TieT a)
instance IsPitch a => IsPitch (TieT a)
instance Tiable a => Tiable (Product a)
instance Tiable a => Tiable (Sum a)
instance Tiable a => Tiable (Average a)
instance Tiable a => Tiable (Maybe a)
instance Tiable a => Tiable (c, a)
instance Tiable a => Tiable (Behavior a)
instance Tiable a => Tiable [a]
instance Tiable a => Tiable (TieT a)
instance Tiable (Ratio a)
instance Tiable ()
instance Tiable Integer
instance Tiable Int
instance Tiable Char
instance Tiable Float
instance Tiable Double
instance Rewrapped (TieT a) (TieT b)
instance Wrapped (TieT a)


-- | Provides functions for manipulating parts.
module Music.Score.Part

-- | Parts type.

-- | Part type.

-- | Class of types that provide a part traversal.
class (Transformable (Part s), Transformable (Part t)) => HasParts s t
parts :: HasParts s t => Traversal s t (Part s) (Part t)

-- | Class of types that provide a single part.
class HasParts s t => HasPart s t
part :: HasPart s t => Lens s t (Part s) (Part t)
type HasPart' a = HasPart a a
type HasParts' a = HasParts a a

-- | Part type.
part' :: (HasPart s t, s ~ t) => Lens' s (Part s)

-- | Part type.
parts' :: (HasParts s t, s ~ t) => Traversal' s (Part s)

-- | List all the parts
allParts :: (Ord (Part a), HasParts' a) => a -> [Part a]
extracted :: (Ord (Part a), HasPart' a) => Iso (Score a) (Score b) [Score a] [Score b]
extractedWithInfo :: (Ord (Part a), Ord (Part b), HasPart' a, HasPart' b) => Iso (Score a) (Score b) [(Part a, Score a)] [(Part b, Score b)]

-- | List all the parts
extractPart :: (Eq (Part a), HasPart' a) => Part a -> Score a -> Score a

-- | List all the parts
extractParts :: (Ord (Part a), HasPart' a) => Score a -> [Score a]
extractPartsWithInfo :: (Ord (Part a), HasPart' a) => Score a -> [(Part a, Score a)]
newtype PartT n a
PartT :: (n, a) -> PartT n a
getPartT :: PartT n a -> (n, a)

-- | Similar to <a>&lt;&gt;</a>, but increases parts in the second part to
--   prevent collision.
(</>) :: (HasParts' a, Enum (Part a)) => Score a -> Score a -> Score a

-- | Concatenate parts.
rcat :: (HasParts' a, Enum (Part a)) => [Score a] -> Score a
instance Typeable PartT
instance (Eq n, Eq a) => Eq (PartT n a)
instance (Ord n, Ord a) => Ord (PartT n a)
instance (Show n, Show a) => Show (PartT n a)
instance Functor (PartT n)
instance Monoid n => Applicative (PartT n)
instance Comonad (PartT n)
instance Monoid n => Monad (PartT n)
instance Transformable a => Transformable (PartT n a)
instance HasParts a b => HasParts (Voice a) (Voice b)
instance HasParts a b => HasParts (Score a) (Score b)
instance (HasPart a a, HasPart a b) => HasPart (Behavior a) (Behavior b)
instance (HasPart a a, HasPart a b) => HasParts (Behavior a) (Behavior b)
instance (HasPart a a, HasPart a b) => HasPart (Segment a) (Segment b)
instance (HasPart a a, HasPart a b) => HasParts (Segment a) (Segment b)
instance Tiable a => Tiable (PartT n a)
instance Reversible a => Reversible (PartT p a)
instance (IsDynamics a, Enum n) => IsDynamics (PartT n a)
instance (IsPitch a, Enum n) => IsPitch (PartT n a)
instance (Transformable p, Transformable p') => HasParts (PartT p a) (PartT p' a)
instance (Transformable p, Transformable p') => HasPart (PartT p a) (PartT p' a)
instance Rewrapped (PartT p a) (PartT p' b)
instance Wrapped (PartT p a)
instance HasParts a b => HasParts (Note a) (Note b)
instance HasPart a b => HasPart (Note a) (Note b)
instance HasParts a b => HasParts (Event a) (Event b)
instance HasPart a b => HasPart (Event a) (Event b)
instance HasParts a b => HasParts (Either c a) (Either c b)
instance HasParts a b => HasParts (Maybe a) (Maybe b)
instance HasParts a b => HasParts [a] [b]
instance HasParts a b => HasParts (c, a) (c, b)
instance HasPart a b => HasPart (c, a) (c, b)
instance HasParts a b => HasParts (Aligned a) (Aligned b)
instance HasParts Float Float
instance HasPart Float Float
instance HasParts Integer Integer
instance HasPart Integer Integer
instance HasParts Int Int
instance HasPart Int Int
instance (b ~ Part b, Transformable b) => HasParts () b
instance (b ~ Part b, Transformable b) => HasPart () b
instance (b ~ Part b, Transformable b) => HasParts Ordering b
instance (b ~ Part b, Transformable b) => HasPart Ordering b
instance (b ~ Part b, Transformable b) => HasParts Bool b
instance (b ~ Part b, Transformable b) => HasPart Bool b


-- | Provides miscellaneous conversions.
module Music.Time.Internal.Convert

-- | Convert a score to a voice. Fails if the score contain overlapping
--   events.

-- | <i>Deprecated: </i>
scoreToVoice :: Transformable a => Score a -> Voice (Maybe a)

-- | <i>Deprecated: </i>
reactiveToVoice' :: Span -> Reactive a -> Voice a


-- | This module provides phrase-wise traversal.
module Music.Score.Phrases

-- | Classes that provide a phrase traversal.
class HasPhrases s t a b | s -> a, t -> b, s b -> t, t a -> s
mvoices :: HasPhrases s t a b => Traversal s t (MVoice a) (MVoice b)
type HasPhrases' s a = HasPhrases s s a a

-- | A generic phrase-traversal.
phrases :: HasPhrases s t a b => Traversal s t (Phrase a) (Phrase b)

-- | A simple generic phrase-traversal.
phrases' :: HasPhrases' s a => Traversal' s (Phrase a)

-- | For a phrase, we simply use a voice without rests.
--   
--   To represent a sequence of phrases we provide two equivalent
--   representations:
--   
--   <ul>
--   <li><a>MVoice</a> is a sequence of notes/chords or rests. All
--   consecutive non-rests consitute a phrase.</li>
--   <li><a>PVoice</a> is a sequence of phrases or durations.</li>
--   </ul>
type Phrase a = Voice a

-- | A sequence of phrases or rests, represented as notes or rests.
--   
--   Each consecutive sequence of non-rest elements is considered to be a
--   phrase. For a more explicit representation of the phrase structure,
--   see <a>PVoice</a>.
type MVoice a = Voice (Maybe a)

-- | A sequence of phrases or rests, represented with explicit phrase
--   structure.
type PVoice a = [Either Duration (Phrase a)]

-- | A sequence of phrases or rests, represented as phrases with an
--   explicit onset.
--   
--   This is only isomorphic to <a>MVoice</a> (and <a>PVoice</a>) up to
--   onset equivalence.
type TVoice a = Track (Phrase a)

-- | View an <a>MVoice</a> as a <a>PVoice</a>.
mVoicePVoice :: Lens (MVoice a) (MVoice b) (PVoice a) (PVoice b)
mVoiceTVoice :: Lens (MVoice a) (MVoice b) (TVoice a) (TVoice b)
pVoiceTVoice :: Lens (PVoice a) (PVoice b) (TVoice a) (TVoice b)

-- | View an <a>MVoice</a> as a <a>PVoice</a> and vice versa.
--   
--   This a valid <a>Iso</a> up to meta-data equivalence.
unsafeMVoicePVoice :: Iso (MVoice a) (MVoice b) (PVoice a) (PVoice b)
singleMVoice :: Prism (Score a) (Score b) (MVoice a) (MVoice b)
mapPhrasesWithPrevAndCurrentOnset :: HasPhrases s t a b => (Maybe Time -> Time -> Phrase a -> Phrase b) -> s -> t
instance (HasPart' a, Ord (Part a)) => HasPhrases (Score a) (Score b) a b
instance HasPhrases (PVoice a) (PVoice b) a b
instance HasPhrases (MVoice a) (MVoice b) a b


-- | Provides a representation of musical <i>slides</i>, commonly known as
--   <i>glissando</i> or <i>portamento</i>.
module Music.Score.Slide
class HasSlide a
setBeginGliss :: HasSlide a => Bool -> a -> a
setBeginSlide :: HasSlide a => Bool -> a -> a
setEndGliss :: HasSlide a => Bool -> a -> a
setEndSlide :: HasSlide a => Bool -> a -> a
newtype SlideT a
SlideT :: Couple ((Any, Any), (Any, Any)) a -> SlideT a
getSlideT :: SlideT a -> Couple ((Any, Any), (Any, Any)) a

-- | Add a slide between the first and the last note.
slide :: (HasPhrases' s a, HasSlide a) => s -> s

-- | Add a glissando between the first and the last note.
glissando :: (HasPhrases' s a, HasSlide a) => s -> s
instance Typeable SlideT
instance (Real a, Enum a, Integral a) => Integral (SlideT a)
instance (Num a, Ord a, Real a) => Real (SlideT a)
instance Bounded a => Bounded (SlideT a)
instance Enum a => Enum (SlideT a)
instance Floating a => Floating (SlideT a)
instance Fractional a => Fractional (SlideT a)
instance Num a => Num (SlideT a)
instance Eq a => Eq (SlideT a)
instance Show a => Show (SlideT a)
instance Ord a => Ord (SlideT a)
instance Functor SlideT
instance Foldable SlideT
instance Applicative SlideT
instance Monad SlideT
instance Comonad SlideT
instance HasSlide (SlideT a)
instance Rewrapped (SlideT a) (SlideT b)
instance Wrapped (SlideT a)
instance HasSlide a => HasSlide (Note a)
instance HasSlide a => HasSlide (Voice a)
instance HasSlide a => HasSlide (Score a)
instance HasSlide a => HasSlide [a]
instance HasSlide a => HasSlide (Couple b a)
instance HasSlide a => HasSlide (b, a)


-- | Provides a way of adding text to notes.
module Music.Score.Text
class HasText a
addText :: HasText a => String -> a -> a
newtype TextT a
TextT :: Couple [String] a -> TextT a
getTextT :: TextT a -> Couple [String] a

-- | Attach the given text to the first note.
text :: (HasPhrases' s a, HasText a) => String -> s -> s

-- | Attach the given text to the last note.
textLast :: (HasPhrases' s a, HasText a) => String -> s -> s
instance Typeable TextT
instance (Real a, Enum a, Integral a) => Integral (TextT a)
instance (Num a, Ord a, Real a) => Real (TextT a)
instance Bounded a => Bounded (TextT a)
instance Enum a => Enum (TextT a)
instance Floating a => Floating (TextT a)
instance Fractional a => Fractional (TextT a)
instance Num a => Num (TextT a)
instance Eq a => Eq (TextT a)
instance Show a => Show (TextT a)
instance Ord a => Ord (TextT a)
instance Functor TextT
instance Foldable TextT
instance Applicative TextT
instance Monad TextT
instance Comonad TextT
instance HasText (TextT a)
instance Rewrapped (TextT a) (TextT b)
instance Wrapped (TextT a)
instance HasText a => HasText (Score a)
instance HasText a => HasText (Voice a)
instance HasText a => HasText (Note a)
instance HasText a => HasText [a]
instance HasText a => HasText (Couple b a)
instance HasText a => HasText (b, a)


-- | Provides a representation of harmonics.
module Music.Score.Harmonics
class HasHarmonic a
setNatural :: HasHarmonic a => Bool -> a -> a
setHarmonic :: HasHarmonic a => Int -> a -> a
newtype HarmonicT a
HarmonicT :: Couple (Any, Sum Int) a -> HarmonicT a
getHarmonicT :: HarmonicT a -> Couple (Any, Sum Int) a

-- | Make all notes natural harmonics on the given overtone (1 for octave,
--   2 for fifth etc). Sounding pitch is unaffected, but notated output is
--   transposed automatically.
harmonic :: HasHarmonic a => Int -> a -> a

-- | Make all notes natural harmonics on the given overtone (1 for octave,
--   2 for fifth etc). Sounding pitch is unaffected, but notated output is
--   transposed automatically.
artificial :: HasHarmonic a => a -> a
instance Typeable HarmonicT
instance (Real a, Enum a, Integral a) => Integral (HarmonicT a)
instance (Num a, Ord a, Real a) => Real (HarmonicT a)
instance Bounded a => Bounded (HarmonicT a)
instance Enum a => Enum (HarmonicT a)
instance Floating a => Floating (HarmonicT a)
instance Fractional a => Fractional (HarmonicT a)
instance Num a => Num (HarmonicT a)
instance Eq a => Eq (HarmonicT a)
instance Show a => Show (HarmonicT a)
instance Ord a => Ord (HarmonicT a)
instance Functor HarmonicT
instance Foldable HarmonicT
instance Applicative HarmonicT
instance Monad HarmonicT
instance Comonad HarmonicT
instance HasHarmonic (HarmonicT a)
instance Rewrapped (HarmonicT a) (HarmonicT b)
instance Wrapped (HarmonicT a)
instance HasHarmonic a => HasHarmonic (Score a)
instance HasHarmonic a => HasHarmonic [a]
instance HasHarmonic a => HasHarmonic (Couple b a)
instance HasHarmonic a => HasHarmonic (b, a)


-- | Provides functions for manipulating pitch.
module Music.Score.Pitch

-- | This type fuction is used to access the pitch type for a given type.

-- | This type fuction is used to update the pitch type for a given type.
--   The first argument is the new type.

-- | Associated interval type.
type Interval a = Diff (Pitch a)

-- | Class of types that provide a single pitch.
class HasPitches s t => HasPitch s t
pitch :: HasPitch s t => Lens s t (Pitch s) (Pitch t)

-- | Class of types that provide zero or more pitches.
class (Transformable (Pitch s), Transformable (Pitch t), SetPitch (Pitch t) s ~ t) => HasPitches s t
pitches :: HasPitches s t => Traversal s t (Pitch s) (Pitch t)
type HasPitch' a = HasPitch a a
type HasPitches' a = HasPitches a a

-- | Access the pitch.
--   
--   Same as <a>pitch</a>, but without polymorphic update.
pitch' :: HasPitch' s => Lens' s (Pitch s)

-- | Access all pitches.
--   
--   Same as <a>pitches</a>, but without polymorphic update.
pitches' :: HasPitches' s => Traversal' s (Pitch s)
type PitchPair v w = (Num (Scalar v), IsInterval v, IsPitch w)
type AffinePair v w = (VectorSpace v, AffineSpace w)

-- | Class of types that can be transposed, inverted and so on.
type Transposable a = (HasPitches' a, AffinePair (Interval a) (Pitch a), PitchPair (Interval a) (Pitch a))

-- | Transpose (translate) up.
--   
--   <pre>
--   &gt;&gt;&gt; up m3 (c :: Pitch)
--   eb
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; up _P5 [c,d,e :: Pitch]
--   [g,a,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; up _P5 [440 :: Hertz, 442, 810]
--   [g,a,b]
--   </pre>
up :: Transposable a => Interval a -> a -> a

-- | Transpose (translate) down.
--   
--   <pre>
--   &gt;&gt;&gt; down m3 (c :: Pitch)
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; down _P5 [c,d,e]
--   [f_,g_,a_]
--   </pre>
down :: Transposable a => Interval a -> a -> a

-- | Add the given interval above.
--   
--   <pre>
--   &gt;&gt;&gt; above _P8 [c :: Pitch]
--   [c,c']
--   </pre>
above :: (Semigroup a, Transposable a) => Interval a -> a -> a

-- | Add the given interval below.
--   
--   <pre>
--   &gt;&gt;&gt; below _P8 [c :: Pitch]
--   [c,c_]
--   </pre>
below :: (Semigroup a, Transposable a) => Interval a -> a -> a

-- | Transpose up by the given number of octaves.
--   
--   <pre>
--   &gt;&gt;&gt; octavesUp 2 (c :: Pitch)
--   c''
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; octavesUp 1 [c,d,e]
--   [c',d',e']
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; octavesUp (-1) [c,d,e]
--   [c_,d_,e_]
--   </pre>
octavesUp :: Transposable a => Scalar (Interval a) -> a -> a

-- | Transpose down by the given number of octaves.
--   
--   <pre>
--   &gt;&gt;&gt; octavesDown 2 (c :: Pitch)
--   c__
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; octavesDown 1 [c,d,e]
--   [c_,d_,e_]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; octavesDown (-1) [c,d,e]
--   [c',d',e']
--   </pre>
octavesDown :: Transposable a => Scalar (Interval a) -> a -> a

-- | Same as <tt><a>octavesUp</a> 2</tt>.
_15va :: Transposable a => a -> a

-- | Same as <tt><a>octavesUp</a> 1</tt>.
_8va :: Transposable a => a -> a

-- | Same as <tt><a>octavesDown</a> 1</tt>.
_8vb :: Transposable a => a -> a

-- | Same as <tt><a>octavesDown</a> 2</tt>.
_15vb :: Transposable a => a -> a

-- | Invert pitches.
invertPitches :: Transposable a => Pitch a -> a -> a

-- | Extract the highest pitch. Returns <tt>Nothing</tt> if there are none.
highest :: (HasPitches' a, Ord (Pitch a)) => a -> Maybe (Pitch a)

-- | Extract the lowest pitch. Returns <tt>Nothing</tt> if there are none.
lowest :: (HasPitches' a, Ord (Pitch a)) => a -> Maybe (Pitch a)

-- | Extract the average pitch. Returns <tt>Nothing</tt> if there are none.
meanPitch :: (HasPitches' a, Fractional (Pitch a)) => a -> Maybe (Pitch a)
instance HasPitch a b => HasPitch (SlideT a) (SlideT b)
instance HasPitches a b => HasPitches (SlideT a) (SlideT b)
instance HasPitch a b => HasPitch (TieT a) (TieT b)
instance HasPitches a b => HasPitches (TieT a) (TieT b)
instance HasPitch a b => HasPitch (HarmonicT a) (HarmonicT b)
instance HasPitches a b => HasPitches (HarmonicT a) (HarmonicT b)
instance HasPitch a b => HasPitch (TextT a) (TextT b)
instance HasPitches a b => HasPitches (TextT a) (TextT b)
instance HasPitch a b => HasPitch (Couple c a) (Couple c b)
instance HasPitches a b => HasPitches (Couple c a) (Couple c b)
instance (Transformable a, Transformable b, b ~ Pitch b) => HasPitch (Behavior a) b
instance (Transformable a, Transformable b, b ~ Pitch b) => HasPitches (Behavior a) b
instance HasPitches a b => HasPitches (Sum a) (Sum b)
instance HasPitches a b => HasPitches (Score a) (Score b)
instance HasPitches a b => HasPitches (Track a) (Track b)
instance HasPitches a b => HasPitches (Voice a) (Voice b)
instance HasPitches a b => HasPitches (Either c a) (Either c b)
instance HasPitches a b => HasPitches (Maybe a) (Maybe b)
instance HasPitches a b => HasPitches (Map k a) (Map k b)
instance HasPitches a b => HasPitches (Seq a) (Seq b)
instance HasPitches a b => HasPitches [a] [b]
instance HasPitch a b => HasPitch (Note a) (Note b)
instance HasPitches a b => HasPitches (Note a) (Note b)
instance HasPitch a b => HasPitch (Placed a) (Placed b)
instance HasPitches a b => HasPitches (Placed a) (Placed b)
instance HasPitch a b => HasPitch (Event a) (Event b)
instance HasPitches a b => HasPitches (Event a) (Event b)
instance HasPitches a b => HasPitches (c, a) (c, b)
instance HasPitch a b => HasPitch (c, a) (c, b)
instance HasPitches a b => HasPitches (Aligned a) (Aligned b)
instance (Transformable a, a ~ Pitch a) => HasPitches Double a
instance (Transformable a, a ~ Pitch a) => HasPitch Double a
instance (Transformable a, a ~ Pitch a) => HasPitches Float a
instance (Transformable a, a ~ Pitch a) => HasPitch Float a
instance (Transformable a, a ~ Pitch a) => HasPitches Integer a
instance (Transformable a, a ~ Pitch a) => HasPitch Integer a
instance (Transformable a, a ~ Pitch a) => HasPitches Int a
instance (Transformable a, a ~ Pitch a) => HasPitch Int a
instance (Transformable a, a ~ Pitch a) => HasPitches Char a
instance (Transformable a, a ~ Pitch a) => HasPitch Char a
instance (Transformable a, a ~ Pitch a) => HasPitches Ordering a
instance (Transformable a, a ~ Pitch a) => HasPitch Ordering a
instance (Transformable a, a ~ Pitch a) => HasPitches Bool a
instance (Transformable a, a ~ Pitch a) => HasPitch Bool a
instance (Transformable a, a ~ Pitch a) => HasPitches () a
instance (Transformable a, a ~ Pitch a) => HasPitch () a


-- | Provides functions for manipulating dynamics.
module Music.Score.Dynamics

-- | Dynamics type.

-- | Dynamic type.
type DynamicLensLaws' s t a b = (Dynamic (SetDynamic a s) ~ a, SetDynamic (Dynamic t) s ~ t, SetDynamic a (SetDynamic b s) ~ SetDynamic a s)
type DynamicLensLaws s t = DynamicLensLaws' s t (Dynamic s) (Dynamic t)

-- | Class of types that provide a dynamic traversal.
class (Transformable (Dynamic s), Transformable (Dynamic t), DynamicLensLaws s t) => HasDynamics s t
dynamics :: HasDynamics s t => Traversal s t (Dynamic s) (Dynamic t)

-- | Class of types that provide a single dynamic.
class HasDynamics s t => HasDynamic s t
dynamic :: HasDynamic s t => Lens s t (Dynamic s) (Dynamic t)
type HasDynamics' a = HasDynamics a a
type HasDynamic' a = HasDynamic a a

-- | Access a single dynamic.
dynamic' :: (HasDynamic s t, s ~ t) => Lens' s (Dynamic s)

-- | Access all dynamics.
dynamics' :: (HasDynamics s t, s ~ t) => Traversal' s (Dynamic s)

-- | Associated interval type.
type Level a = Diff (Dynamic a)

-- | Class of types that can be transposed.
type Attenuable a = (HasDynamics a a, VectorSpace (Level a), AffineSpace (Dynamic a), IsDynamics (Dynamic a))

-- | Transpose up.
louder :: Attenuable a => Level a -> a -> a

-- | Transpose down.
softer :: Attenuable a => Level a -> a -> a

-- | Transpose down.
level :: Attenuable a => Dynamic a -> a -> a
compressor :: Attenuable a => Dynamic a -> Scalar (Level a) -> a -> a

-- | Fade in.
fadeIn :: (HasPosition a, Transformable a, HasDynamics' a, Dynamic a ~ Behavior c, Fractional c) => Duration -> a -> a

-- | Fade in.
fadeOut :: (HasPosition a, Transformable a, HasDynamics' a, Dynamic a ~ Behavior c, Fractional c) => Duration -> a -> a
newtype DynamicT n a
DynamicT :: (n, a) -> DynamicT n a
getDynamicT :: DynamicT n a -> (n, a)

-- | View just the dynamices in a voice.
vdynamic :: (HasDynamic a a, HasDynamic a b) => Lens (Voice a) (Voice b) (Voice (Dynamic a)) (Voice (Dynamic b))
addDynCon :: (HasPhrases s t a b, HasDynamic a a, HasDynamic a b, Dynamic a ~ d, Dynamic b ~ Ctxt d) => s -> t
instance Typeable DynamicT
instance Reversible a => Reversible (DynamicT p a)
instance (IsInterval a, Monoid n) => IsInterval (DynamicT n a)
instance (IsPitch a, Monoid n) => IsPitch (DynamicT n a)
instance (Eq n, Eq a) => Eq (DynamicT n a)
instance (Ord n, Ord a) => Ord (DynamicT n a)
instance (Show n, Show a) => Show (DynamicT n a)
instance Functor (DynamicT n)
instance Monoid n => Applicative (DynamicT n)
instance Monoid n => Monad (DynamicT n)
instance Comonad (DynamicT n)
instance Transformable a => Transformable (DynamicT n a)
instance (Monoid n, Monoid a) => Monoid (DynamicT n a)
instance (Semigroup n, Semigroup a) => Semigroup (DynamicT n a)
instance (Tiable n, Tiable a) => Tiable (DynamicT n a)
instance (IsDynamics n, Monoid a) => IsDynamics (DynamicT n a)
instance (Transformable p, Transformable p') => HasDynamics (DynamicT p a) (DynamicT p' a)
instance (Transformable p, Transformable p') => HasDynamic (DynamicT p a) (DynamicT p' a)
instance Rewrapped (DynamicT p a) (DynamicT p' b)
instance Wrapped (DynamicT p a)
instance (Monoid n, Bounded a) => Bounded (DynamicT n a)
instance (Monoid n, Enum a) => Enum (DynamicT n a)
instance (Monoid n, Floating a) => Floating (DynamicT n a)
instance (Monoid n, Fractional a) => Fractional (DynamicT n a)
instance (Monoid n, Num a) => Num (DynamicT n a)
instance HasDynamic a b => HasDynamic (SlideT a) (SlideT b)
instance HasDynamics a b => HasDynamics (SlideT a) (SlideT b)
instance HasDynamic a b => HasDynamic (TieT a) (TieT b)
instance HasDynamics a b => HasDynamics (TieT a) (TieT b)
instance HasDynamic a b => HasDynamic (HarmonicT a) (HarmonicT b)
instance HasDynamics a b => HasDynamics (HarmonicT a) (HarmonicT b)
instance HasDynamic a b => HasDynamic (TextT a) (TextT b)
instance HasDynamics a b => HasDynamics (TextT a) (TextT b)
instance HasDynamic a b => HasDynamic (Couple c a) (Couple c b)
instance HasDynamics a b => HasDynamics (Couple c a) (Couple c b)
instance (Transformable a, Transformable b, b ~ Dynamic b, SetDynamic (Behavior a) b ~ Behavior a) => HasDynamic (Behavior a) b
instance (Transformable a, Transformable b, b ~ Dynamic b, SetDynamic (Behavior a) b ~ Behavior a) => HasDynamics (Behavior a) b
instance HasDynamics a b => HasDynamics (Score a) (Score b)
instance HasDynamics a b => HasDynamics (Track a) (Track b)
instance HasDynamics a b => HasDynamics (Voice a) (Voice b)
instance HasDynamic a b => HasDynamic (Note a) (Note b)
instance HasDynamics a b => HasDynamics (Note a) (Note b)
instance HasDynamic a b => HasDynamic (Placed a) (Placed b)
instance HasDynamics a b => HasDynamics (Placed a) (Placed b)
instance HasDynamic a b => HasDynamic (Event a) (Event b)
instance HasDynamics a b => HasDynamics (Event a) (Event b)
instance HasDynamics a b => HasDynamics (Either c a) (Either c b)
instance HasDynamics a b => HasDynamics (Maybe a) (Maybe b)
instance HasDynamics a b => HasDynamics [a] [b]
instance HasDynamics a b => HasDynamics (c, a) (c, b)
instance HasDynamic a b => HasDynamic (c, a) (c, b)
instance HasDynamics a b => HasDynamics (Aligned a) (Aligned b)
instance (Transformable a, a ~ Dynamic a, SetDynamic Double a ~ Double) => HasDynamics Double a
instance (Transformable a, a ~ Dynamic a, SetDynamic Double a ~ Double) => HasDynamic Double a
instance (Transformable a, a ~ Dynamic a, SetDynamic Float a ~ Float) => HasDynamics Float a
instance (Transformable a, a ~ Dynamic a, SetDynamic Float a ~ Float) => HasDynamic Float a
instance (Transformable a, a ~ Dynamic a, SetDynamic Integer a ~ Integer) => HasDynamics Integer a
instance (Transformable a, a ~ Dynamic a, SetDynamic Integer a ~ Integer) => HasDynamic Integer a
instance (Transformable a, a ~ Dynamic a, SetDynamic Int a ~ Int) => HasDynamics Int a
instance (Transformable a, a ~ Dynamic a, SetDynamic Int a ~ Int) => HasDynamic Int a
instance (Transformable a, a ~ Dynamic a, SetDynamic Char a ~ Char) => HasDynamics Char a
instance (Transformable a, a ~ Dynamic a, SetDynamic Char a ~ Char) => HasDynamic Char a
instance (Transformable a, a ~ Dynamic a, SetDynamic Ordering a ~ Ordering) => HasDynamics Ordering a
instance (Transformable a, a ~ Dynamic a, SetDynamic Ordering a ~ Ordering) => HasDynamic Ordering a
instance (Transformable a, a ~ Dynamic a, SetDynamic Bool a ~ Bool) => HasDynamics Bool a
instance (Transformable a, a ~ Dynamic a, SetDynamic Bool a ~ Bool) => HasDynamic Bool a
instance (Transformable a, a ~ Dynamic a, SetDynamic () a ~ ()) => HasDynamics () a
instance (Transformable a, a ~ Dynamic a, SetDynamic () a ~ ()) => HasDynamic () a


-- | Provides functions for manipulating articulation.
module Music.Score.Articulation

-- | Articulations type.

-- | Articulation type.

-- | Class of types that can be transposed, inverted and so on.
class (Fractional (Accentuation a), Fractional (Separation a), AffineSpace (Accentuation a), AffineSpace (Separation a)) => Articulated a
accentuation :: Articulated a => Lens' a (Accentuation a)
separation :: Articulated a => Lens' a (Separation a)

-- | Class of types that provide a articulation traversal.
class (Transformable (Articulation s), Transformable (Articulation t), ArticulationLensLaws s t) => HasArticulations s t
articulations :: HasArticulations s t => Traversal s t (Articulation s) (Articulation t)

-- | Class of types that provide a single articulation.
class HasArticulations s t => HasArticulation s t
articulation :: HasArticulation s t => Lens s t (Articulation s) (Articulation t)
type HasArticulations' a = HasArticulations a a
type HasArticulation' a = HasArticulation a a

-- | Articulation type.
articulation' :: (HasArticulation s t, s ~ t) => Lens' s (Articulation s)

-- | Articulation type.
articulations' :: (HasArticulations s t, s ~ t) => Traversal' s (Articulation s)
accent :: (HasPhrases' s b, HasArticulations' b, Articulation b ~ a, Articulated a) => s -> s
marcato :: (HasPhrases' s b, HasArticulations' b, Articulation b ~ a, Articulated a) => s -> s
accentLast :: (HasPhrases' s b, HasArticulations' b, Articulation b ~ a, Articulated a) => s -> s
marcatoLast :: (HasPhrases' s b, HasArticulations' b, Articulation b ~ a, Articulated a) => s -> s
accentAll :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
marcatoAll :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
staccatissimo :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
staccato :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
separated :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
portato :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
legato :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
legatissimo :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
tenuto :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
spiccato :: (HasArticulations' s, Articulation s ~ a, Articulated a) => s -> s
newtype ArticulationT n a
ArticulationT :: (n, a) -> ArticulationT n a
getArticulationT :: ArticulationT n a -> (n, a)
varticulation :: (HasArticulation a (SetArticulation a1 a), HasArticulation a a, Functor f, (~) * (Articulation (SetArticulation a1 a)) a1) => (Voice (Articulation a) -> f (Voice a1)) -> Voice a -> f (Voice (SetArticulation a1 a))
addArtCon :: (HasPhrases s t a b, HasArticulation' a, HasArticulation a b, Articulation a ~ d, Articulation b ~ Ctxt d) => s -> t
instance Typeable ArticulationT
instance Reversible a => Reversible (ArticulationT p a)
instance (IsInterval a, Monoid n) => IsInterval (ArticulationT n a)
instance (IsPitch a, Monoid n) => IsPitch (ArticulationT n a)
instance (Eq n, Eq a) => Eq (ArticulationT n a)
instance (Ord n, Ord a) => Ord (ArticulationT n a)
instance (Show n, Show a) => Show (ArticulationT n a)
instance Functor (ArticulationT n)
instance Monoid n => Applicative (ArticulationT n)
instance Monoid n => Monad (ArticulationT n)
instance Comonad (ArticulationT n)
instance Transformable a => Transformable (ArticulationT n a)
instance (Monoid n, Monoid a) => Monoid (ArticulationT n a)
instance (Semigroup n, Semigroup a) => Semigroup (ArticulationT n a)
instance (Tiable n, Tiable a) => Tiable (ArticulationT n a)
instance (Transformable p, Transformable p') => HasArticulations (ArticulationT p a) (ArticulationT p' a)
instance (Transformable p, Transformable p') => HasArticulation (ArticulationT p a) (ArticulationT p' a)
instance Rewrapped (ArticulationT p a) (ArticulationT p' b)
instance Wrapped (ArticulationT p a)
instance (Monoid n, Bounded a) => Bounded (ArticulationT n a)
instance (Monoid n, Enum a) => Enum (ArticulationT n a)
instance (Monoid n, Floating a) => Floating (ArticulationT n a)
instance (Monoid n, Fractional a) => Fractional (ArticulationT n a)
instance (Monoid n, Num a) => Num (ArticulationT n a)
instance (AffineSpace a, AffineSpace b, Fractional a, Fractional b) => Articulated (a, b)
instance HasArticulation a b => HasArticulation (SlideT a) (SlideT b)
instance HasArticulations a b => HasArticulations (SlideT a) (SlideT b)
instance HasArticulation a b => HasArticulation (TieT a) (TieT b)
instance HasArticulations a b => HasArticulations (TieT a) (TieT b)
instance HasArticulation a b => HasArticulation (HarmonicT a) (HarmonicT b)
instance HasArticulations a b => HasArticulations (HarmonicT a) (HarmonicT b)
instance HasArticulation a b => HasArticulation (TextT a) (TextT b)
instance HasArticulations a b => HasArticulations (TextT a) (TextT b)
instance HasArticulation a b => HasArticulation (Couple c a) (Couple c b)
instance HasArticulations a b => HasArticulations (Couple c a) (Couple c b)
instance HasArticulations a b => HasArticulations (Score a) (Score b)
instance HasArticulations a b => HasArticulations (Track a) (Track b)
instance HasArticulations a b => HasArticulations (Voice a) (Voice b)
instance HasArticulation a b => HasArticulation (Note a) (Note b)
instance HasArticulations a b => HasArticulations (Note a) (Note b)
instance HasArticulation a b => HasArticulation (Placed a) (Placed b)
instance HasArticulations a b => HasArticulations (Placed a) (Placed b)
instance HasArticulation a b => HasArticulation (Event a) (Event b)
instance HasArticulations a b => HasArticulations (Event a) (Event b)
instance HasArticulations a b => HasArticulations (Either c a) (Either c b)
instance HasArticulations a b => HasArticulations (Maybe a) (Maybe b)
instance HasArticulations a b => HasArticulations [a] [b]
instance HasArticulations a b => HasArticulations (c, a) (c, b)
instance HasArticulation a b => HasArticulation (c, a) (c, b)
instance (Transformable a, a ~ Articulation a, SetArticulation Double a ~ Double) => HasArticulations Double a
instance (Transformable a, a ~ Articulation a, SetArticulation Double a ~ Double) => HasArticulation Double a
instance (Transformable a, a ~ Articulation a, SetArticulation Float a ~ Float) => HasArticulations Float a
instance (Transformable a, a ~ Articulation a, SetArticulation Float a ~ Float) => HasArticulation Float a
instance (Transformable a, a ~ Articulation a, SetArticulation Integer a ~ Integer) => HasArticulations Integer a
instance (Transformable a, a ~ Articulation a, SetArticulation Integer a ~ Integer) => HasArticulation Integer a
instance (Transformable a, a ~ Articulation a, SetArticulation Int a ~ Int) => HasArticulations Int a
instance (Transformable a, a ~ Articulation a, SetArticulation Int a ~ Int) => HasArticulation Int a
instance (Transformable a, a ~ Articulation a, SetArticulation Char a ~ Char) => HasArticulations Char a
instance (Transformable a, a ~ Articulation a, SetArticulation Char a ~ Char) => HasArticulation Char a
instance (Transformable a, a ~ Articulation a, SetArticulation Ordering a ~ Ordering) => HasArticulations Ordering a
instance (Transformable a, a ~ Articulation a, SetArticulation Ordering a ~ Ordering) => HasArticulation Ordering a
instance (Transformable a, a ~ Articulation a, SetArticulation Bool a ~ Bool) => HasArticulations Bool a
instance (Transformable a, a ~ Articulation a, SetArticulation Bool a ~ Bool) => HasArticulation Bool a
instance (Transformable a, a ~ Articulation a, SetArticulation () a ~ ()) => HasArticulations () a
instance (Transformable a, a ~ Articulation a, SetArticulation () a ~ ()) => HasArticulation () a


-- | Rhythmical quantization.
module Music.Score.Internal.Quantize
data Rhythm a
Beat :: Duration -> a -> Rhythm a
Group :: [Rhythm a] -> Rhythm a
Dotted :: Int -> (Rhythm a) -> Rhythm a
Tuplet :: Duration -> (Rhythm a) -> Rhythm a
mapWithDur :: (Duration -> a -> b) -> Rhythm a -> Rhythm b
quantize :: Tiable a => [(Duration, a)] -> Either String (Rhythm a)
rewrite :: Rhythm a -> Rhythm a

-- | Return the scaling applied to a note with the given number of dots
--   (i.e. 3<i>2, 7</i>4 etc).
dotMod :: Int -> Duration
drawRhythm :: Show a => Rhythm a -> String
testQuantize :: [Duration] -> IO ()
instance Eq a => Eq (Rhythm a)
instance Show a => Show (Rhythm a)
instance Functor Rhythm
instance Foldable Rhythm
instance Monoid RhythmContext
instance VectorSpace (Rhythm a)
instance AdditiveGroup (Rhythm a)
instance HasDuration (Rhythm a)
instance Monoid (Rhythm a)
instance Semigroup (Rhythm a)
instance Transformable (Rhythm a)


module Music.Score.Export.DynamicNotation
data CrescDim
NoCrescDim :: CrescDim
BeginCresc :: CrescDim
EndCresc :: CrescDim
BeginDim :: CrescDim
EndDim :: CrescDim
newtype DynamicNotation
DynamicNotation :: ([CrescDim], Maybe Double) -> DynamicNotation
getDynamicNotation :: DynamicNotation -> ([CrescDim], Maybe Double)
notateDynamic :: (Ord a, Real a) => Ctxt a -> DynamicNotation
removeCloseDynMarks :: (HasPhrases' s a, HasDynamics' a, Dynamic a ~ DynamicNotation, a ~ SetDynamic (Dynamic a) a) => s -> s
removeDynMark :: (HasDynamics' a, Dynamic a ~ DynamicNotation, a ~ SetDynamic (Dynamic a) a) => a -> a
instance Eq CrescDim
instance Ord CrescDim
instance Show CrescDim
instance Monoid DynamicNotation
instance Tiable DynamicNotation
instance Transformable DynamicNotation
instance Rewrapped DynamicNotation DynamicNotation
instance Wrapped DynamicNotation
instance Monoid CrescDim


module Music.Score.Export.ArticulationNotation
data Slur
NoSlur :: Slur
BeginSlur :: Slur
EndSlur :: Slur
data Mark
NoMark :: Mark
Staccato :: Mark
MoltoStaccato :: Mark
Marcato :: Mark
Accent :: Mark
Tenuto :: Mark
newtype ArticulationNotation
ArticulationNotation :: ([Slur], [Mark]) -> ArticulationNotation
getArticulationNotation :: ArticulationNotation -> ([Slur], [Mark])
notateArticulation :: (Ord a, Articulated a, Real (Separation a), Real (Accentuation a)) => Ctxt a -> ArticulationNotation
instance Eq Slur
instance Ord Slur
instance Show Slur
instance Eq Mark
instance Ord Mark
instance Show Mark
instance Monoid ArticulationNotation
instance Tiable ArticulationNotation
instance Transformable ArticulationNotation
instance Rewrapped ArticulationNotation ArticulationNotation
instance Wrapped ArticulationNotation
instance Monoid Mark
instance Monoid Slur


module Music.Score.Meta
addMetaNote :: (AttributeClass a, HasMeta b) => Event a -> b -> b
fromMetaReactive :: AttributeClass b => Meta -> Reactive b
metaAt :: AttributeClass b => Time -> Score a -> b
metaAtStart :: AttributeClass b => Score a -> b
withMeta :: AttributeClass a => (a -> Score b -> Score b) -> Score b -> Score b
withMetaAtStart :: AttributeClass a => (a -> Score b -> Score b) -> Score b -> Score b


-- | Provides a representation for tremolo, i.e. rapid iterations of a
--   note.
module Music.Score.Tremolo
class HasTremolo a
setTrem :: HasTremolo a => Int -> a -> a

-- | Set the number of tremolo divisions for all notes in the score.
tremolo :: HasTremolo a => Int -> a -> a
data TremoloT a

-- | Get the number of tremolo divisions.
runTremoloT :: TremoloT a -> (Int, a)
instance Typeable TremoloT
instance Augmentable a => Augmentable (TremoloT a)
instance Alterable a => Alterable (TremoloT a)
instance Reversible a => Reversible (TremoloT a)
instance Transformable a => Transformable (TremoloT a)
instance HasText a => HasText (TremoloT a)
instance HasSlide a => HasSlide (TremoloT a)
instance HasHarmonic a => HasHarmonic (TremoloT a)
instance Tiable a => Tiable (TremoloT a)
instance Semigroup a => Semigroup (TremoloT a)
instance IsDynamics a => IsDynamics (TremoloT a)
instance IsPitch a => IsPitch (TremoloT a)
instance (Real a, Enum a, Integral a) => Integral (TremoloT a)
instance (Num a, Ord a, Real a) => Real (TremoloT a)
instance Bounded a => Bounded (TremoloT a)
instance Enum a => Enum (TremoloT a)
instance Floating a => Floating (TremoloT a)
instance Fractional a => Fractional (TremoloT a)
instance Num a => Num (TremoloT a)
instance (Monoid b, Augmentable a) => Augmentable (Couple b a)
instance (Monoid b, Alterable a) => Alterable (Couple b a)
instance (Monoid b, Reversible a) => Reversible (Couple b a)
instance (Monoid b, Transformable a) => Transformable (Couple b a)
instance (Monoid b, IsDynamics a) => IsDynamics (Couple b a)
instance (Monoid b, IsPitch a) => IsPitch (Couple b a)
instance Eq a => Eq (TremoloT a)
instance Show a => Show (TremoloT a)
instance Ord a => Ord (TremoloT a)
instance Functor TremoloT
instance Foldable TremoloT
instance Applicative TremoloT
instance Monad TremoloT
instance Comonad TremoloT
instance HasArticulation a b => HasArticulation (TremoloT a) (TremoloT b)
instance HasArticulations a b => HasArticulations (TremoloT a) (TremoloT b)
instance HasDynamic a b => HasDynamic (TremoloT a) (TremoloT b)
instance HasDynamics a b => HasDynamics (TremoloT a) (TremoloT b)
instance HasPitch a b => HasPitch (TremoloT a) (TremoloT b)
instance HasPitches a b => HasPitches (TremoloT a) (TremoloT b)
instance HasTremolo (TremoloT a)
instance Rewrapped (TremoloT a) (TremoloT b)
instance Wrapped (TremoloT a)
instance Tiable a => Tiable (Couple b a)
instance HasTremolo a => HasTremolo (Score a)
instance HasTremolo a => HasTremolo [a]
instance HasTremolo a => HasTremolo (Couple b a)
instance HasTremolo a => HasTremolo (b, a)


-- | Provides colored note heads.
module Music.Score.Color
class HasColor a
setColor :: HasColor a => Colour Double -> a -> a

-- | Set color of all notes in the score.
color :: HasColor a => Colour Double -> a -> a

-- | Color all notes in the score red.
colorRed :: HasColor a => a -> a

-- | Color all notes in the score blue.
colorBlue :: HasColor a => a -> a

-- | Color all notes in the score black.
colorBlack :: HasColor a => a -> a
newtype ColorT a
ColorT :: Couple (Option (Last (Colour Double))) a -> ColorT a
getColorT :: ColorT a -> Couple (Option (Last (Colour Double))) a
instance Bounded a => Bounded (ColorT a)
instance Enum a => Enum (ColorT a)
instance Floating a => Floating (ColorT a)
instance Fractional a => Fractional (ColorT a)
instance Num a => Num (ColorT a)
instance Eq a => Eq (ColorT a)
instance Show a => Show (ColorT a)
instance Functor ColorT
instance Foldable ColorT
instance Applicative ColorT
instance Monad ColorT
instance Comonad ColorT
instance Tiable a => Tiable (ColorT a)
instance Semigroup a => Semigroup (ColorT a)
instance HasColor (ColorT a)
instance Rewrapped (ColorT a) (ColorT b)
instance Wrapped (ColorT a)
instance HasColor a => HasColor (TieT a)
instance HasColor a => HasColor (PartT n a)
instance HasColor a => HasColor (Note a)
instance HasColor a => HasColor (Voice a)
instance HasColor a => HasColor (Score a)
instance HasColor a => HasColor [a]
instance HasColor a => HasColor (b, a)


-- | Provides time signatures and related meta-data.
module Music.Score.Meta.Time

-- | A time signature is a sequence of beat numbers and a note value (i.e.
--   an expression on the form <tt>(a1+a2...)/b</tt>). For simple time
--   signatures just one beat number is used.
--   
--   TimeSignature is an instance of <a>Fractional</a> and can be used as
--   follows:
--   
--   <pre>
--   timeSignature (4/4)
--   timeSignature (6/8)
--   timeSignature ((3+2)/4)
--   </pre>
data TimeSignature

-- | Create a simple time signature.
time :: Integer -> Integer -> TimeSignature

-- | Create a compound time signature.
compoundTime :: [Integer] -> Integer -> TimeSignature

-- | Whether this is a simple time signature.
isSimpleTime :: TimeSignature -> Bool

-- | Whether this is a compound time signature.
isCompoundTime :: TimeSignature -> Bool

-- | Convert to a simple time signature by adding all numerators. If given
--   a simple time signature, returns it.
toSimpleTime :: TimeSignature -> TimeSignature

-- | Extract the components of a time signature. Semantic function.
--   
--   Typically used with the <tt>ViewPatterns</tt> extension, as in
--   
--   <pre>
--   foo (getTimeSignature -&gt; (beats, noteValue)) = ...
--   </pre>
getTimeSignature :: TimeSignature -> ([Integer], Integer)

-- | Set the time signature of the given score.
timeSignature :: (HasMeta a, HasPosition a, Transformable a) => TimeSignature -> a -> a

-- | Set the time signature of the given part of a score.
timeSignatureDuring :: HasMeta a => Span -> TimeSignature -> a -> a

-- | Extract the time signature from the given score, using the given
--   default time signature.
withTimeSignature :: TimeSignature -> (TimeSignature -> Score a -> Score a) -> Score a -> Score a
getTimeSignatures :: TimeSignature -> Score a -> Reactive TimeSignature
getTimeSignatureChanges :: TimeSignature -> Score a -> [(Time, TimeSignature)]

-- | Given a list of time signatures and the duration between them (TODO
--   use voice), return a list of appropriate bar durations.
getBarDurations :: [(TimeSignature, Duration)] -> [Duration]

-- | Given a list of time signatures and the duration between them (TODO
--   use voice), return a list of appropriate time signatures for each bar.
getBarTimeSignatures :: [(TimeSignature, Duration)] -> [TimeSignature]

-- | Time signature typically used for the given duration.
standardTimeSignature :: Duration -> TimeSignature
instance Typeable TimeSignature
instance Eq TimeSignature
instance Ord TimeSignature
instance Show TimeSignature
instance Real TimeSignature
instance Fractional TimeSignature
instance Num TimeSignature


module Music.Score.Internal.Export
extractTimeSignatures :: Score a -> ([Maybe TimeSignature], [Duration])

-- | Convert a voice to a list of bars using the given bar durations.
voiceToBars' :: Tiable a => [Duration] -> Voice (Maybe a) -> [[(Duration, Maybe a)]]

-- | Basic spelling for integral types.
spellPitch :: Integral a => a -> (a, a, a)
type MVoice a = Voice (Maybe a)
toMVoice :: (Semigroup a, Transformable a) => Score a -> MVoice a

-- | <i>Deprecated: Use <tt>unsafeEventsV</tt></i>
unvoice :: Voice b -> [(Duration, b)]
openCommand :: String


-- | Provides MIDI import.
--   
--   <i>Warning</i> Experimental module.
module Music.Score.Import.Midi

-- | This constraint includes all note types that can be constructed from a
--   Midi representation.
type IsMidi a = (IsPitch a, HasPart' a, Ord (Part a), Enum (Part a), Num (Pitch a), HasTremolo a, HasArticulation a a, Tiable a)
fromMidi :: IsMidi a => Midi -> Score a

-- | Read a Midi score from a file. Fails if the file could not be read or
--   if a parsing error occurs.
readMidi :: IsMidi a => FilePath -> IO (Score a)

-- | Read a Midi score from a file. Fails if the file could not be read,
--   and returns <tt>Nothing</tt> if a parsing error occurs.
readMidiMaybe :: IsMidi a => FilePath -> IO (Maybe (Score a))

-- | Read a Midi score from a file. Fails if the file could not be read,
--   and returns <tt>Left m</tt> if a parsing error occurs.
readMidiEither :: IsMidi a => FilePath -> IO (Either String (Score a))


module Music.Score.Export.Backend
type HasOrdPart a = (HasPart' a, Ord (Part a))
type HasDynamic3 a a' a'' = (HasDynamic' a, HasDynamic' a'', HasDynamic a a', HasDynamic a' a'', HasDynamic a a'')
type HasDynamicNotation a b c = (HasDynamic3 a b c, Dynamic b ~ Ctxt (Dynamic a), Dynamic c ~ DynamicNotation, Real (Dynamic a), Part (SetDynamic (Dynamic a) a) ~ Part (SetDynamic DynamicNotation b))
type HasArticulation3 c d e = (HasArticulation' c, HasArticulation c d, HasArticulation d e, HasArticulation c e)
type HasArticulationNotation a b c = (HasArticulation3 a b c, Articulation b ~ Ctxt (Articulation a), Articulation c ~ ArticulationNotation, Articulation a ~ (Average Double, Average Double))

-- | This class defines types and functions for exporting music. It
--   provides the primitive types and methods used to implement
--   <a>export</a>.
--   
--   The backend type <tt>b</tt> is just a type level tag to identify a
--   specific backend. It is typically defined as an empty data
--   declaration.
--   
--   The actual conversion is handled by the subclasses
--   <a>HasBackendScore</a> and <a>HasBackendNote</a>, which converts the
--   time structure, and the contained music respectively. Thus structure
--   and content are handled separately.
--   
--   It is often necessary to alter the events based on their surrounding
--   context: for examples the beginning and end of spanners and beams
--   depend on surrounding notes. The <a>BackendContext</a> type allow
--   <a>HasBackendScore</a> instances to provide context for
--   <a>HasBackendNote</a> instances.
--   
--   @ data NoteList
--   
--   instance HasBackend NoteList where type BackendScore NoteList = []
--   type BackendContext NoteList = Identity type BackendNote NoteList =
--   [(Sum Int, Int)] type BackendMusic NoteList = [(Sum Int, Int)]
--   finalizeExport _ = concat
--   
--   instance HasBackendScore NoteList [a] a where exportScore _ = fmap
--   Identity
--   
--   instance HasBackendNote NoteList a =&gt; HasBackendNote NoteList [a]
--   where exportNote b ps = mconcat $ map (exportNote b) $ sequenceA ps
--   
--   instance HasBackendNote NoteList Int where exportNote _ (Identity p) =
--   [(mempty ,p)]
--   
--   instance HasBackendNote NoteList a =&gt; HasBackendNote NoteList
--   (DynamicT (Sum Int) a) where exportNote b (Identity (DynamicT (d,ps)))
--   = set (mapped._1) d $ exportNote b (Identity ps) -- @
class Functor (BackendScore b) => HasBackend b where type family BackendMusic b :: * type family BackendNote b :: * type family BackendScore b :: * -> * type family BackendContext b :: * -> *
finalizeExport :: HasBackend b => b -> BackendScore b (BackendNote b) -> BackendMusic b

-- | A class for musical container types with an external representation.
--   
--   The first type parameter is simply a token representing the external
--   format, and the second parameter is the type being represented. In a
--   sense, the first parameter saves us from defining a separate class for
--   each external representation, so rather than having
--   <tt>HasMidiScore</tt>, <tt>HasMusicXmlScore</tt> and so on, we have
--   <a>HasBackendScore</a> <tt>Midi</tt>, <a>HasBackendScore</a>
--   <tt>MusicXml</tt> and so on.
class HasBackend b => HasBackendScore b s where type family BackendScoreEvent b s :: *
exportScore :: HasBackendScore b s => b -> s -> BackendScore b (BackendContext b (BackendScoreEvent b s))

-- | A class for musical event types with an external representation.
--   
--   The first type parameter is simply a token representing the external
--   format, and the second parameter is the type being represented. In a
--   sense, the first parameter saves us from defining a separate class for
--   each external representation, so rather than having
--   <tt>HasMidiNote</tt>, <tt>HasMusicXmlNote</tt> and so on, we have
--   <a>HasBackendNote</a> <tt>Midi</tt>, <a>HasBackendNote</a>
--   <tt>MusicXml</tt> and so on.
class HasBackend b => HasBackendNote b a where exportChord = error "Not implemented: exportChord"
exportNote :: HasBackendNote b a => b -> BackendContext b a -> BackendNote b
exportChord :: HasBackendNote b a => b -> BackendContext b [a] -> BackendNote b

-- | This is the primitive music export function.
--   
--   Backend developers are encouraged to provide wrappers on the form
--   <tt>toX</tt>, <tt>writeX</tt> etc.
export :: (HasBackendScore b s, HasBackendNote b (BackendScoreEvent b s)) => b -> s -> BackendMusic b


-- | Provides tempo meta-data.
module Music.Score.Meta.Tempo
type Bpm = Duration
type NoteValue = Duration

-- | Represents musical tempo as a scaling factor with an optional name
--   and/or beat duration.
--   
--   <a>tempoToDuration</a> provides a scaling factor such that
--   
--   <pre>
--   stretch (tempoToDuration t) notation = sounding
--   compress (tempoToDuration t) sounding = notation
--   </pre>
--   
--   You can construct a tempo in various ways
--   
--   <pre>
--   tempoToDuration (metronome (1/4) 120) == tempoToDuration (metronome (1/2) 60)
--   metronome (1/4) 120                   /=                  metronome (1/2) 60
--   </pre>
data Tempo

-- | Create a tempo from a duration and a number of beats per minute.
--   
--   For example <tt>metronome (1/2) 48</tt> means 48 half notes per
--   minute.
metronome :: Duration -> Bpm -> Tempo

-- | Get the note value indicated by a tempo.
tempoNoteValue :: Tempo -> Maybe NoteValue

-- | Get the number of beats per minute indicated by a tempo.
tempoBeatsPerMinute :: Tempo -> Bpm

-- | Get the note value and number of beats per minute indicated by a
--   tempo.
--   
--   Typically used with the <tt>ViewPatterns</tt> extension, as in
--   
--   <pre>
--   foo (getTempo -&gt; (nv, bpm)) = ...
--   </pre>
getTempo :: Tempo -> (NoteValue, Bpm)

-- | Convert a tempo to a duration suitable for converting written to
--   sounding durations.
--   
--   <pre>
--   stretch (tempoToDuration t) notation = sounding
--   compress (tempoToDuration t) sounding = notation
--   </pre>
tempoToDuration :: Tempo -> Duration

-- | Set the tempo of the given score.
tempo :: (HasMeta a, HasPosition a) => Tempo -> a -> a

-- | Set the tempo of the given part of a score.
tempoDuring :: HasMeta a => Span -> Tempo -> a -> a
presto :: Tempo
allegro :: Tempo
allegretto :: Tempo
moderato :: Tempo
andante :: Tempo
adagio :: Tempo
largo :: Tempo
lento :: Tempo

-- | Extract all tempi from the given score, using the given default tempo.
--   withTempo :: (Tempo -&gt; Score a -&gt; Score a) -&gt; Score a -&gt;
--   Score a withTempo f = withMeta (f . fromMaybe def . fmap getFirst .
--   getOption)
renderTempo :: Score a -> Score a
instance Typeable Tempo
instance Eq Tempo
instance Ord Tempo
instance Monoid Tempo
instance Semigroup Tempo
instance Show Tempo
instance Num Tempo


module Music.Score.Export.Midi

-- | Class of part types with an associated MIDI program number.
class HasMidiProgram a where getMidiChannel _ = 0
getMidiChannel :: HasMidiProgram a => a -> Channel
getMidiProgram :: HasMidiProgram a => a -> Preset

-- | A token to represent the Midi backend.
data Midi

-- | Constraint for types that has a MIDI representation.
type HasMidi a = (HasBackendNote Midi (BackendScoreEvent Midi a), HasBackendScore Midi a)
toMidi :: HasMidi a => a -> Midi
writeMidi :: HasMidi a => FilePath -> a -> IO ()
showMidi :: HasMidi a => a -> IO ()
openMidi :: HasMidi a => a -> IO ()
instance Functor MidiScore
instance HasBackendNote Midi a => HasBackendNote Midi (ColorT a)
instance HasBackendNote Midi a => HasBackendNote Midi (TieT a)
instance HasBackendNote Midi a => HasBackendNote Midi (SlideT a)
instance HasBackendNote Midi a => HasBackendNote Midi (HarmonicT a)
instance HasBackendNote Midi a => HasBackendNote Midi (TextT a)
instance HasBackendNote Midi a => HasBackendNote Midi (TremoloT a)
instance HasBackendNote Midi a => HasBackendNote Midi (PartT n a)
instance HasBackendNote Midi a => HasBackendNote Midi (ArticulationT b a)
instance (Real d, HasBackendNote Midi a) => HasBackendNote Midi (DynamicT d a)
instance HasBackendNote Midi a => HasBackendNote Midi (Behavior a)
instance HasBackendNote Midi Double
instance HasBackendNote Midi Float
instance HasBackendNote Midi Integer
instance HasBackendNote Midi Int
instance HasBackendNote Midi a => HasBackendNote Midi [a]
instance (HasPart' a, Ord (Part a), HasMidiProgram (Part a)) => HasBackendScore Midi (Score a)
instance (HasPart' a, HasMidiProgram (Part a)) => HasBackendScore Midi (Voice a)
instance HasBackend Midi
instance (Integral a, HasMidiProgram a) => HasMidiProgram (Ratio a)
instance HasMidiProgram Integer
instance HasMidiProgram Int
instance HasMidiProgram Float
instance HasMidiProgram Double
instance HasMidiProgram ()


-- | Provides miscellaneous instances.
module Music.Score.Internal.Instances
instance Augmentable a => Augmentable (ArticulationT n a)
instance Augmentable a => Augmentable (DynamicT n a)
instance Augmentable a => Augmentable (PartT n a)
instance Augmentable a => Augmentable (TieT a)
instance Alterable a => Alterable (ArticulationT n a)
instance Alterable a => Alterable (DynamicT n a)
instance Alterable a => Alterable (PartT n a)
instance Alterable a => Alterable (TieT a)
instance Augmentable a => Augmentable (TextT a)
instance Augmentable a => Augmentable (HarmonicT a)
instance Augmentable a => Augmentable (SlideT a)
instance Alterable a => Alterable (TextT a)
instance Alterable a => Alterable (HarmonicT a)
instance Alterable a => Alterable (SlideT a)
instance Reversible a => Reversible (TextT a)
instance Reversible a => Reversible (HarmonicT a)
instance Reversible a => Reversible (SlideT a)
instance Transformable a => Transformable (TextT a)
instance Transformable a => Transformable (HarmonicT a)
instance Transformable a => Transformable (SlideT a)
instance HasText a => HasText (ColorT a)
instance HasSlide a => HasSlide (ColorT a)
instance HasHarmonic a => HasHarmonic (ColorT a)
instance HasTremolo a => HasTremolo (ColorT a)
instance Augmentable a => Augmentable (ColorT a)
instance Alterable a => Alterable (ColorT a)
instance Reversible a => Reversible (ColorT a)
instance Transformable a => Transformable (ColorT a)
instance IsDynamics a => IsDynamics (ColorT a)
instance IsPitch a => IsPitch (ColorT a)
instance IsDynamics a => IsDynamics (SlideT a)
instance IsPitch a => IsPitch (SlideT a)
instance IsDynamics a => IsDynamics (HarmonicT a)
instance IsPitch a => IsPitch (HarmonicT a)
instance IsDynamics a => IsDynamics (TextT a)
instance IsPitch a => IsPitch (TextT a)
instance HasText a => HasText (SlideT a)
instance HasHarmonic a => HasHarmonic (SlideT a)
instance HasTremolo a => HasTremolo (SlideT a)
instance HasText a => HasText (HarmonicT a)
instance HasSlide a => HasSlide (HarmonicT a)
instance HasTremolo a => HasTremolo (HarmonicT a)
instance HasSlide a => HasSlide (TextT a)
instance HasHarmonic a => HasHarmonic (TextT a)
instance HasTremolo a => HasTremolo (TextT a)
instance HasText a => HasText (TieT a)
instance HasSlide a => HasSlide (TieT a)
instance HasHarmonic a => HasHarmonic (TieT a)
instance HasTremolo a => HasTremolo (TieT a)
instance HasText a => HasText (PartT n a)
instance HasSlide a => HasSlide (PartT n a)
instance HasHarmonic a => HasHarmonic (PartT n a)
instance HasTremolo a => HasTremolo (PartT n a)
instance IsDynamics a => IsDynamics (Average a)
instance IsInterval a => IsInterval (Average a)
instance IsPitch a => IsPitch (Average a)
instance Transformable a => Transformable (Average a)
instance Transformable a => Transformable (Ctxt a)
instance Tiable a => Tiable (Score a)
instance Bounded a => Bounded [a]
instance Enum a => Enum [a]
instance (Enum v, Ord v, Real a, Enum a, Integral a) => Integral (PartT v a)
instance (Enum v, Ord v, Num a, Ord a, Real a) => Real (PartT v a)
instance (Enum v, Bounded a) => Bounded (PartT v a)
instance (Enum v, Enum a) => Enum (PartT v a)
instance (Enum v, Eq v, Num a) => Num (PartT v a)
instance Augmentable a => Augmentable (Score a)
instance Alterable a => Alterable (Score a)
instance Tiable a => Tiable (SlideT a)
instance Tiable a => Tiable (HarmonicT a)
instance Tiable a => Tiable (TextT a)
instance HasArticulation a b => HasArticulation (ColorT a) (ColorT b)
instance HasArticulations a b => HasArticulations (ColorT a) (ColorT b)
instance HasDynamic a b => HasDynamic (ColorT a) (ColorT b)
instance HasDynamics a b => HasDynamics (ColorT a) (ColorT b)
instance HasPitch a b => HasPitch (ColorT a) (ColorT b)
instance HasPitches a b => HasPitches (ColorT a) (ColorT b)
instance HasArticulations a b => HasArticulations (PartT p a) (PartT p b)
instance HasArticulation a b => HasArticulation (PartT p a) (PartT p b)
instance HasDynamics a b => HasDynamics (ArticulationT p a) (ArticulationT p b)
instance HasDynamic a b => HasDynamic (ArticulationT p a) (ArticulationT p b)
instance HasDynamics a b => HasDynamics (PartT p a) (PartT p b)
instance HasDynamic a b => HasDynamic (PartT p a) (PartT p b)
instance HasPitches a b => HasPitches (ArticulationT p a) (ArticulationT p b)
instance HasPitch a b => HasPitch (ArticulationT p a) (ArticulationT p b)
instance HasPitches a b => HasPitches (DynamicT p a) (DynamicT p b)
instance HasPitch a b => HasPitch (DynamicT p a) (DynamicT p b)
instance HasPitches a b => HasPitches (PartT p a) (PartT p b)
instance HasPitch a b => HasPitch (PartT p a) (PartT p b)
instance Semigroup a => Semigroup (PartT n a)
instance Semigroup a => Semigroup (TextT a)
instance Semigroup a => Semigroup (HarmonicT a)
instance Semigroup a => Semigroup (TieT a)
instance Semigroup a => Semigroup (SlideT a)


-- | Provides various forms of title, subtitle etc. and related meta-data.
module Music.Score.Meta.Title

-- | A title is a sequence of <a>String</a> values, representing the name
--   of a work or part of a work. An arbitrary depth of title sections can
--   be used.
--   
--   Title is an instance of <a>IsString</a> and can be used with the
--   <tt>OverloadedStrings</tt> extension as follows:
--   
--   <pre>
--   title  "Le Nozze di Figaro"
--   
--   subtitle "Atto primo"
--   subsubtitle "Scena I"
--   subsubtitle "Scena II"
--   ...
--   
--   subtitle "Atto secundo"
--   ...
--   </pre>
data Title

-- | Denote a title to a lower level, i.e title becomes subtitle, subtitle
--   becomes subsubtitle etc.
denoteTitle :: Title -> Title

-- | Extract the title as a descending list of title levels (i.e. title,
--   subtitle, subsubtitle...).
getTitle :: Title -> [String]

-- | Extract the title of the given level. Semantic function.
getTitleAt :: Title -> Int -> Maybe String

-- | Set title of the given score.
title :: (HasMeta a, HasPosition a) => Title -> a -> a

-- | Set title of the given part of a score.
titleDuring :: HasMeta a => Span -> Title -> a -> a

-- | Set subtitle of the given score.
subtitle :: (HasMeta a, HasPosition a) => Title -> a -> a

-- | Set subtitle of the given part of a score.
subtitleDuring :: HasMeta a => Span -> Title -> a -> a

-- | Set subsubtitle of the given score.
subsubtitle :: (HasMeta a, HasPosition a) => Title -> a -> a

-- | Set subsubtitle of the given part of a score.
subsubtitleDuring :: HasMeta a => Span -> Title -> a -> a

-- | Extract the title in from the given score.
withTitle :: (Title -> Score a -> Score a) -> Score a -> Score a
instance Typeable Title
instance Monoid Title
instance Semigroup Title
instance Show Title
instance IsString Title


-- | Provides meta-data attribution for composer, lyricist etc.
module Music.Score.Meta.Attribution

-- | An attributions is a simple map from keys to values used to gather
--   information such as composer, lyricist, orchestrator, performer, etc.
--   
--   Attribution is a <a>Semigroup</a>, and compose by choosing the
--   leftmost value in each category. For example
--   
--   <pre>
--   attribution "composer" "H" &lt;&gt; attribution "composer" "S" &lt;&gt; attribution "lyricist" "S"
--       ===&gt; attributions [("composer","H"),("lyricist","S")]
--   </pre>
--   
--   Any kind of attribution can be added, and backends may recognize or
--   ignore categories as they see fit. The following categories are
--   normally recognized:
--   
--   <pre>
--   composer
--   lyricist
--   arranger
--   performer
--   dedication
--   year
--   copyright
--   information
--   </pre>
data Attribution

-- | Make an <a>Attribution</a> a single key and value.
attribution :: String -> String -> Attribution

-- | Make an <a>Attribution</a> from keys and values.
attributions :: [(String, String)] -> Attribution

-- | Extract an the given attributions value. Semantic function.
getAttribution :: Attribution -> String -> Maybe String

-- | Set the given attribution in the given score.
attribute :: (HasMeta a, HasPosition a) => Attribution -> a -> a

-- | Set the given attribution in the given part of a score.
attributeDuring :: HasMeta a => Span -> Attribution -> a -> a

-- | Set composer of the given score.
composer :: (HasMeta a, HasPosition a) => String -> a -> a

-- | Set composer of the given part of a score.
composerDuring :: HasMeta a => Span -> String -> a -> a

-- | Set lyricist of the given score.
lyricist :: (HasMeta a, HasPosition a) => String -> a -> a

-- | Set lyricist of the given part of a score.
lyricistDuring :: HasMeta a => Span -> String -> a -> a

-- | Set arranger of the given score.
arranger :: (HasMeta a, HasPosition a) => String -> a -> a

-- | Set arranger of the given part of a score.
arrangerDuring :: HasMeta a => Span -> String -> a -> a

-- | Extract attribution values of the given category from a score.
withAttribution :: String -> (String -> Score a -> Score a) -> Score a -> Score a

-- | Extract all attribution values from a score.
withAttribution' :: (Attribution -> Score a -> Score a) -> Score a -> Score a
instance Typeable Attribution
instance Monoid Attribution
instance Semigroup Attribution
instance Show Attribution


-- | A simple backend that supports rendering scores to lists of pitch and
--   velocity.
--   
--   This exists as a sanity check for the <tt>Backend</tt> classes, and as
--   an example.
module Music.Score.Export.NoteList

-- | A token to represent the note list backend.
data NoteList

-- | Export music as a note list.
toNoteList :: (HasBackendNote NoteList (BackendScoreEvent NoteList s), HasBackendScore NoteList s) => s -> [(Int, Int)]
instance HasBackendNote NoteList a => HasBackendNote NoteList (ColorT a)
instance HasBackendNote NoteList a => HasBackendNote NoteList (TieT a)
instance HasBackendNote NoteList a => HasBackendNote NoteList (SlideT a)
instance HasBackendNote NoteList a => HasBackendNote NoteList (HarmonicT a)
instance HasBackendNote NoteList a => HasBackendNote NoteList (TextT a)
instance HasBackendNote NoteList a => HasBackendNote NoteList (TremoloT a)
instance HasBackendNote NoteList a => HasBackendNote NoteList (PartT n a)
instance HasBackendNote NoteList a => HasBackendNote NoteList (ArticulationT b a)
instance HasBackendNote NoteList a => HasBackendNote NoteList (DynamicT b a)
instance HasBackendNote NoteList Double
instance HasBackendNote NoteList Int
instance HasBackendNote NoteList a => HasBackendNote NoteList [a]
instance HasBackendScore NoteList (Score a)
instance HasBackendScore NoteList [a]
instance HasBackend NoteList


-- | A backend to generate SuperCollider code.
--   
--   This is a very simple thing that generates <i>patterns</i> (which are
--   basically lazy event lists) in the SuperCollider language.
--   
--   It would of course also be nice to have a backend based the Haskell
--   bindings (see <a>http://hackage.haskell.org/package/hsc3</a>). In that
--   case we could bypass the SuperCollider language and just use
--   <i>scsynth</i>.
module Music.Score.Export.SuperCollider

-- | A token to represent the SuperCollider backend.
data SuperCollider

-- | Constraint for types that has a SuperCollider representation.
type HasSuperCollider a = (HasBackendNote SuperCollider (BackendScoreEvent SuperCollider a), HasBackendScore SuperCollider a)

-- | Convert music to a SuperCollider code string.
toSuperCollider :: HasSuperCollider a => a -> String

-- | Write music as a SuperCollider code string to the given path.
--   
--   <pre>
--   writeSuperCollider "test.sc" $ scat [c,d,e]
--   </pre>
writeSuperCollider :: HasSuperCollider a => FilePath -> a -> IO ()

-- | Write music as a SuperCollider code string and open it.
--   
--   (This is simple wrapper around <a>writeSuperCollider</a> that may not
--   work well on all platforms.)
openSuperCollider :: HasSuperCollider a => a -> IO ()
instance Functor ScScore
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (ColorT a)
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (TieT a)
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (SlideT a)
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (HarmonicT a)
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (TextT a)
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (TremoloT a)
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (PartT n a)
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (ArticulationT b a)
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (DynamicT b a)
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider (Behavior a)
instance HasBackendNote SuperCollider Integer
instance HasBackendNote SuperCollider Int
instance HasBackendNote SuperCollider Double
instance HasBackendNote SuperCollider a => HasBackendNote SuperCollider [a]
instance (HasPart' a, Ord (Part a)) => HasBackendScore SuperCollider (Score a)
instance HasBackendScore SuperCollider (Voice (Maybe a))
instance HasBackend SuperCollider
instance Monoid (ScScore a)


module Music.Score.Export.Lilypond

-- | Extract instrument info as per <a>Music.Part</a> This is really crude,
--   needs rethinking!
class HasLilypondInstrument a
getLilypondClef :: HasLilypondInstrument a => a -> Int

-- | A token to represent the Lilypond backend.
data Lilypond

-- | Context passed to the note export. Includes duration and note/rest
--   distinction.
data LyContext a
LyContext :: Duration -> (Maybe a) -> LyContext a

-- | Constraint for types that has a Lilypond representation.
type HasLilypond a = (HasBackendNote Lilypond (BackendScoreEvent Lilypond a), HasBackendScore Lilypond a)

-- | Convert a score to a Lilypond representation.
toLilypond :: HasLilypond a => a -> LyMusic

-- | Convert a score to a Lilypond string.
toLilypondString :: HasLilypond a => a -> String

-- | Convert a score to a Lilypond representaiton and print it on the
--   standard output.
showLilypond :: HasLilypond a => a -> IO ()

-- | Typeset a score using Lilypond and open it. (This is simple wrapper
--   around <a>writeLilypond</a> that may not work well on all platforms.)
openLilypond :: HasLilypond a => a -> IO ()

-- | Convert a score to a Lilypond representation and write to a file.
writeLilypond :: HasLilypond a => FilePath -> a -> IO ()
data LilypondOptions
LyInlineFormat :: LilypondOptions
LyScoreFormat :: LilypondOptions

-- | Typeset a score using Lilypond and open it. (This is simple wrapper
--   around <a>writeLilypond</a> that may not work well on all platforms.)
openLilypond' :: HasLilypond a => LilypondOptions -> a -> IO ()

-- | Convert a score to a Lilypond representation and write to a file.
writeLilypond' :: HasLilypond a => LilypondOptions -> FilePath -> a -> IO ()
instance Eq ScoreInfo
instance Show ScoreInfo
instance Eq StaffInfo
instance Show StaffInfo
instance Eq BarInfo
instance Show BarInfo
instance Functor LyBar
instance Eq a => Eq (LyBar a)
instance Show a => Show (LyBar a)
instance Functor LyStaff
instance Eq a => Eq (LyStaff a)
instance Show a => Show (LyStaff a)
instance Functor LyScore
instance Eq a => Eq (LyScore a)
instance Show a => Show (LyScore a)
instance Functor LyContext
instance Foldable LyContext
instance Traversable LyContext
instance Eq a => Eq (LyContext a)
instance Show a => Show (LyContext a)
instance Monoid LilypondOptions
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (TieT a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (SlideT a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (HarmonicT a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (TextT a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (TremoloT a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (ColorT a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (ArticulationT ArticulationNotation a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (DynamicT DynamicNotation a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (PartT n a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (Product a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (Sum a)
instance HasBackendNote Lilypond a => HasBackendNote Lilypond (Behavior a)
instance Integral a => HasBackendNote Lilypond (Ratio a)
instance HasBackendNote Lilypond Double
instance HasBackendNote Lilypond Float
instance HasBackendNote Lilypond Int
instance HasBackendNote Lilypond Integer
instance HasBackendNote Lilypond a => HasBackendNote Lilypond [a]
instance (HasDynamicNotation a b c, HasArticulationNotation c d e, Part e ~ Part c, HasOrdPart a, Transformable a, Semigroup a, Tiable e, HasOrdPart c, Show (Part c), HasLilypondInstrument (Part c), Satisfied) => HasBackendScore Lilypond (Score a)
instance HasBackend Lilypond


module Music.Score.Export.MusicXml

-- | Extract instrument info as per <a>Music.Part</a> This is really crude,
--   needs rethinking!
class HasMusicXmlInstrument a
getMusicXmlClef :: HasMusicXmlInstrument a => a -> Int
getMusicXmlNumberOfStaves :: HasMusicXmlInstrument a => a -> Int

-- | A token to represent the MusicXml backend.
data MusicXml

-- | Context passed to the note export. Includes duration and note/rest
--   distinction.
data XmlContext a
XmlContext :: Duration -> (Maybe a) -> XmlContext a

-- | Constraint for types that has a MusicXML representation.
type HasMusicXml a = (HasBackendNote MusicXml (BackendScoreEvent MusicXml a), HasBackendScore MusicXml a)

-- | Convert a score to a MusicXML score.
toMusicXml :: HasMusicXml a => a -> Score

-- | Convert a score to a MusicXML string.
toMusicXmlString :: HasMusicXml a => a -> String

-- | Convert a score to MusicXML string and print it on the standard
--   output.
showMusicXml :: HasMusicXml a => a -> IO ()

-- | Typeset a score using MusicXML and open it. (This is simple wrapper
--   around <a>writeMusicXml</a> that may not work well on all platforms.)
openMusicXml :: HasMusicXml a => a -> IO ()

-- | Convert a score to MusicXML and write to a file.
writeMusicXml :: HasMusicXml a => FilePath -> a -> IO ()
instance Show ClefSign
instance Show Line
instance Eq ScoreInfo
instance Show ScoreInfo
instance Eq StaffInfo
instance Show StaffInfo
instance Eq BarInfo
instance Show BarInfo
instance Functor XmlBar
instance Eq a => Eq (XmlBar a)
instance Show a => Show (XmlBar a)
instance Functor XmlStaff
instance Eq a => Eq (XmlStaff a)
instance Show a => Show (XmlStaff a)
instance Functor XmlScore
instance Eq a => Eq (XmlScore a)
instance Show a => Show (XmlScore a)
instance Functor XmlContext
instance Foldable XmlContext
instance Traversable XmlContext
instance Eq a => Eq (XmlContext a)
instance Show a => Show (XmlContext a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (TieT a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (SlideT a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (HarmonicT a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (TextT a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (TremoloT a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (ColorT a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (ArticulationT b a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (DynamicT DynamicNotation a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (PartT n a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (Product a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (Sum a)
instance HasBackendNote MusicXml a => HasBackendNote MusicXml (Behavior a)
instance Integral a => HasBackendNote MusicXml (Ratio a)
instance HasBackendNote MusicXml Double
instance HasBackendNote MusicXml Float
instance HasBackendNote MusicXml Int
instance HasBackendNote MusicXml Integer
instance HasBackendNote MusicXml a => HasBackendNote MusicXml [a]
instance (HasDynamicNotation a b c, HasOrdPart a, Transformable a, Semigroup a, HasOrdPart c, Tiable c, Show (Part a), HasMusicXmlInstrument (Part a)) => HasBackendScore MusicXml (Score a)
instance HasBackend MusicXml
instance Show PartList
instance Eq PartList


-- | Provides tempo meta-data.
--   
--   <i>Warning</i> This is not supported by any backends yet.
module Music.Score.Meta.RehearsalMark

-- | Represents a rehearsal mark.
--   
--   TODO this needs zero-duration spans to work properly.
data RehearsalMark
rehearsalMark :: (HasMeta a, HasPosition a) => RehearsalMark -> a -> a
rehearsalMarkDuring :: HasMeta a => Span -> RehearsalMark -> a -> a
withRehearsalMark :: (RehearsalMark -> Score a -> Score a) -> Score a -> Score a
instance Typeable RehearsalMark
instance Eq RehearsalMark
instance Ord RehearsalMark
instance Show RehearsalMark
instance Monoid RehearsalMark
instance Semigroup RehearsalMark


-- | Provides special barlines as meta-data.
--   
--   (Ordinary barlines are generated automatically, see also
--   <a>Music.Score.Meta.Time</a>).
module Music.Score.Meta.Barline
data BarlineType
StandardBarline :: BarlineType
DoubleBarline :: BarlineType
FinalBarline :: BarlineType

-- | Represents a barline.
--   
--   TODO repeats
data Barline

-- | Add a barline over the whole score.
barline :: (HasMeta a, HasPosition a) => Barline -> a -> a

-- | Add a barline over the whole score.
doubleBarline :: (HasMeta a, HasPosition a) => Barline -> a -> a

-- | Add a barline over the whole score.
finalBarline :: (HasMeta a, HasPosition a) => Barline -> a -> a

-- | Add a barline to the given score.
barlineDuring :: HasMeta a => Span -> Barline -> a -> a

-- | Extract barlines in from the given score, using the given default
--   barline.
withBarline :: (Barline -> Score a -> Score a) -> Score a -> Score a
instance Typeable BarlineType
instance Typeable Barline
instance Eq BarlineType
instance Ord BarlineType
instance Show BarlineType
instance Eq Barline
instance Ord Barline
instance Show Barline


-- | Provides clefs as meta-data.
--   
--   <i>Warning</i> Experimental module.
module Music.Score.Meta.Clef
data Clef
GClef :: Clef
CClef :: Clef
FClef :: Clef

-- | Set clef of the given score.
clef :: (HasMeta a, HasPosition a) => Clef -> a -> a

-- | Set clef of the given part of a score.
clefDuring :: HasMeta a => Span -> Clef -> a -> a

-- | Extract the clef in from the given score, using the given default
--   clef.
withClef :: Clef -> (Clef -> Score a -> Score a) -> Score a -> Score a
instance Typeable Clef
instance Eq Clef
instance Ord Clef
instance Show Clef
instance IsPitch Clef


-- | Provides fermatas.
module Music.Score.Meta.Fermata
data FermataType
StandardFermata :: FermataType
LongFermata :: FermataType
VeryLongFermata :: FermataType

-- | Represents a fermata.
--   
--   TODO where is the fermata added if the score contains multiple notes.
--   Always the last?
data Fermata

-- | Add a fermata over the whole score.
fermata :: (HasMeta a, HasPosition a) => Fermata -> a -> a

-- | Add a fermata to the given score.
fermataDuring :: HasMeta a => Span -> Fermata -> a -> a

-- | Extract fermatas in from the given score, using the given default
--   fermata.
withFermata :: (Fermata -> Score a -> Score a) -> Score a -> Score a
instance Typeable FermataType
instance Typeable Fermata
instance Eq FermataType
instance Ord FermataType
instance Show FermataType
instance Eq Fermata
instance Ord Fermata
instance Show Fermata


-- | Provides key signature meta-data.
module Music.Score.Meta.Key
data Fifths

-- | A key signature, represented by number of fifths from C and mode.
data KeySignature

-- | Create a major or minor signature.
key :: Fifths -> Bool -> KeySignature
isMajorKey :: KeySignature -> Bool
isMinorKey :: KeySignature -> Bool

-- | Set the key signature of the given score.
keySignature :: (HasMeta a, HasPosition a) => KeySignature -> a -> a

-- | Set the key signature of the given part of a score.
keySignatureDuring :: HasMeta a => Span -> KeySignature -> a -> a

-- | Extract all key signatures from the given score, using the given
--   default key signature.
withKeySignature :: KeySignature -> (KeySignature -> Score a -> Score a) -> Score a -> Score a
instance Typeable KeySignature
instance Eq Fifths
instance Ord Fifths
instance Num Fifths
instance Enum Fifths
instance Integral Fifths
instance Real Fifths
instance Eq KeySignature
instance Ord KeySignature
instance IsPitch Fifths

module Music.Score.Meta.Extract
attributionAt :: HasMeta a => Time -> String -> a -> Maybe String
attributionsAt :: HasMeta a => Time -> a -> [(String, Maybe String)]
titleAt :: HasMeta a => Time -> a -> Maybe Title
partNames :: (HasParts' a, Show (Part a)) => a -> [String]
commonMetaAt :: HasMeta a => Time -> a -> [(String, Maybe String)]


-- | Provides a basic way annotating scores.
module Music.Score.Meta.Annotations

-- | An annotation is a unique textual value attached to parts of a score.
--   They are ignored by default, but can be collected with
--   <a>withAnnotations</a>.
data Annotation
getAnnotation :: Annotation -> [String]

-- | Annotate the whole score.
annotate :: String -> Score a -> Score a

-- | Annotate a part of the score.
annotateSpan :: Span -> String -> Score a -> Score a

-- | Show all annotations in the score.
showAnnotations :: (HasPart' a, Ord (Part a), HasText a) => Score a -> Score a

-- | Show all annotations in the score using the given prefix.
showAnnotations' :: (HasPart' a, Ord (Part a), HasText a) => String -> Score a -> Score a

-- | Handle the annotations in a score.
withAnnotations :: ([String] -> Score a -> Score a) -> Score a -> Score a
instance Typeable Annotation
instance Semigroup Annotation
instance Monoid Annotation
instance IsString Annotation


module Music.Score


-- | Provides tempo meta-data.
--   
--   <i>Warning</i> This is not supported by any backends yet.
module Music.Score.Meta.Pickup

-- | Represents a rehearsal mark.
--   
--   TODO this needs zero-duration spans to work properly.
data Pickup
instance Typeable Pickup
instance Eq Pickup
instance Ord Pickup
instance Show Pickup
instance Monoid Pickup
instance Semigroup Pickup
