-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Binding to the ALSA Library API (PCM audio).
--   
--   This package provides access to ALSA realtime audio signal input and
--   output. For MIDI support see alsa-seq.
@package alsa-pcm
@version 0.6.0.3

module Sound.ALSA.PCM.Parameters.Software
data T i y a
type Size = Int
data TimestampMode
timestampNone :: TimestampMode
timestampMmap :: TimestampMode
getAvailMin :: T i y Size
setAvailMin :: Size -> T i y ()
getSilenceSize :: T i y Size
setSilenceSize :: Size -> T i y ()
getSilenceThreshold :: T i y Size
setSilenceThreshold :: Size -> T i y ()
getSleepMin :: T i y Word
setSleepMin :: Word -> T i y ()
getStartThreshold :: T i y Size
setStartThreshold :: Size -> T i y ()
getStopThreshold :: T i y Size
setStopThreshold :: Size -> T i y ()
getTimestampMode :: T i y TimestampMode
setTimestampMode :: TimestampMode -> T i y ()
getXferAlign :: T i y Size
setXferAlign :: Size -> T i y ()
setBufferSize :: Size -> Size -> T i y ()

module Sound.ALSA.PCM.Parameters.Hardware
data T i y a
type SampleFreq = Int
type Time = Int
type Size = Int
data Interleaved
data Noninterleaved
canMmapSampleResolution :: T i y (Bool)
isDouble :: T i y (Bool)
isBatch :: T i y (Bool)
isBlockTransfer :: T i y (Bool)
canOverrange :: T i y (Bool)
canPause :: T i y (Bool)
canResume :: T i y (Bool)
isHalfDuplex :: T i y (Bool)
isJointDuplex :: T i y (Bool)
canSyncStart :: T i y (Bool)
getRateNumden :: T i y (Word, Word)
getSbits :: T i y (Word)
getFifoSize :: T i y (Word)
getChannels :: T i y (Word)
getChannelsMin :: T i y (Word)
getChannelsMax :: T i y (Word)
testChannels :: Word -> T i y (Errno)

-- | For non-interleaved access the number of channels must be set
--   manually. It can be chosen at runtime, but the compiler cannot check
--   whether the number of allocated channels matches the one in
--   <tt>readn</tt> and <tt>writen</tt>.
--   
--   In interleaved access the number of channels is derived from the type
--   and must not be set manually. The number is static but the compiler
--   checks consistency with <tt>readi</tt> and <tt>writei</tt>.
setChannels :: Word -> T Noninterleaved y ()
setChannelsMin :: Word -> T Noninterleaved y Word
setChannelsMax :: Word -> T Noninterleaved y Word
setChannelsMinmax :: Word -> Word -> T Noninterleaved y (Word, Word)
setChannelsNear :: Word -> T Noninterleaved y Word
setChannelsFirst :: Word -> T Noninterleaved y Word
setChannelsLast :: Word -> T Noninterleaved y Word
getRate :: T i y (SampleFreq, Ordering)
getRateMin :: T i y (SampleFreq, Ordering)
getRateMax :: T i y (SampleFreq, Ordering)
testRate :: SampleFreq -> Ordering -> T i y (Errno)
setRate :: SampleFreq -> Ordering -> T i y ()
setRateMin :: SampleFreq -> Ordering -> T i y (SampleFreq, Ordering)
setRateMax :: SampleFreq -> Ordering -> T i y (SampleFreq, Ordering)
setRateMinmax :: SampleFreq -> Ordering -> SampleFreq -> Ordering -> T i y (SampleFreq, Ordering, SampleFreq, Ordering)
setRateNear :: SampleFreq -> Ordering -> T i y (SampleFreq, Ordering)
setRateFirst :: SampleFreq -> Ordering -> T i y (SampleFreq, Ordering)
setRateLast :: SampleFreq -> Ordering -> T i y (SampleFreq, Ordering)
setRateResample :: Bool -> T i y ()
getRateResample :: T i y (Bool)
setExportBuffer :: Bool -> T i y ()
getExportBuffer :: T i y (Bool)
getPeriodTime :: T i y (Time, Ordering)
getPeriodTimeMin :: T i y (Time, Ordering)
getPeriodTimeMax :: T i y (Time, Ordering)
testPeriodTime :: Time -> Ordering -> T i y (Errno)
setPeriodTime :: Time -> Ordering -> T i y ()
setPeriodTimeMin :: Time -> Ordering -> T i y (Time, Ordering)
setPeriodTimeMax :: Time -> Ordering -> T i y (Time, Ordering)
setPeriodTimeMinmax :: Time -> Ordering -> Time -> Ordering -> T i y (Time, Ordering, Time, Ordering)
setPeriodTimeNear :: Time -> Ordering -> T i y (Time, Ordering)
setPeriodTimeFirst :: Time -> Ordering -> T i y (Time, Ordering)
setPeriodTimeLast :: Time -> Ordering -> T i y (Time, Ordering)
getPeriodSize :: T i y (Size, Ordering)
getPeriodSizeMin :: T i y (Size, Ordering)
getPeriodSizeMax :: T i y (Size, Ordering)
testPeriodSize :: Size -> Ordering -> T i y (Errno)
setPeriodSize :: Size -> Ordering -> T i y ()
setPeriodSizeMin :: Size -> Ordering -> T i y (Size, Ordering)
setPeriodSizeMax :: Size -> Ordering -> T i y (Size, Ordering)
setPeriodSizeMinmax :: Size -> Ordering -> Size -> Ordering -> T i y (Size, Ordering, Size, Ordering)
setPeriodSizeNear :: Size -> Ordering -> T i y (Size, Ordering)
setPeriodSizeFirst :: Size -> Ordering -> T i y (Size, Ordering)
setPeriodSizeLast :: Size -> Ordering -> T i y (Size, Ordering)
setPeriodSizeInteger :: T i y ()
getPeriods :: T i y (Word, Ordering)
getPeriodsMin :: T i y (Word, Ordering)
getPeriodsMax :: T i y (Word, Ordering)
testPeriods :: Word -> Ordering -> T i y (Errno)
setPeriods :: Word -> Ordering -> T i y ()
setPeriodsMin :: Word -> Ordering -> T i y (Word, Ordering)
setPeriodsMax :: Word -> Ordering -> T i y (Word, Ordering)
setPeriodsMinmax :: Word -> Ordering -> Word -> Ordering -> T i y (Word, Ordering, Word, Ordering)
setPeriodsNear :: Word -> Ordering -> T i y (Word, Ordering)
setPeriodsFirst :: Word -> Ordering -> T i y (Word, Ordering)
setPeriodsLast :: Word -> Ordering -> T i y (Word, Ordering)
setPeriodsInteger :: T i y ()
getBufferTime :: T i y (Time, Ordering)
getBufferTimeMin :: T i y (Time, Ordering)
getBufferTimeMax :: T i y (Time, Ordering)
testBufferTime :: Time -> Ordering -> T i y (Errno)
setBufferTime :: Time -> Ordering -> T i y ()
setBufferTimeMin :: Time -> Ordering -> T i y (Time, Ordering)
setBufferTimeMax :: Time -> Ordering -> T i y (Time, Ordering)
setBufferTimeMinmax :: Time -> Ordering -> Time -> Ordering -> T i y (Time, Ordering, Time, Ordering)
setBufferTimeNear :: Time -> Ordering -> T i y (Time, Ordering)
setBufferTimeFirst :: Time -> Ordering -> T i y (Time, Ordering)
setBufferTimeLast :: Time -> Ordering -> T i y (Time, Ordering)
getBufferSize :: T i y (Size)
getBufferSizeMin :: T i y (Size)
getBufferSizeMax :: T i y (Size)
testBufferSize :: Size -> T i y (Errno)
setBufferSize :: Size -> T i y ()
setBufferSizeMin :: Size -> T i y (Size)
setBufferSizeMax :: Size -> T i y (Size)
setBufferSizeMinmax :: Size -> Size -> T i y (Size, Size)
setBufferSizeNear :: Size -> T i y (Size)
setBufferSizeFirst :: Size -> T i y (Size)
setBufferSizeLast :: Size -> T i y (Size)
getTickTime :: T i y (Time, Ordering)
getTickTimeMin :: T i y (Time, Ordering)
getTickTimeMax :: T i y (Time, Ordering)
testTickTime :: Time -> Ordering -> T i y (Errno)
setTickTime :: Time -> Ordering -> T i y ()
setTickTimeMin :: Time -> Ordering -> T i y (Time, Ordering)
setTickTimeMax :: Time -> Ordering -> T i y (Time, Ordering)
setTickTimeMinmax :: Time -> Ordering -> Time -> Ordering -> T i y (Time, Ordering, Time, Ordering)
setTickTimeNear :: Time -> Ordering -> T i y (Time, Ordering)
setTickTimeFirst :: Time -> Ordering -> T i y (Time, Ordering)
setTickTimeLast :: Time -> Ordering -> T i y (Time, Ordering)
getMinAlign :: T i y (Size)
setRateBufferTime :: SampleFreq -> Time -> Time -> T Interleaved y (Size, Size)

module Sound.ALSA.PCM.Node.File
data Handle y
type Time = Int
type SampleFreq = Int
type Size = Int
class (Storable y, C y) => SampleFmt y
open :: SampleFmt y => IOMode -> FilePath -> IO (Handle y)
close :: SampleFmt y => Handle y -> IO ()

-- | This expects pad bytes that are needed in memory in order to satisfy
--   aligment constraints. This is only a problem for samples sizes like 24
--   bit.
read :: SampleFmt y => Handle y -> Ptr y -> Size -> IO Size

-- | Same restrictions as for <tt>fileRead</tt>.
write :: SampleFmt y => Handle y -> Ptr y -> Size -> IO ()

module Sound.ALSA.PCM.Node.ALSA
data Handle i y
data Stream
StreamPlayback :: Stream
StreamCapture :: Stream
data Mode
modes :: [Mode] -> Mode
nonBlock :: Mode
async :: Mode
data Interleaved
data Noninterleaved
type Time = Int
type SampleFreq = Int
type Size = Int
class Access i
class (Storable y, C y) => SampleFmt y

-- | Sample types of this class must have exactly one channel, i.e.
--   Frame.numberOfChannels == 1.
class SampleFmt y => MonoSampleFmt y
open :: (Access i, SampleFmt y) => Mode -> Stream -> T i y a -> (a -> T i y b) -> String -> IO (b, Handle i y)
close :: Handle i y -> IO ()
prepare :: Handle i y -> IO ()
start :: Handle i y -> IO ()
drop :: Handle i y -> IO ()
drain :: Handle i y -> IO ()
readi :: SampleFmt y => Handle Interleaved y -> Ptr y -> Size -> IO Size
writei :: SampleFmt y => Handle Interleaved y -> Ptr y -> Size -> IO Size

-- | retry on buffer over-run
readiRetry :: SampleFmt y => Handle Interleaved y -> Ptr y -> Size -> IO Size

-- | retry on buffer under-run
writeiRetry :: SampleFmt y => Handle Interleaved y -> Ptr y -> Size -> IO Size

-- | The <tt>Ptr (Ptr y)</tt> argument is actually a pointer to an array of
--   pointers. The array must have the size of number of channels. In
--   <a>Noninterleaved</a> mode you must set the number of channels
--   manually using <a>setChannels</a> or its friends. It is an unchecked
--   error if the number of channels set with <a>setChannels</a> does not
--   match the array size in the <a>readn</a> call.
readn :: MonoSampleFmt y => Handle Noninterleaved y -> Ptr (Ptr y) -> Size -> IO Size

-- | Cf. <a>readn</a>.
writen :: MonoSampleFmt y => Handle Noninterleaved y -> Ptr (Ptr y) -> Size -> IO Size

module Sound.ALSA.PCM
class (Storable y, C y) => SampleFmt y
sampleFmtToPcmFormat :: SampleFmt y => y -> Format
type SampleFreq = Int
type Time = Int
type Size = Int
data SoundFmt y
SoundFmt :: SampleFreq -> SoundFmt y
sampleFreq :: SoundFmt y -> SampleFreq

-- | Counts are in samples, not bytes. Multi-channel data is interleaved.
data SoundSource handle y
SoundSource :: IO (handle y) -> (handle y -> IO ()) -> (handle y -> IO ()) -> (handle y -> IO ()) -> (handle y -> Ptr y -> Size -> IO Size) -> SoundSource handle y
soundSourceOpen :: SoundSource handle y -> IO (handle y)
soundSourceClose :: SoundSource handle y -> handle y -> IO ()
soundSourceStart :: SoundSource handle y -> handle y -> IO ()
soundSourceStop :: SoundSource handle y -> handle y -> IO ()
soundSourceRead :: SoundSource handle y -> handle y -> Ptr y -> Size -> IO Size
data SoundSink handle y
SoundSink :: IO (handle y) -> (handle y -> IO ()) -> (handle y -> Ptr y -> Size -> IO ()) -> (handle y -> IO ()) -> (handle y -> IO ()) -> SoundSink handle y
soundSinkOpen :: SoundSink handle y -> IO (handle y)
soundSinkClose :: SoundSink handle y -> handle y -> IO ()
soundSinkWrite :: SoundSink handle y -> handle y -> Ptr y -> Size -> IO ()
soundSinkStart :: SoundSink handle y -> handle y -> IO ()
soundSinkStop :: SoundSink handle y -> handle y -> IO ()
data SoundBufferTime
SoundBufferTime :: Time -> Time -> SoundBufferTime
bufferTime :: SoundBufferTime -> Time
periodTime :: SoundBufferTime -> Time
type Pcm = Handle Interleaved
type File = Handle
withSoundSource :: SoundSource handle y -> (handle y -> IO a) -> IO a
withSoundSourceRunning :: SoundSource handle y -> handle y -> IO a -> IO a
withSoundSink :: SoundSink handle y -> (handle y -> IO a) -> IO a
withSoundSinkRunning :: SoundSink handle y -> handle y -> IO a -> IO a
soundFmtMIME :: SampleFmt y => SoundFmt y -> String
audioBytesPerSample :: SampleFmt y => SoundFmt y -> Int
audioBytesPerFrame :: SampleFmt y => SoundFmt y -> Int
soundSourceBytesPerFrame :: SampleFmt y => SoundSource handle y -> Int
soundSinkBytesPerFrame :: SampleFmt y => SoundSink handle y -> Int
copySound :: SampleFmt y => SoundSource handleIn y -> SoundSink handleOut y -> Size -> IO ()
alsaSoundSource :: SampleFmt y => String -> SoundFmt y -> SoundSource Pcm y
alsaSoundSink :: SampleFmt y => String -> SoundFmt y -> SoundSink Pcm y
alsaSoundSourceTime :: SampleFmt y => String -> SoundFmt y -> SoundBufferTime -> SoundSource Pcm y
alsaSoundSinkTime :: SampleFmt y => String -> SoundFmt y -> SoundBufferTime -> SoundSink Pcm y
alsaSoundSourceParams :: SampleFmt y => String -> T Interleaved y a -> (a -> T Interleaved y ()) -> SoundSource Pcm y
alsaSoundSinkParams :: SampleFmt y => String -> T Interleaved y a -> (a -> T Interleaved y ()) -> SoundSink Pcm y
fileSoundSource :: SampleFmt y => FilePath -> SoundSource File y
fileSoundSink :: SampleFmt y => FilePath -> SoundSink File y
instance Show (SoundFmt y)
instance Show SoundBufferTime
