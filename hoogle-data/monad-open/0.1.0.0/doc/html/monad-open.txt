-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Open recursion for when you need it
--   
@package monad-open
@version 0.1.0.0

module Control.Monad.Open.Class

-- | To know <tt><a>MonadOpen</a> a b m</tt> is to have a function <tt>a →
--   m b</tt> which serves as a recursive call to the ambient open
--   operation. The <tt><a>MonadOpen</a> a b m</tt> judgement presupposes
--   <tt><a>Monad</a> m</tt>.
class Monad m => MonadOpen a b m | m -> a b
call :: MonadOpen a b m => a -> m b

-- | The type of open operations from <tt>a</tt> to <tt>b</tt> in modality
--   <tt>m</tt>; when <tt><a>Alternative</a> m</tt> is evident, then such
--   operations may be composed horizontally via a <a>Monoid</a> instance.
newtype Op a m b
Op :: (a -> m b) -> Op a m b
_op :: Op a m b -> a -> m b
instance MonadOpen a b m => MonadOpen a b (MaybeT m)
instance MonadOpen a b m => MonadOpen a b (ListT m)
instance MonadOpen a b m => MonadOpen a b (ContT r m)
instance MonadOpen a b m => MonadOpen a b (IdentityT m)
instance MonadOpen a b m => MonadOpen a b (ExceptT e m)
instance (Monoid w, MonadOpen a b m) => MonadOpen a b (RWST r w s m)
instance (Monoid w, MonadOpen a b m) => MonadOpen a b (RWST r w s m)
instance MonadOpen a b m => MonadOpen a b (StateT s m)
instance MonadOpen a b m => MonadOpen a b (StateT s m)
instance (Monoid w, MonadOpen a b m) => MonadOpen a b (WriterT w m)
instance (Monoid w, MonadOpen a b m) => MonadOpen a b (WriterT w m)
instance MonadOpen a b m => MonadOpen a b (ReaderT r m)
instance Alternative m => Monoid (Op a m b)

module Control.Monad.Trans.Open

-- | A concrete structure implementing the <a>MonadOpen</a> signature.
data OpenT a b m b'

-- | A simplified version of the <a>OpenT</a> type which fixes the output
--   parameter.
type OpenT' a m b = OpenT a b m b

-- | An open operation may be closed.
close :: Monad m => Op a (OpenT a b m) b -> a -> m b
instance MonadRWS r w s m => MonadRWS r w s (OpenT a b m)
instance Applicative m => Applicative (OpenT a b m)
instance Functor m => Functor (OpenT a b m)
instance Monad m => Monad (OpenT a b m)
instance Alternative m => Alternative (OpenT a b m)
instance MonadPlus m => MonadPlus (OpenT a b m)
instance MonadIO m => MonadIO (OpenT a b m)
instance MonadCont m => MonadCont (OpenT a b m)
instance MonadFix m => MonadFix (OpenT a b m)
instance MonadThrow m => MonadThrow (OpenT a b m)
instance MonadCatch m => MonadCatch (OpenT a b m)
instance MonadMask m => MonadMask (OpenT a b m)
instance MonadError e m => MonadError e (OpenT a b m)
instance MonadWriter w m => MonadWriter w (OpenT a b m)
instance MonadState s m => MonadState s (OpenT a b m)
instance Monad m => MonadOpen a b (OpenT a b m)
instance MonadReader r m => MonadReader r (OpenT a b m)
instance MonadTrans (OpenT a b)


-- | This is a demonstration of using open recursion to implement the
--   judgements of a small theory modularly.
module Control.Monad.Trans.Open.Example

-- | The syntax of terms in our theory.
data Ty
Unit :: Ty
Prod :: Ty -> Ty -> Ty

-- | The syntax of terms in our theory.
data Tm
Ax :: Tm
Pair :: Tm -> Tm -> Tm

-- | Next, the forms of judgements are inductively defined. We index the
--   <a>J</a> type by its synthesis.
--   
--   <ul>
--   <li><i><a>DisplayTy</a></i> To know <tt><a>DisplayTy</a> α</tt> is to
--   know the textual notation for the type <tt>α</tt>.</li>
--   <li><i><a>DisplayTm</a></i> To know <tt><a>DisplayTm</a> m</tt> is to
--   know the textual notation for the term <tt>m</tt>.</li>
--   <li><i><a>Check</a></i> To know <tt><a>Check</a> α m</tt> is to know
--   that <tt>m</tt> is a canonical verification of <tt>α</tt>.</li>
--   </ul>
data J a
DisplayTy :: Ty -> J String
DisplayTm :: Tm -> J String
Check :: Ty -> Tm -> J Bool

-- | A <tt><a>Theory</a> j</tt> is an open, partial implementation of the
--   judgements defined by the judgement signature <tt>j</tt>. Theories may
--   be composed, since <tt><a>Monoid</a> (<a>Theory</a> j)</tt> holds.
type Theory j = (Monad m, Alternative m, MonadOpen (j a) a m) => Op (j a) m a

-- | A <a>Theory</a> implementing the judgements as they pertain to the
--   <a>Unit</a> type former.
unitThy :: Theory J

-- | A <a>Theory</a> implementing the judgments as they pertain to the
--   <a>Prod</a> type former.
prodThy :: Theory J

-- | The horizontal composition of the two above theories.
--   
--   <pre>
--   <a>combinedThy</a> = <a>unitThy</a> <a>&lt;&gt;</a> <a>prodThy</a>
--   </pre>
combinedThy :: Theory J

-- | Judgements may be tested through the result of closing the theory.
--   
--   <pre>
--   <a>judge</a> = <a>close</a> <a>combinedThy</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; judge $ DisplayTy $ Prod Unit (Prod Unit Unit)
--   "(unit * (unit * unit))"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; judge $ DisplayTm $ Pair Ax (Pair Ax Ax)
--   "&lt;ax, &lt;ax, ax&gt;&gt;"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; judge $ Check (Prod Unit Unit) Ax
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; judge $ Check (Prod Unit (Prod Unit Unit)) (Pair Ax (Pair Ax Ax))
--   True
--   </pre>
judge :: (Monad m, Alternative m) => J b -> m b

-- | We can inject a log of all assertions into the theory!
traceThy :: (Monad m, Alternative m, MonadOpen (j a) a m, MonadWriter [Pack J] m) => Op (J a) m a
data Pack φ
Pack :: (φ a) -> Pack φ

-- | A traced judging routine is constructed by precomposing
--   <a>traceThy</a> onto the main theory.
--   
--   <pre>
--   <a>tracedJudge</a> j = <a>runIdentity</a> . <a>runWriterT</a> . <a>runMaybeT</a> $ (<a>close</a> $ <a>traceThy</a> <a>&lt;&gt;</a> <a>combinedThy</a>) j
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tracedJudge $ Check (Prod Unit Unit) (Pair Ax Ax)
--   (Just True,[Check (Prod Unit Unit) (Pair Ax Ax),Check Unit Ax,Check Unit Ax])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tracedJudge $ Check (Prod Unit Unit) (Pair Ax (Pair Ax Ax))
--   (Just False,[Check (Prod Unit Unit) (Pair Ax (Pair Ax Ax)),Check Unit Ax,Check Unit (Pair Ax Ax)])
--   </pre>
tracedJudge :: J b -> (Maybe b, [Pack J])
instance Show (J a)
instance Eq Ty
instance Show Ty
instance Eq Tm
instance Show Tm
instance Show (Pack J)
