-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An EDSL for creating simple diagrams
--   
--   An embedded domain-specific language (EDSL) for creating simple
--   diagrams, built on top of the Cairo rendering engine. NOTE: This
--   package is deprecated, see the diagrams-core, diagrams-lib, and
--   diagrams-cairo packages instead.
@package diagrams
@version 0.2.2.3


-- | Type definitions and convenience functions for
--   <a>Graphics.Rendering.Diagrams</a>, an embedded domain-specific
--   language (EDSL) for creating simple diagrams.
module Graphics.Rendering.Diagrams.Types

-- | <a>Diagram</a> is the core data type which describes a diagram.
--   <a>Diagram</a>s may be constructed, transformed, combined, and
--   ultimately rendered as an image.
data Diagram

-- | The empty diagram
Empty :: Diagram

-- | A primitive shape
Prim :: Shape -> Diagram

-- | An annotated diagram
Ann :: Attr -> Diagram -> Diagram

-- | A compound diagram
Compound :: Layout -> Diagram

-- | A fully processed compound diagram, ready for rendering
Union :: [Diagram] -> Diagram

-- | An explicitly sized diagram whose bounding box takes up a particular
--   amount of space.
Sized :: Point -> Diagram -> Diagram

-- | The <a>Color</a> type class encompasses color representations which
--   can be used by the Diagrams library; that is, every function in the
--   Diagrams library which expects a color can take any type which is an
--   instance of <a>Color</a>. Instances are provided for both the
--   <a>Colour</a> and <a>AlphaColour</a> types from the <a>Data.Colour</a>
--   library.
class Color c
colorToRGBA :: Color c => c -> (Double, Double, Double, Double)

-- | Existential wrapper for instances of the <a>Color</a> class.
data SomeColor
SomeColor :: c -> SomeColor

-- | Basic 2D points/vectors.
type Point = (Double, Double)
type Vec = Point

-- | Scalar multiplication.
(*.) :: Double -> Point -> Point
(.+.) :: Point -> Point -> Point

-- | Elementwise addition, subtraction and multiplication for
--   <a>Point</a>s.
(.-.) :: Point -> Point -> Point
(.*.) :: Point -> Point -> Point

-- | A path is a series of edges which can be stroked, filled, etc. It can
--   be either open (the default) or closed (i.e. the first and last
--   vertices are connected).
data Path
Path :: PathType -> [Vec] -> Path

-- | A path can be open (normal) or closed (first and last vertices
--   connected automatically).
data PathType
Open :: PathType
Closed :: PathType

-- | The styles in which a path can be rendered.
data PathStyle
Straight :: PathStyle
Bezier :: Double -> PathStyle

-- | The primitive shapes which can be used to build up a diagram. Every
--   primitive shape must be an instance of <a>ShapeClass</a>.
--   
--   Given a shape <tt>s</tt>, if <tt>shapeSize s</tt> evaluates to
--   <tt>(w,h)</tt>, then the drawing rendered by <tt>renderShape s</tt>
--   should fit within a <tt>w</tt> by <tt>h</tt> rectangle centered at the
--   origin.
--   
--   You can create your own shape primitives by creating a new data type
--   and making it an instance of <a>ShapeClass</a>. If you do so, you must
--   be sure that your <a>ShapeClass</a> instance satisfies the law
--   described above, on which the rendering engine relies in order to
--   compute the proper positions for objects in a diagram. Otherwise,
--   instances of your object in a diagram may extend outside the
--   boundaries of the rendered image, or inadvertently overlap or be
--   overlapped by other diagram elements. Of course, you are free to
--   ignore this "law" as well; it will cause unexpected output at worst,
--   and at best you may find some clever way to bend the system to your
--   will. =)
class ShapeClass s
shapeSize :: ShapeClass s => s -> Point
renderShape :: ShapeClass s => s -> DiaRenderM ()

-- | Existential wrapper type for shapes.
data Shape
Shape :: s -> Shape

-- | Attributes which can be applied as annotations to a <a>Diagram</a>,
--   and change the way the <a>Diagram</a> is interpreted or rendered.
--   Every attribute must be an instance of <a>AttrClass</a>.
class AttrClass a
attrSize :: AttrClass a => a -> Point -> Point
renderAttr :: AttrClass a => a -> DiaRenderM (DiaRenderEnv -> DiaRenderEnv)

-- | Existential wrapper type for attributes.
data Attr
Attr :: a -> Attr

-- | All layouts must be instances of <a>LayoutClass</a>, along with an
--   appropriate container type which must be an instance of Functor.
class Functor f => LayoutClass l f
layoutSizeAndPos :: LayoutClass l f => l -> f (Point, Diagram) -> (Point, [Diagram])

-- | An existential wrapper type for layouts. A layout consists of a
--   (possibly parameterized) layout type, along with a container of
--   <a>Diagram</a>s.
data Layout
Layout :: l -> (f Diagram) -> Layout

-- | An environment containing additional parameters to be made available
--   while rendering, which for one reason or another are not or cannot be
--   provided by the cairo <tt>Render</tt> monad itself. For example, cairo
--   only tracks one current color, so we must track a fill color and
--   stroke color separately.
data DiaRenderEnv
DREnv :: SomeColor -> SomeColor -> Double -> DiaRenderEnv
envFillColor :: DiaRenderEnv -> SomeColor
envStrokeColor :: DiaRenderEnv -> SomeColor
envStrokeWidth :: DiaRenderEnv -> Double

-- | The default rendering environment: transparent fill with 1-pixel black
--   strokes.
defaultDiaRenderEnv :: DiaRenderEnv
setEnvFillColor :: Color c => c -> DiaRenderEnv -> DiaRenderEnv
setEnvStrokeColor :: Color c => c -> DiaRenderEnv -> DiaRenderEnv
setEnvStrokeWidth :: Double -> DiaRenderEnv -> DiaRenderEnv

-- | The custom rendering monad: ReaderT <a>DiaRenderEnv</a> on top of
--   cairo's Render monad.
newtype DiaRenderM a
DRM :: (ReaderT DiaRenderEnv Render a) -> DiaRenderM a

-- | Run a <a>DiaRenderM</a> action, given an initial rendering
--   environment, to produce a cairo <tt>Render</tt> action.
runDiaRenderM :: DiaRenderM a -> DiaRenderEnv -> Render a

-- | Lift a cairo <tt>Render</tt> action into a <a>DiaRenderM</a> action.
c :: Render a -> DiaRenderM a

-- | A specification of the size of a rendered <a>Diagram</a>.
data SizeSpec

-- | an explicit width; the height is determined automatically
Width :: Double -> SizeSpec

-- | an explicit height; the width is determined automatically
Height :: Double -> SizeSpec

-- | determine the size automatically (do not scale)
Auto :: SizeSpec

-- | The supported output file types for rendered diagrams.
data OutputType
PNG :: OutputType
PS :: OutputType
PDF :: OutputType
SVG :: OutputType
instance Eq PathType
instance Show PathType
instance Read PathType
instance Eq Path
instance Show Path
instance Read Path
instance Eq PathStyle
instance Show PathStyle
instance Read PathStyle
instance Functor DiaRenderM
instance Monad DiaRenderM
instance MonadReader DiaRenderEnv DiaRenderM
instance Color SomeColor
instance (Floating a, Real a) => Color (AlphaColour a)
instance (Floating a, Real a) => Color (Colour a)


-- | Type definitions and convenience functions for
--   <a>Graphics.Rendering.Diagrams</a>, an embedded domain-specific
--   language (EDSL) for creating simple diagrams.
module Graphics.Rendering.Diagrams.Paths

-- | The empty path, i.e. a path with no edges.
emptyPath :: Path

-- | Create an open path from a list of vertices. For example,
--   <tt>pathFromVertices [(1,3), (4,4), (6,5)]</tt> describes the path
--   with two segments which starts at (1,3), has a corner at (4,4), and
--   ends at (6,5). Note, however, that the vertices themselves are not
--   significant, only the distances between them. That is,
--   <tt>pathFromVertices [(0,1), (3,2), (5,3)]</tt> describes exactly the
--   same path.
pathFromVertices :: [Point] -> Path

-- | Create an open path from a list of edge displacement vectors. For
--   example, <tt>pathFromVectors [(1,1), (3,4)]</tt> describes the path
--   with two segments which first moves one unit in the positive x and y
--   directions, and then moves three units in the positive x direction and
--   four in the positive y direction.
pathFromVectors :: [Vec] -> Path

-- | Convert a path into a list of vertices, starting with the given
--   vertex.
pathToVertices :: Point -> Path -> [Point]

-- | Convert a path to a list of vectors corresponding to the edges of the
--   path.
pathToVectors :: Path -> [Vec]

-- | Concatenate two open paths into a single open path consisting of the
--   first followed by the second.
pathConcat :: Path -> Path -> Path

-- | Create a closed path (by connecting the first and last points in the
--   path).
closed :: Path -> Path

-- | Determine whether a <a>Path</a> is closed or open.
isClosed :: Path -> Bool

-- | Rotate a path by a fraction of a circle. <tt>rotPath d</tt> rotates
--   paths by an angle of <tt>d*2*pi</tt> radians. Note that creating a
--   <a>Diagram</a> from a <a>Path</a> (using <tt>straight</tt> or
--   <tt>curved</tt> or some other such function) and then applying
--   <tt>rotate</tt> to it is different than first applying <a>rotPath</a>
--   to the <a>Path</a> before making it into a <a>Diagram</a>. In the
--   latter case, the bounding box will be correct, whereas in the former
--   case, the bounding box will still correspond to the unrotated version
--   of the path.
rotPath :: Double -> Path -> Path

-- | Compute the size of a bounding box for the given <a>Path</a>, and the
--   | offset of the starting vertex from the center.
pathSizeAndOffset :: Path -> (Vec, Point)

-- | Render a path using a particular style in the Cairo rendering monad.
renderPath :: PathStyle -> Path -> Render ()


-- | Attributes which can be added as annotations to a <a>Diagram</a>,
--   implemented via instances of <a>AttrClass</a>.
module Graphics.Rendering.Diagrams.Attributes

-- | Apply all the default attributes to a <a>Diagram</a>.
defaultAttributes :: Diagram -> Diagram

-- | Draw a diagram using the given fill color. Note that the new color
--   only applies to parts of the diagram which are not otherwise colored;
--   subdiagrams which already have an explicit fill color will not be
--   affected. The default fill color is completely transparent.
fillColor :: Color c => c -> Diagram -> Diagram

-- | <a>fc</a> is provided as a convenient short synonym for
--   <a>fillColor</a>.
fc :: Color c => c -> Diagram -> Diagram

-- | Draw a diagram using the given color for lines. Note that the new
--   color only applies to parts of the diagram which are not otherwise
--   colored; subdiagrams which already have an explicit line color will
--   not be affected. The default line color is black.
lineColor :: Color c => c -> Diagram -> Diagram

-- | <a>lc</a> is provided as a convenient short synonym for
--   <a>lineColor</a>.
lc :: Color c => c -> Diagram -> Diagram

-- | Draw shape outlines and lines with the given width. Note that the line
--   width is invariant under uniform scaling, although under non-uniform
--   scaling (scaling by different amounts in the x and y axes) lines can
--   become distorted. The default line width is 1.
lineWidth :: Double -> Diagram -> Diagram

-- | <a>lw</a> is provided as a convenient short synonym for
--   <a>lineWidth</a>.
lw :: Double -> Diagram -> Diagram

-- | Set the line cap style. Valid values for <tt>LineCap</tt> are
--   <tt>LineCapButt</tt>, <tt>LineCapRound</tt>, and
--   <tt>LineCapSquare</tt>.
lineCap :: LineCap -> Diagram -> Diagram

-- | Specify line endings.
--   
--   <ul>
--   <li><i><a>LineCapButt</a></i> Start(stop) the line exactly at the
--   start(end) point.</li>
--   <li><i><a>LineCapRound</a></i> Use a round ending, the center of the
--   circle is the end point.</li>
--   <li><i><a>LineCapSquare</a></i> Use squared ending, the center of the
--   square is the end point</li>
--   </ul>
data LineCap :: *
LineCapButt :: LineCap
LineCapRound :: LineCap
LineCapSquare :: LineCap

-- | Set the line join style. Valid values for <tt>LineJoin</tt> are
--   <tt>LineJoinMiter</tt>, <tt>LineJoinRound</tt>, and
--   <tt>LineJoinBevel</tt>.
lineJoin :: LineJoin -> Diagram -> Diagram

-- | Specify how lines join.
data LineJoin :: *
LineJoinMiter :: LineJoin
LineJoinRound :: LineJoin
LineJoinBevel :: LineJoin

-- | Set the line dashing pattern.
dashing :: [Double] -> Double -> Diagram -> Diagram

-- | Change the default typeface to one named.
typeface :: String -> Diagram -> Diagram

-- | Convenience function to change the typeface.
tf :: String -> Diagram -> Diagram

-- | Stretch a diagram by a separate scaling factor for each axis.
--   <tt>stretch w h</tt> scales by a factor of <tt>w</tt> in the x
--   direction and a factor of <tt>h</tt> in the y direction.
stretch :: Double -> Double -> Diagram -> Diagram

-- | Scale by the same scaling factor in both dimensions, so the diagram
--   retains its aspect ratio.
scale :: Double -> Diagram -> Diagram

-- | Scale a diagram along the x-axis only. <tt>scaleX s</tt> is equivalent
--   to <tt>stretch s 1</tt>.
scaleX :: Double -> Diagram -> Diagram

-- | Scale a diagram along the y-axis only. <tt>scaleY s</tt> is equivalent
--   to <tt>stretch 1 s</tt>.
scaleY :: Double -> Diagram -> Diagram

-- | Translate a diagram by the given relative offsets in the x and y
--   directions. Note that the positive x-axis is to the right, while the
--   positive y-axis points downwards.
translate :: Double -> Double -> Diagram -> Diagram

-- | Translate a diagram along the x-axis only. <tt>translateX x</tt> is
--   equivalent to <tt>translate x 0</tt>.
translateX :: Double -> Diagram -> Diagram

-- | Translate a diagram along the y-axis only. <tt>translateY y</tt> is
--   equivalent to <tt>translate 0 y</tt>.
translateY :: Double -> Diagram -> Diagram

-- | <tt>rotate f</tt> rotates a diagram clockwise by fraction <tt>f</tt>
--   of a complete revolution. <tt>rotate f</tt> is equivalent to
--   <tt>rotateR (2*pi*f)</tt>.
rotate :: Double -> Diagram -> Diagram

-- | <tt>rotateR r</tt> rotates a diagram clockwise by <tt>r</tt> radians.
rotateR :: Double -> Diagram -> Diagram
instance Eq StrokeWidth
instance Show StrokeWidth
instance Read StrokeWidth
instance Eq Typeface
instance Show Typeface
instance Read Typeface
instance Eq Rotate
instance Show Rotate
instance Read Rotate
instance Eq Translate
instance Show Translate
instance Read Translate
instance Eq Scale
instance Show Scale
instance Read Scale
instance AttrClass Dashing
instance AttrClass LJoin
instance AttrClass LCap
instance AttrClass Scale
instance AttrClass Translate
instance AttrClass Rotate
instance AttrClass Typeface
instance AttrClass StrokeWidth
instance AttrClass Stroke
instance AttrClass Fill


-- | Primitive shapes out of which <a>Diagram</a>s can be built,
--   implemented via instances of <a>ShapeClass</a>.
module Graphics.Rendering.Diagrams.Shapes

-- | <tt>circle r</tt> is a circle with radius <tt>r</tt>.
circle :: Double -> Diagram

-- | <tt>arc r a1 a2</tt> is a circular arc with radius <tt>r</tt>,
--   starting at angle <tt>a1*2*pi</tt> and proceeding in a direction of
--   increasing angle to <tt>a2*2*pi</tt>.
arc :: Double -> Double -> Double -> Diagram

-- | <tt>regPolyPath n r</tt> is an open path corresponding to a regular
--   polygon, with the first vertex oriented along the positive x-axis and
--   proceeding clockwise.
regPolyPath :: Int -> Double -> Path

-- | <tt>regPoly n r</tt> is a regular n-gon, with a circumcircle of radius
--   <tt>r</tt>. One vertex is oriented along the positive x-axis.
regPoly :: Int -> Double -> Diagram

-- | <tt>rotRegPoly n r a</tt> is the same as <tt><a>regPoly</a> n r</tt>
--   but rotated through an angle of <tt>a*2*pi</tt> radians (i.e.,
--   <tt>a</tt> represents a fraction of an entire revolution). This is
--   different than <tt><tt>rotate</tt> a $ <a>regPoly</a> n r</tt>;
--   <tt>rotRegPoly</tt> will adjust the bounding box correctly (using
--   <a>rotPath</a>), whereas the construction using <tt>rotate</tt> will
--   still have a bounding box corresponding to the unrotated polygon.
rotRegPoly :: Int -> Double -> Double -> Diagram

-- | <tt>rect w h</tt> is a rectangle of width <tt>w</tt> and height
--   <tt>h</tt>.
rect :: Double -> Double -> Diagram

-- | <tt>rectPath w h</tt> is a closed path describing a rectangle of width
--   <tt>w</tt> and height <tt>h</tt>.
rectPath :: Double -> Double -> Path

-- | <tt>roundRect w h</tt> is a rectangle of width <tt>w</tt> and height
--   <tt>h</tt> with rounded corners having a radius one third the length
--   of the shortest edge.
roundRect :: Double -> Double -> Diagram

-- | <tt>roundRect w h f</tt> is a rectangle of width <tt>w</tt> and height
--   <tt>h</tt> with rounded corners having a radius <tt>f</tt> times the
--   length of the shortest edge.
roundRectF :: Double -> Double -> Double -> Diagram

-- | <tt>straight</tt> creates a <a>Diagram</a> from a path, by drawing
--   straight lines along the path edges.
straight :: Path -> Diagram

-- | <tt>curved d p</tt> is a curved path which follows generally the path
--   <tt>p</tt>. The parameter <tt>d</tt> specifies the amount of corner
--   rounding. In particular, <tt>d</tt> should be a value between 0 and 1,
--   which specifies what fraction of the path segments should be rounded
--   off with bezier curves, using the path vertices as control points.
--   Thus <tt>d = 0</tt> produces the polygonal path itself, with no curved
--   segments; <tt>d = 1</tt> produces a continuously curving path tangent
--   to the midpoints of the path segments; and intermediate values of
--   <tt>d</tt> interpolate between the two. The curved path produced will
--   be everywhere differentiable as long as <tt>d &gt; 0</tt>. If the path
--   is not closed, the curve will begin and end at the first and last path
--   vertices (no rounding will take place at these vertices).
curved :: Double -> Path -> Diagram

-- | <tt>textPath s t</tt> is a string of text <tt>t</tt> at size
--   <tt>s</tt>, represented as an outline with separate stroke and fill.
textPath :: Double -> String -> Diagram

-- | <tt>rawCairo s r</tt> is a diagram with bounding box size <tt>s</tt>,
--   rendered by executing Cairo <tt>Render</tt> action <tt>r</tt>. Import
--   <a>Graphics.Rendering.Cairo</a> to access Cairo operations.
rawCairo :: Point -> Render () -> Diagram
instance Eq Arc
instance Show Arc
instance Read Arc
instance Eq PathShape
instance Show PathShape
instance Read PathShape
instance Eq RoundRect
instance Show RoundRect
instance Read RoundRect
instance Eq Text
instance Show Text
instance Read Text
instance ShapeClass RawCairo
instance ShapeClass Text
instance ShapeClass RoundRect
instance ShapeClass PathShape
instance ShapeClass Arc


-- | The core rendering engine for <a>Graphics.Rendering.Diagrams</a>, an
--   embedded domain-specific language (EDSL) for creating simple diagrams.
module Graphics.Rendering.Diagrams.Engine

-- | Given a <a>Diagram</a>, compute its total size, and produce a new
--   version of the <a>Diagram</a> with all sub-<a>Diagram</a>s positioned
--   properly.
sizeAndPos :: Diagram -> (Point, Diagram)

-- | Given a target width or height and a user-constructed <a>Diagram</a>,
--   render it using the Cairo rendering library. Note that <a>compose</a>
--   takes care of all the rendering details, including preprocessing of
--   the <a>Diagram</a>, and scaling/translating the final output so that
--   it fits within the given width or height. <a>compose</a> also produces
--   the size of the final diagram; the width or height will be equal to
--   that specified in the input, and the other dimension will be
--   determined by the aspect ratio of the diagram.
--   
--   The background of the output diagram will be opaque white.
--   
--   In order to produce a physical output, the output of <a>compose</a>
--   must be given as input to an output adapter such as <tt>writePng</tt>.
--   Normally, however, a user of the diagrams library should not need to
--   call <a>compose</a> directly.
compose :: SizeSpec -> Diagram -> (Point, Render ())

-- | Given a rendered diagram, output it to a file in PNG format with the
--   given width and height.
writePNG :: String -> Point -> Render () -> IO ()

-- | Given a rendered diagram, output it to a file in PostScript format
--   with the given width and height.
writePS :: String -> Point -> Render () -> IO ()

-- | Given a rendered diagram, output it to a file in PDF format with the
--   given width and height.
writePDF :: String -> Point -> Render () -> IO ()

-- | Given a rendered diagram, output it to a file in SVG format with the
--   given width and height.
writeSVG :: String -> Point -> Render () -> IO ()

-- | Given a file name, an output size specification, and a <a>Diagram</a>,
--   use a "backend" to render the <a>Diagram</a> to an actual physical
--   output.
renderWithBackend :: (String -> Point -> Render () -> IO ()) -> String -> SizeSpec -> Diagram -> IO ()
renderOverlayPNG :: FilePath -> FilePath -> Diagram -> IO ()
chooseBackend :: OutputType -> (String -> Point -> Render () -> IO ())

-- | Given a list of rendered diagrams with their height and width, output
--   them as separate pages to a file in PostScript format
writePagesPS :: String -> [(Point, Render ())] -> IO ()

-- | Given a list of rendered diagrams with their height and width, output
--   them as separate pages to a file in DFt format
writePagesPDF :: String -> [(Point, Render ())] -> IO ()

-- | Given a file name, an output size specification, and a list of
--   <a>Diagram</a>s, use a "backend" to render the <a>Diagram</a>s as
--   separate pages to an actual physical output.
renderPagesWithBackend :: (String -> [(Point, Render ())] -> IO ()) -> String -> SizeSpec -> [Diagram] -> IO ()
choosePagesBackend :: OutputType -> (String -> [(Point, Render ())] -> IO ())

-- | Perform a rendering operation atomically, by saving the state and
--   restoring it afterwards.
atomic :: DiaRenderM () -> DiaRenderM ()

-- | Render a diagram.
render :: Diagram -> DiaRenderM ()


-- | Layout definitions for <a>Graphics.Rendering.Diagrams</a>, an embedded
--   domain-specific language (EDSL) for creating simple diagrams.
module Graphics.Rendering.Diagrams.Layouts

-- | Superimpose one diagram atop another. <tt>d1 ## d2</tt> results in a
--   diagram in which <tt>d2</tt> is on top of <tt>d1</tt> (i.e.,
--   <tt>d1</tt> is drawn first, then <tt>d2</tt>).
(##) :: Diagram -> Diagram -> Diagram

-- | Create a <a>Diagram</a> as a union of subdiagrams which will not be
--   repositioned. If the subdiagrams overlap, they will appear with the
--   first <a>Diagram</a> on the bottom, and the last on top.
union :: [Diagram] -> Diagram

-- | Create a <a>Diagram</a> as a union of subdiagrams superimposed on one
--   another, aligned vertically and/or horizontally.
unionA :: HAlignment -> VAlignment -> [Diagram] -> Diagram

-- | <tt>d1 &lt;&gt; d2</tt> is a <a>Diagram</a> with <tt>d1</tt> to the
--   left of <tt>d2</tt>, aligned along their top edges.
(<>) :: Diagram -> Diagram -> Diagram

-- | <tt>d1 // d2</tt> is a <a>Diagram</a> with <tt>d1</tt> above
--   <tt>d2</tt>, aligned along their left edges.
(//) :: Diagram -> Diagram -> Diagram

-- | Lay out a list of <a>Diagram</a>s horizontally from left to right,
--   aligned along their top edges.
hcat :: [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s vertically from top to bottom,
--   aligned along their left edges.
vcat :: [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s horizontally from left to right,
--   with the given vertical alignment (<a>top</a>, <a>vcenter</a>, or
--   <a>bottom</a>).
hcatA :: VAlignment -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s vertically from top to bottom, with
--   the given horizontal alignment (<a>left</a>, <a>hcenter</a>, or
--   <a>right</a>).
vcatA :: HAlignment -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s horizontally, aligned along their
--   top edges, with a given amount of separation in between each pair.
hsep :: Double -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s vertically, aligned along their left
--   edges, with a given amount of separation in between each pair.
vsep :: Double -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s horizontally, with the given amount
--   of separation in between each pair, using the given vertical alignment
--   (<a>top</a>, <a>vcenter</a>, or <a>bottom</a>).
hsepA :: Double -> VAlignment -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s vertically, with the given amount of
--   separation in between each pair, using the given horizontal alignment
--   (<a>left</a>, <a>hcenter</a>, or <a>right</a>).
vsepA :: Double -> HAlignment -> [Diagram] -> Diagram

-- | Distribute a list of <a>Diagram</a>s horizontally according to a
--   regular spacing, aligned along their top edges.
hdistrib :: Double -> HAlignment -> [Diagram] -> Diagram

-- | Distribute a list of <a>Diagram</a>s vertically according to a regular
--   spacing, aligned along their left edges.
vdistrib :: Double -> VAlignment -> [Diagram] -> Diagram

-- | Distribute a list of <a>Diagram</a>s horizontally according to a
--   regular spacing, with the given alignment.
hdistribA :: Double -> HAlignment -> VAlignment -> [Diagram] -> Diagram

-- | Distribute a list of <a>Diagram</a>s vertically according to a regular
--   spacing, with the given alignment.
vdistribA :: Double -> VAlignment -> HAlignment -> [Diagram] -> Diagram

-- | Create a diagram from a list of subdiagrams with explicit positions in
--   a local coordinate system. Each subdiagram will be positioned with its
--   center at the corresponding position. <tt>position</tt> is equivalent
--   to <tt>positionA hcenter vcenter</tt>.
position :: [(Point, Diagram)] -> Diagram

-- | Create a diagram from a list of subdiagrams with explicit positions in
--   a local coordinate system. The alignment options specify what part of
--   each subdiagram should be placed on the corresponding position. For
--   example, <tt>positionA left top</tt> will position the top left corner
--   of each subdiagram at the corresponding point.
positionA :: HAlignment -> VAlignment -> [(Point, Diagram)] -> Diagram

-- | Create a diagram from a list of subdiagrams and a given path, by
--   positioning the subdiagrams at successive vertices of the path. If
--   there are more diagrams than path vertices, the extra diagrams will be
--   discarded.
positionAlong :: [Diagram] -> Path -> Diagram

-- | A version of <a>positionAlong</a> with explicit alignment.
positionAlongA :: HAlignment -> VAlignment -> [Diagram] -> Path -> Diagram

-- | Align diagrams into a grid, with each item centered horizontally and
--   vertically Warning: there is currently an exponential performace
--   blowup if you nest grids. (exponential in how deep the nesting is).
grid :: [[Diagram]] -> Diagram

-- | Align diagrams into a grid with each item aligned as specified.
--   Warning: there is currently an exponential performace blowup if you
--   nest grids (exponential in how deep the nesting is).
gridA :: HAlignment -> VAlignment -> [[Diagram]] -> Diagram

-- | Align diagrams into a grid, specifying individual alignments for each
--   item. Warning: there is currently an exponential performace blowup if
--   you nest grids (exponential in how deep the nesting is).
gridAs :: [[(HAlignment, VAlignment)]] -> [[Diagram]] -> Diagram

-- | Vertical alignment.
type VAlignment = Alignment
top :: VAlignment
vcenter :: VAlignment
bottom :: VAlignment

-- | Horizontal alignment.
type HAlignment = Alignment
left :: HAlignment
hcenter :: HAlignment
right :: HAlignment

-- | Lay out a <a>Tree</a> (from <a>Data.Tree</a>) of <a>Diagram</a>s in a
--   top-down fashion. This layout is experimental; future releases of the
--   Diagrams library are planned which will be able to automatically draw
--   edges between nodes in the tree.
tree :: Double -> Double -> Tree Diagram -> Diagram

-- | Add extra padding to a diagram. <tt>pad w h d</tt> is a diagram which
--   is the same as <tt>d</tt>, but with <tt>w</tt> units added to the
--   width and <tt>h</tt> units added to the height, with <tt>d</tt>
--   centered in the available space. Thus <tt>pad w h</tt> is equivalent
--   to <tt>padA w h hcenter vcenter</tt>.
pad :: Double -> Double -> Diagram -> Diagram

-- | Add extra padding to a diagram, aligning the diagram as indicated
--   within the avilable space.
padA :: Double -> Double -> HAlignment -> VAlignment -> Diagram -> Diagram

-- | Show a rectangle denoting a diagram's bounding box, in addition to the
--   diagram itself.
showBBox :: Diagram -> Diagram

-- | Show the bounding boxes of a diagram and all its subdiagrams.
showBBoxes :: Diagram -> Diagram

-- | Create one diagram using the current size of another. The new diagram
--   is returned, the old one is discarded.
withSize :: (Double -> Double -> Diagram) -> Diagram -> Diagram
instance Eq ListType
instance Show ListType
instance Read ListType
instance Eq Alignment
instance Show Alignment
instance Read Alignment
instance Eq Distribution
instance Show Distribution
instance Read Distribution
instance LayoutClass FromSize Identity
instance LayoutClass ShowBBox Identity
instance LayoutClass Padded Identity
instance LayoutClass Positioned []
instance LayoutClass List []
instance LayoutClass UnionLayout []


-- | An embedded domain-specific language (EDSL) for creating simple
--   diagrams, illustrations, and other types of graphics, built on top of
--   the Cairo rendering engine.
module Graphics.Rendering.Diagrams

-- | <a>Diagram</a> is the core data type which describes a diagram.
--   <a>Diagram</a>s may be constructed, transformed, combined, and
--   ultimately rendered as an image.
data Diagram

-- | The nil diagram, which takes up no space and produces no output.
nil :: Diagram

-- | <tt>circle r</tt> is a circle with radius <tt>r</tt>.
circle :: Double -> Diagram

-- | <tt>arc r a1 a2</tt> is a circular arc with radius <tt>r</tt>,
--   starting at angle <tt>a1*2*pi</tt> and proceeding in a direction of
--   increasing angle to <tt>a2*2*pi</tt>.
arc :: Double -> Double -> Double -> Diagram

-- | <tt>rectPath w h</tt> is a closed path describing a rectangle of width
--   <tt>w</tt> and height <tt>h</tt>.
rectPath :: Double -> Double -> Path

-- | <tt>rect w h</tt> is a rectangle of width <tt>w</tt> and height
--   <tt>h</tt>.
rect :: Double -> Double -> Diagram

-- | <tt>roundRect w h</tt> is a rectangle of width <tt>w</tt> and height
--   <tt>h</tt> with rounded corners having a radius one third the length
--   of the shortest edge.
roundRect :: Double -> Double -> Diagram

-- | <tt>roundRect w h f</tt> is a rectangle of width <tt>w</tt> and height
--   <tt>h</tt> with rounded corners having a radius <tt>f</tt> times the
--   length of the shortest edge.
roundRectF :: Double -> Double -> Double -> Diagram

-- | <tt>regPolyPath n r</tt> is an open path corresponding to a regular
--   polygon, with the first vertex oriented along the positive x-axis and
--   proceeding clockwise.
regPolyPath :: Int -> Double -> Path

-- | <tt>regPoly n r</tt> is a regular n-gon, with a circumcircle of radius
--   <tt>r</tt>. One vertex is oriented along the positive x-axis.
regPoly :: Int -> Double -> Diagram

-- | <tt>rotRegPoly n r a</tt> is the same as <tt><a>regPoly</a> n r</tt>
--   but rotated through an angle of <tt>a*2*pi</tt> radians (i.e.,
--   <tt>a</tt> represents a fraction of an entire revolution). This is
--   different than <tt><tt>rotate</tt> a $ <a>regPoly</a> n r</tt>;
--   <tt>rotRegPoly</tt> will adjust the bounding box correctly (using
--   <a>rotPath</a>), whereas the construction using <tt>rotate</tt> will
--   still have a bounding box corresponding to the unrotated polygon.
rotRegPoly :: Int -> Double -> Double -> Diagram

-- | Create a <a>Diagram</a> out of any instance of <a>ShapeClass</a>.
shape :: ShapeClass s => s -> Diagram

-- | <tt>rawCairo s r</tt> is a diagram with bounding box size <tt>s</tt>,
--   rendered by executing Cairo <tt>Render</tt> action <tt>r</tt>. Import
--   <a>Graphics.Rendering.Cairo</a> to access Cairo operations.
rawCairo :: Point -> Render () -> Diagram

-- | Create text with black fill, no outline, and a default font.
text :: Double -> String -> Diagram

-- | <tt>textPath s t</tt> is a string of text <tt>t</tt> at size
--   <tt>s</tt>, represented as an outline with separate stroke and fill.
textPath :: Double -> String -> Diagram

-- | <tt>hspace w</tt> is a <a>Diagram</a> which produces no output but
--   takes up <tt>w</tt> amount of space horizontally. Useful for manually
--   creating horizontal separation between two diagrams. A negative value
--   of <tt>w</tt> can also be used to move two diagrams closer to one
--   another. <tt>hspace w</tt> is equivalent to <tt>empty w 0</tt>.
hspace :: Double -> Diagram

-- | <tt>vspace h</tt> is a <a>Diagram</a> which produces no output but
--   takes up <tt>h</tt> amount of space vertically. Useful for manually
--   creating vertical separation between two diagrams. A negative value of
--   <tt>h</tt> can also be used to move two diagrams closer to one
--   another. <tt>vspace h</tt> is equivalent to <tt>empty 0 h</tt>.
vspace :: Double -> Diagram

-- | <tt>empty w h</tt> is an empty diagram which produces no output, but
--   takes up an amount of space equal to a <tt>w</tt> by <tt>h</tt>
--   rectangle.
empty :: Double -> Double -> Diagram

-- | A path is a series of edges which can be stroked, filled, etc. It can
--   be either open (the default) or closed (i.e. the first and last
--   vertices are connected).
data Path

-- | The empty path, i.e. a path with no edges.
emptyPath :: Path

-- | Create an open path from a list of vertices. For example,
--   <tt>pathFromVertices [(1,3), (4,4), (6,5)]</tt> describes the path
--   with two segments which starts at (1,3), has a corner at (4,4), and
--   ends at (6,5). Note, however, that the vertices themselves are not
--   significant, only the distances between them. That is,
--   <tt>pathFromVertices [(0,1), (3,2), (5,3)]</tt> describes exactly the
--   same path.
pathFromVertices :: [Point] -> Path

-- | Create an open path from a list of edge displacement vectors. For
--   example, <tt>pathFromVectors [(1,1), (3,4)]</tt> describes the path
--   with two segments which first moves one unit in the positive x and y
--   directions, and then moves three units in the positive x direction and
--   four in the positive y direction.
pathFromVectors :: [Vec] -> Path

-- | Convert a path into a list of vertices, starting with the given
--   vertex.
pathToVertices :: Point -> Path -> [Point]

-- | Convert a path to a list of vectors corresponding to the edges of the
--   path.
pathToVectors :: Path -> [Vec]

-- | Concatenate two open paths into a single open path consisting of the
--   first followed by the second.
pathConcat :: Path -> Path -> Path

-- | Create a closed path (by connecting the first and last points in the
--   path).
closed :: Path -> Path

-- | Determine whether a <a>Path</a> is closed or open.
isClosed :: Path -> Bool

-- | Rotate a path by a fraction of a circle. <tt>rotPath d</tt> rotates
--   paths by an angle of <tt>d*2*pi</tt> radians. Note that creating a
--   <a>Diagram</a> from a <a>Path</a> (using <tt>straight</tt> or
--   <tt>curved</tt> or some other such function) and then applying
--   <tt>rotate</tt> to it is different than first applying <a>rotPath</a>
--   to the <a>Path</a> before making it into a <a>Diagram</a>. In the
--   latter case, the bounding box will be correct, whereas in the former
--   case, the bounding box will still correspond to the unrotated version
--   of the path.
rotPath :: Double -> Path -> Path

-- | <tt>straight</tt> creates a <a>Diagram</a> from a path, by drawing
--   straight lines along the path edges.
straight :: Path -> Diagram

-- | <tt>curved d p</tt> is a curved path which follows generally the path
--   <tt>p</tt>. The parameter <tt>d</tt> specifies the amount of corner
--   rounding. In particular, <tt>d</tt> should be a value between 0 and 1,
--   which specifies what fraction of the path segments should be rounded
--   off with bezier curves, using the path vertices as control points.
--   Thus <tt>d = 0</tt> produces the polygonal path itself, with no curved
--   segments; <tt>d = 1</tt> produces a continuously curving path tangent
--   to the midpoints of the path segments; and intermediate values of
--   <tt>d</tt> interpolate between the two. The curved path produced will
--   be everywhere differentiable as long as <tt>d &gt; 0</tt>. If the path
--   is not closed, the curve will begin and end at the first and last path
--   vertices (no rounding will take place at these vertices).
curved :: Double -> Path -> Diagram

-- | Superimpose one diagram atop another. <tt>d1 ## d2</tt> results in a
--   diagram in which <tt>d2</tt> is on top of <tt>d1</tt> (i.e.,
--   <tt>d1</tt> is drawn first, then <tt>d2</tt>).
(##) :: Diagram -> Diagram -> Diagram

-- | Create a <a>Diagram</a> as a union of subdiagrams which will not be
--   repositioned. If the subdiagrams overlap, they will appear with the
--   first <a>Diagram</a> on the bottom, and the last on top.
union :: [Diagram] -> Diagram

-- | Create a <a>Diagram</a> as a union of subdiagrams superimposed on one
--   another, aligned vertically and/or horizontally.
unionA :: HAlignment -> VAlignment -> [Diagram] -> Diagram

-- | <tt>d1 &lt;&gt; d2</tt> is a <a>Diagram</a> with <tt>d1</tt> to the
--   left of <tt>d2</tt>, aligned along their top edges.
(<>) :: Diagram -> Diagram -> Diagram

-- | <tt>d1 // d2</tt> is a <a>Diagram</a> with <tt>d1</tt> above
--   <tt>d2</tt>, aligned along their left edges.
(//) :: Diagram -> Diagram -> Diagram

-- | Lay out a list of <a>Diagram</a>s horizontally from left to right,
--   aligned along their top edges.
hcat :: [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s vertically from top to bottom,
--   aligned along their left edges.
vcat :: [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s horizontally from left to right,
--   with the given vertical alignment (<a>top</a>, <a>vcenter</a>, or
--   <a>bottom</a>).
hcatA :: VAlignment -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s vertically from top to bottom, with
--   the given horizontal alignment (<a>left</a>, <a>hcenter</a>, or
--   <a>right</a>).
vcatA :: HAlignment -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s horizontally, aligned along their
--   top edges, with a given amount of separation in between each pair.
hsep :: Double -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s vertically, aligned along their left
--   edges, with a given amount of separation in between each pair.
vsep :: Double -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s horizontally, with the given amount
--   of separation in between each pair, using the given vertical alignment
--   (<a>top</a>, <a>vcenter</a>, or <a>bottom</a>).
hsepA :: Double -> VAlignment -> [Diagram] -> Diagram

-- | Lay out a list of <a>Diagram</a>s vertically, with the given amount of
--   separation in between each pair, using the given horizontal alignment
--   (<a>left</a>, <a>hcenter</a>, or <a>right</a>).
vsepA :: Double -> HAlignment -> [Diagram] -> Diagram

-- | Distribute a list of <a>Diagram</a>s horizontally according to a
--   regular spacing, aligned along their top edges.
hdistrib :: Double -> HAlignment -> [Diagram] -> Diagram

-- | Distribute a list of <a>Diagram</a>s vertically according to a regular
--   spacing, aligned along their left edges.
vdistrib :: Double -> VAlignment -> [Diagram] -> Diagram

-- | Distribute a list of <a>Diagram</a>s horizontally according to a
--   regular spacing, with the given alignment.
hdistribA :: Double -> HAlignment -> VAlignment -> [Diagram] -> Diagram

-- | Distribute a list of <a>Diagram</a>s vertically according to a regular
--   spacing, with the given alignment.
vdistribA :: Double -> VAlignment -> HAlignment -> [Diagram] -> Diagram

-- | Create a diagram from a list of subdiagrams with explicit positions in
--   a local coordinate system. Each subdiagram will be positioned with its
--   center at the corresponding position. <tt>position</tt> is equivalent
--   to <tt>positionA hcenter vcenter</tt>.
position :: [(Point, Diagram)] -> Diagram

-- | Create a diagram from a list of subdiagrams with explicit positions in
--   a local coordinate system. The alignment options specify what part of
--   each subdiagram should be placed on the corresponding position. For
--   example, <tt>positionA left top</tt> will position the top left corner
--   of each subdiagram at the corresponding point.
positionA :: HAlignment -> VAlignment -> [(Point, Diagram)] -> Diagram

-- | Create a diagram from a list of subdiagrams and a given path, by
--   positioning the subdiagrams at successive vertices of the path. If
--   there are more diagrams than path vertices, the extra diagrams will be
--   discarded.
positionAlong :: [Diagram] -> Path -> Diagram

-- | A version of <a>positionAlong</a> with explicit alignment.
positionAlongA :: HAlignment -> VAlignment -> [Diagram] -> Path -> Diagram

-- | Align diagrams into a grid, with each item centered horizontally and
--   vertically Warning: there is currently an exponential performace
--   blowup if you nest grids. (exponential in how deep the nesting is).
grid :: [[Diagram]] -> Diagram

-- | Align diagrams into a grid with each item aligned as specified.
--   Warning: there is currently an exponential performace blowup if you
--   nest grids (exponential in how deep the nesting is).
gridA :: HAlignment -> VAlignment -> [[Diagram]] -> Diagram

-- | Align diagrams into a grid, specifying individual alignments for each
--   item. Warning: there is currently an exponential performace blowup if
--   you nest grids (exponential in how deep the nesting is).
gridAs :: [[(HAlignment, VAlignment)]] -> [[Diagram]] -> Diagram

-- | Vertical alignment.
type VAlignment = Alignment
top :: VAlignment
vcenter :: VAlignment
bottom :: VAlignment

-- | Horizontal alignment.
type HAlignment = Alignment
left :: HAlignment
hcenter :: HAlignment
right :: HAlignment

-- | Lay out a <a>Tree</a> (from <a>Data.Tree</a>) of <a>Diagram</a>s in a
--   top-down fashion. This layout is experimental; future releases of the
--   Diagrams library are planned which will be able to automatically draw
--   edges between nodes in the tree.
tree :: Double -> Double -> Tree Diagram -> Diagram

-- | Add extra padding to a diagram. <tt>pad w h d</tt> is a diagram which
--   is the same as <tt>d</tt>, but with <tt>w</tt> units added to the
--   width and <tt>h</tt> units added to the height, with <tt>d</tt>
--   centered in the available space. Thus <tt>pad w h</tt> is equivalent
--   to <tt>padA w h hcenter vcenter</tt>.
pad :: Double -> Double -> Diagram -> Diagram

-- | Add extra padding to a diagram, aligning the diagram as indicated
--   within the avilable space.
padA :: Double -> Double -> HAlignment -> VAlignment -> Diagram -> Diagram

-- | Show a rectangle denoting a diagram's bounding box, in addition to the
--   diagram itself.
showBBox :: Diagram -> Diagram

-- | Show the bounding boxes of a diagram and all its subdiagrams.
showBBoxes :: Diagram -> Diagram

-- | Create one diagram using the current size of another. The new diagram
--   is returned, the old one is discarded.
withSize :: (Double -> Double -> Diagram) -> Diagram -> Diagram

-- | Stretch a diagram by a separate scaling factor for each axis.
--   <tt>stretch w h</tt> scales by a factor of <tt>w</tt> in the x
--   direction and a factor of <tt>h</tt> in the y direction.
stretch :: Double -> Double -> Diagram -> Diagram

-- | Scale by the same scaling factor in both dimensions, so the diagram
--   retains its aspect ratio.
scale :: Double -> Diagram -> Diagram

-- | Scale a diagram along the x-axis only. <tt>scaleX s</tt> is equivalent
--   to <tt>stretch s 1</tt>.
scaleX :: Double -> Diagram -> Diagram

-- | Scale a diagram along the y-axis only. <tt>scaleY s</tt> is equivalent
--   to <tt>stretch 1 s</tt>.
scaleY :: Double -> Diagram -> Diagram

-- | Translate a diagram by the given relative offsets in the x and y
--   directions. Note that the positive x-axis is to the right, while the
--   positive y-axis points downwards.
translate :: Double -> Double -> Diagram -> Diagram

-- | Translate a diagram along the x-axis only. <tt>translateX x</tt> is
--   equivalent to <tt>translate x 0</tt>.
translateX :: Double -> Diagram -> Diagram

-- | Translate a diagram along the y-axis only. <tt>translateY y</tt> is
--   equivalent to <tt>translate 0 y</tt>.
translateY :: Double -> Diagram -> Diagram

-- | <tt>rotate f</tt> rotates a diagram clockwise by fraction <tt>f</tt>
--   of a complete revolution. <tt>rotate f</tt> is equivalent to
--   <tt>rotateR (2*pi*f)</tt>.
rotate :: Double -> Diagram -> Diagram

-- | <tt>rotateR r</tt> rotates a diagram clockwise by <tt>r</tt> radians.
rotateR :: Double -> Diagram -> Diagram

-- | Explicitly set a diagram's bounding box, by giving the coordinates of
--   the upper left and lower right corners (keeping in mind that the
--   positive y-axis points downwards). Particularly useful for applying to
--   the top-level diagram in order to only view a portion of it in the
--   rendered output.
view :: Point -> Point -> Diagram -> Diagram

-- | The <a>Color</a> type class encompasses color representations which
--   can be used by the Diagrams library; that is, every function in the
--   Diagrams library which expects a color can take any type which is an
--   instance of <a>Color</a>. Instances are provided for both the
--   <a>Colour</a> and <a>AlphaColour</a> types from the <a>Data.Colour</a>
--   library.
class Color c

-- | Draw a diagram using the given fill color. Note that the new color
--   only applies to parts of the diagram which are not otherwise colored;
--   subdiagrams which already have an explicit fill color will not be
--   affected. The default fill color is completely transparent.
fillColor :: Color c => c -> Diagram -> Diagram

-- | <a>fc</a> is provided as a convenient short synonym for
--   <a>fillColor</a>.
fc :: Color c => c -> Diagram -> Diagram

-- | Draw a diagram using the given color for lines. Note that the new
--   color only applies to parts of the diagram which are not otherwise
--   colored; subdiagrams which already have an explicit line color will
--   not be affected. The default line color is black.
lineColor :: Color c => c -> Diagram -> Diagram

-- | <a>lc</a> is provided as a convenient short synonym for
--   <a>lineColor</a>.
lc :: Color c => c -> Diagram -> Diagram

-- | Draw shape outlines and lines with the given width. Note that the line
--   width is invariant under uniform scaling, although under non-uniform
--   scaling (scaling by different amounts in the x and y axes) lines can
--   become distorted. The default line width is 1.
lineWidth :: Double -> Diagram -> Diagram

-- | <a>lw</a> is provided as a convenient short synonym for
--   <a>lineWidth</a>.
lw :: Double -> Diagram -> Diagram

-- | Set the line cap style. Valid values for <tt>LineCap</tt> are
--   <tt>LineCapButt</tt>, <tt>LineCapRound</tt>, and
--   <tt>LineCapSquare</tt>.
lineCap :: LineCap -> Diagram -> Diagram

-- | Specify line endings.
--   
--   <ul>
--   <li><i><a>LineCapButt</a></i> Start(stop) the line exactly at the
--   start(end) point.</li>
--   <li><i><a>LineCapRound</a></i> Use a round ending, the center of the
--   circle is the end point.</li>
--   <li><i><a>LineCapSquare</a></i> Use squared ending, the center of the
--   square is the end point</li>
--   </ul>
data LineCap :: *
LineCapButt :: LineCap
LineCapRound :: LineCap
LineCapSquare :: LineCap

-- | Set the line join style. Valid values for <tt>LineJoin</tt> are
--   <tt>LineJoinMiter</tt>, <tt>LineJoinRound</tt>, and
--   <tt>LineJoinBevel</tt>.
lineJoin :: LineJoin -> Diagram -> Diagram

-- | Specify how lines join.
data LineJoin :: *
LineJoinMiter :: LineJoin
LineJoinRound :: LineJoin
LineJoinBevel :: LineJoin

-- | Set the line dashing pattern.
dashing :: [Double] -> Double -> Diagram -> Diagram

-- | Change the default typeface to one named.
typeface :: String -> Diagram -> Diagram

-- | Convenience function to change the typeface.
tf :: String -> Diagram -> Diagram

-- | Render a diagram to a file.
renderAs :: OutputType -> String -> SizeSpec -> Diagram -> IO ()

-- | Render a list of diagrams as separate pages to a file.
renderPagesAs :: OutputType -> String -> SizeSpec -> [Diagram] -> IO ()

-- | The supported output file types for rendered diagrams.
data OutputType
PNG :: OutputType
PS :: OutputType
PDF :: OutputType
SVG :: OutputType

-- | A specification of the size of a rendered <a>Diagram</a>.
data SizeSpec

-- | an explicit width; the height is determined automatically
Width :: Double -> SizeSpec

-- | an explicit height; the width is determined automatically
Height :: Double -> SizeSpec

-- | determine the size automatically (do not scale)
Auto :: SizeSpec

-- | <tt>renderOverPNG infile outfile d</tt> reads the PNG <tt>infile</tt>
--   and renders <tt>d</tt> over this, saving the output as a PNG to
--   <tt>outfile</tt>.
renderOverPNG :: FilePath -> FilePath -> Diagram -> IO ()
