-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HMAC-Based and Time-Based One-Time Passwords
--   
@package one-time-password
@version 1.0.0.1


-- | Implements HMAC-Based One-Time Password Algorithm as defined in RFC
--   4226 and Time-Based One-Time Password Algorithm as defined in RFC
--   6238.
module Data.OTP

-- | Compute HOTP using secret key and counter value.
--   
--   <pre>
--   &gt;&gt;&gt; hotp SHA1 "1234" 100 6
--   317569
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotp SHA512 "1234" 100 6
--   134131
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotp SHA512 "1234" 100 8
--   55134131
--   </pre>
hotp :: HashAlgorithm a => a -> ByteString -> Word64 -> Word -> Word32

-- | Check presented password against a valid range.
--   
--   <pre>
--   &gt;&gt;&gt; hotp SHA1 "1234" 10 6
--   50897
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotpCheck SHA1 "1234" (0,0) 10 6 50897
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotpCheck SHA1 "1234" (0,0) 9 6 50897
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotpCheck SHA1 "1234" (0,1) 9 6 50897
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotpCheck SHA1 "1234" (1,0) 11 6 50897
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotpCheck SHA1 "1234" (2,2) 8 6 50897
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotpCheck SHA1 "1234" (2,2) 7 6 50897
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotpCheck SHA1 "1234" (2,2) 12 6 50897
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hotpCheck SHA1 "1234" (2,2) 13 6 50897
--   False
--   </pre>
hotpCheck :: HashAlgorithm a => a -> ByteString -> (Word64, Word64) -> Word64 -> Word -> Word32 -> Bool

-- | Compute a TOTP using secret key and time.
--   
--   <pre>
--   &gt;&gt;&gt; totp SHA1 "1234" (read "2010-10-10 00:01:00 UTC") 30 6
--   388892
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totp SHA1 "1234" (read "2010-10-10 00:01:00 UTC") 30 8
--   43388892
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totp SHA1 "1234" (read "2010-10-10 00:01:15 UTC") 30 8
--   43388892
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totp SHA1 "1234" (read "2010-10-10 00:01:31 UTC") 30 8
--   39110359
--   </pre>
totp :: HashAlgorithm a => a -> ByteString -> UTCTime -> Word64 -> Word -> Word32

-- | Check presented password against time periods.
--   
--   <pre>
--   &gt;&gt;&gt; totp SHA1 "1234" (read "2010-10-10 00:00:00 UTC") 30 6
--   778374
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCheck SHA1 "1234" (0, 0) (read "2010-10-10 00:00:00 UTC") 30 6 778374
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCheck SHA1 "1234" (0, 0) (read "2010-10-10 00:00:30 UTC") 30 6 778374
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCheck SHA1 "1234" (1, 0) (read "2010-10-10 00:00:30 UTC") 30 6 778374
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCheck SHA1 "1234" (1, 0) (read "2010-10-10 00:01:00 UTC") 30 6 778374
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCheck SHA1 "1234" (2, 0) (read "2010-10-10 00:01:00 UTC") 30 6 778374
--   True
--   </pre>
totpCheck :: HashAlgorithm a => a -> ByteString -> (Word64, Word64) -> UTCTime -> Word64 -> Word -> Word32 -> Bool

-- | Calculate HOTP counter using time. Starting time (T0 according to
--   RFC6238) is 0 (begining of UNIX epoch)
--   
--   <pre>
--   &gt;&gt;&gt; totpCounter (read "2010-10-10 00:00:00 UTC") 30
--   42888960
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCounter (read "2010-10-10 00:00:30 UTC") 30
--   42888961
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCounter (read "2010-10-10 00:01:00 UTC") 30
--   42888962
--   </pre>
totpCounter :: UTCTime -> Word64 -> Word64

-- | Make a sequence of acceptable counters, protected from arithmetic
--   overflow. Maximum range is limited to 1000 due to huge counter ranges
--   being insecure.
--   
--   <pre>
--   &gt;&gt;&gt; counterRange (0, 0) 9000
--   [9000]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; counterRange (1, 0) 9000
--   [8999,9000]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length $ counterRange (5000, 0) 9000
--   501
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length $ counterRange (5000, 5000) 9000
--   1000
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; counterRange (2, 2) maxBound
--   [18446744073709551613,18446744073709551614,18446744073709551615]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; counterRange (2, 2) minBound
--   [0,1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; counterRange (2, 2) (maxBound `div` 2)
--   [9223372036854775805,9223372036854775806,9223372036854775807,9223372036854775808,9223372036854775809]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; counterRange (5, 5) 9000
--   [8995,8996,8997,8998,8999,9000,9001,9002,9003,9004,9005]
--   </pre>
--   
--   RFC recommends avoiding excessively large values for counter ranges.
counterRange :: (Word64, Word64) -> Word64 -> [Word64]

-- | Make a sequence of acceptable periods.
--   
--   <pre>
--   &gt;&gt;&gt; totpCounterRange (0, 0) (read "2010-10-10 00:01:00 UTC") 30
--   [42888962]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCounterRange (2, 0) (read "2010-10-10 00:01:00 UTC") 30
--   [42888960,42888961,42888962]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCounterRange (0, 2) (read "2010-10-10 00:01:00 UTC") 30
--   [42888962,42888963,42888964]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; totpCounterRange (2, 2) (read "2010-10-10 00:01:00 UTC") 30
--   [42888960,42888961,42888962,42888963,42888964]
--   </pre>
totpCounterRange :: (Word64, Word64) -> UTCTime -> Word64 -> [Word64]
