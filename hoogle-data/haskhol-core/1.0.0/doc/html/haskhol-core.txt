-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The core logical system of HaskHOL, an EDSL for HOL theorem
proving.
--   
--   More details can be found at the following page: <a>haskhol.org</a>.
@package haskhol-core
@version 1.0.0


-- | This module is a re-export of the th-lift library originally written
--   by Ian Lynagh and maintained by Mathieu Boespflug. A very minor change
--   was made by Evan Austin in order to facilitate derivation of lift
--   instances for quantified type constructors.
--   
--   The decision to include this source as part of the HaskHOL system,
--   rather than import the original library, was made to facilitate the
--   above change and to sever HaskHOL's only dependence on a non-Haskell
--   Platform library.
module HaskHOL.Core.Lib.Lift

-- | Obtain Info values through a custom reification function. This is
--   useful when generating instances for datatypes that have not yet been
--   declared.
deriveLift' :: Info -> Q [Dec]

-- | Derive Lift instances for the given datatype.
deriveLift :: Name -> Q [Dec]

-- | Derive Lift instances for many datatypes.
deriveLiftMany :: [Name] -> Q [Dec]
instance [overlap ok] Lift String
instance [overlap ok] Lift Rational
instance [overlap ok] Lift ()
instance [overlap ok] Lift NameSpace
instance [overlap ok] Lift NameFlavour
instance [overlap ok] Lift ModName
instance [overlap ok] Lift PkgName
instance [overlap ok] Lift OccName
instance [overlap ok] Lift Name


-- | This module defines or re-exports common utility functions, type
--   classes, and auxilliary data types used in HaskHOL. The following
--   conventions hold true: * Where possible, we favor re-exporting common
--   functions rather than redefining them. * We favor re-exporting
--   individual functions rather entire modules to reduce the number of
--   items in our utility library. * We default to the names of functions
--   commonly used by Haskell libraries, however, if there's a different
--   name for a function in HOL systems we include an alias for it. For
--   example, <a>iComb</a> and <a>id</a>.
--   
--   Note that none of the functions in this module depend on data types
--   introduced by HaskHOL. Utility functions that do have such a
--   dependence are found in the <a>HaskHOL.Core.Basics</a> module.
module HaskHOL.Core.Lib

-- | The I combinator. An alias for <a>id</a>.
iComb :: a -> a

-- | The K combinator. An alias for <a>const</a>.
kComb :: a -> b -> a

-- | The C combinator. An alias for <a>flip</a>.
cComb :: (a -> b -> c) -> b -> a -> c

-- | The W combinator. Takes a function of arity 2 and applies a single
--   argument to it twice.
wComb :: (a -> a -> b) -> a -> b

-- | The FF combinator. An alias for the arrow combinator <a>***</a>.
ffComb :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)

-- | The monadic version of the FF combinator. An alias for the arrow
--   combinator <a>***</a> lifted for <a>Kleisli</a> arrows.
ffCombM :: Monad m => (a -> m c) -> (b -> m d) -> (a, b) -> m (c, d)

-- | Promotes a function to a monad, but only for its first argument, i.e.
--   
--   <pre>
--   liftM1 f a b === flip f b =&lt;&lt; a
--   </pre>
liftM1 :: Monad m => (a -> b -> m c) -> m a -> b -> m c

-- | Swaps the order of a pair. A re-export of <a>swap</a>.
swap :: (a, b) -> (b, a)

-- | Applies a function to both elements of a pair using the <a>***</a>
--   operator.
pairMap :: (a -> b) -> (a, a) -> (b, b)

-- | The monadic version of <a>pairMap</a>.
pairMapM :: Monad m => (a -> m b) -> (a, a) -> m (b, b)

-- | Applies a function only to the first element of a pair. A re-export of
--   <a>first</a>.
first :: (a -> c) -> (a, b) -> (c, b)

-- | A monadic version of <a>first</a> lifted for <a>Kleisli</a> arrows.
firstM :: Monad m => (a -> m c) -> (a, b) -> m (c, b)

-- | Applies a function only to the second element of a pair. A re-export
--   of <a>second</a>.
second :: (b -> c) -> (a, b) -> (a, c)

-- | A monadic version of <a>second</a> lifted for <a>Kleisli</a> arrows.
secondM :: Monad m => (b -> m c) -> (a, b) -> m (a, c)

-- | A safe version of <a>head</a>. Fails with <a>Nothing</a> when trying
--   to take the head of an empty list.
tryHead :: [a] -> Maybe a

-- | A safe version of <a>tail</a>. Fails with <a>Nothing</a> when trying
--   to take the tail of an empty list.
tryTail :: [a] -> Maybe [a]

-- | A safe version of <a>init</a>. Fails with <a>Nothing</a> when trying
--   to drop the last element of an empty list.
tryInit :: [a] -> Maybe [a]

-- | An alias to <a>tryInit</a> for HOL users more familiar with this name.
butLast :: [a] -> Maybe [a]

-- | A safe version of <a>last</a>. Fails with <a>Nothing</a> when trying
--   to take the last element of an empty list.
tryLast :: [a] -> Maybe a

-- | A safe version of <a>index</a>. Fails with <a>Nothing</a> if the
--   selected index does not exist.
tryIndex :: [a] -> Int -> Maybe a

-- | An alias to <a>tryIndex</a> for HOL users more familiar with this
--   name. Note that the order of the arguments is flipped.
el :: Int -> [a] -> Maybe a

-- | An alias to <a>reverse</a> for HOL users more familiar with this name.
rev :: [a] -> [a]

-- | An alias to <a>lookup</a> for HOL users more familiar with this name.
assoc :: Eq a => a -> [(a, b)] -> Maybe b

-- | A version of <a>lookup</a> where the search is performed against the
--   second element of the pair instead of the first. Still fails with
--   <a>Nothing</a> if the desired value is not found.
revLookup :: Eq a => a -> [(b, a)] -> Maybe b

-- | An alias to <a>revLookup</a> for HOL users who are more familiar with
--   this name.
revAssoc :: Eq a => a -> [(b, a)] -> Maybe b

-- | An alias to <a>lookupd</a> for HOL users who are more familiar with
--   this name.
assocd :: Eq a => a -> [(a, b)] -> b -> b

-- | A version of <a>lookup</a> that defaults to a provided value rather
--   than fail.
lookupd :: Eq a => a -> [(a, b)] -> b -> b

-- | A version of <a>revLookup</a> that defaults to a provided value rather
--   than fail.
revLookupd :: Eq a => a -> [(b, a)] -> b -> b

-- | An alias to <a>revLookupd</a> for HOL users who are more familiar with
--   this name.
revAssocd :: Eq a => a -> [(b, a)] -> b -> b

-- | Returns a boolean value indicating whether a monadic computation
--   succeeds or fails. The <a>&lt;|&gt;</a> operator is used for
--   branching.
can :: (Alternative m, Monad m) => (a -> m b) -> a -> m Bool

-- | The opposite of <a>can</a>. Functionally equivalent to
--   
--   <pre>
--   \ f -&gt; liftM not . can f
--   </pre>
canNot :: (Alternative m, Monad m) => (a -> m b) -> a -> m Bool

-- | Checks if a predicate succeeds for a provided value, returning that
--   value guarded by a <a>Maybe</a> type if so.
check :: (a -> Bool) -> a -> Maybe a

-- | Takes a default error value to convert a <a>Maybe</a> type to an
--   <a>Either</a> type.
note :: a -> Maybe b -> Either a b

-- | Suppresses the error value of an <a>Either</a> type to convert it to a
--   <a>Maybe</a> type.
hush :: Either a b -> Maybe b

-- | An analogue of <a>fromJust</a> for the <a>Either</a> type. Fails with
--   <a>error</a> when provided a <a>Left</a> value, so take care only to
--   use it in cases where you know you are working with a <a>Right</a>
--   value or are catching exceptions.
fromRight :: Either err a -> a

-- | A version of <a>fromRight</a> that maps <a>Left</a> values to
--   <a>mzero</a> rather than failing.
fromRightM :: MonadPlus m => Either err a -> m a

-- | A version of <a>fromJust</a> that maps <a>Nothing</a> values to
--   <a>mzero</a> rather than failing.
fromJustM :: MonadPlus m => Maybe a -> m a

-- | The <a>LiftOption</a> class provides an infix operator to more cleanly
--   apply the <a>fromJustM</a> and <a>fromRightM</a> methods to a value
--   that will be passed to a monadic computation.
class Monad m => LiftOption l m where l #<< r = l =<< liftO r <#< l r x = l =<< liftO (r x) l <#> r = liftM1 l $ liftO r
liftO :: LiftOption l m => l a -> m a
(#<<) :: LiftOption l m => (a -> m b) -> l a -> m b
(<#<) :: LiftOption l m => (b -> m c) -> (a -> l b) -> a -> m c
(<#>) :: LiftOption l m => (a -> b -> m c) -> l a -> b -> m c

-- | The <a>Note</a> class provides an ad hoc way of tagging an error case
--   with a string.
class (Alternative m, Monad m) => Note m where failWhen m str = do { cond <- m; when cond empty <?> str }
(<?>) :: Note m => m a -> String -> m a
failWhen :: Note m => m Bool -> String -> m ()

-- | Repeatedly applies a function to an argument <tt>n</tt> times. Rather
--   than fail, the original argument is returned when <tt>n&lt;=0</tt>.
funpow :: Int -> (a -> a) -> a -> a

-- | The monadic version of <a>funpow</a>.
funpowM :: Monad m => Int -> (a -> m a) -> a -> m a

-- | Repeatedly applies a monadic computation to an argument until there is
--   a failure. The <a>&lt;|&gt;</a> operator is used for branching.
repeatM :: (Alternative m, Monad m) => (a -> m a) -> a -> m a

-- | A safe version of a list map for functions of arity 2. Fails with
--   <a>Nothing</a> if the two lists are of different lengths.
map2 :: (a -> b -> c) -> [a] -> [b] -> Maybe [c]

-- | The monadic version of <a>map2</a>. Fails with <a>mzero</a> if the two
--   lists are of different lengths.
map2M :: (Monad m, MonadPlus m) => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | Map a monadic function over a list, ignoring the results. A re-export
--   of <a>mapM_</a>.
doList :: Monad m => (a -> m b) -> [a] -> m ()

-- | Produces a list containing the results of applying a function to all
--   possible combinations of arguments from two lists. Rather than failing
--   if the lists are of different lengths, iteration is shortcutted to end
--   when the left most list is null.
allpairs :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | An alias to <a>foldr</a> for HOL users more familiar with this name.
--   Note that the order of the list and base case arguments is flipped.
itlist :: (a -> b -> b) -> [a] -> b -> b

-- | The monadic version of <a>itlist</a>.
itlistM :: (Foldable t, Monad m) => (a -> b -> m b) -> t a -> b -> m b

-- | The monadic version of <a>foldr</a>. A re-export of <a>foldrM</a>.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | An alias to <a>foldl</a> for HOL users more familiar with this name.
--   Note that the order of the list and base case arguments is flipped, as
--   is the order of the arguments to the function.
revItlist :: (a -> b -> b) -> [a] -> b -> b

-- | The monadic version of <a>foldl</a>. A re-export of <a>foldlM</a>.
foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a

-- | A safe version of <a>foldr1</a>. Fails with <a>Nothing</a> if an empty
--   list is provided as an argument.
tryFoldr1 :: (a -> a -> a) -> [a] -> Maybe a

-- | An alias to <a>tryFoldr1</a> for HOL users more familiar with this
--   name.
endItlist :: (a -> a -> a) -> [a] -> Maybe a

-- | The monadic version of <a>foldr1</a>. Fails with <a>mzero</a> if an
--   empty list is provided as an argument.
foldr1M :: (Monad m, MonadPlus m) => (a -> a -> m a) -> [a] -> m a

-- | A safe version of a right, list fold for functions of arity 2. Fails
--   with <a>Nothing</a> if the two lists are of different lengths.
foldr2 :: (a -> b -> c -> c) -> c -> [a] -> [b] -> Maybe c

-- | An alias to <a>foldr2</a> for HOL users more familiar with this name.
--   Note that the order of the two list arguments and the base case
--   argument is flipped.
itlist2 :: (a -> b -> c -> c) -> [a] -> [b] -> c -> Maybe c

-- | The monadic version of <a>foldr2</a>. Fails with <a>mzero</a> if the
--   two lists are of different lengths.
foldr2M :: (Monad m, MonadPlus m) => (a -> b -> c -> m c) -> c -> [a] -> [b] -> m c

-- | A safe version of a left, list fold for functions of arity 2. Fails
--   with <a>Nothing</a> if the two lists are of different lengths.
foldl2 :: (c -> a -> b -> c) -> c -> [a] -> [b] -> Maybe c

-- | An alias to <a>foldl2</a> for HOL users more familiar with this name.
--   Note that the order of the two list arguments and base case argument
--   is flipped, as is the order of the arguments to the provided function.
revItlist2 :: (a -> b -> c -> c) -> [a] -> [b] -> c -> Maybe c

-- | The monadic version of <a>foldl2</a>. Fails with <a>mzero</a> if the
--   two lists are of different lengths.
foldl2M :: (Monad m, MonadPlus m) => (c -> a -> b -> m c) -> c -> [a] -> [b] -> m c

-- | Sorts a list using a partitioning predicate to build an implied
--   ordering. If <tt>p</tt> is the predicate and <tt>x `p` y</tt> and
--   <tt>not (y `p` x)</tt> are true then <tt>x</tt> will be in front of
--   <tt>y</tt> in the sorted list.
sort :: Eq a => (a -> a -> Bool) -> [a] -> [a]

-- | A more traditional sort using an <a>Ordering</a> relationship between
--   elements. A re-export of <a>sortBy</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | Merges two lists using a partitioning predicate to build an implied
--   ordering. See <a>sort</a> for more information on how the predicate
--   affects the order of the resultant list.
merge :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | Sorts a list using a partitioning predicate to build an implied
--   ordering; uses <a>merge</a> internally. See <a>sort</a> for more
--   information on how the predicate affects the order of the resultant
--   list.
mergesort :: (a -> a -> Bool) -> [a] -> [a]

-- | Repeatedly applies a binary destructor function to a term until
--   failure.
--   
--   Application is forward, or left-associative, such that for a term of
--   the form <tt>x1 `f` x2 `f` b</tt> calling this function with a
--   destructor for <tt>f</tt> will produce the result <tt>([x1, x2],
--   b)</tt>.
splitList :: (b -> Maybe (a, b)) -> b -> ([a], b)

-- | The monadic version of <a>splitList</a>.
splitListM :: (Alternative m, Monad m) => (b -> m (a, b)) -> b -> m ([a], b)

-- | Repeatedly applies a binary destructor function to a term until
--   failure.
--   
--   Application is reverse, or right-associative, such that for a term of
--   the form <tt>x1 `f` x2 `f` b</tt> calling this function with a
--   destructor for <tt>f</tt> will produce the result <tt>(f, [x1, x2 `f`
--   b])</tt>.
revSplitList :: (a -> Maybe (a, a)) -> a -> (a, [a])

-- | The monadic version of <a>revSplitList</a>.
revSplitListM :: (Alternative m, Monad m) => (b -> m (b, b)) -> b -> m (b, [b])

-- | Repeatedly applies a binary destructor function to a term for every
--   element in a provided list.
--   
--   Application is reverse, or right-associative, such that for a term of
--   the form <tt>f x1 (f x2 ...(f xn b))</tt> calling this function with a
--   destructor for <tt>f</tt> and a list <tt>l</tt> will produce the
--   result <tt>([x1 .. xk], f x(k+1) ...(f xn b))</tt> where <tt>k</tt> is
--   the length of list <tt>l</tt>.
nsplit :: (a -> Maybe (a, a)) -> [b] -> a -> Maybe ([a], a)

-- | The monadic version of <a>nsplit</a>.
nsplitM :: Monad m => (b -> m (b, b)) -> [c] -> b -> m ([b], b)

-- | Repeatedly applies a binary destructor function to a term until
--   failure.
--   
--   Application is forward, or left-associative, such that for a term of
--   the form <tt>x1 `f` x2 `f` x3</tt> calling this function with a
--   destructor for <tt>f</tt> will produce the result <tt>[x1, x2,
--   x3]</tt>.
stripList :: (a -> Maybe (a, a)) -> a -> [a]

-- | The monadic version of <a>stripList</a>.
stripListM :: (Alternative m, Monad m) => (a -> m (a, a)) -> a -> m [a]

-- | An alias to <a>all</a> for HOL users who are more familiar with this
--   name.
forall :: (a -> Bool) -> [a] -> Bool

-- | A version of <a>all</a> for predicates of arity 2. Iterates down two
--   lists simultaneously with <a>map2</a>, using <a>and</a> to combine the
--   results.
forall2 :: (a -> b -> Bool) -> [a] -> [b] -> Maybe Bool

-- | An alias to <a>any</a> for HOL users who are more familiar with this
--   name.
exists :: (a -> Bool) -> [a] -> Bool

-- | Separates a list of elements using a predicate. A re-export of
--   <a>partition</a>.
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | An alias to <a>mapMaybe</a> for HOL users more familiar with this
--   name.
mapFilter :: (a -> Maybe b) -> [a] -> [b]

-- | The monadic version of <a>mapFilter</a>. The '(<a>|</a>)' operator is
--   used for branching.
mapFilterM :: (Alternative m, Monad m) => (a -> m b) -> [a] -> m [b]

-- | A re-export of <a>find</a>.
find :: (a -> Bool) -> [a] -> Maybe a

-- | The monadic version of <a>find</a>. Fails if the monadic predicate
--   does. Also fails with <a>mzero</a> if an empty list is provided.
findM :: (Monad m, MonadPlus m) => (a -> m Bool) -> [a] -> m a

-- | An alternative monadic version of <a>find</a> where the predicate is a
--   monadic computation not necessarily of a boolean return type. Returns
--   the result of the first successful application of the predicate to an
--   element of the list. Fails with <a>mzero</a> if called on an empty
--   list.
--   
--   Note that <a>mplus</a> is used for branching instead of
--   <a>&lt;|&gt;</a> to minimize the constraint type; for the vast
--   majority of monads these two functions should be identical anyway.
tryFind :: (Monad m, MonadPlus m) => (a -> m b) -> [a] -> m b

-- | An alias to <a>concat</a> for HOL users who are more familiar with
--   this name.
flat :: [[a]] -> [a]

-- | Drops elements from the end of a list while a predicate is true. A
--   re-export of <a>dropWhileEnd</a>.
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | Separates the first element of a list that satisfies a predicate.
--   Fails with <a>Nothing</a> if no such element is found.
remove :: (a -> Bool) -> [a] -> Maybe (a, [a])

-- | A safe version of <a>splitAt</a>. Fails with <a>Nothing</a> if a split
--   is attempted at an index that doesn't exist.
trySplitAt :: Int -> [a] -> Maybe ([a], [a])

-- | An alias to <a>trySplitAt</a> for HOL users more familiar with this
--   name
chopList :: Int -> [a] -> Maybe ([a], [a])

-- | Returns the first index where an element appears in list. Fails with
--   <a>Nothing</a> if no such element is found. A re-export of
--   <a>elemIndex</a>.
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | An alias to <a>elemIndex</a> for HOL users more familiar with this
--   name.
index :: Eq a => a -> [a] -> Maybe Int

-- | Drops the given prefix from a list. Fails with <a>Nothing</a> if there
--   is no such prefix. A re-export of <a>stripPrefix</a>.
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | Removes adjacent, equal elements from a list.
uniq :: Eq a => [a] -> [a]

-- | Partitions a list into a list of lists matching the structure of the
--   first argument. For example: <tt>shareOut [[1, 2], [3], [4, 5]]
--   "abcde" === ["ab", "c", "de"]</tt>
shareOut :: [[a]] -> [b] -> Maybe [[b]]

-- | An alias to <a>elem</a> for HOL users who are more familiar with this
--   name.
mem :: Eq a => a -> [a] -> Bool

-- | Inserts an item into a list if it would be a unique element.
--   
--   Important note: This insert is unordered, unlike the <a>insert</a> in
--   the <a>Data.List</a> module.
insert :: Eq a => a -> [a] -> [a]

-- | Inserts, or updates, a key value pair in an association list.
--   
--   Note that this insert is unordered, but uniqueness preserving.
insertMap :: Eq a => a -> b -> [(a, b)] -> [(a, b)]

-- | Unions two list maintaining uniqueness of elements.
--   
--   Important note: This union is unordered, unlike the <a>union</a> in
--   the <a>Data.List</a> module.
union :: Eq a => [a] -> [a] -> [a]

-- | Unions a list of lists using <a>union</a>.
unions :: Eq a => [[a]] -> [a]

-- | Finds the intersection of two lists. A re-export of <a>intersect</a>.
intersect :: Eq a => [a] -> [a] -> [a]

-- | Removes an item from a list. A re-export of <a>delete</a>.
delete :: Eq a => a -> [a] -> [a]

-- | Subtracts one list from the other. A re-export of <a>\\</a>.
(\\) :: Eq a => [a] -> [a] -> [a]

-- | Tests if the first list is a subset of the second.
subset :: Eq a => [a] -> [a] -> Bool

-- | A test for set equality using <a>subset</a>.
setEq :: Eq a => [a] -> [a] -> Bool

-- | An alias to <a>nub</a> for HOL users more familiar with this name.
setify :: Eq a => [a] -> [a]

-- | Converts a list to a set by removing duplicates. A re-export of
--   <a>nub</a>.
nub :: Eq a => [a] -> [a]

-- | A version of <a>mem</a> where the membership test is an explicit
--   predicate, rather than a strict equality test.
mem' :: (a -> a -> Bool) -> a -> [a] -> Bool

-- | A version of <a>insert</a> where the uniqueness test is an explicit
--   predicate, rather than a strict equality test.
insert' :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | A version of <a>union</a> where the uniqueness test is an explicit
--   predicate, rather than a strict equality test.
union' :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | A version of <a>unions</a> where the uniqueness test is an explicit
--   predicate, rather than a strict equality test.
unions' :: (a -> a -> Bool) -> [[a]] -> [a]

-- | A version of <a>subtract</a> where the uniqueness test is an explicit
--   predicate, rather than a strict equality test.
subtract' :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | Groups neighbors in a list together based on a predicate. A re-export
--   of <a>groupBy</a>.
group' :: (a -> a -> Bool) -> [a] -> [[a]]

-- | A version of <a>uniq</a> that eliminates elements based on a provided
--   predicate.
uniq' :: Eq a => (a -> a -> Bool) -> [a] -> [a]

-- | A version of <a>setify</a> that eliminates elements based on a
--   provided predicate.
setify' :: Eq a => (a -> a -> Bool) -> (a -> a -> Bool) -> [a] -> [a]

-- | <pre>
--   0 :: Integer
--   </pre>
num0 :: Integer

-- | <pre>
--   1 :: Integer
--   </pre>
num1 :: Integer

-- | <pre>
--   2 :: Integer
--   </pre>
num2 :: Integer

-- | <pre>
--   10 :: Integer
--   </pre>
num10 :: Integer

-- | <pre>
--   x ^ (2 :: Integer)
--   </pre>
pow2 :: Integer -> Integer

-- | <pre>
--   x ^ (10 :: Integer)
--   </pre>
pow10 :: Integer -> Integer

-- | Converts a real number to a rational representation. An alias to
--   <a>toRational</a> for HOL users more familiar with this name.
numdom :: Real a => a -> Rational

-- | Returns the numerator of a rational number. A re-export of
--   <a>numerator</a>.
numerator :: Rational -> Integer

-- | Returns the denominator of a rational number. A re-export of
--   <a>denominator</a>.
denominator :: Rational -> Integer

-- | Finds the least common denominator between two numbers. An alias to
--   <a>gcd</a> for HOL users more familiar with this name.
gcdNum :: Integer -> Integer -> Integer

-- | Finds the least common multiplier between two numbers. An alias to
--   <a>lcm</a> for HOL users more familiar with this name.
lcmNum :: Integer -> Integer -> Integer

-- | Converts a string representation of a number to an appropriate
--   instance of the <a>Num</a> class. Fails with <a>Nothing</a> if the
--   conversion cannot be performed.
--   
--   Note: The following prefixes are valid:
--   
--   <ul>
--   <li><tt>0x</tt> - number read as a hexidecimal value</li>
--   <li><tt>0b</tt> - number read as a binary value</li>
--   <li>Any other prefix causes the number to be read as a decimal
--   value</li>
--   </ul>
numOfString :: (Eq a, Num a) => String -> Maybe a

-- | The <a>Lang</a> class defines common language operations and
--   combinators not based on sequencing.
class Lang a
_FAIL :: Lang a => String -> a
_NO :: Lang a => a
_ALL :: Lang a => a
_ORELSE :: Lang a => a -> a -> a
_FIRST :: Lang a => [a] -> a
_CHANGED :: Lang a => a -> a
_TRY :: Lang a => a -> a

-- | The <a>LangSeq</a> class defines common language operations and
--   combinators based on sequencing. See the note at the top of this
--   section for more details as to why these are separated on their own.
class LangSeq a
_THEN :: LangSeq a => a -> a -> a
_REPEAT :: LangSeq a => a -> a
_EVERY :: LangSeq a => [a] -> a
instance Lift Assoc
instance Eq Assoc
instance Note (Either String)
instance MonadPlus m => LiftOption (Either a) m
instance MonadPlus m => LiftOption Maybe m


-- | This module exports a safe view of HOL types for HaskHOL. It also
--   defines the primitive functions related to types. For clarity, these
--   functions have been seperated based on their influential system: HOL
--   Light, Stateless HOL, and HOL2P.
--   
--   Note that, per the stateless approach, any stateful, but still
--   primitive, functions related to types have been relocated to the
--   <a>HaskHOL.Core.State</a> module.
module HaskHOL.Core.Kernel.Types

-- | The <a>HOLType</a> data type defines the internal constructors for HOL
--   types in HaskHOL. For more details, see the documentation for its view
--   pattern data type, <a>HOLTypeView</a>.
data HOLType

-- | The view pattern data type for HOL types.
data HOLTypeView

-- | A type variable consisting of a constraint flag and name.
TyVar :: Bool -> String -> HOLTypeView

-- | A type application consisting of a type operator and a list of type
--   arguments. See <a>TypeOp</a> for more details.
TyApp :: TypeOp -> [HOLType] -> HOLTypeView

-- | A universal type consisting of a bound type and a body type. Note that
--   the bound type must be a small, type variable.
UType :: HOLType -> HOLType -> HOLTypeView

-- | The data type for type operators, <a>TypeOp</a>, is a mashing together
--   of the representation of type operators from both both HOL2P and
--   Stateless HOL. For more information regarding construction of the
--   different operators, see the documentation of the following functions:
--   <tt>mkTypeOpVar</tt>, <tt>newPrimTypeOp</tt>,
--   <tt>newDefinedTypeOp</tt>
data TypeOp

-- | Type synonym for the commonly used, list-based, type environment.
type HOLTypeEnv = [(HOLType, HOLType)]

-- | Type synonym for the commonly used triplet of substitution
--   environments. See <tt>TypeSubst</tt> for more information.
type SubstTrip = (HOLTypeEnv, [(TypeOp, HOLType)], [(TypeOp, TypeOp)])

-- | Provides an ordering for two types modulo alpha-equivalence.
tyAlphaOrder :: HOLType -> HOLType -> Ordering

-- | Tests if two types are alpha-equivalent.
tyAConv :: HOLType -> HOLType -> Bool

-- | Predicate for type variables.
isVarType :: HOLType -> Bool

-- | Predicate for type applications
isType :: HOLType -> Bool

-- | Constructs a type variable of a given name. Note that the resultant
--   type variable is unconstrained.
mkVarType :: String -> HOLType

-- | Destructs a type variable, returning its name. Fails with
--   <a>Nothing</a> if called on a non-variable type.
destVarType :: HOLType -> Maybe String

-- | Destructs a type application, returning its operator name and its list
--   of type arguments. Fails with <a>Nothing</a> if called on a type that
--   is not an application.
destType :: HOLType -> Maybe (TypeOp, [HOLType])

-- | Returns the list of all free, type variables in a type, not including
--   type operator variables.
tyVars :: HOLType -> [HOLType]

-- | Returns the list of all type variables in a list of types, not
--   including type operator variables.
catTyVars :: [HOLType] -> [HOLType]

-- | The <tt>TypeSubst</tt> class provides the framework for type
--   substitution in HaskHOL. Note that, with the introduction of universal
--   types and type operator variables, we now have three kinds of
--   substitution to handle:
--   
--   <ul>
--   <li>Substitution of types for type variables, satisfying type variable
--   constraints.</li>
--   <li>Instantiation of type operators with universal types.</li>
--   <li>Substitution of type operators for type operator variables.</li>
--   </ul>
--   
--   Rather than have three separate functions exposed to the user, we
--   elected to provide a polymorphic type substitution function that will
--   accept any well-formed, homogenous substitution environment.
--   
--   Note that the internals of <tt>TypeSubst</tt> are hidden to prevent
--   unsound re-definition. The relevant type substitution function is
--   re-exported as <a>typeSubst</a>. We also provide a function,
--   <a>typeSubstFull</a>, that accepts a triplet of all possible
--   substitution environments that can be conveniently used in combination
--   with <tt>typeMatch</tt>.
--   
--   See the ITP2013 paper, <a>Stateless Higher-Order Logic with Quantified
--   Types,</a> for more details.
class TypeSubst a b

-- | Re-exports the internal type substitution function of the
--   <a>TypeSubst</a> class to prevent unsound re-definition. Invalid
--   substitution pairs are pruned from the environment such that
--   substitution never fails.
--   
--   Note that the order of elements in a substitution pair follows the
--   convention of most Haskell libraries, rather than the traditional HOL
--   convention:
--   
--   <ul>
--   <li>The second element is substituted for the first, i.e. the
--   substitution pair <tt>(tyA, tyBool)</tt> indicates that the boolean
--   type should be substituted for the type variable <tt>A</tt>.</li>
--   </ul>
typeSubst :: TypeSubst a b => [(a, b)] -> HOLType -> HOLType

-- | A version of <a>typeSubst</a> that accepts a triplet of type
--   substitution environments.
typeSubstFull :: SubstTrip -> HOLType -> HOLType

-- | Alias to the primitive boolean type.
tyBool :: HOLType

-- | Alias to the unconstrained type variable <tt>A</tt>.
tyA :: HOLType

-- | Alias to the unconstrained type variable <tt>B</tt>.
tyB :: HOLType

-- | Specialized version of <a>destType</a> that returns the domain and
--   range of a function type. Fails with <a>Nothing</a> if the type to be
--   destructed isn't a primitive function type.
destFunTy :: HOLType -> Maybe (HOLType, HOLType)

-- | Returns the type of term. Fails with a special type,
--   <tt>tyBottom</tt>, if the type is poorly constructed; this keeps the
--   function total without requiring the use of an additional guard type
--   like <a>Maybe</a>.
--   
--   In practice, this type will never be seen provided the kernel is not
--   modified to expose the internal constructors for terms.
typeOf :: HOLTerm -> HOLType

-- | Predicate for type operator variables.
isTypeOpVar :: TypeOp -> Bool

-- | Constructs a primitive type operator of a given name and arity.
--   Primitive type operators are used to represent constant, but
--   undefined, types.
newPrimTypeOp :: String -> Int -> TypeOp

-- | Constructs a type operator variable of a given name. Note that type
--   operator arities are not stored, only inferred from the context where
--   the operator is used.
--   
--   The parser makes an attempt to guarantee that all instances of a type
--   operator in a term have the same arity. The same protection is not
--   provided for terms that are manually constructed.
mkTypeOpVar :: String -> TypeOp

-- | Destructs a type operator, returning its name and arity. Note that we
--   use -1 to indicate the arity of a type operator variable since that
--   information is not carried.
destTypeOp :: TypeOp -> (String, Int)

-- | Alias to the primitive boolean type operator.
tyOpBool :: TypeOp

-- | Alias to the primitive function type operator.
tyOpFun :: TypeOp

-- | Constructs a type application from a provided type operator and list
--   of type arguments. Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>A type operator variable is applied to zero arguments.</li>
--   <li>A type operator's arity disagrees with the length of the argument
--   list.</li>
--   </ul>
tyApp :: TypeOp -> [HOLType] -> Either String HOLType

-- | Returns the list of all type operator variables in a type.
typeOpVars :: HOLType -> [TypeOp]

-- | Returns the list of all type operator variables in a list of types.
catTypeOpVars :: [HOLType] -> [TypeOp]

-- | Predicate for universal types.
isUType :: HOLType -> Bool

-- | Predicate for small types. Returns <a>True</a> if all type variables
--   in the type are constrained to be small and the type contains no
--   universal types; returns <a>False</a> otherwise.
isSmall :: HOLType -> Bool

-- | Constructs a universal type of a given bound type and body type. Fails
--   with <a>Left</a> if the bound type is not a small, type variable.
mkUType :: HOLType -> HOLType -> Either String HOLType

-- | Constructs a compound universal type given a list of bound types and a
--   body. Fails with <a>Left</a> if any internal call to <a>mkUType</a>
--   fails.
mkUTypes :: [HOLType] -> HOLType -> Either String HOLType

-- | Constructs a compound universal type from a type operator variable and
--   a given number of bound variables, i.e.
--   
--   <pre>
--   uTypeFromTypeOpVar _T n === % 'A1 ... 'An. ('A1, ..., 'An)_T  
--   </pre>
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li><tt>n&lt;=0</tt> which would result in the application of a type
--   operator to an empty list of type arguments.</li>
--   <li>The type operator argument is not a variable.</li>
--   </ul>
uTypeFromTypeOpVar :: TypeOp -> Int -> Either String HOLType

-- | Constructs a small type from a given type by constraining all of the
--   type variables in the type to be small. Fails with <a>Left</a> if the
--   type contains any universal types.
mkSmall :: HOLType -> Either String HOLType

-- | Destructs a universal type, returning its bound type and body type.
--   Fails with <a>Nothing</a> if the provided type is not universally
--   quantified.
destUType :: HOLType -> Maybe (HOLType, HOLType)

-- | Destructs a compound universal type, returning the list of bound
--   variables and the final body type. Fails if the provided type is not
--   universally quantified.
destUTypes :: HOLType -> Maybe ([HOLType], HOLType)

-- | Predicate to test if a type contains a universal type at any level.
containsUType :: HOLType -> Bool

-- | Renames a type variable to avoid sharing a name with any of a given
--   list of type variables. Note that this function is both smallness
--   presserving and respecting. Returns the original type if it's not a
--   type variable.
variantTyVar :: [HOLType] -> HOLType -> HOLType

-- | Renames a list of type variables to avoid sharing a name with any of a
--   given list of type variables. As each type variable is processed it is
--   added to the list of avoids such that the resultant list of type
--   variables are all uniquely named.
variantTyVars :: [HOLType] -> [HOLType] -> [HOLType]
instance TypeSubst TypeOp HOLType
instance TypeSubst TypeOp TypeOp
instance TypeSubst HOLType HOLType


-- | This module exports a safe view of HOL terms for HaskHOL. It also
--   defines the primitive functions related to terms. For clarity, these
--   functions have been seperated based on their influential system: HOL
--   Light, Stateless HOL, and HOL2P.
--   
--   Note that, per the stateless approach, any stateful, but still
--   primitive, functions related to terms have been relocated to the
--   <a>HaskHOL.Core.State</a> module.
module HaskHOL.Core.Kernel.Terms

-- | The <a>HOLTerm</a> data type defines the internal constructors for HOL
--   terms in HaskHOL. For more details, see the documentation for its view
--   pattern data type, <a>HOLTermView</a>.
data HOLTerm

-- | The view pattern data type for HOL terms.
data HOLTermView

-- | A term variable consisting of a name and type.
Var :: String -> HOLType -> HOLTermView

-- | A term constant consisting of a name, type, and tag. See
--   <a>ConstTag</a> for more information.
Const :: String -> HOLType -> ConstTag -> HOLTermView

-- | A term application consisting of a function term and argument term.
Comb :: HOLTerm -> HOLTerm -> HOLTermView

-- | A term abstraction consisting of a bound term and a body term. Note
--   that the bound term must be a type variable.
Abs :: HOLTerm -> HOLTerm -> HOLTermView

-- | A term-level, type application consisting of a body term and an
--   argument type. Note that the body term must have a universal type.
TyComb :: HOLTerm -> HOLType -> HOLTermView

-- | A term-level, type abstraction consisting of a bound type and a body
--   term. Note that the bound type must be a small, type variable.
TyAbs :: HOLType -> HOLTerm -> HOLTermView

-- | The data type for constant tags, <a>ConstTag</a>, follows identically
--   from the implementation in Stateless HOL. For more information
--   regarding construction of the different tags, see the documentation of
--   the following functions: <tt>newPrimConst</tt>,
--   <tt>newDefinedConst</tt>, and <tt>newDefinedTypeOp</tt>.
data ConstTag

-- | Type synonym for the commonly used, list-based, term environment.
type HOLTermEnv = [(HOLTerm, HOLTerm)]

-- | Provides an ordering for two terms modulo alpha-equivalence
alphaOrder :: HOLTerm -> HOLTerm -> Ordering

-- | Tests if two terms are alpha-equivalent
aConv :: HOLTerm -> HOLTerm -> Bool

-- | Predicate for term variables.
isVar :: HOLTerm -> Bool

-- | Predicate for term constants.
isConst :: HOLTerm -> Bool

-- | Predicate for term abstractions.
isAbs :: HOLTerm -> Bool

-- | Predicate for term combinations.
isComb :: HOLTerm -> Bool

-- | Constructs a term variable of a given name and type.
mkVar :: String -> HOLType -> HOLTerm

-- | Constructs a term abstraction of a given bound term and body term.
--   Fails with <a>Left</a> if the bound term is not a variable.
mkAbs :: HOLTerm -> HOLTerm -> Either String HOLTerm

-- | Constructs a combination of two given terms. Fails with <a>Left</a> in
--   the following cases:
--   
--   <ul>
--   <li>The first term does not have a function type.</li>
--   <li>The types of the two terms does not agree.</li>
--   </ul>
mkComb :: HOLTerm -> HOLTerm -> Either String HOLTerm

-- | Destructs a term variable, returning its name and type. Fails with
--   <a>Nothing</a> if the provided term is not a variable.
destVar :: HOLTerm -> Maybe (String, HOLType)

-- | Destructs a term constant, returning its name and type. Note that no
--   constant tag information is returned. Fails with <a>Nothing</a> if the
--   provided term is not a constant.
destConst :: HOLTerm -> Maybe (String, HOLType)

-- | Destructs a term combination, returning its function and argument
--   terms. Fails with <a>Nothing</a> if the provided term is not a
--   combination.
destComb :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructs a term abstraction, returning its bound term and body term.
--   Fails with <a>Nothing</a> if the provided term is not an abstraction.
destAbs :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Returns a list of all free, term variables in a term.
frees :: HOLTerm -> [HOLTerm]

-- | Returns a list of all free, term variables in a list of terms.
catFrees :: [HOLTerm] -> [HOLTerm]

-- | Checks a list of term variables to see if they are all free in a give
--   term.
freesIn :: [HOLTerm] -> HOLTerm -> Bool

-- | Checks if a variable or constant term is free in a given term.
varFreeIn :: HOLTerm -> HOLTerm -> Bool

-- | Returns a list of all free, type variables in a term, not including
--   type operator variables.
typeVarsInTerm :: HOLTerm -> [HOLType]

-- | Returns a list of all free, type variables in a list of terms, not
--   including type operator variables.
typeVarsInTerms :: [HOLTerm] -> [HOLType]

-- | Performs a basic term substitution using a substitution environment
--   containing pairs consisting of a term variable and a term to be
--   substituted for that variable. Note that the order of elements in a
--   substitution pair follows the convention of most Haskell libraries,
--   rather than the traditional HOL convention:
--   
--   <ul>
--   <li>The second element is substituted for the first, i.e. the
--   substitution pair <tt>(A, \ x.x)</tt> indicates that the lambda term
--   <tt>\x.x</tt> should be substituted for the term variable
--   <tt>A</tt>.</li>
--   </ul>
varSubst :: HOLTermEnv -> HOLTerm -> HOLTerm

-- | The <tt>Inst</tt> class provides the framework for type instantiation
--   in HaskHOL. Note that in the simplest cases, instantiation is simply a
--   type substitution for the types of term variables and constants.
--   Therefore, instantiation is constrained by the <a>TypeSubst</a> class.
--   
--   The move to a polymorphic type system further complicates things as
--   types can now be bound at the term level, requiring renaming for type
--   instantiation. Since we have three different possible substitution
--   environment types, we have three different possible instantiation
--   environment types and, therefore, three different ways to handle
--   renaming:
--   
--   <ul>
--   <li>For <tt>(x::<a>HOLTerm</a>, r::<a>HOLTerm</a>)</tt> substitution
--   pairs we rename in the case where a type abstraction binds a type
--   variable present in <tt>r</tt> and <tt>x</tt> is present in the body
--   of the type abstraction.</li>
--   <li>For <tt>(_::<a>TypeOp</a>, _::<a>TypeOp</a>)</tt> substitution
--   pairs we can safely ignore renaming as our logic does not permit the
--   binding of type operator variables.</li>
--   <li>For <tt>(x::<a>TypeOp</a>, r::<a>HOLTerm</a>)</tt> substitution
--   pairs we rename in the case where a type abstraction binds a type
--   variable present in <tt>r</tt> and <tt>x</tt> is present in the body
--   of the type abstraction.</li>
--   </ul>
--   
--   Just as we did for the <a>TypeSubst</a> class, we hide the internals
--   of <tt>Inst</tt> to prevent unsound re-definition. The correct
--   functions to call for type instantiation are <a>inst</a> and
--   <a>instFull</a>.
class TypeSubst a b => Inst a b

-- | Type instantiation for terms. Accepts the same types of substitution
--   environments as discussed in the documentation for the
--   <a>TypeSubst</a> class, with invalid substitution pairs being pruned
--   internally by <a>typeSubst</a> as necessary.
--   
--   For more information on why the <a>Inst</a> class constraint is
--   necessary and how renaming of bound types is performed, see that
--   classes documentation.
inst :: Inst a b => [(a, b)] -> HOLTerm -> HOLTerm

-- | A version of <a>inst</a> that accepts a triplet of type substitution
--   environments.
instFull :: SubstTrip -> HOLTerm -> HOLTerm

-- | A simplified version of <a>inst</a> that works only for term
--   constants. Fails with <a>Nothing</a> if the provided term is not a
--   constant. Used internally by <tt>mkConst</tt> to guarantee that only
--   constants are constructed.
instConst :: TypeSubst a b => HOLTerm -> [(a, b)] -> Maybe HOLTerm

-- | A version of <a>instConst</a> that accepts a triplet of type
--   substitition environments.
instConstFull :: HOLTerm -> SubstTrip -> Maybe HOLTerm

-- | Constructs an instance of the HOL equality constant, <tt>=</tt>, for a
--   given type.
tmEq :: HOLType -> HOLTerm

-- | Predicate for equations, i.e. terms of the form <tt>l = r</tt>.
isEq :: HOLTerm -> Bool

-- | Constructs an equation term given the left and right hand side
--   arguments. Fails with <a>Left</a> if the types of the terms are not
--   alpha-equivalent.
primMkEq :: HOLTerm -> HOLTerm -> Either String HOLTerm

-- | Destructs an equation term, returning the left and right hand side
--   arguments. Fails with <a>Nothing</a> if the term is not an equation,
--   i.e. of the form <tt>l = r</tt>.
destEq :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Renames a term variable to avoid sharing a name with any of a given
--   list of term variables. Rreturns the original term if it's not a term
--   variable.
variant :: [HOLTerm] -> HOLTerm -> HOLTerm

-- | Renames a list of term variables to avoid sharing a name with any of a
--   given list of term variables. As each term variable is processed it is
--   added to the list of avoids such that the resultant list of term
--   variables are all uniquely named.
variants :: [HOLTerm] -> [HOLTerm] -> [HOLTerm]

-- | Constructs a primitive constant given a name and type. Note that
--   primitive constants are tagged with a <tt>Prim</tt> <a>ConstTag</a>
--   indicating that they have no definition.
newPrimConst :: String -> HOLType -> HOLTerm

-- | Returns the list of all type operator variables in a term.
typeOpVarsInTerm :: HOLTerm -> [TypeOp]

-- | Returns the list of all type operator variables in a list of terms.
typeOpVarsInTerms :: [HOLTerm] -> [TypeOp]

-- | Predicate for type abstraction terms.
isTyAbs :: HOLTerm -> Bool

-- | Predicate for type combination terms.
isTyComb :: HOLTerm -> Bool

-- | Constructs a type abstraction term given a bound type and a body term.
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The bound type is not a small type variable.</li>
--   <li>The bound type variable occurs in the type of a free variable in
--   the body term.</li>
--   </ul>
mkTyAbs :: HOLType -> HOLTerm -> Either String HOLTerm

-- | Constructs a type combination term given a body term and a type
--   argument to apply. Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The type argument is not a small type.</li>
--   <li>The type of the body term is not a universal type.</li>
--   </ul>
mkTyComb :: HOLTerm -> HOLType -> Either String HOLTerm

-- | Destructs a type abstraction, returning its bound type and body term.
--   Fails with <a>Nothing</a> if the provided term is not a type
--   abstraction.
destTyAbs :: HOLTerm -> Maybe (HOLType, HOLTerm)

-- | Destructs a type combination, returning its body term and type
--   argument. Fails with <a>Nothing</a> if the provided term is not a type
--   combination.
destTyComb :: HOLTerm -> Maybe (HOLTerm, HOLType)
instance Inst TypeOp HOLType
instance Inst TypeOp TypeOp
instance Inst HOLType HOLType


-- | This module exports the logical kernel of HaskHOL. It consists of:
--   
--   <ul>
--   <li>The view pattern required to pattern match on terms outside of the
--   kernel.</li>
--   <li>A safe view of HOL theorems for HaskHOL.</li>
--   <li>The primitive inference rules of the system.</li>
--   <li>The primitive, stateless theory extension functions.</li>
--   </ul>
--   
--   For clarity, all of these items have been seperated based on their
--   influential system: HOL Light, Stateless HOL, and HOL2P.
--   
--   Note that, per the stateless approach, any stateful, but still
--   primitive, functions related to theorems or theory extension have been
--   relocated to the <a>HaskHOL.Core.State</a> module.
module HaskHOL.Core.Kernel

-- | The view pattern function for HaskHOL's primitive data types:
--   
--   <ul>
--   <li>For types - Converts from <a>HOLType</a> to
--   <a>HOLTypeView</a>.</li>
--   <li>For terms - Converts from <a>HOLTerm</a> to
--   <a>HOLTermView</a>.</li>
--   <li>For theorems - Converts from <a>HOLThm</a> to
--   <a>HOLThmView</a>.</li>
--   </ul>
view :: Viewable a b => a -> b

-- | The <a>HOLThm</a> data type defines HOL Theorems in HaskHOL. A theorem
--   is defined simply as a list of assumption terms and a conclusion term.
--   
--   Note that this representation, in combination with a stateless
--   approach, means that the introduction of axioms is not tracked in the
--   kernel. Axioms can be tracked once the stateful layer of the prover is
--   introduced, though. For more details see the documentation for
--   <tt>newAxiom</tt>.
data HOLThm

-- | The view pattern data type for HOL theorems.
data HOLThmView
Thm :: [HOLTerm] -> HOLTerm -> HOLThmView

-- | Destructs a theorem, returning its list of assumption terms and
--   conclusion term.
destThm :: HOLThm -> ([HOLTerm], HOLTerm)

-- | Accessor for the hypotheses, or assumption terms, of a theorem.
hyp :: HOLThm -> [HOLTerm]

-- | Accessor for the conclusion term of a theorem.
concl :: HOLThm -> HOLTerm

-- | <pre>
--        t    
--   -----------
--    |- t = t
--   </pre>
--   
--   Never fails.
primREFL :: HOLTerm -> HOLThm

-- | <pre>
--    A1 |- t1 = t2   A2 |- t2 = t3
--   -------------------------------
--          A1 U A2 |- t1 = t3     
--   </pre>
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The middle terms are not alpha-equivalent.</li>
--   <li>One, or both, of the theorem conclusions is not an equation.</li>
--   </ul>
primTRANS :: HOLThm -> HOLThm -> Either String HOLThm

-- | <pre>
--    A1 |- f = g   A2 |- x = y
--   ---------------------------
--       A1 U A2 |- f x = g y
--   </pre>
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>One, or both, of the theorem conclusions is not an equation.</li>
--   <li>The first theorem conclusion is not an equation of function
--   terms.</li>
--   <li>The types of the function terms and argument terms do not
--   agree.</li>
--   </ul>
primMK_COMB :: HOLThm -> HOLThm -> Either String HOLThm

-- | <pre>
--             A |- t1 = t2
--   -------------------------------
--    A |- (\ x . t1) = (\ x . t2)
--   </pre>
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The term to bind is free in the assumption list of the
--   theorem.</li>
--   <li>The conclusion of the theorem is not an equation.</li>
--   </ul>
primABS :: HOLTerm -> HOLThm -> Either String HOLThm

-- | <pre>
--           (\ x . t[x]) x
--   -------------------------------
--        |- (\ x . t) x = t[x]
--   </pre>
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The term is not a valid application.</li>
--   <li>The reduction is not a trivial one, i.e. the argument term is not
--   equivalent to the bound variable.</li>
--   </ul>
primBETA :: HOLTerm -> Either String HOLThm

-- | <pre>
--        t
--   -----------
--      t |- t
--   </pre>
--   
--   Fails with <a>Nothing</a> if the term is not a proposition.
primASSUME :: HOLTerm -> Maybe HOLThm

-- | <pre>
--    A1 |- t1 = t2   A2 |- t1
--   ----------------------------
--         A1 U A2 |- t2
--   </pre>
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The conclusion of the first theorem is not an equation.</li>
--   <li>The conclusion term of the second theorem and the left hand side
--   of the equation are not alpha-equivalent.</li>
--   </ul>
primEQ_MP :: HOLThm -> HOLThm -> Either String HOLThm

-- | <pre>
--          A |- p       B |- q       
--   ----------------------------------
--    (A - {q}) U (B - {p}) |- p &lt;=&gt; q
--   </pre>
--   
--   Never fails.
primDEDUCT_ANTISYM_RULE :: HOLThm -> HOLThm -> HOLThm

-- | <pre>
--    [(ty1, tv1), ..., (tyn, tvn)]   A |- t              
--   ----------------------------------------
--      A[ty1, ..., tyn/tv1, ..., tvn]
--       |- t[ty1, ..., tyn/tv1, ..., tvn]
--   </pre>
--   
--   Never fails.
primINST_TYPE :: Inst a b => [(a, b)] -> HOLThm -> HOLThm

-- | A version of <a>primINST_TYPE</a> that instantiates a theorem via
--   <a>instFull</a>.
primINST_TYPE_FULL :: SubstTrip -> HOLThm -> HOLThm

-- | <pre>
--    [(t1, x1), ..., (tn, xn)]   A |- t          
--   ------------------------------------
--      A[t1, ..., tn/x1, ..., xn]
--       |- t[t1, ..., tn/x1, ..., xn]   
--   </pre>
--   
--   Never fails.
primINST :: HOLTermEnv -> HOLThm -> HOLThm

-- | <pre>
--             A |- t1 = t2
--   -------------------------------
--    A |- (\\ x . t1) = (\\ x . t2)
--   </pre>
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The type to bind is not a small type variable.</li>
--   <li>The conclusion of the theorem is not an equation.</li>
--   <li>The type to bind is free in the assumption list of the
--   theorem.</li>
--   <li>The type variable to bind is free in the conclusion of the
--   theorem.</li>
--   </ul>
primTYABS :: HOLType -> HOLThm -> Either String HOLThm

-- | <pre>
--             A |- t1 = t2
--   -------------------------------
--    A |- t1 [: ty1] = t2 [: ty2]
--   </pre>
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The conclusion of the theorem is not an equation of terms of
--   universal type.</li>
--   <li>The type arguments are not alpha-equivalent.</li>
--   <li>One, or both, of the type arguments is not small.</li>
--   </ul>
primTYAPP2 :: HOLType -> HOLType -> HOLThm -> Either String HOLThm

-- | <pre>
--           A |- t1 = t2
--   ----------------------------
--    A |- t1 [: ty] = t2 [: ty]
--   </pre>
--   
--   Fails with <a>Nothing</a> if the conclusion of the theorem is not an
--   equation.
--   
--   Note that <a>primTYAPP</a> is equivalent to <a>primTYAPP2</a> when the
--   same type is applied to both sides, i.e.
--   
--   <pre>
--   primTYAPP ty === primTYAPP2 ty ty
--   </pre>
primTYAPP :: HOLType -> HOLThm -> Maybe HOLThm

-- | <pre>
--        (\\ ty . t[ty]) [: ty]    
--   ---------------------------------
--    |- (\\ ty . t[ty]) [: ty] = t
--   </pre>
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The term is not a valid type application.</li>
--   <li>The reduction is not a trivial one, i.e. the argument type is not
--   equivalent to the bound type variable.</li>
--   </ul>
primTYBETA :: HOLTerm -> Either String HOLThm

-- | Creates a new axiom theorem.
--   
--   Note that, as discussed in the documentation for <a>HOLThm</a>, the
--   introduction of axioms is not tracked until the stateful layer of the
--   system is introduced so be careful using this function.
axiomThm :: HOLTerm -> HOLThm

-- | <pre>
--      c = t  
--   -----------
--    |- c = t
--   </pre>
--   
--   Creates a new defined constant given a term that equates a variable of
--   the desired constant name and type to its desired definition. The
--   return value is a pair of the new constant and its definitional
--   theorem.
--   
--   Note that internally the constant is tagged with its definitional term
--   via the <tt>Defined</tt> <a>ConstTag</a>.
--   
--   Fails with <a>Left</a> in the following cases:
--   
--   <ul>
--   <li>The provided term is not an equation.</li>
--   <li>The provided term is not closed.</li>
--   <li>There are free type variables present in the definition that are
--   not also in the desired type of the constant.</li>
--   </ul>
newDefinedConst :: HOLTerm -> Either String (HOLTerm, HOLThm)

-- | <pre>
--                              |- p x:rep
--   -----------------------------------------------------------------
--    (|- mk:rep-&gt;ty (dest:ty-&gt;rep a) = a, |- P r &lt;=&gt; dest(mk r) = r)
--   </pre>
--   
--   Creates a new defined type constant that is defined as an inhabited
--   subset of an existing type constant. The return value is a pentuple
--   that collectively provides a bijection between the new type and the
--   old type.
--   
--   The following four items are taken as input:
--   
--   <ul>
--   <li>The name of the new type constant - <tt>ty</tt> in the above
--   sequent.</li>
--   <li>The name of the new term constant that will be used to make an
--   instance of the new type - <tt>mk</tt> in the above sequent.</li>
--   <li>The name of the new term constant that will be used to destruct an
--   instance of the new type - <tt>dest</tt> in the above sequent.</li>
--   <li>A theorem proving that the desired subset is non-empty. The
--   conclusion of this theorem must take the form <tt>p x</tt> where
--   <tt>p</tt> is the predicate that defines the subset and <tt>x</tt> is
--   a witness to inhabitation.</li>
--   </ul>
--   
--   The following items are returned as part of the resultant pentuple:
--   
--   <ul>
--   <li>The new defined type operator. These type operators carry their
--   name, arity, and definitional theorem. The arity, in this case, is
--   inferred from the number of free type variables found in the predicate
--   of the definitional theorem.</li>
--   <li>The new term constants, <tt>mk</tt> and <tt>dest</tt>, as
--   described above. Note that constants constructed in this manner are
--   tagged with special instances of <a>ConstTag</a>, <tt>MkAbstract</tt>
--   and <tt>DestAbstract</tt> accordingly, that carry the name, arity, and
--   definitional theorem of their related type constant.</li>
--   <li>The two theorems proving the bijection, as shown in the sequent
--   above.</li>
--   </ul>
newDefinedTypeOp :: String -> String -> String -> HOLThm -> Either String (TypeOp, HOLTerm, HOLTerm, HOLThm, HOLThm)


-- | This module exports the primitive types and combinators for the
--   <a>HOL</a> computational monad. At a high level this monad is a
--   flattened stack of a <tt>State</tt> monad transformer and a limited
--   <a>IO</a> monad.
--   
--   For higher level monadic combinators see the <a>HaskHOL.Core.State</a>
--   and <a>HaskHOL.Core.Basics</a> modules.
module HaskHOL.Core.State.Monad

-- | The <a>HOL</a> monad structures computations in the HaskHOL system at
--   the stateful layer and above. The type parameters are used as such:
--   
--   <ul>
--   <li><tt>cls</tt> - <a>HOL</a> computations are split into two classes,
--   those that extend the current working theory and those that are
--   "pure"-ly used for proof. The <tt>cls</tt> parameter is used to
--   indicate the classification of a computation. It is a phantom type
--   variable that is inhabited by one of two empty data types,
--   <a>Theory</a> and <a>Proof</a>.</li>
--   <li><tt>thry</tt> - Carries a tag indicating the most recent
--   checkpoint of the current working theory, i.e. the last library
--   loaded. Again, it is phantom type variable that is inhabited by an
--   empty data type. A unique tag is created for each library by
--   linerearly extending the tag starting from a base value. For example,
--   the tag <tt>ExtThry EqualThry BaseThry</tt> would indicate a current
--   working theory consisting of the base and equality logic
--   theories.</li>
--   </ul>
--   
--   Note that typically this value is left polymorphic and is constrained
--   by a class related to a library. For example, the following type
--   indicates a computation that can only be ran by using a theory context
--   value that has the equality logic library loaded: <tt>EqualCtxt thry
--   =&gt; HOL cls thry a</tt>
--   
--   <ul>
--   <li><tt>a</tt> - The return type of a <a>HOL</a> computation.</li>
--   </ul>
--   
--   Note that the <a>HOL</a> monad is effectively a flattened stack of a
--   limited <a>IO</a> monad and a <tt>State</tt> monad. We say limited as
--   we restrict the possible IO-like computations to the ones shown in
--   this module, rather than allowing arbitrary computations through a
--   mechanism like <tt>MonadIO</tt>. This prevents a number of soundness
--   issues.
--   
--   For more information regarding the contents of a theory context see
--   the documentation for <a>HOLContext</a>.
data HOL cls thry a

-- | The classification tag for theory extension computations.
data Theory

-- | The classification tag for proof computations.
data Proof

-- | Evaluates a <a>HOL</a> computation with a provided theory context.
--   Returns the result paired with an updated theory context.
runHOLCtxt :: HOL cls thry a -> HOLContext thry -> IO (a, HOLContext thry)

-- | A version of <a>runHOLCtxt</a> that returns only the resultant value.
evalHOLCtxt :: HOL cls thry a -> HOLContext thry -> IO a

-- | A version of <a>runHOLCtxt</a> that returns only the theory context.
execHOLCtxt :: HOL cls thry a -> HOLContext thry -> IO (HOLContext thry)

-- | Equivalent to <a>get</a> for the <a>HOL</a> monad. Note that we define
--   our own version of this function, rather than define an instance of
--   <tt>MonadState</tt> so that we can control where the morphisms are
--   exported.
--   
--   This is done in the name of soundness given that a user can inject an
--   unsound theory context into a proof using a <tt>put</tt> morphism.
--   This is analogous to the issue behind defining an instance of
--   <tt>MonadIO</tt> given <tt>liftIO</tt> can be used to inject arbitrary
--   computations into the <a>HOL</a> monad, including ones containing
--   unsound contexts.
get :: HOL cls thry (HOLContext thry)

-- | A version of <a>get</a> that applies a function to the state before
--   returning the result.
gets :: (HOLContext thry -> a) -> HOL cls thry a

-- | A version of <a>putStr</a> lifted to the <a>HOL</a> monad.
putStrHOL :: String -> HOL cls thry ()

-- | A version of <a>putStrLn</a> lifted to the <a>HOL</a> monad.
putStrLnHOL :: String -> HOL cls thry ()

-- | The data type for generic errors in HaskHOL. Carries a <a>String</a>
--   message.
newtype HOLException
HOLException :: String -> HOLException

-- | A version of <tt>throwIO</tt> lifted to the <a>HOL</a> monad.
--   
--   Note that the following functions for the <a>HOL</a> type rely on
--   <a>throwHOL</a>:
--   
--   <ul>
--   <li><a>fail</a> - Equivalent to</li>
--   </ul>
--   
--   <pre>
--   throwHOL . HOLException
--   </pre>
--   
--   <ul>
--   <li><a>mzero</a> - Equivalent to</li>
--   </ul>
--   
--   <pre>
--   fail "mzero - HOL"
--   </pre>
--   
--   <ul>
--   <li><a>empty</a> - Equivalent to</li>
--   </ul>
--   
--   <pre>
--   fail "empty - HOL"
--   </pre>
throwHOL :: Exception e => e -> HOL cls thry a

-- | A version of <a>catch</a> lifted to the <a>HOL</a> monad.
--   
--   Note that <a>mplus</a> and <a>&lt;|&gt;</a> are defined in terms of
--   catching a <a>SomeException</a> with <a>catchHOL</a> and then ignoring
--   it to run an alternative computation instead.
catchHOL :: Exception e => HOL cls thry a -> (e -> HOL cls thry a) -> HOL cls thry a

-- | Lifts a <a>Maybe</a> value into the <a>HOL</a> monad mapping
--   <a>Just</a>s to <a>return</a>s and <a>Nothing</a>s to <a>fail</a>s
--   with the provided <a>String</a>.
liftMaybe :: String -> Maybe a -> HOL cls thry a

-- | Lifts an <a>Either</a> value into the <a>HOL</a> monad mapping
--   <a>Right</a>s to <a>return</a>s and <a>Left</a>s to <a>fail</a>s.
--   
--   Note that the value inside the <a>Left</a> must have an instance of
--   the <a>Show</a> class such that <a>show</a> can be used to construct a
--   string to be used with <a>fail</a>.
liftEither :: Show err => String -> Either err a -> HOL cls thry a

-- | A type synonym for <a>IORef</a>.
type HOLRef = IORef

-- | Creates a new <a>HOLRef</a> from a given starting value. Functionally
--   equivalent to <a>newIORef</a> lifted to the <a>HOL</a> monad.
newHOLRef :: a -> HOL cls thry (HOLRef a)

-- | Reads a <a>HOLRef</a> returning the stored value. Functionally
--   equivalent to <a>readIORef</a> lifted to the <a>HOL</a> monad.
readHOLRef :: IORef a -> HOL cls thry a

-- | Writes a value to a <a>HOLRef</a>. Functionally equivalent to
--   <a>writeHOLRef</a> lifted to the <a>HOL</a> monad.
writeHOLRef :: IORef a -> a -> HOL cls thry ()

-- | Applies a given function to a <a>HOLRef</a>, modifying the stored
--   value. Functionally equivalent to <a>modifyHOLRef</a> lifted to the
--   <a>HOL</a> monad.
modifyHOLRef :: IORef a -> (a -> a) -> HOL cls thry ()

-- | HOL systems typically use a large number of boolean flags in order to
--   direct system behavior, i.e. debug flags, warning flags,
--   parser/printer flags, etc. These flags don't affect the underlying
--   proof computations, hence their classification as benign, so we'd like
--   to be able to toggle them on and off at will. Unfortunately, if we
--   store them in the extensible state and use <a>putExt</a> or
--   <a>modifyExt</a> we're limited to only being able to change them in
--   <a>Theory</a> computations.
--   
--   Instead, we include them in a separate part of the theory context
--   where we can interact with them in any way we want without sacrificing
--   the safety of the extensible state portion of the context.
--   
--   The <a>BenignFlag</a> class works very similarly to the
--   <a>ExtClass</a> class with the obvious exception that initial values
--   are restricted to boolean values.
--   
--   See <a>HOLContext</a>, <a>getBenignFlagCtxt</a>, and
--   <a>setBenignFlag</a> for more details.
class Typeable a => BenignFlag a
initFlagValue :: BenignFlag a => a -> Bool

-- | Adds a new, or modifies an existing, benign flag to be <a>True</a>.
--   Benign flags in the context are stored as a list of
--   <tt>(<a>String</a>, <a>Bool</a>)</tt> pairs. The first field in this
--   pair is a term-level reificatino of a benign flag's type, produced via
--   a composition of <a>show</a> and <a>typeOf</a>. The second field is
--   simply the current boolean value of the flag.
--   
--   Numerous usage examples can be found in both the
--   <a>HaskHOL.Core.Parser.Lib</a> and <a>HaskHOL.Core.Printer</a> modules
--   where flags are used to direct the behavior of the parsers and
--   printers accordingly.
--   
--   Note that since the retrieval and storage of benign flags are driven
--   by types, it is in the best interest of library implementors to
--   guarantee that the types of their flags are unique. The easiest way to
--   do this is to create a unique <tt>data</tt> type for each flag. The
--   type doesn't need to carry a payload, but it does need to provide a
--   witness to the flag type. As such, it can either be a nullary, punned
--   data declaration, i.e. <tt>data X = X</tt>, or an empty data
--   declaration with a type annotated instance of <a>undefined</a> acting
--   as the ness, i.e. <tt>undefined :: X</tt>.
--   
--   Example:
--   
--   <pre>
--   setBenignFlag FlagDebug
--   </pre>
--   
--   would set the debugging flag equal to <a>True</a>.
--   
--   Alternatively, the <a>newFlag</a> splice can be used to automatically
--   construct a new extension given a name and initial value. See that
--   function's documentation for more information.
setBenignFlag :: BenignFlag a => a -> HOL cls thry ()

-- | Unsets a benign flag making it <a>False</a>.
unsetBenignFlag :: BenignFlag a => a -> HOL cls thry ()

-- | Retrieves the value of a benign flag from a theory context. This
--   function is typically used external to <a>HOL</a> computations, such
--   as in the parser and printer.
--   
--   Note that retrieval of the value requires a witness to the desired
--   flag's type, i.e.
--   
--   <pre>
--   getBenignFlag FlagDebug
--   </pre>
--   
--   or
--   
--   <pre>
--   getBenignFlag (undefined :: FlagDebug)
--   </pre>
--   
--   In the event that the flag is not found then the <a>initFlagValue</a>
--   for that type is returned. Thus, this function never fails.
getBenignFlagCtxt :: BenignFlag a => a -> HOLContext thry -> Bool

-- | A version of <a>getBenignFlagCtxt</a> that can be used with theory
--   contexts passed implicitly as part of a <a>HOL</a> computation.
--   
--   Never fails.
getBenignFlag :: BenignFlag a => a -> HOL cls thry Bool

-- | Increments the term counter stored in the context, returning the new
--   value. Can be used to guarantee the freshness of term names within a
--   single computation.
tickTermCounter :: HOL cls thry Int

-- | Increments the type counter stored in the context, returning the new
--   value. Can be used to gurantee the freshness of type names within a
--   single computation.
tickTypeCounter :: HOL cls thry Int

-- | The <a>ExtClass</a> type class is the heart of HaskHOL's extensible
--   state mechanism. It serves a number of purposes:
--   
--   <ul>
--   <li>It provides the polymorphic type for heterogenous structures of
--   type <a>ExtState</a>.</li>
--   <li>It introduces the <a>Typeable</a> constraint that enables the
--   mechanism for selecting specific state extensions based on their type.
--   See <a>getExt</a> for more details.</li>
--   <li>It defines an initial value for state extensions to use if they
--   have not been introduced to the context by a computation yet.</li>
--   </ul>
--   
--   For more information see the documentation for <a>HOLContext</a>,
--   <a>getExtCtxt</a>, and <a>putExt</a>.
class (Lift a, Typeable a) => ExtClass a
initValue :: ExtClass a => a

-- | Used to build heterogenous structures that hold state extensions. See
--   <a>ExtClass</a> for more details.
data ExtState

-- | Adds a new, or modifies an existing, state extension. State extensions
--   in the context are stored as a list of <tt>(<a>String</a>,
--   <a>ExtState</a>)</tt> pairs. The first field in this pair is a
--   term-level reification of a state extension's type, produced via a
--   composition of <a>show</a> and <a>typeOf</a>. The second field is
--   simply a wrapping of the extension's value with <a>ExtState</a> to
--   facilitate heterogeneous structures.
--   
--   Numerous usage examples can be found in the
--   <a>HaskHOL.Core.Parser.Lib</a> module where extensible state is used
--   to store the list of operators, as well as other information, required
--   by the parser.
--   
--   Note that since the retrieval and storage of state extensions are
--   driven by types, it is in the best interest of library implementors to
--   guarantee that the type of their extensions are unique. The easiest
--   way to do this is to create a <tt>newtype</tt> wrapper for your
--   extension and hide the internal constructor to prevent unintended
--   modification. Again, see <a>HaskHOL.Core.Parser.Lib</a> for usage
--   examples.
--   
--   Alternatively, the <a>newExtension</a> splice can be used to
--   automatically construct a new extension given a name and initial
--   value. See that function's documentation for more information.
putExt :: ExtClass a => a -> HOL Theory thry ()

-- | Retrives a state extension from a theory context. This function is
--   typically used external to <a>HOL</a> computations, such as in the
--   parser, where a theory context is passed explicitly as a value.
--   
--   Note that the selection of the extension is driven by the return type
--   of this function. Thus when binding the result of this function, the
--   type must be fixed either via explicit type annotation or through the
--   presence of a unique constructor.
--   
--   In order to provide the correct result type, this function relies on
--   the type-safe <a>cast</a> operation. In the event that either this
--   cast fails or the state extension is not found then the
--   <a>initValue</a> for that type is returned. Thus, this function never
--   fails.
getExtCtxt :: ExtClass a => HOLContext thry -> a

-- | A version of <a>getExtCtxt</a> that can be used with theory contexts
--   passed implicitly as part of a <a>HOL</a> computation.
--   
--   Never fails.
getExt :: ExtClass a => HOL cls thry a

-- | Modifies the value of a state extension. Functionally equivalent to
--   the composition
--   
--   <pre>
--   \ f -&gt; putExt . f =&lt;&lt; getExt
--   </pre>
modifyExt :: ExtClass a => (a -> a) -> HOL Theory thry ()

-- | The state type for the <a>HOL</a> monad. A newtype wrapper to the
--   following quad:
--   
--   <ul>
--   <li>An association <tt>List</tt> of <tt>(<a>String</a>,
--   <a>Bool</a>)</tt> pairs that models HaskHOL's extensible benign flag
--   system. The first field is a <a>String</a> representation of the type
--   of a benign flag and the second field is that flag's current
--   value.</li>
--   <li>An <a>Int</a> counter that is used for fresh name generation for
--   type variables.</li>
--   <li>An <a>Int</a> counter that is used for fresh name generation for
--   term variables.</li>
--   <li>An association <tt>List</tt> of <tt>(<a>String</a>,
--   <a>ExtState</a>)</tt> pairs that models HaskHOL's extensible state.
--   The first field is a <a>String</a> representation of the type of a
--   state extension and the second field is a wrapping of that type that
--   has an instance of the <a>ExtClass</a> class.</li>
--   </ul>
--   
--   See <a>putExt</a> and <a>getExtCtxt</a> for more details on how to
--   interact with the extensible state and see <a>setBenignFlag</a> and
--   <a>getBenignFlag</a> for more details on how to interact with benign
--   flags.
data HOLContext thry

-- | The initial working theory value: debugging is on, the counters are at
--   zero and the extensible state is empty.
ctxtBase :: HOLContext BaseThry

-- | The <a>ExtThry</a> type is the type of a linear theory extension, i.e.
--   a cons-like operation for theory types. See the module
--   <a>HaskHOL.Lib.Equal.Context</a> for an example of how to correctly
--   define theory types and contexts for a library.
data ExtThry a b
ExtThry :: a -> b -> ExtThry a b

-- | The <a>BaseThry</a> type is the type of the initial working theory.
data BaseThry
BaseThry :: BaseThry

-- | The <a>BaseCtxt</a> class is the context name associated with the
--   <a>BaseThry</a> type, i.e. the constraint to be used to guarantee that
--   the stateful kernel has been loaded. This should always be true.
class BaseCtxt a

-- | The <a>newFlag</a> splice can be used to automatically construct a new
--   benign flag given a name and an initial flag value.
--   
--   Example:
--   
--   <pre>
--   newFlag "FlagDebug" True
--   </pre>
--   
--   will construct the following Haskell code:
--   
--   <pre>
--   data FlagDebug = FlagDebug deriving Typeable
--   instance BenignFlag FlagDebug where
--       initFlagValue _ = True
--   </pre>
newFlag :: String -> Bool -> Q [Dec]

-- | The <a>newExtension</a> splice can be used to automatically construct
--   a new state extension given a name and a quoted, type annotated,
--   initial value. The type annotation is required as many initial values,
--   such as an empty list, are too polymorphic to infer the correct type
--   on its own.
--   
--   Example:
--   
--   <pre>
--   newExtension "TheCoreDefinitions" [| [] :: [HOLThm] |]
--   </pre>
--   
--   will construct the following Haskell code:
--   
--   <pre>
--   newtype TheCoreDefinitions = TheCoreDefinitions [HOLThm] deriving Typeable
--   instance ExtClass TheCoreDefinitions where
--       initValue = TheCoreDefinitions []
--   </pre>
--   
--   Note that, due to limitations with the current version of Template
--   Haskell, <a>Lift</a> instances should be derived external to this
--   splice via <a>deriveLift</a> or <a>deriveLiftMany</a>.
newExtension :: String -> ExpQ -> Q [Dec]

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
instance Lift ExtState
instance Typeable HOLException
instance Typeable1 HOLContext
instance Typeable BaseThry
instance Typeable2 ExtThry
instance Show HOLException
instance BaseCtxt b => BaseCtxt (ExtThry a b)
instance BaseCtxt BaseThry
instance Show (HOLContext thry)
instance Lift (HOLContext thry)
instance Exception HOLException
instance Note (HOL cls thry)
instance Alternative (HOL cls thry)
instance Applicative (HOL cls thry)
instance MonadPlus (HOL cls thry)
instance Monad (HOL cls thry)
instance Functor (HOL cls thry)


-- | This module exports the stateful layer of HaskHOL. It consists of:
--   
--   <ul>
--   <li>Stateful type primitives not found in
--   <a>HaskHOL.Core.Types</a>.</li>
--   <li>Stateful term primitives not found in
--   <a>HaskHOL.Core.Terms</a>.</li>
--   <li>Stateful theory extension primitives not found in
--   <a>HaskHOL.Core.Kernel</a>.</li>
--   <li>A very primitive debugging system.</li>
--   </ul>
module HaskHOL.Core.State

-- | Retrieves the list of type constants from the current working theory.
--   The list contains pairs of strings recognized by the parser and the
--   associated type operator value, i.e.
--   
--   <pre>
--   ("bool", tyOpBool)
--   </pre>
types :: HOL cls thry [(String, TypeOp)]

-- | Retrieves the arity of a given type constant. Fails with
--   <a>Nothing</a> if the provided type constant name is not defined in
--   the provided context.
--   
--   Note that this function takes a <a>HOLContext</a> argument such that
--   it can be used outside of <a>HOL</a> computations; for example, in the
--   parser.
getTypeArityCtxt :: HOLContext thry -> String -> Maybe Int

-- | A version of <a>getTypeArityCtxt</a> that operates over the current
--   working theory of a <a>HOL</a> computation. Throws a
--   <a>HOLException</a> if the provided type constant name is not defined.
getTypeArity :: String -> HOL cls thry Int

-- | Constructs a new primitve type constant of a given name and arity.
--   Also adds this new type to the current working theory. Throws a
--   <a>HOLException</a> when a type of the same name has already been
--   declared.
newType :: String -> Int -> HOL Theory thry ()

-- | Constructs a type application given an operator name and a list of
--   argument types. If the provided name is not a currently defined type
--   constant then this function defaults it to a type operator variable.
--   Throws a <a>HOLException</a> in the following cases:
--   
--   <ul>
--   <li>A type operator's arity disagrees with the length of the argument
--   list.</li>
--   <li>A type operator is applied to zero arguments.</li>
--   </ul>
mkType :: String -> [HOLType] -> HOL cls thry HOLType

-- | Constructs a function type safely using <a>mkType</a>. Should never
--   fail provided that the initial value for type constants has not been
--   modified.
mkFunTy :: HOLType -> HOLType -> HOL cls thry HOLType

-- | Retrieves the list of term constants from the current working theory.
--   The list contains pairs of strings recognized by the parser and the
--   associated term constant value, i.e.
--   
--   <pre>
--   ("=", tmEq tyA)
--   </pre>
constants :: HOL cls thry [(String, HOLTerm)]

-- | Retrieves the type of a given term constant. Throws a
--   <a>HOLException</a> if the provided term constant name is not defined.
getConstType :: String -> HOL cls thry HOLType

-- | Constructs a new primitive term constant of a given name and type.
--   Also adds this new term to the current working theory. Throws a
--   <a>HOLException</a> when a term of the same name has already been
--   declared.
newConstant :: String -> HOLType -> HOL Theory thry ()

-- | Constructs a specific instance of a term constant when provided with
--   its name and a type substition environment. Throws a
--   <a>HOLException</a> in the following cases:
--   
--   <ul>
--   <li>The instantiation as performed by <a>instConst</a> fails.</li>
--   <li>The provided name is not a currently defined constant.</li>
--   </ul>
mkConst :: TypeSubst l r => String -> [(l, r)] -> HOL cls thry HOLTerm

-- | A version of <a>mkConst</a> that accepts a triplet of type
--   substitition environments. Frequently used with the <tt>typeMatch</tt>
--   function.
mkConstFull :: String -> SubstTrip -> HOL cls thry HOLTerm

-- | Safely creates an equality between two terms using <a>mkConst</a>
--   using the type of the left hand side argument to perform the required
--   instantiation. Throws a <a>HOLException</a> in the case when the types
--   of the two terms do not agree.
mkEq :: HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | Retrieves the list of axioms from the current working theory. The list
--   contains pairs of string names and the axioms. This names exists such
--   that compile time operations have a tag with which they can use to
--   extract axioms from saved theories. See <tt>extractAxiom</tt> for more
--   details.
axioms :: HOL cls thry [(String, HOLThm)]

-- | Retrieves a specific axiom by name. Throws a <a>HOLException</a> if
--   there is no axiom with the provided name in the current working
--   theory.
getAxiom :: String -> HOL cls thry HOLThm

-- | Constructs a new axiom of a given name and conclusion term. Also adds
--   this new axiom to the current working theory. Throws a
--   <a>HOLException</a> in the following cases:
--   
--   <ul>
--   <li>The provided term is not a proposition.</li>
--   <li>An axiom with the provided name has already been declared.</li>
--   </ul>
newAxiom :: String -> HOLTerm -> HOL Theory thry HOLThm

-- | Retrieves the list of definitions from the current working theory. See
--   <a>newBasicDefinition</a> for more details.
definitions :: HOL cls thry [HOLThm]

-- | Introduces a definition of the form <tt>c = t</tt> into the current
--   working theory. Throws a <a>HOLException</a> when the definitional
--   term is ill-formed. See <a>newDefinedConst</a> for more details.
newBasicDefinition :: HOLTerm -> HOL Theory thry HOLThm

-- | Introduces a new type constant, and two associated term constants,
--   into the current working theory that is defined as an inhabited subset
--   of an existing type constant. Takes the following arguments:
--   
--   <ul>
--   <li>The name of the new type constant.</li>
--   <li>The name of the new term constant that will be used to construct
--   the type.</li>
--   <li>The name of the new term constant that will be used to desctruct
--   the type.</li>
--   <li>A theorem that proves that the defining predicate has at least one
--   satisfying value.</li>
--   </ul>
--   
--   Throws a <a>HOLException</a> in the following cases:
--   
--   <ul>
--   <li>A term constant of either of the provided names has already been
--   defined.</li>
--   <li>A type constant of the provided name has already been
--   defined.</li>
--   </ul>
--   
--   See <a>newDefinedTypeOp</a> for more details.
newBasicTypeDefinition :: String -> String -> String -> HOLThm -> HOL Theory thry (HOLThm, HOLThm)

-- | Flag states whether or not to print debug statements.
data FlagDebug
FlagDebug :: FlagDebug

-- | Prints the provided string, with a new line, when the given boolean
--   value is true.
warn :: Bool -> String -> HOL cls thry ()

-- | Prints the provided string, with a new line, when debugging is turned
--   on, then returns the given <a>HOL</a> computation. A version of
--   <tt>trace</tt> for the <a>HOL</a> monad that is referentially
--   transparent.
printDebugLn :: String -> HOL cls thry a -> HOL cls thry a

-- | A version of printDebug that does not print a new line.
printDebug :: String -> HOL cls thry a -> HOL cls thry a
instance Lift TheCoreDefinitions
instance Lift TheAxioms
instance Lift TermConstants
instance Lift TypeConstants
instance Typeable TheCoreDefinitions
instance ExtClass TheCoreDefinitions
instance Typeable TheAxioms
instance ExtClass TheAxioms
instance Typeable TermConstants
instance ExtClass TermConstants
instance Typeable TypeConstants
instance ExtClass TypeConstants
instance Typeable FlagDebug
instance BenignFlag FlagDebug


-- | This module defines common utility functions that depend on data types
--   introduced by HaskHOL. See the <a>HaskHOL.Core.Lib</a> module for
--   utility functions that do not have this dependence.
module HaskHOL.Core.Basics

-- | Generates a new term variable consisting of a given prefix and the
--   next value in the fresh term counter.
genVarWithName :: String -> HOLType -> HOL cls thry HOLTerm

-- | A version of <a>genVarWithName</a> that defaults to the prefix "_".
genVar :: HOLType -> HOL cls thry HOLTerm

-- | Checks to see if the first type occurs in the second type. Note that
--   the predicate is also satisfied if the two types are equal.
occursIn :: HOLType -> HOLType -> Bool

-- | Basic type substitution that ignores type operators and prunes the
--   substitution environment of bound variables rather than handle
--   renaming. Works for all types, variable and non-variable alike. Fails
--   with <a>Left</a> when the substitution would result in an invalid type
--   construction.
--   
--   Note that the order of the elements of the substitution pairs matches
--   other environments in the systems, such that for the pair <tt>(A,
--   B)</tt> <tt>B</tt> will be substituted for all instances of
--   <tt>A</tt>.
tysubst :: HOLTypeEnv -> HOLType -> Either String HOLType

-- | Alpha conversion for universal types. Renames a bound type variable to
--   match the name of a provided type variable. Fails with <a>Left</a> in
--   the following cases:
--   
--   <ul>
--   <li>First type is not a small type variable.</li>
--   <li>Second type is not a universal type.</li>
--   <li>The type variable is free in the body of the universal type.</li>
--   </ul>
alphaUtype :: HOLType -> HOLType -> Either String HOLType

-- | Predicate to check if the first term is free in the second modulo
--   alpha-equivalence.
freeIn :: HOLTerm -> HOLTerm -> Bool

-- | Basic term substitution. Throws a <a>HOLException</a> when the
--   substitution would result in an invalid term construction.
--   
--   Note that the order of the elements of the substitution pairs matches
--   other environments in the systems, such that for the pair <tt>(A,
--   B)</tt> <tt>B</tt> will be substituted for all instances of
--   <tt>A</tt>.
subst :: HOLTermEnv -> HOLTerm -> HOL cls thry HOLTerm

-- | Alpha conversion for term abstractions. Renames a bound variable to
--   match the name of a provided variable. Fails with <a>Left</a> in the
--   following cases:
--   
--   <ul>
--   <li>First term is not a variable.</li>
--   <li>Second term is not an abstraction.</li>
--   <li>The types of the variable and bound variable do no agree.</li>
--   <li>The variable is free in the body of the abstraction.</li>
--   </ul>
alpha :: HOLTerm -> HOLTerm -> Either String HOLTerm

-- | Alpha conversion for type abstractions. Renames a bound type variable
--   to match the name of a provided type variable. Fails with <a>Left</a>
--   in the following cases:
--   
--   <ul>
--   <li>The provided type is not a small type variable.</li>
--   <li>The provided term is not a type abstraction.</li>
--   <li>The type is free in the body of the type abstraction.</li>
--   </ul>
alphaTyabs :: HOLType -> HOLTerm -> Either String HOLTerm

-- | Searches a term for a subterm that satisfies a given predicate. Fails
--   with <a>Nothing</a> if no such term is found.
findTerm :: (HOLTerm -> Bool) -> HOLTerm -> Maybe HOLTerm

-- | Searches a term for all unique subterms that satisfy a given
--   predicate.
findTerms :: (HOLTerm -> Bool) -> HOLTerm -> [HOLTerm]

-- | Searches a term for a subterm that satisfies a given predicate,
--   returning a string that indicates the path to that subterm:
--   
--   <ul>
--   <li><tt>'b'</tt> - Take the body of an abstraction.</li>
--   <li><tt>'t'</tt> - Take the body of a type abstraction.</li>
--   <li><tt>'l'</tt> - Take the left path in a term combination.</li>
--   <li><tt>'r'</tt> - Take the right path in a term combination.</li>
--   <li><tt>'c'</tt> - Take the body in a type combination.</li>
--   </ul>
--   
--   Fails with <a>Nothing</a> if there is no satisfying subterm.
findPath :: (HOLTerm -> Bool) -> HOLTerm -> Maybe String

-- | Returns the subterm found by following a <a>String</a> path as
--   produced by <a>findPath</a>. Fails with <a>Nothing</a> if the provided
--   term does not a suitable subterm for the given path.
followPath :: String -> HOLTerm -> Maybe HOLTerm

-- | Returns the list of all free type variables in a theorem.
typeVarsInThm :: HOLThm -> [HOLType]

-- | Returns the list of all free term variables in a theorem.
thmFrees :: HOLThm -> [HOLTerm]

-- | Constructs a complex combination that represents the application of a
--   function to a list of arguments. Fails with <a>Left</a> if any
--   internal call to <a>mkComb</a> fails.
listMkComb :: HOLTerm -> [HOLTerm] -> Either String HOLTerm

-- | Constructs a complex abstraction that represents a term with multiple
--   bound variables. Fails with <a>Left</a> if any internal call to
--   <a>mkAbs</a> fails.
listMkAbs :: [HOLTerm] -> HOLTerm -> Either String HOLTerm

-- | Constructs a list of term variables of a given prefix. Names are
--   adjusted as necessary with <a>variant</a> to avoid clashing with the
--   provided list of term variables. The number and types of the resultant
--   variables is directed by the provided list of types, i.e.
--   
--   <pre>
--   mkArgs "x" avoids [ty1, ... tyn] === [x1:ty1, ..., xn:tyn] where {x1, ..., xn} are not elements of avoids
--   </pre>
mkArgs :: String -> [HOLTerm] -> [HOLType] -> [HOLTerm]

-- | Returns the left term of a combination. Fails with <a>Nothing</a> if
--   the provided term is not a combination.
rator :: HOLTerm -> Maybe HOLTerm

-- | Returns the right term of a combination. Fails with <a>Nothing</a> if
--   the provided term is not a combination.
rand :: HOLTerm -> Maybe HOLTerm

-- | Returns the bound term of an abstraction. Fails with <a>Nothing</a> if
--   the provided term is not an abstraction.
bndvar :: HOLTerm -> Maybe HOLTerm

-- | Returns the body term of an abstraction. Fails with <a>Nothing</a> if
--   the provided term is not an abstraction.
body :: HOLTerm -> Maybe HOLTerm

-- | Returns the bound type of a type abstraction. Fails with
--   <a>Nothing</a> if the provided term is not a type abstraction.
bndvarTyabs :: HOLTerm -> Maybe HOLType

-- | Returns the body term of a type abstraction. Fails with <a>Nothing</a>
--   if the provided term is not a type abstraction.
bodyTyabs :: HOLTerm -> Maybe HOLTerm

-- | Destructs a complex combination returning its function term and its
--   list of argument terms.
stripComb :: HOLTerm -> (HOLTerm, [HOLTerm])

-- | Destructs a complex abstraction returning its list of bound variables
--   and its body term.
stripAbs :: HOLTerm -> ([HOLTerm], HOLTerm)

-- | Computes a tiplet of substitution environments that can be used to
--   make two types match. The triplet argument can be used to constrain
--   the match, or its three environments can be left empty to find the
--   most general match. Fails with <a>Nothing</a> in the event that a
--   match cannot be found that satisfies the provided constraint.
typeMatch :: HOLType -> HOLType -> SubstTrip -> Maybe SubstTrip

-- | Constructs an instance of a constant of the provided name and type.
--   Relies internally on <a>typeMatch</a> in order to provide a match
--   between the most general type of the constant and the provided type.
--   Throws a <a>HOLException</a> in the following cases:
--   
--   <ul>
--   <li>The provided string is not the name of a defined constant.</li>
--   <li>Type matching fails.</li>
--   </ul>
mkMConst :: String -> HOLType -> HOL cls thry HOLTerm

-- | A version of <a>mkComb</a> that instantiates the type variables in the
--   left hand argument. Relies internally on <a>typeMatch</a> in order to
--   provide a match between the domain type of the function and the type
--   of the argument. Fails with <a>Nothing</a> if instantiation is
--   impossible.
mkIComb :: HOLTerm -> HOLTerm -> Maybe HOLTerm

-- | An iterative version of <a>mkIComb</a> that builds a complex
--   combination given a constant name and a list of arguments, attempting
--   to find a correct instantiation at every step. Throws a
--   <a>HOLException</a> in the following cases:
--   
--   <ul>
--   <li>The provided name is not a currently defiend constant.</li>
--   <li>Any internal call to mkIComb fails.</li>
--   </ul>
listMkIComb :: String -> [HOLTerm] -> HOL cls thry HOLTerm

-- | Predicate that tests if a term is a binary application whose operator
--   has the given name.
isBinary :: String -> HOLTerm -> Bool

-- | A version of <a>isBinary</a> that tests for operator terms, not
--   strings.
isBinop :: HOLTerm -> HOLTerm -> Bool

-- | Destructs a binary application returning its left and right arguments.
--   Fails with <a>Nothing</a> if the provided term is not a binary
--   application with the specified operator name.
destBinary :: String -> HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | A version of <a>destBinary</a> that tests for operator terms, not
--   strings.
destBinop :: HOLTerm -> HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Constructs a binary application given a constant name and two argument
--   terms. Note that no instantiation is performed, thus the constant must
--   be monomorphic or the provided arguments must match the constant's
--   general type. Throws a <a>HOLException</a> if any of the internal
--   calls to <a>mkConst</a> or <a>mkComb</a> fail.
mkBinary :: String -> HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | A version of <a>mkBinary</a> that accepts the operator as a
--   pre-constructed term.
mkBinop :: HOLTerm -> HOLTerm -> HOLTerm -> Either String HOLTerm

-- | Iteratively builds a complex combination using <a>mkBinop</a>, i.e.
--   
--   <pre>
--   listMkBinop (/\) [T, F, T] === T /\ F /\ T
--   </pre>
listMkBinop :: HOLTerm -> [HOLTerm] -> Either String HOLTerm

-- | The inverse of <a>listMkBinop</a>. Destructs a complex combination
--   built with a binary operator into its list of arguments.
binops :: HOLTerm -> HOLTerm -> [HOLTerm]

-- | Predicate for generalized abstractions. See <a>mkGAbs</a> for more
--   details.
isGAbs :: HOLTerm -> Bool

-- | Predicate that tests if a term is an abstraction of specified binder
--   name.
isBinder :: String -> HOLTerm -> Bool

-- | Predicate that tests if a term is an abtraction of a specified type
--   binder name.
isTyBinder :: String -> HOLTerm -> Bool

-- | Destructor for generalized abstractions. Fails with <a>Nothing</a> if
--   the provided term is not an abstraction or generalized abstraction.
--   See <a>mkGAbs</a> for more details.
destGAbs :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructs an abstraction of specified binder name into its bound
--   variable and its body term. Fails with <a>Nothing</a> if the provided
--   term is not an abstraction with the specified binder name.
destBinder :: String -> HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructs a type abstraction of specified binder name into its bound
--   type variable and its body term. Fails with <a>Nothing</a> if the
--   provided term is not a type abstraction with the specified type binder
--   name.
destTyBinder :: String -> HOLTerm -> Maybe (HOLType, HOLTerm)

-- | Constructor for generalized abstractions. Generalized abstractions
--   extend term abstractions to the more general of notion of a function
--   mapping some structure to some term. This allows us to bind patterns
--   more complicated than a variable, i.e. binding pairs
--   
--   <pre>
--   \ (x:num, y:num) -&gt; x + y
--   </pre>
--   
--   or lists
--   
--   <pre>
--   \ CONS x xs -&gt; x
--   </pre>
--   
--   Note that in the case where the pattern to bind is simply a variable
--   <a>mkGAbs</a> just calls <a>mkAbs</a>.
mkGAbs :: HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructs an abstraction given a binder name and two argument terms.
--   Throws a <a>HOLException</a> if any of the internal calls to
--   <a>mkConst</a>, <a>mkAbs</a>, or <a>mkComb</a> fail.
--   
--   Note that the given string can actually be any constant name of type
--   <tt>(A -&gt; *) -&gt; *</tt>, such that a well-typed term of the form
--   <tt>c (\x . t)</tt> can be produced.
mkBinder :: String -> HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructs a type abstraction given a type binder name, a type
--   variable to find, and a body term. Throws a <a>HOLException</a> if any
--   of the internal calls to <a>mkConst</a>, <a>mkTyAbs</a>, or
--   <a>mkComb</a> fail.
--   
--   Note that the given string can actually be any constant name of type
--   <tt>(% 'a . *) -&gt; *</tt>, such that a well-typed term of the form
--   <tt>c (\\x . t)</tt> can be produced.
mkTyBinder :: String -> HOLType -> HOLTerm -> HOL cls thry HOLTerm

-- | A specific version of <a>listMkAbs</a> for general abstractions.
listMkGAbs :: [HOLTerm] -> HOLTerm -> HOL cls thry HOLTerm

-- | A specific version of <a>stripAbs</a> for general abstractions.
stripGAbs :: HOLTerm -> ([HOLTerm], HOLTerm)

-- | Predicate for boolean conjunctions.
isConj :: HOLTerm -> Bool

-- | Predicate for boolean implications.
isImp :: HOLTerm -> Bool

-- | Predicate for universal term quantification.
isForall :: HOLTerm -> Bool

-- | Predicate for existential term quantification.
isExists :: HOLTerm -> Bool

-- | Predicate for boolean disjunctions.
isDisj :: HOLTerm -> Bool

-- | Predicate for boolean negations.
isNeg :: HOLTerm -> Bool

-- | Predicate for unique, existential quantification.
isUExists :: HOLTerm -> Bool

-- | Predicate for term-level universal type quantification.
isTyAll :: HOLTerm -> Bool

-- | Predicate for term-level existential type quantification.
isTyEx :: HOLTerm -> Bool

-- | Destructor for boolean conjunctions.
destConj :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructor for boolean implications.
destImp :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructor for universal term quantification.
destForall :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructor for existential term quantification.
destExists :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructor for boolean disjunctions.
destDisj :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructor for boolean negations.
destNeg :: HOLTerm -> Maybe HOLTerm

-- | Destructor for unique, existential quantification.
destUExists :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructor for term-level universal type quantification.
destTyAll :: HOLTerm -> Maybe (HOLType, HOLTerm)

-- | Destructor for term-level existential type quantification.
destTyEx :: HOLTerm -> Maybe (HOLType, HOLTerm)

-- | Constructor for boolean conjunctions. Throws a <a>HOLException</a> if
--   the internal call to <a>mkBinary</a> fails.
mkConj :: HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructor for boolean implications. Throws a <a>HOLException</a> if
--   the internal call to <a>mkBinary</a> fails.
mkImp :: HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructor for universal term quantification. Throws a
--   <a>HOLException</a> if the internal call to <a>mkBinder</a> fails.
mkForall :: HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructor for existential term quantification. Throws a
--   <a>HOLException</a> if the internal call to <a>mkBinder</a> fails.
mkExists :: HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructor for boolean disjunctions. Throws a <a>HOLException</a> if
--   the internal call to <a>mkBinary</a> fails.
mkDisj :: HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructor for boolean negations. Throws a <a>HOLException</a> if any
--   of the internal calls to <a>mkConst</a> or <a>mkComb</a> fail.
mkNeg :: HOLTerm -> HOL cls thry HOLTerm

-- | Constructor for unique, existential term quantification. Throws a
--   <a>HOLException</a> if the internal call to <a>mkBinder</a> fails.
mkUExists :: HOLTerm -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructor for term-level universal type quantification. Throws a
--   <a>HOLException</a> if the internal call to <a>mkTyBinder</a> fails.
mkTyAll :: HOLType -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructor for term-level existential type quantification. Throws a
--   <a>HOLException</a> if the internal call to <a>mkTyBinder</a> fails.
mkTyEx :: HOLType -> HOLTerm -> HOL cls thry HOLTerm

-- | Constructs a complex conjunction from a given list of propositions.
listMkConj :: [HOLTerm] -> HOL cls thry HOLTerm

-- | Constructs a complex disjunction from a given list of propositions.
listMkDisj :: [HOLTerm] -> HOL cls thry HOLTerm

-- | A specific version of <a>listMkAbs</a> for universal term
--   quantification.
listMkForall :: [HOLTerm] -> HOLTerm -> HOL cls thry HOLTerm

-- | A specific version of <a>listMkAbs</a> for existential term
--   quantification.
listMkExists :: [HOLTerm] -> HOLTerm -> HOL cls thry HOLTerm

-- | Returns the list of propositions in a complex conjunction.
conjuncts :: HOLTerm -> [HOLTerm]

-- | Returns the list of propositions in a complex disjunction.
disjuncts :: HOLTerm -> [HOLTerm]

-- | A specific version of <a>stripAbs</a> for universal term
--   quantification.
stripForall :: HOLTerm -> ([HOLTerm], HOLTerm)

-- | A specific version of <a>stripAbs</a> for existential term
--   quantification.
stripExists :: HOLTerm -> ([HOLTerm], HOLTerm)

-- | A specific version of <a>stripAbs</a> for term-level universal type
--   quantification.
stripTyAll :: HOLTerm -> ([HOLType], HOLTerm)

-- | A specific version of <a>stripAbs</a> for term-level existential type
--   quantification.
stripTyEx :: HOLTerm -> ([HOLType], HOLTerm)

-- | Predicate for list <tt>CONS</tt>.
isCons :: HOLTerm -> Bool

-- | Predicate for list terms.
isList :: HOLTerm -> Bool

-- | Predicate for let binding terms.
isLet :: HOLTerm -> Bool

-- | Destructor for list <tt>CONS</tt>.
destCons :: HOLTerm -> Maybe (HOLTerm, HOLTerm)

-- | Destructor for list terms. Returns a list of the elements in the term.
--   Fails with <a>Nothing</a> if internall the term is not of the form
--   
--   <pre>
--   x1 `CONS` .... xn `CONS` NIL
--   </pre>
destList :: HOLTerm -> Maybe [HOLTerm]

-- | Destructs a let binding term into a list of its name and value pairs
--   and its body term. Fails with <a>Nothing</a> if internally the term is
--   not of the form
--   
--   <pre>
--   LET (x1, v1) ... (xn, vn) LET_END
--   </pre>
destLet :: HOLTerm -> Maybe ([(HOLTerm, HOLTerm)], HOLTerm)

-- | Converts a numeral term to an <a>Integer</a>. Fails with
--   <a>Nothing</a> if internally the term is not of the form
--   
--   <pre>
--   NUMERAL bits _0, where bits is a series of BIT0 and BIT1 terms  
--   </pre>
destNumeral :: HOLTerm -> Maybe Integer

-- | Internally, <a>Net</a>s are represented with a tree structure; each
--   node has a list of labeled branches and a list of values. The node
--   labels are generated via the following guidelines:
--   
--   <ul>
--   <li>Flattening of combinations favors the left hand side such that the
--   head of an application is looked at first.</li>
--   <li>If the head of an application is variable, the whole term is
--   considered variable.</li>
--   <li>Type abstractions and type combinations are effectively treated as
--   local constants, though they do have their own node lable
--   representations to avoid any potential issues with user provided
--   variable lists for <tt>enter</tt>.</li>
--   <li>Matching is conservative, such that all matching values will be
--   returned, but some non-matching values may be returned. For example, a
--   pattern term of the form <tt>x `op` x</tt> will match any term of the
--   form <tt>a `op` b</tt> regardless of the values of <tt>a</tt> and
--   <tt>b</tt>.</li>
--   </ul>
data Net a

-- | The empty <a>Net</a>.
netEmpty :: Net a

-- | Inserts a new element, paired with a pattern term, into a provided
--   net. The first argument is a list of variables that should be treated
--   as local constants, such that only patterns with those variables at
--   the exact same position will match. See the documentation for
--   <a>Net</a> for more details.
--   
--   Never fails.
netEnter :: Ord a => [HOLTerm] -> (HOLTerm, a) -> Net a -> HOL cls thry (Net a)

-- | Returns the list of all values stored in a term net that satisfy a
--   provided pattern term. See the documentation for <a>Net</a> for more
--   details.
netLookup :: HOLTerm -> Net a -> [a]

-- | Merges two term nets together. The values for the two nets are merged,
--   maintaining order and uniqueness, with the term labels adjusted
--   appropriately. The algorithm to do so is courtesy of Don Syme via John
--   Harrison's implementation in HOL Light.
netMerge :: Ord a => Net a -> Net a -> Net a


-- | This module defines the parsers for <tt>HOLType</tt>s and
--   <tt>HOLTerm</tt>s.
--   
--   It also re-exports the related benign flags, theory extension
--   mechanisms, and type/term elaborators.
--   
--   For examples of the parsers and elaborators in use see the
--   <a>HaskHOL.Core.TermRep</a> module.
module HaskHOL.Core.Parser

-- | Parsed, but pre-elaborated HOL terms.
data PreTerm

-- | Parsed, but pre-elaborated HOL types.
data PreType

-- | Flag to say whether to treat a constant varstruct, i.e. <tt>\ const .
--   bod</tt>, as variable.
data FlagIgnoreConstVarstruct
FlagIgnoreConstVarstruct :: FlagIgnoreConstVarstruct

-- | Flag indicating that the user should be warned if a type variable was
--   invented during parsing.
data FlagTyInvWarning
FlagTyInvWarning :: FlagTyInvWarning

-- | Flag indicating that the user should be warned if a type operator
--   variable was invented during parsing.
data FlagTyOpInvWarning
FlagTyOpInvWarning :: FlagTyOpInvWarning

-- | Flag to say whether implicit type applications are to be added during
--   parsing.
data FlagAddTyAppsAuto
FlagAddTyAppsAuto :: FlagAddTyAppsAuto

-- | Specifies a <a>String</a> to be recognized as a term binder by the
--   parser.
parseAsBinder :: String -> HOL Theory thry ()

-- | Specifies a <a>String</a> to be recognized as a type binder by the
--   parser.
parseAsTyBinder :: String -> HOL Theory thry ()

-- | Specifies a <a>String</a> to be recognized as a prefix operator by the
--   parser.
parseAsPrefix :: String -> HOL Theory thry ()

-- | Specifies a <a>String</a> to be recognized as an infix operator by the
--   parser with a given precedence level and associativity.
parseAsInfix :: (String, (Int, Assoc)) -> HOL Theory thry ()

-- | Specifies a <a>String</a> for the parser to stop recognizing as a term
--   binder.
unparseAsBinder :: String -> HOL Theory thry ()

-- | Specifies a <a>String</a> for the parser to stop recognizing as a type
--   binder.
unparseAsTyBinder :: String -> HOL Theory thry ()

-- | Specifies a <a>String</a> for the parser to stop recognizing as a
--   prefix operator.
unparseAsPrefix :: String -> HOL Theory thry ()

-- | Specifies a <a>String</a> for the parser to stop recognizing as an
--   infix operator.
unparseAsInfix :: String -> HOL Theory thry ()

-- | Returns all <a>String</a>s recognized as term binders by the parser.
binders :: HOLContext thry -> [String]

-- | Returns all <a>String</a>s recognized as type binders by the parser.
tyBinders :: HOLContext thry -> [String]

-- | Returns all <a>String</a>s recognized as prefix operators by the
--   parser.
prefixes :: HOLContext thry -> [String]

-- | Returns all <a>String</a>s recognized as infix operators by the parser
--   along with their precedence and associativity pairs.
infixes :: HOLContext thry -> [(String, (Int, Assoc))]

-- | Predicate for <a>String</a>s recognized as term binders by the parser.
parsesAsBinder :: String -> HOLContext thry -> Bool

-- | Predicate for <a>String</a>s recognized as term binders by the parser.
parsesAsTyBinder :: String -> HOLContext thry -> Bool

-- | Predicate for <a>String</a>s recognized as prefix operators by the
--   parser.
isPrefix :: String -> HOLContext thry -> Bool

-- | Predicate for <a>String</a>s recognized as infix operators by the
--   parser. Returns a precidence and associativity pair guarded by
--   <a>Maybe</a>.
getInfixStatus :: String -> HOLContext thry -> Maybe (Int, Assoc)

-- | Specifies a <a>String</a> that can act as an overloadable identifier
--   within the parser. The provided type is the most general type that
--   instances of this symbol may have. Throws a <a>HOLException</a> if the
--   given symbol has already been declared as overloadable with a
--   different type.
--   
--   Note that defining a symbol as overloadable will erase any interface
--   overloads that were previously introduced via <a>overrideInterface</a>
--   in order to guarantee that all overloads are matchable with their most
--   general type.
makeOverloadable :: String -> HOLType -> HOL Theory thry ()

-- | Removes all instances of an overloaded symbol from the interface.
removeInterface :: String -> HOL Theory thry ()

-- | Removes a specific instance of an overloaded symbol from the
--   interface. Throws a <a>HOLException</a> if the provided term is not a
--   constant or varible term representing an instance of the overloaded
--   symbol.
reduceInterface :: String -> HOLTerm -> HOL Theory thry ()

-- | Removes all existing overloads for a given symbol and replaces them
--   with a single, specific instance. Throws a <a>HOLException</a> if the
--   provided term is not a constant or variable term representing an
--   instance of the overloaded symbol.
--   
--   Note that because <a>overrideInterface</a> can introduce at most one
--   overload for a symbol it does not have to be previously defined as
--   overloadable via <a>makeOverloadable</a>. However, if the symbol is
--   defined as overloadable then the provided term must have a type that
--   is matchable with the symbol's most general type.
overrideInterface :: String -> HOLTerm -> HOL Theory thry ()

-- | Introduces a new overload for a given symbol. Throws a
--   <a>HOLException</a> in the following cases:
--   
--   <ul>
--   <li>The symbol has not previously been defined as overloadable via
--   <a>makeOverloadable</a>.</li>
--   <li>The provided term is not a constant or variable term representing
--   a specific instance of the overloaded symbol.</li>
--   <li>The provided term does not have a type that is matchable with the
--   overloadable symbol's specified most general type.</li>
--   </ul>
--   
--   Note that specifying an overload that already exists will move it to
--   the front of the interface list, effectively prioritizing it. This
--   behavior is utilized by <a>prioritizeOverload</a>.
overloadInterface :: String -> HOLTerm -> HOL Theory thry ()

-- | Specifies a type to prioritize when the interface is used to overload
--   a symbol. Note that this applies to all overloads in the system whose
--   match with the specified most general type involves the provided type.
--   Prioritization is done by redefining overloads via
--   <a>overloadInterface</a>.
prioritizeOverload :: HOLType -> HOL Theory thry ()

-- | Returns the list of all currently defined interface overloads.
getInterface :: HOLContext thry -> [(String, (String, HOLType))]

-- | Returns the list of all overloadable symbols paired with their most
--   generic types.
getOverloads :: HOLContext thry -> [(String, HOLType)]

-- | Specifies a <a>String</a> to act as an abbreviation for a given type
--   in the parser. Upon recognizing the abbreviation the parser will
--   replace it with the <a>PreType</a> value for it's associated
--   <a>HOLType</a> such that the elaborator can infer the correct type for
--   polymorphic abbreviations.
newTypeAbbrev :: String -> HOLType -> HOL Theory thry ()

-- | Specifies a <a>String</a> for the parser to stop recognizing as a type
--   abbreviation.
removeTypeAbbrev :: String -> HOL Theory thry ()

-- | Returns all <a>String</a>s currently acting as type abbreviations in
--   the parser paired with their associated types.
typeAbbrevs :: HOLContext thry -> [(String, HOLType)]

-- | Specifies a <a>String</a> for the parser to stop recognizing as a
--   constant.
hideConstant :: String -> HOL Theory thry ()

-- | Specifies a <a>String</a> for the parser to resume recognizing as a
--   constant.
unhideConstant :: String -> HOL Theory thry ()

-- | Returns all <a>String</a>s currently acting as constants hidden from
--   the parser.
getHidden :: HOLContext thry -> [String]

-- | Elaborator for <a>PreType</a>s.
tyElab :: PreType -> HOL cls thry HOLType

-- | Elaborator and type inference for <a>PreTerm</a>s.
elab :: PreTerm -> HOL cls thry HOLTerm

-- | Parser for <tt>HOLType</tt>s.
holTypeParser :: String -> HOLContext thry -> Either ParseError PreType

-- | Parser for <tt>HOLTerm</tt>s.
holTermParser :: String -> HOLContext thry -> Either ParseError PreTerm

-- | The <a>HOLTypeRep</a> class provides a conversion from an alternative
--   representation of types to <a>HOLType</a> within the <a>HOL</a> monad.
--   
--   The first parameter is the type of the alternative representation.
--   
--   The second parameter is the tag for the last checkpoint of the current
--   working theory. This enables us to have a conversion from
--   representations that are theory dependent without running into type
--   matchability issues.
class HOLTypeRep a thry | a -> thry
toHTy :: HOLTypeRep a thry => a -> HOL cls thry HOLType

-- | The <a>HOLTermRep</a> class provides a conversion from an alternative
--   representation of terms to <a>HOLTerm</a> within the <a>HOL</a> monad.
--   
--   The first parameter is the type of the alternative representation.
--   
--   The second parameter is the tag for the last checkpoint of the current
--   working theory. This enables us to have a conversion from
--   representations that are theory dependent, i.e. <tt>PTerm</tt>,
--   without running into type matchability issues.
class HOLTermRep a thry | a -> thry
toHTm :: HOLTermRep a thry => a -> HOL cls thry HOLTerm


-- | This module defines pretty printers for <a>HOLType</a>s,
--   <a>HOLTerm</a>s and <a>HOLThm</a>s. Note that the printers for terms
--   and theorems are context dependent as they rely on the same theory
--   extensions that the parsers utilize.
--   
--   To make printing these objects easier within HOL computations, this
--   module also defines the <a>showHOL</a> and <a>printHOL</a> methods
--   which will automatically retrieve the current working theory to use
--   for pretty printing. Because the pretty printer for <a>HOLType</a>s is
--   not context dependent it has definitions for both <a>show</a> and
--   <a>showHOL</a>.
--   
--   Note that, like the parser, there are a number of HOL term forms that
--   the printer does not currently support. Again, these are mainly
--   related to sets and patterns and will be added in when the HaskHOL
--   system has libraries for them.
module HaskHOL.Core.Printer

-- | Flag to indicate whether the interface should be reversed on printing.
data FlagRevInterface
FlagRevInterface :: FlagRevInterface

-- | Flag to indicate if the entirety of a theorem should be printed, as
--   opposed to just the conclusion term.
data FlagPrintAllThm
FlagPrintAllThm :: FlagPrintAllThm

-- | Specifies a symbol to be recognized as an unspaced, binary operator by
--   the printer. Applications involving these operators will be built with
--   the <a>&lt;&gt;</a> combinator as opposed to <a>&lt;+&gt;</a>.
--   
--   Note that technically this method should be considered benign,
--   however, for simplicity of implementation it is defined using
--   <a>modifyExt</a> and thus must be tagged a <a>Theory</a> computation.
addUnspacedBinop :: String -> HOL Theory thry ()

-- | Specifies a symbol to be recognized as a prebroken, binary operator by
--   the printer. Applications involving these operators will have their
--   right-hand side argument printed on the next line using the
--   <a>hang</a> combinator.
--   
--   Note that technically this method should be considered benign,
--   however, for simplicity of implementation it is defined using
--   <a>modifyExt</a> and thus must be tagged a <a>Theory</a> computation.
addPrebrokenBinop :: String -> HOL Theory thry ()

-- | Specifies a symbol to stop being recognized as an unspaced, binary
--   operator by the printer.
--   
--   Note that technically this method should be considered benign,
--   however, for simplicity of implementation it is defined using
--   <a>modifyExt</a> and thus must be tagged a <a>Theory</a> computation.
removeUnspacedBinop :: String -> HOL Theory thry ()

-- | Specifies a symbol to stop being recognized as an prebroken, binary
--   operator by the printer.
--   
--   Note that technically this method should be considered benign,
--   however, for simplicity of implementation it is defined using
--   <a>modifyExt</a> and thus must be tagged a <a>Theory</a> computation.
removePrebrokenBinop :: String -> HOL Theory thry ()

-- | Returns the list of all symbols current recognized as unspaced, binary
--   operators by the printer.
getUnspacedBinops :: HOLContext thry -> [String]

-- | Returns the list of all symbols current recognized as prebroken,
--   binary operators by the printer.
getPrebrokenBinops :: HOLContext thry -> [String]

-- | Pretty printer for <a>HOLType</a>s.
ppType :: HOLType -> String

-- | Pretty printer for <a>HOLTerm</a>s.
ppTerm :: HOLContext thry -> HOLTerm -> String

-- | Pretty printer for <tt>HOLTheorem</tt>s.
ppThm :: HOLContext thry -> HOLThm -> String

-- | The <tt>ShowHOL</tt> class is functionally equivalent to <a>show</a>
--   lifted to the <a>HOL</a> monad. It is used to retrieve the current
--   working theory to be used with the context sensitive pretty printers
--   for <a>HOLTerm</a>s and <a>HOLType</a>s.
class ShowHOL a thry
showHOL :: ShowHOL a thry => a -> HOL cls thry String

-- | Prints a HOL object with a new line. A composition of
--   <a>putStrLnHOL</a> and <a>showHOL</a>.
printHOL :: ShowHOL a thry => a -> HOL cls thry ()
instance [overlap ok] Lift PrebrokenBinops
instance [overlap ok] Lift UnspacedBinops
instance [overlap ok] Typeable PrebrokenBinops
instance [overlap ok] ShowHOL HOLThm thry
instance [overlap ok] ShowHOL HOLTerm thry
instance [overlap ok] ShowHOL HOLType thry
instance [overlap ok] ShowHOL TypeOp thry
instance [overlap ok] ShowHOL Assoc thry
instance [overlap ok] (ShowHOL a thry, ShowHOL b thry, ShowHOL c thry, ShowHOL d thry) => ShowHOL (a, b, c, d) thry
instance [overlap ok] (ShowHOL a thry, ShowHOL b thry, ShowHOL c thry) => ShowHOL (a, b, c) thry
instance [overlap ok] (ShowHOL a thry, ShowHOL b thry) => ShowHOL (a, b) thry
instance [overlap ok] ShowHOL a thry => ShowHOL [a] thry
instance [overlap ok] ShowHOL String thry
instance [overlap ok] ExtClass PrebrokenBinops
instance [overlap ok] Typeable UnspacedBinops
instance [overlap ok] ExtClass UnspacedBinops
instance [overlap ok] Typeable FlagPrintAllThm
instance [overlap ok] BenignFlag FlagPrintAllThm
instance [overlap ok] Typeable FlagRevInterface
instance [overlap ok] BenignFlag FlagRevInterface


-- | This module exports HaskHOL's non-trivial extensions to the underlying
--   HOL system, i.e. the compile time operations. These operations are
--   split into three categories:
--   
--   <ul>
--   <li>Methods related to the Protect and Serve Mechanism for sealing and
--   unsealing data against a provided theory context.</li>
--   <li>Methods related to quasi-quoting of <a>HOLTerm</a>s.</li>
--   <li>Methods related to compile time extension and caching of theory
--   contexts.</li>
--   </ul>
module HaskHOL.Core.Ext

-- | The Protected class is the associated type class that facilitates our
--   protect/serve protection mechanism.
--   
--   It defines:
--   
--   <ul>
--   <li>A data wrapper for our protected type.</li>
--   <li>Conversions to/from this new type, protect and serve.</li>
--   <li>Some boilerplate code to enable template haskell lifting.</li>
--   </ul>
class Lift a => Protected a where data family PData a thry
protect :: Protected a => HOLContext thry -> a -> PData a thry
serve :: Protected a => PData a thry -> HOL cls thry a

-- | Type synonym for protected <a>HOLType</a>s.
type PType thry = PData HOLType thry

-- | Type synonym for protected <a>HOLTerm</a>s.
type PTerm thry = PData HOLTerm thry

-- | Type synonym for protected <a>HOLThm</a>s.
type PThm thry = PData HOLThm thry

-- | Lifts a protected data value as an expression using an ascribed type.
--   For example:
--   
--   <pre>
--   liftProtectedExp (x::PData a Bool)
--   </pre>
--   
--   produces the following spliceable expression
--   
--   <pre>
--   [| x :: forall thry. BoolCtxt thry =&gt; PData a Bool |]
--   </pre>
liftProtectedExp :: (Protected a, Typeable thry) => PData a thry -> Q Exp

-- | Lifts a protected data value as a declaration of a given name with an
--   ascribed type signature. For example:
--   
--   <pre>
--   liftProtected "protX" (x::PData a Bool)
--   </pre>
--   
--   produces the following list of spliceable declarations
--   
--   <pre>
--   [ [d| protX :: forall thry. BoolCtxt thry =&gt; PData a Bool |]
--   , [d| protX = x |] ]
--   </pre>
--   
--   See <a>extractAxiom</a> for a basic example of how this function may
--   be used.
liftProtected :: (Protected a, Typeable thry) => String -> PData a thry -> Q [Dec]

-- | Evaluates a proof compilation, protects it with the theory used to
--   evaluate it, and then lifts it as a declaration of a given name with
--   an ascribed type signature.
--   
--   Relies internally on <a>protect</a> and <a>liftProtected</a> to
--   guarantee that the resultant theorem is sealed with the right type.
proveCompileTime :: Typeable thry => HOLContext thry -> String -> HOL Proof thry HOLThm -> Q [Dec]

-- | A version of <a>proveCompileTime</a> that works for a proof
--   computation returning multiple theorems.
--   
--   Note that each resultant theorem must have a unique, provided name.
proveCompileTimeMany :: Typeable thry => HOLContext thry -> [String] -> HOL Proof thry [HOLThm] -> Q [Dec]

-- | Extracts a basic term definition from a provided context, protecting
--   and lifting it with <a>liftProtected</a>. The extraction is performed
--   by looking for a definition whose left hand side matches a provided
--   constant name. For example:
--   
--   <pre>
--   extractBasicDefinition ctxtBool "defT" "T"
--   </pre>
--   
--   will return the spliceable list of declarations for the following
--   theorem
--   
--   <pre>
--   |- T = ( p:bool . p) = ( p:bool . p)
--   </pre>
extractBasicDefinition :: Typeable thry => HOLContext thry -> String -> String -> Q [Dec]

-- | Extracts an axiom from a provided context, protecting and lifting it
--   with <a>liftProtected</a>. The extraction is performed by looking for
--   an axioms of a given name, as specified when the axiom was created
--   with <a>newAxiom</a>.
extractAxiom :: Typeable thry => HOLContext thry -> String -> Q [Dec]

-- | This is the base quasi-quoter for the HaskHOL system. When provided
--   with a theory context value, it constucts a theory specific
--   quasi-quoter that parses a <a>String</a> as a term, protecting and
--   lifting the result.
--   
--   Note that, at this point in time, we only allowing quoting at the
--   expression level.
baseQuoter :: Typeable thry => HOLContext thry -> QuasiQuoter

-- | An instance of <a>baseQuoter</a> for the core theory context,
--   <a>ctxtBase</a>. Example:
--   
--   <pre>
--   [base| x = y |]
--   </pre>
--   
--   will parse the provided string and construct the <tt>HOLTerm</tt>
--   <tt>x = y</tt> at compile time. Note that this term is protected, such
--   that it has to be accessed via <a>serve</a>. This is advantageous in
--   computations that may be run many times, for example:
--   
--   <pre>
--   do tm &lt;- serve [base| x = y |]
--      ...
--   </pre>
--   
--   will parse the term exactly once, only checking the <tt>thry</tt> tag
--   of the computation for each evaluation. Conversely,
--   
--   <pre>
--   do tm &lt;- toHTm "x = y"
--      ...
--   </pre>
--   
--   will parse the term for every evaluation of that computation.
--   Generally, the use of <a>toHTm</a> is reserved for run time parsing
--   and in larger computations that themselves are evaluated at copmile
--   time to minimize the amount of work Template Haskell has to do.
base :: QuasiQuoter

-- | This is a specialized quasi-quoter for <a>String</a>s. It can be used
--   to strip white space and automatically escape special characters. It
--   is typically used in conjunction with <a>toHTm</a> directly or
--   indirectly.
str :: QuasiQuoter

-- | Extends a theory by evaluating a provided computation, returning a
--   list of declarations containing:
--   
--   <ul>
--   <li>A new empty data declaration associated with the new theory.</li>
--   <li>A new type class associated with the new theory to be used with
--   <tt>DerivedCtxt</tt> along with the appropriate instances.</li>
--   <li>The context value for the new theory.</li>
--   <li>A class constraint alias that can be safely exported for use in
--   type signatures external to the library where it was defined.</li>
--   <li>A quasiquoter for the new theory.</li>
--   <li>A compile-time proof function for the new theory.</li>
--   </ul>
--   
--   For example:
--   
--   <pre>
--   extendCtxt ctxtBase loadBoolLib "bool"
--   </pre>
--   
--   will produce the following code
--   
--   <pre>
--   data BoolThry deriving Typeable
--   type BoolType = ExtThry BoolThry BaseThry
--   
--   class BaseCtxt a =&gt; BoolContext a
--   instance BaseCtxt b =&gt; BoolContext (ExtThry BoolThry b)
--   instance BoolContext b =&gt; BoolContext (ExtThry a b)
--   
--   class BoolContext a =&gt; BoolCtxt a
--   instance BoolContext a =&gt; BoolCtxt a
--   
--   ctxtBool :: HOLContext BoolType
--   ctxtBool = ...
--   
--   bool :: QuasiQuoter
--   bool = baseQuoter ctxtBool
--   
--   proveBool :: String -&gt; HOL Proof BoolType HOLThm -&gt; Q [Dec]
--   proveBool = proveCompileTime ctxtBool
--   
--   proveBoolMany :: [String] -&gt; HOL Proof BoolType [HOLThm] -&gt; Q [Dec]
--   proveBoolMany = proveCompileTimeMany ctxtBool
--   </pre>
extendCtxt :: Typeable thry => HOLContext thry -> HOL cls thry () -> String -> Q [Dec]


-- | This module is the one to import for users looking to include the
--   entirety of the core of the HaskHOL proof system. It re-exports all of
--   the core sub-modules in addition to a number of overloaded functions
--   that work with <a>HOLTermRep</a> and <a>HOLTypeRep</a> representations
--   for convenience reasons.
module HaskHOL.Core

-- | A redefinition of <a>newConstant</a> to overload it for all valid term
--   representations as defined by <a>HOLTermRep</a>.
newConstant :: HOLTypeRep ty thry => String -> ty -> HOL Theory thry ()

-- | A redefinition of <a>newAxiom</a> to overload it for all valid term
--   representations as defined by <a>HOLTermRep</a>.
newAxiom :: HOLTermRep tm thry => String -> tm -> HOL Theory thry HOLThm

-- | A redefinition of <a>newBasicDefinition</a> to overload it for all
--   valid term representations as defined by <a>HOLTermRep</a>.
newBasicDefinition :: HOLTermRep tm thry => tm -> HOL Theory thry HOLThm

-- | A redefinition of <a>makeOverloadable</a> to overload it for all valid
--   type representations as defined by <a>HOLTypeRep</a>.
makeOverloadable :: HOLTypeRep ty thry => String -> ty -> HOL Theory thry ()

-- | A redefinition of <a>reduceInterface</a> to overload it for all valid
--   term representations as defined by <a>HOLTermRep</a>.
reduceInterface :: HOLTermRep tm thry => String -> tm -> HOL Theory thry ()

-- | A redefinition of <a>overrideInterface</a> to overload it for all
--   valid term representations as defined by <a>HOLTermRep</a>.
overrideInterface :: HOLTermRep tm thry => String -> tm -> HOL Theory thry ()

-- | A redefinition of <a>overloadInterface</a> to overload it for all
--   valid term representations as defined by <a>HOLTermRep</a>.
overloadInterface :: HOLTermRep tm thry => String -> tm -> HOL Theory thry ()

-- | A redefinition of <a>prioritizeOverload</a> to overload it for all
--   valid type representations as defined by <a>HOLTypeRep</a>.
prioritizeOverload :: HOLTypeRep ty thry => ty -> HOL Theory thry ()

-- | A redefinition of <a>newTypeAbbrev</a> to overload it for all valid
--   type representations as defined by <a>HOLTypeRep</a>.
newTypeAbbrev :: HOLTypeRep ty thry => String -> ty -> HOL Theory thry ()
