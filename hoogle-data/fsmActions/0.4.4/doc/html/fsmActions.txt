-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Finite state machines and FSM actions
--   
--   This is a library for representing and manipulating finite state
--   machines (FSMs) in Haskell, with an emphasis on computing the effects
--   of sequences of transitions across entire machines (which we call
--   actions), and in particular investigating action equivalences between
--   such sequences.
@package fsmActions
@version 0.4.4


-- | Error handling for FSMs.
module Data.FsmActions.Error

-- | Errors when reading matrices from strings.
data FsmError
FsmError :: String -> String -> FsmError

-- | Explanatory message
msg :: FsmError -> String

-- | Offending value
value :: FsmError -> String

-- | Error monad for reading FSMs in.
type ReadFsmMonad = Either FsmError
instance Typeable FsmError
instance Eq FsmError
instance Show FsmError
instance Error FsmError
instance Exception FsmError


-- | Finite state machines.
--   
--   Here an <a>FSM</a> is a map from symbols to actions. Symbols are
--   parametric (will usually be Strings or Chars). <a>Action</a>s specify
--   the action of a symbol on each state, and are represented as lists of
--   transitions: one per state. States are just numbers, from 0 to n,
--   corresponding to indices on transition lists in <a>Action</a>s. Then
--   deterministic actions are just Ints, identifying the state to
--   transition to under that action; nondeterministic actions are lists of
--   Ints: all the states to possibly transition to under that action.
module Data.FsmActions

-- | States are integers, counting from zero.
type State = Int

-- | Destination sets are just lists of <a>State</a>s.
newtype DestinationSet
DestinationSet :: [State] -> DestinationSet
destinations :: DestinationSet -> [State]

-- | Actions are lists of <tt>DestinationSets</tt>, indexed by source
--   <a>State</a>.
newtype Action
Action :: [DestinationSet] -> Action
destinationSets :: Action -> [DestinationSet]

-- | Finite state machine whose nodes are labelled with type sy.
data FSM sy

-- | Words are lists of symbols.
newtype Word sy
Word :: [sy] -> Word sy

-- | Create an FSM from a list of symbol, Action pairs.
fromList :: Ord sy => [(sy, Action)] -> FSM sy

-- | Turn an FSM into a list of symbol, Action pairs.
toList :: FSM sy -> [(sy, Action)]

-- | Delete a symbol and its action from an FSM.
delete :: Ord sy => sy -> FSM sy -> FSM sy

-- | Look up a symbol's <a>Action</a> in an <a>FSM</a>
lookup :: Ord sy => sy -> FSM sy -> Maybe Action

-- | Map a function over the FSM.
fsmMap :: (sy -> Action -> a) -> FSM sy -> [a]

-- | Compute the list of states of the <a>FSM</a>. Only really meaningful
--   if the FSM's well-formedness is not <tt>BadLengths</tt>. With current
--   implementation, is just [0..n] for some n (or empty).
states :: FSM sy -> [State]

-- | Compute the alphabet of an <a>FSM</a>.
alphabet :: FSM sy -> [sy]

-- | Normalise an <a>FSM</a>, i.e. normalise all its <tt>Actions</tt>.
normalise :: FSM sy -> FSM sy
normaliseAction :: Action -> Action

-- | Build an action given a nested list of destination states.
mkAction :: [[State]] -> Action

-- | Build a deterministic action given a list of destination states.
mkDAction :: [State] -> Action

-- | Append two <a>Action</a>s, ie compute the <a>Action</a> corresponding
--   to the application of the first followed by the second.
append :: Action -> Action -> Action

-- | Compute the <a>DestinationSet</a> reached by following some
--   <a>Action</a> from some <a>State</a>.
actionLookup :: Action -> State -> DestinationSet

-- | Compute the <a>Action</a> for some <a>Word</a> over some <a>FSM</a>.
--   The word might contain symbols outside the FSM's alphabet, so the
--   result could be Nothing.
action :: Ord sy => FSM sy -> Word sy -> Maybe Action

-- | Test if two <a>Word</a>s are action-equivalent over some FSM.
actionEquiv :: Ord sy => FSM sy -> Word sy -> Word sy -> Bool

-- | Compute the <a>DestinationSet</a> for some <a>Word</a> at some
--   <a>State</a> of an <a>FSM</a>. The word might contain symbols outside
--   the FSM's alphabet, or the state might be out of range, so the result
--   could be Nothing.
destinationSet :: Ord sy => FSM sy -> State -> Word sy -> Maybe DestinationSet

-- | Test if two <a>Word</a>s are destination-equivalent at some
--   <a>State</a> of an <a>FSM</a>.
destinationEquiv :: Ord sy => FSM sy -> State -> Word sy -> Word sy -> Bool

-- | Compute the identity action for a given FSM.
fsmIdentity :: FSM sy -> Action

-- | Compute the identity action for a given number of states
identity :: Int -> Action

-- | Test if an <a>Action</a> is deterministic or not.
isDAction :: Action -> Bool

-- | Compute whether an <a>FSM</a> is deterministic or not.
isDFSM :: FSM sy -> Bool
instance Eq DestinationSet
instance Ord DestinationSet
instance Show DestinationSet
instance Eq Action
instance Ord Action
instance Show Action
instance Eq sy => Eq (FSM sy)
instance Ord sy => Ord (FSM sy)
instance Show sy => Show (FSM sy)


-- | Well-formedness checks for finite state machines.
module Data.FsmActions.WellFormed

-- | An <a>FSM</a> is well-formed if all its actions are the same length,
--   none of its actions contain destinations which are out of range, and
--   it is not disjoint.
data WellFormed sy

-- | Lengths of Actions in the <a>FSM</a> don't all match. Carries a sorted
--   list of (symbol, <a>Action</a> length) pairs, one for every symbol in
--   the alphabet of the <a>FSM</a>.
BadLengths :: [(sy, Int)] -> WellFormed sy

-- | Some <a>Action</a>s contain out-of-range (negative or too-high)
--   destinations. Carries a sorted list of all such actions and their
--   corresponding symbols.
BadActions :: [(sy, Action)] -> WellFormed sy

-- | The FSM is disconnected, i.e. not even weakly-connected. Carries a
--   list of its weakly-connected components (each is a list of
--   <a>State</a>s).
Disconnected :: [[State]] -> WellFormed sy

-- | Well-formed.
WellFormed :: WellFormed sy

-- | Check if an <a>FSM</a> is well-formed or not.
isWellFormed :: Ord sy => FSM sy -> WellFormed sy

-- | Given an FSM, normalise it and check it's well-formed.
--   
--   This should be called whenever an FSM is read/computed from an outside
--   source. If parsing, the right time to call this is immediately after
--   you've decided if the parse of the FSM was successful or not. (In
--   other words, here are some static checks!)
polishFSM :: (Ord sy, Show sy) => FSM sy -> ReadFsmMonad (FSM sy)
instance Eq sy => Eq (WellFormed sy)
instance Show sy => Show (WellFormed sy)


-- | Serialisation/deserialisation of <a>FSM</a>s and <a>Action</a>s as
--   binary adjacency matrices.
--   
--   An <a>Action</a> may be represented as an adjacency matrix of 0s and
--   1s. The rows and columns of the matrix correspond to states of an
--   <a>FSM</a>: a 1 in a cell indicates that the <a>Action</a> causes a
--   transition from the 'row' state to the 'column' state. If any of the
--   rows in the matrix contain more than one 1, the corresponding
--   <a>Action</a> and <a>FSM</a> will be nondeterministic.
--   
--   An ActionSpecFile is a list of (symbol string, path to ActionMatrix
--   file) pairs. Its syntax is as follows:
--   
--   <ul>
--   <li>Symbols, and paths, should all be enclosed in double quotes (with
--   the nice side-effect that spaces are thus allowed).</li>
--   <li>A symbol/path pair is separated by whitespace.</li>
--   <li>The list of symbol/path pairs is delimited by semicolons (and
--   optional whitespace). A trailing semicolon is optional.</li>
--   <li>Line comments, starting with -- (as in Haskell), are allowed
--   anywhere whitespace is allowed.</li>
--   </ul>
module Data.FsmActions.ActionMatrix

-- | Load an <a>FSM</a> from action matrices, given a path to an ActionSpec
--   file.
loadActionMxFsm :: FilePath -> IO (FSM String)

-- | Save an <a>FSM</a> to an ActionSpec file (whose path is specified) and
--   a set of action matrices (whose paths may be optionally specified
--   using a (label, path) association list).
saveActionMxFsm :: FSM String -> FilePath -> [(String, FilePath)] -> IO ()

-- | Given a (symbol, path) association list, compute an <a>FSM</a> whose
--   actions are read from action matrices in the specified paths, and
--   associated with their corresponding symbols.
parseFsmActionMxFiles :: (Ord sy, Show sy) => [(sy, FilePath)] -> IO (FSM sy)

-- | Given a (symbol, ActionMatrix string) association list, parse the
--   strings and construct an FSM. Includes normalisation and
--   well-formedness checks. Parse errors in individual action strings
--   result in an error here (ReadFsmMonad is in the Either monad).
--   
--   Note that if the same symbol appears multiple times, only one instance
--   will appear in the <a>FSM</a>; the choice of which appears is not
--   defined.
parseFsmActionMxs :: (Ord sy, Show sy) => [(sy, String)] -> ReadFsmMonad (FSM sy)

-- | Parse an action matrix string, and turn it into an <a>Action</a>.
parseActionMx :: String -> ReadFsmMonad Action

-- | Pretty-print a string FSM into an ActionSpec string and an
--   (ActionMatrix path, ActionMatrix string) association list. (The paths
--   will be interpreted relative to the ActionSpec's location.) Filenames
--   (per action label) may be specified by providing a (label, path)
--   association list; whenever a lookup in that list fails, a default is
--   computed from the label.
printFsmActionMx :: FSM String -> [(String, FilePath)] -> (String, [(FilePath, String)])

-- | Pretty-print an action in action matrix format.
printActionMx :: Action -> String


-- | Generating, interpreting, and drawing graphs of FSMs.
--   
--   Includes:
--   
--   <ul>
--   <li>Interface to fgl graph library for graph input/output
--   (<a>http://hackage.haskell.org/package/fgl</a>).</li>
--   <li>Interface to graphviz library for dot output
--   (<a>http://hackage.haskell.org/package/graphviz</a>).</li>
--   <li>Home-grown GML (Graph Modelling Language) output.</li>
--   </ul>
module Data.FsmActions.Graph

-- | When converting an <a>FSM</a> into a graph, do we keep all self-loops,
--   or only those which are sources of nondeterminism?
data SelfLoops

-- | Keep them all
Keep :: SelfLoops

-- | Trim any which aren't nondeterminism sources.
Trim :: SelfLoops

-- | Turn an FSM into an fgl graph with labelled edges.
fsmToFGL :: FSM sy -> SelfLoops -> Gr () sy
fglDot :: (Ord b, Labellable b, Graph gr) => gr a b -> DotGraph Int

-- | Compute an FSM's strongly-connected components.
strongCCs :: Eq sy => FSM sy -> [[State]]

-- | Compute an FSM's weakly-connected components.
weakCCs :: Eq sy => FSM sy -> [[State]]

-- | Turn an FSM into a <a>DotGraph</a>, trimming any self-loops which
--   aren't sources of nondeterminism.
fsmToDot :: (Ord sy, Labellable sy) => FSM sy -> DotGraph Int

-- | Turn an FGL graph (interpreted as being a directed graph) into an FSM.
--   Self-loops are inserted as required. Also returns a list of the
--   graph's labelled nodes, since the labels are discarded by the FSM
--   construction. FSM states are numbered [0..] and thus may be used as an
--   index into that list of labelled nodes, in order to relate FSM states
--   back to the original graph nodes and their labels.
fglToFsm :: (Graph gr, Ord sy, Show sy) => gr a sy -> ReadFsmMonad (FSM sy, [LNode a])


-- | Serialisation/deserialisation of <a>FSM</a>s in edge list format.
--   
--   An <a>FSM</a> may be represented textually as list of
--   {source_state-&gt;destination_state,label} strings, each of which
--   represents an edge in its directed graph. (This representation is
--   interesting because it's used by Mathematica for graph I/O.)
module Data.FsmActions.FsmEdges

-- | Load an <a>FSM</a> from an FsmEdges file.
loadFsmEdges :: FilePath -> IO (FSM String)

-- | Save an <a>FSM</a> to an FsmMatrix file.
saveFsmEdges :: FSM String -> FilePath -> IO ()

-- | Parse an FsmEdges-formatted FSM held in a string. Includes
--   normalisation and well-formedness checks.
parseFsmEdges :: String -> ReadFsmMonad (FSM String)

-- | Pretty-print a string FSM in FsmMatrix format.
printFsmEdges :: FSM String -> String
instance Eq Edge
instance Show Edge


-- | Serialisation/deserialisation of <a>FSM</a>s as FSM transition
--   matrices.
--   
--   A <a>FSM</a> may be represented as an transition matrix whose rows
--   correspond to states of the FSM, and whose columns correspond to its
--   possible actions (labels on its transitions). A given cell then
--   represents the transition(s) from some (row) state under some (column)
--   action, and contains a comma-separated list of integers: the row
--   numbers of the destination states. (Of course, for a deterministic
--   action, there's just one, and no comma.) Rows are numbered from 0 and
--   increment strictly.
module Data.FsmActions.FsmMatrix

-- | Load an <a>FSM</a> from an FsmMatrix file.
loadFsmMx :: FilePath -> IO (FSM String)

-- | Save an <a>FSM</a> to an FsmMatrix file.
saveFsmMx :: FSM String -> FilePath -> IO ()

-- | Parse an FsmMatrix-formatted FSM held in a string. Includes
--   normalisation and well-formedness checks.
parseFsmMx :: String -> ReadFsmMonad (FSM String)

-- | Pretty-print a string FSM in FsmMatrix format.
printFsmMx :: FSM String -> String


-- | High-level input/output interface for finite state machines.
--   
--   This module allows one to load and save FSMs, where the format to be
--   used may be either explicitly specified, or guessed according to the
--   filename's extension.
module Data.FsmActions.IO

-- | Known FSM I/O formats.
data FsmIO

-- | ActionMatrix format: use <a>loadActionMxFsm</a> and
--   <a>saveActionMxFsm</a>; filename extensions: actions, actionspec,
--   actionmxs, actionmatrices, fsmactions.
FsmActionMatrices :: FsmIO

-- | FsmEdges format: use <a>loadFsmEdges</a> and <a>saveFsmEdges</a>;
--   filename extensions: edges, fsmedges, graph, mathematica.
FsmEdges :: FsmIO

-- | FsmMatrix format: use <a>loadFsmMx</a> and <a>saveFsmMx</a>; filename
--   extensions: mx, matrix, fsmmx, fsmmatrix, fsm.
FsmMatrix :: FsmIO

-- | Given a path, return a list of all <a>FsmIO</a> formats, with guesses
--   (according to the file extension) at the front.
fsmFormats :: FilePath -> [FsmIO]

-- | Read an <a>FSM</a> from a file. If the user specifies any <a>FsmIO</a>
--   formats, try each of those in turn; otherwise, try every format known,
--   using the filename extension to guess which to try first.
--   
--   The returned value is either the resultant <a>FSM</a>, or the error
--   message produced by trying to load it with the _first_ format (so in
--   the case of guessing formats, if the guess is wrong and the file is
--   corrupt, you might get an unhelpful error message).
loadFsm :: FilePath -> [FsmIO] -> IO (Either FsmError (FSM String))

-- | Save an <a>FSM</a> to a file. If the user specifies an <a>FsmIO</a>
--   format, it is used; otherwise, it is guessed from the filename
--   extension (and failing that, the first guess, ie
--   <a>FsmActionMatrices</a>, is used).
saveFsm :: FSM String -> FilePath -> Maybe FsmIO -> IO ()
instance Bounded FsmIO
instance Enum FsmIO
instance Eq FsmIO
instance Ord FsmIO
instance Show FsmIO
