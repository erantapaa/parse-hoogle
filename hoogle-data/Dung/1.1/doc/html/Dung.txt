-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementation of the Dung argumentation frameworks.
--   
@package Dung
@version 1.1


-- | This module implements Dung's argumentation frameworks.
module Language.Dung.AF

-- | An abstract argumentation framework is a set of arguments (represented
--   as a list) and an attack relation on these arguments.
data DungAF arg
AF :: [arg] -> [(arg, arg)] -> DungAF arg

-- | Given an argumentation framework, determines whether args (subset of
--   the arguments in the AF), attacks an argument arg (in the AF).
setAttacks :: Eq arg => DungAF arg -> [arg] -> arg -> Bool

-- | Given an argumentation framework, determines the set of arguments that
--   are attacked by an argument (in the AF).
aplus :: Eq arg => DungAF arg -> arg -> [arg]

-- | Given an argumentation framework, determines the set of arguments
--   attacking an argument (in the AF).
amin :: Eq arg => DungAF arg -> arg -> [arg]

-- | Given an argumentation framework, determines the set of arguments that
--   are attacked by the given subset of arguments (in the AF).
argplus :: Ord arg => DungAF arg -> [arg] -> [arg]

-- | Given an argumentation framework, determines the set of arguments that
--   attack a given subset of arguments (in the AF).
argmin :: Ord arg => DungAF arg -> [arg] -> [arg]

-- | Given an argumentation framework, determines whether args (subset of
--   the arguments in the AF) is conflict-free.
conflictFree :: Eq arg => DungAF arg -> [arg] -> Bool

-- | Given an argumentation framework, determines whether an argument is
--   acceptable with respect to a list of <tt>args</tt> (subset of the
--   arguments in the AF).
acceptable :: Eq arg => DungAF arg -> arg -> [arg] -> Bool

-- | Given an argumentation framework, returns the set of arguments that
--   are acceptable with respect to <tt>args</tt> (subset of the arguments
--   in the AF).
f :: Eq arg => DungAF arg -> [arg] -> [arg]

-- | Given an argumentation framework, determines whether the set of
--   arguments <tt>args</tt> (subset of the arguments in the AF) is
--   admissible, i.e. if <tt>args</tt> is <a>conflictFree</a> and args is a
--   subset of <tt>f af args</tt>
admissible :: Ord arg => DungAF arg -> [arg] -> Bool

-- | Given a characteristic function f, computes the grounded extension by
--   iterating on the empty set (list) until it reaches a fixpoint.
groundedF :: Eq arg => ([arg] -> [arg]) -> [arg]

-- | Given a characteristic function f, computes the grounded extension by
--   iterating on the empty set (list) until it reaches a fixpoint. Strict
--   version.
groundedF' :: Eq arg => ([arg] -> [arg]) -> [arg]

-- | Given an argumentation framework, computes all complete extension, by
--   taking all sets of arguments of the powerset of arguments of that AF,
--   given that they are admissible and <tt>f af == f</tt>.
completeF :: Ord arg => DungAF arg -> [[arg]]

-- | Given an argumentation framework, computes all preferred extensions,
--   by applying a filter on the complete extensions. Note that this, naive
--   definition is faster than the current algorithm implementation.
preferredF :: Ord arg => DungAF arg -> [[arg]]

-- | Given an argumentation framework, computes all stable extensions, by
--   applying a filter on the complete extensions. Note that this, naive
--   definition is faster than the current algorithm implementation.
stableF :: Ord arg => DungAF arg -> [[arg]]

-- | A complete extension is also a preferred extension if it is not a
--   subset of one of the other extensions.
isPreferredExt :: Ord arg => DungAF arg -> [[arg]] -> [arg] -> Bool

-- | S is a stable extension is an extension iff it is equal to the set of
--   arguments not attacked by S.
isStableExt :: Ord arg => DungAF arg -> [arg] -> Bool

-- | Labelling status of arguments.
data Status
In :: Status
Out :: Status
Undecided :: Status

-- | Labelling of arguments.
type Labelling arg = [(arg, Status)]

-- | Given a labelling of arguments, give back the arguments labelled
--   <a>In</a>.
inLab :: Labelling arg -> [arg]

-- | Given a labelling of arguments, give back the arguments labelled
--   <a>Out</a>.
outLab :: Labelling arg -> [arg]

-- | Given a labelling of arguments, give back the arguments labelled
--   <a>Undecided</a>.
undecLab :: Labelling arg -> [arg]

-- | The allIn labelling is a <a>Labelling</a> that labels every argument
--   <a>In</a>.
allIn :: [arg] -> Labelling arg

-- | The allOut labelling is a <a>Labelling</a> that labels every argument
--   <a>Out</a>.
allOut :: [arg] -> Labelling arg

-- | The allUndec labelling is a <a>Labelling</a> that labels every
--   argument <a>Undecided</a>.
allUndec :: [arg] -> Labelling arg

-- | Computes a list with all possible labellings.
powerLabel :: [arg] -> [Labelling arg]

-- | Given a list of arguments that are <a>Out</a> in an argumentation
--   framework af, an argument <tt>arg</tt> is unattacked if the list of
--   its attackers, ignoring the outs, is empty.
unattacked :: Ord arg => [arg] -> DungAF arg -> arg -> Bool

-- | Given a list of arguments that are <a>In</a> in an argumentation
--   framework af, an argument <tt>arg</tt> is attacked if there exists an
--   attacker that is <a>In</a>.
attacked :: Ord arg => [arg] -> DungAF arg -> arg -> Bool

-- | Given an argumentation framework, determines the list of attackers of
--   an argument, from a given labelling, returning the labelled attackers.
labAttackers :: Eq arg => DungAF arg -> arg -> Labelling arg -> Labelling arg

-- | Given an AF and <a>Labelling</a>, an argument a (in the AF) is
--   illegally <a>In</a> iff a is labelled <a>In</a>, but not all its
--   attackers are labelled <a>Out</a>.
illegallyIn :: Eq arg => DungAF arg -> Labelling arg -> (arg, Status) -> Bool

-- | Given an AF and <a>Labelling</a>, an argument a (in the AF) is
--   illegally <a>Out</a> iff a is labelled <a>Out</a> but does not have an
--   attacker labelled <a>In</a>.
illegallyOut :: Eq arg => DungAF arg -> Labelling arg -> (arg, Status) -> Bool

-- | Given an AF and <a>Labelling</a>, an argument a (in the AF) is
--   illegally <a>Undecided</a> iff a is labelled <a>Undecided</a> but
--   either all its attackers are labelled <a>Out</a> or it has an attacker
--   that is labelled <a>In</a>.
illegallyUndec :: Eq arg => DungAF arg -> Labelling arg -> (arg, Status) -> Bool

-- | Given an AF and <a>Labelling</a>, an argument a (in the AF) is legally
--   <a>In</a> iff a is labelled <a>In</a> and it's not <a>illegallyIn</a>.
legallyIn :: Eq arg => DungAF arg -> Labelling arg -> (arg, Status) -> Bool

-- | Given an AF and <a>Labelling</a>, an argument a (in the AF) is legally
--   <a>Out</a> iff a is labelled <a>Out</a> and it's not
--   <a>illegallyOut</a>.
legallyOut :: Eq arg => DungAF arg -> Labelling arg -> (arg, Status) -> Bool

-- | Given an AF and <a>Labelling</a>, an argument a (in the AF) is legally
--   <a>Undecided</a> iff a is labelled <a>Undecided</a> and it's not
--   <a>illegallyUndec</a>.
legallyUndec :: Eq arg => DungAF arg -> Labelling arg -> (arg, Status) -> Bool

-- | Given an AF, an admissible labelling is a <a>Labelling</a> without
--   arguments that are <a>illegallyIn</a> and without arguments that are
--   <a>illegallyOut</a>.
isAdmissible :: Eq arg => DungAF arg -> Labelling arg -> Bool

-- | Given an AF, a complete labelling is a labelling without arguments
--   that are <a>illegallyIn</a>, without arguments that are
--   <a>illegallyOut</a> and without arguments that are
--   <a>illegallyUndec</a>.
isComplete :: Eq arg => DungAF arg -> Labelling arg -> Bool

-- | Let <tt>labs</tt> be a complete labelling, i.e. <tt>isComplete af
--   labs</tt>, we say that labs is a preferred labelling iff <tt>inLab
--   labs</tt> is maximal (w.r.t. set inclusion).
isPreferred :: Ord arg => DungAF arg -> [Labelling arg] -> Labelling arg -> Bool

-- | Let <tt>labs</tt> be a complete labelling, i.e. 'isComplete af labs',
--   we say that labs is a preferred labelling iff <tt>undecLab(labs) ==
--   []</tt>
isStable :: Eq arg => DungAF arg -> [Labelling arg] -> Labelling arg -> Bool

-- | Let <tt>labs</tt> be a complete labelling, i.e. <tt>isComplete af
--   labs</tt>, we say that labs is a semi-stable labelling iff
--   <tt>undecLab labs</tt> is minimal (w.r.t. set inclusion).
isSemiStable :: Ord arg => DungAF arg -> [Labelling arg] -> Labelling arg -> Bool

-- | Given an AF, a labelling labs and an illegally in argument a in the
--   af, (i.e. <tt>illegallyIn af a labs</tt> =&gt; True), a transition
--   step on a in labs consists of the following: 1. the label of a is
--   changed from <a>In</a> to <a>Out</a> 2. for every b in {a} cup a+, if
--   b is illegally out, then change the label from b from <a>Out</a> to
--   <a>Undecided</a>
transitionStep :: Eq arg => DungAF arg -> Labelling arg -> arg -> Labelling arg

-- | Given an AF, a labelling, labs, is terminated iff labs does not
--   contain any argument that is illegally in, i.e. <tt>not (illegallyIn
--   af lab arg)</tt> for all arg in labs.
terminatedTransition :: Eq arg => DungAF arg -> Labelling arg -> Bool

-- | Given an AF and <a>Labelling</a>, an argument a (in the AF) is
--   superillegally <a>In</a> iff a is labelled <a>In</a>, and it is
--   attacked by an argument that is legally <a>In</a> or legally
--   <a>Undecided</a>.
superIllegallyIn :: Eq arg => DungAF arg -> Labelling arg -> (arg, Status) -> Bool

-- | Computes the grounded labelling for a Dung argumentation framework,
--   returning a (unique) list of arguments with statuses.
--   
--   Based on section 4.1 of Proof Theories and Algorithms for Abstract
--   Argumentation Frameworks by Modgil and Caminada.
grounded :: Ord arg => DungAF arg -> Labelling arg

-- | The grounded extension of an argumentation framework is just the
--   grounded labelling, keeping only those arguments that were labelled
--   <a>In</a>.
groundedExt :: Ord arg => DungAF arg -> [arg]

-- | Computes maximal and minimal complete labellings for a Dung
--   argumentation framework. This is based on Caminada's algorithm for
--   computing semi-stable labellings, with all checks removed.
complete :: Ord arg => DungAF arg -> [Labelling arg]

-- | Computes all preferred labellings for a Dung argumentation framework,
--   by taking the maximally in complete labellings.
preferred :: Ord arg => DungAF arg -> [Labelling arg]

-- | Computes all stable labellings for a Dung argumentation framework, by
--   keeping only those labellings with no <a>Undecided</a> labels.
stable :: Ord arg => DungAF arg -> [Labelling arg]

-- | Computes all semi-stable labellings for a Dung argumentation
--   framework, by taking the minimally undecided complete labellings.
semiStable :: Ord arg => DungAF arg -> [Labelling arg]

-- | The complete extension of an argumentation framework is just the
--   complete labelling, keeping only those arguments that were labelled
--   <a>In</a>.
completeExt :: Ord arg => DungAF arg -> [[arg]]

-- | The preferred extension of an argumentation framework is just the
--   preferred labelling, keeping only those arguments that were labelled
--   <a>In</a>.
preferredExt :: Ord arg => DungAF arg -> [[arg]]

-- | The stable extension of an argumentation framework is just the stable
--   labelling, keeping only those arguments that were labelled <a>In</a>.
stableExt :: Ord arg => DungAF arg -> [[arg]]

-- | The semi-stable extension of an argumentation framework is just the
--   semi-stable labelling, keeping only those arguments that were labelled
--   <a>In</a>.
semiStableExt :: Ord arg => DungAF arg -> [[arg]]
instance Eq arg => Eq (DungAF arg)
instance Ord arg => Ord (DungAF arg)
instance Show arg => Show (DungAF arg)
instance Eq Status
instance Show Status
instance Ord Status


-- | This is the input module accompanying the implementation of Dung's
--   argumentation frameworks. It defines a simple parser for an
--   argumentation framework that assumes the input file is in
--   CEGARTIX/PrefSat-like format.
--   
--   Files are assumed to have one argument or attack on each line, ending
--   in a dot. (Our parser is slightly more relaxed than this and doesn't
--   care about whitespace.)
--   
--   <tt>att(a1,a2).</tt> or <tt>arg(a1).</tt>
--   
--   Argument names are assumed to consist only of letters and numbers.
--   Arguments used in attacks should be declared separately as well.
module Language.Dung.Input

-- | Parses a <a>String</a> containing multiple arguments/attacks. If
--   parsing fails, it propagates the parse error.
parseAF :: String -> Either ParseError (DungAF String)

-- | An AF is parsed by parsing at least one argument or attack, followed
--   by an end of file token.
pAF :: Parser (DungAF String)


-- | This is the output module accompanying the implementation of Dung's
--   argumentation frameworks. It allows an implemented argumentation
--   framework to be outputted to files in a standard format.
--   
--   This module currently contains two output format. The strict version
--   is readable by both CEGARTIX and PrefSat. The lax version keeps more
--   of the original formatting.
module Language.Dung.Output

-- | Converts an argument to a CEGARTIX <a>String</a>. All argument names
--   are made into string literals removing extra quotes.
argToCegartix :: Show arg => arg -> String

-- | Converts an attack to a CEGARTIX <a>String</a>. All argument names are
--   made into string literals removing extra quotes.
atkToCegartix :: Show arg => (arg, arg) -> String

-- | Outputs an argumentation frameworks in CEGARTIX/PrefSat format.
toCegartix :: Show arg => DungAF arg -> String

-- | Converts an argument to a CEGARTIX <a>String</a>. All argument names
--   are made into string literals removing extra quotes. Additionally all
--   parentheses are removed.
argToStrictCegartix :: Show arg => arg -> String

-- | Converts an attack to a CEGARTIX <a>String</a>. All argument names are
--   made into string literals removing extra quotes. Additionally all
--   parentheses are removed.
atkToStrictCegartix :: Show arg => (arg, arg) -> String

-- | Outputs an argumentation frameworks in strict CEGARTIX/PrefSat format.
toStrictCegartix :: Show arg => DungAF arg -> String


-- | This is the examples module accompanying the implementation of Dung's
--   argumentation frameworks.
--   
--   This module contains a collection of examples, showing how to define
--   arguments, argumentation frameworks and how to use the standard
--   definitions.
--   
--   To run these examples, or your own: start GHCi and do the following:
--   
--   <pre>
--   :l Language.Dung.Examples
--   </pre>
module Language.Dung.Examples

-- | The simplest abstract argument is an argument identifiable by its name
type AbsArg = String
a :: AbsArg
b :: AbsArg
c :: AbsArg

-- | Example AF: A -&gt; B -&gt; C
exampleAF :: DungAF AbsArg

-- | Example AF: A &lt;-&gt; B
--   
--   Now follow a few example outputs using the above argumentation
--   frameworks.
--   
--   <ul>
--   <li><i>setAttacks:</i></li>
--   </ul>
--   
--   <tt>[a,b]</tt> <a>setAttacks</a> <tt>c</tt> in the argumentation
--   framework <a>exampleAF</a>:
--   
--   <pre>
--   &gt;&gt;&gt; setAttacks exampleAF [a,b] c
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setAttacks exampleAF [b,c] a
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setAttacks exampleAF2 [] b
--   False
--   </pre>
--   
--   <ul>
--   <li><i>conflictFree:</i></li>
--   </ul>
--   
--   <tt>[a,c]</tt> is <a>conflictFree</a> in the argumentation framework
--   <a>exampleAF</a>:
--   
--   <pre>
--   &gt;&gt;&gt; conflictFree exampleAF [a,c]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conflictFree exampleAF [a,b,c]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conflictFree exampleAF2 [a,b]
--   False
--   </pre>
--   
--   <ul>
--   <li><i>acceptable:</i></li>
--   </ul>
--   
--   <tt>c</tt> is acceptable w.r.t. <tt>[a,b]</tt> in the argumentation
--   framework <a>exampleAF</a>:
--   
--   <pre>
--   &gt;&gt;&gt; acceptable exampleAF c [a,b]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; acceptable exampleAF c []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; acceptable exampleAF b [a,b,c]
--   False
--   </pre>
--   
--   <ul>
--   <li><i>admissible:</i></li>
--   </ul>
--   
--   <tt>[a,b,c]</tt> is admissible in the argumentation framework
--   <a>exampleAF</a>:
--   
--   <pre>
--   &gt;&gt;&gt; admissible exampleAF [a,b,c]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; admissible exampleAF [a,c]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; admissible exampleAF [a]
--   True
--   </pre>
--   
--   <ul>
--   <li><i>grounded:</i></li>
--   </ul>
--   
--   The grounded labelling of the argumentation frameworks
--   <a>exampleAF</a> and <a>exampleAF2</a>:
--   
--   <pre>
--   &gt;&gt;&gt; grounded exampleAF
--   [("A",In),("C",In),("B",Out)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; grounded exampleAF2
--   [("A",Undecided),("B",Undecided)]
--   </pre>
--   
--   <ul>
--   <li><i>groundedExt:</i></li>
--   </ul>
--   
--   The grounded extension of the argumentation frameworks
--   <a>exampleAF</a> and <a>exampleAF2</a>:
--   
--   <pre>
--   &gt;&gt;&gt; groundedExt exampleAF
--   ["A", "C"]
--   
--   &gt;&gt;&gt; groundedExt exampleAF2
--   []
--   </pre>
exampleAF2 :: DungAF AbsArg

-- | fixed point function for a specific argumentation framework, <tt>faf =
--   f exampleAF</tt>.
--   
--   <ul>
--   <li><i>groundedF:</i></li>
--   </ul>
--   
--   The grounded extension of the argumentation framework <a>exampleAF</a>
--   using the fixpoint definition:
--   
--   <pre>
--   &gt;&gt;&gt; groundedF faf
--   ["A","C"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; groundedF (f exampleAF2)
--   []
--   </pre>
faf :: [AbsArg] -> [AbsArg]
d :: AbsArg
e :: AbsArg

-- | Left hand side of Fig1. in Caminada. Arguments are: {a,b,c,d}.
--   Attacks: {(a, a), (a, c), (b, c), (c, d)}
exampleAF3 :: DungAF AbsArg

-- | Right hand side of Fig1. in Caminada. Arguments are: {a,b,c,d,e}.
--   Attacks: {(a, b), (b, a), (b, c), (c, d), (d, e), (e, c)}
--   
--   <ul>
--   <li><i>complete:</i></li>
--   </ul>
--   
--   The complete labellings of the argumentation framework
--   <a>exampleAF3</a> and <a>exampleAF4</a>:
--   
--   <pre>
--   &gt;&gt;&gt; complete exampleAF3
--   [
--     [("A",Undecided),("B",In),("C",Out),("D",In)]
--   ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; complete exampleAF4
--   [
--     [("A",Out),("B",In),("C",Out),("D",In),("E",Out)],
--     [("A",In),("B",Out),("C",Undecided),("D",Undecided),("E",Undecided)],
--     [("A",Out),("B",In),("C",Out),("D",Undecided),("E",Undecided)]
--   ]
--   </pre>
--   
--   <ul>
--   <li><i>completeExt:</i></li>
--   </ul>
--   
--   The complete extensions of the argumentation frameworks
--   <a>exampleAF3</a> and <a>exampleAF4</a>:
--   
--   <pre>
--   &gt;&gt;&gt; completeExt exampleAF3
--   [
--     ["B","D"]
--   ]
--   
--   &gt;&gt;&gt; completeExt exampleAF4
--   [
--     ["B","D"],
--     ["A"],
--     ["B"]
--   ]
--   </pre>
--   
--   <ul>
--   <li><i>semiStable:</i></li>
--   </ul>
--   
--   The semi-stable labellings of the argumentation framework
--   <a>exampleAF3</a> and <a>exampleAF4</a>:
--   
--   <pre>
--   &gt;&gt;&gt; semiStable exampleAF3
--   [
--     [("A",Undecided),("B",In),("C",Out),("D",In)]
--   ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; semiStable exampleAF4
--   [
--     [("A",Out),("B",In),("C",Out),("D",In),("E",Out)],
--   ]
--   </pre>
--   
--   <ul>
--   <li><i>semiStableExt:</i></li>
--   </ul>
--   
--   The complete extensions of the argumentation frameworks
--   <a>exampleAF3</a> and <a>exampleAF4</a>:
--   
--   <pre>
--   &gt;&gt;&gt; semiStableExt exampleAF3
--   [
--     ["B","D"]
--   ]
--   
--   &gt;&gt;&gt; semiStableExt exampleAF4
--   [
--     ["B","D"],
--   ]
--   </pre>
exampleAF4 :: DungAF AbsArg

-- | Parsed example as given on the CEGARTIX webpage:
--   <a>http://www.dbai.tuwien.ac.at/proj/argumentation/cegartix/</a>.
--   
--   <pre>
--   arg(a).
--   arg(b).
--   arg(c).
--   arg(d).
--   arg(e).
--   arg(f).
--   arg(g).
--   att(a,b).
--   att(c,b).
--   att(c,d).
--   att(d,c).
--   att(d,e).
--   att(e,g).
--   att(f,e).
--   att(g,f).
--   </pre>
--   
--   This is given as a literal string to <a>parseAF</a>.
exampleAF5 :: DungAF AbsArg

-- | Output <a>String</a> corresponding to <a>exampleAF</a>, i.e.
--   <tt>toCegartix exampleAF</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; putStr output
--   arg("A").
--   arg("B").
--   arg("C").
--   att("A","B").
--   att("B","C").
--   </pre>
output :: String

-- | Output <a>String</a> corresponding to <a>exampleAF2</a>, i.e.
--   <tt>toCegartix exampleAF2</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; putStr output2
--   arg("A").
--   arg("B").
--   att("A","B").
--   att("B","A").
--   </pre>
output2 :: String

-- | Output <a>String</a> corresponding to <a>exampleAF3</a>, i.e.
--   <tt>toCegartix exampleAF3</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; putStr output3
--   arg("A").
--   arg("B").
--   arg("C").
--   arg("D").
--   att("A","A").
--   att("A","C").
--   att("B","C").
--   att("C","D").
--   </pre>
output3 :: String

-- | Output <a>String</a> corresponding to <a>exampleAF4</a>, i.e.
--   <tt>toCegartix exampleAF4</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; putStr output4
--   arg("A").
--   arg("B").
--   arg("C").
--   arg("D").
--   arg("E").
--   att("A","B").
--   att("B","A").
--   att("B","C").
--   att("C","D").
--   att("D","E").
--   att("E","C").
--   </pre>
output4 :: String

-- | Output <a>String</a> corresponding to <a>exampleAF5</a>, i.e.
--   <tt>toCegartix exampleAF5</tt>.
output5 :: String
