-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library provides support for JSON.
--   
--   This library provides support for JSON.
@package json2
@version 0.8.3


-- | Efficient build ByteString from <a>Json</a> with escaped string.
--   
--   <i>For example - use in YESOD:</i>
--   
--   <pre>
--   import Yesod
--   import Data.JSON2       as JSON
--   import Data.JSON2.Blaze as JSON
--   import Blaze.ByteString.Builder (toLazyByteString)
--   --
--   toRepJson :: ToJson a =&gt; a -&gt; RepJson
--   toRepJson =  RepJson . toContent . toLazyByteString . (JSON.blazeJson) . (JSON.toJson)
--   </pre>
module Data.JSON2.Blaze
blazeJson :: Json -> Builder


-- | See also:
--   <a>http://www.haskell.org/haskellwiki/HXT#The_concept_of_filters</a>
module Data.JSON2.Query
type JFilter = Json -> Jsons

-- | Filter <a>Json</a> strings.
isStr :: JFilter

-- | Predicative filter <a>Json</a> strings.
isStrBy :: (String -> Bool) -> JFilter

-- | Filter <a>Json</a> numbers.
isNum :: JFilter

-- | Predicative filter <a>Json</a> numbers.
isNumBy :: Fractional a => (a -> Bool) -> JFilter

-- | Filter <a>Json</a> Bool.
isBool :: JFilter

-- | Filter <a>Json</a> True.
isTrue :: JFilter

-- | Filter <a>Json</a> False.
isFalse :: JFilter

-- | Filter <a>Json</a> null.
isNull :: JFilter

-- | Filter primitive types.
isAtomic :: JFilter

-- | Filter <a>Json</a> objects.
isObj :: JFilter

-- | Get all elements from object.
getFromObj :: JFilter

-- | Get elements from object with key.
getFromKey :: String -> JFilter

-- | Get elements from object with keys.
getFromKeys :: [String] -> JFilter

-- | Get elements from object with key by.
getFromKeyBy :: (String -> Bool) -> JFilter

-- | Filter <a>Json</a> arrays.
isArr :: JFilter

-- | Get all elements from array.
getFromArr :: JFilter

-- | Get element from array with index.
getFromIndex :: Int -> JFilter

-- | Get elements from array with index by.
--   
--   DEPRECATED use: getFromIndexBy
getFromIndexes :: [Int] -> JFilter

-- | Get elements from array with indexes.
getFromIndexBy :: (Int -> Bool) -> JFilter

-- | Get all elements from object and array.
getChildern :: JFilter

-- | <tt>(f &gt;&gt;&gt; g)</tt> - Apply filter f, later filter g .
(>>>) :: JFilter -> JFilter -> JFilter

-- | Concat results two filters.
(<+>) :: JFilter -> JFilter -> JFilter

-- | <tt>(f <a>orElse</a> g)</tt> - Apply f, if <tt>f</tt> returned
--   <tt>empty</tt> apply <tt>g</tt>.
orElse :: JFilter -> JFilter -> JFilter

-- | <tt>(f <a>when</a> g)</tt> - When <tt>g</tt> returned <tt>not
--   empty</tt>, apply <tt>f</tt>.
when :: JFilter -> JFilter -> JFilter

-- | <tt>(f <a>guards</a> g )</tt> - If <tt>f</tt> returned <tt>empty</tt>
--   then <tt>empty</tt> else apply <tt>g</tt>.
guards :: JFilter -> JFilter -> JFilter

-- | Tree traversal filter for object and array.
deep :: JFilter -> JFilter

-- | Tree traversal filter for array.
deepObj :: JFilter -> JFilter
deepArr :: JFilter -> JFilter

module Data.JSON2.Parser

-- | Encode <a>String</a> to <a>Json</a>.
encodeJson :: String -> Json

-- | Parses JSON string.
parseJson :: String -> Either ParseError Json

module Data.JSON2.Internal
type ConvResult a = Either ConvError a

-- | Conversion <a>Rational</a> number to <a>Integral</a> number with check
--   bounds.
checkBoundsIntegral :: (Typeable a, Bounded a, Integral a) => (Rational -> a) -> Rational -> ConvResult a

-- | Conversion <a>Rational</a> number to <a>Bounded</a> values with check
--   bounds. checkBoundsEnum (toEnum . round)
checkBoundsEnum :: (Typeable a, Bounded a, Enum a) => (Rational -> a) -> Rational -> ConvResult a

-- | Conversion <a>Rational</a> to <a>RealFloat</a> values with check
--   infinity.
checkInfinite :: (Typeable a, RealFloat a) => (Rational -> a) -> Rational -> ConvResult a
data ConvError
ConvError :: String -> String -> String -> String -> ConvError

-- | Create conversion error.
mkError :: (Show a, Typeable a, Typeable b) => a -> ConvResult b

-- | Create conversion error with message.
mkError' :: (Show a, Typeable a, Typeable b) => String -> a -> ConvResult b
instance Eq ConvError
instance Read ConvError
instance Show ConvError
instance Error ConvError


-- | Class and Instances for pretty printing Your data.
--   
--   Minimal definition for instances <tt>Pretty</tt> - method <tt>pp</tt>
--   .
module Data.JSON2.Pretty
class Show a => Pretty a
pp :: Pretty a => a -> Doc
pprint :: Pretty a => a -> String
instance [incoherent] Pretty Json
instance [incoherent] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e) => Pretty (a, b, c, d, e)
instance [incoherent] (Pretty a, Pretty b, Pretty c, Pretty d) => Pretty (a, b, c, d)
instance [incoherent] (Pretty a, Pretty b, Pretty c) => Pretty (a, b, c)
instance [incoherent] (Pretty a, Pretty b) => Pretty (a, b)
instance [incoherent] Pretty a => Pretty (Set a)
instance [incoherent] (Pretty k, Pretty v) => Pretty (Map k v)
instance [incoherent] Pretty a => Pretty [a]
instance [incoherent] (Pretty a, Pretty b) => Pretty (Either a b)
instance [incoherent] Pretty a => Pretty (Maybe a)
instance [incoherent] Pretty String
instance [incoherent] Pretty Rational
instance [incoherent] Pretty Double
instance [incoherent] Pretty Float
instance [incoherent] Pretty Integer
instance [incoherent] Pretty Int
instance [incoherent] Pretty Char
instance [incoherent] Pretty ()


-- | <ol>
--   <li><i>Renders JSON to String</i></li>
--   </ol>
--   
--   Haskell value has a JSON string:
--   
--   <pre>
--    HASKELL value                             JSON string (toString . toJson)
--   -------------------------------           -----------------------------
--   Just "bla" :: Maybe String                "bla"
--   Nothing :: Maybe String                   null
--   Left 1 :: Either Int Int                  [[1], []]
--   Right 1 :: Either Int Int                 [[], [1]]
--   'a' :: Char                               97
--   () :: ()                                  []
--   (1, "bla") :: (Int, String)               [1, "bla"]
--   fromList [1,2,3,4] :: Set Int             [1, 2, 3, 4]
--   fromList [("0",0),("1",10),("2",20)]      {"0": 0, "1": 10, "2": 20}
--       :: Map String Int
--   </pre>
--   
--   <ol>
--   <li><i>Conversion haskell values from and to JSON</i></li>
--   </ol>
--   
--   This module provides many instances classes <a>FromJson</a> and
--   <a>ToJson</a> for haskell data types. See instances class
--   <a>ToJson</a> for SQL (HDBC) in module Database.HDBC.JSON2 (package
--   json2-hdbc).
--   
--   <i>Adding Instance class ToJson or FromJson</i>
--   
--   Transformation of algebraic product in <a>Json</a>. For example:
--   
--   <pre>
--   data Person = Person {name :: String, age:: Int}
--       deriving (Typeable, Show, Eq)
--   </pre>
--   
--   <pre>
--   instance ToJson Person where
--       toJson (Person s n) = toJson [toJson s, toJson n]
--   </pre>
--   
--   <pre>
--   instance FromJson Person where
--       safeFromJson (JArray [js, jn])
--                      = return $ Person (fromJson js) (fromJson jn)
--       safeFromJson x = mkError x
--   </pre>
--   
--   Converting <a>Bounded</a> and <a>Enum</a> values to Json. For example:
--   
--   <pre>
--   data Color = Red | Green | Blue | Black
--       deriving (Typeable, Show, Eq, Enum, Bounded)
--   </pre>
--   
--   <pre>
--   instance ToJson Color where
--       toJson = JNumber . toRational . fromEnum
--   instance FromJson Color where
--       safeFromJson (JNumber x) = checkBoundsEnum (toEnum . round) x
--       safeFromJson x =  mkError x
--   </pre>
module Data.JSON2
data Json :: *
JString :: String -> Json
JNumber :: !Rational -> Json
JBool :: !Bool -> Json
JNull :: Json
JArray :: [Json] -> Json
JObject :: Map String Json -> Json
type Jsons = [Json]

-- | Renders <a>Json</a> to String.
toString :: Json -> String

-- | Class for conversion from <a>Json</a>.
class Typeable a => ToJson a
toJson :: ToJson a => a -> Json

-- | Class for conversion from <a>Json</a>.
class Typeable a => FromJson a
safeFromJson :: FromJson a => Json -> ConvResult a

-- | Conversion from <a>Json</a>.
fromJson :: FromJson a => Json -> a

-- | Create empty <a>Json</a> object.
emptyObj :: Json

-- | Create single <a>Json</a> object.
(.=) :: (ToJson v, Typeable v) => String -> v -> Json

-- | Create <a>Json</a> object from list.
--   
--   <pre>
--   ghci&gt; pp $ mkObj [("a", "old"), ("a", "new"), ("bb", "other")]
--   {"a": "new", "bb": "other"}
--   </pre>
mkObj :: (ToJson v, Typeable v) => [(String, v)] -> Json

-- | Merge two <a>JObject</a>. Other <a>Json</a> values interpreted as
--   <a>emptyObj</a>.
--   
--   <pre>
--   ghci &gt; pp $ ("a" .= "old") += ("a" .= "new") += ("bb" .= "other")
--   {"a": "new", "bb": "other"}
--   </pre>
(+=) :: Json -> Json -> Json

-- | Merge <a>Json</a> objects from list.
--   
--   <pre>
--   ghci&gt;  pp $ merges [("a" .= "old"), ("a" .= "new"), ("bb" .= "other")]
--   {"a": "new", "bb": "other"}
--   </pre>
merges :: [Json] -> Json

-- | Recursively merge the two <a>Json</a> objects.
mergeRec :: Json -> Json -> Json

-- | Projection <a>Json</a> object to list of <a>Json</a> .
--   
--   <pre>
--   &gt; pp $ projectionObj ["b", "c", "b"] $ mkObj [("a",1),("b", 2), ("c", 3)]
--   [2, 3, 2]
--   </pre>
projectionObj :: [String] -> Json -> Jsons
instance [incoherent] (FromJson t1, FromJson t2, FromJson t3, FromJson t4, FromJson t5) => FromJson (t1, t2, t3, t4, t5)
instance [incoherent] (ToJson t1, ToJson t2, ToJson t3, ToJson t4, ToJson t5) => ToJson (t1, t2, t3, t4, t5)
instance [incoherent] (FromJson t1, FromJson t2, FromJson t3, FromJson t4) => FromJson (t1, t2, t3, t4)
instance [incoherent] (ToJson t1, ToJson t2, ToJson t3, ToJson t4) => ToJson (t1, t2, t3, t4)
instance [incoherent] (FromJson t1, FromJson t2, FromJson t3) => FromJson (t1, t2, t3)
instance [incoherent] (ToJson t1, ToJson t2, ToJson t3) => ToJson (t1, t2, t3)
instance [incoherent] (FromJson t1, FromJson t2) => FromJson (t1, t2)
instance [incoherent] (ToJson t1, ToJson t2) => ToJson (t1, t2)
instance [incoherent] (FromJson a, Ord a) => FromJson (Set a)
instance [incoherent] ToJson a => ToJson (Set a)
instance [incoherent] FromJson v => FromJson (Map String v)
instance [incoherent] ToJson v => ToJson (Map String v)
instance [incoherent] FromJson a => FromJson [a]
instance [incoherent] ToJson a => ToJson [a]
instance [incoherent] FromJson Rational
instance [incoherent] ToJson Rational
instance [incoherent] FromJson Float
instance [incoherent] ToJson Float
instance [incoherent] FromJson Double
instance [incoherent] ToJson Double
instance [incoherent] FromJson Word64
instance [incoherent] ToJson Word64
instance [incoherent] FromJson Word32
instance [incoherent] ToJson Word32
instance [incoherent] FromJson Word16
instance [incoherent] ToJson Word16
instance [incoherent] FromJson Word8
instance [incoherent] ToJson Word8
instance [incoherent] FromJson Word
instance [incoherent] ToJson Word
instance [incoherent] FromJson Int64
instance [incoherent] ToJson Int64
instance [incoherent] FromJson Int32
instance [incoherent] ToJson Int32
instance [incoherent] FromJson Int16
instance [incoherent] ToJson Int16
instance [incoherent] FromJson Int8
instance [incoherent] ToJson Int8
instance [incoherent] FromJson Int
instance [incoherent] ToJson Int
instance [incoherent] FromJson Integer
instance [incoherent] ToJson Integer
instance [incoherent] FromJson Char
instance [incoherent] ToJson Char
instance [incoherent] FromJson ByteString
instance [incoherent] ToJson ByteString
instance [incoherent] FromJson ByteString
instance [incoherent] ToJson ByteString
instance [incoherent] FromJson String
instance [incoherent] ToJson String
instance [incoherent] (FromJson a, FromJson b) => FromJson (Either a b)
instance [incoherent] (ToJson a, ToJson b) => ToJson (Either a b)
instance [incoherent] FromJson Bool
instance [incoherent] ToJson Bool
instance [incoherent] FromJson a => FromJson (Maybe a)
instance [incoherent] ToJson a => ToJson (Maybe a)
instance [incoherent] FromJson ()
instance [incoherent] ToJson ()
instance [incoherent] FromJson Json
instance [incoherent] ToJson Json


-- | This module provides Instances classes <a>ToJson</a> and
--   <a>FromJson</a> for Time.
--   
--   Time transforms to JSON as:
--   
--   <pre>
--   <a>Day</a>              ["2011", "04", "03"]
--   <a>TimeOfDay</a>        ["13", "12", "47", ".244649"]
--   <a>TimeZone</a>         "EEST"
--   <a>LocalTime</a>        ["2011", "04", "03", "13", "12", "47", ".244649"]
--   <a>ZonedTime</a>        ["2011", "04", "03", "13", "12", "47", ".244649", "EEST"]
--   <a>UTCTime</a>          ["2011", "04", "03", "10", "12", "47", ".244777", "UTC"]
--   <a>NominalDiffTime</a>  1.301825863528051e9
--   <a>POSIXTime</a>        1.301825863528051e9
--   </pre>
module Data.JSON2.Instances.Time
instance FromJson NominalDiffTime
instance ToJson NominalDiffTime
instance FromJson UTCTime
instance ToJson UTCTime
instance FromJson LocalTime
instance ToJson LocalTime
instance FromJson TimeZone
instance ToJson TimeZone
instance FromJson TimeOfDay
instance ToJson TimeOfDay
instance FromJson Day
instance ToJson Day
instance FromJson ZonedTime
instance ToJson ZonedTime
