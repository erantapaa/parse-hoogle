-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Constraint Functional-Logic Programming in Haskell
--   
--   This package provides combinators for constraint functional-logic
--   programming ((C)FLP) in Haskell. The combinators might later be used
--   as a target language for compiling programs written in an FLP language
--   like Curry or Toy. Another application of FLP is demand driven
--   test-case generation.
@package cflp
@version 2009.2.1

module CFLP.Strategies.Random
class Randomiser c
getRandomGen :: (Randomiser c) => c -> StdGen
setRandomGen :: (Randomiser c) => c -> StdGen -> c -> c
data Rnd s a
data RndCtx c
randomise :: (Monad s) => s c -> Rnd s (RndCtx c)
instance [incoherent] (Monad s) => Monad (Rnd s)
instance [incoherent] (MonadPlus s) => MonadPlus (Rnd s)
instance [incoherent] (Enumerable s) => Enumerable (Rnd s)
instance [incoherent] (Randomiser c) => StrategyT c Rnd
instance [incoherent] Transformer RndCtx
instance [incoherent] Randomiser (RndCtx c)
instance [incoherent] (Randomiser c, Transformer t) => Randomiser (t c)

module CFLP.Strategies.DepthCounter
class DepthCounter c
currentDepth :: (DepthCounter c) => c -> Int
incrementDepth :: (DepthCounter c) => c -> c -> c
data Depth s a
data DepthCtx c
countDepth :: (Monad s) => s c -> Depth s (DepthCtx c)
instance [incoherent] (Monad s) => Monad (Depth s)
instance [incoherent] (MonadPlus s) => MonadPlus (Depth s)
instance [incoherent] (Enumerable s) => Enumerable (Depth s)
instance [incoherent] (DepthCounter c) => StrategyT c Depth
instance [incoherent] Transformer DepthCtx
instance [incoherent] DepthCounter (DepthCtx c)
instance [incoherent] (DepthCounter c, Transformer t) => DepthCounter (t c)

module CFLP.Strategies.DepthLimit
class DepthLimiter c
depthLimit :: (DepthLimiter c) => c -> Int
resetDepthLimit :: (DepthLimiter c) => c -> Int -> c -> c
data DepthLim s a
data DepthLimCtx c
limitDepth :: (Monad s) => Int -> s c -> DepthLim s (DepthLimCtx c)
setDepthLimit :: (Monad s, DepthLimiter c, MonadUpdate c s) => c -> Int -> s ()
instance [incoherent] (Monad s) => Monad (DepthLim s)
instance [incoherent] (MonadPlus s) => MonadPlus (DepthLim s)
instance [incoherent] (Enumerable s) => Enumerable (DepthLim s)
instance [incoherent] (DepthCounter c, DepthLimiter c) => StrategyT c DepthLim
instance [incoherent] Transformer DepthLimCtx
instance [incoherent] DepthLimiter (DepthLimCtx c)
instance [incoherent] (DepthLimiter c, Transformer t) => DepthLimiter (t c)

module CFLP.Strategies.CallTimeChoice
data CTC s a
data StoreCTC c
callTimeChoice :: (Monad s) => s c -> CTC s (StoreCTC c)
instance [incoherent] (Monad s) => Monad (CTC s)
instance [incoherent] (MonadPlus s) => MonadPlus (CTC s)
instance [incoherent] (Enumerable s) => Enumerable (CTC s)
instance [incoherent] Show ChoiceStoreIM
instance [incoherent] (ChoiceStore c) => StrategyT c CTC
instance [incoherent] (ChoiceStore c, Transformer t) => ChoiceStore (t c)
instance [incoherent] Transformer StoreCTC
instance [incoherent] ChoiceStore (StoreCTC c)
instance [incoherent] ChoiceStore ChoiceStoreIM

module CFLP
class (Strategy (Ctx s) s, MonadPlus s, Solvable (Ctx s), MonadUpdate (Ctx s) s, Update (Ctx s) s s, Update (Ctx s) s (Res s), MonadPlus (Res s), Enumerable (Res s)) => CFLP s
class Enumerable s
enumeration :: (Enumerable s) => s a -> [a]
type Data s a = Nondet (Ctx s) s a
eval :: (Monad s, CFLP s, Generic a) => [s (Ctx s)] -> (Context (Ctx s) -> ID -> Data s a) -> IO [a]
evalPartial :: (Monad s, CFLP s, Generic a) => [s (Ctx s)] -> (Context (Ctx s) -> ID -> Data s a) -> IO [a]
evalPrint :: (Monad s, CFLP s, Generic a) => [s (Ctx s)] -> (Context (Ctx s) -> ID -> Data s a) -> IO ()
data Monadic m a
monadic :: (Monad m) => Monadic (UpdateT c m) ()
data UpdateT s m a
data NormalForm
data Nondet cs m a
newtype Context cs
Context :: cs -> Context cs
data ID
initID :: IO ID
withUnique :: (With ID a) => a -> ID -> Nondet (C ID a) (M ID a) (T ID a)
class Narrow c a
narrow :: (Narrow c a, Monad s, Strategy c s, MonadUpdate c s, Update c s s) => Context c -> ID -> Nondet c s a
unknown :: (Monad s, Strategy c s, MonadUpdate c s, Update c s s, Narrow c a) => ID -> Nondet c s a
failure :: (MonadPlus m) => Nondet cs m a
oneOf :: (Strategy c s, MonadUpdate c s) => [Nondet c s a] -> Context c -> ID -> Nondet c s a
(?) :: (Monad s, Strategy c s, MonadUpdate c s) => Nondet c s a -> Nondet c s a -> ID -> Nondet c s a
withHNF :: (Monad m, Update cs m m) => Nondet cs m a -> (HeadNormalForm cs m -> Context cs -> Nondet cs m b) -> Context cs -> Nondet cs m b
caseOf :: (MonadPlus m, Update cs m m) => Nondet cs m a -> [Match a cs m b] -> Context cs -> Nondet cs m b
caseOf_ :: (Monad m, Update cs m m) => Nondet cs m a -> [Match a cs m b] -> Nondet cs m b -> Context cs -> Nondet cs m b
data Match a cs m b
class Generic a
genericOps :: (Generic a) => GenericOps a
constr :: (Generic a) => Int -> GenericOps a
primitive :: (Generic a) => NormalForm -> a
generic :: (Generic a) => a -> NormalForm
nondet :: (Monad m, Update cs m m, Generic a) => a -> Nondet cs m a
type Decons a = ([NormalForm] -> NormalForm) -> Result a -> Maybe NormalForm
class ApplyCons a where { type family Result a; }
applyCons :: (ApplyCons a) => a -> [NormalForm] -> Result a
(!) :: (Int -> GenericOps a) -> (Int -> GenericOps a) -> Int -> GenericOps a
cons :: (ApplyCons a) => String -> a -> Decons a -> Int -> GenericOps (Result a)
groundNormalForm :: (Monad s, Monad m, Update c s m) => s c -> Nondet c s a -> m (NormalForm, c)
partialNormalForm :: (Monad s, Strategy c s, Solvable c, MonadPlus m, Update c s m) => s c -> Nondet c s a -> m (NormalForm, c)
data ConsPatList a b
(:!) :: a -> b -> ConsPatList a b
constructors :: (ConsList a, Generic (CData a)) => a
patterns :: (PatternList a, Generic (PData a)) => a
apply :: (Monad m, Update cs m m) => Nondet cs m (a -> b) -> Nondet cs m a -> Context cs -> ID -> Nondet cs m b
fun :: (Monad m, LiftFun f, NestLambda cs m t (Lift f)) => f -> Nondet cs m t
instance [incoherent] (MonadPlus m, Enumerable m) => CFLP (Monadic (UpdateT () m))

module CFLP.Types.Bool
true :: (Monad m) => Nondet c m Bool
false :: (Monad m) => Nondet c m Bool
pTrue :: (Context c -> Nondet c m a) -> Match Bool c m a
pFalse :: (Context c -> Nondet c m a) -> Match Bool c m a
not :: (CFLP s) => Data s Bool -> Context (Ctx s) -> Data s Bool
(===) :: (CFLP s) => Data s a -> Data s a -> Context (Ctx s) -> Data s Bool
instance [incoherent] Narrow c Bool

module CFLP.Constraints.Boolean
yes :: (Monad m) => Nondet c m Boolean
no :: (Monad m) => Nondet c m Boolean
neg :: (Monad m) => Nondet c m Boolean -> Nondet c m Boolean
(.&&.) :: (Monad m) => Nondet c m Boolean -> Nondet c m Boolean -> Nondet c m Boolean
(.||.) :: (Monad m) => Nondet c m Boolean -> Nondet c m Boolean -> Nondet c m Boolean
class BooleanSolver c
lookupBoolean :: (BooleanSolver c) => Int -> c -> Maybe Bool
assertBoolean :: (BooleanSolver c, MonadPlus m) => c -> Boolean -> c -> m c
data SatCtx c
data Sat s a
satSolving :: (Monad s) => s c -> Sat s (SatCtx c)
ifThen :: (CFLP s, BooleanSolver (Ctx s)) => Data s Boolean -> Data s a -> Context (Ctx s) -> Data s a
ifThenElse :: (CFLP s, BooleanSolver (Ctx s)) => Data s Boolean -> Data s a -> Data s a -> Context (Ctx s) -> Data s a
booleanToBool :: (CFLP s, BooleanSolver (Ctx s)) => Data s Boolean -> Context (Ctx s) -> Data s Bool
instance [incoherent] (Monad s) => Monad (Sat s)
instance [incoherent] (MonadPlus s) => MonadPlus (Sat s)
instance [incoherent] (Enumerable s) => Enumerable (Sat s)
instance [incoherent] (BooleanSolver c) => Narrow c Boolean
instance [incoherent] (BooleanSolver c) => StrategyT c Sat
instance [incoherent] (Solvable c) => Solvable (SatCtx c)
instance [incoherent] BooleanSolver (SatCtx c)
instance [incoherent] Transformer SatCtx
instance [incoherent] (BooleanSolver c, Transformer t) => BooleanSolver (t c)
instance [incoherent] Generic Boolean
instance [incoherent] ApplyCons Boolean

module CFLP.Strategies
type Computation a = forall s. (CFLP s, BooleanSolver (Ctx s)) => Context (Ctx s) -> ID -> Data s a
dfs :: [CTC (Monadic (UpdateT (StoreCTC ()) [])) (StoreCTC ())]
limDFS :: Int -> [CTC (Depth (DepthLim (Monadic (UpdateT (StoreCTC (DepthCtx (DepthLimCtx ()))) [])))) (StoreCTC (DepthCtx (DepthLimCtx ())))]
iterDFS :: [CTC (Depth (DepthLim (Monadic (UpdateT (StoreCTC (DepthCtx (DepthLimCtx ()))) [])))) (StoreCTC (DepthCtx (DepthLimCtx ())))]
bfs :: [CTC (Monadic (UpdateT (StoreCTC ()) Levels)) (StoreCTC ())]
diag :: [CTC (Monadic (UpdateT (StoreCTC ()) Omega)) (StoreCTC ())]
fair :: [CTC (Monadic (UpdateT (StoreCTC ()) Stream)) (StoreCTC ())]
rndDFS :: [CTC (Rnd (Monadic (UpdateT (StoreCTC (RndCtx ())) []))) (StoreCTC (RndCtx ()))]
dfs_B :: [CTC (Sat (Monadic (UpdateT (StoreCTC (SatCtx ())) []))) (StoreCTC (SatCtx ()))]
limDFS_B :: Int -> [CTC (Depth (DepthLim (Sat (Monadic (UpdateT (StoreCTC (DepthCtx (DepthLimCtx (SatCtx ())))) []))))) (StoreCTC (DepthCtx (DepthLimCtx (SatCtx ()))))]
iterDFS_B :: [CTC (Depth (DepthLim (Sat (Monadic (UpdateT (StoreCTC (DepthCtx (DepthLimCtx (SatCtx ())))) []))))) (StoreCTC (DepthCtx (DepthLimCtx (SatCtx ()))))]
bfs_B :: [CTC (Sat (Monadic (UpdateT (StoreCTC (SatCtx ())) Levels))) (StoreCTC (SatCtx ()))]
diag_B :: [CTC (Sat (Monadic (UpdateT (StoreCTC (SatCtx ())) Omega))) (StoreCTC (SatCtx ()))]
fair_B :: [CTC (Sat (Monadic (UpdateT (StoreCTC (SatCtx ())) Stream))) (StoreCTC (SatCtx ()))]
rndDFS_B :: [CTC (Rnd (Sat (Monadic (UpdateT (StoreCTC (RndCtx (SatCtx ()))) [])))) (StoreCTC (RndCtx (SatCtx ())))]
instance [incoherent] (MonadPlus m, Enumerable m) => CFLP (CTC (Rnd (Sat (Monadic (UpdateT (StoreCTC (RndCtx (SatCtx ()))) m)))))
instance [incoherent] (MonadPlus m, Enumerable m) => CFLP (CTC (Depth (DepthLim (Sat (Monadic (UpdateT (StoreCTC (DepthCtx (DepthLimCtx (SatCtx ())))) m))))))
instance [incoherent] (MonadPlus m, Enumerable m) => CFLP (CTC (Sat (Monadic (UpdateT (StoreCTC (SatCtx ())) m))))
instance [incoherent] (MonadPlus m, Enumerable m) => CFLP (CTC (Rnd (Monadic (UpdateT (StoreCTC (RndCtx ())) m))))
instance [incoherent] (MonadPlus m, Enumerable m) => CFLP (CTC (Depth (DepthLim (Monadic (UpdateT (StoreCTC (DepthCtx (DepthLimCtx ()))) m)))))
instance [incoherent] (MonadPlus m, Enumerable m) => CFLP (CTC (Monadic (UpdateT (StoreCTC ()) m)))
instance [incoherent] Enumerable Stream
instance [incoherent] Enumerable Omega
instance [incoherent] Enumerable Levels
instance [incoherent] Enumerable Logic
instance [incoherent] Enumerable []

module CFLP.Tests
assertResults :: (Generic a, Show a, Eq a) => Computation a -> [a] -> Assertion
assertResultsN :: (Generic a, Show a, Eq a) => Int -> Computation a -> [a] -> Assertion
assertResultsLimit :: (Generic a, Show a, Eq a) => Maybe Int -> Computation a -> [a] -> Assertion

module CFLP.Types.List
dNil :: Decons [a]
dCons :: (Generic a) => Decons [a]
nil :: (Monad m, Generic a) => Nondet c m [a]
(^:) :: (Monad m, Generic a) => Nondet c m a -> Nondet c m [a] -> Nondet c m [a]
pNil :: (Generic a) => (Context c -> Nondet c m b) -> Match [a] c m b
pCons :: (Generic a) => (Context c -> Nondet c m a -> Nondet c m [a] -> Nondet c m b) -> Match [a] c m b
null :: (CFLP s, Generic a) => Data s [a] -> Context (Ctx s) -> Data s Bool
head :: (CFLP s, Generic a) => Data s [a] -> Context (Ctx s) -> Data s a
tail :: (CFLP s, Generic a) => Data s [a] -> Context (Ctx s) -> Data s [a]
map :: (CFLP s, Generic a, Generic b) => Data s (a -> b) -> Data s [a] -> Context (Ctx s) -> ID -> Data s [b]
foldr :: (CFLP s, Generic a) => Data s (a -> b -> b) -> Data s b -> Data s [a] -> Context (Ctx s) -> ID -> Data s b
instance [incoherent] (Narrow c a, Generic a) => Narrow c [a]
instance [incoherent] (Generic a) => Generic [a]
instance [incoherent] ApplyCons [a]

module CFLP.Tests.Boolean
tests :: Test
assertVariable :: Assertion
xAndYandZ :: Assertion
unsatisfiable :: Assertion
unsatisfiableWithBacktracking :: Assertion

module CFLP.Tests.CallTimeChoice
tests :: Test
ignoreFirstNarrowSecond :: Assertion
ignot :: (CFLP s) => Data s a -> Data s Bool -> Context (Ctx s) -> Data s Bool
sharedVarsAreEqual :: Assertion
two :: (Monad m, Generic a) => Nondet cs m a -> Nondet cs m [a]
noDemandOnSharedVar :: Assertion
sharedCompoundTerms :: Assertion
negHeads :: (CFLP s) => Data s [Bool] -> Context (Ctx s) -> Data s [Bool]

module CFLP.Tests.HigherOrder
tests :: Test
applyNotFunction :: Assertion
applyBinCons :: Assertion
applyChoice :: Assertion
callTimeChoice :: Assertion
two :: (Monad m, Generic a) => Nondet cs m a -> Nondet cs m [a]
mapSharedUnknowns :: Assertion
memberWithFold :: Assertion
after :: (CFLP s) => Data s (b -> c) -> Data s (a -> b) -> Data s (a -> c)
overApplication :: Assertion
reverseWithFoldr :: Assertion
flip :: (CFLP s) => Data s (a -> b -> c) -> Data s b -> Data s a -> Context (Ctx s) -> ID -> Data s c
id :: Data s a -> Data s a
pointfreeReverse :: Assertion
functionConversion :: Assertion
