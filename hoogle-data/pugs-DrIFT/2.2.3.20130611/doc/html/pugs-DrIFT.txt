-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | DrIFT with pugs-specific rules.
--   
--   DrIFT is a type sensitive preprocessor for Haskell. It extracts type
--   declarations and directives from modules. The directives cause rules
--   to be fired on the parsed type declarations, generating new code which
--   is then appended to the bottom of the input file. The rules are
--   expressed as Haskell code, and it is intended that the user can add
--   new rules as required. DrIFT automates instance derivation for classes
--   that aren't supported by the standard compilers. In addition,
--   instances can be produced in seperate modules to that containing the
--   type declaration. This allows instances to be derived for a type after
--   the original module has been compiled. As a bonus, simple utility
--   functions can also be produced from a type.
@package pugs-DrIFT
@version 2.2.3.20130611

module DrIFT.YAML
type Buf = ByteString
type YAMLClass = String
type YAMLKey = String
type YAMLVal = YamlNode
type SeenCache = IORef IntSet
toYamlString :: YAML a => a -> IO String
fromYamlString :: YAML a => String -> IO a
toYamlNode :: YAML a => a -> IO YamlNode
showYaml :: YAML a => a -> IO String
showYamlCompressed :: YAML a => a -> IO String
type EmitAs = ReaderT SeenCache IO
class Typeable a => YAML a where asYAML x = lift $ do { ty <- handle (\ (e :: SomeException) -> return "()") $ evaluate (show (typeOf x)); case ty of { "()" -> return nilNode _ -> return $ mkTagNode (tagHs ty) ENil } } fromYAML = fromYAMLElem . n_elem fromYAMLElem e = do { fail $ "unhandled element: " ++ (show e) ++ ", expecting " ++ show (typeOf (undefined :: a)) }
asYAML :: YAML a => a -> EmitAs YamlNode
fromYAML :: YAML a => YamlNode -> IO a
fromYAMLElem :: YAML a => YamlElem -> IO a
asYAMLseq :: YAMLClass -> [EmitAs YAMLVal] -> EmitAs YamlNode
asYAMLmap :: YAMLClass -> [(YAMLKey, EmitAs YAMLVal)] -> EmitAs YamlNode
asYAMLmapBuf :: YAMLClass -> [(ByteString, EmitAs YAMLVal)] -> EmitAs YamlNode
fromYAMLseq :: YAML a => YamlNode -> IO [a]
fromYAMLmap :: YAML a => YamlNode -> IO [(String, a)]
fromYAMLmapBuf :: YAML a => YamlNode -> IO [(ByteString, a)]
asYAMLcls :: YAMLClass -> EmitAs YamlNode
tagHs :: YAMLClass -> String
deTag :: YamlNode -> YAMLClass
asYAMLanchor :: a -> EmitAs YamlNode -> EmitAs YamlNode
asYAMLwith :: (YAML a, YAML b) => (a -> EmitAs b) -> a -> EmitAs YamlNode
failWith :: YAML a => YamlElem -> IO a
type SeenHash = HashTable SYMID (Maybe YamlNode)
type DuplHash = HashTable YamlNode Int
compressYamlNode :: YamlNode -> IO YamlNode
eqNode :: YamlNode -> YamlNode -> Bool
eqElem :: YamlElem -> YamlElem -> Bool
visitNode :: (?countRef :: IORef Int, ?duplHash :: DuplHash) => YamlNode -> IO YamlNode
visitElem :: (?countRef :: IORef Int, ?duplHash :: DuplHash) => YamlElem -> IO YamlElem
markNode :: (?seenHash :: SeenHash, ?duplHash :: DuplHash) => YamlNode -> IO YamlNode
markElem :: (?seenHash :: SeenHash, ?duplHash :: DuplHash) => YamlElem -> IO (Int32, YamlElem)
hashIDs :: [SYMID] -> Int32
iterIDs :: Int32 -> SYMID -> Int32
iterI32s :: Int32 -> Int32 -> Int32
golden :: Int32
mulHi :: Int32 -> Int32 -> Int32
hashByteString :: ByteString -> Int32
instance [incoherent] (Typeable a, YAML a) => YAML (TVar a)
instance [incoherent] (YAML a, YAML b, YAML c) => YAML (a, b, c)
instance [incoherent] (YAML a, YAML b) => YAML (a, b)
instance [incoherent] YAML a => YAML (Seq a)
instance [incoherent] YAML a => YAML [a]
instance [incoherent] YAML a => YAML (Maybe a)
instance [incoherent] YAML Double
instance [incoherent] YAML Rational
instance [incoherent] YAML Integer
instance [incoherent] YAML Bool
instance [incoherent] YAML String
instance [incoherent] YAML Buf
instance [incoherent] YAML Word
instance [incoherent] YAML Int
instance [incoherent] YAML ()

module DrIFT.Perl6Class
showPerl6RoleDef :: NamespaceMangler -> String -> String
showMooseRoleDef :: NamespaceMangler -> String -> String
showPerl6ClassDef :: NamespaceMangler -> String -> String -> [(String, String, String)] -> String
showMooseClassDef :: NamespaceMangler -> String -> String -> [(String, String, String)] -> String
qt :: String -> Doc
type NamespaceMangler = String -> String
class Typeable a => MooseClass a where showMooseTypeDef _ ty = error $ "showMooseTypeDef " ++ (show $ typeOf ty)
showMooseTypeDef :: MooseClass a => NamespaceMangler -> a -> String
class PLit a => Perl6Class a where showPerl6TypeDef _ ty = error $ "showPerl6TypeDef " ++ (show $ typeOf ty) asPerl6Object simple = "new " ++ (show $ typeOf simple)
showPerl6TypeDef :: Perl6Class a => NamespaceMangler -> a -> String
asPerl6Object :: Perl6Class a => a -> String
showKV :: (PLit a, PLit b) => (a, b) -> Doc
ts :: PLit a => a -> Doc
qbraces :: [Doc] -> [Doc]

-- | typeclass for dumping literals in Perl 6 source code.
class (Typeable a, Show a) => PLit a where plShow = show
plShow :: PLit a => a -> String

-- | Turn a string into source-code fitting Perl 6 string literal. May
--   result in code for concatenation of several such literals. The restult
--   is a [Doc] rather than a single String so that calling pretty-printers
--   can render linebreaks at the correct places trivially with cat.
showStringLiteral :: String -> [Doc]

-- | An FPS version of <tt>showStringLiteral</tt>. Since the
--   pretty-printing library isn't fps, this isn't as fast as it might have
--   been.
showSLiteral :: ByteString -> [Doc]

-- | An FPS version of <tt>showStringLiteral</tt>. Since the
--   pretty-printing library isn't fps, this isn't as fast as it might have
--   been.
showLLiteral :: ByteString -> [Doc]
instance [incoherent] (Typeable a, Show a) => PLit a
instance [incoherent] PLit a => PLit (Maybe a)
instance [incoherent] PLit a => PLit [a]
instance [incoherent] PLit ByteString
instance [incoherent] PLit ByteString
instance [incoherent] PLit String
instance [incoherent] MooseClass Word
instance [incoherent] MooseClass Float
instance [incoherent] MooseClass Rational
instance [incoherent] MooseClass Int
instance [incoherent] Perl6Class Word
instance [incoherent] Perl6Class Float
instance [incoherent] Perl6Class Rational
instance [incoherent] Perl6Class Int
instance [incoherent] (Perl6Class a, Perl6Class b, PLit a, PLit b, PLit (Map a b)) => Perl6Class (Map a b)
instance [incoherent] Perl6Class a => Perl6Class [a]

module DrIFT.Perl5
type Perl5Class = String
type Perl5Key = String
type Perl5Val = String
class Show a => Perl5 a where showPerl5 x = show (show x)
showPerl5 :: Perl5 a => a -> String
showP5ArrayObj :: Perl5Class -> [Perl5Val] -> String
showP5HashObj :: Perl5Class -> [(Perl5Key, Perl5Val)] -> String
showP5Array :: [Perl5Val] -> String
showP5Hash :: [(Perl5Key, Perl5Val)] -> String
showP5Class :: Perl5Class -> String
showP5Obj :: (a -> String) -> Perl5Class -> a -> String
instance [incoherent] (Perl5 a, Perl5 b, Perl5 c) => Perl5 (a, b, c)
instance [incoherent] (Perl5 a, Perl5 b) => Perl5 (a, b)
instance [incoherent] Perl5 a => Perl5 [a]
instance [incoherent] Perl5 a => Perl5 (Maybe a)
instance [incoherent] Perl5 Double
instance [incoherent] Perl5 Rational
instance [incoherent] Perl5 Integer
instance [incoherent] Perl5 Bool
instance [incoherent] Perl5 String
instance [incoherent] Perl5 ByteString
instance [incoherent] Perl5 ByteString
instance [incoherent] Perl5 Word
instance [incoherent] Perl5 Int
instance [incoherent] Perl5 ()

module DrIFT.JSON
type JSONClass = String
type JSONKey = String
type JSONVal = String
class Show a => JSON a where showJSON x = show (show x)
showJSON :: JSON a => a -> String
showJSArrayObj :: JSONClass -> [JSONVal] -> String
showJSHashObj :: JSONClass -> [(JSONKey, JSONVal)] -> String
showJSArray :: [JSONVal] -> String
showJSHash :: [(JSONKey, JSONVal)] -> String
showJSScalar :: JSONClass -> String
showJSObj :: (a -> String) -> JSONClass -> a -> String
instance [incoherent] (JSON a, JSON b, JSON c) => JSON (a, b, c)
instance [incoherent] (JSON a, JSON b) => JSON (a, b)
instance [incoherent] JSON a => JSON [a]
instance [incoherent] JSON a => JSON (Maybe a)
instance [incoherent] JSON Double
instance [incoherent] JSON Rational
instance [incoherent] JSON Integer
instance [incoherent] JSON Bool
instance [incoherent] JSON String
instance [incoherent] JSON ByteString
instance [incoherent] JSON ByteString
instance [incoherent] JSON Word
instance [incoherent] JSON Int
instance [incoherent] JSON ()
