-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Audio file reading/writing
--   
--   encode and decode soundfiles using Iteratees. Audio files may be read
--   or written, with classes and data structures to facilitate conversion
--   between different formats. Currently only wave format is supported.
@package sndfile-enumerators
@version 0.10.0.0

module Sound.Iteratee.Utils

-- | interleave multiple vectors. The inputs must all have the same length,
--   else Nothing.
--   
--   if there are no input vectors, output <tt>Just V.empty</tt>
interleave :: Storable a => [Vector a] -> Maybe (Vector a)

module Sound.Iteratee.Base

-- | Information about the AudioStream
data AudioStreamState

-- | Handle, format, Total bytes written, data bytes written, data chunklen
--   offset
WaveState :: !Maybe Handle -> !Maybe AudioFormat -> !Integer -> !Integer -> !Integer -> AudioStreamState
NoState :: AudioStreamState

-- | Common functions for writing audio data
class WritableAudio a
emptyState :: WritableAudio a => a -> AudioStreamState
initState :: WritableAudio a => a -> Handle -> AudioStreamState
supportedBitDepths :: WritableAudio a => a -> SupportedBitDepths
fileType :: WritableAudio a => a -> SupportedFileFormat

-- | Audio monad stack (for writing files)
type AudioMonad = StateT AudioStreamState IO
defaultChunkLength :: Int

-- | Format of audio data
data AudioFormat
AudioFormat :: NumChannels -> SampleRate -> BitDepth -> AudioFormat

-- | Number of channels in the audio data
numberOfChannels :: AudioFormat -> NumChannels

-- | Sample rate of the audio data
sampleRate :: AudioFormat -> SampleRate

-- | Bit depth of the audio data
bitDepth :: AudioFormat -> BitDepth
data SupportedBitDepths
Any :: SupportedBitDepths
Supported :: [BitDepth] -> SupportedBitDepths
type NumChannels = Integer
type SampleRate = Integer
type BitDepth = Integer
type FrameCount = Integer

-- | An enumeration of all file types supported for reading and writing.
data SupportedFileFormat
Raw :: SupportedFileFormat
Wave :: SupportedFileFormat
data UnknownFileTypeException
UnknownFileTypeException :: UnknownFileTypeException
data CorruptFileException
CorruptFileException :: CorruptFileException
data MissingFormatException
MissingFormatException :: MissingFormatException

-- | Operate on a single channel of an audio stream.
getChannel :: Monad m => Int -> Int -> Enumeratee (Vector Double) (Vector Double) m a
instance Typeable SupportedFileFormat
instance Typeable AudioFormat
instance Typeable UnknownFileTypeException
instance Typeable CorruptFileException
instance Typeable MissingFormatException
instance Show SupportedFileFormat
instance Enum SupportedFileFormat
instance Bounded SupportedFileFormat
instance Eq SupportedFileFormat
instance Data SupportedFileFormat
instance Show AudioFormat
instance Eq AudioFormat
instance Data AudioFormat
instance Eq AudioStreamState
instance Show AudioStreamState
instance Eq UnknownFileTypeException
instance Show UnknownFileTypeException
instance Eq CorruptFileException
instance Show CorruptFileException
instance Eq MissingFormatException
instance Show MissingFormatException
instance IException MissingFormatException
instance Exception MissingFormatException
instance IException CorruptFileException
instance Exception CorruptFileException
instance IException UnknownFileTypeException
instance Exception UnknownFileTypeException
instance ReadableChunk (Vector Word8) Word8
instance Storable a => NullPoint (Vector a)
instance Storable a => Nullable (Vector a)

module Sound.Iteratee.Codecs.Wave

-- | Data type to specify WAVE-formatted data
data WaveCodec
WaveCodec :: WaveCodec

-- | A WAVE directory is a list associating WAVE chunks with a record
--   WAVEDE
type WAVEDict = IntMap [WAVEDE]
data WAVEDE
WAVEDE :: Int -> WAVECHUNK -> WAVEDEENUM -> WAVEDE

-- | length of chunk
wavedeCount :: WAVEDE -> Int

-- | type of chunk
wavedeType :: WAVEDE -> WAVECHUNK

-- | enumerator to get values of chunk
wavedeEnum :: WAVEDE -> WAVEDEENUM
data WAVEDEENUM
WENBYTE :: (forall a m. (MonadCatchIO m, Functor m) => MEnumeratorM (Vector Word8) (Vector Word8) m a) -> WAVEDEENUM
WENDUB :: (forall a m. (MonadCatchIO m, Functor m) => MEnumeratorM2 (Vector Word8) (Vector Double) m a) -> WAVEDEENUM

-- | Standard WAVE Chunks
data WAVECHUNK

-- | Format
WAVEFMT :: WAVECHUNK

-- | Data
WAVEDATA :: WAVECHUNK

-- | Other
WAVEOTHER :: String -> WAVECHUNK

-- | Convert a WAVECHUNK to the representative string
chunkToString :: WAVECHUNK -> String

-- | The library function to read the WAVE dictionary
waveReader :: (MonadCatchIO m, Functor m) => Iteratee (Vector Word8) m (Maybe WAVEDict)

-- | Read the RIFF header of a file. Returns True if the file is a valid
--   RIFF.
readRiff :: MonadCatchIO m => Iteratee (Vector Word8) m Bool

-- | Convert a string to WAVECHUNK type
waveChunk :: String -> Maybe WAVECHUNK

-- | Read the specified format chunk from the WAVE dictionary
dictReadFormat :: (MonadCatchIO m, Functor m) => Int -> WAVEDict -> Iteratee (Vector Word8) m (Maybe AudioFormat)

-- | Read the first format chunk in the WAVE dictionary.
dictReadFirstFormat :: (MonadCatchIO m, Functor m) => WAVEDict -> Iteratee (Vector Word8) m (Maybe AudioFormat)

-- | Read the last format chunk from the WAVE dictionary. This is useful
--   when parsing all chunks in the dictionary.
dictReadLastFormat :: (MonadCatchIO m, Functor m) => WAVEDict -> Iteratee (Vector Word8) m (Maybe AudioFormat)

-- | Read the specified data chunk from the dictionary, applying the data
--   to the specified Iteratee.
dictProcessData :: (MonadCatchIO m, Functor m) => Int -> WAVEDict -> Iteratee (Vector Double) m a -> Iteratee (Vector Word8) m (Iteratee (Vector Double) m a)
dictProcessData_ :: (MonadCatchIO m, Functor m) => Int -> WAVEDict -> Iteratee (Vector Double) m a -> Iteratee (Vector Word8) m (Maybe a)

-- | Get the length of data in a dictionary chunk, in bytes.
dictGetLengthBytes :: WAVECHUNK -> Int -> WAVEDict -> Maybe Integer

-- | Get the length of a data chunk, in samples.
dictGetLengthSamples :: AudioFormat -> Int -> WAVEDict -> Maybe Integer

-- | Get the AudioFormat and data length from a file
dictSoundInfo :: (MonadCatchIO m, Functor m) => WAVEDict -> Iteratee (Vector Word8) m (Maybe (AudioFormat, Integer))

-- | Create an iteratee to write data to a wave file.
writeWave :: FilePath -> AudioFormat -> Iteratee (Vector Double) AudioMonad ()

-- | Open a wave file for writing
openWave :: FilePath -> AudioMonad ()
closeWave :: AudioMonad ()
runWaveAM :: AudioMonad a -> IO a

-- | Write a data format block to the open wave file
writeFormat :: AudioFormat -> AudioMonad ()

-- | Write the header for a Data chunk.
writeDataHeader :: AudioMonad ()

-- | Write a data chunk.
writeDataChunk :: Vector Double -> AudioMonad ()
instance Eq WAVECHUNK
instance Ord WAVECHUNK
instance Show WAVECHUNK
instance Enum WAVECHUNK
instance Show WAVEDE

module Sound.Iteratee.Codecs.Raw
data RawCodec
RawCodec :: RawCodec
readRaw :: (MonadCatchIO m, Functor m) => AudioFormat -> Iteratee (Vector Double) m a -> Iteratee (Vector Word8) m a
instance WritableAudio RawCodec

module Sound.Iteratee.Codecs

-- | Get a writer iteratee for a SupportedFileFormat
getWriter :: SupportedFileFormat -> FilePath -> AudioFormat -> Iteratee (Vector Double) AudioMonad ()

-- | An existentially-wrapped codec. This exists in order to get an
--   arbitrary codec (and associated information, such as bit depths) from
--   a SupportedFileFormat.
data Codec
Codec :: a -> Codec
getCodec :: SupportedFileFormat -> Codec
instance WritableAudio Codec


-- | Generic functions and iteratees to support writing files.
module Sound.Iteratee.Writer

-- | A simplified interface to running an audio iteratee
fileDriverAudio :: Iteratee (Vector Word8) AudioMonad a -> FilePath -> IO a
runAudioMonad :: AudioMonad a -> IO a
enumAudioFile :: MonadCatchIO m => Int -> FilePath -> Enumerator (Vector Word8) m a

module Sound.Iteratee.File

-- | get the format from a file name
getFormat :: FilePath -> Maybe SupportedFileFormat

-- | get audio format information and audio length (samples, not frames)
--   from a file
getAudioInfo :: FilePath -> IO (Maybe (AudioFormat, Integer))
runAudioIteratee :: FilePath -> Iteratee (Vector Double) AudioMonad a -> IO a
tryRunAudioIteratee :: Exception e => FilePath -> Iteratee (Vector Double) AudioMonad a -> IO (Either e a)
enumAudioIteratee :: (MonadCatchIO m, Functor m) => FilePath -> Iteratee (Vector Double) m a -> m (Iteratee (Vector Double) m a)
enumAudioIterateeWithFormat :: (MonadCatchIO m, Functor m) => FilePath -> (AudioFormat -> Iteratee (Vector Double) m a) -> m (Iteratee (Vector Double) m a)

-- | Default buffer size. The value from Data.Iteratee.IO is generally too
--   small for good performance.
defaultBufSize :: Int

module Sound.Iteratee
