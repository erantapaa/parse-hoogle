-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Implementation of the "Monads, Zippers and Views" (Schrijvers and Oliveira, ICFP'11)
--   
--   Implementation of the <a>Monads, Zippers and Views</a> (Schrijvers and
--   Oliveira, ICFP'11)
@package mzv
@version 0.1.0.2


-- | The MonadWriter class.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>) Advanced
--   School of Functional Programming, 1995.
module Control.Monad.Writer.Class
class (Monoid w, Monad m) => MonadWriter w m | m -> w
tell :: MonadWriter w m => w -> m ()
listen :: MonadWriter w m => m a -> m (a, w)
pass :: MonadWriter w m => m (a, w -> w) -> m a
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
censor :: MonadWriter w m => (w -> w) -> m a -> m a


-- | MonadState class.
--   
--   This module is inspired by the paper /Functional Programming with
--   Overloading and Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.State.Class

-- | <i>get</i> returns the state from the internals of the monad.
--   
--   <i>put</i> replaces the state inside the monad.
class Monad m => MonadState s m | m -> s
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a


-- | <ul>
--   <li><i>Computation type:</i> Computations which read values from a
--   shared environment.</li>
--   <li><i>Binding strategy:</i> Monad values are functions from the
--   environment to a value. The bound function is applied to the bound
--   value, and both have access to the shared environment.</li>
--   <li><i>Useful for:</i> Maintaining variable bindings, or other shared
--   environment.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><tt>Reader</tt> [(String,Value)]
--   a</tt></li>
--   </ul>
--   
--   The <tt>Reader</tt> monad (also called the Environment monad).
--   Represents a computation, which can read values from a shared
--   environment, pass values from function to function, and execute
--   sub-computations in a modified environment. Using <tt>Reader</tt>
--   monad for such computations is often clearer and easier than using the
--   <a>State</a> monad.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.Reader.Class

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r m | m -> r
ask :: MonadReader r m => m r
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment. Parameters:
--   
--   <ul>
--   <li>The selector function to apply to the environment.</li>
--   </ul>
--   
--   See an example in <a>Control.Monad.Reader</a>.
asks :: MonadReader r m => (r -> a) -> m a


-- | Declaration of the MonadRWS class.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.RWS.Class
class (Monoid w, MonadReader r m, MonadWriter w m, MonadState s m) => MonadRWS r w s m | m -> r, m -> w, m -> s


-- | <ul>
--   <li><i>Computation type:</i> Computations which can be interrupted and
--   resumed.</li>
--   <li><i>Binding strategy:</i> Binding a function to a monadic value
--   creates a new continuation which uses the function as the continuation
--   of the monadic computation.</li>
--   <li><i>Useful for:</i> Complex control structures, error handling, and
--   creating co-routines.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><tt>Cont</tt> r a</tt></li>
--   </ul>
--   
--   The Continuation monad represents computations in continuation-passing
--   style (CPS). In continuation-passing style function result is not
--   returned, but instead is passed to another function, received as a
--   parameter (continuation). Computations are built up from sequences of
--   nested continuations, terminated by a final continuation (often
--   <tt>id</tt>) which produces the final result. Since continuations are
--   functions which represent the future of a computation, manipulation of
--   the continuation functions can achieve complex manipulations of the
--   future of the computation, such as interrupting a computation in the
--   middle, aborting a portion of a computation, restarting a computation,
--   and interleaving execution of computations. The Continuation monad
--   adapts CPS to the structure of a monad.
--   
--   Before using the Continuation monad, be sure that you have a firm
--   understanding of continuation-passing style and that continuations
--   represent the best solution to your particular design problem. Many
--   algorithms which require continuations in other languages do not
--   require them in Haskell, due to Haskell's lazy semantics. Abuse of the
--   Continuation monad can produce code that is impossible to understand
--   and maintain.
module Control.Monad.Cont.Class
class Monad m => MonadCont m
callCC :: MonadCont m => ((a -> m b) -> m a) -> m a


-- | <ul>
--   <li><i>Computation type:</i> Computations which may fail or throw
--   exceptions.</li>
--   <li><i>Binding strategy:</i> Failure records information about the
--   cause/location of the failure. Failure values bypass the bound
--   function, other values are used as inputs to the bound function.</li>
--   <li><i>Useful for:</i> Building computations from sequences of
--   functions that may fail or using exception handling to structure error
--   handling.</li>
--   <li><i>Zero and plus:</i> Zero is represented by an empty error and
--   the plus operation executes its second argument if the first
--   fails.</li>
--   <li><i>Example type:</i> <tt><a>Either</a> String a</tt></li>
--   </ul>
--   
--   The Error monad (also called the Exception monad).
module Control.Monad.Error.Class

-- | An exception to be thrown. An instance must redefine at least one of
--   <a>noMsg</a>, <a>strMsg</a>.
class Error a where noMsg = strMsg "" strMsg _ = noMsg
noMsg :: Error a => a
strMsg :: Error a => String -> a

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   String</tt> or <tt><a>Either</a> IOError</tt>. In these cases you will
--   have to explicitly define instances of the <a>Error</a> and/or
--   <a>MonadError</a> classes.
class Monad m => MonadError e m | m -> e
throwError :: MonadError e m => e -> m a
catchError :: MonadError e m => m a -> (e -> m a) -> m a
instance Error IOError
instance Error String


-- | The MonadTrans class.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.Trans
class MonadTrans t where tmixmap f m = unlift (\ ul -> f $ ul m)
lift :: (MonadTrans t, Monad m) => m a -> t m a
mt :: (MonadTrans t, Monad m) => Transformation t m
unlift :: (MonadTrans t, Monad m, Monad n) => (forall f. Functor f => (forall x. t m x -> m (f x)) -> n (f a)) -> t n a
tmixmap :: (MonadTrans t, Monad m, Monad n) => (forall a. m a -> n a) -> t m c -> t n c
class Monad m => MonadIO m
liftIO :: MonadIO m => IO a -> m a
data Transformation (t :: (* -> *) -> * -> *) (m :: * -> *)
MT :: Transformation t m
tmap :: (MonadTrans t, Monad m, Monad n) => (forall a. m a -> n a) -> t m c -> t n c
instance MonadIO IO


-- | <ul>
--   <li><i>Computation type:</i> Computations which can be interrupted and
--   resumed.</li>
--   <li><i>Binding strategy:</i> Binding a function to a monadic value
--   creates a new continuation which uses the function as the continuation
--   of the monadic computation.</li>
--   <li><i>Useful for:</i> Complex control structures, error handling, and
--   creating co-routines.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><a>Cont</a> r a</tt></li>
--   </ul>
--   
--   The Continuation monad represents computations in continuation-passing
--   style (CPS). In continuation-passing style function result is not
--   returned, but instead is passed to another function, received as a
--   parameter (continuation). Computations are built up from sequences of
--   nested continuations, terminated by a final continuation (often
--   <tt>id</tt>) which produces the final result. Since continuations are
--   functions which represent the future of a computation, manipulation of
--   the continuation functions can achieve complex manipulations of the
--   future of the computation, such as interrupting a computation in the
--   middle, aborting a portion of a computation, restarting a computation,
--   and interleaving execution of computations. The Continuation monad
--   adapts CPS to the structure of a monad.
--   
--   Before using the Continuation monad, be sure that you have a firm
--   understanding of continuation-passing style and that continuations
--   represent the best solution to your particular design problem. Many
--   algorithms which require continuations in other languages do not
--   require them in Haskell, due to Haskell's lazy semantics. Abuse of the
--   Continuation monad can produce code that is impossible to understand
--   and maintain.
module Control.Monad.Cont

-- | Continuation monad. <tt>Cont r a</tt> is a CPS computation that
--   produces an intermediate result of type <tt>a</tt> within a CPS
--   computation whose final result type is <tt>r</tt>.
--   
--   The <tt>return</tt> function simply creates a continuation which
--   passes the value on.
--   
--   The <tt>&gt;&gt;=</tt> operator adds the bound function into the
--   continuation chain.
newtype Cont r a
Cont :: ((a -> r) -> r) -> Cont r a

-- | Runs a CPS computation, returns its result after applying the final
--   continuation to it. Parameters:
--   
--   <ul>
--   <li>a continuation computation (<tt>Cont</tt>).</li>
--   <li>the final continuation, which produces the final result (often
--   <tt>id</tt>).</li>
--   </ul>
runCont :: Cont r a -> (a -> r) -> r
mapCont :: (r -> r) -> Cont r a -> Cont r a
withCont :: ((b -> r) -> (a -> r)) -> Cont r a -> Cont r b

-- | The continuation monad transformer. Can be used to add continuation
--   handling to other monads.
newtype ContT r m a
ContT :: ((a -> m r) -> m r) -> ContT r m a
runContT :: ContT r m a -> (a -> m r) -> m r
mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
withContT :: ((b -> m r) -> (a -> m r)) -> ContT r m a -> ContT r m b
instance MonadState s m => MonadState s (ContT r m)
instance MonadReader r' m => MonadReader r' (ContT r m)
instance MonadIO m => MonadIO (ContT r m)
instance MonadTrans (ContT r)
instance Monad m => MonadCont (ContT r m)
instance Monad m => Monad (ContT r m)
instance Monad m => Functor (ContT r m)
instance MonadCont (Cont r)
instance Monad (Cont r)
instance Functor (Cont r)


-- | The List monad.
module Control.Monad.List
newtype ListT m a
ListT :: m [a] -> ListT m a
runListT :: ListT m a -> m [a]
mapListT :: (m [a] -> n [b]) -> ListT m a -> ListT n b
instance MonadState s m => MonadState s (ListT m)
instance MonadReader s m => MonadReader s (ListT m)
instance MonadError e m => MonadError e (ListT m)
instance MonadCont m => MonadCont (ListT m)
instance MonadIO m => MonadIO (ListT m)
instance MonadTrans ListT
instance Monad m => MonadPlus (ListT m)
instance Monad m => Monad (ListT m)
instance Monad m => Functor (ListT m)


-- | Lazy RWS monad.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.RWS.Lazy
newtype RWS r w s a
RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
runRWS :: RWS r w s a -> r -> s -> (a, s, w)
evalRWS :: RWS r w s a -> r -> s -> (a, w)
execRWS :: RWS r w s a -> r -> s -> (s, w)
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a
newtype RWST r w s m a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a
instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m)
instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m)
instance (Monoid w, MonadIO m) => MonadIO (RWST r w s m)
instance Monoid w => MonadTrans (RWST r w s)
instance (Monoid w, Monad m) => MonadRWS r w s (RWST r w s m)
instance (Monoid w, Monad m) => MonadState s (RWST r w s m)
instance (Monoid w, Monad m) => MonadWriter w (RWST r w s m)
instance (Monoid w, Monad m) => MonadReader r (RWST r w s m)
instance (Monoid w, MonadPlus m) => MonadPlus (RWST r w s m)
instance (Monoid w, Monad m) => Monad (RWST r w s m)
instance Monad m => Functor (RWST r w s m)
instance Monoid w => MonadRWS r w s (RWS r w s)
instance Monoid w => MonadState s (RWS r w s)
instance Monoid w => MonadWriter w (RWS r w s)
instance Monoid w => MonadReader r (RWS r w s)
instance Monoid w => Monad (RWS r w s)
instance Functor (RWS r w s)


-- | Declaration of the MonadRWS class.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.RWS


-- | Strict RWS Monad.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.RWS.Strict
newtype RWS r w s a
RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
runRWS :: RWS r w s a -> r -> s -> (a, s, w)
evalRWS :: RWS r w s a -> r -> s -> (a, w)
execRWS :: RWS r w s a -> r -> s -> (s, w)
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a
newtype RWST r w s m a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a
instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m)
instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m)
instance (Monoid w, MonadIO m) => MonadIO (RWST r w s m)
instance Monoid w => MonadTrans (RWST r w s)
instance (Monoid w, Monad m) => MonadRWS r w s (RWST r w s m)
instance (Monoid w, Monad m) => MonadState s (RWST r w s m)
instance (Monoid w, Monad m) => MonadWriter w (RWST r w s m)
instance (Monoid w, Monad m) => MonadReader r (RWST r w s m)
instance (Monoid w, MonadPlus m) => MonadPlus (RWST r w s m)
instance (Monoid w, Monad m) => Monad (RWST r w s m)
instance Monad m => Functor (RWST r w s m)
instance Monoid w => MonadRWS r w s (RWS r w s)
instance Monoid w => MonadState s (RWS r w s)
instance Monoid w => MonadWriter w (RWS r w s)
instance Monoid w => MonadReader r (RWS r w s)
instance Monoid w => Monad (RWS r w s)
instance Functor (RWS r w s)


-- | Strict state monads.
--   
--   This module is inspired by the paper /Functional Programming with
--   Overloading and Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
--   
--   See below for examples.
module Control.Monad.State.Strict

-- | A parameterizable state monad where <i>s</i> is the type of the state
--   to carry and <i>a</i> is the type of the <i>return value</i>.
newtype State s a
State :: (s -> (a, s)) -> State s a
runState :: State s a -> s -> (a, s)

-- | Evaluate this state monad with the given initial state,throwing away
--   the final state. Very much like <tt>fst</tt> composed with
--   <tt>runstate</tt>.
evalState :: State s a -> s -> a

-- | Execute this state and return the new state, throwing away the return
--   value. Very much like <tt>snd</tt> composed with <tt>runstate</tt>.
execState :: State s a -> s -> s

-- | Map a stateful computation from one (return value, state) pair to
--   another. For instance, to convert numberTree from a function that
--   returns a tree to a function that returns the sum of the numbered tree
--   (see the Examples section for numberTree and sumTree) you may write:
--   
--   <pre>
--   sumNumberedTree :: (Eq a) =&gt; Tree a -&gt; State (Table a) Int
--   sumNumberedTree = mapState (\ (t, tab) -&gt; (sumTree t, tab))  . numberTree
--   </pre>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | Apply this function to this state and return the resulting state.
withState :: (s -> s) -> State s a -> State s a

-- | A parameterizable state monad for encapsulating an inner monad.
--   
--   The StateT Monad structure is parameterized over two things:
--   
--   <ul>
--   <li>s - The state.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   Here are some examples of use:
--   
--   (Parser from ParseLib with Hugs)
--   
--   <pre>
--   type Parser a = StateT String [] a
--      ==&gt; StateT (String -&gt; [(a,String)])
--   </pre>
--   
--   For example, item can be written as:
--   
--   <pre>
--   item = do (x:xs) &lt;- get
--          put xs
--          return x
--   
--   type BoringState s a = StateT s Indentity a
--        ==&gt; StateT (s -&gt; Identity (a,s))
--   
--   type StateWithIO s a = StateT s IO a
--        ==&gt; StateT (s -&gt; IO (a,s))
--   
--   type StateWithErr s a = StateT s Maybe a
--        ==&gt; StateT (s -&gt; Maybe (a,s))
--   </pre>
newtype StateT s m a
StateT :: (s -> m (a, s)) -> StateT s m a
runStateT :: StateT s m a -> s -> m (a, s)

-- | Similar to <a>evalState</a>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Similar to <a>execState</a>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Similar to <a>mapState</a>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | Similar to <a>withState</a>
withStateT :: (s -> s) -> StateT s m a -> StateT s m a
instance MonadWriter w m => MonadWriter w (StateT s m)
instance MonadReader r m => MonadReader r (StateT s m)
instance MonadError e m => MonadError e (StateT s m)
instance MonadCont m => MonadCont (StateT s m)
instance MonadIO m => MonadIO (StateT s m)
instance MonadTrans (StateT s)
instance Monad m => MonadState s (StateT s m)
instance MonadPlus m => MonadPlus (StateT s m)
instance Monad m => Monad (StateT s m)
instance Monad m => Functor (StateT s m)
instance MonadState s (State s)
instance Monad (State s)
instance Functor (State s)


-- | Lazy writer monads.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>) Advanced
--   School of Functional Programming, 1995.
module Control.Monad.Writer.Lazy
newtype Writer w a
Writer :: (a, w) -> Writer w a
runWriter :: Writer w a -> (a, w)
execWriter :: Writer w a -> w
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
newtype WriterT w m a
WriterT :: m (a, w) -> WriterT w m a
runWriterT :: WriterT w m a -> m (a, w)
execWriterT :: Monad m => WriterT w m a -> m w
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
instance (Monoid w, MonadState s m) => MonadState s (WriterT w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance (Monoid w, MonadError e m) => MonadError e (WriterT w m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT w m)
instance (Monoid w, MonadIO m) => MonadIO (WriterT w m)
instance Functor (WriterF w)
instance Monoid w => MonadTrans (WriterT w)
instance (Monoid w, Monad m) => MonadWriter w (WriterT w m)
instance (Monoid w, MonadPlus m) => MonadPlus (WriterT w m)
instance (Monoid w, Monad m) => Monad (WriterT w m)
instance Monad m => Functor (WriterT w m)
instance Monoid w => MonadWriter w (Writer w)
instance Monoid w => Monad (Writer w)
instance Functor (Writer w)


-- | Strict writer monads.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>) Advanced
--   School of Functional Programming, 1995.
module Control.Monad.Writer.Strict
newtype Writer w a
Writer :: (a, w) -> Writer w a
runWriter :: Writer w a -> (a, w)
execWriter :: Writer w a -> w
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
newtype WriterT w m a
WriterT :: m (a, w) -> WriterT w m a
runWriterT :: WriterT w m a -> m (a, w)
execWriterT :: Monad m => WriterT w m a -> m w
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
instance (Monoid w, MonadState s m) => MonadState s (WriterT w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance (Monoid w, MonadError e m) => MonadError e (WriterT w m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT w m)
instance (Monoid w, MonadIO m) => MonadIO (WriterT w m)
instance Monoid w => MonadTrans (WriterT w)
instance (Monoid w, Monad m) => MonadWriter w (WriterT w m)
instance (Monoid w, MonadPlus m) => MonadPlus (WriterT w m)
instance (Monoid w, Monad m) => Monad (WriterT w m)
instance Monad m => Functor (WriterT w m)
instance Monoid w => MonadWriter w (Writer w)
instance Monoid w => Monad (Writer w)
instance Functor (Writer w)


-- | Lazy state monads.
--   
--   This module is inspired by the paper /Functional Programming with
--   Overloading and Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
--   
--   See below for examples.
module Control.Monad.State.Lazy

-- | A parameterizable state monad where <i>s</i> is the type of the state
--   to carry and <i>a</i> is the type of the <i>return value</i>.
newtype State s a
State :: (s -> (a, s)) -> State s a
runState :: State s a -> s -> (a, s)

-- | Evaluate this state monad with the given initial state,throwing away
--   the final state. Very much like <tt>fst</tt> composed with
--   <tt>runstate</tt>.
evalState :: State s a -> s -> a

-- | Execute this state and return the new state, throwing away the return
--   value. Very much like <tt>snd</tt> composed with <tt>runstate</tt>.
execState :: State s a -> s -> s

-- | Map a stateful computation from one (return value, state) pair to
--   another. For instance, to convert numberTree from a function that
--   returns a tree to a function that returns the sum of the numbered tree
--   (see the Examples section for numberTree and sumTree) you may write:
--   
--   <pre>
--   sumNumberedTree :: (Eq a) =&gt; Tree a -&gt; State (Table a) Int
--   sumNumberedTree = mapState (\ (t, tab) -&gt; (sumTree t, tab))  . numberTree
--   </pre>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | Apply this function to this state and return the resulting state.
withState :: (s -> s) -> State s a -> State s a

-- | A parameterizable state monad for encapsulating an inner monad.
--   
--   The StateT Monad structure is parameterized over two things:
--   
--   <ul>
--   <li>s - The state.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   Here are some examples of use:
--   
--   (Parser from ParseLib with Hugs)
--   
--   <pre>
--   type Parser a = StateT String [] a
--      ==&gt; StateT (String -&gt; [(a,String)])
--   </pre>
--   
--   For example, item can be written as:
--   
--   <pre>
--   item = do (x:xs) &lt;- get
--          put xs
--          return x
--   
--   type BoringState s a = StateT s Indentity a
--        ==&gt; StateT (s -&gt; Identity (a,s))
--   
--   type StateWithIO s a = StateT s IO a
--        ==&gt; StateT (s -&gt; IO (a,s))
--   
--   type StateWithErr s a = StateT s Maybe a
--        ==&gt; StateT (s -&gt; Maybe (a,s))
--   </pre>
newtype StateT s m a
StateT :: (s -> m (a, s)) -> StateT s m a
runStateT :: StateT s m a -> s -> m (a, s)

-- | Similar to <a>evalState</a>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Similar to <a>execState</a>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Similar to <a>mapState</a>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | Similar to <a>withState</a>
withStateT :: (s -> s) -> StateT s m a -> StateT s m a
instance MonadWriter w m => MonadWriter w (StateT s m)
instance MonadReader r m => MonadReader r (StateT s m)
instance MonadError e m => MonadError e (StateT s m)
instance MonadCont m => MonadCont (StateT s m)
instance MonadIO m => MonadIO (StateT s m)
instance Functor (RPair s)
instance MonadTrans (StateT s)
instance Monad m => MonadState s (StateT s m)
instance MonadPlus m => MonadPlus (StateT s m)
instance Monad m => Monad (StateT s m)
instance Monad m => Functor (StateT s m)
instance MonadState s (State s)
instance Monad (State s)
instance Functor (State s)


-- | The MonadWriter class.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>) Advanced
--   School of Functional Programming, 1995.
module Control.Monad.Writer


-- | State monads.
--   
--   This module is inspired by the paper /Functional Programming with
--   Overloading and Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.State


-- | <ul>
--   <li><i>Computation type:</i> Simple function application.</li>
--   <li><i>Binding strategy:</i> The bound function is applied to the
--   input value. <tt><a>Identity</a> x &gt;&gt;= f == <a>Identity</a> (f
--   x)</tt></li>
--   <li><i>Useful for:</i> Monads can be derived from monad transformers
--   applied to the <a>Identity</a> monad.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><a>Identity</a> a</tt></li>
--   </ul>
--   
--   The <tt>Identity</tt> monad is a monad that does not embody any
--   computational strategy. It simply applies the bound function to its
--   input without any modification. Computationally, there is no reason to
--   use the <tt>Identity</tt> monad instead of the much simpler act of
--   simply applying functions to their arguments. The purpose of the
--   <tt>Identity</tt> monad is its fundamental role in the theory of monad
--   transformers. Any monad transformer applied to the <tt>Identity</tt>
--   monad yields a non-transformer version of that monad.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.Identity

-- | Identity wrapper. Abstraction for wrapping up a object. If you have an
--   monadic function, say:
--   
--   <pre>
--   example :: Int -&gt; Identity Int
--   example x = return (x*x)
--   </pre>
--   
--   you can "run" it, using
--   
--   <pre>
--   Main&gt; runIdentity (example 42)
--   1764 :: Int
--   </pre>
--   
--   A typical use of the Identity monad is to derive a monad from a monad
--   transformer.
--   
--   <pre>
--   -- derive the <a>State</a> monad using the <a>StateT</a> monad transformer
--   type <a>State</a> s a = <a>StateT</a> s <a>Identity</a> a
--   </pre>
--   
--   The <tt><a>runIdentity</a></tt> label is used in the type definition
--   because it follows a style of monad definition that explicitly
--   represents monad values as computations. In this style, a monadic
--   computation is built up using the monadic operators and then the value
--   of the computation is extracted using the <tt>run******</tt> function.
--   Because the <tt>Identity</tt> monad does not do any computation, its
--   definition is trivial. For a better example of this style of monad,
--   see the <tt><a>State</a></tt> monad.
newtype Identity a
Identity :: a -> Identity a
runIdentity :: Identity a -> a
newtype IdentityT m a
IdentityT :: m a -> IdentityT m a
runIdentityT :: IdentityT m a -> m a
instance MonadState w m => MonadState w (IdentityT m)
instance MonadWriter w m => MonadWriter w (IdentityT m)
instance MonadTrans IdentityT
instance Monad m => Monad (IdentityT m)
instance Monad Identity
instance Functor Identity


-- | <ul>
--   <li><i>Computation type:</i> Computations which read values from a
--   shared environment.</li>
--   <li><i>Binding strategy:</i> Monad values are functions from the
--   environment to a value. The bound function is applied to the bound
--   value, and both have access to the shared environment.</li>
--   <li><i>Useful for:</i> Maintaining variable bindings, or other shared
--   environment.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><a>Reader</a> [(String,Value)]
--   a</tt></li>
--   </ul>
--   
--   The <a>Reader</a> monad (also called the Environment monad).
--   Represents a computation, which can read values from a shared
--   environment, pass values from function to function, and execute
--   sub-computations in a modified environment. Using <a>Reader</a> monad
--   for such computations is often clearer and easier than using the
--   <a>State</a> monad.
--   
--   Inspired by the paper /Functional Programming with Overloading and
--   Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.Reader

-- | The parameterizable reader monad.
--   
--   The <tt>return</tt> function creates a <tt>Reader</tt> that ignores
--   the environment, and produces the given value.
--   
--   The binding operator <tt>&gt;&gt;=</tt> produces a <tt>Reader</tt>
--   that uses the environment to extract the value its left-hand side, and
--   then applies the bound function to that value in the same environment.
newtype Reader r a
Reader :: (r -> a) -> Reader r a

-- | Runs <tt>Reader</tt> and extracts the final value from it. To extract
--   the value apply <tt>(runReader reader)</tt> to an environment value.
--   Parameters:
--   
--   <ul>
--   <li>A <tt>Reader</tt> to run.</li>
--   <li>An initial environment.</li>
--   </ul>
runReader :: Reader r a -> r -> a
mapReader :: (a -> b) -> Reader r a -> Reader r b

-- | A more general version of <a>local</a>.
withReader :: (r' -> r) -> Reader r a -> Reader r' a

-- | The reader monad transformer. Can be used to add environment reading
--   functionality to other monads.
newtype ReaderT r m a
ReaderT :: (r -> m a) -> ReaderT r m a
runReaderT :: ReaderT r m a -> r -> m a
mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
withReaderT :: (r' -> r) -> ReaderT r m a -> ReaderT r' m a
instance MonadWriter w m => MonadWriter w (ReaderT r m)
instance MonadState s m => MonadState s (ReaderT r m)
instance MonadError e m => MonadError e (ReaderT r m)
instance MonadCont m => MonadCont (ReaderT r m)
instance MonadIO m => MonadIO (ReaderT r m)
instance MonadTrans (ReaderT r)
instance Monad m => MonadReader r (ReaderT r m)
instance MonadPlus m => MonadPlus (ReaderT r m)
instance Monad m => Monad (ReaderT r m)
instance Monad m => Functor (ReaderT r m)
instance MonadReader r (Reader r)
instance Monad (Reader r)
instance Functor (Reader r)


-- | <ul>
--   <li><i>Computation type:</i> Computations which may fail or throw
--   exceptions.</li>
--   <li><i>Binding strategy:</i> Failure records information about the
--   cause/location of the failure. Failure values bypass the bound
--   function, other values are used as inputs to the bound function.</li>
--   <li><i>Useful for:</i> Building computations from sequences of
--   functions that may fail or using exception handling to structure error
--   handling.</li>
--   <li><i>Zero and plus:</i> Zero is represented by an empty error and
--   the plus operation executes its second argument if the first
--   fails.</li>
--   <li><i>Example type:</i> <tt><a>Either</a> String a</tt></li>
--   </ul>
--   
--   The Error monad (also called the Exception monad).
module Control.Monad.Error

-- | The error monad transformer. It can be used to add error handling to
--   other monads.
--   
--   The <tt>ErrorT</tt> Monad structure is parameterized over two things:
--   
--   <ul>
--   <li>e - The error type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   Here are some examples of use:
--   
--   <pre>
--   -- wraps IO action that can throw an error e
--   type ErrorWithIO e a = ErrorT e IO a
--   ==&gt; ErrorT (IO (Either e a))
--   
--   -- IO monad wrapped in StateT inside of ErrorT
--   type ErrorAndStateWithIO e s a = ErrorT e (StateT s IO) a
--   ==&gt; ErrorT (StateT s IO (Either e a))
--   ==&gt; ErrorT (StateT (s -&gt; IO (Either e a,s)))
--   </pre>
newtype ErrorT e m a
ErrorT :: m (Either e a) -> ErrorT e m a
runErrorT :: ErrorT e m a -> m (Either e a)
mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
instance (Error e, MonadWriter w m) => MonadWriter w (ErrorT e m)
instance (Error e, MonadState s m) => MonadState s (ErrorT e m)
instance (Error e, MonadReader r m) => MonadReader r (ErrorT e m)
instance (Error e, MonadRWS r w s m) => MonadRWS r w s (ErrorT e m)
instance (Error e, MonadCont m) => MonadCont (ErrorT e m)
instance (Error e, MonadIO m) => MonadIO (ErrorT e m)
instance Error e => MonadTrans (ErrorT e)
instance (Monad m, Error e) => MonadError e (ErrorT e m)
instance (Monad m, Error e) => MonadPlus (ErrorT e m)
instance (Monad m, Error e) => Monad (ErrorT e m)
instance Monad m => Functor (ErrorT e m)
instance MonadError IOError IO

module Control.Monad.Zipper
newtype (:>) t1 (t2 :: (* -> *) -> * -> *) m a
Z :: t1 (t2 m) a -> :> t1 m a
runZ :: :> t1 m a -> t1 (t2 m) a
leftL :: :> t1 t2 m a -> t1 (t2 m) a
rightL :: t1 (t2 m) a -> :> t1 t2 m a
returnZ :: (MonadTrans t1, MonadTrans t2, Monad m) => a -> (t1 :> t2) m a
bindZ :: (MonadTrans t1, MonadTrans t2, Monad m) => (t1 :> t2) m a -> (a -> (t1 :> t2) m b) -> (t1 :> t2) m b
liftZ :: (MonadTrans t1, MonadTrans t2, Monad m) => m a -> (t1 :> t2) m a
unliftZ :: (Monad m, Monad n, MonadTrans t1, MonadTrans t2) => (forall f. Functor f => (forall x. (t1 :> t2) m x -> m (f x)) -> n (f a)) -> (t1 :> t2) n a
newtype FComp f1 f2 a
FComp :: f1 (f2 a) -> FComp f1 f2 a
runFComp :: FComp f1 f2 a -> f1 (f2 a)
instance (MonadTrans t1, MonadTrans t2, Monad m, MonadWriter w (t2 m)) => MonadWriter w ((:>) t1 t2 m)
instance (MonadTrans t1, MonadTrans t2, Monad m, MonadReader e (t2 m)) => MonadReader e ((:>) t1 t2 m)
instance (MonadTrans t1, MonadTrans t2, Monad m, MonadError e (t2 m)) => MonadError e ((:>) t1 t2 m)
instance (MonadTrans t1, MonadTrans t2, Monad m, MonadState s (t2 m)) => MonadState s ((:>) t1 t2 m)
instance (Functor f1, Functor f2) => Functor (FComp f1 f2)
instance (MonadTrans t1, MonadTrans t2) => MonadTrans (t1 :> t2)
instance (MonadTrans t1, MonadTrans t2, Monad m) => Monad ((:>) t1 t2 m)

module Control.Monad.Views
class MonadMorphism g
idv :: (MonadMorphism g, Monad m) => m g m
hcomp :: (MonadMorphism g, Monad l, Monad m, Monad n) => (m g n) -> (l g m) -> (l g n)
hmap :: (MonadMorphism g, Monad m, Monad n, MonadTrans t) => (m g n) -> (t m g t n)
from :: (MonadMorphism g, Monad m, Monad n) => (n g m) -> n a -> m a
htmap :: (Monad (t1 n), Monad (t2 n), Monad m, Monad n, Monad (t1 m), MonadTrans t1, MonadMorphism g) => (forall m. Monad m => t1 m g t2 m) -> (m g n) -> t1 m g t2 n
newtype (:->) n m
Uni :: (forall a. n a -> m a) -> :-> n m
liftv :: (MonadTrans t, Monad m) => m :-> t m
r1 :: (MonadTrans t, Monad m, MonadState s (t m)) => ReaderT s m :-> t m
ra :: (Monad m, MonadState r (t m), MonadTrans t) => :-> (ReaderT r m) (t m)
data (:><:) n m
Bi :: (forall a. n a -> m a) -> (forall a. m a -> n a) -> :><: n m
bifrom :: :><: n m -> forall a. n a -> m a
bito :: :><: n m -> forall a. m a -> n a
to :: (Monad n, Monad m) => n :><: m -> m a -> n a
inverse :: (Monad n, Monad m) => n :><: m -> m :><: n
class MonadMorphism g => View g
view :: View g => (forall a. n a -> m a) -> (forall a. m a -> n a) -> n g m
stateIso :: (Monad m, View g) => (s2 -> s1) -> (s1 -> s2) -> StateT s2 m g StateT s1 m
newtype MonadStateReaderT s m a
MonadStateReaderT :: m a -> MonadStateReaderT s m a
runMonadStateReaderT :: MonadStateReaderT s m a -> m a
r2 :: (MonadState s m, View g) => MonadStateReaderT s m g m
i :: (Monad m, View g) => m g m
o :: (MonadTrans t1, MonadTrans t2, Monad m, View g) => (t1 :> t2) m g t1 (t2 m)
vcomp :: (Monad (t m), Monad (t n1), Monad n, Monad m, Monad n1, MonadTrans t, MonadMorphism g) => g (t n1) n -> g m n1 -> g (t m) n
instance [overlap ok] Monad m => Monad (MonadStateReaderT s m)
instance [overlap ok] MonadTrans (MonadStateReaderT s)
instance [overlap ok] MonadWriter w m => MonadWriter w (MonadStateReaderT s m)
instance [overlap ok] MonadState s m => MonadReader s (MonadStateReaderT s m)
instance [overlap ok] View :><:
instance [overlap ok] View :->
instance [overlap ok] MonadMorphism :><:
instance [overlap ok] MonadMorphism :->

module Control.Monad.Mask
newtype Tagged tag m a
Tag :: m a -> Tagged tag m a
unTag :: Tagged tag m a -> m a
type TStateT tag s m = Tagged tag (StateT s m)
runTStateT :: Monad m => s -> TStateT tag s m a -> m (a, s)
evalTStateT :: Monad m => s -> TStateT tag s m a -> m a
type TErrorT tag error m = Tagged tag (ErrorT error m)
runTErrorT :: Monad m => TErrorT tag e m a -> m (Either e a)
class (Monad m, Monad n) => TWith tag n m
structure :: (TWith tag n m, View g) => tag -> (n g m)
use :: TWith tag n m => n a -> tag -> m a
expose :: TWith tag n m => m a -> tag -> n a
t :: View g => m g Tagged tag m
unt :: View g => Tagged tag m g m
inverse_o :: View g => g (t1 (t2 m)) (:> t1 t2 m)
data Log1
Log1 :: Log1
data Log2
Log2 :: Log2
ifpos1 :: MonadState Int m => m () -> m ()
luse :: LWith taglist n m => n a -> taglist -> m a
data (:&:) e l
(:&:) :: e -> l -> :&: e l
data HTrue
HTrue :: HTrue
data HFalse
HFalse :: HFalse
class HMember e l b
hmember :: HMember e l b => e -> l -> b
class LWith list (n :: * -> *) (m :: * -> *)
lstructure :: (LWith list n m, View g) => list -> (n g m)
class LWith1 list b (n :: * -> *) (m :: * -> *)
lstructure1 :: (LWith1 list b n m, View g) => list -> b -> (n g m)
class LWith2 list b (n :: * -> *) (m :: * -> *)
lstructure2 :: (LWith2 list b n m, View g) => list -> b -> (n g m)
getv :: (Monad m, MonadState a n, MonadMorphism g) => g n m -> m a
putv :: (Monad m, MonadState a n, MonadMorphism g) => g n m -> a -> m ()
instance [overlap ok] (Monad m, Monad n, LWith list n ((:>) (t0 :> t1) t2 m), MonadTrans t2, MonadTrans t1, MonadTrans t0) => LWith2 list HFalse n ((:>) t0 (Tagged e) (t1 (t2 m)))
instance [overlap ok] (Monad m, n ~ (:>) t0 t n', Monad n', LWith list n' m, MonadTrans t, MonadTrans t0) => LWith2 list HTrue n ((:>) t0 (Tagged e) (t m))
instance [overlap ok] (LWith list n ((:>) t t' m), Monad n, Monad m, MonadTrans t, MonadTrans t') => LWith1 list HFalse n (Tagged e (t (t' m)))
instance [overlap ok] (Monad m, n ~ t n', Monad n', LWith list n' m, MonadTrans t) => LWith1 list HTrue n (Tagged e (t m))
instance [overlap ok] (m ~ n, Monad m, Monad n) => LWith l n m
instance [overlap ok] (HMember t l b, LWith2 l b n ((:>) t0 (Tagged t) m), Monad m, Monad n) => LWith l n ((:>) t0 (Tagged t) m)
instance [overlap ok] (HMember t l b, LWith1 l b n (Tagged t m), Monad m, Monad n) => LWith l n (Tagged t m)
instance [overlap ok] HMember e l b => HMember e (f :&: l) b
instance [overlap ok] b ~ HTrue => HMember e (e :&: l) b
instance [overlap ok] b ~ HFalse => HMember e f b
instance [overlap ok] b ~ HTrue => HMember e e b
instance [overlap ok] (Monad (t0 (t1 n)), Monad m, Monad n, TWith tag m ((:>) t0 t1 n), MonadTrans t0, MonadTrans t1) => TWith tag m (t0 (t1 n))
instance [overlap ok] (Monad (t' n), Monad m, Monad n, MonadTrans t, m ~ (:>) (t :> Tagged tag) t' n, MonadTrans t') => TWith tag m ((:>) t (Tagged tag) (t' n))
instance [overlap ok] (Monad m, Monad n, MonadTrans t, m ~ t n) => TWith tag m ((:>) t (Tagged tag) n)
instance [overlap ok] (Monad m, m ~ t n, MonadTrans t) => TWith tag m (Tagged tag (t n))
instance [overlap ok] (Monad m, m ~ n) => TWith tag n (Tagged tag m)
instance [overlap ok] MonadState s m => MonadState s (Tagged t m)
instance [overlap ok] Monad m => Monad (Tagged tag m)
instance [overlap ok] MonadTrans (Tagged tag)
