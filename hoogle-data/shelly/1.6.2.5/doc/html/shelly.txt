-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | shell-like (systems) programming in Haskell
--   
@package shelly
@version 1.6.2.5


-- | A module for shell-like programming in Haskell. Shelly's focus is
--   entirely on ease of use for those coming from shell scripting.
--   However, it also tries to use modern libraries and techniques to keep
--   things efficient.
--   
--   The functionality provided by this module is (unlike standard Haskell
--   filesystem functionality) thread-safe: each Sh maintains its own
--   environment and its own working directory.
--   
--   Recommended usage includes putting the following at the top of your
--   program, otherwise you will likely need either type annotations or
--   type conversions
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import qualified Data.Text as T
--   default (T.Text)
--   </pre>
module Shelly
data Sh a

-- | ShIO is Deprecated in favor of <a>Sh</a>, which is easier to type.

-- | <i>Deprecated: Use Sh instead of ShIO</i>
type ShIO a = Sh a

-- | Enter a Sh from (Monad)IO. The environment and working directories are
--   inherited from the current process-wide values. Any subsequent changes
--   in processwide working directory or environment are not reflected in
--   the running Sh.
shelly :: MonadIO m => Sh a -> m a

-- | Deprecated now, just use <a>shelly</a>, whose default has been
--   changed. Using this entry point does not create a <tt>.shelly</tt>
--   directory in the case of failure. Instead it logs directly into the
--   standard error stream (<tt>stderr</tt>).

-- | <i>Deprecated: Just use shelly. The default settings have changed</i>
shellyNoDir :: MonadIO m => Sh a -> m a

-- | Using this entry point creates a <tt>.shelly</tt> directory in the
--   case of failure where errors are recorded.
shellyFailDir :: MonadIO m => Sh a -> m a

-- | spawn an asynchronous action with a copy of the current state
asyncSh :: Sh a -> Sh (Async a)

-- | Enter a sub-Sh that inherits the environment The original state will
--   be restored when the sub-Sh completes. Exceptions are propagated
--   normally.
sub :: Sh a -> Sh a

-- | Create a sub-Sh in which external command outputs are not echoed and
--   commands are not printed. See <a>sub</a>.
silently :: Sh a -> Sh a

-- | Create a sub-Sh in which external command outputs are echoed and
--   Executed commands are printed See <a>sub</a>.
verbosely :: Sh a -> Sh a

-- | Create a sub-Sh with shell character escaping on or off. Defaults to
--   <tt>True</tt>.
--   
--   Setting to <tt>False</tt> allows for shell wildcard such as * to be
--   expanded by the shell along with any other special shell characters.
--   As a side-effect, setting to <tt>False</tt> causes changes to
--   <tt>PATH</tt> to be ignored: see the <a>run</a> documentation.
escaping :: Bool -> Sh a -> Sh a

-- | Create a sub-Sh with stdout printing on or off Defaults to True.
print_stdout :: Bool -> Sh a -> Sh a

-- | Create a sub-Sh with stderr printing on or off Defaults to True.
print_stderr :: Bool -> Sh a -> Sh a

-- | Create a sub-Sh with command echoing on or off Defaults to False, set
--   to True by <a>verbosely</a>
print_commands :: Bool -> Sh a -> Sh a

-- | When running an external command, apply the given initializers to the
--   specified handles for that command. This can for example be used to
--   change the encoding of the handles or set them into binary mode.
onCommandHandles :: StdInit -> Sh a -> Sh a

-- | Create a sub-Sh where commands are not traced Defaults to True. You
--   should only set to False temporarily for very specific reasons
tracing :: Bool -> Sh a -> Sh a

-- | named after bash -e errexit. Defaults to <tt>True</tt>. When
--   <tt>True</tt>, throw an exception on a non-zero exit code. When
--   <tt>False</tt>, ignore a non-zero exit code. Not recommended to set to
--   <tt>False</tt> unless you are specifically checking the error code
--   with <a>lastExitCode</a>.
errExit :: Bool -> Sh a -> Sh a

-- | Create a sub-Sh in which stdout is sent to the user-defined logger
log_stdout_with :: (Text -> IO ()) -> Sh a -> Sh a

-- | Create a sub-Sh in which stderr is sent to the user-defined logger
log_stderr_with :: (Text -> IO ()) -> Sh a -> Sh a

-- | Execute an external command. Takes the command name and arguments.
--   
--   You may prefer using <a>cmd</a> instead, which is a variadic argument
--   version of this function.
--   
--   <a>stdout</a> and <a>stderr</a> are collected. The <a>stdout</a> is
--   returned as a result of <a>run</a>, and complete stderr output is
--   available after the fact using <a>lastStderr</a>
--   
--   All of the stdout output will be loaded into memory. You can avoid
--   this if you don't need stdout by using <a>run_</a>, If you want to
--   avoid the memory and need to process the output then use
--   <a>runFoldLines</a> or <a>runHandle</a> or <a>runHandles</a>.
--   
--   By default shell characters are escaped and the command name is a name
--   of a program that can be found via <tt>PATH</tt>. Shelly will look
--   through the <tt>PATH</tt> itself to find the command.
--   
--   When <a>escaping</a> is set to <tt>False</tt>, shell characters are
--   allowed. Since there is no longer a guarantee that a single program
--   name is given, Shelly cannot look in the <tt>PATH</tt> for it. a
--   <tt>PATH</tt> modified by setenv is not taken into account when
--   finding the exe name. Instead the original Haskell program
--   <tt>PATH</tt> is used. On a Posix system the <tt>env</tt> command can
--   be used to make the <a>setenv</a> PATH used when <a>escaping</a> is
--   set to False. <tt>env echo hello</tt> instead of <tt>echo hello</tt>
run :: FilePath -> [Text] -> Sh Text

-- | the same as <a>run</a>, but return <tt>()</tt> instead of the stdout
--   content stdout will be read and discarded line-by-line
run_ :: FilePath -> [Text] -> Sh ()

-- | used by <a>run</a>. fold over stdout line-by-line as it is read to
--   avoid keeping it in memory stderr is still being placed in memory
--   under the assumption it is always relatively small
runFoldLines :: a -> FoldCallback a -> FilePath -> [Text] -> Sh a

-- | variadic argument version of <a>run</a>. Please see the documenation
--   for <a>run</a>.
--   
--   The syntax is more convenient, but more importantly it also allows the
--   use of a FilePath as a command argument. So an argument can be a Text
--   or a FilePath without manual conversions. a FilePath is automatically
--   converted to Text with <a>toTextIgnore</a>.
--   
--   Convenient usage of <a>cmd</a> requires the following:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import qualified Data.Text as T
--   default (T.Text)
--   </pre>
cmd :: ShellCmd result => FilePath -> result
type FoldCallback a = a -> Text -> a

-- | Pipe operator. set the stdout the first command as the stdin of the
--   second. This does not create a shell-level pipe, but hopefully it will
--   in the future. To create a shell level pipe you can set <tt>escaping
--   False</tt> and use a pipe <tt>|</tt> character in a command.
(-|-) :: Sh Text -> Sh b -> Sh b

-- | The output of last external command. See <a>run</a>.
lastStderr :: Sh Text

-- | set the stdin to be used and cleared by the next <a>run</a>.
setStdin :: Text -> Sh ()

-- | The exit code from the last command. Unless you set <a>errExit</a> to
--   False you won't get a chance to use this: a non-zero exit code will
--   throw an exception.
lastExitCode :: Sh Int

-- | bind some arguments to run for re-use. Example:
--   
--   <pre>
--   monit = command "monit" ["-c", "monitrc"]
--   monit ["stop", "program"]
--   </pre>
command :: FilePath -> [Text] -> [Text] -> Sh Text

-- | bind some arguments to <a>run_</a> for re-use. Example:
--   
--   <pre>
--   monit_ = command_ "monit" ["-c", "monitrc"]
--   monit_ ["stop", "program"]
--   </pre>
command_ :: FilePath -> [Text] -> [Text] -> Sh ()

-- | bind some arguments to run for re-use, and require 1 argument.
--   Example:
--   
--   <pre>
--   git = command1 "git" []; git "pull" ["origin", "master"]
--   </pre>
command1 :: FilePath -> [Text] -> Text -> [Text] -> Sh Text

-- | bind some arguments to run for re-use, and require 1 argument.
--   Example:
--   
--   <pre>
--   git_ = command1_ "git" []; git "pull" ["origin", "master"]
--   </pre>
command1_ :: FilePath -> [Text] -> Text -> [Text] -> Sh ()

-- | run commands over SSH. An ssh executable is expected in your path.
--   Commands are in the same form as <a>run</a>, but given as pairs
--   
--   <pre>
--   sshPairs "server-name" [("cd", "dir"), ("rm",["-r","dir2"])]
--   </pre>
--   
--   This interface is crude, but it works for now.
--   
--   Please note this sets <a>escaping</a> to False: the commands will not
--   be shell escaped. Internally the list of commands are combined with
--   the string <tt>&amp;&amp;</tt> before given to ssh.
sshPairs :: Text -> [(FilePath, [Text])] -> Sh Text

-- | same as <a>sshPairs</a>, but returns ()
sshPairs_ :: Text -> [(FilePath, [Text])] -> Sh ()

-- | For the variadic function <a>cmd</a>
--   
--   partially applied variadic functions require type signatures
class ShellCmd t
cmdAll :: ShellCmd t => FilePath -> [Text] -> t

-- | Argument converter for the variadic argument version of <a>run</a>
--   called <a>cmd</a>. Useful for a type signature of a function that uses
--   <a>cmd</a>
class CmdArg a
toTextArg :: CmdArg a => a -> Text

-- | Similar to <a>run</a> but gives the raw stdout handle in a callback.
--   If you want even more control, use <a>runHandles</a>.
runHandle :: FilePath -> [Text] -> (Handle -> Sh a) -> Sh a

-- | Similar to <a>run</a> but gives direct access to all input and output
--   handles.
--   
--   Be careful when using the optional input handles. If you specify
--   Inherit for a handle then attempting to access the handle in your
--   callback is an error
runHandles :: FilePath -> [Text] -> [StdHandle] -> (Handle -> Handle -> Handle -> Sh a) -> Sh a

-- | Transfer from one handle to another For example, send contents of a
--   process output to stdout. does not close the write handle.
--   
--   Also, return the complete contents being streamed line by line.
transferLinesAndCombine :: Handle -> (Text -> IO ()) -> IO Text

-- | Transfer from one handle to another For example, send contents of a
--   process output to stdout. does not close the write handle.
--   
--   Also, fold over the contents being streamed line by line
transferFoldHandleLines :: a -> FoldCallback a -> Handle -> (Text -> IO ()) -> IO a
data StdHandle
InHandle :: StdStream -> StdHandle
OutHandle :: StdStream -> StdHandle
ErrorHandle :: StdStream -> StdHandle
data StdStream :: *

-- | Inherit Handle from parent
Inherit :: StdStream

-- | Use the supplied Handle
UseHandle :: Handle -> StdStream

-- | Create a new pipe. The returned <tt>Handle</tt> will use the default
--   encoding and newline translation mode (just like <tt>Handle</tt>s
--   created by <tt>openFile</tt>).
CreatePipe :: StdStream

-- | Initialize a handle before using it
type HandleInitializer = Handle -> IO ()

-- | A collection of initializers for the three standard process handles
data StdInit
StdInit :: HandleInitializer -> HandleInitializer -> HandleInitializer -> StdInit
inInit :: StdInit -> HandleInitializer
outInit :: StdInit -> HandleInitializer
errInit :: StdInit -> HandleInitializer

-- | Apply a single initializer to the two output process handles (stdout
--   and stderr)
initOutputHandles :: HandleInitializer -> StdInit

-- | Apply a single initializer to all three standard process handles
--   (stdin, stdout and stderr)
initAllHandles :: HandleInitializer -> StdInit

-- | Set an environment variable. The environment is maintained in Sh
--   internally, and is passed to any external commands to be executed.
setenv :: Text -> Text -> Sh ()

-- | Fetch the current value of an environment variable. if non-existant or
--   empty text, will be Nothing
get_env :: Text -> Sh (Maybe Text)

-- | Fetch the current value of an environment variable. Both empty and
--   non-existent variables give empty string as a result.
get_env_text :: Text -> Sh Text

-- | deprecated

-- | <i>Deprecated: use get_env or get_env_text</i>
getenv :: Text -> Sh Text

-- | Fetch the current value of an environment variable. Both empty and
--   non-existent variables give the default Text value as a result

-- | <i>Deprecated: use fromMaybe DEFAULT get_env</i>
get_env_def :: Text -> Text -> Sh Text

-- | get the full environment
get_env_all :: Sh [(String, String)]

-- | <i>Deprecated: use get_env_all</i>
get_environment :: Sh [(String, String)]

-- | add the filepath onto the PATH env variable
appendToPath :: FilePath -> Sh ()

-- | Change current working directory of Sh. This does *not* change the
--   working directory of the process we are running it. Instead, Sh keeps
--   track of its own working directory and builds absolute paths
--   internally instead of passing down relative paths.
cd :: FilePath -> Sh ()

-- | <a>cd</a>, execute a Sh action in the new directory and then pop back
--   to the original directory
chdir :: FilePath -> Sh a -> Sh a

-- | <a>chdir</a>, but first create the directory if it does not exit
chdir_p :: FilePath -> Sh a -> Sh a

-- | Obtain the current (Sh) working directory.
pwd :: Sh FilePath

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_n :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_err :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_n_err :: Text -> Sh ()

-- | a print lifted into <a>Sh</a>
inspect :: Show s => s -> Sh ()

-- | a print lifted into <a>Sh</a> using stderr
inspect_err :: Show s => s -> Sh ()

-- | same as <a>trace</a>, but use it combinator style
tag :: Sh a -> Text -> Sh a

-- | internally log what occurred. Log will be re-played on failure.
trace :: Text -> Sh ()
show_command :: FilePath -> [Text] -> Text

-- | List directory contents. Does *not* include "." and "..", but it does
--   include (other) hidden files.
ls :: FilePath -> Sh [FilePath]

-- | Get back [Text] instead of [FilePath]
lsT :: FilePath -> Sh [Text]

-- | Does a path point to an existing filesystem object?
test_e :: FilePath -> Sh Bool

-- | Does a path point to an existing file?
test_f :: FilePath -> Sh Bool

-- | Does a path point to an existing directory?
test_d :: FilePath -> Sh Bool

-- | Does a path point to a symlink?
test_s :: FilePath -> Sh Bool

-- | Test that a file is in the PATH and also executable
test_px :: FilePath -> Sh Bool

-- | Get a full path to an executable by looking at the <tt>PATH</tt>
--   environement variable. Windows normally looks in additional places
--   besides the <tt>PATH</tt>: this does not duplicate that behavior.
which :: FilePath -> Sh (Maybe FilePath)

-- | Make a relative path absolute by combining with the working directory.
--   An absolute path is returned as is. To create a relative path, use
--   <a>relPath</a>.
absPath :: FilePath -> Sh FilePath

-- | uses System.FilePath.CurrentOS, but can automatically convert a Text
(</>) :: (ToFilePath filepath1, ToFilePath filepath2) => filepath1 -> filepath2 -> FilePath

-- | uses System.FilePath.CurrentOS, but can automatically convert a Text
(<.>) :: ToFilePath filepath => filepath -> Text -> FilePath

-- | makes an absolute path. Like <a>canonicalize</a>, but on an exception
--   returns <a>absPath</a>
canonic :: FilePath -> Sh FilePath

-- | Obtain a (reasonably) canonic file path to a filesystem object. Based
--   on "canonicalizePath" in system-fileio.
canonicalize :: FilePath -> Sh FilePath

-- | Makes a relative path relative to the current Sh working directory. An
--   absolute path is returned as is. To create an absolute path, use
--   <a>absPath</a>
relPath :: FilePath -> Sh FilePath

-- | make the second path relative to the first Uses <a>stripPrefix</a>,
--   but will canonicalize the paths if necessary
relativeTo :: FilePath -> FilePath -> Sh FilePath

-- | deprecated

-- | <i>Deprecated: use absPath, canonic, or relPath instead</i>
path :: FilePath -> Sh FilePath

-- | flipped hasExtension for Text
hasExt :: Text -> FilePath -> Bool

-- | Move a file. The second path could be a directory, in which case the
--   original file is moved into that directory. wraps system-fileio
--   <a>rename</a>, which may not work across FS boundaries
mv :: FilePath -> FilePath -> Sh ()

-- | Remove a file. Does fail if the file does not exist (use <a>rm_f</a>
--   instead) or is not a file.
rm :: FilePath -> Sh ()

-- | Remove a file. Does not fail if the file does not exist. Does fail if
--   the file is not a file.
rm_f :: FilePath -> Sh ()

-- | A swiss army cannon for removing things. Actually this goes farther
--   than a normal rm -rf, as it will circumvent permission problems for
--   the files we own. Use carefully. Uses <a>removeTree</a>
rm_rf :: FilePath -> Sh ()

-- | Copy a file. The second path could be a directory, in which case the
--   original file name is used, in that directory.
cp :: FilePath -> FilePath -> Sh ()

-- | Copy a file, or a directory recursively. uses <a>cp</a>
cp_r :: FilePath -> FilePath -> Sh ()

-- | Create a new directory (fails if the directory exists).
mkdir :: FilePath -> Sh ()

-- | Create a new directory, including parents (succeeds if the directory
--   already exists).
mkdir_p :: FilePath -> Sh ()

-- | Create a new directory tree. You can describe a bunch of directories
--   as a tree and this function will create all subdirectories. An
--   example:
--   
--   <pre>
--   exec = mkTree $
--             "package" # [
--                  "src" # [
--                      "Data" # leaves ["Tree", "List", "Set", "Map"]
--                  ],
--                  "test" # leaves ["QuickCheck", "HUnit"],
--                  "dist/doc/html" # []
--              ]
--           where (#) = Node
--                 leaves = map (# [])
--   </pre>
mkdirTree :: Tree FilePath -> Sh ()
readfile :: FilePath -> Sh Text

-- | wraps ByteSting readFile
readBinary :: FilePath -> Sh ByteString

-- | Write a Text to a file.
writefile :: FilePath -> Text -> Sh ()

-- | Append a Text to a file.
appendfile :: FilePath -> Text -> Sh ()

-- | Update a file, creating (a blank file) if it does not exist.
touchfile :: FilePath -> Sh ()

-- | Create a temporary directory and pass it as a parameter to a Sh
--   computation. The directory is nuked afterwards.
withTmpDir :: (FilePath -> Sh a) -> Sh a

-- | exit 0 means no errors, all other codes are error conditions
exit :: Int -> Sh a

-- | echo a message and exit with status 1
errorExit :: Text -> Sh a

-- | for exiting with status &gt; 0 without printing debug information
quietExit :: Int -> Sh a

-- | fail that takes a Text
terror :: Text -> Sh a
bracket_sh :: Sh a -> (a -> Sh b) -> (a -> Sh c) -> Sh c

-- | A helper to catch any exception (same as <tt>... <a>catch</a> (e ::
--   SomeException) -&gt; ...</tt>).
catchany :: IO a -> (SomeException -> IO a) -> IO a

-- | Same as a normal <a>catch</a> but specialized for the Sh monad.
catch_sh :: Exception e => Sh a -> (e -> Sh a) -> Sh a

-- | Same as a normal <a>handle</a> but specialized for the Sh monad.
handle_sh :: Exception e => (e -> Sh a) -> Sh a -> Sh a

-- | Handle any exception in the Sh monad.
handleany_sh :: (SomeException -> Sh a) -> Sh a -> Sh a

-- | Same as a normal <a>finally</a> but specialized for the <a>Sh</a>
--   monad.
finally_sh :: Sh a -> Sh b -> Sh a

-- | You need to wrap exception handlers with this when using
--   <a>catches_sh</a>.
data ShellyHandler a
ShellyHandler :: (e -> Sh a) -> ShellyHandler a

-- | Same as a normal <a>catches</a>, but specialized for the <a>Sh</a>
--   monad.
catches_sh :: Sh a -> [ShellyHandler a] -> Sh a

-- | Catch any exception in the Sh monad.
catchany_sh :: Sh a -> (SomeException -> Sh a) -> Sh a

-- | Shelly's wrapper around exceptions thrown in its monad
data ReThrownException e
ReThrownException :: e -> String -> ReThrownException e

-- | silently uses the Right or Left value of
--   "Filesystem.Path.CurrentOS.toText"
toTextIgnore :: FilePath -> Text
toTextWarn :: FilePath -> Sh Text

-- | Convert human‐readable text into a <a>FilePath</a>.
--   
--   This function ignores the user’s locale, and assumes all file paths
--   are encoded in UTF8. If you need to create file paths with an unusual
--   or obscure encoding, encode them manually and then use <a>decode</a>.
--   
--   Since: 0.2
fromText :: Text -> FilePath

-- | A monadic-conditional version of the "when" guard.
whenM :: Monad m => m Bool -> m () -> m ()

-- | A monadic-conditional version of the <a>unless</a> guard.
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Run a Sh computation and collect timing information.
time :: Sh a -> Sh (Double, a)

-- | threadDelay wrapper that uses seconds
sleep :: Int -> Sh ()

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()

-- | The reverse of <a>when</a>.
unless :: Monad m => Bool -> m () -> m ()
data FilePath :: *

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b
get :: Sh State
put :: State -> Sh ()

-- | List directory recursively (like the POSIX utility "find"). listing is
--   relative if the path given is relative. If you want to filter out some
--   results or fold over them you can do that with the returned files. A
--   more efficient approach is to use one of the other find functions.
find :: FilePath -> Sh [FilePath]

-- | <a>find</a> that filters the found files as it finds. Files must
--   satisfy the given filter to be returned in the result.
findWhen :: (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | Fold an arbitrary folding function over files froma a <a>find</a>.
--   Like <a>findWhen</a> but use a more general fold rather than a filter.
findFold :: (a -> FilePath -> Sh a) -> a -> FilePath -> Sh a

-- | <a>find</a> that filters out directories as it finds Filtering out
--   directories can make a find much more efficient by avoiding entire
--   trees of files.
findDirFilter :: (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | similar <a>findWhen</a>, but also filter out directories
--   Alternatively, similar to <a>findDirFilter</a>, but also filter out
--   files Filtering out directories makes the find much more efficient
findDirFilterWhen :: (FilePath -> Sh Bool) -> (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | like <a>findDirFilterWhen</a> but use a folding function rather than a
--   filter The most general finder: you likely want a more specific one
findFoldDirFilter :: (a -> FilePath -> Sh a) -> a -> (FilePath -> Sh Bool) -> FilePath -> Sh a
instance [incoherent] Typeable RunFailed
instance [incoherent] Typeable QuietExit
instance [incoherent] Typeable ReThrownException
instance [incoherent] Show QuietExit
instance [incoherent] Exception e => Show (ReThrownException e)
instance [incoherent] Exception e => Exception (ReThrownException e)
instance [incoherent] Exception QuietExit
instance [incoherent] Exception RunFailed
instance [incoherent] Show RunFailed
instance [incoherent] ToFilePath String
instance [incoherent] ToFilePath Text
instance [incoherent] ToFilePath FilePath
instance [incoherent] (CmdArg arg, ShellCmd result) => ShellCmd ([arg] -> result)
instance [incoherent] (CmdArg arg, ShellCmd result) => ShellCmd (arg -> result)
instance [incoherent] ShellCmd (Sh ())
instance [incoherent] (s ~ Text, Show s) => ShellCmd (Sh s)
instance [incoherent] ShellCmd (Sh Text)
instance [incoherent] CmdArg String
instance [incoherent] CmdArg FilePath
instance [incoherent] CmdArg Text


-- | A module for shell-like programming in Haskell. Shelly's focus is
--   entirely on ease of use for those coming from shell scripting.
--   However, it also tries to use modern libraries and techniques to keep
--   things efficient.
--   
--   The functionality provided by this module is (unlike standard Haskell
--   filesystem functionality) thread-safe: each Sh maintains its own
--   environment and its own working directory.
--   
--   Recommended usage includes putting the following at the top of your
--   program, otherwise you will likely need either type annotations or
--   type conversions
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import qualified Data.Text as T
--   default (T.Text)
--   </pre>
module Shelly.Lifted
class Monad m => MonadSh m
liftSh :: MonadSh m => Sh a -> m a
data Sh a

-- | ShIO is Deprecated in favor of <a>Sh</a>, which is easier to type.

-- | <i>Deprecated: Use Sh instead of ShIO</i>
type ShIO a = Sh a

-- | Enter a Sh from (Monad)IO. The environment and working directories are
--   inherited from the current process-wide values. Any subsequent changes
--   in processwide working directory or environment are not reflected in
--   the running Sh.
shelly :: MonadIO m => Sh a -> m a

-- | Deprecated now, just use <a>shelly</a>, whose default has been
--   changed. Using this entry point does not create a <tt>.shelly</tt>
--   directory in the case of failure. Instead it logs directly into the
--   standard error stream (<tt>stderr</tt>).

-- | <i>Deprecated: Just use shelly. The default settings have changed</i>
shellyNoDir :: MonadIO m => Sh a -> m a

-- | Using this entry point creates a <tt>.shelly</tt> directory in the
--   case of failure where errors are recorded.
shellyFailDir :: MonadIO m => Sh a -> m a
sub :: MonadShControl m => m a -> m a
silently :: MonadShControl m => m a -> m a
verbosely :: MonadShControl m => m a -> m a
escaping :: MonadShControl m => Bool -> m a -> m a
print_stdout :: MonadShControl m => Bool -> m a -> m a
print_stderr :: MonadShControl m => Bool -> m a -> m a
print_commands :: MonadShControl m => Bool -> m a -> m a
tracing :: MonadShControl m => Bool -> m a -> m a
errExit :: MonadShControl m => Bool -> m a -> m a
log_stdout_with :: MonadShControl m => (Text -> IO ()) -> m a -> m a
log_stderr_with :: MonadShControl m => (Text -> IO ()) -> m a -> m a
run :: MonadSh m => FilePath -> [Text] -> m Text
run_ :: MonadSh m => FilePath -> [Text] -> m ()
runFoldLines :: MonadSh m => a -> FoldCallback a -> FilePath -> [Text] -> m a

-- | variadic argument version of <a>run</a>. Please see the documenation
--   for <a>run</a>.
--   
--   The syntax is more convenient, but more importantly it also allows the
--   use of a FilePath as a command argument. So an argument can be a Text
--   or a FilePath without manual conversions. a FilePath is automatically
--   converted to Text with <a>toTextIgnore</a>.
--   
--   Convenient usage of <a>cmd</a> requires the following:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import qualified Data.Text as T
--   default (T.Text)
--   </pre>
cmd :: ShellCmd result => FilePath -> result
type FoldCallback a = a -> Text -> a
(-|-) :: (MonadShControl m, MonadSh m) => m Text -> m b -> m b
lastStderr :: MonadSh m => m Text
setStdin :: MonadSh m => Text -> m ()
lastExitCode :: MonadSh m => m Int
command :: MonadSh m => FilePath -> [Text] -> [Text] -> m Text
command_ :: MonadSh m => FilePath -> [Text] -> [Text] -> m ()
command1 :: MonadSh m => FilePath -> [Text] -> Text -> [Text] -> m Text
command1_ :: MonadSh m => FilePath -> [Text] -> Text -> [Text] -> m ()
sshPairs :: MonadSh m => Text -> [(FilePath, [Text])] -> m Text
sshPairs_ :: MonadSh m => Text -> [(FilePath, [Text])] -> m ()

-- | For the variadic function <a>cmd</a>
--   
--   partially applied variadic functions require type signatures
class ShellCmd t
cmdAll :: ShellCmd t => FilePath -> [Text] -> t

-- | Argument converter for the variadic argument version of <a>run</a>
--   called <a>cmd</a>. Useful for a type signature of a function that uses
--   <a>cmd</a>
class CmdArg a
toTextArg :: CmdArg a => a -> Text
runHandle :: MonadShControl m => FilePath -> [Text] -> (Handle -> m a) -> m a
runHandles :: MonadShControl m => FilePath -> [Text] -> [StdHandle] -> (Handle -> Handle -> Handle -> m a) -> m a
transferLinesAndCombine :: MonadIO m => Handle -> (Text -> IO ()) -> m Text

-- | Transfer from one handle to another For example, send contents of a
--   process output to stdout. does not close the write handle.
--   
--   Also, fold over the contents being streamed line by line
transferFoldHandleLines :: a -> FoldCallback a -> Handle -> (Text -> IO ()) -> IO a
data StdHandle
InHandle :: StdStream -> StdHandle
OutHandle :: StdStream -> StdHandle
ErrorHandle :: StdStream -> StdHandle
data StdStream :: *

-- | Inherit Handle from parent
Inherit :: StdStream

-- | Use the supplied Handle
UseHandle :: Handle -> StdStream

-- | Create a new pipe. The returned <tt>Handle</tt> will use the default
--   encoding and newline translation mode (just like <tt>Handle</tt>s
--   created by <tt>openFile</tt>).
CreatePipe :: StdStream
setenv :: MonadSh m => Text -> Text -> m ()
get_env :: MonadSh m => Text -> m (Maybe Text)
get_env_text :: MonadSh m => Text -> m Text
get_env_all :: MonadSh m => m [(String, String)]
appendToPath :: MonadSh m => FilePath -> m ()
cd :: MonadSh m => FilePath -> m ()
chdir :: MonadShControl m => FilePath -> m a -> m a
chdir_p :: MonadShControl m => FilePath -> m a -> m a
pwd :: MonadSh m => m FilePath
echo :: MonadSh m => Text -> m ()
echo_n :: MonadSh m => Text -> m ()
echo_err :: MonadSh m => Text -> m ()
echo_n_err :: MonadSh m => Text -> m ()
inspect :: (Show s, MonadSh m) => s -> m ()
inspect_err :: (Show s, MonadSh m) => s -> m ()
tag :: (MonadShControl m, MonadSh m) => m a -> Text -> m a
trace :: MonadSh m => Text -> m ()
show_command :: FilePath -> [Text] -> Text
ls :: MonadSh m => FilePath -> m [FilePath]
lsT :: MonadSh m => FilePath -> m [Text]
test_e :: MonadSh m => FilePath -> m Bool
test_f :: MonadSh m => FilePath -> m Bool
test_d :: MonadSh m => FilePath -> m Bool
test_s :: MonadSh m => FilePath -> m Bool
test_px :: MonadSh m => FilePath -> m Bool
which :: MonadSh m => FilePath -> m (Maybe FilePath)
absPath :: MonadSh m => FilePath -> m FilePath

-- | uses System.FilePath.CurrentOS, but can automatically convert a Text
(</>) :: (ToFilePath filepath1, ToFilePath filepath2) => filepath1 -> filepath2 -> FilePath

-- | uses System.FilePath.CurrentOS, but can automatically convert a Text
(<.>) :: ToFilePath filepath => filepath -> Text -> FilePath
canonic :: MonadSh m => FilePath -> m FilePath

-- | Obtain a (reasonably) canonic file path to a filesystem object. Based
--   on "canonicalizePath" in system-fileio.
canonicalize :: MonadSh m => FilePath -> m FilePath
relPath :: MonadSh m => FilePath -> m FilePath
relativeTo :: MonadSh m => FilePath -> FilePath -> m FilePath

-- | flipped hasExtension for Text
hasExt :: Text -> FilePath -> Bool
mv :: MonadSh m => FilePath -> FilePath -> m ()
rm :: MonadSh m => FilePath -> m ()
rm_f :: MonadSh m => FilePath -> m ()
rm_rf :: MonadSh m => FilePath -> m ()
cp :: MonadSh m => FilePath -> FilePath -> m ()
cp_r :: MonadSh m => FilePath -> FilePath -> m ()
mkdir :: MonadSh m => FilePath -> m ()
mkdir_p :: MonadSh m => FilePath -> m ()
mkdirTree :: MonadSh m => Tree FilePath -> m ()
readfile :: MonadSh m => FilePath -> m Text
readBinary :: MonadSh m => FilePath -> m ByteString
writefile :: MonadSh m => FilePath -> Text -> m ()
appendfile :: MonadSh m => FilePath -> Text -> m ()
touchfile :: MonadSh m => FilePath -> m ()
withTmpDir :: MonadShControl m => (FilePath -> m a) -> m a
exit :: MonadSh m => Int -> m a
errorExit :: MonadSh m => Text -> m a
quietExit :: MonadSh m => Int -> m a
terror :: MonadSh m => Text -> m a

-- | <i>Deprecated: use Control.Exception.Lifted.bracket instead</i>
bracket_sh :: Sh a -> (a -> Sh b) -> (a -> Sh c) -> Sh c
catchany :: MonadBaseControl IO m => m a -> (SomeException -> m a) -> m a

-- | <i>Deprecated: use Control.Exception.Lifted.catch instead</i>
catch_sh :: Exception e => Sh a -> (e -> Sh a) -> Sh a

-- | <i>Deprecated: use Control.Exception.Lifted.handle instead</i>
handle_sh :: Exception e => (e -> Sh a) -> Sh a -> Sh a

-- | <i>Deprecated: use Control.Exception.Enclosed.handleAny instead</i>
handleany_sh :: (SomeException -> Sh a) -> Sh a -> Sh a

-- | <i>Deprecated: use Control.Exception.Lifted.finally instead</i>
finally_sh :: Sh a -> Sh b -> Sh a

-- | <i>Deprecated: use Control.Exception.Lifted.catches instead</i>
catches_sh :: Sh a -> [Handler Sh a] -> Sh a

-- | <i>Deprecated: use Control.Exception.Enclosed.catchAny instead</i>
catchany_sh :: Sh a -> (SomeException -> Sh a) -> Sh a

-- | silently uses the Right or Left value of
--   "Filesystem.Path.CurrentOS.toText"
toTextIgnore :: FilePath -> Text
toTextWarn :: MonadSh m => FilePath -> m Text

-- | Convert human‐readable text into a <a>FilePath</a>.
--   
--   This function ignores the user’s locale, and assumes all file paths
--   are encoded in UTF8. If you need to create file paths with an unusual
--   or obscure encoding, encode them manually and then use <a>decode</a>.
--   
--   Since: 0.2
fromText :: Text -> FilePath

-- | A monadic-conditional version of the "when" guard.
whenM :: Monad m => m Bool -> m () -> m ()

-- | A monadic-conditional version of the <a>unless</a> guard.
unlessM :: Monad m => m Bool -> m () -> m ()
time :: MonadShControl m => m a -> m (Double, a)
sleep :: MonadSh m => Int -> m ()

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()

-- | The reverse of <a>when</a>.
unless :: Monad m => Bool -> m () -> m ()
data FilePath :: *

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b
get :: MonadSh m => m State
put :: MonadSh m => State -> m ()

-- | List directory recursively (like the POSIX utility "find"). listing is
--   relative if the path given is relative. If you want to filter out some
--   results or fold over them you can do that with the returned files. A
--   more efficient approach is to use one of the other find functions.
find :: FilePath -> Sh [FilePath]

-- | <a>find</a> that filters the found files as it finds. Files must
--   satisfy the given filter to be returned in the result.
findWhen :: (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | Fold an arbitrary folding function over files froma a <a>find</a>.
--   Like <a>findWhen</a> but use a more general fold rather than a filter.
findFold :: (a -> FilePath -> Sh a) -> a -> FilePath -> Sh a

-- | <a>find</a> that filters out directories as it finds Filtering out
--   directories can make a find much more efficient by avoiding entire
--   trees of files.
findDirFilter :: (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | similar <a>findWhen</a>, but also filter out directories
--   Alternatively, similar to <a>findDirFilter</a>, but also filter out
--   files Filtering out directories makes the find much more efficient
findDirFilterWhen :: (FilePath -> Sh Bool) -> (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | like <a>findDirFilterWhen</a> but use a folding function rather than a
--   filter The most general finder: you likely want a more specific one
findFoldDirFilter :: (a -> FilePath -> Sh a) -> a -> (FilePath -> Sh Bool) -> FilePath -> Sh a
instance [incoherent] (MonadShControl m, Monoid w) => MonadShControl (RWST r w s m)
instance [incoherent] (MonadShControl m, Monoid w) => MonadShControl (RWST r w s m)
instance [incoherent] MonadShControl m => MonadShControl (ReaderT r m)
instance [incoherent] MonadShControl m => MonadShControl (StateT s m)
instance [incoherent] MonadShControl m => MonadShControl (StateT s m)
instance [incoherent] (MonadShControl m, Error e) => MonadShControl (ErrorT e m)
instance [incoherent] (MonadShControl m, Monoid w) => MonadShControl (WriterT w m)
instance [incoherent] (MonadShControl m, Monoid w) => MonadShControl (WriterT w m)
instance [incoherent] MonadShControl m => MonadShControl (IdentityT m)
instance [incoherent] MonadShControl m => MonadShControl (MaybeT m)
instance [incoherent] MonadShControl m => MonadShControl (ListT m)
instance [incoherent] MonadShControl Sh
instance [incoherent] MonadSh m => ShellCmd (m ())
instance [incoherent] (MonadSh m, s ~ Text, Show s) => ShellCmd (m s)
instance [incoherent] MonadSh m => ShellCmd (m Text)
instance [incoherent] (Monoid w, MonadSh m) => MonadSh (RWST r w s m)
instance [incoherent] (Monoid w, MonadSh m) => MonadSh (RWST r w s m)
instance [incoherent] (Monoid w, MonadSh m) => MonadSh (WriterT w m)
instance [incoherent] (Monoid w, MonadSh m) => MonadSh (WriterT w m)
instance [incoherent] MonadSh m => MonadSh (StateT s m)
instance [incoherent] MonadSh m => MonadSh (StateT s m)
instance [incoherent] MonadSh m => MonadSh (ReaderT r m)
instance [incoherent] (Error e, MonadSh m) => MonadSh (ErrorT e m)
instance [incoherent] MonadSh m => MonadSh (ContT r m)
instance [incoherent] MonadSh m => MonadSh (MaybeT m)
instance [incoherent] MonadSh m => MonadSh (ListT m)
instance [incoherent] MonadSh m => MonadSh (IdentityT m)
instance [incoherent] MonadSh Sh


-- | This module is a wrapper for the module <a>Shelly</a>. The only
--   difference is a main type <a>Sh</a>. In this module <a>Sh</a> contains
--   a list of results. Actual definition of the type <a>Sh</a> is:
--   
--   <pre>
--   import qualified Shelly as S
--   
--   newtype Sh a = Sh { unSh :: S.Sh [a] }
--   </pre>
--   
--   This definition can simplify some filesystem commands. A monad bind
--   operator becomes a pipe operator and we can write
--   
--   <pre>
--   findExt ext = findWhen (pure . hasExt ext)
--   
--   main :: IO ()
--   main = shs $ do
--       mkdir "new"
--       findExt "hs"  "." &gt;&gt;= flip cp "new"
--       findExt "cpp" "." &gt;&gt;= rm_f 
--       liftIO $ putStrLn "done"
--   </pre>
--   
--   Monad methods "return" and "&gt;&gt;=" behave like methods for
--   <tt>ListT Shelly.Sh</tt>, but "&gt;&gt;" forgets the number of the
--   empty effects. So the last line prints <tt>"done"</tt> only once.
--   
--   Documentation in this module mostly just reference documentation from
--   the main <a>Shelly</a> module.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import Data.Text as T
--   default (T.Text)
--   </pre>
module Shelly.Pipe

-- | This type is a simple wrapper for a type <tt>Shelly.Sh</tt>. <a>Sh</a>
--   contains a list of results.
data Sh a

-- | Performs <a>shelly</a> and then an empty action <tt>return ()</tt>.
shs :: MonadIO m => Sh () -> m ()

-- | see <a>shelly</a>
shelly :: MonadIO m => Sh a -> m [a]

-- | see <a>shellyFailDir</a>
shellyFailDir :: MonadIO m => Sh a -> m [a]

-- | Performs <a>shellyFailDir</a> and then an empty action <tt>return
--   ()</tt>.
shsFailDir :: MonadIO m => Sh () -> m ()

-- | see <a>sub</a>
sub :: Sh a -> Sh a
silently :: Sh a -> Sh a
verbosely :: Sh a -> Sh a

-- | see <a>escaping</a>
escaping :: Bool -> Sh a -> Sh a

-- | see <a>print_stdout</a>
print_stdout :: Bool -> Sh a -> Sh a

-- | see 'S.print_commands
print_commands :: Bool -> Sh a -> Sh a

-- | see <a>tracing</a>
tracing :: Bool -> Sh a -> Sh a

-- | see <a>errExit</a>
errExit :: Bool -> Sh a -> Sh a

-- | see <a>log_stdout_with</a>
log_stdout_with :: (Text -> IO ()) -> Sh a -> Sh a

-- | see <a>log_stderr_with</a>
log_stderr_with :: (Text -> IO ()) -> Sh a -> Sh a

-- | Pack list of results. It performs <tt>concat</tt> inside <a>Sh</a>.
roll :: Sh [a] -> Sh a

-- | Unpack list of results.
unroll :: Sh a -> Sh [a]

-- | Transform result as list. It can be useful for filtering.
liftSh :: ([a] -> [b]) -> Sh a -> Sh b
type FoldCallback a = a -> Text -> a

-- | see <a>run</a>
run :: FilePath -> [Text] -> Sh Text

-- | see <a>run_</a>
run_ :: FilePath -> [Text] -> Sh ()

-- | see <a>runFoldLines</a>
runFoldLines :: a -> FoldCallback a -> FilePath -> [Text] -> Sh a

-- | see <a>cmd</a>
cmd :: ShellCommand result => FilePath -> result

-- | see <a>-|-</a>
(-|-) :: Sh Text -> Sh b -> Sh b

-- | see <a>lastStderr</a>
lastStderr :: Sh Text

-- | see <a>setStdin</a>
setStdin :: Text -> Sh ()

-- | see <a>lastExitCode</a>
lastExitCode :: Sh Int

-- | see <a>command</a>
command :: FilePath -> [Text] -> [Text] -> Sh Text

-- | see <a>command_</a>
command_ :: FilePath -> [Text] -> [Text] -> Sh ()

-- | see <a>command1</a>
command1 :: FilePath -> [Text] -> Text -> [Text] -> Sh Text

-- | see <a>command1_</a>
command1_ :: FilePath -> [Text] -> Text -> [Text] -> Sh ()

-- | see <a>sshPairs</a>
sshPairs :: Text -> [(FilePath, [Text])] -> Sh Text

-- | see <a>sshPairs_</a>
sshPairs_ :: Text -> [(FilePath, [Text])] -> Sh ()

-- | see <a>setenv</a>
setenv :: Text -> Text -> Sh ()

-- | see <a>get_env</a>
get_env :: Text -> Sh (Maybe Text)

-- | see <a>get_env_text</a>
get_env_text :: Text -> Sh Text

-- | see <a>get_env_def</a>

-- | <i>Deprecated: use fromMaybe DEFAULT get_env</i>
get_env_def :: Text -> Text -> Sh Text

-- | see <a>appendToPath</a>
appendToPath :: FilePath -> Sh ()

-- | see <a>cd</a>
cd :: FilePath -> Sh ()

-- | see <a>chdir</a>
chdir :: FilePath -> Sh a -> Sh a

-- | see <a>pwd</a>
pwd :: Sh FilePath

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_n :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_err :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_n_err :: Text -> Sh ()

-- | see <a>inspect</a>
inspect :: Show s => s -> Sh ()

-- | see <a>inspect_err</a>
inspect_err :: Show s => s -> Sh ()

-- | see <a>tag</a>
tag :: Sh a -> Text -> Sh a

-- | see <a>trace</a>
trace :: Text -> Sh ()

-- | see <a>show_command</a>
show_command :: FilePath -> [Text] -> Text

-- | see <a>ls</a>
ls :: FilePath -> Sh FilePath

-- | see <a>lsT</a>
lsT :: FilePath -> Sh Text

-- | see <a>test_e</a>
test_e :: FilePath -> Sh Bool

-- | see <a>test_f</a>
test_f :: FilePath -> Sh Bool

-- | see <a>test_d</a>
test_d :: FilePath -> Sh Bool

-- | see <a>test_s</a>
test_s :: FilePath -> Sh Bool

-- | see 'S.which
which :: FilePath -> Sh (Maybe FilePath)

-- | see <a>absPath</a>
absPath :: FilePath -> Sh FilePath

-- | uses System.FilePath.CurrentOS, but can automatically convert a Text
(</>) :: (ToFilePath filepath1, ToFilePath filepath2) => filepath1 -> filepath2 -> FilePath

-- | uses System.FilePath.CurrentOS, but can automatically convert a Text
(<.>) :: ToFilePath filepath => filepath -> Text -> FilePath

-- | see <a>canonic</a>
canonic :: FilePath -> Sh FilePath

-- | see <a>canonicalize</a>
canonicalize :: FilePath -> Sh FilePath

-- | see <a>relPath</a>
relPath :: FilePath -> Sh FilePath

-- | see <a>relativeTo</a>
relativeTo :: FilePath -> FilePath -> Sh FilePath

-- | flipped hasExtension for Text
hasExt :: Text -> FilePath -> Bool

-- | see <a>mv</a>
mv :: FilePath -> FilePath -> Sh ()

-- | see <a>rm</a>
rm :: FilePath -> Sh ()

-- | see <a>rm_f</a>
rm_f :: FilePath -> Sh ()

-- | see <a>rm_rf</a>
rm_rf :: FilePath -> Sh ()

-- | see <a>cp</a>
cp :: FilePath -> FilePath -> Sh ()

-- | see <a>cp_r</a>
cp_r :: FilePath -> FilePath -> Sh ()

-- | see <a>mkdir</a>
mkdir :: FilePath -> Sh ()

-- | see <a>mkdir_p</a>
mkdir_p :: FilePath -> Sh ()

-- | see <a>mkdirTree</a>
mkdirTree :: Tree FilePath -> Sh ()

-- | see <a>readFile</a>
readfile :: FilePath -> Sh Text

-- | see <a>readBinary</a>
readBinary :: FilePath -> Sh ByteString

-- | see <a>writeFile</a>
writefile :: FilePath -> Text -> Sh ()

-- | see <a>appendFile</a>
appendfile :: FilePath -> Text -> Sh ()

-- | see <a>touchFile</a>
touchfile :: FilePath -> Sh ()

-- | see <a>withTmpDir</a>
withTmpDir :: (FilePath -> Sh a) -> Sh a

-- | see <a>exit</a>
exit :: Int -> Sh ()

-- | see <a>errorExit</a>
errorExit :: Text -> Sh ()

-- | see <a>quietExit</a>
quietExit :: Int -> Sh ()

-- | see <a>terror</a>
terror :: Text -> Sh a

-- | A helper to catch any exception (same as <tt>... <a>catch</a> (e ::
--   SomeException) -&gt; ...</tt>).
catchany :: IO a -> (SomeException -> IO a) -> IO a

-- | see <a>catch_sh</a>
catch_sh :: Exception e => Sh a -> (e -> Sh a) -> Sh a

-- | see <a>finally_sh</a>
finally_sh :: Sh a -> Sh b -> Sh a

-- | see <a>ShellyHandler</a>
data ShellyHandler a
ShellyHandler :: (e -> Sh a) -> ShellyHandler a

-- | see <a>catches_sh</a>
catches_sh :: Sh a -> [ShellyHandler a] -> Sh a

-- | see <a>catchany_sh</a>
catchany_sh :: Sh a -> (SomeException -> Sh a) -> Sh a

-- | silently uses the Right or Left value of
--   "Filesystem.Path.CurrentOS.toText"
toTextIgnore :: FilePath -> Text

-- | see <a>toTextWarn</a>
toTextWarn :: FilePath -> Sh Text

-- | Convert human‐readable text into a <a>FilePath</a>.
--   
--   This function ignores the user’s locale, and assumes all file paths
--   are encoded in UTF8. If you need to create file paths with an unusual
--   or obscure encoding, encode them manually and then use <a>decode</a>.
--   
--   Since: 0.2
fromText :: Text -> FilePath

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | A monadic-conditional version of the "when" guard.
whenM :: Monad m => m Bool -> m () -> m ()

-- | A monadic-conditional version of the <a>unless</a> guard.
unlessM :: Monad m => m Bool -> m () -> m ()

-- | see <a>time</a>
time :: Sh a -> Sh (Double, a)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()

-- | The reverse of <a>when</a>.
unless :: Monad m => Bool -> m () -> m ()
data FilePath :: *
get :: Sh State
put :: State -> Sh ()

-- | see <a>find</a>
find :: FilePath -> Sh FilePath

-- | see <a>findWhen</a>
findWhen :: (FilePath -> Sh Bool) -> FilePath -> Sh FilePath

-- | see <a>findFold</a>
findFold :: (a -> FilePath -> Sh a) -> a -> FilePath -> Sh a

-- | see <a>findDirFilter</a>
findDirFilter :: (FilePath -> Sh Bool) -> FilePath -> Sh FilePath

-- | see <a>findDirFilterWhen</a>
findDirFilterWhen :: (FilePath -> Sh Bool) -> (FilePath -> Sh Bool) -> FilePath -> Sh FilePath

-- | see <a>findFoldDirFilterWhen</a>
findFoldDirFilter :: (a -> FilePath -> Sh a) -> a -> (FilePath -> Sh Bool) -> FilePath -> Sh a
instance (ShellArg arg, ShellCommand result) => ShellCommand (arg -> result)
instance ShellCommand (Sh ())
instance (s ~ Text, Show s) => ShellCommand (Sh s)
instance ShellCommand (Sh Text)
instance ShellArg FilePath
instance ShellArg Text
instance MonadIO Sh
instance MonadPlus Sh
instance Alternative Sh
instance Applicative Sh
instance Monad Sh
instance Functor Sh
