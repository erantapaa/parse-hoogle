-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compositional lazy dataflow networks for exact real number computation
--   
--   AERN-Net provides datatypes and abstractions for defining and
--   executing networks of communicating processes. These networks have a
--   fixed topology, which can be infinite via recursion. The communication
--   on each channel is driven by some query-response protocol. Basic
--   protocols for communicating approximations of real numbers and
--   functions are provided together with protocol combinators eg for
--   communicating value pairs or lists and communicating with additional
--   query parameters or with optimised repetitions.
--   
--   An class-based abstraction is provided to make it possible to execute
--   networks on various distributed backends without modification. At the
--   moment there is only one backend, which is not distributed. It is
--   envisaged that truly distributed backends will be added soon, eg based
--   on plain TCP, MPI or REST/SOAP Web services.
--   
--   A mathematical foundation of these networks is described in the draft
--   paper
--   <a>http://www-users.aston.ac.uk/~konecnym/papers/ernets08-draft.html</a>.
--   
--   Simple examples of usage can be found in modules <tt>DemoMax</tt> and
--   <tt>DemoSqrt</tt> in folder <tt>examples</tt>.
@package AERN-Net
@version 0.2.1.1


-- | This module defines the concept of a protocol for channel
--   communication.
--   
--   The protocol concept is formalised using the 2-parameter class
--   <a>QAProtocol</a> and the existential types <a>ChannelType</a>,
--   <a>AnswerAnyProt</a>, <a>QueryAnyProt</a> indexed by instances of
--   <a>QAProtocol</a>.
module Control.ERNet.Foundations.Protocol

-- | any danger of over 2^29 queries?
type QueryId = Int

-- | A class grouping types of queries and answers.
--   
--   Each instance has to define dynamic type checking of answers agains
--   queries.
class (Ord q, HTML q, HTML a, Show q, Show a, Typeable q, Typeable a) => QAProtocol q a | a -> q, q -> a
qaMatch :: (QAProtocol q a) => q -> a -> Maybe String
qaaSetMinGran :: (QAProtocol q a) => Granularity -> a -> a

-- | This type is used to identify protocols eg for the creation of new
--   channels or for dynamic type checking. It consists of an example query
--   and an example answer.
data ChannelType
ChannelType :: q -> a -> ChannelType

-- | Union of queries from all protocols.
data QueryAnyProt
QueryAnyProt :: q -> QueryAnyProt

-- | Union of answers from all protocols.
data AnswerAnyProt
AnswerAnyProt :: a -> AnswerAnyProt
data QAUnitQ
QAUnitQ :: QAUnitQ
data QAUnitA
QAUnitA :: QAUnitA
data QABoolQ
QABoolQ :: QABoolQ
data QANatQ
QANatQ :: QANatQ
data QANatA
QANatA :: Integer -> QANatA
instance Typeable QANatA
instance Typeable QANatQ
instance Typeable QABoolQ
instance Typeable QAUnitA
instance Typeable QAUnitQ
instance Eq QANatA
instance Ord QANatA
instance Show QANatA
instance Eq QANatQ
instance Ord QANatQ
instance Show QANatQ
instance Eq QABoolQ
instance Ord QABoolQ
instance Show QABoolQ
instance Eq QAUnitA
instance Ord QAUnitA
instance Show QAUnitA
instance Eq QAUnitQ
instance Ord QAUnitQ
instance Show QAUnitQ
instance HTML QANatA
instance HTML QANatQ
instance QAProtocol QANatQ QANatA
instance HTML QABoolQ
instance HTML Bool
instance QAProtocol QABoolQ Bool
instance HTML QAUnitA
instance HTML QAUnitQ
instance QAProtocol QAUnitQ QAUnitA
instance HTML AnswerAnyProt
instance Show AnswerAnyProt
instance HTML QueryAnyProt
instance Show QueryAnyProt
instance Show ChannelType
instance Eq ChannelType


-- | Communication events with various data useful for logging and
--   debugging.
module Control.ERNet.Foundations.Event

-- | Data to be logged with every query and answer event.
data ERNetEvent
ERNetEvQryMade :: UTCTime -> QueryId -> String -> QueryId -> String -> q -> ERNetEvent
ernetevTime :: ERNetEvent -> UTCTime
ernetevQryId :: ERNetEvent -> QueryId
ernetevFromId :: ERNetEvent -> String
ernetevFromQryId :: ERNetEvent -> QueryId
ernetevToId :: ERNetEvent -> String
ernetevQry :: ERNetEvent -> q
ERNetEvQryReceived :: UTCTime -> QueryId -> String -> q -> ERNetEvent
ernetevTime :: ERNetEvent -> UTCTime
ernetevQryId :: ERNetEvent -> QueryId
ernetevToId :: ERNetEvent -> String
ernetevQry :: ERNetEvent -> q
ERNetEvAnsMade :: UTCTime -> QueryId -> String -> a -> ERNetEvent
ernetevTime :: ERNetEvent -> UTCTime
ernetevQryId :: ERNetEvent -> QueryId
ernetevToId :: ERNetEvent -> String
ernetevAns :: ERNetEvent -> a
ERNetEvAnsReceived :: UTCTime -> QueryId -> String -> QueryId -> String -> a -> q -> ERNetEvent
ernetevTime :: ERNetEvent -> UTCTime
ernetevQryId :: ERNetEvent -> QueryId
ernetevFromId :: ERNetEvent -> String
ernetevFromQryId :: ERNetEvent -> QueryId
ernetevToId :: ERNetEvent -> String
ernetevAns :: ERNetEvent -> a
ernetevQry :: ERNetEvent -> q
instance Show ERNetEvent


-- | Abstraction of an event logger in the IO monad.
--   
--   To be imported qualified, usually with the prefix LG.
module Control.ERNet.Foundations.Event.Logger
class Logger lg
new :: (Logger lg) => IO lg
addEvent :: (Logger lg) => lg -> ERNetEvent -> IO ()
emptyAndDo :: (Logger lg) => lg -> (ERNetEvent -> IO a) -> IO ()
emptyAndGetEvents :: (Logger lg) => lg -> IO ([ERNetEvent])


-- | Abstraction of data flow channels and its sockets with associated
--   query-answer protocol for gradual data communication.
--   
--   To be imported qualified, usually with the prefix CH.
module Control.ERNet.Foundations.Channel

-- | A channel type, as it is presented to the processes, consists of an
--   input socket and an output socket types.
--   
--   Each socket type has a unique protocol associated with it. Whenever
--   the protocol can be determined at compile time, we use the sIn and
--   sOut types, otherwise we use the sInAnyProt and sOutAnyProt types.
--   Elements of sInAnyProt and sOutAnyProt can be dynamically cast to
--   elements of sIn and sOut once the protocol can be deduced by the
--   Haskell type checker.
class Channel sIn sOut sInAnyProt sOutAnyProt | sIn -> sOut sInAnyProt sOutAnyProt, sOut -> sIn sInAnyProt sOutAnyProt, sInAnyProt -> sOutAnyProt sIn sOut, sOutAnyProt -> sInAnyProt sIn sOut
castIn :: (Channel sIn sOut sInAnyProt sOutAnyProt, QAProtocol q a) => String -> sInAnyProt -> sIn q a
castOut :: (Channel sIn sOut sInAnyProt sOutAnyProt, QAProtocol q a) => String -> sOutAnyProt -> sOut q a
castInIO :: (Channel sIn sOut sInAnyProt sOutAnyProt, QAProtocol q a) => String -> sInAnyProt -> IO (sIn q a)
castOutIO :: (Channel sIn sOut sInAnyProt sOutAnyProt, QAProtocol q a) => String -> sOutAnyProt -> IO (sOut q a)
makeQuery :: (Channel sIn sOut sInAnyProt sOutAnyProt, QAProtocol q a, Show q, Show a) => sOut q2 a2 -> QueryId -> sIn q a -> q -> IO QueryId
makeQueryAnyProt :: (Channel sIn sOut sInAnyProt sOutAnyProt) => String -> sOutAnyProt -> QueryId -> sInAnyProt -> QueryAnyProt -> IO QueryId
waitForQuery :: (Channel sIn sOut sInAnyProt sOutAnyProt, QAProtocol q a, Show q, Show a) => sOut q a -> IO (QueryId, q)
waitForQueryMulti :: (Channel sIn sOut sInAnyProt sOutAnyProt) => [sOutAnyProt] -> IO (Int, (QueryId, QueryAnyProt))
answerQuery :: (Channel sIn sOut sInAnyProt sOutAnyProt, QAProtocol q a) => Bool -> (sOut q a) -> (QueryId, a) -> IO ()
answerQueryAnyProt :: (Channel sIn sOut sInAnyProt sOutAnyProt) => String -> Bool -> sOutAnyProt -> (QueryId, AnswerAnyProt) -> IO ()
waitForAnswer :: (Channel sIn sOut sInAnyProt sOutAnyProt, QAProtocol q a, Show q, Show a) => sOut q2 a2 -> QueryId -> sIn q a -> QueryId -> IO a
waitForAnswerMulti :: (Channel sIn sOut sInAnyProt sOutAnyProt) => sOutAnyProt -> QueryId -> [(sInAnyProt, QueryId)] -> IO (Int, AnswerAnyProt)
class (Channel sIn sOut sInAnyProt sOutAnyProt, Logger lg) => ChannelForScheduler lg sIn sOut sInAnyProt sOutAnyProt | sIn -> lg
new :: (ChannelForScheduler lg sIn sOut sInAnyProt sOutAnyProt) => lg -> String -> Int -> ChannelType -> IO (sInAnyProt, sOutAnyProt)


-- | Kahn process networks with channels adapted for arbitrary precision
--   real higher-order data communication. Executed using a number of
--   parallel threads. Each process started in a dedicated thread and each
--   process typically starts further internal threads. Each channel is a
--   transactional variable (TVar) known to both end processes and allows
--   them to communicate according to its instance of the <a>QAProtocol</a>
--   class.
module Control.ERNet.Foundations.Process

-- | All data that define a process, including its behaviour. Each
--   executing process is instantiated from one of these descriptions.
data ERProcess sInAnyProt sOutAnyProt
ERProcess :: ERProcessName -> ERProcessDeploy sInAnyProt sOutAnyProt -> [ChannelType] -> [ChannelType] -> ERProcess sInAnyProt sOutAnyProt

-- | undeployed process name
erprocName :: ERProcess sInAnyProt sOutAnyProt -> ERProcessName

-- | On deployment, a process either expands itself using the provided
--   callback function and does not use the sockets at all
--   
--   OR it uses the sockets and never calls the expansion callback.
erprocDeploy :: ERProcess sInAnyProt sOutAnyProt -> ERProcessDeploy sInAnyProt sOutAnyProt
erprocInputTypes :: ERProcess sInAnyProt sOutAnyProt -> [ChannelType]
erprocOutputTypes :: ERProcess sInAnyProt sOutAnyProt -> [ChannelType]
type ERProcessName = String
type ERProcessDeploy sInAnyProt sOutAnyProt = ERProcessName -> [sInAnyProt] -> [sOutAnyProt] -> (ERProcessExpandCallback sInAnyProt sOutAnyProt) -> IO ()
type ERProcessExpandCallback sInAnyProt sOutAnyProt = String -> [(ChannelType, Int)] -> [(ChannelType, Int)] -> [(ERProcess sInAnyProt sOutAnyProt, ([Int], [Int]))] -> IO ()

-- | Explicit representation of a process' action, able to distinguish
--   between answering and making a query or pausing one internal thread
--   until the internal state (TV) has met some condition.
--   
--   This is useful for producing highly customisable <tt>templates</tt>
--   for processes as Haskell functions whose parameters are functions that
--   determine what the process should do as a response to some external or
--   internal events. See for example
--   <tt>Control.ERNet.Blocks.Basic.passThroughStatefulProcess</tt>.
data ERProcessAction s q a
ERProcessActionRetryWhen :: (s -> Bool) -> ERProcessAction s q a
ERProcessActionQuery :: q -> ERProcessAction s q a
ERProcessActionAnswer :: Bool -> a -> ERProcessAction s q a
subnetProcess :: ERProcessName -> [(ChannelType, Int)] -> [(ChannelType, Int)] -> [(ERProcess sInAnyProt sOutAnyProt, ([Int], [Int]))] -> ERProcess sInAnyProt sOutAnyProt


-- | Abstraction of a distributed manager for networked ER processes. Its
--   functions comprise:
--   
--   <ul>
--   <li>initial process deployment</li>
--   <li>expansion of a process into a sub-network</li>
--   </ul>
--   
--   To be imported qualified, usually with the prefix MAN.
module Control.ERNet.Foundations.Manager
class (ChannelForScheduler lg sIn sOut sInAnyProt sOutAnyProt) => Manager man lg sIn sOut sInAnyProt sOutAnyProt | man -> lg sIn sOut sInAnyProt sOutAnyProt
new :: (Manager man lg sIn sOut sInAnyProt sOutAnyProt) => ManagerName -> IO (man, ManagerID)
connectNeighbour :: (Manager man lg sIn sOut sInAnyProt sOutAnyProt) => man -> ManagerID -> IO Bool
runProcess :: (Manager man lg sIn sOut sInAnyProt sOutAnyProt) => man -> ERProcess sInAnyProt sOutAnyProt -> IO lg

-- | A name given to a ditributed node by a programmer.
type ManagerName = String

-- | A globally unique name as a URL.
--   
--   eg ernet:<i></i>localhost:4176/miks-ivp-solver-master
--   ernet-local:/ivp-solver-master ernet-mpi:/ivp-solver-master
--   
--   The port 4176 was unassigned when checked on
--   http:<i></i>www.iana.org<i>assignments</i>port-numbers on 2nd November
--   2008.
type ManagerID = String

-- | Run a process together with some queries on one of its output sockets.
runDialogue :: (Manager man lg sIn sOut sInAnyProt sOutAnyProt, QAProtocol q a) => man -> ERProcess sInAnyProt sOutAnyProt -> Int -> ChannelType -> ((q -> IO a) -> IO ()) -> Bool -> IO lg


-- | This module defines some basic concrete protocols, namely protocols
--   for transferring a unit and a boolean.
--   
--   Some protocol combinators are provided to form new protocols from old
--   protocols. Eg one can form a product of two protocols to get a
--   protocol for query-answer dialogues about a pair of values. Similarly,
--   one can construct protocols for a sum of two types, a maybe type and a
--   list type.
--   
--   Any protocol can be also extended to include effort indices in queries
--   or to allow incremental computation with non-blocking queries on
--   progress, multiple dialogue thread tracking and the communication of a
--   failure.
--   
--   TODO: add protocols for
--   
--   <ul>
--   <li>game-theoretic HO functions</li>
--   </ul>
module Control.ERNet.Foundations.Protocol.StandardCombinators
data QAMaybeQ q
QAMaybeQ :: q -> QAMaybeQ q
QAMaybeQIsNothing :: q -> QAMaybeQ q
data QAMaybeA a
QAMaybeA :: (Maybe a) -> QAMaybeA a
QAMaybeAIsNothing :: Bool -> QAMaybeA a
chTMaybe :: ChannelType -> ChannelType
makeAnswerMaybe :: (QAProtocol q a) => (q -> Maybe a) -> (QAMaybeQ q) -> (QAMaybeA a)
data QAIxQ q
QAIxQ :: EffortIndex -> q -> QAIxQ q
data QAIxA a
QAIxA :: a -> QAIxA a
chTIx :: ChannelType -> ChannelType
data QAChangesQ q
QAChangesQIfNew :: QueryId -> q -> QAChangesQ q
QAChangesQWhenNew :: QueryId -> q -> QAChangesQ q
QAChangesQ :: q -> QAChangesQ q
data QAChangesA a
QAChangesANew :: a -> QAChangesA a
QAChangesASame :: QAChangesA a
QAChangesAGivenUp :: QAChangesA a
chTChanges :: ChannelType -> ChannelType
firstJust :: [Maybe err] -> Maybe err
data QAListQ q
QAListQAllHomog :: q -> QAListQ q
QAListQSingle :: Int -> q -> QAListQ q
QAListQPrefix :: [q] -> QAListQ q
QAListQLength :: QAListQ q
data QAListA a
QAListA :: [a] -> QAListA a
QAListASingle :: a -> QAListA a
QAListALength :: Int -> QAListA a
chTList :: ChannelType -> ChannelType
makeAnswerList :: (QAProtocol q a) => ([a]) -> (QAListQ q) -> (QAListA a)
data QAProdQ q1 q2
QAProdQFirst :: q1 -> QAProdQ q1 q2
QAProdQSecond :: q2 -> QAProdQ q1 q2
QAProdQBoth :: q1 -> q2 -> QAProdQ q1 q2
data QAProdA a1 a2
QAProdAFirst :: a1 -> QAProdA a1 a2
QAProdASecond :: a2 -> QAProdA a1 a2
QAProdABoth :: a1 -> a2 -> QAProdA a1 a2
chTProd :: ChannelType -> ChannelType -> ChannelType
makeAnswerProd :: (QAProtocol q1 a1, QAProtocol q2 a2) => (q1 -> a1) -> (q2 -> a2) -> (QAProdQ q1 q2) -> (QAProdA a1 a2)
instance Typeable2 QAProdA
instance Typeable2 QAProdQ
instance Typeable1 QAListA
instance Typeable1 QAListQ
instance Typeable1 QAChangesA
instance Typeable1 QAChangesQ
instance Typeable1 QAIxA
instance Typeable1 QAIxQ
instance Typeable1 QAMaybeA
instance Typeable1 QAMaybeQ
instance (Eq a1, Eq a2) => Eq (QAProdA a1 a2)
instance (Ord a1, Ord a2) => Ord (QAProdA a1 a2)
instance (Show a1, Show a2) => Show (QAProdA a1 a2)
instance (Eq q1, Eq q2) => Eq (QAProdQ q1 q2)
instance (Ord q1, Ord q2) => Ord (QAProdQ q1 q2)
instance (Show q1, Show q2) => Show (QAProdQ q1 q2)
instance (Eq a) => Eq (QAListA a)
instance (Ord a) => Ord (QAListA a)
instance (Show a) => Show (QAListA a)
instance (Eq q) => Eq (QAListQ q)
instance (Ord q) => Ord (QAListQ q)
instance (Show q) => Show (QAListQ q)
instance (Eq a) => Eq (QAChangesA a)
instance (Ord a) => Ord (QAChangesA a)
instance (Show a) => Show (QAChangesA a)
instance (Eq q) => Eq (QAChangesQ q)
instance (Ord q) => Ord (QAChangesQ q)
instance (Show q) => Show (QAChangesQ q)
instance (Eq a) => Eq (QAIxA a)
instance (Ord a) => Ord (QAIxA a)
instance (Show a) => Show (QAIxA a)
instance (Eq q) => Eq (QAIxQ q)
instance (Ord q) => Ord (QAIxQ q)
instance (Show q) => Show (QAIxQ q)
instance (Eq a) => Eq (QAMaybeA a)
instance (Ord a) => Ord (QAMaybeA a)
instance (Show a) => Show (QAMaybeA a)
instance (Eq q) => Eq (QAMaybeQ q)
instance (Ord q) => Ord (QAMaybeQ q)
instance (Show q) => Show (QAMaybeQ q)
instance (HTML a1, HTML a2) => HTML (QAProdA a1 a2)
instance (HTML q1, HTML q2) => HTML (QAProdQ q1 q2)
instance (QAProtocol q1 a1, QAProtocol q2 a2, Show q1, Show a1, Show q2, Show a2) => QAProtocol (QAProdQ q1 q2) (QAProdA a1 a2)
instance (HTML a) => HTML (QAListA a)
instance (HTML q) => HTML (QAListQ q)
instance (QAProtocol q a, Show q, Show a) => QAProtocol (QAListQ q) (QAListA a)
instance (HTML a) => HTML (QAChangesA a)
instance (HTML q) => HTML (QAChangesQ q)
instance (QAProtocol q a, Show q, Show a) => QAProtocol (QAChangesQ q) (QAChangesA a)
instance (HTML a) => HTML (QAIxA a)
instance (HTML q) => HTML (QAIxQ q)
instance (QAProtocol q a) => QAProtocol (QAIxQ q) (QAIxA a)
instance (HTML a) => HTML (QAMaybeA a)
instance (HTML q) => HTML (QAMaybeQ q)
instance (QAProtocol q a, Show q, Show a) => QAProtocol (QAMaybeQ q) (QAMaybeA a)


-- | Definitions of a few universaly useful simple network processes and
--   process templates.
module Control.ERNet.Blocks.Basic

-- | A generic stateless process with no inputs.
constantProcess :: (QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> (q -> a) -> ChannelType -> ERProcess sInAnyProt sOutAnyProt

-- | A generic process with no inputs that answers using a ChTChanges
--   protocol.
constantChangedProcess :: (QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> (q -> a) -> ChannelType -> ERProcess sInAnyProt sOutAnyProt

-- | A generic stateful process with no inputs.
constantStatefulProcess :: (QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> (s -> (QueryId, q) -> ((Bool, a), Maybe s)) -> s -> ChannelType -> ERProcess sInAnyProt sOutAnyProt

-- | A simple process that passes on a translated version of each query to
--   another process and translates the answers before passing them back.
passThroughProcess :: (QAProtocol q1 a1, QAProtocol q2 a2, Channel sIn sOut sInAnyProt sOutAnyProt) => Bool -> ERProcessName -> (q1 -> q2) -> (q1 -> a2 -> a1) -> ChannelType -> ChannelType -> ERProcess sInAnyProt sOutAnyProt

-- | A simple process that either responds with no further queries or
--   passes on a translated version of the query to another process, and
--   then passing back a translated version of the answer received.
maybePassThroughProcess :: (QAProtocol q1 a1, QAProtocol q2 a2, Channel sIn sOut sInAnyProt sOutAnyProt) => Bool -> ERProcessName -> (q1 -> Bool) -> (q1 -> a1) -> (q1 -> q2) -> (q1 -> a2 -> a1) -> ChannelType -> ChannelType -> ERProcess sInAnyProt sOutAnyProt

-- | A process with one input and one output socket. Upon receiving a query
--   or an answer related to a previously received query, the process uses
--   the provided functions to decide whether to answer the query, make a
--   new query or wait until the state meets a certain condition. When the
--   condition is met, the event (query or answer) in question is processed
--   again using the same function.
--   
--   Several simpler processes are defined as specialisations of this one.
passThroughStatefulProcess :: (QAProtocol q1 a1, QAProtocol q2 a2, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> (s -> (QueryId, q1) -> (ERProcessAction s q2 a1, Maybe s)) -> (s -> (QueryId, q1) -> (q2, a2) -> (ERProcessAction s q2 a1, Maybe s)) -> s -> ChannelType -> ChannelType -> ERProcess sInAnyProt sOutAnyProt

-- | A process that passes on a translated version of each query to one or
--   both of another 2 channels. When the other channel(s) answer, it
--   analyses the answer(s) and decides whether to send other queries or
--   answer its original query.
passThroughBinaryStatefulProcess :: (QAProtocol q1 a1, QAProtocol q2 a2, QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> (s -> (QueryId, q) -> (ERProcessAction s (Maybe q1, Maybe q2) a, Maybe s)) -> (s -> (QueryId, q) -> (Maybe a1, Maybe a2) -> (ERProcessAction s (Maybe q1, Maybe q2) a, Maybe s)) -> s -> (ChannelType, ChannelType) -> ChannelType -> ERProcess sInAnyProt sOutAnyProt

-- | A simple process that passes on a translated version of each query to
--   another process and translates the answers before passing them back.
passThroughBinaryProcess :: (QAProtocol q1 a1, QAProtocol q2 a2, QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => Bool -> ERProcessName -> (q -> (q1, q2)) -> (q -> (a1, a2) -> a) -> (ChannelType, ChannelType) -> ChannelType -> ERProcess sInAnyProt sOutAnyProt

-- | A process passing on information without modification, except for
--   improving the convergence rate in successive queries.
--   
--   Each query may refer to a previous query. When it does, the query will
--   not be answered until either:
--   
--   <ul>
--   <li>the answer has improved sufficiently since last time one was
--   given</li>
--   <li>the number of queries made in response to this query has reached
--   the given limit</li>
--   </ul>
--   
--   Currently supports only single-threaded querying.
rateProcess :: (QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> (a -> a -> Bool) -> Int -> ChannelType -> ERProcess sInAnyProt sOutAnyProt

-- | A trivial passthrough process that only:
--   
--   <ul>
--   <li>reduces prec by 1 in all queries</li>
--   <li>ensures that the granularity of all answers is raised to prec</li>
--   </ul>
precProcess :: (QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => Bool -> ERProcessName -> ChannelType -> a -> ERProcess sInAnyProt sOutAnyProt


-- | A collection of processes whose main purpose is to synchronise other
--   processes and have little semantical value.
module Control.ERNet.Blocks.Control.Basic

-- | This process joins information from two channels (<a>step</a>,
--   <a>val</a>) in such a way that it acts as a splitter of
--   responsibilities for its multi-threaded failure-enabled result channel
--   as follows:
--   
--   <ul>
--   <li>The <a>step</a> channel provides the timing and effort information
--   for responses.</li>
--   <li>The <a>val</a> channel provides values without significant
--   blocking.</li>
--   </ul>
--   
--   While the process is waiting for a response from the step channel, any
--   queries are put on hold until the response comes.
--   
--   <ul>
--   <li>If the step channel responds with indication of failure, then all
--   pending queries are answered as failed.</li>
--   <li>If the step channel responds with ok, then all the pending queries
--   are forwarded to the value channel and answered asap. No new queries
--   are accepted during such forwarding stage.</li>
--   </ul>
joinStepValProcess :: (QAProtocol q a, Show q, Show a, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> ChannelType -> a -> ERProcess sInAnyProt sOutAnyProt

-- | This process provides multiple copies of one single-threaded channel.
--   
--   merges splits a channel into two channels - primary channel and
--   secondary channel. The primary channel is a clean forward of the
--   original channel. The secondary channel can use a slightly different
--   protocol than the primary channel.
--   
--   Any query on the secondary channel will be blocked until a matching
--   query is received and processed on the primary channel. (The user must
--   supply a function that decides whether or not the queries are
--   matching.)
--   
--   Whenever a query is being answered on the primary channel, all queries
--   pending on the secondary channel that are matching this one will be
--   replied at the same time using the an answer derived from the answer
--   on the primary channel.
splitSyncProcess :: (QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> ChannelType -> Int -> a -> ERProcess sInAnyProt sOutAnyProt

-- | This process provides two channels (primary, secondary) split off from
--   one source channel. The primary channel is a clean forward of the
--   source channel. The secondary channel can use a slightly different
--   protocol than the primary channel.
--   
--   Any query on the secondary channel will be blocked until a matching
--   query is received and processed on the primary channel. (The user must
--   supply a function that decides whether or not the queries are
--   matching.)
--   
--   Whenever a query is being answered on the primary channel, all queries
--   pending on the secondary channel that are matching this one will be
--   replied at the same time using the an answer derived from the answer
--   on the primary channel.
biasedSplitSyncProcess :: (QAProtocol q1 a1, QAProtocol q2 a2, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> ChannelType -> ChannelType -> (q2 -> q1 -> Bool) -> (q2 -> a1 -> a2) -> ERProcess sInAnyProt sOutAnyProt

-- | This process acts as a <a>switch</a> for a group of channels,
--   forwarding information from one of two groups of source channels. The
--   special <a>switch</a> channel indicates whether to use one or the
--   other.
switchMultiProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt) => Bool -> ERProcessName -> [ChannelType] -> ERProcess sInAnyProt sOutAnyProt

-- | This process acts as a simple pass-through + it decreases the effort
--   index of each query except for a query with effort index zero it asks
--   a special value provider. It can cope with several queries in
--   parallel.
improverIxSimpleProcess :: (QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> ChannelType -> a -> ERProcess sInAnyProt sOutAnyProt

-- | This process acts as a simple pass-through + it remembers its last
--   answer and provides it on another channel. It initialises its memory
--   from a special value provider.
improverNoIxSimpleProcess :: (QAProtocol q a, Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> ChannelType -> a -> ERProcess sInAnyProt sOutAnyProt


-- | Basic protocols for transferring approximations of real functions.
module Control.ERNet.Blocks.RnToRm.Protocols
data QAFn1Q box
QAFn1QAll :: QAFn1Q box
QAFn1QDom :: box -> QAFn1Q box
QAFn1QPt :: box -> QAFn1Q box
data QAFn1A ranra fa
QAFn1A :: fa -> QAFn1A ranra fa
QAFn1APt :: [ranra] -> QAFn1A ranra fa
chTFn1 :: (ERFnApprox box varid domra ranra fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable box, Show box, Typeable domra, Typeable ranra, Typeable fa, HTML fa) => fa -> ChannelType

-- | Construct an answer about a function, assuming they will not ask about
--   a subdomain.
makeAnswerFn1NoIx :: (ERFnApprox box varid domra ranra fa) => fa -> (QAFn1Q box) -> (QAFn1A ranra fa)

-- | Construct an answer about a function, given as a Haskell real -&gt;
--   real function.
makeAnswerFn1ByBoxesNoIx :: (ERFnDomApprox box varid domra ranra fa) => (box -> [ranra]) -> (QAFn1Q box) -> (QAFn1A ranra fa)
data QAFn2Q fa
QAFn2QPt :: fa -> QAFn2Q fa
data QAFn2A fa
QAFn2APt :: fa -> QAFn2A fa
chTFn2 :: (ERFnApprox box varid domra ranra fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable box, Show box, Typeable domra, Typeable ranra, Typeable fa, HTML fa) => fa -> ChannelType
instance Typeable1 QAFn2A
instance Typeable1 QAFn2Q
instance Typeable2 QAFn1A
instance Typeable1 QAFn1Q
instance (Show fa) => Show (QAFn2A fa)
instance (Show fa) => Show (QAFn2Q fa)
instance (Show ranra, Show fa) => Show (QAFn1A ranra fa)
instance (Show box) => Show (QAFn1Q box)
instance (HTML fa) => HTML (QAFn2A fa)
instance (HTML fa) => HTML (QAFn2Q fa)
instance (ERFnApprox box varid domra ranra fa) => Ord (QAFn2Q fa)
instance (ERFnApprox box varid domra ranra fa) => Eq (QAFn2A fa)
instance (ERFnApprox box varid domra ranra fa) => Eq (QAFn2Q fa)
instance (ERFnApprox box varid domra ranra fa, Typeable fa, HTML fa) => QAProtocol (QAFn2Q fa) (QAFn2A fa)
instance (Show ranra, HTML fa) => HTML (QAFn1A ranra fa)
instance (Show box) => HTML (QAFn1Q box)
instance (ERFnApprox box varid domra ranra fa) => Eq (QAFn1A ranra fa)
instance (DomainBox box varid domra, ERApprox domra) => Ord (QAFn1Q box)
instance (DomainBox box varid domra, ERApprox domra) => Eq (QAFn1Q box)
instance (ERFnApprox box varid domra ranra fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable box, Show box, Typeable domra, Typeable ranra, Typeable fa, HTML fa) => QAProtocol (QAFn1Q box) (QAFn1A ranra fa)


-- | Basic protocol for transferring approximations of a single real number
--   using intervals.
module Control.ERNet.Blocks.Real.Protocols
data QARealQ
QARealQ :: QARealQ
data QARealA ra
QARealA :: ra -> QARealA ra
chTReal :: (ERApproxElementary ira, Typeable ira) => ira -> ChannelType

-- | Construct an answer to a query for a real number using the default
--   real number protocol with an effort index.
makeAnswerR :: (ERApproxElementary ra) => (EffortIndex -> ra) -> (QAIxQ (QARealQ)) -> (QAIxA (QARealA ra))

-- | Construct an answer to a query for a real number using the default
--   real number protocol without any effort index.
makeAnswerRNoIx :: (ERApproxElementary ra) => (ra) -> (QARealQ) -> (QARealA ra)

-- | Construct an answer to a query for a list a real numbers using the
--   list protocol with an effort index.
makeAnswerRs :: (ERApproxElementary ra) => (EffortIndex -> [ra]) -> (QAIxQ (QAListQ QARealQ)) -> (QAIxA (QAListA (QARealA ra)))

-- | Construct an answer to a query for a list a real numbers using the
--   list protocol without any effort index.
makeAnswerRsNoIx :: (ERApproxElementary ra) => ([ra]) -> (QAListQ QARealQ) -> (QAListA (QARealA ra))

-- | Make a query and wait for answer on a real number input socket with
--   the standard (index -&gt; approx) protocol.
querySyncR :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERApproxElementary ira, Typeable ira) => sOut q2 a2 -> QueryId -> (sIn (QAIxQ QARealQ) (QAIxA (QARealA ira))) -> EffortIndex -> IO (ira)
instance Typeable1 QARealA
instance Typeable QARealQ
instance (Eq ra) => Eq (QARealA ra)
instance (Ord ra) => Ord (QARealA ra)
instance (Show ra) => Show (QARealA ra)
instance Eq QARealQ
instance Ord QARealQ
instance Show QARealQ
instance (Show ra) => HTML (QARealA ra)
instance HTML QARealQ
instance (ERApproxElementary ira, Typeable ira) => QAProtocol QARealQ (QARealA ira)


-- | A few processes universally useful when representing (1st-order) real
--   functions as single data entities via <a>ERFnDomApprox</a>.
module Control.ERNet.Blocks.RnToRm.Basic

-- | A pass-through process for first order real functions with effort
--   index that is almost equal to the identity.
--   
--   It restricts the function's graph at certain given intervals to the
--   given boxes.
boundingProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERFnDomApprox box varid domra ranra fa, Typeable box, Typeable fa, Show box, HTML fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable domra, Typeable ranra) => Bool -> ERProcessName -> ChannelType -> fa -> EffortIndex -> [(domra, ranra)] -> ERProcess sInAnyProt sOutAnyProt

-- | A simple integrator process for first-order linear domain functions
--   with effort index using the default integration of the
--   <a>ERFnDomApprox</a> instance.
integrateFAProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERFnDomApprox box varid domra ranra fa, Typeable box, Typeable fa, Show box, HTML fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable domra, Typeable ranra) => ERProcessName -> ChannelType -> fa -> ERProcess sInAnyProt sOutAnyProt

-- | An intersecting and improvement measuring stateful integrator process
--   using default intersecting &amp; measuring integration of the
--   <a>ERFnDomApprox</a> instance.
integrateIsectMeasureFAProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERFnDomApprox box varid domra ranra fa, Typeable box, Typeable fa, Show box, HTML fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable domra, Typeable ranra) => ERProcessName -> fa -> ERProcess sInAnyProt sOutAnyProt

-- | Apply a function transformer ((R^m-&gt;R^n) -&gt; (R^m-&gt;R^n)) to a
--   function (R^m-&gt;R^n).
applyFieldProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERFnDomApprox box varid domra ranra fa, Typeable box, Typeable fa, Show box, HTML fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable domra, Typeable ranra) => ERProcessName -> fa -> ERProcess sInAnyProt sOutAnyProt

-- | A process joining two functions for adjacent domains to one function
--   on the joint domain.
--   
--   Each query is split accordingly to two queries on the two halves of
--   the bisected domain, respectively.
joinFADomProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERFnDomApprox box varid domra ranra fa, Typeable box, Typeable fa, Show box, HTML fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable domra, Typeable ranra) => ERProcessName -> fa -> ERProcess sInAnyProt sOutAnyProt

-- | A process splitting a function into two based on a bisection of the
--   domain.
--   
--   A query for either half of the function results in a query for the
--   whole. The whole function is then cached to answer an analogous query
--   for the second half. Only one such result is cached (always the last
--   one).
splitFADomProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERFnDomApprox box varid domra ranra fa, Typeable box, Typeable fa, Show box, HTML fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable domra, Typeable ranra) => ERProcessName -> fa -> ERProcess sInAnyProt sOutAnyProt

-- | A process passing on information about a real function, trying to
--   improve the convergence rate in successive queries.
--   
--   Each query may refer to a previous query. When it does, the query will
--   not be answered until either:
--   
--   <ul>
--   <li>the information about the function has improved by the desired
--   amount since last time</li>
--   <li>the number of queries made in response to this query has reached
--   the given limit</li>
--   </ul>
rateFnProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERFnDomApprox box varid domra ranra fa, Typeable box, Typeable fa, Show box, HTML fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable domra, Typeable ranra) => ERProcessName -> Rational -> Int -> fa -> ERProcess sInAnyProt sOutAnyProt

-- | A process passing on information about the values of a real function
--   at its domain endpoints.
--   
--   Protocols are wrapped in <tt>ChannelComm.ChTChanges</tt> in order to
--   be able to communicate failure.
getEndpointValsProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERFnDomApprox box varid domra ranra fa, Typeable box, Typeable fa, Show box, HTML fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable domra, Typeable ranra) => ERProcessName -> fa -> ERProcess sInAnyProt sOutAnyProt

-- | A process passing on information about the values of a real function
--   over a fixed domain.
--   
--   Protocols are wrapped in <tt>ChannelComm.ChTChanges</tt> in order to
--   be able to communicate failure.
maxOverDomProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERFnDomApprox box varid domra ranra fa, Typeable box, Typeable fa, Show box, HTML fa, ERApproxElementary domra, ERApproxElementary ranra, Typeable domra, Typeable ranra) => ERProcessName -> box -> fa -> ERProcess sInAnyProt sOutAnyProt


module Control.ERNet.Blocks.Real.Basic

-- | A process passing on information about a real number, trying to
--   improve the convergence rate in successive queries.
--   
--   Each query may refer to a previous query. When it does, the query will
--   not be answered until either:
--   
--   <ul>
--   <li>the information about the number has improved by the desired
--   amount since last time</li>
--   <li>the number of queries made in response to this query has reached
--   the given limit</li>
--   </ul>
rateRProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERApproxElementary ra, Typeable ra) => ERProcessName -> Rational -> Int -> ra -> ERProcess sInAnyProt sOutAnyProt

-- | A process passing on information about a list of real numbers, trying
--   to improve the convergence rate in successive queries.
--   
--   Each query may refer to a previous query. When it does, the query will
--   not be answered until either:
--   
--   <ul>
--   <li>the information about the tuple has improved by the desired amount
--   since last time</li>
--   <li>the number of queries made in response to this query has reached
--   the given limit</li>
--   </ul>
rateRsProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERApproxElementary ra, Typeable ra) => ERProcessName -> Rational -> Int -> ra -> ERProcess sInAnyProt sOutAnyProt


-- | A protocol for sending a real number using a stream of LFT digits
--   based on the work of Potts and Edalat (1997).
module Control.ERNet.Blocks.Real.LFT
data QALFTRealQ
QALFTRealQ :: Int -> QALFTRealQ
data QALFTRealA
QALFTRealA :: [LFTDigit] -> QALFTRealA
data LFTDigit
LFT_L :: LFTDigit
LFT_M :: LFTDigit
LFT_R :: LFTDigit
LFT_SG_ZER :: LFTDigit
LFT_SG_INF :: LFTDigit
LFT_SG_POS :: LFTDigit
LFT_SG_NEG :: LFTDigit

-- | Interpret the LFT digits as LFTs.
lftDigit2Tensor :: LFTDigit -> LFTTensor
chTLFTReal :: ChannelType

-- | A process communicating a real number to a single client incrementally
--   digit by digit.
lftRealNumberIncremProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt, ERIntApprox ra, Typeable ra) => ERProcessName -> (EffortIndex -> ra) -> ERProcess sInAnyProt sOutAnyProt

-- | A process that receives a real number incrementally digit by digit and
--   makes it available to multiple clients incrementally or
--   non-incrementally.
lftRealNumberBufferForkProcess :: (Channel sIn sOut sInAnyProt sOutAnyProt) => ERProcessName -> ERProcess sInAnyProt sOutAnyProt

-- | A multi-dimensional linear fractional transformation with integer
--   coefficients.
data LFTTensor
LFTTensor :: Int -> Map [Bool] Integer -> LFTTensor
lftTNSrank :: LFTTensor -> Int

-- | the first Bool indicates whether or not the term is in the numerator
--   of the LFT
lftTNScoeffs :: LFTTensor -> Map [Bool] Integer

-- | Constructor for a 0-ary LFT with integer coefficients.
lftConst :: Integer -> Integer -> LFTTensor

-- | Constructor for a unary LFT with integer coefficients.
lftMatrix :: Integer -> Integer -> Integer -> Integer -> LFTTensor

-- | Constructor for a binary LFT with integer coefficients.
lftTensorBinary :: Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> LFTTensor

-- | Work out what interval is the image of the lft when all variables are
--   given the value [0,oo]. The returned interval may be slightly bigger
--   than the exact image due to rounding but it always contains the whole
--   exact image.
lftTensorInfo :: (ERApprox ra) => Granularity -> LFTTensor -> ExtInterval ra
lftTensorIsPositive :: LFTTensor -> Bool

-- | Compose two LFTs, ie substituting one into another using one of its
--   variables.
lftTensorCompose :: LFTTensor -> Int -> LFTTensor -> LFTTensor

-- | Compose two unary LFTs, ie substituting one into the other.
lftTensorComposeUnary :: LFTTensor -> LFTTensor -> LFTTensor
instance Typeable LFTDigit
instance Typeable QALFTRealA
instance Typeable QALFTRealQ
instance (Show ra) => Show (ExtInterval ra)
instance Show LFTTensor
instance Eq LFTDigit
instance Ord LFTDigit
instance Eq QALFTRealA
instance Ord QALFTRealA
instance Show QALFTRealA
instance Eq QALFTRealQ
instance Ord QALFTRealQ
instance Show QALFTRealQ
instance HTML QALFTRealA
instance HTML QALFTRealQ
instance HTML LFTDigit
instance Show LFTDigit
instance QAProtocol QALFTRealQ QALFTRealA


-- | Functions that produce a javascipt representation of the message
--   dependence graph contained in a set of network events.
module Control.ERNet.Foundations.Event.JavaScript
constructJS :: [ERNetEvent] -> String


-- | A simple logger implementation using an STM channel.
module Control.ERNet.Deployment.Local.Logger
data LoggerLocal
instance Logger LoggerLocal


-- | A simple channel implementation using STM protected variables.
module Control.ERNet.Deployment.Local.Channel
data ChannelLocal q a

-- | Union of channel types over instances of the
--   <tt>ChannelComm.QERrotocol</tt> class.
--   
--   (existential type)
data ChannelLocalAnyProt
instance Typeable2 ChannelLocal
instance Show (ChannelLocal q a)
instance Ord (ChannelLocal q a)
instance Eq (ChannelLocal q a)
instance ChannelForScheduler LoggerLocal ChannelLocal ChannelLocal ChannelLocalAnyProt ChannelLocalAnyProt
instance Channel ChannelLocal ChannelLocal ChannelLocalAnyProt ChannelLocalAnyProt


-- | A simple implementation of
--   <a>Control.ERNet.Foundations.Manager.Manager</a>, deploying all
--   processes locally.
module Control.ERNet.Deployment.Local.Manager
data ManagerLocal
instance Manager ManagerLocal LoggerLocal ChannelLocal ChannelLocal ChannelLocalAnyProt ChannelLocalAnyProt
