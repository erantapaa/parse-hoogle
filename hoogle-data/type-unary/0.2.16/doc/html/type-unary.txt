-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-level and typed unary natural numbers, inequality proofs, vectors
--   
--   Type-level and value-typed unary natural numbers, inequality proofs,
--   and length-typed vectors. There are probably many of these packages.
--   Perhaps consolidate.
@package type-unary
@version 0.2.16


-- | Type-level unary natural numbers
module TypeUnary.TyNat

-- | Type-level representation of zero
data Z

-- | Type-level representation of successor
data S n

-- | Sum of type-level numbers

-- | Product of type-level numbers
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
type N11 = S N10
type N12 = S N11
type N13 = S N12
type N14 = S N13
type N15 = S N14
type N16 = S N15
instance Typeable Z
instance Typeable1 S


-- | Experiment in length-typed vectors
module TypeUnary.Nat
data Nat :: * -> *
Zero :: Nat Z
Succ :: Nat n -> Nat (S n)
zero :: Nat N0
one :: Nat N1
two :: Nat N2
three :: Nat N3
four :: Nat N4
withIsNat :: (IsNat n => Nat n -> a) -> (Nat n -> a)
natSucc :: Nat n -> Nat (S n)
natIsNat :: Nat n -> (IsNat n => Nat n)

-- | Interpret a <a>Nat</a> as a plain number
natToZ :: (Enum a, Num a) => Nat n -> a

-- | Equality test
natEq :: Nat m -> Nat n -> Maybe (m :=: n)

-- | Sum of naturals
natAdd :: Nat m -> Nat n -> Nat (m :+: n)

-- | Product of naturals
natMul :: Nat m -> Nat n -> Nat (m :*: n)

-- | Is <tt>n</tt> a natural number type?
class Typeable n => IsNat n
nat :: IsNat n => Nat n

-- | Peano's induction principle
induction :: p Z -> (forall n. IsNat n => p n -> p (S n)) -> (forall n. IsNat n => p n)

-- | Proof that <tt>m &lt; n</tt>
data (:<:) m n
ZLess :: Z :<: S n
SLess :: m :<: n -> S m :<: S n

-- | Increase the upper limit in an inequality proof
succLim :: m :<: n -> m :<: S n

-- | A number under the given limit, with proof
data Index lim
Index :: (n :<: lim) -> (Nat n) -> Index lim
unIndex :: (Num a, Enum a) => Index m -> a
succI :: Index m -> Index (S m)
index0 :: Index (N1 :+: m)
index1 :: Index (N2 :+: m)
index2 :: Index (N3 :+: m)
index3 :: Index (N4 :+: m)

-- | Index generation from integer. Can fail dynamically if the integer is
--   too large.
coerceToIndex :: (Eq i, Show i, Num i, IsNat m) => i -> Index m
instance IsNat n => IsNat (S n)
instance IsNat Z
instance IsNat n => Num (Index n)
instance Show (Index n)
instance Eq (Index lim)
instance Show (Nat n)


-- | Experiment in length-typed vectors
module TypeUnary.Vec

-- | Vectors with type-determined length, having empty vector (<a>ZVec</a>)
--   and vector cons ('(:&lt;)').
data Vec :: * -> * -> *
ZVec :: Vec Z a
(:<) :: a -> Vec n a -> Vec (S n) a

-- | Type-safe un-cons for vectors
unConsV :: Vec (S n) a -> (a, Vec n a)

-- | Type-safe head for vectors
headV :: Vec (S n) a -> a

-- | Type-safe tail for vectors
tailV :: Vec (S n) a -> Vec n a

-- | Equivalent to monad <tt>join</tt> for vectors
joinV :: Vec n (Vec n a) -> Vec n a

-- | Concatenation of vectors
(<+>) :: Vec m a -> Vec n a -> Vec (m :+: n) a

-- | Indices under <tt>n</tt>: <a>index0</a> :&lt; <a>index1</a> :&lt; ...
indices :: IsNat n => Vec n (Index n)

-- | Vector of ints from 0 to n-1. Named for APL iota operation (but 0
--   based).
iota :: (IsNat n, Num a, Enum a) => Vec n a
type Vec0 = Vec N0
type Vec1 = Vec N1
type Vec2 = Vec N2
type Vec3 = Vec N3
type Vec4 = Vec N4
type Vec5 = Vec N5
type Vec6 = Vec N6
type Vec7 = Vec N7
type Vec8 = Vec N8
type Vec9 = Vec N9
type Vec10 = Vec N10
type Vec11 = Vec N11
type Vec12 = Vec N12
type Vec13 = Vec N13
type Vec14 = Vec N14
type Vec15 = Vec N15
type Vec16 = Vec N16
vec1 :: a -> Vec1 a
vec2 :: a -> a -> Vec2 a
vec3 :: a -> a -> a -> Vec3 a
vec4 :: a -> a -> a -> a -> Vec4 a
vec5 :: a -> a -> a -> a -> a -> Vec5 a
vec6 :: a -> a -> a -> a -> a -> a -> Vec6 a
vec7 :: a -> a -> a -> a -> a -> a -> a -> Vec7 a
vec8 :: a -> a -> a -> a -> a -> a -> a -> a -> Vec8 a

-- | Extract element
un1 :: Vec1 a -> a

-- | Extract elements
un2 :: Vec2 a -> (a, a)

-- | Extract elements
un3 :: Vec3 a -> (a, a, a)

-- | Extract elements
un4 :: Vec4 a -> (a, a, a, a)

-- | Extract a vector element, taking a proof that the index is within
--   bounds.
get :: Index n -> Vec n a -> a
get0 :: Vec (N1 :+: n) a -> a
get1 :: Vec (N2 :+: n) a -> a
get2 :: Vec (N3 :+: n) a -> a
get3 :: Vec (N4 :+: n) a -> a

-- | Update a vector element, taking a proof that the index is within
--   bounds.
update :: Index n -> (a -> a) -> Vec n a -> Vec n a

-- | Replace a vector element, taking a proof that the index is within
--   bounds.
set :: Index n -> a -> Vec n a -> Vec n a
set0 :: a -> Vec (N1 :+: n) a -> Vec (N1 :+: n) a
set1 :: a -> Vec (N2 :+: n) a -> Vec (N2 :+: n) a
set2 :: a -> Vec (N3 :+: n) a -> Vec (N3 :+: n) a
set3 :: a -> Vec (N4 :+: n) a -> Vec (N4 :+: n) a

-- | Variant of <a>get</a> in which the index size is checked at run-time
--   instead of compile-time.
getI :: (IsNat n, Show i, Integral i) => i -> Vec n a -> a

-- | Variant of <a>set</a> in which the index size is checked at run-time
--   instead of compile-time.
setI :: (IsNat n, Show i, Integral i) => i -> a -> Vec n a -> Vec n a

-- | Flatten a vector of vectors (a 2D array) into a vector
flattenV :: IsNat n => Vec n (Vec m a) -> Vec (n :*: m) a

-- | Chunk a vector into a vector of vectors (a 2D array)
chunkV :: (IsNat n, IsNat m) => Vec (n :*: m) a -> Vec n (Vec m a)

-- | Swizzling. Extract multiple elements simultaneously.
swizzle :: Vec n (Index m) -> Vec m a -> Vec n a

-- | Split a vector
split :: IsNat n => Vec (n :+: m) a -> (Vec n a, Vec m a)

-- | Delete exactly one occurrence of an element from a vector, raising an
--   error if the element isn't present.
deleteV :: Eq a => a -> Vec (S n) a -> Vec n a

-- | Convert a list into a vector. Error if the list is too short or too
--   long
elemsV :: IsNat n => [a] -> Vec n a

-- | Zip two vectors into one. Like <tt><a>liftA2</a> '(,)'</tt>, but the
--   former requires <tt>IsNat n</tt>.
zipV :: Vec n a -> Vec n b -> Vec n (a, b)

-- | Unzip one vector into two. Like <a>liftA2</a>, but the former requires
--   <tt>IsNat n</tt>.
zipWithV :: (a -> b -> c) -> Vec n a -> Vec n b -> Vec n c

-- | Unzip a vector of pairs into a pair of vectors
unzipV :: Vec n (a, b) -> (Vec n a, Vec n b)

-- | Zip three vectors into one. Like <tt><tt>liftA3</tt> '(,)'</tt>, but
--   the former requires <tt>IsNat n</tt>.
zipV3 :: Vec n a -> Vec n b -> Vec n c -> Vec n (a, b, c)

-- | Unzip one vector into two. Like <a>liftA2</a>, but the former requires
--   <tt>IsNat n</tt>.
zipWithV3 :: (a -> b -> c -> d) -> Vec n a -> Vec n b -> Vec n c -> Vec n d

-- | Unzip a vector of pairs into a pair of vectors
unzipV3 :: Vec n (a, b, c) -> (Vec n a, Vec n b, Vec n c)

-- | Matrix transposition. Specialization of <a>sequenceA</a>.
transpose :: IsNat n => Vec m (Vec n a) -> Vec n (Vec m a)

-- | Cross-product of two vectors, in the set-theory sense, not the
--   geometric sense. You can <a>flattenV</a> the resulting vector of
--   vectors.
cross :: Vec m a -> Vec n b -> Vec m (Vec n (a, b))
class ToVec c n a
toVec :: ToVec c n a => c -> Vec n a
instance Typeable2 Vec
instance (IsNat n, RealFloat applicative_arg) => RealFloat (Vec n applicative_arg)
instance (IsNat n, RealFrac applicative_arg) => RealFrac (Vec n applicative_arg)
instance (IsNat n, Floating applicative_arg) => Floating (Vec n applicative_arg)
instance (IsNat n, Fractional applicative_arg) => Fractional (Vec n applicative_arg)
instance (IsNat n, Integral applicative_arg) => Integral (Vec n applicative_arg)
instance (IsNat n, Num applicative_arg, Ord applicative_arg) => Real (Vec n applicative_arg)
instance (IsNat n, Num applicative_arg) => Num (Vec n applicative_arg)
instance (IsNat n, Enum applicative_arg) => Enum (Vec n applicative_arg)
instance IsNat n => ToVec [a] n a
instance ToVec (Vec n a) n a
instance (IsNat n, Storable a) => Storable (Vec n a)
instance (IsNat n, Num a) => InnerSpace (Vec n a)
instance (IsNat n, Num a) => VectorSpace (Vec n a)
instance (IsNat n, Num a) => AdditiveGroup (Vec n a)
instance Newtype (Vec (S n) a) (a, Vec n a)
instance Newtype (Vec Z a) ()
instance Traversable (Vec n)
instance Foldable (Vec n)
instance IsNat n => Monad (Vec n)
instance IsNat n => Applicative (Vec n)
instance Functor (Vec n)
instance (IsNat n, Monoid a) => Monoid (Vec n a)
instance Show a => Show (Vec n a)
instance Ord a => Ord (Vec n a)
instance Eq a => Eq (Vec n a)
