-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Principled, cross-platform & extensible hashing of types, including an implementation of the FNV-1a algorithm.
--   
@package hashabler
@version 0.1.0.2

module Data.Hashabler

-- | A class of types that can be converted into a hash value. We expect
--   all instances to display "good" hashing properties (w<i>r</i>t
--   avalanche, bit independence, etc.) when passed to a "good" <a>Hash</a>
--   function.
--   
--   We try to ensure that bytes are extracted from values in a way that is
--   portable across architectures (where possible), and straightforward to
--   replicate on other platforms and in other languages. Exceptions are
--   <b>NOTE</b>-ed in instance docs.
--   
--   See the section <a>"Defining Hashable instances"</a> for details of
--   what we expect from instances.
class Hashable a
hash :: (Hashable a, Hash h) => h -> a -> h

-- | A class for hash functions which take a running hash value and
--   incrementally mix in bytes (or chunks of bytes). Bytes are fed to
--   these methods in our <a>Hashable</a> instances, which promise to call
--   these methods in a platform-independent way.
--   
--   Instances of <a>Hash</a> only need to define <a>mix8</a>, but may
--   additional handle <tt>mix</tt>-ing in larger word chunks for
--   performance reasons. For instance a hash function which operates on
--   four bytes at a time might make use of <a>mix32</a>, and perhaps in
--   <a>mix8</a> pad with three additional 0s.
class Eq h => Hash h where mix16 h = \ wd16 -> let (wd8_0, wd8_1) = bytes16 wd16 in h `mix8` wd8_0 `mix8` wd8_1 mix32 h = \ wd32 -> let (b0, b1, b2, b3) = bytes32 wd32 in h `mix8` b0 `mix8` b1 `mix8` b2 `mix8` b3
mix8 :: Hash h => h -> Word8 -> h
mix16 :: Hash h => h -> Word16 -> h
mix32 :: Hash h => h -> Word32 -> h

-- | The FNV-1a hash algorithm. See
--   <a>http://www.isthe.com/chongo/tech/comp/fnv/</a>
newtype FNV32
FNV32 :: Word32 -> FNV32
fnv32 :: FNV32 -> Word32

-- | Hash a value using the standard spec-prescribed 32-bit seed value. For
--   relevant instances of primitive types, we expect this to produce
--   values following the FNV1a spec.
--   
--   <pre>
--   hashFNV32 = <a>hash</a> <a>fnvOffsetBasis32</a>
--   </pre>
hashFNV32 :: Hashable a => a -> FNV32
newtype FNV64
FNV64 :: Word64 -> FNV64
fnv64 :: FNV64 -> Word64

-- | Hash a value using the standard spec-prescribed 64-bit seed value. For
--   relevant instances of primitive types, we expect this to produce
--   values following the FNV1a spec.
--   
--   This may be slow on 32-bit machines.
--   
--   <pre>
--   hashFNV64 = <a>hash</a> <a>fnvOffsetBasis64</a>
--   </pre>
hashFNV64 :: Hashable a => a -> FNV64
fnvPrime32 :: Word32
fnvPrime64 :: Word64
fnvOffsetBasis32 :: FNV32
fnvOffsetBasis64 :: FNV64
mixConstructor :: Hash h => Word8 -> h -> h
instance Eq FNV32
instance Ord FNV32
instance Read FNV32
instance Show FNV32
instance Eq FNV64
instance Ord FNV64
instance Read FNV64
instance Show FNV64
instance (Hashable a1, Hashable a2, Hashable a3, Hashable a4, Hashable a5, Hashable a6, Hashable a7, Hashable a8) => Hashable (a1, a2, a3, a4, a5, a6, a7, a8)
instance (Hashable a1, Hashable a2, Hashable a3, Hashable a4, Hashable a5, Hashable a6, Hashable a7) => Hashable (a1, a2, a3, a4, a5, a6, a7)
instance (Hashable a1, Hashable a2, Hashable a3, Hashable a4, Hashable a5, Hashable a6) => Hashable (a1, a2, a3, a4, a5, a6)
instance (Hashable a1, Hashable a2, Hashable a3, Hashable a4, Hashable a5) => Hashable (a1, a2, a3, a4, a5)
instance (Hashable a1, Hashable a2, Hashable a3, Hashable a4) => Hashable (a1, a2, a3, a4)
instance (Hashable a1, Hashable a2, Hashable a3) => Hashable (a1, a2, a3)
instance (Hashable a1, Hashable a2) => Hashable (a1, a2)
instance Hashable ()
instance (Hashable a, Hashable b) => Hashable (Either a b)
instance Hashable a => Hashable (Maybe a)
instance Hashable a => Hashable [a]
instance Hashable Ordering
instance Hashable Bool
instance Hashable Unique
instance Hashable Version
instance Hashable (StableName a)
instance Hashable TypeRep
instance Hashable ThreadId
instance Hashable Char
instance Hashable ByteArray
instance Hashable Text
instance Hashable Text
instance Hashable ShortByteString
instance Hashable ByteString
instance Hashable ByteString
instance Hashable Word64
instance Hashable Word32
instance Hashable Word16
instance Hashable Word8
instance Hashable Int64
instance Hashable Int32
instance Hashable Int16
instance Hashable Int8
instance Hashable Double
instance Hashable Float
instance Hashable Word
instance Hashable Int
instance (Integral a, Hashable a) => Hashable (Ratio a)
instance Hashable Integer
instance Hash FNV64
instance Hash FNV32
