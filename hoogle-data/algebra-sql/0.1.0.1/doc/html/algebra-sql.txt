-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Relational Algebra and SQL Code Generation
--   
--   This library contains data types for relational table algebra
--   operators. DAG plans (<a>algebra-dag</a>) over these operators can be
--   compiled into compact SQL:2003 queries.
@package algebra-sql
@version 0.1.0.1

module Database.Algebra.SQL.Compatibility

-- | Defines the possible modes used for certain tasks like rendering and
--   materialization.
data CompatMode
SQL99 :: CompatMode
PostgreSQL :: CompatMode
MonetDB :: CompatMode


-- | A representation of table algebra operators over multiset relations.
module Database.Algebra.Table.Lang

-- | Sorting rows in a direction
data SortDir
Asc :: SortDir
Desc :: SortDir
data AggrType
Avg :: Expr -> AggrType
Max :: Expr -> AggrType
Min :: Expr -> AggrType
Sum :: Expr -> AggrType
Count :: AggrType
All :: Expr -> AggrType
Any :: Expr -> AggrType

-- | The show instance results in values that are accepted in the xml plan.

-- | table algebra types At this level we do not have any structural types
--   anymore those are represented by columns.
data ATy
AInt :: ATy
AStr :: ATy
ABool :: ATy
ADec :: ATy
ADouble :: ATy
ANat :: ATy

-- | Show the table algebra types in a way that is compatible with the xml
--   plan.

-- | Wrapper around values that can occur in an table algebra plan
data AVal
VInt :: Integer -> AVal
VStr :: String -> AVal
VBool :: Bool -> AVal
VDouble :: Double -> AVal
VDec :: Float -> AVal
VNat :: Integer -> AVal

-- | Show the values in the way compatible with the xml plan.

-- | Attribute name or column name
type Attr = String

-- | Name of an attribute in which the result of an expression, aggregate
--   or window function is stored.
type ResAttr = Attr

-- | Names of partition attributes used in window specifications
type PartAttr = Attr

-- | Left attribute name, used to represent the left argument when applying
--   binary operators
type LeftAttr = Attr

-- | Right attribute name, used to represent the right argument when
--   applying binary operators
type RightAttr = Attr

-- | Name of a database table
type TableName = String

-- | Typed columns
type TypedAttr = (Attr, ATy)

-- | Key of a database table, a key consists of multiple column names
newtype Key
Key :: [Attr] -> Key

-- | Sorting information
type SortSpec = (Expr, SortDir)

-- | Binary functions and operators in expressions
data BinFun
Gt :: BinFun
Lt :: BinFun
GtE :: BinFun
LtE :: BinFun
Eq :: BinFun
NEq :: BinFun
And :: BinFun
Or :: BinFun
Plus :: BinFun
Minus :: BinFun
Times :: BinFun
Div :: BinFun
Modulo :: BinFun
Contains :: BinFun
SimilarTo :: BinFun
Like :: BinFun
Concat :: BinFun

-- | Unary functions/operators in expressions
data UnFun
Not :: UnFun
Cast :: ATy -> UnFun
Sin :: UnFun
Cos :: UnFun
Tan :: UnFun
ASin :: UnFun
ACos :: UnFun
ATan :: UnFun
Sqrt :: UnFun
Log :: UnFun
Exp :: UnFun
SubString :: Integer -> Integer -> UnFun

-- | Projection expressions
data Expr
BinAppE :: BinFun -> Expr -> Expr -> Expr
UnAppE :: UnFun -> Expr -> Expr
ColE :: Attr -> Expr
ConstE :: AVal -> Expr
IfE :: Expr -> Expr -> Expr -> Expr

-- | Expressions which are used to specify partitioning in window
--   functions.
type PartExpr = Expr

-- | New column name and the expression that generates the new column
type Proj = (ResAttr, Expr)

-- | A tuple is a list of values
type Tuple = [AVal]

-- | Schema information, represents a table structure, the first element of
--   the tuple is the column name the second its type.
type SchemaInfos = [(Attr, ATy)]

-- | Comparison operators which can be used for ThetaJoins.
data JoinRel
EqJ :: JoinRel
GtJ :: JoinRel
GeJ :: JoinRel
LtJ :: JoinRel
LeJ :: JoinRel
NeJ :: JoinRel

-- | Window frame start specification
data FrameStart

-- | UNBOUNDED PRECEDING
FSUnboundPrec :: FrameStart

-- | <a>value</a> PRECEDING
FSValPrec :: Int -> FrameStart

-- | CURRENT ROW
FSCurrRow :: FrameStart

-- | Window frame end specification
data FrameEnd

-- | CURRENT ROW
FECurrRow :: FrameEnd

-- | <a>value</a> FOLLOWING
FEValFol :: Int -> FrameEnd

-- | UNBOUNDED FOLLOWING
FEUnboundFol :: FrameEnd
data FrameBounds
HalfOpenFrame :: FrameStart -> FrameBounds
ClosedFrame :: FrameStart -> FrameEnd -> FrameBounds
data WinFun
WinMax :: Expr -> WinFun
WinMin :: Expr -> WinFun
WinSum :: Expr -> WinFun
WinAvg :: Expr -> WinFun
WinAll :: Expr -> WinFun
WinAny :: Expr -> WinFun
WinFirstValue :: Expr -> WinFun
WinLastValue :: Expr -> WinFun
WinCount :: WinFun
data NullOp
LitTable :: ([Tuple], SchemaInfos) -> NullOp
TableRef :: (TableName, [TypedAttr], [Key]) -> NullOp
newtype DescrCol
DescrCol :: Attr -> DescrCol

-- | Declare need for position columns in the query result. The distinction
--   between AbsPos and RelPos is only relevant for the optimizer: AbsPos
--   signals that the actual pos values are required. RelPos signals that
--   only the order induced by the pos column is relevant.
data SerializeOrder
AbsPos :: Attr -> SerializeOrder
RelPos :: [Attr] -> SerializeOrder
NoPos :: SerializeOrder
newtype PayloadCol
PayloadCol :: Attr -> PayloadCol
data UnOp
RowNum :: (Attr, [SortSpec], [PartExpr]) -> UnOp
RowRank :: (ResAttr, [SortSpec]) -> UnOp
WinFun :: ((ResAttr, WinFun), [PartExpr], [SortSpec], Maybe FrameBounds) -> UnOp
Rank :: (ResAttr, [SortSpec]) -> UnOp
Project :: [(Attr, Expr)] -> UnOp
Select :: Expr -> UnOp
Distinct :: () -> UnOp
Aggr :: ([(AggrType, ResAttr)], [(PartAttr, Expr)]) -> UnOp
Serialize :: (Maybe DescrCol, SerializeOrder, [PayloadCol]) -> UnOp
data BinOp
Cross :: () -> BinOp
EqJoin :: (LeftAttr, RightAttr) -> BinOp
ThetaJoin :: [(Expr, Expr, JoinRel)] -> BinOp
SemiJoin :: [(Expr, Expr, JoinRel)] -> BinOp
AntiJoin :: [(Expr, Expr, JoinRel)] -> BinOp
DisjUnion :: () -> BinOp
Difference :: () -> BinOp
type TableAlgebra = Algebra () BinOp UnOp NullOp AlgNode
replace :: Eq a => a -> a -> a -> a
replaceChild :: Eq c => c -> c -> Algebra t b u n c -> Algebra t b u n c
instance Eq SortDir
instance Ord SortDir
instance Generic SortDir
instance Read SortDir
instance Eq ATy
instance Ord ATy
instance Generic ATy
instance Eq AVal
instance Ord AVal
instance Generic AVal
instance Eq Key
instance Ord Key
instance Show Key
instance Generic Key
instance Eq BinFun
instance Ord BinFun
instance Generic BinFun
instance Eq UnFun
instance Ord UnFun
instance Generic UnFun
instance Eq Expr
instance Ord Expr
instance Generic Expr
instance Eq AggrType
instance Ord AggrType
instance Generic AggrType
instance Eq JoinRel
instance Ord JoinRel
instance Generic JoinRel
instance Eq FrameStart
instance Ord FrameStart
instance Show FrameStart
instance Generic FrameStart
instance Eq FrameEnd
instance Ord FrameEnd
instance Show FrameEnd
instance Generic FrameEnd
instance Eq FrameBounds
instance Ord FrameBounds
instance Show FrameBounds
instance Generic FrameBounds
instance Eq WinFun
instance Ord WinFun
instance Show WinFun
instance Generic WinFun
instance Ord NullOp
instance Eq NullOp
instance Show NullOp
instance Generic NullOp
instance Ord DescrCol
instance Eq DescrCol
instance Generic DescrCol
instance Ord SerializeOrder
instance Eq SerializeOrder
instance Generic SerializeOrder
instance Ord PayloadCol
instance Eq PayloadCol
instance Generic PayloadCol
instance Ord UnOp
instance Eq UnOp
instance Show UnOp
instance Generic UnOp
instance Ord BinOp
instance Eq BinOp
instance Show BinOp
instance Generic BinOp
instance Datatype D1SortDir
instance Constructor C1_0SortDir
instance Constructor C1_1SortDir
instance Datatype D1ATy
instance Constructor C1_0ATy
instance Constructor C1_1ATy
instance Constructor C1_2ATy
instance Constructor C1_3ATy
instance Constructor C1_4ATy
instance Constructor C1_5ATy
instance Datatype D1AVal
instance Constructor C1_0AVal
instance Constructor C1_1AVal
instance Constructor C1_2AVal
instance Constructor C1_3AVal
instance Constructor C1_4AVal
instance Constructor C1_5AVal
instance Datatype D1Key
instance Constructor C1_0Key
instance Datatype D1BinFun
instance Constructor C1_0BinFun
instance Constructor C1_1BinFun
instance Constructor C1_2BinFun
instance Constructor C1_3BinFun
instance Constructor C1_4BinFun
instance Constructor C1_5BinFun
instance Constructor C1_6BinFun
instance Constructor C1_7BinFun
instance Constructor C1_8BinFun
instance Constructor C1_9BinFun
instance Constructor C1_10BinFun
instance Constructor C1_11BinFun
instance Constructor C1_12BinFun
instance Constructor C1_13BinFun
instance Constructor C1_14BinFun
instance Constructor C1_15BinFun
instance Constructor C1_16BinFun
instance Datatype D1UnFun
instance Constructor C1_0UnFun
instance Constructor C1_1UnFun
instance Constructor C1_2UnFun
instance Constructor C1_3UnFun
instance Constructor C1_4UnFun
instance Constructor C1_5UnFun
instance Constructor C1_6UnFun
instance Constructor C1_7UnFun
instance Constructor C1_8UnFun
instance Constructor C1_9UnFun
instance Constructor C1_10UnFun
instance Constructor C1_11UnFun
instance Datatype D1Expr
instance Constructor C1_0Expr
instance Constructor C1_1Expr
instance Constructor C1_2Expr
instance Constructor C1_3Expr
instance Constructor C1_4Expr
instance Datatype D1AggrType
instance Constructor C1_0AggrType
instance Constructor C1_1AggrType
instance Constructor C1_2AggrType
instance Constructor C1_3AggrType
instance Constructor C1_4AggrType
instance Constructor C1_5AggrType
instance Constructor C1_6AggrType
instance Datatype D1JoinRel
instance Constructor C1_0JoinRel
instance Constructor C1_1JoinRel
instance Constructor C1_2JoinRel
instance Constructor C1_3JoinRel
instance Constructor C1_4JoinRel
instance Constructor C1_5JoinRel
instance Datatype D1FrameStart
instance Constructor C1_0FrameStart
instance Constructor C1_1FrameStart
instance Constructor C1_2FrameStart
instance Datatype D1FrameEnd
instance Constructor C1_0FrameEnd
instance Constructor C1_1FrameEnd
instance Constructor C1_2FrameEnd
instance Datatype D1FrameBounds
instance Constructor C1_0FrameBounds
instance Constructor C1_1FrameBounds
instance Datatype D1WinFun
instance Constructor C1_0WinFun
instance Constructor C1_1WinFun
instance Constructor C1_2WinFun
instance Constructor C1_3WinFun
instance Constructor C1_4WinFun
instance Constructor C1_5WinFun
instance Constructor C1_6WinFun
instance Constructor C1_7WinFun
instance Constructor C1_8WinFun
instance Datatype D1NullOp
instance Constructor C1_0NullOp
instance Constructor C1_1NullOp
instance Datatype D1DescrCol
instance Constructor C1_0DescrCol
instance Datatype D1SerializeOrder
instance Constructor C1_0SerializeOrder
instance Constructor C1_1SerializeOrder
instance Constructor C1_2SerializeOrder
instance Datatype D1PayloadCol
instance Constructor C1_0PayloadCol
instance Datatype D1UnOp
instance Constructor C1_0UnOp
instance Constructor C1_1UnOp
instance Constructor C1_2UnOp
instance Constructor C1_3UnOp
instance Constructor C1_4UnOp
instance Constructor C1_5UnOp
instance Constructor C1_6UnOp
instance Constructor C1_7UnOp
instance Constructor C1_8UnOp
instance Datatype D1BinOp
instance Constructor C1_0BinOp
instance Constructor C1_1BinOp
instance Constructor C1_2BinOp
instance Constructor C1_3BinOp
instance Constructor C1_4BinOp
instance Constructor C1_5BinOp
instance Constructor C1_6BinOp
instance Operator TableAlgebra
instance Show PayloadCol
instance Show SerializeOrder
instance Show DescrCol
instance Show JoinRel
instance Show Expr
instance Show UnFun
instance Show BinFun
instance Show AVal
instance Show ATy
instance Show SortDir
instance Show AggrType

module Database.Algebra.Table.Render.JSON
serializePlan :: (NodeMap [Tag], [AlgNode], NodeMap TableAlgebra) -> ByteString
deserializePlan :: ByteString -> (NodeMap [Tag], [AlgNode], NodeMap TableAlgebra)
planToFile :: FilePath -> (NodeMap [Tag], [AlgNode], NodeMap TableAlgebra) -> IO ()
planFromFile :: FilePath -> IO (NodeMap [Tag], [AlgNode], NodeMap TableAlgebra)
instance Generic Plan
instance Datatype D1Plan
instance Constructor C1_0Plan
instance Selector S1_0_0Plan
instance Selector S1_0_1Plan
instance Selector S1_0_2Plan
instance FromJSON Plan
instance ToJSON Plan
instance FromJSON FrameStart
instance FromJSON FrameEnd
instance FromJSON FrameBounds
instance FromJSON PayloadCol
instance FromJSON SerializeOrder
instance FromJSON DescrCol
instance FromJSON Key
instance FromJSON BinFun
instance FromJSON UnFun
instance FromJSON Expr
instance FromJSON BinOp
instance FromJSON UnOp
instance FromJSON WinFun
instance FromJSON NullOp
instance FromJSON AggrType
instance FromJSON SortSpec
instance FromJSON JoinRel
instance FromJSON SortDir
instance FromJSON AVal
instance FromJSON ATy
instance ToJSON FrameStart
instance ToJSON FrameEnd
instance ToJSON FrameBounds
instance ToJSON PayloadCol
instance ToJSON SerializeOrder
instance ToJSON DescrCol
instance ToJSON Key
instance ToJSON BinFun
instance ToJSON UnFun
instance ToJSON Expr
instance ToJSON BinOp
instance ToJSON UnOp
instance ToJSON WinFun
instance ToJSON NullOp
instance ToJSON AggrType
instance ToJSON SortSpec
instance ToJSON JoinRel
instance ToJSON SortDir
instance ToJSON AVal
instance ToJSON ATy


-- | This module contains smart constructors for table algebra plans.
module Database.Algebra.Table.Construct

-- | Create a TA int value
int :: Integer -> AVal

-- | Create a TA string value
string :: String -> AVal

-- | Create a TA boolean value
bool :: Bool -> AVal

-- | Create a TA double value
double :: Double -> AVal

-- | Create a TA decimal value
dec :: Float -> AVal

-- | Create a TA nat value
nat :: Integer -> AVal

-- | Types of atomic values
intT :: ATy

-- | Types of atomic values
stringT :: ATy

-- | Types of atomic values
boolT :: ATy

-- | Types of atomic values
decT :: ATy

-- | Types of atomic values
doubleT :: ATy

-- | Types of atomic values
natT :: ATy

-- | Construct a database table node The first argument is the
--   emph{qualified} name of the database table. The second describes the
--   columns in alphabetical order. The third argument describes the
--   database keys (one table key can span over multiple columns).
dbTable :: String -> [(Attr, ATy)] -> [Key] -> Build TableAlgebra AlgNode

-- | Construct a table with one value
litTable :: AVal -> String -> ATy -> Build TableAlgebra AlgNode

-- | Construct a literal table with multiple columns and rows
litTable' :: [[AVal]] -> [(String, ATy)] -> Build TableAlgebra AlgNode

-- | Join two plans where the columns n1 of table 1 and columns n2 of table
--   2 are equal.
eqJoin :: LeftAttr -> RightAttr -> AlgNode -> AlgNode -> Build TableAlgebra AlgNode
thetaJoin :: [(Expr, Expr, JoinRel)] -> AlgNode -> AlgNode -> Build TableAlgebra AlgNode
semiJoin :: [(Expr, Expr, JoinRel)] -> AlgNode -> AlgNode -> Build TableAlgebra AlgNode
antiJoin :: [(Expr, Expr, JoinRel)] -> AlgNode -> AlgNode -> Build TableAlgebra AlgNode

-- | Assign a number to each row in column <a>ResAttr</a> incrementally
--   sorted by <tt>sort</tt>. The numbering is not dense!
rank :: ResAttr -> [SortSpec] -> AlgNode -> Build TableAlgebra AlgNode

-- | Compute the difference between two plans.
difference :: AlgNode -> AlgNode -> Build TableAlgebra AlgNode

-- | Same as rank but provides a dense numbering.
rowrank :: ResAttr -> [SortSpec] -> AlgNode -> Build TableAlgebra AlgNode

-- | Select rows where the column <tt>SelAttr</tt> contains True.
select :: Expr -> AlgNode -> Build TableAlgebra AlgNode

-- | Remove duplicate rows
distinct :: AlgNode -> Build TableAlgebra AlgNode

-- | Make cross product from two plans
cross :: AlgNode -> AlgNode -> Build TableAlgebra AlgNode

-- | Union between two plans
union :: AlgNode -> AlgNode -> Build TableAlgebra AlgNode

-- | Project/rename certain column out of a plan
proj :: [Proj] -> AlgNode -> Build TableAlgebra AlgNode

-- | Apply aggregate functions to a plan
aggr :: [(AggrType, ResAttr)] -> [(Attr, Expr)] -> AlgNode -> Build TableAlgebra AlgNode
winFun :: (ResAttr, WinFun) -> [PartExpr] -> [SortSpec] -> Maybe FrameBounds -> AlgNode -> Build TableAlgebra AlgNode

-- | Similar to rowrank but this will assign a unique number to every row
--   (even if two rows are equal)
rownum :: Attr -> [Attr] -> [PartExpr] -> AlgNode -> Build TableAlgebra AlgNode

-- | Same as rownum but columns can be assigned an ordering direction
rownum' :: Attr -> [SortSpec] -> [PartExpr] -> AlgNode -> Build TableAlgebra AlgNode

-- | Perform theta join on two plans
thetaJoinM :: [(Expr, Expr, JoinRel)] -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Perform a semi join on two plans
semiJoinM :: [(Expr, Expr, JoinRel)] -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Perform an anti join on two plans
antiJoinM :: [(Expr, Expr, JoinRel)] -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Join two plans where the columns n1 of table 1 and columns n2 of table
--   2 are equal.
eqJoinM :: String -> String -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Assign a number to each row in column <a>ResAttr</a> incrementing
--   sorted by <tt>sort</tt>. The numbering is not dense!
rankM :: ResAttr -> [SortSpec] -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Compute the difference between two plans.
differenceM :: Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Same as rank but provides a dense numbering.
rowrankM :: ResAttr -> [SortSpec] -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Select rows where the column <tt>SelAttr</tt> contains True.
selectM :: Expr -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Remove duplicate rows
distinctM :: Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Make cross product from two plans
crossM :: Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Union between two plans
unionM :: Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Project/rename certain column out of a plan
projM :: [Proj] -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Apply aggregate functions to a plan
aggrM :: [(AggrType, ResAttr)] -> [(Attr, Expr)] -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode
winFunM :: (ResAttr, WinFun) -> [PartExpr] -> [SortSpec] -> Maybe FrameBounds -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Similar to rowrank but this will assign a emph{unique} number to every
--   row (even if two rows are equal)
rownumM :: Attr -> [Attr] -> [PartExpr] -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

-- | Same as rownum but columns can be assigned an ordering direction
rownum'M :: Attr -> [SortSpec] -> [PartExpr] -> Build TableAlgebra AlgNode -> Build TableAlgebra AlgNode

module Database.Algebra.SQL.Materialization

-- | The type of materialization function. The result consists of:
--   
--   <ul>
--   <li>The queries which need to be executed first<ul><li>The queries
--   produced from the root nodes</li></ul></li>
--   </ul>
type MatFun = ([TileTree], DependencyList) -> ([Query], [Query])


-- | Materializes tiles which are reachable through multiple root tiles as
--   temporary tables and everything else by using common tables
--   expressions. It is possible to choose the binding strategy for common
--   table expressions:
--   
--   <ul>
--   <li>Bind in lowest possible CTE, results in toughest possible scoping,
--   tiles are only bound where they are actually used.<ul><li>Bind in
--   highest possible CTE, tiles are bound at the highest possible CTE,
--   results in very few common table expressions.</li></ul></li>
--   </ul>
module Database.Algebra.SQL.Materialization.Combined

-- | Describes the binding behaviour within a dependency tree.
data BindingStrategy
Lowest :: BindingStrategy
Highest :: BindingStrategy

-- | Same as <tt>materializeByBehaviour</tt> with <a>Lowest</a> as
--   behaviour.
materialize :: MatFun

-- | Merges all tiles reachable by a single root tile into nested common
--   table expressions (depending on their scope) and all tiles reachable
--   by multiple root tiles into a temporary table. The binding strategy
--   determines whether it is merged in the highest possible CTE or in the
--   lowest.
materializeByBindingStrategy :: BindingStrategy -> MatFun

module Database.Algebra.SQL.Materialization.CTE
materialize :: MatFun

-- | Create a CTE for every root tile and add a binding for every
--   dependency.
legacyMaterialize :: MatFun


-- | This module abstracts over commonly used functions.
module Database.Algebra.SQL.Util
renderOutputCompact :: CompatMode -> TADag -> MatFun -> ShowS
renderOutputPlain :: CompatMode -> TADag -> MatFun -> ShowS

-- | Produces pretty output, optionally with debug information.
renderDebugOutput :: CompatMode -> TADag -> MatFun -> Bool -> ShowS

-- | Produces output which allows further inspection with the psql command
--   line utility (and possibly others too).
renderAdvancedDebugOutput :: CompatMode -> Bool -> Bool -> TADag -> MatFun -> String

-- | Render output directly for DSH. The order from the root nodes in the
--   directed acyclic graph is preserved. (This function uses the combined
--   materialization strategy.)
renderOutputDSH :: CompatMode -> TADag -> (Maybe String, [String])

-- | Render output directly for DSH. The order from the root nodes in the
--   directed acyclic graph is preserved.
renderOutputDSHWith :: CompatMode -> MatFun -> TADag -> (Maybe String, [String])
putShowSLn :: ShowS -> IO ()

module Database.Algebra.Table.Render.Dot

-- | Render an TableAlgebra plan into a dot file (GraphViz).
renderTADot :: NodeMap [Tag] -> [AlgNode] -> NodeMap TableAlgebra -> String
