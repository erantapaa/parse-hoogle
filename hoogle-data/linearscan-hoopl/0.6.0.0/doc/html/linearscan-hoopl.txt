-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Makes it easy to use the linearscan register allocator with Hoopl
--   
@package linearscan-hoopl
@version 0.6.0.0

module LinearScan.Hoopl.DSL
data SpillStack
SpillStack :: Int -> Int -> Map (Maybe Int) Int -> SpillStack
stackPtr :: SpillStack -> Int
stackSlotSize :: SpillStack -> Int
stackSlots :: SpillStack -> Map (Maybe Int) Int
type Env = Tardis (Map PhysReg VarId) ([Int], SpillStack)
newSpillStack :: Int -> Int -> SpillStack
getStackSlot :: Maybe VarId -> Env Int
setAssignment :: PhysReg -> VarId -> Env ()
getAssignment :: PhysReg -> Env VarId

-- | The <a>Asm</a> monad lets us create labels by name and refer to them
--   later.
type Labels = Map String Label
type Asm = StateT Labels SimpleUniqueMonad
getLabel :: String -> Asm Label

-- | A series of <a>Nodes</a> is a set of assembly instructions that ends
--   with some kind of closing operation, such as a jump, branch or return.
type Nodes n a = Free ((,) (n O O)) a

-- | The <a>Nodes</a> free monad is really just a convenient way to
--   describe a list that must result in a closing operation at the end.
nodesToList :: Nodes n a -> (a, [n O O])
type BodyNode n = Nodes n ()
bodyNode :: n O O -> BodyNode n
type EndNode n = Nodes n (Asm (n O C))
endNode :: Asm (n O C) -> EndNode n

-- | A program is a series of <a>Nodes</a>, each associated with a label.
data ProgramF n
FreeBlock :: Label -> EndNode n -> ProgramF n
labelEntry :: ProgramF n -> Label
labelBody :: ProgramF n -> EndNode n
type Program n = FreeT ((,) (ProgramF n)) Asm ()
label :: String -> EndNode n -> Program n
jump :: HooplNode n => String -> EndNode n

-- | When we compile a program, the result is a closed Hoopl Graph and the
--   label corresponding to the requested entry label name.
compile :: (NonLocal n, HooplNode n) => String -> Program n -> SimpleUniqueMonad (Graph n C C, Label)
instance Eq SpillStack
instance Show SpillStack

module LinearScan.Hoopl
class HooplNode nv => NodeAlloc nv nr | nv -> nr, nr -> nv
isCall :: NodeAlloc nv nr => nv O O -> Bool
isBranch :: NodeAlloc nv nr => nv O C -> Bool
retargetBranch :: NodeAlloc nv nr => nv O C -> Label -> Label -> nv O C
mkLabelOp :: NodeAlloc nv nr => Label -> nv C O
mkJumpOp :: NodeAlloc nv nr => Label -> nv O C
getReferences :: NodeAlloc nv nr => nv e x -> [VarInfo]
setRegisters :: NodeAlloc nv nr => [(Int, PhysReg)] -> nv e x -> Env (nr e x)
mkMoveOps :: NodeAlloc nv nr => PhysReg -> PhysReg -> Env [nr O O]
mkSwapOps :: NodeAlloc nv nr => PhysReg -> PhysReg -> Env [nr O O]
mkSaveOps :: NodeAlloc nv nr => PhysReg -> Maybe VarId -> Env [nr O O]
mkRestoreOps :: NodeAlloc nv nr => Maybe VarId -> PhysReg -> Env [nr O O]
op1ToString :: NodeAlloc nv nr => nv e x -> String
data NodeV n
NodeCO :: n C O -> NodeV n
getNodeCO :: NodeV n -> n C O
NodeOO :: n O O -> NodeV n
getNodeOO :: NodeV n -> n O O
NodeOC :: n O C -> NodeV n
getNodeOC :: NodeV n -> n O C
blockInfo :: (NodeAlloc nv nr, NonLocal nv, NonLocal nr) => (Label -> Env Int) -> BlockInfo Env (Block nv C C) (Block nr C C) (NodeV nv) (NodeV nr)
opInfo :: NodeAlloc nv nr => OpInfo Env (NodeV nv) (NodeV nr)
allocateHoopl :: (NodeAlloc nv nr, NonLocal nv, NonLocal nr) => Int -> Int -> Int -> Label -> Graph nv C C -> Either [String] (Graph nr C C)
