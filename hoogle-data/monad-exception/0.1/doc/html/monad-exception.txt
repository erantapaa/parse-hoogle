-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Exstensible monadic exceptions
--   
--   Extensible exceptions are a good solution to the exception problem in
--   Haskell. However, there is one problem: they are not extensible
--   enough! The problem is that the functions defined in
--   <tt>Control.Exception</tt> for dealing with exceptions can only be
--   used with the <tt>IO</tt> monad. A lot of Haskell code uses a stack of
--   monads, at the bottom of which is <tt>IO</tt>, but the <tt>IO</tt>
--   monad is not used directly.
--   
--   There have been many attempts to solve this problem, but the stumbling
--   block has been the presence of short-circuiting monad transformers:
--   sometimes, these prevented the cleanup actions from being run, making
--   it effectively impossible to catch exceptions in such monads. The
--   <tt>monad-control</tt> package has been developed as a solution to
--   this problem: it defines a way to turn a monad transformer stack
--   "inside-out", which ensures that cleanup actions are run even when the
--   original action short-circuits. The <tt>lifted-base</tt> package,
--   built on top of <tt>monad-control</tt>, exports the
--   <tt>Control.Exception.Lifted</tt> module, which contains versions of
--   the <a>Control.Exception</a> functions that work on any monad stack
--   with <tt>IO</tt> at its base.
--   
--   This has pretty much solved the above problems. However, one thing
--   that the solutions that came before <tt>monad-control</tt> did was
--   provide a type class encapsulating exception functionality that could
--   be implemented by pure monads, allowing you to use the same interface
--   to throw and catch exceptions in both pure and <tt>IO</tt>-based code.
--   This also makes it possible to express which can throw an exception,
--   but which don't necessarily do any IO and which are polymorphic in
--   their exception throwing (i.e., you could run the function in
--   <tt>IO</tt> and it would use <tt>throwIO</tt>, or you could run it as
--   an <tt>Either</tt> and it would use <tt>Left</tt>).
--   
--   That's what this package does. It provides a <tt>MonadException</tt>
--   type class (in the <a>Control.Monad.Exception.Class</a> module), which
--   has instances for <tt>IO</tt> and <tt>IO</tt>-like monads (for which
--   <tt>monad-control</tt> is used to provide the correct instances as
--   described above), as well as for some pure monads. Several overlapping
--   instances (in the spirit of <tt>mtl-evil-instances</tt>) are provided,
--   so it is not necessary to provide a pass-through instance for
--   <tt>MonadException</tt> for every monad transformer you write.
--   
--   This package also defines an <tt>ExceptionT</tt> monad transformer (in
--   <a>Control.Monad.Trans.Exception</a>) that can be used to add
--   <tt>MonadException</tt> functionality to otherwise pure monad stacks.
--   <tt>mtl-evil-instances</tt> is used to automatically provide
--   pass-through instances for the <tt>mtl</tt> type classes for this
--   transformer.
--   
--   Finally, this package includes the module
--   <a>Control.Exception.Monadic</a>, which is a full replacement for
--   <a>Control.Exception</a>, whose functions work on any instance of
--   <tt>MonadException</tt> and not just <tt>IO</tt>. The functions for
--   dealing with asynchronous exceptions require <tt>IO</tt> however, so
--   these are only polymorphic for any <tt>IO</tt>-like monadic (as
--   determined by <tt>monad-control</tt>).
@package monad-exception
@version 0.1


-- | This module exports the <a>MonadException</a> type class.
module Control.Monad.Exception.Class

-- | The <a>MonadException</a> type class. Minimal complete definition:
--   <a>throw</a>, <a>catch</a>.
class Monad m => MonadException m where bracket open close thing = do { a <- open; b <- thing a `catch` \ e@(SomeException _) -> close a >> throw e; close a; return b }
throw :: (MonadException m, Exception e) => e -> m a
catch :: (MonadException m, Exception e) => m a -> (e -> m a) -> m a
bracket :: MonadException m => m a -> (a -> m b) -> (a -> m c) -> m c
instance [overlap ok] (MonadTransControl t, Monad (t m), MonadException m) => MonadException (t m)
instance [overlap ok] (MonadException b, MonadBaseControl b m) => MonadException m
instance [overlap ok] MonadException IO
instance [overlap ok] MonadException (Either SomeException)


-- | This module exports the <a>ExceptionT</a> monad transformer.
module Control.Monad.Trans.Exception

-- | The <a>ExceptionT</a> monad transformer. This is can be used to add
--   <a>MonadException</a> functionality otherwise pure monad stacks. If
--   your monad stack is built on top of <a>IO</a> however, it already has
--   <a>MonadException</a> functionality and you should use that instead,
--   unless you have a good reason not to. Pass-through instances for the
--   <tt>mtl</tt> type classes are provided automatically by the
--   <tt>mtl-evil-instances</tt> package.
data ExceptionT m a

-- | Run the <a>ExceptionT</a> monad transformer. This returns <a>Right</a>
--   if everything goes okay, and <a>Left</a> in the case of an error, with
--   the exception wrapped up in a <a>SomeException</a>.
runExceptionT :: Monad m => ExceptionT m a -> m (Either SomeException a)
instance Monad m => MonadException (ExceptionT m)
instance MonadBaseControl b m => MonadBaseControl b (ExceptionT m)
instance Monad m => MonadPlus (ExceptionT m)
instance Monad m => Monad (ExceptionT m)
instance Monad m => Alternative (ExceptionT m)
instance Monad m => Applicative (ExceptionT m)
instance Monad m => Functor (ExceptionT m)
instance MonadTransControl ExceptionT
instance MonadTrans ExceptionT


-- | This module is intended as a drop-in replacement for
--   <a>Control.Exception</a>.
module Control.Exception.Monadic

-- | The <a>MonadException</a> type class. Minimal complete definition:
--   <a>throw</a>, <a>catch</a>.
class Monad m => MonadException m where bracket open close thing = do { a <- open; b <- thing a `catch` \ e@(SomeException _) -> close a >> throw e; close a; return b }
throw :: (MonadException m, Exception e) => e -> m a
catch :: (MonadException m, Exception e) => m a -> (e -> m a) -> m a
bracket :: MonadException m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Generalized version of <a>catches</a>.
catches :: MonadException m => m a -> [Handler m a] -> m a

-- | Generalized version of <a>Handler</a>. You need this when using
--   <a>catches</a>.
data Handler m a
Handler :: (e -> m a) -> Handler m a

-- | Generalized version of <a>catchJust</a>.
catchJust :: (MonadException m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a

-- | A version of <a>catch</a> with the arguments swapped around. See
--   <a>handle</a>.
handle :: (MonadException m, Exception e) => (e -> m a) -> m a -> m a

-- | A version of <a>catchJust</a> with the arguments swapped around. See
--   <a>handleJust</a>.
handleJust :: (MonadException m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a

-- | A generalized version of <a>try</a>.
try :: (MonadException m, Exception e) => m a -> m (Either e a)

-- | A generalized version of <a>tryJust</a>.
tryJust :: (MonadException m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)

-- | Generalized version of <a>bracket_</a>.
bracket_ :: MonadException m => m a -> m b -> m c -> m c

-- | Generalized version of <a>bracketOnError</a>.
bracketOnError :: MonadException m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Generalized version of <a>finally</a>.
finally :: MonadException m => m a -> m b -> m a

-- | Generalized version of <a>onException</a>.
onException :: MonadException m => m a -> m b -> m a

-- | Generalized version of <a>evaluate</a>. This only works on
--   <a>IO</a>-like monads. See <a>unsafeEvaluate</a> for a version that
--   works on every <a>MonadException</a>.
evaluate :: MonadBase IO m => a -> m a

-- | Generalized version of <a>evaluate</a>. This uses
--   <a>unsafePerformIO</a> behind the scenes to do something kind of
--   similar to what the <tt>spoon</tt> package does.
unsafeEvaluate :: MonadException m => a -> m a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Generalized version of <a>throwTo</a>.
throwTo :: (MonadBase IO m, Exception e) => ThreadId -> e -> m ()

-- | Generalized version of <a>mask</a>.
mask :: MonadBaseControl IO m => ((forall n b. MonadBaseControl IO n => n b -> n b) -> m a) -> m a

-- | Generalized version of <a>mask</a>.
mask_ :: MonadBaseControl IO m => m a -> m a

-- | Generalized version of <a>mask</a>.
uninterruptibleMask :: MonadBaseControl IO m => ((forall n b. MonadBaseControl IO n => n b -> n b) -> m a) -> m a

-- | Generalized version of <a>mask</a>.
uninterruptibleMask_ :: MonadBaseControl IO m => m a -> m a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState :: *

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Generalized version of <a>getMaskingState</a>.
getMaskingState :: MonadBase IO m => m MaskingState

-- | Generalized version of <a>allowInterrupt</a>.
allowInterrupt :: MonadBase IO m => m ()

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException :: *
SomeException :: e -> SomeException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException :: *

-- | Arithmetic exceptions.
data ArithException :: *
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

-- | Exceptions generated by array operations
data ArrayException :: *

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | <a>assert</a> was applied to <a>False</a>.
data AssertionFailed :: *
AssertionFailed :: String -> AssertionFailed

-- | Asynchronous exceptions.
data AsyncException :: *

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception.</li>
--   <li>GHC currently does not throw <a>HeapOverflow</a> exceptions.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data NonTermination :: *
NonTermination :: NonTermination

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data NestedAtomically :: *
NestedAtomically :: NestedAtomically

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar :: *
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM :: *
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock :: *
Deadlock :: Deadlock

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
data NoMethodError :: *
NoMethodError :: String -> NoMethodError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
data PatternMatchFail :: *
PatternMatchFail :: String -> PatternMatchFail

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
data RecConError :: *
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
data RecSelError :: *
RecSelError :: String -> RecSelError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
data RecUpdError :: *
RecUpdError :: String -> RecUpdError

-- | This is thrown when the user calls <a>error</a>. The <tt>String</tt>
--   is the argument given to <a>error</a>.
data ErrorCall :: *
ErrorCall :: String -> ErrorCall
