-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Scene Graph
--   
--   Scene Graph Library.
@package scenegraph
@version 0.1.0.1

module Graphics.SceneGraph.ReadImage
readImage :: FilePath -> IO (Maybe (Size, PixelData a))
instance [overlap ok] Storable Word32BigEndian

module Graphics.SceneGraph.TGA
withBinaryFile' :: FilePath -> (Handle -> IO a) -> IO a
readTga :: FilePath -> IO (Maybe (Size, PixelData Word8))
swapBytes' :: Ptr Word8 -> Int -> Int -> IO ()
swapByteRGB :: Ptr Word8 -> IO ()
swapByteRGBA :: Ptr Word8 -> IO ()
getFormat :: Int -> IO (PixelFormat)

module Graphics.SceneGraph.MySTM
type STM a = IO a
atomically :: MVar Bool -> STM a -> IO a
unsafeIOToSTM :: IO a -> STM a
type TVar a = IORef a
readTVar :: TVar a -> STM a
writeTVar :: TVar a -> a -> STM ()
newTVar :: a -> STM (TVar a)

module Graphics.SceneGraph.Utils

module Graphics.SceneGraph.Textures
getAndCreateTextures :: [String] -> IO [Maybe TextureObject]
getAndCreateTexture :: String -> IO (Maybe TextureObject)
readImageC :: String -> IO (Maybe (Size, PixelData Word8))
createTexture :: (Maybe (Size, PixelData a)) -> IO (Maybe TextureObject)

module Graphics.SceneGraph.Vector
type VectorD = Vector GLdouble
betweenV3 :: (Storable a, Num a) => Vertex3 a -> Vertex3 a -> Vector a
lengthV3 :: (Floating a) => Vector3 a -> a
vector3 :: (Storable a, Num a) => a -> a -> a -> Vector a
vy :: (Storable a, Num a) => a -> Vector a
vx :: (Storable a, Num a) => a -> Vector a
vxz :: (Storable a, Num a) => a -> a -> Vector a
vxy :: (Storable a, Num a) => a -> a -> Vector a
v1z :: (Storable a, Num a) => a -> Vector a
v1y :: (Storable a, Num a) => a -> Vector a
v1x :: (Storable a, Num a) => a -> Vector a
vz :: (Storable a, Num a) => a -> Vector a
v1 :: VectorD
v0 :: VectorD
vyz :: (Storable a, Num a) => a -> a -> Vector a

module Graphics.SceneGraph.Matrix
type MatrixD = Matrix GLdouble
identityMatrix :: MatrixD
asMatrix :: VectorD -> MatrixD
translateM :: VectorD -> MatrixD -> MatrixD
translatePostM :: VectorD -> MatrixD -> MatrixD
scaleM :: VectorD -> MatrixD -> MatrixD

-- | Build rotational transform matrix for rotate of ''theta'' around a
--   vector.
rotateM' :: (Element a) => a -> Vector a -> Matrix a
mulV :: MatrixD -> VectorD -> VectorD


-- | Definition of types and combinators.
--   
--   Construction of the graph is done within a Monad (<a>OSGT</a>).
--   <a>osg</a> is then used to extract the <a>Scene</a>.
module Graphics.SceneGraph.Basic

-- | Scene Node. Made up of data and maybe a widget
data SceneNode
SceneNode :: (Node, String) -> SceneData -> SceneNode

-- | Scene Graph based on a Graph
type SceneGraph = Gr SceneNode ()
type OSG = OSGT Identity

-- | Scene Graph with indicate root node
type Scene = (SceneGraph, Node)

-- | Simple colours
data Colour
Grey :: Colour
JustWhite :: Colour
Red :: Colour
Green :: Colour
Blue :: Colour
Black :: Colour
LightBlue :: Colour
White :: Colour
Yellow :: Colour

-- | Scene Node Data.
data SceneData
Group :: SceneData
Geode :: Geometry -> SceneData
LOD :: SceneData
MatrixTransform :: (MatrixD) -> SceneData
Switch :: Int -> SceneData
Material :: Phong -> SceneData
Handler :: (Maybe (ClickHandler, Sink ())) -> (Maybe (DragHandler, Sink GLdouble)) -> SceneData
Light :: SceneData
Camera :: SceneData
Texture :: String -> SceneData
Text :: String -> SceneData

-- | Phong colouring
data Phong
Phong :: Maybe (Color4 GLfloat) -> Maybe (Color4 GLfloat) -> Maybe (Color4 GLfloat) -> Maybe (Color4 GLfloat) -> Maybe (GLfloat) -> Maybe (Color4 GLfloat) -> Maybe (GLfloat) -> Maybe (Color4 GLfloat) -> Maybe (GLfloat) -> Phong
emissionPh :: Phong -> Maybe (Color4 GLfloat)
ambientPh :: Phong -> Maybe (Color4 GLfloat)
diffusePh :: Phong -> Maybe (Color4 GLfloat)
specularPh :: Phong -> Maybe (Color4 GLfloat)
shinePh :: Phong -> Maybe (GLfloat)
reflectivePh :: Phong -> Maybe (Color4 GLfloat)
reflectivityPh :: Phong -> Maybe (GLfloat)
transparentPh :: Phong -> Maybe (Color4 GLfloat)
tranparencyPh :: Phong -> Maybe (GLfloat)

-- | Geometry. Either a basic GL object or a mesh.
--   
--   FIXME - Reduce number of mesh types - to whatever is easier to draw (I
--   suppose)
data Geometry
GLObj :: Object -> Geometry
Mesh1 :: [(PrimitiveMode, Int, Int)] -> [VectorD] -> [VectorD] -> Geometry
Mesh2 :: [(PrimitiveMode, Int, Int)] -> (Array Int (VectorD, VectorD, Maybe (VectorD))) -> Geometry
Mesh3 :: [VectorD] -> Geometry
BezierMesh :: [[[Vertex3 GLfloat]]] -> Geometry
emptyOSG :: SceneGraph

-- | Holds state of graph as it is built.
data OSGState
OSGState :: SceneGraph -> [SceneNode] -> Map Int SceneNode -> Int -> Int -> Maybe OSGStateRef -> OSGState
gr :: OSGState -> SceneGraph
context :: OSGState -> [SceneNode]
heap :: OSGState -> Map Int SceneNode
startNode :: OSGState -> Int
root :: OSGState -> Int
selfRef :: OSGState -> Maybe OSGStateRef

-- | Empty state
--   
--   Empty state with the self reference set
emptyStateWithRef :: IO OSGState

-- | Creates an empty scene graph
--   
--   Creates a scene graph containing the supplied node
trivialGr :: SceneNode -> SceneGraph

-- | Non-monadic form of addNode
addNode' :: OSGState -> SceneNode -> [((), Node)] -> (SceneNode, OSGState)

-- | Add node with scene data
--   
--   Add node with scene data
--   
--   Add empty node
addNullNode :: (Monad m) => OSGT m SceneNode

-- | Basic add node
addNodeBasic :: (Monad m) => SceneNode -> OSGT m SceneNode

-- | Add a node to a scene graph with supplied children
addNode :: (Monad m) => SceneNode -> [((), Node)] -> OSGT m SceneNode

-- | Replace a Scene Node
replaceNode :: (Monad m) => SceneNode -> OSGT m SceneNode
findCamera :: Scene -> Int -> Node
findCameraPath :: Scene -> Int -> Path

-- | Rotate a node around X axis
rotateX :: (Monad m) => OSGT m SceneNode -> GLdouble -> OSGT m SceneNode

-- | Rotate a node around Y axis
rotateY :: (Monad m) => OSGT m SceneNode -> GLdouble -> OSGT m SceneNode

-- | Rotate a node around Z axis
rotateZ :: (Monad m) => OSGT m SceneNode -> GLdouble -> OSGT m SceneNode

-- | Create a node containing a torus.
torus :: (Monad m) => Float -> OSGT m SceneNode

-- | Create a node containing a sphere
sphere :: (Monad m) => Float -> OSGT m SceneNode

-- | Create a node containing a tetrahedron
tetra :: (Monad m) => OSGT m SceneNode

-- | Create a node containing a line
line :: (Monad m) => VectorD -> VectorD -> OSGT m SceneNode

-- | Create a node containing a cube. Fixme: Faces are not orientated same
--   way.
cube :: (Monad m) => GLdouble -> OSGT m SceneNode

-- | Create a ClickHandler
switchHandler :: ClickHandler

-- | Create a light
light :: (Monad m) => OSGT m SceneNode

-- | Create a camera
camera :: (Monad m) => OSGT m SceneNode
plane :: (Monad m) => Int -> OSGT m SceneNode

-- | Add texture
texture :: (Monad m) => OSGT m SceneNode -> String -> OSGT m SceneNode
planeQ :: (Monad m) => Int -> OSGT m SceneNode

-- | Add Text
text :: (Monad m) => String -> OSGT m SceneNode

-- | Scale a node by equal amounts in all directions
scaleS :: (Monad m) => OSGT m SceneNode -> GLdouble -> OSGT m SceneNode

-- | Scale a node
scale :: (Monad m) => OSGT m SceneNode -> VectorD -> OSGT m SceneNode

-- | Translate a node
translate :: (Monad m) => OSGT m SceneNode -> VectorD -> OSGT m SceneNode

-- | Rotate a node by an angle around a vector.
rotate :: (Monad m) => OSGT m SceneNode -> (GLdouble, VectorD) -> OSGT m SceneNode

-- | Join two graphs together
(<+>) :: (Monad m) => OSGT m SceneNode -> OSGT m SceneNode -> OSGT m SceneNode

-- | Translate a node
(<*>) :: (Monad m) => OSGT m SceneNode -> VectorD -> OSGT m SceneNode

-- | Scale a node
(</>) :: (Monad m) => OSGT m SceneNode -> VectorD -> OSGT m SceneNode

-- | Get a strip mesh
strip :: (Monad m) => OSGT m SceneNode

-- | Create a switch node
switch :: (Monad m) => OSGT m SceneNode -> OSGT m SceneNode -> OSGT m SceneNode
switch' :: (Monad m) => Int -> OSGT m SceneNode -> OSGT m SceneNode -> OSGT m SceneNode
translateSG' :: SceneGraph -> Node -> VectorD -> SceneGraph
rotatePostSG' :: SceneGraph -> Node -> VectorD -> GLdouble -> SceneGraph
translatePostSG' :: SceneGraph -> Node -> VectorD -> SceneGraph

-- | Add colour to a node
colour :: (Monad m) => OSGT m SceneNode -> Colour -> OSGT m SceneNode

-- | Create cylinder as a BezierMesh
cylinder :: (Monad m) => GLfloat -> GLfloat -> OSGT m SceneNode

-- | Wrapper for running the OSG monad to return a scene graph and root
--   node.
osg :: (Monad m) => OSGT m SceneNode -> m Scene

-- | Create and run a OSG monad to return a scene graph and root node.
runOSG :: (Monad m) => OSGState -> OSGT m SceneNode -> m (SceneNode, OSGState, Node)
r :: GLdouble

-- | Return the matrix got by traversing down the Node
getTransformTo :: Scene -> Node -> MatrixD

-- | Work down the tree from indicated no to find the first handler scene
--   node.
findHandlerDown :: SceneGraph -> Int -> Int
findTextDown :: SceneGraph -> Int -> Int

-- | The OSG monad within which construction of scene graphs occur. was
--   'type OSGT m = ErrorT Throwable (ST.StateT OSGState m)'
type OSGT m = StateT OSGState m

-- | Actually does the job of replacing node in a scene graph
replaceNode'' :: SceneGraph -> SceneNode -> SceneGraph

-- | Add an handler node
handler :: (Monad m) => OSGT m SceneNode -> ClickHandler -> OSGT m SceneNode
handler2 :: (Monad m) => OSGT m SceneNode -> (ClickHandler, DragHandler) -> OSGT m SceneNode

-- | Handle some event
handleClickEvent :: Scene -> GLuint -> KeyState -> IO (Scene, Maybe Scene, Maybe (SceneGraph -> SceneGraph))

-- | Label a node
label :: (Monad m) => OSGT m SceneNode -> String -> OSGT m SceneNode
getByLabel :: SceneGraph -> String -> Node
getHitAction :: Scene -> (GLuint -> IO ())

-- | Work up the tree from indicated no to find the first handler scene
--   node.
findHandler :: SceneGraph -> GLuint -> Maybe SceneNode

-- | Inner monad version of replace node
replaceNode' :: (Monad md) => SceneGraph -> SceneNode -> md SceneGraph
newtype OSGStateRef
OSGStateRef :: IORef OSGState -> OSGStateRef
getOSR :: OSGStateRef -> IORef OSGState
data SinkValue
SVD :: GLdouble -> SinkValue
SVB :: Bool -> SinkValue
SVT :: String -> SinkValue

-- | Create a DragHandler
dragHandler :: DragHandler
instance [overlap ok] Eq OSGState
instance [overlap ok] Show OSGState
instance [overlap ok] Show Throwable
instance [overlap ok] Eq Phong
instance [overlap ok] Show Phong
instance [overlap ok] Show Colour
instance [overlap ok] Eq Colour
instance [overlap ok] Eq Geometry
instance [overlap ok] Show Geometry
instance [overlap ok] Show SceneNode
instance [overlap ok] Eq OSGStateRef
instance [overlap ok] Show OSGStateRef
instance [overlap ok] Error Throwable
instance [overlap ok] Eq SceneGraph
instance [overlap ok] Show SceneData
instance [overlap ok] Show DragHandler
instance [overlap ok] Show ClickHandler
instance [overlap ok] Eq SceneNode


-- | Scene Graph drawing
module Graphics.SceneGraph.Render

-- | Draw a scene graph (or a scenegraph fragment)
drawSceneGraph :: Map String TextureObject -> (SceneGraph, Node) -> IO ()


-- | Provide a view window onto a scenegraph. Handles basic navigation and
--   interaction with widgets.
module Graphics.SceneGraph.SimpleViewport

-- | Setup GUI and run it.
setupGUI :: MVar Bool -> GSRef -> IO ()
data GraphicsState
GraphicsState :: GLdouble -> GLdouble -> GLdouble -> Maybe Position -> Maybe DisplayList -> Maybe (IO ()) -> Maybe HitSink -> Bool -> Maybe Scene -> Maybe Scene -> Map String TextureObject -> Maybe (Vector GLdouble) -> Maybe (GLmatrix GLdouble) -> Maybe (Int -> IO ()) -> Maybe (GLmatrix GLdouble) -> GraphicsState
gsR :: GraphicsState -> GLdouble
gsSig :: GraphicsState -> GLdouble
gsTheta :: GraphicsState -> GLdouble
gsMPos :: GraphicsState -> Maybe Position
gsDisplayList :: GraphicsState -> Maybe DisplayList
gsDrawFunc :: GraphicsState -> Maybe (IO ())
gsHitSink :: GraphicsState -> Maybe HitSink
gsDrag :: GraphicsState -> Bool
gsScene :: GraphicsState -> Maybe Scene
gsFocus :: GraphicsState -> Maybe Scene
gsTexture :: GraphicsState -> Map String TextureObject
gsDragPos :: GraphicsState -> Maybe (Vector GLdouble)
gsProjMatrix :: GraphicsState -> Maybe (GLmatrix GLdouble)
gsBlah :: GraphicsState -> Maybe (Int -> IO ())
gsModelMatrix :: GraphicsState -> Maybe (GLmatrix GLdouble)
drawCanvas :: GSRef -> STM ()
type GSRef = TVar GraphicsState

-- | Run a scene. Displays the Scene in a basic viewport permitting user
--   interaction.
runScene :: Scene -> IO ()

module Graphics.SceneGraph.GraphViz
exportSG :: Handle -> (SceneGraph, Node) -> IO ()


module Graphics.SceneGraph.Library
simple1 :: (SceneGraph, Node)
simple :: (SceneGraph, Node)
rr :: GLdouble
crossbeam :: GLdouble -> OSG SceneNode
ferris :: GLdouble -> OSG SceneNode
wheel :: OSG SceneNode
buttons :: OSG SceneNode
tux :: OSG SceneNode
tuxAndToys :: Scene
calcButton :: [Char] -> OSGT Identity SceneNode
room :: OSGT Identity SceneNode
calculator :: Scene

module Graphics.SceneGraph.Dump
dump :: SceneGraph -> IO ()

module Graphics.SceneGraph
