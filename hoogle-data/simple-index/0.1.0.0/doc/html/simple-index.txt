-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Allows simple indexation on any data type
--   
--   Allows simple indexation on any data type
@package simple-index
@version 0.1.0.0

module Data.SimpleIndex
data Indexed a i1 i2 i3 i4 i5 i6

-- | Use this function to create an Indexed data type with only 1 index for
--   your type
create1 :: (Eq a, Eq i1, Hashable i1) => (a -> i1) -> Indexed a i1 () () () () ()

-- | Create an Indexed data type with 2 indexes for your type create2 ::
--   forall a i1 i2 i3 i4 i5 i6. (Eq i1, Eq i2, Eq i3, Eq i4, Eq i5, Eq i6,
--   Hashable i1, Hashable i2, Hashable i3, Hashable i4, Hashable i5,
--   Hashable i6, SafeCopy a) =&gt; (a -&gt; i1) -- ^ The function that
--   returns the first index for your datatype -&gt; (a -&gt; i2) -- ^ The
--   function that returns the second index for your datatype -&gt; Indexed
--   a i1 i2 i3 i4 i5 i6
create2 :: (a -> i1) -> (a -> i2) -> Indexed a i1 i2 i3 i4 i5 i6

-- | Create an Indexed data type with 3 indexes for your type
create3 :: (a -> i1) -> (a -> i2) -> (a -> i3) -> Indexed a i1 i2 i3 () () ()

-- | Create an Indexed data type with 4 indexes for your type
create4 :: (a -> i1) -> (a -> i2) -> (a -> i3) -> (a -> i4) -> Indexed a i1 i2 i3 i4 () ()

-- | Create an Indexed data type with 5 indexes for your type
create5 :: (a -> i1) -> (a -> i2) -> (a -> i3) -> (a -> i4) -> (a -> i5) -> Indexed a i1 i2 i3 i4 i5 ()

-- | Create an Indexed data type with 6 indexes for your type
create6 :: (a -> i1) -> (a -> i2) -> (a -> i3) -> (a -> i4) -> (a -> i5) -> (a -> i6) -> Indexed a i1 i2 i3 i4 i5 i6
class SimpleIx a where type family I1 a type family I2 a type family I3 a type family I4 a type family I5 a type family I6 a
create :: SimpleIx a => Indexed a (I1 a) (I2 a) (I3 a) (I4 a) (I5 a) (I6 a)

-- | Inserts a new value into the Indexed data type and updates all the
--   information in the indexes
ixInsert :: (Eq k4, Eq k3, Eq k2, Eq k1, Eq k, Eq i6, Hashable k4, Hashable k3, Hashable k2, Hashable k1, Hashable k, Hashable i6) => Indexed a k4 k3 k2 k1 k i6 -> a -> Indexed a k4 k3 k2 k1 k i6

-- | Deletes a value from the Indexed data type and updates all the
--   information in the indexes
ixDelete :: (Eq a, Eq k, Eq i2, Eq i3, Eq i4, Eq i5, Eq i6, Hashable k, Hashable i2, Hashable i3, Hashable i4, Hashable i5, Hashable i6) => Indexed a k i2 i3 i4 i5 i6 -> a -> Indexed a k i2 i3 i4 i5 i6

-- | Updates a value in the Indexed data type and all the information in
--   the indexes
ixUpdate :: (Eq k, Eq i2, Eq i3, Eq i4, Eq i5, Eq i6, Hashable k, Hashable i2, Hashable i3, Hashable i4, Hashable i5, Hashable i6) => Indexed a k i2 i3 i4 i5 i6 -> k -> (a -> a) -> Maybe (Int, a, a, Indexed a k i2 i3 i4 i5 i6)

-- | Reads your datatype from the Indexed data by looking up a first index
--   value
ixRead1 :: (Eq b, Hashable b) => b -> Indexed a b t2 t3 t4 t5 t6 -> Maybe a

-- | Reads your datatype from the Indexed data by looking up a value on the
--   second index
ixRead2 :: (Eq b, Hashable b) => b -> Indexed a t1 b t3 t4 t5 t6 -> Maybe a

-- | Reads your datatype from the Indexed data by looking up a value on the
--   third index
ixRead3 :: (Eq b, Hashable b) => b -> Indexed a t1 t2 b t4 t5 t6 -> Maybe a

-- | Reads your datatype from the Indexed data by looking up a value on the
--   fourth index
ixRead4 :: (Eq b, Hashable b) => b -> Indexed a t1 t2 t3 b t5 t6 -> Maybe a

-- | Reads your datatype from the Indexed data by looking up a value on the
--   fifth index
ixRead5 :: (Eq b, Hashable b) => b -> Indexed a t1 t2 t3 t4 b t6 -> Maybe a

-- | Reads your datatype from the Indexed data by looking up a value on the
--   sixth index
ixRead6 :: (Eq b, Hashable b) => b -> Indexed a t1 t2 t3 t4 t5 b -> Maybe a
instance (Eq a, Eq t1, Eq t2, Eq t3, Eq t4, Eq t5, Eq t6, Hashable t1, Hashable t2, Hashable t3, Hashable t4, Hashable t5, Hashable t6, t1 ~ I1 a, t2 ~ I2 a, t3 ~ I3 a, t4 ~ I4 a, t5 ~ I5 a, t6 ~ I6 a, SafeCopy a, SimpleIx a) => SafeCopy (Indexed a t1 t2 t3 t4 t5 t6)
