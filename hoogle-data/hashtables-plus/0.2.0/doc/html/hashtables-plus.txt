-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extensions for a "hashtables" library
--   
--   A dome API over the "hashtables" library, which provides <a>null</a>
--   and <a>size</a> functions of <i>O(1)</i> complexity and advanced data
--   structures: multimap, set, <a>StableName</a>-based structures.
@package hashtables-plus
@version 0.2.0

module HashtablesPlus.HashRef

-- | A reference to a mutable value, which provides instances for
--   <a>Hashable</a> and <a>Eq</a>.
--   
--   It allows to use the values without those instances as keys in hash
--   tables.
data HashRef a
HashRef :: {-# UNPACK #-} !(StableName a) -> !a -> HashRef a

-- | Create a new reference.
--   
--   Two references created from the same value are not guaranteed to be
--   equal or produce the same hash. However the references created from
--   different values are guaranteed to be different.
new :: a -> IO (HashRef a)

-- | Extract the value from this reference.
value :: HashRef a -> a
instance Eq (HashRef a)
instance Hashable (HashRef a)

module HashtablesPlus

-- | A type synonym for an <a>IOHashTable</a> with <a>Algorithm</a>
--   <tt>a</tt>.
--   
--   E.g.:
--   
--   <pre>
--   type CuckooTable k v = <a>Map</a> <a>Cuckoo</a> k v
--   </pre>
type Map a k v = a RealWorld k v

-- | A set of values, which have instances for <a>Eq</a> and
--   <a>Hashable</a>.
--   
--   <tt>a</tt> is the underlying <a>Algorithm</a>, <tt>v</tt> is the item.
--   
--   E.g.:
--   
--   <pre>
--   type CuckooSet v = <a>Set</a> <a>Cuckoo</a> v
--   </pre>
data Set a v

-- | A specialized set of <a>HashRef</a>s.
--   
--   <tt>a</tt> is the underlying <a>Algorithm</a>, <tt>v</tt> is the item.
--   
--   E.g.:
--   
--   <pre>
--   type LinearHashRefSet v = <a>HashRefSet</a> <a>Linear</a> v
--   </pre>
data HashRefSet a v

-- | A multimap with an underlying <a>Algorithm</a> <tt>a</tt>, a key
--   <tt>k</tt> and a set implementation <tt>s</tt>.
--   
--   E.g.:
--   
--   <pre>
--   type BasicMultimap k v = <a>Multimap</a> <a>Basic</a> k (<a>Set</a> <a>Basic</a> v)
--   </pre>
--   
--   If a <a>Sized</a> implementation of set is specified, a more space
--   efficient instance of <a>Delete</a> will be used. E.g.:
--   
--   <pre>
--   Multimap Basic k (<a>Sized</a> (Set Basic v))
--   </pre>
data Multimap a k s

-- | A wrapper over a <a>Collection</a>, which adds <a>null</a> and
--   <a>size</a> functions of <i>O(1)</i> complexity.
--   
--   E.g.:
--   
--   <pre>
--   type SizedLinearTable k v = <a>Sized</a> (<a>Map</a> <a>Linear</a> k v)
--   </pre>
data Sized c

-- | An alias to a <a>HashTable</a> constraint of the "hashtables" library.
type Algorithm = HashTable

-- | The fastest, but the most memory-hungry implementation.
type Basic = HashTable

-- | The implementation with a medium performance and memory consumption.
type Cuckoo = HashTable

-- | The implementation with a low performance, but also a low memory
--   consumption.
type Linear = HashTable

-- | A constraint for values usable as hash table key.
type Key k = (Hashable k, Eq k)

-- | A row of a collection. For tables and multitables it's a key-value
--   pair, for sets it's just the item.

-- | A unique row identifier. For tables it's a key, for multitables it's a
--   key-value pair, for sets it's the item itself.

-- | A non-unique row identifier. For tables and sets there is none, for
--   multitables it's a key.

-- | An item of a collection. For tables and multitables it's a value (from
--   the key-value pair), for sets it's the item.
class Collection c
new :: Collection c => IO c
traverse :: Collection c => c -> (Row c -> IO ()) -> IO ()

-- | <i>O(n)</i>. Convert a collection to a list.
toList :: Collection c => c -> IO [Row c]
class Collection c => Lookup c
lookup :: Lookup c => c -> UniqueKey c -> IO (Maybe (Value c))
class Collection c => TraverseMulti c
traverseMulti :: TraverseMulti c => c -> MultiKey c -> (Value c -> IO ()) -> IO ()

-- | Lookup multiple items by a non-unique key.
lookupMulti :: TraverseMulti c => c -> MultiKey c -> IO [Value c]
class Collection c => Elem c where elem = ((fmap isJust) .) . lookup
elem :: Elem c => c -> UniqueKey c -> IO Bool
class Collection c => Insert c where insertFast = (void .) . insert
insert :: Insert c => c -> Row c -> IO Bool
insertFast :: Insert c => c -> Row c -> IO ()
class Collection c => Delete c where deleteFast = (void .) . delete
delete :: Delete c => c -> UniqueKey c -> IO Bool
deleteFast :: Delete c => c -> UniqueKey c -> IO ()
class Collection c => Size c
size :: Size c => c -> IO Int
class Collection c => Null c where null = fmap (<= 0) . size
null :: Null c => c -> IO Bool
instance Collection c => Null (Sized c)
instance Collection c => Size (Sized c)
instance Delete c => Delete (Sized c)
instance Insert c => Insert (Sized c)
instance Elem c => Elem (Sized c)
instance TraverseMulti c => TraverseMulti (Sized c)
instance Lookup c => Lookup (Sized c)
instance Collection c => Collection (Sized c)
instance (Algorithm a, Key k, Delete s) => Delete (Multimap a k (Sized s))
instance (Algorithm a, Key k, Delete s) => Delete (Multimap a k s)
instance (Algorithm a, Key k, Insert s) => Insert (Multimap a k s)
instance (Algorithm a, Key k, Elem s) => Elem (Multimap a k s)
instance (Algorithm a, Key k, Collection s, Value s ~ Row s) => TraverseMulti (Multimap a k s)
instance (Algorithm a, Key k, Collection s) => Collection (Multimap a k s)
instance Algorithm a => Delete (HashRefSet a v)
instance Algorithm a => Insert (HashRefSet a v)
instance Algorithm a => Elem (HashRefSet a v)
instance Algorithm a => Collection (HashRefSet a v)
instance (Algorithm a, Key v) => Delete (Set a v)
instance (Algorithm a, Key v) => Insert (Set a v)
instance (Algorithm a, Key v) => Elem (Set a v)
instance (Algorithm a, Key v) => Collection (Set a v)
instance (Algorithm a, Key k) => Delete (Map a k v)
instance (Algorithm a, Key k) => Insert (Map a k v)
instance (Algorithm a, Key k) => Elem (Map a k v)
instance (Algorithm a, Key k) => Lookup (Map a k v)
instance (Algorithm a, Key k) => Collection (Map a k v)
