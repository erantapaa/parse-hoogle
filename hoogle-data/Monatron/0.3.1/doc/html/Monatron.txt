-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monad transformer library with uniform liftings
--   
--   An extensible monad transformer library with uniform liftings, a
--   fairly portable core, and option of explicit naming of liftings. See
--   http://www.fceia.unr.edu.ar/~mjj/Monatron/ for more information. The
--   monad zipper allows modular composition of components with Monatron
--   effects. It is a contribution of Bruno Oliveira and Tom Schrijvers.
--   See http://www.cs.kuleuven.be/~toms/Haskell/ for more information.
@package Monatron
@version 0.3.1

module Control.Monatron.MonadT
class MonadT t
lift :: (MonadT t, Monad m) => m a -> t m a
treturn :: (MonadT t, Monad m) => a -> t m a
tbind :: (MonadT t, Monad m) => t m a -> (a -> t m b) -> t m b
class MonadT t => FMonadT t
tmap' :: FMonadT t => FunctorD m -> FunctorD n -> (a -> b) -> (forall x. m x -> n x) -> t m a -> t n b
class FMonadT t => MMonadT t
flift :: (MMonadT t, Functor f) => f a -> t f a
monoidalT :: (MMonadT t, Functor f, Functor g) => t f (t g a) -> t (FComp f g) a
newtype FComp f g a
Comp :: (f (g a)) -> FComp f g a
deComp :: FComp f g a -> (f (g a))
newtype FunctorD f
FunctorD :: (forall a b. (a -> b) -> f a -> f b) -> FunctorD f
fmapD :: FunctorD f -> forall a b. (a -> b) -> f a -> f b
tmap :: (FMonadT t, Functor m, Functor n) => (forall b. m b -> n b) -> t m a -> t n a
mtmap :: FMonadT t => FunctorD f -> (a -> b) -> t f a -> t f b
instance (Functor f, Functor g) => Functor (FComp f g)

module Control.Monatron.AutoInstances
instance [overlap ok] (Monad m, MonadT t) => Functor (t m)
instance [overlap ok] (Monad m, MonadT t) => Monad (t m)

module Control.Monatron.Transformer
data StateT s m a
stateT :: (s -> m (a, s)) -> StateT s m a
runStateT :: s -> StateT s m a -> m (a, s)
data WriterT w m a
writerT :: (Monoid w, Monad m) => m (a, w) -> WriterT w m a
runWriterT :: Monoid w => WriterT w m a -> m (a, w)
data ReaderT s m a
readerT :: Monad m => (e -> m a) -> ReaderT e m a
runReaderT :: s -> ReaderT s m a -> m a
data ExcT x m a
excT :: Monad m => m (Either x a) -> ExcT x m a
runExcT :: Monad m => ExcT x m a -> m (Either x a)
data ContT r m a
contT :: ((a -> m r) -> m r) -> ContT r m a
runContT :: (a -> m r) -> ContT r m a -> m r
data StepT f m x
stepT :: m (Either x (f (StepT f m x))) -> StepT f m x
runStepT :: StepT f m x -> m (Either x (f (StepT f m x)))
caseStepT :: (Functor f, Monad m) => (a -> StepT f m x) -> (f (StepT f m a) -> StepT f m x) -> StepT f m a -> StepT f m x
unfoldStepT :: (Functor f, Monad m) => (y -> m (Either x (f y))) -> y -> StepT f m x
data ListT m a
listT :: m (LSig (ListT m) a ()) -> ListT m a
runListT :: ListT m a -> m (LSig (ListT m) a ())
foldListT :: Monad m => (a -> m b -> m b) -> m b -> ListT m a -> m b
collectListT :: Monad m => ListT m a -> m [a]
emptyL :: Monad m => ListT m a
appendL :: Monad m => ListT m a -> ListT m a -> ListT m a
instance Functor f => FMonadT (StepT f)
instance Functor f => MonadT (StepT f)
instance FMonadT ListT
instance MonadT ListT
instance MonadT (ContT r)
instance FMonadT (ExcT x)
instance MonadT (ExcT x)
instance MonadFix m => MonadFix (ExcT x m)
instance MMonadT (ReaderT s)
instance FMonadT (ReaderT s)
instance MonadT (ReaderT s)
instance Monoid w => MMonadT (WriterT w)
instance Monoid w => FMonadT (WriterT w)
instance Monoid w => MonadT (WriterT w)
instance MMonadT (StateT s)
instance FMonadT (StateT s)
instance MonadFix m => MonadFix (StateT s m)
instance MonadT (StateT s)

module Control.Monatron.Monad
type State s = StateT s Id
type Writer w = WriterT w Id
type Reader r = ReaderT r Id
type Exception x = ExcT x Id
type Cont r = ContT r Id
state :: (s -> (a, s)) -> State s a
writer :: Monoid w => (a, w) -> Writer w a
reader :: (r -> a) -> Reader r a
exception :: Either x a -> Exception x a
cont :: ((a -> r) -> r) -> Cont r a
runState :: s -> State s a -> (a, s)
runWriter :: Monoid w => Writer w a -> (a, w)
runReader :: r -> Reader r a -> a
runException :: Exception x a -> Either x a
runCont :: (a -> r) -> Cont r a -> r
newtype Id a
Id :: a -> Id a
runId :: Id a -> a
data Lift a
L :: a -> Lift a
runLift :: Lift a -> a
instance MonadFix Lift
instance MonadFix Id
instance Functor Lift
instance Functor Id
instance Monad Lift
instance Monad Id

module Control.Monatron.Codensity
data Codensity f a
codensity :: (forall b. (a -> f b) -> f b) -> Codensity f a
runCodensity :: Monad m => Codensity m a -> m a
instance MonadFix m => MonadFix (Codensity m)
instance MonadT Codensity

module Control.Monatron.Operations
type ExtModel f g m = forall a. f (m (g a)) -> m a
type Model f m = forall a. f (m a) -> m a
type AlgModel f m = forall a. f a -> m a
toAlg :: (Functor f, Monad m) => Model f m -> AlgModel f (Codensity m)
liftModel :: (Functor f, Monad m, Functor m, FMonadT t, Monad (t (Codensity m))) => Model f m -> Model f (t m)
liftAlgModel :: (MonadT t, Monad m, Functor f) => AlgModel f m -> AlgModel f (t m)
liftExtModel :: (Functor f, Functor g, Monad m, Functor m, MMonadT t, Functor (t f), Functor (t m)) => ExtModel f g m -> ExtModel f g (t m)
data StateOp s a
Get :: (s -> a) -> StateOp s a
Put :: s -> a -> StateOp s a
modelStateT :: Monad m => AlgModel (StateOp s) (StateT s m)
getX :: Monad m => AlgModel (StateOp s) m -> m s
putX :: Monad m => AlgModel (StateOp s) m -> s -> m ()
data ReaderOp s a
Ask :: (s -> a) -> ReaderOp s a
InEnv :: s -> a -> ReaderOp s a
modelReaderT :: Monad m => Model (ReaderOp s) (ReaderT s m)
askX :: Monad m => Model (ReaderOp s) m -> m s
inEnvX :: Monad m => Model (ReaderOp s) m -> s -> m a -> m a
localX :: Monad m => Model (ReaderOp z) m -> (z -> z) -> m a -> m a
data WriterOp w a
Trace :: w -> a -> WriterOp w a
modelWriterT :: (Monad m, Monoid w) => AlgModel (WriterOp w) (WriterT w m)
traceX :: Monad m => AlgModel (WriterOp w) m -> w -> m ()
data ThrowOp x a
Throw :: x -> ThrowOp x a
data HandleOp x a
Handle :: a -> (x -> a) -> HandleOp x a
modelThrowExcT :: Monad m => AlgModel (ThrowOp x) (ExcT x m)
modelHandleExcT :: Monad m => Model (HandleOp x) (ExcT x m)
modelThrowIO :: AlgModel (ThrowOp SomeException) IO
modelHandleIO :: Model (HandleOp SomeException) IO
throwX :: Monad m => AlgModel (ThrowOp x) m -> x -> m a
handleX :: Monad m => Model (HandleOp x) m -> m a -> (x -> m a) -> m a
data ContOp r a
Abort :: r -> ContOp r a
CallCC :: ((a -> r) -> a) -> ContOp r a
modelContT :: Monad m => AlgModel (ContOp (m r)) (ContT r m)
callccX :: Monad m => AlgModel (ContOp r) m -> ((a -> m b) -> m a) -> m a
callCCX :: Monad m => AlgModel (ContOp r) m -> ((a -> r) -> a) -> m a
abortX :: Monad m => AlgModel (ContOp r) m -> r -> m a
newtype StepOp f x
StepOp :: (f x) -> StepOp f x
stepX :: Monad m => Model (StepOp f) m -> f (m x) -> m x
modelStepT :: (Functor f, Monad m) => Model (StepOp f) (StepT f m)
data ListOp a
ZeroList :: ListOp a
PlusList :: a -> a -> ListOp a
modelListT :: Monad m => AlgModel ListOp (ListT m)
zeroListX :: Monad m => AlgModel ListOp m -> m a
plusListX :: Monad m => AlgModel ListOp m -> m a -> m a -> m a
instance Functor ListOp
instance Functor f => Functor (StepOp f)
instance Functor (ContOp r)
instance Functor (WriterOp w)
instance Functor (HandleOp x)
instance Functor (ThrowOp x)
instance Functor (ReaderOp s)
instance Functor (StateOp s)

module Control.Monatron.AutoLift
class Monad m => StateM z m | m -> z
stateModel :: StateM z m => AlgModel (StateOp z) m
get :: StateM z m => m z
put :: StateM z m => z -> m ()
class (Monoid z, Monad m) => WriterM z m | m -> z
writerModel :: WriterM z m => AlgModel (WriterOp z) m
tell :: (Monoid z, WriterM z m) => z -> m ()
class Monad m => ReaderM z m | m -> z
readerModel :: ReaderM z m => Model (ReaderOp z) m
ask :: ReaderM z m => m z
local :: ReaderM z m => (z -> z) -> m a -> m a
class Monad m => ExcM z m | m -> z
throwModel :: ExcM z m => AlgModel (ThrowOp z) m
handleModel :: ExcM z m => Model (HandleOp z) m
throw :: ExcM z m => z -> m a
handle :: ExcM z m => m a -> (z -> m a) -> m a
class Monad m => ContM r m | m -> r
contModel :: ContM r m => AlgModel (ContOp r) m
callCC :: ContM r m => ((a -> r) -> a) -> m a
class Monad m => ListM m
listModel :: ListM m => AlgModel ListOp m
mZero :: ListM m => m a
mPlus :: ListM m => m a -> m a -> m a
instance [overlap ok] (ListM m, MonadT t) => ListM (t m)
instance [overlap ok] Monad m => ListM (ListT m)
instance [overlap ok] (ContM r m, MonadT t) => ContM r (t m)
instance [overlap ok] Monad m => ContM (m r) (ContT r m)
instance [overlap ok] (ExcM z m, Functor m, FMonadT t) => ExcM z (t m)
instance [overlap ok] ExcM SomeException IO
instance [overlap ok] Monad m => ExcM z (ExcT z m)
instance [overlap ok] (ReaderM z m, Functor m, FMonadT t) => ReaderM z (t m)
instance [overlap ok] Monad m => ReaderM z (ReaderT z m)
instance [overlap ok] (Monoid z, WriterM z m, MonadT t) => WriterM z (t m)
instance [overlap ok] (Monoid z, Monad m) => WriterM z (WriterT z m)
instance [overlap ok] (StateM z m, MonadT t) => StateM z (t m)
instance [overlap ok] Monad m => StateM z (StateT z m)

module Control.Monatron.Monatron
version :: (Int, Int, Int)

module Control.Monatron.IdT
newtype IdT m a
IdT :: m a -> IdT m a
runIdT :: IdT m a -> m a
instance FMonadT IdT
instance MonadT IdT

module Control.Monatron.Open
data (:+:) f g a
Inl :: (f a) -> :+: f g a
Inr :: (g a) -> :+: f g a
newtype Fix f
In :: f (Fix f) -> Fix f
out :: Fix f -> f (Fix f)
type Open e f r = (e -> r) -> (f e -> r)
(<@>) :: Open e f r -> Open e g r -> Open e (f :+: g) r
fix :: Open (Fix f) f r -> (Fix f -> r)
class :<: f g
inj :: :<: f g => f a -> g a
inject :: :<: f g => f (Fix g) -> Fix g
foldFix :: Functor f => (f a -> a) -> Fix f -> a
instance [overlap ok] (Functor f, Functor g) => Functor (f :+: g)
instance [overlap ok] (Functor g, Functor h, Functor f, f :<: g) => f :<: (h :+: g)
instance [overlap ok] (Functor g, Functor f) => f :<: (f :+: g)
instance [overlap ok] Functor f => f :<: f

module Control.Monatron.Zipper
newtype (:>) t1 t2 :: ((* -> *) -> * -> *) m a
L :: t1 (t2 m) a -> :> t1 m a
runL :: :> t1 m a -> t1 (t2 m) a
runZipper :: (t1 :> t2) m a -> t1 (t2 m) a
zipper :: t1 (t2 m) a -> (t1 :> t2) m a

-- | shift focus to left
leftL :: (t1 :> t2) m a -> t1 (t2 m) a

-- | shift focus to right
rightL :: t1 (t2 m) a -> (t1 :> t2) m a
data (:><:) m n
View :: (forall a. m a -> n a) -> (forall a. n a -> m a) -> :><: m n
to :: :><: m n -> forall a. m a -> n a
from :: :><: m n -> forall a. n a -> m a
i :: m :><: m
o :: (Monad m, MonadT t1, MonadT t2) => t1 (t2 m) :><: (t1 :> t2) m
vlift :: (FMonadT t, Functor m, Functor n) => (m :><: n) -> (t m :><: t n)
hcomp :: (n :><: o) -> (m :><: n) -> (m :><: o)
vcomp :: (Functor m1, Functor m2, FMonadT t) => (t m2 :><: m3) -> (m1 :><: m2) -> (t m1 :><: m3)
r :: Monad m => StateT s m :><: ReaderT s m
stateIso :: Monad m => (s1 -> s2) -> (s2 -> s1) -> StateT s1 m :><: StateT s2 m
getv :: StateM s n => (m :><: n) -> m s
putv :: StateM s n => (m :><: n) -> s -> m ()
instance [overlap ok] (ListM (t2 m), FMonadT t1, FMonadT t2, Functor (t2 m), Monad m) => ListM ((:>) t1 t2 m)
instance [overlap ok] (ContM r (t2 m), FMonadT t1, FMonadT t2, Functor (t2 m), Monad m) => ContM r ((:>) t1 t2 m)
instance [overlap ok] (ExcM z (t2 m), FMonadT t1, FMonadT t2, Functor (t2 m), Monad m) => ExcM z ((:>) t1 t2 m)
instance [overlap ok] (ReaderM z (t2 m), FMonadT t1, FMonadT t2, Functor (t2 m), Monad m) => ReaderM z ((:>) t1 t2 m)
instance [overlap ok] (WriterM z (t2 m), MonadT t1, Monad m, MonadT t2) => WriterM z ((:>) t1 t2 m)
instance [overlap ok] (Monad m, MonadT t1, MonadT t2, StateM z (t2 m)) => StateM z ((:>) t1 t2 m)
instance [overlap ok] (MonadT t1, MonadT t2) => MonadT (t1 :> t2)
instance [overlap ok] (FMonadT t1, FMonadT t2) => FMonadT (t1 :> t2)

module Control.Monatron.ZipperExamples
fmask :: (m :><: n) -> Open e f (n a) -> Open e f (m a)
type Env = [(String, Int)]
type Count = Int
data Mem e
Store :: e -> Mem e
Retrieve :: Mem e
type Reg = Int
evalMem2 :: (StateM Reg (t m), StateM Count m, MonadT t) => Open e Mem (t m Int)
type M4 = StateT Reg (StateT Env (ExcT String (StateT Count Id)))
data Lit a
Lit :: Int -> Lit a
data Var a
Var :: String -> Var a
data Add e
Add :: e -> e -> Add e
lit :: :<: Lit g => Int -> Fix g
var :: :<: Var g => String -> Fix g
add :: :<: Add g => Fix g -> Fix g -> Fix g
store :: :<: Mem g => Fix g -> Fix g
retrieve :: :<: Mem g => Fix g
type Expr3 = Fix (Mem :+: (Var :+: Lit))
eval4 :: Expr3 -> M4 Int
handleExc :: Monad m => ExcT a m b -> m b
instance Functor Mem
instance Functor Add
instance Functor Var
instance Functor Lit
