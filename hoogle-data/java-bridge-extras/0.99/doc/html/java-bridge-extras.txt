-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for working with the java-bridge package.
--   
--   Utilities for working with the java-bridge package.
@package java-bridge-extras
@version 0.99


-- | Every java methods returns in priniciple either Nothing or Just a
--   value. This is quite cumbersome to work with. This module contains
--   utility functions for working with Maybe values in the java monad.
--   
--   This module offers the orphan instance (!)
--   
--   <pre>
--   instance JavaObject a =&gt; JavaObject (Maybe a)
--   </pre>
--   
--   This instance allows you to apply <a>toString</a> and the like without
--   unwrapping a <a>Maybe</a> value.
--   
--   Note that the <a>asObject</a> function provided by this instance is
--   undefined (since <tt>null</tt> is not an object). This is also the
--   reason why this instance is not included in <a>Foreign.Java</a> by
--   default. Invoking it will call <tt>error
--   <a>NullPointerException</a></tt>. In other words: This fine module
--   will bring back all the joy of Java you might miss in Haskell :-)
--   
--   <a>toString</a> will return <tt>null</tt> for <tt>Nothing</tt>.
--   
--   <a>hashCode</a> will return <tt>0</tt> for <tt>Nothing</tt>.
--   
--   <a>classOf</a> will return the class for <tt>java.lang.Void</tt> on
--   <tt>Nothing</tt>, as this is a class for which there gare no object
--   instances. This is only a stopgap and slightly incorrect, as null is
--   not an object, and does therefor not have a class.
module Foreign.Java.Maybe
instance JavaObject a => JavaObject (Maybe a)


-- | Utilities to ease IO operations in the Java monad.
module Foreign.Java.IO
class PrintLn a
println :: (PrintLn a, MonadIO m) => a -> m ()
print :: (PrintLn a, MonadIO m) => a -> m ()
instance [overlap ok] Show a => PrintLn a
instance [overlap ok] PrintLn String


-- | Utilities for controlling actions inside the Java monad.
module Foreign.Java.Control

-- | Execute an action if the given predicate evaluates to <a>True</a>.
when :: Monad m => m Bool -> m () -> m ()

-- | Execute an action if the given predicate evaluates to <a>False</a>.
unless :: Monad m => m Bool -> m () -> m ()

-- | Execute either the first or the second action, depending on whether
--   the given predicate evaluates to <a>True</a> or <a>False</a>.
whether :: Monad m => m Bool -> m a -> m a -> m a

-- | Run a computation as long as the given predicate evaluates to
--   <a>True</a>.
while :: Monad m => m Bool -> m () -> m ()

-- | Reiterate a computation on a given value as long as a condition is
--   <a>True</a>.
for :: Monad m => a -> (a -> m Bool) -> (a -> m a) -> m a

-- | Reiterate a computation on a given value until a condition is
--   <a>True</a>.
until :: Monad m => a -> (a -> m (Bool, a)) -> m a
