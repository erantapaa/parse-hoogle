-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A graphical viewer for Hood
--   
--   GHood is a graphical back-end for Hood, the front-end (the Haskell
--   interface) is precisely that of Hood. If you have been using Hood
--   already you won't have to change your programs to switch to GHood. If
--   you haven't used Hood before, you can employ all the nice definitions
--   in Hood's Observe library, just as explained in the Hood documentation
--   (see the Hood homepage at <a>http://www.haskell.org/hood/</a>).
@package GHood
@version 0.0.4


-- | GHood: A graphical viewer for Hood
--   
--   Created a cabal library package. Improved the search for the GHood.jar
--   file, that is bundled with the library. Changed from Literate Haskell
--   to plain Haskell for better haddock documentation support.
--   
--   Hugo Pacheco, November 2008
--   
--   Added ObserveM. Adapted imports to use GHC's hierarchical libraries.
--   
--   Alcino Cunha, February 2004
--   
--   Modified version of Hood/Observe.lhs to match GHood, the Graphical
--   Haskell Object Observation Debugger, which is distributed as a Java
--   class file archive GHood.jar. [Apart from two new hooks, modifications
--   are at the end]
--   
--   Claus Reinke, December 2000
--   
--   The file is part of the Haskell Object Observation Debugger, (HOOD)
--   July 2000 release. Actually this is all of this version of HOOD, apart
--   from the documentation and examples...
--   
--   HOOD is a small post-mortem debugger for the lazy functional language
--   Haskell. It is based on the concept of observation of intermediate
--   data structures, rather than the more traditional stepping and
--   variable examination paradigm used by imperative language debuggers.
--   
--   Copyright (c) Andy Gill, 1992-2000
module Debug.Observe

-- | Our principle function and class
observe :: Observable a => String -> a -> a

-- | Contains a <tt>forall</tt> typed observe (if supported).
newtype Observer
O :: (forall a. Observable a => String -> a -> a) -> Observer
type Observing a = a -> a
class Observable a
observer :: Observable a => a -> Parent -> a
observers :: Observable a => String -> (Observer -> a) -> a

-- | Runs observe ridden code.
runO :: IO a -> IO ()

-- | Runs and prints observe ridden code.
printO :: Show a => a -> IO ()

-- | Prints a string during observation.
putStrO :: String -> IO ()

-- | A simple state monad for placing numbers on sub-observations.
newtype ObserverM a
ObserverM :: (Int -> Int -> (a, Int)) -> ObserverM a
runMO :: ObserverM a -> Int -> Int -> (a, Int)

-- | the infix (&lt;&lt;) is a shortcut for constructor arguments.
(<<) :: Observable a => ObserverM (a -> b) -> a -> ObserverM b

-- | thunk is for marking suspensions.
thunk :: Observable a => a -> ObserverM a

-- | Sends a packet to the observation agent.
send :: String -> ObserverM a -> Parent -> a

-- | Observe a base type
--   
--   The strictness (by using seq) is the same as the pattern matching done
--   on other constructors. We evaluate to WHNF, and not further.
observeBase :: Show a => a -> Parent -> a

-- | Observe a base type as an <tt>opaque</tt> string.
observeOpaque :: String -> a -> Parent -> a

-- | Parent book-keeping information.
data Parent
Parent :: !Int -> !Int -> Parent

-- | my parent
observeParent :: Parent -> !Int

-- | my branch number
observePort :: Parent -> !Int

-- | Debugs observe ridden code.
debugO :: IO a -> IO [CDS]
data CDS
CDSNamed :: String -> CDSSet -> CDS
CDSCons :: Int -> String -> [CDSSet] -> CDS
CDSFun :: Int -> CDSSet -> CDSSet -> CDS
CDSEntered :: Int -> CDS
type CDSSet = [CDS]
instance Show Parent
instance Show Change
instance Show Event
instance Show CDS
instance Eq CDS
instance Ord CDS
instance Eq Output
instance Ord Output
instance Eq DOC
instance Show DOC
instance Show Doc
instance Eq Doc
instance Monad ObserverM
instance (Observable a, Observable b) => Observable (a -> b)
instance Observable IOError
instance Observable a => Observable (IO a)
instance (Ix a, Observable a, Observable b) => Observable (Array a b)
instance (Observable a, Observable b) => Observable (Either a b)
instance Observable a => Observable (Maybe a)
instance Observable a => Observable [a]
instance (Observable a, Observable b, Observable c, Observable d, Observable e) => Observable (a, b, c, d, e)
instance (Observable a, Observable b, Observable c, Observable d) => Observable (a, b, c, d)
instance (Observable a, Observable b, Observable c) => Observable (a, b, c)
instance (Observable a, Observable b) => Observable (a, b)
instance Observable ()
instance Observable Char
instance Observable Double
instance Observable Float
instance Observable Integer
instance Observable Bool
instance Observable Int
