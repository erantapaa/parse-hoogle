-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lens Families
--   
@package lens-family
@version 1.2.0


-- | <i>Caution</i>: Improper use of this module can lead to unexpected
--   behaviour if the preconditions of the functions are not met.
module Lens.Family2.Unchecked

-- | Build a lens from a <tt>getter</tt> and <tt>setter</tt> families.
--   
--   <i>Caution</i>: In order for the generated lens family to be
--   well-defined, you must ensure that the three lens laws hold:
--   
--   <ul>
--   <li><pre>getter (setter a b) === b</pre></li>
--   <li><pre>setter a (getter a) === a</pre></li>
--   <li><pre>setter (setter a b1) b2) === setter a b2</pre></li>
--   </ul>
lens :: (a -> b) -> (a -> b' -> a') -> Lens a a' b b'

-- | Build a lens from isomorphism families.
--   
--   <i>Caution</i>: In order for the generated lens family to be
--   well-defined, you must ensure that the two isomorphism laws hold:
--   
--   <ul>
--   <li><pre>yin . yang === id</pre></li>
--   <li><pre>yang . yin === id</pre></li>
--   </ul>
iso :: (a -> b) -> (b' -> a') -> Lens a a' b b'

-- | <a>setting</a> promotes a "semantic editor combinator" to a
--   modify-only lens. To demote a lens to a semantic edit combinator, use
--   the section <tt>(l %~)</tt> or <tt>over l</tt> from
--   <a>Lens.Family2</a>.
--   
--   <pre>
--   &gt;&gt;&gt; setting map . fstL %~ length $ [("The",0),("quick",1),("brown",1),("fox",2)]
--   [(3,0),(5,1),(5,1),(3,2)]
--   </pre>
--   
--   <i>Caution</i>: In order for the generated setter family to be
--   well-defined, you must ensure that the two functors laws hold:
--   
--   <ul>
--   <li><pre>sec id === id</pre></li>
--   <li><pre>sec f . sec g === sec (f . g)</pre></li>
--   </ul>
setting :: ((b -> b') -> a -> a') -> Setter a a' b b'
type Lens a a' b b' = forall f. Functor f => LensLike f a a' b b'
type Lens' a b = forall f. Functor f => LensLike' f a b
type Traversal a a' b b' = forall f. Applicative f => LensLike f a a' b b'
type Traversal' a b = forall f. Applicative f => LensLike' f a b
type Setter a a' b b' = forall f. Identical f => LensLike f a a' b b'
type Setter' a b = forall f. Identical f => LensLike' f a b
type LensLike (f :: * -> *) a a' b b' = (b -> f b') -> a -> f a'
type LensLike' (f :: * -> *) a b = (b -> f b) -> a -> f a
class Applicative f => Identical (f :: * -> *)

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results
--   (<a>&lt;*&gt;</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of these
--   functions satisfying the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = <a>pure</a> (<a>const</a> <a>id</a>)
--   <a>&lt;*&gt;</a> u <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>pure</a> <a>const</a> <a>&lt;*&gt;</a>
--   u <a>&lt;*&gt;</a> v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: * -> *)


-- | This is the main module for end-users of lens-families. If you are not
--   building your own lenses or traversals, but just using functional
--   references made by others, this is the only module you need.
module Lens.Family2

-- | <a>to</a> promotes a projection function to a read-only lens called a
--   getter. To demote a lens to a projection function, use the section
--   <tt>(^.l)</tt> or <tt>view l</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (3 :+ 4, "example")^._1.to(abs)
--   5.0 :+ 0.0
--   </pre>
to :: (a -> b) -> Getter a a' b b'

-- | <pre>
--   view :: Getter a a' b b' -&gt; a -&gt; b
--   </pre>
--   
--   Demote a lens or getter to a projection function.
--   
--   <pre>
--   view :: Monoid b =&gt; Fold a a' b b' -&gt; a -&gt; b
--   </pre>
--   
--   Returns the monoidal summary of a traversal or a fold.
view :: FoldLike b a a' b b' -> a -> b

-- | <pre>
--   (^.) :: a -&gt; Getter a a' b b' -&gt; b
--   </pre>
--   
--   Access the value referenced by a getter or lens.
--   
--   <pre>
--   (^.) :: Monoid b =&gt; a -&gt; Fold a a' b b' -&gt; b
--   </pre>
--   
--   Access the monoidal summary referenced by a getter or lens.
(^.) :: a -> FoldLike b a a' b b' -> b

-- | <a>folding</a> promotes a "toList" function to a read-only traversal
--   called a fold.
--   
--   To demote a traversal or fold to a "toList" function use the section
--   <tt>(^..l)</tt> or <tt>toListOf l</tt>.
folding :: Foldable f => (a -> f b) -> Fold a a' b b'

-- | <pre>
--   views :: Monoid r =&gt; Fold a a' b b' -&gt; (b -&gt; r) -&gt; a -&gt; r
--   </pre>
--   
--   Given a fold or traversal, return the <tt>foldMap</tt> of all the
--   values using the given function.
--   
--   <pre>
--   views :: Getter a a' b b' -&gt; (b -&gt; r) -&gt; a -&gt; r
--   </pre>
--   
--   <a>views</a> is not particularly useful for getters or lenses, but
--   given a getter or lens, it returns the referenced value passed through
--   the given function.
--   
--   <pre>
--   views l f a = f (view l a)
--   </pre>
views :: FoldLike r a a' b b' -> (b -> r) -> a -> r

-- | Returns a list of all of the referenced values in order.
(^..) :: a -> Fold a a' b b' -> [b]

-- | Returns <a>Just</a> the first referenced value. Returns <a>Nothing</a>
--   if there are no referenced values.
(^?) :: a -> Fold a a' b b' -> Maybe b

-- | Returns a list of all of the referenced values in order.
toListOf :: Fold a a' b b' -> a -> [b]

-- | Returns true if all of the referenced values satisfy the given
--   predicate.
allOf :: Fold a a' b b' -> (b -> Bool) -> a -> Bool

-- | Returns true if any of the referenced values satisfy the given
--   predicate.
anyOf :: Fold a a' b b' -> (b -> Bool) -> a -> Bool

-- | Returns <a>Just</a> the first referenced value. Returns <a>Nothing</a>
--   if there are no referenced values. See <a>^?</a> for an infix version
--   of <a>firstOf</a>
firstOf :: Fold a a' b b' -> a -> Maybe b

-- | Returns <a>Just</a> the last referenced value. Returns <a>Nothing</a>
--   if there are no referenced values.
lastOf :: Fold a a' b b' -> a -> Maybe b

-- | Returns the sum of all the referenced values.
sumOf :: Num b => Fold a a' b b' -> a -> b

-- | Returns the product of all the referenced values.
productOf :: Num b => Fold a a' b b' -> a -> b

-- | Counts the number of references in a traversal or fold for the input.
lengthOf :: Num r => Fold a a' b b' -> a -> r

-- | Returns true if the number of references in the input is zero.
nullOf :: Fold a a' b b' -> a -> Bool

-- | <pre>
--   backwards :: Traversal a a' b b' -&gt; Traversal a a' b b'
--   backwards :: Fold a a' b b' -&gt; Fold a a' b b'
--   </pre>
--   
--   Given a traversal or fold, reverse the order that elements are
--   traversed.
--   
--   <pre>
--   backwards :: Lens a a' b b' -&gt; Lens a a' b b'
--   backwards :: Getter a a' b b' -&gt; Getter a a' b b'
--   backwards :: Setter a a' b b' -&gt; Setter a a' b b'
--   </pre>
--   
--   No effect on lenses, getters or setters.
backwards :: LensLike (Backwards f) a a' b b' -> LensLike f a a' b b'

-- | Demote a setter to a semantic editor combinator.
over :: Setter a a' b b' -> (b -> b') -> a -> a'

-- | Modify all referenced fields.
(%~) :: Setter a a' b b' -> (b -> b') -> a -> a'

-- | Set all referenced fields to the given value.
set :: Setter a a' b b' -> b' -> a -> a'

-- | Set all referenced fields to the given value.
(.~) :: Setter a a' b b' -> b' -> a -> a'

-- | A flipped version of <tt>($)</tt>.
(&) :: a -> (a -> b) -> b
(+~) :: Num b => Setter' a b -> b -> a -> a
(*~) :: Num b => Setter' a b -> b -> a -> a
(-~) :: Num b => Setter' a b -> b -> a -> a
(//~) :: Fractional b => Setter' a b -> b -> a -> a
(&&~) :: Setter' a Bool -> Bool -> a -> a
(||~) :: Setter' a Bool -> Bool -> a -> a

-- | Monoidally append a value to all referenced fields.
(<>~) :: Monoid o => Setter' a o -> o -> a -> a
type Lens a a' b b' = forall f. Functor f => LensLike f a a' b b'
type Lens' a b = forall f. Functor f => LensLike' f a b
type Traversal a a' b b' = forall f. Applicative f => LensLike f a a' b b'
type Traversal' a b = forall f. Applicative f => LensLike' f a b
type Setter a a' b b' = forall f. Identical f => LensLike f a a' b b'
type Setter' a b = forall f. Identical f => LensLike' f a b
type Getter a a' b b' = forall f. Phantom f => LensLike f a a' b b'
type Getter' a b = forall f. Phantom f => LensLike' f a b
type Fold a a' b b' = forall f. (Phantom f, Applicative f) => LensLike f a a' b b'
type Fold' a b = forall f. (Phantom f, Applicative f) => LensLike' f a b
type LensLike (f :: * -> *) a a' b b' = (b -> f b') -> a -> f a'
type LensLike' (f :: * -> *) a b = (b -> f b) -> a -> f a
type FoldLike r a a' b b' = LensLike (Constant r) a a' b b'
type FoldLike' r a b = LensLike' (Constant r) a b

-- | Constant functor.
data Constant a b :: * -> * -> *
class Functor f => Phantom (f :: * -> *)
class Applicative f => Identical (f :: * -> *)

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results
--   (<a>&lt;*&gt;</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of these
--   functions satisfying the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = <a>pure</a> (<a>const</a> <a>id</a>)
--   <a>&lt;*&gt;</a> u <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>pure</a> <a>const</a> <a>&lt;*&gt;</a>
--   u <a>&lt;*&gt;</a> v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: * -> *)

-- | Data structures that can be folded.
--   
--   Minimal complete definition: <a>foldMap</a> or <a>foldr</a>.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
class Foldable (t :: * -> *)

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a

-- | The same functor, but with an <a>Applicative</a> instance that
--   performs actions in the reverse order.
data Backwards (f :: * -> *) a :: (* -> *) -> * -> *


-- | This module contains lenses and traversals for common structures in
--   Haskell. It also contains the combinators for lenses and traversals.
module Lens.Family2.Stock

-- | <pre>
--   choosing :: Lens a a' c c' -&gt; Lens b b' c c' -&gt; Lens (Either a b) (Either a' b') c c'
--   </pre>
--   
--   <pre>
--   choosing :: Traversal a a' c c' -&gt; Traversal b b' c c' -&gt; Traversal (Either a b) (Either a' b') c c'
--   </pre>
--   
--   <pre>
--   choosing :: Getter a a' c c' -&gt; Getter b b' c c' -&gt; Getter (Either a b) (Either a' b') c c'
--   </pre>
--   
--   <pre>
--   choosing :: Fold a a' c c' -&gt; Fold b b' c c' -&gt; Fold (Either a b) (Either a' b') c c'
--   </pre>
--   
--   <pre>
--   choosing :: Setter a a' c c' -&gt; Setter b b' c c' -&gt; Setter (Either a b) (Either a' b') c c'
--   </pre>
--   
--   Given two lens/traversal/getter/fold/setter families with the same
--   substructure, make a new lens/traversal/getter/fold/setter on
--   <a>Either</a>.
choosing :: Functor f => LensLike f a a' c c' -> LensLike f b b' c c' -> LensLike f (Either a b) (Either a' b') c c'

-- | <pre>
--   alongside :: Lens a1 a1' b1 b1' -&gt; Lens a2 a2' b2 b2' -&gt; Lens (a1, a2) (a1', a2') (b1, b2) (b1', b2')
--   </pre>
--   
--   <pre>
--   alongside :: Getter a1 a1' b1 b1' -&gt; Getter a2 a2' b2 b2' -&gt; Getter (a1, a2) (a1', a2') (b1, b2) (b1', b2')
--   </pre>
--   
--   Given two lens/getter families, make a new lens/getter on their
--   product.
alongside :: Functor f => LensLike (AlongsideLeft f b2') a1 a1' b1 b1' -> LensLike (AlongsideRight f a1') a2 a2' b2 b2' -> LensLike f (a1, a2) (a1', a2') (b1, b2) (b1', b2')

-- | <pre>
--   beside :: Traversal a a' c c' -&gt; Traversal b' b' c c' -&gt; Traversal (a,b) (a',b') c c'
--   </pre>
--   
--   <pre>
--   beside :: Fold a a' c c' -&gt; Fold b' b' c c' -&gt; Fold (a,b) (a',b') c c'
--   </pre>
--   
--   <pre>
--   beside :: Setter a a' c c' -&gt; Setter b' b' c c' -&gt; Setter (a,b) (a',b') c c'
--   </pre>
--   
--   Given two traversals/folds/setters referencing a type <tt>c</tt>,
--   create a traversal/fold/setter on the pair referencing <tt>c</tt>.
beside :: Applicative f => LensLike f a a' c c' -> LensLike f b b' c c' -> LensLike f (a, b) (a', b') c c'

-- | Lens on the first element of a pair.
_1 :: Lens (a, b) (a', b) a a'

-- | Lens on the second element of a pair.
_2 :: Lens (a, b) (a, b') b b'

-- | Lens on the Left or Right element of an (<a>Either</a> a a).
chosen :: Lens (Either a a) (Either b b) a b

-- | Lens on a given point of a function.
ix :: Eq k => k -> Lens' (k -> v) v

-- | Lens on a given point of a <a>Map</a>.
at :: Ord k => k -> Lens' (Map k v) (Maybe v)

-- | Lens on a given point of a <a>IntMap</a>.
intAt :: Int -> Lens' (IntMap v) (Maybe v)

-- | Lens on a given point of a <a>Set</a>.
contains :: Ord k => k -> Lens' (Set k) Bool

-- | Lens on a given point of a <a>IntSet</a>.
intContains :: Int -> Lens' IntSet Bool

-- | Traversals on both elements of a pair <tt>(a,a)</tt>.
both :: Traversal (a, a) (b, b) a b

-- | Traversal on the <a>Left</a> element of an <a>Either</a>.
_Left :: Traversal (Either a b) (Either a' b) a a'

-- | Traversal on the <a>Right</a> element of an <a>Either</a>.
_Right :: Traversal (Either a b) (Either a b') b b'

-- | Traversal on the <a>Just</a> element of a <a>Maybe</a>.
_Just :: Traversal (Maybe a) (Maybe a') a a'

-- | Traversal on the <a>Nothing</a> element of a <a>Maybe</a>.
_Nothing :: Traversal' (Maybe a) ()

-- | The empty traveral on any type.
ignored :: Traversal a a b b'

-- | An SEC referencing the parameter of a functor.
mapped :: Functor f => Setter (f a) (f a') a a'
data AlongsideLeft (f :: * -> *) b a :: (* -> *) -> * -> * -> *
data AlongsideRight (f :: * -> *) a b :: (* -> *) -> * -> * -> *
type Lens a a' b b' = forall f. Functor f => LensLike f a a' b b'
type Lens' a b = forall f. Functor f => LensLike' f a b
type Traversal a a' b b' = forall f. Applicative f => LensLike f a a' b b'
type Traversal' a b = forall f. Applicative f => LensLike' f a b
type Setter a a' b b' = forall f. Identical f => LensLike f a a' b b'
type LensLike (f :: * -> *) a a' b b' = (b -> f b') -> a -> f a'
type LensLike' (f :: * -> *) a b = (b -> f b) -> a -> f a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results
--   (<a>&lt;*&gt;</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of these
--   functions satisfying the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = <a>pure</a> (<a>const</a> <a>id</a>)
--   <a>&lt;*&gt;</a> u <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>pure</a> <a>const</a> <a>&lt;*&gt;</a>
--   u <a>&lt;*&gt;</a> v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: * -> *)
class Applicative f => Identical (f :: * -> *)


-- | Lenses allow you to use fields of the state of a state monad as if
--   they were variables in an imperative language. <a>use</a> is used to
--   retrieve the value of a variable, and <a>.=</a> and <a>%=</a> allow
--   you to set and modify a variable. C-style compound assignments are
--   also provided.
module Lens.Family2.State.Lazy

-- | <pre>
--   zoom :: Monad m =&gt; Lens' a b -&gt; StateT b m c -&gt; StateT a m c
--   </pre>
--   
--   Lift a stateful operation on a field to a stateful operation on the
--   whole state. This is a good way to call a "subroutine" that only needs
--   access to part of the state.
--   
--   <pre>
--   zoom :: (Monoid c, Moand m) =&gt; Traversal' a b -&gt; StateT b m c -&gt; StateT a m c
--   </pre>
--   
--   Run the "subroutine" on each element of the traversal in turn and
--   <tt>mconcat</tt> all the results together.
--   
--   <pre>
--   zoom :: Monad m =&gt; Traversal' a b -&gt; StateT b m () -&gt; StateT a m ()
--   </pre>
--   
--   Run the "subroutine" on each element the traversal in turn.
zoom :: Monad m => LensLike' (Zooming m c) a b -> StateT b m c -> StateT a m c

-- | <pre>
--   use :: MonadState a m =&gt; Getter a a' b b' -&gt; m b
--   </pre>
--   
--   Retrieve a field of the state
--   
--   <pre>
--   use :: (Monoid b, MonadState a m) =&gt; Fold a a' b b' -&gt; m b
--   </pre>
--   
--   Retrieve a monoidal summary of all the referenced fields from the
--   state
use :: MonadState a m => FoldLike b a a' b b' -> m b

-- | <pre>
--   uses :: (MonadState a m, Monoid r) =&gt; Fold a a' b b' -&gt; (b -&gt; r) -&gt; m r
--   </pre>
--   
--   Retrieve all the referenced fields from the state and foldMap the
--   results together with <tt>f :: b -&gt; r</tt>.
--   
--   <pre>
--   uses :: MonadState a m =&gt; Getter a a' b b' -&gt; (b -&gt; r) -&gt; m r
--   </pre>
--   
--   Retrieve a field of the state and pass it through the function <tt>f
--   :: b -&gt; r</tt>.
--   
--   <pre>
--   uses l f = f &lt;$&gt; use l
--   </pre>
uses :: MonadState a m => FoldLike r a a' b b' -> (b -> r) -> m r

-- | Modify a field of the state.
(%=) :: MonadState a m => Setter a a b b' -> (b -> b') -> m ()

-- | Set a field of the state.
assign :: MonadState a m => Setter a a b b' -> b' -> m ()

-- | Set a field of the state.
(.=) :: MonadState a m => Setter a a b b' -> b' -> m ()

-- | <pre>
--   (%%=) :: MonadState a m =&gt; Lens a a b b' -&gt; (b -&gt; (c, b')) -&gt; m c
--   </pre>
--   
--   Modify a field of the state while returning another value.
--   
--   <pre>
--   (%%=) :: (MonadState a m, Monoid c) =&gt; Traversal a a b b' -&gt; (b -&gt; (c, b')) -&gt; m c
--   </pre>
--   
--   Modify each field of the state and return the <tt>mconcat</tt> of the
--   other values.
(%%=) :: MonadState a m => LensLike (Writer c) a a b b' -> (b -> (c, b')) -> m c

-- | Set a field of the state using the result of executing a stateful
--   command.
(<~) :: MonadState a m => Setter a a b b' -> m b' -> m ()
(+=) :: (MonadState a m, Num b) => Setter' a b -> b -> m ()
(-=) :: (MonadState a m, Num b) => Setter' a b -> b -> m ()
(*=) :: (MonadState a m, Num b) => Setter' a b -> b -> m ()
(//=) :: (MonadState a m, Fractional b) => Setter' a b -> b -> m ()
(&&=) :: MonadState a m => Setter' a Bool -> Bool -> m ()
(||=) :: MonadState a m => Setter' a Bool -> Bool -> m ()

-- | Monoidally append a value to all referenced fields of the state.
(<>=) :: (Monoid o, MonadState a m) => Setter' a o -> o -> m ()
data Zooming (m :: * -> *) c a :: (* -> *) -> * -> * -> *
type LensLike (f :: * -> *) a a' b b' = (b -> f b') -> a -> f a'
type LensLike' (f :: * -> *) a b = (b -> f b) -> a -> f a
type FoldLike r a a' b b' = LensLike (Constant r) a a' b b'

-- | Constant functor.
data Constant a b :: * -> * -> *
type Setter a a' b b' = forall f. Identical f => LensLike f a a' b b'
type Setter' a b = forall f. Identical f => LensLike' f a b
class Applicative f => Identical (f :: * -> *)

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data StateT s (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: * -> *) | m -> s

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a

module Lens.Family2.State


-- | Lenses allow you to use fields of the state of a state monad as if
--   they were variables in an imperative language. <a>use</a> is used to
--   retrieve the value of a variable, and <a>.=</a> and <a>%=</a> allow
--   you to set and modify a variable. C-style compound assignments are
--   also provided.
module Lens.Family2.State.Strict

-- | <pre>
--   zoom :: Monad m =&gt; Lens' a b -&gt; StateT b m c -&gt; StateT a m c
--   </pre>
--   
--   Lift a stateful operation on a field to a stateful operation on the
--   whole state. This is a good way to call a "subroutine" that only needs
--   access to part of the state.
--   
--   <pre>
--   zoom :: (Monoid c, Moand m) =&gt; Traversal' a b -&gt; StateT b m c -&gt; StateT a m c
--   </pre>
--   
--   Run the "subroutine" on each element of the traversal in turn and
--   <tt>mconcat</tt> all the results together.
--   
--   <pre>
--   zoom :: Monad m =&gt; Traversal' a b -&gt; StateT b m () -&gt; StateT a m ()
--   </pre>
--   
--   Run the "subroutine" on each element the traversal in turn.
zoom :: Monad m => LensLike' (Zooming m c) a b -> StateT b m c -> StateT a m c

-- | <pre>
--   use :: MonadState a m =&gt; Getter a a' b b' -&gt; m b
--   </pre>
--   
--   Retrieve a field of the state
--   
--   <pre>
--   use :: (Monoid b, MonadState a m) =&gt; Fold a a' b b' -&gt; m b
--   </pre>
--   
--   Retrieve a monoidal summary of all the referenced fields from the
--   state
use :: MonadState a m => FoldLike b a a' b b' -> m b

-- | <pre>
--   uses :: (MonadState a m, Monoid r) =&gt; Fold a a' b b' -&gt; (b -&gt; r) -&gt; m r
--   </pre>
--   
--   Retrieve all the referenced fields from the state and foldMap the
--   results together with <tt>f :: b -&gt; r</tt>.
--   
--   <pre>
--   uses :: MonadState a m =&gt; Getter a a' b b' -&gt; (b -&gt; r) -&gt; m r
--   </pre>
--   
--   Retrieve a field of the state and pass it through the function <tt>f
--   :: b -&gt; r</tt>.
--   
--   <pre>
--   uses l f = f &lt;$&gt; use l
--   </pre>
uses :: MonadState a m => FoldLike r a a' b b' -> (b -> r) -> m r

-- | Modify a field of the state.
(%=) :: MonadState a m => Setter a a b b' -> (b -> b') -> m ()

-- | Set a field of the state.
assign :: MonadState a m => Setter a a b b' -> b' -> m ()

-- | Set a field of the state.
(.=) :: MonadState a m => Setter a a b b' -> b' -> m ()

-- | <pre>
--   (%%=) :: MonadState a m =&gt; Lens a a b b' -&gt; (b -&gt; (c, b')) -&gt; m c
--   </pre>
--   
--   Modify a field of the state while returning another value.
--   
--   <pre>
--   (%%=) :: (MonadState a m, Monoid c) =&gt; Traversal a a b b' -&gt; (b -&gt; (c, b')) -&gt; m c
--   </pre>
--   
--   Modify each field of the state and return the <tt>mconcat</tt> of the
--   other values.
(%%=) :: MonadState a m => LensLike (Writer c) a a b b' -> (b -> (c, b')) -> m c

-- | Set a field of the state using the result of executing a stateful
--   command.
(<~) :: MonadState a m => Setter a a b b' -> m b' -> m ()
(+=) :: (MonadState a m, Num b) => Setter' a b -> b -> m ()
(-=) :: (MonadState a m, Num b) => Setter' a b -> b -> m ()
(*=) :: (MonadState a m, Num b) => Setter' a b -> b -> m ()
(//=) :: (MonadState a m, Fractional b) => Setter' a b -> b -> m ()
(&&=) :: MonadState a m => Setter' a Bool -> Bool -> m ()
(||=) :: MonadState a m => Setter' a Bool -> Bool -> m ()

-- | Monoidally append a value to all referenced fields of the state.
(<>=) :: (Monoid o, MonadState a m) => Setter' a o -> o -> m ()
data Zooming (m :: * -> *) c a :: (* -> *) -> * -> * -> *
type LensLike (f :: * -> *) a a' b b' = (b -> f b') -> a -> f a'
type LensLike' (f :: * -> *) a b = (b -> f b) -> a -> f a
type FoldLike r a a' b b' = LensLike (Constant r) a a' b b'

-- | Constant functor.
data Constant a b :: * -> * -> *
type Setter a a' b b' = forall f. Identical f => LensLike f a a' b b'
type Setter' a b = forall f. Identical f => LensLike' f a b
class Applicative f => Identical (f :: * -> *)

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data StateT s (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: * -> *) | m -> s

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a
