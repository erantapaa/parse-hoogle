-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Profunctors
--   
@package profunctors
@version 5.1.1


module Data.Profunctor.Trace

-- | Coend of <a>Profunctor</a> from <tt>Hask -&gt; Hask</tt>.
data Trace f
Trace :: f a a -> Trace f


-- | For a good explanation of profunctors in Haskell see Dan Piponi's
--   article:
--   
--   <a>http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html</a>
--   
--   This module includes <i>unsafe</i> composition operators that are
--   useful in practice when it comes to generating optimal core in GHC.
--   
--   If you import this module you are taking upon yourself the obligation
--   that you will only call the operators with <tt>#</tt> in their names
--   with functions that are operationally identity such as
--   <tt>newtype</tt> constructors or the field accessor of a
--   <tt>newtype</tt>.
--   
--   If you are ever in doubt, use <a>rmap</a> or <a>lmap</a>.
module Data.Profunctor.Unsafe

-- | Formally, the class <a>Profunctor</a> represents a profunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where the first argument is
--   contravariant and the second argument is covariant.
--   
--   You can define a <a>Profunctor</a> by either defining <a>dimap</a> or
--   by defining both <a>lmap</a> and <a>rmap</a>.
--   
--   If you supply <a>dimap</a>, you should ensure that:
--   
--   <pre>
--   <a>dimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>lmap</a> and <a>rmap</a>, ensure:
--   
--   <pre>
--   <a>lmap</a> <a>id</a> ≡ <a>id</a>
--   <a>rmap</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>dimap</a> (f <a>.</a> g) (h <a>.</a> i) ≡ <a>dimap</a> g h <a>.</a> <a>dimap</a> f i
--   <a>lmap</a> (f <a>.</a> g) ≡ <a>lmap</a> g <a>.</a> <a>lmap</a> f
--   <a>rmap</a> (f <a>.</a> g) ≡ <a>rmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
class Profunctor p where dimap f g = lmap f . rmap g lmap f = dimap f id rmap = dimap id (#.) = \ f -> \ p -> p `seq` rmap f p (.#) = \ p -> p `seq` \ f -> lmap f p
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
lmap :: Profunctor p => (a -> b) -> p b c -> p a c
rmap :: Profunctor p => (b -> c) -> p a b -> p a c
(#.) :: (Profunctor p, Coercible c b) => (b -> c) -> p a b -> p a c
(.#) :: (Profunctor p, Coercible b a) => p b c -> (a -> b) -> p a c
instance Functor w => Profunctor (Cokleisli w)
instance Monad m => Profunctor (Kleisli m)
instance Profunctor Tagged
instance Profunctor (->)


-- | For a good explanation of profunctors in Haskell see Dan Piponi's
--   article:
--   
--   <a>http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html</a>
--   
--   For more information on strength and costrength, see:
--   
--   <a>http://comonad.com/reader/2008/deriving-strength-from-laziness/</a>
module Data.Profunctor

-- | Formally, the class <a>Profunctor</a> represents a profunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where the first argument is
--   contravariant and the second argument is covariant.
--   
--   You can define a <a>Profunctor</a> by either defining <a>dimap</a> or
--   by defining both <a>lmap</a> and <a>rmap</a>.
--   
--   If you supply <a>dimap</a>, you should ensure that:
--   
--   <pre>
--   <a>dimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>lmap</a> and <a>rmap</a>, ensure:
--   
--   <pre>
--   <a>lmap</a> <a>id</a> ≡ <a>id</a>
--   <a>rmap</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>dimap</a> (f <a>.</a> g) (h <a>.</a> i) ≡ <a>dimap</a> g h <a>.</a> <a>dimap</a> f i
--   <a>lmap</a> (f <a>.</a> g) ≡ <a>lmap</a> g <a>.</a> <a>lmap</a> f
--   <a>rmap</a> (f <a>.</a> g) ≡ <a>rmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
class Profunctor p where dimap f g = lmap f . rmap g lmap f = dimap f id rmap = dimap id (#.) = \ f -> \ p -> p `seq` rmap f p (.#) = \ p -> p `seq` \ f -> lmap f p
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
lmap :: Profunctor p => (a -> b) -> p b c -> p a c
rmap :: Profunctor p => (b -> c) -> p a b -> p a c

-- | Generalizing <a>Star</a> of a strong <a>Functor</a>
--   
--   <i>Note:</i> Every <a>Functor</a> in Haskell is strong with respect to
--   <tt>(,)</tt>.
--   
--   This describes profunctor strength with respect to the product
--   structure of Hask.
--   
--   <a>http://www-kb.is.s.u-tokyo.ac.jp/~asada/papers/arrStrMnd.pdf</a>
class Profunctor p => Strong p where first' = dimap swap swap . second' second' = dimap swap swap . first'
first' :: Strong p => p a b -> p (a, c) (b, c)
second' :: Strong p => p a b -> p (c, a) (c, b)

-- | The generalization of <a>Costar</a> of <a>Functor</a> that is strong
--   with respect to <a>Either</a>.
--   
--   Note: This is also a notion of strength, except with regards to
--   another monoidal structure that we can choose to equip Hask with: the
--   cocartesian coproduct.
class Profunctor p => Choice p where left' = dimap (either Right Left) (either Right Left) . right' right' = dimap (either Right Left) (either Right Left) . left'
left' :: Choice p => p a b -> p (Either a c) (Either b c)
right' :: Choice p => p a b -> p (Either c a) (Either c b)

-- | Analogous to <a>ArrowLoop</a>, <a>loop</a> = <a>unfirst</a>
class Profunctor p => Costrong p where unfirst = unsecond . dimap swap swap unsecond = unfirst . dimap swap swap
unfirst :: Costrong p => p (a, d) (b, d) -> p a b
unsecond :: Costrong p => p (d, a) (d, b) -> p a b
class Profunctor p => Cochoice p where unleft = unright . dimap (either Right Left) (either Right Left) unright = unleft . dimap (either Right Left) (either Right Left)
unleft :: Cochoice p => p (Either a d) (Either b d) -> p a b
unright :: Cochoice p => p (Either d a) (Either d b) -> p a b

-- | Lift a <a>Functor</a> into a <a>Profunctor</a> (forwards).
newtype Star f d c
Star :: (d -> f c) -> Star f d c
runStar :: Star f d c -> d -> f c

-- | Lift a <a>Functor</a> into a <a>Profunctor</a> (backwards).
newtype Costar f d c
Costar :: (f d -> c) -> Costar f d c
runCostar :: Costar f d c -> f d -> c

-- | Wrap an arrow for use as a <a>Profunctor</a>.
newtype WrappedArrow p a b
WrapArrow :: p a b -> WrappedArrow p a b
unwrapArrow :: WrappedArrow p a b -> p a b
newtype Forget r a b
Forget :: (a -> r) -> Forget r a b
runForget :: Forget r a b -> a -> r
type (:->) p q = forall a b. p a b -> q a b
instance Traversable f => Cochoice (Star f)
instance Applicative f => Cochoice (Costar f)
instance Cochoice (->)
instance Functor f => Costrong (Cokleisli f)
instance MonadFix m => Costrong (Kleisli m)
instance ArrowLoop p => Costrong (WrappedArrow p)
instance Costrong Tagged
instance Functor f => Costrong (Costar f)
instance Costrong (->)
instance Monoid r => Choice (Forget r)
instance ArrowChoice p => Choice (WrappedArrow p)
instance Choice Tagged
instance Traversable w => Choice (Costar w)
instance Comonad w => Choice (Cokleisli w)
instance Applicative f => Choice (Star f)
instance Monad m => Choice (Kleisli m)
instance Choice (->)
instance Strong (Forget r)
instance Arrow p => Strong (WrappedArrow p)
instance Functor m => Strong (Star m)
instance Monad m => Strong (Kleisli m)
instance Strong (->)
instance Traversable (Forget r a)
instance Foldable (Forget r a)
instance Functor (Forget r a)
instance Profunctor (Forget r)
instance Arrow p => Profunctor (WrappedArrow p)
instance ArrowLoop p => ArrowLoop (WrappedArrow p)
instance ArrowApply p => ArrowApply (WrappedArrow p)
instance ArrowChoice p => ArrowChoice (WrappedArrow p)
instance ArrowZero p => ArrowZero (WrappedArrow p)
instance Arrow p => Arrow (WrappedArrow p)
instance Category p => Category (WrappedArrow p)
instance Monad (Costar f a)
instance Applicative (Costar f a)
instance Functor (Costar f a)
instance Distributive (Costar f d)
instance Functor f => Profunctor (Costar f)
instance Distributive f => Distributive (Star f a)
instance MonadPlus f => MonadPlus (Star f a)
instance Monad f => Monad (Star f a)
instance Alternative f => Alternative (Star f a)
instance Applicative f => Applicative (Star f a)
instance Functor f => Functor (Star f a)
instance Functor f => Profunctor (Star f)

module Data.Profunctor.Monad
class ProfunctorFunctor t
promap :: (ProfunctorFunctor t, Profunctor p) => (p :-> q) -> t p :-> t q
class ProfunctorFunctor t => ProfunctorMonad t
proreturn :: (ProfunctorMonad t, Profunctor p) => p :-> t p
projoin :: (ProfunctorMonad t, Profunctor p) => t (t p) :-> t p
class ProfunctorFunctor t => ProfunctorComonad t
proextract :: (ProfunctorComonad t, Profunctor p) => t p :-> p
produplicate :: (ProfunctorComonad t, Profunctor p) => t p :-> t (t p)

module Data.Profunctor.Adjunction
class (ProfunctorFunctor f, ProfunctorFunctor u) => ProfunctorAdjunction f u | f -> u, u -> f
unit :: (ProfunctorAdjunction f u, Profunctor p) => p :-> u (f p)
counit :: (ProfunctorAdjunction f u, Profunctor p) => f (u p) :-> p


module Data.Profunctor.Cayley
newtype Cayley f p a b
Cayley :: f (p a b) -> Cayley f p a b
runCayley :: Cayley f p a b -> f (p a b)

-- | Cayley transforms Monads in <tt>Hask</tt> into monads on <tt>Prof</tt>

-- | Cayley transforms Comonads in <tt>Hask</tt> into comonads on
--   <tt>Prof</tt>
instance (Applicative f, ArrowPlus p) => ArrowPlus (Cayley f p)
instance (Applicative f, ArrowZero p) => ArrowZero (Cayley f p)
instance (Applicative f, ArrowLoop p) => ArrowLoop (Cayley f p)
instance (Applicative f, ArrowChoice p) => ArrowChoice (Cayley f p)
instance (Applicative f, Arrow p) => Arrow (Cayley f p)
instance (Applicative f, Category p) => Category (Cayley f p)
instance (Functor f, Choice p) => Choice (Cayley f p)
instance (Functor f, Strong p) => Strong (Cayley f p)
instance (Functor f, Profunctor p) => Profunctor (Cayley f p)
instance Comonad f => ProfunctorComonad (Cayley f)
instance (Functor f, Monad f) => ProfunctorMonad (Cayley f)
instance Functor f => ProfunctorFunctor (Cayley f)

module Data.Profunctor.Closed

-- | A strong profunctor allows the monoidal structure to pass through.
--   
--   A closed profunctor allows the closed structure to pass through.
class Profunctor p => Closed p
closed :: Closed p => p a b -> p (x -> a) (x -> b)

-- | <a>Closure</a> adjoins a <a>Closed</a> structure to any
--   <a>Profunctor</a>.
--   
--   Analogous to <a>Tambara</a> for <a>Strong</a>.
newtype Closure p a b
Closure :: (forall x. p (x -> a) (x -> b)) -> Closure p a b
runClosure :: Closure p a b -> forall x. p (x -> a) (x -> b)

-- | <pre>
--   <a>close</a> <a>.</a> <a>unclose</a> ≡ <a>id</a>
--   <a>unclose</a> <a>.</a> <a>close</a> ≡ <a>id</a>
--   </pre>
close :: Closed p => (p :-> q) -> p :-> Closure q

-- | <pre>
--   <a>close</a> <a>.</a> <a>unclose</a> ≡ <a>id</a>
--   <a>unclose</a> <a>.</a> <a>close</a> ≡ <a>id</a>
--   </pre>
unclose :: Profunctor q => (p :-> Closure q) -> p :-> q
data Environment p a b
Environment :: ((z -> y) -> b) -> p x y -> (a -> z -> x) -> Environment p a b
instance ProfunctorAdjunction Environment Closure
instance ProfunctorMonad Environment
instance ProfunctorFunctor Environment
instance Profunctor p => Profunctor (Environment p)
instance (Profunctor p, Arrow p, Monoid b) => Monoid (Closure p a b)
instance (Profunctor p, ArrowPlus p) => Alternative (Closure p a)
instance (Profunctor p, Arrow p) => Applicative (Closure p a)
instance Profunctor p => Functor (Closure p a)
instance ArrowPlus p => ArrowPlus (Closure p)
instance ArrowZero p => ArrowZero (Closure p)
instance ArrowLoop p => ArrowLoop (Closure p)
instance Arrow p => Arrow (Closure p)
instance Category p => Category (Closure p)
instance Strong p => Strong (Closure p)
instance Profunctor p => Closed (Closure p)
instance ProfunctorComonad Closure
instance ProfunctorFunctor Closure
instance Profunctor p => Profunctor (Closure p)
instance (Distributive f, Monad f) => Closed (Kleisli f)
instance Distributive f => Closed (Star f)
instance Functor f => Closed (Cokleisli f)
instance Functor f => Closed (Costar f)
instance Closed (->)
instance Closed Tagged


module Data.Profunctor.Sieve

-- | A <a>Profunctor</a> <tt>p</tt> is a <a>Sieve</a> <b>on</b> <tt>f</tt>
--   if it is a subprofunctor of <tt><a>Star</a> f</tt>.
--   
--   That is to say it is a subset of <tt>Hom(-,f=)</tt> closed under
--   <a>lmap</a> and <a>rmap</a>.
--   
--   Alternately, you can view it as a sieve <b>in</b> the comma category
--   <tt>Hask/f</tt>.
class (Profunctor p, Functor f) => Sieve p f | p -> f
sieve :: Sieve p f => p a b -> a -> f b

-- | A <a>Profunctor</a> <tt>p</tt> is a <a>Cosieve</a> <b>on</b>
--   <tt>f</tt> if it is a subprofunctor of <tt><a>Costar</a> f</tt>.
--   
--   That is to say it is a subset of <tt>Hom(f-,=)</tt> closed under
--   <a>lmap</a> and <a>rmap</a>.
--   
--   Alternately, you can view it as a cosieve <b>in</b> the comma category
--   <tt>f/Hask</tt>.
class (Profunctor p, Functor f) => Cosieve p f | p -> f
cosieve :: Cosieve p f => p a b -> f a -> b
instance Functor f => Cosieve (Costar f) f
instance Cosieve Tagged Proxy
instance Functor w => Cosieve (Cokleisli w) w
instance Cosieve (->) Identity
instance Sieve (Forget r) (Const r)
instance Functor f => Sieve (Star f) f
instance (Monad m, Functor m) => Sieve (Kleisli m) m
instance Sieve (->) Identity


module Data.Profunctor.Rep

-- | A <a>Profunctor</a> <tt>p</tt> is <a>Representable</a> if there exists
--   a <a>Functor</a> <tt>f</tt> such that <tt>p d c</tt> is isomorphic to
--   <tt>d -&gt; f c</tt>.
class (Sieve p (Rep p), Strong p) => Representable p where type family Rep p :: * -> *
tabulate :: Representable p => (d -> Rep p c) -> p d c

-- | <a>tabulate</a> and <a>sieve</a> form two halves of an isomorphism.
--   
--   This can be used with the combinators from the <tt>lens</tt> package.
--   
--   <pre>
--   <a>tabulated</a> :: <a>Representable</a> p =&gt; <tt>Iso'</tt> (d -&gt; <a>Rep</a> p c) (p d c)
--   </pre>
tabulated :: (Representable p, Representable q) => Iso (d -> Rep p c) (d' -> Rep q c') (p d c) (q d' c')

-- | Default definition for <a>first'</a> given that p is
--   <a>Representable</a>.
firstRep :: Representable p => p a b -> p (a, c) (b, c)

-- | Default definition for <a>second'</a> given that p is
--   <a>Representable</a>.
secondRep :: Representable p => p a b -> p (c, a) (c, b)

-- | A <a>Profunctor</a> <tt>p</tt> is <a>Corepresentable</a> if there
--   exists a <a>Functor</a> <tt>f</tt> such that <tt>p d c</tt> is
--   isomorphic to <tt>f d -&gt; c</tt>.
class (Cosieve p (Corep p), Costrong p) => Corepresentable p where type family Corep p :: * -> *
cotabulate :: Corepresentable p => (Corep p d -> c) -> p d c

-- | <a>cotabulate</a> and <a>cosieve</a> form two halves of an
--   isomorphism.
--   
--   This can be used with the combinators from the <tt>lens</tt> package.
--   
--   <pre>
--   <a>cotabulated</a> :: <a>Corep</a> f p =&gt; <tt>Iso'</tt> (f d -&gt; c) (p d c)
--   </pre>
cotabulated :: (Corepresentable p, Corepresentable q) => Iso (Corep p d -> c) (Corep q d' -> c') (p d c) (q d' c')

-- | Default definition for <a>unfirst</a> given that p is
--   <a>Corepresentable</a>.
unfirstCorep :: Corepresentable p => p (a, d) (b, d) -> p a b

-- | Default definition for <a>unsecond</a> given that p is
--   <a>Corepresentable</a>.
unsecondCorep :: Corepresentable p => p (d, a) (d, b) -> p a b
instance Functor f => Corepresentable (Costar f)
instance Corepresentable Tagged
instance Functor w => Corepresentable (Cokleisli w)
instance Corepresentable (->)
instance Representable (Forget r)
instance Functor f => Representable (Star f)
instance (Monad m, Functor m) => Representable (Kleisli m)
instance Representable (->)


module Data.Profunctor.Composition

-- | <tt><a>Procompose</a> p q</tt> is the <a>Profunctor</a> composition of
--   the <a>Profunctor</a>s <tt>p</tt> and <tt>q</tt>.
--   
--   For a good explanation of <a>Profunctor</a> composition in Haskell see
--   Dan Piponi's article:
--   
--   <a>http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html</a>
data Procompose p q d c
Procompose :: p x c -> q d x -> Procompose p q d c
procomposed :: Category p => Procompose p p a b -> p a b

-- | <tt>(-&gt;)</tt> functions as a lax identity for <a>Profunctor</a>
--   composition.
--   
--   This provides an <a>Iso</a> for the <tt>lens</tt> package that
--   witnesses the isomorphism between <tt><a>Procompose</a> (-&gt;) q d
--   c</tt> and <tt>q d c</tt>, which is the left identity law.
--   
--   <pre>
--   <a>idl</a> :: <a>Profunctor</a> q =&gt; Iso' (<a>Procompose</a> (-&gt;) q d c) (q d c)
--   </pre>
idl :: Profunctor q => Iso (Procompose (->) q d c) (Procompose (->) r d' c') (q d c) (r d' c')

-- | <tt>(-&gt;)</tt> functions as a lax identity for <a>Profunctor</a>
--   composition.
--   
--   This provides an <a>Iso</a> for the <tt>lens</tt> package that
--   witnesses the isomorphism between <tt><a>Procompose</a> q (-&gt;) d
--   c</tt> and <tt>q d c</tt>, which is the right identity law.
--   
--   <pre>
--   <a>idr</a> :: <a>Profunctor</a> q =&gt; Iso' (<a>Procompose</a> q (-&gt;) d c) (q d c)
--   </pre>
idr :: Profunctor q => Iso (Procompose q (->) d c) (Procompose r (->) d' c') (q d c) (r d' c')

-- | The associator for <a>Profunctor</a> composition.
--   
--   This provides an <a>Iso</a> for the <tt>lens</tt> package that
--   witnesses the isomorphism between <tt><a>Procompose</a> p
--   (<a>Procompose</a> q r) a b</tt> and <tt><a>Procompose</a>
--   (<a>Procompose</a> p q) r a b</tt>, which arises because <tt>Prof</tt>
--   is only a bicategory, rather than a strict 2-category.
assoc :: Iso (Procompose p (Procompose q r) a b) (Procompose x (Procompose y z) a b) (Procompose (Procompose p q) r a b) (Procompose (Procompose x y) z a b)

-- | <a>Profunctor</a> composition generalizes <a>Functor</a> composition
--   in two ways.
--   
--   This is the first, which shows that <tt>exists b. (a -&gt; f b, b
--   -&gt; g c)</tt> is isomorphic to <tt>a -&gt; f (g c)</tt>.
--   
--   <pre>
--   <a>stars</a> :: <a>Functor</a> f =&gt; Iso' (<a>Procompose</a> (<a>Star</a> f) (<a>Star</a> g) d c) (<a>Star</a> (<a>Compose</a> f g) d c)
--   </pre>
stars :: Functor g => Iso (Procompose (Star f) (Star g) d c) (Procompose (Star f') (Star g') d' c') (Star (Compose g f) d c) (Star (Compose g' f') d' c')

-- | This is a variant on <a>stars</a> that uses <a>Kleisli</a> instead of
--   <a>Star</a>.
--   
--   <pre>
--   <a>kleislis</a> :: <a>Monad</a> f =&gt; Iso' (<a>Procompose</a> (<a>Kleisli</a> f) (<a>Kleisli</a> g) d c) (<a>Kleisli</a> (<a>Compose</a> f g) d c)
--   </pre>
kleislis :: Monad g => Iso (Procompose (Kleisli f) (Kleisli g) d c) (Procompose (Kleisli f') (Kleisli g') d' c') (Kleisli (Compose g f) d c) (Kleisli (Compose g' f') d' c')

-- | <a>Profunctor</a> composition generalizes <a>Functor</a> composition
--   in two ways.
--   
--   This is the second, which shows that <tt>exists b. (f a -&gt; b, g b
--   -&gt; c)</tt> is isomorphic to <tt>g (f a) -&gt; c</tt>.
--   
--   <pre>
--   <a>costars</a> :: <a>Functor</a> f =&gt; Iso' (<a>Procompose</a> (<a>Costar</a> f) (<a>Costar</a> g) d c) (<a>Costar</a> (<a>Compose</a> g f) d c)
--   </pre>
costars :: Functor f => Iso (Procompose (Costar f) (Costar g) d c) (Procompose (Costar f') (Costar g') d' c') (Costar (Compose f g) d c) (Costar (Compose f' g') d' c')

-- | This is a variant on <a>costars</a> that uses <a>Cokleisli</a> instead
--   of <a>Costar</a>.
--   
--   <pre>
--   <a>cokleislis</a> :: <a>Functor</a> f =&gt; Iso' (<a>Procompose</a> (<a>Cokleisli</a> f) (<a>Cokleisli</a> g) d c) (<a>Cokleisli</a> (<a>Compose</a> g f) d c)
--   </pre>
cokleislis :: Functor f => Iso (Procompose (Cokleisli f) (Cokleisli g) d c) (Procompose (Cokleisli f') (Cokleisli g') d' c') (Cokleisli (Compose f g) d c) (Cokleisli (Compose f' g') d' c')

-- | This represents the right Kan lift of a <a>Profunctor</a> <tt>q</tt>
--   along a <a>Profunctor</a> <tt>p</tt> in a limited version of the
--   2-category of Profunctors where the only object is the category Hask,
--   1-morphisms are profunctors composed and compose with Profunctor
--   composition, and 2-morphisms are just natural transformations.
newtype Rift p q a b
Rift :: (forall x. p b x -> q a x) -> Rift p q a b
runRift :: Rift p q a b -> forall x. p b x -> q a x

-- | The 2-morphism that defines a left Kan lift.
--   
--   Note: When <tt>p</tt> is right adjoint to <tt><a>Rift</a> p
--   (-&gt;)</tt> then <a>decomposeRift</a> is the <a>counit</a> of the
--   adjunction.
decomposeRift :: Procompose p (Rift p q) :-> q
instance ProfunctorAdjunction (Procompose p) (Rift p)
instance p ~ q => Category (Rift p q)
instance Profunctor p => Functor (Rift p q a)
instance (Profunctor p, Profunctor q) => Profunctor (Rift p q)
instance Category p => ProfunctorComonad (Rift p)
instance ProfunctorFunctor (Rift p)
instance (Corepresentable p, Corepresentable q) => Costrong (Procompose p q)
instance (Closed p, Closed q) => Closed (Procompose p q)
instance (Choice p, Choice q) => Choice (Procompose p q)
instance (Strong p, Strong q) => Strong (Procompose p q)
instance (Corepresentable p, Corepresentable q) => Corepresentable (Procompose p q)
instance (Cosieve p f, Cosieve q g) => Cosieve (Procompose p q) (Compose f g)
instance (Representable p, Representable q) => Representable (Procompose p q)
instance (Sieve p f, Sieve q g) => Sieve (Procompose p q) (Compose g f)
instance Profunctor p => Functor (Procompose p q a)
instance (Profunctor p, Profunctor q) => Profunctor (Procompose p q)
instance Category p => ProfunctorMonad (Procompose p)
instance ProfunctorFunctor (Procompose p)


module Data.Profunctor.Codensity

-- | This represents the right Kan extension of a <a>Profunctor</a>
--   <tt>p</tt> along itself. This provides a generalization of the
--   "difference list" trick to profunctors.
newtype Codensity p a b
Codensity :: (forall x. p x a -> p x b) -> Codensity p a b
runCodensity :: Codensity p a b -> forall x. p x a -> p x b
decomposeCodensity :: Procompose (Codensity p) p a b -> p a b
instance Category (Codensity p)
instance Profunctor p => Functor (Codensity p a)
instance Profunctor p => Profunctor (Codensity p)

module Data.Profunctor.Monoid

-- | a <a>Category</a> that is also a <a>Profunctor</a> is a
--   <tt>Monoid</tt> in <tt>Prof</tt>
eta :: (Profunctor p, Category p) => (->) :-> p
mu :: Category p => Procompose p p :-> p


module Data.Profunctor.Ran

-- | This represents the right Kan extension of a <a>Profunctor</a>
--   <tt>q</tt> along a <a>Profunctor</a> <tt>p</tt> in a limited version
--   of the 2-category of Profunctors where the only object is the category
--   Hask, 1-morphisms are profunctors composed and compose with Profunctor
--   composition, and 2-morphisms are just natural transformations.
newtype Ran p q a b
Ran :: (forall x. p x a -> q x b) -> Ran p q a b
runRan :: Ran p q a b -> forall x. p x a -> q x b

-- | The 2-morphism that defines a right Kan extension.
--   
--   Note: When <tt>q</tt> is left adjoint to <tt><a>Ran</a> q (-&gt;)</tt>
--   then <a>decomposeRan</a> is the <tt>counit</tt> of the adjunction.
decomposeRan :: Procompose (Ran q p) q :-> p
precomposeRan :: Profunctor q => Procompose q (Ran p (->)) :-> Ran p q
curryRan :: (Procompose p q :-> r) -> p :-> Ran q r
uncurryRan :: (p :-> Ran q r) -> Procompose p q :-> r
instance p ~ q => Category (Ran p q)
instance Profunctor q => Functor (Ran p q a)
instance (Profunctor p, Profunctor q) => Profunctor (Ran p q)
instance Category p => ProfunctorComonad (Ran p)
instance ProfunctorFunctor (Ran p)


module Data.Profunctor.Tambara
newtype Tambara p a b
Tambara :: (forall c. p (a, c) (b, c)) -> Tambara p a b
runTambara :: Tambara p a b -> forall c. p (a, c) (b, c)

-- | <pre>
--   <a>tambara</a> <a>.</a> <a>untambara</a> ≡ <a>id</a>
--   <a>untambara</a> <a>.</a> <a>tambara</a> ≡ <a>id</a>
--   </pre>
tambara :: Strong p => (p :-> q) -> p :-> Tambara q

-- | <pre>
--   <a>tambara</a> <a>.</a> <a>untambara</a> ≡ <a>id</a>
--   <a>untambara</a> <a>.</a> <a>tambara</a> ≡ <a>id</a>
--   </pre>
untambara :: Profunctor q => (p :-> Tambara q) -> p :-> q

-- | Pastro -| Tambara
data Pastro p a b
Pastro :: ((y, z) -> b) -> p x y -> (a -> (x, z)) -> Pastro p a b

-- | Cotambara is freely adjoins respect for cocartesian structure to a
--   profunctor
newtype Cotambara p a b
Cotambara :: (forall c. p (Either a c) (Either b c)) -> Cotambara p a b
runCotambara :: Cotambara p a b -> forall c. p (Either a c) (Either b c)

-- | <pre>
--   <a>cotambara</a> <a>.</a> <a>uncotambara</a> ≡ <a>id</a>
--   <a>uncotambara</a> <a>.</a> <a>cotambara</a> ≡ <a>id</a>
--   </pre>
cotambara :: Choice p => (p :-> q) -> p :-> Cotambara q

-- | <pre>
--   <a>cotambara</a> <a>.</a> <a>uncotambara</a> ≡ <a>id</a>
--   <a>uncotambara</a> <a>.</a> <a>cotambara</a> ≡ <a>id</a>
--   </pre>
uncotambara :: Profunctor q => (p :-> Cotambara q) -> p :-> q

-- | Copastro -| Cotambara
data Copastro p a b
Copastro :: (Either y z -> b) -> p x y -> (a -> Either x z) -> Copastro p a b
instance ProfunctorMonad Copastro
instance ProfunctorFunctor Copastro
instance ProfunctorAdjunction Copastro Cotambara
instance Profunctor p => Profunctor (Copastro p)
instance Profunctor p => Functor (Cotambara p a)
instance Category p => Category (Cotambara p)
instance Profunctor p => Choice (Cotambara p)
instance Profunctor p => Profunctor (Cotambara p)
instance ProfunctorComonad Cotambara
instance ProfunctorFunctor Cotambara
instance ProfunctorAdjunction Pastro Tambara
instance ProfunctorMonad Pastro
instance ProfunctorFunctor Pastro
instance Profunctor p => Profunctor (Pastro p)
instance (Profunctor p, ArrowPlus p) => Monoid (Tambara p a b)
instance (Profunctor p, ArrowPlus p) => Alternative (Tambara p a)
instance (Profunctor p, Arrow p) => Applicative (Tambara p a)
instance Profunctor p => Functor (Tambara p a)
instance ArrowPlus p => ArrowPlus (Tambara p)
instance ArrowZero p => ArrowZero (Tambara p)
instance ArrowLoop p => ArrowLoop (Tambara p)
instance ArrowApply p => ArrowApply (Tambara p)
instance ArrowChoice p => ArrowChoice (Tambara p)
instance Arrow p => Arrow (Tambara p)
instance Category p => Category (Tambara p)
instance Choice p => Choice (Tambara p)
instance Profunctor p => Strong (Tambara p)
instance ProfunctorComonad Tambara
instance ProfunctorFunctor Tambara
instance Profunctor p => Profunctor (Tambara p)
