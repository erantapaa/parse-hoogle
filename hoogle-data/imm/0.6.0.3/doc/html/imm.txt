-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Retrieve RSS/Atom feeds and write one mail per new item in a maildir.
--   
--   Cf README
@package imm
@version 0.6.0.3

module Imm.Util

-- | Like <a>&lt;/&gt;</a> with first argument in IO to build
--   platform-dependent paths.
(>/>) :: MonadBase IO m => IO FilePath -> FilePath -> m FilePath

-- | Shortcut to <a>liftBase</a> with <a>IO</a> as base monad
io :: MonadBase IO m => IO a -> m a

module Imm.Error
data ImmError
OtherError :: String -> ImmError
HTTPError :: HttpException -> ImmError
TLSError :: TLSException -> ImmError
UnicodeError :: UnicodeException -> ImmError
ParseUriError :: String -> ImmError
ParseTimeError :: String -> ImmError
ParseItemDateError :: Item -> ImmError
ParseFeedError :: String -> ImmError
IOE :: IOError -> ImmError
TimeOut :: ImmError
withError :: (Error e, Show e, MonadBase IO m) => String -> ErrorT e m () -> m ()
localError :: (MonadBase IO m, MonadError ImmError m) => String -> m () -> m ()

-- | Monad-agnostic version of <a>try</a>
try :: (MonadBase IO m, MonadError ImmError m) => IO a -> m a

-- | Monad-agnostic version of <a>timeout</a>
timeout :: (MonadBase IO m, MonadError ImmError m) => Int -> IO a -> m a

-- | Monad-agnostic version of <a>parseURI</a>
parseURI :: MonadError ImmError m => String -> m URI

-- | Monad-agnostic version of <a>parseTime</a>
parseTime :: MonadError ImmError m => String -> m UTCTime
instance Error ImmError
instance Show ImmError

module Imm.Database
type FeedID = URI
class DatabaseReader m
getLastCheck :: DatabaseReader m => FeedID -> m UTCTime
class DatabaseWriter m
storeLastCheck :: DatabaseWriter m => FeedID -> UTCTime -> m ()
forget :: DatabaseWriter m => FeedID -> m ()
type DatabaseState m = (DatabaseReader m, DatabaseWriter m)
data FileDatabase
directory :: Lens' FileDatabase FilePath
getDataFile :: Lens' FileDatabase (FeedID -> FilePath)
instance [overlap ok] (MonadBase IO m, MonadError ImmError m) => DatabaseWriter (ReaderT FileDatabase m)
instance [overlap ok] MonadBase IO m => DatabaseReader (ReaderT FileDatabase m)
instance [overlap ok] Default (IO FileDatabase)
instance [overlap ok] (Error e, DatabaseReader m) => DatabaseReader (ErrorT e m)

module Imm.HTTP
class (Applicative m, Functor m, Monad m) => Decoder m where decode string = return . fromChunks . (: []) =<< toUnicode <$> converter <*> return strictString where strictString = concat $ toChunks string
converter :: Decoder m => m Converter
decode :: Decoder m => ByteString -> m Text

-- | Perform an HTTP GET request and return the response body as raw
--   <a>ByteString</a>
getRaw :: (MonadBase IO m, MonadError ImmError m) => URI -> m ByteString

-- | Same as <a>getRaw</a> with additional decoding
get :: (Decoder m, MonadBase IO m, MonadError ImmError m) => URI -> m Text

-- | Monad-agnostic version of <a>withManager</a>
withManager' :: (MonadError ImmError m, MonadBase IO m) => (Manager -> ResourceT IO b) -> m b

-- | Monad-agnostic version of <a>parseUrl</a>
parseURL :: (MonadBase IO m, MonadError ImmError m) => String -> m Request

-- | Build an HTTP request for given URI
request :: (MonadBase IO m, MonadError ImmError m) => String -> m Request
instance (Error e, Decoder m) => Decoder (ErrorT e m)

module Imm.Feed
data Action
Check :: Action
ShowStatus :: Action
MarkAsRead :: Action
MarkAsUnread :: Action
Update :: Action
type ImmFeed = (FeedID, Feed)
class FeedParser m
parseDate :: FeedParser m => String -> m (Maybe UTCTime)

-- | Provide a <a>String</a> representation of the feed type.
showType :: Feed -> String
describe :: Feed -> String
describeItem :: Item -> String

-- | Monad-agnostic version of <a>parseFeedString</a>
parse :: MonadError ImmError m => String -> m Feed

-- | Retrieve, decode and parse the given resource as a feed.
download :: (Decoder m, MonadBase IO m, MonadError ImmError m) => URI -> m ImmFeed

-- | Count the list of unread items for given feed.
check :: (FeedParser m, DatabaseReader m, MonadBase IO m, MonadError ImmError m) => ImmFeed -> m ()

-- | Simply set the last check time to now.
markAsRead :: (MonadBase IO m, MonadError ImmError m, DatabaseWriter m) => URI -> m ()

-- | Simply remove the state file.
markAsUnread :: (MonadBase IO m, MonadError ImmError m, DatabaseWriter m) => URI -> m ()

-- | Return a <a>String</a> describing the last update for a given feed.
showStatus :: (DatabaseReader m, MonadBase IO m) => URI -> m String

-- | This function is missing from <a>Query</a>, probably because it is
--   difficult to define where the content is located in a generic way for
--   Atom<i>RSS 1.x</i>RSS 2.x feeds.
getItemContent :: Item -> String
getDate :: (FeedParser m, Monad m, MonadError ImmError m) => Item -> m UTCTime
extractHtml :: EntryContent -> String
instance Eq Action
instance Show Action
instance (Monad m, Error e, FeedParser m) => FeedParser (ErrorT e m)

module Imm.Mail
data Mail
Mail :: String -> Maybe ZonedTime -> String -> String -> String -> String -> String -> String -> Mail
_returnPath :: Mail -> String
_date :: Mail -> Maybe ZonedTime
_from :: Mail -> String
_subject :: Mail -> String
_mime :: Mail -> String
_charset :: Mail -> String
_contentDisposition :: Mail -> String
_body :: Mail -> String
subject :: Lens' Mail String
returnPath :: Lens' Mail String
mime :: Lens' Mail String
from :: Lens' Mail String
date :: Lens' Mail (Maybe ZonedTime)
contentDisposition :: Lens' Mail String
charset :: Lens' Mail String
body :: Lens' Mail String
type Format = (Item, Feed) -> String
class MailFormatter m
formatFrom :: MailFormatter m => m Format
formatSubject :: MailFormatter m => m Format
formatBody :: MailFormatter m => m Format

-- | Build mail from a given feed, using builders functions from
--   <tt>Settings</tt>.
build :: (Applicative m, MailFormatter m, FeedParser m, Monad m) => TimeZone -> (Item, Feed) -> m Mail
instance Show Mail
instance Default Mail

module Imm.Maildir
type Maildir = FilePath
class MaildirWriter m
init :: MaildirWriter m => m ()
write :: MaildirWriter m => Mail -> m ()

-- | Return an allegedly unique filename; useful to add new mail files in a
--   maildir.
getUniqueName :: MonadBase IO m => m String
instance (MonadBase IO m, MonadError ImmError m) => MaildirWriter (ReaderT Maildir m)

module Imm.Config
newtype FromFormat
FromFormat :: Format -> FromFormat
newtype SubjectFormat
SubjectFormat :: Format -> SubjectFormat
newtype BodyFormat
BodyFormat :: Format -> BodyFormat

-- | The only exported constructor is through <a>Default</a> class.
data Config
maildir :: Lens' Config Maildir
fileDatabase :: Lens' Config FileDatabase
dateParsers :: Lens' Config [String -> Maybe UTCTime]
formatFrom :: Lens' Config FromFormat
formatSubject :: Lens' Config SubjectFormat
formatBody :: Lens' Config BodyFormat
decoder :: Lens' Config String
withConfig :: MonadBase IO m => (Config -> Config) -> ReaderT Config m a -> m a

-- | Return the Haskell code to write in the configuration file to add
--   feeds.
addFeeds :: MonadBase IO m => [(String, [String])] -> m ()
instance [overlap ok] Monad m => MailFormatter (ReaderT Config m)
instance [overlap ok] (MonadBase IO m, MonadError ImmError m) => MaildirWriter (ReaderT Config m)
instance [overlap ok] (MonadError ImmError m, MonadBase IO m) => DatabaseWriter (ReaderT Config m)
instance [overlap ok] MonadBase IO m => DatabaseReader (ReaderT Config m)
instance [overlap ok] (Applicative m, MonadBase IO m) => Decoder (ReaderT Config m)
instance [overlap ok] Monad m => FeedParser (ReaderT Config m)
instance [overlap ok] Default (IO Config)
instance [overlap ok] Default BodyFormat
instance [overlap ok] Default SubjectFormat
instance [overlap ok] Default FromFormat

module Imm.Core
type FeedConfig = (Config -> Config, FeedID)
type FeedList = [FeedConfig]
dispatch :: (Config -> Config) -> Action -> FeedList -> IO ()
importOPML :: (MonadBase IO m, MonadPlus m) => String -> m ()
check :: (Config -> Config) -> FeedConfig -> IO ()
showStatus :: (Config -> Config) -> FeedConfig -> IO ()
markAsRead :: (Config -> Config) -> FeedConfig -> IO ()
markAsUnread :: (Config -> Config) -> FeedConfig -> IO ()

-- | Write mails for each new item, and update the last check time in state
--   file.
update :: (Config -> Config) -> FeedConfig -> IO ()

module Imm.Boot

-- | Main function to call in the configuration file.
imm :: [ConfigFeed] -> IO ()
type ConfigFeed = (Config -> Config, String)

module Imm

-- | Parse an OPML string and return a list of tuples (category title, feed
--   URIs).
read :: String -> Maybe [(String, [String])]
