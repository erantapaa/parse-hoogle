-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions to desugar Template Haskell
--   
@package th-desugar
@version 1.5.3


-- | The functions in this module convert desugared Template Haskell back
--   into proper Template Haskell.
module Language.Haskell.TH.Desugar.Sweeten
expToTH :: DExp -> Exp
matchToTH :: DMatch -> Match
patToTH :: DPat -> Pat
decsToTH :: [DDec] -> [Dec]

-- | This returns a list of <tt>Dec</tt>s because GHC 7.6.3 does not have a
--   one-to-one mapping between <a>DDec</a> and <tt>Dec</tt>.
decToTH :: DDec -> [Dec]
letDecToTH :: DLetDec -> Dec
typeToTH :: DType -> Type
kindToTH :: DKind -> Kind
conToTH :: DCon -> Con
foreignToTH :: DForeign -> Foreign
pragmaToTH :: DPragma -> Maybe Pragma
ruleBndrToTH :: DRuleBndr -> RuleBndr
clauseToTH :: DClause -> Clause
tvbToTH :: DTyVarBndr -> TyVarBndr
cxtToTH :: DCxt -> Cxt
predToTH :: DPred -> Pred


-- | Expands type synonyms and open type families in desugared types,
--   ignoring closed type families. See also the package th-expand-syns for
--   doing this to non-desugared types.
module Language.Haskell.TH.Desugar.Expand

-- | Expand all type synonyms and open type families in the desugared
--   abstract syntax tree provided. Normally, the first parameter should
--   have a type like <a>DExp</a> or <a>DLetDec</a>.
expand :: (DsMonad q, Data a) => a -> q a

-- | Expands all type synonyms in a desugared type. Also expands open type
--   family applications, as long as the arguments have no free variables.
--   Attempts to expand closed type family applications, but aborts the
--   moment it spots anything strange, like a nested type family
--   application or type variable.
expandType :: DsMonad q => DType -> q DType

-- | Capture-avoiding substitution on types
substTy :: DsMonad q => Map Name DType -> DType -> q DType


-- | Desugars full Template Haskell syntax into a smaller core syntax for
--   further processing. The desugared types and constructors are prefixed
--   with a D.
module Language.Haskell.TH.Desugar

-- | Corresponds to TH's <tt>Exp</tt> type. Note that <tt>DLamE</tt> takes
--   names, not patterns.
data DExp
DVarE :: Name -> DExp
DConE :: Name -> DExp
DLitE :: Lit -> DExp
DAppE :: DExp -> DExp -> DExp
DLamE :: [Name] -> DExp -> DExp
DCaseE :: DExp -> [DMatch] -> DExp
DLetE :: [DLetDec] -> DExp -> DExp
DSigE :: DExp -> DType -> DExp
DStaticE :: DExp -> DExp

-- | Declarations as used in a <tt>let</tt> statement.
data DLetDec
DFunD :: Name -> [DClause] -> DLetDec
DValD :: DPat -> DExp -> DLetDec
DSigD :: Name -> DType -> DLetDec
DInfixD :: Fixity -> Name -> DLetDec

-- | Corresponds to TH's <tt>Pat</tt> type.
data DPat
DLitPa :: Lit -> DPat
DVarPa :: Name -> DPat
DConPa :: Name -> [DPat] -> DPat
DTildePa :: DPat -> DPat
DBangPa :: DPat -> DPat
DWildPa :: DPat

-- | Corresponds to TH's <tt>Type</tt> type.
data DType
DForallT :: [DTyVarBndr] -> DCxt -> DType -> DType
DAppT :: DType -> DType -> DType
DSigT :: DType -> DKind -> DType
DVarT :: Name -> DType
DConT :: Name -> DType
DArrowT :: DType
DLitT :: TyLit -> DType

-- | Corresponds to TH's <tt>Kind</tt> type, which is a synonym for
--   <tt>Type</tt>. <a>DKind</a>, though, only contains constructors that
--   make sense for kinds.
data DKind
DForallK :: [Name] -> DKind -> DKind
DVarK :: Name -> DKind
DConK :: Name -> [DKind] -> DKind
DArrowK :: DKind -> DKind -> DKind
DStarK :: DKind

-- | Corresponds to TH's <tt>Cxt</tt>
type DCxt = [DPred]

-- | Corresponds to TH's <tt>Pred</tt>
data DPred
DAppPr :: DPred -> DType -> DPred
DSigPr :: DPred -> DKind -> DPred
DVarPr :: Name -> DPred
DConPr :: Name -> DPred

-- | Corresponds to TH's <tt>TyVarBndr</tt>. Note that <tt>PlainTV x</tt>
--   and <tt>KindedTV x StarT</tt> are distinct, so we retain that
--   distinction here.
data DTyVarBndr
DPlainTV :: Name -> DTyVarBndr
DKindedTV :: Name -> DKind -> DTyVarBndr

-- | Corresponds to TH's <tt>Match</tt> type.
data DMatch
DMatch :: DPat -> DExp -> DMatch

-- | Corresponds to TH's <tt>Clause</tt> type.
data DClause
DClause :: [DPat] -> DExp -> DClause

-- | Corresponds to TH's <tt>Dec</tt> type.
data DDec
DLetDec :: DLetDec -> DDec
DDataD :: NewOrData -> DCxt -> Name -> [DTyVarBndr] -> [DCon] -> [Name] -> DDec
DTySynD :: Name -> [DTyVarBndr] -> DType -> DDec
DClassD :: DCxt -> Name -> [DTyVarBndr] -> [FunDep] -> [DDec] -> DDec
DInstanceD :: DCxt -> DType -> [DDec] -> DDec
DForeignD :: DForeign -> DDec
DPragmaD :: DPragma -> DDec
DFamilyD :: FamFlavour -> Name -> [DTyVarBndr] -> (Maybe DKind) -> DDec
DDataInstD :: NewOrData -> DCxt -> Name -> [DType] -> [DCon] -> [Name] -> DDec
DTySynInstD :: Name -> DTySynEqn -> DDec
DClosedTypeFamilyD :: Name -> [DTyVarBndr] -> (Maybe DKind) -> [DTySynEqn] -> DDec
DRoleAnnotD :: Name -> [Role] -> DDec
DStandaloneDerivD :: DCxt -> DType -> DDec
DDefaultSigD :: Name -> DType -> DDec

-- | Is it a <tt>newtype</tt> or a <tt>data</tt> type?
data NewOrData
Newtype :: NewOrData
Data :: NewOrData

-- | Corresponds to TH's <tt>Con</tt> type.
data DCon
DCon :: [DTyVarBndr] -> DCxt -> Name -> DConFields -> DCon

-- | A list of fields either for a standard data constructor or a record
--   data constructor.
data DConFields
DNormalC :: [DStrictType] -> DConFields
DRecC :: [DVarStrictType] -> DConFields

-- | Corresponds to TH's <tt>StrictType</tt> type.
type DStrictType = (Strict, DType)

-- | Corresponds to TH's <tt>VarStrictType</tt> type.
type DVarStrictType = (Name, Strict, DType)

-- | Corresponds to TH's <tt>Foreign</tt> type.
data DForeign
DImportF :: Callconv -> Safety -> String -> Name -> DType -> DForeign
DExportF :: Callconv -> String -> Name -> DType -> DForeign

-- | Corresponds to TH's <tt>Pragma</tt> type.
data DPragma
DInlineP :: Name -> Inline -> RuleMatch -> Phases -> DPragma
DSpecialiseP :: Name -> DType -> (Maybe Inline) -> Phases -> DPragma
DSpecialiseInstP :: DType -> DPragma
DRuleP :: String -> [DRuleBndr] -> DExp -> DExp -> Phases -> DPragma
DAnnP :: AnnTarget -> DExp -> DPragma
DLineP :: Int -> String -> DPragma

-- | Corresponds to TH's <tt>RuleBndr</tt> type.
data DRuleBndr
DRuleVar :: Name -> DRuleBndr
DTypedRuleVar :: Name -> DType -> DRuleBndr

-- | Corresponds to TH's <tt>TySynEqn</tt> type (to store type family
--   equations).
data DTySynEqn
DTySynEqn :: [DType] -> DType -> DTySynEqn

-- | Corresponds to TH's <tt>Info</tt> type.
data DInfo
DTyConI :: DDec -> (Maybe [DInstanceDec]) -> DInfo

-- | The <tt>Maybe Name</tt> stores the name of the enclosing definition
--   (datatype, for a data constructor; class, for a method), if any
DVarI :: Name -> DType -> (Maybe Name) -> Fixity -> DInfo
DTyVarI :: Name -> DKind -> DInfo

-- | The <tt>Int</tt> is the arity; the <tt>Bool</tt> is whether this tycon
--   is unlifted.
DPrimTyConI :: Name -> Int -> Bool -> DInfo
type DInstanceDec = DDec

-- | Role annotations
data Role :: *

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role
data AnnTarget :: *
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget

-- | This class relates a TH type with its th-desugar type and allows
--   conversions back and forth. The functional dependency goes only one
--   way because <a>Type</a> and <a>Kind</a> are type synonyms, but they
--   desugar to different types.
class Desugar th ds | ds -> th
desugar :: (Desugar th ds, DsMonad q) => th -> q ds
sweeten :: Desugar th ds => ds -> th

-- | Desugar an expression
dsExp :: DsMonad q => Exp -> q DExp

-- | Desugar arbitrary <tt>Dec</tt>s
dsDecs :: DsMonad q => [Dec] -> q [DDec]

-- | Desugar a type
dsType :: DsMonad q => Type -> q DType

-- | Desugar a kind
dsKind :: DsMonad q => Kind -> q DKind

-- | Desugar <tt>Info</tt>
dsInfo :: DsMonad q => Info -> q DInfo

-- | Desugar a pattern, along with processing a (desugared) expression that
--   is the entire scope of the variables bound in the pattern.
dsPatOverExp :: DsMonad q => Pat -> DExp -> q (DPat, DExp)

-- | Desugar multiple patterns. Like <a>dsPatOverExp</a>.
dsPatsOverExp :: DsMonad q => [Pat] -> DExp -> q ([DPat], DExp)

-- | Desugar a pattern, returning a list of (Name, DExp) pairs of extra
--   variables that must be bound within the scope of the pattern
dsPatX :: DsMonad q => Pat -> q (DPat, [(Name, DExp)])

-- | Desugar <tt>Dec</tt>s that can appear in a let expression
dsLetDecs :: DsMonad q => [Dec] -> q [DLetDec]

-- | Desugar a <tt>TyVarBndr</tt>
dsTvb :: DsMonad q => TyVarBndr -> q DTyVarBndr

-- | Desugar a <tt>Cxt</tt>
dsCxt :: DsMonad q => Cxt -> q DCxt

-- | Desugar a single <tt>Con</tt>.
dsCon :: DsMonad q => Con -> q DCon

-- | Desugar a <tt>Foreign</tt>.
dsForeign :: DsMonad q => Foreign -> q DForeign

-- | Desugar a <tt>Pragma</tt>.
dsPragma :: DsMonad q => Pragma -> q DPragma

-- | Desugar a <tt>RuleBndr</tt>.
dsRuleBndr :: DsMonad q => RuleBndr -> q DRuleBndr

-- | Desugaring a pattern also returns the list of variables bound in
--   as-patterns and the values they should be bound to. This variables
--   must be brought into scope in the "body" of the pattern.
type PatM q = WriterT [(Name, DExp)] q

-- | Desugar a <tt>Pred</tt>, flattening any internal tuples
dsPred :: DsMonad q => Pred -> q DCxt

-- | Desugar a pattern.
dsPat :: DsMonad q => Pat -> PatM q DPat

-- | Desugar a single <tt>Dec</tt>, perhaps producing multiple <a>DDec</a>s
dsDec :: DsMonad q => Dec -> q [DDec]

-- | Desugar a single <tt>Dec</tt>, perhaps producing multiple
--   <a>DLetDec</a>s
dsLetDec :: DsMonad q => Dec -> q [DLetDec]

-- | Desugar a list of matches for a <tt>case</tt> statement
dsMatches :: DsMonad q => Name -> [Match] -> q [DMatch]

-- | Desugar a <tt>Body</tt>
dsBody :: DsMonad q => Body -> [Dec] -> DExp -> q DExp

-- | Desugar guarded expressions
dsGuards :: DsMonad q => [(Guard, Exp)] -> DExp -> q DExp

-- | Desugar the <tt>Stmt</tt>s in a <tt>do</tt> expression
dsDoStmts :: DsMonad q => [Stmt] -> q DExp

-- | Desugar the <tt>Stmt</tt>s in a list or monad comprehension
dsComp :: DsMonad q => [Stmt] -> q DExp

-- | Desugar clauses to a function definition
dsClauses :: DsMonad q => Name -> [Clause] -> q [DClause]

-- | Expand all type synonyms and open type families in the desugared
--   abstract syntax tree provided. Normally, the first parameter should
--   have a type like <a>DExp</a> or <a>DLetDec</a>.
expand :: (DsMonad q, Data a) => a -> q a

-- | Expands all type synonyms in a desugared type. Also expands open type
--   family applications, as long as the arguments have no free variables.
--   Attempts to expand closed type family applications, but aborts the
--   moment it spots anything strange, like a nested type family
--   application or type variable.
expandType :: DsMonad q => DType -> q DType

-- | Reify a declaration, warning the user about splices if the reify
--   fails. The warning says that reification can fail if you try to reify
--   a type in the same splice as it is declared.
reifyWithWarning :: Quasi q => Name -> q Info

-- | Add a list of declarations to be considered when reifying local
--   declarations.
withLocalDeclarations :: DsMonad q => [Dec] -> DsM q a -> q a

-- | Like <a>reify</a>, but safer and desugared. Uses local declarations
--   where available.
dsReify :: DsMonad q => Name -> q (Maybe DInfo)

-- | Like <tt>reify</tt> from Template Haskell, but looks also in any
--   not-yet-typechecked declarations. To establish this list of
--   not-yet-typechecked declarations, use <a>withLocalDeclarations</a>.
--   Returns <a>Nothing</a> if reification fails. Note that no inferred
--   type information is available from local declarations; bottoms may be
--   used if necessary.
reifyWithLocals_maybe :: DsMonad q => Name -> q (Maybe Info)

-- | Like <a>reifyWithLocals_maybe</a>, but throws an exception upon
--   failure, warning the user about separating splices.
reifyWithLocals :: DsMonad q => Name -> q Info

-- | A <a>DsMonad</a> stores some list of declarations that should be
--   considered in scope. <a>DsM</a> is the prototypical inhabitant of
--   <a>DsMonad</a>.
class Quasi m => DsMonad m
localDeclarations :: DsMonad m => m [Dec]

-- | A convenient implementation of the <a>DsMonad</a> class. Use by
--   calling <a>withLocalDeclarations</a>.
data DsM q a

-- | Remove all nested pattern-matches within this expression. This also
--   removes all <a>DTildePa</a>s and <a>DBangPa</a>s. After this is run,
--   every pattern is guaranteed to be either a <a>DConPa</a> with bare
--   variables as arguments, a <a>DLitPa</a>, or a <a>DWildPa</a>.
scExp :: DsMonad q => DExp -> q DExp

-- | Like <a>scExp</a>, but for a <a>DLetDec</a>.
scLetDec :: DsMonad q => DLetDec -> q DLetDec

-- | Apply one <a>DExp</a> to a list of arguments
applyDExp :: DExp -> [DExp] -> DExp

-- | Apply one <a>DType</a> to a list of arguments
applyDType :: DType -> [DType] -> DType

-- | Convert a <a>DPat</a> to a <a>DExp</a>. Fails on <tt>DWildP</tt>.
dPatToDExp :: DPat -> DExp

-- | Remove all wildcards from a pattern, replacing any wildcard with a
--   fresh variable
removeWilds :: DsMonad q => DPat -> q DPat

-- | Extract the <tt>TyVarBndr</tt>s and constructors given the
--   <tt>Name</tt> of a type
getDataD :: Quasi q => String -> Name -> q ([TyVarBndr], [Con])

-- | From the name of a data constructor, retrive the datatype definition
--   it is a part of.
dataConNameToDataName :: Quasi q => Name -> q Name

-- | From the name of a data constructor, retrieve its definition as a
--   <tt>Con</tt>
dataConNameToCon :: Quasi q => Name -> q Con

-- | Check if a name occurs anywhere within a TH tree.
nameOccursIn :: Data a => Name -> a -> Bool

-- | Extract all Names mentioned in a TH tree.
allNamesIn :: Data a => a -> [Name]

-- | If the declaration passed in is a <a>DValD</a>, creates new,
--   equivalent declarations such that the <a>DPat</a> in all <a>DValD</a>s
--   is just a plain <a>DVarPa</a>. Other declarations are passed through
--   unchanged. Note that the declarations that come out of this function
--   are rather less efficient than those that come in: they have many more
--   pattern matches.
flattenDValD :: Quasi q => DLetDec -> q [DLetDec]

-- | Produces <a>DLetDec</a>s representing the record selector functions
--   from the provided <a>DCon</a>.
getRecordSelectors :: Quasi q => DType -> DCon -> q [DLetDec]

-- | Like TH's <tt>lookupTypeName</tt>, but if this name is not bound, then
--   we assume it is declared in the current module.
mkTypeName :: Quasi q => String -> q Name

-- | Like TH's <tt>lookupDataName</tt>, but if this name is not bound, then
--   we assume it is declared in the current module.
mkDataName :: Quasi q => String -> q Name

-- | Like newName, but even more unique (unique across different splices),
--   and with unique <tt>nameBase</tt>s.
newUniqueName :: Quasi q => String -> q Name

-- | Make a tuple <a>DExp</a> from a list of <a>DExp</a>s. Avoids using a
--   1-tuple.
mkTupleDExp :: [DExp] -> DExp

-- | Make a tuple <a>DPat</a> from a list of <a>DPat</a>s. Avoids using a
--   1-tuple.
mkTupleDPat :: [DPat] -> DPat

-- | If decs is non-empty, delcare them in a let:
maybeDLetE :: [DLetDec] -> DExp -> DExp

-- | If matches is non-empty, make a case statement; otherwise make an
--   error statement
maybeDCaseE :: String -> DExp -> [DMatch] -> DExp

-- | Capture-avoiding substitution on types
substTy :: DsMonad q => Map Name DType -> DType -> q DType

-- | Extract the degree of a tuple
tupleDegree_maybe :: String -> Maybe Int

-- | Extract the degree of a tuple name
tupleNameDegree_maybe :: Name -> Maybe Int

-- | Extract the degree of an unboxed tuple
unboxedTupleDegree_maybe :: String -> Maybe Int

-- | Extract the degree of a tuple name
unboxedTupleNameDegree_maybe :: Name -> Maybe Int

-- | Extract the names bound in a <tt>Stmt</tt>
extractBoundNamesStmt :: Stmt -> Set Name

-- | Extract the names bound in a <tt>Dec</tt> that could appear in a
--   <tt>let</tt> expression.
extractBoundNamesDec :: Dec -> Set Name

-- | Extract the names bound in a <tt>Pat</tt>
extractBoundNamesPat :: Pat -> Set Name
instance Desugar Con DCon
instance Desugar [Dec] [DDec]
instance Desugar TyVarBndr DTyVarBndr
instance Desugar Cxt DCxt
instance Desugar Kind DKind
instance Desugar Type DType
instance Desugar Exp DExp


-- | Defines <tt>Lift</tt> instances for the desugared language. This is
--   defined in a separate module because it also must define <tt>Lift</tt>
--   instances for several TH types, which are orphans and may want another
--   definition downstream.
module Language.Haskell.TH.Desugar.Lift
instance Lift NewOrData
instance Lift DTySynEqn
instance Lift DRuleBndr
instance Lift DPragma
instance Lift DForeign
instance Lift DConFields
instance Lift DCon
instance Lift DDec
instance Lift DLetDec
instance Lift DClause
instance Lift DMatch
instance Lift DTyVarBndr
instance Lift DPred
instance Lift DKind
instance Lift DType
instance Lift DPat
instance Lift DExp
