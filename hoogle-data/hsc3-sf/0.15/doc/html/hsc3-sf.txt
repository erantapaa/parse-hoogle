-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell SuperCollider SoundFile
--   
@package hsc3-sf
@version 0.15


-- | Audio data encodings.
module Sound.File.Encoding

-- | Enemeration of valid audio data encodings.
data Encoding
Linear8 :: Encoding
Linear16 :: Encoding
Linear32 :: Encoding
Float :: Encoding
Double :: Encoding

-- | Bytes per sample at <a>Encoding</a>.
sizeOf :: Encoding -> Int
instance Eq Encoding
instance Show Encoding


-- | Decoder for audio data.
module Sound.File.Decode

-- | Given an <a>Encoding</a> and the number of channels, decode a
--   <a>ByteString</a> to set of <a>deinterleave</a>d channels.
decode :: (Real n, Floating n) => Encoding -> Int -> ByteString -> [[n]]

-- | Given channel count, deinterleave list to set of channels.
--   
--   <pre>
--   deinterleave 2 [0..9] == [[0,2,4,6,8],[1,3,5,7,9]]
--   </pre>
deinterleave :: Int -> [a] -> [[a]]


-- | Encode audio data.
module Sound.File.Encode

-- | Interleave channel data, ie. <a>concat</a> <a>.</a> <a>transpose</a>.
--   
--   <pre>
--   interleave [[0,2..8],[1,3..9]] == [0,1,2,3,4,5,6,7,8,9]
--   </pre>
interleave :: [[a]] -> [a]

-- | Given <a>Encoding</a> and a set of channels, <a>interleave</a> and
--   encode as <a>ByteString</a>.
encode :: (Real n, Floating n) => Encoding -> [[n]] -> ByteString


-- | Read and write NeXT/Sun format sound files.
module Sound.File.NeXT

-- | Number of frames at <a>Header</a>.
type FrameCount = Int

-- | Sample rate at <a>Header</a>.
type SampleRate = Int

-- | Number of channels at <a>Header</a>.
type ChannelCount = Int

-- | Data type encapsulating sound file meta data.
data Header
Header :: FrameCount -> Encoding -> SampleRate -> ChannelCount -> Header
frameCount :: Header -> FrameCount
encoding :: Header -> Encoding
sampleRate :: Header -> SampleRate
channelCount :: Header -> ChannelCount

-- | Read sound file meta data.
header :: FilePath -> IO Header

-- | Read sound file, data is interleaved.
read :: (Real n, Floating n) => FilePath -> IO (Header, [[n]])

-- | Write sound file, data is non-interleaved.
write :: (Real n, Floating n) => FilePath -> Header -> [[n]] -> IO ()
instance Eq Header
instance Show Header
