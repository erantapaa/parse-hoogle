-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Template Haskell based deriver for optimised NFData instances
--   
--   This package provides a Template Haskell based mechanism for deriving
--   optimised NFData instances for custom data types. See documentation in
--   <a>Control.DeepSeq.TH</a> for more information.
--   
--   See also the <tt>deepseq-generics</tt> package
--   (<a>http://hackage.haskell.org/package/deepseq-generics</a>) for a
--   less experimental approach.
@package deepseq-th
@version 0.1.0.4


-- | Module providing Template Haskell based <a>NFData</a> instance
--   generators and WHNF=NF type inspectors.
--   
--   To use this module enable the <tt>TemplateHaskell</tt> extension and
--   import <a>Control.DeepSeq.TH</a>:
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   import Control.DeepSeq.TH
--   </pre>
module Control.DeepSeq.TH

-- | Derive <a>NFData</a> instance for simple <tt>Data</tt>-declarations
--   
--   Example usage for deriving <a>NFData</a> instance for the type
--   <tt>TypeName</tt>:
--   
--   <pre>
--   $(deriveNFData ''TypeName)
--   </pre>
--   
--   The derivation tries to avoid evaluation of strict fields whose types
--   have the WHNF=NF property (see also <a>typeWhnfIsNf</a> and
--   <a>decWhnfIsNf</a>). For instance, consider the following types
--   <tt>Foo</tt> and <tt>Bar</tt>:
--   
--   <pre>
--   data Foo a = Foo1
--              | Foo2 !Int !String
--              | Foo3 (Foo a)
--              | Foo4 { fX :: Int, fY :: Char }
--              | Foo5 !Bar
--              | Foo6 !(String -&gt; Int)
--              | Foo a :--: !Bool
--   
--   data Bar = Bar0 | Bar1 !Char | Bar2 !Int !Int | Bar3 !Bar
--   </pre>
--   
--   By invoking <tt>$(deriveNFData ''Foo)</tt> the generated <a>NFData</a>
--   instance will be equivalent to:
--   
--   <pre>
--   instance NFData a =&gt; NFData (Foo a) where
--       rnf Foo1       = ()
--       rnf (Foo2 _ x) = x `deepseq` ()
--       rnf (Foo3 x)   = x `deepseq` ()
--       rnf (Foo4 x y) = x `deepseq` y `deepseq` ()
--       rnf (Foo5 _)   = ()
--       rnf (Foo6 _)   = ()
--       rnf (x :--: _) = x `deepseq` ()
--   </pre>
--   
--   Whereas <tt>$(deriveNFData ''Bar)</tt> generates the following default
--   <a>NFData</a> instance since <tt>Bar</tt> is inferred as a WHNF=NF
--   type:
--   
--   <pre>
--   instance NFData Bar
--   </pre>
--   
--   Known issues/limitations:
--   
--   <ul>
--   <li><tt>TypeName</tt> must be a proper <tt>data</tt> typename (use the
--   <tt>GeneralizedNewtypeDeriving</tt> extension for <tt>newtype</tt>
--   names)</li>
--   <li>Does not support existential types yet (i.e. use of the
--   <tt>forall</tt> keyword)</li>
--   <li>Does not always detect phantom type variables (e.g. for <tt>data
--   Foo a = Foo0 | Foo1 (Foo a)</tt>) which causes those to require
--   <a>NFData</a> instances.</li>
--   </ul>
deriveNFData :: Name -> Q [Dec]

-- | Plural version of <a>deriveNFData</a>
--   
--   Convenience wrapper for <a>deriveNFData</a> which allows to derive
--   multiple <a>NFData</a> instances for a list of <tt>TypeName</tt>s,
--   e.g.:
--   
--   <pre>
--   $(deriveNFData [''TypeName1, ''TypeName2, ''TypeName3])
--   </pre>
deriveNFDatas :: [Name] -> Q [Dec]

-- | Try to infer whether <a>Type</a> has the property that WHNF=NF for its
--   values.
--   
--   A result of <tt>Nothing</tt> means it is not known whether the
--   property holds for the given type. <tt>Just True</tt> means that the
--   property holds.
--   
--   This function has currently a rather limited knowledge and returns
--   <tt>Nothing</tt> most of the time except for some primitive types and
--   other simple cases.
--   
--   See also <a>decWhnfIsNf</a>
typeWhnfIsNf :: Type -> Q (Maybe Bool)

-- | Try to infer whether a <a>Dec</a> which defines a type which has the
--   property that WHNF=NF for its values. This property is derived
--   statically via the following simple rules:
--   
--   <ul>
--   <li><tt>newtype</tt>s are WHNF=NF if the wrapped type is WHNF=NF</li>
--   <li><tt>type</tt>s are WHNF=NF if the aliased type is WHNF=NF</li>
--   <li>Types defined by <tt>data</tt> are WHNF=NF if all constructors
--   contain only strict fields with WHNF=NF types</li>
--   </ul>
--   
--   Known limitations:
--   
--   <ul>
--   <li>Doesn't work properly with parametrized declarations (in which
--   case <tt>Nothing</tt> is returned) or existential types</li>
--   </ul>
--   
--   See also <a>typeWhnfIsNf</a>
decWhnfIsNf :: Dec -> Q (Maybe Bool)
