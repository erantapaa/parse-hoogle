-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions on System.FilePath
--   
--   Functions over <tt>System.FilePath</tt> including a find function for
--   recursing down directories.
@package FilePather
@version 0.2.0

module System.FilePath.FilePather.FileType

-- | The possible types of a file.
data FileType

-- | The type is a normal file.
File :: FileType

-- | The type is a directory.
Directory :: FileType

-- | The type is unknown.
Unknown :: FileType
isFile :: FileType -> Bool
isDirectory :: FileType -> Bool
isUnknown :: FileType -> Bool
instance Eq FileType
instance Ord FileType
instance Show FileType
instance Enum FileType

module System.FilePath.FilePather.FilterPredicate
data FilterPredicateT f

-- | A filter predicate that does not require effects to compute its
--   result.
type FilterPredicate = FilterPredicateT Identity

-- | A filter predicate takes a <a>FilePath</a> and a file type and returns
--   whether or not to filter the value.
filterPredicateT :: (FilePath -> FileType -> f Bool) -> FilterPredicateT f

-- | Construct a filter predicate that does not require effects to compute
--   its result.
filterPredicate :: (FilePath -> FileType -> Bool) -> FilterPredicate

-- | A filter predicate takes a <a>FilePath</a> and returns whether or not
--   to filter the value.
filterPredicateT' :: (FilePath -> f Bool) -> FilterPredicateT f

-- | Construct a filter predicate that does not require effects to compute
--   its result.
filterPredicate' :: (FilePath -> Bool) -> FilterPredicate

-- | Extract the filter predicate function.
runFilterPredicateT :: FilterPredicateT f -> FilePath -> FileType -> f Bool

-- | Construct a filter predicate that does not require effects to compute
--   its result.
runFilterPredicate :: FilterPredicate -> FilePath -> FileType -> Bool
isDirectoryType :: Monad f => FilterPredicateT f
isFileType :: Monad f => FilterPredicateT f
isUnknownType :: Monad f => FilterPredicateT f

module System.FilePath.FilePather.RecursePredicate

-- | A recurse predicate takes a <a>FilePath</a>, which is a directory, and
--   returns whether or not to continue recursing down on that directory.
data RecursePredicateT f

-- | A recurse predicate that does not require effects to compute its
--   result.
type RecursePredicate = RecursePredicateT Identity

-- | Construct a recurse predicate. The most general construction function.
recursePredicateT :: (FilePath -> f Bool) -> RecursePredicateT f

-- | Construct a recurse predicate that does not require effects to compute
--   its result.
recursePredicate :: (FilePath -> Bool) -> RecursePredicate

-- | Extract the recurse predicate function.
runRecursePredicateT :: RecursePredicateT f -> FilePath -> f Bool

-- | Extract the recurse predicate function that does not require effects
--   to compute its result.
runRecursePredicate :: RecursePredicate -> FilePath -> Bool

-- | Convert the recurse predicate to a filter predicate.
toFilterPredicate :: RecursePredicateT f -> FilterPredicateT f

module System.FilePath.FilePather.FilePathPredicate

-- | Functions that are common to predicates that work on <a>FilePath</a>
--   values.
class FilePathPredicate f where anyof = foldr (.||.) never allof = foldr (.&&.) always extensionEq p = extension (== p) extensionOneof = foldr (\ a b -> extensionEq a .||. b) never extensionNoneof = foldr (\ a b -> (.!.) (extensionEq a) .&&. b) always hasExtension = (.!.) notHasExtension notHasExtension = (.!.) hasExtension hasTrailingPathSeparator = (.!.) notHasTrailingPathSeparator notHasTrailingPathSeparator = (.!.) hasTrailingPathSeparator isRelative = (.!.) isNotRelative isNotRelative = (.!.) isRelative isAbsolute = (.!.) isNotAbsolute isNotAbsolute = (.!.) isAbsolute isValid = (.!.) isNotValid isNotValid = (.!.) isValid
always :: (FilePathPredicate f, Monad g) => f g
never :: (FilePathPredicate f, Monad g) => f g
(.&&.) :: (FilePathPredicate f, Monad g) => f g -> f g -> f g
(.||.) :: (FilePathPredicate f, Monad g) => f g -> f g -> f g
(.!.) :: (FilePathPredicate f, Monad g) => f g -> f g
anyof :: (FilePathPredicate f, Foldable t, Monad g) => t (f g) -> f g
allof :: (FilePathPredicate f, Foldable t, Monad g) => t (f g) -> f g
extension :: (FilePathPredicate f, Monad g) => (FilePath -> Bool) -> f g
extensionEq :: (FilePathPredicate f, Monad g) => FilePath -> f g
extensionOneof :: (FilePathPredicate f, Foldable t, Monad g) => t FilePath -> f g
extensionNoneof :: (FilePathPredicate f, Foldable t, Monad g) => t FilePath -> f g
directory :: (FilePathPredicate f, Monad g) => (FilePath -> Bool) -> f g
hasExtension :: (FilePathPredicate f, Monad g) => f g
notHasExtension :: (FilePathPredicate f, Monad g) => f g
splitExtension :: (FilePathPredicate f, Monad g) => (String -> String -> Bool) -> f g
splitDirectories :: (FilePathPredicate f, Monad g) => ([FilePath] -> Bool) -> f g
hasTrailingPathSeparator :: (FilePathPredicate f, Monad g) => f g
notHasTrailingPathSeparator :: (FilePathPredicate f, Monad g) => f g
fileName :: (FilePathPredicate f, Monad g) => (FilePath -> Bool) -> f g
baseName :: (FilePathPredicate f, Monad g) => (FilePath -> Bool) -> f g
normalise :: (FilePathPredicate f, Monad g) => (FilePath -> Bool) -> f g
makeValid :: (FilePathPredicate f, Monad g) => (FilePath -> Bool) -> f g
isRelative :: (FilePathPredicate f, Monad g) => f g
isNotRelative :: (FilePathPredicate f, Monad g) => f g
isAbsolute :: (FilePathPredicate f, Monad g) => f g
isNotAbsolute :: (FilePathPredicate f, Monad g) => f g
isValid :: (FilePathPredicate f, Monad g) => f g
isNotValid :: (FilePathPredicate f, Monad g) => f g
instance FilePathPredicate FilterPredicateT
instance FilePathPredicate RecursePredicateT

module System.FilePath.FilePather.LiftI

-- | A type-class for lifting a value. This type-class probably belongs
--   elsewhere (pointers appreciated!).
class LiftI f a | f -> a
liftI :: (LiftI f a, Monad g) => g a -> f g
instance LiftI FilterPredicateT Bool
instance LiftI RecursePredicateT Bool

module System.FilePath.FilePather.Find
class Find f where findHere f r = getCurrentDirectory >>= find f r findp f r = liftM (\ x -> x >>= \ w -> case w of { Found p _ -> [p] Drop _ _ -> [] Recurse _ -> [] NoRecurse _ -> [] }) . find f r findpHere f r = getCurrentDirectory >>= findp f r
find :: Find f => FilterPredicateT f -> RecursePredicateT f -> FilePath -> IO [FindR]
findHere :: Find f => FilterPredicateT f -> RecursePredicateT f -> IO [FindR]
findp :: Find f => FilterPredicateT f -> RecursePredicateT f -> FilePath -> IO [FilePath]
findpHere :: Find f => FilterPredicateT f -> RecursePredicateT f -> IO [FilePath]

-- | A specialisation of <a>find</a> to the <a>Identity</a> monad. Useful
--   in assisting type-inference.
findi :: FilterPredicate -> RecursePredicate -> FilePath -> IO [FindR]

-- | A specialisation of <a>findp</a> to the <a>Identity</a> monad. Useful
--   in assisting type-inference.
findpi :: FilterPredicate -> RecursePredicate -> FilePath -> IO [FilePath]

-- | The results of a path find. One of
--   
--   <ul>
--   <li><tt>found</tt> with the file path name and file type.</li>
--   <li><a>drop</a> with the file path name and file type.</li>
--   <li><tt>recurse</tt> with the file path (the file type is always
--   directory).</li>
--   <li>`no-recurse` with the file path (the file type is always
--   directory).</li>
--   </ul>
data FindR
foundR :: FilePath -> FileType -> FindR
dropR :: FilePath -> FileType -> FindR
recurseR :: FilePath -> FindR
noRecurseR :: FilePath -> FindR
foundL :: PartialLens FindR (FilePath, FileType)
dropL :: PartialLens FindR (FilePath, FileType)
recurseL :: PartialLens FindR FilePath
noRecurseL :: PartialLens FindR FilePath
instance Eq FindR
instance Show FindR
instance Comonad f => Find (IdentityT f)
instance Find IO
instance Find Identity

module System.FilePath.FilePather
