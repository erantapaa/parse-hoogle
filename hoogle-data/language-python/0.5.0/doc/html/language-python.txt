-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parsing and pretty printing of Python code.
--   
@package language-python
@version 0.5.0


-- | Conversion to/from escaped characters in strings. Note: currently does
--   not support escaped Unicode character names.
--   
--   See:
--   
--   <ul>
--   <li>Version 2.6
--   <a>http://www.python.org/doc/2.6/reference/lexical_analysis.html#string-literals</a></li>
--   <li>Version 3.1
--   <a>http://www.python.org/doc/3.1/reference/lexical_analysis.html#string-and-bytes-literals</a></li>
--   </ul>
module Language.Python.Common.StringEscape

-- | Convert escaped sequences of characters into <i>real</i> characters in
--   a normal Python string.
unescapeString :: String -> String
unescapeRawString :: String -> String

-- | The set of valid octal digits in Python.
octalDigits :: String

-- | The set of valid hex digits in Python.
hexDigits :: String


-- | Convenience class for pretty printing combinators.
module Language.Python.Common.Pretty

-- | All types which can be transformed into a <a>Doc</a>.
class Pretty a
pretty :: Pretty a => a -> Doc

-- | Transform values into strings.
prettyText :: Pretty a => a -> String

-- | Print just the prefix of something
prettyPrefix :: Pretty a => Int -> a -> Doc

-- | Conditionally wrap parentheses around an item.
parensIf :: Pretty a => (a -> Bool) -> a -> Doc
perhaps :: Pretty a => Maybe a -> Doc -> Doc

-- | A list of things separated by commas.
commaList :: Pretty a => [a] -> Doc
instance Pretty a => Pretty (Maybe a)
instance Pretty Bool
instance Pretty Double
instance Pretty Integer
instance Pretty Int
instance Pretty String


-- | Source location information for the Python lexer and parser. This
--   module provides single-point locations and spans, and conversions
--   between them.
module Language.Python.Common.SrcLocation

-- | A location for a syntactic entity from the source code. The location
--   is specified by its filename, and starting row and column.
data SrcLocation
Sloc :: !String -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> SrcLocation
sloc_filename :: SrcLocation -> !String
sloc_row :: SrcLocation -> {-# UNPACK #-} !Int
sloc_column :: SrcLocation -> {-# UNPACK #-} !Int
NoLocation :: SrcLocation

-- | Source location spanning a contiguous section of a file.
data SrcSpan

-- | A span which starts and ends on the same line.
SpanCoLinear :: !String -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> SrcSpan
span_filename :: SrcSpan -> !String
span_row :: SrcSpan -> {-# UNPACK #-} !Int
span_start_column :: SrcSpan -> {-# UNPACK #-} !Int
span_end_column :: SrcSpan -> {-# UNPACK #-} !Int

-- | A span which starts and ends on different lines.
SpanMultiLine :: !String -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> SrcSpan
span_filename :: SrcSpan -> !String
span_start_row :: SrcSpan -> {-# UNPACK #-} !Int
span_start_column :: SrcSpan -> {-# UNPACK #-} !Int
span_end_row :: SrcSpan -> {-# UNPACK #-} !Int
span_end_column :: SrcSpan -> {-# UNPACK #-} !Int

-- | A span which is actually just one point in the file.
SpanPoint :: !String -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> SrcSpan
span_filename :: SrcSpan -> !String
span_row :: SrcSpan -> {-# UNPACK #-} !Int
span_column :: SrcSpan -> {-# UNPACK #-} !Int

-- | No span information.
SpanEmpty :: SrcSpan

-- | Types which have a span.
class Span a where getSpan x = SpanEmpty
getSpan :: Span a => a -> SrcSpan

-- | Create a new span which encloses two spanned things.
spanning :: (Span a, Span b) => a -> b -> SrcSpan

-- | Make a span from two locations. Assumption: either the arguments are
--   the same, or the left one preceeds the right one.
mkSrcSpan :: SrcLocation -> SrcLocation -> SrcSpan

-- | Combines two <a>SrcSpan</a> into one that spans at least all the
--   characters within both spans. Assumes the "file" part is the same in
--   both inputs
combineSrcSpans :: SrcSpan -> SrcSpan -> SrcSpan

-- | Construct the initial source location for a file.
initialSrcLocation :: String -> SrcLocation

-- | Make a point span from the start of a span
spanStartPoint :: SrcSpan -> SrcSpan

-- | Increment the column of a location.
incColumn :: Int -> SrcLocation -> SrcLocation

-- | Decrement the column of a location, only if they are on the same row.
decColumn :: Int -> SrcLocation -> SrcLocation

-- | Increment the line number (row) of a location by one.
incLine :: Int -> SrcLocation -> SrcLocation

-- | Increment the column of a location by one tab stop.
incTab :: SrcLocation -> SrcLocation

-- | Get the column of the end of a span.
endCol :: SrcSpan -> Int

-- | Get the row of the end of a span.
endRow :: SrcSpan -> Int

-- | Get the column of the start of a span.
startCol :: SrcSpan -> Int

-- | Get the row of the start of a span.
startRow :: SrcSpan -> Int
instance Typeable SrcLocation
instance Typeable SrcSpan
instance Eq SrcLocation
instance Ord SrcLocation
instance Show SrcLocation
instance Data SrcLocation
instance Eq SrcSpan
instance Ord SrcSpan
instance Show SrcSpan
instance Data SrcSpan
instance Span SrcLocation
instance Pretty SrcSpan
instance Span SrcSpan
instance (Span a, Span b) => Span (a, b)
instance (Span a, Span b) => Span (Either a b)
instance Span a => Span (Maybe a)
instance Span a => Span [a]
instance Pretty SrcLocation


-- | Lexical tokens for the Python lexer. Contains the superset of tokens
--   from version 2 and version 3 of Python (they are mostly the same).
module Language.Python.Common.Token

-- | Lexical tokens.
data Token

-- | Indentation: increase.
IndentToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Indentation: decrease.
DedentToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Newline.
NewlineToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Line join (backslash at end of line).
LineJoinToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Single line comment.
CommentToken :: !SrcSpan -> !String -> Token
token_span :: Token -> !SrcSpan
token_literal :: Token -> !String

-- | Identifier.
IdentifierToken :: !SrcSpan -> !String -> Token
token_span :: Token -> !SrcSpan
token_literal :: Token -> !String

-- | Literal: string.
StringToken :: !SrcSpan -> !String -> Token
token_span :: Token -> !SrcSpan
token_literal :: Token -> !String

-- | Literal: byte string.
ByteStringToken :: !SrcSpan -> !String -> Token
token_span :: Token -> !SrcSpan
token_literal :: Token -> !String

-- | Literal: unicode string, version 2 only.
UnicodeStringToken :: !SrcSpan -> !String -> Token
token_span :: Token -> !SrcSpan
token_literal :: Token -> !String

-- | Literal: integer.
IntegerToken :: !SrcSpan -> !String -> !Integer -> Token
token_span :: Token -> !SrcSpan
token_literal :: Token -> !String
token_integer :: Token -> !Integer

-- | Literal: long integer. <i>Version 2 only</i>.
LongIntegerToken :: !SrcSpan -> !String -> !Integer -> Token
token_span :: Token -> !SrcSpan
token_literal :: Token -> !String
token_integer :: Token -> !Integer

-- | Literal: floating point.
FloatToken :: !SrcSpan -> !String -> !Double -> Token
token_span :: Token -> !SrcSpan
token_literal :: Token -> !String
token_double :: Token -> !Double

-- | Literal: imaginary number.
ImaginaryToken :: !SrcSpan -> !String -> !Double -> Token
token_span :: Token -> !SrcSpan
token_literal :: Token -> !String
token_double :: Token -> !Double

-- | Keyword: 'def'.
DefToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'while'.
WhileToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'if'.
IfToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'True'.
TrueToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'False'.
FalseToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'Return'.
ReturnToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'try'.
TryToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'except'.
ExceptToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'raise'.
RaiseToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'in'.
InToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'is'.
IsToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'lambda'.
LambdaToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'class'.
ClassToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'finally'.
FinallyToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'None'.
NoneToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'for'.
ForToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'from'.
FromToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'global'.
GlobalToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'with'.
WithToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'as'.
AsToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'elif'.
ElifToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'yield'.
YieldToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'assert'.
AssertToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'import'.
ImportToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'pass'.
PassToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'break'.
BreakToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'continue'.
ContinueToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'del'.
DeleteToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'else'.
ElseToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'not'.
NotToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: boolean conjunction 'and'.
AndToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: boolean disjunction 'or'. Version 3.x only:
OrToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'nonlocal' (Python 3.x only) Version 2.x only:
NonLocalToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'print'. (Python 2.x only)
PrintToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Keyword: 'exec'. (Python 2.x only)
ExecToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: at sign '@'.
AtToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: left round bracket '('.
LeftRoundBracketToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: right round bracket ')'.
RightRoundBracketToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: left square bracket '['.
LeftSquareBracketToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: right square bracket ']'.
RightSquareBracketToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: left curly bracket '{'.
LeftBraceToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: right curly bracket '}'.
RightBraceToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: dot (full stop) '.'.
DotToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: comma ','.
CommaToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: semicolon ';'.
SemiColonToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: colon ':'.
ColonToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: ellipses (three dots) '...'.
EllipsisToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: right facing arrow '-&gt;'.
RightArrowToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: assignment '='.
AssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: plus assignment '+='.
PlusAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: minus assignment '-='.
MinusAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: multiply assignment '*='
MultAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: divide assignment '/='.
DivAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: modulus assignment '%='.
ModAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: power assignment '**='.
PowAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: binary-and assignment '&amp;='.
BinAndAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: binary-or assignment '|='.
BinOrAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: binary-xor assignment '^='.
BinXorAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: binary-left-shift assignment '&lt;&lt;='.
LeftShiftAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: binary-right-shift assignment '&gt;&gt;='.
RightShiftAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: floor-divide assignment '//='.
FloorDivAssignToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Delimiter: back quote character '`\'.
BackQuoteToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: plus '+'.
PlusToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: minus: '-'.
MinusToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: multiply '*'.
MultToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: divide '/'.
DivToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: greater-than '&gt;'.
GreaterThanToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: less-than '&lt;'.
LessThanToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: equals '=='.
EqualityToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: greater-than-or-equals '&gt;='.
GreaterThanEqualsToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: less-than-or-equals '&lt;='.
LessThanEqualsToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: exponential '**'.
ExponentToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: binary-or '|'.
BinaryOrToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: binary-xor '^'.
XorToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: binary-and '&amp;'.
BinaryAndToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: binary-shift-left '&lt;&lt;'.
ShiftLeftToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: binary-shift-right '&gt;&gt;'.
ShiftRightToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: modulus '%'.
ModuloToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: floor-divide '//'.
FloorDivToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: tilde '~'.
TildeToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: not-equals '!='.
NotEqualsToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Operator: not-equals '&lt;&gt;'. Version 2 only.
NotEqualsV2Token :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | End of file
EOFToken :: !SrcSpan -> Token
token_span :: Token -> !SrcSpan

-- | Produce a string from a token containing detailed information. Mainly
--   intended for debugging.
debugTokenString :: Token -> String

-- | Produce a string from a token which is suitable for printing as Python
--   concrete syntax. <i>Invisible</i> tokens yield an empty string.
tokenString :: Token -> String

-- | Test if a token contains its literal source text.
hasLiteral :: Token -> Bool

-- | Classification of tokens
data TokenClass
Comment :: TokenClass
Number :: TokenClass
Identifier :: TokenClass
Punctuation :: TokenClass
Bracket :: TokenClass
Layout :: TokenClass
Keyword :: TokenClass
String :: TokenClass
Operator :: TokenClass
Assignment :: TokenClass
classifyToken :: Token -> TokenClass
instance Typeable Token
instance Eq Token
instance Ord Token
instance Show Token
instance Data Token
instance Show TokenClass
instance Eq TokenClass
instance Ord TokenClass
instance Span Token


-- | Representation of the Python abstract syntax tree (AST). The
--   representation is a superset of versions 2.x and 3.x of Python. In
--   many cases they are identical. The documentation in this module
--   indicates where they are different.
--   
--   All the data types have a (polymorphic) parameter which allows the AST
--   to be annotated by an arbitrary type (for example source locations).
--   Specialised instances of the types are provided for source spans. For
--   example <tt>Module a</tt> is the type of modules, and
--   <tt>ModuleSpan</tt> is the type of modules annoted with source span
--   information.
--   
--   Note: there are cases where the AST is more liberal than the formal
--   grammar of the language. Therefore some care must be taken when
--   constructing Python programs using the raw AST.
module Language.Python.Common.AST

-- | Convenient access to annotations in annotated types.
class Annotated t
annot :: Annotated t => t annot -> annot

-- | A module (Python source file).
--   
--   <ul>
--   <li>Version 2.6
--   <a>http://www.python.org/doc/2.6/reference/toplevel_components.html</a></li>
--   <li>Version 3.1
--   <a>http://www.python.org/doc/3.1/reference/toplevel_components.html</a></li>
--   </ul>
newtype Module annot

-- | A module is just a sequence of top-level statements.
Module :: [Statement annot] -> Module annot
type ModuleSpan = Module SrcSpan

-- | Identifier.
data Ident annot
Ident :: !String -> annot -> Ident annot
ident_string :: Ident annot -> !String
ident_annot :: Ident annot -> annot
type IdentSpan = Ident SrcSpan

-- | A compound name constructed with the dot operator.
type DottedName annot = [Ident annot]
type DottedNameSpan = DottedName SrcSpan

-- | Statements.
--   
--   <ul>
--   <li>Simple statements:<ul><li>Version 2.6
--   <a>http://www.python.org/doc/2.6/reference/simple_stmts.html</a></li><li>Version
--   3.1
--   <a>http://www.python.org/doc/3.1/reference/simple_stmts.html</a></li><li>Compound
--   statements:</li><li>Version 2.6
--   <a>http://www.python.org/doc/2.6/reference/compound_stmts.html</a></li><li>Version
--   3.1
--   <a>http://www.python.org/doc/3.1/reference/compound_stmts.html</a></li></ul></li>
--   </ul>
data Statement annot

-- | Import statement.
Import :: [ImportItem annot] -> annot -> Statement annot

-- | Items to import.
import_items :: Statement annot -> [ImportItem annot]
stmt_annot :: Statement annot -> annot

-- | From ... import statement.
FromImport :: ImportRelative annot -> FromItems annot -> annot -> Statement annot

-- | Module to import from.
from_module :: Statement annot -> ImportRelative annot

-- | Items to import.
from_items :: Statement annot -> FromItems annot
stmt_annot :: Statement annot -> annot

-- | While loop.
While :: Expr annot -> Suite annot -> Suite annot -> annot -> Statement annot

-- | Loop condition.
while_cond :: Statement annot -> Expr annot

-- | Loop body.
while_body :: Statement annot -> Suite annot

-- | Else clause.
while_else :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | For loop.
For :: [Expr annot] -> Expr annot -> Suite annot -> Suite annot -> annot -> Statement annot

-- | Loop variables.
for_targets :: Statement annot -> [Expr annot]

-- | Loop generator.
for_generator :: Statement annot -> Expr annot

-- | Loop body
for_body :: Statement annot -> Suite annot

-- | Else clause.
for_else :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | Function definition.
Fun :: Ident annot -> [Parameter annot] -> Maybe (Expr annot) -> Suite annot -> annot -> Statement annot

-- | Function name.
fun_name :: Statement annot -> Ident annot

-- | Function parameter list.
fun_args :: Statement annot -> [Parameter annot]

-- | Optional result annotation.
fun_result_annotation :: Statement annot -> Maybe (Expr annot)

-- | Function body.
fun_body :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | Class definition.
Class :: Ident annot -> [Argument annot] -> Suite annot -> annot -> Statement annot

-- | Class name.
class_name :: Statement annot -> Ident annot

-- | Class argument list. In version 2.x this is only ArgExprs.
class_args :: Statement annot -> [Argument annot]

-- | Class body.
class_body :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | Conditional statement (if-elif-else).
Conditional :: [(Expr annot, Suite annot)] -> Suite annot -> annot -> Statement annot

-- | Sequence of if-elif conditional clauses.
cond_guards :: Statement annot -> [(Expr annot, Suite annot)]

-- | Possibly empty unconditional else clause.
cond_else :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | Assignment statement.
Assign :: [Expr annot] -> Expr annot -> annot -> Statement annot

-- | Entity to assign to.
assign_to :: Statement annot -> [Expr annot]

-- | Expression to evaluate.
assign_expr :: Statement annot -> Expr annot
stmt_annot :: Statement annot -> annot

-- | Augmented assignment statement.
AugmentedAssign :: Expr annot -> AssignOp annot -> Expr annot -> annot -> Statement annot

-- | Entity to assign to.
aug_assign_to :: Statement annot -> Expr annot

-- | Assignment operator (for example '+=').
aug_assign_op :: Statement annot -> AssignOp annot

-- | Expression to evaluate.
aug_assign_expr :: Statement annot -> Expr annot
stmt_annot :: Statement annot -> annot

-- | Decorated definition of a function or class.
Decorated :: [Decorator annot] -> Statement annot -> annot -> Statement annot

-- | Decorators.
decorated_decorators :: Statement annot -> [Decorator annot]

-- | Function or class definition to be decorated.
decorated_def :: Statement annot -> Statement annot
stmt_annot :: Statement annot -> annot

-- | Return statement (may only occur syntactically nested in a function
--   definition).
Return :: Maybe (Expr annot) -> annot -> Statement annot

-- | Optional expression to evaluate and return to caller.
return_expr :: Statement annot -> Maybe (Expr annot)
stmt_annot :: Statement annot -> annot

-- | Try statement (exception handling).
Try :: Suite annot -> [Handler annot] -> Suite annot -> Suite annot -> annot -> Statement annot

-- | Try clause.
try_body :: Statement annot -> Suite annot

-- | Exception handlers.
try_excepts :: Statement annot -> [Handler annot]

-- | Possibly empty else clause, executed if and when control flows off the
--   end of the try clause.
try_else :: Statement annot -> Suite annot

-- | Possibly empty finally clause.
try_finally :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | Raise statement (exception throwing).
Raise :: RaiseExpr annot -> annot -> Statement annot
raise_expr :: Statement annot -> RaiseExpr annot
stmt_annot :: Statement annot -> annot

-- | With statement (context management).
With :: [(Expr annot, Maybe (Expr annot))] -> Suite annot -> annot -> Statement annot

-- | Context expression(s) (yields a context manager).
with_context :: Statement annot -> [(Expr annot, Maybe (Expr annot))]

-- | Suite to be managed.
with_body :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | Pass statement (null operation).
Pass :: annot -> Statement annot
stmt_annot :: Statement annot -> annot

-- | Break statement (may only occur syntactically nested in a for or while
--   loop, but not nested in a function or class definition within that
--   loop).
Break :: annot -> Statement annot
stmt_annot :: Statement annot -> annot

-- | Continue statement (may only occur syntactically nested in a for or
--   while loop, but not nested in a function or class definition or
--   finally clause within that loop).
Continue :: annot -> Statement annot
stmt_annot :: Statement annot -> annot

-- | Del statement (delete).
Delete :: [Expr annot] -> annot -> Statement annot

-- | Items to delete.
del_exprs :: Statement annot -> [Expr annot]
stmt_annot :: Statement annot -> annot

-- | Expression statement.
StmtExpr :: Expr annot -> annot -> Statement annot
stmt_expr :: Statement annot -> Expr annot
stmt_annot :: Statement annot -> annot

-- | Global declaration.
Global :: [Ident annot] -> annot -> Statement annot

-- | Variables declared global in the current block.
global_vars :: Statement annot -> [Ident annot]
stmt_annot :: Statement annot -> annot

-- | Nonlocal declaration. <i>Version 3.x only</i>.
NonLocal :: [Ident annot] -> annot -> Statement annot

-- | Variables declared nonlocal in the current block (their binding comes
--   from bound the nearest enclosing scope).
nonLocal_vars :: Statement annot -> [Ident annot]
stmt_annot :: Statement annot -> annot

-- | Assertion.
Assert :: [Expr annot] -> annot -> Statement annot

-- | Expressions being asserted.
assert_exprs :: Statement annot -> [Expr annot]
stmt_annot :: Statement annot -> annot

-- | Print statement. <i>Version 2 only</i>.
Print :: Bool -> [Expr annot] -> Bool -> annot -> Statement annot

-- | Optional chevron (&gt;&gt;)
print_chevron :: Statement annot -> Bool

-- | Arguments to print
print_exprs :: Statement annot -> [Expr annot]

-- | Does it end in a comma?
print_trailing_comma :: Statement annot -> Bool
stmt_annot :: Statement annot -> annot

-- | Exec statement. <i>Version 2 only</i>.
Exec :: Expr annot -> Maybe (Expr annot, Maybe (Expr annot)) -> annot -> Statement annot

-- | Expression to exec.
exec_expr :: Statement annot -> Expr annot

-- | Global and local environments to evaluate the expression within.
exec_globals_locals :: Statement annot -> Maybe (Expr annot, Maybe (Expr annot))
stmt_annot :: Statement annot -> annot
type StatementSpan = Statement SrcSpan

-- | A block of statements. A suite is a group of statements controlled by
--   a clause, for example, the body of a loop.
--   
--   <ul>
--   <li>Version 2.6
--   <a>http://www.python.org/doc/2.6/reference/compound_stmts.html</a></li>
--   <li>Version 3.1
--   <a>http://www.python.org/doc/3.1/reference/compound_stmts.html</a></li>
--   </ul>
type Suite annot = [Statement annot]
type SuiteSpan = Suite SrcSpan

-- | Formal parameter of function definitions and lambda expressions.
--   
--   <ul>
--   <li>Version 2.6:</li>
--   
--   <li><a>http://www.python.org/doc/2.6/reference/compound_stmts.html#function-definitions</a></li>
--   
--   <li><a>http://www.python.org/doc/2.6/reference/expressions.html#calls</a></li>
--   <li>Version 3.1:</li>
--   
--   <li><a>http://www.python.org/doc/3.1/reference/compound_stmts.html#function-definitions</a></li>
--   
--   <li><a>http://www.python.org/doc/3.1/reference/expressions.html#calls</a></li>
--   </ul>
data Parameter annot

-- | Ordinary named parameter.
Param :: Ident annot -> Maybe (Expr annot) -> Maybe (Expr annot) -> annot -> Parameter annot

-- | Parameter name.
param_name :: Parameter annot -> Ident annot

-- | Optional annotation.
param_py_annotation :: Parameter annot -> Maybe (Expr annot)

-- | Optional default value.
param_default :: Parameter annot -> Maybe (Expr annot)
param_annot :: Parameter annot -> annot

-- | Excess positional parameter (single asterisk before its name in the
--   concrete syntax).
VarArgsPos :: Ident annot -> Maybe (Expr annot) -> annot -> Parameter annot

-- | Parameter name.
param_name :: Parameter annot -> Ident annot

-- | Optional annotation.
param_py_annotation :: Parameter annot -> Maybe (Expr annot)
param_annot :: Parameter annot -> annot

-- | Excess keyword parameter (double asterisk before its name in the
--   concrete syntax).
VarArgsKeyword :: Ident annot -> Maybe (Expr annot) -> annot -> Parameter annot

-- | Parameter name.
param_name :: Parameter annot -> Ident annot

-- | Optional annotation.
param_py_annotation :: Parameter annot -> Maybe (Expr annot)
param_annot :: Parameter annot -> annot

-- | Marker for the end of positional parameters (not a parameter itself).
EndPositional :: annot -> Parameter annot
param_annot :: Parameter annot -> annot

-- | Tuple unpack. <i>Version 2 only</i>.
UnPackTuple :: ParamTuple annot -> Maybe (Expr annot) -> annot -> Parameter annot

-- | The tuple to unpack.
param_unpack_tuple :: Parameter annot -> ParamTuple annot

-- | Optional default value.
param_default :: Parameter annot -> Maybe (Expr annot)
param_annot :: Parameter annot -> annot
type ParameterSpan = Parameter SrcSpan

-- | Tuple unpack parameter. <i>Version 2 only</i>.
data ParamTuple annot

-- | A variable name.
ParamTupleName :: Ident annot -> annot -> ParamTuple annot
param_tuple_name :: ParamTuple annot -> Ident annot
param_tuple_annot :: ParamTuple annot -> annot

-- | A (possibly nested) tuple parameter.
ParamTuple :: [ParamTuple annot] -> annot -> ParamTuple annot
param_tuple :: ParamTuple annot -> [ParamTuple annot]
param_tuple_annot :: ParamTuple annot -> annot
type ParamTupleSpan = ParamTuple SrcSpan

-- | Decorator.
data Decorator annot
Decorator :: DottedName annot -> [Argument annot] -> annot -> Decorator annot

-- | Decorator name.
decorator_name :: Decorator annot -> DottedName annot

-- | Decorator arguments.
decorator_args :: Decorator annot -> [Argument annot]
decorator_annot :: Decorator annot -> annot
type DecoratorSpan = Decorator SrcSpan

-- | Augmented assignment operators.
data AssignOp annot

-- | '+='
PlusAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '-='
MinusAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '*='
MultAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '/='
DivAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '%='
ModAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '*='
PowAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '&amp;='
BinAndAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '|='
BinOrAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '^='
BinXorAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '&lt;&lt;='
LeftShiftAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '&gt;&gt;='
RightShiftAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot

-- | '//='
FloorDivAssign :: annot -> AssignOp annot
assignOp_annot :: AssignOp annot -> annot
type AssignOpSpan = AssignOp SrcSpan

-- | Expressions.
--   
--   <ul>
--   <li>Version 2.6
--   <a>http://www.python.org/doc/2.6/reference/expressions.html</a>.</li>
--   <li>Version 3.1
--   <a>http://www.python.org/doc/3.1/reference/expressions.html</a>.</li>
--   </ul>
data Expr annot

-- | Variable.
Var :: Ident annot -> annot -> Expr annot
var_ident :: Expr annot -> Ident annot
expr_annot :: Expr annot -> annot

-- | Literal integer.
Int :: Integer -> String -> annot -> Expr annot
int_value :: Expr annot -> Integer
expr_literal :: Expr annot -> String
expr_annot :: Expr annot -> annot

-- | Long literal integer. <i>Version 2 only</i>.
LongInt :: Integer -> String -> annot -> Expr annot
int_value :: Expr annot -> Integer
expr_literal :: Expr annot -> String
expr_annot :: Expr annot -> annot

-- | Literal floating point number.
Float :: Double -> String -> annot -> Expr annot
float_value :: Expr annot -> Double
expr_literal :: Expr annot -> String
expr_annot :: Expr annot -> annot

-- | Literal imaginary number.
Imaginary :: Double -> String -> annot -> Expr annot
imaginary_value :: Expr annot -> Double
expr_literal :: Expr annot -> String
expr_annot :: Expr annot -> annot

-- | Literal boolean.
Bool :: Bool -> annot -> Expr annot
bool_value :: Expr annot -> Bool
expr_annot :: Expr annot -> annot

-- | Literal 'None' value.
None :: annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Ellipsis '...'.
Ellipsis :: annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Literal byte string.
ByteStrings :: [String] -> annot -> Expr annot
byte_string_strings :: Expr annot -> [String]
expr_annot :: Expr annot -> annot

-- | Literal strings (to be concatentated together).
Strings :: [String] -> annot -> Expr annot
strings_strings :: Expr annot -> [String]
expr_annot :: Expr annot -> annot

-- | Unicode literal strings (to be concatentated together). Version 2
--   only.
UnicodeStrings :: [String] -> annot -> Expr annot
unicodestrings_strings :: Expr annot -> [String]
expr_annot :: Expr annot -> annot

-- | Function call.
Call :: Expr annot -> [Argument annot] -> annot -> Expr annot

-- | Expression yielding a callable object (such as a function).
call_fun :: Expr annot -> Expr annot

-- | Call arguments.
call_args :: Expr annot -> [Argument annot]
expr_annot :: Expr annot -> annot

-- | Subscription, for example 'x [y]'.
Subscript :: Expr annot -> Expr annot -> annot -> Expr annot
subscriptee :: Expr annot -> Expr annot
subscript_expr :: Expr annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Slicing, for example 'w [x:y:z]'.
SlicedExpr :: Expr annot -> [Slice annot] -> annot -> Expr annot
slicee :: Expr annot -> Expr annot
slices :: Expr annot -> [Slice annot]
expr_annot :: Expr annot -> annot

-- | Conditional expresison.
CondExpr :: Expr annot -> Expr annot -> Expr annot -> annot -> Expr annot

-- | Expression to evaluate if condition is True.
ce_true_branch :: Expr annot -> Expr annot

-- | Boolean condition.
ce_condition :: Expr annot -> Expr annot

-- | Expression to evaluate if condition is False.
ce_false_branch :: Expr annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Binary operator application.
BinaryOp :: Op annot -> Expr annot -> Expr annot -> annot -> Expr annot
operator :: Expr annot -> Op annot
left_op_arg :: Expr annot -> Expr annot
right_op_arg :: Expr annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Unary operator application.
UnaryOp :: Op annot -> Expr annot -> annot -> Expr annot
operator :: Expr annot -> Op annot
op_arg :: Expr annot -> Expr annot
expr_annot :: Expr annot -> annot
Dot :: Expr annot -> Ident annot -> annot -> Expr annot
dot_expr :: Expr annot -> Expr annot
dot_attribute :: Expr annot -> Ident annot
expr_annot :: Expr annot -> annot

-- | Anonymous function definition (lambda).
Lambda :: [Parameter annot] -> Expr annot -> annot -> Expr annot
lambda_args :: Expr annot -> [Parameter annot]
lambda_body :: Expr annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Tuple. Can be empty.
Tuple :: [Expr annot] -> annot -> Expr annot
tuple_exprs :: Expr annot -> [Expr annot]
expr_annot :: Expr annot -> annot

-- | Generator yield.
Yield :: Maybe (YieldArg annot) -> annot -> Expr annot

-- | Optional Yield argument.
yield_arg :: Expr annot -> Maybe (YieldArg annot)
expr_annot :: Expr annot -> annot

-- | Generator.
Generator :: Comprehension annot -> annot -> Expr annot
gen_comprehension :: Expr annot -> Comprehension annot
expr_annot :: Expr annot -> annot

-- | List comprehension.
ListComp :: Comprehension annot -> annot -> Expr annot
list_comprehension :: Expr annot -> Comprehension annot
expr_annot :: Expr annot -> annot

-- | List.
List :: [Expr annot] -> annot -> Expr annot
list_exprs :: Expr annot -> [Expr annot]
expr_annot :: Expr annot -> annot

-- | Dictionary.
Dictionary :: [DictMappingPair annot] -> annot -> Expr annot
dict_mappings :: Expr annot -> [DictMappingPair annot]
expr_annot :: Expr annot -> annot

-- | Dictionary comprehension. <i>Version 3 only</i>.
DictComp :: Comprehension annot -> annot -> Expr annot
dict_comprehension :: Expr annot -> Comprehension annot
expr_annot :: Expr annot -> annot

-- | Set.
Set :: [Expr annot] -> annot -> Expr annot
set_exprs :: Expr annot -> [Expr annot]
expr_annot :: Expr annot -> annot

-- | Set comprehension. <i>Version 3 only</i>.
SetComp :: Comprehension annot -> annot -> Expr annot
set_comprehension :: Expr annot -> Comprehension annot
expr_annot :: Expr annot -> annot

-- | Starred expression. <i>Version 3 only</i>.
Starred :: Expr annot -> annot -> Expr annot
starred_expr :: Expr annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Parenthesised expression.
Paren :: Expr annot -> annot -> Expr annot
paren_expr :: Expr annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | String conversion (backquoted expression). Version 2 only.
StringConversion :: Expr annot -> annot -> Expr annot
backquoted_expr :: Expr annot -> Expr annot
expr_anot :: Expr annot -> annot
type ExprSpan = Expr SrcSpan

-- | Operators.
data Op annot

-- | 'and'
And :: annot -> Op annot
op_annot :: Op annot -> annot

-- | 'or'
Or :: annot -> Op annot
op_annot :: Op annot -> annot

-- | 'not'
Not :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '**'
Exponent :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '&lt;'
LessThan :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '&gt;'
GreaterThan :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '=='
Equality :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '&gt;='
GreaterThanEquals :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '&lt;='
LessThanEquals :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '!='
NotEquals :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '&lt;&gt;'. Version 2 only.
NotEqualsV2 :: annot -> Op annot
op_annot :: Op annot -> annot

-- | 'in'
In :: annot -> Op annot
op_annot :: Op annot -> annot

-- | 'is'
Is :: annot -> Op annot
op_annot :: Op annot -> annot

-- | 'is not'
IsNot :: annot -> Op annot
op_annot :: Op annot -> annot

-- | 'not in'
NotIn :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '|'
BinaryOr :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '^'
Xor :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '&amp;'
BinaryAnd :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '&lt;&lt;'
ShiftLeft :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '&gt;&gt;'
ShiftRight :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '*'
Multiply :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '+'
Plus :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '-'
Minus :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '/'
Divide :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '//'
FloorDivide :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '~' (bitwise inversion of its integer argument)
Invert :: annot -> Op annot
op_annot :: Op annot -> annot

-- | '%'
Modulo :: annot -> Op annot
op_annot :: Op annot -> annot
type OpSpan = Op SrcSpan

-- | Arguments to function calls, class declarations and decorators.
data Argument annot

-- | Ordinary argument expression.
ArgExpr :: Expr annot -> annot -> Argument annot

-- | Argument expression.
arg_expr :: Argument annot -> Expr annot
arg_annot :: Argument annot -> annot

-- | Excess positional argument.
ArgVarArgsPos :: Expr annot -> annot -> Argument annot

-- | Argument expression.
arg_expr :: Argument annot -> Expr annot
arg_annot :: Argument annot -> annot

-- | Excess keyword argument.
ArgVarArgsKeyword :: Expr annot -> annot -> Argument annot

-- | Argument expression.
arg_expr :: Argument annot -> Expr annot
arg_annot :: Argument annot -> annot

-- | Keyword argument.
ArgKeyword :: Ident annot -> Expr annot -> annot -> Argument annot

-- | Keyword name.
arg_keyword :: Argument annot -> Ident annot

-- | Argument expression.
arg_expr :: Argument annot -> Expr annot
arg_annot :: Argument annot -> annot
type ArgumentSpan = Argument SrcSpan

-- | Slice compenent.
data Slice annot
SliceProper :: Maybe (Expr annot) -> Maybe (Expr annot) -> Maybe (Maybe (Expr annot)) -> annot -> Slice annot
slice_lower :: Slice annot -> Maybe (Expr annot)
slice_upper :: Slice annot -> Maybe (Expr annot)
slice_stride :: Slice annot -> Maybe (Maybe (Expr annot))
slice_annot :: Slice annot -> annot
SliceExpr :: Expr annot -> annot -> Slice annot
slice_expr :: Slice annot -> Expr annot
slice_annot :: Slice annot -> annot
SliceEllipsis :: annot -> Slice annot
slice_annot :: Slice annot -> annot
type SliceSpan = Slice SrcSpan
data DictMappingPair annot
DictMappingPair :: (Expr annot) -> (Expr annot) -> DictMappingPair annot
type DictMappingPairSpan = DictMappingPair SrcSpan
data YieldArg annot

-- | Yield from a generator (Version 3 only)
YieldFrom :: (Expr annot) -> annot -> YieldArg annot

-- | Yield value of an expression
YieldExpr :: (Expr annot) -> YieldArg annot
type YieldArgSpan = YieldArg SrcSpan

-- | An entity imported using the 'import' keyword.
--   
--   <ul>
--   <li>Version 2.6
--   <a>http://www.python.org/doc/2.6/reference/simple_stmts.html#the-import-statement</a><ul><li>Version
--   3.1
--   <a>http://www.python.org/doc/3.1/reference/simple_stmts.html#the-import-statement</a></li></ul></li>
--   </ul>
data ImportItem annot
ImportItem :: DottedName annot -> Maybe (Ident annot) -> annot -> ImportItem annot

-- | The name of module to import.
import_item_name :: ImportItem annot -> DottedName annot

-- | An optional name to refer to the entity (the 'as' name).
import_as_name :: ImportItem annot -> Maybe (Ident annot)
import_item_annot :: ImportItem annot -> annot
type ImportItemSpan = ImportItem SrcSpan

-- | An entity imported using the 'from ... import' construct.
--   
--   <ul>
--   <li>Version 2.6
--   <a>http://www.python.org/doc/2.6/reference/simple_stmts.html#the-import-statement</a></li>
--   <li>Version 3.1
--   <a>http://www.python.org/doc/3.1/reference/simple_stmts.html#the-import-statement</a></li>
--   </ul>
data FromItem annot
FromItem :: Ident annot -> Maybe (Ident annot) -> annot -> FromItem annot

-- | The name of the entity imported.
from_item_name :: FromItem annot -> Ident annot

-- | An optional name to refer to the entity (the 'as' name).
from_as_name :: FromItem annot -> Maybe (Ident annot)
from_item_annot :: FromItem annot -> annot
type FromItemSpan = FromItem SrcSpan

-- | Items imported using the 'from ... import' construct.
data FromItems annot

-- | Import everything exported from the module.
ImportEverything :: annot -> FromItems annot
from_items_annot :: FromItems annot -> annot

-- | Import a specific list of items from the module.
FromItems :: [FromItem annot] -> annot -> FromItems annot
from_items_items :: FromItems annot -> [FromItem annot]
from_items_annot :: FromItems annot -> annot
type FromItemsSpan = FromItems SrcSpan

-- | A reference to the module to import from using the 'from ... import'
--   construct.
data ImportRelative annot
ImportRelative :: Int -> Maybe (DottedName annot) -> annot -> ImportRelative annot
import_relative_dots :: ImportRelative annot -> Int
import_relative_module :: ImportRelative annot -> Maybe (DottedName annot)
import_relative_annot :: ImportRelative annot -> annot
type ImportRelativeSpan = ImportRelative SrcSpan

-- | Exception handler.
data Handler annot
Handler :: ExceptClause annot -> Suite annot -> annot -> Handler annot
handler_clause :: Handler annot -> ExceptClause annot
handler_suite :: Handler annot -> Suite annot
handler_annot :: Handler annot -> annot
type HandlerSpan = Handler SrcSpan

-- | Exception clause.
data ExceptClause annot
ExceptClause :: Maybe (Expr annot, Maybe (Expr annot)) -> annot -> ExceptClause annot
except_clause :: ExceptClause annot -> Maybe (Expr annot, Maybe (Expr annot))
except_clause_annot :: ExceptClause annot -> annot
type ExceptClauseSpan = ExceptClause SrcSpan

-- | The argument for a <tt>raise</tt> statement.
data RaiseExpr annot

-- | Optional expression to evaluate, and optional 'from' clause.
--   <i>Version 3 only</i>.
RaiseV3 :: (Maybe (Expr annot, Maybe (Expr annot))) -> RaiseExpr annot

-- | <i>Version 2 only</i>.
RaiseV2 :: (Maybe (Expr annot, Maybe (Expr annot, Maybe (Expr annot)))) -> RaiseExpr annot
type RaiseExprSpan = RaiseExpr SrcSpan

-- | Comprehension. In version 3.x this can be used for lists, sets,
--   dictionaries and generators. data Comprehension e annot
data Comprehension annot
Comprehension :: ComprehensionExpr annot -> CompFor annot -> annot -> Comprehension annot
comprehension_expr :: Comprehension annot -> ComprehensionExpr annot
comprehension_for :: Comprehension annot -> CompFor annot
comprehension_annot :: Comprehension annot -> annot
type ComprehensionSpan = Comprehension SrcSpan
data ComprehensionExpr annot
ComprehensionExpr :: (Expr annot) -> ComprehensionExpr annot
ComprehensionDict :: (DictMappingPair annot) -> ComprehensionExpr annot
type ComprehensionExprSpan = ComprehensionExpr SrcSpan

-- | Comprehension 'for' component.
data CompFor annot
CompFor :: [Expr annot] -> Expr annot -> Maybe (CompIter annot) -> annot -> CompFor annot
comp_for_exprs :: CompFor annot -> [Expr annot]
comp_in_expr :: CompFor annot -> Expr annot
comp_for_iter :: CompFor annot -> Maybe (CompIter annot)
comp_for_annot :: CompFor annot -> annot
type CompForSpan = CompFor SrcSpan

-- | Comprehension guard.
data CompIf annot
CompIf :: Expr annot -> Maybe (CompIter annot) -> annot -> CompIf annot
comp_if :: CompIf annot -> Expr annot
comp_if_iter :: CompIf annot -> Maybe (CompIter annot)
comp_if_annot :: CompIf annot -> annot
type CompIfSpan = CompIf SrcSpan

-- | Comprehension iterator (either a 'for' or an 'if').
data CompIter annot
IterFor :: CompFor annot -> annot -> CompIter annot
comp_iter_for :: CompIter annot -> CompFor annot
comp_iter_annot :: CompIter annot -> annot
IterIf :: CompIf annot -> annot -> CompIter annot
comp_iter_if :: CompIter annot -> CompIf annot
comp_iter_annot :: CompIter annot -> annot
type CompIterSpan = CompIter SrcSpan
instance Typeable Ident
instance Typeable ImportItem
instance Typeable FromItem
instance Typeable FromItems
instance Typeable ImportRelative
instance Typeable ParamTuple
instance Typeable Op
instance Typeable Expr
instance Typeable Slice
instance Typeable DictMappingPair
instance Typeable YieldArg
instance Typeable Comprehension
instance Typeable CompFor
instance Typeable CompIter
instance Typeable CompIf
instance Typeable ComprehensionExpr
instance Typeable Argument
instance Typeable Parameter
instance Typeable ExceptClause
instance Typeable Decorator
instance Typeable RaiseExpr
instance Typeable AssignOp
instance Typeable Statement
instance Typeable Handler
instance Typeable Module
instance Eq annot => Eq (Ident annot)
instance Ord annot => Ord (Ident annot)
instance Show annot => Show (Ident annot)
instance Data annot => Data (Ident annot)
instance Functor Ident
instance Eq annot => Eq (ImportItem annot)
instance Ord annot => Ord (ImportItem annot)
instance Show annot => Show (ImportItem annot)
instance Data annot => Data (ImportItem annot)
instance Functor ImportItem
instance Eq annot => Eq (FromItem annot)
instance Ord annot => Ord (FromItem annot)
instance Show annot => Show (FromItem annot)
instance Data annot => Data (FromItem annot)
instance Functor FromItem
instance Eq annot => Eq (FromItems annot)
instance Ord annot => Ord (FromItems annot)
instance Show annot => Show (FromItems annot)
instance Data annot => Data (FromItems annot)
instance Functor FromItems
instance Eq annot => Eq (ImportRelative annot)
instance Ord annot => Ord (ImportRelative annot)
instance Show annot => Show (ImportRelative annot)
instance Data annot => Data (ImportRelative annot)
instance Functor ImportRelative
instance Eq annot => Eq (ParamTuple annot)
instance Ord annot => Ord (ParamTuple annot)
instance Show annot => Show (ParamTuple annot)
instance Data annot => Data (ParamTuple annot)
instance Functor ParamTuple
instance Eq annot => Eq (Op annot)
instance Ord annot => Ord (Op annot)
instance Show annot => Show (Op annot)
instance Data annot => Data (Op annot)
instance Functor Op
instance Eq annot => Eq (Expr annot)
instance Ord annot => Ord (Expr annot)
instance Show annot => Show (Expr annot)
instance Data annot => Data (Expr annot)
instance Functor Expr
instance Eq annot => Eq (Slice annot)
instance Ord annot => Ord (Slice annot)
instance Show annot => Show (Slice annot)
instance Data annot => Data (Slice annot)
instance Functor Slice
instance Eq annot => Eq (DictMappingPair annot)
instance Ord annot => Ord (DictMappingPair annot)
instance Show annot => Show (DictMappingPair annot)
instance Data annot => Data (DictMappingPair annot)
instance Functor DictMappingPair
instance Eq annot => Eq (YieldArg annot)
instance Ord annot => Ord (YieldArg annot)
instance Show annot => Show (YieldArg annot)
instance Data annot => Data (YieldArg annot)
instance Functor YieldArg
instance Eq annot => Eq (Comprehension annot)
instance Ord annot => Ord (Comprehension annot)
instance Show annot => Show (Comprehension annot)
instance Data annot => Data (Comprehension annot)
instance Functor Comprehension
instance Eq annot => Eq (CompFor annot)
instance Ord annot => Ord (CompFor annot)
instance Show annot => Show (CompFor annot)
instance Data annot => Data (CompFor annot)
instance Functor CompFor
instance Eq annot => Eq (CompIter annot)
instance Ord annot => Ord (CompIter annot)
instance Show annot => Show (CompIter annot)
instance Data annot => Data (CompIter annot)
instance Functor CompIter
instance Eq annot => Eq (CompIf annot)
instance Ord annot => Ord (CompIf annot)
instance Show annot => Show (CompIf annot)
instance Data annot => Data (CompIf annot)
instance Functor CompIf
instance Eq annot => Eq (ComprehensionExpr annot)
instance Ord annot => Ord (ComprehensionExpr annot)
instance Show annot => Show (ComprehensionExpr annot)
instance Data annot => Data (ComprehensionExpr annot)
instance Functor ComprehensionExpr
instance Eq annot => Eq (Argument annot)
instance Ord annot => Ord (Argument annot)
instance Show annot => Show (Argument annot)
instance Data annot => Data (Argument annot)
instance Functor Argument
instance Eq annot => Eq (Parameter annot)
instance Ord annot => Ord (Parameter annot)
instance Show annot => Show (Parameter annot)
instance Data annot => Data (Parameter annot)
instance Functor Parameter
instance Eq annot => Eq (ExceptClause annot)
instance Ord annot => Ord (ExceptClause annot)
instance Show annot => Show (ExceptClause annot)
instance Data annot => Data (ExceptClause annot)
instance Functor ExceptClause
instance Eq annot => Eq (Decorator annot)
instance Ord annot => Ord (Decorator annot)
instance Show annot => Show (Decorator annot)
instance Data annot => Data (Decorator annot)
instance Functor Decorator
instance Eq annot => Eq (RaiseExpr annot)
instance Ord annot => Ord (RaiseExpr annot)
instance Show annot => Show (RaiseExpr annot)
instance Data annot => Data (RaiseExpr annot)
instance Functor RaiseExpr
instance Eq annot => Eq (AssignOp annot)
instance Ord annot => Ord (AssignOp annot)
instance Show annot => Show (AssignOp annot)
instance Data annot => Data (AssignOp annot)
instance Functor AssignOp
instance Eq annot => Eq (Statement annot)
instance Ord annot => Ord (Statement annot)
instance Show annot => Show (Statement annot)
instance Data annot => Data (Statement annot)
instance Functor Statement
instance Eq annot => Eq (Handler annot)
instance Ord annot => Ord (Handler annot)
instance Show annot => Show (Handler annot)
instance Data annot => Data (Handler annot)
instance Functor Handler
instance Eq annot => Eq (Module annot)
instance Ord annot => Ord (Module annot)
instance Show annot => Show (Module annot)
instance Data annot => Data (Module annot)
instance Functor Module
instance Annotated AssignOp
instance Span AssignOpSpan
instance Annotated Op
instance Span OpSpan
instance Annotated Slice
instance Span SliceSpan
instance Span DictMappingPairSpan
instance Annotated Expr
instance Span YieldArgSpan
instance Span ExprSpan
instance Annotated CompIter
instance Span CompIterSpan
instance Annotated CompIf
instance Span CompIfSpan
instance Annotated CompFor
instance Span CompForSpan
instance Span ComprehensionExprSpan
instance Annotated Comprehension
instance Span ComprehensionSpan
instance Annotated ExceptClause
instance Span ExceptClauseSpan
instance Annotated Handler
instance Span HandlerSpan
instance Annotated Argument
instance Span ArgumentSpan
instance Annotated ParamTuple
instance Span ParamTupleSpan
instance Annotated Parameter
instance Span ParameterSpan
instance Annotated Decorator
instance Span DecoratorSpan
instance Annotated Statement
instance Span StatementSpan
instance Annotated ImportRelative
instance Span ImportRelativeSpan
instance Annotated FromItems
instance Span FromItemsSpan
instance Annotated FromItem
instance Span FromItemSpan
instance Annotated ImportItem
instance Span ImportItemSpan
instance Annotated Ident
instance Span IdentSpan


-- | Pretty printing of the Python abstract syntax (version 2.x and 3.x).
module Language.Python.Common.PrettyAST
instance Pretty (AssignOp a)
instance Pretty (Op a)
instance Pretty (Slice a)
instance Pretty (DictMappingPair a)
instance Pretty (YieldArg a)
instance Pretty (Expr a)
instance Pretty (CompIter a)
instance Pretty (CompIf a)
instance Pretty (CompFor a)
instance Pretty (ComprehensionExpr a)
instance Pretty (Comprehension a)
instance Pretty (Argument a)
instance Pretty (ParamTuple a)
instance Pretty (Parameter a)
instance Pretty (Decorator a)
instance Pretty (RaiseExpr a)
instance Pretty (ExceptClause a)
instance Pretty (Handler a)
instance Pretty (Statement a)
instance Pretty (ImportRelative a)
instance Pretty (FromItems a)
instance Pretty (FromItem a)
instance Pretty (ImportItem a)
instance Pretty (Ident a)
instance Pretty (Module a)


-- | Pretty printing of tokens. Note the output is intended for displaying
--   in messages to the user, and may not be valid Python syntax. For
--   instance the pretty printing is useful for displaying parser error
--   messages, but not useful for producing concrete Python source.
module Language.Python.Common.PrettyToken
instance Pretty Token


-- | Error values for the lexer and parser.
module Language.Python.Common.ParseError
data ParseError

-- | An error from the parser. Token found where it should not be. Note:
--   tokens contain their own source span.
UnexpectedToken :: Token -> ParseError

-- | An error from the lexer. Character found where it should not be.
UnexpectedChar :: Char -> SrcLocation -> ParseError

-- | A generic error containing a string message. No source location.
StrError :: String -> ParseError
instance Eq ParseError
instance Ord ParseError
instance Show ParseError
instance Error ParseError


-- | Pretty printing of parse errors.
module Language.Python.Common.PrettyParseError
instance Pretty ParseError


-- | Monad support for Python parser and lexer.
module Language.Python.Common.ParserMonad
type P a = StateT ParseState (Either ParseError) a
execParser :: P a -> ParseState -> Either ParseError a
execParserKeepComments :: P a -> ParseState -> Either ParseError (a, [Token])
runParser :: P a -> ParseState -> Either ParseError (a, ParseState)
thenP :: P a -> (a -> P b) -> P b
returnP :: a -> P a
setLocation :: SrcLocation -> P ()
getLocation :: P SrcLocation
getInput :: P String
setInput :: String -> P ()
getLastToken :: P Token
setLastToken :: Token -> P ()
setLastEOL :: SrcSpan -> P ()
getLastEOL :: P SrcSpan
data ParseError

-- | An error from the parser. Token found where it should not be. Note:
--   tokens contain their own source span.
UnexpectedToken :: Token -> ParseError

-- | An error from the lexer. Character found where it should not be.
UnexpectedChar :: Char -> SrcLocation -> ParseError

-- | A generic error containing a string message. No source location.
StrError :: String -> ParseError
data ParseState
ParseState :: !SrcLocation -> !String -> !Token -> [Int] -> [Int] -> [Token] -> !SrcSpan -> [Token] -> ParseState
location :: ParseState -> !SrcLocation
input :: ParseState -> !String
previousToken :: ParseState -> !Token
startCodeStack :: ParseState -> [Int]
indentStack :: ParseState -> [Int]
parenStack :: ParseState -> [Token]
lastEOL :: ParseState -> !SrcSpan
comments :: ParseState -> [Token]
initialState :: SrcLocation -> String -> [Int] -> ParseState
pushStartCode :: Int -> P ()
popStartCode :: P ()
getStartCode :: P Int
getIndent :: P Int
pushIndent :: Int -> P ()
popIndent :: P ()
getIndentStackDepth :: P Int
getParen :: P (Maybe Token)
pushParen :: Token -> P ()
popParen :: P ()
getParenStackDepth :: P Int
addComment :: Token -> P ()
getComments :: P [Token]
spanError :: Span a => a -> String -> P b
instance Show ParseState


-- | Lexical analysis for Python version 3.x programs. See:
--   <a>http://www.python.org/doc/3.1/reference/lexical_analysis.html</a>.
module Language.Python.Version3.Lexer

-- | Parse a string into a list of Python Tokens, or return an error.
lex :: String -> String -> Either ParseError [Token]

-- | Try to lex the first token in an input string. Return either a parse
--   error or a pair containing the next token and the rest of the input
--   after the token.
lexOneToken :: String -> String -> Either ParseError (Token, String)

-- | Lex a sequence of tokens.
lexer :: P [Token]
initLexState :: String -> String -> ParseState


-- | A parser for Python version 3.x programs. Parsers are provided for
--   modules, statements, and expressions. The parsers produce comment
--   tokens in addition to the abstract syntax tree.
--   
--   See:
--   
--   <ul>
--   <li><a>http://www.python.org/doc/3.1/reference/index.html</a> for an
--   overview of the language.</li>
--   <li><a>http://www.python.org/doc/3.1/reference/grammar.html</a> for
--   the full grammar.</li>
--   
--   <li><a>http://www.python.org/doc/3.1/reference/toplevel_components.html</a>
--   for a description of the various Python top-levels, which correspond
--   to the parsers provided here.</li>
--   </ul>
module Language.Python.Version3.Parser

-- | Parse a whole Python source file. Return comments in addition to the
--   parsed module.
parseModule :: String -> String -> Either ParseError (ModuleSpan, [Token])

-- | Parse one compound statement, or a sequence of simple statements.
--   Generally used for interactive input, such as from the command line of
--   an interpreter. Return comments in addition to the parsed statements.
parseStmt :: String -> String -> Either ParseError ([StatementSpan], [Token])

-- | Parse an expression. Generally used as input for the 'eval' primitive.
--   Return comments in addition to the parsed expression.
parseExpr :: String -> String -> Either ParseError (ExprSpan, [Token])


-- | A convenient re-export of the parser and lexer for version 3.x of
--   Python.
--   
--   See:
--   
--   <ul>
--   <li><a>http://www.python.org/doc/3.1/reference/index.html</a> for an
--   overview of the language.</li>
--   <li><a>http://www.python.org/doc/3.1/reference/grammar.html</a> for
--   the full grammar.</li>
--   
--   <li><a>http://www.python.org/doc/3.1/reference/toplevel_components.html</a>
--   for a description of the various Python top-levels, which correspond
--   to the parsers provided here.</li>
--   </ul>
module Language.Python.Version3


-- | Lexical analysis for Python version 2.x programs. See:
--   <a>http://www.python.org/doc/2.6/reference/lexical_analysis.html</a>.
module Language.Python.Version2.Lexer

-- | Parse a string into a list of Python Tokens, or return an error.
lex :: String -> String -> Either ParseError [Token]

-- | Try to lex the first token in an input string. Return either a parse
--   error or a pair containing the next token and the rest of the input
--   after the token.
lexOneToken :: String -> String -> Either ParseError (Token, String)


-- | A parser for Python version 2.x programs. Parsers are provided for
--   modules, statements, and expressions. The parsers produce comment
--   tokens in addition to the abstract syntax tree.
--   
--   See:
--   
--   <ul>
--   <li><a>http://www.python.org/doc/2.6/reference/index.html</a> for an
--   overview of the language.</li>
--   <li><a>http://www.python.org/doc/2.6/reference/grammar.html</a> for
--   the full grammar.</li>
--   
--   <li><a>http://www.python.org/doc/2.6/reference/toplevel_components.html</a>
--   for a description of the various Python top-levels, which correspond
--   to the parsers provided here.</li>
--   </ul>
module Language.Python.Version2.Parser

-- | Parse a whole Python source file. Return comments in addition to the
--   parsed module.
parseModule :: String -> String -> Either ParseError (ModuleSpan, [Token])

-- | Parse one compound statement, or a sequence of simple statements.
--   Generally used for interactive input, such as from the command line of
--   an interpreter. Return comments in addition to the parsed statements.
parseStmt :: String -> String -> Either ParseError ([StatementSpan], [Token])

-- | Parse an expression. Generally used as input for the 'eval' primitive.
--   Return comments in addition to the parsed expression.
parseExpr :: String -> String -> Either ParseError (ExprSpan, [Token])


-- | A convenient re-export of the parser and lexer for version 2.x of
--   Python.
--   
--   See:
--   
--   <ul>
--   <li><a>http://www.python.org/doc/2.6/reference/index.html</a> for an
--   overview of the language.</li>
--   <li><a>http://www.python.org/doc/2.6/reference/grammar.html</a> for
--   the full grammar.</li>
--   
--   <li><a>http://www.python.org/doc/2.6/reference/toplevel_components.html</a>
--   for a description of the various Python top-levels, which correspond
--   to the parsers provided here.</li>
--   </ul>
module Language.Python.Version2


-- | Convenient re-export of common code, which works with both version 2.x
--   and 3.x of Python.
module Language.Python.Common
