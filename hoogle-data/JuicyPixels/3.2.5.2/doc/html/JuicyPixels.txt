-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)
--   
@package JuicyPixels
@version 3.2.5.2


-- | This module provide a totally partial and incomplete maping of Exif
--   values. Used for Tiff parsing and reused for Exif extraction.
module Codec.Picture.Metadata.Exif

-- | Tag values used for exif fields. Completly incomplete
data ExifTag
TagPhotometricInterpretation :: ExifTag

-- | Short type
TagCompression :: ExifTag

-- | Short or long type
TagImageWidth :: ExifTag

-- | Short or long type
TagImageLength :: ExifTag

-- | Rational type
TagXResolution :: ExifTag

-- | Rational type
TagYResolution :: ExifTag
TagResolutionUnit :: ExifTag

-- | Short or long type
TagRowPerStrip :: ExifTag

-- | Short or long
TagStripByteCounts :: ExifTag

-- | Short or long
TagStripOffsets :: ExifTag
TagBitsPerSample :: ExifTag

-- | Short
TagColorMap :: ExifTag
TagTileWidth :: ExifTag
TagTileLength :: ExifTag
TagTileOffset :: ExifTag
TagTileByteCount :: ExifTag

-- | Short
TagSamplesPerPixel :: ExifTag
TagArtist :: ExifTag
TagDocumentName :: ExifTag
TagSoftware :: ExifTag

-- | Short
TagPlanarConfiguration :: ExifTag
TagOrientation :: ExifTag

-- | Short
TagSampleFormat :: ExifTag
TagInkSet :: ExifTag
TagSubfileType :: ExifTag
TagFillOrder :: ExifTag
TagYCbCrCoeff :: ExifTag
TagYCbCrSubsampling :: ExifTag
TagYCbCrPositioning :: ExifTag
TagReferenceBlackWhite :: ExifTag
TagXPosition :: ExifTag
TagYPosition :: ExifTag
TagExtraSample :: ExifTag
TagImageDescription :: ExifTag
TagPredictor :: ExifTag
TagCopyright :: ExifTag
TagMake :: ExifTag
TagModel :: ExifTag
TagDateTime :: ExifTag
TagGPSInfo :: ExifTag
TagJpegProc :: ExifTag
TagJPEGInterchangeFormat :: ExifTag
TagJPEGInterchangeFormatLength :: ExifTag
TagJPEGRestartInterval :: ExifTag
TagJPEGLosslessPredictors :: ExifTag
TagJPEGPointTransforms :: ExifTag
TagJPEGQTables :: ExifTag
TagJPEGDCTables :: ExifTag
TagJPEGACTables :: ExifTag
TagExifOffset :: ExifTag
TagUnknown :: !Word16 -> ExifTag

-- | Possible data held by an Exif tag
data ExifData
ExifNone :: ExifData
ExifLong :: !Word32 -> ExifData
ExifShort :: !Word16 -> ExifData
ExifString :: !ByteString -> ExifData
ExifUndefined :: !ByteString -> ExifData
ExifShorts :: !(Vector Word16) -> ExifData
ExifLongs :: !(Vector Word32) -> ExifData
ExifRational :: !Word32 -> !Word32 -> ExifData
ExifSignedRational :: !Int32 -> !Int32 -> ExifData
ExifIFD :: ![(ExifTag, ExifData)] -> ExifData

-- | Convert a value to it's corresponding Exif tag. Will often be written
--   as <a>TagUnknown</a>
tagOfWord16 :: Word16 -> ExifTag

-- | Convert a tag to it's corresponding value.
word16OfTag :: ExifTag -> Word16
instance Eq ExifTag
instance Ord ExifTag
instance Show ExifTag
instance Show ExifData
instance NFData ExifData
instance NFData ExifTag


-- | Module providing the basic types for image manipulation in the
--   library. Defining the types used to store all those _Juicy Pixels_
module Codec.Picture.Types

-- | The main type of this package, one that most functions work on, is
--   Image.
--   
--   Parameterized by the underlying pixel format it forms a rigid type. If
--   you wish to store images of different or unknown pixel formats use
--   <a>DynamicImage</a>.
--   
--   Image is essentially a rectangular pixel buffer of specified width and
--   height. The coordinates are assumed to start from the upper-left
--   corner of the image, with the horizontal position first and vertical
--   second.
data Image a
Image :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Vector (PixelBaseComponent a) -> Image a

-- | Width of the image in pixels
imageWidth :: Image a -> {-# UNPACK #-} !Int

-- | Height of the image in pixels.
imageHeight :: Image a -> {-# UNPACK #-} !Int

-- | Image pixel data. To extract pixels at a given position you should use
--   the helper functions.
--   
--   Internally pixel data is stored as consecutively packed lines from top
--   to bottom, scanned from left to right within individual lines, from
--   first to last color component within each pixel.
imageData :: Image a -> Vector (PixelBaseComponent a)

-- | Image or pixel buffer, the coordinates are assumed to start from the
--   upper-left corner of the image, with the horizontal position first,
--   then the vertical one. The image can be transformed in place.
data MutableImage s a
MutableImage :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> STVector s (PixelBaseComponent a) -> MutableImage s a

-- | Width of the image in pixels
mutableImageWidth :: MutableImage s a -> {-# UNPACK #-} !Int

-- | Height of the image in pixels.
mutableImageHeight :: MutableImage s a -> {-# UNPACK #-} !Int

-- | The real image, to extract pixels at some position you should use the
--   helpers functions.
mutableImageData :: MutableImage s a -> STVector s (PixelBaseComponent a)

-- | Image type enumerating all predefined pixel types. It enables loading
--   and use of images of different pixel types.
data DynamicImage

-- | A greyscale image.
ImageY8 :: (Image Pixel8) -> DynamicImage

-- | A greyscale image with 16bit components
ImageY16 :: (Image Pixel16) -> DynamicImage

-- | A greyscale HDR image
ImageYF :: (Image PixelF) -> DynamicImage

-- | An image in greyscale with an alpha channel.
ImageYA8 :: (Image PixelYA8) -> DynamicImage

-- | An image in greyscale with alpha channel on 16 bits.
ImageYA16 :: (Image PixelYA16) -> DynamicImage

-- | An image in true color.
ImageRGB8 :: (Image PixelRGB8) -> DynamicImage

-- | An image in true color with 16bit depth.
ImageRGB16 :: (Image PixelRGB16) -> DynamicImage

-- | An image with HDR pixels
ImageRGBF :: (Image PixelRGBF) -> DynamicImage

-- | An image in true color and an alpha channel.
ImageRGBA8 :: (Image PixelRGBA8) -> DynamicImage

-- | A true color image with alpha on 16 bits.
ImageRGBA16 :: (Image PixelRGBA16) -> DynamicImage

-- | An image in the colorspace used by Jpeg images.
ImageYCbCr8 :: (Image PixelYCbCr8) -> DynamicImage

-- | An image in the colorspace CMYK
ImageCMYK8 :: (Image PixelCMYK8) -> DynamicImage

-- | An image in the colorspace CMYK and 16 bits precision
ImageCMYK16 :: (Image PixelCMYK16) -> DynamicImage

-- | Type for the palette used in Gif &amp; PNG files.
type Palette = Image PixelRGB8

-- | Create a mutable image, filled with the given background color.
createMutableImage :: (Pixel px, PrimMonad m) => Int -> Int -> px -> m (MutableImage (PrimState m) px)

-- | Create a mutable image with garbage as content. All data is
--   uninitialized.
newMutableImage :: (Pixel px, PrimMonad m) => Int -> Int -> m (MutableImage (PrimState m) px)

-- | `O(n)` Yield an immutable copy of an image by making a copy of it
freezeImage :: (Storable (PixelBaseComponent px), PrimMonad m) => MutableImage (PrimState m) px -> m (Image px)

-- | `O(1)` Unsafe convert a mutable image to an immutable one without
--   copying. The mutable image may not be used after this operation.
unsafeFreezeImage :: (Storable (PixelBaseComponent a), PrimMonad m) => MutableImage (PrimState m) a -> m (Image a)

-- | `O(n)` Yield a mutable copy of an image by making a copy of it.
thawImage :: (Storable (PixelBaseComponent px), PrimMonad m) => Image px -> m (MutableImage (PrimState m) px)

-- | `O(1)` Unsafe convert an imutable image to an mutable one without
--   copying. The source image shouldn't be used after this operation.
unsafeThawImage :: (Storable (PixelBaseComponent px), PrimMonad m) => Image px -> m (MutableImage (PrimState m) px)

-- | Traversal type matching the definition in the Lens package.
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | Traversal in "raster" order, from left to right the top to bottom.
--   This traversal is matching pixelMap in spirit.
--   
--   Since 3.2.4
imagePixels :: (Pixel pxa, Pixel pxb) => Traversal (Image pxa) (Image pxb) pxa pxb

-- | Traversal providing the pixel position with it's value. The traversal
--   in raster order, from lef to right, then top to bottom. The traversal
--   match pixelMapXY in spirit.
--   
--   Since 3.2.4
imageIPixels :: (Pixel pxa, Pixel pxb) => Traversal (Image pxa) (Image pxb) (Int, Int, pxa) pxb

-- | Type alias for 8bit greyscale pixels. For simplicity, greyscale pixels
--   use plain numbers instead of a separate type.
type Pixel8 = Word8

-- | Type alias for 16bit greyscale pixels.
type Pixel16 = Word16

-- | Type alias for 32bit greyscale pixels.
type Pixel32 = Word32

-- | Type alias for 32bit floating point greyscale pixels. The standard
--   bounded value range is mapped to the closed interval [0,1] i.e.
--   
--   <pre>
--   map promotePixel [0, 1 .. 255 :: Pixel8] == [0/255, 1/255 .. 1.0 :: PixelF]
--   </pre>
type PixelF = Float

-- | Pixel type storing 8bit Luminance (Y) and alpha (A) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Luminance</li>
--   <li>Alpha</li>
--   </ul>
data PixelYA8
PixelYA8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYA8

-- | Pixel type storing 16bit Luminance (Y) and alpha (A) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Luminance</li>
--   <li>Alpha</li>
--   </ul>
data PixelYA16
PixelYA16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelYA16

-- | Classic pixel type storing 8bit red, green and blue (RGB) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGB8
PixelRGB8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelRGB8

-- | Pixel type storing 16bit red, green and blue (RGB) information. Values
--   are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGB16
PixelRGB16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelRGB16

-- | HDR pixel type storing floating point 32bit red, green and blue (RGB)
--   information. Same value range and comments apply as for <a>PixelF</a>.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGBF
PixelRGBF :: {-# UNPACK #-} !PixelF -> {-# UNPACK #-} !PixelF -> {-# UNPACK #-} !PixelF -> PixelRGBF

-- | Classical pixel type storing 8bit red, green, blue and alpha (RGBA)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   <li>Alpha</li>
--   </ul>
data PixelRGBA8
PixelRGBA8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelRGBA8

-- | Pixel type storing 16bit red, green, blue and alpha (RGBA)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   <li>Alpha</li>
--   </ul>
data PixelRGBA16
PixelRGBA16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelRGBA16

-- | Pixel type storing 8bit cyan, magenta, yellow and black (CMYK)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Cyan</li>
--   <li>Magenta</li>
--   <li>Yellow</li>
--   <li>Black</li>
--   </ul>
data PixelCMYK8
PixelCMYK8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelCMYK8

-- | Pixel type storing 16bit cyan, magenta, yellow and black (CMYK)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Cyan</li>
--   <li>Magenta</li>
--   <li>Yellow</li>
--   <li>Black</li>
--   </ul>
data PixelCMYK16
PixelCMYK16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelCMYK16

-- | Pixel type storing 8bit luminance, blue difference and red difference
--   (YCbCr) information. Values are stored in the following order:
--   
--   <ul>
--   <li>Y (luminance)</li>
--   <li>Cb</li>
--   <li>Cr</li>
--   </ul>
data PixelYCbCr8
PixelYCbCr8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYCbCr8

-- | Pixel type storing value for the YCCK color space:
--   
--   <ul>
--   <li>Y (Luminance)</li>
--   <li>Cb</li>
--   <li>Cr</li>
--   <li>Black</li>
--   </ul>
data PixelYCbCrK8
PixelYCbCrK8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYCbCrK8

-- | Implement upcasting for pixel types. Minimal declaration of
--   <a>promotePixel</a>. It is strongly recommended to overload
--   promoteImage to keep performance acceptable
class (Pixel a, Pixel b) => ColorConvertible a b where promoteImage = pixelMap promotePixel
promotePixel :: ColorConvertible a b => a -> b
promoteImage :: ColorConvertible a b => Image a -> Image b

-- | Definition of pixels used in images. Each pixel has a color space, and
--   a representative component (Word8 or Float).
class (Storable (PixelBaseComponent a), Num (PixelBaseComponent a), Eq a) => Pixel a where type family PixelBaseComponent a :: * mixWithAlpha f _ = mixWith f pixelBaseIndex (Image {imageWidth = w}) x y = (x + y * w) * componentCount (undefined :: a) mutablePixelBaseIndex (MutableImage {mutableImageWidth = w}) x y = (x + y * w) * componentCount (undefined :: a)
mixWith :: Pixel a => (Int -> PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> a -> a -> a
mixWithAlpha :: Pixel a => (Int -> PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> (PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> a -> a -> a
pixelOpacity :: Pixel a => a -> PixelBaseComponent a
componentCount :: Pixel a => a -> Int
colorMap :: Pixel a => (PixelBaseComponent a -> PixelBaseComponent a) -> a -> a
pixelBaseIndex :: Pixel a => Image a -> Int -> Int -> Int
mutablePixelBaseIndex :: Pixel a => MutableImage s a -> Int -> Int -> Int
pixelAt :: Pixel a => Image a -> Int -> Int -> a
readPixel :: (Pixel a, PrimMonad m) => MutableImage (PrimState m) a -> Int -> Int -> m a
writePixel :: (Pixel a, PrimMonad m) => MutableImage (PrimState m) a -> Int -> Int -> a -> m ()
unsafePixelAt :: Pixel a => Vector (PixelBaseComponent a) -> Int -> a
unsafeReadPixel :: (Pixel a, PrimMonad m) => STVector (PrimState m) (PixelBaseComponent a) -> Int -> m a
unsafeWritePixel :: (Pixel a, PrimMonad m) => STVector (PrimState m) (PixelBaseComponent a) -> Int -> a -> m ()

-- | This class abstract colorspace conversion. This conversion can be
--   lossy, which ColorConvertible cannot
class (Pixel a, Pixel b) => ColorSpaceConvertible a b where convertImage = pixelMap convertPixel
convertPixel :: ColorSpaceConvertible a b => a -> b
convertImage :: ColorSpaceConvertible a b => Image a -> Image b

-- | Helper class to help extract a luma plane out of an image or a pixel
class (Pixel a, Pixel (PixelBaseComponent a)) => LumaPlaneExtractable a where extractLumaPlane = pixelMap computeLuma
computeLuma :: LumaPlaneExtractable a => a -> PixelBaseComponent a
extractLumaPlane :: LumaPlaneExtractable a => Image a -> Image (PixelBaseComponent a)

-- | Class modeling transparent pixel, should provide a method to combine
--   transparent pixels
class (Pixel a, Pixel b) => TransparentPixel a b | a -> b
dropTransparency :: TransparentPixel a b => a -> b
getTransparency :: TransparentPixel a b => a -> PixelBaseComponent a

-- | <a>map</a> equivalent for an image, working at the pixel level. Little
--   example : a brightness function for an rgb image
--   
--   <pre>
--   brightnessRGB8 :: Int -&gt; Image PixelRGB8 -&gt; Image PixelRGB8
--   brightnessRGB8 add = pixelMap brightFunction
--        where up v = fromIntegral (fromIntegral v + add)
--              brightFunction (PixelRGB8 r g b) =
--                      PixelRGB8 (up r) (up g) (up b)
--   </pre>
pixelMap :: (Pixel a, Pixel b) => (a -> b) -> Image a -> Image b

-- | Just like <a>pixelMap</a> only the function takes the pixel
--   coordinates as additional parameters.
pixelMapXY :: (Pixel a, Pixel b) => (Int -> Int -> a -> b) -> Image a -> Image b

-- | Fold over the pixel of an image with a raster scan order: from top to
--   bottom, left to right
pixelFold :: Pixel pixel => (acc -> Int -> Int -> pixel -> acc) -> acc -> Image pixel -> acc

-- | Fold over the pixel of an image with a raster scan order: from top to
--   bottom, left to right, carrying out a state
pixelFoldM :: (Pixel pixel, Monad m) => (acc -> Int -> Int -> pixel -> m acc) -> acc -> Image pixel -> m acc

-- | Fold over the pixel of an image with a raster scan order: from top to
--   bottom, left to right. This functions is analog to the foldMap from
--   the <tt>Foldable</tt> typeclass, but due to the Pixel constraint,
--   Image cannot be made an instance of it.
pixelFoldMap :: (Pixel px, Monoid m) => (px -> m) -> Image px -> m

-- | Helper function to help extract information from dynamic image. To get
--   the width of a dynamic image, you can use the following snippet:
--   
--   <pre>
--   dynWidth :: DynamicImage -&gt; Int
--   dynWidth img = dynamicMap imageWidth img
--   </pre>
dynamicMap :: (forall pixel. Pixel pixel => Image pixel -> a) -> DynamicImage -> a

-- | Equivalent of the <a>pixelMap</a> function for the dynamic images. You
--   can perform pixel colorspace independant operations with this
--   function.
--   
--   For instance, if you want to extract a square crop of any image,
--   without caring about colorspace, you can use the following snippet.
--   
--   <pre>
--   dynSquare :: DynamicImage -&gt; DynamicImage
--   dynSquare = dynamicPixelMap squareImage
--   
--   squareImage :: Pixel a =&gt; Image a -&gt; Image a
--   squareImage img = generateImage (\x y -&gt; pixelAt img x y) edge edge
--      where edge = min (imageWidth img) (imageHeight img)
--   </pre>
dynamicPixelMap :: (forall pixel. Pixel pixel => Image pixel -> Image pixel) -> DynamicImage -> DynamicImage

-- | For any image with an alpha component (transparency), drop it,
--   returning a pure opaque image.
dropAlphaLayer :: TransparentPixel a b => Image a -> Image b

-- | Create an image using a monadic initializer function. The function
--   will receive values from 0 to width-1 for the x parameter and 0 to
--   height-1 for the y parameter. The coordinates 0,0 are the upper left
--   corner of the image, and (width-1, height-1) the lower right corner.
--   
--   The function is called for each pixel in the line from left to right
--   (0 to width - 1) and for each line (0 to height - 1).
withImage :: (Pixel pixel, PrimMonad m) => Int -> Int -> (Int -> Int -> m pixel) -> m (Image pixel)

-- | Combine, pixel by pixel and component by component the values of 3
--   different images. Usage example:
--   
--   <pre>
--   averageBrightNess c1 c2 c3 = clamp $ toInt c1 + toInt c2 + toInt c3
--     where clamp = fromIntegral . min 0 . max 255
--           toInt :: a -&gt; Int
--           toInt = fromIntegral
--   ziPixelComponent3 averageBrightNess img1 img2 img3
--   </pre>
zipPixelComponent3 :: Storable (PixelBaseComponent px) => (PixelBaseComponent px -> PixelBaseComponent px -> PixelBaseComponent px -> PixelBaseComponent px) -> Image px -> Image px -> Image px -> Image px

-- | Create an image given a function to generate pixels. The function will
--   receive values from 0 to width-1 for the x parameter and 0 to height-1
--   for the y parameter. The coordinates 0,0 are the upper left corner of
--   the image, and (width-1, height-1) the lower right corner.
--   
--   for example, to create a small gradient image:
--   
--   <pre>
--   imageCreator :: String -&gt; IO ()
--   imageCreator path = writePng path $ generateImage pixelRenderer 250 300
--      where pixelRenderer x y = PixelRGB8 x y 128
--   </pre>
generateImage :: Pixel a => (Int -> Int -> a) -> Int -> Int -> Image a

-- | Create an image given a function to generate pixels. The function will
--   receive values from 0 to width-1 for the x parameter and 0 to height-1
--   for the y parameter. The coordinates 0,0 are the upper left corner of
--   the image, and (width-1, height-1) the lower right corner.
--   
--   the acc parameter is a user defined one.
--   
--   The function is called for each pixel in the line from left to right
--   (0 to width - 1) and for each line (0 to height - 1).
generateFoldImage :: Pixel a => (acc -> Int -> Int -> (acc, a)) -> acc -> Int -> Int -> (acc, Image a)

-- | Perform a gamma correction for an image with HDR pixels.
gammaCorrection :: PixelF -> Image PixelRGBF -> Image PixelRGBF

-- | Perform a tone mapping operation on an High dynamic range image.
toneMapping :: PixelF -> Image PixelRGBF -> Image PixelRGBF

-- | Class used to describle plane present in the pixel type. If a pixel
--   has a plane description associated, you can use the plane name to
--   extract planes independently.
class ColorPlane pixel planeToken

-- | Define the plane for the red color component
data PlaneRed
PlaneRed :: PlaneRed

-- | Define the plane for the green color component
data PlaneGreen
PlaneGreen :: PlaneGreen

-- | Define the plane for the blue color component
data PlaneBlue
PlaneBlue :: PlaneBlue

-- | Define the plane for the alpha (transparency) component
data PlaneAlpha
PlaneAlpha :: PlaneAlpha

-- | Define the plane for the luma component
data PlaneLuma
PlaneLuma :: PlaneLuma

-- | Define the plane for the Cr component
data PlaneCr
PlaneCr :: PlaneCr

-- | Define the plane for the Cb component
data PlaneCb
PlaneCb :: PlaneCb

-- | Define plane for the cyan component of the CMYK color space.
data PlaneCyan
PlaneCyan :: PlaneCyan

-- | Define plane for the magenta component of the CMYK color space.
data PlaneMagenta
PlaneMagenta :: PlaneMagenta

-- | Define plane for the yellow component of the CMYK color space.
data PlaneYellow
PlaneYellow :: PlaneYellow

-- | Define plane for the black component of the CMYK color space.
data PlaneBlack
PlaneBlack :: PlaneBlack

-- | Extract a color plane from an image given a present plane in the image
--   examples:
--   
--   <pre>
--   extractRedPlane :: Image PixelRGB8 -&gt; Image Pixel8
--   extractRedPlane = extractComponent PlaneRed
--   </pre>
extractComponent :: (Pixel px, Pixel (PixelBaseComponent px), PixelBaseComponent (PixelBaseComponent px) ~ PixelBaseComponent px, ColorPlane px plane) => plane -> Image px -> Image (PixelBaseComponent px)

-- | Extract a plane of an image. Returns the requested color component as
--   a greyscale image.
--   
--   If you ask for a component out of bound, the <a>error</a> function
--   will be called.
unsafeExtractComponent :: (Pixel a, Pixel (PixelBaseComponent a), PixelBaseComponent (PixelBaseComponent a) ~ PixelBaseComponent a) => Int -> Image a -> Image (PixelBaseComponent a)

-- | This typeclass exist for performance reason, it allow to pack a pixel
--   value to a simpler "primitive" data type to allow faster writing to
--   moemory.
class PackeablePixel a where type family PackedRepresentation a
packPixel :: PackeablePixel a => a -> PackedRepresentation a
unpackPixel :: PackeablePixel a => PackedRepresentation a -> a

-- | This function will fill an image with a simple packeable pixel. It
--   will be faster than any unsafeWritePixel.
fillImageWith :: (Pixel px, PackeablePixel px, PrimMonad m, Storable (PackedRepresentation px)) => MutableImage (PrimState m) px -> px -> m ()

-- | Read a packeable pixel from an image. Equivalent to unsafeReadPixel
readPackedPixelAt :: (Pixel px, PackeablePixel px, Storable (PackedRepresentation px), PrimMonad m) => MutableImage (PrimState m) px -> Int -> m px

-- | Write a packeable pixel into an image. equivalent to unsafeWritePixel.
writePackedPixelAt :: (Pixel px, PackeablePixel px, Storable (PackedRepresentation px), PrimMonad m) => MutableImage (PrimState m) px -> Int -> px -> m ()

-- | Fill a packeable pixel between two bounds.
unsafeWritePixelBetweenAt :: (PrimMonad m, Pixel px, PackeablePixel px, Storable (PackedRepresentation px)) => MutableImage (PrimState m) px -> px -> Int -> Int -> m ()
instance Eq PixelYA8
instance Ord PixelYA8
instance Show PixelYA8
instance Eq PixelYA16
instance Ord PixelYA16
instance Show PixelYA16
instance Eq PixelRGB8
instance Ord PixelRGB8
instance Show PixelRGB8
instance Eq PixelYCbCrK8
instance Ord PixelYCbCrK8
instance Show PixelYCbCrK8
instance Eq PixelRGB16
instance Ord PixelRGB16
instance Show PixelRGB16
instance Eq PixelRGBF
instance Ord PixelRGBF
instance Show PixelRGBF
instance Eq PixelYCbCr8
instance Ord PixelYCbCr8
instance Show PixelYCbCr8
instance Eq PixelCMYK8
instance Ord PixelCMYK8
instance Show PixelCMYK8
instance Eq PixelCMYK16
instance Ord PixelCMYK16
instance Show PixelCMYK16
instance Eq PixelRGBA8
instance Ord PixelRGBA8
instance Show PixelRGBA8
instance Eq PixelRGBA16
instance Ord PixelRGBA16
instance Show PixelRGBA16
instance PackeablePixel PixelYA8
instance PackeablePixel PixelYA16
instance PackeablePixel PixelCMYK16
instance PackeablePixel PixelCMYK8
instance PackeablePixel PixelRGBA16
instance PackeablePixel PixelRGBA8
instance PackeablePixel PixelF
instance PackeablePixel Pixel32
instance PackeablePixel Pixel16
instance PackeablePixel Pixel8
instance ColorPlane PixelCMYK16 PlaneBlack
instance ColorPlane PixelCMYK16 PlaneYellow
instance ColorPlane PixelCMYK16 PlaneMagenta
instance ColorPlane PixelCMYK16 PlaneCyan
instance ColorSpaceConvertible PixelCMYK16 PixelRGB16
instance Pixel PixelCMYK16
instance ColorPlane PixelCMYK8 PlaneBlack
instance ColorPlane PixelCMYK8 PlaneYellow
instance ColorPlane PixelCMYK8 PlaneMagenta
instance ColorPlane PixelCMYK8 PlaneCyan
instance ColorSpaceConvertible PixelRGB8 PixelCMYK8
instance ColorSpaceConvertible PixelYCbCrK8 PixelCMYK8
instance ColorSpaceConvertible PixelYCbCrK8 PixelRGB8
instance Pixel PixelYCbCrK8
instance ColorSpaceConvertible PixelCMYK8 PixelRGB8
instance Pixel PixelCMYK8
instance ColorPlane PixelYCbCr8 PlaneCr
instance ColorPlane PixelYCbCr8 PlaneCb
instance ColorPlane PixelYCbCr8 PlaneLuma
instance ColorSpaceConvertible PixelYCbCr8 PixelRGB8
instance ColorSpaceConvertible PixelRGB8 PixelYCbCr8
instance Pixel a => ColorSpaceConvertible a a
instance Pixel PixelYCbCr8
instance ColorPlane PixelRGBA16 PlaneAlpha
instance ColorPlane PixelRGBA16 PlaneBlue
instance ColorPlane PixelRGBA16 PlaneGreen
instance ColorPlane PixelRGBA16 PlaneRed
instance TransparentPixel PixelRGBA16 PixelRGB16
instance Pixel PixelRGBA16
instance ColorPlane PixelRGBA8 PlaneAlpha
instance ColorPlane PixelRGBA8 PlaneBlue
instance ColorPlane PixelRGBA8 PlaneGreen
instance ColorPlane PixelRGBA8 PlaneRed
instance ColorConvertible PixelRGBA8 PixelRGBA16
instance Pixel PixelRGBA8
instance LumaPlaneExtractable PixelRGB8
instance ColorPlane PixelRGB8 PlaneBlue
instance ColorPlane PixelRGB8 PlaneGreen
instance ColorPlane PixelRGB8 PlaneRed
instance ColorConvertible PixelRGB8 PixelRGBA16
instance ColorConvertible PixelRGB8 PixelRGB16
instance ColorConvertible PixelRGB8 PixelRGBF
instance ColorConvertible PixelRGB8 PixelRGBA8
instance Pixel PixelRGB8
instance LumaPlaneExtractable PixelRGB16
instance ColorConvertible PixelRGB16 PixelRGBA16
instance ColorSpaceConvertible PixelRGB16 PixelCMYK16
instance ColorPlane PixelRGB16 PlaneBlue
instance ColorPlane PixelRGB16 PlaneGreen
instance ColorPlane PixelRGB16 PlaneRed
instance Pixel PixelRGB16
instance ColorPlane PixelRGBF PlaneBlue
instance ColorPlane PixelRGBF PlaneGreen
instance ColorPlane PixelRGBF PlaneRed
instance Pixel PixelRGBF
instance TransparentPixel PixelYA16 Pixel16
instance ColorPlane PixelYA16 PlaneAlpha
instance ColorPlane PixelYA16 PlaneLuma
instance ColorConvertible PixelYA16 PixelRGBA16
instance Pixel PixelYA16
instance LumaPlaneExtractable PixelYA8
instance TransparentPixel PixelYA8 Pixel8
instance ColorPlane PixelYA8 PlaneAlpha
instance ColorPlane PixelYA8 PlaneLuma
instance ColorConvertible PixelYA8 PixelRGBA8
instance ColorConvertible PixelYA8 PixelRGB8
instance Pixel PixelYA8
instance ColorConvertible PixelF PixelRGBF
instance Pixel PixelF
instance Pixel Pixel32
instance ColorConvertible Pixel16 PixelRGBA16
instance ColorConvertible Pixel16 PixelRGB16
instance ColorConvertible Pixel16 PixelYA16
instance Pixel Pixel16
instance ColorConvertible Pixel8 PixelRGBA8
instance ColorConvertible Pixel8 PixelRGB8
instance ColorConvertible Pixel8 Pixel16
instance ColorConvertible Pixel8 PixelF
instance ColorConvertible Pixel8 PixelYA8
instance Pixel Pixel8
instance Pixel a => ColorConvertible a a
instance LumaPlaneExtractable PixelYCbCr8
instance LumaPlaneExtractable PixelRGBA8
instance LumaPlaneExtractable PixelRGBF
instance LumaPlaneExtractable PixelF
instance LumaPlaneExtractable Pixel32
instance LumaPlaneExtractable Pixel16
instance LumaPlaneExtractable Pixel8
instance NFData DynamicImage
instance NFData (MutableImage s a)
instance NFData (Image a)
instance TransparentPixel PixelRGBA8 PixelRGB8


-- | This module provide some color quantisation algorithm in order to help
--   in the creation of paletted images. The most important function is
--   <a>palettize</a> which will make everything to create a nice color
--   indexed image with its palette.
module Codec.Picture.ColorQuant

-- | Reduces an image to a color palette according to <tt>PaletteOpts</tt>
--   and returns the <i>indices image</i> along with its <a>Palette</a>.
palettize :: PaletteOptions -> Image PixelRGB8 -> (Image Pixel8, Palette)

-- | Default palette option, which aim at the best quality and maximum
--   possible colors (256)
defaultPaletteOptions :: PaletteOptions

-- | Define which palette creation method is used.
data PaletteCreationMethod

-- | MedianMeanCut method, provide the best results (visualy) at the cost
--   of increased calculations.
MedianMeanCut :: PaletteCreationMethod

-- | Very fast algorithm (one pass), doesn't provide good looking results.
Uniform :: PaletteCreationMethod

-- | To specify how the palette will be created.
data PaletteOptions
PaletteOptions :: PaletteCreationMethod -> Bool -> Int -> PaletteOptions

-- | Algorithm used to find the palette
paletteCreationMethod :: PaletteOptions -> PaletteCreationMethod

-- | Do we want to apply the dithering to the image. Enabling it often
--   reduce compression ratio but enhance the perceived quality of the
--   final image.
enableImageDithering :: PaletteOptions -> Bool

-- | Maximum number of color we want in the palette
paletteColorCount :: PaletteOptions -> Int
instance Ord Cluster
instance Eq Cluster
instance Applicative (Fold a)
instance Functor (Fold a)


-- | This module expose a common "metadata" storage for various image type.
--   Different format can generate different metadatas, and write only a
--   part of them.
--   
--   Since version 3.2.5
module Codec.Picture.Metadata

-- | Dependent storage used for metadatas. All metadatas of a given kind
--   are unique within this container.
--   
--   The current data structure is based on list, so bad performances can
--   be expected.
data Metadatas

-- | Store various additional information about an image. If something is
--   not recognized, it can be stored in an unknown tag.
--   
--   <ul>
--   <li><a>DpiX</a> Dot per inch on this x axis.</li>
--   <li><a>DpiY</a> Dot per inch on this y axis.</li>
--   <li><a>Width</a> Image width in pixel. Relying on the metadata for
--   this information can avoid the full decompression of the image.
--   Ignored for image writing.</li>
--   <li><a>Height</a> Image height in pixels. Relyiung on the metadata for
--   this information can void the full decomrpession of the image. Ignored
--   for image writing.</li>
--   <li><a>Unknown</a> unlikely to be decoded, but usefull for metadata
--   writing</li>
--   <li><a>Exif</a> Exif tag and associated data.</li>
--   </ul>
data Keys a
Gamma :: Keys Double
Format :: Keys SourceFormat
DpiX :: Keys Word
DpiY :: Keys Word
Width :: Keys Word
Height :: Keys Word
Title :: Keys String
Description :: Keys String
Author :: Keys String
Copyright :: Keys String
Software :: Keys String
Comment :: Keys String
Disclaimer :: Keys String
Source :: Keys String
Warning :: Keys String
Exif :: !ExifTag -> Keys ExifData
Unknown :: !String -> Keys Value

-- | Encode values for unknown information
data Value
Int :: !Int -> Value
Double :: !Double -> Value
String :: !String -> Value

-- | Element describing a metadata and it's (typed) associated value.
data Elem k
(:=>) :: !(k a) -> a -> Elem k

-- | Type describing the original file format of the ilfe.
data SourceFormat
SourceJpeg :: SourceFormat
SourceGif :: SourceFormat
SourceBitmap :: SourceFormat
SourceTiff :: SourceFormat
SourcePng :: SourceFormat
SourceHDR :: SourceFormat
SourceTGA :: SourceFormat

-- | Search a metadata with the given key.
lookup :: Keys a -> Metadatas -> Maybe a

-- | Empty metadatas. Favor <a>mempty</a>
empty :: Metadatas

-- | Insert an element in the metadatas, if an element with the same key is
--   present, it is overwritten.
insert :: (Show a, NFData a) => Keys a -> a -> Metadatas -> Metadatas

-- | Remove an element of the given keys from the metadatas. If not present
--   does nothing.
delete :: Keys a -> Metadatas -> Metadatas

-- | Create metadatas with a single element.
singleton :: (Show a, NFData a) => Keys a -> a -> Metadatas

-- | Strict left fold of the metadatas
foldl' :: (acc -> Elem Keys -> acc) -> acc -> Metadatas -> acc

-- | foldMap equivalent for metadatas.
foldMap :: Monoid m => (Elem Keys -> m) -> Metadatas -> m

-- | Create metadatas indicating the resolution, with DpiX == DpiY
mkDpiMetadata :: Word -> Metadatas

-- | Create metadatas holding width and height information.
mkSizeMetadata :: Integral n => n -> n -> Metadatas

-- | Create simple metadatas with Format, Width &amp; Height
basicMetadata :: Integral nSize => SourceFormat -> nSize -> nSize -> Metadatas

-- | Create simple metadatas with Format, Width, Height, DpiX &amp; DpiY
simpleMetadata :: (Integral nSize, Integral nDpi) => SourceFormat -> nSize -> nSize -> nDpi -> nDpi -> Metadatas

-- | Conversion from dpm to dpi
dotsPerMeterToDotPerInch :: Word -> Word

-- | Conversion from dpi to dpm
dotPerInchToDotsPerMeter :: Word -> Word

-- | Conversion dpcm -&gt; dpi
dotsPerCentiMeterToDotPerInch :: Word -> Word
instance Show (Elem Keys)
instance Eq (Keys a)
instance Show (Keys a)
instance Eq SourceFormat
instance Show SourceFormat
instance Eq Value
instance Show Value
instance Show Metadatas
instance NFData Metadatas
instance Monoid Metadatas
instance NFData (Elem Keys)
instance NFData Value
instance NFData SourceFormat


-- | Modules used for Bitmap file (.bmp) file loading and writing
module Codec.Picture.Bitmap

-- | Write an image in a file use the bitmap format.
writeBitmap :: BmpEncodable pixel => FilePath -> Image pixel -> IO ()

-- | Encode an image into a bytestring in .bmp format ready to be written
--   on disk.
encodeBitmap :: BmpEncodable pixel => Image pixel -> ByteString

-- | Equivalent to <a>encodeBitmap</a> but also store the following
--   metadatas:
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
encodeBitmapWithMetadata :: BmpEncodable pixel => Metadatas -> Image pixel -> ByteString

-- | Try to decode a bitmap image. Right now this function can output the
--   following pixel types :
--   
--   <ul>
--   <li>PixelRGB8<ul><li>Pixel8</li></ul></li>
--   </ul>
decodeBitmap :: ByteString -> Either String DynamicImage

-- | Same as <a>decodeBitmap</a> but also extracts metadata.
decodeBitmapWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Encode a dynamic image in bmp if possible, supported pixel type are :
--   
--   <ul>
--   <li>RGB8</li>
--   <li>RGBA8</li>
--   <li>Y8</li>
--   </ul>
encodeDynamicBitmap :: DynamicImage -> Either String ByteString

-- | Equivalent to <a>encodeBitmapWithPalette</a> but also store the
--   following metadatas:
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
encodeBitmapWithPaletteAndMetadata :: BmpEncodable pixel => Metadatas -> BmpPalette -> Image pixel -> ByteString

-- | Write a dynamic image in a .bmp image file if possible. The same
--   restriction as encodeDynamicBitmap apply.
writeDynamicBitmap :: FilePath -> DynamicImage -> IO (Either String Bool)

-- | All the instance of this class can be written as a bitmap file using
--   this library.
class BmpEncodable pixel where defaultPalette _ = BmpPalette []
instance Show BmpInfoHeader
instance BmpEncodable PixelRGB8
instance BmpEncodable PixelRGBA8
instance BmpEncodable Pixel8
instance Binary BmpInfoHeader
instance Binary BmpHeader


-- | Module implementing GIF decoding.
module Codec.Picture.Gif

-- | Transform a raw gif image to an image, witout modifying the pixels.
--   This function can output the following pixel types :
--   
--   <ul>
--   <li>PixelRGB8</li>
--   <li>PixelRGBA8</li>
--   </ul>
decodeGif :: ByteString -> Either String DynamicImage

-- | Transform a raw gif image to an image, witout modifying the pixels.
--   This function can output the following pixel types :
--   
--   <ul>
--   <li>PixelRGB8</li>
--   <li>PixelRGBA8</li>
--   </ul>
--   
--   Metadatas include Width &amp; Height information.
decodeGifWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Transform a raw gif to a list of images, representing all the images
--   of an animation.
decodeGifImages :: ByteString -> Either String [DynamicImage]

-- | Extract a list of frame delays from a raw gif.
getDelaysGifImages :: ByteString -> Either String [GifDelay]

-- | Delay to wait before showing the next Gif image. The delay is
--   expressed in 100th of seconds.
type GifDelay = Int

-- | Help to control the behaviour of GIF animation looping.
data GifLooping

-- | The animation will stop once the end is reached
LoopingNever :: GifLooping

-- | The animation will restart once the end is reached
LoopingForever :: GifLooping

-- | The animation will repeat n times before stoping
LoopingRepeat :: Word16 -> GifLooping

-- | Encode a greyscale image to a bytestring.
encodeGifImage :: Image Pixel8 -> ByteString

-- | Encode an image with a given palette. Can return errors if the palette
--   is ill-formed.
--   
--   <ul>
--   <li>A palette must have between 1 and 256 colors</li>
--   </ul>
encodeGifImageWithPalette :: Image Pixel8 -> Palette -> Either String ByteString

-- | Encode a gif animation to a bytestring.
--   
--   <ul>
--   <li>Every image must have the same size</li>
--   <li>Every palette must have between one and 256 colors.</li>
--   </ul>
encodeGifImages :: GifLooping -> [(Palette, GifDelay, Image Pixel8)] -> Either String ByteString

-- | Write a greyscale in a gif file on the disk.
writeGifImage :: FilePath -> Image Pixel8 -> IO ()

-- | Write a gif image with a palette to a file.
--   
--   <ul>
--   <li>A palette must have between 1 and 256 colors</li>
--   </ul>
writeGifImageWithPalette :: FilePath -> Image Pixel8 -> Palette -> Either String (IO ())

-- | Write a list of images as a gif animation in a file.
--   
--   <ul>
--   <li>Every image must have the same size</li>
--   <li>Every palette must have between one and 256 colors.</li>
--   </ul>
writeGifImages :: FilePath -> GifLooping -> [(Palette, GifDelay, Image Pixel8)] -> Either String (IO ())

-- | Default palette to produce greyscale images.
greyPalette :: Palette
instance Binary GifFile
instance Binary GifHeader
instance Binary ImageDescriptor
instance Binary GifImage
instance Binary GraphicControlExtension
instance Binary LogicalScreenDescriptor
instance Binary GifVersion


-- | Module dedicated of Radiance file decompression (.hdr or .pic) file.
--   Radiance file format is used for High dynamic range imaging.
module Codec.Picture.HDR

-- | Decode an HDR (radiance) image, the resulting pixel type can be :
--   
--   <ul>
--   <li>PixelRGBF</li>
--   </ul>
decodeHDR :: ByteString -> Either String DynamicImage

-- | Equivalent to decodeHDR but with aditional metadatas.
decodeHDRWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Encode an High dynamic range image into a radiance image file format.
--   Alias for encodeRawHDR
encodeHDR :: Image PixelRGBF -> ByteString

-- | Encode an High dynamic range image into a radiance image file format.
--   without compression
encodeRawHDR :: Image PixelRGBF -> ByteString

-- | Encode an High dynamic range image into a radiance image file format
--   using a light RLE compression. Some problems seem to arise with some
--   image viewer.
encodeRLENewStyleHDR :: Image PixelRGBF -> ByteString

-- | Write an High dynamic range image into a radiance image file on disk.
writeHDR :: FilePath -> Image PixelRGBF -> IO ()

-- | Write a RLE encoded High dynamic range image into a radiance image
--   file on disk.
writeRLENewStyleHDR :: FilePath -> Image PixelRGBF -> IO ()
instance Binary RadianceHeader
instance Binary RadianceFormat
instance Binary RGBE


-- | Module implementing function to read and write Targa (*.tga) files.
module Codec.Picture.Tga

-- | Transform a raw tga image to an image, without modifying the
--   underlying pixel type.
--   
--   This function can output the following pixel types:
--   
--   <ul>
--   <li>PixelY8<ul><li>PixelRGB8</li><li>PixelRGBA8</li></ul></li>
--   </ul>
decodeTga :: ByteString -> Either String DynamicImage

-- | Equivalent to decodeTga but also provide metadata
decodeTgaWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | This typeclass determine if a pixel can be saved in the TGA format.
class TgaSaveable a

-- | Transform a compatible image to a raw bytestring representing a Targa
--   file.
encodeTga :: TgaSaveable px => Image px -> ByteString

-- | Helper function to directly write an image a tga on disk.
writeTga :: TgaSaveable pixel => FilePath -> Image pixel -> IO ()
instance TgaSaveable PixelRGBA8
instance TgaSaveable PixelRGB8
instance TgaSaveable Pixel8
instance TGAPixel Depth32
instance TGAPixel Depth24
instance TGAPixel Depth15
instance TGAPixel Depth8
instance Binary TgaFile
instance Binary TgaHeader
instance Binary TgaImageDescription
instance Binary TgaImageType
instance Binary TgaColorMapType


-- | Module used for loading &amp; writing 'Portable Network Graphics'
--   (PNG) files.
--   
--   A high level API is provided. It loads and saves images for you while
--   hiding all the details about PNG chunks.
--   
--   Basic functions for PNG handling are <a>decodePng</a>,
--   <a>encodePng</a> and <a>encodePalettedPng</a>. Convenience functions
--   are provided for direct file handling and using <a>DynamicImage</a>s.
--   
--   The loader has been validated against the pngsuite
--   (http:/<i>www.libpng.org</i>pub<i>png</i>pngsuite.html)
module Codec.Picture.Png

-- | Encode an image into a png if possible.
class PngSavable a where encodePng = encodePngWithMetadata mempty
encodePng :: PngSavable a => Image a -> ByteString
encodePngWithMetadata :: PngSavable a => Metadatas -> Image a -> ByteString

-- | Transform a raw png image to an image, without modifying the
--   underlying pixel type. If the image is greyscale and &lt; 8 bits, a
--   transformation to RGBA8 is performed. This should change in the
--   future. The resulting image let you manage the pixel types.
--   
--   This function can output the following pixel types:
--   
--   <ul>
--   
--   <li>PixelY8<ul><li>PixelY16</li><li>PixelYA8</li><li>PixelYA16</li><li>PixelRGB8</li><li>PixelRGB16</li><li>PixelRGBA8</li><li>PixelRGBA16</li></ul></li>
--   </ul>
decodePng :: ByteString -> Either String DynamicImage

-- | Same as <a>decodePng</a> but also extract meta datas present in the
--   files.
decodePngWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Helper function to directly write an image as a png on disk.
writePng :: PngSavable pixel => FilePath -> Image pixel -> IO ()

-- | Encode a dynamic image in bmp if possible, supported pixel type are :
--   
--   <ul>
--   <li>Y8</li>
--   <li>Y16</li>
--   <li>YA8</li>
--   <li>YA16</li>
--   <li>RGB8</li>
--   <li>RGB16</li>
--   <li>RGBA8</li>
--   <li>RGBA16</li>
--   </ul>
encodeDynamicPng :: DynamicImage -> Either String ByteString

-- | Encode a paletted image as a color indexed 8-bit PNG. the palette must
--   have between 1 and 256 values in it.
encodePalettedPng :: Palette -> Image Pixel8 -> Either String ByteString

-- | Equivalent to <a>encodePalettedPng</a> but allow writing of metadatas.
encodePalettedPngWithMetadata :: Metadatas -> Palette -> Image Pixel8 -> Either String ByteString

-- | Write a dynamic image in a .png image file if possible. The same
--   restriction as encodeDynamicPng apply.
writeDynamicPng :: FilePath -> DynamicImage -> IO (Either String Bool)


-- | Module implementing TIFF decoding.
--   
--   Supported compression schemes:
--   
--   <ul>
--   <li>Uncompressed</li>
--   <li>PackBits</li>
--   <li>LZW</li>
--   </ul>
--   
--   Supported bit depth:
--   
--   <ul>
--   <li>2 bits</li>
--   <li>4 bits</li>
--   <li>8 bits</li>
--   <li>16 bits</li>
--   </ul>
module Codec.Picture.Tiff

-- | Decode a tiff encoded image while preserving the underlying pixel type
--   (except for Y32 which is truncated to 16 bits).
--   
--   This function can output the following pixel types:
--   
--   <ul>
--   <li>PixelY8</li>
--   <li>PixelY16</li>
--   <li>PixelYA8</li>
--   <li>PixelYA16</li>
--   <li>PixelRGB8</li>
--   <li>PixelRGB16</li>
--   <li>PixelRGBA8</li>
--   <li>PixelRGBA16</li>
--   <li>PixelCMYK8</li>
--   <li>PixelCMYK16</li>
--   </ul>
decodeTiff :: ByteString -> Either String DynamicImage

-- | Like <a>decodeTiff</a> but also provides some metdata present in the
--   Tiff file.
--   
--   The metadata extracted are the DpiX &amp; DpiY information alongside
--   the EXIF informations.
decodeTiffWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Class defining which pixel types can be serialized in a Tiff file.
class Pixel px => TiffSaveable px where extraSampleCodeOfPixel _ = Nothing subSamplingInfo _ = empty

-- | Transform an image into a Tiff encoded bytestring, ready to be written
--   as a file.
encodeTiff :: TiffSaveable px => Image px -> ByteString

-- | Helper function to directly write an image as a tiff on disk.
writeTiff :: TiffSaveable pixel => FilePath -> Image pixel -> IO ()
instance TiffSaveable PixelYCbCr8
instance TiffSaveable PixelRGBA16
instance TiffSaveable PixelRGBA8
instance TiffSaveable PixelRGB16
instance TiffSaveable PixelRGB8
instance TiffSaveable PixelCMYK16
instance TiffSaveable PixelCMYK8
instance TiffSaveable PixelYA16
instance TiffSaveable PixelYA8
instance TiffSaveable Pixel16
instance TiffSaveable Pixel8
instance BinaryParam ByteString TiffInfo
instance Unpackable YCbCrSubsampling
instance Unpackable Pack12
instance Unpackable Pack2
instance Unpackable Pack4
instance Unpackable Word32
instance Unpackable Word16
instance Unpackable Word8


-- | Module used for JPEG file loading and writing.
module Codec.Picture.Jpg

-- | Try to decompress a jpeg file and decompress. The colorspace is still
--   YCbCr if you want to perform computation on the luma part. You can
--   convert it to RGB using <a>convertImage</a> from the
--   <a>ColorSpaceConvertible</a> typeclass.
--   
--   This function can output the following pixel types :
--   
--   <ul>
--   
--   <li>PixelY8<ul><li>PixelYA8</li><li>PixelRGB8</li><li>PixelYCbCr8</li></ul></li>
--   </ul>
decodeJpeg :: ByteString -> Either String DynamicImage

-- | Equivalent to <a>decodeJpeg</a> but also extracts metadatas.
--   
--   Extract the following metadatas from the JFIF bloc:
--   
--   <ul>
--   <li>DpiX</li>
--   <li>DpiY</li>
--   </ul>
--   
--   Exif metadata are also extracted if present.
decodeJpegWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Function to call to encode an image to jpeg. The quality factor should
--   be between 0 and 100 (100 being the best quality).
encodeJpegAtQuality :: Word8 -> Image PixelYCbCr8 -> ByteString

-- | Equivalent to <a>encodeJpegAtQuality</a>, but will store the following
--   metadatas in the file using a JFIF block:
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
encodeJpegAtQualityWithMetadata :: Word8 -> Metadatas -> Image PixelYCbCr8 -> ByteString

-- | Encode an image in jpeg at a reasonnable quality level. If you want
--   better quality or reduced file size, you should use
--   <a>encodeJpegAtQuality</a>
encodeJpeg :: Image PixelYCbCr8 -> ByteString


-- | Helper functions to save dynamic images to other file format with
--   automatic color space/sample format conversion done automatically.
module Codec.Picture.Saving

-- | This function will try to do anything to encode an image as JPEG, make
--   all color conversion and such. Equivalent of <tt>decodeImage</tt> for
--   jpeg encoding
imageToJpg :: Int -> DynamicImage -> ByteString

-- | This function will try to do anything to encode an image as PNG, make
--   all color conversion and such. Equivalent of <tt>decodeImage</tt> for
--   PNG encoding
imageToPng :: DynamicImage -> ByteString

-- | This function will try to do anything to encode an image as a gif,
--   make all color conversion and quantization. Equivalent of
--   <tt>decodeImage</tt> for gif encoding
imageToGif :: DynamicImage -> Either String ByteString

-- | This function will try to do anything to encode an image as bitmap,
--   make all color conversion and such. Equivalent of <tt>decodeImage</tt>
--   for Bitmap encoding
imageToBitmap :: DynamicImage -> ByteString

-- | This function will try to do anything to encode an image as a Tiff,
--   make all color conversion and such. Equivalent of <tt>decodeImage</tt>
--   for Tiff encoding
imageToTiff :: DynamicImage -> ByteString

-- | This function will try to do anything to encode an image as RADIANCE,
--   make all color conversion and such. Equivalent of <tt>decodeImage</tt>
--   for radiance encoding
imageToRadiance :: DynamicImage -> ByteString


-- | Main module for image import/export into various image formats.
--   
--   To use the library without thinking about it, look after
--   <a>decodeImage</a> and <a>readImage</a>.
--   
--   Generally, the read* functions read the images from a file and try to
--   decode it, and the decode* functions try to decode a bytestring.
--   
--   For an easy image writing use the <a>saveBmpImage</a>,
--   <a>saveJpgImage</a> &amp; <a>savePngImage</a> functions
module Codec.Picture

-- | Load an image file without even thinking about it, it does everything
--   as <a>decodeImage</a>
readImage :: FilePath -> IO (Either String DynamicImage)

-- | Equivalent to <a>readImage</a> but also providing metadatas.
readImageWithMetadata :: FilePath -> IO (Either String (DynamicImage, Metadatas))

-- | If you want to decode an image in a bytestring without even thinking
--   in term of format or whatever, this is the function to use. It will
--   try to decode in each known format and if one decoding succeeds, it
--   will return the decoded image in it's own colorspace.
decodeImage :: ByteString -> Either String DynamicImage

-- | Equivalent to <a>decodeImage</a>, but also provide potential metadatas
--   present in the given file.
decodeImageWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | <a>map</a> equivalent for an image, working at the pixel level. Little
--   example : a brightness function for an rgb image
--   
--   <pre>
--   brightnessRGB8 :: Int -&gt; Image PixelRGB8 -&gt; Image PixelRGB8
--   brightnessRGB8 add = pixelMap brightFunction
--        where up v = fromIntegral (fromIntegral v + add)
--              brightFunction (PixelRGB8 r g b) =
--                      PixelRGB8 (up r) (up g) (up b)
--   </pre>
pixelMap :: (Pixel a, Pixel b) => (a -> b) -> Image a -> Image b

-- | Create an image given a function to generate pixels. The function will
--   receive values from 0 to width-1 for the x parameter and 0 to height-1
--   for the y parameter. The coordinates 0,0 are the upper left corner of
--   the image, and (width-1, height-1) the lower right corner.
--   
--   for example, to create a small gradient image:
--   
--   <pre>
--   imageCreator :: String -&gt; IO ()
--   imageCreator path = writePng path $ generateImage pixelRenderer 250 300
--      where pixelRenderer x y = PixelRGB8 x y 128
--   </pre>
generateImage :: Pixel a => (Int -> Int -> a) -> Int -> Int -> Image a

-- | Create an image given a function to generate pixels. The function will
--   receive values from 0 to width-1 for the x parameter and 0 to height-1
--   for the y parameter. The coordinates 0,0 are the upper left corner of
--   the image, and (width-1, height-1) the lower right corner.
--   
--   the acc parameter is a user defined one.
--   
--   The function is called for each pixel in the line from left to right
--   (0 to width - 1) and for each line (0 to height - 1).
generateFoldImage :: Pixel a => (acc -> Int -> Int -> (acc, a)) -> acc -> Int -> Int -> (acc, Image a)

-- | Create an image using a monadic initializer function. The function
--   will receive values from 0 to width-1 for the x parameter and 0 to
--   height-1 for the y parameter. The coordinates 0,0 are the upper left
--   corner of the image, and (width-1, height-1) the lower right corner.
--   
--   The function is called for each pixel in the line from left to right
--   (0 to width - 1) and for each line (0 to height - 1).
withImage :: (Pixel pixel, PrimMonad m) => Int -> Int -> (Int -> Int -> m pixel) -> m (Image pixel)

-- | Traversal type matching the definition in the Lens package.
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | Traversal in "raster" order, from left to right the top to bottom.
--   This traversal is matching pixelMap in spirit.
--   
--   Since 3.2.4
imagePixels :: (Pixel pxa, Pixel pxb) => Traversal (Image pxa) (Image pxb) pxa pxb

-- | Traversal providing the pixel position with it's value. The traversal
--   in raster order, from lef to right, then top to bottom. The traversal
--   match pixelMapXY in spirit.
--   
--   Since 3.2.4
imageIPixels :: (Pixel pxa, Pixel pxb) => Traversal (Image pxa) (Image pxb) (Int, Int, pxa) pxb

-- | Save an image to a '.bmp' file, will do everything it can to save an
--   image.
saveBmpImage :: FilePath -> DynamicImage -> IO ()

-- | Save an image to a '.jpg' file, will do everything it can to save an
--   image.
saveJpgImage :: Int -> FilePath -> DynamicImage -> IO ()

-- | Save an image to a '.gif' file, will do everything it can to save it.
saveGifImage :: FilePath -> DynamicImage -> Either String (IO ())

-- | Save an image to a '.png' file, will do everything it can to save an
--   image. For example, a simple transcoder to png
--   
--   <pre>
--   transcodeToPng :: FilePath -&gt; FilePath -&gt; IO ()
--   transcodeToPng pathIn pathOut = do
--      eitherImg &lt;- readImage pathIn
--      case eitherImg of
--          Left _ -&gt; return ()
--          Right img -&gt; savePngImage pathOut img
--   </pre>
savePngImage :: FilePath -> DynamicImage -> IO ()

-- | Save an image to a '.tiff' file, will do everything it can to save an
--   image.
saveTiffImage :: FilePath -> DynamicImage -> IO ()

-- | Save an image to a '.hdr' file, will do everything it can to save an
--   image.
saveRadianceImage :: FilePath -> DynamicImage -> IO ()

-- | All the instance of this class can be written as a bitmap file using
--   this library.
class BmpEncodable pixel where defaultPalette _ = BmpPalette []

-- | Write an image in a file use the bitmap format.
writeBitmap :: BmpEncodable pixel => FilePath -> Image pixel -> IO ()

-- | Encode an image into a bytestring in .bmp format ready to be written
--   on disk.
encodeBitmap :: BmpEncodable pixel => Image pixel -> ByteString

-- | Try to load a .bmp file. The colorspace would be RGB or Y.
readBitmap :: FilePath -> IO (Either String DynamicImage)

-- | Try to decode a bitmap image. Right now this function can output the
--   following pixel types :
--   
--   <ul>
--   <li>PixelRGB8<ul><li>Pixel8</li></ul></li>
--   </ul>
decodeBitmap :: ByteString -> Either String DynamicImage

-- | Encode a dynamic image in bmp if possible, supported pixel type are :
--   
--   <ul>
--   <li>RGB8</li>
--   <li>RGBA8</li>
--   <li>Y8</li>
--   </ul>
encodeDynamicBitmap :: DynamicImage -> Either String ByteString

-- | Write a dynamic image in a .bmp image file if possible. The same
--   restriction as encodeDynamicBitmap apply.
writeDynamicBitmap :: FilePath -> DynamicImage -> IO (Either String Bool)

-- | Helper function trying to load a gif file from a file on disk.
readGif :: FilePath -> IO (Either String DynamicImage)

-- | Helper function trying to load all the images of an animated gif file.
readGifImages :: FilePath -> IO (Either String [DynamicImage])

-- | Transform a raw gif image to an image, witout modifying the pixels.
--   This function can output the following pixel types :
--   
--   <ul>
--   <li>PixelRGB8</li>
--   <li>PixelRGBA8</li>
--   </ul>
decodeGif :: ByteString -> Either String DynamicImage

-- | Transform a raw gif to a list of images, representing all the images
--   of an animation.
decodeGifImages :: ByteString -> Either String [DynamicImage]

-- | Encode a greyscale image to a bytestring.
encodeGifImage :: Image Pixel8 -> ByteString

-- | Write a greyscale in a gif file on the disk.
writeGifImage :: FilePath -> Image Pixel8 -> IO ()

-- | Encode an image with a given palette. Can return errors if the palette
--   is ill-formed.
--   
--   <ul>
--   <li>A palette must have between 1 and 256 colors</li>
--   </ul>
encodeGifImageWithPalette :: Image Pixel8 -> Palette -> Either String ByteString

-- | Write a gif image with a palette to a file.
--   
--   <ul>
--   <li>A palette must have between 1 and 256 colors</li>
--   </ul>
writeGifImageWithPalette :: FilePath -> Image Pixel8 -> Palette -> Either String (IO ())

-- | Encode a full color image to a gif by applying a color quantization
--   algorithm on it.
encodeColorReducedGifImage :: Image PixelRGB8 -> Either String ByteString

-- | Write a full color image to a gif by applying a color quantization
--   algorithm on it.
writeColorReducedGifImage :: FilePath -> Image PixelRGB8 -> Either String (IO ())

-- | Encode a gif animation to a bytestring.
--   
--   <ul>
--   <li>Every image must have the same size</li>
--   <li>Every palette must have between one and 256 colors.</li>
--   </ul>
encodeGifImages :: GifLooping -> [(Palette, GifDelay, Image Pixel8)] -> Either String ByteString

-- | Write a list of images as a gif animation in a file.
--   
--   <ul>
--   <li>Every image must have the same size</li>
--   <li>Every palette must have between one and 256 colors.</li>
--   </ul>
writeGifImages :: FilePath -> GifLooping -> [(Palette, GifDelay, Image Pixel8)] -> Either String (IO ())

-- | Delay to wait before showing the next Gif image. The delay is
--   expressed in 100th of seconds.
type GifDelay = Int

-- | Help to control the behaviour of GIF animation looping.
data GifLooping

-- | The animation will stop once the end is reached
LoopingNever :: GifLooping

-- | The animation will restart once the end is reached
LoopingForever :: GifLooping

-- | The animation will repeat n times before stoping
LoopingRepeat :: Word16 -> GifLooping

-- | Helper function to create a gif animation. All the images of the
--   animation are separated by the same delay.
encodeGifAnimation :: GifDelay -> GifLooping -> [Image PixelRGB8] -> Either String ByteString

-- | Helper function to write a gif animation on disk. See
--   encodeGifAnimation
writeGifAnimation :: FilePath -> GifDelay -> GifLooping -> [Image PixelRGB8] -> Either String (IO ())

-- | Try to load a jpeg file and decompress. The colorspace is still YCbCr
--   if you want to perform computation on the luma part. You can convert
--   it to RGB using <tt>colorSpaceConversion</tt>.
readJpeg :: FilePath -> IO (Either String DynamicImage)

-- | Try to decompress a jpeg file and decompress. The colorspace is still
--   YCbCr if you want to perform computation on the luma part. You can
--   convert it to RGB using <a>convertImage</a> from the
--   <a>ColorSpaceConvertible</a> typeclass.
--   
--   This function can output the following pixel types :
--   
--   <ul>
--   
--   <li>PixelY8<ul><li>PixelYA8</li><li>PixelRGB8</li><li>PixelYCbCr8</li></ul></li>
--   </ul>
decodeJpeg :: ByteString -> Either String DynamicImage

-- | Encode an image in jpeg at a reasonnable quality level. If you want
--   better quality or reduced file size, you should use
--   <a>encodeJpegAtQuality</a>
encodeJpeg :: Image PixelYCbCr8 -> ByteString

-- | Function to call to encode an image to jpeg. The quality factor should
--   be between 0 and 100 (100 being the best quality).
encodeJpegAtQuality :: Word8 -> Image PixelYCbCr8 -> ByteString

-- | Encode an image into a png if possible.
class PngSavable a where encodePng = encodePngWithMetadata mempty
encodePng :: PngSavable a => Image a -> ByteString
encodePngWithMetadata :: PngSavable a => Metadatas -> Image a -> ByteString

-- | Helper function trying to load a png file from a file on disk.
readPng :: FilePath -> IO (Either String DynamicImage)

-- | Transform a raw png image to an image, without modifying the
--   underlying pixel type. If the image is greyscale and &lt; 8 bits, a
--   transformation to RGBA8 is performed. This should change in the
--   future. The resulting image let you manage the pixel types.
--   
--   This function can output the following pixel types:
--   
--   <ul>
--   
--   <li>PixelY8<ul><li>PixelY16</li><li>PixelYA8</li><li>PixelYA16</li><li>PixelRGB8</li><li>PixelRGB16</li><li>PixelRGBA8</li><li>PixelRGBA16</li></ul></li>
--   </ul>
decodePng :: ByteString -> Either String DynamicImage

-- | Helper function to directly write an image as a png on disk.
writePng :: PngSavable pixel => FilePath -> Image pixel -> IO ()

-- | Encode a paletted image as a color indexed 8-bit PNG. the palette must
--   have between 1 and 256 values in it.
encodePalettedPng :: Palette -> Image Pixel8 -> Either String ByteString

-- | Encode a dynamic image in bmp if possible, supported pixel type are :
--   
--   <ul>
--   <li>Y8</li>
--   <li>Y16</li>
--   <li>YA8</li>
--   <li>YA16</li>
--   <li>RGB8</li>
--   <li>RGB16</li>
--   <li>RGBA8</li>
--   <li>RGBA16</li>
--   </ul>
encodeDynamicPng :: DynamicImage -> Either String ByteString

-- | Write a dynamic image in a .png image file if possible. The same
--   restriction as encodeDynamicPng apply.
writeDynamicPng :: FilePath -> DynamicImage -> IO (Either String Bool)

-- | Try to load a .tga file from disk.
readTGA :: FilePath -> IO (Either String DynamicImage)

-- | Transform a raw tga image to an image, without modifying the
--   underlying pixel type.
--   
--   This function can output the following pixel types:
--   
--   <ul>
--   <li>PixelY8<ul><li>PixelRGB8</li><li>PixelRGBA8</li></ul></li>
--   </ul>
decodeTga :: ByteString -> Either String DynamicImage

-- | This typeclass determine if a pixel can be saved in the TGA format.
class TgaSaveable a

-- | Transform a compatible image to a raw bytestring representing a Targa
--   file.
encodeTga :: TgaSaveable px => Image px -> ByteString

-- | Helper function to directly write an image a tga on disk.
writeTga :: TgaSaveable pixel => FilePath -> Image pixel -> IO ()

-- | Helper function trying to load tiff file from a file on disk.
readTiff :: FilePath -> IO (Either String DynamicImage)

-- | Class defining which pixel types can be serialized in a Tiff file.
class Pixel px => TiffSaveable px where extraSampleCodeOfPixel _ = Nothing subSamplingInfo _ = empty

-- | Decode a tiff encoded image while preserving the underlying pixel type
--   (except for Y32 which is truncated to 16 bits).
--   
--   This function can output the following pixel types:
--   
--   <ul>
--   <li>PixelY8</li>
--   <li>PixelY16</li>
--   <li>PixelYA8</li>
--   <li>PixelYA16</li>
--   <li>PixelRGB8</li>
--   <li>PixelRGB16</li>
--   <li>PixelRGBA8</li>
--   <li>PixelRGBA16</li>
--   <li>PixelCMYK8</li>
--   <li>PixelCMYK16</li>
--   </ul>
decodeTiff :: ByteString -> Either String DynamicImage

-- | Transform an image into a Tiff encoded bytestring, ready to be written
--   as a file.
encodeTiff :: TiffSaveable px => Image px -> ByteString

-- | Helper function to directly write an image as a tiff on disk.
writeTiff :: TiffSaveable pixel => FilePath -> Image pixel -> IO ()

-- | Try to load a .pic file. The colorspace can only be RGB with floating
--   point precision.
readHDR :: FilePath -> IO (Either String DynamicImage)

-- | Decode an HDR (radiance) image, the resulting pixel type can be :
--   
--   <ul>
--   <li>PixelRGBF</li>
--   </ul>
decodeHDR :: ByteString -> Either String DynamicImage

-- | Encode an High dynamic range image into a radiance image file format.
--   Alias for encodeRawHDR
encodeHDR :: Image PixelRGBF -> ByteString

-- | Write an High dynamic range image into a radiance image file on disk.
writeHDR :: FilePath -> Image PixelRGBF -> IO ()

-- | Define which palette creation method is used.
data PaletteCreationMethod

-- | MedianMeanCut method, provide the best results (visualy) at the cost
--   of increased calculations.
MedianMeanCut :: PaletteCreationMethod

-- | Very fast algorithm (one pass), doesn't provide good looking results.
Uniform :: PaletteCreationMethod

-- | To specify how the palette will be created.
data PaletteOptions
PaletteOptions :: PaletteCreationMethod -> Bool -> Int -> PaletteOptions

-- | Algorithm used to find the palette
paletteCreationMethod :: PaletteOptions -> PaletteCreationMethod

-- | Do we want to apply the dithering to the image. Enabling it often
--   reduce compression ratio but enhance the perceived quality of the
--   final image.
enableImageDithering :: PaletteOptions -> Bool

-- | Maximum number of color we want in the palette
paletteColorCount :: PaletteOptions -> Int

-- | Reduces an image to a color palette according to <tt>PaletteOpts</tt>
--   and returns the <i>indices image</i> along with its <a>Palette</a>.
palettize :: PaletteOptions -> Image PixelRGB8 -> (Image Pixel8, Palette)

-- | The main type of this package, one that most functions work on, is
--   Image.
--   
--   Parameterized by the underlying pixel format it forms a rigid type. If
--   you wish to store images of different or unknown pixel formats use
--   <a>DynamicImage</a>.
--   
--   Image is essentially a rectangular pixel buffer of specified width and
--   height. The coordinates are assumed to start from the upper-left
--   corner of the image, with the horizontal position first and vertical
--   second.
data Image a
Image :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Vector (PixelBaseComponent a) -> Image a

-- | Width of the image in pixels
imageWidth :: Image a -> {-# UNPACK #-} !Int

-- | Height of the image in pixels.
imageHeight :: Image a -> {-# UNPACK #-} !Int

-- | Image pixel data. To extract pixels at a given position you should use
--   the helper functions.
--   
--   Internally pixel data is stored as consecutively packed lines from top
--   to bottom, scanned from left to right within individual lines, from
--   first to last color component within each pixel.
imageData :: Image a -> Vector (PixelBaseComponent a)

-- | Image type enumerating all predefined pixel types. It enables loading
--   and use of images of different pixel types.
data DynamicImage

-- | A greyscale image.
ImageY8 :: (Image Pixel8) -> DynamicImage

-- | A greyscale image with 16bit components
ImageY16 :: (Image Pixel16) -> DynamicImage

-- | A greyscale HDR image
ImageYF :: (Image PixelF) -> DynamicImage

-- | An image in greyscale with an alpha channel.
ImageYA8 :: (Image PixelYA8) -> DynamicImage

-- | An image in greyscale with alpha channel on 16 bits.
ImageYA16 :: (Image PixelYA16) -> DynamicImage

-- | An image in true color.
ImageRGB8 :: (Image PixelRGB8) -> DynamicImage

-- | An image in true color with 16bit depth.
ImageRGB16 :: (Image PixelRGB16) -> DynamicImage

-- | An image with HDR pixels
ImageRGBF :: (Image PixelRGBF) -> DynamicImage

-- | An image in true color and an alpha channel.
ImageRGBA8 :: (Image PixelRGBA8) -> DynamicImage

-- | A true color image with alpha on 16 bits.
ImageRGBA16 :: (Image PixelRGBA16) -> DynamicImage

-- | An image in the colorspace used by Jpeg images.
ImageYCbCr8 :: (Image PixelYCbCr8) -> DynamicImage

-- | An image in the colorspace CMYK
ImageCMYK8 :: (Image PixelCMYK8) -> DynamicImage

-- | An image in the colorspace CMYK and 16 bits precision
ImageCMYK16 :: (Image PixelCMYK16) -> DynamicImage

-- | Type for the palette used in Gif &amp; PNG files.
type Palette = Image PixelRGB8

-- | Definition of pixels used in images. Each pixel has a color space, and
--   a representative component (Word8 or Float).
class (Storable (PixelBaseComponent a), Num (PixelBaseComponent a), Eq a) => Pixel a where type family PixelBaseComponent a :: * mixWithAlpha f _ = mixWith f pixelBaseIndex (Image {imageWidth = w}) x y = (x + y * w) * componentCount (undefined :: a) mutablePixelBaseIndex (MutableImage {mutableImageWidth = w}) x y = (x + y * w) * componentCount (undefined :: a)
mixWith :: Pixel a => (Int -> PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> a -> a -> a
mixWithAlpha :: Pixel a => (Int -> PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> (PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> a -> a -> a
pixelOpacity :: Pixel a => a -> PixelBaseComponent a
componentCount :: Pixel a => a -> Int
colorMap :: Pixel a => (PixelBaseComponent a -> PixelBaseComponent a) -> a -> a
pixelBaseIndex :: Pixel a => Image a -> Int -> Int -> Int
mutablePixelBaseIndex :: Pixel a => MutableImage s a -> Int -> Int -> Int
pixelAt :: Pixel a => Image a -> Int -> Int -> a
readPixel :: (Pixel a, PrimMonad m) => MutableImage (PrimState m) a -> Int -> Int -> m a
writePixel :: (Pixel a, PrimMonad m) => MutableImage (PrimState m) a -> Int -> Int -> a -> m ()
unsafePixelAt :: Pixel a => Vector (PixelBaseComponent a) -> Int -> a
unsafeReadPixel :: (Pixel a, PrimMonad m) => STVector (PrimState m) (PixelBaseComponent a) -> Int -> m a
unsafeWritePixel :: (Pixel a, PrimMonad m) => STVector (PrimState m) (PixelBaseComponent a) -> Int -> a -> m ()

-- | Type alias for 8bit greyscale pixels. For simplicity, greyscale pixels
--   use plain numbers instead of a separate type.
type Pixel8 = Word8

-- | Type alias for 16bit greyscale pixels.
type Pixel16 = Word16

-- | Type alias for 32bit floating point greyscale pixels. The standard
--   bounded value range is mapped to the closed interval [0,1] i.e.
--   
--   <pre>
--   map promotePixel [0, 1 .. 255 :: Pixel8] == [0/255, 1/255 .. 1.0 :: PixelF]
--   </pre>
type PixelF = Float

-- | Pixel type storing 8bit Luminance (Y) and alpha (A) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Luminance</li>
--   <li>Alpha</li>
--   </ul>
data PixelYA8
PixelYA8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYA8

-- | Pixel type storing 16bit Luminance (Y) and alpha (A) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Luminance</li>
--   <li>Alpha</li>
--   </ul>
data PixelYA16
PixelYA16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelYA16

-- | Classic pixel type storing 8bit red, green and blue (RGB) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGB8
PixelRGB8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelRGB8

-- | Pixel type storing 16bit red, green and blue (RGB) information. Values
--   are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGB16
PixelRGB16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelRGB16

-- | HDR pixel type storing floating point 32bit red, green and blue (RGB)
--   information. Same value range and comments apply as for <a>PixelF</a>.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGBF
PixelRGBF :: {-# UNPACK #-} !PixelF -> {-# UNPACK #-} !PixelF -> {-# UNPACK #-} !PixelF -> PixelRGBF

-- | Classical pixel type storing 8bit red, green, blue and alpha (RGBA)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   <li>Alpha</li>
--   </ul>
data PixelRGBA8
PixelRGBA8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelRGBA8

-- | Pixel type storing 16bit red, green, blue and alpha (RGBA)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   <li>Alpha</li>
--   </ul>
data PixelRGBA16
PixelRGBA16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelRGBA16

-- | Pixel type storing 8bit luminance, blue difference and red difference
--   (YCbCr) information. Values are stored in the following order:
--   
--   <ul>
--   <li>Y (luminance)</li>
--   <li>Cb</li>
--   <li>Cr</li>
--   </ul>
data PixelYCbCr8
PixelYCbCr8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYCbCr8

-- | Pixel type storing 8bit cyan, magenta, yellow and black (CMYK)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Cyan</li>
--   <li>Magenta</li>
--   <li>Yellow</li>
--   <li>Black</li>
--   </ul>
data PixelCMYK8
PixelCMYK8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelCMYK8

-- | Pixel type storing 16bit cyan, magenta, yellow and black (CMYK)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Cyan</li>
--   <li>Magenta</li>
--   <li>Yellow</li>
--   <li>Black</li>
--   </ul>
data PixelCMYK16
PixelCMYK16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelCMYK16

-- | Import a image from an unsafe pointer The pointer must have a size of
--   width * height * componentCount px
imageFromUnsafePtr :: (Pixel px, (PixelBaseComponent px) ~ Word8) => Int -> Int -> ForeignPtr Word8 -> Image px
