-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A revised version of the scotty library that attempts to be simpler and more performant.
--   
@package growler
@version 0.6.0

module Web.Growler.Types
data MatchResult
Fail :: MatchResult
Partial :: [Param] -> MatchResult
Complete :: [Param] -> MatchResult
newtype RoutePattern
RoutePattern :: (Request -> RoutePatternResult) -> RoutePattern
runRoutePattern :: RoutePattern -> Request -> RoutePatternResult
data RoutePatternResult
RoutePatternResult :: !Text -> !Request -> !MatchResult -> RoutePatternResult
routePatternResultName :: RoutePatternResult -> !Text

-- | The (potentially) updated request after consuming a portion of the
--   path
routePatternResultRequest :: RoutePatternResult -> !Request
routePatternResultMatchResult :: RoutePatternResult -> !MatchResult
path :: Request -> Text
capture :: Text -> RoutePattern
type Param = (ByteString, ByteString)
data BodySource
FileSource :: !FilePath -> !(Maybe FilePart) -> BodySource
BuilderSource :: !Builder -> BodySource
LBSSource :: !ByteString -> BodySource
StreamSource :: !StreamingBody -> BodySource
RawSource :: !(IO ByteString -> (ByteString -> IO ()) -> IO ()) -> !Response -> BodySource
data RequestState
RequestState :: Maybe Text -> [Param] -> Request -> RequestState
requestStateMatchedPattern :: RequestState -> Maybe Text
requestStateParams :: RequestState -> [Param]
requestStateRequest :: RequestState -> Request
data ResponseState
ResponseState :: !Status -> !(HashMap (CI ByteString) [ByteString]) -> !BodySource -> ResponseState
responseStateStatus :: ResponseState -> !Status
responseStateHeaders :: ResponseState -> !(HashMap (CI ByteString) [ByteString])
responseStateBodySource :: ResponseState -> !BodySource
class HasBodySource s a | s -> a
bodySource :: HasBodySource s a => Lens' s a
class HasHeaders s a | s -> a
headers :: HasHeaders s a => Lens' s a
class HasStatus s a | s -> a
status :: HasStatus s a => Lens' s a
class HasMatchedPattern s a | s -> a
matchedPattern :: HasMatchedPattern s a => Lens' s a
class HasParams s a | s -> a
params :: HasParams s a => Lens' s a
class HasRequest s a | s -> a
request :: HasRequest s a => Lens' s a
type EarlyTermination = ResponseState
type HandlerAbort m = EitherT EarlyTermination m
newtype HandlerT m a
HandlerT :: RWST RequestState () ResponseState (HandlerAbort m) a -> HandlerT m a
fromHandler :: HandlerT m a -> RWST RequestState () ResponseState (HandlerAbort m) a
newtype StHandlerT a
StHandlerT :: Either ResponseState (a, ResponseState) -> StHandlerT a
unStHandlerT :: StHandlerT a -> Either ResponseState (a, ResponseState)
type Handler = HandlerT IO
newtype GrowlerT m a
GrowlerT :: StateT [(StdMethod, RoutePattern, HandlerT m ())] m a -> GrowlerT m a
fromGrowlerT :: GrowlerT m a -> StateT [(StdMethod, RoutePattern, HandlerT m ())] m a
type Growler = GrowlerT IO
data JsonInputError
RequestBodyExhausted :: JsonInputError
JsonError :: DecodingError -> JsonInputError
data GrowlerConfig m
GrowlerConfig :: HandlerT m () -> (SomeException -> HandlerT m ()) -> GrowlerConfig m

-- | The 404 not found handler. If no route matches, then this handler will
--   be evaluated.
growlerConfigNotFoundHandler :: GrowlerConfig m -> HandlerT m ()

-- | The uncaught exception handler. If an exception is thrown and not
--   caught while trying to service a request, then this handler will be
--   evaluated.
growlerConfigErrorHandler :: GrowlerConfig m -> SomeException -> HandlerT m ()
instance Monad m => Monad (GrowlerT m)
instance MonadIO m => MonadIO (HandlerT m)
instance Monad m => Functor (HandlerT m)
instance Monad m => Monad (HandlerT m)
instance Monad m => Applicative (HandlerT m)
instance Show JsonInputError
instance Eq JsonInputError
instance MonadIO m => MonadIO (GrowlerT m)
instance (Functor m, Monad m) => Applicative (GrowlerT m)
instance Functor m => Functor (GrowlerT m)
instance MonadBaseControl b m => MonadBaseControl b (HandlerT m)
instance MonadTransControl HandlerT
instance MonadBase b m => MonadBase b (HandlerT m)
instance MonadTrans HandlerT
instance HasRequest RequestState Request
instance HasParams RequestState [Param]
instance HasMatchedPattern RequestState (Maybe Text)
instance HasStatus ResponseState Status
instance HasHeaders ResponseState (HashMap (CI ByteString) [ByteString])
instance HasBodySource ResponseState BodySource
instance Show MatchResult
instance Eq MatchResult
instance IsString RoutePattern
instance Monoid RoutePattern
instance Monoid MatchResult

module Web.Growler.Parsable

-- | Minimum implemention: <a>parseParam</a>
class Parsable a where parseParamList t = mapM parseParam (split ',' t)
parseParam :: Parsable a => ByteString -> Either ByteString a
parseParamList :: Parsable a => ByteString -> Either ByteString [a]

-- | Overrides default <a>parseParamList</a> to parse String.

-- | Checks if parameter is present and is null-valued, not a literal '()'.
--   If the URI requested is: '/foo?bar=()&amp;baz' then <tt>baz</tt> will
--   parse as (), where <tt>bar</tt> will not.

-- | Useful for creating <a>Parsable</a> instances for things that already
--   implement <a>Read</a>. Ex:
--   
--   <pre>
--   instance Parsable Int where parseParam = readEither
--   </pre>
readEither :: Read a => ByteString -> Either ByteString a
instance Parsable Integer
instance Parsable Int
instance Parsable Float
instance Parsable Double
instance Parsable Bool
instance Parsable a => Parsable [a]
instance Parsable ()
instance Parsable Char
instance Parsable ByteString
instance Parsable Text
instance Parsable Text

module Web.Growler.Handler
initialState :: ResponseState
currentResponse :: Monad m => HandlerT m ResponseState

-- | End the handler early with an arbitrary <a>ResponseState</a>.
abort :: Monad m => ResponseState -> HandlerT m ()

-- | Set the response status code.
status :: Monad m => Status -> HandlerT m ()

-- | Add a header to the response. Header names are case-insensitive.
addHeader :: Monad m => CI ByteString -> ByteString -> HandlerT m ()

-- | Set a response header. Overrides duplicate headers of the same name.
setHeader :: Monad m => CI ByteString -> ByteString -> HandlerT m ()

-- | Set an arbitrary body source for the response.
body :: Monad m => BodySource -> HandlerT m ()

-- | Send a file as the response body.
file :: Monad m => FilePath -> Maybe FilePart -> HandlerT m ()

-- | Set the response body to a ByteString <a>Builder</a>. Sets no headers.
builder :: Monad m => Builder -> HandlerT m ()

-- | Set the response body to a lazy <tt>ByteString</tt>. Sets no headers.
bytestring :: Monad m => ByteString -> HandlerT m ()

-- | Send a streaming response body. Sets no headers.
stream :: Monad m => StreamingBody -> HandlerT m ()

-- | Send raw output as the response body. Useful for e.g. websockets. See
--   WAI's <tt>responseRaw</tt> for more details.
raw :: MonadIO m => (IO ByteString -> (ByteString -> IO ()) -> IO ()) -> Response -> HandlerT m ()

-- | Send a value as JSON as the response body. Also sets the content type
--   to application/json.
json :: Monad m => ToJSON a => a -> HandlerT m ()

-- | Parse out the form parameters and the uploaded files. Consumes the
--   request body.
formData :: MonadIO m => BackEnd y -> HandlerT m ([(ByteString, ByteString)], [File y])

-- | Get all the request headers.
headers :: Monad m => HandlerT m RequestHeaders

-- | Consume the request body as a JSON value. Returns a
--   <a>JsonInputError</a> on failure.
jsonData :: (FromJSON a, MonadIO m) => HandlerT m (Either JsonInputError a)

-- | Get all matched params.
params :: Monad m => HandlerT m [Param]

-- | Terminate the current handler and send a <tt>302 Found</tt> redirect
--   to the provided URL. Other headers that have already been set will
--   also be returned in the request.
redirect :: Monad m => Text -> HandlerT m ()

-- | Get the underlying WAI <a>Request</a>
request :: Monad m => HandlerT m Request

-- | Return plain text as the response body. Sets the Content-Type header
--   to "text/plain; charset=utf-8".
text :: Monad m => Text -> HandlerT m ()

-- | Return HTML as the response body. Sets the Content-Type header to
--   "text/html; charset=utf-8". If you're using something like blaze-html
--   or lucid, you'll probably get better performance by rolling your own
--   function that sets the response body to a <a>Builder</a>.
html :: Monad m => Text -> HandlerT m ()

-- | Get the pattern that was matched in the router, e.g.
--   <tt>"<i>foo</i>:bar"</tt>
routePattern :: Monad m => HandlerT m (Maybe Text)
lookupParam :: (Functor m, Monad m, Parsable a) => ByteString -> HandlerT m (Maybe a)
param :: (Functor m, Monad m, Parsable a) => ByteString -> HandlerT m a
raise :: Monad m => ByteString -> HandlerT m ()
runHandler :: Monad m => ResponseState -> Maybe Text -> Request -> [Param] -> HandlerT m a -> m (Either ResponseState (a, ResponseState))
liftAround :: Monad m => (forall a. m a -> m a) -> HandlerT m a -> HandlerT m a

module Web.Growler.Router

-- | get = <a>addRoute</a> <a>GET</a>
get :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | post = <a>addRoute</a> <a>POST</a>
post :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | put = <a>addRoute</a> <a>PUT</a>
put :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | delete = <a>addRoute</a> <a>DELETE</a>
delete :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | patch = <a>addRoute</a> <a>PATCH</a>
patch :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | Define a route with a <a>StdMethod</a>, <a>Text</a> value representing
--   the path spec, and a body (<tt>Action</tt>) which modifies the
--   response.
--   
--   <pre>
--   addroute GET "/" $ text "beam me up!"
--   </pre>
--   
--   The path spec can include values starting with a colon, which are
--   interpreted as <i>captures</i>. These are named wildcards that can be
--   looked up with <a>param</a>.
--   
--   <pre>
--   addroute GET "/foo/:bar" $ do
--       v &lt;- param "bar"
--       text v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/foo/something
--   something
--   </pre>
addRoute :: MonadIO m => StdMethod -> RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | Add a route that matches regardless of the HTTP verb.
matchAny :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | Standard Sinatra-style route. Named captures are prepended with
--   colons. This is the default route type generated by OverloadedString
--   routes. i.e.
--   
--   <pre>
--   get (capture "/foo/:bar") $ ...
--   </pre>
--   
--   and
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   ...
--   get "/foo/:bar" $ ...
--   </pre>
--   
--   are equivalent.
capture :: String -> RoutePattern

-- | Match requests using a regular expression. Named captures are not yet
--   supported.
--   
--   <pre>
--   get (regex "^/f(.*)r$") $ do
--      path &lt;- param "0"
--      cap &lt;- param "1"
--      text $ mconcat ["Path: ", path, "\nCapture: ", cap]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/foo/bar
--   Path: /foo/bar
--   Capture: oo/ba
--   </pre>
regex :: String -> RoutePattern

-- | Build a route based on a function which can match using the entire
--   <a>Request</a> object. <a>Nothing</a> indicates the route does not
--   match. A <a>Just</a> value indicates a successful match, optionally
--   returning a list of key-value pairs accessible by <a>param</a>.
--   
--   <pre>
--   get (function $ \req -&gt; Just [("version", T.pack $ show $ httpVersion req)]) $ do
--       v &lt;- param "version"
--       text v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/
--   HTTP/1.1
--   </pre>
function :: (Request -> Text) -> (Request -> MatchResult) -> RoutePattern
mount :: Monad m => RoutePattern -> GrowlerT m () -> GrowlerT m ()

-- | Build a route that requires the requested path match exactly, without
--   captures.
literal :: String -> RoutePattern
route :: Request -> StdMethod -> RoutePattern -> Maybe (Text, [Param])
handlerHook :: Monad m => (HandlerT m () -> HandlerT m ()) -> GrowlerT m ()
newtype RoutePattern
RoutePattern :: (Request -> RoutePatternResult) -> RoutePattern
runRoutePattern :: RoutePattern -> Request -> RoutePatternResult

-- | A blank 404 Not Found handler for convenience.
notFound :: Monad m => HandlerT m ()

-- | A blank 500 Internal Server Error handler for convenience.
internalServerError :: Monad m => HandlerT m ()


-- | A Haskell web framework inspired by the Scotty framework, with an eye
--   towards performance, extensibility, and ease of use.
--   
--   <pre>
--   module Main where
--   import Data.Monoid ((&lt;&gt;))
--   import Web.Growler
--   
--   main = growl id defaultConfig $ do
--     get "/" $ text "Hello, World!"
--     get "/:name" $ do
--       name &lt;- param "name"
--       text ("Hello, " &lt;&gt; name &lt;&gt; "!")
--   </pre>
module Web.Growler

-- | The simple approach to starting up a web server
growl :: MonadIO m => (forall a. m a -> IO a) -> GrowlerConfig m -> GrowlerT m () -> IO ()

-- | For more complex needs, access to the actual WAI <a>Application</a>.
--   Useful for adding middleware.
growler :: MonadIO m => (forall a. m a -> IO a) -> GrowlerConfig m -> GrowlerT m () -> IO Application
defaultConfig :: MonadIO m => GrowlerConfig m
data GrowlerConfig m
GrowlerConfig :: HandlerT m () -> (SomeException -> HandlerT m ()) -> GrowlerConfig m

-- | The 404 not found handler. If no route matches, then this handler will
--   be evaluated.
growlerConfigNotFoundHandler :: GrowlerConfig m -> HandlerT m ()

-- | The uncaught exception handler. If an exception is thrown and not
--   caught while trying to service a request, then this handler will be
--   evaluated.
growlerConfigErrorHandler :: GrowlerConfig m -> SomeException -> HandlerT m ()
type Growler = GrowlerT IO
data GrowlerT m a

-- | Match requests using a regular expression. Named captures are not yet
--   supported.
--   
--   <pre>
--   get (regex "^/f(.*)r$") $ do
--      path &lt;- param "0"
--      cap &lt;- param "1"
--      text $ mconcat ["Path: ", path, "\nCapture: ", cap]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/foo/bar
--   Path: /foo/bar
--   Capture: oo/ba
--   </pre>
regex :: String -> RoutePattern

-- | Standard Sinatra-style route. Named captures are prepended with
--   colons. This is the default route type generated by OverloadedString
--   routes. i.e.
--   
--   <pre>
--   get (capture "/foo/:bar") $ ...
--   </pre>
--   
--   and
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   ...
--   get "/foo/:bar" $ ...
--   </pre>
--   
--   are equivalent.
capture :: String -> RoutePattern

-- | Build a route based on a function which can match using the entire
--   <a>Request</a> object. <a>Nothing</a> indicates the route does not
--   match. A <a>Just</a> value indicates a successful match, optionally
--   returning a list of key-value pairs accessible by <a>param</a>.
--   
--   <pre>
--   get (function $ \req -&gt; Just [("version", T.pack $ show $ httpVersion req)]) $ do
--       v &lt;- param "version"
--       text v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/
--   HTTP/1.1
--   </pre>
function :: (Request -> Text) -> (Request -> MatchResult) -> RoutePattern

-- | Build a route that requires the requested path match exactly, without
--   captures.
literal :: String -> RoutePattern
mount :: Monad m => RoutePattern -> GrowlerT m () -> GrowlerT m ()
handlerHook :: Monad m => (HandlerT m () -> HandlerT m ()) -> GrowlerT m ()

-- | A blank 404 Not Found handler for convenience.
notFound :: Monad m => HandlerT m ()

-- | get = <a>addRoute</a> <a>GET</a>
get :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | post = <a>addRoute</a> <a>POST</a>
post :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | put = <a>addRoute</a> <a>PUT</a>
put :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | delete = <a>addRoute</a> <a>DELETE</a>
delete :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | patch = <a>addRoute</a> <a>PATCH</a>
patch :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | Add a route that matches regardless of the HTTP verb.
matchAny :: MonadIO m => RoutePattern -> HandlerT m () -> GrowlerT m ()

-- | Define a route with a <a>StdMethod</a>, <a>Text</a> value representing
--   the path spec, and a body (<tt>Action</tt>) which modifies the
--   response.
--   
--   <pre>
--   addroute GET "/" $ text "beam me up!"
--   </pre>
--   
--   The path spec can include values starting with a colon, which are
--   interpreted as <i>captures</i>. These are named wildcards that can be
--   looked up with <a>param</a>.
--   
--   <pre>
--   addroute GET "/foo/:bar" $ do
--       v &lt;- param "bar"
--       text v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/foo/something
--   something
--   </pre>
addRoute :: MonadIO m => StdMethod -> RoutePattern -> HandlerT m () -> GrowlerT m ()
type Handler = HandlerT IO
data HandlerT m a

-- | Get the underlying WAI <a>Request</a>
request :: Monad m => HandlerT m Request

-- | Get the pattern that was matched in the router, e.g.
--   <tt>"<i>foo</i>:bar"</tt>
routePattern :: Monad m => HandlerT m (Maybe Text)

-- | Get all matched params.
params :: Monad m => HandlerT m [Param]

-- | Send a file as the response body.
file :: Monad m => FilePath -> Maybe FilePart -> HandlerT m ()

-- | Set the response body to a ByteString <a>Builder</a>. Sets no headers.
builder :: Monad m => Builder -> HandlerT m ()

-- | Set the response body to a lazy <tt>ByteString</tt>. Sets no headers.
bytestring :: Monad m => ByteString -> HandlerT m ()

-- | Send a streaming response body. Sets no headers.
stream :: Monad m => StreamingBody -> HandlerT m ()

-- | Send raw output as the response body. Useful for e.g. websockets. See
--   WAI's <tt>responseRaw</tt> for more details.
raw :: MonadIO m => (IO ByteString -> (ByteString -> IO ()) -> IO ()) -> Response -> HandlerT m ()
currentResponse :: Monad m => HandlerT m ResponseState

-- | End the handler early with an arbitrary <a>ResponseState</a>.
abort :: Monad m => ResponseState -> HandlerT m ()
lookupParam :: (Functor m, Monad m, Parsable a) => ByteString -> HandlerT m (Maybe a)
param :: (Functor m, Monad m, Parsable a) => ByteString -> HandlerT m a

-- | Parse out the form parameters and the uploaded files. Consumes the
--   request body.
formData :: MonadIO m => BackEnd y -> HandlerT m ([(ByteString, ByteString)], [File y])

-- | Get all the request headers.
headers :: Monad m => HandlerT m RequestHeaders

-- | Consume the request body as a JSON value. Returns a
--   <a>JsonInputError</a> on failure.
jsonData :: (FromJSON a, MonadIO m) => HandlerT m (Either JsonInputError a)

-- | Set the response status code.
status :: Monad m => Status -> HandlerT m ()

-- | Add a header to the response. Header names are case-insensitive.
addHeader :: Monad m => CI ByteString -> ByteString -> HandlerT m ()

-- | Set a response header. Overrides duplicate headers of the same name.
setHeader :: Monad m => CI ByteString -> ByteString -> HandlerT m ()
raise :: Monad m => ByteString -> HandlerT m ()

-- | Terminate the current handler and send a <tt>302 Found</tt> redirect
--   to the provided URL. Other headers that have already been set will
--   also be returned in the request.
redirect :: Monad m => Text -> HandlerT m ()

-- | Return plain text as the response body. Sets the Content-Type header
--   to "text/plain; charset=utf-8".
text :: Monad m => Text -> HandlerT m ()

-- | Return HTML as the response body. Sets the Content-Type header to
--   "text/html; charset=utf-8". If you're using something like blaze-html
--   or lucid, you'll probably get better performance by rolling your own
--   function that sets the response body to a <a>Builder</a>.
html :: Monad m => Text -> HandlerT m ()

-- | Send a value as JSON as the response body. Also sets the content type
--   to application/json.
json :: Monad m => ToJSON a => a -> HandlerT m ()
data JsonInputError
RequestBodyExhausted :: JsonInputError
JsonError :: DecodingError -> JsonInputError

-- | An error while decoding a JSON value.
data DecodingError :: *

-- | An <tt>attoparsec</tt> error that happened while parsing the raw JSON
--   string.
AttoparsecError :: ParsingError -> DecodingError

-- | An <tt>aeson</tt> error that happened while trying to convert a
--   <a>Value</a> to an <a>FromJSON</a> instance, as reported by
--   <a>Error</a>.
FromJSONError :: String -> DecodingError

-- | Minimum implemention: <a>parseParam</a>
class Parsable a where parseParamList t = mapM parseParam (split ',' t)
parseParam :: Parsable a => ByteString -> Either ByteString a
parseParamList :: Parsable a => ByteString -> Either ByteString [a]

-- | Useful for creating <a>Parsable</a> instances for things that already
--   implement <a>Read</a>. Ex:
--   
--   <pre>
--   instance Parsable Int where parseParam = readEither
--   </pre>
readEither :: Read a => ByteString -> Either ByteString a

-- | Set an arbitrary body source for the response.
body :: Monad m => BodySource -> HandlerT m ()
data BodySource
FileSource :: !FilePath -> !(Maybe FilePart) -> BodySource
BuilderSource :: !Builder -> BodySource
LBSSource :: !ByteString -> BodySource
StreamSource :: !StreamingBody -> BodySource
RawSource :: !(IO ByteString -> (ByteString -> IO ()) -> IO ()) -> !Response -> BodySource
data ResponseState
ResponseState :: !Status -> !(HashMap (CI ByteString) [ByteString]) -> !BodySource -> ResponseState
responseStateStatus :: ResponseState -> !Status
responseStateHeaders :: ResponseState -> !(HashMap (CI ByteString) [ByteString])
responseStateBodySource :: ResponseState -> !BodySource
newtype RoutePattern
RoutePattern :: (Request -> RoutePatternResult) -> RoutePattern
runRoutePattern :: RoutePattern -> Request -> RoutePatternResult

module Web.Growler.EventSource
eventSource :: MonadIO m => IO ServerEvent -> HandlerT m ()
