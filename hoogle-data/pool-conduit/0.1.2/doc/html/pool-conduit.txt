-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Resource pool allocations via ResourceT.
--   
--   Allocate resources from a pool, guaranteeing resource handling via the
--   ResourceT transformer.
@package pool-conduit
@version 0.1.2


-- | Allocate resources from a pool, guaranteeing resource handling via the
--   ResourceT transformer.
module Data.Conduit.Pool

-- | The result of taking a resource.
data ManagedResource m a
ManagedResource :: a -> (Bool -> m ()) -> m () -> ManagedResource m a

-- | The actual resource.
mrValue :: ManagedResource m a -> a

-- | Let's you specify whether the resource should be returned to the pool
--   (via <a>putResource</a>) or destroyed (via <a>destroyResource</a>) on
--   release. This defaults to destruction, in case of exceptions.
mrReuse :: ManagedResource m a -> Bool -> m ()

-- | Release this resource, either destroying it or returning it to the
--   pool.
mrRelease :: ManagedResource m a -> m ()

-- | Take a resource from the pool and register a release action.
takeResource :: MonadResource m => Pool a -> m (ManagedResource m a)

-- | Same as <a>takeResource</a>, but apply some action to check if a
--   resource is still valid.
takeResourceCheck :: MonadResource m => Pool a -> (a -> m Bool) -> m (ManagedResource m a)
data Pool a :: * -> *
createPool :: IO a -> (a -> IO ()) -> Int -> NominalDiffTime -> Int -> IO (Pool a)

-- | Temporarily take a resource from a <a>Pool</a>, perform an action with
--   it, and return it to the pool afterwards.
--   
--   <ul>
--   <li>If the pool has an idle resource available, it is used
--   immediately.</li>
--   <li>Otherwise, if the maximum number of resources has not yet been
--   reached, a new resource is created and used.</li>
--   <li>If the maximum number of resources has been reached, this function
--   blocks until a resource becomes available.</li>
--   </ul>
--   
--   If the action throws an exception of any type, the resource is
--   destroyed, and not returned to the pool.
--   
--   It probably goes without saying that you should never manually destroy
--   a pooled resource, as doing so will almost certainly cause a
--   subsequent user (who expects the resource to be valid) to throw an
--   exception.
withResource :: MonadBaseControl IO m => Pool a -> (a -> m b) -> m b

-- | Like <a>withResource</a>, but times out the operation if resource
--   allocation does not complete within the given timeout period.
--   
--   Since 0.1.2
withResourceTimeout :: MonadBaseControl IO m => Int -> Pool a -> (a -> m b) -> m (Maybe b)

-- | Like <a>withResource</a>, but uses <a>MonadResource</a> instead of
--   <a>MonadBaseControl</a>.
--   
--   Since 0.1.1
withResourceT :: MonadResource m => Pool a -> (a -> m b) -> m b
