-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Computing lenses generically using generics-sop
--   
--   This library contains a definition of generalized lenses that are
--   built on top of the <tt><a>fclabels</a></tt> package.
--   
--   It also contains SOP-style generic functions (based on the
--   <tt><a>generics-sop</a></tt> package) that compute lenses for a given
--   record type. Generalized lenses for the SOP representation types are
--   also provided.
--   
--   Furthermore, a generic function is provided that computes a lens from
--   a given (string-based) path specification.
@package lens-sop
@version 0.1.0.2


-- | Generalized lenses
--   
--   Intended to be imported qualified
--   
--   <pre>
--   import Generics.SOP.Lens as GLens
--   </pre>
module Generics.SOP.Lens

-- | GLens generalizes a monomorphic lens by allowing for different
--   categories for the getter and modifier
data GLens r w a b
lens :: r a b -> w (w b b, a) a -> GLens r w a b
get :: GLens r w a b -> r a b
modify :: GLens r w a b -> w (w b b, a) a
set :: Arrow w => GLens r w a b -> w (b, a) a
fromLens :: (Arrow r, ArrowApply w) => Lens (->) a b -> GLens r w a b
fromIso :: (Arrow r, ArrowApply w) => Iso (->) a b -> GLens r w a b
toLens :: GLens cat cat a b -> Lens cat a b
glenses :: (Generic a, Code a ~ '[xs], Arrow r, ArrowApply w) => NP (GLens r w a) xs
np :: (Arrow r, ArrowApply w, SingI xs) => NP (GLens r w (NP I xs)) xs
rep :: (Arrow r, ArrowApply w, Generic a) => GLens r w a (Rep a)
sop :: (Arrow r, ArrowApply w) => GLens r w (SOP f '[xs]) (NP f xs)
head :: (Arrow r, ArrowApply w) => GLens r w (NP f (x : xs)) (f x)
tail :: (Arrow r, ArrowApply w) => GLens r w (NP f (x : xs)) (NP f xs)
i :: (Arrow r, ArrowApply w) => GLens r w (I a) a
instance (Category r, ArrowApply w) => Category (GLens r w)

module Generics.SOP.Lens.Named
type LensName = String

-- | Total abstract lens
data NamedLens a ctxt
NamedLens :: GLens (->) (->) a b -> NamedLens a ctxt
unNamedLens :: NamedLens a ctxt -> GLens (->) (->) a b
get :: NamedLens a ctxt -> (forall b. ctxt b => b -> c) -> a -> c
modify :: NamedLens a ctxt -> (forall b. ctxt b => b -> b) -> a -> a
set :: NamedLens a ctxt -> (forall b. ctxt b => b) -> a -> a

-- | Construct named lenses for a record type
--   
--   NOTE: This will throw a runtime error for non-record types
gnamedLenses :: (Generic a, HasDatatypeInfo a, Code a ~ '[xs], All ctxt xs) => (DatatypeName -> ConstructorName -> LensName) -> [(String, NamedLens a ctxt)]
instance Show (NamedLens a ctxt)

module Generics.SOP.Lens.Computed

-- | An abstract lens qualifies existentially over the target type of the
--   lens
--   
--   Sadly, abstract lenses do not form a category, so we provide special
--   identity and composition functions.
data AbstractLens r w c a
AbstractLens :: (GLens r w a x) -> AbstractLens r w c a

-- | Identity abstract lens
abstractId :: (ArrowApply r, ArrowApply w, c a) => AbstractLens r w c a

-- | Compose with a pointwise lens on the right
afterGLens :: (ArrowApply r, ArrowApply w) => AbstractLens r w c a -> GLens r w b a -> AbstractLens r w c b

-- | Getter for computed lenses
--   
--   <pre>
--   get l == runIdentity . getM l . Identity
--   </pre>
get :: Category r => AbstractLens r w c a -> (forall x. c x => r a x -> b) -> b

-- | Setter for computed lenses
--   
--   <pre>
--   set l == runIdentity . setM l . Identity
--   </pre>
set :: Arrow w => AbstractLens r w c a -> (forall x. c x => x) -> w a a

-- | Modifier for computed lenses
modify :: Arrow w => AbstractLens r w c a -> (forall x. c x => w x x) -> w a a

-- | Getter with possibility for <a>compile time</a> failure
getM :: (Monad m, Category r) => AbstractLens r w c a -> (forall x. c x => r a x -> m b) -> m b

-- | Setter with possibility for <a>compile time</a> failure
setM :: (Monad m, Arrow w) => AbstractLens r w c a -> (forall x. c x => m x) -> m (w a a)

-- | Modifier with possibility for <a>compile time</a> failure
modifyM :: (Monad m, Arrow w) => AbstractLens r w c a -> (forall x. c x => m (w x x)) -> m (w a a)

-- | A path is a series of field names. For instance, given
--   
--   <pre>
--   data T1 = T1 { a :: Int, b :: Int } deriving Generic
--   data T2 = T2 { c :: T1,  d :: Int } deriving Generic
--   </pre>
--   
--   valid paths on T2 are
--   
--   <pre>
--   []
--   ["c"]
--   ["d"]
--   ["c", "a"]
--   ["c", "b"]
--   </pre>
type Path = [String]

-- | Compute a lens for a given type and path
--   
--   The <tt>Either</tt> is used to indicate <a>compile time</a> failure of
--   the computation of the lens (for instance, when this path is invalid
--   for this data type).
--   
--   Some lenses may of course be themselves effectful, depending on the
--   category. However, the lenses returned by the generic computation are
--   pure and total (as is evident from the type of glens).
class CLens r w c a where lens = glens
lens :: CLens r w c a => LensOptions -> Path -> Either String (AbstractLens r w c a)

-- | A lens for abstract types (supports empty paths only)
--   
--   Useful for defining CLens instances for types such as Int, Bool, Text,
--   etc.
--   
--   <pre>
--   instance CLens c Int where lens = emptyPathOnly
--   </pre>
emptyPathOnly :: (ArrowApply r, ArrowApply w, c a) => LensOptions -> Path -> Either String (AbstractLens r w c a)
data LensOptions
LensOptions :: (DatatypeName -> FieldName -> String -> Bool) -> LensOptions

-- | Match a selector against a path component
lensOptionsMatch :: LensOptions -> DatatypeName -> FieldName -> String -> Bool

-- | Default match just compares field names
defaultLensOptions :: LensOptions
