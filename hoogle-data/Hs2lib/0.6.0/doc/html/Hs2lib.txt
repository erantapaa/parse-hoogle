-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.
--   
--   The supplied PreProcessor can be run over any existing source and
--   would generate FFI code for every function marked to be exported by
--   the special notation documented inside the package. It then proceeds
--   to compile this generated code into a lib.
--   
--   The Library contains some helper code that's commonly needed to
--   convert between types, and contains the code for the typeclasses the
--   PreProcessor uses in the generated code to keep things clean.
--   
--   It will always generated the required C types for use when calling the
--   dll, but it will also generate the C# unsafe code if requested.
--   
--   Read http:<i></i>blog.zhox.com/hs2lib.pdf (not published yet)
--   
--   Current Restrictions:
--   
--   <ul>
--   <li>Does NOT support x64 bit versions of GHC. This will be added in
--   future versions if enough demand exist.</li>
--   <li>You cannot export functions which have the same name (even if
--   they're in different modules because 1 big hsc file is generated at
--   the moment, no conflict resolutions)</li>
--   <li>You cannot export datatypes with the same name, same restriction
--   as above.</li>
--   <li>Does not support automatic instance generation for infix
--   constructors yet</li>
--   </ul>
--   
--   NOTE: Package is not working again, but I have fixed the version of
--   haskell-src-exts to prevent it from breaking again.
@package Hs2lib
@version 0.6.0


-- | Contains a pseudo implementation of an artificial stack. This is used
--   to print a StackTrace out and manipulate the stack.
module WinDll.Debug.Stack

-- | A simple stack implementation
data Stack
class Show a => Stackable a
toStack :: Stackable a => a -> Stack
type FunctionName = String

-- | Creating an empty stack
emptyStack :: Stack

-- | Adding an element to the top of the stack
pushStack :: Stackable st => st -> FunctionName -> Stack

-- | Look at the item at the top of the stack, but does not remove it
topStack :: Stack -> Maybe FunctionName

-- | Remove an element from the top of the stack
popStack :: Stack -> Stack

-- | Create a new stack from a template
newStack :: FunctionName -> Stack

-- | The size of the stack e.g the amount of elements inside it
sizeStack :: Stack -> Int

-- | Shrinks and Compress the stack, reducing the stack to the bare minimum
--   of steps/calls needed to represent the same stack
shrinkStack :: Stack -> Stack

-- | Pretty print a stack back out to a string
printStack :: Stack -> String
instance Typeable Stack
instance Data Stack
instance Eq Stack
instance Show Stack
instance Read Stack
instance Ord Stack
instance Stackable String
instance Stackable Stack


-- | Contains the structures to hold allocation information used when
--   debugging.
module WinDll.Debug.Records

-- | The allocation structure/record that is used to keep track of
--   allocations
data MemAlloc
MemAlloc :: Caller -> Stack -> PtrLocation -> Maybe PtrLocation -> Maybe MemSize -> String -> MemAlloc
memFun :: MemAlloc -> Caller
memStack :: MemAlloc -> Stack
memStart :: MemAlloc -> PtrLocation
memStop :: MemAlloc -> Maybe PtrLocation
memSize :: MemAlloc -> Maybe MemSize
memTime :: MemAlloc -> String
MemFree :: Stack -> PtrLocation -> Maybe MemSize -> String -> MemAlloc
memStack :: MemAlloc -> Stack
memStart :: MemAlloc -> PtrLocation
memSize :: MemAlloc -> Maybe MemSize
memTime :: MemAlloc -> String

-- | Identifier which shows which function was invoked to do allocations
data Caller
Malloc :: Caller
Alloc :: Caller
ReAlloc :: Caller
Other :: Caller
Record :: Caller

-- | The file to write the results too
fileName :: IO String

-- | Write out a single allocation structure out to file.
writeMemAlloc :: MemAlloc -> IO ()
instance Show Caller
instance Read Caller
instance Show MemAlloc
instance Read MemAlloc


-- | These re-exported allocation functions allows us to keep track of
--   memory allocations within our program. We can later analyze this to
--   find memory leaks
module WinDll.Debug.Alloc

-- | Re-export of the Foreign.Marshal.Alloc.alloca function taking an
--   explicit stack
alloca :: (Storable a, Stackable st) => st -> (Ptr a -> IO b) -> IO b

-- | Re-export of the Foreign.Marshal.Alloc.malloc function taking an
--   explicit stack
malloc :: (Storable a, Stackable st) => st -> IO (Ptr a)

-- | Re-export of the Foreign.Marshal.Alloc.realloc function taking an
--   explicit stack
realloc :: (Storable b, Stackable st) => st -> Ptr a -> IO (Ptr b)

-- | This function record the allocation information about a Ptr we
--   couldn't override it's allocation function for.
record :: (Storable a, Stackable st, Show (m a)) => st -> m a -> IO ()

-- | This function mirrors <i>record</i> in its function. Except that the
--   value it's given might not be a ptr value
recordM :: (Storable a, Stackable st) => st -> b -> (b -> IO (Ptr a)) -> IO (Ptr a)

-- | Free a ptr that is not a normal Ptr type, (e.g. ForeignPtr etc)
freeDefault :: (Storable a, Stackable st, Show (m a)) => st -> m a -> (m a -> IO ()) -> IO ()

-- | Free a ptr that is not a normal Ptr type, (e.g. ForeignPtr etc),
--   however it does not record the size of the value held by the pointer.
--   as such, it has no need for the Storable requirement
freeUnknown :: (Stackable st, Show (m a)) => st -> m a -> (m a -> IO ()) -> IO ()

-- | Re-export of the Foreign.Marshal.Alloc.free function taking an
--   explicit stack
free :: (Storable a, Stackable st) => st -> Ptr a -> IO ()


-- | A module containing memory management exports that will be
--   automatically added to your file when --debug is being used.
module WinDll.Debug.Exports
freeS :: Ptr () -> IO ()
freeC :: Ptr () -> IO ()
recordS :: Ptr () -> IO ()
recordC :: Ptr () -> IO ()


-- | Module containing types and enums for misc instances, for commonly
--   used datatypes like Maybe, Either etc
module WinDll.Lib.InstancesTypes
maybenothing :: Int
maybejust :: Int
eitherleft :: Int
eitherright :: Int
type MaybePtr a = Ptr (Maybe a)
type EitherPtr a b = Ptr (Either a b)


-- | This module contains the lookup values to do type conversions. These
--   lists are the basic, build-in predefined lists.
module WinDll.Lib.Native
type Defs = [(String, String)]

-- | List containing mapping to C/C++ Types
nativeLisths2c :: [(String, String)]

-- | Contains a list of mapping types. This is the first list to be
--   extended by the pragmas We need to preserve the Haskell type name for
--   later transformations and for FFI
nativeConvList :: [(String, String)]

-- | List of type conversion from C/C++ to C# types
nativeC2cslist :: [(String, String)]

-- | List containing mapping to C# Types
nativeCslist :: Bool -> [(String, String)]

-- | List containing mapping to CSizes
nativeC_sizes :: [(String, Int)]
defaultPointerSize :: Int


-- | Types used when describing structures in WinDll
module WinDll.Structs.Types
type Name = String
type ModuleName = String
type Import = String
type ExportName = String
type Type = Type
type TypeName = String
type TypeNames = [TypeName]
type NamedTypes = [(Name, Type)]
type AnnNamedTypes = [AnnType]
type Types = [Type]

-- | Annotation on functions, This allows more complex types to be
--   expressed
data Ann
Ann :: [Int] -> Bool -> [Int] -> [(String, String)] -> [(String, String)] -> [(String, Int)] -> (Bool -> [(String, String)]) -> Bool -> ModuleName -> Ann

-- | Offsets into the type list to indicate which fields are counters for
--   lists
annArrayIndices :: Ann -> [Int]

-- | Indicates if the field type is a List type.
annArrayIsList :: Ann -> Bool

-- | Indices/Offsets to indicate whether this function has any StablePtr
--   values
annStableIndices :: Ann -> [Int]

-- | Copy of the definition list for the Haskell translation functions
annWorkingSet :: Ann -> [(String, String)]

-- | Copy of the definition list for the C translation functions
annWorkingSetC :: Ann -> [(String, String)]

-- | Copy of the definition list for the C sizes translation functions
annWorkingSetCSize :: Ann -> [(String, Int)]

-- | Copy of the definition list for the C# translation functions
annWorkingSetCs :: Ann -> Bool -> [(String, String)]

-- | Indicates is debugging has been enabled for this session
annDebug :: Ann -> Bool
annModule :: Ann -> ModuleName

-- | Annotated type, basically a 4-tuple that holds all possible
--   information on a datatype field
data AnnType
AnnType :: Name -> Type -> Ann -> Type -> ModuleName -> AnnType

-- | The field name, if this is a record the name will be the record name.
antName :: AnnType -> Name

-- | The preprocessed type of the field
antType :: AnnType -> Type

-- | The type annotations for the antType
antAnn :: AnnType -> Ann

-- | The original unpreprocessed type
antOrigType :: AnnType -> Type

-- | The module that originally defined the type
antModule :: AnnType -> ModuleName

-- | Generic empty annotation
noAnn :: Ann

-- | Find any Names embedded within any arbitraty structures
findStrings' :: Data a => a -> [String]
instance Typeable Ann
instance Typeable AnnType
instance Show Ann
instance Eq Ann
instance Data Ann
instance Show AnnType
instance Eq AnnType
instance Data AnnType
instance Show (Bool -> [(String, String)])
instance Eq (Bool -> [(String, String)])
instance Monoid Ann


-- | Contains the list of native types and their mapping to their
--   equivalent FFI types
module WinDll.Lib.NativeMapping_Debug

-- | Typeclase to allow Left LoaD transform. It is basically to allow a
--   transformation to take place at the last argument/return type of the
--   function. This is because most of the functions are in IO.
class LLD m a b c | b -> c
lld :: LLD m a b c => m a b -> m a c

-- | A class that manages the conversion between the normal and type
--   supported by ffi. Minimal implementation requires atleast one of the
--   pair toNative<i>toFFI and fromNative</i>fromFFI. The implementation
--   will almost always call fromNative and toNative because all exported
--   functions are in IO since they all might have side-effects. The only
--   exception to this is for the defaults provided in this module.
class FFIType phi ix where toFFI st = error $ show st ++ ": toFFI is undefined for the specified type, try toNative instead." fromFFI st = error $ show st ++ ": fromFFI is undefined for the specified type, try fromNative instead." fromList st = error $ show st ++ ": fromList is undefined for this type. " ++ "Please add a definition or consider using one of the default ones." fromNative st = return . fromFFI st toNative st = return . toFFI st freeFFI = \ _ _ _ -> return ()
toFFI :: (FFIType phi ix, Stackable st) => st -> phi -> ix
fromFFI :: (FFIType phi ix, Stackable st) => st -> ix -> phi
fromList :: (FFIType phi ix, Stackable st) => st -> CInt -> ix -> IO phi
fromNative :: (FFIType phi ix, Stackable st) => st -> ix -> IO phi
toNative :: (FFIType phi ix, Stackable st) => st -> phi -> IO ix
freeFFI :: (FFIType phi ix, Stackable st) => st -> phi -> ix -> IO ()

-- | Tranform functions to and from the correct types TODO: Update this
--   variant to use the impure variants, This will be an issue.. TODO: Can
--   this even be defined using the native functions? This instance can't
--   be generated. It'll stay here for now, buy it can only be used by
--   types which define toFFI<i>fromFFI instead of toNative</i>fromNative
--   instance (FFIType a b, FFIType c d) =&gt; FFIType (a -&gt; c) (b -&gt;
--   d) where toFFI st f x = toFFI st (f (fromFFI st x)) fromFFI st f x =
--   fromFFI st (f (toFFI st x))
newtype Pure a
Pure :: a -> Pure a
pure :: Pure a -> a

-- | Tuples are not FFI compatible, As such i'll translate them to a build
--   in tuple datatype . This function translates the embedded types of a
--   Ty to the correct forms using the function translate' (see below)
translate :: Defs -> Type -> Type

-- | Translate everything but applied types. e.g. Foo Token -&gt; FooPtr
--   Token And lists, since lists are implicitly an applied type: e.g
--   [Token] --&gt;&gt; [] Token --&gt;&gt; Ptr Token
translatePartial :: Defs -> Type -> Type

-- | Check to see if the next type is a Simple type. e.g. A TyVar or TyCon
isSimpleType :: Type -> Bool

-- | Contrary to translate translatePrimitive will only transform the
--   defined primitive types in the convList below. This is because while a
--   transformed signature should only be partially transformed till the
--   first application (Since that'll be the main pointer) we should
--   pre-transform the primitive types into their well known static forms.
translatePrimitive :: Defs -> Type -> Type

-- | Helper function to define translatePrimitive. It attemps to lookup the
--   type in convList but in the case where it's not found the search query
--   is returned.
translateP :: Defs -> String -> String

-- | Translate Partial Form, This is basically translatePrimitive .
--   translatePartial
translatePForm :: Defs -> Type -> Type

-- | Look up the FFI type representation of the given type. Moreover when
--   the type is not found it is assumed to be a new structure and it is
--   assumed to be a pointer value.
translate' :: Defs -> String -> String

-- | Remove all spaces from a sentence
trim :: String -> String

-- | A function to split a list of elements by the given seperator
split :: Eq a => [a] -> a -> [[a]]
instance [incoherent] Functor Pure
instance [incoherent] FFIType Char CWchar
instance [incoherent] FFIType Rational CDouble
instance [incoherent] FFIType Char CChar
instance [incoherent] (Num a, Integral a) => FFIType Integer a
instance [incoherent] Storable a => Storable [a]
instance [incoherent] (FFIType a b, Storable b) => FFIType [a] (Ptr CInt -> IO (Ptr b))
instance [incoherent] Storable a => FFIType [a] (Ptr a)
instance [incoherent] Storable a => FFIType a (Ptr a)
instance [incoherent] FFIType Float CFloat
instance [incoherent] FFIType Int CInt
instance [incoherent] FFIType FastString CWString
instance [incoherent] FFIType CLLong CLLong
instance [incoherent] FFIType CDouble CDouble
instance [incoherent] FFIType CInt CInt
instance [incoherent] FFIType CWString CWString
instance [incoherent] FFIType CWchar CWchar
instance [incoherent] (Storable a, FFIType b a) => FFIType [b] (Ptr a)
instance [incoherent] FFIType String CWString
instance [incoherent] (FFIType (Pure a) (Pure b), FFIType (Pure c) (Pure d), FFIType c d, FFIType a b) => FFIType (Pure (a -> c)) (Pure (b -> d))
instance [incoherent] FFIType a b => FFIType (Pure [a]) (Pure [b])
instance [incoherent] FFIType (Pure Char) (Pure CWchar)
instance [incoherent] FFIType (Pure Rational) (Pure CDouble)
instance [incoherent] FFIType (Pure Char) (Pure CChar)
instance [incoherent] (Num a, Integral a) => FFIType (Pure Integer) (Pure a)
instance [incoherent] FFIType (Pure Float) (Pure CFloat)
instance [incoherent] FFIType (Pure Int) (Pure CInt)
instance [incoherent] FFIType (FunPtr a) (FunPtr a)
instance [incoherent] FFIType (StablePtr a) (StablePtr a)
instance [incoherent] FFIType Bool Int8
instance [incoherent] FFIType Bool Word8
instance [incoherent] FFIType Bool CInt
instance [incoherent] FFIType Bool Bool
instance [incoherent] FFIType () ()
instance [incoherent] LLD (->) a b (IO b)


-- | Module containing definitions for tuples, since those can't be
--   automatically translated. We This file contains predefined mappings of
--   tuples till 8-tuples. If you need more you need to unfortunately add
--   these yourself
module WinDll.Lib.Tuples_Debug
data Tuple2 a b
Tuple2 :: a -> b -> Tuple2 a b
data Tuple3 a b c
Tuple3 :: a -> b -> c -> Tuple3 a b c
data Tuple4 a b c d
Tuple4 :: a -> b -> c -> d -> Tuple4 a b c d
data Tuple5 a b c d e
Tuple5 :: a -> b -> c -> d -> e -> Tuple5 a b c d e
data Tuple6 a b c d e f
Tuple6 :: a -> b -> c -> d -> e -> f -> Tuple6 a b c d e f
data Tuple7 a b c d e f g
Tuple7 :: a -> b -> c -> d -> e -> f -> g -> Tuple7 a b c d e f g
data Tuple8 a b c d e f g h
Tuple8 :: a -> b -> c -> d -> e -> f -> g -> h -> Tuple8 a b c d e f g h
type Tuple2Ptr a b = Ptr (Tuple2 a b)
type Tuple3Ptr a b c = Ptr (Tuple3 a b c)
type Tuple4Ptr a b c d = Ptr (Tuple4 a b c d)
type Tuple5Ptr a b c d e = Ptr (Tuple5 a b c d e)
type Tuple6Ptr a b c d e f = Ptr (Tuple6 a b c d e f)
type Tuple7Ptr a b c d e f g = Ptr (Tuple7 a b c d e f g)
type Tuple8Ptr a b c d e f g h = Ptr (Tuple8 a b c d e f g h)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g, Storable h) => Storable (a, b, c, d, e, f, g, h)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => Storable (a, b, c, d, e, f, g)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => Storable (a, b, c, d, e, f)
instance (Storable a, Storable b, Storable c, Storable d, Storable e) => Storable (a, b, c, d, e)
instance (Storable a, Storable b, Storable c, Storable d) => Storable (a, b, c, d)
instance (Storable a, Storable b, Storable c) => Storable (a, b, c)
instance (Storable a, Storable b) => Storable (a, b)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g, Storable h) => Storable (Tuple8 a b c d e f g h)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => Storable (Tuple7 a b c d e f g)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => Storable (Tuple6 a b c d e f)
instance (Storable a, Storable b, Storable c, Storable d, Storable e) => Storable (Tuple5 a b c d e)
instance (Storable a, Storable b, Storable c, Storable d) => Storable (Tuple4 a b c d)
instance (Storable a, Storable b, Storable c) => Storable (Tuple3 a b c)
instance (Storable a, Storable b) => Storable (Tuple2 a b)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, FFIType m n, FFIType o p, Storable n, Storable p, Storable j, Storable l, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g, i, k, m, o) (Tuple8Ptr b d f h j l n p)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, FFIType m n, Storable n, Storable j, Storable l, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g, i, k, m) (Tuple7Ptr b d f h j l n)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, Storable j, Storable l, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g, i, k) (Tuple6Ptr b d f h j l)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, Storable j, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g, i) (Tuple5Ptr b d f h j)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g) (Tuple4Ptr b d f h)
instance (FFIType a b, FFIType c d, FFIType e f, Storable b, Storable d, Storable f) => FFIType (a, c, e) (Tuple3Ptr b d f)
instance (FFIType a b, FFIType c d, Storable b, Storable d) => FFIType (a, c) (Tuple2Ptr b d)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, FFIType m n, FFIType o p) => FFIType (a, c, e, g, i, k, m, o) (Tuple8 b d f h j l n p)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, FFIType m n) => FFIType (a, c, e, g, i, k, m) (Tuple7 b d f h j l n)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l) => FFIType (a, c, e, g, i, k) (Tuple6 b d f h j l)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j) => FFIType (a, c, e, g, i) (Tuple5 b d f h j)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h) => FFIType (a, c, e, g) (Tuple4 b d f h)
instance (FFIType a b, FFIType c d, FFIType e f) => FFIType (a, c, e) (Tuple3 b d f)
instance (FFIType a b, FFIType c d) => FFIType (a, c) (Tuple2 b d)
instance Storable a => Functor (Tuple8 a b c d e f g)
instance Storable a => Functor (Tuple7 a b c d e f)
instance Storable a => Functor (Tuple6 a b c d e)
instance Storable a => Functor (Tuple5 a b c d)
instance Storable a => Functor (Tuple4 a b c)
instance Storable a => Functor (Tuple3 a b)
instance Storable a => Functor (Tuple2 a)


-- | Contains the list of native types and their mapping to their
--   equivalent FFI types
module WinDll.Lib.NativeMapping

-- | Typeclase to allow Left LoaD transform. It is basically to allow a
--   transformation to take place at the last argument/return type of the
--   function. This is because most of the functions are in IO.
class LLD m a b c | b -> c
lld :: LLD m a b c => m a b -> m a c

-- | A class that manages the conversion between the normal and type
--   supported by ffi. Minimal implementation requires atleast one of the
--   pair toNative<i>toFFI and fromNative</i>fromFFI. The implementation
--   will almost always call fromNative and toNative because all exported
--   functions are in IO since they all might have side-effects. The only
--   exception to this is for the defaults provided in this module.
class FFIType phi ix where toFFI = error "toFFI is undefined for the specified type, try toNative instead." fromFFI = error "fromFFI is undefined for the specified type, try fromNative instead." fromList ic = error "fromList is undefined for this type. Please add a definition or consider using one of the default ones" fromNative = return . fromFFI toNative = return . toFFI freeFFI = \ _ _ -> return ()
toFFI :: FFIType phi ix => phi -> ix
fromFFI :: FFIType phi ix => ix -> phi
fromList :: FFIType phi ix => CInt -> ix -> IO phi
fromNative :: FFIType phi ix => ix -> IO phi
toNative :: FFIType phi ix => phi -> IO ix
freeFFI :: FFIType phi ix => phi -> ix -> IO ()

-- | Tranform functions to and from the correct types TODO: Update this
--   variant to use the impure variants, This will be an issue.. TODO: Can
--   this even be defined using the native functions? This instance can't
--   be generated. It'll stay here for now, buy it can only be used by
--   types which define toFFI<i>fromFFI instead of toNative</i>fromNative
--   instance (FFIType a b, FFIType c d) =&gt; FFIType (a -&gt; c) (b -&gt;
--   d) where toFFI f x = toFFI (f (fromFFI x)) fromFFI f x = fromFFI (f
--   (toFFI x))
newtype Pure a
Pure :: a -> Pure a
pure :: Pure a -> a

-- | Tuples are not FFI compatible, As such i'll translate them to a build
--   in tuple datatype . This function translates the embedded types of a
--   Ty to the correct forms using the function translate' (see below)
translate :: Defs -> Type -> Type

-- | Translate everything but applied types. e.g. Foo Token -&gt; FooPtr
--   Token And lists, since lists are implicitly an applied type: e.g
--   [Token] --&gt;&gt; [] Token --&gt;&gt; Ptr Token
translatePartial :: Defs -> Type -> Type

-- | Check to see if the next type is a Simple type. e.g. A TyVar or TyCon
isSimpleType :: Type -> Bool

-- | Contrary to translate translatePrimitive will only transform the
--   defined primitive types in the convList below. This is because while a
--   transformed signature should only be partially transformed till the
--   first application (Since that'll be the main pointer) we should
--   pre-transform the primitive types into their well known static forms.
translatePrimitive :: Defs -> Type -> Type

-- | Helper function to define translatePrimitive. It attemps to lookup the
--   type in convList but in the case where it's not found the search query
--   is returned.
translateP :: Defs -> String -> String

-- | Translate Partial Form, This is basically translatePrimitive .
--   translatePartial
translatePForm :: Defs -> Type -> Type

-- | Look up the FFI type representation of the given type. Moreover when
--   the type is not found it is assumed to be a new structure and it is
--   assumed to be a pointer value.
translate' :: Defs -> String -> String

-- | Remove all spaces from a sentence
trim :: String -> String

-- | A function to split a list of elements by the given seperator
split :: Eq a => [a] -> a -> [[a]]
instance [incoherent] Functor Pure
instance [incoherent] FFIType Char CWchar
instance [incoherent] FFIType Rational CDouble
instance [incoherent] FFIType Char CChar
instance [incoherent] (Num a, Integral a) => FFIType Integer a
instance [incoherent] Storable a => Storable [a]
instance [incoherent] (FFIType a b, Storable b) => FFIType [a] (Ptr CInt -> IO (Ptr b))
instance [incoherent] Storable a => FFIType [a] (Ptr a)
instance [incoherent] Storable a => FFIType a (Ptr a)
instance [incoherent] FFIType Float CFloat
instance [incoherent] FFIType Int CInt
instance [incoherent] FFIType FastString CWString
instance [incoherent] FFIType CLLong CLLong
instance [incoherent] FFIType CDouble CDouble
instance [incoherent] FFIType CInt CInt
instance [incoherent] FFIType CWString CWString
instance [incoherent] FFIType CWchar CWchar
instance [incoherent] (Storable a, FFIType b a) => FFIType [b] (Ptr a)
instance [incoherent] FFIType String CWString
instance [incoherent] (FFIType (Pure a) (Pure b), FFIType (Pure c) (Pure d), FFIType c d, FFIType a b) => FFIType (Pure (a -> c)) (Pure (b -> d))
instance [incoherent] FFIType a b => FFIType (Pure [a]) (Pure [b])
instance [incoherent] FFIType (Pure Char) (Pure CWchar)
instance [incoherent] FFIType (Pure Rational) (Pure CDouble)
instance [incoherent] FFIType (Pure Char) (Pure CChar)
instance [incoherent] (Num a, Integral a) => FFIType (Pure Integer) (Pure a)
instance [incoherent] FFIType (Pure Float) (Pure CFloat)
instance [incoherent] FFIType (Pure Int) (Pure CInt)
instance [incoherent] FFIType (FunPtr a) (FunPtr a)
instance [incoherent] FFIType (StablePtr a) (StablePtr a)
instance [incoherent] FFIType Bool Int8
instance [incoherent] FFIType Bool Word8
instance [incoherent] FFIType Bool CInt
instance [incoherent] FFIType Bool Bool
instance [incoherent] FFIType () ()
instance [incoherent] LLD (->) a b (IO b)


-- | Module containing definitions for tuples, since those can't be
--   automatically translated. We This file contains predefined mappings of
--   tuples till 8-tuples. If you need more you need to unfortunately add
--   these yourself
module WinDll.Lib.Tuples
data Tuple2 a b
Tuple2 :: a -> b -> Tuple2 a b
data Tuple3 a b c
Tuple3 :: a -> b -> c -> Tuple3 a b c
data Tuple4 a b c d
Tuple4 :: a -> b -> c -> d -> Tuple4 a b c d
data Tuple5 a b c d e
Tuple5 :: a -> b -> c -> d -> e -> Tuple5 a b c d e
data Tuple6 a b c d e f
Tuple6 :: a -> b -> c -> d -> e -> f -> Tuple6 a b c d e f
data Tuple7 a b c d e f g
Tuple7 :: a -> b -> c -> d -> e -> f -> g -> Tuple7 a b c d e f g
data Tuple8 a b c d e f g h
Tuple8 :: a -> b -> c -> d -> e -> f -> g -> h -> Tuple8 a b c d e f g h
type Tuple2Ptr a b = Ptr (Tuple2 a b)
type Tuple3Ptr a b c = Ptr (Tuple3 a b c)
type Tuple4Ptr a b c d = Ptr (Tuple4 a b c d)
type Tuple5Ptr a b c d e = Ptr (Tuple5 a b c d e)
type Tuple6Ptr a b c d e f = Ptr (Tuple6 a b c d e f)
type Tuple7Ptr a b c d e f g = Ptr (Tuple7 a b c d e f g)
type Tuple8Ptr a b c d e f g h = Ptr (Tuple8 a b c d e f g h)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g, Storable h) => Storable (a, b, c, d, e, f, g, h)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => Storable (a, b, c, d, e, f, g)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => Storable (a, b, c, d, e, f)
instance (Storable a, Storable b, Storable c, Storable d, Storable e) => Storable (a, b, c, d, e)
instance (Storable a, Storable b, Storable c, Storable d) => Storable (a, b, c, d)
instance (Storable a, Storable b, Storable c) => Storable (a, b, c)
instance (Storable a, Storable b) => Storable (a, b)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g, Storable h) => Storable (Tuple8 a b c d e f g h)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => Storable (Tuple7 a b c d e f g)
instance (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => Storable (Tuple6 a b c d e f)
instance (Storable a, Storable b, Storable c, Storable d, Storable e) => Storable (Tuple5 a b c d e)
instance (Storable a, Storable b, Storable c, Storable d) => Storable (Tuple4 a b c d)
instance (Storable a, Storable b, Storable c) => Storable (Tuple3 a b c)
instance (Storable a, Storable b) => Storable (Tuple2 a b)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, FFIType m n, FFIType o p, Storable n, Storable p, Storable j, Storable l, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g, i, k, m, o) (Tuple8Ptr b d f h j l n p)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, FFIType m n, Storable n, Storable j, Storable l, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g, i, k, m) (Tuple7Ptr b d f h j l n)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, Storable j, Storable l, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g, i, k) (Tuple6Ptr b d f h j l)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, Storable j, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g, i) (Tuple5Ptr b d f h j)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, Storable b, Storable d, Storable f, Storable h) => FFIType (a, c, e, g) (Tuple4Ptr b d f h)
instance (FFIType a b, FFIType c d, FFIType e f, Storable b, Storable d, Storable f) => FFIType (a, c, e) (Tuple3Ptr b d f)
instance (FFIType a b, FFIType c d, Storable b, Storable d) => FFIType (a, c) (Tuple2Ptr b d)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, FFIType m n, FFIType o p) => FFIType (a, c, e, g, i, k, m, o) (Tuple8 b d f h j l n p)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l, FFIType m n) => FFIType (a, c, e, g, i, k, m) (Tuple7 b d f h j l n)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j, FFIType k l) => FFIType (a, c, e, g, i, k) (Tuple6 b d f h j l)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h, FFIType i j) => FFIType (a, c, e, g, i) (Tuple5 b d f h j)
instance (FFIType a b, FFIType c d, FFIType e f, FFIType g h) => FFIType (a, c, e, g) (Tuple4 b d f h)
instance (FFIType a b, FFIType c d, FFIType e f) => FFIType (a, c, e) (Tuple3 b d f)
instance (FFIType a b, FFIType c d) => FFIType (a, c) (Tuple2 b d)
instance Storable a => Functor (Tuple8 a b c d e f g)
instance Storable a => Functor (Tuple7 a b c d e f)
instance Storable a => Functor (Tuple6 a b c d e)
instance Storable a => Functor (Tuple5 a b c d)
instance Storable a => Functor (Tuple4 a b c)
instance Storable a => Functor (Tuple3 a b)
instance Storable a => Functor (Tuple2 a)


-- | This module handles generically the convertion from and to native
--   types
module WinDll.Lib.Converter
