-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Primitive functions for updating many elements in mutable arrays at once
--   
--   An collection of functions for working with multiple elements in
--   mutable arrays. It is hoped some or all of these functions will be
--   included in the array package for GHC 7.2. New in this version:
--   Basically all names have been changed. A lot of redundant information
--   has been removed as well.
@package array-utils
@version 0.3

module Data.Array.Util

-- | updateAll mutates every element in an array while avoiding all bounds
--   checks. Think of it as a mutable version of map. <i>O(size of arr)</i>
--   
--   <pre>
--   &gt;&gt;&gt; arr &lt;- newArray (1,10) 0 :: IO (IOArray Int Int)
--       -- Produces a 1 based array with 10 elements all set to 0.
--   
--   &gt;&gt;&gt; updateAll arr (+ 10)
--       -- Updates all elements to 10
--   </pre>
updateAll :: (MArray a e m, Ix i) => (e -> e) -> a i e -> m ()

-- | The same as updateAll, but also providing the index to the mapping
--   function. <i>O(size of arr)</i>
updateAllIx :: (MArray a e m, Ix i) => (i -> e -> e) -> a i e -> m ()

-- | The same as updateAll but taking a monadic function. <i>O(size of
--   arr)</i>
updateAllM :: (MArray a e m, Ix i) => (e -> m e) -> a i e -> m ()

-- | The same updateAllIx but taking a monadic function. <i>O(size of
--   arr)</i>
updateAllIxM :: (MArray a e m, Ix i) => (i -> e -> m e) -> a i e -> m ()

-- | Takes a mapping function, and a list of indicies to mutate.
--   
--   Throws an <a>IndexOutOfBounds</a> exception if any of the indicies are
--   out of bounds. In this case the array will be left unmutated.
--   
--   <i>O(length xs)</i>
updateOn :: (MArray a e m, Ix i) => (e -> e) -> [i] -> a i e -> m ()
updateOnIx :: (MArray a e m, Ix i) => (i -> e -> e) -> [i] -> a i e -> m ()
updateOnM :: (MArray a e m, Ix i) => (e -> m e) -> [i] -> a i e -> m ()
updateOnIxM :: (MArray a e m, Ix i) => (i -> e -> m e) -> [i] -> a i e -> m ()

-- | Takes an update function <tt>f</tt> and a tuple of indicies '(start,
--   finish)', and applies the function to all elements returned by 'range
--   (start, finish)'.
--   
--   If this is a 2D array, then the area updated will be the box bounded
--   by these elements, and the rectangular prism area for a 3D array etc.
--   
--   Throws an <a>IndexOutOfBounds</a> exception if either of the indicies
--   are out of bounds.
updateWithin :: (MArray a e m, Ix i) => (e -> e) -> (i, i) -> a i e -> m ()
updateWithinIx :: (MArray a e m, Ix i, Show i) => (i -> e -> e) -> (i, i) -> a i e -> m ()
updateWithinM :: (MArray a e m, Ix i) => (e -> m e) -> (i, i) -> a i e -> m ()
updateWithinIxM :: (MArray a e m, Ix i, Show i) => (i -> e -> m e) -> (i, i) -> a i e -> m ()

-- | updateSlice mutates every element in an array between a start index
--   and an end index. <i>O(size of arr)</i>
--   
--   <pre>
--   &gt;&gt;&gt; arr &lt;- newArray (1,10) 0 :: IO (IOArray Int Int)
--       -- Produces a 1 based array with 10 elements all set to 0.
--   
--   &gt;&gt;&gt; updateSlice arr (2,4) (+ 10)
--       -- Updates elements at indexes 2, 3 and 4 to 10
--   </pre>
updateSlice :: (MArray a e m, Ix i) => (e -> e) -> (i, i) -> a i e -> m ()
updateSliceM :: (MArray a e m, Ix i) => (e -> m e) -> (i, i) -> a i e -> m ()
