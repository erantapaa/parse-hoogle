-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Disciplined Disciple Compiler core language and type checker.
--   
--   Disciple Core is an explicitly typed language based on System-F2,
--   intended as an intermediate representation for a compiler. In addition
--   to the polymorphism of System-F2 it supports region, effect and
--   closure typing. Evaluation order is left-to-right call-by-value by
--   default. There is a capability system to track whether objects are
--   mutable or constant, and to ensure that computations that perform
--   visible side effects are not reordered inappropriately. See the
--   <tt>ddc-tools</tt> package for a user-facing interpreter and compiler.
@package ddc-core
@version 0.4.1.3

module DDC.Type.Exp

-- | A value type, kind, or sort.
--   
--   We use the same data type to represent all three universes, as they
--   have a similar algebraic structure.
data Type n

-- | Variable.
TVar :: !(Bound n) -> Type n

-- | Constructor.
TCon :: !(TyCon n) -> Type n

-- | Abstraction.
TForall :: !(Bind n) -> !(Type n) -> Type n

-- | Application.
TApp :: !(Type n) -> !(Type n) -> Type n

-- | Least upper bound.
TSum :: !(TypeSum n) -> Type n
type Kind n = Type n
type Sort n = Type n
type Region n = Type n
type Effect n = Type n
type Closure n = Type n

-- | A least upper bound of several types.
--   
--   We keep type sums in this normalised format instead of joining them
--   together with a binary operator (like <tt>(+)</tt>). This makes sums
--   easier to work with, as a given sum type often only has a single
--   physical representation.
data TypeSum n
TypeSumBot :: !(Kind n) -> TypeSum n

-- | The kind of the elements in this sum.
typeSumKind :: TypeSum n -> !(Kind n)
TypeSumSet :: !(Kind n) -> !(Array TyConHash (Set (TypeSumVarCon n))) -> !(Map n (Kind n)) -> !(Map Int (Kind n)) -> ![Type n] -> TypeSum n

-- | The kind of the elements in this sum.
typeSumKind :: TypeSum n -> !(Kind n)

-- | Where we can see the outer constructor of a type, its argument is
--   inserted into this array. This handles common cases like Read, Write,
--   Alloc effects.
typeSumElems :: TypeSum n -> !(Array TyConHash (Set (TypeSumVarCon n)))

-- | A map for named type variables.
typeSumBoundNamed :: TypeSum n -> !(Map n (Kind n))

-- | A map for anonymous type variables.
typeSumBoundAnon :: TypeSum n -> !(Map Int (Kind n))

-- | Types that can't be placed in the other fields go here.
--   
--   INVARIANT: this list doesn't contain more <a>TSum</a>s.
typeSumSpill :: TypeSum n -> ![Type n]

-- | Hash value used to insert types into the <a>typeSumElems</a> array of
--   a <a>TypeSum</a>.
data TyConHash
TyConHash :: !Int -> TyConHash

-- | Wraps a variable or constructor that can be added the
--   <a>typeSumElems</a> array.
data TypeSumVarCon n
TypeSumVar :: !(Bound n) -> TypeSumVarCon n
TypeSumCon :: !(Bound n) -> !(Kind n) -> TypeSumVarCon n

-- | Kind, type and witness constructors.
--   
--   These are grouped to make it easy to determine the universe that they
--   belong to.
data TyCon n

-- | (level 3) Builtin Sort constructors.
TyConSort :: !SoCon -> TyCon n

-- | (level 2) Builtin Kind constructors.
TyConKind :: !KiCon -> TyCon n

-- | (level 1) Builtin Spec constructors for the types of witnesses.
TyConWitness :: !TwCon -> TyCon n

-- | (level 1) Builtin Spec constructors for types of other kinds.
TyConSpec :: !TcCon -> TyCon n

-- | User defined type constructor.
TyConBound :: !(Bound n) -> !(Kind n) -> TyCon n

-- | An existentially quantified name, with its kind. Used during type
--   checking, but not accepted in source programs.
TyConExists :: !Int -> !(Kind n) -> TyCon n

-- | Sort constructor.
data SoCon

-- | Sort of witness kinds.
SoConProp :: SoCon

-- | Sort of computation kinds.
SoConComp :: SoCon

-- | Kind constructor.
data KiCon

-- | Function kind constructor. This is only well formed when it is fully
--   applied.
KiConFun :: KiCon

-- | Kind of witnesses.
KiConWitness :: KiCon

-- | Kind of data values.
KiConData :: KiCon

-- | Kind of regions.
KiConRegion :: KiCon

-- | Kind of effects.
KiConEffect :: KiCon

-- | Kind of closures.
KiConClosure :: KiCon

-- | Witness type constructors.
data TwCon
TwConImpl :: TwCon

-- | Purity of some effect.
TwConPure :: TwCon

-- | Emptiness of some closure.
TwConEmpty :: TwCon

-- | Globalness of some region.
TwConGlobal :: TwCon

-- | Globalness of material regions in some type.
TwConDeepGlobal :: TwCon

-- | Constancy of some region.
TwConConst :: TwCon

-- | Constancy of material regions in some type
TwConDeepConst :: TwCon

-- | Mutability of some region.
TwConMutable :: TwCon

-- | Mutability of material regions in some type.
TwConDeepMutable :: TwCon

-- | Distinctness of some n regions
TwConDistinct :: Int -> TwCon

-- | Laziness of some region.
TwConLazy :: TwCon

-- | Laziness of the primary region in some type.
TwConHeadLazy :: TwCon

-- | Manifestness of some region (not lazy).
TwConManifest :: TwCon

-- | Non-interfering effects are disjoint. Used for rewrite rules.
TwConDisjoint :: TwCon

-- | Other constructors at the spec level.
data TcCon

-- | The unit data type constructor is baked in.
TcConUnit :: TcCon

-- | Pure function.
TcConFun :: TcCon

-- | Function with a latent effect and closure.
TcConFunEC :: TcCon

-- | A suspended computation.
TcConSusp :: TcCon

-- | Read of some region.
TcConRead :: TcCon

-- | Read the head region in a data type.
TcConHeadRead :: TcCon

-- | Read of all material regions in a data type.
TcConDeepRead :: TcCon

-- | Write of some region.
TcConWrite :: TcCon

-- | Write to all material regions in some data type.
TcConDeepWrite :: TcCon

-- | Allocation into some region.
TcConAlloc :: TcCon

-- | Allocation into all material regions in some data type.
TcConDeepAlloc :: TcCon

-- | Region is captured in a closure.
TcConUse :: TcCon

-- | All material regions in a data type are captured in a closure.
TcConDeepUse :: TcCon

-- | A variable binder.
data Binder n
RNone :: Binder n
RAnon :: Binder n
RName :: !n -> Binder n

-- | A variable binder with its type.
data Bind n

-- | A variable with no uses in the body doesn't need a name.
BNone :: !(Type n) -> Bind n

-- | Nameless variable on the deBruijn stack.
BAnon :: !(Type n) -> Bind n

-- | Named variable in the environment.
BName :: n -> !(Type n) -> Bind n

-- | A bound occurrence of a variable, with its type.
--   
--   If variable hasn't been annotated with its real type then this can be
--   <tt>tBot</tt> (an empty sum).
data Bound n

-- | Nameless variable that should be on the deBruijn stack.
UIx :: !Int -> Bound n

-- | Named variable that should be in the environment.
UName :: !n -> Bound n

-- | Named primitive that has its type attached to it. The types of
--   primitives must be closed.
UPrim :: !n -> !(Type n) -> Bound n


-- | Utilities for working with <a>TypeSum</a>s.
module DDC.Type.Sum

-- | Construct an empty type sum of the given kind.
empty :: Kind n -> TypeSum n

-- | Construct a type sum containing a single element.
singleton :: Ord n => Kind n -> Type n -> TypeSum n

-- | Add two type sums.
union :: Ord n => TypeSum n -> TypeSum n -> TypeSum n

-- | Union a list of <a>TypeSum</a>s together.
unions :: Ord n => Kind n -> [TypeSum n] -> TypeSum n

-- | Insert a new element into a sum.
insert :: Ord n => Type n -> TypeSum n -> TypeSum n

-- | Flatten out a sum, yielding a list of individual terms.
toList :: TypeSum n -> [Type n]

-- | Convert a list of types to a <a>TypeSum</a>
fromList :: Ord n => Kind n -> [Type n] -> TypeSum n

-- | Take the kind of a sum.
kindOfSum :: TypeSum n -> Kind n

-- | Check whether an element is a member of a sum.
--   
--   <ul>
--   <li>Returns True when the first argument is $0 or !0.</li>
--   <li>Returns False when the first argument is another sum.</li>
--   <li>May return False if the first argument is miskinded but still
--   alpha-equivalent to some component of the sum.</li>
--   </ul>
elem :: (Eq n, Ord n) => Type n -> TypeSum n -> Bool

-- | Delete an element from a sum.
delete :: Ord n => Type n -> TypeSum n -> TypeSum n

-- | Delete all members of the second sum from the first one.
difference :: Ord n => TypeSum n -> TypeSum n -> TypeSum n

-- | Yield the <a>TyConHash</a> of a <a>TyCon</a>, or <a>Nothing</a> if
--   there isn't one.
hashTyCon :: TyCon n -> Maybe TyConHash

-- | The range of hashes that can be produced by <a>hashTyCon</a>.
hashTyConRange :: (TyConHash, TyConHash)

-- | Yield the <a>TyCon</a> corresponding to a <a>TyConHash</a>, or
--   <a>error</a> if there isn't one.
unhashTyCon :: TyConHash -> TyCon n
instance Eq n => Eq (Bind n)
instance Eq n => Eq (Bound n)
instance Eq n => Eq (TyCon n)
instance Ord n => Ord (TypeSumVarCon n)
instance Eq n => Eq (TypeSumVarCon n)
instance Ord n => Ord (Bound n)
instance Eq n => Eq (TypeSum n)
instance Eq n => Eq (Type n)

module DDC.Type.Compounds

-- | Take the variable name of a bind. If this is an anonymous binder then
--   there won't be a name.
takeNameOfBind :: Bind n -> Maybe n

-- | Take the type of a bind.
typeOfBind :: Bind n -> Type n

-- | Replace the type of a bind with a new one.
replaceTypeOfBind :: Type n -> Bind n -> Bind n

-- | Take the binder of a bind.
binderOfBind :: Bind n -> Binder n

-- | Make a bind from a binder and its type.
makeBindFromBinder :: Binder n -> Type n -> Bind n

-- | Make lists of binds that have the same type.
partitionBindsByType :: Eq n => [Bind n] -> [([Binder n], Type n)]

-- | Take the name of bound variable. If this is a deBruijn index then
--   there won't be a name.
takeNameOfBound :: Bound n -> Maybe n

-- | Get the attached type of a <a>Bound</a>, if any.
takeTypeOfBound :: Bound n -> Maybe (Type n)

-- | Check whether a bound maches a bind. <a>UName</a> and <a>BName</a>
--   match if they have the same name. <tt>UIx 0 _</tt> and <tt>BAnon
--   _</tt> always match. Yields <a>False</a> for other combinations of
--   bounds and binds.
boundMatchesBind :: Eq n => Bound n -> Bind n -> Bool

-- | Check whether a named bound matches a named bind. Yields <a>False</a>
--   if they are not named or have different names.
namedBoundMatchesBind :: Eq n => Bound n -> Bind n -> Bool

-- | Convert a <a>Bind</a> to a <a>Bound</a>, ready for substitution.
--   
--   Returns <a>UName</a> for <a>BName</a>, <tt>UIx 0</tt> for <a>BAnon</a>
--   and <a>Nothing</a> for <a>BNone</a>, because there's nothing to
--   substitute.
takeSubstBoundOfBind :: Bind n -> Maybe (Bound n)

-- | Convert some <a>Bind</a>s to <tt>Bounds</tt>
takeSubstBoundsOfBinds :: [Bind n] -> [Bound n]

-- | If this <a>Bound</a> is a <a>UPrim</a> then replace it's embedded type
--   with a new one, otherwise return it unharmed.
replaceTypeOfBound :: Type n -> Bound n -> Bound n

-- | Construct a kind function.
kFun :: Kind n -> Kind n -> Kind n

-- | Construct some kind functions.
kFuns :: [Kind n] -> Kind n -> Kind n

-- | Destruct a kind function
takeKFun :: Kind n -> Maybe (Kind n, Kind n)

-- | Destruct a chain of kind functions into the arguments
takeKFuns :: Kind n -> ([Kind n], Kind n)

-- | Like <a>takeKFuns</a>, but return argument and return kinds in the
--   same list.
takeKFuns' :: Kind n -> [Kind n]

-- | Take the result kind of a kind function, or return the same kind
--   unharmed if it's not a kind function.
takeResultKind :: Kind n -> Kind n

-- | Build an anonymous type abstraction, with a single parameter.
tForall :: Kind n -> (Type n -> Type n) -> Type n

-- | Build an anonymous type abstraction, with a single parameter. Starting
--   the next index from the given value.
tForall' :: Int -> Kind n -> (Type n -> Type n) -> Type n

-- | Build an anonymous type abstraction, with several parameters. Starting
--   the next index from the given value.
tForalls :: [Kind n] -> ([Type n] -> Type n) -> Type n

-- | Build an anonymous type abstraction, with several parameters. Starting
--   the next index from the given value.
tForalls' :: Int -> [Kind n] -> ([Type n] -> Type n) -> Type n

-- | Split nested foralls from the front of a type, or <a>Nothing</a> if
--   there was no outer forall.
takeTForalls :: Type n -> Maybe ([Bind n], Type n)

-- | Erase all <a>TForall</a> quantifiers from a type.
eraseTForalls :: Ord n => Type n -> Type n

-- | Construct an empty type sum.
tBot :: Kind n -> Type n
tSum :: Ord n => Kind n -> [Type n] -> Type n

-- | Construct a type application.
tApp :: Type n -> Type n -> Type n

-- | Construct a type application.
($:) :: Type n -> Type n -> Type n

-- | Construct a sequence of type applications.
tApps :: Type n -> [Type n] -> Type n

-- | Flatten a sequence ot type applications into the function part and
--   arguments, if any.
takeTApps :: Type n -> [Type n]

-- | Flatten a sequence of type applications, returning the type
--   constructor and arguments, if there is one.
takeTyConApps :: Type n -> Maybe (TyCon n, [Type n])

-- | Flatten a sequence of type applications, returning the type
--   constructor and arguments, if there is one. Only accept primitive type
--   constructors.
takePrimTyConApps :: Type n -> Maybe (n, [Type n])

-- | Flatten a sequence of type applications, returning the type
--   constructor and arguments, if there is one. Only accept data type
--   constructors.
takeDataTyConApps :: Type n -> Maybe (TyCon n, [Type n])

-- | Take the prime region variable of a data type. This corresponds to the
--   region the outermost constructor is allocated into.
takePrimeRegion :: Type n -> Maybe (Type n)

-- | Construct a pure function type.
tFun :: Type n -> Type n -> Type n

-- | Construct a pure and empty function from a list containing the
--   parameter and return type. Yields <a>Nothing</a> if the list is empty.
tFunOfList :: [Type n] -> Maybe (Type n)

-- | Construct a pure and empty value type function.
tFunPE :: Type n -> Type n -> Type n

-- | Construct a pure and empty function from a list containing the
--   parameter and return type. Yields <a>Nothing</a> if the list is empty.
tFunOfListPE :: [Type n] -> Maybe (Type n)

-- | Construct a value type function, with the provided effect and closure.
tFunEC :: Type n -> Effect n -> Closure n -> Type n -> Type n

-- | Yield the argument and result type of a function type.
--   
--   Works for both <a>TcConFun</a> and <a>TcConFunEC</a>.
takeTFun :: Type n -> Maybe (Type n, Type n)

-- | Yield the argument and result type of a function type.
takeTFunEC :: Type n -> Maybe (Type n, Effect n, Closure n, Type n)

-- | Destruct the type of a function, returning just the argument and
--   result types.
--   
--   Works for both <a>TcConFun</a> and <a>TcConFunEC</a>.
takeTFunArgResult :: Type n -> ([Type n], Type n)

-- | Destruct the type of a function, returning the witness argument, value
--   argument and result types. The function type must have the witness
--   implications before the value arguments, eg <tt>T1 =&gt; T2 -&gt; T3
--   -&gt; T4 -&gt; T5</tt>.
--   
--   Works for both <a>TcConFun</a> and <a>TcConFunEC</a>.
takeTFunWitArgResult :: Type n -> ([Type n], [Type n], Type n)

-- | Destruct the type of a possibly polymorphic function returning all
--   kinds of quantifiers, witness arguments, and value arguments in the
--   order they appear, along with the type of the result.
takeTFunAllArgResult :: Type n -> ([Type n], Type n)

-- | Determine the arity of an expression by looking at its type. Count all
--   the function arrows, and foralls.
--   
--   This assumes the type is in prenex form, meaning that all the
--   quantifiers are at the front.
arityOfType :: Type n -> Int
tSusp :: Effect n -> Type n -> Type n

-- | Construct a witness implication type.
tImpl :: Type n -> Type n -> Type n
tUnit :: Type n

-- | Construct a deBruijn index.
tIx :: Kind n -> Int -> Type n

-- | Take an existential variable from a type.
takeTExists :: Type n -> Maybe Int
sComp :: Type n
sProp :: Type n
kData :: Type n
kRegion :: Type n
kEffect :: Type n
kClosure :: Type n
kWitness :: Type n
tRead :: Type n -> Type n
tDeepRead :: Type n -> Type n
tHeadRead :: Type n -> Type n
tWrite :: Type n -> Type n
tDeepWrite :: Type n -> Type n
tAlloc :: Type n -> Type n
tDeepAlloc :: Type n -> Type n
tUse :: Type n -> Type n
tDeepUse :: Type n -> Type n
tPure :: Type n -> Type n
tEmpty :: Type n -> Type n
tGlobal :: Type n -> Type n
tDeepGlobal :: Type n -> Type n
tConst :: Type n -> Type n
tDeepConst :: Type n -> Type n
tMutable :: Type n -> Type n
tDeepMutable :: Type n -> Type n
tDistinct :: Int -> [Type n] -> Type n
tLazy :: Type n -> Type n
tHeadLazy :: Type n -> Type n
tManifest :: Type n -> Type n

-- | Build a nullary type constructor of the given kind.
tConData0 :: n -> Kind n -> Type n

-- | Build a type constructor application of one argumnet.
tConData1 :: n -> Kind n -> Type n -> Type n


-- | Core language AST with a separate node to hold annotations.
--   
--   This version of the AST is used when generating code where most or all
--   of the annotations would be empty. General purpose transformations
--   should deal with the fully annotated version of the AST instead.
module DDC.Core.Exp.Simple

-- | Well-typed expressions have types of kind <tt>Data</tt>.
data Exp a n

-- | Annotation.
XAnnot :: a -> (Exp a n) -> Exp a n

-- | Value variable or primitive operation.
XVar :: !(Bound n) -> Exp a n

-- | Data constructor or literal.
XCon :: !(DaCon n) -> Exp a n

-- | Type abstraction (level-1).
XLAM :: !(Bind n) -> !(Exp a n) -> Exp a n

-- | Value and Witness abstraction (level-0).
XLam :: !(Bind n) -> !(Exp a n) -> Exp a n

-- | Application.
XApp :: !(Exp a n) -> !(Exp a n) -> Exp a n

-- | Possibly recursive bindings.
XLet :: !(Lets a n) -> !(Exp a n) -> Exp a n

-- | Case branching.
XCase :: !(Exp a n) -> ![Alt a n] -> Exp a n

-- | Type cast.
XCast :: !(Cast a n) -> !(Exp a n) -> Exp a n

-- | Type can appear as the argument of an application.
XType :: !(Type n) -> Exp a n

-- | Witness can appear as the argument of an application.
XWitness :: !(Witness a n) -> Exp a n

-- | Type casts.
data Cast a n

-- | Weaken the effect of an expression. The given effect is added to the
--   effect of the body.
CastWeakenEffect :: !(Effect n) -> Cast a n

-- | Weaken the closure of an expression. The closures of these expressions
--   are added to the closure of the body.
CastWeakenClosure :: ![Exp a n] -> Cast a n

-- | Purify the effect (action) of an expression.
CastPurify :: !(Witness a n) -> Cast a n

-- | Forget about the closure (sharing) of an expression.
CastForget :: !(Witness a n) -> Cast a n

-- | Box up a computation, capturing its effects in the S computation type.
CastBox :: Cast a n

-- | Run a computation, releasing its effects into the environment.
CastRun :: Cast a n

-- | Possibly recursive bindings.
data Lets a n

-- | Non-recursive expression binding.
LLet :: !(Bind n) -> !(Exp a n) -> Lets a n

-- | Recursive binding of lambda abstractions.
LRec :: ![(Bind n, Exp a n)] -> Lets a n

-- | Bind a local region variable, and witnesses to its properties.
LPrivate :: ![Bind n] -> !(Maybe (Type n)) -> ![Bind n] -> Lets a n

-- | Holds a region handle during evaluation.
LWithRegion :: !(Bound n) -> Lets a n

-- | Case alternatives.
data Alt a n
AAlt :: !(Pat n) -> !(Exp a n) -> Alt a n

-- | Pattern matching.
data Pat n

-- | The default pattern always succeeds.
PDefault :: Pat n

-- | Match a data constructor and bind its arguments.
PData :: !(DaCon n) -> ![Bind n] -> Pat n

-- | When a witness exists in the program it guarantees that a certain
--   property of the program is true.
data Witness a n
WAnnot :: a -> (Witness a n) -> Witness a n

-- | Witness variable.
WVar :: !(Bound n) -> Witness a n

-- | Witness constructor.
WCon :: !(WiCon n) -> Witness a n

-- | Witness application.
WApp :: !(Witness a n) -> !(Witness a n) -> Witness a n

-- | Joining of witnesses.
WJoin :: !(Witness a n) -> !(Witness a n) -> Witness a n

-- | Type can appear as the argument of an application.
WType :: !(Type n) -> Witness a n

-- | Data constructors.
data DaCon n

-- | Baked in unit data constructor.
DaConUnit :: DaCon n

-- | Primitive data constructor used for literals and baked-in
--   constructors.
--   
--   The type of the constructor needs to be attached to handle the case
--   where there are too many constructors in the data type to list, like
--   for Int literals. In this case we determine what data type it belongs
--   to from the attached type of the data constructor.
DaConPrim :: !n -> !(Type n) -> DaCon n

-- | Name of the data constructor.
--   
--   Name of the data constructor.
daConName :: DaCon n -> !n

-- | Type of the data constructor.
daConType :: DaCon n -> !(Type n)

-- | Data constructor that has a data type declaration.
DaConBound :: !n -> DaCon n

-- | Name of the data constructor.
--   
--   Name of the data constructor.
daConName :: DaCon n -> !n

-- | Witness constructors.
data WiCon n

-- | Witness constructors baked into the language.
WiConBuiltin :: !WbCon -> WiCon n

-- | Witness constructors defined in the environment. In the interpreter we
--   use this to hold runtime capabilities. The attached type must be
--   closed.
WiConBound :: !(Bound n) -> !(Type n) -> WiCon n

-- | Built-in witness constructors.
--   
--   These are used to convert a runtime capability into a witness that the
--   corresponding property is true.
data WbCon

-- | (axiom) The pure effect is pure.
--   
--   <pre>
--   pure     :: Pure !0
--   </pre>
WbConPure :: WbCon

-- | (axiom) The empty closure is empty.
--   
--   <pre>
--   empty    :: Empty $0
--   </pre>
WbConEmpty :: WbCon

-- | Convert a capability guaranteeing that a region is in the global heap,
--   into a witness that a closure using this region is empty. This lets us
--   rely on the garbage collector to reclaim objects in the region. It is
--   needed when we suspend the evaluation of expressions that have a
--   region in their closure, because the type of the returned thunk may
--   not reveal that it references objects in that region.
--   
--   <pre>
--   use      :: [r : %]. Global r =&gt; Empty (Use r)
--   </pre>
WbConUse :: WbCon

-- | Convert a capability guaranteeing the constancy of a region, into a
--   witness that a read from that region is pure. This lets us suspend
--   applications that read constant objects, because it doesn't matter if
--   the read is delayed, we'll always get the same result.
--   
--   <pre>
--   read     :: [r : %]. Const r  =&gt; Pure (Read r)
--   </pre>
WbConRead :: WbCon

-- | Convert a capability guaranteeing the constancy of a region, into a
--   witness that allocation into that region is pure. This lets us
--   increase the sharing of constant objects, because we can't tell
--   constant objects of the same value apart.
--   
--   <pre>
--   alloc    :: [r : %]. Const r  =&gt; Pure (Alloc r)
--   </pre>
WbConAlloc :: WbCon
instance (Show a, Show n) => Show (Witness a n)
instance (Eq a, Eq n) => Eq (Witness a n)
instance (Show a, Show n) => Show (Cast a n)
instance (Eq a, Eq n) => Eq (Cast a n)
instance (Show a, Show n) => Show (Exp a n)
instance (Eq a, Eq n) => Eq (Exp a n)
instance (Show a, Show n) => Show (Alt a n)
instance (Eq a, Eq n) => Eq (Alt a n)
instance (Show a, Show n) => Show (Lets a n)
instance (Eq a, Eq n) => Eq (Lets a n)
instance (NFData a, NFData n) => NFData (Witness a n)
instance (NFData a, NFData n) => NFData (Alt a n)
instance (NFData a, NFData n) => NFData (Lets a n)
instance (NFData a, NFData n) => NFData (Cast a n)
instance (NFData a, NFData n) => NFData (Exp a n)


-- | Utilities for constructing and destructing compound expressions.
--   
--   For the Simple version of the AST.
module DDC.Core.Compounds.Simple

-- | Make some nested type lambdas.
xLAMs :: [Bind n] -> Exp a n -> Exp a n

-- | Make some nested value or witness lambdas.
xLams :: [Bind n] -> Exp a n -> Exp a n

-- | Make some nested lambda abstractions, using a flag to indicate whether
--   the lambda is a level-1 (True), or level-0 (False) binder.
makeXLamFlags :: [(Bool, Bind n)] -> Exp a n -> Exp a n

-- | Split type lambdas from the front of an expression, or <a>Nothing</a>
--   if there aren't any.
takeXLAMs :: Exp a n -> Maybe ([Bind n], Exp a n)

-- | Split nested value or witness lambdas from the front of an expression,
--   or <a>Nothing</a> if there aren't any.
takeXLams :: Exp a n -> Maybe ([Bind n], Exp a n)

-- | Split nested lambdas from the front of an expression, with a flag
--   indicating whether the lambda was a level-1 (True), or level-0 (False)
--   binder.
takeXLamFlags :: Exp a n -> Maybe ([(Bool, Bind n)], Exp a n)

-- | Build sequence of value applications.
xApps :: Exp a n -> [Exp a n] -> Exp a n

-- | Flatten an application into the function part and its arguments.
--   
--   Returns <a>Nothing</a> if there is no outer application.
takeXApps :: Exp a n -> Maybe (Exp a n, [Exp a n])

-- | Flatten an application into the function part and its arguments.
--   
--   This is like <a>takeXApps</a> above, except we know there is at least
--   one argument.
takeXApps1 :: Exp a n -> Exp a n -> (Exp a n, [Exp a n])

-- | Flatten an application into the function parts and arguments, if any.
takeXAppsAsList :: Exp a n -> [Exp a n]

-- | Flatten an application of a data constructor into the constructor and
--   its arguments.
--   
--   Returns <a>Nothing</a> if the expression isn't a constructor
--   application.
takeXConApps :: Exp a n -> Maybe (DaCon n, [Exp a n])

-- | Flatten an application of a primop into the variable and its
--   arguments.
--   
--   Returns <a>Nothing</a> if the expression isn't a primop application.
takeXPrimApps :: Exp a n -> Maybe (n, [Exp a n])

-- | Wrap some let-bindings around an expression.
xLets :: [Lets a n] -> Exp a n -> Exp a n

-- | Split let-bindings from the front of an expression, if any.
splitXLets :: Exp a n -> ([Lets a n], Exp a n)

-- | Take the binds of a <a>Lets</a>.
--   
--   The level-1 and level-0 binders are returned separately.
bindsOfLets :: Lets a n -> ([Bind n], [Bind n])

-- | Like <a>bindsOfLets</a> but only take the spec (level-1) binders.
specBindsOfLets :: Lets a n -> [Bind n]

-- | Like <a>bindsOfLets</a> but only take the value and witness (level-0)
--   binders.
valwitBindsOfLets :: Lets a n -> [Bind n]

-- | Take the binds of a <a>Pat</a>.
bindsOfPat :: Pat n -> [Bind n]

-- | Take the constructor name of an alternative, if there is one.
takeCtorNameOfAlt :: Alt a n -> Maybe n

-- | Construct a witness application
wApp :: Witness a n -> Witness a n -> Witness a n

-- | Construct a sequence of witness applications
wApps :: Witness a n -> [Witness a n] -> Witness a n

-- | Take the witness from an <a>XWitness</a> argument, if any.
takeXWitness :: Exp a n -> Maybe (Witness a n)

-- | Flatten an application into the function parts and arguments, if any.
takeWAppsAsList :: Witness a n -> [Witness a n]

-- | Flatten an application of a witness into the witness constructor name
--   and its arguments.
--   
--   Returns nothing if there is no witness constructor in head position.
takePrimWiConApps :: Witness a n -> Maybe (n, [Witness a n])

-- | Take the type from an <a>XType</a> argument, if any.
takeXType :: Exp a n -> Maybe (Type n)

-- | Construct a value of unit type.
xUnit :: Exp a n

-- | The unit data constructor.
dcUnit :: DaCon n

-- | Take the name of data constructor, if there is one.
takeNameOfDaCon :: DaCon n -> Maybe n

-- | Take the type annotation of a data constructor, if we know it locally.
takeTypeOfDaCon :: DaCon n -> Maybe (Type n)


-- | Core language AST that includes an annotation on every node of an
--   expression.
--   
--   This is the default representation for Disciple Core, and should be
--   preferred over the <tt>Simple</tt> version of the AST in most cases.
--   
--   <ul>
--   <li>Local transformations on this AST should propagate the annotations
--   in a way that would make sense if they were source position
--   identifiers that tracked the provenance of each code snippet. If the
--   specific annotations attached to the AST would not make sense after
--   such a transformation, then the client should erase them to
--   <tt>()</tt> beforehand using the <tt>reannotate</tt> transform.</li>
--   <li>Global transformations that drastically change the provenance of
--   code snippets should accept an AST with an arbitrary annotation type,
--   but produce one with the annotations set to <tt>()</tt>.</li>
--   </ul>
module DDC.Core.Exp.Annot

-- | Well-typed expressions have types of kind <tt>Data</tt>.
data Exp a n

-- | Value variable or primitive operation.
XVar :: !a -> !(Bound n) -> Exp a n

-- | Data constructor or literal.
XCon :: !a -> !(DaCon n) -> Exp a n

-- | Type abstraction (level-1).
XLAM :: !a -> !(Bind n) -> !(Exp a n) -> Exp a n

-- | Value and Witness abstraction (level-0).
XLam :: !a -> !(Bind n) -> !(Exp a n) -> Exp a n

-- | Application.
XApp :: !a -> !(Exp a n) -> !(Exp a n) -> Exp a n

-- | Possibly recursive bindings.
XLet :: !a -> !(Lets a n) -> !(Exp a n) -> Exp a n

-- | Case branching.
XCase :: !a -> !(Exp a n) -> ![Alt a n] -> Exp a n

-- | Type cast.
XCast :: !a -> !(Cast a n) -> !(Exp a n) -> Exp a n

-- | Type can appear as the argument of an application.
XType :: !a -> !(Type n) -> Exp a n

-- | Witness can appear as the argument of an application.
XWitness :: !a -> !(Witness a n) -> Exp a n

-- | Possibly recursive bindings.
data Lets a n

-- | Non-recursive expression binding.
LLet :: !(Bind n) -> !(Exp a n) -> Lets a n

-- | Recursive binding of lambda abstractions.
LRec :: ![(Bind n, Exp a n)] -> Lets a n

-- | Bind a private region variable, and witnesses to its properties.
LPrivate :: ![Bind n] -> !(Maybe (Type n)) -> ![Bind n] -> Lets a n

-- | Holds a region handle during evaluation.
LWithRegion :: !(Bound n) -> Lets a n

-- | Case alternatives.
data Alt a n
AAlt :: !(Pat n) -> !(Exp a n) -> Alt a n

-- | Pattern matching.
data Pat n

-- | The default pattern always succeeds.
PDefault :: Pat n

-- | Match a data constructor and bind its arguments.
PData :: !(DaCon n) -> ![Bind n] -> Pat n

-- | Type casts.
data Cast a n

-- | Weaken the effect of an expression. The given effect is added to the
--   effect of the body.
CastWeakenEffect :: !(Effect n) -> Cast a n

-- | Weaken the closure of an expression. The closures of these expressions
--   are added to the closure of the body.
CastWeakenClosure :: ![Exp a n] -> Cast a n

-- | Purify the effect (action) of an expression.
CastPurify :: !(Witness a n) -> Cast a n

-- | Forget about the closure (sharing) of an expression.
CastForget :: !(Witness a n) -> Cast a n

-- | Box up a computation, capturing its effects in the S computation type.
CastBox :: Cast a n

-- | Run a computation, releasing its effects into the environment.
CastRun :: Cast a n

-- | When a witness exists in the program it guarantees that a certain
--   property of the program is true.
data Witness a n

-- | Witness variable.
WVar :: a -> !(Bound n) -> Witness a n

-- | Witness constructor.
WCon :: a -> !(WiCon n) -> Witness a n

-- | Witness application.
WApp :: a -> !(Witness a n) -> !(Witness a n) -> Witness a n

-- | Joining of witnesses.
WJoin :: a -> !(Witness a n) -> !(Witness a n) -> Witness a n

-- | Type can appear as the argument of an application.
WType :: a -> !(Type n) -> Witness a n

-- | Data constructors.
data DaCon n

-- | Baked in unit data constructor.
DaConUnit :: DaCon n

-- | Primitive data constructor used for literals and baked-in
--   constructors.
--   
--   The type of the constructor needs to be attached to handle the case
--   where there are too many constructors in the data type to list, like
--   for Int literals. In this case we determine what data type it belongs
--   to from the attached type of the data constructor.
DaConPrim :: !n -> !(Type n) -> DaCon n

-- | Name of the data constructor.
--   
--   Name of the data constructor.
daConName :: DaCon n -> !n

-- | Type of the data constructor.
daConType :: DaCon n -> !(Type n)

-- | Data constructor that has a data type declaration.
DaConBound :: !n -> DaCon n

-- | Name of the data constructor.
--   
--   Name of the data constructor.
daConName :: DaCon n -> !n

-- | Witness constructors.
data WiCon n

-- | Witness constructors baked into the language.
WiConBuiltin :: !WbCon -> WiCon n

-- | Witness constructors defined in the environment. In the interpreter we
--   use this to hold runtime capabilities. The attached type must be
--   closed.
WiConBound :: !(Bound n) -> !(Type n) -> WiCon n

-- | Built-in witness constructors.
--   
--   These are used to convert a runtime capability into a witness that the
--   corresponding property is true.
data WbCon

-- | (axiom) The pure effect is pure.
--   
--   <pre>
--   pure     :: Pure !0
--   </pre>
WbConPure :: WbCon

-- | (axiom) The empty closure is empty.
--   
--   <pre>
--   empty    :: Empty $0
--   </pre>
WbConEmpty :: WbCon

-- | Convert a capability guaranteeing that a region is in the global heap,
--   into a witness that a closure using this region is empty. This lets us
--   rely on the garbage collector to reclaim objects in the region. It is
--   needed when we suspend the evaluation of expressions that have a
--   region in their closure, because the type of the returned thunk may
--   not reveal that it references objects in that region.
--   
--   <pre>
--   use      :: [r : %]. Global r =&gt; Empty (Use r)
--   </pre>
WbConUse :: WbCon

-- | Convert a capability guaranteeing the constancy of a region, into a
--   witness that a read from that region is pure. This lets us suspend
--   applications that read constant objects, because it doesn't matter if
--   the read is delayed, we'll always get the same result.
--   
--   <pre>
--   read     :: [r : %]. Const r  =&gt; Pure (Read r)
--   </pre>
WbConRead :: WbCon

-- | Convert a capability guaranteeing the constancy of a region, into a
--   witness that allocation into that region is pure. This lets us
--   increase the sharing of constant objects, because we can't tell
--   constant objects of the same value apart.
--   
--   <pre>
--   alloc    :: [r : %]. Const r  =&gt; Pure (Alloc r)
--   </pre>
WbConAlloc :: WbCon
instance (Show a, Show n) => Show (Witness a n)
instance (Eq a, Eq n) => Eq (Witness a n)
instance (Show a, Show n) => Show (Exp a n)
instance (Eq a, Eq n) => Eq (Exp a n)
instance (Show a, Show n) => Show (Cast a n)
instance (Eq a, Eq n) => Eq (Cast a n)
instance (Show a, Show n) => Show (Alt a n)
instance (Eq a, Eq n) => Eq (Alt a n)
instance (Show a, Show n) => Show (Lets a n)
instance (Eq a, Eq n) => Eq (Lets a n)
instance (NFData a, NFData n) => NFData (Witness a n)
instance (NFData a, NFData n) => NFData (Alt a n)
instance (NFData a, NFData n) => NFData (Lets a n)
instance (NFData a, NFData n) => NFData (Cast a n)
instance (NFData a, NFData n) => NFData (Exp a n)


-- | Abstract syntax for the Disciple core language.
module DDC.Core.Exp


-- | Utilities for constructing and destructing compound expressions.
--   
--   For the annotated version of the AST.
module DDC.Core.Compounds.Annot

-- | Take the outermost annotation from an expression.
annotOfExp :: Exp a n -> a

-- | Make some nested type lambdas.
xLAMs :: a -> [Bind n] -> Exp a n -> Exp a n

-- | Make some nested value or witness lambdas.
xLams :: a -> [Bind n] -> Exp a n -> Exp a n

-- | Make some nested lambda abstractions, using a flag to indicate whether
--   the lambda is a level-1 (True), or level-0 (False) binder.
makeXLamFlags :: a -> [(Bool, Bind n)] -> Exp a n -> Exp a n

-- | Split type lambdas from the front of an expression, or <a>Nothing</a>
--   if there aren't any.
takeXLAMs :: Exp a n -> Maybe ([Bind n], Exp a n)

-- | Split nested value or witness lambdas from the front of an expression,
--   or <a>Nothing</a> if there aren't any.
takeXLams :: Exp a n -> Maybe ([Bind n], Exp a n)

-- | Split nested lambdas from the front of an expression, with a flag
--   indicating whether the lambda was a level-1 (True), or level-0 (False)
--   binder.
takeXLamFlags :: Exp a n -> Maybe ([(Bool, Bind n)], Exp a n)

-- | Build sequence of value applications.
xApps :: a -> Exp a n -> [Exp a n] -> Exp a n

-- | Build sequence of applications. Similar to <a>xApps</a> but also takes
--   list of annotations for the <a>XApp</a> constructors.
makeXAppsWithAnnots :: Exp a n -> [(Exp a n, a)] -> Exp a n

-- | Flatten an application into the function part and its arguments.
--   
--   Returns <a>Nothing</a> if there is no outer application.
takeXApps :: Exp a n -> Maybe (Exp a n, [Exp a n])

-- | Flatten an application into the function part and its arguments.
--   
--   This is like <a>takeXApps</a> above, except we know there is at least
--   one argument.
takeXApps1 :: Exp a n -> Exp a n -> (Exp a n, [Exp a n])

-- | Flatten an application into the function parts and arguments, if any.
takeXAppsAsList :: Exp a n -> [Exp a n]

-- | Destruct sequence of applications. Similar to <a>takeXAppsAsList</a>
--   but also keeps annotations for later.
takeXAppsWithAnnots :: Exp a n -> (Exp a n, [(Exp a n, a)])

-- | Flatten an application of a data constructor into the constructor and
--   its arguments.
--   
--   Returns <a>Nothing</a> if the expression isn't a constructor
--   application.
takeXConApps :: Exp a n -> Maybe (DaCon n, [Exp a n])

-- | Flatten an application of a primop into the variable and its
--   arguments.
--   
--   Returns <a>Nothing</a> if the expression isn't a primop application.
takeXPrimApps :: Exp a n -> Maybe (n, [Exp a n])

-- | Wrap some let-bindings around an expression.
xLets :: a -> [Lets a n] -> Exp a n -> Exp a n

-- | Wrap some let-bindings around an expression, with individual
--   annotations.
xLetsAnnot :: [(Lets a n, a)] -> Exp a n -> Exp a n

-- | Split let-bindings from the front of an expression, if any.
splitXLets :: Exp a n -> ([Lets a n], Exp a n)

-- | Take the binds of a <a>Lets</a>.
--   
--   The level-1 and level-0 binders are returned separately.
bindsOfLets :: Lets a n -> ([Bind n], [Bind n])

-- | Like <a>bindsOfLets</a> but only take the spec (level-1) binders.
specBindsOfLets :: Lets a n -> [Bind n]

-- | Like <a>bindsOfLets</a> but only take the value and witness (level-0)
--   binders.
valwitBindsOfLets :: Lets a n -> [Bind n]

-- | Take the binds of a <a>Pat</a>.
bindsOfPat :: Pat n -> [Bind n]

-- | Take the pattern of an alternative.
patOfAlt :: Alt a n -> Pat n

-- | Take the constructor name of an alternative, if there is one.
takeCtorNameOfAlt :: Alt a n -> Maybe n

-- | Construct a witness application
wApp :: a -> Witness a n -> Witness a n -> Witness a n

-- | Construct a sequence of witness applications
wApps :: a -> Witness a n -> [Witness a n] -> Witness a n

-- | Take the annotation from a witness.
annotOfWitness :: Witness a n -> a

-- | Take the witness from an <a>XWitness</a> argument, if any.
takeXWitness :: Exp a n -> Maybe (Witness a n)

-- | Flatten an application into the function parts and arguments, if any.
takeWAppsAsList :: Witness a n -> [Witness a n]

-- | Flatten an application of a witness into the witness constructor name
--   and its arguments.
--   
--   Returns nothing if there is no witness constructor in head position.
takePrimWiConApps :: Witness a n -> Maybe (n, [Witness a n])

-- | Take the type from an <a>XType</a> argument, if any.
takeXType :: Exp a n -> Maybe (Type n)

-- | Construct a value of unit type.
xUnit :: a -> Exp a n

-- | The unit data constructor.
dcUnit :: DaCon n

-- | Take the name of data constructor, if there is one.
takeNameOfDaCon :: DaCon n -> Maybe n

-- | Take the type annotation of a data constructor, if we know it locally.
takeTypeOfDaCon :: DaCon n -> Maybe (Type n)


-- | Utilities for constructing and destructing compound expressions.
module DDC.Core.Compounds


-- | Lifting and lowering level-0 deBruijn indices in core things.
--   
--   Level-0 indices are used for both value and witness variables.
module DDC.Core.Transform.LiftX

-- | Wrapper for <a>liftAtDepthX</a> that starts at depth 0.
liftX :: MapBoundX c n => Int -> c n -> c n

-- | Lift debruijn indices less than or equal to the given depth.
liftAtDepthX :: MapBoundX c n => Int -> Int -> c n -> c n

-- | Wrapper for <a>lowerAtDepthX</a> that starts at depth 0.
lowerX :: MapBoundX c n => Int -> c n -> c n

-- | Lower debruijn indices less than or equal to the given depth.
lowerAtDepthX :: MapBoundX c n => Int -> Int -> c n -> c n
class MapBoundX (c :: * -> *) n
mapBoundAtDepthX :: MapBoundX c n => (Int -> Bound n -> Bound n) -> Int -> c n -> c n
instance MapBoundX (Alt a) n
instance MapBoundX (Cast a) n
instance MapBoundX (Witness a) n
instance MapBoundX (Exp a) n
instance MapBoundX Bound n

module DDC.Core.Transform.MapT

-- | Apply a function to all possibly open types in a thing. Not the types
--   of primitives because they're guaranteed to be closed.
mapT :: MapT c => (Type n -> Type n) -> c n -> c n
instance MapT (Cast a)
instance MapT (Witness a)
instance MapT Pat
instance MapT (Alt a)
instance MapT (Lets a)
instance MapT (Exp a)
instance MapT Bound
instance MapT Bind

module DDC.Core.Transform.Annotate

-- | Convert the <tt>Simple</tt> version of the AST to the <tt>Annot</tt>
--   version, using a the provided default annotation value.
class Annotate (c1 :: * -> * -> *) (c2 :: * -> * -> *) | c1 -> c2
annotate :: Annotate c1 c2 => a -> c1 a n -> c2 a n
instance Annotate Witness Witness
instance Annotate Alt Alt
instance Annotate Lets Lets
instance Annotate Cast Cast
instance Annotate Exp Exp

module DDC.Core.Transform.Deannotate

-- | Convert the <tt>Annot</tt> version of the AST to the <tt>Simple</tt>
--   version, using the provided function to decide when to keep the
--   annotation.
class Deannotate (c1 :: * -> * -> *) (c2 :: * -> * -> *) | c1 -> c2
deannotate :: Deannotate c1 c2 => (a -> Maybe a) -> c1 a n -> c2 a n
instance Deannotate Cast Cast
instance Deannotate Witness Witness
instance Deannotate Alt Alt
instance Deannotate Lets Lets
instance Deannotate Exp Exp


-- | Lifting of deBruijn indices in a type.
module DDC.Type.Transform.LiftT

-- | Wrapper for <tt>liftAtDepthX</tt> that starts at depth 0.
liftT :: MapBoundT c n => Int -> c n -> c n

-- | Lift debruijn indices less than or equal to the given depth.
liftAtDepthT :: MapBoundT c n => Int -> Int -> c n -> c n

-- | Wrapper for <tt>lowerAtDepthX</tt> that starts at depth 0.
lowerT :: MapBoundT c n => Int -> c n -> c n

-- | Lower debruijn indices less than or equal to the given depth.
lowerAtDepthT :: MapBoundT c n => Int -> Int -> c n -> c n
class MapBoundT (c :: * -> *) n
mapBoundAtDepthT :: MapBoundT c n => (Int -> Bound n -> Bound n) -> Int -> c n -> c n
instance Ord n => MapBoundT TypeSum n
instance Ord n => MapBoundT Type n
instance MapBoundT Bound n
instance Ord n => MapBoundT Bind n

module DDC.Core.Transform.LiftT

-- | Wrapper for <tt>liftAtDepthX</tt> that starts at depth 0.
liftT :: MapBoundT c n => Int -> c n -> c n

-- | Lift debruijn indices less than or equal to the given depth.
liftAtDepthT :: MapBoundT c n => Int -> Int -> c n -> c n
class MapBoundT (c :: * -> *) n
mapBoundAtDepthT :: MapBoundT c n => (Int -> Bound n -> Bound n) -> Int -> c n -> c n
instance Ord n => MapBoundT (Alt a) n
instance Ord n => MapBoundT (Cast a) n
instance Ord n => MapBoundT (Witness a) n
instance Ord n => MapBoundT (Exp a) n


-- | Renaming of variable binders to anonymous form to avoid capture.
module DDC.Type.Transform.Rename
class Rename (c :: * -> *)
renameWith :: (Rename c, Ord n) => Sub n -> c n -> c n

-- | Substitution state. Keeps track of the binders in the environment that
--   have been rewrittten to avoid variable capture or spec binder
--   shadowing.
data Sub n
Sub :: !(Bound n) -> !Bool -> !(Set n) -> !(Set n) -> !(BindStack n) -> !(BindStack n) -> Sub n

-- | Bound variable that we're substituting for.
subBound :: Sub n -> !(Bound n)

-- | We've decended past a binder that shadows the one that we're
--   substituting for. We're no longer substituting, but still may need to
--   anonymise variables in types. This can only happen for level-0 named
--   binders.
subShadow0 :: Sub n -> !Bool

-- | Level-1 names that need to be rewritten to avoid capture.
subConflict1 :: Sub n -> !(Set n)

-- | Level-0 names that need to be rewritten to avoid capture.
subConflict0 :: Sub n -> !(Set n)

-- | Rewriting stack for level-1 names.
subStack1 :: Sub n -> !(BindStack n)

-- | Rewriting stack for level-0 names.
subStack0 :: Sub n -> !(BindStack n)

-- | Stack of anonymous binders that we've entered under during
--   substitution.
data BindStack n
BindStack :: ![Bind n] -> ![Bind n] -> !Int -> !Int -> BindStack n

-- | Holds anonymous binders that were already in the program, as well as
--   named binders that are being rewritten to anonymous ones. In the
--   resulting expression all these binders will be anonymous.
stackBinds :: BindStack n -> ![Bind n]

-- | Holds all binders, independent of whether they are being rewritten or
--   not.
stackAll :: BindStack n -> ![Bind n]

-- | Number of <a>BAnon</a> in <a>stackBinds</a>.
stackAnons :: BindStack n -> !Int

-- | Number of <a>BName</a> in <a>stackBinds</a>.
stackNamed :: BindStack n -> !Int

-- | Push a bind onto a bind stack, anonymizing it if need be to avoid
--   variable capture.
pushBind :: Ord n => Set n -> BindStack n -> Bind n -> (BindStack n, Bind n)

-- | Push several binds onto the bind stack, anonymyzing them if need be to
--   avoid variable capture.
pushBinds :: Ord n => Set n -> BindStack n -> [Bind n] -> (BindStack n, [Bind n])

-- | Compare a <a>Bound</a> against the one we're substituting for.
substBound :: Ord n => BindStack n -> Bound n -> Bound n -> Either (Bound n) Int

-- | Push a level-1 binder on the rewrite stack.
bind1 :: Ord n => Sub n -> Bind n -> (Sub n, Bind n)

-- | Push some level-1 binders on the rewrite stack.
bind1s :: Ord n => Sub n -> [Bind n] -> (Sub n, [Bind n])

-- | Push a level-0 binder on the rewrite stack.
bind0 :: Ord n => Sub n -> Bind n -> (Sub n, Bind n)

-- | Push some level-0 binders on the rewrite stack.
bind0s :: Ord n => Sub n -> [Bind n] -> (Sub n, [Bind n])

-- | Rewrite the use of a level-1 binder if need be.
use1 :: Ord n => Sub n -> Bound n -> Bound n

-- | Rewrite the use of a level-0 binder if need be.
use0 :: Ord n => Sub n -> Bound n -> Bound n
instance Rename Bind
instance Rename TypeSum
instance Rename Type

module DDC.Core.Transform.Rename
class Rename (c :: * -> *)
renameWith :: (Rename c, Ord n) => Sub n -> c n -> c n

-- | Substitution state. Keeps track of the binders in the environment that
--   have been rewrittten to avoid variable capture or spec binder
--   shadowing.
data Sub n
Sub :: !(Bound n) -> !Bool -> !(Set n) -> !(Set n) -> !(BindStack n) -> !(BindStack n) -> Sub n

-- | Bound variable that we're substituting for.
subBound :: Sub n -> !(Bound n)

-- | We've decended past a binder that shadows the one that we're
--   substituting for. We're no longer substituting, but still may need to
--   anonymise variables in types. This can only happen for level-0 named
--   binders.
subShadow0 :: Sub n -> !Bool

-- | Level-1 names that need to be rewritten to avoid capture.
subConflict1 :: Sub n -> !(Set n)

-- | Level-0 names that need to be rewritten to avoid capture.
subConflict0 :: Sub n -> !(Set n)

-- | Rewriting stack for level-1 names.
subStack1 :: Sub n -> !(BindStack n)

-- | Rewriting stack for level-0 names.
subStack0 :: Sub n -> !(BindStack n)

-- | Stack of anonymous binders that we've entered under during
--   substitution.
data BindStack n
BindStack :: ![Bind n] -> ![Bind n] -> !Int -> !Int -> BindStack n

-- | Holds anonymous binders that were already in the program, as well as
--   named binders that are being rewritten to anonymous ones. In the
--   resulting expression all these binders will be anonymous.
stackBinds :: BindStack n -> ![Bind n]

-- | Holds all binders, independent of whether they are being rewritten or
--   not.
stackAll :: BindStack n -> ![Bind n]

-- | Number of <a>BAnon</a> in <a>stackBinds</a>.
stackAnons :: BindStack n -> !Int

-- | Number of <a>BName</a> in <a>stackBinds</a>.
stackNamed :: BindStack n -> !Int

-- | Push a bind onto a bind stack, anonymizing it if need be to avoid
--   variable capture.
pushBind :: Ord n => Set n -> BindStack n -> Bind n -> (BindStack n, Bind n)

-- | Push several binds onto the bind stack, anonymyzing them if need be to
--   avoid variable capture.
pushBinds :: Ord n => Set n -> BindStack n -> [Bind n] -> (BindStack n, [Bind n])

-- | Compare a <a>Bound</a> against the one we're substituting for.
substBound :: Ord n => BindStack n -> Bound n -> Bound n -> Either (Bound n) Int

-- | Push a level-1 binder on the rewrite stack.
bind1 :: Ord n => Sub n -> Bind n -> (Sub n, Bind n)

-- | Push some level-1 binders on the rewrite stack.
bind1s :: Ord n => Sub n -> [Bind n] -> (Sub n, [Bind n])

-- | Push a level-0 binder on the rewrite stack.
bind0 :: Ord n => Sub n -> Bind n -> (Sub n, Bind n)

-- | Push some level-0 binders on the rewrite stack.
bind0s :: Ord n => Sub n -> [Bind n] -> (Sub n, [Bind n])

-- | Rewrite the use of a level-1 binder if need be.
use1 :: Ord n => Sub n -> Bound n -> Bound n

-- | Rewrite the use of a level-0 binder if need be.
use0 :: Ord n => Sub n -> Bound n -> Bound n
instance Rename (Witness a)


-- | Type environments.
--   
--   An environment contains the types named bound variables, named
--   primitives, and a deBruijn stack for anonymous variables.
module DDC.Type.Env

-- | A type environment.
data Env n
Env :: !(Map n (Type n)) -> ![Type n] -> !Int -> !(n -> Maybe (Type n)) -> Env n

-- | Types of named binders.
envMap :: Env n -> !(Map n (Type n))

-- | Types of anonymous deBruijn binders.
envStack :: Env n -> ![Type n]

-- | The length of the above stack.
envStackLength :: Env n -> !Int

-- | Types of baked in, primitive names.
envPrimFun :: Env n -> !(n -> Maybe (Type n))

-- | Type synonym to improve readability.
type SuperEnv n = Env n

-- | Type synonym to improve readability.
type KindEnv n = Env n

-- | Type synonym to improve readability.
type TypeEnv n = Env n

-- | An empty environment.
empty :: Env n

-- | Construct a singleton type environment.
singleton :: Ord n => Bind n -> Env n

-- | Extend an environment with a new binding. Replaces bindings with the
--   same name already in the environment.
extend :: Ord n => Bind n -> Env n -> Env n

-- | Extend an environment with a list of new bindings. Replaces bindings
--   with the same name already in the environment.
extends :: Ord n => [Bind n] -> Env n -> Env n

-- | Combine two environments. If both environments have a binding with the
--   same name, then the one in the second environment takes preference.
union :: Ord n => Env n -> Env n -> Env n

-- | Combine multiple environments, with the latter ones taking preference.
unions :: Ord n => [Env n] -> Env n

-- | Convert a list of <a>Bind</a>s to an environment.
fromList :: Ord n => [Bind n] -> Env n

-- | Convert a map of names to types to a environment.
fromTypeMap :: Map n (Type n) -> Env n

-- | Yield the total depth of the deBruijn stack.
depth :: Env n -> Int

-- | Check whether a bound variable is present in an environment.
member :: Ord n => Bound n -> Env n -> Bool

-- | Check whether a binder is already present in the an environment. This
--   can only return True for named binders, not anonymous or primitive
--   ones.
memberBind :: Ord n => Bind n -> Env n -> Bool

-- | Lookup a bound variable from an environment.
lookup :: Ord n => Bound n -> Env n -> Maybe (Type n)

-- | Lookup a bound name from an environment.
lookupName :: Ord n => n -> Env n -> Maybe (Type n)

-- | Set the function that knows the types of primitive things.
setPrimFun :: (n -> Maybe (Type n)) -> Env n -> Env n

-- | Check if the type of a name is defined by the <a>envPrimFun</a>.
isPrim :: Env n -> n -> Bool

-- | Wrap locally bound (non primitive) variables defined in an environment
--   around a type as new foralls.
wrapTForalls :: Ord n => Env n -> Type n -> Type n

-- | Lift all free deBruijn indices in the environment by the given number
--   of steps.
lift :: Ord n => Int -> Env n -> Env n

module DDC.Type.Universe

-- | Universes of the Disciple Core language.
data Universe

-- | (level 3). The universe of sorts. Sorts classify kinds.
UniverseSort :: Universe

-- | (level 2). The universe of kinds. Kinds classify specifications.
UniverseKind :: Universe

-- | (level 1). The universe of specifications. Specifications classify
--   both witnesses and data values. In the vanilla Haskell world
--   "specifications" are known as "types", but here we use the former term
--   because we overload the word "type" to refer to kinds and sorts as
--   well.
UniverseSpec :: Universe

-- | (level 0). The universe of witnesses. The existence of a witness in
--   the program guarantees that some property about how it operates at
--   runtime. For example, a witness of constancy of some region guarantees
--   objects in that region will not be updated. This is like the
--   <tt>Prop</tt> universe in constructive logic.
UniverseWitness :: Universe

-- | (level 0). The universe of data values. These are physical data
--   objects that take up space at runtime. This is like the <tt>Set</tt>
--   universe in constructive logic, but the expressions may diverge or
--   cause side effects.
UniverseData :: Universe

-- | Given the type of the type of the type of some thing (up three
--   levels), yield the universe of the original thing, or <a>Nothing</a>
--   it was badly formed.
universeFromType3 :: Type n -> Maybe Universe

-- | Given the type of the type of some thing (up two levels), yield the
--   universe of the original thing, or <a>Nothing</a> if it was badly
--   formed.
universeFromType2 :: Type n -> Maybe Universe

-- | Given the type of some thing (up one level), yield the universe of the
--   original thing, or <a>Nothing</a> if it was badly formed.
universeFromType1 :: Ord n => Env n -> Type n -> Maybe Universe

-- | Yield the universe of some type.
--   
--   <pre>
--   universeOfType (tBot kEffect) = UniverseSpec
--   universeOfType kRegion        = UniverseKind
--   </pre>
universeOfType :: Ord n => Env n -> Type n -> Maybe Universe
instance Show Universe
instance Eq Universe
instance Pretty Universe


-- | Algebraic data type definitions.
module DDC.Type.DataDef

-- | The definition of a single data type.
data DataDef n
DataDef :: !n -> ![Bind n] -> !(Maybe [DataCtor n]) -> Bool -> DataDef n

-- | Name of the data type.
dataDefTypeName :: DataDef n -> !n

-- | Binders for type parameters.
dataDefParams :: DataDef n -> ![Bind n]

-- | Constructors of the data type, or Nothing if the data type is algbraic
--   but there are too many constructors to list (like with <a>Int</a>).
dataDefCtors :: DataDef n -> !(Maybe [DataCtor n])

-- | Whether the data type is algebraic. These can be deconstructed with
--   'case' expressions.
dataDefIsAlgebraic :: DataDef n -> Bool

-- | Get the kind of the type constructor defined by a <a>DataDef</a>.
kindOfDataDef :: DataDef n -> Kind n

-- | Get the type associated with a data definition, that is, the type
--   produced by the constructors.
dataTypeOfDataDef :: DataDef n -> Type n

-- | Get the list of data constructor names that this type defines, or
--   Nothing if there are too many to list.
dataCtorNamesOfDataDef :: DataDef n -> Maybe [n]

-- | Shortcut for constructing a <a>DataDef</a> for an algebraic type.
--   
--   Values of algebraic type can be deconstructed with case-expressions.
makeDataDefAlg :: n -> [Bind n] -> Maybe [(n, [Type n])] -> DataDef n

-- | Shortcut for constructing a <a>DataDef</a> for an abstract type.
--   
--   Values of abstract type cannot be deconstructed with case-expressions.
makeDataDefAbs :: n -> [Bind n] -> DataDef n

-- | A table of data type definitions, unpacked into type and data
--   constructors so we can find them easily.
data DataDefs n
DataDefs :: !(Map n (DataType n)) -> !(Map n (DataCtor n)) -> DataDefs n
dataDefsTypes :: DataDefs n -> !(Map n (DataType n))
dataDefsCtors :: DataDefs n -> !(Map n (DataCtor n))

-- | The mode of a data type records how many data constructors there are.
--   This can be set to <tt>Large</tt> for large primitive types like Int
--   and Float. In this case we don't ever expect them all to be enumerated
--   as case alternatives.
data DataMode n
DataModeSmall :: ![n] -> DataMode n
DataModeLarge :: DataMode n

-- | An empty table of data type definitions.
emptyDataDefs :: DataDefs n

-- | Insert a data type definition into some DataDefs.
insertDataDef :: Ord n => DataDef n -> DataDefs n -> DataDefs n

-- | Union two <a>DataDef</a> tables.
unionDataDefs :: Ord n => DataDefs n -> DataDefs n -> DataDefs n

-- | Build a <a>DataDefs</a> table from a list of <a>DataDef</a>
fromListDataDefs :: Ord n => [DataDef n] -> DataDefs n

-- | Describes a data type constructor, used in the <a>DataDefs</a> table.
data DataType n
DataType :: !n -> ![Bind n] -> !(DataMode n) -> Bool -> DataType n

-- | Name of data type constructor.
dataTypeName :: DataType n -> !n

-- | Kinds of type parameters to constructor.
dataTypeParams :: DataType n -> ![Bind n]

-- | Names of data constructors of this data type, or <a>Nothing</a> if it
--   has infinitely many constructors.
dataTypeMode :: DataType n -> !(DataMode n)

-- | Whether the data type is algebraic.
dataTypeIsAlgebraic :: DataType n -> Bool

-- | Get the kind of the type constructor defined by a <a>DataDef</a>.
kindOfDataType :: DataType n -> Kind n

-- | Yield the list of data constructor names for some data type, or
--   <a>Nothing</a> for large types with too many constructors to list.
lookupModeOfDataType :: Ord n => n -> DataDefs n -> Maybe (DataMode n)

-- | Describes a data constructor, used in the <a>DataDefs</a> table.
data DataCtor n
DataCtor :: !n -> !Integer -> ![Type n] -> !(Type n) -> !n -> ![Bind n] -> DataCtor n

-- | Name of data constructor.
dataCtorName :: DataCtor n -> !n

-- | Tag of constructor (order in data type declaration)
dataCtorTag :: DataCtor n -> !Integer

-- | Field types of constructor.
dataCtorFieldTypes :: DataCtor n -> ![Type n]

-- | Result type of constructor.
dataCtorResultType :: DataCtor n -> !(Type n)

-- | Name of result type of constructor.
dataCtorTypeName :: DataCtor n -> !n

-- | Parameters of data type
dataCtorTypeParams :: DataCtor n -> ![Bind n]

-- | Get the type of <a>DataCtor</a>
typeOfDataCtor :: DataCtor n -> Type n
instance Show n => Show (DataMode n)
instance Show n => Show (DataType n)
instance Show n => Show (DataCtor n)
instance Show n => Show (DataDefs n)
instance Show n => Show (DataDef n)
instance NFData n => NFData (DataCtor n)
instance NFData n => NFData (DataDef n)

module DDC.Core.Module

-- | A module can be mutually recursive with other modules.
data Module a n
ModuleCore :: !ModuleName -> ![(n, ExportSource n)] -> ![(n, ExportSource n)] -> ![(n, ImportSource n)] -> ![(n, ImportSource n)] -> ![DataDef n] -> !(Exp a n) -> Module a n

-- | Name of this module.
moduleName :: Module a n -> !ModuleName

-- | Kinds of exported types.
moduleExportTypes :: Module a n -> ![(n, ExportSource n)]

-- | Types of exported values.
moduleExportValues :: Module a n -> ![(n, ExportSource n)]

-- | Kinds of imported types, along with the name of the module they are
--   from. These imports come from a Disciple module, that we've compiled
--   ourself.
moduleImportTypes :: Module a n -> ![(n, ImportSource n)]

-- | Types of imported values, along with the name of the module they are
--   from. These imports come from a Disciple module, that we've compiled
--   ourself.
moduleImportValues :: Module a n -> ![(n, ImportSource n)]

-- | Data types defined in this module.
moduleDataDefsLocal :: Module a n -> ![DataDef n]

-- | The module body consists of some let-bindings wrapping a unit data
--   constructor. We're only interested in the bindings, with the unit
--   being just a place-holder.
moduleBody :: Module a n -> !(Exp a n)

-- | Check if this is the <tt>Main</tt> module.
isMainModule :: Module a n -> Bool

-- | Get the top-level kind environment of a module, from its imported
--   types.
moduleKindEnv :: Ord n => Module a n -> KindEnv n

-- | Get the top-level type environment of a module, from its imported
--   values.
moduleTypeEnv :: Ord n => Module a n -> TypeEnv n

-- | Get the set of top-level value bindings in a module.
moduleTopBinds :: Ord n => Module a n -> Set n

-- | Get a map of named top-level bindings to their types.
moduleTopBindTypes :: Ord n => Module a n -> Map n (Type n)

-- | Map of module names to modules.
type ModuleMap a n = Map ModuleName (Module a n)

-- | Add the kind environment exported by all these modules to the given
--   one.
modulesExportTypes :: Ord n => ModuleMap a n -> KindEnv n -> KindEnv n

-- | Add the type environment exported by all these modules to the given
--   one.
modulesExportValues :: Ord n => ModuleMap a n -> TypeEnv n -> TypeEnv n

-- | A fully qualified name, including the name of the module it is from.
data QualName n
QualName :: ModuleName -> n -> QualName n

-- | A hierarchical module name.
data ModuleName
ModuleName :: [String] -> ModuleName

-- | Check whether this is the name of the "Main" module.
isMainModuleName :: ModuleName -> Bool
data ExportSource n

-- | A name defined in this module, with an explicit type.
ExportSourceLocal :: n -> Type n -> ExportSource n
exportSourceLocalName :: ExportSource n -> n
exportSourceLocalType :: ExportSource n -> Type n

-- | A named defined in this module, without a type attached. We use this
--   version for source language where we infer the type of the exported
--   thing.
ExportSourceLocalNoType :: n -> ExportSource n
exportSourceLocalName :: ExportSource n -> n

-- | Take the type of an imported thing, if there is one.
takeTypeOfExportSource :: ExportSource n -> Maybe (Type n)

-- | Apply a function to any type in an ExportSource.
mapTypeOfExportSource :: (Type n -> Type n) -> ExportSource n -> ExportSource n

-- | Source of some imported thing.
data ImportSource n

-- | A type imported abstractly. It may be defined in a foreign language,
--   but the Disciple program treats it abstractly.
ImportSourceAbstract :: Type n -> ImportSource n
importSourceAbstractType :: ImportSource n -> Type n

-- | Something imported from a Disciple module that we compiled ourself.
ImportSourceModule :: ModuleName -> n -> Type n -> ImportSource n
importSourceModuleName :: ImportSource n -> ModuleName
importSourceModuleVar :: ImportSource n -> n
importSourceModuleType :: ImportSource n -> Type n

-- | Something imported via the C calling convention.
ImportSourceSea :: String -> Type n -> ImportSource n
importSourceSeaVar :: ImportSource n -> String
importSourceSeaType :: ImportSource n -> Type n

-- | Take the type of an imported thing.
typeOfImportSource :: ImportSource n -> Type n

-- | Apply a function to the type in an ImportSource.
mapTypeOfImportSource :: (Type n -> Type n) -> ImportSource n -> ImportSource n
instance Typeable ModuleName
instance Typeable2 Module
instance Show ModuleName
instance Eq ModuleName
instance Ord ModuleName
instance Show n => Show (QualName n)
instance Show n => Show (ExportSource n)
instance Eq n => Eq (ExportSource n)
instance Show n => Show (ImportSource n)
instance Eq n => Eq (ImportSource n)
instance (Show a, Show n) => Show (Module a n)
instance NFData n => NFData (ImportSource n)
instance NFData n => NFData (ExportSource n)
instance NFData n => NFData (QualName n)
instance NFData ModuleName
instance (NFData a, NFData n) => NFData (Module a n)

module DDC.Core.Transform.Reannotate

-- | Apply the given function to every annotation in a core thing.
class Reannotate c
reannotate :: Reannotate c => (a -> b) -> c a n -> c b n
instance Reannotate Witness
instance Reannotate Cast
instance Reannotate Alt
instance Reannotate Lets
instance Reannotate Exp
instance Reannotate Module

module DDC.Type.Transform.SpreadT
class SpreadT (c :: * -> *)
spreadT :: (SpreadT c, Ord n) => TypeEnv n -> c n -> c n
instance SpreadT DataCtor
instance SpreadT DataType
instance SpreadT DataDefs
instance SpreadT DataDef
instance SpreadT TyCon
instance SpreadT Bound
instance SpreadT Bind
instance SpreadT TypeSum
instance SpreadT Type

module DDC.Core.Transform.SpreadX
class SpreadX (c :: * -> *)
spreadX :: (SpreadX c, Ord n) => Env n -> Env n -> c n -> c n
instance SpreadX Bound
instance SpreadX Bind
instance SpreadX WiCon
instance SpreadX (Witness a)
instance SpreadX (Lets a)
instance SpreadX (Alt a)
instance SpreadX Pat
instance SpreadX (Cast a)
instance SpreadX DaCon
instance SpreadX (Exp a)
instance SpreadX ImportSource
instance SpreadT ExportSource
instance SpreadX (Module a)


-- | Predicates on type expressions.
module DDC.Type.Predicates
isBNone :: Bind n -> Bool
isBAnon :: Bind n -> Bool
isBName :: Bind n -> Bool

-- | Check whether a type is a <a>TVar</a>
isTVar :: Type n -> Bool

-- | Test if some type is an empty TSum
isBot :: Type n -> Bool

-- | Check whether a type is a <a>TVar</a>, <a>TCon</a> or is Bottom.
isAtomT :: Type n -> Bool

-- | Check whether this type is an existential variable.
isTExists :: Type n -> Bool

-- | Check if some kind is the data kind.
isDataKind :: Kind n -> Bool

-- | Check if some kind is the region kind.
isRegionKind :: Region n -> Bool

-- | Check if some kind is the effect kind.
isEffectKind :: Kind n -> Bool

-- | Check if some kind is the closure kind.
isClosureKind :: Kind n -> Bool

-- | Check if some kind is the witness kind.
isWitnessKind :: Kind n -> Bool

-- | Check whether this type is that of algebraic data.
--   
--   It needs to have an explicit data constructor out the front, and not a
--   type variable. The constructor must not be the function constructor,
--   and must return a value of kind <a>*</a>.
isAlgDataType :: Eq n => Type n -> Bool

-- | Check whether type is a witness constructor
isWitnessType :: Eq n => Type n -> Bool

-- | Check whether this is the type of a <tt>Const</tt> witness.
isConstWitType :: Eq n => Type n -> Bool

-- | Check whether this is the type of a <tt>Mutable</tt> witness.
isMutableWitType :: Eq n => Type n -> Bool

-- | Check whether this is the type of a <tt>Distinct</tt> witness.
isDistinctWitType :: Eq n => Type n -> Bool

-- | Check whether this is an atomic read effect.
isReadEffect :: Effect n -> Bool

-- | Check whether this is an atomic write effect.
isWriteEffect :: Effect n -> Bool

-- | Check whether this is an atomic alloc effect.
isAllocEffect :: Effect n -> Bool

-- | Check whether an effect is some sort of read effect. Matches
--   <tt>Read</tt> <tt>HeadRead</tt> and <tt>DeepRead</tt>.
isSomeReadEffect :: Effect n -> Bool

-- | Check whether an effect is some sort of allocation effect. Matches
--   <tt>Alloc</tt> and <tt>DeepAlloc</tt>
isSomeWriteEffect :: Effect n -> Bool

-- | Check whether an effect is some sort of allocation effect. Matches
--   <tt>Alloc</tt> and <tt>DeepAlloc</tt>
isSomeAllocEffect :: Effect n -> Bool


-- | Simple predicates on core expressions.
module DDC.Core.Predicates

-- | Check whether an expression is a variable.
isXVar :: Exp a n -> Bool

-- | Check whether an expression is a constructor.
isXCon :: Exp a n -> Bool

-- | Check whether an expression is a <a>XVar</a> or an <a>XCon</a>, or
--   some type or witness atom.
isAtomX :: Exp a n -> Bool

-- | Check whether a witness is a <a>WVar</a> or <a>WCon</a>.
isAtomW :: Witness a n -> Bool

-- | Check whether an expression is a spec abstraction (level-1).
isXLAM :: Exp a n -> Bool

-- | Check whether an expression is a value or witness abstraction
--   (level-0).
isXLam :: Exp a n -> Bool

-- | Check whether an expression is a spec, value, or witness abstraction.
isLambdaX :: Exp a n -> Bool

-- | Check whether an expression is an <a>XApp</a>.
isXApp :: Exp a n -> Bool

-- | Check whether an expression is a <a>XLet</a>.
isXLet :: Exp a n -> Bool

-- | Check whether an expression is an <a>XType</a>.
isXType :: Exp a n -> Bool

-- | Check whether an expression is an <a>XWitness</a>.
isXWitness :: Exp a n -> Bool

-- | Check whether an alternative is a <a>PDefault</a>.
isPDefault :: Pat n -> Bool


-- | Pretty printing for core modules and expressions.
module DDC.Core.Pretty

-- | Pretty print an exported type definition.
pprExportType :: (Pretty n, Eq n) => (n, ExportSource n) -> Doc

-- | Pretty print an exported value definition.
pprExportValue :: (Pretty n, Eq n) => (n, ExportSource n) -> Doc

-- | Pretty print an imported type definition.
pprImportType :: (Pretty n, Eq n) => (n, ImportSource n) -> Doc

-- | Pretty print an imported value definition.
pprImportValue :: (Pretty n, Eq n) => (n, ImportSource n) -> Doc
instance Pretty WbCon
instance (Pretty n, Eq n) => Pretty (WiCon n)
instance (Pretty n, Eq n) => Pretty (Witness a n)
instance (Pretty n, Eq n) => Pretty (Lets a n)
instance (Pretty n, Eq n) => Pretty (Cast a n)
instance (Pretty n, Eq n) => Pretty (DaCon n)
instance (Pretty n, Eq n) => Pretty (Alt a n)
instance (Pretty n, Eq n) => Pretty (Pat n)
instance (Pretty n, Eq n) => Pretty (Exp a n)
instance (Pretty n, Eq n) => Pretty (DataCtor n)
instance (Pretty n, Eq n) => Pretty (DataDef n)
instance (Pretty n, Eq n) => Pretty (Module a n)
instance Pretty ModuleName

module DDC.Core.Lexer.Tokens

-- | Tokens accepted by the core language parser.
data Tok n

-- | Some junk symbol that isn't part of the language.
KJunk :: String -> Tok n

-- | Meta tokens contain out-of-band information that is eliminated before
--   parsing proper.
KM :: !TokMeta -> Tok n

-- | Atomic tokens are keywords, punctuation and baked-in constructor
--   names.
KA :: !TokAtom -> Tok n

-- | A named token that is specific to the language fragment (maybe it's a
--   primop), or a user defined name.
KN :: !(TokNamed n) -> Tok n

-- | Apply a function to all the names in a <a>Tok</a>.
renameTok :: Ord n2 => (n1 -> Maybe n2) -> Tok n1 -> Maybe (Tok n2)

-- | Describe a token for parser error messages.
describeTok :: Pretty n => Tok n -> String

-- | Meta tokens contain out-of-band information that is eliminated before
--   parsing proper.
data TokMeta
KNewLine :: TokMeta
KCommentLineStart :: TokMeta
KCommentBlockStart :: TokMeta
KCommentBlockEnd :: TokMeta

-- | This is injected by <tt>dropCommentBlock</tt> when it finds an
--   unterminated block comment.
KCommentUnterminated :: TokMeta

-- | This is injected by <tt>applyOffside</tt> when it finds an explit
--   close brace in a position where it would close a synthetic one.
KOffsideClosingBrace :: TokMeta

-- | Describe a TokMeta, for lexer error messages.
describeTokMeta :: TokMeta -> String

-- | Atomic tokens are keywords, punctuation and baked-in constructor
--   names. They don't contain user-defined names or primops specific to
--   the language fragment.
data TokAtom
KRoundBra :: TokAtom
KRoundKet :: TokAtom
KSquareBra :: TokAtom
KSquareKet :: TokAtom
KBraceBra :: TokAtom
KBraceKet :: TokAtom
KSquareColonBra :: TokAtom
KSquareColonKet :: TokAtom
KBraceColonBra :: TokAtom
KBraceColonKet :: TokAtom

-- | Naked operator, like in 1 + 2.
KOp :: String -> TokAtom

-- | Wrapped operator, like in (+) 1 2.
KOpVar :: String -> TokAtom
KHat :: TokAtom
KDot :: TokAtom
KComma :: TokAtom
KSemiColon :: TokAtom
KUnderscore :: TokAtom
KBackSlash :: TokAtom
KBigLambda :: TokAtom
KArrowTilde :: TokAtom
KArrowDash :: TokAtom
KArrowDashLeft :: TokAtom
KArrowEquals :: TokAtom
KBotEffect :: TokAtom
KBotClosure :: TokAtom
KModule :: TokAtom
KImport :: TokAtom
KExport :: TokAtom
KForeign :: TokAtom
KType :: TokAtom
KValue :: TokAtom
KData :: TokAtom
KWith :: TokAtom
KWhere :: TokAtom
KIn :: TokAtom
KLet :: TokAtom
KLetCase :: TokAtom
KLetRec :: TokAtom
KPrivate :: TokAtom
KExtend :: TokAtom
KUsing :: TokAtom
KWithRegion :: TokAtom
KCase :: TokAtom
KOf :: TokAtom
KWeakEff :: TokAtom
KWeakClo :: TokAtom
KPurify :: TokAtom
KForget :: TokAtom
KBox :: TokAtom
KRun :: TokAtom
KDo :: TokAtom
KMatch :: TokAtom
KElse :: TokAtom
KIndex :: Int -> TokAtom
KSoConBuiltin :: SoCon -> TokAtom
KKiConBuiltin :: KiCon -> TokAtom
KTwConBuiltin :: TwCon -> TokAtom
KWbConBuiltin :: WbCon -> TokAtom
KTcConBuiltin :: TcCon -> TokAtom
KDaConUnit :: TokAtom

-- | Describe a <a>TokAtom</a>, for parser error messages.
describeTokAtom :: TokAtom -> String

-- | A token with a user-defined name.
data TokNamed n
KCon :: n -> TokNamed n
KVar :: n -> TokNamed n
KLit :: n -> TokNamed n

-- | Describe a <a>TokNamed</a>, for parser error messages.
describeTokNamed :: Pretty n => TokNamed n -> String
instance Eq TokMeta
instance Show TokMeta
instance Eq TokAtom
instance Show TokAtom
instance Eq n => Eq (TokNamed n)
instance Show n => Show (TokNamed n)
instance Eq n => Eq (Tok n)
instance Show n => Show (Tok n)

module DDC.Core.Lexer.Names

-- | Textual keywords in the core language.
keywords :: [(String, Tok n)]

-- | Read a named sort constructor.
readSoConBuiltin :: String -> Maybe SoCon

-- | Read a named kind constructor.
readKiConBuiltin :: String -> Maybe KiCon

-- | Read a named witness type constructor.
readTwConBuiltin :: String -> Maybe TwCon

-- | Read a builtin type constructor with a non-symbolic name. ie not
--   '-&gt;'.
readTcConBuiltin :: String -> Maybe TcCon

-- | Read a witness constructor.
readWbConBuiltin :: String -> Maybe WbCon

-- | String is a variable name
isVarName :: String -> Bool

-- | Charater can start a variable name.
isVarStart :: Char -> Bool

-- | Character can be part of a variable body.
isVarBody :: Char -> Bool

-- | Read a named, user defined variable.
readVar :: String -> Maybe String

-- | String is a constructor name.
isConName :: String -> Bool

-- | Character can start a constructor name.
isConStart :: Char -> Bool

-- | Charater can be part of a constructor body.
isConBody :: Char -> Bool

-- | Read a named, user defined <a>TcCon</a>.
readCon :: String -> Maybe String

-- | String is the name of some operator.
isOpName :: String -> Bool

-- | Character can start an operator.
isOpStart :: Char -> Bool

-- | Character can be part of an operator body.
isOpBody :: Char -> Bool

-- | String is the name of a literal.
isLitName :: String -> Bool

-- | Character can start a literal.
isLitStart :: Char -> Bool

-- | Character can be part of a literal body.
isLitBody :: Char -> Bool


-- | Reference lexer for core langauge parser. Slow but Simple.
--   
--   The lexers here all use <a>String</a> in place of a real name type.
--   After applying these functions to the program text, we need to use
--   <a>renameTok</a> tok convert the strings in <a>TokNamed</a> tokens
--   into the name type specific to the langauge fragment to be parsed.
module DDC.Core.Lexer

-- | Lex a module and apply the offside rule.
--   
--   Automatically drop comments from the token stream along the way.
lexModuleWithOffside :: FilePath -> Int -> String -> [Token (Tok String)]

-- | Lex a string into tokens.
--   
--   Automatically drop comments from the token stream along the way.
lexExp :: FilePath -> Int -> String -> [Token (Tok String)]


-- | The ambient Disciple Core language is specialised to concrete
--   languages by adding primitive operations and optionally restricting
--   the set of available language features. This specialisation results in
--   user-facing language fragments such as <tt>Disciple Core Lite</tt> and
--   <tt>Disciple Core Salt</tt>.
module DDC.Core.Fragment

-- | Carries all the information we need to work on a particular fragment
--   of the Disciple Core language.
data Fragment n (err :: * -> *)
Fragment :: Profile n -> String -> (String -> Maybe n) -> (String -> Int -> String -> [Token (Tok n)]) -> (String -> Int -> String -> [Token (Tok n)]) -> (forall a. Module a n -> Maybe (err a)) -> (forall a. Exp a n -> Maybe (err a)) -> Fragment n

-- | Language profile for this fragment.
fragmentProfile :: Fragment n -> Profile n

-- | File extension to use when dumping modules in this fragment.
fragmentExtension :: Fragment n -> String

-- | Read a name.
fragmentReadName :: Fragment n -> String -> Maybe n

-- | Lex module source into tokens, given the source name and starting line
--   number.
fragmentLexModule :: Fragment n -> String -> Int -> String -> [Token (Tok n)]

-- | Lex expression source into tokens, given the source name and starting
--   line number.
fragmentLexExp :: Fragment n -> String -> Int -> String -> [Token (Tok n)]

-- | Perform language fragment specific checks on a module.
fragmentCheckModule :: Fragment n -> forall a. Module a n -> Maybe (err a)

-- | Perform language fragment specific checks on an expression.
fragmentCheckExp :: Fragment n -> forall a. Exp a n -> Maybe (err a)

-- | The fragment profile describes the language features and primitive
--   operators available in the language.
data Profile n
Profile :: !String -> !Features -> !(DataDefs n) -> !(KindEnv n) -> !(TypeEnv n) -> !(Type n -> Bool) -> !(Maybe (n -> Bool)) -> Profile n

-- | The name of this profile.
profileName :: Profile n -> !String

-- | Permitted language features.
profileFeatures :: Profile n -> !Features

-- | Primitive data type declarations.
profilePrimDataDefs :: Profile n -> !(DataDefs n)

-- | Kinds of primitive types.
profilePrimKinds :: Profile n -> !(KindEnv n)

-- | Types of primitive operators.
profilePrimTypes :: Profile n -> !(TypeEnv n)

-- | Check whether a type is an unboxed type. Some fragments limit how
--   these can be used.
profileTypeIsUnboxed :: Profile n -> !(Type n -> Bool)

-- | Check whether some name represents a hole that needs to be filled in
--   by the type checker.
profileNameIsHole :: Profile n -> !(Maybe (n -> Bool))

-- | A language profile with no features or primitive operators.
--   
--   This provides a simple first-order language.
zeroProfile :: Profile n

-- | Language feature supported by a fragment.
data Feature

-- | Track effect type information.
TrackedEffects :: Feature

-- | Track closure type information.
TrackedClosures :: Feature

-- | Attach latent effects to function types.
FunctionalEffects :: Feature

-- | Attach latent closures to function types.
FunctionalClosures :: Feature

-- | Treat effects as capabilities.
EffectCapabilities :: Feature

-- | Partially applied primitive operators.
PartialPrims :: Feature

-- | Partially applied functions
PartialApplication :: Feature

-- | Function application where the thing being applied is not a variable.
--   Most backend languages (like LLVM) don't support this.
GeneralApplication :: Feature

-- | Nested function bindings. The output of the lambda-lifter should not
--   contain these.
NestedFunctions :: Feature

-- | Debruijn binders. Most backends will want to use real names, instead
--   of indexed binders.
DebruijnBinders :: Feature

-- | Allow data and witness vars without binding occurrences if they are
--   annotated directly with their types. This lets us work with open
--   terms.
UnboundLevel0Vars :: Feature

-- | Allow non-primitive functions to be instantiated at unboxed types. Our
--   existing backends can't handle this, because boxed and unboxed objects
--   have different representations.
UnboxedInstantiation :: Feature

-- | Allow name shadowing.
NameShadowing :: Feature

-- | Allow unused named data and witness bindings.
UnusedBindings :: Feature

-- | Allow unused named matches.
UnusedMatches :: Feature

-- | A flattened set of features, for easy lookup.
data Features
Features :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Features
featuresTrackedEffects :: Features -> Bool
featuresTrackedClosures :: Features -> Bool
featuresFunctionalEffects :: Features -> Bool
featuresFunctionalClosures :: Features -> Bool
featuresEffectCapabilities :: Features -> Bool
featuresPartialPrims :: Features -> Bool
featuresPartialApplication :: Features -> Bool
featuresGeneralApplication :: Features -> Bool
featuresNestedFunctions :: Features -> Bool
featuresDebruijnBinders :: Features -> Bool
featuresUnboundLevel0Vars :: Features -> Bool
featuresUnboxedInstantiation :: Features -> Bool
featuresNameShadowing :: Features -> Bool
featuresUnusedBindings :: Features -> Bool
featuresUnusedMatches :: Features -> Bool

-- | An emtpy feature set, with all flags set to <a>False</a>.
zeroFeatures :: Features

-- | Check whether a core thing complies with a language fragment profile.
complies :: (Ord n, Show n, Complies c) => Profile n -> c a n -> Maybe (Error a n)

-- | Like <a>complies</a> but with some starting environments.
compliesWithEnvs :: (Ord n, Show n, Complies c) => Profile n -> KindEnv n -> TypeEnv n -> c a n -> Maybe (Error a n)

-- | Class of things we can check language fragment compliance for.
class Complies (c :: * -> * -> *)

-- | Language fragment compliance violations.
data Error a n

-- | Found an unsupported language feature.
ErrorUnsupported :: !Feature -> Error a n

-- | Found an undefined primitive operator.
ErrorUndefinedPrim :: !n -> Error a n

-- | Found an unbound variable.
ErrorUndefinedVar :: !n -> Error a n

-- | Found a variable binder that shadows another one at a higher scope,
--   but the profile doesn't permit this.
ErrorShadowedBind :: !n -> Error a n

-- | Found a bound variable with no uses, but the profile doesn't permit
--   this.
ErrorUnusedBind :: !n -> Error a n

-- | Found a naked type that isn't used as a function argument.
ErrorNakedType :: !(Type n) -> Error a n

-- | Found a naked witness that isn't used as a function argument.
ErrorNakedWitness :: !(Witness a n) -> Error a n
instance Show (Fragment n err)


-- | Core language parser.
module DDC.Core.Parser

-- | A parser of core language tokens.
type Parser n a = Parser (Tok n) a

-- | Configuration and information from the context. Used for context
--   sensitive parsing.
data Context
Context :: Bool -> Bool -> Bool -> Bool -> Context
contextTrackedEffects :: Context -> Bool
contextTrackedClosures :: Context -> Bool
contextFunctionalEffects :: Context -> Bool
contextFunctionalClosures :: Context -> Bool

-- | Slurp an initital <a>Context</a> from a language <a>Profile</a>.
contextOfProfile :: Profile n -> Context

-- | Parse a type.
pType :: Ord n => Context -> Parser n (Type n)

-- | Parse a type application.
pTypeApp :: Ord n => Context -> Parser n (Type n)

-- | Parse a variable, constructor or parenthesised type.
pTypeAtom :: Ord n => Context -> Parser n (Type n)

-- | Parse a core module.
pModule :: (Ord n, Pretty n) => Context -> Parser n (Module SourcePos n)

-- | Parse a module name.
pModuleName :: Pretty n => Parser n ModuleName

-- | Parse a core language expression.
pExp :: Ord n => Context -> Parser n (Exp SourcePos n)

-- | Parse a function application.
pExpApp :: Ord n => Context -> Parser n (Exp SourcePos n)

-- | Parse a variable, constructor or parenthesised expression.
pExpAtom :: Ord n => Context -> Parser n (Exp SourcePos n)

-- | Specification of a function parameter. We can determine the
--   contribution to the type of the function, as well as its expression
--   based on the parameter.
data ParamSpec n
ParamType :: (Bind n) -> ParamSpec n
ParamWitness :: (Bind n) -> ParamSpec n
ParamValue :: (Bind n) -> (Type n) -> (Type n) -> ParamSpec n

-- | Build the type of a function from specifications of its parameters,
--   and the type of the body.
funTypeOfParams :: Context -> [ParamSpec n] -> Type n -> Type n

-- | Build the expression of a function from specifications of its
--   parameters, and the expression for the body.
expOfParams :: a -> [ParamSpec n] -> Exp a n -> Exp a n

-- | Parse a function parameter specification, requiring a full type (or
--   kind) annotation.
pBindParamSpecAnnot :: Ord n => Context -> Parser n [ParamSpec n]

-- | Parse a function parameter specification, with an optional type (or
--   kind) annotation.
pBindParamSpec :: Ord n => Context -> Parser n [ParamSpec n]

-- | Parse a witness expression.
pWitness :: Ord n => Context -> Parser n (Witness SourcePos n)

-- | Parse a witness application.
pWitnessApp :: Ord n => Context -> Parser n (Witness SourcePos n)

-- | Parse a variable, constructor or parenthesised witness.
pWitnessAtom :: Ord n => Context -> Parser n (Witness SourcePos n)

-- | Parse a constructor name.
pCon :: Parser n n

-- | Parse a constructor name.
pConSP :: Parser n (n, SourcePos)

-- | Parse a literal.
pLit :: Parser n n

-- | Parse a literal, with source position.
pLitSP :: Parser n (n, SourcePos)

-- | Parse a deBruijn index.
pIndex :: Parser n Int

-- | Parse a deBruijn index, with source position.
pIndexSP :: Parser n (Int, SourcePos)

-- | Parse a variable.
pVar :: Parser n n

-- | Parse a variable, with source position.
pVarSP :: Parser n (n, SourcePos)

-- | Parse a binder.
pBinder :: Ord n => Parser n (Binder n)

-- | Parse a constructor or variable name.
pName :: Parser n n

-- | Parse an infix operator.
pOpSP :: Parser n (String, SourcePos)

-- | Parse an infix operator used as a variable.
pOpVarSP :: Parser n (String, SourcePos)

-- | Parse an atomic token.
pTok :: TokAtom -> Parser n ()

-- | Parse an atomic token, yielding its source position.
pTokSP :: TokAtom -> Parser n SourcePos

-- | Parse an atomic token and return some value.
pTokAs :: TokAtom -> a -> Parser n a

module DDC.Type.Bind

-- | Lookup the type of a bound thing from the binder stack. The binder
--   stack contains the binders of all the <a>TForall</a>s we've entered
--   under so far.
getBindType :: Eq n => [Bind n] -> Bound n -> Maybe (Int, Type n)


-- | Collecting sets of variables and constructors.
module DDC.Type.Collect

-- | Collect the free Spec variables in a thing (level-1).
freeT :: (BindStruct c, Ord n) => Env n -> c n -> Set (Bound n)

-- | Collect the free type variables in a type.
freeVarsT :: Ord n => KindEnv n -> Type n -> Set (Bound n)
class FreeVarConT (c :: * -> *)
freeVarConT :: (FreeVarConT c, Ord n) => KindEnv n -> c n -> (Set (Bound n), Set (Bound n))

-- | Collect all the bound variables in a thing, independent of whether
--   they are free or not.
collectBound :: (BindStruct c, Ord n) => c n -> Set (Bound n)

-- | Collect all the spec and exp binders in a thing.
collectBinds :: (BindStruct c, Ord n) => c n -> ([Bind n], [Bind n])

-- | A description of the binding structure of some type or expression.
data BindTree n

-- | An abstract binding expression.
BindDef :: BindWay -> [Bind n] -> [BindTree n] -> BindTree n

-- | Use of a variable.
BindUse :: BoundLevel -> (Bound n) -> BindTree n

-- | Use of a constructor.
BindCon :: BoundLevel -> (Bound n) -> (Maybe (Kind n)) -> BindTree n

-- | Describes how a variable was bound.
data BindWay
BindForall :: BindWay
BindLAM :: BindWay
BindLam :: BindWay
BindLet :: BindWay
BindLetRec :: BindWay
BindLetRegions :: BindWay
BindLetRegionWith :: BindWay
BindCasePat :: BindWay
class BindStruct (c :: * -> *)
slurpBindTree :: BindStruct c => c n -> [BindTree n]

-- | What level this binder is at.
data BoundLevel
BoundSpec :: BoundLevel
BoundExp :: BoundLevel
BoundWit :: BoundLevel

-- | Check if a boundlevel is expression or witness
isBoundExpWit :: BoundLevel -> Bool

-- | Get the <a>BoundLevel</a> corresponding to a <a>BindWay</a>.
boundLevelOfBindWay :: BindWay -> BoundLevel

-- | Helper for constructing the <a>BindTree</a> for a type binder.
bindDefT :: BindStruct c => BindWay -> [Bind n] -> [c n] -> BindTree n
instance Eq BindWay
instance Show BindWay
instance Eq BoundLevel
instance Show BoundLevel
instance Eq n => Eq (BindTree n)
instance Show n => Show (BindTree n)
instance BindStruct TyCon
instance BindStruct Type

module DDC.Type.Transform.Trim

-- | Trim compound closures into their components.
--   
--   This is like <tt>crushEffect</tt>, but for closures instead of
--   effects.
--   
--   For example, trimming <tt>DeepUse (Int r2 -(Read r1 | Use r1)&gt; Int
--   r2)</tt> yields just <tt>Use r1</tt>. Only <tt>r1</tt> might contain
--   an actual store object that is reachable from a function closure with
--   such a type.
--   
--   This function assumes the closure is well-kinded, and may return
--   <a>Nothing</a> if this is not the case.
trimClosure :: Ord n => Closure n -> Maybe (Closure n)

module DDC.Type.Transform.Crush

-- | Crush compound effects and closure terms. We check for a crushable
--   term before calling crushT because that function will recursively
--   crush the components. As equivT is already recursive, we don't want a
--   doubly-recursive function that tries to re-crush the same
--   non-crushable type over and over.
crushSomeT :: Ord n => Type n -> Type n

-- | Crush compound effect terms into their components.
--   
--   This is like <a>trimClosure</a> but for effects instead of closures.
--   
--   For example, crushing <tt>DeepRead (List r1 (Int r2))</tt> yields
--   <tt>(Read r1 + Read r2)</tt>.
crushEffect :: Ord n => Effect n -> Effect n


-- | Capture avoiding substitution of types in types.
module DDC.Type.Transform.SubstituteT

-- | Substitute a <a>Type</a> for the <a>Bound</a> corresponding to some
--   <a>Bind</a> in a thing.
substituteT :: (SubstituteT c, Ord n) => Bind n -> Type n -> c n -> c n

-- | Wrapper for <a>substituteT</a> to substitute multiple things.
substituteTs :: (SubstituteT c, Ord n) => [(Bind n, Type n)] -> c n -> c n

-- | Substitute a <a>Type</a> for <a>Bound</a> in some thing.
substituteBoundT :: (SubstituteT c, Ord n) => Bound n -> Type n -> c n -> c n
class SubstituteT (c :: * -> *)
substituteWithT :: (SubstituteT c, Ord n) => Bound n -> Type n -> Set n -> BindStack n -> c n -> c n

-- | Stack of anonymous binders that we've entered under during
--   substitution.
data BindStack n
BindStack :: ![Bind n] -> ![Bind n] -> !Int -> !Int -> BindStack n

-- | Holds anonymous binders that were already in the program, as well as
--   named binders that are being rewritten to anonymous ones. In the
--   resulting expression all these binders will be anonymous.
stackBinds :: BindStack n -> ![Bind n]

-- | Holds all binders, independent of whether they are being rewritten or
--   not.
stackAll :: BindStack n -> ![Bind n]

-- | Number of <a>BAnon</a> in <a>stackBinds</a>.
stackAnons :: BindStack n -> !Int

-- | Number of <a>BName</a> in <a>stackBinds</a>.
stackNamed :: BindStack n -> !Int

-- | Push a bind onto a bind stack, anonymizing it if need be to avoid
--   variable capture.
pushBind :: Ord n => Set n -> BindStack n -> Bind n -> (BindStack n, Bind n)

-- | Push several binds onto the bind stack, anonymyzing them if need be to
--   avoid variable capture.
pushBinds :: Ord n => Set n -> BindStack n -> [Bind n] -> (BindStack n, [Bind n])

-- | Compare a <a>Bound</a> against the one we're substituting for.
substBound :: Ord n => BindStack n -> Bound n -> Bound n -> Either (Bound n) Int
instance SubstituteT TypeSum
instance SubstituteT Type
instance SubstituteT Bind

module DDC.Type.Transform.Instantiate

-- | Instantiate a type with an argument. The type to be instantiated must
--   have an outer forall, else <a>Nothing</a>.
instantiateT :: Ord n => Type n -> Type n -> Maybe (Type n)

-- | Instantiate a type with several arguments. The type to be instantiated
--   must have at least as many outer foralls as provided type arguments,
--   else <a>Nothing</a>.
instantiateTs :: Ord n => Type n -> [Type n] -> Maybe (Type n)


-- | Collecting sets of variables and constructors.
module DDC.Core.Collect

-- | Collect the free Spec variables in a thing (level-1).
freeT :: (BindStruct c, Ord n) => Env n -> c n -> Set (Bound n)

-- | Collect the free Data and Witness variables in a thing (level-0).
freeX :: (BindStruct c, Ord n) => Env n -> c n -> Set (Bound n)

-- | Collect all the bound variables in a thing, independent of whether
--   they are free or not.
collectBound :: (BindStruct c, Ord n) => c n -> Set (Bound n)

-- | Collect all the spec and exp binders in a thing.
collectBinds :: (BindStruct c, Ord n) => c n -> ([Bind n], [Bind n])
data Support n
Support :: Set (Bound n) -> Set (Bound n) -> Set (Bound n) -> Set (Bound n) -> Set (Bound n) -> Set (Bound n) -> Support n

-- | Type constructors used in the expression.
supportTyCon :: Support n -> Set (Bound n)

-- | Type constructors used in the argument of a value-type application.
supportTyConXArg :: Support n -> Set (Bound n)

-- | Free spec variables in an expression.
supportSpVar :: Support n -> Set (Bound n)

-- | Type constructors used in the argument of a value-type application.
supportSpVarXArg :: Support n -> Set (Bound n)

-- | Free witness variables in an expression. (from the Witness universe)
supportWiVar :: Support n -> Set (Bound n)

-- | Free value variables in an expression. (from the Data universe)
supportDaVar :: Support n -> Set (Bound n)
class SupportX (c :: * -> *)
support :: (SupportX c, Ord n) => KindEnv n -> TypeEnv n -> c n -> Support n


-- | Capture avoiding substitution of types in expressions.
--   
--   If a binder would capture a variable then it is anonymized to deBruijn
--   form.
module DDC.Core.Transform.SubstituteTX
class SubstituteTX (c :: * -> *)
substituteWithTX :: (SubstituteTX c, Ord n) => Type n -> Sub n -> c n -> c n

-- | Substitute a <a>Type</a> for the <a>Bound</a> corresponding to some
--   <a>Bind</a> in a thing.
substituteTX :: (SubstituteTX c, Ord n) => Bind n -> Type n -> c n -> c n

-- | Wrapper for <a>substituteT</a> to substitute multiple types.
substituteTXs :: (SubstituteTX c, Ord n) => [(Bind n, Type n)] -> c n -> c n

-- | Substitute a <a>Type</a> for a <a>Bound</a> in some thing.
substituteBoundTX :: (SubstituteTX c, Ord n) => Bound n -> Type n -> c n -> c n
instance SubstituteTX Type
instance SubstituteTX Bind
instance SubstituteTX (Witness a)
instance SubstituteTX (Cast a)
instance SubstituteTX (Alt a)
instance SubstituteTX (Exp a)


-- | Capture avoiding substitution of witnesses in expressions.
--   
--   If a binder would capture a variable then it is anonymized to deBruijn
--   form.
module DDC.Core.Transform.SubstituteWX
class SubstituteWX (c :: * -> * -> *)
substituteWithWX :: (SubstituteWX c, Ord n) => Witness a n -> Sub n -> c a n -> c a n

-- | Wrapper for <a>substituteWithWX</a> that determines the set of free
--   names in the type being substituted, and starts with an empty binder
--   stack.
substituteWX :: (Ord n, SubstituteWX c) => Bind n -> Witness a n -> c a n -> c a n

-- | Wrapper for <a>substituteWithWX</a> to substitute multiple things.
substituteWXs :: (Ord n, SubstituteWX c) => [(Bind n, Witness a n)] -> c a n -> c a n
instance SubstituteWX Witness
instance SubstituteWX Cast
instance SubstituteWX Alt
instance SubstituteWX Exp


-- | Capture avoiding substitution of expressions in expressions.
--   
--   If a binder would capture a variable then it is anonymized to deBruijn
--   form.
module DDC.Core.Transform.SubstituteXX
class SubstituteXX (c :: * -> * -> *)
substituteWithXX :: (SubstituteXX c, Ord n) => Exp a n -> Sub n -> c a n -> c a n

-- | Wrapper for <tt>substituteWithX</tt> that determines the set of free
--   names in the expression being substituted, and starts with an empty
--   binder stack.
substituteXX :: (Ord n, SubstituteXX c) => Bind n -> Exp a n -> c a n -> c a n

-- | Wrapper for <tt>substituteX</tt> to substitute multiple expressions.
substituteXXs :: (Ord n, SubstituteXX c) => [(Bind n, Exp a n)] -> c a n -> c a n

-- | Substitute the argument of an application into an expression. Perform
--   type substitution for an <a>XType</a> and witness substitution for an
--   <a>XWitness</a>
substituteXArg :: (Ord n, SubstituteXX c, SubstituteWX c, SubstituteTX (c a)) => Bind n -> Exp a n -> c a n -> c a n

-- | Wrapper for <a>substituteXArgs</a> to substitute multiple arguments.
substituteXArgs :: (Ord n, SubstituteXX c, SubstituteWX c, SubstituteTX (c a)) => [(Bind n, Exp a n)] -> c a n -> c a n
instance SubstituteXX Cast
instance SubstituteXX Alt
instance SubstituteXX Exp


-- | Trim the expressions passed to <tt>weakclo</tt> casts to just those
--   terms that can affect the closure of the body.
module DDC.Core.Transform.Trim

-- | Trim an expression if it is a <tt>weakclo</tt> cast.
--   
--   Non-recursive version. If you want to recursively trim closures, use
--   <tt>transformUpX' (const trimX)</tt>.
trimX :: Ord n => Exp a n -> Exp a n

-- | Trim the expressions of a weaken closure <tt>(XCast
--   CastWeakenClosure)</tt> into only the free variables.
--   
--   For example, <tt>trimClosures [build (k z. something k), else] =
--   [build, something, else] </tt>
trimClosures :: Ord n => a -> [Exp a n] -> [Exp a n]

module DDC.Type.Equiv

-- | Check equivalence of types.
--   
--   Checks equivalence up to alpha-renaming, as well as crushing of
--   effects and trimming of closures.
--   
--   <ul>
--   <li>Return <a>False</a> if we find any free variables.</li>
--   <li>We assume the types are well-kinded, so that the type annotations
--   on bound variables match the binders. If this is not the case then you
--   get an indeterminate result.</li>
--   </ul>
equivT :: Ord n => Type n -> Type n -> Bool

-- | Like <a>equivT</a> but take the initial stacks of type binders.
equivWithBindsT :: Ord n => [Bind n] -> [Bind n] -> Type n -> Type n -> Bool

-- | Check if two <tt>TyCons</tt> are equivalent. We need to handle
--   <a>TyConBound</a> specially incase it's kind isn't attached,
equivTyCon :: Eq n => TyCon n -> TyCon n -> Bool

module DDC.Type.Subsumes

-- | Check whether the first type subsumes the second.
--   
--   Both arguments are converted to sums, and we check that every element
--   of the second sum is equivalent to an element in the first.
--   
--   This only works for well formed types of effect and closure kind.
--   Other types will yield <a>False</a>.
subsumesT :: Ord n => Kind n -> Type n -> Type n -> Bool


-- | Check the kind of a type.
module DDC.Type.Check

-- | Static configuration for the type checker. These fields don't change
--   as we decend into the tree.
--   
--   The starting configuration should be converted from the profile that
--   defines the language fragment you are checking. See
--   <a>DDC.Core.Fragment</a> and use <a>configOfProfile</a> below.
data Config n
Config :: KindEnv n -> TypeEnv n -> DataDefs n -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe (n -> Bool) -> Config n

-- | Kinds of primitive types.
configPrimKinds :: Config n -> KindEnv n

-- | Types of primitive operators.
configPrimTypes :: Config n -> TypeEnv n

-- | Data type definitions.
configDataDefs :: Config n -> DataDefs n

-- | Track effect type information.
configTrackedEffects :: Config n -> Bool

-- | Track closure type information.
configTrackedClosures :: Config n -> Bool

-- | Attach effect information to function types.
configFunctionalEffects :: Config n -> Bool

-- | Attach closure information to function types.
configFunctionalClosures :: Config n -> Bool

-- | Treat effects as capabilities.
configEffectCapabilities :: Config n -> Bool

-- | This name represents some hole in the expression that needs to be
--   filled in by the type checker.
configNameIsHole :: Config n -> Maybe (n -> Bool)

-- | Convert a langage profile to a type checker configuration.
configOfProfile :: Profile n -> Config n

-- | Check a type in the given universe with the given environment Returns
--   the updated type and its classifier (a kind or sort), depeding on the
--   universe of the type being checked.
checkType :: (Ord n, Show n, Pretty n) => Config n -> KindEnv n -> Universe -> Type n -> Either (Error n) (Type n, Type n)

-- | Check a type returning its kind, or a kind returning its sort.
--   
--   The unverse of the thing to check is directly specified, and if the
--   thing is not actually in this universe they you'll get an error.
--   
--   We track what universe the provided kind is in for defence against
--   transform bugs. Types like ([a : [b : Data]. b]. a -&gt; a), should
--   not be accepted by the source parser, but may be created by bogus
--   program transformations. Quantifiers cannot be used at the kind level,
--   so it's better to fail early.
checkTypeM :: (Ord n, Show n, Pretty n) => Config n -> KindEnv n -> Context n -> Universe -> Type n -> Mode n -> CheckM n (Type n, Kind n, Context n)

-- | Check a spec in the given environment, returning an error or its kind.
checkSpec :: (Ord n, Show n, Pretty n) => Config n -> KindEnv n -> Type n -> Either (Error n) (Type n, Kind n)

-- | Check a spec in an empty environment, returning an error or its kind.
kindOfSpec :: (Ord n, Show n, Pretty n) => Config n -> Type n -> Either (Error n) (Kind n)

-- | Check a kind in an empty environment, returning an error or its sort.
sortOfKind :: (Ord n, Show n, Pretty n) => Config n -> Kind n -> Either (Error n) (Sort n)

-- | Take the superkind of an atomic kind constructor.
--   
--   Yields <a>Nothing</a> for the kind function (~&gt;) as it doesn't have
--   a sort without being fully applied.
takeSortOfKiCon :: KiCon -> Maybe (Sort n)

-- | Take the kind of a witness type constructor.
kindOfTwCon :: TwCon -> Kind n

-- | Take the kind of a computation type constructor.
kindOfTcCon :: TcCon -> Kind n

-- | Things that can go wrong when checking the kind of at type.
data Error n

-- | Tried to check a type using the wrong universe, for example: asking
--   for the kind of a kind.
ErrorUniverseMalfunction :: Type n -> Universe -> Error n
errorType :: Error n -> Type n
errorUniverse :: Error n -> Universe

-- | Generic kind mismatch.
ErrorMismatch :: Universe -> Type n -> Type n -> Type n -> Error n
errorUniverse :: Error n -> Universe
errorInferred :: Error n -> Type n
errorExpected :: Error n -> Type n
errorChecking :: Error n -> Type n

-- | An undefined type variable.
ErrorUndefined :: Bound n -> Error n
errorBound :: Error n -> Bound n

-- | Found an unapplied kind function constructor.
ErrorUnappliedKindFun :: Error n

-- | Found a naked sort constructor.
ErrorNakedSort :: Sort n -> Error n
errorSort :: Error n -> Sort n

-- | An undefined type constructor.
ErrorUndefinedTypeCtor :: Bound n -> Error n
errorBound :: Error n -> Bound n

-- | A type application where the thing being applied is not a function.
ErrorAppNotFun :: Type n -> Type n -> Kind n -> Type n -> Error n
errorChecking :: Error n -> Type n
errorFunType :: Error n -> Type n
errorFunTypeKind :: Error n -> Kind n
errorArgType :: Error n -> Type n

-- | A type application where the parameter and argument kinds don't match.
ErrorAppArgMismatch :: Type n -> Type n -> Kind n -> Type n -> Kind n -> Error n
errorChecking :: Error n -> Type n
errorFunType :: Error n -> Type n
errorFunKind :: Error n -> Kind n
errorArgType :: Error n -> Type n
errorArgKind :: Error n -> Kind n

-- | A witness implication where the premise or conclusion has an invalid
--   kind.
ErrorWitnessImplInvalid :: Type n -> Type n -> Kind n -> Type n -> Kind n -> Error n
errorChecking :: Error n -> Type n
errorLeftType :: Error n -> Type n
errorLeftKind :: Error n -> Kind n
errorRightType :: Error n -> Type n
errorRightKind :: Error n -> Kind n

-- | A forall where the body does not have data or witness kind.
ErrorForallKindInvalid :: Type n -> Type n -> Kind n -> Error n
errorChecking :: Error n -> Type n
errorBody :: Error n -> Type n
errorKind :: Error n -> Kind n

-- | A type sum where the components have differing kinds.
ErrorSumKindMismatch :: Kind n -> TypeSum n -> [Kind n] -> Error n
errorKindExpected :: Error n -> Kind n
errorTypeSum :: Error n -> TypeSum n
errorKinds :: Error n -> [Kind n]

-- | A type sum that does not have effect or closure kind.
ErrorSumKindInvalid :: TypeSum n -> Kind n -> Error n
errorCheckingSum :: Error n -> TypeSum n
errorKind :: Error n -> Kind n

-- | Things that can go wrong when checking data type definitions.
data ErrorData n

-- | A duplicate data type constructor name.
ErrorDataDupTypeName :: n -> ErrorData n
errorDataDupTypeName :: ErrorData n -> n

-- | A duplicate data constructor name.
ErrorDataDupCtorName :: n -> ErrorData n
errorDataCtorName :: ErrorData n -> n

-- | A data constructor with the wrong result type.
ErrorDataWrongResult :: n -> Type n -> Type n -> ErrorData n
errorDataCtorName :: ErrorData n -> n
errorDataCtorResultActual :: ErrorData n -> Type n
errorDataCtorResultExpected :: ErrorData n -> Type n

module DDC.Core.Annot.AnT

-- | The type checker for witnesses adds this annotation to every node in
--   the, giving the type of each component of the witness.
data AnT a n
AnT :: (Type n) -> a -> AnT a n
annotType :: AnT a n -> (Type n)
annotTail :: AnT a n -> a
instance Typeable2 AnT
instance (Show a, Show n) => Show (AnT a n)
instance Pretty (AnT a n)
instance (NFData a, NFData n) => NFData (AnT a n)

module DDC.Core.Annot.AnTEC

-- | The type checker adds this annotation to every node in the AST, giving
--   its type, effect and closure.
data AnTEC a n
AnTEC :: (Type n) -> (Effect n) -> (Closure n) -> a -> AnTEC a n
annotType :: AnTEC a n -> (Type n)
annotEffect :: AnTEC a n -> (Effect n)
annotClosure :: AnTEC a n -> (Closure n)
annotTail :: AnTEC a n -> a

-- | Promote an <a>AnT</a> to an <a>AnTEC</a> by filling in the effect and
--   closure portions with bottoms.
fromAnT :: AnT a n -> AnTEC a n
instance Typeable2 AnTEC
instance (Show a, Show n) => Show (AnTEC a n)
instance Pretty (AnTEC a n)
instance (NFData a, NFData n) => NFData (AnTEC a n)


-- | Type checker for the Disciple Core language.
--   
--   The functions in this module do not check for language fragment
--   compliance. This needs to be done separately via
--   <a>DDC.Core.Fragment</a>.
module DDC.Core.Check

-- | Static configuration for the type checker. These fields don't change
--   as we decend into the tree.
--   
--   The starting configuration should be converted from the profile that
--   defines the language fragment you are checking. See
--   <a>DDC.Core.Fragment</a> and use <a>configOfProfile</a> below.
data Config n
Config :: KindEnv n -> TypeEnv n -> DataDefs n -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe (n -> Bool) -> Config n

-- | Kinds of primitive types.
configPrimKinds :: Config n -> KindEnv n

-- | Types of primitive operators.
configPrimTypes :: Config n -> TypeEnv n

-- | Data type definitions.
configDataDefs :: Config n -> DataDefs n

-- | Track effect type information.
configTrackedEffects :: Config n -> Bool

-- | Track closure type information.
configTrackedClosures :: Config n -> Bool

-- | Attach effect information to function types.
configFunctionalEffects :: Config n -> Bool

-- | Attach closure information to function types.
configFunctionalClosures :: Config n -> Bool

-- | Treat effects as capabilities.
configEffectCapabilities :: Config n -> Bool

-- | This name represents some hole in the expression that needs to be
--   filled in by the type checker.
configNameIsHole :: Config n -> Maybe (n -> Bool)

-- | Convert a langage profile to a type checker configuration.
configOfProfile :: Profile n -> Config n

-- | Human readable trace of the type checker.
data CheckTrace
CheckTrace :: Doc -> CheckTrace
checkTraceDoc :: CheckTrace -> Doc

-- | Type check a module.
--   
--   If it's good, you get a new version with types attached to all the
--   bound variables
--   
--   If it's bad, you get a description of the error.
checkModule :: (Ord n, Show n, Pretty n) => Config n -> Module a n -> Mode n -> (Either (Error a n) (Module (AnTEC a n) n), CheckTrace)

-- | What mode we're performing type checking/inference in.
data Mode n

-- | Reconstruct the type of the expression, requiring type annotations on
--   parameters as well as type applications to already be present.
Recon :: Mode n

-- | The ascending smoke of incense. Synthesise the type of the expression,
--   producing unification variables for bidirectional type inference.
Synth :: Mode n

-- | The descending tongue of flame. Check the type of an expression
--   against this expected type, and unify expected types into unification
--   variables for bidirecional type inference.
Check :: (Type n) -> Mode n

-- | Type check an expression.
--   
--   If it's good, you get a new version with types attached every AST
--   node, as well as every binding occurrence of a variable.
--   
--   If it's bad, you get a description of the error.
--   
--   The kinds and types of primitives are added to the environments
--   automatically, you don't need to supply these as part of the starting
--   kind and type environment.
checkExp :: (Ord n, Show n, Pretty n) => Config n -> KindEnv n -> TypeEnv n -> Exp a n -> Mode n -> (Either (Error a n) (Exp (AnTEC a n) n, Type n, Effect n, Closure n), CheckTrace)

-- | Like <a>checkExp</a>, but only return the value type of an expression.
typeOfExp :: (Ord n, Pretty n, Show n) => Config n -> KindEnv n -> TypeEnv n -> Exp a n -> Either (Error a n) (Type n)

-- | Check a witness.
--   
--   If it's good, you get a new version with types attached to all the
--   bound variables, as well as the type of the overall witness.
--   
--   If it's bad, you get a description of the error.
--   
--   The returned expression has types attached to all variable
--   occurrences, so you can call <a>typeOfWitness</a> on any open subterm.
--   
--   The kinds and types of primitives are added to the environments
--   automatically, you don't need to supply these as part of the starting
--   environments.
checkWitness :: (Ord n, Show n, Pretty n) => Config n -> KindEnv n -> TypeEnv n -> Witness a n -> Either (Error a n) (Witness (AnT a n) n, Type n)

-- | Like <a>checkWitness</a>, but check in an empty environment.
--   
--   As this function is not given an environment, the types of free
--   variables must be attached directly to the bound occurrences. This
--   attachment is performed by <a>checkWitness</a> above.
typeOfWitness :: (Ord n, Show n, Pretty n) => Config n -> Witness a n -> Either (Error a n) (Type n)

-- | Take the type of a witness constructor.
typeOfWiCon :: WiCon n -> Type n

-- | The type checker adds this annotation to every node in the AST, giving
--   its type, effect and closure.
data AnTEC a n
AnTEC :: (Type n) -> (Effect n) -> (Closure n) -> a -> AnTEC a n
annotType :: AnTEC a n -> (Type n)
annotEffect :: AnTEC a n -> (Effect n)
annotClosure :: AnTEC a n -> (Closure n)
annotTail :: AnTEC a n -> a

-- | All the things that can go wrong when type checking an expression or
--   witness.
data Error a n

-- | Found a kind error when checking a type.
ErrorType :: Error n -> Error a n
errorTypeError :: Error a n -> Error n

-- | Found an error in the data type definitions.
ErrorData :: ErrorData n -> Error a n
errorData :: Error a n -> ErrorData n

-- | Exported value is undefined.
ErrorExportUndefined :: n -> Error a n
errorName :: Error a n -> n

-- | Exported name is exported multiple times.
ErrorExportDuplicate :: n -> Error a n
errorName :: Error a n -> n

-- | Type signature of exported binding does not match the type at the
--   definition site.
ErrorExportMismatch :: n -> Type n -> Type n -> Error a n
errorName :: Error a n -> n
errorExportType :: Error a n -> Type n
errorDefType :: Error a n -> Type n

-- | Imported name is imported multiple times.
ErrorImportDuplicate :: n -> Error a n
errorName :: Error a n -> n

-- | An imported value that doesn't have kind Data.
ErrorImportValueNotData :: n -> Error a n
errorName :: Error a n -> n

-- | Generic mismatch between expected and inferred types.
ErrorMismatch :: a -> Type n -> Type n -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorInferred :: Error a n -> Type n
errorExpected :: Error a n -> Type n
errorChecking :: Error a n -> Exp a n

-- | An undefined type variable.
ErrorUndefinedVar :: a -> Bound n -> Universe -> Error a n
errorAnnot :: Error a n -> a
errorBound :: Error a n -> Bound n
errorUniverse :: Error a n -> Universe

-- | A data constructor that wasn't in the set of data definitions.
ErrorUndefinedCtor :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n

-- | A function application where the parameter and argument don't match.
ErrorAppMismatch :: a -> Exp a n -> Type n -> Type n -> Error a n
errrorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorParamType :: Error a n -> Type n
errorArgType :: Error a n -> Type n

-- | Tried to apply something that is not a function.
ErrorAppNotFun :: a -> Exp a n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorNotFunType :: Error a n -> Type n

-- | Cannot infer type of polymorphic expression.
ErrorAppCannotInferPolymorphic :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n

-- | A type abstraction that tries to shadow a type variable that is
--   already in the environment.
ErrorLamShadow :: a -> Exp a n -> Bind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBind :: Error a n -> Bind n

-- | An abstraction where the body has a visible side effect that is not
--   supported by the current language fragment.
ErrorLamNotPure :: a -> Exp a n -> Universe -> Effect n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorUniverse :: Error a n -> Universe
errorEffect :: Error a n -> Effect n

-- | An abstraction where the body has a visible closure that is not
--   supported by the current language fragment.
ErrorLamNotEmpty :: a -> Exp a n -> Universe -> Closure n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorUniverse :: Error a n -> Universe
errorClosure :: Error a n -> Closure n

-- | A value function where the parameter does not have data or witness
--   kind.
ErrorLamBindBadKind :: a -> Exp a n -> Type n -> Kind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorType :: Error a n -> Type n
errorKind :: Error a n -> Kind n

-- | An abstraction where the body does not have data kind.
ErrorLamBodyNotData :: a -> Exp a n -> Bind n -> Type n -> Kind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBind :: Error a n -> Bind n
errorType :: Error a n -> Type n
errorKind :: Error a n -> Kind n

-- | A function abstraction without a type annotation on the parameter.
ErrorLamParamUnannotated :: a -> Exp a n -> Bind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBind :: Error a n -> Bind n

-- | A type abstraction without a kind annotation on the parameter.
ErrorLAMParamUnannotated :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n

-- | A type abstraction parameter with a bad sort.
ErrorLAMParamBadSort :: a -> Exp a n -> Bind n -> Sort n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBind :: Error a n -> Bind n
errorSort :: Error a n -> Sort n

-- | A let-expression where the type of the binder does not match the right
--   of the binding.
ErrorLetMismatch :: a -> Exp a n -> Bind n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBind :: Error a n -> Bind n
errorType :: Error a n -> Type n

-- | A let-expression where the right of the binding does not have data
--   kind.
ErrorLetBindingNotData :: a -> Exp a n -> Bind n -> Kind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBind :: Error a n -> Bind n
errorKind :: Error a n -> Kind n

-- | A let-expression where the body does not have data kind.
ErrorLetBodyNotData :: a -> Exp a n -> Type n -> Kind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorType :: Error a n -> Type n
errorKind :: Error a n -> Kind n

-- | A recursive let-expression where the right of the binding is not a
--   lambda abstraction.
ErrorLetrecBindingNotLambda :: a -> Exp a n -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorExp :: Error a n -> Exp a n

-- | A recursive let-binding with a missing type annotation.
ErrorLetrecMissingAnnot :: a -> Bind n -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorBind :: Error a n -> Bind n
errorExp :: Error a n -> Exp a n

-- | A recursive let-expression that has more than one binding with the
--   same name.
ErrorLetrecRebound :: a -> Exp a n -> Bind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBind :: Error a n -> Bind n

-- | A letregion-expression where the some of the bound variables do not
--   have region kind.
ErrorLetRegionsNotRegion :: a -> Exp a n -> [Bind n] -> [Kind n] -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBinds :: Error a n -> [Bind n]
errorKinds :: Error a n -> [Kind n]

-- | A letregion-expression that tried to shadow some pre-existing named
--   region variables.
ErrorLetRegionsRebound :: a -> Exp a n -> [Bind n] -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBinds :: Error a n -> [Bind n]

-- | A letregion-expression where some of the the bound region variables
--   are free in the type of the body.
ErrorLetRegionFree :: a -> Exp a n -> [Bind n] -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBinds :: Error a n -> [Bind n]
errorType :: Error a n -> Type n

-- | A letregion-expression that tried to create a witness with an invalid
--   type.
ErrorLetRegionWitnessInvalid :: a -> Exp a n -> Bind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBind :: Error a n -> Bind n

-- | A letregion-expression that tried to create conflicting witnesses.
ErrorLetRegionWitnessConflict :: a -> Exp a n -> Bind n -> Bind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBindWitness1 :: Error a n -> Bind n
errorBindWitness2 :: Error a n -> Bind n

-- | A letregion-expression where a bound witnesses was not for the the
--   region variable being introduced.
ErrorLetRegionsWitnessOther :: a -> Exp a n -> [Bound n] -> Bind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBoundRegions :: Error a n -> [Bound n]
errorBindWitness :: Error a n -> Bind n

-- | A withregion-expression where the handle does not have region kind.
ErrorWithRegionNotRegion :: a -> Exp a n -> Bound n -> Kind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBound :: Error a n -> Bound n
errorKind :: Error a n -> Kind n

-- | A letregion-expression where some of the the bound region variables
--   are free in the type of the body.
ErrorWithRegionFree :: a -> Exp a n -> Bound n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorBound :: Error a n -> Bound n
errorType :: Error a n -> Type n

-- | A witness application where the argument type does not match the
--   parameter type.
ErrorWAppMismatch :: a -> Witness a n -> Type n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorWitness :: Error a n -> Witness a n
errorParamType :: Error a n -> Type n
errorArgType :: Error a n -> Type n

-- | Tried to perform a witness application with a non-witness.
ErrorWAppNotCtor :: a -> Witness a n -> Type n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorWitness :: Error a n -> Witness a n
errorNotFunType :: Error a n -> Type n
errorArgType :: Error a n -> Type n

-- | An invalid witness join.
ErrorCannotJoin :: a -> Witness a n -> Witness a n -> Type n -> Witness a n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorWitness :: Error a n -> Witness a n
errorWitnessLeft :: Error a n -> Witness a n
errorTypeLeft :: Error a n -> Type n
errorWitnessRight :: Error a n -> Witness a n
errorTypeRight :: Error a n -> Type n

-- | A witness provided for a purify cast that does not witness purity.
ErrorWitnessNotPurity :: a -> Exp a n -> Witness a n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorWitness :: Error a n -> Witness a n
errorType :: Error a n -> Type n

-- | A witness provided for a forget cast that does not witness emptiness.
ErrorWitnessNotEmpty :: a -> Exp a n -> Witness a n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorWitness :: Error a n -> Witness a n
errorType :: Error a n -> Type n

-- | A case-expression where the scrutinee type is not algebraic.
ErrorCaseScrutineeNotAlgebraic :: a -> Exp a n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorTypeScrutinee :: Error a n -> Type n

-- | A case-expression where the scrutinee type is not in our set of data
--   type declarations.
ErrorCaseScrutineeTypeUndeclared :: a -> Exp a n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorTypeScrutinee :: Error a n -> Type n

-- | A case-expression with no alternatives.
ErrorCaseNoAlternatives :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n

-- | A case-expression where the alternatives don't cover all the possible
--   data constructors.
ErrorCaseNonExhaustive :: a -> Exp a n -> [n] -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorCtorNamesMissing :: Error a n -> [n]

-- | A case-expression where the alternatives don't cover all the possible
--   constructors, and the type has too many data constructors to list.
ErrorCaseNonExhaustiveLarge :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n

-- | A case-expression with overlapping alternatives.
ErrorCaseOverlapping :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n

-- | A case-expression where one of the patterns has too many binders.
ErrorCaseTooManyBinders :: a -> Exp a n -> DaCon n -> Int -> Int -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorCtorDaCon :: Error a n -> DaCon n
errorCtorFields :: Error a n -> Int
errorPatternFields :: Error a n -> Int

-- | A case-expression where the pattern types could not be instantiated
--   with the arguments of the scrutinee type.
ErrorCaseCannotInstantiate :: a -> Exp a n -> Type n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorTypeScrutinee :: Error a n -> Type n
errorTypeCtor :: Error a n -> Type n

-- | A case-expression where the type of the scrutinee does not match the
--   type of the pattern.
ErrorCaseScrutineeTypeMismatch :: a -> Exp a n -> Type n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorTypeScrutinee :: Error a n -> Type n
errorTypePattern :: Error a n -> Type n

-- | A case-expression where the annotation on a pattern variable binder
--   does not match the field type of the constructor.
ErrorCaseFieldTypeMismatch :: a -> Exp a n -> Type n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorTypeAnnot :: Error a n -> Type n
errorTypeField :: Error a n -> Type n

-- | A case-expression where the result types of the alternatives are not
--   identical.
ErrorCaseAltResultMismatch :: a -> Exp a n -> Type n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorAltType1 :: Error a n -> Type n
errorAltType2 :: Error a n -> Type n

-- | A weakeff-cast where the type provided does not have effect kind.
ErrorWeakEffNotEff :: a -> Exp a n -> Effect n -> Kind n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorEffect :: Error a n -> Effect n
errorKind :: Error a n -> Kind n

-- | A run cast applied to a non-suspension.
ErrorRunNotSuspension :: a -> Exp a n -> Type n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorType :: Error a n -> Type n

-- | A run cast where the context does not support the suspended effect.
ErrorRunNotSupported :: a -> Exp a n -> Effect n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n
errorEffect :: Error a n -> Effect n

-- | A run cast where we cannot infer the type of the suspended computation
--   and thus cannot check if its effects are suppored by the context.
ErrorRunCannotInfer :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorExp :: Error a n -> Exp a n

-- | Found a naked <a>XType</a> that wasn't the argument of an application.
ErrorNakedType :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n

-- | Found a naked <a>XWitness</a> that wasn't the argument of an
--   application.
ErrorNakedWitness :: a -> Exp a n -> Error a n
errorAnnot :: Error a n -> a
errorChecking :: Error a n -> Exp a n


-- | "Loading" refers to the combination of parsing and type checking. This
--   is the easiest way to turn source tokens into a type-checked abstract
--   syntax tree.
module DDC.Core.Load

-- | The type checker adds this annotation to every node in the AST, giving
--   its type, effect and closure.
data AnTEC a n
AnTEC :: (Type n) -> (Effect n) -> (Closure n) -> a -> AnTEC a n
annotType :: AnTEC a n -> (Type n)
annotEffect :: AnTEC a n -> (Effect n)
annotClosure :: AnTEC a n -> (Closure n)
annotTail :: AnTEC a n -> a

-- | Things that can go wrong when loading a core thing.
data Error n err
ErrorRead :: !String -> Error n err
ErrorParser :: !ParseError -> Error n err
ErrorCheckType :: !(Error n) -> Error n err
ErrorCheckExp :: !(Error SourcePos n) -> Error n err
ErrorCompliance :: !(Error (AnTEC SourcePos n) n) -> Error n err
ErrorFragment :: !(err (AnTEC SourcePos n)) -> Error n err

-- | What mode we're performing type checking/inference in.
data Mode n

-- | Reconstruct the type of the expression, requiring type annotations on
--   parameters as well as type applications to already be present.
Recon :: Mode n

-- | The ascending smoke of incense. Synthesise the type of the expression,
--   producing unification variables for bidirectional type inference.
Synth :: Mode n

-- | The descending tongue of flame. Check the type of an expression
--   against this expected type, and unify expected types into unification
--   variables for bidirecional type inference.
Check :: (Type n) -> Mode n

-- | Human readable trace of the type checker.
data CheckTrace
CheckTrace :: Doc -> CheckTrace
checkTraceDoc :: CheckTrace -> Doc

-- | Parse and type check a core module from a file.
loadModuleFromFile :: (Eq n, Ord n, Show n, Pretty n) => Fragment n err -> FilePath -> Mode n -> IO (Either (Error n err) (Module (AnTEC SourcePos n) n), Maybe CheckTrace)

-- | Parse and type check a core module from a string.
loadModuleFromString :: (Eq n, Ord n, Show n, Pretty n) => Fragment n err -> FilePath -> Int -> Mode n -> String -> (Either (Error n err) (Module (AnTEC SourcePos n) n), Maybe CheckTrace)

-- | Parse and type check a core module from some tokens.
loadModuleFromTokens :: (Eq n, Ord n, Show n, Pretty n) => Fragment n err -> FilePath -> Mode n -> [Token (Tok n)] -> (Either (Error n err) (Module (AnTEC SourcePos n) n), Maybe CheckTrace)

-- | Parse and type-check and expression from a string.
loadExpFromString :: (Eq n, Ord n, Show n, Pretty n) => Fragment n err -> Map ModuleName (Module (AnTEC () n) n) -> FilePath -> Mode n -> String -> (Either (Error n err) (Exp (AnTEC SourcePos n) n), Maybe CheckTrace)

-- | Parse and check an expression returning it along with its spec, effect
--   and closure
loadExpFromTokens :: (Eq n, Ord n, Show n, Pretty n) => Fragment n err -> Map ModuleName (Module (AnTEC () n) n) -> FilePath -> Mode n -> [Token (Tok n)] -> (Either (Error n err) (Exp (AnTEC SourcePos n) n), Maybe CheckTrace)

-- | Parse and check a type from a string, returning it along with its
--   kind.
loadTypeFromString :: (Eq n, Ord n, Show n, Pretty n) => Fragment n err -> Universe -> FilePath -> String -> Either (Error n err) (Type n, Kind n)

-- | Parse and check a type from some tokens, returning it along with its
--   kind.
loadTypeFromTokens :: (Eq n, Ord n, Show n, Pretty n) => Fragment n err -> Universe -> FilePath -> [Token (Tok n)] -> Either (Error n err) (Type n, Kind n)

-- | Parse and check a witness from a string, returning it along with its
--   kind.
loadWitnessFromString :: (Eq n, Ord n, Show n, Pretty n) => Fragment n err -> FilePath -> String -> Either (Error n err) (Witness (AnT SourcePos n) n, Type n)

-- | Parse and check a witness from some tokens, returning it along with
--   its type.
loadWitnessFromTokens :: (Eq n, Ord n, Show n, Pretty n) => Fragment n err -> FilePath -> [Token (Tok n)] -> Either (Error n err) (Witness (AnT SourcePos n) n, Type n)
instance (Eq n, Show n, Pretty n, Pretty (err (AnTEC SourcePos n))) => Pretty (Error n err)
