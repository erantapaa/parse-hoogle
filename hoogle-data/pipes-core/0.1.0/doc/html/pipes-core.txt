-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compositional pipelines
--   
--   This library offers an abstraction similar in scope to
--   iteratees/enumerators/enumeratees, but with different characteristics
--   and naming conventions.
--   
--   This package is a fork of the original pipes package by Gabriel
--   Gonzalez. See
--   <a>https://github.com/pcapriotti/pipes-core/wiki/pipes-core-vs-pipes</a>
--   for a comparison between the two packages.
--   
--   Differences with traditional iteratees:
--   
--   <ul>
--   <li><i>Simpler semantics</i>: There is only one data type
--   (<a>Pipe</a>), two basic primitives (<a>await</a> and <a>yield</a>),
--   and only one way to compose <a>Pipe</a>s (<a>&gt;+&gt;</a>). In fact,
--   (<a>&gt;+&gt;</a>) is just convenient syntax for the composition
--   operator in <a>Category</a>. Most pipes can be implemented just using
--   the <a>Monad</a> instance and composition.</li>
--   <li><i>Different naming conventions</i>: Enumeratees are called
--   <a>Pipe</a>s, Enumerators are <a>Producer</a>s, and Iteratees are
--   <a>Consumer</a>s. <a>Producer</a>s and <a>Consumer</a>s are just type
--   synonyms for <a>Pipe</a>s with either the input or output end
--   closed.</li>
--   <li><i>Pipes form a Category</i>: that means that composition is
--   associative, and that there is an identity <a>Pipe</a>.</li>
--   <li><i>"Vertical" concatenation works on every 'Pipe'</i>:
--   (<a>&gt;&gt;</a>), concatenates <a>Pipe</a>s. Since everything is a
--   <a>Pipe</a>, you can use it to concatenate <a>Producer</a>s,
--   <a>Consumer</a>s, and even intermediate <a>Pipe</a> stages. Vertical
--   concatenation can be combined with composition to create elaborate
--   combinators, without the need of executing pipes in "passes" or
--   resuming partially executed pipes.</li>
--   </ul>
--   
--   Check out <a>Control.Pipe</a> for a copious introduction (in the
--   spirit of the <tt>iterIO</tt> library), and
--   <a>Control.Pipe.Combinators</a> for some basic combinators and
--   <a>Pipe</a> examples.
@package pipes-core
@version 0.1.0


-- | This module contains Multiplicative and Comultiplicative type classes,
--   which provide a generalization of <tt>splitP</tt> and <tt>joinP</tt>
--   to arbitrary monoidal categories.
module Control.Category.Multiplicative

-- | Monoidal category with a multiplication natural transformation.
--   
--   A multiplicative structure on <tt>k</tt> is the same thing as a monoid
--   object structure on the identity functor, when End(k) is given the
--   pointwise monoidal structure.
--   
--   Laws:
--   
--   <pre>
--   first unit . mult = idl
--   second unit . mult = idr
--   mult . first mult = mult . second mult . associate
--   </pre>
class Monoidal k p => Multiplicative k p
unit :: Multiplicative k p => k (Id k p) a
mult :: Multiplicative k p => k (p a a) a

-- | Comonoidal category with a comultiplication natural transformation.
--   
--   A comultiplicative structure on <tt>k</tt> is the same thing as a
--   coalgebra object structure on the identity functor, when End(k) is
--   given the pointwise comonoidal structure.
--   
--   Laws:
--   
--   <pre>
--   first counit . comult = coidl
--   second counit . comult = coidr
--   first diag . diag = disassociate . second diag . diag
--   </pre>
class Monoidal k p => Comultiplicative k p
counit :: Comultiplicative k p => k a (Id k p)
comult :: Comultiplicative k p => k a (p a a)

module Control.Pipe.Common

-- | The base type for pipes.
--   
--   <ul>
--   <li><i><tt>a</tt></i> The type of input received fom upstream
--   pipes.</li>
--   <li><i><tt>b</tt></i> The type of output delivered to downstream
--   pipes.</li>
--   <li><i><tt>m</tt></i> The base monad.</li>
--   <li><i><tt>r</tt></i> The type of the monad's final result.</li>
--   </ul>
data Pipe a b m r
Pure :: r -> (Finalizer m) -> Pipe a b m r
Throw :: SomeException -> (Finalizer m) -> Pipe a b m r
Await :: (a -> Pipe a b m r) -> (SomeException -> Pipe a b m r) -> Pipe a b m r
M :: MaskState -> (m (Pipe a b m r)) -> (SomeException -> Pipe a b m r) -> Pipe a b m r
Yield :: b -> (Pipe a b m r) -> (Finalizer m) -> Pipe a b m r

-- | A pipe that can only produce values.
type Producer b m = Pipe () b m

-- | A pipe that can only consume values.
type Consumer a m = Pipe a Void m

-- | A self-contained pipeline that is ready to be run.
type Pipeline m = Pipe () Void m
data Void :: *

-- | Wait for input from upstream within the <a>Pipe</a> monad.
--   
--   <a>await</a> blocks until input is ready.
await :: Monad m => Pipe a b m a

-- | Pass output downstream within the <a>Pipe</a> monad.
--   
--   <a>yield</a> blocks until the downstream pipe calls <a>await</a>
--   again.
yield :: Monad m => b -> Pipe a b m ()

-- | Execute an action in the base monad with asynchronous exceptions
--   masked.
--   
--   This function is effective only if the <a>Pipeline</a> is run with
--   <a>runPipe</a>, otherwise it is identical to <a>lift</a>
masked :: Monad m => m r -> Pipe a b m r

-- | Convert a pure function into a pipe.
--   
--   <pre>
--   pipe = forever $ do
--     x &lt;- await
--     yield (f x)
--   </pre>
pipe :: Monad m => (a -> b) -> Pipe a b m r

-- | The identity pipe.
idP :: Monad m => Pipe a a m r

-- | The <a>discard</a> pipe silently discards all input fed to it.
discard :: Monad m => Pipe a b m r

-- | Left to right pipe composition.
(>+>) :: Monad m => Pipe a b m r -> Pipe b c m r -> Pipe a c m r

-- | Right to left pipe composition.
(<+<) :: Monad m => Pipe b c m r -> Pipe a b m r -> Pipe a c m r

-- | Run a self-contained <a>Pipeline</a>, converting it to an action in
--   the base monad.
--   
--   This function is exception-safe. Any exception thrown in the base
--   monad during execution of the pipeline will be captured by
--   <a>catch</a> statements in the <a>Pipe</a> monad.
runPipe :: MonadBaseControl IO m => Pipeline m r -> m r

-- | Run a self-contained pipeline over an arbitrary monad, with fewer
--   exception-safety guarantees than <a>runPipe</a>.
--   
--   Only pipe termination exceptions and exceptions thrown using
--   <a>throw</a> will be catchable within the <a>Pipe</a> monad. Any other
--   exception will terminate execution immediately and finalizers will not
--   be called.
--   
--   Any captured exception will be returned in the left component of the
--   result.
runPurePipe :: Monad m => Pipeline m r -> m (Either SomeException r)

-- | A version of <a>runPurePipe</a> which rethrows any captured exception
--   instead of returning it.
runPurePipe_ :: Monad m => Pipeline m r -> m r

-- | The <a>BrokenPipe</a> exception is used to signal termination of the
--   upstream portion of a <a>Pipeline</a> before the current pipe
--   
--   A <a>BrokenPipe</a> exception can be caught to perform cleanup actions
--   immediately before termination, like returning a result or yielding
--   additional values.
data BrokenPipe

-- | Type of action in the base monad.
data MaskState

-- | Action to be run with asynchronous exceptions masked.
Masked :: MaskState

-- | Action to be run with asynchronous exceptions unmasked.
Unmasked :: MaskState

-- | Throw an exception within the <a>Pipe</a> monad.
throwP :: Monad m => SomeException -> Pipe a b m r

-- | Catch an exception within the pipe monad.
catchP :: Monad m => Pipe a b m r -> (SomeException -> Pipe a b m r) -> Pipe a b m r

-- | Execute an action in the base monad with the given <a>MaskState</a>.
liftP :: Monad m => MaskState -> m r -> Pipe a b m r
instance Typeable BrokenPipe
instance Show BrokenPipe
instance MonadIO m => MonadIO (Pipe a b m)
instance MonadTrans (Pipe a b)
instance Monad m => Applicative (Pipe a b m)
instance Monad m => Functor (Pipe a b m)
instance Monad m => Monad (Pipe a b m)
instance Exception BrokenPipe

module Control.Pipe.Monoidal

-- | Create a <a>Pipe</a> that behaves like the given <a>Pipe</a> of the
--   left component of the input, and lets values in the right component
--   pass through.
firstP :: Monad m => Pipe a b m r -> Pipe (Either a c) (Either b c) m r

-- | This function is the equivalent of <a>firstP</a> for the right
--   component.
secondP :: Monad m => Pipe a b m r -> Pipe (Either c a) (Either c b) m r

-- | Combine two pipes into a single pipe that behaves like the first on
--   the left component, and the second on the right component.
(***) :: Monad m => Pipe a b m r -> Pipe a' b' m r -> Pipe (Either a a') (Either b b') m r

-- | Convert between the two possible associations of a triple sum.
associateP :: Monad m => Pipe (Either (Either a b) c) (Either a (Either b c)) m r

-- | Inverse of <a>associateP</a>.
disassociateP :: Monad m => Pipe (Either a (Either b c)) (Either (Either a b) c) m r

-- | Discard all values on the left component.
discardL :: Monad m => Pipe (Either x a) a m r

-- | Discard all values on the right component.
discardR :: Monad m => Pipe (Either a x) a m r

-- | Swap the left and right components.
swapP :: Monad m => Pipe (Either a b) (Either b a) m r

-- | Yield both components of input values into the output.
joinP :: Monad m => Pipe (Either a a) a m r

-- | Yield all input values into both the left and right components of the
--   output.
splitP :: Monad m => Pipe a (Either a a) m r

-- | The <a>loopP</a> combinator allows to create <a>Pipe</a>s whose output
--   value is fed back to the <a>Pipe</a> as input.
loopP :: Monad m => Pipe (Either a c) (Either b c) m r -> Pipe a b m r

module Control.Pipe.Category

-- | Category of pipes.
--   
--   Composition corresponds to <a>&lt;+&lt;</a> and identity to
--   <a>idP</a>.
newtype PipeC m r a b
PipeC :: Pipe a b m r -> PipeC m r a b
unPipeC :: PipeC m r a b -> Pipe a b m r

-- | Identity-on-objects functor.
--   
--   This is part of the interface of Arrow.
class Category k => IFunctor k
arr :: IFunctor k => (a -> b) -> k a b
instance Monad m => Multiplicative (PipeC m r) Either
instance Monad m => Comultiplicative (PipeC m r) Either
instance Monad m => Symmetric (PipeC m r) Either
instance Monad m => Braided (PipeC m r) Either
instance Monad m => Monoidal (PipeC m r) Either
instance Monad m => Associative (PipeC m r) Either
instance Monad m => Bifunctor Either (PipeC m r) (PipeC m r) (PipeC m r)
instance Monad m => QFunctor Either (PipeC m r) (PipeC m r)
instance Monad m => PFunctor Either (PipeC m r) (PipeC m r)
instance Monad m => IFunctor (PipeC m r)
instance Monad m => Category (PipeC m r)

module Control.Pipe.Exception

-- | Throw an exception within the <a>Pipe</a> monad.
--   
--   An exception thrown with <a>throw</a> can be caught by <a>catch</a>
--   with any base monad.
--   
--   If the exception is not caught in the <a>Pipeline</a> at all, it will
--   be rethrown as a normal Haskell exception when using <a>runPipe</a>.
--   Note that <a>runPurePipe</a> returns the exception in an <a>Either</a>
--   value, instead.
throw :: (Monad m, Exception e) => e -> Pipe a b m r

-- | Catch an exception within the <a>Pipe</a> monad.
--   
--   This function takes a <a>Pipe</a>, runs it, and if an exception is
--   raised it executes the handler, passing it the value of the exception.
--   Otherwise, the result is returned as normal.
--   
--   For example, given a <a>Pipe</a>:
--   
--   <pre>
--   reader :: Pipe () String IO ()
--   </pre>
--   
--   we can use <a>catch</a> to resume after an exception. For example:
--   
--   <pre>
--   safeReader :: Pipe () (Either SomeException String) IO ()
--   safeReader = catch (reader &gt;+&gt; 'Pipe' Right) $ \e -&gt; do
--     yield $ Left e
--   </pre>
--   
--   Note that only the initial monadic actions contained in a handler are
--   guaranteed to be executed. Anything else is subject to the usual
--   termination rule of <a>Pipe</a>s: if a <a>Pipe</a> at either side
--   terminates, the whole pipeline terminates.
catch :: (Monad m, Exception e) => Pipe a b m r -> (e -> Pipe a b m r) -> Pipe a b m r

-- | Allocate a resource within the base monad, run a <a>Pipe</a>, then
--   ensure the resource is released.
--   
--   The typical example is reading from a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     hClose
--     (\handle -&gt; do
--         line &lt;- lift $ hGetLine handle
--         yield line
--         ...)
--   </pre>
bracket :: Monad m => m r -> (r -> m y) -> (r -> Pipe a b m x) -> Pipe a b m x

-- | A variant of <a>bracket</a> where the return value from the allocation
--   action is not required.
bracket_ :: Monad m => m r -> m y -> Pipe a b m x -> Pipe a b m x

-- | Like <a>bracket</a>, but only performs the "release" action if there
--   was an exception raised by the <a>Pipe</a>.
bracketOnError :: Monad m => m r -> (r -> m y) -> (r -> Pipe a b m x) -> Pipe a b m x

-- | A specialized variant of <a>bracket</a> with just a computation to run
--   afterwards.
finally :: Monad m => Pipe a b m r -> m s -> Pipe a b m r

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the <a>Pipe</a>.
onException :: Monad m => Pipe a b m r -> Pipe a b m s -> Pipe a b m r

module Control.Pipe


-- | Basic pipe combinators.
module Control.Pipe.Combinators

-- | Like <a>await</a>, but returns <tt>Just x</tt> when the upstream pipe
--   yields some value <tt>x</tt>, and <a>Nothing</a> when it terminates.
--   
--   Further calls to <a>tryAwait</a> after upstream termination will keep
--   returning <a>Nothing</a>, whereas calling <a>await</a> will terminate
--   the current pipe immediately.
tryAwait :: Monad m => Pipe a b m (Maybe a)

-- | Execute the specified pipe for each value in the input stream.
--   
--   Any action after a call to <a>forP</a> will be executed when upstream
--   terminates.
forP :: Monad m => (a -> Pipe a b m r) -> Pipe a b m ()

-- | Connect producer to consumer, ignoring producer return value.
($$) :: Monad m => Pipe x a m r' -> Pipe a y m r -> Pipe x y m (Maybe r)

-- | Successively yield elements of a list.
fromList :: Monad m => [a] -> Pipe x a m ()

-- | A fold pipe. Apply a binary function to successive input values and an
--   accumulator, and return the final result.
fold :: Monad m => (b -> a -> b) -> b -> Pipe a x m b

-- | A variation of <a>fold</a> without an initial value for the
--   accumulator. This pipe doesn't return any value if no input values are
--   received.
fold1 :: Monad m => (a -> a -> a) -> Pipe a x m a

-- | Accumulate all input values into a list.
consume :: Monad m => Pipe a x m [a]

-- | Accumulate all input values into a non-empty list.
consume1 :: Monad m => Pipe a x m [a]

-- | Act as an identity for the first <tt>n</tt> values, then terminate.
take :: Monad m => Int -> Pipe a a m ()

-- | Remove the first <tt>n</tt> values from the stream, then act as an
--   identity.
drop :: Monad m => Int -> Pipe a a m r

-- | Act as an identity until as long as inputs satisfy the given
--   predicate. Return the first element that doesn't satisfy the
--   predicate.
takeWhile :: Monad m => (a -> Bool) -> Pipe a a m a

-- | Variation of <a>takeWhile</a> returning <tt>()</tt>.
takeWhile_ :: Monad m => (a -> Bool) -> Pipe a a m ()

-- | Remove inputs as long as they satisfy the given predicate, then act as
--   an identity.
dropWhile :: Monad m => (a -> Bool) -> Pipe a a m r

-- | Yield Nothing when an input satisfying the predicate is received.
intersperse :: Monad m => (a -> Bool) -> Pipe a (Maybe a) m r

-- | Group input values by the given predicate.
groupBy :: Monad m => (a -> a -> Bool) -> Pipe a [a] m r

-- | Remove values from the stream that don't satisfy the given predicate.
filter :: Monad m => (a -> Bool) -> Pipe a a m r

-- | Apply a function with multiple return values to the stream.
pipeList :: Monad m => (a -> [b]) -> Pipe a b m r

-- | A pipe that terminates immediately.
nullP :: Monad m => Pipe a b m ()

-- | Feed an input element to a pipe.
feed :: Monad m => a -> Pipe a b m r -> Pipe a b m r
