-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings to the BLAS library
--   
--   The BLAS (Basic Linear Algebra Subprograms) are routines that provide
--   standard building blocks for performing basic vector and matrix
--   operations. The Level 1 BLAS perform scalar, vector and vector-vector
--   operations, the Level 2 BLAS perform matrix-vector operations, and the
--   Level 3 BLAS perform matrix-matrix operations. Because the BLAS are
--   efficient, portable, and widely available, they are commonly used in
--   the development of high quality linear algebra software, LAPACK for
--   example.
--   
--   For more information, see the Netlib BLAS webpage:
--   <a>http://www.netlib.org/blas/</a>
@package blas
@version 0.7.6


-- | Overloaded interface for mutable and immutable tensors. This module
--   contains the common functionality for the classes in
--   <a>Data.Tensor.Class.ITensor</a> and <a>Data.Tensor.Class.MTensor</a>.
module Data.Tensor.Class

-- | The base class for objects with shapes and indices (i.e. Vector,
--   Matrix, etc.).
class (Ix i, Show i) => Shaped x i | x -> i
shape :: (Shaped x i) => x n e -> i
bounds :: (Shaped x i) => x n e -> (i, i)


-- | Overloaded interface for immutable tensors.
module Data.Tensor.Class.ITensor

-- | A class for immutable tensors.
class (Shaped x i) => ITensor x i e
size :: (ITensor x i e) => x n e -> Int
(//) :: (ITensor x i e) => x n e -> [(i, e)] -> x n e
unsafeAt :: (ITensor x i e) => x n e -> i -> e
unsafeReplace :: (ITensor x i e) => x n e -> [(i, e)] -> x n e
indices :: (ITensor x i e) => x n e -> [i]
elems :: (ITensor x i e) => x n e -> [e]
assocs :: (ITensor x i e) => x n e -> [(i, e)]
tmap :: (ITensor x i e) => (e -> e) -> x n e -> x n e
(*>) :: (ITensor x i e, Num e) => e -> x n e -> x n e
shift :: (ITensor x i e, Num e) => e -> x n e -> x n e

-- | Get the value at the given index. Range-checks the argument.
(!) :: (ITensor x i e) => x n e -> i -> e


-- | Common functionality for the types defined in
--   <a>Data.Matrix.Dense.Class</a> and <a>Data.Matrix.Banded.Class</a>,
--   and a base class for the mutable and immutable matrix classes defined
--   in the submodules of this one.
module Data.Matrix.Class

-- | A base class for objects shaped like matrices.
class (Shaped a (Int, Int)) => MatrixShaped a
herm :: (MatrixShaped a) => a (m, n) e -> a (n, m) e

-- | Get the number of rows in the matrix.
numRows :: (MatrixShaped a) => a mn e -> Int

-- | Get the number of rows in the matrix.
numCols :: (MatrixShaped a) => a mn e -> Int

-- | Indicate whether or not a matrix has the same number of rows and
--   columns.
isSquare :: (MatrixShaped a) => a mn e -> Bool

-- | Indicate whether or not the number of rows is less than or equal to
--   the number of columns.
isFat :: (MatrixShaped a) => a mn e -> Bool

-- | Indicate whether or not the number of rows is greater than or equal to
--   the number of columns.
isTall :: (MatrixShaped a) => a mn e -> Bool

-- | Replaces <tt>(m,n)</tt> with <tt>(n,m)</tt>
flipShape :: (Int, Int) -> (Int, Int)

-- | A class for matrices with an associated type for row, column, and
--   diagonal vector views.
class HasVectorView a :: (* -> * -> *) where { type family VectorView a :: * -> * -> *; }

-- | A class for matrix types that use a matrix internally for storage,
--   <a>Data.Matrix.Banded.Class</a> for example.
class HasMatrixStorage a :: (* -> * -> *) where { type family MatrixStorage a :: * -> * -> *; }

-- | Matrix element storage order.
data OrderEnum
RowMajor :: OrderEnum
ColMajor :: OrderEnum

-- | Exchange <tt>RowMajor</tt> and <tt>ColMajor</tt>.
flipOrder :: OrderEnum -> OrderEnum

-- | Transpose type.
data TransEnum
NoTrans :: TransEnum
ConjTrans :: TransEnum

-- | Exchange <tt>NoTrans</tt> and <tt>ConjTrans</tt>.
flipTrans :: TransEnum -> TransEnum

-- | Lower or upper triangular storage.
data UpLoEnum
Upper :: UpLoEnum
Lower :: UpLoEnum

-- | Exchange <tt>Upper</tt> and <tt>Lower</tt>.
flipUpLo :: UpLoEnum -> UpLoEnum

-- | Diagonal storage.
data DiagEnum
Unit :: DiagEnum
NonUnit :: DiagEnum

-- | Multiplication side.
data SideEnum
LeftSide :: SideEnum
RightSide :: SideEnum

-- | Exchange <tt>LeftSide</tt> and <tt>RigthSide</tt>.
flipSide :: SideEnum -> SideEnum

-- | Vector conjugacy
data ConjEnum
NoConj :: ConjEnum
Conj :: ConjEnum

-- | Exchange <tt>NoConj</tt> and <tt>Conj</tt>.
flipConj :: ConjEnum -> ConjEnum


-- | Hermitian views of matrices.
module Data.Matrix.Herm

-- | A hermitian view of an underlying matrix. The view can either be of
--   the upper or lower triangular part of the matrix. The type arguments
--   are as follows:
--   
--   <ul>
--   <li><tt>a</tt>: the underlyting matrix type.</li>
--   <li><tt>nn</tt>: a phantom type for the shape of the matrix.</li>
--   <li><tt>e</tt>: the element type of the matrix.</li>
--   </ul>
data Herm a nn e
Herm :: UpLoEnum -> (a nn e) -> Herm a nn e

-- | Convert from a base matrix type to a Herm matrix type.
hermFromBase :: UpLoEnum -> a (n, n) e -> Herm a (n, n) e

-- | Convert from a Herm matrix type to a base matrix type.
hermToBase :: Herm a (n, n) e -> (UpLoEnum, a (n, n) e)

-- | Apply a function to the unerlying matrix.
mapHerm :: (a nn e -> b nn' e) -> Herm a nn e -> Herm b nn' e

-- | Construct a lower-triangular hermitian view into a matrix. This also
--   checks to see if the base matrix is square.
hermL :: (MatrixShaped a) => a (n, n) e -> Herm a (n, n) e

-- | Construct an upper-triangular hermitian view into a matrix. This also
--   checks to see if the base matrix is square.
hermU :: (MatrixShaped a) => a (n, n) e -> Herm a (n, n) e

-- | Cast the phantom shape type.
coerceHerm :: Herm a mn e -> Herm a mn' e


-- | Vector operations.
module Data.Elem.BLAS.Level1

-- | Types with vector-vector operations.
class (Elem a) => BLAS1 a
dot :: (BLAS1 a) => ConjEnum -> ConjEnum -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO a
nrm2 :: (BLAS1 a) => Int -> Ptr a -> Int -> IO Double
asum :: (BLAS1 a) => Int -> Ptr a -> Int -> IO Double
iamax :: (BLAS1 a) => Int -> Ptr a -> Int -> IO Int
scal :: (BLAS1 a) => Int -> a -> Ptr a -> Int -> IO ()
swap :: (BLAS1 a) => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
copy :: (BLAS1 a) => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
axpy :: (BLAS1 a) => Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
rotg :: (BLAS1 a) => Ptr a -> Ptr a -> Ptr a -> Ptr a -> IO ()
rot :: (BLAS1 a) => Int -> Ptr a -> Int -> Ptr a -> Int -> Double -> Double -> IO ()
vconj :: (BLAS1 a) => Int -> Ptr a -> Int -> IO ()
acxpy :: (BLAS1 a) => Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
vmul :: (BLAS1 a) => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
vcmul :: (BLAS1 a) => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
vdiv :: (BLAS1 a) => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
vcdiv :: (BLAS1 a) => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
instance BLAS1 (Complex Double)
instance BLAS1 Double


-- | Matrix-Vector operations.
module Data.Elem.BLAS.Level2

-- | Types with matrix-vector operations.
class (BLAS1 a) => BLAS2 a
gemv :: (BLAS2 a) => TransEnum -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
gbmv :: (BLAS2 a) => TransEnum -> Int -> Int -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
trmv :: (BLAS2 a) => UpLoEnum -> TransEnum -> DiagEnum -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tbmv :: (BLAS2 a) => UpLoEnum -> TransEnum -> DiagEnum -> Int -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
trsv :: (BLAS2 a) => UpLoEnum -> TransEnum -> DiagEnum -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tbsv :: (BLAS2 a) => UpLoEnum -> TransEnum -> DiagEnum -> Int -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
hemv :: (BLAS2 a) => UpLoEnum -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hbmv :: (BLAS2 a) => UpLoEnum -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
geru :: (BLAS2 a) => Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
gerc :: (BLAS2 a) => Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
her :: (BLAS2 a) => UpLoEnum -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
her2 :: (BLAS2 a) => UpLoEnum -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
instance BLAS2 (Complex Double)
instance BLAS2 Double


-- | Matrix-Matrix operations.
module Data.Elem.BLAS.Level3

-- | Types with matrix-matrix operations.
class (BLAS2 a) => BLAS3 a
gemm :: (BLAS3 a) => TransEnum -> TransEnum -> Int -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
symm :: (BLAS3 a) => SideEnum -> UpLoEnum -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hemm :: (BLAS3 a) => SideEnum -> UpLoEnum -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
trmm :: (BLAS3 a) => SideEnum -> UpLoEnum -> TransEnum -> DiagEnum -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
trsm :: (BLAS3 a) => SideEnum -> UpLoEnum -> TransEnum -> DiagEnum -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
syrk :: (BLAS3 a) => UpLoEnum -> TransEnum -> Int -> Int -> a -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
syr2k :: (BLAS3 a) => UpLoEnum -> TransEnum -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
herk :: (BLAS3 a) => UpLoEnum -> TransEnum -> Int -> Int -> a -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
her2k :: (BLAS3 a) => UpLoEnum -> TransEnum -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
instance BLAS3 (Complex Double)
instance BLAS3 Double


-- | Type classes for elements with BLAS support.
module Data.Elem.BLAS

-- | The base class for elements.
class (AEq e, Storable e, Fractional e) => Elem e
conjugate :: (Elem e) => e -> e
norm :: (Elem e) => e -> Double
norm1 :: (Elem e) => e -> Double
fromReal :: (Elem e) => Double -> e
maybeToReal :: (Elem e) => e -> Maybe Double

-- | Types with vector-vector operations.
class (Elem a) => BLAS1 a

-- | Types with matrix-vector operations.
class (BLAS1 a) => BLAS2 a

-- | Types with matrix-matrix operations.
class (BLAS2 a) => BLAS3 a


-- | Overloaded interface for mutable tensors. This modules includes
--   tensors which can be <i>read</i> in a monad, <a>ReadTensor</a>, as
--   well as tensors which can be <i>modified</i> in a monad,
--   <a>WriteTensor</a>.
module Data.Tensor.Class.MTensor

-- | Class for mutable read-only tensors.
class (Shaped x i, Monad m) => ReadTensor x i e m | x -> i
getSize :: (ReadTensor x i e m) => x n e -> m Int
unsafeReadElem :: (ReadTensor x i e m) => x n e -> i -> m e
getIndices :: (ReadTensor x i e m) => x n e -> m [i]
getIndices' :: (ReadTensor x i e m) => x n e -> m [i]
getElems :: (ReadTensor x i e m) => x n e -> m [e]
getElems' :: (ReadTensor x i e m) => x n e -> m [e]
getAssocs :: (ReadTensor x i e m) => x n e -> m [(i, e)]
getAssocs' :: (ReadTensor x i e m) => x n e -> m [(i, e)]

-- | Gets the value at the specified index after checking that the argument
--   is in bounds.
readElem :: (ReadTensor x i e m) => x n e -> i -> m e

-- | Class for modifiable mutable tensors.
class (ReadTensor x i e m) => WriteTensor x i e m | x -> m
getMaxSize :: (WriteTensor x i e m) => x n e -> m Int
setZero :: (WriteTensor x i e m, Num e) => x n e -> m ()
setConstant :: (WriteTensor x i e m) => e -> x n e -> m ()
canModifyElem :: (WriteTensor x i e m) => x n e -> i -> m Bool
unsafeWriteElem :: (WriteTensor x i e m) => x n e -> i -> e -> m ()
unsafeModifyElem :: (WriteTensor x i e m) => x n e -> i -> (e -> e) -> m ()
modifyWith :: (WriteTensor x i e m) => (e -> e) -> x n e -> m ()
unsafeSwapElems :: (WriteTensor x i e m) => x n e -> i -> i -> m ()
doConj :: (WriteTensor x i e m, Elem e) => x n e -> m ()
scaleBy :: (WriteTensor x i e m, Num e) => e -> x n e -> m ()
shiftBy :: (WriteTensor x i e m, Num e) => e -> x n e -> m ()

-- | Set the value of the element at the given index.
writeElem :: (WriteTensor x i e m) => x n e -> i -> e -> m ()

-- | Update the value of the element at the given index.
modifyElem :: (WriteTensor x i e m) => x n e -> i -> (e -> e) -> m ()

-- | Swap the values stored at two positions in the tensor.
swapElems :: (WriteTensor x i e m) => x n e -> i -> i -> m ()


-- | Immutable dense vectors.
module Data.Vector.Dense

-- | Immutable dense vectors. The type arguments are as follows:
--   
--   <ul>
--   <li><tt>n</tt>: a phantom type for the dimension of the vector</li>
--   <li><tt>e</tt>: the element type of the vector. Only certain element
--   types are supported.</li>
--   </ul>
data Vector n e

-- | Common functionality for all vector types.
class (Shaped x Int, Elem e) => BaseVector x e
dim :: (BaseVector x e) => x n e -> Int
isConj :: (BaseVector x e) => x n e -> Bool
conjEnum :: (BaseVector x e) => x n e -> ConjEnum
conj :: (BaseVector x e) => x n e -> x n e
coerceVector :: (BaseVector x e) => x n e -> x n' e

-- | Create a vector with the given dimension and elements. The elements
--   given in the association list must all have unique indices, otherwise
--   the result is undefined.
vector :: (BLAS1 e) => Int -> [(Int, e)] -> Vector n e

-- | Create a vector of the given dimension with elements initialized to
--   the values from the list. <tt>listVector n es</tt> is equivalent to
--   <tt>vector n (zip [0..(n-1)] es)</tt>, except that the result is
--   undefined if <tt>length es</tt> is less than <tt>n</tt>.
listVector :: (BLAS1 e) => Int -> [e] -> Vector n e

-- | <tt>zeroVector n</tt> creates a vector of dimension <tt>n</tt> with
--   all values set to zero.
zeroVector :: (BLAS1 e) => Int -> Vector n e

-- | <tt>constantVector n e</tt> creates a vector of dimension <tt>n</tt>
--   with all values set to <tt>e</tt>.
constantVector :: (BLAS1 e) => Int -> e -> Vector n e

-- | <tt>basisVector n i</tt> creates a vector of dimension <tt>n</tt> with
--   zeros everywhere but position <tt>i</tt>, where there is a one.
basisVector :: (BLAS1 e) => Int -> Int -> Vector n e

-- | <tt>subvector x o n</tt> creates a subvector of <tt>x</tt> starting at
--   index <tt>o</tt> and having length <tt>n</tt>.
subvector :: (BLAS1 e) => Vector n e -> Int -> Int -> Vector n' e

-- | <tt>subvectorWithStride s x o n</tt> creates a subvector of <tt>x</tt>
--   starting at index <tt>o</tt>, having length <tt>n</tt> and stride
--   <tt>s</tt>.
subvectorWithStride :: (BLAS1 e) => Int -> Vector n e -> Int -> Int -> Vector n' e

-- | Compute the sum of absolute values of entries in the vector.
sumAbs :: (BLAS1 e) => Vector n e -> Double

-- | Compute the 2-norm of a vector.
norm2 :: (BLAS1 e) => Vector n e -> Double

-- | Get the index and norm of the element with absulte value. Not valid if
--   any of the vector entries are <tt>NaN</tt>. Raises an exception if the
--   vector has length <tt>0</tt>.
whichMaxAbs :: (BLAS1 e) => Vector n e -> (Int, e)

-- | Compute the dot product of two vectors.
(<.>) :: (BLAS1 e) => Vector n e -> Vector n e -> e


-- | An overloaded interface to mutable dense vectors. For vector types
--   than can be used with this interface, see <a>Data.Vector.Dense.IO</a>
--   and <a>Data.Vector.Dense.ST</a>. Many of these functions can also be
--   used with the immutable type defined in <a>Data.Vector.Dense</a>.
module Data.Vector.Dense.Class

-- | Common functionality for all vector types.
class (Shaped x Int, Elem e) => BaseVector x e
dim :: (BaseVector x e) => x n e -> Int
stride :: (BaseVector x e) => x n e -> Int
isConj :: (BaseVector x e) => x n e -> Bool
conjEnum :: (BaseVector x e) => x n e -> ConjEnum
conj :: (BaseVector x e) => x n e -> x n e
coerceVector :: (BaseVector x e) => x n e -> x n' e
unsafeVectorToIOVector :: (BaseVector x e) => x n e -> IOVector n e

-- | Vectors that can be read in a monad.
class (BaseVector x e, BLAS1 e, Monad m, ReadTensor x Int e m) => ReadVector x e m
unsafePerformIOWithVector :: (ReadVector x e m) => x n e -> (IOVector n e -> IO a) -> m a
freezeVector :: (ReadVector x e m) => x n e -> m (Vector n e)
unsafeFreezeVector :: (ReadVector x e m) => x n e -> m (Vector n e)

-- | Vectors that can be created or modified in a monad.
class (ReadVector x e m, WriteTensor x Int e m) => WriteVector x e m
unsafeConvertIOVector :: (WriteVector x e m) => IO (IOVector n e) -> m (x n e)
newVector_ :: (WriteVector x e m) => Int -> m (x n e)
thawVector :: (WriteVector x e m) => Vector n e -> m (x n e)
unsafeThawVector :: (WriteVector x e m) => Vector n e -> m (x n e)

-- | Creates a new vector with the given association list. Unspecified
--   indices will get initialized to zero.
newVector :: (WriteVector x e m) => Int -> [(Int, e)] -> m (x n e)

-- | Creates a new vector of the given dimension with the given elements.
--   If the list has length less than the passed-in dimenson, the tail of
--   the vector will be uninitialized.
newListVector :: (WriteVector x e m) => Int -> [e] -> m (x n e)

-- | Create a zero vector of the specified length.
newZeroVector :: (WriteVector x e m) => Int -> m (x n e)

-- | Create a vector with every element initialized to the same value.
newConstantVector :: (WriteVector x e m) => Int -> e -> m (x n e)

-- | <tt>newBasisVector n i</tt> creates a vector of length <tt>n</tt> that
--   is all zero except for at position <tt>i</tt>, where it equal to one.
newBasisVector :: (WriteVector x e m) => Int -> Int -> m (x n e)

-- | Set every element in the vector to zero.
setZeroVector :: (WriteVector x e m) => x n e -> m ()

-- | Set every element in the vector to a constant.
setConstantVector :: (WriteVector x e m) => e -> x n e -> m ()

-- | <tt>setBasis x i</tt> sets the <tt>i</tt>th coordinate of <tt>x</tt>
--   to <tt>1</tt>, and all other coordinates to <tt>0</tt>. If the vector
--   has been scaled, it is possible that <tt>readVector x i</tt> will not
--   return exactly <tt>1</tt>. See <tt>setElem</tt>.
setBasisVector :: (WriteVector x e m) => Int -> x n e -> m ()

-- | Creates a new vector by copying another one.
newCopyVector :: (ReadVector x e m, WriteVector y e m) => x n e -> m (y n e)

-- | Creates a new vector by copying another one. The returned vector is
--   gauranteed not to be a view into another vector. That is, the returned
--   vector will have <tt>isConj</tt> to be <tt>False</tt>.
newCopyVector' :: (ReadVector x e m, WriteVector y e m) => x n e -> m (y n e)

-- | <tt>copyVector dst src</tt> replaces the values in <tt>dst</tt> with
--   those in source. The operands must be the same shape.
copyVector :: (WriteVector y e m, ReadVector x e m) => y n e -> x n e -> m ()

-- | Swap the values stored in two vectors.
swapVector :: (WriteVector x e m, WriteVector y e m) => x n e -> y n e -> m ()

-- | <tt>subvectorView x o n</tt> creates a subvector view of <tt>x</tt>
--   starting at index <tt>o</tt> and having length <tt>n</tt>.
subvectorView :: (BaseVector x e) => x n e -> Int -> Int -> x n' e

-- | <tt>subvectorViewWithStride s x o n</tt> creates a subvector view of
--   <tt>x</tt> starting at index <tt>o</tt>, having length <tt>n</tt> and
--   stride <tt>s</tt>.
subvectorViewWithStride :: (BaseVector x e) => Int -> x n e -> Int -> Int -> x n' e

-- | Get a new vector with elements with the conjugates of the elements of
--   the given vector
getConjVector :: (ReadVector x e m, WriteVector y e m) => x n e -> m (y n e)

-- | Get a new vector by scaling the elements of another vector by a given
--   value.
getScaledVector :: (ReadVector x e m, WriteVector y e m) => e -> x n e -> m (y n e)

-- | Get a new vector by shifting the elements of another vector by a given
--   value.
getShiftedVector :: (ReadVector x e m, WriteVector y e m) => e -> x n e -> m (y n e)

-- | Conjugate every element of the vector.
doConjVector :: (WriteVector y e m) => y n e -> m ()

-- | Scale every element by the given value.
scaleByVector :: (WriteVector y e m) => e -> y n e -> m ()

-- | Add the given value to every element.
shiftByVector :: (WriteVector y e m) => e -> y n e -> m ()

-- | <tt>getAddVector x y</tt> creates a new vector equal to the sum
--   <tt>x+y</tt>. The operands must have the same dimension.
getAddVector :: (ReadVector x e m, ReadVector y e m, WriteVector z e m) => x n e -> y n e -> m (z n e)

-- | <tt>getSubVector x y</tt> creates a new tensor equal to the difference
--   <tt>x-y</tt>. The operands must have the same dimension.
getSubVector :: (ReadVector x e m, ReadVector y e m, WriteVector z e m) => x n e -> y n e -> m (z n e)

-- | <tt>getMulVector x y</tt> creates a new vector equal to the
--   elementwise product <tt>x*y</tt>. The operands must have the same
--   dimensino
getMulVector :: (ReadVector x e m, ReadVector y e m, WriteVector z e m) => x n e -> y n e -> m (z n e)

-- | <tt>getDivVector x y</tt> creates a new vector equal to the
--   elementwise ratio <tt>x/y</tt>. The operands must have the same shape.
getDivVector :: (ReadVector x e m, ReadVector y e m, WriteVector z e m) => x n e -> y n e -> m (z n e)

-- | <tt>addVector y x</tt> replaces <tt>y</tt> with <tt>y+x</tt>.
addVector :: (WriteVector y e m, ReadVector x e m) => y n e -> x n e -> m ()

-- | <tt>subVector y x</tt> replaces <tt>y</tt> with <tt>y-x</tt>.
subVector :: (WriteVector y e m, ReadVector x e m) => y n e -> x n e -> m ()

-- | <tt>axpyVector alpha x y</tt> replaces <tt>y</tt> with <tt>alpha * x +
--   y</tt>.
axpyVector :: (ReadVector x e m, WriteVector y e m) => e -> x n e -> y n e -> m ()

-- | <tt>mulVector y x</tt> replaces <tt>y</tt> with <tt>y*x</tt>.
mulVector :: (WriteVector y e m, ReadVector x e m) => y n e -> x n e -> m ()

-- | <tt>divVector y x</tt> replaces <tt>y</tt> with <tt>y/x</tt>.
divVector :: (WriteVector y e m, ReadVector x e m) => y n e -> x n e -> m ()

-- | Gets the sum of the absolute values of the vector entries.
getSumAbs :: (ReadVector x e m) => x n e -> m Double

-- | Gets the 2-norm of a vector.
getNorm2 :: (ReadVector x e m) => x n e -> m Double

-- | Gets the index and norm of the element with maximum magnitude. This is
--   undefined if any of the elements are <tt>NaN</tt>. It will throw an
--   exception if the dimension of the vector is 0.
getWhichMaxAbs :: (ReadVector x e m) => x n e -> m (Int, e)

-- | Computes the dot product of two vectors.
getDot :: (ReadVector x e m, ReadVector y e m) => x n e -> y n e -> m e


-- | An overloaded interface for mutable matrices. The type class
--   associates a matrix with a monad type in which operations can be
--   perfomred. The matrices provide access to rows and columns, and can
--   operate via multiplication on dense vectors and matrices.
module Data.Matrix.Class.MMatrix

-- | A type class for mutable matrices associated with a monad. The member
--   functions of the type class do not perform any checks on the validity
--   of shapes or indices, so in general their safe counterparts should be
--   preferred.
class (MatrixShaped a, BLAS3 e, Monad m) => MMatrix a e m
getRows :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> m [x l e]
getCols :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> m [x k e]

-- | Get the given row in a matrix.
getRow :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> Int -> m (x l e)

-- | Get the given column in a matrix.
getCol :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> Int -> m (x k e)

-- | Get a strict list the row vectors in the matrix.
getRows' :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> m [x l e]

-- | Get a strict list of the column vectors in the matrix.
getCols' :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> m [x k e]

-- | Apply to a vector
getApply :: (MMatrix a e m, ReadVector x e m, WriteVector y e m) => a (k, l) e -> x l e -> m (y k e)

-- | Scale and apply to a vector
getSApply :: (MMatrix a e m, ReadVector x e m, WriteVector y e m) => e -> a (k, l) e -> x l e -> m (y k e)

-- | Apply to a matrix
getApplyMat :: (MMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (r, s) e -> b (s, t) e -> m (c (r, t) e)

-- | Scale and apply to a matrix
getSApplyMat :: (MMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => e -> a (r, s) e -> b (s, t) e -> m (c (r, t) e)

-- | Apply to a vector and store the result in another vector
doApply :: (MMatrix a e m, ReadVector x e m, WriteVector y e m) => a (k, l) e -> x l e -> y k e -> m ()

-- | <pre>
--   y := alpha a x + beta y
--   </pre>
doSApplyAdd :: (MMatrix a e m, ReadVector x e m, WriteVector y e m) => e -> a (k, l) e -> x l e -> e -> y k e -> m ()

-- | <pre>
--   x := a x
--   </pre>
doApply_ :: (MMatrix a e m, WriteVector y e m) => a (n, n) e -> y n e -> m ()

-- | <pre>
--   x := alpha a x
--   </pre>
doSApply_ :: (MMatrix a e m, WriteVector y e m) => e -> a (n, n) e -> y n e -> m ()

-- | Apply to a matrix and store the result in another matrix
doApplyMat :: (MMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (r, s) e -> b (s, t) e -> c (r, t) e -> m ()

-- | <pre>
--   c := alpha a b + beta c
--   </pre>
doSApplyAddMat :: (MMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => e -> a (r, s) e -> b (s, t) e -> e -> c (r, t) e -> m ()

-- | <pre>
--   b := a b
--   </pre>
doApplyMat_ :: (MMatrix a e m, WriteMatrix b e m) => a (s, s) e -> b (s, t) e -> m ()

-- | <pre>
--   b := alpha a b
--   </pre>
doSApplyMat_ :: (MMatrix a e m, WriteMatrix b e m) => e -> a (s, s) e -> b (s, t) e -> m ()


-- | An overloaded interface to mutable dense matrices. For matrix types
--   than can be used with this interface, see <a>Data.Matrix.Dense.IO</a>
--   and <a>Data.Matrix.Dense.ST</a>. Many of these functions can also be
--   used with the immutable type defined in <a>Data.Matrix.Dense</a>.
module Data.Matrix.Dense.Class

-- | Common functionality for all dense matrix types.
class (HasVectorView a, Elem e, MatrixShaped a, BaseVector (VectorView a) e) => BaseMatrix a e
ldaMatrix :: (BaseMatrix a e) => a (n, p) e -> Int
transEnumMatrix :: (BaseMatrix a e) => a (n, p) e -> TransEnum
isHermMatrix :: (BaseMatrix a e) => a (n, p) e -> Bool
coerceMatrix :: (BaseMatrix a e) => a np e -> a np' e
maybeViewMatrixAsVector :: (BaseMatrix a e) => a (n, p) e -> Maybe (VectorView a np e)
maybeViewVectorAsRow :: (BaseMatrix a e) => VectorView a p e -> Maybe (a (one, p) e)
maybeViewVectorAsCol :: (BaseMatrix a e) => VectorView a n e -> Maybe (a (n, one) e)
maybeViewVectorAsMatrix :: (BaseMatrix a e) => (Int, Int) -> VectorView a np e -> Maybe (a (n, p) e)
unsafeMatrixToIOMatrix :: (BaseMatrix a e) => a (n, p) e -> IOMatrix (n, p) e

-- | Dense matrices that can be read in a monad.
class (BaseMatrix a e, BLAS3 e, ReadTensor a (Int, Int) e m, MMatrix a e m, MMatrix (Herm a) e m, MMatrix (Tri a) e m, MSolve (Tri a) e m, ReadVector (VectorView a) e m) => ReadMatrix a e m
unsafePerformIOWithMatrix :: (ReadMatrix a e m) => a (n, p) e -> (IOMatrix (n, p) e -> IO r) -> m r
freezeMatrix :: (ReadMatrix a e m) => a (n, p) e -> m (Matrix (n, p) e)
unsafeFreezeMatrix :: (ReadMatrix a e m) => a (n, p) e -> m (Matrix (n, p) e)

-- | Dense matrices that can be created or modified in a monad.
class (ReadMatrix a e m, WriteTensor a (Int, Int) e m, WriteVector (VectorView a) e m) => WriteMatrix a e m
newMatrix_ :: (WriteMatrix a e m) => (Int, Int) -> m (a (n, p) e)
unsafeConvertIOMatrix :: (WriteMatrix a e m) => IO (IOMatrix (n, p) e) -> m (a (n, p) e)
thawMatrix :: (WriteMatrix a e m) => Matrix (n, p) e -> m (a (n, p) e)
unsafeThawMatrix :: (WriteMatrix a e m) => Matrix (n, p) e -> m (a (n, p) e)

-- | Creates a new matrix with the given association list. Unspecified
--   indices will get initialized to zero.
newMatrix :: (WriteMatrix a e m) => (Int, Int) -> [((Int, Int), e)] -> m (a (n, p) e)

-- | Create a new matrix with the given elements in column-major order.
newListMatrix :: (WriteMatrix a e m) => (Int, Int) -> [e] -> m (a (n, p) e)

-- | Form a matrix from a list of row vectors.
newRowsMatrix :: (ReadVector x e m, WriteMatrix a e m) => (Int, Int) -> [x p e] -> m (a (n, p) e)

-- | Form a matrix from a list of column vectors.
newColsMatrix :: (ReadVector x e m, WriteMatrix a e m) => (Int, Int) -> [x n e] -> m (a (n, p) e)

-- | Create a new matrix from a row vector.
newRowMatrix :: (ReadVector x e m, WriteMatrix a e m) => x p e -> m (a (one, p) e)

-- | Create a new matrix from a column vector.
newColMatrix :: (ReadVector x e m, WriteMatrix a e m) => x n e -> m (a (n, one) e)

-- | Create a zero matrix of the specified shape.
newZeroMatrix :: (WriteMatrix a e m) => (Int, Int) -> m (a (n, p) e)

-- | Set every element in the matrix to zero.
setZeroMatrix :: (WriteMatrix a e m) => a (n, p) e -> m ()

-- | Create a constant matrix of the specified shape.
newConstantMatrix :: (WriteMatrix a e m) => (Int, Int) -> e -> m (a (n, p) e)

-- | Set every element in the matrix to the given constant.
setConstantMatrix :: (WriteMatrix a e m) => e -> a (n, p) e -> m ()

-- | Create a new matrix of the given shape with ones along the diagonal,
--   and zeros everywhere else.
newIdentityMatrix :: (WriteMatrix a e m) => (Int, Int) -> m (a (n, p) e)

-- | Set diagonal elements to one and all other elements to zero.
setIdentityMatrix :: (WriteMatrix a e m) => a (n, p) e -> m ()

-- | Get a copy of a matrix.
newCopyMatrix :: (ReadMatrix a e m, WriteMatrix b e m) => a (n, p) e -> m (b (n, p) e)

-- | Get a copy of a matrix and make sure the returned matrix is not a
--   view. Specififially, the returned matrix will have
--   <tt>isHermMatrix</tt> equal to <tt>False</tt>.
newCopyMatrix' :: (ReadMatrix a e m, WriteMatrix b e m) => a (n, p) e -> m (b (n, p) e)

-- | <tt>copyMatrix dst src</tt> replaces the values in <tt>dst</tt> with
--   those in source. The operands must be the same shape.
copyMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()

-- | <tt>swapMatrix x y</tt> swaps the values stored in two matrices.
swapMatrix :: (WriteMatrix a e m, WriteMatrix b e m) => a (n, p) e -> b (n, p) e -> m ()

-- | Swap the elements in two rows of a matrix.
swapRows :: (WriteMatrix a e m) => a (n, p) e -> Int -> Int -> m ()

-- | Swap the elements in two columns of a matrix.
swapCols :: (WriteMatrix a e m) => a (n, p) e -> Int -> Int -> m ()

-- | <tt>submatrixView a ij mn</tt> returns a view of the submatrix of
--   <tt>a</tt> with element <tt>(0,0)</tt> being element <tt>ij</tt> in
--   <tt>a</tt>, and having shape <tt>mn</tt>.
submatrixView :: (BaseMatrix a e) => a (n, p) e -> (Int, Int) -> (Int, Int) -> a (n', p') e

-- | Divide the rows of a matrix into two blocks and return views into the
--   blocks. The integer argument indicates how many rows should be in the
--   first block.
splitRowsAt :: (BaseMatrix a e) => Int -> a (n, p) e -> (a (n1, p) e, a (n2, p) e)

-- | Divide the columns of a matrix into two blocks and return views into
--   the blocks. The integer argument indicates how many columns should be
--   in the first block.
splitColsAt :: (BaseMatrix a e) => Int -> a (n, p) e -> (a (n, p1) e, a (n, p2) e)

-- | Get a list of vector views of the rows of the matrix.
rowViews :: (BaseMatrix a e) => a (n, p) e -> [VectorView a p e]

-- | Get a list of vector views of the columns of the matrix.
colViews :: (BaseMatrix a e) => a (n, p) e -> [VectorView a n e]

-- | Get a vector view of the given row in a matrix.
rowView :: (BaseMatrix a e) => a (n, p) e -> Int -> VectorView a p e

-- | Get a vector view of the given column in a matrix.
colView :: (BaseMatrix a e) => a (n, p) e -> Int -> VectorView a n e

-- | Get a vector view of the given diagonal in a matrix.
diagView :: (BaseMatrix a e) => a (n, p) e -> Int -> VectorView a k e

-- | Take a unary elementwise vector operation and apply it to the elements
--   of a matrix.
liftMatrix :: (ReadMatrix a e m) => (forall k. VectorView a k e -> m ()) -> a (n, p) e -> m ()

-- | Take a binary elementwise vector operation and apply it to the
--   elements of a pair of matrices.
liftMatrix2 :: (ReadMatrix a e m, ReadMatrix b f m) => (forall k. VectorView a k e -> VectorView b k f -> m ()) -> a (n, p) e -> b (n, p) f -> m ()

-- | Get the given diagonal in a matrix. Negative indices correspond to
--   sub-diagonals.
getDiag :: (ReadMatrix a e m, WriteVector y e m) => a (n, p) e -> Int -> m (y k e)

-- | Get a new matrix with elements with the conjugates of the elements of
--   the given matrix.
getConjMatrix :: (ReadMatrix a e m, WriteMatrix b e m) => a (n, p) e -> m (b (n, p) e)

-- | Get a new matrix by scaling the elements of another matrix by a given
--   value.
getScaledMatrix :: (ReadMatrix a e m, WriteMatrix b e m) => e -> a (n, p) e -> m (b (n, p) e)

-- | Get a new matrix by shifting the elements of another matrix by a given
--   value.
getShiftedMatrix :: (ReadMatrix a e m, WriteMatrix b e m) => e -> a (n, p) e -> m (b (n, p) e)

-- | Conjugate every element of a matrix.
doConjMatrix :: (WriteMatrix a e m) => a (n, p) e -> m ()

-- | Scale every element of a matrix by the given value.
scaleByMatrix :: (WriteMatrix a e m) => e -> a (n, p) e -> m ()

-- | Add a constant to every element in a matrix.
shiftByMatrix :: (WriteMatrix a e m) => e -> a (n, p) e -> m ()

-- | <tt>getAddMatrix a b</tt> creates a new matrix equal to the sum
--   <tt>a+b</tt>. The operands must have the same shape.
getAddMatrix :: (ReadMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (n, p) e -> b (n, p) e -> m (c (n, p) e)

-- | <tt>getSubMatrix a b</tt> creates a new matrix equal to the difference
--   <tt>a-b</tt>. The operands must have the same shape.
getSubMatrix :: (ReadMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (n, p) e -> b (n, p) e -> m (c (n, p) e)

-- | <tt>getMulMatrix a b</tt> creates a new matrix equal to the
--   elementwise product <tt>a*b</tt>. The operands must have the same
--   shape.
getMulMatrix :: (ReadMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (n, p) e -> b (n, p) e -> m (c (n, p) e)

-- | <tt>getDivMatrix a b</tt> creates a new matrix equal to the
--   elementwise ratio <tt>a/b</tt>. The operands must have the same shape.
getDivMatrix :: (ReadMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (n, p) e -> b (n, p) e -> m (c (n, p) e)

-- | Replace the first argument with the elementwise sum.
addMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()

-- | Replace the first argument with the elementwise sum.
subMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()

-- | <tt>axpyMatrix a x y</tt> replaces <tt>y := a x + y</tt>.
axpyMatrix :: (ReadMatrix a e m, WriteMatrix b e m) => e -> a (n, p) e -> b (n, p) e -> m ()

-- | Replace the first argument with the elementwise product.
mulMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()

-- | Replace the first argument with the elementwise quotient.
divMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()


-- | Mutable dense matrices in the IO monad.
module Data.Matrix.Dense.IO

-- | Dense matrix in the <a>IO</a> monad. The type arguments are as
--   follows:
--   
--   <ul>
--   <li><tt>np</tt>: a phantom type for the shape of the matrix. Most
--   functions will demand that this be specified as a pair. When writing a
--   function signature, you should always prefer <tt>IOMatrix (n,p) e</tt>
--   to <tt>IOMatrix np e</tt>.</li>
--   <li><tt>e</tt>: the element type of the matrix. Only certain element
--   types are supported.</li>
--   </ul>
data IOMatrix np e

-- | Perform an <a>IO</a> action with a pointer to the first element of the
--   matrix.
withIOMatrix :: IOMatrix (n, p) e -> (Ptr e -> IO a) -> IO a

-- | View an array in memory as a matrix.
matrixViewArray :: (Elem e) => ForeignPtr e -> Int -> (Int, Int) -> IOMatrix (n, p) e

-- | View an array in memory as a matrix, with the given leading dimension
--   size.
matrixViewArrayWithLda :: (Elem e) => Int -> ForeignPtr e -> Int -> (Int, Int) -> IOMatrix (n, p) e


-- | An overloaded interface for solving matrix systems in a monad. The
--   matrices can operate via inverse multiplication on immutable dense
--   vectors and matrices.
module Data.Matrix.Class.MSolve

-- | A type class for mutable matrices with inverses. The member functions
--   of the type class do not perform any checks on the validity of shapes
--   or indices, so in general their safe counterparts should be preferred.
class (MatrixShaped a, BLAS3 e, Monad m) => MSolve a e m

-- | Return <tt>x</tt> such that <tt>a x = y</tt>.
getSolve :: (MSolve a e m, ReadVector y e m, WriteVector x e m) => a (k, l) e -> y k e -> m (x l e)

-- | Return <tt>b</tt> such that <tt>a b = c</tt>.
getSolveMat :: (MSolve a e m, ReadMatrix c e m, WriteMatrix b e m) => a (r, s) e -> c (r, t) e -> m (b (s, t) e)

-- | Return <tt>x</tt> such that <tt>a x = alpha y</tt>.
getSSolve :: (MSolve a e m, ReadVector y e m, WriteVector x e m) => e -> a (k, l) e -> y k e -> m (x l e)

-- | Return <tt>b</tt> such that <tt>a b = alpha c</tt>.
getSSolveMat :: (MSolve a e m, ReadMatrix c e m, WriteMatrix b e m) => e -> a (r, s) e -> c (r, t) e -> m (b (s, t) e)

-- | Set <tt>x := a^{-1} y</tt>.
doSolve :: (MSolve a e m, ReadVector y e m, WriteVector x e m) => a (r, s) e -> y r e -> x s e -> m ()

-- | Set <tt>b := a^{-1} c</tt>.
doSolveMat :: (MSolve a e m, ReadMatrix c e m, WriteMatrix b e m) => a (r, s) e -> c (r, t) e -> b (s, t) e -> m ()

-- | Set <tt>x := a^{-1} (alpha y)</tt>.
doSSolve :: (MSolve a e m, ReadVector y e m, WriteVector x e m) => e -> a (k, l) e -> y k e -> x l e -> m ()

-- | Set <tt>b := a^{-1} (alpha c)</tt>.
doSSolveMat :: (MSolve a e m, ReadMatrix c e m, WriteMatrix b e m) => e -> a (r, s) e -> c (r, t) e -> b (s, t) e -> m ()

-- | Set <tt>x := a^{-1} x</tt>.
doSolve_ :: (MSolve a e m, ReadVector y e m, WriteVector x e m) => a (k, k) e -> x k e -> m ()

-- | Set <tt>b := a^{-1} b</tt>.
doSolveMat_ :: (MSolve a e m, WriteMatrix b e m) => a (k, k) e -> b (k, l) e -> m ()

-- | Set <tt>x := a^{-1} (alpha x)</tt>.
doSSolve_ :: (MSolve a e m, WriteVector x e m) => e -> a (k, k) e -> x k e -> m ()

-- | Set <tt>b := a^{-1} (alpha b)</tt>.
doSSolveMat_ :: (MSolve a e m, WriteMatrix b e m) => e -> a (k, k) e -> b (k, l) e -> m ()


-- | Mutable vectors in the IO monad.
module Data.Vector.Dense.IO

-- | Dense vectors in the <a>IO</a> monad. The type arguments are as
--   follows:
--   
--   <ul>
--   <li><tt>n</tt>: a phantom type for the dimension of the vector</li>
--   <li><tt>e</tt>: the element type of the vector. Only certain element
--   types are supported.</li>
--   </ul>
data IOVector n e

-- | View an array in memory as a vector.
vectorViewArray :: (Elem e) => ForeignPtr e -> Int -> Int -> IOVector n e

-- | View an array in memory as a vector, with the given stride.
vectorViewArrayWithStride :: (Elem e) => Int -> ForeignPtr e -> Int -> Int -> IOVector n e

-- | Execute an <a>IO</a> action with a pointer to the first element in the
--   vector.
withIOVector :: IOVector n e -> (Ptr e -> IO a) -> IO a


-- | Mutable dense matrices in the ST monad.
module Data.Matrix.Dense.ST

-- | Dense matrix in the <a>ST</a> monad. The type arguments are as
--   follows:
--   
--   <ul>
--   <li><tt>s</tt>: the state variable argument for the <a>ST</a>
--   type</li>
--   <li><tt>np</tt>: a phantom type for the shape of the matrix. Most
--   functions will demand that this be specified as a pair. When writing a
--   function signature, you should always prefer <tt>STMatrix s (n,p)
--   e</tt> to <tt>STMatrix s np e</tt>.</li>
--   <li><tt>e</tt>: the element type of the matrix. Only certain element
--   types are supported.</li>
--   </ul>
data STMatrix s np e

-- | A safe way to create and work with a mutable matrix before returning
--   an immutable matrix for later perusal. This function avoids copying
--   the matrix before returning it - it uses unsafeFreezeMatrix
--   internally, but this wrapper is a safe interface to that function.
runSTMatrix :: (forall s. ST s (STMatrix s n e)) -> Matrix n e


-- | Mutable vectors in the ST monad.
module Data.Vector.Dense.ST

-- | Dense vectors in the <a>ST</a> monad. The type arguments are as
--   follows:
--   
--   <ul>
--   <li><tt>s</tt>: the state variable argument for the <a>ST</a>
--   type</li>
--   <li><tt>n</tt>: a phantom type for the dimension of the vector</li>
--   <li><tt>e</tt>: the element type of the vector. Only certain element
--   types are supported.</li>
--   </ul>
data STVector s n e

-- | A safe way to create and work with a mutable vector before returning
--   an immutable vector for later perusal. This function avoids copying
--   the vector before returning it - it uses unsafeFreezeVector
--   internally, but this wrapper is a safe interface to that function.
runSTVector :: (forall s. ST s (STVector s n e)) -> Vector n e


-- | An overloaded interface for immutable matrices. The matrices provide
--   access to rows and columns, and can operate via multiplication on
--   immutable dense vectors and matrices.
module Data.Matrix.Class.IMatrix

-- | A type class for immutable matrices. The member functions of the type
--   class do not perform any checks on the validity of shapes or indices,
--   so in general their safe counterparts should be preferred.
class (MatrixShaped a, BLAS3 e) => IMatrix a e

-- | Get the given row in a matrix.
row :: (IMatrix a e) => a (m, n) e -> Int -> Vector n e

-- | Get the given column in a matrix.
col :: (IMatrix a e) => a (m, n) e -> Int -> Vector m e

-- | Get a list the row vectors in the matrix.
rows :: (IMatrix a e) => a (m, n) e -> [Vector n e]

-- | Get a list the column vectors in the matrix.
cols :: (IMatrix a e) => a (m, n) e -> [Vector m e]

-- | Matrix multiplication by a vector.
(<*>) :: (IMatrix a e) => a (m, n) e -> Vector n e -> Vector m e

-- | Matrix multiplication by a matrix.
(<**>) :: (IMatrix a e) => a (m, k) e -> Matrix (k, n) e -> Matrix (m, n) e

-- | Scale and multiply by a vector. <tt>sapply k a x</tt> is equal to
--   <tt>a &lt;*&gt; (k *&gt; x)</tt>, and often it is faster.
sapply :: (IMatrix a e) => e -> a (m, n) e -> Vector n e -> Vector m e

-- | Scale and multiply by a matrix. <tt>sapplyMat k a b</tt> is equal to
--   <tt>a &lt;**&gt; (k *&gt; b)</tt>, and often it is faster.
sapplyMat :: (IMatrix a e) => e -> a (m, k) e -> Matrix (k, n) e -> Matrix (m, n) e


-- | Immutable dense matrices.
module Data.Matrix.Dense

-- | Immutable dense matrices. The type arguments are as follows:
--   
--   <ul>
--   <li><tt>np</tt>: a phantom type for the shape of the matrix. Most
--   functions will demand that this be specified as a pair. When writing a
--   function signature, you should always prefer <tt>Matrix (n,p) e</tt>
--   to <tt>Matrix np e</tt>.</li>
--   <li><tt>e</tt>: the element type of the matrix. Only certain element
--   types are supported.</li>
--   </ul>
data Matrix np e

-- | Common functionality for all dense matrix types.
class (HasVectorView a, Elem e, MatrixShaped a, BaseVector (VectorView a) e) => BaseMatrix a e
ldaMatrix :: (BaseMatrix a e) => a (n, p) e -> Int
transEnumMatrix :: (BaseMatrix a e) => a (n, p) e -> TransEnum
isHermMatrix :: (BaseMatrix a e) => a (n, p) e -> Bool
coerceMatrix :: (BaseMatrix a e) => a np e -> a np' e

-- | Create a new matrix of the given size and initialize the given
--   elements to the given values. All other elements get set to zero.
matrix :: (BLAS3 e) => (Int, Int) -> [((Int, Int), e)] -> Matrix (n, p) e

-- | Create a new matrix with the given elements in row-major order.
listMatrix :: (BLAS3 e) => (Int, Int) -> [e] -> Matrix (n, p) e

-- | Create a matrix of the given shape from a list of rows
rowsMatrix :: (BLAS3 e) => (Int, Int) -> [Vector p e] -> Matrix (n, p) e

-- | Create a matrix of the given shape from a list of columns
colsMatrix :: (BLAS3 e) => (Int, Int) -> [Vector n e] -> Matrix (n, p) e

-- | Get a new zero of the given shape.
zeroMatrix :: (BLAS3 e) => (Int, Int) -> Matrix (n, p) e

-- | Get a new constant of the given shape.
constantMatrix :: (BLAS3 e) => (Int, Int) -> e -> Matrix (n, p) e

-- | Get a new matrix of the given shape with ones along the diagonal and
--   zeroes everywhere else.
identityMatrix :: (BLAS3 e) => (Int, Int) -> Matrix (n, p) e

-- | Get a matrix from a row vector.
matrixFromRow :: (BLAS3 e) => Vector p e -> Matrix (one, p) e

-- | Get a matrix from a column vector.
matrixFromCol :: (BLAS3 e) => Vector n e -> Matrix (n, one) e

-- | Get a matrix from the elements stored in columnwise order in the
--   vector.
matrixFromVector :: (BLAS3 e) => (Int, Int) -> Vector np e -> Matrix (n, p) e

-- | Get a vector by concatenating the columns of the matrix.
vectorFromMatrix :: (BLAS3 e) => Matrix (n, p) e -> Vector np e

-- | <tt>submatrix a ij mn</tt> returns the submatrix of <tt>a</tt> with
--   element <tt>(0,0)</tt> being element <tt>ij</tt> in <tt>a</tt>, and
--   having shape <tt>mn</tt>.
submatrix :: (Elem e) => Matrix (n, p) e -> (Int, Int) -> (Int, Int) -> Matrix (n', p') e

-- | Divide the rows of a matrix into two blocks and return views into the
--   blocks. The integer argument indicates how many rows should be in the
--   first block.
splitRowsAt :: (BaseMatrix a e) => Int -> a (n, p) e -> (a (n1, p) e, a (n2, p) e)

-- | Divide the columns of a matrix into two blocks and return views into
--   the blocks. The integer argument indicates how many columns should be
--   in the first block.
splitColsAt :: (BaseMatrix a e) => Int -> a (n, p) e -> (a (n, p1) e, a (n, p2) e)

-- | Get a the given diagonal in a matrix. Negative indices correspond to
--   sub-diagonals.
diag :: (Elem e) => Matrix (n, p) e -> Int -> Vector k e


-- | An overloaded interface for solving immutable matrix systems. The
--   matrices can operate via inverse multiplication on immutable dense
--   vectors and matrices.
module Data.Matrix.Class.ISolve

-- | A type class for immutable matrices with inverses. The member
--   functions of the type class do not perform any checks on the validity
--   of shapes or indices, so in general their safe counterparts should be
--   preferred.
class (MatrixShaped a, BLAS3 e) => ISolve a e

-- | Solve for a vector.
(<\>) :: (ISolve a e) => a (m, n) e -> Vector m e -> Vector n e

-- | Solve for a matrix.
(<\\>) :: (ISolve a e) => a (m, n) e -> Matrix (m, k) e -> Matrix (n, k) e

-- | Solve for a vector and scale. <tt>ssolve k a y</tt> is equal to <tt>a
--   &lt;\&gt; (k *&gt; y)</tt> but is often faster.
ssolve :: (ISolve a e) => e -> a (m, n) e -> Vector m e -> Vector n e

-- | Solve for a matrix and scale. <tt>ssolveMat k a c</tt> is equal to
--   <tt>a &lt;\\&gt; (k *&gt; c)</tt> but is often faster.
ssolveMat :: (ISolve a e) => e -> a (m, n) e -> Matrix (m, k) e -> Matrix (n, k) e


-- | Triangular views of matrices.
module Data.Matrix.Tri

-- | A triangular or trapezoidal view of an underlying matrix. The view can
--   either be of the upper or lower triangular part of the matrix, and can
--   optionally include or exclude the diagonal. If the diagonal enum is
--   <tt>Unit</tt>, the diagonal entries of the underlying matrix are not
--   referenced, but are assumed to be <tt>1</tt>. The type arguments are
--   as follows:
--   
--   <ul>
--   <li><tt>a</tt>: the underlyting matrix type.</li>
--   <li><tt>np</tt>: a phantom type for the shape of the view.</li>
--   <li><tt>e</tt>: the element type of the matrix.</li>
--   </ul>
data Tri a np e
Tri :: UpLoEnum -> DiagEnum -> (a np e) -> Tri a np e

-- | Convert from a base matrix type to a triangular view.
triFromBase :: UpLoEnum -> DiagEnum -> a (n, p) e -> Tri a (n, p) e

-- | Convert from a triangular view to the base matrix.
triToBase :: Tri a (n, p) e -> (UpLoEnum, DiagEnum, a (n, p) e)

-- | Apply a function to the base matrix.
mapTri :: (a np e -> b np' e) -> Tri a np e -> Tri b np' e

-- | Get a lower triangular view of a matrix.
lower :: (MatrixShaped a) => a (n, p) e -> Tri a (n, p) e

-- | Get a lower triangular view of a matrix, with unit diagonal.
lowerU :: (MatrixShaped a) => a (n, p) e -> Tri a (n, p) e

-- | Get an upper triangular view of a matrix.
upper :: (MatrixShaped a) => a (n, p) e -> Tri a (n, p) e

-- | Get an upper triangular view of a matrix, with unit diagonal.
upperU :: (MatrixShaped a) => a (n, p) e -> Tri a (n, p) e

-- | Cast the phantom shape type.
coerceTri :: Tri a np e -> Tri a np' e


-- | Immutable banded matrices.
module Data.Matrix.Banded

-- | Immutable banded matrices. The type arguments are as follows:
--   
--   <ul>
--   <li><tt>np</tt>: a phantom type for the shape of the matrix. Most
--   functions will demand that this be specified as a pair. When writing a
--   function signature, you should always prefer <tt>Banded (n,p) e</tt>
--   to <tt>Banded np e</tt>.</li>
--   <li><tt>e</tt>: the element type of the matrix. Only certain element
--   types are supported.</li>
--   </ul>
data Banded np e

-- | Common functionality for all banded matrix types.
class (MatrixShaped a, HasVectorView a, HasMatrixStorage a, Elem e, BaseVector (VectorView a) e, BaseMatrix (MatrixStorage a) e) => BaseBanded a e
numLower :: (BaseBanded a e) => a (n, p) e -> Int
numUpper :: (BaseBanded a e) => a (n, p) e -> Int
bandwidths :: (BaseBanded a e) => a (n, p) e -> (Int, Int)
ldaBanded :: (BaseBanded a e) => a (n, p) e -> Int
transEnumBanded :: (BaseBanded a e) => a (n, p) e -> TransEnum
isHermBanded :: (BaseBanded a e) => a (n, p) e -> Bool
coerceBanded :: (BaseBanded a e) => a np e -> a np' e
maybeMatrixStorageFromBanded :: (BaseBanded a e) => a (n, p) e -> Maybe (MatrixStorage a (k, p) e)
maybeBandedFromMatrixStorage :: (BaseBanded a e) => (Int, Int) -> (Int, Int) -> MatrixStorage a (k, p) e -> Maybe (a (n, p) e)

-- | Create a banded matrix with the given shape, bandwidths, and
--   associations. The indices in the associations list must all fall in
--   the bandwidth of the matrix. Unspecified elements will be set to zero.
banded :: (BLAS3 e) => (Int, Int) -> (Int, Int) -> [((Int, Int), e)] -> Banded (n, p) e

-- | Create a banded matrix of the given shape and bandwidths by specifying
--   its diagonal elements. The lists must all have the same length, equal
--   to the number of elements in the main diagonal of the matrix. The
--   sub-diagonals are specified first, then the super-diagonals. In
--   subdiagonal <tt>i</tt>, the first <tt>i</tt> elements of the list are
--   ignored.
listsBanded :: (BLAS3 e) => (Int, Int) -> (Int, Int) -> [[e]] -> Banded (n, p) e

-- | Create a zero banded matrix with the specified shape and bandwidths.
zeroBanded :: (BLAS3 e) => (Int, Int) -> (Int, Int) -> Banded (n, p) e

-- | Create a constant banded matrix of the specified shape and bandwidths.
constantBanded :: (BLAS3 e) => (Int, Int) -> (Int, Int) -> e -> Banded (n, p) e

-- | Create a banded matrix from a vector. The vector must have length
--   equal to one of the specified dimension sizes.
bandedFromVector :: (Elem e) => (Int, Int) -> Vector k e -> Banded (n, p) e

-- | Create a diagonal banded matrix from a vector.
diagBandedFromVector :: (Elem e) => Vector n e -> Banded (n, n) e

-- | Convert a diagonal banded matrix to a vector. Fail if the banded
--   matrix has more than one diagonal
maybeVectorFromBanded :: (Elem e) => Banded (n, p) e -> Maybe (Vector k e)

-- | Get a the given diagonal in a banded matrix. Negative indices
--   correspond to sub-diagonals.
diagBanded :: (BLAS1 e) => Banded (n, p) e -> Int -> Vector k e


-- | An overloaded interface to mutable banded matrices. For matrix types
--   than can be used with this interface, see <a>Data.Matrix.Banded.IO</a>
--   and <a>Data.Matrix.Banded.ST</a>. Many of these functions can also be
--   used with the immutable type defined in <a>Data.Matrix.Banded</a>.
module Data.Matrix.Banded.Class

-- | Common functionality for all banded matrix types.
class (MatrixShaped a, HasVectorView a, HasMatrixStorage a, Elem e, BaseVector (VectorView a) e, BaseMatrix (MatrixStorage a) e) => BaseBanded a e
numLower :: (BaseBanded a e) => a (n, p) e -> Int
numUpper :: (BaseBanded a e) => a (n, p) e -> Int
bandwidths :: (BaseBanded a e) => a (n, p) e -> (Int, Int)
ldaBanded :: (BaseBanded a e) => a (n, p) e -> Int
transEnumBanded :: (BaseBanded a e) => a (n, p) e -> TransEnum
isHermBanded :: (BaseBanded a e) => a (n, p) e -> Bool
coerceBanded :: (BaseBanded a e) => a np e -> a np' e
maybeMatrixStorageFromBanded :: (BaseBanded a e) => a (n, p) e -> Maybe (MatrixStorage a (k, p) e)
maybeBandedFromMatrixStorage :: (BaseBanded a e) => (Int, Int) -> (Int, Int) -> MatrixStorage a (k, p) e -> Maybe (a (n, p) e)
viewVectorAsBanded :: (BaseBanded a e) => (Int, Int) -> VectorView a k e -> a (n, p) e
viewVectorAsDiagBanded :: (BaseBanded a e) => VectorView a n e -> a (n, n) e
maybeViewBandedAsVector :: (BaseBanded a e) => a (n, p) e -> Maybe (VectorView a k e)
unsafeBandedToIOBanded :: (BaseBanded a e) => a (n, p) e -> IOBanded (n, p) e

-- | Banded matrices that can be read in a monad.
class (BaseBanded a e, BLAS2 e, ReadTensor a (Int, Int) e m, MMatrix a e m, MMatrix (Herm a) e m, MMatrix (Tri a) e m, MSolve (Tri a) e m, ReadVector (VectorView a) e m, ReadMatrix (MatrixStorage a) e m) => ReadBanded a e m
unsafePerformIOWithBanded :: (ReadBanded a e m) => a (n, p) e -> (IOBanded (n, p) e -> IO r) -> m r
freezeBanded :: (ReadBanded a e m) => a (n, p) e -> m (Banded (n, p) e)
unsafeFreezeBanded :: (ReadBanded a e m) => a (n, p) e -> m (Banded (n, p) e)

-- | Banded matrices that can be created or modified in a monad.
class (ReadBanded a e m, WriteTensor a (Int, Int) e m, WriteVector (VectorView a) e m, WriteMatrix (MatrixStorage a) e m) => WriteBanded a e m
newBanded_ :: (WriteBanded a e m) => (Int, Int) -> (Int, Int) -> m (a (n, p) e)
unsafeConvertIOBanded :: (WriteBanded a e m) => IO (IOBanded (n, p) e) -> m (a (n, p) e)
thawBanded :: (WriteBanded a e m) => Banded (n, p) e -> m (a (n, p) e)
unsafeThawBanded :: (WriteBanded a e m) => Banded (n, p) e -> m (a (n, p) e)

-- | Create a banded matrix with the given shape, bandwidths, and
--   associations. The indices in the associations list must all fall in
--   the bandwidth of the matrix. Unspecified elements will be set to zero.
newBanded :: (WriteBanded a e m) => (Int, Int) -> (Int, Int) -> [((Int, Int), e)] -> m (a (n, p) e)

-- | Create a banded matrix of the given shape and bandwidths by specifying
--   its diagonal elements. The lists must all have the same length, equal
--   to the number of elements in the main diagonal of the matrix. The
--   sub-diagonals are specified first, then the super-diagonals. In
--   subdiagonal <tt>i</tt>, the first <tt>i</tt> elements of the list are
--   ignored.
newListsBanded :: (WriteBanded a e m) => (Int, Int) -> (Int, Int) -> [[e]] -> m (a (n, p) e)

-- | Create a zero banded matrix with the specified shape and bandwidths.
newZeroBanded :: (WriteBanded a e m) => (Int, Int) -> (Int, Int) -> m (a (n, p) e)

-- | Set every element of a banded matrix to zero.
setZeroBanded :: (WriteBanded a e m) => a (n, p) e -> m ()

-- | Create a constant banded matrix of the specified shape and bandwidths.
newConstantBanded :: (WriteBanded a e m) => (Int, Int) -> (Int, Int) -> e -> m (a (n, p) e)

-- | Set every element of a banded matrix to a constant.
setConstantBanded :: (WriteBanded a e m) => e -> a (n, p) e -> m ()

-- | Create a new banded matrix by taking a copy of another one.
newCopyBanded :: (ReadBanded a e m, WriteBanded b e m) => a (n, p) e -> m (b (n, p) e)

-- | Copy the elements of one banded matrix into another. The two matrices
--   must have the same shape and badwidths.
copyBanded :: (WriteBanded b e m, ReadBanded a e m) => b (n, p) e -> a (n, p) e -> m ()

-- | Get a view into the partial row of the banded matrix, along with the
--   number of zeros to pad before and after the view.
rowViewBanded :: (BaseBanded a e) => a (n, p) e -> Int -> (Int, VectorView a k e, Int)

-- | Get a view into the partial column of the banded matrix, along with
--   the number of zeros to pad before and after the view.
colViewBanded :: (BaseBanded a e) => a (n, p) e -> Int -> (Int, VectorView a k e, Int)

-- | Get a view of a diagonal of the banded matrix. This will fail if the
--   index is outside of the bandwidth.
diagViewBanded :: (BaseBanded a e) => a (n, p) e -> Int -> VectorView a k e

-- | Get a copy of the given diagonal of a banded matrix.
getDiagBanded :: (ReadBanded a e m, WriteVector y e m) => a (n, p) e -> Int -> m (y k e)


-- | Mutable banded matrices in the IO monad.
module Data.Matrix.Banded.IO

-- | Banded matrix in the <a>IO</a> monad. The type arguments are as
--   follows:
--   
--   <ul>
--   <li><tt>np</tt>: a phantom type for the shape of the matrix. Most
--   functions will demand that this be specified as a pair. When writing a
--   function signature, you should always prefer <tt>IOBanded (n,p) e</tt>
--   to <tt>IOBanded np e</tt>.</li>
--   <li><tt>e</tt>: the element type of the matrix. Only certain element
--   types are supported.</li>
--   </ul>
data IOBanded np e

-- | Execute an <a>IO</a> action with a pointer to the first element in the
--   banded matrix.
withIOBanded :: IOBanded (n, p) e -> (Ptr e -> IO a) -> IO a


-- | Mutable dense matrices in the ST monad.
module Data.Matrix.Banded.ST

-- | Banded matrix in the <a>ST</a> monad. The type arguments are as
--   follows:
--   
--   <ul>
--   <li><tt>s</tt>: the state variable argument for the <a>ST</a>
--   type</li>
--   <li><tt>np</tt>: a phantom type for the shape of the matrix. Most
--   functions will demand that this be specified as a pair. When writing a
--   function signature, you should always prefer <tt>STBanded s (n,p)
--   e</tt> to <tt>STBanded s np e</tt>.</li>
--   <li><tt>e</tt>: the element type of the matrix. Only certain element
--   types are supported.</li>
--   </ul>
data STBanded s np e

-- | A safe way to create and work with a mutable banded matrix before
--   returning an immutable one for later perusal. This function avoids
--   copying the matrix before returning it - it uses unsafeFreezeBanded
--   internally, but this wrapper is a safe interface to that function.
runSTBanded :: (forall s. ST s (STBanded s n e)) -> Banded n e


-- | Unsafe BLAS functions. Most of these functions to not check the shapes
--   of their arguments, and should be used with caution.
module Unsafe.BLAS
clearArray :: (Storable e) => Ptr e -> Int -> IO ()
inlinePerformIO :: IO a -> a

-- | Dense vectors in the <a>IO</a> monad. The type arguments are as
--   follows:
--   
--   <ul>
--   <li><tt>n</tt>: a phantom type for the dimension of the vector</li>
--   <li><tt>e</tt>: the element type of the vector. Only certain element
--   types are supported.</li>
--   </ul>
data IOVector n e
IOVector :: !!ConjEnum -> !!Int -> !!ForeignPtr e -> !!Ptr e -> !!Int -> IOVector n e
unsafeIOVectorToVector :: (BaseVector x e) => IOVector n e -> x n e
unsafeVector :: (BLAS1 e) => Int -> [(Int, e)] -> Vector n e
unsafeSubvector :: (BLAS1 e) => Vector n e -> Int -> Int -> Vector n' e
unsafeSubvectorWithStride :: (Elem e) => Int -> Vector n e -> Int -> Int -> Vector n' e
unsafeDot :: (BLAS1 e) => Vector n e -> Vector n e -> e
unsafeNewVector :: (WriteVector x e m) => Int -> [(Int, e)] -> m (x n e)
unsafeCopyVector :: (ReadVector y e m, ReadVector x e m) => y n e -> x n e -> m ()
unsafeSwapVector :: (WriteVector x e m, WriteVector y e m) => x n e -> y n e -> m ()
unsafeSubvectorView :: (BaseVector x e) => x n e -> Int -> Int -> x n' e
unsafeSubvectorViewWithStride :: (BaseVector x e) => Int -> x n e -> Int -> Int -> x n' e
unsafeGetAddVector :: (ReadVector x e m, ReadVector y e m, WriteVector z e m) => x n e -> y n e -> m (z n e)
unsafeGetSubVector :: (ReadVector x e m, ReadVector y e m, WriteVector z e m) => x n e -> y n e -> m (z n e)
unsafeGetMulVector :: (ReadVector x e m, ReadVector y e m, WriteVector z e m) => x n e -> y n e -> m (z n e)
unsafeGetDivVector :: (ReadVector x e m, ReadVector y e m, WriteVector z e m) => x n e -> y n e -> m (z n e)
unsafeAxpyVector :: (ReadVector x e m, ReadVector y e m) => e -> x n e -> y n e -> m ()
unsafeAddVector :: (WriteVector y e m, ReadVector x e m) => y n e -> x n e -> m ()
unsafeSubVector :: (WriteVector y e m, ReadVector x e m) => y n e -> x n e -> m ()
unsafeMulVector :: (WriteVector y e m, ReadVector x e m) => y n e -> x n e -> m ()
unsafeDivVector :: (WriteVector y e m, ReadVector x e m) => y n e -> x n e -> m ()
unsafeGetDot :: (ReadVector x e m, ReadVector y e m) => x n e -> y n e -> m e

-- | Dense matrix in the <a>IO</a> monad. The type arguments are as
--   follows:
--   
--   <ul>
--   <li><tt>np</tt>: a phantom type for the shape of the matrix. Most
--   functions will demand that this be specified as a pair. When writing a
--   function signature, you should always prefer <tt>IOMatrix (n,p) e</tt>
--   to <tt>IOMatrix np e</tt>.</li>
--   <li><tt>e</tt>: the element type of the matrix. Only certain element
--   types are supported.</li>
--   </ul>
data IOMatrix np e
IOMatrix :: !!TransEnum -> !!Int -> !!Int -> !!ForeignPtr e -> !!Ptr e -> !!Int -> IOMatrix np e
unsafeIOMatrixToMatrix :: (BaseMatrix a e) => IOMatrix (n, p) e -> a (n, p) e
unsafeSubmatrixView :: (BaseMatrix a e) => a (n, p) e -> (Int, Int) -> (Int, Int) -> a (n', p') e
unsafeDiagView :: (BaseMatrix a e) => a (n, p) e -> Int -> VectorView a k e
unsafeRowView :: (BaseMatrix a e) => a (n, p) e -> Int -> VectorView a p e
unsafeColView :: (BaseMatrix a e) => a (n, p) e -> Int -> VectorView a n e
unsafeMatrix :: (BLAS3 e) => (Int, Int) -> [((Int, Int), e)] -> Matrix (n, p) e
unsafeSubmatrix :: (Elem e) => Matrix (n, p) e -> (Int, Int) -> (Int, Int) -> Matrix (n', p') e
unsafeDiag :: (Elem e) => Matrix (n, p) e -> Int -> Vector k e
unsafeNewMatrix :: (WriteMatrix a e m) => (Int, Int) -> [((Int, Int), e)] -> m (a (n, p) e)
unsafeCopyMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()
unsafeSwapMatrix :: (WriteMatrix a e m, WriteMatrix b e m) => a (n, p) e -> b (n, p) e -> m ()
unsafeSwapRows :: (WriteMatrix a e m) => a (n, p) e -> Int -> Int -> m ()
unsafeSwapCols :: (WriteMatrix a e m) => a (n, p) e -> Int -> Int -> m ()
unsafeGetDiag :: (ReadMatrix a e m, WriteVector y e m) => a (n, p) e -> Int -> m (y k e)
unsafeGetAddMatrix :: (ReadMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (n, p) e -> b (n, p) e -> m (c (n, p) e)
unsafeGetSubMatrix :: (ReadMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (n, p) e -> b (n, p) e -> m (c (n, p) e)
unsafeGetMulMatrix :: (ReadMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (n, p) e -> b (n, p) e -> m (c (n, p) e)
unsafeGetDivMatrix :: (ReadMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => a (n, p) e -> b (n, p) e -> m (c (n, p) e)
unsafeAxpyMatrix :: (ReadMatrix a e m, WriteMatrix b e m) => e -> a (n, p) e -> b (n, p) e -> m ()
unsafeAddMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()
unsafeSubMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()
unsafeMulMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()
unsafeDivMatrix :: (WriteMatrix b e m, ReadMatrix a e m) => b (n, p) e -> a (n, p) e -> m ()

-- | Banded matrix in the <a>IO</a> monad. The type arguments are as
--   follows:
--   
--   <ul>
--   <li><tt>np</tt>: a phantom type for the shape of the matrix. Most
--   functions will demand that this be specified as a pair. When writing a
--   function signature, you should always prefer <tt>IOBanded (n,p) e</tt>
--   to <tt>IOBanded np e</tt>.</li>
--   <li><tt>e</tt>: the element type of the matrix. Only certain element
--   types are supported.</li>
--   </ul>
data IOBanded np e
IOBanded :: !!TransEnum -> !!Int -> !!Int -> !!Int -> !!Int -> !!ForeignPtr e -> !!Ptr e -> !!Int -> IOBanded np e
transEnumIOBanded :: IOBanded np e -> !!TransEnum
numRowsIOBanded :: IOBanded np e -> !!Int
numColsIOBanded :: IOBanded np e -> !!Int
numLowerIOBanded :: IOBanded np e -> !!Int
numUpperIOBanded :: IOBanded np e -> !!Int
fptrIOBanded :: IOBanded np e -> !!ForeignPtr e
ptrIOBanded :: IOBanded np e -> !!Ptr e
ldaIOBanded :: IOBanded np e -> !!Int
unsafeIOBandedToBanded :: (BaseBanded a e) => IOBanded (n, p) e -> a (n, p) e
unsafeDiagViewBanded :: (BaseBanded a e) => a (n, p) e -> Int -> VectorView a k e
unsafeRowViewBanded :: (BaseBanded a e) => a (n, p) e -> Int -> (Int, VectorView a k e, Int)
unsafeColViewBanded :: (BaseBanded a e) => a (n, p) e -> Int -> (Int, VectorView a k e, Int)
unsafeBanded :: (BLAS3 e) => (Int, Int) -> (Int, Int) -> [((Int, Int), e)] -> Banded (n, p) e
unsafeNewBanded :: (WriteBanded a e m) => (Int, Int) -> (Int, Int) -> [((Int, Int), e)] -> m (a (n, p) e)
unsafeGetDiagBanded :: (ReadBanded a e m, WriteVector y e m) => a (n, p) e -> Int -> m (y k e)
unsafeGetRowBanded :: (ReadBanded a e m, WriteVector y e m) => a (n, p) e -> Int -> m (y p e)
unsafeGetColBanded :: (ReadBanded a e m, WriteVector y e m) => a (n, p) e -> Int -> m (y n e)
unsafeDiagBanded :: (BLAS1 e) => Banded (n, p) e -> Int -> Vector k e

-- | A type class for immutable matrices. The member functions of the type
--   class do not perform any checks on the validity of shapes or indices,
--   so in general their safe counterparts should be preferred.
class (MatrixShaped a, BLAS3 e) => IMatrix a e

-- | A type class for immutable matrices with inverses. The member
--   functions of the type class do not perform any checks on the validity
--   of shapes or indices, so in general their safe counterparts should be
--   preferred.
class (MatrixShaped a, BLAS3 e) => ISolve a e

-- | A type class for mutable matrices associated with a monad. The member
--   functions of the type class do not perform any checks on the validity
--   of shapes or indices, so in general their safe counterparts should be
--   preferred.
class (MatrixShaped a, BLAS3 e, Monad m) => MMatrix a e m
unsafeGetSApply :: (MMatrix a e m, ReadVector x e m, WriteVector y e m) => e -> a (k, l) e -> x l e -> m (y k e)
unsafeGetSApplyMat :: (MMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => e -> a (r, s) e -> b (s, t) e -> m (c (r, t) e)
unsafeDoSApplyAdd :: (MMatrix a e m, ReadVector x e m, WriteVector y e m) => e -> a (k, l) e -> x l e -> e -> y k e -> m ()
unsafeDoSApplyAddMat :: (MMatrix a e m, ReadMatrix b e m, WriteMatrix c e m) => e -> a (r, s) e -> b (s, t) e -> e -> c (r, t) e -> m ()
unsafeDoSApply_ :: (MMatrix a e m, WriteVector y e m) => e -> a (n, n) e -> y n e -> m ()
unsafeDoSApplyMat_ :: (MMatrix a e m, WriteMatrix b e m) => e -> a (k, k) e -> b (k, l) e -> m ()
unsafeGetRow :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> Int -> m (x l e)
unsafeGetCol :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> Int -> m (x k e)
getRows :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> m [x l e]
getCols :: (MMatrix a e m, WriteVector x e m) => a (k, l) e -> m [x k e]
getRowsIO :: (MMatrix a e IO, WriteVector x e IO) => a (k, l) e -> IO [x l e]
getRowsST :: (MMatrix a e (ST s), WriteVector x e (ST s)) => a (k, l) e -> ST s [x l e]
getColsIO :: (MMatrix a e IO, WriteVector x e IO) => a (k, l) e -> IO [x k e]
getColsST :: (MMatrix a e (ST s), WriteVector x e (ST s)) => a (k, l) e -> ST s [x k e]

-- | A type class for mutable matrices with inverses. The member functions
--   of the type class do not perform any checks on the validity of shapes
--   or indices, so in general their safe counterparts should be preferred.
class (MatrixShaped a, BLAS3 e, Monad m) => MSolve a e m
unsafeDoSolve :: (MSolve a e m, ReadVector y e m, WriteVector x e m) => a (k, l) e -> y k e -> x l e -> m ()
unsafeDoSolveMat :: (MSolve a e m, ReadMatrix c e m, WriteMatrix b e m) => a (r, s) e -> c (r, t) e -> b (s, t) e -> m ()
unsafeDoSSolve :: (MSolve a e m, ReadVector y e m, WriteVector x e m) => e -> a (k, l) e -> y k e -> x l e -> m ()
unsafeDoSSolveMat :: (MSolve a e m, ReadMatrix c e m, WriteMatrix b e m) => e -> a (r, s) e -> c (r, t) e -> b (s, t) e -> m ()
unsafeDoSolve_ :: (MSolve a e m, WriteVector x e m) => a (k, k) e -> x k e -> m ()
unsafeDoSSolve_ :: (MSolve a e m, WriteVector x e m) => e -> a (k, k) e -> x k e -> m ()
unsafeDoSolveMat_ :: (MSolve a e m, WriteMatrix b e m) => a (k, k) e -> b (k, l) e -> m ()
unsafeDoSSolveMat_ :: (MSolve a e m, WriteMatrix b e m) => e -> a (k, k) e -> b (k, l) e -> m ()


-- | Test generators for BLAS types.
module Test.QuickCheck.BLAS

-- | Element types that can be tested with QuickCheck properties.
class (BLAS3 e, Arbitrary e) => TestElem e
isTestElemElem :: (TestElem e) => e -> Bool

-- | Generate a list of elements suitable for testing with.
elements :: (TestElem e) => Int -> Gen [e]

-- | Generate a list of elements for testing that have no imaginary part.
realElements :: (TestElem e) => Int -> Gen [e]

-- | Get an appropriate dimension for a random vector
dim :: Gen Int

-- | Generate a random vector of the given size.
vector :: (TestElem e) => Int -> Gen (Vector n e)

-- | Generate an appropriate shape for a random matrix.
shape :: Gen (Int, Int)

-- | Generate a random matrix of the given shape.
matrix :: (TestElem e) => (Int, Int) -> Gen (Matrix (m, n) e)

-- | Generate valid bandwidths for the given matrix shape.
bandwidths :: (Int, Int) -> Gen (Int, Int)

-- | Generate a random banded matrix.
banded :: (TestElem e) => (Int, Int) -> (Int, Int) -> Gen (Banded (m, n) e)
instance (BLAS3 e) => Show (SubMatrix m n e)
instance (Elem e) => Show (SubVector n e)
instance (TestElem e) => Arbitrary (SubMatrix m n e)
instance (TestElem e) => Arbitrary (SubVector n e)
instance TestElem (Complex Double)
instance Arbitrary (Complex Double)
instance TestElem Double
