-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Collection of alignment algorithms
--   
@package AlignmentAlgorithms
@version 0.0.2.0


-- | Very simple pairwise global alignment. The terminal tapes may contain
--   the atomic types <tt>u</tt> and <tt>l</tt> which means that one may
--   align sequences of different types.
--   
--   In case you want to align nucleotides to amino acids, this version
--   should only be used if the nucleotides are already in triplet form and
--   have no frameshift within the sequence. Alternatively, specify a
--   derived grammar of higher complexity.
module DP.Alignment.Global.Tapes2

-- | Define signature and grammar
data SigGlobal m_abOS s_abOT r_abOU t_l_abOV t_u_abOW
SigGlobal :: (s_abOT -> (:.) ((:.) Z t_l_abOV) t_u_abOW -> s_abOT) -> (s_abOT -> (:.) ((:.) Z t_l_abOV) () -> s_abOT) -> ((:.) ((:.) Z ()) () -> s_abOT) -> (s_abOT -> (:.) ((:.) Z ()) t_u_abOW -> s_abOT) -> (Stream m_abOS s_abOT -> m_abOS r_abOU) -> SigGlobal m_abOS s_abOT r_abOU t_l_abOV t_u_abOW
align :: SigGlobal m_abOS s_abOT r_abOU t_l_abOV t_u_abOW -> s_abOT -> (:.) ((:.) Z t_l_abOV) t_u_abOW -> s_abOT
delin :: SigGlobal m_abOS s_abOT r_abOU t_l_abOV t_u_abOW -> s_abOT -> (:.) ((:.) Z t_l_abOV) () -> s_abOT
done :: SigGlobal m_abOS s_abOT r_abOU t_l_abOV t_u_abOW -> (:.) ((:.) Z ()) () -> s_abOT
indel :: SigGlobal m_abOS s_abOT r_abOU t_l_abOV t_u_abOW -> s_abOT -> (:.) ((:.) Z ()) t_u_abOW -> s_abOT
h :: SigGlobal m_abOS s_abOT r_abOU t_l_abOV t_u_abOW -> Stream m_abOS s_abOT -> m_abOS r_abOU
gGlobal :: (Build b2, MkStream m S t3, MkStream m (Stack b2) t3, Element (Stack b2) t3, RuleContext t3, TermStaticVar (TermSymbol (TermSymbol M Deletion) b1) t3, TermStaticVar (TermSymbol (TermSymbol M Epsilon) Epsilon) t3, TermStaticVar (TermSymbol (TermSymbol M b) Deletion) t3, TermStaticVar (TermSymbol (TermSymbol M b) b1) t3, TerminalStream m (TermSymbol (TermSymbol M Deletion) b1) t3, TerminalStream m (TermSymbol (TermSymbol M Epsilon) Epsilon) t3, TerminalStream m (TermSymbol (TermSymbol M b) Deletion) t3, TerminalStream m (TermSymbol (TermSymbol M b) b1) t3, Apply ((:.) (Arg (Stack b2)) ((:.) (TermArg (TermSymbol M b)) ()) -> a), Apply ((:.) (Arg (Stack b2)) (TermArg (TermSymbol (TermSymbol M b) b1)) -> a), Apply ((:.) (Arg (Stack b2)) (TermArg (TermSymbol (TermSymbol M Deletion) b1)) -> a), (~) * (Fun ((:.) (Arg (Stack b2)) ((:.) (TermArg (TermSymbol M b)) ()) -> a)) (a -> (:.) ((:.) Z t1) () -> a), (~) * (Fun ((:.) (Arg (Stack b2)) (TermArg (TermSymbol (TermSymbol M b) b1)) -> a)) (a -> (:.) ((:.) Z t1) t2 -> a), (~) * (Fun ((:.) (Arg (Stack b2)) (TermArg (TermSymbol (TermSymbol M Deletion) b1)) -> a)) (a -> (:.) ((:.) Z ()) t2 -> a)) => SigGlobal m a t t1 t2 -> ((t3 -> t3 -> m t) -> b2) -> b -> b1 -> (:.) Z b2

-- | Generic backtracking scheme via <tt>FMList</tt>s.
backtrack :: Monad m => u -> l -> SigGlobal m (FMList (l, u)) [FMList (l, u)] l u

-- | Turn a single <tt>FMList</tt> backtracking result into the
--   corresponding list.
runBacktrack :: FMList (u, l) -> [(u, l)]
instance (Monad mL0, Monad mR0, Eq xL0, mL0 ~ mR0, xL0 ~ rL0) => ProductBacktracking (SigGlobal mL0 xL0 rL0 t_l0 t_u0) (SigGlobal mR0 xR0 rR0 t_l0 t_u0)
