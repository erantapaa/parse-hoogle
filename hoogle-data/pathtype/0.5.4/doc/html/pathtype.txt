-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe replacement for System.FilePath etc
--   
@package pathtype
@version 0.5.4


-- | This module provides type-safe access to filepath manipulations.
--   
--   Normally you would import <a>Path</a> (which will use the default
--   implementation for the host platform) instead of this. However,
--   importing this explicitly allows for manipulation of non-native paths.
module System.Path.Windows

-- | This is the main filepath abstract datatype
data Path ar fd
data Abs
data Rel
data File
data Dir
type AbsFile = Path Abs File
type RelFile = Path Rel File
type AbsDir = Path Abs Dir
type RelDir = Path Rel Dir
type AbsPath fd = Path Abs fd
type RelPath fd = Path Rel fd
type FilePath ar = Path ar File
type DirPath ar = Path ar Dir

-- | This class allows selective behaviour for absolute and relative paths
--   and is mostly for internal use.
class Private ar => AbsRelClass ar
absRel :: AbsRelClass ar => (AbsPath fd -> a) -> (RelPath fd -> a) -> Path ar fd -> a

-- | This class allows selective behaviour for file and directory paths and
--   is mostly for internal use.
class Private fd => FileDirClass fd
fileDir :: FileDirClass fd => (FilePath ar -> a) -> (DirPath ar -> a) -> Path ar fd -> a

-- | Convert the <a>Path</a> into a plain <a>String</a>. This is simply an
--   alias for <a>show</a>.
getPathString :: AbsRelClass ar => Path ar fd -> String
rootDir :: AbsDir
currentDir :: RelDir

-- | Use a <a>String</a> as a <a>Path</a> whose type is determined by its
--   context.
--   
--   <pre>
--   &gt; asPath "/tmp" == "/tmp"
--   &gt; asPath "file.txt" == "file.txt"
--   &gt; isAbsolute (asPath "/tmp" :: AbsDir) == True
--   &gt; isAbsolute (asPath "/tmp" :: RelDir) == False
--   &gt; getPathString (asPath "/tmp" :: AbsDir) == "/tmp"
--   &gt; getPathString (asPath "/tmp" :: RelDir) == "tmp"
--   </pre>
asPath :: String -> Path ar fd

-- | Use a <a>String</a> as a <a>RelFile</a>. No checking is done.
--   
--   <pre>
--   &gt; getPathString (asRelFile "file.txt") == "file.txt"
--   &gt; getPathString (asRelFile "/file.txt") == "file.txt"
--   &gt; getPathString (asRelFile "tmp") == "tmp"
--   &gt; getPathString (asRelFile "/tmp") == "tmp"
--   </pre>
asRelFile :: String -> RelFile

-- | Use a <a>String</a> as a <a>RelDir</a>. No checking is done.
--   
--   <pre>
--   &gt; getPathString (asRelDir "file.txt") == "file.txt"
--   &gt; getPathString (asRelDir "/file.txt") == "file.txt"
--   &gt; getPathString (asRelDir "tmp") == "tmp"
--   &gt; getPathString (asRelDir "/tmp") == "tmp"
--   </pre>
asRelDir :: String -> RelDir

-- | Use a <a>String</a> as an <a>AbsFile</a>. No checking is done.
--   
--   <pre>
--   &gt; getPathString (asAbsFile "file.txt") == "/file.txt"
--   &gt; getPathString (asAbsFile "/file.txt") == "/file.txt"
--   &gt; getPathString (asAbsFile "tmp") == "/tmp"
--   &gt; getPathString (asAbsFile "/tmp") == "/tmp"
--   </pre>
asAbsFile :: String -> AbsFile

-- | Use a <a>String</a> as an <a>AbsDir</a>. No checking is done.
--   
--   <pre>
--   &gt; getPathString (asAbsDir "file.txt") == "/file.txt"
--   &gt; getPathString (asAbsDir "/file.txt") == "/file.txt"
--   &gt; getPathString (asAbsDir "tmp") == "/tmp"
--   &gt; getPathString (asAbsDir "/tmp") == "/tmp"
--   </pre>
asAbsDir :: String -> AbsDir

-- | Use a <a>String</a> as a 'RelPath fd'. No checking is done.
asRelPath :: String -> RelPath fd

-- | Use a <a>String</a> as an 'AbsPath fd'. No checking is done.
asAbsPath :: String -> AbsPath fd

-- | Use a <a>String</a> as a 'FilePath ar'. No checking is done.
asFilePath :: String -> FilePath ar

-- | Use a <a>String</a> as a 'DirPath ar'. No checking is done.
asDirPath :: String -> DirPath ar

-- | Examines the supplied string and constructs an absolute or relative
--   path as appropriate.
--   
--   <pre>
--   &gt; either id (const "fred") (mkPathAbsOrRel "/tmp") == "/tmp"
--   &gt; either id (const "fred") (mkPathAbsOrRel  "tmp") == "fred"
--   </pre>
mkPathAbsOrRel :: String -> Either (AbsPath fd) (RelPath fd)

-- | Searches for a file or directory with the supplied path string and
--   returns a <a>File</a> or <a>Dir</a> path as appropriate. If neither
--   exists at the supplied path, <a>Nothing</a> is returned.
mkPathFileOrDir :: AbsRelClass ar => String -> IO (Maybe (Either (FilePath ar) (DirPath ar)))

-- | Convert a <a>String</a> into an <a>AbsPath</a> by interpreting it as
--   relative to the supplied directory if necessary.
--   
--   <pre>
--   &gt; mkAbsPath "/tmp" "foo.txt" == "/tmp/foo.txt"
--   &gt; mkAbsPath "/tmp" "/etc/foo.txt" == "/etc/foo.txt"
--   </pre>
mkAbsPath :: AbsDir -> String -> AbsPath fd

-- | Convert a <a>String</a> into an <a>AbsPath</a> by interpreting it as
--   relative to the cwd if necessary.
mkAbsPathFromCwd :: String -> IO (AbsPath fd)

-- | Join an (absolute or relative) directory path with a relative (file or
--   directory) path to form a new path.
(</>) :: DirPath ar -> RelPath fd -> Path ar fd

-- | We only allow files (and not directories) to have extensions added by
--   this function. This is because it's the vastly common case and an
--   attempt to add one to a directory will - more often than not -
--   represent an error. We don't however want to prevent the corresponding
--   operation on directories, and so we provide a function that is more
--   flexible: <a>genericAddExtension</a>.
(<.>) :: FilePath ar -> String -> FilePath ar

-- | Add an extension, even if there is already one there. E.g.
--   <tt>addExtension "foo.txt" "bat" -&gt; "foo.txt.bat"</tt>.
--   
--   <pre>
--   &gt; addExtension "file.txt" "bib" == "file.txt.bib"
--   &gt; addExtension "file." ".bib" == "file..bib"
--   &gt; addExtension "file" ".bib" == "file.bib"
--   &gt; takeFileName (addExtension "" "ext") == ".ext"
--   </pre>
addExtension :: FilePath ar -> String -> FilePath ar

-- | Join an (absolute or relative) directory path with a relative (file or
--   directory) path to form a new path.
combine :: DirPath ar -> RelPath fd -> Path ar fd

-- | Remove last extension, and the "." preceding it.
--   
--   <pre>
--   &gt; dropExtension x == fst (splitExtension x)
--   </pre>
dropExtension :: FilePath ar -> FilePath ar

-- | Drop all extensions
--   
--   <pre>
--   &gt; not $ hasAnExtension (dropExtensions x)
--   </pre>
dropExtensions :: FilePath ar -> FilePath ar
dropFileName :: Path ar fd -> DirPath ar

-- | Set the extension of a file, overwriting one if already present.
--   
--   <pre>
--   &gt; replaceExtension "file.txt" ".bob" == "file.bob"
--   &gt; replaceExtension "file.txt" "bob" == "file.bob"
--   &gt; replaceExtension "file" ".bob" == "file.bob"
--   &gt; replaceExtension "file.txt" "" == "file"
--   &gt; replaceExtension "file.fred.bob" "txt" == "file.fred.txt"
--   </pre>
replaceExtension :: FilePath ar -> String -> FilePath ar
replaceBaseName :: Path ar fd -> String -> Path ar fd
replaceDirectory :: Path ar1 fd -> DirPath ar2 -> Path ar2 fd
replaceFileName :: Path ar fd -> String -> Path ar fd

-- | Split on the extension. <a>addExtension</a> is the inverse.
--   
--   <pre>
--   &gt; uncurry (&lt;.&gt;) (splitExtension x) == x
--   &gt; uncurry addExtension (splitExtension x) == x
--   &gt; splitExtension "file.txt" == ("file",".txt")
--   &gt; splitExtension "file" == ("file","")
--   &gt; splitExtension "file/file.txt" == ("file/file",".txt")
--   &gt; splitExtension "file.txt/boris" == ("file.txt/boris","")
--   &gt; splitExtension "file.txt/boris.ext" == ("file.txt/boris",".ext")
--   &gt; splitExtension "file/path.txt.bob.fred" == ("file/path.txt.bob",".fred")
--   </pre>
splitExtension :: FilePath ar -> (FilePath ar, String)

-- | Split on all extensions
--   
--   <pre>
--   &gt; splitExtensions "file.tar.gz" == ("file",".tar.gz")
--   </pre>
splitExtensions :: FilePath ar -> (FilePath ar, String)
splitFileName :: Path ar fd -> (DirPath ar, RelPath fd)

-- | Get the basename of a file
--   
--   <pre>
--   &gt; takeBaseName "/tmp/somedir/myfile.txt" == "myfile"
--   &gt; takeBaseName "./myfile.txt" == "myfile"
--   &gt; takeBaseName "myfile.txt" == "myfile"
--   </pre>
takeBaseName :: Path ar fd -> RelPath fd
takeDirectory :: Path ar fd -> DirPath ar

-- | Get the extension of a file, returns <tt>""</tt> for no extension,
--   <tt>.ext</tt> otherwise.
--   
--   <pre>
--   &gt; takeExtension x == snd (splitExtension x)
--   &gt; takeExtension (addExtension x "ext") == ".ext"
--   &gt; takeExtension (replaceExtension x "ext") == ".ext"
--   </pre>
takeExtension :: FilePath ar -> String

-- | Get all extensions
--   
--   <pre>
--   &gt; takeExtensions "file.tar.gz" == ".tar.gz"
--   </pre>
takeExtensions :: FilePath ar -> String

-- | Get the filename component of a file path (ie stripping all parent
--   dirs)
--   
--   <pre>
--   &gt; takeFileName "/tmp/somedir/myfile.txt" == "myfile.txt"
--   &gt; takeFileName "./myfile.txt" == "myfile.txt"
--   &gt; takeFileName "myfile.txt" == "myfile.txt"
--   </pre>
takeFileName :: Path ar fd -> RelPath fd

-- | Check whether two strings are equal as file paths.
--   
--   <pre>
--   &gt; equalFilePath "/tmp/" "/tmp" == True
--   &gt; equalFilePath "/tmp"  "tmp"  == False
--   </pre>
equalFilePath :: String -> String -> Bool

-- | Constructs a <a>Path</a> from a list of components.
--   
--   <pre>
--   &gt; joinPath ["/tmp","someDir","file.txt"] == "/tmp/someDir/file.txt"
--   &gt; (joinPath ["/tmp","someDir","file.txt"] :: RelFile) == "tmp/someDir/file.txt"
--   </pre>
joinPath :: [String] -> Path ar fd

-- | Currently just transforms:
--   
--   <pre>
--   &gt; normalise "/tmp/fred/./jim/./file" == "/tmp/fred/jim/file"
--   </pre>
normalise :: Path ar fd -> Path ar fd

-- | Deconstructs a path into its components.
--   
--   <pre>
--   &gt; splitPath ("/tmp/someDir/myfile.txt" :: AbsDir)  == (["tmp","someDir","myfile.txt"],Nothing)
--   &gt; splitPath ("/tmp/someDir/myfile.txt" :: AbsFile) == (["tmp","someDir"],Just "myfile.txt")
--   &gt; splitPath (asAbsFile "/tmp/someDir/myfile.txt")  == (["tmp","someDir"],Just "myfile.txt")
--   </pre>
splitPath :: FileDirClass fd => Path ar fd -> ([RelDir], Maybe RelFile)

-- | This function can be used to construct a relative path by removing the
--   supplied <a>AbsDir</a> from the front. It is a runtime <a>error</a> if
--   the supplied <a>AbsPath</a> doesn't start with the <a>AbsDir</a>.
--   
--   <pre>
--   &gt; makeRelative "/tmp/somedir" "/tmp/somedir/anotherdir/file.txt" == "anotherdir/file.txt"
--   </pre>
makeRelative :: AbsDir -> AbsPath fd -> RelPath fd

-- | Joins an absolute directory with a relative path to construct a new
--   absolute path.
--   
--   <pre>
--   &gt; makeAbsolute "/tmp" "file.txt"      == "/tmp/file.txt"
--   &gt; makeAbsolute "/tmp" "adir/file.txt" == "/tmp/adir/file.txt"
--   </pre>
makeAbsolute :: AbsDir -> RelPath fd -> AbsPath fd

-- | Converts a relative path into an absolute one by prepending the
--   current working directory.
makeAbsoluteFromCwd :: RelPath fd -> IO (AbsPath fd)

-- | As for <a>makeAbsolute</a>, but for use when the path may already be
--   absolute (in which case it is left unchanged).
--   
--   <pre>
--   &gt; genericMakeAbsolute "/tmp" (asRelFile "file.txt")       == "/tmp/file.txt"
--   &gt; genericMakeAbsolute "/tmp" (asRelFile "adir/file.txt")  == "/tmp/adir/file.txt"
--   &gt; genericMakeAbsolute "/tmp" (asAbsFile "adir/file.txt")  == "/adir/file.txt"
--   &gt; genericMakeAbsolute "/tmp" (asAbsFile "/adir/file.txt") == "/adir/file.txt"
--   </pre>
genericMakeAbsolute :: AbsRelClass ar => AbsDir -> Path ar fd -> AbsPath fd

-- | As for <a>makeAbsoluteFromCwd</a>, but for use when the path may
--   already be absolute (in which case it is left unchanged).
genericMakeAbsoluteFromCwd :: AbsRelClass ar => Path ar fd -> IO (AbsPath fd)

-- | Map over the components of the path.
--   
--   <pre>
--   &gt; pathMap (map toLower) "/tmp/Reports/SpreadSheets" == "/tmp/reports/spreadsheets"
--   </pre>
pathMap :: (String -> String) -> Path ar fd -> Path ar fd

-- | Test whether a <tt><a>Path</a> ar fd</tt> is absolute.
--   
--   <pre>
--   &gt; isAbsolute (asAbsFile "fred")  == True
--   &gt; isAbsolute (asRelFile "fred")  == False
--   &gt; isAbsolute (asAbsFile "/fred") == True
--   &gt; isAbsolute (asRelFile "/fred") == False
--   </pre>
isAbsolute :: AbsRelClass ar => Path ar fd -> Bool

-- | Test whether the <a>String</a> would correspond to an absolute path if
--   interpreted as a <a>Path</a>.
isAbsoluteString :: String -> Bool

-- | Invariant - this should return True iff arg is of type <tt><a>Path</a>
--   Rel _</tt>
--   
--   <pre>
--   isRelative = not . isAbsolute
--   </pre>
isRelative :: AbsRelClass ar => Path ar fd -> Bool

-- | Test whether the <a>String</a> would correspond to a relative path if
--   interpreted as a <a>Path</a>.
--   
--   <pre>
--   isRelativeString = not . isAbsoluteString
--   </pre>
isRelativeString :: String -> Bool

-- | Does the given filename have an extension?
--   
--   <pre>
--   &gt; null (takeExtension x) == not (hasAnExtension x)
--   </pre>
hasAnExtension :: FilePath ar -> Bool

-- | Does the given filename have the given extension?
--   
--   <pre>
--   &gt; hasExtension ".hs" "MyCode.hs" == True
--   &gt; hasExtension ".hs" "MyCode.hs.bak" == False
--   &gt; hasExtension ".hs" "MyCode.bak.hs" == True
--   </pre>
hasExtension :: String -> FilePath ar -> Bool

-- | This is largely for <a>FilePath</a> compatability
addTrailingPathSeparator :: String -> String

-- | This is largely for <a>FilePath</a> compatability
dropTrailingPathSeparator :: String -> String

-- | File extension character
--   
--   <pre>
--   &gt; extSeparator == '.'
--   </pre>
extSeparator :: Char

-- | This is largely for <a>FilePath</a> compatability
hasTrailingPathSeparator :: String -> Bool

-- | The character that separates directories. In the case where more than
--   one character is possible, <a>pathSeparator</a> is the 'ideal' one.
--   
--   <pre>
--   &gt; isPathSeparator pathSeparator
--   </pre>
pathSeparator :: Char

-- | The list of all possible separators.
--   
--   <pre>
--   &gt; pathSeparator `elem` pathSeparators
--   </pre>
pathSeparators :: [Char]

-- | The character that is used to separate the entries in the $PATH
--   environment variable.
searchPathSeparator :: Char

-- | Is the character an extension character?
--   
--   <pre>
--   &gt; isExtSeparator a == (a == extSeparator)
--   </pre>
isExtSeparator :: Char -> Bool

-- | Rather than using <tt>(== <a>pathSeparator</a>)</tt>, use this. Test
--   if something is a path separator.
--   
--   <pre>
--   &gt; isPathSeparator a == (a `elem` pathSeparators)
--   </pre>
isPathSeparator :: Char -> Bool

-- | Is the character a file separator?
--   
--   <pre>
--   &gt; isSearchPathSeparator a == (a == searchPathSeparator)
--   </pre>
isSearchPathSeparator :: Char -> Bool

-- | This is a more flexible variant of <a>addExtension</a> /
--   <a>&lt;.&gt;</a> which can work with files or directories
--   
--   <pre>
--   &gt; genericAddExtension "/" "x" == "/.x"
--   </pre>
genericAddExtension :: Path ar fd -> String -> Path ar fd
genericDropExtension :: Path ar fd -> Path ar fd
genericDropExtensions :: Path ar fd -> Path ar fd
genericSplitExtension :: Path ar fd -> (Path ar fd, String)
genericSplitExtensions :: Path ar fd -> (Path ar fd, String)
genericTakeExtension :: Path ar fd -> String
genericTakeExtensions :: Path ar fd -> String
instance Eq PathComponent
instance Ord PathComponent
instance Eq (Path ar fd)
instance Ord (Path ar fd)
instance Arbitrary (Path ar Dir)
instance Arbitrary (Path ar File)
instance Arbitrary PathComponent
instance IsString (Path ar fd)
instance AbsRelClass ar => Read (Path ar fd)
instance AbsRelClass ar => Show (Path ar fd)
instance FileDirClass Dir
instance FileDirClass File
instance AbsRelClass Rel
instance AbsRelClass Abs
instance Private Dir
instance Private File
instance Private Rel
instance Private Abs
instance Show PathComponent


-- | This module provides type-safe access to filepath manipulations.
--   
--   Normally you would import <a>Path</a> (which will use the default
--   implementation for the host platform) instead of this. However,
--   importing this explicitly allows for manipulation of non-native paths.
module System.Path.Posix

-- | This is the main filepath abstract datatype
data Path ar fd
data Abs
data Rel
data File
data Dir
type AbsFile = Path Abs File
type RelFile = Path Rel File
type AbsDir = Path Abs Dir
type RelDir = Path Rel Dir
type AbsPath fd = Path Abs fd
type RelPath fd = Path Rel fd
type FilePath ar = Path ar File
type DirPath ar = Path ar Dir

-- | This class allows selective behaviour for absolute and relative paths
--   and is mostly for internal use.
class Private ar => AbsRelClass ar
absRel :: AbsRelClass ar => (AbsPath fd -> a) -> (RelPath fd -> a) -> Path ar fd -> a

-- | This class allows selective behaviour for file and directory paths and
--   is mostly for internal use.
class Private fd => FileDirClass fd
fileDir :: FileDirClass fd => (FilePath ar -> a) -> (DirPath ar -> a) -> Path ar fd -> a

-- | Convert the <a>Path</a> into a plain <a>String</a>. This is simply an
--   alias for <a>show</a>.
getPathString :: AbsRelClass ar => Path ar fd -> String
rootDir :: AbsDir
currentDir :: RelDir

-- | Use a <a>String</a> as a <a>Path</a> whose type is determined by its
--   context.
--   
--   <pre>
--   &gt; asPath "/tmp" == "/tmp"
--   &gt; asPath "file.txt" == "file.txt"
--   &gt; isAbsolute (asPath "/tmp" :: AbsDir) == True
--   &gt; isAbsolute (asPath "/tmp" :: RelDir) == False
--   &gt; getPathString (asPath "/tmp" :: AbsDir) == "/tmp"
--   &gt; getPathString (asPath "/tmp" :: RelDir) == "tmp"
--   </pre>
asPath :: String -> Path ar fd

-- | Use a <a>String</a> as a <a>RelFile</a>. No checking is done.
--   
--   <pre>
--   &gt; getPathString (asRelFile "file.txt") == "file.txt"
--   &gt; getPathString (asRelFile "/file.txt") == "file.txt"
--   &gt; getPathString (asRelFile "tmp") == "tmp"
--   &gt; getPathString (asRelFile "/tmp") == "tmp"
--   </pre>
asRelFile :: String -> RelFile

-- | Use a <a>String</a> as a <a>RelDir</a>. No checking is done.
--   
--   <pre>
--   &gt; getPathString (asRelDir "file.txt") == "file.txt"
--   &gt; getPathString (asRelDir "/file.txt") == "file.txt"
--   &gt; getPathString (asRelDir "tmp") == "tmp"
--   &gt; getPathString (asRelDir "/tmp") == "tmp"
--   </pre>
asRelDir :: String -> RelDir

-- | Use a <a>String</a> as an <a>AbsFile</a>. No checking is done.
--   
--   <pre>
--   &gt; getPathString (asAbsFile "file.txt") == "/file.txt"
--   &gt; getPathString (asAbsFile "/file.txt") == "/file.txt"
--   &gt; getPathString (asAbsFile "tmp") == "/tmp"
--   &gt; getPathString (asAbsFile "/tmp") == "/tmp"
--   </pre>
asAbsFile :: String -> AbsFile

-- | Use a <a>String</a> as an <a>AbsDir</a>. No checking is done.
--   
--   <pre>
--   &gt; getPathString (asAbsDir "file.txt") == "/file.txt"
--   &gt; getPathString (asAbsDir "/file.txt") == "/file.txt"
--   &gt; getPathString (asAbsDir "tmp") == "/tmp"
--   &gt; getPathString (asAbsDir "/tmp") == "/tmp"
--   </pre>
asAbsDir :: String -> AbsDir

-- | Use a <a>String</a> as a 'RelPath fd'. No checking is done.
asRelPath :: String -> RelPath fd

-- | Use a <a>String</a> as an 'AbsPath fd'. No checking is done.
asAbsPath :: String -> AbsPath fd

-- | Use a <a>String</a> as a 'FilePath ar'. No checking is done.
asFilePath :: String -> FilePath ar

-- | Use a <a>String</a> as a 'DirPath ar'. No checking is done.
asDirPath :: String -> DirPath ar

-- | Examines the supplied string and constructs an absolute or relative
--   path as appropriate.
--   
--   <pre>
--   &gt; either id (const "fred") (mkPathAbsOrRel "/tmp") == "/tmp"
--   &gt; either id (const "fred") (mkPathAbsOrRel  "tmp") == "fred"
--   </pre>
mkPathAbsOrRel :: String -> Either (AbsPath fd) (RelPath fd)

-- | Searches for a file or directory with the supplied path string and
--   returns a <a>File</a> or <a>Dir</a> path as appropriate. If neither
--   exists at the supplied path, <a>Nothing</a> is returned.
mkPathFileOrDir :: AbsRelClass ar => String -> IO (Maybe (Either (FilePath ar) (DirPath ar)))

-- | Convert a <a>String</a> into an <a>AbsPath</a> by interpreting it as
--   relative to the supplied directory if necessary.
--   
--   <pre>
--   &gt; mkAbsPath "/tmp" "foo.txt" == "/tmp/foo.txt"
--   &gt; mkAbsPath "/tmp" "/etc/foo.txt" == "/etc/foo.txt"
--   </pre>
mkAbsPath :: AbsDir -> String -> AbsPath fd

-- | Convert a <a>String</a> into an <a>AbsPath</a> by interpreting it as
--   relative to the cwd if necessary.
mkAbsPathFromCwd :: String -> IO (AbsPath fd)

-- | Join an (absolute or relative) directory path with a relative (file or
--   directory) path to form a new path.
(</>) :: DirPath ar -> RelPath fd -> Path ar fd

-- | We only allow files (and not directories) to have extensions added by
--   this function. This is because it's the vastly common case and an
--   attempt to add one to a directory will - more often than not -
--   represent an error. We don't however want to prevent the corresponding
--   operation on directories, and so we provide a function that is more
--   flexible: <a>genericAddExtension</a>.
(<.>) :: FilePath ar -> String -> FilePath ar

-- | Add an extension, even if there is already one there. E.g.
--   <tt>addExtension "foo.txt" "bat" -&gt; "foo.txt.bat"</tt>.
--   
--   <pre>
--   &gt; addExtension "file.txt" "bib" == "file.txt.bib"
--   &gt; addExtension "file." ".bib" == "file..bib"
--   &gt; addExtension "file" ".bib" == "file.bib"
--   &gt; takeFileName (addExtension "" "ext") == ".ext"
--   </pre>
addExtension :: FilePath ar -> String -> FilePath ar

-- | Join an (absolute or relative) directory path with a relative (file or
--   directory) path to form a new path.
combine :: DirPath ar -> RelPath fd -> Path ar fd

-- | Remove last extension, and the "." preceding it.
--   
--   <pre>
--   &gt; dropExtension x == fst (splitExtension x)
--   </pre>
dropExtension :: FilePath ar -> FilePath ar

-- | Drop all extensions
--   
--   <pre>
--   &gt; not $ hasAnExtension (dropExtensions x)
--   </pre>
dropExtensions :: FilePath ar -> FilePath ar
dropFileName :: Path ar fd -> DirPath ar

-- | Set the extension of a file, overwriting one if already present.
--   
--   <pre>
--   &gt; replaceExtension "file.txt" ".bob" == "file.bob"
--   &gt; replaceExtension "file.txt" "bob" == "file.bob"
--   &gt; replaceExtension "file" ".bob" == "file.bob"
--   &gt; replaceExtension "file.txt" "" == "file"
--   &gt; replaceExtension "file.fred.bob" "txt" == "file.fred.txt"
--   </pre>
replaceExtension :: FilePath ar -> String -> FilePath ar
replaceBaseName :: Path ar fd -> String -> Path ar fd
replaceDirectory :: Path ar1 fd -> DirPath ar2 -> Path ar2 fd
replaceFileName :: Path ar fd -> String -> Path ar fd

-- | Split on the extension. <a>addExtension</a> is the inverse.
--   
--   <pre>
--   &gt; uncurry (&lt;.&gt;) (splitExtension x) == x
--   &gt; uncurry addExtension (splitExtension x) == x
--   &gt; splitExtension "file.txt" == ("file",".txt")
--   &gt; splitExtension "file" == ("file","")
--   &gt; splitExtension "file/file.txt" == ("file/file",".txt")
--   &gt; splitExtension "file.txt/boris" == ("file.txt/boris","")
--   &gt; splitExtension "file.txt/boris.ext" == ("file.txt/boris",".ext")
--   &gt; splitExtension "file/path.txt.bob.fred" == ("file/path.txt.bob",".fred")
--   </pre>
splitExtension :: FilePath ar -> (FilePath ar, String)

-- | Split on all extensions
--   
--   <pre>
--   &gt; splitExtensions "file.tar.gz" == ("file",".tar.gz")
--   </pre>
splitExtensions :: FilePath ar -> (FilePath ar, String)
splitFileName :: Path ar fd -> (DirPath ar, RelPath fd)

-- | Get the basename of a file
--   
--   <pre>
--   &gt; takeBaseName "/tmp/somedir/myfile.txt" == "myfile"
--   &gt; takeBaseName "./myfile.txt" == "myfile"
--   &gt; takeBaseName "myfile.txt" == "myfile"
--   </pre>
takeBaseName :: Path ar fd -> RelPath fd
takeDirectory :: Path ar fd -> DirPath ar

-- | Get the extension of a file, returns <tt>""</tt> for no extension,
--   <tt>.ext</tt> otherwise.
--   
--   <pre>
--   &gt; takeExtension x == snd (splitExtension x)
--   &gt; takeExtension (addExtension x "ext") == ".ext"
--   &gt; takeExtension (replaceExtension x "ext") == ".ext"
--   </pre>
takeExtension :: FilePath ar -> String

-- | Get all extensions
--   
--   <pre>
--   &gt; takeExtensions "file.tar.gz" == ".tar.gz"
--   </pre>
takeExtensions :: FilePath ar -> String

-- | Get the filename component of a file path (ie stripping all parent
--   dirs)
--   
--   <pre>
--   &gt; takeFileName "/tmp/somedir/myfile.txt" == "myfile.txt"
--   &gt; takeFileName "./myfile.txt" == "myfile.txt"
--   &gt; takeFileName "myfile.txt" == "myfile.txt"
--   </pre>
takeFileName :: Path ar fd -> RelPath fd

-- | Check whether two strings are equal as file paths.
--   
--   <pre>
--   &gt; equalFilePath "/tmp/" "/tmp" == True
--   &gt; equalFilePath "/tmp"  "tmp"  == False
--   </pre>
equalFilePath :: String -> String -> Bool

-- | Constructs a <a>Path</a> from a list of components.
--   
--   <pre>
--   &gt; joinPath ["/tmp","someDir","file.txt"] == "/tmp/someDir/file.txt"
--   &gt; (joinPath ["/tmp","someDir","file.txt"] :: RelFile) == "tmp/someDir/file.txt"
--   </pre>
joinPath :: [String] -> Path ar fd

-- | Currently just transforms:
--   
--   <pre>
--   &gt; normalise "/tmp/fred/./jim/./file" == "/tmp/fred/jim/file"
--   </pre>
normalise :: Path ar fd -> Path ar fd

-- | Deconstructs a path into its components.
--   
--   <pre>
--   &gt; splitPath ("/tmp/someDir/myfile.txt" :: AbsDir)  == (["tmp","someDir","myfile.txt"],Nothing)
--   &gt; splitPath ("/tmp/someDir/myfile.txt" :: AbsFile) == (["tmp","someDir"],Just "myfile.txt")
--   &gt; splitPath (asAbsFile "/tmp/someDir/myfile.txt")  == (["tmp","someDir"],Just "myfile.txt")
--   </pre>
splitPath :: FileDirClass fd => Path ar fd -> ([RelDir], Maybe RelFile)

-- | This function can be used to construct a relative path by removing the
--   supplied <a>AbsDir</a> from the front. It is a runtime <a>error</a> if
--   the supplied <a>AbsPath</a> doesn't start with the <a>AbsDir</a>.
--   
--   <pre>
--   &gt; makeRelative "/tmp/somedir" "/tmp/somedir/anotherdir/file.txt" == "anotherdir/file.txt"
--   </pre>
makeRelative :: AbsDir -> AbsPath fd -> RelPath fd

-- | Joins an absolute directory with a relative path to construct a new
--   absolute path.
--   
--   <pre>
--   &gt; makeAbsolute "/tmp" "file.txt"      == "/tmp/file.txt"
--   &gt; makeAbsolute "/tmp" "adir/file.txt" == "/tmp/adir/file.txt"
--   </pre>
makeAbsolute :: AbsDir -> RelPath fd -> AbsPath fd

-- | Converts a relative path into an absolute one by prepending the
--   current working directory.
makeAbsoluteFromCwd :: RelPath fd -> IO (AbsPath fd)

-- | As for <a>makeAbsolute</a>, but for use when the path may already be
--   absolute (in which case it is left unchanged).
--   
--   <pre>
--   &gt; genericMakeAbsolute "/tmp" (asRelFile "file.txt")       == "/tmp/file.txt"
--   &gt; genericMakeAbsolute "/tmp" (asRelFile "adir/file.txt")  == "/tmp/adir/file.txt"
--   &gt; genericMakeAbsolute "/tmp" (asAbsFile "adir/file.txt")  == "/adir/file.txt"
--   &gt; genericMakeAbsolute "/tmp" (asAbsFile "/adir/file.txt") == "/adir/file.txt"
--   </pre>
genericMakeAbsolute :: AbsRelClass ar => AbsDir -> Path ar fd -> AbsPath fd

-- | As for <a>makeAbsoluteFromCwd</a>, but for use when the path may
--   already be absolute (in which case it is left unchanged).
genericMakeAbsoluteFromCwd :: AbsRelClass ar => Path ar fd -> IO (AbsPath fd)

-- | Map over the components of the path.
--   
--   <pre>
--   &gt; pathMap (map toLower) "/tmp/Reports/SpreadSheets" == "/tmp/reports/spreadsheets"
--   </pre>
pathMap :: (String -> String) -> Path ar fd -> Path ar fd

-- | Test whether a <tt><a>Path</a> ar fd</tt> is absolute.
--   
--   <pre>
--   &gt; isAbsolute (asAbsFile "fred")  == True
--   &gt; isAbsolute (asRelFile "fred")  == False
--   &gt; isAbsolute (asAbsFile "/fred") == True
--   &gt; isAbsolute (asRelFile "/fred") == False
--   </pre>
isAbsolute :: AbsRelClass ar => Path ar fd -> Bool

-- | Test whether the <a>String</a> would correspond to an absolute path if
--   interpreted as a <a>Path</a>.
isAbsoluteString :: String -> Bool

-- | Invariant - this should return True iff arg is of type <tt><a>Path</a>
--   Rel _</tt>
--   
--   <pre>
--   isRelative = not . isAbsolute
--   </pre>
isRelative :: AbsRelClass ar => Path ar fd -> Bool

-- | Test whether the <a>String</a> would correspond to a relative path if
--   interpreted as a <a>Path</a>.
--   
--   <pre>
--   isRelativeString = not . isAbsoluteString
--   </pre>
isRelativeString :: String -> Bool

-- | Does the given filename have an extension?
--   
--   <pre>
--   &gt; null (takeExtension x) == not (hasAnExtension x)
--   </pre>
hasAnExtension :: FilePath ar -> Bool

-- | Does the given filename have the given extension?
--   
--   <pre>
--   &gt; hasExtension ".hs" "MyCode.hs" == True
--   &gt; hasExtension ".hs" "MyCode.hs.bak" == False
--   &gt; hasExtension ".hs" "MyCode.bak.hs" == True
--   </pre>
hasExtension :: String -> FilePath ar -> Bool

-- | This is largely for <a>FilePath</a> compatability
addTrailingPathSeparator :: String -> String

-- | This is largely for <a>FilePath</a> compatability
dropTrailingPathSeparator :: String -> String

-- | File extension character
--   
--   <pre>
--   &gt; extSeparator == '.'
--   </pre>
extSeparator :: Char

-- | This is largely for <a>FilePath</a> compatability
hasTrailingPathSeparator :: String -> Bool

-- | The character that separates directories. In the case where more than
--   one character is possible, <a>pathSeparator</a> is the 'ideal' one.
--   
--   <pre>
--   &gt; isPathSeparator pathSeparator
--   </pre>
pathSeparator :: Char

-- | The list of all possible separators.
--   
--   <pre>
--   &gt; pathSeparator `elem` pathSeparators
--   </pre>
pathSeparators :: [Char]

-- | The character that is used to separate the entries in the $PATH
--   environment variable.
searchPathSeparator :: Char

-- | Is the character an extension character?
--   
--   <pre>
--   &gt; isExtSeparator a == (a == extSeparator)
--   </pre>
isExtSeparator :: Char -> Bool

-- | Rather than using <tt>(== <a>pathSeparator</a>)</tt>, use this. Test
--   if something is a path separator.
--   
--   <pre>
--   &gt; isPathSeparator a == (a `elem` pathSeparators)
--   </pre>
isPathSeparator :: Char -> Bool

-- | Is the character a file separator?
--   
--   <pre>
--   &gt; isSearchPathSeparator a == (a == searchPathSeparator)
--   </pre>
isSearchPathSeparator :: Char -> Bool

-- | This is a more flexible variant of <a>addExtension</a> /
--   <a>&lt;.&gt;</a> which can work with files or directories
--   
--   <pre>
--   &gt; genericAddExtension "/" "x" == "/.x"
--   </pre>
genericAddExtension :: Path ar fd -> String -> Path ar fd
genericDropExtension :: Path ar fd -> Path ar fd
genericDropExtensions :: Path ar fd -> Path ar fd
genericSplitExtension :: Path ar fd -> (Path ar fd, String)
genericSplitExtensions :: Path ar fd -> (Path ar fd, String)
genericTakeExtension :: Path ar fd -> String
genericTakeExtensions :: Path ar fd -> String
instance Eq PathComponent
instance Ord PathComponent
instance Eq (Path ar fd)
instance Ord (Path ar fd)
instance Arbitrary (Path ar Dir)
instance Arbitrary (Path ar File)
instance Arbitrary PathComponent
instance IsString (Path ar fd)
instance AbsRelClass ar => Read (Path ar fd)
instance AbsRelClass ar => Show (Path ar fd)
instance FileDirClass Dir
instance FileDirClass File
instance AbsRelClass Rel
instance AbsRelClass Abs
instance Private Dir
instance Private File
instance Private Rel
instance Private Abs
instance Show PathComponent


-- | This module provides type-safe access to filepath manipulations.
--   
--   It is designed to be imported instead of <a>System.FilePath</a>. (It
--   is intended to provide versions of functions from that module which
--   have equivalent functionality but are more typesafe).
--   <a>System.Path.Directory</a> is a companion module providing a
--   type-safe alternative to <a>System.Directory</a>.
--   
--   The heart of this module is the <tt><a>Path</a> ar fd</tt> abstract
--   type which represents file and directory paths. The idea is that there
--   are two phantom type parameters - the first should be <a>Abs</a> or
--   <a>Rel</a>, and the second <a>File</a> or <a>Dir</a>. A number of type
--   synonyms are provided for common types:
--   
--   <pre>
--   type AbsFile     = Path Abs File
--   type RelFile     = Path Rel File
--   type AbsDir      = Path Abs Dir
--   type RelDir      = Path Rel Dir
--   
--   type AbsPath  fd = Path Abs fd
--   type RelPath  fd = Path Rel fd
--   type FilePath ar = Path ar File
--   type DirPath  ar = Path ar Dir
--   </pre>
--   
--   The type of the <a>combine</a> (aka <a>&lt;/&gt;</a>) function gives
--   the idea:
--   
--   <pre>
--   (&lt;/&gt;) :: DirPath ar -&gt; RelPath fd -&gt; Path ar fd
--   </pre>
--   
--   Together this enables us to give more meaningful types to a lot of the
--   functions, and (hopefully) catch a bunch more errors at compile time.
--   
--   Overloaded string literals are supported, so with the
--   <tt>OverloadedStrings</tt> extension enabled, you can:
--   
--   <pre>
--   f :: FilePath ar
--   f = "tmp" &lt;/&gt; "someFile" &lt;.&gt; "ext"
--   </pre>
--   
--   If you don't want to use <tt>OverloadedStrings</tt>, you can use the
--   construction fns:
--   
--   <pre>
--   f :: FilePath ar
--   f = asDirPath "tmp" &lt;/&gt; asFilePath "someFile" &lt;.&gt; "ext"
--   </pre>
--   
--   or...
--   
--   <pre>
--   f :: FilePath ar
--   f = asPath "tmp" &lt;/&gt; asPath "someFile" &lt;.&gt; "ext"
--   </pre>
--   
--   or just...
--   
--   <pre>
--   f :: FilePath ar
--   f = asPath "tmp/someFile.ext"
--   </pre>
--   
--   One point to note is that whether one of these is interpreted as an
--   absolute or a relative path depends on the type at which it is used:
--   
--   <pre>
--   *System.Path&gt; f :: AbsFile
--   /tmp/someFile.ext
--   *System.Path&gt; f :: RelFile
--   tmp/someFile.ext
--   </pre>
--   
--   You will typically want to import as follows:
--   
--   <pre>
--   import Prelude hiding (FilePath)
--   import System.Path
--   import System.Path.Directory
--   import System.Path.IO
--   </pre>
--   
--   The basic API (and properties satisfied) are heavily influenced by
--   Neil Mitchell's <a>System.FilePath</a> module.
--   
--   Ben Moseley - (c) 2009-2010
module System.Path


-- | This module provides type-safe access to directory manipulations.
--   
--   It is designed to be imported instead of <a>System.Directory</a>. (It
--   is intended to provide versions of functions from that module which
--   have equivalent functionality but are more typesafe).
--   <a>System.Path</a> is a companion module providing a type-safe
--   alternative to <a>System.FilePath</a>.
--   
--   You will typically want to import as follows:
--   
--   <pre>
--   import Prelude hiding (FilePath)
--   import System.Path
--   import System.Path.Directory
--   import System.Path.IO
--   </pre>
--   
--   Ben Moseley - (c) 2009
module System.Path.Directory
createDirectory :: AbsRelClass ar => DirPath ar -> IO ()
createDirectoryIfMissing :: AbsRelClass ar => Bool -> DirPath ar -> IO ()
removeDirectory :: AbsRelClass ar => DirPath ar -> IO ()
removeDirectoryRecursive :: AbsRelClass ar => DirPath ar -> IO ()
renameDirectory :: (AbsRelClass ar1, AbsRelClass ar2) => DirPath ar1 -> DirPath ar2 -> IO ()

-- | An alias for <a>relDirectoryContents</a>.
getDirectoryContents :: AbsRelClass ar => DirPath ar -> IO ([RelDir], [RelFile])

-- | Retrieve the contents of a directory path (which may be relative) as
--   absolute paths
absDirectoryContents :: AbsRelClass ar => DirPath ar -> IO ([AbsDir], [AbsFile])

-- | Returns paths relative <i>to</i> the supplied (abs or relative)
--   directory path. eg (for current working directory of
--   <tt>/somewhere/cwd/</tt>):
--   
--   <pre>
--   show (relDirectoryContents "d/e/f/") == (["subDir1A","subDir1B"],
--                                                        ["file1A","file1B"])
--   </pre>
relDirectoryContents :: AbsRelClass ar => DirPath ar -> IO ([RelDir], [RelFile])

-- | A convenient alternative to <a>relDirectoryContents</a> if you only
--   want files.
filesInDir :: AbsRelClass ar => DirPath ar -> IO [RelFile]

-- | A convenient alternative to <a>relDirectoryContents</a> if you only
--   want directories.
dirsInDir :: AbsRelClass ar => DirPath ar -> IO [RelDir]
getCurrentDirectory :: IO AbsDir
setCurrentDirectory :: AbsRelClass ar => DirPath ar -> IO ()
getHomeDirectory :: IO AbsDir
getAppUserDataDirectory :: String -> IO AbsDir
getUserDocumentsDirectory :: IO AbsDir
getTemporaryDirectory :: IO AbsDir
removeFile :: AbsRelClass ar => FilePath ar -> IO ()
renameFile :: (AbsRelClass ar1, AbsRelClass ar2) => FilePath ar1 -> FilePath ar2 -> IO ()
copyFile :: (AbsRelClass ar1, AbsRelClass ar2) => FilePath ar1 -> FilePath ar2 -> IO ()
canonicalizePath :: AbsRelClass ar => Path ar fd -> IO (AbsPath fd)
makeRelativeToCurrentDirectory :: AbsRelClass ar => Path ar fd -> IO (RelPath fd)
findExecutable :: String -> IO (Maybe AbsFile)
doesFileExist :: AbsRelClass ar => FilePath ar -> IO Bool
doesDirectoryExist :: AbsRelClass ar => DirPath ar -> IO Bool
data Permissions :: *
getPermissions :: AbsRelClass ar => Path ar fd -> IO Permissions
setPermissions :: AbsRelClass ar => Path ar fd -> Permissions -> IO ()
getModificationTime :: AbsRelClass ar => Path ar fd -> IO UTCTime


-- | This module provides type-safe access to IO operations.
--   
--   It is designed to be imported instead of <a>System.IO</a>. (It is
--   intended to provide versions of functions from that module which have
--   equivalent functionality but are more typesafe). <a>System.Path</a> is
--   a companion module providing a type-safe alternative to
--   <a>System.FilePath</a>.
--   
--   You will typically want to import as follows:
--   
--   <pre>
--   import Prelude hiding (FilePath)
--   import System.Path
--   import System.Path.Directory
--   import System.Path.IO
--   </pre>
--   
--   Ben Moseley - (c) 2009
module System.Path.IO
withFile :: AbsRelClass ar => Path ar fd -> IOMode -> (Handle -> IO r) -> IO r
openFile :: AbsRelClass ar => FilePath ar -> IOMode -> IO Handle
readFile :: AbsRelClass ar => FilePath ar -> IO String
writeFile :: AbsRelClass ar => FilePath ar -> String -> IO ()
appendFile :: AbsRelClass ar => FilePath ar -> String -> IO ()
withBinaryFile :: AbsRelClass ar => FilePath ar -> IOMode -> (Handle -> IO r) -> IO r
openBinaryFile :: AbsRelClass ar => FilePath ar -> IOMode -> IO Handle
openTempFile :: AbsRelClass ar => DirPath ar -> RelFile -> IO (AbsFile, Handle)
openBinaryTempFile :: AbsRelClass ar => DirPath ar -> RelFile -> IO (AbsFile, Handle)

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a :: * -> *
fixIO :: (a -> IO a) -> IO a

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle :: *

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | See <a>openFile</a>
data IOMode :: *
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
hClose :: Handle -> IO ()

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
hFileSize :: Handle -> IO Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
hSetFileSize :: Handle -> Integer -> IO ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it has to attempt to read from
--   the stream to determine whether there is any more data to be read.
hIsEOF :: Handle -> IO Bool

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode :: *

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer is
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
hSetBuffering :: Handle -> BufferMode -> IO ()

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
hGetBuffering :: Handle -> IO BufferMode

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isFullError</tt> if the device is full;</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
hFlush :: Handle -> IO ()

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
hGetPosn :: Handle -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()
data HandlePosn :: *

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not seekable, or
--   does not support the requested seek mode.</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode :: *

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Computation <a>hTell</a> <tt>hdl</tt> returns the current position of
--   the handle <tt>hdl</tt>, as the number of bytes from the beginning of
--   the file. The value returned may be subsequently passed to
--   <a>hSeek</a> to reposition the handle to the current position.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not
--   seekable.</li>
--   </ul>
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool
hIsSeekable :: Handle -> IO Bool

-- | Is the handle connected to a terminal?
hIsTerminalDevice :: Handle -> IO Bool

-- | Set the echoing status of a handle connected to a terminal.
hSetEcho :: Handle -> Bool -> IO ()

-- | Get the echoing status of a handle connected to a terminal.
hGetEcho :: Handle -> IO Bool

-- | <a>hShow</a> is in the <a>IO</a> monad, and gives more comprehensive
--   output than the (pure) instance of <a>Show</a> for <a>Handle</a>.
hShow :: Handle -> IO String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hReady</a> <tt>hdl</tt> indicates whether at least one
--   item is available for input from handle <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hReady :: Handle -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   If <a>hGetLine</a> encounters end-of-file at any other point while
--   reading in a line, it is treated as a line terminator and the
--   (partial) line is returned.
hGetLine :: Handle -> IO String

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isEOFError</tt> if the end of file has been reached.</li>
--   </ul>
hLookAhead :: Handle -> IO Char

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <tt>hClose</tt>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <tt>hClose</tt> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
hPutStrLn :: Handle -> String -> IO ()

-- | Computation <a>hPrint</a> <tt>hdl t</tt> writes the string
--   representation of <tt>t</tt> given by the <a>shows</a> function to the
--   file or channel managed by <tt>hdl</tt> and appends a newline.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPrint :: Show a => Handle -> a -> IO ()

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <tt>openBinaryFile</tt>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>char8</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
hSetBinaryMode :: Handle -> Bool -> IO ()

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <tt>TextEncoding</tt>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
