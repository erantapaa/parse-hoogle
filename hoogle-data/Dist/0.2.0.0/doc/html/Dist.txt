-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell library for probability distributions
--   
@package Dist
@version 0.2.0.0


-- | This module provides a data structure and associated functions for
--   representing discrete probability distributions.
--   
--   All time and space complexity metrics are given in terms of
--   <tt>n</tt>. In this case, <tt>n</tt> refers to the number of unique
--   outcomes inserted into the tree. If one were to construct a tree by
--   inserting a billion of the same outcome, <tt>n</tt> would still be 1.
--   
--   The data structure is optimized for fast sampling from the
--   distribution. Sampling ranges from <tt>O(1)</tt> to <tt>O(log(n))</tt>
--   depending on the distribution.
--   
--   Under the hood, the distribution is represented by a perfectly
--   balanced binary tree. The tree enforces a heap property, where more
--   likely outcomes are closer to the top than less likely outcomes.
--   Because we're more likely to sample from those outcomes, we minimize
--   the amount of time spent traversing the tree.
--   
--   When a duplicate outcome is inserted into the tree, the tree's "dups"
--   counter is incremented. When more than half the tree is duplicate
--   entries, the entire tree is rebuilt from scratch. Using amortized
--   complexity analysis, we can show that insertion is, at worst,
--   <tt>log(n)</tt> amortized complexity. This prevents the size of tree
--   from increasing to more than <tt>O(n)</tt>, even with many duplicate
--   outcomes inserted.
module Numeric.Probability.Distribution

-- | A probability distribution with probabilities of type <tt>p</tt> and
--   outcomes/events of type <tt>o</tt>.
data Distribution p o

-- | Take a sample from the distribution. Can be used with e.g.
--   <tt>evalRand</tt> or <tt>evalRandIO</tt> from
--   <tt>Control.Monad.Random</tt>. <tt>O(log(n))</tt> for a uniform
--   distribution (worst case), but approaches <tt>O(1)</tt> with less
--   balanced distributions.
sample :: (Ord p, Num p, Random p, MonadRandom m) => Distribution p o -> m o

-- | The sum of all probabilities in the distribution. <tt>O(1)</tt>
cumulate :: Num p => Distribution p o -> p

-- | Normalizes the distribution. After normalizing, <tt><a>cumulate</a>
--   distribution</tt> is 1. <tt>O(n)</tt>
normalize :: Fractional p => Distribution p o -> Distribution p o

-- | The empty distribution. <tt>O(1)</tt>
empty :: Num p => Distribution p o

-- | Insert an outcome into the distribution. Inserting <tt>(o,p1)</tt> and
--   <tt>(o,p2)</tt> results in the same sampled distribution as inserting
--   <tt>(o,p1+p2)</tt>. <tt>O(log(n))</tt> amortized.
insert :: (Ord o, Num p, Ord p) => (o, p) -> Distribution p o -> Distribution p o

-- | <tt>O(n*log(n))</tt> amortized.
fromList :: (Ord o, Num p, Ord p) => [(o, p)] -> Distribution p o

-- | Reweights the probabilities in the distribution based on the given
--   function. <tt>n*log(n)</tt>
reweight :: (Ord o, Num p, Ord p) => ((o, p) -> p) -> Distribution p o -> Distribution p o

-- | <tt>O(n*log(n))</tt>.
toList :: (Ord o, Num p) => Distribution p o -> [(o, p)]

-- | A right-associative fold on the tree structure, including the
--   probabilities. Note that outcomes may be repeated within the data
--   structure. If you want identical outcomes to be lumped together, fold
--   on the list produced by <tt><a>toList</a></tt>. <tt>O(n)</tt>.
foldrWithP :: ((o, p) -> b -> b) -> b -> Distribution p o -> b

-- | Creates a new distribution that's the joint distribution of the two
--   provided. <tt>O(nm*log(nm))</tt> amortized.
joint :: (Ord o1, Ord o2, Num p, Ord p) => Distribution p o1 -> Distribution p o2 -> Distribution p (o1, o2)

-- | Creates a new distribution by summing the probabilities of the
--   outcomes in the two provided. <tt>O((n+m)log(n+m))</tt> amortized.
sum :: (Ord o, Num p, Ord p) => Distribution p o -> Distribution p o -> Distribution p o

-- | A series of tests on the internal structure of the distribution. For
--   debugging purposes.
invariants :: (Num p, Ord p, Show p, Ord e, Show e) => Distribution p e -> Either String ()
instance (Num p, Show p, Ord o, Show o) => Show (Distribution p o)
