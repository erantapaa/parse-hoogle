-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A testing framework inspired by QuickCheck and SmallCheck
--   
--   This framework provides functionality for testing Haskell functions
--   against properties, similar to QuickCheck, but allowing different test
--   data generation strategies for different structures, and even within
--   the same structure using composition strategies. Reporting, test case
--   scheduling and data generation modules can be assembled to customize
--   the test program based on the situation.
--   
--   Test data generation is based on combinatorial theory and uses
--   explicit enumeration of regular polynomial types, combined with
--   selection strategies to build data generators. Generators can be
--   composed or combined in parallel to create composite strategies for
--   data sampling.
@package gencheck
@version 0.1.1

module Test.GenCheck.Base.LabelledPartition
class (Foldable (c k), Functor v) => LabelledPartition c k v where map f = fold (\ k x lys -> insert k (f k x) lys) empty
empty :: LabelledPartition c k v => c k (v a)
new :: (LabelledPartition c k v, Ord k) => k -> [a] -> c k (v a)
size :: LabelledPartition c k v => c k (v a) -> Int
insert :: (LabelledPartition c k v, Ord k) => k -> a -> c k (v a) -> c k (v a)
lookup :: (LabelledPartition c k v, Ord k) => k -> c k (v a) -> Maybe (v a)
merge :: (LabelledPartition c k v, Ord k, Monoid (v a)) => c k (v a) -> c k (v a) -> c k (v a)
map :: (LabelledPartition c k v, Ord k) => (k -> a -> r) -> c k (v a) -> c k (v r)
fold :: LabelledPartition c k v => (k -> a -> b -> b) -> b -> c k (v a) -> b
toList :: LabelledPartition c k v => c k (v a) -> [(k, v a)]
fromList :: (LabelledPartition c k v, Ord k, Monoid (v a)) => [(k, [a])] -> c k (v a)
relabel :: (LabelledPartition c k v, LabelledPartition c k' v, Ord k') => (k -> a -> k') -> c k (v a) -> c k' (v a)
filter :: (LabelledPartition c k v, Ord k) => (k -> a -> Bool) -> c k (v a) -> c k (v a)
instance Ord k => LabelledPartition Map k []
instance (LabelledPartition c k v, Ord k, Monoid (v r)) => Monoid (c k (v r))

module Test.GenCheck.Base.Verdict
class Verdict s
verdict :: Verdict s => s -> Bool
class Foldable s => SummaryVerdict s
summaryverdict :: (SummaryVerdict s, Verdict v) => s v -> Bool
instance Verdict Bool

module Test.GenCheck.Base.Datum
class Datum t where type family DataType t :: *
datum :: Datum t => t -> DataType t
instance Datum (Identity a)

module Test.GenCheck.System.Result
dspVerdict :: (LabelledPartition c k v, Verdict r, DetailedResult (c k) v r) => String -> c k (v r) -> IO (Bool)
dspSummary :: (Datum r, Show k, Show (v (DataType r)), LabelledPartition c k v, DetailedResult (c k) v r) => String -> c k (v r) -> IO ()
dspDetails :: (Datum r, Show k, Show (v r), LabelledPartition c k v, DetailedResult (c k) v r) => String -> c k (v r) -> IO ()
class (Verdict r, Datum r) => DetailedResult c v r
cases :: DetailedResult c v r => c (v r) -> c (v (DataType r))
failures :: DetailedResult c v r => c (v r) -> c (v r)
result :: (LabelledPartition c k v, Verdict r) => c k (v r) -> Bool
resultPartial :: (LabelledPartition c k v, SummaryVerdict v, Ord k, Verdict r) => c k (v r) -> k -> Bool
instance (LabelledPartition c k v, Verdict r, Datum r, Ord k, Functor v, Functor (c k)) => DetailedResult (c k) v r

module Test.GenCheck.Base.Base
type Rank = Int
type Count = Integer
type Property a = a -> Bool


-- | Rational|, |Float| and |Double|. These `<tt>scalar'</tt> types require
--   some additional structure. Most of the base type enumeration functions
--   are in BaseTypeEnum.lhs.
--   
--   All Haskell regular polynomial structure types can be enumerated by
--   rank (size) using a mechanical algorithm based solely on the type
--   constructor. These enumerations are constructed using the combinators
--   eConst, eNode, eSum, eProd, etc. to mirror the type's constructor.
--   Recursive structure enumerations should also be memoized to improve
--   their performance since the count / selection of value at rank r is
--   dependent on the count / selection of values at ranks $1$ through
--   $(r-1)$. The eMemoize function provides the default memoization;
--   additional memoization techniques are also provided in Memoize.lhs
--   
--   Note: the Enumeration class differs from Haskell's Enum class in that
--   the index of the enumerated value is unrecoverable, so the methods
--   succ, pred, enumToInt, etc. are not required for the Enumeration
--   instances.
module Test.GenCheck.Generator.Enumeration
data Enumeration c a
class Functor c => Enumerated c where enumFromTo (l, u) = enumRange (l, u) enumeration
enumeration :: Enumerated c => Enumeration c Label
enumFromTo :: Enumerated c => (Integer, Integer) -> Enumeration c Label

-- | mkEnumeration| applies a default memoization strategy to both the
--   counter and selector functions. |mkEnum| is just the raw constructor,
--   and is used for enumerations that will be embedded in other
--   enumerations to avoid redundant memoization. |mkEnum| should only be
--   needed by experts and the Template Haskell code that assembles the
--   enumeration combinators based on the type constructor.
--   
--   An enumerated type may be defined to be an instance of the
--   |Enumerated| class, which will automatically provide the default
--   generators for that type as instances of StandardGens in the Generator
--   module. The structures will have a Label (A, B, etc.) in each
--   `<tt>hole'</tt> that distinguishes the sort of the element.
--   
--   |get| retrieves a value from an enumeration given a rank and an index,
--   or returns |Nothing| if the index is outside of the range of the
--   enumeration. |getUnsafe| assumes the rank and index values are valid
--   and in range, with unpredictable results if not.
type Counter = Rank -> Count
type Selector c a = Rank -> Count -> c a
mkEnum, mkEnumeration :: Counter -> Selector c a -> Enumeration c a
counter :: Enumeration c a -> Counter
selector :: Enumeration c a -> Selector c a
get :: Enumeration c a -> Rank -> Count -> Maybe (c a)
getUnsafe :: Enumeration c a -> Rank -> Count -> c a
enumRange :: (Count, Count) -> Enumeration c a -> Enumeration c a
eMemoize :: Enumeration c a -> Enumeration c a
eConst, eNode :: c a -> Enumeration c a
eSum :: Enumeration c a -> Enumeration c a -> Enumeration c a
eSum3 :: Enumeration c a -> Enumeration c a -> Enumeration c a -> Enumeration c a
eSum4 :: Enumeration c a -> Enumeration c a -> Enumeration c a -> Enumeration c a -> Enumeration c a
eProd :: (a x -> b x -> c x) -> Enumeration a x -> Enumeration b x -> Enumeration c x
eProd3 :: (a x -> b x -> c x -> d x) -> Enumeration a x -> Enumeration b x -> Enumeration c x -> Enumeration d x
eProd4 :: (a x -> b x -> c x -> d x -> e x) -> Enumeration a x -> Enumeration b x -> Enumeration c x -> Enumeration d x -> Enumeration e x
cConst, cNode :: Counter
cSum, cProd :: Counter -> Counter -> Counter
cSum3, cProd3 :: Counter -> Counter -> Counter -> Counter
cSum4, cProd4 :: Counter -> Counter -> Counter -> Counter -> Counter
sConst, sNode :: (Num a, Num b, Eq a, Eq b) => t x -> a -> b -> t x
sSum :: Enumeration c a -> Enumeration c a -> Selector c a
sSum3 :: Enumeration c a -> Enumeration c a -> Enumeration c a -> Selector c a
sSum4 :: Enumeration c a -> Enumeration c a -> Enumeration c a -> Enumeration c a -> Selector c a
sProd :: (a x -> b x -> c x) -> Enumeration a x -> Enumeration b x -> Selector c x
sProd3 :: (a x -> b x -> c x -> d x) -> Enumeration a x -> Enumeration b x -> Enumeration c x -> Selector d x
sProd4 :: (a x -> b x -> c x -> d x -> e x) -> Enumeration a x -> Enumeration b x -> Enumeration c x -> Enumeration d x -> Selector e x
data Label
A :: Label
B :: Label
C :: Label
D :: Label
E :: Label
F :: Label
G :: Label
instance Show Label
instance Functor c => Functor (Enumeration c)

module Test.GenCheck.Generator.BaseEnum
makeBaseEnum :: Count -> BaseSelector a -> BaseEnum a
data BaseEnum a
Base :: Count -> BaseSelector a -> BaseEnum a
baseCount :: BaseEnum a -> Count
baseSelect :: BaseEnum a -> BaseSelector a
class EnumGC a
base :: EnumGC a => BaseEnum a
getBase :: BaseEnum a -> Count -> Maybe a
getBaseUnsafe :: BaseEnum a -> Count -> a
enumList :: [a] -> BaseEnum a
enumBaseRange :: Enum a => (a, a) -> BaseEnum a
enumBaseInt, enumDfltInt, enumBasePosInt, enumBaseNat :: BaseEnum Int
enumBaseChar, enumUpperChar, enumDigitChar, enumLowChar, enumDfltChar :: BaseEnum Char
enumBaseBool :: BaseEnum Bool
instance EnumGC Char
instance EnumGC Int

module Test.GenCheck.Generator.EnumStrat
type EnumStrat = Count -> [Count]
exhaustG :: EnumStrat
randG :: StdGen -> EnumStrat
uniform :: Int -> EnumStrat

-- | extreme (1,20) = [1,20,10,2,11,9,19,5,15,3,12,6,16,4,14,8,18,7,13,17]|
--   
--   The first two extreme binary trees will be the ``all left'' and ''all
--   right'' branched trees, which is a good start for testing, but in
--   general extreme indices may or may not map to boundary conditions in a
--   particular structure.
--   
--   Extreme generators is best used for pulling a small number of cases in
--   conjunction with random testing. It is not an efficient strategy to
--   produce a large number of test cases, and may contain duplicate index
--   entries.
extreme :: EnumStrat
interleave :: [a] -> [a] -> [a]
branch :: EnumStrat

module Test.GenCheck.Generator.Generator
type Generator a = Rank -> [a]
generate :: Generator a -> [(Rank, Count)] -> [a]
genTake :: Generator a -> Rank -> Count -> [a]
enumGenerator :: EnumStrat -> Enumeration c a -> Generator (c a)
data StandardGens a
StdGens :: Generator a -> Generator a -> (Int -> Generator a) -> (StdGen -> Generator a) -> StandardGens a
genAll :: StandardGens a -> Generator a
genXtrm :: StandardGens a -> Generator a
genUni :: StandardGens a -> Int -> Generator a
genRand :: StandardGens a -> StdGen -> Generator a
UnrankedGen :: (Generator a) -> StandardGens a
class Show a => Testable a
stdTestGens :: Testable a => StandardGens a
stdEnumGens :: Enumerated c => StandardGens (c Label)
enumGens :: Enumeration c Label -> StandardGens (c Label)

module Test.GenCheck.System.TestSuite
type GenInstruct = [(Rank, Count)]
type TestSuite c k v a = c k (v a)
type MapRankSuite a = TestSuite Map Rank [] a
genSuite :: Generator a -> GenInstruct -> MapRankSuite a
testSuite :: [Generator a] -> [GenInstruct] -> MapRankSuite a
baseSuite :: StandardGens a -> Count -> MapRankSuite a
stdSuite :: StandardGens a -> StdGen -> Rank -> Count -> MapRankSuite a
deepSuite :: StandardGens a -> StdGen -> Rank -> Count -> MapRankSuite a
suiteMerge :: (LabelledPartition c k v, Monoid (v a), Ord k) => [TestSuite c k v a] -> TestSuite c k v a

module Test.GenCheck.Generator.Substitution
class Structure c
substitute :: Structure c => c a -> [b] -> (Maybe (c b), [b])
subst :: Structure c => Generator (c a) -> Generator b -> Generator (c b)
substN :: Structure c => Int -> Generator (c a) -> Generator b -> Generator (c b)
substAll :: Structure c => Generator (c a) -> Generator b -> Generator (c b)
substStdGenN :: Structure c => Int -> StandardGens (c a) -> Generator b -> StandardGens (c b)
substStdGenAll :: Structure c => StandardGens (c a) -> Generator b -> StandardGens (c b)
class Structure2 c
substitute2 :: Structure2 c => c a b -> [a'] -> [b'] -> (Maybe (c a' b'), [a'], [b'])
subst2 :: Structure2 c => Generator (c a b) -> Generator a' -> Generator b' -> Generator (c a' b')
subst2N :: Structure2 c => Int -> Generator (c a b) -> Generator a' -> Generator b' -> Generator (c a' b')
subst2StdGen :: Structure2 c => StandardGens (c a b) -> Generator a' -> Generator b' -> StandardGens (c a' b')
class Structure3 c
substitute3 :: Structure3 c => c a1 a2 a3 -> [a1'] -> [a2'] -> [a3'] -> (Maybe (c a1' a2' a3'), [a1'], [a2'], [a3'])

module Test.GenCheck.Generator.BaseGens
baseGen :: [a] -> Generator a
baseEnumGen :: EnumStrat -> BaseEnum a -> Generator a
baseEnumGCStdGens :: EnumGC a => StandardGens a
baseEnumGCGens :: BaseEnum a -> StandardGens a
genBaseRangeAll, genBaseRangeExt :: Enum a => (a, a) -> Generator a
genBaseRangeUni :: Enum a => (a, a) -> Int -> Generator a
genBaseRangeRnd :: (RandomGen t, Random a) => (a, a) -> t -> Generator a
genBaseStdGens :: (Enum a, Random a) => (a, a) -> StandardGens a
genIntAll, genIntExt :: Generator Int
genIntUni :: Int -> Generator Int
genIntRnd :: RandomGen t => t -> Generator Int
genLowCharAll, genDigitCharAll, genUpperCharAll, genDfltCharAll :: Generator Char
genLowCharRnd, genDigitCharRnd, genUpperCharRnd, genDfltCharRnd :: StdGen -> Generator Char
genLowCharExt, genDigitCharExt, genUpperCharExt, genDfltCharExt :: Generator Char
genLowCharUni, genDigitCharUni, genUpperCharUni, genDfltCharUni :: Int -> Generator Char
genStrRangeAll :: (Char, Char) -> Generator String
genStrDfltCharAll, genStrDigitCharAll, genStrUpperCharAll, genStrLowCharAll :: Generator String
genStrRangeRnd :: StdGen -> (Char, Char) -> Generator String
genStrLowRnd, genStrDigitRnd, genStrUpperRnd :: StdGen -> Generator String
bldStr :: StdGen -> (Char, Char) -> Rank -> (String, StdGen)
genDblRnd :: StdGen -> Generator Double
genDblRangeRnd :: (Double, Double) -> StdGen -> Generator Double
genDblXtrm :: Generator Double
genDblUni :: Int -> Generator Double
genDblRangeUni :: (Double, Double) -> Int -> Generator Double
genFltRnd :: StdGen -> Generator Float
genFltRangeRnd :: (Float, Float) -> StdGen -> Generator Float
genFltXtrm :: Generator Float
genFltUni :: Int -> Generator Float
genFltRangeUni :: (Float, Float) -> Int -> Generator Float
instance Testable Char
instance Testable Int

module Test.GenCheck.Generator.StructureGens
genListOf :: Generator a -> Rank -> Generator [a]
genListAll :: Generator [Label]
listStdGens :: StandardGens [Label]
genTplAll :: Generator (Label, Label)
instance Testable (Label, Label)
instance Structure2 (,)
instance Testable [Int]
instance Testable [Label]
instance Structure []

module Test.GenCheck.System.SimpleCheck
type Property a = a -> Bool
simpleTest, simpleReport :: Show a => String -> Property a -> MapRankSuite a -> IO ()
simpleCheck :: Show a => String -> Property a -> MapRankSuite a -> IO ()
stdTest :: (Testable a, Integral k) => Property a -> k -> IO ()
stdTestArgs :: Show a => StandardGens a -> String -> Rank -> Property a -> Count -> IO ()
stdReport :: (Testable a, Integral k) => Property a -> k -> IO ()
stdReportArgs :: Show a => StandardGens a -> String -> Rank -> Property a -> Count -> IO ()
stdCheck :: (Testable a, Integral k) => Property a -> k -> IO ()
stdCheckArgs :: Show a => StandardGens a -> String -> Rank -> Property a -> Count -> IO ()
deepTest :: (Testable a, Integral k) => Property a -> k -> IO ()
deepTestArgs :: Show a => StandardGens a -> String -> Rank -> Property a -> Count -> IO ()
deepReport :: (Testable a, Integral k) => Property a -> k -> IO ()
deepReportArgs :: Show a => StandardGens a -> String -> Rank -> Property a -> Count -> IO ()
deepCheck :: (Testable a, Integral k) => Property a -> k -> IO ()
deepCheckArgs :: Show a => StandardGens a -> String -> Rank -> Property a -> Count -> IO ()
baseTest :: (Testable a, Integral k) => Property a -> k -> IO ()
baseTestArgs :: Show a => StandardGens a -> String -> Property a -> Count -> IO ()
baseReport :: (Testable a, Integral k) => Property a -> k -> IO ()
baseReportArgs :: Show a => StandardGens a -> String -> Property a -> Count -> IO ()
baseCheck :: (Testable a, Integral k) => Property a -> k -> IO ()
baseCheckArgs :: Show a => StandardGens a -> String -> Property a -> Count -> IO ()
instance Verdict (SimpleTestPt a)
instance Datum (SimpleTestPt a)
instance Show a => Show (SimpleTestPt a)

module Test.GenCheck
type Property a = a -> Bool
type Rank = Int
type Count = Integer
simpleCheck :: Show a => String -> Property a -> MapRankSuite a -> IO ()
simpleTest, simpleReport :: Show a => String -> Property a -> MapRankSuite a -> IO ()
type MapRankSuite a = TestSuite Map Rank [] a
type TestSuite c k v a = c k (v a)
suiteMerge :: (LabelledPartition c k v, Monoid (v a), Ord k) => [TestSuite c k v a] -> TestSuite c k v a
type GenInstruct = [(Rank, Count)]
genSuite :: Generator a -> GenInstruct -> MapRankSuite a
testSuite :: [Generator a] -> [GenInstruct] -> MapRankSuite a
stdSuite :: StandardGens a -> StdGen -> Rank -> Count -> MapRankSuite a
deepSuite :: StandardGens a -> StdGen -> Rank -> Count -> MapRankSuite a
baseSuite :: StandardGens a -> Count -> MapRankSuite a
type Generator a = Rank -> [a]
class Show a => Testable a
stdTestGens :: Testable a => StandardGens a
data StandardGens a
StdGens :: Generator a -> Generator a -> (Int -> Generator a) -> (StdGen -> Generator a) -> StandardGens a
genAll :: StandardGens a -> Generator a
genXtrm :: StandardGens a -> Generator a
genUni :: StandardGens a -> Int -> Generator a
genRand :: StandardGens a -> StdGen -> Generator a
UnrankedGen :: (Generator a) -> StandardGens a
stdEnumGens :: Enumerated c => StandardGens (c Label)
data Label
A :: Label
B :: Label
C :: Label
D :: Label
E :: Label
F :: Label
G :: Label
class Functor c => Enumerated c where enumFromTo (l, u) = enumRange (l, u) enumeration
enumeration :: Enumerated c => Enumeration c Label
enumFromTo :: Enumerated c => (Integer, Integer) -> Enumeration c Label
data Enumeration c a
listStdGens :: StandardGens [Label]
class EnumGC a
base :: EnumGC a => BaseEnum a
class Structure c
substitute :: Structure c => c a -> [b] -> (Maybe (c b), [b])
subst :: Structure c => Generator (c a) -> Generator b -> Generator (c b)
substN :: Structure c => Int -> Generator (c a) -> Generator b -> Generator (c b)
substAll :: Structure c => Generator (c a) -> Generator b -> Generator (c b)
substStdGenN :: Structure c => Int -> StandardGens (c a) -> Generator b -> StandardGens (c b)
substStdGenAll :: Structure c => StandardGens (c a) -> Generator b -> StandardGens (c b)
class Structure2 c
substitute2 :: Structure2 c => c a b -> [a'] -> [b'] -> (Maybe (c a' b'), [a'], [b'])
subst2 :: Structure2 c => Generator (c a b) -> Generator a' -> Generator b' -> Generator (c a' b')
subst2N :: Structure2 c => Int -> Generator (c a b) -> Generator a' -> Generator b' -> Generator (c a' b')
subst2StdGen :: Structure2 c => StandardGens (c a b) -> Generator a' -> Generator b' -> StandardGens (c a' b')
class Structure3 c
substitute3 :: Structure3 c => c a1 a2 a3 -> [a1'] -> [a2'] -> [a3'] -> (Maybe (c a1' a2' a3'), [a1'], [a2'], [a3'])
