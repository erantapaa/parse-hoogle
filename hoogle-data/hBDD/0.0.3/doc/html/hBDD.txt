-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An abstraction layer for BDD libraries
--   
@package hBDD
@version 0.0.3


-- | An interface to libraries supporting efficient manipulation of Boolean
--   functions, such as BDDs. It is an evolution of <tt>Logical
--   Abstractions in Haskell</tt> by Nancy A. Day, John Launchbury and Jeff
--   Lewis, Haskell Workshop, Paris, October 1999.
--   
--   The purity of this interface may make it difficult to predict when
--   BDDs actually get constructed.
--   
--   Note the use of <a>neg</a> rather than <tt>not</tt> to avoid a clash
--   with <tt>Prelude.not</tt>.
module Data.Boolean

-- | Boolean variables.
class BooleanVariable b where bvars = map bvar
bvar :: BooleanVariable b => String -> b
bvars :: BooleanVariable b => [String] -> [b]
unbvar :: BooleanVariable b => b -> String

-- | The operators have similar fixities and associativies to the standard
--   boolean operators, but at higher precedence (they bind more strongly).
--   
--   The overloaded Boolean operations proper. Provides defaults for
--   operations with obvious expansions, such as <a>nand</a>. A minimal
--   instance should define '(/)' and <a>neg</a>.
class Boolean b where x `nand` y = neg (x /\ y) x \/ y = neg $ (neg x) /\ (neg y) x `nor` y = neg (x \/ y) x `xor` y = (x \/ y) /\ (neg (x /\ y)) x --> y = (neg x) \/ y x <-> y = neg (x `xor` y)
false :: Boolean b => b
true :: Boolean b => b
(/\) :: Boolean b => b -> b -> b
neg :: Boolean b => b -> b
nand :: Boolean b => b -> b -> b
(\/) :: Boolean b => b -> b -> b
nor :: Boolean b => b -> b -> b
xor :: Boolean b => b -> b -> b
(-->) :: Boolean b => b -> b -> b
(<->) :: Boolean b => b -> b -> b

-- | Quantified Boolean Formulae (QBF) operations.
class (Boolean b, BooleanVariable b) => QBF b where data family Group b :: * rel_product qvars f g = exists qvars (f /\ g)
mkGroup :: QBF b => [b] -> Group b
exists :: QBF b => Group b -> b -> b
forall :: QBF b => Group b -> b -> b
rel_product :: QBF b => Group b -> b -> b -> b

-- | Substitutions.
class (Boolean b, BooleanVariable b) => Substitution b where data family Subst b :: * rename = substitute
mkSubst :: Substitution b => [(b, b)] -> Subst b
rename :: Substitution b => Subst b -> b -> b
substitute :: Substitution b => Subst b -> b -> b

-- | Reverse implication
(<--) :: Boolean b => b -> b -> b

-- | Forms the Big Conjunction of a list of <a>Boolean</a> formulas.
conjoin :: Boolean b => [b] -> b

-- | Forms the Big Disjunction of a list of <a>Boolean</a> formulas.
disjoin :: Boolean b => [b] -> b

-- | Compute the fixpoint of a <a>Boolean</a> function.
fix :: Eq b => b -> (b -> b) -> b

-- | "fix" with state.
fix2 :: Eq b => a -> b -> (a -> b -> (a, b)) -> (a, b)

-- | Operations provided by BDD representations.
--   
--   Note that the <a>Eq</a> instance is expected to provide
--   <i>semantic</i> equality on boolean functions, as is typical of BDD
--   packages.
class (Eq b, QBF b, Substitution b) => BDDOps b
get_bdd_ptr :: BDDOps b => b -> IntPtr
bif :: BDDOps b => b -> b
belse :: BDDOps b => b -> b
bthen :: BDDOps b => b -> b
reduce :: BDDOps b => b -> b -> b
satisfy :: BDDOps b => b -> b
support :: BDDOps b => b -> [b]

-- | BDD libraries tend to include some kind of variable reordering
--   heuristics. These are some common ones.
data ReorderingMethod

-- | Switch off variable reordering.
ReorderNone :: ReorderingMethod

-- | Sifting
ReorderSift :: ReorderingMethod

-- | Sifting with identification of symmetric variables
ReorderSiftSym :: ReorderingMethod

-- | Window permutation.
ReorderStableWindow3 :: ReorderingMethod

-- | A class for the text constants and operators used by <a>sop</a>.
class RenderBool a
rbTrue :: RenderBool a => a
rbFalse :: RenderBool a => a
rbVar :: RenderBool a => String -> a
rbAnd :: RenderBool a => a
rbOr :: RenderBool a => a
rbNeg :: RenderBool a => a
rbEmpty :: RenderBool a => a
rbConcat :: RenderBool a => a -> a -> a

-- | Render a <a>Boolean</a> type as a sum-of-products. This was stolen
--   lock-stock from David Long's calculator example.
sop :: (BDDOps b, RenderBool a) => b -> a

-- | Count the number of paths in a BDD leading to <a>true</a>.
countPaths :: BDDOps b => b -> Integer
instance Eq ReorderingMethod
instance Ord ReorderingMethod
instance Show ReorderingMethod
instance RenderBool ShowS
instance Boolean Bool


module Data.Boolean.BF

-- | An abstract syntax tree-ish instance of the <a>Boolean</a> interface,
--   sometimes useful for debugging.
--   
--   Note the <a>Eq</a> instance is <i>not</i> semantic equality.
data BF
BFtrue :: BF
BFfalse :: BF
BFvar :: String -> BF
BFand :: BF -> BF -> BF
BFor :: BF -> BF -> BF
BFxor :: BF -> BF -> BF
BFimplies :: BF -> BF -> BF
BFiff :: BF -> BF -> BF
BFneg :: BF -> BF
BFexists :: [BF] -> BF -> BF
BFforall :: [BF] -> BF -> BF
BFsubst :: [(BF, BF)] -> BF -> BF
instance Eq BF
instance Show BF
instance Substitution BF
instance QBF BF
instance Boolean BF
instance BooleanVariable BF
