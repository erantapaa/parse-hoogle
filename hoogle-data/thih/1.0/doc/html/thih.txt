-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typing Haskell In Haskell
--   
--   Haskell benefits from a sophisticated type system, but implementors,
--   programmers, and researchers suffer because it has no formal
--   description. To remedy this shortcoming, we present a Haskell program
--   that implements a Haskell typechecker, thus providing a mathematically
--   rigorous specification in a notation that is familiar to Haskell
--   users. We expect this program to fill a serious gap in current
--   descriptions of Haskell, both as a starting point for discussions
--   about existing features of the type system, and as a platform from
--   which to explore new proposals.
--   
--   This package is derived from the Haskell '98 + Multiparameter Type
--   Classes package of THIH.
@package thih
@version 1.0

module PPrint
pretty :: PPrint a => a -> String
ppParen :: Bool -> Doc -> Doc
class PPrint a
pprint :: PPrint a => a -> Doc
parPprint :: PPrint a => a -> Doc
pplist :: PPrint a => [a] -> Doc
instance (PPrint a, PPrint b, PPrint c) => PPrint (a, b, c)
instance (PPrint a, PPrint b) => PPrint (a, b)
instance PPrint Double
instance PPrint Float
instance PPrint Int
instance PPrint Integer
instance PPrint Char
instance PPrint a => PPrint [a]

module Kind
data Kind
Star :: Kind
Kfun :: Kind -> Kind -> Kind
ppkind :: Int -> Kind -> Doc
instance Eq Kind
instance PPrint Kind

module Debug
debug :: PPrint a => String -> a -> b -> b

module Id
type Id = String
enumId :: Int -> Id

module Type
data Type
TVar :: Tyvar -> Type
TCon :: Tycon -> Type
TAp :: Type -> Type -> Type
TGen :: Int -> Type
data Tyvar
Tyvar :: Id -> Kind -> Tyvar
data Tycon
Tycon :: Id -> Kind -> Tycon
tString :: Type
fn :: Type -> Type -> Type
list :: Type -> Type
pair :: Type -> Type -> Type
class HasKind t
kind :: HasKind t => t -> Kind
instance Eq Tycon
instance Eq Tyvar
instance Eq Type
instance HasKind Type
instance HasKind Tycon
instance HasKind Tyvar
instance PPrint Tyvar
instance PPrint Type

module Subst
type Subst = [(Tyvar, Type)]
nullSubst :: Subst
(+->) :: Tyvar -> Type -> Subst
class Types t
apply :: Types t => Subst -> t -> t
tv :: Types t => t -> [Tyvar]
(@@) :: Subst -> Subst -> Subst
merge :: Monad m => Subst -> Subst -> m Subst
instance Types a => Types [a]
instance Types Type

module Unify
class Unify t
mgu :: (Unify t, Monad m) => t -> t -> m Subst
varBind :: Monad m => Tyvar -> Type -> m Subst
class Match t
match :: (Match t, Monad m) => t -> t -> m Subst
instance Match t => Match [t]
instance Match Type
instance (Unify t, Types t) => Unify [t]
instance Unify Type

module Pred
data Qual t
(:=>) :: [Pred] -> t -> Qual t
data Pred
IsIn :: Id -> [Type] -> Pred
predHead :: Pred -> Id
type Class = ([Tyvar], [Pred], [Inst])
type Inst = Qual Pred
data ClassEnv
ClassEnv :: (Id -> Maybe Class) -> [Type] -> ClassEnv
classes :: ClassEnv -> Id -> Maybe Class
defaults :: ClassEnv -> [Type]
sig :: ClassEnv -> Id -> [Tyvar]
super :: ClassEnv -> Id -> [Pred]
insts :: ClassEnv -> Id -> [Inst]
defined :: Maybe a -> Bool
modify :: ClassEnv -> Id -> Class -> ClassEnv
initialEnv :: ClassEnv
type EnvTransformer = ClassEnv -> Maybe ClassEnv
(<:>) :: EnvTransformer -> EnvTransformer -> EnvTransformer
addClass :: Id -> [Tyvar] -> [Pred] -> EnvTransformer
addPreludeClasses :: EnvTransformer
addCoreClasses :: EnvTransformer
addNumClasses :: EnvTransformer
addInst :: [Pred] -> Pred -> EnvTransformer
overlap :: Pred -> Pred -> Bool
exampleInsts :: EnvTransformer
bySuper :: ClassEnv -> Pred -> [Pred]
byInst :: ClassEnv -> Pred -> Maybe [Pred]
entail :: ClassEnv -> [Pred] -> Pred -> Bool
simplify :: ([Pred] -> Pred -> Bool) -> [Pred] -> [Pred]
reduce :: ClassEnv -> [Pred] -> [Pred]
elimTauts :: ClassEnv -> [Pred] -> [Pred]
scEntail :: ClassEnv -> [Pred] -> Pred -> Bool
instance Eq Pred
instance Eq t => Eq (Qual t)
instance Match Pred
instance Unify Pred
instance Types Pred
instance Types t => Types (Qual t)
instance PPrint Pred
instance PPrint t => PPrint (Qual t)

module Scheme
data Scheme
Forall :: [Kind] -> (Qual Type) -> Scheme
quantify :: [Tyvar] -> Qual Type -> Scheme
toScheme :: Type -> Scheme
instance Eq Scheme
instance Types Scheme
instance PPrint Scheme

module TIMonad
newtype TI a
TI :: (Subst -> Int -> (Subst, Int, a)) -> TI a
runTI :: TI a -> a
getSubst :: TI Subst
unify :: Type -> Type -> TI ()
trim :: [Tyvar] -> TI ()
extSubst :: Subst -> TI ()
newTVar :: Kind -> TI Type
freshInst :: Scheme -> TI (Qual Type)
class Instantiate t
inst :: Instantiate t => [Type] -> t -> t
instance Instantiate Pred
instance Instantiate t => Instantiate (Qual t)
instance Instantiate a => Instantiate [a]
instance Instantiate Type
instance Monad TI

module Assump
data Assump
(:>:) :: Id -> Scheme -> Assump
find :: Monad m => Id -> [Assump] -> m Scheme
instance Types Assump
instance PPrint Assump

module Static
isIn1 :: Id -> Type -> Pred
mkInst :: Instantiate a => [Kind] -> a -> a
instances :: [Inst] -> EnvTransformer

module StaticPrelude

module StaticMaybe

module StaticTest

module StaticMonad

module StaticList

module StaticThih
tId :: Type
tKind :: Type
starCfun :: Assump
kfunCfun :: Assump
tType :: Type
tVarCfun :: Assump
tConCfun :: Assump
tApCfun :: Assump
tGenCfun :: Assump
tTyvar :: Type
tyvarCfun :: Assump
tTycon :: Type
tyconCfun :: Assump
tSubst :: Type
tQual :: Type
qualifyCfun :: Assump
tPred :: Type
isInCfun :: Assump
tClass :: Type
tInst :: Type
tClassEnv :: Type
classEnvCfun :: Assump
classesSfun :: Assump
defaultsSfun :: Assump
tEnvTransformer :: Type
tScheme :: Type
forallCfun :: Assump
tAssump :: Type
assumeCfun :: Assump
tTI :: Type
tICfun :: Assump
tInfer :: Type -> Type -> Type
tLiteral :: Type
litIntCfun :: Assump
litCharCfun :: Assump
litRatCfun :: Assump
litStrCfun :: Assump
tPat :: Type
pVarCfun :: Assump
pWildcardCfun :: Assump
pAsCfun :: Assump
pLitCfun :: Assump
pNpkCfun :: Assump
pConCfun :: Assump
tExpr :: Type
varCfun :: Assump
litCfun :: Assump
constCfun :: Assump
apCfun :: Assump
letCfun :: Assump
tAlt :: Type
tAmbiguity :: Type
tExpl :: Type
tImpl :: Type
tBindGroup :: Type
tProgram :: Type
thihClasses :: ClassEnv -> Maybe ClassEnv
instsThih :: [Qual Pred]
cHasKind :: String
kindMfun :: Assump
cTypes :: String
applyMfun :: Assump
tvMfun :: Assump
cInstantiate :: String
instMfun :: Assump

module Infer
type Infer e t = ClassEnv -> [Assump] -> e -> TI ([Pred], t)

module Lit
data Literal
LitInt :: Integer -> Literal
LitChar :: Char -> Literal
LitRat :: Rational -> Literal
LitStr :: String -> Literal
tiLit :: Literal -> TI ([Pred], Type)

module Pat
data Pat
PVar :: Id -> Pat
PWildcard :: Pat
PAs :: Id -> Pat -> Pat
PLit :: Literal -> Pat
PNpk :: Id -> Integer -> Pat
PCon :: Assump -> [Pat] -> Pat
PLazy :: Pat -> Pat
tiPat :: Pat -> TI ([Pred], [Assump], Type)
tiPats :: [Pat] -> TI ([Pred], [Assump], [Type])

module TIMain
data Expr
Var :: Id -> Expr
Lit :: Literal -> Expr
Const :: Assump -> Expr
Ap :: Expr -> Expr -> Expr
Let :: BindGroup -> Expr -> Expr
Lam :: Alt -> Expr
If :: Expr -> Expr -> Expr -> Expr
Case :: Expr -> [(Pat, Expr)] -> Expr
toBg :: [(Id, Maybe Scheme, [Alt])] -> BindGroup
tiExpr :: Infer Expr Type
type Alt = ([Pat], Expr)
tiAlt :: Infer Alt Type
tiAlts :: ClassEnv -> [Assump] -> [Alt] -> Type -> TI [Pred]
split :: Monad m => ClassEnv -> [Tyvar] -> [Tyvar] -> [Pred] -> m ([Pred], [Pred])
type Ambiguity = (Tyvar, [Pred])
ambiguities :: ClassEnv -> [Tyvar] -> [Pred] -> [Ambiguity]
numClasses :: [Id]
stdClasses :: [Id]
candidates :: ClassEnv -> Ambiguity -> [Type]
withDefaults :: Monad m => ([Ambiguity] -> [Type] -> a) -> ClassEnv -> [Tyvar] -> [Pred] -> m a
defaultedPreds :: Monad m => ClassEnv -> [Tyvar] -> [Pred] -> m [Pred]
defaultSubst :: Monad m => ClassEnv -> [Tyvar] -> [Pred] -> m Subst
type Expl = (Id, Scheme, [Alt])
tiExpl :: ClassEnv -> [Assump] -> Expl -> TI [Pred]
type Impl = (Id, [Alt])
restricted :: [Impl] -> Bool
tiImpls :: Infer [Impl] [Assump]
type BindGroup = ([Expl], [[Impl]])
tiBindGroup :: Infer BindGroup [Assump]
tiSeq :: Infer bg [Assump] -> Infer [bg] [Assump]

module TIProg
type Program = [BindGroup]
tiProgram :: ClassEnv -> [Assump] -> Program -> [Assump]
tiProgram' :: ClassEnv -> [Assump] -> Program -> [Assump]

module Testbed
test :: ClassEnv -> [Assump] -> [BindGroup] -> IO ()
save :: String -> ClassEnv -> [Assump] -> [BindGroup] -> IO ()

module HaskellMaybe

module HaskellPrims

module SourcePrelude
savePrelude :: IO ()
preludeDefns :: [BindGroup]
hugsSpecific :: [BindGroup]
preludeMems :: [BindGroup]

module HaskellPrelude

module SourceTest
main :: IO ()
saveTest :: IO ()
imports :: [Assump]
testDefns :: [BindGroup]

module HaskellTest

module HaskellList

module HaskellMonad

module HaskellThih

module SourceMaybe
main :: IO ()
saveMaybe :: IO ()
imports :: [Assump]
maybeDefns :: [BindGroup]

module SourceList
main :: IO ()
saveList :: IO ()
imports :: [Assump]
listDefns :: [BindGroup]

module SourceMonad
main :: IO ()
saveMonad :: IO ()
imports :: [Assump]
monadDefns :: [BindGroup]
monadMems :: [BindGroup]

module SourceThih
main :: IO ()
saveThih :: IO ()
imports :: [Assump]
thihDefns :: [BindGroup]
thihMems :: [BindGroup]
