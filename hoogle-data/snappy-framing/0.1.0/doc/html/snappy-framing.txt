-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Snappy Framing Format in Haskell
--   
--   Implementation of the Snappy framing format (SVN revision 71, cf.
--   <a>http://code.google.com/p/snappy/source/browse/trunk/framing_format.txt?r=71</a>)
@package snappy-framing
@version 0.1.0


module Codec.Compression.Snappy.Framing
type Checksum = Word32
data Chunk
StreamIdentifier :: Chunk
Compressed :: !Checksum -> !ByteString -> Chunk
Uncompressed :: !Checksum -> !ByteString -> Chunk
Skippable :: !Word8 -> Chunk
Unskippable :: !Word8 -> Chunk
type DecodeError = (ByteOffset, String)

-- | Encode a lazy <a>ByteString</a> into a <a>Chunk</a>
--   
--   If the input is longer than <a>minCompressible</a> bytes, the
--   resulting chunk is <a>Compressed</a> otherwise <a>Uncompressed</a>. If
--   the input size exceeds <a>maxUncompressed</a> bytes, the leftover
--   input is returned in a <a>Just</a>.
encode :: ByteString -> (Chunk, Maybe ByteString)

-- | Encode a strict <a>ByteString</a> into a <a>Chunk</a>
--   
--   If the input is longer than <a>minCompressible</a> bytes, the
--   resulting chunk is <a>Compressed</a> otherwise <a>Uncompressed</a>. If
--   the input size exceeds <a>maxUncompressed</a> bytes, the leftover
--   input is returned in a <a>Just</a>.
encode' :: ByteString -> (Chunk, Maybe ByteString)

-- | Decode a lazy <a>ByteString</a> into a <a>Chunk</a>
decode :: ByteString -> (Either DecodeError Chunk, Maybe ByteString)

-- | Decode a strict <a>ByteString</a> into a <a>Chunk</a>
decode' :: ByteString -> (Either DecodeError Chunk, Maybe ByteString)

-- | Decode a lazy <a>ByteString</a> into a <a>Chunk</a> and <a>verify</a>
--   the result
decodeVerify :: ByteString -> (Either DecodeError Chunk, Maybe ByteString)

-- | Decode a strict <a>ByteString</a> into a <a>Chunk</a> and
--   <a>verify</a> the result
decodeVerify' :: ByteString -> (Either DecodeError Chunk, Maybe ByteString)

-- | Decode drawing input from the given monadic action as needed
decodeM :: Monad m => m (Maybe ByteString) -> m (Either DecodeError Chunk, Maybe ByteString)

-- | Like <a>decodeM</a>, but <a>verify</a> the result
decodeVerifyM :: Monad m => m (Maybe ByteString) -> m (Either DecodeError Chunk, Maybe ByteString)

-- | Compute a masked CRC32C checksum of the input
checksum :: ByteString -> Checksum

-- | Yield a stream identifier (start-of-stream marker)
streamIdentifier :: ByteString

-- | Verify a <a>Chunk</a>
--   
--   Returns <a>Nothing</a> if the input is an <a>Unskippable</a> chunk, or
--   the checksum verification fails (if the input is a <a>Compressed</a>
--   or <a>Uncompressed</a> chunk). Otherwise, the input <a>Chunk</a> is
--   returned in a <a>Just</a>. Note that <a>Compressed</a> chunks are
--   decompressed into <a>Uncompressed</a> chunks on the fly.
verify :: Chunk -> Maybe Chunk
instance Eq Chunk
instance Show Chunk
instance Binary Chunk
