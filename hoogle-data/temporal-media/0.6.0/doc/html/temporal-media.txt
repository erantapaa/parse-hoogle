-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | data types for temporal media
--   
@package temporal-media
@version 0.6.0

module Temporal.Class

-- | Duration for the given type.

-- | Calculates duration.
class Duration a
dur :: Duration a => a -> DurOf a
class Melody a where a +:+ b = mel [a, b] mel = foldl1 (+:+)
mel :: Melody a => [a] -> a
(+:+) :: Melody a => a -> a -> a
class Harmony a where a =:= b = har [a, b] har = foldl1 (=:=)
har :: Harmony a => [a] -> a
(=:=) :: Harmony a => a -> a -> a
class (Melody a, Harmony a) => Compose a

-- | Repeats the given audio segment several times.
loopBy :: Melody a => Int -> a -> a

-- | Transforms a sequence and then applies a mel.
melMap :: Melody b => (a -> b) -> [a] -> b

-- | Transforms a sequence and then applies a har.
harMap :: Harmony b => (a -> b) -> [a] -> b
class Delay a
del :: Delay a => DurOf a -> a -> a

-- | Infix <a>del</a> function.
(+|) :: Delay a => DurOf a -> a -> a
class Rest a
rest :: Rest a => DurOf a -> a
class Stretch a
str :: Stretch a => DurOf a -> a -> a

-- | Infix <a>str</a> function.
(*|) :: Stretch a => DurOf a -> a -> a
class Limit a
lim :: Limit a => DurOf a -> a -> a
class Loop a
loop :: Loop a => a -> a


-- | A library for creating lists of constant time events related in time.
module Temporal.Media

-- | Constant time events. Value <tt>a</tt> starts at some time and lasts
--   for some time.
data Event t a
Event :: t -> t -> a -> Event t a
eventStart :: Event t a -> t
eventDur :: Event t a -> t
eventContent :: Event t a -> a

-- | <a>Track</a> is a set of <a>Event</a> s. There is total duration of
--   the track, but Events can go beyond the scope of total duration (as a
--   result of <a>mapEvents</a> function). Total duration is used in
--   sequent composition of tracks.
data Track t a

-- | Tests if given <a>Event</a> happens between two time stamps.
within :: Real t => t -> t -> Event t a -> Bool

-- | End point of event (start time plus duration).
eventEnd :: Num t => Event t a -> t

-- | <a>temp</a> constructs just an event. Value of type a lasts for one
--   time unit and starts at zero.
temp :: Num t => a -> Track t a

-- | Constructs a track that contains a single event.
fromEvent :: Num t => Event t a -> Track t a

-- | Constructs a track that contains a single event.
--   
--   <pre>
--   singleEvent start duration content
--   </pre>
singleEvent :: Num t => t -> t -> a -> Track t a

-- | Reversing the tracks
reflect :: (Num t, IfB t, OrdB t) => Track t a -> Track t a

-- | Turncating parallel composition. Total duration equals to minimum of
--   the two tracks. All events that goes beyond the lmimt are dropped.
(=:/) :: (Real t, IfB t, OrdB t) => Track t a -> Track t a -> Track t a

-- | Turncating parallel composition on list of tracks.
harT :: (Real t, IfB t, OrdB t) => [Track t a] -> Track t a

-- | After this transformation events last longer by some constant amount
--   of time.
sustain :: Real t => t -> Track t a -> Track t a

-- | Prolongated events can not exceed total track duration. All event are
--   sustained but those that are close to end of the track are sliceped.
--   It resembles sustain on piano, when track ends you release the pedal.
sustainT :: Real t => t -> Track t a -> Track t a

-- | Analog of <a>replicate</a> function for tracks. Replicated tracks are
--   played sequentially.
--   
--   A melody of events. Each of them lasts for one second.
melTemp :: (Num t, IfB t, OrdB t) => [a] -> Track t a

-- | A chord of events. Each of them lasts for one second.
harTemp :: (Num t, IfB t, OrdB t) => [a] -> Track t a

-- | Transforms a sequence and then applies a harT.
harTMap :: (Real t, IfB t, OrdB t) => (a -> Track t b) -> [a] -> Track t b

-- | <a>slice</a> cuts piece of value within given time interval. for
--   <tt>(<a>slice</a> t0 t1 m)</tt>, if <tt>t1 &lt; t0</tt> result is
--   reversed. If <tt>t0</tt> is negative or <tt>t1</tt> goes beyond
--   <tt><a>dur</a> m</tt> blocks of nothing inserted so that duration of
--   result equals to <tt><a>abs</a> (t0 - t1)</tt>.
slice :: Real t => t -> t -> Track t a -> Track t a

-- | <tt>(<a>takeT</a> t)</tt> is equivalent to <tt>(<a>slice</a> 0
--   t)</tt>.
takeT :: Real t => t -> Track t a -> Track t a

-- | <tt>(<a>dropT</a> t m)</tt> is equivalent to <tt>(<a>slice</a> t (dur
--   a) a)</tt>.
dropT :: Real t => t -> Track t a -> Track t a

-- | Filter track.
filterEvents :: Real t => (Event t a -> Bool) -> Track t a -> Track t a

-- | General mapping. Mapps not only values but events.
mapEvents :: Num t => (Event t a -> Event t b) -> Track t a -> Track t b
traverseEvents :: (Num t1, Applicative f) => (t1 -> f t2) -> (Event t1 a -> f (Event t2 b)) -> Track t1 a -> f (Track t2 b)

-- | Mapps values and time stamps.
tmap :: Real t => (Event t a -> b) -> Track t a -> Track t b

-- | Relative tmap. Time values are normalized by argument's duration.
tmapRel :: RealFrac t => (Event t a -> b) -> Track t a -> Track t b

-- | Get all events on recordered on the track.
render :: Num t => Track t a -> [Event t a]

-- | Shifts all events so that minimal start time equals to zero if first
--   event has negative start time.
alignByZero :: Real t => [Event t a] -> [Event t a]

-- | Sorts all events by start time.
sortEvents :: Ord t => [Event t a] -> [Event t a]

-- | Synonym for method <a>mempty</a>.
nil :: Monoid a => a

-- | Linear interpolation. Can be useful with <a>mapEvents</a> for envelope
--   changes.
--   
--   <pre>
--   linfun [a, da, b, db, c, ... ]
--   </pre>
--   
--   <tt>a, b, c ...</tt> - values
--   
--   <tt>da, db, ...</tt> - duration of segments
linfun :: (Ord t, Fractional t) => [t] -> t -> t

-- | With <a>linfunRel</a> you can make linear interpolation function that
--   has equal distance between points. First argument gives total length
--   of the interpolation function and second argument gives list of
--   values. So call
--   
--   <pre>
--   linfunRel dur [a1, a2, a3, ..., aN]
--   </pre>
--   
--   is equivalent to:
--   
--   <pre>
--   linfun [a1, dur/N, a2, dur/N, a3, ..., dur/N, aN]
--   </pre>
linfunRel :: (Ord t, Fractional t) => t -> [t] -> t -> t
instance (Show t, Show a) => Show (Event t a)
instance (Eq t, Eq a) => Eq (Event t a)
instance Show t => Show (Tfm t)
instance Eq t => Eq (Tfm t)
instance (Show t, Show a) => Show (TList t a)
instance (Eq t, Eq a) => Eq (TList t a)
instance Functor (TList t)
instance Foldable (TList t)
instance Traversable (TList t)
instance (Show t, Show a) => Show (Track t a)
instance (Eq t, Eq a) => Eq (Track t a)
instance Functor (Track t)
instance Foldable (Track t)
instance Traversable (Track t)
instance Monoid (TList t a)
instance Functor (Event t)
instance (Num t, IfB t, OrdB t) => Rest (Track t a)
instance (Num t, IfB t, OrdB t) => Compose (Track t a)
instance (Num t, IfB t, OrdB t) => Harmony (Track t a)
instance (Num t, IfB t, OrdB t) => Melody (Track t a)
instance Num t => Delay (Track t a)
instance Num t => Stretch (Track t a)
instance Duration (Track t a)
instance (Num t, IfB t, OrdB t) => Monoid (Track t a)
