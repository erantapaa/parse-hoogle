-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Collection of types for bioinformatics
--   
@package BiobaseTypes
@version 0.1.1.0


-- | Strand information. A newtyped version, complete with serialization,
--   pattern synonyms, being a <tt>PrimitiveArray</tt> index type, etc.
--   
--   TODO will be expanded to encode biological sense information more
--   clearly:
--   <a>http://en.wikipedia.org/wiki/Sense_%28molecular_biology%29</a>.
module Biobase.Types.Strand
newtype Strand
Strand :: Int -> Strand
getStrand :: Strand -> Int
instance Arbitrary Strand
instance IndexStream Strand
instance IndexStream z => IndexStream (z :. Strand)
instance Index Strand
instance Vector Vector Strand
instance MVector MVector Strand
instance Unbox Strand
instance Eq Strand
instance Ord Strand
instance Generic Strand
instance Datatype D1Strand
instance Constructor C1_0Strand
instance Selector S1_0_0Strand
instance Hashable Strand
instance FromJSON Strand
instance ToJSON Strand
instance Serialize Strand
instance Binary Strand
instance NFData Strand
instance Enum Strand
instance Bounded Strand
instance Read Strand
instance Show Strand


-- | Discretized log-odds.
module Biobase.Types.Odds

-- | Discretized log-odds.
--   
--   The BLOSUM matrices, for example, store data in discretized log-odds
--   form.
--   
--   TODO Might move up even higher into statistics modules.
newtype DLO
DLO :: Int -> DLO
getDLO :: DLO -> Int
instance NFData DLO
instance ToJSON DLO
instance FromJSON DLO
instance Serialize DLO
instance Binary DLO
instance Vector Vector DLO
instance MVector MVector DLO
instance Unbox DLO
instance Generic DLO
instance Eq DLO
instance Ord DLO
instance Show DLO
instance Read DLO
instance Datatype D1DLO
instance Constructor C1_0DLO
instance Selector S1_0_0DLO

module Biobase.Types.Index.Type

-- | A linear <tt>Int</tt>-based index type.
newtype Index (t :: Nat)
Index :: Int -> Index
getIndex :: Index -> Int

-- | Turn an <a>Int</a> into an <a>Index</a> safely.
index :: KnownNat t => Int -> Index t

-- | Produce <a>Just</a> and <a>Index</a> or <a>Nothing</a>.
maybeIndex :: KnownNat t => Int -> Maybe (Index t)
instance Arbitrary (Index t)
instance IndexStream (Index t)
instance IndexStream z => IndexStream (z :. Index t)
instance KnownNat t => Index (Index t)
instance Vector Vector (Index t0)
instance MVector MVector (Index t0)
instance Unbox (Index t0)
instance Show (Index t)
instance Read (Index t)
instance Eq (Index t)
instance Ord (Index t)
instance Generic (Index t)
instance Ix (Index t)
instance Datatype D1Index
instance Constructor C1_0Index
instance Selector S1_0_0Index
instance Hashable (Index t)
instance FromJSON (Index t)
instance ToJSON (Index t)
instance Serialize (Index t)
instance Binary (Index t)
instance NFData (Index t)
instance KnownNat t => Num (Index t)


-- | Biological sequence data is oftentimes indexed either <tt>0-</tt> or
--   <tt>1-</tt>based. The <tt>Index</tt> type developed provides static
--   guarantees that there is no confusion what index is in use.
--   
--   This module does not export the ctor <tt>Index</tt>. If you want to
--   (unsafely) use it, import <tt>Biobase.Types.Index.Type</tt> directly.
--   Use <tt>fromInt0</tt> to make clear that you count from 0 and
--   transform to an <tt>Index t</tt>. I.e. <tt>fromInt0 0 :: Index 1</tt>
--   yields the lowest 1-base index.
module Biobase.Types.Index

-- | Uses <a>index</a> to guarantee that the <a>Index</a> is ok.
checkIndex :: KnownNat t => Index t -> Index t

-- | Re-Index an index of type <tt>Index n</tt> as <tt>Index m</tt>. This
--   is always safe, as <tt>0 :: Index 0</tt> gives <tt>1 :: Index 1</tt>
--   for example. I.e. valid indices become valid indices.
reIndex :: (KnownNat n, KnownNat m) => Index n -> Index m

-- | Helper function that allows <tt>addition</tt> of an <a>Index</a> and
--   an <a>Int</a>, with the <a>Int</a> on the right.
(+.) :: KnownNat t => Index t -> Int -> Index t

-- | Unsafe plus.
unsafePlus :: KnownNat t => Index t -> Int -> Index t

-- | Helper function that allows <tt>subtraction</tt> of an <a>Index</a>
--   and an <a>Int</a>, with the <a>Int</a> on the right.
(-.) :: KnownNat t => Index t -> Int -> Index t

-- | Unsafe minus.
unsafeMinus :: KnownNat t => Index t -> Int -> Index t

-- | Return the index as an <tt>Int</tt>-style index that is zero-based.
toInt0 :: KnownNat t => Index t -> Int

-- | As an index from an <tt>Int</tt>-style zero-based one.
--   
--   TODO We might want to check that the argument is <tt>[0..]</tt>.
fromInt0 :: KnownNat t => Int -> Index t

-- | Zero-based indices.
type I0 = Index 0

-- | One-based indices.
type I1 = Index 1
getIndex :: Index t -> Int

-- | Turn an <a>Int</a> into an <a>Index</a> safely.
index :: KnownNat t => Int -> Index t

-- | Produce <a>Just</a> and <a>Index</a> or <a>Nothing</a>.
maybeIndex :: KnownNat t => Int -> Maybe (Index t)

-- | A linear <tt>Int</tt>-based index type.
data Index (t :: Nat)


-- | For some values, we want to have different kind of extreme values.
--   Consider a <tt>Double</tt> representing an energy. We want <tt>near
--   infinities</tt> that do not lead to numeric problems.
--   
--   TODO benchmark different extremes and their interplay with algebraic
--   operations.
--   
--   TODO consider the <tt>ieee754</tt> package
module Biobase.Types.NumericalExtremes

-- | Very large and small numbers with some numerical safety to
--   <tt>1/0</tt> or <tt>maxBound</tt> (depending on if we are
--   <tt>Integral</tt> or <tt>RealFloat</tt>.
--   
--   We have:
--   
--   <pre>
--   maxFinite &gt;= extremelyLarge &gt;= veryLarge
--   </pre>
--   
--   <pre>
--   veryLarge &gt;= verySmall
--   </pre>
--   
--   <tt>verySmall &gt;= extremelySmall &gt;= minFinite</tt>.
--   
--   TODO the small stuff should actually be around zero, but positive and
--   go into <tt>NumericalEpsilon</tt>. Here we should actually use other
--   names.
class NumericalExtremes x
maxFinite :: NumericalExtremes x => x
minFinite :: NumericalExtremes x => x
veryLarge :: NumericalExtremes x => x
verySmall :: NumericalExtremes x => x
extremelyLarge :: NumericalExtremes x => x
extremelySmall :: NumericalExtremes x => x

-- | Small numbers.
class NumericalEpsilon x
epsilon :: NumericalEpsilon x => x
instance NumericalEpsilon Double
instance NumericalExtremes Double
instance NumericalExtremes Int


-- | Different types of energies and conversion between.
--   
--   TODO enthalpy TODO entropy
module Biobase.Types.Energy

-- | Gibbs free energy change.
--   
--   For RNA structure, the change in energy from the unfolded structure to
--   the given structure.
--   
--   In units of <tt>kcal / mol</tt>.
--   
--   TODO shall we phantom-type the actual units?
newtype DeltaGibbs
DG :: Double -> DeltaGibbs
getDG :: DeltaGibbs -> Double

-- | <tt>round $ DeltaGibbs / 100</tt>.
newtype DeltaDekaGibbs
DekaG :: Int -> DeltaDekaGibbs
getDekaG :: DeltaDekaGibbs -> Int
instance NumericalExtremes DeltaDekaGibbs
instance Default DeltaDekaGibbs
instance ToJSON DeltaDekaGibbs
instance FromJSON DeltaDekaGibbs
instance Serialize DeltaDekaGibbs
instance Binary DeltaDekaGibbs
instance Hashable DeltaDekaGibbs
instance Vector Vector DeltaDekaGibbs
instance MVector MVector DeltaDekaGibbs
instance Unbox DeltaDekaGibbs
instance NumericalEpsilon DeltaGibbs
instance NumericalExtremes DeltaGibbs
instance Eq DeltaDekaGibbs
instance Ord DeltaDekaGibbs
instance Num DeltaDekaGibbs
instance Read DeltaDekaGibbs
instance Show DeltaDekaGibbs
instance Generic DeltaDekaGibbs
instance Datatype D1DeltaDekaGibbs
instance Constructor C1_0DeltaDekaGibbs
instance Selector S1_0_0DeltaDekaGibbs
instance Default DeltaGibbs
instance ToJSON DeltaGibbs
instance FromJSON DeltaGibbs
instance Serialize DeltaGibbs
instance Binary DeltaGibbs
instance Hashable DeltaGibbs
instance Vector Vector DeltaGibbs
instance MVector MVector DeltaGibbs
instance Unbox DeltaGibbs
instance Eq DeltaGibbs
instance Ord DeltaGibbs
instance Num DeltaGibbs
instance Fractional DeltaGibbs
instance Read DeltaGibbs
instance Show DeltaGibbs
instance Generic DeltaGibbs
instance Datatype D1DeltaGibbs
instance Constructor C1_0DeltaGibbs
instance Selector S1_0_0DeltaGibbs

module Biobase.Types.Accession

-- | The accession number is a unique identifier in bioinformatics.
--   
--   Depending on the source, accession numbers follow different
--   alphanumeric formats! While letters-than-numbers is quite common,
--   swissprot uses a mix. Hence, we just use a text string as accession.
--   
--   A phantom type is provided to enable type safety annotations. Helper
--   functions provide smart construction from the <tt>Accession</tt>
--   tagged generic type.
newtype Accession t
Accession :: Text -> Accession t
_getAccession :: Accession t -> Text
accession :: Stringable s => s -> Accession t
tagAccession :: Accession f -> Accession t

-- | nucleotide sequence
data Nucleotide

-- | protein sequence
data Protein

-- | Tag as being a clan.
data Clan

-- | Tag as being a Pfam model.
data Pfam

-- | Tag as being an Rfam model. Used for Stockholm and CM files.
data Rfam

-- | Species have an accession number, too.
data Species
instance Eq (Accession t)
instance Ord (Accession t)
instance Read (Accession t)
instance Show (Accession t)
instance Generic (Accession t)
instance Datatype D1Accession
instance Constructor C1_0Accession
instance Selector S1_0_0Accession
instance ToJSON (Accession t)
instance Serialize (Accession t)
instance Hashable (Accession t)
instance FromJSON (Accession t)
instance Binary (Accession t)
instance IsString (Accession t)
