-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library of efficent, purely-functional data structures (Core Implementations)
--   
--   This package provides the core Edison data structure implementations,
--   including multiple sequence, set, bag, and finite map concrete
--   implementations with various performance characteristics. The
--   implementations in this package have no dependencies other than those
--   commonly bundled with Haskell compilers.
@package EdisonCore
@version 1.2.2.1


-- | A general sequence representation with arbitrary annotations, for use
--   as a base for implementations of various collection types, as
--   described in section 4 of
--   
--   <ul>
--   <li>Ralf Hinze and Ross Paterson, "Finger trees: a simple
--   general-purpose data structure", <i>Journal of Functional
--   Programming</i> 16:2 (2006) pp 197-217.
--   <a>http://www.soi.city.ac.uk/~ross/papers/FingerTree.html</a></li>
--   </ul>
--   
--   This data structure forms the basis of the
--   <a>Data.Edison.Seq.FingerSeq</a> sequence data structure.
--   
--   An amortized running time is given for each operation, with <i>n</i>
--   referring to the length of the sequence. These bounds hold even in a
--   persistent (shared) setting.
module Data.Edison.Concrete.FingerTree

-- | Finger trees with element type <tt>a</tt>, annotated with measures of
--   type <tt>v</tt>. The operations enforce the constraint
--   <tt><a>Measured</a> v a</tt>.
data FingerTree v a
data Split t a
Split :: t -> a -> t -> Split t a

-- | <i>O(1)</i>. The empty sequence.
empty :: Measured v a => FingerTree v a

-- | <i>O(1)</i>. A singleton sequence.
singleton :: Measured v a => a -> FingerTree v a

-- | <i>O(1)</i>. Add an element to the left end of a sequence.
lcons :: Measured v a => a -> FingerTree v a -> FingerTree v a

-- | <i>O(1)</i>. Add an element to the right end of a sequence.
rcons :: Measured v a => a -> FingerTree v a -> FingerTree v a

-- | <i>O(log(min(n1,n2)))</i>. Concatenate two sequences.
append :: Measured v a => FingerTree v a -> FingerTree v a -> FingerTree v a

-- | <i>O(n)</i>. Create a sequence from a finite list of elements.
fromList :: Measured v a => [a] -> FingerTree v a
toList :: FingerTree v a -> [a]

-- | <i>O(1)</i>. Is this the empty sequence?
null :: Measured v a => FingerTree v a -> Bool
size :: FingerTree v a -> Int

-- | <i>O(1)</i>. Analyse the left end of a sequence.
lview :: (Measured v a, Monad m) => FingerTree v a -> m (a, FingerTree v a)

-- | <i>O(1)</i>. Analyse the right end of a sequence.
rview :: (Measured v a, Monad m) => FingerTree v a -> m (a, FingerTree v a)

-- | <i>O(log(min(i,n-i)))</i>. Split a sequence at a point where the
--   predicate on the accumulated measure changes from <a>False</a> to
--   <a>True</a>.
split :: Measured v a => (v -> Bool) -> FingerTree v a -> (FingerTree v a, FingerTree v a)
takeUntil :: Measured v a => (v -> Bool) -> FingerTree v a -> FingerTree v a
dropUntil :: Measured v a => (v -> Bool) -> FingerTree v a -> FingerTree v a
splitTree :: Measured v a => (v -> Bool) -> v -> FingerTree v a -> Split (FingerTree v a) a

-- | <i>O(n)</i>. The reverse of a sequence.
reverse :: Measured v a => FingerTree v a -> FingerTree v a
mapTree :: Measured v2 a2 => (a1 -> a2) -> FingerTree v1 a1 -> FingerTree v2 a2
foldFT :: b -> (b -> b -> b) -> (a -> b) -> FingerTree v a -> b
reduce1 :: (a -> a -> a) -> FingerTree v a -> a
reduce1' :: (a -> a -> a) -> FingerTree v a -> a
strict :: FingerTree v a -> FingerTree v a
strictWith :: (a -> b) -> FingerTree v a -> FingerTree v a
structuralInvariant :: (Eq v, Measured v a) => FingerTree v a -> Bool
instance Show a => Show (Digit a)
instance (Show v, Show a) => Show (Node v a)
instance (Measured v a, CoArbitrary a) => CoArbitrary (FingerTree v a)
instance (Measured v a, Arbitrary a) => Arbitrary (FingerTree v a)
instance (Measured v a, CoArbitrary a) => CoArbitrary (Node v a)
instance (Measured v a, Arbitrary a) => Arbitrary (Node v a)
instance CoArbitrary a => CoArbitrary (Digit a)
instance Arbitrary a => Arbitrary (Digit a)
instance (Measured v a, Show a) => Show (FingerTree v a)
instance (Measured v a, Ord a) => Ord (FingerTree v a)
instance (Measured v a, Eq a) => Eq (FingerTree v a)
instance Measured v a => Measured v (FingerTree v a)
instance Monoid v => Measured v (Node v a)
instance Measured v a => Measured v (Digit a)


-- | This module provides default implementations of many of the sequence
--   operations. It is used to fill in implementations and is not intended
--   for end users.
module Data.Edison.Seq.Defaults
rconsUsingAppend :: Sequence s => a -> s a -> s a
rconsUsingFoldr :: Sequence s => a -> s a -> s a
appendUsingFoldr :: Sequence s => s a -> s a -> s a
rviewDefault :: (Monad m, Sequence s) => s a -> m (a, s a)
rtailUsingLview :: Sequence s => s a -> s a
rtailMUsingLview :: (Monad m, Sequence s) => s a -> m (s a)
concatUsingFoldr :: Sequence s => s (s a) -> s a
reverseUsingReverseOnto :: Sequence s => s a -> s a
reverseUsingLists :: Sequence s => s a -> s a
reverseOntoUsingFoldl :: Sequence s => s a -> s a -> s a
reverseOntoUsingReverse :: Sequence s => s a -> s a -> s a
fromListUsingCons :: Sequence s => [a] -> s a
toListUsingFoldr :: Sequence s => s a -> [a]
mapUsingFoldr :: Sequence s => (a -> b) -> s a -> s b
concatMapUsingFoldr :: Sequence s => (a -> s b) -> s a -> s b
foldrUsingLists :: Sequence s => (a -> b -> b) -> b -> s a -> b
foldr'UsingLists :: Sequence s => (a -> b -> b) -> b -> s a -> b
foldlUsingLists :: Sequence s => (b -> a -> b) -> b -> s a -> b
foldl'UsingLists :: Sequence s => (b -> a -> b) -> b -> s a -> b
foldr1UsingLists :: Sequence s => (a -> a -> a) -> s a -> a
foldr1'UsingLists :: Sequence s => (a -> a -> a) -> s a -> a
foldl1UsingLists :: Sequence s => (a -> a -> a) -> s a -> a
foldl1'UsingLists :: Sequence s => (a -> a -> a) -> s a -> a
fold1UsingFold :: Sequence s => (a -> a -> a) -> s a -> a
fold1'UsingFold' :: Sequence s => (a -> a -> a) -> s a -> a
foldr1UsingLview :: Sequence s => (a -> a -> a) -> s a -> a
foldr1'UsingLview :: Sequence s => (a -> a -> a) -> s a -> a
foldl1UsingFoldl :: Sequence s => (a -> a -> a) -> s a -> a
foldl1'UsingFoldl' :: Sequence s => (a -> a -> a) -> s a -> a
reducerUsingReduce1 :: Sequence s => (a -> a -> a) -> a -> s a -> a
reducer'UsingReduce1' :: Sequence s => (a -> a -> a) -> a -> s a -> a
reducelUsingReduce1 :: Sequence s => (a -> a -> a) -> a -> s a -> a
reducel'UsingReduce1' :: Sequence s => (a -> a -> a) -> a -> s a -> a
reduce1UsingLists :: Sequence s => (a -> a -> a) -> s a -> a
reduce1'UsingLists :: Sequence s => (a -> a -> a) -> s a -> a
copyUsingLists :: Sequence s => Int -> a -> s a
inBoundsUsingDrop :: Sequence s => Int -> s a -> Bool
inBoundsUsingLookupM :: Sequence s => Int -> s a -> Bool
inBoundsUsingSize :: Sequence s => Int -> s a -> Bool
lookupUsingLookupM :: Sequence s => Int -> s a -> a
lookupUsingDrop :: Sequence s => Int -> s a -> a
lookupWithDefaultUsingLookupM :: Sequence s => a -> Int -> s a -> a
lookupWithDefaultUsingDrop :: Sequence s => a -> Int -> s a -> a
lookupMUsingDrop :: (Monad m, Sequence s) => Int -> s a -> m a
filterUsingLview :: Sequence s => (a -> Bool) -> s a -> s a
filterUsingLists :: Sequence s => (a -> Bool) -> s a -> s a
filterUsingFoldr :: Sequence s => (a -> Bool) -> s a -> s a
partitionUsingLists :: Sequence s => (a -> Bool) -> s a -> (s a, s a)
partitionUsingFoldr :: Sequence s => (a -> Bool) -> s a -> (s a, s a)
updateUsingAdjust :: Sequence s => Int -> a -> s a -> s a
updateUsingSplitAt :: Sequence s => Int -> a -> s a -> s a
adjustUsingLists :: Sequence s => (a -> a) -> Int -> s a -> s a
adjustUsingSplitAt :: Sequence s => (a -> a) -> Int -> s a -> s a
mapWithIndexUsingLists :: Sequence s => (Int -> a -> b) -> s a -> s b
foldrWithIndexUsingLists :: Sequence s => (Int -> a -> b -> b) -> b -> s a -> b
foldrWithIndex'UsingLists :: Sequence s => (Int -> a -> b -> b) -> b -> s a -> b
foldlWithIndexUsingLists :: Sequence s => (b -> Int -> a -> b) -> b -> s a -> b
foldlWithIndex'UsingLists :: Sequence s => (b -> Int -> a -> b) -> b -> s a -> b
takeUsingLists :: Sequence s => Int -> s a -> s a
takeUsingLview :: Sequence s => Int -> s a -> s a
dropUsingLists :: Sequence s => Int -> s a -> s a
dropUsingLtail :: Sequence s => Int -> s a -> s a
splitAtDefault :: Sequence s => Int -> s a -> (s a, s a)
splitAtUsingLview :: Sequence s => Int -> s a -> (s a, s a)
subseqDefault :: Sequence s => Int -> Int -> s a -> s a
takeWhileUsingLview :: Sequence s => (a -> Bool) -> s a -> s a
dropWhileUsingLview :: Sequence s => (a -> Bool) -> s a -> s a
splitWhileUsingLview :: Sequence s => (a -> Bool) -> s a -> (s a, s a)
zipUsingLview :: Sequence s => s a -> s b -> s (a, b)
zip3UsingLview :: Sequence s => s a -> s b -> s c -> s (a, b, c)
zipWithUsingLview :: Sequence s => (a -> b -> c) -> s a -> s b -> s c
zipWith3UsingLview :: Sequence s => (a -> b -> c -> d) -> s a -> s b -> s c -> s d
zipUsingLists :: Sequence s => s a -> s b -> s (a, b)
zip3UsingLists :: Sequence s => s a -> s b -> s c -> s (a, b, c)
zipWithUsingLists :: Sequence s => (a -> b -> c) -> s a -> s b -> s c
zipWith3UsingLists :: Sequence s => (a -> b -> c -> d) -> s a -> s b -> s c -> s d
unzipUsingLists :: Sequence s => s (a, b) -> (s a, s b)
unzipUsingFoldr :: Sequence s => s (a, b) -> (s a, s b)
unzip3UsingLists :: Sequence s => s (a, b, c) -> (s a, s b, s c)
unzip3UsingFoldr :: Sequence s => s (a, b, c) -> (s a, s b, s c)
unzipWithUsingLists :: Sequence s => (a -> b) -> (a -> c) -> s a -> (s b, s c)
unzipWithUsingFoldr :: Sequence s => (a -> b) -> (a -> c) -> s a -> (s b, s c)
unzipWith3UsingLists :: Sequence s => (a -> b) -> (a -> c) -> (a -> d) -> s a -> (s b, s c, s d)
unzipWith3UsingFoldr :: Sequence s => (a -> b) -> (a -> c) -> (a -> d) -> s a -> (s b, s c, s d)
showsPrecUsingToList :: (Show a, Sequence s) => Int -> s a -> ShowS
readsPrecUsingFromList :: (Read a, Sequence s) => Int -> ReadS (s a)
defaultCompare :: (Ord a, Sequence s) => s a -> s a -> Ordering
dropMatch :: (Eq a, MonadPlus m) => [a] -> [a] -> m [a]
tokenMatch :: MonadPlus m => String -> String -> m String
readSParens :: ReadS a -> ReadS a
maybeParens :: ReadS a -> ReadS a


-- | Binary Random-Access lists. All functions have the standard running
--   times from <a>Data.Edison.Seq</a> except the following:
--   
--   <ul>
--   <li>lcons, lhead, ltail*, lview*, rhead*, size, lookup*, update,
--   adjust, drop <tt>O( log n )</tt></li>
--   <li>copy, inBounds <tt>O( i )</tt></li>
--   <li>append, reverseOnto <tt>O( n1 + log n2 )</tt></li>
--   <li>take, splitAt <tt>O( i + log n )</tt></li>
--   <li>subseq <tt>O( log n + len )</tt></li>
--   <li>zip <tt>O( min( n1, n2 ) + log max( n1, n2 ) )</tt></li>
--   </ul>
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Chris Okasaki. <i>Purely Functional Data Structures</i>. 1998.
--   Section 10.1.2.</li>
--   </ul>
module Data.Edison.Seq.BinaryRandList
data Seq a
empty :: Seq a
singleton :: a -> Seq a
lcons :: a -> Seq a -> Seq a
rcons :: a -> Seq a -> Seq a
append :: Seq a -> Seq a -> Seq a
lview :: Monad m => Seq a -> m (a, Seq a)
lhead :: Seq a -> a
ltail :: Seq a -> Seq a
rview :: Monad m => Seq a -> m (a, Seq a)
rhead :: Seq a -> a
rtail :: Seq a -> Seq a
lheadM :: Monad m => Seq a -> m a
ltailM :: Monad m => Seq a -> m (Seq a)
rheadM :: Monad m => Seq a -> m a
rtailM :: Monad m => Seq a -> m (Seq a)
null :: Seq a -> Bool
size :: Seq a -> Int
concat :: Seq (Seq a) -> Seq a
reverse :: Seq a -> Seq a
reverseOnto :: Seq a -> Seq a -> Seq a
fromList :: [a] -> Seq a
toList :: Seq a -> [a]
map :: (a -> b) -> Seq a -> Seq b
concatMap :: (a -> Seq b) -> Seq a -> Seq b
fold :: (a -> b -> b) -> b -> Seq a -> b
fold' :: (a -> b -> b) -> b -> Seq a -> b
fold1 :: (a -> a -> a) -> Seq a -> a
fold1' :: (a -> a -> a) -> Seq a -> a
foldr :: (a -> b -> b) -> b -> Seq a -> b
foldr' :: (a -> b -> b) -> b -> Seq a -> b
foldl :: (b -> a -> b) -> b -> Seq a -> b
foldl' :: (b -> a -> b) -> b -> Seq a -> b
foldr1 :: (a -> a -> a) -> Seq a -> a
foldr1' :: (a -> a -> a) -> Seq a -> a
foldl1 :: (a -> a -> a) -> Seq a -> a
foldl1' :: (a -> a -> a) -> Seq a -> a
reducer :: (a -> a -> a) -> a -> Seq a -> a
reducer' :: (a -> a -> a) -> a -> Seq a -> a
reducel :: (a -> a -> a) -> a -> Seq a -> a
reducel' :: (a -> a -> a) -> a -> Seq a -> a
reduce1 :: (a -> a -> a) -> Seq a -> a
reduce1' :: (a -> a -> a) -> Seq a -> a
copy :: Int -> a -> Seq a
inBounds :: Int -> Seq a -> Bool
lookup :: Int -> Seq a -> a
lookupM :: Monad m => Int -> Seq a -> m a
lookupWithDefault :: a -> Int -> Seq a -> a
update :: Int -> a -> Seq a -> Seq a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldrWithIndex' :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
foldlWithIndex' :: (b -> Int -> a -> b) -> b -> Seq a -> b
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
subseq :: Int -> Int -> Seq a -> Seq a
filter :: (a -> Bool) -> Seq a -> Seq a
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
takeWhile :: (a -> Bool) -> Seq a -> Seq a
dropWhile :: (a -> Bool) -> Seq a -> Seq a
splitWhile :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
zip :: Seq a -> Seq b -> Seq (a, b)
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzip3 :: Seq (a, b, c) -> (Seq a, Seq b, Seq c)
unzipWith :: (a -> b) -> (a -> c) -> Seq a -> (Seq b, Seq c)
unzipWith3 :: (a -> b) -> (a -> c) -> (a -> d) -> Seq a -> (Seq b, Seq c, Seq d)
strict :: Seq a -> Seq a
strictWith :: (a -> b) -> Seq a -> Seq a
structuralInvariant :: Seq a -> Bool
moduleName :: String
instance Eq a => Eq (Seq a)
instance Monoid (Seq a)
instance CoArbitrary a => CoArbitrary (Seq a)
instance Arbitrary a => Arbitrary (Seq a)
instance Read a => Read (Seq a)
instance Show a => Show (Seq a)
instance Ord a => Ord (Seq a)
instance MonadPlus Seq
instance Monad Seq
instance Functor Seq
instance Sequence Seq


-- | This module provides default implementations of many of the collection
--   methods. The functions in this module are used to fill out collection
--   implementations and are not intended to be used directly by end users.
module Data.Edison.Coll.Defaults
insertSeqUsingUnion :: (CollX c a, Sequence seq) => seq a -> c -> c
insertSeqUsingFoldr :: (CollX c a, Sequence seq) => seq a -> c -> c
memberUsingFold :: Coll c a => c -> a -> Bool
countUsingMember :: SetX c a => a -> c -> Int
lookupAllUsingLookupM :: (Set c a, Sequence seq) => a -> c -> seq a
deleteSeqUsingDelete :: (CollX c a, Sequence seq) => seq a -> c -> c
unionSeqUsingFoldl :: (CollX c a, Sequence seq) => seq c -> c
unionSeqUsingFoldl' :: (CollX c a, Sequence seq) => seq c -> c
unionSeqUsingReduce :: (CollX c a, Sequence seq) => seq c -> c
fromSeqUsingFoldr :: (CollX c a, Sequence seq) => seq a -> c
fromSeqUsingUnionSeq :: (CollX c a, Sequence seq) => seq a -> c
toSeqUsingFold :: (Coll c a, Sequence seq) => c -> seq a
unsafeInsertMaxUsingUnsafeAppend :: OrdCollX c a => a -> c -> c
toOrdSeqUsingFoldr :: (OrdColl c a, Sequence seq) => c -> seq a
unsafeFromOrdSeqUsingUnsafeInsertMin :: (OrdCollX c a, Sequence seq) => seq a -> c
disjointUsingToOrdList :: OrdColl c a => c -> c -> Bool
intersectWitnessUsingToOrdList :: (OrdColl c a, Monad m) => c -> c -> m (a, a)
lookupUsingLookupM :: Coll c a => a -> c -> a
lookupUsingLookupAll :: Coll c a => a -> c -> a
lookupMUsingLookupAll :: (Coll c a, Monad m) => a -> c -> m a
lookupWithDefaultUsingLookupAll :: Coll c a => a -> a -> c -> a
lookupWithDefaultUsingLookupM :: Coll c a => a -> a -> c -> a
deleteMaxUsingMaxView :: OrdColl c a => c -> c
fromSeqWithUsingInsertWith :: (Set c a, Sequence seq) => (a -> a -> a) -> seq a -> c
insertUsingInsertWith :: Set c a => a -> c -> c
unionUsingUnionWith :: Set c a => c -> c -> c
filterUsingOrdLists :: OrdColl c a => (a -> Bool) -> c -> c
partitionUsingOrdLists :: OrdColl c a => (a -> Bool) -> c -> (c, c)
intersectionUsingIntersectionWith :: Set c a => c -> c -> c
differenceUsingOrdLists :: OrdSet c a => c -> c -> c
symmetricDifferenceUsingDifference :: SetX c a => c -> c -> c
properSubsetUsingOrdLists :: OrdSet c a => c -> c -> Bool
subsetUsingOrdLists :: OrdSet c a => c -> c -> Bool
properSubsetOnOrdLists :: Ord t => [t] -> [t] -> Bool
subsetOnOrdLists :: Ord t => [t] -> [t] -> Bool
insertSeqWithUsingInsertWith :: (Set c a, Sequence seq) => (a -> a -> a) -> seq a -> c -> c
unionlUsingUnionWith :: Set c a => c -> c -> c
unionrUsingUnionWith :: Set c a => c -> c -> c
unionWithUsingOrdLists :: OrdSet c a => (a -> a -> a) -> c -> c -> c
unionSeqWithUsingReducer :: (Set c a, Sequence seq) => (a -> a -> a) -> seq c -> c
intersectionWithUsingOrdLists :: OrdSet c a => (a -> a -> a) -> c -> c -> c
unsafeMapMonotonicUsingFoldr :: (OrdColl cin a, OrdCollX cout b) => (a -> b) -> (cin -> cout)
showsPrecUsingToList :: (Coll c a, Show a) => Int -> c -> ShowS
readsPrecUsingFromList :: (Coll c a, Read a) => Int -> ReadS c
compareUsingToOrdList :: OrdColl c a => c -> c -> Ordering


-- | Lazy Paring Heaps
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Chris Okasaki. <i>Purely Functional Data Structures</i>. 1998.
--   Section 6.5.</li>
--   </ul>
module Data.Edison.Coll.LazyPairingHeap
data Heap a
empty :: Heap a
singleton :: a -> Heap a
fromSeq :: (Ord a, Sequence seq) => seq a -> Heap a
insert :: Ord a => a -> Heap a -> Heap a
insertSeq :: (Ord a, Sequence seq) => seq a -> Heap a -> Heap a
union :: Ord a => Heap a -> Heap a -> Heap a
unionSeq :: (Ord a, Sequence seq) => seq (Heap a) -> Heap a
delete :: Ord a => a -> Heap a -> Heap a
deleteAll :: Ord a => a -> Heap a -> Heap a
deleteSeq :: (Ord a, Sequence seq) => seq a -> Heap a -> Heap a
null :: Heap a -> Bool
size :: Heap a -> Int
member :: Ord a => a -> Heap a -> Bool
count :: Ord a => a -> Heap a -> Int
strict :: Heap a -> Heap a
structuralInvariant :: Heap a -> Bool
toSeq :: Sequence seq => Heap a -> seq a
lookup :: Ord a => a -> Heap a -> a
lookupM :: (Ord a, Monad m) => a -> Heap a -> m a
lookupAll :: (Ord a, Sequence seq) => a -> Heap a -> seq a
lookupWithDefault :: Ord a => a -> a -> Heap a -> a
fold :: (a -> b -> b) -> b -> Heap a -> b
fold' :: (a -> b -> b) -> b -> Heap a -> b
fold1 :: (a -> a -> a) -> Heap a -> a
fold1' :: (a -> a -> a) -> Heap a -> a
filter :: Ord a => (a -> Bool) -> Heap a -> Heap a
partition :: Ord a => (a -> Bool) -> Heap a -> (Heap a, Heap a)
strictWith :: (a -> b) -> Heap a -> Heap a
deleteMin :: Ord a => Heap a -> Heap a
deleteMax :: Ord a => Heap a -> Heap a
unsafeInsertMin :: Ord a => a -> Heap a -> Heap a
unsafeInsertMax :: Ord a => a -> Heap a -> Heap a
unsafeFromOrdSeq :: (Ord a, Sequence seq) => seq a -> Heap a
unsafeAppend :: Ord a => Heap a -> Heap a -> Heap a
filterLT :: Ord a => a -> Heap a -> Heap a
filterLE :: Ord a => a -> Heap a -> Heap a
filterGT :: Ord a => a -> Heap a -> Heap a
filterGE :: Ord a => a -> Heap a -> Heap a
partitionLT_GE :: Ord a => a -> Heap a -> (Heap a, Heap a)
partitionLE_GT :: Ord a => a -> Heap a -> (Heap a, Heap a)
partitionLT_GT :: Ord a => a -> Heap a -> (Heap a, Heap a)
minView :: (Ord a, Monad m) => Heap a -> m (a, Heap a)
minElem :: Heap a -> a
maxView :: (Ord a, Monad m) => Heap a -> m (a, Heap a)
maxElem :: Ord a => Heap a -> a
foldr :: Ord a => (a -> b -> b) -> b -> Heap a -> b
foldr' :: Ord a => (a -> b -> b) -> b -> Heap a -> b
foldl :: Ord a => (b -> a -> b) -> b -> Heap a -> b
foldl' :: Ord a => (b -> a -> b) -> b -> Heap a -> b
foldr1 :: Ord a => (a -> a -> a) -> Heap a -> a
foldr1' :: Ord a => (a -> a -> a) -> Heap a -> a
foldl1 :: Ord a => (a -> a -> a) -> Heap a -> a
foldl1' :: Ord a => (a -> a -> a) -> Heap a -> a
toOrdSeq :: (Ord a, Sequence seq) => Heap a -> seq a
unsafeMapMonotonic :: (Ord a, Ord b) => (a -> b) -> Heap a -> Heap b
moduleName :: String
instance Ord a => Ord (Heap a)
instance Ord a => Monoid (Heap a)
instance (Ord a, CoArbitrary a) => CoArbitrary (Heap a)
instance (Ord a, Arbitrary a) => Arbitrary (Heap a)
instance (Ord a, Read a) => Read (Heap a)
instance (Ord a, Show a) => Show (Heap a)
instance Ord a => Eq (Heap a)
instance Ord a => OrdColl (Heap a) a
instance Ord a => Coll (Heap a) a
instance Ord a => OrdCollX (Heap a) a
instance Ord a => CollX (Heap a) a


-- | Leftist Heaps
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Chris Okasaki. <i>Purely Functional Data Structures</i>. 1998.
--   Section 3.1.</li>
--   </ul>
module Data.Edison.Coll.LeftistHeap
data Heap a
empty :: Ord a => Heap a
singleton :: Ord a => a -> Heap a
fromSeq :: (Ord a, Sequence seq) => seq a -> Heap a
insert :: Ord a => a -> Heap a -> Heap a
insertSeq :: (Ord a, Sequence seq) => seq a -> Heap a -> Heap a
union :: Ord a => Heap a -> Heap a -> Heap a
unionSeq :: (Ord a, Sequence seq) => seq (Heap a) -> Heap a
delete :: Ord a => a -> Heap a -> Heap a
deleteAll :: Ord a => a -> Heap a -> Heap a
deleteSeq :: (Ord a, Sequence seq) => seq a -> Heap a -> Heap a
null :: Ord a => Heap a -> Bool
size :: Ord a => Heap a -> Int
member :: Ord a => a -> Heap a -> Bool
count :: Ord a => a -> Heap a -> Int
strict :: Heap a -> Heap a
structuralInvariant :: Ord a => Heap a -> Bool
toSeq :: (Ord a, Sequence seq) => Heap a -> seq a
lookup :: Ord a => a -> Heap a -> a
lookupM :: (Ord a, Monad m) => a -> Heap a -> m a
lookupAll :: (Ord a, Sequence seq) => a -> Heap a -> seq a
lookupWithDefault :: Ord a => a -> a -> Heap a -> a
fold :: Ord a => (a -> b -> b) -> b -> Heap a -> b
fold' :: Ord a => (a -> b -> b) -> b -> Heap a -> b
fold1 :: Ord a => (a -> a -> a) -> Heap a -> a
fold1' :: Ord a => (a -> a -> a) -> Heap a -> a
filter :: Ord a => (a -> Bool) -> Heap a -> Heap a
partition :: Ord a => (a -> Bool) -> Heap a -> (Heap a, Heap a)
strictWith :: (a -> b) -> Heap a -> Heap a
deleteMin :: Ord a => Heap a -> Heap a
deleteMax :: Ord a => Heap a -> Heap a
unsafeInsertMin :: Ord a => a -> Heap a -> Heap a
unsafeInsertMax :: Ord a => a -> Heap a -> Heap a
unsafeFromOrdSeq :: (Ord a, Sequence seq) => seq a -> Heap a
unsafeAppend :: Ord a => Heap a -> Heap a -> Heap a
filterLT :: Ord a => a -> Heap a -> Heap a
filterLE :: Ord a => a -> Heap a -> Heap a
filterGT :: Ord a => a -> Heap a -> Heap a
filterGE :: Ord a => a -> Heap a -> Heap a
partitionLT_GE :: Ord a => a -> Heap a -> (Heap a, Heap a)
partitionLE_GT :: Ord a => a -> Heap a -> (Heap a, Heap a)
partitionLT_GT :: Ord a => a -> Heap a -> (Heap a, Heap a)
minView :: (Ord a, Monad m) => Heap a -> m (a, Heap a)
minElem :: Ord a => Heap a -> a
maxView :: (Ord a, Monad m) => Heap a -> m (a, Heap a)
maxElem :: Ord a => Heap a -> a
foldr :: Ord a => (a -> b -> b) -> b -> Heap a -> b
foldr' :: Ord a => (a -> b -> b) -> b -> Heap a -> b
foldl :: Ord a => (b -> a -> b) -> b -> Heap a -> b
foldl' :: Ord a => (b -> a -> b) -> b -> Heap a -> b
foldr1 :: Ord a => (a -> a -> a) -> Heap a -> a
foldr1' :: Ord a => (a -> a -> a) -> Heap a -> a
foldl1 :: Ord a => (a -> a -> a) -> Heap a -> a
foldl1' :: Ord a => (a -> a -> a) -> Heap a -> a
toOrdSeq :: (Ord a, Sequence seq) => Heap a -> seq a
unsafeMapMonotonic :: Ord a => (a -> a) -> Heap a -> Heap a
moduleName :: String
instance Ord a => Ord (Heap a)
instance Ord a => Monoid (Heap a)
instance (Ord a, CoArbitrary a) => CoArbitrary (Heap a)
instance (Ord a, Arbitrary a) => Arbitrary (Heap a)
instance (Ord a, Read a) => Read (Heap a)
instance (Ord a, Show a) => Show (Heap a)
instance Ord a => Eq (Heap a)
instance Ord a => OrdColl (Heap a) a
instance Ord a => Coll (Heap a) a
instance Ord a => OrdCollX (Heap a) a
instance Ord a => CollX (Heap a) a


-- | Skew heaps.
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Daniel Sleator and Robert Tarjan. "Self-Adjusting Heaps". <i>SIAM
--   Journal on Computing</i>, 15(1):52-69, February 1986.</li>
--   </ul>
module Data.Edison.Coll.SkewHeap
data Heap a
empty :: Ord a => Heap a
singleton :: Ord a => a -> Heap a
fromSeq :: (Ord a, Sequence seq) => seq a -> Heap a
insert :: Ord a => a -> Heap a -> Heap a
insertSeq :: (Ord a, Sequence seq) => seq a -> Heap a -> Heap a
union :: Ord a => Heap a -> Heap a -> Heap a
unionSeq :: (Ord a, Sequence seq) => seq (Heap a) -> Heap a
delete :: Ord a => a -> Heap a -> Heap a
deleteAll :: Ord a => a -> Heap a -> Heap a
deleteSeq :: (Ord a, Sequence seq) => seq a -> Heap a -> Heap a
null :: Ord a => Heap a -> Bool
size :: Ord a => Heap a -> Int
member :: Ord a => a -> Heap a -> Bool
count :: Ord a => a -> Heap a -> Int
strict :: Heap a -> Heap a
structuralInvariant :: Ord a => Heap a -> Bool
toSeq :: (Ord a, Sequence seq) => Heap a -> seq a
lookup :: Ord a => a -> Heap a -> a
lookupM :: (Ord a, Monad m) => a -> Heap a -> m a
lookupAll :: (Ord a, Sequence seq) => a -> Heap a -> seq a
lookupWithDefault :: Ord a => a -> a -> Heap a -> a
fold :: Ord a => (a -> b -> b) -> b -> Heap a -> b
fold' :: Ord a => (a -> b -> b) -> b -> Heap a -> b
fold1 :: Ord a => (a -> a -> a) -> Heap a -> a
fold1' :: Ord a => (a -> a -> a) -> Heap a -> a
filter :: Ord a => (a -> Bool) -> Heap a -> Heap a
partition :: Ord a => (a -> Bool) -> Heap a -> (Heap a, Heap a)
strictWith :: (a -> b) -> Heap a -> Heap a
deleteMin :: Ord a => Heap a -> Heap a
deleteMax :: Ord a => Heap a -> Heap a
unsafeInsertMin :: Ord a => a -> Heap a -> Heap a
unsafeInsertMax :: Ord a => a -> Heap a -> Heap a
unsafeFromOrdSeq :: (Ord a, Sequence seq) => seq a -> Heap a
unsafeAppend :: Ord a => Heap a -> Heap a -> Heap a
filterLT :: Ord a => a -> Heap a -> Heap a
filterLE :: Ord a => a -> Heap a -> Heap a
filterGT :: Ord a => a -> Heap a -> Heap a
filterGE :: Ord a => a -> Heap a -> Heap a
partitionLT_GE :: Ord a => a -> Heap a -> (Heap a, Heap a)
partitionLE_GT :: Ord a => a -> Heap a -> (Heap a, Heap a)
partitionLT_GT :: Ord a => a -> Heap a -> (Heap a, Heap a)
minView :: (Ord a, Monad m) => Heap a -> m (a, Heap a)
minElem :: Ord a => Heap a -> a
maxView :: (Ord a, Monad m) => Heap a -> m (a, Heap a)
maxElem :: Ord a => Heap a -> a
foldr :: Ord a => (a -> b -> b) -> b -> Heap a -> b
foldr' :: Ord a => (a -> b -> b) -> b -> Heap a -> b
foldl :: Ord a => (b -> a -> b) -> b -> Heap a -> b
foldl' :: Ord a => (b -> a -> b) -> b -> Heap a -> b
foldr1 :: Ord a => (a -> a -> a) -> Heap a -> a
foldr1' :: Ord a => (a -> a -> a) -> Heap a -> a
foldl1 :: Ord a => (a -> a -> a) -> Heap a -> a
foldl1' :: Ord a => (a -> a -> a) -> Heap a -> a
toOrdSeq :: (Ord a, Sequence seq) => Heap a -> seq a
unsafeMapMonotonic :: Ord a => (a -> a) -> Heap a -> Heap a
moduleName :: String
instance Ord a => Ord (Heap a)
instance Ord a => Monoid (Heap a)
instance (Ord a, CoArbitrary a) => CoArbitrary (Heap a)
instance (Ord a, Arbitrary a) => Arbitrary (Heap a)
instance (Ord a, Read a) => Read (Heap a)
instance (Ord a, Show a) => Show (Heap a)
instance Ord a => Eq (Heap a)
instance Ord a => OrdColl (Heap a) a
instance Ord a => Coll (Heap a) a
instance Ord a => OrdCollX (Heap a) a
instance Ord a => CollX (Heap a) a


-- | Splay heaps.
--   
--   If <a>minElem</a> is called frequently, then SplayHeap should be used
--   in conjunction with <a>Data.Edison.Coll.MinHeap</a>.
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Chris Okasaki. <i>Purely Functional Data Structures</i>. 1998.
--   Section 5.4.</li>
--   </ul>
module Data.Edison.Coll.SplayHeap
data Heap a
empty :: Heap a
singleton :: a -> Heap a
fromSeq :: (Ord a, Sequence s) => s a -> Heap a
insert :: Ord a => a -> Heap a -> Heap a
insertSeq :: (Ord a, Sequence s) => s a -> Heap a -> Heap a
union :: Ord a => Heap a -> Heap a -> Heap a
unionSeq :: (Ord a, Sequence s) => s (Heap a) -> Heap a
delete :: Ord a => a -> Heap a -> Heap a
deleteAll :: Ord a => a -> Heap a -> Heap a
deleteSeq :: (Ord a, Sequence s) => s a -> Heap a -> Heap a
null :: Heap a -> Bool
size :: Heap a -> Int
member :: Ord a => a -> Heap a -> Bool
count :: Ord a => a -> Heap a -> Int
strict :: Heap a -> Heap a
structuralInvariant :: Ord a => Heap a -> Bool
toSeq :: (Ord a, Sequence s) => Heap a -> s a
lookup :: Ord a => a -> Heap a -> a
lookupM :: (Ord a, Monad m) => a -> Heap a -> m a
lookupAll :: (Ord a, Sequence s) => a -> Heap a -> s a
lookupWithDefault :: Ord a => a -> a -> Heap a -> a
fold :: Ord a => (a -> b -> b) -> b -> Heap a -> b
fold' :: Ord a => (a -> b -> b) -> b -> Heap a -> b
fold1 :: Ord a => (a -> a -> a) -> Heap a -> a
fold1' :: Ord a => (a -> a -> a) -> Heap a -> a
filter :: Ord a => (a -> Bool) -> Heap a -> Heap a
partition :: Ord a => (a -> Bool) -> Heap a -> (Heap a, Heap a)
strictWith :: (a -> b) -> Heap a -> Heap a
deleteMin :: Ord a => Heap a -> Heap a
deleteMax :: Ord a => Heap a -> Heap a
unsafeInsertMin :: Ord a => a -> Heap a -> Heap a
unsafeInsertMax :: Ord a => a -> Heap a -> Heap a
unsafeFromOrdSeq :: (Ord a, Sequence s) => s a -> Heap a
unsafeAppend :: Ord a => Heap a -> Heap a -> Heap a
filterLT :: Ord a => a -> Heap a -> Heap a
filterLE :: Ord a => a -> Heap a -> Heap a
filterGT :: Ord a => a -> Heap a -> Heap a
filterGE :: Ord a => a -> Heap a -> Heap a
partitionLT_GE :: Ord a => a -> Heap a -> (Heap a, Heap a)
partitionLE_GT :: Ord a => a -> Heap a -> (Heap a, Heap a)
partitionLT_GT :: Ord a => a -> Heap a -> (Heap a, Heap a)
minView :: (Ord a, Monad m) => Heap a -> m (a, Heap a)
minElem :: Ord a => Heap a -> a
maxView :: (Ord a, Monad m) => Heap a -> m (a, Heap a)
maxElem :: Ord a => Heap a -> a
foldr :: Ord a => (a -> b -> b) -> b -> Heap a -> b
foldr' :: Ord a => (a -> b -> b) -> b -> Heap a -> b
foldl :: Ord a => (b -> a -> b) -> b -> Heap a -> b
foldl' :: Ord a => (b -> a -> b) -> b -> Heap a -> b
foldr1 :: Ord a => (a -> a -> a) -> Heap a -> a
foldr1' :: Ord a => (a -> a -> a) -> Heap a -> a
foldl1 :: Ord a => (a -> a -> a) -> Heap a -> a
foldl1' :: Ord a => (a -> a -> a) -> Heap a -> a
toOrdSeq :: (Ord a, Sequence s) => Heap a -> s a
unsafeMapMonotonic :: (a -> b) -> Heap a -> Heap b
moduleName :: String
instance Ord a => Ord (Heap a)
instance Ord a => Monoid (Heap a)
instance (Ord a, CoArbitrary a) => CoArbitrary (Heap a)
instance (Ord a, Arbitrary a) => Arbitrary (Heap a)
instance (Ord a, Read a) => Read (Heap a)
instance (Ord a, Show a) => Show (Heap a)
instance Ord a => Eq (Heap a)
instance Ord a => OrdColl (Heap a) a
instance Ord a => Coll (Heap a) a
instance Ord a => OrdCollX (Heap a) a
instance Ord a => CollX (Heap a) a


-- | The standard library <a>Data.Set</a> repackaged as an Edison
--   collection.
module Data.Edison.Coll.StandardSet
type Set = Set
empty :: Set a
singleton :: a -> Set a
fromSeq :: (Ord a, Sequence seq) => seq a -> Set a
insert :: Ord a => a -> Set a -> Set a
insertSeq :: (Ord a, Sequence seq) => seq a -> Set a -> Set a
union :: Ord a => Set a -> Set a -> Set a
unionSeq :: (Ord a, Sequence seq) => seq (Set a) -> Set a
delete :: Ord a => a -> Set a -> Set a
deleteAll :: Ord a => a -> Set a -> Set a
deleteSeq :: (Ord a, Sequence seq) => seq a -> Set a -> Set a
null :: Set a -> Bool
size :: Set a -> Int
member :: Ord a => a -> Set a -> Bool
count :: Ord a => a -> Set a -> Int
strict :: Ord a => Set a -> Set a
toSeq :: (Ord a, Sequence seq) => Set a -> seq a
lookup :: Ord a => a -> Set a -> a
lookupM :: (Ord a, Monad m) => a -> Set a -> m a
lookupAll :: (Ord a, Sequence seq) => a -> Set a -> seq a
lookupWithDefault :: Ord a => a -> a -> Set a -> a
fold :: (a -> b -> b) -> b -> Set a -> b
fold' :: (a -> b -> b) -> b -> Set a -> b
fold1 :: (a -> a -> a) -> Set a -> a
fold1' :: (a -> a -> a) -> Set a -> a
filter :: Ord a => (a -> Bool) -> Set a -> Set a
partition :: Ord a => (a -> Bool) -> Set a -> (Set a, Set a)
strictWith :: Ord a => (a -> b) -> Set a -> Set a
structuralInvariant :: Ord a => Set a -> Bool
deleteMin :: Ord a => Set a -> Set a
deleteMax :: Ord a => Set a -> Set a
unsafeInsertMin :: Ord a => a -> Set a -> Set a
unsafeInsertMax :: Ord a => a -> Set a -> Set a
unsafeFromOrdSeq :: (Ord a, Sequence seq) => seq a -> Set a
unsafeAppend :: Ord a => Set a -> Set a -> Set a
filterLT :: Ord a => a -> Set a -> Set a
filterLE :: Ord a => a -> Set a -> Set a
filterGT :: Ord a => a -> Set a -> Set a
filterGE :: Ord a => a -> Set a -> Set a
partitionLT_GE :: Ord a => a -> Set a -> (Set a, Set a)
partitionLE_GT :: Ord a => a -> Set a -> (Set a, Set a)
partitionLT_GT :: Ord a => a -> Set a -> (Set a, Set a)
minView :: (Ord a, Monad m) => Set a -> m (a, Set a)
minElem :: Set a -> a
maxView :: (Ord a, Monad m) => Set a -> m (a, Set a)
maxElem :: Set a -> a
foldr :: (a -> b -> b) -> b -> Set a -> b
foldr' :: (a -> b -> b) -> b -> Set a -> b
foldl :: (b -> a -> b) -> b -> Set a -> b
foldl' :: (b -> a -> b) -> b -> Set a -> b
foldr1 :: (a -> a -> a) -> Set a -> a
foldr1' :: (a -> a -> a) -> Set a -> a
foldl1 :: (a -> a -> a) -> Set a -> a
foldl1' :: (a -> a -> a) -> Set a -> a
toOrdSeq :: (Ord a, Sequence seq) => Set a -> seq a
unsafeMapMonotonic :: Ord a => (a -> a) -> Set a -> Set a
intersection :: Ord a => Set a -> Set a -> Set a
difference :: Ord a => Set a -> Set a -> Set a
symmetricDifference :: Ord a => Set a -> Set a -> Set a
properSubset :: Ord a => Set a -> Set a -> Bool
subset :: Ord a => Set a -> Set a -> Bool
fromSeqWith :: (Ord a, Sequence seq) => (a -> a -> a) -> seq a -> Set a
insertWith :: Ord a => (a -> a -> a) -> a -> Set a -> Set a
insertSeqWith :: (Ord a, Sequence seq) => (a -> a -> a) -> seq a -> Set a -> Set a
unionl :: Ord a => Set a -> Set a -> Set a
unionr :: Ord a => Set a -> Set a -> Set a
unionWith :: Ord a => (a -> a -> a) -> Set a -> Set a -> Set a
unionSeqWith :: (Ord a, Sequence seq) => (a -> a -> a) -> seq (Set a) -> Set a
intersectionWith :: Ord a => (a -> a -> a) -> Set a -> Set a -> Set a
moduleName :: String
instance (Ord a, CoArbitrary a) => CoArbitrary (Set a)
instance (Ord a, Arbitrary a) => Arbitrary (Set a)
instance Ord a => OrdSet (Set a) a
instance Ord a => OrdSetX (Set a) a
instance Ord a => Set (Set a) a
instance Ord a => SetX (Set a) a
instance Ord a => OrdColl (Set a) a
instance Ord a => Coll (Set a) a
instance Ord a => OrdCollX (Set a) a
instance Ord a => CollX (Set a) a


-- | An efficient implementation of sets over small enumerations. The
--   implementation of <tt>EnumSet</tt> is based on bit-wise operations.
--   
--   For this implementation to work as expected at type <tt>A</tt>, there
--   are a number of preconditions on the <tt>Eq</tt>, <tt>Enum</tt> and
--   <tt>Ord</tt> instances.
--   
--   The <tt>Enum A</tt> instance must create a bijection between the
--   elements of type <tt>A</tt> and a finite subset of the naturals
--   [0,1,2,3....]. As a corollary we must have:
--   
--   <pre>
--   forall x y::A, fromEnum x == fromEnum y &lt;==&gt; x is indistinguishable from y
--   </pre>
--   
--   Also, the number of distinct elements of <tt>A</tt> must be less than
--   or equal to the number of bits in <tt>Word</tt>.
--   
--   The <tt>Enum A</tt> instance must be consistent with the <tt>Eq A</tt>
--   instance. That is, we must have:
--   
--   <pre>
--   forall x y::A, x == y &lt;==&gt; toEnum x == toEnum y
--   </pre>
--   
--   Additionally, for operations that require an <tt>Ord A</tt> context,
--   we require that toEnum be monotonic with respect to comparison. That
--   is, we must have:
--   
--   <pre>
--   forall x y::A, x &lt; y &lt;==&gt; toEnum x &lt; toEnum y
--   </pre>
--   
--   Derived <tt>Eq</tt>, <tt>Ord</tt> and <tt>Enum</tt> instances will
--   fulfill these conditions, if the enumerated type has sufficently few
--   constructors.
module Data.Edison.Coll.EnumSet

-- | A set of values <tt>a</tt> implemented as bitwise operations. Useful
--   for members of class Enum with no more elements than there are bits in
--   <tt>Word</tt>.
data Set a

-- | <i>O(1)</i>. The empty set.
empty :: Set a

-- | <i>O(1)</i>. Create a singleton set.
singleton :: (Eq a, Enum a) => a -> Set a
fromSeq :: (Eq a, Enum a, Sequence s) => s a -> Set a

-- | <i>O(1)</i>. Insert an element in a set. If the set already contains
--   an element equal to the given value, it is replaced with the new
--   value.
insert :: (Eq a, Enum a) => a -> Set a -> Set a
insertSeq :: (Eq a, Enum a, Sequence s) => s a -> Set a -> Set a

-- | <i>O(1)</i>. The union of two sets.
union :: Set a -> Set a -> Set a

-- | The union of a list of sets: (<tt><tt>unions</tt> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unionSeq :: (Eq a, Enum a, Sequence s) => s (Set a) -> Set a

-- | <i>O(1)</i>. Delete an element from a set.
delete :: (Eq a, Enum a) => a -> Set a -> Set a
deleteAll :: (Eq a, Enum a) => a -> Set a -> Set a
deleteSeq :: (Eq a, Enum a, Sequence s) => s a -> Set a -> Set a

-- | <i>O(1)</i>. Is this the empty set?
null :: Set a -> Bool

-- | <i>O(1)</i>. The number of elements in the set.
size :: Set a -> Int

-- | <i>O(1)</i>. Is the element in the set?
member :: (Eq a, Enum a) => a -> Set a -> Bool
count :: (Eq a, Enum a) => a -> Set a -> Int
strict :: Set a -> Set a

-- | <i>O(1)</i>. Delete the minimal element.
deleteMin :: Enum a => Set a -> Set a

-- | <i>O(1)</i>. Delete the maximal element.
deleteMax :: Enum a => Set a -> Set a
unsafeInsertMin :: (Ord a, Enum a) => a -> Set a -> Set a
unsafeInsertMax :: (Ord a, Enum a) => a -> Set a -> Set a
unsafeFromOrdSeq :: (Ord a, Enum a, Sequence s) => s a -> Set a
unsafeAppend :: (Ord a, Enum a) => Set a -> Set a -> Set a
filterLT :: (Ord a, Enum a) => a -> Set a -> Set a
filterLE :: (Ord a, Enum a) => a -> Set a -> Set a
filterGT :: (Ord a, Enum a) => a -> Set a -> Set a
filterGE :: (Ord a, Enum a) => a -> Set a -> Set a
partitionLT_GE :: (Ord a, Enum a) => a -> Set a -> (Set a, Set a)
partitionLE_GT :: (Ord a, Enum a) => a -> Set a -> (Set a, Set a)
partitionLT_GT :: (Ord a, Enum a) => a -> Set a -> (Set a, Set a)

-- | <i>O(1)</i>. The intersection of two sets.
intersection :: Set a -> Set a -> Set a

-- | <i>O(1)</i>. Difference of two sets.
difference :: Set a -> Set a -> Set a
symmetricDifference :: Set a -> Set a -> Set a

-- | <i>O(1)</i>. Is this a proper subset? (ie. a subset but not equal).
properSubset :: Set a -> Set a -> Bool

-- | <i>O(1)</i>. Is this a subset? <tt>(s1 <a>subset</a> s2)</tt> tells
--   whether <tt>s1</tt> is a subset of <tt>s2</tt>.
subset :: Set a -> Set a -> Bool
toSeq :: (Eq a, Enum a, Sequence s) => Set a -> s a
lookup :: (Eq a, Enum a) => a -> Set a -> a
lookupM :: (Eq a, Enum a, Monad m) => a -> Set a -> m a
lookupAll :: (Eq a, Enum a, Sequence s) => a -> Set a -> s a
lookupWithDefault :: (Eq a, Enum a) => a -> a -> Set a -> a
fold :: (Eq a, Enum a) => (a -> c -> c) -> c -> Set a -> c
fold' :: (Eq a, Enum a) => (a -> c -> c) -> c -> Set a -> c
fold1 :: (Eq a, Enum a) => (a -> a -> a) -> Set a -> a
fold1' :: (Eq a, Enum a) => (a -> a -> a) -> Set a -> a

-- | <i>O(n)</i>. Filter all elements that satisfy the predicate.
filter :: (Eq a, Enum a) => (a -> Bool) -> Set a -> Set a

-- | <i>O(n)</i>. Partition the set into two sets, one with all elements
--   that satisfy the predicate and one with all elements that don't
--   satisfy the predicate. See also <tt>split</tt>.
partition :: (Eq a, Enum a) => (a -> Bool) -> Set a -> (Set a, Set a)
strictWith :: (a -> b) -> Set a -> Set a
minView :: (Enum a, Monad m) => Set a -> m (a, Set a)

-- | <i>O(1)</i>. The minimal element of a set.
minElem :: Enum a => Set a -> a
maxView :: (Enum a, Monad m) => Set a -> m (a, Set a)

-- | <i>O(1)</i>. The maximal element of a set.
maxElem :: Enum a => Set a -> a
foldr :: (Ord a, Enum a) => (a -> b -> b) -> b -> Set a -> b
foldr' :: (Ord a, Enum a) => (a -> b -> b) -> b -> Set a -> b
foldl :: (Ord a, Enum a) => (c -> a -> c) -> c -> Set a -> c
foldl' :: (Ord a, Enum a) => (c -> a -> c) -> c -> Set a -> c
foldr1 :: (Ord a, Enum a) => (a -> a -> a) -> Set a -> a
foldr1' :: (Ord a, Enum a) => (a -> a -> a) -> Set a -> a
foldl1 :: (Ord a, Enum a) => (a -> a -> a) -> Set a -> a
foldl1' :: (Ord a, Enum a) => (a -> a -> a) -> Set a -> a
toOrdSeq :: (Ord a, Enum a, Sequence s) => Set a -> s a
unsafeMapMonotonic :: Enum a => (a -> a) -> Set a -> Set a
fromSeqWith :: (Eq a, Enum a, Sequence s) => (a -> a -> a) -> s a -> Set a
fromOrdSeq :: (Ord a, Enum a, Sequence s) => s a -> Set a
insertWith :: (Eq a, Enum a) => (a -> a -> a) -> a -> Set a -> Set a
insertSeqWith :: (Eq a, Enum a, Sequence s) => (a -> a -> a) -> s a -> Set a -> Set a
unionl :: Set a -> Set a -> Set a
unionr :: Set a -> Set a -> Set a
unionWith :: (a -> a -> a) -> Set a -> Set a -> Set a
unionSeqWith :: (Eq a, Enum a, Sequence s) => (a -> a -> a) -> s (Set a) -> Set a
intersectionWith :: (a -> a -> a) -> Set a -> Set a -> Set a

-- | <i>O(n)</i>. <tt><a>map</a> f s</tt> is the set obtained by applying
--   <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Enum a, Enum b) => (a -> b) -> Set a -> Set b

-- | <i>O(1)</i> Changes the type of the elements in the set without
--   changing the representation. Equivalant to <tt>map (toEnum .
--   fromEnum)</tt>, and to <tt>(fromBits . toBits)</tt>. This method is
--   operationally a no-op.
setCoerce :: (Enum a, Enum b) => Set a -> Set b

-- | <i>O(1)</i>. The complement of a set with its universe set.
--   <tt>complement</tt> can be used with bounded types for which the
--   universe set will be automatically created.
complement :: (Eq a, Bounded a, Enum a) => Set a -> Set a

-- | <i>O(1)</i> Get the underlying bit-encoded representation. This method
--   is operationally a no-op.
toBits :: Set a -> Word

-- | <i>O(1)</i> Create an EnumSet from a bit-encoded representation. This
--   method is operationally a no-op.
fromBits :: Word -> Set a
moduleName :: String
instance Eq (Set a)
instance (Ord a, Enum a) => Ord (Set a)
instance (Eq a, Enum a) => Monoid (Set a)
instance (Eq a, Enum a, CoArbitrary a) => CoArbitrary (Set a)
instance (Eq a, Enum a, Arbitrary a) => Arbitrary (Set a)
instance (Eq a, Enum a, Read a) => Read (Set a)
instance (Eq a, Enum a, Show a) => Show (Set a)
instance (Ord a, Enum a) => OrdSet (Set a) a
instance (Ord a, Enum a) => OrdSetX (Set a) a
instance (Eq a, Enum a) => Set (Set a) a
instance (Ord a, Enum a) => OrdColl (Set a) a
instance (Eq a, Enum a) => Coll (Set a) a
instance (Eq a, Enum a) => SetX (Set a) a
instance (Ord a, Enum a) => OrdCollX (Set a) a
instance (Eq a, Enum a) => CollX (Set a) a


-- | Sets implemented as unbalanced binary search trees.
module Data.Edison.Coll.UnbalancedSet
data Set a
empty :: Set a
singleton :: a -> Set a
fromSeq :: (Ord a, Sequence seq) => seq a -> Set a
insert :: Ord a => a -> Set a -> Set a
insertSeq :: (Ord a, Sequence seq) => seq a -> Set a -> Set a
union :: Ord a => Set a -> Set a -> Set a
unionSeq :: (Ord a, Sequence seq) => seq (Set a) -> Set a
delete :: Ord a => a -> Set a -> Set a
deleteAll :: Ord a => a -> Set a -> Set a
deleteSeq :: (Ord a, Sequence seq) => seq a -> Set a -> Set a
null :: Set a -> Bool
size :: Set a -> Int
member :: Ord a => a -> Set a -> Bool
count :: Ord a => a -> Set a -> Int
strict :: Set a -> Set a
structuralInvariant :: Ord a => Set a -> Bool
toSeq :: (Ord a, Sequence seq) => Set a -> seq a
lookup :: Ord a => a -> Set a -> a
lookupM :: (Ord a, Monad m) => a -> Set a -> m a
lookupAll :: (Ord a, Sequence seq) => a -> Set a -> seq a
lookupWithDefault :: Ord a => a -> a -> Set a -> a
fold :: (a -> b -> b) -> b -> Set a -> b
fold' :: (a -> b -> b) -> b -> Set a -> b
fold1 :: (a -> a -> a) -> Set a -> a
fold1' :: (a -> a -> a) -> Set a -> a
filter :: Ord a => (a -> Bool) -> Set a -> Set a
partition :: Ord a => (a -> Bool) -> Set a -> (Set a, Set a)
strictWith :: (a -> b) -> Set a -> Set a
deleteMin :: Ord a => Set a -> Set a
deleteMax :: Ord a => Set a -> Set a
unsafeInsertMin :: Ord a => a -> Set a -> Set a
unsafeInsertMax :: Ord a => a -> Set a -> Set a
unsafeFromOrdSeq :: (Ord a, Sequence seq) => seq a -> Set a
unsafeAppend :: Ord a => Set a -> Set a -> Set a
filterLT :: Ord a => a -> Set a -> Set a
filterLE :: Ord a => a -> Set a -> Set a
filterGT :: Ord a => a -> Set a -> Set a
filterGE :: Ord a => a -> Set a -> Set a
partitionLT_GE :: Ord a => a -> Set a -> (Set a, Set a)
partitionLE_GT :: Ord a => a -> Set a -> (Set a, Set a)
partitionLT_GT :: Ord a => a -> Set a -> (Set a, Set a)
minView :: Monad m => Set a -> m (a, Set a)
minElem :: Set a -> a
maxView :: Monad m => Set a -> m (a, Set a)
maxElem :: Set a -> a
foldr :: (a -> b -> b) -> b -> Set a -> b
foldr' :: (a -> b -> b) -> b -> Set a -> b
foldl :: (b -> a -> b) -> b -> Set a -> b
foldl' :: (b -> a -> b) -> b -> Set a -> b
foldr1 :: (a -> a -> a) -> Set a -> a
foldr1' :: (a -> a -> a) -> Set a -> a
foldl1 :: (a -> a -> a) -> Set a -> a
foldl1' :: (a -> a -> a) -> Set a -> a
toOrdSeq :: (Ord a, Sequence seq) => Set a -> seq a
unsafeMapMonotonic :: Ord a => (a -> a) -> Set a -> Set a
intersection :: Ord a => Set a -> Set a -> Set a
difference :: Ord a => Set a -> Set a -> Set a
symmetricDifference :: Ord a => Set a -> Set a -> Set a
properSubset :: Ord a => Set a -> Set a -> Bool
subset :: Ord a => Set a -> Set a -> Bool
fromSeqWith :: (Ord a, Sequence seq) => (a -> a -> a) -> seq a -> Set a
insertWith :: Ord a => (a -> a -> a) -> a -> Set a -> Set a
insertSeqWith :: (Ord a, Sequence seq) => (a -> a -> a) -> seq a -> Set a -> Set a
unionl :: Ord a => Set a -> Set a -> Set a
unionr :: Ord a => Set a -> Set a -> Set a
unionWith :: Ord a => (a -> a -> a) -> Set a -> Set a -> Set a
unionSeqWith :: (Ord a, Sequence seq) => (a -> a -> a) -> seq (Set a) -> Set a
intersectionWith :: Ord a => (a -> a -> a) -> Set a -> Set a -> Set a
moduleName :: String
instance Ord a => Ord (Set a)
instance Ord a => Monoid (Set a)
instance (Ord a, CoArbitrary a) => CoArbitrary (Set a)
instance (Ord a, Arbitrary a) => Arbitrary (Set a)
instance (Ord a, Read a) => Read (Set a)
instance (Ord a, Show a) => Show (Set a)
instance Ord a => Eq (Set a)
instance Ord a => OrdSet (Set a) a
instance Ord a => OrdSetX (Set a) a
instance Ord a => Set (Set a) a
instance Ord a => SetX (Set a) a
instance Ord a => OrdColl (Set a) a
instance Ord a => Coll (Set a) a
instance Ord a => OrdCollX (Set a) a
instance Ord a => CollX (Set a) a


-- | A generic adaptor for bags to keep the minimum element separately.
module Data.Edison.Coll.MinHeap
data Min h a
empty :: Min h a
singleton :: (CollX h a, Ord a) => a -> Min h a
fromSeq :: (OrdColl h a, Ord a, Sequence s) => s a -> Min h a
insert :: (OrdCollX h a, Ord a) => a -> Min h a -> Min h a
insertSeq :: (OrdColl h a, Ord a, Sequence s) => s a -> Min h a -> Min h a
union :: (OrdCollX h a, Ord a) => Min h a -> Min h a -> Min h a
unionSeq :: (OrdColl h a, Ord a, Sequence s) => s (Min h a) -> Min h a
delete :: (OrdColl h a, Ord a) => a -> Min h a -> Min h a
deleteAll :: (OrdColl h a, Ord a) => a -> Min h a -> Min h a
deleteSeq :: (OrdColl h a, Ord a, Sequence s) => s a -> Min h a -> Min h a
null :: Min h a -> Bool
size :: CollX h a => Min h a -> Int
member :: (CollX h a, Ord a) => a -> Min h a -> Bool
count :: (CollX h a, Ord a) => a -> Min h a -> Int
strict :: (CollX h a, Ord a) => Min h a -> Min h a
structuralInvariant :: (Ord a, OrdColl h a) => Min h a -> Bool
toSeq :: (Coll h a, Sequence s) => Min h a -> s a
lookup :: (Coll h a, Ord a) => a -> Min h a -> a
lookupM :: (Coll h a, Ord a, Monad m) => a -> Min h a -> m a
lookupAll :: (Coll h a, Ord a, Sequence s) => a -> Min h a -> s a
lookupWithDefault :: (Coll h a, Ord a) => a -> a -> Min h a -> a
fold :: Coll h a => (a -> b -> b) -> b -> Min h a -> b
fold' :: Coll h a => (a -> b -> b) -> b -> Min h a -> b
fold1 :: Coll h a => (a -> a -> a) -> Min h a -> a
fold1' :: Coll h a => (a -> a -> a) -> Min h a -> a
filter :: OrdColl h a => (a -> Bool) -> Min h a -> Min h a
partition :: OrdColl h a => (a -> Bool) -> Min h a -> (Min h a, Min h a)
strictWith :: OrdColl h a => (a -> b) -> Min h a -> Min h a
deleteMin :: (OrdColl h a, Ord a) => Min h a -> Min h a
deleteMax :: (OrdCollX h a, Ord a) => Min h a -> Min h a
unsafeInsertMin :: (OrdCollX h a, Ord a) => a -> Min h a -> Min h a
unsafeInsertMax :: (OrdCollX h a, Ord a) => a -> Min h a -> Min h a
unsafeFromOrdSeq :: (OrdCollX h a, Ord a, Sequence s) => s a -> Min h a
unsafeAppend :: (OrdCollX h a, Ord a) => Min h a -> Min h a -> Min h a
filterLT :: (OrdCollX h a, Ord a) => a -> Min h a -> Min h a
filterLE :: (OrdCollX h a, Ord a) => a -> Min h a -> Min h a
filterGT :: (OrdColl h a, Ord a) => a -> Min h a -> Min h a
filterGE :: (OrdColl h a, Ord a) => a -> Min h a -> Min h a
partitionLT_GE :: (OrdColl h a, Ord a) => a -> Min h a -> (Min h a, Min h a)
partitionLE_GT :: (OrdColl h a, Ord a) => a -> Min h a -> (Min h a, Min h a)
partitionLT_GT :: (OrdColl h a, Ord a) => a -> Min h a -> (Min h a, Min h a)
minView :: (OrdColl h a, Ord a, Monad m) => Min h a -> m (a, Min h a)
minElem :: (OrdColl h a, Ord a) => Min h a -> a
maxView :: (OrdColl h a, Ord a, Monad m) => Min h a -> m (a, Min h a)
maxElem :: (OrdColl h a, Ord a) => Min h a -> a
foldr :: (OrdColl h a, Ord a) => (a -> b -> b) -> b -> Min h a -> b
foldr' :: (OrdColl h a, Ord a) => (a -> b -> b) -> b -> Min h a -> b
foldl :: (OrdColl h a, Ord a) => (b -> a -> b) -> b -> Min h a -> b
foldl' :: (OrdColl h a, Ord a) => (b -> a -> b) -> b -> Min h a -> b
foldr1 :: (OrdColl h a, Ord a) => (a -> a -> a) -> Min h a -> a
foldr1' :: (OrdColl h a, Ord a) => (a -> a -> a) -> Min h a -> a
foldl1 :: (OrdColl h a, Ord a) => (a -> a -> a) -> Min h a -> a
foldl1' :: (OrdColl h a, Ord a) => (a -> a -> a) -> Min h a -> a
toOrdSeq :: (OrdColl h a, Ord a, Sequence s) => Min h a -> s a
unsafeMapMonotonic :: (OrdColl h a, Ord a) => (a -> a) -> Min h a -> Min h a
toColl :: OrdColl h a => Min h a -> h
fromColl :: OrdColl h a => h -> Min h a
moduleName :: String
instance (Eq h, Eq a) => Eq (Min h a)
instance (Eq h, OrdColl h a) => Ord (Min h a)
instance OrdColl h a => Monoid (Min h a)
instance (OrdColl h a, CoArbitrary h, CoArbitrary a) => CoArbitrary (Min h a)
instance (OrdColl h a, Arbitrary h, Arbitrary a) => Arbitrary (Min h a)
instance (OrdColl h a, Read h) => Read (Min h a)
instance (OrdColl h a, Show h) => Show (Min h a)
instance (OrdColl h a, Ord a) => OrdColl (Min h a) a
instance (OrdColl h a, Ord a) => Coll (Min h a) a
instance (OrdColl h a, Ord a) => OrdCollX (Min h a) a
instance (OrdColl h a, Ord a) => CollX (Min h a) a


-- | This module implements Banker's Queues. It has the standard running
--   times from <a>Data.Edison.Seq</a> except for the following:
--   
--   <ul>
--   <li>rcons, size, inBounds <tt>O( 1 )</tt></li>
--   </ul>
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Chris Okasaki, <i>Purely Functional Data Structures</i>, 1998,
--   sections 6.3.2 and 8.4.1.</li>
--   <li>Chris Okasaki, "Simple and efficient purely functional queues and
--   deques", <i>Journal of Function Programming</i> 5(4):583-592, October
--   1995.</li>
--   </ul>
module Data.Edison.Seq.BankersQueue
data Seq a
empty :: Seq a
singleton :: a -> Seq a
lcons :: a -> Seq a -> Seq a
rcons :: a -> Seq a -> Seq a
append :: Seq a -> Seq a -> Seq a
lview :: Monad m => Seq a -> m (a, Seq a)
lhead :: Seq a -> a
ltail :: Seq a -> Seq a
rview :: Monad m => Seq a -> m (a, Seq a)
rhead :: Seq a -> a
rtail :: Seq a -> Seq a
lheadM :: Monad m => Seq a -> m a
ltailM :: Monad m => Seq a -> m (Seq a)
rheadM :: Monad m => Seq a -> m a
rtailM :: Monad m => Seq a -> m (Seq a)
null :: Seq a -> Bool
size :: Seq a -> Int
concat :: Seq (Seq a) -> Seq a
reverse :: Seq a -> Seq a
reverseOnto :: Seq a -> Seq a -> Seq a
fromList :: [a] -> Seq a
toList :: Seq a -> [a]
map :: (a -> b) -> Seq a -> Seq b
concatMap :: (a -> Seq b) -> Seq a -> Seq b
fold :: (a -> b -> b) -> b -> Seq a -> b
fold' :: (a -> b -> b) -> b -> Seq a -> b
fold1 :: (a -> a -> a) -> Seq a -> a
fold1' :: (a -> a -> a) -> Seq a -> a
foldr :: (a -> b -> b) -> b -> Seq a -> b
foldr' :: (a -> b -> b) -> b -> Seq a -> b
foldl :: (b -> a -> b) -> b -> Seq a -> b
foldl' :: (b -> a -> b) -> b -> Seq a -> b
foldr1 :: (a -> a -> a) -> Seq a -> a
foldr1' :: (a -> a -> a) -> Seq a -> a
foldl1 :: (a -> a -> a) -> Seq a -> a
foldl1' :: (a -> a -> a) -> Seq a -> a
reducer :: (a -> a -> a) -> a -> Seq a -> a
reducer' :: (a -> a -> a) -> a -> Seq a -> a
reducel :: (a -> a -> a) -> a -> Seq a -> a
reducel' :: (a -> a -> a) -> a -> Seq a -> a
reduce1 :: (a -> a -> a) -> Seq a -> a
reduce1' :: (a -> a -> a) -> Seq a -> a
copy :: Int -> a -> Seq a
inBounds :: Int -> Seq a -> Bool
lookup :: Int -> Seq a -> a
lookupM :: Monad m => Int -> Seq a -> m a
lookupWithDefault :: a -> Int -> Seq a -> a
update :: Int -> a -> Seq a -> Seq a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldrWithIndex' :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
foldlWithIndex' :: (b -> Int -> a -> b) -> b -> Seq a -> b
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
subseq :: Int -> Int -> Seq a -> Seq a
filter :: (a -> Bool) -> Seq a -> Seq a
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
takeWhile :: (a -> Bool) -> Seq a -> Seq a
dropWhile :: (a -> Bool) -> Seq a -> Seq a
splitWhile :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
zip :: Seq a -> Seq b -> Seq (a, b)
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzip3 :: Seq (a, b, c) -> (Seq a, Seq b, Seq c)
unzipWith :: (a -> b) -> (a -> c) -> Seq a -> (Seq b, Seq c)
unzipWith3 :: (a -> b) -> (a -> c) -> (a -> d) -> Seq a -> (Seq b, Seq c, Seq d)
strict :: Seq a -> Seq a
strictWith :: (a -> b) -> Seq a -> Seq a
structuralInvariant :: Seq a -> Bool
moduleName :: String
instance Monoid (Seq a)
instance CoArbitrary a => CoArbitrary (Seq a)
instance Arbitrary a => Arbitrary (Seq a)
instance Read a => Read (Seq a)
instance Show a => Show (Seq a)
instance Ord a => Ord (Seq a)
instance Eq a => Eq (Seq a)
instance MonadPlus Seq
instance Monad Seq
instance Functor Seq
instance Sequence Seq


-- | One-sided Braun sequences. All running times are as listed in
--   <a>Data.Edison.Seq</a> except the following:
--   
--   <ul>
--   <li>lview, lcons, ltail* <tt>O( log n )</tt></li>
--   <li>rcons, rview, rhead*, rtail*, size <tt>O( log^2 n )</tt></li>
--   <li>copy, inBounds, lookup*, update, adjust <tt>O( log i )</tt></li>
--   <li>append <tt>O( n1 log n2 )</tt></li>
--   <li>concat <tt>O( n + m log m )</tt></li>
--   <li>drop, splitAt <tt>O( i log n )</tt></li>
--   <li>subseq <tt>O( i log n + len )</tt></li>
--   <li>reverseOnto <tt>O( n1 log n2 )</tt></li>
--   <li>concatMap, (&gt;&gt;=) <tt>O( n * t + m log m )</tt>, where
--   <tt>n</tt> is the length of the input sequence <tt>m</tt> is the
--   length of the output sequence and <tt>t</tt> is the running time of
--   <tt>f</tt></li>
--   </ul>
--   
--   By keeping track of the size, we could get rcons, rview, rhead*, and
--   rtail* down to <tt>O(log n)</tt> as well; furthermore, size would be
--   <tt>O( 1 )</tt>.
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Rob Hoogerwoord. "A symmetric set of efficient list operations".
--   <i>Journal of Functional Programming</i>, 2(4):505--513, 1992.</li>
--   <li>Rob Hoogerwoord. "A Logarithmic Implementation of Flexible
--   Arrays". <i>Mathematics of Program Construction</i> (MPC'92), pages
--   191-207.</li>
--   <li>Chris Okasaki. "Three algorithms on Braun Trees". <i>Journal of
--   Function Programming</i> 7(6):661-666. Novemebr 1997.</li>
--   </ul>
module Data.Edison.Seq.BraunSeq
data Seq a
empty :: Seq a
singleton :: a -> Seq a
lcons :: a -> Seq a -> Seq a
rcons :: a -> Seq a -> Seq a
append :: Seq a -> Seq a -> Seq a
lview :: Monad m => Seq a -> m (a, Seq a)
lhead :: Seq a -> a
ltail :: Seq a -> Seq a
rview :: Monad m => Seq a -> m (a, Seq a)
rhead :: Seq a -> a
rtail :: Seq a -> Seq a
lheadM :: Monad m => Seq a -> m a
ltailM :: Monad m => Seq a -> m (Seq a)
rheadM :: Monad m => Seq a -> m a
rtailM :: Monad m => Seq a -> m (Seq a)
null :: Seq a -> Bool
size :: Seq a -> Int
concat :: Seq (Seq a) -> Seq a
reverse :: Seq a -> Seq a
reverseOnto :: Seq a -> Seq a -> Seq a
fromList :: [a] -> Seq a
toList :: Seq a -> [a]
map :: (a -> b) -> Seq a -> Seq b
concatMap :: (a -> Seq b) -> Seq a -> Seq b
fold :: (a -> b -> b) -> b -> Seq a -> b
fold' :: (a -> b -> b) -> b -> Seq a -> b
fold1 :: (a -> a -> a) -> Seq a -> a
fold1' :: (a -> a -> a) -> Seq a -> a
foldr :: (a -> b -> b) -> b -> Seq a -> b
foldr' :: (a -> b -> b) -> b -> Seq a -> b
foldl :: (b -> a -> b) -> b -> Seq a -> b
foldl' :: (b -> a -> b) -> b -> Seq a -> b
foldr1 :: (a -> a -> a) -> Seq a -> a
foldr1' :: (a -> a -> a) -> Seq a -> a
foldl1 :: (a -> a -> a) -> Seq a -> a
foldl1' :: (a -> a -> a) -> Seq a -> a
reducer :: (a -> a -> a) -> a -> Seq a -> a
reducer' :: (a -> a -> a) -> a -> Seq a -> a
reducel :: (a -> a -> a) -> a -> Seq a -> a
reducel' :: (a -> a -> a) -> a -> Seq a -> a
reduce1 :: (a -> a -> a) -> Seq a -> a
reduce1' :: (a -> a -> a) -> Seq a -> a
copy :: Int -> a -> Seq a
inBounds :: Int -> Seq a -> Bool
lookup :: Int -> Seq a -> a
lookupM :: Monad m => Int -> Seq a -> m a
lookupWithDefault :: a -> Int -> Seq a -> a
update :: Int -> a -> Seq a -> Seq a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldrWithIndex' :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
foldlWithIndex' :: (b -> Int -> a -> b) -> b -> Seq a -> b
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
subseq :: Int -> Int -> Seq a -> Seq a
filter :: (a -> Bool) -> Seq a -> Seq a
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
takeWhile :: (a -> Bool) -> Seq a -> Seq a
dropWhile :: (a -> Bool) -> Seq a -> Seq a
splitWhile :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
zip :: Seq a -> Seq b -> Seq (a, b)
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzip3 :: Seq (a, b, c) -> (Seq a, Seq b, Seq c)
unzipWith :: (a -> b) -> (a -> c) -> Seq a -> (Seq b, Seq c)
unzipWith3 :: (a -> b) -> (a -> c) -> (a -> d) -> Seq a -> (Seq b, Seq c, Seq d)
strict :: Seq a -> Seq a
strictWith :: (a -> b) -> Seq a -> Seq a
structuralInvariant :: Seq a -> Bool
moduleName :: String
instance Eq a => Eq (Seq a)
instance Monoid (Seq a)
instance CoArbitrary a => CoArbitrary (Seq a)
instance Arbitrary a => Arbitrary (Seq a)
instance Read a => Read (Seq a)
instance Show a => Show (Seq a)
instance Ord a => Ord (Seq a)
instance MonadPlus Seq
instance Monad Seq
instance Functor Seq
instance Sequence Seq


module Data.Edison.Seq.FingerSeq
data Seq a
empty :: Seq a
singleton :: a -> Seq a
lcons :: a -> Seq a -> Seq a
rcons :: a -> Seq a -> Seq a
append :: Seq a -> Seq a -> Seq a
lview :: Monad m => Seq a -> m (a, Seq a)
lhead :: Seq a -> a
ltail :: Seq a -> Seq a
rview :: Monad m => Seq a -> m (a, Seq a)
rhead :: Seq a -> a
rtail :: Seq a -> Seq a
lheadM :: Monad m => Seq a -> m a
ltailM :: Monad m => Seq a -> m (Seq a)
rheadM :: Monad m => Seq a -> m a
rtailM :: Monad m => Seq a -> m (Seq a)
null :: Seq a -> Bool
size :: Seq a -> Int
concat :: Seq (Seq a) -> Seq a
reverse :: Seq a -> Seq a
reverseOnto :: Seq a -> Seq a -> Seq a
fromList :: [a] -> Seq a
toList :: Seq a -> [a]
map :: (a -> b) -> Seq a -> Seq b
concatMap :: (a -> Seq b) -> Seq a -> Seq b
fold :: (a -> b -> b) -> b -> Seq a -> b
fold' :: (a -> b -> b) -> b -> Seq a -> b
fold1 :: (a -> a -> a) -> Seq a -> a
fold1' :: (a -> a -> a) -> Seq a -> a
foldr :: (a -> b -> b) -> b -> Seq a -> b
foldr' :: (a -> b -> b) -> b -> Seq a -> b
foldl :: (b -> a -> b) -> b -> Seq a -> b
foldl' :: (b -> a -> b) -> b -> Seq a -> b
foldr1 :: (a -> a -> a) -> Seq a -> a
foldr1' :: (a -> a -> a) -> Seq a -> a
foldl1 :: (a -> a -> a) -> Seq a -> a
foldl1' :: (a -> a -> a) -> Seq a -> a
reducer :: (a -> a -> a) -> a -> Seq a -> a
reducer' :: (a -> a -> a) -> a -> Seq a -> a
reducel :: (a -> a -> a) -> a -> Seq a -> a
reducel' :: (a -> a -> a) -> a -> Seq a -> a
reduce1 :: (a -> a -> a) -> Seq a -> a
reduce1' :: (a -> a -> a) -> Seq a -> a
copy :: Int -> a -> Seq a
inBounds :: Int -> Seq a -> Bool
lookup :: Int -> Seq a -> a
lookupM :: Monad m => Int -> Seq a -> m a
lookupWithDefault :: a -> Int -> Seq a -> a
update :: Int -> a -> Seq a -> Seq a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
subseq :: Int -> Int -> Seq a -> Seq a
filter :: (a -> Bool) -> Seq a -> Seq a
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
takeWhile :: (a -> Bool) -> Seq a -> Seq a
dropWhile :: (a -> Bool) -> Seq a -> Seq a
splitWhile :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
zip :: Seq a -> Seq b -> Seq (a, b)
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzip3 :: Seq (a, b, c) -> (Seq a, Seq b, Seq c)
unzipWith :: (a -> b) -> (a -> c) -> Seq a -> (Seq b, Seq c)
unzipWith3 :: (a -> b) -> (a -> c) -> (a -> d) -> Seq a -> (Seq b, Seq c, Seq d)
strict :: Seq a -> Seq a
strictWith :: (a -> b) -> Seq a -> Seq a
structuralInvariant :: Seq a -> Bool
moduleName :: String
instance Eq SizeM
instance Ord SizeM
instance Num SizeM
instance Enum SizeM
instance Show SizeM
instance Monoid (Seq a)
instance CoArbitrary a => CoArbitrary (Seq a)
instance Arbitrary a => Arbitrary (Seq a)
instance CoArbitrary a => CoArbitrary (Elem a)
instance Arbitrary a => Arbitrary (Elem a)
instance Read a => Read (Seq a)
instance Show a => Show (Seq a)
instance Ord a => Ord (Seq a)
instance Eq a => Eq (Seq a)
instance MonadPlus Seq
instance Monad Seq
instance Functor Seq
instance Sequence Seq
instance Measured SizeM (Elem a)
instance Monoid SizeM


-- | Join lists. All running times are as listed in <a>Data.Edison.Seq</a>
--   except for the following:
--   
--   <ul>
--   <li>rcons, append <tt>O( 1 )</tt></li>
--   <li>ltail*, lview <tt>O( 1 )</tt> when used single-threaded, <tt>O( n
--   )</tt> otherwise</li>
--   <li>lhead* <tt>O( n )</tt></li>
--   <li>inBounds, lookup <tt>O( n )</tt></li>
--   <li>copy <tt>O( log i )</tt></li>
--   <li>concat <tt>O( n1 )</tt></li>
--   <li>concatMap, (&gt;&gt;=) <tt>O( n * t )</tt>, where <tt>n</tt> is
--   the length of the input sequence and <tt>t</tt> is the running time of
--   <tt>f</tt></li>
--   </ul>
module Data.Edison.Seq.JoinList
data Seq a
empty :: Seq a
singleton :: a -> Seq a
lcons :: a -> Seq a -> Seq a
rcons :: a -> Seq a -> Seq a
append :: Seq a -> Seq a -> Seq a
lview :: Monad m => Seq a -> m (a, Seq a)
lhead :: Seq a -> a
ltail :: Seq a -> Seq a
rview :: Monad m => Seq a -> m (a, Seq a)
rhead :: Seq a -> a
rtail :: Seq a -> Seq a
lheadM :: Monad m => Seq a -> m a
ltailM :: Monad m => Seq a -> m (Seq a)
rheadM :: Monad m => Seq a -> m a
rtailM :: Monad m => Seq a -> m (Seq a)
null :: Seq a -> Bool
size :: Seq a -> Int
concat :: Seq (Seq a) -> Seq a
reverse :: Seq a -> Seq a
reverseOnto :: Seq a -> Seq a -> Seq a
fromList :: [a] -> Seq a
toList :: Seq a -> [a]
map :: (a -> b) -> Seq a -> Seq b
concatMap :: (a -> Seq b) -> Seq a -> Seq b
fold :: (a -> b -> b) -> b -> Seq a -> b
fold' :: (a -> b -> b) -> b -> Seq a -> b
fold1 :: (a -> a -> a) -> Seq a -> a
fold1' :: (a -> a -> a) -> Seq a -> a
foldr :: (a -> b -> b) -> b -> Seq a -> b
foldr' :: (a -> b -> b) -> b -> Seq a -> b
foldl :: (b -> a -> b) -> b -> Seq a -> b
foldl' :: (b -> a -> b) -> b -> Seq a -> b
foldr1 :: (a -> a -> a) -> Seq a -> a
foldr1' :: (a -> a -> a) -> Seq a -> a
foldl1 :: (a -> a -> a) -> Seq a -> a
foldl1' :: (a -> a -> a) -> Seq a -> a
reducer :: (a -> a -> a) -> a -> Seq a -> a
reducer' :: (a -> a -> a) -> a -> Seq a -> a
reducel :: (a -> a -> a) -> a -> Seq a -> a
reducel' :: (a -> a -> a) -> a -> Seq a -> a
reduce1 :: (a -> a -> a) -> Seq a -> a
reduce1' :: (a -> a -> a) -> Seq a -> a
copy :: Int -> a -> Seq a
inBounds :: Int -> Seq a -> Bool
lookup :: Int -> Seq a -> a
lookupM :: Monad m => Int -> Seq a -> m a
lookupWithDefault :: a -> Int -> Seq a -> a
update :: Int -> a -> Seq a -> Seq a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
subseq :: Int -> Int -> Seq a -> Seq a
filter :: (a -> Bool) -> Seq a -> Seq a
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
takeWhile :: (a -> Bool) -> Seq a -> Seq a
dropWhile :: (a -> Bool) -> Seq a -> Seq a
splitWhile :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
zip :: Seq a -> Seq b -> Seq (a, b)
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzip3 :: Seq (a, b, c) -> (Seq a, Seq b, Seq c)
unzipWith :: (a -> b) -> (a -> c) -> Seq a -> (Seq b, Seq c)
unzipWith3 :: (a -> b) -> (a -> c) -> (a -> d) -> Seq a -> (Seq b, Seq c, Seq d)
strict :: Seq a -> Seq a
strictWith :: (a -> b) -> Seq a -> Seq a
structuralInvariant :: Seq a -> Bool
moduleName :: String
instance Monoid (Seq a)
instance CoArbitrary a => CoArbitrary (Seq a)
instance Arbitrary a => Arbitrary (Seq a)
instance Read a => Read (Seq a)
instance Show a => Show (Seq a)
instance Ord a => Ord (Seq a)
instance Eq a => Eq (Seq a)
instance MonadPlus Seq
instance Monad Seq
instance Functor Seq
instance Sequence Seq


-- | Meyers Stacks. All operations are as listed in <a>Data.Edison.Seq</a>
--   except the following:
--   
--   <ul>
--   <li>lookup, inBounds, drop <tt>O( min(i, log n) )</tt></li>
--   <li>rhead*, size <tt>O( log n )</tt></li>
--   <li>subseq <tt>O( min (i, log n) + len )</tt></li>
--   </ul>
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Eugene Myers. "An applicative random-access stack". /Information
--   Processing Letters/, 17(5):241-248, December 1983.</li>
--   </ul>
module Data.Edison.Seq.MyersStack
data Seq a
empty :: Seq a
singleton :: a -> Seq a
lcons :: a -> Seq a -> Seq a
rcons :: a -> Seq a -> Seq a
append :: Seq a -> Seq a -> Seq a
lview :: Monad m => Seq a -> m (a, Seq a)
lhead :: Seq a -> a
ltail :: Seq a -> Seq a
rview :: Monad m => Seq a -> m (a, Seq a)
rhead :: Seq a -> a
rtail :: Seq a -> Seq a
lheadM :: Monad m => Seq a -> m a
ltailM :: Monad m => Seq a -> m (Seq a)
rheadM :: Monad m => Seq a -> m a
rtailM :: Monad m => Seq a -> m (Seq a)
null :: Seq a -> Bool
size :: Seq a -> Int
concat :: Seq (Seq a) -> Seq a
reverse :: Seq a -> Seq a
reverseOnto :: Seq a -> Seq a -> Seq a
fromList :: [a] -> Seq a
toList :: Seq a -> [a]
map :: (a -> b) -> Seq a -> Seq b
concatMap :: (a -> Seq b) -> Seq a -> Seq b
fold :: (a -> b -> b) -> b -> Seq a -> b
fold' :: (a -> b -> b) -> b -> Seq a -> b
fold1 :: (a -> a -> a) -> Seq a -> a
fold1' :: (a -> a -> a) -> Seq a -> a
foldr :: (a -> b -> b) -> b -> Seq a -> b
foldr' :: (a -> b -> b) -> b -> Seq a -> b
foldl :: (b -> a -> b) -> b -> Seq a -> b
foldl' :: (b -> a -> b) -> b -> Seq a -> b
foldr1 :: (a -> a -> a) -> Seq a -> a
foldr1' :: (a -> a -> a) -> Seq a -> a
foldl1 :: (a -> a -> a) -> Seq a -> a
foldl1' :: (a -> a -> a) -> Seq a -> a
reducer :: (a -> a -> a) -> a -> Seq a -> a
reducer' :: (a -> a -> a) -> a -> Seq a -> a
reducel :: (a -> a -> a) -> a -> Seq a -> a
reducel' :: (a -> a -> a) -> a -> Seq a -> a
reduce1 :: (a -> a -> a) -> Seq a -> a
reduce1' :: (a -> a -> a) -> Seq a -> a
copy :: Int -> a -> Seq a
inBounds :: Int -> Seq a -> Bool
lookup :: Int -> Seq a -> a
lookupM :: Monad m => Int -> Seq a -> m a
lookupWithDefault :: a -> Int -> Seq a -> a
update :: Int -> a -> Seq a -> Seq a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldrWithIndex' :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
foldlWithIndex' :: (b -> Int -> a -> b) -> b -> Seq a -> b
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
subseq :: Int -> Int -> Seq a -> Seq a
filter :: (a -> Bool) -> Seq a -> Seq a
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
takeWhile :: (a -> Bool) -> Seq a -> Seq a
dropWhile :: (a -> Bool) -> Seq a -> Seq a
splitWhile :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
zip :: Seq a -> Seq b -> Seq (a, b)
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzip3 :: Seq (a, b, c) -> (Seq a, Seq b, Seq c)
unzipWith :: (a -> b) -> (a -> c) -> Seq a -> (Seq b, Seq c)
unzipWith3 :: (a -> b) -> (a -> c) -> (a -> d) -> Seq a -> (Seq b, Seq c, Seq d)
strict :: Seq a -> Seq a
strictWith :: (a -> b) -> Seq a -> Seq a
structuralInvariant :: Seq a -> Bool
moduleName :: String
instance Monoid (Seq a)
instance CoArbitrary a => CoArbitrary (Seq a)
instance Arbitrary a => Arbitrary (Seq a)
instance Read a => Read (Seq a)
instance Show a => Show (Seq a)
instance Ord a => Ord (Seq a)
instance Eq a => Eq (Seq a)
instance MonadPlus Seq
instance Monad Seq
instance Functor Seq
instance Sequence Seq


-- | Random-Access Lists. All operations are as listed in
--   <a>Data.Edison.Seq</a> except the following:
--   
--   <ul>
--   <li>rhead*, size <tt>O( log n )</tt></li>
--   <li>copy, inBounds <tt>O( log i )</tt></li>
--   <li>lookup*, update, adjust, drop <tt>O( min( i, log n ) )</tt></li>
--   <li>subseq <tt>O( min( i, log n ) + len )</tt></li>
--   </ul>
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Chris Okasaki. <i>Purely Functional Data Structures</i>. 1998.
--   Section 9.3.1.</li>
--   <li>Chris Okasaki. "Purely Functional Random Access Lists". FPCA'95,
--   pages 86-95.</li>
--   </ul>
module Data.Edison.Seq.RandList
data Seq a
empty :: Seq a
singleton :: a -> Seq a
lcons :: a -> Seq a -> Seq a
rcons :: a -> Seq a -> Seq a
append :: Seq a -> Seq a -> Seq a
lview :: Monad m => Seq a -> m (a, Seq a)
lhead :: Seq a -> a
ltail :: Seq a -> Seq a
rview :: Monad m => Seq a -> m (a, Seq a)
rhead :: Seq a -> a
rtail :: Seq a -> Seq a
lheadM :: Monad m => Seq a -> m a
ltailM :: Monad m => Seq a -> m (Seq a)
rheadM :: Monad m => Seq a -> m a
rtailM :: Monad m => Seq a -> m (Seq a)
null :: Seq a -> Bool
size :: Seq a -> Int
concat :: Seq (Seq a) -> Seq a
reverse :: Seq a -> Seq a
reverseOnto :: Seq a -> Seq a -> Seq a
fromList :: [a] -> Seq a
toList :: Seq a -> [a]
map :: (a -> b) -> Seq a -> Seq b
concatMap :: (a -> Seq b) -> Seq a -> Seq b
fold :: (a -> b -> b) -> b -> Seq a -> b
fold' :: (a -> b -> b) -> b -> Seq a -> b
fold1 :: (a -> a -> a) -> Seq a -> a
fold1' :: (a -> a -> a) -> Seq a -> a
foldr :: (a -> b -> b) -> b -> Seq a -> b
foldr' :: (a -> b -> b) -> b -> Seq a -> b
foldl :: (b -> a -> b) -> b -> Seq a -> b
foldl' :: (b -> a -> b) -> b -> Seq a -> b
foldr1 :: (a -> a -> a) -> Seq a -> a
foldr1' :: (a -> a -> a) -> Seq a -> a
foldl1 :: (a -> a -> a) -> Seq a -> a
foldl1' :: (a -> a -> a) -> Seq a -> a
reducer :: (a -> a -> a) -> a -> Seq a -> a
reducer' :: (a -> a -> a) -> a -> Seq a -> a
reducel :: (a -> a -> a) -> a -> Seq a -> a
reducel' :: (a -> a -> a) -> a -> Seq a -> a
reduce1 :: (a -> a -> a) -> Seq a -> a
reduce1' :: (a -> a -> a) -> Seq a -> a
copy :: Int -> a -> Seq a
inBounds :: Int -> Seq a -> Bool
lookup :: Int -> Seq a -> a
lookupM :: Monad m => Int -> Seq a -> m a
lookupWithDefault :: a -> Int -> Seq a -> a
update :: Int -> a -> Seq a -> Seq a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldrWithIndex' :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
foldlWithIndex' :: (b -> Int -> a -> b) -> b -> Seq a -> b
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
subseq :: Int -> Int -> Seq a -> Seq a
filter :: (a -> Bool) -> Seq a -> Seq a
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
takeWhile :: (a -> Bool) -> Seq a -> Seq a
dropWhile :: (a -> Bool) -> Seq a -> Seq a
splitWhile :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
zip :: Seq a -> Seq b -> Seq (a, b)
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzip3 :: Seq (a, b, c) -> (Seq a, Seq b, Seq c)
unzipWith :: (a -> b) -> (a -> c) -> Seq a -> (Seq b, Seq c)
unzipWith3 :: (a -> b) -> (a -> c) -> (a -> d) -> Seq a -> (Seq b, Seq c, Seq d)
strict :: Seq a -> Seq a
strictWith :: (a -> b) -> Seq a -> Seq a
structuralInvariant :: Seq t -> Bool
moduleName :: String
instance Eq a => Eq (Tree a)
instance Eq a => Eq (Seq a)
instance Monoid (Seq a)
instance CoArbitrary a => CoArbitrary (Seq a)
instance Arbitrary a => Arbitrary (Seq a)
instance Read a => Read (Seq a)
instance Show a => Show (Seq a)
instance Ord a => Ord (Seq a)
instance MonadPlus Seq
instance Monad Seq
instance Functor Seq
instance Sequence Seq


-- | This module defines a sequence adaptor <tt>Rev s</tt>. If <tt>s</tt>
--   is a sequence type constructor, then <tt>Rev s</tt> is a sequence type
--   constructor that is identical to <tt>s</tt>, except that it is kept in
--   the opposite order. Also keeps explicit track of the size of the
--   sequence, similar to the <tt>Sized</tt> adaptor in
--   <a>Data.Edison.Seq.SizedSeq</a>.
--   
--   This module is most useful when s is a sequence type that offers fast
--   access to the front but slow access to the rear, and your application
--   needs the opposite (i.e., fast access to the rear but slow access to
--   the front).
--   
--   All time complexities are determined by the underlying sequence,
--   except that the complexities for accessing the left and right sides of
--   the sequence are exchanged, and size becomes <tt>O( 1 )</tt>.
module Data.Edison.Seq.RevSeq
data Rev s a
empty :: Sequence s => Rev s a
singleton :: Sequence s => a -> Rev s a
lcons :: Sequence s => a -> Rev s a -> Rev s a
rcons :: Sequence s => a -> Rev s a -> Rev s a
append :: Sequence s => Rev s a -> Rev s a -> Rev s a
lview :: (Sequence s, Monad m) => Rev s a -> m (a, Rev s a)
lhead :: Sequence s => Rev s a -> a
ltail :: Sequence s => Rev s a -> Rev s a
rview :: (Sequence s, Monad m) => Rev s a -> m (a, Rev s a)
rhead :: Sequence s => Rev s a -> a
rtail :: Sequence s => Rev s a -> Rev s a
lheadM :: (Sequence s, Monad m) => Rev s a -> m a
ltailM :: (Sequence s, Monad m) => Rev s a -> m (Rev s a)
rheadM :: (Sequence s, Monad m) => Rev s a -> m a
rtailM :: (Sequence s, Monad m) => Rev s a -> m (Rev s a)
null :: Sequence s => Rev s a -> Bool
size :: Sequence s => Rev s a -> Int
concat :: Sequence s => Rev s (Rev s a) -> Rev s a
reverse :: Sequence s => Rev s a -> Rev s a
reverseOnto :: Sequence s => Rev s a -> Rev s a -> Rev s a
fromList :: Sequence s => [a] -> Rev s a
toList :: Sequence s => Rev s a -> [a]
map :: Sequence s => (a -> b) -> Rev s a -> Rev s b
concatMap :: Sequence s => (a -> Rev s b) -> Rev s a -> Rev s b
fold :: Sequence s => (a -> b -> b) -> b -> Rev s a -> b
fold' :: Sequence s => (a -> b -> b) -> b -> Rev s a -> b
fold1 :: Sequence s => (a -> a -> a) -> Rev s a -> a
fold1' :: Sequence s => (a -> a -> a) -> Rev s a -> a
foldr :: Sequence s => (a -> b -> b) -> b -> Rev s a -> b
foldr' :: Sequence s => (a -> b -> b) -> b -> Rev s a -> b
foldl :: Sequence s => (b -> a -> b) -> b -> Rev s a -> b
foldl' :: Sequence s => (b -> a -> b) -> b -> Rev s a -> b
foldr1 :: Sequence s => (a -> a -> a) -> Rev s a -> a
foldr1' :: Sequence s => (a -> a -> a) -> Rev s a -> a
foldl1 :: Sequence s => (a -> a -> a) -> Rev s a -> a
foldl1' :: Sequence s => (a -> a -> a) -> Rev s a -> a
reducer :: Sequence s => (a -> a -> a) -> a -> Rev s a -> a
reducer' :: Sequence s => (a -> a -> a) -> a -> Rev s a -> a
reducel :: Sequence s => (a -> a -> a) -> a -> Rev s a -> a
reducel' :: Sequence s => (a -> a -> a) -> a -> Rev s a -> a
reduce1 :: Sequence s => (a -> a -> a) -> Rev s a -> a
reduce1' :: Sequence s => (a -> a -> a) -> Rev s a -> a
copy :: Sequence s => Int -> a -> Rev s a
inBounds :: Sequence s => Int -> Rev s a -> Bool
lookup :: Sequence s => Int -> Rev s a -> a
lookupM :: (Sequence s, Monad m) => Int -> Rev s a -> m a
lookupWithDefault :: Sequence s => a -> Int -> Rev s a -> a
update :: Sequence s => Int -> a -> Rev s a -> Rev s a
adjust :: Sequence s => (a -> a) -> Int -> Rev s a -> Rev s a
mapWithIndex :: Sequence s => (Int -> a -> b) -> Rev s a -> Rev s b
foldrWithIndex :: Sequence s => (Int -> a -> b -> b) -> b -> Rev s a -> b
foldrWithIndex' :: Sequence s => (Int -> a -> b -> b) -> b -> Rev s a -> b
foldlWithIndex :: Sequence s => (b -> Int -> a -> b) -> b -> Rev s a -> b
foldlWithIndex' :: Sequence s => (b -> Int -> a -> b) -> b -> Rev s a -> b
take :: Sequence s => Int -> Rev s a -> Rev s a
drop :: Sequence s => Int -> Rev s a -> Rev s a
splitAt :: Sequence s => Int -> Rev s a -> (Rev s a, Rev s a)
subseq :: Sequence s => Int -> Int -> Rev s a -> Rev s a
filter :: Sequence s => (a -> Bool) -> Rev s a -> Rev s a
partition :: Sequence s => (a -> Bool) -> Rev s a -> (Rev s a, Rev s a)
takeWhile :: Sequence s => (a -> Bool) -> Rev s a -> Rev s a
dropWhile :: Sequence s => (a -> Bool) -> Rev s a -> Rev s a
splitWhile :: Sequence s => (a -> Bool) -> Rev s a -> (Rev s a, Rev s a)
zip :: Sequence s => Rev s a -> Rev s b -> Rev s (a, b)
zip3 :: Sequence s => Rev s a -> Rev s b -> Rev s c -> Rev s (a, b, c)
zipWith :: Sequence s => (a -> b -> c) -> Rev s a -> Rev s b -> Rev s c
zipWith3 :: Sequence s => (a -> b -> c -> d) -> Rev s a -> Rev s b -> Rev s c -> Rev s d
unzip :: Sequence s => Rev s (a, b) -> (Rev s a, Rev s b)
unzip3 :: Sequence s => Rev s (a, b, c) -> (Rev s a, Rev s b, Rev s c)
unzipWith :: Sequence s => (a -> b) -> (a -> c) -> Rev s a -> (Rev s b, Rev s c)
unzipWith3 :: Sequence s => (a -> b) -> (a -> c) -> (a -> d) -> Rev s a -> (Rev s b, Rev s c, Rev s d)
strict :: Sequence s => Rev s a -> Rev s a
strictWith :: Sequence s => (a -> b) -> Rev s a -> Rev s a
structuralInvariant :: Sequence s => Rev s a -> Bool
moduleName :: String
instanceName :: Sequence s => Rev s a -> String
fromSeq :: Sequence s => s a -> Rev s a
toSeq :: Sequence s => Rev s a -> s a
instance Sequence s => Monoid (Rev s a)
instance (Sequence s, CoArbitrary (s a)) => CoArbitrary (Rev s a)
instance (Sequence s, Arbitrary (s a)) => Arbitrary (Rev s a)
instance (Sequence s, Read (s a)) => Read (Rev s a)
instance (Sequence s, Show (s a)) => Show (Rev s a)
instance (Sequence s, Ord a, Eq (s a)) => Ord (Rev s a)
instance Eq (s a) => Eq (Rev s a)
instance Sequence s => MonadPlus (Rev s)
instance Sequence s => Monad (Rev s)
instance Sequence s => Functor (Rev s)
instance Sequence s => Sequence (Rev s)


-- | Simple Queues. All operations have running times as listed in
--   <a>Data.Edison.Seq</a> except for the following:
--   
--   <ul>
--   <li>rcons, fromList <tt>O( 1 )</tt></li>
--   <li>lview, ltail* <tt>O( 1 )</tt> if single threaded, <tt>O( n )</tt>
--   otherwise</li>
--   <li>inBounds, lookup, update, drop, splitAt <tt>O( n )</tt></li>
--   </ul>
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Chris Okasaki. <i>Purely Functional Data Structures</i>. 1998.
--   Section 5.2.</li>
--   <li>F. Warren Burton. "An efficient functional implementation of FIFO
--   queues". <i>Information Processing Letters</i>, 14(5):205-206, July
--   1982.</li>
--   </ul>
module Data.Edison.Seq.SimpleQueue
data Seq a
empty :: Seq a
singleton :: a -> Seq a
lcons :: a -> Seq a -> Seq a
rcons :: a -> Seq a -> Seq a
append :: Seq a -> Seq a -> Seq a
lview :: Monad m => Seq a -> m (a, Seq a)
lhead :: Seq a -> a
ltail :: Seq a -> Seq a
rview :: Monad m => Seq a -> m (a, Seq a)
rhead :: Seq a -> a
rtail :: Seq a -> Seq a
lheadM :: Monad m => Seq a -> m a
ltailM :: Monad m => Seq a -> m (Seq a)
rheadM :: Monad m => Seq a -> m a
rtailM :: Monad m => Seq a -> m (Seq a)
null :: Seq a -> Bool
size :: Seq a -> Int
concat :: Seq (Seq a) -> Seq a
reverse :: Seq a -> Seq a
reverseOnto :: Seq a -> Seq a -> Seq a
fromList :: [a] -> Seq a
toList :: Seq a -> [a]
map :: (a -> b) -> Seq a -> Seq b
concatMap :: (a -> Seq b) -> Seq a -> Seq b
fold :: (a -> b -> b) -> b -> Seq a -> b
fold' :: (a -> b -> b) -> b -> Seq a -> b
fold1 :: (a -> a -> a) -> Seq a -> a
fold1' :: (a -> a -> a) -> Seq a -> a
foldr :: (a -> b -> b) -> b -> Seq a -> b
foldr' :: (a -> b -> b) -> b -> Seq a -> b
foldl :: (b -> a -> b) -> b -> Seq a -> b
foldl' :: (b -> a -> b) -> b -> Seq a -> b
foldr1 :: (a -> a -> a) -> Seq a -> a
foldr1' :: (a -> a -> a) -> Seq a -> a
foldl1 :: (a -> a -> a) -> Seq a -> a
foldl1' :: (a -> a -> a) -> Seq a -> a
reducer :: (a -> a -> a) -> a -> Seq a -> a
reducer' :: (a -> a -> a) -> a -> Seq a -> a
reducel :: (a -> a -> a) -> a -> Seq a -> a
reducel' :: (a -> a -> a) -> a -> Seq a -> a
reduce1 :: (a -> a -> a) -> Seq a -> a
reduce1' :: (a -> a -> a) -> Seq a -> a
copy :: Int -> a -> Seq a
inBounds :: Int -> Seq a -> Bool
lookup :: Int -> Seq a -> a
lookupM :: Monad m => Int -> Seq a -> m a
lookupWithDefault :: a -> Int -> Seq a -> a
update :: Int -> a -> Seq a -> Seq a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
foldrWithIndex' :: (Int -> a -> b -> b) -> b -> Seq a -> b
foldlWithIndex' :: (b -> Int -> a -> b) -> b -> Seq a -> b
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
subseq :: Int -> Int -> Seq a -> Seq a
filter :: (a -> Bool) -> Seq a -> Seq a
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
takeWhile :: (a -> Bool) -> Seq a -> Seq a
dropWhile :: (a -> Bool) -> Seq a -> Seq a
splitWhile :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
zip :: Seq a -> Seq b -> Seq (a, b)
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzip3 :: Seq (a, b, c) -> (Seq a, Seq b, Seq c)
unzipWith :: (a -> b) -> (a -> c) -> Seq a -> (Seq b, Seq c)
unzipWith3 :: (a -> b) -> (a -> c) -> (a -> d) -> Seq a -> (Seq b, Seq c, Seq d)
strict :: Seq a -> Seq a
strictWith :: (a -> b) -> Seq a -> Seq a
structuralInvariant :: Seq a -> Bool
moduleName :: String
instance Monoid (Seq a)
instance CoArbitrary a => CoArbitrary (Seq a)
instance Arbitrary a => Arbitrary (Seq a)
instance Read a => Read (Seq a)
instance Show a => Show (Seq a)
instance Ord a => Ord (Seq a)
instance Eq a => Eq (Seq a)
instance MonadPlus Seq
instance Monad Seq
instance Functor Seq
instance Sequence Seq


-- | This module defines a sequence adaptor <tt>Sized s</tt>. If <tt>s</tt>
--   is a sequence type constructor, then <tt>Sized s</tt> is a sequence
--   type constructor that is identical to <tt>s</tt>, except that it also
--   keeps track of the current size of each sequence.
--   
--   All time complexities are determined by the underlying sequence,
--   except that size becomes <tt>O( 1 )</tt>.
module Data.Edison.Seq.SizedSeq
data Sized s a
empty :: Sequence s => Sized s a
singleton :: Sequence s => a -> Sized s a
lcons :: Sequence s => a -> Sized s a -> Sized s a
rcons :: Sequence s => a -> Sized s a -> Sized s a
append :: Sequence s => Sized s a -> Sized s a -> Sized s a
lview :: (Sequence s, Monad m) => Sized s a -> m (a, Sized s a)
lhead :: Sequence s => Sized s a -> a
ltail :: Sequence s => Sized s a -> Sized s a
rview :: (Sequence s, Monad m) => Sized s a -> m (a, Sized s a)
rhead :: Sequence s => Sized s a -> a
rtail :: Sequence s => Sized s a -> Sized s a
lheadM :: (Sequence s, Monad m) => Sized s a -> m a
ltailM :: (Sequence s, Monad m) => Sized s a -> m (Sized s a)
rheadM :: (Sequence s, Monad m) => Sized s a -> m a
rtailM :: (Sequence s, Monad m) => Sized s a -> m (Sized s a)
null :: Sequence s => Sized s a -> Bool
size :: Sequence s => Sized s a -> Int
concat :: Sequence s => Sized s (Sized s a) -> Sized s a
reverse :: Sequence s => Sized s a -> Sized s a
reverseOnto :: Sequence s => Sized s a -> Sized s a -> Sized s a
fromList :: Sequence s => [a] -> Sized s a
toList :: Sequence s => Sized s a -> [a]
map :: Sequence s => (a -> b) -> Sized s a -> Sized s b
concatMap :: Sequence s => (a -> Sized s b) -> Sized s a -> Sized s b
fold :: Sequence s => (a -> b -> b) -> b -> Sized s a -> b
fold' :: Sequence s => (a -> b -> b) -> b -> Sized s a -> b
fold1 :: Sequence s => (a -> a -> a) -> Sized s a -> a
fold1' :: Sequence s => (a -> a -> a) -> Sized s a -> a
foldr :: Sequence s => (a -> b -> b) -> b -> Sized s a -> b
foldr' :: Sequence s => (a -> b -> b) -> b -> Sized s a -> b
foldl :: Sequence s => (b -> a -> b) -> b -> Sized s a -> b
foldl' :: Sequence s => (b -> a -> b) -> b -> Sized s a -> b
foldr1 :: Sequence s => (a -> a -> a) -> Sized s a -> a
foldr1' :: Sequence s => (a -> a -> a) -> Sized s a -> a
foldl1 :: Sequence s => (a -> a -> a) -> Sized s a -> a
foldl1' :: Sequence s => (a -> a -> a) -> Sized s a -> a
reducer :: Sequence s => (a -> a -> a) -> a -> Sized s a -> a
reducer' :: Sequence s => (a -> a -> a) -> a -> Sized s a -> a
reducel :: Sequence s => (a -> a -> a) -> a -> Sized s a -> a
reducel' :: Sequence s => (a -> a -> a) -> a -> Sized s a -> a
reduce1 :: Sequence s => (a -> a -> a) -> Sized s a -> a
reduce1' :: Sequence s => (a -> a -> a) -> Sized s a -> a
copy :: Sequence s => Int -> a -> Sized s a
inBounds :: Sequence s => Int -> Sized s a -> Bool
lookup :: Sequence s => Int -> Sized s a -> a
lookupM :: (Sequence s, Monad m) => Int -> Sized s a -> m a
lookupWithDefault :: Sequence s => a -> Int -> Sized s a -> a
update :: Sequence s => Int -> a -> Sized s a -> Sized s a
adjust :: Sequence s => (a -> a) -> Int -> Sized s a -> Sized s a
mapWithIndex :: Sequence s => (Int -> a -> b) -> Sized s a -> Sized s b
foldrWithIndex :: Sequence s => (Int -> a -> b -> b) -> b -> Sized s a -> b
foldlWithIndex :: Sequence s => (b -> Int -> a -> b) -> b -> Sized s a -> b
foldrWithIndex' :: Sequence s => (Int -> a -> b -> b) -> b -> Sized s a -> b
foldlWithIndex' :: Sequence s => (b -> Int -> a -> b) -> b -> Sized s a -> b
take :: Sequence s => Int -> Sized s a -> Sized s a
drop :: Sequence s => Int -> Sized s a -> Sized s a
splitAt :: Sequence s => Int -> Sized s a -> (Sized s a, Sized s a)
subseq :: Sequence s => Int -> Int -> Sized s a -> Sized s a
filter :: Sequence s => (a -> Bool) -> Sized s a -> Sized s a
partition :: Sequence s => (a -> Bool) -> Sized s a -> (Sized s a, Sized s a)
takeWhile :: Sequence s => (a -> Bool) -> Sized s a -> Sized s a
dropWhile :: Sequence s => (a -> Bool) -> Sized s a -> Sized s a
splitWhile :: Sequence s => (a -> Bool) -> Sized s a -> (Sized s a, Sized s a)
zip :: Sequence s => Sized s a -> Sized s b -> Sized s (a, b)
zip3 :: Sequence s => Sized s a -> Sized s b -> Sized s c -> Sized s (a, b, c)
zipWith :: Sequence s => (a -> b -> c) -> Sized s a -> Sized s b -> Sized s c
zipWith3 :: Sequence s => (a -> b -> c -> d) -> Sized s a -> Sized s b -> Sized s c -> Sized s d
unzip :: Sequence s => Sized s (a, b) -> (Sized s a, Sized s b)
unzip3 :: Sequence s => Sized s (a, b, c) -> (Sized s a, Sized s b, Sized s c)
unzipWith :: Sequence s => (a -> b) -> (a -> c) -> Sized s a -> (Sized s b, Sized s c)
unzipWith3 :: Sequence s => (a -> b) -> (a -> c) -> (a -> d) -> Sized s a -> (Sized s b, Sized s c, Sized s d)
strict :: Sequence s => Sized s a -> Sized s a
strictWith :: Sequence s => (a -> b) -> Sized s a -> Sized s a
structuralInvariant :: Sequence s => Sized s a -> Bool
moduleName :: String
instanceName :: Sequence s => Sized s a -> String
fromSeq :: Sequence s => s a -> Sized s a
toSeq :: Sequence s => Sized s a -> s a
instance Sequence s => Monoid (Sized s a)
instance (Sequence s, CoArbitrary (s a)) => CoArbitrary (Sized s a)
instance (Sequence s, Arbitrary (s a)) => Arbitrary (Sized s a)
instance (Sequence s, Read (s a)) => Read (Sized s a)
instance (Sequence s, Show (s a)) => Show (Sized s a)
instance (Sequence s, Ord a, Eq (s a)) => Ord (Sized s a)
instance Eq (s a) => Eq (Sized s a)
instance Sequence s => MonadPlus (Sized s)
instance Sequence s => Monad (Sized s)
instance Sequence s => Functor (Sized s)
instance Sequence s => Sequence (Sized s)


-- | This module provides default implementations of many of the
--   associative collection operations. These function are used to fill in
--   collection implementations and are not intended to be used directly by
--   end users.
module Data.Edison.Assoc.Defaults
singletonUsingInsert :: Assoc m k => k -> a -> m a
fromSeqUsingInsertSeq :: (AssocX m k, Sequence seq) => seq (k, a) -> m a
insertSeqUsingFoldr :: (AssocX m k, Sequence seq) => seq (k, a) -> m a -> m a
unionSeqUsingReduce :: (AssocX m k, Sequence seq) => seq (m a) -> m a
deleteSeqUsingFoldr :: (AssocX m k, Sequence seq) => seq k -> m a -> m a
memberUsingLookupM :: AssocX m k => k -> m a -> Bool
sizeUsingElements :: AssocX m k => m a -> Int
countUsingMember :: AssocX m k => k -> m a -> Int
lookupAllUsingLookupM :: (AssocX m k, Sequence seq) => k -> m a -> seq a
lookupWithDefaultUsingLookupM :: AssocX m k => a -> k -> m a -> a
partitionUsingFilter :: AssocX m k => (a -> Bool) -> m a -> (m a, m a)
fold1UsingElements :: AssocX m k => (a -> a -> a) -> m a -> a
elementsUsingFold :: (AssocX m k, Sequence seq) => m a -> seq a
nullUsingElements :: AssocX m k => m a -> Bool
insertWithUsingLookupM :: FiniteMapX m k => (a -> a -> a) -> k -> a -> m a -> m a
fromSeqWithUsingInsertSeqWith :: (FiniteMapX m k, Sequence seq) => (a -> a -> a) -> seq (k, a) -> m a
fromSeqWithKeyUsingInsertSeqWithKey :: (FiniteMapX m k, Sequence seq) => (k -> a -> a -> a) -> seq (k, a) -> m a
insertWithKeyUsingInsertWith :: FiniteMapX m k => (k -> a -> a -> a) -> k -> a -> m a -> m a
insertSeqWithUsingInsertWith :: (FiniteMapX m k, Sequence seq) => (a -> a -> a) -> seq (k, a) -> m a -> m a
insertSeqWithKeyUsingInsertWithKey :: (FiniteMapX m k, Sequence seq) => (k -> a -> a -> a) -> seq (k, a) -> m a -> m a
unionSeqWithUsingReduce :: (FiniteMapX m k, Sequence seq) => (a -> a -> a) -> seq (m a) -> m a
unionSeqWithUsingFoldr :: (FiniteMapX m k, Sequence seq) => (a -> a -> a) -> seq (m a) -> m a
toSeqUsingFoldWithKey :: (Assoc m k, Sequence seq) => m a -> seq (k, a)
keysUsingFoldWithKey :: (Assoc m k, Sequence seq) => m a -> seq k
unionWithUsingInsertWith :: FiniteMap m k => (a -> a -> a) -> m a -> m a -> m a
unionWithKeyUsingInsertWithKey :: FiniteMap m k => (k -> a -> a -> a) -> m a -> m a -> m a
unionSeqWithKeyUsingReduce :: (FiniteMap m k, Sequence seq) => (k -> a -> a -> a) -> seq (m a) -> m a
unionSeqWithKeyUsingFoldr :: (FiniteMap m k, Sequence seq) => (k -> a -> a -> a) -> seq (m a) -> m a
intersectionWithUsingLookupM :: FiniteMap m k => (a -> b -> c) -> m a -> m b -> m c
intersectionWithKeyUsingLookupM :: FiniteMap m k => (k -> a -> b -> c) -> m a -> m b -> m c
differenceUsingDelete :: FiniteMap m k => m a -> m b -> m a
properSubsetUsingSubset :: FiniteMapX m k => m a -> m b -> Bool
subsetUsingMember :: FiniteMap m k => m a -> m b -> Bool
submapByUsingLookupM :: FiniteMap m k => (a -> a -> Bool) -> m a -> m a -> Bool
properSubmapByUsingSubmapBy :: FiniteMapX m k => (a -> a -> Bool) -> m a -> m a -> Bool
sameMapByUsingOrdLists :: OrdFiniteMap m k => (a -> a -> Bool) -> m a -> m a -> Bool
sameMapByUsingSubmapBy :: FiniteMapX m k => (a -> a -> Bool) -> m a -> m a -> Bool
lookupAndDeleteDefault :: AssocX m k => k -> m a -> (a, m a)
lookupAndDeleteMDefault :: (Monad rm, AssocX m k) => k -> m a -> rm (a, m a)
lookupAndDeleteAllDefault :: (Sequence seq, AssocX m k) => k -> m a -> (seq a, m a)
adjustOrInsertUsingMember :: AssocX m k => (a -> a) -> a -> k -> m a -> m a
adjustOrDeleteDefault :: AssocX m k => (a -> Maybe a) -> k -> m a -> m a
adjustOrDeleteAllDefault :: AssocX m k => (a -> Maybe a) -> k -> m a -> m a
minElemUsingMinView :: OrdAssocX m k => m a -> a
deleteMinUsingMinView :: OrdAssocX m k => m a -> m a
minElemWithKeyUsingMinViewWithKey :: OrdAssoc m k => m a -> (k, a)
maxElemUsingMaxView :: OrdAssocX m k => m a -> a
deleteMaxUsingMaxView :: OrdAssocX m k => m a -> m a
maxElemWithKeyUsingMaxViewWithKey :: OrdAssoc m k => m a -> (k, a)
toOrdSeqUsingFoldrWithKey :: (OrdAssoc m k, Sequence seq) => m a -> seq (k, a)
showsPrecUsingToList :: (Show k, Show a, Assoc m k) => Int -> m a -> ShowS
readsPrecUsingFromList :: (Read k, Read a, AssocX m k) => Int -> ReadS (m a)
showsPrecUsingToOrdList :: (Show k, Show a, OrdAssoc m k) => Int -> m a -> ShowS
readsPrecUsingUnsafeFromOrdSeq :: (Read k, Read a, OrdAssoc m k) => Int -> ReadS (m a)
compareUsingToOrdList :: (Ord a, OrdAssoc m k) => m a -> m a -> Ordering


-- | This module implements finite maps as simple association lists.
--   
--   Duplicates are removed conceptually, but not physically. The first
--   occurrence of a given key is the one that is considered to be in the
--   map.
--   
--   The list type is mildly customized to prevent boxing the pairs.
module Data.Edison.Assoc.AssocList
data FM k a
empty :: Eq k => FM k a
singleton :: Eq k => k -> a -> FM k a
fromSeq :: (Eq k, Sequence seq) => seq (k, a) -> FM k a
insert :: Eq k => k -> a -> FM k a -> FM k a
insertSeq :: (Eq k, Sequence seq) => seq (k, a) -> FM k a -> FM k a
union :: Eq k => FM k a -> FM k a -> FM k a
unionSeq :: (Eq k, Sequence seq) => seq (FM k a) -> FM k a
delete :: Eq k => k -> FM k a -> FM k a
deleteAll :: Eq k => k -> FM k a -> FM k a
deleteSeq :: (Eq k, Sequence seq) => seq k -> FM k a -> FM k a
null :: Eq k => FM k a -> Bool
size :: Eq k => FM k a -> Int
member :: Eq k => k -> FM k a -> Bool
count :: Eq k => k -> FM k a -> Int
lookup :: Eq k => k -> FM k a -> a
lookupM :: (Eq k, Monad rm) => k -> FM k a -> rm a
lookupAll :: (Eq k, Sequence seq) => k -> FM k a -> seq a
lookupAndDelete :: Eq k => k -> FM k a -> (a, FM k a)
lookupAndDeleteM :: (Eq k, Monad rm) => k -> FM k a -> rm (a, FM k a)
lookupAndDeleteAll :: (Eq k, Sequence seq) => k -> FM k a -> (seq a, FM k a)
lookupWithDefault :: Eq k => a -> k -> FM k a -> a
adjust :: Eq k => (a -> a) -> k -> FM k a -> FM k a
adjustAll :: Eq k => (a -> a) -> k -> FM k a -> FM k a
adjustOrInsert :: Eq k => (a -> a) -> a -> k -> FM k a -> FM k a
adjustAllOrInsert :: Eq k => (a -> a) -> a -> k -> FM k a -> FM k a
adjustOrDelete :: Eq k => (a -> Maybe a) -> k -> FM k a -> FM k a
adjustOrDeleteAll :: Eq k => (a -> Maybe a) -> k -> FM k a -> FM k a
strict :: FM k a -> FM k a
strictWith :: (a -> b) -> FM k a -> FM k a
map :: Eq k => (a -> b) -> FM k a -> FM k b
fold :: Eq k => (a -> b -> b) -> b -> FM k a -> b
fold' :: Eq k => (a -> b -> b) -> b -> FM k a -> b
fold1 :: Eq k => (a -> a -> a) -> FM k a -> a
fold1' :: Eq k => (a -> a -> a) -> FM k a -> a
filter :: Eq k => (a -> Bool) -> FM k a -> FM k a
partition :: Eq k => (a -> Bool) -> FM k a -> (FM k a, FM k a)
elements :: (Eq k, Sequence seq) => FM k a -> seq a
structuralInvariant :: Eq k => FM k a -> Bool
minView :: (Ord k, Monad m) => FM k a -> m (a, FM k a)
minElem :: Ord k => FM k a -> a
deleteMin :: Ord k => FM k a -> FM k a
unsafeInsertMin :: Ord k => k -> a -> FM k a -> FM k a
maxView :: (Ord k, Monad m) => FM k a -> m (a, FM k a)
maxElem :: Ord k => FM k a -> a
deleteMax :: Ord k => FM k a -> FM k a
unsafeInsertMax :: Ord k => k -> a -> FM k a -> FM k a
foldr :: Ord k => (a -> b -> b) -> b -> FM k a -> b
foldr' :: Ord k => (a -> b -> b) -> b -> FM k a -> b
foldl :: Ord k => (b -> a -> b) -> b -> FM k a -> b
foldl' :: Ord k => (b -> a -> b) -> b -> FM k a -> b
foldr1 :: Ord k => (a -> a -> a) -> FM k a -> a
foldr1' :: Ord k => (a -> a -> a) -> FM k a -> a
foldl1 :: Ord k => (a -> a -> a) -> FM k a -> a
foldl1' :: Ord k => (a -> a -> a) -> FM k a -> a
unsafeFromOrdSeq :: (Ord k, Sequence seq) => seq (k, a) -> FM k a
unsafeAppend :: Ord k => FM k a -> FM k a -> FM k a
filterLT :: Ord k => k -> FM k a -> FM k a
filterLE :: Ord k => k -> FM k a -> FM k a
filterGT :: Ord k => k -> FM k a -> FM k a
filterGE :: Ord k => k -> FM k a -> FM k a
partitionLT_GE :: Ord k => k -> FM k a -> (FM k a, FM k a)
partitionLE_GT :: Ord k => k -> FM k a -> (FM k a, FM k a)
partitionLT_GT :: Ord k => k -> FM k a -> (FM k a, FM k a)
toSeq :: (Eq k, Sequence seq) => FM k a -> seq (k, a)
keys :: (Eq k, Sequence seq) => FM k a -> seq k
mapWithKey :: Eq k => (k -> a -> b) -> FM k a -> FM k b
foldWithKey :: Eq k => (k -> a -> b -> b) -> b -> FM k a -> b
foldWithKey' :: Eq k => (k -> a -> b -> b) -> b -> FM k a -> b
filterWithKey :: Eq k => (k -> a -> Bool) -> FM k a -> FM k a
partitionWithKey :: Eq k => (k -> a -> Bool) -> FM k a -> (FM k a, FM k a)
minViewWithKey :: (Ord k, Monad m) => FM k a -> m ((k, a), FM k a)
minElemWithKey :: Ord k => FM k a -> (k, a)
maxViewWithKey :: (Ord k, Monad m) => FM k a -> m ((k, a), FM k a)
maxElemWithKey :: Ord k => FM k a -> (k, a)
foldrWithKey :: Ord k => (k -> a -> b -> b) -> b -> FM k a -> b
foldrWithKey' :: Ord k => (k -> a -> b -> b) -> b -> FM k a -> b
foldlWithKey :: Ord k => (b -> k -> a -> b) -> b -> FM k a -> b
foldlWithKey' :: Ord k => (b -> k -> a -> b) -> b -> FM k a -> b
toOrdSeq :: (Ord k, Sequence seq) => FM k a -> seq (k, a)
fromSeqWith :: (Eq k, Sequence seq) => (a -> a -> a) -> seq (k, a) -> FM k a
fromSeqWithKey :: (Eq k, Sequence seq) => (k -> a -> a -> a) -> seq (k, a) -> FM k a
insertWith :: Eq k => (a -> a -> a) -> k -> a -> FM k a -> FM k a
insertWithKey :: Eq k => (k -> a -> a -> a) -> k -> a -> FM k a -> FM k a
insertSeqWith :: (Eq k, Sequence seq) => (a -> a -> a) -> seq (k, a) -> FM k a -> FM k a
insertSeqWithKey :: (Eq k, Sequence seq) => (k -> a -> a -> a) -> seq (k, a) -> FM k a -> FM k a
unionl :: Eq k => FM k a -> FM k a -> FM k a
unionr :: Eq k => FM k a -> FM k a -> FM k a
unionWith :: Eq k => (a -> a -> a) -> FM k a -> FM k a -> FM k a
unionSeqWith :: (Eq k, Sequence seq) => (a -> a -> a) -> seq (FM k a) -> FM k a
intersectionWith :: Eq k => (a -> b -> c) -> FM k a -> FM k b -> FM k c
difference :: Eq k => FM k a -> FM k b -> FM k a
properSubset :: Eq k => FM k a -> FM k b -> Bool
subset :: Eq k => FM k a -> FM k b -> Bool
properSubmapBy :: Eq k => (a -> a -> Bool) -> FM k a -> FM k a -> Bool
submapBy :: Eq k => (a -> a -> Bool) -> FM k a -> FM k a -> Bool
sameMapBy :: Eq k => (a -> a -> Bool) -> FM k a -> FM k a -> Bool
properSubmap :: (Eq k, Eq a) => FM k a -> FM k a -> Bool
submap :: (Eq k, Eq a) => FM k a -> FM k a -> Bool
sameMap :: (Eq k, Eq a) => FM k a -> FM k a -> Bool
unionWithKey :: Eq k => (k -> a -> a -> a) -> FM k a -> FM k a -> FM k a
unionSeqWithKey :: (Eq k, Sequence seq) => (k -> a -> a -> a) -> seq (FM k a) -> FM k a
intersectionWithKey :: Eq k => (k -> a -> b -> c) -> FM k a -> FM k b -> FM k c
moduleName :: String
instance Eq k => Monoid (FM k a)
instance (Eq k, CoArbitrary k, CoArbitrary a) => CoArbitrary (FM k a)
instance (Eq k, Arbitrary k, Arbitrary a) => Arbitrary (FM k a)
instance (Eq k, Read k, Read a) => Read (FM k a)
instance (Eq k, Show k, Show a) => Show (FM k a)
instance (Ord k, Ord a) => Ord (FM k a)
instance (Eq k, Eq a) => Eq (FM k a)
instance Eq k => Functor (FM k)
instance Ord k => OrdFiniteMap (FM k) k
instance Eq k => FiniteMap (FM k) k
instance Ord k => OrdAssoc (FM k) k
instance Eq k => Assoc (FM k) k
instance Ord k => OrdFiniteMapX (FM k) k
instance Eq k => FiniteMapX (FM k) k
instance Ord k => OrdAssocX (FM k) k
instance Eq k => AssocX (FM k) k


-- | Finite maps implemented as little-endian Patricia trees.
--   
--   <i>References:</i>
--   
--   <ul>
--   <li>Chris Okasaki and Any Gill. "Fast Mergeable Integer Maps".
--   Workshop on ML, September 1998, pages 77-86.</li>
--   </ul>
module Data.Edison.Assoc.PatriciaLoMap
data FM a
empty :: FM a
singleton :: Int -> a -> FM a
fromSeq :: Sequence seq => seq (Int, a) -> FM a
insert :: Int -> a -> FM a -> FM a
insertSeq :: Sequence seq => seq (Int, a) -> FM a -> FM a
union :: FM a -> FM a -> FM a
unionSeq :: Sequence seq => seq (FM a) -> FM a
delete :: Int -> FM a -> FM a
deleteAll :: Int -> FM a -> FM a
deleteSeq :: Sequence seq => seq Int -> FM a -> FM a
null :: FM a -> Bool
size :: FM a -> Int
member :: Int -> FM a -> Bool
count :: Int -> FM a -> Int
lookup :: Int -> FM a -> a
lookupM :: Monad rm => Int -> FM a -> rm a
lookupAll :: Sequence seq => Int -> FM a -> seq a
lookupAndDelete :: Int -> FM a -> (a, FM a)
lookupAndDeleteM :: Monad m => Int -> FM a -> m (a, FM a)
lookupAndDeleteAll :: Sequence seq => Int -> FM a -> (seq a, FM a)
strict :: t -> t
strictWith :: (t -> a) -> FM t -> FM t
lookupWithDefault :: a -> Int -> FM a -> a
adjust :: (a -> a) -> Int -> FM a -> FM a
adjustAll :: (a -> a) -> Int -> FM a -> FM a
adjustOrInsert :: (a -> a) -> a -> Int -> FM a -> FM a
adjustAllOrInsert :: (a -> a) -> a -> Int -> FM a -> FM a
map :: (a -> b) -> FM a -> FM b
fold :: (a -> b -> b) -> b -> FM a -> b
fold' :: (a -> b -> b) -> b -> FM a -> b
fold1 :: (a -> a -> a) -> FM a -> a
fold1' :: (a -> a -> a) -> FM a -> a
filter :: (a -> Bool) -> FM a -> FM a
partition :: (a -> Bool) -> FM a -> (FM a, FM a)
elements :: Sequence seq => FM a -> seq a
structuralInvariant :: FM a -> Bool
toSeq :: Sequence seq => FM a -> seq (Int, a)
keys :: Sequence seq => FM a -> seq Int
mapWithKey :: (Int -> a -> b) -> FM a -> FM b
foldWithKey :: (Int -> a -> b -> b) -> b -> FM a -> b
foldWithKey' :: (Int -> a -> b -> b) -> b -> FM a -> b
filterWithKey :: (Int -> a -> Bool) -> FM a -> FM a
partitionWithKey :: (Int -> a -> Bool) -> FM a -> (FM a, FM a)
fromSeqWith :: Sequence seq => (a -> a -> a) -> seq (Int, a) -> FM a
fromSeqWithKey :: Sequence seq => (Int -> a -> a -> a) -> seq (Int, a) -> FM a
insertWith :: (a -> a -> a) -> Int -> a -> FM a -> FM a
insertWithKey :: (Int -> a -> a -> a) -> Int -> a -> FM a -> FM a
insertSeqWith :: Sequence seq => (a -> a -> a) -> seq (Int, a) -> FM a -> FM a
insertSeqWithKey :: Sequence seq => (Int -> a -> a -> a) -> seq (Int, a) -> FM a -> FM a
unionl :: FM a -> FM a -> FM a
unionr :: FM a -> FM a -> FM a
unionWith :: (a -> a -> a) -> FM a -> FM a -> FM a
unionSeqWith :: Sequence seq => (a -> a -> a) -> seq (FM a) -> FM a
intersectionWith :: (a -> b -> c) -> FM a -> FM b -> FM c
difference :: FM a -> FM b -> FM a
properSubset :: FM a -> FM b -> Bool
subset :: FM a -> FM b -> Bool
properSubmapBy :: (a -> a -> Bool) -> FM a -> FM a -> Bool
submapBy :: (a -> a -> Bool) -> FM a -> FM a -> Bool
sameMapBy :: (a -> a -> Bool) -> FM a -> FM a -> Bool
properSubmap :: Eq a => FM a -> FM a -> Bool
submap :: Eq a => FM a -> FM a -> Bool
sameMap :: Eq a => FM a -> FM a -> Bool
unionWithKey :: (Int -> a -> a -> a) -> FM a -> FM a -> FM a
unionSeqWithKey :: Sequence seq => (Int -> a -> a -> a) -> seq (FM a) -> FM a
intersectionWithKey :: (Int -> a -> b -> c) -> FM a -> FM b -> FM c
minView :: Monad m => FM a -> m (a, FM a)
minElem :: FM a -> a
deleteMin :: FM a -> FM a
unsafeInsertMin :: Int -> a -> FM a -> FM a
maxView :: Monad m => FM a -> m (a, FM a)
maxElem :: FM a -> a
deleteMax :: FM a -> FM a
unsafeInsertMax :: Int -> a -> FM a -> FM a
foldr :: (a -> b -> b) -> b -> FM a -> b
foldr' :: (a -> b -> b) -> b -> FM a -> b
foldr1 :: (a -> a -> a) -> FM a -> a
foldr1' :: (a -> a -> a) -> FM a -> a
foldl :: (b -> a -> b) -> b -> FM a -> b
foldl' :: (b -> a -> b) -> b -> FM a -> b
foldl1 :: (a -> a -> a) -> FM a -> a
foldl1' :: (a -> a -> a) -> FM a -> a
unsafeFromOrdSeq :: Sequence seq => seq (Int, a) -> FM a
unsafeAppend :: FM a -> FM a -> FM a
filterLT :: Int -> FM a -> FM a
filterLE :: Int -> FM a -> FM a
filterGT :: Int -> FM a -> FM a
filterGE :: Int -> FM a -> FM a
partitionLT_GE :: Int -> FM a -> (FM a, FM a)
partitionLE_GT :: Int -> FM a -> (FM a, FM a)
partitionLT_GT :: Int -> FM a -> (FM a, FM a)
minViewWithKey :: Monad m => FM a -> m ((Int, a), FM a)
minElemWithKey :: FM a -> (Int, a)
maxViewWithKey :: Monad m => FM a -> m ((Int, a), FM a)
maxElemWithKey :: FM a -> (Int, a)
foldrWithKey :: (Int -> a -> b -> b) -> b -> FM a -> b
foldrWithKey' :: (Int -> a -> b -> b) -> b -> FM a -> b
foldlWithKey :: (b -> Int -> a -> b) -> b -> FM a -> b
foldlWithKey' :: (b -> Int -> a -> b) -> b -> FM a -> b
toOrdSeq :: Sequence seq => FM a -> seq (Int, a)
moduleName :: String
instance Monoid (FM a)
instance CoArbitrary a => CoArbitrary (FM a)
instance Arbitrary a => Arbitrary (FM a)
instance Ord a => Ord (FM a)
instance Eq a => Eq (FM a)
instance Read a => Read (FM a)
instance Show a => Show (FM a)
instance Functor FM
instance OrdFiniteMap FM Int
instance OrdFiniteMapX FM Int
instance OrdAssoc FM Int
instance OrdAssocX FM Int
instance FiniteMap FM Int
instance FiniteMapX FM Int
instance Assoc FM Int
instance AssocX FM Int


-- | The standard library <a>Data.Map</a> repackaged as an Edison
--   associative collection.
module Data.Edison.Assoc.StandardMap
type FM = Map
empty :: FM k a
singleton :: Ord k => k -> a -> FM k a
fromSeq :: (Ord k, Sequence seq) => seq (k, a) -> FM k a
insert :: Ord k => k -> a -> FM k a -> FM k a
insertSeq :: (Ord k, Sequence seq) => seq (k, a) -> FM k a -> FM k a
union :: Ord k => FM k a -> FM k a -> FM k a
unionSeq :: (Ord k, Sequence seq) => seq (FM k a) -> FM k a
delete :: Ord k => k -> FM k a -> FM k a
deleteAll :: Ord k => k -> FM k a -> FM k a
deleteSeq :: (Ord k, Sequence seq) => seq k -> FM k a -> FM k a
null :: FM k a -> Bool
size :: FM k a -> Int
member :: Ord k => k -> FM k a -> Bool
count :: Ord k => k -> FM k a -> Int
lookup :: Ord k => k -> FM k a -> a
lookupM :: (Ord k, Monad m) => k -> FM k a -> m a
lookupAll :: (Ord k, Sequence seq) => k -> FM k a -> seq a
lookupAndDelete :: Ord k => k -> FM k a -> (a, FM k a)
lookupAndDeleteM :: (Ord k, Monad m) => k -> FM k a -> m (a, FM k a)
lookupAndDeleteAll :: (Ord k, Sequence seq) => k -> FM k a -> (seq a, FM k a)
lookupWithDefault :: Ord k => a -> k -> FM k a -> a
adjust :: Ord k => (a -> a) -> k -> FM k a -> FM k a
adjustAll :: Ord k => (a -> a) -> k -> FM k a -> FM k a
adjustOrInsert :: Ord k => (a -> a) -> a -> k -> FM k a -> FM k a
adjustAllOrInsert :: Ord k => (a -> a) -> a -> k -> FM k a -> FM k a
adjustOrDelete :: Ord k => (a -> Maybe a) -> k -> FM k a -> FM k a
adjustOrDeleteAll :: Ord k => (a -> Maybe a) -> k -> FM k a -> FM k a
strict :: Ord k => FM k a -> FM k a
strictWith :: Ord k => (a -> b) -> FM k a -> FM k a
map :: (Ord k, Functor (FM k)) => (a -> b) -> FM k a -> FM k b
fold :: Ord k => (a -> b -> b) -> b -> FM k a -> b
fold' :: Ord k => (a -> b -> b) -> b -> FM k a -> b
fold1 :: Ord k => (a -> a -> a) -> FM k a -> a
fold1' :: Ord k => (a -> a -> a) -> FM k a -> a
filter :: Ord k => (a -> Bool) -> FM k a -> FM k a
partition :: Ord k => (a -> Bool) -> FM k a -> (FM k a, FM k a)
elements :: (Ord k, Sequence seq) => FM k a -> seq a
structuralInvariant :: Ord k => FM k a -> Bool
fromSeqWith :: (Ord k, Sequence seq) => (a -> a -> a) -> seq (k, a) -> FM k a
fromSeqWithKey :: (Ord k, Sequence seq) => (k -> a -> a -> a) -> seq (k, a) -> FM k a
insertWith :: Ord k => (a -> a -> a) -> k -> a -> FM k a -> FM k a
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> FM k a -> FM k a
insertSeqWith :: (Ord k, Sequence seq) => (a -> a -> a) -> seq (k, a) -> FM k a -> FM k a
insertSeqWithKey :: (Ord k, Sequence seq) => (k -> a -> a -> a) -> seq (k, a) -> FM k a -> FM k a
unionl :: Ord k => FM k a -> FM k a -> FM k a
unionr :: Ord k => FM k a -> FM k a -> FM k a
unionWith :: Ord k => (a -> a -> a) -> FM k a -> FM k a -> FM k a
unionSeqWith :: (Ord k, Sequence seq) => (a -> a -> a) -> seq (FM k a) -> FM k a
intersectionWith :: Ord k => (a -> b -> c) -> FM k a -> FM k b -> FM k c
difference :: Ord k => FM k a -> FM k b -> FM k a
properSubset :: Ord k => FM k a -> FM k b -> Bool
subset :: Ord k => FM k a -> FM k b -> Bool
properSubmapBy :: Ord k => (a -> a -> Bool) -> FM k a -> FM k a -> Bool
submapBy :: Ord k => (a -> a -> Bool) -> FM k a -> FM k a -> Bool
sameMapBy :: Ord k => (a -> a -> Bool) -> FM k a -> FM k a -> Bool
properSubmap :: (Ord k, Eq a) => FM k a -> FM k a -> Bool
submap :: (Ord k, Eq a) => FM k a -> FM k a -> Bool
sameMap :: (Ord k, Eq a) => FM k a -> FM k a -> Bool
minView :: (Ord k, Monad m) => FM k a -> m (a, FM k a)
minElem :: Ord k => FM k a -> a
deleteMin :: Ord k => FM k a -> FM k a
unsafeInsertMin :: Ord k => k -> a -> FM k a -> FM k a
maxView :: (Ord k, Monad m) => FM k a -> m (a, FM k a)
maxElem :: Ord k => FM k a -> a
deleteMax :: Ord k => FM k a -> FM k a
unsafeInsertMax :: Ord k => k -> a -> FM k a -> FM k a
foldr :: Ord k => (a -> b -> b) -> b -> FM k a -> b
foldr' :: Ord k => (a -> b -> b) -> b -> FM k a -> b
foldl :: Ord k => (b -> a -> b) -> b -> FM k a -> b
foldl' :: Ord k => (b -> a -> b) -> b -> FM k a -> b
foldr1 :: Ord k => (a -> a -> a) -> FM k a -> a
foldr1' :: Ord k => (a -> a -> a) -> FM k a -> a
foldl1 :: Ord k => (a -> a -> a) -> FM k a -> a
foldl1' :: Ord k => (a -> a -> a) -> FM k a -> a
unsafeFromOrdSeq :: (Ord k, Sequence seq) => seq (k, a) -> FM k a
unsafeAppend :: Ord k => FM k a -> FM k a -> FM k a
filterLT :: Ord k => k -> FM k a -> FM k a
filterLE :: Ord k => k -> FM k a -> FM k a
filterGT :: Ord k => k -> FM k a -> FM k a
filterGE :: Ord k => k -> FM k a -> FM k a
partitionLT_GE :: Ord k => k -> FM k a -> (FM k a, FM k a)
partitionLE_GT :: Ord k => k -> FM k a -> (FM k a, FM k a)
partitionLT_GT :: Ord k => k -> FM k a -> (FM k a, FM k a)
toSeq :: (Ord k, Sequence seq) => FM k a -> seq (k, a)
keys :: (Ord k, Sequence seq) => FM k a -> seq k
mapWithKey :: Ord k => (k -> a -> b) -> FM k a -> FM k b
foldWithKey :: Ord k => (k -> a -> b -> b) -> b -> FM k a -> b
foldWithKey' :: Ord k => (k -> a -> b -> b) -> b -> FM k a -> b
filterWithKey :: Ord k => (k -> a -> Bool) -> FM k a -> FM k a
partitionWithKey :: Ord k => (k -> a -> Bool) -> FM k a -> (FM k a, FM k a)
minViewWithKey :: (Ord k, Monad m) => FM k a -> m ((k, a), FM k a)
minElemWithKey :: Ord k => FM k a -> (k, a)
maxViewWithKey :: (Ord k, Monad m) => FM k a -> m ((k, a), FM k a)
maxElemWithKey :: Ord k => FM k a -> (k, a)
foldrWithKey :: (k -> a -> b -> b) -> b -> FM k a -> b
foldrWithKey' :: (k -> a -> b -> b) -> b -> FM k a -> b
foldlWithKey :: (b -> k -> a -> b) -> b -> FM k a -> b
foldlWithKey' :: (b -> k -> a -> b) -> b -> FM k a -> b
toOrdSeq :: (Ord k, Sequence seq) => FM k a -> seq (k, a)
unionWithKey :: Ord k => (k -> a -> a -> a) -> FM k a -> FM k a -> FM k a
unionSeqWithKey :: (Ord k, Sequence seq) => (k -> a -> a -> a) -> seq (FM k a) -> FM k a
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> FM k a -> FM k b -> FM k c
moduleName :: String
instance (Ord k, CoArbitrary k, CoArbitrary a) => CoArbitrary (FM k a)
instance (Ord k, Arbitrary k, Arbitrary a) => Arbitrary (FM k a)
instance Ord k => OrdFiniteMap (FM k) k
instance Ord k => FiniteMap (FM k) k
instance Ord k => OrdAssoc (FM k) k
instance Ord k => Assoc (FM k) k
instance Ord k => OrdFiniteMapX (FM k) k
instance Ord k => FiniteMapX (FM k) k
instance Ord k => OrdAssocX (FM k) k
instance Ord k => AssocX (FM k) k


-- | Finite maps implemented as ternary search tries
module Data.Edison.Assoc.TernaryTrie
data FM k a
empty :: Ord k => FM k a
singleton :: Ord k => [k] -> a -> FM k a
fromSeq :: (Ord k, Sequence seq) => seq ([k], a) -> FM k a
insert :: Ord k => [k] -> a -> FM k a -> FM k a
insertSeq :: (Ord k, Sequence seq) => seq ([k], a) -> FM k a -> FM k a
union :: Ord k => FM k a -> FM k a -> FM k a
unionSeq :: (Ord k, Sequence seq) => seq (FM k a) -> FM k a
delete :: Ord k => [k] -> FM k a -> FM k a
deleteAll :: Ord k => [k] -> FM k a -> FM k a
deleteSeq :: (Ord k, Sequence seq) => seq [k] -> FM k a -> FM k a
null :: Ord k => FM k a -> Bool
size :: Ord k => FM k a -> Int
member :: Ord k => [k] -> FM k a -> Bool
count :: Ord k => [k] -> FM k a -> Int
lookup :: Ord k => [k] -> FM k a -> a
lookupM :: (Ord k, Monad rm) => [k] -> FM k a -> rm a
lookupAll :: (Ord k, Sequence seq) => [k] -> FM k a -> seq a
lookupAndDelete :: Ord k => [k] -> FM k a -> (a, FM k a)
lookupAndDeleteM :: (Ord k, Monad rm) => [k] -> FM k a -> rm (a, FM k a)
lookupAndDeleteAll :: (Ord k, Sequence seq) => [k] -> FM k a -> (seq a, FM k a)
lookupWithDefault :: Ord k => a -> [k] -> FM k a -> a
adjust :: Ord k => (a -> a) -> [k] -> FM k a -> FM k a
adjustAll :: Ord k => (a -> a) -> [k] -> FM k a -> FM k a
adjustOrInsert :: Ord k => (a -> a) -> a -> [k] -> FM k a -> FM k a
adjustAllOrInsert :: Ord k => (a -> a) -> a -> [k] -> FM k a -> FM k a
adjustOrDelete :: Ord k => (a -> Maybe a) -> [k] -> FM k a -> FM k a
adjustOrDeleteAll :: Ord k => (a -> Maybe a) -> [k] -> FM k a -> FM k a
strict :: FM k a -> FM k a
strictWith :: (a -> b) -> FM k a -> FM k a
map :: Ord k => (a -> b) -> FM k a -> FM k b
fold :: Ord k => (a -> b -> b) -> b -> FM k a -> b
fold' :: Ord k => (a -> b -> b) -> b -> FM k a -> b
fold1 :: Ord k => (a -> a -> a) -> FM k a -> a
fold1' :: Ord k => (a -> a -> a) -> FM k a -> a
filter :: Ord k => (a -> Bool) -> FM k a -> FM k a
partition :: Ord k => (a -> Bool) -> FM k a -> (FM k a, FM k a)
elements :: (Ord k, Sequence seq) => FM k a -> seq a
structuralInvariant :: Ord k => FM k a -> Bool
toSeq :: (Ord k, Sequence seq) => FM k a -> seq ([k], a)
keys :: (Ord k, Sequence seq) => FM k a -> seq [k]
mapWithKey :: Ord k => ([k] -> a -> b) -> FM k a -> FM k b
foldWithKey :: Ord k => ([k] -> a -> b -> b) -> b -> FM k a -> b
foldWithKey' :: Ord k => ([k] -> a -> b -> b) -> b -> FM k a -> b
filterWithKey :: Ord k => ([k] -> a -> Bool) -> FM k a -> FM k a
partitionWithKey :: Ord k => ([k] -> a -> Bool) -> FM k a -> (FM k a, FM k a)
fromSeqWith :: (Ord k, Sequence seq) => (a -> a -> a) -> seq ([k], a) -> FM k a
fromSeqWithKey :: (Ord k, Sequence seq) => ([k] -> a -> a -> a) -> seq ([k], a) -> FM k a
insertWith :: Ord k => (a -> a -> a) -> [k] -> a -> FM k a -> FM k a
insertWithKey :: Ord k => ([k] -> a -> a -> a) -> [k] -> a -> FM k a -> FM k a
insertSeqWith :: (Ord k, Sequence seq) => (a -> a -> a) -> seq ([k], a) -> FM k a -> FM k a
insertSeqWithKey :: (Ord k, Sequence seq) => ([k] -> a -> a -> a) -> seq ([k], a) -> FM k a -> FM k a
unionl :: Ord k => FM k a -> FM k a -> FM k a
unionr :: Ord k => FM k a -> FM k a -> FM k a
unionWith :: Ord k => (a -> a -> a) -> FM k a -> FM k a -> FM k a
unionSeqWith :: (Ord k, Sequence seq) => (a -> a -> a) -> seq (FM k a) -> FM k a
intersectionWith :: Ord k => (a -> b -> c) -> FM k a -> FM k b -> FM k c
difference :: Ord k => FM k a -> FM k b -> FM k a
properSubset :: Ord k => FM k a -> FM k b -> Bool
subset :: Ord k => FM k a -> FM k b -> Bool
properSubmapBy :: Ord k => (a -> a -> Bool) -> FM k a -> FM k a -> Bool
submapBy :: Ord k => (a -> a -> Bool) -> FM k a -> FM k a -> Bool
sameMapBy :: Ord k => (a -> a -> Bool) -> FM k a -> FM k a -> Bool
properSubmap :: (Ord k, Eq a) => FM k a -> FM k a -> Bool
submap :: (Ord k, Eq a) => FM k a -> FM k a -> Bool
sameMap :: (Ord k, Eq a) => FM k a -> FM k a -> Bool
unionWithKey :: Ord k => ([k] -> a -> a -> a) -> FM k a -> FM k a -> FM k a
unionSeqWithKey :: (Ord k, Sequence seq) => ([k] -> a -> a -> a) -> seq (FM k a) -> FM k a
intersectionWithKey :: Ord k => ([k] -> a -> b -> c) -> FM k a -> FM k b -> FM k c
minView :: Monad m => FM k a -> m (a, FM k a)
minElem :: FM t1 t -> t
deleteMin :: Ord k => FM k a -> FM k a
unsafeInsertMin :: Ord k => [k] -> a -> FM k a -> FM k a
maxView :: Monad m => FM k a -> m (a, FM k a)
maxElem :: FM k a -> a
deleteMax :: Ord k => FM k a -> FM k a
unsafeInsertMax :: Ord k => [k] -> a -> FM k a -> FM k a
foldr :: Ord k => (a -> b -> b) -> b -> FM k a -> b
foldr' :: Ord k => (a -> b -> b) -> b -> FM k a -> b
foldr1 :: Ord k => (a -> a -> a) -> FM k a -> a
foldr1' :: Ord k => (a -> a -> a) -> FM k a -> a
foldl :: (a -> b -> a) -> a -> FM t b -> a
foldl' :: (a -> b -> a) -> a -> FM t b -> a
foldl1 :: (b -> b -> b) -> FM k b -> b
foldl1' :: (b -> b -> b) -> FM k b -> b
unsafeFromOrdSeq :: (Ord k, Sequence seq) => seq ([k], a) -> FM k a
unsafeAppend :: Ord k => FM k a -> FM k a -> FM k a
filterLT :: Ord k => [k] -> FM k a -> FM k a
filterLE :: Ord k => [k] -> FM k a -> FM k a
filterGT :: Ord k => [k] -> FM k a -> FM k a
filterGE :: Ord k => [k] -> FM k a -> FM k a
partitionLT_GE :: Ord k => [k] -> FM k a -> (FM k a, FM k a)
partitionLE_GT :: Ord k => [k] -> FM k a -> (FM k a, FM k a)
partitionLT_GT :: Ord k => [k] -> FM k a -> (FM k a, FM k a)
minViewWithKey :: Monad m => FM k a -> m (([k], a), FM k a)
minElemWithKey :: FM k a -> ([k], a)
maxViewWithKey :: Monad m => FM k a -> m (([k], a), FM k a)
maxElemWithKey :: FM k a -> ([k], a)
foldrWithKey :: Ord k => ([k] -> a -> b -> b) -> b -> FM k a -> b
foldrWithKey' :: Ord k => ([k] -> a -> b -> b) -> b -> FM k a -> b
foldlWithKey :: Ord k => (b -> [k] -> a -> b) -> b -> FM k a -> b
foldlWithKey' :: Ord k => (b -> [k] -> a -> b) -> b -> FM k a -> b
toOrdSeq :: (Ord k, Sequence seq) => FM k a -> seq ([k], a)
mergeVFM :: Ord k => (Maybe a -> Maybe b -> Maybe c) -> FM k a -> FM k b -> FM k c
mergeKVFM :: Ord k => ([k] -> Maybe a -> Maybe b -> Maybe c) -> FM k a -> FM k b -> FM k c
moduleName :: String
instance Ord k => Monoid (FM k a)
instance (Ord k, CoArbitrary k, CoArbitrary a) => CoArbitrary (FM k a)
instance (Ord k, Arbitrary k, Arbitrary a) => Arbitrary (FM k a)
instance (Ord k, Ord a) => Ord (FM k a)
instance (Ord k, Eq a) => Eq (FM k a)
instance (Ord k, Read k, Read a) => Read (FM k a)
instance (Ord k, Show k, Show a) => Show (FM k a)
instance Ord k => Functor (FM k)
instance Ord k => OrdFiniteMap (FM k) [k]
instance Ord k => OrdFiniteMapX (FM k) [k]
instance Ord k => OrdAssoc (FM k) [k]
instance Ord k => OrdAssocX (FM k) [k]
instance Ord k => FiniteMap (FM k) [k]
instance Ord k => FiniteMapX (FM k) [k]
instance Ord k => Assoc (FM k) [k]
instance Ord k => AssocX (FM k) [k]
