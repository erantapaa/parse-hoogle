-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Semirings, ring-like structures used for dynamic programming applications
--   
--   This provides a type class for semirings and implementations of the
--   common semirings used in natural language processing.
@package semiring
@version 0.2

module NLP.Semiring

-- | A <a>Semiring</a> is made up of an additive Monoid and a
--   Multiplicative. It must also satisfy several other algebraic
--   properties checked by quickcheck.
class (Multiplicative a, Monoid a) => Semiring a

-- | A <a>WeightedSemiring</a> also includes a sensical ordering over
--   choices. i.e. out of two choices which is better. This is used for
--   Viterbi selection.
class (Semiring a, Ord a) => WeightedSemiring a

-- | The <a>Weighted</a> type is the main type of WeightedSemiring. It
--   combines scoring semiring with a history semiring.
--   
--   The best example of this is the ViterbiDerivation semiring.
newtype Weighted semi1 semi2
Weighted :: (semi1, semi2) -> Weighted semi1 semi2
instance (Eq semi1, Eq semi2) => Eq (Weighted semi1 semi2)
instance (Show semi1, Show semi2) => Show (Weighted semi1 semi2)
instance (Monoid semi1, Monoid semi2) => Monoid (Weighted semi1 semi2)
instance (Multiplicative semi1, Multiplicative semi2) => Multiplicative (Weighted semi1 semi2)
instance (Semiring semi1, Semiring semi2) => Semiring (Weighted semi1 semi2)
instance (WeightedSemiring a, Eq b, Semiring b) => WeightedSemiring (Weighted a b)
instance (Ord semi1, Eq semi2) => Ord (Weighted semi1 semi2)
instance (Semiring a, Semiring b) => Semiring (a, b)
instance (Multiplicative a, Multiplicative b) => Multiplicative (a, b)

module NLP.Semiring.Boolean
newtype Boolean
Boolean :: Bool -> Boolean
instance Eq Boolean
instance Show Boolean
instance Boolean Boolean
instance Semiring Boolean
instance Monoid Boolean
instance Multiplicative Boolean

module NLP.Semiring.Prob

-- | The <a>Prob</a> semiring keeps track of the likelihood of the known
--   output by keeping track of the probability of all paths.
newtype Prob
Prob :: Double -> Prob
instance Eq Prob
instance Show Prob
instance Num Prob
instance Real Prob
instance Fractional Prob
instance Ord Prob
instance WeightedSemiring Prob
instance Semiring Prob
instance Monoid Prob
instance Multiplicative Prob

module NLP.Semiring.ViterbiNBest
class N a
mkN :: (N a) => a
n :: (N a) => a -> Int

-- | The <a>ViterbiNBest</a> semiring keeps track of the n best scoring
--   path to a known output. This score is determined by a user defined
--   <a>WeightedSemiring</a>.
--   
--   The value of n (the number of of values to rank) is included in the
--   type to prevent combining mismatching values. To create a new n, make
--   a new unary type and an instance of N.
--   
--   <pre>
--   data Ten = Ten  
--   instance N Ten where 
--    mkN = Ten
--    n _ = 10
--   </pre>
data ViterbiNBest n semi
ViterbiNBest :: [semi] -> ViterbiNBest n semi
data Ten
Ten :: Ten
type Viterbi10Best semi = ViterbiNBest Ten semi
instance (Eq semi) => Eq (ViterbiNBest n semi)
instance (Show semi) => Show (ViterbiNBest n semi)
instance N Ten
instance (N n, WeightedSemiring semi, Ord semi) => Semiring (ViterbiNBest n semi)
instance (N n, WeightedSemiring semi, Ord semi) => Monoid (ViterbiNBest n semi)
instance (N n, Ord semi, WeightedSemiring semi) => Multiplicative (ViterbiNBest n semi)

module NLP.Semiring.Viterbi
data One
One :: One
type Viterbi semi = ViterbiNBest One semi
fromViterbi :: (Semiring semi) => Viterbi semi -> semi
instance N One

module NLP.Semiring.Counting

-- | The <a>Counting</a> semiring keeps track of the number of paths or
--   derivations led to a given output.
newtype Counting
Counting :: Integer -> Counting
instance Eq Counting
instance Show Counting
instance Num Counting
instance Ord Counting
instance WeightedSemiring Counting
instance Semiring Counting
instance Monoid Counting
instance Multiplicative Counting

module NLP.Semiring.Derivation

-- | The <a>Derivation</a> semiring keeps track of a single path or
--   derivation that led to the known output. If there are more than one
--   path it discards in favor the lesser path (based on ord). The main
--   purpose of this semiring is to track derivations for
--   ViterbiNBestDerivation. If you want to keep all paths, use
--   <a>MultiDerivation</a>.
--   
--   Derivation takes a Monoid as an argument that describes how to build
--   up paths or more complicated structures.
newtype Derivation m
Derivation :: (Maybe m) -> Derivation m

-- | The <a>MultiDerivation</a> semiring keeps track of a all paths or
--   derivations that led to the known output. This can be useful for
--   debugging output.
--   
--   Keeping all these paths around can be expensive.
--   <a>MultiDerivation</a> leaves open the implementation of the internal
--   path monoid for more compact representations.
newtype MultiDerivation m
MultiDerivation :: (Set m) -> MultiDerivation m
mkDerivation :: (Monoid m) => m -> Derivation m
fromDerivation :: (Monoid m) => Derivation m -> m
instance (Eq m) => Eq (MultiDerivation m)
instance (Show m) => Show (MultiDerivation m)
instance (Ord m) => Ord (MultiDerivation m)
instance (Eq m) => Eq (Derivation m)
instance (Ord m) => Ord (Derivation m)
instance (Ord m, Monoid m, Eq m) => Semiring (MultiDerivation m)
instance (Ord m) => Monoid (MultiDerivation m)
instance (Monoid m, Ord m) => Multiplicative (MultiDerivation m)
instance (Show m) => Show (Derivation m)
instance (Monoid m) => Semiring (Derivation m)
instance Monoid (Derivation m)
instance (Monoid m) => Multiplicative (Derivation m)

module NLP.Semiring.ViterbiNBestDerivation

-- | The <a>ViterbiNBestDerivation</a> is an example of a more complicated
--   semiring built up from smaller components. It keeps track of the top N
--   scoring paths along with their derivations.
--   
--   <pre>
--   type ViterbiNBestDerivation n m = ViterbiNBest n (Weighted Prob (Derivation m))
--   </pre>
type ViterbiNBestDerivation n m = ViterbiNBest n (Weighted Prob (Derivation m))

-- | The <a>ViterbiDerivation</a> is a simpler semiring. It just keeps
--   track of the best scoring path and it's derivation.
--   
--   <pre>
--   type ViterbiDerivation m  = Viterbi (Weighted Prob (Derivation m))
--   </pre>
type ViterbiDerivation m = Viterbi (Weighted Prob (Derivation m))
getBestDerivation :: (Monoid m) => ViterbiDerivation m -> m
getBestScore :: (Monoid m) => ViterbiDerivation m -> Prob
