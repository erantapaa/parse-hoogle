-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Couch DB client library using http-enumerator and aeson
--   
--   This package is a thin wrapper around http-enumerator to access a
--   Couch DB Database, using the aeson package to parse and encode JSON
--   data. http-enumerator, aeson, and attoparsec fit togther so well that
--   this package is mostly just a direct combination of these packages.
--   The single additional feature in this package is an attoparsec parser
--   for views, which allows constant memory processing of view returns.
--   This package is deprecated by
--   <a>http://hackage.haskell.org/package/couchdb-conduit</a>
@package couchdb-enumerator
@version 0.3.7


-- | With the advent of conduits, you are strongly encouraged to use
--   couchdb-conduit
--   <a>http://hackage.haskell.org/package/couchdb-conduit</a> instead of
--   this package. It exports almost the same interface but uses conduits
--   instead of enumerator.
--   
--   This module is a very thin wrapper around
--   <a>Network.HTTP.Enumerator</a> using the aeson package to parse and
--   encode JSON. The Couch DB HTTP API is the best place to learn about
--   how to use this library.
--   <a>http://wiki.apache.org/couchdb/Complete_HTTP_API_Reference</a>
--   
--   <pre>
--   
--   import Control.Monad.IO.Class (liftIO)
--   import Data.Aeson
--   import qualified Data.ByteString.Lazy as BL
--   import Data.ByteString.UTF8 (fromString)
--   import Data.Enumerator (($$), run_)
--   import qualified Data.Enumerator.List as EL
--   import Database.CouchDB.Enumerator
--   
--   testCouch :: IO ()
--   testCouch = runCouch "localhost" 5984 "test" $ do
--      -- Make database if not present
--      couchPutDb ""
--      
--      -- Insert some documents.   Note that the dbname passed to 
--      -- withCouchConnection is prepended to the given path, so this is a put 
--      -- to http://localhost:5984/test/doc1
--      rev1 &lt;- couchPut "doc1" [] $ object [ "foo" .= (3 :: Int), 
--                                            "bar" .= ("abc" :: String) ]
--      rev2 &lt;- couchPut "doc2" [] $ object [ "foo" .= (7 :: Int), 
--                                            "baz" .= (145 :: Int) ]
--   
--      -- Load the document and print it out
--      couchGet "doc1" [] &gt;&gt;= liftIO . BL.putStrLn . encode . Object
--   
--      -- Overwite the document.  We supply the revision, otherwise Couch DB 
--      -- would give an error. (The revision could also have been passed  
--      -- in the query arguments.)
--      rev3 &lt;- couchPut "doc1" [] $ object [ "foo" .= (10 :: Int)
--                                          , "bar" .= ("def" :: String)
--                                          , "_rev" .= rev1 ]
--   
--      -- Create a view
--      couchPut_ "_design/testdesign" [] $ 
--          object [ "language" .= ("javascript" :: String)
--                 , "views"    .= object [ "myview" .= object [ "map" .=
--                      ("function(doc) { emit(doc.foo, doc); }" :: String)
--                      ]]
--                 ]
--   
--      -- Read from the view using couchGet and print it out.
--      couchGet "_design/testdesign/_view/myview" [] &gt;&gt;= 
--              liftIO . BL.putStrLn . encode . Object
--      couchGet "_design/testdesign/_view/myview" 
--              [(fromString "key", Just $ fromString "10")]
--              &gt;&gt;= liftIO . BL.putStrLn . encode . Object
--   
--      -- Read the view using couchView and print it out.
--      run_ $ couchView "testdesign/_view/myview" [] $$
--              EL.foldM (\_ o -&gt; liftIO $ BL.putStrLn $ encode $ Object o) ()
--   
--      -- .. with restrictions and extracting view value
--      run_ $ couchView "testdesign/_view/myview" 
--              [(fromString "key", Just $ fromString "10")] $= extractViewValue $$
--              EL.foldM (\_ o -&gt; liftIO $ BL.putStrLn $ encode $ Object o) ()
--   
--      -- .. and in strict manner
--      v1 &lt;- couchView "testdesign/_view/myview" [] $= extractViewValue
--              EL.consume
--      print v1
--   
--      -- Delete the objects
--      couchDelete "doc1" rev3
--      couchDelete "doc2" rev2
--   
--      -- Delete test database
--      couchDeleteDb ""
--   </pre>
module Database.CouchDB.Enumerator

-- | Represents a connection to a single Couch DB Database.
--   
--   A connection contains a <a>Manager</a> and reuses it for multiple
--   requests, which means a single open HTTP connection to CouchDB will be
--   kept around until the manager is closed (http-enumerator will create
--   more connections if needed, it just keeps only one and closes the
--   rest.) See the Pool section for more information.
--   
--   To access more than one database, the dbname entry can be set to the
--   empty string.
data CouchConnection
CouchConnection :: ByteString -> Int -> Manager -> String -> CouchConnection
host :: CouchConnection -> ByteString
port :: CouchConnection -> Int
manager :: CouchConnection -> Manager
dbname :: CouchConnection -> String

-- | Run a sequence of CouchDB actions.
--   
--   The functions below to access CouchDB require a <a>MonadCouch</a>
--   instance to access the connection information. <a>ReaderT</a> is an
--   instance of <a>MonadCouch</a>, and <i>runCouch</i> runs a sequence of
--   database actions using <a>ReaderT</a>. See the top of this page for an
--   example using <i>runCouch</i>.
--   
--   The main reason to not use <i>runCouch</i> is to obtain more control
--   over connection pooling. Also, if your db code is part of a larger
--   monad, it makes sense to just make the larger monad an instance of
--   <a>MonadCouch</a> and skip the intermediate ReaderT, since then
--   performance is improved by eliminating one monad from the final
--   transformer stack.
--   
--   This function is a combination of <a>withCouchConnection</a> and
--   <a>runReaderT</a>
runCouch :: (MonadIO m, MonadBaseControl IO m) => String -> Int -> String -> ReaderT CouchConnection m a -> m a

-- | Connect to a CouchDB database, call the supplied function, and then
--   close the connection.
--   
--   If you create your own instance of <a>MonadCouch</a> instead of using
--   <a>runCouch</a>, this function will help you create the
--   <a>CouchConnection</a>. On the other hand, if you want to implement
--   connection pooling, you will not be able to use withCouchConnection
--   and must create the connection yourself.
withCouchConnection :: MonadBaseControl IO m => String -> Int -> String -> (CouchConnection -> m a) -> m a

-- | A Couch DB Error. If the error comes from http, the http status code
--   is also given. Non-http errors include things like errors parsing the
--   response.
data CouchError
CouchError :: (Maybe Int) -> String -> CouchError

-- | A monad which allows access to the connection.
class (MonadIO m, MonadBaseControl IO m) => MonadCouch m
couchConnection :: MonadCouch m => m CouchConnection

-- | Create CouchDB database regardless of presence. Roughly equivalent to
--   
--   <pre>
--   couchPut_ "" [] $ object []
--   </pre>
--   
--   but catches <a>CouchError</a> <i>412</i>.
couchPutDb :: MonadCouch m => Path -> m ()

-- | Delete a database.
couchDeleteDb :: MonadCouch m => Path -> m ()

-- | A path to a Couch DB Object.
type Path = String

-- | Represents a revision of a Couch DB Document.
type Revision = Text

-- | Get Revision of a document.
couchRev :: MonadCouch m => Path -> m Revision

-- | Load a single object from couch DB.
couchGet :: MonadCouch m => Path -> Query -> m Object

-- | Put an object in Couch DB, returning the new Revision.
couchPut :: (MonadCouch m, ToJSON a) => Path -> Query -> a -> m Revision

-- | Put an object in Couch DB with revision, returning the new Revision.
couchPutRev :: (MonadCouch m, ToJSON a) => Path -> Revision -> Query -> a -> m Revision

-- | A version of <a>couchPut</a> which ignores the return value. This is
--   slightly faster than <i> _ &lt;- couchPut ...</i> since the JSON
--   parser is not run.
couchPut_ :: (MonadCouch m, ToJSON a) => Path -> Query -> a -> m ()

-- | Delete the given revision of the object.
couchDelete :: MonadCouch m => Path -> Revision -> m ()

-- | Load from a Couch DB View.
--   
--   While you can use <a>couchGet</a> on a view object, this function
--   combines the incredible power of http-enumerator and attoparsec to
--   allow you to process objects in constant space. As data is read from
--   the network, it is fed into attoparsec. When attoparsec completes
--   parsing an object it is sent out the enumerator.
--   
--   The objects enumerated are the entries in the "rows" property of the
--   view result, which means they are not directly the objects you put
--   into the database. See
--   <a>http://wiki.apache.org/couchdb/HTTP_view_API</a> for more
--   information. The objects inserted into the database are available in
--   the "value" entry, and can be extracted with the
--   <a>extractViewValue</a> enumeratee, for example:
--   
--   <pre>
--   couchView "mydesigndoc/_view/myview" 
--       [(fromString "key", Just $ fromString "3")] 
--           $= extractViewValue
--   </pre>
couchView :: MonadCouch m => Path -> Query -> Enumerator Object m a

-- | An enumeratee to extract the "value" member of JSON objects.
--   
--   This is useful to extract the object from the data returned from a
--   view. For example, Couch DB will return objects that look like the
--   following:
--   
--   <pre>
--   { "id":"64ACF01B05F53...", "key":null, "value": { some object } }
--   </pre>
--   
--   and this enumeratee will extract <i>{some object}</i>
extractViewValue :: Monad m => Enumeratee Object Object m a

-- | Simplified version of <a>couch'</a>.
--   
--   Response headers are ignored, and the response status is only used to
--   detect for an error, in which case a <a>CouchError</a> is sent down
--   the <a>Iteratee</a>.
couch :: MonadCouch m => Method -> Path -> Query -> Iteratee ByteString m a -> RequestBody m -> Iteratee ByteString m a

-- | The most general method of accessing CouchDB. This is a very thin
--   wrapper around <a>http</a>. Most of the time you should use one of the
--   other access functions, but this function is needed for example to
--   write and read attachments that are not in JSON format.
--   
--   If CouchDB returns an error, the iteratee passed to this function is
--   not called and instead a <a>CouchError</a> is sent out the Iteratee
--   returned from this function.
couch' :: MonadCouch m => Method -> Path -> RequestHeaders -> Query -> (ResponseHeaders -> Iteratee ByteString m a) -> RequestBody m -> Iteratee ByteString m a
instance Typeable CouchError
instance Show CouchError
instance (MonadIO m, MonadBaseControl IO m) => MonadCouch (ReaderT CouchConnection m)
instance Exception CouchError


-- | A convenient wrapper around <a>Database.CouchDB.Enumerator</a> and
--   <a>Data.Aeson.Generic</a>
--   
--   The aeson library has the ability to encode and decode JSON using the
--   generic Data and Typeable classes via the <a>Data.Aeson.Generic</a>
--   module. It isn't too hard to use <a>fromJSON</a> and <a>toJSON</a>
--   combined with the functions in <a>Database.CouchDB.Enumerator</a>,
--   except that in several cases Couch DB uses system fields <i>_id</i>
--   and <i>_rev</i> which present a small difficulty.
--   
--   For example, Couch DB will return an object like the following
--   
--   <pre>
--   {
--      "_id": "somedoc",
--      "_rev": "11-52b4f9b471de393fab82313b9d8571c1",
--      "foo": 3,
--      "bar": true
--   }
--   </pre>
--   
--   Also, occasionally (not always) the <i>_rev</i> field must be present
--   in an object that is sent to Couch DB during a PUT.
--   
--   The short wrapper functions in this module take care of handling the
--   <i>_id</i> and <i>_rev</i> fields separately from the encoding and
--   decoding to the generic data structure.
--   
--   <pre>
--   import Data.Data (Data, Typeable)
--   import Data.Bytestring (Bytestring)
--   import Database.CouchDB.Enumerator hiding (couchGet, couchPut)
--   import qualified Database.CouchDB.Enumerator.Generic as G
--   
--   data Rec = Rec {
--       field1 :: Int
--     , field2 :: ByteString
--   } deriving (Data, Typeable)
--   
--   testCouch :: IO ()
--   testCouch = runCouch "localhost" 5984 "test" $ do
--      -- Insert doc
--      rev1 &lt;- G.couchPut "doc1" Nothing [] $ Rec 1 "foo"
--      -- Get doc 
--      G.CouchDoc p r doc1 &lt;- G.couchGet "doc1" []
--      -- New revision
--      rev2 &lt;- G.couchPut "doc1" (Just rev1) [] $ Rec 2 "bar"
--   </pre>
module Database.CouchDB.Enumerator.Generic

-- | CouchDB document with path and revision.
data CouchDoc a
CouchDoc :: Path -> Revision -> a -> CouchDoc a

-- | Load a single object from couch DB.
couchGet :: (MonadCouch m, Data a) => Path -> Query -> m (CouchDoc a)

-- | Put an object in Couch DB, returning the new Revision.
couchPut :: (MonadCouch m, Data a) => Path -> Revision -> Query -> a -> m Revision

-- | Brute force version of <a>couchPut</a>. Stores document regardless of
--   presence in database (catches <a>couchRev</a> <a>CouchError</a>
--   <i>404</i>).
--   
--   This version is slower that <a>couchPut</a> because it first tries to
--   find the document revision.
--   
--   Also, there are no guarantees that some other thread or program
--   updated the object (and thus generated a new revision) between loading
--   the existing revision and deleting the object. If this occurs, an
--   error will still be thrown.
couchPut' :: (MonadCouch m, Data a) => Path -> Query -> a -> m Revision

-- | Strictly consumes all view result. Use this if all view data is
--   mandatory and all errors must be handled.
consumeView :: (MonadCouch m, Data a) => Path -> Query -> m [a]

-- | Parse <a>Object</a> from <a>extractViewValue</a>.
parseGeneric :: (Monad m, Data a) => Enumeratee Object a m b
instance Show a => Show (CouchDoc a)
instance FromJSON DocSig
