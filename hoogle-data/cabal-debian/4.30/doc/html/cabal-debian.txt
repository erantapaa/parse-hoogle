-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Create a Debianization for a Cabal package
--   
@package cabal-debian
@version 4.30

module Paths_cabal_debian
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath


-- | A class used while converting Cabal dependencies into Debian
--   dependencies.
module Debian.Debianize.Interspersed

-- | A class of Bs insterspersed with Cs. It is used when converting the
--   cabal dependencies to debian, where the "around" type is the binary
--   package name and the "between" type is the version number.
--   
--   Minimum implementation is a method to return the leftmost B, and
--   another to return the following (C,B) pairs. Its unfortunate to
--   require lists in the implementation, a fold function would be better
--   (though I find implementing such folds to be a pain in the
--   you-know-what.)
--   
--   The class provides implementations of three folds, each of which
--   exposes slightly different views of the data.
class Interspersed t around between | t -> around, t -> between where foldTriples f r0 x = snd $ foldl (\ (b1, r) (c, b2) -> (b1, f b1 c b2 r)) (leftmost x, r0) (pairs x) foldInverted f r0 x = (\ (bn, an, r) -> f bn an Nothing r) $ foldl g (Nothing, leftmost x, r0) (pairs x) where g (b1, a1, r) (b2, a2) = (Just b2, a2, f b1 a1 (Just b2) r) foldArounds f r0 x = snd $ foldl (\ (a1, r) (_, a2) -> (a2, f a1 a2 r)) (leftmost x, r0) (pairs x) foldBetweens f r0 x = foldl (\ r (b, _) -> (f b r)) r0 (pairs x)
leftmost :: Interspersed t around between => t -> around
pairs :: Interspersed t around between => t -> [(between, around)]
foldTriples :: Interspersed t around between => (around -> between -> around -> r -> r) -> r -> t -> r
foldInverted :: Interspersed t around between => (Maybe between -> around -> Maybe between -> r -> r) -> r -> t -> r
foldArounds :: Interspersed t around between => (around -> around -> r -> r) -> r -> t -> r
foldBetweens :: Interspersed t around between => (between -> r -> r) -> r -> t -> r
instance Show Splits
instance Interspersed Splits Double String

module Debian.Debianize.Changelog

-- | Apply a filter to the version numbers of the changelog entries.
filterEntries :: (DebianVersion -> Bool) -> ChangeLog -> ChangeLog

-- | Filter out versions newer than the given one.
dropFutureEntries :: DebianVersion -> ChangeLog -> ChangeLog

-- | Find the log entry with the given version.
findChangelogEntry :: DebianVersion -> ChangeLog -> Maybe ChangeLogEntry
mergeChangelogEntries :: ChangeLogEntry -> ChangeLogEntry -> ChangeLogEntry


-- | Convert between cabal and debian package names based on version number
--   ranges.
module Debian.Debianize.VersionSplits

-- | The base of a debian binary package name, the string that appears
--   between "libghc-" and "-dev".
newtype DebBase
DebBase :: String -> DebBase
unDebBase :: DebBase -> String

-- | Describes a mapping from cabal package name and version to debian
--   package names. For example, versions of the cabal QuickCheck package
--   less than 2 are mapped to "quickcheck1", while version 2 or greater is
--   mapped to "quickcheck2".
data VersionSplits

-- | Create a version split database that assigns a single debian package
--   name base to all cabal versions.
makePackage :: DebBase -> VersionSplits

-- | Split the version range and give the older packages a new name.
insertSplit :: Version -> DebBase -> VersionSplits -> VersionSplits

-- | Brute force implementation - I'm assuming this is not a huge map.
cabalFromDebian :: Map PackageName VersionSplits -> DebBase -> DebianVersion -> PackageName
cabalFromDebian' :: Map PackageName VersionSplits -> DebBase -> Version -> PackageIdentifier
debianFromCabal :: VersionSplits -> PackageIdentifier -> DebBase
packageRangesFromVersionSplits :: VersionSplits -> [(DebBase, VersionRange)]

-- | Given a version split database, turn the debian version requirements
--   into a debian package name base that ought to satisfy them.
doSplits :: VersionSplits -> Maybe VersionReq -> DebBase
instance Typeable DebBase
instance Typeable VersionSplits
instance Eq DebBase
instance Ord DebBase
instance Read DebBase
instance Show DebBase
instance Data DebBase
instance Eq VersionSplits
instance Ord VersionSplits
instance Data VersionSplits
instance Interspersed VersionSplits DebBase Version
instance Show VersionSplits

module Distribution.Version.Invert

-- | This function belongs in Cabal, see
--   <a>http://hackage.haskell.org/trac/hackage/ticket/935</a>.
invertVersionRange :: VersionRange -> VersionRange
invertVersionIntervals :: [(LowerBound, UpperBound)] -> [(LowerBound, UpperBound)]


-- | Functions and instances used by but not related to cabal-debian. These
--   could conceivably be moved into more general libraries.
module Debian.Debianize.Prelude
curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
type DebMap = Map BinPkgName (Maybe DebianVersion)

-- | Read and parse the status file for installed debian packages:
--   <tt><i>var</i>lib<i>dpkg</i>status</tt>
buildDebVersionMap :: IO DebMap
(!) :: DebMap -> BinPkgName -> DebianVersion
strip :: String -> String
stripWith :: (a -> Bool) -> [a] -> [a]
strictReadF :: (Text -> r) -> FilePath -> IO r

-- | Write a file which we might still be reading from in order to compute
--   the text argument.
replaceFile :: FilePath -> String -> IO ()

-- | Compute the new file contents from the old. If f returns Nothing do
--   not write.
modifyFile :: FilePath -> (String -> IO (Maybe String)) -> IO ()
diffFile :: FilePath -> Text -> IO (Maybe String)
removeIfExists :: FilePath -> IO ()

-- | Create a map from pathname to the names of the packages that contains
--   that pathname using the contents of the debian package info directory
--   <tt><i>var</i>lib<i>dpkg</i>info</tt>.
dpkgFileMap :: IO (Map FilePath (Set BinPkgName))

-- | Given a path, return the name of the package that owns it.
debOfFile :: FilePath -> ReaderT (Map FilePath (Set BinPkgName)) IO (Maybe BinPkgName)
cond :: t -> t -> Bool -> t
readFile' :: FilePath -> IO Text
readFileMaybe :: FilePath -> IO (Maybe Text)
showDeps :: Relations -> String
showDeps' :: Relations -> String

-- | From Darcs.Utils - set the working directory and run an IO operation.
withCurrentDirectory :: FilePath -> IO a -> IO a

-- | Get directory contents minus dot files.
getDirectoryContents' :: FilePath -> IO [FilePath]
setMapMaybe :: (Ord a, Ord b) => (a -> Maybe b) -> Set a -> Set b
zipMaps :: Ord k => (k -> Maybe a -> Maybe b -> Maybe c) -> Map k a -> Map k b -> Map k c
foldEmpty :: r -> ([a] -> r) -> [a] -> r

-- | If the current value of view x is Nothing, replace it with f.
maybeL :: Lens' a (Maybe b) -> Maybe b -> a -> a
indent :: [Char] -> String -> String
maybeRead :: Read a => String -> Maybe a
read' :: Read a => (String -> a) -> String -> a
modifyM :: MonadState a m => (a -> m a) -> m ()

-- | Version of <a>intToVerbosity</a> that first clamps its argument to the
--   acceptable range (0-3).
intToVerbosity' :: Int -> Verbosity
listElemLens :: (a -> Bool) -> Lens' [a] (Maybe a)
maybeLens :: a -> Lens' a b -> Lens' (Maybe a) b
fromEmpty :: Set a -> Set a -> Set a
fromSingleton :: a -> ([a] -> a) -> Set a -> a

-- | Set <tt>b</tt> if it currently isNothing and the argument isJust, that
--   is 1. Nothing happens if the argument isNothing 2. Nothing happens if
--   the current value isJust
(.?=) :: Monad m => Lens' a (Maybe b) -> Maybe b -> StateT a m ()

-- | This should probably be used in a lot of places.
escapeDebianWildcards :: String -> String
instance Pretty (PP PackageName)
instance Pretty (PP PackageIdentifier)


-- | The basic information required to load a Cabal or Debian package
--   description.
module Debian.Debianize.BasicInfo

-- | This record supplies enough information to locate and load a
--   debianization or a cabal file from the IO monad.
data Flags
Flags :: Int -> Bool -> Bool -> CompilerFlavor -> Set (FlagName, Bool) -> EnvSet -> Flags

-- | Run with progress messages at the given level of verboseness.
_verbosity :: Flags -> Int

-- | Don't write any files or create any directories, just explain what
--   would have been done.
_dryRun :: Flags -> Bool

-- | Fail if the debianization already present doesn't match the one we are
--   going to generate closely enough that it is safe to debianize during
--   the run of dpkg-buildpackage, when Setup configure is run.
--   Specifically, the version number in the top changelog entry must
--   match, and the sets of package names in the control file must match.
_validate :: Flags -> Bool

-- | Which compiler should we generate library packages for? In theory a
--   single deb could handle multiple compiler flavors, but the support
--   tools are not ready for this as of right now (28 Jan 2015.)
_compilerFlavor :: Flags -> CompilerFlavor

-- | Flags to pass to Cabal function finalizePackageDescription, this can
--   be used to control the flags in the cabal file. It can be supplied to
--   the cabal-debian binary using the --flags option.
_cabalFlagAssignments :: Flags -> Set (FlagName, Bool)

-- | Directory containing the build environment for which the debianization
--   will be generated. This determines which compiler will be available,
--   which in turn determines which basic libraries can be provided by the
--   compiler. By default all the paths in EnvSet are "/".
_buildEnv :: Flags -> EnvSet
data EnvSet
EnvSet :: FilePath -> FilePath -> FilePath -> EnvSet

-- | The output of the debootstrap command
cleanOS :: EnvSet -> FilePath

-- | An environment with build dependencies installed
dependOS :: EnvSet -> FilePath

-- | An environment where we have built a package
buildOS :: EnvSet -> FilePath

-- | A redundant data type, too lazy to expunge.
data DebType
Dev :: DebType
Prof :: DebType
Doc :: DebType
verbosity :: Lens' Flags Int
dryRun :: Lens' Flags Bool
validate :: Lens' Flags Bool
compilerFlavor :: Lens' Flags CompilerFlavor
cabalFlagAssignments :: Lens' Flags (Set (FlagName, Bool))
buildEnv :: Lens' Flags EnvSet

-- | Command line options which build a function that modifies a state
--   monad value of type <a>Flags</a>
flagOptions :: MonadIO m => [OptDescr (StateT Flags m ())]
instance Typeable EnvSet
instance Typeable Flags
instance Typeable DebType
instance Eq EnvSet
instance Ord EnvSet
instance Show EnvSet
instance Data EnvSet
instance Eq Flags
instance Ord Flags
instance Show Flags
instance Data Flags
instance Eq DebType
instance Ord DebType
instance Read DebType
instance Show DebType
instance Data DebType


-- | Code pulled out of cabal-debian that straightforwardly implements
--   parts of the Debian policy manual, or other bits of Linux standards.
module Debian.Policy
databaseDirectory :: BinPkgName -> String
dataDirectory :: PackageDescription -> String
apacheLogDirectory :: BinPkgName -> String
apacheErrorLog :: BinPkgName -> String
apacheAccessLog :: BinPkgName -> String
serverLogDirectory :: BinPkgName -> String
serverAppLog :: BinPkgName -> String
serverAccessLog :: BinPkgName -> String
errorLogBaseName :: String
appLogBaseName :: String
accessLogBaseName :: String
debianPackageVersion :: String -> IO (Maybe DebianVersion)

-- | The version number of the installed debhelper package is the highest
--   acceptable value for compat in a debian/control file. If the package
--   doesn't explicitly set an (acceptable) compat value we can use the
--   value returned by this function, assuming debhelper is installed.
getDebhelperCompatLevel :: IO (Maybe Int)
data StandardsVersion
StandardsVersion :: Int -> Int -> Int -> (Maybe Int) -> StandardsVersion

-- | Assumes debian-policy is installed
getDebianStandardsVersion :: IO (Maybe StandardsVersion)
parseStandardsVersion :: String -> StandardsVersion
data SourceFormat
Native3 :: SourceFormat
Quilt3 :: SourceFormat
readSourceFormat :: Text -> Either Text SourceFormat
data PackagePriority
Required :: PackagePriority
Important :: PackagePriority
Standard :: PackagePriority
Optional :: PackagePriority
Extra :: PackagePriority
readPriority :: String -> PackagePriority

-- | The architectures for which a binary deb can be built.
data PackageArchitectures

-- | The package is architecture independenct
All :: PackageArchitectures

-- | The package can be built for any architecture
Any :: PackageArchitectures

-- | The list of suitable architectures
Names :: [String] -> PackageArchitectures
parsePackageArchitectures :: String -> PackageArchitectures
data Section
MainSection :: String -> Section
AreaSection :: Area -> String -> Section
readSection :: String -> Section
data Area
Main :: Area
Contrib :: Area
NonFree :: Area

-- | Turn the uploaders field of a cabal package into a list of RFC2822
--   NameAddr values.
parseUploaders :: String -> Either String [NameAddr]

-- | Parse a string containing a single NameAddr value.
parseMaintainer :: String -> Either String NameAddr

-- | Maintainer is a mandatory field, so we need a value we can use when
--   all else fails.
maintainerOfLastResort :: NameAddr
getCurrentDebianUser :: IO (Maybe NameAddr)
haskellMaintainer :: NameAddr

-- | Official Debian license types as described in
--   <a>https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/#license-specification</a>.
data License

-- | No license required for any purpose; the work is not subject to
--   copyright in any jurisdiction.
Public_Domain :: License

-- | Apache license 1.0, 2.0.
Apache :: License

-- | Artistic license 1.0, 2.0.
Artistic :: License

-- | Berkeley software distribution license, 2-clause version.
BSD_2_Clause :: License

-- | Berkeley software distribution license, 3-clause version.
BSD_3_Clause :: License

-- | Berkeley software distribution license, 4-clause version.
BSD_4_Clause :: License

-- | Internet Software Consortium, sometimes also known as the OpenBSD
--   License.
ISC :: License

-- | Creative Commons Attribution license 1.0, 2.0, 2.5, 3.0.
CC_BY :: License

-- | Creative Commons Attribution Share Alike license 1.0, 2.0, 2.5, 3.0.
CC_BY_SA :: License

-- | Creative Commons Attribution No Derivatives license 1.0, 2.0, 2.5,
--   3.0.
CC_BY_ND :: License

-- | Creative Commons Attribution Non-Commercial license 1.0, 2.0, 2.5,
--   3.0.
CC_BY_NC :: License

-- | Creative Commons Attribution Non-Commercial Share Alike license 1.0,
--   2.0, 2.5, 3.0.
CC_BY_NC_SA :: License

-- | Creative Commons Attribution Non-Commercial No Derivatives license
--   1.0, 2.0, 2.5, 3.0.
CC_BY_NC_ND :: License

-- | Creative Commons Zero 1.0 Universal. Omit <a>Universal</a> from the
--   license version when forming the short name.
CC0 :: License

-- | Common Development and Distribution License 1.0.
CDDL :: License

-- | IBM Common Public License.
CPL :: License

-- | The Eiffel Forum License 1.0, 2.0.
EFL :: License

-- | The Expat license.
Expat :: License

-- | GNU General Public License 1.0, 2.0, 3.0.
GPL :: License

-- | GNU Lesser General Public License 2.1, 3.0, or GNU Library General
--   Public License 2.0.
LGPL :: License

-- | GNU Free Documentation License 1.0, 1.1, 1.2, or 1.3. Use GFDL-NIV
--   instead if there are no Front-Cover or Back-Cover Texts or Invariant
--   Sections.
GFDL :: License

-- | GNU Free Documentation License, with no Front-Cover or Back-Cover
--   Texts or Invariant Sections. Use the same version numbers as GFDL.
GFDL_NIV :: License

-- | LaTeX Project Public License 1.0, 1.1, 1.2, 1.3c.
LPPL :: License

-- | Mozilla Public License 1.1.
MPL :: License

-- | erl license (use "GPL-1+ or Artistic-1" instead)
Perl :: License

-- | Python license 2.0.
Python :: License

-- | Q Public License 1.0.
QPL :: License

-- | W3C Software License For more information, consult the W3C
--   Intellectual Rights FAQ.
W3C :: License

-- | zlib/libpng license.
Zlib :: License

-- | Zope Public License 1.0, 1.1, 2.0, 2.1.
Zope :: License

-- | A license name associated with the subsequent text of the License:
--   field or in a Files paragraph of the same debian/copyright file, or in
--   a License: paragraph.
OtherLicense :: String -> License

-- | Convert the Cabal license to a Debian license. I would welcome input
--   on how to make this more correct.
fromCabalLicense :: License -> License

-- | Convert a Debian license to a Cabal license. Additional cases and
--   corrections welcome.
toCabalLicense :: License -> License

-- | I think we need an actual parser for license names.
readLicense :: Text -> License
instance Typeable StandardsVersion
instance Typeable SourceFormat
instance Typeable PackagePriority
instance Typeable PackageArchitectures
instance Typeable Area
instance Typeable Section
instance Typeable License
instance Eq StandardsVersion
instance Ord StandardsVersion
instance Show StandardsVersion
instance Data StandardsVersion
instance Eq SourceFormat
instance Ord SourceFormat
instance Show SourceFormat
instance Data SourceFormat
instance Eq PackagePriority
instance Ord PackagePriority
instance Read PackagePriority
instance Show PackagePriority
instance Data PackagePriority
instance Read PackageArchitectures
instance Eq PackageArchitectures
instance Ord PackageArchitectures
instance Show PackageArchitectures
instance Data PackageArchitectures
instance Read Area
instance Eq Area
instance Ord Area
instance Show Area
instance Data Area
instance Read Section
instance Eq Section
instance Ord Section
instance Show Section
instance Data Section
instance Read License
instance Show License
instance Eq License
instance Ord License
instance Data License
instance Pretty License
instance Pretty (PP Area)
instance Pretty (PP Section)
instance Pretty (PP PackageArchitectures)
instance Pretty (PP PackagePriority)
instance Pretty (PP SourceFormat)
instance Pretty (PP StandardsVersion)

module Debian.Debianize.BinaryDebDescription
class Canonical a
canonical :: Canonical a => a -> a

-- | This type represents a section of the control file other than the
--   first, which in turn represent one of the binary packages or debs
--   produced by this debianization.
--   
--   The different types of binary debs we can produce from a haskell
--   package
data BinaryDebDescription
newBinaryDebDescription :: BinPkgName -> BinaryDebDescription
package :: Lens' BinaryDebDescription BinPkgName
description :: Lens' BinaryDebDescription (Maybe Text)
packageType :: Lens' BinaryDebDescription (Maybe PackageType)
architecture :: Lens' BinaryDebDescription (Maybe PackageArchitectures)
binarySection :: Lens' BinaryDebDescription (Maybe Section)
binaryPriority :: Lens' BinaryDebDescription (Maybe PackagePriority)
essential :: Lens' BinaryDebDescription (Maybe Bool)
relations :: Lens' BinaryDebDescription PackageRelations

-- | Package interrelationship information.
data PackageType

-- | The libghc-foo-dev package.
Development :: PackageType

-- | The libghc-foo-prof package.
Profiling :: PackageType

-- | The libghc-foo-doc package.
Documentation :: PackageType

-- | A package related to a particular executable, perhaps but not
--   necessarily a server.
Exec :: PackageType

-- | A package that holds the package's data files and any executables not
--   assigned to other packages.
Utilities :: PackageType

-- | The source package (not a binary deb actually.)
Source :: PackageType

-- | The source package of a haskell library (add prefix haskell- to source
--   package name.)
HaskellSource :: PackageType

-- | This is used to construct the value for DEB_CABAL_PACKAGE in the rules
--   file
Cabal :: PackageType
data PackageRelations
newPackageRelations :: PackageRelations
depends :: Lens' PackageRelations Relations
recommends :: Lens' PackageRelations Relations
suggests :: Lens' PackageRelations Relations
preDepends :: Lens' PackageRelations Relations
breaks :: Lens' PackageRelations Relations
conflicts :: Lens' PackageRelations Relations
provides :: Lens' PackageRelations Relations
replaces :: Lens' PackageRelations Relations
builtUsing :: Lens' PackageRelations Relations
instance Typeable PackageType
instance Typeable PackageRelations
instance Typeable BinaryDebDescription
instance Eq PackageType
instance Ord PackageType
instance Show PackageType
instance Read PackageType
instance Data PackageType
instance Eq PackageRelations
instance Ord PackageRelations
instance Read PackageRelations
instance Show PackageRelations
instance Data PackageRelations
instance Eq BinaryDebDescription
instance Ord BinaryDebDescription
instance Read BinaryDebDescription
instance Show BinaryDebDescription
instance Data BinaryDebDescription
instance Canonical Relations
instance Canonical PackageRelations
instance Canonical BinaryDebDescription
instance Canonical [BinaryDebDescription]

module Debian.Debianize.SourceDebDescription

-- | This type represents the debian/control file, which is the core of the
--   source package debianization. It includes the information that goes in
--   the first, or source, section, and then a list of the succeeding
--   binary package sections.
data SourceDebDescription
newSourceDebDescription :: SourceDebDescription
newSourceDebDescription' :: SrcPkgName -> NameAddr -> SourceDebDescription
source :: Lens' SourceDebDescription (Maybe SrcPkgName)
maintainer :: Lens' SourceDebDescription (Either String NameAddr)
changedBy :: Lens' SourceDebDescription (Maybe NameAddr)
uploaders :: Lens' SourceDebDescription [NameAddr]
dmUploadAllowed :: Lens' SourceDebDescription Bool
priority :: Lens' SourceDebDescription (Maybe PackagePriority)
section :: Lens' SourceDebDescription (Maybe Section)
buildDepends :: Lens' SourceDebDescription Relations
buildConflicts :: Lens' SourceDebDescription Relations
buildDependsIndep :: Lens' SourceDebDescription Relations
buildConflictsIndep :: Lens' SourceDebDescription Relations
standardsVersion :: Lens' SourceDebDescription (Maybe StandardsVersion)
homepage :: Lens' SourceDebDescription (Maybe Text)
vcsFields :: Lens' SourceDebDescription (Set VersionControlSpec)
xFields :: Lens' SourceDebDescription (Set XField)
xDescription :: Lens' SourceDebDescription (Maybe Text)
binaryPackages :: Lens' SourceDebDescription [BinaryDebDescription]
data VersionControlSpec
VCSBrowser :: Text -> VersionControlSpec
VCSArch :: Text -> VersionControlSpec
VCSBzr :: Text -> VersionControlSpec
VCSCvs :: Text -> VersionControlSpec
VCSDarcs :: Text -> VersionControlSpec
VCSGit :: Text -> VersionControlSpec
VCSHg :: Text -> VersionControlSpec
VCSMtn :: Text -> VersionControlSpec
VCSSvn :: Text -> VersionControlSpec

-- | User defined fields. Parse the line "XBS-Comment: I stand between the
--   candle and the star." to get XField (fromList <a>BS</a>)
--   <a>Comment</a> " I stand between the candle and the star."
data XField
XField :: (Set XFieldDest) -> Text -> Text -> XField
data XFieldDest

-- | Field will be copied to the binary packgae control files
B :: XFieldDest

-- | Field will be copied to the source packgae control files
S :: XFieldDest

-- | Field will be copied to the upload control (.changes) file
C :: XFieldDest
instance Typeable VersionControlSpec
instance Typeable XFieldDest
instance Typeable XField
instance Typeable SourceDebDescription
instance Eq VersionControlSpec
instance Ord VersionControlSpec
instance Show VersionControlSpec
instance Data VersionControlSpec
instance Eq XFieldDest
instance Ord XFieldDest
instance Read XFieldDest
instance Show XFieldDest
instance Data XFieldDest
instance Eq XField
instance Ord XField
instance Show XField
instance Data XField
instance Eq SourceDebDescription
instance Ord SourceDebDescription
instance Show SourceDebDescription
instance Data SourceDebDescription
instance Canonical SourceDebDescription

module Debian.GHC
withCompilerVersion :: FilePath -> CompilerFlavor -> (DebianVersion -> a) -> a

-- | Memoized version of newestAvailable'
newestAvailable :: FilePath -> BinPkgName -> Maybe DebianVersion
compilerIdFromDebianVersion :: CompilerFlavor -> DebianVersion -> CompilerId

-- | General function to build a command line option that reads most of the
--   possible values for CompilerFlavor.
compilerFlavorOption :: (CompilerFlavor -> a -> a) -> OptDescr (a -> a)
newestAvailableCompilerId :: FilePath -> CompilerFlavor -> CompilerId
compilerPackageName :: CompilerFlavor -> PackageType -> BinPkgName
instance Memoizable BinPkgName
instance Memoizable CompilerFlavor


-- | Input the Cabal package description.
module Debian.Debianize.InputCabal

-- | Load a PackageDescription using the information in the Flags record -
--   in particular, using the dependency environment in the EnvSet, find
--   the newest available compiler of the requested compiler flavor and use
--   that information load the configured PackageDescription.
inputCabalization :: MonadIO m => Flags -> WithProcAndSys m PackageDescription


-- | Determine whether a specific version of a Haskell package is bundled
--   with into this particular version of the given compiler.
module Debian.Debianize.Bundled

-- | Find out what version, if any, of a cabal library is built into the
--   newest version of haskell compiler hc in environment root. For GHC
--   this is done by looking at what virtual packages debian package
--   provides. I have modified the ghcjs packaging to generate the required
--   virtual packages in the Provides line. For other compilers it maybe be
--   unimplemented.
builtIn :: Map PackageName VersionSplits -> CompilerFlavor -> FilePath -> PackageName -> Maybe Version
aptCacheShowPkg :: FilePath -> String -> Either SomeException String
aptCacheProvides :: FilePath -> String -> [(DebianVersion, [BinPkgName])]
aptCacheDepends :: FilePath -> String -> String -> Either SomeException String
aptCacheConflicts :: FilePath -> String -> DebianVersion -> [BinPkgName]
aptVersions :: FilePath -> String -> [DebianVersion]

module Data.Maybe.Extended
nothingIf :: (a -> Bool) -> a -> Maybe a


-- | 
--   <a>https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/</a>
module Debian.Debianize.CopyrightDescription

-- | Description of the machine readable debian/copyright file. A special
--   case is used to represeent the old style free format file - if the
--   value is equal to newCopyrightDescription except for the field
--   _summaryComment, the text in _summaryComment is the copyright file.
data CopyrightDescription
CopyrightDescription :: URI -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe License -> Maybe Text -> [FilesOrLicenseDescription] -> CopyrightDescription
_format :: CopyrightDescription -> URI
_upstreamName :: CopyrightDescription -> Maybe Text
_upstreamContact :: CopyrightDescription -> Maybe Text
_upstreamSource :: CopyrightDescription -> Maybe Text
_disclaimer :: CopyrightDescription -> Maybe Text
_summaryComment :: CopyrightDescription -> Maybe Text
_summaryLicense :: CopyrightDescription -> Maybe License
_summaryCopyright :: CopyrightDescription -> Maybe Text
_filesAndLicenses :: CopyrightDescription -> [FilesOrLicenseDescription]
data FilesOrLicenseDescription
FilesDescription :: FilePath -> Text -> License -> Maybe Text -> FilesOrLicenseDescription
_filesPattern :: FilesOrLicenseDescription -> FilePath
_filesCopyright :: FilesOrLicenseDescription -> Text
_filesLicense :: FilesOrLicenseDescription -> License
_filesComment :: FilesOrLicenseDescription -> Maybe Text
LicenseDescription :: License -> Maybe Text -> FilesOrLicenseDescription
_license :: FilesOrLicenseDescription -> License
_comment :: FilesOrLicenseDescription -> Maybe Text
format :: Lens' CopyrightDescription URI
upstreamName :: Lens' CopyrightDescription (Maybe Text)
upstreamContact :: Lens' CopyrightDescription (Maybe Text)
upstreamSource :: Lens' CopyrightDescription (Maybe Text)
disclaimer :: Lens' CopyrightDescription (Maybe Text)
summaryComment :: Lens' CopyrightDescription (Maybe Text)
summaryLicense :: Lens' CopyrightDescription (Maybe License)
summaryCopyright :: Lens' CopyrightDescription (Maybe Text)
filesAndLicenses :: Lens' CopyrightDescription [FilesOrLicenseDescription]
filesPattern :: Traversal' FilesOrLicenseDescription FilePath
filesCopyright :: Traversal' FilesOrLicenseDescription Text
filesLicense :: Traversal' FilesOrLicenseDescription License
filesComment :: Traversal' FilesOrLicenseDescription (Maybe Text)
license :: Traversal' FilesOrLicenseDescription License
comment :: Traversal' FilesOrLicenseDescription (Maybe Text)

-- | Read a <a>CopyrightDescription</a> from the text one might obtain from
--   a <tt>debian/copyright</tt> file.
readCopyrightDescription :: Text -> CopyrightDescription

-- | Try to parse a structured copyright file
parseCopyrightDescription :: [Paragraph' Text] -> Maybe CopyrightDescription

-- | Infer a <a>CopyrightDescription</a> from a Cabal package description.
--   This will try to read any copyright files listed in the cabal
--   configuration. Inputs include the license field from the cabal file,
--   the contents of the license files mentioned there, and the provided
--   <tt>copyright0</tt> value.
defaultCopyrightDescription :: PackageDescription -> IO CopyrightDescription
instance Typeable FilesOrLicenseDescription
instance Typeable CopyrightDescription
instance Eq FilesOrLicenseDescription
instance Ord FilesOrLicenseDescription
instance Show FilesOrLicenseDescription
instance Data FilesOrLicenseDescription
instance Eq CopyrightDescription
instance Ord CopyrightDescription
instance Show CopyrightDescription
instance Data CopyrightDescription
instance Default CopyrightDescription
instance Pretty CopyrightDescription


-- | This module holds a long list of lenses that access the Atoms record,
--   the record that holds the input data from which the debianization is
--   to be constructed.
module Debian.Debianize.DebInfo

-- | Information required to represent a non-cabal debianization.
data DebInfo
data Atom

-- | Create a symbolic link in the binary package
Link :: BinPkgName -> FilePath -> FilePath -> Atom

-- | Install a build file into the binary package
Install :: BinPkgName -> FilePath -> FilePath -> Atom

-- | Install a build file into the binary package at an exact location
InstallTo :: BinPkgName -> FilePath -> FilePath -> Atom

-- | DHInstallTo somewhere relative to DataDir (see above)
InstallData :: BinPkgName -> FilePath -> FilePath -> Atom

-- | Create a file with the given text at the given path
File :: BinPkgName -> FilePath -> Text -> Atom

-- | Install a cabal executable into the binary package
InstallCabalExec :: BinPkgName -> String -> FilePath -> Atom

-- | Install a cabal executable into the binary package at an exact
--   location
InstallCabalExecTo :: BinPkgName -> String -> FilePath -> Atom

-- | Create a directory in the binary package
InstallDir :: BinPkgName -> FilePath -> Atom

-- | Information about the web site we are packaging.
data Site
Site :: String -> String -> Server -> Site

-- | The domain name assigned to the server. An apache configuration will
--   be generated to redirect requests from this domain to hostname:port
domain :: Site -> String

-- | Apache ServerAdmin parameter
serverAdmin :: Site -> String

-- | The hint to install the server job
server :: Site -> Server

-- | Information about the server we are packaging.
data Server
Server :: String -> Int -> String -> String -> [String] -> InstallFile -> Server

-- | Host on which the server will run
hostname :: Server -> String

-- | Port on which the server will run. Obviously, this must assign each
--   and every server package to a different port.
port :: Server -> Int

-- | A comment that will be inserted to explain how the file was generated
headerMessage :: Server -> String

-- | start-stop-daemon --retry argument
retry :: Server -> String

-- | Extra flags to pass to the server via the init script
serverFlags :: Server -> [String]

-- | The hint to install the server executable
installFile :: Server -> InstallFile
data InstallFile
InstallFile :: String -> Maybe FilePath -> Maybe FilePath -> String -> InstallFile

-- | The name of the executable file
execName :: InstallFile -> String

-- | where to find it, default is dist<i>build</i><a>execName</a>/
sourceDir :: InstallFile -> Maybe FilePath

-- | where to put it, default is usr<i>bin</i><a>execName</a>
destDir :: InstallFile -> Maybe FilePath

-- | name to give installed executable
destName :: InstallFile -> String
data TestsStatus
TestsDisable :: TestsStatus
TestsBuild :: TestsStatus
TestsRun :: TestsStatus
flags :: Lens' DebInfo Flags
warning :: Lens' DebInfo (Set Text)
sourceFormat :: Lens' DebInfo SourceFormat
watch :: Lens' DebInfo (Maybe Text)
rulesHead :: Lens' DebInfo (Maybe Text)
rulesSettings :: Lens' DebInfo [Text]
rulesIncludes :: Lens' DebInfo [Text]
rulesFragments :: Lens' DebInfo (Set Text)
copyright :: Lens' DebInfo (Maybe CopyrightDescription)
control :: Lens' DebInfo SourceDebDescription
intermediateFiles :: Lens' DebInfo (Set (FilePath, Text))
compat :: Lens' DebInfo (Maybe Int)
changelog :: Lens' DebInfo (Maybe ChangeLog)
installInit :: Lens' DebInfo (Map BinPkgName Text)
logrotateStanza :: Lens' DebInfo (Map BinPkgName (Set Text))
postInst :: Lens' DebInfo (Map BinPkgName Text)
postRm :: Lens' DebInfo (Map BinPkgName Text)
preInst :: Lens' DebInfo (Map BinPkgName Text)
preRm :: Lens' DebInfo (Map BinPkgName Text)
atomSet :: Lens' DebInfo (Set Atom)
noDocumentationLibrary :: Lens' DebInfo Bool
noProfilingLibrary :: Lens' DebInfo Bool
omitProfVersionDeps :: Lens' DebInfo Bool
omitLTDeps :: Lens' DebInfo Bool
buildDir :: Lens' DebInfo (Maybe FilePath)
sourcePackageName :: Lens' DebInfo (Maybe SrcPkgName)
overrideDebianNameBase :: Lens' DebInfo (Maybe DebBase)
revision :: Lens' DebInfo (Maybe String)
debVersion :: Lens' DebInfo (Maybe DebianVersion)
maintainerOption :: Lens' DebInfo (Maybe NameAddr)
uploadersOption :: Lens' DebInfo [NameAddr]
utilsPackageNameBase :: Lens' DebInfo (Maybe String)
xDescriptionText :: Lens' DebInfo (Maybe Text)
comments :: Lens' DebInfo (Maybe [[Text]])
missingDependencies :: Lens' DebInfo (Set BinPkgName)
extraLibMap :: Lens' DebInfo (Map String Relations)
execMap :: Lens' DebInfo (Map String Relations)
apacheSite :: Lens' DebInfo (Map BinPkgName (String, FilePath, Text))
sourceArchitectures :: Lens' DebInfo (Maybe PackageArchitectures)
binaryArchitectures :: Lens' DebInfo (Map BinPkgName PackageArchitectures)
sourcePriority :: Lens' DebInfo (Maybe PackagePriority)
binaryPriorities :: Lens' DebInfo (Map BinPkgName PackagePriority)
sourceSection :: Lens' DebInfo (Maybe Section)
binarySections :: Lens' DebInfo (Map BinPkgName Section)
executable :: Lens' DebInfo (Map BinPkgName InstallFile)
serverInfo :: Lens' DebInfo (Map BinPkgName Server)
website :: Lens' DebInfo (Map BinPkgName Site)
backups :: Lens' DebInfo (Map BinPkgName String)
extraDevDeps :: Lens' DebInfo Relations
official :: Lens' DebInfo Bool
testsStatus :: Lens' DebInfo TestsStatus
allowDebianSelfBuildDeps :: Lens' DebInfo Bool

-- | Lens to look up the binary deb description by name and create it if
--   absent.
--   <a>http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Package</a>
binaryDebDescription :: BinPkgName -> Lens' DebInfo BinaryDebDescription
link :: Monad m => BinPkgName -> FilePath -> FilePath -> StateT DebInfo m ()
install :: Monad m => BinPkgName -> FilePath -> FilePath -> StateT DebInfo m ()
installTo :: Monad m => BinPkgName -> FilePath -> FilePath -> StateT DebInfo m ()
installData :: Monad m => BinPkgName -> FilePath -> FilePath -> StateT DebInfo m ()
file :: Monad m => BinPkgName -> FilePath -> Text -> StateT DebInfo m ()
installCabalExec :: Monad m => BinPkgName -> String -> FilePath -> StateT DebInfo m ()
installCabalExecTo :: Monad m => BinPkgName -> String -> FilePath -> StateT DebInfo m ()
installDir :: Monad m => BinPkgName -> FilePath -> StateT DebInfo m ()
makeDebInfo :: Flags -> DebInfo
instance Typeable Atom
instance Typeable InstallFile
instance Typeable Server
instance Typeable Site
instance Typeable TestsStatus
instance Typeable DebInfo
instance Show Atom
instance Eq Atom
instance Ord Atom
instance Data Atom
instance Read InstallFile
instance Show InstallFile
instance Eq InstallFile
instance Ord InstallFile
instance Data InstallFile
instance Read Server
instance Show Server
instance Eq Server
instance Ord Server
instance Data Server
instance Read Site
instance Show Site
instance Eq Site
instance Ord Site
instance Data Site
instance Eq TestsStatus
instance Show TestsStatus
instance Data TestsStatus
instance Show DebInfo
instance Data DebInfo
instance Canonical DebInfo

module Debian.Debianize.CabalInfo

-- | Bits and pieces of information about the mapping from cabal package
--   names and versions to debian package names and versions. In essence,
--   an <tt>Atoms</tt> value represents a package's debianization. The
--   lenses in this module are used to get and set the values hidden in
--   this Atoms value. Many of the values should be left alone to be set
--   when the debianization is finalized.
data CabalInfo
data PackageInfo
PackageInfo :: PackageName -> Maybe (BinPkgName, DebianVersion) -> Maybe (BinPkgName, DebianVersion) -> Maybe (BinPkgName, DebianVersion) -> PackageInfo
cabalName :: PackageInfo -> PackageName
devDeb :: PackageInfo -> Maybe (BinPkgName, DebianVersion)
profDeb :: PackageInfo -> Maybe (BinPkgName, DebianVersion)
docDeb :: PackageInfo -> Maybe (BinPkgName, DebianVersion)
packageDescription :: Lens' CabalInfo PackageDescription
debInfo :: Lens' CabalInfo DebInfo
debianNameMap :: Lens' CabalInfo (Map PackageName VersionSplits)
epochMap :: Lens' CabalInfo (Map PackageName Int)
packageInfo :: Lens' CabalInfo (Map PackageName PackageInfo)

-- | Given the <a>Flags</a> value read the cabalization and build a new
--   <a>CabalInfo</a> record.
newCabalInfo :: (MonadIO m, MonadMask m) => Flags -> m CabalInfo
instance Canonical CabalInfo
instance Typeable PackageInfo
instance Typeable CabalInfo
instance Eq PackageInfo
instance Ord PackageInfo
instance Show PackageInfo
instance Data PackageInfo
instance Show CabalInfo
instance Data CabalInfo

module Debian.Debianize.Monad

-- | Bits and pieces of information about the mapping from cabal package
--   names and versions to debian package names and versions. In essence,
--   an <tt>Atoms</tt> value represents a package's debianization. The
--   lenses in this module are used to get and set the values hidden in
--   this Atoms value. Many of the values should be left alone to be set
--   when the debianization is finalized.
data CabalInfo
type CabalT m = StateT CabalInfo m
runCabalT :: Monad m => CabalT m a -> CabalInfo -> m (a, CabalInfo)
evalCabalT :: Monad m => CabalT m a -> CabalInfo -> m a
execCabalT :: Monad m => CabalT m a -> CabalInfo -> m CabalInfo
type CabalM = State CabalInfo
runCabalM :: CabalM a -> CabalInfo -> (a, CabalInfo)
evalCabalM :: CabalM a -> CabalInfo -> a
execCabalM :: CabalM a -> CabalInfo -> CabalInfo
type DebianT m = StateT DebInfo m
evalDebianT :: Monad m => DebianT m a -> DebInfo -> m a
evalDebian :: DebianT Identity a -> DebInfo -> a
execDebianT :: Monad m => DebianT m () -> DebInfo -> m DebInfo
liftCabal :: Monad m => StateT DebInfo m a -> StateT CabalInfo m a
ifM :: Monad m => m Bool -> m a -> m a -> m a
whenM :: Monad m => m Bool -> m () -> m ()
unlessM :: Monad m => m Bool -> m () -> m ()


-- | How to name the debian packages based on the cabal package name and
--   version number.
module Debian.Debianize.DebianName

-- | Build the Debian package name for a given package type.
debianName :: (Monad m, Functor m, PkgName name) => PackageType -> CompilerFlavor -> CabalT m name

-- | Function that applies the mapping from cabal names to debian names
--   based on version numbers. If a version split happens at v, this will
--   return the ltName if &lt; v, and the geName if the relation is &gt;=
--   v.
debianNameBase :: Monad m => CabalT m DebBase

-- | Build a debian package name from a cabal package name and a debian
--   package type. Unfortunately, this does not enforce the correspondence
--   between the PackageType value and the name type, so it can return
--   nonsense like (SrcPkgName "libghc-debian-dev").
mkPkgName :: PkgName name => CompilerFlavor -> PackageName -> PackageType -> name
mkPkgName' :: PkgName name => CompilerFlavor -> PackageType -> DebBase -> name

-- | Map all versions of Cabal package pname to Debian package dname. Not
--   really a debian package name, but the name of a cabal package that
--   maps to the debian package name we want. (Should this be a
--   SrcPkgName?)
mapCabal :: Monad m => PackageName -> DebBase -> CabalT m ()

-- | Map versions less than ver of Cabal Package pname to Debian package
--   ltname
splitCabal :: Monad m => PackageName -> DebBase -> Version -> CabalT m ()

-- | Replace any existing mapping of the cabal name <tt>pname</tt> with the
--   debian name <tt>dname</tt>. (Use case: to change the debian package
--   name so it differs from the package provided by ghc.)
remapCabal :: Monad m => PackageName -> DebBase -> CabalT m ()
instance Eq Dependency_
instance Show Dependency_


-- | Detailed information about the specific repositories such as debian or
--   seereason - in particular how cabal names are mapped to debian.
module Debian.Debianize.Details

-- | Update the CabalInfo value in the CabalT state with some details about
--   the debian repository - special cases for how some cabal packages are
--   mapped to debian package names.
debianDefaults :: Monad m => CabalT m ()


-- | Things that seem like they could be clients of this library, but are
--   instead included as part of the library.
module Debian.Debianize.Goodies

-- | Create equals dependencies. For each pair (A, B), use dpkg-query to
--   find out B's version number, version B. Then write a rule into P's
--   .substvar that makes P require that that exact version of A, and
--   another that makes P conflict with any older version of A.
tightDependencyFixup :: Monad m => [(BinPkgName, BinPkgName)] -> BinPkgName -> DebianT m ()

-- | Add a debian binary package to the debianization containing a cabal
--   executable file set up to be a server.
doServer :: Monad m => BinPkgName -> Server -> CabalT m ()

-- | Add a debian binary package to the debianization containing a cabal
--   executable file set up to be a web site.
doWebsite :: Monad m => BinPkgName -> Site -> CabalT m ()

-- | Add a debian binary package to the debianization containing a cabal
--   executable file set up to be a backup script.
doBackups :: Monad m => BinPkgName -> String -> CabalT m ()

-- | Add a debian binary package to the debianization containing a cabal
--   executable file.
doExecutable :: Monad m => BinPkgName -> InstallFile -> CabalT m ()
describe :: Monad m => CabalT m Text
watchAtom :: PackageName -> Text
oldClckwrksSiteFlags :: Site -> [String]
oldClckwrksServerFlags :: Server -> [String]
siteAtoms :: PackageDescription -> BinPkgName -> Site -> CabalInfo -> CabalInfo
serverAtoms :: PackageDescription -> BinPkgName -> Server -> Bool -> CabalInfo -> CabalInfo
backupAtoms :: BinPkgName -> String -> CabalInfo -> CabalInfo
execAtoms :: BinPkgName -> InstallFile -> CabalInfo -> CabalInfo


-- | Compute the debianization of a cabal package.
module Debian.Debianize.BuildDependencies
debianBuildDeps :: (Monad m, Functor m) => PackageDescription -> CabalT m Relations
debianBuildDepsIndep :: (Monad m, Functor m) => PackageDescription -> CabalT m Relations
instance Eq Dependency_
instance Show Dependency_
instance Show a => Show (Rels a)


-- | Read an existing Debianization from a directory file.
module Debian.Debianize.InputDebian
inputDebianization :: MonadIO m => DebianT m ()

-- | Try to input a file and if successful add it to the debianization's
--   list of "intermediate" files, files which will simply be added to the
--   final debianization without any understanding of their contents or
--   purpose.
inputDebianizationFile :: MonadIO m => FilePath -> DebianT m ()
inputChangeLog :: MonadIO m => DebianT m ()

-- | Where to put the installed data files. Computes the destination
--   directory from a Cabal package description. This needs to match the
--   path cabal assigns to datadir in the
--   dist<i>build</i>autogen/Paths_packagename.hs module, or perhaps the
--   path in the CABAL_DEBIAN_DATADIR environment variable.
dataDest :: Monad m => CabalT m FilePath

-- | Where to look for the data-files
dataTop :: Monad m => CabalT m FilePath


-- | Compute the debianization of a cabal package.
module Debian.Debianize.Finalize

-- | <tt>debianize customize</tt> initializes the CabalT state from the
--   environment and the cabal package description in (and possibly the
--   debian/changelog file) from the current directory, then runs
--   <tt>customize</tt> and finalizes the debianization so it is ready to
--   be output.
debianize :: (MonadIO m, Functor m) => CabalT m () -> CabalT m ()
instance Eq Dependency_
instance Show Dependency_


-- | Convert a Debianization into a list of files that can then be written
--   out.
module Debian.Debianize.Files

-- | Turn the Debianization into a list of files, making sure the text
--   associated with each path is unique. Assumes that
--   finalizeDebianization has already been called. (Yes, I'm considering
--   building one into the other, but it is handy to look at the
--   Debianization produced by finalizeDebianization in the unit tests.)
debianizationFileMap :: (Monad m, Functor m) => DebianT m (Map FilePath Text)
instance Pretty (PP (PackageDescription -> IO CopyrightDescription))
instance Pretty (PP Bool)

module Debian.Debianize.Optparse

-- | This data type is an abomination. It represent information, provided
--   on command line. Part of such information provides means to create
--   initial <a>CabalT</a> state and is stored in <a>_flags</a> field. See
--   <tt>newCabalInfo</tt>.
--   
--   Other, much greater part represent changes to already created state.
--   They are stored in <a>_adjustment</a> field.
--   
--   All this can be understood from (simplified) types:
--   
--   <pre>
--   type CabalT m a = StateT CabalInfo m a
--   newCabalInfo :: Flags -&gt; IO CabalInfo
--   handleBehaviorAdjustment :: BehaviorAdjustment -&gt; CabalT IO ()
--   </pre>
data CommandLineOptions
CommandLineOptions :: Flags -> BehaviorAdjustment -> CommandLineOptions
_flags :: CommandLineOptions -> Flags
_adjustment :: CommandLineOptions -> BehaviorAdjustment

-- | This data type represents changes to <a>CabalT</a> state, requested at
--   command line.
data BehaviorAdjustment

-- | This record supplies enough information to locate and load a
--   debianization or a cabal file from the IO monad.
data Flags
Flags :: Int -> Bool -> Bool -> CompilerFlavor -> Set (FlagName, Bool) -> EnvSet -> Flags

-- | Run with progress messages at the given level of verboseness.
_verbosity :: Flags -> Int

-- | Don't write any files or create any directories, just explain what
--   would have been done.
_dryRun :: Flags -> Bool

-- | Fail if the debianization already present doesn't match the one we are
--   going to generate closely enough that it is safe to debianize during
--   the run of dpkg-buildpackage, when Setup configure is run.
--   Specifically, the version number in the top changelog entry must
--   match, and the sets of package names in the control file must match.
_validate :: Flags -> Bool

-- | Which compiler should we generate library packages for? In theory a
--   single deb could handle multiple compiler flavors, but the support
--   tools are not ready for this as of right now (28 Jan 2015.)
_compilerFlavor :: Flags -> CompilerFlavor

-- | Flags to pass to Cabal function finalizePackageDescription, this can
--   be used to control the flags in the cabal file. It can be supplied to
--   the cabal-debian binary using the --flags option.
_cabalFlagAssignments :: Flags -> Set (FlagName, Bool)

-- | Directory containing the build environment for which the debianization
--   will be generated. This determines which compiler will be available,
--   which in turn determines which basic libraries can be provided by the
--   compiler. By default all the paths in EnvSet are "/".
_buildEnv :: Flags -> EnvSet
parseProgramArguments :: IO CommandLineOptions
parseProgramArguments' :: [String] -> IO CommandLineOptions
handleBehaviorAdjustment :: (MonadIO m, Functor m) => BehaviorAdjustment -> CabalT m ()
instance Eq HaddockStatus
instance Eq ProfilingStatus
instance Eq OfficialStatus
instance Generic BuildDep
instance Generic BuildDepIndep
instance Generic DevDep
instance Generic ExtraDepends
instance Generic ExtraConflicts
instance Generic ExtraProvides
instance Generic ExtraReplaces
instance Generic ExtraRecommends
instance Generic ExtraSuggests
instance Generic CabalDebMapping
instance Generic ExecDebMapping
instance Generic Revision
instance Generic CabalEpochMapping
instance Generic CabalFlagMapping
instance Datatype D1BuildDep
instance Constructor C1_0BuildDep
instance Datatype D1BuildDepIndep
instance Constructor C1_0BuildDepIndep
instance Datatype D1DevDep
instance Constructor C1_0DevDep
instance Datatype D1ExtraDepends
instance Constructor C1_0ExtraDepends
instance Datatype D1ExtraConflicts
instance Constructor C1_0ExtraConflicts
instance Datatype D1ExtraProvides
instance Constructor C1_0ExtraProvides
instance Datatype D1ExtraReplaces
instance Constructor C1_0ExtraReplaces
instance Datatype D1ExtraRecommends
instance Constructor C1_0ExtraRecommends
instance Datatype D1ExtraSuggests
instance Constructor C1_0ExtraSuggests
instance Datatype D1CabalDebMapping
instance Constructor C1_0CabalDebMapping
instance Datatype D1ExecDebMapping
instance Constructor C1_0ExecDebMapping
instance Datatype D1Revision
instance Constructor C1_0Revision
instance Datatype D1CabalEpochMapping
instance Constructor C1_0CabalEpochMapping
instance Datatype D1CabalFlagMapping
instance Constructor C1_0CabalFlagMapping
instance Newtype CabalFlagMapping
instance Newtype CabalEpochMapping
instance Newtype Revision
instance Newtype ExecDebMapping
instance Newtype CabalDebMapping
instance Newtype ExtraSuggests
instance Newtype ExtraRecommends
instance Newtype ExtraReplaces
instance Newtype ExtraProvides
instance Newtype ExtraConflicts
instance Newtype ExtraDepends
instance Newtype DevDep
instance Newtype BuildDepIndep
instance Newtype BuildDep


-- | Wrappers around the debianization function to perform various tasks -
--   output, describe, validate a debianization, run an external script to
--   produce a debianization.
module Debian.Debianize.Output

-- | Depending on the options in <tt>atoms</tt>, either validate, describe,
--   or write the generated debianization.
finishDebianization :: (MonadIO m, Functor m) => StateT CabalInfo m ()

-- | Run the script in <tt>debian/Debianize.hs</tt> with the given command
--   line arguments. Returns <tt>True</tt> if the script exists and
--   succeeds. In this case it may be assumed that a debianization was
--   created (or updated) in the debian subdirectory of the current
--   directory. In this way we can include a script in a package to produce
--   a customized debianization more sophisticated than the one that would
--   be produced by the cabal-debian executable. An example is included in
--   the debian subdirectory of this library.
runDebianizeScript :: [String] -> IO Bool

-- | Write the files of the debianization <tt>d</tt> to ./debian
writeDebianization :: (MonadIO m, Functor m) => DebianT m ()

-- | Return a string describing the debianization - a list of file names
--   and their contents in a somewhat human readable format.
describeDebianization :: (MonadIO m, Functor m) => DebianT m String

-- | Compare the old and new debianizations, returning a string describing
--   the differences.
compareDebianization :: DebInfo -> DebInfo -> [String]

-- | Make sure the new debianization matches the existing debianization in
--   several ways - specifically, version number, and the names of the
--   source and binary packages. Some debian packages come with a skeleton
--   debianization that needs to be filled in, this can be used to make
--   sure the debianization we produce is usable.
validateDebianization :: DebInfo -> DebInfo -> ()

-- | Perform whole debianization. You provide your customization, this
--   function does everything else.
performDebianization :: CabalT IO () -> IO ()


-- | <ul>
--   <li><i><i>QUICK START:</i></i></li>
--   </ul>
--   
--   You can either run <tt>cabal-debian</tt>, or for more power and
--   flexibility you can put a <tt>Debianize.hs</tt> script in the
--   package's <tt>debian</tt> subdirectory.
--   
--   To see what your debianization would produce, or how it differs from
--   the debianization already present:
--   
--   <pre>
--   % cabal-debian -n
--   </pre>
--   
--   This is equivalent to the library call
--   
--   <pre>
--   % ghc -e 'System.Environment.withArgs ["-n"] $ Debian.Debianize.performDebianization Debian.Debianize.debianDefaults'
--   </pre>
--   
--   To actually create the debianization and then build the debs,
--   
--   <pre>
--   % ghc -e 'Debian.Debianize.performDebianization Debian.Debianize.debianDefaults'
--   % sudo dpkg-buildpackage
--   </pre>
--   
--   At this point you may need a script to achieve specific packaging
--   goals. Put this this in debian/Debianize.hs:
--   
--   <pre>
--   import Control.Lens
--   import Data.Map as Map
--   import Data.Set as Set
--   import Debian.Relation (BinPkgName(BinPkgName), Relation(Rel))
--   import Debian.Debianize
--   main = performDebianization $ do
--     debianDefaults
--     (debInfo . binaryDebDescription (BinPkgName "cabal-debian") . relations . depends) %= (++ (rels "apt-file, debian-policy, debhelper, haskell-devscripts (&gt;= 0.8.19)"))
--   </pre>
--   
--   Then to test it,
--   
--   <pre>
--   % runhaskell debian/Debianize.hs -n
--   </pre>
--   
--   and to run it for real:
--   
--   <pre>
--   % runhaskell debian/Debianize.hs
--   </pre>
--   
--   <ul>
--   <li><i><i>DESIGN OVERVIEW</i></i></li>
--   </ul>
--   
--   The three phases of the operation of the system are Input -&gt;
--   Finalization -&gt; Output.
--   
--   <ul>
--   <li><i>Input</i> Module <a>Debian.Debianize.Input</a> - gather inputs
--   using IO operations and customization functions, from the .cabal file,
--   an existing debianization, and so on. This information results in a
--   value of type <tt>Atoms</tt>. Modules <tt>Types</tt>, <tt>Lenses</tt>,
--   <tt>Inputs</tt>.<ul><li><i>Customize</i> Make modifications to the
--   input values</li><li><i>Finalization</i> Module
--   <a>Debian.Debianize.Finalize</a> - Fill in any information missing
--   from <tt>Atoms</tt> that is required to build the debianization based
--   on the inputs and our policy decisions.</li><li><i>Debianize</i>
--   Module <a>Debian.Debianize.Files</a> - Compute the paths and files of
--   the debianization from the Atoms value.</li><li><i>Output</i> Module
--   <a>Debian.Debianize.Output</a> - Perform a variety of output
--   operations on the debianzation - writing or updating the files in a
--   debian directory, comparing two debianizations, validate a
--   debianization (ensure two debianizations match in source and binary
--   package names), or describe a debianization.</li></ul></li>
--   </ul>
--   
--   There is also a high level function to run a script that runs this
--   entire pipeline when it finds from a script found in a
--   debian/Debianize.hs file.
module Debian.Debianize
