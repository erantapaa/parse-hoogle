-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Plain byte strings ('ForeignPtr'-less 'ByteString's)
--   
--   More compact representation for strict <a>ByteString</a>s avoiding the
--   overhead and indirection caused by <a>ForeignPtr</a>.
--   
--   This representation is useful to reduce the incurred memory overhead
--   when operating with many small, long-lived, distinct byte strings
--   (such as keys for containers).
--   
--   See documentation in <a>Data.ByteString.Plain</a> for more details
--   about this representation.
@package bytestring-plain
@version 0.1.0.0


-- | This module is intended to be imported <tt>qualified</tt> in order to
--   avoid name clashes with the <a>Prelude</a>, <a>Data.ByteString</a>,
--   and <a>Data.ByteString.Lazy</a> modules. E.g.:
--   
--   <pre>
--   import qualified Data.ByteString.Plain as PB
--   </pre>
module Data.ByteString.Plain

-- | Compact heap representation a (strict) <a>ByteString</a> can be
--   (un)wrapped to/from.
--   
--   This data type depends on the ordinary <a>ByteString</a> type to be
--   useful but comes with a different cost-model.
--   
--   This representation avoids the <a>ForeignPtr</a> indirection, and the
--   offset/length slice representation for shared <a>ByteString</a>s, and
--   is therefore suitable if you need to store many small strings in a
--   data records or for use as keys in container types. On the other hand,
--   string operations on <a>ByteString</a> would require re-allocations,
--   and thus are not supported. If you need to perform such operations
--   convert and operate on conventional <a>ByteString</a>s instead.
--   
--   This structure supports <tt>UNPACK</tt>, and then has an overhead of
--   only 3 words (beyond the word-padded storage of the byte-string
--   payload), as it's basically just a pointer to a
--   <a>MutableByteArray#</a>:
--   
--   <pre>
--   data ByteString = PBS !(MutableByteArray# RealWorld)
--   </pre>
--   
--   In contrast, a single non-shared unpacked (<a>PlainPtr</a>-backed)
--   <a>ByteString</a> field exhibits an overhead of 8 words:
--   
--   <pre>
--   data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8) -- payload (2 words)
--                        {-# UNPACK #-} !Int                -- offset (1 word)
--                        {-# UNPACK #-} !Int                -- length (1 word)
--   
--   data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents -- 2 words w/o info-ptr
--   
--   data ForeignPtrContents -- 1 word needed for info-ptr
--       = PlainForeignPtr {...}
--       | MallocPtr {...}
--       | PlainPtr (MutableByteArray# RealWorld)  -- common case (1 word)
--   
--   data MutableByteArray# s -- 2 words + payload
--   </pre>
--   
--   As an optimization, all zero-length strings are mapped to the
--   singleton <a>empty</a> value.
data ByteString

-- | Singleton value the <a>empty</a> <a>ByteString</a> is mapped to/from.
empty :: ByteString

-- | Extract <a>ByteString</a> from <a>ByteString</a>
--   
--   If possible, the internally used <a>MutableByteArray#</a> is shared
--   with the original <a>ByteString</a> in which case the conversion is
--   cheap.
--   
--   However, if necessary, a trimmed copy of the original
--   <a>ByteString</a> will be created via <a>copy</a> resulting in a newly
--   allocated <a>MutableByteArray#</a>.
--   
--   N.B.: Because strict <a>ByteString</a>s use pinned memory internally
--   also plain <a>ByteString</a>s use pinned memory and thereby increase
--   the potential for memory fragmentation as the garbage collector is not
--   allowed to move pinned memory areas.
--   
--   Depending on the use case, it might be beneficial to apply some form
--   of memoizing to the <a>fromStrict</a> conversion (also known as
--   <a>Hash consing</a> or <a>String interning</a>).
fromStrict :: ByteString -> ByteString

-- | Convert a plain <a>ByteString</a> back into a <a>ByteString</a>.
--   
--   This effectively wraps the plain <a>ByteString</a> into a
--   <a>ForeignPtr</a> and a plain <a>ByteString</a> type.
toStrict :: ByteString -> ByteString
null :: ByteString -> Bool
length :: ByteString -> Int
instance Typeable ByteString
instance Read ByteString
instance Show ByteString
instance Hashable ByteString
instance Ord ByteString
instance Eq ByteString
instance NFData ByteString
