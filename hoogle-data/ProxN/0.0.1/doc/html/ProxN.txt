-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Proximity sets in N dimensions
--   
--   Proximity sets in N dimensions
@package ProxN
@version 0.0.1

module Data.ProxN.Show1
class Show1 v
show1 :: (Show1 v, Show a) => v a -> String

module Data.ProxN.Pretty
class Pretty p
prettyPrint :: Pretty p => p -> PrettyM ()
pretty :: Pretty p => (String -> String) -> p -> String
prettySimp :: Pretty p => p -> String
class Pretty1 p1
prettyPrint1 :: (Pretty1 p1, Pretty p) => p1 p -> PrettyM ()
pretty1 :: (Pretty1 p1, Pretty p) => (String -> String) -> p1 p -> String
prettySimp1 :: (Pretty1 p1, Pretty p) => p1 p -> String
prettyPut :: String -> PrettyM ()
prettyNl :: PrettyM ()
prettyIndent :: PrettyM a -> PrettyM a
instance Monad PrettyM
instance Functor PrettyM
instance Applicative PrettyM
instance MonadReader (String -> String, String -> String) PrettyM

module Data.ProxN.Peano
data Zero
data Succ n
type One = Succ Zero
type Two = Succ One
type Three = Succ Two
type Four = Succ Three
type Five = Succ Four
type Six = Succ Five
type Seven = Succ Six
type Eight = Succ Seven
type Nine = Succ Eight
type Ten = Succ Nine
class Peano p
fromPeano :: Peano p => p -> Int
class Peano p => Logarithm p
logarithm :: Logarithm p => p -> Double -> Double
instance Peano a => Logarithm (Succ a)
instance Logarithm Zero
instance Peano p => Peano (Succ p)
instance Peano Zero

module Data.ProxN.VecN
class (Peano n, Applicative (VecN n), Functor (VecN n)) => VecNClass n where { data family VecN n :: * -> *; }
distance2 :: (VecNClass n, Num a) => VecN n a -> VecN n a -> a
vecCartProd :: VecNClass n => VecN n [a] -> [VecN n a]
fromList :: VecNClass n => [a] -> Maybe (VecN n a)
instance VecNClass Zero
instance VecNClass r => VecNClass (Succ r)
instance (Show a, Show (VecN n a)) => Pretty (VecN (Succ n) a)
instance Show a => Pretty (VecN Zero a)
instance Applicative (VecN n) => Applicative (VecN (Succ n))
instance Applicative (VecN Zero)
instance Foldable (VecN n) => Foldable (VecN (Succ n))
instance Foldable (VecN Zero)
instance Functor (VecN n) => Functor (VecN (Succ n))
instance Functor (VecN Zero)
instance (Show a, Show (VecN n a)) => Show (VecN (Succ n) a)
instance Show (VecN Zero a)

module Data.ProxN.Tree2N
data Tree2N n a
Tree2NBranch :: !a -> !Treed n (Tree2N n a) -> Tree2N n a
Tree2NLeaf :: Tree2N n a
class (Functor (Treed n), Applicative (Treed n), Show1 (Treed n), Pretty1 (Treed n)) => Tree2NClass n where { data family Treed n :: * -> *; }
swapNode :: (Tree2NClass n, Ord a) => (b -> b) -> VecN n a -> VecN n a -> Treed n b -> Treed n b
foldTree :: Tree2NClass n => (a -> b) -> VecN n (b -> b -> b) -> Treed n a -> b
chooseNode :: (Tree2NClass n, Ord a) => VecN n a -> VecN n a -> Treed n b -> b
type VecTree n a = Tree2N n (VecN n a)
fold2NTree :: Tree2NClass n => b -> VecN n (b -> b -> b) -> (a -> b -> b) -> Tree2N n a -> b
fromList :: (Ord a, Tree2NClass n) => [VecN n a] -> VecTree n a
depth :: (Tree2NClass n, VecNClass n) => Tree2N n a -> Int
size :: (Tree2NClass n, VecNClass n) => Tree2N n a -> Int
tree0 :: Tree2N Zero Int
tree1 :: Tree2N One Int
tree2 :: Tree2N Two Int
tree3 :: Tree2N Three Int
instance Tree2NClass n => Tree2NClass (Succ n)
instance Tree2NClass Zero
instance Pretty1 (Treed n) => Pretty1 (Treed (Succ n))
instance Pretty1 (Treed Zero)
instance Show1 (Treed n) => Show1 (Treed (Succ n))
instance Show1 (Treed Zero)
instance Applicative (Treed n) => Applicative (Treed (Succ n))
instance Applicative (Treed Zero)
instance Functor (Treed n) => Functor (Treed (Succ n))
instance Functor (Treed Zero)
instance (Tree2NClass n, Pretty a) => Pretty (Tree2N n a)
instance Tree2NClass n => Pretty1 (Tree2N n)
instance (Show a, Tree2NClass n) => Show (Tree2N n a)
instance Tree2NClass n => Applicative (Tree2N n)
instance Tree2NClass n => Functor (Tree2N n)

module Data.ProxN.Proximity
prox :: (VecNClass n, Tree2NClass n) => Double -> VecN n Double -> VecTree n Double -> [VecN n Double]
proximity :: (VecNClass n, Tree2NClass n) => Double -> VecN n Double -> VecTree n Double -> ([VecN n Double] -> [VecN n Double])
