-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | simple and interactive command-line build tool
--   
--   Shaker is a build tool which allow to simply compile or launch test on
--   an haskell project and provides some interesting features like
--   continuous action. With continuous action, an action (compile or test)
--   will be automatically executed when a source modification is detected.
--   
--   All configuration are made via cabal; Shaker will read cabal
--   configuration to discover source directories, compilation options and
--   targets to compile.
--   
--   <i>Usage</i>
--   
--   The cabal configuration file should be generated beforehand with
--   <i>cabal configure</i>. If you change your cabal configuration, you
--   will need to recreate the configuration file.
--   
--   <i>Launch interactive prompt</i>
--   
--   In the root of your haskell project, launch shaker. An interactive
--   prompt will allow you to execute different actions.
--   
--   <i>Launch a shaker action from command-line</i>
--   
--   In the root of your haskell project, launch shaker with your action as
--   a command argument; shaker will execute the given action and exit. See
--   examples for more details.
--   
--   <i>Action execution</i>
--   
--   <ul>
--   <li><i><tt>Simple Execution</tt></i> An action can be launched
--   normally, by entering the action name.</li>
--   <li><i><tt>Multiple action execution</tt></i> You can specify multiple
--   action to execute simply by separating action by spaces.</li>
--   <li><i><tt>Continuous Action</tt></i> A continuous action will execute
--   the action when a file modification has been detected. Every action
--   are elligible to continuous action, you simply need to prefix them
--   with '~'. To stop a continuous action, simply use ^C.</li>
--   </ul>
--   
--   <i>Available actions</i>
--   
--   <ul>
--   <li><i><tt>compile</tt></i> Compile the project. Targets of the
--   compilation are main files (in case of executable) and exposed modules
--   (in case of library).</li>
--   <li><i><tt>fullcompile</tt></i> Compile all hs files found in source
--   directory. It is usefull to compile sources not declared in cabal.
--   Since it is not possible to compile multiple modules with main, all
--   modules with a main function are excluded.</li>
--   <li><i><tt>help</tt></i> Print all available action.</li>
--   <li><i><tt>clean</tt></i> Clean the directory containing .o and .hi
--   files.</li>
--   <li><i><tt>test</tt></i> Launch all quickcheck properties and hunit
--   tests of the project using test-framework. You can provide one or
--   several regexps as argument and shaker will execute all tests matching
--   one regexp. Quickcheck properties and HUnit tests are automatically
--   discovered using GHC Api. All functions begining with “prop_” are
--   considered as quickcheck properties and all functions of type
--   Test.HUnit.Lang.Assertion and TestCase are considered as HUnit
--   tests.</li>
--   <li><i><tt>test-module</tt></i> Same as test but test-module takes one
--   or several module patterns as arguments.</li>
--   <li><i><tt>quit</tt></i> Exit the application. You can also use ^C or
--   ^D to exit shaker.</li>
--   </ul>
--   
--   <i>Examples with interactive prompt</i>
--   
--   <ul>
--   <li><i><tt>% compile</tt></i> Simply compile the project</li>
--   <li><i><tt>% clean compile</tt></i> Clean and compile the project</li>
--   <li><i><tt>% ~compile</tt></i> Switch to continuous mode and will
--   compile the project when sources are modified.</li>
--   <li><i><tt>% ~clean compile</tt></i> Switch to continuous mode and
--   will clean and compile the project when sources are modified.</li>
--   <li><i><tt>% test</tt></i> Execute all tests in the project</li>
--   <li><i><tt>% test prop_.*</tt></i> Execute all quickcheck properties
--   of the project.</li>
--   <li><i><tt>% test testExecute.* testFilter.* </tt></i> Execute all
--   tests matching testExecute.* or testFilter.*</li>
--   <li><i><tt>% test-module Regex Refle</tt></i> Launch all tests in
--   modules matching Regex.* or Refle.*</li>
--   </ul>
--   
--   <i>Examples with command-line</i>
--   
--   <ul>
--   <li><i><tt>% shaker fullcompile</tt></i> Launch shaker, execute the
--   fullcompile action and give back the control.</li>
--   <li><i><tt>% shaker "~fullcompile" </tt></i> Launch shaker,
--   continuously execute the fullcompile action until shaker is
--   interrupted.</li>
--   </ul>
@package shaker
@version 0.5.1


-- | Allow to filter a list of string with fileListenInfoInclude and
--   exclude patterns
module Shaker.Regex

-- | Filter all elements matching fileListenInfoInclude patterns and remove
--   all elements matching exclude patterns to the result.
--   
--   If no fileListenInfoInclude pattern is given, all elements are
--   accepted minus those matching exclude patterns.
--   
--   If no exclude pattern is given, all elements matching
--   fileListenInfoInclude patterns are taken.
processListWithRegexp :: [String] -> [String] -> [String] -> [String]

module Shaker.CommonUtil
separateEqual :: Eq a => [a] -> [[a]]
separateEqual' :: Eq a => [[a]] -> a -> [[a]]
trimList :: [String] -> [String]


-- | Aggregate all types and data used through shaker
module Shaker.Type

-- | Environnement containing the project configuration. It is generated at
--   startup and won't change
type Shaker = ReaderT ShakerInput
type ShakerR = Reader ShakerInput
type ThreadIdList = MVar [ThreadId]
type Token = MVar Int

-- | MVar used to store currentFiles listed
type CurrentFiles = MVar [FileInfo]

-- | MVar used to store modifiedFiles since the last check
type MvModifiedFiles = MVar [FileInfo]

-- | MVar used to pass action to the fileListenInfoDirectory scanner
type Job = MVar [FileListenInfo]

-- | Environnement for the project compilation This environnement can
--   change depending on the compile action called
type CompileM = Reader CompileInput
data ConductorData
ConductorData :: ListenState -> ([FileInfo] -> IO ()) -> ConductorData

-- | Agregate all information of listener
data ListenState
ListenState :: CurrentFiles -> MvModifiedFiles -> [ThreadId] -> ListenState

-- | Files found in the last check
currentFiles :: ListenState -> CurrentFiles

-- | Differences between last and before last check
mvModifiedFiles :: ListenState -> MvModifiedFiles

-- | List of all forks id initialized
threadIds :: ListenState -> [ThreadId]

-- | Duration define the life span of an action
data Duration

-- | Execute the action and give back control
OneShot :: Duration

-- | Execute the action when a source file modification is done until it is
--   stopped
Continuous :: Duration

-- | Action represents the differents action with arguments
data Action
Action :: ShakerAction -> Action
ActionWithArg :: ShakerAction -> [String] -> Action

-- | The input mvar is used to push the parsed command
type InputCommand = MVar (Maybe Command)
data InputState
InputState :: InputCommand -> Token -> InputState
shakerInputStateCommand :: InputState -> InputCommand

-- | Token is used to manage the token between action executor and
--   command-line listener
shakerInputStateToken :: InputState -> Token

-- | ShakerAction represents the differents actions realisable by shaker
data ShakerAction

-- | Compile sources with ghc
Compile :: ShakerAction

-- | Compile all hs sources with ghc
FullCompile :: ShakerAction

-- | Execute both quickcheck and hunit using test framework
TestFramework :: ShakerAction

-- | Execute both quickcheck and hunit using test framework with module
--   filtering
ModuleTestFramework :: ShakerAction

-- | Execute both quickcheck and hunit using test framework on recompiled
--   modules
IntelligentTestFramework :: ShakerAction

-- | Execute both quickcheck and hunit using test framework on recompiled
--   modules
IntelligentModuleTestFramework :: ShakerAction

-- | Display an error when invalid action is inputed
InvalidAction :: ShakerAction

-- | Display the help
Help :: ShakerAction

-- | Execute a command
Execute :: ShakerAction

-- | Nothing to execute
Empty :: ShakerAction

-- | Exit shaker
Quit :: ShakerAction

-- | Delete generated
Clean :: ShakerAction

-- | Command agregate a duration with an action
data Command
Command :: Duration -> [Action] -> Command
data Verbosity
Silent :: Verbosity
Debug :: Verbosity

-- | Represents the global configuration of the system
data ShakerInput
ShakerInput :: [CompileInput] -> ListenerInput -> PluginMap -> CommandMap -> [String] -> [FileInfo] -> ThreadData -> InputState -> LocalBuildInfo -> PackageIndex -> [ModuleData] -> Verbosity -> ShakerInput
shakerCompileInputs :: ShakerInput -> [CompileInput]
shakerListenerInput :: ShakerInput -> ListenerInput
shakerPluginMap :: ShakerInput -> PluginMap
shakerCommandMap :: ShakerInput -> CommandMap
shakerArgument :: ShakerInput -> [String]
shakerModifiedInfoFiles :: ShakerInput -> [FileInfo]
shakerThreadData :: ShakerInput -> ThreadData
shakerInputState :: ShakerInput -> InputState
shakerLocalBuildInfo :: ShakerInput -> LocalBuildInfo
shakerPackageIndex :: ShakerInput -> PackageIndex
shakerModuleData :: ShakerInput -> [ModuleData]
shakerVerbosity :: ShakerInput -> Verbosity
data ThreadData
ThreadData :: Token -> Token -> ThreadIdList -> ThreadIdList -> ThreadData
threadDataListenToken :: ThreadData -> Token
threadDataQuitToken :: ThreadData -> Token
threadDataListenList :: ThreadData -> ThreadIdList
threadDataQuitList :: ThreadData -> ThreadIdList
getListenThreadList :: ShakerInput -> ThreadIdList

-- | Configuration flags to pass to the ghc compiler
data CompileInput
CompileInput :: [String] -> String -> (DynFlags -> DynFlags) -> [String] -> [String] -> CompileInput

-- | Source fileListenInfoDirectory of haskell files
compileInputSourceDirs :: CompileInput -> [String]

-- | Destination of .o and .hi files
compileInputBuildDirectory :: CompileInput -> String

-- | A transform fonction wich will takes the DynFlags of the current ghc
--   session and change some values
compileInputDynFlags :: CompileInput -> DynFlags -> DynFlags

-- | The command line to pass options to pass to the ghc compiler
compileInputCommandLineFlags :: CompileInput -> [String]

-- | List of files or list of modules to compile
compileInputTargetFiles :: CompileInput -> [String]

-- | Configuration of the continuous listener
data ListenerInput
ListenerInput :: [FileListenInfo] -> Int -> ListenerInput

-- | The files to listen
listenerInputFiles :: ListenerInput -> [FileListenInfo]

-- | Delay beetween 2 check in microsecond
listenerInputDelay :: ListenerInput -> Int

-- | Represents fileListenInfoDirectory to listen
data FileListenInfo
FileListenInfo :: FilePath -> [String] -> [String] -> FileListenInfo

-- | location of the listened fileListenInfoDirectory
fileListenInfoDir :: FileListenInfo -> FilePath

-- | fileListenInfoIgnore patterns
fileListenInfoIgnore :: FileListenInfo -> [String]

-- | fileListenInfoInclude patterns
fileListenInfoInclude :: FileListenInfo -> [String]

-- | Agregate a FilePath with its modification time
data FileInfo
FileInfo :: FilePath -> ClockTime -> FileInfo
fileInfoFilePath :: FileInfo -> FilePath
fileInfoClockTime :: FileInfo -> ClockTime
data PackageData
PackageData :: MapImportToModules -> [String] -> PackageData
packageDataMapImportToModules :: PackageData -> MapImportToModules
packageDataListProjectModules :: PackageData -> [String]
data ModuleData
ModuleData :: String -> String -> Bool -> [String] -> [String] -> [String] -> ModuleData
moduleDataName :: ModuleData -> String
moduleDataFileName :: ModuleData -> String
moduleDataHasMain :: ModuleData -> Bool
moduleDataProperties :: ModuleData -> [String]
moduleDataAssertions :: ModuleData -> [String]
moduleDataTestCase :: ModuleData -> [String]
GhcModuleData :: String -> [String] -> [String] -> ModuleData
ghcModuleDataName :: ModuleData -> String
ghcModuleDataAssertions :: ModuleData -> [String]
ghcModuleDataTestCase :: ModuleData -> [String]
getModuleDataTests :: ModuleData -> ([String], [String], [String])
getModuleDataName :: ModuleData -> String
type MapImportToModules = Map String [String]

-- | Represents the mapping beetween an action and the function to execute
type PluginMap = Map ShakerAction Plugin

-- | Represents the mapping between the command-line input and the action
type CommandMap = Map String ShakerAction

-- | Represents an action of shaker
type Plugin = Shaker IO ()

-- | default dynamics flags the sources are expected to be in src as
--   described in
--   <a>http://www.haskell.org/haskellwiki/structure_of_a_haskell_project</a>
--   the result of compilation (.o and .hi) are placed in the
--   dist/shakerTarget there is no main linkage by default to allow faster
--   compilation feedback
defaultCompileFlags :: DynFlags -> DynFlags

-- | Default haskell file pattern : *.hs
defaultHaskellPatterns :: [String]

-- | Default exclude pattern : Setup.hs
defaultExclude :: [String]
exitCommand :: Command
emptyCommand :: Command
listTestLibs :: [String]
moduleDataExtension :: String
defaultDistDir :: String
instance Show Duration
instance Eq Duration
instance Show ShakerAction
instance Eq ShakerAction
instance Ord ShakerAction
instance Show Action
instance Eq Action
instance Ord Action
instance Show Command
instance Eq Command
instance Show FileListenInfo
instance Eq FileListenInfo
instance Show FileInfo
instance Eq FileInfo
instance Read ModuleData
instance Show ModuleData
instance Eq ModuleData
instance Monoid ModuleData
instance Monoid FileListenInfo
instance Monoid ListenerInput
instance Show CompileInput
instance Monoid CompileInput


-- | Standard and simple actions
module Shaker.Action.Standard

-- | Print the list of available actions
runHelp :: Plugin

-- | Print exit. The real exit management is made in conductor
runExit :: Plugin

-- | Print a begin action notification
runStartAction :: Plugin
runEmpty :: Plugin

-- | Print an end action notification
runEndAction :: Plugin

-- | Clean action is responsible to delete fileListenInfoDirectory
--   containing temporary .o and .hi files
runClean :: Plugin
runInvalidAction :: Plugin


-- | Manage all file operations like listing files with
--   fileListenInfoIncludes and exclude patterns and file filtering
module Shaker.Io

-- | Get the build file (without extension) for the given file
getCorrespondingBuildFile :: FilePath -> Shaker IO FilePath

-- | Get the tuples of (newFiles,modifiedFiles) from given list of
--   fileListenInfoDirectory
listModifiedAndCreatedFiles :: [FileListenInfo] -> [FileInfo] -> IO ([FileInfo], [FileInfo])

-- | List files in the given fileListenInfoDirectory Files matching one
--   regexp in the fileListenInfoIgnore shakerArgument are excluded
listFiles :: FileListenInfo -> IO [FilePath]

-- | Get the list of FileInfo of the given fileListenInfoDirectory
getCurrentFpCl :: FileListenInfo -> IO [FileInfo]
recurseMultipleListFiles :: [FileListenInfo] -> IO [FilePath]

-- | Recursively list all files All non matching files are excluded
recurseListFiles :: FileListenInfo -> IO [FilePath]
mapImportToModules :: IO PackageData

-- | Default haskell file pattern : *.hs
defaultHaskellPatterns :: [String]

-- | Default exclude pattern : Setup.hs
defaultExclude :: [String]
handleActionInterrupt :: IO () -> IO ()
handleIOException :: IO () -> IO ()


-- | Module responsible to parse a String into a Command
module Shaker.Parser

-- | Parse the given string to a Command
parseCommand :: String -> ShakerInput -> Either ParseError Command


-- | Command line manager This manager will listen to the standard input as
--   soon as the MVar token is filled. Then, it will fill another MVar
--   (input) with the parsed command. Autocompletion is supported throught
--   haskeline configuration.
module Shaker.Cli

-- | Listen to keyboard input and parse command
getInput :: Shaker IO (IO ())
listActions :: Monad m => ShakerInput -> String -> m [Completion]
data InputState
InputState :: InputCommand -> Token -> InputState
shakerInputStateCommand :: InputState -> InputCommand

-- | Token is used to manage the token between action executor and
--   command-line listener
shakerInputStateToken :: InputState -> Token


-- | Manage file listener operation for continuous mode. All communication
--   are made via MVars
module Shaker.Listener

-- | listen to the job box and process the job
listen :: CurrentFiles -> MvModifiedFiles -> Job -> IO ()
initializeListener :: Shaker IO ListenState

-- | manage the job box. Fill it with a job every listenerInputDelay
schedule :: ListenerInput -> Job -> IO ()

-- | Update the files status
updateFileStat :: CurrentFiles -> MvModifiedFiles -> [FileInfo] -> [FileInfo] -> IO ()

-- | Agregate all information of listener
data ListenState
ListenState :: CurrentFiles -> MvModifiedFiles -> [ThreadId] -> ListenState

-- | Files found in the last check
currentFiles :: ListenState -> CurrentFiles

-- | Differences between last and before last check
mvModifiedFiles :: ListenState -> MvModifiedFiles

-- | List of all forks id initialized
threadIds :: ListenState -> [ThreadId]

module Shaker.HsHelper
parseHsFiles :: [FileListenInfo] -> IO [HsModule]
parseFileToHsModule :: FilePath -> IO (Maybe HsModule)
hsModuleCollectProperties :: HsModule -> [String]
abstractCollectFunctionWithUnqualifiedType :: (HsQualType -> Bool) -> HsModule -> [String]
filterSnd :: (b -> Bool) -> [(a, b)] -> [(a, b)]
mapSnd :: (t1 -> t2) -> [(t, t1)] -> [(t, t2)]
getListFunction :: HsModule -> [String]
getTupleFunctionNameType :: HsModule -> [(String, HsQualType)]
getSignature :: HsDecl -> Maybe (String, HsQualType)
getFunBindName :: HsDecl -> Maybe String
getIdentFromHsName :: HsName -> String
getDecls :: HsModule -> [HsDecl]
hsModuleFileName :: HsModule -> String
hsModuleName :: HsModule -> String

module Shaker.ModuleData

-- | Get the corresponding mdata file from the given source file
getCorrespondingModuleDataFile :: FilePath -> Shaker IO FilePath

-- | Write given moduleData in dist directory
writeModuleData :: ModuleData -> Shaker IO ()

-- | Parse module data from all haskell sources.
parseAllModuleData :: Shaker IO [ModuleData]

-- | Read Module data from the given haskell source. It tries to read
--   serialized information beforehand.
parseModuleData :: FilePath -> Shaker IO (Maybe ModuleData)

-- | Read Module data from the serialized data. It returns Nothing if the
--   serialized data is absent or out-of-date.
parseModuleDataIfExist :: FilePath -> Shaker IO (Maybe ModuleData)
convertModuleDataToFullCompileInput :: Shaker IO [CompileInput]
groupByValidTargets :: [ModuleData] -> [[ModuleData]]
getNonMainCompileInput :: Shaker IO CompileInput
fillModuleData :: ShakerInput -> IO ShakerInput
constructModuleData :: HsModule -> ModuleData
hsModuleDataHasTest :: ModuleData -> Bool

-- | Include only module matching the given pattern
filterModulesWithPattern :: [ModuleData] -> String -> [ModuleData]
filterFunctionsWithPatterns :: [ModuleData] -> [String] -> [ModuleData]
filterFunctionsWithPatterns' :: ModuleData -> [String] -> ModuleData
removeNonTestModules :: [ModuleData] -> [ModuleData]


-- | Allow to dynamically construct a list of quickcheck properties and
--   Hunit test with template haskell
module Shaker.TestTH

-- | List all test group of the project. see <a>Shaker.TestTH</a>
listAllTestFrameworkGroupList :: ShakerInput -> ExpQ

-- | List all test group for test-framework from the list of modules
listTestFrameworkGroupList :: [ModuleData] -> ExpQ

-- | Generate a test group for a given module
getSingleTestFrameworkGroup :: ModuleData -> Exp
convertHunitTestCaseToTuples :: [String] -> Exp

-- | Generate an expression for a single hunit test
getSingleFrameworkHunit :: String -> Exp

-- | Generate an expression for a single quickcheck property
getSingleFrameworkQuickCheck :: String -> Exp


-- | Conductor is responsible to control the command-line listener, the
--   listener manager and the action to execute
module Shaker.Conductor

-- | Initialize the master thread Once quit is called, all threads are
--   killed
initThread :: Shaker IO ()

-- | Execute Given Command in a new thread
executeCommand :: Maybe Command -> Shaker IO ()

module Shaker.GhcInterface
initializeGhc :: GhcMonad m => CompileInput -> m ()

-- | Configure and load targets of compilation. It is possible to exploit
--   the compilation result after this step.
ghcCompile :: GhcMonad m => CompileInput -> m SuccessFlag

-- | Get the list of unresolved import and unexposed yet needed packages
getListNeededPackages :: Shaker IO [String]
installedPackageIdString :: InstalledPackageId -> String
fillModuleDataTest :: [ModuleData] -> Shaker IO [[ModuleData]]
addLibraryToDynFlags :: [String] -> DynFlags -> DynFlags
searchInstalledPackageId :: String -> Shaker IO (Maybe String)

module Shaker.CabalInterface
generateAutogenFiles :: LocalBuildInfo -> IO ()
applyPreprocessSources :: Shaker IO ()
getPreprocessorDirectory :: LocalBuildInfo -> Executable -> FilePath
getCompileFlagsForExecutable :: LocalBuildInfo -> Executable -> ComponentLocalBuildInfo -> [String]
getCompileFlagsForLibrary :: LocalBuildInfo -> Library -> ComponentLocalBuildInfo -> [String]

module Shaker.Action.Compile

-- | Run haskell compilation on given CompileInput list
runCompile :: Plugin

-- | Run haskell compilation on all haskell files
runFullCompile :: Plugin

-- | Configure and load targets of compilation. It is possible to exploit
--   the compilation result after this step.
ghcCompile :: GhcMonad m => CompileInput -> m SuccessFlag

module Shaker.Reflexivite
data RunnableFunction
RunnableFunction :: [String] -> [String] -> String -> RunnableFunction
runnableFunctionModule :: RunnableFunction -> [String]
runnableLibrairies :: RunnableFunction -> [String]
runnableFunctionFunction :: RunnableFunction -> String

-- | Compile, load and run the given function
runFunction :: CompileInput -> RunnableFunction -> Shaker IO ()
instance Show RunnableFunction

module Shaker.Action.Test
runTestFramework :: Plugin
runModuleTestFramework :: Plugin
getModulesWithModuleFiltering :: Shaker IO [ModuleData]
getModulesWithFunctionFiltering :: Shaker IO [ModuleData]
processModuleDataList :: [[ModuleData]] -> Plugin
executeTest :: [ModuleData] -> Plugin


-- | Register available actions and how they will be called
module Shaker.PluginConfig

-- | The default plugin map contains mapping for compile, help and exit
--   action
defaultPluginMap :: PluginMap
defaultCommandMap :: CommandMap


-- | Contains the default configuration of shaker
module Shaker.Config
defaultInput :: ShakerInput
defaultInputInitialized :: IO ShakerInput
defaultThreadData :: IO ThreadData
defaultInputState :: IO InputState


-- | Allow to use cabal configuration (generated via the configure action
--   of cabal). Source fileListenInfoDirectories and compilation options
--   will be reused by Shaker.
module Shaker.CabalInfo

-- | Read the build information from cabal and output a shakerInput from it
defaultCabalInput :: IO ShakerInput
applyPreprocessSources :: Shaker IO ()
