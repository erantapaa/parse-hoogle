-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library for purely functional lazy interactions with the outer world.
--   
--   This package implements a data structure and operations on it for
--   writing interactive program with no imperative flavor of IO monads.
--   
--   <ul>
--   <li><i>N.B.</i> At the moment, APIs maybe change.</li>
--   </ul>
@package oi
@version 0.3.1

module Data.OI.Force

-- | forces
force :: a -> ()

-- | returns forcing invoker
force' :: a -> (a, ())

-- | forces sequence
forceSeq :: [a] -> ()

module Data.OI.Internal

-- | Datatype for intermediating interaction: <tt>OI</tt> has two states
--   (programmer cannot distinguish), non-expressed and exressed.
--   `Non-expressed' indicates that no computation is assigned. In other
--   words, it's value is never denotated by any expression. So, if you
--   refer the value then the process will be suspended until other process
--   determins the value. Non-expressed value can be determined to become
--   <tt>expressed</tt> for a value by a expression at most once.
--   <tt>Expressed</tt> indicates that some computation is assigned for the
--   value. Once expressed, the value never be back to non-expressed nor be
--   changed.
data OI a

-- | Interaction (a function from a intermediating type to another type)
--   type
type (:->) a b = OI a -> b

-- | Dereference operator
(??) :: OI a -> a

-- | Reference operator
(##) :: a -> OI a

-- | Assign Operator
(=:) :: a -> OI a -> a

-- | Decomposer for pair
dePair :: OI (a, b) -> (OI a, OI b)

-- | Decomposer for list
deList :: OI [a] -> Maybe (OI a, OI [a])

-- | Decomposer for triple
deTriple :: OI (a, b, c) -> (OI a, OI b, OI c)

-- | Decomposer for 4-tuple
deTuple4 :: OI (a, b, c, d) -> (OI a, OI b, OI c, OI d)

-- | Decomposer for 5-tuple
deTuple5 :: OI (a, b, c, d, e) -> (OI a, OI b, OI c, OI d, OI e)

-- | Decomposer for 6-tuple
deTuple6 :: OI (a, b, c, d, e, f) -> (OI a, OI b, OI c, OI d, OI e, OI f)

-- | Decomposer for 7-tuple
deTuple7 :: OI (a, b, c, d, e, f, g) -> (OI a, OI b, OI c, OI d, OI e, OI f, OI g)
deLeft :: OI (Either a b) -> Either (OI a) (OI b)
deRight :: OI (Either a b) -> Either (OI a) (OI b)

-- | Drive interaction
runInteraction :: (OI a -> b) -> IO b

-- | <tt>IOResult</tt> for error handling
data IOResult a
Success :: a -> IOResult a
result :: IOResult a -> a
Failure :: String -> IOResult a
errmsg :: IOResult a -> String

-- | Convert IO to interaction
iooi :: IO a -> OI a -> a
iooi' :: IO a -> OI (IOResult a) -> IOResult a
instance Functor IOResult
instance Show a => Show (IOResult a)
instance Comonad OI
instance Monad OI
instance Functor OI

module Data.OI.Combinator

-- | Connect two interactions into an interaction
(|:|) :: (a :-> c) -> (b :-> d) -> ((a, b) :-> (c, d))
(|>|) :: (a :-> (p, c)) -> (b :-> (p -> d)) -> ((a, b) :-> (c, d))
(|/|) :: (a :-> c) -> (c -> (b :-> d)) -> ((a, b) :-> d)
(|><|) :: (a :-> (p -> (q, c))) -> (b :-> (q -> (p, d))) -> ((a, b) :-> (c, d))
sequenceOI :: [a :-> b] -> [a] :-> [b]

-- | Iteration
foldOI :: (a :-> (b -> b)) -> b -> ([a] :-> b)
mapOI :: (a :-> b) -> ([a] :-> [b])
zipWithOI :: (a -> (b :-> c)) -> ([a] -> ([b] :-> [c]))
zipWithOI' :: (a :-> (b -> c)) -> ([a] :-> ([b] -> [c]))

-- | Conditional branching
ifOI :: Bool -> (a :-> c) -> (b :-> c) -> (Either a b :-> c)
choiceOI :: (a :-> c) -> (b :-> c) -> Bool -> (Either a b :-> c)
choiceOIOn :: (t -> a :-> c) -> (t -> b :-> c) -> (t -> Bool) -> t -> Either a b :-> c

-- | Sequencing
seqsOI :: [a :-> b] -> ([a] :-> ())
seqsOI' :: [a] :-> ([a :-> b] -> ())

module Data.OI.IFun
type IFun p a b = a -> p :-> b
(|::|) :: IFun p a c -> IFun q b d -> IFun (p, q) (a, b) (c, d)
(|->|) :: IFun p a (b', c) -> IFun q (b', b) d -> IFun (p, q) (a, b) (c, d)
(|<>|) :: IFun p (a', a) (b', c) -> IFun q (b', b) (a', d) -> IFun (p, q) (a, b) (c, d)

module Data.OI.IO
type (:~>) a b = OI (IOResult a) -> IOResult b
openFile :: FilePath -> IOMode -> Handle :~> Handle
hIsClosed :: Handle -> Bool :~> Bool
hIsEOF :: Handle -> Bool :~> Bool
hGetLine :: Handle -> String :~> String
hClose :: Handle -> () :~> ()
hPutStrLn :: Handle -> String -> () :~> ()
isEOF :: Bool :~> Bool
getLine :: String :~> String
putStrLn :: String -> () :~> ()

module Data.OI.Merge
mergeOI :: [a] -> [a] -> [a] :-> [a]
nmergeOI :: [[a]] -> [a] :-> [a]

module Data.OI.Resource
data Resource a
Resource :: () -> [IOResult a] -> Resource a
release :: Resource a -> ()
stream :: Resource a -> [IOResult a]
inFileResource :: FilePath -> IOResult (Resource String) :-> IOResult (Resource String)
outFileResource :: FilePath -> [String] -> IOResult (Resource ()) :-> IOResult (Resource ())
mapR :: (a -> b) -> IOResult (Resource a) -> [b]
mapR' :: (a -> b) -> Resource a -> [b]
filterR :: (a -> Bool) -> IOResult (Resource a) -> [a]
filterR' :: (a -> Bool) -> Resource a -> [a]
takeR :: Integral i => i -> IOResult (Resource a) -> [a]
takeR' :: Integral i => i -> Resource a -> [a]
takeWhileR :: (a -> Bool) -> IOResult (Resource a) -> [a]
takeWhileR' :: (a -> Bool) -> Resource a -> [a]
instance Show a => Show (Resource a)

module Data.OI.System
args :: [String] :-> [String]
progName :: String :-> String
environment :: [(String, String)] :-> [(String, String)]

module Data.OI
