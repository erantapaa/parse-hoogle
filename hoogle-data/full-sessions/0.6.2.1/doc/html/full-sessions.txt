-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a monad for protocol-typed network programming
--   
--   This library defines a <tt>Session</tt> monad, which provides static
--   checking of safe and consistent use of communication channels
--   according to protocols. It requires almost no type- or term-
--   annotations. Examples inculude a SMTP client and a simple chat client
--   with its own protocol. Alternatives are: the simple-sessions package
--   (<a>http://hackage.haskell.org/package/simple-sessions</a>) and the
--   sessions package (<a>http://hackage.haskell.org/package/sessions</a>).
@package full-sessions
@version 0.6.2.1


-- | Pi-calculus style communication and concurrency primitives which come
--   with session types.
module Control.Concurrent.FullSession

-- | Type level zero.
data Z

-- | Type level successor. <tt><a>S</a> n</tt> denotes <tt>(n+1)</tt>.
data S n

-- | Type level predecessor (only for internal use). <tt><a>P</a> n</tt>
--   denotes <tt>(n-1)</tt>.
data P n

-- | The class which covers type-level natural numbers.
class Nat n

-- | Type level <tt>True</tt>.
data T

-- | Type level <tt>False</tt>.
data F

-- | <tt><a>Send</a> v u</tt> denotes a protocol to emit a value of type
--   <tt>v</tt> followed by a behavior of type <tt>u</tt>. Use of
--   <tt><tt>send</tt></tt> on a channel changes its session type from
--   <tt><a>Send</a> v u</tt> into <tt>u</tt>.
data Send v u

-- | <tt><a>Recv</a> v u</tt> denotes a protocol of receiving a value of
--   type <tt>v</tt> followed by a behavior of type <tt>u</tt>. Use of
--   <tt><tt>recv</tt></tt> on a channel changes its session type from
--   <tt><a>Recv</a> v u</tt> into <tt>u</tt>.
data Recv v u

-- | <tt><a>Throw</a> u1 u2</tt> denotes a behavior to output of a channel
--   with session type <tt>u1</tt> followed by a behavior of type
--   <tt>u2</tt>. Use of <tt><tt>sendS</tt></tt> on a channel changes its
--   session type from <tt><a>Throw</a> u1 u2</tt> into <tt>u2</tt>.
data Throw u' u

-- | <tt><a>Catch</a> u1 u2</tt> is the input of a channel with session
--   type <tt>u1</tt> followed by a behavior of type <tt>u2</tt>. Use of
--   <tt><tt>recvS</tt></tt> on a channel changes its session type from
--   <tt><a>Catch</a> u1 u2</tt> into <tt>u2</tt>.
data Catch u' u

-- | <tt><a>Select</a> u1 u2</tt> denotes to be either behavior of type
--   <tt>u1</tt> or type <tt>u2</tt> after emitting a corresponding label
--   <tt>1</tt> or <tt>2</tt>. Use of <tt><tt>sel1</tt></tt> or
--   <tt><tt>sel2</tt></tt> on a channel changes its session type from
--   <tt><a>Select</a> u1 u2</tt> into <tt>u1</tt> or <tt>u2</tt>,
--   respectively.
data Select u1 u2

-- | <tt><a>Offer</a> u1 u2</tt> denotes a behavior like either <tt>u1</tt>
--   or <tt>u2</tt> according to the incoming label.
data Offer u1 u2

-- | <a>End</a> denotes a terminated session. Further communication along a
--   channel with type <a>End</a> cannot take place.
data End

-- | <a>Bot</a> is the type for a channel whose both endpoints are already
--   engaged by two processes, so that no further processes can own that
--   channel. For example, in <tt>forkIO (send k e) &gt;&gt;&gt; recv
--   k</tt>, <tt>k</tt> has type <a>Bot</a>.
data Bot

-- | <tt><a>Rec</a> m r</tt> denotes recursive session, where <tt>m</tt>
--   represents the binder of recursion variable. a type-level natural
--   numer (like <tt><a>S</a> <a>Z</a></tt>). nesting level of
--   <tt><a>Rec</a></tt>, and <tt>r</tt> is the body of the recursion which
--   may contain <tt><a>Var</a> m</tt>.
data Rec m r

-- | Recursion variable.
data Var n

-- | <tt><a>Close</a></tt> denotes a session that can do nothing but
--   closing it.
data Close
data SelectN u1 u2
data OfferN u1 u2

-- | Type-level snoc (reversed version of cons <tt>(:)</tt>). <tt>ss :&gt;
--   s</tt> denotes a list <tt>ss</tt> with <tt>s</tt> on its end.
--   (FIXME:English)
data (:>) ss s

-- | Type-level empty list (<tt>[]</tt>).
data Nil

-- | The <tt>Session</tt> monad. <tt>ss</tt> and <tt>tt</tt> denotes the
--   <i>usage</i> of channels.
--   
--   <ul>
--   <li><tt>ss</tt> denotes <i>pre-type</i>, which denotes the type-level
--   list of session types <i>required</i> to run the session.</li>
--   <li><tt>tt</tt> denotes <i>post-type</i>, which denotes the type-level
--   lists of session types <i>produced</i> by the session.</li>
--   </ul>
--   
--   <tt>t</tt> denotes a <i>type-tag</i>, which prevents abuse of use of
--   channels. For detail, see <a>runS</a>.
data Session t ss tt a

-- | Bind (a.k.a <tt>&gt;&gt;=</tt>) operation for <a>Session</a> monad.
(>>>=) :: Session t ss tt a -> (a -> Session t tt uu b) -> Session t ss uu b
(>>>) :: Session t ss tt a -> Session t tt uu b -> Session t ss uu b

-- | Unit (a.k.a <tt>return</tt>) operation for <a>Session</a> monad.
ireturn :: a -> Session t ss ss a

-- | <a>runS</a> runs the <a>Session</a>. The pretype (see <a>Session</a>)
--   must be <a>Nil</a>. The posttype must be <a>Ended</a>, i.e. all
--   channels must be <a>End</a>.
--   
--   Forall'd type variable <tt>t</tt> prevents abuse of use of channels
--   inside different run. For example, <tt>new &gt;&gt;&gt;= c -&gt;
--   <tt>io_</tt> (runS ( ... send c ...) )</tt> is rejected by the Haskell
--   typechecker with error <tt>Inferred type is less polymorphic than
--   expected</tt>.
runS :: Ended n ss => forall a n. (forall t. Session t Nil ss a) -> IO a

-- | The channel type. The type-level number <tt>n</tt> points to the
--   session-type in type environments. For example, in the type
--   <tt>Session t (Nil:&gt;Send Int End) (Nil:&gt;End) ()</tt>, the usage
--   of the channel <tt>c :: Channel t Z</tt> is <tt>Send Int End</tt> in
--   pretype and <tt>End</tt> in posttype.
data Channel t n
data Service u
close :: (Pickup ss n Close, Update ss n End ss', IsEnded ss F) => Channel t n -> Session t ss ss' ()
send :: (Pickup ss n (Send v a), Update ss n a ss', IsEnded ss F) => Channel t n -> v -> Session t ss ss' ()
recv :: (Pickup ss n (Recv v u), Update ss n u ss', IsEnded ss F) => Channel t n -> Session t ss ss' v
sendS :: (Pickup ss n1 (Throw c1 u1), Update ss n1 u1 ss', Pickup ss' n2 c1, Update ss' n2 End ss'', IsEnded ss F) => Channel t n1 -> Channel t n2 -> Session t ss ss'' ()
recvS :: (Pickup ss n1 (Catch c1 u1), Update ss n1 u1 ss', SList ss' l, IsEnded ss F) => Channel t n1 -> Session t ss (ss' :> c1) (Channel t l)

-- | output a label `1'
sel1 :: (Pickup ss n (Select s x), Update ss n s tt, IsEnded ss F) => Channel t n -> Session t ss tt ()

-- | output a label `2'
sel2 :: (Pickup ss n (Select x s), Update ss n s tt, IsEnded ss F) => Channel t n -> Session t ss tt ()
ifSelect :: (Pickup ss n (Select x y), Update ss n x sx, Update ss n y sy, Diff xx yy zz, IsEnded ss F) => Channel t n -> Bool -> Session t sx xx a -> Session t sy yy a -> Session t ss zz a
offer :: (Pickup ss n (Offer x y), Update ss n x sx, Update ss n y sy, Diff xx yy zz, IsEnded ss F) => Channel t n -> Session t sx xx a -> Session t sy yy a -> Session t ss zz a
new :: SList ss l => Session t ss (ss :> Bot) (Channel t l)
newService :: Dual Z u u' => IO (Service u)
connect :: (Dual Z u u', SList ss l) => Service u -> Session t ss (ss :> u') (Channel t l)
connectRunS :: (Dual Z u u', Ended xs n) => Service u -> (forall t. Channel t Z -> Session t (Nil :> u') xs a) -> IO a
accept :: (Dual Z u u', SList ss l) => Service u -> Session t ss (ss :> u) (Channel t l)
acceptRunS :: (Dual Z u u', Ended xs n) => Service u -> (forall t. Channel t Z -> Session t (Nil :> u) xs a) -> IO a
connectNw :: (SList ss l, NwSession u) => NwService u -> Session t ss (ss :> u) (Channel t l)
connectNw2 :: (SList ss l, NwSendOnly u, NwReceiveOnly u') => NwService2 u u' -> Session t ss ((ss :> u) :> u') (Channel t l, Channel t (S l))
acceptOneNw2 :: (SList ss l, NwSendOnly u, NwReceiveOnly u') => NwService2 u u' -> Session t ss ((ss :> u) :> u') (Channel t l, Channel t (S l))

-- | output a label `1'
sel1N :: (Pickup ss n (SelectN s x), Update ss n s tt) => Channel t n -> Session t ss tt ()
sel2N :: (Pickup ss n (SelectN x s), Update ss n s tt) => Channel t n -> Session t ss tt ()
ifSelectN :: (Pickup ss n (SelectN x y), Update ss n x sx, Update ss n y sy, Diff xx yy zz, IsEnded ss F) => Channel t n -> Bool -> Session t sx xx a -> Session t sy yy a -> Session t ss zz a
offerN :: (NwReceiver x, NwReceiver y, Pickup ss n (OfferN x y), Update ss n x sx, Update ss n y sy, Diff xx yy zz, IsEnded ss F) => Channel t n -> Session t sx xx a -> Session t sy yy a -> Session t ss zz a
dualNw :: NwDual u u' => NwService u -> NwService u'
dualNw2 :: (NwDual u1 u1', NwDual u2 u2') => NwService2 u1 u2 -> NwService2 u1' u2'
mkNwService :: NwSession u => String -> Int -> u -> NwService u
mkNwService2 :: (NwSendOnly u, NwReceiveOnly u') => String -> Int -> u -> u' -> NwService2 u u'
class Message mes
parseMessage :: Message mes => String -> Maybe (mes, String)
showMessage :: Message mes => mes -> String

-- | start a new thread
forkIOs, forkOSs :: (SList ss l, SList tt' l, SList tt l, Ended l' ss', IsEnded ss b, Par' b ss tt' tt) => Session t ss ss' () -> Session t tt tt' ThreadId
io :: IO a -> Session t ss ss a
io_ :: IO a -> Session t ss ss ()
finallys :: Session t ss tt () -> IO () -> Session t ss tt ()
unwind0 :: (RecFold Z u r r, RecUnfold Z r r u, Pickup ss n (Rec Z r), Update ss n u tt, IsEnded ss F) => Channel t n -> Session t ss tt ()
unwind1 :: (RecFold (S Z) u r r, RecUnfold (S Z) r r u, Pickup ss n (Rec (S Z) r), Update ss n u tt, IsEnded ss F) => Channel t n -> Session t ss tt ()
unwind2 :: (RecFold (S (S Z)) u r r, RecUnfold (S (S Z)) r r u, Pickup ss n (Rec (S (S Z)) r), Update ss n u tt, IsEnded ss F) => Channel t n -> Session t ss tt ()
recur1 :: (EndedWithout n s ss, AppendEnd ss ss', SList ss' l, Ended l tt) => (Channel t n -> Session t ss tt ()) -> Channel t n -> Session t ss' tt ()
recur2 :: (EndedWithout2 n m s s' ss, AppendEnd ss ss', SList ss' l, Ended l tt) => (Channel t n -> Channel t m -> Session t ss tt ()) -> Channel t n -> Channel t m -> Session t ss' tt ()
channeltype1 :: Pickup ss' Z s' => (Channel t Z -> Session t (Nil :> s) ss' a) -> (s, s')
channeltype2 :: (Pickup ss' Z s', Pickup ss' (S Z) t') => (Channel t Z -> Channel t (S Z) -> Session t ((Nil :> s) :> t) ss' a) -> ((s, s'), (t, t'))
typecheck1 :: SList ss l => (Channel t l -> Session t (ss :> s1) ss' a) -> Session t (ss :> s1) ss' a
typecheck2 :: SList ss l => (Channel t l -> Channel t (S l) -> Session t ((ss :> s1) :> s2) ss' a) -> Session t ((ss :> s1) :> s2) ss' a

-- | Equality on type-level natural numbers. <tt>b ~ <a>T</a></tt> if <tt>x
--   == y</tt>. Otherwise <tt>b ~ F</tt>.
class EqNat x y b | x y -> b

-- | Computes subtraction of <tt>n</tt> by <tt>n'</tt> (FIXME:OK?)
class Sub n n'

-- | Computes subtraction of <tt>n</tt> by <tt>n'</tt>

-- | type-level <a>&amp;&amp;</a>
class And b1 b2 b | b1 b2 -> b

-- | The class which covers session-type environments. The second parameter
--   of the class denotes the length of the list.
class SList ss l | ss -> l

-- | <tt><a>Pickup</a> ss n s</tt> denotes that the <tt>n</tt>-th element
--   of the list <tt>ss</tt> is <tt>s</tt>. This type class plays an
--   important role in session-type inference.
--   
--   Formally, <tt><a>Pickup</a> ss n s</tt> if <tt>s = pickup ss n</tt>
--   where <tt>pickup</tt> is:
--   
--   <pre>
--   pickup ss n = pickupR ss (len ss - (n+1))
--     where pickupR (ss:&gt;s) Z     = s
--           pickupR (ss:&gt;s) (S n) = pickupR ss n
--           len Nil     = 0
--           len (ss:&gt;s) = (len ss) + 1
--   </pre>
--   
--   For example, <tt>Pickup (End :&gt; Bot :&gt; Send Int End) Z t)</tt>
--   is an instance of <tt>Pickup</tt>, and <tt>t</tt> is unified with
--   <tt>Bot</tt>.
--   
--   Note that the list counts from left to right. For example, The
--   <tt>0</tt>-th element of the list <tt>((Nil :&gt; End) :&gt; Bot)
--   :&gt; Send Int End</tt> is <tt>End</tt>.
--   
--   Usually the list is accessed from the right end. The context
--   
--   <pre>
--   <a>SList</a> ss (S n), <a>Pickup</a> (ss:&gt;Bot:&gt;Recv Char End) n s
--   </pre>
--   
--   is expanded into
--   
--   <pre>
--   <a>SList</a> ss (S n), <a>PickupR</a> (ss:&gt;Bot:&gt;Recv Char End) (<a>SubT</a> (S n) (S n)) s, <a>Sub</a> (S n) (S n)
--   </pre>
--   
--   since <tt><a>SubT</a> (<a>S</a> n) (<a>S</a> n) ~ Z</tt>, it will be
--   reduced to
--   
--   <pre>
--   <a>PickupR</a> (ss:&gt;Bot:&gt;Recv Char End) Z s
--   </pre>
--   
--   and then <tt>s</tt> is unified with <tt>Recv Char End</tt>.
class Pickup ss n s | ss n -> s

-- | The reversed version of <a>Pickup</a> which accesses lists in reversed
--   order (counts from right to left). I.e., <tt><a>PickupR</a> (End :&gt;
--   Bot :&gt; Send Int End) Z (Send Int End)</tt> is an instance of
--   <a>PickupR</a>.
class PickupR ss n s | ss n -> s

-- | <tt><a>Update</a> ss n t ss'</tt> denotes that <tt>ss'</tt> is same as
--   <tt>ss</tt> except that its <tt>n</tt>-th element is <tt>t</tt>.
--   Formally, <tt><a>Update</a> ss n t ss'</tt> if <tt>ss' = update ss n
--   t</tt> where <tt>update</tt> is:
--   
--   <pre>
--   update ss n t = updateR ss (len ss - (n+1)) t
--     where updateR (ss:&gt;_) Z     t = ss :&gt; t
--           updateR (ss:&gt;s) (S n) t = updateR ss n t :&gt; s
--           len Nil     = 0
--           len (ss:&gt;s) = (len ss) + 1
--   </pre>
--   
--   In other words, <tt><a>Update</a> (End :&gt; Bot :&gt; Send Int End) Z
--   End (End :&gt; Bot :&gt; End))</tt> is an instance of <tt>Update</tt>.
--   
--   Note that the list counts from left to right, as in the case of
--   <tt>Pickup</tt>.
class Update ss n t ss' | ss n t -> ss'

-- | The reversed version of <a>Update</a>.
class UpdateR ss n t ss' | ss n t -> ss'

-- | <tt><a>Ended</a> n ss</tt> denotes that the session-type environment
--   <tt>ss</tt> (the length of it is <tt>n</tt>) is Ended. The all
--   elements in an Ended type environments are <tt><a>End</a></tt>.
class (SList ss n, IsEnded ss T) => Ended n ss | n -> ss

-- | <tt><a>IsEnded</a> ss b</tt> denotes that b ~ T if <tt>ss</tt> is
--   Ended, otherwise <tt>b ~ F</tt>. In other words, <tt>b ~ T</tt> if the
--   all elements of ss are End
class IsEnded ss b | ss -> b
class IsEndedST s b | s -> b

-- | duality
class Dual n s t | s -> t, t -> s

-- | sesion type algebra
class Comp s t u | s u -> t, t u -> s, s t -> u

-- | pointwise extension of <a>Comp</a> -- FIXME: method
class Par ss tt' tt | ss tt' -> tt, ss tt -> tt', tt tt' -> ss

-- | the specialized case for <a>ended</a> ss -- FIXME
class Par' t ss tt' tt | t ss tt' -> tt, t ss tt -> tt', t tt tt' -> ss
class EndedWithout n s ss | n s -> ss
class EndedWithout' n s l ss | n s l -> ss
class EndedWithout2 n m s t ss | n s m t -> ss
class EndedWithout2' n m s t l ss | n m s t l -> ss
class AppendEnd ss ss'
class AppendEnd' n ss ss' | n ss -> ss', n ss' -> ss
class Diff xx yy zz | xx yy -> zz
class Diff' n xx yy zz | n xx yy -> zz
data NwService u
data NwService2 u u'
class NwSession u => NwSender u
class NwSession u => NwReceiver u
class NwSession u
class (NwSession s, NwSession t) => NwDual s t | s -> t, t -> s
class NwSession u => NwSendOnly u
class NwSession u => NwReceiveOnly u
class RecFold m u s r | m u -> r
class RecFoldCont b m n a s r | b m n a -> r
class RecFold2 m u r | m u -> r
class RecFoldCont2 b m n a r | b m n a -> r
class RecUnfold m r s u | m r s -> u
class RecUnfoldCont b m n s a | b m n s -> a
class TypeEq' () x y b => TypeEq x y b | x y -> b
class TypeEq' q x y b | q x y -> b
class TypeEq'' q x y b | q x y -> b
