-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Optimal Block boundary determination for rsync-like behaviours
--   
@package optimal-blocks
@version 0.1.0

module Algorithm.OptimalBlocks.SipHash
data LE64
data Sip
fromWord64 :: Word64 -> LE64
fullBlock :: Int -> LE64 -> (Sip -> r) -> Sip -> r
lastBlock :: Int -> Int -> LE64 -> (Sip -> r) -> Sip -> r
finalize :: Int -> (Word64 -> r) -> Sip -> r
hashByteString :: Int -> Int -> Word64 -> Word64 -> ByteString -> Word64
instance Eq LE64
instance Show LE64


-- | This is a rolling hash used to calculate the hashes of fixed-length
--   sequences of characters within a given ByteString. BuzzHash is nice in
--   that it makes this calculation very efficient.
module Algorithm.OptimalBlocks.BuzzHash

-- | Determine the hash of every <tt>len</tt> sequence of bytes in the
--   given <a>ByteString</a>. Because this uses BuzzHash, a rolling hash,
--   this runs in <tt>O(n)</tt> time dependent on the length of
--   <tt>bs</tt>, and independent of <tt>len</tt>.
--   
--   This will generate <tt>(length bs - len + 1)</tt> 64-bit hashes.
--   
--   This function really doesn't serve any purpose anymore, and is just
--   kept around as a sanity check for the much faster <a>split</a>
--   function.
hashes :: WindowSize -> ByteString -> Vector Word64

-- | Split up a ByteString into a complete block and a remainder. If no
--   break point is found in the given string, the first element of the
--   resulting pair will be empty.
split :: WindowSize -> BlockShift -> ByteString -> (ByteString, ByteString)

-- | Same thing as <a>split</a>, but actually calculates the hash of every
--   window explicitly. This is really slow, and is only used to validate
--   the results of <a>split</a>
slowSplit :: WindowSize -> BlockShift -> ByteString -> (ByteString, ByteString)

-- | A representation of a hash that allows rolling hashes to be easily
--   calculated.
data Hash
Hash :: !WindowSize -> !Word64 -> Hash
windowLength :: Hash -> !WindowSize
currentVal :: Hash -> !Word64

-- | Create a <a>Hash</a> instance using an entire <a>ByteString</a>. This
--   doesn't have any sort of length argument to do partial
--   <a>ByteString</a>s because <a>ByteString</a> supports efficient slices
--   on its own.
init :: ByteString -> Hash

-- | Roll the <a>Hash</a> to the next byte over in the <a>ByteString</a>
--   being hashed. This doesn't do any sort of checking to ensure that
--   <tt>old</tt> and <tt>new</tt> are actually correct, so this is
--   probably easy to mess up when using it manually. The expected usage is
--   that one would initialize a hash using <a>init</a> on the beginning of
--   some <a>ByteString</a>, and then to calculate the hash of each
--   sequence of bytes one would manually track the first and last byte of
--   each window on the <a>ByteString</a>. <a>hashes</a> does this for
--   you...
roll :: WindowSize -> Word64 -> Word8 -> Word8 -> Word64

-- | Upgrade an 8-bit word to a 64-bit one that is very "different" from
--   all the other possible 8-bit words. This library uses SipHash to do
--   this.
h :: Word8 -> Word64
instance Show Hash

module Algorithm.OptimalBlocks

-- | The result of the <a>chop</a> function, contains the list of optimal
--   blocks that were found, and any remaining bytes that did not end
--   optimally.
data Blocks
Blocks :: [OptimalBlock] -> ByteString -> Blocks
blocksOptimal :: Blocks -> [OptimalBlock]
blocksRemain :: Blocks -> ByteString

-- | Parameters to the chop function. <a>windowSize</a> is how many bytes
--   wide the hashing window is. <a>blockSize</a> is the target size of
--   each generated block. Actual blocks will be larger or smaller, but on
--   average, blocks will be about <a>blockSize</a> on reasonably
--   high-entropy data.
data ChunkConfig
ChunkConfig :: Int -> Int -> Algorithm -> ChunkConfig
windowSize :: ChunkConfig -> Int
blockSize :: ChunkConfig -> Int
chunkAlg :: ChunkConfig -> Algorithm

-- | Alias for <a>ByteString</a>, used to indicate that this sequence of
--   bytes ends in an optimal fashion.
newtype OptimalBlock
OptimalBlock :: ByteString -> OptimalBlock
fromOptimal :: OptimalBlock -> ByteString
data Algorithm
Reference :: Algorithm
Old :: Algorithm
New :: Algorithm

-- | Chop up a <a>ByteString</a> into blocks of data that are likely to
--   occur in other <a>ByteString</a>s. This uses roughly the same
--   algorithm that rsync does: calculate a hash of every
--   <a>windowSize</a>-sized sequence of bytes within the given
--   <a>ByteString</a>, and then break it up where the hashes match a
--   certain pattern. Specifically, this function uses BuzzHash (a rolling
--   hash) to make the hash calculations fast, and the pattern it looks for
--   is that the hash's binary form ends with the right number of "ones",
--   where "right" is determined by the given <a>blockSize</a>. The breaks
--   are inserted after the matching windows are found.
chop :: ChunkConfig -> ByteString -> Blocks

-- | Split up a ByteString into a complete block and a remainder. If no
--   break point is found in the given string, the first element of the
--   resulting pair will be empty.
split :: WindowSize -> BlockShift -> ByteString -> (ByteString, ByteString)

-- | This is an alias of <tt>chop'</tt> that uses a window size of 128
--   bytes and a desired block size of 256KiB.
defaultConfig :: ChunkConfig

-- | Determine the bitmask that will probably give us blocks of size
--   <tt>desiredSz</tt>. The idea behind this is that if, for example, we
--   want 1MB blocks, then we need a bitmask that will match one window in
--   (1024*1024). This is equivalent to saying that we want the hash's
--   bottom 20 bits to be set (a 1 in 2**20 occurrance). This function's
--   ugly, and uses logarithms and lots of type conversions, but it's only
--   called once per <tt>chop'</tt> call, so it doesn't have much impact on
--   performance.
sizedBitmask :: Int -> Word64
instance Eq OptimalBlock
instance Ord OptimalBlock
instance Show OptimalBlock
instance Eq Blocks
instance Show Blocks
instance Eq Algorithm
instance Ord Algorithm
instance Show Algorithm
instance Show ChunkConfig
instance NFData Blocks
