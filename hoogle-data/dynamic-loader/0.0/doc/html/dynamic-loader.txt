-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | lightweight loader of GHC-based modules or packages
--   
--   This package allows the linking against GHC-compiled object files and
--   shared libraries. Specialized modules are provided for navigating
--   directory structure and dependency checking.
--   
--   No attempt at type-safe loading of symbols is made.
@package dynamic-loader
@version 0.0


-- | A module that implements dynamic loading. You can load and use GHC
--   object files and packages dynamically at runtime.
module System.Plugins.DynamicLoader
data DynamicModule
dm_path :: DynamicModule -> FilePath
data DynamicPackage
dp_path :: DynamicPackage -> FilePath

-- | Dynamically load a shared library (DLL or .so). A shared library can't
--   be unloaded using this interface, if you need it use
--   System.Posix.DynamicLinker instead.
addDLL :: String -> IO ()

-- | Load a module given its name (for instance <tt>Data.FiniteMap</tt>),
--   maybe a path to the base directory and maybe a file extension. If no
--   such path is given the current working directory is used and if no
--   file suffix is given "o" is used.
--   
--   If we have our module hierarchy in <tt>/usr/lib/modules</tt> and we
--   want to load the module <tt>Foo.Bar</tt> located in
--   <tt>/usr/lib/modules/Foo/Bar.o</tt> we could issue the command:
--   
--   <pre>
--   loadModule "Foo.Bar" (Just "/usr/lib/modules") Nothing
--   </pre>
--   
--   If our current directory was <tt>/tmp</tt> and we wanted to load the
--   module <tt>Foo</tt> located in the file <tt>/tmp/Foo.obj</tt> we would
--   write:
--   
--   <pre>
--   loadModule "Foo" Nothing (Just "obj")
--   </pre>
--   
--   If it cannot load the object it will throw an exception.
loadModule :: String -> Maybe FilePath -> Maybe String -> IO DynamicModule

-- | Load a module given its full path and maybe a base directory to use in
--   figuring out the module's hierarchical name. If no base directory is
--   given, it is set to the current directory.
--   
--   For instance if one wants to load module <tt>Foo.Bar</tt> located in
--   <tt>/usr/modules/Foo/Bar.o</tt> one would issue the command:
--   
--   <pre>
--   loadModuleFromPath "/usr/modules/Foo/Bar.o" (Just
--   "/usr/modules")
--   </pre>
--   
--   If it cannot load the object it will throw an exception.
loadModuleFromPath :: FilePath -> Maybe FilePath -> IO DynamicModule

-- | Load a GHC package such as "base" or "text". Takes the package name,
--   maybe a path to the packages, maybe a package prefix and maybe a
--   package suffix.
--   
--   Path defaults to the current directory, package prefix to "HS" and
--   package suffix to "o".
--   
--   This function also loads accompanying cbits-packages. I.e. if you load
--   the package <tt>base</tt> located in <tt>/usr/modules</tt> using
--   <tt>HS</tt> and <tt>o</tt> as prefix and suffix, <tt>loadPackage</tt>
--   will also look for the file <tt>/usr/modules/HSbase_cbits.o</tt> and
--   load it if present.
--   
--   If it fails to load a package it will throw an exception. You will
--   need to resolve functions before you use any functions loaded.
loadPackage :: String -> Maybe FilePath -> Maybe String -> Maybe String -> IO DynamicPackage

-- | Load a GHC package such as "base" or "text". Takes the full path to
--   the package.
--   
--   This function also loads accompanying cbits-packages. I.e. if you load
--   the package <tt>/usr/modules/HSbase.o</tt> it will deduce that
--   <tt>o</tt> is the suffix and <tt>loadPackageFromPath</tt> will then
--   also look for the file <tt>/usr/modules/HSbase_cbits.o</tt> and load
--   it if present.
--   
--   If it fails to load a package it will throw an exception. You will
--   need to resolve functions before you use any functions loaded.
loadPackageFromPath :: FilePath -> IO DynamicPackage

-- | Unload a previously loaded module. If it cannot unload it an exception
--   will be thrown.
unloadModule :: DynamicModule -> IO ()

-- | Unload a package (such as <tt>base</tt>) and its cbits-package (if
--   any). Throws an exception if any unloading fails.
unloadPackage :: DynamicPackage -> IO ()

-- | Load a function from a given module. If the function can't be found an
--   exception will be thrown. You should have called
--   <tt>resolveFunctions</tt> before you call this.
--   
--   Beware that this function isn't type-safe in any way!
loadFunction :: DynamicModule -> String -> IO a

-- | Load a function from package (or module) given the fully qualified
--   name (e.g. <tt>Data.FiniteMap.emptyFM</tt>). If the function can't be
--   found an exception will be thrown. You should have called
--   <tt>resolveFunctions</tt> before you call this.
--   
--   You must take care that you load the function qualified with the name
--   of the module it's defined in! You can for instance not load
--   <tt>Data.Bool.not</tt> because it is only reexported in that module
--   (from GHC.Base).
--   
--   Beware that this function isn't type-safe in any way!
loadQualifiedFunction :: String -> IO a

-- | Resolve all loaded functions. Should be called before any functions
--   are loaded. If it is unable to resolve all functions it will throw an
--   exception.
resolveFunctions :: IO ()

module System.Plugins.Criteria.LoadCriterion
class LoadCriterion (c :: Constraint) t where data family Criterion c t type family Effective c t :: * addDynamicLibrary _ = addDLL resolveSymbols _ = resolveFunctions
addDynamicLibrary :: LoadCriterion c t => Criterion c t -> String -> IO ()
resolveSymbols :: LoadCriterion c t => Criterion c t -> IO ()
loadQualified :: (LoadCriterion c t, c) => Criterion c t -> String -> Effective c t
instance LoadCriterion (Typeable t, MonadIO m) t
instance LoadCriterion (Typeable t) t

module System.Plugins.Criteria.UnsafeCriterion
instance LoadCriterion () t


-- | A module that implements dynamic loading. Has smart handling of
--   dependencies and is thread safe.
module System.Plugins.PathLoader
data LoadedModule
data ModuleType
MT_Module :: ModuleType
MT_Package :: ModuleType

-- | Set the base path used in figuring out module names. If not set the
--   default (i.e. currentDirectory) will be used.
setBasePath :: Maybe FilePath -> IO ()

-- | Add a module dependency. Any dependencies must be added <i>before</i>
--   any calls to loadModule/loadPackage or symbols will not be resolved
--   with a crash as result.
addDependency :: FilePath -> (ModuleType, FilePath) -> IO ()

-- | Set all dependencies. All previous dependencies are removed.
setDependencies :: FilePath -> [(ModuleType, FilePath)] -> IO ()

-- | Delete a module dependency.
delDependency :: FilePath -> (ModuleType, FilePath) -> IO ()

-- | Delete all dependencies for a module. Same behaviour as
--   <tt>setDependencies path []</tt>.
delAllDeps :: FilePath -> IO ()

-- | Do something with the current dependencies of a module. You can't use
--   (blocking) functions from this module in the function given to
--   withDependencies. If you do so, a deadlock will occur.
withDependencies :: Loadable c t t' => Criterion c t -> FilePath -> (Maybe [(ModuleType, FilePath)] -> Effective c t) -> Effective c t

-- | Load a module (or package) and modules (or packages) it depends on. It
--   is possible to load a module many times without any error occuring.
--   However to unload a module one needs to call <tt>unloadModule</tt> the
--   same number of times.
--   
--   Before loading any modules you should add wich dependencies it has
--   with addDependency (and which dependencies the modules upon which it
--   depends have).
--   
--   If the module already has been loaded nothing will be done except
--   updating the reference count. I.e. if dependencies have been updated
--   they will be ignored until the module has been completely unloaded and
--   loaded again.
--   
--   If any error occurs an exception is thrown.
loadModule :: FilePath -> ModuleType -> IO LoadedModule

-- | Unload a module and all modules it depends on. This unloading only
--   occurs if the module isn't needed by any other libraries or hasn't
--   been loaded more than once. An exception is thrown in case of error.
unloadModule :: LoadedModule -> IO ()

-- | Same as <tt>unloadModule</tt> just doesn't trow any exceptions on
--   error.
unloadModuleQuiet :: LoadedModule -> IO ()

-- | Load a function from a module. It cannot load functions from packages
--   and will throw an exception if one tries to do so. Also throws if an
--   error occurs.
--   
--   It seems (but I'm unsure) like any functions loaded will continue to
--   be valid even after the module it resides in is unloaded. It will also
--   still be valid if a new version of that module is loaded (it will thus
--   still call the old function).
loadFunction :: Loadable c t t' => Criterion c t -> LoadedModule -> String -> Effective c t

-- | Load a qualified function from a module or package. It will throw an
--   exception if an error occurs. Same restriction as for
--   DynamicLinker.loadQualifiedFunction applies here too.
loadQualifiedFunction :: Loadable c t t' => Criterion c t -> String -> Effective c t

-- | Give the modification time for a loded module. Will throw an exception
--   if the module isn't loaded.
moduleLoadedAt :: LoadedModule -> IO UTCTime
loadedModules :: IO [String]

-- | Dynamically load a shared library (DLL or .so). A shared library can't
--   be unloaded using this interface, if you need it use
--   System.Posix.DynamicLinker instead.
addDLL :: String -> IO ()
instance Eq ModuleType
instance Ord ModuleType
instance Show ModuleType


-- | A module that implements dynamic loading. Has smart handling of
--   dependencies and is thread safe.
module System.Plugins.NameLoader
type Module = String
data LoadedModule
data ModuleType
MT_Module :: ModuleType
MT_Package :: ModuleType

-- | Set the environment in wich all module loading will reside. If this
--   function isn't called the defaults will be used.
--   
--   The parameters are: Path to modules, module suffix, path to packages,
--   package prefix and package suffix. The paths will default to current
--   directory and the rest (in order) to <i>o</i>, <i>HS</i> and <i>o</i>.
setEnvironment :: Maybe FilePath -> Maybe String -> Maybe FilePath -> Maybe String -> Maybe String -> IO ()

-- | Add a module dependency. Any dependencies must be added <i>before</i>
--   any calls to loadModule or symbols will not be resolved with a crash
--   as result.
addDependency :: Module -> Module -> IO ()

-- | Delete a module dependency.
delDependency :: Module -> Module -> IO ()

-- | Delete all dependencies for a module.
delAllDeps :: Module -> IO ()

-- | Do something with the current dependencies of a module. You can't use
--   (blocking) functions from this module in the function given to
--   withDependencies. If you do so, a deadlock will occur.
withDependencies :: Loadable c t t' => Criterion c t -> Module -> (Maybe [Module] -> Effective c t) -> Effective c t

-- | Load a module (or package) and modules it depends on. It is possible
--   to load a module many times without any error occuring. However to
--   unload a module one needs to call <tt>unloadModule</tt> the same
--   number of times.
--   
--   Before loading any modules you should add wich dependencies it has
--   with addDependency (and which dependencies the modules upon which it
--   depends have).
--   
--   If the module already has been loaded nothing will be done except
--   updating the reference count. I.e. if dependencies have been updated
--   they will be ignored until the module has been completely unloaded and
--   loaded again.
--   
--   It treats names begining with uppercase letters (such as
--   <tt>Foo.Bar</tt>) as modules and other names (such as <tt>base</tt>)
--   as packages.
--   
--   If any error occurs an exception is thrown.
loadModule :: Module -> IO LoadedModule

-- | Unload a module and all modules it depends on. This unloading only
--   occurs if the module isn't needed by any other libraries or hasn't
--   been loaded more than once. An exception is thrown in case of error.
unloadModule :: LoadedModule -> IO ()

-- | Same as <tt>unloadModule</tt> just doesn't trow any exceptions on
--   error.
unloadModuleQuiet :: LoadedModule -> IO ()

-- | Load a function from a module. It cannot load functions from packages
--   and will throw an exception if one tries to do so. Also throws if an
--   error occurs.
--   
--   It seems (but I'm unsure) like any functions loaded will continue to
--   be valid even after the module it resides in is unloaded. It will also
--   still be valid if a new version of that module is loaded (it will thus
--   still call the old function).
loadFunction :: Loadable c t t' => Criterion c t -> LoadedModule -> String -> Effective c t

-- | Give the modification time for a loded module. Will throw an exception
--   if the module isn't loaded.
moduleLoadedAt :: LoadedModule -> IO UTCTime
loadedModules :: IO [String]
sm_path :: NameModule -> FilePath

-- | Dynamically load a shared library (DLL or .so). A shared library can't
--   be unloaded using this interface, if you need it use
--   System.Posix.DynamicLinker instead.
addDLL :: String -> IO ()
instance Eq ModuleType
instance Ord ModuleType
instance Show ModuleType
