-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SAT encoding monad
--   
@package satchmo
@version 2.9.7.3


-- | this module just defines types for formulas, it is not meant to
--   contain efficient implementations for formula manipulation.
module Satchmo.Data
data CNF
cnf :: [Clause] -> CNF
clauses :: CNF -> [Clause]
size :: CNF -> Int
data Clause
clause :: [Literal] -> Clause
literals :: Clause -> [Literal]
data Literal
literal :: Bool -> Variable -> Literal
nicht :: Literal -> Literal
positive :: Literal -> Bool
variable :: Literal -> Variable
type Variable = Int
instance Eq Literal
instance Ord Literal
instance Eq Clause
instance Ord Clause
instance Show CNF
instance Show Clause
instance Show Literal

module Satchmo.Code
class Monad m => Decode m c a
decode :: Decode m c a => c -> m a
instance (Ord i, Decode m c a) => Decode m (Map i c) (Map i a)
instance (Ix i, Decode m c a) => Decode m (Array i c) (Array i a)
instance Decode m a b => Decode m (Maybe a) (Maybe b)
instance Decode m c a => Decode m [c] [a]
instance (Decode m c a, Decode m d b) => Decode m (c, d) (a, b)
instance Monad m => Decode m () ()

module Satchmo.MonadSAT
class (MonadFix m, Applicative m, Monad m) => MonadSAT m where type family Decoder m :: * -> *
fresh, fresh_forall :: MonadSAT m => m Literal
emit :: MonadSAT m => Clause -> m ()
note :: MonadSAT m => String -> m ()
decode_variable :: MonadSAT m => Variable -> Decoder m Bool
type Weight = Int
data Header
Header :: !Int -> !Int -> ![Int] -> Header
numClauses :: Header -> !Int
numVars :: Header -> !Int
universals :: Header -> ![Int]
instance Show Header

module Satchmo.Boolean
class (MonadFix m, Applicative m, Monad m) => MonadSAT m where type family Decoder m :: * -> *
fresh, fresh_forall :: MonadSAT m => m Literal
emit :: MonadSAT m => Clause -> m ()
note :: MonadSAT m => String -> m ()
decode_variable :: MonadSAT m => Variable -> Decoder m Bool
data Boolean
Boolean :: Literal -> Boolean
encode :: Boolean -> Literal
Constant :: !Bool -> Boolean
value :: Boolean -> !Bool
type Booleans = [Boolean]
boolean :: MonadSAT m => m (Boolean)
exists :: MonadSAT m => m (Boolean)
forall :: MonadSAT m => m (Boolean)
constant :: MonadSAT m => Bool -> m (Boolean)
not :: Boolean -> Boolean
monadic :: Monad m => ([a] -> m b) -> ([m a] -> m b)
assertOr :: MonadSAT m => [Boolean] -> m ()
assertAnd :: MonadSAT m => [Boolean] -> m ()
assert :: MonadSAT m => [Boolean] -> m ()
constant :: MonadSAT m => Bool -> m (Boolean)
and :: MonadSAT m => [Boolean] -> m Boolean
or :: MonadSAT m => [Boolean] -> m Boolean
xor :: MonadSAT m => [Boolean] -> m Boolean
xor2 :: MonadSAT m => Boolean -> Boolean -> m Boolean
equals2 :: MonadSAT m => Boolean -> Boolean -> m Boolean
equals :: MonadSAT m => [Boolean] -> m Boolean
implies :: MonadSAT m => Boolean -> Boolean -> m Boolean
(||) :: MonadSAT m => Boolean -> Boolean -> m Boolean
(&&) :: MonadSAT m => Boolean -> Boolean -> m Boolean

-- | implement the function by giving a full CNF that determines the
--   outcome
fun2 :: MonadSAT m => (Bool -> Bool -> Bool) -> Boolean -> Boolean -> m Boolean

-- | implement the function by giving a full CNF that determines the
--   outcome
fun3 :: MonadSAT m => (Bool -> Bool -> Bool -> Bool) -> Boolean -> Boolean -> Boolean -> m Boolean
ifThenElse :: MonadSAT m => Boolean -> m Boolean -> m Boolean -> m Boolean
ifThenElseM :: MonadSAT m => m Boolean -> m Boolean -> m Boolean -> m Boolean
assert_fun2 :: MonadSAT m => (Bool -> Bool -> Bool) -> Boolean -> Boolean -> m ()
assert_fun3 :: MonadSAT m => (Bool -> Bool -> Bool -> Bool) -> Boolean -> Boolean -> Boolean -> m ()
monadic :: Monad m => ([a] -> m b) -> ([m a] -> m b)


-- | functions in this module have no extra variables but exponential cost.
module Satchmo.Counting.Direct
atleast :: MonadSAT m => Int -> [Boolean] -> m Boolean
atmost :: MonadSAT m => Int -> [Boolean] -> m Boolean
exactly :: MonadSAT m => Int -> [Boolean] -> m Boolean

-- | (and ys) implies (atmost k xs)
assert_implies_atmost :: MonadSAT m => [Boolean] -> Int -> [Boolean] -> m ()

-- | asserting that (and ys) implies (exactly k xs)
assert_implies_exactly :: MonadSAT m => [Boolean] -> Int -> [Boolean] -> m ()

module Satchmo.Unary.Op.Common
iszero :: MonadSAT m => Number -> m Boolean
equals :: MonadSAT m => Number -> Number -> m Boolean
lt :: MonadSAT m => Number -> Number -> m Boolean
le :: MonadSAT m => Number -> Number -> m Boolean
ge :: MonadSAT m => Number -> Number -> m Boolean
eq :: MonadSAT m => Number -> Number -> m Boolean
gt :: MonadSAT m => Number -> Number -> m Boolean
min :: MonadSAT m => Number -> Number -> m Number
max :: MonadSAT m => Number -> Number -> m Number

-- | minimum (x:xs) = foldM min x xs
minimum :: MonadSAT m => [Number] -> m Number

-- | maximum (x:xs) = foldM max x xs
maximum :: MonadSAT m => [Number] -> m Number

-- | when f is False, switch off all bits
select :: MonadSAT m => Boolean -> Number -> m Number

-- | when p is True, switch ON all bits
antiselect :: MonadSAT m => Boolean -> Number -> m Number

-- | for both "add" methods: if first arg is Nothing, then result length is
--   sum of argument lengths (cannot overflow). else result is cut off
--   (overflow =&gt; unsatisfiable)
add_quadratic :: MonadSAT m => Maybe Int -> Number -> Number -> m Number

-- | works for all widths
add_by_odd_even_merge :: MonadSAT m => Maybe Int -> Number -> Number -> m Number

-- | will fill up the input such that length is a power of two. it seems to
--   be hard to improve this, cf
--   <a>http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi/2009/CS/CS-2009-07</a>
add_by_bitonic_sort :: MonadSAT m => Maybe Int -> Number -> Number -> m Number

module Satchmo.Unary.Op.Flexible

-- | Unary addition. Output bit length is sum of input bit lengths.
add :: MonadSAT m => Number -> Number -> m Number
add_quadratic :: MonadSAT m => Number -> Number -> m Number
add_by_odd_even_merge :: MonadSAT m => Number -> Number -> m Number
add_by_bitonic_sort :: MonadSAT m => Number -> Number -> m Number

module Satchmo.Unary
data Number

-- | contents is [ 1 .. 1 0 .. 0 ] number of 1 is value of number
bits :: Number -> [Boolean]
make :: [Boolean] -> Number
width :: Number -> Int

-- | declare a number with range (0, w)
number :: MonadSAT m => Int -> m Number
constant :: MonadSAT m => Integer -> m Number

module Satchmo.Unary.Op.Fixed
add :: MonadSAT m => Number -> Number -> m Number
add_quadratic :: MonadSAT m => Number -> Number -> m Number
add_by_odd_even_merge :: MonadSAT m => Number -> Number -> m Number
add_by_bitonic_sort :: MonadSAT m => Number -> Number -> m Number

module Satchmo.Array
data Array i v
array :: Ix i => (i, i) -> [(i, v)] -> Array i v
unknown :: (Ix i, Functor f, Monad f) => (i, i) -> f v -> f (Array i v)
constant :: Array i v -> Array i v
(!) :: Ix i => Array i e -> i -> e
elems :: Ix i => Array i e -> [e]
indices :: Ix i => Array i e -> [i]
bounds :: Ix i => Array i e -> (i, i)
range :: Ix a => (a, a) -> [a]
assocs :: Ix i => Array i e -> [(i, e)]
instance (Functor m, Ix i, Decode m c d) => Decode m (Array i c) (Array i d)

module Satchmo.Numeric
class Constant a
constant :: (Constant a, MonadSAT m) => Integer -> m a
class Create a
create :: (Create a, MonadSAT m) => Int -> m a
class Numeric a
equal :: (Numeric a, MonadSAT m) => a -> a -> m Boolean
greater_equal :: (Numeric a, MonadSAT m) => a -> a -> m Boolean
plus :: (Numeric a, MonadSAT m) => a -> a -> m a
minus :: (Numeric a, MonadSAT m) => a -> a -> m a
times :: (Numeric a, MonadSAT m) => a -> a -> m a

module Satchmo.Integer.Difference
data Number a
Difference :: a -> a -> Number a
top :: Number a -> a
bot :: Number a -> a
instance Numeric a => Numeric (Number a)
instance Create a => Create (Number a)
instance Constant a => Constant (Number a)
instance Decode m a Integer => Decode m (Number a) Integer

module Satchmo.Polynomial.Numeric
data Poly a
Poly :: [a] -> Poly a
derive :: (Constant a, Numeric a, MonadSAT m) => Poly a -> m (Poly a)
constantTerm :: Poly a -> a
polynomial :: (Create a, MonadSAT m) => Int -> Int -> m (Poly a)
compose :: (Constant a, Create a, Numeric a, MonadSAT m) => Poly a -> Poly a -> m (Poly a)
fullZip :: [a] -> [b] -> [(Maybe a, Maybe b)]
instance Show a => Show (Poly a)
instance (Create a, Constant a, Numeric a) => Numeric (Poly a)
instance Decode m a b => Decode m (Poly a) (Poly b)

module Satchmo.SAT.Tmpfile
data SAT a
data Header
Header :: !Int -> !Int -> ![Int] -> Header
numClauses :: Header -> !Int
numVars :: Header -> !Int
universals :: Header -> ![Int]
fresh, fresh_forall :: MonadSAT m => m Literal
fresh, fresh_forall :: MonadSAT m => m Literal
emit :: MonadSAT m => Clause -> m ()
type Weight = Int
sat :: SAT a -> IO (ByteString, Header, a)
instance MonadState Accu SAT
instance MonadReader Handle SAT
instance Monad SAT
instance MonadIO SAT
instance Functor SAT
instance Applicative SAT
instance MonadFix SAT
instance MonadSAT SAT
instance Decode (Reader (Array Variable Bool)) Boolean Bool

module Satchmo.SAT

module Satchmo.Counting.Unary
atleast :: MonadSAT m => Int -> [Boolean] -> m Boolean
atmost :: MonadSAT m => Int -> [Boolean] -> m Boolean
exactly :: MonadSAT m => Int -> [Boolean] -> m Boolean


-- | Re-exports <tt>Satchmo.Counting.Unary</tt> for backwards
--   compatibility.
module Satchmo.Counting

module Satchmo.Binary.Op.Common
iszero :: MonadSAT m => Number -> m Boolean
equals :: MonadSAT m => Number -> Number -> m Boolean
lt :: MonadSAT m => Number -> Number -> m Boolean
le :: MonadSAT m => Number -> Number -> m Boolean
ge :: MonadSAT m => Number -> Number -> m Boolean
eq :: MonadSAT m => Number -> Number -> m Boolean
gt :: MonadSAT m => Number -> Number -> m Boolean
full_adder :: MonadSAT m => Boolean -> Boolean -> Boolean -> m (Boolean, Boolean)
half_adder :: MonadSAT m => Boolean -> Boolean -> m (Boolean, Boolean)

-- | i flag is True, then the number itself, and zero otherwise.
select :: MonadSAT m => Boolean -> Number -> m Number
max :: MonadSAT m => Number -> Number -> m Number
min :: MonadSAT m => Number -> Number -> m Number
maximum :: MonadSAT m => [Number] -> m Number

module Satchmo.Binary.Op.Times
times :: MonadSAT m => Maybe Int -> Number -> Number -> m Number
dot_product :: MonadSAT m => (Maybe Int) -> [Number] -> [Number] -> m Number
data Overflow
Ignore :: Overflow
Refuse :: Overflow
times' :: (MonadSAT m, Ord k, Num k, Enum k) => Overflow -> Maybe k -> [Boolean] -> [Boolean] -> m [Boolean]


-- | operations from this module cannot overflow. instead they increase the
--   bit width.
module Satchmo.Binary.Op.Flexible
add :: MonadSAT m => Number -> Number -> m Number
times :: MonadSAT m => Number -> Number -> m Number
dot_product :: MonadSAT m => [Number] -> [Number] -> m Number
add_with_carry :: MonadSAT m => Boolean -> Booleans -> Booleans -> m (Booleans, Boolean)
times1 :: MonadSAT m => Boolean -> Number -> m Number

-- | multiply by 2
shift :: MonadSAT m => Number -> m Number
data Number
bits :: Number -> [Boolean]
make :: [Boolean] -> Number
width :: Number -> Int

-- | declare a number variable (bit width)
number :: MonadSAT m => Int -> m Number

-- | Declare a number constant
constant :: MonadSAT m => Integer -> m Number

-- | <tt>constantWidth w</tt> declares a number constant using at least
--   <tt>w</tt> bits
constantWidth :: MonadSAT m => Int -> Integer -> m Number
fromBinary :: [Bool] -> Integer
toBinary :: Integer -> [Bool]

-- | <tt>toBinaryWidth w</tt> converts to binary using at least <tt>w</tt>
--   bits
toBinaryWidth :: Int -> Integer -> [Bool]

module Satchmo.Binary

module Satchmo.Integer
data Number
make :: [Boolean] -> Number

-- | declare a number variable (bit width)
number :: MonadSAT m => Int -> m Number

-- | declare a number constant
constant :: MonadSAT m => Int -> Integer -> m Number
decode :: (Decode m Boolean Bool, Integral b) => b -> Number -> m Integer

-- | lsb first, using two's complement
bits :: Number -> [Boolean]
width :: Number -> Int
sign :: Number -> Boolean

-- | negate. Unsatisfiable if value is lowest negatve.
negate :: MonadSAT m => Number -> m Number
add :: MonadSAT m => Number -> Number -> m Number
sub :: MonadSAT m => Number -> Number -> m Number
times :: MonadSAT m => Number -> Number -> m Number
gt :: MonadSAT m => Number -> Number -> m Boolean
ge :: MonadSAT m => Number -> Number -> m Boolean
eq :: MonadSAT m => Number -> Number -> m Boolean


-- | operations with fixed bit width. still they are non-overflowing: if
--   overflow occurs, the constraints are not satisfiable. the bit width of
--   the result of binary operations is the max of the bit width of the
--   inputs.
module Satchmo.Binary.Op.Fixed

-- | give only lower k bits, upper bits must be zero, (else unsatisfiable)
restricted :: MonadSAT m => Int -> Number -> m Number

-- | result bit width is max of argument bit widths. if overflow occurs,
--   then formula is unsatisfiable.
add :: MonadSAT m => Number -> Number -> m Number

-- | result bit width is at most max of argument bit widths. if overflow
--   occurs, then formula is unsatisfiable.
times :: MonadSAT m => Number -> Number -> m Number
dot_product :: MonadSAT m => Int -> [Number] -> [Number] -> m Number
dot_product' :: MonadSAT m => [Number] -> [Number] -> m Number
data Number
bits :: Number -> [Boolean]
make :: [Boolean] -> Number
width :: Number -> Int

-- | declare a number variable (bit width)
number :: MonadSAT m => Int -> m Number

-- | Declare a number constant
constant :: MonadSAT m => Integer -> m Number

-- | <tt>constantWidth w</tt> declares a number constant using at least
--   <tt>w</tt> bits
constantWidth :: MonadSAT m => Int -> Integer -> m Number
fromBinary :: [Bool] -> Integer
toBinary :: Integer -> [Bool]

-- | <tt>toBinaryWidth w</tt> converts to binary using at least <tt>w</tt>
--   bits
toBinaryWidth :: Int -> Integer -> [Bool]
restrictedTimes :: MonadSAT m => Number -> Number -> m Number


-- | Operations with fixed bit width. Still they are non-overflowing: if
--   overflow occurs, the constraints are not satisfiable. The bit width of
--   the result of binary operations is the max of the bit width of the
--   inputs.
module Satchmo.BinaryTwosComplement.Op.Fixed
add :: MonadSAT m => Number -> Number -> m Number
subtract :: MonadSAT m => Number -> Number -> m Number
times :: MonadSAT m => Number -> Number -> m Number
increment :: MonadSAT m => Number -> m Number
negate :: MonadSAT m => Number -> m Number
linear :: MonadSAT m => Number -> Number -> Number -> m Number
data Number
bits :: Number -> [Boolean]

-- | Make a number from its binary representation
fromBooleans :: [Boolean] -> Number

-- | Get a number variable of given bit width
number :: MonadSAT m => Int -> m Number

-- | Convert to unsigned number (see <a>Satchmo.Binary.Op.Flexible</a>)
toUnsigned :: Number -> Number

-- | Convert from unsigned number (see <a>Satchmo.Binary.Op.Flexible</a>).
--   The result is interpreted as a positive or negative number, depending
--   on its most significant bit.
fromUnsigned :: Number -> Number

-- | Get bit width
width :: Number -> Int

-- | <tt>isNull n == True</tt> if <tt>width n == 0</tt>
isNull :: Number -> Bool

-- | Most significant bit
msb :: Number -> Boolean

-- | Get a number constant
constant :: MonadSAT m => Integer -> m Number

-- | <tt>constantWidth w</tt> declares a number constant using at least
--   <tt>w</tt> bits
constantWidth :: MonadSAT m => Int -> Integer -> m Number
equals :: MonadSAT m => Number -> Number -> m Boolean
eq :: MonadSAT m => Number -> Number -> m Boolean
lt :: MonadSAT m => Number -> Number -> m Boolean
le :: MonadSAT m => Number -> Number -> m Boolean
ge :: MonadSAT m => Number -> Number -> m Boolean
gt :: MonadSAT m => Number -> Number -> m Boolean
positive :: MonadSAT m => Number -> m Boolean
negative :: MonadSAT m => Number -> m Boolean
nonNegative :: MonadSAT m => Number -> m Boolean

module Satchmo.BinaryTwosComplement

module Satchmo.Polynomial

-- | polynomial in one variable, coefficients starting from degree zero
data Poly a
Poly :: [a] -> Poly a
type NumPoly = Poly Number
polynomial :: MonadSAT m => Int -> Int -> m NumPoly
constant :: MonadSAT m => Integer -> m NumPoly
fromCoefficients :: MonadSAT m => Int -> [Integer] -> m NumPoly
isNull :: Poly a -> Bool
null :: Poly a
constantTerm :: Poly a -> a
coefficients :: Poly a -> [a]
equals :: MonadSAT m => NumPoly -> NumPoly -> m Boolean
ge :: MonadSAT m => NumPoly -> NumPoly -> m Boolean
gt :: MonadSAT m => NumPoly -> NumPoly -> m Boolean
add :: MonadSAT m => NumPoly -> NumPoly -> m NumPoly
times :: MonadSAT m => NumPoly -> NumPoly -> m NumPoly
subtract :: MonadSAT m => NumPoly -> NumPoly -> m NumPoly

-- | <pre>
--   compose p(x) q(x) = p(q(x))
--   </pre>
compose :: MonadSAT m => NumPoly -> NumPoly -> m NumPoly

-- | <tt>apply p x</tt> applies number <tt>x</tt> to polynomial <tt>p</tt>
apply :: MonadSAT m => NumPoly -> Number -> m Number

-- | <tt>derive p</tt> computes the derivation of <tt>p</tt>
derive :: MonadSAT m => NumPoly -> m NumPoly
instance Eq a => Eq (Poly a)
instance Ord a => Ord (Poly a)
instance Show a => Show (Poly a)
instance Decode m a Integer => Decode m (Poly a) (Poly Integer)

module Satchmo.PolynomialSOS
nonNegative :: MonadSAT m => Int -> Int -> Int -> NumPoly -> m Boolean
positive :: MonadSAT m => Int -> Int -> Int -> NumPoly -> m Boolean
strictlyMonotone :: MonadSAT m => Int -> Int -> Int -> NumPoly -> m Boolean

module Satchmo.BinaryTwosComplement.Numeric
instance Numeric Number
instance Create Number
instance Constant Number

module Satchmo.PolynomialN
type Coefficient a = a
type Exponents = [Integer]
data PolynomialN a
type NumPolynomialN = PolynomialN Number
fromMonomials :: MonadSAT m => Int -> [(Coefficient Integer, Exponents)] -> m NumPolynomialN
add :: MonadSAT m => NumPolynomialN -> NumPolynomialN -> m NumPolynomialN
equals :: MonadSAT m => NumPolynomialN -> NumPolynomialN -> m Boolean
instance Show a => Show (Monomial a)
instance Show a => Show (PolynomialN a)
instance Decode m a Integer => Decode m (PolynomialN a) (PolynomialN Integer)
instance Decode m a Integer => Decode m (Monomial a) (Monomial Integer)

module Satchmo.Binary.Numeric
instance Numeric Number
instance Create Number
instance Constant Number

module Satchmo.Counting.Binary
atleast :: MonadSAT m => Int -> [Boolean] -> m Boolean
atmost :: MonadSAT m => Int -> [Boolean] -> m Boolean
exactly :: MonadSAT m => Int -> [Boolean] -> m Boolean
count :: MonadSAT m => [Boolean] -> m Number

module Satchmo.Relation.Data
data Relation a b
relation :: (Ix a, Ix b, MonadSAT m) => ((a, b), (a, b)) -> m (Relation a b)
build :: (Ix a, Ix b) => ((a, b), (a, b)) -> [((a, b), Boolean)] -> Relation a b
identity :: (Ix a, MonadSAT m) => ((a, a), (a, a)) -> m (Relation a a)
bounds :: (Ix a, Ix b) => Relation a b -> ((a, b), (a, b))
(!) :: (Ix t1, Ix t) => Relation t t1 -> (t, t1) -> Boolean
indices :: (Ix t1, Ix t) => Relation t t1 -> [(t, t1)]
assocs :: (Ix t1, Ix t) => Relation t t1 -> [((t, t1), Boolean)]
elems :: (Ix t1, Ix t) => Relation t t1 -> [Boolean]
table :: (Enum a, Ix a, Enum b, Ix b) => Array (a, b) Bool -> String
instance (Ix a, Ix b, Decode m Boolean Bool) => Decode m (Relation a b) (Array (a, b) Bool)

module Satchmo.Relation.Op
mirror :: (Ix a, Ix b) => Relation a b -> Relation b a
union :: (Ix a, Ix b, MonadSAT m) => Relation a b -> Relation a b -> m (Relation a b)
complement :: (Ix a, Ix b) => Relation a b -> Relation a b
product :: (Ix a, Ix b, Ix c, MonadSAT m) => Relation a b -> Relation b c -> m (Relation a c)
power :: (Ix a, MonadSAT m) => Int -> Relation a a -> m (Relation a a)
intersection :: (Ix a, Ix b, MonadSAT m) => Relation a b -> Relation a b -> m (Relation a b)

module Satchmo.Relation.Prop
implies :: (Ix a, Ix b, MonadSAT m) => Relation a b -> Relation a b -> m Boolean
symmetric :: (Ix a, MonadSAT m) => Relation a a -> m Boolean
transitive :: (Ix a, MonadSAT m) => Relation a a -> m Boolean
irreflexive :: (Ix a, MonadSAT m) => Relation a a -> m Boolean
reflexive :: (Ix a, MonadSAT m) => Relation a a -> m Boolean
regular :: (Ix a, MonadSAT m) => Int -> Relation a a -> m Boolean
empty :: (Ix a, Ix b, MonadSAT m) => Relation a b -> m Boolean
complete :: (MonadSAT m, Ix b, Ix a) => Relation a b -> m Boolean
disjoint :: (MonadSAT m, Ix b, Ix a) => Relation a b -> Relation a b -> m Boolean
equals :: (MonadSAT m, Ix b, Ix a) => Relation a b -> Relation a b -> m Boolean

module Satchmo.Relation

module Satchmo.Set.Data
data Set a

-- | allocate an unknown subset of these elements
unknown :: (MonadSAT m, Ord a) => [a] -> m (Set a)
unknownSingleton :: (MonadSAT m, Ord k) => [k] -> m (Set k)
constant :: (MonadSAT m, Ord a) => [a] -> m (Set a)
member :: (MonadSAT m, Ord k) => k -> Set k -> m Boolean
keys :: Set k -> [k]
keysSet :: Set k -> Set k
keys :: Set k -> [k]
assocs :: Set k -> [(k, Boolean)]
elems :: Set k -> [Boolean]
all2 :: (MonadSAT m, Ord k) => (Boolean -> Boolean -> m Boolean) -> Set k -> Set k -> m Boolean
common2 :: (MonadSAT f, Ord a) => (Boolean -> Boolean -> f Boolean) -> Set a -> Set a -> f (Set a)
instance (Functor m, Decode m Boolean Bool, Ord a) => Decode m (Set a) (Set a)

module Satchmo.Set.Op
null :: (Ord a, MonadSAT m) => Set a -> m Boolean
equals :: (Ord a, MonadSAT m) => Set a -> Set a -> m Boolean
isSubsetOf :: (Ord a, MonadSAT m) => Set a -> Set a -> m Boolean
isSupersetOf :: (Ord a, MonadSAT m) => Set a -> Set a -> m Boolean
isSingleton :: (Ord a, MonadSAT m) => Set a -> m Boolean
isDisjoint :: (Ord a, MonadSAT m) => Set a -> Set a -> m Boolean
union :: (Ord a, MonadSAT m) => Set a -> Set a -> m (Set a)
intersection :: (Ord a, MonadSAT m) => Set a -> Set a -> m (Set a)
difference :: (Ord a, MonadSAT m) => Set a -> Set a -> m (Set a)

module Satchmo.Set

module Satchmo.Map.Data
data Map a b

-- | allocate an unknown map with this domain
unknown :: (MonadSAT m, Ord a) => [a] -> m b -> m (Map a b)
constant :: (MonadSAT m, Ord a) => [(a, c)] -> (c -> m b) -> m (Map a b)
(!) :: Ord k => Map k a -> k -> a
elems :: Map k a -> [a]
keys :: Map k a -> [k]
toList :: Map k a -> [(k, a)]
fromList :: Ord a => [(a, b)] -> Map a b
map :: (a1 -> b) -> Map a a1 -> Map a b
mapWithKey :: (a -> a1 -> b) -> Map a a1 -> Map a b
instance (Functor m, Decode m b c, Ord a) => Decode m (Map a b) (Map a c)

module Satchmo.Map

module Satchmo.SAT.Mini
data SAT a
fresh, fresh_forall :: MonadSAT m => m Literal
emit :: MonadSAT m => Clause -> m ()
solve :: SAT (SAT a) -> IO (Maybe a)
solve_with_timeout :: Maybe Int -> SAT (SAT a) -> IO (Maybe a)
instance Enum Lit
instance Decode SAT Boolean Bool
instance MonadSAT SAT
instance MonadFix SAT
instance Applicative SAT
instance Monad SAT
instance Functor SAT
