-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Repackages standard type classes with the ConstraintKinds extension
--   
--   This module provides more flexible versions of common type classes
--   that use the ConstraintKinds extension. This allows us to make types
--   that require constraints instances of the popular classes. For
--   example, we reimplement Functor and Foldable using the ContraintKinds
--   style. This allows us to manipulate lists and unboxed vectors using
--   the same functions.
--   
--   This library needs a lot of work before it can be considered ready for
--   others to use. Right now, only those instances needed by the HLearn
--   library have been implemented in this library.
@package ConstraintKinds
@version 1.3.0

module Control.ConstraintKinds.Functor
class Functor f where type family FunctorConstraint f x :: Constraint type instance FunctorConstraint f x = ()
fmap :: (Functor f, FunctorConstraint f a, FunctorConstraint f b) => (a -> b) -> f a -> f b

-- | An infix synonym for <a>fmap</a>.
(<$>) :: (Functor f, FunctorConstraint f a, FunctorConstraint f b) => (a -> b) -> f a -> f b
instance Functor Vector
instance Functor Vector
instance Functor ReadPrec
instance Functor []

module Control.ConstraintKinds.Pointed
class Functor f => Pointed f where type family PointedConstraint f x :: Constraint type instance PointedConstraint f x = FunctorConstraint f x
point :: (Pointed f, PointedConstraint f a) => a -> f a
instance Pointed Vector
instance Pointed Vector
instance Pointed []

module Control.ConstraintKinds.Foldable
class Foldable t where type family FoldableConstraint t x :: Constraint type instance FoldableConstraint t x = () fold = foldMap id foldMap f = foldr (mappend . f) mempty
foldr :: (Foldable t, FoldableConstraint t a) => (a -> b -> b) -> b -> t a -> b
foldr' :: (Foldable t, FoldableConstraint t a) => (a -> b -> b) -> b -> t a -> b
foldl :: (Foldable t, FoldableConstraint t b) => (a -> b -> a) -> a -> t b -> a
foldl' :: (Foldable t, FoldableConstraint t b) => (a -> b -> a) -> a -> t b -> a
foldr1 :: (Foldable t, FoldableConstraint t a) => (a -> a -> a) -> t a -> a
foldl1 :: (Foldable t, FoldableConstraint t a) => (a -> a -> a) -> t a -> a
fold :: (Foldable t, FoldableConstraint t m, Monoid m) => t m -> m
foldMap :: (Foldable t, FoldableConstraint t a, FoldableConstraint t m, Monoid m) => (a -> m) -> t a -> m
toList :: (Foldable t, FoldableConstraint t [a], FoldableConstraint t a) => t a -> [a]
instance Foldable DList
instance Foldable Vector
instance Foldable Vector
instance Foldable []

module Control.ConstraintKinds.Applicative
class Pointed f => Applicative f where type family ApplicativeConstraint f x :: Constraint type instance ApplicativeConstraint f x = PointedConstraint f x
(<*>) :: (Applicative f, ApplicativeConstraint f a, ApplicativeConstraint f b) => f (a -> b) -> f a -> f b

-- | Lift a function to actions. This function may be used as a value for
--   <a>fmap</a> in a <a>Functor</a> instance. liftA ::
--   (ApplicativeConstraint f a, ApplicativeConstraint f (a -&gt; b),
--   ApplicativeConstraint f b, Applicative f) =&gt; (a -&gt; b) -&gt; f a
--   -&gt; f b
liftA :: (ApplicativeConstraint f a, ApplicativeConstraint f b, PointedConstraint f (a -> b), Applicative f) => (a -> b) -> f a -> f b

-- | Lift a binary function to actions. liftA2 :: (FunctorConstraint f a,
--   FunctorConstraint f (b -&gt; c), Applicative f) =&gt; (a -&gt; b -&gt;
--   c) -&gt; f a -&gt; f b -&gt; f c
liftA2 :: (ApplicativeConstraint f a, ApplicativeConstraint f b, FunctorConstraint f a1, FunctorConstraint f (a -> b), Applicative f) => (a1 -> a -> b) -> f a1 -> f a -> f b

-- | Lift a ternary function to actions. liftA3 :: (FunctorConstraint f a,
--   FunctorConstraint f (b -&gt; c -&gt; d), Applicative f)=&gt; (a -&gt;
--   b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d
liftA3 :: (ApplicativeConstraint f a, ApplicativeConstraint f b, ApplicativeConstraint f a1, ApplicativeConstraint f (a -> b), FunctorConstraint f a2, FunctorConstraint f (a1 -> a -> b), Applicative f) => (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> f b
instance Applicative Vector
instance Applicative []

module Control.ConstraintKinds.Monad
ifThenElse :: Bool -> a -> a -> a
class Functor m => Monad m where fail = error join m = m >>= id a >>= b = join $ fmap b a m >> k = m >>= \ _ -> k
fail :: Monad m => String -> m a
return :: (Monad m, FunctorConstraint m a) => a -> m a
join :: (Monad m, FunctorConstraint m a, FunctorConstraint m (m a)) => m (m a) -> m a
(>>=) :: (Monad m, FunctorConstraint m a, FunctorConstraint m b, FunctorConstraint m (m b)) => m a -> (a -> m b) -> m b
(>>) :: (Monad m, FunctorConstraint m a, FunctorConstraint m b, FunctorConstraint m (m b)) => m a -> m b -> m b
instance Monad Vector
instance Monad Vector
instance Monad ReadPrec
instance Monad []

module Control.ConstraintKinds
