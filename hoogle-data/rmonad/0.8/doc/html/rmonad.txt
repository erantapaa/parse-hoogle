-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Restricted monad library
--   
--   A library for restricted monads based on associated datatypes. This
--   allows datatypes such as Set to be made into monads. Users can either
--   use the NoImplicitPrelude extension and use Control.RMonad directly,
--   or use Control.RMonad.AsMonad with the embed and unEmbed combinators
--   to use the normal Prelude monad operations.
@package rmonad
@version 0.8

module Control.IfThenElse
ifThenElse :: Bool -> a -> a -> a


-- | This module provides alternatives to the <a>Functor</a>, <a>Monad</a>
--   and <tt>MonadPlus</tt> classes, allowing for constraints on the
--   contained type (a restricted monad). It makes use of associated
--   datatypes (available in GHC 6.8).
--   
--   To make your own type instances of these classes, first define the
--   <a>Constraints</a> datatype and the <a>Suitable</a> type class for it.
--   For example,
--   
--   <pre>
--   data instance Constraints Set a = Ord a =&gt; SetConstraints
--   instance Ord a =&gt; Suitable Set a where
--      constraints _ = SetConstraints
--   </pre>
--   
--   You need to change <tt>Set</tt> to your own type, <tt>Ord a</tt> to
--   your own constraints, and <tt>SetConstraints</tt> to some
--   distinguished name (this name will not normally be visible to users of
--   your type)
--   
--   Next you can make an instance of <a>RMonad</a> and if appropriate
--   <a>RMonadPlus</a> by defining the members in the usual way. When you
--   need to make use of the constraint on the contained type, you will
--   need to get hold of the constraint wrapped up in the
--   <a>Constraints</a> datatype. For example here are the instances for
--   <tt>Set</tt>:
--   
--   <pre>
--   instance RMonad Set where
--      return = Set.singleton
--      s &gt;&gt;= f = let res = case constraints res of
--                            SetConstraints -&gt; Set.fold (a s' -&gt; Set.union (f a) s') Set.empty s
--                in res
--      fail _ = Set.empty
--   </pre>
--   
--   <pre>
--   instance RMonadPlus Set where
--      mzero = Set.empty
--      mplus s1 s2 = let res = case constraints res of
--                                 SetConstraints -&gt; Set.union s1 s2
--                    in res
--   </pre>
--   
--   Once you have made your type an instance of <a>RMonad</a>, you can use
--   it in two ways. Firstly, import this module directly and use the
--   <tt>RebindableSyntax</tt> extension so that do-syntax is rebound. If
--   using ghc&lt;7 use <tt>NoImplicitPrelude</tt> instead. Secondly, use
--   the wrapper type in <a>Control.RMonad.AsMonad</a> which supports the
--   normal <a>Monad</a> operations.
module Control.RMonad
class Suitable (m :: * -> *) a
constraints :: Suitable m a => Constraints m a
class RFunctor f
fmap :: (RFunctor f, Suitable f a, Suitable f b) => (a -> b) -> f a -> f b
class RMonad m where m1 >> m2 = m1 >>= \ _ -> m2 fail = error
return :: (RMonad m, Suitable m a) => a -> m a
(>>=) :: (RMonad m, Suitable m a, Suitable m b) => m a -> (a -> m b) -> m b
(>>) :: (RMonad m, Suitable m a, Suitable m b) => m a -> m b -> m b
fail :: (RMonad m, Suitable m a) => String -> m a
class RMonad m => RMonadPlus m
mzero :: (RMonadPlus m, Suitable m a) => m a
mplus :: (RMonadPlus m, Suitable m a) => m a -> m a -> m a
(<=<) :: (RMonad m, Suitable m a, Suitable m b, Suitable m c) => (b -> m c) -> (a -> m b) -> a -> m c
(=<<) :: (RMonad m, Suitable m a, Suitable m b) => (a -> m b) -> m a -> m b
(>=>) :: (RMonad m, Suitable m a, Suitable m b, Suitable m c) => (a -> m b) -> (b -> m c) -> a -> m c
ap :: (RMonad m, Suitable m (a -> b), Suitable m a, Suitable m b) => m (a -> b) -> m a -> m b
filterM :: (RMonad m, Suitable m [a], Suitable m Bool) => (a -> m Bool) -> [a] -> m [a]
foldM :: (RMonad m, Suitable m a) => (a -> b -> m a) -> a -> [b] -> m a
foldM_ :: (RMonad m, Suitable m a, Suitable m ()) => (a -> b -> m a) -> a -> [b] -> m ()
forM :: (RMonad m, Suitable m b, Suitable m [b]) => [a] -> (a -> m b) -> m [b]
forM_ :: (RMonad m, Suitable m b, Suitable m ()) => [a] -> (a -> m b) -> m ()
forever :: (RMonad m, Suitable m a, Suitable m b) => m a -> m b
guard :: (RMonadPlus m, Suitable m ()) => Bool -> m ()
join :: (RMonad m, Suitable m a, Suitable m (m a)) => m (m a) -> m a
liftM :: (RMonad m, Suitable m a1, Suitable m r) => (a1 -> r) -> m a1 -> m r
liftM2 :: (RMonad m, Suitable m a1, Suitable m a2, Suitable m r) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
liftM3 :: (RMonad m, Suitable m a1, Suitable m a2, Suitable m a3, Suitable m r) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
liftM4 :: (RMonad m, Suitable m a1, Suitable m a2, Suitable m a3, Suitable m a4, Suitable m r) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
liftM5 :: (RMonad m, Suitable m a1, Suitable m a2, Suitable m a3, Suitable m a4, Suitable m a5, Suitable m r) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
mapAndUnzipM :: (RMonad m, Suitable m (b, c), Suitable m [(b, c)], Suitable m ([b], [c])) => (a -> m (b, c)) -> [a] -> m ([b], [c])
mapM :: (RMonad m, Suitable m b, Suitable m [b]) => (a -> m b) -> [a] -> m [b]
mapM_ :: (RMonad m, Suitable m b, Suitable m ()) => (a -> m b) -> [a] -> m ()
msum :: (RMonadPlus m, Suitable m a) => [m a] -> m a
replicateM :: (RMonad m, Suitable m a, Suitable m [a]) => Int -> m a -> m [a]
replicateM_ :: (RMonad m, Suitable m a, Suitable m ()) => Int -> m a -> m ()
sequence :: (RMonad m, Suitable m a, Suitable m [a]) => [m a] -> m [a]
sequence_ :: (RMonad m, Suitable m a, Suitable m ()) => [m a] -> m ()
unless :: (RMonad m, Suitable m ()) => Bool -> m () -> m ()
when :: (RMonad m, Suitable m ()) => Bool -> m () -> m ()
zipWithM :: (RMonad m, Suitable m c, Suitable m [c]) => (a -> b -> m c) -> [a] -> [b] -> m [c]
zipWithM_ :: (RMonad m, Suitable m c, Suitable m ()) => (a -> b -> m c) -> [a] -> [b] -> m ()
instance RMonadPlus Set
instance RMonad Set
instance RFunctor Set
instance RMonad IO
instance RFunctor IO
instance RMonadPlus []
instance RMonad []
instance RFunctor []
instance RMonadPlus Maybe
instance RMonad Maybe
instance RFunctor Maybe
instance RMonad ((->) r)
instance RFunctor ((->) r)

module Control.RMonad.AsMonad

-- | A wrapper type that can be used to embed an arbitrary restricted monad
--   as a normal monad.
--   
--   Note that in general there can be an efficiency loss in using
--   <a>AsMonad</a> where the underlying restricted monad could have been
--   used instead. For example when using <tt>Set</tt> with <a>AsMonad</a>,
--   intermediate results will not have duplicates removed. On the other
--   hand, it becomes legal to use intermediate results that do not have
--   <a>Ord</a> instances.
data AsMonad m a

-- | Turn a restricted monad into a normal monad
embed :: Suitable m a => m a -> AsMonad m a

-- | Unwrap an <a>AsMonad</a> value into the enclosed restricted monad
unEmbed :: Suitable m a => AsMonad m a -> m a
instance RMonadPlus m => MonadPlus (AsMonad m)
instance RMonad m => Monad (AsMonad m)
instance RFunctor f => Functor (AsMonad f)

module Control.RMonad.Prelude

module Control.RMonad.Fix
class RMonad m => RMonadFix m
mfix :: (RMonadFix m, Suitable m a) => (a -> m a) -> m a

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
fix :: (a -> a) -> a
instance RMonadFix Set
instance RMonadFix ((->) r)
instance RMonadFix IO
instance RMonadFix []
instance RMonadFix Maybe

module Control.RMonad.Trans
class RMonadTrans t
lift :: (RMonadTrans t, RMonad m, Suitable m a, Suitable (t m) a) => m a -> t m a
class RMonad m => RMonadIO m
liftIO :: (RMonadIO m, Suitable m a) => IO a -> m a
instance RMonadIO IO

module Control.RMonad.Trans.Set
newtype SetT m a
SetT :: m (Set a) -> SetT m a
runSetT :: SetT m a -> m (Set a)
instance RMonadIO m => RMonadIO (SetT m)
instance RMonadTrans SetT
instance RMonad m => RMonadPlus (SetT m)
instance RMonad m => RMonad (SetT m)
instance (Ord a, Suitable m a, Suitable m (Set a)) => Suitable (SetT m) a

module Control.RMonad.Trans.List
instance RMonadIO m => RMonadIO (ListT m)
instance RMonadTrans ListT
instance RMonad m => RMonadPlus (ListT m)
instance RMonad m => RMonad (ListT m)
instance (Suitable m a, Suitable m [a]) => Suitable (ListT m) a

module Control.RMonad.Trans.Reader
instance RMonadIO m => RMonadIO (ReaderT r m)
instance RMonadTrans (ReaderT r)
instance RMonad m => RMonad (ReaderT r m)
instance Suitable m a => Suitable (ReaderT r m) a

module Control.RMonad.Trans.Cont
instance RMonadIO m => RMonadIO (ContT r m)
instance RMonadTrans (ContT r)
instance RMonad m => RMonad (ContT r m)
instance (Suitable m a, Suitable m r) => Suitable (ContT r m) a
