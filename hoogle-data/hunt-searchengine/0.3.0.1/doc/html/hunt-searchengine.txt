-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A search and indexing engine.
--   
@package hunt-searchengine
@version 0.3.0.1


-- | Logging auxiliary functions.
--   
--   The <a>LogShow</a> is an alternative <a>Show</a> instance for a custom
--   representation in logs. It uses the <a>Show</a> instance by default.
module Hunt.Utility.Log

-- | Alternative <a>Show</a> instance for a custom representation in logs.
--   It uses the <a>Show</a> instance by default.
class LogShow e
logShow :: LogShow e => e -> String
instance [overlap ok] Show e => LogShow e


-- | The document identifier type DocId and the newtype DocId' with Show
--   and ToJSOn instances
module Hunt.Common.DocId
newtype DocId
DocId :: Int -> DocId
unDocId :: DocId -> Int
mkDocId :: Binary a => a -> DocId
toHex :: Int -> String
fromHex :: String -> Maybe Int
instance Eq DocId
instance Ord DocId
instance ToJSON DocId
instance Binary DocId
instance Show DocId


-- | Efficient Set implementation for <a>DocId</a>s.
module Hunt.Common.DocIdSet
newtype DocIdSet
DIS :: IntSet -> DocIdSet
unDIS :: DocIdSet -> IntSet
singleton :: DocId -> DocIdSet
null :: DocIdSet -> Bool
member :: DocId -> DocIdSet -> Bool
fromList :: [DocId] -> DocIdSet
toIntSet :: DocIdSet -> IntSet
toList :: DocIdSet -> [DocId]
difference :: DocIdSet -> DocIdSet -> DocIdSet
union :: DocIdSet -> DocIdSet -> DocIdSet
intersection :: DocIdSet -> DocIdSet -> DocIdSet
instance Typeable DocIdSet
instance Eq DocIdSet
instance Show DocIdSet
instance NFData DocIdSet
instance FromJSON DocIdSet
instance ToJSON DocIdSet
instance Monoid DocIdSet
instance Binary DocIdSet

module Hunt.Utility.Output
outputValue :: (Functor m, MonadIO m, ToJSON c) => String -> c -> m ()
jsonOutput :: ToJSON c => Bool -> (ByteString -> IO a) -> c -> IO a


-- | General utitlity functions.
module Hunt.Utility

-- | The boob operator.
(.::) :: (c -> d) -> (a -> b -> c) -> a -> b -> d

-- | The Total Recall operator.
(.:::) :: (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e

-- | Safe <a>head</a>.
head' :: [a] -> Maybe a

-- | Strict version of <tt>foldM</tt>.
foldM' :: Monad m => (a -> b -> m a) -> a -> [b] -> m a

-- | <a>foldlM</a> for <a>Map</a> with key.
foldlWithKeyM :: Monad m => (b -> k -> a -> m b) -> b -> Map k a -> m b

-- | <a>foldrM</a> for <a>Map</a> with key.
foldrWithKeyM :: Monad m => (k -> a -> b -> m b) -> b -> Map k a -> m b

-- | Monadic <a>when</a>.
whenM :: Monad m => m Bool -> m () -> m ()

-- | <a>catMaybes</a> on a <a>Set</a> instead of a List.
catMaybesSet :: Ord a => Set (Maybe a) -> [a]

-- | Test if <a>Either</a> is a <a>Left</a> value.
isLeft :: Either a b -> Bool

-- | Test if <a>Either</a> is a <a>Right</a> value.
isRight :: Either a b -> Bool

-- | Unwraps a <a>Left</a> value - fails on <a>Right</a>.
fromLeft :: Either a b -> a

-- | Unwraps a <a>Right</a> value - fails on <a>Left</a>.
fromRight :: Either a b -> b

-- | Unbox a singleton.
--   
--   <i>Note</i>: This fails if the list is not a singleton.
unbox :: [a] -> a

-- | Unbox a singleton in a safe way with <a>Maybe</a>.
unboxM :: [a] -> Maybe a

-- | Test if the list contains a single element.
isSingleton :: [a] -> Bool

-- | Split a string into seperate strings at a specific character sequence.
split :: Eq a => [a] -> [a] -> [[a]]

-- | partition the list of input data into a list of input data lists of
--   approximately the same specified length
partitionListByLength :: Int -> [a] -> [[a]]

-- | partition the list of input data into a list of a specified number of
--   input data lists with approximately the same length
partitionListByCount :: Int -> [a] -> [[a]]

-- | To use with <tt>sortBy</tt>.
descending :: Ord a => a -> a -> Ordering

-- | Removes leading and trailing whitespace from a string.
strip :: String -> String

-- | Removes leading whitespace from a string.
stripl :: String -> String

-- | Removes trailing whitespace from a string.
stripr :: String -> String

-- | Strip leading and trailing elements matching a predicate.
stripWith :: (a -> Bool) -> [a] -> [a]

-- | Escapes non-alphanumeric or space characters in a String
escape :: String -> String
showText :: Show a => a -> Text

-- | Like <a>object</a> to use with <a>.=?</a>, <a>.==</a> and <a>.\.</a>.
--   This allows omitting (default) values in <a>ToJSON</a> instances.
--   
--   <pre>
--   toJSON (Example maybe list float) = object' $
--     [ "maybe" .=? maybe .\. isNothing
--     , "list"  .=? list  .\. null
--     , "float" .=? float .\. (== 1.0)
--     ]
--   </pre>
object' :: [[Pair]] -> Value

-- | Like <a>.=</a> but allows omitting of (default) values in
--   <a>ToJSON</a> instances.
--   
--   See <a>object'</a>.
(.=?) :: ToJSON a => Text -> (a, a -> Bool) -> [Pair]

-- | <a>.==</a> for <a>object'</a>.
--   
--   See <a>object'</a>.
(.==) :: ToJSON a => Text -> a -> [Pair]

-- | Use with <a>.=?</a> to specify which value to omit.
--   
--   See <a>object'</a>.
(.\.) :: ToJSON a => a -> (a -> Bool) -> (a, a -> Bool)

-- | A dummy type without constructor.
data TypeDummy


-- | Normalization and validation for date.
--   
--   Days are represented here as in ISO 8601:2000 Second Edition: ISO
--   (International Organization for Standardization). Representations of
--   dates and times, second edition, 2000-12-15.
--   
--   NOT as in ISO 8601 ISO (International Organization for
--   Standardization). Representations of dates and times, 1988-06-15.
--   
--   The main difference is dealing with year 0. in the older ISO standard,
--   this is excluded and "-0001" is the representation of year 1 Before
--   Common Era "-1 BCE". In the latter standard "0000" represents "-1 BCE"
--   and "-0001" represents "-2 BCE"
module Hunt.Index.Schema.Normalize.Date

-- | Normalize a date representation to store in the index or search for.
normalize :: Text -> Text

-- | Function takes normalized Date and transforms it back a readable form.
--   We don't transform it back to the original representation, since that
--   is never used, but to a general readable date format
denormalize :: Text -> Text

-- | Checks if the string is a date representation (syntactically).
isAnyDate :: String -> Bool

-- | Same as <a>isAnyDate</a> but also checks if <tt>(showDate .
--   readAnyDate)</tt> produces the same result. <i>NOTE</i>: excludes
--   dates before year 0 (1 BCE).
isAnyDate' :: String -> Bool
isTime :: String -> Bool
nullDay :: Day
showGYearMonth :: Date -> String
showGYear :: Date -> String
showGMonthDay :: Date -> String
showGMonth :: Date -> String
showGDay :: Date -> String
showTime :: Date -> String
instance Show Date
instance Ord Date
instance Eq Date


-- | Normalization and validation for geographic positions.
module Hunt.Index.Schema.Normalize.Position

-- | Normalizes valid position A valid position has a format like
--   "double-double"/"latitude-longitude".
normalize :: Text -> Text

-- | Denormalizes internal position into valid position. A valid position
--   has a format like "double-double"/"latitude-longitude".
denormalize :: Text -> Text

-- | Checks if value is a valid position. A valid position has a format
--   like "double-double"/"latitude-longitude".
isPosition :: Text -> Bool

-- | Parse a coordinate.
position :: Parser (Double, Double)


-- | <a>ToJSON</a> instance for <a>GCStats</a>.
module GHC.Stats.Json
instance ToJSON GCStats


-- | <a>Binary</a> instance for <a>Fingerprint</a>.
module GHC.Fingerprint.Binary
instance Binary Fingerprint


-- | <a>Binary</a> instance for <a>TypeRep</a>.
module Data.Typeable.Binary
instance Binary TyCon
instance Binary TypeRep


-- | Default <a>Binary</a> instance for <a>Text</a> using UTF-8.
module Data.Text.Binary
instance Binary Text

module Hunt.Common.DocDesc
newtype DocDesc
DocDesc :: Object -> DocDesc
unDesc :: DocDesc -> Object

-- | Smart constructor for document descriptions.
mkDocDesc :: Object -> DocDesc

-- | The empty description.
empty :: DocDesc

-- | Check if document description is empty.
null :: DocDesc -> Bool

-- | Insert key value pair into description.
insert :: ToJSON v => Text -> v -> DocDesc -> DocDesc

-- | Remove a key value pair
delete :: Text -> DocDesc -> DocDesc

-- | Union of two descriptions.
union :: DocDesc -> DocDesc -> DocDesc

-- | restrict a DocDesc map to a set of fields
restrict :: [Text] -> DocDesc -> DocDesc
deleteNull :: DocDesc -> DocDesc
lookupValue :: Text -> DocDesc -> Value
lookup :: FromJSON v => Text -> DocDesc -> Maybe v
lookupText :: Text -> DocDesc -> Text

-- | Create a document description from as list
fromList :: ToJSON v => [(Text, v)] -> DocDesc

-- | Create a list from a document description.
toList :: DocDesc -> [(Text, Value)]
instance Typeable DocDesc
instance Eq DocDesc
instance Show DocDesc
instance NFData DocDesc
instance FromJSON DocDesc
instance ToJSON DocDesc
instance Binary DocDesc


-- | Common types used within Hunt.
module Hunt.Common.BasicTypes

-- | The URI describing the location of the original document.
type URI = Text

-- | The description of a document is a generic key value map.
type Description = DocDesc

-- | The title of a document.
type Title = Text

-- | The content of a document.
type Content = Text

-- | The position of a word in the document.
type Position = Int

-- | The name of a context.
type Context = Text

-- | A single word.
type Word = Text

-- | Positions of Words for each context.
type Words = Map Context WordList

-- | Positions of words in the document.
type WordList = Map Word [Position]

-- | Text index
data TextSearchOp
Case :: TextSearchOp
NoCase :: TextSearchOp
PrefixCase :: TextSearchOp
PrefixNoCase :: TextSearchOp

-- | Weight (for ranking).
type Weight = Score

-- | Regular expression.
type RegEx = Text

-- | The score of a hit (either a document hit or a word hit). type Score =
--   Float
--   
--   Weight or score of a documents, <tt>0.0</tt> indicates: not set, so
--   there is no need to work with Maybe's wrapped in newtype to not mix up
--   with Score's and Weight's in documents
newtype Score
SC :: Float -> Score
unScore :: Score -> Float
noScore :: Score
mkScore :: Float -> Score
getScore :: Score -> Maybe Float
defScore :: Score
toDefScore :: Score -> Score
fromDefScore :: Score -> Score
accScore :: [Score] -> Score

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a

-- | An infix synonym for <a>mappend</a>.
--   
--   <i>Since: 4.5.0.0</i>
(<>) :: Monoid m => m -> m -> m
instance Eq TextSearchOp
instance Show TextSearchOp
instance Eq Score
instance Ord Score
instance Num Score
instance Fractional Score
instance Show Score
instance Binary TextSearchOp
instance Binary Score
instance ToJSON TextSearchOp
instance FromJSON TextSearchOp
instance ToJSON Score
instance FromJSON Score
instance Monoid Score
instance NFData Score


-- | Document format for the interpreter and JSON API. It includes the
--   document description, the index data and additional metadata.
module Hunt.Common.ApiDocument

-- | The document accepted by the interpreter and JSON API.
data ApiDocument
ApiDocument :: URI -> IndexMap -> Description -> Score -> ApiDocument

-- | The unique identifier.
adUri :: ApiDocument -> URI

-- | The data to index according to schema associated with the context.
adIndex :: ApiDocument -> IndexMap

-- | The document description (a simple key-value map).
adDescr :: ApiDocument -> Description

-- | An optional document boost, (internal default is <tt>1.0</tt>).
adWght :: ApiDocument -> Score

-- | Context map
type IndexMap = Map Context Content

-- | Multiple <a>ApiDocument</a>s.
type ApiDocuments = [ApiDocument]

-- | Text analysis function
type AnalyzerFunction = Text -> [(Position, Text)]

-- | Types of analyzer
data AnalyzerType
DefaultAnalyzer :: AnalyzerType

-- | Paginated result with an offset and chunk size.
data LimitedResult x
LimitedResult :: [x] -> Int -> Int -> Int -> LimitedResult x

-- | The list with at most <a>lrMax</a> elements.
lrResult :: LimitedResult x -> [x]

-- | The offset of the result.
lrOffset :: LimitedResult x -> Int

-- | The limit for the result.
lrMax :: LimitedResult x -> Int

-- | The size of the complete result.
lrCount :: LimitedResult x -> Int

-- | Create a paginated result with an offset and a chunk size. The result
--   also includes the size of the complete result.
mkLimitedResult :: Int -> Int -> [x] -> LimitedResult x

-- | Empty index content.
emptyApiDocIndexMap :: IndexMap

-- | Empty <tt>Document</tt> description.
emptyApiDocDescr :: Description

-- | Empty <a>ApiDocument</a>.
emptyApiDoc :: ApiDocument
instance Show ApiDocument
instance Show AnalyzerType
instance Show x => Show (LimitedResult x)
instance Eq x => Eq (LimitedResult x)
instance ToJSON AnalyzerType
instance FromJSON AnalyzerType
instance ToJSON ApiDocument
instance FromJSON ApiDocument
instance FromJSON x => FromJSON (LimitedResult x)
instance ToJSON x => ToJSON (LimitedResult x)
instance LogShow ApiDocument
instance Binary ApiDocument
instance NFData ApiDocument
instance NFData x => NFData (LimitedResult x)


-- | Normalization and validation for integer.
module Hunt.Index.Schema.Normalize.Int

-- | Normalize an integer to a <a>Text</a> representation preserving
--   ordering.
normalizeToText :: Text -> Text

-- | Denormalize a value transformed with <tt>normalize</tt>.
denormalizeFromText :: Text -> Text

-- | Normalize an integer to an <a>Int</a>.
normalizeToInt :: Text -> Int

-- | Denormalize an integer.
denormalizeFromInt :: Int -> Text

-- | Validate if the text represents a valid integer. Needs to be within
--   <a>Int</a> range.
isInt :: Text -> Bool

-- | Parse a simple integer representation.
integer :: Parser Int


-- | The query language.
--   
--   <a>Query</a> specifies the complete grammar.
--   
--   <a>Hunt.Query.Language.Parser</a> provides a parser for plain text
--   queries.
module Hunt.Query.Language.Grammar

-- | The query language.
data Query

-- | prefix search for a word
QWord :: TextSearchType -> Text -> Query

-- | search for a complete word
QFullWord :: TextSearchType -> Text -> Query

-- | Phrase search.
QPhrase :: TextSearchType -> Text -> Query

-- | Restrict a query to a list of contexts.
QContext :: [Context] -> Query -> Query

-- | Combine two queries with a binary operation.
QBinary :: BinOp -> Query -> Query -> Query
QSeq :: BinOp -> [Query] -> Query

-- | Weight for query.
QBoost :: Weight -> Query -> Query

-- | Range query.
QRange :: Text -> Text -> Query

-- | A binary operation.
data BinOp

-- | Intersect two queries.
And :: BinOp

-- | Union two queries.
Or :: BinOp

-- | Filter a query by another.
AndNot :: BinOp

-- | Search for a sequence of words
Phrase :: BinOp

-- | Search a word followed another word within a distance
Follow :: Int -> BinOp

-- | search a word followed or preceded another word within a distance
Near :: Int -> BinOp

-- | The search opeation.
data TextSearchType

-- | Case-sensitive search.
QCase :: TextSearchType

-- | Case-insensitive search.
QNoCase :: TextSearchType

-- | Fuzzy search. See <a>Hunt.Query.Fuzzy</a> for details. The query
--   processor allows additional configuration with <a>ProcessConfig</a>.
QFuzzy :: TextSearchType

-- | The character an escape sequence starts with.
escapeChar :: Char

-- | Characters that cannot occur in a word (and have to be escaped).
notWordChar :: String

-- | Minor query optimizations.
--   
--   <i>Note</i>: This can affect the ranking.
optimize :: Query -> Query

-- | Check if the query arguments comply with some custom predicate.
checkWith :: (Text -> Bool) -> Query -> Bool

-- | Returns a list of all terms in the query.
extractTerms :: Query -> [Text]

-- | Renders a text representation of a Query.
printQuery :: Query -> Text
instance Eq TextSearchType
instance Show TextSearchType
instance Eq BinOp
instance Show BinOp
instance Eq Query
instance Show Query
instance Binary BinOp
instance Binary TextSearchType
instance Binary Query
instance FromJSON BinOp
instance ToJSON BinOp
instance FromJSON TextSearchType
instance ToJSON TextSearchType
instance FromJSON Query
instance ToJSON Query

module Hunt.Query.Language.Builder

-- | case sensitive prefix search of a single word
qWord :: Text -> Query

-- | case insensitive prefix search of a single word
qWordNoCase :: Text -> Query

-- | exact case sensitive search of a single word
qFullWord :: Text -> Query

-- | exact, but case insensitive search of a single word
qFullWordNoCase :: Text -> Query

-- | exact search of a sequence of space separated words. For each word in
--   the sequence, an exact word search is performed.
qPhrase :: Text -> Query

-- | exact, but case insenitive search of a sequence of space separated
--   words. For each word in the sequence, a word search is performed.
qPhraseNoCase :: Text -> Query

-- | prefix search of a sequence of space separated words. For each word in
--   the sequence, a prefix search is performed.
qPrefixPhrase :: Text -> Query

-- | prefix search of a sequence of space separated words. For each word in
--   the sequence, a prefix search is performed.
qPrefixPhraseNoCase :: Text -> Query

-- | search a range of words or an intervall for numeric contexts
qRange :: Text -> Text -> Query

-- | and query
qAnd :: Query -> Query -> Query
qAnds :: [Query] -> Query

-- | or query
qOr :: Query -> Query -> Query
qOrs :: [Query] -> Query

-- | and not query
qAndNot :: Query -> Query -> Query
qAndNots :: [Query] -> Query

-- | neighborhood queries. The list must not be empty
--   
--   TODO: a better name for qNext and qNexts, qPhrase is already used
qNext :: Query -> Query -> Query
qNexts :: [Query] -> Query
qFollow :: Int -> Query -> Query -> Query
qFollows :: Int -> [Query] -> Query
qNear :: Int -> Query -> Query -> Query
qNears :: Int -> [Query] -> Query

-- | case insensitve search, only sensible for word and phrase queries
setNoCaseSearch :: Query -> Query

-- | fuzzy search, only sensible for word and phrase queries
setFuzzySearch :: Query -> Query

-- | restrict search to a single context
setContext :: Context -> Query -> Query

-- | restrict search to list of contexts
setContexts :: [Context] -> Query -> Query

-- | boost the search results by a factor
setBoost :: Weight -> Query -> Query

-- | <i>Deprecated: Don't use this, use setContexts</i>
withinContexts :: [Context] -> Query -> Query

-- | <i>Deprecated: Don't use this, use setContext</i>
withinContext :: Context -> Query -> Query

-- | <i>Deprecated: Don't use this, use setBoost</i>
withBoost :: Weight -> Query -> Query

-- | shortcut for case sensitive context search
qContext :: Context -> Text -> Query


-- | Version : 0.2
--   
--   The Hunt query parser, based on the famous Parsec library.
--   
--   The parser implements a default syntax for the query grammar which
--   exposes all possible query types and operators to the user.
--   
--   Syntax:
--   
--   <ul>
--   <li><i><tt>AND</tt>, <tt>OR</tt>, <tt>AND NOT</tt></i> = combinatory
--   queries</li>
--   <li><i><tt>!w</tt></i> = case sensitive prefix query e.g.:
--   <tt>!car</tt> or <tt>!Car</tt></li>
--   <li><i><tt>~w</tt></i> = fuzzy word query e.g.: <tt>~car</tt> or
--   <tt>~cra</tt></li>
--   <li><i><tt>"..."</tt></i> = phrase query, performs an exact search for
--   a single word</li>
--   <li><i><tt>(...)</tt></i> = brackets</li>
--   <li><i><tt>c:w</tt></i> = context sensitive queries e.g.:
--   <tt>(who:Rudi Voeller)</tt></li>
--   <li><i><tt>c1,c2:w</tt></i> = multi context queries e.g.:
--   <tt>(content,who,title:Rudi Voeller)</tt></li>
--   <li><i>@[... TO ...\</i> <tt>] = range queries e.g.: </tt>[2014-02-10
--   TO 2012-02-16]@</li>
--   <li><i><tt>w^b</tt></i> = query boosting e.g.: <tt>toList OR
--   toAscList^1.5</tt></li>
--   </ul>
module Hunt.Query.Language.Parser

-- | Parse a query using the default syntax provided by the Hunt framework.
parseQuery :: String -> Either Text Query


-- | The document representation.
--   
--   This includes the
--   
--   <ul>
--   <li>URI for identification,</li>
--   <li>the description for the data itself</li>
--   <li>the weight used in ranking and</li>
--   <li>optionally a score</li>
--   </ul>
module Hunt.Common.Document

-- | The document representation.
data Document
Document :: !URI -> !Description -> !Score -> Document

-- | Unique identifier of the document.
uri :: Document -> !URI

-- | Description of the document (simple key-value store).
desc :: Document -> !Description

-- | Weight used in ranking (default <tt>1.0</tt>).
wght :: Document -> !Score
emptyDocument :: Document
toApiDocument :: Document -> ApiDocument
fromApiDocument :: ApiDocument -> Document

-- | Simple bijection between <tt>e</tt> and <a>Document</a> for
--   compression.
class NFData e => DocumentWrapper e where update f = wrap . f . unwrap
unwrap :: DocumentWrapper e => e -> Document
wrap :: DocumentWrapper e => Document -> e
update :: DocumentWrapper e => (Document -> Document) -> e -> e
instance Show Document
instance Eq Document
instance LogShow Document
instance DocumentWrapper Document
instance NFData Document
instance Binary Document
instance FromJSON Document
instance ToJSON Document


-- | Version : 0.2
--   
--   The unique Holumbus mechanism for generating fuzzy sets.
module Hunt.Query.Fuzzy

-- | A set of string which have been "fuzzed" with an associated score.
type FuzzySet = Map Text FuzzyScore

-- | Some replacements which can be applied to a string to generate a
--   <a>FuzzySet</a>. The scores of the replacements will be normalized to
--   a maximum of 1.0.
type Replacements = [Replacement]

-- | A single replacements, where the first will be replaced by the second
--   and vice versa in the target string. The score indicates the amount of
--   fuzzines that one single application of this replacement in just one
--   direction will cause on the target string.
type Replacement = ((Text, Text), FuzzyScore)

-- | The score indicating an amount of fuzziness.
type FuzzyScore = Float

-- | The configuration of a fuzzy query.
data FuzzyConfig
FuzzyConfig :: Bool -> Bool -> FuzzyScore -> Replacements -> FuzzyConfig

-- | Indicates whether the replacements should be applied.
applyReplacements :: FuzzyConfig -> Bool

-- | Indicates whether the swapping of adjacent characters should be
--   applied.
applySwappings :: FuzzyConfig -> Bool

-- | The maximum allowed fuzziness.
maxFuzziness :: FuzzyConfig -> FuzzyScore

-- | The replacements that should be applied.
customReplacements :: FuzzyConfig -> Replacements

-- | Some default replacements for the english language.
englishReplacements :: Replacements

-- | Some default replacements for the german language.
germanReplacements :: Replacements

-- | Continue fuzzing a string with the an explicitly specified list of
--   replacements until a given score threshold is reached.
fuzz :: FuzzyConfig -> Text -> FuzzySet

-- | Transform a fuzzy set into a list (ordered by score).
toList :: FuzzySet -> [(Text, FuzzyScore)]
instance Show FuzzyConfig
instance Binary FuzzyConfig
instance Default FuzzyConfig


-- | Intermediate data structure for sorting and paging a result set
--   
--   When sorting a result set by priority and knowing how many results are
--   requested and which "page" of the result set is requested, a priority
--   queue with limited capacity can be used for efficient sorting and
--   paging.
module Data.LimitedPriorityQueue
data Queue v

-- | Create an empty priority queue with a limited capacity. If capacity is
--   &lt; 0, no limit is set
mkQueue :: Int -> Queue v

-- | Insert an element if there is space in the queue or if the element is
--   larger than the smallest element.
insert :: Ord v => v -> Queue v -> Queue v

-- | Reduce size and capacity of queue by throwing away small elements.
reduce :: Ord v => Int -> Queue v -> Queue v
toList :: Ord v => Int -> Int -> Queue v -> [v]
fromList :: Ord v => Int -> [v] -> Queue v

-- | Take a list of scored values, sort it and return a page of the result.
--   
--   <pre>
--   pageList 10 5 xs == take 5 . drop 10 . sortBy snd $ xs
--   </pre>
--   
--   If the length is set to <tt>-1</tt> no limit on the page length is
--   set.
pageList :: Ord v => Int -> Int -> [v] -> [v]
instance Show v => Show (Heap v)
instance Show v => Show (Queue v)


-- | A cache for single element <tt>IntSet</tt>s with elements 0 &lt;= i
--   &lt; cacheSize (1024) These single element sets occur very frequently
--   in position sets in occurrence maps, so sharing becomes available with
--   this cache.
--   
--   Usage: substitute all singleton calls with <tt>cacheAt</tt> calls and
--   all <tt>fromList</tt> calls with <tt>IS.unions . map cacheAt</tt>.
module Data.IntSet.Cache

-- | Initialize the <tt>IntSet</tt> cache.
cache :: Vector IntSet

-- | A (cached) <tt>IntSet</tt> singleton.
cacheAt :: Int -> IntSet


-- | Positions within document.
module Hunt.Common.Positions

-- | The positions of the word in the document.
newtype Positions
PS :: IntSet -> Positions
unPS :: Positions -> IntSet

-- | Empty positions.
empty :: Positions

-- | Positions with one element.
singleton :: Position -> Positions

-- | Test whether it is the empty positions.
null :: Positions -> Bool

-- | Whether the <a>Position</a> is part of <a>Positions</a>.
member :: Position -> Positions -> Bool

-- | Converts <a>Positions</a> to a list of <a>Position</a>s in ascending
--   order.
toAscList :: Positions -> [Position]

-- | Constructs Positions from a list of <a>Position</a>s.
fromList :: [Position] -> Positions

-- | Number of <a>Position</a>s.
size :: Positions -> Int

-- | The union of two <a>Positions</a>.
union :: Positions -> Positions -> Positions

-- | The union of two <a>Positions</a>.
intersection :: Positions -> Positions -> Positions

-- | The union of two <a>Positions</a>.
difference :: Positions -> Positions -> Positions

-- | A fold over Positions
foldr :: (Position -> r -> r) -> r -> Positions -> r

-- | intersection with a "shifted" 2. set with elements decremented by a
--   displacement <tt>d</tt> before the element test
--   
--   useful when searching for sequences of words (phrases)
intersectionWithDispl :: Int -> Positions -> Positions -> Positions

-- | intersction with "fuzzy" element test. All elements <tt>e1</tt> for
--   which an element <tt>e2</tt> in <tt>s2</tt> is found with <tt>e2 - e1
--   <a>elem</a> [lb..ub]</tt> remain in set <tt>s1</tt>.
--   
--   Useful for context search with sequences of words. This generatizes
--   <a>intersectionWithDispl</a>
--   
--   Law: <tt>intersectionWithIntervall d d == intersectionWithDispl d</tt>
intersectionWithIntervall :: Int -> Int -> Positions -> Positions -> Positions
instance Typeable Positions
instance Eq Positions
instance Ord Positions
instance Read Positions
instance Show Positions
instance NFData Positions
instance Monoid Positions
instance ToJSON Positions
instance Binary Positions

module Data.IntMap.BinTree.Strict
moduleName :: String
error' :: String -> a
type Key = Int
type IntMap v = Tree v
data Tree v
Empty :: Tree v
Node :: !Key -> !v -> !(Tree v) -> !(Tree v) -> Tree v
Lt :: !Key -> !v -> !(Tree v) -> Tree v
Gt :: !Key -> !v -> !(Tree v) -> Tree v
Leaf :: !Key -> !v -> Tree v
traverseWithKey :: Applicative t => (Key -> a -> t b) -> Tree a -> t (Tree b)
mkNode :: Key -> v -> Tree v -> Tree v -> Tree v
unNode :: Tree v -> (Key, v, Tree v, Tree v)
split' :: Key -> Tree v -> (Maybe v, Tree v, Tree v)
join' :: Maybe (Key, v) -> Tree v -> Tree v -> Tree v
lookup :: Key -> Tree v -> Maybe v
insertWith :: (v -> v -> v) -> Key -> v -> Tree v -> Tree v
delete :: Key -> Tree v -> Tree v
find :: Key -> Tree v -> v
findWithDefault :: v -> Key -> Tree v -> v
member :: Key -> Tree v -> Bool
notMember :: Key -> Tree v -> Bool
insert :: Key -> v -> Tree v -> Tree v
empty :: Tree v
null :: Tree v -> Bool
size :: Tree v -> Int

-- | retuns the size of a tree or Nothing if <tt>size t &gt; limit</tt>
--   
--   limits the computation time to O(limit), not O(size)
sizeWithLimit :: Int -> Tree v -> Maybe Int
union :: Tree v -> Tree v -> Tree v
unionWith :: (v -> v -> v) -> Tree v -> Tree v -> Tree v
unionWithKey' :: (Key -> v -> v -> v) -> Tree v -> Tree v -> Tree v
unionsWith :: (v -> v -> v) -> [Tree v] -> Tree v
difference :: Tree a -> Tree b -> Tree a
differenceWith :: (a -> b -> Maybe a) -> Tree a -> Tree b -> Tree a
differenceWithKey' :: (Key -> a -> b -> Maybe a) -> Tree a -> Tree b -> Tree a
intersection :: Tree a -> Tree b -> Tree a
intersectionWith :: (a -> b -> c) -> Tree a -> Tree b -> Tree c
intersectionWithKey' :: (Key -> a -> b -> c) -> Tree a -> Tree b -> Tree c
equal :: Eq v => Tree v -> Tree v -> Bool
map :: (a -> b) -> Tree a -> Tree b
mapWithKey :: (Key -> a -> b) -> Tree a -> Tree b
filter :: (a -> Bool) -> Tree a -> Tree a
filterWithKey :: (Key -> a -> Bool) -> Tree a -> Tree a
foldr :: (a -> b -> b) -> b -> Tree a -> b
foldr' :: (a -> b -> b) -> b -> Tree a -> b
foldrWithKey :: (Key -> a -> b -> b) -> b -> Tree a -> b
foldrWithKey' :: (Key -> a -> b -> b) -> b -> Tree a -> b
foldl :: (b -> a -> b) -> b -> Tree a -> b
foldl' :: (b -> a -> b) -> b -> Tree a -> b
foldlWithKey :: (b -> Key -> a -> b) -> b -> Tree a -> b
foldlWithKey' :: (b -> Key -> a -> b) -> b -> Tree a -> b
fromList :: [(Key, v)] -> Tree v
fromSet :: (Key -> v) -> IntSet -> Tree v
fromAscList :: [(Key, v)] -> Tree v
toTr :: Int -> Tree v -> [(Key, v)] -> Tree v
scan :: Int -> [(Key, v)] -> (Tree v, [(Key, v)])
toAscList :: Tree v -> [(Key, v)]
toList :: Tree v -> [(Key, v)]
assocs :: Tree v -> [(Key, v)]
elems :: Tree v -> [v]
keys :: Tree v -> [Key]
minView :: Tree v -> Maybe (v, Tree v)
minViewWithKey :: Tree v -> Maybe ((Key, v), Tree v)
maxView :: Tree v -> Maybe (v, Tree v)
maxViewWithKey :: Tree v -> Maybe ((Key, v), Tree v)
first :: (a -> c) -> (a, b) -> (c, b)
unionWithKey :: (Key -> v -> v -> v) -> Tree v -> Tree v -> Tree v
intersectionWithKey :: (Key -> a -> b -> c) -> Tree a -> Tree b -> Tree c
differenceWithKey :: (Key -> a -> b -> Maybe a) -> Tree a -> Tree b -> Tree a
instance Typeable Tree
instance Show v => Show (Tree v)
instance Traversable Tree
instance Foldable Tree
instance Functor Tree
instance Binary v => Binary (Tree v)
instance NFData v => NFData (Tree v)
instance Eq v => Eq (Tree v)


-- | Efficient Map implementation for <a>DocId</a>s.
module Hunt.Common.DocIdMap

-- | An efficient Map implementation for <a>DocId</a>s.
newtype DocIdMap v
DIM :: IntMap v -> DocIdMap v
unDIM :: DocIdMap v -> IntMap v

-- | The empty map.
empty :: DocIdMap v

-- | A map with a single element.
singleton :: DocId -> v -> DocIdMap v

-- | Is the map empty?
null :: DocIdMap v -> Bool

-- | Is the <a>DocId</a> member of the map?
member :: DocId -> DocIdMap v -> Bool

-- | Lookup the value at a <a>DocId</a> in the map.
lookup :: DocId -> DocIdMap v -> Maybe v

-- | Insert a <a>DocId</a> and value in the map. If the <a>DocId</a> is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <a>insertWith</a>
--   <a>const</a>.
insert :: DocId -> v -> DocIdMap v -> DocIdMap v

-- | Delete a <a>DocId</a> and its value from the map. When the
--   <a>DocId</a> is not a member of the map, the original map is returned.
delete :: DocId -> DocIdMap v -> DocIdMap v

-- | Insert with a function, combining new value and old value.
--   <tt>insertWith f docId value mp</tt> will insert the pair <tt>(docId,
--   value)</tt> into <tt>mp</tt> if <tt>docId</tt> does not exist in the
--   map. If the <a>DocId</a> does exist, the function will insert the pair
--   <tt>(docId, f new_value old_value)</tt>.
insertWith :: (v -> v -> v) -> DocId -> v -> DocIdMap v -> DocIdMap v

-- | The number of elements in the map.
size :: DocIdMap v -> Int

-- | The number of elements limited up to a maximum
sizeWithLimit :: Int -> DocIdMap v -> Maybe Int

-- | The (left-biased) union of two maps. It prefers the first map when
--   duplicate <a>DocId</a> are encountered, i.e. <tt>(union == unionWith
--   const)</tt>.
union :: DocIdMap v -> DocIdMap v -> DocIdMap v

-- | The (left-biased) intersection of two maps (based on <a>DocId</a>s).
intersection :: DocIdMap v -> DocIdMap v -> DocIdMap v

-- | Difference between two maps (based on <a>DocId</a>s).
difference :: DocIdMap v -> DocIdMap w -> DocIdMap v

-- | Difference between the map and a set of <a>DocId</a>s.
diffWithSet :: DocIdMap v -> DocIdSet -> DocIdMap v

-- | The union with a combining function.
unionWith :: (v -> v -> v) -> DocIdMap v -> DocIdMap v -> DocIdMap v

-- | The intersection with a combining function.
intersectionWith :: (v -> v -> v) -> DocIdMap v -> DocIdMap v -> DocIdMap v

-- | Difference with a combining function.
differenceWith :: (v -> v -> Maybe v) -> DocIdMap v -> DocIdMap v -> DocIdMap v

-- | The union of a list of maps, with a combining operation.
unionsWith :: (v -> v -> v) -> [DocIdMap v] -> DocIdMap v

-- | Map a function over all values in the map.
map :: (v -> r) -> DocIdMap v -> DocIdMap r

-- | Filter all values that satisfy some predicate.
filter :: (v -> Bool) -> DocIdMap v -> DocIdMap v

-- | Filter all <a>DocId</a>s/values that satisfy some predicate.
filterWithKey :: (DocId -> v -> Bool) -> DocIdMap v -> DocIdMap v

-- | Map a function over all values in the map.
mapWithKey :: (DocId -> v -> r) -> DocIdMap v -> DocIdMap r

-- | <tt><a>traverseWithKey</a> f s == <a>fromList</a> <a>$</a>
--   <tt>traverse</tt> ((k, v) -&gt; (,) k <a>$</a> f k v) (<a>toList</a>
--   m)</tt> That is, behaves exactly like a regular <tt>traverse</tt>
--   except that the traversing function also has access to the
--   <a>DocId</a> associated with a value.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (DocId -> a -> t b) -> DocIdMap a -> t (DocIdMap b)

-- | Fold the values in the map using the given right-associative binary
--   operator, such that <tt><a>foldr</a> f z == <a>foldr</a> f z .
--   <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (v -> b -> b) -> b -> DocIdMap v -> b

-- | Fold the <a>DocId</a>s and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <tt>toAscList</tt></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (DocId -> v -> b -> b) -> b -> DocIdMap v -> b
foldl :: (b -> v -> b) -> b -> DocIdMap v -> b

-- | Create a map from a list of <a>DocId</a>/value pairs.
fromList :: [(DocId, v)] -> DocIdMap v

-- | Create a map from a set of <a>DocId</a> values
fromDocIdSet :: (Int -> v) -> DocIdSet -> DocIdMap v

-- | Build a map from a list of <a>DocId</a>/value pairs where the
--   <a>DocId</a>s are in ascending order.
fromAscList :: [(DocId, v)] -> DocIdMap v

-- | Convert the map to a list of <a>DocId</a>/value pairs. Subject to list
--   fusion.
toList :: DocIdMap v -> [(DocId, v)]

-- | Return all <a>DocId</a>s of the map in ascending order. Subject to
--   list fusion.
keys :: DocIdMap v -> [DocId]

-- | Return all elements of the map in the ascending order of their
--   <a>DocId</a>s. Subject to list fusion.
elems :: DocIdMap v -> [v]
instance Typeable DocIdMap
instance Eq v => Eq (DocIdMap v)
instance Show v => Show (DocIdMap v)
instance Foldable DocIdMap
instance Functor DocIdMap
instance NFData v => NFData (DocIdMap v)
instance FromJSON v => FromJSON (DocIdMap v)
instance ToJSON v => ToJSON (DocIdMap v)
instance Binary v => Binary (DocIdMap v)
instance Monoid v => Monoid (DocIdMap v)


-- | Occurrences of words within the index. A word occurs in document at
--   specific locations.
module Hunt.Common.Occurrences

-- | The occurrences of words in documents. A mapping from document ids to
--   the positions in the document.
type Occurrences = DocIdMap Positions

-- | Create an empty set of positions.
empty :: Occurrences

-- | Create Occurrences from a <a>DocIdSet</a> Since the <a>DocIdSet</a>
--   contains no position information, we assume position one for each
--   <a>DocId</a>
fromDocIdSet :: DocIdSet -> Occurrences

-- | Create a single dcid set with a single position.
singleton :: DocId -> Position -> Occurrences

-- | Create a single dcid set with a set of.
singleton' :: DocId -> [Position] -> Occurrences

-- | Test on empty set of positions.
null :: Occurrences -> Bool

-- | Determine the number of positions in a set of occurrences.
size :: Occurrences -> Int

-- | Add a position to occurrences.
insert :: DocId -> Position -> Occurrences -> Occurrences

-- | Add multiple positions to occurrences
insert' :: DocId -> Positions -> Occurrences -> Occurrences

-- | Remove a position from occurrences.
deleteOccurrence :: DocId -> Position -> Occurrences -> Occurrences

-- | Delete a document (by <a>DocId</a>) from occurrences.
delete :: DocId -> Occurrences -> Occurrences

-- | Changes the DocIDs of the occurrences.
update :: (DocId -> DocId) -> Occurrences -> Occurrences

-- | Merge two occurrences.
merge :: Occurrences -> Occurrences -> Occurrences

-- | Merge occurrences
merges :: [Occurrences] -> Occurrences

-- | Difference of occurrences.
difference :: Occurrences -> Occurrences -> Occurrences

-- | Remove Set of DocIds from Occurrences
diffWithSet :: Occurrences -> DocIdSet -> Occurrences

-- | Subtract occurrences from some other occurrences.
subtract :: Occurrences -> Occurrences -> Occurrences
intersectOccurrences :: (Positions -> Positions -> Positions) -> Occurrences -> Occurrences -> Occurrences


-- | The raw result of index queries.
module Hunt.Common.RawResult

-- | The raw result returned when searching the index.
type RawResult = [(Word, Occurrences)]
type RawScoredResult = [(Word, (Score, Occurrences))]

-- | Transform the raw result into a tree structure ordered by word.
resultByWord :: Context -> RawResult -> Map Word (Map Context Occurrences)

-- | Transform the raw result into a tree structure ordered by document.
resultByDocument :: Context -> RawResult -> DocIdMap (Map Context (Map Word Positions))

module Hunt.Common.IntermediateValue
newtype IntermediateValue
IntermediateValue :: Occurrences -> IntermediateValue
unIntermediate :: IntermediateValue -> Occurrences
mkIntermediateValue :: Occurrences -> IntermediateValue
fromIntermediates :: IndexValue u => [(x, IntermediateValue)] -> [(x, u)]
fromScoredIntermediates :: IndexValue u => [(x, (s, IntermediateValue))] -> [(x, (s, u))]
toIntermediates :: IndexValue u => [(x, u)] -> [(x, IntermediateValue)]
class (Binary x, NFData x) => IndexValue x
toIntermediate :: IndexValue x => x -> IntermediateValue
fromIntermediate :: IndexValue x => IntermediateValue -> x
mergeValues :: IndexValue x => x -> x -> x
diffValues :: IndexValue x => DocIdSet -> x -> Maybe x
mapToSet :: Occurrences -> DocIdSet
instance Show IntermediateValue
instance Eq IntermediateValue
instance IndexValue DocIdSet
instance IndexValue Occurrences
instance ToJSON IntermediateValue
instance NFData IntermediateValue


-- | The index interface.
module Hunt.Index

-- | The index type class which needs to be implemented to be used by the
--   <tt>Interpreter</tt>. The type parameter <tt>i</tt> is the
--   implementation. The implementation must have a value type parameter.
class IndexValue (IVal i) => Index i where type family IKey i :: * type family IVal i :: * type family ICon i :: Constraint type instance ICon i = () searchSc op k ix = addDefScore $ search op k ix lookupRangeSc k1 k2 ix = addDefScore $ lookupRange k1 k2 ix insert k v = insertList [(k, v)] delete = deleteDocs . singleton map f = mapMaybe (Just . f)
search :: (Index i, ICon i) => TextSearchOp -> IKey i -> i -> [(IKey i, IntermediateValue)]
searchSc :: (Index i, ICon i) => TextSearchOp -> IKey i -> i -> [(IKey i, (Score, IntermediateValue))]
lookupRange :: (Index i, ICon i) => IKey i -> IKey i -> i -> [(IKey i, IntermediateValue)]
lookupRangeSc :: (Index i, ICon i) => IKey i -> IKey i -> i -> [(IKey i, (Score, IntermediateValue))]
insertList :: (Index i, ICon i) => [(IKey i, IntermediateValue)] -> i -> i
insert :: (Index i, ICon i) => IKey i -> IntermediateValue -> i -> i
deleteDocs :: (Index i, ICon i) => DocIdSet -> i -> i
delete :: (Index i, ICon i) => DocId -> i -> i
empty :: (Index i, ICon i) => i
toList :: (Index i, ICon i) => i -> [(IKey i, IntermediateValue)]
fromList :: (Index i, ICon i) => [(IKey i, IntermediateValue)] -> i
unionWith :: (Index i, ICon i) => (IVal i -> IVal i -> IVal i) -> i -> i -> i
map :: (Index i, ICon i) => (IVal i -> IVal i) -> i -> i
mapMaybe :: (Index i, ICon i) => (IVal i -> Maybe (IVal i)) -> i -> i
keys :: (Index i, ICon i) => i -> [IKey i]

-- | Monadic version of <a>Index</a>. <a>Index</a> instances are
--   automatically instance of this type class.
class Monad m => IndexM m i where type family IKeyM i :: * type family IValM i :: * type family IConM i :: Constraint type instance IConM i = () searchMSc op k ix = searchM op k ix >>= return . addDefScore lookupRangeMSc k1 k2 ix = lookupRangeM k1 k2 ix >>= return . addDefScore insertM k v = insertListM [(k, v)] deleteM k i = deleteDocsM (singleton k) i mapM f = mapMaybeM (Just . f)
searchM :: (IndexM m i, IConM i) => TextSearchOp -> IKeyM i -> i -> m [(IKeyM i, IntermediateValue)]
searchMSc :: (IndexM m i, IConM i) => TextSearchOp -> IKeyM i -> i -> m [(IKeyM i, (Score, IntermediateValue))]
lookupRangeM :: (IndexM m i, IConM i) => IKeyM i -> IKeyM i -> i -> m [(IKeyM i, IntermediateValue)]
lookupRangeMSc :: (IndexM m i, IConM i) => IKeyM i -> IKeyM i -> i -> m [(IKeyM i, (Score, IntermediateValue))]
insertListM :: (IndexM m i, IConM i) => [(IKeyM i, IntermediateValue)] -> i -> m (i)
insertM :: (IndexM m i, IConM i) => IKeyM i -> IntermediateValue -> i -> m (i)
deleteDocsM :: (IndexM m i, IConM i) => DocIdSet -> i -> m (i)
deleteM :: (IndexM m i, IConM i) => DocId -> i -> m (i)
emptyM :: (IndexM m i, IConM i) => m (i)
toListM :: (IndexM m i, IConM i) => i -> m [(IKeyM i, IntermediateValue)]
fromListM :: (IndexM m i, IConM i) => [(IKeyM i, IntermediateValue)] -> m (i)
unionWithM :: (IndexM m i, IConM i) => (IValM i -> IValM i -> IValM i) -> i -> i -> m (i)
mapM :: (IndexM m i, IConM i) => (IValM i -> IValM i) -> i -> m (i)
mapMaybeM :: (IndexM m i, IConM i) => (IValM i -> Maybe (IValM i)) -> i -> m (i)
keysM :: (IndexM m i, IConM i) => i -> m [IKeyM i]
addDefScore :: [(a, b)] -> [(a, (Score, b))]
instance (Index i, Monad m) => IndexM m i


-- | Heterogeneous indexes using <tt>ExistentialQuantification</tt>.
--   
--   Indexes have to implement the <a>Index</a> type class as well as obey
--   other constraints defined in <a>IndexImplCon</a>.
--   
--   <i>Note</i>: Due to the nature of <tt>ExistentialQuantification</tt>,
--   deserialization is tricky because the concrete implementation is not
--   known. This is circumvented by storing the type representation of the
--   index. Deserialization is possible if there is a matching type
--   representation in the set of available types. This requires the use of
--   the custom get functions.
module Hunt.Index.IndexImpl

-- | Constraint for index implementations.
type IndexImplCon i = (Index i, Show i, ICon i, IndexValue (IVal i), Binary i, Typeable i, IKey i ~ Text)

-- | Index using <tt>ExistentialQuantification</tt> to allow heterogeneous
--   index containers.
data IndexImpl
IndexImpl :: i -> IndexImpl
ixImpl :: IndexImpl -> i

-- | FIXME: actually implement instance

-- | Deserialize a set of <a>IndexImpl</a>s. Requires a set of available
--   index implementations.
--   
--   <i>Note</i>: This will fail if a used index implementation is not
--   provided.
gets' :: [IndexImpl] -> Get [(Context, IndexImpl)]

-- | Deserialize an <a>IndexImpl</a>. Requires a set of available index
--   implementations.
--   
--   <i>Note</i>: This will fail if a used index implementation is not
--   provided.
get' :: [IndexImpl] -> Get (IndexImpl)

-- | Wrap an index using <tt>ExistentialQuantification</tt> to allow
--   heterogeneous containers.
mkIndex :: IndexImplCon i => i -> IndexImpl
instance Binary IndexImpl
instance NFData IndexImpl
instance Show IndexImpl


-- | The document table interface.
module Hunt.DocTable

-- | The document table type class which needs to be implemented to be used
--   by the <tt>Interpreter</tt>. The type parameter <tt>i</tt> is the
--   implementation. The implementation must have a value type parameter.
class DocumentWrapper (DValue i) => DocTable i where type family DValue i :: * adjust f did d = maybe (return d) (upd d did <=< f) =<< lookup did d where upd i docid v = update docid v i adjustByURI f uri d = maybe (return d) (flip (adjust f) d) =<< lookupByURI uri d deleteByURI u ds = maybe (return ds) (flip delete ds) =<< lookupByURI u ds differenceByURI uris d = do { ids <- liftM (fromList . catMaybes) . mapM (flip lookupByURI d) . toList $ uris; difference ids d }
null :: (DocTable i, Monad m) => i -> m Bool
size :: (DocTable i, Monad m) => i -> m Int
lookup :: (DocTable i, Monad m) => DocId -> i -> m (Maybe (DValue i))
lookupByURI :: (DocTable i, Monad m) => URI -> i -> m (Maybe DocId)
union :: (DocTable i, Monad m) => i -> i -> m i
disjoint :: (DocTable i, Monad m) => i -> i -> m Bool
insert :: (DocTable i, Monad m) => DValue i -> i -> m (DocId, i)
update :: (DocTable i, Monad m) => DocId -> DValue i -> i -> m i
adjust :: (DocTable i, Monad m) => (DValue i -> m (DValue i)) -> DocId -> i -> m i
adjustByURI :: (DocTable i, Monad m) => (DValue i -> m (DValue i)) -> URI -> i -> m i
delete :: (DocTable i, Monad m) => DocId -> i -> m i
deleteByURI :: (DocTable i, Monad m) => URI -> i -> m i
difference :: (DocTable i, Monad m) => DocIdSet -> i -> m i
differenceByURI :: (DocTable i, Monad m) => Set URI -> i -> m i
map :: (DocTable i, Monad m) => (DValue i -> DValue i) -> i -> m i
filter :: (DocTable i, Monad m) => (DValue i -> Bool) -> i -> m i
toMap :: (DocTable i, Monad m) => i -> m (DocIdMap (DValue i))
empty :: DocTable i => i
restrict :: (Functor m, Monad m, Applicative m, DocTable i) => DocIdSet -> i -> m i

-- | JSON dump of the document table.
toJSON'DocTable :: (Functor m, Monad m, Applicative m, DocTable i) => i -> m Value

-- | JSON import of the document table.
fromJSON'DocTable :: (Functor m, Monad m, Applicative m, DocTable i) => Value -> m i


-- | A more space efficient substitute for Hunt.Index.Documents and a more
--   flexible implementation than Hunt.Index.CompactDocuments.
--   
--   DocIds are computed by a hash function, so the inverse map from
--   <a>URI</a>s to <a>DocId</a>s is substituted by the hash function.
--   
--   MurmurHash2 64-bit is used as the hash function.
--   <a>https://sites.google.com/site/murmurhash/</a>
--   
--   It is a fast non-cryptographic hash function with good performance and
--   hash distribution properties.
--   <a>http://programmers.stackexchange.com/a/145633</a>
module Hunt.DocTable.HashedDocTable

-- | The <a>DocTable</a> implementation. Maps <a>DocId</a>s to
--   <a>Document</a>s.
newtype Documents e

-- | A mapping from a document id to the document itself.
Documents :: DocMap e -> Documents e
idToDoc :: Documents e -> DocMap e

-- | The table which is used to map a document to an artificial id and vice
--   versa.
type DocMap e = DocIdMap e

-- | Build a <a>DocTable</a> from a <a>DocIdMap</a> (maps <a>DocId</a>s to
--   <a>Document</a>s)
fromMap :: (DocTable (Documents e), DocumentWrapper e) => (Document -> e) -> DocIdMap Document -> Documents e
instance Eq e => Eq (Documents e)
instance Show e => Show (Documents e)
instance DocumentWrapper e => DocTable (Documents e)
instance (DocumentWrapper e, Binary e) => Binary (Documents e)
instance NFData e => NFData (Documents e)


-- | <a>Bijection</a> instances represent a bijection between two types and
--   allow conversion to and from.
module Data.Bijection

-- | Bijection between two types <tt>a</tt> and <tt>b</tt>. <a>to</a> and
--   <a>from</a> represent the bijective function.
--   
--   For a proper bijection between x and y, two instances need to be
--   defined (<tt>Bijection x y</tt> and <tt>Bijection y x</tt>).
class Bijection a b
to :: Bijection a b => a -> b
from :: Bijection a b => b -> a


-- | Default <a>Bijection</a> instances.
module Data.Bijection.Instances

-- | <a>Text</a> to <a>String</a>.

-- | <a>String</a> to <a>Text</a>.
instance [overlap ok] Bijection String Text
instance [overlap ok] Bijection Text String


-- | Key conversion proxy. Wraps an index to expose the desired key type.
--   The conversion is defined by the <a>Bijection</a> implementation.
--   
--   This can be used for simple conversions like <tt>Text</tt> to
--   <tt>String</tt> or normalization and compression.
module Hunt.Index.Proxy.KeyIndex

-- | Key conversion proxy. <tt>toType</tt> is the desired/exposed key type,
--   followed by the wrapped index type. There has to be a corresponding
--   <a>Bijection</a> instance:
--   
--   <pre>
--   instance Bijection (IKey impl v) toType where ...
--   </pre>
newtype KeyProxyIndex toType impl
KeyProxyIx :: impl -> KeyProxyIndex toType impl
keyProxyIx :: KeyProxyIndex toType impl -> impl
instance [overlap ok] Eq impl => Eq (KeyProxyIndex toType impl)
instance [overlap ok] Show impl => Show (KeyProxyIndex toType impl)
instance [overlap ok] NFData impl => NFData (KeyProxyIndex toType impl)
instance [overlap ok] IndexValue (IVal impl) => Index (KeyProxyIndex toType impl)
instance [overlap ok] Binary impl => Binary (KeyProxyIndex toType impl)


-- | Text index using the <tt>DocIdMap</tt> based on the <tt>StringMap</tt>
--   implementation.
module Hunt.Index.PrefixTreeIndex

-- | Text index using <tt>DocIdMap</tt> based on the <tt>StringMap</tt>
--   implementation. Note that the value parameter is on the type of the
--   <tt>DocIdMap</tt> value and not the <a>DocIdSet</a> itself.
newtype DmPrefixTree v
DmPT :: StringMap v -> DmPrefixTree v
dmPT :: DmPrefixTree v -> StringMap v

-- | Integer index using a <tt>StringMap</tt>-implementation.
newtype SimplePrefixTreeIndex
SimplePTIx :: KeyProxyIndex Text (DmPrefixTree DocIdSet) -> SimplePrefixTreeIndex
simplePTIx :: SimplePrefixTreeIndex -> KeyProxyIndex Text (DmPrefixTree DocIdSet)

-- | Integer index using a <tt>StringMap</tt>-implementation.
newtype PrefixTreeIndexInt
InvIntIx :: KeyProxyIndex Text (KeyProxyIndex UnInt (KeyProxyIndex Text (DmPrefixTree DocIdSet))) -> PrefixTreeIndexInt
invIntIx :: PrefixTreeIndexInt -> KeyProxyIndex Text (KeyProxyIndex UnInt (KeyProxyIndex Text (DmPrefixTree DocIdSet)))

-- | Date index using a <tt>StringMap</tt>-implementation.
newtype PrefixTreeIndexDate
InvDateIx :: KeyProxyIndex Text (KeyProxyIndex UnDate (KeyProxyIndex Text (DmPrefixTree DocIdSet))) -> PrefixTreeIndexDate
invDateIx :: PrefixTreeIndexDate -> KeyProxyIndex Text (KeyProxyIndex UnDate (KeyProxyIndex Text (DmPrefixTree DocIdSet)))
instance Typeable DmPrefixTree
instance Typeable SimplePrefixTreeIndex
instance Typeable PrefixTreeIndexInt
instance Typeable PrefixTreeIndexDate
instance Eq v => Eq (DmPrefixTree v)
instance Show v => Show (DmPrefixTree v)
instance NFData v => NFData (DmPrefixTree v)
instance Eq SimplePrefixTreeIndex
instance Show SimplePrefixTreeIndex
instance NFData SimplePrefixTreeIndex
instance Show UnInt
instance Eq UnInt
instance NFData UnInt
instance Eq PrefixTreeIndexInt
instance Show PrefixTreeIndexInt
instance NFData PrefixTreeIndexInt
instance Show UnDate
instance Eq UnDate
instance NFData UnDate
instance Eq PrefixTreeIndexDate
instance Show PrefixTreeIndexDate
instance NFData PrefixTreeIndexDate
instance Index PrefixTreeIndexDate
instance Binary PrefixTreeIndexDate
instance Bijection Text UnDate
instance Bijection UnDate Text
instance Index PrefixTreeIndexInt
instance Binary PrefixTreeIndexInt
instance Bijection Text UnInt
instance Bijection UnInt Text
instance Index SimplePrefixTreeIndex
instance Binary SimplePrefixTreeIndex
instance IndexValue v => Index (DmPrefixTree v)
instance IndexValue v => Binary (DmPrefixTree v)


-- | Text index using the <tt>DocIdMap</tt> based on the <tt>StringMap</tt>
--   implementation.
module Hunt.Index.PrefixTreeIndex2Dim

-- | Text index using <tt>DocIdMap</tt> based on the <tt>StringMap</tt>
--   implementation. Note that the value parameter is on the type of the
--   <tt>DocIdMap</tt> value and not the <a>DocIdSet</a> itself.
newtype DmPrefixTree v
DmPT :: StringMap v -> DmPrefixTree v
dmPT :: DmPrefixTree v -> StringMap v

-- | Geo-position index using a <tt>StringMap</tt>-implementation.
data PrefixTreeIndexPosition
instance Typeable DmPrefixTree
instance Typeable PrefixTreeIndexPosition
instance Eq v => Eq (DmPrefixTree v)
instance Show v => Show (DmPrefixTree v)
instance NFData v => NFData (DmPrefixTree v)
instance Show UnPos
instance Eq UnPos
instance NFData UnPos
instance Eq PrefixTreeIndexPosition
instance Show PrefixTreeIndexPosition
instance NFData PrefixTreeIndexPosition
instance Index PrefixTreeIndexPosition
instance Binary PrefixTreeIndexPosition
instance Bijection Text UnPos
instance Bijection UnPos Text
instance IndexValue v => Index (DmPrefixTree v)
instance IndexValue v => Binary (DmPrefixTree v)


-- | Top-level index implementations with <a>Text</a> keys for
--   
--   <ul>
--   <li>text<ul><li>integers</li><li>dates and</li><li>geographic
--   positions.</li></ul></li>
--   </ul>
module Hunt.Index.InvertedIndex

-- | Text index using a <tt>StringMap</tt>-implementation.
newtype InvertedIndex
InvIx :: KeyProxyIndex Text (DmPrefixTree Occurrences) -> InvertedIndex
invIx :: InvertedIndex -> KeyProxyIndex Text (DmPrefixTree Occurrences)
mkInvIx :: KeyProxyIndex Text (DmPrefixTree Occurrences) -> InvertedIndex

-- | a simple similarity heuristic for scoring words found when doing a
--   fuzzy or prefix search
similar :: Text -> Text -> Score
similar' :: Text -> Text -> Score

-- | Text index with 2-dimensional lookup using a
--   <tt>StringMap</tt>-implementation.
newtype InvertedIndex2Dim
InvIx2D :: KeyProxyIndex Text (DmPrefixTree Occurrences) -> InvertedIndex2Dim
invIx2D :: InvertedIndex2Dim -> KeyProxyIndex Text (DmPrefixTree Occurrences)
mkInvIx2D :: KeyProxyIndex Text (DmPrefixTree Occurrences) -> InvertedIndex2Dim
instance [overlap ok] Typeable InvertedIndex
instance [overlap ok] Typeable InvertedIndex2Dim
instance [overlap ok] Eq InvertedIndex
instance [overlap ok] Show InvertedIndex
instance [overlap ok] NFData InvertedIndex
instance [overlap ok] Eq InvertedIndex2Dim
instance [overlap ok] Show InvertedIndex2Dim
instance [overlap ok] NFData InvertedIndex2Dim
instance [overlap ok] Index InvertedIndex2Dim
instance [overlap ok] Binary InvertedIndex2Dim
instance [overlap ok] Index InvertedIndex
instance [overlap ok] Binary InvertedIndex


-- | Text index using the <tt>DocIdMap</tt> based on the <tt>StringMap</tt>
--   implementation.
module Hunt.Index.RTreeIndex

-- | Index adapter for <a>RTree</a> data structure
newtype RTreeIndex v
DmRT :: RTree v -> RTreeIndex v
dmRT :: RTreeIndex v -> RTree v

-- | Date index using a <tt>StringMap</tt>-implementation.
newtype SimpleRTreeIndex
InvRTreeIx :: KeyProxyIndex Text (RTreeIndex DocIdSet) -> SimpleRTreeIndex
invRTreeIx :: SimpleRTreeIndex -> KeyProxyIndex Text (RTreeIndex DocIdSet)
readPosition :: Text -> MBB
showPosition :: MBB -> Text
instance Typeable RTreeIndex
instance Typeable SimpleRTreeIndex
instance Eq v => Eq (RTreeIndex v)
instance Show v => Show (RTreeIndex v)
instance NFData v => NFData (RTreeIndex v)
instance Eq SimpleRTreeIndex
instance Show SimpleRTreeIndex
instance NFData SimpleRTreeIndex
instance Index SimpleRTreeIndex
instance Binary SimpleRTreeIndex
instance Bijection MBB Text
instance IndexValue v => Index (RTreeIndex v)
instance IndexValue x => Binary (RTreeIndex x)


-- | Schema for the <tt>ContextIndex</tt>.
--   
--   Every context has a type (e.g. text, int, date, position) and
--   additional schema information. This includes how keys are splitted and
--   normalized when inserted and searched for.
module Hunt.Index.Schema

-- | The global schema assigning schema information to each context.
type Schema = Map Context ContextSchema

-- | The context schema information. Every context schema has a type and
--   additional to adjust the behavior.
--   
--   The regular expression splits the text into words which are then
--   transformed by the given normalizations functions (e.g. to lower
--   case).
data ContextSchema
ContextSchema :: Maybe RegEx -> [CNormalizer] -> Weight -> Bool -> ContextType -> ContextSchema

-- | Optional regex to override the default given by context type.
cxRegEx :: ContextSchema -> Maybe RegEx

-- | Normalizers to apply on keys.
cxNormalizer :: ContextSchema -> [CNormalizer]

-- | Context weight to boost results.
cxWeight :: ContextSchema -> Weight

-- | Whether the context is searched in queries without context-specifier.
cxDefault :: ContextSchema -> Bool

-- | The type of the index (e.g. text, int, date, geo-position).
cxType :: ContextSchema -> ContextType

-- | A general context type like text or int.
data ContextType
CType :: Text -> RegEx -> CValidator -> IndexImpl -> ContextType

-- | Name used in the (JSON) API.
ctName :: ContextType -> Text

-- | Default regex to split words.
ctRegEx :: ContextType -> RegEx

-- | Validation function for keys.
ctValidate :: ContextType -> CValidator

-- | The index implementation used for this type.
ctIxImpl :: ContextType -> IndexImpl

-- | Set of context types.
type ContextTypes = [ContextType]

-- | Validation function for single words.
data CValidator
CValidator :: (Word -> Bool) -> CValidator
validate :: CValidator -> Word -> Bool

-- | Normalizer for words/keys of an index.
data CNormalizer
CNormalizer :: Text -> (Text -> Text) -> CNormalizer

-- | Name used in (JSON) API.
cnName :: CNormalizer -> Text

-- | Normalization function.
normalize :: CNormalizer -> Text -> Text

-- | Apply the normalizers to a word.
normalize' :: [CNormalizer] -> Word -> Word

-- | Text context type.
ctText :: ContextType

-- | Special text context type smaller index but not phrase queries
--   possible (due to not storing the words positions)
ctTextSimple :: ContextType

-- | Int context type.
ctInt :: ContextType

-- | Date context type.
ctDate :: ContextType

-- | Geographic position context type.
ctPosition :: ContextType
ctPositionRTree :: ContextType

-- | Uppercase normalizer "UpperCase".
cnUpperCase :: CNormalizer

-- | Lowercase normalizer "LowerCase".
cnLowerCase :: CNormalizer

-- | Int normalizer "ZeroFill" to preserve int ordering on strings.
cnZeroFill :: CNormalizer
instance Show ContextType
instance Show ContextSchema
instance Binary CNormalizer
instance Binary ContextType
instance Binary ContextSchema
instance ToJSON ContextSchema
instance FromJSON ContextSchema
instance ToJSON CNormalizer
instance FromJSON CNormalizer
instance ToJSON ContextType
instance FromJSON ContextType
instance Default CNormalizer
instance Show CNormalizer
instance Show CValidator
instance Default CValidator
instance Default IndexImpl
instance Default ContextType
instance Default ContextSchema


-- | Common data types shared by all index types and a unified interface
--   for all different index types. This module defines the common
--   interfaces of indexes and their document tables as well as full-text
--   caches.
module Hunt.Common


-- | The context index introduces contexts and combines the index, document
--   table and schema.
module Hunt.ContextIndex
empty :: DocTable dt => ContextIndex dt

-- | Inserts a new context.
insertContext :: Context -> IndexImpl -> ContextSchema -> ContextIndex dt -> ContextIndex dt

-- | Removes context (including the index and the schema).
deleteContext :: Context -> ContextIndex dt -> ContextIndex dt
foreachContext :: (Functor m, Monad m) => [Context] -> (Context -> m res) -> m [(Context, res)]

-- | Contexts/keys of <a>ContextMap</a>.
contexts :: ContextMap -> [Context]

-- | All contexts of the index.
contextsM :: (Monad m, DocTable dt) => ContextIndex dt -> m [Context]

-- | Check if the context exists.
hasContext :: Context -> ContextMap -> Bool

-- | Does the context exist?
hasContextM :: (Monad m, DocTable dt) => Context -> ContextIndex dt -> m Bool

-- | Range query in a context between first and second key.
lookupRangeCx :: Monad m => Context -> Text -> Text -> ContextMap -> m [(Text, IntermediateValue)]

-- | Dump a context
lookupAllWithCx :: Monad m => Context -> ContextMap -> m [(Text, IntermediateValue)]

-- | Search query in a context.
searchWithCx :: Monad m => TextSearchOp -> Context -> Text -> ContextMap -> m [(Text, IntermediateValue)]

-- | Search over a list of contexts and words
searchWithCxsNormalized :: (Functor m, Monad m) => TextSearchOp -> [(Context, Text)] -> ContextMap -> m [(Context, [(Text, IntermediateValue)])]

-- | Search query with scored results XXX TODO: this function should return
--   intermediates and query processor should work with those
searchWithCxSc :: Monad m => TextSearchOp -> Context -> Text -> ContextMap -> m [(Text, (Score, Occurrences))]

-- | Range query in a context between first and second key. XXX TODO: this
--   function should return intermediates and query processor should work
--   with those
lookupRangeCxSc :: Monad m => Context -> Text -> Text -> ContextMap -> m [(Text, (Score, Occurrences))]

-- | Insert multiple documents and words.
insertList :: (MonadParallel m, Applicative m, DocTable dt) => [(DValue dt, Words)] -> ContextIndex dt -> m (ContextIndex dt)
createDocTableFromPartition :: (MonadParallel m, DocTable dt) => [(DValue dt, Words)] -> m (dt, [(DocId, Words)])
unionDocTables :: (DocTable dt, MonadParallel m) => [(dt, [(DocId, Words)])] -> dt -> m (dt, [(DocId, Words)])

-- | Modify the description of a document and add words (occurrences for
--   that document) to the index.
modifyWithDescription :: (MonadParallel m, Applicative m, DocTable dt) => Score -> Description -> Words -> DocId -> ContextIndex dt -> m (ContextIndex dt)

-- | Delete a set of documents by <a>DocId</a>.
delete :: (MonadParallel m, Applicative m, DocTable dt) => DocIdSet -> ContextIndex dt -> m (ContextIndex dt)

-- | Delete a set of documents by <a>URI</a>.
deleteDocsByURI :: (MonadParallel m, Applicative m, DocTable dt) => Set URI -> ContextIndex dt -> m (ContextIndex dt)

-- | Deserialize a <a>ContextIndex</a> with the list of available index
--   implementations and a map of available <a>ContextSchema</a>.
--   
--   <i>Note</i>: The serialized index implementations have to be in the
--   list of available types, otherwise this will fail. The serialized
--   schemas have to be in the list of available <a>ContextSchema</a>,
--   otherwise this will fail as well.
decodeCxIx :: (Binary dt, DocTable dt) => [IndexImpl] -> ByteString -> ContextIndex dt

-- | Is the document part of the index?
member :: (Monad m, Applicative m, DocTable dt) => URI -> ContextIndex dt -> m Bool

-- | Context index introduces contexts and combines the major components of
--   Hunt.
data ContextIndex dt
ContextIndex :: !ContextMap -> !dt -> ContextIndex dt

-- | Indexes associated to contexts.
ciIndex :: ContextIndex dt -> !ContextMap

-- | Document table.
ciDocs :: ContextIndex dt -> !dt
newtype ContextMap
ContextMap :: Map Context IndexRep -> ContextMap
cxMap :: ContextMap -> Map Context IndexRep

-- | Contexts with associated heterogeneous index implementations.
type IndexRep = (ContextSchema, IndexImpl)

-- | Strict smart constructor for the <a>ContextMap</a>.
mkContextMap :: Map Context IndexRep -> ContextMap

-- | Get <a>Schema</a> from <a>ContextMap</a>
mapToSchema :: ContextMap -> Schema
instance Show ContextMap
instance Binary dt => Binary (ContextIndex dt)
instance Binary ContextMap


-- | The data type for results of Holumbus queries.
--   
--   The result of a query is defined in terms of two partial results, the
--   documents containing the search terms and the words which are possible
--   completions of the search terms.
module Hunt.Query.Result

-- | The combined result type for Holumbus queries.
data Result e
Result :: DocHits e -> WordHits -> Result e

-- | The documents matching the query.
docHits :: Result e -> DocHits e

-- | The words which are completions of the query terms.
wordHits :: Result e -> WordHits

-- | A mapping from a document to it's score and the contexts where it was
--   found.
type DocHits e = DocIdMap (DocInfo e, DocContextHits)

-- | A mapping from a context to the words of the document that were found
--   in this context.
type DocContextHits = Map Context DocWordHits

-- | A mapping from a word of the document in a specific context to it's
--   positions.
type DocWordHits = Map Word Positions

-- | A mapping from a word to it's score and the contexts where it was
--   found.
type WordHits = Map Word WordInfoAndHits

-- | A mapping from a context to the documents that contain the word that
--   were found in this context.
type WordContextHits = Map Context WordDocHits

-- | A mapping from a document containing the word to the positions of the
--   word.
type WordDocHits = DocBoosts

-- | Information about an document.
data DocInfo e
DocInfo :: e -> Weight -> Score -> DocInfo e

-- | The document itself.
document :: DocInfo e -> e

-- | The document weight, init with <tt>1.0</tt>
docBoost :: DocInfo e -> Weight

-- | The score for the document (initial score for all documents is
--   <tt>0.0</tt>).
docScore :: DocInfo e -> Score

-- | Information about a word.
data WordInfo
WordInfo :: Terms -> Score -> WordInfo

-- | The search terms that led to this very word.
terms :: WordInfo -> Terms

-- | The frequency of the word in the document for a context.
wordScore :: WordInfo -> Score
data WordInfoAndHits
WIH :: WordInfo -> WordContextHits -> WordInfoAndHits

-- | The score of a hit (either a document hit or a word hit). type Score =
--   Float
--   
--   Weight or score of a documents, <tt>0.0</tt> indicates: not set, so
--   there is no need to work with Maybe's wrapped in newtype to not mix up
--   with Score's and Weight's in documents
data Score

-- | Weight (for ranking).
type Weight = Score

-- | Boosting of a single document.
type Boost = Score

-- | Document boosting.
type DocBoosts = DocIdMap Score

-- | Create an empty result.
emptyResult :: Result e

-- | Test if the result contains anything.
null :: Result e -> Bool

-- | Query the number of documents in a result.
sizeDocHits :: Result e -> Int

-- | Query the number of documents in a result.
sizeWordHits :: Result e -> Int

-- | Query the maximum score of the documents.
maxScoreDocHits :: Result e -> Score

-- | Query the maximum score of the words.
maxScoreWordHits :: Result e -> Score

-- | Extract all documents from a result.
getDocuments :: Result e -> [e]

-- | Set the score in a document info.
setDocScore :: Score -> DocInfo e -> DocInfo e

-- | Set the score in a word info.
setWordScore :: Score -> WordInfo -> WordInfo
instance Show e => Show (Result e)
instance Eq WordInfo
instance Show WordInfo
instance Eq WordInfoAndHits
instance Show WordInfoAndHits
instance Monoid WordInfoAndHits
instance Monoid WordInfo
instance Show (DocInfo e)


-- | The intermediate query results which have to be merged for the various
--   combinatorial operations.
--   
--   <tt>toResult</tt> creates the final result which includes the document
--   (and word) hits.
module Hunt.Query.Intermediate
class Monoid a => ScoredResult a
boost :: ScoredResult a => Score -> a -> a
nullSC :: ScoredResult a => a -> Bool
differenceSC :: ScoredResult a => a -> a -> a
intersectSC :: ScoredResult a => a -> a -> a
intersectDisplSC :: ScoredResult a => Int -> a -> a -> a
intersectFuzzySC :: ScoredResult a => Int -> Int -> a -> a -> a
class Aggregate a b
aggregate :: Aggregate a b => a -> b
data ScoredDocs
data ScoredWords
type ScoredContexts = ScoredWords
data ScoredOccs
data ScoredRawDocs

-- | Add the Context dimension to a scored result
data ScoredCx a

-- | The result type for unscored search of documents
--   
--   used when all matching docs must be processed, e.g. in DeleteByQuery
--   commands
data UnScoredDocs
newtype RankedDoc
RD :: (Score, Document) -> RankedDoc
unRD :: RankedDoc -> (Score, Document)
toScoredDocs :: Occurrences -> ScoredDocs

-- | The final op for a search result: boost the partial results of the
--   contexts with the context weights from the schema and aggregate them
--   by throwing away the contexts
boostAndAggregateCx :: ScoredResult a => ScoredContexts -> ScoredCx a -> a
fromCxRawResults :: CxRawResults -> ScoredCx ScoredRawDocs
fromRawResult :: Context -> RawScoredResult -> ScoredCx ScoredRawDocs
limitRawResult :: Int -> RawScoredResult -> RawScoredResult
limitCxRawResults :: Int -> CxRawResults -> CxRawResults
contextWeights :: Schema -> ScoredContexts
filterByDocSet :: UnScoredDocs -> ScoredRawDocs -> ScoredRawDocs
toDocIdSet :: UnScoredDocs -> DocIdSet

-- | convert a set of scored doc ids into a list of documents containing
--   the score
--   
--   This list may be further sorted by score, partitioned into pages or
--   ...
toDocsResult :: (Applicative m, Monad m, DocTable dt) => dt -> ScoredDocs -> m [RankedDoc]
toDocumentResultPage :: Int -> Int -> [RankedDoc] -> [RankedDoc]
toWordsResult :: Int -> ScoredWords -> [(Word, Score)]

-- | combine a sequence of results from a phrase query into a single result
--   and aggregate this result into a simpler structure, e.g. a
--   <tt>ScoredDocs</tt> or <tt>ScoredWords</tt> value
--   
--   The arguments must be of this unaggregated from, still containing word
--   positions, else sequences of words are not detected
evalSequence :: (ScoredResult r, Aggregate ScoredRawDocs r) => (ScoredCx ScoredRawDocs -> ScoredCx r) -> [ScoredCx ScoredRawDocs] -> ScoredCx r
evalFollow :: (ScoredResult r, Aggregate ScoredRawDocs r) => (ScoredCx ScoredRawDocs -> ScoredCx r) -> Int -> [ScoredCx ScoredRawDocs] -> ScoredCx r
evalNear :: (ScoredResult r, Aggregate ScoredRawDocs r) => (ScoredCx ScoredRawDocs -> ScoredCx r) -> Int -> [ScoredCx ScoredRawDocs] -> ScoredCx r
evalOr :: ScoredResult a => [a] -> a
evalAnd :: ScoredResult a => [a] -> a
evalAndNot :: ScoredResult a => [a] -> a
evalBoost :: ScoredResult a => Score -> a -> a
evalPrim :: Aggregate (ScoredCx ScoredRawDocs) (ScoredCx r) => ScoredCx ScoredRawDocs -> ScoredCx r
instance Show ScoredDocs
instance Show UnScoredDocs
instance Monoid UnScoredDocs
instance Show ScoredWords
instance Show ScoredOccs
instance Show ScoredRawDocs
instance Show a => Show (ScoredCx a)
instance Show RankedDoc
instance Eq RankedWord
instance Aggregate a b => Aggregate (ScoredCx a) (ScoredCx b)
instance Aggregate ScoredRawDocs ScoredWords
instance Aggregate ScoredRawDocs UnScoredDocs
instance Aggregate ScoredRawDocs ScoredDocs
instance Aggregate ScoredOccs Score
instance Aggregate ScoredOccs UnScoredDocs
instance Aggregate ScoredOccs ScoredDocs
instance Aggregate ScoredDocs Score
instance Aggregate a a
instance Ord RankedWord
instance ToJSON RankedDoc
instance Ord RankedDoc
instance Eq RankedDoc
instance ScoredResult a => ScoredResult (ScoredCx a)
instance Monoid a => Monoid (ScoredCx a)
instance Functor ScoredCx
instance ScoredResult ScoredRawDocs
instance Monoid ScoredRawDocs
instance ScoredResult ScoredOccs
instance Monoid ScoredOccs
instance ScoredResult ScoredWords
instance Monoid ScoredWords
instance ScoredResult UnScoredDocs
instance ScoredResult ScoredDocs
instance Monoid ScoredDocs


-- | Version : 0.3
--   
--   The ranking mechanism for Hunt.
--   
--   Customized ranking functions for both documents and suggested words
--   can be provided by the user. Some predefined ranking functions are
--   avaliable, too.
module Hunt.Query.Ranking

-- | The configuration of the ranking mechanism.
data RankConfig e
RankConfig :: DocRanking e -> WordRanking -> RankConfig e

-- | A function to determine the score of a document.
docRanking :: RankConfig e -> DocRanking e

-- | A function to determine the score of a word.
wordRanking :: RankConfig e -> WordRanking

-- | The signature of a function to determine the score of a document.
type DocRanking e = ContextWeights -> DocId -> Score -> DocInfo e -> DocContextHits -> Score

-- | The signature of a function to determine the score of a word.
type WordRanking = Word -> WordInfo -> WordContextHits -> Score

-- | Weights for the contexts (optional).
type ContextWeights = Map Context Weight

-- | Rank the result with custom ranking functions (and the given context
--   weights).
rank :: (DocTable dt, Monad m, Applicative m) => RankConfig e -> dt -> ContextWeights -> Result e -> m (Result e)

-- | Rank documents by count and multiply occurrences with their respective
--   context weights (default <tt>1.0</tt>). Pass an empty map to discard
--   context weights.
--   
--   <pre>
--   docRankByCount :: ContextWeights -&gt; DocId -&gt; Score -&gt; DocInfo e -&gt; DocContextHits -&gt; Score
--   </pre>
docRankByCount :: DocRanking e

-- | Rank words by count.
--   
--   <pre>
--   wordRankByCount :: Word -&gt; WordInfo -&gt; WordContextHits -&gt; Score
--   </pre>
wordRankByCount :: WordRanking
wordRankBySimilarity :: WordRanking

-- | The configuration of the ranking mechanism.
defaultRankConfig :: DocumentWrapper e => RankConfig e


-- | Analyzer for index data. Creates raw index data by splitting and
--   normalizing the <a>ApiDocument</a> index data as defined in the
--   schema.
module Hunt.Index.Schema.Analyze

-- | Extracts the <a>Document</a> (<a>DocumentWrapper</a>) and raw index
--   data from an <a>ApiDocument</a> in compliance with the schema.
--   
--   <i>Note</i>: Contexts mentioned in the <a>ApiDocument</a> need to
--   exist.
toDocAndWords :: DocumentWrapper e => Schema -> ApiDocument -> (e, Score, Words)

-- | Extracts the <a>Document</a> and raw index data from an
--   <a>ApiDocument</a> in compliance with the schema.
--   
--   <i>Note</i>: Contexts mentioned in the ApiDoc need to exist.
toDocAndWords' :: Schema -> ApiDocument -> (Document, Score, Words)

-- | Normalization function.
normalize :: CNormalizer -> Text -> Text

-- | Tokenize a text with a regular expression for words.
--   
--   <pre>
--   scanTextRE "[^ \t\n\r]*" == Data.Text.words
--   </pre>
--   
--   Grammar: <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>
scanTextRE :: RegEx -> Text -> [Word]


-- | Basic "low-level" commands that are directly interpreted.
--   
--   <a>Hunt.Interpreter.Command</a> defines the "high-level" commands
--   accepted by the (JSON) API.
module Hunt.Interpreter.BasicCommand

-- | The "low-level" commands that are actually interpreted.
data BasicCommand

-- | Search query with pagination.
Search :: Query -> Int -> Int -> Bool -> Maybe [Text] -> BasicCommand
icQuery :: BasicCommand -> Query
icOffsetSR :: BasicCommand -> Int
icMaxSR :: BasicCommand -> Int
icWeight :: BasicCommand -> Bool
icFields :: BasicCommand -> Maybe [Text]

-- | Auto-completion query with a limit.
Completion :: Query -> Int -> BasicCommand
icPrefixCR :: BasicCommand -> Query
icMaxCR :: BasicCommand -> Int

-- | Raw query without any ranking, scoring and ordering
Select :: Query -> BasicCommand
icQuery :: BasicCommand -> Query

-- | Insert documents.
InsertList :: [ApiDocument] -> BasicCommand
icDocs :: BasicCommand -> [ApiDocument]

-- | Update the document description.
Update :: ApiDocument -> BasicCommand
icDoc :: BasicCommand -> ApiDocument

-- | Delete documents by <a>URI</a>.
DeleteDocs :: Set URI -> BasicCommand
icUris :: BasicCommand -> Set URI

-- | Delete all documents of the query result.
DeleteByQuery :: Query -> BasicCommand
icQueryD :: BasicCommand -> Query

-- | Insert a context and the associated schema.
InsertContext :: Context -> ContextSchema -> BasicCommand
icICon :: BasicCommand -> Context
icSchema :: BasicCommand -> ContextSchema

-- | Delete a context.
DeleteContext :: Context -> BasicCommand
icDCon :: BasicCommand -> Context

-- | Deserialize the index.
LoadIx :: FilePath -> BasicCommand
icPath :: BasicCommand -> FilePath

-- | Serialize the index.
StoreIx :: FilePath -> BasicCommand
icPath :: BasicCommand -> FilePath

-- | Query general information about the server/index.
Status :: StatusCmd -> BasicCommand
icStatus :: BasicCommand -> StatusCmd

-- | Sequence commands.
Sequence :: [BasicCommand] -> BasicCommand
icCmdSeq :: BasicCommand -> [BasicCommand]

-- | No operation. Can be used in control flow and as an alive test.
NOOP :: BasicCommand

-- | Available status commands.
data StatusCmd

-- | Garbage collection statistics.
StatusGC :: StatusCmd

-- | Document table JSON dump.
StatusDocTable :: StatusCmd

-- | Index JSON dump.
StatusIndex :: StatusCmd

-- | Index context dump
StatusContext :: Context -> StatusCmd
instance Show StatusCmd
instance Show BasicCommand
instance LogShow BasicCommand
instance FromJSON StatusCmd
instance ToJSON StatusCmd


-- | "High-level" commands that are accepted by the (JSON) API.
--   
--   These commands are translated with <a>toBasicCommand</a> to
--   <a>BasicCommand</a>s which can be interpreted.
module Hunt.Interpreter.Command

-- | The "high-level" commands accepted by the <tt>Interpreter</tt> / JSON
--   API. These are translated to <a>BasicCommand</a>s.
data Command

-- | Search query with pagination.
Search :: Query -> Int -> Int -> Bool -> Maybe [Text] -> Command
icQuery :: Command -> Query
icOffsetSR :: Command -> Int
icMaxSR :: Command -> Int
icWeight :: Command -> Bool
icFields :: Command -> Maybe [Text]

-- | Auto-completion query with a limit.
Completion :: Query -> Int -> Command
icPrefixCR :: Command -> Query
icMaxCR :: Command -> Int

-- | Raw query without any ranking, scoring and ordering
Select :: Query -> Command
icQuery :: Command -> Query

-- | Insert a document.
Insert :: ApiDocument -> Command
icDoc :: Command -> ApiDocument

-- | Update a documents' description.
Update :: ApiDocument -> Command
icDoc :: Command -> ApiDocument

-- | Delete a documents by <a>URI</a>.
Delete :: URI -> Command
icUri :: Command -> URI

-- | Delete all documents of the query result.
DeleteByQuery :: Query -> Command
icQueryD :: Command -> Query

-- | Insert a context and the associated schema.
InsertContext :: Context -> ContextSchema -> Command
icIContext :: Command -> Context
icSchema :: Command -> ContextSchema

-- | Delete a context.
DeleteContext :: Context -> Command
icDContext :: Command -> Context

-- | Deserialize the index.
LoadIx :: FilePath -> Command
icPath :: Command -> FilePath

-- | Serialize the index.
StoreIx :: FilePath -> Command
icPath :: Command -> FilePath

-- | Query general information about the server/index.
Status :: StatusCmd -> Command
icStatus :: Command -> StatusCmd

-- | Sequence commands.
Sequence :: [Command] -> Command
icCmdSeq :: Command -> [Command]

-- | No operation. Can be used in control flow and as an alive test.
NOOP :: Command

-- | Available status commands.
data StatusCmd

-- | Garbage collection statistics.
StatusGC :: StatusCmd

-- | Document table JSON dump.
StatusDocTable :: StatusCmd

-- | Index JSON dump.
StatusIndex :: StatusCmd

-- | Index context dump
StatusContext :: Context -> StatusCmd

-- | The result of an interpreted command.
data CmdResult

-- | The command was processed successfully.
ResOK :: CmdResult

-- | The search results.
ResSearch :: LimitedResult RankedDoc -> CmdResult
crRes :: CmdResult -> LimitedResult RankedDoc

-- | The auto-completion results.
ResCompletion :: [(Text, [Text])] -> CmdResult
crWords :: CmdResult -> [(Text, [Text])]

-- | The simplified completion result
ResSuggestion :: [(Text, Score)] -> CmdResult
crSugg :: CmdResult -> [(Text, Score)]

-- | A generic JSON result.
ResGeneric :: Value -> CmdResult
crGen :: CmdResult -> Value

-- | An error during processing of the command. This includes a error code
--   and a message.
data CmdError
ResError :: Int -> Text -> CmdError

-- | Error code.
ceCode :: CmdError -> Int

-- | Message describing the error.
ceMsg :: CmdError -> Text

-- | auxiliary type for parsing JSON CmdResult's of various kinds
--   
--   usefull in hunt applications, not used within the hunt server
newtype CmdRes a
CmdRes :: a -> CmdRes a
unCmdRes :: CmdRes a -> a

-- | Transform the supported input command into lower level commands which
--   are actually interpreted.
--   
--   Transformations:
--   
--   <ul>
--   <li>Multiple <a>Delete</a>s into a single
--   <tt>DeleteDocs</tt>.<ul><li>Multiple <a>Insert</a>s into a single or
--   multiple <tt>InsertList</tt>s.</li></ul></li>
--   </ul>
toBasicCommand :: Command -> BasicCommand
instance Show Command
instance Show CmdResult
instance Eq CmdResult
instance Show CmdError
instance Show a => Show (CmdRes a)
instance FromJSON CmdError
instance ToJSON CmdError
instance Error CmdError
instance ToJSON CmdResult
instance FromJSON Command
instance ToJSON Command
instance LogShow Command
instance FromJSON a => FromJSON (CmdRes a)
instance NFData CmdError
instance NFData CmdResult


-- | Common data types and and smart constructors for calling a hunt server
--   from a client.
--   
--   Values of the Command datatype and its component types, e.g Query,
--   ApiDocument, and others can be constructed with the "smart"
--   construtors defined in this module
--   
--   The module is intended to be imported qualified, eg like <tt>import
--   qualified Hunt.ClientInterface as HI</tt>.
module Hunt.ClientInterface

-- | The "high-level" commands accepted by the <tt>Interpreter</tt> / JSON
--   API. These are translated to <a>BasicCommand</a>s.
data Command

-- | The document accepted by the interpreter and JSON API.
data ApiDocument
ApiDocument :: URI -> IndexMap -> Description -> Score -> ApiDocument

-- | The unique identifier.
adUri :: ApiDocument -> URI

-- | The data to index according to schema associated with the context.
adIndex :: ApiDocument -> IndexMap

-- | The document description (a simple key-value map).
adDescr :: ApiDocument -> Description

-- | An optional document boost, (internal default is <tt>1.0</tt>).
adWght :: ApiDocument -> Score
class Huntable x where huntIndexMap _ = emptyApiDocIndexMap huntDescr _ = emptyApiDocDescr toApiDocument x = setDescription (huntDescr x) $ setIndex (huntIndexMap x) $ mkApiDoc $ (huntURI x)
huntURI :: Huntable x => x -> URI
huntIndexMap :: Huntable x => x -> IndexMap
huntDescr :: Huntable x => x -> Description
toApiDocument :: Huntable x => x -> ApiDocument

-- | The content of a document.
type Content = Text

-- | The name of a context.
type Context = Text

-- | The context schema information. Every context schema has a type and
--   additional to adjust the behavior.
--   
--   The regular expression splits the text into words which are then
--   transformed by the given normalizations functions (e.g. to lower
--   case).
data ContextSchema

-- | The description of a document is a generic key value map.
type Description = DocDesc

-- | Context map
type IndexMap = Map Context Content

-- | Regular expression.
type RegEx = Text

-- | Available status commands.
data StatusCmd

-- | The URI describing the location of the original document.
type URI = Text

-- | Weight (for ranking).
type Weight = Score

-- | An error during processing of the command. This includes a error code
--   and a message.
data CmdError
ResError :: Int -> Text -> CmdError

-- | Error code.
ceCode :: CmdError -> Int

-- | Message describing the error.
ceMsg :: CmdError -> Text

-- | auxiliary type for parsing JSON CmdResult's of various kinds
--   
--   usefull in hunt applications, not used within the hunt server
newtype CmdRes a
CmdRes :: a -> CmdRes a
unCmdRes :: CmdRes a -> a

-- | The result of an interpreted command.
data CmdResult

-- | The command was processed successfully.
ResOK :: CmdResult

-- | The search results.
ResSearch :: LimitedResult RankedDoc -> CmdResult
crRes :: CmdResult -> LimitedResult RankedDoc

-- | The auto-completion results.
ResCompletion :: [(Text, [Text])] -> CmdResult
crWords :: CmdResult -> [(Text, [Text])]

-- | The simplified completion result
ResSuggestion :: [(Text, Score)] -> CmdResult
crSugg :: CmdResult -> [(Text, Score)]

-- | A generic JSON result.
ResGeneric :: Value -> CmdResult
crGen :: CmdResult -> Value

-- | Paginated result with an offset and chunk size.
data LimitedResult x
LimitedResult :: [x] -> Int -> Int -> Int -> LimitedResult x

-- | The list with at most <a>lrMax</a> elements.
lrResult :: LimitedResult x -> [x]

-- | The offset of the result.
lrOffset :: LimitedResult x -> Int

-- | The limit for the result.
lrMax :: LimitedResult x -> Int

-- | The size of the complete result.
lrCount :: LimitedResult x -> Int

-- | The score of a hit (either a document hit or a word hit). type Score =
--   Float
--   
--   Weight or score of a documents, <tt>0.0</tt> indicates: not set, so
--   there is no need to work with Maybe's wrapped in newtype to not mix up
--   with Score's and Weight's in documents
data Score

-- | create simple search command
cmdSearch :: Query -> Command

-- | Create simple completion command
cmdCompletion :: Query -> Command
cmdSelect :: Query -> Command

-- | insert document
cmdInsertDoc :: ApiDocument -> Command

-- | update document
cmdUpdateDoc :: ApiDocument -> Command

-- | delete document identified by an URI
cmdDeleteDoc :: URI -> Command

-- | delete all documents idenitfied by a query
cmdDeleteDocsByQuery :: Query -> Command
cmdLoadIndex :: FilePath -> Command
cmdStoreIndex :: FilePath -> Command
cmdInsertContext :: Context -> ContextSchema -> Command
cmdDeleteContext :: Context -> Command
cmdStatus :: StatusCmd -> Command
cmdSequence :: [Command] -> Command
cmdNOOP :: Command

-- | configure search command: set the list of attributes of the document
--   decription to be included in the result list
--   
--   example: <tt>setSelectedFields ["title", "date"]</tt> restricts the
--   documents attributes to these to fields
setSelectedFields :: [Text] -> Command -> Command

-- | configure search and completion command: set the max # of results
setMaxResults :: Int -> Command -> Command

-- | configure search command: set the starting offset of the result list
setResultOffset :: Int -> Command -> Command

-- | configure search command: include document weight in result list
setWeightIncluded :: Command -> Command

-- | create InsertContext Commands by a list of Insert Commands These
--   contexts are not optimized and shoudn't be used in production code.
createContextCommands :: [ApiDocument] -> Command

-- | build an api document with an uri as key and a description map as
--   contents
mkApiDoc :: URI -> ApiDocument

-- | add an index map containing the text parts to be indexed
setDescription :: Description -> ApiDocument -> ApiDocument
getDescription :: ApiDocument -> Description
addDescription :: ToJSON v => Text -> v -> ApiDocument -> ApiDocument
remDescription :: Text -> ApiDocument -> ApiDocument
changeDescription :: (Description -> Description) -> ApiDocument -> ApiDocument
lookupDescription :: FromJSON v => Text -> ApiDocument -> Maybe v
lookupDescriptionText :: Text -> ApiDocument -> Text

-- | add an index map containing the text parts to be indexed
setIndex :: IndexMap -> ApiDocument -> ApiDocument
addToIndex :: Context -> Content -> ApiDocument -> ApiDocument
getFromIndex :: Context -> ApiDocument -> Text
changeIndex :: (IndexMap -> IndexMap) -> ApiDocument -> ApiDocument

-- | add a document weight
setDocWeight :: Score -> ApiDocument -> ApiDocument

-- | wrapper for building an ApiDocument by lists
listToApiDoc :: Text -> [(Text, Text)] -> [(Text, Text)] -> ApiDocument
insertCmdsToDocuments :: Command -> [ApiDocument]
mkDescription :: [(Text, Text)] -> Description
mapToDescr :: Map Text Text -> DocDesc
insDescription :: ToJSON v => Text -> v -> Description -> Description
emptyDescription :: Description
fromDescription :: Description -> [(Text, Value)]

-- | The query language.
data Query

-- | Parse a query using the default syntax provided by the Hunt framework.
parseQuery :: String -> Either Text Query

-- | Renders a text representation of a Query.
printQuery :: Query -> Text
completeQueries :: Query -> [Text] -> [Query]

-- | the default schema: context type is text, no normalizers, weigth is
--   1.0, context is always searched by queries without context spec
mkSchema :: ContextSchema

-- | prevent searching in context, when not explicitly set in query
setCxNoDefault :: ContextSchema -> ContextSchema

-- | set the regex for splitting a text into words
setCxWeight :: Float -> ContextSchema -> ContextSchema

-- | set the regex for splitting a text into words
setCxRegEx :: RegEx -> ContextSchema -> ContextSchema

-- | add a text normalizer for transformation into uppercase
setCxUpperCase :: ContextSchema -> ContextSchema

-- | add a text normalizer for transformation into lowercase
setCxLowerCase :: ContextSchema -> ContextSchema

-- | add a text normalizer for transformation into lowercase
setCxZeroFill :: ContextSchema -> ContextSchema

-- | set the type of a context to text
setCxText :: ContextSchema -> ContextSchema

-- | set the type of a context to Int
setCxInt :: ContextSchema -> ContextSchema

-- | set the type of a context to Date
setCxDate :: ContextSchema -> ContextSchema

-- | set the type of a context to Int
setCxPosition :: ContextSchema -> ContextSchema
noScore :: Score
defScore :: Score
mkScore :: Float -> Score
getScore :: Score -> Maybe Float

-- | send command as JSON into a file
--   
--   the JSON is pretty printed with aeson-pretty, <tt>""</tt> and
--   <tt>"-"</tt> are used for output to stdout
sendCmdToFile :: String -> Command -> IO ()


-- | The query processor to perform <a>Query</a>s.
--   
--   <tt>processQuery</tt> executes the query and generates the unranked
--   result. The result can be ranked with the default <a>rank</a>
--   function.
module Hunt.Query.Processor
processQueryScoredDocs :: ProcessEnv -> Query -> IO (Either CmdError ScoredDocs)
processQueryUnScoredDocs :: ProcessEnv -> Query -> IO (Either CmdError UnScoredDocs)
processQueryScoredWords :: ProcessEnv -> Query -> IO (Either CmdError ScoredWords)

-- | Initialize the state of the processor.
initProcessor :: ProcessConfig -> QueryIndex -> ProcessEnv

-- | Query processor configuration.
data ProcessConfig
ProcessConfig :: !FuzzyConfig -> !Bool -> !Int -> !Int -> ProcessConfig

-- | The configuration for fuzzy queries.
fuzzyConfig :: ProcessConfig -> !FuzzyConfig

-- | Optimize the query before processing (default: <tt>False</tt>).
optimizeQuery :: ProcessConfig -> !Bool

-- | The maximum number of words used from a prefix. <tt>0</tt> = no limit
--   (default: <tt>100</tt>).
wordLimit :: ProcessConfig -> !Int

-- | The maximum number of documents taken into account. <tt>0</tt> = no
--   limit (default: <tt>500</tt>).
docLimit :: ProcessConfig -> !Int

-- | The internal state of the query processor.
data ProcessEnv
instance (Monad m, Functor m) => Applicative (ProcessorT m)
instance Monad m => Monad (ProcessorT m)
instance MonadIO m => MonadIO (ProcessorT m)
instance Functor m => Functor (ProcessorT m)
instance Monad m => MonadReader ProcessEnv (ProcessorT m)
instance Monad m => MonadError CmdError (ProcessorT m)
instance MonadTrans ProcessorT
instance Binary ProcessConfig
instance Default ProcessConfig


-- | An <a>MVar</a> variation that only blocks for modification. Readers
--   are never blocked but write access is carried out in sequence.
--   
--   This is done with two <a>MVar</a>s. While modification is done, the
--   readers use the old value. When the modification is done, the old
--   (unmodified) value is replaced with the new one. For this to work, the
--   writers have to block each other which is done with the second
--   <a>MVar</a>. This process is encapsulated in <a>modifyXMVar</a> and
--   <a>modifyXMVar_</a>.
--   
--   <i>Note</i>: This may increase the memory usage since there may be two
--   value present at a time. This is intended to be used with (big) data
--   structures where small changes are made.
module Control.Concurrent.XMVar

-- | An <a>MVar</a> variation that only blocks for modification. It
--   consists of two <a>MVar</a>s. One for the value which can always be
--   read and the second one to block writers so that modifications are
--   done sequentially.
data XMVar a

-- | Create a new <a>XMVar</a> with the supplied value.
newXMVar :: a -> IO (XMVar a)

-- | Read the value.
readXMVar :: XMVar a -> IO a

-- | Modify the content.
modifyXMVar :: XMVar a -> (a -> IO (a, b)) -> IO b

-- | Like <a>modifyXMVar</a> but without a return value.
modifyXMVar_ :: XMVar a -> (a -> IO a) -> IO ()

-- | Locks for writes and reads the value. Readers do not block each other.
--   <a>modifyXMVar</a> encapsulates <a>takeXMVarWrite</a> and
--   <a>putXMVarWrite</a> and also handles exceptions.
takeXMVarWrite :: XMVar a -> IO a

-- | Replaces the value (since it was locked for potential writers) and
--   unlocks writers.
putXMVarWrite :: XMVar a -> a -> IO ()

-- | Locks for both reads and writes (<a>MVar</a> behaviour). This may be
--   useful to save space because the old <tt>a</tt> does not have to be
--   kept in memory for read access. Note that references to the old
--   <tt>a</tt> might still lead to memory leaks/issues.
takeXMVarLock :: XMVar a -> IO a

-- | Replaces the value (since it was locked for potential writers) and
--   unlocks writers.
putXMVarLock :: XMVar a -> a -> IO ()


-- | The interpreter to evaluate <a>Command</a>s.
module Hunt.Interpreter

-- | Initialize the Hunt environment with default values.
initHunt :: DocTable dt => IO (HuntEnv dt)

-- | Run the command the supplied environment/state.
runCmd :: (DocTable dt, Binary dt) => HuntEnv dt -> Command -> IO (Either CmdError CmdResult)

-- | Execute the command in the Hunt monad.
execCmd :: (Binary dt, DocTable dt) => Command -> Hunt dt CmdResult

-- | Run the Hunt monad with the supplied environment/state.
runHunt :: DocTable dt => HuntT dt m a -> HuntEnv dt -> m (Either CmdError a)

-- | The Hunt monad on <a>IO</a>.
type Hunt dt = HuntT dt IO

-- | The Hunt transformer monad. Allows a custom monad to be embedded to
--   combine with other DSLs.
newtype HuntT dt m a
HuntT :: ReaderT (HuntEnv dt) (ErrorT CmdError m) a -> HuntT dt m a
runHuntT :: HuntT dt m a -> ReaderT (HuntEnv dt) (ErrorT CmdError m) a

-- | The Hunt state and environment. Initialize with default values with
--   <a>initHunt</a>.
data HuntEnv dt
HuntEnv :: (DocTable dt => XMVar (ContextIndex dt)) -> RankConfig (DValue dt) -> ContextTypes -> [CNormalizer] -> ProcessConfig -> HuntEnv dt

-- | The context index (indexes, document table and schema). Stored in an
--   <a>XMVar</a> so that read access is always possible.
huntIndex :: HuntEnv dt -> DocTable dt => XMVar (ContextIndex dt)

-- | Ranking configuration.
huntRankingCfg :: HuntEnv dt -> RankConfig (DValue dt)

-- | Available context types.
huntTypes :: HuntEnv dt -> ContextTypes

-- | Available normalizers.
huntNormalizers :: HuntEnv dt -> [CNormalizer]

-- | Query processor configuration.
huntQueryCfg :: HuntEnv dt -> ProcessConfig

-- | Default Hunt environment type.
type DefHuntEnv = HuntEnv (Documents Document)
instance (Monad m, Functor m) => Applicative (HuntT dt m)
instance Monad m => Monad (HuntT dt m)
instance MonadIO m => MonadIO (HuntT dt m)
instance Functor m => Functor (HuntT dt m)
instance Monad m => MonadReader (HuntEnv dt) (HuntT dt m)
instance Monad m => MonadError CmdError (HuntT dt m)
instance MonadTrans (HuntT dt)
