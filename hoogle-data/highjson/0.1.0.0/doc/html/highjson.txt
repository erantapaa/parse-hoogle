-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Very fast JSON parsing
--   
@package highjson
@version 0.1.0.0

module Data.Json.Parser

-- | Parse json from a strict <a>ByteString</a>
parseJsonBs :: JsonReadable t => ByteString -> Either String t

-- | Parse json from a lazy <a>ByteString</a>
parseJsonBsl :: JsonReadable t => ByteString -> Either String t

-- | Parse json from a strict <a>Text</a>
parseJsonT :: JsonReadable t => Text -> Either String t

-- | Typeclass defining an attoparsec <a>Parser</a> how Haskell types
--   should be parsed from JSON. Use predifined instances (with
--   <a>readJson</a>) and <a>runSpec</a> (on <a>ObjSpec</a>) to define
--   instances for custom types
class JsonReadable t
readJson :: JsonReadable t => Parser t

-- | Convert an <a>ObjSpec</a> into a <a>Parser</a> provided a constructor
--   function
runSpec :: HVectElim ts x -> ObjSpec ts -> Parser x

-- | List of <a>TypedKey</a>s, should be in the same order as your
--   constructor in <a>runSpec</a> will expect them
data ObjSpec (ts :: [*])
ObjSpecNil :: ObjSpec []
(:&&:) :: !(TypedKey t) -> !(ObjSpec ts) -> ObjSpec (t : ts)

-- | Json object key to a value t
data TypedKey t

-- | Required json object key. Use <a>IsString</a> instance for automatic
--   choice
reqKey :: Typeable t => Text -> TypedKey t

-- | Optional json object key. Use <a>IsString</a> instance for automatic
--   choice
optKey :: Typeable t => Text -> TypedKey (Maybe t)

-- | Parse a json object given a value parser for each key
readObject :: (Text -> Maybe (Parser WrappedValue)) -> Parser (HashMap Text WrappedValue)

-- | A value that is <a>Typeable</a> and <a>JsonReadable</a>
data WrappedValue
WrappedValue :: !t -> WrappedValue

-- | Get a value out of the map returned by <a>readObject</a>
getValueByKey :: (Monad m, Typeable t) => Text -> HashMap Text WrappedValue -> m t

-- | Optionally get a value out of the map returned by <a>readObject</a>
getOptValueByKey :: (Monad m, Typeable t) => Text -> HashMap Text WrappedValue -> m (Maybe t)
instance [overlap ok] Typeable t => IsString (TypedKey t)
instance [overlap ok] Typeable t => IsString (TypedKey (Maybe t))
instance [overlap ok] (JsonReadable a, JsonReadable b) => JsonReadable (Either a b)
instance [overlap ok] JsonReadable t => JsonReadable (Maybe t)
instance [overlap ok] JsonReadable Text
instance [overlap ok] JsonReadable Word64
instance [overlap ok] JsonReadable Word32
instance [overlap ok] JsonReadable Word16
instance [overlap ok] JsonReadable Word8
instance [overlap ok] JsonReadable Word
instance [overlap ok] JsonReadable Int64
instance [overlap ok] JsonReadable Int32
instance [overlap ok] JsonReadable Int16
instance [overlap ok] JsonReadable Int8
instance [overlap ok] JsonReadable Int
instance [overlap ok] JsonReadable Double
instance [overlap ok] JsonReadable Scientific
instance [overlap ok] JsonReadable Bool
instance [overlap ok] JsonReadable t => JsonReadable (t, t)
instance [overlap ok] JsonReadable t => JsonReadable (Vector t)
instance [overlap ok] JsonReadable t => JsonReadable [t]
