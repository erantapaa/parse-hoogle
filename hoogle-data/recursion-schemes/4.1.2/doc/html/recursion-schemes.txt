-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generalized bananas, lenses and barbed wire
--   
@package recursion-schemes
@version 4.1.2


module Data.Functor.Foldable
newtype Fix f
Fix :: (f (Fix f)) -> Fix f
newtype Mu f
Mu :: (forall a. (f a -> a) -> a) -> Mu f
data Nu f
Nu :: (a -> f a) -> a -> Nu f
class Functor (Base t) => Foldable t where cata f = c where c = f . fmap c . project para t = p where p x = t . fmap ((,) <*> p) $ project x gpara t = gzygo embed t prepro e f = c where c = f . fmap (c . cata (embed . e)) . project gprepro k e f = extract . c where c = fmap f . k . fmap (duplicate . c . cata (embed . e)) . project
project :: Foldable t => t -> Base t t
cata :: Foldable t => (Base t a -> a) -> t -> a
para :: Foldable t => (Base t (t, a) -> a) -> t -> a
gpara :: (Foldable t, Unfoldable t, Comonad w) => (forall b. Base t (w b) -> w (Base t b)) -> (Base t (EnvT t w a) -> a) -> t -> a
prepro :: (Foldable t, Unfoldable t) => (forall b. Base t b -> Base t b) -> (Base t a -> a) -> t -> a
gprepro :: (Foldable t, Unfoldable t, Comonad w) => (forall b. Base t (w b) -> w (Base t b)) -> (forall c. Base t c -> Base t c) -> (Base t (w a) -> a) -> t -> a
gapo :: Unfoldable t => (b -> Base t b) -> (a -> Base t (Either b a)) -> a -> t

-- | A generalized catamorphism
gcata :: (Foldable t, Comonad w) => (forall b. Base t (w b) -> w (Base t b)) -> (Base t (w a) -> a) -> t -> a
zygo :: Foldable t => (Base t b -> b) -> (Base t (b, a) -> a) -> t -> a
gzygo :: (Foldable t, Comonad w) => (Base t b -> b) -> (forall c. Base t (w c) -> w (Base t c)) -> (Base t (EnvT b w a) -> a) -> t -> a

-- | Course-of-value iteration
histo :: Foldable t => (Base t (Cofree (Base t) a) -> a) -> t -> a
ghisto :: (Foldable t, Functor h) => (forall b. Base t (h b) -> h (Base t b)) -> (Base t (Cofree h a) -> a) -> t -> a
futu :: Unfoldable t => (a -> Base t (Free (Base t) a)) -> a -> t
distCata :: Functor f => f (Identity a) -> Identity (f a)
distPara :: Unfoldable t => Base t (t, a) -> (t, Base t a)
distParaT :: (Unfoldable t, Comonad w) => (forall b. Base t (w b) -> w (Base t b)) -> Base t (EnvT t w a) -> EnvT t w (Base t a)
distZygo :: Functor f => (f b -> b) -> (f (b, a) -> (b, f a))
distZygoT :: (Functor f, Comonad w) => (f b -> b) -> (forall c. f (w c) -> w (f c)) -> f (EnvT b w a) -> EnvT b w (f a)
distHisto :: Functor f => f (Cofree f a) -> Cofree f (f a)
distGHisto :: (Functor f, Functor h) => (forall b. f (h b) -> h (f b)) -> f (Cofree h a) -> Cofree h (f a)
distFutu :: Functor f => Free f (f a) -> f (Free f a)
distGFutu :: (Functor f, Functor h) => (forall b. h (f b) -> f (h b)) -> Free h (f a) -> f (Free h a)
class Functor (Base t) => Unfoldable t where ana g = a where a = embed . fmap a . g apo g = a where a = embed . (fmap (either id a)) . g postpro e g = a where a = embed . fmap (ana (e . project) . a) . g gpostpro k e g = a . return where a = embed . fmap (ana (e . project) . a . join) . k . liftM g
embed :: Unfoldable t => Base t t -> t
ana :: Unfoldable t => (a -> Base t a) -> a -> t
apo :: (Unfoldable t, Foldable t) => (a -> Base t (Either t a)) -> a -> t
postpro :: (Unfoldable t, Foldable t) => (forall b. Base t b -> Base t b) -> (a -> Base t a) -> a -> t
gpostpro :: (Unfoldable t, Foldable t, Monad m) => (forall b. m (Base t b) -> Base t (m b)) -> (forall c. Base t c -> Base t c) -> (a -> Base t (m a)) -> a -> t

-- | A generalized anamorphism
gana :: (Unfoldable t, Monad m) => (forall b. m (Base t b) -> Base t (m b)) -> (a -> Base t (m a)) -> a -> t
distAna :: Functor f => Identity (f a) -> f (Identity a)
distApo :: Foldable t => Either t (Base t a) -> Base t (Either t a)
distGApo :: Functor f => (b -> f b) -> Either b (f a) -> f (Either b a)
hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b

-- | A generalized hylomorphism
ghylo :: (Comonad w, Functor f, Monad m) => (forall c. f (w c) -> w (f c)) -> (forall d. m (f d) -> f (m d)) -> (f (w b) -> b) -> (a -> f (m a)) -> a -> b
refix :: (Foldable s, Unfoldable t, Base s ~ Base t) => s -> t
fold :: Foldable t => (Base t a -> a) -> t -> a

-- | A generalized catamorphism
gfold :: (Foldable t, Comonad w) => (forall b. Base t (w b) -> w (Base t b)) -> (Base t (w a) -> a) -> t -> a
unfold :: Unfoldable t => (a -> Base t a) -> a -> t

-- | A generalized anamorphism
gunfold :: (Unfoldable t, Monad m) => (forall b. m (Base t b) -> Base t (m b)) -> (a -> Base t (m a)) -> a -> t
refold :: Functor f => (f b -> b) -> (a -> f a) -> a -> b

-- | A generalized hylomorphism
grefold :: (Comonad w, Functor f, Monad m) => (forall c. f (w c) -> w (f c)) -> (forall d. m (f d) -> f (m d)) -> (f (w b) -> b) -> (a -> f (m a)) -> a -> b

-- | Mendler-style iteration
mcata :: (forall y. (y -> c) -> f y -> c) -> Fix f -> c

-- | Mendler-style course-of-value iteration
mhisto :: (forall y. (y -> c) -> (y -> f y) -> f y -> c) -> Fix f -> c

-- | Elgot algebras
elgot :: Functor f => (f a -> a) -> (b -> Either a (f b)) -> b -> a

-- | Elgot coalgebras:
--   <a>http://comonad.com/reader/2008/elgot-coalgebras/</a>
coelgot :: Functor f => ((a, f b) -> b) -> (a -> f a) -> a -> b

-- | Zygohistomorphic prepromorphisms:
--   
--   A corrected and modernized version of
--   <a>http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms</a>
zygoHistoPrepro :: (Unfoldable t, Foldable t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (EnvT b (Cofree (Base t)) a) -> a) -> t -> a
instance Typeable Fix
instance Read (f (Fix f)) => Read (Fix f)
instance Show (f (Fix f)) => Show (Fix f)
instance Ord (f (Fix f)) => Ord (Fix f)
instance Eq (f (Fix f)) => Eq (Fix f)
instance (Eq a, Eq b) => Eq (Prim [a] b)
instance (Ord a, Ord b) => Ord (Prim [a] b)
instance (Show a, Show b) => Show (Prim [a] b)
instance (Read a, Read b) => Read (Prim [a] b)
instance (Functor f, Read (f (Fix f)), Read (Fix f)) => Read (Nu f)
instance (Functor f, Show (f (Fix f)), Show (Fix f)) => Show (Nu f)
instance (Functor f, Ord (f (Fix f)), Ord (Fix f)) => Ord (Nu f)
instance (Functor f, Eq (f (Fix f)), Eq (Fix f)) => Eq (Nu f)
instance Functor f => Foldable (Nu f)
instance Functor f => Unfoldable (Nu f)
instance (Functor f, Read (f (Fix f)), Read (Fix f)) => Read (Mu f)
instance (Functor f, Show (f (Fix f)), Show (Fix f)) => Show (Mu f)
instance (Functor f, Ord (f (Fix f)), Ord (Fix f)) => Ord (Mu f)
instance (Functor f, Eq (f (Fix f)), Eq (Fix f)) => Eq (Mu f)
instance Functor f => Unfoldable (Mu f)
instance Functor f => Foldable (Mu f)
instance Functor f => Unfoldable (Fix f)
instance Functor f => Foldable (Fix f)
instance Unfoldable (Either a b)
instance Foldable (Either a b)
instance Unfoldable (Maybe a)
instance Foldable (Maybe a)
instance Unfoldable [a]
instance Foldable [a]
instance Functor (Prim [a])
