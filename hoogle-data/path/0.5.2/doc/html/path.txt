-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Path
--   
@package path
@version 0.5.2


-- | Internal types and functions.
module Path.Internal

-- | Path of some base and type.
--   
--   Internally is a string. The string can be of two formats only:
--   
--   <ol>
--   <li>File format: <tt>file.txt</tt>, <tt>foo/bar.txt</tt>,
--   <tt>/foo/bar.txt</tt></li>
--   <li>Directory format: <tt>foo/</tt>, <tt>/foo/bar/</tt></li>
--   </ol>
--   
--   All directories end in a trailing separator. There are no duplicate
--   path separators <tt>//</tt>, no <tt>..</tt>, no <tt>./</tt>, no
--   <tt>~/</tt>, etc.
newtype Path b t
Path :: FilePath -> Path b t
instance Typeable Path
instance Show (Path b t)
instance Ord (Path b t)
instance Eq (Path b t)


-- | A normalizing well-typed path type.
module Path

-- | Path of some base and type.
--   
--   Internally is a string. The string can be of two formats only:
--   
--   <ol>
--   <li>File format: <tt>file.txt</tt>, <tt>foo/bar.txt</tt>,
--   <tt>/foo/bar.txt</tt></li>
--   <li>Directory format: <tt>foo/</tt>, <tt>/foo/bar/</tt></li>
--   </ol>
--   
--   All directories end in a trailing separator. There are no duplicate
--   path separators <tt>//</tt>, no <tt>..</tt>, no <tt>./</tt>, no
--   <tt>~/</tt>, etc.
data Path b t

-- | An absolute path.
data Abs

-- | A relative path; one without a root.
data Rel

-- | A file path.
data File

-- | A directory path.
data Dir

-- | Get a location for an absolute directory. Produces a normalized path
--   which always ends in a path separator.
--   
--   Throws: <a>PathParseException</a>
parseAbsDir :: MonadThrow m => FilePath -> m (Path Abs Dir)

-- | Get a location for a relative directory. Produces a normalized path
--   which always ends in a path separator.
--   
--   Throws: <a>PathParseException</a>
parseRelDir :: MonadThrow m => FilePath -> m (Path Rel Dir)

-- | Get a location for an absolute file.
--   
--   Throws: <a>PathParseException</a>
parseAbsFile :: MonadThrow m => FilePath -> m (Path Abs File)

-- | Get a location for a relative file.
--   
--   Throws: <a>PathParseException</a>
parseRelFile :: MonadThrow m => FilePath -> m (Path Rel File)

-- | Exception when parsing a location.
data PathParseException

-- | Make a 'Path Abs Dir'.
--   
--   Remember: due to the nature of absolute paths this (e.g.
--   <tt>/home/foo</tt>) may compile on your platform, but it may not
--   compile on another platform (Windows).
mkAbsDir :: FilePath -> Q Exp

-- | Make a 'Path Rel Dir'.
mkRelDir :: FilePath -> Q Exp

-- | Make a 'Path Abs File'.
--   
--   Remember: due to the nature of absolute paths this (e.g.
--   <tt>/home/foo</tt>) may compile on your platform, but it may not
--   compile on another platform (Windows).
mkAbsFile :: FilePath -> Q Exp

-- | Make a 'Path Rel File'.
mkRelFile :: FilePath -> Q Exp

-- | Append two paths.
--   
--   The following cases are valid and the equalities hold:
--   
--   <pre>
--   $(mkAbsDir x) &lt;/&gt; $(mkRelDir y) = $(mkAbsDir (x ++ "/" ++ y))
--   </pre>
--   
--   <pre>
--   $(mkAbsDir x) &lt;/&gt; $(mkRelFile y) = $(mkAbsFile (x ++ "/" ++ y))
--   </pre>
--   
--   <pre>
--   $(mkRelDir x) &lt;/&gt; $(mkRelDir y) = $(mkRelDir (x ++ "/" ++ y))
--   </pre>
--   
--   <pre>
--   $(mkRelDir x) &lt;/&gt; $(mkRelFile y) = $(mkRelFile (x ++ "/" ++ y))
--   </pre>
--   
--   The following are proven not possible to express:
--   
--   <pre>
--   $(mkAbsFile …) &lt;/&gt; x
--   </pre>
--   
--   <pre>
--   $(mkRelFile …) &lt;/&gt; x
--   </pre>
--   
--   <pre>
--   x &lt;/&gt; $(mkAbsFile …)
--   </pre>
--   
--   <pre>
--   x &lt;/&gt; $(mkAbsDir …)
--   </pre>
(</>) :: Path b Dir -> Path Rel t -> Path b t

-- | Strip directory from path, making it relative to that directory.
--   Returns <a>Nothing</a> if directory is not a parent of the path.
--   
--   The following properties hold:
--   
--   <pre>
--   stripDir parent (parent &lt;/&gt; child) = child
--   </pre>
--   
--   Cases which are proven not possible:
--   
--   <pre>
--   stripDir (a :: Path Abs …) (b :: Path Rel …)
--   </pre>
--   
--   <pre>
--   stripDir (a :: Path Rel …) (b :: Path Abs …)
--   </pre>
--   
--   In other words the bases must match.
--   
--   Throws: <a>Couldn'tStripPrefixDir</a>
stripDir :: MonadThrow m => Path b Dir -> Path b t -> m (Path Rel t)

-- | Is p a parent of the given location? Implemented in terms of
--   <a>stripDir</a>. The bases must match.
isParentOf :: Path b Dir -> Path b t -> Bool

-- | Take the absolute parent directory from the absolute path.
--   
--   The following properties hold:
--   
--   <pre>
--   parent (parent &lt;/&gt; child) == parent
--   </pre>
--   
--   On the root, getting the parent is idempotent:
--   
--   <pre>
--   parent (parent "/") = "/"
--   </pre>
parent :: Path Abs t -> Path Abs Dir

-- | Extract the file part of a path.
--   
--   The following properties hold:
--   
--   <pre>
--   filename (parent &lt;/&gt; filename a) == a
--   </pre>
filename :: Path b File -> Path Rel File

-- | Extract the last directory name of a path.
--   
--   The following properties hold:
--   
--   <pre>
--   dirname (parent &lt;/&gt; dirname a) == a
--   </pre>
dirname :: Path b Dir -> Path Rel Dir

-- | Convert to a <a>FilePath</a> type.
--   
--   All directories have a trailing slash, so if you want no trailing
--   slash, you can use <a>dropTrailingPathSeparator</a> from the filepath
--   package.
toFilePath :: Path b t -> FilePath
instance Typeable Abs
instance Typeable Rel
instance Typeable File
instance Typeable Dir
instance Typeable PathParseException
instance Show PathParseException
instance Exception PathParseException
