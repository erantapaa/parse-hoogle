-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Optional function arguments
--   
@package optional-args
@version 1.0.0


-- | Use the <a>Optional</a> type for optional function arguments. For
--   example:
--   
--   <pre>
--   import Data.Optional
--   
--   greet :: Optional String -&gt; String
--   greet (Specific name) = "Hello, " ++ name
--   greet  Default        = "Hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; greet (Specific "John")
--   "Hello, John"
--   
--   &gt;&gt;&gt; greet Default
--   "Hello"
--   </pre>
--   
--   The <a>Optional</a> type overloads as many Haskell literals as
--   possible so that you do not need to wrap values in <a>Specific</a>.
--   For example, if you enable the <tt>OverloadedStrings</tt> extension
--   you can use a naked string literal instead:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; greet "John"
--   "Hello, John"
--   </pre>
--   
--   The <a>Optional</a> type also implements <a>Num</a> and
--   <a>Fractional</a>, so you can use numeric literals in place of
--   <a>Optional</a> values:
--   
--   <pre>
--   birthday :: Optional Int -&gt; String
--   birthday (Specific age) = "You are " ++ show age ++ " years old!"
--   birthday  Default       = "You are one year older!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; birthday 20
--   "You are 20 years old!"
--   
--   &gt;&gt;&gt; birthday Default
--   "You are one year older!"
--   </pre>
--   
--   The <a>IsString</a>, <a>Num</a>, and <a>Fractional</a> instances are
--   recursive, so you can wrap your types in a more descriptive newtype
--   and derive <a>IsString</a>, <a>Num</a> or <a>Fractional</a>:
--   
--   <pre>
--   {-# LANGUAGE GeneralizedNewtypeDeriving #-}
--   
--   import Data.Optional
--   import Data.String (IsString)
--   
--   newtype Name = Name { getName :: String } deriving (IsString)
--   
--   greet :: Optional Name -&gt; String
--   greet (Specific name) = "Hello, " ++ getName name
--   greet  Default        = "Hello"
--   
--   newtype Age = Age { getAge :: Int } deriving (Num)
--   
--   birthday :: Optional Age -&gt; String
--   birthday (Specific age) = "You are " ++ show (getAge age) ++ " years old!"
--   birthday  Default       = "You are one year older!"
--   </pre>
--   
--   ... and you would still be able to provide naked numeric or string
--   literals:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; greet "John"
--   "Hello, John"
--   
--   &gt;&gt;&gt; birthday 20
--   "You are 20 years old!"
--   </pre>
--   
--   You can use <a>empty</a> as a short-hand for a <a>Default</a>
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; greet empty
--   "Hello"
--   
--   &gt;&gt;&gt; birthday empty
--   "You are one year older!"
--   </pre>
--   
--   You can also use <a>pure</a> as a short-hand for a <a>Specific</a>
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; greet (pure "John")
--   "Hello, John"
--   
--   &gt;&gt;&gt; birthday (pure 20)
--   "You are 20 years old!"
--   </pre>
module Data.Optional

-- | A function argument that has a <a>Default</a> value
data Optional a
Default :: Optional a
Specific :: a -> Optional a

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => forall a. f a

-- | Lift a value.
pure :: Applicative f => forall a. a -> f a
instance Eq a => Eq (Optional a)
instance Functor Optional
instance Foldable Optional
instance Traversable Optional
instance Show a => Show (Optional a)
instance Fractional a => Fractional (Optional a)
instance Num a => Num (Optional a)
instance IsString a => IsString (Optional a)
instance Monoid a => Monoid (Optional a)
instance MonadPlus Optional
instance Alternative Optional
instance Monad Optional
instance Applicative Optional
