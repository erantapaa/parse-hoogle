-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Synchronous communication channels
--   
@package synchronous-channels
@version 0.2


-- | This module provides synchronous channels. Unlike the channels in
--   <a>Chan</a>, which are unbounded queues on which writers never block,
--   these channels allow each writer to block until it synchronizes with
--   the particular reader that receives its message.
--   
--   We actually provide three classes of channel operations:
--   
--   <ul>
--   <li><i>Synchronous, blocking</i> These operations block until they
--   synchronize their communication with another thread.</li>
--   <li><i>Synchronous, non-blocking</i> These operations complete
--   immediately if another thread is ready to synchronize, and otherwise
--   return a failure code immediately.</li>
--   <li><i>Asynchronous</i> These operations complete immediately and
--   always succeed, though the value they send may not be received until
--   another thread tries to receive it.</li>
--   </ul>
module Control.Concurrent.Chan.Synchronous

-- | The abstract channel type for sending values of type <tt>a</tt>.
data Chan a

-- | Make a new channel.
newChan :: IO (Chan a)

-- | Is the channel currently empty? Note that the answer may become false
--   arbitrarily soon. Don't rely on this operation.
isEmptyChan :: Chan a -> IO Bool

-- | Write a value to a channel, possibly blocking until synchronizing with
--   a reader.
writeChan :: Chan a -> a -> IO ()

-- | Reads a value from a channel, potentially blocking until a writer is
--   ready to synchronize.
readChan :: Chan a -> IO a

-- | Write to the "read end" of a channel. If several writers are waiting,
--   this jumps ahead of them to the front of the line. Blocks until
--   matched up with a reader.
unGetChan :: Chan a -> a -> IO ()

-- | Reads a value from a channel, replacing it with a different value.
--   Blocks until the replacement value is read, and then returns the old
--   value.
--   
--   <i>CAUTION:</i> This operation does not guarantee that the read and
--   subsequent write are atomic. It is somewhat likely to be better in
--   that respect than <a>readChan</a> followed by <a>unGetChan</a>,
--   however.
swapChan :: Chan a -> a -> IO a

-- | Read the contents of the channel as a lazy list. While this operation
--   returns immediately, forcing evaluation of the list will block, which
--   is why this is included among the blocking operations. Writers will
--   block until each link in the list is forced as well.
--   
--   Any subsequent attempts to read from the channel will fail, unless a
--   thread is interrupted while blocking on forcing the list. Don't rely
--   on this behavior.
getChanContents :: Chan a -> IO [a]

-- | Read a given number of elements from the channel as a lazy list. Like
--   <a>getChanContents</a>, this operation returns immediately, but it
--   will block when the list is forced. (Taking the length of the list
--   should block until all the matching writes complete.)
getChanN :: Chan a -> Integer -> IO [a]

-- | Write a list to a channel, blocking until the read completes. It is
--   guaranteed that no other writes can intervene among the list elements.
--   (This cannot be implemented in terms of <a>writeChan</a>.) The list
--   may be infinite, in which case this operation never completes.
--   
--   Interrupting this operation before the list is read completely causes
--   the rest of the list not to be written. (If you want to write the
--   whole list, <a>asyncWriteList2Chan</a> may be suitable.)
writeList2Chan :: Chan a -> [a] -> IO ()

-- | The synchronous, non-blocking operations may succeed immediately, or
--   they may give up for a variety of reasons:
data TryResult a

-- | The operation succeeded.
Success :: a -> TryResult a
getSuccess :: TryResult a -> a

-- | No other thread is currently ready to synchronize for the requested
--   operation.
NotReady :: TryResult a

-- | An attempt was made to synchronize with another thread, but the other
--   thread bailed out before it could complete. Another thread may be
--   available, so it may be worth trying again immediately.
TryAgain :: TryResult a

-- | Another thread is currently operating on the channel. It may be worth
--   trying again very soon.
WouldBlock :: TryResult a

-- | Lift results of the try* operations into <a>Maybe</a>. <a>Success</a>
--   goes to <a>Just</a> and all kinds of failure go to <a>Nothing</a>.
maybeTry :: IO (TryResult a) -> IO (Maybe a)

-- | Attempts to write a value to a channel, succeeding immediately if a
--   reader is already available to synchronize. Will fail if the reader is
--   interrupted before the operation completes, if there is no reader
--   available, or if another thread is currently starting an operation on
--   the channel.
tryWriteChan :: Chan a -> a -> IO (TryResult ())

-- | Attempts to read a value from a channel, succeeding immediately if a
--   writer is already available to synchronize.
tryReadChan :: Chan a -> IO (TryResult a)

-- | Attempts to read a value from a channel, but does not allow a writer
--   to synchronize, and does not remove the observed value from the
--   channel. Fails if no writer is currently available, if the first
--   writer has bailed, or if it cannot immediately get a lock on the
--   channel.
tryPeekChan :: Chan a -> IO (TryResult a)

-- | Read the currently available elements from the channel as a lazy list.
--   The list is lazy because the number of currently available elements
--   may be infinite (see <a>writeList2Chan</a>).
tryGetChanContents :: Chan a -> IO (TryResult [a])

-- | Read up to the given number of currently available elements from the
--   channel. The list will be no longer than the given number, but if
--   there are insufficient writers available then it may be shorter. The
--   writers will block until their portions of the list's spine are
--   forced.
tryGetChanN :: Chan a -> Integer -> IO (TryResult [a])

-- | Attempt to write as much of a list as possible to a channel
--   synchronously, but without blocking; returns the unwritten remainder
--   of the list. This operation will write additional list elements so
--   long as -- there are readers ready to receive them (and so long as the
--   list doesn't run out).
tryWriteList2Chan :: Chan a -> [a] -> IO (TryResult (), [a])

-- | Write a value to a channel, returning immediately rather than waiting
--   for the reader to arrive.
asyncWriteChan :: Chan a -> a -> IO ()

-- | Write a value to the "read end" of a channel, succeeding immediately
--   rather than waiting for a reader.
asyncUnGetChan :: Chan a -> a -> IO ()

-- | If a writer is available to synchronize with, synchronizes with the
--   writer, allowing its operation to complete, writes the replacement
--   value ahead of any other writers, and then returns immediately. Unlike
--   <a>swapChan</a>, guarantees that no other write can intervene.
tryAsyncSwapChan :: Chan a -> a -> IO (TryResult a)

-- | Write a list to a channel, succeeding immediately. The list may be
--   infinite, in which case the operation still completes immediately.
--   (Actually, it may take time proportional to the number of readers that
--   are ready, so if an infinite list is written to <a>getChanContents</a>
--   on the other side, it may not actually complete.)
asyncWriteList2Chan :: Chan a -> [a] -> IO ()
instance Eq a => Eq (TryResult a)
instance Show a => Show (TryResult a)
