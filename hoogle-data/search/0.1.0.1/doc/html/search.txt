-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Infinite search in finite time with Hilbert's epsilon
--   
@package search
@version 0.1.0.1

module Data.Search.Intensional

-- | Given a test that is required to execute in finite time for _all_
--   inputs, even infinite ones, <a>Search</a> should productively yield an
--   answer.
--   
--   I currently also assume that comparison of scores can be done in
--   finite time for all scores.
--   
--   This rules out large score sets.
--   
--   <tt><a>Search</a> <a>Bool</a></tt> can be used for predicate searches.
newtype Search a b
Search :: (forall m. (Monad m, Applicative m) => (b -> m a) -> m b) -> Search a b
optimumM :: Search a b -> forall m. (Monad m, Applicative m) => (b -> m a) -> m b

-- | Find the worst-scoring result of a search with monadic effects.
pessimumM :: (Monad m, Applicative m) => Search (Down a) b -> (b -> m a) -> m b
optimum :: Search a b -> (b -> a) -> b

-- | Find the worst-scoring result of a search.
pessimum :: Search (Down a) b -> (b -> a) -> b

-- | What is the best score obtained by the search?
optimalScore :: Search a b -> (b -> a) -> a

-- | What is the worst score obtained by the search?
pessimalScore :: Search (Down a) b -> (b -> a) -> a

-- | <a>Search</a> is more powerful than <a>Cont</a>.
--   
--   This provides a canonical monad homomorphism into <a>Cont</a>.
cps :: Search a b -> Cont a b
union :: Ord a => Search a b -> Search a b -> Search a b
pair :: Ord a => b -> b -> Search a b
fromList :: Ord a => [b] -> Search a b

-- | <a>Hilbert's epsilon</a>
class Hilbert a b where epsilon = to <$> gepsilon
epsilon :: Hilbert a b => Search a b

-- | search for an optimal answer using Hilbert's epsilon
--   
--   <pre>
--   &gt;&gt;&gt; search (&gt;4) :: Int8
--   5
--   </pre>
best :: Hilbert a b => (b -> a) -> b

-- | What is the worst scoring answer by Hilbert's epsilon?
worst :: Hilbert (Down a) b => (b -> a) -> b
bestScore :: Hilbert a b => (b -> a) -> a
worstScore :: Hilbert (Down a) b => (b -> a) -> a
every :: Hilbert Bool b => (b -> Bool) -> Bool

-- | does there exist an element satisfying the predicate?
--   
--   <pre>
--   &gt;&gt;&gt; exists (&gt;(maxBound::Int8))
--   False
--   </pre>
exists :: Hilbert Bool b => (b -> Bool) -> Bool
instance Typeable Search
instance (Ord x, Ord a, Hilbert x b) => Hilbert x (Search a b)
instance (Ord x, Hilbert x a, Hilbert x b) => Hilbert x (Either a b)
instance (Ord x, Hilbert x a) => Hilbert x (Last a)
instance (Ord x, Hilbert x a) => Hilbert x (First a)
instance (Ord x, Hilbert x a) => Hilbert x (Maybe a)
instance (Ord x, Hilbert x a) => Hilbert x (ZipList a)
instance (Ord x, Hilbert x a) => Hilbert x [a]
instance Ord x => Hilbert x Word16
instance Ord x => Hilbert x Word8
instance Ord x => Hilbert x Int16
instance Ord x => Hilbert x Int8
instance Ord x => Hilbert x Char
instance Ord x => Hilbert x Ordering
instance Hilbert x a => Hilbert x (Sum a)
instance Hilbert x a => Hilbert x (Product a)
instance Ord x => Hilbert x All
instance Ord x => Hilbert x Any
instance Ord x => Hilbert x Bool
instance (Hilbert x a, Hilbert x b, Hilbert x c, Hilbert x d, Hilbert x e) => Hilbert x (a, b, c, d, e)
instance (Hilbert x a, Hilbert x b, Hilbert x c, Hilbert x d) => Hilbert x (a, b, c, d)
instance (Hilbert x a, Hilbert x b, Hilbert x c) => Hilbert x (a, b, c)
instance (Hilbert x a, Hilbert x b) => Hilbert x (a, b)
instance Hilbert x a => Hilbert x (Tagged s a)
instance Hilbert x (Proxy a)
instance Hilbert x ()
instance GHilbert a f => GHilbert a (M1 i c f)
instance Hilbert a b => GHilbert a (K1 i b)
instance (GHilbert a f, GHilbert a g, Ord a) => GHilbert a (f :+: g)
instance (GHilbert a f, GHilbert a g) => GHilbert a (f :*: g)
instance GHilbert a U1
instance Monad (Search a)
instance Bind (Search a)
instance Ord a => Alt (Search a)
instance Applicative (Search a)
instance Apply (Search a)
instance Functor (Search a)
instance Profunctor Search

module Data.Search

-- | Given a test that is required to execute in finite time for _all_
--   inputs, even infinite ones, <a>Search</a> should productively yield an
--   answer.
--   
--   I currently also assume that comparison of scores can be done in
--   finite time for all scores.
--   
--   This rules out large score sets.
--   
--   <tt><a>Search</a> <a>Bool</a></tt> can be used for predicate searches.
newtype Search a b
Search :: ((b -> a) -> b) -> Search a b
optimum :: Search a b -> (b -> a) -> b

-- | Find the worst-scoring result of a search.
pessimum :: Search (Down a) b -> (b -> a) -> b

-- | What is the best score obtained by the search?
optimalScore :: Search a b -> (b -> a) -> a

-- | What is the worst score obtained by the search?
pessimalScore :: Search (Down a) b -> (b -> a) -> a

-- | <a>Search</a> is more powerful than <a>Cont</a>.
--   
--   This provides a canonical monad homomorphism into <a>Cont</a>.
cps :: Search a b -> Cont a b
union :: Ord a => Search a b -> Search a b -> Search a b
pair :: Ord a => b -> b -> Search a b
fromList :: Ord a => [b] -> Search a b

-- | <a>Hilbert's epsilon</a>
class Hilbert a b where epsilon = to <$> gepsilon
epsilon :: Hilbert a b => Search a b

-- | search for an optimal answer using Hilbert's epsilon
--   
--   <pre>
--   &gt;&gt;&gt; search (&gt;4) :: Int8
--   5
--   </pre>
best :: Hilbert a b => (b -> a) -> b

-- | What is the worst scoring answer by Hilbert's epsilon?
worst :: Hilbert (Down a) b => (b -> a) -> b
bestScore :: Hilbert a b => (b -> a) -> a
worstScore :: Hilbert (Down a) b => (b -> a) -> a
every :: Hilbert Bool b => (b -> Bool) -> Bool

-- | does there exist an element satisfying the predicate?
--   
--   <pre>
--   &gt;&gt;&gt; exists (&gt;(maxBound::Int8))
--   False
--   </pre>
exists :: Hilbert Bool b => (b -> Bool) -> Bool
instance Typeable Search
instance (Ord x, Ord a, Hilbert x b) => Hilbert x (Search a b)
instance (Ord x, Hilbert x a, Hilbert x b) => Hilbert x (Either a b)
instance (Ord x, Hilbert x a) => Hilbert x (Last a)
instance (Ord x, Hilbert x a) => Hilbert x (First a)
instance (Ord x, Hilbert x a) => Hilbert x (Maybe a)
instance (Ord x, Hilbert x a) => Hilbert x (ZipList a)
instance (Ord x, Hilbert x a) => Hilbert x [a]
instance Ord x => Hilbert x Word16
instance Ord x => Hilbert x Word8
instance Ord x => Hilbert x Int16
instance Ord x => Hilbert x Int8
instance Ord x => Hilbert x Char
instance Ord x => Hilbert x Ordering
instance Hilbert x a => Hilbert x (Sum a)
instance Hilbert x a => Hilbert x (Product a)
instance Ord x => Hilbert x All
instance Ord x => Hilbert x Any
instance Ord x => Hilbert x Bool
instance (Hilbert x a, Hilbert x b, Hilbert x c, Hilbert x d, Hilbert x e) => Hilbert x (a, b, c, d, e)
instance (Hilbert x a, Hilbert x b, Hilbert x c, Hilbert x d) => Hilbert x (a, b, c, d)
instance (Hilbert x a, Hilbert x b, Hilbert x c) => Hilbert x (a, b, c)
instance (Hilbert x a, Hilbert x b) => Hilbert x (a, b)
instance Hilbert x a => Hilbert x (Tagged s a)
instance Hilbert x (Proxy a)
instance Hilbert x ()
instance GHilbert a f => GHilbert a (M1 i c f)
instance Hilbert a b => GHilbert a (K1 i b)
instance (GHilbert a f, GHilbert a g, Ord a) => GHilbert a (f :+: g)
instance (GHilbert a f, GHilbert a g) => GHilbert a (f :*: g)
instance GHilbert a U1
instance Monad (Search a)
instance Bind (Search a)
instance Ord a => Alt (Search a)
instance Applicative (Search a)
instance Apply (Search a)
instance Functor (Search a)
instance Profunctor Search
