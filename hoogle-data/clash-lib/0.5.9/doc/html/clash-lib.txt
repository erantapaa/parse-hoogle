-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | CAES Language for Synchronous Hardware - As a Library
--   
--   CλaSH (pronounced ‘clash’) is a functional hardware description
--   language that borrows both its syntax and semantics from the
--   functional programming language Haskell. The merits of using a
--   functional language to describe hardware comes from the fact that
--   combinational circuits can be directly modelled as mathematical
--   functions and that functional languages lend themselves very well at
--   describing and (de-)composing mathematical functions.
--   
--   This package provides:
--   
--   <ul>
--   <li>The CoreHW internal language: SystemF + Letrec +
--   Case-decomposition</li>
--   <li>The normalisation process that brings CoreHW in a normal form that
--   can be converted to a netlist</li>
--   <li>Blackbox/Primitive Handling</li>
--   </ul>
--   
--   Front-ends (for: parsing, typecheck, etc.) are provided by separate
--   packages:
--   
--   <ul>
--   <li><a>Idris Frontend</a></li>
--   <li><a>GHC/Haskell Frontend</a></li>
--   </ul>
--   
--   Prelude library:
--   <a>http://hackage.haskell.org/package/clash-prelude</a>
@package clash-lib
@version 0.5.9


-- | Transform/format a Netlist Identifier so that it is acceptable as a
--   HDL identifier
module CLaSH.Netlist.Id

-- | Transform/format a text so that it is acceptable as a HDL identifier
mkBasicId :: Text -> Text
mkBasicId' :: Bool -> Text -> Text
stripDollarPrefixes :: Text -> Text


-- | Types used in BlackBox modules
module CLaSH.Netlist.BlackBox.Types

-- | A BlackBox Template is a List of Elements
type BlackBoxTemplate = [Element]

-- | Elements of a blackbox context
data Element

-- | Constant
[C] :: Text -> Element

-- | Component instantiation hole
[D] :: Decl -> Element

-- | Output hole
[O] :: Element

-- | Input hole
[I] :: Int -> Element

-- | Literal hole
[L] :: Int -> Element

-- | Symbol hole
[Sym] :: Int -> Element

-- | Clock hole (Maybe clk corresponding to input, clk corresponding to
--   output if Nothing)
[Clk] :: (Maybe Int) -> Element

-- | Reset hole
[Rst] :: (Maybe Int) -> Element

-- | Type declaration hole
[Typ] :: (Maybe Int) -> Element

-- | Type root hole
[TypM] :: (Maybe Int) -> Element

-- | Error value hole
[Err] :: (Maybe Int) -> Element

-- | Select element type from a vector type
[TypElem] :: Element -> Element

-- | Hole for the name of the component in which the blackbox is
--   instantiated
[CompName] :: Element

-- | Size of a type hole
[Size] :: Element -> Element

-- | Length of a vector hole
[Length] :: Element -> Element

-- | Hole containing a filepath for a data file
[FilePath] :: Element -> Element

-- | Hole marking beginning (True) or end (False) of a generative construct
[Gen] :: Bool -> Element
[SigD] :: [Element] -> (Maybe Int) -> Element

-- | Component instantiation hole. First argument indicates which function
--   argument to instantiate. Second argument corresponds to output and
--   input assignments, where the first element is the output assignment,
--   and the subsequent elements are the consecutive input assignments.
--   
--   The LHS of the tuple is the name of the signal, while the RHS of the
--   tuple is the type of the signal
data Decl
[Decl] :: Int -> [(BlackBoxTemplate, BlackBoxTemplate)] -> Decl
instance Show Element
instance Show Decl


-- | Parser definitions for BlackBox templates
module CLaSH.Netlist.BlackBox.Parser

-- | Parse a text as a BlackBoxTemplate, returns a list of errors in case
--   parsing fails
runParse :: Text -> (BlackBoxTemplate, [Error LineColPos])


-- | Type and instance definitions for Primitive
module CLaSH.Primitives.Types

-- | Primitive Definitions
type PrimMap = HashMap Text Primitive

-- | Externally defined primitive
data Primitive

-- | A primitive that has a template that can be filled out by the backend
--   render
[BlackBox] :: Text -> Either Text Text -> Primitive

-- | Name of the primitive
[name] :: Primitive -> Text

-- | Either a <i>declaration</i> or an <i>expression</i> template.
[template] :: Primitive -> Either Text Text

-- | A primitive that carries additional information
[Primitive] :: Text -> Text -> Primitive

-- | Name of the primitive
[name] :: Primitive -> Text

-- | Additional information
[primType] :: Primitive -> Text
instance Show Primitive
instance FromJSON Primitive


-- | Assortment of utility function used in the CLaSH library
module CLaSH.Util

-- | A class that can generate unique numbers
class MonadUnique m
getUniqueM :: MonadUnique m => m Int

-- | Create a TH expression that returns the a formatted string containing
--   the name of the module <a>curLoc</a> is spliced into, and the line
--   where it was spliced.
curLoc :: Q Exp

-- | Cache the result of a monadic action
makeCached :: (MonadState s m, Hashable k, Eq k) => k -> Lens' s (HashMap k v) -> m v -> m v

-- | Cache the result of a monadic action in a State 3 transformer layers
--   down
makeCachedT3 :: (MonadTrans t2, MonadTrans t1, MonadTrans t, Eq k, Hashable k, MonadState s m, Monad (t2 m), Monad (t1 (t2 m)), Monad (t (t1 (t2 m)))) => k -> Lens' s (HashMap k v) -> (t (t1 (t2 m))) v -> (t (t1 (t2 m))) v

-- | Spine-strict cache variant of <tt>mkCachedT3</tt>
makeCachedT3S :: (MonadTrans t2, MonadTrans t1, MonadTrans t, Eq k, Hashable k, MonadState s m, Monad (t2 m), Monad (t1 (t2 m)), Monad (t (t1 (t2 m))), NFData v) => k -> Lens' s (HashMap k v) -> (t (t1 (t2 m))) v -> (t (t1 (t2 m))) v

-- | Run a State-action using the State that is stored in a higher-layer
--   Monad
liftState :: (MonadState s m) => Lens' s s' -> State s' a -> m a

-- | Functorial version of <a>first</a>
firstM :: Functor f => (a -> f c) -> (a, b) -> f (c, b)

-- | Functorial version of <a>second</a>
secondM :: Functor f => (b -> f c) -> (a, b) -> f (a, c)
combineM :: (Applicative f) => (a -> f b) -> (c -> f d) -> (a, c) -> f (b, d)

-- | Performs trace when first argument evaluates to <a>True</a>
traceIf :: Bool -> String -> a -> a

-- | Monadic version of <a>partition</a>
partitionM :: Monad m => (a -> m Bool) -> [a] -> m ([a], [a])

-- | Monadic version of <a>mapAccumL</a>
mapAccumLM :: (Monad m) => (acc -> x -> m (acc, y)) -> acc -> [x] -> m (acc, [y])

-- | Composition of a unary function with a binary function
dot :: (c -> d) -> (a -> b -> c) -> a -> b -> d

-- | if-then-else as a function on an argument
ifThenElse :: (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b

-- | Applicative version of 'GHC.Types.(:)'
(<:>) :: Applicative f => f a -> f [a] -> f [a]

-- | Safe indexing, returns a <a>Nothing</a> if the index does not exist
indexMaybe :: [a] -> Int -> Maybe a

-- | Unsafe indexing, return a custom error message when indexing fails
indexNote :: String -> [a] -> Int -> a

-- | Split the second list at the length of the first list
splitAtList :: [b] -> [a] -> ([a], [a])
clashLibVersion :: Version

-- | ceiling (log_2(c))
clog2 :: (Integral a, Integral c) => a -> c

-- | Build lenses (and traversals) with a sensible default configuration.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBar
--     = Foo { _x, _y :: <a>Int</a> }
--     | Bar { _x :: <a>Int</a> }
--   <a>makeLenses</a> ''FooBar
--   </pre>
--   
--   will create
--   
--   <pre>
--   x :: <a>Lens'</a> FooBar <a>Int</a>
--   x f (Foo a b) = (\a' -&gt; Foo a' b) &lt;$&gt; f a
--   x f (Bar a)   = Bar &lt;$&gt; f a
--   y :: <a>Traversal'</a> FooBar <a>Int</a>
--   y f (Foo a b) = (\b' -&gt; Foo a  b') &lt;$&gt; f b
--   y _ c@(Bar _) = pure c
--   </pre>
--   
--   <pre>
--   <a>makeLenses</a> = <a>makeLensesWith</a> <a>lensRules</a>
--   </pre>
makeLenses :: Name -> DecsQ
instance Monad m => MonadUnique (StateT Int m)


-- | Utility functions to generate Primitives
module CLaSH.Primitives.Util

-- | Generate a set of primitives that are found in the primitive
--   definition files in the given directories.
generatePrimMap :: [FilePath] -> IO PrimMap


-- | Variables in CoreHW
module CLaSH.Core.Var

-- | Variables in CoreHW
data Var a

-- | Constructor for type variables
[TyVar] :: Name a -> Embed Kind -> Var a
[varName] :: Var a -> Name a
[varKind] :: Var a -> Embed Kind

-- | Constructor for term variables
[Id] :: Name a -> Embed Type -> Var a
[varName] :: Var a -> Name a
[varType] :: Var a -> Embed Type

-- | Term variable
type Id = Var Term

-- | Type variable
type TyVar = Var Type

-- | Change the name of a variable
modifyVarName :: (Name a -> Name a) -> Var a -> Var a
instance Selector S1_1_1Var
instance Selector S1_1_0Var
instance Selector S1_0_1Var
instance Selector S1_0_0Var
instance Constructor C1_1Var
instance Constructor C1_0Var
instance Datatype D1Var
instance NFData (Var a)
instance Generic (Var a)
instance Show (Var a)
instance Eq (Var a)
instance (Typeable a, Alpha a) => Alpha (Var a)
instance Generic b => Subst Term (Var b)
instance Generic b => Subst Type (Var b)


-- | Data Constructors in CoreHW
module CLaSH.Core.DataCon

-- | Data Constructor
data DataCon
[MkData] :: DcName -> ConTag -> Type -> [TyName] -> [TyName] -> [Type] -> DataCon

-- | Name of the DataCon
[dcName] :: DataCon -> DcName

-- | Syntactical position in the type definition
[dcTag] :: DataCon -> ConTag

-- | Type of the 'DataCon
[dcType] :: DataCon -> Type

-- | Universally quantified type-variables, these type variables are also
--   part of the result type of the DataCon
[dcUnivTyVars] :: DataCon -> [TyName]

-- | Existentially quantified type-variables, these type variables are not
--   part of the result of the DataCon, but only of the arguments.
[dcExtTyVars] :: DataCon -> [TyName]

-- | Argument types
[dcArgTys] :: DataCon -> [Type]

-- | DataCon reference
type DcName = Name DataCon

-- | Syntactical position of the DataCon in the type definition
type ConTag = Int

-- | Given a DataCon and a list of types, the type variables of the DataCon
--   type are substituted for the list of types. The argument types are
--   returned.
--   
--   The list of types should be equal to the number of type variables,
--   otherwise an error is reported.
dataConInstArgTys :: DataCon -> [Type] -> [Type]
instance Selector S1_0_5DataCon
instance Selector S1_0_4DataCon
instance Selector S1_0_3DataCon
instance Selector S1_0_2DataCon
instance Selector S1_0_1DataCon
instance Selector S1_0_0DataCon
instance Constructor C1_0DataCon
instance Datatype D1DataCon
instance NFData DataCon
instance Generic DataCon
instance Show DataCon
instance Eq DataCon
instance Ord DataCon
instance Alpha DataCon
instance Subst a DataCon


-- | Type Constructors in CoreHW
module CLaSH.Core.TyCon

-- | Type Constructor
data TyCon

-- | Algorithmic DataCons
[AlgTyCon] :: TyConName -> Kind -> Int -> AlgTyConRhs -> TyCon

-- | Name of the TyCon
[tyConName] :: TyCon -> TyConName

-- | Kind of the TyCon
[tyConKind] :: TyCon -> Kind

-- | Number of type arguments
[tyConArity] :: TyCon -> Int

-- | DataCon definitions
[algTcRhs] :: TyCon -> AlgTyConRhs

-- | Function TyCons (e.g. type families)
[FunTyCon] :: TyConName -> Kind -> Int -> [([Type], Type)] -> TyCon

-- | Name of the TyCon
[tyConName] :: TyCon -> TyConName

-- | Kind of the TyCon
[tyConKind] :: TyCon -> Kind

-- | Number of type arguments
[tyConArity] :: TyCon -> Int

-- | List of: ([LHS match types], RHS type)
[tyConSubst] :: TyCon -> [([Type], Type)]

-- | Primitive TyCons
[PrimTyCon] :: TyConName -> Kind -> Int -> TyCon

-- | Name of the TyCon
[tyConName] :: TyCon -> TyConName

-- | Kind of the TyCon
[tyConKind] :: TyCon -> Kind

-- | Number of type arguments
[tyConArity] :: TyCon -> Int

-- | To close the loop on the type hierarchy
[SuperKindTyCon] :: TyConName -> TyCon

-- | Name of the TyCon
[tyConName] :: TyCon -> TyConName

-- | TyCon reference
type TyConName = Name TyCon

-- | The RHS of an Algebraic Datatype
data AlgTyConRhs
[DataTyCon] :: [DataCon] -> AlgTyConRhs

-- | The DataCons of a TyCon
[dataCons] :: AlgTyConRhs -> [DataCon]
[NewTyCon] :: DataCon -> ([TyName], Type) -> AlgTyConRhs

-- | The newtype DataCon
[dataCon] :: AlgTyConRhs -> DataCon

-- | The argument type of the newtype DataCon in eta-reduced form, which is
--   just the representation of the TyCon. The TyName's are the
--   type-variables from the corresponding TyCon.
[ntEtadRhs] :: AlgTyConRhs -> ([TyName], Type)

-- | Create a Kind out of a TyConName
mkKindTyCon :: TyConName -> Kind -> TyCon

-- | Does the TyCon look like a tuple TyCon
isTupleTyConLike :: TyConName -> Bool

-- | Get the DataCons belonging to a TyCon
tyConDataCons :: TyCon -> [DataCon]
instance Selector S1_1_1AlgTyConRhs
instance Selector S1_1_0AlgTyConRhs
instance Selector S1_0_0AlgTyConRhs
instance Constructor C1_1AlgTyConRhs
instance Constructor C1_0AlgTyConRhs
instance Datatype D1AlgTyConRhs
instance Selector S1_3_0TyCon
instance Selector S1_2_2TyCon
instance Selector S1_2_1TyCon
instance Selector S1_2_0TyCon
instance Selector S1_1_3TyCon
instance Selector S1_1_2TyCon
instance Selector S1_1_1TyCon
instance Selector S1_1_0TyCon
instance Selector S1_0_3TyCon
instance Selector S1_0_2TyCon
instance Selector S1_0_1TyCon
instance Selector S1_0_0TyCon
instance Constructor C1_3TyCon
instance Constructor C1_2TyCon
instance Constructor C1_1TyCon
instance Constructor C1_0TyCon
instance Datatype D1TyCon
instance Alpha AlgTyConRhs
instance NFData AlgTyConRhs
instance Generic AlgTyConRhs
instance Show AlgTyConRhs
instance NFData TyCon
instance Generic TyCon
instance Show TyCon
instance Eq TyCon
instance Ord TyCon
instance Alpha TyCon


-- | Builtin Type and Kind definitions
module CLaSH.Core.TysPrim
liftedTypeKind :: Type
typeNatKind :: Type
typeSymbolKind :: Type
intPrimTy :: Type
stringPrimTy :: Type
voidPrimTy :: Type
tysPrimMap :: HashMap TyConName TyCon


-- | Term Literal
module CLaSH.Core.Literal

-- | Term Literal
data Literal
[IntegerLiteral] :: Integer -> Literal
[StringLiteral] :: String -> Literal
[RationalLiteral] :: Rational -> Literal

-- | Determines the Type of a Literal
literalType :: Literal -> Type
instance Constructor C1_2Literal
instance Constructor C1_1Literal
instance Constructor C1_0Literal
instance Datatype D1Literal
instance NFData Literal
instance Generic Literal
instance Show Literal
instance Ord Literal
instance Eq Literal
instance Alpha Literal
instance Subst a Literal


-- | Term representation in the CoreHW language: System F + LetRec + Case
module CLaSH.Core.Term

-- | Term representation in the CoreHW language: System F + LetRec + Case
data Term

-- | Variable reference
[Var] :: Type -> TmName -> Term

-- | Datatype constructor
[Data] :: DataCon -> Term

-- | Literal
[Literal] :: Literal -> Term

-- | Primitive
[Prim] :: Text -> Type -> Term

-- | Term-abstraction
[Lam] :: (Bind Id Term) -> Term

-- | Type-abstraction
[TyLam] :: (Bind TyVar Term) -> Term

-- | Application
[App] :: Term -> Term -> Term

-- | Type-application
[TyApp] :: Term -> Type -> Term

-- | Recursive let-binding
[Letrec] :: (Bind (Rec [LetBinding]) Term) -> Term

-- | Case-expression: subject, type of alternatives, list of alternatives
[Case] :: Term -> Type -> [Bind Pat Term] -> Term

-- | Term reference
type TmName = Name Term

-- | Binding in a LetRec construct
type LetBinding = (Id, Embed Term)

-- | Patterns in the LHS of a case-decomposition
data Pat

-- | Datatype pattern, '[TyVar]' bind existentially-quantified
--   type-variables of a DataCon
[DataPat] :: (Embed DataCon) -> (Rebind [TyVar] [Id]) -> Pat

-- | Literal pattern
[LitPat] :: (Embed Literal) -> Pat

-- | Default pattern
[DefaultPat] :: Pat
instance Constructor C1_2Pat
instance Constructor C1_1Pat
instance Constructor C1_0Pat
instance Datatype D1Pat
instance Constructor C1_9Term
instance Constructor C1_8Term
instance Constructor C1_7Term
instance Constructor C1_6Term
instance Constructor C1_5Term
instance Constructor C1_4Term
instance Constructor C1_3Term
instance Constructor C1_2Term
instance Constructor C1_1Term
instance Constructor C1_0Term
instance Datatype D1Term
instance Alpha Pat
instance NFData Pat
instance Generic Pat
instance Show Pat
instance NFData Term
instance Generic Term
instance Show Term
instance Eq Term
instance Ord Term
instance Alpha Term
instance Subst Type Pat
instance Subst Term Pat
instance Subst Term Term
instance Subst Type Term


-- | Capture-free substitution function for CoreHW
module CLaSH.Core.Subst

-- | Substitutes types in a type
substTys :: [(TyName, Type)] -> Type -> Type

-- | Substitutes a type in a type
substTy :: TyName -> Type -> Type -> Type

-- | Substitutes kinds in a kind
substKindWith :: [(KiName, Kind)] -> Kind -> Kind

-- | Substitutes a type in a term
substTyInTm :: TyName -> Type -> Term -> Term

-- | Substitutes types in a term
substTysinTm :: [(TyName, Type)] -> Term -> Term

-- | Substitutes a term in a term
substTm :: TmName -> Term -> Term -> Term

-- | Substitutes terms in a term
substTms :: [(TmName, Term)] -> Term -> Term


-- | Types in CoreHW
module CLaSH.Core.Type

-- | Types in CoreHW: function and polymorphic types
data Type

-- | Type variable
[VarTy] :: Kind -> TyName -> Type

-- | Type constant
[ConstTy] :: ConstTy -> Type

-- | Polymorphic Type
[ForAllTy] :: (Bind TyVar Type) -> Type

-- | Type Application
[AppTy] :: Type -> Type -> Type

-- | Type literal
[LitTy] :: LitTy -> Type

-- | An easier view on types
data TypeView

-- | Function type
[FunTy] :: Type -> Type -> TypeView

-- | Applied TyCon
[TyConApp] :: TyConName -> [Type] -> TypeView

-- | Neither of the above
[OtherType] :: Type -> TypeView

-- | Type Constants
data ConstTy

-- | TyCon type
[TyCon] :: TyConName -> ConstTy

-- | Function type
[Arrow] :: ConstTy

-- | Literal Types
data LitTy
[NumTy] :: Int -> LitTy
[SymTy] :: String -> LitTy

-- | The level above types
type Kind = Type

-- | Either a Kind or a Type
type KindOrType = Type

-- | Reference to a Kind
type KiName = Name Kind

-- | Reference to a Type
type TyName = Name Type

-- | Type variable
type TyVar = Var Type

-- | An easier view on types
tyView :: Type -> TypeView

-- | A view on types in which <tt>Signal</tt> types and newtypes are
--   transparent, and type functions are evaluated when possible.
coreView :: HashMap TyConName TyCon -> Type -> TypeView

-- | A transformation that renders <tt>Signal</tt> types transparent
transparentTy :: Type -> Type

-- | Determine the kind of a type
typeKind :: HashMap TyConName TyCon -> Type -> Kind

-- | Make a Type out of a TyCon
mkTyConTy :: TyConName -> Type

-- | Make a function type of an argument and result type
mkFunTy :: Type -> Type -> Type

-- | Make a TyCon Application out of a TyCon and a list of argument types
mkTyConApp :: TyConName -> [Type] -> Type

-- | Split a function type in an argument and result type
splitFunTy :: HashMap TyConName TyCon -> Type -> Maybe (Type, Type)
splitFunTys :: HashMap TyConName TyCon -> Type -> ([Type], Type)

-- | Split a poly-function type in a: list of type-binders and argument
--   types, and the result type
splitFunForallTy :: Type -> ([Either TyVar Type], Type)

-- | Split a TyCon Application in a TyCon and its arguments
splitTyConAppM :: Type -> Maybe (TyConName, [Type])

-- | Is a type a polymorphic or function type?
isPolyFunTy :: Type -> Bool

-- | Is a type a polymorphic or function type under <a>coreView</a>?
isPolyFunCoreTy :: HashMap TyConName TyCon -> Type -> Bool

-- | Is a type polymorphic?
isPolyTy :: Type -> Bool

-- | Is a type a function type?
isFunTy :: HashMap TyConName TyCon -> Type -> Bool

-- | Apply a function type to an argument type and get the result type
applyFunTy :: HashMap TyConName TyCon -> Type -> Type -> Type

-- | Substitute the type variable of a type (<a>ForAllTy</a>) with another
--   type
applyTy :: Fresh m => HashMap TyConName TyCon -> Type -> KindOrType -> m Type
findFunSubst :: [([Type], Type)] -> [Type] -> Maybe Type
instance Constructor C1_1ConstTy
instance Constructor C1_0ConstTy
instance Datatype D1ConstTy
instance Constructor C1_4Type
instance Constructor C1_3Type
instance Constructor C1_2Type
instance Constructor C1_1Type
instance Constructor C1_0Type
instance Datatype D1Type
instance Constructor C1_1LitTy
instance Constructor C1_0LitTy
instance Datatype D1LitTy
instance Show TypeView
instance Alpha ConstTy
instance NFData ConstTy
instance Generic ConstTy
instance Show ConstTy
instance NFData Type
instance Generic Type
instance Show Type
instance Alpha LitTy
instance NFData LitTy
instance Generic LitTy
instance Show LitTy
instance Alpha Type
instance Subst a LitTy
instance Subst a ConstTy
instance Subst Term Type
instance Subst Type Type
instance Eq Type
instance Ord Type


-- | Free variable calculations
module CLaSH.Core.FreeVars

-- | Gives the free type-variables in a Type
typeFreeVars :: Fold Type TyName

-- | Gives the free term-variables of a Term
termFreeIds :: Fold Term TmName

-- | Gives the free type-variables of a Term
termFreeTyVars :: Fold Term TyName


-- | Pretty printing class and instances for CoreHW
module CLaSH.Core.Pretty

-- | Pretty printing Show-like typeclass
class Pretty p where ppr = pprPrec 0
ppr :: (Pretty p, Applicative m, LFresh m) => p -> m Doc
pprPrec :: (Pretty p, Applicative m, LFresh m) => Rational -> p -> m Doc

-- | Print a Pretty thing to a String
showDoc :: Pretty p => p -> String
instance Ord TypePrec
instance Eq TypePrec
instance Pretty (Name a)
instance Pretty a => Pretty [a]
instance Pretty (Id, Term)
instance Pretty Type
instance Pretty (Var Type)
instance Pretty TyCon
instance Pretty LitTy
instance Pretty Term
instance Pretty (Var Term)
instance Pretty DataCon
instance Pretty Literal
instance Pretty Pat


-- | Smart constructor and destructor functions for CoreHW
module CLaSH.Core.Util

-- | Type environment/context
type Gamma = HashMap TmName Type

-- | Kind environment/context
type Delta = HashMap TyName Kind

-- | Determine the type of a term
termType :: (Functor m, Fresh m) => HashMap TyConName TyCon -> Term -> m Type

-- | Split a (Type)Application in the applied term and it arguments
collectArgs :: Term -> (Term, [Either Term Type])

-- | Split a (Type)Abstraction in the bound variables and the abstracted
--   term
collectBndrs :: Fresh m => Term -> m ([Either Id TyVar], Term)

-- | Get the result type of a polymorphic function given a list of
--   arguments
applyTypeToArgs :: Fresh m => HashMap TyConName TyCon -> Type -> [Either Term Type] -> m Type

-- | Get the list of term-binders out of a DataType pattern
patIds :: Pat -> [Id]

-- | Make a type variable
mkTyVar :: Kind -> TyName -> TyVar

-- | Make a term variable
mkId :: Type -> TmName -> Id

-- | Abstract a term over a list of term and type variables
mkAbstraction :: Term -> [Either Id TyVar] -> Term

-- | Abstract a term over a list of term variables
mkTyLams :: Term -> [TyVar] -> Term

-- | Abstract a term over a list of type variables
mkLams :: Term -> [Id] -> Term

-- | Apply a list of types and terms to a term
mkApps :: Term -> [Either Term Type] -> Term

-- | Apply a list of terms to a term
mkTmApps :: Term -> [Term] -> Term

-- | Apply a list of types to a term
mkTyApps :: Term -> [Type] -> Term

-- | Does a term have a function type?
isFun :: (Functor m, Fresh m) => HashMap TyConName TyCon -> Term -> m Bool

-- | Does a term have a function or polymorphic type?
isPolyFun :: (Functor m, Fresh m) => HashMap TyConName TyCon -> Term -> m Bool

-- | Is a term a term-abstraction?
isLam :: Term -> Bool

-- | Is a term a recursive let-binding?
isLet :: Term -> Bool

-- | Is a term a variable reference?
isVar :: Term -> Bool

-- | Is a term a datatype constructor?
isCon :: Term -> Bool

-- | Is a term a primitive?
isPrim :: Term -> Bool

-- | Make variable reference out of term variable
idToVar :: Id -> Term

-- | Make a term variable out of a variable reference
varToId :: Term -> Id
termSize :: Term -> Int


-- | Type and instance definitions for Netlist modules
module CLaSH.Netlist.Types

-- | Monad that caches generated components (StateT) and remembers hidden
--   inputs of components that are being generated (WriterT)
newtype NetlistMonad a
[NetlistMonad] :: WriterT (Set (Identifier, HWType)) (StateT NetlistState (FreshMT IO)) a -> NetlistMonad a
[runNetlist] :: NetlistMonad a -> WriterT (Set (Identifier, HWType)) (StateT NetlistState (FreshMT IO)) a

-- | State of the NetlistMonad
data NetlistState
[NetlistState] :: HashMap TmName (Type, Term) -> Gamma -> Int -> Int -> HashMap TmName Component -> PrimMap -> (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> HashMap TyConName TyCon -> String -> Identifier -> [(String, FilePath)] -> NetlistState

-- | Global binders
[_bindings] :: NetlistState -> HashMap TmName (Type, Term)

-- | Type environment/context
[_varEnv] :: NetlistState -> Gamma

-- | Number of signal declarations
[_varCount] :: NetlistState -> Int

-- | Number of create components
[_cmpCount] :: NetlistState -> Int

-- | Cached components
[_components] :: NetlistState -> HashMap TmName Component

-- | Primitive Definitions
[_primitives] :: NetlistState -> PrimMap

-- | Hardcoded Type -&gt; HWType translator
[_typeTranslator] :: NetlistState -> HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)

-- | TyCon cache
[_tcCache] :: NetlistState -> HashMap TyConName TyCon

-- | Name of the module containing the <tt>topEntity</tt>
[_modNm] :: NetlistState -> String
[_curCompNm] :: NetlistState -> Identifier
[_dataFiles] :: NetlistState -> [(String, FilePath)]

-- | Signal reference
type Identifier = Text

-- | Component: base unit of a Netlist
data Component
[Component] :: Identifier -> [(Identifier, HWType)] -> [(Identifier, HWType)] -> [(Identifier, HWType)] -> [Declaration] -> Component

-- | Name of the component
[componentName] :: Component -> Identifier

-- | Ports that have no correspondence the original function definition
[hiddenPorts] :: Component -> [(Identifier, HWType)]

-- | Input ports
[inputs] :: Component -> [(Identifier, HWType)]

-- | Output ports
[outputs] :: Component -> [(Identifier, HWType)]

-- | Internal declarations
[declarations] :: Component -> [Declaration]

-- | Size indication of a type (e.g. bit-size or number of elements)
type Size = Int

-- | Representable hardware types
data HWType

-- | Empty type
[Void] :: HWType

-- | Boolean type
[Bool] :: HWType

-- | Integer type
[Integer] :: HWType

-- | BitVector of a specified size
[BitVector] :: Size -> HWType

-- | Unsigned integer with specified (exclusive) upper bounder
[Index] :: Size -> HWType

-- | Signed integer of a specified size
[Signed] :: Size -> HWType

-- | Unsigned integer of a specified size
[Unsigned] :: Size -> HWType

-- | Vector type
[Vector] :: Size -> HWType -> HWType

-- | Sum type: Name and Constructor names
[Sum] :: Identifier -> [Identifier] -> HWType

-- | Product type: Name and field types
[Product] :: Identifier -> [HWType] -> HWType

-- | Sum-of-Product type: Name and Constructor names + field types
[SP] :: Identifier -> [(Identifier, [HWType])] -> HWType

-- | Clock type with specified name and period
[Clock] :: Identifier -> Int -> HWType

-- | Reset type corresponding to clock with a specified name and period
[Reset] :: Identifier -> Int -> HWType

-- | Internals of a Component
data Declaration

-- | Signal assignment:
--   
--   <ul>
--   <li>Signal to assign</li>
--   <li>Assigned expression</li>
--   </ul>
[Assignment] :: Identifier -> Expr -> Declaration

-- | Conditional signal assignment:
--   
--   <ul>
--   <li>Signal to assign</li>
--   <li>Type of the result/alternatives</li>
--   <li>Scrutinized expression</li>
--   <li>List of: (Maybe expression scrutinized expression is compared
--   with,RHS of alternative)</li>
--   </ul>
[CondAssignment] :: Identifier -> HWType -> Expr -> [(Maybe Expr, Expr)] -> Declaration

-- | Instantiation of another component
[InstDecl] :: Identifier -> Identifier -> [(Identifier, Expr)] -> Declaration

-- | Instantiation of blackbox declaration
[BlackBoxD] :: Text -> BlackBoxTemplate -> BlackBoxContext -> Declaration

-- | Signal declaration
[NetDecl] :: Identifier -> HWType -> Declaration

-- | Expression Modifier
data Modifier

-- | Index the expression: (Type of expression,DataCon tag,Field Tag)
[Indexed] :: (HWType, Int, Int) -> Modifier

-- | See expression in a DataCon context: (Type of the expression, DataCon
--   tag)
[DC] :: (HWType, Int) -> Modifier

-- | See the expression in the context of a Vector append operation
[VecAppend] :: Modifier

-- | Expression used in RHS of a declaration
data Expr

-- | Literal expression
[Literal] :: (Maybe (HWType, Size)) -> Literal -> Expr

-- | DataCon application
[DataCon] :: HWType -> Modifier -> [Expr] -> Expr

-- | Signal reference
[Identifier] :: Identifier -> (Maybe Modifier) -> Expr

-- | <tt>Left e</tt>: tagToEnum
[DataTag] :: HWType -> (Either Identifier Identifier) -> Expr

-- | Instantiation of a BlackBox expression
[BlackBoxE] :: Text -> BlackBoxTemplate -> BlackBoxContext -> Bool -> Expr

-- | Literals used in an expression
data Literal

-- | Number literal
[NumLit] :: Integer -> Literal

-- | Bit literal
[BitLit] :: Bit -> Literal

-- | Boolean literal
[BoolLit] :: Bool -> Literal

-- | Vector literal
[VecLit] :: [Literal] -> Literal

-- | String literal
[StringLit] :: String -> Literal

-- | Bit literal
data Bit

-- | High
[H] :: Bit

-- | Low
[L] :: Bit

-- | Undefined
[U] :: Bit

-- | High-impedance
[Z] :: Bit

-- | Context used to fill in the holes of a BlackBox template
data BlackBoxContext
[Context] :: (SyncExpr, HWType) -> [(SyncExpr, HWType, Bool)] -> IntMap (Either BlackBoxTemplate Declaration, BlackBoxContext) -> BlackBoxContext

-- | Result name and type
[bbResult] :: BlackBoxContext -> (SyncExpr, HWType)

-- | Argument names, types, and whether it is a literal
[bbInputs] :: BlackBoxContext -> [(SyncExpr, HWType, Bool)]

-- | Function arguments (subset of inputs):
--   
--   <ul>
--   <li>(Blackbox Template,Partial Blackbox Concext)</li>
--   </ul>
[bbFunctions] :: BlackBoxContext -> IntMap (Either BlackBoxTemplate Declaration, BlackBoxContext)
emptyBBContext :: BlackBoxContext

-- | Either the name of the identifier, or a tuple of the identifier and
--   the corresponding clock
type SyncIdentifier = Either Identifier (Identifier, (Identifier, Int))
type SyncExpr = Either Expr (Expr, (Identifier, Int))
varEnv :: Lens' NetlistState Gamma
varCount :: Lens' NetlistState Int
typeTranslator :: Lens' NetlistState (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType))
tcCache :: Lens' NetlistState (HashMap TyConName TyCon)
primitives :: Lens' NetlistState PrimMap
modNm :: Lens' NetlistState String
dataFiles :: Lens' NetlistState [(String, FilePath)]
curCompNm :: Lens' NetlistState Identifier
components :: Lens' NetlistState (HashMap TmName Component)
cmpCount :: Lens' NetlistState Int
bindings :: Lens' NetlistState (HashMap TmName (Type, Term))
instance Constructor C1_12HWType
instance Constructor C1_11HWType
instance Constructor C1_10HWType
instance Constructor C1_9HWType
instance Constructor C1_8HWType
instance Constructor C1_7HWType
instance Constructor C1_6HWType
instance Constructor C1_5HWType
instance Constructor C1_4HWType
instance Constructor C1_3HWType
instance Constructor C1_2HWType
instance Constructor C1_1HWType
instance Constructor C1_0HWType
instance Datatype D1HWType
instance MonadIO NetlistMonad
instance Fresh NetlistMonad
instance MonadState NetlistState NetlistMonad
instance MonadWriter (Set (Identifier, HWType)) NetlistMonad
instance Applicative NetlistMonad
instance Monad NetlistMonad
instance Functor NetlistMonad
instance Show Component
instance Show Declaration
instance Show BlackBoxContext
instance Show Expr
instance Show Literal
instance Show Bit
instance Show Modifier
instance Generic HWType
instance Show HWType
instance Ord HWType
instance Eq HWType
instance NFData Component
instance Hashable HWType
instance NFData HWType
instance NFData Declaration


-- | Type and instance definitions for Rewrite modules
module CLaSH.Rewrite.Types

-- | Context in which a term appears
data CoreContext

-- | Function position of an application
[AppFun] :: CoreContext

-- | Argument position of an application
[AppArg] :: CoreContext

-- | Function position of a type application
[TyAppC] :: CoreContext

-- | RHS of a Let-binder with the sibling LHS'
[LetBinding] :: [Id] -> CoreContext

-- | Body of a Let-binding with the bound LHS'
[LetBody] :: [Id] -> CoreContext

-- | Body of a lambda-term with the abstracted variable
[LamBody] :: Id -> CoreContext

-- | Body of a TyLambda-term with the abstracted type-variable
[TyLamBody] :: TyVar -> CoreContext

-- | RHS of a case-alternative with the variables bound by the pattern on
--   the LHS
[CaseAlt] :: [Id] -> CoreContext

-- | Subject of a case-decomposition
[CaseScrut] :: CoreContext

-- | State of a rewriting session
data RewriteState
[RewriteState] :: Int -> HashMap TmName (Type, Term) -> Supply -> (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> HashMap TyConName TyCon -> (HashMap TyConName TyCon -> Term -> Term) -> RewriteState

-- | Number of applied transformations
[_transformCounter] :: RewriteState -> Int

-- | Global binders
[_bindings] :: RewriteState -> HashMap TmName (Type, Term)

-- | Supply of unique numbers
[_uniqSupply] :: RewriteState -> Supply

-- | Hardcode Type -&gt; HWType translator
[_typeTranslator] :: RewriteState -> HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)

-- | TyCon cache
[_tcCache] :: RewriteState -> HashMap TyConName TyCon

-- | Hardcoded evaluator (delta-reduction)
[_evaluator] :: RewriteState -> HashMap TyConName TyCon -> Term -> Term
uniqSupply :: Lens' RewriteState Supply
typeTranslator :: Lens' RewriteState (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType))
transformCounter :: Lens' RewriteState Int
tcCache :: Lens' RewriteState (HashMap TyConName TyCon)
evaluator :: Lens' RewriteState (HashMap TyConName TyCon -> Term -> Term)
bindings :: Lens' RewriteState (HashMap TmName (Type, Term))

-- | Debug Message Verbosity
data DebugLevel

-- | Don't show debug messages
[DebugNone] :: DebugLevel

-- | Show completely normalized expressions
[DebugFinal] :: DebugLevel

-- | Names of applied transformations
[DebugName] :: DebugLevel

-- | Show sub-expressions after a successful rewrite
[DebugApplied] :: DebugLevel

-- | Show all sub-expressions on which a rewrite is attempted
[DebugAll] :: DebugLevel

-- | Read-only environment of a rewriting session
newtype RewriteEnv
[RE] :: DebugLevel -> RewriteEnv
[_dbgLevel] :: RewriteEnv -> DebugLevel
dbgLevel :: Iso' RewriteEnv DebugLevel

-- | Monad that keeps track how many transformations have been applied and
--   can generate fresh variables and unique identifiers
type RewriteSession m = ReaderT RewriteEnv (StateT RewriteState (FreshMT m))

-- | Monad that can do the same as <a>RewriteSession</a> and in addition
--   keeps track if a transformation/rewrite has been successfully applied.
type RewriteMonad m = WriterT Any (RewriteSession m)

-- | MTL convenience wrapper around <a>RewriteMonad</a>
newtype R m a
[R] :: RewriteMonad m a -> R m a
[runR] :: R m a -> RewriteMonad m a

-- | Monadic action that transforms a term given a certain context
type Transform m = [CoreContext] -> Term -> m Term

-- | A <a>Transform</a> action in the context of the <a>RewriteMonad</a>
type Rewrite m = Transform (R m)
instance Monad m => Fresh (R m)
instance Monad m => MonadUnique (R m)
instance Monad m => MonadWriter Any (R m)
instance Monad m => MonadState RewriteState (R m)
instance Monad m => MonadReader RewriteEnv (R m)
instance Monad m => Monad (R m)
instance Monad m => Applicative (R m)
instance Functor m => Functor (R m)
instance Monad m => MonadUnique (RewriteMonad m)
instance Read DebugLevel
instance Ord DebugLevel
instance Eq DebugLevel
instance Show CoreContext
instance Eq CoreContext


-- | Type definitions used by the Driver module
module CLaSH.Driver.Types

-- | Global function binders
type BindingMap = HashMap TmName (Type, Term)
data CLaSHOpts
[CLaSHOpts] :: Int -> Int -> Int -> DebugLevel -> CLaSHOpts
[opt_inlineLimit] :: CLaSHOpts -> Int
[opt_specLimit] :: CLaSHOpts -> Int
[opt_inlineBelow] :: CLaSHOpts -> Int
[opt_dbgLevel] :: CLaSHOpts -> DebugLevel


-- | Types used in Normalize modules
module CLaSH.Normalize.Types

-- | State of the <a>NormalizeMonad</a>
data NormalizeState
[NormalizeState] :: HashMap TmName (Type, Term) -> Map (TmName, Int, Either Term Type) (TmName, Type) -> HashMap TmName Int -> Int -> HashMap TmName (HashMap TmName Int) -> Int -> Int -> TmName -> NormalizeState

-- | Global binders
[_normalized] :: NormalizeState -> HashMap TmName (Type, Term)

-- | Cache of previously specialised functions:
--   
--   <ul>
--   <li>Key: (name of the original function, argument position,
--   specialised term/type)</li>
--   <li>Elem: (name of specialised function,type of specialised
--   function)</li>
--   </ul>
[_specialisationCache] :: NormalizeState -> Map (TmName, Int, Either Term Type) (TmName, Type)

-- | Cache of how many times a function was specialized
[_specialisationHistory] :: NormalizeState -> HashMap TmName Int

-- | Number of time a function <tt>f</tt> can be specialized
[_specialisationLimit] :: NormalizeState -> Int

-- | Cache of function where inlining took place:
--   
--   <ul>
--   <li>Key: function where inlining took place</li>
--   <li>Elem: (functions which were inlined, number of times inlined)</li>
--   </ul>
[_inlineHistory] :: NormalizeState -> HashMap TmName (HashMap TmName Int)

-- | Number of times a function <tt>f</tt> can be inlined in a function
--   <tt>g</tt>
[_inlineLimit] :: NormalizeState -> Int

-- | Size of a function below which it is always inlined if it is not
--   recursive
[_inlineBelow] :: NormalizeState -> Int

-- | Function which is currently normalized
[_curFun] :: NormalizeState -> TmName
specialisationLimit :: Lens' NormalizeState Int
specialisationHistory :: Lens' NormalizeState (HashMap TmName Int)
specialisationCache :: Lens' NormalizeState (Map (TmName, Int, Either Term Type) (TmName, Type))
normalized :: Lens' NormalizeState (HashMap TmName (Type, Term))
inlineLimit :: Lens' NormalizeState Int
inlineHistory :: Lens' NormalizeState (HashMap TmName (HashMap TmName Int))
inlineBelow :: Lens' NormalizeState Int
curFun :: Lens' NormalizeState TmName

-- | State monad that stores specialisation and inlining information
type NormalizeMonad = State NormalizeState

-- | RewriteSession with extra Normalisation information
type NormalizeSession = RewriteSession NormalizeMonad

-- | A <tt>Transform</tt> action in the context of the
--   <tt>RewriteMonad</tt> and <a>NormalizeMonad</a>
type NormRewrite = Rewrite NormalizeMonad


-- | Rewriting combinators and traversals
module CLaSH.Rewrite.Combinators

-- | Apply a transformation on the subtrees of an term
allR :: (Functor m, Monad m, Fresh m) => Bool -> Transform m -> Transform m

-- | Apply two transformations in succession
(>->) :: (Monad m) => Transform m -> Transform m -> Transform m

-- | Apply a transformation in a topdown traversal
topdownR :: (Fresh m, Functor m, Monad m) => Transform m -> Transform m

-- | Apply a transformation in a topdown traversal. Doesn't freshen bound
--   variables
unsafeTopdownR :: (Fresh m, Functor m, Monad m) => Transform m -> Transform m

-- | Apply a transformation in a bottomup traversal
bottomupR :: (Fresh m, Functor m, Monad m) => Transform m -> Transform m

-- | Apply a transformation in a bottomup traversal. Doesn't freshen bound
--   variables
unsafeBottomupR :: (Fresh m, Functor m, Monad m) => Transform m -> Transform m

-- | Only apply the second transformation if the first one succeeds.
(!->) :: Monad m => Rewrite m -> Rewrite m -> Rewrite m

-- | Only apply the second transformation if the first one fails.
(>-!) :: Monad m => Rewrite m -> Rewrite m -> Rewrite m

-- | Keep applying a transformation until it fails.
repeatR :: Monad m => Rewrite m -> Rewrite m
whenR :: Monad m => ([CoreContext] -> Term -> m Bool) -> Transform m -> Transform m

-- | Only traverse downwards when the assertion evaluates to true
bottomupWhenR :: (Monad m, Fresh m, Functor m) => ([CoreContext] -> Term -> m Bool) -> Transform m -> Transform m


-- | Utilities for converting Core Type/Term to Netlist datatypes
module CLaSH.Netlist.Util

-- | Split a normalized term into: a list of arguments, a list of
--   let-bindings, and a variable reference that is the body of the
--   let-binding. Returns a String containing the error is the term was not
--   in a normalized form.
splitNormalized :: (Fresh m, Functor m) => HashMap TyConName TyCon -> Term -> m (Either String ([Id], [LetBinding], Id))

-- | Converts a Core type to a HWType given a function that translates
--   certain builtin types. Errors if the Core type is not translatable.
unsafeCoreTypeToHWType :: String -> (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> HashMap TyConName TyCon -> Type -> HWType

-- | Converts a Core type to a HWType within the NetlistMonad; errors on
--   failure
unsafeCoreTypeToHWTypeM :: String -> Type -> NetlistMonad HWType

-- | Converts a Core type to a HWType within the NetlistMonad;
--   <a>Nothing</a> on failure
coreTypeToHWTypeM :: Type -> NetlistMonad (Maybe HWType)

-- | Returns the name and period of the clock corresponding to a type
synchronizedClk :: HashMap TyConName TyCon -> Type -> Maybe (Identifier, Int)

-- | Converts a Core type to a HWType given a function that translates
--   certain builtin types. Returns a string containing the error message
--   when the Core type is not translatable.
coreTypeToHWType :: (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> HashMap TyConName TyCon -> Type -> Either String HWType

-- | Converts an algebraic Core type (split into a TyCon and its argument)
--   to a HWType.
mkADT :: (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> HashMap TyConName TyCon -> String -> TyConName -> [Type] -> Either String HWType

-- | Simple check if a TyCon is recursively defined.
isRecursiveTy :: HashMap TyConName TyCon -> TyConName -> Bool

-- | Determines if a Core type is translatable to a HWType given a function
--   that translates certain builtin types.
representableType :: (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> HashMap TyConName TyCon -> Type -> Bool

-- | Determines the bitsize of a type
typeSize :: HWType -> Int

-- | Determines the bitsize of the constructor of a type
conSize :: HWType -> Int

-- | Gives the length of length-indexed types
typeLength :: HWType -> Int

-- | Gives the HWType corresponding to a term. Returns an error if the term
--   has a Core type that is not translatable to a HWType.
termHWType :: String -> Term -> NetlistMonad HWType

-- | Gives the HWType corresponding to a term. Returns <a>Nothing</a> if
--   the term has a Core type that is not translatable to a HWType.
termHWTypeM :: Term -> NetlistMonad (Maybe HWType)

-- | Turns a Core variable reference to a Netlist expression. Errors if the
--   term is not a variable.
varToExpr :: Term -> Expr

-- | Uniquely rename all the variables and their references in a normalized
--   term
mkUniqueNormalized :: ([Id], [LetBinding], Id) -> NetlistMonad ([Id], [LetBinding], TmName)

-- | Append a string to a name
appendToName :: TmName -> String -> TmName

-- | Preserve the Netlist <a>_varEnv</a> and <a>_varCount</a> when
--   executing a monadic action
preserveVarEnv :: NetlistMonad a -> NetlistMonad a
dcToLiteral :: HWType -> Int -> Expr


-- | Utilities for rewriting: e.g. inlining, specialisation, etc.
module CLaSH.Rewrite.Util

-- | Lift an action working in the inner monad to the <a>RewriteMonad</a>
liftR :: Monad m => m a -> RewriteMonad m a

-- | Lift an action working in the inner monad to the <a>RewriteSession</a>
liftRS :: Monad m => m a -> RewriteSession m a

-- | Record if a transformation is succesfully applied
apply :: (Monad m, Functor m) => String -> Rewrite m -> Rewrite m

-- | Perform a transformation on a Term
runRewrite :: (Monad m, Functor m) => String -> Rewrite m -> Term -> RewriteSession m Term

-- | Evaluate a RewriteSession to its inner monad
runRewriteSession :: (Functor m, Monad m) => DebugLevel -> RewriteState -> RewriteSession m a -> m a

-- | Notify that a transformation has changed the expression
setChanged :: Monad m => RewriteMonad m ()

-- | Identity function that additionally notifies that a transformation has
--   changed the expression
changed :: Monad m => a -> RewriteMonad m a

-- | Create a type and kind context out of a transformation context
contextEnv :: [CoreContext] -> (Gamma, Delta)

-- | Create a complete type and kind context out of the global binders and
--   the transformation context
mkEnv :: (Functor m, Monad m) => [CoreContext] -> RewriteMonad m (Gamma, Delta)

-- | Make a new binder and variable reference for a term
mkTmBinderFor :: (Functor m, Fresh m, MonadUnique m) => HashMap TyConName TyCon -> String -> Term -> m (Id, Term)

-- | Make a new binder and variable reference for either a term or a type
mkBinderFor :: (Functor m, Monad m, MonadUnique m, Fresh m) => HashMap TyConName TyCon -> String -> Either Term Type -> m (Either (Id, Term) (TyVar, Type))

-- | Make a new, unique, identifier and corresponding variable reference
mkInternalVar :: (Functor m, Monad m, MonadUnique m) => String -> KindOrType -> m (Id, Term)

-- | Inline the binders in a let-binding that have a certain property
inlineBinders :: Monad m => (LetBinding -> RewriteMonad m Bool) -> Rewrite m

-- | Substitute the RHS of the first set of Let-binders for references to
--   the first set of Let-binders in: the second set of Let-binders and the
--   additional term
substituteBinders :: [LetBinding] -> [LetBinding] -> Term -> ([LetBinding], Term)

-- | Calculate the <i>local</i> free variable of an expression: the free
--   variables that are not bound in the global environment.
localFreeIds :: (Applicative f, Contravariant f, Monad m) => RewriteMonad m ((TmName -> f TmName) -> Term -> f Term)

-- | Lift the binders in a let-binding to a global function that have a
--   certain property
liftBinders :: (Functor m, Monad m) => (LetBinding -> RewriteMonad m Bool) -> Rewrite m

-- | Create a global function for a Let-binding and return a Let-binding
--   where the RHS is a reference to the new global function applied to the
--   free variables of the original RHS
liftBinding :: (Functor m, Monad m) => Gamma -> Delta -> LetBinding -> RewriteMonad m LetBinding

-- | Make a global function for a name-term tuple
mkFunction :: (Functor m, Monad m) => TmName -> Term -> RewriteMonad m (TmName, Type)

-- | Add a function to the set of global binders
addGlobalBind :: (Functor m, Monad m) => TmName -> Type -> Term -> RewriteMonad m ()

-- | Create a new name out of the given name, but with another unique
cloneVar :: (Functor m, Monad m) => TmName -> RewriteMonad m TmName

-- | Test whether a term is a variable reference to a local binder
isLocalVar :: (Functor m, Monad m) => Term -> RewriteMonad m Bool

-- | Determine if a term cannot be represented in hardware
isUntranslatable :: (Functor m, Monad m) => Term -> RewriteMonad m Bool

-- | Is the Context a Lambda/Term-abstraction context?
isLambdaBodyCtx :: CoreContext -> Bool

-- | Make a binder that should not be referenced
mkWildValBinder :: (Functor m, Monad m, MonadUnique m) => Type -> m Id

-- | Make a case-decomposition that extracts a field out of a
--   (Sum-of-)Product type
mkSelectorCase :: (Functor m, Monad m, MonadUnique m, Fresh m) => String -> HashMap TyConName TyCon -> [CoreContext] -> Term -> Int -> Int -> m Term

-- | Specialise an application on its argument
specialise :: (Functor m, MonadState s m) => Lens' s (Map (TmName, Int, Either Term Type) (TmName, Type)) -> Lens' s (HashMap TmName Int) -> Lens' s Int -> Bool -> Rewrite m

-- | Specialise an application on its argument
specialise' :: (Functor m, MonadState s m) => Lens' s (Map (TmName, Int, Either Term Type) (TmName, Type)) -> Lens' s (HashMap TmName Int) -> Lens' s Int -> Bool -> [CoreContext] -> Term -> (Term, [Either Term Type]) -> Either Term Type -> R m Term

-- | Create binders and variable references for free variables in
--   <tt>specArg</tt>
specArgBndrsAndVars :: (Functor m, Monad m) => [CoreContext] -> Either Term Type -> RewriteMonad m ([Either Id TyVar], [Either Term Type])


-- | Utility functions used by the normalisation transformations
module CLaSH.Normalize.Util

-- | Determine if a function is already inlined in the context of the
--   <tt>NetlistMonad</tt>
alreadyInlined :: TmName -> NormalizeMonad (Maybe Int)
addNewInline :: TmName -> NormalizeMonad ()

-- | Specialize under the Normalization Monad
specializeNorm :: Bool -> NormRewrite

-- | Determine if a term is closed
isClosed :: (Functor m, Fresh m) => HashMap TyConName TyCon -> Term -> m Bool

-- | Determine if a term represents a constant
isConstant :: Term -> Bool

-- | Create a call graph for a set of global binders, given a root
callGraph :: [TmName] -> HashMap TmName (Type, Term) -> TmName -> [(TmName, [TmName])]

-- | Determine the sets of recursive components given the edges of a
--   callgraph
recursiveComponents :: [(TmName, [TmName])] -> [[TmName]]
lambdaDropPrep :: HashMap TmName (Type, Term) -> TmName -> HashMap TmName (Type, Term)
lambdaDrop :: HashMap TmName (Type, Term) -> HashMap TmName [TmName] -> [TmName] -> (TmName, (Type, Term))
dominator :: HashMap TmName [TmName] -> [TmName] -> Gr TmName TmName
blockSink :: HashMap TmName (Type, Term) -> Gr TmName TmName -> LNode TmName -> (TmName, (Type, Term))


-- | Transformations of the Normalization process
module CLaSH.Normalize.Transformations

-- | Propagate arguments of application inwards; except for <a>Lam</a>
--   where the argument becomes let-bound.
appProp :: NormRewrite

-- | Inline non-recursive, non-representable let-bindings
bindNonRep :: NormRewrite

-- | Lift non-representable let-bindings
liftNonRep :: NormRewrite

-- | Lift the let-bindings out of the subject of a Case-decomposition
caseLet :: NormRewrite

-- | Specialize a Case-decomposition (replace by the RHS of an alternative)
--   if the subject is (an application of) a DataCon; or if there is only a
--   single alternative that doesn't reference variables bound by the
--   pattern.
caseCon :: NormRewrite

-- | Move a Case-decomposition from the subject of a Case-decomposition to
--   the alternatives
caseCase :: NormRewrite

-- | Inline function with a non-representable result if it's the subject of
--   a Case-decomposition
inlineNonRep :: NormRewrite

-- | Specialize functions on their type
typeSpec :: NormRewrite

-- | Specialize functions on their non-representable argument
nonRepSpec :: NormRewrite

-- | Eta-expand top-level lambda's (DON'T use in a traversal!)
etaExpansionTL :: NormRewrite

-- | Bring an application of a DataCon or Primitive in ANF, when the
--   argument is is considered non-representable
nonRepANF :: NormRewrite

-- | Inline let-bindings when the RHS is either a local variable reference
--   or is constant
bindConstantVar :: NormRewrite

-- | Specialise functions on arguments which are constant
constantSpec :: NormRewrite

-- | Turn an expression into a modified ANF-form. As opposed to standard
--   ANF, constants do not become let-bound.
makeANF :: NormRewrite

-- | Remove unused let-bindings
deadCode :: NormRewrite

-- | Ensure that top-level lambda's eventually bind a let-expression of
--   which the body is a variable-reference.
topLet :: NormRewrite

-- | Turn a normalized recursive function, where the recursive calls only
--   pass along the unchanged original arguments, into let-recursive
--   function. This means that all recursive calls are replaced by the same
--   variable reference as found in the body of the top-level
--   let-expression.
recToLetRec :: NormRewrite

-- | Inline nullary/closed functions
inlineClosed :: NormRewrite

-- | Inline a function with functional arguments
inlineHO :: NormRewrite

-- | Inline small functions
inlineSmall :: NormRewrite

-- | Simplified CSE, only works on let-bindings, works from top to bottom
simpleCSE :: NormRewrite
reduceConst :: NormRewrite


-- | Transformation process for normalization
module CLaSH.Normalize.Strategy

-- | Normalisation transformation
normalization :: NormRewrite
constantPropgation :: NormRewrite

-- | Topdown traversal, stops upon first success
topdownSucR :: (Functor m, Monad m) => Rewrite m -> Rewrite m
innerMost :: (Functor m, Monad m) => Rewrite m -> Rewrite m
applyMany :: (Functor m, Monad m) => [(String, Rewrite m)] -> Rewrite m


-- | Turn CoreHW terms into normalized CoreHW Terms
module CLaSH.Normalize

-- | Run a NormalizeSession in a given environment
runNormalization :: CLaSHOpts -> Supply -> HashMap TmName (Type, Term) -> (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> HashMap TyConName TyCon -> (HashMap TyConName TyCon -> Term -> Term) -> NormalizeSession a -> a
normalize :: [TmName] -> NormalizeSession (HashMap TmName (Type, Term))
normalize' :: TmName -> NormalizeSession ([TmName], (TmName, (Type, Term)))

-- | Rewrite a term according to the provided transformation
rewriteExpr :: (String, NormRewrite) -> (String, Term) -> NormalizeSession Term

-- | Check if the call graph (second argument), starting at the
--   <tt>topEnity</tt> (first argument) is non-recursive. Returns the list
--   of normalized terms if call graph is indeed non-recursive, errors
--   otherwise.
checkNonRecursive :: TmName -> HashMap TmName (Type, Term) -> HashMap TmName (Type, Term)

-- | Perform general "clean up" of the normalized (non-recursive) function
--   hierarchy. This includes:
--   
--   <ul>
--   <li>Inlining functions that simply "wrap" another function</li>
--   </ul>
cleanupGraph :: TmName -> (HashMap TmName (Type, Term)) -> NormalizeSession (HashMap TmName (Type, Term))
data CallTree
[CLeaf] :: (TmName, (Type, Term)) -> CallTree
[CBranch] :: (TmName, (Type, Term)) -> [CallTree] -> CallTree
mkCallTree :: [TmName] -> HashMap TmName (Type, Term) -> TmName -> CallTree
stripArgs :: [TmName] -> [Id] -> [Either Term Type] -> Maybe [Either Term Type]
flattenNode :: CallTree -> NormalizeSession (Either CallTree ((TmName, Term), [CallTree]))
flattenCallTree :: CallTree -> NormalizeSession CallTree
callTreeToList :: [TmName] -> CallTree -> ([TmName], [(TmName, (Type, Term))])

module CLaSH.Backend
class Backend state
initBackend :: Backend state => state
primDir :: Backend state => state -> IO FilePath
name :: Backend state => state -> String
extension :: Backend state => state -> String
extractTypes :: Backend state => state -> HashSet HWType
genHDL :: Backend state => String -> Component -> State state (String, Doc)
mkTyPackage :: Backend state => String -> [HWType] -> State state [(String, Doc)]
hdlType :: Backend state => HWType -> State state Doc
hdlTypeErrValue :: Backend state => HWType -> State state Doc
hdlTypeMark :: Backend state => HWType -> State state Doc
hdlSig :: Backend state => Text -> HWType -> State state Doc
genStmt :: Backend state => Bool -> State state Doc
inst :: Backend state => Declaration -> State state (Maybe Doc)
expr :: Backend state => Bool -> Expr -> State state Doc


-- | Utilties to verify blackbox contexts against templates and rendering
--   filled in templates
module CLaSH.Netlist.BlackBox.Util

-- | Determine if the number of normal<i>literal</i>function inputs of a
--   blackbox context at least matches the number of argument that is
--   expected by the template.
verifyBlackBoxContext :: BlackBoxContext -> BlackBoxTemplate -> Bool
extractLiterals :: BlackBoxContext -> [Expr]

-- | Update all the symbol references in a template, and increment the
--   symbol counter for every newly encountered symbol.
setSym :: Int -> BlackBoxTemplate -> (BlackBoxTemplate, Int)
setCompName :: Identifier -> BlackBoxTemplate -> BlackBoxTemplate
setClocks :: (MonadWriter (Set (Identifier, HWType)) m, Applicative m) => BlackBoxContext -> BlackBoxTemplate -> m BlackBoxTemplate
findAndSetDataFiles :: BlackBoxContext -> [(String, FilePath)] -> BlackBoxTemplate -> ([(String, FilePath)], BlackBoxTemplate)
renderFilePath :: [(String, FilePath)] -> String -> ([(String, FilePath)], Element)

-- | Get the name of the clock of an identifier
clkSyncId :: SyncExpr -> (Identifier, Int)

-- | Render a blackbox given a certain context. Returns a filled out
--   template and a list of <tt>hidden</tt> inputs that must be added to
--   the encompassing component.
renderBlackBox :: Backend backend => BlackBoxTemplate -> BlackBoxContext -> State backend Text

-- | Render a single template element
renderElem :: Backend backend => BlackBoxContext -> Element -> State backend Text
parseFail :: Text -> BlackBoxTemplate
syncIdToSyncExpr :: (Text, HWType) -> (SyncExpr, HWType, Bool)

-- | Fill out the template corresponding to an output/input assignment of a
--   component instantiation, and turn it into a single identifier so it
--   can be used for a new blackbox context.
lineToIdentifier :: Backend backend => BlackBoxContext -> BlackBoxTemplate -> State backend Text
lineToType :: BlackBoxContext -> BlackBoxTemplate -> HWType

-- | Give a context and a tagged hole (of a template), returns part of the
--   context that matches the tag of the hole.
renderTag :: Backend backend => BlackBoxContext -> Element -> State backend Text


-- | Functions to create BlackBox Contexts and fill in BlackBox templates
module CLaSH.Netlist.BlackBox

-- | Generate the context for a BlackBox instantiation.
mkBlackBoxContext :: Id -> [Term] -> NetlistMonad (BlackBoxContext, [Declaration])
prepareBlackBox :: Text -> Text -> BlackBoxContext -> NetlistMonad BlackBoxTemplate
mkArgument :: Term -> NetlistMonad ((SyncExpr, HWType, Bool), [Declaration])
mkPrimitive :: Bool -> Bool -> Text -> [Either Term Type] -> Type -> NetlistMonad (Expr, [Declaration])

-- | Create an template instantiation text and a partial blackbox content
--   for an argument term, given that the term is a function. Errors if the
--   term is not a function
mkFunInput :: Id -> Term -> NetlistMonad ((Either BlackBoxTemplate Declaration, BlackBoxContext), [Declaration])

-- | Instantiate symbols references with a new symbol and increment symbol
--   counter
instantiateSym :: BlackBoxTemplate -> NetlistMonad BlackBoxTemplate
instantiateCompName :: BlackBoxTemplate -> NetlistMonad BlackBoxTemplate
collectFilePaths :: BlackBoxContext -> BlackBoxTemplate -> NetlistMonad BlackBoxTemplate


-- | Create Netlists out of normalized CoreHW Terms
module CLaSH.Netlist

-- | Generate a hierarchical netlist out of a set of global binders with
--   <tt>topEntity</tt> at the top.
genNetlist :: Maybe Int -> HashMap TmName (Type, Term) -> PrimMap -> HashMap TyConName TyCon -> (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> Maybe Int -> String -> [(String, FilePath)] -> TmName -> IO ([Component], [(String, FilePath)], Int)

-- | Run a NetlistMonad action in a given environment
runNetlistMonad :: Maybe Int -> HashMap TmName (Type, Term) -> PrimMap -> HashMap TyConName TyCon -> (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> String -> [(String, FilePath)] -> NetlistMonad a -> IO (a, NetlistState)

-- | Generate a component for a given function (caching)
genComponent :: TmName -> Maybe Int -> NetlistMonad Component

-- | Generate a component for a given function
genComponentT :: TmName -> Term -> Maybe Int -> NetlistMonad Component

-- | Generate a list of Declarations for a let-binder
mkDeclarations :: Id -> Term -> NetlistMonad [Declaration]

-- | Generate a list of Declarations for a let-binder where the RHS is a
--   function application
mkFunApp :: Id -> TmName -> [Term] -> NetlistMonad [Declaration]
toSimpleVar :: (Expr, Type) -> NetlistMonad (Expr, [Declaration])

-- | Generate an expression for a term occurring on the RHS of a let-binder
mkExpr :: Bool -> Type -> Term -> NetlistMonad (Expr, [Declaration])

-- | Generate an expression for a DataCon application occurring on the RHS
--   of a let-binder
mkDcApplication :: HWType -> DataCon -> [Term] -> NetlistMonad (Expr, [Declaration])


-- | Generate a HDL testbench for a component given a set of stimuli and a
--   set of matching expected outputs
module CLaSH.Driver.TestbenchGen

-- | Generate a HDL testbench for a component given a set of stimuli and a
--   set of matching expected outputs
genTestBench :: CLaSHOpts -> Supply -> PrimMap -> (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> HashMap TyConName TyCon -> (HashMap TyConName TyCon -> Term -> Term) -> Int -> HashMap TmName (Type, Term) -> Maybe TmName -> Maybe TmName -> String -> [(String, FilePath)] -> Component -> IO ([Component], [(String, FilePath)])


module CLaSH.Driver.TopWrapper

-- | Create a wrapper around a component, potentially initiating clock
--   sources
mkTopWrapper :: PrimMap -> Maybe TopEntity -> String -> Component -> Component

-- | Create extra input ports for the wrapper
extraIn :: Maybe TopEntity -> [(Identifier, HWType)]

-- | Create extra output ports for the wrapper
extraOut :: Maybe TopEntity -> [(Identifier, HWType)]

-- | Generate input port mappings
mkInput :: [Identifier] -> (Identifier, HWType) -> Int -> ([Identifier], ([(Identifier, HWType)], ([Declaration], Identifier)))

-- | Create a Vector chain for a list of <a>Identifier</a>s
mkVectorChain :: Int -> HWType -> [Identifier] -> Expr

-- | Generate output port mappings
mkOutput :: [Identifier] -> (Identifier, HWType) -> Int -> ([Identifier], ([(Identifier, HWType)], ([Declaration], Identifier)))

-- | Create clock generators
mkClocks :: PrimMap -> [(Identifier, HWType)] -> Maybe TopEntity -> [Declaration]
stringToVar :: String -> Expr

-- | Create a single clock generator
mkClock :: ClockSource -> ([Declaration], (Identifier, [String], Bool))
mkClockDecl :: String -> Declaration

-- | Create a single clock path
clockPorts :: Maybe (String, String) -> [(String, String)] -> ([(Identifier, Expr)], [String])

-- | Generate resets
mkResets :: PrimMap -> [(Identifier, HWType)] -> [(Identifier, [String], Bool)] -> [Declaration]

-- | Generate a reset synchroniser that synchronously de-asserts an
--   asynchronous reset signal
genSyncReset :: PrimMap -> Identifier -> Identifier -> Text -> Int -> NetlistMonad [Declaration]

-- | The <tt>NetListMonad</tt> is an transformer stack with <a>IO</a> at
--   the bottom. So we must use <a>unsafePerformIO</a>.
unsafeRunNetlist :: NetlistMonad a -> a


-- | Module that connects all the parts of the CLaSH compiler library
module CLaSH.Driver

-- | Create a set of target HDL files for a set of functions
generateHDL :: Backend backend => BindingMap -> Maybe backend -> PrimMap -> HashMap TyConName TyCon -> (HashMap TyConName TyCon -> Type -> Maybe (Either String HWType)) -> (HashMap TyConName TyCon -> Term -> Term) -> Maybe TopEntity -> CLaSHOpts -> IO ()

-- | Pretty print Components to HDL Documents
createHDL :: Backend backend => backend -> String -> [Component] -> [(String, Doc)]

-- | Prepares the directory for writing HDL files. This means creating the
--   dir if it does not exist and removing all existing .hdl files from it.
prepareDir :: String -> IO ()

-- | Writes a HDL file to the given directory
writeHDL :: Backend backend => backend -> FilePath -> (String, Doc) -> IO ()
copyDataFiles :: FilePath -> [(String, FilePath)] -> IO ()
