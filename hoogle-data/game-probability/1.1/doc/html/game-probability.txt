-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple probability library for dice rolls, card games and similar
--   
--   A library designed to aid in easily calculating the probability of
--   various outcomes of dice rolls and card draws. The central types are
--   held in the <a>Numeric.Probability.Game.Event</a> module, the dice are
--   defined in the <a>Numeric.Probability.Game.Dice</a> module, and the
--   functions for calculating probabilities are in the
--   <a>Numeric.Probability.Game.Query</a> module. The functions for
--   playing cards cand be found in the
--   <a>Numeric.Probability.Game.Cards</a> module, and more efficient
--   calculation helpers can be found in the
--   <a>Numeric.Probability.Game.Cards.Hand</a> module.
--   
--   Various examples are scattered throughout the library, but here are
--   some more:
--   
--   Evalulates the chance of a coin toss turning up heads:
--   
--   <pre>
--   chanceTrue coinToss
--   </pre>
--   
--   Shows the chances of each outcome of rolling two six-sided dice, as a
--   textual bar chart:
--   
--   <pre>
--   show (2*d6)
--   </pre>
--   
--   The chance of getting an 18 when rolling 3 six-sided dice and
--   rerolling on any total less than 8:
--   
--   <pre>
--   chancePred (== 18) ((3*d6) `rerollOn` [3..7])
--   </pre>
--   
--   As a more complex example, this implements my memory/understanding of
--   the original World of Darkness dice system
--   (<a>http://en.wikipedia.org/wiki/Storytelling_System</a>). You roll a
--   given number of 10-sided dice, rolling one extra for every 10 you
--   score if you are specialised. The number of 1s on the original roll
--   are subtracted from the total number of dice that equal or exceed the
--   difficulty target:
--   
--   <pre>
--   successes :: Int -&gt; Int -&gt; Bool -&gt; EventM Int
--   successes target dice specialised
--     = do initial &lt;- replicateM dice d10
--          extra &lt;- if specialised
--                     then replicateM (count (== 10) initial) d10
--                     else return []
--          return (count (&gt;= target) (initial ++ extra) - count (== 1) initial)
--     where
--       count f xs = length (filter f xs)
--   </pre>
--   
--   If only all RPGs specified their rules in Haskell!
--   
--   See also the blog posts on the design of the library:
--   <a>http://chplib.wordpress.com/2010/08/13/nice-dice-in-haskell/</a>,
--   <a>http://chplib.wordpress.com/2010/08/23/sharp-cards-in-haskell-drawing-cards/</a>
--   and
--   <a>http://chplib.wordpress.com/2010/09/08/sharp-cards-in-haskell-the-odds/</a>
@package game-probability
@version 1.1


-- | A module containing the central type of the library, <a>EventM</a>,
--   and various related helper functions.
module Numeric.Probability.Game.Event

-- | A probabilistic event with an outcome of type <tt>a</tt>. See the
--   <a>enact</a> function to actually run the event and randomly pick an
--   outcome.
--   
--   For an explanation of the <a>Num</a> instance, see the DieRoll type in
--   the <a>Numeric.Probability.Game.Dice</a> module.
--   
--   The <a>Eq</a> instance compares the two distributions to see if they
--   are equal. This looks at all the outcomes and sees if their
--   probabilities are equal on the left-hand side and the right-hand side.
--   For example, <tt>coinToss == fmap (&gt;= 4) d6</tt>, but <tt>d12 /= d6
--   + d6</tt>.
--   
--   The <a>Show</a> instance will display a horizontal bar-chart of
--   relative outcome probability. Note: this really is a relative
--   probability -- common factors are cancelled, and is not a count of the
--   different outcomes. If you wish to show the raw numbers, use <tt>show
--   . outcomes</tt> instead.
--   
--   The <a>Functor</a> instance allows you to modify the outcome values
--   without changing their associated probabilities. For example, <tt>fmap
--   show d6</tt> changes the outcomes into their String representations.
--   
--   The <a>Applicative</a> instance allows you to join together the
--   results of two events in a predetermined manner. For example,
--   <tt>makeEvent [id, (* 2)] &lt;*&gt; d6</tt> allows you to roll a d6
--   that has a 50% chance of being doubled. Note that <tt>pure 6</tt> is
--   an event that is certain to produce the outcome 6.
--   
--   The <a>Monad</a> instance allows you to base the choice of the next
--   event on the result of the previous event. For example, <tt>coinToss
--   &gt;&gt;= x -&gt; if x then d6 else d4</tt> will roll a d4 50% of the
--   time and a d6 the other 50%. Note that <tt>return 6</tt> is an event
--   that is certain to produce the outcome 6.
data EventM a

-- | Makes an event that has an equal chance of taking on the value of each
--   entry in the list. Note that duplicates in the list are permitted and
--   do have an effect: <tt>makeEvent [True, False]</tt> has a 50% chance
--   of giving a True result, but <tt>makeEvent [True, True, False, False,
--   False]</tt> only has a 40% chance of giving a True result. If you do
--   not want this behaviour, use <tt>makeEvent . nub</tt> to remove
--   duplicates.
--   
--   The result of passing the empty list is undefined.
makeEvent :: [a] -> EventM a

-- | Given a list of events and their associated probabilities, forms a
--   corresponding event. The probabilities must be non-negative. If the
--   probabilities do not sum to one, they are all scaled linearly so that
--   their sum is one. Duplicate items will have their probabilities added.
--   
--   The result of passing the empty list, a list containing negative
--   probabilities, or a list where all the probabilities are zero is
--   undefined.
makeEventProb :: (Ord a, Real prob) => [(a, prob)] -> EventM a

-- | Gets a list of all the outcomes of the event and their associated
--   probability. You can be sure that the probabilities will all sum to 1,
--   and that there will only be one item in the list per outcome. It is
--   possible that some of the outcomes in the list will have zero
--   probability.
outcomes :: Ord a => EventM a -> [(a, Rational)]

-- | Actually enacts the event and produces a single result according to
--   the probabilities in the <tt>EventM a</tt> parameter.
enact :: EventM a -> IO a

-- | An event with a 50% chance of giving True, and a 50% chance of giving
--   False.
coinToss :: EventM Bool

-- | If the <tt>EventM a</tt> parameter returns a result equal to the first
--   parameter, it is changed to be the second parameter; otherwise it is
--   left untouched. For example <tt>replace 4 8 d4</tt> has an equal
--   chance of producing the outcomes 1, 2, 3 and 8, <tt>replace 10 0 d10
--   == z10</tt>, and <tt>replace 10 20 d6 == d6</tt>.
subst :: Eq a => a -> a -> EventM a -> EventM a

-- | Compares the outcomes of the two events, and works out the probability
--   associated with the first outcome being greater than, equal to or less
--   than the second outcome. The probabilites for each are returned in an
--   associative map.
--   
--   Added in version 1.1.
compareEvent :: Ord a => EventM a -> EventM a -> Map Ordering Rational
instance Monad EventM
instance Functor EventM
instance Applicative EventM
instance (Show a, Ord a) => Show (EventM a)
instance Num (EventM Int)
instance Ord a => Eq (EventM a)


-- | A module containing various definitions of dice as random events, and
--   a few associated helper functions. See <a>DieRoll</a>, which is really
--   a synonym for <a>EventM</a> Int.
module Numeric.Probability.Game.Dice

-- | A type synonym for events with an integer outcome (i.e. all standard
--   die rolls).
--   
--   The <a>Num</a> instance for <tt>EventM Int</tt> allows you to add the
--   results of two die rolls, or subtract them (if it helps, <tt>(+) =
--   liftA2 (+)</tt>).
--   
--   Multiplication works as follows. <tt>d * e</tt> evaluates the first
--   die roll, then sums that many rolls of the second. So <tt>2 * d6</tt>
--   rolls two d6 and adds the outcomes. However, this definition means
--   that <tt>d6 * 2</tt> rolls one d6, then effectively scales the result
--   by 2. And <tt>d6 * d4</tt> rolls one d6, then rolls that number of
--   <tt>d4</tt>, adding their results together. The simple rule when one
--   of the terms is a constant is: use the constant on the left-hand side
--   to get more dice, and use the constant on the right-hand side to scale
--   the result.
type DieRoll = EventM Int

-- | A nice synonym for <a>enact</a>: actually rolls the die and produces a
--   single result according to the probabilities in the <tt>EventM a</tt>
--   parameter.
roll :: DieRoll -> IO Int

-- | A die with an equal chance of rolling 1, 2, 3 or 4.
d4 :: DieRoll

-- | A die with an equal chance of rolling 1, 2, 3, 4, 5 or 6.
d6 :: DieRoll

-- | A die with an equal chance of rolling 1, 2, 3, 4, 5, 6, 7 or 8.
d8 :: DieRoll

-- | A die with an equal chance of rolling 0, 1, 2, 3, 4, 5, 6, 7, 8 or 9.
z10 :: DieRoll

-- | A die with an equal chance of rolling 1, 2, 3, 4, 5, 6, 7, 8, 9 or 10.
d10 :: DieRoll

-- | A die with an equal chance of rolling 1 to 12 inclusive.
d12 :: DieRoll

-- | A die with an equal chance of rolling 1 to 20 inclusive.
d20 :: DieRoll

-- | A die with an equal chance of rolling 1 to 100 inclusive.
d100 :: DieRoll

-- | A die with an equal chance of rolling 0 to 99 inclusive.
z100 :: DieRoll

-- | Makes a die that has an equal chance of achieving the numbers 1
--   through the number given. <tt>d 4</tt> has an equal chance of
--   producing the outcomes 1, 2, 3 and 4, <tt>d 1</tt> is equivalent to
--   <tt>return 1</tt> (a certain result of 1), and <tt>d</tt> is undefined
--   for any number below 1. For convenience, all the standard dice are
--   provided, e.g. <tt>d6 = d 6</tt>.
d :: Int -> DieRoll

-- | Makes a die that has an equal chance of achieving the numbers 0
--   through the one less than the number given. <tt>z 4</tt> has an equal
--   chance of producing the outcomes 0, 1, 2 and 3, while <tt>z 1</tt> is
--   equivalent to <tt>return 0</tt> (a certain result of 0), and
--   <tt>z</tt> is undefined for any number below 1. For convenience,
--   several standard dice that can be interpreted with a lower result of 0
--   are provided, e.g. <tt>z10 = z 10</tt>.
z :: Int -> DieRoll

-- | Rerolls the die when the specified outcome(s) occur. This has the
--   effect of removing the outcomes from the set of outcomes and rescaling
--   all the other probabilities linearly to sum to 1. For example:
--   
--   <pre>
--   d6 `rerollOn` [5,6] == d4
--   chancePred (== 12) ((2*d6) `rerollOn` [7]) == 1/30
--   </pre>
--   
--   With the latter example, the standard chance of 12 on 2d6 is 1/36,
--   which is rescaled by 36/30, the reciprocal of the chance of <i>not</i>
--   hitting a 7.
rerollOn :: DieRoll -> [Int] -> DieRoll

module Numeric.Probability.Game.Cards

-- | A collection/deck of cards. The collection of cards has no implicit
--   order, and each card is deemed to be equally likely to be drawn.
--   
--   So, for example, <tt>makeCards ["a","a","a","b","c"]</tt> is a
--   collection of cards with a 3/5 chance of drawing an <tt>"a"</tt>.
--   
--   Note that in <a>Cards</a> and all functions using it, the <a>Ord</a>
--   instance is considered to be authoritative. Imagine you have some type
--   like:
--   
--   <pre>
--   data MyCard = MyCard {cardType :: String, cardDescription :: String}
--   instance Ord MyCard where compare = comparing cardType
--   </pre>
--   
--   If you then create a collection of cards, all those with the same
--   <tt>cardType</tt> will be considered the same, and differences in
--   <tt>cardDescription</tt> will be collapsed. So, for example you may
--   find that:
--   
--   <pre>
--   cardsMap (makeCards [MyCard "Sword" "Long Sword", MyCard "Sword" "Legendary Sword of the Ancient King of Rak'Tharr", MyCard "Shield" "Buckler"])
--    == fromList [(MyCard "Sword" "Long Sword", 2), (MyCard "Shield" Buckler", 1)]
--   </pre>
--   
--   The two sword cards are indistinguishable from each other by the Ord
--   instance, so an arbitrary card for the two is kept in the collection
--   to represent them both -- the legendary sword is treated the same as
--   the long sword (so, equally, you might get two legendary swords in the
--   deck and no long sword).
--   
--   If you want the difference to matter, use an <a>Ord</a> instance that
--   recognises the difference. If you want the difference to matter some
--   of the time, and not matter at other times, you may want to use
--   <a>mapCards</a> to either pick out just the aspects you are interested
--   in, or to use a default value (e.g. empty description) for the aspects
--   you are not interested in.
--   
--   The <a>Monoid</a> instance can be used to get an empty <a>Cards</a>
--   object, and to add two collections of cards together.
data Cards a

-- | Gets a map from card to frequency for the given <a>Cards</a> item.
cardsMap :: Cards a -> Map a Int

-- | Gets a sorted list of cards. For example:
--   
--   <pre>
--   ["a","a","a","b","c","c"] == sortedCards (makeCardsMap (fromList [("c", 2), ("b", 1), ("a", 3)]))
--   </pre>
sortedCards :: Cards a -> [a]

-- | Counts the number of cards (i.e. the sum of the frequencies of each
--   distinct card) in the collection. <tt>cardCount cards == length
--   (sortedCards count)</tt>
--   
--   If you want the number of distinct cards in a collection, use <tt>size
--   . cardsMap</tt>.
cardCount :: Cards a -> Int

-- | Makes a collection of cards from the given list. The order of the list
--   does not matter, but duplicates are important: if a card occurs
--   multiple times in the list, it will appear multiple times in the
--   collection. So <tt>makeCards [<a>a</a>,<a>b</a>]</tt> has one card
--   named "a" and one named "b", but <tt>makeCards
--   [<a>a</a>,<a>a</a>,<a>b</a>,<a>a</a>]</tt> has three cards named "a"
--   and one named "b".
makeCards :: Ord a => [a] -> Cards a

-- | Makes a <a>Cards</a> item using a <a>Map</a> from card to frequency.
--   Any card with a frequency of 0 or less will be ignored.
makeCardsMap :: Ord a => Map a Int -> Cards a

-- | Adds the given card and frequency to the collection of cards. If the
--   card is already in the collection, the frequencies are added.
--   
--   Example:
--   
--   <pre>
--   addCard ("c", 2) (makeCards ["a","a","b"]) == makeCards ["a","a","b","c","c"]
--   addCard ("b", 1) (makeCards ["a","a","b"]) == makeCards ["a","a","b","b"]
--   </pre>
addCard :: Ord a => (a, Int) -> Cards a -> Cards a

-- | Removes a given number of cards that match the given criteria.
--   
--   As the name suggests, the choice of cards removed is arbitrary. This
--   function is mainly useful if you later want to check for the odds of
--   finding a card that <i>does</i> match the given criteria, but first
--   want to express that you know of many cards that don't meet the
--   criteria that aren't in the deck.
--   
--   If not enough cards meet the criteria in the collection, all that
--   don't meet the criteria will be removed.
removeArbitrary :: Ord a => (a -> Bool) -> Int -> Cards a -> Cards a

-- | Removes one of the given cards from the collection. This only reduces
--   the frequency by one; it does not remove all of the given card from
--   the collection. If the card is not in the collection, this has no
--   effect.
--   
--   Example:
--   
--   <pre>
--   removeOneCard "a" (makeCards ["a","a","a","b"]) == makeCards ["a","a","b"]
--   removeOneCard "c" (makeCards ["a","a","a","b"]) == makeCards ["a","a","a","b"]
--   </pre>
removeOneCard :: Ord a => a -> Cards a -> Cards a

-- | Applies a function to the cards. Like <a>fmap</a> for <a>Cards</a>,
--   but we can't use <a>Functor</a> because of the <a>Ord</a> constraint.
--   
--   If this function maps two old cards to the same single new card, their
--   frequencies are added together, but otherwise the frequencies are left
--   untouched.
--   
--   This function is particularly useful for narrowing the number of
--   distinct cards; see functions in the
--   <a>Numeric.Probability.Game.Cards.Hand</a> module.
--   
--   Example:
--   
--   <pre>
--   mapCards (map toUpper) (makeCardsMap (fromList [("a", 2), ("A", 3), ("b", 2)])) == makeCardsMap (fromList [("A", 5), ("B", 2)])
--   </pre>
mapCards :: Ord b => (a -> b) -> Cards a -> Cards b

-- | Removes the cards in the second parameter from the cards in the first
--   parameter. If the frequency of a card in the second parameter is
--   greater than or equal to the frequency of a card in the first
--   parameter, all of them are removed. Negative frequencies are not
--   possible.
--   
--   Example:
--   
--   <pre>
--   makeCardsMap (fromList [("a", 3), ("b", 1), ("c", 2)]) `minusCards` (makeCards ["a","b","b","c"]) == makeCards ["a","a","c"]
--   </pre>
minusCards :: Ord a => Cards a -> Cards a -> Cards a

-- | Draws one card from the given collection of cards at random. Returns
--   the card, and the collection of cards after the card has been drawn
--   (i.e. with one of that card removed). If the collection is empty, the
--   result is undefined.
--   
--   Note that using this function repeatedly to draw a hand of cards can
--   be quite computationally intensive; for more efficient methods, see
--   the <a>Numeric.Probability.Game.Cards.Hand</a> module.
--   
--   Example:
--   
--   <pre>
--   outcomes (drawOne (makeCards ["a","a","a","b"])) == [(("a", makeCards ["a","a","b"]), 3 % 4), (("b", makeCards ["a","a","a"]), 1 % 4)]
--   </pre>
drawOne :: Ord a => Cards a -> EventM (a, Cards a)

-- | Draws the given number of cards from the given collection with
--   replacement. Returns the collection of cards that will be drawn (and
--   thus you can be sure that: <tt>cardsCount &lt;$&gt; drawReplace n
--   cards</tt> will be <tt>n</tt>, provided <tt>cards</tt> is not empty).
--   If the given collection of cards is empty, the result is undefined.
--   
--   Note that using this function to draw a hand of cards can be quite
--   computationally intensive; for more efficient methods, see the
--   <a>Numeric.Probability.Game.Cards.Hand</a> module.
--   
--   Example:
--   
--   <pre>
--   outcomes (drawReplace 2 (makeCards ["a","a","a","b"])) ==
--     [(makeCards ["a","a"], 9 % 16), (makeCards ["a","b"], 3 % 8), (makeCards ["b","b"], 1 % 16)]
--   </pre>
drawReplace :: Ord a => Int -> Cards a -> EventM (Cards a)

-- | Draws the given number of cards from the given deck of cards at
--   random, without replacement. Returns the collection of cards that were
--   drawn (the first part of the result pait), and the corresponding
--   remaining deck of cards. If the deck is empty or does not contain
--   enough cards to draw the specified number, the result is undefined.
--   
--   Note that using this function to draw a hand of cards can be quite
--   computationally intensive; for more efficient methods, see the
--   <a>Numeric.Probability.Game.Cards.Hand</a> module.
--   
--   Note that <tt>makeCards n cards == swap &lt;$&gt; makeCards (cardCount
--   cards - n) cards</tt>; this method will be much more efficient with a
--   smaller number as parameter than a larger number.
--   
--   Example:
--   
--   <pre>
--   outcomes (drawNoReplace 2 (makeCards ["a","a","a","a", "b"])) ==
--     [((makeCards ["a","a"], makeCards ["a","a", "b"]), 3 % 5), ((makeCards ["a","b"], makeCards ["a,"a","a"]), 2 % 5)]
--   </pre>
drawNoReplace :: Ord a => Int -> Cards a -> EventM (Cards a, Cards a)
instance Ord a => Monoid (Cards a)
instance Show a => Show (Cards a)
instance Ord a => Ord (Cards a)
instance Ord a => Eq (Cards a)


-- | A module containing some simple data definitions for a deck of playing
--   cards.
module Numeric.Probability.Game.PlayingCards

-- | A playing card with a rank and suit. The ordering on them is arbitrary
--   (by rank then by suit).
data PlayingCard
PlayingCard :: Rank -> Suit -> PlayingCard
rank :: PlayingCard -> Rank
suit :: PlayingCard -> Suit

-- | The standard four suits of playing cards. The ordering on them is
--   arbitrary (alphabetical, in fact).
data Suit
Clubs :: Suit
Diamonds :: Suit
Hearts :: Suit
Spades :: Suit

-- | The rank of playing cards. The ranking is specified ace-high, as this
--   is how many games operate. If you wish to have an ace-low ordering you
--   can use the <a>AceLowRank</a> newtype.
data Rank
Two :: Rank
Three :: Rank
Four :: Rank
Five :: Rank
Six :: Rank
Seven :: Rank
Eight :: Rank
Nine :: Rank
Ten :: Rank
Jack :: Rank
Queen :: Rank
King :: Rank
Ace :: Rank

-- | A wrapper for <a>Rank</a> where the Ord, Enum and Bounded instances
--   are adjusted to list Ace as the lowest item rather than the highest.
newtype AceLowRank
AceLow :: Rank -> AceLowRank
alRank :: AceLowRank -> Rank

-- | The standard full deck of 52 playing cards.
deck :: Cards PlayingCard

-- | Checks if the two cards have the same suit.
sameSuit :: PlayingCard -> PlayingCard -> Bool

-- | Checks if the two cards have the same rank.
sameRank :: PlayingCard -> PlayingCard -> Bool
instance Eq PlayingCard
instance Ord PlayingCard
instance Show PlayingCard
instance Read PlayingCard
instance Eq Suit
instance Ord Suit
instance Show Suit
instance Read Suit
instance Eq AceLowRank
instance Show AceLowRank
instance Read AceLowRank
instance Bounded Rank
instance Enum Rank
instance Eq Rank
instance Ord Rank
instance Show Rank
instance Read Rank
instance Ord AceLowRank
instance Enum AceLowRank
instance Bounded AceLowRank


-- | Functions for efficiently calculating the probability of drawing
--   cards. Here are some examples of using the module.
--   
--   In the game Dominion you start out with a deck consisting of 7
--   "Copper" cards and 3 "Estate" cards. On your first turn you draw five
--   cards from this deck. To calculate the chances of drawing the
--   different number of "Copper" cards (as a map from number of "Copper"
--   cards to probability), you can use this code:
--   
--   <pre>
--   copperChances :: Map Int Rational
--   copperChances = chanceMap startingDeck (drawCount (== "Copper") 5)
--     where startingDeck = makeCards $ replicate 7 "Copper " ++ replicate 3 "Estate"
--   </pre>
--   
--   You could equally define a data-type for the cards rather than use
--   Strings, but often Strings are easiest for one-off queries.
--   
--   As a different example, in the game Ticket To Ride: Europe, the deck
--   of cards consists of 12 cards of each of eight colours and 14
--   multi-colour cards. We can describe it using a custom data-type this
--   time:
--   
--   <pre>
--   data TTRECard = Purple | White | Blue | Yellow | Orange | Black | Red | Green | MultiColour
--   </pre>
--   
--   <pre>
--   ttreDeck :: Cards TTRECard
--   ttreDeck = replicate 14 MultiColour ++ concatMap (replicate 12) [Purple, White, Blue, Yellow, Orange, Black, Red, Green]
--   </pre>
--   
--   In the game, there are always 5 communal cards visible. Imagine you
--   wanted to calculate the probability of receiving a particular colour
--   when drawing from the deck. You must first remove the cards in your
--   hand and those visible communal cards (we'll ignore the discards),
--   then calculate the probability for drawing one card with the
--   <a>draw</a> function:
--   
--   <pre>
--   colourChances :: Map TTRECard Rational
--   colourChances = chanceMap (ttreDeck `minusCards` (myHand `mappend` communal)) draw
--   </pre>
--   
--   This will give you a map from TTRECard (i.e. colour) to probability.
--   
--   To continue with that example, when you build tunnels in the game, you
--   must lay out the required number of coloured cards, then draw three
--   from the deck. If any of the three match the colour of tunnel you are
--   building, you must pay that many additional cards. You may want a
--   function that, given your hand (we'll ignore the communal cards to
--   keep the example shorter) and the length of the tunnel, works out if
--   you are likely to make it. One way to do this is:
--   
--   <pre>
--   tunnel :: Cards TTRECard -&gt; Int -&gt; Rational
--   tunnel myHand n = chance (ttreDeck `minusCards` myHand)
--                            (drawCount match 3 &gt;&gt;= ensure . (&lt;= spare))
--     where
--       spare = length (filter match $ sortedCards myHand) - n
--       match a = a == MultiColour || a == tunnelColour
--   </pre>
--   
--   That should be fairly fast. But to illustrate how to speed up these
--   calculations, here is another, faster way to do this: pre-process the
--   cards into those that match and those that don't, using
--   <a>chanceOn</a>:
--   
--   <pre>
--   tunnel :: Cards TTRECard -&gt; Int -&gt; Rational
--   tunnel myHand n = chanceOn match (ttreDeck `minusCards` myHand)
--                            (drawCount (== True) 3 &gt;&gt;= ensure . (&lt;= spare))
--     where
--       spare = length (filter match $ sortedCards myHand) - n
--       match a = a == MultiColour || a == tunnelColour
--   </pre>
--   
--   This may seem like a relatively small difference, and indeed it is a
--   small change to the code. However, it will execute much faster,
--   because the <a>chanceOn</a> function only has two different card
--   values to consider: True, and False, so it just considers those two.
--   Previously it had to consider the nine different types of card
--   separately, even though only two would match (the function has no way
--   of knowing that a priori).
module Numeric.Probability.Game.Cards.Hand

-- | A monad for describing drawing cards.
--   
--   The first parameter is the type of the card (this must match the deck
--   you end up drawing from), the second parameter is the monadic return
--   type as normal.
--   
--   Each action in the monad is the drawing of a card, see <a>draw</a> and
--   similar functions. There is the notion of failure: <a>badHand</a>
--   makes the current draw fail, as does <a>drawWhere</a> if no cards
--   satisfy the criteria, and attempting to <a>draw</a> when there are no
--   more cards will also fail.
--   
--   The <a>Alternative</a> instance allows you to choose between two
--   sequences of draws. If the LHS of '(&lt;|&gt;)' fails, the right-hand
--   side is used instead. <a>empty</a> is the same as <a>badHand</a>.
data DrawM card a

-- | Checks that the given property holds, otherwise fails the current
--   draw. Its definition is simple:
--   
--   <pre>
--   ensure b = if b then return () else badHand
--   </pre>
ensure :: Bool -> DrawM a ()

-- | Indicates that the current draw should not be continued.
badHand :: DrawM card a

-- | Tries to perform the two draws interleaved with each other in any
--   sequence, favouring those where the left-hand side acts first.
--   
--   As an example:
--   
--   <pre>
--   interleave (replicateM 2 (drawWhere (== "a"))) (replicateM 3 (drawWhere (== "b")))
--   </pre>
--   
--   will attempt to draw two "a" cards and three "b" cards, in any order
--   and return them as a pair. If you want to draw identical groupings
--   like this where the exact values of the cards can vary, look at
--   <a>drawGroups</a>.
interleave :: DrawM card a -> DrawM card b -> DrawM card (a, b)

-- | Draws a single card and returns it.
--   
--   If you are not interested in the value of the returned card,
--   <a>drawAny</a> is much more efficient. If you want to constrain which
--   card might be drawn, use <a>drawWhere</a>.
draw :: DrawM card card

-- | Draws any card from the deck. In cases where you are not interested in
--   what the card is, this is much more efficient than <a>draw</a>.
drawAny :: DrawM card ()

-- | Draws a single card that matches the given criteria (i.e. where the
--   given function returns True for the card).
--   
--   For example:
--   
--   <pre>
--   drawWhere (/= "c")
--   </pre>
--   
--   will draw any card that is not <tt>"c"</tt>. Note that:
--   
--   <pre>
--   (draw &gt;&gt;= ensure f) == (drawWhere f &gt;&gt; return ())
--   </pre>
drawWhere :: (card -> Bool) -> DrawM card card

-- | Draws cards until it draws a card that satisfies the given condition
--   or it hits the optional limit of cards. If the limit is zero, the
--   function will fail every time, 1 will only draw a single card, 2 will
--   draw up to 2 and so on.
--   
--   All the cards drawn will be returned in order, therefore you can be
--   guaranteed that the last card in the list (and only that card)
--   satisfies the given function.
drawUntil :: (card -> Bool) -> Maybe Int -> DrawM card [card]

-- | Draws the given number of cards and then counts how many meet the
--   given criteria. The definition is:
--   
--   <pre>
--   drawCount f n = length . filter f &lt;$&gt; replicateM n draw
--   </pre>
--   
--   Note that this is definitely <i>NOT</i> the same as <tt>replicateM n
--   (drawWhere f)</tt>. The <tt>drawWhere</tt> code makes sure that it
--   draws n cards that meet the given criteria (and fails in other cases),
--   whereas this function draws the given number then checks how many meet
--   the criteria. Therefore this function will only fail if there are
--   insufficient cards to draw that many.
drawCount :: (card -> Bool) -> Int -> DrawM card Int

-- | Draws the given number of identical cards from the deck.
--   
--   This corresponds to drawing one card from the deck with <a>draw</a>
--   and then using <a>drawWhere</a> to make sure the rest of the cards
--   match. The card that was drawn is returned (since all of them are
--   identical, only a single example is returned rather than a list).
drawSame :: Eq card => Int -> DrawM card card

-- | Draws the given number of identical (by the given aspect) cards from
--   the deck.
--   
--   This corresponds to drawing one card from the deck with <a>draw</a>
--   and then using <a>drawWhere</a> with the given mapping function to
--   make sure the rest of the cards match on the aspect specified. The
--   card that was drawn is returned (since all of them are identical, only
--   a single example is returned rather than a list). The order of the
--   returned list is arbitrary.
--   
--   For example:
--   
--   <pre>
--   drawSameOn (map toLower) 5
--   </pre>
--   
--   will draw 5 cards (where the card type is simply String) that have
--   matching names when compared case-insensitive. The return list you get
--   might be something like <tt>["a","A","A","a","a"]</tt>.
drawSameOn :: Eq aspect => (card -> aspect) -> Int -> DrawM card [card]

-- | Draws cards in groups of identical cards (but in any order) according
--   to the given sizes.
--   
--   This function is best explained by example:
--   
--   <ul>
--   <li><tt>drawGroups [2]</tt> will draw two identical cards, much as
--   <tt>drawSame 2</tt> does.</li>
--   <li><tt>drawGroups [2,1]</tt> will draw two identical cards, and a
--   third card that is guaranteed not to be equal to the two identical
--   cards.</li>
--   <li><tt>drawGroups [2,2]</tt> will draw two different lots of two
--   identical cards (i.e. it cannot return 4 of the same card).</li>
--   </ul>
--   
--   It is perhaps helpful to think of this function in terms of poker
--   hands. <tt>drawGroups [4,1]</tt> looks for 4-of-a-kind in a hand of 5,
--   <tt>drawGroups [3,2]</tt> looks for a full house, <tt>drawGroups
--   [2,2,1]</tt> looks for two-pair, while <tt>drawGroups [2,1,1,1]</tt>
--   looks for exactly one pair.
--   
--   The order of groups requested corresponds to the returns. Thus, for
--   example, this code should never fail a pattern match:
--   
--   <pre>
--   do [[a1,a2], [b1,b2,b3]] &lt;- drawGroups [2,3]
--   </pre>
--   
--   The groups have no correspondence to the order in which the cards were
--   drawn. So although the groups above and returned together, those 5
--   cards could have been drawn in any order, for example: <tt>[b2, a1,
--   b3, b2, a2]</tt>. This function is intended for cases when you want
--   particular identical groups but don't mind about the order. That is
--   surprisingly fiddly to write without this helper function.
drawGroups :: Ord card => [Int] -> DrawM card [[card]]

-- | Like <a>drawGroups</a>, but considers them equal if their given aspect
--   is equal.
drawGroupsOn :: Ord aspect => (card -> aspect) -> [Int] -> DrawM card [[card]]

-- | Calculates the chance of the given draw succeeding (i.e. not failing)
--   with the given deck. Note that the return value of the draw is
--   ignored; this function is only interested in whether the draw
--   succeeds.
--   
--   Note that if you are only interested in partial aspects of the cards
--   (e.g. just the rank in a deck of playing cards), <a>chanceOn</a> is
--   much more efficient. See <a>chanceOn</a> for more details.
--   
--   Examples:
--   
--   <pre>
--   chance deck (return ()) == 1
--   chance (makeCards ["a", "a", "b"]) (drawWhere (== "a")) == 2 % 3
--   chance (makeCards ["a", "a", "b"]) (drawSame 2) == 1 % 3
--   </pre>
chance :: Ord card => Cards card -> DrawM card a -> Rational

-- | Calculates the chance of the given draw succeeding (i.e. not failing)
--   with the given deck. Note that the return value of the draw is
--   ignored; this function is only interested in whether the draw
--   succeeds.
--   
--   The given function is used to transform the cards for drawing. This
--   can make the function much more efficient if the transform maps
--   several cards onto the same aspect. Consider if you wanted the
--   probability of drawing two aces from a deck of playing cards. If you
--   use <a>chance</a>, it will check all 52 distinct cards in the deck
--   separately to see if they are aces when you are drawing. However if
--   you use <tt>chanceOn rank</tt>, it can collapse the 52 playing cards
--   into 13 distinct cards (one per rank) with frequency 4, and only check
--   each of the 13 cards separately. Since this saving is made across
--   repeated draws, using <a>chanceOn</a> rather than <a>chance</a> can
--   reduce queries from taking many seconds into being instant. This also
--   applies to all the other chance..On and event..On variants of
--   functions in this module.
--   
--   Examples:
--   
--   <pre>
--   chanceOn id deck m == chance deck m
--   chanceOn (map toLower) (makeCards ["a", "a", "A", "A", "b"]) (drawWhere (== "a")) == 4 % 5
--   </pre>
chanceOn :: Ord aspect => (card -> aspect) -> Cards card -> DrawM aspect a -> Rational

-- | Calculates the probability of each result of the given draw with the
--   given deck. The probabilities will exclude the chance of a failed
--   draw; therefore the chance of a failed draw is <tt>1 - sum (elems $
--   chanceMap ..)</tt>. Alternatively you can incorporate the possibility
--   of a failed draw with a Maybe wrapper using <tt>chanceMap cards
--   (optional m)</tt>.
--   
--   Examples:
--   
--   <pre>
--   chanceMap (makeCards ["a","b"]) (drawWhere (== "a"))) == singleton "a" (1 % 2)
--   </pre>
--   
--   <pre>
--   outcomes (eventDraw (makeCards ["a","a","a","b","b"]) (drawSame 2)
--     == fromList [("a", 3 % 10), ("b", 1 % 5)]
--   </pre>
chanceMap :: (Ord card, Ord a) => Cards card -> DrawM card a -> Map a Rational

-- | Like <a>chanceMap</a> but can be much more efficient. See
--   <a>chanceOn</a> for an explanation of why.
chanceMapOn :: (Ord a, Ord aspect) => (card -> aspect) -> Cards card -> DrawM aspect a -> Map a Rational

-- | Turns the successful outcomes of the given draw into an <a>EventM</a>
--   type, which will return the different values of the successful draw
--   with their corresponding relative probabilities. Note that only
--   successful draws are included; a failed draw will have a probability
--   of zero. To incorporate the possibility of a failed draw, use
--   <a>eventDrawMaybe</a> instead.
--   
--   As with other functions, <a>eventDrawOn</a> can be much more
--   efficient; see <a>chanceOn</a> for details.
--   
--   For example:
--   
--   <pre>
--   outcomes (eventDraw (makeCards ["a","b"]) (drawWhere (== "a"))) == [("a", 1)]
--   </pre>
--   
--   <pre>
--   outcomes (eventDraw (makeCards ["a","a","a","b","b"]) (drawSame 2)
--     == [("a", 3 % 5), ("b", 2 % 5)]
--   </pre>
eventDraw :: (Ord a, Ord card) => Cards card -> DrawM card a -> EventM a

-- | Like <a>eventDraw</a> but can be much more efficient. See
--   <a>chanceOn</a> for an explanation of why.
eventDrawOn :: (Ord a, Ord aspect) => (card -> aspect) -> Cards card -> DrawM aspect a -> EventM a

-- | Turns the outcomes of the given draw into an <a>EventM</a> type, which
--   will return the different values of the draw with their corresponding
--   probabilities. Successful draws are the Just values; Nothing indicates
--   an unsuccessful draw, with its corresponding probability.
--   
--   As with other functions, <a>eventDrawMaybeOn</a> can be much more
--   efficient; see <a>chanceOn</a> for details.
--   
--   For example:
--   
--   <pre>
--   outcomes (eventDraw (makeCards ["a","b"]) (drawWhere (== "a"))) == [(Just "a", 1 % 2), (Nothing, 1 % 2)]
--   </pre>
--   
--   <pre>
--   outcomes (eventDraw (makeCards ["a","a","a","b","b"]) (drawSame 2)
--     == [(Just "a", 3 % 10), (Just "b", 1 % 5), (Nothing, 1 % 2)]
--   </pre>
--   
--   <pre>
--   eventDrawMaybe cards m == eventDraw cards (optional m)
--   </pre>
eventDrawMaybe :: (Ord a, Ord card) => Cards card -> DrawM card a -> EventM (Maybe a)

-- | Like <a>eventDrawMaybe</a> but can be much more efficient. See
--   <a>chanceOn</a> for an explanation of why.
eventDrawMaybeOn :: (Ord a, Ord aspect) => (card -> aspect) -> Cards card -> DrawM aspect a -> EventM (Maybe a)
instance Alternative (DrawM card)
instance Functor (DrawM card)
instance Applicative (DrawM card)
instance Monad (DrawM card)


-- | A module with functions for querying the probabilities of various
--   outcomes.
module Numeric.Probability.Game.Query

-- | Gets the probability that the outcome will satisfy the given
--   predicate. For example:
--   
--   <pre>
--   chancePred (&lt;= 2) d6 == 1/3   -- The chance of getting 2 or less on a d6
--   chancePred even d6 == 1/2     -- The chance of rolling an event number on a d6
--   </pre>
chancePred :: (a -> Bool) -> EventM a -> Rational

-- | Gets the probability that the given relation will hold between the two
--   events. For example:
--   
--   <pre>
--   chanceRel (==) d6 d6 == 1/6   -- The chance of rolling doubles on d6
--   chanceRel (&gt;) (2*d6) d12      -- The chance of beating a d12 with two d6
--   </pre>
chanceRel :: (a -> a -> Bool) -> EventM a -> EventM a -> Rational

-- | Gets the probability that the given boolean-outcome event will give a
--   True outcome. For example:
--   
--   <pre>
--   chanceTrue coinToss == 1/2
--   chanceTrue ((== 3) &lt;$&gt; d6) == 1/6
--   </pre>
--   
--   (For the latter example, <a>chancePred</a> is more concise.)
chanceTrue :: EventM Bool -> Rational
