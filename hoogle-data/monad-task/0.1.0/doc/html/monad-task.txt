-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monad transformer that turns event processing into co-routine programming.
--   
--   Task monad transformer can help refactor event and callback heavy
--   programs into monads via co-routines. The idea is loosely based on
--   <i>Combining Events And Threads For Scalable Network Services</i>, by
--   Peng Li and Steve Zdancewic, in <i>PLDI</i>, 2007.
--   (<a>http://www.cis.upenn.edu/~stevez/papers/abstracts.html#LZ07</a>),
--   but with deterministic and co-oprative lightweight threads, also known
--   as co-routines, so that the base monad can be anything ranging from IO
--   to state monads, or your favorite monad transformer stack.
@package monad-task
@version 0.1.0


-- | The MonadTask class that defines the set of combinators to work with
--   Task monad.
--   
--   The operations for MonadTask are similar to those of co-routines, with
--   the addition of watching and signaling events.
--   
--   We also define a set of auto lifting for common transformers. Note
--   that we purposely leave a case undefined where a state transformer
--   goes on top of a task monad, because such an operation is either
--   unsound or has to roll back the state (see
--   <tt><a>liftCallCC</a></tt>). So it's recommended to keep TaskT on top
--   of all StateT in a transformer stack.
module Control.Monad.Task.Class

-- | <tt>MonadTask</tt> specifies a task monad <tt>m</tt> over an event
--   type <tt>e</tt>.
class Monad m => MonadTask e m | m -> e
yield :: MonadTask e m => m ()
fork :: MonadTask e m => m a -> m ()
watch :: MonadTask e m => (e -> Maybe a) -> m a
signal :: MonadTask e m => e -> m ()
exit :: MonadTask e m => m ()

-- | <tt>orElse</tt> is a helper function for combining two trigger
--   functions disjuctively, favoring the first one.
orElse :: (e -> Maybe a) -> (e -> Maybe b) -> e -> Maybe (Either a b)
instance (Monoid w, Monad m, MonadTask a m) => MonadTask a (WriterT w m)
instance (Monoid w, Monad m, MonadTask a m) => MonadTask a (WriterT w m)
instance (Monad m, MonadTask a m) => MonadTask a (ReaderT r m)
instance (Monad m, MonadTask a m) => MonadTask a (MaybeT m)
instance (Monad m, MonadTask a m) => MonadTask a (ListT m)
instance (Monad m, MonadTask a m) => MonadTask a (IdentityT m)
instance (Error e, Monad m, MonadTask a m) => MonadTask a (ErrorT e m)

module Control.Monad.Trans.Task

-- | Task monad transformer.
newtype TaskT e m a
TaskT :: ContT (Trace m e) m a -> TaskT e m a
runTaskT :: TaskT e m a -> ContT (Trace m e) m a

-- | A <tt>Trace m e</tt> represents the control flow of a mult-threaded
--   task monad defined over a base monad <tt>m</tt> and event type
--   <tt>e</tt>.
data Trace m e
EXIT :: Trace m e
RET :: Trace m e
YIELD :: m (Trace m e) -> Trace m e
FORK :: m (Trace m e) -> m (Trace m e) -> Trace m e
WATCH :: (e -> Maybe v) -> (v -> m (Trace m e)) -> Trace m e
SIGNAL :: e -> m (Trace m e) -> Trace m e

-- | <tt>runTrace</tt> runs a trace to its completion in the base monad
--   with a simple round-robin scheduler.
runTrace :: Monad m => m (Trace m e) -> m ()

-- | <tt>tasktoTrace</tt> CPS-converts a task monad into a trace in its
--   base monad.
taskToTrace :: Monad m => TaskT e m a -> m (Trace m e)

-- | <tt>runTask</tt> runs a task monad until to its completion, i.e., no
--   more active tasks to run, or until it exits.
--   
--   <ul>
--   <li><pre><a>runTask</a> = <a>runTrace</a> .
--   <a>taskToTrace</a></pre></li>
--   </ul>
runTask :: Monad m => TaskT e m a -> m ()
instance Functor (TaskT e m)
instance Applicative (TaskT e m)
instance MonadIO m => MonadIO (TaskT e m)
instance Monad m => MonadTask e (TaskT e m)
instance MonadState s m => MonadState s (TaskT e m)
instance MonadReader s m => MonadReader s (TaskT e m)
instance MonadTrans (TaskT e)
instance Monad m => Monad (TaskT e m)


-- | Task monad transformer can help refactor event and callback heavy
--   programs into monads via co-routines. The idea is loosely based on
--   <i>Combining Events And Threads For Scalable Network Services</i>, by
--   Peng Li and Steve Zdancewic, in <i>PLDI</i>, 2007.
--   (<a>http://www.cis.upenn.edu/~stevez/papers/abstracts.html#LZ07</a>),
--   but with deterministic and co-oprative lightweight threads, also known
--   as co-routines, so that the base monad can be anything ranging from IO
--   to state monads, or your favorite monad transformer stack.
--   
--   Besides, Task monad transformer also provides a simple mechanism to
--   signal and watch for events, which allows complex event processing
--   logic to be expressed as streamlined monadic co-routines.
--   
--   Task monad transformer is essentially a ContT, or continuation
--   transformer, defined to extract the control flow of monadic programs
--   with co-operative multi-threading. After the CPS transformation, the
--   program trace is then executed with a simple round-robin scheduler.
module Control.Monad.Task

-- | <tt>MonadTask</tt> specifies a task monad <tt>m</tt> over an event
--   type <tt>e</tt>.
class Monad m => MonadTask e m | m -> e
yield :: MonadTask e m => m ()
fork :: MonadTask e m => m a -> m ()
watch :: MonadTask e m => (e -> Maybe a) -> m a
signal :: MonadTask e m => e -> m ()
exit :: MonadTask e m => m ()

-- | Task monad transformer.
newtype TaskT e m a
TaskT :: ContT (Trace m e) m a -> TaskT e m a
runTaskT :: TaskT e m a -> ContT (Trace m e) m a

-- | <tt>runTask</tt> runs a task monad until to its completion, i.e., no
--   more active tasks to run, or until it exits.
--   
--   <ul>
--   <li><pre><a>runTask</a> = <a>runTrace</a> .
--   <a>taskToTrace</a></pre></li>
--   </ul>
runTask :: Monad m => TaskT e m a -> m ()

-- | <tt>orElse</tt> is a helper function for combining two trigger
--   functions disjuctively, favoring the first one.
orElse :: (e -> Maybe a) -> (e -> Maybe b) -> e -> Maybe (Either a b)
