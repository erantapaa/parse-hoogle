-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Minimal HTTP client library optimized for benchmarking
--   
@package uhttpc
@version 0.1.1.0


-- | Minimal HTTP client implementation
--   
--   Note: this implementation only supports a subset of the HTTP protocol
--   for performance-reasons. This implementation is not meant to be used
--   for more than benchmarking purposes.
--   
--   See <tt>doReq</tt> in <tt>src-exe/uhttpc-bench.hs</tt> for an usage
--   example of this API
module Network.HTTP.MicroClient

-- | Minimal socket input-stream abstraction w/ single pushback &amp;
--   consumed byte-count
--   
--   This abstraction is inspired by io-streams but is tuned for
--   low-overhead
data SockStream

-- | Convert an existing <a>Socket</a> into a <a>SockStream</a>
ssFromSocket :: Socket -> IO SockStream

-- | Wrapper that creates TCP/IP IPv4 <tt>SocketStream</tt> and connects to
--   <a>SockAddr</a> created with <a>getSockAddr</a>
--   
--   If provided, the <tt>Maybe SockAddr</tt> argument allows to locally
--   bind the socket to a specific source address.
ssConnect :: Maybe SockAddr -> SockAddr -> IO SockStream

-- | Access underlying <a>Socket</a>
ssToSocket :: SockStream -> Socket
ssClose :: SockStream -> IO ()

-- | Access <a>SockStream</a> counter id
--   
--   Each created <a>SockStream</a> wrapper has an unique counter id value
--   associated
ssId :: SockStream -> Int

-- | Read data from stream.
--   
--   Note: Returns empty string on EOF. It's often better to use
--   <a>ssRead'</a> instead.
ssRead :: SockStream -> IO ByteString

-- | Version of <a>ssRead</a> which does not consume the data returned
--   
--   That is, <tt>ssPeek ss</tt> is semantically equivalent to <tt>do { b
--   &lt;- ssRead ss; ssUnRead b ss; return b}</tt>.
--   
--   <a>ssPeek</a> is idempotent, i.e. <tt>ssPeek ss == ssPeek ss &gt;&gt;
--   ssPeek ss</tt>
ssPeek :: SockStream -> IO ByteString

-- | May return empty string if no data has been buffered yet
ssPeekBuf :: SockStream -> IO ByteString

-- | Version of <a>ssRead</a> that throws
ssRead' :: SockStream -> IO ByteString

-- | Read exactly n bytes from <tt>SocketStream</tt>; throws exception if
--   connection is closed
ssReadN :: SockStream -> Word64 -> IO ByteString

-- | Push-back read data into <a>SockStream</a>
ssUnRead :: ByteString -> SockStream -> IO ()

-- | Write data out to socket (uses <a>sendAll</a> internally)
ssWrite :: ByteString -> SockStream -> IO ()

-- | Returns length of data consumed (i.e. w/o <a>ssUnRead</a> data)
ssReadCnt :: SockStream -> IO Word64

-- | Returns length of data written to stream
ssWriteCnt :: SockStream -> IO Word64
data HttpResponse
HttpResponse :: !HttpCode -> !Bool -> !Word64 -> [MsgHeader] -> [ByteString] -> HttpResponse

-- | status code
respCode :: HttpResponse -> !HttpCode

-- | whether server keeps connection open
respKeepalive :: HttpResponse -> !Bool

-- | content length
respContentLen :: HttpResponse -> !Word64

-- | list of header lines w/o CRLF
respHeader :: HttpResponse -> [MsgHeader]

-- | list of chunks
respContent :: HttpResponse -> [ByteString]

-- | HTTP status code
type HttpCode = Int

-- | RFC2616 sec 5.1.1 <tt>Method</tt>
data Method
GET :: Method
POST :: Method
HEAD :: Method
PUT :: Method
DELETE :: Method
TRACE :: Method
CONNECT :: Method
OPTIONS :: Method
type ReqURI = ByteString
type HostPort = ByteString
type MsgHeader = ByteString

-- | transfer-encoding/content-length information
data TransferEncoding

-- | identity w/ content length
TeIdentity :: !Word64 -> TransferEncoding

-- | chunked transfer
TeChunked :: TransferEncoding
TeInvalid :: TransferEncoding

-- | Construct general HTTP/1.1 request.
mkHttp11Req :: Method -> ReqURI -> HostPort -> Bool -> [MsgHeader] -> (Maybe ByteString) -> ByteString

-- | Construct HTTP/1.1 <tt>GET</tt> request. See <a>mkHttp11Req</a> for
--   constructing more general requests.
mkHttp11GetReq :: ReqURI -> HostPort -> Bool -> [MsgHeader] -> ByteString

-- | Receive full HTTP response
recvHttpResponse :: SockStream -> IO HttpResponse

-- | Receive/consume HTTP response from <a>SockStream</a>
--   
--   If no exception occured during <a>recvHttpHeaders</a> the
--   <a>SockStream</a> is left at the beginning of the (potentially empty)
--   HTTP response body.
recvHttpHeaders :: SockStream -> IO [ByteString]

-- | Extract information from the header lines as returned by
--   <a>recvHttpHeaders</a>
--   
--   returns: (status-code, close-conn, Just content-length <i>or</i>
--   Nothing (i.e. chunked))
httpHeaderGetInfos :: [ByteString] -> (HttpCode, Bool, TransferEncoding)

-- | Receive single HTTP chunk
recvChunk :: SockStream -> IO ByteString

-- | Construct IPv4 <a>SockAddr</a>
getSockAddr :: HostName -> PortNumber -> IO SockAddr

-- | Split HTTP URL into (hostname,port,url-path)
splitUrl :: String -> Either String (String, PortNumber, String)

-- | Return the time as the number of seconds (with up to microsecond
--   precision) since the Epoch, <tt>1970-01-01 00:00:00 +0000 (UTC)</tt>.
--   
--   This is a faster implementation the code below useful for benchmarking
--   purposes.
--   
--   <pre>
--   import Data.Time.Clock.POSIX (getPOSIXTime)
--   
--   getPOSIXTimeSecs :: IO Double
--   getPOSIXTimeSecs = fmap realToFrac getPOSIXTime
--   </pre>
--   
--   Note: this function returns <i>NaN</i> in case the underlying
--   <tt>gettimeofday(2)</tt> call fails.
getPOSIXTimeSecs :: IO Double

-- | Return the time as the number of microseconds since the Epoch,
--   <tt>1970-01-01 00:00:00 +0000 (UTC)</tt>.
--   
--   Note: this function returns <tt>0</tt> in case the underlying
--   <tt>gettimeofday(2)</tt> call fails.
--   
--   See also <a>getPOSIXTimeSecs</a>
getPOSIXTimeUSecs :: IO Word64
instance Show TransferEncoding
instance Eq TransferEncoding
instance Show Method
instance Eq Method
instance Enum Method
instance Show HttpResponse
instance NFData HttpResponse
instance NFData TransferEncoding
