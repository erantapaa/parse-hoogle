-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic classes for interacting with different container types
--   
--   Allow users of your library to choose which data structure they want
--   to use rather than constraining them to whatever you chose at the
--   time.
@package container-classes
@version 0.0.0.0


module Data.Containers

-- | <a>Container</a>s are data-types that store values. No restriction is
--   placed on <i>how</i> they store these values, though there may be
--   restrictions on some methods if a <a>Container</a> is also an instance
--   of a sub-class of <a>Container</a>.
--   
--   Minimum required implementation:
--   
--   <ul>
--   <li><a>null</a></li>
--   <li><a>insert</a></li>
--   <li><a>fold</a> or <a>splitElem</a></li>
--   </ul>
class Monoid c => Container c v | c -> v
null :: Container c v => c -> Bool
singleton :: Container c v => v -> c
insert :: Container c v => v -> c -> c
elem :: (Container c v, Eq v) => v -> c -> Bool
notElem :: (Container c v, Eq v) => v -> c -> Bool
delete :: (Container c v, Eq v) => v -> c -> c
deleteAll :: (Container c v, Eq v) => v -> c -> c
filter :: Container c v => (v -> Bool) -> c -> c
fold :: Container c v => (v -> a -> a) -> a -> c -> a
fold1 :: Container c v => (v -> v -> v) -> c -> v
genericSize :: (Container c v, Num n) => c -> n
size :: Container c v => c -> Int
partition :: Container c v => (v -> Bool) -> c -> (c, c)
all :: Container c v => (v -> Bool) -> c -> Bool
and :: (Container c v, v ~ Bool) => c -> Bool
any :: Container c v => (v -> Bool) -> c -> Bool
or :: (Container c v, v ~ Bool) => c -> Bool
product :: (Container c v, Num v) => c -> v
sum :: (Container c v, Num v) => c -> v
rigidMap :: Container c v => (v -> v) -> c -> c
splitElem :: Container c v => c -> Maybe (v, c)
maximum :: (Container c v, Ord v) => c -> v
minimum :: (Container c v, Ord v) => c -> v
build :: Container c v => ((v -> c -> c) -> c -> c) -> c

-- | An alias for <a>mempty</a>; constructs an empty <a>Container</a>.
empty :: Container c v => c

-- | An alias for <a>mappend</a>; combines two <a>Container</a>s. For
--   instances of <a>Sequence</a> this should be an <tt>append</tt>
--   operation.
(++) :: Container c v => c -> c -> c

-- | Concatenate all the inner <a>Container</a>s together.
concat :: (Container o i, Container i v) => o -> i

-- | Map a function over a <a>Container</a> and concatenate the results.
--   Note that the types of the initial and final <a>Container</a>s do not
--   have to be the same.
concatMap :: (Container f fv, Container t tv) => (fv -> t) -> f -> t

-- | Convert one <a>Container</a> to another. If they are both
--   <a>Sequence</a>s, then ordering is preserved.
convertContainer :: (Container f v, Container t v) => f -> t

-- | Convert one <a>Container</a> to another by utilising a mapping
--   function. If they are both <a>Sequence</a>s, then ordering is
--   preserved.
convertContainerBy :: (Container f fv, Container t tv) => (fv -> tv) -> f -> t

-- | Denotes <a>Container</a>s that have kind <tt>* -&gt; *</tt> and can
--   thus have more than one possible type of value stored within them.
class Container (c a) a => CFunctor c a
map :: (CFunctor c a, CFunctor c b) => (a -> b) -> c a -> c b

-- | Evaluate each action in the <a>Container</a> and collect the results.
--   The order the actions are evaluated in are determined by the
--   corresponding <a>fold</a> definition.
sequence :: (Monad m, CFunctor c a, CFunctor c (m a)) => c (m a) -> m (c a)

-- | Evaluate each action in the <a>Container</a> and discard the results.
--   The order the actions are evaluated in are determined by the
--   corresponding <a>fold</a> definition.
sequence_ :: (Monad m, Container c (m a)) => c -> m ()

-- | Apply the monadic mapping function to all the elements of the
--   'Container, and then evaluate the actions and collect the results. The
--   order the actions are evaluated in are determined by the corresponding
--   <a>fold</a> definition.
mapM :: (Monad m, CFunctor c a, CFunctor c b) => (a -> m b) -> c a -> m (c b)

-- | Apply the monadic mapping function to all the elements of the
--   'Container, and then evaluate the actions and discard the results. The
--   order the actions are evaluated in are determined by the corresponding
--   <a>fold</a> definition.
mapM_ :: (Monad m, CFunctor c a) => (a -> m b) -> c a -> m ()

-- | <a>Sequence</a>s are linear <a>Container</a>s with explicit left
--   (start) and right (end) ends. As such, it is possible to
--   append/traverse from either end.
--   
--   All methods have default stand-alone definitions, and thus no explicit
--   method definitions are required for instances.
class Container c v => Sequence c v
snoc :: Sequence c v => c -> v -> c
foldl :: Sequence c v => (b -> v -> b) -> b -> c -> b
foldl1 :: Sequence c v => (v -> v -> v) -> c -> v
viewR :: Sequence c v => c -> Maybe (v, c)
head :: (Sequence c v, Sequence c v) => c -> v
tail :: (Sequence c v, Sequence c v) => c -> c
last :: (Sequence c v, Sequence c v) => c -> v
init :: (Sequence c v, Sequence c v) => c -> c
genericTake :: (Sequence c v, Integral n) => n -> c -> c
take :: Sequence c v => Int -> c -> c
takeWhile :: Sequence c v => (v -> Bool) -> c -> c
dropWhile :: Sequence c v => (v -> Bool) -> c -> c
genericDrop :: (Sequence c v, Integral n) => n -> c -> c
drop :: Sequence c v => Int -> c -> c
reverse :: Sequence c v => c -> c
span :: Sequence c v => (v -> Bool) -> c -> (c, c)
break :: Sequence c v => (v -> Bool) -> c -> (c, c)
genericSplitAt :: (Sequence c v, Integral n) => n -> c -> (c, c)
splitAt :: Sequence c v => Int -> c -> (c, c)
genericReplicate :: (Sequence c v, Integral n) => n -> v -> c
replicate :: Sequence c v => Int -> v -> c
lines :: (Sequence c v, v ~ String) => String -> c
unlines :: (Sequence c v, v ~ String) => c -> String
words :: (Sequence c v, v ~ String) => String -> c
unwords :: (Sequence c v, v ~ String) => c -> String
buildL :: Sequence c v => ((c -> v -> c) -> c -> c) -> c

-- | An alias for <a>insert</a> for <a>Sequence</a>s.
cons :: Sequence c v => v -> c -> c

-- | An alias for <a>genericSize</a> for <a>Sequence</a>s.
genericLength :: (Sequence c v, Integral n) => c -> n

-- | An alias for <a>size</a> for <a>Sequence</a>s.
length :: Sequence c v => c -> Int

-- | An alias for <a>fold</a> for <tt>Seuquence</tt>s.
foldr :: Sequence c v => (v -> a -> a) -> a -> c -> a

-- | An alias for <a>fold1</a> for <tt>Seuquence</tt>s.
foldr1 :: Sequence c v => (v -> v -> v) -> c -> v

-- | An alias for <a>splitElem</a> for <tt>Seuquence</tt>s.
viewL :: Sequence c v => c -> Maybe (v, c)

-- | <a>Sequence</a> index (subscript) operator, starting from 0. Will
--   throw an <a>error</a> if the index is negative or larger than the
--   length of the <a>Sequence</a>.
(!!) :: Sequence c v => c -> Int -> v

-- | Represents <a>Sequence</a>s that are also instances of
--   <a>CFunctor</a>. All methods have default definitions.
class (Sequence (c a) a, CFunctor c a) => SFunctor c a
scanl :: (SFunctor c a, SFunctor c b) => (b -> a -> b) -> b -> c a -> c b
scanl1 :: SFunctor c a => (a -> a -> a) -> c a -> c a
scanr :: (SFunctor c a, SFunctor c b) => (a -> b -> b) -> b -> c a -> c b
scanr1 :: SFunctor c a => (a -> a -> a) -> c a -> c a
zipWith :: (SFunctor c a, SFunctor c b, SFunctor c d) => (a -> b -> d) -> c a -> c b -> c d
zip :: (SFunctor c a, SFunctor c b, SFunctor c (a, b)) => c a -> c b -> c (a, b)
unzip :: (SFunctor c a, SFunctor c b, SFunctor c (a, b)) => c (a, b) -> (c a, c b)
zipWith3 :: (SFunctor c a, SFunctor c b, SFunctor c d, SFunctor c e) => (a -> b -> d -> e) -> c a -> c b -> c d -> c e
zip3 :: (SFunctor c a, SFunctor c b, SFunctor c d, SFunctor c (a, b, d)) => c a -> c b -> c d -> c (a, b, d)
unzip3 :: (SFunctor c a, SFunctor c b, SFunctor c d, SFunctor c (a, b, d)) => c (a, b, d) -> (c a, c b, c d)

-- | Represents <a>Sequence</a>s that may be infinite in length. All
--   methods have default definitions.
class Sequence c v => Stream c v
repeat :: Stream c v => v -> c
cycle :: Stream c v => c -> c
iterate :: Stream c v => (v -> v) -> v -> c

-- | A wrapper around <a>enumFrom</a>.
enumFrom :: (Enum a, Stream c a) => a -> c

-- | A wrapper around <a>enumFromThen</a>.
enumFromThen :: (Enum a, Stream c a) => a -> a -> c

-- | A wrapper around <a>enumFromThenTo</a>.
enumFromThenTo :: (Enum a, Sequence c a) => a -> a -> a -> c

-- | A wrapper around <a>enumFromTo</a>.
enumFromTo :: (Enum a, Sequence c a) => a -> a -> c
instance SFunctor [] a
instance Sequence [a] a
instance CFunctor [] a
instance Container [a] a
