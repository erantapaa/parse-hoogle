-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data Parallel Haskell common definitions used by other dph-lifted packages.
--   
--   Data Parallel Haskell common definitions used by other dph-lifted
--   packages.
@package dph-lifted-base
@version 0.7.0.1


-- | During testing, we compare the output of each invocation of the lifted
--   combinators in <a>Data.Array.Parallel.PArray</a> with the reference
--   implementations.
--   
--   This module helps convert the to and from the array representation
--   used by the reference implementation.
module Data.Array.Parallel.PArray.Reference.Convert
class Similar a
similar :: Similar a => a -> a -> Bool
class PprPhysical1 a where pprp1v vec = brackets $ hcat $ punctuate (text ", ") $ toList $ map pprp1 vec
pprp1 :: PprPhysical1 a => a -> Doc
pprp1v :: PprPhysical1 a => Vector a -> Doc

-- | Compare the result of some array operator against a reference.
withRef1 :: (Array r a, Array c a, PprPhysical1 (c a), Similar a, PprPhysical1 a) => String -> r a -> c a -> c a

-- | Compare the nested result of some array operator against a reference.
withRef2 :: (Array r (r a), Array r a, Array c (c a), PprPhysical1 (c (c a)), Array c a, PprPhysical1 (c a), Similar a, PprPhysical1 a) => String -> r (r a) -> c (c a) -> c (c a)

-- | Convert an array to the reference version.
toRef1 :: (Array c a, Array r a) => c a -> r a

-- | Convert a nested array to the reference version.
toRef2 :: (Array c (c a), Array c a, Array r (r a), Array r a) => c (c a) -> r (r a)

-- | Convert a doubly nested array to the reference version.
toRef3 :: (Array c (c (c a)), Array c (c a), Array c a, Array r (r (r a)), Array r (r a), Array r a) => c (c (c a)) -> r (r (r a))


-- | Reference implementation of operators on unvectorised parallel arrays.
--   
--   <ul>
--   <li>In this module we just used boxed vectors as the array
--   representation. This won't be fast, but it means we can write the
--   operators without needing type class dictionaries such as PA. This
--   makes them much easier to use as reference code.</li>
--   <li>The operators should also all do bounds checks, sanity checks, and
--   give nice error messages if something is wrong. The ideas is that this
--   code can be run side-by-side production code during debugging.</li>
--   </ul>
module Data.Array.Parallel.PArray.Reference
type PArray a = Vector a

-- | Check that an array has a valid internal representation.
valid :: PArray a -> Bool

-- | Force an array to normal form.
nf :: PArray a -> ()

-- | O(1). An empty array.
empty :: PArray a

-- | O(1). Produce an array containing a single element.
singleton :: a -> PArray a

-- | O(n). Produce an array of singleton arrays.
singletonl :: PArray a -> PArray (PArray a)

-- | O(n). Define an array of the given size, that maps all elements to the
--   same value.
replicate :: Int -> a -> PArray a

-- | O(sum lengths). Lifted replicate.
replicatel :: PArray Int -> PArray a -> PArray (PArray a)

-- | O(sum lengths). Segmented replicate.
replicates :: Segd -> PArray a -> PArray a

-- | O(sum lengths). Wrapper for segmented replicate that takes replication
--   counts and uses them to build the <a>Segd</a>.
replicates' :: PArray Int -> PArray a -> PArray a

-- | Append two arrays.
append :: PArray a -> PArray a -> PArray a

-- | Lifted append.
appendl :: PArray (PArray a) -> PArray (PArray a) -> PArray (PArray a)

-- | Concatenation
concat :: PArray (PArray a) -> PArray a

-- | Lifted concatenation.
concatl :: PArray (PArray (PArray a)) -> PArray (PArray a)

-- | Impose a nesting structure on a flat array
unconcat :: PArray (PArray a) -> PArray b -> PArray (PArray b)

-- | Create a nested array from a segment descriptor and some flat data.
--   The segment descriptor must represent as many elements as present in
--   the flat data array, else <a>error</a>
nestUSegd :: Segd -> PArray a -> PArray (PArray a)

-- | Take the length of an array
length :: PArray a -> Int

-- | Take the length of some arrays.
lengthl :: PArray (PArray a) -> PArray Int

-- | Lookup a single element from the source array.
index :: PArray a -> Int -> a

-- | Lookup a several elements from several source arrays.
indexl :: PArray (PArray a) -> PArray Int -> PArray a

-- | Extract a range of elements from an array.
extract :: PArray a -> Int -> Int -> PArray a

-- | Segmented extract.
extracts :: Vector (PArray a) -> SSegd -> PArray a

-- | Wrapper for <a>extracts</a> that takes arrays of sources, starts and
--   lengths of the segments, and uses these to build the <a>SSegd</a>.
extracts' :: Vector (PArray a) -> PArray Int -> PArray Int -> PArray Int -> PArray a

-- | Extract a range of elements from an arrary. Like <a>extract</a> but
--   with the parameters in a different order.
slice :: Int -> Int -> PArray a -> PArray a

-- | Extract some slices from some arrays. The arrays of starting indices
--   and lengths must themselves have the same length.
slicel :: PArray Int -> PArray Int -> PArray (PArray a) -> PArray (PArray a)

-- | Take the segment descriptor from a nested array. This can cause index
--   space overflow if the number of elements in the result does not can
--   not be represented by a single machine word.
takeUSegd :: PArray (PArray a) -> Segd

-- | Select the elements of an array that have their tag set to True.
pack :: PArray a -> PArray Bool -> PArray a

-- | Lifted pack.
packl :: PArray (PArray a) -> PArray (PArray Bool) -> PArray (PArray a)

-- | Filter an array based on some tags.
packByTag :: PArray a -> Array Tag -> Tag -> PArray a

-- | Combine two arrays based on a selector.
combine2 :: Sel2 -> PArray a -> PArray a -> PArray a

-- | Construct a range of integers
enumFromTo :: Int -> Int -> PArray Int

-- | Lifted enumeration
enumFromTol :: PArray Int -> PArray Int -> PArray (PArray Int)

-- | O(n). Zip a pair of arrays into an array of pairs.
zip :: PArray a -> PArray b -> PArray (a, b)

-- | Lifted zip
zipl :: PArray (PArray a) -> PArray (PArray b) -> PArray (PArray (a, b))

-- | O(n). Unzip an array of pairs into a pair of arrays.
unzip :: PArray (a, b) -> (PArray a, PArray b)

-- | Lifted unzip
unzipl :: PArray (PArray (a, b)) -> PArray (PArray a, PArray b)

-- | Convert a <a>Vector</a> to a <a>PArray</a>
fromVector :: Vector a -> PArray a

-- | Convert a <a>PArray</a> to a <a>Vector</a>
toVector :: PArray a -> Vector a

-- | Convert a list to a <a>PArray</a>.
fromList :: [a] -> PArray a

-- | Convert a <a>PArray</a> to a list.
toList :: PArray a -> [a]

-- | Convert a <a>Array</a> to a <a>PArray</a>
fromUArray :: Elt a => Array a -> PArray a

-- | Convert a <a>PArray</a> to a <a>Array</a>
toUArray :: Elt a => PArray a -> Array a

-- | Convert a <a>Array</a> of tuples to a <a>PArray</a>
fromUArray2 :: (Elt a, Elt b) => Array (a, b) -> PArray (a, b)


-- | Defines the extra types we use when representing algebraic data in
--   parallel arrays. We don't store values of user defined algebraic type
--   directly in PArrays. Instead, we convert these to a generic
--   representation and store that representation.
--   
--   Conversion to and from the generic representation is handled by the
--   methods of the PA class defined in
--   <a>Data.Array.Parallel.PArray.PRepr</a>.
module Data.Array.Parallel.PArray.Types

-- | The <a>Void</a> type is used when representing enumerations.
--   
--   A type like Bool is represented as <tt>Sum2 Void Void</tt>, meaning
--   that we only only care about the tag of the data constructor and not
--   its argumnent.
data Void

-- | A <tt>value</tt> with the void type. Used as a placholder like
--   <a>undefined</a>. Forcing this yields <a>error</a>.
void :: Void

-- | Coerce a <a>Void</a> to a different type. Used as a placeholder like
--   <a>undefined</a>. Forcing the result yields <a>error</a>.
fromVoid :: a

-- | Sum types used for the generic representation of algebraic data.
data Sum2 a b
Alt2_1 :: a -> Sum2 a b
Alt2_2 :: b -> Sum2 a b
tagOfSum2 :: Sum2 a b -> Tag
data Sum3 a b c
Alt3_1 :: a -> Sum3 a b c
Alt3_2 :: b -> Sum3 a b c
Alt3_3 :: c -> Sum3 a b c
tagOfSum3 :: Sum3 a b c -> Tag

-- | When converting a data type to its generic representation, we use
--   <a>Wrap</a> to help us convert only one layer at a time. For example:
--   
--   <pre>
--      data Foo a = Foo Int a
--   
--   instance PA a =&gt; PA (Foo a) where
--       type PRepr (Foo a) = (Int, Wrap a)  -- define how (Foo a) is represented
--   </pre>
--   
--   Here we've converted the <tt>Foo</tt> data constructor to a pair, and
--   Int is its own representation type. We have PData/PR instances for
--   pairs and Ints, so we can work with arrays of these types. However, we
--   can't just use (Int, a) as the representation of (Foo a) because
--   <tt>a</tt> might be user defined and we won't have PData/PR instances
--   for it.
--   
--   Instead, we wrap the second element with the Wrap constructor, which
--   tells us that if we want to process this element we still need to
--   convert it to the generic representation (and back). This last part is
--   done by the PR instance of Wrap, who's methods are defined by calls to
--   the *PD functions from <a>Data.Array.Parallel.PArray.PRepr</a>.
newtype Wrap a
Wrap :: a -> Wrap a
unWrap :: Wrap a -> a
instance Typeable1 Wrap
instance Typeable3 Sum3
instance Typeable2 Sum2
instance Typeable Void
instance (PprPhysical a, PprPhysical b) => PprPhysical (Sum2 a b)
