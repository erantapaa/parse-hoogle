-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Mutable, doubly linked lists for STM
--   
--   Doubly linked lists are often used in imperative languages to maintain
--   a collection of objects such that an object can remove itself easily.
--   The same idea applies here. Thanks to STM, these lists can be shared
--   among threads with little effort.
--   
--   Suppose you have a thread listening for events. You want to dispatch
--   events to any thread that opts in. You could write a function that
--   installs an event handler, performs an action, and removes the
--   handler:
--   
--   <pre>
--   withEventHandler list handler action =
--       bracket (atomically $ LinkedList.append handler list)
--               (atomically . LinkedList.delete)
--               (\_ -&gt; action)
--   </pre>
--   
--   Then, you could have your listener thread dispatch events using a
--   function like this:
--   
--   <pre>
--   dispatchEvent list event = do
--       handlers &lt;- atomically $ LinkedList.toList list
--       forM_ handlers $ \handler -&gt; handler event
--   </pre>
@package stm-linkedlist
@version 0.1.0.0


-- | Mutable, doubly linked lists for use with STM (software transactional
--   memory). Provides efficient random insertion and removal.
--   
--   This module is usually imported qualified:
--   
--   <pre>
--   import Data.STM.LinkedList (LinkedList)
--   import qualified Data.STM.LinkedList as LinkedList
--   </pre>
module Data.STM.LinkedList

-- | List handle. Used for insertion and traversal starting at the
--   beginning or end of the list.
data LinkedList a

-- | Unwrap the list head, a special <a>Node</a> with the following
--   properties:
--   
--   <ul>
--   <li><pre><a>next</a> . <a>listHead</a> == <a>start</a></pre></li>
--   <li><pre><a>prev</a> . <a>listHead</a> == <a>end</a></pre></li>
--   <li><pre><a>insertBefore</a> v . <a>listHead</a> == <a>append</a>
--   v</pre></li>
--   <li><pre><a>insertAfter</a> v . <a>listHead</a> == <a>prepend</a>
--   v</pre></li>
--   <li><pre><a>value</a> . <a>listHead</a> ==&gt; <i>error</i></pre></li>
--   <li><pre><a>delete</a> . <a>listHead</a> ==&gt;
--   <i>error</i></pre></li>
--   </ul>
listHead :: LinkedList a -> Node a

-- | List node. Used for insertion, traversal, and removal starting at a
--   given item in the list.
--   
--   A Node contains an immutable value of type <tt>a</tt>, and
--   <a>TVar</a>s that point to the previous and next nodes.
--   
--   Node equality can be likened to pointer equality in C. Two Node values
--   are considered equal if and only if they were created with the same
--   insertion operation.
data Node a

-- | Extract the value of a node.
value :: Node a -> a

-- | <i>O(1)</i>. Is the list empty?
null :: LinkedList a -> STM Bool

-- | <i>O(n)</i>. Count the number of items in the list.
length :: LinkedList a -> STM Int

-- | <i>O(1)</i>. Create an empty linked list.
empty :: STM (LinkedList a)

-- | <i>O(1)</i>. Version of <a>empty</a> that can be used in the <a>IO</a>
--   monad.
emptyIO :: IO (LinkedList a)

-- | <i>O(1)</i>. Add a node to the beginning of a linked list.
prepend :: a -> LinkedList a -> STM (Node a)

-- | <i>O(1)</i>. Add a node to the end of a linked list.
append :: a -> LinkedList a -> STM (Node a)

-- | <i>O(1)</i>. Insert an item before the given node.
insertBefore :: a -> Node a -> STM (Node a)

-- | <i>O(1)</i>. Insert an item after the given node.
insertAfter :: a -> Node a -> STM (Node a)

-- | <i>O(1)</i>. Remove a node from whatever <a>LinkedList</a> it is in.
--   If the node has already been removed, this is a no-op.
delete :: Node a -> STM ()

-- | <i>O(1)</i>. Get the previous node. Return <a>Nothing</a> if this is
--   the first item, or if this node has been <a>delete</a>d from its list.
prev :: Node a -> STM (Maybe (Node a))

-- | <i>O(1)</i>. Get the next node. Return <a>Nothing</a> if this is the
--   last item, or if this node has been <a>delete</a>d from its list.
next :: Node a -> STM (Maybe (Node a))

-- | <i>O(1)</i>. Get the node corresponding to the first item of the list.
--   Return <a>Nothing</a> if the list is empty.
start :: LinkedList a -> STM (Maybe (Node a))

-- | <i>O(1)</i>. Get the node corresponding to the last item of the list.
--   Return <a>Nothing</a> if the list is empty.
end :: LinkedList a -> STM (Maybe (Node a))

-- | <i>O(n)</i>. Return all of the items in a <a>LinkedList</a>.
toList :: LinkedList a -> STM [a]

-- | <i>O(n)</i>. Return all of the items in a <a>LinkedList</a>, in
--   reverse order.
toListRev :: LinkedList a -> STM [a]
