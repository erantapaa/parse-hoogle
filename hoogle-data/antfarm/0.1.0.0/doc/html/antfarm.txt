-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Referring expressions for definitions
--   
--   Referring expressions for definitions
@package antfarm
@version 0.1.0.0


-- | Cardinality constraints
module NLP.Antfarm.Cardinality
data Constraint
AtMost :: Int -> Constraint
Exactly :: Int -> Constraint
AtLeast :: Int -> Constraint
Unknown :: Text -> Constraint
lowerBound :: Constraint -> Maybe Int
upperBound :: Constraint -> Maybe Int
unknown :: Constraint -> Maybe Text
instance Show Constraint
instance Eq Constraint
instance Ord Constraint

module NLP.Antfarm.Refex

-- | Input needed to realise a subunit of a referring expression A subunit
--   corresponds to <a>RefGroup</a> (but in practice, we need the whole
--   <a>DiscourseUnit</a>, not just the <a>RefGroup</a> root)
data SubRxInput
SubRxInput :: SingPlu [Text] -> SingPlu Text -> DiscourseUnit -> SubRxInput

-- | determiner (can be empty)
srxInpDet :: SubRxInput -> SingPlu [Text]

-- | main word
srxInpWord :: SubRxInput -> SingPlu Text
srxInpEntity :: SubRxInput -> DiscourseUnit

-- | Output for a subunit of a referring expression
data SubRx
SubRx :: Number -> Discriminator -> SingPlu [Text] -> SingPlu Text -> SubRx
srxNumber :: SubRx -> Number
srxDiscriminator :: SubRx -> Discriminator
srxDet :: SubRx -> SingPlu [Text]
srxWord :: SubRx -> SingPlu Text

-- | A single referring expression has subunits, each of which potentially
--   having examples
type RxInput = [Tree SubRxInput]

-- | A referring expression
type Rx = [Tree SubRx]

-- | A discourse unit includes all instances and constraints needed to
--   uniquely identify it. (see note discourse tree)
--   
--   In the current implementation, a referring expression may contain more
--   than one discourse unit. So in a referring expression “three cats and
--   at most two dogs (a poodle and a labrador)”, the “at most two dogs (a
--   poodle and a labrador)” and “three cats” would each correspond to
--   different <a>DiscourseUnit</a>s
type DiscourseUnit = Tree RefGroup

-- | A sub-unit in a referring expression, instances of and/or constraints
--   over class. So in a referring expression “three cats and at most two
--   dogs”, the “at most two dogs” and “three cats” would each be
--   <a>RefGroup</a>s
data RefGroup
RefGroup :: Text -> Set Text -> Bounds -> RefGroup
rgClass :: RefGroup -> Text
rgIdxes :: RefGroup -> Set Text
rgBounds :: RefGroup -> Bounds
rgIdxList :: RefGroup -> [Text]

-- | A unique object
type RefKey = (Text, Text)
data Bounds
Bounds :: [Text] -> Maybe Int -> Maybe Int -> Bounds
bUnknown :: Bounds -> [Text]

-- | lower
bLower :: Bounds -> Maybe Int

-- | upper
bUpper :: Bounds -> Maybe Int
emptyBounds :: Bounds
explicitBounds :: [Constraint] -> Bounds

-- | When two <a>Bounds</a> are combined the result is narrower: the
--   highest low and the lowest high.
--   
--   The unknown bounds are not really defined. We concatenate them, for
--   what it's worth, which is at least sensible when none or only one of
--   them is defined, but not ideal when both are
narrow :: Bounds -> Bounds -> Bounds

-- | Fuzzy number is a variant on <a>Number</a> that allows us the option
--   of overriding what would otherwise be singular agreement
--   
--   If you don't need to, or have no idea why somebody would even want to
--   do such a thing, just <a>defuzz</a> it
data FuzzyNumber
FN_Plural :: FuzzyNumber
FN_MaybeSingular :: FuzzyNumber
FN_Singular :: FuzzyNumber

-- | <tt>defuzz</tt> treats <a>FN_MaybeSingular</a> as <a>Singular</a>
defuzz :: FuzzyNumber -> Number

-- | Somewhat abstract representation of subrx discriminators (but in
--   reality just based on English)
--   
--   A discriminator is what we call the optional bit of text that helps
--   you distinguish one set instances of a class from another, eg, “the
--   same” or “another three”, or simply “the“. This isn't a technical term
--   as far as I'm aware, just a made-up convenience word
data Discriminator
NilDiscriminator :: Discriminator
Bounded :: BoundsExpr -> Discriminator
TheSame :: Discriminator
TheOther :: Discriminator
TheOrdinal :: Int -> Discriminator
NewOrdinal :: Int -> Discriminator
Another :: Int -> Discriminator
PlainCardinal :: Int -> Discriminator
CardinalOfThe :: Int -> Discriminator
The :: Discriminator
data BoundsExpr
SayAtLeast :: Int -> BoundsExpr
SayAtMost :: Int -> BoundsExpr
SayBetween :: Int -> Int -> BoundsExpr
SayExactly :: Int -> BoundsExpr
SayArbitrary :: Text -> BoundsExpr
instance Ord Bounds
instance Eq Bounds
instance Ord RefGroup
instance Eq RefGroup
instance Eq FuzzyNumber
instance Show FuzzyNumber
instance Eq BoundsExpr
instance Show BoundsExpr
instance Eq Discriminator
instance Show Discriminator
instance Eq SubRx
instance Show SubRx


-- | Functions to realise antfarm output in English.
--   
--   We're not under any illusions that antfarm will work well for
--   languages other than English, but it could still be useful to try
--   anyway.
module NLP.Antfarm.English

-- | English realisation for a referring expression
englishRx :: [Tree SubRx] -> Text

-- | English realisation for a referring expression subunit (this can be
--   useful if you need special formatting between units, eg. bullet
--   points)
englishSubrx :: SubRx -> Text
englishDiscriminator :: SingPlu [Text] -> Discriminator -> [Text]


-- | Discourse history tracking
module NLP.Antfarm.History

-- | A <a>RefGroup</a> is considered to refer exactly to its indices if it
--   has no bounds information or examples associated with it.
isExact :: RefGroup -> Bool

-- | A discourse unit that would refer to just an element
mkSingletonDu :: RefKey -> DiscourseUnit
data RefHistory
RefHistory :: Map DiscourseUnit RefCount -> Map Text [Text] -> RefHistory

-- | How many times a <a>DiscourseUnit</a> has been mentioned
rhCount :: RefHistory -> Map DiscourseUnit RefCount

-- | For each class: an ordering of indices that reflects what ordinal
--   expression should be used for them (if at all)
--   
--   So <tt>[c8,c3,c4]</tt> means
--   
--   c8: the first c3: the second c4: the third
rhOrder :: RefHistory -> Map Text [Text]
type RefCount = Int
plusRefCount :: RefCount -> RefCount -> RefCount

-- | Discourse history without any objects
emptyHistory :: RefHistory

-- | Take note of the fact that these discourse units have been mentioned
--   (again) in the history.
--   
--   You probably want to realise the units first, then add them to the
--   history.
addToHistory :: [DiscourseUnit] -> RefHistory -> RefHistory

-- | Individuals mentioned in a discourse unit (see <a>refSingleton</a>)
duSingletons :: DiscourseUnit -> [RefKey]

-- | A <a>refSingleton</a> is an instance that appears by itself in a
--   <a>RefGroup</a> without other items or constraints that imply that
--   there could be other items
refSingleton :: RefGroup -> Maybe RefKey

-- | If a RefGroup has explicit constraints, augment them with the implicit
--   constraints that arise from treating each item as evidence of an at
--   least constraint
--   
--   It's a good idea to run this once when building <a>RefGroup</a>s, but
--   you may also decide that this sort of behaviour is not desirable for
--   your application, so it's off by default
noteImplicitBounds :: RefGroup -> RefGroup

-- | <tt>hasDistractorGroup st k</tt> returns whether or not the discourse
--   history <tt>st</tt> contains a group with distractors to <tt>k</tt>.
--   
--   See <a>distractorGroups</a> for more details
hasDistractorGroup :: RefHistory -> RefKey -> Bool

-- | <tt>distractorGroups st k</tt> returns all the distractor groups for
--   <tt>k</tt> in the discourse history.
--   
--   A distractor is defined (here) as something that has the the same
--   class as <tt>k</tt> but a different index.
distractorGroups :: RefHistory -> RefKey -> [DiscourseUnit]

-- | <tt>hasSupersetMention st g</tt> returns whether or not the discourse
--   history contains a group that includes all members of <tt>g</tt>
--   
--   Note that if a group has already occured in the discourse history,
--   this returns a True (ie. not a strict superset)
hasSupersetMention :: RefHistory -> DiscourseUnit -> Bool

-- | <tt>supersetMentions g st</tt> returns the portion of discourse
--   history <tt>st</tt> in which all groups are supersets of <tt>g</tt>
--   (inclusive, not strict super)
supersetMentions :: DiscourseUnit -> RefHistory -> RefHistory

-- | <tt>lastMention st k</tt> returns the number of times <tt>k</tt> has
--   been mentioned
lastMention :: RefHistory -> RefKey -> Int

-- | <tt>lastMention st g</tt> returns the number of times the group
--   <tt>g</tt> has been mentioned
lastMentions :: RefHistory -> DiscourseUnit -> Int
isFirstMention :: RefHistory -> RefKey -> Bool

-- | If it makes sense to refer to a key using an ordinal expression, the
--   order we should assign it (Nothing if we either can't sensibly assign
--   one, or the history does not give us enough information to do so)
mentionOrder :: RefHistory -> RefKey -> Maybe Int

-- | Is a subset of a previously mentioned group <tt>g</tt> where there are
--   no distractors to <tt>g</tt> in the discourse history
hasTidyBackpointer :: RefHistory -> DiscourseUnit -> Bool

-- | <tt>isTheOther st k</tt> returns whether or not there is a two-member
--   group in the discourse history which <tt>k</tt> is a member of such
--   that the other member has already been mentioned as a part of a
--   singleton group.
--   
--   The idea is that if you have said <a>one of the X</a>, you will want
--   to say <a>the other X</a> for the other member of that group
isTheOther :: RefHistory -> RefKey -> Bool

-- | Is the class itself, not any individual entity within that class ie.
--   “ants” instead of “an ant” or “some ants”
--   
--   By convention, any group which containts no indices or constraints is
--   considered to be classwide.
isClasswide :: RefGroup -> Bool

-- | Like <a>flatten</a>, but returns whole subtrees instead of just nodes:
--   
--   <pre>
--   a(b c(d e(f g)) h)
--   b
--   c(d e(f g))
--   d
--   e(f g)
--   f
--   g
--   h
--   </pre>
--   
--   Invariant: <tt>map rootLabel (subtrees x) == flatten x</tt>
subtrees :: Tree a -> [Tree a]
mkLeaf :: a -> Tree a
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c
instance Ord (Tree RefGroup)


-- | The heart of the referring expression generation
module NLP.Antfarm.Internal

-- | Decide how to realise a referring expression
rx :: RefHistory -> [Tree SubRxInput] -> [Tree SubRx]

-- | Decide how to realise a single unit within a referring expression
--   
--   Keep in mind that this is only for one <a>DiscourseUnit</a> within a
--   single rx. An rx may involve multiple discourse units (eg. 3 cats and
--   1 dog)
subrx :: RefHistory -> Tree SubRxInput -> Tree SubRx

-- | Helper for <tt>fromConcept</tt>
--   
--   Whether the noun in a <a>DiscourseUnit</a> should be realised as
--   singular or plural. Note the difference between this and
--   <tt>actualNumber</tt>
surfaceNumber :: RefHistory -> DiscourseUnit -> Number

-- | Whether a <a>DiscourseUnit</a> should be considered *morally*
--   (semantically) singular or plural. The actual form used may be
--   different (see <tt>conceptNumber</tt> because of deeper issues that
--   override this).
--   
--   Consider one of the *dogs*; here the rx number is <a>Singular</a> —
--   one dog — but on the surface we use the <a>Plural</a> (the NP 'the
--   dogs' is itself plural). This discrepency is partly due to the hacky
--   way we've written this. A cleaner implementation would recursively
--   realise 'the dogs' as a separate expression with its own number.
subrxNumber :: DiscourseUnit -> FuzzyNumber

-- | Helper for <tt>fromConcept</tt>
--   
--   A discriminator is what we call the optional bit of text that helps
--   you distinguish one set instances of a class from another, eg, “the
--   same” or “another three”, or simply “the“
discriminate :: RefHistory -> DiscourseUnit -> Discriminator

-- | If there are any unknown constraints, we pick the first one.
--   Otherwise, we generate an expression appropriate for the lower/upper
--   bounds
boundsText :: Bounds -> Maybe BoundsExpr


-- | Referring expression generation for definitions.
module NLP.Antfarm
data RefHistory
RefHistory :: Map DiscourseUnit RefCount -> Map Text [Text] -> RefHistory

-- | How many times a <a>DiscourseUnit</a> has been mentioned
rhCount :: RefHistory -> Map DiscourseUnit RefCount

-- | For each class: an ordering of indices that reflects what ordinal
--   expression should be used for them (if at all)
--   
--   So <tt>[c8,c3,c4]</tt> means
--   
--   c8: the first c3: the second c4: the third
rhOrder :: RefHistory -> Map Text [Text]

-- | Take note of the fact that these discourse units have been mentioned
--   (again) in the history.
--   
--   You probably want to realise the units first, then add them to the
--   history.
addToHistory :: [DiscourseUnit] -> RefHistory -> RefHistory

-- | Discourse history without any objects
emptyHistory :: RefHistory

-- | If a RefGroup has explicit constraints, augment them with the implicit
--   constraints that arise from treating each item as evidence of an at
--   least constraint
--   
--   It's a good idea to run this once when building <a>RefGroup</a>s, but
--   you may also decide that this sort of behaviour is not desirable for
--   your application, so it's off by default
noteImplicitBounds :: RefGroup -> RefGroup

-- | Decide how to realise a referring expression
rx :: RefHistory -> [Tree SubRxInput] -> [Tree SubRx]

-- | Decide how to realise a single unit within a referring expression
--   
--   Keep in mind that this is only for one <a>DiscourseUnit</a> within a
--   single rx. An rx may involve multiple discourse units (eg. 3 cats and
--   1 dog)
subrx :: RefHistory -> Tree SubRxInput -> Tree SubRx

-- | Whether a <a>DiscourseUnit</a> should be considered *morally*
--   (semantically) singular or plural. The actual form used may be
--   different (see <tt>conceptNumber</tt> because of deeper issues that
--   override this).
--   
--   Consider one of the *dogs*; here the rx number is <a>Singular</a> —
--   one dog — but on the surface we use the <a>Plural</a> (the NP 'the
--   dogs' is itself plural). This discrepency is partly due to the hacky
--   way we've written this. A cleaner implementation would recursively
--   realise 'the dogs' as a separate expression with its own number.
subrxNumber :: DiscourseUnit -> FuzzyNumber

-- | English realisation for a referring expression
englishRx :: [Tree SubRx] -> Text

-- | English realisation for a referring expression subunit (this can be
--   useful if you need special formatting between units, eg. bullet
--   points)
englishSubrx :: SubRx -> Text


-- | Helper functions for the antfarm demonstrator. You probably don't want
--   to import this module unless you're doing something amusing like
--   making a web app out of the antfarm demonstrator. But it could be
--   useful to look at the source if you're making something using antfarm
module NLP.Antfarm.Demo
decode :: String -> Either ParseError [[DiscourseUnit]]
decodeRx :: String -> Either ParseError [DiscourseUnit]
type RefStateT m a = StateT RefHistory m a
type RefState a = RefStateT Identity a
nextRx :: Monad m => [DiscourseUnit] -> RefStateT m Text
itemToClass :: Text -> Text
isClassWide :: Text -> Bool
stripNonClassStuff :: Text -> Text
lexMap :: [(Text, Text)]
onWords :: (Text -> Maybe Text) -> Text -> Text
intercalateRx :: [Text] -> Text
data DemoElem
DemoElem :: Text -> Constr -> DemoElem
dClass :: DemoElem -> Text
dConstr :: DemoElem -> Constr
data Constr
Constr :: Constraint -> Constr
Inst :: Text -> Constr
ClassWide :: Constr
fromDemoElem :: DemoElem -> RefGroup
mergeGroups :: [RefGroup] -> RefGroup

-- | Regroup constraints and examples so that like are with like
--   
--   <pre>
--   a1 b3 a4
--     ==&gt; [a1 a4] [b3]
--   a1 b3 a4 (x &lt;= 3) b6
--     ==&gt; [a1 a4]([x &lt;= 3]) [b3 b6]
--   a1 b3 a4 (x &lt;= 3) b6 (y &gt;= 8) a &lt;= 1 (x &gt;= 8)
--     ==&gt; [a1 a4]([x &lt;= 3 &gt;= 8]) [b3 b6]([y&gt;=8])
--   </pre>
fromDemoForest :: [Tree DemoElem] -> [DiscourseUnit]
toSubRxInput :: DiscourseUnit -> Tree SubRxInput
pFilled :: Parser a -> Parser a
pSentence :: Parser [[Tree DemoElem]]
pDemoElemForest :: Parser [Tree DemoElem]
pDemoElemTree :: Parser (Tree DemoElem)
pDemoElem :: Parser DemoElem
pConstr :: Parser Constraint
opTable :: [(Int -> Constraint, [Text])]
pLexeme :: Parser Text
pOp :: Parser Text
pNatural :: Parser Int
class Pretty a
pretty :: Pretty a => a -> Text
parens :: Text -> Text
squares :: Text -> Text
prettyForest :: Pretty a => [Tree a] -> Text
prettyTree :: Pretty a => Tree a -> Text
buckets :: Ord b => (a -> b) -> [a] -> [(b, [a])]
onSubTrees :: (Tree a -> b) -> Tree a -> Tree b
instance Show Constr
instance Show DemoElem
instance Pretty Int
instance Pretty Text
instance Pretty Bounds
instance Pretty RefGroup
