-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Various tools to detect/correct mistakes in words
--   
--   Haskell library meant to be a set of tools to correct spelling
--   mistakes, homophones, and OCR errors.
--   
--   Sample session:
--   
--   <pre>
--   ghci&gt; :m + Language.Distance.Search.BK
--   ghci&gt; distance "foo" "bar" :: Distance DamerauLevenshtein
--   3
--   ghci&gt; let bk = foldr insert empty ["foo", "foa", "fooa", "ofo", "arstu", "nana", "faa"] :: BKTree String <a>DamerauLevenshtein</a>
--   ghci&gt; query 0 "foo" bk
--   [("foo",Distance 0)]
--   ghci&gt; query 2 "foo" bk
--   [("faa",Distance 2),("foa",Distance 1),("fooa",Distance 1),("foo",Distance 0),("ofo",Distance 1)]
--   </pre>
--   
--   TODO:
--   
--   <ul>
--   <li>Phonetic algorithms: metaphone, double metaphone, maybe
--   others</li>
--   <li>Tests and better benchmarking</li>
--   <li>Cost tuning when searching</li>
--   </ul>
@package language-spelling
@version 0.3.2


-- | See the documentation for <a>Internal</a> to see why this module is
--   potentially dangerous.
module Language.Phonetic.Internal

-- | A wrapped <a>ByteString</a>.
newtype Code enc
Code :: ByteString -> Code enc
getCode :: Code enc -> ByteString

-- | A wrapped <a>Set</a> <a>Char</a>.
newtype Alphabet enc
Alphabet :: Set Char -> Alphabet enc
getAlphabet :: Alphabet enc -> Set Char
instance Eq (Code enc)
instance Show (Code enc)
instance Eq (Alphabet enc)
instance Show (Alphabet enc)


-- | "A phonetic algorithm is an algorithm for indexing of words by their
--   pronunciation":
--   <a>https://en.wikipedia.org/wiki/Phonetic_algorithm</a>.
--   
--   Right now only a very rudimental one is provided, <a>Soundex</a>; plus
--   <a>Encoder</a>, a generic interface.
module Language.Phonetic

-- | A wrapped <a>ByteString</a>.
data Code enc

-- | A wrapped <a>Set</a> <a>Char</a>.
data Alphabet enc

-- | Type class for algorithms that encode words based on their
--   pronunciation.
--   
--   Minimal definition: <a>alphabet</a>, <a>encodeUnsafe</a>.
class Encoder enc where encode ll | all (flip member alph) ll = Just (encodeUnsafe ll) | otherwise = Nothing where alph = getAlphabet (alphabet :: Alphabet enc)
alphabet :: Encoder enc => Alphabet enc
encodeUnsafe :: (Encoder enc, ListLike full Char) => full -> Code enc
encode :: (Encoder enc, ListLike full Char) => full -> Maybe (Code enc)

-- | See <a>https://en.wikipedia.org/wiki/Soundex</a> for more info.
data Soundex


-- | This module lets you tamper with <a>Distance</a> - in other words you
--   can give it whatever phantom type since the constructor is exported.
--   
--   The only use for this module is to construct new <a>Distance</a> data
--   when writing <tt>EditDistance</tt> instances, but be careful not to
--   change the phantom type of existing <a>Distance</a>s!
module Language.Distance.Internal
newtype Distance algo
Distance :: Int -> Distance algo
getDistance :: Distance algo -> Int
instance Eq (Distance algo)
instance Ord (Distance algo)
instance Show (Distance algo)


-- | Generic interface to calculate the edit instance between two list-like
--   things using various algorithms.
--   
--   Right now, two algorithms are provided, <a>Levenshtein</a> and
--   <a>DamerauLevenshtein</a>.
module Language.Distance
data Distance algo
getDistance :: Distance algo -> Int

-- | Generic typeclass for edit distances. Specify the type manually to use
--   a specific algorithm, for instance
--   
--   <pre>
--   distance "foo" "bar" :: <a>Distance</a> <a>DamerauLevenshtein</a>
--   </pre>
--   
--   Monomorphic functions are also provided, see <a>levenshtein</a> and
--   <a>damerauLevenshtein</a>.
class EditDistance sym algo
distance :: (EditDistance sym algo, ListLike full sym) => full -> full -> Distance algo

-- | The classic Levenshtein distance, where adding, removing or changing a
--   character are taken into account.
--   
--   More information:
--   <a>https://en.wikipedia.org/wiki/Levenshtein_distance</a>.
data Levenshtein
levenshtein :: (ListLike full sym, Eq sym) => full -> full -> Distance Levenshtein

-- | Like <a>Levenshtein</a>, but transpositions are also taken into
--   account:
--   <a>https://en.wikipedia.org/wiki/Damerau-Levenshtein_distance</a>.
data DamerauLevenshtein
damerauLevenshtein :: (ListLike full sym, Ord sym) => full -> full -> Distance DamerauLevenshtein
instance Ord sym => EditDistance sym DamerauLevenshtein
instance Eq sym => EditDistance sym Levenshtein


-- | An implementation of <a>Search</a> based on a BK-tree:
--   <a>https://en.wikipedia.org/wiki/Bk-tree</a>. It performs reasonably,
--   and it scales decently as the query distance increases. Moreover the
--   data structure can work on any instance of <a>EditDistance</a>, or in
--   fact any metric space - a generic interface is provided in
--   <a>BKTree</a>.
--   
--   However, for very short distances (less than 3), <a>TST</a> is faster.
module Language.Distance.Search.BK
data BKTree full algo
empty :: (EditDistance sym algo, ListLike full sym) => BKTree full algo
insert :: (EditDistance sym algo, ListLike full sym) => full -> BKTree full algo -> BKTree full algo
query :: (ListLike full sym, EditDistance sym algo) => Int -> full -> BKTree full algo -> [(full, Distance algo)]
levenshtein :: (ListLike full sym, EditDistance sym Levenshtein) => Int -> full -> BKTree full Levenshtein -> [(full, Distance Levenshtein)]
damerauLevenshtein :: (ListLike full sym, EditDistance sym DamerauLevenshtein) => Int -> full -> BKTree full DamerauLevenshtein -> [(full, Distance DamerauLevenshtein)]


-- | An implementation of <tt>Search</tt> based on a ternary search tree
--   (<a>TSTSet</a>):
--   <a>https://en.wikipedia.org/wiki/Ternary_search_tree</a>.
--   
--   The searches are performed by manually generating the close word by
--   deleting, transposing, or adding wildcards to match additional
--   characters.
--   
--   This makes this structure fast for small distances with a small number
--   of generated candidates, but impractical for even slightly larger
--   distances - in my tests <a>BK</a> outpeforms this module when the
--   distance is greater than 2.
--   
--   The data structure has no knowledge of the distance and thus it does
--   not need to be rebuilt if different edit distances are needed. However
--   this means that it cannot work with arbitrary <tt>EditDistance</tt>
--   instances are functions need to be defined manually to generate the
--   candidates. In this case <a>levenshtein</a> uses <a>deletions</a>,
--   <a>replaces</a>, and <a>insertions</a> to generate the candidates;
--   while <a>damerauLevenshtein</a> also uses <a>transpositions</a>.
module Language.Distance.Search.TST
data TSTSet sym :: * -> *
empty :: Ord sym => TSTSet sym
insert :: (Ord sym, ListLike full sym) => full -> TSTSet sym -> TSTSet sym
levenshtein :: (Ord sym, ListLike full sym) => Int -> full -> TSTSet sym -> [(full, Distance Levenshtein)]
damerauLevenshtein :: (Ord sym, ListLike full sym) => Int -> full -> TSTSet sym -> [(full, Distance DamerauLevenshtein)]
data WildCard a :: * -> *
WildCard :: WildCard a
El :: a -> WildCard a
type WildList a = [WildCard a]
deletions :: [a] -> [[a]]
transpositions :: [a] -> [[a]]
replaces :: WildList a -> [WildList a]
insertions :: WildList a -> [WildList a]


-- | The <a>Search</a> typeclass lets you build dictinaries and then query
--   them to find words close to a given one.
--   
--   Right now two data types are provided: <a>TST</a> and <a>BK</a>,
--   monomorphic functions are provided as well. The difference is in
--   performance: <a>TST</a> is faster for low distances (less than 3) but
--   impractical for larger ones, where <a>BK</a> is more suited. See the
--   specific modules for more info.
module Language.Distance.Search

-- | Generic class for data structures that can perform queries retrieving
--   words close to a given one.
--   
--   Minimal definition: <a>empty</a>, <a>insert</a>, and <a>query</a>.
class Search container full algo | container -> full, container -> algo where singleton str = insert str empty member x = not . null . query 0 x fromList = foldr insert empty
empty :: Search container full algo => container
insert :: Search container full algo => full -> container -> container
query :: Search container full algo => Int -> full -> container -> [(full, Distance algo)]
singleton :: Search container full algo => full -> container
member :: Search container full algo => full -> container -> Bool
fromList :: Search container full algo => [full] -> container

-- | We need to wrap <a>TSTSet</a> in a newtype because we need the
--   algorithm and the container have to depend on the type.
newtype TSTDist full sym algo
TSTDist :: TSTSet sym -> TSTDist full sym algo
getTST :: TSTDist full sym algo -> TSTSet sym

-- | Again, wrapping <a>BKTree</a> to have the phantom types in place.
newtype BKDist full sym algo
BKDist :: BKTree full algo -> BKDist full sym algo
getBK :: BKDist full sym algo -> BKTree full algo
instance (Eq sym, ListLike full sym, EditDistance sym algo) => Search (BKDist full sym algo) full algo
instance (Ord sym, ListLike full sym, EditDistance sym DamerauLevenshtein) => Search (TSTDist full sym DamerauLevenshtein) full DamerauLevenshtein
instance (Ord sym, ListLike full sym, EditDistance sym Levenshtein) => Search (TSTDist full sym Levenshtein) full Levenshtein
