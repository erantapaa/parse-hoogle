-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Binding to the GLIB library for Gtk2Hs.
--   
@package glib
@version 0.13.1.0


-- | Attributes interface
--   
--   Attributes of an object can be get and set. Getting the value of an
--   object's attribute is straingtforward. As an example consider a
--   <tt>button</tt> widget and an attribute called <tt>buttonLabel</tt>.
--   
--   <pre>
--   value &lt;- get button buttonLabel
--   </pre>
--   
--   The syntax for setting or updating an attribute is only slightly more
--   complex. At the simplest level it is just:
--   
--   <pre>
--   set button [ buttonLabel := value ]
--   </pre>
--   
--   However as the list notation would indicate, you can set or update
--   multiple attributes of the same object in one go:
--   
--   <pre>
--   set button [ buttonLabel := value, buttonFocusOnClick := False ]
--   </pre>
--   
--   You are not limited to setting the value of an attribute, you can also
--   apply an update function to an attribute's value. That is the function
--   receives the current value of the attribute and returns the new value.
--   
--   <pre>
--   set spinButton [ spinButtonValue :~ (+1) ]
--   </pre>
--   
--   There are other variants of these operators, (see <a>AttrOp</a>).
--   <a>:=&gt;</a> and <a>:~&gt;</a> and like <a>:=</a> and <a>:~</a> but
--   operate in the <a>IO</a> monad rather than being pure. There is also
--   <a>::=</a> and <a>::~</a> which take the object as an extra parameter.
--   
--   Attributes can be read only, write only or both read/write.
module System.Glib.Attributes

-- | An ordinary attribute. Most attributes have the same get and set
--   types.
type Attr o a = ReadWriteAttr o a a

-- | A read-only attribute.
type ReadAttr o a = ReadWriteAttr o a ()

-- | A write-only attribute.
type WriteAttr o b = ReadWriteAttr o () b

-- | A generalised attribute with independent get and set types.
data ReadWriteAttr o a b

-- | A set or update operation on an attribute.
data AttrOp o

-- | Assign a value to an attribute.
(:=) :: ReadWriteAttr o a b -> b -> AttrOp o

-- | Apply an update function to an attribute.
(:~) :: ReadWriteAttr o a b -> (a -> b) -> AttrOp o

-- | Assign the result of an IO action to an attribute.
(:=>) :: ReadWriteAttr o a b -> (IO b) -> AttrOp o

-- | Apply a IO update function to an attribute.
(:~>) :: ReadWriteAttr o a b -> (a -> IO b) -> AttrOp o

-- | Assign a value to an attribute with the object as an argument.
(::=) :: ReadWriteAttr o a b -> (o -> b) -> AttrOp o

-- | Apply an update function to an attribute with the object as an
--   argument.
(::~) :: ReadWriteAttr o a b -> (o -> a -> b) -> AttrOp o

-- | Get an Attr of an object.
get :: o -> ReadWriteAttr o a b -> IO a

-- | Set a number of properties for some object.
set :: o -> [AttrOp o] -> IO ()

-- | Create a new attribute with a getter and setter function.
newNamedAttr :: String -> (o -> IO a) -> (o -> b -> IO ()) -> ReadWriteAttr o a b

-- | Create a new read-only attribute.
readNamedAttr :: String -> (o -> IO a) -> ReadAttr o a

-- | Create a new write-only attribute.
writeNamedAttr :: String -> (o -> b -> IO ()) -> WriteAttr o b

-- | Create a new attribute with a getter and setter function.
newAttr :: (o -> IO a) -> (o -> b -> IO ()) -> ReadWriteAttr o a b

-- | Create a new read-only attribute.
readAttr :: (o -> IO a) -> ReadAttr o a

-- | Create a new write-only attribute.
writeAttr :: (o -> b -> IO ()) -> WriteAttr o b
instance Show (ReadWriteAttr o a b)


-- | This module defines a type class for flags that are marshaled as
--   bitflags.
module System.Glib.Flags
class (Enum a, Bounded a) => Flags a
fromFlags :: Flags a => [a] -> Int
toFlags :: Flags a => Int -> [a]


-- | Defines functions to extract data from a GString.
module System.Glib.GString
type GString = Ptr (())
readGString :: GString -> IO (Maybe String)
readGStringByteString :: GString -> IO (Maybe ByteString)
fromGString :: GString -> IO (Maybe String)


-- | Defines functions to extract data from a GList and to produce a GList
--   from a list of pointers.
--   
--   <ul>
--   <li>The same for GSList.</li>
--   </ul>
module System.Glib.GList
type GList = Ptr (())
readGList :: GList -> IO [Ptr a]
fromGList :: GList -> IO [Ptr a]
toGList :: [Ptr a] -> IO GList
withGList :: [Ptr a] -> (GSList -> IO b) -> IO b
type GSList = Ptr (())
readGSList :: GSList -> IO [Ptr a]
fromGSList :: GSList -> IO [Ptr a]
fromGSListRev :: GSList -> IO [Ptr a]
toGSList :: [Ptr a] -> IO GSList
withGSList :: [Ptr a] -> (GSList -> IO b) -> IO b


-- | This module implements only the necessities for the GTK binding.
module System.Glib.GType
type GType = CULong

-- | Check if an object is of the specific type or derived from it.
--   
--   <ul>
--   <li>Internally used by Hierarchy.</li>
--   </ul>
typeInstanceIsA :: Ptr () -> GType -> Bool

-- | Prior to any use of the glib type/object system, <tt>glibTypeInit</tt>
--   has to be called to initialise the system.
--   
--   Note that this is not needed for gtk applications using
--   <tt>initGUI</tt> since that initialises everything itself. It is only
--   needed for applications using glib directly, without also using gtk.
glibTypeInit :: IO ()


-- | This module implements only the necessities for the GTK binding.
--   
--   <ul>
--   <li>Everything here is only used by
--   <a>Graphics.UI.Gtk.TreeList.TreeModel</a> and friends.</li>
--   </ul>
module System.Glib.GValue
newtype GValue
GValue :: (Ptr (GValue)) -> GValue

-- | Clear a GValue.
valueInit :: GValue -> GType -> IO ()

-- | Get the type of the value stored in the GValue
valueGetType :: GValue -> IO GType

-- | Temporarily allocate a GValue.
allocaGValue :: (GValue -> IO b) -> IO b


-- | Storable instance for GParameter, used by objectNew
module System.Glib.GParameter
newtype GParameter
GParameter :: (String, GValue) -> GParameter
instance Storable GParameter


module System.Glib.GTypeConstants
invalid :: GType
none :: GType
uint :: GType
int :: GType
uint64 :: GType
int64 :: GType
uchar :: GType
char :: GType
bool :: GType
enum :: GType
flags :: GType
pointer :: GType
float :: GType
double :: GType
string :: GType
object :: GType
boxed :: GType


-- | This module adds CString-like functions that handle UTF8 strings.
module System.Glib.UTFString
class (IsString s, Monoid s, Show s) => GlibString s
withUTFString :: GlibString s => s -> (CString -> IO a) -> IO a
withUTFStringLen :: GlibString s => s -> (CStringLen -> IO a) -> IO a
peekUTFString :: GlibString s => CString -> IO s
maybePeekUTFString :: GlibString s => CString -> IO (Maybe s)
peekUTFStringLen :: GlibString s => CStringLen -> IO s
newUTFString :: GlibString s => s -> IO CString
newUTFStringLen :: GlibString s => s -> IO CStringLen
genUTFOfs :: GlibString s => s -> UTFCorrection
stringLength :: GlibString s => s -> Int
unPrintf :: GlibString s => s -> s

-- | Like like <a>peekUTFString</a> but then frees the string using g_free
readUTFString :: GlibString s => CString -> IO s

-- | Like <a>peekCString</a> but then frees the string using
--   <tt>g_free</tt>.
readCString :: CString -> IO String

-- | Temporarily allocate a list of UTF-8 <a>CString</a>s.
withUTFStrings :: GlibString s => [s] -> ([CString] -> IO a) -> IO a

-- | Temporarily allocate an array of UTF-8 encoded <a>CString</a>s.
withUTFStringArray :: GlibString s => [s] -> (Ptr CString -> IO a) -> IO a

-- | Temporarily allocate a null-terminated array of UTF-8 encoded
--   <a>CString</a>s.
withUTFStringArray0 :: GlibString s => [s] -> (Ptr CString -> IO a) -> IO a

-- | Convert an array (of the given length) of UTF-8 encoded
--   <a>CString</a>s to a list of Haskell <a>String</a>s.
peekUTFStringArray :: GlibString s => Int -> Ptr CString -> IO [s]

-- | Convert a null-terminated array of UTF-8 encoded <a>CString</a>s to a
--   list of Haskell <a>String</a>s.
peekUTFStringArray0 :: GlibString s => Ptr CString -> IO [s]

-- | Like <a>peekUTFStringArray0</a> but then free the string array
--   including all strings.
--   
--   To be used when functions indicate that their return value should be
--   freed with <tt>g_strfreev</tt>.
readUTFStringArray0 :: GlibString s => Ptr CString -> IO [s]

-- | Offset correction for String to UTF8 mapping.
data UTFCorrection
ofsToUTF :: Int -> UTFCorrection -> Int
ofsFromUTF :: Int -> UTFCorrection -> Int
glibToString :: Text -> String
stringToGlib :: String -> Text
type DefaultGlibString = Text
class fp ~ FilePath => GlibFilePath fp
withUTFFilePath :: GlibFilePath fp => fp -> (CString -> IO a) -> IO a
peekUTFFilePath :: GlibFilePath fp => CString -> IO fp
withUTFFilePaths :: GlibFilePath fp => [fp] -> ([CString] -> IO a) -> IO a
withUTFFilePathArray :: GlibFilePath fp => [fp] -> (Ptr CString -> IO a) -> IO a
withUTFFilePathArray0 :: GlibFilePath fp => [fp] -> (Ptr CString -> IO a) -> IO a
peekUTFFilePathArray0 :: GlibFilePath fp => Ptr CString -> IO [fp]
readUTFFilePathArray0 :: GlibFilePath fp => Ptr CString -> IO [fp]
instance Show UTFCorrection
instance GlibFilePath FilePath
instance GlibString Text
instance GlibString [Char]


-- | The base object type for all glib objects
module System.Glib.GObject
newtype GObject
GObject :: (ForeignPtr (GObject)) -> GObject
class GObjectClass o
toGObject :: GObjectClass o => o -> GObject
unsafeCastGObject :: GObjectClass o => GObject -> o
mkGObject :: (ForeignPtr GObject -> GObject, FinalizerPtr a)
unGObject :: GObject -> ForeignPtr GObject
castToGObject :: GObjectClass obj => obj -> obj

-- | Decrease the reference counter of an object
objectUnref :: FinalizerPtr a

-- | Construct a new object (should rairly be used directly)
objectNew :: GType -> [(String, GValue)] -> IO (Ptr GObject)

-- | Increase the reference counter of an object
objectRef :: GObjectClass obj => Ptr obj -> IO ()

-- | Reference and sink an object.
objectRefSink :: GObjectClass obj => Ptr obj -> IO ()

-- | This function wraps any object that does not derive from Object. It
--   should be used whenever a function returns a pointer to an existing
--   <a>GObject</a> (as opposed to a function that constructs a new
--   object).
--   
--   <ul>
--   <li>The first argument is the contructor of the specific object.</li>
--   </ul>
makeNewGObject :: GObjectClass obj => (ForeignPtr obj -> obj, FinalizerPtr obj) -> IO (Ptr obj) -> IO obj

-- | This function wraps any newly created objects that derives from
--   GInitiallyUnowned also known as objects with "floating-references".
--   The object will be refSink (for glib versions &gt;= 2.10). On
--   non-floating objects, this function behaves exactly the same as
--   "makeNewGObject".
constructNewGObject :: GObjectClass obj => (ForeignPtr obj -> obj, FinalizerPtr obj) -> IO (Ptr obj) -> IO obj

-- | This function wraps any newly created object that does not derived
--   from GInitiallyUnowned (that is a GObject with no floating reference).
--   Since newly created <a>GObject</a>s have a reference count of one,
--   they don't need ref'ing.
wrapNewGObject :: GObjectClass obj => (ForeignPtr obj -> obj, FinalizerPtr obj) -> IO (Ptr obj) -> IO obj

-- | The type constant to check if an instance is of <a>GObject</a> type.
gTypeGObject :: GType

-- | Determine if this is an instance of a particular GTK type
isA :: GObjectClass o => o -> GType -> Bool
type DestroyNotify = FunPtr (((Ptr ()) -> (IO ())))

-- | Many methods in classes derived from GObject take a callback function
--   and a destructor function which is called to free that callback
--   function when it is no longer required. This constants is an address
--   of a functions in C land that will free a function pointer.
destroyFunPtr :: DestroyNotify

-- | The address of a function freeing a <a>StablePtr</a>. See
--   <a>destroyFunPtr</a>.
destroyStablePtr :: DestroyNotify
type Quark = CUInt

-- | Create a unique id based on the given string.
quarkFromString :: GlibString string => string -> IO Quark

-- | Add an attribute to this object.
--   
--   <ul>
--   <li>The function returns a new attribute that can be set or retrieved
--   from any <a>GObject</a>. The attribute is wrapped in a <a>Maybe</a>
--   type to reflect the circumstance when the attribute is not set or if
--   it should be unset.</li>
--   </ul>
objectCreateAttribute :: GObjectClass o => IO (Attr o (Maybe a))

-- | Set the value of an association.
objectSetAttribute :: GObjectClass o => Quark -> o -> Maybe a -> IO ()

-- | Get the value of an association.
--   
--   <ul>
--   <li>Note that this function may crash the Haskell run-time since the
--   returned type can be forced to be anything. See
--   <a>objectCreateAttribute</a> for a safe wrapper around this
--   funciton.</li>
--   </ul>
objectGetAttributeUnsafe :: GObjectClass o => Quark -> o -> IO (Maybe a)


-- | This is used by the implementation of properties and by the
--   <a>TreeModel</a> and related modules.
module System.Glib.GValueTypes
valueSetUInt :: GValue -> Word -> IO ()
valueGetUInt :: GValue -> IO Word
valueSetInt :: GValue -> Int -> IO ()
valueGetInt :: GValue -> IO Int
valueSetUInt64 :: GValue -> Word64 -> IO ()
valueGetUInt64 :: GValue -> IO Word64
valueSetInt64 :: GValue -> Int64 -> IO ()
valueGetInt64 :: GValue -> IO Int64
valueSetBool :: GValue -> Bool -> IO ()
valueGetBool :: GValue -> IO Bool
valueSetPointer :: GValue -> (Ptr ()) -> IO ()
valueGetPointer :: GValue -> IO (Ptr ())
valueSetFloat :: GValue -> Float -> IO ()
valueGetFloat :: GValue -> IO Float
valueSetDouble :: GValue -> Double -> IO ()
valueGetDouble :: GValue -> IO Double
valueSetEnum :: Enum enum => GValue -> enum -> IO ()
valueGetEnum :: Enum enum => GValue -> IO enum
valueSetFlags :: Flags flag => GValue -> [flag] -> IO ()
valueGetFlags :: Flags flag => GValue -> IO [flag]
valueSetString :: GlibString string => GValue -> string -> IO ()
valueGetString :: GlibString string => GValue -> IO string
valueSetMaybeString :: GlibString string => GValue -> Maybe string -> IO ()
valueGetMaybeString :: GlibString string => GValue -> IO (Maybe string)
valueSetFilePath :: GlibFilePath string => GValue -> string -> IO ()
valueGetFilePath :: GlibFilePath string => GValue -> IO string
valueSetMaybeFilePath :: GlibFilePath string => GValue -> Maybe string -> IO ()
valueGetMaybeFilePath :: GlibFilePath string => GValue -> IO (Maybe string)
valueSetBoxed :: (boxed -> (Ptr boxed -> IO ()) -> IO ()) -> GValue -> boxed -> IO ()
valueGetBoxed :: (Ptr boxed -> IO boxed) -> GValue -> IO boxed
valueSetGObject :: GObjectClass gobj => GValue -> gobj -> IO ()
valueGetGObject :: GObjectClass gobj => GValue -> IO gobj
valueSetMaybeGObject :: GObjectClass gobj => GValue -> (Maybe gobj) -> IO ()
valueGetMaybeGObject :: GObjectClass gobj => GValue -> IO (Maybe gobj)


module System.Glib.StoreValue
data TMType
TMinvalid :: TMType
TMuint :: TMType
TMint :: TMType
TMboolean :: TMType
TMenum :: TMType
TMflags :: TMType
TMfloat :: TMType
TMdouble :: TMType
TMstring :: TMType
TMobject :: TMType

-- | A union with information about the currently stored type.
--   
--   <ul>
--   <li>Internally used by <a>Graphics.UI.Gtk.TreeList.TreeModel</a>.</li>
--   </ul>
data GenericValue
GVuint :: Word -> GenericValue
GVint :: Int -> GenericValue
GVboolean :: Bool -> GenericValue
GVenum :: Int -> GenericValue
GVflags :: Int -> GenericValue
GVfloat :: Float -> GenericValue
GVdouble :: Double -> GenericValue
GVstring :: (Maybe Text) -> GenericValue
GVobject :: GObject -> GenericValue
valueSetGenericValue :: GValue -> GenericValue -> IO ()
valueGetGenericValue :: GValue -> IO GenericValue
instance Enum TMType

module System.Glib.Signals
newtype Signal object handler
Signal :: (Bool -> object -> handler -> IO (ConnectId object)) -> Signal object handler

-- | Perform an action in response to a signal.
--   
--   Use it like this:
--   
--   <pre>
--   on obj sig $ do
--   ...
--   </pre>
--   
--   or if the signal handler takes any arguments:
--   
--   <pre>
--   on obj sig $ \args -&gt; do
--   ...
--   </pre>
on :: object -> Signal object callback -> callback -> IO (ConnectId object)

-- | Perform an action in response to a signal.
--   
--   <ul>
--   <li>Like <a>on</a> but the signal is executed after Gtk's default
--   handler has run.</li>
--   </ul>
after :: object -> Signal object callback -> callback -> IO (ConnectId object)
type SignalName = String
type ConnectAfter = Bool

-- | The type of signal handler ids. If you ever need to <a>disconnect</a>
--   a signal handler then you will need to retain the <a>ConnectId</a> you
--   got when you registered it.
data GObjectClass o => ConnectId o
ConnectId :: (CULong) -> o -> ConnectId o

-- | Disconnect a signal handler. After disconnecting the handler will no
--   longer be invoked when the event occurs.
signalDisconnect :: GObjectClass obj => ConnectId obj -> IO ()

-- | Block a specific signal handler.
--   
--   <ul>
--   <li>Blocks a handler of an instance so it will not be called during
--   any signal emissions unless it is unblocked again. Thus "blocking" a
--   signal handler means to temporarily deactive it, a signal handler has
--   to be unblocked exactly the same amount of times it has been blocked
--   before to become active again.</li>
--   </ul>
signalBlock :: GObjectClass obj => ConnectId obj -> IO ()

-- | Unblock a specific signal handler.
--   
--   <ul>
--   <li>Undoes the effect of a previous <a>signalBlock</a> call. A blocked
--   handler is skipped during signal emissions and will not be invoked,
--   unblocking it (for exactly the amount of times it has been blocked
--   before) reverts its "blocked" state, so the handler will be recognized
--   by the signal system and is called upon future or currently ongoing
--   signal emissions (since the order in which handlers are called during
--   signal emissions is deterministic, whether the unblocked handler in
--   question is called as part of a currently ongoing emission depends on
--   how far that emission has proceeded yet).</li>
--   </ul>
signalUnblock :: GObjectClass obj => ConnectId obj -> IO ()

-- | Stops a signal's current emission.
--   
--   <ul>
--   <li>This will prevent the default method from running. The sequence in
--   which handlers are run is "first", "on", "last" then "after" where
--   Gtk-internal signals are connected either at "first" or at "last".
--   Hence this function can only stop the signal processing if it is
--   called from within a handler that is connected with an "on" signal and
--   if the Gtk-internal handler is connected as "last". Gtk prints a
--   warning if this function is used on a signal which isn't being
--   emitted.</li>
--   </ul>
signalStopEmission :: GObjectClass obj => obj -> SignalName -> IO ()

-- | <i>Deprecated: use signalDisconnect instead</i>
disconnect :: GObjectClass obj => ConnectId obj -> IO ()
data GClosure
connectGeneric :: GObjectClass obj => SignalName -> ConnectAfter -> obj -> handler -> IO (ConnectId obj)


-- | main event loop, and events
module System.Glib.MainLoop
type HandlerId = CUInt

-- | Sets a function to be called at regular intervals, with the default
--   priority <a>priorityDefault</a>. The function is called repeatedly
--   until it returns <tt>False</tt>, after which point the timeout
--   function will not be called again. The first call to the function will
--   be at the end of the first interval.
--   
--   Note that timeout functions may be delayed, due to the processing of
--   other event sources. Thus they should not be relied on for precise
--   timing. After each call to the timeout function, the time of the next
--   timeout is recalculated based on the current time and the given
--   interval (it does not try to 'catch up' time lost in delays).
timeoutAdd :: IO Bool -> Int -> IO HandlerId

-- | Sets a function to be called at regular intervals, with the given
--   priority. The function is called repeatedly until it returns
--   <tt>False</tt>, after which point the timeout function will not be
--   called again. The first call to the function will be at the end of the
--   first interval.
--   
--   Note that timeout functions may be delayed, due to the processing of
--   other event sources. Thus they should not be relied on for precise
--   timing. After each call to the timeout function, the time of the next
--   timeout is recalculated based on the current time and the given
--   interval (it does not try to 'catch up' time lost in delays).
timeoutAddFull :: IO Bool -> Priority -> Int -> IO HandlerId

-- | Remove a previously added timeout handler by its <a>HandlerId</a>.
timeoutRemove :: HandlerId -> IO ()

-- | Add a callback that is called whenever the system is idle.
--   
--   <ul>
--   <li>A priority can be specified via an integer. This should usually be
--   <a>priorityDefaultIdle</a>.</li>
--   <li>If the function returns <tt>False</tt> it will be removed.</li>
--   </ul>
idleAdd :: IO Bool -> Priority -> IO HandlerId

-- | Remove a previously added idle handler by its <a>HandlerId</a>.
idleRemove :: HandlerId -> IO ()

-- | Flags representing a condition to watch for on a file descriptor.
--   
--   <ul>
--   <li><i><tt>IOIn</tt></i> There is data to read.</li>
--   <li><i><tt>IOOut</tt></i> Data can be written (without blocking).</li>
--   <li><i><tt>IOPri</tt></i> There is urgent data to read.</li>
--   <li><i><tt>IOErr</tt></i> Error condition.</li>
--   <li><i><tt>IOHup</tt></i> Hung up (the connection has been broken,
--   usually for pipes and sockets).</li>
--   <li><i><tt>IOInvalid</tt></i> Invalid request. The file descriptor is
--   not open.</li>
--   </ul>
data IOCondition
IOIn :: IOCondition
IOOut :: IOCondition
IOPri :: IOCondition
IOErr :: IOCondition
IOHup :: IOCondition
IOInvalid :: IOCondition

-- | Adds the file descriptor into the main event loop with the given
--   priority.
inputAdd :: FD -> [IOCondition] -> Priority -> IO Bool -> IO HandlerId
inputRemove :: HandlerId -> IO ()

-- | Priorities for installing callbacks.
type Priority = Int
priorityLow :: Int
priorityDefaultIdle :: Int
priorityHighIdle :: Int
priorityDefault :: Int
priorityHigh :: Int

-- | A main event loop abstraction.
data MainLoop

-- | Create a new <a>MainLoop</a>.
mainLoopNew :: Maybe MainContext -> Bool -> IO MainLoop

-- | Runs a main loop until <a>mainLoopQuit</a> is called on the loop. If
--   this is called for the thread of the loop's <a>MainContext</a>, it
--   will process events from the loop, otherwise it will simply wait.
mainLoopRun :: MainLoop -> IO ()

-- | Stops a <a>MainLoop</a> from running. Any calls to mainLoopRun for the
--   loop will return.
mainLoopQuit :: MainLoop -> IO ()

-- | Checks to see if the main loop is currently being run via mainLoopRun.
mainLoopIsRunning :: MainLoop -> IO Bool

-- | An opaque datatype representing a set of sources to be handled in a
--   main loop.
data MainContext

-- | Creates a new <a>MainContext</a>.
mainContextNew :: IO MainContext

-- | The default <a>MainContext</a>. This is the main context used for main
--   loop functions when a main loop is not explicitly specified.
mainContextDefault :: MainContext

-- | Runs a single iteration for the given main loop. This involves
--   checking to see if any event sources are ready to be processed, then
--   if no events sources are ready and <tt>mayBlock</tt> is <a>True</a>,
--   waiting for a source to become ready, then dispatching the highest
--   priority events sources that are ready. Note that even when
--   <tt>mayBlock</tt> is <a>True</a>, it is still possible for
--   <a>mainContextIteration</a> to return (0), since the the wait may be
--   interrupted for other reasons than an event source becoming ready.
mainContextIteration :: MainContext -> Bool -> IO Bool
mainContextFindSourceById :: MainContext -> HandlerId -> IO Source
newtype Source
Source :: (ForeignPtr (Source)) -> Source
sourceAttach :: Source -> MainContext -> IO HandlerId
sourceSetPriority :: Source -> Priority -> IO ()
sourceGetPriority :: Source -> IO Priority
sourceDestroy :: Source -> IO ()
sourceIsDestroyed :: Source -> IO Bool
instance Eq IOCondition
instance Bounded IOCondition
instance Flags IOCondition
instance Enum IOCondition


-- | Error Reporting, glib's system for reporting errors.
--   
--   <a>GError</a>s are used by glib to report recoverable runtime errors.
--   
--   This module provides functions for checking glib/gtk functions that
--   report <a>GError</a>s. It also provides functions for throwing and
--   catching <a>GError</a>s as Haskell exceptions.
module System.Glib.GError

-- | A GError consists of a domain, code and a human readable message.
data GError
GError :: !GErrorDomain -> !GErrorCode -> !GErrorMessage -> GError

-- | A code used to identify the 'namespace' of the error. Within each
--   error domain all the error codes are defined in an enumeration. Each
--   gtk/gnome module that uses GErrors has its own error domain. The
--   rationale behind using error domains is so that each module can
--   organise its own error codes without having to coordinate on a global
--   error code list.
type GErrorDomain = GQuark

-- | A code to identify a specific error within a given
--   <a>GErrorDomain</a>. Most of time you will not need to deal with this
--   raw code since there is an enumeration type for each error domain. Of
--   course which enumeraton to use depends on the error domain, but if you
--   use <a>catchGErrorJustDomain</a> or <a>handleGErrorJustDomain</a>,
--   this is worked out for you automatically.
type GErrorCode = Int

-- | A human readable error message.
type GErrorMessage = Text

-- | This will catch just a specific GError exception. If you need to catch
--   a range of related errors, <a>catchGErrorJustDomain</a> is probably
--   more appropriate. Example:
--   
--   <pre>
--   do image &lt;- catchGErrorJust PixbufErrorCorruptImage
--   loadImage
--   (\errorMessage -&gt; do log errorMessage
--   return mssingImagePlaceholder)
--   </pre>
catchGErrorJust :: GErrorClass err => err -> IO a -> (GErrorMessage -> IO a) -> IO a

-- | Catch all GErrors from a particular error domain. The handler function
--   should just deal with one error enumeration type. If you need to catch
--   errors from more than one error domain, use this function twice with
--   an appropriate handler functions for each.
--   
--   <pre>
--   catchGErrorJustDomain
--   loadImage
--   (\err message -&gt; case err of
--   PixbufErrorCorruptImage -&gt; ...
--   PixbufErrorInsufficientMemory -&gt; ...
--   PixbufErrorUnknownType -&gt; ...
--   _ -&gt; ...)
--   </pre>
catchGErrorJustDomain :: GErrorClass err => IO a -> (err -> GErrorMessage -> IO a) -> IO a

-- | A verson of <a>handleGErrorJust</a> with the arguments swapped around.
handleGErrorJust :: GErrorClass err => err -> (GErrorMessage -> IO a) -> IO a -> IO a

-- | A verson of <a>catchGErrorJustDomain</a> with the arguments swapped
--   around.
handleGErrorJustDomain :: GErrorClass err => (err -> GErrorMessage -> IO a) -> IO a -> IO a

-- | This will catch any GError exception. The handler function will
--   receive the raw GError. This is probably only useful when you want to
--   take some action that does not depend on which GError exception has
--   occured, otherwise it would be better to use either
--   <a>catchGErrorJust</a> or <a>catchGErrorJustDomain</a>. For example:
--   
--   <pre>
--   catchGError
--   (do ...
--   ...)
--   (\(GError dom code msg) -&gt; fail msg)
--   </pre>

-- | <i>Deprecated: Use ordinary Control.Exception.catch</i>
catchGError :: IO a -> (GError -> IO a) -> IO a

-- | A verson of <a>catchGError</a> with the arguments swapped around.
--   
--   <pre>
--   handleGError (\(GError dom code msg) -&gt; ...) $
--   ...
--   </pre>

-- | <i>Deprecated: Use ordinary Control.Exception.handle</i>
handleGError :: (GError -> IO a) -> IO a -> IO a

-- | Catch all GError exceptions and convert them into a general failure.
failOnGError :: IO a -> IO a

-- | Use this if you need to explicitly throw a GError or re-throw an
--   existing GError that you do not wish to handle.

-- | <i>Deprecated: Use ordinary Control.Exception.throw</i>
throwGError :: GError -> IO a

-- | Each error domain's error enumeration type should be an instance of
--   this class. This class helps to hide the raw error and domain codes
--   from the user. This interface should be implemented by calling the
--   approrpiate <tt>{error_domain}_error_quark</tt>. It is safe to use a
--   pure FFI call for this.
--   
--   Example for <a>PixbufError</a>:
--   
--   <pre>
--   instance GErrorClass PixbufError where
--   gerrorDomain _ = {#call pure unsafe pixbuf_error_quark#}
--   </pre>
class Enum err => GErrorClass err
gerrorDomain :: GErrorClass err => err -> GErrorDomain

-- | Glib functions which report <a>GError</a>s take as a parameter a
--   <tt>GError **error</tt>. Use this function to supply such a parameter.
--   It checks if an error was reported and if so throws it as a Haskell
--   exception.
--   
--   Example of use:
--   
--   <pre>
--   propagateGError $ \gerrorPtr -&gt;
--   {# call g_some_function_that_might_return_an_error #} a b gerrorPtr
--   </pre>
propagateGError :: (Ptr (Ptr ()) -> IO a) -> IO a

-- | Like <a>propagateGError</a> but instead of throwing the GError as an
--   exception handles the error immediately using the supplied error
--   handler.
--   
--   Example of use:
--   
--   <pre>
--   checkGError
--   (\gerrorPtr -&gt; {# call g_some_function_that_might_return_an_error #} a b gerrorPtr)
--   (\(GError domain code msg) -&gt; ...)
--   </pre>
checkGError :: (Ptr (Ptr ()) -> IO a) -> (GError -> IO a) -> IO a
instance Typeable GError
instance Storable GError
instance Exception GError
instance Show GError


module System.Glib.GDateTime
type GTimeValPart = CLong
data GTimeVal
GTimeVal :: GTimeValPart -> GTimeValPart -> GTimeVal
gTimeValSec :: GTimeVal -> GTimeValPart
gTimeValUSec :: GTimeVal -> GTimeValPart
gGetCurrentTime :: IO GTimeVal
gUSleep :: GTimeValPart -> IO ()
gTimeValAdd :: GTimeVal -> GTimeValPart -> GTimeVal
gTimeValFromISO8601 :: GlibString string => string -> Maybe GTimeVal
gTimeValToISO8601 :: GlibString string => GTimeVal -> string
newtype GDate
GDate :: GDateJulianDay -> GDate
gDateJulianDay :: GDate -> GDateJulianDay
data GDateDay
data GDateMonth
data GDateYear
type GDateJulianDay = CUInt
data GDateWeekday
gDateValidJulian :: GDateJulianDay -> Bool
gDateValidDMY :: GDateDay -> GDateMonth -> GDateYear -> Bool
gDateNewJulian :: GDateJulianDay -> Maybe GDate
gDateNewDMY :: GDateDay -> GDateMonth -> GDateYear -> Maybe GDate
gDateSetDay :: GDate -> GDateDay -> Maybe GDate
gDateSetMonth :: GDate -> GDateMonth -> Maybe GDate
gDateSetYear :: GDate -> GDateYear -> Maybe GDate
gDateNewTimeVal :: GTimeVal -> GDate
gDateParse :: GlibString string => string -> IO (Maybe GDate)
gDateAddDays :: GDate -> Word -> GDate
gDateSubtractDays :: GDate -> Word -> GDate
gDateAddMonths :: GDate -> Word -> GDate
gDateSubtractMonths :: GDate -> Word -> GDate
gDateAddYears :: GDate -> Word -> GDate
gDateSubtractYears :: GDate -> Word -> GDate
gDateDaysBetween :: GDate -> GDate -> Int
gDateCompare :: GDate -> GDate -> Ordering
gDateClamp :: GDate -> GDate -> GDate -> GDate
gDateDay :: GDate -> GDateDay
gDateMonth :: GDate -> GDateMonth
gDateYear :: GDate -> GDateYear
gDateWeekday :: GDate -> GDateWeekday
instance Eq GTimeVal
instance Ord GTimeVal
instance Eq GDateDay
instance Ord GDateDay
instance Eq GDateMonth
instance Ord GDateMonth
instance Eq GDateYear
instance Ord GDateYear
instance Eq GDate
instance Eq GDateWeekday
instance Ord GDateWeekday
instance Ord GDate
instance Bounded GDateWeekday
instance Enum GDateWeekday
instance Storable GDate
instance Bounded GDateYear
instance Bounded GDateMonth
instance Enum GDateMonth
instance Bounded GDateDay
instance Storable GTimeVal


-- | This module binds GLib-specific utility procedures.
module System.Glib.Utils

-- | Gets a human-readable name for the application, as set by
--   <a>setApplicationName</a>. This name should be localized if possible,
--   and is intended for display to the user. Contrast with
--   <a>getProgramName</a>, which gets a non-localized name. If
--   <a>setApplicationName</a> has not been performed, returns the result
--   of <a>getProgramName</a> (which may be <a>Nothing</a> if
--   <a>setProgramName</a> has also not been performed).
getApplicationName :: GlibString string => IO (Maybe string)

-- | Sets a human-readable name for the application. This name should be
--   localized if possible, and is intended for display to the user.
--   Contrast with <a>setProgramName</a>, which sets a non-localized name.
--   <a>setProgramName</a> will be performed automatically by
--   <tt>initGUI</tt>, but <a>setApplicationName</a> will not.
--   
--   Note that for thread safety reasons, this computation can only be
--   performed once.
--   
--   The application name will be used in contexts such as error messages,
--   or when displaying an application's name in the task list.
setApplicationName :: GlibString string => string -> IO ()

-- | Gets the name of the program. This name should <i>not</i> be
--   localized, contrast with <a>getApplicationName</a>. If you are using
--   GDK or GTK+, the program name is set in <tt>initGUI</tt> to the last
--   component of argv[0].
getProgramName :: GlibString string => IO (Maybe string)

-- | Sets the name of the program. This name should <i>not</i> be
--   localized, contrast with <a>setApplicationName</a>. Note that for
--   thread-safety reasons this computation can only be performed once.
setProgramName :: GlibString string => string -> IO ()


-- | Functions for getting and setting GObject properties
module System.Glib.Properties
objectSetPropertyInt :: GObjectClass gobj => String -> gobj -> Int -> IO ()
objectGetPropertyInt :: GObjectClass gobj => String -> gobj -> IO Int
objectSetPropertyUInt :: GObjectClass gobj => String -> gobj -> Int -> IO ()
objectGetPropertyUInt :: GObjectClass gobj => String -> gobj -> IO Int
objectSetPropertyInt64 :: GObjectClass gobj => String -> gobj -> Int64 -> IO ()
objectGetPropertyInt64 :: GObjectClass gobj => String -> gobj -> IO Int64
objectSetPropertyUInt64 :: GObjectClass gobj => String -> gobj -> Word64 -> IO ()
objectGetPropertyUInt64 :: GObjectClass gobj => String -> gobj -> IO Word64
objectSetPropertyChar :: GObjectClass gobj => String -> gobj -> Char -> IO ()
objectGetPropertyChar :: GObjectClass gobj => String -> gobj -> IO Char
objectSetPropertyBool :: GObjectClass gobj => String -> gobj -> Bool -> IO ()
objectGetPropertyBool :: GObjectClass gobj => String -> gobj -> IO Bool
objectSetPropertyEnum :: (GObjectClass gobj, Enum enum) => GType -> String -> gobj -> enum -> IO ()
objectGetPropertyEnum :: (GObjectClass gobj, Enum enum) => GType -> String -> gobj -> IO enum
objectSetPropertyFlags :: (GObjectClass gobj, Flags flag) => GType -> String -> gobj -> [flag] -> IO ()
objectGetPropertyFlags :: (GObjectClass gobj, Flags flag) => GType -> String -> gobj -> IO [flag]
objectSetPropertyFloat :: GObjectClass gobj => String -> gobj -> Float -> IO ()
objectGetPropertyFloat :: GObjectClass gobj => String -> gobj -> IO Float
objectSetPropertyDouble :: GObjectClass gobj => String -> gobj -> Double -> IO ()
objectGetPropertyDouble :: GObjectClass gobj => String -> gobj -> IO Double
objectSetPropertyString :: (GObjectClass gobj, GlibString string) => String -> gobj -> string -> IO ()
objectGetPropertyString :: (GObjectClass gobj, GlibString string) => String -> gobj -> IO string
objectSetPropertyMaybeString :: (GObjectClass gobj, GlibString string) => String -> gobj -> Maybe string -> IO ()
objectGetPropertyMaybeString :: (GObjectClass gobj, GlibString string) => String -> gobj -> IO (Maybe string)
objectSetPropertyFilePath :: (GObjectClass gobj, GlibFilePath string) => String -> gobj -> string -> IO ()
objectGetPropertyFilePath :: (GObjectClass gobj, GlibFilePath string) => String -> gobj -> IO string
objectSetPropertyMaybeFilePath :: (GObjectClass gobj, GlibFilePath string) => String -> gobj -> Maybe string -> IO ()
objectGetPropertyMaybeFilePath :: (GObjectClass gobj, GlibFilePath string) => String -> gobj -> IO (Maybe string)
objectSetPropertyBoxedOpaque :: GObjectClass gobj => (boxed -> (Ptr boxed -> IO ()) -> IO ()) -> GType -> String -> gobj -> boxed -> IO ()
objectGetPropertyBoxedOpaque :: GObjectClass gobj => (Ptr boxed -> IO boxed) -> GType -> String -> gobj -> IO boxed
objectSetPropertyBoxedStorable :: (GObjectClass gobj, Storable boxed) => GType -> String -> gobj -> boxed -> IO ()
objectGetPropertyBoxedStorable :: (GObjectClass gobj, Storable boxed) => GType -> String -> gobj -> IO boxed
objectSetPropertyGObject :: (GObjectClass gobj, GObjectClass gobj') => GType -> String -> gobj -> gobj' -> IO ()
objectGetPropertyGObject :: (GObjectClass gobj, GObjectClass gobj') => GType -> String -> gobj -> IO gobj'
newAttrFromIntProperty :: GObjectClass gobj => String -> Attr gobj Int
readAttrFromIntProperty :: GObjectClass gobj => String -> ReadAttr gobj Int
newAttrFromUIntProperty :: GObjectClass gobj => String -> Attr gobj Int
readAttrFromUIntProperty :: GObjectClass gobj => String -> ReadAttr gobj Int
writeAttrFromUIntProperty :: GObjectClass gobj => String -> WriteAttr gobj Int
newAttrFromCharProperty :: GObjectClass gobj => String -> Attr gobj Char
readAttrFromCharProperty :: GObjectClass gobj => String -> ReadAttr gobj Char
newAttrFromBoolProperty :: GObjectClass gobj => String -> Attr gobj Bool
readAttrFromBoolProperty :: GObjectClass gobj => String -> ReadAttr gobj Bool
newAttrFromFloatProperty :: GObjectClass gobj => String -> Attr gobj Float
readAttrFromFloatProperty :: GObjectClass gobj => String -> ReadAttr gobj Float
newAttrFromDoubleProperty :: GObjectClass gobj => String -> Attr gobj Double
readAttrFromDoubleProperty :: GObjectClass gobj => String -> ReadAttr gobj Double
newAttrFromEnumProperty :: (GObjectClass gobj, Enum enum) => String -> GType -> Attr gobj enum
readAttrFromEnumProperty :: (GObjectClass gobj, Enum enum) => String -> GType -> ReadAttr gobj enum
writeAttrFromEnumProperty :: (GObjectClass gobj, Enum enum) => String -> GType -> WriteAttr gobj enum
newAttrFromFlagsProperty :: (GObjectClass gobj, Flags flag) => String -> GType -> Attr gobj [flag]
readAttrFromFlagsProperty :: (GObjectClass gobj, Flags flag) => String -> GType -> ReadAttr gobj [flag]
newAttrFromStringProperty :: (GObjectClass gobj, GlibString string) => String -> Attr gobj string
readAttrFromStringProperty :: (GObjectClass gobj, GlibString string) => String -> ReadAttr gobj string
writeAttrFromStringProperty :: (GObjectClass gobj, GlibString string) => String -> WriteAttr gobj string
newAttrFromMaybeStringProperty :: (GObjectClass gobj, GlibString string) => String -> Attr gobj (Maybe string)
readAttrFromMaybeStringProperty :: (GObjectClass gobj, GlibString string) => String -> ReadAttr gobj (Maybe string)
writeAttrFromMaybeStringProperty :: (GObjectClass gobj, GlibString string) => String -> WriteAttr gobj (Maybe string)
newAttrFromFilePathProperty :: (GObjectClass gobj, GlibFilePath string) => String -> Attr gobj string
readAttrFromFilePathProperty :: (GObjectClass gobj, GlibFilePath string) => String -> ReadAttr gobj string
writeAttrFromFilePathProperty :: (GObjectClass gobj, GlibFilePath string) => String -> WriteAttr gobj string
newAttrFromMaybeFilePathProperty :: (GObjectClass gobj, GlibFilePath string) => String -> Attr gobj (Maybe string)
readAttrFromMaybeFilePathProperty :: (GObjectClass gobj, GlibFilePath string) => String -> ReadAttr gobj (Maybe string)
writeAttrFromMaybeFilePathProperty :: (GObjectClass gobj, GlibFilePath string) => String -> WriteAttr gobj (Maybe string)
newAttrFromBoxedOpaqueProperty :: GObjectClass gobj => (Ptr boxed -> IO boxed) -> (boxed -> (Ptr boxed -> IO ()) -> IO ()) -> String -> GType -> Attr gobj boxed
readAttrFromBoxedOpaqueProperty :: GObjectClass gobj => (Ptr boxed -> IO boxed) -> String -> GType -> ReadAttr gobj boxed
writeAttrFromBoxedOpaqueProperty :: GObjectClass gobj => (boxed -> (Ptr boxed -> IO ()) -> IO ()) -> String -> GType -> WriteAttr gobj boxed
newAttrFromBoxedStorableProperty :: (GObjectClass gobj, Storable boxed) => String -> GType -> Attr gobj boxed
readAttrFromBoxedStorableProperty :: (GObjectClass gobj, Storable boxed) => String -> GType -> ReadAttr gobj boxed
newAttrFromObjectProperty :: (GObjectClass gobj, GObjectClass gobj', GObjectClass gobj'') => String -> GType -> ReadWriteAttr gobj gobj' gobj''
readAttrFromObjectProperty :: (GObjectClass gobj, GObjectClass gobj') => String -> GType -> ReadAttr gobj gobj'
writeAttrFromObjectProperty :: (GObjectClass gobj, GObjectClass gobj') => String -> GType -> WriteAttr gobj gobj'
newAttrFromMaybeObjectProperty :: (GObjectClass gobj, GObjectClass gobj', GObjectClass gobj'') => String -> GType -> ReadWriteAttr gobj (Maybe gobj') (Maybe gobj'')
readAttrFromMaybeObjectProperty :: (GObjectClass gobj, GObjectClass gobj') => String -> GType -> ReadAttr gobj (Maybe gobj')
writeAttrFromMaybeObjectProperty :: (GObjectClass gobj, GObjectClass gobj') => String -> GType -> WriteAttr gobj (Maybe gobj')
objectGetPropertyInternal :: GObjectClass gobj => GType -> (GValue -> IO a) -> String -> gobj -> IO a
objectSetPropertyInternal :: GObjectClass gobj => GType -> (GValue -> a -> IO ()) -> String -> gobj -> a -> IO ()

module System.Glib
