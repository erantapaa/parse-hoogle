-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sound synthesis with SuperCollider
--   
@package vivid
@version 0.1.0.3


-- | Internal. Just use <a>Vivid.SynthDef</a>
module Vivid.SynthDef.Types
data Signal
Constant :: Float -> Signal
Param :: ByteString -> Signal
UGOut :: Int -> Int32 -> Signal

-- | The rate that a UGen computes at
data CalculationRate

-- | constant value
IR :: CalculationRate

-- | control rate
KR :: CalculationRate

-- | audio rate
AR :: CalculationRate

-- | demand rate
DR :: CalculationRate

-- | Internal representation of Synth Definitions. Usually, use <a>sd</a>
--   instead of making these by hand.
--   
--   This representation (especially <a>_sdUGens</a>) might change in the
--   future.
data SynthDef
SynthDef :: SDName -> [(ByteString, Float)] -> Map Int UGen -> SynthDef
_sdName :: SynthDef -> SDName
_sdParams :: SynthDef -> [(ByteString, Float)]
_sdUGens :: SynthDef -> Map Int UGen
data SDName
SDName_Named :: ByteString -> SDName
SDName_Hash :: SDName

-- | State monad to construct SynthDefs
--   
--   The SynthDef is an under-construction synth definition The [Int] is
--   the id supply. Its type definitely could change in the future
type SDState = State ([Int], SynthDef)

-- | Representation of Unit Generators. You usually won't be creating these
--   by hand, but instead using things from the library in <a>UGens</a>
data UGen
UGen :: UGenName -> CalculationRate -> [Signal] -> Int -> UGen
_ugenName :: UGen -> UGenName
_ugenCalculationRate :: UGen -> CalculationRate
_ugenIns :: UGen -> [Signal]
_ugenNumOuts :: UGen -> Int
data UGenName
UGName_S :: ByteString -> UGenName
UGName_U :: UnaryOp -> UGenName
UGName_B :: BinaryOp -> UGenName

-- | Unary signal operations. Many of these have functions so you don't
--   need to use this internal representation (e.g. <a>Neg</a> has
--   <tt>neg</tt>, etc).
--   
--   This type might not be exposed in the future.
data UnaryOp
Neg :: UnaryOp
Not :: UnaryOp
IsNil :: UnaryOp
NotNil :: UnaryOp
BitNot :: UnaryOp
Abs :: UnaryOp
AsFloat :: UnaryOp
AsInt :: UnaryOp
Ciel :: UnaryOp
Floor :: UnaryOp
Frac :: UnaryOp
Sign :: UnaryOp
Squared :: UnaryOp
Cubed :: UnaryOp
Sqrt :: UnaryOp
Exp :: UnaryOp
Recip :: UnaryOp
MIDICPS :: UnaryOp
CPSMIDI :: UnaryOp
MIDIRatio :: UnaryOp
RatioMIDI :: UnaryOp
DbAmp :: UnaryOp
AmpDb :: UnaryOp
OctCPS :: UnaryOp
CPSOct :: UnaryOp
Log :: UnaryOp
Log2 :: UnaryOp
Log10 :: UnaryOp
Sin :: UnaryOp
Cos :: UnaryOp
Tan :: UnaryOp
ArcSin :: UnaryOp
ArcCos :: UnaryOp
ArcTan :: UnaryOp
SinH :: UnaryOp
CosH :: UnaryOp
TanH :: UnaryOp
Rand :: UnaryOp
Rand2 :: UnaryOp
LinRand :: UnaryOp
BiLinRand :: UnaryOp
Sum3Rand :: UnaryOp
Distort :: UnaryOp
SoftClip :: UnaryOp
Coin :: UnaryOp
DigitValue :: UnaryOp
Silence :: UnaryOp
Thru :: UnaryOp
RectWindow :: UnaryOp
HanWindow :: UnaryOp
WelchWindow :: UnaryOp
TriWindow :: UnaryOp
Ramp :: UnaryOp
SCurve :: UnaryOp
NumUnarySelectors :: UnaryOp

-- | Binary signal operations. For the simple ones (like <a>Add</a>,
--   <a>Mul</a>, etc.), there are functions (like <a>~+</a>, <a>~*</a>,
--   etc.) that wrap them up so you don't have to make a ugen for them
--   yourself.
--   
--   In the future these may not be exported -- we'll just have functions
--   for all of them.
data BinaryOp
Add :: BinaryOp
Sub :: BinaryOp
Mul :: BinaryOp

-- | Integer division
IDiv :: BinaryOp

-- | Float division
FDiv :: BinaryOp
Mod :: BinaryOp
Eq :: BinaryOp
Ne :: BinaryOp
Lt :: BinaryOp
Gt :: BinaryOp
Le :: BinaryOp
Ge :: BinaryOp
Min :: BinaryOp
Max :: BinaryOp
BitAnd :: BinaryOp
BitOr :: BinaryOp
BitXor :: BinaryOp
Lcm :: BinaryOp
Gcd :: BinaryOp
Round :: BinaryOp
RoundUp :: BinaryOp
Trunc :: BinaryOp
Atan2 :: BinaryOp
Hypot :: BinaryOp
Hypotx :: BinaryOp
Pow :: BinaryOp
ShiftLeft :: BinaryOp
ShiftRight :: BinaryOp
UnsignedShift :: BinaryOp
Fill :: BinaryOp

-- | a * (b + 1) == a * b + a
Ring1 :: BinaryOp

-- | a * b + a + b
Ring2 :: BinaryOp

-- | a * a * b
Ring3 :: BinaryOp

-- | a * a * b - a * b * b
Ring4 :: BinaryOp

-- | a * a - b * b
DifSqr :: BinaryOp

-- | a * a + b * b
SumSqr :: BinaryOp

-- | (a + b) ^ 2
SqrSum :: BinaryOp

-- | (a - b) ^ 2
SqrDif :: BinaryOp

-- | abs(a - b)
AbsDif :: BinaryOp
Thresh :: BinaryOp
AMClip :: BinaryOp
ScaleNeg :: BinaryOp
Clip2 :: BinaryOp
Excess :: BinaryOp
Fold2 :: BinaryOp
Wrap2 :: BinaryOp
FirstArg :: BinaryOp
RandRange :: BinaryOp
ExpRandRange :: BinaryOp
NumBinarySelectors :: BinaryOp
instance Show Signal
instance Eq Signal
instance Show SDName
instance Eq SDName
instance Read SDName
instance Ord SDName
instance Show CalculationRate
instance Read CalculationRate
instance Eq CalculationRate
instance Enum CalculationRate
instance Ord CalculationRate
instance Show BinaryOp
instance Eq BinaryOp
instance Ord BinaryOp
instance Enum BinaryOp
instance Show UnaryOp
instance Eq UnaryOp
instance Ord UnaryOp
instance Enum UnaryOp
instance Show UGenName
instance Eq UGenName
instance Show UGen
instance Eq UGen
instance Show SynthDef


-- | Our IncoherentInstances + UndecidableInstances sin bin, for everything
--   that needs crazy type hacks
--   
--   Most of this is just to get numbers defaulting to Floats in a useful
--   way in SynthDefs
--   
--   We keep these separated so everything that doesn't need
--   IncoherentInstances can live in Sanity Land
module Vivid.SynthDef.CrazyTypes
class ToSig s
toSig :: ToSig s => s -> Signal

-- | For <a>Constant</a> (Float) values
class ToSigM s
toSigM :: ToSigM s => s -> SDState Signal
class HasSynthRef a
getSynthRef :: HasSynthRef a => a -> Either ByteString SynthDef
instance [incoherent] HasSynthRef SynthDef
instance [incoherent] HasSynthRef String
instance [incoherent] ToSigM (SDState Signal)
instance [incoherent] ToSig i => ToSigM i
instance [incoherent] ToSig String
instance [incoherent] (Num a, Real a) => ToSig a
instance [incoherent] ToSig Signal

module Vivid.OSC.Util
align :: (Num i, Bits i) => i -> i
floatToWord :: Float -> Word32
wordToFloat :: Word32 -> Float


-- | <b>You probably don't need to use this directly</b> -- use
--   <a>Vivid.SynthDef</a> instead
--   
--   This is a representation of how SynthDefs are sent over the wire, as
--   described in the <a>Synth Definition File Format</a> helpfile.
module Vivid.SynthDef.Literally
data LiteralSynthDef
LiteralSynthDef :: ByteString -> [Float] -> [Float] -> [ParamName] -> [UGenSpec] -> [VariantSpec] -> LiteralSynthDef
_synthDefName :: LiteralSynthDef -> ByteString
_synthDefConstants :: LiteralSynthDef -> [Float]
_synthDefParameters :: LiteralSynthDef -> [Float]
_synthDefParamNames :: LiteralSynthDef -> [ParamName]
_synthDefUGens :: LiteralSynthDef -> [UGenSpec]
_synthDefVariants :: LiteralSynthDef -> [VariantSpec]
encodeSynthDefFile :: SynthDefFile -> ByteString
decodeSynthDefFile :: ByteString -> IO SynthDefFile
data UGenSpec
UGenSpec :: ByteString -> CalculationRate -> [InputSpec] -> [OutputSpec] -> Int16 -> UGenSpec
_uGenSpec_name :: UGenSpec -> ByteString
_uGenSpec_calcRate :: UGenSpec -> CalculationRate
_uGenSpec_inputs :: UGenSpec -> [InputSpec]
_uGenSpec_outputs :: UGenSpec -> [OutputSpec]
_uGenSpec_specialIndex :: UGenSpec -> Int16
data InputSpec
InputSpec_UGen :: Int32 -> Int32 -> InputSpec
_inputSpec_uGen_index :: InputSpec -> Int32
_inputSpec_uGen_outputIndex :: InputSpec -> Int32
InputSpec_Constant :: Int32 -> InputSpec
_inputSpec_constant_index :: InputSpec -> Int32
data ParamName
ParamName :: ByteString -> Int32 -> ParamName
_paramName_name :: ParamName -> ByteString
_paramName_indexInParamArray :: ParamName -> Int32
data SynthDefFile
SynthDefFile :: [LiteralSynthDef] -> SynthDefFile
data OutputSpec
OutputSpec :: CalculationRate -> OutputSpec
_outputSpec_calcRate :: OutputSpec -> CalculationRate
instance Show ParamName
instance Show InputSpec
instance Read InputSpec
instance Eq InputSpec
instance Show OutputSpec
instance Read OutputSpec
instance Eq OutputSpec
instance Show UGenSpec
instance Show VariantSpec
instance Show LiteralSynthDef
instance Show SynthDefFile


-- | <b>You probably don't need to use this directly</b>
--   
--   Representation of Open Sound Control data
module Vivid.OSC

-- | An OSC message, e.g.
--   
--   <pre>
--   OSC "/n_free" [OSC_I 42]
--   </pre>
data OSC
OSC :: ByteString -> [OSCDatum] -> OSC
data OSCDatum
OSC_I :: Int32 -> OSCDatum
OSC_S :: ByteString -> OSCDatum
OSC_F :: Float -> OSCDatum
OSC_B :: ByteString -> OSCDatum
encodeOSC :: OSC -> ByteString
decodeOSC :: ByteString -> OSC
instance Show OSCDatum
instance Read OSCDatum
instance Eq OSCDatum
instance Show OSC
instance Read OSC
instance Eq OSC
instance NFData OSCDatum


-- | Library for interacting with the SuperCollider server.
--   
--   You don't need to use much of this day-to-day
--   
--   There's a toplevel <a>scServerState</a> that stores the current state
--   of the SC server
module Vivid.SCServer

-- | Send an <a>OSC</a> message to the SuperCollider server
call :: OSC -> IO ()

-- | Send a ByteString to the SuperCollider server. You usually want to use
--   <a>call</a> instead. May be removed in future versions.
callBS :: ByteString -> IO ()

-- | Stop the SuperCollider server
quit :: IO ()

-- | Your "emergency" button. Run this and everything playing on the SC
--   server will be freed -- silence!
--   
--   Corresponds to the cmd-. / ctrl-. key command in the SuperCollider IDE
cmdPeriod :: IO ()
newtype NodeId
NodeId :: Int32 -> NodeId
unNodeId :: NodeId -> Int32
newNodeId :: IO NodeId
newtype BufferId
BufferId :: Int32 -> BufferId
unBufferId :: BufferId -> Int32
newBufferId :: IO BufferId

-- | If you've started the SC server with a non-default number of buffer
--   ids, (e.g. with the "-b" argument), you can reflect that here
--   
--   Note that the buffer ids start at 512, to not clash with any that
--   sclang has allocated
setMaxBufferIds :: Int32 -> IO ()

-- | Make an empty buffer
--   
--   The Int32 is the buffer length <i>in samples</i>. Multiply seconds by
--   the default sample rate of the server (usually 48000) to get the
--   number of samples
makeBuffer :: Int32 -> IO BufferId

-- | Make a buffer and fill it with sound data from a file
makeBufferFromFile :: FilePath -> IO BufferId

-- | Write a buffer to a file
saveBuffer :: BufferId -> FilePath -> IO ()

-- | <b>You usually don't need to call this function</b>
--   
--   Use this if to connect on a non-default port or to a server not at
--   localhost
--   
--   Otherwise the connection is created when it's needed. You can also use
--   this to explicitly create the connection, so the computation is done
--   upfront
--   
--   The <a>HostName</a> is the ip address or "localhost". The
--   <a>ServiceName</a> is the port
createSCServerConnection :: HostName -> ServiceName -> IO Socket

-- | Async messages to the sc server get responded to with "/done" -- so
--   this calls those functions and waits for the "/done" before continuing
callAndWaitForDone :: OSC -> IO ()
data SCServerState
SCServerState :: !(TVar (Maybe Socket)) -> !(TVar [BufferId]) -> !(TVar Int32) -> !(TVar [NodeId]) -> !(TVar [SyncId]) -> !(TVar (Set (SDName, Int))) -> SCServerState
scServer_socket :: SCServerState -> !(TVar (Maybe Socket))
scServer_availableBufferIds :: SCServerState -> !(TVar [BufferId])
scServer_maxBufIds :: SCServerState -> !(TVar Int32)
scServer_availableNodeIds :: SCServerState -> !(TVar [NodeId])
scServer_availableSyncIds :: SCServerState -> !(TVar [SyncId])
scServer_definedSDs :: SCServerState -> !(TVar (Set (SDName, Int)))
scServerState :: SCServerState
instance Show NodeId
instance Eq NodeId
instance Show BufferId
instance Eq BufferId
instance Show SyncId
instance Read SyncId
instance Eq SyncId
instance Ord SyncId


-- | Synth Definitions in SuperCollider are how you define the way synths
--   should sound -- you describe parameters and a graph of sound
--   generators, add them to the server with <a>defineSD</a>, and then
--   create instances of the Synth Definition (called "synths"), which each
--   play separately. You can set parameters of the synth at any time while
--   they're playing
--   
--   Usually, you shouldn't be making <a>SynthDef</a>s explicitly --
--   there's a state monad <a>SDState</a> which lets you construct
--   synthdefs like so:
--   
--   <pre>
--   test :: SynthDef
--   test = <a>sdNamed</a> "testSynthDef" [("note", 0)] $ do
--      s &lt;- 0.1 <a>~*</a> <a>sinOsc</a> (Freq $ <a>midiCPS</a> "note")
--      out 0 [s, s]
--   
--   </pre>
--   
--   You then optionally explicitly send the synth definition to the SC
--   server with
--   
--   <pre>
--   &gt;&gt;&gt; defineSD test
--   </pre>
--   
--   You then create a synth from the synthdef like:
--   
--   <pre>
--   &gt;&gt;&gt; s &lt;- synth "testSynthDef" [("note", 45)]
--   </pre>
--   
--   Or, alternately:
--   
--   <pre>
--   &gt;&gt;&gt; s &lt;- synth test [("note", 45)]
--   </pre>
--   
--   This returns a <a>NodeId</a> which is a reference to the synth, which
--   you can use to e.g. change the params of the running synth with e.g.
--   
--   <pre>
--   &gt;&gt;&gt; set s [("note", 38)]
--   </pre>
--   
--   Then you can free it (stop its playing) with
--   
--   <pre>
--   &gt;&gt;&gt; free s
--   </pre>
module Vivid.SynthDef

-- | Create a real live music-playing synth from a boring, dead SynthDef.
--   
--   If you haven't defined the SynthDef on the server, this will do it
--   automatically (Note that this may cause jitters in musical timing)
--   
--   Uses <a>HasSynthRef</a> so that given...
--   
--   <pre>
--   &gt;&gt;&gt; let foo = sdNamed "foo" [] $ out 0 [0.1 ~* whiteNoise]
--   </pre>
--   
--   ...you can create a synth either with...
--   
--   <pre>
--   &gt;&gt;&gt; synth "foo" []
--   </pre>
--   
--   ...or...
--   
--   <pre>
--   &gt;&gt;&gt; synth foo []
--   </pre>
--   
--   Careful!: The SC server doesn't keep track of your nodes for you, so
--   if you do something like...
--   
--   <pre>
--   &gt;&gt;&gt; s &lt;- synth "someSynth" []
--   
--   &gt;&gt;&gt; s &lt;- synth "oops" []           -- 's' is overwritten
--   </pre>
--   
--   ...you've got no way to refer to the first synth you've created, and
--   if you want to stop it you have to <a>cmdPeriod</a>
synth :: HasSynthRef a => a -> [(String, Float)] -> IO NodeId

-- | Set the given parameters of a running synth
--   
--   e.g.
--   
--   <pre>
--   &gt;&gt;&gt; let setTest = sd [("pan", 0.5)] $ out 0 =&lt;&lt; pan2 (In $ 0.1 ~* whiteNoise) (Pos "pan")
--   
--   &gt;&gt;&gt; s &lt;- synth setTest []
--   
--   &gt;&gt;&gt; set s [("pan", -0.5)]
--   </pre>
--   
--   Any parameters not referred to will be unaffected, and any you specify
--   that don't exist will be (silently) ignored
set :: NodeId -> [(String, Float)] -> IO ()

-- | Immediately stop a synth playing
--   
--   This can create a "clipping" artifact if the sound goes from a high
--   amplitude to 0 in an instant -- you can avoid that with e.g.
--   <a>lag</a>
free :: NodeId -> IO ()

-- | Internal representation of Synth Definitions. Usually, use <a>sd</a>
--   instead of making these by hand.
--   
--   This representation (especially <a>_sdUGens</a>) might change in the
--   future.
data SynthDef
SynthDef :: SDName -> [(ByteString, Float)] -> Map Int UGen -> SynthDef
_sdName :: SynthDef -> SDName
_sdParams :: SynthDef -> [(ByteString, Float)]
_sdUGens :: SynthDef -> Map Int UGen

-- | Representation of Unit Generators. You usually won't be creating these
--   by hand, but instead using things from the library in <a>UGens</a>
data UGen
UGen :: UGenName -> CalculationRate -> [Signal] -> Int -> UGen
_ugenName :: UGen -> UGenName
_ugenCalculationRate :: UGen -> CalculationRate
_ugenIns :: UGen -> [Signal]
_ugenNumOuts :: UGen -> Int

-- | Alias for <a>addMonoUGen</a>
addUGen :: UGen -> SDState Signal

-- | Add a unit generator with one output
addMonoUGen :: UGen -> SDState Signal

-- | Polyphonic -- returns a list of <a>Signal</a>s. In the future this
--   might be a tuple instead of a list
addPolyUGen :: UGen -> SDState [Signal]
class ToSig s
toSig :: ToSig s => s -> Signal
class ToSigM s
toSigM :: ToSigM s => s -> SDState Signal
data Signal
Constant :: Float -> Signal
Param :: ByteString -> Signal
UGOut :: Int -> Int32 -> Signal
encodeSD :: SynthDef -> ByteString

-- | Send a synth definition to be loaded on the SC server
--   
--   Note that this is sort of optional -- if you don't call it, it'll be
--   called the first time you call <a>synth</a> with the SynthDef
defineSD :: SynthDef -> IO ()

-- | Define a Synth Definition
sd :: [(String, Float)] -> SDState x -> SynthDef

-- | Define a Synth Definition and give it a name you can refer to from
--   e.g. sclang
sdNamed :: String -> [(String, Float)] -> SDState x -> SynthDef
sdPretty :: SynthDef -> String

-- | Set the calculation rate of a UGen
--   
--   e.g.
--   
--   <pre>
--   play $ do
--      s0 &lt;- 1 ~+ (lfSaw (Freq 1) ? KR)
--      s1 &lt;- 0.1 ~* lfSaw (Freq $ 220 ~* s0)
--      out 0 [s1, s1]
--   </pre>
--   
--   Mnemonic: "?" is like thinking
--   
--   In the future, the representation of calculation rates definitely may
--   change
(?) :: SDState Signal -> CalculationRate -> SDState Signal

-- | Given a UGen graph, just start playing it right away.
--   
--   e.g.
--   
--   <pre>
--   play $ do
--      s &lt;- 0.2 ~* lpf (In whiteNoise) (Freq 440)
--      out 0 [s, s]
--   </pre>
play :: SDState a -> IO NodeId

-- | Your "emergency" button. Run this and everything playing on the SC
--   server will be freed -- silence!
--   
--   Corresponds to the cmd-. / ctrl-. key command in the SuperCollider IDE
cmdPeriod :: IO ()
data DoneAction
DoNothing :: DoneAction
FreeEnclosing :: DoneAction
doneActionNum :: DoneAction -> Float
sdLitPretty :: LiteralSynthDef -> String
class HasSynthRef a
sdToLiteral :: SynthDef -> LiteralSynthDef

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s
getCalcRate :: Signal -> SDState CalculationRate

-- | Unary signal operations. Many of these have functions so you don't
--   need to use this internal representation (e.g. <a>Neg</a> has
--   <tt>neg</tt>, etc).
--   
--   This type might not be exposed in the future.
data UnaryOp
Neg :: UnaryOp
Not :: UnaryOp
IsNil :: UnaryOp
NotNil :: UnaryOp
BitNot :: UnaryOp
Abs :: UnaryOp
AsFloat :: UnaryOp
AsInt :: UnaryOp
Ciel :: UnaryOp
Floor :: UnaryOp
Frac :: UnaryOp
Sign :: UnaryOp
Squared :: UnaryOp
Cubed :: UnaryOp
Sqrt :: UnaryOp
Exp :: UnaryOp
Recip :: UnaryOp
MIDICPS :: UnaryOp
CPSMIDI :: UnaryOp
MIDIRatio :: UnaryOp
RatioMIDI :: UnaryOp
DbAmp :: UnaryOp
AmpDb :: UnaryOp
OctCPS :: UnaryOp
CPSOct :: UnaryOp
Log :: UnaryOp
Log2 :: UnaryOp
Log10 :: UnaryOp
Sin :: UnaryOp
Cos :: UnaryOp
Tan :: UnaryOp
ArcSin :: UnaryOp
ArcCos :: UnaryOp
ArcTan :: UnaryOp
SinH :: UnaryOp
CosH :: UnaryOp
TanH :: UnaryOp
Rand :: UnaryOp
Rand2 :: UnaryOp
LinRand :: UnaryOp
BiLinRand :: UnaryOp
Sum3Rand :: UnaryOp
Distort :: UnaryOp
SoftClip :: UnaryOp
Coin :: UnaryOp
DigitValue :: UnaryOp
Silence :: UnaryOp
Thru :: UnaryOp
RectWindow :: UnaryOp
HanWindow :: UnaryOp
WelchWindow :: UnaryOp
TriWindow :: UnaryOp
Ramp :: UnaryOp
SCurve :: UnaryOp
NumUnarySelectors :: UnaryOp
uOpToSpecialI :: UnaryOp -> Int16
specialIToUOp :: Int16 -> UnaryOp

-- | Binary signal operations. For the simple ones (like <a>Add</a>,
--   <a>Mul</a>, etc.), there are functions (like <a>~+</a>, <a>~*</a>,
--   etc.) that wrap them up so you don't have to make a ugen for them
--   yourself.
--   
--   In the future these may not be exported -- we'll just have functions
--   for all of them.
data BinaryOp
Add :: BinaryOp
Sub :: BinaryOp
Mul :: BinaryOp

-- | Integer division
IDiv :: BinaryOp

-- | Float division
FDiv :: BinaryOp
Mod :: BinaryOp
Eq :: BinaryOp
Ne :: BinaryOp
Lt :: BinaryOp
Gt :: BinaryOp
Le :: BinaryOp
Ge :: BinaryOp
Min :: BinaryOp
Max :: BinaryOp
BitAnd :: BinaryOp
BitOr :: BinaryOp
BitXor :: BinaryOp
Lcm :: BinaryOp
Gcd :: BinaryOp
Round :: BinaryOp
RoundUp :: BinaryOp
Trunc :: BinaryOp
Atan2 :: BinaryOp
Hypot :: BinaryOp
Hypotx :: BinaryOp
Pow :: BinaryOp
ShiftLeft :: BinaryOp
ShiftRight :: BinaryOp
UnsignedShift :: BinaryOp
Fill :: BinaryOp

-- | a * (b + 1) == a * b + a
Ring1 :: BinaryOp

-- | a * b + a + b
Ring2 :: BinaryOp

-- | a * a * b
Ring3 :: BinaryOp

-- | a * a * b - a * b * b
Ring4 :: BinaryOp

-- | a * a - b * b
DifSqr :: BinaryOp

-- | a * a + b * b
SumSqr :: BinaryOp

-- | (a + b) ^ 2
SqrSum :: BinaryOp

-- | (a - b) ^ 2
SqrDif :: BinaryOp

-- | abs(a - b)
AbsDif :: BinaryOp
Thresh :: BinaryOp
AMClip :: BinaryOp
ScaleNeg :: BinaryOp
Clip2 :: BinaryOp
Excess :: BinaryOp
Fold2 :: BinaryOp
Wrap2 :: BinaryOp
FirstArg :: BinaryOp
RandRange :: BinaryOp
ExpRandRange :: BinaryOp
NumBinarySelectors :: BinaryOp
biOpToSpecialI :: BinaryOp -> Int16
specialIToBiOp :: Int16 -> BinaryOp
instance Show DoneAction
instance Eq DoneAction
instance Hashable SynthDef


-- | These are named the same as their SC counterparts, usually. Sometimes
--   not, if the names are long or if the names would clash w/ common other
--   names.
module Vivid.UGens.Args
data Buf
Buf :: i -> Buf
data Bus
Bus :: i -> Bus
data Damp
Damp :: i -> Damp
data Dur
Dur :: i -> Dur
data End
End :: i -> End
data Freq
Freq :: i -> Freq
data Hi
Hi :: i -> Hi
data In
In :: i -> In
data Lo
Lo :: i -> Lo
data MaxVal
MaxVal :: i -> MaxVal
data MinVal
MinVal :: i -> MinVal
data Mix
Mix :: i -> Mix
data NumChans
NumChans :: i -> NumChans
data NumFrames
NumFrames :: i -> NumFrames
data Phase
Phase :: i -> Phase
data Pos
Pos :: i -> Pos
data Ratio
Ratio :: i -> Ratio
data Room
Room :: i -> Room
data Rq
Rq :: i -> Rq
data SawFreq
SawFreq :: i -> SawFreq
data Secs
Secs :: s -> Secs
data Start
Start :: i -> Start
data SyncFreq
SyncFreq :: i -> SyncFreq
data Trigger
Trigger :: i -> Trigger
data Width
Width :: i -> Width
data Wipe
Wipe :: i -> Wipe


-- | Unit Generators, which are the signal-generating/processing components
--   of synths.
--   
--   Most of your time reading documentation will probably be in this
--   module
--   
--   Most of these take named arguments with types like <a>In</a>,
--   <a>Freq</a>, etc. This just means you construct them with the same
--   data constructor. The data constructor is the same as its type
--   (<a>In</a> and <a>In</a>, etc.). So e.g. to make a lowpass filter
--   which filters whitenoise at 440hz, you'd write:
--   
--   <pre>
--   lpf (In whiteNoise) (Freq 440)
--   </pre>
--   
--   This is far from all the ones in SC, so I've exposed the internals so
--   you can make your own when you want. Some exports may disappear in
--   future versions.
module Vivid.UGens

-- | "A non-band-limited triangle oscillator. Output ranges from -1 to +1."
lfTri :: Freq -> SDState Signal

-- | "A non-band-limited sawtooth oscillator. Output ranges from -1 to +1."
lfSaw :: Freq -> SDState Signal

-- | Sine wave
sinOsc :: Freq -> SDState Signal
fSinOsc :: Freq -> SDState Signal

-- | "Generates noise whose spectrum has equal power at all frequencies."
whiteNoise :: SDState Signal

-- | "Generates noise whose spectrum falls off in power by 3 dB per octave.
--   This gives equal power over the span of each octave. This version
--   gives 8 octaves of pink noise."
pinkNoise :: SDState Signal

-- | "Generates noise whose spectrum falls off in power by 6 dB per
--   octave."
brownNoise :: SDState Signal

-- | "Generates an exponential curve from the start value to the end value.
--   Both the start and end values must be non-zero and have the same
--   sign."
--   
--   Defaults to KR
xLine :: Start -> End -> Dur -> DoneAction -> SDState Signal

-- | "Generates a line from the start value to the end value."
--   
--   Defaults to KR
line :: Start -> End -> Dur -> DoneAction -> SDState Signal

-- | Bus input (usually mic). "0" because it's from the 0th bus
soundIn0 :: SDState Signal
mouseX :: MinVal -> MaxVal -> SDState Signal
mouseY :: MinVal -> MaxVal -> SDState Signal

-- | Band-pass filter
bpf :: In -> Freq -> Rq -> SDState Signal

-- | Low-pass filter
lpf :: In -> Freq -> SDState Signal

-- | High-pass filter
hpf :: In -> Freq -> SDState Signal

-- | Unlike in SuperCollider, you don't specify a "lo" parameter -- "lo" is
--   always negative "hi"
clip :: In -> Hi -> SDState Signal

-- | Play a 1-channel buffer
playBuf1 :: Buf -> SDState Signal

-- | Record a 1-channel buffer
recordBuf1 :: In -> Buf -> SDState Signal

-- | Add a single LocalBuf for FFT
localBuf :: NumFrames -> NumChans -> SDState Signal
fft :: Buf -> In -> SDState Signal
ifft :: Buf -> SDState Signal
pv_binScramble :: Buf -> Wipe -> Width -> Trigger -> SDState Signal
pv_randComb :: Buf -> Wipe -> Trigger -> SDState Signal
(~*) :: (ToSigM sig0, ToSigM sig1) => sig0 -> sig1 -> SDState Signal
(~+) :: (ToSigM i0, ToSigM i1) => i0 -> i1 -> SDState Signal
(~/) :: (ToSigM i0, ToSigM i1) => i0 -> i1 -> SDState Signal
(~-) :: (ToSigM i0, ToSigM i1) => i0 -> i1 -> SDState Signal
(~>) :: (ToSigM i0, ToSigM i1) => i0 -> i1 -> SDState Signal

-- | Convert from a midi note number (0-127, each representing a musical
--   half step) to a frequency in hz (cycles per second)
midiCPS :: ToSigM i => i -> SDState Signal

-- | Inverse of <a>midiCPS</a>
cpsMIDI :: ToSigM i => i -> SDState Signal

-- | The prime is to not conflict with "abs" in the prelude. May just use
--   "uOp Abs" in the future
abs' :: ToSigM i => i -> SDState Signal
neg :: ToSigM i => i -> SDState Signal

-- | Build your own!
binaryOp :: (ToSigM s0, ToSigM s1) => BinaryOp -> s0 -> s1 -> SDState Signal

-- | Alias of <a>binaryOp</a>. Shorter, fer livecodin
biOp :: (ToSigM s0, ToSigM s1) => BinaryOp -> s0 -> s1 -> SDState Signal

-- | Build your own, from <a>UnaryOp</a>s
unaryOp :: ToSigM sig => UnaryOp -> sig -> SDState Signal

-- | Alias of <a>unaryOp</a>
uOp :: ToSigM sig => UnaryOp -> sig -> SDState Signal
varSaw :: Freq -> Width -> SDState Signal
syncSaw :: SyncFreq -> SawFreq -> SDState Signal
impulse :: Freq -> SDState Signal

-- | <tt>pos</tt> is -1 to 1
pan2 :: In -> Pos -> SDState [Signal]
out :: ToSigM i => Float -> [i] -> SDState [Signal]
lfPar :: Freq -> SDState Signal
lfCub :: Freq -> SDState Signal
lfPulse :: Freq -> Width -> SDState Signal

-- | Mixes down a list of audio rate inputs to one. The list can't be
--   empty.
--   
--   This is more efficient than e.g. <tt>foldl1 (~+)</tt>
mix :: ToSigM s => [s] -> SDState Signal
freeVerb :: In -> Mix -> Room -> Damp -> SDState Signal
pitchShift :: In -> Ratio -> SDState Signal

-- | The "Secs" arg is the same as the "lagTime" arg in SC
lag :: In -> Secs -> SDState Signal


-- | For an intro to all this, check out <a>http://amindfv.com/vivid</a> or
--   the <a>Vivid.SynthDef</a> module
module Vivid
sleep :: Float -> IO ()
