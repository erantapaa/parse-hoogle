-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Unification in a Commutative Monoid
--   
@package cmu
@version 1.10


-- | Linear Diophantine Equation solver.
--   
--   The solver uses the algorithm of Contejean and Devie as specified in
--   "An Efficient Incremental Algorithm for Solving Systems of Linear
--   Diophantine Equations", Information and Computation Vol. 113, pp.
--   143-174, 1994.
--   
--   The algorithm for systems of homogeneous linear Diophantine equations
--   follows. Let e[k] be the kth basis vector for 1 &lt;= k &lt;= n. To
--   find the minimal, non-negative solutions M to the system of equations
--   sum(i=1,n,a[i]*v[i]) = 0, the algorithm of Contejean and Devie is:
--   
--   <ol>
--   <li>[init] A := {e[k] | 1 &lt;= k &lt;= n}; M := {}</li>
--   <li>[new minimal results] M := M + {a in A | a is a solution}</li>
--   <li>[unnecessary branches] A := {a in A | all m in M : some 1 &lt;= k
--   &lt;= n : m[k] &lt; a[k]}</li>
--   <li>[breadth-first search] A := {a + e[k] | a in A, 1 &lt;= k &lt;= n,
--   &lt;sum(i=1,n,a[i]*v[i]),v[k]&gt; &lt; 0}</li>
--   <li>[test] If A = {}, stop, else go to 2.</li>
--   </ol>
--   
--   This module provides a solver for a single linear Diophantine equation
--   a*v = b, where a and v are vectors, not matrices.
--   
--   When solving an inhomogeneous equation, it uses the homogeneous solver
--   after adding -b as the first element of v and by bounding the first
--   element of a to be one at each step in the computation. The first
--   element of a solution is zero if it is a solution to the associated
--   homogeneous equation, and one if it is a solution to the inhomogeneous
--   equation.
--   
--   The algorithm is likely to be Fortenbacher's algorithm, the one
--   generalized to systems of equations by Contejean and Devie, but I have
--   not been able to verified this fact.
module Algebra.CommutativeMonoid.LinDiophEq

-- | The <a>linDiophEq</a> function takes a list of integers that specifies
--   the coefficients of linear Diophantine equation and a constant, and
--   returns the equation's minimal, non-negative solutions.
--   
--   When solving an inhomogeneous equation, the first element of a
--   solution is zero if it solves the associated homogeneous equation, and
--   one otherwise.
--   
--   Thus to solve 2x + y - z = 2, use
--   
--   <pre>
--   linDiophEq [2,1,-1] 2 = [[0,0,1,1],[1,1,0,0],[0,1,0,2],[1,0,2,0]]
--   </pre>
--   
--   The two minimal solutions to the homogeneous equation are [0,1,1] and
--   [1,0,2], so any linear combinations of these solutions contributes to
--   a solution. The solution that corresponds to [1,0,0] is x = w + 1, y =
--   v, and z = v + 2w. The solution that corresponds to [0,2,0] is x = w,
--   y = v + 2, and z = v + 2w.
linDiophEq :: [Int] -> Int -> [[Int]]


-- | This module provides unification in a commutative monoid.
--   
--   In this module, a commutative monoid is a free algebra over a
--   signature with two function symbols:
--   
--   <ul>
--   <li>the binary symbol +, the monoid operator,<ul><li>a constant 0, the
--   identity element, and</li></ul></li>
--   </ul>
--   
--   The algebra is generated by a set of variables. Syntactically, a
--   variable is an identifer such as x and y (see <a>isVar</a>).
--   
--   The axioms associated with the algebra are:
--   
--   <ul>
--   <li><i>Communtativity</i> x + y = y + x</li>
--   <li><i>Associativity</i> (x + y) + z = x + (y + z)</li>
--   <li><i>Identity Element</i> x + 0 = x</li>
--   </ul>
--   
--   A substitution maps variables to terms. A substitution s is applied to
--   a term as follows.
--   
--   <ul>
--   <li>s(0) = 0<ul><li>s(t + t') = s(t) + s(t')</li></ul></li>
--   </ul>
--   
--   The unification problem is given the problem statement t =? t', find a
--   most general substitution s such that s(t) = s(t') modulo the axioms
--   of the algebra. Substitition s is more general than s' if there is a
--   substitition s" such that s' = s" o s.
module Algebra.CommutativeMonoid.Unification

-- | A term in a commutative monoid is represented by the identity element,
--   or as the sum of factors. A factor is the product of a positive
--   integer coefficient and a variable. No variable occurs twice in a
--   term. For the show and read methods, zero is the identity element, the
--   plus sign is the monoid operation.
data Term

-- | <a>ide</a> represents the identity element (zero).
ide :: Term

-- | A variable is an alphabetic Unicode character followed by a sequence
--   of alphabetic or numeric digit Unicode characters. The show method for
--   a term works correctly when variables satisfy the <a>isVar</a>
--   predicate.
isVar :: String -> Bool

-- | Return a term that consists of a single variable.
var :: String -> Term

-- | Multiply every coefficient in a term by an non-negative integer.
mul :: Int -> Term -> Term

-- | Add two terms.
add :: Term -> Term -> Term

-- | Return all variable-coefficient pairs in the term in ascending
--   variable order.
assocs :: Term -> [(String, Int)]

-- | An equation is a pair of terms. For the show and read methods, the two
--   terms are separated by an equal sign.
newtype Equation
Equation :: (Term, Term) -> Equation

-- | A substitution maps variables into terms. For the show and read
--   methods, the substitution is a list of maplets, and the variable and
--   the term in each element of the list are separated by a colon.
data Substitution

-- | Construct a substitution from a list of variable-term pairs.
subst :: [(String, Term)] -> Substitution

-- | Return all variable-term pairs in ascending variable order.
maplets :: Substitution -> [(String, Term)]

-- | Return the result of applying a substitution to a term.
apply :: Substitution -> Term -> Term

-- | Given <a>Equation</a> (t0, t1), return a most general substitution s
--   such that s(t0) = s(t1) modulo the equational axioms of a commutative
--   monoid.
unify :: Equation -> Substitution
instance Eq Term
instance Eq Equation
instance Eq Substitution
instance Eq Maplet
instance Read Substitution
instance Show Substitution
instance Read Maplet
instance Show Maplet
instance Read Equation
instance Show Equation
instance Read Term
instance Show Term
