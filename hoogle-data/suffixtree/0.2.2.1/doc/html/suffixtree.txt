-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient, lazy suffix tree implementation
--   
--   An efficient, lazy suffix tree implementation.
@package suffixtree
@version 0.2.2.1


-- | A lazy, efficient suffix tree implementation.
--   
--   Since many function names (but not the type name) clash with
--   <a>Prelude</a> names, this module is usually imported
--   <tt>qualified</tt>, e.g.
--   
--   <pre>
--   import Data.SuffixTree (STree)
--   import qualified Data.SuffixTree as T
--   </pre>
--   
--   The implementation is based on the first of those described in the
--   following paper:
--   
--   <ul>
--   <li>Robert Giegerich and Stefan Kurtz, "/A comparison of imperative
--   and purely functional suffix tree constructions/", Science of Computer
--   Programming 25(2-3):187-218, 1995,
--   <a>http://citeseer.ist.psu.edu/giegerich95comparison.html</a></li>
--   </ul>
--   
--   This implementation constructs the suffix tree lazily, so subtrees are
--   not created until they are traversed. Two construction functions are
--   provided, <a>constructWith</a> for sequences composed of small
--   alphabets, and <a>construct</a> for larger alphabets.
--   
--   Estimates are given for performance. The value <i>k</i> is a constant;
--   <i>n</i> is the length of a query string; and <i>t</i> is the number
--   of elements (nodes and leaves) in a suffix tree.
module Data.SuffixTree

-- | The list of symbols that <a>constructWith</a> can possibly see in its
--   input.
type Alphabet a = [a]

-- | An edge in the suffix tree.
type Edge a = (Prefix a, STree a)

-- | The prefix string associated with an <a>Edge</a>. Use <a>mkPrefix</a>
--   to create a value of this type, and <a>prefix</a> to deconstruct one.
data Prefix a

-- | The suffix tree type. The implementation is exposed to ease the
--   development of custom traversal functions. Note that
--   <tt>(<a>Prefix</a> a, <a>STree</a> a)</tt> pairs are not stored in any
--   order.
data STree a
Node :: [Edge a] -> STree a
Leaf :: STree a

-- | <i>O(k n log n)</i>. Constructs a suffix tree using the given
--   alphabet. The performance of this function is linear in the size
--   <i>k</i> of the alphabet. That makes this function suitable for small
--   alphabets, such as DNA nucleotides. For an alphabet containing more
--   than a few symbols, <a>construct</a> is usually several orders of
--   magnitude faster.
constructWith :: Eq a => Alphabet a -> [a] -> STree a

-- | <i>O(n log n)</i>. Constructs a suffix tree.
construct :: Ord a => [a] -> STree a

-- | <i>O(n)</i>. Indicates whether the suffix tree contains the given
--   sublist. Performance is linear in the length <i>n</i> of the sublist.
elem :: Eq a => [a] -> STree a -> Bool

-- | <i>O(n)</i>. Finds the given subsequence in the suffix tree. On
--   failure, returns <a>Nothing</a>. On success, returns the <a>Edge</a>
--   in the suffix tree at which the subsequence ends, along with the
--   number of elements to drop from the prefix of the <a>Edge</a> to get
--   the "real" remaining prefix.
--   
--   Here is an example:
--   
--   <pre>
--   &gt; find "ssip" (construct "mississippi")
--   Just ((mkPrefix "ppi",Leaf),1)
--   </pre>
--   
--   This indicates that the edge <tt>(<a>mkPrefix</a>
--   "ppi",<a>Leaf</a>)</tt> matches, and that we must strip 1 character
--   from the string <tt>"ppi"</tt> to get the remaining prefix string
--   <tt>"pi"</tt>.
--   
--   Performance is linear in the length <i>n</i> of the query list.
findEdge :: Eq a => [a] -> STree a -> Maybe (Edge a, Int)

-- | <i>O(n)</i>. Finds the subtree rooted at the end of the given query
--   sequence. On failure, returns <a>Nothing</a>.
--   
--   Performance is linear in the length <i>n</i> of the query list.
findTree :: Eq a => [a] -> STree a -> Maybe (STree a)

-- | <i>O(n)</i>. Returns the path from the <a>Edge</a> in the suffix tree
--   at which the given subsequence ends, up to the root of the tree. If
--   the subsequence is not found, returns the empty list.
--   
--   Performance is linear in the length of the query list.
findPath :: Eq a => [a] -> STree a -> [Edge a]

-- | <i>O(t)</i>. Count the number of leaves in a tree.
--   
--   Performance is linear in the number <i>t</i> of elements in the tree.
countLeaves :: STree a -> Int

-- | <i>O(n + r)</i>. Count the number of times a sequence is repeated in
--   the input sequence that was used to construct the suffix tree.
--   
--   Performance is linear in the length <i>n</i> of the input sequence,
--   plus the number of times <i>r</i> the sequence is repeated.
countRepeats :: Eq a => [a] -> STree a -> Int

-- | <i>O(t)</i>. Folds the edges in a tree, using post-order traversal.
--   Suitable for lazy use.
foldr :: (Prefix a -> b -> b) -> b -> STree a -> b

-- | <i>O(t)</i>. Folds the edges in a tree, using pre-order traversal. The
--   step function is evaluated strictly.
foldl :: (a -> Prefix b -> a) -> a -> STree b -> a

-- | <i>O(t)</i>. Generic fold over a tree.
--   
--   A few simple examples.
--   
--   <pre>
--   countLeaves == fold id id (const const) (1+) 0
--   </pre>
--   
--   <pre>
--   countEdges = fold id id (\_ a _ -&gt; a+1) id 0
--   </pre>
--   
--   This more complicated example generates a tree of the same shape, but
--   new type, with annotated leaves.
--   
--   <pre>
--   data GenTree a b = GenNode [(<a>Prefix</a> a, GenTree a b)]
--                    | GenLeaf b
--                      deriving (<a>Show</a>)
--   </pre>
--   
--   <pre>
--   gentree :: <a>STree</a> a -&gt; GenTree a Int
--   gentree = <a>fold</a> reset id fprefix reset leaf
--       where leaf = GenLeaf 1
--             reset = <a>const</a> leaf
--             fprefix p t (GenLeaf _) = GenNode [(p, t)]
--             fprefix p t (GenNode es) = GenNode ((p, t):es)
--   </pre>
fold :: (a -> a) -> (a -> a) -> (Prefix b -> a -> a -> a) -> (a -> a) -> a -> STree b -> a

-- | <i>O(1)</i>. Construct a <a>Prefix</a> value.
mkPrefix :: [a] -> Prefix a

-- | <i>O(n)</i>. Obtain the list stored in a <a>Prefix</a>.
prefix :: Prefix a -> [a]

-- | <i>O(n)</i>. Returns all non-empty suffixes of the argument, longest
--   first. Behaves as follows:
--   
--   <pre>
--   suffixes xs == init (tails xs)
--   </pre>
suffixes :: [a] -> [[a]]
instance Show a => Show (Length a)
instance Show a => Show (STree a)
instance Functor STree
instance Functor Prefix
instance Show a => Show (Prefix a)
instance Ord a => Ord (Prefix a)
instance Eq a => Eq (Prefix a)
