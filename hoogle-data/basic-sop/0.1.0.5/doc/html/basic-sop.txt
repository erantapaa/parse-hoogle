-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Basic examples and functions for generics-sop
--   
@package basic-sop
@version 0.1.0.5


-- | Generic reduction to normal form.
--   
--   This module contains a generic function that reduces a value to normal
--   form, defined using <tt>generics-sop</tt>.
module Generics.SOP.NFData

-- | Generic reduction to normal form.
--   
--   This function is a generic implementation of the <a>rnf</a> function
--   that can be used to instantiate the <a>NFData</a> class in
--   <tt>deepseq</tt>.
--   
--   Assuming you have a <a>Generic</a> instance for your datatype
--   <tt>T</tt>, you can use <a>grnf</a> as follows:
--   
--   <pre>
--   instance NFData T where
--     rnf = grnf
--   </pre>
grnf :: (Generic a, All2 NFData (Code a)) => a -> ()


-- | Generic computation of a skeleton.
--   
--   $skeleton
module Generics.SOP.Skeleton

-- | Generic computation of a skeleton.
--   
--   A skeleton for a record type has a defined "spine" but is undefined
--   everywhere else. For instance, a skeleton for pairs would be
--   
--   <pre>
--   (undefined, undefined)
--   </pre>
--   
--   We introduce a type class for this purpose because the skeleton for
--   nested records would look like
--   
--   <pre>
--   (undefined, (undefined, undefined))
--   </pre>
--   
--   The default instance of <a>skeleton</a> applies to record types; for
--   everything else, use undefined (or error):
--   
--   <pre>
--   instance Skeleton SomeRecordType -- no where clause
--   </pre>
--   
--   or
--   
--   <pre>
--   instance Skeleton SomeNonRecordType where skeleton = undefined
--   </pre>
--   
--   This is an example of how SOP-style generic functions can be used with
--   <tt>DefaultSignatures</tt>.
--   
--   Furthermore, metadata is used in order to produce better error
--   messages. For the undefined components of a record, an error is
--   triggered that mentions the name of the field.
class Skeleton a where skeleton = gskeleton
skeleton :: Skeleton a => a
instance Typeable Skeleton
instance Skeleton Text
instance Skeleton Bool
instance Skeleton Rational
instance Skeleton Double
instance Skeleton Int
instance Skeleton (Maybe a)
instance Skeleton [a]


-- | Generic show.
--   
--   This module contains a generic show function defined using
--   <tt>generics-sop</tt>.
module Generics.SOP.Show

-- | Generic show.
--   
--   This function is a proof-of-concept implementation of a function that
--   is similar to the <a>show</a> function you get by using 'deriving
--   Show'.
--   
--   It serves as an example of an SOP-style generic function that makes
--   use of metadata. However, it does currently not handle parentheses
--   correctly, and is therefore not really usable as a replacement.
--   
--   If you want to use it anyway on a datatype <tt>T</tt> for which you
--   have a <a>Generic</a> instance, you can use <a>gshow</a> as follows:
--   
--   <pre>
--   instance Show T where
--     show = gshow
--   </pre>
gshow :: (Generic a, HasDatatypeInfo a, All2 Show (Code a)) => a -> String


-- | Generic generation of random test cases.
--   
--   This module contains a generic version of <a>arbitrary</a> from the
--   <a>Test.Quickcheck</a> library, using <tt>generics-sop</tt>.
module Generics.SOP.Arbitrary

-- | Generic generation of random test cases.
--   
--   This function is a proof-of-concept implementation of a generic
--   <a>arbitrary</a> that can be used to instantiate the <a>Arbitrary</a>
--   class in <tt>QuickCheck</tt>.
--   
--   If you want to use it on a datatype <tt>T</tt> for which you have a
--   <a>Generic</a> instance, you can say:
--   
--   <pre>
--   instance Arbitrary T where
--     arbitrary = garbitrary
--   </pre>
--   
--   Note that currently no attempts are being made to generate arbitrary
--   values of a particular size, and it is possible that this function
--   diverges for recursive structures.
garbitrary :: (Generic a, All2 Arbitrary (Code a)) => Gen a

-- | Random generation and shrinking of values.
class Arbitrary a
arbitrary :: Arbitrary a => Gen a
shrink :: Arbitrary a => a -> [a]


-- | Generic equality.
--   
--   This module contains a generic equality function defined using
--   <tt>generics-sop</tt>.
module Generics.SOP.Eq

-- | Generic equality.
--   
--   This function reimplements the built-in generic equality that you get
--   by using <tt>deriving Eq</tt>.
--   
--   Assuming you have a <a>Generic</a> instance for a datatype <tt>T</tt>,
--   you can use <a>geq</a> as follows:
--   
--   <pre>
--   instance Eq T where
--     (==) = geq
--   </pre>
geq :: (Generic a, All2 Eq (Code a)) => a -> a -> Bool
