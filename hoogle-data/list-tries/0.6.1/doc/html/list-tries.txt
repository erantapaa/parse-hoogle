-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tries and Patricia tries: finite sets and maps for list keys
--   
@package list-tries
@version 0.6.1

module Data.ListTrie.Base.Map

-- | Minimal complete implementation:
--   
--   <ul>
--   <li><a>eqCmp</a></li>
--   <li><a>null</a></li>
--   <li><a>lookup</a></li>
--   <li><a>alter</a></li>
--   <li><a>unionWithKey</a>, <a>differenceWithKey</a>,
--   <a>intersectionWithKey</a></li>
--   <li><a>toListKV</a></li>
--   <li><a>empty</a> or <tt>fromList</tt> or <tt>fromListWith</tt></li>
--   <li><a>isSubmapOfBy</a></li>
--   </ul>
--   
--   For decent performance, supplying at least <a>mapAccumWithKey</a> and
--   <a>filter</a> as well is probably a good idea.
class Foldable (m k) => Map m k where empty = fromListKV [] singleton k v = insert k v empty doubleton k v = insert k v .: singleton insert = insertWith const insertWith f k v = alter (\ mold -> Just $ case mold of { Nothing -> v Just old -> f v old }) k adjust f = update (Just . f) delete = update (const Nothing) update f = alter (f =<<) unionWith = unionWithKey . const differenceWith = differenceWithKey . const intersectionWith = intersectionWithKey . const map = mapWithKey . const mapWithKey f = snd . mapAccumWithKey (\ _ k v -> ((), f k v)) () mapAccum f = mapAccumWithKey (const . f) mapAccumWithKey f z = second fromListKV . mapAccumL (\ a (k, v) -> fmap ((,) k) (f a k v)) z . toListKV filter p = fromListKV . filter (p . snd) . toListKV fromListKV = fromListKVWith const fromListKVWith f = foldr (uncurry $ insertWith f) empty serializeToList = toListKV deserializeFromList = fromListKV singletonView m = case toListKV m of { [x] -> Just x _ -> Nothing }
eqCmp :: Map m k => m k a -> k -> k -> Bool
empty :: Map m k => m k a
singleton :: Map m k => k -> a -> m k a
doubleton :: Map m k => k -> a -> k -> a -> m k a
null :: Map m k => m k a -> Bool
lookup :: Map m k => k -> m k a -> Maybe a
insertWith :: Map m k => (a -> a -> a) -> k -> a -> m k a -> m k a
insert :: Map m k => k -> a -> m k a -> m k a
update :: Map m k => (a -> Maybe a) -> k -> m k a -> m k a
adjust :: Map m k => (a -> a) -> k -> m k a -> m k a
delete :: Map m k => k -> m k a -> m k a
alter :: Map m k => (Maybe a -> Maybe a) -> k -> m k a -> m k a
unionWith :: Map m k => (a -> a -> a) -> m k a -> m k a -> m k a
differenceWith :: Map m k => (a -> b -> Maybe a) -> m k a -> m k b -> m k a
intersectionWith :: Map m k => (a -> b -> c) -> m k a -> m k b -> m k c
unionWithKey :: Map m k => (k -> a -> a -> a) -> m k a -> m k a -> m k a
differenceWithKey :: Map m k => (k -> a -> b -> Maybe a) -> m k a -> m k b -> m k a
intersectionWithKey :: Map m k => (k -> a -> b -> c) -> m k a -> m k b -> m k c
map :: Map m k => (a -> b) -> m k a -> m k b
mapWithKey :: Map m k => (k -> a -> b) -> m k a -> m k b
mapAccum :: Map m k => (a -> b -> (a, c)) -> a -> m k b -> (a, m k c)
mapAccumWithKey :: Map m k => (a -> k -> b -> (a, c)) -> a -> m k b -> (a, m k c)
filter :: Map m k => (a -> Bool) -> m k a -> m k a
toListKV :: Map m k => m k a -> [(k, a)]
fromListKV :: Map m k => [(k, a)] -> m k a
fromListKVWith :: Map m k => (a -> a -> a) -> [(k, a)] -> m k a
serializeToList :: Map m k => m k a -> [(k, a)]
deserializeFromList :: Map m k => [(k, a)] -> m k a
isSubmapOfBy :: Map m k => (a -> b -> Bool) -> m k a -> m k b -> Bool
singletonView :: Map m k => m k a -> Maybe (k, a)

-- | Minimal complete definition:
--   
--   <ul>
--   <li><a>ordCmp</a></li>
--   <li><a>toAscList</a> or <a>toDescList</a></li>
--   <li><a>splitLookup</a></li>
--   </ul>
--   
--   For decent performance, supplying at least the following is probably a
--   good idea:
--   
--   <ul>
--   <li><a>minViewWithKey</a>, <a>maxViewWithKey</a></li>
--   <li><a>mapAccumAscWithKey</a>, <a>mapAccumDescWithKey</a></li>
--   </ul>
class Map m k => OrdMap m k where toAscList = reverse . toDescList toDescList = reverse . toAscList split m k = let (a, _, b) = splitLookup m k in (a, b) minViewWithKey m = case toAscList m of { [] -> (Nothing, m) (x : xs) -> (Just x, fromListKV xs) } maxViewWithKey m = case toDescList m of { [] -> (Nothing, m) (x : xs) -> (Just x, fromListKV xs) } findPredecessor m = fst . maxViewWithKey . fst . split m findSuccessor m = fst . minViewWithKey . snd . split m mapAccumAsc f = mapAccumAscWithKey (const . f) mapAccumDesc f = mapAccumDescWithKey (const . f) mapAccumAscWithKey f z = second fromListKV . mapAccumL (\ a (k, v) -> fmap ((,) k) (f a k v)) z . toAscList mapAccumDescWithKey f z = second fromListKV . mapAccumL (\ a (k, v) -> fmap ((,) k) (f a k v)) z . toDescList
ordCmp :: OrdMap m k => m k a -> k -> k -> Ordering
toAscList :: OrdMap m k => m k a -> [(k, a)]
toDescList :: OrdMap m k => m k a -> [(k, a)]
splitLookup :: OrdMap m k => k -> m k a -> (m k a, Maybe a, m k a)
split :: OrdMap m k => k -> m k a -> (m k a, m k a)
minViewWithKey :: OrdMap m k => m k a -> (Maybe (k, a), m k a)
maxViewWithKey :: OrdMap m k => m k a -> (Maybe (k, a), m k a)
findPredecessor :: OrdMap m k => k -> m k a -> Maybe (k, a)
findSuccessor :: OrdMap m k => k -> m k a -> Maybe (k, a)
mapAccumAsc :: OrdMap m k => (a -> b -> (a, c)) -> a -> m k b -> (a, m k c)
mapAccumAscWithKey :: OrdMap m k => (a -> k -> b -> (a, c)) -> a -> m k b -> (a, m k c)
mapAccumDesc :: OrdMap m k => (a -> b -> (a, c)) -> a -> m k b -> (a, m k c)
mapAccumDescWithKey :: OrdMap m k => (a -> k -> b -> (a, c)) -> a -> m k b -> (a, m k c)
data AList k v
data WrappedIntMap k v
instance Eq v => Eq (WrappedIntMap k v)
instance Ord v => Ord (WrappedIntMap k v)
instance Enum k => OrdMap WrappedIntMap k
instance Enum k => Map WrappedIntMap k
instance Traversable (WrappedIntMap k)
instance Foldable (WrappedIntMap k)
instance Functor (WrappedIntMap k)
instance Ord k => OrdMap Map k
instance Ord k => Map Map k
instance Ord k => OrdMap AList k
instance Eq k => Map AList k
instance Traversable (AList k)
instance Foldable (AList k)
instance Functor (AList k)
instance (Ord k, Ord v) => Ord (AList k v)
instance (Eq k, Eq v) => Eq (AList k v)


-- | The base implementation of a Patricia trie representing a map with
--   list keys, generalized over any type of map from element values to
--   tries.
--   
--   Worst-case complexities are given in terms of <tt>n</tt>, <tt>m</tt>,
--   and <tt>s</tt>. <tt>n</tt> refers to the number of keys in the map and
--   <tt>m</tt> to their maximum length. <tt>s</tt> refers to the length of
--   a key given to the function, not any property of the map.
--   
--   In addition, the trie's branching factor plays a part in almost every
--   operation, but the complexity depends on the underlying <a>Map</a>.
--   Thus, for instance, <a>member</a> is actually <tt>O(m f(b))</tt> where
--   <tt>f(b)</tt> is the complexity of a lookup operation on the
--   <a>Map</a> used. This complexity depends on the underlying operation,
--   which is not part of the specification of the visible function. Thus
--   it could change whilst affecting the complexity only for certain Map
--   types: hence this "b factor" is not shown explicitly.
--   
--   Disclaimer: the complexities have not been proven.
--   
--   Strict versions of functions are provided for those who want to be
--   certain that their <a>TrieMap</a> doesn't contain values consisting of
--   unevaluated thunks. Note, however, that they do not evaluate the whole
--   trie strictly, only the values. And only to one level of depth: for
--   instance, <a>alter'</a> does not <a>seq</a> the value within the
--   <a>Maybe</a>, only the <a>Maybe</a> itself. The user should add the
--   strictness in such cases himself, if he so wishes.
--   
--   Many functions come in both ordinary and <tt>WithKey</tt> forms, where
--   the former takes a function of type <tt>a -&gt; b</tt> and the latter
--   of type <tt>[k] -&gt; a -&gt; b</tt>, where <tt>[k]</tt> is the key
--   associated with the value <tt>a</tt>. For most of these functions,
--   there is additional overhead involved in keeping track of the key:
--   don't use the latter form of the function unless you need it.
module Data.ListTrie.Patricia.Map

-- | The data structure itself: a map from keys of type <tt>[k]</tt> to
--   values of type <tt>v</tt> implemented as a trie, using <tt>map</tt> to
--   map keys of type <tt>k</tt> to sub-tries.
--   
--   Regarding the instances:
--   
--   <ul>
--   <li>The <tt>Trie</tt> class is internal, ignore it.</li>
--   <li>The <a>Eq</a> constraint for the <a>Ord</a> instance is
--   misleading: it is needed only because <a>Eq</a> is a superclass of
--   <a>Ord</a>.</li>
--   <li>The <tt>Foldable</tt> and <a>Traversable</a> instances allow
--   folding over and traversing only the values, not the keys.</li>
--   <li>The <a>Monoid</a> instance defines <a>mappend</a> as <a>union</a>
--   and <a>mempty</a> as <a>empty</a>.</li>
--   </ul>
data TrieMap map k v

-- | <tt>O(1)</tt>. The empty map.
empty :: Map map k => TrieMap map k a

-- | <tt>O(1)</tt>. The singleton map containing only the given key-value
--   pair.
singleton :: Map map k => [k] -> a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Inserts the key-value pair into the map. If the
--   key is already a member of the map, the given value replaces the old
--   one.
--   
--   <pre>
--   insert = insertWith const
--   </pre>
insert :: Map map k => [k] -> a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Like <a>insert</a>, but the new value is reduced
--   to weak head normal form before being placed into the map.
--   
--   <pre>
--   insert' = insertWith' const
--   </pre>
insert' :: Map map k => [k] -> a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Inserts the key-value pair into the map. If the
--   key is already a member of the map, the old value is replaced by <tt>f
--   givenValue oldValue</tt> where <tt>f</tt> is the given function.
insertWith :: Map map k => (a -> a -> a) -> [k] -> a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Like <a>insertWith</a>, but the new value is
--   reduced to weak head normal form before being placed into the map,
--   whether it is the given value or a result of the combining function.
insertWith' :: Map map k => (a -> a -> a) -> [k] -> a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Removes the key from the map along with its
--   associated value. If the key is not a member of the map, the map is
--   unchanged.
delete :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Updates the value at the given key: if the given
--   function returns <a>Nothing</a>, the value and its associated key are
--   removed; if <a>Just</a><tt> a</tt> is returned, the old value is
--   replaced with <tt>a</tt>. If the key is not a member of the map, the
--   map is unchanged.
update :: Map map k => (a -> Maybe a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Like <a>update</a>, but also returns <a>Just</a>
--   the original value, or <a>Nothing</a> if the key is not a member of
--   the map.
updateLookup :: Map map k => (a -> Maybe a) -> [k] -> TrieMap map k a -> (Maybe a, TrieMap map k a)

-- | <tt>O(min(m,s))</tt>. Adjusts the value at the given key by calling
--   the given function on it. If the key is not a member of the map, the
--   map is unchanged.
adjust :: Map map k => (a -> a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Like <a>adjust</a>, but the function is applied
--   strictly.
adjust' :: Map map k => (a -> a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. The most general modification function, allowing
--   you to modify the value at the given key, whether or not it is a
--   member of the map. In short: the given function is passed <a>Just</a>
--   the value at the key if it is present, or <a>Nothing</a> otherwise; if
--   the function returns <a>Just</a> a value, the new value is inserted
--   into the map, otherwise the old value is removed. More precisely, for
--   <tt>alter f k m</tt>:
--   
--   If <tt>k</tt> is a member of <tt>m</tt>, <tt>f (</tt><a>Just</a><tt>
--   oldValue)</tt> is called. Now:
--   
--   <ul>
--   <li>If <tt>f</tt> returned <a>Just</a><tt> newValue</tt>,
--   <tt>oldValue</tt> is replaced with <tt>newValue</tt>.</li>
--   <li>If <tt>f</tt> returned <a>Nothing</a>, <tt>k</tt> and
--   <tt>oldValue</tt> are removed from the map.</li>
--   </ul>
--   
--   If, instead, <tt>k</tt> is not a member of <tt>m</tt>, <tt>f
--   </tt><a>Nothing</a> is called, and:
--   
--   <ul>
--   <li>If <tt>f</tt> returned <a>Just</a><tt> value</tt>, <tt>value</tt>
--   is inserted into the map, at <tt>k</tt>.</li>
--   <li>If <tt>f</tt> returned <a>Nothing</a>, the map is unchanged.</li>
--   </ul>
--   
--   The function is applied lazily only if the given key is a prefix of
--   more than one key in the map.
alter :: Map map k => (Maybe a -> Maybe a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Like <a>alter</a>, but the function is always
--   applied strictly.
alter' :: Map map k => (Maybe a -> Maybe a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(1)</tt>. <a>True</a> iff the map is empty.
null :: Map map k => TrieMap map k a -> Bool

-- | <tt>O(n m)</tt>. The number of elements in the map. The value is built
--   up lazily, allowing for delivery of partial results without traversing
--   the whole map.
size :: (Map map k, Num n) => TrieMap map k a -> n

-- | <tt>O(n m)</tt>. The number of elements in the map. The value is built
--   strictly: no value is returned until the map has been fully traversed.
size' :: (Map map k, Num n) => TrieMap map k a -> n

-- | <tt>O(min(m,s))</tt>. <a>True</a> iff the given key is associated with
--   a value in the map.
member :: Map map k => [k] -> TrieMap map k a -> Bool

-- | <tt>O(min(m,s))</tt>. <a>False</a> iff the given key is associated
--   with a value in the map.
notMember :: Map map k => [k] -> TrieMap map k a -> Bool

-- | <tt>O(min(m,s))</tt>. <a>Just</a> the value in the map associated with
--   the given key, or <a>Nothing</a> if the key is not a member of the
--   map.
lookup :: Map map k => [k] -> TrieMap map k a -> Maybe a

-- | <tt>O(min(m,s))</tt>. Like <a>lookup</a>, but returns the given value
--   when the key is not a member of the map.
lookupWithDefault :: Map map k => a -> [k] -> TrieMap map k a -> a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. <a>True</a> iff the first map is a
--   submap of the second, i.e. all keys that are members of the first map
--   are also members of the second map, and their associated values are
--   the same.
--   
--   <pre>
--   isSubmapOf = isSubmapOfBy (==)
--   </pre>
isSubmapOf :: (Map map k, Eq a) => TrieMap map k a -> TrieMap map k a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>isSubmapOf</a>, but one can
--   specify the equality relation applied to the values.
--   
--   <a>True</a> iff all keys that are members of the first map are also
--   members of the second map, and the given function <tt>f</tt> returns
--   <a>True</a> for all <tt>f firstMapValue secondMapValue</tt> where
--   <tt>firstMapValue</tt> and <tt>secondMapValue</tt> are associated with
--   the same key.
isSubmapOfBy :: Map map k => (a -> b -> Bool) -> TrieMap map k a -> TrieMap map k b -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. <a>True</a> iff the first map is a
--   proper submap of the second, i.e. all keys that are members of the
--   first map are also members of the second map, and their associated
--   values are the same, but the maps are not equal. That is, at least one
--   key was a member of the second map but not the first.
--   
--   <pre>
--   isProperSubmapOf = isProperSubmapOfBy (==)
--   </pre>
isProperSubmapOf :: (Map map k, Eq a) => TrieMap map k a -> TrieMap map k a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>isProperSubmapOf</a>, but one
--   can specify the equality relation applied to the values.
--   
--   <a>True</a> iff all keys that are members of the first map are also
--   members of the second map, and the given function <tt>f</tt> returns
--   <a>True</a> for all <tt>f firstMapValue secondMapValue</tt> where
--   <tt>firstMapValue</tt> and <tt>secondMapValue</tt> are associated with
--   the same key, and at least one key in the second map is not a member
--   of the first.
isProperSubmapOfBy :: Map map k => (a -> b -> Bool) -> TrieMap map k a -> TrieMap map k b -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The union of the two maps: the map which
--   contains all keys that are members of either map. This union is
--   left-biased: if a key is a member of both maps, the value from the
--   first map is chosen.
--   
--   The worst-case performance occurs when the two maps are identical.
--   
--   <pre>
--   union = unionWith const
--   </pre>
union :: Map map k => TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>union</a>, but the combining
--   function (<a>const</a>) is applied strictly.
--   
--   <pre>
--   union' = unionWith' const
--   </pre>
union' :: Map map k => TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. The union of all the maps: the map which contains
--   all keys that are members of any of the maps. If a key is a member of
--   multiple maps, the value that occurs in the earliest of the maps
--   (according to the order of the given list) is chosen.
--   
--   The worst-case performance occurs when all the maps are identical.
--   
--   <pre>
--   unions = unionsWith const
--   </pre>
unions :: Map map k => [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unions</a>, but the combining function
--   (<a>const</a>) is applied strictly.
--   
--   <pre>
--   unions' = unionsWith' const
--   </pre>
unions' :: Map map k => [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>union</a>, but the given
--   function is used to determine the new value if a key is a member of
--   both given maps. For a function <tt>f</tt>, the new value is <tt>f
--   firstMapValue secondMapValue</tt>.
unionWith :: Map map k => (a -> a -> a) -> TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>unionWith</a>, but in addition
--   to the two values, the key is passed to the combining function.
unionWithKey :: Map map k => ([k] -> a -> a -> a) -> TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unions</a>, but the given function
--   determines the final value if a key is a member of more than one map.
--   The function is applied as a left fold over the values in the given
--   list's order. For example:
--   
--   <pre>
--   unionsWith (-) [fromList [("a",1)],fromList [("a",2)],fromList [("a",3)]]
--      == fromList [("a",(1-2)-3)]
--      == fromList [("a",-4)]
--   </pre>
unionsWith :: Map map k => (a -> a -> a) -> [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unionsWith</a>, but in addition to the two
--   values under consideration, the key is passed to the combining
--   function.
unionsWithKey :: Map map k => ([k] -> a -> a -> a) -> [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>unionWith</a>, but the combining
--   function is applied strictly.
unionWith' :: Map map k => (a -> a -> a) -> TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>unionWithKey</a>, but the
--   combining function is applied strictly.
unionWithKey' :: Map map k => ([k] -> a -> a -> a) -> TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unionsWith</a>, but the combining function
--   is applied strictly.
unionsWith' :: Map map k => (a -> a -> a) -> [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unionsWithKey</a>, but the combining
--   function is applied strictly.
unionsWithKey' :: Map map k => ([k] -> a -> a -> a) -> [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The difference of the two maps: the map
--   which contains all keys that are members of the first map and not of
--   the second.
--   
--   The worst-case performance occurs when the two maps are identical.
--   
--   <pre>
--   difference = differenceWith (\_ _ -&gt; Nothing)
--   </pre>
difference :: Map map k => TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>difference</a>, but the given
--   function determines what to do when a key is a member of both maps. If
--   the function returns <a>Nothing</a>, the key is removed; if it returns
--   <a>Just</a> a new value, that value replaces the old one in the first
--   map.
differenceWith :: Map map k => (a -> b -> Maybe a) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>differenceWith</a>, but in
--   addition to the two values, the key they are associated with is passed
--   to the combining function.
differenceWithKey :: Map map k => ([k] -> a -> b -> Maybe a) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The intersection of the two maps: the
--   map which contains all keys that are members of both maps.
--   
--   The worst-case performance occurs when the two maps are identical.
--   
--   <pre>
--   intersection = intersectionWith const
--   </pre>
intersection :: Map map k => TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersection</a>, but the
--   combining function is applied strictly.
--   
--   <pre>
--   intersection' = intersectionWith' const
--   </pre>
intersection' :: Map map k => TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersection</a>, but the given
--   function determines the new values.
intersectionWith :: Map map k => (a -> b -> c) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k c

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersectionWith</a>, but in
--   addition to the two values, the key they are associated with is passed
--   to the combining function.
intersectionWithKey :: Map map k => ([k] -> a -> b -> c) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k c

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersectionWith</a>, but the
--   combining function is applied strictly.
intersectionWith' :: Map map k => (a -> b -> c) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k c

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersectionWithKey</a>, but the
--   combining function is applied strictly.
intersectionWithKey' :: Map map k => ([k] -> a -> b -> c) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k c

-- | <tt>O(n m)</tt>. Apply the given function to the elements in the map,
--   discarding those for which the function returns <a>False</a>.
filter :: Map map k => (a -> Bool) -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>filter</a>, but the key associated with the
--   element is also passed to the given predicate.
filterWithKey :: Map map k => ([k] -> a -> Bool) -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(n m)</tt>. A pair of maps: the first element contains those
--   values for which the given predicate returns <a>True</a>, and the
--   second contains those for which it was <a>False</a>.
partition :: Map map k => (a -> Bool) -> TrieMap map k a -> (TrieMap map k a, TrieMap map k a)

-- | <tt>O(n m)</tt>. Like <a>partition</a>, but the key associated with
--   the element is also passed to the given predicate.
partitionWithKey :: Map map k => ([k] -> a -> Bool) -> TrieMap map k a -> (TrieMap map k a, TrieMap map k a)

-- | <tt>O(n m)</tt>. Apply the given function to the elements in the map,
--   preserving only the <a>Just</a> results.
mapMaybe :: Map map k => (a -> Maybe b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Like <a>mapMaybe</a>, but the key associated with the
--   element is also passed to the given function.
mapMaybeWithKey :: Map map k => ([k] -> a -> Maybe b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Apply the given function to the elements in the map,
--   separating the <a>Left</a> results from the <a>Right</a>. The first
--   element of the pair contains the former results, and the second the
--   latter.
mapEither :: Map map k => (a -> Either b c) -> TrieMap map k a -> (TrieMap map k b, TrieMap map k c)

-- | <tt>O(n m)</tt>. Like <a>mapEither</a>, but the key associated with
--   the element is also passed to the given function.
mapEitherWithKey :: Map map k => ([k] -> a -> Either b c) -> TrieMap map k a -> (TrieMap map k b, TrieMap map k c)

-- | <tt>O(n m)</tt>. Apply the given function to all the elements in the
--   map.
map :: Map map k => (a -> b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Like <a>map</a>, but apply the function strictly.
map' :: Map map k => (a -> b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Like <a>map</a>, but also pass the key associated
--   with the element to the given function.
mapWithKey :: Map map k => ([k] -> a -> b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Like <a>mapWithKey</a>, but apply the function
--   strictly.
mapWithKey' :: Map map k => ([k] -> a -> b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Apply the given function to all the keys in a map.
--   
--   <pre>
--   mapKeys = mapKeysWith const
--   </pre>
mapKeys :: (Map map k1, Map map k2) => ([k1] -> [k2]) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>mapKeys</a>, but use the first given function
--   to combine elements if the second function gives two keys the same
--   value.
mapKeysWith :: (Map map k1, Map map k2) => (a -> a -> a) -> ([k1] -> [k2]) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Apply the given function to the contents of all the
--   keys in the map.
--   
--   <pre>
--   mapInKeys = mapInKeysWith const
--   </pre>
mapInKeys :: (Map map k1, Map map k2) => (k1 -> k2) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>mapInKeys</a>, but combine identical keys
--   strictly.
--   
--   <pre>
--   mapInKeys' = mapInKeysWith' const
--   </pre>
mapInKeys' :: (Map map k1, Map map k2) => (k1 -> k2) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>mapInKeys</a>, but use the first given
--   function to combine elements if the second function gives two keys the
--   same value.
mapInKeysWith :: (Map map k1, Map map k2) => (a -> a -> a) -> (k1 -> k2) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>mapInKeysWith</a>, but apply the combining
--   function strictly.
mapInKeysWith' :: (Map map k1, Map map k2) => (a -> a -> a) -> (k1 -> k2) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>Data.List</a>.<tt>mapAccumL</tt> on the
--   <a>toList</a> representation.
--   
--   Essentially a combination of <a>map</a> and <a>foldl</a>: the given
--   function is applied to each element of the map, resulting in a new
--   value for the accumulator and a replacement element for the map.
mapAccum :: Map map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccum</a>, but the function receives the
--   key in addition to the value associated with it.
mapAccumWithKey :: Map map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccum</a>, but the function is applied
--   strictly.
mapAccum' :: Map map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumWithKey</a>, but the function is
--   applied strictly.
mapAccumWithKey' :: Map map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccum</a>, but in ascending order, as
--   though operating on the <a>toAscList</a> representation.
mapAccumAsc :: OrdMap map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumAsc</a>, but the function receives
--   the key in addition to the value associated with it.
mapAccumAscWithKey :: OrdMap map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumAsc</a>, but the function is applied
--   strictly.
mapAccumAsc' :: OrdMap map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumAscWithKey</a>, but the function is
--   applied strictly.
mapAccumAscWithKey' :: OrdMap map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccum</a>, but in descending order, as
--   though operating on the <a>toDescList</a> representation.
mapAccumDesc :: OrdMap map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumDesc</a>, but the function receives
--   the key in addition to the value associated with it.
mapAccumDescWithKey :: OrdMap map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumDesc</a>, but the function is applied
--   strictly.
mapAccumDesc' :: OrdMap map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumDescWithKey</a>, but the function is
--   applied strictly.
mapAccumDescWithKey' :: OrdMap map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toList</a> representation, folding only over the elements.
foldr :: Map map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toList</a> representation, folding over both the keys and the
--   elements.
foldrWithKey :: Map map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toAscList</a> representation.
foldrAsc :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toAscList</a> representation, folding over both the keys and the
--   elements.
foldrAscWithKey :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toDescList</a> representation.
foldrDesc :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toDescList</a> representation, folding over both the keys and the
--   elements.
foldrDescWithKey :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toList
--   representation.
foldl :: Map map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toList
--   representation, folding over both the keys and the elements.
foldlWithKey :: Map map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toAscList
--   representation.
foldlAsc :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toAscList
--   representation, folding over both the keys and the elements.
foldlAscWithKey :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toDescList
--   representation.
foldlDesc :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toDescList
--   representation, folding over both the keys and the elements.
foldlDescWithKey :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toList</a> representation.
foldl' :: Map map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toList</a> representation, folding over both the keys and the
--   elements.
foldlWithKey' :: Map map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toAscList</a> representation.
foldlAsc' :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toAscList</a> representation, folding over both the keys and the
--   elements.
foldlAscWithKey' :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toDescList</a> representation.
foldlDesc' :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toDescList</a> representation, folding over both the keys and the
--   elements.
foldlDescWithKey' :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Converts the map to a list of the key-value pairs
--   contained within, in undefined order.
toList :: Map map k => TrieMap map k a -> [([k], a)]

-- | <tt>O(n m)</tt>. Converts the map to a list of the key-value pairs
--   contained within, in ascending order.
toAscList :: OrdMap map k => TrieMap map k a -> [([k], a)]

-- | <tt>O(n m)</tt>. Converts the map to a list of the key-value pairs
--   contained within, in descending order.
toDescList :: OrdMap map k => TrieMap map k a -> [([k], a)]

-- | <tt>O(n m)</tt>. Creates a map from a list of key-value pairs. If a
--   key occurs more than once, the value from the last pair (according to
--   the list's order) is the one which ends up in the map.
--   
--   <pre>
--   fromList = fromListWith const
--   </pre>
fromList :: Map map k => [([k], a)] -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>fromList</a>, but the given function is used
--   to determine the final value if a key occurs more than once. The
--   function is applied as though it were flipped and then applied as a
--   left fold over the values in the given list's order. Or, equivalently
--   (except as far as performance is concerned), as though the function
--   were applied as a right fold over the values in the reverse of the
--   given list's order. For example:
--   
--   <pre>
--   fromListWith (-) [("a",1),("a",2),("a",3),("a",4)]
--      == fromList [("a",4-(3-(2-1)))]
--      == fromList [("a",2)]
--   </pre>
fromListWith :: Map map k => (a -> a -> a) -> [([k], a)] -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>fromListWith</a>, but the key, in addition to
--   the values to be combined, is passed to the combining function.
fromListWithKey :: Map map k => ([k] -> a -> a -> a) -> [([k], a)] -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>fromListWith</a>, but the combining function
--   is applied strictly.
fromListWith' :: Map map k => (a -> a -> a) -> [([k], a)] -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>fromListWithKey</a>, but the combining
--   function is applied strictly.
fromListWithKey' :: Map map k => ([k] -> a -> a -> a) -> [([k], a)] -> TrieMap map k a

-- | <tt>O(m)</tt>. Removes and returns the minimal key in the map, along
--   with the value associated with it. If the map is empty, <a>Nothing</a>
--   and the original map are returned.
minView :: OrdMap map k => TrieMap map k a -> (Maybe ([k], a), TrieMap map k a)

-- | <tt>O(m)</tt>. Removes and returns the maximal key in the map, along
--   with the value associated with it. If the map is empty, <a>Nothing</a>
--   and the original map are returned.
maxView :: OrdMap map k => TrieMap map k a -> (Maybe ([k], a), TrieMap map k a)

-- | <tt>O(m)</tt>. Like <a>fst</a> composed with <a>minView</a>.
--   <a>Just</a> the minimal key in the map and its associated value, or
--   <a>Nothing</a> if the map is empty.
findMin :: OrdMap map k => TrieMap map k a -> Maybe ([k], a)

-- | <tt>O(m)</tt>. Like <a>fst</a> composed with <a>maxView</a>.
--   <a>Just</a> the minimal key in the map and its associated value, or
--   <a>Nothing</a> if the map is empty.
findMax :: OrdMap map k => TrieMap map k a -> Maybe ([k], a)

-- | <tt>O(m)</tt>. Like <a>snd</a> composed with <a>minView</a>. The map
--   without its minimal key, or the unchanged original map if it was
--   empty.
deleteMin :: OrdMap map k => TrieMap map k a -> TrieMap map k a

-- | <tt>O(m)</tt>. Like <a>snd</a> composed with <a>maxView</a>. The map
--   without its maximal key, or the unchanged original map if it was
--   empty.
deleteMax :: OrdMap map k => TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Splits the map in two about the given key. The
--   first element of the resulting pair is a map containing the keys
--   lesser than the given key; the second contains those keys that are
--   greater.
split :: OrdMap map k => [k] -> TrieMap map k a -> (TrieMap map k a, TrieMap map k a)

-- | <tt>O(min(m,s))</tt>. Like <a>split</a>, but also returns the value
--   associated with the given key, if any.
splitLookup :: OrdMap map k => [k] -> TrieMap map k a -> (TrieMap map k a, Maybe a, TrieMap map k a)

-- | <tt>O(m)</tt>. <a>Just</a> the key of the map which precedes the given
--   key in order, along with its associated value, or <a>Nothing</a> if
--   the map is empty.
findPredecessor :: OrdMap map k => [k] -> TrieMap map k a -> Maybe ([k], a)

-- | <tt>O(m)</tt>. <a>Just</a> the key of the map which succeeds the given
--   key in order, along with its associated value, or <a>Nothing</a> if
--   the map is empty.
findSuccessor :: OrdMap map k => [k] -> TrieMap map k a -> Maybe ([k], a)

-- | <tt>O(s)</tt>. The map which contains all keys of which the given key
--   is a prefix. For example:
--   
--   <pre>
--   lookupPrefix "ab" (fromList [("a",1),("ab",2),("ac",3),("abc",4)])
--      == fromList [("ab",2),("abc",4)]
--   </pre>
lookupPrefix :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(s)</tt>. Prepends the given key to all the keys of the map. For
--   example:
--   
--   <pre>
--   addPrefix "xa" (fromList [("a",1),("b",2)])
--      == fromList [("xaa",1),("xab",2)]
--   </pre>
addPrefix :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(s)</tt>. The map which contains all keys of which the given key
--   is a prefix, with the prefix removed from each key. If the given key
--   is not a prefix of any key in the map, an empty map is returned. For
--   example:
--   
--   <pre>
--   deletePrefix "a" (fromList [("a",1),("ab",2),("ac",3)])
--      == fromList [("",1),("b",2),("c",3)]
--   </pre>
--   
--   This function can be used, for instance, to reduce potentially
--   expensive I/O operations: if you need to find the value in a map
--   associated with a string, but you only have a prefix of it and
--   retrieving the rest is an expensive operation, calling
--   <a>deletePrefix</a> with what you have might allow you to avoid the
--   operation: if the resulting map is empty, the entire string cannot be
--   a member of the map.
deletePrefix :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(s)</tt>. Deletes all keys which are suffixes of the given key.
--   For example:
--   
--   <pre>
--   deleteSuffixes "ab" (fromList $ zip ["a","ab","ac","b","abc"] [1..])
--      == fromList [("a",1),("ac",3),("b",4)]
--   </pre>
deleteSuffixes :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(1)</tt>. A triple containing the longest common prefix of all
--   keys in the map, the value associated with that prefix, if any, and
--   the map with that prefix removed from all the keys as well as the map
--   itself. Examples:
--   
--   <pre>
--   splitPrefix (fromList [("a",1),("b",2)])
--      == ("", Nothing, fromList [("a",1),("b",2)])
--   splitPrefix (fromList [("a",1),("ab",2),("ac",3)])
--      == ("a", Just 1, fromList [("b",2),("c",3)])
--   </pre>
splitPrefix :: Map map k => TrieMap map k a -> ([k], Maybe a, TrieMap map k a)

-- | <tt>O(1)</tt>. The children of the longest common prefix in the trie
--   as maps, associated with their distinguishing key value. If the map
--   contains less than two keys, this function will return an empty map.
--   Examples;
--   
--   <pre>
--   children (fromList [("a",1),("abc",2),("abcd",3)])
--      == Map.fromList [('b',fromList [("c",2),("cd",3)])]
--   children (fromList [("b",1),("c",2)])
--      == Map.fromList [('b',fromList [("",1)]),('c',fromList [("",2)])]
--   </pre>
children :: Map map k => TrieMap map k a -> map k (TrieMap map k a)

-- | <tt>O(1)</tt>. The children of the first element of the longest common
--   prefix in the trie as maps, associated with their distinguishing key
--   value. If the map contains less than two keys, this function will
--   return an empty map.
--   
--   If the longest common prefix of all keys in the trie is the empty
--   list, this function is equivalent to <a>children</a>.
--   
--   Examples:
--   
--   <pre>
--   children1 (fromList [("abc",1),("abcd",2)])
--      == Map.fromList [('a',fromList [("bc",1),("bcd",2)])]
--   children1 (fromList [("b",1),("c",2)])
--      == Map.fromList [('b',fromList [("",1)]),('c',fromList [("",2)])]
--   </pre>
children1 :: Map map k => TrieMap map k a -> map k (TrieMap map k a)

-- | <tt>O(n m)</tt>. Displays the map's internal structure in an undefined
--   way. That is to say, no program should depend on the function's
--   results.
showTrie :: (Show k, Show a, Map map k) => TrieMap map k a -> ShowS

-- | <tt>O(n m)</tt>. Like <a>showTrie</a>, but uses the given function to
--   display the elements of the map. Still undefined.
showTrieWith :: (Show k, Map map k) => (Maybe a -> ShowS) -> TrieMap map k a -> ShowS
instance (Map map k, Binary k, Binary a) => Binary (TrieMap map k a)
instance (Map map k, Read k, Read a) => Read (TrieMap map k a)
instance (Map map k, Show k, Show a) => Show (TrieMap map k a)
instance (Map map k, Traversable (map k)) => Traversable (TrieMap map k)
instance Map map k => Foldable (TrieMap map k)
instance Map map k => Functor (TrieMap map k)
instance Map map k => Monoid (TrieMap map k a)
instance (Eq (map k (TrieMap map k a)), OrdMap map k, Ord k, Ord a) => Ord (TrieMap map k a)
instance (Map map k, Eq (map k (TrieMap map k a)), Eq a) => Eq (TrieMap map k a)
instance Map map k => Trie TrieMap Maybe map k


-- | A map from lists of elements that can be compared for equality to
--   arbitrary values, based on a Patricia trie.
module Data.ListTrie.Patricia.Map.Eq
type TrieMap = TrieMap AList


-- | A map from lists of elements that can be totally ordered to arbitrary
--   values, based on a Patricia trie.
module Data.ListTrie.Patricia.Map.Ord
type TrieMap = TrieMap Map


-- | A map from lists of enumerable elements to arbitrary values, based on
--   a Patricia trie.
--   
--   Note that those operations which require an ordering, such as
--   <a>toAscList</a>, do not compare the elements themselves, but rather
--   their <a>Int</a> representation after <a>fromEnum</a>.
module Data.ListTrie.Patricia.Map.Enum
type TrieMap = TrieMap WrappedIntMap


-- | The base implementation of a Patricia trie representing a set of
--   lists, generalized over any type of map from element values to tries.
--   
--   Worst-case complexities are given in terms of <tt>n</tt>, <tt>m</tt>,
--   and <tt>s</tt>. <tt>n</tt> refers to the number of keys in the set and
--   <tt>m</tt> to their maximum length. <tt>s</tt> refers to the length of
--   a key given to the function, not any property of the set.
--   
--   In addition, the trie's branching factor plays a part in almost every
--   operation, but the complexity depends on the underlying <a>Map</a>.
--   Thus, for instance, <a>member</a> is actually <tt>O(m f(b))</tt> where
--   <tt>f(b)</tt> is the complexity of a lookup operation on the
--   <a>Map</a> used. This complexity depends on the underlying operation,
--   which is not part of the specification of the visible function. Thus
--   it could change whilst affecting the complexity only for certain Map
--   types: hence this "b factor" is not shown explicitly.
--   
--   Disclaimer: the complexities have not been proven.
module Data.ListTrie.Patricia.Set

-- | The data structure itself: a set of keys of type <tt>[a]</tt>
--   implemented as a trie, using <tt>map</tt> to map keys of type
--   <tt>a</tt> to sub-tries.
--   
--   Regarding the instances:
--   
--   <ul>
--   <li>The <tt>CMap</tt> type is internal, ignore it. For <a>Eq</a> and
--   <a>Ord</a> an <a>Eq</a> instance is required: what this means is that
--   <tt>map a v</tt> is expected to be an instance of <a>Eq</a>, given
--   <a>Eq</a><tt> v</tt>.</li>
--   <li>The <a>Eq</a> constraint for the <a>Ord</a> instance is
--   misleading: it is needed only because <a>Eq</a> is a superclass of
--   <a>Ord</a>.</li>
--   <li>The <a>Monoid</a> instance defines <a>mappend</a> as <a>union</a>
--   and <a>mempty</a> as <a>empty</a>.</li>
--   </ul>
data TrieSet map a

-- | <tt>O(1)</tt>. The empty set.
empty :: Map map a => TrieSet map a

-- | <tt>O(1)</tt>. The singleton set containing only the given key.
singleton :: Map map a => [a] -> TrieSet map a

-- | <tt>O(min(m,s))</tt>. Inserts the key into the set. If the key is
--   already a member of the set, the set is unchanged.
insert :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(min(m,s))</tt>. Removes the key from the set. If the key is not
--   a member of the set, the set is unchanged.
delete :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(1)</tt>. <a>True</a> iff the set is empty.
null :: Map map a => TrieSet map a -> Bool

-- | <tt>O(n m)</tt>. The number of keys in the set. The value is built up
--   lazily, allowing for delivery of partial results without traversing
--   the whole set.
size :: (Map map a, Num n) => TrieSet map a -> n

-- | <tt>O(n m)</tt>. The number of keys in the set. The value is built
--   strictly: no value is returned until the set has been fully traversed.
size' :: (Map map a, Num n) => TrieSet map a -> n

-- | <tt>O(min(m,s))</tt>. <a>True</a> iff the given key is contained
--   within the set.
member :: Map map a => [a] -> TrieSet map a -> Bool

-- | <tt>O(min(m,s))</tt>. <a>False</a> iff the given key is contained
--   within the set.
notMember :: Map map a => [a] -> TrieSet map a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. <a>True</a> iff the first set is a
--   subset of the second, i.e. all keys that are members of the first set
--   are also members of the second set.
isSubsetOf :: Map map a => TrieSet map a -> TrieSet map a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. <a>True</a> iff the first set is a
--   proper subset of the second, i.e. the first is a subset of the second,
--   but the sets are not equal.
isProperSubsetOf :: Map map a => TrieSet map a -> TrieSet map a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The union of the two sets: the set which
--   contains all keys that are members of either set.
--   
--   The worst-case performance occurs when the two sets are identical.
union :: Map map a => TrieSet map a -> TrieSet map a -> TrieSet map a

-- | <tt>O(sum(n))</tt>. The union of all the sets: the set which contains
--   all keys that are members of any of the sets.
--   
--   The worst-case performance occurs when all the sets are identical.
unions :: Map map a => [TrieSet map a] -> TrieSet map a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The difference of the two sets: the set
--   which contains all keys that are members of the first set and not
--   members of the second set.
--   
--   The worst-case performance occurs when the two sets are identical.
difference :: Map map a => TrieSet map a -> TrieSet map a -> TrieSet map a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The intersection of the two sets: the
--   set which contains all keys that are members of both sets.
--   
--   The worst-case performance occurs when the two sets are identical.
intersection :: Map map a => TrieSet map a -> TrieSet map a -> TrieSet map a

-- | <tt>O(n m)</tt>. The set of those keys in the set for which the given
--   predicate returns <a>True</a>.
filter :: Map map a => ([a] -> Bool) -> TrieSet map a -> TrieSet map a

-- | <tt>O(n m)</tt>. A pair of sets: the first element contains those keys
--   for which the given predicate returns <a>True</a>, and the second
--   element contains those for which it was <a>False</a>.
partition :: Map map a => ([a] -> Bool) -> TrieSet map a -> (TrieSet map a, TrieSet map a)

-- | <tt>O(n m)</tt>. Apply the given function to all the keys in the set.
map :: (Map map a, Map map b) => ([a] -> [b]) -> TrieSet map a -> TrieSet map b

-- | <tt>O(n m)</tt>. Apply the given function to the contents of all the
--   keys in the set.
mapIn :: (Map map a, Map map b) => (a -> b) -> TrieSet map a -> TrieSet map b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toList</a> representation.
foldr :: Map map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toAscList</a> representation.
foldrAsc :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toDescList</a> representation.
foldrDesc :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the
--   <a>toList</a> representation.
foldl :: Map map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the
--   <a>toAscList</a> representation.
foldlAsc :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the
--   <a>toDescList</a> representation.
foldlDesc :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toList</a> representation.
foldl' :: Map map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toAscList</a> representation.
foldlAsc' :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toDescList</a> representation.
foldlDesc' :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Converts the set to a list of the keys contained
--   within, in undefined order.
toList :: Map map a => TrieSet map a -> [[a]]

-- | <tt>O(n m)</tt>. Converts the set to a list of the keys contained
--   within, in ascending order.
toAscList :: OrdMap map a => TrieSet map a -> [[a]]

-- | <tt>O(n m)</tt>. Converts the set to a list of the keys contained
--   within, in descending order.
toDescList :: OrdMap map a => TrieSet map a -> [[a]]

-- | <tt>O(n m)</tt>. Creates a set from a list of keys.
fromList :: Map map a => [[a]] -> TrieSet map a

-- | <tt>O(m)</tt>. Removes and returns the minimal key in the set. If the
--   set is empty, <a>Nothing</a> and the original set are returned.
minView :: OrdMap map a => TrieSet map a -> (Maybe [a], TrieSet map a)

-- | <tt>O(m)</tt>. Removes and returns the maximal key in the set. If the
--   set is empty, <a>Nothing</a> and the original set are returned.
maxView :: OrdMap map a => TrieSet map a -> (Maybe [a], TrieSet map a)

-- | <tt>O(m)</tt>. Like <a>fst</a> composed with <a>minView</a>.
--   <a>Just</a> the minimal key in the set, or <a>Nothing</a> if the set
--   is empty.
findMin :: OrdMap map a => TrieSet map a -> Maybe [a]

-- | <tt>O(m)</tt>. Like <a>fst</a> composed with <a>maxView</a>.
--   <a>Just</a> the maximal key in the set, or <a>Nothing</a> if the set
--   is empty.
findMax :: OrdMap map a => TrieSet map a -> Maybe [a]

-- | <tt>O(m)</tt>. Like <a>snd</a> composed with <a>minView</a>. The set
--   without its minimal key, or the unchanged original set if it was
--   empty.
deleteMin :: OrdMap map a => TrieSet map a -> TrieSet map a

-- | <tt>O(m)</tt>. Like <a>snd</a> composed with <a>maxView</a>. The set
--   without its maximal key, or the unchanged original set if it was
--   empty.
deleteMax :: OrdMap map a => TrieSet map a -> TrieSet map a

-- | <tt>O(min(m,s))</tt>. Splits the set in two about the given key. The
--   first element of the resulting pair is a set containing the keys
--   lesser than the given key; the second contains those keys that are
--   greater.
split :: OrdMap map a => [a] -> TrieSet map a -> (TrieSet map a, TrieSet map a)

-- | <tt>O(min(m,s))</tt>. Like <a>split</a>, but also returns whether the
--   given key was a member of the set or not.
splitMember :: OrdMap map a => [a] -> TrieSet map a -> (TrieSet map a, Bool, TrieSet map a)

-- | <tt>O(m)</tt>. <a>Just</a> the key of the set which precedes the given
--   key in order, or <a>Nothing</a> if the set is empty.
findPredecessor :: OrdMap map a => [a] -> TrieSet map a -> Maybe [a]

-- | <tt>O(m)</tt>. <a>Just</a> the key of the set which succeeds the given
--   key in order, or <a>Nothing</a> if the set is empty.
findSuccessor :: OrdMap map a => [a] -> TrieSet map a -> Maybe [a]

-- | <tt>O(s)</tt>. The set which contains all keys of which the given key
--   is a prefix. For example:
--   
--   <pre>
--   lookupPrefix "ab" (fromList ["a","ab","ac","abc"])
--      == fromList ["ab","abc"]
--   </pre>
lookupPrefix :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(s)</tt>. Prepends the given key to all the keys of the set. For
--   example:
--   
--   <pre>
--   addPrefix "pre" (fromList ["a","b"]) == fromList ["prea","preb"]
--   </pre>
addPrefix :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(s)</tt>. The set which contains all keys of which the given key
--   is a prefix, with the prefix removed from each key. If the given key
--   is not a prefix of any key in the set, an empty set is returned. For
--   example:
--   
--   <pre>
--   deletePrefix "a" (fromList ["a","ab","ac"]) == fromList ["","b","c"]
--   </pre>
--   
--   This function can be used, for instance, to reduce potentially
--   expensive I/O operations: if you need to check whether a string is a
--   member of a set, but you only have a prefix of it and retrieving the
--   rest is an expensive operation, calling <a>deletePrefix</a> with what
--   you have might allow you to avoid the operation: if the resulting set
--   is empty, the entire string cannot be a member of the set.
deletePrefix :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(s)</tt>. Deletes all keys which are suffixes of the given key.
--   For example:
--   
--   <pre>
--   deleteSuffixes "ab" (fromList $ zip ["a","ab","ac","b","abc"] [1..])
--      == fromList [("a",1),("ac",3),("b",4)]
--   </pre>
deleteSuffixes :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(1)</tt>. A triple containing the longest common prefix of all
--   keys in the set, whether that prefix was a member of the set, and the
--   set with that prefix removed from all the keys as well as the set
--   itself. Examples:
--   
--   <pre>
--   splitPrefix (fromList ["a","b"]) == ("", False, fromList ["a","b"])
--   splitPrefix (fromList ["a","ab","ac"]) == ("a", True, fromList ["b","c"])
--   </pre>
splitPrefix :: Map map a => TrieSet map a -> ([a], Bool, TrieSet map a)

-- | <tt>O(1)</tt>. The children of the longest common prefix in the trie
--   as sets, associated with their distinguishing key value. If the set
--   contains less than two keys, this function will return an empty map.
--   Examples;
--   
--   <pre>
--   children (fromList ["a","abc","abcd"])
--      == Map.fromList [('b',fromList ["c","cd"])]
--   children (fromList ["b","c"])
--      == Map.fromList [('b',fromList [""]),('c',fromList [""])]
--   </pre>
children :: Map map a => TrieSet map a -> map a (TrieSet map a)

-- | <tt>O(1)</tt>. The children of the first element of the longest common
--   prefix in the trie as sets, associated with their distinguishing key
--   value. If the set contains less than two keys, this function will
--   return an empty map.
--   
--   If the longest common prefix of all keys in the trie is the empty
--   list, this function is equivalent to <a>children</a>.
--   
--   Examples:
--   
--   <pre>
--   children1 (fromList ["abc","abcd"])
--      == Map.fromList [('a',fromList ["bc","bcd"])]
--   children1 (fromList ["b","c"])
--      == Map.fromList [('b',fromList [""]),('c',fromList [""])]
--   </pre>
children1 :: Map map a => TrieSet map a -> map a (TrieSet map a)

-- | <tt>O(n m)</tt>. Displays the set's internal structure in an undefined
--   way. That is to say, no program should depend on the function's
--   results.
showTrie :: (Show a, Map map a) => TrieSet map a -> ShowS
instance (Map map a, Binary a) => Binary (TrieSet map a)
instance (Map map k, Binary k, Binary a) => Binary (TrieSetBase map k a)
instance (Map map a, Read a) => Read (TrieSet map a)
instance (Map map a, Show a) => Show (TrieSet map a)
instance Map map a => Monoid (TrieSet map a)
instance (Eq (CMap map a Bool), OrdMap map a, Ord a) => Ord (TrieSet map a)
instance (Eq (CMap map a Bool), Map map a) => Eq (TrieSet map a)
instance (Eq (CMap map a Bool), OrdMap map a, Ord a) => Ord (TrieSetBase map a Bool)
instance (Map map a, Eq (CMap map a Bool)) => Eq (TrieSetBase map a Bool)
instance Map map k => Trie TrieSetBase Identity map k


-- | A set of lists of elements that can be compared for equality, based on
--   a Patricia trie.
module Data.ListTrie.Patricia.Set.Eq
type TrieSet = TrieSet AList


-- | A set of lists of elements that can be totally ordered, based on a
--   Patricia trie.
module Data.ListTrie.Patricia.Set.Ord
type TrieSet = TrieSet Map


-- | A set of lists of enumerable elements, based on a Patricia trie.
--   
--   Note that those operations which require an ordering, such as
--   <a>toAscList</a>, do not compare the elements themselves, but rather
--   their <a>Int</a> representation after <a>fromEnum</a>.
module Data.ListTrie.Patricia.Set.Enum
type TrieSet = TrieSet WrappedIntMap


-- | The base implementation of a trie representing a map with list keys,
--   generalized over any type of map from element values to tries.
--   
--   Worst-case complexities are given in terms of <tt>n</tt>, <tt>m</tt>,
--   and <tt>s</tt>. <tt>n</tt> refers to the number of keys in the map and
--   <tt>m</tt> to their maximum length. <tt>s</tt> refers to the length of
--   a key given to the function, not any property of the map.
--   
--   In addition, the trie's branching factor plays a part in almost every
--   operation, but the complexity depends on the underlying <a>Map</a>.
--   Thus, for instance, <a>member</a> is actually <tt>O(m f(b))</tt> where
--   <tt>f(b)</tt> is the complexity of a lookup operation on the
--   <a>Map</a> used. This complexity depends on the underlying operation,
--   which is not part of the specification of the visible function. Thus
--   it could change whilst affecting the complexity only for certain Map
--   types: hence this "b factor" is not shown explicitly.
--   
--   Disclaimer: the complexities have not been proven.
--   
--   Strict versions of functions are provided for those who want to be
--   certain that their <a>TrieMap</a> doesn't contain values consisting of
--   unevaluated thunks. Note, however, that they do not evaluate the whole
--   trie strictly, only the values. And only to one level of depth: for
--   instance, <a>alter'</a> does not <a>seq</a> the value within the
--   <a>Maybe</a>, only the <a>Maybe</a> itself. The user should add the
--   strictness in such cases himself, if he so wishes.
--   
--   Many functions come in both ordinary and <tt>WithKey</tt> forms, where
--   the former takes a function of type <tt>a -&gt; b</tt> and the latter
--   of type <tt>[k] -&gt; a -&gt; b</tt>, where <tt>[k]</tt> is the key
--   associated with the value <tt>a</tt>. For most of these functions,
--   there is additional overhead involved in keeping track of the key:
--   don't use the latter form of the function unless you need it.
module Data.ListTrie.Map

-- | The data structure itself: a map from keys of type <tt>[k]</tt> to
--   values of type <tt>v</tt> implemented as a trie, using <tt>map</tt> to
--   map keys of type <tt>k</tt> to sub-tries.
--   
--   Regarding the instances:
--   
--   <ul>
--   <li>The <tt>Trie</tt> class is internal, ignore it.</li>
--   <li>The <a>Eq</a> constraint for the <a>Ord</a> instance is
--   misleading: it is needed only because <a>Eq</a> is a superclass of
--   <a>Ord</a>.</li>
--   <li>The <tt>Foldable</tt> and <a>Traversable</a> instances allow
--   folding over and traversing only the values, not the keys.</li>
--   <li>The <a>Monoid</a> instance defines <a>mappend</a> as <a>union</a>
--   and <a>mempty</a> as <a>empty</a>.</li>
--   </ul>
data TrieMap map k v

-- | <tt>O(1)</tt>. The empty map.
empty :: Map map k => TrieMap map k a

-- | <tt>O(s)</tt>. The singleton map containing only the given key-value
--   pair.
singleton :: Map map k => [k] -> a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Inserts the key-value pair into the map. If the
--   key is already a member of the map, the given value replaces the old
--   one.
insert :: Map map k => [k] -> a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Inserts the key-value pair into the map. If the
--   key is already a member of the map, the given value replaces the old
--   one.
insert' :: Map map k => [k] -> a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Inserts the key-value pair into the map. If the
--   key is already a member of the map, the old value is replaced by <tt>f
--   givenValue oldValue</tt> where <tt>f</tt> is the given function.
insertWith :: Map map k => (a -> a -> a) -> [k] -> a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Like <a>insertWith</a>, but the new value is
--   reduced to weak head normal form before being placed into the map,
--   whether it is the given value or a result of the combining function.
insertWith' :: Map map k => (a -> a -> a) -> [k] -> a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Removes the key from the map along with its
--   associated value. If the key is not a member of the map, the map is
--   unchanged.
delete :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Updates the value at the given key: if the given
--   function returns <a>Nothing</a>, the value and its associated key are
--   removed; if <a>Just</a><tt> a</tt> is returned, the old value is
--   replaced with <tt>a</tt>. If the key is not a member of the map, the
--   map is unchanged.
update :: Map map k => (a -> Maybe a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Like <a>update</a>, but also returns <a>Just</a>
--   the original value, or <a>Nothing</a> if the key is not a member of
--   the map.
updateLookup :: Map map k => (a -> Maybe a) -> [k] -> TrieMap map k a -> (Maybe a, TrieMap map k a)

-- | <tt>O(min(m,s))</tt>. Adjusts the value at the given key by calling
--   the given function on it. If the key is not a member of the map, the
--   map is unchanged.
adjust :: Map map k => (a -> a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Like <a>adjust</a>, but the function is applied
--   strictly.
adjust' :: Map map k => (a -> a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. The most general modification function, allowing
--   you to modify the value at the given key, whether or not it is a
--   member of the map. In short: the given function is passed <a>Just</a>
--   the value at the key if it is present, or <a>Nothing</a> otherwise; if
--   the function returns <a>Just</a> a value, the new value is inserted
--   into the map, otherwise the old value is removed. More precisely, for
--   <tt>alter f k m</tt>:
--   
--   If <tt>k</tt> is a member of <tt>m</tt>, <tt>f (</tt><a>Just</a><tt>
--   oldValue)</tt> is called. Now:
--   
--   <ul>
--   <li>If <tt>f</tt> returned <a>Just</a><tt> newValue</tt>,
--   <tt>oldValue</tt> is replaced with <tt>newValue</tt>.</li>
--   <li>If <tt>f</tt> returned <a>Nothing</a>, <tt>k</tt> and
--   <tt>oldValue</tt> are removed from the map.</li>
--   </ul>
--   
--   If, instead, <tt>k</tt> is not a member of <tt>m</tt>, <tt>f
--   </tt><a>Nothing</a> is called, and:
--   
--   <ul>
--   <li>If <tt>f</tt> returned <a>Just</a><tt> value</tt>, <tt>value</tt>
--   is inserted into the map, at <tt>k</tt>.</li>
--   <li>If <tt>f</tt> returned <a>Nothing</a>, the map is unchanged.</li>
--   </ul>
--   
--   The function is applied lazily only if the given key is a prefix of
--   another key in the map.
alter :: Map map k => (Maybe a -> Maybe a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Like <a>alter</a>, but the function is always
--   applied strictly.
alter' :: Map map k => (Maybe a -> Maybe a) -> [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(1)</tt>. <a>True</a> iff the map is empty.
null :: Map map k => TrieMap map k a -> Bool

-- | <tt>O(n m)</tt>. The number of elements in the map. The value is built
--   up lazily, allowing for delivery of partial results without traversing
--   the whole map.
size :: (Map map k, Num n) => TrieMap map k a -> n

-- | <tt>O(n m)</tt>. The number of elements in the map. The value is built
--   strictly: no value is returned until the map has been fully traversed.
size' :: (Map map k, Num n) => TrieMap map k a -> n

-- | <tt>O(min(m,s))</tt>. <a>True</a> iff the given key is associated with
--   a value in the map.
member :: Map map k => [k] -> TrieMap map k a -> Bool

-- | <tt>O(min(m,s))</tt>. <a>False</a> iff the given key is associated
--   with a value in the map.
notMember :: Map map k => [k] -> TrieMap map k a -> Bool

-- | <tt>O(min(m,s))</tt>. <a>Just</a> the value in the map associated with
--   the given key, or <a>Nothing</a> if the key is not a member of the
--   map.
lookup :: Map map k => [k] -> TrieMap map k a -> Maybe a

-- | <tt>O(min(m,s))</tt>. Like <a>lookup</a>, but returns the given value
--   when the key is not a member of the map.
lookupWithDefault :: Map map k => a -> [k] -> TrieMap map k a -> a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. <a>True</a> iff the first map is a
--   submap of the second, i.e. all keys that are members of the first map
--   are also members of the second map, and their associated values are
--   the same.
--   
--   <pre>
--   isSubmapOf = isSubmapOfBy (==)
--   </pre>
isSubmapOf :: (Map map k, Eq a) => TrieMap map k a -> TrieMap map k a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>isSubmapOf</a>, but one can
--   specify the equality relation applied to the values.
--   
--   <a>True</a> iff all keys that are members of the first map are also
--   members of the second map, and the given function <tt>f</tt> returns
--   <a>True</a> for all <tt>f firstMapValue secondMapValue</tt> where
--   <tt>firstMapValue</tt> and <tt>secondMapValue</tt> are associated with
--   the same key.
isSubmapOfBy :: Map map k => (a -> b -> Bool) -> TrieMap map k a -> TrieMap map k b -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. <a>True</a> iff the first map is a
--   proper submap of the second, i.e. all keys that are members of the
--   first map are also members of the second map, and their associated
--   values are the same, but the maps are not equal. That is, at least one
--   key was a member of the second map but not the first.
--   
--   <pre>
--   isProperSubmapOf = isProperSubmapOfBy (==)
--   </pre>
isProperSubmapOf :: (Map map k, Eq a) => TrieMap map k a -> TrieMap map k a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>isProperSubmapOf</a>, but one
--   can specify the equality relation applied to the values.
--   
--   <a>True</a> iff all keys that are members of the first map are also
--   members of the second map, and the given function <tt>f</tt> returns
--   <a>True</a> for all <tt>f firstMapValue secondMapValue</tt> where
--   <tt>firstMapValue</tt> and <tt>secondMapValue</tt> are associated with
--   the same key, and at least one key in the second map is not a member
--   of the first.
isProperSubmapOfBy :: Map map k => (a -> b -> Bool) -> TrieMap map k a -> TrieMap map k b -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The union of the two maps: the map which
--   contains all keys that are members of either map. This union is
--   left-biased: if a key is a member of both maps, the value from the
--   first map is chosen.
--   
--   The worst-case performance occurs when the two maps are identical.
--   
--   <pre>
--   union = unionWith const
--   </pre>
union :: Map map k => TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>union</a>, but the combining
--   function (<a>const</a>) is applied strictly.
--   
--   <pre>
--   union' = unionWith' const
--   </pre>
union' :: Map map k => TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. The union of all the maps: the map which contains
--   all keys that are members of any of the maps. If a key is a member of
--   multiple maps, the value that occurs in the earliest of the maps
--   (according to the order of the given list) is chosen.
--   
--   The worst-case performance occurs when all the maps are identical.
--   
--   <pre>
--   unions = unionsWith const
--   </pre>
unions :: Map map k => [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unions</a>, but the combining function
--   (<a>const</a>) is applied strictly.
--   
--   <pre>
--   unions' = unionsWith' const
--   </pre>
unions' :: Map map k => [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>union</a>, but the given
--   function is used to determine the new value if a key is a member of
--   both given maps. For a function <tt>f</tt>, the new value is <tt>f
--   firstMapValue secondMapValue</tt>.
unionWith :: Map map k => (a -> a -> a) -> TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>unionWith</a>, but in addition
--   to the two values, the key is passed to the combining function.
unionWithKey :: Map map k => ([k] -> a -> a -> a) -> TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unions</a>, but the given function
--   determines the final value if a key is a member of more than one map.
--   The function is applied as a left fold over the values in the given
--   list's order. For example:
--   
--   <pre>
--   unionsWith (-) [fromList [("a",1)],fromList [("a",2)],fromList [("a",3)]]
--      == fromList [("a",(1-2)-3)]
--      == fromList [("a",-4)]
--   </pre>
unionsWith :: Map map k => (a -> a -> a) -> [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unionsWith</a>, but in addition to the two
--   values under consideration, the key is passed to the combining
--   function.
unionsWithKey :: Map map k => ([k] -> a -> a -> a) -> [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>unionWith</a>, but the combining
--   function is applied strictly.
unionWith' :: Map map k => (a -> a -> a) -> TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>unionWithKey</a>, but the
--   combining function is applied strictly.
unionWithKey' :: Map map k => ([k] -> a -> a -> a) -> TrieMap map k a -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unionsWith</a>, but the combining function
--   is applied strictly.
unionsWith' :: Map map k => (a -> a -> a) -> [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(sum(n))</tt>. Like <a>unionsWithKey</a>, but the combining
--   function is applied strictly.
unionsWithKey' :: Map map k => ([k] -> a -> a -> a) -> [TrieMap map k a] -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The difference of the two maps: the map
--   which contains all keys that are members of the first map and not of
--   the second.
--   
--   The worst-case performance occurs when the two maps are identical.
--   
--   <pre>
--   difference = differenceWith (\_ _ -&gt; Nothing)
--   </pre>
difference :: Map map k => TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>difference</a>, but the given
--   function determines what to do when a key is a member of both maps. If
--   the function returns <a>Nothing</a>, the key is removed; if it returns
--   <a>Just</a> a new value, that value replaces the old one in the first
--   map.
differenceWith :: Map map k => (a -> b -> Maybe a) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>differenceWith</a>, but in
--   addition to the two values, the key they are associated with is passed
--   to the combining function.
differenceWithKey :: Map map k => ([k] -> a -> b -> Maybe a) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The intersection of the two maps: the
--   map which contains all keys that are members of both maps.
--   
--   The worst-case performance occurs when the two maps are identical.
--   
--   <pre>
--   intersection = intersectionWith const
--   </pre>
intersection :: Map map k => TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersection</a>, but the
--   combining function is applied strictly.
--   
--   <pre>
--   intersection' = intersectionWith' const
--   </pre>
intersection' :: Map map k => TrieMap map k a -> TrieMap map k b -> TrieMap map k a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersection</a>, but the given
--   function determines the new values.
intersectionWith :: Map map k => (a -> b -> c) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k c

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersectionWith</a>, but in
--   addition to the two values, the key they are associated with is passed
--   to the combining function.
intersectionWithKey :: Map map k => ([k] -> a -> b -> c) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k c

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersectionWith</a>, but the
--   combining function is applied strictly.
intersectionWith' :: Map map k => (a -> b -> c) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k c

-- | <tt>O(min(n1 m1,n2 m2))</tt>. Like <a>intersectionWithKey</a>, but the
--   combining function is applied strictly.
intersectionWithKey' :: Map map k => ([k] -> a -> b -> c) -> TrieMap map k a -> TrieMap map k b -> TrieMap map k c

-- | <tt>O(n m)</tt>. Apply the given function to the elements in the map,
--   discarding those for which the function returns <a>False</a>.
filter :: Map map k => (a -> Bool) -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>filter</a>, but the key associated with the
--   element is also passed to the given predicate.
filterWithKey :: Map map k => ([k] -> a -> Bool) -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(n m)</tt>. A pair of maps: the first element contains those
--   values for which the given predicate returns <a>True</a>, and the
--   second contains those for which it was <a>False</a>.
partition :: Map map k => (a -> Bool) -> TrieMap map k a -> (TrieMap map k a, TrieMap map k a)

-- | <tt>O(n m)</tt>. Like <a>partition</a>, but the key associated with
--   the element is also passed to the given predicate.
partitionWithKey :: Map map k => ([k] -> a -> Bool) -> TrieMap map k a -> (TrieMap map k a, TrieMap map k a)

-- | <tt>O(n m)</tt>. Apply the given function to the elements in the map,
--   preserving only the <a>Just</a> results.
mapMaybe :: Map map k => (a -> Maybe b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Like <a>mapMaybe</a>, but the key associated with the
--   element is also passed to the given function.
mapMaybeWithKey :: Map map k => ([k] -> a -> Maybe b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Apply the given function to the elements in the map,
--   separating the <a>Left</a> results from the <a>Right</a>. The first
--   element of the pair contains the former results, and the second the
--   latter.
mapEither :: Map map k => (a -> Either b c) -> TrieMap map k a -> (TrieMap map k b, TrieMap map k c)

-- | <tt>O(n m)</tt>. Like <a>mapEither</a>, but the key associated with
--   the element is also passed to the given function.
mapEitherWithKey :: Map map k => ([k] -> a -> Either b c) -> TrieMap map k a -> (TrieMap map k b, TrieMap map k c)

-- | <tt>O(n m)</tt>. Apply the given function to all the elements in the
--   map.
map :: Map map k => (a -> b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Like <a>map</a>, but apply the function strictly.
map' :: Map map k => (a -> b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Like <a>map</a>, but also pass the key associated
--   with the element to the given function.
mapWithKey :: Map map k => ([k] -> a -> b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Like <a>mapWithKey</a>, but apply the function
--   strictly.
mapWithKey' :: Map map k => ([k] -> a -> b) -> TrieMap map k a -> TrieMap map k b

-- | <tt>O(n m)</tt>. Apply the given function to all the keys in a map.
--   
--   <pre>
--   mapKeys = mapKeysWith const
--   </pre>
mapKeys :: (Map map k1, Map map k2) => ([k1] -> [k2]) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>mapKeys</a>, but use the first given function
--   to combine elements if the second function gives two keys the same
--   value.
mapKeysWith :: (Map map k1, Map map k2) => (a -> a -> a) -> ([k1] -> [k2]) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Apply the given function to the contents of all the
--   keys in the map.
--   
--   <pre>
--   mapInKeys = mapInKeysWith const
--   </pre>
mapInKeys :: (Map map k1, Map map k2) => (k1 -> k2) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>mapInKeys</a>, but combine identical keys
--   strictly.
--   
--   <pre>
--   mapInKeys' = mapInKeysWith' const
--   </pre>
mapInKeys' :: (Map map k1, Map map k2) => (k1 -> k2) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>mapInKeys</a>, but use the first given
--   function to combine elements if the second function gives two keys the
--   same value.
mapInKeysWith :: (Map map k1, Map map k2) => (a -> a -> a) -> (k1 -> k2) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>mapInKeysWith</a>, but apply the combining
--   function strictly.
mapInKeysWith' :: (Map map k1, Map map k2) => (a -> a -> a) -> (k1 -> k2) -> TrieMap map k1 a -> TrieMap map k2 a

-- | <tt>O(n m)</tt>. Like <a>Data.List</a>.<tt>mapAccumL</tt> on the
--   <a>toList</a> representation.
--   
--   Essentially a combination of <a>map</a> and <a>foldl</a>: the given
--   function is applied to each element of the map, resulting in a new
--   value for the accumulator and a replacement element for the map.
mapAccum :: Map map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccum</a>, but the function receives the
--   key in addition to the value associated with it.
mapAccumWithKey :: Map map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccum</a>, but the function is applied
--   strictly.
mapAccum' :: Map map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumWithKey</a>, but the function is
--   applied strictly.
mapAccumWithKey' :: Map map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccum</a>, but in ascending order, as
--   though operating on the <a>toAscList</a> representation.
mapAccumAsc :: OrdMap map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumAsc</a>, but the function receives
--   the key in addition to the value associated with it.
mapAccumAscWithKey :: OrdMap map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumAsc</a>, but the function is applied
--   strictly.
mapAccumAsc' :: OrdMap map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumAscWithKey</a>, but the function is
--   applied strictly.
mapAccumAscWithKey' :: OrdMap map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccum</a>, but in descending order, as
--   though operating on the <a>toDescList</a> representation.
mapAccumDesc :: OrdMap map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumDesc</a>, but the function receives
--   the key in addition to the value associated with it.
mapAccumDescWithKey :: OrdMap map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumDesc</a>, but the function is applied
--   strictly.
mapAccumDesc' :: OrdMap map k => (acc -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Like <a>mapAccumDescWithKey</a>, but the function is
--   applied strictly.
mapAccumDescWithKey' :: OrdMap map k => (acc -> [k] -> a -> (acc, b)) -> acc -> TrieMap map k a -> (acc, TrieMap map k b)

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toList</a> representation, folding only over the elements.
foldr :: Map map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toList</a> representation, folding over both the keys and the
--   elements.
foldrWithKey :: Map map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toAscList</a> representation.
foldrAsc :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toAscList</a> representation, folding over both the keys and the
--   elements.
foldrAscWithKey :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toDescList</a> representation.
foldrDesc :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toDescList</a> representation, folding over both the keys and the
--   elements.
foldrDescWithKey :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toList
--   representation.
foldl :: Map map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toList
--   representation, folding over both the keys and the elements.
foldlWithKey :: Map map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toAscList
--   representation.
foldlAsc :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toAscList
--   representation, folding over both the keys and the elements.
foldlAscWithKey :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toDescList
--   representation.
foldlDesc :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the toDescList
--   representation, folding over both the keys and the elements.
foldlDescWithKey :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toList</a> representation.
foldl' :: Map map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toList</a> representation, folding over both the keys and the
--   elements.
foldlWithKey' :: Map map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toAscList</a> representation.
foldlAsc' :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toAscList</a> representation, folding over both the keys and the
--   elements.
foldlAscWithKey' :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toDescList</a> representation.
foldlDesc' :: OrdMap map k => (a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toDescList</a> representation, folding over both the keys and the
--   elements.
foldlDescWithKey' :: OrdMap map k => ([k] -> a -> b -> b) -> b -> TrieMap map k a -> b

-- | <tt>O(n m)</tt>. Converts the map to a list of the key-value pairs
--   contained within, in undefined order.
toList :: Map map k => TrieMap map k a -> [([k], a)]

-- | <tt>O(n m)</tt>. Converts the map to a list of the key-value pairs
--   contained within, in ascending order.
toAscList :: OrdMap map k => TrieMap map k a -> [([k], a)]

-- | <tt>O(n m)</tt>. Converts the map to a list of the key-value pairs
--   contained within, in descending order.
toDescList :: OrdMap map k => TrieMap map k a -> [([k], a)]

-- | <tt>O(n m)</tt>. Creates a map from a list of key-value pairs. If a
--   key occurs more than once, the value from the last pair (according to
--   the list's order) is the one which ends up in the map.
--   
--   <pre>
--   fromList = fromListWith const
--   </pre>
fromList :: Map map k => [([k], a)] -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>fromList</a>, but the given function is used
--   to determine the final value if a key occurs more than once. The
--   function is applied as though it were flipped and then applied as a
--   left fold over the values in the given list's order. Or, equivalently
--   (except as far as performance is concerned), as though the function
--   were applied as a right fold over the values in the reverse of the
--   given list's order. For example:
--   
--   <pre>
--   fromListWith (-) [("a",1),("a",2),("a",3),("a",4)]
--      == fromList [("a",4-(3-(2-1)))]
--      == fromList [("a",2)]
--   </pre>
fromListWith :: Map map k => (a -> a -> a) -> [([k], a)] -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>fromListWith</a>, but the key, in addition to
--   the values to be combined, is passed to the combining function.
fromListWithKey :: Map map k => ([k] -> a -> a -> a) -> [([k], a)] -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>fromListWith</a>, but the combining function
--   is applied strictly.
fromListWith' :: Map map k => (a -> a -> a) -> [([k], a)] -> TrieMap map k a

-- | <tt>O(n m)</tt>. Like <a>fromListWithKey</a>, but the combining
--   function is applied strictly.
fromListWithKey' :: Map map k => ([k] -> a -> a -> a) -> [([k], a)] -> TrieMap map k a

-- | <tt>O(m)</tt>. Removes and returns the minimal key in the map, along
--   with the value associated with it. If the map is empty, <a>Nothing</a>
--   and the original map are returned.
minView :: OrdMap map k => TrieMap map k a -> (Maybe ([k], a), TrieMap map k a)

-- | <tt>O(m)</tt>. Removes and returns the maximal key in the map, along
--   with the value associated with it. If the map is empty, <a>Nothing</a>
--   and the original map are returned.
maxView :: OrdMap map k => TrieMap map k a -> (Maybe ([k], a), TrieMap map k a)

-- | <tt>O(m)</tt>. Like <a>fst</a> composed with <a>minView</a>.
--   <a>Just</a> the minimal key in the map and its associated value, or
--   <a>Nothing</a> if the map is empty.
findMin :: OrdMap map k => TrieMap map k a -> Maybe ([k], a)

-- | <tt>O(m)</tt>. Like <a>fst</a> composed with <a>maxView</a>.
--   <a>Just</a> the minimal key in the map and its associated value, or
--   <a>Nothing</a> if the map is empty.
findMax :: OrdMap map k => TrieMap map k a -> Maybe ([k], a)

-- | <tt>O(m)</tt>. Like <a>snd</a> composed with <a>minView</a>. The map
--   without its minimal key, or the unchanged original map if it was
--   empty.
deleteMin :: OrdMap map k => TrieMap map k a -> TrieMap map k a

-- | <tt>O(m)</tt>. Like <a>snd</a> composed with <a>maxView</a>. The map
--   without its maximal key, or the unchanged original map if it was
--   empty.
deleteMax :: OrdMap map k => TrieMap map k a -> TrieMap map k a

-- | <tt>O(min(m,s))</tt>. Splits the map in two about the given key. The
--   first element of the resulting pair is a map containing the keys
--   lesser than the given key; the second contains those keys that are
--   greater.
split :: OrdMap map k => [k] -> TrieMap map k a -> (TrieMap map k a, TrieMap map k a)

-- | <tt>O(min(m,s))</tt>. Like <a>split</a>, but also returns the value
--   associated with the given key, if any.
splitLookup :: OrdMap map k => [k] -> TrieMap map k a -> (TrieMap map k a, Maybe a, TrieMap map k a)

-- | <tt>O(m)</tt>. <a>Just</a> the key of the map which precedes the given
--   key in order, along with its associated value, or <a>Nothing</a> if
--   the map is empty.
findPredecessor :: OrdMap map k => [k] -> TrieMap map k a -> Maybe ([k], a)

-- | <tt>O(m)</tt>. <a>Just</a> the key of the map which succeeds the given
--   key in order, along with its associated value, or <a>Nothing</a> if
--   the map is empty.
findSuccessor :: OrdMap map k => [k] -> TrieMap map k a -> Maybe ([k], a)

-- | <tt>O(s)</tt>. The map which contains all keys of which the given key
--   is a prefix. For example:
--   
--   <pre>
--   lookupPrefix "ab" (fromList [("a",1),("ab",2),("ac",3),("abc",4)])
--      == fromList [("ab",2),("abc",4)]
--   </pre>
lookupPrefix :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(s)</tt>. Prepends the given key to all the keys of the map. For
--   example:
--   
--   <pre>
--   addPrefix "xa" (fromList [("a",1),("b",2)])
--      == fromList [("xaa",1),("xab",2)]
--   </pre>
addPrefix :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(s)</tt>. The map which contains all keys of which the given key
--   is a prefix, with the prefix removed from each key. If the given key
--   is not a prefix of any key in the map, an empty map is returned. For
--   example:
--   
--   <pre>
--   deletePrefix "a" (fromList [("a",1),("ab",2),("ac",3)])
--      == fromList [("",1),("b",2),("c",3)]
--   </pre>
--   
--   This function can be used, for instance, to reduce potentially
--   expensive I/O operations: if you need to find the value in a map
--   associated with a string, but you only have a prefix of it and
--   retrieving the rest is an expensive operation, calling
--   <a>deletePrefix</a> with what you have might allow you to avoid the
--   operation: if the resulting map is empty, the entire string cannot be
--   a member of the map.
deletePrefix :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(s)</tt>. Deletes all keys which are suffixes of the given key.
--   For example:
--   
--   <pre>
--   deleteSuffixes "ab" (fromList $ zip ["a","ab","ac","b","abc"] [1..])
--      == fromList [("a",1),("ac",3),("b",4)]
--   </pre>
deleteSuffixes :: Map map k => [k] -> TrieMap map k a -> TrieMap map k a

-- | <tt>O(m)</tt>. A triple containing the longest common prefix of all
--   keys in the map, the value associated with that prefix, if any, and
--   the map with that prefix removed from all the keys as well as the map
--   itself. Examples:
--   
--   <pre>
--   splitPrefix (fromList [("a",1),("b",2)])
--      == ("", Nothing, fromList [("a",1),("b",2)])
--   splitPrefix (fromList [("a",1),("ab",2),("ac",3)])
--      == ("a", Just 1, fromList [("b",2),("c",3)])
--   </pre>
splitPrefix :: Map map k => TrieMap map k a -> ([k], Maybe a, TrieMap map k a)

-- | <tt>O(m)</tt>. The children of the longest common prefix in the trie
--   as maps, associated with their distinguishing key value. If the map
--   contains less than two keys, this function will return an empty map.
--   Examples;
--   
--   <pre>
--   children (fromList [("a",1),("abc",2),("abcd",3)])
--      == Map.fromList [('b',fromList [("c",2),("cd",3)])]
--   children (fromList [("b",1),("c",2)])
--      == Map.fromList [('b',fromList [("",1)]),('c',fromList [("",2)])]
--   </pre>
children :: Map map k => TrieMap map k a -> map k (TrieMap map k a)

-- | <tt>O(1)</tt>. The children of the first element of the longest common
--   prefix in the trie as maps, associated with their distinguishing key
--   value. If the map contains less than two keys, this function will
--   return an empty map.
--   
--   If the longest common prefix of all keys in the trie is the empty
--   list, this function is equivalent to <a>children</a>.
--   
--   Examples:
--   
--   <pre>
--   children1 (fromList [("abc",1),("abcd",2)])
--      == Map.fromList [('a',fromList [("bc",1),("bcd",2)])]
--   children1 (fromList [("b",1),("c",2)])
--      == Map.fromList [('b',fromList [("",1)]),('c',fromList [("",2)])]
--   </pre>
children1 :: Map map k => TrieMap map k a -> map k (TrieMap map k a)

-- | <tt>O(n m)</tt>. Displays the map's internal structure in an undefined
--   way. That is to say, no program should depend on the function's
--   results.
showTrie :: (Show k, Show a, Map map k) => TrieMap map k a -> ShowS

-- | <tt>O(n m)</tt>. Like <a>showTrie</a>, but uses the given function to
--   display the elements of the map. Still undefined.
showTrieWith :: (Show k, Map map k) => (Maybe a -> ShowS) -> TrieMap map k a -> ShowS
instance (Map map k, Binary k, Binary a) => Binary (TrieMap map k a)
instance (Map map k, Read k, Read a) => Read (TrieMap map k a)
instance (Map map k, Show k, Show a) => Show (TrieMap map k a)
instance (Map map k, Traversable (map k)) => Traversable (TrieMap map k)
instance Map map k => Foldable (TrieMap map k)
instance Map map k => Functor (TrieMap map k)
instance Map map k => Monoid (TrieMap map k a)
instance (Eq (map k (TrieMap map k a)), OrdMap map k, Ord k, Ord a) => Ord (TrieMap map k a)
instance (Eq (map k (TrieMap map k a)), Eq a) => Eq (TrieMap map k a)
instance Map map k => Trie TrieMap Maybe map k


-- | A map from lists of elements that can be compared for equality to
--   arbitrary values, based on a trie.
module Data.ListTrie.Map.Eq
type TrieMap = TrieMap AList


-- | A map from lists of elements that can be totally ordered to arbitrary
--   values, based on a trie.
module Data.ListTrie.Map.Ord
type TrieMap = TrieMap Map


-- | A map from lists of enumerable elements to arbitrary values, based on
--   a trie.
--   
--   Note that those operations which require an ordering, such as
--   <a>toAscList</a>, do not compare the elements themselves, but rather
--   their Int representation after <a>fromEnum</a>.
module Data.ListTrie.Map.Enum
type TrieMap = TrieMap WrappedIntMap


-- | The base implementation of a trie representing a set of lists,
--   generalized over any type of map from key values to tries.
--   
--   Worst-case complexities are given in terms of <tt>n</tt>, <tt>m</tt>,
--   and <tt>s</tt>. <tt>n</tt> refers to the number of keys in the set and
--   <tt>m</tt> to their maximum length. <tt>s</tt> refers to the length of
--   a key given to the function, not any property of the set.
--   
--   In addition, the trie's branching factor plays a part in almost every
--   operation, but the complexity depends on the underlying <a>Map</a>.
--   Thus, for instance, <a>member</a> is actually <tt>O(m f(b))</tt> where
--   <tt>f(b)</tt> is the complexity of a lookup operation on the
--   <a>Map</a> used. This complexity depends on the underlying operation,
--   which is not part of the specification of the visible function. Thus
--   it could change whilst affecting the complexity only for certain Map
--   types: hence this "b factor" is not shown explicitly.
--   
--   Disclaimer: the complexities have not been proven.
module Data.ListTrie.Set

-- | The data structure itself: a set of keys of type <tt>[a]</tt>
--   implemented as a trie, using <tt>map</tt> to map keys of type
--   <tt>a</tt> to sub-tries.
--   
--   Regarding the instances:
--   
--   <ul>
--   <li>The <tt>CMap</tt> type is internal, ignore it. For <a>Eq</a> and
--   <a>Ord</a> an <a>Eq</a> instance is required: what this means is that
--   <tt>map a v</tt> is expected to be an instance of <a>Eq</a>, given
--   <a>Eq</a><tt> v</tt>.</li>
--   <li>The <a>Eq</a> constraint for the <a>Ord</a> instance is
--   misleading: it is needed only because <a>Eq</a> is a superclass of
--   <a>Ord</a>.</li>
--   <li>The <a>Monoid</a> instance defines <a>mappend</a> as <a>union</a>
--   and <a>mempty</a> as <a>empty</a>.</li>
--   </ul>
data TrieSet map a

-- | <tt>O(1)</tt>. The empty set.
empty :: Map map a => TrieSet map a

-- | <tt>O(s)</tt>. The singleton set containing only the given key.
singleton :: Map map a => [a] -> TrieSet map a

-- | <tt>O(min(m,s))</tt>. Inserts the key into the set. If the key is
--   already a member of the set, the set is unchanged.
insert :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(min(m,s))</tt>. Removes the key from the set. If the key is not
--   a member of the set, the set is unchanged.
delete :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(1)</tt>. <a>True</a> iff the set is empty.
null :: Map map a => TrieSet map a -> Bool

-- | <tt>O(n m)</tt>. The number of keys in the set. The value is built up
--   lazily, allowing for delivery of partial results without traversing
--   the whole set.
size :: (Map map a, Num n) => TrieSet map a -> n

-- | <tt>O(n m)</tt>. The number of keys in the set. The value is built
--   strictly: no value is returned until the set has been fully traversed.
size' :: (Map map a, Num n) => TrieSet map a -> n

-- | <tt>O(min(m,s))</tt>. <a>True</a> iff the given key is contained
--   within the set.
member :: Map map a => [a] -> TrieSet map a -> Bool

-- | <tt>O(min(m,s))</tt>. <a>False</a> iff the given key is contained
--   within the set.
notMember :: Map map a => [a] -> TrieSet map a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. <a>True</a> iff the first set is a
--   subset of the second, i.e. all keys that are members of the first set
--   are also members of the second set.
isSubsetOf :: Map map a => TrieSet map a -> TrieSet map a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. <a>True</a> iff the first set is a
--   proper subset of the second, i.e. the first is a subset of the second,
--   but the sets are not equal.
isProperSubsetOf :: Map map a => TrieSet map a -> TrieSet map a -> Bool

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The union of the two sets: the set which
--   contains all keys that are members of either set.
--   
--   The worst-case performance occurs when the two sets are identical.
union :: Map map a => TrieSet map a -> TrieSet map a -> TrieSet map a

-- | <tt>O(sum(n))</tt>. The union of all the sets: the set which contains
--   all keys that are members of any of the sets.
--   
--   The worst-case performance occurs when all the sets are identical.
unions :: Map map a => [TrieSet map a] -> TrieSet map a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The difference of the two sets: the set
--   which contains all keys that are members of the first set and not
--   members of the second set.
--   
--   The worst-case performance occurs when the two sets are identical.
difference :: Map map a => TrieSet map a -> TrieSet map a -> TrieSet map a

-- | <tt>O(min(n1 m1,n2 m2))</tt>. The intersection of the two sets: the
--   set which contains all keys that are members of both sets.
--   
--   The worst-case performance occurs when the two sets are identical.
intersection :: Map map a => TrieSet map a -> TrieSet map a -> TrieSet map a

-- | <tt>O(n m)</tt>. The set of those keys in the set for which the given
--   predicate returns <a>True</a>.
filter :: Map map a => ([a] -> Bool) -> TrieSet map a -> TrieSet map a

-- | <tt>O(n m)</tt>. A pair of sets: the first element contains those keys
--   for which the given predicate returns <a>True</a>, and the second
--   element contains those for which it was <a>False</a>.
partition :: Map map a => ([a] -> Bool) -> TrieSet map a -> (TrieSet map a, TrieSet map a)

-- | <tt>O(n m)</tt>. Apply the given function to all the keys in the set.
map :: (Map map a, Map map b) => ([a] -> [b]) -> TrieSet map a -> TrieSet map b

-- | <tt>O(n m)</tt>. Apply the given function to the contents of all the
--   keys in the set.
mapIn :: (Map map a, Map map b) => (a -> b) -> TrieSet map a -> TrieSet map b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toList</a> representation.
foldr :: Map map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toAscList</a> representation.
foldrAsc :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldr</tt> on the
--   <a>toDescList</a> representation.
foldrDesc :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the
--   <a>toList</a> representation.
foldl :: Map map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the
--   <a>toAscList</a> representation.
foldlAsc :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl</tt> on the
--   <a>toDescList</a> representation.
foldlDesc :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toList</a> representation.
foldl' :: Map map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toAscList</a> representation.
foldlAsc' :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Equivalent to a list <tt>foldl'</tt> on the
--   <a>toDescList</a> representation.
foldlDesc' :: OrdMap map a => ([a] -> b -> b) -> b -> TrieSet map a -> b

-- | <tt>O(n m)</tt>. Converts the set to a list of the keys contained
--   within, in undefined order.
toList :: Map map a => TrieSet map a -> [[a]]

-- | <tt>O(n m)</tt>. Converts the set to a list of the keys contained
--   within, in ascending order.
toAscList :: OrdMap map a => TrieSet map a -> [[a]]

-- | <tt>O(n m)</tt>. Converts the set to a list of the keys contained
--   within, in descending order.
toDescList :: OrdMap map a => TrieSet map a -> [[a]]

-- | <tt>O(n m)</tt>. Creates a set from a list of keys.
fromList :: Map map a => [[a]] -> TrieSet map a

-- | <tt>O(m)</tt>. Removes and returns the minimal key in the set. If the
--   set is empty, <a>Nothing</a> and the original set are returned.
minView :: OrdMap map a => TrieSet map a -> (Maybe [a], TrieSet map a)

-- | <tt>O(m)</tt>. Removes and returns the maximal key in the set. If the
--   set is empty, <a>Nothing</a> and the original set are returned.
maxView :: OrdMap map a => TrieSet map a -> (Maybe [a], TrieSet map a)

-- | <tt>O(m)</tt>. Like <a>fst</a> composed with <a>minView</a>.
--   <a>Just</a> the minimal key in the set, or <a>Nothing</a> if the set
--   is empty.
findMin :: OrdMap map a => TrieSet map a -> Maybe [a]

-- | <tt>O(m)</tt>. Like <a>fst</a> composed with <a>maxView</a>.
--   <a>Just</a> the maximal key in the set, or <a>Nothing</a> if the set
--   is empty.
findMax :: OrdMap map a => TrieSet map a -> Maybe [a]

-- | <tt>O(m)</tt>. Like <a>snd</a> composed with <a>minView</a>. The set
--   without its minimal key, or the unchanged original set if it was
--   empty.
deleteMin :: OrdMap map a => TrieSet map a -> TrieSet map a

-- | <tt>O(m)</tt>. Like <a>snd</a> composed with <a>maxView</a>. The set
--   without its maximal key, or the unchanged original set if it was
--   empty.
deleteMax :: OrdMap map a => TrieSet map a -> TrieSet map a

-- | <tt>O(min(m,s))</tt>. Splits the set in two about the given key. The
--   first element of the resulting pair is a set containing the keys
--   lesser than the given key; the second contains those keys that are
--   greater.
split :: OrdMap map a => [a] -> TrieSet map a -> (TrieSet map a, TrieSet map a)

-- | <tt>O(min(m,s))</tt>. Like <a>split</a>, but also returns whether the
--   given key was a member of the set or not.
splitMember :: OrdMap map a => [a] -> TrieSet map a -> (TrieSet map a, Bool, TrieSet map a)

-- | <tt>O(m)</tt>. <a>Just</a> the key of the set which precedes the given
--   key in order, or <a>Nothing</a> if the set is empty.
findPredecessor :: OrdMap map a => [a] -> TrieSet map a -> Maybe [a]

-- | <tt>O(m)</tt>. <a>Just</a> the key of the set which succeeds the given
--   key in order, or <a>Nothing</a> if the set is empty.
findSuccessor :: OrdMap map a => [a] -> TrieSet map a -> Maybe [a]

-- | <tt>O(s)</tt>. The set which contains all keys of which the given key
--   is a prefix. For example:
--   
--   <pre>
--   lookupPrefix "ab" (fromList ["a","ab","ac","abc"])
--      == fromList ["ab","abc"]
--   </pre>
lookupPrefix :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(s)</tt>. Prepends the given key to all the keys of the set. For
--   example:
--   
--   <pre>
--   addPrefix "pre" (fromList ["a","b"]) == fromList ["prea","preb"]
--   </pre>
addPrefix :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(s)</tt>. The set which contains all keys of which the given key
--   is a prefix, with the prefix removed from each key. If the given key
--   is not a prefix of any key in the set, an empty set is returned. For
--   example:
--   
--   <pre>
--   deletePrefix "a" (fromList ["a","ab","ac"]) == fromList ["","b","c"]
--   </pre>
--   
--   This function can be used, for instance, to reduce potentially
--   expensive I/O operations: if you need to check whether a string is a
--   member of a set, but you only have a prefix of it and retrieving the
--   rest is an expensive operation, calling <a>deletePrefix</a> with what
--   you have might allow you to avoid the operation: if the resulting set
--   is empty, the entire string cannot be a member of the set.
deletePrefix :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(s)</tt>. Deletes all keys which are suffixes of the given key.
--   For example:
--   
--   <pre>
--   deleteSuffixes "ab" (fromList $ zip ["a","ab","ac","b","abc"] [1..])
--      == fromList [("a",1),("ac",3),("b",4)]
--   </pre>
deleteSuffixes :: Map map a => [a] -> TrieSet map a -> TrieSet map a

-- | <tt>O(m)</tt>. A triple containing the longest common prefix of all
--   keys in the set, whether that prefix was a member of the set, and the
--   set with that prefix removed from all the keys as well as the set
--   itself. Examples:
--   
--   <pre>
--   splitPrefix (fromList ["a","b"]) == ("", False, fromList ["a","b"])
--   splitPrefix (fromList ["a","ab","ac"]) == ("a", True, fromList ["b","c"])
--   </pre>
splitPrefix :: Map map a => TrieSet map a -> ([a], Bool, TrieSet map a)

-- | <tt>O(m)</tt>. The children of the longest common prefix in the trie
--   as sets, associated with their distinguishing key value. If the set
--   contains less than two keys, this function will return an empty map.
--   Examples;
--   
--   <pre>
--   children (fromList ["a","abc","abcd"])
--      == Map.fromList [('b',fromList ["c","cd"])]
--   children (fromList ["b","c"])
--      == Map.fromList [('b',fromList [""]),('c',fromList [""])]
--   </pre>
children :: Map map a => TrieSet map a -> map a (TrieSet map a)

-- | <tt>O(1)</tt>. The children of the first element of the longest common
--   prefix in the trie as sets, associated with their distinguishing key
--   value. If the set contains less than two keys, this function will
--   return an empty map.
--   
--   If the longest common prefix of all keys in the trie is the empty
--   list, this function is equivalent to <a>children</a>.
--   
--   Examples:
--   
--   <pre>
--   children1 (fromList ["abc","abcd"])
--      == Map.fromList [('a',fromList ["bc","bcd"])]
--   children1 (fromList ["b","c"])
--      == Map.fromList [('b',fromList [""]),('c',fromList [""])]
--   </pre>
children1 :: Map map a => TrieSet map a -> map a (TrieSet map a)

-- | <tt>O(n m)</tt>. Displays the set's internal structure in an undefined
--   way. That is to say, no program should depend on the function's
--   results.
showTrie :: (Show a, Map map a) => TrieSet map a -> ShowS
instance (Map map a, Binary a) => Binary (TrieSet map a)
instance (Map map k, Binary k, Binary a) => Binary (TrieSetBase map k a)
instance (Map map a, Read a) => Read (TrieSet map a)
instance (Map map a, Show a) => Show (TrieSet map a)
instance Map map a => Monoid (TrieSet map a)
instance (Eq (CMap map a Bool), OrdMap map a, Ord a) => Ord (TrieSet map a)
instance Eq (CMap map a Bool) => Eq (TrieSet map a)
instance (Eq (CMap map a Bool), OrdMap map a, Ord a) => Ord (TrieSetBase map a Bool)
instance Eq (CMap map a Bool) => Eq (TrieSetBase map a Bool)
instance Map map k => Trie TrieSetBase Identity map k


-- | A set of lists of elements that can be compared for equality, based on
--   a trie.
module Data.ListTrie.Set.Eq
type TrieSet = TrieSet AList


-- | A set of lists of elements that can be totally ordered, based on a
--   trie.
module Data.ListTrie.Set.Ord
type TrieSet = TrieSet Map


-- | A set of lists of enumerable elements, based on a trie.
--   
--   Note that those operations which require an ordering, such as
--   <a>toAscList</a>, do not compare the elements themselves, but rather
--   their Int representation after <a>fromEnum</a>.
module Data.ListTrie.Set.Enum
type TrieSet = TrieSet WrappedIntMap
