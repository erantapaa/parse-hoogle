-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Various basic utilities for Pipes.
--   
--   This module contains basic utilities for Pipes to deal with files and
--   chunked binary data, as well as extra combinators like <a>zip</a> and
--   <a>tee</a>.
@package pipes-extra
@version 0.2.0


-- | This module contains an alternative pipe implementation,
--   <a>PutbackPipe</a>, providing an additional primitive <a>putback</a>,
--   which allows data to be inserted into the input stream of the current
--   pipe.
--   
--   PutbackPipes can be used to implement pipes with left-over data, and
--   can be composed vertically (using the Monad instance), but not
--   horizontally.
--   
--   To make use of a PutbackPipe within a <tt>Pipeline</tt>, you need to
--   convert it to a regular <a>Pipe</a> using <a>runPutback</a>.
module Control.Pipe.PutbackPipe

-- | The <a>PutbackPipe</a> data type.
newtype PutbackPipe a b m r
PutbackPipe :: Pipe (Either a a) (Either b a) m r -> PutbackPipe a b m r
unPutback :: PutbackPipe a b m r -> Pipe (Either a a) (Either b a) m r

-- | Create a <a>PutbackPipe</a> from a regular pipe.
fromPipe :: Monad m => Pipe a b m r -> PutbackPipe a b m r

-- | Put back an element into the input stream.
putback :: Monad m => a -> PutbackPipe a b m ()

-- | Same as <a>yield</a> for regular pipes.
yield :: Monad m => b -> PutbackPipe a b m ()

-- | Same as <a>await</a> for regular pipes.
await :: Monad m => PutbackPipe a b m a

-- | Same as <a>tryAwait</a> for regular pipes.
tryAwait :: Monad m => PutbackPipe a b m (Maybe a)

-- | Convert a <a>PutbackPipe</a> to a regular pipe.
runPutback :: Monad m => PutbackPipe a b m r -> Pipe a b m r
instance MonadIO m => MonadIO (PutbackPipe a b m)
instance Monad m => Applicative (PutbackPipe a b m)
instance Monad m => Functor (PutbackPipe a b m)
instance MonadTrans (PutbackPipe a b)
instance Monad m => Monad (PutbackPipe a b m)

module Control.Pipe.Coroutine
data Coroutine a b m r
resume :: Coroutine a b m r -> Pipe a b m r
suspend :: Monad m => Pipe a b m r -> Pipe a x m (Either r (b, Coroutine a b m r))
coroutine :: Monad m => Pipe a b m r -> Coroutine a b m r
step :: Monad m => Coroutine a b m r -> Pipe a x m (Either r (b, Coroutine a b m r))
terminate :: Monad m => Coroutine a b m r -> Pipe a b m ()

module Control.Pipe.Zip
controllable :: Monad m => Producer a m r -> Pipe (Either () (ProducerControl r)) a m r
controllable_ :: Monad m => Producer a m r -> Producer a m r
zip :: Monad m => Producer a m r -> Producer b m r -> Pipe (Either () (ZipControl r)) (Either a b) m r
zip_ :: Monad m => Producer a m r -> Producer b m r -> Producer (Either a b) m r
data ProducerControl r
Done :: r -> ProducerControl r
Error :: SomeException -> ProducerControl r
data ZipControl r
LeftZ :: (ProducerControl r) -> ZipControl r
RightZ :: (ProducerControl r) -> ZipControl r

module Control.Pipe.Binary

-- | Read data from a file.
fileReader :: MonadIO m => FilePath -> Pipe () ByteString m ()

-- | Read data from an open handle.
handleReader :: MonadIO m => Handle -> Pipe () ByteString m ()

-- | Write data to a file.
--   
--   The file is only opened if some data arrives into the pipe.
fileWriter :: MonadIO m => FilePath -> Pipe ByteString Void m r

-- | Write data to a handle.
handleWriter :: MonadIO m => Handle -> Pipe ByteString Void m r

-- | Act as an identity for the first <tt>n</tt> bytes, then terminate
--   returning the unconsumed portion of the last chunk.
take :: Monad m => Int -> Pipe ByteString ByteString m ByteString

-- | Act as an identity as long as the given predicate holds, then
--   terminate returning the unconsumed portion of the last chunk.
takeWhile :: Monad m => (Word8 -> Bool) -> Pipe ByteString ByteString m ByteString

-- | Drop bytes as long as the given predicate holds, then act as an
--   identity.
dropWhile :: Monad m => (Word8 -> Bool) -> Pipe ByteString ByteString m r

-- | Split the chunked input stream into lines, and yield them
--   individually.
lines :: Monad m => Pipe ByteString ByteString m r

-- | Yield individual bytes of the chunked input stream.
bytes :: Monad m => Pipe ByteString Word8 m r


-- | The <a>tee</a> combinators act like <a>idP</a>, but also send a copy
--   of the input to the supplied <a>Consumer</a> (e.g. a file). This is
--   typically done for the purpose of logging a pipeline, showing
--   progress, etc.
module Control.Pipe.Tee

-- | Acts like <a>idP</a>, but also passes a copy to the supplied consumer.
tee :: Monad m => Pipe a Void m r -> Pipe a a m r

-- | Acts like <a>idP</a>, but also writes a copy to a file.
teeFile :: MonadIO m => (a -> ByteString) -> FilePath -> Pipe a a m ()

-- | Acts like, <a>idP</a>, but also writes a copy to the specified log
--   file.
--   
--   This function is equivalent to <tt>teeFile id</tt>.
teeFileBS :: MonadIO m => FilePath -> Pipe ByteString ByteString m ()
