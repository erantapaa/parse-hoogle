-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lightweight generic library for mutually recursive data types.
--   
--   Multiplate is an alternative extension of the Uniplate/Compos core
--   library to support mutally recursive datatypes in a way that is as
--   powerful as Compos, as easy to use as Biplate, and more portable than
--   both of them. Multiplate does not require GADTs and does not require
--   multi-parameter type classes. It only requires rank 3 polymorphism.
@package multiplate
@version 0.0.2


-- | Suppose we are given mutually recursive data types <tt>A</tt>,
--   <tt>B</tt>, and <tt>C</tt>. Here are some definitions of terms.
--   
--   <ul>
--   <li><i><tt>child</tt></i> A maximal subexpression of <tt>A</tt>,
--   <tt>B</tt>, or <tt>C</tt>. A child does not necessarily have to have
--   the same type as the parent. <tt>A</tt> might have some children of
--   type <tt>B</tt> and other children of type <tt>C</tt> or even
--   <tt>A</tt>.</li>
--   <li><i><tt>children</tt></i> A list of all children. In particular
--   children are ordered from left to right.</li>
--   <li><i><tt>descendant</tt></i> Any subexpression of of <tt>A</tt>,
--   <tt>B</tt>, or <tt>C</tt>. Specifically a descendant of an expression
--   is either the expression itself or a descendant of one of its
--   children.</li>
--   <li><i><tt>family</tt></i> A list of all descendant. The order is a
--   context dependent. <a>preorderFold</a> uses preorder, while
--   <a>postorderFold</a> and <a>mapFamilyM</a> uses postorder.</li>
--   <li><i><tt>plate</tt></i> A plate is a record parametrized by a
--   functor <tt>f</tt> with one field of type <tt>A -&gt; f A</tt> for
--   each type belonging to the mutually recursive set of types. For
--   example, a plate for <tt>A</tt>, <tt>B</tt>, and <tt>C</tt> would look
--   like</li>
--   </ul>
--   
--   <pre>
--   data ABCPlate f = ABCPlate
--                   { fieldA :: A -&gt; f A
--                   , fieldB :: B -&gt; f B
--                   , fieldC :: C -&gt; f C
--                   }
--   </pre>
--   
--   Although this above is the original motivation behind multiplate,but
--   you can make any structure you want into a <a>Multiplate</a> as long
--   as you satisfy the two multiplate laws listed below.
--   
--   The names of the functions in this module are based on Sebastian
--   Fischer's Refactoring Uniplate:
--   <a>http://www-ps.informatik.uni-kiel.de/~sebf/projects/traversal.html</a>
module Data.Generics.Multiplate

-- | A plate over <tt>f</tt> consists of several fields of type <tt>A -&gt;
--   f A</tt> for various <tt>A</tt>s. <a>Projector</a> is the type of the
--   projection functions of plates.
type Projector p a = forall f. p f -> a -> f a

-- | A <a>Multiplate</a> is a constructor of kind <tt>(* -&gt; *) -&gt;
--   *</tt> operating on <a>Applicative</a> functors having functions
--   <a>multiplate</a> and <a>mkPlate</a> that satisfy the following two
--   laws:
--   
--   <ol>
--   <li><pre> <a>multiplate</a> <a>purePlate</a> = <a>purePlate</a> where
--   <a>purePlate</a> = <a>mkPlate</a> (\_ -&gt; <a>pure</a>) </pre></li>
--   <li><pre> <a>multiplate</a> (<a>composePlate</a> p1 p2) =
--   <a>composePlate</a> (<a>multiplate</a> p1) (<a>multiplate</a> p2)
--   where <a>composePlate</a> p1 p2 = <a>mkPlate</a> (\proj a -&gt;
--   (<a>Compose</a> (proj p1 `<a>fmap</a>` proj p2 a))) </pre></li>
--   </ol>
--   
--   Note: By parametricity, it suffices for (1) to prove
--   
--   <pre>
--   <a>multiplate</a> (<a>mkPlate</a> (\_ -&gt; <a>Identity</a>)) = <a>mkPlate</a> (\_ -&gt; <a>Identity</a>)
--   </pre>
class Multiplate p
multiplate :: (Multiplate p, Applicative f) => p f -> p f
mkPlate :: Multiplate p => (forall a. Projector p a -> (a -> f a)) -> p f

-- | Given a natural transformation between two functors, <tt>f</tt> and
--   <tt>g</tt>, and a plate over <tt>f</tt>, compose the natural
--   transformation with each field of the plate.
applyNaturalTransform :: Multiplate p => (forall a. f a -> g a) -> p f -> p g

-- | Given an <a>Applicative</a> <tt>f</tt>, <a>purePlate</a> builds a
--   plate over <tt>f</tt> whose fields are all <a>pure</a>.
--   
--   Generally <a>purePlate</a> is used as the base of a record update. One
--   constructs the expression
--   
--   <pre>
--   <a>purePlate</a> { <i>fieldOfInterest</i> = \a -&gt; case a of 
--               | <i>constructorOfInterest</i> -&gt; <i>expr</i>
--               | _                     -&gt; <a>pure</a> a
--             }
--   </pre>
--   
--   and this is a typical parameter that is passed to most functions in
--   this library.
purePlate :: (Multiplate p, Applicative f) => p f

-- | Given an <a>Alternative</a> <tt>f</tt>, <a>emptyPlate</a> builds a
--   plate over <tt>f</tt> whose fields are all <tt><a>const</a>
--   <a>empty</a></tt>.
--   
--   Generally <a>emptyPlate</a> is used as the base of a record update.
--   One constructs the expression
--   
--   <pre>
--   <a>emptyPlate</a> { <i>fieldOfInterest</i> = \a -&gt; case a of 
--                | <i>constructorOfInterest</i> -&gt; <i>expr</i>
--                | _                     -&gt; <a>empty</a>
--              }
--   </pre>
--   
--   and this is a typical parameter that is passed to <a>evalFamily</a>
--   and <a>evalFamilyM</a>.
emptyPlate :: (Multiplate p, Alternative f) => p f

-- | Given two plates over a monad <tt>m</tt>, the fields of the plate can
--   be Kleisli composed (<a>&lt;=&lt;</a>) fieldwise.
kleisliComposePlate :: (Multiplate p, Monad m) => p m -> p m -> p m

-- | Given two plates, they can be composed fieldwise yielding the
--   composite functor.
composePlate :: (Multiplate p, Functor g) => p f -> p g -> p (Compose g f)

-- | Given two plates with one over the <a>Identity</a> functor, the two
--   plates can be composed fieldwise.
composePlateRightId :: Multiplate p => p f -> p Identity -> p f

-- | Given two plates with one over the <a>Identity</a> functor, the two
--   plates can be composed fieldwise.
composePlateLeftId :: (Multiplate p, Functor f) => p Identity -> p f -> p f

-- | Given two plates with one over the <tt><a>Constant</a> o</tt>
--   applicative functor for a <a>Monoid</a> <tt>o</tt>, each field of the
--   plate can be pointwise appended with <a>mappend</a>.
appendPlate :: (Multiplate p, Monoid o) => p (Constant o) -> p (Constant o) -> p (Constant o)

-- | Given a plate whose fields all return a <a>Monoid</a> <tt>o</tt>,
--   <a>mChildren</a> produces a plate that returns the <a>mconcat</a> of
--   all the children of the input.
mChildren :: (Multiplate p, Monoid o) => p (Constant o) -> p (Constant o)

-- | Given a plate whose fields all return a <a>Monoid</a> <tt>o</tt>,
--   <a>preorderFold</a> produces a plate that returns the <a>mconcat</a>
--   of the family of the input. The input itself produces the leftmost
--   element of the concatenation, then this is followed by the family of
--   the first child, then it is followed by the family of the second
--   child, and so forth.
preorderFold :: (Multiplate p, Monoid o) => p (Constant o) -> p (Constant o)

-- | Given a plate whose fields all return a <a>Monoid</a> <tt>o</tt>,
--   <a>preorderFold</a> produces a plate that returns the <a>mconcat</a>
--   of the family of the input. The concatenation sequence begins with the
--   family of the first child, then it is followed by the family of the
--   second child, and so forth until finally the input itself produces the
--   rightmost element of the concatenation.
postorderFold :: (Multiplate p, Monoid o) => p (Constant o) -> p (Constant o)

-- | Given a plate whose fields transform each type, <a>mapChildren</a>
--   returns a plate whose fields transform the children of the input.
mapChildren :: Multiplate p => p Identity -> p Identity

-- | Given a plate whose fields transform each type, <a>mapFamily</a>
--   returns a plate whose fields transform the family of the input. The
--   traversal proceeds bottom up, first transforming the families of the
--   children, before finally transforming the value itself.
mapFamily :: Multiplate p => p Identity -> p Identity

-- | Given a plate whose fields transform each type, <a>mapChildrenM</a>
--   returns a plate whose fields transform the children of the input. The
--   processing is sequenced from the first child to the last child.
mapChildrenM :: (Multiplate p, Applicative m, Monad m) => p m -> p m

-- | Given a plate whose fields transform each type, <a>mapFamilyM</a>
--   returns a plate whose fields transform the family of the input. The
--   sequencing is done in a depth-first postorder traversal.
mapFamilyM :: (Multiplate p, Applicative m, Monad m) => p m -> p m

-- | Given a plate whose fields maybe transforms each type,
--   <a>evalFamily</a> returns a plate whose fields exhaustively transform
--   the family of the input. The traversal proceeds bottom up, first
--   transforming the families of the children. If a transformation
--   succeeds then the result is re-<a>evalFamily</a>ed.
--   
--   A post-condition is that the input transform returns <a>Nothing</a> on
--   all family members of the output, or more formally
--   
--   <pre>
--   <a>preorderFold</a> (<a>applyNaturalTransform</a> t f) `<a>composePlate</a>` (<a>evalFamily</a> f) âŠ‘ <a>purePlate</a>
--    where
--     t :: forall a. <a>Maybe</a> a -&gt; <a>Constant</a> <a>All</a> a
--     t = <a>Constant</a> <a>.</a> <a>All</a> <a>.</a> <a>isNothing</a>
--   </pre>
evalFamily :: Multiplate p => p Maybe -> p Identity

-- | Given a plate whose fields maybe transforms each type,
--   <a>evalFamilyM</a> returns a plate whose fields exhaustively transform
--   the family of the input. The sequencing is done in a depth-first
--   postorder traversal, but if a transformation succeeds then the result
--   is re-<a>evalFamilyM</a>ed.
evalFamilyM :: (Multiplate p, Applicative m, Monad m) => p (MaybeT m) -> p m

-- | Given a plate used for <a>evalFamily</a>, replace returning
--   <a>Nothing</a> with returning the input. This transforms plates
--   suitable for <a>evalFamily</a> into plates suitable form
--   <a>mapFamily</a>.
always :: Multiplate p => p Maybe -> p Identity

-- | Given a plate used for <a>evalFamilyM</a>, replace returning
--   <a>Nothing</a> with returning the input. This transforms plates
--   suitable for <a>evalFamilyM</a> into plates suitable form
--   <a>mapFamilyM</a>.
alwaysM :: (Multiplate p, Functor f) => p (MaybeT f) -> p f

-- | Given a projection function for a plate over the <a>Identity</a>
--   functor, upgrade the projection function to strip off the wrapper.
traverseFor :: Multiplate p => Projector p a -> p Identity -> a -> a

-- | Instantiate a projection function at a monad.
traverseMFor :: (Multiplate p, Monad m) => Projector p a -> p m -> a -> m a

-- | Given a projection function for a plate over the <tt><a>Constant</a>
--   o</tt> functor, upgrade the projection function to strip off the
--   wrapper.
foldFor :: Multiplate p => Projector p a -> p (Constant o) -> a -> o

-- | Given a projection function for a plate over the <tt><a>Constant</a>
--   o</tt> functor, and a continuation for <tt>o</tt>, upgrade the
--   projection function to strip off the wrapper and run the continuation.
--   
--   Typically the continuation simply strips off a wrapper for <tt>o</tt>.
unwrapFor :: Multiplate p => (o -> b) -> Projector p a -> p (Constant o) -> a -> b

-- | Given a projection function for a plate over the <tt><a>Constant</a>
--   (<a>Sum</a> n)</tt> functor, upgrade the projection function to strip
--   off the wrappers.
sumFor :: Multiplate p => Projector p a -> p (Constant (Sum n)) -> a -> n

-- | Given a projection function for a plate over the <tt><a>Constant</a>
--   (<a>Product</a> n)</tt> functor, upgrade the projection function to
--   strip off the wrappers.
productFor :: Multiplate p => Projector p a -> p (Constant (Product n)) -> a -> n

-- | Given a projection function for a plate over the <tt><a>Constant</a>
--   <a>All</a></tt> functor, upgrade the projection function to strip off
--   the wrappers.
allFor :: Multiplate p => Projector p a -> p (Constant All) -> a -> Bool

-- | Given a projection function for a plate over the <tt><a>Constant</a>
--   <a>Any</a></tt> functor, upgrade the projection function to strip off
--   the wrappers.
anyFor :: Multiplate p => Projector p a -> p (Constant Any) -> a -> Bool

-- | Given a projection function for a plate over the <tt><a>Constant</a>
--   (<a>First</a> n)</tt> functor, upgrade the projection function to
--   strip off the wrappers.
firstFor :: Multiplate p => Projector p a -> p (Constant (First b)) -> a -> Maybe b

-- | Given a projection function for a plate over the <tt><a>Constant</a>
--   (<a>Last</a> n)</tt> functor, upgrade the projection function to strip
--   off the wrappers.
lastFor :: Multiplate p => Projector p a -> p (Constant (Last b)) -> a -> Maybe b
