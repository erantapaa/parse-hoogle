-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Overloading of concurrency variables
--   
--   MonadIO provides for many IO operations to be overloaded over other
--   IO-like monads.
@package monadIO
@version 0.10.1.4


-- | Overloads the standard operations on IORefs, as defined in Data.IORef.
--   This module is name-for-name swappable with Data.IORef unless
--   ghc-specific operations like weak pointers are used.
--   
--   The standard operations on <tt>IORef</tt> (such as <a>newIORef</a>, or
--   <a>modifyIORef</a>) are overloaded over the <a>MonadIO</a> class. A
--   monad <tt>m</tt> is declared an instance of <a>MonadIO</a> by defining
--   a function
--   
--   <pre>
--   liftIO :: IO a -&gt; m a
--   </pre>
module Data.IORef.MonadIO

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)
liftIO :: MonadIO m => IO a -> m a

-- | A mutable variable in the <a>IO</a> monad
data IORef a :: * -> *
newIORef :: MonadIO io => a -> io (IORef a)
readIORef :: MonadIO io => IORef a -> io a
writeIORef :: MonadIO io => IORef a -> a -> io ()
modifyIORef :: MonadIO io => IORef a -> (a -> a) -> io ()
atomicModifyIORef :: MonadIO io => IORef a -> (a -> (a, b)) -> io b


-- | Overloads the standard operations on MVars, Chans, and threads, as
--   defined in Control.Concurrent. This module is name-for-name swappable
--   with Control.Concurrent unless ghc-specific operations like
--   <tt>mergeIO</tt> or <tt>threadWaitRead</tt> are used.
--   
--   The standard operations on <tt>MVar</tt> and <tt>Chan</tt> (such as
--   <a>newEmptyMVar</a>, or <tt>putChan</tt>) are overloaded over the
--   <a>MonadIO</a> class. A monad <tt>m</tt> is declared an instance of
--   <a>MonadIO</a> by defining a function
--   
--   <pre>
--   liftIO :: IO a -&gt; m a
--   </pre>
--   
--   The explicit concurrency operations over threads are available if a
--   monad <tt>m</tt> is declared an instance of the <a>HasFork</a> class,
--   by defining a function
--   
--   <pre>
--   fork :: m () -&gt; m ThreadId
--   </pre>
--   
--   <ul>
--   <li>Example use.</li>
--   </ul>
--   
--   Suppose you define a new monad (EIO say) which is like <a>IO</a>
--   except that it provides an environment too. You will need to declare
--   EIO and instance of the <a>Monad</a> class. In addition, you can
--   declare it in the <a>MonadIO</a> class. For example:
--   
--   <pre>
--   newtype EIO a = EIO {useEnv :: Env -&gt; IO a}
--   
--   instance MonadIO EIO where
--     liftIO m = EIO $ (\_ -&gt; m)
--   </pre>
--   
--   Now the standard operations on <tt>MVar</tt> and <tt>Chan</tt> (such
--   as <a>newEmptyMVar</a>, or <tt>putChan</tt> are immediately available
--   as EIO operations. To enable EIO to fork explicit threads, and to
--   access operations such as <a>killThread</a> and <a>threadDelay</a>,
--   use the declaration
--   
--   <pre>
--   instance HasFork EIO where
--     fork em = EIO $ \e -&gt; forkIO (em `useEnv` e)
--   </pre>
--   
--   <ul>
--   <li>Notes.</li>
--   </ul>
--   
--   The <tt>MVar</tt> operations do not include: withMVar, modifyMVar, or
--   addMVarFinalizer. Consider using TMVars for these instead. In
--   particular, modifyMVar seems to promise atomicity, but it is NOT
--   atomic. In contrast TMVars can be used just like MVars, and they will
--   behave the way you expect (module Control.Concurrent.STM.MonadIO).
module Control.Concurrent.MonadIO

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)
liftIO :: MonadIO m => IO a -> m a

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a a box, which may be empty or full.
data MVar a :: * -> *
newEmptyMVar :: MonadIO io => io (MVar a)
newMVar :: MonadIO io => a -> io (MVar a)
takeMVar :: MonadIO io => MVar a -> io a
putMVar :: MonadIO io => MVar a -> a -> io ()
readMVar :: MonadIO io => MVar a -> io a
swapMVar :: MonadIO io => MVar a -> a -> io a
tryTakeMVar :: MonadIO io => MVar a -> io (Maybe a)
tryPutMVar :: MonadIO io => MVar a -> a -> io Bool
isEmptyMVar :: MonadIO io => MVar a -> io Bool

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a :: * -> *
newChan :: MonadIO io => io (Chan a)
writeChan :: MonadIO io => Chan a -> a -> io ()
readChan :: MonadIO io => Chan a -> io a
dupChan :: MonadIO io => Chan a -> io (Chan a)
unGetChan :: MonadIO io => Chan a -> a -> io ()
isEmptyChan :: MonadIO io => Chan a -> io Bool
getChanContents :: MonadIO io => Chan a -> io [a]
writeList2Chan :: MonadIO io => Chan a -> [a] -> io ()
class MonadIO io => HasFork io
fork :: HasFork io => io () -> io ThreadId

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
--   
--   <i>Note</i>: Hugs does not provide any operations on other threads; it
--   defines <a>ThreadId</a> as a synonym for ().
data ThreadId :: *

-- | Included to maintain name-for-name compatibility with
--   Control.Concurrent
forkIO :: IO () -> IO ThreadId
myThreadId :: HasFork io => io ThreadId
killThread :: HasFork io => ThreadId -> io ()
throwTo :: (Exception e, HasFork io) => ThreadId -> e -> io ()
yield :: HasFork io => io ()
threadDelay :: HasFork io => Int -> io ()
instance HasFork IO


-- | Overloads the standard operations on TVars, and TMVars as defined in
--   Control.Concurrent.STM.
--   
--   TVars and MVars are often thought of as variables to be used in the
--   STM monad. But in practice, they should be used just as frequently (if
--   not more so) in any IO-like monad, with STM being used purely when a
--   new atomic transaction is being defined. Thus we reverse the naming
--   convention, and use the plain access names when in the IO-like monad,
--   and use an explicit STM suffix when using the variables tentatively
--   within the STM monad itself.
--   
--   TMVars are particularly valuable when used in an IO-like monad,
--   because operations like readTMVar and modifyTMvar can guarantee the
--   atomicity of the operation (unlike the corresponding operations over
--   MVars).
--   
--   The standard operations on <a>TVar</a> and <a>TMVar</a> (such as
--   <a>writeTVar</a> or <a>newEmptyTMVar</a>) are overloaded over the
--   <a>MonadIO</a> class. A monad <tt>m</tt> is declared an instance of
--   <a>MonadIO</a> by defining a function
--   
--   <pre>
--   liftIO :: IO a -&gt; m a
--   </pre>
--   
--   It also overloads the <a>atomically</a> function, so that STM
--   transactions can be defined from within any MonadIO monad.
module Control.Concurrent.STM.MonadIO

-- | A monad supporting atomic memory transactions.
data STM a :: * -> *

-- | The atomically function allows STM to be called directly from any
--   monad which contains IO, i.e. is a member of MonadIO.
atomically :: MonadIO io => STM a -> io a

-- | always is a variant of alwaysSucceeds in which the invariant is
--   expressed as an STM Bool action that must return True. Returning False
--   or raising an exception are both treated as invariant failures.
always :: STM Bool -> STM ()

-- | alwaysSucceeds adds a new invariant that must be true when passed to
--   alwaysSucceeds, at the end of the current transaction, and at the end
--   of every subsequent transaction. If it fails at any of those points
--   then the transaction violating it is aborted and the exception raised
--   by the invariant is propagated.
alwaysSucceeds :: STM a -> STM ()

-- | Retry execution of the current memory transaction because it has seen
--   values in TVars which mean that it should not continue (e.g. the TVars
--   represent a shared buffer that is now empty). The implementation may
--   block the thread until one of the TVars that it has read from has been
--   udpated. (GHC only)
retry :: STM a

-- | Compose two alternative STM actions (GHC only). If the first action
--   completes without retrying then it forms the result of the orElse.
--   Otherwise, if the first action retries, then the second action is
--   tried in its place. If both actions retry then the orElse as a whole
--   retries.
orElse :: STM a -> STM a -> STM a
check :: Bool -> STM ()

-- | Exception handling within STM actions.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a :: * -> *
newTVar :: MonadIO io => a -> io (TVar a)
readTVar :: MonadIO io => TVar a -> io a
writeTVar :: MonadIO io => TVar a -> a -> io ()
registerDelay :: MonadIO io => Int -> io (TVar Bool)

-- | <a>modifyTVar</a> is an atomic update operation which provides both
--   the former value and the newly computed value as a result.
modifyTVar :: MonadIO io => TVar a -> (a -> a) -> io (a, a)
modifyTVar_ :: MonadIO io => TVar a -> (a -> a) -> io ()
newTVarSTM :: a -> STM (TVar a)
readTVarSTM :: TVar a -> STM a
writeTVarSTM :: TVar a -> a -> STM ()

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data TMVar a :: * -> *
newTMVar :: MonadIO io => a -> io (TMVar a)
newEmptyTMVar :: MonadIO io => io (TMVar a)
takeTMVar :: MonadIO io => TMVar a -> io a
putTMVar :: MonadIO io => TMVar a -> a -> io ()
readTMVar :: MonadIO io => TMVar a -> io a
swapTMVar :: MonadIO io => TMVar a -> a -> io a
tryTakeTMVar :: MonadIO io => TMVar a -> io (Maybe a)
tryPutTMVar :: MonadIO io => TMVar a -> a -> io Bool
isEmptyTMVar :: MonadIO io => TMVar a -> io Bool
modifyTMVar :: MonadIO io => TMVar a -> (a -> a) -> io (a, a)
modifyTMVar_ :: MonadIO io => TMVar a -> (a -> a) -> io ()
newTMVarSTM :: a -> STM (TMVar a)
newEmptyTMVarSTM :: STM (TMVar a)
takeTMVarSTM :: TMVar a -> STM a
putTMVarSTM :: TMVar a -> a -> STM ()
readTMVarSTM :: TMVar a -> STM a
swapTMVarSTM :: TMVar a -> a -> STM a
tryTakeTMVarSTM :: TMVar a -> STM (Maybe a)
tryPutTMVarSTM :: TMVar a -> a -> STM Bool
isEmptyTMVarSTM :: TMVar a -> STM Bool


-- | A low-tech concurrent interface to the console. When multiple threads
--   want input, they send messages to the console with the format
--   
--   <pre>
--   &lt;thread-id&gt;:request
--   </pre>
--   
--   The user supplies input to any requesting thread in a similar way:
--   
--   <pre>
--   &lt;thread-id&gt;:response
--   </pre>
--   
--   At any time, the user can enter <tt>!!</tt> to obtain a listing of all
--   the active prompts. Any input not of either of these forms is
--   discarded.
--   
--   <pre>
--   example :: IO ()
--   example = setupStdinout processes
--   
--   processes :: IO ()
--   processes = do
--       forkIO $ (prompt "Enter something" &gt;&gt; return ())
--       forkIO $ (prompt "Something else" &gt;&gt; return ())
--       prompt "quit"      -- When the main thread dies,
--       return ()          -- the whole interaction ends
--   </pre>
module Control.Concurrent.StdInOut

-- | <a>setupStdInOut</a> establishes the context for <a>prompt</a>, by
--   running a daemon while its argument is executing. The daemon is
--   terminated once the argument to <a>setupStdInOut</a> finishes.
setupStdInOut :: IO a -> IO a

-- | <a>prompt</a> is the main user level function of the module. The
--   function prints its argument on stdout, prefixed by its process
--   number. The user similarly selects the recipient by prefixing the
--   process number, e.g. <a>23:</a>. Active prompts will reprompt when !!
--   is entered.
prompt :: HasFork io => String -> io String

-- | <a>putStrLine</a> sends output to stdout, ensuring that lines are
--   whole and uninterrupted (including the final newline).
putStrLine :: MonadIO io => String -> io ()
