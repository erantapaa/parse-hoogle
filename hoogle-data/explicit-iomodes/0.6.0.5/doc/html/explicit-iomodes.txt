-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | File handles with explicit IOModes
--   
--   The module <tt>System.IO.ExplicitIOModes</tt> exports a
--   <tt>Handle</tt> to a file which is parameterized with the IOMode the
--   handle is in. All operations on handles explicitly specify the needed
--   IOMode. This way it is impossible to read from a write-only handle or
--   write to a read-only handle for example.
--   
--   See the <tt>explicit-iomodes-bytestring/text</tt> package for
--   <tt>ByteString/Text</tt> operations.
@package explicit-iomodes
@version 0.6.0.5

module System.IO.ExplicitIOModes.Unsafe

-- | Retrieves the regular <tt>System.IO.</tt><a>Handle</a>.
regularHandle :: Handle ioMode -> Handle
wrap :: (Handle -> α) -> (Handle ioMode -> α)
wrap2 :: (Handle -> β -> α) -> (Handle ioMode -> β -> α)


-- | This module exports a <a>Handle</a> to a file which is parameterized
--   with the IOMode the handle is in. All operations on handles explicitly
--   specify the needed IOMode. This way it is impossible to read from a
--   write-only handle or write to a read-only handle for example.
--   
--   This modules re-exports everything from <a>IO</a> so you can just
--   replace: <tt>import System.IO</tt> with: <tt>import
--   System.IO.ExplicitIOModes</tt>, change some type signatures and expect
--   everything to type-check.
--   
--   There's one exception to this last statement: If you are using the
--   standard handles <a>stdin</a>, <a>stdout</a> or <a>stderr</a> in a
--   mode which isn't their default mode (<a>ReadMode</a> for <a>stdin</a>
--   and <a>WriteMode</a> for <a>stdout</a> and <a>stderr</a>) you have to
--   <a>cast</a> these handles to the expected IOMode.
module System.IO.ExplicitIOModes

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a :: * -> *
fixIO :: (a -> IO a) -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | A handle to a file with an explicit IOMode.
--   
--   Wraps: <tt>System.IO.<a>Handle</a></tt>.
data Handle ioMode

-- | Read only.
data ReadMode

-- | Write only.
data WriteMode

-- | Write only by appending.
data AppendMode

-- | Both read and write.
data ReadWriteMode

-- | Class of readable IO mode types.
--   
--   Note the super class <tt>ReadModesPrivate</tt>. This type class is not
--   exported by this module which ensures you can't accidentally make
--   another type (like <a>WriteMode</a> or <a>AppendMode</a>) an instance
--   of <a>ReadModes</a>.
class ReadModesPrivate ioMode => ReadModes ioMode

-- | Class of writable IO mode types.
--   
--   Note the super class <tt>WriteModesPrivate</tt>. This type class is
--   not exported by this module which ensures you can't accidentally make
--   another type (like <a>ReadMode</a>) an instance of <a>WriteModes</a>.
class WriteModesPrivate ioMode => WriteModes ioMode

-- | The IOMode GADT which for each constructor specifies the associated
--   IOMode type.
--   
--   Also see: <tt>System.IO.<a>IOMode</a></tt>.
data IOMode ioMode
ReadMode :: IOMode ReadMode
WriteMode :: IOMode WriteMode
AppendMode :: IOMode AppendMode
ReadWriteMode :: IOMode ReadWriteMode
class MkIOMode ioMode
mkIOMode :: MkIOMode ioMode => IOMode ioMode

-- | Retrieves the regular <tt>System.IO.<a>IOMode</a></tt>.
regularIOMode :: IOMode ioMode -> IOMode

-- | Wraps: <tt>System.IO.<a>stdin</a></tt>.
stdin :: Handle ReadMode

-- | Wraps: <tt>System.IO.<a>stdout</a></tt>.
stdout :: Handle WriteMode

-- | Wraps: <tt>System.IO.<a>stderr</a></tt>.
stderr :: Handle WriteMode

-- | Cast the IOMode of a handle if the handle supports it.
cast :: CheckMode castedIOMode => Handle anyIOMode -> IO (Maybe (Handle castedIOMode))
class CheckMode ioMode

-- | Wraps: <tt>System.IO.<a>openFile</a></tt>.
openFile :: FilePath -> IOMode ioMode -> IO (Handle ioMode)

-- | Wraps: <tt>System.IO.<a>withFile</a></tt>.
withFile :: FilePath -> IOMode ioMode -> (Handle ioMode -> IO α) -> IO α

-- | Open a file without explicitly specifying the IOMode. The IOMode is
--   inferred from the type of the resulting <a>Handle</a>.
--   
--   Note that: <tt>openFile' fp = <a>openFile</a> fp <a>mkIOMode</a></tt>.
openFile' :: MkIOMode ioMode => FilePath -> IO (Handle ioMode)

-- | Note that: <tt>withFile' fp = <a>withFile</a> fp <a>mkIOMode</a></tt>.
withFile' :: MkIOMode ioMode => FilePath -> (Handle ioMode -> IO α) -> IO α

-- | Wraps: <tt>System.IO.<a>hClose</a></tt>.
hClose :: Handle ioMode -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | Wraps: <tt>System.IO.<a>hFileSize</a></tt>.
hFileSize :: Handle ioMode -> IO Integer

-- | Wraps: <tt>System.IO.<a>hSetFileSize</a></tt>.
hSetFileSize :: Handle ioMode -> Integer -> IO ()

-- | Wraps: <tt>System.IO.<a>hIsEOF</a></tt>.
hIsEOF :: ReadModes ioMode => Handle ioMode -> IO Bool

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode :: *

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | Wraps: <tt>System.IO.<a>hSetBuffering</a></tt>.
hSetBuffering :: Handle ioMode -> BufferMode -> IO ()

-- | Wraps: <tt>System.IO.<a>hGetBuffering</a></tt>.
hGetBuffering :: Handle ioMode -> IO BufferMode

-- | Wraps: <tt>System.IO.<a>hFlush</a></tt>.
hFlush :: Handle ioMode -> IO ()

-- | Wraps: <tt>System.IO.<a>hGetPosn</a></tt>.
hGetPosn :: Handle ioMode -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()
data HandlePosn :: *

-- | Wraps: <tt>System.IO.<a>hSeek</a></tt>.
hSeek :: Handle ioMode -> SeekMode -> Integer -> IO ()

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode :: *

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Wraps: <tt>System.IO.<a>hTell</a></tt>.
hTell :: Handle ioMode -> IO Integer

-- | Wraps: <tt>System.IO.<a>hIsOpen</a></tt>.
hIsOpen :: Handle ioMode -> IO Bool

-- | Wraps: <tt>System.IO.<a>hIsClosed</a></tt>.
hIsClosed :: Handle ioMode -> IO Bool

-- | Wraps: <tt>System.IO.<a>hIsReadable</a></tt>.
hIsReadable :: Handle ioMode -> IO Bool

-- | Wraps: <tt>System.IO.<a>hIsWritable</a></tt>.
hIsWritable :: Handle ioMode -> IO Bool

-- | Wraps: <tt>System.IO.<a>hIsSeekable</a></tt>.
hIsSeekable :: Handle ioMode -> IO Bool

-- | Wraps: <tt>System.IO.<a>hIsTerminalDevice</a></tt>.
hIsTerminalDevice :: Handle ioMode -> IO Bool

-- | Wraps: <tt>System.IO.<a>hSetEcho</a></tt>.
hSetEcho :: Handle ioMode -> Bool -> IO ()

-- | Wraps: <tt>System.IO.<a>hGetEcho</a></tt>.
hGetEcho :: Handle ioMode -> IO Bool

-- | Wraps: <tt>System.IO.<a>hShow</a></tt>.
hShow :: Handle ioMode -> IO String

-- | Wraps: <tt>System.IO.<a>hWaitForInput</a></tt>.
hWaitForInput :: ReadModes ioMode => Handle ioMode -> Int -> IO Bool

-- | Wraps: <tt>System.IO.<a>hReady</a></tt>.
hReady :: ReadModes ioMode => Handle ioMode -> IO Bool

-- | Wraps: <tt>System.IO.<a>hGetChar</a></tt>.
hGetChar :: ReadModes ioMode => Handle ioMode -> IO Char

-- | Wraps: <tt>System.IO.<a>hGetLine</a></tt>.
hGetLine :: ReadModes ioMode => Handle ioMode -> IO String

-- | Wraps: <tt>System.IO.<a>hLookAhead</a></tt>.
hLookAhead :: ReadModes ioMode => Handle ioMode -> IO Char

-- | Wraps: <tt>System.IO.<a>hGetContents</a></tt>.
hGetContents :: ReadModes ioMode => Handle ioMode -> IO String

-- | Wraps: <tt>System.IO.<a>hPutChar</a></tt>.
hPutChar :: WriteModes ioMode => Handle ioMode -> Char -> IO ()

-- | Wraps: <tt>System.IO.<a>hPutStr</a></tt>.
hPutStr :: WriteModes ioMode => Handle ioMode -> String -> IO ()

-- | Wraps: <tt>System.IO.<a>hPutStrLn</a></tt>.
hPutStrLn :: WriteModes ioMode => Handle ioMode -> String -> IO ()

-- | Wraps: <tt>System.IO.<a>hPrint</a></tt>.
hPrint :: (WriteModes ioMode, Show α) => Handle ioMode -> α -> IO ()

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | Wraps: <tt>System.IO.<a>openBinaryFile</a></tt>.
openBinaryFile :: FilePath -> IOMode ioMode -> IO (Handle ioMode)

-- | Wraps: <tt>System.IO.<a>withBinaryFile</a></tt>.
withBinaryFile :: FilePath -> IOMode ioMode -> (Handle ioMode -> IO α) -> IO α

-- | Note that: <tt>openBinaryFile' fp = <a>openBinaryFile</a> fp
--   <a>mkIOMode</a></tt>.
openBinaryFile' :: MkIOMode ioMode => FilePath -> IO (Handle ioMode)

-- | Note that: <tt>withBinaryFile' fp = <a>withBinaryFile</a> fp
--   <a>mkIOMode</a></tt>.
withBinaryFile' :: MkIOMode ioMode => FilePath -> (Handle ioMode -> IO α) -> IO α

-- | Wraps: <tt>System.IO.<a>hSetBinaryMode</a></tt>.
hSetBinaryMode :: Handle ioMode -> Bool -> IO ()

-- | Wraps: <tt>System.IO.<a>hPutBuf</a></tt>.
hPutBuf :: WriteModes ioMode => Handle ioMode -> Ptr α -> Int -> IO ()

-- | Wraps: <tt>System.IO.<a>hGetBuf</a></tt>.
hGetBuf :: ReadModes ioMode => Handle ioMode -> Ptr α -> Int -> IO Int

-- | Wraps: <tt>System.IO.<a>hGetBufSome</a></tt>.
hGetBufSome :: ReadModes ioMode => Handle ioMode -> Ptr α -> Int -> IO Int

-- | Wraps: <tt>System.IO.<a>hPutBufNonBlocking</a></tt>.
hPutBufNonBlocking :: WriteModes ioMode => Handle ioMode -> Ptr α -> Int -> IO Int

-- | Wraps: <tt>System.IO.<a>hGetBufNonBlocking</a></tt>.
hGetBufNonBlocking :: ReadModes ioMode => Handle ioMode -> Ptr α -> Int -> IO Int

-- | Wraps: <tt>System.IO.<a>openTempFile</a></tt>.
openTempFile :: FilePath -> String -> IO (FilePath, Handle ReadWriteMode)

-- | Wraps: <tt>System.IO.<a>openBinaryTempFile</a></tt>.
openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle ReadWriteMode)
openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle ReadWriteMode)
openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle ReadWriteMode)
hSetEncoding :: Handle ioMode -> TextEncoding -> IO ()
hGetEncoding :: Handle ioMode -> IO (Maybe TextEncoding)

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <tt>utf8</tt>.
data TextEncoding :: *

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than '\255' to a
--   <tt>Handle</tt> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (litte-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (litte-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

-- | The Unicode encoding of the current locale
--   
--   This is the initial locale encoding: if it has been subsequently
--   changed by <a>setLocaleEncoding</a> this value will not reflect that
--   change.
localeEncoding :: TextEncoding

-- | An encoding in which Unicode code points are translated to bytes by
--   taking the code point modulo 256. When decoding, bytes are translated
--   directly into the equivalent code point.
--   
--   This encoding never fails in either direction. However, encoding
--   discards information, so encode followed by decode is not the
--   identity.
char8 :: TextEncoding

-- | Look up the named Unicode encoding. May fail with
--   
--   <ul>
--   <li><tt>isDoesNotExistError</tt> if the encoding is unknown</li>
--   </ul>
--   
--   The set of known encodings is system-dependent, but includes at least:
--   
--   <ul>
--   <li><pre>UTF-8</pre></li>
--   <li><tt>UTF-16</tt>, <tt>UTF-16BE</tt>, <tt>UTF-16LE</tt></li>
--   <li><tt>UTF-32</tt>, <tt>UTF-32BE</tt>, <tt>UTF-32LE</tt></li>
--   </ul>
--   
--   On systems using GNU iconv (e.g. Linux), there is additional notation
--   for specifying how illegal characters are handled:
--   
--   <ul>
--   <li>a suffix of <tt>//IGNORE</tt>, e.g. <tt>UTF-8//IGNORE</tt>, will
--   cause all illegal sequences on input to be ignored, and on output will
--   drop all code points that have no representation in the target
--   encoding.</li>
--   <li>a suffix of <tt>//TRANSLIT</tt> will choose a replacement
--   character for illegal sequences or code points.</li>
--   </ul>
--   
--   On Windows, you can access supported code pages with the prefix
--   <tt>CP</tt>; for example, <tt>"CP1250"</tt>.
mkTextEncoding :: String -> IO TextEncoding
hSetNewlineMode :: Handle ioMode -> NewlineMode -> IO ()

-- | The representation of a newline in the external file or stream.
data Newline :: *

-- | '\n'
LF :: Newline

-- | '\r\n'
CRLF :: Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the '\n' character; the newline
--   mode specifies how to translate '\n' on output, and what to translate
--   into '\n' on input.
data NewlineMode :: *
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
inputNL :: NewlineMode -> Newline

-- | the representation of newlines on output
outputNL :: NewlineMode -> Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map '\r\n' into '\n' on input, and '\n' to the native newline
--   represetnation on output. This mode can be used on any platform, and
--   works with text files using any newline convention. The downside is
--   that <tt>readFile &gt;&gt;= writeFile</tt> might yield a different
--   file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF, 
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode
instance CheckMode ReadWriteMode
instance CheckMode AppendMode
instance CheckMode WriteMode
instance CheckMode ReadMode
instance Show (IOMode ioMode)
instance Eq (IOMode ioMode)
instance MkIOMode ReadWriteMode
instance MkIOMode AppendMode
instance MkIOMode WriteMode
instance MkIOMode ReadMode
instance WriteModes ReadWriteMode
instance WriteModesPrivate ReadWriteMode
instance WriteModes AppendMode
instance WriteModesPrivate AppendMode
instance WriteModes WriteMode
instance WriteModesPrivate WriteMode
instance ReadModes ReadWriteMode
instance ReadModesPrivate ReadWriteMode
instance ReadModes ReadMode
instance ReadModesPrivate ReadMode
