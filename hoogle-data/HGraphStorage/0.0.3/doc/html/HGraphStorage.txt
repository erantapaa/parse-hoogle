-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Graph database stored on disk
--   
@package HGraphStorage
@version 0.0.3


-- | Free list management
module Database.Graph.HGraphStorage.FreeList

-- | Free List structure
data FreeList a
FreeList :: Integer -> Handle -> IO () -> FreeList a

-- | Record size
flSize :: FreeList a -> Integer

-- | File handle
flHandle :: FreeList a -> Handle

-- | What to do on close if no record
flOnEmptyClose :: FreeList a -> IO ()

-- | position handle
initFreeList :: (Binary a, MonadIO m) => Integer -> Handle -> IO () -> m (FreeList a)

-- | Close underlying handle and return if we have still objects in the
--   list
closeFreeList :: (Binary a, MonadIO m) => FreeList a -> m Bool

-- | Add object to list
addToFreeList :: (Binary a, MonadIO m) => a -> FreeList a -> m ()

-- | get object to list if list is non empty
getFromFreeList :: (Binary a, Eq a, Default a, MonadIO m) => FreeList a -> m (Maybe a)


-- | Base types and simple functions on them
module Database.Graph.HGraphStorage.Types

-- | put our constraints in one synonym
type GraphUsableMonad m = (MonadBaseControl IO m, MonadResource m, MonadLogger m)

-- | IDs for objects
type ObjectID = Int32

-- | IDs for types of objects
type ObjectTypeID = Int16

-- | IDs for relations
type RelationID = Int32

-- | IDs for types of relations
type RelationTypeID = Int16

-- | IDs for property values
type PropertyID = Int32

-- | IDs for types of properties
type PropertyTypeID = Int16

-- | IDs for data types
type DataTypeID = Int8

-- | Offset of property value on value file
type PropertyValueOffset = Int64

-- | Length of property value on value file
type PropertyValueLength = Int64

-- | An object as represented in the object file
data Object
Object :: ObjectTypeID -> RelationID -> RelationID -> PropertyID -> Object

-- | type of object
oType :: Object -> ObjectTypeID

-- | first relation starting from the object
oFirstFrom :: Object -> RelationID

-- | first relation arriving at the object
oFirstTo :: Object -> RelationID

-- | first property
oFirstProperty :: Object -> PropertyID

-- | Simple binary instance

-- | Simple default instance

-- | Size of an object record
objectSize :: Int64

-- | Calculates the length of the binary serialization of the given object
binLength :: Binary b => b -> Int64

-- | A relation as represented in the relation file
data Relation
Relation :: ObjectID -> ObjectTypeID -> ObjectID -> ObjectTypeID -> RelationTypeID -> RelationID -> RelationID -> PropertyID -> Relation

-- | origin object
rFrom :: Relation -> ObjectID

-- | origin object type
rFromType :: Relation -> ObjectTypeID

-- | target object
rTo :: Relation -> ObjectID

-- | target object type
rToType :: Relation -> ObjectTypeID

-- | type of the relation
rType :: Relation -> RelationTypeID

-- | next relation of origin object
rFromNext :: Relation -> RelationID

-- | next relation of target object
rToNext :: Relation -> RelationID

-- | first property id
rFirstProperty :: Relation -> PropertyID

-- | simple binary instance

-- | simple default instance

-- | size of a relation record
relationSize :: Int64

-- | A property as represented in the property file
data Property
Property :: PropertyTypeID -> PropertyID -> PropertyValueOffset -> PropertyValueLength -> Property

-- | type of the property
pType :: Property -> PropertyTypeID

-- | next property id
pNext :: Property -> PropertyID

-- | offset of the value
pOffset :: Property -> PropertyValueOffset

-- | length of the value
pLength :: Property -> PropertyValueLength

-- | simple binary instance

-- | simple default instance

-- | size of a property record
propertySize :: Int64

-- | Type of a property as represented in the property type file
data PropertyType
PropertyType :: DataTypeID -> PropertyID -> PropertyType

-- | Data type ID
ptDataType :: PropertyType -> DataTypeID

-- | first property of the type itself
ptFirstProperty :: PropertyType -> PropertyID

-- | simple binary instance

-- | simple default instance

-- | size of a property type record
propertyTypeSize :: Int64

-- | Type of an object as represented in the object type file
data ObjectType
ObjectType :: PropertyID -> ObjectType

-- | First property of the type itself
otFirstProperty :: ObjectType -> PropertyID

-- | simple binary instance

-- | simple default instance

-- | Size of an object type record
objectTypeSize :: Int64

-- | Type of a relation as represented in the relation type file
data RelationType
RelationType :: PropertyID -> RelationType

-- | First property of the type itself
rtFirstProperty :: RelationType -> PropertyID

-- | simple binary instance

-- | simple default instance

-- | Size of a relation type record
relationTypeSize :: Int64

-- | Handles to the various files
data Handles
Handles :: Handle -> FreeList ObjectID -> Handle -> Handle -> FreeList ObjectID -> Handle -> Handle -> FreeList ObjectID -> Handle -> Handle -> Handles
hObjects :: Handles -> Handle
hObjectFree :: Handles -> FreeList ObjectID
hObjectTypes :: Handles -> Handle
hRelations :: Handles -> Handle
hRelationFree :: Handles -> FreeList ObjectID
hRelationTypes :: Handles -> Handle
hProperties :: Handles -> Handle
hPropertyFree :: Handles -> FreeList ObjectID
hPropertyTypes :: Handles -> Handle
hPropertyValues :: Handles -> Handle

-- | The current model: lookup tables between names and ids types of
--   artifacts
data Model
Model :: Lookup ObjectTypeID Text -> Lookup RelationTypeID Text -> Lookup PropertyTypeID (Text, DataType) -> Model
mObjectTypes :: Model -> Lookup ObjectTypeID Text
mRelationTypes :: Model -> Lookup RelationTypeID Text
mPropertyTypes :: Model -> Lookup PropertyTypeID (Text, DataType)

-- | Default model: a "name" property property type with a name property

-- | the ID of the "name" property
namePropertyID :: PropertyTypeID

-- | A lookup table allowing two ways lookup
data Lookup a b
Lookup :: Map b a -> Map a b -> Lookup a b
fromName :: Lookup a b -> Map b a
toName :: Lookup a b -> Map a b

-- | Default instance (empty tables)

-- | Add to the lookup maps
addToLookup :: (Ord a, Ord b) => a -> b -> Lookup a b -> Lookup a b

-- | the supported data types for properties
data DataType
DTText :: DataType
DTInteger :: DataType
DTBinary :: DataType

-- | Convert a DataType object to its ID
dataTypeID :: DataType -> DataTypeID

-- | Convert a DataType ID to the Haskell object
dataType :: DataTypeID -> DataType

-- | A typed property value
data PropertyValue
PVText :: Text -> PropertyValue
PVInteger :: Integer -> PropertyValue
PVBinary :: ByteString -> PropertyValue

-- | Get the data type for a given value
valueType :: PropertyValue -> DataType

-- | Get the value in a format ready to index
valueToIndex :: PropertyValue -> [Int16]

-- | Transform a text in a index key
textToKey :: Text -> [Int16]

-- | Transform an integer in a index key
integerToKey :: Integer -> [Int16]

-- | Transform a bytestring in a index key
bytestringToKey :: ByteString -> [Int16]

-- | The exceptions we may throw
data GraphStorageException

-- | Something is not right with the name property
IncoherentNamePropertyTypeID :: PropertyTypeID -> PropertyTypeID -> GraphStorageException
UnknownPropertyType :: PropertyTypeID -> GraphStorageException
NoNameProperty :: PropertyTypeID -> GraphStorageException
MultipleNameProperty :: PropertyTypeID -> GraphStorageException
UnknownObjectType :: ObjectTypeID -> GraphStorageException
UnknownRelationType :: RelationTypeID -> GraphStorageException
DuplicateIndexKey :: [Text] -> GraphStorageException

-- | Make our exception a standard exception

-- | Settings for the Graph DB
data GraphSettings
GraphSettings :: Maybe BufferMode -> Maybe BufferMode -> Maybe BufferMode -> GraphSettings
gsMainBuffering :: GraphSettings -> Maybe BufferMode
gsFreeBuffering :: GraphSettings -> Maybe BufferMode
gsIndexBuffering :: GraphSettings -> Maybe BufferMode

-- | Default instance for settings
instance Typeable Object
instance Typeable Relation
instance Typeable Property
instance Typeable PropertyType
instance Typeable ObjectType
instance Typeable RelationType
instance Typeable Lookup
instance Typeable DataType
instance Typeable Model
instance Typeable PropertyValue
instance Typeable GraphStorageException
instance Typeable GraphSettings
instance Show Object
instance Read Object
instance Eq Object
instance Ord Object
instance Generic Object
instance Show Relation
instance Read Relation
instance Eq Relation
instance Ord Relation
instance Generic Relation
instance Show Property
instance Read Property
instance Eq Property
instance Ord Property
instance Generic Property
instance Show PropertyType
instance Read PropertyType
instance Eq PropertyType
instance Ord PropertyType
instance Generic PropertyType
instance Show ObjectType
instance Read ObjectType
instance Eq ObjectType
instance Ord ObjectType
instance Generic ObjectType
instance Show RelationType
instance Read RelationType
instance Eq RelationType
instance Ord RelationType
instance Generic RelationType
instance (Show a, Show b) => Show (Lookup a b)
instance (Ord a, Ord b, Read a, Read b) => Read (Lookup a b)
instance (Eq a, Eq b) => Eq (Lookup a b)
instance (Ord a, Ord b) => Ord (Lookup a b)
instance Show DataType
instance Read DataType
instance Eq DataType
instance Ord DataType
instance Bounded DataType
instance Enum DataType
instance Show Model
instance Read Model
instance Eq Model
instance Ord Model
instance Show PropertyValue
instance Read PropertyValue
instance Eq PropertyValue
instance Ord PropertyValue
instance Show GraphStorageException
instance Read GraphStorageException
instance Eq GraphStorageException
instance Ord GraphStorageException
instance Show GraphSettings
instance Read GraphSettings
instance Eq GraphSettings
instance Ord GraphSettings
instance Datatype D1Object
instance Constructor C1_0Object
instance Selector S1_0_0Object
instance Selector S1_0_1Object
instance Selector S1_0_2Object
instance Selector S1_0_3Object
instance Datatype D1Relation
instance Constructor C1_0Relation
instance Selector S1_0_0Relation
instance Selector S1_0_1Relation
instance Selector S1_0_2Relation
instance Selector S1_0_3Relation
instance Selector S1_0_4Relation
instance Selector S1_0_5Relation
instance Selector S1_0_6Relation
instance Selector S1_0_7Relation
instance Datatype D1Property
instance Constructor C1_0Property
instance Selector S1_0_0Property
instance Selector S1_0_1Property
instance Selector S1_0_2Property
instance Selector S1_0_3Property
instance Datatype D1PropertyType
instance Constructor C1_0PropertyType
instance Selector S1_0_0PropertyType
instance Selector S1_0_1PropertyType
instance Datatype D1ObjectType
instance Constructor C1_0ObjectType
instance Selector S1_0_0ObjectType
instance Datatype D1RelationType
instance Constructor C1_0RelationType
instance Selector S1_0_0RelationType
instance Default GraphSettings
instance Exception GraphStorageException
instance Default (Lookup a b)
instance Default Model
instance Default RelationType
instance Binary RelationType
instance Default ObjectType
instance Binary ObjectType
instance Default PropertyType
instance Binary PropertyType
instance Default Property
instance Binary Property
instance Default Relation
instance Binary Relation
instance Default Object
instance Binary Object


-- | Index on disk <a>http://sqlity.net/en/2445/b-plus-tree</a>
--   <a>http://en.wikipedia.org/wiki/Trie</a>
module Database.Graph.HGraphStorage.Index

-- | Trie on disk
data Trie k v
Trie :: Handle -> Int64 -> Trie k v

-- | The disk Handle
trHandle :: Trie k v -> Handle

-- | The length of a record
trRecordLength :: Trie k v -> Int64

-- | Create a new trie with a given handle The limitations are: Key and
--   Value must have a binary representation of constant length!
newTrie :: (Binary k, Binary v, Default k, Default v) => Handle -> Trie k v

-- | Build a file backed trie
newFileTrie :: (Binary k, Binary v, Default k, Default v) => FilePath -> IO (Trie k v)

-- | Insert a value if it does not exist in the tree if it exists, return
--   the old value and does nothing
insertNew :: (Binary k, Eq k, Default k, Binary v, Eq v, Default v) => [k] -> v -> Trie k v -> IO (Maybe v)

-- | Insert a value for a key if the value existed for that key, return the
--   old value
insert :: (Binary k, Eq k, Default k, Binary v, Eq v, Default v) => [k] -> v -> Trie k v -> IO (Maybe v)

-- | Lookup a value from a key
lookup :: (Binary k, Eq k, Binary v, Eq v, Default v) => [k] -> Trie k v -> IO (Maybe v)

-- | Return all key and values for the given prefix which may be null (in
--   which case all mappings are returned).
prefix :: (Binary k, Eq k, Binary v, Eq v, Default v) => [k] -> Trie k v -> IO [([k], v)]

-- | Delete the value associated with a key This only remove the value from
--   the trienode, it doesn't prune the trie in any way.
delete :: (Binary k, Eq k, Binary v, Eq v, Default v) => [k] -> Trie k v -> IO (Maybe v)
instance Typeable TrieNode
instance (Show k, Show v) => Show (TrieNode k v)
instance (Read k, Read v) => Read (TrieNode k v)
instance (Eq k, Eq v) => Eq (TrieNode k v)
instance (Ord k, Ord v) => Ord (TrieNode k v)
instance Generic (TrieNode k v)
instance Datatype D1TrieNode
instance Constructor C1_0TrieNode
instance Selector S1_0_0TrieNode
instance Selector S1_0_1TrieNode
instance Selector S1_0_2TrieNode
instance Selector S1_0_3TrieNode
instance (Binary k, Binary v) => Binary (TrieNode k v)


-- | Operations on the data files
module Database.Graph.HGraphStorage.FileOps

-- | Open all the file handles.
open :: FilePath -> GraphSettings -> IO Handles

-- | Set the buffer mode on the given handle, if provided.
setBufferMode :: Handle -> Maybe BufferMode -> IO ()

-- | Close all the file handles
close :: Handles -> IO ()

-- | Read the current model from the handles generate a default model if
--   none present (new db)
readModel :: GraphUsableMonad m => Handles -> m Model

-- | Generic write operation: write the given binary using the given ID and
--   record size if no id, we write at then end otherwise we always ensure
--   that we write at the proper offset, which is why we have fixed length
--   records
writeGeneric :: GraphUsableMonad m => (Integral a, Binary a, Default a, Binary b) => Handle -> Maybe (FreeList a) -> Int64 -> Maybe a -> b -> m a

-- | Read a binary with a given ID from the given handle
readGeneric :: GraphUsableMonad m => (Integral a, Binary b) => Handle -> Int64 -> a -> m b

-- | Read all binary objects from a given handle, generating their IDs from
--   their offset
readAll :: (GraphUsableMonad m, GraphIdSerializable a b) => Handles -> m [(a, b)]

-- | Read all binary objects from a given handle, generating their IDs from
--   their offset
foldAllGeneric :: GraphUsableMonad m => (Integral a, Eq b, Binary b, Default b) => Handle -> Int64 -> (c -> (a, b) -> m c) -> c -> m c

-- | Read all properties, starting from a given one, with an optional
--   filter on the Property Type
readProperties :: GraphUsableMonad m => Handles -> Model -> PropertyTypeID -> PropertyID -> m [(Property, PropertyValue)]

-- | Write a property, knowing the next one in the chain
writeProperty :: GraphUsableMonad m => Handles -> PropertyTypeID -> PropertyID -> PropertyValue -> m PropertyID

-- | Helper method throwing an exception if we got a Maybe, otherwise
--   return the Just value
throwIfNothing :: (MonadBase IO m, Exception e) => e -> Maybe a -> m a

-- | Read a property value given an offset and length
readPropertyValue :: GraphUsableMonad m => Handles -> DataType -> PropertyValueOffset -> PropertyValueLength -> m PropertyValue

-- | A class that defines basic read and write operations for a given ID
--   and binary object
class (Integral a, Binary b) => GraphIdSerializable a b
write :: (GraphIdSerializable a b, GraphUsableMonad m) => Handles -> Maybe a -> b -> m a
readOne :: (GraphIdSerializable a b, GraphUsableMonad m) => Handles -> a -> m b
foldAll :: (GraphIdSerializable a b, GraphUsableMonad m) => Handles -> (c -> (a, b) -> m c) -> c -> m c

-- | Serialization methods for ObjectID + Object

-- | Serialization methods for RelationID + Relation

-- | Serialization methods for PropertyID + Property

-- | Serialization methods for PropertyTypeID + PropertyType

-- | Serialization methods for ObjectTypeID + ObjectType

-- | Serialization methods for RelationTypeID + RelationType
instance GraphIdSerializable RelationTypeID RelationType
instance GraphIdSerializable ObjectTypeID ObjectType
instance GraphIdSerializable PropertyTypeID PropertyType
instance GraphIdSerializable PropertyID Property
instance GraphIdSerializable RelationID Relation
instance GraphIdSerializable ObjectID Object


-- | Higher level API for reading and writing
module Database.Graph.HGraphStorage.API

-- | State for the monad
data GsData
GsData :: Handles -> Model -> FilePath -> GraphSettings -> [(IndexInfo, Trie Int16 ObjectID)] -> GsData
gsHandles :: GsData -> Handles
gsModel :: GsData -> Model
gsDir :: GsData -> FilePath
gsSettings :: GsData -> GraphSettings
gsIndexes :: GsData -> [(IndexInfo, Trie Int16 ObjectID)]

-- | Index metadata
data IndexInfo
IndexInfo :: Text -> [Text] -> [Text] -> IndexInfo
iiName :: IndexInfo -> Text
iiTypes :: IndexInfo -> [Text]
iiProps :: IndexInfo -> [Text]

-- | Run a computation with the graph storage engine, storing the data in
--   the given directory
withGraphStorage :: (MonadThrow m, MonadIO m, MonadLogger m, MonadBaseControl IO m) => FilePath -> GraphSettings -> GraphStorageT (ResourceT m) a -> m a

-- | Our monad transformer.
newtype GraphStorageT m a
Gs :: StateT GsData m a -> GraphStorageT m a
unIs :: GraphStorageT m a -> StateT GsData m a

-- | Monad Base instance.

-- | Monad Trans Control instance.

-- | Monad Base Control instance.

-- | MonadLogger instance.

-- | An object with a type and properties.
data GraphObject a
GraphObject :: a -> Text -> Map Text [PropertyValue] -> GraphObject a
goID :: GraphObject a -> a
goType :: GraphObject a -> Text
goProperties :: GraphObject a -> Map Text [PropertyValue]

-- | A relation between two objects, with a type and properties.
data GraphRelation a b
GraphRelation :: a -> GraphObject b -> GraphObject b -> Text -> Map Text [PropertyValue] -> GraphRelation a b
grID :: GraphRelation a b -> a
grFrom :: GraphRelation a b -> GraphObject b
grTo :: GraphRelation a b -> GraphObject b
grType :: GraphRelation a b -> Text
grProperties :: GraphRelation a b -> Map Text [PropertyValue]

-- | Get the file handles.
getHandles :: Monad m => GraphStorageT m Handles

-- | Get the currently known model.
getModel :: Monad m => GraphStorageT m Model

-- | Get the currently known model.
getDirectory :: Monad m => GraphStorageT m FilePath

-- | Get the current settings.
getSettings :: Monad m => GraphStorageT m GraphSettings

-- | Get the current indices.
getIndices :: Monad m => GraphStorageT m [(IndexInfo, Trie Int16 ObjectID)]

-- | The file used to store the index information.
indexFile :: Monad m => GraphStorageT m FilePath

-- | Create or replace an object.
createObject :: GraphUsableMonad m => GraphObject (Maybe ObjectID) -> GraphStorageT m (GraphObject ObjectID)

-- | Replace an object.
updateObject :: GraphUsableMonad m => GraphObject ObjectID -> GraphStorageT m (GraphObject ObjectID)

-- | Checks if there is a duplicate on any applicable index. Then remove
--   obsolete values from the index, and generate the list of values to add
--   We'll only add the values once the object has been properly written,
--   so we can have the ID of new objects.
removeOldValuesFromIndex :: GraphUsableMonad m => GraphObject a -> Maybe ObjectID -> GraphStorageT m [(Text, [Trie Int16 ObjectID], [PropertyValue])]

-- | Check if duplicates exist in index.
checkDuplicates :: GraphUsableMonad m => Maybe ObjectID -> [(Text, [Trie Int16 ObjectID], [PropertyValue])] -> GraphStorageT m ()

-- | Insert new values in applicable indices.
insertNewValuesInIndex :: GraphUsableMonad m => ObjectID -> [(Text, [Trie Int16 ObjectID], [PropertyValue])] -> GraphStorageT m ()

-- | Create properties from map, returns the first ID in the chain
createProperties :: GraphUsableMonad m => Map Text [PropertyValue] -> GraphStorageT m PropertyID

-- | filter objects
filterObjects :: GraphUsableMonad m => (GraphObject ObjectID -> GraphStorageT m Bool) -> GraphStorageT m [GraphObject ObjectID]

-- | (Internal) Fill an object with its properties
populateObject :: GraphUsableMonad m => ObjectID -> Object -> GraphStorageT m (GraphObject ObjectID)

-- | Get one object from its ID.
getObject :: GraphUsableMonad m => ObjectID -> GraphStorageT m (GraphObject ObjectID)

-- | Get the type name for a given low level Object.
getTypeName :: GraphUsableMonad m => Object -> GraphStorageT m Text

-- | (Internal) Build a property map by reading the property list.
listProperties :: GraphUsableMonad m => PropertyID -> GraphStorageT m (Map Text [PropertyValue])

-- | Create a relation between two objects
createRelation :: GraphUsableMonad m => GraphRelation (Maybe RelationID) (Maybe ObjectID) -> GraphStorageT m (GraphRelation RelationID ObjectID)

-- | Create a relation between two objects
createRelation' :: GraphUsableMonad m => GraphRelation (Maybe RelationID) ObjectID -> GraphStorageT m (GraphRelation RelationID ObjectID)

-- | list relations matchinf a filter
filterRelations :: GraphUsableMonad m => (GraphRelation RelationID ObjectID -> GraphStorageT m Bool) -> GraphStorageT m [GraphRelation RelationID ObjectID]

-- | Delete a relation from the DB.
deleteRelation :: GraphUsableMonad m => RelationID -> GraphStorageT m ()

-- | (Internal) Delete a relation from the DB.
deleteRelation' :: GraphUsableMonad m => RelationID -> Bool -> Bool -> GraphStorageT m [RelationID]

-- | Delete an object
deleteObject :: GraphUsableMonad m => ObjectID -> GraphStorageT m ()

-- | (Internal) Delete all properties in the list
deleteProperties :: GraphUsableMonad m => Handles -> PropertyID -> GraphStorageT m ()

-- | (Internal) retrieve an object type id from its name (creating it if
--   need be)
objectType :: GraphUsableMonad m => Text -> GraphStorageT m ObjectTypeID

-- | (Internal) retrieve a property type id from its name and data type
--   (creating it if need be)
propertyType :: GraphUsableMonad m => (Text, DataType) -> GraphStorageT m PropertyTypeID

-- | (Internal) retrieve an relation type id from its name (creating it if
--   need be)
relationType :: GraphUsableMonad m => Text -> GraphStorageT m RelationTypeID

-- | (Internal) Fetch type helper
fetchType :: (GraphUsableMonad m, Ord k, GraphIdSerializable i v) => (Model -> Lookup i k) -> (Model -> Lookup i k -> Model) -> k -> Text -> (PropertyID -> v) -> GraphStorageT m i

-- | Add an index to be automatically managed.
addIndex :: GraphUsableMonad m => IndexInfo -> GraphStorageT m (Trie Int16 ObjectID)

-- | Add an index to be automatically managed.
addIndex' :: GraphUsableMonad m => Bool -> IndexInfo -> GraphStorageT m (Trie Int16 ObjectID)

-- | (Internal) Create an index.
createIndex :: (Binary k, Binary v, Default k, Default v, GraphUsableMonad m) => Text -> GraphStorageT m (Trie k v)

-- | Get the indices to update, per property.
indexMap :: GraphUsableMonad m => GraphObject a -> GraphStorageT m (Map Text [Trie Int16 ObjectID])

-- | Is the given index applicable to the given object type?
isIndexApplicable :: IndexInfo -> Text -> Bool
instance Typeable GraphObject
instance Typeable GraphRelation
instance MonadResource m => MonadResource (GraphStorageT m)
instance Show IndexInfo
instance Read IndexInfo
instance Eq IndexInfo
instance Ord IndexInfo
instance Functor m => Functor (GraphStorageT m)
instance (Monad m, Functor m) => Applicative (GraphStorageT m)
instance (Functor m, MonadPlus m) => Alternative (GraphStorageT m)
instance Monad m => Monad (GraphStorageT m)
instance MonadFix m => MonadFix (GraphStorageT m)
instance MonadPlus m => MonadPlus (GraphStorageT m)
instance MonadIO m => MonadIO (GraphStorageT m)
instance MonadTrans GraphStorageT
instance MonadThrow m => MonadThrow (GraphStorageT m)
instance Show a => Show (GraphObject a)
instance Read a => Read (GraphObject a)
instance Eq a => Eq (GraphObject a)
instance Ord a => Ord (GraphObject a)
instance (Show a, Show b) => Show (GraphRelation a b)
instance (Read a, Read b) => Read (GraphRelation a b)
instance (Eq a, Eq b) => Eq (GraphRelation a b)
instance (Ord a, Ord b) => Ord (GraphRelation a b)
instance MonadLogger m => MonadLogger (GraphStorageT m)
instance MonadBaseControl b m => MonadBaseControl b (GraphStorageT m)
instance MonadTransControl GraphStorageT
instance MonadBase b m => MonadBase b (GraphStorageT m)


-- | Higher level API for querying
module Database.Graph.HGraphStorage.Query

-- | Direction to follow
data RelationDir
OUT :: RelationDir
IN :: RelationDir
BOTH :: RelationDir

-- | One step in the query
data RelationStep
RelationStep :: [Text] -> RelationDir -> [Text] -> (GraphObject ObjectID -> Bool) -> Maybe Int -> RelationStep

-- | Types of relations to follow (empty -&gt; all)
rsRelTypes :: RelationStep -> [Text]

-- | Direction of relation
rsDirection :: RelationStep -> RelationDir

-- | Types of objects to retrieve (empty -&gt; all)
rsTgtTypes :: RelationStep -> [Text]

-- | Condition to match on objects
rsTgtFilter :: RelationStep -> GraphObject ObjectID -> Bool

-- | Maximum number of relations to follow (limit applies after all other
--   filters)
rsLimit :: RelationStep -> Maybe Int

-- | Default instance: navigates all out links

-- | Result of a query step
data StepResult
StepResult :: RelationID -> RelationDir -> Text -> Map Text [PropertyValue] -> GraphObject ObjectID -> StepResult

-- | Relation id
srRelationID :: StepResult -> RelationID

-- | Direction of relation
srDirection :: StepResult -> RelationDir

-- | Type of relation
srType :: StepResult -> Text

-- | Properties of relation
srProperties :: StepResult -> Map Text [PropertyValue]

-- | Target object
srObject :: StepResult -> GraphObject ObjectID

-- | Run a one step query on one given object
queryStep :: GraphUsableMonad m => ObjectID -> RelationStep -> GraphStorageT m [StepResult]
instance Typeable RelationDir
instance Typeable RelationStep
instance Typeable StepResult
instance Show RelationDir
instance Read RelationDir
instance Eq RelationDir
instance Ord RelationDir
instance Bounded RelationDir
instance Enum RelationDir
instance Show StepResult
instance Read StepResult
instance Eq StepResult
instance Ord StepResult
instance Default RelationStep
