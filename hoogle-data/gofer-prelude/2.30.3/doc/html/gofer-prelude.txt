-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Gofer 2.30 standard prelude
--   
--   Functional programming environment, Version 2.30 Standard prelude for
--   use of overloaded values using type classes. Based on the Haskell
--   standard prelude version 1.2.
--   
--   <a>http://web.cecs.pdx.edu/~mpj/goferarc/</a>
@package gofer-prelude
@version 2.30.3


-- | Copyright Mark P Jones 1991-1994. Copyright Don Stewart, 2009
--   
--   Functional programming environment, Version 2.30 Standard prelude for
--   use of overloaded values using type classes. Based on the Haskell
--   standard prelude version 1.2.
module Prelude.Gofer
strict :: (t1 -> t) -> t1 -> t

-- | primitive strict primStrict :: (a -&gt; b) -&gt; a -&gt; b
const :: a -> b -> a
id :: a -> a
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
fst :: (a, b) -> a
snd :: (a, b) -> b
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c
(.) :: (b -> c) -> (a -> b) -> (a -> c)
flip :: (a -> b -> c) -> b -> a -> c
($) :: (a -> b) -> a -> b
(&&) :: Bool -> Bool -> Bool
(||) :: Bool -> Bool -> Bool
not :: Bool -> Bool
and :: [Bool] -> Bool
or :: [Bool] -> Bool
any :: (a -> Bool) -> [a] -> Bool
all :: (a -> Bool) -> [a] -> Bool
otherwise :: Bool
ord :: Char -> Int
chr :: Int -> Char
isAscii :: Char -> Bool
isControl :: Char -> Bool
isPrint :: Char -> Bool
isSpace :: Char -> Bool
isUpper :: Char -> Bool
isLower :: Char -> Bool
isAlpha :: Char -> Bool
isDigit :: Char -> Bool
isAlphanum :: Char -> Bool
minChar :: Char
maxChar :: Char
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
range :: Ix a => (a, a) -> [a]
index :: Ix a => (a, a) -> a -> Int
inRange :: Ix a => (a, a) -> a -> Bool
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]
enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a
(/) :: Num a => a -> a -> a
negate :: Num a => a -> a
fromInteger_ :: Num a => Int -> a
sin :: Float -> Float
asin :: Float -> Float
cos :: Float -> Float
acos :: Float -> Float
tan :: Float -> Float
atan :: Float -> Float
log :: Float -> Float
exp :: Float -> Float
sqrt :: Float -> Float
atan2 :: Float -> Float
truncate :: Float -> Int
pi :: Float
div :: Int -> Int -> Int
quot :: Int -> Int -> Int
rem :: Int -> Int -> Int
mod :: Int -> Int -> Int
subtract :: Num a => a -> a -> a
even :: Int -> Bool
odd :: Int -> Bool
gcd :: Int -> Int -> Int
lcm :: Int -> Int -> Int
(^) :: Num a => a -> Int -> a
abs :: (Num a, Ord a) => a -> a
signum :: (Num a, Ord a) => a -> Int
sum :: Num a => [a] -> a
product :: Num a => [a] -> a
sums :: Num a => [a] -> [a]
products :: Num a => [a] -> [a]
head :: [a] -> a
last :: [a] -> a
tail :: [a] -> [a]
init :: [a] -> [a]
(++) :: [a] -> [a] -> [a]
genericLength :: Num a => [b] -> a
length :: [a] -> Int
(!!) :: [a] -> Int -> a
iterate :: (a -> a) -> a -> [a]
repeat :: a -> [a]
cycle :: [a] -> [a]
copy :: Int -> a -> [a]
nub :: Eq a => [a] -> [a]
reverse :: [a] -> [a]
elem :: Eq a => a -> [a] -> Bool

-- | test for membership in list
notElem :: Eq a => a -> [a] -> Bool
maximum :: Ord a => [a] -> a

-- | max element in non-empty list. min element in non-empty list
minimum :: Ord a => [a] -> a
concat :: [[a]] -> [a]
transpose :: [[a]] -> [[a]]

-- | null provides a simple and efficient way of determining whether a
--   given list is empty, without using (==) and hence avoiding a
--   constraint of the form Eq [a].
null :: [a] -> Bool

-- | (\) is used to remove the first occurrence of each element in the
--   second list from the first list. It is a kind of inverse of (++) in
--   the sense that (xs ++ ys) \ xs = ys for any finite list xs of proper
--   values xs.
(\\) :: Eq a => [a] -> [a] -> [a]

-- | map f xs applies the function f to each element of the list xs
--   returning the corresponding list of results. filter p xs returns the
--   sublist of xs containing those elements which satisfy the predicate p.
map :: (a -> b) -> [a] -> [b]
filter :: (a -> Bool) -> [a] -> [a]

-- | Fold primitives: The foldl and scanl functions, variants foldl1 and
--   scanl1 for non-empty lists, and strict variants foldl' scanl' describe
--   common patterns of recursion over lists. Informally:
--   
--   <pre>
--   foldl f a [x1, x2, ..., xn]  = f (...(f (f a x1) x2)...) xn
--                                = (...((a `f` x1) `f` x2)...) `f` xn
--   </pre>
--   
--   etc...
--   
--   The functions foldr, scanr and variants foldr1, scanr1 are duals of
--   these functions:
--   
--   <pre>
--   foldr f a xs = foldl (flip f) a (reverse xs)  for finite lists xs.
--   </pre>
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl1 :: (a -> a -> a) -> [a] -> a
foldl' :: (a -> b -> a) -> a -> [b] -> a
scanl :: (a -> b -> a) -> a -> [b] -> [a]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanl' :: (a -> b -> a) -> a -> [b] -> [a]
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr1 :: (a -> a -> a) -> [a] -> a
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | List breaking functions:
--   
--   take n xs returns the first n elements of xs drop n xs returns the
--   remaining elements of xs splitAt n xs = (take n xs, drop n xs)
--   
--   takeWhile p xs returns the longest initial segment of xs whose
--   elements satisfy p dropWhile p xs returns the remaining portion of the
--   list span p xs = (takeWhile p xs, dropWhile p xs)
--   
--   takeUntil p xs returns the list of elements upto and including the
--   first element of xs which satisfies p
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
takeWhile :: (a -> Bool) -> [a] -> [a]
takeUntil :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
span :: (a -> Bool) -> [a] -> ([a], [a])
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | Text processing: lines s returns the list of lines in the string s.
--   words s returns the list of words in the string s. unlines ls joins
--   the list of lines ls into a single string with lines separated by
--   newline characters. unwords ws joins the list of words ws into a
--   single string with words separated by spaces.
lines :: String -> [String]
words :: String -> [String]
unlines :: [String] -> String
unwords :: [String] -> String
merge :: Ord a => [a] -> [a] -> [a]
sort :: Ord a => [a] -> [a]
insert :: Ord a => a -> [a] -> [a]
qsort :: Ord a => [a] -> [a]
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
unzip :: [(a, b)] -> ([a], [b])
cjustify :: Int -> String -> String
ljustify :: Int -> String -> String
rjustify :: Int -> String -> String
space :: Int -> String
layn :: [String] -> String
until :: (a -> Bool) -> (a -> a) -> a -> a
until' :: (a -> Bool) -> (a -> a) -> a -> [a]
error :: [Char] -> a
undefined :: a
asTypeOf :: a -> a -> a
type ShowS = String -> String
showsPrec :: Text a => Int -> a -> ShowS
showList :: Text a => [a] -> ShowS
shows :: Text a => a -> ShowS
show :: Text a => a -> String
showChar :: Char -> ShowS
showString :: String -> ShowS
stdin :: [Char]
stdout :: [Char]
stderr :: [Char]
stdecho :: [Char]

-- | The Dialogue, Request, Response and IOError datatypes are now builtin:
data Request
ReadFile :: String -> Request
WriteFile :: String -> String -> Request
AppendFile :: String -> String -> Request
ReadChan :: String -> Request
AppendChan :: String -> String -> Request
Echo :: Bool -> Request
GetArgs :: Request
GetProgName :: Request
GetEnv :: String -> Request
data Response
Success :: Response
Str :: String -> Response
Failure :: IOError -> Response
StrList :: [String] -> Response
data IOError
WriteError :: String -> IOError
ReadError :: String -> IOError
SearchError :: String -> IOError
FormatError :: String -> IOError
OtherError :: String -> IOError
type Dialogue = [Response] -> [Request]
type SuccCont = Dialogue
type StrCont = String -> Dialogue
type StrListCont = [String] -> Dialogue
type FailCont = IOError -> Dialogue
done :: Dialogue
readFile :: String -> FailCont -> StrCont -> Dialogue
writeFile :: String -> String -> FailCont -> SuccCont -> Dialogue
appendFile :: String -> String -> FailCont -> SuccCont -> Dialogue
readChan :: String -> FailCont -> StrCont -> Dialogue
appendChan :: String -> String -> FailCont -> SuccCont -> Dialogue
echo :: Bool -> FailCont -> SuccCont -> Dialogue
getArgs :: FailCont -> StrListCont -> Dialogue
getProgName :: FailCont -> StrCont -> Dialogue
getEnv :: String -> FailCont -> StrCont -> Dialogue
strDispatch :: (IOError -> [Response] -> t) -> (String -> [Response] -> t) -> [Response] -> t
succDispatch :: (IOError -> [Response] -> t) -> ([Response] -> t) -> [Response] -> t
strListDispatch :: (IOError -> [Response] -> t) -> ([String] -> [Response] -> t) -> [Response] -> t
abort :: FailCont
exit :: FailCont
print :: Text a => a -> Dialogue
prints :: Text a => a -> String -> Dialogue
interact :: (String -> String) -> Dialogue
run :: (String -> String) -> Dialogue
openfile :: String -> String
help :: [Char]
instance (Text a, Text b) => Text (a, b)
instance Text a => Text [a]
instance Text Char
instance Text Float
instance Text Int
instance Text Bool
instance Text ()
instance Ord Bool
instance Eq Bool
instance (Ord a, Ord b) => Ord (a, b)
instance (Eq a, Eq b) => Eq (a, b)
instance Ord a => Ord [a]
instance Eq a => Eq [a]
instance Enum Char
instance Ix Char
instance Ord Char
instance Eq Char
instance Num Float
instance Enum Float
instance Ord Float
instance Eq Float
instance Num Int
instance Enum Int
instance Ix Int
instance Ord Int
instance Eq Int
instance Ord ()
instance Eq ()
