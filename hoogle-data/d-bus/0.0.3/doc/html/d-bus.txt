-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Permissively licensed D-Bus client library
--   
@package d-bus
@version 0.0.3

module DBus.Error
data DBusError
CouldNotConnect :: String -> DBusError
DBusParseError :: String -> DBusError
MarshalError :: String -> DBusError
instance Typeable DBusError
instance Show DBusError
instance Eq DBusError
instance Exception DBusError

module DBus.Auth
type Mechanism = ByteString
type InitialResponse = ByteString
data ServerMessage
SMRejected :: [ByteString] -> ServerMessage
SMOK :: ByteString -> ServerMessage
SMError :: ByteString -> ServerMessage
SMAgreeUnixFD :: ServerMessage
SMData :: ByteString -> ServerMessage
space :: IsString a => Parser ByteString a -> Parser ByteString a
parseHexString :: Parser ByteString
parseHexChar :: Parser Word8
encodeHexString :: ByteString -> Builder
parseLine :: ByteString -> (t -> a) -> Parser t -> Parser a
parseWords :: Parser [ByteString]
parseWord :: Parser ByteString
restOfLine :: Parser ByteString
parseServerLine :: Parser ServerMessage
data ClientMessage
CMAuth :: Mechanism -> InitialResponse -> ClientMessage
CMCancel :: ClientMessage
CMBegin :: ClientMessage
CMData :: ByteString -> ClientMessage
CMError :: ByteString -> ClientMessage
CMNegotiateUnixFD :: ClientMessage
serializeLine :: ByteString -> Builder -> Builder
serializeCMessage :: ClientMessage -> Builder
data SASLF a
Send :: ClientMessage -> a -> SASLF a
Recv :: (ServerMessage -> a) -> SASLF a
newtype SASL a
SASL :: ErrorT String (Free SASLF) a -> SASL a
unSASL :: SASL a -> ErrorT String (Free SASLF) a
saslSend :: ClientMessage -> SASL ()
saslRecv :: SASL ServerMessage
expectData :: SASL ByteString
expectOK :: SASL ByteString
runSasl :: Monad m => (Builder -> m a) -> m ByteString -> SASL b -> m (Either String b)
sasl :: SASL ServerMessage
external :: SASL ByteString
instance Show ServerMessage
instance Show ClientMessage
instance Functor SASLF
instance Functor SASL
instance Applicative SASL
instance Monad SASL
instance MonadError String SASL

module DBus.Transport
data UDS
UDSPath :: ByteString -> UDS
UDSTmpDir :: ByteString -> UDS
UDSAbstract :: ByteString -> UDS
data TCPFamily
TCPFamilyIPv4 :: TCPFamily
TCPFamilyIPv6 :: TCPFamily
data TCP
TCP :: Maybe ByteString -> Maybe ByteString -> Maybe Word16 -> Maybe TCPFamily -> TCP
tcpHost :: TCP -> Maybe ByteString
tcpBind :: TCP -> Maybe ByteString
tcpPort :: TCP -> Maybe Word16
tcpFamily :: TCP -> Maybe TCPFamily
data TransportType
TransportTCP :: TCP -> TransportType
TransportUnix :: UDS -> TransportType
OtherTransport :: ByteString -> [(ByteString, ByteString)] -> TransportType
type GUID = ByteString
withProtocol :: Parser t -> ((t, [(ByteString, ByteString)]) -> Parser a) -> Parser (Maybe (Maybe ByteString, a))
parsePair :: Parser (ByteString, ByteString)
parseUnix :: Parser (Maybe (Maybe ByteString, TransportType))
parseTCP :: Parser (Maybe (Maybe GUID, TransportType))
parseOtherTransport :: Parser (Maybe (Maybe GUID, TransportType))
parseMaybe :: MonadPlus m => Maybe a -> m a
parseTransport :: Parser (Maybe GUID, TransportType)
parseTransports :: Parser [(Maybe GUID, TransportType)]
connectTcp :: TCP -> IO Socket
connectUnix :: UDS -> IO Socket
connectTransport :: TransportType -> IO Socket
connectString :: String -> IO (Maybe Socket)
instance Show UDS
instance Eq UDS
instance Show TCPFamily
instance Eq TCPFamily
instance Show TCP
instance Eq TCP
instance Eq TransportType
instance Show TransportType

module DBus.Types
data ObjectPath
ObjectPath :: Bool -> [Text] -> ObjectPath
opAbsolute :: ObjectPath -> Bool
opParts :: ObjectPath -> [Text]
newtype Signature
Signature :: [DBusType] -> Signature
fromSignature :: Signature -> [DBusType]

-- | Parse an object path. Contrary to the standard, empty path parts are
--   ignored
objectPath :: Text -> ObjectPath
objectPathToText :: ObjectPath -> Text
stripObjectPrefix :: ObjectPath -> ObjectPath -> Maybe ObjectPath
isPathPrefix :: ObjectPath -> ObjectPath -> Bool
isRoot :: ObjectPath -> Bool
isEmpty :: ObjectPath -> Bool
data DBusSimpleType
TypeByte :: DBusSimpleType
TypeBoolean :: DBusSimpleType
TypeInt16 :: DBusSimpleType
TypeUInt16 :: DBusSimpleType
TypeInt32 :: DBusSimpleType
TypeUInt32 :: DBusSimpleType
TypeInt64 :: DBusSimpleType
TypeUInt64 :: DBusSimpleType
TypeDouble :: DBusSimpleType
TypeUnixFD :: DBusSimpleType
TypeString :: DBusSimpleType
TypeObjectPath :: DBusSimpleType
TypeSignature :: DBusSimpleType
ppSimpleType :: DBusSimpleType -> String
data DBusType
DBusSimpleType :: DBusSimpleType -> DBusType
TypeArray :: DBusType -> DBusType
TypeStruct :: [DBusType] -> DBusType
TypeDict :: DBusSimpleType -> DBusType -> DBusType
TypeVariant :: DBusType
TypeDictEntry :: DBusSimpleType -> DBusType -> DBusType
TypeUnit :: DBusType
ppType :: DBusType -> String
data Parity
Null :: Parity
Arg :: Parity -> Parity
data MethodDescription parity
(:->) :: Text -> MethodDescription n -> MethodDescription (Arg n)
Result :: Text -> MethodDescription Null
type TypeByteSym0 = TypeByte
type TypeBooleanSym0 = TypeBoolean
type TypeInt16Sym0 = TypeInt16
type TypeUInt16Sym0 = TypeUInt16
type TypeInt32Sym0 = TypeInt32
type TypeUInt32Sym0 = TypeUInt32
type TypeInt64Sym0 = TypeInt64
type TypeUInt64Sym0 = TypeUInt64
type TypeDoubleSym0 = TypeDouble
type TypeUnixFDSym0 = TypeUnixFD
type TypeStringSym0 = TypeString
type TypeObjectPathSym0 = TypeObjectPath
type TypeSignatureSym0 = TypeSignature
type SDBusSimpleType (z_anp0 :: DBusSimpleType) = Sing z_anp0
type DBusSimpleTypeSym1 (t_anp1 :: DBusSimpleType) = DBusSimpleType t_anp1
data DBusSimpleTypeSym0 (l_anp2 :: TyFun DBusSimpleType DBusType)
DBusSimpleTypeSym0KindInference :: DBusSimpleTypeSym0
type TypeArraySym1 (t_anp4 :: DBusType) = TypeArray t_anp4
data TypeArraySym0 (l_anp5 :: TyFun DBusType DBusType)
TypeArraySym0KindInference :: TypeArraySym0
type TypeStructSym1 (t_anp7 :: [] DBusType) = TypeStruct t_anp7
data TypeStructSym0 (l_anp8 :: TyFun ([] DBusType) DBusType)
TypeStructSym0KindInference :: TypeStructSym0
type TypeDictSym2 (t_anpa :: DBusSimpleType) (t_anpb :: DBusType) = TypeDict t_anpa t_anpb
data TypeDictSym1 (l_anpf :: DBusSimpleType) (l_anpe :: TyFun DBusType DBusType)
TypeDictSym1KindInference :: TypeDictSym1
data TypeDictSym0 (l_anpc :: TyFun DBusSimpleType (TyFun DBusType DBusType -> *))
TypeDictSym0KindInference :: TypeDictSym0
type TypeVariantSym0 = TypeVariant
type TypeDictEntrySym2 (t_anph :: DBusSimpleType) (t_anpi :: DBusType) = TypeDictEntry t_anph t_anpi
data TypeDictEntrySym1 (l_anpm :: DBusSimpleType) (l_anpl :: TyFun DBusType DBusType)
TypeDictEntrySym1KindInference :: TypeDictEntrySym1
data TypeDictEntrySym0 (l_anpj :: TyFun DBusSimpleType (TyFun DBusType DBusType -> *))
TypeDictEntrySym0KindInference :: TypeDictEntrySym0
type TypeUnitSym0 = TypeUnit
type SDBusType (z_anpo :: DBusType) = Sing z_anpo
type NullSym0 = Null
type ArgSym1 (t_anpR :: Parity) = Arg t_anpR
data ArgSym0 (l_anpS :: TyFun Parity Parity)
ArgSym0KindInference :: ArgSym0
type SParity (z_anpU :: Parity) = Sing z_anpU
data DBusStruct :: [DBusType] -> *
StructSingleton :: DBusValue a -> DBusStruct '[a]
StructCons :: DBusValue a -> DBusStruct as -> DBusStruct (a : as)
data SomeDBusStruct
SDBS :: DBusStruct ts -> SomeDBusStruct
showStruct :: Sing a -> DBusStruct a -> String
data DBusValue :: DBusType -> *
DBVByte :: Word8 -> DBusValue (DBusSimpleType TypeByte)
DBVBool :: Bool -> DBusValue (DBusSimpleType TypeBoolean)
DBVInt16 :: Int16 -> DBusValue (DBusSimpleType TypeInt16)
DBVUInt16 :: Word16 -> DBusValue (DBusSimpleType TypeUInt16)
DBVInt32 :: Int32 -> DBusValue (DBusSimpleType TypeInt32)
DBVUInt32 :: Word32 -> DBusValue (DBusSimpleType TypeUInt32)
DBVInt64 :: Int64 -> DBusValue (DBusSimpleType TypeInt64)
DBVUInt64 :: Word64 -> DBusValue (DBusSimpleType TypeUInt64)
DBVDouble :: Double -> DBusValue (DBusSimpleType TypeDouble)
DBVUnixFD :: Word32 -> DBusValue (DBusSimpleType TypeUnixFD)
DBVString :: Text -> DBusValue (DBusSimpleType TypeString)
DBVObjectPath :: ObjectPath -> DBusValue (DBusSimpleType TypeObjectPath)
DBVSignature :: [DBusType] -> DBusValue (DBusSimpleType TypeSignature)
DBVVariant :: DBusValue t -> DBusValue TypeVariant
DBVArray :: [DBusValue a] -> DBusValue (TypeArray a)
DBVByteArray :: ByteString -> DBusValue (TypeArray (DBusSimpleType TypeByte))
DBVStruct :: DBusStruct ts -> DBusValue (TypeStruct ts)
DBVDict :: [(DBusValue (DBusSimpleType k), DBusValue v)] -> DBusValue (TypeDict k v)
DBVUnit :: DBusValue TypeUnit
castDBV :: (SingI s, SingI t) => DBusValue s -> Maybe (DBusValue t)
data SomeDBusValue
DBV :: DBusValue t -> SomeDBusValue
dbusValue :: SingI t => SomeDBusValue -> Maybe (DBusValue t)
dbusSValue :: SingI t => SomeDBusValue -> Maybe (DBusValue (DBusSimpleType t))

-- | Extract a DBusValue from a Variant iff the type matches or return
--   nothing
fromVariant :: SingI t => DBusValue TypeVariant -> Maybe (DBusValue t)
typeOf :: SingI t => DBusValue t -> DBusType
class Representable a where type family RepType a :: DBusType
toRep :: Representable a => a -> DBusValue (RepType a)
fromRep :: Representable a => DBusValue (RepType a) -> Maybe a
data MethodWrapper av rv
MReturn :: IO (DBusValue t) -> MethodWrapper [] t
MAsk :: (DBusValue t -> MethodWrapper avs rv) -> MethodWrapper (t : avs) rv
data Method
Method :: MethodWrapper avs t -> Text -> MethodDescription (ArgParity avs) -> Method
data Annotation
Annotation :: Text -> Text -> Annotation
annotationName :: Annotation -> Text
annotationValue :: Annotation -> Text
data Interface
Interface :: Text -> [Method] -> [Annotation] -> Interface
interfaceName :: Interface -> Text
interfaceMethods :: Interface -> [Method]
interfaceAnnotations :: Interface -> [Annotation]
data Object
Object :: ObjectPath -> [Interface] -> [Object] -> Object
objectObjectPath :: Object -> ObjectPath
objectInterfaces :: Object -> [Interface]
objectSubObjects :: Object -> [Object]
data MsgError
MsgError :: Text -> Maybe Text -> [SomeDBusValue] -> MsgError
errorName :: MsgError -> Text
errorText :: MsgError -> Maybe Text
errorBody :: MsgError -> [SomeDBusValue]
data Connection
Connection :: () -> TVar (Map Word32 (TMVar (Either MsgError SomeDBusValue))) -> ThreadId -> Connection
primConnection :: Connection -> ()
answerSlots :: Connection -> TVar (Map Word32 (TMVar (Either MsgError SomeDBusValue)))
mainLoop :: Connection -> ThreadId
data MethodError
MethodErrorMessage :: [SomeDBusValue] -> MethodError
MethodSignatureMissmatch :: SomeDBusValue -> MethodError
type Serial = Word32
type Slot = Either [SomeDBusValue] SomeDBusValue -> STM ()
type AnswerSlots = Map Serial Slot
data DBusConnection
DBusConnection :: STM Serial -> TVar AnswerSlots -> TMVar (Builder -> IO ()) -> Text -> TVar Bool -> DBusConnection
dBusCreateSerial :: DBusConnection -> STM Serial
dBusAnswerSlots :: DBusConnection -> TVar AnswerSlots
dBusWriteLock :: DBusConnection -> TMVar (Builder -> IO ())
dBusConnectionName :: DBusConnection -> Text
connectionAliveRef :: DBusConnection -> TVar Bool
instance Typeable Annotation
instance Typeable MsgError
instance Typeable MethodError
instance Eq Annotation
instance Show Annotation
instance Data Annotation
instance Show MsgError
instance Show MethodError
instance Exception MethodError
instance Error MsgError
instance Exception MsgError
instance Eq Interface
instance SingI t => Show (DBusValue t)
instance Show SomeDBusValue
instance Eq (DBusValue t)
instance SingI a => Show (DBusStruct a)
instance Eq (DBusStruct t)
instance PEq 'KProxy
instance SEq 'KProxy
instance PEq 'KProxy
instance SEq 'KProxy
instance PEq 'KProxy
instance SEq 'KProxy
instance SingI n0 => SingI ('Arg n0)
instance SingI 'Null
instance SingKind 'KProxy
instance SuppressUnusedWarnings ArgSym0
instance SingI 'TypeUnit
instance (SingI n0, SingI n1) => SingI ('TypeDictEntry n0 n1)
instance SingI 'TypeVariant
instance (SingI n0, SingI n1) => SingI ('TypeDict n0 n1)
instance SingI n0 => SingI ('TypeStruct n0)
instance SingI n0 => SingI ('TypeArray n0)
instance SingI n0 => SingI ('DBusSimpleType n0)
instance SingKind 'KProxy
instance SuppressUnusedWarnings TypeDictEntrySym0
instance SuppressUnusedWarnings TypeDictEntrySym1
instance SuppressUnusedWarnings TypeDictSym0
instance SuppressUnusedWarnings TypeDictSym1
instance SuppressUnusedWarnings TypeStructSym0
instance SuppressUnusedWarnings TypeArraySym0
instance SuppressUnusedWarnings DBusSimpleTypeSym0
instance SingI 'TypeSignature
instance SingI 'TypeObjectPath
instance SingI 'TypeString
instance SingI 'TypeUnixFD
instance SingI 'TypeDouble
instance SingI 'TypeUInt64
instance SingI 'TypeInt64
instance SingI 'TypeUInt32
instance SingI 'TypeInt32
instance SingI 'TypeUInt16
instance SingI 'TypeInt16
instance SingI 'TypeBoolean
instance SingI 'TypeByte
instance SingKind 'KProxy
instance Typeable ObjectPath
instance Typeable DBusSimpleType
instance Typeable DBusType
instance Typeable Parity
instance Eq ObjectPath
instance Data ObjectPath
instance Show DBusSimpleType
instance Read DBusSimpleType
instance Eq DBusSimpleType
instance Data DBusSimpleType
instance Show DBusType
instance Read DBusType
instance Eq DBusType
instance Data DBusType
instance Show Signature
instance Eq Signature
instance Eq Parity
instance Show Parity
instance Data Parity
instance Show ObjectPath

module DBus.TH
for :: Functor f => f a -> (a -> b) -> f b
litStruct :: [ExpQ] -> ExpQ
litStructPat :: [PatQ] -> PatQ
caseMaybes :: [(Name, Name)] -> ExpQ -> ExpQ
fromTyVarBndr :: TyVarBndr -> Type
fromConstr :: Con -> (Name, [Type])
tyVarName :: TyVarBndr -> Name
promotedListT :: [TypeQ] -> TypeQ
relevantTyVars :: [Con] -> [Name]
makeRepresentable :: Name -> Q [Dec]
makeRepresentableTuple :: Int -> Q Dec

module DBus.Representable
instance (Representable l, Representable r, SingI (RepType l), SingI (RepType r)) => Representable (Either l r)
instance (Ord k, Representable k, RepType k ~ 'DBusSimpleType r, Representable v) => Representable (Map k v)
instance Representable ByteString
instance (Representable a, SingI (RepType a)) => Representable [a]
instance Representable ObjectPath
instance Representable Text
instance Representable Double
instance Representable Word64
instance Representable Int64
instance Representable Word32
instance Representable Int32
instance Representable Word16
instance Representable Int16
instance Representable Bool
instance Representable Word8
instance Representable ()
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k, Representable l, Representable m, Representable n, Representable o, Representable p, Representable q, Representable r, Representable s, Representable t) => Representable (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k, Representable l, Representable m, Representable n, Representable o, Representable p, Representable q, Representable r, Representable s) => Representable (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k, Representable l, Representable m, Representable n, Representable o, Representable p, Representable q, Representable r) => Representable (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k, Representable l, Representable m, Representable n, Representable o, Representable p, Representable q) => Representable (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k, Representable l, Representable m, Representable n, Representable o, Representable p) => Representable (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k, Representable l, Representable m, Representable n, Representable o) => Representable (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k, Representable l, Representable m, Representable n) => Representable (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k, Representable l, Representable m) => Representable (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k, Representable l) => Representable (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j, Representable k) => Representable (a, b, c, d, e, f, g, h, i, j, k)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i, Representable j) => Representable (a, b, c, d, e, f, g, h, i, j)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h, Representable i) => Representable (a, b, c, d, e, f, g, h, i)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g, Representable h) => Representable (a, b, c, d, e, f, g, h)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f, Representable g) => Representable (a, b, c, d, e, f, g)
instance (Representable a, Representable b, Representable c, Representable d, Representable e, Representable f) => Representable (a, b, c, d, e, f)
instance (Representable a, Representable b, Representable c, Representable d, Representable e) => Representable (a, b, c, d, e)
instance (Representable a, Representable b, Representable c, Representable d) => Representable (a, b, c, d)
instance (Representable a, Representable b, Representable c) => Representable (a, b, c)
instance (Representable a, Representable b) => Representable (a, b)

module DBus.Signature
stToSignature :: DBusSimpleType -> Char
toSignature :: DBusType -> ByteString
toSignatures :: [DBusType] -> ByteString
toSignature' :: DBusType -> Builder
simpleTypeMap :: IntMap DBusSimpleType
simpleType :: Parser ByteString DBusSimpleType
dictEntrySignature :: Parser ByteString DBusType
arraySignature :: Parser ByteString DBusType
structSignature :: Parser ByteString DBusType
signature :: Parser ByteString DBusType
eitherParseSig :: ByteString -> Either Text DBusType
parseSig :: ByteString -> Maybe DBusType
eitherParseSigs :: ByteString -> Either Text [DBusType]
parseSigs :: ByteString -> Maybe [DBusType]

module DBus.Wire
fromEnum' :: (Enum a, Num c) => a -> c
toEnum' :: (Enum c, Integral a) => a -> c
alignment :: DBusType -> Int
data Endian
Little :: Endian
Big :: Endian
type DBusPut a = RWS Endian Builder Int a
endian :: (a -> Builder) -> (a -> Builder) -> a -> DBusPut ()
putSize :: MonadState Int m => Int -> m ()
alignPut :: Int -> DBusPut ()
sizeOf :: Int -> Int -> DBusPut a -> DBusPut Int
bytes :: (a -> Builder) -> (a -> Builder) -> Int -> a -> DBusPut ()
putWord8 :: Word8 -> DBusPut ()
putWord16 :: Word16 -> DBusPut ()
putWord32 :: Word32 -> DBusPut ()
putWord64 :: Word64 -> DBusPut ()
putInt8 :: Int8 -> DBusPut ()
putInt16 :: Int16 -> DBusPut ()
putInt32 :: Int32 -> DBusPut ()
putInt64 :: Int64 -> DBusPut ()
putDouble :: Double -> DBusPut ()
putByteString :: ByteString -> DBusPut ()
putText :: Text -> DBusPut ()
putObjectPath :: ObjectPath -> DBusPut ()
putSignatures :: [DBusType] -> RWST Endian Builder Int Identity ()
putDBV :: SingI DBusType t => DBusValue t -> DBusPut ()
putDBV' :: Sing t -> DBusValue t -> DBusPut ()
putStruct :: Sing a -> DBusStruct a -> DBusPut ()
runDBusPut :: Num s => r -> RWS r b s a -> b
putValues :: [SomeDBusValue] -> DBusPut ()
type DBusGet a = ReaderT Endian Get a
getEndian :: Get a -> Get a -> DBusGet a
alignGet :: Int -> DBusGet ()
getting :: Get a -> Get a -> Int -> DBusGet a
getWord8 :: DBusGet Word8
getWord16 :: DBusGet Word16
getWord32 :: DBusGet Word32
getWord64 :: DBusGet Word64
getInt16 :: DBusGet Int16
getInt32 :: DBusGet Int32
getInt64 :: DBusGet Int64
getDouble :: DBusGet Double
getText :: DBusGet Text
getBool :: DBusGet Bool
getSignatures :: ReaderT Endian Get [DBusType]
getByteString :: MonadTrans t => Int -> t Get ByteString
getDBV :: SingI t => DBusGet (DBusValue t)
getDBVByType :: DBusType -> DBusGet SomeDBusValue
getDBV' :: Sing t -> DBusGet (DBusValue t)
getStruct :: Sing ts -> DBusGet (DBusStruct ts)
getMany :: Int64 -> Sing t -> DBusGet [DBusValue t]
getManyPairs :: Int64 -> Sing kt -> Sing vt -> DBusGet [(DBusValue kt, DBusValue vt)]
sinkGet :: MonadThrow m => Get b -> ConduitM ByteString o m b
instance Show Endian
instance Eq Endian
instance Enum Endian
instance Bounded Endian

module DBus.Message
data MessageType
Invalid :: MessageType
MethodCall :: MessageType
MethodReturn :: MessageType
Error :: MessageType
Signal :: MessageType
Other :: Word8 -> MessageType
data Flag
NoReplyExpected :: Flag
NoAutoStart :: Flag
newtype Flags
Flags :: [Flag] -> Flags
fromFlags :: (Bits a, Ord a, Num a) => a -> [Flag]
data HeaderFields
HeaderFields :: Maybe ObjectPath -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Word32 -> Maybe Text -> Maybe Text -> Maybe Signature -> Maybe Word32 -> HeaderFields
hFPath :: HeaderFields -> Maybe ObjectPath
hFInterface :: HeaderFields -> Maybe Text
hFMember :: HeaderFields -> Maybe Text
hFErrorName :: HeaderFields -> Maybe Text
hFReplySerial :: HeaderFields -> Maybe Word32
hFDestination :: HeaderFields -> Maybe Text
hFSender :: HeaderFields -> Maybe Text
hFMessageSignature :: HeaderFields -> Maybe Signature
hFUnixfds :: HeaderFields -> Maybe Word32
emptyHeaderFields :: HeaderFields
toFields :: HeaderFields -> [HeaderField]
fromFields :: [HeaderField] -> HeaderFields
data HeaderField
HeaderFieldInvalid :: HeaderField
HeaderFieldPath :: ObjectPath -> HeaderField
HeaderFieldInterface :: Text -> HeaderField
HeaderFieldMember :: Text -> HeaderField
HeaderFieldErrorName :: Text -> HeaderField
HeaderFieldReplySerial :: Word32 -> HeaderField
HeaderFieldDestination :: Text -> HeaderField
HeaderFieldSender :: Text -> HeaderField
HeaderFieldMessageSignature :: Signature -> HeaderField
HeaderFieldUnixFDs :: Word32 -> HeaderField
data MessageHeader
MessageHeader :: Endian -> MessageType -> Flags -> Word8 -> Word32 -> Word32 -> HeaderFields -> MessageHeader
endianessFlag :: MessageHeader -> Endian
messageType :: MessageHeader -> MessageType
flags :: MessageHeader -> Flags
version :: MessageHeader -> Word8
messageLength :: MessageHeader -> Word32
serial :: MessageHeader -> Word32
fields :: MessageHeader -> HeaderFields
methodCall :: Word32 -> Text -> ObjectPath -> Text -> Text -> [SomeDBusValue] -> [Flag] -> Builder
methodReturn :: Word32 -> Word32 -> Text -> [SomeDBusValue] -> Builder
errorMessage :: Word32 -> Maybe Word32 -> Text -> Text -> Maybe Text -> [SomeDBusValue] -> Builder
serializeMessage :: MessageHeader -> [SomeDBusValue] -> Builder
getMessage :: Get (MessageHeader, [SomeDBusValue])
parseMessages :: MonadThrow m => ConduitM ByteString (MessageHeader, [SomeDBusValue]) m b
sendBS :: DBusConnection -> Builder -> IO ()

-- | Asychronously call a method. Returns an STM action that waits for the
--   returned value.
callMethod :: Text -> ObjectPath -> Text -> Text -> [SomeDBusValue] -> [Flag] -> DBusConnection -> IO (STM (Either [SomeDBusValue] SomeDBusValue))

-- | Wait for the answer of a method call
getAnswer :: IO (STM b) -> IO b

-- | Synchronously call a method. Returned errors are thrown as
--   <a>MethodError</a>s. If the returned value's type doesn't match the
--   expected type a <a>MethodSignatureMissmatch</a> is thrown.
callMethod' :: (SingI (RepType a), Representable a, MonadThrow m, MonadIO m) => Text -> ObjectPath -> Text -> Text -> [SomeDBusValue] -> [Flag] -> DBusConnection -> m a
instance Representable MessageHeader
instance Show MessageHeader
instance Eq MessageHeader
instance Representable Endian
instance Representable HeaderField
instance Eq MessageType
instance Show MessageType
instance Eq Flag
instance Show Flag
instance Show Flags
instance Eq Flags
instance Show HeaderFields
instance Eq HeaderFields
instance Show HeaderField
instance Eq HeaderField
instance Representable HeaderFields
instance Representable Signature
instance Representable Flags
instance Representable MessageType

module DBus.Object
class IsMethod f where type family ArgTypes f :: [DBusType] type family ResultType f :: DBusType
toMethod :: IsMethod f => f -> MethodWrapper (ArgTypes f) (ResultType f)
class RepMethod f where type family RepMethodArgs f :: [DBusType] type family RepMethodValue f :: DBusType
repMethod :: RepMethod f => f -> MethodWrapper (RepMethodArgs f) (RepMethodValue f)
runMethodW :: SingI at => MethodWrapper at rt -> [SomeDBusValue] -> Maybe (IO (DBusValue rt))
runMethodW' :: Sing at -> [SomeDBusValue] -> MethodWrapper at rt -> Maybe (IO (DBusValue rt))
methodWSignature :: (SingI at, SingI rt) => MethodWrapper (at :: [DBusType]) (rt :: DBusType) -> ([DBusType], Maybe DBusType)
runMethod :: Method -> [SomeDBusValue] -> Maybe (IO SomeDBusValue)
methodSignature :: Method -> ([DBusType], Maybe DBusType)
methodName :: Method -> Text
argDescriptions :: MethodDescription t -> ([Text], Text)
findObject :: ObjectPath -> Object -> Maybe Object
callAtPath :: Object -> ObjectPath -> Text -> Text -> [SomeDBusValue] -> Either MsgError (IO SomeDBusValue)
instance [overlap ok] Show Object
instance [overlap ok] Show Interface
instance [overlap ok] Show Method
instance [overlap ok] (RepMethod b, Representable a, SingI (RepType a)) => RepMethod (a -> b)
instance [overlap ok] (Representable t, SingI (RepType t)) => RepMethod (IO t)
instance [overlap ok] (IsMethod f, SingI t) => IsMethod (DBusValue t -> f)
instance [overlap ok] SingI t => IsMethod (IO (DBusValue t))

module DBus.MessageBus
messageBusMethod :: (MonadIO m, MonadThrow m, Representable a, SingI (RepType a)) => Text -> [SomeDBusValue] -> DBusConnection -> m a
hello :: (MonadIO m, MonadThrow m) => DBusConnection -> m Text
data RequestNameFlag
RequestNameFlag :: Bool -> Bool -> Bool -> RequestNameFlag
allowReplacement :: RequestNameFlag -> Bool
replaceExisting :: RequestNameFlag -> Bool
doNotQueue :: RequestNameFlag -> Bool
fromRequestNameFlags :: Num a => RequestNameFlag -> a
data RequestNameReply
PrimaryOwner :: RequestNameReply
InQueue :: RequestNameReply
Exists :: RequestNameReply
AlreadyOwner :: RequestNameReply
requestName :: (MonadIO m, MonadThrow m) => Text -> RequestNameFlag -> DBusConnection -> m RequestNameReply
data ReleaseNameReply
Released :: ReleaseNameReply
NonExistent :: ReleaseNameReply
NotOwner :: ReleaseNameReply
releaseName :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m ReleaseNameReply
listQueuedOwners :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m [Text]
listNames :: (MonadIO m, MonadThrow m) => DBusConnection -> m [Text]
listActivatableNames :: (MonadIO m, MonadThrow m) => DBusConnection -> m [Text]
nameHasOwner :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m Bool
data StartServiceResult
StartServiceSuccess :: StartServiceResult
StartServiceAlreadyRunning :: StartServiceResult
startServiceByName :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m StartServiceResult
getNameOwner :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m Text
getConnectionUnixUser :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m Word32
getConnectionProcessID :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m Word32
getID :: (MonadIO m, MonadThrow m) => DBusConnection -> m Text
instance Show StartServiceResult
instance Read StartServiceResult
instance Eq StartServiceResult
instance Default RequestNameFlag

module DBus.Signal
data MatchRule
MatchRule :: Maybe MessageType -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe (Bool, ObjectPath) -> Maybe Text -> [(Int, Text)] -> [(Int, Text)] -> Maybe Text -> Maybe Bool -> MatchRule
mrType :: MatchRule -> Maybe MessageType
mrSender :: MatchRule -> Maybe Text
mrInterface :: MatchRule -> Maybe Text
mrMember :: MatchRule -> Maybe Text
mrPath :: MatchRule -> Maybe (Bool, ObjectPath)
mrDestination :: MatchRule -> Maybe Text
mrArgs :: MatchRule -> [(Int, Text)]
mrArgPaths :: MatchRule -> [(Int, Text)]
mrArg0namespace :: MatchRule -> Maybe Text
mrEavesdrop :: MatchRule -> Maybe Bool
matchAll :: MatchRule
renderRule :: MatchRule -> Text

-- | Match a Signal against a rule. The argN, argNPath and arg0namespace
--   parameter are ignored at the moment
matchSignal :: MessageHeader -> MatchRule -> Bool
addMatch :: (MonadIO m, MonadThrow m) => MatchRule -> DBusConnection -> m ()
removeMatch :: (MonadIO m, MonadThrow m) => MatchRule -> DBusConnection -> m ()

module DBus.MainLoop
handleMessage :: (MessageHeader -> [SomeDBusValue] -> IO ()) -> (MessageHeader -> [SomeDBusValue] -> IO ()) -> TVar (Map Word32 (Either [SomeDBusValue] SomeDBusValue -> STM ())) -> (MessageHeader, [SomeDBusValue]) -> IO ()

-- | Create a message handler that dispatches matches to the methods in a
--   root object
objectRoot :: Object -> Handler

-- | Check whether connection is alive
checkAlive :: DBusConnection -> IO Bool

-- | Wait until connection is closed
waitFor :: DBusConnection -> IO ()

-- | Which Bus to connect to
data ConnectionType

-- | The well-known system bus. First the environmental variable
--   DBUS_SYSTEM_BUS_ADDRESS is checked and if it doesn't exist the address
--   <i>unix:path=/var/run/dbus/system_bus_socket</i> is used
System :: ConnectionType

-- | The well-known session bus. Refers to the address stored in the
--   environmental variable DBUS_SESSION_BUS_ADDRESS
Session :: ConnectionType

-- | The bus at the give addresss
Address :: String -> ConnectionType
type MethodCallHandler = DBusConnection -> MessageHeader -> [SomeDBusValue] -> IO ()
type SignalHandler = DBusConnection -> MessageHeader -> [SomeDBusValue] -> IO ()

-- | Create a new connection to a message bus
connectBus :: ConnectionType -> MethodCallHandler -> SignalHandler -> IO DBusConnection
type Handler = DBusConnection -> MessageHeader -> [SomeDBusValue] -> IO ()
sendCredentials :: Socket -> IO Int

module DBus.Introspect
data IDirection
In :: IDirection
Out :: IDirection
directionFromText :: Text -> Either Text IDirection
directionToText :: IDirection -> Text
data IPropertyAccess
Read :: IPropertyAccess
Write :: IPropertyAccess
ReadWrite :: IPropertyAccess
propertyAccessFromText :: Text -> Either Text IPropertyAccess
propertyAccessToText :: IPropertyAccess -> Text
data IArgument
IArgument :: Text -> DBusType -> Maybe IDirection -> IArgument
iArgumentName :: IArgument -> Text
iArgumentType :: IArgument -> DBusType
iArgumentDirection :: IArgument -> Maybe IDirection
data IMethod
IMethod :: Text -> [IArgument] -> [Annotation] -> IMethod
iMethodName :: IMethod -> Text
iMethodArguments :: IMethod -> [IArgument]
iMethodAnnotations :: IMethod -> [Annotation]
data ISignal
ISignal :: Text -> [IArgument] -> [Annotation] -> ISignal
iSignalName :: ISignal -> Text
iSignalArguments :: ISignal -> [IArgument]
iSignalAnnotations :: ISignal -> [Annotation]
data IProperty
IProperty :: Text -> DBusType -> IPropertyAccess -> [Annotation] -> IProperty
iPropertyName :: IProperty -> Text
iPropertType :: IProperty -> DBusType
iPropertyAccess :: IProperty -> IPropertyAccess
iPropertyAnnotation :: IProperty -> [Annotation]
data IInterface
IInterface :: Text -> [IMethod] -> [ISignal] -> [IProperty] -> [Annotation] -> IInterface
iInterfaceName :: IInterface -> Text
iInterfaceMethods :: IInterface -> [IMethod]
iInterfaceSignals :: IInterface -> [ISignal]
iInterfaceProperties :: IInterface -> [IProperty]
iInterfaceAnnotations :: IInterface -> [Annotation]
data INode
INode :: Text -> [IInterface] -> [INode] -> INode
nodeName :: INode -> Text
nodeInterfaces :: INode -> [IInterface]
nodeSubnodes :: INode -> [INode]
xpAnnotation :: PU [Node] Annotation
xpSignature :: PU Text DBusType
xpDirection :: PU Text IDirection
xpPropertyAccess :: PU Text IPropertyAccess
xpArgument :: PU [Node] IArgument
xpMethod :: PU [Node] IMethod
xpSignal :: PU [Node] ISignal
xpProperty :: PU [Node] IProperty
xpInterface :: PU [Node] IInterface
xpNode :: PU [Node] INode
xmlToNode :: ByteString -> Either Text INode
pubID :: ExternalID
prologue :: Prologue
nodeToXml :: INode -> ByteString
introspectMethods :: [Method] -> [IMethod]
introspectInterface :: Interface -> IInterface
introspectObject :: Object -> INode
introspect :: Object -> IO Text
introspectMethod :: Object -> Method
introspectable :: Object -> Interface
addIntrospectable :: Object -> Object
instance Typeable IDirection
instance Typeable IPropertyAccess
instance Typeable IArgument
instance Typeable IMethod
instance Typeable ISignal
instance Typeable IProperty
instance Typeable IInterface
instance Typeable INode
instance Eq IDirection
instance Show IDirection
instance Data IDirection
instance Eq IPropertyAccess
instance Show IPropertyAccess
instance Data IPropertyAccess
instance Eq IArgument
instance Show IArgument
instance Data IArgument
instance Eq IMethod
instance Show IMethod
instance Data IMethod
instance Eq ISignal
instance Show ISignal
instance Data ISignal
instance Eq IProperty
instance Show IProperty
instance Data IProperty
instance Eq IInterface
instance Show IInterface
instance Data IInterface
instance Eq INode
instance Show INode
instance Data INode

module DBus

-- | Which Bus to connect to
data ConnectionType

-- | The well-known system bus. First the environmental variable
--   DBUS_SYSTEM_BUS_ADDRESS is checked and if it doesn't exist the address
--   <i>unix:path=/var/run/dbus/system_bus_socket</i> is used
System :: ConnectionType

-- | The well-known session bus. Refers to the address stored in the
--   environmental variable DBUS_SESSION_BUS_ADDRESS
Session :: ConnectionType

-- | The bus at the give addresss
Address :: String -> ConnectionType

-- | Create a new connection to a message bus
connectBus :: ConnectionType -> MethodCallHandler -> SignalHandler -> IO DBusConnection
type MethodCallHandler = DBusConnection -> MessageHeader -> [SomeDBusValue] -> IO ()
type SignalHandler = DBusConnection -> MessageHeader -> [SomeDBusValue] -> IO ()

-- | Check whether connection is alive
checkAlive :: DBusConnection -> IO Bool

-- | Wait until connection is closed
waitFor :: DBusConnection -> IO ()

-- | Create a message handler that dispatches matches to the methods in a
--   root object
objectRoot :: Object -> Handler
data MatchRule
MatchRule :: Maybe MessageType -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe (Bool, ObjectPath) -> Maybe Text -> [(Int, Text)] -> [(Int, Text)] -> Maybe Text -> Maybe Bool -> MatchRule
mrType :: MatchRule -> Maybe MessageType
mrSender :: MatchRule -> Maybe Text
mrInterface :: MatchRule -> Maybe Text
mrMember :: MatchRule -> Maybe Text
mrPath :: MatchRule -> Maybe (Bool, ObjectPath)
mrDestination :: MatchRule -> Maybe Text
mrArgs :: MatchRule -> [(Int, Text)]
mrArgPaths :: MatchRule -> [(Int, Text)]
mrArg0namespace :: MatchRule -> Maybe Text
mrEavesdrop :: MatchRule -> Maybe Bool
matchAll :: MatchRule

-- | Match a Signal against a rule. The argN, argNPath and arg0namespace
--   parameter are ignored at the moment
matchSignal :: MessageHeader -> MatchRule -> Bool
addMatch :: (MonadIO m, MonadThrow m) => MatchRule -> DBusConnection -> m ()
removeMatch :: (MonadIO m, MonadThrow m) => MatchRule -> DBusConnection -> m ()
class Representable a where type family RepType a :: DBusType
toRep :: Representable a => a -> DBusValue (RepType a)
fromRep :: Representable a => DBusValue (RepType a) -> Maybe a
makeRepresentable :: Name -> Q [Dec]
makeRepresentableTuple :: Int -> Q Dec
data DBusValue :: DBusType -> *
DBVByte :: Word8 -> DBusValue (DBusSimpleType TypeByte)
DBVBool :: Bool -> DBusValue (DBusSimpleType TypeBoolean)
DBVInt16 :: Int16 -> DBusValue (DBusSimpleType TypeInt16)
DBVUInt16 :: Word16 -> DBusValue (DBusSimpleType TypeUInt16)
DBVInt32 :: Int32 -> DBusValue (DBusSimpleType TypeInt32)
DBVUInt32 :: Word32 -> DBusValue (DBusSimpleType TypeUInt32)
DBVInt64 :: Int64 -> DBusValue (DBusSimpleType TypeInt64)
DBVUInt64 :: Word64 -> DBusValue (DBusSimpleType TypeUInt64)
DBVDouble :: Double -> DBusValue (DBusSimpleType TypeDouble)
DBVUnixFD :: Word32 -> DBusValue (DBusSimpleType TypeUnixFD)
DBVString :: Text -> DBusValue (DBusSimpleType TypeString)
DBVObjectPath :: ObjectPath -> DBusValue (DBusSimpleType TypeObjectPath)
DBVSignature :: [DBusType] -> DBusValue (DBusSimpleType TypeSignature)
DBVVariant :: DBusValue t -> DBusValue TypeVariant
DBVArray :: [DBusValue a] -> DBusValue (TypeArray a)
DBVByteArray :: ByteString -> DBusValue (TypeArray (DBusSimpleType TypeByte))
DBVStruct :: DBusStruct ts -> DBusValue (TypeStruct ts)
DBVDict :: [(DBusValue (DBusSimpleType k), DBusValue v)] -> DBusValue (TypeDict k v)
DBVUnit :: DBusValue TypeUnit
castDBV :: (SingI s, SingI t) => DBusValue s -> Maybe (DBusValue t)
data DBusStruct :: [DBusType] -> *
StructSingleton :: DBusValue a -> DBusStruct '[a]
StructCons :: DBusValue a -> DBusStruct as -> DBusStruct (a : as)
data SomeDBusValue
DBV :: DBusValue t -> SomeDBusValue
dbusValue :: SingI t => SomeDBusValue -> Maybe (DBusValue t)

-- | Extract a DBusValue from a Variant iff the type matches or return
--   nothing
fromVariant :: SingI t => DBusValue TypeVariant -> Maybe (DBusValue t)
data DBusSimpleType
TypeByte :: DBusSimpleType
TypeBoolean :: DBusSimpleType
TypeInt16 :: DBusSimpleType
TypeUInt16 :: DBusSimpleType
TypeInt32 :: DBusSimpleType
TypeUInt32 :: DBusSimpleType
TypeInt64 :: DBusSimpleType
TypeUInt64 :: DBusSimpleType
TypeDouble :: DBusSimpleType
TypeUnixFD :: DBusSimpleType
TypeString :: DBusSimpleType
TypeObjectPath :: DBusSimpleType
TypeSignature :: DBusSimpleType
data DBusType
DBusSimpleType :: DBusSimpleType -> DBusType
TypeArray :: DBusType -> DBusType
TypeStruct :: [DBusType] -> DBusType
TypeDict :: DBusSimpleType -> DBusType -> DBusType
TypeVariant :: DBusType
TypeDictEntry :: DBusSimpleType -> DBusType -> DBusType
TypeUnit :: DBusType
newtype Signature
Signature :: [DBusType] -> Signature
fromSignature :: Signature -> [DBusType]
typeOf :: SingI t => DBusValue t -> DBusType
data Object
Object :: ObjectPath -> [Interface] -> [Object] -> Object
objectObjectPath :: Object -> ObjectPath
objectInterfaces :: Object -> [Interface]
objectSubObjects :: Object -> [Object]
data Interface
Interface :: Text -> [Method] -> [Annotation] -> Interface
interfaceName :: Interface -> Text
interfaceMethods :: Interface -> [Method]
interfaceAnnotations :: Interface -> [Annotation]
data ObjectPath

-- | Parse an object path. Contrary to the standard, empty path parts are
--   ignored
objectPath :: Text -> ObjectPath
objectPathToText :: ObjectPath -> Text
stripObjectPrefix :: ObjectPath -> ObjectPath -> Maybe ObjectPath
isPathPrefix :: ObjectPath -> ObjectPath -> Bool
isRoot :: ObjectPath -> Bool
isEmpty :: ObjectPath -> Bool
data Method
Method :: MethodWrapper avs t -> Text -> MethodDescription (ArgParity avs) -> Method
data MethodWrapper av rv
MReturn :: IO (DBusValue t) -> MethodWrapper [] t
MAsk :: (DBusValue t -> MethodWrapper avs rv) -> MethodWrapper (t : avs) rv
data MethodDescription parity
(:->) :: Text -> MethodDescription n -> MethodDescription (Arg n)
Result :: Text -> MethodDescription Null
repMethod :: RepMethod f => f -> MethodWrapper (RepMethodArgs f) (RepMethodValue f)

-- | Asychronously call a method. Returns an STM action that waits for the
--   returned value.
callMethod :: Text -> ObjectPath -> Text -> Text -> [SomeDBusValue] -> [Flag] -> DBusConnection -> IO (STM (Either [SomeDBusValue] SomeDBusValue))

-- | Synchronously call a method. Returned errors are thrown as
--   <a>MethodError</a>s. If the returned value's type doesn't match the
--   expected type a <a>MethodSignatureMissmatch</a> is thrown.
callMethod' :: (SingI (RepType a), Representable a, MonadThrow m, MonadIO m) => Text -> ObjectPath -> Text -> Text -> [SomeDBusValue] -> [Flag] -> DBusConnection -> m a
data MsgError
MsgError :: Text -> Maybe Text -> [SomeDBusValue] -> MsgError
errorName :: MsgError -> Text
errorText :: MsgError -> Maybe Text
errorBody :: MsgError -> [SomeDBusValue]
addIntrospectable :: Object -> Object
requestName :: (MonadIO m, MonadThrow m) => Text -> RequestNameFlag -> DBusConnection -> m RequestNameReply
data RequestNameFlag
RequestNameFlag :: Bool -> Bool -> Bool -> RequestNameFlag
allowReplacement :: RequestNameFlag -> Bool
replaceExisting :: RequestNameFlag -> Bool
doNotQueue :: RequestNameFlag -> Bool
data RequestNameReply
PrimaryOwner :: RequestNameReply
InQueue :: RequestNameReply
Exists :: RequestNameReply
AlreadyOwner :: RequestNameReply
releaseName :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m ReleaseNameReply
data ReleaseNameReply
Released :: ReleaseNameReply
NonExistent :: ReleaseNameReply
NotOwner :: ReleaseNameReply
listQueuedOwners :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m [Text]
listNames :: (MonadIO m, MonadThrow m) => DBusConnection -> m [Text]
listActivatableNames :: (MonadIO m, MonadThrow m) => DBusConnection -> m [Text]
nameHasOwner :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m Bool
startServiceByName :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m StartServiceResult
getNameOwner :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m Text
getConnectionUnixUser :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m Word32
getConnectionProcessID :: (MonadIO m, MonadThrow m) => Text -> DBusConnection -> m Word32
getID :: (MonadIO m, MonadThrow m) => DBusConnection -> m Text
