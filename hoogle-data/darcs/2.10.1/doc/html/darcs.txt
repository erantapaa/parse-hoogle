-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a distributed, interactive, smart revision control system
--   
@package darcs
@version 2.10.1

module Darcs.Util.Download.Request

-- | A UrlRequest object contains a url to get, the file into which the
--   contents at the given url should be written, the cachability of this
--   request and the request's priority.
data UrlRequest
UrlRequest :: String -> FilePath -> Cachable -> Priority -> UrlRequest
url :: UrlRequest -> String
file :: UrlRequest -> FilePath
cachable :: UrlRequest -> Cachable
priority :: UrlRequest -> Priority
data Cachable
Cachable :: Cachable
Uncachable :: Cachable
MaxAge :: !CInt -> Cachable

-- | A UrlState object contains a map of url -&gt; InProgressStatus, a Q of
--   urls waiting to be started, the current pipe length and the unique
--   junk to create unique filenames.
data UrlState
UrlState :: Map String InProgressStatus -> Q String -> Int -> String -> UrlState
inProgress :: UrlState -> Map String InProgressStatus
waitToStart :: UrlState -> Q String
pipeLength :: UrlState -> Int
randomJunk :: UrlState -> String

-- | Q represents a prioritised queue, with two-tier priority. The left
--   list contains higher priority items than the right list.
data Q a
Q :: [a] -> [a] -> Q a

-- | <a>readQ</a> will try and take an element from the Q, preferring
--   elements from the high priority list.
readQ :: Q a -> Maybe (a, Q a)

-- | <a>insertQ</a> inserts a low priority item into a Q.
insertQ :: a -> Q a -> Q a

-- | <a>pushQ</a> inserts a high priority item into a Q.
pushQ :: a -> Q a -> Q a

-- | Return a function for adding an element based on the priority.
addUsingPriority :: Priority -> a -> Q a -> Q a

-- | <a>deleteQ</a> removes any instances of a given element from the Q.
deleteQ :: Eq a => a -> Q a -> Q a

-- | <a>deleteQ</a> checks for membership in a Q.
elemQ :: Eq a => a -> Q a -> Bool

-- | <a>emptyQ</a> is an empty Q.
emptyQ :: Q a

-- | <a>nullQ</a> checks if the Q contains no items.
nullQ :: Q a -> Bool
data Priority
High :: Priority
Low :: Priority

-- | Data type to represent a connection error. The following are the codes
--   from libcurl which map to each of the constructors: * 6 -&gt;
--   CouldNotResolveHost : The remote host was not resolved. * 7 -&gt;
--   CouldNotConnectToServer : Failed to connect() to host or proxy. * 28
--   -&gt; OperationTimeout: the specified time-out period was reached.
data ConnectionError
CouldNotResolveHost :: ConnectionError
CouldNotConnectToServer :: ConnectionError
OperationTimeout :: ConnectionError
instance Eq Priority
instance Show Cachable
instance Eq Cachable
instance Eq ConnectionError
instance Read ConnectionError
instance Show ConnectionError

module Darcs.UI.Options.Iso

-- | Lightweight type ismomorphisms (a.k.a. invertible functions). If
--   
--   <pre>
--   Iso fw bw :: Iso a b
--   </pre>
--   
--   then <tt>fw</tt> and <tt>bw</tt> are supposed to satisfy
--   
--   <pre>
--   fw . bw = id = bw . fw
--   </pre>
data Iso a b
Iso :: (a -> b) -> (b -> a) -> Iso a b

-- | Lift an isomorphism between <tt>a</tt> and <tt>b</tt> to one between
--   <tt>f a</tt> and <tt>f b</tt>. Like <a>Functor</a>, except we can only
--   map invertible functions (i.e. an Isomorphisms).
class IsoFunctor f
imap :: IsoFunctor f => Iso a b -> f a -> f b

-- | Apply an iso under a functor.
under :: Functor f => Iso a b -> Iso (f a) (f b)

-- | Apply an iso under cps (which is a cofunctor).
cps :: Iso a b -> Iso (a -> c) (b -> c)


-- | Option specifications using continuations with a changing answer type.
--   
--   Based on
--   
--   <pre>
--   <a>www.is.ocha.ac.jp/~asai/papers/tr08-2.pdf</a>
--   </pre>
--   
--   with additional inspiration provided by
--   
--   <pre>
--   <a>http://okmij.org/ftp/typed-formatting/FPrintScan.html#DSL-FIn</a>
--   </pre>
--   
--   which shows how the same format specifiers can be used for both
--   <tt>sprintf</tt> and <tt>sscanf</tt>.
--   
--   The <a>OptSpec</a> type corresponds to the format specifiers for the
--   sprintf and sscanf functions, which I called <a>ounparse</a> and
--   <a>oparse</a> here; they no longer work on <a>String</a>s but instead
--   on any list (the intention is, of course, that this is a list of
--   flags).
--   
--   As explained in the original paper by Kenichi Asai, we cannot use
--   <a>Cont</a>, even with the recent additions of the <tt>shift</tt> and
--   <tt>reset</tt> combinators, since <a>Cont</a> requires that the answer
--   type remains the same over the whole computation, while the trick used
--   here requires that the answer type can change.
--   
--   Besides parsing and unparsing, the <a>OptSpec</a> type contains two
--   more members: <a>odesc</a> is the list of <tt>OptDescr</tt> that
--   <a>getOpt</a> needs as input for parsing the command line and for
--   generating the usage help, while <a>ocheck</a> takes a list of flags
--   and returns a list of error messages, which can be used to check for
--   conflicting options.
module Darcs.UI.Options.Core

-- | A type for option specifications.
--   
--   It consists of four components: a parser, an unparser, a checker, and
--   a list of descriptions.
--   
--   The parser converts a flag list to some result value. This can never
--   fail: we demand that primitive parsers are written so that there is
--   always a default value (use <a>Maybe</a> with default <a>Nothing</a>
--   as a last resort).
--   
--   The unparser does the opposite of the parser: a value is converted
--   back to a flag list.
--   
--   The checker returns a list of error messages (which should be empty if
--   there are no problems found). This can be used to e.g. check whether
--   there are conflicting flags in the list.
--   
--   Separating the checker and parser is unusual. The reason for this is
--   that we want to support flags coming from multiple sources, such as
--   the command line or a defaults file. Prioritising these sources is
--   done by concatenating the flag lists in the order of precedence, so
--   that earlier flags win over later ones. That means that when parsing
--   the (final) flag list, conflicting flags are resolved by picking the
--   first flag that matches an option. The checker, on the other hand, can
--   be called for each source separately.
--   
--   The last component is a list of descriptors for each single
--   switch/flag that the option is made of.
--   
--   The <a>OptSpec</a> type is heavily parameterized. The type arguments
--   are:
--   
--   <ul>
--   <li><i><tt>f</tt></i> The flag type, such as <a>DarcsFlag</a>.</li>
--   <li><i><tt>d</tt></i> A type that describes an single flag, such as
--   <a>OptDescr</a> or <a>DarcsOptDescr</a>. It should be a
--   <a>Functor</a>.</li>
--   </ul>
--   
--   Abstracting over these types is not technically necessary: for the
--   intended application in Darcs, we could as well fix them as
--   <tt>d=<a>DarcsOptDescr</a></tt>, and <tt>f=<a>DarcsFlag</a></tt>,
--   saving two type parameters. However, doing that here would only
--   obscure what's going on, making the code harder to understand, not
--   easier. Besides, the resulting more general type signatures give us
--   additional guarantees, known as "free theorems" (free as in beer, not
--   in speak).
--   
--   In contrast, the type parameters
--   
--   <ul>
--   <li><i><tt>a</tt>, <tt>b</tt></i> are necessary to make chaining of
--   options a la typed printf/scanf possible. In a nutshell, <tt>a</tt> is
--   the result type of a function that consumes the result of parsing or
--   unparsing an option, while <tt>b</tt> is the complete type of such a
--   function.</li>
--   </ul>
--   
--   The <a>ounparse</a> and <a>oparse</a> members use continuation passing
--   style, which is the reason for their apparently "inverted" type
--   signature. To understand them, it helps to look at the type of
--   "primitive" (not yet combined) options (see <a>PrimOptSpec</a> below).
--   For a primitive option, <tt>b</tt> gets instantiated to <tt>v -&gt;
--   a</tt>, where <tt>v</tt> is the type of values associated with the
--   option. The whole option spec then has type
--   
--   <pre>
--   o :: 'OptSpec' d f a (v -&gt; a)
--   </pre>
--   
--   so that the <a>oparse</a> and <a>ounparse</a> members are instantiated
--   to
--   
--   <pre>
--   ounparse :: forall a. ([f] -&gt; a) -&gt; (x -&gt; a)
--   oparse   :: forall a. (x -&gt; a) -&gt; ([f] -&gt; a)
--   </pre>
--   
--   which can be easily seen to be equivalent to
--   
--   <pre>
--   ounparse :: x -&gt; [f]
--   oparse   :: [f] -&gt; x
--   </pre>
--   
--   Chaining such options results in a combined option of type
--   
--   <pre>
--   o1 ^ o2 ^ ... :: OptSpec d f a (v1 -&gt; v2 -&gt; ... -&gt; a)
--   </pre>
--   
--   that is, <tt>b</tt> gets instantiated to
--   
--   <pre>
--   v1 -&gt; v2 -&gt; ... -&gt; a
--   </pre>
--   
--   To use such an option (primitive or combined), you pass in the
--   consumer. A typical consumer of option values is a command
--   implementation. Given
--   
--   <pre>
--   cmd :: v1 -&gt; v2 -&gt; ... -&gt; [String] -&gt; IO ()
--   </pre>
--   
--   we can parse the flags and pass the results to <tt>cmd</tt>:
--   
--   <pre>
--   oparse (o1 ^ o2 ^ ...) cmd flags
--   </pre>
data OptSpec d f a b
OptSpec :: (([f] -> a) -> b) -> (b -> ([f] -> a)) -> ([f] -> [String]) -> [d f] -> OptSpec d f a b

-- | Convert option value (back) to flag list, in CPS.
ounparse :: OptSpec d f a b -> ([f] -> a) -> b

-- | Convert flag list to option value, in CPS. Note: as a pure function,
--   it is not supposed to fail.
oparse :: OptSpec d f a b -> b -> ([f] -> a)

-- | Check for erros in a flag list, returns error messages.
ocheck :: OptSpec d f a b -> [f] -> [String]

-- | Descriptions, one for each flag that makes up the option.
odesc :: OptSpec d f a b -> [d f]

-- | Identity <a>OptSpec</a>, unit for <a>^</a>
oid :: OptSpec d f a a

-- | <a>OptSpec</a> composition, associative
(^) :: OptSpec d f b c -> OptSpec d f a b -> OptSpec d f a c

-- | Normalise a flag list by parsing and then unparsing it. This adds all
--   implicit (default) flags to the list, which is useful as long as there
--   is legacy code that circumvents the <a>OptSpec</a> abstraction and
--   directly tests for flag membership.
--   
--   <pre>
--   onormalise opts = (oparse opts . ounparse opts) id
--   </pre>
onormalise :: OptSpec d f [f] b -> [f] -> [f]

-- | The list of default flags for an <a>OptSpec</a>.
--   
--   <pre>
--   defaultFlags opts = onormalise opts []
--   </pre>
defaultFlags :: OptSpec d f [f] b -> [f]

-- | Lift an isomorphism between <tt>b</tt> and <tt>c</tt> to one between
--   <tt><a>OptSpec</a> d f a b</tt> and <tt><a>OptSpec</a> d f a c</tt>.
--   
--   The forward component of the <a>Iso</a> is needed for <a>ounparse</a>,
--   the backward component for <a>oparse</a>. For the other two components
--   this is the identity.
oimap :: Iso b c -> OptSpec d f a b -> OptSpec d f a c

-- | Type of primitive (not yet combined) options. The type parameter
--   <tt>b</tt> gets instantiated to <tt>(v -&gt; a)</tt>, adding one
--   argument of type <tt>v</tt> to the answer type of the continuation.
type PrimOptSpec d f a v = OptSpec d f a (v -> a)

-- | Combine two list valued options of the same type "in parellel". This
--   is done by concatenating the resulting option values (<a>oparse</a>),
--   flags (<a>ounparse</a>), errors (<a>ocheck</a>), and descriptors
--   (<a>odesc</a>), respectively, of the input options.
oappend :: PrimOptSpec d f a [v] -> PrimOptSpec d f a [v] -> PrimOptSpec d f a [v]

-- | Unit for <a>oappend</a>.
oempty :: PrimOptSpec d f a [v]

-- | See <a>oappend</a> and <a>oempty</a>.

-- | Parse a list of flags against a primitive option spec, returning the
--   value associated with the option. As noted above, this cannot fail
--   because options always have a default value.
--   
--   <pre>
--   parseFlags o fs = oparse o id fs
--   </pre>
parseFlags :: (forall a. PrimOptSpec d f a v) -> [f] -> v
instance Monoid (PrimOptSpec d f a [v])
instance IsoFunctor (OptSpec d f a)

module Darcs.Util.DateTime

-- | Get the current UTC time from the system clock.
getCurrentTime :: IO UTCTime
toSeconds :: UTCTime -> Integer
formatDateTime :: String -> UTCTime -> String
fromClockTime :: ClockTime -> UTCTime
parseDateTime :: String -> String -> Maybe UTCTime
startOfTime :: UTCTime


-- | This module implements relative paths within a Tree. All paths are
--   anchored at a certain root (this is usually the Tree root). They are
--   represented by a list of Names (these are just strict bytestrings).
module Storage.Hashed.AnchoredPath
newtype Name
Name :: ByteString -> Name

-- | This is a type of "sane" file paths. These are always canonic in the
--   sense that there are no stray slashes, no ".." components and similar.
--   They are usually used to refer to a location within a Tree, but a
--   relative filesystem path works just as well. These are either
--   constructed from individual name components (using "appendPath",
--   "catPaths" and "makeName"), or converted from a FilePath ("floatPath"
--   -- but take care when doing that) or .
newtype AnchoredPath
AnchoredPath :: [Name] -> AnchoredPath
anchoredRoot :: AnchoredPath

-- | Append an element to the end of a path.
appendPath :: AnchoredPath -> Name -> AnchoredPath

-- | Take a "root" directory and an anchored path and produce a full
--   <a>FilePath</a>. Moreover, you can use <tt>anchorPath ""</tt> to get a
--   relative <a>FilePath</a>.
anchorPath :: FilePath -> AnchoredPath -> FilePath

-- | Check whether a path is a prefix of another path.
isPrefix :: AnchoredPath -> AnchoredPath -> Bool

-- | Get parent (path) of a given path. foo<i>bar</i>baz -&gt; foo/bar
parent :: AnchoredPath -> AnchoredPath

-- | List all parents of a given path. foo<i>bar</i>baz -&gt; [foo,
--   foo/bar]
parents :: AnchoredPath -> [AnchoredPath]

-- | Catenate two paths together. Not very safe, but sometimes useful (e.g.
--   when you are representing paths relative to a different point than a
--   Tree root).
catPaths :: AnchoredPath -> AnchoredPath -> AnchoredPath
flatten :: AnchoredPath -> ByteString
makeName :: String -> Name

-- | Append a ByteString to the last Name of an AnchoredPath.
appendToName :: AnchoredPath -> String -> AnchoredPath

-- | Unsafe. Only ever use on bytestrings that came from flatten on a
--   pre-existing AnchoredPath.
floatBS :: ByteString -> AnchoredPath

-- | Take a relative FilePath and turn it into an AnchoredPath. The
--   operation is (relatively) unsafe. Basically, by using floatPath, you
--   are testifying that the argument is a path relative to some common
--   root -- i.e. the root of the associated <a>Tree</a> object. Also,
--   there are certain invariants about AnchoredPath that this function
--   tries hard to preserve, but probably cannot guarantee (i.e. this is a
--   best-effort thing). You should sanitize any FilePaths before you
--   declare them "good" by converting into AnchoredPath (using this
--   function).
floatPath :: FilePath -> AnchoredPath

-- | Take a prefix path, the changed prefix path, and a path to change.
--   Assumes the prefix path is a valid prefix. If prefix is wrong return
--   AnchoredPath [].
replacePrefixPath :: AnchoredPath -> AnchoredPath -> AnchoredPath -> AnchoredPath
instance Eq Name
instance Show Name
instance Ord Name
instance Eq AnchoredPath
instance Show AnchoredPath
instance Ord AnchoredPath


-- | XXX: Perhaps a word of explanation here [WL]
module Darcs.Util.Ratified

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <tt>hClose</tt>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <tt>hClose</tt> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String


-- | |A parser for commandlines, returns an arg list and expands format
--   strings given in a translation table. Additionally the commandline can
--   end with "%&lt;" specifying that the command expects input on stdin.
--   
--   Some tests for the parser.
--   
--   <pre>
--   formatTable = [('s',"&lt;insert subject here&gt;"),
--                  ('a',"&lt;insert author here&gt;")]
--   
--   testParser :: (Show a, Eq a) =&gt; Parser a -&gt; String -&gt; a -&gt; a
--   testParser p s ok = case parse p "" s of
--                       Left e -&gt; error $ "Parser failed with: " ++ (show e)
--                       Right res -&gt; if res == ok
--                                    then res
--                                    else error $ "Parser failed: got "
--                                           ++ (show res) ++ ", expected "
--                                           ++ (show ok)
--   
--   testCases = [("a b",(["a","b"], False)),
--                ("a b %&lt;",(["a","b"], True)),
--                ("a b %&lt; ",(["a","b"], True)),
--                ("\"arg0 contains spaces \\\"quotes\\\"\" b",
--                 (["arg0 contains spaces \"quotes\"","b"],False)),
--                ("a %s %&lt;",(["a","&lt;insert subject here&gt;"], True))]
--   
--   runTests = map (uncurry $ testParser (commandline formatTable)) testCases
--   </pre>
module Darcs.Util.CommandLine

-- | parse a commandline returning a list of strings (intended to be used
--   as argv) and a bool value which specifies if the command expects input
--   on stdin format specifiers with a mapping in ftable are accepted and
--   replaced by the given strings. E.g. if the ftable is
--   [(<tt>s</tt>,"Some subject")], then "%s" is replaced by "Some subject"
parseCmd :: FTable -> String -> Either ParseError ([String], Bool)

-- | for every mapping (c,s), add a mapping with uppercase c and the
--   urlencoded string s
addUrlencoded :: FTable -> FTable


-- | This was originally Tomasz Zielonka's AtExit module, slightly
--   generalised to include global variables. Here, we attempt to cover
--   broad, global features, such as exit handlers. These features slightly
--   break the Haskellian purity of darcs, in favour of programming
--   convenience.
module Darcs.Util.AtExit

-- | Registers an IO action to run just before darcs exits. Useful for
--   removing temporary files and directories, for example. Referenced in
--   Issue1914.
atexit :: IO () -> IO ()
withAtexit :: IO a -> IO a


module Darcs.Util.Workaround

-- | <tt><a>renameFile</a> old new</tt> changes the name of an existing
--   file system object from <i>old</i> to <i>new</i>. If the <i>new</i>
--   object already exists, it is atomically replaced by the <i>old</i>
--   object. Neither path may refer to an existing directory. A conformant
--   implementation need not support renaming files in all situations (e.g.
--   renaming across different physical devices), but the constraints must
--   be documented.
--   
--   The operation may fail with:
--   
--   <ul>
--   <li><tt>HardwareFault</tt> A physical I/O error has occurred.
--   <tt>[EIO]</tt></li>
--   <li><tt>InvalidArgument</tt> Either operand is not a valid file name.
--   <tt>[ENAMETOOLONG, ELOOP]</tt></li>
--   <li><a>isDoesNotExistError</a> / <tt>NoSuchThing</tt> The original
--   file does not exist, or there is no path to the target. <tt>[ENOENT,
--   ENOTDIR]</tt></li>
--   <li><a>isPermissionError</a> / <tt>PermissionDenied</tt> The process
--   has insufficient privileges to perform the operation. <tt>[EROFS,
--   EACCES, EPERM]</tt></li>
--   <li><tt>ResourceExhausted</tt> Insufficient resources are available to
--   perform the operation. <tt>[EDQUOT, ENOSPC, ENOMEM, EMLINK]</tt></li>
--   <li><tt>UnsatisfiedConstraints</tt> Implementation-dependent
--   constraints are not satisfied. <tt>[EBUSY]</tt></li>
--   <li><tt>UnsupportedOperation</tt> The implementation does not support
--   renaming in this situation. <tt>[EXDEV]</tt></li>
--   <li><a>InappropriateType</a> Either path refers to an existing
--   directory. <tt>[ENOTDIR, EISDIR, EINVAL, EEXIST, ENOTEMPTY]</tt></li>
--   </ul>
renameFile :: FilePath -> FilePath -> IO ()
setExecutable :: FilePath -> Bool -> IO ()

-- | If the operating system has a notion of current directories,
--   <a>getCurrentDirectory</a> returns an absolute path to the current
--   directory of the calling process.
--   
--   The operation may fail with:
--   
--   <ul>
--   <li><tt>HardwareFault</tt> A physical I/O error has occurred.
--   <tt>[EIO]</tt></li>
--   <li><a>isDoesNotExistError</a> / <tt>NoSuchThing</tt> There is no path
--   referring to the current directory. <tt>[EPERM, ENOENT,
--   ESTALE...]</tt></li>
--   <li><a>isPermissionError</a> / <tt>PermissionDenied</tt> The process
--   has insufficient privileges to perform the operation.
--   <tt>[EACCES]</tt></li>
--   <li><tt>ResourceExhausted</tt> Insufficient resources are available to
--   perform the operation.</li>
--   <li><tt>UnsupportedOperation</tt> The operating system has no notion
--   of current directory.</li>
--   </ul>
--   
--   Note that in a concurrent program, the current directory is global
--   state shared between all threads of the process. When using filesystem
--   operations from multiple threads, it is therefore highly recommended
--   to use absolute rather than relative <a>FilePath</a>s.
getCurrentDirectory :: IO FilePath

-- | <tt>installHandler int handler iset</tt> calls <tt>sigaction</tt> to
--   install an interrupt handler for signal <tt>int</tt>. If
--   <tt>handler</tt> is <tt>Default</tt>, <tt>SIG_DFL</tt> is installed;
--   if <tt>handler</tt> is <tt>Ignore</tt>, <tt>SIG_IGN</tt> is installed;
--   if <tt>handler</tt> is <tt>Catch action</tt>, a handler is installed
--   which will invoke <tt>action</tt> in a new thread when (or shortly
--   after) the signal is received. If <tt>iset</tt> is <tt>Just s</tt>,
--   then the <tt>sa_mask</tt> of the <tt>sigaction</tt> structure is set
--   to <tt>s</tt>; otherwise it is cleared. The previously installed
--   signal handler for <tt>int</tt> is returned
installHandler :: Signal -> Handler -> Maybe SignalSet -> IO Handler

-- | <tt>raiseSignal int</tt> calls <tt>kill</tt> to signal the current
--   process with interrupt signal <tt>int</tt>.
raiseSignal :: Signal -> IO ()

-- | The actions to perform when a signal is received.
data Handler :: *
Default :: Handler
Ignore :: Handler
Catch :: IO () -> Handler
CatchOnce :: IO () -> Handler

-- | <i>Since: 2.7.0.0</i>
CatchInfo :: (SignalInfo -> IO ()) -> Handler

-- | <i>Since: 2.7.0.0</i>
CatchInfoOnce :: (SignalInfo -> IO ()) -> Handler
type Signal = CInt
sigINT :: CInt
sigHUP :: CInt
sigABRT :: CInt
sigALRM :: CInt
sigTERM :: CInt
sigPIPE :: CInt

module Darcs.Util.Crypt.SHA256
sha256sum :: ByteString -> String


-- | This modules provides rudimentary natural language generation (NLG)
--   utilities. That is, generating natural language from a machine
--   representation. Initially, only English is supported at all.
--   Representations are implemented for:
--   
--   <ul>
--   <li>countable nouns (plurality); and</li>
--   <li>lists of clauses (foo, bar and/or baz).</li>
--   </ul>
module Darcs.Util.English

-- | <pre>
--   englishNum 0 (Noun "watch") "" == "watches"
--   englishNum 1 (Noun "watch") "" == "watch"
--   englishNum 2 (Noun "watch") "" == "watches"
--   </pre>
englishNum :: Countable n => Int -> n -> ShowS

-- | Things that have a plural and singular spelling
class Countable a
plural :: Countable a => a -> ShowS
singular :: Countable a => a -> ShowS

-- | This only distinguishes between nouns with a final -ch, and nouns
--   which do not. More irregular nouns will just need to have their own
--   type
--   
--   <pre>
--   plural (Noun "batch") "" == "batches"
--   plural (Noun "bat")   "" == "bats"
--   plural (Noun "mouse") "" == "mouses" -- :-(
--   </pre>
newtype Noun
Noun :: String -> Noun
data Pronoun
It :: Pronoun

-- | <pre>
--   singular This (Noun "batch") "" == "this batch"
--   plural   This (Noun "batch") "" == "these batches"
--   </pre>
data This
This :: Noun -> This

-- | Given a list of things, combine them thusly:
--   
--   <pre>
--   orClauses ["foo", "bar", "baz"] == "foo, bar or baz"
--   </pre>
andClauses :: [String] -> String

-- | Given a list of things, combine them thusly:
--   
--   <pre>
--   orClauses ["foo", "bar", "baz"] == "foo, bar or baz"
--   </pre>
orClauses :: [String] -> String

-- | As <tt>intersperse</tt>, with a different separator for the last |
--   interspersal.
intersperseLast :: String -> String -> [String] -> String
presentParticiple :: String -> String
instance Countable This
instance Countable Pronoun
instance Countable Noun

module Darcs.Patch.RegChars

-- | <a>regChars</a> returns a filter function that tells if a char is a
--   member of the regChar expression or not. The regChar expression is
--   basically a set of chars, but it can contain ranges with use of the
--   <a>-</a> (dash), and it can also be specified as a complement set by
--   prefixing with <a>^</a> (caret). The dash and caret, as well as the
--   backslash, can all be escaped with a backslash to suppress their
--   special meaning.
--   
--   NOTE: The <a>.</a> (dot) is allowed to be escaped. It has no special
--   meaning if it is not escaped, but the default <tt>filename_toks</tt>
--   in Darcs.Commands.Replace uses an escaped dot (WHY?).
regChars :: String -> Char -> Bool


module Darcs.Util.IsoDate

-- | The current time in the format returned by <a>showIsoDateTime</a>
getIsoDateTime :: IO String

-- | Read/interpret a date string, assuming UTC if timezone is not
--   specified in the string (see <a>readDate</a>) Warning! This errors out
--   if we fail to interpret the date
readUTCDate :: String -> CalendarTime

-- | Parse a date string, assuming a default timezone if the date string
--   does not specify one. The date formats understood are those of
--   <a>showIsoDateTime</a> and <a>dateTime</a>
parseDate :: Int -> String -> Either ParseError MCalendarTime

-- | Return the local timezone offset from UTC in seconds
getLocalTz :: IO Int

-- | In English, either a date followed by a time, or vice-versa, e.g,
--   
--   <ul>
--   <li>yesterday at noon<ul><li>yesterday tea time</li><li>12:00
--   yesterday</li></ul></li>
--   </ul>
--   
--   See <a>englishDate</a> and <a>englishTime</a> Uses its first argument
--   as "now", i.e. the time relative to which "yesterday", "today" etc are
--   to be interpreted
englishDateTime :: CalendarTime -> CharParser a CalendarTime

-- | English expressions for intervals of time,
--   
--   <ul>
--   <li>before tea time (i.e. from the beginning of time)<ul><li>after
--   14:00 last month (i.e. till now)</li><li>between last year and last
--   month</li><li>in the last three months (i.e. from then till
--   now)</li><li>4 months ago (i.e. till now; see
--   <a>englishAgo</a>)</li></ul></li>
--   </ul>
englishInterval :: CalendarTime -> CharParser a TimeInterval

-- | Durations in English that begin with the word "last", E.g. "last 4
--   months" is treated as the duration between 4 months ago and now
englishLast :: CalendarTime -> CharParser a (CalendarTime, CalendarTime)

-- | Intervals in ISO 8601, e.g.,
--   
--   <ul>
--   
--   <li>2008-09/2012-08-17T16:30<ul><li>2008-09/P2Y11MT16H30M</li><li>P2Y11MT16H30M/2012-08-17T16:30</li></ul></li>
--   </ul>
--   
--   See <a>iso8601Duration</a>
iso8601Interval :: Int -> CharParser a (Either TimeDiff (MCalendarTime, MCalendarTime))

-- | Durations in ISO 8601, e.g.,
--   
--   <ul>
--   <li>P4Y (four years)<ul><li>P5M (five months)</li><li>P4Y5M (four
--   years and five months)</li><li>P4YT3H6S (four years, three hours and
--   six seconds)</li></ul></li>
--   </ul>
iso8601Duration :: CharParser a TimeDiff

-- | Convert a date string into ISO 8601 format (yyyymmdd variant) assuming
--   local timezone if not specified in the string Warning! This errors out
--   if we fail to interpret the date
cleanLocalDate :: String -> IO String

-- | Set a calendar to UTC time any eliminate any inconsistencies within
--   (for example, where the weekday is given as <tt>Thursday</tt>, but
--   this does not match what the numerical date would lead one to expect)
resetCalendar :: CalendarTime -> CalendarTime

-- | An <tt>MCalenderTime</tt> is an underspecified <a>CalendarTime</a> It
--   is used for parsing dates. For example, if you want to parse the date
--   '4 January', it may be useful to underspecify the year by setting it
--   to <a>Nothing</a>. This uses almost the same fields as
--   <a>CalendarTime</a>, a notable exception being that we introduce
--   <a>mctWeek</a> to indicate if a weekday was specified or not
data MCalendarTime
MCalendarTime :: Maybe Int -> Maybe Month -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Integer -> Maybe Day -> Maybe Int -> Maybe String -> Maybe Int -> Maybe Bool -> Bool -> MCalendarTime
mctYear :: MCalendarTime -> Maybe Int
mctMonth :: MCalendarTime -> Maybe Month
mctDay :: MCalendarTime -> Maybe Int
mctHour :: MCalendarTime -> Maybe Int
mctMin :: MCalendarTime -> Maybe Int
mctSec :: MCalendarTime -> Maybe Int
mctPicosec :: MCalendarTime -> Maybe Integer
mctWDay :: MCalendarTime -> Maybe Day
mctYDay :: MCalendarTime -> Maybe Int
mctTZName :: MCalendarTime -> Maybe String
mctTZ :: MCalendarTime -> Maybe Int
mctIsDST :: MCalendarTime -> Maybe Bool
mctWeek :: MCalendarTime -> Bool
subtractFromMCal :: TimeDiff -> MCalendarTime -> MCalendarTime
addToMCal :: TimeDiff -> MCalendarTime -> MCalendarTime

-- | Trivially convert a <a>CalendarTime</a> to a fully specified
--   <a>MCalendarTime</a> (note that this sets the <a>mctWeek</a> flag to
--   <tt>False</tt>
toMCalendarTime :: CalendarTime -> MCalendarTime

-- | Returns the first <a>CalendarTime</a> that falls within a
--   <a>MCalendarTime</a> This is only unsafe in the sense that it plugs in
--   default values for fields that have not been set, e.g.
--   <tt>January</tt> for the month or <tt>0</tt> for the seconds field.
--   Maybe we should rename it something happier. See also
--   <a>resetCalendar</a>
unsafeToCalendarTime :: MCalendarTime -> CalendarTime

-- | Zero the time fields of a <a>CalendarTime</a>
unsetTime :: CalendarTime -> CalendarTime
type TimeInterval = (Maybe CalendarTime, Maybe CalendarTime)
instance Show MCalendarTime

module Storage.Hashed.Hash
data Hash
SHA256 :: !ByteString -> Hash
SHA1 :: !ByteString -> Hash
NoHash :: Hash
encodeBase64u :: Hash -> ByteString

-- | Take a base64/url-encoded string and decode it as a <a>Hash</a>. If
--   the string is malformed, yields NoHash.
decodeBase64u :: ByteString -> Hash

-- | Produce a base16 (ascii-hex) encoded string from a hash. This can be
--   turned back into a Hash (see "decodeBase16". This is a loss-less
--   process.
encodeBase16 :: Hash -> ByteString

-- | Take a base16-encoded string and decode it as a <a>Hash</a>. If the
--   string is malformed, yields NoHash.
decodeBase16 :: ByteString -> Hash

-- | Compute a sha256 of a (lazy) ByteString. However, although this works
--   correctly for any bytestring, it is only efficient if the bytestring
--   only has a sigle chunk.
sha256 :: ByteString -> Hash
rawHash :: Hash -> ByteString
match :: Hash -> Hash -> Bool
instance Typeable Hash
instance Show Hash
instance Eq Hash
instance Ord Hash
instance Read Hash
instance Data Hash


-- | This was originally Tomasz Zielonka's AtExit module, slightly
--   generalised to include global variables. Here, we attempt to cover
--   broad, global features, such as exit handlers. These features slightly
--   break the Haskellian purity of darcs, in favour of programming
--   convenience.
module Darcs.Util.Global
timingsMode :: Bool
setTimingsMode :: IO ()
whenDebugMode :: IO () -> IO ()
withDebugMode :: (Bool -> IO a) -> IO a
setDebugMode :: IO ()
debugMessage :: String -> IO ()
debugFail :: String -> IO a
putTiming :: IO ()
addCRCWarning :: FilePath -> IO ()
getCRCWarnings :: IO [FilePath]
resetCRCWarnings :: IO ()
addBadSource :: String -> IO ()
getBadSourcesList :: IO [String]
isBadSource :: IO (String -> Bool)
darcsdir :: String
darcsLastMessage :: String
darcsSendMessage :: String
darcsSendMessageFinal :: String
isReachableSource :: IO (String -> Bool)
addReachableSource :: String -> IO ()


-- | Utility functions for tracking progress of long-running actions.
module Darcs.Util.Progress

-- | <tt>beginTedious k</tt> starts a tedious process and registers it in
--   <a>_progressData</a> with the key <tt>k</tt>. A tedious process is one
--   for which we want a progress indicator.
--   
--   Wouldn't it be safer if it had type String -&gt; IO ProgressDataKey,
--   so that we can ensure there is no collision? What happens if you call
--   beginTedious twice with the same string, without calling endTedious in
--   the meantime?
beginTedious :: String -> IO ()

-- | <tt>endTedious k</tt> unregisters the tedious process with key
--   <tt>k</tt>, printing <a>Done</a> if such a tedious process exists.
endTedious :: String -> IO ()
tediousSize :: String -> Int -> IO ()
debugMessage :: String -> IO ()
debugFail :: String -> IO a
withoutProgress :: IO a -> IO a
progress :: String -> a -> a
progressKeepLatest :: String -> a -> a
finishedOne :: String -> String -> a -> a
finishedOneIO :: String -> String -> IO ()
progressList :: String -> [a] -> [a]

-- | XXX: document this constant
minlist :: Int
setProgressMode :: Bool -> IO ()


module Darcs.Util.Exec
exec :: String -> [String] -> Redirects -> IO ExitCode
execInteractive :: String -> String -> IO ExitCode
readInteractiveProcess :: FilePath -> [String] -> IO (ExitCode, String)
renderExecException :: ExecException -> String
withoutNonBlock :: IO a -> IO a
type Redirects = (Redirect, Redirect, Redirect)
data Redirect
AsIs :: Redirect
Null :: Redirect
File :: FilePath -> Redirect
Stdout :: Redirect
data ExecException
ExecException :: String -> [String] -> Redirects -> String -> ExecException
instance Typeable ExecException
instance Show Redirect
instance Show ExecException
instance Exception ExecException

module Darcs.Util.Ssh
data SshSettings
SshSettings :: String -> String -> String -> SshSettings
ssh :: SshSettings -> String
scp :: SshSettings -> String
sftp :: SshSettings -> String
defaultSsh :: SshSettings
windows :: Bool
instance Show SshSettings
instance Eq SshSettings

module Darcs.Util.SignalHandler
withSignalsHandled :: IO a -> IO a
withSignalsBlocked :: IO a -> IO a
catchInterrupt :: IO a -> IO a -> IO a

-- | A drop-in replacement for <a>catch</a>, which allows us to catch
--   anything but a signal. Useful for situations where we don't want to
--   inhibit ctrl-C.
catchNonSignal :: IO a -> (SomeException -> IO a) -> IO a
tryNonSignal :: IO a -> IO (Either SomeException a)
stdoutIsAPipe :: IO Bool
instance Typeable SignalException
instance Show SignalException
instance Exception SignalException

module Darcs.Util.Exception

-- | The firstJustIO is a slight modification to firstJustM: the entries in
--   the list must be IO monad operations and the firstJustIO will silently
--   turn any monad call that throws an exception into Nothing, basically
--   causing it to be ignored.
firstJustIO :: [IO (Maybe a)] -> IO (Maybe a)
catchall :: IO a -> IO a -> IO a
clarifyErrors :: IO a -> String -> IO a
prettyException :: SomeException -> String
prettyError :: IOError -> String

module Darcs.Util.Environment
maybeGetEnv :: String -> IO (Maybe String)


module Darcs.Util.DateMatcher

-- | <a>parseDateMatcher</a> <tt>s</tt> return the first matcher in
--   <a>getMatchers</a> that can parse <tt>s</tt>
parseDateMatcher :: String -> IO (CalendarTime -> Bool)

-- | A <a>DateMatcher</a> combines a potential parse for a date string with
--   a "matcher" function that operates on a given date. We use an
--   existential type on the matcher to allow the date string to either be
--   interpreted as a point in time or as an interval.
data DateMatcher
DM :: String -> (Either ParseError d) -> (d -> CalendarTime -> Bool) -> DateMatcher

-- | <a>getMatchers</a> <tt>d</tt> returns the list of matchers that will
--   be applied on <tt>d</tt>. If you wish to extend the date parsing code,
--   this will likely be the function that you modify to do so.
getMatchers :: String -> IO [DateMatcher]

module Darcs.Patch.Type

-- | Used for indicating a patch type without having a concrete patch
data PatchType (p :: * -> * -> *)
PatchType :: PatchType
patchType :: p wX wY -> PatchType p

module Darcs.Util.Prompt

-- | Ask the user to press Enter
askEnter :: String -> IO ()

-- | Ask the user for a line of input.
askUser :: String -> IO String

-- | <tt>askUserListItem prompt xs</tt> enumerates <tt>xs</tt> on the
--   screen, allowing the user to choose one of the items
askUserListItem :: String -> [String] -> IO String
data PromptConfig
PromptConfig :: String -> [Char] -> [Char] -> Maybe Char -> [Char] -> PromptConfig
pPrompt :: PromptConfig -> String
pBasicCharacters :: PromptConfig -> [Char]

-- | only shown on help
pAdvancedCharacters :: PromptConfig -> [Char]
pDefault :: PromptConfig -> Maybe Char
pHelp :: PromptConfig -> [Char]

-- | Prompt the user for a yes or no
promptYorn :: String -> IO Bool

-- | Prompt the user for a character, among a list of possible ones. Always
--   returns a lowercase character. This is because the default character
--   (ie, the character shown in uppercase, that is automatically selected
--   when the user presses the space bar) is shown as uppercase, hence
--   users may want to enter it as uppercase.
promptChar :: PromptConfig -> IO Char

module Darcs.Patch.OldDate

-- | Read/interpret a date string, assuming UTC if timezone is not
--   specified in the string
readUTCDate :: String -> CalendarTime
showIsoDateTime :: CalendarTime -> String

module Darcs.Util.Show
appPrec :: Int
newtype BSWrapper
BSWrapper :: ByteString -> BSWrapper
instance Show BSWrapper

module Darcs.Patch.Witnesses.Show
data ShowDict a
ShowDictClass :: ShowDict a
ShowDictRecord :: (Int -> a -> ShowS) -> (a -> String) -> ([a] -> ShowS) -> ShowDict a
showD :: ShowDict a -> a -> String
showListD :: ShowDict a -> [a] -> ShowS
showsPrecD :: ShowDict a -> Int -> a -> ShowS
class Show1 a
showDict1 :: Show1 a => ShowDict (a wX)
class Show2 a
showDict2 :: Show2 a => ShowDict (a wX wY)
show1 :: Show1 a => a wX -> String
showsPrec1 :: Show1 a => Int -> a wX -> ShowS
show2 :: Show2 a => a wX wY -> String
showsPrec2 :: Show2 a => Int -> a wX wY -> ShowS
showOp2 :: (Show2 a, Show2 b) => Int -> String -> Int -> a wW wX -> b wY wZ -> String -> String
appPrec :: Int

module Darcs.Patch.Witnesses.Unsafe
unsafeCoerceP :: a wX wY -> a wB wC
unsafeCoercePStart :: a wX1 wY -> a wX2 wY
unsafeCoercePEnd :: a wX wY1 -> a wX wY2
unsafeCoerceP2 :: t wW wX wY wZ -> t wA wB wC wD
unsafeCoerceP1 :: a wX -> a wY

module Darcs.Patch.Witnesses.Eq

-- | <a>EqCheck</a> is used to pass around evidence (or lack thereof) of
--   two witness types being equal.
data EqCheck wA wB
IsEq :: EqCheck wA wA
NotEq :: EqCheck wA wB

-- | An witness aware equality class. A minimal definition defines any one
--   of <a>unsafeCompare</a>, <a>=\/=</a> and <a>=/\=</a>.
class MyEq p where unsafeCompare a b = IsEq == (a =/\= unsafeCoerceP b) a =\/= b | unsafeCompare a b = unsafeCoerceP IsEq | otherwise = NotEq a =/\= b | IsEq == (a =\/= unsafeCoerceP b) = unsafeCoerceP IsEq | otherwise = NotEq
unsafeCompare :: MyEq p => p wA wB -> p wC wD -> Bool
(=\/=) :: MyEq p => p wA wB -> p wA wC -> EqCheck wB wC
(=/\=) :: MyEq p => p wA wC -> p wB wC -> EqCheck wA wB
isIsEq :: EqCheck wA wB -> Bool
instance Show (EqCheck wA wB)
instance Eq (EqCheck wA wB)

module Darcs.Patch.Witnesses.Sealed

-- | A <a>Sealed</a> type is a way of hide an existentially quantified type
--   parameter, in this case wX, inside the type. Note that the only thing
--   we can currently recover about the existentially quantified type wX is
--   that it exists.
data Sealed a
Sealed :: a wX -> Sealed a
seal :: a wX -> Sealed a

-- | The same as <a>Sealed</a> but for two parameters (wX and wY).
data Sealed2 a
Sealed2 :: !(a wX wY) -> Sealed2 a
seal2 :: a wX wY -> Sealed2 a
data FlippedSeal a wY
FlippedSeal :: !(a wX wY) -> FlippedSeal a wY
flipSeal :: a wX wY -> FlippedSeal a wY
unsafeUnseal :: Sealed a -> a wX
unsafeUnsealFlipped :: FlippedSeal a wY -> a wX wY
unsafeUnseal2 :: Sealed2 a -> a wX wY
unseal :: (forall wX. a wX -> b) -> Sealed a -> b
unsealM :: Monad m => m (Sealed a) -> (forall wX. a wX -> m b) -> m b
liftSM :: Monad m => (forall wX. a wX -> b) -> m (Sealed a) -> m b
mapSeal :: (forall wX. a wX -> b wX) -> Sealed a -> Sealed b
mapFlipped :: (forall wX. a wX wY -> b wX wZ) -> FlippedSeal a wY -> FlippedSeal b wZ
unseal2 :: (forall wX wY. a wX wY -> b) -> Sealed2 a -> b
mapSeal2 :: (forall wX wY. a wX wY -> b wX wY) -> Sealed2 a -> Sealed2 b
unsealFlipped :: (forall wX wY. a wX wY -> b) -> FlippedSeal a wZ -> b

-- | <a>Poly</a> is similar to <a>Sealed</a>, but the type argument is
--   universally quantified instead of being existentially quantified.
newtype Poly a
Poly :: (forall wX. a wX) -> Poly a
unPoly :: Poly a -> forall wX. a wX

-- | <a>Stepped</a> is a type level composition operator. For example, <tt>
--   <a>Stepped</a> (<a>Sealed</a> p) </tt> is equivalent to <tt> \x -&gt;
--   <a>Sealed</a> (p x) </tt>
newtype Stepped (f :: (* -> *) -> *) a wX
Stepped :: f (a wX) -> Stepped a wX
unStepped :: Stepped a wX -> f (a wX)

-- | <a>FreeLeft</a> p is <tt> forall x . exists y . p x y </tt> In other
--   words the caller is free to specify the left witness, and then the
--   right witness is an existential. Note that the order of the type
--   constructors is important for ensuring that <tt> y </tt> is dependent
--   on the <tt> x </tt> that is supplied. This is why <a>Stepped</a> is
--   needed, rather than writing the more obvious <a>Sealed</a>
--   (<a>Poly</a> p) which would notionally have the same quantification of
--   the type witnesses.
newtype FreeLeft p
FLInternal :: (Poly (Stepped Sealed p)) -> FreeLeft p

-- | <a>FreeLeft</a> p is <tt> forall y . exists x . p x y </tt> In other
--   words the caller is free to specify the right witness, and then the
--   left witness is an existential. Note that the order of the type
--   constructors is important for ensuring that <tt> x </tt> is dependent
--   on the <tt> y </tt> that is supplied.
newtype FreeRight p
FRInternal :: (Poly (FlippedSeal p)) -> FreeRight p

-- | Unwrap a <a>FreeLeft</a> value
unFreeLeft :: FreeLeft p -> Sealed (p wX)

-- | Unwrap a <a>FreeRight</a> value
unFreeRight :: FreeRight p -> FlippedSeal p wX

-- | <a>Gap</a> abstracts over <a>FreeLeft</a> and <a>FreeRight</a> for
--   code constructing these values
class Gap w
emptyGap :: Gap w => (forall wX. p wX wX) -> w p
freeGap :: Gap w => (forall wX wY. p wX wY) -> w p
joinGap :: Gap w => (forall wX wY wZ. p wX wY -> q wY wZ -> r wX wZ) -> w p -> w q -> w r
instance Gap FreeRight
instance Gap FreeLeft
instance Show2 a => Show (Sealed2 a)
instance Show1 a => Show (Sealed a)
instance MyEq a => Eq (Sealed (a wX))

module Darcs.Patch.Format

-- | Showing and reading lists of patches. This class allows us to control
--   how lists of patches are formatted on disk. For legacy reasons V1
--   patches have their own special treatment (see <a>ListFormat</a>).
--   Other patch types use the default format which just puts them in a
--   sequence without separators or any prelude/epilogue.
--   
--   This means that 'FL (FL p)' etc would be ambiguous, so there are no
--   instances for 'FL p' or other list types.
class PatchListFormat p where patchListFormat = ListFormatDefault
patchListFormat :: PatchListFormat p => ListFormat p

-- | This type is used to tweak the way that lists of <tt>p</tt> are shown
--   for a given <tt>Patch</tt> type <tt>p</tt>. It is needed to maintain
--   backwards compatibility for V1 and V2 patches.
data ListFormat (p :: * -> * -> *)

-- | Show and read lists without braces.
ListFormatDefault :: ListFormat

-- | Show lists with a single layer of braces around the outside, except
--   for singletons which have no braces. Read with arbitrary nested braces
--   and parens and flatten them out.
ListFormatV1 :: ListFormat

-- | Show lists without braces. Read with arbitrary nested parens and
--   flatten them out.
ListFormatV2 :: ListFormat
copyListFormat :: ListFormat p -> ListFormat q
data FileNameFormat
OldFormat :: FileNameFormat
NewFormat :: FileNameFormat

module Darcs.Patch.Prim.V3.ObjectMap
newtype UUID
UUID :: ByteString -> UUID
type Location = (UUID, ByteString)
data Object (m :: * -> *)
Directory :: DirContent -> Object
Blob :: (m ByteString) -> !Hash -> Object
data ObjectMap (m :: * -> *)
ObjectMap :: (UUID -> m (Maybe (Object m))) -> (UUID -> Object m -> m (ObjectMap m)) -> m [UUID] -> ObjectMap
getObject :: ObjectMap -> UUID -> m (Maybe (Object m))
putObject :: ObjectMap -> UUID -> Object m -> m (ObjectMap m)
listObjects :: ObjectMap -> m [UUID]
type DirContent = Map ByteString UUID
instance Eq UUID
instance Ord UUID
instance Show UUID


-- | GZIp and MMap IO for ByteStrings, encoding utilities, and
--   miscellaneous functions for Data.ByteString
module Darcs.Util.ByteString

-- | Do something with the internals of a PackedString. Beware of altering
--   the contents!
unsafeWithInternals :: ByteString -> (Ptr Word8 -> Int -> IO a) -> IO a

-- | Decodes a <tt>ByteString</tt> containing UTF-8 to a <a>String</a>.
--   Decoding errors are flagged with the U+FFFD character.
unpackPSFromUTF8 :: ByteString -> String
packStringToUTF8 :: String -> ByteString

-- | Read an entire file, which may or may not be gzip compressed, directly
--   into a <a>ByteString</a>.
gzReadFilePS :: FilePath -> IO ByteString

-- | Like readFilePS, this reads an entire file directly into a
--   <a>ByteString</a>, but it is even more efficient. It involves directly
--   mapping the file to memory. This has the advantage that the contents
--   of the file never need to be copied. Also, under memory pressure the
--   page may simply be discarded, wile in the case of readFilePS it would
--   need to be written to swap. If you read many small files, mmapFilePS
--   will be less memory-efficient than readFilePS, since each mmapFilePS
--   takes up a separate page of memory. Also, you can run into bus errors
--   if the file is modified. NOTE: as with <tt>readFilePS</tt>, the string
--   representation in the file is assumed to be ISO-8859-1.
mmapFilePS :: FilePath -> IO ByteString
gzWriteFilePS :: FilePath -> ByteString -> IO ()
gzWriteFilePSs :: FilePath -> [ByteString] -> IO ()

-- | Read standard input, which may or may not be gzip compressed, directly
--   into a <a>ByteString</a>.
gzReadStdin :: IO ByteString
gzWriteHandle :: Handle -> [ByteString] -> IO ()
isGZFile :: FilePath -> IO (Maybe Int)

-- | Decompress the given bytestring into a lazy list of chunks, along with
--   a boolean flag indicating (if True) that the CRC was corrupted.
--   Inspecting the flag will cause the entire list of chunks to be
--   evaluated (but if you throw away the list immediately this should run
--   in constant space).
gzDecompress :: Maybe Int -> ByteString -> ([ByteString], Bool)
dropSpace :: ByteString -> ByteString
breakSpace :: ByteString -> (ByteString, ByteString)
linesPS :: ByteString -> [ByteString]

-- | This function acts exactly like the <a>Prelude</a> unlines function,
--   or like <a>Data.ByteString.Char8</a> <a>unlines</a>, but with one
--   important difference: it will produce a string which may not end with
--   a newline! That is:
--   
--   <pre>
--   unlinesPS ["foo", "bar"]
--   </pre>
--   
--   evaluates to "foo\nbar", not "foo\nbar\n"! This point should hold true
--   for <a>linesPS</a> as well.
--   
--   TODO: rename this function.
unlinesPS :: [ByteString] -> ByteString
hashPS :: ByteString -> Int32
breakFirstPS :: Char -> ByteString -> Maybe (ByteString, ByteString)
breakLastPS :: Char -> ByteString -> Maybe (ByteString, ByteString)
substrPS :: ByteString -> ByteString -> Maybe Int

-- | readIntPS skips any whitespace at the beginning of its argument, and
--   reads an Int from the beginning of the PackedString. If there is no
--   integer at the beginning of the string, it returns Nothing, otherwise
--   it just returns the int read, along with a B.ByteString containing the
--   remainder of its input.
readIntPS :: ByteString -> Maybe (Int, ByteString)
isFunky :: ByteString -> Bool
fromHex2PS :: ByteString -> ByteString
fromPS2Hex :: ByteString -> ByteString

-- | betweenLinesPS returns the B.ByteString between the two lines given,
--   or Nothing if they do not appear.
betweenLinesPS :: ByteString -> ByteString -> ByteString -> Maybe ByteString
breakAfterNthNewline :: Int -> ByteString -> Maybe (ByteString, ByteString)
breakBeforeNthNewline :: Int -> ByteString -> (ByteString, ByteString)

-- | <i>O(n)</i> The <a>intercalate</a> function takes a <a>ByteString</a>
--   and a list of <a>ByteString</a>s and concatenates the list after
--   interspersing the first argument between each element of the list.
intercalate :: ByteString -> [ByteString] -> ByteString

-- | Test if a ByteString is made of ascii characters
isAscii :: ByteString -> Bool

-- | Decode a ByteString to a String according to the current locale
--   unsafePerformIO in the locale function is ratified by the fact that
--   GHC 6.12 and above also supply locale conversion with functions with a
--   pure type. Unrecognized byte sequences in the input are skipped.
decodeLocale :: ByteString -> String

-- | Encode a String to a ByteString according to the current locale
encodeLocale :: String -> ByteString

-- | Take a <a>String</a> that represents byte values and re-decode it
--   acording to the current locale. Note: we globally enforce char8 as the
--   default encoding, see <a>Main</a> and <a>Darcs.Utils</a>. This means
--   we get command line args and environment variables as <a>String</a>s
--   with char8 encoding, too. So we need this to convert such strings back
--   to the user's encoding.
decodeString :: String -> IO String


-- | This module defines our parsing monad. In the past there have been
--   lazy and strict parsers in this module. Currently we have only the
--   strict variant and it is used for parsing patch files.
module Darcs.Patch.ReadMonads
class (Functor m, Applicative m, Alternative m, Monad m, MonadPlus m) => ParserM m
parse :: ParserM m => m a -> ByteString -> Maybe (a, ByteString)

-- | Takes exactly <tt>n</tt> bytes, or fails.
take :: ParserM m => Int -> m ByteString

-- | <a>parseStrictly</a> applies the parser functions to a string and
--   checks that each parser produced a result as it goes. The strictness
--   is in the <a>ParserM</a> instance for <a>SM</a>.
parseStrictly :: SM a -> ByteString -> Maybe (a, ByteString)

-- | Accepts only the specified character. Consumes a character, if
--   available.
char :: ParserM m => Char -> m ()

-- | Parse an integer and return it. Skips leading whitespaces and | uses
--   the efficient ByteString readInt.
int :: ParserM m => m Int

-- | If <tt>p</tt> fails it returns <tt>x</tt>, otherwise it returns the
--   result of <tt>p</tt>.
option :: Alternative f => a -> f a -> f a

-- | Attempts each option until one succeeds.
choice :: Alternative f => [f a] -> f a

-- | Discards spaces until a non-space character is encountered. Always
--   succeeds.
skipSpace :: ParserM m => m ()

-- | Discards any characters as long as <tt>p</tt> returns True. Always |
--   succeeds.
skipWhile :: ParserM m => (Char -> Bool) -> m ()

-- | Only succeeds if the characters in the input exactly match
--   <tt>str</tt>.
string :: ParserM m => ByteString -> m ()

-- | <a>lexChar</a> checks if the next space delimited token from the input
--   stream matches a specific <a>Char</a>. Uses <a>Maybe</a> inside
--   <a>ParserM</a> to handle failed matches, so that it always returns ()
--   on success.
lexChar :: ParserM m => Char -> m ()

-- | <a>lexString</a> fetches the next whitespace delimited token from from
--   the input and checks if it matches the <tt>ByteString</tt> input. Uses
--   <a>Maybe</a> inside <a>ParserM</a> to handle failed matches, so that
--   it always returns () on success.
lexString :: ParserM m => ByteString -> m ()

-- | <a>lexEof</a> looks for optional spaces followed by the end of input.
--   Uses <a>Maybe</a> inside <a>ParserM</a> to handle failed matches, so
--   that it always returns () on success.
lexEof :: ParserM m => m ()

-- | Equivalent to <tt>takeTill (==c)</tt>, except that it is optimized for
--   | the equality case.
takeTillChar :: ParserM m => Char -> m ByteString

-- | Like <a>myLex</a> except that it is in ParserM
myLex' :: ParserM m => m ByteString

-- | Accepts the next character and returns it. Only fails at end of input.
anyChar :: ParserM m => m Char

-- | Only succeeds at end of input, consumes no characters.
endOfInput :: ParserM m => m ()

-- | Takes characters while <tt>p</tt> returns True. Always succeeds.
takeTill :: ParserM m => (Char -> Bool) -> m ByteString

-- | Ensure that a parser consumes input when producing a result Causes the
--   initial state of the input stream to be held on to while the parser
--   runs, so use with caution.
checkConsumes :: ParserM m => m a -> m a

-- | This is a highly optimized way to read lines that start with a
--   particular character. To implement this efficiently we need access to
--   the parser's internal state. If this is implemented in terms of the
--   other primitives for the parser it requires us to consume one
--   character at a time. That leads to <tt>(&gt;&gt;=)</tt> wasting
--   significant time.
linesStartingWith :: ParserM m => Char -> m [ByteString]

-- | This is a highly optimized way to read lines that start with a
--   particular character, and stops when it reaches a particular |
--   character. See <a>linesStartingWith</a> for details on why this |
--   defined here as a primitive.
linesStartingWithEndingWith :: ParserM m => Char -> Char -> m [ByteString]
instance Alternative SM
instance Applicative SM
instance Functor SM
instance MonadPlus SM
instance ParserM SM
instance Monad SM


module Darcs.Util.Crypt.SHA1
sha1PS :: ByteString -> SHA1
data SHA1
SHA1 :: !Word32 -> !Word32 -> !Word32 -> !Word32 -> !Word32 -> SHA1
showAsHex :: Word32 -> String
instance Eq SHA1
instance Ord SHA1
instance Binary SHA1
instance Show SHA1


-- | A <a>Document</a> is at heart <a>ShowS</a> from the prelude
--   
--   Essentially, if you give a Doc a string it'll print out whatever it
--   wants followed by that string. So <tt>text "foo"</tt> makes the Doc
--   that prints <tt>"foo"</tt> followed by its argument. The combinator
--   names are taken from <a>HughesPJ</a>, although the behaviour of the
--   two libraries is slightly different.
--   
--   The advantage of Printer over simple string appending/concatenating is
--   that the appends end up associating to the right, e.g.:
--   
--   <pre>
--     (text "foo" &lt;&gt; text "bar") &lt;&gt; (text "baz" &lt;&gt; text "quux") ""
--   = \s -&gt; (text "foo" &lt;&gt; text "bar") ((text "baz" &lt;&gt; text "quux") s) ""
--   = (text "foo" &lt;&gt; text "bar") ((text "baz" &lt;&gt; text "quux") "")
--   = (\s -&gt; (text "foo") (text "bar" s)) ((text "baz" &lt;&gt; text "quux") "")
--   = text "foo" (text "bar" ((text "baz" &lt;&gt; text "quux") ""))
--   = (\s -&gt; "foo" ++ s) (text "bar" ((text "baz" &lt;&gt; text "quux") ""))
--   = "foo" ++ (text "bar" ((text "baz" &lt;&gt; text "quux") ""))
--   = "foo" ++ ("bar" ++ ((text "baz" &lt;&gt; text "quux") ""))
--   = "foo" ++ ("bar" ++ ((\s -&gt; text "baz" (text "quux" s)) ""))
--   = "foo" ++ ("bar" ++ (text "baz" (text "quux" "")))
--   = "foo" ++ ("bar" ++ ("baz" ++ (text "quux" "")))
--   = "foo" ++ ("bar" ++ ("baz" ++ ("quux" ++ "")))
--   </pre>
--   
--   The Empty alternative comes in because you want
--   
--   <pre>
--   text "a" $$ vcat xs $$ text "b"
--   </pre>
--   
--   <a>$$</a> means above, <a>vcat</a> is the list version of <a>$$</a>
--   (to be <tt>"a\nb"</tt> when <tt>xs</tt> is <tt>[]</tt>), but without
--   the concept of an Empty Document each <tt>$$</tt> would add a
--   <tt>'\n'</tt> and you'd end up with <tt>"a\n\nb"</tt>. Note that
--   <tt>Empty /= text ""</tt> (the latter would cause two <tt>'\\n'</tt>).
--   
--   This code was made generic in the element type by Juliusz Chroboczek.
module Darcs.Util.Printer

-- | A <a>Printable</a> is either a String, a packed string, or a chunk of
--   text with both representations.
data Printable
S :: !String -> Printable
PS :: !ByteString -> Printable
Both :: !String -> !ByteString -> Printable

-- | a <a>Doc</a> is a bit of enriched text. <a>Doc</a>s get concatanated
--   using <a>&lt;&gt;</a>, which is right-associative.
newtype Doc
Doc :: (St -> Document) -> Doc
unDoc :: Doc -> St -> Document
type Printers = Handle -> Printers'

-- | A set of printers to print different types of text to a handle.
data Printers'
Printers :: !(Color -> Printer) -> !Printer -> !Printer -> !Printer -> !Printer -> !(Color -> Doc -> Doc) -> !([Printable] -> [Printable]) -> Printers'
colorP :: Printers' -> !(Color -> Printer)
invisibleP :: Printers' -> !Printer
hiddenP :: Printers' -> !Printer
userchunkP :: Printers' -> !Printer
defP :: Printers' -> !Printer
lineColorT :: Printers' -> !(Color -> Doc -> Doc)
lineColorS :: Printers' -> !([Printable] -> [Printable])
type Printer = Printable -> St -> Document
data Color
Blue :: Color
Red :: Color
Green :: Color
Cyan :: Color
Magenta :: Color

-- | Used when rendering a <a>Doc</a> to indicate if the result should be
--   encoded to the current locale or left alone. In practice this only
--   affects output when a relevant DARCS_DONT_ESCAPE_XXX option is set
--   (see Darcs.Util.Printer.Color) If in doubt, choose <a>Standard</a>.
data RenderMode

-- | Encode Strings with the current locale. At present ByteStrings are
--   assumed to be in UTF8 and are left alone, so will be mis-encoded in
--   non-UTF8 locales.
Encode :: RenderMode

-- | Don't encode.
Standard :: RenderMode

-- | <tt>hputDoc</tt> puts a doc on the given handle using
--   <a>simplePrinters</a>
hPutDoc :: RenderMode -> Handle -> Doc -> IO ()
hPutDocLn :: RenderMode -> Handle -> Doc -> IO ()

-- | <a>putDoc</a> puts a doc on stdout using the simple printer
--   <a>simplePrinters</a>.
putDoc :: Doc -> IO ()

-- | <a>putDocLn</a> puts a doc, followed by a newline on stdout using
--   <a>simplePrinters</a>
putDocLn :: Doc -> IO ()

-- | <tt>hputDocWith</tt> puts a doc on the given handle using the given
--   printer.
hPutDocWith :: Printers -> RenderMode -> Handle -> Doc -> IO ()

-- | <tt>hputDocLnWith</tt> puts a doc, followed by a newline on the given
--   handle using the given printer.
hPutDocLnWith :: Printers -> RenderMode -> Handle -> Doc -> IO ()

-- | <a>putDocWith</a> puts a doc on stdout using the given printer.
putDocWith :: Printers -> Doc -> IO ()

-- | <a>putDocLnWith</a> puts a doc, followed by a newline on stdout using
--   the given printer.
putDocLnWith :: Printers -> Doc -> IO ()

-- | like <a>hPutDoc</a> but with compress data before writing
hPutDocCompr :: RenderMode -> Handle -> Doc -> IO ()

-- | Write a <a>Doc</a> to stderr if debugging is turned on.
debugDocLn :: Doc -> IO ()

-- | renders a <a>Doc</a> into a <a>String</a> with control codes for the
--   special features of the doc.
renderString :: RenderMode -> Doc -> String

-- | renders a <a>Doc</a> into a <a>String</a> using a given set of
--   printers.
renderStringWith :: Printers' -> RenderMode -> Doc -> String

-- | renders a <a>Doc</a> into <a>ByteString</a> with control codes for the
--   special features of the Doc. See also <tt>readerString</tt>.
renderPS :: RenderMode -> Doc -> ByteString

-- | renders a doc into a <a>ByteString</a> using a given set of printers.
renderPSWith :: Printers' -> RenderMode -> Doc -> ByteString

-- | renders a <a>Doc</a> into a list of <tt>PackedStrings</tt>, one for
--   each line.
renderPSs :: RenderMode -> Doc -> [ByteString]

-- | renders a <a>Doc</a> into a list of <tt>PackedStrings</tt>, one for
--   each chunk of text that was added to the doc, using the given set of
--   printers.
renderPSsWith :: Printers' -> RenderMode -> Doc -> [ByteString]
lineColor :: Color -> Doc -> Doc
prefix :: String -> Doc -> Doc
insertBeforeLastline :: Doc -> Doc -> Doc

-- | <a>colorText</a> creates a <a>Doc</a> containing colored text from a
--   <tt>String</tt>
colorText :: Color -> String -> Doc

-- | <a>invisibleText</a> creates a <a>Doc</a> containing invisible text
--   from a <tt>String</tt>
invisibleText :: String -> Doc
prefixLines :: Doc -> Doc -> Doc

-- | <a>hiddenText</a> creates a <a>Doc</a> containing hidden text from a
--   <tt>String</tt>
hiddenText :: String -> Doc
hiddenPrefix :: String -> Doc -> Doc

-- | <a>userchunk</a> creates a <a>Doc</a> containing a user chunk from a
--   <tt>String</tt>
userchunk :: String -> Doc

-- | <a>text</a> creates a <a>Doc</a> from a <tt>String</tt>, using
--   <a>printable</a>.
text :: String -> Doc

-- | 'printable x' creates a <a>Doc</a> from any <a>Printable</a>.
printable :: Printable -> Doc

-- | <tt><a>wrapText</a> n s</tt> is a <a>Doc</a> representing <tt>s</tt>
--   line-wrapped at <tt>n</tt> characters
wrapText :: Int -> String -> Doc

-- | <a>blueText</a> creates a <a>Doc</a> containing blue text from a
--   <tt>String</tt>
blueText :: String -> Doc

-- | <a>blueText</a> creates a <a>Doc</a> containing blue text from a
--   <tt>String</tt>
redText :: String -> Doc

-- | <a>blueText</a> creates a <a>Doc</a> containing blue text from a
--   <tt>String</tt>
greenText :: String -> Doc

-- | <a>blueText</a> creates a <a>Doc</a> containing blue text from a
--   <tt>String</tt>
magentaText :: String -> Doc

-- | <a>blueText</a> creates a <a>Doc</a> containing blue text from a
--   <tt>String</tt>
cyanText :: String -> Doc

-- | <a>unsafeText</a> creates a <a>Doc</a> from a <a>String</a>, using
--   <a>simplePrinter</a> directly
unsafeText :: String -> Doc

-- | <a>unsafeBoth</a> builds a Doc from a <a>String</a> and a
--   <a>ByteString</a> representing the same text, but does not check that
--   they do.
unsafeBoth :: String -> ByteString -> Doc

-- | <a>unsafeBothText</a> builds a <a>Doc</a> from a <a>String</a>. The
--   string is stored in the Doc as both a String and a <a>ByteString</a>.
unsafeBothText :: String -> Doc

-- | <a>unsafeChar</a> creates a Doc containing just one character.
unsafeChar :: Char -> Doc

-- | <a>invisiblePS</a> creates a <a>Doc</a> with invisible text from a
--   <a>ByteString</a>
invisiblePS :: ByteString -> Doc

-- | <a>packedString</a> builds a <a>Doc</a> from a <a>ByteString</a> using
--   <a>printable</a>
packedString :: ByteString -> Doc

-- | <a>unsafePackedString</a> builds a <a>Doc</a> from a <a>ByteString</a>
--   using <a>simplePrinter</a>
unsafePackedString :: ByteString -> Doc

-- | <a>userchunkPS</a> creates a <a>Doc</a> representing a user chunk from
--   a <a>ByteString</a>.
userchunkPS :: ByteString -> Doc

-- | <a>simplePrinters</a> is a <a>Printers</a> which uses the set
--   'simplePriners\'' on any handle.
simplePrinters :: Printers

-- | <a>invisiblePrinter</a> is the <a>Printer</a> for hidden text. It just
--   replaces the document with <a>empty</a>. It's useful to have a printer
--   that doesn't actually do anything because this allows you to have
--   tunable policies, for example, only printing some text if it's to the
--   terminal, but not if it's to a file or vice-versa.
invisiblePrinter :: Printer

-- | <a>simplePrinter</a> is the simplest <a>Printer</a>: it just
--   concatenates together the pieces of the <a>Doc</a>
simplePrinter :: Printer
doc :: ([Printable] -> [Printable]) -> Doc

-- | The empty <a>Doc</a>.
empty :: Doc

-- | '(&lt;&gt;)' is the concatenation operator for <a>Doc</a>s
(<>) :: Doc -> Doc -> Doc

-- | <tt>a <a>&lt;?&gt;</a> b</tt> is <tt>a &lt;&gt; b</tt> if <tt>a</tt>
--   is not empty, else empty.
(<?>) :: Doc -> Doc -> Doc

-- | <tt>a <a>&lt;+&gt;</a> b</tt> is <tt>a</tt> followed by a space, then
--   <tt>b</tt>.
(<+>) :: Doc -> Doc -> Doc

-- | <tt>a <a>$$</a> b</tt> is <tt>a</tt> above <tt>b</tt>.
($$) :: Doc -> Doc -> Doc

-- | <a>vcat</a> piles vertically a list of <a>Doc</a>s.
vcat :: [Doc] -> Doc

-- | <a>vsep</a> piles vertically a list of <a>Doc</a>s leaving a blank
--   line between each.
vsep :: [Doc] -> Doc

-- | <a>hcat</a> concatenates (horizontally) a list of <a>Doc</a>s
hcat :: [Doc] -> Doc

-- | Minimal <a>Doc</a>s representing the common characters <a>space</a>,
--   <a>newline</a> <a>minus</a>, <a>plus</a>, and <a>backslash</a>.
minus :: Doc

-- | Minimal <a>Doc</a>s representing the common characters <a>space</a>,
--   <a>newline</a> <a>minus</a>, <a>plus</a>, and <a>backslash</a>.
newline :: Doc

-- | Minimal <a>Doc</a>s representing the common characters <a>space</a>,
--   <a>newline</a> <a>minus</a>, <a>plus</a>, and <a>backslash</a>.
plus :: Doc

-- | Minimal <a>Doc</a>s representing the common characters <a>space</a>,
--   <a>newline</a> <a>minus</a>, <a>plus</a>, and <a>backslash</a>.
space :: Doc

-- | Minimal <a>Doc</a>s representing the common characters <a>space</a>,
--   <a>newline</a> <a>minus</a>, <a>plus</a>, and <a>backslash</a>.
backslash :: Doc

-- | <a>lparen</a> is the <a>Doc</a> that represents <tt>"("</tt>
lparen :: Doc

-- | <a>rparen</a> is the <a>Doc</a> that represents <tt>")"</tt>
rparen :: Doc

-- | <tt><a>parens</a> doc</tt> returns a <a>Doc</a> with the content of
--   <tt>doc</tt> put within a pair of parenthesis.
parens :: Doc -> Doc
errorDoc :: Doc -> a
instance IsString Doc

module Darcs.Util.Bug
_bug :: BugStuff -> String -> a
_bugDoc :: BugStuff -> Doc -> a
_impossible :: BugStuff -> a
_fromJust :: BugStuff -> Maybe a -> a


-- | Path resolving:
--   
--   <ul>
--   <li>An http URL contains the sequence <tt>"http(s)://"</tt>.<ul><li>A
--   local filepath does not contain colons, except as second character
--   (windows drives) when this filepath is meant to be used as repository
--   name</li><li>A path that is neither an http URL nor a local file is an
--   ssh-path.</li></ul></li>
--   </ul>
--   
--   Examples:
--   
--   <pre>
--   /usr/repo/foo                 -- local file
--   c:/src/darcs                  -- local file
--   http://darcs.net/             -- URL
--   peter@host:/path              -- ssh
--   droundy@host:                 -- ssh
--   host:/path                    -- ssh
--   </pre>
--   
--   This means that single-letter hosts in ssh-paths do not work, unless a
--   username is provided.
--   
--   Perhaps ssh-paths should use <tt>"ssh://user@host/path"</tt>-syntax
--   instead?
module Darcs.Util.URL
isValidLocalPath :: String -> Bool
isHttpUrl :: String -> Bool
isSshUrl :: String -> Bool
isRelative :: String -> Bool
isAbsolute :: String -> Bool
isSshNopath :: String -> Bool
data SshFilePath
sshRepo :: SshFilePath -> String
sshUhost :: SshFilePath -> String
sshFile :: SshFilePath -> String
urlOf :: SshFilePath -> String

-- | Gives the (user, host, dir) out of an ssh url
splitSshUrl :: String -> SshFilePath


-- | LCS stands for Longest Common Subsequence, and it is a relatively
--   challenging problem to find an LCS efficiently. This module implements
--   the algorithm described in:
--   
--   "An O(ND) Difference Algorithm and its Variations", Eugene Myers,
--   Algorithmica Vol. 1 No. 2, 1986, pp. 251-266; especially the variation
--   described in section 4.2 and most refinements implemented in GNU diff
--   (D is the edit-distance).
--   
--   There is currently no heuristic to reduce the running time and produce
--   suboptimal output for large inputs with many differences. It behaves
--   like GNU diff with the -d option in this regard.
--   
--   In the first step, a hash value for every line is calculated and
--   collisions are marked with a special value. This reduces a string
--   comparison to an int comparison for line tuples where at least one of
--   the hash values is not equal to the special value. After that, lines
--   which only exists in one of the files are removed and marked as
--   changed which reduces the running time of the following difference
--   algorithm. GNU diff additionally removes lines that appear very often
--   in the other file in some cases. The last step tries to create longer
--   changed regions and line up deletions in the first file to insertions
--   in the second by shifting changed lines forward and backward.
module Darcs.Util.Diff.Myers

-- | create a list of changes between a and b, each change has the form
--   (starta, lima, startb, limb) which means that a[starta, lima) has to
--   be replaced by b[startb, limb)
getChanges :: [ByteString] -> [ByteString] -> [(Int, [ByteString], [ByteString])]

-- | try to create nicer diffs by shifting around regions of changed lines
shiftBoundaries :: BSTArray s -> BSTArray s -> PArray -> Int -> Int -> ST s ()
initP :: [ByteString] -> PArray
aLen :: IArray a e => a Int e -> Int
type PArray = Array Int ByteString
getSlice :: PArray -> Int -> Int -> [ByteString]

module Darcs.Util.Diff.Patience
getChanges :: [ByteString] -> [ByteString] -> [(Int, [ByteString], [ByteString])]

module Darcs.Util.Diff
getChanges :: DiffAlgorithm -> [ByteString] -> [ByteString] -> [(Int, [ByteString], [ByteString])]
data DiffAlgorithm
PatienceDiff :: DiffAlgorithm
MyersDiff :: DiffAlgorithm
instance Eq DiffAlgorithm
instance Show DiffAlgorithm

module Darcs.Repository.Flags
data Compression
NoCompression :: Compression
GzipCompression :: Compression
data RemoteDarcs
RemoteDarcs :: String -> RemoteDarcs
DefaultRemoteDarcs :: RemoteDarcs
data Reorder
NoReorder :: Reorder
Reorder :: Reorder
data Verbosity
Quiet :: Verbosity
NormalVerbosity :: Verbosity
Verbose :: Verbosity
data UpdateWorking
YesUpdateWorking :: UpdateWorking
NoUpdateWorking :: UpdateWorking
data UseCache
YesUseCache :: UseCache
NoUseCache :: UseCache
data DryRun
YesDryRun :: DryRun
NoDryRun :: DryRun
data UMask
YesUMask :: String -> UMask
NoUMask :: UMask
data LookForAdds
YesLookForAdds :: LookForAdds
NoLookForAdds :: LookForAdds
data LookForReplaces
YesLookForReplaces :: LookForReplaces
NoLookForReplaces :: LookForReplaces
data DiffAlgorithm
PatienceDiff :: DiffAlgorithm
MyersDiff :: DiffAlgorithm
data LookForMoves
YesLookForMoves :: LookForMoves
NoLookForMoves :: LookForMoves
data RunTest
YesRunTest :: RunTest
NoRunTest :: RunTest
data SetScriptsExecutable
YesSetScriptsExecutable :: SetScriptsExecutable
NoSetScriptsExecutable :: SetScriptsExecutable
data LeaveTestDir
YesLeaveTestDir :: LeaveTestDir
NoLeaveTestDir :: LeaveTestDir
data RemoteRepos
RemoteRepos :: [String] -> RemoteRepos
data SetDefault
YesSetDefault :: Bool -> SetDefault
NoSetDefault :: Bool -> SetDefault
data UseIndex
UseIndex :: UseIndex
IgnoreIndex :: UseIndex
data ScanKnown

-- | Just files already known to darcs
ScanKnown :: ScanKnown

-- | All files, i.e. look for new ones
ScanAll :: ScanKnown

-- | All files, even boring ones
ScanBoring :: ScanKnown
data CloneKind

-- | Just copy pristine and inventories
LazyClone :: CloneKind

-- | First do a lazy clone then copy everything
NormalClone :: CloneKind

-- | Same as Normal but omit telling user they can interrumpt
CompleteClone :: CloneKind
data AllowConflicts
NoAllowConflicts :: AllowConflicts
YesAllowConflicts :: AllowConflicts
YesAllowConflictsAndMark :: AllowConflicts
data ExternalMerge
YesExternalMerge :: String -> ExternalMerge
NoExternalMerge :: ExternalMerge
data WorkRepo
WorkRepoDir :: String -> WorkRepo
WorkRepoPossibleURL :: String -> WorkRepo
WorkRepoCurrentDir :: WorkRepo
data WantGuiPause
YesWantGuiPause :: WantGuiPause
NoWantGuiPause :: WantGuiPause
data WithPatchIndex
YesPatchIndex :: WithPatchIndex
NoPatchIndex :: WithPatchIndex
data WithWorkingDir
WithWorkingDir :: WithWorkingDir
NoWorkingDir :: WithWorkingDir
data ForgetParent
YesForgetParent :: ForgetParent
NoForgetParent :: ForgetParent
instance Eq Verbosity
instance Show Verbosity
instance Eq Compression
instance Show Compression
instance Eq WithPatchIndex
instance Show WithPatchIndex
instance Eq RemoteDarcs
instance Show RemoteDarcs
instance Eq Reorder
instance Eq UpdateWorking
instance Show UpdateWorking
instance Eq UseCache
instance Show UseCache
instance Eq DryRun
instance Show DryRun
instance Eq UMask
instance Show UMask
instance Eq LookForAdds
instance Show LookForAdds
instance Eq LookForReplaces
instance Show LookForReplaces
instance Eq LookForMoves
instance Show LookForMoves
instance Eq RunTest
instance Show RunTest
instance Eq SetScriptsExecutable
instance Show SetScriptsExecutable
instance Eq LeaveTestDir
instance Show LeaveTestDir
instance Eq RemoteRepos
instance Show RemoteRepos
instance Eq SetDefault
instance Show SetDefault
instance Eq UseIndex
instance Show UseIndex
instance Eq CloneKind
instance Show CloneKind
instance Eq AllowConflicts
instance Show AllowConflicts
instance Eq ExternalMerge
instance Show ExternalMerge
instance Eq WorkRepo
instance Show WorkRepo
instance Eq WantGuiPause
instance Show WantGuiPause
instance Eq WithWorkingDir
instance Show WithWorkingDir
instance Eq ForgetParent
instance Show ForgetParent

module Darcs.Util.Printer.Color
showDoc :: RenderMode -> Doc -> String
errorDoc :: Doc -> a
traceDoc :: Doc -> a -> a
assertDoc :: Maybe Doc -> a -> a

-- | <tt><a>fancyPrinters</a> h</tt> returns a set of printers suitable for
--   outputting to <tt>h</tt>
fancyPrinters :: Printers
environmentHelpColor :: ([String], [String])
environmentHelpEscape :: ([String], [String])
environmentHelpEscapeWhite :: ([String], [String])

module Darcs.Util.Text
sentence :: Doc -> Doc

-- | Take a list of paragraphs and format them to the given line length,
--   with a blank line between paragraphs.
formatText :: Int -> [String] -> String
formatParas :: Int -> [String] -> [String]

-- | Take a list of words and split it up so that each chunk fits into the
--   specified width when spaces are included. Any words longer than the
--   specified width end up in a chunk of their own.
formatPara :: Int -> [[a]] -> [[[a]]]
chompTrailingNewline :: String -> String
breakCommand :: String -> (String, [String])


module Darcs.Repository.Ssh
copySSH :: RemoteDarcs -> SshFilePath -> FilePath -> IO ()
data SSHCmd
SSH :: SSHCmd
SCP :: SSHCmd
SFTP :: SSHCmd

-- | Return the command and arguments needed to run an ssh command First
--   try the appropriate darcs environment variable and SSH_PORT defaulting
--   to "ssh" and no specified port.
getSSH :: SSHCmd -> IO (String, [String])
environmentHelpSsh :: ([String], [String])
environmentHelpScp :: ([String], [String])
environmentHelpSshPort :: ([String], [String])
remoteDarcs :: RemoteDarcs -> String

module Darcs.UI.Email
makeEmail :: String -> [(String, String)] -> Maybe Doc -> Maybe String -> Doc -> Maybe String -> Doc
readEmail :: ByteString -> ByteString

-- | Formats an e-mail header by encoding any non-ascii characters using
--   UTF-8 and Q-encoding, and folding lines at appropriate points. It
--   doesn't do more than that, so the header name and header value should
--   be well-formatted give or take line length and encoding. So no
--   non-ASCII characters within quoted-string, quoted-pair, or atom; no
--   semantically meaningful signs in names; no non-ASCII characters in the
--   header name; etcetera.
formatHeader :: String -> String -> ByteString

module Darcs.Util.Path

-- | FileName is an abstract type intended to facilitate the input and
--   output of unicode filenames.
data FileName
fp2fn :: FilePath -> FileName
fn2fp :: FileName -> FilePath
fn2ps :: FileName -> ByteString
ps2fn :: ByteString -> FileName
niceps2fn :: ByteString -> FileName
fn2niceps :: FileName -> ByteString
breakOnDir :: FileName -> Maybe (FileName, FileName)

-- | convert a path string into a sequence of directories strings "/", "."
--   and ".." are generally interpreted as expected. Behaviour with too
--   many '..' is to leave them.
--   
--   Examples: Splitting: "aa<i>bb</i>cc" -&gt; ["aa","bb","cc"] Ignoring
--   "." and extra "/": "aa<i>.</i>bb" -&gt; ["aa","bb"] "aa//bb" -&gt;
--   ["aa","bb"] "<i>aa</i>bb/" -&gt; ["aa","bb"] Handling "..":
--   "aa<i>..</i>bb/cc" -&gt; ["bb","cc"] "aa<i>bb</i>..<i>..</i>cc" -&gt;
--   ["cc"] "aa<i>..</i>bb<i>..</i>cc" -&gt; ["cc"] "../cc" -&gt;
--   ["..","cc"]
normPath :: FileName -> FileName
ownName :: FileName -> FileName
superName :: FileName -> FileName
movedirfilename :: FileName -> FileName -> FileName -> FileName

-- | <a>encodeWhite</a> translates whitespace in filenames to a
--   darcs-specific format (numerical representation according to
--   <a>ord</a> surrounded by backslashes). Note that backslashes are also
--   escaped since they are used in the encoding.
--   
--   <pre>
--   encodeWhite "hello there" == "hello\32\there"
--   encodeWhite "hello\there" == "hello\92\there"
--   </pre>
encodeWhite :: FilePath -> String

-- | <a>decodeWhite</a> interprets the Darcs-specific "encoded" filenames
--   produced by <a>encodeWhite</a>
--   
--   <pre>
--   decodeWhite "hello\32\there"  == "hello there"
--   decodeWhite "hello\92\there"  == "hello\there"
--   decodeWhite "hello\there"   == error "malformed filename"
--   </pre>
decodeWhite :: String -> FilePath
isParentOrEqOf :: FileName -> FileName -> Bool
data AbsolutePath

-- | Take an absolute path and a string representing a (possibly relative)
--   path and combine them into an absolute path. If the second argument is
--   already absolute, then the first argument gets ignored. This function
--   also takes care that the result is converted to Posix convention and
--   normalized. Also, parent directories ("..") at the front of the string
--   argument get canceled out against trailing directory parts of the
--   absolute path argument.
--   
--   Regarding the last point, someone more familiar with how these
--   functions are used should verify that this is indeed necessary or at
--   least useful.
makeAbsolute :: AbsolutePath -> FilePath -> AbsolutePath

-- | Interpret a possibly relative path wrt the current working directory.
ioAbsolute :: FilePath -> IO AbsolutePath

-- | The root directory as an absolute path.
rootDirectory :: AbsolutePath

-- | This is for situations where a string (e.g. a command line argument)
--   may take the value "-" to mean stdin or stdout (which one depends on
--   context) instead of a normal file path.
data AbsolutePathOrStd
makeAbsoluteOrStd :: AbsolutePath -> String -> AbsolutePathOrStd
ioAbsoluteOrStd :: String -> IO AbsolutePathOrStd

-- | Execute either the first or the second argument action, depending on
--   whether the given path is an <a>AbsolutePath</a> or stdin/stdout.
useAbsoluteOrStd :: (AbsolutePath -> a) -> a -> AbsolutePathOrStd -> a
stdOut :: AbsolutePathOrStd
data AbsoluteOrRemotePath
ioAbsoluteOrRemote :: String -> IO AbsoluteOrRemotePath
isRemote :: AbsoluteOrRemotePath -> Bool

-- | Paths which are relative to the local darcs repository and normalized.
--   Note: These are understood not to have the dot in front.
data SubPath

-- | Make the second path relative to the first, if possible
makeSubPathOf :: AbsolutePath -> AbsolutePath -> Maybe SubPath
simpleSubPath :: FilePath -> Maybe SubPath
isSubPathOf :: SubPath -> SubPath -> Bool

-- | Transform a SubPath into an AnchoredPath.
floatSubPath :: SubPath -> AnchoredPath
sp2fn :: SubPath -> FileName
class FilePathOrURL a
toPath :: FilePathOrURL a => a -> String
class FilePathOrURL a => FilePathLike a
toFilePath :: FilePathLike a => a -> FilePath
getCurrentDirectory :: IO AbsolutePath
setCurrentDirectory :: FilePathLike p => p -> IO ()

-- | Iteratively tries find first non-existing path generated by buildName,
--   it feeds to buildName the number starting with -1. When it generates
--   non-existing path and it isn't first, it displays the message created
--   with buildMsg. Usually used for generation of the name like
--   <a>path</a>_<a>number</a> when <a>path</a> already exist (e.g.
--   darcs.net_0).
getUniquePathName :: Bool -> (FilePath -> String) -> (Int -> FilePath) -> IO FilePath
doesPathExist :: FilePath -> IO Bool

-- | What is a malicious path?
--   
--   A spoofed path is a malicious path.
--   
--   <ol>
--   <li>Darcs only creates explicitly relative paths (beginning with
--   <tt>"./"</tt>), so any not explicitly relative path is surely
--   spoofed.</li>
--   <li>Darcs normalizes paths so they never contain <tt>"/../"</tt>, so
--   paths with <tt>"/../"</tt> are surely spoofed.</li>
--   </ol>
--   
--   A path to a darcs repository's meta data can modify "trusted" patches
--   or change safety defaults in that repository, so we check for paths
--   containing <tt>"/_darcs/"</tt> which is the entry to darcs meta data.
--   
--   To do?
--   
--   <ul>
--   <li>How about get repositories?</li>
--   <li>Would it be worth adding a --semi-safe-paths option for allowing
--   changes to certain preference files (_darcs/prefs/) in sub
--   repositories'?</li>
--   </ul>
isMaliciousPath :: String -> Bool

-- | Warning : this is less rigorous than isMaliciousPath but it's to allow
--   for subpath representations that don't start with ./
isMaliciousSubPath :: String -> Bool

-- | Same as <tt>filterPath</tt>, but for ordinary <a>FilePath</a>s (as
--   opposed to AnchoredPath).
filterFilePaths :: [FilePath] -> AnchoredPath -> t -> Bool

-- | Construct a filter from a list of AnchoredPaths, that will accept any
--   path that is either a parent or a child of any of the listed paths,
--   and discard everything else.
filterPaths :: [AnchoredPath] -> AnchoredPath -> t -> Bool
instance Eq FileName
instance Ord FileName
instance Eq SubPath
instance Ord SubPath
instance Eq AbsolutePath
instance Ord AbsolutePath
instance Eq AbsolutePathOrStd
instance Ord AbsolutePathOrStd
instance Eq AbsoluteOrRemotePath
instance Ord AbsoluteOrRemotePath
instance Show AbsoluteOrRemotePath
instance Show AbsolutePathOrStd
instance Show SubPath
instance Show AbsolutePath
instance CharLike c => FilePathLike [c]
instance CharLike Char
instance FilePathLike SubPath
instance FilePathLike AbsolutePath
instance FilePathLike FileName
instance FilePathOrURL FileName
instance FilePathOrURL AbsoluteOrRemotePath
instance CharLike c => FilePathOrURL [c]
instance FilePathOrURL SubPath
instance FilePathOrURL AbsolutePath
instance Binary FileName
instance Show FileName

module Darcs.Patch.SummaryData
data SummDetail
SummAddDir :: FileName -> SummDetail
SummRmDir :: FileName -> SummDetail
SummFile :: SummOp -> FileName -> Int -> Int -> Int -> SummDetail
SummMv :: FileName -> FileName -> SummDetail
SummNone :: SummDetail
data SummOp
SummAdd :: SummOp
SummRm :: SummOp
SummMod :: SummOp
instance Ord SummOp
instance Eq SummOp
instance Ord SummDetail
instance Eq SummDetail

module Darcs.Util.File
getFileStatus :: FilePath -> IO (Maybe FileStatus)
withCurrentDirectory :: FilePathLike p => p -> IO a -> IO a
doesDirectoryReallyExist :: FilePath -> IO Bool
removeFileMayNotExist :: FilePathLike p => p -> IO ()

-- | xdgCacheDir returns the $XDG_CACHE_HOME environment variable, or
--   <tt>~/.cache</tt> if undefined. See the FreeDesktop specification:
--   <a>http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html</a>
xdgCacheDir :: IO (Maybe FilePath)

-- | osxCacheDir assumes <tt>~<i>Library</i>Caches/</tt> exists.
osxCacheDir :: IO (Maybe FilePath)

-- | <tt><a>getDirectoryContents</a> dir</tt> returns a list of <i>all</i>
--   entries in <i>dir</i>.
--   
--   The operation may fail with:
--   
--   <ul>
--   <li><tt>HardwareFault</tt> A physical I/O error has occurred.
--   <tt>[EIO]</tt></li>
--   <li><tt>InvalidArgument</tt> The operand is not a valid directory
--   name. <tt>[ENAMETOOLONG, ELOOP]</tt></li>
--   <li><a>isDoesNotExistError</a> / <tt>NoSuchThing</tt> The directory
--   does not exist. <tt>[ENOENT, ENOTDIR]</tt></li>
--   <li><a>isPermissionError</a> / <tt>PermissionDenied</tt> The process
--   has insufficient privileges to perform the operation.
--   <tt>[EACCES]</tt></li>
--   <li><tt>ResourceExhausted</tt> Insufficient resources are available to
--   perform the operation. <tt>[EMFILE, ENFILE]</tt></li>
--   <li><a>InappropriateType</a> The path refers to an existing
--   non-directory object. <tt>[ENOTDIR]</tt></li>
--   </ul>
getDirectoryContents :: FilePath -> IO [FilePath]

-- | getRecursiveContents returns all files under topdir that aren't
--   directories.
getRecursiveContents :: FilePath -> IO [FilePath]

-- | getRecursiveContentsFullPath returns all files under topdir that
--   aren't directories. Unlike getRecursiveContents this function returns
--   the full path.
getRecursiveContentsFullPath :: FilePath -> IO [FilePath]


module Darcs.Util.Download
copyUrl :: String -> FilePath -> Cachable -> IO ()
copyUrlFirst :: String -> FilePath -> Cachable -> IO ()
setDebugHTTP :: IO ()
disableHTTPPipelining :: IO ()
maxPipelineLength :: IO Int
waitUrl :: String -> IO ()
data Cachable
Cachable :: Cachable
Uncachable :: Cachable
MaxAge :: !CInt -> Cachable
environmentHelpProxy :: ([String], [String])
environmentHelpProxyPassword :: ([String], [String])

-- | Data type to represent a connection error. The following are the codes
--   from libcurl which map to each of the constructors: * 6 -&gt;
--   CouldNotResolveHost : The remote host was not resolved. * 7 -&gt;
--   CouldNotConnectToServer : Failed to connect() to host or proxy. * 28
--   -&gt; OperationTimeout: the specified time-out period was reached.
data ConnectionError
CouldNotResolveHost :: ConnectionError
CouldNotConnectToServer :: ConnectionError
OperationTimeout :: ConnectionError

module Darcs.Repository.Compat
stdoutIsAPipe :: IO Bool
mkStdoutTemp :: String -> IO String
canonFilename :: FilePath -> IO FilePath
maybeRelink :: String -> String -> IO Bool
atomicCreate :: FilePath -> IO ()
sloppyAtomicCreate :: FilePath -> IO ()

module Darcs.Repository.Lock
withLock :: String -> IO a -> IO a

-- | Tries to perform some task if it can obtain the lock, Otherwise, just
--   gives up without doing the task
withLockCanFail :: String -> IO a -> IO (Either () a)
environmentHelpLocks :: ([String], [String])

-- | <a>withTemp</a> safely creates an empty file (not open for writing)
--   and returns its name.
--   
--   The temp file operations are rather similar to the locking operations,
--   in that they both should always try to clean up, so exitWith causes
--   trouble.
withTemp :: (String -> IO a) -> IO a

-- | <a>withOpenTemp</a> creates a temporary file, and opens it. Both of
--   them run their argument and then delete the file. Also, both of them
--   (to my knowledge) are not susceptible to race conditions on the
--   temporary file (as long as you never delete the temporary file; that
--   would reintroduce a race condition).
withOpenTemp :: ((Handle, String) -> IO a) -> IO a
withStdoutTemp :: (String -> IO a) -> IO a

-- | <a>withTempDir</a> creates an empty directory and then removes it when
--   it is no longer needed. withTempDir creates a temporary directory. The
--   location of that directory is determined by the contents of
--   _darcs<i>prefs</i>tmpdir, if it exists, otherwise by
--   <tt>$DARCS_TMPDIR</tt>, and if that doesn't exist then whatever your
--   operating system considers to be a a temporary directory (e.g.
--   <tt>$TMPDIR</tt> under Unix, <tt>$TEMP</tt> under Windows).
--   
--   If none of those exist it creates the temporary directory in the
--   current directory, unless the current directory is under a _darcs
--   directory, in which case the temporary directory in the parent of the
--   highest _darcs directory to avoid accidentally corrupting darcs's
--   internals. This should not fail, but if it does indeed fail, we go
--   ahead and use the current directory anyway. If
--   <tt>$DARCS_KEEP_TMPDIR</tt> variable is set temporary directory is not
--   removed, this can be useful for debugging.
withTempDir :: String -> (AbsolutePath -> IO a) -> IO a

-- | <a>withPermDir</a> is like <a>withTempDir</a>, except that it doesn't
--   delete the directory afterwards.
withPermDir :: String -> (AbsolutePath -> IO a) -> IO a
withDelayedDir :: String -> (AbsolutePath -> IO a) -> IO a
withNamedTemp :: String -> (String -> IO a) -> IO a
writeToFile :: FilePathLike p => p -> (Handle -> IO ()) -> IO ()
appendToFile :: FilePathLike p => p -> (Handle -> IO ()) -> IO ()
writeBinFile :: FilePathLike p => p -> String -> IO ()

-- | Writes a file. Differs from writeBinFile in that it writes the string
--   encoded with the current locale instead of what GHC thinks is right.
writeLocaleFile :: FilePathLike p => p -> String -> IO ()
writeDocBinFile :: FilePathLike p => p -> Doc -> IO ()
appendBinFile :: FilePathLike p => p -> String -> IO ()
appendDocBinFile :: FilePathLike p => p -> Doc -> IO ()
readBinFile :: FilePathLike p => p -> IO String

-- | Reads a file. Differs from readBinFile in that it interprets the file
--   in the current locale instead of as ISO-8859-1.
readLocaleFile :: FilePathLike p => p -> IO String
readDocBinFile :: FilePathLike p => p -> IO Doc
writeAtomicFilePS :: FilePathLike p => p -> ByteString -> IO ()
gzWriteAtomicFilePS :: FilePathLike p => p -> ByteString -> IO ()
gzWriteAtomicFilePSs :: FilePathLike p => p -> [ByteString] -> IO ()
gzWriteDocFile :: FilePathLike p => p -> Doc -> IO ()
rmRecursive :: FilePath -> IO ()
removeFileMayNotExist :: FilePathLike p => p -> IO ()
canonFilename :: FilePath -> IO FilePath
maybeRelink :: String -> String -> IO Bool
worldReadableTemp :: String -> IO String
tempdirLoc :: IO FilePath
environmentHelpTmpdir :: ([String], [String])
environmentHelpKeepTmpdir :: ([String], [String])
addToErrorLoc :: IOException -> String -> IOException

module Darcs.Repository.External
cloneTree :: FilePath -> FilePath -> IO ()
cloneFile :: FilePath -> FilePath -> IO ()

-- | <tt>fetchFile fileOrUrl cache</tt> returns the content of its argument
--   (either a file or an URL). If it has to download an url, then it will
--   use a cache as required by its second argument.
--   
--   We always use default remote darcs, since it is not fatal if the
--   remote darcs does not exist or is too old -- anything that supports
--   transfer-mode should do, and if not, we will fall back to SFTP or SCP.
fetchFilePS :: String -> Cachable -> IO ByteString

-- | <tt>fetchFileLazyPS fileOrUrl cache</tt> lazily reads the content of
--   its argument (either a file or an URL). Warning: this function may
--   constitute a fd leak; make sure to force consumption of file contents
--   to avoid that. See "fetchFilePS" for details.
fetchFileLazyPS :: String -> Cachable -> IO ByteString
gzFetchFilePS :: String -> Cachable -> IO ByteString
speculateFileOrUrl :: String -> FilePath -> IO ()
copyFileOrUrl :: RemoteDarcs -> FilePath -> FilePath -> Cachable -> IO ()
data Cachable
Cachable :: Cachable
Uncachable :: Cachable
MaxAge :: !CInt -> Cachable
backupByRenaming :: FilePath -> IO ()
backupByCopying :: FilePath -> IO ()
environmentHelpProtocols :: ([String], [String])

module Darcs.Repository.Cache

-- | <a>cacheHash</a> computes the cache hash (i.e. filename) of a packed
--   string.
cacheHash :: ByteString -> String
okayHash :: String -> Bool
takeHash :: ByteString -> Maybe (String, ByteString)

-- | Cache is an abstract type for hiding the underlying cache locations
newtype Cache
Ca :: [CacheLoc] -> Cache
data CacheType
Repo :: CacheType
Directory :: CacheType
data CacheLoc
Cache :: !CacheType -> !WritableOrNot -> !String -> CacheLoc
cacheType :: CacheLoc -> !CacheType
cacheWritable :: CacheLoc -> !WritableOrNot
cacheSource :: CacheLoc -> !String
data WritableOrNot
Writable :: WritableOrNot
NotWritable :: WritableOrNot
data HashedDir
HashedPristineDir :: HashedDir
HashedPatchesDir :: HashedDir
HashedInventoriesDir :: HashedDir
hashedDir :: HashedDir -> String
bucketFolder :: String -> String
unionCaches :: Cache -> Cache -> Cache

-- | unionRemoteCaches merges caches. It tries to do better than just
--   blindly copying remote cache entries:
--   
--   <ul>
--   <li>If remote repository is accessed through network, do not copy any
--   cache entries from it. Taking local entries does not make sense and
--   using network entries can lead to darcs hang when it tries to get to
--   unaccessible host.</li>
--   <li>If remote repositoty is local, copy all network cache entries. For
--   local cache entries if the cache directory exists and is writable it
--   is added as writable cache, if it exists but is not writable it is
--   added as read-only cache.</li>
--   </ul>
--   
--   This approach should save us from bogus cache entries. One case it
--   does not work very well is when you fetch from partial repository over
--   network. Hopefully this is not a common case.
unionRemoteCaches :: Cache -> Cache -> String -> IO Cache
cleanCaches :: Cache -> HashedDir -> IO ()
cleanCachesWithHint :: Cache -> HashedDir -> [String] -> IO ()

-- | <tt>fetchFileUsingCache cache dir hash</tt> receives a list of caches
--   <tt>cache</tt>, the directory for which that file belongs <tt>dir</tt>
--   and the <tt>hash</tt> of the file to fetch. It tries to fetch the file
--   from one of the sources, trying them in order one by one. If the file
--   cannot be fetched from any of the sources, this operation fails.
fetchFileUsingCache :: Cache -> HashedDir -> String -> IO (String, ByteString)

-- | <tt>speculateFileUsingCache cache subdirectory name</tt> takes note
--   that the file <tt>name</tt> is likely to be useful soon: pipelined
--   downloads will add it to the (low-priority) queue, for the rest it is
--   a noop.
speculateFileUsingCache :: Cache -> HashedDir -> String -> IO ()

-- | Note that the files are likely to be useful soon: pipelined downloads
--   will add them to the (low-priority) queue, for the rest it is a noop.
speculateFilesUsingCache :: Cache -> HashedDir -> [String] -> IO ()

-- | <tt>writeFileUsingCache cache compression subdir contents</tt> write
--   the string <tt>contents</tt> to the directory subdir, except if it is
--   already in the cache, in which case it is a noop. Warning (?) this
--   means that in case of a hash collision, writing using
--   writeFileUsingCache is a noop. The returned value is the filename that
--   was given to the string.
writeFileUsingCache :: Cache -> Compression -> HashedDir -> ByteString -> IO String

-- | <tt>peekInCache cache subdir hash</tt> tells whether <tt>cache</tt>
--   and contains an object with hash <tt>hash</tt> in a writable position.
--   Florent: why do we want it to be in a writable position?
peekInCache :: Cache -> HashedDir -> String -> IO Bool
repo2cache :: String -> Cache
writable :: CacheLoc -> Bool
isThisRepo :: CacheLoc -> Bool

-- | <tt>hashedFilePath cachelocation subdir hash</tt> returns the physical
--   filename of hash <tt>hash</tt> in the <tt>subdir</tt> section of
--   <tt>cachelocation</tt>.
hashedFilePath :: CacheLoc -> HashedDir -> String -> String
allHashedDirs :: [HashedDir]

-- | Compares two caches, a remote cache is greater than a local one. The
--   order of the comparison is given by: local &lt; http &lt; ssh
compareByLocality :: CacheLoc -> CacheLoc -> Ordering

-- | Prints an error message with a list of bad caches.
reportBadSources :: IO ()
instance Eq WritableOrNot
instance Show WritableOrNot
instance Eq CacheType
instance Show CacheType
instance Eq OrOnlySpeculate
instance Eq FromWhere
instance Show Cache
instance Show CacheLoc
instance Eq CacheLoc

module Darcs.Repository.Format

-- | Representation of the format of a repository. Each sublist corresponds
--   to a line in the format file. Currently all lines are expected to be
--   singleton words.
newtype RepoFormat
RF :: [[RepoProperty]] -> RepoFormat
data RepoProperty
Darcs1 :: RepoProperty
Darcs2 :: RepoProperty
HashedInventory :: RepoProperty
NoWorkingDir :: RepoProperty
RebaseInProgress :: RepoProperty
UnknownFormat :: String -> RepoProperty

-- | Identify the format of the repository at the given location
--   (directory, URL, or SSH path). Fails if we weren't able to identify
--   the format.
identifyRepoFormat :: String -> IO RepoFormat

-- | Identify the format of the repository at the given location
--   (directory, URL, or SSH path). Return <tt><a>Left</a> reason</tt> if
--   it fails, where <tt>reason</tt> explains why we weren't able to
--   identify the format. Note that we do no verification of the format,
--   which is handled by <a>readProblem</a> or <a>writeProblem</a> on the
--   resulting <a>RepoFormat</a>.
tryIdentifyRepoFormat :: String -> IO (Either String RepoFormat)

-- | <tt>createRepoFormat useFormat1 useNoWorkingDir</tt> create a repo
--   format
createRepoFormat :: Bool -> WithWorkingDir -> RepoFormat

-- | Write the repo format to the given file.
writeRepoFormat :: RepoFormat -> FilePath -> IO ()

-- | <tt>writeProblem form</tt> tells if we can write to a repo in format
--   <tt>form</tt>, first checking if we can read that repo It returns
--   <tt>Nothing</tt> if there's no problem writing to such a repository.
writeProblem :: RepoFormat -> Maybe String

-- | <tt><a>readProblem</a> source</tt> returns <a>Just</a> an error
--   message if we cannot read from a repo in format <tt>source</tt>, or
--   <a>Nothing</a> if there's no such problem.
readProblem :: RepoFormat -> Maybe String

-- | <tt><a>transferProblem</a> source target</tt> returns <a>Just</a> an
--   error message if we cannot transfer patches from a repo in format
--   <tt>source</tt> to a repo in format <tt>target</tt>, or <a>Nothing</a>
--   if there are no such problem.
transferProblem :: RepoFormat -> RepoFormat -> Maybe String

-- | Is a given property contained within a given format?
formatHas :: RepoProperty -> RepoFormat -> Bool

-- | Add a single property to an existing format.
addToFormat :: RepoProperty -> RepoFormat -> RepoFormat

-- | Remove a single property from an existing format.
removeFromFormat :: RepoProperty -> RepoFormat -> RepoFormat
instance Eq RepoProperty
instance Show RepoFormat
instance Show RepoProperty

module Darcs.Repository.Prefs
addToPreflist :: String -> String -> IO ()

-- | delete references to other repositories. Used when cloning to a ssh
--   destination. Assume the current working dir is the repository.
deleteSources :: IO ()
getPreflist :: String -> IO [String]
setPreflist :: String -> [String] -> IO ()
getGlobal :: String -> IO [String]
environmentHelpHome :: ([String], [String])
defaultrepo :: RemoteRepos -> AbsolutePath -> [String] -> IO [String]
getDefaultRepoPath :: IO (Maybe String)

-- | addRepoSource adds a new entry to _darcs<i>prefs</i>repos and sets it
--   as default in _darcs<i>prefs</i>defaultrepo, unless --no-set-default
--   or --dry-run is passed, or it is the same repository as the current
--   one.
addRepoSource :: String -> DryRun -> RemoteRepos -> SetDefault -> IO ()
getPrefval :: String -> IO (Maybe String)
setPrefval :: String -> String -> IO ()
changePrefval :: String -> String -> String -> IO ()
defPrefval :: String -> String -> IO String
writeDefaultPrefs :: IO ()

-- | boringRegexps returns a list of the boring regexps, from the local and
--   global prefs/boring files. Any invalid regexps are filtered,
--   preventing an exception in (potentially) pure code, when the regexps
--   are used.
boringRegexps :: IO [Regex]
boringFileFilter :: IO ([FilePath] -> [FilePath])
darcsdirFilter :: [FilePath] -> [FilePath]
data FileType
BinaryFile :: FileType
TextFile :: FileType
filetypeFunction :: IO (FilePath -> FileType)
getCaches :: UseCache -> String -> IO Cache
binariesFileHelp :: [String]
boringFileHelp :: [String]
globalCacheDir :: IO (Maybe FilePath)

-- | The relative path of the global preference directory;
--   <tt>~/.darcs</tt> on Unix, and <tt>%APPDATA%/darcs</tt> on Windows.
--   This is used for online documentation.
globalPrefsDirDoc :: String

-- | The path of the global preference directory; <tt>~/.darcs</tt> on
--   Unix, and <tt>%APPDATA%/darcs</tt> on Windows.
globalPrefsDir :: IO (Maybe FilePath)

-- | oldGlobalCacheDir is the old cache path <tt>~<i>.darcs</i>cache</tt>
--   now ony used with read-only access.
oldGlobalCacheDir :: IO (Maybe FilePath)
instance Eq FileType

module Darcs.Repository.Motd

-- | Fetch and return the message of the day for a given repository.
getMotd :: String -> IO ByteString

-- | Display the message of the day for a given repository,
showMotd :: String -> IO ()


-- | This module should only be imported by Darcs.UI.Options.* and by
--   <a>Flags</a>. Other modules needing access to <a>DarcsFlag</a> should
--   import <a>Flags</a>
module Darcs.UI.Options.Flags

-- | The <a>DarcsFlag</a> type is a list of all flags that can ever be
--   passed to darcs, or to one of its commands.
data DarcsFlag
Version :: DarcsFlag
ExactVersion :: DarcsFlag
ListCommands :: DarcsFlag
Help :: DarcsFlag
ListOptions :: DarcsFlag
NoTest :: DarcsFlag
Test :: DarcsFlag
OnlyChangesToFiles :: DarcsFlag
ChangesToAllFiles :: DarcsFlag
LeaveTestDir :: DarcsFlag
NoLeaveTestDir :: DarcsFlag
Timings :: DarcsFlag
Debug :: DarcsFlag
DebugHTTP :: DarcsFlag
Verbose :: DarcsFlag
NormalVerbosity :: DarcsFlag
Quiet :: DarcsFlag
Target :: String -> DarcsFlag
Cc :: String -> DarcsFlag
Output :: AbsolutePathOrStd -> DarcsFlag
OutputAutoName :: AbsolutePath -> DarcsFlag
Mail :: DarcsFlag
Subject :: String -> DarcsFlag
InReplyTo :: String -> DarcsFlag
Charset :: String -> DarcsFlag
SendmailCmd :: String -> DarcsFlag
Author :: String -> DarcsFlag
SelectAuthor :: DarcsFlag
PatchName :: String -> DarcsFlag
OnePatch :: String -> DarcsFlag
SeveralPatch :: String -> DarcsFlag
OneHash :: String -> DarcsFlag
AfterPatch :: String -> DarcsFlag
UpToPatch :: String -> DarcsFlag
AfterHash :: String -> DarcsFlag
UpToHash :: String -> DarcsFlag
TagName :: String -> DarcsFlag
LastN :: Int -> DarcsFlag
MaxCount :: Int -> DarcsFlag
PatchIndexRange :: Int -> Int -> DarcsFlag
NumberPatches :: DarcsFlag
OneTag :: String -> DarcsFlag
AfterTag :: String -> DarcsFlag
UpToTag :: String -> DarcsFlag
GenContext :: DarcsFlag
Context :: AbsolutePath -> DarcsFlag
Count :: DarcsFlag
LogFile :: AbsolutePath -> DarcsFlag
RmLogFile :: DarcsFlag
DontRmLogFile :: DarcsFlag
DistName :: String -> DarcsFlag
DistZip :: DarcsFlag
All :: DarcsFlag
Recursive :: DarcsFlag
NoRecursive :: DarcsFlag
Minimize :: DarcsFlag
NoMinimize :: DarcsFlag
Reorder :: DarcsFlag
NoReorder :: DarcsFlag
RestrictPaths :: DarcsFlag
DontRestrictPaths :: DarcsFlag
AskDeps :: DarcsFlag
NoAskDeps :: DarcsFlag
IgnoreTimes :: DarcsFlag
DontIgnoreTimes :: DarcsFlag
LookForAdds :: DarcsFlag
NoLookForAdds :: DarcsFlag
LookForMoves :: DarcsFlag
NoLookForMoves :: DarcsFlag
LookForReplaces :: DarcsFlag
NoLookForReplaces :: DarcsFlag
UseMyersDiff :: DarcsFlag
UsePatienceDiff :: DarcsFlag
Intersection :: DarcsFlag
Union :: DarcsFlag
Complement :: DarcsFlag
Sign :: DarcsFlag
SignAs :: String -> DarcsFlag
NoSign :: DarcsFlag
SignSSL :: String -> DarcsFlag
HappyForwarding :: DarcsFlag
NoHappyForwarding :: DarcsFlag
Verify :: AbsolutePath -> DarcsFlag
VerifySSL :: AbsolutePath -> DarcsFlag
RemoteDarcsOpt :: String -> DarcsFlag
EditDescription :: DarcsFlag
NoEditDescription :: DarcsFlag
Toks :: String -> DarcsFlag
EditLongComment :: DarcsFlag
NoEditLongComment :: DarcsFlag
PromptLongComment :: DarcsFlag
KeepDate :: DarcsFlag
NoKeepDate :: DarcsFlag
AllowConflicts :: DarcsFlag
MarkConflicts :: DarcsFlag
NoAllowConflicts :: DarcsFlag
SkipConflicts :: DarcsFlag
Boring :: DarcsFlag
SkipBoring :: DarcsFlag
AllowCaseOnly :: DarcsFlag
DontAllowCaseOnly :: DarcsFlag
AllowWindowsReserved :: DarcsFlag
DontAllowWindowsReserved :: DarcsFlag
DontGrabDeps :: DarcsFlag
DontPromptForDependencies :: DarcsFlag
PromptForDependencies :: DarcsFlag
Compress :: DarcsFlag
NoCompress :: DarcsFlag
UnCompress :: DarcsFlag
WorkRepoDir :: String -> DarcsFlag
WorkRepoUrl :: String -> DarcsFlag
RemoteRepo :: String -> DarcsFlag
NewRepo :: String -> DarcsFlag
NotInRemote :: (Maybe String) -> DarcsFlag
Reply :: String -> DarcsFlag
ApplyAs :: String -> DarcsFlag
MachineReadable :: DarcsFlag
HumanReadable :: DarcsFlag
Pipe :: DarcsFlag
Interactive :: DarcsFlag
DiffCmd :: String -> DarcsFlag
ExternalMerge :: String -> DarcsFlag
Summary :: DarcsFlag
NoSummary :: DarcsFlag
PauseForGui :: DarcsFlag
NoPauseForGui :: DarcsFlag
Unified :: DarcsFlag
NonUnified :: DarcsFlag
Reverse :: DarcsFlag
Forward :: DarcsFlag
Complete :: DarcsFlag
Lazy :: DarcsFlag
DiffFlags :: String -> DarcsFlag
XMLOutput :: DarcsFlag
ForceReplace :: DarcsFlag
OnePattern :: String -> DarcsFlag
SeveralPattern :: String -> DarcsFlag
AfterPattern :: String -> DarcsFlag
UpToPattern :: String -> DarcsFlag
NonApply :: DarcsFlag
NonVerify :: DarcsFlag
NonForce :: DarcsFlag
DryRun :: DarcsFlag
SetDefault :: DarcsFlag
NoSetDefault :: DarcsFlag
Disable :: DarcsFlag
SetScriptsExecutable :: DarcsFlag
DontSetScriptsExecutable :: DarcsFlag
Once :: DarcsFlag
Linear :: DarcsFlag
Backoff :: DarcsFlag
Bisect :: DarcsFlag
Hashed :: DarcsFlag
UseFormat1 :: DarcsFlag
UseFormat2 :: DarcsFlag
UseNoWorkingDir :: DarcsFlag
UseWorkingDir :: DarcsFlag
Sibling :: AbsolutePath -> DarcsFlag
Files :: DarcsFlag
NoFiles :: DarcsFlag
Directories :: DarcsFlag
NoDirectories :: DarcsFlag
Pending :: DarcsFlag
NoPending :: DarcsFlag
PosthookCmd :: String -> DarcsFlag
NoPosthook :: DarcsFlag
AskPosthook :: DarcsFlag
RunPosthook :: DarcsFlag
PrehookCmd :: String -> DarcsFlag
NoPrehook :: DarcsFlag
AskPrehook :: DarcsFlag
RunPrehook :: DarcsFlag
UMask :: String -> DarcsFlag
StoreInMemory :: DarcsFlag
ApplyOnDisk :: DarcsFlag
NoHTTPPipelining :: DarcsFlag
Packs :: DarcsFlag
NoPacks :: DarcsFlag
NoCache :: DarcsFlag
AllowUnrelatedRepos :: DarcsFlag
Check :: DarcsFlag
Repair :: DarcsFlag
JustThisRepo :: DarcsFlag
ReadMarks :: String -> DarcsFlag
WriteMarks :: String -> DarcsFlag
NullFlag :: DarcsFlag
NoAmendUnrecord :: DarcsFlag
AmendUnrecord :: DarcsFlag
PatchIndexFlag :: DarcsFlag
NoPatchIndexFlag :: DarcsFlag
instance Eq DarcsFlag
instance Show DarcsFlag


-- | Constructing <a>OptSpec</a>s and <a>OptDescr</a>s
module Darcs.UI.Options.Util

-- | This type synonym is here for brevity and because we want to import
--   the data constructors (but not the type) of <a>DarcsFlag</a>
--   qualified.
type Flag = DarcsFlag

-- | This is <a>PrimOptSpec</a> instantiated with 'DarcsOptDescr and
--   <a>Flag</a>.
type PrimDarcsOption v = forall a. PrimOptSpec DarcsOptDescr Flag a v

-- | We do not instantiate the <tt>d</tt> in <tt><a>OptSpec</a> d f</tt>
--   directly with <a>OptDescr</a>. Instead we (post-) compose it with
--   <tt>(-&gt;) <a>AbsolutePath</a></tt>. Modulo newtype noise, this is
--   the same as
--   
--   <pre>
--   type 'DarcsOptDescr f = <a>OptDescr</a> (<a>AbsolutePath</a> -&gt; f)
--   </pre>
--   
--   This is so we can pass a directory relative to which an option
--   argument is interpreted (if it has the form of a relative path).
type DarcsOptDescr = Compose OptDescr ((->) AbsolutePath)

-- | Construct an 'DarcsOptDescr with no arguments.
noArg :: [Char] -> [String] -> f -> String -> DarcsOptDescr f

-- | Construct an 'DarcsOptDescr with a <a>String</a> argument.
strArg :: SingleArgOptDescr String f

-- | Construct an 'DarcsOptDescr with an optional <a>String</a> argument.
optStrArg :: SingleArgOptDescr (Maybe String) f

-- | Construct an 'DarcsOptDescr with an <a>AbsolutePath</a> argument.
absPathArg :: SingleArgOptDescr AbsolutePath f

-- | Construct an 'DarcsOptDescr with an <a>AbsolutePathOrStd</a> argument.
absPathOrStdArg :: SingleArgOptDescr AbsolutePathOrStd f

-- | Construct an 'DarcsOptDescr with an optional <a>AbsolutePath</a>
--   argument.
optAbsPathArg :: [Char] -> [String] -> String -> (AbsolutePath -> f) -> String -> String -> DarcsOptDescr f

-- | The raw material from which multi-valued options are built. See
--   <a>withDefault</a>.
data RawOptSpec f v
RawNoArg :: [Char] -> [String] -> f -> v -> String -> RawOptSpec f v
RawStrArg :: [Char] -> [String] -> (String -> f) -> (f -> [String]) -> (String -> v) -> (v -> [String]) -> String -> String -> RawOptSpec f v
RawAbsPathArg :: [Char] -> [String] -> (AbsolutePath -> f) -> (f -> [AbsolutePath]) -> (AbsolutePath -> v) -> (v -> [AbsolutePath]) -> String -> String -> RawOptSpec f v
RawAbsPathOrStdArg :: [Char] -> [String] -> (AbsolutePathOrStd -> f) -> (f -> [AbsolutePathOrStd]) -> (AbsolutePathOrStd -> v) -> (v -> [AbsolutePathOrStd]) -> String -> String -> RawOptSpec f v
RawOptAbsPathArg :: [Char] -> [String] -> (AbsolutePath -> f) -> (f -> [AbsolutePath]) -> (AbsolutePath -> v) -> (v -> [AbsolutePath]) -> String -> String -> String -> RawOptSpec f v

-- | Construct a <a>PrimDarcsOption</a> from a default value and a list of
--   <a>RawOptSpec</a>.
--   
--   Precondition: the list must have an entry for each possible value
--   (type <tt>v</tt>).
withDefault :: Eq v => v -> [RawOptSpec Flag v] -> PrimDarcsOption v

-- | Construct a <a>Bool</a> valued option with a single flag that takes no
--   arguments and has no default flag.
--   
--   The arguments are: short switches, long switches, flag value, help
--   string.
singleNoArg :: [Char] -> [String] -> Flag -> String -> PrimDarcsOption Bool

-- | Construct a <tt><a>Maybe</a> <a>String</a></tt> valued option with a
--   single flag that takes a <a>String</a> argument and has no default
--   flag.
--   
--   The arguments are: short switches, long switches, flag constructor,
--   single flag parser, help string.
singleStrArg :: [Char] -> [String] -> (String -> Flag) -> (Flag -> Maybe String) -> String -> String -> PrimDarcsOption (Maybe String)

-- | Similar to <a>singleStrArg</a>, except that the flag can be given more
--   than once. The flag arguments are collected in a list of
--   <a>String</a>s.
multiStrArg :: [Char] -> [String] -> (String -> Flag) -> ([Flag] -> [String]) -> String -> String -> PrimDarcsOption [String]

-- | Similar to <a>multiStrArg</a>, except that the flag arguments are
--   optional.
multiOptStrArg :: [Char] -> [String] -> (Maybe String -> Flag) -> ([Flag] -> [Maybe String]) -> String -> String -> PrimDarcsOption [Maybe String]

-- | Construct a <tt><a>Maybe</a> <a>AbsolutePath</a></tt> valued option
--   with a single flag that takes an <a>AbsolutePath</a> argument and has
--   no default flag.
--   
--   The arguments are: short switches, long switches, flag constructor,
--   single flag parser, help string.
singleAbsPathArg :: [Char] -> [String] -> (AbsolutePath -> Flag) -> (Flag -> Maybe AbsolutePath) -> String -> String -> PrimDarcsOption (Maybe AbsolutePath)

-- | Similar to <a>singleAbsPathArg</a>, except that the flag can be given
--   more than once. The flag arguments are collected in a list of
--   <a>AbsolutePath</a>s.
multiAbsPathArg :: [Char] -> [String] -> (AbsolutePath -> Flag) -> ([Flag] -> [AbsolutePath]) -> String -> String -> PrimDarcsOption [AbsolutePath]

-- | A deprecated option. If you want to deprecate only some flags and not
--   the whole option, extract the <a>RawOptSpec</a>s out of the original
--   option and create a new deprecated option. The strings in the first
--   argument are appended to the automatically generated error message in
--   case additional hints should be provided.
deprecated :: [String] -> [RawOptSpec Flag v] -> PrimDarcsOption ()
data AbsolutePath

-- | This is for situations where a string (e.g. a command line argument)
--   may take the value "-" to mean stdin or stdout (which one depends on
--   context) instead of a normal file path.
data AbsolutePathOrStd

-- | Take an absolute path and a string representing a (possibly relative)
--   path and combine them into an absolute path. If the second argument is
--   already absolute, then the first argument gets ignored. This function
--   also takes care that the result is converted to Posix convention and
--   normalized. Also, parent directories ("..") at the front of the string
--   argument get canceled out against trailing directory parts of the
--   absolute path argument.
--   
--   Regarding the last point, someone more familiar with how these
--   functions are used should verify that this is indeed necessary or at
--   least useful.
makeAbsolute :: AbsolutePath -> FilePath -> AbsolutePath
makeAbsoluteOrStd :: AbsolutePath -> String -> AbsolutePathOrStd
instance IsoFunctor (RawOptSpec f)

module Darcs.UI.Options.Markdown
optionsMarkdown :: [DarcsOptDescr f] -> String

module Darcs.Patch.Witnesses.Ordered

-- | Directed Forward Pairs
data (:>) a1 a2 wX wY
(:>) :: (a1 wX wZ) -> (a2 wZ wY) -> (:>) a1 a2 wX wY

-- | Directed Reverse Pairs
data (:<) a1 a2 wX wY
(:<) :: (a1 wZ wY) -> (a2 wX wZ) -> (:<) a1 a2 wX wY

-- | Forward lists
data FL a wX wZ
(:>:) :: a wX wY -> FL a wY wZ -> FL a wX wZ
NilFL :: FL a wX wX

-- | Reverse lists
data RL a wX wZ
(:<:) :: a wY wZ -> RL a wX wY -> RL a wX wZ
NilRL :: RL a wX wX

-- | Forking Pairs (Implicit starting context)
data (:\/:) a1 a2 wX wY
(:\/:) :: (a1 wZ wX) -> (a2 wZ wY) -> (:\/:) a1 a2 wX wY

-- | Joining Pairs
data (:/\:) a3 a4 wX wY
(:/\:) :: (a3 wX wZ) -> (a4 wY wZ) -> (:/\:) a3 a4 wX wY

-- | Parallel Pairs
data (:||:) a1 a2 wX wY
(:||:) :: (a1 wX wY) -> (a2 wX wY) -> (:||:) a1 a2 wX wY

-- | Forking Pair (Explicit starting context)
--   
--   <pre>
--   wX     wY       
--    \     /    
--     \   /
--      \ /     
--       wU
--       |
--       |
--       |
--       wA
--   </pre>
data Fork common left right wA wX wY
Fork :: (common wA wU) -> (left wU wX) -> (right wU wY) -> Fork common left right wA wX wY
lengthFL :: FL a wX wZ -> Int
mapFL :: (forall wW wZ. a wW wZ -> b) -> FL a wX wY -> [b]
mapFL_FL :: (forall wW wY. a wW wY -> b wW wY) -> FL a wX wZ -> FL b wX wZ
spanFL :: (forall wW wY. a wW wY -> Bool) -> FL a wX wZ -> (FL a :> FL a) wX wZ
foldlFL :: (forall wW wY. a -> b wW wY -> a) -> a -> FL b wX wZ -> a
allFL :: (forall wX wY. a wX wY -> Bool) -> FL a wW wZ -> Bool
anyFL :: (forall wX wY. a wX wY -> Bool) -> FL a wW wZ -> Bool
filterFL :: (forall wX wY. a wX wY -> Bool) -> FL a wW wZ -> [Sealed2 a]
splitAtFL :: Int -> FL a wX wZ -> (FL a :> FL a) wX wZ
splitAtRL :: Int -> RL a wX wZ -> (RL a :< RL a) wX wZ
bunchFL :: Int -> FL a wX wY -> FL (FL a) wX wY
foldlRL :: (forall wW wY. a -> b wW wY -> a) -> a -> RL b wX wZ -> a
lengthRL :: RL a wX wZ -> Int
isShorterThanRL :: RL a wX wY -> Int -> Bool
mapRL :: (forall wW wZ. a wW wZ -> b) -> RL a wX wY -> [b]
mapRL_RL :: (forall wW wY. a wW wY -> b wW wY) -> RL a wX wZ -> RL b wX wZ
zipWithFL :: (forall wX wY. a -> p wX wY -> q wX wY) -> [a] -> FL p wW wZ -> FL q wW wZ

-- | <tt>filterOutFLFL p xs</tt> deletes any <tt>x</tt> in <tt>xs</tt> for
--   which <tt>p x == IsEq</tt> (indicating that <tt>x</tt> has no effect
--   as far as we are concerned, and can be safely removed from the chain)
filterOutFLFL :: (forall wX wY. p wX wY -> EqCheck wX wY) -> FL p wW wZ -> FL p wW wZ
filterOutRLRL :: (forall wX wY. p wX wY -> EqCheck wX wY) -> RL p wW wZ -> RL p wW wZ
filterRL :: (forall wX wY. p wX wY -> Bool) -> RL p wA wB -> [Sealed2 p]
reverseFL :: FL a wX wZ -> RL a wX wZ
reverseRL :: RL a wX wZ -> FL a wX wZ
(+>+) :: FL a wX wY -> FL a wY wZ -> FL a wX wZ
(+<+) :: RL a wY wZ -> RL a wX wY -> RL a wX wZ
nullFL :: FL a wX wZ -> Bool
concatFL :: FL (FL a) wX wZ -> FL a wX wZ
concatRL :: RL (RL a) wX wZ -> RL a wX wZ
consRLSealed :: a wY wZ -> FlippedSeal (RL a) wY -> FlippedSeal (RL a) wZ
nullRL :: RL a wX wZ -> Bool
toFL :: [FreeLeft a] -> Sealed (FL a wX)
dropWhileFL :: (forall wX wY. a wX wY -> Bool) -> FL a wR wV -> FlippedSeal (FL a) wV
dropWhileRL :: (forall wX wY. a wX wY -> Bool) -> RL a wR wV -> Sealed (RL a wR)
spanFL_M :: Monad m => (forall wW wY. a wW wY -> m Bool) -> FL a wX wZ -> m ((FL a :> FL a) wX wZ)
mapFL_FL_M :: Monad m => (forall wW wY. a wW wY -> m (b wW wY)) -> FL a wX wZ -> m (FL b wX wZ)

-- | Check that two <a>FL</a>s are equal element by element. This differs
--   from the <a>MyEq</a> instance for <a>FL</a> which uses commutation.
eqFL :: MyEq a => FL a wX wY -> FL a wX wZ -> EqCheck wY wZ
eqFLRev :: MyEq a => FL a wX wZ -> FL a wY wZ -> EqCheck wX wY
eqFLUnsafe :: MyEq a => FL a wX wY -> FL a wZ wW -> Bool
instance (Show2 a, Show2 b) => Show2 (a :/\: b)
instance (Show2 a, Show2 b) => Show ((:/\:) a b wX wY)
instance (Show2 a, Show2 b) => Show2 (a :\/: b)
instance (Show2 a, Show2 b) => Show ((:\/:) a b wX wY)
instance (Show2 a, Show2 b) => Show2 (a :> b)
instance (MyEq a, MyEq b) => Eq ((:<) a b wX wY)
instance (MyEq a, MyEq b) => MyEq (a :< b)
instance (MyEq a, MyEq b) => Eq ((:>) a b wX wY)
instance (MyEq a, MyEq b) => MyEq (a :> b)
instance (Show2 a, Show2 b) => Show ((:>) a b wX wY)
instance (Show2 a, Show2 b) => Show1 ((:>) a b wX)
instance Show2 a => Show2 (RL a)
instance Show2 a => Show1 (RL a wX)
instance Show2 a => Show (RL a wX wZ)
instance Show2 a => Show2 (FL a)
instance Show2 a => Show1 (FL a wX)
instance Show2 a => Show (FL a wX wZ)

module Darcs.Patch.Bracketed

-- | This type exists for legacy support of on-disk format patch formats.
--   It is a wrapper type that explicitly tracks the nesting of braces and
--   parens in the on-disk representation of such patches. It is used as an
--   intermediate form when reading such patches normally, and also for
--   round-tripping such patches when checking the hash in bundles. It
--   shouldn't be used for anything else.
data Bracketed p wX wY
Singleton :: p wX wY -> Bracketed p wX wY
Braced :: BracketedFL p wX wY -> Bracketed p wX wY
Parens :: BracketedFL p wX wY -> Bracketed p wX wY
mapBracketed :: (forall wA wB. p wA wB -> q wA wB) -> Bracketed p wX wY -> Bracketed q wX wY
unBracketed :: Bracketed p wX wY -> FL p wX wY
type BracketedFL p wX wY = FL (Bracketed p) wX wY
mapBracketedFLFL :: (forall wA wB. p wA wB -> q wA wB) -> BracketedFL p wX wY -> BracketedFL q wX wY
unBracketedFL :: BracketedFL p wX wY -> FL p wX wY
instance PatchListFormat (Bracketed p)

module Darcs.Patch.CommuteFn

-- | CommuteFn is the basis of a general framework for building up
--   commutation operations between different patch types in a generic
--   manner. Unfortunately type classes are not well suited to the problem
--   because of the multiple possible routes by which the commuter for (FL
--   p1, FL p2) can be built out of the commuter for (p1, p2) - and more
--   complicated problems when we start building multiple constructors on
--   top of each other. The type class resolution machinery really can't
--   cope with selecting some route, because it doesn't know that all
--   possible routes should be equivalent.
type CommuteFn p1 p2 = forall wX wY. (p1 :> p2) wX wY -> Maybe ((p2 :> p1) wX wY)
commuterIdFL :: CommuteFn p1 p2 -> CommuteFn p1 (FL p2)
commuterFLId :: CommuteFn p1 p2 -> CommuteFn (FL p1) p2
commuterIdRL :: CommuteFn p1 p2 -> CommuteFn p1 (RL p2)
commuterRLId :: CommuteFn p1 p2 -> CommuteFn (RL p1) p2
type MergeFn p1 p2 = forall wX wY. (p1 :\/: p2) wX wY -> (p2 :/\: p1) wX wY
mergerIdFL :: MergeFn p1 p2 -> MergeFn p1 (FL p2)
type TotalCommuteFn p1 p2 = forall wX wY. (p1 :> p2) wX wY -> (p2 :> p1) wX wY
totalCommuterIdFL :: TotalCommuteFn p1 p2 -> TotalCommuteFn p1 (FL p2)
totalCommuterFLId :: TotalCommuteFn p1 p2 -> TotalCommuteFn (FL p1) p2
totalCommuterFLFL :: TotalCommuteFn p1 p2 -> TotalCommuteFn (FL p1) (FL p2)

module Darcs.Patch.Inspect
class PatchInspect p
listTouchedFiles :: PatchInspect p => p wX wY -> [FilePath]
hunkMatches :: PatchInspect p => (ByteString -> Bool) -> p wX wY -> Bool
instance PatchInspect p => PatchInspect (RL p)
instance PatchInspect p => PatchInspect (FL p)

module Darcs.Patch.Debug

-- | PatchDebug is a hook class for temporarily adding debug information.
--   To use it, add any methods that are required, implement those methods
--   where needed, and then make it available in the relevant contexts. For
--   example it can be temporarily added as a superclass of
--   <tt>Patchy</tt>. The advantage of having it here already is that
--   everything is (or should be) declared as an instance of it, so you can
--   use defaulting or just leave out declarations of instance methods and
--   code will still compile.
class PatchDebug p where patchDebugDummy _ = ()
patchDebugDummy :: PatchDebug p => p wX wY -> ()
instance PatchDebug p => PatchDebug (RL p)
instance PatchDebug p => PatchDebug (FL p)

module Darcs.Patch.MaybeInternal
newtype InternalChecker p
InternalChecker :: (forall wX wY. p wX wY -> EqCheck wX wY) -> InternalChecker p
isInternal :: InternalChecker p -> forall wX wY. p wX wY -> EqCheck wX wY

-- | Provides a hook for flagging whether a patch is "internal" to the repo
--   and therefore shouldn't be referred to externally, e.g. by inclusion
--   in tags. Note that despite the name, every patch type has to implement
--   it, but for normal (non-internal) types the default implementation is
--   fine. Currently only used for rebase internal patches.
class MaybeInternal p where patchInternalChecker = Nothing
patchInternalChecker :: MaybeInternal p => Maybe (InternalChecker (FL p))
flIsInternal :: MaybeInternal p => FL p wX wY -> EqCheck wX wY

module Darcs.Patch.Witnesses.WZipper
data FZipper a wX wZ
FZipper :: RL a wX wY -> FL a wY wZ -> FZipper a wX wZ
focus :: FZipper a wX wY -> Maybe (Sealed2 a)
leftmost :: FZipper p wX wY -> Bool
left :: FZipper p wX wY -> FZipper p wX wY
rightmost :: FZipper p wX wY -> Bool
right :: FZipper p wX wY -> FZipper p wX wY

-- | See <a>clowns</a>
jokers :: FZipper a wX wY -> FlippedSeal (FL a) wY

-- | "Clowns to the left of me, jokers to the right. Here I am, stuck in
--   the middle of you"
--   <a>http://en.wikipedia.org/wiki/Stuck_in_the_Middle</a>
clowns :: FZipper a wX wY -> Sealed ((RL a) wX)
flToZipper :: FL a wX wY -> FZipper a wX wY
lengthFZ :: FZipper a wX wY -> Int
nullFZ :: FZipper a wX wY -> Bool
toEnd :: FZipper p wX wY -> FZipper p wX wY
toStart :: FZipper p wX wY -> FZipper p wX wY

module Darcs.Patch.Info

-- | A PatchInfo value contains the metadata of a patch. The date, name,
--   author and log fields are UTF-8 encoded text in darcs 2.4 and later,
--   and just sequences of bytes (decoded with whatever is the locale when
--   displayed) in earlier darcs.
--   
--   The members with names that start with '_' are not supposed to be used
--   directly in code that does not care how the patch info is stored.
data PatchInfo
PatchInfo :: !ByteString -> !ByteString -> !ByteString -> ![ByteString] -> !Bool -> PatchInfo
_piDate :: PatchInfo -> !ByteString
_piName :: PatchInfo -> !ByteString
_piAuthor :: PatchInfo -> !ByteString
_piLog :: PatchInfo -> ![ByteString]
isInverted :: PatchInfo -> !Bool

-- | <tt>patchinfo date name author log</tt> constructs a new
--   <a>PatchInfo</a> value with the given details, automatically assigning
--   an Ignore-this header to guarantee the patch is unique. The function
--   does not verify the date string's sanity.
patchinfo :: String -> String -> String -> [String] -> IO PatchInfo
invertName :: PatchInfo -> PatchInfo
rawPatchInfo :: String -> String -> String -> [String] -> Bool -> PatchInfo

-- | addJunk adds a line that contains a random number to make the patch
--   unique.
addJunk :: PatchInfo -> IO PatchInfo

-- | Hash on patch metadata (patch name, author, date, log, and "inverted"
--   flag. Robust against context changes but does not garantee patch
--   contents. Usually used as matcher or patch identifier (see
--   Darcs.Patch.Match).
makePatchname :: PatchInfo -> SHA1

-- | This makes darcs-1 (non-hashed repos) filenames, and is also generally
--   used in both in hashed and non-hashed repo code for making patch
--   "hashes".
--   
--   The name consists of three segments:
--   
--   <ul>
--   <li>timestamp (ISO8601-compatible yyyymmmddHHMMSS, UTC)</li>
--   <li>SHA1 hash of the author</li>
--   <li>SHA1 hash of the patch name, author, date, log, and "inverted"
--   flag.</li>
--   </ul>
makeFilename :: PatchInfo -> String

-- | Parser for <a>PatchInfo</a> as stored in patch bundles and inventory
--   files, for example:
--   
--   <pre>
--   [Document the foo interface
--   John Doe &lt;john.doe@example.com&gt;**20110615084241
--    Ignore-this: 85b94f67d377c4ab671101266ef9c229
--    Nobody knows what a 'foo' is, so describe it.
--   ]
--   </pre>
--   
--   See <a>showPatchInfo</a> for the inverse operation.
readPatchInfo :: ParserM m => m PatchInfo

-- | Get the name, including an "UNDO: " prefix if the patch is inverted.
justName :: PatchInfo -> String

-- | Returns the author of a patch.
justAuthor :: PatchInfo -> String
justLog :: PatchInfo -> String
showPatchInfoUI :: PatchInfo -> Doc
toXml :: PatchInfo -> Doc
piDate :: PatchInfo -> CalendarTime
setPiDate :: String -> PatchInfo -> PatchInfo
piDateString :: PatchInfo -> String
piDateBytestring :: PatchInfo -> ByteString

-- | Returns the name of the patch. Unlike <a>justName</a>, it does not
--   preprend "UNDO: " to the name if the patch is inverted.
piName :: PatchInfo -> String
piRename :: PatchInfo -> String -> PatchInfo

-- | Returns the author of a patch.
piAuthor :: PatchInfo -> String

-- | Get the tag name, if the patch is a tag patch.
piTag :: PatchInfo -> Maybe String

-- | Get the log message of a patch.
piLog :: PatchInfo -> [String]

-- | Patch is stored between square brackets.
--   
--   <pre>
--   [ &lt;patch name&gt;
--   &lt;patch author&gt;*&lt;patch date&gt;
--    &lt;patch log (may be empty)&gt; (indented one)
--    &lt;can have multiple lines in patch log,&gt;
--    &lt;as long as they're preceded by a space&gt;
--    &lt;and don't end with a square bracket.&gt;
--   ]
--   </pre>
--   
--   note that below I assume the name has no newline in it. See
--   <a>readPatchInfo</a> for the inverse operation.
showPatchInfo :: PatchInfo -> Doc
isTag :: PatchInfo -> Bool
readPatchInfos :: ByteString -> [PatchInfo]
escapeXML :: String -> Doc
instance Eq PatchInfo
instance Ord PatchInfo
instance Show PatchInfo

module Darcs.Patch.Index.Types

-- | The FileId for a file consists of the FilePath (creation name) and an
--   index. The index denotes how many files with the same name have been
--   added before (and subsequently deleted or moved)
data FileId
FileId :: FileName -> Int -> FileId
cname :: FileId -> FileName
count :: FileId -> Int

-- | Parse FileId from a string
parseFileId :: String -> FileId

-- | Convert FileId to string
showFileId :: FileId -> String

-- | The PatchId identifies a patch and can be created from a PatchInfo
--   with makePatchname
newtype PatchId
PID :: SHA1 -> PatchId
patchId :: PatchId -> SHA1
pid2string :: PatchId -> String

-- | describes a filepath that is interpreted relative to a certain point
--   in the history of the repository. The point is given by Just pid which
--   denotes the history up to (including) pid or Nothing which denotes the
--   history including the last patch
data DatedFilePath
DatedFilePath :: FilePath -> (Maybe PatchId) -> DatedFilePath

-- | This is used to track changes to files
data PatchMod a
PTouch :: a -> PatchMod a
PCreateFile :: a -> PatchMod a
PCreateDir :: a -> PatchMod a
PRename :: a -> a -> PatchMod a
PRemove :: a -> PatchMod a

-- | This is an invalid patch e.g. there is a patch 'Move Autoconf.lhs
--   Autoconf.lhs.in' where there is no Autoconf.lhs in the darcs repo
PInvalid :: a -> PatchMod a

-- | this is used for duplicate patches that don't have any effect, but we
--   still want to keep track of them
PDuplicateTouch :: a -> PatchMod a
makePatchID :: PatchInfo -> PatchId
short :: PatchId -> Word32
instance Eq FileId
instance Show FileId
instance Ord FileId
instance Show PatchId
instance Ord PatchId
instance Eq PatchId
instance Show a => Show (PatchMod a)
instance Eq a => Eq (PatchMod a)
instance Functor PatchMod
instance Binary PatchId
instance Binary FileId


-- | The abstract representation of a Tree and useful abstract utilities to
--   handle those.
module Storage.Hashed.Tree

-- | Abstraction of a filesystem tree. Please note that the Tree returned
--   by the respective read operations will have TreeStub items in it. To
--   obtain a Tree without such stubs, call expand on it, eg.:
--   
--   <pre>
--   tree &lt;- readDarcsPristine "." &gt;&gt;= expand
--   </pre>
--   
--   When a Tree is expanded, it becomes "final". All stubs are forced and
--   the Tree can be traversed purely. Access to actual file contents stays
--   in IO though.
--   
--   A Tree may have a Hash associated with it. A pair of Tree's is
--   identical whenever their hashes are (the reverse need not hold, since
--   not all Trees come equipped with a hash).
data Tree m
data Blob m
Blob :: !(m ByteString) -> !Hash -> Blob m
data TreeItem m
File :: !(Blob m) -> TreeItem m
SubTree :: !(Tree m) -> TreeItem m
Stub :: !(m (Tree m)) -> !Hash -> TreeItem m
data ItemType
TreeType :: ItemType
BlobType :: ItemType
data Hash
SHA256 :: !ByteString -> Hash
SHA1 :: !ByteString -> Hash
NoHash :: Hash
makeTree :: Monad m => [(Name, TreeItem m)] -> Tree m
makeTreeWithHash :: Monad m => [(Name, TreeItem m)] -> Hash -> Tree m
emptyTree :: Monad m => Tree m
emptyBlob :: Monad m => Blob m
makeBlob :: Monad m => ByteString -> Blob m
makeBlobBS :: Monad m => ByteString -> Blob m
expandUpdate :: Monad m => (AnchoredPath -> Tree m -> m (Tree m)) -> Tree m -> m (Tree m)

-- | Expand a stubbed Tree into a one with no stubs in it. You might want
--   to filter the tree before expanding to save IO. This is the basic
--   implementation, which may be overriden by some Tree instances (this is
--   especially true of the Index case).
expand :: Monad m => Tree m -> m (Tree m)

-- | Unfold a path in a (stubbed) Tree, such that the leaf node of the path
--   is reachable without crossing any stubs. Moreover, the leaf ought not
--   be a Stub in the resulting Tree. A non-existent path is expanded as
--   far as it can be.
expandPath :: Monad m => Tree m -> AnchoredPath -> m (Tree m)

-- | Check the disk version of a Tree: expands it, and checks each hash.
--   Returns either the expanded tree or a list of AnchoredPaths where
--   there are problems. The first argument is the hashing function used to
--   create the tree.
checkExpand :: (TreeItem IO -> IO Hash) -> Tree IO -> IO (Either [(AnchoredPath, Hash, Maybe Hash)] (Tree IO))
items :: Tree m -> (Map Name (TreeItem m))

-- | List all contents of a <a>Tree</a>.
list :: Tree m -> [(AnchoredPath, TreeItem m)]
listImmediate :: Tree m -> [(Name, TreeItem m)]

-- | Get hash of a Tree. This is guaranteed to uniquely identify the Tree
--   (including any blob content), as far as cryptographic hashes are
--   concerned. Sha256 is recommended.
treeHash :: Tree m -> Hash

-- | Look up a <a>Tree</a> item (an immediate subtree or blob).
lookup :: Tree m -> Name -> Maybe (TreeItem m)

-- | Find a <a>TreeItem</a> by its path. Gives <a>Nothing</a> if the path
--   is invalid.
find :: Tree m -> AnchoredPath -> Maybe (TreeItem m)

-- | Find a <a>Blob</a> by its path. Gives <a>Nothing</a> if the path is
--   invalid, or does not point to a Blob.
findFile :: Tree m -> AnchoredPath -> Maybe (Blob m)

-- | Find a <a>Tree</a> by its path. Gives <a>Nothing</a> if the path is
--   invalid, or does not point to a Tree.
findTree :: Tree m -> AnchoredPath -> Maybe (Tree m)

-- | Get a hash of a TreeItem. May be Nothing.
itemHash :: TreeItem m -> Hash
itemType :: TreeItem m -> ItemType

-- | For every pair of corresponding blobs from the two supplied trees,
--   evaluate the supplied function and accumulate the results in a list.
--   Hint: to get IO actions through, just use sequence on the resulting
--   list. NB. This won't expand any stubs.
zipCommonFiles :: (AnchoredPath -> Blob m -> Blob m -> a) -> Tree m -> Tree m -> [a]

-- | For each file in each of the two supplied trees, evaluate the supplied
--   function (supplying the corresponding file from the other tree, or
--   Nothing) and accumulate the results in a list. Hint: to get IO actions
--   through, just use sequence on the resulting list. NB. This won't
--   expand any stubs.
zipFiles :: (AnchoredPath -> Maybe (Blob m) -> Maybe (Blob m) -> a) -> Tree m -> Tree m -> [a]
zipTrees :: (AnchoredPath -> Maybe (TreeItem m) -> Maybe (TreeItem m) -> a) -> Tree m -> Tree m -> [a]

-- | Cautiously extracts differing subtrees from a pair of Trees. It will
--   never do any unneccessary expanding. Tree hashes are used to cut the
--   comparison as high up the Tree branches as possible. The result is a
--   pair of trees that do not share any identical subtrees. They are
--   derived from the first and second parameters respectively and they are
--   always fully expanded. It might be advantageous to feed the result
--   into <a>zipFiles</a> or <a>zipTrees</a>.
diffTrees :: (Functor m, Monad m) => Tree m -> Tree m -> m (Tree m, Tree m)

-- | Read a Blob into a Lazy ByteString. Might be backed by an mmap, use
--   with care.
readBlob :: Blob m -> m ByteString
class Monad m => FilterTree a m
filter :: FilterTree a m => (AnchoredPath -> TreeItem m -> Bool) -> a m -> a m

-- | Given two Trees, a <tt>guide</tt> and a <tt>tree</tt>, produces a new
--   Tree that is a identical to <tt>tree</tt>, but only has those items
--   that are present in both <tt>tree</tt> and <tt>guide</tt>. The
--   <tt>guide</tt> Tree may not contain any stubs.
restrict :: (FilterTree t m, Monad n) => Tree n -> t m -> t m

-- | Modify a Tree (by replacing, or removing or adding items).
modifyTree :: Monad m => Tree m -> AnchoredPath -> Maybe (TreeItem m) -> Tree m

-- | Does <i>not</i> expand the tree.
updateTree :: (Functor m, Monad m) => (TreeItem m -> m (TreeItem m)) -> Tree m -> m (Tree m)

-- | Does <i>not</i> expand the tree.
partiallyUpdateTree :: (Functor m, Monad m) => (TreeItem m -> m (TreeItem m)) -> (AnchoredPath -> TreeItem m -> Bool) -> Tree m -> m (Tree m)
updateSubtrees :: (Tree m -> Tree m) -> Tree m -> Tree m

-- | Lay one tree over another. The resulting Tree will look like the base
--   (1st parameter) Tree, although any items also present in the overlay
--   Tree will be taken from the overlay. It is not allowed to overlay a
--   different kind of an object, nor it is allowed for the overlay to add
--   new objects to base. This means that the overlay Tree should be a
--   subset of the base Tree (although any extraneous items will be ignored
--   by the implementation).
overlay :: (Functor m, Monad m) => Tree m -> Tree m -> Tree m
addMissingHashes :: (Monad m, Functor m) => (TreeItem m -> m Hash) -> Tree m -> m (Tree m)
instance Show ItemType
instance Eq ItemType
instance Ord ItemType
instance Monad m => FilterTree Tree m


-- | An experimental monadic interface to Tree mutation. The main idea is
--   to simulate IO-ish manipulation of real filesystem (that's the state
--   part of the monad), and to keep memory usage down by reasonably often
--   dumping the intermediate data to disk and forgetting it. The monad
--   interface itself is generic, and a number of actual implementations
--   can be used. This module provides just <a>virtualTreeIO</a> that never
--   writes any changes, but may trigger filesystem reads as appropriate.
module Storage.Hashed.Monad
virtualTreeIO :: TreeIO a -> Tree IO -> IO (a, Tree IO)

-- | Run a TreeIO action without storing any changes. This is useful for
--   running monadic tree mutations for obtaining the resulting Tree (as
--   opposed to their effect of writing a modified tree to disk). The
--   actions can do both read and write -- reads are passed through to the
--   actual filesystem, but the writes are held in memory in a form of
--   modified Tree.
virtualTreeMonad :: (Functor m, Monad m) => TreeMonad m a -> Tree m -> m (a, Tree m)
tree :: TreeState m -> (Tree m)

-- | Internal state of the <a>TreeIO</a> monad. Keeps track of the current
--   Tree content, unsync'd changes and a current working directory (of the
--   monad).
data TreeState m

-- | A <a>TreeIO</a> monad. A sort of like IO but it keeps a
--   <a>TreeState</a> around as well, which is a sort of virtual
--   filesystem. Depending on how you obtained your <a>TreeIO</a>, the
--   actions in your virtual filesystem get somehow reflected in the actual
--   real filesystem. For <a>virtualTreeIO</a>, nothing happens in real
--   filesystem, however with <tt>plainTreeIO</tt>, the plain tree will be
--   updated every now and then, and with <tt>hashedTreeIO</tt> a
--   darcs-style hashed tree will get updated.
type TreeMonad m = RWST AnchoredPath () (TreeState m) m
type TreeIO = TreeMonad IO
runTreeMonad :: (Functor m, Monad m) => TreeMonad m a -> TreeState m -> m (a, Tree m)
initialState :: Tree m -> (TreeItem m -> m Hash) -> (AnchoredPath -> TreeItem m -> TreeMonad m (TreeItem m)) -> TreeState m

-- | Replace an item with a new version without modifying the content of
--   the tree. This does not do any change tracking. Ought to be only used
--   from a <tt>sync</tt> implementation for a particular storage format.
--   The presumed use-case is that an existing in-memory Blob is replaced
--   with a one referring to an on-disk file.
replaceItem :: (Functor m, Monad m) => AnchoredPath -> Maybe (TreeItem m) -> TreeMonad m ()
findM :: (Monad m, Functor m) => Tree m -> AnchoredPath -> m (Maybe (TreeItem m))
findFileM :: (Monad m, Functor m) => Tree m -> AnchoredPath -> m (Maybe (Blob m))
findTreeM :: (Monad m, Functor m) => Tree m -> AnchoredPath -> m (Maybe (Tree m))
class (Functor m, Monad m) => TreeRO m
currentDirectory :: TreeRO m => m AnchoredPath
withDirectory :: TreeRO m => AnchoredPath -> m a -> m a
readFile :: TreeRO m => AnchoredPath -> m ByteString
exists :: TreeRO m => AnchoredPath -> m Bool
directoryExists :: TreeRO m => AnchoredPath -> m Bool
fileExists :: TreeRO m => AnchoredPath -> m Bool
class TreeRO m => TreeRW m
writeFile :: TreeRW m => AnchoredPath -> ByteString -> m ()
createDirectory :: TreeRW m => AnchoredPath -> m ()
unlink :: TreeRW m => AnchoredPath -> m ()
rename :: TreeRW m => AnchoredPath -> AnchoredPath -> m ()
copy :: TreeRW m => AnchoredPath -> AnchoredPath -> m ()
instance (Functor m, Monad m) => TreeRW (TreeMonad m)
instance (Functor m, Monad m) => TreeRO (TreeMonad m)

module Darcs.Patch.MonadProgress
class Monad m => MonadProgress m
runProgressActions :: MonadProgress m => String -> [ProgressAction m ()] -> m ()

-- | a monadic action, annotated with a progress message that could be
--   printed out while running the action, and a message that could be
--   printed out on error. Actually printing out these messages is optional
--   to allow non-IO monads to just run the action.
data ProgressAction m a
ProgressAction :: m a -> Doc -> Doc -> ProgressAction m a
paAction :: ProgressAction m a -> m a
paMessage :: ProgressAction m a -> Doc
paOnError :: ProgressAction m a -> Doc

-- | run a list of <a>ProgressAction</a>s without any feedback messages
silentlyRunProgressActions :: Monad m => String -> [ProgressAction m ()] -> m ()
instance (Functor m, Monad m) => MonadProgress (TreeMonad m)

module Darcs.Patch.ApplyMonad
class (Functor m, Monad m, Functor (ApplyMonadBase m), Monad (ApplyMonadBase m), ToTree state) => ApplyMonad m (state :: (* -> *) -> *) where type family ApplyMonadBase m :: * -> * mReadFilePSs f = linesPS `fmap` mReadFilePS f mCreateFile f = mModifyFilePS f $ \ _ -> return empty mModifyFilePSs f j = mModifyFilePS f (fmap unlinesPS . j . linesPS) mChangePref _ _ _ = return ()
nestedApply :: ApplyMonad m state => m x -> state (ApplyMonadBase m) -> m (x, state (ApplyMonadBase m))
liftApply :: ApplyMonad m state => (state (ApplyMonadBase m) -> (ApplyMonadBase m) x) -> state (ApplyMonadBase m) -> m (x, state (ApplyMonadBase m))
getApplyState :: ApplyMonad m state => m (state (ApplyMonadBase m))
putApplyState :: ApplyMonad m state => state m -> m ()
editFile :: (ApplyMonad m state, state ~ ObjectMap) => UUID -> (ByteString -> ByteString) -> m ()
editDirectory :: (ApplyMonad m state, state ~ ObjectMap) => UUID -> (DirContent -> DirContent) -> m ()
mDoesDirectoryExist :: (ApplyMonad m state, state ~ Tree) => FileName -> m Bool
mDoesFileExist :: (ApplyMonad m state, state ~ Tree) => FileName -> m Bool
mReadFilePS :: (ApplyMonad m state, state ~ Tree) => FileName -> m ByteString
mReadFilePSs :: (ApplyMonad m state, state ~ Tree) => FileName -> m [ByteString]
mCreateDirectory :: (ApplyMonad m state, state ~ Tree) => FileName -> m ()
mRemoveDirectory :: (ApplyMonad m state, state ~ Tree) => FileName -> m ()
mCreateFile :: (ApplyMonad m state, state ~ Tree) => FileName -> m ()
mRemoveFile :: (ApplyMonad m state, state ~ Tree) => FileName -> m ()
mRename :: (ApplyMonad m state, state ~ Tree) => FileName -> FileName -> m ()
mModifyFilePS :: (ApplyMonad m state, state ~ Tree) => FileName -> (ByteString -> m ByteString) -> m ()
mModifyFilePSs :: (ApplyMonad m state, state ~ Tree) => FileName -> ([ByteString] -> m [ByteString]) -> m ()
mChangePref :: (ApplyMonad m state, state ~ Tree) => String -> String -> String -> m ()
class (Functor m, Monad m, ApplyMonad (ApplyMonadOver m state) state) => ApplyMonadTrans m (state :: (* -> *) -> *) where type family ApplyMonadOver m state :: * -> *
runApplyMonad :: ApplyMonadTrans m state => (ApplyMonadOver m state) x -> state m -> m (x, state m)

-- | withFileNames takes a maybe list of existing rename-pairs, a list of
--   filenames and an action, and returns the resulting triple of affected
--   files, updated filename list and new rename details. If the
--   rename-pairs are not present, a new list is generated from the
--   filesnames.
withFileNames :: Maybe [OrigFileNameOf] -> [FileName] -> FilePathMonad a -> FilePathMonadState
withFiles :: [(FileName, ByteString)] -> RestrictedApply a -> [(FileName, ByteString)]
class ToTree s
toTree :: ToTree s => s m -> Tree m
instance MonadProgress RestrictedApply
instance ApplyMonad RestrictedApply Tree
instance MonadProgress FilePathMonad
instance ApplyMonad FilePathMonad Tree
instance (Functor m, Monad m) => ApplyMonad (TreeMonad m) Tree
instance (Functor m, Monad m) => ApplyMonadTrans m Tree
instance ToTree Tree

module Darcs.Patch.Index.Monad
data FileModMonad a
withPatchMods :: FileModMonad a -> Set FileName -> (Set FileName, [PatchMod FileName])
instance Functor FileModMonad
instance Applicative FileModMonad
instance Monad FileModMonad
instance MonadState (Set FileName, [PatchMod FileName]) FileModMonad
instance ApplyMonad FileModMonad Tree


-- | The plain format implementation resides in this module. The plain
--   format does not use any hashing and basically just wraps a normal
--   filesystem tree in the hashed-storage API.
--   
--   NB. The <a>read</a> function on Blobs coming from a plain tree is
--   susceptible to file content changes. Since we use mmap in <a>read</a>,
--   this will break referential transparency and produce unexpected
--   results. Please always make sure that all parallel access to the
--   underlying filesystem tree never mutates files. Unlink + recreate is
--   fine though (in other words, the <a>writePlainTree</a> and
--   <a>plainTreeIO</a> implemented in this module are safe in this
--   respect).
module Storage.Hashed.Plain
readPlainTree :: FilePath -> IO (Tree IO)

-- | Write out <i>full</i> tree to a plain directory structure. If you
--   instead want to make incremental updates, refer to
--   <a>Storage.Hashed.Monad</a>.
writePlainTree :: Tree IO -> FilePath -> IO ()

-- | Run a <a>TreeIO</a> action in a plain tree setting. Writes out changes
--   to the plain tree every now and then (after the action is finished,
--   the last tree state is always flushed to disk). XXX Modify the tree
--   with filesystem reading and put it back into st (ie. replace the
--   in-memory Blobs with normal ones, so the memory can be GCd).
plainTreeIO :: TreeIO a -> Tree IO -> FilePath -> IO (a, Tree IO)


-- | This module contains plain tree indexing code. The index itself is a
--   CACHE: you should only ever use it as an optimisation and never as a
--   primary storage. In practice, this means that when we change index
--   format, the application is expected to throw the old index away and
--   build a fresh index. Please note that tracking index validity is out
--   of scope for this library: this is responsibility of your application.
--   It is advisable that in your validity tracking code, you also check
--   for format validity (see <a>indexFormatValid</a>) and scrap and
--   re-create index when needed.
--   
--   The index is a binary file that overlays a hashed tree over the
--   working copy. This means that every working file and directory has an
--   entry in the index, that contains its path and hash and validity data.
--   The validity data is a timestamp plus the file size. The file hashes
--   are sha256's of the file's content. It also contains the fileid to
--   track moved files.
--   
--   There are two entry types, a file entry and a directory entry. Both
--   have a common binary format (see <a>Item</a>). The on-disk format is
--   best described by the section <i>Index format</i> below.
--   
--   For each file, the index has a copy of the file's last modification
--   timestamp taken at the instant when the hash has been computed. This
--   means that when file size and timestamp of a file in working copy
--   matches those in the index, we assume that the hash stored in the
--   index for given file is valid. These hashes are then exposed in the
--   resulting <a>Tree</a> object, and can be leveraged by eg.
--   <a>diffTrees</a> to compare many files quickly.
--   
--   You may have noticed that we also keep hashes of directories. These
--   are assumed to be valid whenever the complete subtree has been valid.
--   At any point, as soon as a size or timestamp mismatch is found, the
--   working file in question is opened, its hash (and timestamp and size)
--   is recomputed and updated in-place in the index file (everything lives
--   at a fixed offset and is fixed size, so this isn't an issue). This is
--   also true of directories: when a file in a directory changes hash,
--   this triggers recomputation of all of its parent directory hashes;
--   moreover this is done efficiently -- each directory is updated at most
--   once during an update run.
--   
--   <i>Index format</i>
--   
--   The Index is organised into "lines" where each line describes a single
--   indexed item. Cf. <a>Item</a>.
--   
--   The first word on the index "line" is the length of the file path
--   (which is the only variable-length part of the line). Then comes the
--   path itself, then fixed-length hash (sha256) of the file in question,
--   then three words, one for size, one for "aux", which is used
--   differently for directories and for files, and one for the fileid
--   (inode or fhandle) of the file.
--   
--   With directories, this aux holds the offset of the next sibling line
--   in the index, so we can efficiently skip reading the whole subtree
--   starting at a given directory (by just seeking aux bytes forward). The
--   lines are pre-ordered with respect to directory structure -- the
--   directory comes first and after it come all its items. Cf.
--   <tt>readIndex'</tt>.
--   
--   For files, the aux field holds a timestamp.
module Storage.Hashed.Index

-- | Read an index and build up a <a>Tree</a> object from it, referring to
--   current working directory. The initial Index object returned by
--   readIndex is not directly useful. However, you can use <a>filter</a>
--   on it. Either way, to obtain the actual Tree object, call update.
--   
--   The usual use pattern is this:
--   
--   <pre>
--   do (idx, update) &lt;- readIndex
--      tree &lt;- update =&lt;&lt; filter predicate idx
--   </pre>
--   
--   The resulting tree will be fully expanded.
readIndex :: FilePath -> (Tree IO -> Hash) -> IO Index

-- | Will add and remove files in index to make it match the <a>Tree</a>
--   object given (it is an error for the <a>Tree</a> to contain a file or
--   directory that does not exist in a plain form in current working
--   directory).
updateIndexFrom :: FilePath -> (Tree IO -> Hash) -> Tree IO -> IO Index

-- | Check that a given file is an index file with a format we can handle.
--   You should remove and re-create the index whenever this is not true.
indexFormatValid :: FilePath -> IO Bool
updateIndex :: Index -> IO (Tree IO)

-- | Return a list containing all the file/folder names in an index, with
--   their respective ItemType and FileID.
listFileIDs :: Index -> IO ([((AnchoredPath, ItemType), FileID)])
type Index = IndexM IO

-- | Given <tt>pred tree</tt>, produce a <a>Tree</a> that only has items
--   for which <tt>pred</tt> returns <tt>True</tt>. The tree might contain
--   stubs. When expanded, these will be subject to filtering as well.
filter :: FilterTree a m => (AnchoredPath -> TreeItem m -> Bool) -> a m -> a m

-- | For a given file or folder path, get the corresponding fileID from the
--   filesystem.
getFileID :: AnchoredPath -> IO (Maybe FileID)
instance Show Item
instance FilterTree IndexM IO


-- | This module implements an "object storage". This is a directory on
--   disk containing a content-addressed storage. This is useful for
--   storing all kinds of things, particularly filesystem trees, or darcs
--   pristine caches and patch objects. However, this is an abstract, flat
--   storage: no tree semantics are provided. You just need to provide a
--   reference-collecting functionality, computing a list of references for
--   any given object. The system provides transparent garbage collection
--   and packing.
module Storage.Hashed.Packed

-- | On-disk format for object storage: we implement a completely loose
--   format (one file per object), a compact format stored in a single
--   append-only file and an immutable "pack" format.
data Format
Loose :: Format
Compact :: Format
Pack :: Format

-- | Object storage block. When used as a hatchery, the loose or compact
--   format are preferable, while for mature space, the pack format is more
--   useful.
data Block

-- | Object storage. Contains a single "hatchery" and possibly a number of
--   mature space blocks, usually in form of packs. It also keeps a list of
--   root pointers and has a way to extract pointers from objects
--   (externally supplied). These last two things are used to implement a
--   simple GC.
data OS

-- | Add new objects to the object storage (i.e. put them into hatchery).
--   It is safe to call this even on objects that are already present in
--   the storage: such objects will be skipped.
hatch :: OS -> [ByteString] -> IO OS

-- | Move things from hatchery into a (new) pack.
compact :: OS -> IO OS

-- | Reduce number of packs in the object storage. This may both recombine
--   packs to eliminate dead objects and join some packs to form bigger
--   packs.
repack :: OS -> IO OS
lookup :: OS -> Hash -> IO (Maybe FileSegment)

-- | Create an empty object storage in given directory, with a hatchery of
--   given format. The directory is created if needed, but is assumed to be
--   empty.
create :: FilePath -> Format -> IO OS
load :: FilePath -> IO OS
format :: Block -> Format
blockLookup :: Block -> Hash -> IO (Maybe FileSegment)

-- | Build a map of live objects (i.e. those reachable from the given
--   roots) in a given list of Blocks.
live :: OS -> [Block] -> IO (Map Hash FileSegment)
hatchery :: OS -> Block
mature :: OS -> [Block]
roots :: OS -> [Hash]
references :: OS -> FileSegment -> IO [Hash]
rootdir :: OS -> FilePath
instance Show Format
instance Eq Format


-- | A few darcs-specific utility functions. These are used for reading and
--   writing darcs and darcs-compatible hashed trees.
module Storage.Hashed.Darcs

-- | <a>darcsDecodeWhite</a> interprets the Darcs-specific "encoded"
--   filenames produced by <a>darcsEncodeWhite</a>
--   
--   <pre>
--   darcsDecodeWhite "hello\32\there" == "hello there"
--   darcsDecodeWhite "hello\92\there" == "hello\there"
--   darcsDecodeWhite "hello\there"    == error "malformed filename"
--   </pre>
darcsDecodeWhite :: String -> FilePath

-- | <a>darcsEncodeWhite</a> translates whitespace in filenames to a
--   darcs-specific format (backslash followed by numerical representation
--   according to <a>ord</a>). Note that backslashes are also escaped since
--   they are used in the encoding.
--   
--   <pre>
--   darcsEncodeWhite "hello there" == "hello\32\there"
--   darcsEncodeWhite "hello\there" == "hello\92\there"
--   </pre>
darcsEncodeWhite :: FilePath -> String
darcsEncodeWhiteBS :: ByteString -> ByteString
decodeDarcsHash :: ByteString -> Hash
decodeDarcsSize :: ByteString -> Maybe Int
darcsLocation :: FilePath -> (Maybe Int, Hash) -> FileSegment
darcsFormatDir :: Tree m -> Maybe ByteString
darcsParseDir :: ByteString -> [(ItemType, Name, Maybe Int, Hash)]

-- | Compute a darcs-compatible hash value for a tree-like structure.
darcsTreeHash :: Tree m -> Hash
darcsUpdateDirHashes :: Tree m -> Tree m
darcsUpdateHashes :: (Monad m, Functor m) => Tree m -> m (Tree m)
darcsHash :: (Monad m, Functor m) => TreeItem m -> m Hash
darcsAddMissingHashes :: (Monad m, Functor m) => Tree m -> m (Tree m)

-- | Read and parse a darcs-style hashed directory listing from a given
--   <tt>dir</tt> and with a given <tt>hash</tt>.
readDarcsHashedDir :: FilePath -> (Maybe Int, Hash) -> IO [(ItemType, Name, Maybe Int, Hash)]

-- | Read in a darcs-style hashed tree. This is mainly useful for reading
--   "pristine.hashed". You need to provide the root hash you are
--   interested in (found in _darcs/hashed_inventory).
readDarcsHashed' :: Bool -> FilePath -> (Maybe Int, Hash) -> IO (Tree IO)
readDarcsHashed :: FilePath -> (Maybe Int, Hash) -> IO (Tree IO)
readDarcsHashedNosize :: FilePath -> Hash -> IO (Tree IO)

-- | Write a Tree into a darcs-style hashed directory.
writeDarcsHashed :: Tree IO -> FilePath -> IO Hash

-- | Create a hashed file from a <a>FilePath</a> and content. In case the
--   file exists it is kept untouched and is assumed to have the right
--   content. XXX Corrupt files should be probably renamed out of the way
--   automatically or something (probably when they are being read though).
fsCreateHashedFile :: FilePath -> ByteString -> TreeIO ()

-- | Run a <a>TreeIO</a> <tt>action</tt> in a hashed setting. The
--   <tt>initial</tt> tree is assumed to be fully available from the
--   <tt>directory</tt>, and any changes will be written out to same.
--   Please note that actual filesystem files are never removed.
hashedTreeIO :: TreeIO a -> Tree IO -> FilePath -> IO (a, Tree IO)

-- | Read a Tree in the darcs hashed format from an object storage. This is
--   basically the same as readDarcsHashed from Storage.Hashed, but uses an
--   object storage instead of traditional darcs filesystem layout.
--   Requires the tree root hash as a starting point.
readPackedDarcsPristine :: OS -> Hash -> IO (Tree IO)

-- | Write a Tree into an object storage, using the darcs-style directory
--   formatting (and therefore darcs-style hashes). Gives back the object
--   storage and the root hash of the stored Tree. NB. The function expects
--   that the Tree comes equipped with darcs-style hashes already!
writePackedDarcsPristine :: Tree IO -> OS -> IO (OS, Hash)
storePackedDarcsPristine :: Tree IO -> OS -> IO (OS, Hash)
darcsPristineRefs :: FileSegment -> IO [Hash]
darcsCheckExpand :: Tree IO -> IO (Either [(FilePath, Hash, Maybe Hash)] (Tree IO))

module Darcs.Repository.HashedIO
type HashedIO p = StateT (HashDir RW p) IO

-- | Grab a whole pristine tree from a hash, and, if asked, write files in
--   the working copy.
copyHashed :: String -> Cache -> WithWorkingDir -> String -> IO ()
copyPartialsHashed :: FilePathLike fp => Cache -> String -> [fp] -> IO ()
cleanHashdir :: Cache -> HashedDir -> [String] -> IO ()

-- | getHashedFiles returns all hash files targeted by files in hashroots
--   in the hashdir directory.
getHashedFiles :: String -> [String] -> IO [String]
data RW
RW :: RW

-- | Returns a list of pairs (FilePath, (strict) ByteString) of the
--   pristine tree starting with the hash <tt>root</tt>. <tt>path</tt>
--   should be either "." or end with "/" Separator "/" is used since this
--   function is used to generate zip archives from pristine trees.
pathsAndContents :: FilePath -> Cache -> String -> IO [(FilePath, ByteString)]
instance Eq ObjType
instance ApplyMonad (HashedIO p) Tree

module Storage.Hashed
readPlainTree :: FilePath -> IO (Tree IO)
readDarcsHashed :: FilePath -> (Maybe Int, Hash) -> IO (Tree IO)

-- | Read a Blob into a Lazy ByteString. Might be backed by an mmap, use
--   with care.
readBlob :: Blob m -> m ByteString

-- | Write out <i>full</i> tree to a plain directory structure. If you
--   instead want to make incremental updates, refer to
--   <a>Storage.Hashed.Monad</a>.
writePlainTree :: Tree IO -> FilePath -> IO ()

-- | Write a Tree into a darcs-style hashed directory.
writeDarcsHashed :: Tree IO -> FilePath -> IO Hash

-- | Take a relative FilePath and turn it into an AnchoredPath. The
--   operation is (relatively) unsafe. Basically, by using floatPath, you
--   are testifying that the argument is a path relative to some common
--   root -- i.e. the root of the associated <a>Tree</a> object. Also,
--   there are certain invariants about AnchoredPath that this function
--   tries hard to preserve, but probably cannot guarantee (i.e. this is a
--   best-effort thing). You should sanitize any FilePaths before you
--   declare them "good" by converting into AnchoredPath (using this
--   function).
floatPath :: FilePath -> AnchoredPath

-- | Take a relative FilePath within a Tree and print the contents of the
--   object there. Useful for exploration, less so for serious programming.
printPath :: Tree IO -> FilePath -> IO ()

module Darcs.UI.Commands.Util.Tree
treeHas :: (Functor m, Monad m) => Tree m -> FilePath -> m Bool
treeHasDir :: (Functor m, Monad m) => Tree m -> FilePath -> m Bool
treeHasFile :: (Functor m, Monad m) => Tree m -> FilePath -> m Bool
treeHasAnycase :: (Functor m, Monad m) => Tree m -> FilePath -> m Bool

module Darcs.Patch.TokenReplace

-- | tryTokInternal takes a String of token chars, an oldToken ByteString,
--   a newToken ByteString and returns the list of token-delimited
--   ByteStrings, with any tokens matching oldToken being replaced by
--   newToken. If newToken is already in the input, we return Nothing.
tryTokInternal :: String -> ByteString -> ByteString -> ByteString -> Maybe [ByteString]

-- | forceTokReplace replaces all occurrences of the old token with the new
--   token, throughout the input ByteString.
forceTokReplace :: String -> ByteString -> ByteString -> ByteString -> ByteString

-- | breakOutToken takes a String of token chars and an input ByteString,
--   and returns the ByteString triple of (beforeToken, token, afterToken).
breakOutToken :: String -> ByteString -> (ByteString, ByteString, ByteString)

module Darcs.Patch.Rebase.NameHack

-- | When commuting a <tt>Normal</tt> patch past a <tt>Suspended</tt> one,
--   we need to adjust the internals of the <tt>Suspended</tt> one to take
--   account of the effect of the <tt>Normal</tt> patch. This includes the
--   name of the <tt>Normal</tt> patch - but the layering is such that we
--   are actually commuting patches of type <tt>Named (Rebasing p)</tt> -
--   i.e. <tt>Rebasing p</tt> doesn't actually contain the name. We
--   therefore need to add a hook to the <tt>Commute</tt> instances for
--   <tt>Named</tt> which <tt>Rebasing</tt> can then implement.
--   
--   There is a default so that other patch types only need to declare the
--   instance.
class NameHack p where nameHack = \ _ -> Nothing
nameHack :: NameHack p => DiffAlgorithm -> Maybe (PatchInfo -> FL p wX wY -> FL p wX wY, PatchInfo -> FL p wW wZ -> FL p wW wZ)

module Darcs.Patch.Read
class ReadPatch p
readPatch' :: (ReadPatch p, ParserM m) => m (Sealed (p wX))
readPatch :: ReadPatch p => ByteString -> Maybe (Sealed (p wX))
readPatchPartial :: ReadPatch p => ByteString -> Maybe (Sealed (p wX), ByteString)
bracketedFL :: ParserM m => (forall wY. m (Sealed (p wY))) -> Char -> Char -> m (Sealed (FL p wX))
peekfor :: ParserM m => ByteString -> m a -> m a -> m a
readFileName :: FileNameFormat -> ByteString -> FileName
instance (ReadPatch p, PatchListFormat p) => ReadPatch (RL p)
instance (ReadPatch p, PatchListFormat p) => ReadPatch (FL p)
instance ReadPatch p => ReadPatch (Bracketed p)

module Darcs.Patch.Invert
class Invert p
invert :: Invert p => p wX wY -> p wY wX
invertFL :: Invert p => FL p wX wY -> RL p wY wX
invertRL :: Invert p => RL p wX wY -> FL p wY wX
instance Invert p => Invert (RL p)
instance Invert p => Invert (FL p)

module Darcs.Patch.Commute

-- | Commute represents things that can be (possibly) commuted.
class Commute p
commute :: Commute p => (p :> p) wX wY -> Maybe ((p :> p) wX wY)

-- | <a>commuteFL</a> commutes a single element past a FL.
commuteFL :: Commute p => (p :> FL p) wX wY -> Maybe ((FL p :> p) wX wY)

-- | <a>commuteFLorComplain</a> attempts to commute a single element past a
--   FL. If any individual commute fails, then we return the patch that
--   first patch that cannot be commuted past.
commuteFLorComplain :: Commute p => (p :> FL p) wX wY -> Either (Sealed2 p) ((FL p :> p) wX wY)

-- | <a>commuteRL</a> commutes a RL past a single element.
commuteRL :: Commute p => (RL p :> p) wX wY -> Maybe ((p :> RL p) wX wY)

-- | <a>commuteRLFL</a> commutes an <a>RL</a> past an <a>FL</a>.
commuteRLFL :: Commute p => (RL p :> FL p) wX wY -> Maybe ((FL p :> RL p) wX wY)

-- | Swaps the ordered pair type so that commute can be called directly.
toFwdCommute :: (Commute p, Commute q, Monad m) => ((p :< q) wX wY -> m ((q :< p) wX wY)) -> (q :> p) wX wY -> m ((p :> q) wX wY)

-- | Swaps the ordered pair type from the order expected by commute to the
--   reverse order.
toRevCommute :: (Commute p, Commute q, Monad m) => ((p :> q) wX wY -> m ((q :> p) wX wY)) -> (q :< p) wX wY -> m ((p :< q) wX wY)

-- | Build a commuter between a patch and itself using the operation from
--   the type class.
selfCommuter :: Commute p => CommuteFn p p
instance Commute p => Commute (RL p)
instance Commute p => Commute (FL p)


module Darcs.Patch.Merge

-- | Things that can always be merged
class Commute p => Merge p
merge :: Merge p => (p :\/: p) wX wY -> (p :/\: p) wX wY
selfMerger :: Merge p => MergeFn p p
mergeFL :: Merge p => (p :\/: FL p) wX wY -> (FL p :/\: p) wX wY
instance Merge p => Merge (RL p)
instance Merge p => Merge (FL p)

module Darcs.Patch.Permutations

-- | <a>removeFL</a> <tt>x xs</tt> removes <tt>x</tt> from <tt>xs</tt> if
--   <tt>x</tt> can be commuted to its head. Otherwise it returns
--   <a>Nothing</a>
removeFL :: (MyEq p, Commute p) => p wX wY -> FL p wX wZ -> Maybe (FL p wY wZ)

-- | <a>removeRL</a> is like <a>removeFL</a> except with <a>RL</a>
removeRL :: (MyEq p, Commute p) => p wY wZ -> RL p wX wZ -> Maybe (RL p wX wY)
removeCommon :: (MyEq p, Commute p) => (FL p :\/: FL p) wX wY -> (FL p :\/: FL p) wX wY
commuteWhatWeCanFL :: Commute p => (p :> FL p) wX wY -> (FL p :> (p :> FL p)) wX wY
commuteWhatWeCanRL :: Commute p => (RL p :> p) wX wY -> (RL p :> (p :> RL p)) wX wY
genCommuteWhatWeCanRL :: Commute p => (forall wA wB. (p :> q) wA wB -> Maybe ((q :> p) wA wB)) -> (RL p :> q) wX wY -> (RL p :> (q :> RL p)) wX wY
genCommuteWhatWeCanFL :: Commute q => (forall wA wB. (p :> q) wA wB -> Maybe ((q :> p) wA wB)) -> (p :> FL q) wX wY -> (FL q :> (p :> FL q)) wX wY

-- | split an <a>FL</a> into "left" and "right" lists according to a
--   predicate <tt>p</tt>, using commutation as necessary. If a patch does
--   satisfy the predicate but cannot be commuted past one that does not
--   satisfy the predicate, it goes in the "middle" list; to sum up, we
--   have: <tt>all p left</tt> and <tt>all (not.p) right</tt>, while
--   midddle is mixed. Note that <tt>p</tt> should be invariant under
--   commutation (i.e. if <tt>x1</tt> can commute to <tt>x2</tt> then 'p x1
--   <a>=</a> p x2').
partitionFL :: Commute p => (forall wU wV. p wU wV -> Bool) -> FL p wX wY -> (FL p :> (FL p :> FL p)) wX wY

-- | split an <a>RL</a> into "left" and "right" lists according to a
--   predicate, using commutation as necessary. If a patch does satisfy the
--   predicate but cannot be commuted past one that does not satisfy the
--   predicate, it goes in the "left" list.
partitionRL :: Commute p => (forall wU wV. p wU wV -> Bool) -> RL p wX wY -> (RL p :> RL p) wX wY

-- | This is a minor variant of <a>headPermutationsFL</a> with each
--   permutation is simply returned as a <a>FL</a>
simpleHeadPermutationsFL :: Commute p => FL p wX wY -> [FL p wX wY]

-- | <a>headPermutationsRL</a> is like <a>headPermutationsFL</a>, except
--   that we operate on an <a>RL</a> (in other words, we are pushing things
--   to the end of a patch sequence instead of to the beginning).
headPermutationsRL :: Commute p => RL p wX wY -> [RL p wX wY]

-- | <a>headPermutationsFL</a> <tt>p:&gt;:ps</tt> returns all the
--   permutations of the list in which one element of <tt>ps</tt> is
--   commuted past <tt>p</tt>
--   
--   Suppose we have a sequence of patches
--   
--   <pre>
--   X h a y s-t-c k
--   </pre>
--   
--   Suppose furthermore that the patch <tt>c</tt> depends on <tt>t</tt>,
--   which in turn depends on <tt>s</tt>. This function will return
--   
--   <pre>
--   X :&gt; h a y s t c k
--   h :&gt; X a y s t c k
--   a :&gt; X h y s t c k
--   y :&gt; X h a s t c k
--   s :&gt; X h a y t c k
--   k :&gt; X h a y s t c
--   </pre>
headPermutationsFL :: Commute p => FL p wX wY -> [(p :> FL p) wX wY]

-- | <a>removeSubsequenceFL</a> <tt>ab abc</tt> returns <tt>Just c'</tt>
--   where all the patches in <tt>ab</tt> have been commuted out of it, if
--   possible. If this is not possible for any reason (the set of patches
--   <tt>ab</tt> is not actually a subset of <tt>abc</tt>, or they can't be
--   commuted out) we return <a>Nothing</a>.
removeSubsequenceFL :: (MyEq p, Commute p) => FL p wA wB -> FL p wA wC -> Maybe (FL p wB wC)

-- | <a>removeSubsequenceRL</a> is like <tt>removeSubsequenceFL</tt> except
--   that it works on <a>RL</a>
removeSubsequenceRL :: (MyEq p, Commute p) => RL p wAb wAbc -> RL p wA wAbc -> Maybe (RL p wA wAb)

-- | Partition a list into the patches that merge with the given patch and
--   those that don't (including dependencies)
partitionConflictingFL :: (Commute p1, Invert p1) => CommuteFn p1 p2 -> FL p1 wX wY -> p2 wX wZ -> (FL p1 :> FL p1) wX wY
inverseCommuter :: (Invert p, Invert q) => CommuteFn p q -> CommuteFn q p
instance (MyEq p, Commute p) => MyEq (RL p)
instance (MyEq p, Commute p) => MyEq (FL p)


module Darcs.Patch.Apply
class Apply p where type family ApplyState p :: (* -> *) -> *
apply :: (Apply p, ApplyMonad m (ApplyState p)) => p wX wY -> m ()
applyToFilePaths :: (Apply p, ApplyState p ~ Tree) => p wX wY -> Maybe [(FilePath, FilePath)] -> [FilePath] -> ([FilePath], [FilePath], [(FilePath, FilePath)])

-- | Apply a patch to a <a>Tree</a>, yielding a new <a>Tree</a>.
applyToTree :: (Apply p, Functor m, Monad m, ApplyState p ~ Tree) => p wX wY -> Tree m -> m (Tree m)
applyToState :: (Apply p, ApplyMonadTrans m (ApplyState p)) => p wX wY -> (ApplyState p) m -> m ((ApplyState p) m)

-- | Apply a patch to set of <a>FileName</a>s, yielding the new set of
--   <a>FileName</a>s and <a>PatchMod</a>s
applyToFileMods :: (Apply p, ApplyState p ~ Tree) => p wX wY -> Set FileName -> (Set FileName, [PatchMod FileName])
effectOnFilePaths :: (Apply p, ApplyState p ~ Tree) => p wX wY -> [FilePath] -> [FilePath]
instance Apply p => Apply (RL p)
instance Apply p => Apply (FL p)

module Darcs.Patch.Repair

-- | <a>Repair</a> and <a>RepairToFL</a> deal with repairing old patches
--   that were were written out due to bugs or that we no longer wish to
--   support. <a>Repair</a> is implemented by collections of patches (FL,
--   Named, PatchInfoAnd) that might need repairing.
class Repair p
applyAndTryToFix :: (Repair p, ApplyMonad m (ApplyState p)) => p wX wY -> m (Maybe (String, p wX wY))

-- | <a>RepairToFL</a> is implemented by single patches that can be
--   repaired (Prim, Patch, RealPatch) There is a default so that patch
--   types with no current legacy problems don't need to have an
--   implementation.
class Apply p => RepairToFL p where applyAndTryToFixFL p = do { apply p; return Nothing }
applyAndTryToFixFL :: (RepairToFL p, ApplyMonad m (ApplyState p)) => p wX wY -> m (Maybe (String, FL p wX wY))
mapMaybeSnd :: (a -> b) -> Maybe (c, a) -> Maybe (c, b)
class Check p where isInconsistent _ = Nothing
isInconsistent :: Check p => p wX wY -> Maybe Doc
instance RepairToFL p => Repair (FL p)
instance Check p => Check (RL p)
instance Check p => Check (FL p)

module Darcs.Patch.Show
class ShowPatchBasic p
showPatch :: ShowPatchBasic p => p wX wY -> Doc
class ShowPatchBasic p => ShowPatch p where showNicely = showPatch showContextPatch p = return $ showPatch p description = showPatch thing _ = "patch" things x = plural (Noun $ thing x) ""
showNicely :: ShowPatch p => p wX wY -> Doc
showContextPatch :: (ShowPatch p, Monad m, ApplyMonadTrans m (ApplyState p), ApplyMonad m (ApplyState p)) => p wX wY -> m Doc
description :: ShowPatch p => p wX wY -> Doc
summary :: ShowPatch p => p wX wY -> Doc
summaryFL :: ShowPatch p => FL p wX wY -> Doc
thing :: ShowPatch p => p wX wY -> String
things :: ShowPatch p => p wX wY -> String
showNamedPrefix :: PatchInfo -> [PatchInfo] -> Doc
formatFileName :: FileNameFormat -> FileName -> Doc

module Darcs.Patch.Patchy
class (Apply p, Commute p, Invert p) => Patchy p
class Apply p where type family ApplyState p :: (* -> *) -> *
apply :: (Apply p, ApplyMonad m (ApplyState p)) => p wX wY -> m ()

-- | Commute represents things that can be (possibly) commuted.
class Commute p
commute :: Commute p => (p :> p) wX wY -> Maybe ((p :> p) wX wY)
class Invert p
invert :: Invert p => p wX wY -> p wY wX
class PatchInspect p
listTouchedFiles :: PatchInspect p => p wX wY -> [FilePath]
hunkMatches :: PatchInspect p => (ByteString -> Bool) -> p wX wY -> Bool
class ReadPatch p
readPatch' :: (ReadPatch p, ParserM m) => m (Sealed (p wX))
showPatch :: ShowPatchBasic p => p wX wY -> Doc
class ShowPatchBasic p => ShowPatch p where showNicely = showPatch showContextPatch p = return $ showPatch p description = showPatch thing _ = "patch" things x = plural (Noun $ thing x) ""
showNicely :: ShowPatch p => p wX wY -> Doc
showContextPatch :: (ShowPatch p, Monad m, ApplyMonadTrans m (ApplyState p), ApplyMonad m (ApplyState p)) => p wX wY -> m Doc
description :: ShowPatch p => p wX wY -> Doc
summary :: ShowPatch p => p wX wY -> Doc
summaryFL :: ShowPatch p => FL p wX wY -> Doc
thing :: ShowPatch p => p wX wY -> String
things :: ShowPatch p => p wX wY -> String

module Darcs.Patch.Matchable
class (Patchy p, PatchInspect p, MaybeInternal p, NameHack p) => Matchable p

module Darcs.Patch.Bracketed.Instances
instance ShowPatchBasic p => ShowPatchBasic (Bracketed p)

module Darcs.Patch.FileHunk
data FileHunk wX wY
FileHunk :: !FileName -> !Int -> [ByteString] -> [ByteString] -> FileHunk wX wY
class IsHunk p
isHunk :: IsHunk p => p wX wY -> Maybe (FileHunk wX wY)
showFileHunk :: FileNameFormat -> FileHunk wX wY -> Doc

module Darcs.Patch.Prim.Class
class PrimConstruct prim
addfile :: PrimConstruct prim => FilePath -> prim wX wY
rmfile :: PrimConstruct prim => FilePath -> prim wX wY
adddir :: PrimConstruct prim => FilePath -> prim wX wY
rmdir :: PrimConstruct prim => FilePath -> prim wX wY
move :: PrimConstruct prim => FilePath -> FilePath -> prim wX wY
changepref :: PrimConstruct prim => String -> String -> String -> prim wX wY
hunk :: PrimConstruct prim => FilePath -> Int -> [ByteString] -> [ByteString] -> prim wX wY
tokreplace :: PrimConstruct prim => FilePath -> String -> String -> String -> prim wX wY
binary :: PrimConstruct prim => FilePath -> ByteString -> ByteString -> prim wX wY
primFromHunk :: PrimConstruct prim => FileHunk wX wY -> prim wX wY
anIdentity :: PrimConstruct prim => prim wX wX
class PrimCanonize prim
tryToShrink :: PrimCanonize prim => FL prim wX wY -> FL prim wX wY
tryShrinkingInverse :: PrimCanonize prim => FL prim wX wY -> Maybe (FL prim wX wY)
sortCoalesceFL :: PrimCanonize prim => FL prim wX wY -> FL prim wX wY
canonize :: PrimCanonize prim => DiffAlgorithm -> prim wX wY -> FL prim wX wY
canonizeFL :: PrimCanonize prim => DiffAlgorithm -> FL prim wX wY -> FL prim wX wY
coalesce :: PrimCanonize prim => (prim :> prim) wX wY -> Maybe (FL prim wX wY)
class PrimClassify prim
primIsAddfile :: PrimClassify prim => prim wX wY -> Bool
primIsRmfile :: PrimClassify prim => prim wX wY -> Bool
primIsAdddir :: PrimClassify prim => prim wX wY -> Bool
primIsRmdir :: PrimClassify prim => prim wX wY -> Bool
primIsMove :: PrimClassify prim => prim wX wY -> Bool
primIsHunk :: PrimClassify prim => prim wX wY -> Bool
primIsTokReplace :: PrimClassify prim => prim wX wY -> Bool
primIsBinary :: PrimClassify prim => prim wX wY -> Bool
primIsSetpref :: PrimClassify prim => prim wX wY -> Bool
is_filepatch :: PrimClassify prim => prim wX wY -> Maybe FileName
class PrimDetails prim
summarizePrim :: PrimDetails prim => prim wX wY -> [SummDetail]
class PrimShow prim
showPrim :: PrimShow prim => FileNameFormat -> prim wA wB -> Doc
showPrimFL :: PrimShow prim => FileNameFormat -> FL prim wA wB -> Doc
class PrimRead prim
readPrim :: (PrimRead prim, ParserM m) => FileNameFormat -> m (Sealed (prim wX))
class PrimApply prim
applyPrimFL :: (PrimApply prim, ApplyMonad m (ApplyState prim)) => FL prim wX wY -> m ()
class (Patchy prim, MyEq prim, PatchListFormat prim, IsHunk prim, RepairToFL prim, PatchInspect prim, ReadPatch prim, ShowPatch prim, PrimConstruct prim, PrimCanonize prim, PrimClassify prim, PrimDetails prim, PrimShow prim, PrimRead prim, PrimApply prim) => PrimPatch prim
class PrimPatch (PrimOf p) => PrimPatchBase p where type family PrimOf (p :: * -> * -> *) :: * -> * -> *
class FromPrim p
fromPrim :: FromPrim p => PrimOf p wX wY -> p wX wY
class FromPrims p
fromPrims :: FromPrims p => FL (PrimOf p) wX wY -> p wX wY
class FromPrim p => ToFromPrim p
toPrim :: ToFromPrim p => p wX wY -> Maybe (PrimOf p wX wY)
instance FromPrim p => FromPrims (RL p)
instance FromPrim p => FromPrims (FL p)
instance FromPrim p => FromPrim (FL p)
instance PrimPatchBase p => PrimPatchBase (RL p)
instance PrimPatchBase p => PrimPatchBase (FL p)

module Darcs.Patch.Effect

-- | Patches whose concrete effect which can be expressed as a list of
--   primitive patches.
--   
--   A minimal definition would be either of <tt>effect</tt> or
--   <tt>effectRL</tt>.
class Effect p where effect = reverseRL . effectRL effectRL = reverseFL . effect
effect :: Effect p => p wX wY -> FL (PrimOf p) wX wY
effectRL :: Effect p => p wX wY -> RL (PrimOf p) wX wY
instance Effect p => Effect (RL p)
instance Effect p => Effect (FL p)

module Darcs.Patch.Conflict
class (Effect p, PatchInspect (PrimOf p)) => Conflict p where listConflictedFiles p = nubSort $ concatMap (unseal listTouchedFiles) $ concat $ resolveConflicts p conflictedEffect x = case listConflictedFiles x of { [] -> mapFL (IsC Okay) $ effect x _ -> mapFL (IsC Conflicted) $ effect x }
listConflictedFiles :: Conflict p => p wX wY -> [FilePath]
resolveConflicts :: Conflict p => p wX wY -> [[Sealed (FL (PrimOf p) wY)]]
conflictedEffect :: Conflict p => p wX wY -> [IsConflictedPrim (PrimOf p)]
class CommuteNoConflicts p
commuteNoConflicts :: CommuteNoConflicts p => (p :> p) wX wY -> Maybe ((p :> p) wX wY)
data IsConflictedPrim prim
IsC :: !ConflictState -> !(prim wX wY) -> IsConflictedPrim prim
data ConflictState
Okay :: ConflictState
Conflicted :: ConflictState
Duplicated :: ConflictState
instance Eq ConflictState
instance Ord ConflictState
instance Show ConflictState
instance Read ConflictState
instance Show2 prim => Show (IsConflictedPrim prim)
instance CommuteNoConflicts p => CommuteNoConflicts (RL p)
instance (CommuteNoConflicts p, Conflict p) => Conflict (RL p)
instance CommuteNoConflicts p => CommuteNoConflicts (FL p)
instance (CommuteNoConflicts p, Conflict p) => Conflict (FL p)

module Darcs.Patch.Prim
showPrim :: PrimShow prim => FileNameFormat -> prim wA wB -> Doc
showPrimFL :: PrimShow prim => FileNameFormat -> FL prim wA wB -> Doc
primIsAddfile :: PrimClassify prim => prim wX wY -> Bool
primIsHunk :: PrimClassify prim => prim wX wY -> Bool
primIsBinary :: PrimClassify prim => prim wX wY -> Bool
primIsSetpref :: PrimClassify prim => prim wX wY -> Bool
primIsAdddir :: PrimClassify prim => prim wX wY -> Bool
is_filepatch :: PrimClassify prim => prim wX wY -> Maybe FileName

-- | It can sometimes be handy to have a canonical representation of a
--   given patch. We achieve this by defining a canonical form for each
--   patch type, and a function <a>canonize</a> which takes a patch and
--   puts it into canonical form. This routine is used by the diff function
--   to create an optimal patch (based on an LCS algorithm) from a simple
--   hunk describing the old and new version of a file.
canonize :: PrimCanonize prim => DiffAlgorithm -> prim wX wY -> FL prim wX wY

-- | <tt>tryToShrink ps</tt> simplifies <tt>ps</tt> by getting rid of
--   self-cancellations or coalescing patches
--   
--   Question (Eric Kow): what properties should this have? For example,
--   the prim1 implementation only gets rid of the first self-cancellation
--   it finds (as far as I can tell). Is that OK? Can we try harder?
tryToShrink :: PrimCanonize prim => FL prim wX wY -> FL prim wX wY

-- | <a>sortCoalesceFL</a> <tt>ps</tt> coalesces as many patches in
--   <tt>ps</tt> as possible, sorting the results in some standard order.
sortCoalesceFL :: PrimCanonize prim => FL prim wX wY -> FL prim wX wY
coalesce :: PrimCanonize prim => (prim :> prim) wX wY -> Maybe (FL prim wX wY)

-- | <a>canonizeFL</a> <tt>ps</tt> puts a sequence of primitive patches
--   into canonical form. Even if the patches are just hunk patches, this
--   is not necessarily the same set of results as you would get if you
--   applied the sequence to a specific tree and recalculated a diff.
--   
--   Note that this process does not preserve the commutation behaviour of
--   the patches and is therefore not appropriate for use when working with
--   already recorded patches (unless doing amend-record or the like).
canonizeFL :: PrimCanonize prim => DiffAlgorithm -> FL prim wX wY -> FL prim wX wY

-- | <tt>tryShrinkingInverse ps</tt> deletes the first subsequence of
--   primitive patches that is followed by the inverse subsequence, if one
--   exists. If not, it returns <tt>Nothing</tt>
tryShrinkingInverse :: PrimCanonize prim => FL prim wX wY -> Maybe (FL prim wX wY)
summarizePrim :: PrimDetails prim => prim wX wY -> [SummDetail]
applyPrimFL :: (PrimApply prim, ApplyMonad m (ApplyState prim)) => FL prim wX wY -> m ()
readPrim :: (PrimRead prim, ParserM m) => FileNameFormat -> m (Sealed (prim wX))
class FromPrim p
fromPrim :: FromPrim p => PrimOf p wX wY -> p wX wY
class FromPrims p
fromPrims :: FromPrims p => FL (PrimOf p) wX wY -> p wX wY
class FromPrim p => ToFromPrim p
toPrim :: ToFromPrim p => p wX wY -> Maybe (PrimOf p wX wY)
class (Patchy prim, MyEq prim, PatchListFormat prim, IsHunk prim, RepairToFL prim, PatchInspect prim, ReadPatch prim, ShowPatch prim, PrimConstruct prim, PrimCanonize prim, PrimClassify prim, PrimDetails prim, PrimShow prim, PrimRead prim, PrimApply prim) => PrimPatch prim
class PrimPatch (PrimOf p) => PrimPatchBase p where type family PrimOf (p :: * -> * -> *) :: * -> * -> *
class PrimConstruct prim
addfile :: PrimConstruct prim => FilePath -> prim wX wY
rmfile :: PrimConstruct prim => FilePath -> prim wX wY
adddir :: PrimConstruct prim => FilePath -> prim wX wY
rmdir :: PrimConstruct prim => FilePath -> prim wX wY
move :: PrimConstruct prim => FilePath -> FilePath -> prim wX wY
changepref :: PrimConstruct prim => String -> String -> String -> prim wX wY
hunk :: PrimConstruct prim => FilePath -> Int -> [ByteString] -> [ByteString] -> prim wX wY
tokreplace :: PrimConstruct prim => FilePath -> String -> String -> String -> prim wX wY
binary :: PrimConstruct prim => FilePath -> ByteString -> ByteString -> prim wX wY
primFromHunk :: PrimConstruct prim => FileHunk wX wY -> prim wX wY
anIdentity :: PrimConstruct prim => prim wX wX

module Darcs.Patch.ConflictMarking
mangleUnravelled :: PrimPatch prim => [Sealed (FL prim wX)] -> Sealed (FL prim wX)

module Darcs.Patch.Summary
plainSummary :: (Conflict e, Effect e, PrimPatchBase e) => e wX wY -> Doc
plainSummaryPrim :: PrimDetails prim => prim wX wY -> Doc
plainSummaryPrims :: PrimDetails prim => FL prim wX wY -> Doc
xmlSummary :: (Effect p, Conflict p, PrimPatchBase p) => p wX wY -> Doc
instance Ord SummChunk
instance Eq SummChunk

module Darcs.Patch.Prim.V1.Core
data Prim wX wY
Move :: !FileName -> !FileName -> Prim wX wY
DP :: !FileName -> !(DirPatchType wX wY) -> Prim wX wY
FP :: !FileName -> !(FilePatchType wX wY) -> Prim wX wY
ChangePref :: !String -> !String -> !String -> Prim wX wY
data DirPatchType wX wY
RmDir :: DirPatchType wX wY
AddDir :: DirPatchType wX wY
data FilePatchType wX wY
RmFile :: FilePatchType wX wY
AddFile :: FilePatchType wX wY
Hunk :: !Int -> [ByteString] -> [ByteString] -> FilePatchType wX wY
TokReplace :: !String -> !String -> !String -> FilePatchType wX wY
Binary :: ByteString -> ByteString -> FilePatchType wX wY
isIdentity :: Prim wX wY -> EqCheck wX wY

-- | <a>comparePrim</a> <tt>p1 p2</tt> is used to provide an arbitrary
--   ordering between <tt>p1</tt> and <tt>p2</tt>. Basically, identical
--   patches are equal and <tt>Move &lt; DP &lt; FP &lt; ChangePref</tt>.
--   Everything else is compared in dictionary order of its arguments.
comparePrim :: Prim wX wY -> Prim wW wZ -> Ordering
instance Eq (FilePatchType wX wY)
instance Ord (FilePatchType wX wY)
instance Eq (DirPatchType wX wY)
instance Ord (DirPatchType wX wY)
instance Eq (Prim wX wY)
instance MyEq Prim
instance PatchDebug Prim
instance PatchInspect Prim
instance Invert Prim
instance IsHunk Prim
instance PrimConstruct Prim
instance PrimClassify Prim
instance MyEq DirPatchType
instance MyEq FilePatchType

module Darcs.Patch.Prim.V1.Commute
data Perhaps a
Unknown :: Perhaps a
Failed :: Perhaps a
Succeeded :: a -> Perhaps a
subcommutes :: [(String, WrappedCommuteFunction)]
newtype WrappedCommuteFunction
WrappedCommuteFunction :: CommuteFunction -> WrappedCommuteFunction
runWrappedCommuteFunction :: WrappedCommuteFunction -> CommuteFunction
instance Commute Prim
instance MonadPlus Perhaps
instance Alternative Perhaps
instance Monad Perhaps
instance Applicative Perhaps
instance Functor Perhaps

module Darcs.Patch.Prim.V1.Details
instance PrimDetails Prim

module Darcs.Patch.Prim.V1.Read
instance PrimRead Prim
instance ReadPatch Prim

module Darcs.Patch.Prim.V3.Core
data Prim wX wY
BinaryHunk :: !UUID -> Hunk wX wY -> Prim wX wY
TextHunk :: !UUID -> Hunk wX wY -> Prim wX wY
Manifest :: !UUID -> Location -> Prim wX wY
Demanifest :: !UUID -> Location -> Prim wX wY
Move :: !UUID -> Location -> Location -> Prim wX wY
Identity :: Prim wX wX
data Hunk wX wY
Hunk :: !Int -> ByteString -> ByteString -> Hunk wX wY
newtype UUID
UUID :: ByteString -> UUID
type Location = (UUID, ByteString)
data Object (m :: * -> *)
Directory :: DirContent -> Object
Blob :: (m ByteString) -> !Hash -> Object
touches :: Prim wX wY -> [UUID]
hunkEdit :: Hunk wX wY -> ByteString -> ByteString
instance Show (Prim wX wY)
instance Show (Hunk wX wY)
instance Eq (Prim wX wY)
instance MyEq Prim
instance PatchInspect Prim
instance Invert Prim
instance IsHunk Prim
instance PrimConstruct Prim
instance PrimClassify Prim
instance Show2 Prim
instance Show1 (Prim wX)
instance MyEq Hunk
instance Show2 Hunk
instance Show1 (Hunk wX)

module Darcs.Patch.Prim.V3.Coalesce
instance PrimCanonize Prim

module Darcs.Patch.Prim.V3.Commute
class Monad m => CommuteMonad m
commuteFail :: CommuteMonad m => m a
instance Commute' Prim
instance Commute Prim
instance CommuteMonad Maybe

module Darcs.Patch.Prim.V3.Details
instance PrimDetails Prim

module Darcs.Patch.Prim.V3.Read
instance ReadPatch Prim
instance PrimRead Prim

module Darcs.Patch.Prim.V3.Show
showHunk :: String -> UUID -> Hunk wX wY -> Doc
instance PrimShow Prim
instance ShowPatch Prim
instance ShowPatchBasic Prim
instance PatchListFormat Prim

module Darcs.Patch.Viewing
showContextHunk :: ApplyMonad m Tree => FileHunk wX wY -> m Doc
showContextSeries :: (Apply p, ShowPatch p, IsHunk p, ApplyMonadTrans m (ApplyState p), ApplyMonad m (ApplyState p)) => FL p wX wY -> m Doc
instance (Apply p, IsHunk p, PatchListFormat p, ShowPatch p) => ShowPatch (RL p)
instance (PatchListFormat p, ShowPatchBasic p) => ShowPatchBasic (RL p)
instance (Apply p, IsHunk p, PatchListFormat p, ShowPatch p) => ShowPatch (FL p)
instance (PatchListFormat p, ShowPatchBasic p) => ShowPatchBasic (FL p)

module Darcs.Patch.Named

-- | The <tt>Named</tt> type adds a patch info about a patch, that is a
--   name.
--   
--   <tt>NamedP info deps p</tt> represents patch <tt>p</tt> with name
--   <tt>info</tt>. <tt>deps</tt> is a list of dependencies added at the
--   named patch level, compared with the unnamed level (ie, dependencies
--   added with <tt>darcs record --ask-deps</tt>).
data Named p wX wY
NamedP :: !PatchInfo -> ![PatchInfo] -> !(FL p wX wY) -> Named p wX wY
infopatch :: PatchInfo -> FL p wX wY -> Named p wX wY
adddeps :: Named p wX wY -> [PatchInfo] -> Named p wX wY
namepatch :: String -> String -> String -> [String] -> FL p wX wY -> IO (Named p wX wY)
anonymous :: FL p wX wY -> IO (Named p wX wY)
getdeps :: Named p wX wY -> [PatchInfo]
patch2patchinfo :: Named p wX wY -> PatchInfo
patchname :: Named p wX wY -> String
patchcontents :: Named p wX wY -> FL p wX wY
fmapNamed :: (forall wA wB. p wA wB -> q wA wB) -> Named p wX wY -> Named q wX wY
fmapFL_Named :: (FL p wA wB -> FL q wC wD) -> Named p wA wB -> Named q wC wD
commuterIdNamed :: CommuteFn p1 p2 -> CommuteFn p1 (Named p2)
commuterNamedId :: CommuteFn p1 p2 -> CommuteFn (Named p1) p2
mergerIdNamed :: MergeFn p1 p2 -> MergeFn p1 (Named p2)
instance Show2 p => Show (Named p wX wY)
instance PatchDebug p => PatchDebug (Named p)
instance Show2 p => Show2 (Named p)
instance Show2 p => Show1 (Named p wX)
instance (Apply p, CommuteNoConflicts p, Conflict p, IsHunk p, PatchListFormat p, PrimPatchBase p, ShowPatch p) => ShowPatch (Named p)
instance (PatchListFormat p, ShowPatchBasic p) => ShowPatchBasic (Named p)
instance Check p => Check (Named p)
instance (CommuteNoConflicts p, Conflict p) => Conflict (Named p)
instance PatchInspect p => PatchInspect (Named p)
instance (Merge p, NameHack p) => Merge (Named p)
instance (Commute p, NameHack p) => Commute (Named p)
instance Invert p => Invert (Named p)
instance (Commute p, MyEq p) => MyEq (Named p)
instance RepairToFL p => Repair (Named p)
instance Apply p => Apply (Named p)
instance (ReadPatch p, PatchListFormat p) => ReadPatch (Named p)
instance PatchListFormat (Named p)
instance IsHunk (Named p)
instance Effect p => Effect (Named p)
instance PrimPatchBase p => PrimPatchBase (Named p)

module Darcs.Patch.Rebase.Name

-- | A <a>RebaseName</a> encapsulates the concept of the name of a patch,
--   without any contents. This allows us to track explicit dependencies in
--   the rebase state, changing them to follow uses of amend-record or
--   unsuspend on a depended-on patch, and warning the user if any are lost
--   entirely.
data RebaseName (p :: * -> * -> *) wX wY
AddName :: PatchInfo -> RebaseName p wX wY
DelName :: PatchInfo -> RebaseName p wX wY
Rename :: PatchInfo -> PatchInfo -> RebaseName p wX wY

-- | Commute a name patch and a primitive patch. They trivially commute so
--   this just involves changing the witnesses.
commuteNamePrim :: PrimPatchBase p => (RebaseName p :> PrimOf p) wX wY -> (PrimOf p :> RebaseName p) wX wY

-- | Commute a primitive patch and a name patch. They trivially commute so
--   this just involves changing the witnesses.
commutePrimName :: PrimPatchBase p => (PrimOf p :> RebaseName p) wX wY -> (RebaseName p :> PrimOf p) wX wY

-- | Commute a name patch and a named patch. In most cases this is trivial
--   but we do need to check explicit dependencies.
commuteNameNamed :: Invert p => CommuteFn (RebaseName p) (Named p)

-- | Commute a named patch and a name patch. In most cases this is trivial
--   but we do need to check explicit dependencies.
commuteNamedName :: Invert p => CommuteFn (Named p) (RebaseName p)
instance Show (RebaseName p wX wY)
instance MyEq (RebaseName p)
instance Effect (RebaseName p)
instance PrimPatchBase p => PrimPatchBase (RebaseName p)
instance Apply p => Patchy (RebaseName p)
instance Apply p => Apply (RebaseName p)
instance PatchInspect (RebaseName p)
instance Invert (RebaseName p)
instance Commute (RebaseName p)
instance ReadPatch (RebaseName p)
instance ShowPatch (RebaseName p)
instance ShowPatchBasic (RebaseName p)
instance Show2 (RebaseName p)
instance Show1 (RebaseName p wX)

module Darcs.Patch.Patchy.Instances
instance (IsHunk p, PatchListFormat p, Patchy p) => Patchy (RL p)
instance (IsHunk p, PatchListFormat p, Patchy p) => Patchy (FL p)

module Darcs.Patch.Split

-- | A splitter is something that can take a patch and (possibly) render it
--   as text in some format of its own choosing. This text can then be
--   presented to the user for editing, and the result given to the
--   splitter for parsing. If the parse succeeds, the result is a list of
--   patches that could replace the original patch in any context.
--   Typically this list will contain the changed version of the patch,
--   along with fixup pieces to ensure that the overall effect of the list
--   is the same as the original patch. The individual elements of the list
--   can then be offered separately to the user, allowing them to accept
--   some and reject others.
--   
--   There's no immediate application for a splitter for anything other
--   than Prim (you shouldn't go editing named patches, you'll break them!)
--   However you might want to compose splitters for FilePatchType to make
--   splitters for Prim etc, and the generality doesn't cost anything.
data Splitter p
Splitter :: (forall wX wY. DiffAlgorithm -> p wX wY -> Maybe (ByteString, ByteString -> Maybe (FL p wX wY))) -> (forall wX wY. DiffAlgorithm -> FL p wX wY -> FL p wX wY) -> Splitter p
applySplitter :: Splitter p -> forall wX wY. DiffAlgorithm -> p wX wY -> Maybe (ByteString, ByteString -> Maybe (FL p wX wY))
canonizeSplit :: Splitter p -> forall wX wY. DiffAlgorithm -> FL p wX wY -> FL p wX wY

-- | This generic splitter just lets the user edit the printed
--   representation of the patch Should not be used expect for testing and
--   experimentation.
rawSplitter :: (ShowPatch p, ReadPatch p, Invert p) => Splitter p

-- | Never splits. In other code we normally pass around Maybe Splitter
--   instead of using this as the default, because it saves clients that
--   don't care about splitting from having to import this module just to
--   get noSplitter.
noSplitter :: Splitter p

-- | Split a primitive hunk patch up by allowing the user to edit both the
--   before and after lines, then insert fixup patches to clean up the
--   mess.
primSplitter :: PrimPatch p => Splitter p
reversePrimSplitter :: PrimPatch prim => Splitter prim

module Darcs.Patch.V2.Non

-- | A <a>Non</a> stores a context with a <tt>Prim</tt> patch. It is a
--   patch whose effect isn't visible - a Non-affecting patch.
data Non p wX
Non :: FL p wX wY -> PrimOf p wY wZ -> Non p wX

-- | Nonable represents the class of patches that can be turned into a Non.
class Nonable p
non :: Nonable p => p wX wY -> Non p wX

-- | unNon converts a Non into a FL of its context followed by the
--   primitive patch.
unNon :: FromPrim p => Non p wX -> Sealed (FL p wX)

-- | showNon creates a Doc representing a Non.
showNon :: (ShowPatchBasic p, PatchListFormat p, PrimPatchBase p) => Non p wX -> Doc

-- | showNons creates a Doc representing a list of Nons.
showNons :: (ShowPatchBasic p, PatchListFormat p, PrimPatchBase p) => [Non p wX] -> Doc

-- | readNon is a parser that attempts to read a single Non.
readNon :: (ReadPatch p, PatchListFormat p, PrimPatchBase p, ParserM m) => m (Non p wX)

-- | readNons is a parser that attempts to read a list of Nons.
readNons :: (ReadPatch p, PatchListFormat p, PrimPatchBase p, ParserM m) => m [Non p wX]

-- | commutePrimsOrAddToCtx takes a WL of prims and attempts to commute
--   them past a Non.
commutePrimsOrAddToCtx :: (WL l, Patchy p, ToFromPrim p) => l (PrimOf p) wX wY -> Non p wY -> Non p wX

-- | <a>commuteOrAddToCtx</a> <tt>x cy</tt> tries to commute <tt>x</tt>
--   past <tt>cy</tt> and always returns some variant <tt>cy'</tt>. If
--   commutation suceeds, the variant is just straightforwardly the
--   commuted version. If commutation fails, the variant consists of
--   <tt>x</tt> prepended to the context of <tt>cy</tt>.
commuteOrAddToCtx :: (Patchy p, ToFromPrim p) => p wX wY -> Non p wY -> Non p wX

-- | commuteOrRemFromCtx attempts to remove a given patch from a Non. If
--   the patch was not in the Non, then the commute will succeed and the
--   modified Non will be returned. If the commute fails then the patch is
--   either in the Non context, or the Non patch itself; we attempt to
--   remove the patch from the context and then return the non with the
--   updated context.
--   
--   TODO: understand if there is any case where p is equal to the prim
--   patch of the Non, in which case, we return the original Non, is that
--   right?
commuteOrRemFromCtx :: (Patchy p, MyEq p, ToFromPrim p) => p wX wY -> Non p wX -> Maybe (Non p wY)

-- | <a>commuteOrAddToCtxRL</a> <tt>xs cy</tt> commutes as many patches of
--   <tt>xs</tt> past <tt>cy</tt> as possible, adding any that don't
--   commute to the context of cy. Suppose we have
--   
--   <pre>
--   x1 x2 x3 [c1 c2 y]
--   </pre>
--   
--   and that in our example <tt>x1</tt> fails to commute past <tt>c1</tt>,
--   this function would commute down to
--   
--   <pre>
--   x1 [c1'' c2'' y''] x2' x3'
--   </pre>
--   
--   and return <tt>[x1 c1'' c2'' y'']</tt>
commuteOrAddToCtxRL :: (Patchy p, ToFromPrim p) => RL p wX wY -> Non p wY -> Non p wX

-- | commuteOrRemFromCtxFL attempts to remove a FL of patches from a Non,
--   returning Nothing if any of the individual removes fail.
commuteOrRemFromCtxFL :: (Patchy p, MyEq p, ToFromPrim p) => FL p wX wY -> Non p wX -> Maybe (Non p wY)
remNons :: (Nonable p, Effect p, Patchy p, MyEq p, ToFromPrim p, PrimPatchBase p, MyEq (PrimOf p)) => [Non p wX] -> Non p wX -> Non p wX

-- | (*&gt;) attemts to modify a Non by commuting it past a given patch.
(*>) :: (Patchy p, ToFromPrim p) => Non p wX -> p wX wY -> Maybe (Non p wY)

-- | (&gt;*) attempts to modify a Non, by commuting a given patch past it.
(>*) :: (Patchy p, ToFromPrim p) => p wX wY -> Non p wY -> Maybe (Non p wX)

-- | (*&gt;&gt;) attempts to modify a Non by commuting it past a given WL
--   of patches.
(*>>) :: (WL l, Patchy p, ToFromPrim p, PrimPatchBase p) => Non p wX -> l (PrimOf p) wX wY -> Maybe (Non p wY)

-- | (&gt;&gt;*) attempts to modify a Non by commuting a given WL of
--   patches past it.
(>>*) :: (WL l, Patchy p, ToFromPrim p) => l (PrimOf p) wX wY -> Non p wY -> Maybe (Non p wX)
instance WL RL
instance WL FL
instance (Commute p, MyEq p, MyEq (PrimOf p)) => Eq (Non p wX)
instance (Show2 p, Show2 (PrimOf p)) => Show1 (Non p)
instance (Show2 p, Show2 (PrimOf p)) => Show (Non p wX)

module Darcs.Patch.Prim.V1.Show
showHunk :: FileNameFormat -> FileName -> Int -> [ByteString] -> [ByteString] -> Doc
instance PrimShow Prim
instance Show (DirPatchType wX wY)
instance Show (FilePatchType wX wY)
instance Show1 (Prim wX)
instance Show2 Prim
instance Show (Prim wX wY)
instance ApplyState Prim ~ Tree => ShowPatch Prim
instance ShowPatchBasic Prim
instance PatchListFormat Prim

module Darcs.Patch.Prim.V1.Apply
instance PrimApply Prim
instance RepairToFL Prim
instance Apply Prim

module Darcs.Patch.Prim.V1.Coalesce
instance Show (Simple wX wY)
instance PrimCanonize Prim

module Darcs.Patch.Prim.V1
data Prim wX wY
instance FromPrim Prim
instance PrimPatchBase Prim
instance Patchy Prim
instance PrimPatch Prim

module Darcs.Patch.Prim.V3.Apply
data ObjectMap (m :: * -> *)
ObjectMap :: (UUID -> m (Maybe (Object m))) -> (UUID -> Object m -> m (ObjectMap m)) -> m [UUID] -> ObjectMap
getObject :: ObjectMap -> UUID -> m (Maybe (Object m))
putObject :: ObjectMap -> UUID -> Object m -> m (ObjectMap m)
listObjects :: ObjectMap -> m [UUID]
instance (Functor m, Monad m) => ApplyMonadTrans m ObjectMap
instance (Functor m, Monad m) => ApplyMonad (StateT (ObjectMap m) m) ObjectMap
instance ToTree ObjectMap
instance PrimApply Prim
instance RepairToFL Prim
instance Apply Prim

module Darcs.Patch.Prim.V3
data Prim wX wY
instance FromPrim Prim
instance PrimPatchBase Prim
instance Patchy Prim
instance PrimPatch Prim

module Darcs.Patch.Rebase.Fixup

-- | A single rebase fixup, needed to ensure that the actual patches being
--   stored in the rebase state have the correct context.
data RebaseFixup p wX wY
PrimFixup :: PrimOf p wX wY -> RebaseFixup p wX wY
NameFixup :: RebaseName p wX wY -> RebaseFixup p wX wY
commuteNamedFixup :: (FromPrim p, Effect p, Commute p, Invert p) => (Named p :> RebaseFixup p) wX wY -> Maybe ((FL (RebaseFixup p) :> Named p) wX wY)
commuteFixupNamed :: (FromPrim p, Effect p, Commute p, Invert p) => (RebaseFixup p :> Named p) wX wY -> Maybe ((Named p :> FL (RebaseFixup p)) wX wY)
commuteNamedFixups :: (FromPrim p, Effect p, Commute p, Invert p) => (Named p :> FL (RebaseFixup p)) wX wY -> Maybe ((FL (RebaseFixup p) :> Named p) wX wY)

-- | Split a sequence of fixups into names and prims
flToNamesPrims :: PrimPatchBase p => FL (RebaseFixup p) wX wY -> (FL (RebaseName p) :> FL (PrimOf p)) wX wY
instance PrimPatchBase p => Commute (RebaseFixup p)
instance PatchInspect (PrimOf p) => PatchInspect (RebaseFixup p)
instance Invert (PrimOf p) => Invert (RebaseFixup p)
instance MyEq (PrimOf p) => MyEq (RebaseFixup p)
instance Effect (RebaseFixup p)
instance (PrimPatchBase p, Apply p, ApplyState p ~ ApplyState (PrimOf p)) => Apply (RebaseFixup p)
instance PrimPatchBase p => PrimPatchBase (RebaseFixup p)
instance Show2 (PrimOf p) => Show2 (RebaseFixup p)
instance Show2 (PrimOf p) => Show1 (RebaseFixup p wX)
instance Show2 (PrimOf p) => Show (RebaseFixup p wX wY)

module Darcs.Patch.Rebase.Recontext

-- | Some non-rebase code needs to manipulate the rebase state if one
--   exists. This class provides the hook for them to do so without needing
--   to explicitly detect that there is a rebase state:
--   <a>recontextRebase</a> abstracts out that information.
--   
--   The hook is used in amend-record - look there for an explanation of
--   how.
--   
--   There is a default so that other patch types only need to declare the
--   instance.
class RecontextRebase p where recontextRebase = Nothing
recontextRebase :: RecontextRebase p => Maybe (RecontextRebase1 p)

-- | Check whether a given patch is a suspended rebase patch, and if so
--   provide evidence that the start and end contexts are the same (from
--   the point of view of the containing repo), and return a function that
--   produces a new version with some fixups added.
--   
--   Nested in a type to avoid needing an impredicative argument to
--   <a>Maybe</a>.
newtype RecontextRebase1 p
RecontextRebase1 :: (forall wY wZ. Named p wY wZ -> (EqCheck wY wZ, RecontextRebase2 p wY wZ)) -> RecontextRebase1 p
recontextFunc1 :: RecontextRebase1 p -> forall wY wZ. Named p wY wZ -> (EqCheck wY wZ, RecontextRebase2 p wY wZ)

-- | Return a suspended patch with the given fixups added.
--   
--   Nested in a type to avoid needing an impredicative argument to a
--   tuple.
newtype RecontextRebase2 p wY wZ
RecontextRebase2 :: (forall wX. FL (RebaseFixup p) wX wY -> IO (Named p wX wX)) -> RecontextRebase2 p wY wZ
recontextFunc2 :: RecontextRebase2 p wY wZ -> forall wX. FL (RebaseFixup p) wX wY -> IO (Named p wX wX)

module Darcs.Patch.RepoPatch
class (Patchy p, Merge p, Effect p, IsHunk p, PatchInspect p, ReadPatch p, ShowPatch p, FromPrim p, Conflict p, CommuteNoConflicts p, Check p, RepairToFL p, PatchListFormat p, PrimPatchBase p, Patchy (PrimOf p), IsHunk (PrimOf p), MaybeInternal p, RecontextRebase p, NameHack p, Matchable p) => RepoPatch p

module Darcs.Patch.Dummy
data DummyPatch wX wY
instance PatchDebug DummyPatch
instance RepoPatch DummyPatch
instance RecontextRebase DummyPatch
instance NameHack DummyPatch
instance MaybeInternal DummyPatch
instance PrimPatchBase DummyPatch
instance RepairToFL DummyPatch
instance Check DummyPatch
instance CommuteNoConflicts DummyPatch
instance FromPrim DummyPatch
instance Conflict DummyPatch
instance Merge DummyPatch
instance Effect DummyPatch
instance Patchy DummyPatch
instance Matchable DummyPatch
instance Apply DummyPatch
instance Commute DummyPatch
instance ShowPatch DummyPatch
instance ShowPatchBasic DummyPatch
instance ReadPatch DummyPatch
instance PatchInspect DummyPatch
instance Invert DummyPatch
instance MyEq DummyPatch
instance PatchListFormat DummyPatch
instance IsHunk DummyPatch
instance PatchDebug DummyPrim
instance PrimPatch DummyPrim
instance PrimApply DummyPrim
instance PrimRead DummyPrim
instance PrimShow DummyPrim
instance PrimDetails DummyPrim
instance PrimClassify DummyPrim
instance PrimCanonize DummyPrim
instance PrimConstruct DummyPrim
instance RepairToFL DummyPrim
instance Patchy DummyPrim
instance Apply DummyPrim
instance Commute DummyPrim
instance ShowPatch DummyPrim
instance ShowPatchBasic DummyPrim
instance ReadPatch DummyPrim
instance PatchInspect DummyPrim
instance Invert DummyPrim
instance MyEq DummyPrim
instance PatchListFormat DummyPrim
instance IsHunk DummyPrim

module Darcs.Patch.V1.Core

-- | The format of a merger is <tt>Merger undos unwindings conflicting
--   original</tt>.
--   
--   <tt>undos</tt> = the effect of the merger
--   
--   <tt>unwindings</tt> = TODO: eh?
--   
--   <tt>conflicting</tt> = the patch we conflict with
--   
--   <tt>original</tt> = the patch we really are
data Patch prim wX wY
PP :: prim wX wY -> Patch prim wX wY
Merger :: FL (Patch prim) wX wY -> RL (Patch prim) wX wB -> Patch prim wC wB -> Patch prim wC wD -> Patch prim wX wY
Regrem :: FL (Patch prim) wX wY -> RL (Patch prim) wX wB -> Patch prim wC wB -> Patch prim wC wA -> Patch prim wY wX
isMerger :: Patch prim wA wB -> Bool
mergerUndo :: Patch prim wX wY -> FL (Patch prim) wX wY
instance PatchDebug prim => PatchDebug (Patch prim)
instance Check (Patch prim)
instance PatchListFormat (Patch prim)
instance FromPrim (Patch prim)
instance PrimPatch prim => PrimPatchBase (Patch prim)
instance RecontextRebase (Patch prim)
instance NameHack (Patch prim)
instance MaybeInternal (Patch prim)
instance Show2 prim => Show2 (Patch prim)
instance Show2 prim => Show1 (Patch prim wX)
instance Show2 prim => Show (Patch prim wX wY)

module Darcs.Patch.V1.Show
showPatch_ :: PrimPatch prim => Patch prim wA wB -> Doc

module Darcs.Patch.V1.Commute
merge :: Merge p => (p :\/: p) wX wY -> (p :/\: p) wX wY

-- | merger takes two patches, (which have been determined to conflict) and
--   constructs a Merger patch to represent the conflict. <tt>p1</tt> is
--   considered to be conflicting with <tt>p2</tt> (<tt>p1</tt> is the
--   "first" patch in the repo ordering), the resulting Merger is therefore
--   a representation of <tt>p2</tt>.
merger :: PrimPatch prim => String -> Patch prim wX wY -> Patch prim wX wZ -> Sealed (Patch prim wY)
unravel :: PrimPatch prim => Patch prim wX wY -> [Sealed (FL prim wX)]
publicUnravel :: PrimPatch prim => Patch prim wX wY -> [Sealed (FL prim wY)]
instance MyEq prim => Eq (Patch prim wX wY)
instance MyEq prim => MyEq (Patch prim)
instance Invert prim => Invert (Patch prim)
instance IsHunk prim => IsHunk (Patch prim)
instance PrimPatch prim => Effect (Patch prim)
instance PrimPatch prim => Conflict (Patch prim)
instance PrimPatch prim => CommuteNoConflicts (Patch prim)
instance PrimPatch prim => PatchInspect (Patch prim)
instance PrimPatch prim => Commute (Patch prim)
instance PrimPatch prim => Merge (Patch prim)
instance MonadPlus Perhaps
instance Alternative Perhaps
instance Monad Perhaps
instance Applicative Perhaps
instance Functor Perhaps

module Darcs.Patch.V1.Read
instance PrimPatch prim => ReadPatch (Patch prim)

module Darcs.Patch.V2.Real

-- | <a>RealPatch</a> is used to represents prim patches that are
--   duplicates of, or conflict with, another prim patch in the repository.
--   
--   <tt>Normal prim</tt>: A primitive patch
--   
--   <tt>Duplicate x</tt>: This patch has no effect since <tt>x</tt> is
--   already present in the repository.
--   
--   <pre>
--   Etacilpud x: invert (Duplicate x)
--   </pre>
--   
--   <tt>Conflictor ix xx x</tt>: <tt>ix</tt> is the set of patches: * that
--   conflict with <tt>x</tt> and also conflict with another patch in the
--   repository. * that conflict with a patch that conflict with <tt>x</tt>
--   
--   <tt>xx</tt> is the sequence of patches that conflict *only* with
--   <tt>x</tt>
--   
--   <tt>x</tt> is the original, conflicting patch.
--   
--   <tt>ix</tt> and <tt>x</tt> are stored as <tt>Non</tt> objects, which
--   include any necessary context to uniquely define the patch that is
--   referred to.
--   
--   The intuition is that a Conflictor should have the effect of inverting
--   any patches that <tt>x</tt> conflicts with, that haven't already been
--   undone by another Conflictor in the repository. Therefore, the effect
--   of a Conflictor is <tt>invert xx</tt>.
--   
--   <tt>InvConflictor ix xx x</tt>: like <tt>invert (Conflictor ix xx
--   x)</tt>
data RealPatch prim wX wY
Duplicate :: Non (RealPatch prim) wX -> RealPatch prim wX wX
Etacilpud :: Non (RealPatch prim) wX -> RealPatch prim wX wX
Normal :: prim wX wY -> RealPatch prim wX wY
Conflictor :: [Non (RealPatch prim) wX] -> FL prim wX wY -> Non (RealPatch prim) wX -> RealPatch prim wY wX
InvConflictor :: [Non (RealPatch prim) wX] -> FL prim wX wY -> Non (RealPatch prim) wX -> RealPatch prim wX wY
prim2real :: prim wX wY -> RealPatch prim wX wY

-- | This is used for unit-testing and for internal sanity checks
isConsistent :: PrimPatch prim => RealPatch prim wX wY -> Maybe Doc

-- | <a>isForward</a> <tt>p</tt> is <tt>True</tt> if <tt>p</tt> is either
--   an <a>InvConflictor</a> or <a>Etacilpud</a>.
isForward :: PrimPatch prim => RealPatch prim wS wY -> Maybe Doc

-- | <a>isDuplicate</a> <tt>p</tt> is <tt>True</tt> if <tt>p</tt> is either
--   a <a>Duplicate</a> or <a>Etacilpud</a> patch.
isDuplicate :: RealPatch prim wS wY -> Bool

-- | <a>mergeUnravelled</a> is used when converting from Darcs V1 patches
--   (Mergers) to Darcs V2 patches (Conflictors).
mergeUnravelled :: PrimPatch prim => [Sealed ((FL prim) wX)] -> Maybe (FlippedSeal (RealPatch prim) wX)
instance IsHunk prim => IsHunk (RealPatch prim)
instance PrimPatch prim => Effect (RealPatch prim)
instance PrimPatch prim => Nonable (RealPatch prim)
instance Show2 prim => Show2 (RealPatch prim)
instance Show2 prim => Show1 (RealPatch prim wX)
instance Show2 prim => Show (RealPatch prim wX wY)
instance PrimPatch prim => ReadPatch (RealPatch prim)
instance PrimPatch prim => ShowPatch (RealPatch prim)
instance PrimPatch prim => ShowPatchBasic (RealPatch prim)
instance PatchListFormat (RealPatch prim)
instance PrimPatch prim => RepairToFL (RealPatch prim)
instance PrimPatch prim => Apply (RealPatch prim)
instance PatchInspect prim => PatchInspect (RealPatch prim)
instance PrimPatch prim => Merge (RealPatch prim)
instance PrimPatch prim => Commute (RealPatch prim)
instance Invert prim => Invert (RealPatch prim)
instance PrimPatch prim => MyEq (RealPatch prim)
instance ToFromPrim (RealPatch prim)
instance FromPrim (RealPatch prim)
instance PrimPatch prim => Check (RealPatch prim)
instance PrimPatch prim => CommuteNoConflicts (RealPatch prim)
instance PrimPatch prim => Conflict (RealPatch prim)
instance PatchDebug prim => PatchDebug (RealPatch prim)
instance PrimPatch prim => Patchy (RealPatch prim)
instance RecontextRebase (RealPatch prim)
instance NameHack (RealPatch prim)
instance MaybeInternal (RealPatch prim)
instance PrimPatch prim => PrimPatchBase (RealPatch prim)

module Darcs.Patch.V2

-- | <a>RealPatch</a> is used to represents prim patches that are
--   duplicates of, or conflict with, another prim patch in the repository.
--   
--   <tt>Normal prim</tt>: A primitive patch
--   
--   <tt>Duplicate x</tt>: This patch has no effect since <tt>x</tt> is
--   already present in the repository.
--   
--   <pre>
--   Etacilpud x: invert (Duplicate x)
--   </pre>
--   
--   <tt>Conflictor ix xx x</tt>: <tt>ix</tt> is the set of patches: * that
--   conflict with <tt>x</tt> and also conflict with another patch in the
--   repository. * that conflict with a patch that conflict with <tt>x</tt>
--   
--   <tt>xx</tt> is the sequence of patches that conflict *only* with
--   <tt>x</tt>
--   
--   <tt>x</tt> is the original, conflicting patch.
--   
--   <tt>ix</tt> and <tt>x</tt> are stored as <tt>Non</tt> objects, which
--   include any necessary context to uniquely define the patch that is
--   referred to.
--   
--   The intuition is that a Conflictor should have the effect of inverting
--   any patches that <tt>x</tt> conflicts with, that haven't already been
--   undone by another Conflictor in the repository. Therefore, the effect
--   of a Conflictor is <tt>invert xx</tt>.
--   
--   <tt>InvConflictor ix xx x</tt>: like <tt>invert (Conflictor ix xx
--   x)</tt>
data RealPatch prim wX wY
prim2real :: prim wX wY -> RealPatch prim wX wY
instance PrimPatch prim => RepoPatch (RealPatch prim)
instance PrimPatch prim => Matchable (RealPatch prim)

module Darcs.Patch.V1.Apply
instance PrimPatch prim => RepairToFL (Patch prim)
instance PrimPatch prim => Apply (Patch prim)

module Darcs.Patch.V1.Viewing
instance PrimPatch prim => ShowPatch (Patch prim)
instance PrimPatch prim => ShowPatchBasic (Patch prim)

module Darcs.Patch.V1

-- | The format of a merger is <tt>Merger undos unwindings conflicting
--   original</tt>.
--   
--   <tt>undos</tt> = the effect of the merger
--   
--   <tt>unwindings</tt> = TODO: eh?
--   
--   <tt>conflicting</tt> = the patch we conflict with
--   
--   <tt>original</tt> = the patch we really are
data Patch prim wX wY
instance PrimPatch prim => RepoPatch (Patch prim)
instance PrimPatch prim => Matchable (Patch prim)
instance PrimPatch prim => Patchy (Patch prim)

module Darcs.Patch
class (Patchy p, Merge p, Effect p, IsHunk p, PatchInspect p, ReadPatch p, ShowPatch p, FromPrim p, Conflict p, CommuteNoConflicts p, Check p, RepairToFL p, PatchListFormat p, PrimPatchBase p, Patchy (PrimOf p), IsHunk (PrimOf p), MaybeInternal p, RecontextRebase p, NameHack p, Matchable p) => RepoPatch p

-- | The <tt>Named</tt> type adds a patch info about a patch, that is a
--   name.
--   
--   <tt>NamedP info deps p</tt> represents patch <tt>p</tt> with name
--   <tt>info</tt>. <tt>deps</tt> is a list of dependencies added at the
--   named patch level, compared with the unnamed level (ie, dependencies
--   added with <tt>darcs record --ask-deps</tt>).
data Named p wX wY
class (Apply p, Commute p, Invert p) => Patchy p
fromPrim :: FromPrim p => PrimOf p wX wY -> p wX wY
fromPrims :: FromPrims p => FL (PrimOf p) wX wY -> p wX wY
rmfile :: PrimConstruct prim => FilePath -> prim wX wY
addfile :: PrimConstruct prim => FilePath -> prim wX wY
rmdir :: PrimConstruct prim => FilePath -> prim wX wY
adddir :: PrimConstruct prim => FilePath -> prim wX wY
move :: PrimConstruct prim => FilePath -> FilePath -> prim wX wY
hunk :: PrimConstruct prim => FilePath -> Int -> [ByteString] -> [ByteString] -> prim wX wY
tokreplace :: PrimConstruct prim => FilePath -> String -> String -> String -> prim wX wY
namepatch :: String -> String -> String -> [String] -> FL p wX wY -> IO (Named p wX wY)
anonymous :: FL p wX wY -> IO (Named p wX wY)
binary :: PrimConstruct prim => FilePath -> ByteString -> ByteString -> prim wX wY
description :: ShowPatch p => p wX wY -> Doc

-- | showContextPatch is used to add context to a patch, as diff -u does.
--   Thus, it differs from showPatch only for hunks. It is used for
--   instance before putting it into a bundle. As this unified context is
--   not included in patch representation, this requires access to the
--   tree.
showContextPatch :: (ShowPatch p, Monad m, ApplyMonadTrans m (ApplyState p), ApplyMonad m (ApplyState p)) => p wX wY -> m Doc
showPatch :: ShowPatchBasic p => p wX wY -> Doc
showNicely :: ShowPatch p => p wX wY -> Doc
infopatch :: PatchInfo -> FL p wX wY -> Named p wX wY
changepref :: PrimConstruct prim => String -> String -> String -> prim wX wY
thing :: ShowPatch p => p wX wY -> String
things :: ShowPatch p => p wX wY -> String
primIsAddfile :: PrimClassify prim => prim wX wY -> Bool
primIsHunk :: PrimClassify prim => prim wX wY -> Bool
primIsSetpref :: PrimClassify prim => prim wX wY -> Bool
merge :: Merge p => (p :\/: p) wX wY -> (p :/\: p) wX wY
commute :: Commute p => (p :> p) wX wY -> Maybe ((p :> p) wX wY)
listTouchedFiles :: PatchInspect p => p wX wY -> [FilePath]
hunkMatches :: PatchInspect p => (ByteString -> Bool) -> p wX wY -> Bool

-- | forceTokReplace replaces all occurrences of the old token with the new
--   token, throughout the input ByteString.
forceTokReplace :: String -> ByteString -> ByteString -> ByteString -> ByteString
class (Patchy prim, MyEq prim, PatchListFormat prim, IsHunk prim, RepairToFL prim, PatchInspect prim, ReadPatch prim, ShowPatch prim, PrimConstruct prim, PrimCanonize prim, PrimClassify prim, PrimDetails prim, PrimShow prim, PrimRead prim, PrimApply prim) => PrimPatch prim
resolveConflicts :: Conflict p => p wX wY -> [[Sealed (FL (PrimOf p) wY)]]

-- | Patches whose concrete effect which can be expressed as a list of
--   primitive patches.
--   
--   A minimal definition would be either of <tt>effect</tt> or
--   <tt>effectRL</tt>.
class Effect p where effect = reverseRL . effectRL effectRL = reverseFL . effect
effect :: Effect p => p wX wY -> FL (PrimOf p) wX wY
primIsBinary :: PrimClassify prim => prim wX wY -> Bool
primIsAdddir :: PrimClassify prim => prim wX wY -> Bool
invert :: Invert p => p wX wY -> p wY wX
invertFL :: Invert p => FL p wX wY -> RL p wY wX
invertRL :: Invert p => RL p wX wY -> FL p wY wX

-- | <a>commuteFLorComplain</a> attempts to commute a single element past a
--   FL. If any individual commute fails, then we return the patch that
--   first patch that cannot be commuted past.
commuteFLorComplain :: Commute p => (p :> FL p) wX wY -> Either (Sealed2 p) ((FL p :> p) wX wY)

-- | <a>commuteRL</a> commutes a RL past a single element.
commuteRL :: Commute p => (RL p :> p) wX wY -> Maybe ((p :> RL p) wX wY)
readPatch :: ReadPatch p => ByteString -> Maybe (Sealed (p wX))
readPatchPartial :: ReadPatch p => ByteString -> Maybe (Sealed (p wX), ByteString)

-- | It can sometimes be handy to have a canonical representation of a
--   given patch. We achieve this by defining a canonical form for each
--   patch type, and a function <a>canonize</a> which takes a patch and
--   puts it into canonical form. This routine is used by the diff function
--   to create an optimal patch (based on an LCS algorithm) from a simple
--   hunk describing the old and new version of a file.
canonize :: PrimCanonize prim => DiffAlgorithm -> prim wX wY -> FL prim wX wY

-- | <a>sortCoalesceFL</a> <tt>ps</tt> coalesces as many patches in
--   <tt>ps</tt> as possible, sorting the results in some standard order.
sortCoalesceFL :: PrimCanonize prim => FL prim wX wY -> FL prim wX wY

-- | <tt>tryToShrink ps</tt> simplifies <tt>ps</tt> by getting rid of
--   self-cancellations or coalescing patches
--   
--   Question (Eric Kow): what properties should this have? For example,
--   the prim1 implementation only gets rid of the first self-cancellation
--   it finds (as far as I can tell). Is that OK? Can we try harder?
tryToShrink :: PrimCanonize prim => FL prim wX wY -> FL prim wX wY
patchname :: Named p wX wY -> String
patchcontents :: Named p wX wY -> FL p wX wY
applyToFilePaths :: (Apply p, ApplyState p ~ Tree) => p wX wY -> Maybe [(FilePath, FilePath)] -> [FilePath] -> ([FilePath], [FilePath], [(FilePath, FilePath)])
apply :: (Apply p, ApplyMonad m (ApplyState p)) => p wX wY -> m ()

-- | Apply a patch to a <a>Tree</a>, yielding a new <a>Tree</a>.
applyToTree :: (Apply p, Functor m, Monad m, ApplyState p ~ Tree) => p wX wY -> Tree m -> m (Tree m)
effectOnFilePaths :: (Apply p, ApplyState p ~ Tree) => p wX wY -> [FilePath] -> [FilePath]
patch2patchinfo :: Named p wX wY -> PatchInfo
summary :: ShowPatch p => p wX wY -> Doc
summaryFL :: ShowPatch p => FL p wX wY -> Doc
plainSummary :: (Conflict e, Effect e, PrimPatchBase e) => e wX wY -> Doc
xmlSummary :: (Effect p, Conflict p, PrimPatchBase p) => p wX wY -> Doc
plainSummaryPrims :: PrimDetails prim => FL prim wX wY -> Doc
adddeps :: Named p wX wY -> [PatchInfo] -> Named p wX wY
getdeps :: Named p wX wY -> [PatchInfo]
listConflictedFiles :: Conflict p => p wX wY -> [FilePath]
isInconsistent :: Check p => p wX wY -> Maybe Doc
instance (Patchy p, NameHack p, ApplyState p ~ Tree) => Patchy (Named p)

module Darcs.Patch.PatchInfoAnd

-- | <tt><a>Hopefully</a> p C</tt> <tt>(x y)</tt> is <tt><a>Either</a>
--   String (p C</tt> <tt>(x y))</tt> in a form adapted to darcs patches.
--   The <tt>C</tt> <tt>(x y)</tt> represents the type witness for the
--   patch that should be there. The <tt>Hopefully</tt> type just tells
--   whether we expect the patch to be hashed or not, and
--   <a>SimpleHopefully</a> does the real work of emulating <a>Either</a>.
--   <tt>Hopefully sh</tt> represents an expected unhashed patch, and
--   <tt>Hashed hash sh</tt> represents an expected hashed patch with its
--   hash.
data Hopefully a wX wY
Hopefully :: (SimpleHopefully a wX wY) -> Hopefully a wX wY
Hashed :: String -> (SimpleHopefully a wX wY) -> Hopefully a wX wY

-- | <tt>SimpleHopefully</tt> is a variant of <tt>Either String</tt>
--   adapted for type witnesses. <tt>Actually</tt> is the equivalent of
--   <tt>Right</tt>, while <tt>Unavailable</tt> is <tt>Left</tt>.
data SimpleHopefully a wX wY
Actually :: (a wX wY) -> SimpleHopefully a wX wY
Unavailable :: String -> SimpleHopefully a wX wY

-- | <tt><a>PatchInfoAnd</a> p wA wB</tt> represents a hope we have to get
--   a patch through its info. We're not sure we have the patch, but we
--   know its info.
data PatchInfoAnd p wA wB
PIAP :: !PatchInfo -> (Hopefully (Named p) wA wB) -> PatchInfoAnd p wA wB

-- | <tt><a>WPatchInfo</a> wA wB</tt> represents the info of a patch,
--   marked with the patch's witnesses.
data WPatchInfo wA wB
unWPatchInfo :: WPatchInfo wA wB -> PatchInfo
compareWPatchInfo :: WPatchInfo wA wB -> WPatchInfo wC wD -> EqCheck (wA, wB) (wC, wD)

-- | <tt><a>piap</a> i p</tt> creates a PatchInfoAnd containing p with info
--   i.
piap :: PatchInfo -> Named p wA wB -> PatchInfoAnd p wA wB

-- | <tt>n2pia</tt> creates a PatchInfoAnd representing a <tt>Named</tt>
--   patch.
n2pia :: Named p wX wY -> PatchInfoAnd p wX wY
patchInfoAndPatch :: PatchInfo -> Hopefully (Named p) wA wB -> PatchInfoAnd p wA wB
fmapPIAP :: (forall wA wB. p wA wB -> q wA wB) -> PatchInfoAnd p wX wY -> PatchInfoAnd q wX wY
fmapFLPIAP :: (FL p wX wY -> FL q wX wY) -> PatchInfoAnd p wX wY -> PatchInfoAnd q wX wY

-- | <tt><a>conscientiously</a> er hp</tt> tries to extract a patch from a
--   <a>PatchInfoAnd</a>. If it fails, it applies the error handling
--   function <tt>er</tt> to a description of the patch info component of
--   <tt>hp</tt>.
conscientiously :: (Doc -> Doc) -> PatchInfoAnd p wA wB -> Named p wA wB

-- | <tt><a>hopefully</a> hp</tt> tries to get a patch from a
--   <a>PatchInfoAnd</a> value. If it fails, it outputs an error "failed to
--   read patch: &lt;description of the patch&gt;". We get the description
--   of the patch from the info part of <tt>hp</tt>
hopefully :: PatchInfoAnd p wA wB -> Named p wA wB
info :: PatchInfoAnd p wA wB -> PatchInfo
winfo :: PatchInfoAnd p wA wB -> WPatchInfo wA wB

-- | <tt>hopefullyM</tt> is a version of <tt>hopefully</tt> which calls
--   <tt>fail</tt> in a monad instead of erroring.
hopefullyM :: Monad m => PatchInfoAnd p wA wB -> m (Named p wA wB)
createHashed :: String -> (String -> IO (Sealed (a wX))) -> IO (Sealed (Hopefully a wX))
extractHash :: PatchInfoAnd p wA wB -> Either (Named p wA wB) String
actually :: a wX wY -> Hopefully a wX wY
unavailable :: String -> Hopefully a wX wY
patchDesc :: PatchInfoAnd p wX wY -> String
instance Show (a wX wY) => Show (SimpleHopefully a wX wY)
instance Show (a wX wY) => Show (Hopefully a wX wY)
instance Show2 p => Show (PatchInfoAnd p wA wB)
instance (Patchy p, NameHack p, ApplyState p ~ Tree) => Patchy (PatchInfoAnd p)
instance PatchDebug p => PatchDebug (PatchInfoAnd p)
instance IsHunk (PatchInfoAnd p)
instance Effect p => Effect (PatchInfoAnd p)
instance (ReadPatch p, PatchListFormat p) => ReadPatch (PatchInfoAnd p)
instance RepairToFL p => Repair (PatchInfoAnd p)
instance Apply p => Apply (PatchInfoAnd p)
instance PatchInspect p => PatchInspect (PatchInfoAnd p)
instance (Merge p, NameHack p) => Merge (PatchInfoAnd p)
instance (Commute p, NameHack p) => Commute (PatchInfoAnd p)
instance (Apply p, Conflict p, CommuteNoConflicts p, IsHunk p, PatchListFormat p, PrimPatchBase p, ShowPatch p, ApplyState p ~ Tree) => ShowPatch (PatchInfoAnd p)
instance (PatchListFormat p, ShowPatchBasic p) => ShowPatchBasic (PatchInfoAnd p)
instance PatchListFormat (PatchInfoAnd p)
instance Invert p => Invert (PatchInfoAnd p)
instance MyEq (PatchInfoAnd p)
instance MyEq WPatchInfo
instance PrimPatchBase p => PrimPatchBase (PatchInfoAnd p)
instance Show2 p => Show2 (PatchInfoAnd p)
instance Show2 p => Show1 (PatchInfoAnd p wX)


module Darcs.Patch.Annotate
annotate :: (Apply p, ApplyState p ~ Tree) => DiffAlgorithm -> FL (PatchInfoAnd p) wX wY -> FileName -> ByteString -> AnnotateResult
annotateDirectory :: (Apply p, ApplyState p ~ Tree) => DiffAlgorithm -> FL (PatchInfoAnd p) wX wY -> FileName -> [FileName] -> AnnotateResult
format :: ByteString -> AnnotateResult -> String
machineFormat :: ByteString -> AnnotateResult -> String
type AnnotateResult = Vector (Maybe PatchInfo, ByteString)
instance Show FileOrDirectory
instance Eq FileOrDirectory
instance Show Annotated
instance ApplyMonad AnnotatedM Tree

module Darcs.Patch.ApplyPatches
applyPatches :: (MonadProgress m, ApplyMonad m (ApplyState p), Patchy p) => FL (PatchInfoAnd p) wX wY -> m ()

module Darcs.Repository.ApplyPatches
applyPatches :: (MonadProgress m, ApplyMonad m (ApplyState p), Patchy p) => FL (PatchInfoAnd p) wX wY -> m ()

-- | Apply patches, emitting warnings if there are any IO errors
runTolerantly :: TolerantWrapper TolerantIO a -> IO a

-- | Apply patches, ignoring all errors
runSilently :: TolerantWrapper SilentIO a -> IO a
data DefaultIO a

-- | The default mode of applying patches: fail if the directory is not as
--   we expect
runDefault :: DefaultIO a -> IO a
instance Functor DefaultIO
instance Applicative DefaultIO
instance Monad DefaultIO
instance Functor TolerantIO
instance Applicative TolerantIO
instance Monad TolerantIO
instance Functor SilentIO
instance Applicative SilentIO
instance Monad SilentIO
instance Functor m => Functor (TolerantWrapper m)
instance Applicative m => Applicative (TolerantWrapper m)
instance Monad m => Monad (TolerantWrapper m)
instance TolerantMonad m => TolerantMonad (TolerantWrapper m)
instance TolerantMonad m => ApplyMonad (TolerantWrapper m) Tree
instance TolerantMonad SilentIO
instance TolerantMonad TolerantIO
instance ApplyMonad DefaultIO Tree
instance MonadProgress DefaultIO

module Darcs.Patch.Set

-- | The patches in a repository are stored in chunks broken up at "clean"
--   tags. A tag is clean if the only patches before it in the current
--   repository ordering are ones that the tag depends on (either directly
--   or indirectly). Each chunk is stored in a separate inventory file on
--   disk.
--   
--   A <a>PatchSet</a> represents a repo's history as the list of patches
--   since the last clean tag, and then a list of patch lists each
--   delimited by clean tags.
data PatchSet p wStart wY
PatchSet :: RL (PatchInfoAnd p) wX wY -> RL (Tagged p) wStart wX -> PatchSet p wStart wY

-- | A <a>Tagged</a> is a single chunk of a <a>PatchSet</a>. It has a
--   <a>PatchInfo</a> representing a clean tag, the hash of the previous
--   inventory (if it exists), and the list of patches since that previous
--   inventory.
data Tagged p wX wZ
Tagged :: PatchInfoAnd p wY wZ -> Maybe String -> RL (PatchInfoAnd p) wX wY -> Tagged p wX wZ
type SealedPatchSet p wStart = Sealed ((PatchSet p) wStart)

-- | <a>Origin</a> is a type used to represent the initial context of a
--   repo.
data Origin

-- | Runs a progress action for each tag and patch in a given PatchSet,
--   using the passed progress message. Does not alter the PatchSet.
progressPatchSet :: String -> PatchSet p wStart wX -> PatchSet p wStart wX

-- | <a>tags</a> returns the PatchInfos corresponding to the tags of a
--   given <a>PatchSet</a>.
tags :: PatchSet p wStart wX -> [PatchInfo]
emptyPatchSet :: PatchSet p wX wX

-- | <a>appendPSFL</a> takes a <a>PatchSet</a> and a <a>FL</a> of patches
--   that "follow" the PatchSet, and concatenates the patches into the
--   PatchSet.
appendPSFL :: PatchSet p wStart wX -> FL (PatchInfoAnd p) wX wY -> PatchSet p wStart wY

-- | <a>newset2RL</a> takes a <a>PatchSet</a> and returns an equivalent,
--   linear <a>RL</a> of patches.
newset2RL :: PatchSet p wStart wX -> RL (PatchInfoAnd p) wStart wX

-- | <a>newset2FL</a> takes a <a>PatchSet</a> and returns an equivalent,
--   linear <a>FL</a> of patches.
newset2FL :: PatchSet p wStart wX -> FL (PatchInfoAnd p) wStart wX
instance Show2 p => Show (Tagged p wX wZ)
instance Show2 p => Show (PatchSet p wStart wY)
instance Show2 p => Show2 (Tagged p)
instance Show2 p => Show1 (Tagged p wX)
instance Show2 p => Show2 (PatchSet p)
instance Show2 p => Show1 (PatchSet p wStart)

module Darcs.Patch.Rebase

-- | A patch that lives in a repository where a rebase is in progress. Such
--   a repository will consist of <tt>Normal</tt> patches along with
--   exactly one <tt>Suspended</tt> patch.
--   
--   Most rebase operations will require the <tt>Suspended</tt> patch to be
--   at the end of the repository.
--   
--   <tt>Normal</tt> represents a normal patch within a respository where a
--   rebase is in progress. <tt>Normal p</tt> is given the same on-disk
--   representation as <tt>p</tt>, so a repository can be switched into and
--   out of rebasing mode simply by adding or removing a <tt>Suspended</tt>
--   patch and setting the appropriate format flag.
--   
--   The single <tt>Suspended</tt> patch contains the entire rebase state,
--   in the form of <a>RebaseItem</a>s.
--   
--   Note that the witnesses are such that the <tt>Suspended</tt> patch has
--   no effect on the context of the rest of the repository; in a sense the
--   patches within it are dangling off to one side from the main
--   repository.
--   
--   See Note [Rebase representation] in the source for a discussion of the
--   design choice to embed the rebase state in a single patch.
data Rebasing p wX wY
Normal :: p wX wY -> Rebasing p wX wY
Suspended :: FL (RebaseItem p) wX wY -> Rebasing p wX wX

-- | A single item in the rebase state consists of either a patch that is
--   being edited, or a fixup that adjusts the context so that a subsequent
--   patch that is being edited "makes sense".
--   
--   <tt>ToEdit</tt> holds a patch that is being edited. The name
--   (<tt>PatchInfo</tt>) of the patch will typically be the name the patch
--   had before it was added to the rebase state; if it is moved back into
--   the repository it must be given a fresh name to account for the fact
--   that it will not necessarily have the same dependencies as the
--   original patch. This is typically done by changing the
--   <tt>Ignore-This</tt> junk.
--   
--   <tt>Fixup</tt> adjusts the context so that a subsequent
--   <tt>ToEdit</tt> patch is correct. Where possible, <tt>Fixup</tt>
--   changes are commuted as far as possible into the rebase state, so any
--   remaining ones will typically cause a conflict when the
--   <tt>ToEdit</tt> patch is moved back into the repository.
data RebaseItem p wX wY
ToEdit :: Named p wX wY -> RebaseItem p wX wY
Fixup :: RebaseFixup p wX wY -> RebaseItem p wX wY

-- | A <a>RebaseName</a> encapsulates the concept of the name of a patch,
--   without any contents. This allows us to track explicit dependencies in
--   the rebase state, changing them to follow uses of amend-record or
--   unsuspend on a depended-on patch, and warning the user if any are lost
--   entirely.
data RebaseName (p :: * -> * -> *) wX wY
AddName :: PatchInfo -> RebaseName p wX wY
DelName :: PatchInfo -> RebaseName p wX wY
Rename :: PatchInfo -> PatchInfo -> RebaseName p wX wY

-- | A single rebase fixup, needed to ensure that the actual patches being
--   stored in the rebase state have the correct context.
data RebaseFixup p wX wY
PrimFixup :: PrimOf p wX wY -> RebaseFixup p wX wY
NameFixup :: RebaseName p wX wY -> RebaseFixup p wX wY

-- | Given a list of rebase items, try to push a new fixup as far as
--   possible into the list as possible, using both commutation and
--   coalescing. If the fixup commutes past all the <a>ToEdit</a> patches
--   then it is dropped entirely.
simplifyPush :: (PrimPatchBase p, Commute p, FromPrim p, Effect p) => DiffAlgorithm -> RebaseFixup p wX wY -> FL (RebaseItem p) wY wZ -> Sealed (FL (RebaseItem p) wX)

-- | Like <a>simplifyPush</a> but for a list of fixups.
simplifyPushes :: (PrimPatchBase p, Commute p, FromPrim p, Effect p) => DiffAlgorithm -> FL (RebaseFixup p) wX wY -> FL (RebaseItem p) wY wZ -> Sealed (FL (RebaseItem p) wX)
mkSuspended :: FL (RebaseItem p) wX wY -> IO (Named (Rebasing p) wX wX)

-- | given the repository contents, get the rebase container patch, its
--   contents, and the rest of the repository contents. The rebase patch
--   must be at the head of the repository.
takeHeadRebase :: PatchSet (Rebasing p) wA wB -> (PatchInfoAnd (Rebasing p) wB wB, Sealed (FL (RebaseItem p) wB), PatchSet (Rebasing p) wA wB)
takeHeadRebaseFL :: FL (PatchInfoAnd (Rebasing p)) wA wB -> (PatchInfoAnd (Rebasing p) wB wB, Sealed (FL (RebaseItem p) wB), FL (PatchInfoAnd (Rebasing p)) wA wB)
takeHeadRebaseRL :: RL (PatchInfoAnd (Rebasing p)) wA wB -> (PatchInfoAnd (Rebasing p) wB wB, Sealed (FL (RebaseItem p) wB), RL (PatchInfoAnd (Rebasing p)) wA wB)

-- | given the repository contents, get the rebase container patch, and its
--   contents The rebase patch can be anywhere in the repository and is
--   returned without being commuted to the end.
takeAnyRebase :: PatchSet (Rebasing p) wA wB -> (Sealed2 (PatchInfoAnd (Rebasing p)), Sealed2 (FL (RebaseItem p)))

-- | given the repository contents, get the rebase container patch, its
--   contents, and the rest of the repository contents. Commutes the patch
--   to the end of the repository if necessary. The rebase patch must be at
--   the head of the repository.
takeAnyRebaseAndTrailingPatches :: PatchSet (Rebasing p) wA wB -> FlippedSeal (PatchInfoAnd (Rebasing p) :> RL (PatchInfoAnd (Rebasing p))) wB
countToEdit :: FL (RebaseItem p) wX wY -> Int
instance MaybeInternal (Rebasing p)
instance (Commute p, PrimPatchBase p, FromPrim p, Effect p) => RecontextRebase (Rebasing p)
instance RepoPatch p => RepoPatch (Rebasing p)
instance PatchListFormat p => PatchListFormat (Rebasing p)
instance RepairInternalFL (RebaseFixup p)
instance RepairInternalFL (RebaseItem p)
instance RepairInternalFL p => RepairInternal (FL p)
instance RepairToFL p => RepairToFL (Rebasing p)
instance Check p => Check (RebaseItem p)
instance Check p => Check (Rebasing p)
instance FromPrim p => FromPrim (Rebasing p)
instance IsHunk p => IsHunk (Rebasing p)
instance (PrimPatchBase p, PatchListFormat p, ReadPatch p) => ReadPatch (Rebasing p)
instance PrimPatchBase p => PrimPatchBase (Rebasing p)
instance (PrimPatchBase p, PatchListFormat p, ReadPatch p) => ReadPatch (RebaseItem p)
instance (PrimPatchBase p, PatchListFormat p, Apply p, CommuteNoConflicts p, Conflict p, IsHunk p, ShowPatch p) => ShowPatch (RebaseItem p)
instance (PrimPatchBase p, PatchListFormat p, ShowPatchBasic p) => ShowPatchBasic (RebaseItem p)
instance (PrimPatchBase p, PatchListFormat p, Apply p, CommuteNoConflicts p, Conflict p, IsHunk p, ShowPatch p) => ShowPatch (Rebasing p)
instance (PrimPatchBase p, PatchListFormat p, ShowPatchBasic p) => ShowPatchBasic (Rebasing p)
instance Apply p => Apply (Rebasing p)
instance (Conflict p, FromPrim p, Effect p, Invert p, Commute p) => Conflict (Rebasing p)
instance (PrimPatchBase p, PatchListFormat p, Patchy p, FromPrim p, Conflict p, Effect p, PatchInspect p, CommuteNoConflicts p, IsHunk p) => Matchable (Rebasing p)
instance PatchDebug p => PatchDebug (Rebasing p)
instance (PrimPatchBase p, PatchListFormat p, Patchy p, FromPrim p, Conflict p, Effect p, CommuteNoConflicts p, IsHunk p) => Patchy (Rebasing p)
instance Effect p => Effect (Rebasing p)
instance Invert p => Invert (Rebasing p)
instance (PrimPatchBase p, PatchInspect p) => PatchInspect (Rebasing p)
instance (PrimPatchBase p, FromPrim p, Effect p, Invert p, Merge p) => Merge (Rebasing p)
instance (PrimPatchBase p, FromPrim p, Effect p, Invert p, Commute p, CommuteNoConflicts p) => CommuteNoConflicts (Rebasing p)
instance (PrimPatchBase p, FromPrim p, Effect p, Commute p) => NameHack (Rebasing p)
instance (PrimPatchBase p, FromPrim p, Effect p, Invert p, Commute p) => Commute (Rebasing p)
instance (Show2 p, Show2 (PrimOf p)) => Show2 (RebaseItem p)
instance (Show2 p, Show2 (PrimOf p)) => Show1 (RebaseItem p wX)
instance (Show2 p, Show2 (PrimOf p)) => Show (RebaseItem p wX wY)
instance (Show2 p, Show2 (PrimOf p)) => Show2 (Rebasing p)
instance (Show2 p, Show2 (PrimOf p)) => Show1 (Rebasing p wX)
instance (Show2 p, Show2 (PrimOf p)) => Show (Rebasing p wX wY)

module Darcs.Patch.Progress

-- | Evaluate an <a>RL</a> list and report progress.
progressRL :: String -> RL a wX wY -> RL a wX wY

-- | Evaluate an <a>FL</a> list and report progress.
progressFL :: String -> FL a wX wY -> FL a wX wY

-- | Evaluate an <a>RL</a> list and report progress. In addition to
--   printing the number of patches we got, show the name of the last tag
--   we got.
progressRLShowTags :: String -> RL (PatchInfoAnd p) wX wY -> RL (PatchInfoAnd p) wX wY

module Darcs.Patch.Rebase.Viewing

-- | Encapsulate a single patch in the rebase state together with its
--   fixups. Used during interactive selection to make sure that each item
--   presented to the user corresponds to a patch.
data RebaseSelect p wX wY
RSFwd :: FL (RebaseFixup p) wX wY -> Named p wY wZ -> RebaseSelect p wX wZ
RSRev :: FL (RebaseFixup p) wX wY -> Named p wY wZ -> RebaseSelect p wZ wX

-- | Turn a list of rebase items being rebased into a list suitable for use
--   by interactive selection. Each actual patch being rebased is grouped
--   together with any fixups needed.
toRebaseSelect :: PrimPatchBase p => FL (RebaseItem p) wX wY -> FL (RebaseSelect p) wX wY

-- | Turn a list of items back from the format used for interactive
--   selection into a normal list
fromRebaseSelect :: FL (RebaseSelect p) wX wY -> FL (RebaseItem p) wX wY

-- | Turn a selected rebase patch back into a patch we can apply to the
--   main repository, together with residual fixups that need to go back
--   into the rebase state (unless the rebase is now finished). Any fixups
--   associated with the patch will turn into conflicts.
extractRebaseSelect :: (Commute p, Merge p, Invert p, Effect p, FromPrim p, PrimPatchBase p) => FL (RebaseSelect p) wX wY -> (FL (WDDNamed p) :> FL (RebaseFixup p)) wX wY

-- | Like <a>extractRebaseSelect</a>, but any fixups are "reified" into a
--   separate patch.
reifyRebaseSelect :: (PrimPatchBase p, Commute p, Merge p, Invert p, Effect p, FromPrim p) => FL (RebaseSelect p) wX wY -> IO ((FL (WDDNamed p) :> FL (RebaseFixup p)) wX wY)

-- | Split a list of rebase patches into those that will have conflicts if
--   unsuspended and those that won't.
partitionUnconflicted :: (PrimPatchBase p, FromPrim p, Effect p, Commute p, Invert p, NameHack p) => FL (RebaseSelect p) wX wY -> (FL (RebaseSelect p) :> RL (RebaseSelect p)) wX wY

-- | Get hold of the <a>Named</a> patch inside a <a>RebaseSelect</a>.
rsToNamed :: RebaseSelect p wX wY -> Sealed2 (Named p)

-- | A patch, together with a list of patch names that it used to depend
--   on, but were lost during the rebasing process. The UI can use this
--   information to report them to the user.
data WithDroppedDeps p wX wY
WithDroppedDeps :: p wX wY -> [PatchInfo] -> WithDroppedDeps p wX wY
wddPatch :: WithDroppedDeps p wX wY -> p wX wY
wddDependedOn :: WithDroppedDeps p wX wY -> [PatchInfo]
type WDDNamed p = WithDroppedDeps (Named p)
commuterIdWDD :: CommuteFn p q -> CommuteFn p (WithDroppedDeps q)

-- | Used for displaying during 'rebase changes'. 'Named (RebaseChange p)'
--   is very similar to 'RebaseSelect p' but slight mismatches
--   (<a>Named</a> embeds an <a>FL</a>) makes it not completely trivial to
--   merge them.
data RebaseChange p wX wY
RCFwd :: FL (RebaseFixup p) wX wY -> FL p wY wZ -> RebaseChange p wX wZ
RCRev :: FL (RebaseFixup p) wX wY -> FL p wY wZ -> RebaseChange p wZ wX
toRebaseChanges :: PrimPatchBase p => FL (RebaseItem p) wX wY -> FL (PatchInfoAnd (RebaseChange p)) wX wY
instance (PrimPatchBase p, Apply p, Invert p, PatchInspect p, ApplyState p ~ ApplyState (PrimOf p)) => Matchable (RebaseChange p)
instance PatchListFormat (RebaseChange p)
instance NameHack (RebaseChange p)
instance IsHunk p => IsHunk (RebaseChange p)
instance MaybeInternal (RebaseChange p)
instance CommuteNoConflicts (RebaseChange p)
instance Effect p => Effect (WithDroppedDeps p)
instance PrimPatchBase p => PrimPatchBase (WithDroppedDeps p)
instance (PrimPatchBase p, PatchInspect p) => PatchInspect (RebaseChange p)
instance (PrimPatchBase p, PatchInspect p) => PatchInspect (RebaseSelect p)
instance Commute (RebaseChange p)
instance (PrimPatchBase p, FromPrim p, Effect p, Commute p, Invert p, NameHack p) => Commute (RebaseSelect p)
instance (PrimPatchBase p, Commute p, MyEq p) => MyEq (RebaseSelect p)
instance Invert (RebaseChange p)
instance Invert p => Invert (RebaseSelect p)
instance PrimPatch (PrimOf p) => PrimPatchBase (RebaseChange p)
instance ReadPatch (RebaseChange p)
instance ReadPatch p => ReadPatch (RebaseSelect p)
instance (PrimPatchBase p, PatchListFormat p, ShowPatchBasic p, Invert p, Effect p, Merge p, FromPrim p, Conflict p, CommuteNoConflicts p) => ShowPatch (RebaseChange p)
instance (PrimPatchBase p, PatchListFormat p, Apply p, CommuteNoConflicts p, Conflict p, IsHunk p, ShowPatch p) => ShowPatch (RebaseSelect p)
instance (PrimPatchBase p, PatchListFormat p, ShowPatchBasic p) => ShowPatchBasic (RebaseChange p)
instance (PrimPatchBase p, PatchListFormat p, ShowPatchBasic p) => ShowPatchBasic (RebaseSelect p)
instance (PrimPatchBase p, Invert p, Effect p) => Effect (RebaseChange p)
instance (PrimPatchBase p, Invert p, Effect p) => Effect (RebaseSelect p)
instance (PrimPatchBase p, Invert p, Effect p, FromPrim p, Merge p, Conflict p, CommuteNoConflicts p) => Conflict (RebaseChange p)
instance (PrimPatchBase p, FromPrim p, Conflict p, CommuteNoConflicts p, Invert p) => Conflict (RebaseSelect p)
instance (PrimPatchBase p, Invert p, Apply p, ApplyState p ~ ApplyState (PrimOf p)) => Apply (RebaseChange p)
instance (PrimPatchBase p, Invert p, Apply p, ApplyState p ~ ApplyState (PrimOf p)) => Apply (RebaseSelect p)
instance PatchDebug p => PatchDebug (RebaseChange p)
instance PatchDebug p => PatchDebug (RebaseSelect p)
instance (PrimPatchBase p, Apply p, ApplyState p ~ ApplyState (PrimOf p), Invert p) => Patchy (RebaseChange p)
instance (PrimPatchBase p, PatchListFormat p, Conflict p, FromPrim p, Effect p, CommuteNoConflicts p, IsHunk p, Patchy p, ApplyState p ~ ApplyState (PrimOf p), NameHack p) => Patchy (RebaseSelect p)
instance PrimPatchBase p => PrimPatchBase (RebaseSelect p)
instance (Show2 p, Show2 (PrimOf p)) => Show (RebaseChange p wX wY)
instance (Show2 p, Show2 (PrimOf p)) => Show2 (RebaseChange p)
instance (Show2 p, Show2 (PrimOf p)) => Show1 (RebaseChange p wX)
instance (Show2 p, Show2 (PrimOf p)) => Show2 (RebaseSelect p)
instance (Show2 p, Show2 (PrimOf p)) => Show1 (RebaseSelect p wX)
instance (Show2 p, Show2 (PrimOf p)) => Show (RebaseSelect p wX wY)

module Darcs.Patch.Depends

-- | <tt>getUncovered ps</tt> returns the <a>PatchInfo</a> for all the
--   patches in <tt>ps</tt> that are not depended on by anything else
--   *through explicit dependencies*. Tags are a likely candidate, although
--   we may also find some non-tag patches in this list.
--   
--   Keep in mind that in a typical repository with a lot of tags, only a
--   small fraction of tags would be returned as they would be at least
--   indirectly depended on by the topmost ones.
getUncovered :: PatchSet p wStart wX -> [PatchInfo]
areUnrelatedRepos :: (Patchy p, NameHack p) => PatchSet p wStart wX -> PatchSet p wStart wY -> Bool
findCommonAndUncommon :: (Patchy p, NameHack p) => PatchSet p wStart wX -> PatchSet p wStart wY -> Fork (PatchSet p) (FL (PatchInfoAnd p)) (FL (PatchInfoAnd p)) wStart wX wY
mergeThem :: (Patchy p, Merge p, NameHack p) => PatchSet p wStart wX -> PatchSet p wStart wY -> Sealed (FL (PatchInfoAnd p) wX)
findCommonWithThem :: (Patchy p, NameHack p) => PatchSet p wStart wX -> PatchSet p wStart wY -> (PatchSet p :> FL (PatchInfoAnd p)) wStart wX
countUsThem :: (Patchy p, NameHack p) => PatchSet p wStart wX -> PatchSet p wStart wY -> (Int, Int)
removeFromPatchSet :: (Patchy p, NameHack p) => FL (PatchInfoAnd p) wX wY -> PatchSet p wStart wY -> Maybe (PatchSet p wStart wX)

-- | <tt>slightlyOptimizePatchset</tt> only works on the surface inventory
--   (see <tt>optimizePatchset</tt>) and only optimises at most one tag in
--   there, going for the most recent tag which has no non-depended patch
--   after it. Older tags won't be <tt>clean</tt>, which means the PatchSet
--   will not be in 'unclean :&lt; clean' state.
slightlyOptimizePatchset :: PatchSet p wStart wX -> PatchSet p wStart wX
getPatchesBeyondTag :: (Patchy p, NameHack p) => PatchInfo -> PatchSet p wStart wX -> FlippedSeal (RL (PatchInfoAnd p)) wX

-- | splitOnTag takes a tag's <a>PatchInfo</a>, and a <a>PatchSet</a>, and
--   attempts to find the tag in the PatchSet, returning a pair: the clean
--   PatchSet "up to" the tag, and a RL of patches after the tag; If the
--   tag is not in the PatchSet, we return Nothing.
splitOnTag :: (Patchy p, NameHack p) => PatchInfo -> PatchSet p wStart wX -> Maybe ((PatchSet p :> RL (PatchInfoAnd p)) wStart wX)
newsetUnion :: (Patchy p, Merge p, NameHack p) => [SealedPatchSet p wStart] -> SealedPatchSet p wStart
newsetIntersection :: (Patchy p, NameHack p) => [SealedPatchSet p wStart] -> SealedPatchSet p wStart
commuteToEnd :: (Patchy p, NameHack p) => RL (PatchInfoAnd p) wX wY -> PatchSet p wStart wY -> (PatchSet p :> RL (PatchInfoAnd p)) wStart wX
findUncommon :: (Patchy p, NameHack p) => PatchSet p wStart wX -> PatchSet p wStart wY -> (FL (PatchInfoAnd p) :\/: FL (PatchInfoAnd p)) wX wY

-- | Merge two FLs (say L and R), starting in a common context. The result
--   is a FL starting in the original end context of L, going to a new
--   context that is the result of applying all patches from R on top of
--   patches from L.
--   
--   While this function is similar to <a>mergeFL</a>, there are three
--   important differences to keep in mind:
--   
--   <ul>
--   <li><a>mergeFL</a> does not correctly deal with duplicate patches
--   whereas this one does (Question from Eric Kow: in what sense? Why not
--   fix the mergeFL instance?)</li>
--   <li>The conventional order we use in this function is reversed from
--   <a>mergeFL</a> (so <tt>mergeFL r l</tt> vs. <tt>merge2FL l r</tt>.
--   This does not matter so much for the former since you get both paths.
--   (Question from Eric Kow: should we flip merge2FL for more uniformity
--   in the code?)</li>
--   </ul>
merge2FL :: (Patchy p, Merge p, NameHack p) => FL (PatchInfoAnd p) wX wY -> FL (PatchInfoAnd p) wX wZ -> (FL (PatchInfoAnd p) :/\: FL (PatchInfoAnd p)) wY wZ

module Darcs.Patch.Bundle

-- | hashBundle creates a SHA1 string of a given a FL of named patches.
--   This allows us to ensure that the patches in a received patchBundle
--   have not been modified in transit.
hashBundle :: (PatchListFormat p, ShowPatchBasic p) => FL (Named p) wX wY -> String

-- | In makeBundle2, it is presumed that the two patch sequences are
--   identical, but that they may be lazily generated. If two different
--   patch sequences are passed, a bundle with a mismatched hash will be
--   generated, which is not the end of the world, but isn't very useful
--   either.
makeBundle2 :: (ApplyState p ~ Tree, RepoPatch p) => Maybe (Tree IO) -> RL (PatchInfoAnd p) wStart wX -> FL (Named p) wX wY -> FL (Named p) wX wY -> IO Doc
makeBundleN :: (ApplyState p ~ Tree, RepoPatch p) => Maybe (Tree IO) -> PatchSet p wStart wX -> FL (Named p) wX wY -> IO Doc
scanBundle :: RepoPatch p => ByteString -> Either String (SealedPatchSet p Origin)
contextPatches :: RepoPatch p => PatchSet p Origin wX -> (PatchSet p :> RL (PatchInfoAnd p)) Origin wX

-- | <a>scanContextFile</a> scans the context in the file of the given
--   name.
scanContextFile :: RepoPatch p => FilePath -> IO (PatchSet p Origin wX)

-- | patchFilename maps a patch description string to a safe (lowercased,
--   spaces removed and ascii-only characters) patch filename.
patchFilename :: String -> String

-- | getContext parses a context list, returning a tuple containing the
--   list, and remaining ByteString input.
getContext :: ByteString -> ([PatchInfo], ByteString)

-- | Minimize the context of a bundle to be sent, taking into account the
--   patches selected to be sent
minContext :: RepoPatch p => PatchSet p wStart wB -> FL (PatchInfoAnd p) wB wC -> Sealed ((PatchSet p :> FL (PatchInfoAnd p)) wStart)
parseBundle :: RepoPatch p => ByteString -> Either String (Sealed ((PatchSet p :> FL (PatchInfoAnd p)) Origin))


-- | PatchChoices divides a sequence of patches into three sets: "first",
--   "middle" and "last", such that all patches can be applied, if you
--   first apply the first ones then the middle ones and then the last
--   ones. Obviously if there are dependencies between the patches that
--   will put a constraint on how you can choose to divide them up. The
--   PatchChoices data type and associated functions are here to deal with
--   many of the common cases that come up when choosing a subset of a
--   group of patches.
--   
--   <a>forceLast</a> tells PatchChoices that a particular patch is
--   required to be in the "last" group, which also means that any patches
--   that depend on it must be in the "last" group.
--   
--   Internally, a PatchChoices doesn't always reorder the patches until it
--   is asked for the final output (e.g. by <tt>get_first_choice</tt>).
--   Instead, each patch is placed in a state of definitely first,
--   definitely last and undecided; undecided leans towards "middle". The
--   patches that are first are commuted to the head immediately, but
--   patches that are middle and last are mixed together. In case you're
--   wondering about the first-middle-last language, it's because in some
--   cases the "yes" answers will be last (as is the case for the revert
--   command), and in others first (as in record, pull and push).
--   
--   Some patch marked "middle" may in fact be unselectable because of
--   dependencies: when a patch is marked "last", its dependencies are not
--   updated until patchSlot is called on them.
module Darcs.Patch.Choices
data PatchChoices p wX wY
patchChoices :: Patchy p => FL p wX wY -> PatchChoices p wX wY

-- | Label a sequence of patches.
patchChoicesLps :: Patchy p => FL p wX wY -> (PatchChoices p wX wY, FL (LabelledPatch p) wX wY)

-- | Label a sequence of patches as subpatches of an existing label. This
--   is intended for use when substituting a patch for an equivalent patch
--   or patches.
patchChoicesLpsSub :: Patchy p => Maybe Label -> FL p wX wY -> (PatchChoices p wX wY, FL (LabelledPatch p) wX wY)
patchSlot :: Patchy p => LabelledPatch p wA wB -> PatchChoices p wX wY -> (Slot, PatchChoices p wX wY)
patchSlot' :: Patchy p => LabelledPatch p wA wB -> StateT (PatchChoices p wX wY) Identity Slot

-- | <tt>getChoices</tt> evaluates a <tt>PatchChoices</tt> into the first,
--   middle and last sequences by doing the commutes that were needed.
getChoices :: Patchy p => PatchChoices p wX wY -> (FL (LabelledPatch p) :> (FL (LabelledPatch p) :> FL (LabelledPatch p))) wX wY

-- | <tt>refineChoices act</tt> performs <tt>act</tt> on the middle part of
--   a sequence of choices, in order to hopefully get more patches into the
--   <tt>first</tt> and <tt>last</tt> parts of a <tt>PatchChoices</tt>.
refineChoices :: (Patchy p, Monad m, Functor m) => (forall wU wV. FL (LabelledPatch p) wU wV -> PatchChoices p wU wV -> m (PatchChoices p wU wV)) -> PatchChoices p wX wY -> m (PatchChoices p wX wY)
separateFirstMiddleFromLast :: Patchy p => PatchChoices p wX wZ -> (FL (LabelledPatch p) :> FL (LabelledPatch p)) wX wZ
separateFirstFromMiddleLast :: Patchy p => PatchChoices p wX wZ -> (FL (LabelledPatch p) :> FL (LabelledPatch p)) wX wZ
forceFirst :: Patchy p => Label -> PatchChoices p wA wB -> PatchChoices p wA wB
forceFirsts :: Patchy p => [Label] -> PatchChoices p wA wB -> PatchChoices p wA wB
forceLast :: Patchy p => Label -> PatchChoices p wA wB -> PatchChoices p wA wB
forceLasts :: Patchy p => [Label] -> PatchChoices p wA wB -> PatchChoices p wA wB
forceMatchingFirst :: Patchy p => (forall wX wY. LabelledPatch p wX wY -> Bool) -> PatchChoices p wA wB -> PatchChoices p wA wB
forceMatchingLast :: Patchy p => (forall wX wY. LabelledPatch p wX wY -> Bool) -> PatchChoices p wA wB -> PatchChoices p wA wB
selectAllMiddles :: Patchy p => Bool -> PatchChoices p wX wY -> PatchChoices p wX wY
makeUncertain :: Patchy p => Label -> PatchChoices p wA wB -> PatchChoices p wA wB
makeEverythingLater :: Patchy p => PatchChoices p wX wY -> PatchChoices p wX wY
makeEverythingSooner :: Patchy p => PatchChoices p wX wY -> PatchChoices p wX wY
data LabelledPatch p wX wY

-- | <a>Label</a> <tt>mp i</tt> acts as a temporary identifier to help us
--   keep track of patches during the selection process. These are useful
--   for finding patches that may have moved around during patch selection
--   (being pushed forwards or backwards as dependencies arise).
--   
--   The identifier is implemented as a tuple <tt>Label mp i</tt>. The
--   <tt>i</tt> is just some arbitrary label, expected to be unique within
--   the patches being scrutinised. The <tt>mp</tt> is motivated by patch
--   splitting; it provides a convenient way to generate a new identifier
--   from the patch being split. For example, if we split a patch
--   identified as <tt>Label Nothing 5</tt>, the resulting sub-patches
--   could be identified as <tt>Label (Label Nothing 5) 1</tt>, <tt>Label
--   (Label Nothing 5) 2</tt>, etc.
data Label
label :: LabelledPatch p wX wY -> Label
lpPatch :: LabelledPatch p wX wY -> p wX wY

-- | See module documentation for <a>Choices</a>
data Slot
InFirst :: Slot
InMiddle :: Slot
InLast :: Slot

-- | <a>substitute</a> <tt>(a :||: bs)</tt> <tt>pcs</tt> replaces
--   <tt>a</tt> with <tt>bs</tt> in <tt>pcs</tt> preserving the choice
--   associated with <tt>a</tt>
substitute :: Patchy p => Sealed2 (LabelledPatch p :||: FL (LabelledPatch p)) -> PatchChoices p wX wY -> PatchChoices p wX wY
instance Eq Label
instance Ord Label
instance MyEq p => MyEq (PatchChoice p)
instance Merge p => Merge (PatchChoice p)
instance PatchInspect p => PatchInspect (PatchChoice p)
instance Commute p => Commute (PatchChoice p)
instance Merge p => Merge (LabelledPatch p)
instance PatchInspect p => PatchInspect (LabelledPatch p)
instance Commute p => Commute (LabelledPatch p)
instance Invert p => Invert (LabelledPatch p)
instance MyEq p => MyEq (LabelledPatch p)


-- | <i>First matcher, Second matcher and Nonrange matcher</i>
--   
--   When we match for patches, we have a PatchSet, of which we want a
--   subset. This subset is formed by the patches in a given interval which
--   match a given criterion. If we represent time going left to right,
--   then we have (up to) three <a>Matcher</a>s:
--   
--   <ul>
--   <li>the <a>firstMatcher</a> is the left bound of the interval,</li>
--   <li>the <a>secondMatcher</a> is the right bound, and</li>
--   <li>the <a>nonrangeMatcher</a> is the criterion we use to select among
--   patches in the interval.</li>
--   </ul>
module Darcs.Patch.Match
matchParser :: Matchable p => CharParser st (MatchFun p)

-- | The string that is emitted when the user runs <tt>darcs help
--   --match</tt>.
helpOnMatchers :: [String]
addInternalMatcher :: Matchable p => Maybe (Matcher p) -> Maybe (Matcher p)

-- | <tt>matchFirstPatchset fs ps</tt> returns the part of <tt>ps</tt>
--   before its first matcher, ie the one that comes first dependencywise.
--   Hence, patches in <tt>matchFirstPatchset fs ps</tt> are the context
--   for the ones we don't want.
matchFirstPatchset :: Matchable p => [MatchFlag] -> PatchSet p wStart wX -> SealedPatchSet p wStart

-- | <tt>matchSecondPatchset fs ps</tt> returns the part of <tt>ps</tt>
--   before its second matcher, ie the one that comes last dependencywise.
matchSecondPatchset :: Matchable p => [MatchFlag] -> PatchSet p wStart wX -> SealedPatchSet p wStart

-- | Split on the second matcher. Note that this picks up the first match
--   starting from the earliest patch in a sequence, as opposed to
--   <a>matchSecondPatchset</a> which picks up the first match starting
--   from the latest patch
splitSecondFL :: Matchable p => (forall wA wB. q wA wB -> Sealed2 (Named p)) -> [MatchFlag] -> FL q wX wY -> (FL q :> FL q) wX wY
matchPatch :: Matchable p => [MatchFlag] -> PatchSet p wStart wX -> Sealed2 (Named p)

-- | <tt>matchAPatch fs p</tt> tells whether <tt>p</tt> matches the
--   matchers in the flags <tt>fs</tt>
matchAPatch :: Matchable p => [MatchFlag] -> Named p wX wY -> Bool

-- | <tt>matchAPatchread fs p</tt> tells whether <tt>p</tt> matches the
--   matchers in the flags listed in <tt>fs</tt>.
matchAPatchread :: Matchable p => [MatchFlag] -> PatchInfoAnd p wX wY -> Bool
getNonrangeMatchS :: (ApplyMonad m (ApplyState p), MonadProgress m, Matchable p, ApplyState p ~ Tree) => [MatchFlag] -> PatchSet p Origin wX -> m ()

-- | <tt>firstMatch fs</tt> tells whether <tt>fs</tt> implies a "first
--   match", that is if we match against patches from a point in the past
--   on, rather than against all patches since the creation of the
--   repository.
firstMatch :: [MatchFlag] -> Bool

-- | <tt>secondMatch fs</tt> tells whether <tt>fs</tt> implies a "second
--   match", that is if we match against patches up to a point in the past
--   on, rather than against all patches until now.
secondMatch :: [MatchFlag] -> Bool

-- | <tt>haveNonrangeMatch flags</tt> tells whether there is a flag in
--   <tt>flags</tt> which corresponds to a match that is "non-range". Thus,
--   <tt>--match</tt>, <tt>--patch</tt>, <tt>--hash</tt> and
--   <tt>--index</tt> make <tt>haveNonrangeMatch</tt> true, but not
--   <tt>--from-patch</tt> or <tt>--to-patch</tt>.
haveNonrangeMatch :: Matchable p => PatchType p -> [MatchFlag] -> Bool

-- | <tt>havePatchsetMatch flags</tt> tells whether there is a "patchset
--   match" in the flag list. A patchset match is <tt>--match</tt> or
--   <tt>--patch</tt>, or <tt>--context</tt>, but not <tt>--from-patch</tt>
--   nor (!) <tt>--index</tt>. Question: Is it supposed not to be a subset
--   of <tt>haveNonrangeMatch</tt>?
havePatchsetMatch :: [MatchFlag] -> Bool
checkMatchSyntax :: [MatchFlag] -> IO ()
applyInvToMatcher :: (Matchable p, ApplyMonad m (ApplyState p)) => InclusiveOrExclusive -> Matcher p -> PatchSet p Origin wX -> m ()

-- | <tt>nonrangeMatcher</tt> is the criterion that is used to match
--   against patches in the interval. It is 'Just m' when the
--   <tt>--patch</tt>, <tt>--match</tt>, <tt>--tag</tt> options are passed
--   (or their plural variants).
nonrangeMatcher :: Matchable p => [MatchFlag] -> Maybe (Matcher p)
data InclusiveOrExclusive
Inclusive :: InclusiveOrExclusive
Exclusive :: InclusiveOrExclusive

-- | <tt>matchExists m ps</tt> tells whether there is a patch matching
--   <tt>m</tt> in <tt>ps</tt>
matchExists :: Matcher p -> PatchSet p wStart wX -> Bool

-- | <tt>applyNInv</tt> n ps applies the inverse of the last <tt>n</tt>
--   patches of <tt>ps</tt>.
applyNInv :: (Matchable p, ApplyMonad m (ApplyState p)) => Int -> PatchSet p Origin wX -> m ()
hasIndexRange :: [MatchFlag] -> Maybe (Int, Int)

-- | <tt>getMatchingTag m ps</tt>, where <tt>m</tt> is a <a>Matcher</a>
--   which matches tags returns a <a>SealedPatchSet</a> containing all
--   patches in the last tag which matches <tt>m</tt>. Last tag means the
--   most recent tag in repository order, i.e. the last one you'd see if
--   you ran darcs changes -t <tt>m</tt>. Calls <a>error</a> if there is no
--   matching tag.
getMatchingTag :: Matchable p => Matcher p -> PatchSet p wStart wX -> SealedPatchSet p wStart

-- | <tt>matchAPatchset m ps</tt> returns a (the largest?) subset of
--   <tt>ps</tt> ending in patch which matches <tt>m</tt>. Calls
--   <a>error</a> if there is none.
matchAPatchset :: Matchable p => Matcher p -> PatchSet p wStart wX -> SealedPatchSet p wStart
getFirstMatchS :: (ApplyMonad m (ApplyState p), MonadProgress m, Matchable p) => [MatchFlag] -> PatchSet p Origin wX -> m ()

-- | <tt>nonrangeMatcherIsTag</tt> returns true if the matching option was
--   '--tag'
nonrangeMatcherIsTag :: [MatchFlag] -> Bool
data MatchFlag
OnePattern :: String -> MatchFlag
SeveralPattern :: String -> MatchFlag
AfterPattern :: String -> MatchFlag
UpToPattern :: String -> MatchFlag
OnePatch :: String -> MatchFlag
OneHash :: String -> MatchFlag
AfterHash :: String -> MatchFlag
UpToHash :: String -> MatchFlag
SeveralPatch :: String -> MatchFlag
AfterPatch :: String -> MatchFlag
UpToPatch :: String -> MatchFlag
OneTag :: String -> MatchFlag
AfterTag :: String -> MatchFlag
UpToTag :: String -> MatchFlag
LastN :: Int -> MatchFlag
PatchIndexRange :: Int -> Int -> MatchFlag
Context :: AbsolutePath -> MatchFlag
instance Show MatchFlag
instance Eq InclusiveOrExclusive
instance Show (Matcher p)


-- | Patch matching options.
--   
--   These are all of the same type <a>MatchOption</a> defined below.
--   
--   Multiple flags per option are allowed and do not raise a conflict
--   error. This is how Darcs currently operates, even though I suspect
--   that it ignores all but the first <a>MatchFlag</a> (since it does so
--   for many other options).
--   
--   Given a suitable semantics (and documentation thereof), for instance
--   "all the given patterns must match", this could be turned into a
--   useful feature.
module Darcs.UI.Options.Matching
data MatchFlag
OnePattern :: String -> MatchFlag
SeveralPattern :: String -> MatchFlag
AfterPattern :: String -> MatchFlag
UpToPattern :: String -> MatchFlag
OnePatch :: String -> MatchFlag
OneHash :: String -> MatchFlag
AfterHash :: String -> MatchFlag
UpToHash :: String -> MatchFlag
SeveralPatch :: String -> MatchFlag
AfterPatch :: String -> MatchFlag
UpToPatch :: String -> MatchFlag
OneTag :: String -> MatchFlag
AfterTag :: String -> MatchFlag
UpToTag :: String -> MatchFlag
LastN :: Int -> MatchFlag
PatchIndexRange :: Int -> Int -> MatchFlag
Context :: AbsolutePath -> MatchFlag
matchOne :: MatchOption

-- | Used by: clone
matchOneContext :: MatchOption

-- | Used by: amend
matchOneNontag :: MatchOption

-- | Used by: rebase pull, apply, send, push, pull, fetch
matchSeveral :: MatchOption

-- | Used by: rebase unsuspend/reify
matchSeveralOrFirst :: MatchOption

-- | Used by: unrecord, obliterate, rebase suspend, rollback
matchSeveralOrLast :: MatchOption

-- | Used by: diff
matchRange :: MatchOption

-- | Used by: log
matchSeveralOrRange :: MatchOption
matchAny :: MatchOption
context :: MatchOption


-- | All the concrete options.
--   
--   Notes:
--   
--   <ul>
--   <li>The term "option" refers to a flag or combination of flags that
--   together form a part of a command's configuration. Ideally, options
--   should be orthogonal to each other, so we can freely combine
--   them.</li>
--   <li>A primitive (indivisible) option has an associate value type.</li>
--   <li>An option named "xyzActions" represents a set of flags that act as
--   mutually exclusive sub-commands. They typically have a dedicated value
--   type named "XyzAction".</li>
--   <li>This module is probably best imported qualified. This is in
--   contrast to the current practice of using subtly differing names to
--   avoid name clashes for closely related items. For instance, the data
--   constructors for an option's value type and the corresponding data
--   constructors in <a>DarcsFlag</a> may coincide. This is also why we
--   import <a>Darcs.UI.Flags</a> qualified here.</li>
--   <li>When the new options system is finally in place, no code other
--   than the one for constructing options should directly refer to
--   <a>DarcsFlag</a> constructors.</li>
--   </ul>
module Darcs.UI.Options.All

-- | <a>DarcsOption</a> instantiates the first two type parameters of
--   <a>OptSpec</a> to what we need in darcs. The first parameter is
--   instantiated to The flag type is instantiate to <a>Flag</a>.
type DarcsOption = OptSpec DarcsOptDescr Flag

-- | Options for darcs iself that act like sub-commands.
data RootAction
RootHelp :: RootAction
Version :: RootAction
ExactVersion :: RootAction
ListCommands :: RootAction
rootActions :: PrimDarcsOption (Maybe RootAction)
data StdCmdAction
Help :: StdCmdAction
ListOptions :: StdCmdAction
Disable :: StdCmdAction
stdCmdActions :: PrimDarcsOption (Maybe StdCmdAction)
debug :: PrimDarcsOption Bool
data Verbosity
Quiet :: Verbosity
NormalVerbosity :: Verbosity
Verbose :: Verbosity
verbosity :: PrimDarcsOption Verbosity
timings :: PrimDarcsOption Bool
anyVerbosity :: DarcsOption a (Bool -> Bool -> Verbosity -> Bool -> a)
preHook :: DarcsOption a (Maybe String -> Bool -> a)
postHook :: DarcsOption a (Maybe String -> Bool -> a)
hooks :: DarcsOption a (Maybe String -> Bool -> Maybe String -> Bool -> a)
data UseCache
YesUseCache :: UseCache
NoUseCache :: UseCache
useCache :: PrimDarcsOption UseCache
data XmlOutput
NoXml :: XmlOutput
YesXml :: XmlOutput
xmloutput :: PrimDarcsOption XmlOutput
data DryRun
YesDryRun :: DryRun
NoDryRun :: DryRun

-- | NOTE: I'd rather work to have no uses of dryRunNoxml, so that any time
--   --dry-run is a possibility, automated users can examine the results
--   more easily with --xml.
--   
--   See also issue2397.
dryRun :: PrimDarcsOption DryRun
dryRunXml :: DarcsOption a (DryRun -> XmlOutput -> a)
interactive :: PrimDarcsOption (Maybe Bool)
pipe :: PrimDarcsOption Bool
data WantGuiPause
YesWantGuiPause :: WantGuiPause
NoWantGuiPause :: WantGuiPause
pauseForGui :: PrimDarcsOption WantGuiPause
askdeps :: PrimDarcsOption Bool
data SelectDeps
NoDeps :: SelectDeps
AutoDeps :: SelectDeps
PromptDeps :: SelectDeps
selectDeps :: PrimDarcsOption SelectDeps
changesReverse :: PrimDarcsOption Bool

-- | TODO: Returning <tt>-1</tt> if the argument cannot be parsed as an
--   integer is not something I expected to find in a Haskell program.
--   Instead, the flag should take either a plain <a>String</a> argument
--   (leaving it to a later stage to parse the <a>String</a> to an
--   <a>Int</a>), or else a <tt><a>Maybe</a> <a>Int</a></tt>, taking the
--   possibility of a failed parse into account.
matchMaxcount :: PrimDarcsOption (Maybe Int)
data WorkRepo
WorkRepoDir :: String -> WorkRepo
WorkRepoPossibleURL :: String -> WorkRepo
WorkRepoCurrentDir :: WorkRepo
workRepo :: PrimDarcsOption WorkRepo
workingRepoDir :: PrimDarcsOption (Maybe String)
data RemoteRepos
RemoteRepos :: [String] -> RemoteRepos
remoteRepos :: PrimDarcsOption RemoteRepos
possiblyRemoteRepo :: PrimDarcsOption (Maybe String)

-- | <tt>--repodir</tt> is there for compatibility, should be removed
--   eventually
--   
--   IMHO the whole option can disappear; it overlaps with using an extra
--   (non-option) argument, which is how e.g. <tt>darcs get</tt> is usually
--   invoked.
reponame :: PrimDarcsOption (Maybe String)
notInRemote :: PrimDarcsOption [Maybe String]
notInRemoteFlagName :: String
data RepoCombinator
Intersection :: RepoCombinator
Union :: RepoCombinator
Complement :: RepoCombinator
repoCombinator :: PrimDarcsOption RepoCombinator
allowUnrelatedRepos :: PrimDarcsOption Bool
justThisRepo :: PrimDarcsOption Bool
data WithWorkingDir
WithWorkingDir :: WithWorkingDir
NoWorkingDir :: WithWorkingDir

-- | convert, clone, init
useWorkingDir :: PrimDarcsOption WithWorkingDir
data SetDefault
YesSetDefault :: Bool -> SetDefault
NoSetDefault :: Bool -> SetDefault
setDefault :: PrimDarcsOption (Maybe Bool)
patchname :: PrimDarcsOption (Maybe String)
author :: PrimDarcsOption (Maybe String)
data AskLongComment
NoEditLongComment :: AskLongComment
YesEditLongComment :: AskLongComment
PromptLongComment :: AskLongComment
askLongComment :: PrimDarcsOption (Maybe AskLongComment)
keepDate :: PrimDarcsOption Bool
data Logfile
Logfile :: Maybe AbsolutePath -> Bool -> Logfile
_logfile :: Logfile -> Maybe AbsolutePath
_rmlogfile :: Logfile -> Bool
logfile :: PrimDarcsOption Logfile
data LookFor
LookFor :: LookForAdds -> LookForReplaces -> LookForMoves -> LookFor
adds :: LookFor -> LookForAdds
replaces :: LookFor -> LookForReplaces
moves :: LookFor -> LookForMoves
data LookForAdds
YesLookForAdds :: LookForAdds
NoLookForAdds :: LookForAdds
data LookForMoves
YesLookForMoves :: LookForMoves
NoLookForMoves :: LookForMoves
data LookForReplaces
YesLookForReplaces :: LookForReplaces
NoLookForReplaces :: LookForReplaces
lookfor :: PrimDarcsOption LookFor
data UseIndex
UseIndex :: UseIndex
IgnoreIndex :: UseIndex
data ScanKnown

-- | Just files already known to darcs
ScanKnown :: ScanKnown

-- | All files, i.e. look for new ones
ScanAll :: ScanKnown

-- | All files, even boring ones
ScanBoring :: ScanKnown
diffing :: PrimDarcsOption (UseIndex, ScanKnown, DiffAlgorithm)
includeBoring :: PrimDarcsOption Bool
allowProblematicFilenames :: DarcsOption a (Bool -> Bool -> a)
allowCaseDifferingFilenames :: PrimDarcsOption Bool
allowWindowsReservedFilenames :: PrimDarcsOption Bool

-- | TODO: see issue2395
onlyToFiles :: PrimDarcsOption Bool
useIndex :: PrimDarcsOption UseIndex
recursive :: PrimDarcsOption Bool
data DiffAlgorithm
PatienceDiff :: DiffAlgorithm
MyersDiff :: DiffAlgorithm
diffAlgorithm :: PrimDarcsOption DiffAlgorithm
data WithContext
NoContext :: WithContext
YesContext :: WithContext
withContext :: PrimDarcsOption WithContext
unidiff :: PrimDarcsOption Bool
data ExternalDiff
ExternalDiff :: Maybe String -> [String] -> ExternalDiff
_diffCmd :: ExternalDiff -> Maybe String
_diffOpts :: ExternalDiff -> [String]
extDiff :: PrimDarcsOption ExternalDiff
data TestChanges
NoTestChanges :: TestChanges
YesTestChanges :: LeaveTestDir -> TestChanges
testChanges :: PrimDarcsOption TestChanges
data RunTest
YesRunTest :: RunTest
NoRunTest :: RunTest
test :: PrimDarcsOption RunTest
data LeaveTestDir
YesLeaveTestDir :: LeaveTestDir
NoLeaveTestDir :: LeaveTestDir
leaveTestDir :: PrimDarcsOption LeaveTestDir
data HeaderFields
HeaderFields :: [String] -> [String] -> Maybe String -> Maybe String -> Maybe String -> HeaderFields
_to :: HeaderFields -> [String]
_cc :: HeaderFields -> [String]
_from :: HeaderFields -> Maybe String
_subject :: HeaderFields -> Maybe String
_inReplyTo :: HeaderFields -> Maybe String
headerFields :: PrimDarcsOption HeaderFields
sendToContext :: PrimDarcsOption (Maybe AbsolutePath)
sendmail :: PrimDarcsOption (Bool, Maybe String)
sendmailCmd :: PrimDarcsOption (Maybe String)
charset :: PrimDarcsOption (Maybe String)
editDescription :: PrimDarcsOption Bool
ccApply :: PrimDarcsOption (Maybe String)
reply :: PrimDarcsOption (Maybe String)
happyForwarding :: PrimDarcsOption Bool
applyAs :: PrimDarcsOption (Maybe String)
data Sign
NoSign :: Sign
Sign :: Sign
SignAs :: String -> Sign
SignSSL :: String -> Sign
sign :: PrimDarcsOption Sign
data Verify
NoVerify :: Verify
VerifyKeyring :: AbsolutePath -> Verify
VerifySSL :: AbsolutePath -> Verify
verify :: PrimDarcsOption Verify
data AllowConflicts
NoAllowConflicts :: AllowConflicts
YesAllowConflicts :: AllowConflicts
YesAllowConflictsAndMark :: AllowConflicts
conflicts :: AllowConflicts -> PrimDarcsOption (Maybe AllowConflicts)
data ExternalMerge
YesExternalMerge :: String -> ExternalMerge
NoExternalMerge :: ExternalMerge
useExternalMerge :: PrimDarcsOption ExternalMerge
data Compression
NoCompression :: Compression
GzipCompression :: Compression
compress :: PrimDarcsOption Compression
usePacks :: PrimDarcsOption Bool
data WithPatchIndex
YesPatchIndex :: WithPatchIndex
NoPatchIndex :: WithPatchIndex
patchIndex :: PrimDarcsOption WithPatchIndex
patchIndexYes :: PrimDarcsOption WithPatchIndex
data Reorder
NoReorder :: Reorder
Reorder :: Reorder
reorder :: PrimDarcsOption Reorder
minimize :: PrimDarcsOption Bool
storeInMemory :: PrimDarcsOption Bool
data Output
Output :: AbsolutePathOrStd -> Output
OutputAutoName :: AbsolutePath -> Output
output :: PrimDarcsOption (Maybe Output)
data Summary
NoSummary :: Summary
YesSummary :: Summary
summary :: PrimDarcsOption (Maybe Summary)
data RemoteDarcs
RemoteDarcs :: String -> RemoteDarcs
DefaultRemoteDarcs :: RemoteDarcs

-- | TODO: reconsider this grouping of options
data NetworkOptions
NetworkOptions :: Bool -> RemoteDarcs -> NetworkOptions
noHttpPipelining :: NetworkOptions -> Bool
remoteDarcs :: NetworkOptions -> RemoteDarcs
network :: PrimDarcsOption NetworkOptions
data UMask
YesUMask :: String -> UMask
NoUMask :: UMask
umask :: PrimDarcsOption UMask
data SetScriptsExecutable
YesSetScriptsExecutable :: SetScriptsExecutable
NoSetScriptsExecutable :: SetScriptsExecutable
setScriptsExecutable :: PrimDarcsOption SetScriptsExecutable
restrictPaths :: PrimDarcsOption Bool
amendUnrecord :: PrimDarcsOption Bool
selectAuthor :: PrimDarcsOption Bool

-- | TODO: These should be mutually exclusive, but are they? The code is
--   almost inscrutable.
humanReadable :: PrimDarcsOption Bool

-- | See above.
machineReadable :: PrimDarcsOption Bool
data CloneKind

-- | Just copy pristine and inventories
LazyClone :: CloneKind

-- | First do a lazy clone then copy everything
NormalClone :: CloneKind

-- | Same as Normal but omit telling user they can interrumpt
CompleteClone :: CloneKind
partial :: PrimDarcsOption CloneKind
distname :: PrimDarcsOption (Maybe String)
distzip :: PrimDarcsOption Bool
marks :: DarcsOption a (Maybe String -> Maybe String -> a)
readMarks :: PrimDarcsOption (Maybe String)
writeMarks :: PrimDarcsOption (Maybe String)
data PatchFormat
PatchFormat1 :: PatchFormat
PatchFormat2 :: PatchFormat
patchFormat :: PrimDarcsOption PatchFormat

-- | Deprecated flag, still present to output an error message.
hashed :: PrimDarcsOption ()
data ChangesFormat
HumanReadable :: ChangesFormat
GenContext :: ChangesFormat
GenXml :: ChangesFormat
NumberPatches :: ChangesFormat
CountPatches :: ChangesFormat
changesFormat :: PrimDarcsOption (Maybe ChangesFormat)
tokens :: PrimDarcsOption (Maybe String)
forceReplace :: PrimDarcsOption Bool
data TestStrategy
Once :: TestStrategy
Linear :: TestStrategy
Backoff :: TestStrategy
Bisect :: TestStrategy
testStrategy :: PrimDarcsOption TestStrategy
files :: PrimDarcsOption Bool
directories :: PrimDarcsOption Bool
pending :: PrimDarcsOption Bool
nullFlag :: PrimDarcsOption Bool
data GzcrcsAction
GzcrcsCheck :: GzcrcsAction
GzcrcsRepair :: GzcrcsAction
gzcrcsActions :: PrimDarcsOption (Maybe GzcrcsAction)
siblings :: PrimDarcsOption [AbsolutePath]
reorderPatches :: PrimDarcsOption Bool
optimizePatchIndex :: PrimDarcsOption (Maybe WithPatchIndex)
instance Eq RootAction
instance Show RootAction
instance Eq StdCmdAction
instance Show StdCmdAction
instance Eq XmlOutput
instance Show XmlOutput
instance Eq SelectDeps
instance Show SelectDeps
instance Eq RepoCombinator
instance Show RepoCombinator
instance Eq AskLongComment
instance Show AskLongComment
instance Eq WithContext
instance Show WithContext
instance Eq ExternalDiff
instance Show ExternalDiff
instance Eq TestChanges
instance Eq Sign
instance Show Sign
instance Eq Verify
instance Show Verify
instance Eq Output
instance Show Output
instance Eq Summary
instance Show Summary
instance Eq PatchFormat
instance Show PatchFormat
instance Eq ChangesFormat
instance Show ChangesFormat
instance Eq TestStrategy
instance Show TestStrategy
instance Eq GzcrcsAction
instance Show GzcrcsAction

module Darcs.UI.Options

-- | <a>DarcsOption</a> instantiates the first two type parameters of
--   <a>OptSpec</a> to what we need in darcs. The first parameter is
--   instantiated to The flag type is instantiate to <a>Flag</a>.
type DarcsOption = OptSpec DarcsOptDescr Flag

-- | This is <a>PrimOptSpec</a> instantiated with 'DarcsOptDescr and
--   <a>Flag</a>.
type PrimDarcsOption v = forall a. PrimOptSpec DarcsOptDescr Flag a v

-- | We do not instantiate the <tt>d</tt> in <tt><a>OptSpec</a> d f</tt>
--   directly with <a>OptDescr</a>. Instead we (post-) compose it with
--   <tt>(-&gt;) <a>AbsolutePath</a></tt>. Modulo newtype noise, this is
--   the same as
--   
--   <pre>
--   type 'DarcsOptDescr f = <a>OptDescr</a> (<a>AbsolutePath</a> -&gt; f)
--   </pre>
--   
--   This is so we can pass a directory relative to which an option
--   argument is interpreted (if it has the form of a relative path).
type DarcsOptDescr = Compose OptDescr ((->) AbsolutePath)

-- | The <tt>instance Functor OptDescr</tt> was introduced only in
--   base-4.7.0.0, which is why we implement it here manually.
optDescr :: AbsolutePath -> DarcsOptDescr f -> OptDescr f


-- | This module provides a variant of <a>usageInfo</a>.
--   
--   Unlike the standard <tt>usageInfo</tt> function, lists of long
--   switches are broken across multiple lines to economise on columns. For
--   example,
--   
--   <pre>
--   -r  --recursive           add contents of subdirectories
--       --not-recursive,
--       --no-recursive        don't add contents of subdirectories
--   
--   </pre>
module Darcs.UI.Usage

-- | Variant of <a>usageInfo</a>. Return a string describing the usage of a
--   command, derived from the header (first argument) and the options
--   described by the second argument.
--   
--   Sequences of long switches are presented on separate lines.
usageInfo :: String -> [DarcsOptDescr a] -> String

module Darcs.UI.External
sendEmail :: String -> String -> String -> String -> String -> String -> IO ()
generateEmail :: Handle -> String -> String -> String -> String -> Doc -> IO ()

-- | Send an email, optionally containing a patch bundle (more precisely,
--   its description and the bundle itself)
sendEmailDoc :: String -> String -> String -> String -> String -> Maybe (Doc, Doc) -> Doc -> IO ()
resendEmail :: String -> String -> ByteString -> IO ()
signString :: Sign -> Doc -> IO Doc
verifyPS :: Verify -> ByteString -> IO (Maybe ByteString)
execDocPipe :: RenderMode -> String -> [String] -> Doc -> IO Doc
execPipeIgnoreError :: RenderMode -> String -> [String] -> Doc -> IO Doc
pipeDoc :: RenderMode -> String -> [String] -> Doc -> IO ExitCode
pipeDocSSH :: Compression -> RenderMode -> SshFilePath -> [String] -> Doc -> IO ExitCode
maybeURLCmd :: String -> String -> IO (Maybe String)
viewDoc :: Doc -> IO ()
viewDocWith :: Printers -> RenderMode -> Doc -> IO ()
haveSendmail :: IO Bool
sendmailPath :: IO String
diffProgram :: IO String

-- | Get the name of the darcs executable (as supplied by
--   <tt>getExecutablePath</tt>)
darcsProgram :: IO String
editText :: String -> ByteString -> IO ByteString

-- | <tt>editFile f</tt> lets the user edit a file which could but does not
--   need to already exist. This function returns the exit code from the
--   text editor and a flag indicating if the user made any changes.
editFile :: FilePathLike p => p -> IO (ExitCode, Bool)
catchall :: IO a -> IO a -> IO a

-- | In some environments, darcs requires that certain global GHC library
--   variables that control the encoding used in internal translations are
--   set to specific values.
--   
--   <tt>setDarcsEncoding</tt> enforces those settings, and should be
--   called before the first time any darcs operation is run, and again if
--   anything else might have set those encodings to different values.
--   
--   Note that it isn't thread-safe and has a global effect on your
--   program.
--   
--   The current behaviour of this function is as follows, though this may
--   change in future:
--   
--   Encodings are only set on GHC 7.4 and up, on any non-Windows platform.
--   
--   Two encodings are set, both to <tt>GHC.IO.Encoding.char8</tt>:
--   <tt>GHC.IO.Encoding.setFileSystemEncoding</tt> and
--   <tt>GHC.IO.Encoding.setForeignEncoding</tt>.
--   
--   Prevent HLint from warning us about a redundant do if the macro isn't
--   defined:
setDarcsEncodings :: IO ()
getSystemEncoding :: IO String

-- | <tt>isUTF8</tt> checks if an encoding is UTF-8 (or ascii, since it is
--   a subset of UTF-8).
isUTF8Locale :: String -> Bool

module Darcs.UI.Flags

-- | The <a>DarcsFlag</a> type is a list of all flags that can ever be
--   passed to darcs, or to one of its commands.
data DarcsFlag
Version :: DarcsFlag
ExactVersion :: DarcsFlag
ListCommands :: DarcsFlag
Help :: DarcsFlag
ListOptions :: DarcsFlag
NoTest :: DarcsFlag
Test :: DarcsFlag
OnlyChangesToFiles :: DarcsFlag
ChangesToAllFiles :: DarcsFlag
LeaveTestDir :: DarcsFlag
NoLeaveTestDir :: DarcsFlag
Timings :: DarcsFlag
Debug :: DarcsFlag
DebugHTTP :: DarcsFlag
Verbose :: DarcsFlag
NormalVerbosity :: DarcsFlag
Quiet :: DarcsFlag
Target :: String -> DarcsFlag
Cc :: String -> DarcsFlag
Output :: AbsolutePathOrStd -> DarcsFlag
OutputAutoName :: AbsolutePath -> DarcsFlag
Mail :: DarcsFlag
Subject :: String -> DarcsFlag
InReplyTo :: String -> DarcsFlag
Charset :: String -> DarcsFlag
SendmailCmd :: String -> DarcsFlag
Author :: String -> DarcsFlag
SelectAuthor :: DarcsFlag
PatchName :: String -> DarcsFlag
OnePatch :: String -> DarcsFlag
SeveralPatch :: String -> DarcsFlag
OneHash :: String -> DarcsFlag
AfterPatch :: String -> DarcsFlag
UpToPatch :: String -> DarcsFlag
AfterHash :: String -> DarcsFlag
UpToHash :: String -> DarcsFlag
TagName :: String -> DarcsFlag
LastN :: Int -> DarcsFlag
MaxCount :: Int -> DarcsFlag
PatchIndexRange :: Int -> Int -> DarcsFlag
NumberPatches :: DarcsFlag
OneTag :: String -> DarcsFlag
AfterTag :: String -> DarcsFlag
UpToTag :: String -> DarcsFlag
GenContext :: DarcsFlag
Context :: AbsolutePath -> DarcsFlag
Count :: DarcsFlag
LogFile :: AbsolutePath -> DarcsFlag
RmLogFile :: DarcsFlag
DontRmLogFile :: DarcsFlag
DistName :: String -> DarcsFlag
DistZip :: DarcsFlag
All :: DarcsFlag
Recursive :: DarcsFlag
NoRecursive :: DarcsFlag
Minimize :: DarcsFlag
NoMinimize :: DarcsFlag
Reorder :: DarcsFlag
NoReorder :: DarcsFlag
RestrictPaths :: DarcsFlag
DontRestrictPaths :: DarcsFlag
AskDeps :: DarcsFlag
NoAskDeps :: DarcsFlag
IgnoreTimes :: DarcsFlag
DontIgnoreTimes :: DarcsFlag
LookForAdds :: DarcsFlag
NoLookForAdds :: DarcsFlag
LookForMoves :: DarcsFlag
NoLookForMoves :: DarcsFlag
LookForReplaces :: DarcsFlag
NoLookForReplaces :: DarcsFlag
UseMyersDiff :: DarcsFlag
UsePatienceDiff :: DarcsFlag
Intersection :: DarcsFlag
Union :: DarcsFlag
Complement :: DarcsFlag
Sign :: DarcsFlag
SignAs :: String -> DarcsFlag
NoSign :: DarcsFlag
SignSSL :: String -> DarcsFlag
HappyForwarding :: DarcsFlag
NoHappyForwarding :: DarcsFlag
Verify :: AbsolutePath -> DarcsFlag
VerifySSL :: AbsolutePath -> DarcsFlag
RemoteDarcsOpt :: String -> DarcsFlag
EditDescription :: DarcsFlag
NoEditDescription :: DarcsFlag
Toks :: String -> DarcsFlag
EditLongComment :: DarcsFlag
NoEditLongComment :: DarcsFlag
PromptLongComment :: DarcsFlag
KeepDate :: DarcsFlag
NoKeepDate :: DarcsFlag
AllowConflicts :: DarcsFlag
MarkConflicts :: DarcsFlag
NoAllowConflicts :: DarcsFlag
SkipConflicts :: DarcsFlag
Boring :: DarcsFlag
SkipBoring :: DarcsFlag
AllowCaseOnly :: DarcsFlag
DontAllowCaseOnly :: DarcsFlag
AllowWindowsReserved :: DarcsFlag
DontAllowWindowsReserved :: DarcsFlag
DontGrabDeps :: DarcsFlag
DontPromptForDependencies :: DarcsFlag
PromptForDependencies :: DarcsFlag
Compress :: DarcsFlag
NoCompress :: DarcsFlag
UnCompress :: DarcsFlag
WorkRepoDir :: String -> DarcsFlag
WorkRepoUrl :: String -> DarcsFlag
RemoteRepo :: String -> DarcsFlag
NewRepo :: String -> DarcsFlag
NotInRemote :: (Maybe String) -> DarcsFlag
Reply :: String -> DarcsFlag
ApplyAs :: String -> DarcsFlag
MachineReadable :: DarcsFlag
HumanReadable :: DarcsFlag
Pipe :: DarcsFlag
Interactive :: DarcsFlag
DiffCmd :: String -> DarcsFlag
ExternalMerge :: String -> DarcsFlag
Summary :: DarcsFlag
NoSummary :: DarcsFlag
PauseForGui :: DarcsFlag
NoPauseForGui :: DarcsFlag
Unified :: DarcsFlag
NonUnified :: DarcsFlag
Reverse :: DarcsFlag
Forward :: DarcsFlag
Complete :: DarcsFlag
Lazy :: DarcsFlag
DiffFlags :: String -> DarcsFlag
XMLOutput :: DarcsFlag
ForceReplace :: DarcsFlag
OnePattern :: String -> DarcsFlag
SeveralPattern :: String -> DarcsFlag
AfterPattern :: String -> DarcsFlag
UpToPattern :: String -> DarcsFlag
NonApply :: DarcsFlag
NonVerify :: DarcsFlag
NonForce :: DarcsFlag
DryRun :: DarcsFlag
SetDefault :: DarcsFlag
NoSetDefault :: DarcsFlag
Disable :: DarcsFlag
SetScriptsExecutable :: DarcsFlag
DontSetScriptsExecutable :: DarcsFlag
Once :: DarcsFlag
Linear :: DarcsFlag
Backoff :: DarcsFlag
Bisect :: DarcsFlag
Hashed :: DarcsFlag
UseFormat1 :: DarcsFlag
UseFormat2 :: DarcsFlag
UseNoWorkingDir :: DarcsFlag
UseWorkingDir :: DarcsFlag
Sibling :: AbsolutePath -> DarcsFlag
Files :: DarcsFlag
NoFiles :: DarcsFlag
Directories :: DarcsFlag
NoDirectories :: DarcsFlag
Pending :: DarcsFlag
NoPending :: DarcsFlag
PosthookCmd :: String -> DarcsFlag
NoPosthook :: DarcsFlag
AskPosthook :: DarcsFlag
RunPosthook :: DarcsFlag
PrehookCmd :: String -> DarcsFlag
NoPrehook :: DarcsFlag
AskPrehook :: DarcsFlag
RunPrehook :: DarcsFlag
UMask :: String -> DarcsFlag
StoreInMemory :: DarcsFlag
ApplyOnDisk :: DarcsFlag
NoHTTPPipelining :: DarcsFlag
Packs :: DarcsFlag
NoPacks :: DarcsFlag
NoCache :: DarcsFlag
AllowUnrelatedRepos :: DarcsFlag
Check :: DarcsFlag
Repair :: DarcsFlag
JustThisRepo :: DarcsFlag
ReadMarks :: String -> DarcsFlag
WriteMarks :: String -> DarcsFlag
NullFlag :: DarcsFlag
NoAmendUnrecord :: DarcsFlag
AmendUnrecord :: DarcsFlag
PatchIndexFlag :: DarcsFlag
NoPatchIndexFlag :: DarcsFlag
compression :: Config -> Compression
remoteDarcs :: Config -> RemoteDarcs
reorder :: Config -> Reorder
minimize :: Config -> Bool
editDescription :: Config -> Bool
diffingOpts :: Config -> (UseIndex, ScanKnown, DiffAlgorithm)

-- | Non-trivial interaction between options.
diffOpts :: UseIndex -> LookForAdds -> Bool -> DiffAlgorithm -> (UseIndex, ScanKnown, DiffAlgorithm)
externalMerge :: Config -> ExternalMerge

-- | This will become dis-entangled as soon as we inline these functions.
wantGuiPause :: Config -> WantGuiPause

-- | Non-trivial interaction between options. Explicit <tt>-i</tt> or
--   <tt>-a</tt> dominates, else <tt>--count</tt>, <tt>--xml</tt>, or
--   <tt>--dry-run</tt> imply <tt>-a</tt>, else default to interactive.
isInteractive :: Config -> Bool
maxCount :: Config -> Maybe Int
willRemoveLogFile :: Config -> Bool
isUnified :: Config -> WithContext
doHappyForwarding :: Config -> Bool
includeBoring :: Config -> Bool
doAllowCaseOnly :: Config -> Bool
doAllowWindowsReserved :: Config -> Bool
doReverse :: Config -> Bool
usePacks :: Config -> Bool
showChangesOnlyToFiles :: Config -> Bool
removeFromAmended :: Config -> Bool
toMatchFlags :: Config -> [MatchFlag]
verbosity :: Config -> Verbosity
useCache :: Config -> UseCache
umask :: Config -> UMask
dryRun :: Config -> DryRun
lookForAdds :: Config -> LookForAdds
lookForMoves :: Config -> LookForMoves
lookForReplaces :: Config -> LookForReplaces
diffAlgorithm :: Config -> DiffAlgorithm
runTest :: Config -> RunTest
testChanges :: Config -> TestChanges
setScriptsExecutable :: Config -> SetScriptsExecutable
withWorkingDir :: Config -> WithWorkingDir
leaveTestDir :: Config -> LeaveTestDir
remoteRepos :: Config -> RemoteRepos
setDefault :: Bool -> Config -> SetDefault
cloneKind :: Config -> CloneKind
workRepo :: Config -> WorkRepo
allowConflicts :: Config -> AllowConflicts
runPatchIndex :: Config -> WithPatchIndex
useIndex :: Config -> UseIndex
hasSummary :: Summary -> Config -> Summary
hasXmlOutput :: Config -> XmlOutput
selectDeps :: Config -> SelectDeps
hasAuthor :: Config -> Maybe String
hasLogfile :: Config -> Maybe AbsolutePath
patchFormat :: Config -> PatchFormat

-- | Ugly. The alternative is to put the remoteRepos accessor into the IO
--   monad, which is hardly better.
fixRemoteRepos :: AbsolutePath -> Config -> IO Config

-- | <a>fixUrl</a> takes a String that may be a file path or a URL. It
--   returns either the URL, or an absolute version of the path.
fixUrl :: AbsolutePath -> String -> IO String

-- | <tt>fixSubPaths files</tt> returns the <tt>SubPath</tt>s for the paths
--   in <tt>files</tt> that are inside the repository, preserving their
--   order. Paths in <tt>files</tt> that are outside the repository
--   directory are not in the result.
--   
--   When converting a relative path to an absolute one, this function
--   first tries to interpret the relative path with respect to the current
--   working directory. If that fails, it tries to interpret it with
--   respect to the repository directory. Only when that fails does it omit
--   the path from the result.
--   
--   It is intended for validating file arguments to darcs commands.
fixSubPaths :: (AbsolutePath, AbsolutePath) -> [FilePath] -> IO [SubPath]

-- | <tt>maybeFixSubPaths files</tt> tries to turn the file paths in its
--   argument into <tt>SubPath</tt>s.
--   
--   When converting a relative path to an absolute one, this function
--   first tries to interpret the relative path with respect to the current
--   working directory. If that fails, it tries to interpret it with
--   respect to the repository directory. Only when that fails does it put
--   a <tt>Nothing</tt> in the result at the position of the path that
--   cannot be converted.
--   
--   It is intended for validating file arguments to darcs commands.
maybeFixSubPaths :: (AbsolutePath, AbsolutePath) -> [FilePath] -> IO [Maybe SubPath]

-- | <a>getRepourl</a> takes a list of flags and returns the url of the
--   repository specified by <tt>Repodir "directory"</tt> in that list of
--   flags, if any. This flag is present if darcs was invoked with
--   <tt>--repodir=DIRECTORY</tt>
getRepourl :: Config -> Maybe String

-- | <a>getAuthor</a> takes a list of flags and returns the author of the
--   change specified by <tt>Author "Leo Tolstoy"</tt> in that list of
--   flags, if any. Otherwise, if <tt>Pipe</tt> is present, asks the user
--   who is the author and returns the answer. If neither are present, try
--   to guess the author, from repository or global preference files or
--   environment variables, and if it's not possible, ask the user.
getAuthor :: Maybe String -> Bool -> IO String

-- | <a>promptAuthor</a> try to guess the author, from repository or global
--   preference files or environment variables, and if it's not possible or
--   alwaysAsk parameter is true, ask the user. If store parameter is true,
--   the new author is added into <tt>_darcs/prefs</tt>.
promptAuthor :: Bool -> Bool -> IO String

-- | <a>getEasyAuthor</a> tries to get the author name first from the
--   repository preferences, then from global preferences, then from
--   environment variables. Returns <tt>[]</tt> if it could not get it.
--   Note that it may only return multiple possibilities when reading from
--   global preferences
getEasyAuthor :: IO [String]

-- | <a>getSendmailCmd</a> takes a list of flags and returns the sendmail
--   command to be used by <tt>darcs send</tt>. Looks for a command
--   specified by <tt>SendmailCmd "command"</tt> in that list of flags, if
--   any. This flag is present if darcs was invoked with
--   <tt>--sendmail-command=COMMAND</tt> Alternatively the user can set
--   <tt>$S</tt><tt>ENDMAIL</tt> which will be used as a fallback if
--   present.
getSendmailCmd :: Config -> IO String
fileHelpAuthor :: [String]
environmentHelpEmail :: ([String], [String])

-- | <a>getSubject</a> takes a list of flags and returns the subject of the
--   mail to be sent by <tt>darcs send</tt>. Looks for a subject specified
--   by <tt>Subject "subject"</tt> in that list of flags, if any. This flag
--   is present if darcs was invoked with <tt>--subject=SUBJECT</tt>
getSubject :: Config -> Maybe String
getCharset :: Config -> Maybe String
getInReplyTo :: Config -> Maybe String

-- | <a>getCc</a> takes a list of flags and returns the addresses to send a
--   copy of the patch bundle to when using <tt>darcs send</tt>. looks for
--   a cc address specified by <tt>Cc "address"</tt> in that list of flags.
--   Returns the addresses as a comma separated string.
getCc :: Config -> String
environmentHelpSendmail :: ([String], [String])

-- | <tt>flagsToSiblings</tt> collects the contents of all <tt>Sibling</tt>
--   flags in a list of flags.
siblings :: Config -> [AbsolutePath]

-- | Accessor for output option
getOutput :: Config -> FilePath -> Maybe AbsolutePathOrStd
getDate :: Bool -> IO String
getReply :: Config -> Maybe String
applyAs :: Config -> Maybe String

module Darcs.UI.CommandsAux

-- | A convenience function to call from all darcs command functions before
--   applying any patches. It checks for malicious paths in patches, and
--   prints an error message and fails if it finds one.
checkPaths :: PatchInspect p => [DarcsFlag] -> FL p wX wY -> IO ()

-- | Filter out patches that contains some malicious file path
maliciousPatches :: PatchInspect p => [Sealed2 p] -> [Sealed2 p]
hasMaliciousPath :: PatchInspect p => p wX wY -> Bool


-- | This module is used by the push and put commands to apply a bundle to
--   a remote repository. By remote I do not necessarily mean a repository
--   on another machine, it is just not the repository we're located in.
module Darcs.UI.RemoteApply
remoteApply :: [DarcsFlag] -> String -> Doc -> IO ExitCode

module Darcs.Patch.TouchesFiles
lookTouch :: (Patchy p, PatchInspect p, ApplyState p ~ Tree) => Maybe [(FilePath, FilePath)] -> [FilePath] -> p wX wY -> (Bool, [FilePath], [FilePath], [(FilePath, FilePath)])
chooseTouching :: (Patchy p, PatchInspect p, ApplyState p ~ Tree) => Maybe [FilePath] -> FL p wX wY -> Sealed (FL p wX)
choosePreTouching :: (Patchy p, PatchInspect p, ApplyState p ~ Tree) => Maybe [FilePath] -> FL p wX wY -> Sealed (FL p wX)
selectTouching :: (Patchy p, PatchInspect p, ApplyState p ~ Tree) => Maybe [FilePath] -> PatchChoices p wX wY -> PatchChoices p wX wY
deselectNotTouching :: (Patchy p, PatchInspect p, ApplyState p ~ Tree) => Maybe [FilePath] -> PatchChoices p wX wY -> PatchChoices p wX wY
selectNotTouching :: (Patchy p, PatchInspect p, ApplyState p ~ Tree) => Maybe [FilePath] -> PatchChoices p wX wY -> PatchChoices p wX wY

module Darcs.Repository.InternalTypes

-- | A <tt>Repository</tt> is a token representing the state of a
--   repository on disk. It is parameterized by the patch type in the
--   repository, and witnesses for the recorded state of the repository
--   (i.e. what darcs get would retrieve), the unrecorded state (what's in
--   the working directory now), and the tentative state, which represents
--   work in progress that will eventually become the new recorded state
--   unless something goes wrong.
data Repository (p :: * -> * -> *) wRecordedstate wUnrecordedstate wTentativestate
Repo :: !String -> !RepoFormat -> !Pristine -> Cache -> Repository wRecordedstate wUnrecordedstate wTentativestate
data Pristine
NoPristine :: Pristine
PlainPristine :: Pristine
HashedPristine :: Pristine
extractCache :: Repository p wR wU wT -> Cache

-- | <a>modifyCache</a> <tt>repository function</tt> modifies the cache of
--   <tt>repository</tt> with <tt>function</tt>, remove duplicates and sort
--   the results with <a>compareByLocality</a>.
modifyCache :: RepoPatch p => Repository p wR wU wT -> (Cache -> Cache) -> Repository p wR wU wT
instance Show Pristine
instance Eq Pristine
instance Show (Repository p wRecordedstate wUnrecordedstate wTentativestate)

module Darcs.Repository.HashedRepo
inventoriesDir :: String
pristineDir :: String
patchesDir :: String
hashedInventory :: String

-- | revertTentativeChanges swaps the tentative and "real" hashed inventory
--   files, and then updates the tentative pristine with the "real"
--   inventory hash.
revertTentativeChanges :: IO ()

-- | finalizeTentativeChanges trys to atomically swap the tentative
--   inventory/pristine pointers with the "real" pointers; it first
--   re-reads the inventory to optimize it, presumably to take account of
--   any new tags, and then writes out the new tentative inventory, and
--   finally does the atomic swap. In general, we can't clean the pristine
--   cache at the same time, since a simultaneous get might be in progress.
finalizeTentativeChanges :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Compression -> IO ()

-- | cleanPristine removes any obsolete (unreferenced) entries in the
--   pristine cache.
cleanPristine :: Repository p wR wU wT -> IO ()

-- | filterDirContents returns the contents of the directory <tt>d</tt>
--   except files whose names begin with <a>.</a> (directories . and ..,
--   hidden files) and files whose names are filtered by the function
--   <tt>f</tt>, if <tt>dir</tt> is empty, no paths are returned.
filterDirContents :: FilePath -> (FilePath -> Bool) -> IO [FilePath]

-- | cleanInventories removes any obsolete (unreferenced) files in the
--   inventories directory.
cleanInventories :: Repository p wR wU wT -> IO ()

-- | cleanPatches removes any obsolete (unreferenced) files in the patches
--   directory.
cleanPatches :: Repository p wR wU wT -> IO ()

-- | copyPristine copies a pristine tree into the current pristine dir, and
--   possibly copies a clean working copy. The target is read from the
--   passed-in dir/inventory name combination.
copyPristine :: Cache -> String -> String -> WithWorkingDir -> IO ()

-- | copyPartialsPristine copies the pristine entries for a given list of
--   filepaths.
copyPartialsPristine :: FilePathLike fp => Cache -> String -> String -> [fp] -> IO ()

-- | applyToTentativePristine applies a patch <tt>p</tt> to the tentative
--   pristine tree, and updates the tentative pristine hash
applyToTentativePristine :: (ApplyState p ~ Tree, Patchy p) => p wX wY -> IO ()

-- | addToSpecificInventory adds a patch to a specific inventory file, and
--   returns the FilePath whichs corresponds to the written-out patch.
addToSpecificInventory :: RepoPatch p => String -> Cache -> Compression -> PatchInfoAnd p wX wY -> IO FilePath
addToTentativeInventory :: RepoPatch p => Cache -> Compression -> PatchInfoAnd p wX wY -> IO FilePath

-- | removeFromTentativeInventory attempts to remove an FL of patches from
--   the tentative inventory. This is used for commands that wish to modify
--   already-recorded patches.
removeFromTentativeInventory :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Compression -> FL (PatchInfoAnd p) wX wT -> IO ()

-- | readRepo returns the "current" repo patchset.
readRepo :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> String -> IO (PatchSet p Origin wR)

-- | readRepo returns the tentative repo patchset.
readTentativeRepo :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> String -> IO (PatchSet p Origin wT)

-- | readRepoUsingSpecificInventory uses the inventory at <tt>invPath</tt>
--   to read the repository <tt>repo</tt>.
readRepoUsingSpecificInventory :: (RepoPatch p, ApplyState p ~ Tree) => String -> Repository p wR wU wT -> String -> IO (PatchSet p Origin wS)

-- | writeAndReadPatch makes a patch lazy, by writing it out to disk (thus
--   forcing it), and then re-reads the patch lazily.
writeAndReadPatch :: RepoPatch p => Cache -> Compression -> PatchInfoAnd p wX wY -> IO (PatchInfoAnd p wX wY)

-- | writeTentativeInventory writes <tt>patchSet</tt> as the tentative
--   inventory.
writeTentativeInventory :: RepoPatch p => Cache -> Compression -> PatchSet p Origin wX -> IO ()

-- | copyRepo copies the hashed inventory of <tt>repo</tt> to the
--   repository located at <tt>remote</tt>.
copyHashedInventory :: RepoPatch p => Repository p wR wU wT -> RemoteDarcs -> String -> IO ()

-- | readHashedPristineRoot attempts to read the pristine hash from the
--   current inventory, returning Nothing if it cannot do so.
readHashedPristineRoot :: Repository p wR wU wT -> IO (Maybe String)

-- | pris2inv takes an updated pristine hash and an inventory, and outputs
--   the new pristine hash followed by the original inventory (having
--   skipped the old inventory hash).
pris2inv :: String -> ByteString -> Doc

-- | inv2pris takes the content of an inventory, and extracts the
--   corresponding pristine hash from the inventory (the hash is prefixed
--   by "pristine:").
inv2pris :: ByteString -> String

-- | <a>copySources</a> copies the prefs/sources file to the local repo,
--   from the remote, having first filtered the local filesystem sources.
copySources :: RepoPatch p => Repository p wR wU wT -> String -> IO ()

-- | listInventories returns a list of the inventories hashes. This
--   function attempts to retrieve missing inventory files.
listInventories :: IO [String]

-- | listInventoriesLocal returns a list of the inventories hashes. This
--   function does not attempt to retrieve missing inventory files.
listInventoriesLocal :: IO [String]

-- | listInventoriesRepoDir returns a list of the inventories hashes. The
--   argument <tt>repoDir</tt> is the directory of the repository from
--   which we are going to read the "hashed_inventory" file. The rest of
--   hashed files are read from the global cache.
listInventoriesRepoDir :: String -> IO [String]

-- | listPatchesLocalBucketed is similar to listPatchesLocal, but it read
--   the inventory directory under <tt>darcsDir</tt> in bucketed format.
listPatchesLocalBucketed :: String -> String -> IO [String]

-- | writeHashIfNecessary writes the patch and returns the resulting
--   info/hash, if it has not already been written. If it has been written,
--   we have the hash in the PatchInfoAnd, so we extract and return the
--   info/hash.
writePatchIfNecessary :: RepoPatch p => Cache -> Compression -> PatchInfoAnd p wX wY -> IO (PatchInfo, String)

-- | readRepoFromInventoryList allows the caller to provide an optional
--   "from inventory" hash, and a list of info/hash pairs that identify a
--   list of patches, returning a patchset of the resulting repo.
readRepoFromInventoryList :: (RepoPatch p, ApplyState p ~ Tree) => Cache -> (Maybe String, [(PatchInfo, String)]) -> IO (SealedPatchSet p Origin)

-- | 'readPatchIds inventory' parses the content of a hashed_inventory file
--   after the "pristine:" and "Starting with inventory:" header lines have
--   been removed. The second value in the resulting tuples is the file
--   hash of the associated patch (the "hash:" line).
readPatchIds :: ByteString -> [(PatchInfo, String)]

-- | set converts a list of strings into a set of Char8 ByteStrings for
--   faster Set operations.
set :: [String] -> Set ByteString

-- | unset is the inverse of set.
unset :: Set ByteString -> [String]


module Darcs.Repository.Diff
treeDiff :: (Functor m, Monad m, Gap w, PrimPatch prim) => DiffAlgorithm -> (FilePath -> FileType) -> Tree m -> Tree m -> m (w (FL prim))

module Darcs.Repository.LowLevel

-- | Read the contents of pending. The return type is currently incorrect
--   as it refers to the tentative state rather than the recorded state.
readPending :: RepoPatch p => Repository p wR wU wT -> IO (Sealed (FL (PrimOf p) wT))

-- | Read the contents of tentative pending.
readTentativePending :: RepoPatch p => Repository p wR wU wT -> IO (Sealed (FL (PrimOf p) wT))

-- | Write the contents of tentative pending.
writeTentativePending :: RepoPatch p => Repository p wR wU wT -> FL (PrimOf p) wT wY -> IO ()

-- | Read the contents of tentative pending.
readNewPending :: RepoPatch p => Repository p wR wU wT -> IO (Sealed (FL (PrimOf p) wT))

-- | Write the contents of new pending. CWD should be the repository
--   directory.
writeNewPending :: RepoPatch p => Repository p wR wU wT -> FL (PrimOf p) wT wY -> IO ()
pendingName :: String
instance ShowPatchBasic p => ShowPatchBasic (FLM p)
instance ReadPatch p => ReadPatch (FLM p)

module Darcs.Repository.State

-- | From a repository and a list of SubPath's, construct a filter that can
--   be used on a Tree (recorded or unrecorded state) of this repository.
--   This constructed filter will take pending into account, so the
--   subpaths will be translated correctly relative to pending move
--   patches.
restrictSubpaths :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> [SubPath] -> IO (TreeFilter m)

-- | Construct a Tree filter that removes any boring files the Tree might
--   have contained. Additionally, you should (in most cases) pass an
--   (expanded) Tree that corresponds to the recorded content of the
--   repository. This is important in the cases when the repository
--   contains files that would be boring otherwise. (If you pass emptyTree
--   instead, such files will simply be discarded by the filter, which is
--   usually not what you want.)
--   
--   This function is most useful when you have a plain Tree corresponding
--   to the full working copy of the repository, including untracked files.
--   Cf. whatsnew, record --look-for-adds. NB. Assumes that our CWD is the
--   repository root.
restrictBoring :: Tree m -> IO (TreeFilter m)
newtype TreeFilter m
TreeFilter :: (forall tr. FilterTree tr m => tr m -> tr m) -> TreeFilter m
applyTreeFilter :: TreeFilter m -> forall tr. FilterTree tr m => tr m -> tr m

-- | Construct a Tree filter that removes any darcs metadata files the Tree
--   might have contained.
restrictDarcsdir :: TreeFilter m

-- | For a repository and an optional list of paths (when Nothing, take
--   everything) compute a (forward) list of prims (i.e. a patch) going
--   from the recorded state of the repository (pristine) to the unrecorded
--   state of the repository (the working copy + pending). When a list of
--   paths is given, at least the files that live under any of these paths
--   in either recorded or unrecorded will be included in the resulting
--   patch. NB. More patches may be included in this list, eg. the full
--   contents of the pending patch. This is usually not a problem, since
--   selectChanges will properly filter the results anyway.
--   
--   This also depends on the options given: with LookForAdds, we will
--   include any non-boring files (i.e. also those that do not exist in the
--   "recorded" state) in the working in the "unrecorded" state, and
--   therefore they will show up in the patches as addfiles.
--   
--   The IgnoreTimes option disables index usage completely -- for each
--   file, we read both the unrecorded and the recorded copy and run a diff
--   on them. This is very inefficient, although in extremely rare cases,
--   the index could go out of sync (file is modified, index is updated and
--   file is modified again within a single second).
unrecordedChanges :: (RepoPatch p, ApplyState p ~ Tree) => (UseIndex, ScanKnown, DiffAlgorithm) -> Repository p wR wU wT -> Maybe [SubPath] -> IO (FL (PrimOf p) wT wU)
unrecordedChangesWithPatches :: (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree) => (UseIndex, ScanKnown, DiffAlgorithm) -> Repository p wR wU wT -> Maybe [SubPath] -> FL (PrimOf p) wX wT -> FL (PrimOf p) wT wT -> IO (FL (PrimOf p) wT wU)
readPending :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (Tree IO, Sealed (FL p wT))

-- | Obtains a Tree corresponding to the "recorded" state of the
--   repository: this is the same as the pristine cache, which is the same
--   as the result of applying all the repository's patches to an empty
--   directory.
--   
--   Handles the plain and hashed pristine cases. Currently does not handle
--   the no-pristine case, as that requires replaying patches. Cf.
--   <a>readDarcsHashed</a> and <a>readPlainTree</a> in hashed-storage that
--   are used to do the actual <a>Tree</a> construction.
readRecorded :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (Tree IO)

-- | Obtains a Tree corresponding to the "unrecorded" state of the
--   repository: the working tree plus the "pending" patch. The optional
--   list of paths allows to restrict the query to a subtree.
--   
--   Limiting the query may be more efficient, since hashes on the
--   uninteresting parts of the index do not need to go through an
--   up-to-date check (which involves a relatively expensive lstat(2) per
--   file.
readUnrecorded :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Maybe [SubPath] -> IO (Tree IO)
readRecordedAndPending :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (Tree IO)

-- | Obtains a Tree corresponding to the working copy of the repository.
--   NB. Almost always, using readUnrecorded is the right choice. This
--   function is only useful in not-completely-constructed repositories.
readWorking :: IO (Tree IO)

-- | Mostly a helper function to <a>unrecordedChanges</a>, returning the
--   pending patch and the subsequent diff from working as two different
--   patches
readPendingAndWorking :: (RepoPatch p, ApplyState p ~ Tree) => (UseIndex, ScanKnown, DiffAlgorithm) -> Repository p wR wU wT -> Maybe [SubPath] -> IO ((FL (PrimOf p) :> FL (PrimOf p)) wT wU)
readIndex :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO Index
updateIndex :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO ()

-- | Mark the existing index as invalid. This has to be called whenever the
--   listing of pristine changes and will cause darcs to update the index
--   next time it tries to read it. (NB. This is about files added and
--   removed from pristine: changes to file content in either pristine or
--   working are handled transparently by the index reading code.)
invalidateIndex :: t -> IO ()
data UseIndex
UseIndex :: UseIndex
IgnoreIndex :: UseIndex
data ScanKnown

-- | Just files already known to darcs
ScanKnown :: ScanKnown

-- | All files, i.e. look for new ones
ScanAll :: ScanKnown

-- | All files, even boring ones
ScanBoring :: ScanKnown

-- | Remove any patches (+dependencies) from a sequence that conflict with
--   the recorded or unrecorded changes in a repo
filterOutConflicts :: (RepoPatch p, ApplyState p ~ Tree) => RL (PatchInfoAnd p) wX wT -> Repository p wR wU wT -> FL (PatchInfoAnd p) wX wZ -> IO (Bool, Sealed (FL (PatchInfoAnd p) wX))

module Darcs.Repository.Old
readOldRepo :: RepoPatch p => String -> IO (SealedPatchSet p Origin)
revertTentativeChanges :: IO ()
oldRepoFailMsg :: String

module Darcs.Repository.Read
readRepo :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (PatchSet p Origin wR)

module Darcs.Repository.PatchIndex

-- | check if patch-index exits for this repository
doesPatchIndexExist :: FilePath -> IO Bool

-- | check if noPatchIndex exists
isPatchIndexDisabled :: FilePath -> IO Bool

-- | check if patch-index is in sync with repository
isPatchIndexInSync :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO Bool

-- | see if the default is to use patch index or not | creates Patch index,
--   if it does not exist, and noPatchIndex is not set
canUsePatchIndex :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO Bool

-- | Checks whether a patch index can (and should) be created. If we are
--   not in an old-fashioned repo, and if we haven't been told not to, then
--   we should create a patch index if it doesn't already exist.
canCreatePI :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO Bool
createPIWithInterrupt :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO ()

-- | create or update patch index
createOrUpdatePatchIndexDisk :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO ()
deletePatchIndex :: FilePath -> IO ()
dumpPatchIndex :: FilePath -> IO ()
dumpPatchIndexFiles :: FilePath -> IO ()

-- | filter given patches so as to keep only the patches that modify the
--   given files
filterPatches :: (RepoPatch p, ApplyState p ~ Tree, a ~ PatchInfoAnd p) => Repository p wR wU wT -> [FilePath] -> [Sealed2 a] -> IO [Sealed2 a]
type PatchFilter p = [FilePath] -> [Sealed2 (PatchInfoAnd p)] -> IO [Sealed2 (PatchInfoAnd p)]

-- | If a patch index is available, filter given patches so as to keep only
--   the patches that modify the given files. If none is available, return
--   the original input.
maybeFilterPatches :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> PatchFilter p
getRelevantSubsequence :: (RepoPatch p, ApplyState p ~ Tree, a ~ PatchInfoAnd p) => Sealed ((RL a) wK) -> Repository p wR wU wR -> [FileName] -> IO (Sealed ((RL a) Origin))
piTest :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO ()

-- | Check if patch index can be created and build it with interrupt.
attemptCreatePatchIndex :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO ()
instance Show FileIdSpan
instance Eq FileIdSpan
instance Ord FileIdSpan
instance Show FilePathSpan
instance Eq FilePathSpan
instance Ord FilePathSpan
instance Show FileInfo
instance Eq FileInfo
instance Ord FileInfo

module Darcs.Repository.Internal

-- | A <tt>Repository</tt> is a token representing the state of a
--   repository on disk. It is parameterized by the patch type in the
--   repository, and witnesses for the recorded state of the repository
--   (i.e. what darcs get would retrieve), the unrecorded state (what's in
--   the working directory now), and the tentative state, which represents
--   work in progress that will eventually become the new recorded state
--   unless something goes wrong.
data Repository (p :: * -> * -> *) wRecordedstate wUnrecordedstate wTentativestate
Repo :: !String -> !RepoFormat -> !Pristine -> Cache -> Repository wRecordedstate wUnrecordedstate wTentativestate

-- | Tries to identify the repository in a given directory
maybeIdentifyRepository :: UseCache -> String -> IO (IdentifyRepo p wR wU wT)

-- | identifyRepository identifies the repo at <tt>url</tt>. Warning: you
--   have to know what kind of patches are found in that repo.
identifyRepository :: UseCache -> String -> IO (Repository p wR wU wT)

-- | <tt>identifyRepositoryFor repo url</tt> identifies (and returns) the
--   repo at <tt>url</tt>, but fails if it is not compatible for reading
--   from and writing to.
identifyRepositoryFor :: RepoPatch p => Repository p wR wU wT -> UseCache -> String -> IO (Repository p vR vU vT)

-- | The status of a given directory: is it a darcs repository?
data IdentifyRepo p wR wU wT

-- | looks like a repository with some error
BadRepository :: String -> IdentifyRepo p wR wU wT

-- | safest guess
NonRepository :: String -> IdentifyRepo p wR wU wT
GoodRepository :: (Repository p wR wU wT) -> IdentifyRepo p wR wU wT
findRepository :: WorkRepo -> IO (Either String ())
amInRepository :: WorkRepo -> IO (Either String ())
amNotInRepository :: WorkRepo -> IO (Either String ())
amInHashedRepository :: WorkRepo -> IO (Either String ())

-- | Slightly confusingly named: as well as throwing away any tentative
--   changes, revertRepositoryChanges also re-initialises the tentative
--   state. It's therefore used before makign any changes to the repo.
revertRepositoryChanges :: RepoPatch p => Repository p wR wU wT -> UpdateWorking -> IO ()
announceMergeConflicts :: (PrimPatch p, PatchInspect p) => String -> AllowConflicts -> ExternalMerge -> FL p wX wY -> IO Bool

-- | setTentativePending is basically unsafe. It overwrites the pending
--   state with a new one, not related to the repository state.
setTentativePending :: RepoPatch p => Repository p wR wU wT -> UpdateWorking -> FL (PrimOf p) wX wY -> IO ()
checkUnrecordedConflicts :: RepoPatch p => UpdateWorking -> FL (Named p) wT wY -> IO Bool
readRepo :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (PatchSet p Origin wR)
readTentativeRepo :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (PatchSet p Origin wT)
readRepoUsingSpecificInventory :: (RepoPatch p, ApplyState p ~ Tree) => String -> Repository p wR wU wT -> IO (PatchSet p Origin wT)
prefsUrl :: Repository p wR wU wT -> String
withRecorded :: RepoPatch p => Repository p wR wU wT -> ((AbsolutePath -> IO a) -> IO a) -> (AbsolutePath -> IO a) -> IO a
withTentative :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> ((AbsolutePath -> IO a) -> IO a) -> (AbsolutePath -> IO a) -> IO a
tentativelyAddPatch :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Compression -> Verbosity -> UpdateWorking -> PatchInfoAnd p wT wY -> IO (Repository p wR wU wY)
tentativelyRemovePatches :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Compression -> UpdateWorking -> FL (PatchInfoAnd p) wX wT -> IO (Repository p wR wU wX)
tentativelyRemovePatches_ :: (RepoPatch p, ApplyState p ~ Tree) => UpdatePristine -> Repository p wR wU wT -> Compression -> UpdateWorking -> FL (PatchInfoAnd p) wX wT -> IO (Repository p wR wU wX)

-- | <tt>tentativelyRemoveFromPending p</tt> is used by Darcs whenever it
--   adds a patch to the repository (eg. with apply or record). Think of it
--   as one part of transferring patches from pending to somewhere else.
--   
--   Question (Eric Kow): how do we detect patch equivalence?
tentativelyRemoveFromPending :: RepoPatch p => Repository p wR wU wT -> UpdateWorking -> PatchInfoAnd p wX wY -> IO ()

-- | <tt>tentativelyAddToPending repo NoDryRun YesUpdateWorking pend
--   ps</tt> appends <tt>ps</tt> to the pending patch.
--   
--   It has no effect with <tt>NoUpdateWorking</tt>.
--   
--   This fuction is unsafe because it accepts a patch that works on the
--   tentative pending and we don't currently track the state of the
--   tentative pending.
tentativelyAddToPending :: RepoPatch p => Repository p wR wU wT -> UpdateWorking -> FL (PrimOf p) wX wY -> IO ()
tentativelyAddPatch_ :: (RepoPatch p, ApplyState p ~ Tree) => UpdatePristine -> Repository p wR wU wT -> Compression -> Verbosity -> UpdateWorking -> PatchInfoAnd p wT wY -> IO (Repository p wR wU wY)
tentativelyAddPatches_ :: (RepoPatch p, ApplyState p ~ Tree) => UpdatePristine -> Repository p wR wU wT -> Compression -> Verbosity -> UpdateWorking -> FL (PatchInfoAnd p) wT wY -> IO (Repository p wR wU wY)

-- | Given a sequence of patches anchored at the end of the current
--   repository, actually pull them to the end of the repository by
--   removing any patches with the same name and then adding the passed in
--   sequence. Typically callers will have obtained the passed in sequence
--   using <tt>findCommon</tt> and friends.
tentativelyReplacePatches :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Compression -> UpdateWorking -> Verbosity -> FL (PatchInfoAnd p) wX wT -> IO ()
finalizeRepositoryChanges :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> UpdateWorking -> Compression -> IO ()
unrevertUrl :: Repository p wR wU wT -> String
applyToWorking :: (ApplyState (PrimOf p) ~ Tree, RepoPatch p) => Repository p wR wU wT -> Verbosity -> FL (PrimOf p) wU wY -> IO (Repository p wR wY wT)
patchSetToPatches :: RepoPatch p => PatchSet p wX wY -> FL (Named p) wX wY

-- | grab the pristine hash of _darcs/hash_inventory, and retrieve whole
--   pristine tree, possibly writing a clean working copy in the process.
createPristineDirectoryTree :: RepoPatch p => Repository p wR wU wT -> FilePath -> WithWorkingDir -> IO ()

-- | Used by the commands dist and diff
createPartialsPristineDirectoryTree :: (FilePathLike fp, RepoPatch p) => Repository p wR wU wT -> [fp] -> FilePath -> IO ()

-- | Writes out a fresh copy of the inventory that minimizes the amount of
--   inventory that need be downloaded when people pull from the
--   repository.
--   
--   Specifically, it breaks up the inventory on the most recent tag. This
--   speeds up most commands when run remotely, both because a smaller file
--   needs to be transfered (only the most recent inventory). It also gives
--   a guarantee that all the patches prior to a given tag are included in
--   that tag, so less commutation and history traversal is needed. This
--   latter issue can become very important in large repositories.
reorderInventory :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wR -> Compression -> UpdateWorking -> Verbosity -> IO ()
cleanRepository :: RepoPatch p => Repository p wR wU wT -> IO ()
setScriptsExecutable :: IO ()
setScriptsExecutablePatches :: PatchInspect p => p wX wY -> IO ()
data UpdatePristine
UpdatePristine :: UpdatePristine
DontUpdatePristine :: UpdatePristine
DontUpdatePristineNorRevert :: UpdatePristine
data MakeChanges
MakeChanges :: MakeChanges
DontMakeChanges :: MakeChanges
applyToTentativePristine :: (ApplyState q ~ Tree, Effect q, Patchy q, ShowPatch q, PrimPatchBase q) => Repository p wR wU wT -> Verbosity -> q wT wY -> IO ()

-- | <tt>makeNewPending repo YesUpdateWorking pendPs</tt> verifies that the
--   <tt>pendPs</tt> could be applied to pristine if we wanted to, and if
--   so writes it to disk. If it can't be applied, <tt>pendPs</tt> must be
--   somehow buggy, so we save it for forensics and crash.
makeNewPending :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> UpdateWorking -> FL (PrimOf p) wT wY -> IO ()

-- | hunt upwards for the darcs repository This keeps changing up one
--   parent directory, testing at each step if the current directory is a
--   repository or not. $ The result is: Nothing, if no repository found
--   Just (Left errorMessage), if bad repository found Just (Right ()), if
--   good repository found. WARNING this changes the current directory for
--   good if matchFn succeeds
seekRepo :: IO (Maybe (Either String ()))
instance Eq MakeChanges
instance Eq UpdatePristine

module Darcs.Repository.Rebase
withManualRebaseUpdate :: (RepoPatch p, ApplyState p ~ Tree) => Compression -> Verbosity -> UpdateWorking -> Repository p wR wU wT1 -> (Repository p wR wU wT1 -> IO (Repository p wR wU wT2, FL (RebaseFixup p) wT2 wT1, x)) -> IO (Repository p wR wU wT2, x)
rebaseJob :: (RepoPatch p, ApplyState p ~ Tree) => (Repository (Rebasing p) wR wU wR -> IO a) -> Repository (Rebasing p) wR wU wR -> Compression -> Verbosity -> UpdateWorking -> IO a
startRebaseJob :: (RepoPatch p, ApplyState p ~ Tree) => (Repository (Rebasing p) wR wU wR -> IO a) -> Repository (Rebasing p) wR wU wR -> Compression -> Verbosity -> UpdateWorking -> IO a
repoJobOnRebaseRepo :: (RepoPatch p, ApplyState p ~ Tree) => (Repository (Rebasing p) wR wU wR -> IO a) -> Repository (Rebasing p) wR wU wR -> IO a

module Darcs.Repository.Job

-- | A <tt>RepoJob</tt> wraps up an action to be performed with a
--   repository. Because repositories can contain different types of
--   patches, such actions typically need to be polymorphic in the kind of
--   patch they work on. <tt>RepoJob</tt> is used to wrap up the
--   polymorphism, and the various functions that act on a <tt>RepoJob</tt>
--   are responsible for instantiating the underlying action with the
--   appropriate patch type.
data RepoJob a

-- | The most common <tt>RepoJob</tt>; the underlying action can accept any
--   patch type that a darcs repository may use.
RepoJob :: (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree) => Repository p wR wU wR -> IO a) -> RepoJob a

-- | A job that only works on darcs 1 patches
V1Job :: (forall wR wU. Repository (Patch Prim) wR wU wR -> IO a) -> RepoJob a

-- | A job that only works on darcs 2 patches
V2Job :: (forall wR wU. Repository (RealPatch Prim) wR wU wR -> IO a) -> RepoJob a

-- | A job that works on any repository where the patch type <tt>p</tt> has
--   <a>PrimOf</a> <tt>p</tt> = <a>Prim</a>.
--   
--   This was added to support darcsden, which inspects the internals of V1
--   prim patches.
--   
--   In future this should be replaced with a more abstract inspection API
--   as part of <tt>PrimPatch</tt>.
PrimV1Job :: (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, PrimOf p ~ Prim) => Repository p wR wU wR -> IO a) -> RepoJob a
RebaseAwareJob :: Compression -> Verbosity -> UpdateWorking -> (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree, PrimOf (Named p) ~ PrimOf p) => Repository p wR wU wR -> IO a) -> RepoJob a
RebaseJob :: Compression -> Verbosity -> UpdateWorking -> (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree, PrimOf (Named p) ~ PrimOf p) => Repository (Rebasing p) wR wU wR -> IO a) -> RepoJob a
StartRebaseJob :: Compression -> Verbosity -> UpdateWorking -> (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree, PrimOf (Named p) ~ PrimOf p) => Repository (Rebasing p) wR wU wR -> IO a) -> RepoJob a

-- | apply a given RepoJob to a repository in the current working
--   directory, taking a lock
withRepoLock :: DryRun -> UseCache -> UpdateWorking -> UMask -> RepoJob a -> IO a

-- | apply a given RepoJob to a repository in the current working
--   directory, taking a lock. If lock not takeable, do nothing.
withRepoLockCanFail :: UseCache -> UpdateWorking -> UMask -> RepoJob () -> IO ()

-- | apply a given RepoJob to a repository in the current working directory
withRepository :: UseCache -> RepoJob a -> IO a

-- | apply a given RepoJob to a repository in a given url
withRepositoryDirectory :: UseCache -> String -> RepoJob a -> IO a

module Darcs.Repository.Test
getTest :: Verbosity -> IO (IO ExitCode)
runPosthook :: Maybe String -> Bool -> Verbosity -> AbsolutePath -> IO ExitCode
runPrehook :: Maybe String -> Bool -> Verbosity -> AbsolutePath -> IO ExitCode
testTentative :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> RunTest -> LeaveTestDir -> SetScriptsExecutable -> Verbosity -> IO ExitCode

module Darcs.Repository.Match
getNonrangeMatch :: (ApplyMonad DefaultIO (ApplyState p), RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> [MatchFlag] -> IO ()
getPartialNonrangeMatch :: (RepoPatch p, ApplyMonad DefaultIO (ApplyState p), ApplyState p ~ Tree) => Repository p wR wU wT -> [MatchFlag] -> [FileName] -> IO ()
getFirstMatch :: (ApplyMonad DefaultIO (ApplyState p), RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> [MatchFlag] -> IO ()
getOnePatchset :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> [MatchFlag] -> IO (SealedPatchSet p Origin)

module Darcs.Repository.Resolution
standardResolution :: (PrimPatchBase p, Conflict p, CommuteNoConflicts p) => FL p wX wY -> Sealed (FL (PrimOf p) wY)
externalResolution :: (RepoPatch p, ApplyState p ~ Tree) => DiffAlgorithm -> Tree IO -> String -> WantGuiPause -> FL (PrimOf p) wX wY -> FL (PrimOf p) wX wZ -> FL p wY wA -> IO (Sealed (FL (PrimOf p) wA))
patchsetConflictResolutions :: RepoPatch p => PatchSet p Origin wX -> Sealed (FL (PrimOf p) wX)

module Darcs.Repository.Merge
tentativelyMergePatches :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> String -> AllowConflicts -> UpdateWorking -> ExternalMerge -> WantGuiPause -> Compression -> Verbosity -> Reorder -> (UseIndex, ScanKnown, DiffAlgorithm) -> FL (PatchInfoAnd p) wX wT -> FL (PatchInfoAnd p) wX wY -> IO (Sealed (FL (PrimOf p) wU))
considerMergeToWorking :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> String -> AllowConflicts -> UpdateWorking -> ExternalMerge -> WantGuiPause -> Compression -> Verbosity -> Reorder -> (UseIndex, ScanKnown, DiffAlgorithm) -> FL (PatchInfoAnd p) wX wT -> FL (PatchInfoAnd p) wX wY -> IO (Sealed (FL (PrimOf p) wU))

module Darcs.Repository

-- | A <tt>Repository</tt> is a token representing the state of a
--   repository on disk. It is parameterized by the patch type in the
--   repository, and witnesses for the recorded state of the repository
--   (i.e. what darcs get would retrieve), the unrecorded state (what's in
--   the working directory now), and the tentative state, which represents
--   work in progress that will eventually become the new recorded state
--   unless something goes wrong.
data Repository (p :: * -> * -> *) wRecordedstate wUnrecordedstate wTentativestate
data HashedDir
HashedPristineDir :: HashedDir
HashedPatchesDir :: HashedDir
HashedInventoriesDir :: HashedDir

-- | Cache is an abstract type for hiding the underlying cache locations
newtype Cache
Ca :: [CacheLoc] -> Cache
data CacheLoc
Cache :: !CacheType -> !WritableOrNot -> !String -> CacheLoc
cacheType :: CacheLoc -> !CacheType
cacheWritable :: CacheLoc -> !WritableOrNot
cacheSource :: CacheLoc -> !String
data WritableOrNot
Writable :: WritableOrNot
NotWritable :: WritableOrNot

-- | A <tt>RepoJob</tt> wraps up an action to be performed with a
--   repository. Because repositories can contain different types of
--   patches, such actions typically need to be polymorphic in the kind of
--   patch they work on. <tt>RepoJob</tt> is used to wrap up the
--   polymorphism, and the various functions that act on a <tt>RepoJob</tt>
--   are responsible for instantiating the underlying action with the
--   appropriate patch type.
data RepoJob a

-- | The most common <tt>RepoJob</tt>; the underlying action can accept any
--   patch type that a darcs repository may use.
RepoJob :: (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree) => Repository p wR wU wR -> IO a) -> RepoJob a

-- | A job that only works on darcs 1 patches
V1Job :: (forall wR wU. Repository (Patch Prim) wR wU wR -> IO a) -> RepoJob a

-- | A job that only works on darcs 2 patches
V2Job :: (forall wR wU. Repository (RealPatch Prim) wR wU wR -> IO a) -> RepoJob a

-- | A job that works on any repository where the patch type <tt>p</tt> has
--   <a>PrimOf</a> <tt>p</tt> = <a>Prim</a>.
--   
--   This was added to support darcsden, which inspects the internals of V1
--   prim patches.
--   
--   In future this should be replaced with a more abstract inspection API
--   as part of <tt>PrimPatch</tt>.
PrimV1Job :: (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, PrimOf p ~ Prim) => Repository p wR wU wR -> IO a) -> RepoJob a
RebaseAwareJob :: Compression -> Verbosity -> UpdateWorking -> (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree, PrimOf (Named p) ~ PrimOf p) => Repository p wR wU wR -> IO a) -> RepoJob a
RebaseJob :: Compression -> Verbosity -> UpdateWorking -> (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree, PrimOf (Named p) ~ PrimOf p) => Repository (Rebasing p) wR wU wR -> IO a) -> RepoJob a
StartRebaseJob :: Compression -> Verbosity -> UpdateWorking -> (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree, PrimOf (Named p) ~ PrimOf p) => Repository (Rebasing p) wR wU wR -> IO a) -> RepoJob a

-- | Tries to identify the repository in a given directory
maybeIdentifyRepository :: UseCache -> String -> IO (IdentifyRepo p wR wU wT)

-- | <tt>identifyRepositoryFor repo url</tt> identifies (and returns) the
--   repo at <tt>url</tt>, but fails if it is not compatible for reading
--   from and writing to.
identifyRepositoryFor :: RepoPatch p => Repository p wR wU wT -> UseCache -> String -> IO (Repository p vR vU vT)
withRecorded :: RepoPatch p => Repository p wR wU wT -> ((AbsolutePath -> IO a) -> IO a) -> (AbsolutePath -> IO a) -> IO a

-- | apply a given RepoJob to a repository in the current working
--   directory, taking a lock
withRepoLock :: DryRun -> UseCache -> UpdateWorking -> UMask -> RepoJob a -> IO a

-- | apply a given RepoJob to a repository in the current working
--   directory, taking a lock. If lock not takeable, do nothing.
withRepoLockCanFail :: UseCache -> UpdateWorking -> UMask -> RepoJob () -> IO ()

-- | apply a given RepoJob to a repository in the current working directory
withRepository :: UseCache -> RepoJob a -> IO a

-- | apply a given RepoJob to a repository in a given url
withRepositoryDirectory :: UseCache -> String -> RepoJob a -> IO a

-- | writePatchSet is like patchSetToRepository, except that it doesn't
--   touch the working directory or pristine cache.
writePatchSet :: (RepoPatch p, ApplyState p ~ Tree) => PatchSet p Origin wX -> UseCache -> IO (Repository p wR wU wT)
findRepository :: WorkRepo -> IO (Either String ())
amInRepository :: WorkRepo -> IO (Either String ())
amNotInRepository :: WorkRepo -> IO (Either String ())
amInHashedRepository :: WorkRepo -> IO (Either String ())

-- | Replace the existing pristine with a new one (loaded up in a Tree
--   object).
replacePristine :: Repository p wR wU wT -> Tree IO -> IO ()
readRepo :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (PatchSet p Origin wR)
prefsUrl :: Repository p wR wU wT -> String
repoPatchType :: Repository p wR wU wT -> PatchType p
readRepoUsingSpecificInventory :: (RepoPatch p, ApplyState p ~ Tree) => String -> Repository p wR wU wT -> IO (PatchSet p Origin wT)

-- | Add a FL of patches starting from the working state to the pending
--   patch, including as much extra context as is necessary (context
--   meaning dependencies), by commuting the patches to be added past as
--   much of the changes between pending and working as is possible, and
--   including anything that doesn't commute, and the patch itself in the
--   new pending patch.
addToPending :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> UpdateWorking -> FL (PrimOf p) wU wY -> IO ()

-- | Add an FL of patches started from the pending state to the pending
--   patch. TODO: add witnesses for pending so we can make the types
--   precise: currently the passed patch can be applied in any context, not
--   just after pending.
addPendingDiffToPending :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> UpdateWorking -> FreeLeft (FL (PrimOf p)) -> IO ()
tentativelyAddPatch :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Compression -> Verbosity -> UpdateWorking -> PatchInfoAnd p wT wY -> IO (Repository p wR wU wY)
tentativelyRemovePatches :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Compression -> UpdateWorking -> FL (PatchInfoAnd p) wX wT -> IO (Repository p wR wU wX)

-- | <tt>tentativelyAddToPending repo NoDryRun YesUpdateWorking pend
--   ps</tt> appends <tt>ps</tt> to the pending patch.
--   
--   It has no effect with <tt>NoUpdateWorking</tt>.
--   
--   This fuction is unsafe because it accepts a patch that works on the
--   tentative pending and we don't currently track the state of the
--   tentative pending.
tentativelyAddToPending :: RepoPatch p => Repository p wR wU wT -> UpdateWorking -> FL (PrimOf p) wX wY -> IO ()

-- | Given a sequence of patches anchored at the end of the current
--   repository, actually pull them to the end of the repository by
--   removing any patches with the same name and then adding the passed in
--   sequence. Typically callers will have obtained the passed in sequence
--   using <tt>findCommon</tt> and friends.
tentativelyReplacePatches :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Compression -> UpdateWorking -> Verbosity -> FL (PatchInfoAnd p) wX wT -> IO ()
readTentativeRepo :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (PatchSet p Origin wT)
withManualRebaseUpdate :: (RepoPatch p, ApplyState p ~ Tree) => Compression -> Verbosity -> UpdateWorking -> Repository p wR wU wT1 -> (Repository p wR wU wT1 -> IO (Repository p wR wU wT2, FL (RebaseFixup p) wT2 wT1, x)) -> IO (Repository p wR wU wT2, x)
tentativelyMergePatches :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> String -> AllowConflicts -> UpdateWorking -> ExternalMerge -> WantGuiPause -> Compression -> Verbosity -> Reorder -> (UseIndex, ScanKnown, DiffAlgorithm) -> FL (PatchInfoAnd p) wX wT -> FL (PatchInfoAnd p) wX wY -> IO (Sealed (FL (PrimOf p) wU))
considerMergeToWorking :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> String -> AllowConflicts -> UpdateWorking -> ExternalMerge -> WantGuiPause -> Compression -> Verbosity -> Reorder -> (UseIndex, ScanKnown, DiffAlgorithm) -> FL (PatchInfoAnd p) wX wT -> FL (PatchInfoAnd p) wX wY -> IO (Sealed (FL (PrimOf p) wU))

-- | Slightly confusingly named: as well as throwing away any tentative
--   changes, revertRepositoryChanges also re-initialises the tentative
--   state. It's therefore used before makign any changes to the repo.
revertRepositoryChanges :: RepoPatch p => Repository p wR wU wT -> UpdateWorking -> IO ()
finalizeRepositoryChanges :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> UpdateWorking -> Compression -> IO ()
createRepository :: Bool -> WithWorkingDir -> WithPatchIndex -> IO ()
cloneRepository :: String -> String -> Verbosity -> UseCache -> CloneKind -> UMask -> RemoteDarcs -> SetScriptsExecutable -> RemoteRepos -> SetDefault -> [MatchFlag] -> RepoFormat -> WithWorkingDir -> WithPatchIndex -> Bool -> Bool -> ForgetParent -> IO ()

-- | patchSetToRepository takes a patch set, and writes a new repository in
--   the current directory that contains all the patches in the patch set.
--   This function is used when 'darcs get'ing a repository with the
--   --to-match flag.
patchSetToRepository :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR1 wU1 wR1 -> PatchSet p Origin wX -> UseCache -> RemoteDarcs -> IO ()
unrevertUrl :: Repository p wR wU wT -> String
applyToWorking :: (ApplyState (PrimOf p) ~ Tree, RepoPatch p) => Repository p wR wU wT -> Verbosity -> FL (PrimOf p) wU wY -> IO (Repository p wR wY wT)
patchSetToPatches :: RepoPatch p => PatchSet p wX wY -> FL (Named p) wX wY

-- | grab the pristine hash of _darcs/hash_inventory, and retrieve whole
--   pristine tree, possibly writing a clean working copy in the process.
createPristineDirectoryTree :: RepoPatch p => Repository p wR wU wT -> FilePath -> WithWorkingDir -> IO ()

-- | Used by the commands dist and diff
createPartialsPristineDirectoryTree :: (FilePathLike fp, RepoPatch p) => Repository p wR wU wT -> [fp] -> FilePath -> IO ()

-- | Writes out a fresh copy of the inventory that minimizes the amount of
--   inventory that need be downloaded when people pull from the
--   repository.
--   
--   Specifically, it breaks up the inventory on the most recent tag. This
--   speeds up most commands when run remotely, both because a smaller file
--   needs to be transfered (only the most recent inventory). It also gives
--   a guarantee that all the patches prior to a given tag are included in
--   that tag, so less commutation and history traversal is needed. This
--   latter issue can become very important in large repositories.
reorderInventory :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wR -> Compression -> UpdateWorking -> Verbosity -> IO ()
cleanRepository :: RepoPatch p => Repository p wR wU wT -> IO ()

-- | The patches in a repository are stored in chunks broken up at "clean"
--   tags. A tag is clean if the only patches before it in the current
--   repository ordering are ones that the tag depends on (either directly
--   or indirectly). Each chunk is stored in a separate inventory file on
--   disk.
--   
--   A <a>PatchSet</a> represents a repo's history as the list of patches
--   since the last clean tag, and then a list of patch lists each
--   delimited by clean tags.
data PatchSet p wStart wY
type SealedPatchSet p wStart = Sealed ((PatchSet p) wStart)

-- | <tt><a>PatchInfoAnd</a> p wA wB</tt> represents a hope we have to get
--   a patch through its info. We're not sure we have the patch, but we
--   know its info.
data PatchInfoAnd p wA wB
setScriptsExecutable :: IO ()
setScriptsExecutablePatches :: PatchInspect p => p wX wY -> IO ()
checkUnrelatedRepos :: RepoPatch p => Bool -> PatchSet p wStart wX -> PatchSet p wStart wY -> IO ()
testTentative :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> RunTest -> LeaveTestDir -> SetScriptsExecutable -> Verbosity -> IO ExitCode

-- | <a>modifyCache</a> <tt>repository function</tt> modifies the cache of
--   <tt>repository</tt> with <tt>function</tt>, remove duplicates and sort
--   the results with <a>compareByLocality</a>.
modifyCache :: RepoPatch p => Repository p wR wU wT -> (Cache -> Cache) -> Repository p wR wU wT

-- | Prints an error message with a list of bad caches.
reportBadSources :: IO ()

-- | Obtains a Tree corresponding to the "recorded" state of the
--   repository: this is the same as the pristine cache, which is the same
--   as the result of applying all the repository's patches to an empty
--   directory.
--   
--   Handles the plain and hashed pristine cases. Currently does not handle
--   the no-pristine case, as that requires replaying patches. Cf.
--   <a>readDarcsHashed</a> and <a>readPlainTree</a> in hashed-storage that
--   are used to do the actual <a>Tree</a> construction.
readRecorded :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (Tree IO)

-- | Obtains a Tree corresponding to the "unrecorded" state of the
--   repository: the working tree plus the "pending" patch. The optional
--   list of paths allows to restrict the query to a subtree.
--   
--   Limiting the query may be more efficient, since hashes on the
--   uninteresting parts of the index do not need to go through an
--   up-to-date check (which involves a relatively expensive lstat(2) per
--   file.
readUnrecorded :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Maybe [SubPath] -> IO (Tree IO)

-- | For a repository and an optional list of paths (when Nothing, take
--   everything) compute a (forward) list of prims (i.e. a patch) going
--   from the recorded state of the repository (pristine) to the unrecorded
--   state of the repository (the working copy + pending). When a list of
--   paths is given, at least the files that live under any of these paths
--   in either recorded or unrecorded will be included in the resulting
--   patch. NB. More patches may be included in this list, eg. the full
--   contents of the pending patch. This is usually not a problem, since
--   selectChanges will properly filter the results anyway.
--   
--   This also depends on the options given: with LookForAdds, we will
--   include any non-boring files (i.e. also those that do not exist in the
--   "recorded" state) in the working in the "unrecorded" state, and
--   therefore they will show up in the patches as addfiles.
--   
--   The IgnoreTimes option disables index usage completely -- for each
--   file, we read both the unrecorded and the recorded copy and run a diff
--   on them. This is very inefficient, although in extremely rare cases,
--   the index could go out of sync (file is modified, index is updated and
--   file is modified again within a single second).
unrecordedChanges :: (RepoPatch p, ApplyState p ~ Tree) => (UseIndex, ScanKnown, DiffAlgorithm) -> Repository p wR wU wT -> Maybe [SubPath] -> IO (FL (PrimOf p) wT wU)
unrecordedChangesWithPatches :: (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree) => (UseIndex, ScanKnown, DiffAlgorithm) -> Repository p wR wU wT -> Maybe [SubPath] -> FL (PrimOf p) wX wT -> FL (PrimOf p) wT wT -> IO (FL (PrimOf p) wT wU)

-- | Remove any patches (+dependencies) from a sequence that conflict with
--   the recorded or unrecorded changes in a repo
filterOutConflicts :: (RepoPatch p, ApplyState p ~ Tree) => RL (PatchInfoAnd p) wX wT -> Repository p wR wU wT -> FL (PatchInfoAnd p) wX wZ -> IO (Bool, Sealed (FL (PatchInfoAnd p) wX))
readPending :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (Tree IO, Sealed (FL p wT))
readRecordedAndPending :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO (Tree IO)
readIndex :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO Index

-- | Mark the existing index as invalid. This has to be called whenever the
--   listing of pristine changes and will cause darcs to update the index
--   next time it tries to read it. (NB. This is about files added and
--   removed from pristine: changes to file content in either pristine or
--   working are handled transparently by the index reading code.)
invalidateIndex :: t -> IO ()

-- | Get a list of all files and directories in the working copy, including
--   boring files if necessary
listFiles :: Bool -> IO [String]

-- | <a>listRegisteredFiles</a> returns the list of all registered files in
--   the repository.
listRegisteredFiles :: IO [String]

-- | <a>listUnregisteredFiles</a> returns the list of all non-boring
--   unregistered files in the repository.
listUnregisteredFiles :: Bool -> IO [String]

module Darcs.Repository.Repair
replayRepository :: (RepoPatch p, ApplyState p ~ Tree) => DiffAlgorithm -> Repository p wR wU wT -> Compression -> Verbosity -> (RepositoryConsistency p wR -> IO a) -> IO a
checkIndex :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Bool -> IO Bool
replayRepositoryInTemp :: (RepoPatch p, ApplyState p ~ Tree) => DiffAlgorithm -> Repository p wR wU wT -> Compression -> Verbosity -> IO (RepositoryConsistency p wR)
data RepositoryConsistency p wX
RepositoryConsistent :: RepositoryConsistency p wX
BrokenPristine :: (Tree IO) -> RepositoryConsistency p wX
BrokenPatches :: (Tree IO) -> (PatchSet p Origin wX) -> RepositoryConsistency p wX

module Darcs.Repository.Util

-- | Search for possible replaces between the recordedAndPending state and
--   the unrecorded (or working) state. Return a Sealed FL list of replace
--   patches to be applied to the recordedAndPending state.
getReplaces :: (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree, wX ~ wR) => (UseIndex, ScanKnown, DiffAlgorithm) -> Repository p wR wU wT -> Maybe [SubPath] -> IO (Sealed (FL (PrimOf p) wX))

-- | Transform a SubPath into an AnchoredPath.
floatSubPath :: SubPath -> AnchoredPath
maybeApplyToTree :: (Apply p, ApplyState p ~ Tree) => p wX wY -> Tree IO -> IO (Maybe (Tree IO))
defaultToks :: String
getMovesPs :: (PrimConstruct prim, PrimCanonize prim, RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree) => Repository p wR wU wR -> Maybe [SubPath] -> IO (FL prim wB wB)
patchSetfMap :: (forall wW wZ. PatchInfoAnd p wW wZ -> IO a) -> PatchSet p wW' wZ' -> IO [a]

-- | getRecursiveDarcsRepos returns all paths to repositories under topdir.
getRecursiveDarcsRepos :: FilePath -> IO [FilePath]

module Darcs.UI.Commands.Util
announceFiles :: Maybe [SubPath] -> String -> IO ()
filterExistingFiles :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> LookForAdds -> [SubPath] -> IO [SubPath]
testTentativeAndMaybeExit :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> Verbosity -> TestChanges -> SetScriptsExecutable -> Bool -> String -> String -> Maybe String -> IO ()
getUniqueRepositoryName :: Bool -> FilePath -> IO FilePath
getUniqueDPatchName :: FilePath -> IO FilePath

module Darcs.UI.PrintPatch

-- | <a>printPatch</a> prints a patch on standard output.
printPatch :: ShowPatch p => p wX wY -> IO ()

-- | <a>contextualPrintPatch</a> prints a patch, together with its context,
--   on standard output.
contextualPrintPatch :: (ShowPatch p, ApplyState p ~ Tree) => Tree IO -> p wX wY -> IO ()

-- | <a>printPatchPager</a> runs '$PAGER' and shows a patch in it.
printPatchPager :: ShowPatch p => p wX wY -> IO ()

-- | <tt><a>printFriendly</a> opts patch</tt> prints <tt>patch</tt> in
--   accordance with the flags in opts, ie, whether <tt>--verbose</tt> or
--   <tt>--summary</tt> were passed at the command-line.
printFriendly :: (ShowPatch p, ApplyState p ~ Tree) => Maybe (Tree IO) -> Verbosity -> Summary -> WithContext -> p wX wY -> IO ()

-- | <tt><a>showFriendly</a> flags patch</tt> returns a <a>Doc</a>
--   representing the right way to show <tt>patch</tt> given the list
--   <tt>flags</tt> of flags darcs was invoked with.
showFriendly :: ShowPatch p => Verbosity -> Summary -> p wX wY -> Doc

module Darcs.UI.Commands
data CommandControl
CommandData :: WrappedCommand -> CommandControl
HiddenCommand :: WrappedCommand -> CommandControl
GroupName :: String -> CommandControl

-- | A <a>DarcsCommand</a> represents a command like add, record etc. The
--   <tt>parsedFlags</tt> type represents the options that are passed to
--   the command's implementation
data DarcsCommand parsedFlags
DarcsCommand :: String -> String -> String -> String -> Int -> [String] -> ((AbsolutePath, AbsolutePath) -> parsedFlags -> [String] -> IO ()) -> ([DarcsFlag] -> IO (Either String ())) -> IO [String] -> ([DarcsFlag] -> AbsolutePath -> [String] -> IO [String]) -> [DarcsOptDescr DarcsFlag] -> [DarcsOptDescr DarcsFlag] -> [DarcsFlag] -> ([DarcsFlag] -> [String]) -> ([DarcsFlag] -> parsedFlags) -> DarcsCommand parsedFlags
commandProgramName :: DarcsCommand parsedFlags -> String
commandName :: DarcsCommand parsedFlags -> String
commandHelp :: DarcsCommand parsedFlags -> String
commandDescription :: DarcsCommand parsedFlags -> String
commandExtraArgs :: DarcsCommand parsedFlags -> Int
commandExtraArgHelp :: DarcsCommand parsedFlags -> [String]
commandCommand :: DarcsCommand parsedFlags -> (AbsolutePath, AbsolutePath) -> parsedFlags -> [String] -> IO ()
commandPrereq :: DarcsCommand parsedFlags -> [DarcsFlag] -> IO (Either String ())
commandGetArgPossibilities :: DarcsCommand parsedFlags -> IO [String]
commandArgdefaults :: DarcsCommand parsedFlags -> [DarcsFlag] -> AbsolutePath -> [String] -> IO [String]
commandBasicOptions :: DarcsCommand parsedFlags -> [DarcsOptDescr DarcsFlag]
commandAdvancedOptions :: DarcsCommand parsedFlags -> [DarcsOptDescr DarcsFlag]
commandDefaults :: DarcsCommand parsedFlags -> [DarcsFlag]
commandCheckOptions :: DarcsCommand parsedFlags -> [DarcsFlag] -> [String]
commandParseOptions :: DarcsCommand parsedFlags -> [DarcsFlag] -> parsedFlags
SuperCommand :: String -> String -> String -> String -> ([DarcsFlag] -> IO (Either String ())) -> [CommandControl] -> DarcsCommand parsedFlags
commandProgramName :: DarcsCommand parsedFlags -> String
commandName :: DarcsCommand parsedFlags -> String
commandHelp :: DarcsCommand parsedFlags -> String
commandDescription :: DarcsCommand parsedFlags -> String
commandPrereq :: DarcsCommand parsedFlags -> [DarcsFlag] -> IO (Either String ())
commandSubCommands :: DarcsCommand parsedFlags -> [CommandControl]

-- | A <a>WrappedCommand</a> is a <a>DarcsCommand</a> where the options
--   type has been hidden
data WrappedCommand
WrappedCommand :: DarcsCommand parsedFlags -> WrappedCommand
wrappedCommandName :: WrappedCommand -> String
commandAlias :: String -> Maybe (DarcsCommand pf) -> DarcsCommand pf -> DarcsCommand pf
commandStub :: String -> String -> String -> DarcsCommand pf -> DarcsCommand pf
commandOptions :: AbsolutePath -> DarcsCommand pf -> [OptDescr DarcsFlag]
commandAlloptions :: DarcsCommand pf -> ([DarcsOptDescr DarcsFlag], [DarcsOptDescr DarcsFlag])
withStdOpts :: DarcsOption (Maybe StdCmdAction -> Bool -> Bool -> Verbosity -> Bool -> b) c -> DarcsOption (UseCache -> Maybe String -> Bool -> Maybe String -> Bool -> a) b -> DarcsOption a c
disambiguateCommands :: [CommandControl] -> String -> [String] -> Either String (CommandArgs, [String])
data CommandArgs
CommandOnly :: DarcsCommand parsedFlags -> CommandArgs
SuperCommandOnly :: DarcsCommand parsedFlags -> CommandArgs
SuperCommandSub :: DarcsCommand parsedFlags1 -> DarcsCommand parsedFlags2 -> CommandArgs
getCommandHelp :: Maybe (DarcsCommand pf1) -> DarcsCommand pf2 -> String
getCommandMiniHelp :: Maybe (DarcsCommand pf1) -> DarcsCommand pf2 -> String
getSubcommands :: DarcsCommand pf -> [CommandControl]
usage :: [CommandControl] -> String
usageHelper :: [CommandControl] -> String
subusage :: DarcsCommand pf -> String
extractCommands :: [CommandControl] -> [WrappedCommand]
extractAllCommands :: [CommandControl] -> [WrappedCommand]
normalCommand :: DarcsCommand parsedFlags -> CommandControl
hiddenCommand :: DarcsCommand parsedFlags -> CommandControl
commandGroup :: String -> CommandControl
superName :: Maybe (DarcsCommand pf) -> String
nodefaults :: [DarcsFlag] -> AbsolutePath -> [String] -> IO [String]
putInfo :: [DarcsFlag] -> Doc -> IO ()
putVerbose :: [DarcsFlag] -> Doc -> IO ()
putWarning :: [DarcsFlag] -> Doc -> IO ()
putVerboseWarning :: [DarcsFlag] -> Doc -> IO ()
abortRun :: [DarcsFlag] -> Doc -> IO ()

-- | <tt><a>printDryRunMessageAndExit</a> action flags patches</tt> prints
--   a string representing the action that would be taken if the
--   <tt>--dry-run</tt> option had not been passed to darcs. Then darcs
--   exits successfully. <tt>action</tt> is the name of the action being
--   taken, like <tt>"push"</tt> <tt>flags</tt> is the list of flags which
--   were sent to darcs <tt>patches</tt> is the sequence of patches which
--   would be touched by <tt>action</tt>.
printDryRunMessageAndExit :: (RepoPatch p, ApplyState p ~ Tree) => String -> Verbosity -> Summary -> DryRun -> XmlOutput -> Bool -> FL (PatchInfoAnd p) wX wY -> IO ()

-- | Set the DARCS_PATCHES and DARCS_PATCHES_XML environment variables with
--   info about the given patches, for use in post-hooks.
setEnvDarcsPatches :: (RepoPatch p, ApplyState p ~ Tree) => FL (PatchInfoAnd p) wX wY -> IO ()

-- | Set the DARCS_FILES environment variable to the files touched by the
--   given patch, one per line, for use in post-hooks.
setEnvDarcsFiles :: (PatchInspect p, Patchy p) => p wX wY -> IO ()

-- | Format a path for screen output, so that the user sees where the path
--   begins and ends. Could (should?) also warn about unprintable
--   characters here.
formatPath :: String -> String
defaultRepo :: [DarcsFlag] -> AbsolutePath -> [String] -> IO [String]
amInHashedRepository :: [DarcsFlag] -> IO (Either String ())
amInRepository :: [DarcsFlag] -> IO (Either String ())
amNotInRepository :: [DarcsFlag] -> IO (Either String ())
findRepository :: [DarcsFlag] -> IO (Either String ())

module Darcs.UI.ApplyPatches

-- | This class is a hack to abstract over pull<i>apply and rebase
--   pull</i>apply.
class PatchApplier pa where type family CarrierType pa (p :: * -> * -> *) :: * -> * -> *
repoJob :: PatchApplier pa => pa -> [DarcsFlag] -> (forall p wR wU. (RepoPatch p, ApplyState p ~ Tree, ApplyState (PrimOf p) ~ Tree, RepoPatch (CarrierType pa p), ApplyState (CarrierType pa p) ~ Tree, ApplyState (PrimOf (CarrierType pa p)) ~ Tree) => (PatchProxy p -> Repository (CarrierType pa p) wR wU wR -> IO ())) -> RepoJob ()
applyPatches :: (PatchApplier pa, RepoPatch p, ApplyState (PrimOf p) ~ Tree, ApplyState p ~ Tree) => pa -> PatchProxy p -> String -> [DarcsFlag] -> String -> Repository (CarrierType pa p) wR wU wT -> FL (PatchInfoAnd (CarrierType pa p)) wX wT -> FL (PatchInfoAnd (CarrierType pa p)) wX wZ -> IO ()
data PatchProxy (p :: * -> * -> *)
PatchProxy :: PatchProxy
data StandardPatchApplier
StandardPatchApplier :: StandardPatchApplier
instance PatchApplier StandardPatchApplier

module Darcs.UI.Commands.Clone
get :: DarcsCommand [DarcsFlag]
put :: DarcsCommand [DarcsFlag]
clone :: DarcsCommand [DarcsFlag]
makeRepoName :: Bool -> [DarcsFlag] -> FilePath -> IO String
cloneToSSH :: [DarcsFlag] -> Maybe String


module Darcs.UI.Commands.Dist
dist :: DarcsCommand [DarcsFlag]
doFastZip :: [DarcsFlag] -> IO ()
doFastZip' :: [DarcsFlag] -> FilePath -> (ByteString -> IO a) -> IO a

module Darcs.UI.Commands.Init
initialize :: DarcsCommand [DarcsFlag]
initializeCmd :: (AbsolutePath, AbsolutePath) -> [DarcsFlag] -> [String] -> IO ()


-- | Help text and UI messages for <tt>darcs send</tt>
module Darcs.UI.Message.Send
cmdDescription :: String
cmdHelp :: String
cannotSendToSelf :: String
creatingPatch :: String -> Doc
noWorkingSendmail :: Doc
nothingSendable :: Doc
selectionIs :: [Doc] -> Doc
selectionIsNull :: Doc
emailBackedUp :: String -> Doc
promptCharSetWarning :: String -> String
charsetAborted :: Doc
charsetCouldNotGuess :: String
currentEncodingIs :: String -> String
charsetUtf8MailDiffLocale :: String
aborted :: Doc
success :: String -> String -> Doc
postingPatch :: String -> Doc
wroteBundle :: FilePathLike a => a -> Doc
savedButNotSent :: String -> Doc
willSendTo :: DryRun -> [String] -> Doc
promptTarget :: String
aboutToEdit :: FilePath -> String
promptNoDescriptionChange :: String

module Darcs.UI.Commands.ShowAuthors
showAuthors :: DarcsCommand [DarcsFlag]
data Spelling
compiledAuthorSpellings :: [DarcsFlag] -> IO [Spelling]
canonizeAuthor :: [Spelling] -> String -> String
rankAuthors :: [Spelling] -> [String] -> [String]

module Darcs.UI.Commands.ShowBug
showBug :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.ShowContents
showContents :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.ShowIndex
showIndex :: DarcsCommand [DarcsFlag]
showPristineCmd :: (AbsolutePath, AbsolutePath) -> [DarcsFlag] -> [String] -> IO ()

module Darcs.UI.Commands.ShowPatchIndex
showPatchIndexFiles :: DarcsCommand [DarcsFlag]
showPatchIndexAll :: DarcsCommand [DarcsFlag]
showPatchIndexStatus :: DarcsCommand [DarcsFlag]
patchIndexTest :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.TransferMode
transferMode :: DarcsCommand [DarcsFlag]


module Darcs.UI.Commands.Add
add :: DarcsCommand [DarcsFlag]
expandDirs :: Bool -> [SubPath] -> IO [SubPath]

module Darcs.UI.SelectChanges

-- | Select patches from a <tt>FL</tt>.
selectChanges :: (Patchy p, PatchInspect p, ShowPatch p, ApplyState p ~ Tree) => FL p wX wY -> PatchSelection p wX wY

-- | When asking about patches, we either ask about them in oldest-first or
--   newest first (with respect to the current ordering of the repository),
--   and we either want an initial segment or a final segment of the poset
--   of patches.
--   
--   <tt>First</tt>: ask for an initial segment, first patches first
--   (default for all pull-like commands)
--   
--   <tt>FirstReversed</tt>: ask for an initial segment, last patches first
--   (used to ask about dependencies in record, and for pull-like commands
--   with the <tt>--reverse</tt> flag).
--   
--   <tt>LastReversed</tt>: ask for a final segment, last patches first.
--   (default for unpull-like commands, except for selecting *primitive*
--   patches in rollback)
--   
--   <tt>Last</tt>: ask for a final segment, first patches first. (used for
--   selecting primitive patches in rollback, and for unpull-like commands
--   with the <tt>--reverse</tt> flag
data WhichChanges
Last :: WhichChanges
LastReversed :: WhichChanges
First :: WhichChanges
FirstReversed :: WhichChanges

-- | The equivalent of <a>selectChanges</a> for the <tt>darcs changes</tt>
--   command
viewChanges :: (Patchy p, ShowPatch p, ApplyState p ~ Tree) => PatchSelectionOptions -> [Sealed2 p] -> IO ()

-- | The function for selecting a patch to amend record. Read at your own
--   risks.
withSelectedPatchFromRepo :: (RepoPatch p, ApplyState p ~ Tree) => String -> Repository p wR wU wT -> PatchSelectionOptions -> (forall wA. (FL (PatchInfoAnd p) :> PatchInfoAnd p) wA wR -> IO ()) -> IO ()

-- | runs a <a>PatchSelection</a> action in the given
--   <a>PatchSelectionContext</a>.
runSelection :: Patchy p => PatchSelection p wX wY -> PatchSelectionContext p -> IO ((FL p :> FL p) wX wY)

-- | A <a>PatchSelectionContext</a> for selecting <tt>Prim</tt> patches.
selectionContextPrim :: PrimPatch prim => WhichChanges -> String -> PatchSelectionOptions -> Maybe (Splitter prim) -> Maybe [FilePath] -> Maybe (Tree IO) -> PatchSelectionContext prim

-- | A generic <a>PatchSelectionContext</a>.
selectionContextGeneric :: (RepoPatch p, Invert q) => (forall wX wY. q wX wY -> Sealed2 (Named p)) -> WhichChanges -> String -> PatchSelectionOptions -> Maybe [FilePath] -> PatchSelectionContext q

-- | A <a>PatchSelectionContext</a> for selecting full patches
--   (<a>PatchInfoAnd</a> patches)
selectionContext :: RepoPatch p => WhichChanges -> String -> PatchSelectionOptions -> Maybe (Splitter (PatchInfoAnd p)) -> Maybe [FilePath] -> PatchSelectionContext (PatchInfoAnd p)

-- | A <tt>PatchSelectionContext</tt> contains all the static settings for
--   selecting patches. See <a>PatchSelectionM</a>
data PatchSelectionContext p
printSummary :: ShowPatch p => p wX wY -> IO ()
data PatchSelectionOptions
PatchSelectionOptions :: Verbosity -> [MatchFlag] -> DiffAlgorithm -> Bool -> SelectDeps -> Summary -> WithContext -> PatchSelectionOptions
verbosity :: PatchSelectionOptions -> Verbosity
matchFlags :: PatchSelectionOptions -> [MatchFlag]
diffAlgorithm :: PatchSelectionOptions -> DiffAlgorithm
interactive :: PatchSelectionOptions -> Bool
selectDeps :: PatchSelectionOptions -> SelectDeps
summary :: PatchSelectionOptions -> Summary
withContext :: PatchSelectionOptions -> WithContext
type InteractiveSelectionM p wX wY a = StateT (InteractiveSelectionContext p wX wY) (PatchSelectionM p IO) a

-- | The dynamic parameters for interactive selection of patches.
data InteractiveSelectionContext p wX wY
ISC :: Int -> Int -> FZipper (LabelledPatch p) wX wY -> PatchChoices p wX wY -> InteractiveSelectionContext p wX wY

-- | total number of patches
total :: InteractiveSelectionContext p wX wY -> Int

-- | number of already-seen patches
current :: InteractiveSelectionContext p wX wY -> Int

-- | the patches we offer
lps :: InteractiveSelectionContext p wX wY -> FZipper (LabelledPatch p) wX wY

-- | the user's choices
choices :: InteractiveSelectionContext p wX wY -> PatchChoices p wX wY

-- | Returns a <tt>Sealed2</tt> version of the patch we are asking the user
--   about.
currentPatch :: Patchy p => InteractiveSelectionM p wX wY (Maybe (Sealed2 (LabelledPatch p)))

-- | Skips patches we should not ask the user about
skipMundane :: (Patchy p, ShowPatch p) => InteractiveSelectionM p wX wY ()

-- | Focus the next patch.
skipOne :: Patchy p => InteractiveSelectionM p wX wY ()

-- | Focus the previous patch.
backOne :: Patchy p => InteractiveSelectionM p wX wY ()
backAll :: Patchy p => InteractiveSelectionM p wX wY ()

-- | Shows the current patch as it should be seen by the user.
showCur :: (Patchy p, ShowPatch p, ApplyState p ~ Tree) => InteractiveSelectionM p wX wY ()

-- | <tt>decide True</tt> selects the current patch, and <tt>decide
--   False</tt> deselects it.
decide :: Patchy p => Bool -> LabelledPatch p wT wU -> InteractiveSelectionM p wX wY ()

-- | like <a>decide</a>, but for all patches touching <tt>file</tt>
decideWholeFile :: (Patchy p, PatchInspect p) => FilePath -> Bool -> InteractiveSelectionM p wX wY ()
isSingleFile :: PatchInspect p => p wX wY -> Bool

-- | returns <tt>Just f</tt> if the <a>currentPatch</a> only modifies
--   <tt>f</tt>, <tt>Nothing</tt> otherwise.
currentFile :: (Patchy p, PatchInspect p) => InteractiveSelectionM p wX wY (Maybe FilePath)

-- | Asks the user about one patch, returns their answer.
promptUser :: (Patchy p, ShowPatch p) => Bool -> Char -> InteractiveSelectionM p wX wY Char

-- | The question to ask about one patch.
prompt :: (Patchy p, ShowPatch p) => InteractiveSelectionM p wX wY String

-- | The type of the answers to a "shall I [wiggle] that [foo]?" question
--   They are found in a [[KeyPress]] bunch, each list representing a set
--   of answers which belong together
data KeyPress
KeyPress :: Char -> String -> KeyPress
kp :: KeyPress -> Char
kpHelp :: KeyPress -> String

-- | The keys used by a list of <tt>keyPress</tt> groups.
keysFor :: [[KeyPress]] -> [Char]

-- | Generates the help for a set of basic and advanced <a>KeyPress</a>
--   groups.
helpFor :: String -> [[KeyPress]] -> [[KeyPress]] -> String
askAboutDepends :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> FL (PrimOf p) wT wY -> PatchSelectionOptions -> [PatchInfo] -> IO [PatchInfo]
instance Eq WhichChanges
instance Show WhichChanges

module Darcs.UI.Commands.Record
record :: DarcsCommand RecordConfig
commit :: DarcsCommand RecordConfig

-- | Get the patch name and long description from one of
--   
--   <ul>
--   <li>the configuration (flags, defaults, hard-coded)</li>
--   <li>an existing log file</li>
--   <li>stdin (e.g. a pipe)</li>
--   <li>a text editor</li>
--   </ul>
--   
--   It ensures the patch name is not empty nor starts with the prefix TAG.
--   
--   The last result component is a possible path to a temporary file that
--   should be removed later.
getLog :: (Patchy prim, PrimPatch prim) => Maybe String -> Bool -> Logfile -> Maybe AskLongComment -> Maybe (String, [String]) -> FL prim wX wY -> IO (String, [String], Maybe String)
recordConfig :: [DarcsFlag] -> RecordConfig
data RecordConfig
RecordConfig :: Maybe String -> Maybe String -> TestChanges -> Maybe Bool -> Bool -> Bool -> Maybe AskLongComment -> LookFor -> Maybe String -> WithContext -> DiffAlgorithm -> Verbosity -> Logfile -> Compression -> UseIndex -> UMask -> SetScriptsExecutable -> UseCache -> RecordConfig
patchname :: RecordConfig -> Maybe String
author :: RecordConfig -> Maybe String
testChanges :: RecordConfig -> TestChanges
interactive :: RecordConfig -> Maybe Bool
pipe :: RecordConfig -> Bool
askDeps :: RecordConfig -> Bool
askLongComment :: RecordConfig -> Maybe AskLongComment
lookfor :: RecordConfig -> LookFor
_workingRepoDir :: RecordConfig -> Maybe String
withContext :: RecordConfig -> WithContext
diffAlgorithm :: RecordConfig -> DiffAlgorithm
verbosity :: RecordConfig -> Verbosity
logfile :: RecordConfig -> Logfile
compress :: RecordConfig -> Compression
useIndex :: RecordConfig -> UseIndex
umask :: RecordConfig -> UMask
sse :: RecordConfig -> SetScriptsExecutable
useCache :: RecordConfig -> UseCache


module Darcs.UI.Commands.Amend
amend :: DarcsCommand AmendConfig
amendrecord :: DarcsCommand AmendConfig
updatePatchHeader :: (RepoPatch p, ApplyState p ~ Tree) => Bool -> PatchSelectionOptions -> Bool -> Bool -> Maybe String -> Maybe String -> Maybe AskLongComment -> Repository p wR wU wT -> PatchInfoAnd p wT wX -> FL (PrimOf p) wX wY -> IO (Maybe String, PatchInfoAnd p wT wY)

module Darcs.UI.Commands.Annotate
annotate :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.Apply
apply :: DarcsCommand [DarcsFlag]
applyCmd :: PatchApplier pa => pa -> (AbsolutePath, AbsolutePath) -> [DarcsFlag] -> [String] -> IO ()
getPatchBundle :: RepoPatch p => [DarcsFlag] -> ByteString -> IO (Either String (SealedPatchSet p Origin))

module Darcs.UI.Commands.Convert
convert :: DarcsCommand [DarcsFlag]
instance Show RefId
instance Show Object
instance Show State

module Darcs.UI.Commands.Diff
diffCommand :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.GZCRCs
gzcrcs :: DarcsCommand [DarcsFlag]

-- | This is designed for use in an atexit handler, e.g. in
--   Darcs.RunCommand
doCRCWarnings :: Bool -> IO ()

module Darcs.UI.Commands.Log

-- | changes is an alias for log
changes :: DarcsCommand [DarcsFlag]
log :: DarcsCommand [DarcsFlag]
changelog :: (Apply p, ApplyState p ~ Tree, ShowPatch p, IsHunk p, PrimPatchBase p, PatchListFormat p, Conflict p, CommuteNoConflicts p) => [DarcsFlag] -> PatchSet p wStart wX -> ([(Sealed2 (PatchInfoAnd p), [FilePath])], [(FilePath, FilePath)], Maybe Doc) -> Doc
getLogInfo :: (Matchable p, ApplyState p ~ Tree) => Maybe Int -> [MatchFlag] -> Bool -> Maybe [FilePath] -> PatchFilter p -> PatchSet p wX wY -> IO ([(Sealed2 (PatchInfoAnd p), [FilePath])], [(FilePath, FilePath)], Maybe Doc)

module Darcs.UI.Commands.MarkConflicts
markconflicts :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.Move
move :: DarcsCommand [DarcsFlag]
mv :: DarcsCommand [DarcsFlag]
instance Show FileKind
instance Eq FileKind
instance Show FileStatus

module Darcs.UI.Commands.Optimize
optimize :: DarcsCommand [DarcsFlag]
doOptimizeHTTP :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> IO ()

module Darcs.UI.Commands.Pull
pull :: DarcsCommand [DarcsFlag]
fetch :: DarcsCommand [DarcsFlag]
pullCmd :: PatchApplier pa => pa -> (AbsolutePath, AbsolutePath) -> [DarcsFlag] -> [String] -> IO ()
data StandardPatchApplier
fetchPatches :: (RepoPatch p, ApplyState p ~ Tree) => AbsolutePath -> [DarcsFlag] -> [String] -> String -> Repository p wR wU wR -> IO (SealedPatchSet p Origin, Sealed ((FL (PatchInfoAnd p) :\/: FL (PatchInfoAnd p)) wR))
revertable :: IO a -> IO a

module Darcs.UI.Commands.Push
push :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.Unrecord
unrecord :: DarcsCommand [DarcsFlag]
unpull :: DarcsCommand [DarcsFlag]
obliterate :: DarcsCommand [DarcsFlag]
getLastPatches :: RepoPatch p => [MatchFlag] -> PatchSet p Origin wR -> (PatchSet p :> FL (PatchInfoAnd p)) Origin wR

-- | matchingHead returns the repository up to some tag. The tag t is the
--   last tag such that there is a patch after t that is matched by the
--   user's query.
matchingHead :: RepoPatch p => [MatchFlag] -> PatchSet p Origin wR -> (PatchSet p :> FL (PatchInfoAnd p)) Origin wR

module Darcs.UI.Commands.Rebase
rebase :: DarcsCommand [DarcsFlag]
instance PatchApplier RebasePatchApplier

module Darcs.UI.Commands.Remove
remove :: DarcsCommand [DarcsFlag]
rm :: DarcsCommand [DarcsFlag]
unadd :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.Repair
repair :: DarcsCommand [DarcsFlag]

-- | check is an alias for repair, with implicit DryRun flag.
check :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.Replace
replace :: DarcsCommand [DarcsFlag]
defaultToks :: String

module Darcs.UI.Commands.Unrevert
unrevert :: DarcsCommand [DarcsFlag]
writeUnrevert :: (RepoPatch p, ApplyState p ~ Tree) => Repository p wR wU wT -> FL (PrimOf p) wX wY -> Tree IO -> FL (PrimOf p) wR wX -> IO ()

module Darcs.UI.Commands.Revert
revert :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.Rollback
rollback :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.SetPref
setpref :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.ShowFiles
showFiles :: DarcsCommand [DarcsFlag]
manifestCmd :: ([DarcsFlag] -> Tree IO -> [FilePath]) -> (AbsolutePath, AbsolutePath) -> [DarcsFlag] -> [String] -> IO ()
toListManifest :: [DarcsFlag] -> Tree m -> [FilePath]
manifest :: [DarcsFlag] -> [String] -> IO [FilePath]

module Darcs.UI.Commands.ShowRepo
showRepo :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.Tag
tag :: DarcsCommand [DarcsFlag]
getTags :: MaybeInternal p => PatchSet p wW wR -> IO [String]

module Darcs.UI.Commands.ShowTags
showTags :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.Show
showCommand :: DarcsCommand [DarcsFlag]
list :: DarcsCommand [DarcsFlag]
query :: DarcsCommand [DarcsFlag]

module Darcs.UI.Commands.Test
test :: DarcsCommand [DarcsFlag]
instance Show BisectDir

module Darcs.UI.Commands.WhatsNew
whatsnew :: DarcsCommand [DarcsFlag]

-- | status is an alias for whatsnew, with implicit Summary and LookForAdds
--   flags. We override the default description, to include the implicit
--   flags.
status :: DarcsCommand [DarcsFlag]

module Darcs.Util.Download.HTTP
fetchUrl :: String -> IO String
postUrl :: String -> String -> String -> IO ()
requestUrl :: String -> FilePath -> a -> IO String
waitNextUrl :: IO (String, String, Maybe ConnectionError)

module Darcs.UI.Commands.Send
send :: DarcsCommand [DarcsFlag]

module Darcs.UI.TheCommands

-- | The commands that darcs knows about (e.g. whatsnew, record), organized
--   into thematic groups. Note that hidden commands are also listed here.
commandControlList :: [CommandControl]

module Darcs.UI.Commands.Help
helpCmd :: (AbsolutePath, AbsolutePath) -> [DarcsFlag] -> [String] -> IO ()
commandControlList :: [CommandControl]

-- | Help on each environment variable in which Darcs is interested.
environmentHelp :: [([String], [String])]
printVersion :: IO ()
listAvailableCommands :: IO ()

module Darcs.UI.Defaults

-- | Apply defaults from all sources to a list of <a>DarcsFlag</a>s (e.g.
--   from the command line), given the command (and possibly super command)
--   name, and a list of all options for the command.
--   
--   Sources for defaults are
--   
--   <ul>
--   <li>the builtin (hard-coded) defaults,</li>
--   <li>the defaults file in the user's configuration, and</li>
--   <li>the defaults file in the current repository.</li>
--   </ul>
--   
--   Note that the pseudo command <tt>ALL</tt> is allowed in defaults files
--   to specify that an option should be the default for all commands to
--   which it applies.
--   
--   The order of precedence for conflicting options (i.e. those belonging
--   to same group of mutually exclusive options) is from less specific to
--   more specific. In other words, options from the command line override
--   all defaults, per-repo defaults override per-user defaults, which in
--   turn override the built-in defaults. Inside the options from a
--   defaults file, options for the given command override options for the
--   <tt>ALL</tt> pseudo command.
--   
--   Conflicting options at the same level of precedence are not allowed.
--   
--   Errors encountered during processing of command line or defaults flags
--   are formatted and added as (separate) strings to the list of error
--   messages that are returned together with the resulting flag list.
applyDefaults :: Maybe String -> DarcsCommand pf -> AbsolutePath -> [String] -> [String] -> [DarcsFlag] -> ([DarcsFlag], [String])


-- | This is the actual heavy lifter code, which is responsible for parsing
--   the arguments and then running the command itself.
module Darcs.UI.RunCommand
runTheCommand :: [CommandControl] -> String -> [String] -> IO ()
