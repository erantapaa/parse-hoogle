-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The most complete prelude formed from only the "base" package
--   
@package base-prelude
@version 0.1.19


-- | This module reexports most of the definitions from the "base" package,
--   which are meant to be imported unqualified.
--   
--   For details check out the source.
module BasePrelude

-- | Case analysis for the <a>Bool</a> type. <tt>bool a b p</tt> evaluates
--   to <tt>a</tt> when <tt>p</tt> is <tt>False</tt>, and evaluates to
--   <tt>b</tt> when <tt>p</tt> is <tt>True</tt>.
bool :: a -> a -> Bool -> a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
(&) :: a -> (a -> b) -> b

-- | Flipped version of <a>&lt;$</a>.
($>) :: Functor f => f a -> b -> f b

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if the first list is a subsequence of the second list.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy . comparing
--   f</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | Decompose a list into its head and tail. If the list is empty, returns
--   <a>Nothing</a>. If the list is non-empty, returns <tt><a>Just</a> (x,
--   xs)</tt>, where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.
uncons :: [a] -> Maybe (a, [a])

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
traceShowId :: Show a => a -> a

-- | Like <a>trace</a> but returning unit in an arbitrary monad. Allows for
--   convenient use in do-notation. Note that the application of
--   <a>trace</a> is not an action in the monad, as <a>traceIO</a> is in
--   the <a>IO</a> monad.
--   
--   <pre>
--   ... = do
--     x &lt;- ...
--     traceM $ "x: " ++ show x
--     y &lt;- ...
--     traceM $ "y: " ++ show y
--   </pre>
traceM :: Monad m => String -> m ()

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   ... = do
--     x &lt;- ...
--     traceShowM $ x
--     y &lt;- ...
--     traceShowM $ x + y
--   </pre>
traceShowM :: (Show a, Monad m) => a -> m ()
