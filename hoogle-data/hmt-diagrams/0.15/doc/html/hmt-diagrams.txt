-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell Music Theory Diagrams
--   
@package hmt-diagrams
@version 0.15


-- | Sequencer type diagram.
module Music.Theory.Diagram.Sequencer

-- | Point
type P2 = (R, R)

-- | Greyscale colour.
type Grey = R

-- | Coloured rectangle as (lower-left,upper-right,greyscale).
type C_Rect = (P2, P2, Grey)

-- | <a>C_Rect</a> with identifier.
type K_Rect = (Int, C_Rect)

-- | Gnuplot string for <a>K_Rect</a>.
k_rect_gnuplot :: K_Rect -> String

-- | Sequencer plot options, (image-size,x-range,y-range). For standard
--   midi data x-range is the time window and y-range is the gamut.
type Seq_Plot_Opt = ((Int, Int), (R, R), (R, R))

-- | Sane defaults for size and gamut.
default_seq_plot_opt :: (R, R) -> Seq_Plot_Opt

-- | Add identifiers.
to_k_rect :: [C_Rect] -> [K_Rect]

-- | Names for SVG terminal have character restrictions.
clean_name :: String -> String
sequencer_plot_rect :: Seq_Plot_Opt -> FilePath -> String -> [C_Rect] -> IO ()

-- | Linear amplitude to grey scale (0 = white, 1 = black).
--   
--   <pre>
--   map (floor . (* 255) . amp_to_grey (-60)) [0,0.25,0.5,0.75,1] == [255,51,25,10,0]
--   </pre>
amp_to_grey :: R -> R -> R

-- | Midi velocity number to linear amplitude.
vel_to_amp :: Int -> R

-- | Midi velocity number to grey scale.
vel_to_grey :: R -> Int -> R

-- | Midi sequence data.
type Sequencer_Midi n = Wseq R (n, n)

-- | Convert <a>Sequencer_Midi</a> node to <a>C_Rect</a>.
sequencer_midi_to_rect :: Real n => ((R, R), (n, n)) -> C_Rect

-- | Plot <a>Sequencer_Midi</a>.
sequencer_plot_midi :: Real n => Seq_Plot_Opt -> FilePath -> String -> Sequencer_Midi n -> IO ()


-- | Contour contact sheets.
module Music.Theory.Diagram.Render.Contour.WT
data Setup
Setup :: Int -> (Int, Int) -> (R, R) -> R -> Setup
wt_nc :: Setup -> Int
wt_dimensions :: Setup -> (Int, Int)
wt_spacers :: Setup -> (R, R)
wt_scalar :: Setup -> R
type CN = [(Bool, [Int])]
type PP = [CN]
fi :: Integral a => a -> R
ipt :: Integral a => a -> a -> Pt R

-- | Generate grid points. l=left, u=upper, r=rows, c=columns, w=width,
--   h=height
grid :: (R, R) -> (Int, Int) -> (R, R) -> (R, R) -> [Pt R]

-- | Calculate number of rows (nr) given number of columns (nc) and number
--   of entries (ne).
calc_nr :: Integral t => t -> t -> t

-- | Cairo co-ordinates are <i>y</i> descending.
invert :: Num a => a -> [a] -> [a]
draw_contour :: Pt R -> Bool -> [Int] -> Render ()
draw_border :: Pt R -> (Int, Int) -> Render ()
draw_img :: Pt R -> (Int, Int) -> CN -> Render ()
draw_wt :: Setup -> PP -> Render ()

-- | Select format from extension (ie. <tt>.pdf</tt> or <tt>.svg</tt>).
draw :: FilePath -> Setup -> [PP] -> IO ()


-- | Functions for circular representations of Zn structures.
module Music.Theory.Diagram.Render.Circular
type P = Pt R
lw :: R
circle_s :: Ca -> P -> R -> Render ()
marks :: R -> Int -> [R]
marks_p :: R -> R -> Int -> [P]
type Text_F = Maybe (Int -> String)

-- | Frame, circle at <tt>(0,0)</tt> with radius <i>r</i> and <i>n</i>
--   marks.
frame :: R -> Int -> Text_F -> Render ()
circle_polygon :: R -> Int -> Ca -> [Int] -> Render ()
circle_marks :: R -> Int -> Ca -> [Int] -> Render ()
circle_diagram_set :: Int -> Text_F -> [[Int]] -> Render ()
circle_diagram :: Int -> Text_F -> [Int] -> Render ()

-- | Variant of <a>render_to_file</a>.
--   
--   <pre>
--   let s = [[0..11],[0,2..10],[0,3..9],[0,4,8]
--           ,[0,5,10,3,8,1,6,11,4,9,2,7]]
--   in to_file F_SVG "/tmp/circular" (circle_diagram_set 12 (Just show) s)
--   </pre>
--   
--   <pre>
--   let s = [[0,5,6,7],[1,2,3,8],[4,9,10,11]]
--   in to_file F_SVG "/tmp/circular" (circle_diagram_set 12 (Just show) s)
--   </pre>
--   
--   <pre>
--   let {s = [0,1,5,6,12,25,29,36,42,48,49,53]
--       ;t = [0,8,16,18,26,34]
--       ;z = map (\i -&gt; map ((`mod` 72) . (+ i)) s) t}
--   in to_file F_SVG "/tmp/circular" (circle_diagram_set 72 (Just show) z)
--   </pre>
to_file :: File_Type -> FilePath -> Render () -> IO ()


-- | Functions to make <i>path diagrams</i> such as those in Fig. VIII-11
--   on I.Xenakis <i>Formalized Music</i>.
module Music.Theory.Diagram.Path

-- | Set of all <i>(pre,element,post)</i> triples of a sequence.
--   
--   <pre>
--   parts "abc" == [("",'a',"bc"),("a",'b',"c"),("ab",'c',"")]
--   </pre>
parts :: [a] -> [([a], a, [a])]

-- | All <i>(element,remainder)</i> pairs for a sequence.
--   
--   <pre>
--   parts' "abc" == [('a',"bc"),('b',"ac"),('c',"ab")]
--   </pre>
parts' :: [a] -> [(a, [a])]

-- | Gather elements with equal keys.
--   
--   <pre>
--   gather (zip "abcba" [0..]) == [('a',[0,4]),('b',[1,3]),('c',[2])]
--   </pre>
gather :: Ord a => [(a, i)] -> [(a, [i])]

-- | Does either endpoint of the <i>lhs</i> <a>Ln</a> lie on the <i>rhs</i>
--   <a>Ln</a>.
--   
--   <pre>
--   ln_on (ln' (1/2,1/2) (1/2,1)) (ln' (0,0) (1,1)) == True
--   ln_on (ln' (1/2,0) (1/2,1)) (ln' (0,0) (1,1)) == False
--   </pre>
ln_on :: Ln R -> Ln R -> Bool

-- | Do <a>Ln</a>s overlap in the particular sense of being
--   <a>ln_parallel</a> and at least one endpoint of one line lying on the
--   other.
overlap :: Ln R -> Ln R -> Bool

-- | Do both points of the <i>rhs</i> <a>Ln</a> lie on the <i>lhs</i>
--   <a>Ln</a>.
includes :: Ln R -> Ln R -> Bool

-- | <a>flip</a> <a>includes</a>.
is_included :: Ln R -> Ln R -> Bool

-- | Apply <i>f</i> to <i>x</i> and <i>y</i> duple of <a>Pt</a>.
pt_fn :: ((a, a) -> b) -> Pt a -> b

-- | Apply <i>f</i> to <i>start</i> and <i>end</i> <a>Pt</a> duple of
--   <a>Ln</a>.
ln_fn :: (Num a, Eq a) => ((Pt a, Pt a) -> b) -> Ln a -> b

-- | Apply <i>f</i> to <i>start</i> and <i>end</i> <a>Pt</a>s of <a>Ln</a>
--   and construct <a>Ln</a>.
ln_pt_fn :: (Num a, Eq a, Num b, Eq b) => (Pt a -> Pt b) -> Ln a -> Ln b

-- | Scale set of <a>Ln</a> to lie in area given by <i>(0,n)</i>.
to_unit :: R -> [Ln R] -> [Ln R]

-- | Enumeration of <a>Vertical</a>, <a>Horizontal</a> and <a>Diagonal</a>.
data Orientation a
Vertical :: Orientation a
Horizontal :: Orientation a
Diagonal :: a -> Orientation a

-- | Calculate <a>Orientation</a> of <a>Ln</a>.
--   
--   <pre>
--   orientation (ln' (0,0) (0,1)) == Vertical
--   orientation (ln' (0,0) (1,0)) == Horizontal
--   orientation (ln' (0,0) (1,1)) == Diagonal 1
--   </pre>
orientation :: (Fractional a, Eq a) => Ln a -> Orientation a

-- | A table <a>Pt</a> and <a>Orientation</a> set pairs.
type Shift_Map a = [(Pt a, [Orientation a])]

-- | Construct a <a>Shift_Map</a> from a set of <a>Ln</a>s.
mk_shift_map :: [Ln R] -> Shift_Map R

-- | Apply <a>Shift_Map</a> to a <a>Pt</a>.
shift_map_pt :: Shift_Map R -> Pt R -> Pt R

-- | Apply <a>Shift_Map</a> to a <a>Ln</a>.
shift_map_ln :: Shift_Map R -> Ln R -> Ln R

-- | A table of <a>Pt</a> pairs.
type Shift_Table a = [(Pt a, Pt a)]

-- | Make element of <a>Shift_Table</a>.
mk_shift_tbl_m :: (Ln R, Bool) -> Maybe (Shift_Table R)

-- | Make complete <a>Shift_Table</a>.
mk_shift_tbl :: Collision_Table -> Shift_Table R

-- | Apply <a>Shift_Table</a> to <a>Ln</a>.
shift_table_ln :: Shift_Table R -> Ln R -> Ln R

-- | Table of <a>Ln</a>s indicating collisions.
type Collision_Table = [(Ln R, Bool)]

-- | Construct <a>Collision_Table</a> for a set of <a>Ln</a>.
mk_collision_table :: [Ln R] -> Collision_Table

-- | Construct <a>Shift_Table</a> from <a>Collision_Table</a> and shift all
--   <a>Ln</a>.
collision_table_rewrite :: Collision_Table -> [Ln R]

-- | A diagram given as a set of <a>Int</a> pairs.
type Path_Diagram = [(Int, Int)]

-- | Construct set of <a>Ln</a> from <a>Path_Diagram</a>.
path_diagram_ln :: Path_Diagram -> [Ln R]

-- | <a>Collision_Table</a> based resolution of <a>Path_Diagram</a>.
mk_path_ct :: Path_Diagram -> [Ln R]

-- | <a>Shift_Map</a> variant of <a>mk_path_ct</a>.
mk_path_sm :: Path_Diagram -> [Ln R]
instance Eq a => Eq (Orientation a)
instance Show a => Show (Orientation a)


-- | Functions to make <i>path diagrams</i> such as those in Fig. VIII-11
--   on I.Xenakis <i>Formalized Music</i>.
module Music.Theory.Diagram.Render.Path

-- | A set of <a>Ca</a> and <a>Ls</a> pairs.
type Path = [(Ca, Ls R)]

-- | Draw <a>Path</a> with mid-point arrows.
draw_path :: Path -> Render ()

-- | <a>mapM_</a> <a>draw_path</a>.
draw_paths :: [Path] -> Render ()

-- | <a>draw_paths</a> to named <tt>PDF</tt> file.
write_pdf :: FilePath -> [Path] -> IO ()

-- | Write <tt>PDF</tt> of a set of <a>Path_Diagram</a>s to named file.
path_diagram :: FilePath -> [Path_Diagram] -> IO ()


-- | Functions for drawing grid and table structure common in music theory
--   and in compositions such as Morton Feldman's durational <i>grid</i>
--   music of the 1950's.
module Music.Theory.Diagram.Grid

-- | Point given as pair of <a>R</a>.
type P = (R, R)

-- | Red, green and blue colour triple.
type C = (R, R, R)

-- | Cell location as row and column indices.
type L = (Int, Int)

-- | Cell
type Cell = (L, C, String)

-- | Grid
type Grid = [Cell]

-- | Given <i>(x,y)</i> upper-left co-ordinate of grid, <i>(w,h)</i> cell
--   dimensions, and <i>(r,c)</i> grid dimensions, make array of upper-left
--   co-ordinates of cells.
--   
--   <pre>
--   grid (10,10) (50,10) (2,2) = [[(10,10),(60,10)],[(10,20),(60,20)]]
--   </pre>
grid :: (Enum a, Num a) => (a, a) -> (a, a) -> (Int, Int) -> [[(a, a)]]

-- | Variant on <a>grid</a> that constructs a single point.
--   
--   <pre>
--   map (grid_pt (10,10) (50,10)) [(0,0),(1,1)] == [(10,10),(60,20)]
--   </pre>
grid_pt :: (R, R) -> (R, R) -> L -> P

-- | Displace <a>P</a> (pointwise addition).
--   
--   <pre>
--   displace (2,3) (1,1) == (3,4)
--   </pre>
displace :: (R, R) -> P -> P

-- | Make a bounding box from <i>row</i> and <i>column</i> dimensions.
mk_bbox :: (Int, Int) -> (R, R)

-- | A table cell is an <a>Attr</a> and <a>Content</a> duple.
type Table_Cell = ([Attr], [Content])

-- | A table caption.
type Caption = [Content]

-- | Table of row order <a>Table_Cell</a>s.
type HTML_Table = (Caption, [[Table_Cell]])

-- | Construct a <tt>Table</tt> with one <a>Content</a> per cell.
simple_table :: Caption -> [[Content]] -> HTML_Table

-- | Construct a <tt>Table</tt> with one <a>Content</a> per cell, and an
--   associated class.
simple_table_class :: Caption -> [[(String, Content)]] -> HTML_Table

-- | A function from <tt>(row,column)</tt> to <a>Maybe</a>
--   <a>Table_Cell</a>
type Build_F = (Int, Int) -> Maybe Table_Cell

-- | Build a table of <tt>(rows,columns)</tt> dimensions given a builder
--   function. If the function is <a>Nothing</a> the cell is skipped,
--   becase another cell has claimed it's locations with <a>colspan</a> or
--   <a>rowspan</a>.
build_table_m :: Caption -> (Int, Int) -> Build_F -> HTML_Table

-- | Build a table of <tt>(rows,columns)</tt> dimensions given a function
--   from <tt>(row,column)</tt> to <a>Table_Cell</a>.
build_table :: Caption -> (Int, Int) -> ((Int, Int) -> Table_Cell) -> HTML_Table

-- | Render <tt>Table</tt> as <tt>HTML</tt> table.
table :: HTML_Table -> Content

-- | A set of related tables.
type HTML_Table_Set = [HTML_Table]

-- | Render a <tt>Table_Set</tt>s in a <tt>div</tt> with class
--   <tt>table-set</tt>.
table_set :: HTML_Table_Set -> Content

-- | Render set of <tt>Table_Set</tt>s as <tt>HTML</tt>.
page :: Maybe FilePath -> [HTML_Table_Set] -> String

-- | Write set of <tt>Table_Set</tt>s to <tt>HTML</tt> file.
to_html :: FilePath -> Maybe FilePath -> [HTML_Table_Set] -> IO ()


-- | Functions for drawing grid and table structure common in music theory
--   and in compositions such as Morton Feldman's durational <i>grid</i>
--   music of the 1950's.
module Music.Theory.Diagram.Render.Grid

-- | Render <tt>Grid</tt> of <i>(rows,columns)</i> with displacement
--   <i>(dx,dy)</i> in indicated font size.
mk_grid :: (Int, Int) -> (R, R) -> R -> Grid -> Render ()

-- | Run render to <tt>PDF</tt> file.
--   
--   <pre>
--   let g = [((0,0),(1,0,0),"a"),((2,2),(0,0,1),"b")]
--   in to_pdf "/tmp/grid.pdf" (60,60) (mk_grid (4,4) (2,8) 9 g)
--   </pre>
to_pdf :: FilePath -> (R, R) -> Render () -> IO ()


-- | Functions for <i>Hinton</i> diagrams of matrices.
module Music.Theory.Diagram.Render.Hinton

-- | Regular (unchecked) two dimensional arrays.
type Arr t = [[t]]

-- | Dimensions of <a>Arr</a>, columns are as at row <tt>0</tt>.
a_dimensions :: Arr t -> (Int, Int)

-- | Normalise <a>Arr</a> such that maxima is <tt>1</tt>.
--   
--   <pre>
--   a_normalise [[3,2],[4,5]] == [[0.6,0.4],[0.8,1.0]]
--   </pre>
a_normalise :: (Fractional t, Ord t) => Arr t -> Arr t

-- | Multiply all elements at <a>Arr</a> by <i>k</i>.
--   
--   <pre>
--   a_scale 0.85 (a_normalise [[3,2],[4,5]]) == [[0.51,0.34],[0.68,0.85]]
--   </pre>
a_scale :: Num t => t -> Arr t -> Arr t
draw_hinton_cell :: (C, C) -> ((R, R), R) -> Render ()
draw_hinton1 :: (C, C, C) -> (Int, Int) -> Arr R -> Render ()

-- | Colours are (background,negative,positive). <i>s</i> is a scalar for
--   normalisation of matrix data.
hinton_diagrams :: (C, C, C) -> R -> FilePath -> [Arr R] -> IO ()


-- | Tuning tables
module Music.Theory.Tuning.Table

-- | <a>Table_Cell</a> from set of <a>HS_R</a>.
hs_r_cell :: (p -> String) -> Int -> (Int -> String) -> [HS_R p] -> (Int, Int) -> Table_Cell
hs_r_pitch_cell :: Int -> (Int -> String) -> [HS_R Pitch] -> (Int, Int) -> Table_Cell
