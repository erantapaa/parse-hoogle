-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | BCrypt salted and hashed passwords in a database as auth for yesod
--   
@package yesod-auth-bcrypt
@version 0.2.0


-- | A yesod-auth AuthPlugin designed to look users up in Persist where
--   their user ID and a Bcrypt hash + salt of their password is stored.
--   
--   Example usage:
--   
--   <pre>
--   -- import the function
--   import Auth.HashDB
--   
--   -- make sure you have an auth route
--   mkYesodData "MyApp" [$parseRoutes|
--   / RootR GET
--   /auth AuthR Auth getAuth
--   |]
--   
--   
--   -- make your app an instance of YesodAuth using this plugin
--   instance YesodAuth MyApp where
--      type AuthId MyApp = UserId
--   
--      loginDest _  = RootR
--      logoutDest _ = RootR
--      getAuthId    = getAuthIdHashDB AuthR (Just . UniqueUser)
--      authPlugins  = [authHashDB (Just . UniqueUser)]
--   
--   
--   -- include the migration function in site startup
--   withServer :: (Application -&gt; IO a) -&gt; IO a
--   withServer f = withConnectionPool $ \p -&gt; do
--       runSqlPool (runMigration migrateUsers) p
--       let h = DevSite p
--   </pre>
--   
--   Note that function which converts username to unique identifier must
--   be same.
--   
--   Your app must be an instance of YesodPersist. and the username,
--   salted-and-hashed-passwords should be added to the database.
module Yesod.Auth.BCrypt

-- | Interface for data type which holds user info. It's just a collection
--   of getters and setters
class HashDBUser siteuser
siteuserPasswordHash :: HashDBUser siteuser => siteuser -> Maybe Text
setSaltAndPasswordHash :: HashDBUser siteuser => Text -> siteuser -> siteuser

-- | Unique keys besides the Key

-- | Set password for user. This function should be used for setting
--   passwords. It generates random salt and calculates proper hashes.
setPassword :: HashDBUser siteuser => Text -> siteuser -> IO (siteuser)

-- | Given a user ID and password in plaintext, validate them against the
--   database values.
validateUser :: (YesodPersist yesod, PersistEntity siteuser, HashDBUser siteuser, PersistEntityBackend siteuser ~ YesodPersistBackend yesod, PersistUnique (YesodPersistBackend yesod)) => Unique siteuser -> Text -> HandlerT yesod IO Bool

-- | Prompt for username and password, validate that against a database
--   which holds the username and a hash of the password
authHashDB :: (YesodAuth m, YesodPersist m, HashDBUser siteuser, PersistEntity siteuser, PersistEntityBackend siteuser ~ YesodPersistBackend m, PersistUnique (YesodPersistBackend m)) => (Text -> Maybe (Unique siteuser)) -> AuthPlugin m

-- | A drop in for the getAuthId method of your YesodAuth instance which
--   can be used if authHashDB is the only plugin in use.
getAuthIdHashDB :: (YesodAuth master, YesodPersist master, HashDBUser siteuser, PersistEntity siteuser, Key siteuser ~ AuthId master, PersistEntityBackend siteuser ~ YesodPersistBackend master, PersistUnique (YesodPersistBackend master)) => (AuthRoute -> Route master) -> (Text -> Maybe (Unique siteuser)) -> Creds master -> HandlerT master IO (Maybe (AuthId master))

-- | Generate data base instances for a valid user
data Siteuser
Siteuser :: !Text -> !Text -> !(Maybe Text) -> Siteuser
siteuserUsername :: Siteuser -> !Text
siteuserPassword :: Siteuser -> !Text
siteuserEmail :: Siteuser -> !(Maybe Text)
type SiteuserId = Key Siteuser

-- | An <a>EntityField</a> is parameterised by the Haskell record it
--   belongs to and the additional type of that field
migrateSiteusers :: Migration
instance Typeable Siteuser
instance Show (Key Siteuser)
instance Read (Key Siteuser)
instance Eq (Key Siteuser)
instance Ord (Key Siteuser)
instance PathPiece (Key Siteuser)
instance PersistField (Key Siteuser)
instance PersistFieldSql (Key Siteuser)
instance ToJSON (Key Siteuser)
instance FromJSON (Key Siteuser)
instance HashDBUser Siteuser
instance ToBackendKey SqlBackend Siteuser
instance PersistEntity Siteuser
instance PersistFieldSql Siteuser
instance PersistField Siteuser
