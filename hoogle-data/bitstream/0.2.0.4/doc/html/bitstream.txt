-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast, packed, strict and lazy bit streams with stream fusion
--   
--   Fast, packed, strict and lazy bit vectors with stream fusion. This is
--   like <tt>bytestring</tt> but stores bits instead of bytes.
@package bitstream
@version 0.2.0.4


-- | Some functions currently missing from
--   <a>Data.Vector.Fusion.Stream.Monadic</a>.
module Data.Bitstream.Fusion.Monadic
genericLength :: (Monad m, Num n) => Stream m α -> m n
genericTake :: (Monad m, Integral n) => n -> Stream m α -> Stream m α
genericDrop :: (Monad m, Integral n) => n -> Stream m α -> Stream m α
genericIndex :: (Monad m, Integral n, Show n) => Stream m α -> n -> m α
genericReplicate :: (Monad m, Integral n) => n -> α -> Stream m α
genericReplicateM :: (Monad m, Integral n) => n -> m α -> Stream m α
genericUnfoldrN :: (Monad m, Integral n) => n -> (β -> Maybe (α, β)) -> β -> Stream m α
genericUnfoldrNM :: (Monad m, Integral n) => n -> (β -> m (Maybe (α, β))) -> β -> Stream m α
genericFindIndex :: (Monad m, Integral n) => (α -> Bool) -> Stream m α -> m (Maybe n)
genericFindIndexM :: (Monad m, Integral n) => (α -> m Bool) -> Stream m α -> m (Maybe n)
genericIndexed :: (Monad m, Integral n) => Stream m α -> Stream m (n, α)


-- | Some functions currently missing from
--   <a>Data.Vector.Fusion.Stream</a>.
module Data.Bitstream.Fusion
genericLength :: Num n => Stream α -> n
genericTake :: Integral n => n -> Stream α -> Stream α
genericDrop :: Integral n => n -> Stream α -> Stream α
genericIndex :: (Integral n, Show n) => Stream α -> n -> α
genericReplicate :: Integral n => n -> α -> Stream α
genericUnfoldrN :: Integral n => n -> (β -> Maybe (α, β)) -> β -> Stream α
genericFindIndex :: Integral n => (α -> Bool) -> Stream α -> Maybe n
genericIndexed :: Integral n => Stream α -> Stream (n, α)


-- | Generic interface to diverse types of <a>Bitstream</a>.
module Data.Bitstream.Generic

-- | Class of diverse types of <a>Bitstream</a>.
--   
--   Methods of this class are functions of <a>Bitstream</a>s that are
--   either basic functions to implement other ones, or have to preserve
--   their packet/chunk structure for efficiency and strictness behaviour.
--   
--   Minimum complete implementation: <i>All but</i> <a>basicCons'</a>,
--   <a>basicConcat</a>, <tt>basicReplicate</tt>, <a>basicPartition</a> and
--   <tt>basicFromBits</tt>.
class Bitstream α where basicCons' = basicCons basicConcat [] = (∅) basicConcat (α : αs) = α ⧺ concat αs basicPartition f α = (filter f α, filter ((¬) ∘ f) α)
basicStream :: Bitstream α => α -> Stream Bool
basicUnstream :: Bitstream α => Stream Bool -> α
basicCons :: Bitstream α => Bool -> α -> α
basicCons' :: Bitstream α => Bool -> α -> α
basicSnoc :: Bitstream α => α -> Bool -> α
basicAppend :: Bitstream α => α -> α -> α
basicTail :: Bitstream α => α -> α
basicInit :: Bitstream α => α -> α
basicMap :: Bitstream α => (Bool -> Bool) -> α -> α
basicReverse :: Bitstream α => α -> α
basicConcat :: Bitstream α => [α] -> α
basicScanl :: Bitstream α => (Bool -> Bool -> Bool) -> Bool -> α -> α
basicTake :: (Bitstream α, Integral n) => n -> α -> α
basicDrop :: (Bitstream α, Integral n) => n -> α -> α
basicTakeWhile :: Bitstream α => (Bool -> Bool) -> α -> α
basicDropWhile :: Bitstream α => (Bool -> Bool) -> α -> α
basicFilter :: Bitstream α => (Bool -> Bool) -> α -> α
basicPartition :: Bitstream α => (Bool -> Bool) -> α -> (α, α)
basicFromNBits :: (Bitstream α, Integral n, Integral β, Bits β) => n -> β -> α
basicToBits :: (Bitstream α, Integral β, Bits β) => α -> β

-- | <i>O(1)</i> The empty <a>Bitstream</a>.
empty :: Bitstream α => α

-- | (∅) = <a>empty</a>
--   
--   U+2205, EMPTY SET
(∅) :: Bitstream α => α

-- | <i>O(1)</i> Convert a <a>Bool</a> into a <a>Bitstream</a>.
singleton :: Bitstream α => Bool -> α

-- | <i>O(n)</i> Convert a [<a>Bool</a>] into a <a>Bitstream</a>.
pack :: Bitstream α => [Bool] -> α

-- | <i>O(n)</i> Convert a <a>Bitstream</a> into a [<a>Bool</a>].
unpack :: Bitstream α => α -> [Bool]

-- | <i>O(n)</i> Convert a <a>FiniteBits</a> into a <a>Bitstream</a>.
fromBits :: (Integral β, FiniteBits β, Bitstream α) => β -> α

-- | <i>O(n)</i> Convert the lower <tt>n</tt> bits of the given
--   <a>Bits</a>. In the case that more bits are requested than the
--   <a>Bits</a> provides, this acts as if the <a>Bits</a> has an infinite
--   number of leading 0 bits.
fromNBits :: (Integral n, Integral β, Bits β, Bitstream α) => n -> β -> α

-- | <i>O(n)</i> Convert a <a>Bitstream</a> into a <a>Bits</a>.
toBits :: (Bitstream α, Integral β, Bits β) => α -> β

-- | <i>O(n)</i> Explicitly convert a <a>Bitstream</a> into a <a>Stream</a>
--   of <a>Bool</a>.
--   
--   <a>Bitstream</a> operations are automatically fused whenever it's
--   possible, safe, and effective to do so, but sometimes you may find the
--   rules are too conservative. These two functions <a>stream</a> and
--   <a>unstream</a> provide a means for coercive stream fusion.
--   
--   You should be careful when you use <a>stream</a>. Most functions in
--   this package are optimised to minimise frequency of memory allocations
--   and copyings, but getting <a>Bitstream</a>s back from
--   <tt><a>Stream</a> <a>Bool</a></tt> requires the whole <a>Bitstream</a>
--   to be constructed from scratch. Moreover, for lazy <a>Bitstream</a>s
--   this leads to be an incorrect strictness behaviour because lazy
--   <a>Bitstream</a>s are represented as lists of strict <a>Bitstream</a>
--   chunks but <a>stream</a> can't preserve the original chunk structure.
--   Let's say you have a lazy <a>Bitstream</a> with the following chunks:
--   
--   <pre>
--   bs = [chunk1, chunk2, chunk3, ...]
--   </pre>
--   
--   and you want to drop the first bit of such stream. Our <a>tail</a> is
--   only strict on the <tt>chunk1</tt> and will produce the following
--   chunks:
--   
--   <pre>
--   <a>tail</a> bs = [chunk0, chunk1', chunk2, chunk3, ...]
--   </pre>
--   
--   where <tt>chunk0</tt> is a singleton vector of the first packet of
--   <tt>chunk1</tt> whose first bit is dropped, and <tt>chunk1'</tt> is a
--   vector of remaining packets of the <tt>chunk1</tt>. Neither
--   <tt>chunk2</tt> nor <tt>chunk3</tt> have to be evaluated here as you
--   might expect.
--   
--   But think about the following expression:
--   
--   <pre>
--   import qualified Data.Vector.Fusion.Stream as Stream
--   <a>unstream</a> $ Stream.tail $ <a>stream</a> bs
--   </pre>
--   
--   the resulting chunk structure will be:
--   
--   <pre>
--   [chunk1', chunk2', chunk3', ...]
--   </pre>
--   
--   where each and every chunks are slightly different from the original
--   chunks, and this time <tt>chunk1'</tt> has the same length as
--   <tt>chunk1</tt> but the last bit of <tt>chunk1'</tt> is from the first
--   bit of <tt>chunk2</tt>. This means when you next time apply some
--   functions strict on the first chunk, you end up fully evaluating
--   <tt>chunk2</tt> as well as <tt>chunk1</tt> and this can be a serious
--   misbehaviour for lazy <a>Bitstream</a>s.
--   
--   The automatic fusion rules are carefully designed to fire only when
--   there aren't any reason to preserve the original packet / chunk
--   structure.
stream :: Bitstream α => α -> Stream Bool

-- | <i>O(n)</i> Convert a <a>Stream</a> of <a>Bool</a> into a
--   <a>Bitstream</a>.
unstream :: Bitstream α => Stream Bool -> α

-- | <i>strict: O(n), lazy: O(1)</i> <a>cons</a> is an analogous to
--   (<tt>:</tt>) for lists.
cons :: Bitstream α => Bool -> α -> α

-- | <i>O(n)</i> For strict <a>Bitstream</a>s, <a>cons'</a> is exactly the
--   same as <a>cons</a>.
--   
--   For lazy ones, <a>cons'</a> is strict in the <a>Bitstream</a> we are
--   consing onto. More precisely, it forces the first chunk to be
--   evaluated. It does this because, for space efficiency, it may coalesce
--   the new bit onto the first chunk rather than starting a new chunk.
cons' :: Bitstream α => Bool -> α -> α

-- | <i>O(n)</i> Append a bit to the end of a <a>Bitstream</a>.
snoc :: Bitstream α => α -> Bool -> α

-- | <i>O(n)</i> Append two <a>Bitstream</a>s.
append :: Bitstream α => α -> α -> α

-- | (⧺) = <a>append</a>
--   
--   U+29FA, DOUBLE PLUS
(⧺) :: Bitstream α => α -> α -> α

-- | <i>O(1)</i> Extract the first bit of a non-empty <a>Bitstream</a>. An
--   exception will be thrown if empty.
head :: Bitstream α => α -> Bool

-- | <i>strict: O(1), lazy: O(n)</i> Extract the last bit of a finite
--   <a>Bitstream</a>. An exception will be thrown if empty.
last :: Bitstream α => α -> Bool

-- | <i>O(1)</i> Extract the bits after the <a>head</a> of a non-empty
--   <a>Bitstream</a>. An exception will be thrown if empty.
tail :: Bitstream α => α -> α

-- | <i>O(n)</i> Return all the bits of a <a>Bitstream</a> except the last
--   one. An exception will be thrown if empty.
init :: Bitstream α => α -> α

-- | <i>O(1)</i> Test whether a <a>Bitstream</a> is empty.
null :: Bitstream α => α -> Bool

-- | <i>strict: O(1), lazy: O(n)</i> Return the length of a finite
--   <a>Bitstream</a>.
length :: Bitstream α => Num n => α -> n

-- | <i>O(n)</i> Map a function over a <a>Bitstream</a>.
map :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> Reverse a <a>Bitstream</a>.
reverse :: Bitstream α => α -> α

-- | <i>O(n)</i> <a>foldl</a>, applied to a binary operator, a starting
--   value (typically the left-identity of the operator), and a
--   <a>Bitstream</a>, reduces the <a>Bitstream</a> using the binary
--   operator, from left to right:
--   
--   <pre>
--   <a>foldl</a> f z [x1, x2, ..., xn] == (...((z <tt>f</tt> x1) <tt>f</tt> x2) <tt>f</tt>...) <tt>f</tt> xn
--   </pre>
--   
--   The <a>Bitstream</a> must be finite.
foldl :: Bitstream α => (β -> Bool -> β) -> β -> α -> β

-- | <i>O(n)</i> <a>foldl'</a> is a variant of <a>foldl</a> that is strict
--   on the accumulator.
foldl' :: Bitstream α => (β -> Bool -> β) -> β -> α -> β

-- | <i>O(n)</i> <a>foldl1</a> is a variant of <a>foldl</a> that has no
--   starting value argument, and thus must be applied to non-empty
--   <a>Bitstream</a>s.
foldl1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> A strict version of <a>foldl1</a>.
foldl1' :: Bitstream α => (Bool -> Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> <a>foldr</a>, applied to a binary operator, a starting
--   value (typically the right-identity of the operator), and a
--   <a>Bitstream</a>, reduces the <a>Bitstream</a> using the binary
--   operator, from right to left:
--   
--   <pre>
--   <a>foldr</a> f z [x1, x2, ..., xn] == x1 <tt>f</tt> (x2 <tt>f</tt> ... (xn <tt>f</tt> z)...)
--   </pre>
foldr :: Bitstream α => (Bool -> β -> β) -> β -> α -> β

-- | <i>O(n)</i> <a>foldr1</a> is a variant of <a>foldr</a> that has no
--   starting value argument, and thus must be applied to non-empty
--   <a>Bitstream</a>s.
foldr1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> Concatenate all <a>Bitstream</a>s in the list.
concat :: Bitstream α => [α] -> α

-- | Map a function over a <a>Bitstream</a> and concatenate the results.
concatMap :: Bitstream α => (Bool -> α) -> α -> α

-- | <i>O(n)</i> <a>and</a> returns the conjunction of a <a>Bool</a> list.
--   For the result to be <a>True</a>, the <a>Bitstream</a> must be finite;
--   <a>False</a>, however, results from a <a>False</a> value at a finite
--   index of a finite or infinite <a>Bitstream</a>. Note that strict
--   <a>Bitstream</a>s are always finite.
and :: Bitstream α => α -> Bool

-- | <i>O(n)</i> <a>or</a> returns the disjunction of a <a>Bool</a> list.
--   For the result to be <a>False</a>, the <a>Bitstream</a> must be
--   finite; <a>True</a>, however, results from a <a>True</a> value at a
--   finite index of a finite or infinite <a>Bitstream</a>. Note that
--   strict <a>Bitstream</a>s are always finite.
or :: Bitstream α => α -> Bool

-- | <i>O(n)</i> Applied to a predicate and a <a>Bitstream</a>, <a>any</a>
--   determines if any bit of the <a>Bitstream</a> satisfies the predicate.
--   For the result to be <a>False</a>, the <a>Bitstream</a> must be
--   finite; <a>True</a>, however, results from a <a>True</a> value for the
--   predicate applied to a bit at a finite index of a finite or infinite
--   <a>Bitstream</a>.
any :: Bitstream α => (Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> Applied to a predicate and a <a>Bitstream</a>, <a>all</a>
--   determines if all bits of the <a>Bitstream</a> satisfy the predicate.
--   For the result to be <a>True</a>, the <a>Bitstream</a> must be finite;
--   <a>False</a>, however, results from a <a>False</a> value for the
--   predicate applied to a bit at a finite index of a finite or infinite
--   <a>Bitstream</a>.
all :: Bitstream α => (Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   <a>Bitstream</a> of successive reduced bits from the left:
--   
--   <pre>
--   <a>scanl</a> f z [x1, x2, ...] == [z, z <tt>f</tt> x1, (z <tt>f</tt> x1) <tt>f</tt> x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   <a>last</a> (<a>scanl</a> f z xs) == <a>foldl</a> f z xs
--   </pre>
scanl :: Bitstream α => (Bool -> Bool -> Bool) -> Bool -> α -> α

-- | <i>O(n)</i> <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   <a>scanl1</a> f [x1, x2, ...] == [x1, x1 <tt>f</tt> x2, ...]
--   </pre>
scanl1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   <a>head</a> (<a>scanr</a> f z xs) == <a>foldr</a> f z xs
--   </pre>
scanr :: Bitstream α => (Bool -> Bool -> Bool) -> Bool -> α -> α

-- | <i>O(n)</i> <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <tt><a>replicate</a> n x</tt> is a <a>Bitstream</a> of
--   length <tt>n</tt> with <tt>x</tt> the value of every bit.
replicate :: (Integral n, Bitstream α) => n -> Bool -> α

-- | <i>O(n)</i> The <a>unfoldr</a> function is a `dual' to <a>foldr</a>:
--   while <a>foldr</a> reduces a <a>Bitstream</a> to a summary value,
--   <a>unfoldr</a> builds a <a>Bitstream</a> from a seed value. The
--   function takes the element and returns <a>Nothing</a> if it is done
--   producing the <a>Bitstream</a> or returns <a>Just</a> <tt>(a, b)</tt>,
--   in which case, <tt>a</tt> is a prepended to the <a>Bitstream</a> and
--   <tt>b</tt> is used as the next element in a recursive call.
unfoldr :: Bitstream α => (β -> Maybe (Bool, β)) -> β -> α

-- | <i>O(n)</i> <a>unfoldrN</a> is a variant of <a>unfoldr</a> but
--   constructs a <a>Bitstream</a> with at most <tt>n</tt> bits.
unfoldrN :: (Integral n, Bitstream α) => n -> (β -> Maybe (Bool, β)) -> β -> α

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a <a>Bitstream</a>
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: (Integral n, Bitstream α) => n -> α -> α

-- | <i>O(n)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> bits, or <a>empty</a> if <tt>n
--   &gt; <a>length</a> xs</tt>.
drop :: (Integral n, Bitstream α) => n -> α -> α

-- | <i>O(n)</i> <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   <a>Bitstream</a> <tt>xs</tt>, returns the longest prefix (possibly
--   <a>empty</a>) of <tt>xs</tt> of bits that satisfy <tt>p</tt>.
takeWhile :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>dropWhile</a> <tt>p xs</tt> returns the suffix
--   remaining after <a>takeWhile</a> <tt>p xs</tt>.
dropWhile :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>span</a>, applied to a predicate <tt>p</tt> and a
--   <a>Bitstream</a> <tt>xs</tt>, returns a tuple where first element is
--   longest prefix (possibly <a>empty</a>) of <tt>xs</tt> of bits that
--   satisfy <tt>p</tt> and second element is the remainder of the
--   <a>Bitstream</a>.
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: Bitstream α => (Bool -> Bool) -> α -> (α, α)

-- | <i>O(n)</i> <a>break</a>, applied to a predicate <tt>p</tt> and a
--   <a>Bitstream</a> <tt>xs</tt>, returns a tuple where first element is
--   longest prefix (possibly <a>empty</a>) of <tt>xs</tt> of bits that
--   <i>do not satisfy</i> <tt>p</tt> and second element is the remainder
--   of the <a>Bitstream</a>.
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<tt>not</tt>
--   . p)</tt>.
break :: Bitstream α => (Bool -> Bool) -> α -> (α, α)

-- | <i>O(n)</i> <a>elem</a> is the <a>Bitstream</a> membership predicate,
--   usually written in infix form, e.g., <tt>x `elem` xs</tt>. For the
--   result to be <a>False</a>, the <a>Bitstream</a> must be finite;
--   <a>True</a>, however, results from an bit equal to <tt>x</tt> found at
--   a finite index of a finite or infinite <a>Bitstream</a>.
elem :: Bitstream α => Bool -> α -> Bool

-- | (∈) = <a>elem</a>
--   
--   U+2208, ELEMENT OF
(∈) :: Bitstream α => Bool -> α -> Bool

-- | (∋) = <a>flip</a> (∈)
--   
--   U+220B, CONTAINS AS MEMBER
(∋) :: Bitstream α => α -> Bool -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the negation of <a>elem</a>.
notElem :: Bitstream α => Bool -> α -> Bool

-- | (∉) = <a>notElem</a>
--   
--   U+2209, NOT AN ELEMENT OF
(∉) :: Bitstream α => Bool -> α -> Bool

-- | (∌) = <a>flip</a> (∉)
--   
--   U+220C, DOES NOT CONTAIN AS MEMBER
(∌) :: Bitstream α => α -> Bool -> Bool

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>Bitstream</a> and returns the bit in the <a>Bitstream</a> matching
--   the predicate, or <a>Nothing</a> if there is no such bit.
find :: Bitstream α => (Bool -> Bool) -> α -> Maybe Bool

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a
--   <a>Bitstream</a>, returns the <a>Bitstream</a> of those bits that
--   satisfy the predicate.
filter :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> The <a>partition</a> function takes a predicate and a
--   <a>Bitstream</a> and returns the pair of <a>Bitstream</a>s of bits
--   which do and do not satisfy the predicate, respectively.
partition :: Bitstream α => (Bool -> Bool) -> α -> (α, α)

-- | <i>O(n)</i> <a>Bitstream</a> index (subscript) operator, starting from
--   0.
(!!) :: (Bitstream α, Integral n, Show n) => α -> n -> Bool

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first bit in the given <a>Bitstream</a> which is equal to the query
--   bit, or <a>Nothing</a> if there is no such bit.
elemIndex :: (Bitstream α, Integral n) => Bool -> α -> Maybe n

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all bits equal to the query bit, in
--   ascending order.
elemIndices :: (Bitstream α, Integral n) => Bool -> α -> [n]

-- | <i>O(n)</i> The <a>findIndex</a> function takes a predicate and a
--   <a>Bitstream</a> and returns the index of the first bit in the
--   <a>Bitstream</a> satisfying the predicate, or <a>Nothing</a> if there
--   is no such bit.
findIndex :: (Bitstream α, Integral n) => (Bool -> Bool) -> α -> Maybe n

-- | <i>O(n)</i> The <a>findIndices</a> function extends <a>findIndex</a>,
--   by returning the indices of all bits satisfying the predicate, in
--   ascending order.
findIndices :: (Bitstream α, Integral n) => (Bool -> Bool) -> α -> [n]

-- | <i>O(min(m, n))</i> <a>zip</a> takes two <a>Bitstream</a>s and returns
--   a list of corresponding bit pairs. If one input <a>Bitstream</a> is
--   short, excess bits of the longer <a>Bitstream</a> are discarded.
zip :: Bitstream α => α -> α -> [(Bool, Bool)]

-- | The <a>zip3</a> function takes three <a>Bitstream</a>s and returns a
--   list of triples, analogous to <a>zip</a>.
zip3 :: Bitstream α => α -> α -> α -> [(Bool, Bool, Bool)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>.
zip4 :: Bitstream α => α -> α -> α -> α -> [(Bool, Bool, Bool, Bool)]

-- | The <a>zip5</a> function takes five <a>Bitstream</a>s and returns a
--   list of five-tuples, analogous to <a>zip</a>.
zip5 :: Bitstream α => α -> α -> α -> α -> α -> [(Bool, Bool, Bool, Bool, Bool)]

-- | The <a>zip6</a> function takes six <a>Bitstream</a>s and returns a
--   list of six-tuples, analogous to <a>zip</a>.
zip6 :: Bitstream α => α -> α -> α -> α -> α -> α -> [(Bool, Bool, Bool, Bool, Bool, Bool)]

-- | <i>O(min(m, n))</i> <a>zipWith</a> generalises <a>zip</a> by zipping
--   with the function given as the first argument, instead of a tupling
--   function.
zipWith :: Bitstream α => (Bool -> Bool -> β) -> α -> α -> [β]

-- | The <a>zipWith3</a> function takes a function which combines three
--   bits, as well as three <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: Bitstream α => (Bool -> Bool -> Bool -> β) -> α -> α -> α -> [β]

-- | The <a>zipWith4</a> function takes a function which combines four
--   bits, as well as four <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith4 :: Bitstream α => (Bool -> Bool -> Bool -> Bool -> β) -> α -> α -> α -> α -> [β]

-- | The <a>zipWith5</a> function takes a function which combines five
--   bits, as well as five <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith5 :: Bitstream α => (Bool -> Bool -> Bool -> Bool -> Bool -> β) -> α -> α -> α -> α -> α -> [β]

-- | The <a>zipWith6</a> function takes a function which combines six bits,
--   as well as six <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith6 :: Bitstream α => (Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> β) -> α -> α -> α -> α -> α -> α -> [β]

-- | <i>O(min(m, n))</i> <a>unzip</a> transforms a list of bit pairs into a
--   <a>Bitstream</a> of first components and a <a>Bitstream</a> of second
--   components.
unzip :: Bitstream α => [(Bool, Bool)] -> (α, α)

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip3 :: Bitstream α => [(Bool, Bool, Bool)] -> (α, α, α)

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip4 :: Bitstream α => [(Bool, Bool, Bool, Bool)] -> (α, α, α, α)

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip5 :: Bitstream α => [(Bool, Bool, Bool, Bool, Bool)] -> (α, α, α, α, α)

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip6 :: Bitstream α => [(Bool, Bool, Bool, Bool, Bool, Bool)] -> (α, α, α, α, α, α)


-- | For internal use only.
module Data.Bitstream.Packet

-- | <a>Left</a> bitstreams interpret an octet as a vector of bits whose
--   LSB comes first and MSB comes last e.g.
--   
--   <ul>
--   <li>11110000 =&gt; [False, False, False, False, True, True , True ,
--   True]</li>
--   <li>10010100 =&gt; [False, False, True , False, True, False, False,
--   True]</li>
--   </ul>
--   
--   <a>Bits</a> operations (like <a>toBits</a>) treat a <a>Left</a>
--   bitstream as a little-endian integer.
data Left

-- | <a>Right</a> bitstreams interpret an octet as a vector of bits whose
--   MSB comes first and LSB comes last e.g.
--   
--   <ul>
--   <li>11110000 =&gt; [True, True , True , True, False, False, False,
--   False]</li>
--   <li>10010100 =&gt; [True, False, False, True, False, True , False,
--   False]</li>
--   </ul>
--   
--   <a>Bits</a> operations (like <a>toBits</a>) treat a <a>Right</a>
--   bitstream as a big-endian integer.
data Right

-- | <a>Packet</a>s are strict <a>Bitstream</a>s having at most 8 bits.
data Packet d

-- | <i>O(1)</i> <tt><a>full</a> p == <a>True</a></tt> iff
--   <tt><a>length</a> p == 8</tt>, otherwise it returns <a>False</a>.
full :: Packet d -> Bool

-- | <i>O(1)</i> Convert an octet to <a>Packet</a>.
fromOctet :: Word8 -> Packet d

-- | <i>O(1)</i> <a>toOctet</a> <tt>p</tt> converts a <a>Packet</a>
--   <tt>p</tt> to an octet, padding with zeroes if <tt><a>length</a> p
--   &lt; 8</tt>.
toOctet :: Packet d -> Word8

-- | <i>O(1)</i> Change the direction of <a>Packet</a> from <a>Left</a> to
--   <a>Right</a>. Bit directions only affect octet-based operations such
--   as <a>toOctet</a>.
packetLToR :: Packet Left -> Packet Right

-- | <i>O(1)</i> Change the direction of <a>Packet</a> from <a>Right</a> to
--   <a>Left</a>. Bit directions only affect octet-based operations such as
--   <a>toOctet</a>.
packetRToL :: Packet Right -> Packet Left
instance Eq (Packet d)
instance Bitstream (Packet Right)
instance Bitstream (Packet Left)
instance Ord (Packet Right)
instance Ord (Packet Left)
instance Show (Packet Right)
instance Show (Packet Left)
instance Storable (Packet d)


-- | Fast, packed, strict bit streams (i.e. list of <a>Bool</a>s) with
--   semi-automatic stream fusion.
--   
--   This module is intended to be imported <tt>qualified</tt>, to avoid
--   name clashes with <a>Prelude</a> functions. e.g.
--   
--   <pre>
--   import qualified Data.BitStream as BS
--   </pre>
--   
--   Strict <a>Bitstream</a>s are made of strict <a>Vector</a> of
--   <a>Packet</a>s, and each <a>Packet</a>s have at least 1 bit.
module Data.Bitstream

-- | A space-efficient representation of a <a>Bool</a> vector, supporting
--   many efficient operations. <a>Bitstream</a>s have an idea of
--   <i>directions</i> controlling how octets are interpreted as bits.
--   There are two types of concrete <a>Bitstream</a>s:
--   <tt><a>Bitstream</a> <a>Left</a></tt> and <tt><a>Bitstream</a>
--   <a>Right</a></tt>.
data Bitstream d

-- | <a>Left</a> bitstreams interpret an octet as a vector of bits whose
--   LSB comes first and MSB comes last e.g.
--   
--   <ul>
--   <li>11110000 =&gt; [False, False, False, False, True, True , True ,
--   True]</li>
--   <li>10010100 =&gt; [False, False, True , False, True, False, False,
--   True]</li>
--   </ul>
--   
--   <a>Bits</a> operations (like <a>toBits</a>) treat a <a>Left</a>
--   bitstream as a little-endian integer.
data Left

-- | <a>Right</a> bitstreams interpret an octet as a vector of bits whose
--   MSB comes first and LSB comes last e.g.
--   
--   <ul>
--   <li>11110000 =&gt; [True, True , True , True, False, False, False,
--   False]</li>
--   <li>10010100 =&gt; [True, False, False, True, False, True , False,
--   False]</li>
--   </ul>
--   
--   <a>Bits</a> operations (like <a>toBits</a>) treat a <a>Right</a>
--   bitstream as a big-endian integer.
data Right

-- | <i>O(1)</i> The empty <a>Bitstream</a>.
empty :: Bitstream α => α

-- | (∅) = <a>empty</a>
--   
--   U+2205, EMPTY SET
(∅) :: Bitstream α => α

-- | <i>O(1)</i> Convert a <a>Bool</a> into a <a>Bitstream</a>.
singleton :: Bitstream α => Bool -> α

-- | <i>O(n)</i> Convert a [<a>Bool</a>] into a <a>Bitstream</a>.
pack :: Bitstream α => [Bool] -> α

-- | <i>O(n)</i> Convert a <a>Bitstream</a> into a [<a>Bool</a>].
unpack :: Bitstream α => α -> [Bool]

-- | <i>O(n)</i> Convert a <a>Vector</a> of <a>Packet</a>s into a
--   <a>Bitstream</a>.
fromPackets :: Bitstream (Packet d) => Vector (Packet d) -> Bitstream d

-- | <i>O(1)</i> Convert a <a>Vector</a> of <a>Packet</a>s into a
--   <a>Bitstream</a>, with provided overall bit length. The correctness of
--   the bit length isn't checked, so you MUST be sure your bit length is
--   absolutely correct.
unsafeFromPackets :: Bitstream (Packet d) => Int -> Vector (Packet d) -> Bitstream d

-- | <i>O(1)</i> Convert a <a>Bitstream</a> into a <a>Vector</a> of
--   <a>Packet</a>s.
toPackets :: Bitstream d -> Vector (Packet d)

-- | <i>O(n)</i> Convert a strict <a>ByteString</a> into a strict
--   <a>Bitstream</a>.
fromByteString :: ByteString -> Bitstream d

-- | <i>O(n)</i> <tt><a>toByteString</a> bits</tt> converts a strict
--   <a>Bitstream</a> <tt>bits</tt> into a strict <a>ByteString</a>. The
--   resulting octets will be padded with zeroes if the <a>length</a> of
--   <tt>bs</tt> is not multiple of 8.
toByteString :: (Bitstream (Bitstream d), Bitstream (Packet d)) => Bitstream d -> ByteString

-- | <i>O(n)</i> Convert a <a>FiniteBits</a> into a <a>Bitstream</a>.
fromBits :: (Integral β, FiniteBits β, Bitstream α) => β -> α

-- | <i>O(n)</i> Convert the lower <tt>n</tt> bits of the given
--   <a>Bits</a>. In the case that more bits are requested than the
--   <a>Bits</a> provides, this acts as if the <a>Bits</a> has an infinite
--   number of leading 0 bits.
fromNBits :: (Integral n, Integral β, Bits β, Bitstream α) => n -> β -> α

-- | <i>O(n)</i> Convert a <a>Bitstream</a> into a <a>Bits</a>.
toBits :: (Bitstream α, Integral β, Bits β) => α -> β

-- | <i>O(n)</i> Explicitly convert a <a>Bitstream</a> into a <a>Stream</a>
--   of <a>Bool</a>.
--   
--   <a>Bitstream</a> operations are automatically fused whenever it's
--   possible, safe, and effective to do so, but sometimes you may find the
--   rules are too conservative. These two functions <a>stream</a> and
--   <a>unstream</a> provide a means for coercive stream fusion.
--   
--   You should be careful when you use <a>stream</a>. Most functions in
--   this package are optimised to minimise frequency of memory allocations
--   and copyings, but getting <a>Bitstream</a>s back from
--   <tt><a>Stream</a> <a>Bool</a></tt> requires the whole <a>Bitstream</a>
--   to be constructed from scratch. Moreover, for lazy <a>Bitstream</a>s
--   this leads to be an incorrect strictness behaviour because lazy
--   <a>Bitstream</a>s are represented as lists of strict <a>Bitstream</a>
--   chunks but <a>stream</a> can't preserve the original chunk structure.
--   Let's say you have a lazy <a>Bitstream</a> with the following chunks:
--   
--   <pre>
--   bs = [chunk1, chunk2, chunk3, ...]
--   </pre>
--   
--   and you want to drop the first bit of such stream. Our <a>tail</a> is
--   only strict on the <tt>chunk1</tt> and will produce the following
--   chunks:
--   
--   <pre>
--   <a>tail</a> bs = [chunk0, chunk1', chunk2, chunk3, ...]
--   </pre>
--   
--   where <tt>chunk0</tt> is a singleton vector of the first packet of
--   <tt>chunk1</tt> whose first bit is dropped, and <tt>chunk1'</tt> is a
--   vector of remaining packets of the <tt>chunk1</tt>. Neither
--   <tt>chunk2</tt> nor <tt>chunk3</tt> have to be evaluated here as you
--   might expect.
--   
--   But think about the following expression:
--   
--   <pre>
--   import qualified Data.Vector.Fusion.Stream as Stream
--   <a>unstream</a> $ Stream.tail $ <a>stream</a> bs
--   </pre>
--   
--   the resulting chunk structure will be:
--   
--   <pre>
--   [chunk1', chunk2', chunk3', ...]
--   </pre>
--   
--   where each and every chunks are slightly different from the original
--   chunks, and this time <tt>chunk1'</tt> has the same length as
--   <tt>chunk1</tt> but the last bit of <tt>chunk1'</tt> is from the first
--   bit of <tt>chunk2</tt>. This means when you next time apply some
--   functions strict on the first chunk, you end up fully evaluating
--   <tt>chunk2</tt> as well as <tt>chunk1</tt> and this can be a serious
--   misbehaviour for lazy <a>Bitstream</a>s.
--   
--   The automatic fusion rules are carefully designed to fire only when
--   there aren't any reason to preserve the original packet / chunk
--   structure.
stream :: Bitstream α => α -> Stream Bool

-- | <i>O(n)</i> Convert a <a>Stream</a> of <a>Bool</a> into a
--   <a>Bitstream</a>.
unstream :: Bitstream α => Stream Bool -> α

-- | <i>O(1)</i> Convert a <a>Bitstream</a> into a <a>Stream</a> of
--   <a>Packet</a>s.
streamPackets :: Bitstream d -> Stream (Packet d)

-- | <i>O(n)</i> Convert a <a>Stream</a> of <a>Packet</a>s into
--   <a>Bitstream</a>.
unstreamPackets :: Bitstream (Packet d) => Stream (Packet d) -> Bitstream d

-- | <i>O(n)</i> Convert a <tt><a>Bitstream</a> <a>Left</a></tt> into a
--   <tt><a>Bitstream</a> <a>Right</a></tt>. Bit directions only affect
--   octet-based operations such as <a>toByteString</a>.
directionLToR :: Bitstream Left -> Bitstream Right

-- | <i>O(n)</i> Convert a <tt><a>Bitstream</a> <a>Right</a></tt> into a
--   <tt><a>Bitstream</a> <a>Left</a></tt>. Bit directions only affect
--   octet-based operations such as <a>toByteString</a>.
directionRToL :: Bitstream Right -> Bitstream Left

-- | <i>strict: O(n), lazy: O(1)</i> <a>cons</a> is an analogous to
--   (<tt>:</tt>) for lists.
cons :: Bitstream α => Bool -> α -> α

-- | <i>O(n)</i> Append a bit to the end of a <a>Bitstream</a>.
snoc :: Bitstream α => α -> Bool -> α

-- | <i>O(n)</i> Append two <a>Bitstream</a>s.
append :: Bitstream α => α -> α -> α

-- | (⧺) = <a>append</a>
--   
--   U+29FA, DOUBLE PLUS
(⧺) :: Bitstream α => α -> α -> α

-- | <i>O(1)</i> Extract the first bit of a non-empty <a>Bitstream</a>. An
--   exception will be thrown if empty.
head :: Bitstream α => α -> Bool

-- | <i>strict: O(1), lazy: O(n)</i> Extract the last bit of a finite
--   <a>Bitstream</a>. An exception will be thrown if empty.
last :: Bitstream α => α -> Bool

-- | <i>O(1)</i> Extract the bits after the <a>head</a> of a non-empty
--   <a>Bitstream</a>. An exception will be thrown if empty.
tail :: Bitstream α => α -> α

-- | <i>O(n)</i> Return all the bits of a <a>Bitstream</a> except the last
--   one. An exception will be thrown if empty.
init :: Bitstream α => α -> α

-- | <i>O(1)</i> Test whether a <a>Bitstream</a> is empty.
null :: Bitstream α => α -> Bool

-- | <i>strict: O(1), lazy: O(n)</i> Return the length of a finite
--   <a>Bitstream</a>.
length :: Bitstream α => Num n => α -> n

-- | <i>O(n)</i> Map a function over a <a>Bitstream</a>.
map :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> Reverse a <a>Bitstream</a>.
reverse :: Bitstream α => α -> α

-- | <i>O(n)</i> <a>foldl</a>, applied to a binary operator, a starting
--   value (typically the left-identity of the operator), and a
--   <a>Bitstream</a>, reduces the <a>Bitstream</a> using the binary
--   operator, from left to right:
--   
--   <pre>
--   <a>foldl</a> f z [x1, x2, ..., xn] == (...((z <tt>f</tt> x1) <tt>f</tt> x2) <tt>f</tt>...) <tt>f</tt> xn
--   </pre>
--   
--   The <a>Bitstream</a> must be finite.
foldl :: Bitstream α => (β -> Bool -> β) -> β -> α -> β

-- | <i>O(n)</i> <a>foldl'</a> is a variant of <a>foldl</a> that is strict
--   on the accumulator.
foldl' :: Bitstream α => (β -> Bool -> β) -> β -> α -> β

-- | <i>O(n)</i> <a>foldl1</a> is a variant of <a>foldl</a> that has no
--   starting value argument, and thus must be applied to non-empty
--   <a>Bitstream</a>s.
foldl1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> A strict version of <a>foldl1</a>.
foldl1' :: Bitstream α => (Bool -> Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> <a>foldr</a>, applied to a binary operator, a starting
--   value (typically the right-identity of the operator), and a
--   <a>Bitstream</a>, reduces the <a>Bitstream</a> using the binary
--   operator, from right to left:
--   
--   <pre>
--   <a>foldr</a> f z [x1, x2, ..., xn] == x1 <tt>f</tt> (x2 <tt>f</tt> ... (xn <tt>f</tt> z)...)
--   </pre>
foldr :: Bitstream α => (Bool -> β -> β) -> β -> α -> β

-- | <i>O(n)</i> <a>foldr1</a> is a variant of <a>foldr</a> that has no
--   starting value argument, and thus must be applied to non-empty
--   <a>Bitstream</a>s.
foldr1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> Concatenate all <a>Bitstream</a>s in the list.
concat :: Bitstream α => [α] -> α

-- | Map a function over a <a>Bitstream</a> and concatenate the results.
concatMap :: Bitstream α => (Bool -> α) -> α -> α

-- | <i>O(n)</i> <a>and</a> returns the conjunction of a <a>Bool</a> list.
--   For the result to be <a>True</a>, the <a>Bitstream</a> must be finite;
--   <a>False</a>, however, results from a <a>False</a> value at a finite
--   index of a finite or infinite <a>Bitstream</a>. Note that strict
--   <a>Bitstream</a>s are always finite.
and :: Bitstream α => α -> Bool

-- | <i>O(n)</i> <a>or</a> returns the disjunction of a <a>Bool</a> list.
--   For the result to be <a>False</a>, the <a>Bitstream</a> must be
--   finite; <a>True</a>, however, results from a <a>True</a> value at a
--   finite index of a finite or infinite <a>Bitstream</a>. Note that
--   strict <a>Bitstream</a>s are always finite.
or :: Bitstream α => α -> Bool

-- | <i>O(n)</i> Applied to a predicate and a <a>Bitstream</a>, <a>any</a>
--   determines if any bit of the <a>Bitstream</a> satisfies the predicate.
--   For the result to be <a>False</a>, the <a>Bitstream</a> must be
--   finite; <a>True</a>, however, results from a <a>True</a> value for the
--   predicate applied to a bit at a finite index of a finite or infinite
--   <a>Bitstream</a>.
any :: Bitstream α => (Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> Applied to a predicate and a <a>Bitstream</a>, <a>all</a>
--   determines if all bits of the <a>Bitstream</a> satisfy the predicate.
--   For the result to be <a>True</a>, the <a>Bitstream</a> must be finite;
--   <a>False</a>, however, results from a <a>False</a> value for the
--   predicate applied to a bit at a finite index of a finite or infinite
--   <a>Bitstream</a>.
all :: Bitstream α => (Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   <a>Bitstream</a> of successive reduced bits from the left:
--   
--   <pre>
--   <a>scanl</a> f z [x1, x2, ...] == [z, z <tt>f</tt> x1, (z <tt>f</tt> x1) <tt>f</tt> x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   <a>last</a> (<a>scanl</a> f z xs) == <a>foldl</a> f z xs
--   </pre>
scanl :: Bitstream α => (Bool -> Bool -> Bool) -> Bool -> α -> α

-- | <i>O(n)</i> <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   <a>scanl1</a> f [x1, x2, ...] == [x1, x1 <tt>f</tt> x2, ...]
--   </pre>
scanl1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   <a>head</a> (<a>scanr</a> f z xs) == <a>foldr</a> f z xs
--   </pre>
scanr :: Bitstream α => (Bool -> Bool -> Bool) -> Bool -> α -> α

-- | <i>O(n)</i> <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <tt><a>replicate</a> n x</tt> is a <a>Bitstream</a> of
--   length <tt>n</tt> with <tt>x</tt> the value of every bit.
replicate :: (Integral n, Bitstream α) => n -> Bool -> α

-- | <i>O(n)</i> The <a>unfoldr</a> function is a `dual' to <a>foldr</a>:
--   while <a>foldr</a> reduces a <a>Bitstream</a> to a summary value,
--   <a>unfoldr</a> builds a <a>Bitstream</a> from a seed value. The
--   function takes the element and returns <a>Nothing</a> if it is done
--   producing the <a>Bitstream</a> or returns <a>Just</a> <tt>(a, b)</tt>,
--   in which case, <tt>a</tt> is a prepended to the <a>Bitstream</a> and
--   <tt>b</tt> is used as the next element in a recursive call.
unfoldr :: Bitstream α => (β -> Maybe (Bool, β)) -> β -> α

-- | <i>O(n)</i> <a>unfoldrN</a> is a variant of <a>unfoldr</a> but
--   constructs a <a>Bitstream</a> with at most <tt>n</tt> bits.
unfoldrN :: (Integral n, Bitstream α) => n -> (β -> Maybe (Bool, β)) -> β -> α

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a <a>Bitstream</a>
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: (Integral n, Bitstream α) => n -> α -> α

-- | <i>O(n)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> bits, or <a>empty</a> if <tt>n
--   &gt; <a>length</a> xs</tt>.
drop :: (Integral n, Bitstream α) => n -> α -> α

-- | <i>O(n)</i> <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   <a>Bitstream</a> <tt>xs</tt>, returns the longest prefix (possibly
--   <a>empty</a>) of <tt>xs</tt> of bits that satisfy <tt>p</tt>.
takeWhile :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>dropWhile</a> <tt>p xs</tt> returns the suffix
--   remaining after <a>takeWhile</a> <tt>p xs</tt>.
dropWhile :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>span</a>, applied to a predicate <tt>p</tt> and a
--   <a>Bitstream</a> <tt>xs</tt>, returns a tuple where first element is
--   longest prefix (possibly <a>empty</a>) of <tt>xs</tt> of bits that
--   satisfy <tt>p</tt> and second element is the remainder of the
--   <a>Bitstream</a>.
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: Bitstream α => (Bool -> Bool) -> α -> (α, α)

-- | <i>O(n)</i> <a>break</a>, applied to a predicate <tt>p</tt> and a
--   <a>Bitstream</a> <tt>xs</tt>, returns a tuple where first element is
--   longest prefix (possibly <a>empty</a>) of <tt>xs</tt> of bits that
--   <i>do not satisfy</i> <tt>p</tt> and second element is the remainder
--   of the <a>Bitstream</a>.
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<tt>not</tt>
--   . p)</tt>.
break :: Bitstream α => (Bool -> Bool) -> α -> (α, α)

-- | <i>O(n)</i> <a>elem</a> is the <a>Bitstream</a> membership predicate,
--   usually written in infix form, e.g., <tt>x `elem` xs</tt>. For the
--   result to be <a>False</a>, the <a>Bitstream</a> must be finite;
--   <a>True</a>, however, results from an bit equal to <tt>x</tt> found at
--   a finite index of a finite or infinite <a>Bitstream</a>.
elem :: Bitstream α => Bool -> α -> Bool

-- | (∈) = <a>elem</a>
--   
--   U+2208, ELEMENT OF
(∈) :: Bitstream α => Bool -> α -> Bool

-- | (∋) = <a>flip</a> (∈)
--   
--   U+220B, CONTAINS AS MEMBER
(∋) :: Bitstream α => α -> Bool -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the negation of <a>elem</a>.
notElem :: Bitstream α => Bool -> α -> Bool

-- | (∉) = <a>notElem</a>
--   
--   U+2209, NOT AN ELEMENT OF
(∉) :: Bitstream α => Bool -> α -> Bool

-- | (∌) = <a>flip</a> (∉)
--   
--   U+220C, DOES NOT CONTAIN AS MEMBER
(∌) :: Bitstream α => α -> Bool -> Bool

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>Bitstream</a> and returns the bit in the <a>Bitstream</a> matching
--   the predicate, or <a>Nothing</a> if there is no such bit.
find :: Bitstream α => (Bool -> Bool) -> α -> Maybe Bool

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a
--   <a>Bitstream</a>, returns the <a>Bitstream</a> of those bits that
--   satisfy the predicate.
filter :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> The <a>partition</a> function takes a predicate and a
--   <a>Bitstream</a> and returns the pair of <a>Bitstream</a>s of bits
--   which do and do not satisfy the predicate, respectively.
partition :: Bitstream α => (Bool -> Bool) -> α -> (α, α)

-- | <i>O(n)</i> <a>Bitstream</a> index (subscript) operator, starting from
--   0.
(!!) :: (Bitstream α, Integral n, Show n) => α -> n -> Bool

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first bit in the given <a>Bitstream</a> which is equal to the query
--   bit, or <a>Nothing</a> if there is no such bit.
elemIndex :: (Bitstream α, Integral n) => Bool -> α -> Maybe n

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all bits equal to the query bit, in
--   ascending order.
elemIndices :: (Bitstream α, Integral n) => Bool -> α -> [n]

-- | <i>O(n)</i> The <a>findIndex</a> function takes a predicate and a
--   <a>Bitstream</a> and returns the index of the first bit in the
--   <a>Bitstream</a> satisfying the predicate, or <a>Nothing</a> if there
--   is no such bit.
findIndex :: (Bitstream α, Integral n) => (Bool -> Bool) -> α -> Maybe n

-- | <i>O(n)</i> The <a>findIndices</a> function extends <a>findIndex</a>,
--   by returning the indices of all bits satisfying the predicate, in
--   ascending order.
findIndices :: (Bitstream α, Integral n) => (Bool -> Bool) -> α -> [n]

-- | <i>O(min(m, n))</i> <a>zip</a> takes two <a>Bitstream</a>s and returns
--   a list of corresponding bit pairs. If one input <a>Bitstream</a> is
--   short, excess bits of the longer <a>Bitstream</a> are discarded.
zip :: Bitstream α => α -> α -> [(Bool, Bool)]

-- | The <a>zip3</a> function takes three <a>Bitstream</a>s and returns a
--   list of triples, analogous to <a>zip</a>.
zip3 :: Bitstream α => α -> α -> α -> [(Bool, Bool, Bool)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>.
zip4 :: Bitstream α => α -> α -> α -> α -> [(Bool, Bool, Bool, Bool)]

-- | The <a>zip5</a> function takes five <a>Bitstream</a>s and returns a
--   list of five-tuples, analogous to <a>zip</a>.
zip5 :: Bitstream α => α -> α -> α -> α -> α -> [(Bool, Bool, Bool, Bool, Bool)]

-- | The <a>zip6</a> function takes six <a>Bitstream</a>s and returns a
--   list of six-tuples, analogous to <a>zip</a>.
zip6 :: Bitstream α => α -> α -> α -> α -> α -> α -> [(Bool, Bool, Bool, Bool, Bool, Bool)]

-- | <i>O(min(m, n))</i> <a>zipWith</a> generalises <a>zip</a> by zipping
--   with the function given as the first argument, instead of a tupling
--   function.
zipWith :: Bitstream α => (Bool -> Bool -> β) -> α -> α -> [β]

-- | The <a>zipWith3</a> function takes a function which combines three
--   bits, as well as three <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: Bitstream α => (Bool -> Bool -> Bool -> β) -> α -> α -> α -> [β]

-- | The <a>zipWith4</a> function takes a function which combines four
--   bits, as well as four <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith4 :: Bitstream α => (Bool -> Bool -> Bool -> Bool -> β) -> α -> α -> α -> α -> [β]

-- | The <a>zipWith5</a> function takes a function which combines five
--   bits, as well as five <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith5 :: Bitstream α => (Bool -> Bool -> Bool -> Bool -> Bool -> β) -> α -> α -> α -> α -> α -> [β]

-- | The <a>zipWith6</a> function takes a function which combines six bits,
--   as well as six <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith6 :: Bitstream α => (Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> β) -> α -> α -> α -> α -> α -> α -> [β]

-- | <i>O(min(m, n))</i> <a>unzip</a> transforms a list of bit pairs into a
--   <a>Bitstream</a> of first components and a <a>Bitstream</a> of second
--   components.
unzip :: Bitstream α => [(Bool, Bool)] -> (α, α)

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip3 :: Bitstream α => [(Bool, Bool, Bool)] -> (α, α, α)

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip4 :: Bitstream α => [(Bool, Bool, Bool, Bool)] -> (α, α, α, α)

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip5 :: Bitstream α => [(Bool, Bool, Bool, Bool, Bool)] -> (α, α, α, α, α)

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip6 :: Bitstream α => [(Bool, Bool, Bool, Bool, Bool, Bool)] -> (α, α, α, α, α, α)

-- | <i>O(n)</i> Read a <a>Bitstream</a> from the stdin strictly,
--   equivalent to <a>hGetContents</a> <tt>stdin</tt>. The <a>Handle</a> is
--   closed after the contents have been read.
getContents :: Bitstream (Packet d) => IO (Bitstream d)

-- | <i>O(n)</i> Write a <a>Bitstream</a> to the stdout, equivalent to
--   <a>hPut</a> <tt>stdout</tt>.
putBits :: (Bitstream (Bitstream d), Bitstream (Packet d)) => Bitstream d -> IO ()

-- | The <a>interact</a> function takes a function of type
--   <tt><a>Bitstream</a> d -&gt; <a>Bitstream</a> d</tt> as its argument.
--   The entire input from the stdin is passed to this function as its
--   argument, and the resulting <a>Bitstream</a> is output on the stdout.
interact :: (Bitstream (Bitstream d), Bitstream (Packet d)) => (Bitstream d -> Bitstream d) -> IO ()

-- | <i>O(n)</i> Read an entire file strictly into a <a>Bitstream</a>.
readFile :: Bitstream (Packet d) => FilePath -> IO (Bitstream d)

-- | <i>O(n)</i> Write a <a>Bitstream</a> to a file.
writeFile :: (Bitstream (Bitstream d), Bitstream (Packet d)) => FilePath -> Bitstream d -> IO ()

-- | <i>O(n)</i> Append a <a>Bitstream</a> to a file.
appendFile :: (Bitstream (Bitstream d), Bitstream (Packet d)) => FilePath -> Bitstream d -> IO ()

-- | <i>O(n)</i> Read entire handle contents strictly into a
--   <a>Bitstream</a>.
--   
--   This function reads chunks at a time, doubling the chunksize on each
--   read. The final buffer is then realloced to the appropriate size. For
--   files &gt; half of available memory, this may lead to memory
--   exhaustion. Consider using <a>readFile</a> in this case.
--   
--   The <a>Handle</a> is closed once the contents have been read, or if an
--   exception is thrown.
hGetContents :: Bitstream (Packet d) => Handle -> IO (Bitstream d)

-- | <i>O(n)</i> <tt><a>hGet</a> h n</tt> reads a <a>Bitstream</a> directly
--   from the specified <a>Handle</a> <tt>h</tt>. First argument <tt>h</tt>
--   is the <a>Handle</a> to read from, and the second <tt>n</tt> is the
--   number of <i>octets</i> to read, not <i>bits</i>. It returns the
--   octets read, up to <tt>n</tt>, or null if EOF has been reached.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGet</a> will behave as if EOF was reached.
hGet :: Bitstream (Packet d) => Handle -> Int -> IO (Bitstream d)

-- | <i>O(n)</i> Like <a>hGet</a>, except that a shorter <a>Bitstream</a>
--   may be returned if there are not enough octets immediately available
--   to satisfy the whole request. <a>hGetSome</a> only blocks if there is
--   no data available, and EOF has not yet been reached.
hGetSome :: Bitstream (Packet d) => Handle -> Int -> IO (Bitstream d)

-- | <i>O(n)</i> <a>hGetNonBlocking</a> is similar to <a>hGet</a>, except
--   that it will never block waiting for data to become available. If
--   there is no data available to be read, <a>hGetNonBlocking</a> returns
--   <a>empty</a>.
hGetNonBlocking :: Bitstream (Packet d) => Handle -> Int -> IO (Bitstream d)

-- | <i>O(n)</i> Write a <a>Bitstream</a> to the given <a>Handle</a>.
hPut :: (Bitstream (Bitstream d), Bitstream (Packet d)) => Handle -> Bitstream d -> IO ()
instance Bitstream (Bitstream Right)
instance Bitstream (Bitstream Left)
instance Bitstream (Bitstream d) => Monoid (Bitstream d)
instance Bitstream (Bitstream d) => Ord (Bitstream d)
instance Bitstream (Bitstream d) => Eq (Bitstream d)
instance Show (Packet d) => Show (Bitstream d)


-- | Fast, packed, lazy bit streams (i.e. list of <a>Bool</a>s) with
--   semi-automatic stream fusion.
--   
--   This module is intended to be imported <tt>qualified</tt>, to avoid
--   name clashes with <a>Prelude</a> functions. e.g.
--   
--   <pre>
--   import qualified Data.BitStream.Lazy as LS
--   </pre>
--   
--   Lazy <a>Bitstream</a>s are made of possibly infinite list of strict
--   <a>Bitstream</a>s as chunks, and each chunks have at least 1 bit.
module Data.Bitstream.Lazy

-- | A space-efficient representation of a <a>Bool</a> vector, supporting
--   many efficient operations. <a>Bitstream</a>s have an idea of
--   <i>directions</i> controlling how octets are interpreted as bits.
--   There are two types of concrete <a>Bitstream</a>s:
--   <tt><a>Bitstream</a> <a>Left</a></tt> and <tt><a>Bitstream</a>
--   <a>Right</a></tt>.
data Bitstream d

-- | <a>Left</a> bitstreams interpret an octet as a vector of bits whose
--   LSB comes first and MSB comes last e.g.
--   
--   <ul>
--   <li>11110000 =&gt; [False, False, False, False, True, True , True ,
--   True]</li>
--   <li>10010100 =&gt; [False, False, True , False, True, False, False,
--   True]</li>
--   </ul>
--   
--   <a>Bits</a> operations (like <a>toBits</a>) treat a <a>Left</a>
--   bitstream as a little-endian integer.
data Left

-- | <a>Right</a> bitstreams interpret an octet as a vector of bits whose
--   MSB comes first and LSB comes last e.g.
--   
--   <ul>
--   <li>11110000 =&gt; [True, True , True , True, False, False, False,
--   False]</li>
--   <li>10010100 =&gt; [True, False, False, True, False, True , False,
--   False]</li>
--   </ul>
--   
--   <a>Bits</a> operations (like <a>toBits</a>) treat a <a>Right</a>
--   bitstream as a big-endian integer.
data Right

-- | <i>O(1)</i> The empty <a>Bitstream</a>.
empty :: Bitstream α => α

-- | (∅) = <a>empty</a>
--   
--   U+2205, EMPTY SET
(∅) :: Bitstream α => α

-- | <i>O(1)</i> Convert a <a>Bool</a> into a <a>Bitstream</a>.
singleton :: Bitstream α => Bool -> α

-- | <i>O(n)</i> Convert a [<a>Bool</a>] into a <a>Bitstream</a>.
pack :: Bitstream α => [Bool] -> α

-- | <i>O(n)</i> Convert a <a>Bitstream</a> into a [<a>Bool</a>].
unpack :: Bitstream α => α -> [Bool]

-- | <i>O(n)</i> Convert a list of chunks, strict <a>Bitstream</a>s, into a
--   lazy <a>Bitstream</a>.
fromChunks :: Bitstream (Bitstream d) => [Bitstream d] -> Bitstream d

-- | <i>O(n)</i> Convert a lazy <a>Bitstream</a> into a list of chunks,
--   strict <a>Bitstream</a>s.
toChunks :: Bitstream d -> [Bitstream d]

-- | <i>O(n)</i> Convert a lazy <a>ByteString</a> into a lazy
--   <a>Bitstream</a>.
fromByteString :: Bitstream (Bitstream d) => ByteString -> Bitstream d

-- | <i>O(n)</i> <tt><a>toByteString</a> bits</tt> converts a lazy
--   <a>Bitstream</a> <tt>bits</tt> into a lazy <a>ByteString</a>. The
--   resulting octets will be padded with zeroes if <tt>bs</tt> is finite
--   and its <a>length</a> is not multiple of 8.
toByteString :: (Bitstream (Bitstream d), Bitstream (Packet d)) => Bitstream d -> ByteString

-- | <i>O(n)</i> Convert a <a>FiniteBits</a> into a <a>Bitstream</a>.
fromBits :: (Integral β, FiniteBits β, Bitstream α) => β -> α

-- | <i>O(n)</i> Convert the lower <tt>n</tt> bits of the given
--   <a>Bits</a>. In the case that more bits are requested than the
--   <a>Bits</a> provides, this acts as if the <a>Bits</a> has an infinite
--   number of leading 0 bits.
fromNBits :: (Integral n, Integral β, Bits β, Bitstream α) => n -> β -> α

-- | <i>O(n)</i> Convert a <a>Bitstream</a> into a <a>Bits</a>.
toBits :: (Bitstream α, Integral β, Bits β) => α -> β

-- | <i>O(n)</i> Explicitly convert a <a>Bitstream</a> into a <a>Stream</a>
--   of <a>Bool</a>.
--   
--   <a>Bitstream</a> operations are automatically fused whenever it's
--   possible, safe, and effective to do so, but sometimes you may find the
--   rules are too conservative. These two functions <a>stream</a> and
--   <a>unstream</a> provide a means for coercive stream fusion.
--   
--   You should be careful when you use <a>stream</a>. Most functions in
--   this package are optimised to minimise frequency of memory allocations
--   and copyings, but getting <a>Bitstream</a>s back from
--   <tt><a>Stream</a> <a>Bool</a></tt> requires the whole <a>Bitstream</a>
--   to be constructed from scratch. Moreover, for lazy <a>Bitstream</a>s
--   this leads to be an incorrect strictness behaviour because lazy
--   <a>Bitstream</a>s are represented as lists of strict <a>Bitstream</a>
--   chunks but <a>stream</a> can't preserve the original chunk structure.
--   Let's say you have a lazy <a>Bitstream</a> with the following chunks:
--   
--   <pre>
--   bs = [chunk1, chunk2, chunk3, ...]
--   </pre>
--   
--   and you want to drop the first bit of such stream. Our <a>tail</a> is
--   only strict on the <tt>chunk1</tt> and will produce the following
--   chunks:
--   
--   <pre>
--   <a>tail</a> bs = [chunk0, chunk1', chunk2, chunk3, ...]
--   </pre>
--   
--   where <tt>chunk0</tt> is a singleton vector of the first packet of
--   <tt>chunk1</tt> whose first bit is dropped, and <tt>chunk1'</tt> is a
--   vector of remaining packets of the <tt>chunk1</tt>. Neither
--   <tt>chunk2</tt> nor <tt>chunk3</tt> have to be evaluated here as you
--   might expect.
--   
--   But think about the following expression:
--   
--   <pre>
--   import qualified Data.Vector.Fusion.Stream as Stream
--   <a>unstream</a> $ Stream.tail $ <a>stream</a> bs
--   </pre>
--   
--   the resulting chunk structure will be:
--   
--   <pre>
--   [chunk1', chunk2', chunk3', ...]
--   </pre>
--   
--   where each and every chunks are slightly different from the original
--   chunks, and this time <tt>chunk1'</tt> has the same length as
--   <tt>chunk1</tt> but the last bit of <tt>chunk1'</tt> is from the first
--   bit of <tt>chunk2</tt>. This means when you next time apply some
--   functions strict on the first chunk, you end up fully evaluating
--   <tt>chunk2</tt> as well as <tt>chunk1</tt> and this can be a serious
--   misbehaviour for lazy <a>Bitstream</a>s.
--   
--   The automatic fusion rules are carefully designed to fire only when
--   there aren't any reason to preserve the original packet / chunk
--   structure.
stream :: Bitstream α => α -> Stream Bool

-- | <i>O(n)</i> Convert a <a>Stream</a> of <a>Bool</a> into a
--   <a>Bitstream</a>.
unstream :: Bitstream α => Stream Bool -> α

-- | <i>O(n)</i> Convert a <tt><a>Bitstream</a> <a>Left</a></tt> into a
--   <tt><a>Bitstream</a> <a>Right</a></tt>. Bit directions only affect
--   octet-based operations such as <a>toByteString</a>.
directionLToR :: Bitstream Left -> Bitstream Right

-- | <i>O(n)</i> Convert a <tt><a>Bitstream</a> <a>Right</a></tt> into a
--   <tt><a>Bitstream</a> <a>Left</a></tt>. Bit directions only affect
--   octet-based operations such as <a>toByteString</a>.
directionRToL :: Bitstream Right -> Bitstream Left

-- | <i>strict: O(n), lazy: O(1)</i> <a>cons</a> is an analogous to
--   (<tt>:</tt>) for lists.
cons :: Bitstream α => Bool -> α -> α

-- | <i>O(n)</i> For strict <a>Bitstream</a>s, <a>cons'</a> is exactly the
--   same as <a>cons</a>.
--   
--   For lazy ones, <a>cons'</a> is strict in the <a>Bitstream</a> we are
--   consing onto. More precisely, it forces the first chunk to be
--   evaluated. It does this because, for space efficiency, it may coalesce
--   the new bit onto the first chunk rather than starting a new chunk.
cons' :: Bitstream α => Bool -> α -> α

-- | <i>O(n)</i> Append a bit to the end of a <a>Bitstream</a>.
snoc :: Bitstream α => α -> Bool -> α

-- | <i>O(n)</i> Append two <a>Bitstream</a>s.
append :: Bitstream α => α -> α -> α

-- | (⧺) = <a>append</a>
--   
--   U+29FA, DOUBLE PLUS
(⧺) :: Bitstream α => α -> α -> α

-- | <i>O(1)</i> Extract the first bit of a non-empty <a>Bitstream</a>. An
--   exception will be thrown if empty.
head :: Bitstream α => α -> Bool

-- | <i>strict: O(1), lazy: O(n)</i> Extract the last bit of a finite
--   <a>Bitstream</a>. An exception will be thrown if empty.
last :: Bitstream α => α -> Bool

-- | <i>O(1)</i> Extract the bits after the <a>head</a> of a non-empty
--   <a>Bitstream</a>. An exception will be thrown if empty.
tail :: Bitstream α => α -> α

-- | <i>O(n)</i> Return all the bits of a <a>Bitstream</a> except the last
--   one. An exception will be thrown if empty.
init :: Bitstream α => α -> α

-- | <i>O(1)</i> Test whether a <a>Bitstream</a> is empty.
null :: Bitstream α => α -> Bool

-- | <i>strict: O(1), lazy: O(n)</i> Return the length of a finite
--   <a>Bitstream</a>.
length :: Bitstream α => Num n => α -> n

-- | <i>O(n)</i> Map a function over a <a>Bitstream</a>.
map :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> Reverse a <a>Bitstream</a>.
reverse :: Bitstream α => α -> α

-- | <i>O(n)</i> <a>foldl</a>, applied to a binary operator, a starting
--   value (typically the left-identity of the operator), and a
--   <a>Bitstream</a>, reduces the <a>Bitstream</a> using the binary
--   operator, from left to right:
--   
--   <pre>
--   <a>foldl</a> f z [x1, x2, ..., xn] == (...((z <tt>f</tt> x1) <tt>f</tt> x2) <tt>f</tt>...) <tt>f</tt> xn
--   </pre>
--   
--   The <a>Bitstream</a> must be finite.
foldl :: Bitstream α => (β -> Bool -> β) -> β -> α -> β

-- | <i>O(n)</i> <a>foldl'</a> is a variant of <a>foldl</a> that is strict
--   on the accumulator.
foldl' :: Bitstream α => (β -> Bool -> β) -> β -> α -> β

-- | <i>O(n)</i> <a>foldl1</a> is a variant of <a>foldl</a> that has no
--   starting value argument, and thus must be applied to non-empty
--   <a>Bitstream</a>s.
foldl1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> A strict version of <a>foldl1</a>.
foldl1' :: Bitstream α => (Bool -> Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> <a>foldr</a>, applied to a binary operator, a starting
--   value (typically the right-identity of the operator), and a
--   <a>Bitstream</a>, reduces the <a>Bitstream</a> using the binary
--   operator, from right to left:
--   
--   <pre>
--   <a>foldr</a> f z [x1, x2, ..., xn] == x1 <tt>f</tt> (x2 <tt>f</tt> ... (xn <tt>f</tt> z)...)
--   </pre>
foldr :: Bitstream α => (Bool -> β -> β) -> β -> α -> β

-- | <i>O(n)</i> <a>foldr1</a> is a variant of <a>foldr</a> that has no
--   starting value argument, and thus must be applied to non-empty
--   <a>Bitstream</a>s.
foldr1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> Concatenate all <a>Bitstream</a>s in the list.
concat :: Bitstream α => [α] -> α

-- | Map a function over a <a>Bitstream</a> and concatenate the results.
concatMap :: Bitstream α => (Bool -> α) -> α -> α

-- | <i>O(n)</i> <a>and</a> returns the conjunction of a <a>Bool</a> list.
--   For the result to be <a>True</a>, the <a>Bitstream</a> must be finite;
--   <a>False</a>, however, results from a <a>False</a> value at a finite
--   index of a finite or infinite <a>Bitstream</a>. Note that strict
--   <a>Bitstream</a>s are always finite.
and :: Bitstream α => α -> Bool

-- | <i>O(n)</i> <a>or</a> returns the disjunction of a <a>Bool</a> list.
--   For the result to be <a>False</a>, the <a>Bitstream</a> must be
--   finite; <a>True</a>, however, results from a <a>True</a> value at a
--   finite index of a finite or infinite <a>Bitstream</a>. Note that
--   strict <a>Bitstream</a>s are always finite.
or :: Bitstream α => α -> Bool

-- | <i>O(n)</i> Applied to a predicate and a <a>Bitstream</a>, <a>any</a>
--   determines if any bit of the <a>Bitstream</a> satisfies the predicate.
--   For the result to be <a>False</a>, the <a>Bitstream</a> must be
--   finite; <a>True</a>, however, results from a <a>True</a> value for the
--   predicate applied to a bit at a finite index of a finite or infinite
--   <a>Bitstream</a>.
any :: Bitstream α => (Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> Applied to a predicate and a <a>Bitstream</a>, <a>all</a>
--   determines if all bits of the <a>Bitstream</a> satisfy the predicate.
--   For the result to be <a>True</a>, the <a>Bitstream</a> must be finite;
--   <a>False</a>, however, results from a <a>False</a> value for the
--   predicate applied to a bit at a finite index of a finite or infinite
--   <a>Bitstream</a>.
all :: Bitstream α => (Bool -> Bool) -> α -> Bool

-- | <i>O(n)</i> <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   <a>Bitstream</a> of successive reduced bits from the left:
--   
--   <pre>
--   <a>scanl</a> f z [x1, x2, ...] == [z, z <tt>f</tt> x1, (z <tt>f</tt> x1) <tt>f</tt> x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   <a>last</a> (<a>scanl</a> f z xs) == <a>foldl</a> f z xs
--   </pre>
scanl :: Bitstream α => (Bool -> Bool -> Bool) -> Bool -> α -> α

-- | <i>O(n)</i> <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   <a>scanl1</a> f [x1, x2, ...] == [x1, x1 <tt>f</tt> x2, ...]
--   </pre>
scanl1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   <a>head</a> (<a>scanr</a> f z xs) == <a>foldr</a> f z xs
--   </pre>
scanr :: Bitstream α => (Bool -> Bool -> Bool) -> Bool -> α -> α

-- | <i>O(n)</i> <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: Bitstream α => (Bool -> Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>iterate</a> <tt>f x</tt> returns an infinite
--   <a>Bitstream</a> of repeated applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   <a>iterate</a> f x == [x, f x, f (f x), ...]
--   </pre>
iterate :: Bitstream (Packet d) => (Bool -> Bool) -> Bool -> Bitstream d

-- | <i>O(n)</i> <a>repeat</a> <tt>x</tt> is an infinite <a>Bitstream</a>,
--   with <tt>x</tt> the value of every bits.
repeat :: Bitstream (Packet d) => Bool -> Bitstream d

-- | <i>O(n)</i> <tt><a>replicate</a> n x</tt> is a <a>Bitstream</a> of
--   length <tt>n</tt> with <tt>x</tt> the value of every bit.
replicate :: (Integral n, Bitstream α) => n -> Bool -> α

-- | <i>O(n)</i> <a>cycle</a> ties a finite <a>Bitstream</a> into a
--   circular one, or equivalently, the infinite repetition of the original
--   <a>Bitstream</a>. It is the identity on infinite <a>Bitstream</a>s.
cycle :: Bitstream (Bitstream d) => Bitstream d -> Bitstream d

-- | <i>O(n)</i> The <a>unfoldr</a> function is a `dual' to <a>foldr</a>:
--   while <a>foldr</a> reduces a <a>Bitstream</a> to a summary value,
--   <a>unfoldr</a> builds a <a>Bitstream</a> from a seed value. The
--   function takes the element and returns <a>Nothing</a> if it is done
--   producing the <a>Bitstream</a> or returns <a>Just</a> <tt>(a, b)</tt>,
--   in which case, <tt>a</tt> is a prepended to the <a>Bitstream</a> and
--   <tt>b</tt> is used as the next element in a recursive call.
unfoldr :: Bitstream α => (β -> Maybe (Bool, β)) -> β -> α

-- | <i>O(n)</i> <a>unfoldrN</a> is a variant of <a>unfoldr</a> but
--   constructs a <a>Bitstream</a> with at most <tt>n</tt> bits.
unfoldrN :: (Integral n, Bitstream α) => n -> (β -> Maybe (Bool, β)) -> β -> α

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a <a>Bitstream</a>
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: (Integral n, Bitstream α) => n -> α -> α

-- | <i>O(n)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> bits, or <a>empty</a> if <tt>n
--   &gt; <a>length</a> xs</tt>.
drop :: (Integral n, Bitstream α) => n -> α -> α

-- | <i>O(n)</i> <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   <a>Bitstream</a> <tt>xs</tt>, returns the longest prefix (possibly
--   <a>empty</a>) of <tt>xs</tt> of bits that satisfy <tt>p</tt>.
takeWhile :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>dropWhile</a> <tt>p xs</tt> returns the suffix
--   remaining after <a>takeWhile</a> <tt>p xs</tt>.
dropWhile :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> <a>span</a>, applied to a predicate <tt>p</tt> and a
--   <a>Bitstream</a> <tt>xs</tt>, returns a tuple where first element is
--   longest prefix (possibly <a>empty</a>) of <tt>xs</tt> of bits that
--   satisfy <tt>p</tt> and second element is the remainder of the
--   <a>Bitstream</a>.
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: Bitstream α => (Bool -> Bool) -> α -> (α, α)

-- | <i>O(n)</i> <a>break</a>, applied to a predicate <tt>p</tt> and a
--   <a>Bitstream</a> <tt>xs</tt>, returns a tuple where first element is
--   longest prefix (possibly <a>empty</a>) of <tt>xs</tt> of bits that
--   <i>do not satisfy</i> <tt>p</tt> and second element is the remainder
--   of the <a>Bitstream</a>.
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<tt>not</tt>
--   . p)</tt>.
break :: Bitstream α => (Bool -> Bool) -> α -> (α, α)

-- | <i>O(n)</i> <a>elem</a> is the <a>Bitstream</a> membership predicate,
--   usually written in infix form, e.g., <tt>x `elem` xs</tt>. For the
--   result to be <a>False</a>, the <a>Bitstream</a> must be finite;
--   <a>True</a>, however, results from an bit equal to <tt>x</tt> found at
--   a finite index of a finite or infinite <a>Bitstream</a>.
elem :: Bitstream α => Bool -> α -> Bool

-- | (∈) = <a>elem</a>
--   
--   U+2208, ELEMENT OF
(∈) :: Bitstream α => Bool -> α -> Bool

-- | (∋) = <a>flip</a> (∈)
--   
--   U+220B, CONTAINS AS MEMBER
(∋) :: Bitstream α => α -> Bool -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the negation of <a>elem</a>.
notElem :: Bitstream α => Bool -> α -> Bool

-- | (∉) = <a>notElem</a>
--   
--   U+2209, NOT AN ELEMENT OF
(∉) :: Bitstream α => Bool -> α -> Bool

-- | (∌) = <a>flip</a> (∉)
--   
--   U+220C, DOES NOT CONTAIN AS MEMBER
(∌) :: Bitstream α => α -> Bool -> Bool

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>Bitstream</a> and returns the bit in the <a>Bitstream</a> matching
--   the predicate, or <a>Nothing</a> if there is no such bit.
find :: Bitstream α => (Bool -> Bool) -> α -> Maybe Bool

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a
--   <a>Bitstream</a>, returns the <a>Bitstream</a> of those bits that
--   satisfy the predicate.
filter :: Bitstream α => (Bool -> Bool) -> α -> α

-- | <i>O(n)</i> The <a>partition</a> function takes a predicate and a
--   <a>Bitstream</a> and returns the pair of <a>Bitstream</a>s of bits
--   which do and do not satisfy the predicate, respectively.
partition :: Bitstream α => (Bool -> Bool) -> α -> (α, α)

-- | <i>O(n)</i> <a>Bitstream</a> index (subscript) operator, starting from
--   0.
(!!) :: (Bitstream α, Integral n, Show n) => α -> n -> Bool

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first bit in the given <a>Bitstream</a> which is equal to the query
--   bit, or <a>Nothing</a> if there is no such bit.
elemIndex :: (Bitstream α, Integral n) => Bool -> α -> Maybe n

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all bits equal to the query bit, in
--   ascending order.
elemIndices :: (Bitstream α, Integral n) => Bool -> α -> [n]

-- | <i>O(n)</i> The <a>findIndex</a> function takes a predicate and a
--   <a>Bitstream</a> and returns the index of the first bit in the
--   <a>Bitstream</a> satisfying the predicate, or <a>Nothing</a> if there
--   is no such bit.
findIndex :: (Bitstream α, Integral n) => (Bool -> Bool) -> α -> Maybe n

-- | <i>O(n)</i> The <a>findIndices</a> function extends <a>findIndex</a>,
--   by returning the indices of all bits satisfying the predicate, in
--   ascending order.
findIndices :: (Bitstream α, Integral n) => (Bool -> Bool) -> α -> [n]

-- | <i>O(min(m, n))</i> <a>zip</a> takes two <a>Bitstream</a>s and returns
--   a list of corresponding bit pairs. If one input <a>Bitstream</a> is
--   short, excess bits of the longer <a>Bitstream</a> are discarded.
zip :: Bitstream α => α -> α -> [(Bool, Bool)]

-- | The <a>zip3</a> function takes three <a>Bitstream</a>s and returns a
--   list of triples, analogous to <a>zip</a>.
zip3 :: Bitstream α => α -> α -> α -> [(Bool, Bool, Bool)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>.
zip4 :: Bitstream α => α -> α -> α -> α -> [(Bool, Bool, Bool, Bool)]

-- | The <a>zip5</a> function takes five <a>Bitstream</a>s and returns a
--   list of five-tuples, analogous to <a>zip</a>.
zip5 :: Bitstream α => α -> α -> α -> α -> α -> [(Bool, Bool, Bool, Bool, Bool)]

-- | The <a>zip6</a> function takes six <a>Bitstream</a>s and returns a
--   list of six-tuples, analogous to <a>zip</a>.
zip6 :: Bitstream α => α -> α -> α -> α -> α -> α -> [(Bool, Bool, Bool, Bool, Bool, Bool)]

-- | <i>O(min(m, n))</i> <a>zipWith</a> generalises <a>zip</a> by zipping
--   with the function given as the first argument, instead of a tupling
--   function.
zipWith :: Bitstream α => (Bool -> Bool -> β) -> α -> α -> [β]

-- | The <a>zipWith3</a> function takes a function which combines three
--   bits, as well as three <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: Bitstream α => (Bool -> Bool -> Bool -> β) -> α -> α -> α -> [β]

-- | The <a>zipWith4</a> function takes a function which combines four
--   bits, as well as four <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith4 :: Bitstream α => (Bool -> Bool -> Bool -> Bool -> β) -> α -> α -> α -> α -> [β]

-- | The <a>zipWith5</a> function takes a function which combines five
--   bits, as well as five <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith5 :: Bitstream α => (Bool -> Bool -> Bool -> Bool -> Bool -> β) -> α -> α -> α -> α -> α -> [β]

-- | The <a>zipWith6</a> function takes a function which combines six bits,
--   as well as six <a>Bitstream</a>s and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith6 :: Bitstream α => (Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> β) -> α -> α -> α -> α -> α -> α -> [β]

-- | <i>O(min(m, n))</i> <a>unzip</a> transforms a list of bit pairs into a
--   <a>Bitstream</a> of first components and a <a>Bitstream</a> of second
--   components.
unzip :: Bitstream α => [(Bool, Bool)] -> (α, α)

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip3 :: Bitstream α => [(Bool, Bool, Bool)] -> (α, α, α)

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip4 :: Bitstream α => [(Bool, Bool, Bool, Bool)] -> (α, α, α, α)

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip5 :: Bitstream α => [(Bool, Bool, Bool, Bool, Bool)] -> (α, α, α, α, α)

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   <a>Bitstream</a>s, analogous to <a>unzip</a>.
unzip6 :: Bitstream α => [(Bool, Bool, Bool, Bool, Bool, Bool)] -> (α, α, α, α, α, α)

-- | <i>O(n)</i> <a>getContents</a> is equivalent to <a>hGetContents</a>
--   <tt>stdin</tt>. Will read <i>lazily</i>.
getContents :: Bitstream (Bitstream d) => IO (Bitstream d)

-- | <i>O(n)</i> Write a <a>Bitstream</a> to <tt>stdout</tt>, equivalent to
--   <a>hPut</a> <tt>stdout</tt>.
putBits :: (Bitstream (Bitstream d), Bitstream (Packet d)) => Bitstream d -> IO ()

-- | The <a>interact</a> function takes a function of type
--   <tt><a>Bitstream</a> d -&gt; <a>Bitstream</a> d</tt> as its argument.
--   The entire input from the stdin is lazily passed to this function as
--   its argument, and the resulting <a>Bitstream</a> is output on the
--   stdout.
interact :: (Bitstream (Bitstream d), Bitstream (Packet d)) => (Bitstream d -> Bitstream d) -> IO ()

-- | <i>O(n)</i> Read an entire file lazily into a <a>Bitstream</a>.
readFile :: Bitstream (Bitstream d) => FilePath -> IO (Bitstream d)

-- | <i>O(n)</i> Write a <a>Bitstream</a> to a file.
writeFile :: (Bitstream (Bitstream d), Bitstream (Packet d)) => FilePath -> Bitstream d -> IO ()

-- | <i>O(n)</i> Append a <a>Bitstream</a> to a file.
appendFile :: (Bitstream (Bitstream d), Bitstream (Packet d)) => FilePath -> Bitstream d -> IO ()

-- | <i>O(n)</i> Read entire handle contents <i>lazily</i> into a
--   <a>Bitstream</a>. Chunks are read on demand, using the default chunk
--   size.
--   
--   Once EOF is encountered, the <a>Handle</a> is closed.
hGetContents :: Bitstream (Bitstream d) => Handle -> IO (Bitstream d)

-- | <tt><a>hGet</a> h n</tt> reads a <a>Bitstream</a> directly from the
--   specified <a>Handle</a> <tt>h</tt>. First argument <tt>h</tt> is the
--   <a>Handle</a> to read from, and the second <tt>n</tt> is the number of
--   <i>octets</i> to read, not <i>bits</i>. It returns the octets read, up
--   to <tt>n</tt>, or null if EOF has been reached.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGet</a> will behave as if EOF was reached.
hGet :: Bitstream (Bitstream d) => Handle -> Int -> IO (Bitstream d)

-- | <i>O(n)</i> <a>hGetNonBlocking</a> is similar to <a>hGet</a>, except
--   that it will never block waiting for data to become available, instead
--   it returns only whatever data is available.
hGetNonBlocking :: (Bitstream (Bitstream d), Bitstream (Packet d)) => Handle -> Int -> IO (Bitstream d)

-- | <i>O(n)</i> Write a <a>Bitstream</a> to the given <a>Handle</a>.
hPut :: (Bitstream (Bitstream d), Bitstream (Packet d)) => Handle -> Bitstream d -> IO ()
instance Bitstream (Bitstream Right)
instance Bitstream (Bitstream Left)
instance Bitstream (Bitstream d) => Monoid (Bitstream d)
instance Bitstream (Bitstream d) => Ord (Bitstream d)
instance Bitstream (Bitstream d) => Eq (Bitstream d)
instance Show (Packet d) => Show (Bitstream d)
