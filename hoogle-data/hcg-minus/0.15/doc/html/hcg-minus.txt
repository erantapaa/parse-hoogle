-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | haskell cg (minus)
--   
@package hcg-minus
@version 0.15


-- | Colour related functions
module Data.CG.Minus.Colour

-- | Opaque colour.
type C = Colour Double

-- | Colour with <i>alpha</i> channel.
type Ca = AlphaColour Double

-- | Grey <a>Colour</a>.
mk_grey :: (Ord a, Floating a) => a -> Colour a

-- | Reduce <a>Colour</a> to grey. Constants are <tt>0.3</tt>,
--   <tt>0.59</tt> and <tt>0.11</tt>.
to_greyscale :: (Ord a, Floating a) => Colour a -> a

-- | <a>mk_grey</a> <a>.</a> <a>to_greyscale</a>.
to_greyscale_c :: (Ord a, Floating a) => Colour a -> Colour a

-- | Discard <i>alpha</i> channel, if possible.
pureColour :: (Ord a, Fractional a) => AlphaColour a -> Colour a

-- | Tuple to <a>C</a>, inverse of <a>unC</a>.
toC :: (Double, Double, Double) -> C

-- | <a>C</a> to <i>(red,green,blue)</i> tuple.
unC :: C -> (Double, Double, Double)

-- | Tuple to <a>Ca</a>, inverse of <a>unCa</a>.
toCa :: (Double, Double, Double, Double) -> Ca

-- | <a>Ca</a> to <i>(red,green,blue,alpha)</i> tuple
unCa :: Ca -> (Double, Double, Double, Double)

-- | Venetian red (<tt>#c80815</tt>).
venetianRed :: C

-- | Swedish azure blue (<tt>#005b99</tt>).
swedishAzureBlue :: C

-- | Safety orange (<tt>#ff6600</tt>).
safetyOrange :: C

-- | Dye magenta (<tt>#ca1f7b</tt>).
dyeMagenta :: C

-- | Candlelight yellow (<tt>#fcd116</tt>).
candlelightYellow :: C

-- | Subtractive primary cyan (<tt>#00B7EB</tt>).
subtractivePrimaryCyan :: C

-- | Fern green (<tt>#009246</tt>).
fernGreen :: C

-- | Sepia brown (<tt>#704214</tt>).
sepiaBrown :: C

-- | The set of named colours defined in this module.
non_svg_colour_set :: [C]

-- | The set of named colours in the <tt>SVG</tt> specification (in
--   alphabetical order).
svg_colour_set :: [C]


-- | Planck radiation equation.
module Data.CG.Minus.Colour.Planck

-- | Given wavelength (in microns) and temperature (in degrees Kelvin)
--   solve Planck's radiation equation.
--   
--   <pre>
--   planck_rad_eq 0.7 2600 == 8.22656629154115e7
--   </pre>
planck_rad_eq :: Floating a => a -> a -> a

-- | Return the color of a black body emitting light at a given
--   temperature. The Planck radiation equation is solved directly for the
--   <tt>R</tt>, <tt>G</tt>, and <tt>B</tt> wavelengths defined for the CIE
--   1931 Standard Colorimetric Observer. The colour temperature is
--   specified in degrees Kelvin. Typical constraints for star temperatures
--   are <tt>&gt;=</tt> 2600<tt>K</tt> (<i>S Cephei, R Andromedae</i>) and
--   <tt>&lt;=</tt> 28,000<tt>K</tt> (<i>Spica</i>).
--   
--   <pre>
--   let h (r,g,b) = let f = floor . (*) 255 in (f r,f g,f b)
--   in map (h . k_to_rgb) [2600,28000] == [(255,95,22),(49,118,254)]
--   </pre>
k_to_rgb :: (Floating t, Ord t) => t -> (t, t, t)

-- | <a>toC</a> <a>.</a> <a>k_to_rgb</a>.
k_to_colour :: Double -> C


-- | CG library (minus).
module Data.CG.Minus

-- | Two-dimensional point.
--   
--   Pt are <a>Num</a>, pointwise, ie:
--   
--   <pre>
--   Pt 1 2 + Pt 3 4 == Pt 4 6
--   Pt 1 2 * Pt 3 4 == Pt 3 8
--   negate (Pt 0 1) == Pt 0 (-1)
--   abs (Pt (-1) 1) == Pt 1 1
--   signum (Pt (-1/2) (1/2)) == Pt (-1) 1
--   </pre>
data Pt a
Pt :: a -> a -> Pt a
pt_x :: Pt a -> a
pt_y :: Pt a -> a

-- | Two-dimensional vector. Vector are <a>Num</a> in the same manner as
--   <a>Pt</a>.
data Vc a
Vc :: a -> a -> Vc a
vc_x :: Vc a -> a
vc_y :: Vc a -> a

-- | Two-dimensional line.
data Ln a
Ln :: Pt a -> Pt a -> Ln a
ln_start :: Ln a -> Pt a
ln_end :: Ln a -> Pt a

-- | Line segments.
type Ls a = [Pt a]

-- | Window, given by a <i>lower left</i> <a>Pt</a> and an <i>extent</i>
--   <a>Vc</a>.
data Wn a
Wn :: Pt a -> Vc a -> Wn a
wn_ll :: Wn a -> Pt a
wn_ex :: Wn a -> Vc a

-- | Real number, synonym for <a>Double</a>.
type R = Double

-- | Epsilon.
epsilon :: Floating n => n

-- | Is absolute difference less than <a>epsilon</a>.
(~=) :: (Floating a, Ord a) => a -> a -> Bool

-- | Degrees to radians.
--   
--   <pre>
--   map r_to_radians [-180,-90,0,90,180] == [-pi,-pi/2,0,pi/2,pi]
--   </pre>
r_to_radians :: R -> R

-- | Radians to degrees, inverse of <a>r_to_radians</a>.
--   
--   <pre>
--   map r_from_radians [-pi,-pi/2,0,pi/2,pi] == [-180,-90,0,90,180]
--   </pre>
r_from_radians :: R -> R

-- | <a>R</a> modulo within range.
--   
--   <pre>
--   map (r_constrain (3,5)) [2.75,5.25] == [4.75,3.25]
--   </pre>
r_constrain :: (R, R) -> R -> R

-- | Sum of squares.
mag_sq :: Num a => a -> a -> a

-- | <a>sqrt</a> of <a>mag_sq</a>.
mag :: Floating c => c -> c -> c

-- | Tuple constructor.
pt' :: (a, a) -> Pt a

-- | Tuple accessor.
pt_xy :: Pt t -> (t, t)

-- | <a>Pt</a> of (0,0).
--   
--   <pre>
--   pt_origin == Pt 0 0
--   </pre>
pt_origin :: Num a => Pt a

-- | Unary operator at <a>Pt</a>, ie. basis for <a>Num</a> instances.
pt_uop :: (a -> b) -> Pt a -> Pt b

-- | Binary operator at <a>Pt</a>, ie. basis for <a>Num</a> instances.
pt_binop :: (a -> b -> c) -> Pt a -> Pt b -> Pt c

-- | <a>Pt</a> at <i>(n,n)</i>.
--   
--   <pre>
--   pt_from_scalar 1 == Pt 1 1
--   </pre>
pt_from_scalar :: Num a => a -> Pt a

-- | Clip <i>x</i> and <i>y</i> to lie in <i>(0,n)</i>.
--   
--   <pre>
--   pt_clipu 1 (Pt 0.5 1.5) == Pt 0.5 1
--   </pre>
pt_clipu :: (Ord a, Num a) => a -> Pt a -> Pt a

-- | Swap <i>x</i> and <i>y</i> coordinates at <a>Pt</a>.
--   
--   <pre>
--   pt_swap (Pt 1 2) == Pt 2 1
--   </pre>
pt_swap :: Pt a -> Pt a

-- | Negate <i>y</i> element of <a>Pt</a>.
--   
--   <pre>
--   pt_negate_y (Pt 1 1) == Pt 1 (-1)
--   </pre>
pt_negate_y :: Num a => Pt a -> Pt a

-- | <a>Pt</a> variant of <a>r_to_radians</a>.
--   
--   <pre>
--   pt_to_radians (Pt 90 270) == Pt (pi/2) (pi*(3/2))
--   </pre>
pt_to_radians :: Pt R -> Pt R

-- | Cartesian to polar.
--   
--   <pre>
--   pt_to_polar (Pt 0 pi) == Pt pi (pi/2)
--   </pre>
pt_to_polar :: Pt R -> Pt R

-- | Polar to cartesian, inverse of <a>pt_to_polar</a>.
--   
--   <pre>
--   pt_from_polar (Pt pi (pi/2)) ~= Pt 0 pi
--   </pre>
pt_from_polar :: Pt R -> Pt R

-- | Scalar <a>Pt</a> <a>+</a>.
--   
--   <pre>
--   pt_offset 1 pt_origin == Pt 1 1
--   </pre>
pt_offset :: Num a => a -> Pt a -> Pt a

-- | Scalar <a>Pt</a> <a>*</a>.
--   
--   <pre>
--   pt_scale 2 (Pt 1 2) == Pt 2 4
--   </pre>
pt_scale :: Num a => a -> Pt a -> Pt a

-- | Pointwise <a>min</a>.
pt_min :: Ord a => Pt a -> Pt a -> Pt a

-- | Pointwise <a>max</a>.
pt_max :: Ord a => Pt a -> Pt a -> Pt a

-- | Apply function to <i>x</i> and <i>y</i> fields of three <a>Pt</a>.
pt_ternary_f :: (a -> a -> b -> b -> c -> c -> d) -> Pt a -> Pt b -> Pt c -> d

-- | Given a <i>(minima,maxima)</i> pair, expand so as to include <i>p</i>.
--   
--   <pre>
--   pt_minmax (Pt 0 0,Pt 1 1) (Pt (-1) 2) == (Pt (-1) 0,Pt 1 2)
--   </pre>
pt_minmax :: Ord a => (Pt a, Pt a) -> Pt a -> (Pt a, Pt a)

-- | <a>Pt</a> variant of <tt>constrain</tt>.
pt_constrain :: (Pt R, Pt R) -> Pt R -> Pt R

-- | Angle to origin.
--   
--   <pre>
--   pt_angle_o (Pt 0 1) == pi / 2
--   </pre>
pt_angle_o :: Pt R -> R

-- | Angle from <i>p</i> to <i>q</i>.
--   
--   <pre>
--   pt_angle (Pt 0 (-1)) (Pt 0 1) == pi/2
--   pt_angle (Pt 1 0) (Pt 0 1) == pi * 3/4
--   pt_angle (Pt 0 1) (Pt 0 1) == 0
--   </pre>
pt_angle :: Pt R -> Pt R -> R

-- | Pointwise <a>+</a>.
--   
--   pt_translate (Pt 0 0) (vc 1 1) == pt 1 1
pt_translate :: (Num a, Eq a) => Pt a -> Vc a -> Pt a

-- | <a>pt_uop</a> <a>fromIntegral</a>.
pt_from_i :: (Integral i, Num a) => Pt i -> Pt a

-- | <a>mag_sq</a> of <i>x</i> <i>y</i> of <a>Pt</a>.
pt_mag_sq :: Num a => Pt a -> a

-- | <a>mag</a> of <i>x</i> <i>y</i> of <a>Pt</a>.
pt_mag :: Floating a => Pt a -> a

-- | Distance from <a>Pt</a> <i>p</i> to <a>Pt</a> <i>q</i>.
--   
--   <pre>
--   pt_distance (Pt 0 0) (Pt 0 1) == 1
--   pt_distance (Pt 0 0) (Pt 1 1) == sqrt 2
--   </pre>
pt_distance :: (Floating a, Eq a) => Pt a -> Pt a -> a

-- | Are <i>x</i> and <i>y</i> of <a>Pt</a> <i>p</i> in range (0,1).
--   
--   <pre>
--   map pt_is_normal [Pt 0 0,Pt 1 1,Pt 2 2] == [True,True,False]
--   </pre>
pt_is_normal :: (Ord a, Num a) => Pt a -> Bool

-- | Rotate <a>Pt</a> <i>n</i> radians.
--   
--   <pre>
--   pt_rotate pi (Pt 1 0) ~= Pt (-1) 0
--   </pre>
pt_rotate :: Floating a => a -> Pt a -> Pt a
pt_rotate_about :: Floating a => a -> Pt a -> Pt a -> Pt a

-- | Unary operator at <a>Vc</a>, ie. basis for <a>Num</a> instances.
vc_uop :: (a -> b) -> Vc a -> Vc b

-- | Binary operator at <a>Vc</a>, ie. basis for <a>Num</a> instances.
vc_binop :: (a -> b -> c) -> Vc a -> Vc b -> Vc c

-- | <a>mag_sq</a> of <a>Vc</a>.
vc_mag_sq :: Floating c => Vc c -> c

-- | <a>mag</a> of <a>Vc</a>.
vc_mag :: Floating c => Vc c -> c

-- | Multiply <a>Vc</a> pointwise by scalar.
--   
--   <pre>
--   vc_scale 2 (Vc 3 4) == Vc 6 8
--   </pre>
vc_scale :: Num a => a -> Vc a -> Vc a

-- | <a>Vc</a> dot product.
--   
--   <pre>
--   vc_dot (Vc 1 2) (Vc 3 4) == 11
--   </pre>
vc_dot :: Num a => Vc a -> Vc a -> a

-- | Scale <a>Vc</a> to have unit magnitude (to within tolerance).
--   
--   <pre>
--   vc_unit (Vc 1 1) ~= let x = (sqrt 2) / 2 in Vc x x
--   </pre>
vc_unit :: (Ord a, Floating a) => Vc a -> Vc a

-- | The angle between two vectors on a plane. The angle is from v1 to v2,
--   positive anticlockwise. The result is in (-pi,pi)
vc_angle :: Vc R -> Vc R -> R

-- | Variant on <a>Ln</a> which takes <a>Pt</a> co-ordinates as duples.
--   
--   <pre>
--   ln' (0,0) (1,1) == Ln (Pt 0 0) (Pt 1 1)
--   ln_start (Ln (Pt 0 0) (Pt 1 1)) == Pt 0 0
--   ln_end (Ln (Pt 0 0) (Pt 1 1)) == Pt 1 1
--   </pre>
ln' :: (Num a, Eq a) => (a, a) -> (a, a) -> Ln a

-- | <a>Vc</a> that <a>pt_translate</a>s start <a>Pt</a> to end <a>Pt</a>
--   of <a>Ln</a>.
--   
--   <pre>
--   let l = Ln (Pt 0 0) (Pt 1 1)
--   in ln_start l `pt_translate` ln_vc l == Pt 1 1
--   </pre>
ln_vc :: (Num a, Eq a) => Ln a -> Vc a

-- | <a>Pt</a> UOp at <a>Ln</a>.
ln_uop :: (Pt a -> Pt b) -> Ln a -> Ln b

-- | <a>pt_scale</a> at <a>Ln</a>.
ln_scale :: Num b => b -> Ln b -> Ln b

-- | The angle, in <i>radians</i>, anti-clockwise from the <i>x</i>-axis.
--   
--   <pre>
--   ln_angle (ln' (0,0) (0,0)) == 0
--   ln_angle (ln' (0,0) (1,1)) == pi/4
--   ln_angle (ln' (0,0) (0,1)) == pi/2
--   ln_angle (ln' (0,0) (-1,1)) == pi * 3/4
--   </pre>
ln_angle :: Ln R -> R

-- | Start and end points of <a>Ln</a>.
--   
--   <pre>
--   ln_pt (Ln (Pt 1 0) (Pt 0 0)) == (Pt 1 0,Pt 0 0)
--   </pre>
ln_pt :: (Num a, Eq a) => Ln a -> (Pt a, Pt a)

-- | Variant of <a>ln_pt</a> giving co-ordinates as duples.
--   
--   <pre>
--   ln_pt' (Ln (Pt 1 0) (Pt 0 0)) == ((1,0),(0,0))
--   </pre>
ln_pt' :: (Num a, Eq a) => Ln a -> ((a, a), (a, a))

-- | Midpoint of a <a>Ln</a>.
--   
--   <pre>
--   ln_midpoint (Ln (Pt 0 0) (Pt 2 1)) == Pt 1 (1/2)
--   </pre>
ln_midpoint :: (Fractional a, Eq a) => Ln a -> Pt a

-- | Variant on <a>ln_midpoint</a>.
--   
--   <pre>
--   cc_midpoint (Just (Pt 0 0),Nothing) == Pt 0 0
--   cc_midpoint (Nothing,Just (Pt 2 1)) == Pt 2 1
--   cc_midpoint (Just (Pt 0 0),Just (Pt 2 1)) == Pt 1 (1/2)
--   </pre>
cc_midpoint :: (Maybe (Pt R), Maybe (Pt R)) -> Pt R

-- | Magnitude of <a>Ln</a>, ie. length of line.
--   
--   <pre>
--   ln_magnitude (Ln (Pt 0 0) (Pt 1 1)) == sqrt 2
--   pt_x (pt_to_polar (Pt 1 1)) == sqrt 2
--   </pre>
ln_magnitude :: Ln R -> R

-- | Order <a>Pt</a> at <a>Ln</a> so that <i>p</i> is to the left of
--   <i>q</i>. If <i>x</i> fields are equal, sort on <i>y</i>.
--   
--   <pre>
--   ln_sort (Ln (Pt 1 0) (Pt 0 0)) == Ln (Pt 0 0) (Pt 1 0)
--   ln_sort (Ln (Pt 0 1) (Pt 0 0)) == Ln (Pt 0 0) (Pt 0 1)
--   </pre>
ln_sort :: (Num a, Ord a) => Ln a -> Ln a

-- | Adjust <a>Ln</a> to have equal starting <a>Pt</a> but magnitude
--   <a>R</a>.
--   
--   <pre>
--   ln_adjust (sqrt 2) (Ln (Pt 0 0) (Pt 2 2)) == Ln (Pt 0 0) (Pt 1 1)
--   </pre>
ln_adjust :: (Floating a, Ord a) => a -> Ln a -> Ln a

-- | Extend <a>Ln</a> by <a>R</a>, ie. <a>ln_adjust</a> with <i>n</i> added
--   to <a>ln_magnitude</a>.
--   
--   <pre>
--   ln_extend (sqrt 2) (Ln (Pt 0 0) (Pt 1 1)) ~= Ln (Pt 0 0) (Pt 2 2)
--   </pre>
ln_extend :: R -> Ln R -> Ln R

-- | Variant definition of <a>ln_extend</a>.
--   
--   <pre>
--   ln_extend_ (sqrt 2) (Ln (Pt 0 0) (Pt 1 1)) == Ln (Pt 0 0) (Pt 2 2)
--   </pre>
ln_extend_ :: R -> Ln R -> Ln R

-- | Calculate the point that extends a line by length <tt>n</tt>.
--   
--   <pre>
--   pt_linear_extension (sqrt 2) (Ln (Pt 1 1) (Pt 2 2)) ~= Pt 3 3
--   pt_linear_extension 1 (Ln (Pt 1 1) (Pt 1 2)) ~= Pt 1 3
--   </pre>
pt_linear_extension :: R -> Ln R -> Pt R

-- | Does <a>Pt</a> <i>p</i> lie on <a>Ln</a> (inclusive).
--   
--   <pre>
--   let {f = pt_on_line (Ln (Pt 0 0) (Pt 1 1))
--       ;r = [True,False,False,True]}
--   in map f [Pt 0.5 0.5,Pt 2 2,Pt (-1) (-1),Pt 0 0] == r
--   </pre>
pt_on_line :: Ln R -> Pt R -> Bool
ln_intersect :: (Eq t, Fractional t) => Ln t -> Ln t -> Maybe (t, t)
ln_pt_along :: (Eq a, Num a) => a -> Ln a -> Pt a

-- | Do two <a>Ln</a>s intersect, and if so at which <a>Pt</a>.
--   
--   <pre>
--   ln_intersection (ln' (0,0) (5,5)) (ln' (5,0) (0,5)) == Just (Pt 2.5 2.5)
--   ln_intersection (ln' (1,3) (9,3)) (ln' (0,1) (2,1)) == Nothing
--   ln_intersection (ln' (1,5) (6,8)) (ln' (0.5,3) (6,4)) == Nothing
--   ln_intersection (ln' (1,2) (3,6)) (ln' (2,4) (4,8)) == Nothing
--   ln_intersection (ln' (2,3) (7,9)) (ln' (1,2) (5,7)) == Nothing
--   ln_intersection (ln' (0,0) (1,1)) (ln' (0,0) (1,0)) == Just (Pt 0 0)
--   </pre>
ln_intersection :: (Ord a, Fractional a) => Ln a -> Ln a -> Maybe (Pt a)

-- | Variant definition of <a>ln_intersection</a>, using algorithm at
--   <a>http://paulbourke.net/geometry/lineline2d/</a>.
--   
--   <pre>
--   ln_intersection_ (ln' (1,2) (3,6)) (ln' (2,4) (4,8)) == Nothing
--   ln_intersection_ (ln' (0,0) (1,1)) (ln' (0,0) (1,0)) == Just (Pt 0 0)
--   </pre>
ln_intersection_ :: (Ord a, Fractional a) => Ln a -> Ln a -> Maybe (Pt a)

-- | Predicate variant of <a>ln_intersection</a>.
--   
--   <pre>
--   ln_intersect_p (ln' (1,1) (3,8)) (ln' (0.5,2) (4,7)) == True
--   ln_intersect_p (ln' (3.5,9) (3.5,0.5)) (ln' (3,1) (9,1)) == True
--   </pre>
ln_intersect_p :: (Ord a, Fractional a) => Ln a -> Ln a -> Bool

-- | Slope of <a>Ln</a> or <a>Nothing</a> if <i>vertical</i>.
--   
--   <pre>
--   let l = zipWith ln' (repeat (0,0)) [(1,0),(2,1),(1,1),(0,1),(-1,1)]
--   in map ln_slope l == [Just 0,Just (1/2),Just 1,Nothing,Just (-1)]
--   </pre>
ln_slope :: (Fractional a, Eq a) => Ln a -> Maybe a

-- | Are <a>Ln</a>s parallel, ie. have equal <a>ln_slope</a>. Note that the
--   direction of the <a>Ln</a> is not relevant, ie. this is not equal to
--   <a>ln_same_direction</a>.
--   
--   <pre>
--   ln_parallel (ln' (0,0) (1,1)) (ln' (2,2) (1,1)) == True
--   ln_parallel (ln' (0,0) (1,1)) (ln' (2,0) (1,1)) == False
--   ln_parallel (ln' (1,2) (3,6)) (ln' (2,4) (4,8)) == True
--   map ln_slope [ln' (2,2) (1,1),ln' (2,0) (1,1)] == [Just 1,Just (-1)]
--   </pre>
ln_parallel :: (Ord a, Fractional a) => Ln a -> Ln a -> Bool

-- | Are <a>Ln</a>s parallel, ie. have equal <a>ln_angle</a>.
--   
--   <pre>
--   ln_parallel_ (ln' (0,0) (1,1)) (ln' (2,2) (1,1)) == True
--   </pre>
ln_parallel_ :: Ln R -> Ln R -> Bool

-- | Are two vectors are in the same direction (to within a small
--   tolerance).
vc_same_direction :: (Ord a, Floating a) => Vc a -> Vc a -> Bool

-- | Do <a>Ln</a>s have same direction (within tolerance).
--   
--   <pre>
--   ln_same_direction (ln' (0,0) (1,1)) (ln' (0,0) (2,2)) == True
--   ln_same_direction (ln' (0,0) (1,1)) (ln' (2,2) (0,0)) == False
--   </pre>
ln_same_direction :: (Ord a, Floating a) => Ln a -> Ln a -> Bool

-- | Are <a>Ln</a>s parallel, ie. does <a>ln_vc</a> of each equal
--   <a>ln_same_direction</a>.
--   
--   <pre>
--   ln_parallel__ (ln' (0,0) (1,1)) (ln' (2,2) (1,1)) == True
--   </pre>
ln_parallel__ :: Ln R -> Ln R -> Bool

-- | Is <a>Ln</a> horizontal, ie. is <a>ln_slope</a> zero.
--   
--   <pre>
--   ln_horizontal (ln' (0,0) (1,0)) == True
--   ln_horizontal (ln' (1,0) (0,0)) == True
--   </pre>
ln_horizontal :: (Fractional a, Eq a) => Ln a -> Bool

-- | Is <a>Ln</a> vertical, ie. is <a>ln_slope</a> <a>Nothing</a>.
--   
--   <pre>
--   ln_vertical (ln' (0,0) (0,1)) == True
--   </pre>
ln_vertical :: (Fractional a, Eq a) => Ln a -> Bool

-- | <a>pt_minmax</a> for set of <a>Ln</a>.
lns_minmax :: Ord n => [Ln n] -> (Pt n, Pt n)

-- | Normalise to (0,m).
lns_normalise :: (Fractional n, Ord n) => n -> [Ln n] -> [Ln n]

-- | <a>Ls</a> constructor.
ls :: [Pt a] -> Ls a

-- | Variant <a>Ls</a> constructor from <a>Pt</a> co-ordinates as duples.
ls' :: [(a, a)] -> Ls a

-- | Negate <i>y</i> elements.
ls_negate_y :: Num a => Ls a -> Ls a

-- | Generate <i>minima</i> and <i>maxima</i> <tt>Point</tt>s from
--   <a>Ls</a>.
ls_minmax :: Ord a => Ls a -> (Pt a, Pt a)

-- | Separate <a>Ls</a> at points where the <a>Vc</a> from one element to
--   the next exceeds the indicated distance.
--   
--   <pre>
--   map length (ls_separate (Vc 2 2) (map (uncurry Pt) [(0,0),(1,1),(3,3)])) == [2,1]
--   </pre>
ls_separate :: (Ord a, Num a) => Vc a -> Ls a -> [Ls a]

-- | Delete <a>Pt</a> from <a>Ls</a> so that no two <a>Pt</a> are within a
--   tolerance given by <a>Vc</a>.
ls_tolerate :: (Ord a, Num a) => Vc a -> Ls a -> Ls a

-- | Variant of <a>ls_tolerate</a> where <a>Vc</a> is optional, and
--   <a>Nothing</a> gives <a>id</a>.
ls_tolerate' :: (Ord a, Num a) => Maybe (Vc a) -> Ls a -> Ls a

-- | Test if point <a>Pt</a> lies inside polygon <a>Ls</a>.
--   
--   <pre>
--   ls_pt_inside (ls' [(0,0),(1,0),(1,1),(0,1)]) (Pt 0.5 0.5) == True
--   </pre>
ls_pt_inside :: Ls R -> Pt R -> Bool

-- | Variant that counts points at vertices as inside.
--   
--   <pre>
--   ls_pt_inside' (ls' [(0,0),(1,0),(1,1),(0,1)]) (Pt 0 1) == True
--   </pre>
ls_pt_inside' :: Ls R -> Pt R -> Bool

-- | Check all <a>Pt</a> at <a>Ls</a> are <a>pt_is_normal</a>.
ls_check_normalised :: (Ord a, Num a) => Ls a -> Bool

-- | Line co-ordinates as <i>x</i>,<i>y</i> list.
--   
--   <pre>
--   ls_xy [Pt 0 0,Pt 1 1] == [0,0,1,1]
--   </pre>
ls_xy :: Ls a -> [a]

-- | <a>Ls</a> average.
ls_centroid :: Fractional t => Ls t -> Pt t

-- | <a>map</a> of <a>pt_rotate_about</a>.
ls_rotate_about :: Floating t => t -> Pt t -> Ls t -> Ls t

-- | <a>ls_rotate_about</a> of <a>ls_centroid</a>.
ls_rotate_about_centroid :: Floating t => t -> Ls t -> Ls t

-- | Variant <a>Wn</a> constructor.
wn' :: Num a => (a, a) -> (a, a) -> Wn a

-- | Extract <i>(x,y)</i> and <i>(dx,dy)</i> pairs.
--   
--   <pre>
--   wn_extract (Wn (Pt 0 0) (Vc 1 1)) == ((0,0),(1,1))
--   </pre>
wn_extract :: Wn a -> ((a, a), (a, a))

-- | Show function for window with fixed precision of <tt>n</tt>.
--   
--   <pre>
--   wn_show 1 (Wn (Pt 0 0) (Vc 1 1)) == "((0.0,0.0),(1.0,1.0))"
--   </pre>
wn_show :: Int -> Wn R -> String

-- | Unit window at origin.
wn_unit :: Num n => Wn n

-- | Is <a>Pt</a> within <a>Wn</a> exclusive of edge.
--   
--   <pre>
--   map (pt_in_window (wn' (0,0) (1,1))) [Pt 0.5 0.5,Pt 1 1] == [True,False]
--   </pre>
pt_in_window :: (Ord a, Num a) => Wn a -> Pt a -> Bool

-- | <a>Wn</a> from <i>(lower-left,upper-right)</i> extent.
wn_from_extent :: (Num a, Ord a) => (Pt a, Pt a) -> Wn a

-- | <a>Wn</a> containing <a>Ls</a>.
--   
--   <pre>
--   ls_window (ls' [(0,0),(1,1),(2,0)]) == wn' (0,0) (2,1)
--   </pre>
ls_window :: (Num a, Ord a) => Ls a -> Wn a

-- | A <a>Wn</a> that encompasses both input <a>Wn</a>s.
wn_join :: (Num a, Ord a) => Wn a -> Wn a -> Wn a

-- | Predictate to determine if two <a>Wn</a>s intersect.
wn_intersect :: (Num a, Ord a) => Wn a -> Wn a -> Bool

-- | Are all points at <a>Ls</a> within the <a>Wn</a>.
ls_in_window :: Wn R -> Ls R -> Bool

-- | Are any points at <a>Ls</a> within the window <a>Wn</a>.
ls_enters_window :: Wn R -> Ls R -> Bool

-- | Are all points at <a>Ls</a> outside the <a>Wn</a>.
ls_not_in_window :: Wn R -> Ls R -> Bool

-- | Break <a>Ls</a> into segments that are entirely within the <a>Wn</a>.
ls_segment_window :: Wn R -> Ls R -> [Ls R]

-- | Normalisation function for <a>Wn</a>, ie. map <a>Pt</a> to lie within
--   (0,1).
wn_normalise_f :: (Ord n, Fractional n) => Wn n -> Pt n -> Pt n

-- | Given <a>Wn</a> normalise the <a>Ls</a>.
ls_normalise_w :: (Ord n, Fractional n) => Wn n -> Ls n -> Ls n

-- | Given <a>Wn</a> normalise <a>Ln</a>.
ln_normalise_w :: (Ord n, Fractional n) => Wn n -> Ln n -> Ln n

-- | Variant of <a>ls_normalise_w</a>, the window is determined by the
--   extent of the <a>Ls</a>.
ls_normalise :: (Ord n, Fractional n) => Ls n -> Ls n

-- | Normalise a set of line segments using composite window.
ls_normalise_set :: (Ord n, Fractional n) => [Ls n] -> [Ls n]

-- | Shift lower left <a>Pt</a> of <a>Wn</a> by indicated <a>Pt</a>.
pt_shift_w :: Num a => Pt a -> Wn a -> Wn a

-- | Negate <i>y</i> field of lower left <a>Pt</a> of <a>Wn</a>.
wn_negate_y :: Num a => Wn a -> Wn a

-- | Transformation matrix data type.
data Matrix n
Matrix :: n -> n -> n -> n -> n -> n -> Matrix n

-- | Enumeration of <a>Matrix</a> indices.
data Matrix_Index
I0 :: Matrix_Index
I1 :: Matrix_Index
I2 :: Matrix_Index
mx_row :: Num n => Matrix n -> Matrix_Index -> (n, n, n)
mx_col :: Num n => Matrix n -> Matrix_Index -> (n, n, n)
mx_multiply :: Num n => Matrix n -> Matrix n -> Matrix n

-- | Pointwise unary operator.
mx_uop :: (n -> n) -> Matrix n -> Matrix n

-- | Pointwise binary operator.
mx_binop :: (n -> n -> n) -> Matrix n -> Matrix n -> Matrix n

-- | A translation matrix with independent x and y offsets.
mx_translation :: Num n => n -> n -> Matrix n

-- | A scaling matrix with independent x and y scalars.
mx_scaling :: Num n => n -> n -> Matrix n

-- | A rotation matrix through the indicated angle (in radians).
mx_rotation :: Floating n => n -> Matrix n

-- | The identity matrix.
mx_identity :: Num n => Matrix n
mx_translate :: Num n => n -> n -> Matrix n -> Matrix n
mx_scale :: Num n => n -> n -> Matrix n -> Matrix n
mx_rotate :: Floating n => n -> Matrix n -> Matrix n
mx_scalar_multiply :: Num n => n -> Matrix n -> Matrix n
mx_adjoint :: Num n => Matrix n -> Matrix n
mx_invert :: Fractional n => Matrix n -> Matrix n
mx_list :: Matrix n -> [n]

-- | Apply a transformation matrix to a point.
pt_transform :: Num n => Matrix n -> Pt n -> Pt n
bezier3 :: Num n => Pt n -> Pt n -> Pt n -> n -> Pt n

-- | Four-point bezier curve interpolation. The index <i>mu</i> is in the
--   range zero to one.
bezier4 :: Num n => Pt n -> Pt n -> Pt n -> Pt n -> n -> Pt n

-- | Given <i>left</i> and <i>right</i>, is <i>x</i> in range (inclusive).
--   
--   <pre>
--   map (in_range 0 1) [-1,0,1,2] == [False,True,True,False]
--   </pre>
in_range :: Ord a => a -> a -> a -> Bool

-- | Split list at element where predicate <i>f</i> over adjacent elements
--   first holds.
--   
--   <pre>
--   split_f (\p q -&gt; q - p &lt; 3) [1,2,4,7,11] == ([1,2,4],[7,11])
--   </pre>
split_f :: (a -> a -> Bool) -> [a] -> ([a], [a])

-- | Variant on <a>split_f</a> that segments input.
--   
--   <pre>
--   segment_f (\p q -&gt; abs (q - p) &lt; 3) [1,3,7,9,15] == [[1,3],[7,9],[15]]
--   </pre>
segment_f :: (a -> a -> Bool) -> [a] -> [[a]]

-- | Delete elements of a list using a predicate over the previous and
--   current elements.
delete_f :: (a -> a -> Bool) -> [a] -> [a]

-- | All adjacent pairs of a list.
--   
--   <pre>
--   pairs [1..5] == [(1,2),(2,3),(3,4),(4,5)]
--   </pre>
pairs :: [x] -> [(x, x)]
instance Eq a => Eq (Pt a)
instance Ord a => Ord (Pt a)
instance Show a => Show (Pt a)
instance Eq a => Eq (Vc a)
instance Ord a => Ord (Vc a)
instance Show a => Show (Vc a)
instance Eq a => Eq (Ln a)
instance Ord a => Ord (Ln a)
instance Show a => Show (Ln a)
instance Eq a => Eq (Wn a)
instance Show a => Show (Wn a)
instance Eq n => Eq (Matrix n)
instance Show n => Show (Matrix n)
instance Num n => Num (Matrix n)
instance Num a => Num (Vc a)
instance Num a => Num (Pt a)


-- | Arrows
module Data.CG.Minus.Arrow

-- | Given the arrow body <a>Ln</a> and the arrow length and arrow angle
--   (in radians) <a>R</a> calculate the <a>Pt</a> of each arrow tip.
--   
--   <pre>
--   arrow_coord (Ln (Pt 0 0) (Pt 1 1)) 0.1 (pi/9)
--   </pre>
arrow_coord :: Ln R -> R -> R -> (Pt R, Pt R)


-- | Compass bearings.
module Data.CG.Minus.Bearing

-- | Enumeration of compass bearings
data Bearing
N :: Bearing
NNE :: Bearing
NE :: Bearing
ENE :: Bearing
E :: Bearing
ESE :: Bearing
SE :: Bearing
SSE :: Bearing
S :: Bearing
SSW :: Bearing
SW :: Bearing
WSW :: Bearing
W :: Bearing
WNW :: Bearing
NW :: Bearing
NNW :: Bearing

-- | Bearing from <a>Pt</a> <i>p</i> to <i>q</i>.
--   
--   <pre>
--   let f (x,y) = bearing (Pt 0 0) (Pt x y)
--   map f [(0,1),(1,1),(1,0),(1,-1)] == [N,NE,E,SE]
--   map f [(0,-1),(-1,-1),(-1,0),(-1,1)] == [S,SW,W,NW]
--   map f [(1/4,1),(1,1/4),(1,-1/4),(1/4,-1)] == [NNE,ENE,ESE,SSE]
--   map f [(-1/4,-1),(-1,-1/4),(-1,1.4),(-1/4,1)] == [SSW,WSW,NW,NNW]
--   </pre>
bearing :: Pt R -> Pt R -> Bearing

-- | Bearing to nearest eight point compass bearing
--   
--   <pre>
--   let f (x,y) = bearing_8 (Pt 0 0) (Pt x y)
--   map f [(1/4,1),(1,1/4),(1,-1/4),(1/4,-1)] == [N,E,E,S]
--   </pre>
bearing_8 :: Pt R -> Pt R -> Bearing

-- | Predicate that is <a>True</a> if bearings are opposite.
--   
--   <pre>
--   bearing_opposite (NW,SE) == True
--   map bearing_opposite (zip [N,E,S,W] [S,W,N,E]) == [True,True,True,True]
--   </pre>
bearing_opposite :: (Bearing, Bearing) -> Bool
instance Eq Bearing
instance Enum Bearing
instance Bounded Bearing
instance Show Bearing
