-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatic generation of Isabelle/HOL correctness proofs for security protocols.
--   
--   scyther-proof is a security protocol verification tool based on a
--   similar algorithm as the Scyther tool developed by Cas Cremers
--   (http:<i></i>people.inf.ethz.ch<i>cremersc</i>scyther/index.html). The
--   theory underlying scyther-proof is described in the paper <a>Strong
--   Invariants for the Efficient Construction of Machine-Checked Protocol
--   Security Proofs</a> by Meier, Cremers, and Basin. Parts of the
--   infrastructure underlying scyther-proof are reused in other projects
--   by the same author. Therefore, most of its modules are exported in the
--   corresponding scyther-proof library. However, this library is not yet
--   thought for general use. Please contact the author, if you would like
--   to build upon/extend scyther-proof.
@package scyther-proof
@version 0.3.0

module Scyther.Theory.Lexer
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
data AlexLastAcc a
AlexNone :: AlexLastAcc a
AlexLastAcc :: a -> !AlexInput -> !Int -> AlexLastAcc a
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc a
data AlexAcc a user
AlexAcc :: a -> AlexAcc a user
AlexAccSkip :: AlexAcc a user
AlexAccPred :: a -> (AlexAccPred user) -> AlexAcc a user
AlexAccSkipPred :: (AlexAccPred user) -> AlexAcc a user
type AlexAccPred user = user -> AlexInput -> Int -> AlexInput -> Bool

-- | Lex a keyword
keyword :: Keyword -> AlexAction Keyword

-- | Lex an identifier
scanIdent :: AlexAction Keyword

-- | Lexable Keywords
data Keyword
IDENT :: String -> Keyword
SQUOTE :: Keyword
DQUOTE :: Keyword
RIGHTARROW :: Keyword
LEFTARROW :: Keyword
LONGRIGHTARROW :: Keyword
LONGLEFTARROW :: Keyword
COMMA :: Keyword
DOT :: Keyword
COLON :: Keyword
QUESTIONMARK :: Keyword
AND :: Keyword
MID :: Keyword
DOLLAR :: Keyword
SHARP :: Keyword
LPAREN :: Keyword
RPAREN :: Keyword
LBRACKET :: Keyword
RBRACKET :: Keyword
LBRACE :: Keyword
RBRACE :: Keyword
TILDE :: Keyword
HAT :: Keyword
STAR :: Keyword
UNDERSCORE :: Keyword
MINUS :: Keyword
PLUS :: Keyword
EQUAL :: Keyword
LESS :: Keyword
GREATER :: Keyword
EOF :: Keyword
FORALL :: Keyword
EXISTS :: Keyword
LAND :: Keyword
LOR :: Keyword
LNOT :: Keyword
APPROX :: Keyword
DUMMY_KEYWORD :: Keyword
type AlexInput = (AlexPosn, Char, String)
alexInputPrevChar :: AlexInput -> Char
alexGetChar :: AlexInput -> Maybe (Char, AlexInput)
data AlexPosn
AlexPn :: !Int -> !Int -> !Int -> AlexPosn
alexStartPos :: AlexPosn
alexMove :: AlexPosn -> Char -> AlexPosn
data AlexState
AlexState :: !AlexPosn -> String -> !Char -> !Int -> !Int -> [String] -> AlexState
alex_pos :: AlexState -> !AlexPosn
alex_inp :: AlexState -> String
alex_chr :: AlexState -> !Char
alex_scd :: AlexState -> !Int
alex_ocd :: AlexState -> !Int
alex_cmt :: AlexState -> [String]
runAlex :: String -> Alex a -> Either String a
newtype Alex a
Alex :: (AlexState -> Either String (AlexState, a)) -> Alex a
unAlex :: Alex a -> AlexState -> Either String (AlexState, a)
alexGetPos :: Alex AlexPosn
alexGetInput :: Alex AlexInput
alexSetInput :: AlexInput -> Alex ()
alexError :: String -> Alex a
alexGetStartCode :: Alex Int
alexSetStartCode :: Int -> Alex ()
alexGetOldStartCode :: Alex Int
alexSetOldStartCode :: Int -> Alex ()
alexGetComments :: Alex [String]
alexSetComments :: [String] -> Alex ()
type AlexAction result = AlexInput -> Int -> Alex result
skip :: AlexAction Keyword
begin :: Int -> AlexAction Keyword

-- | Begin a comment starting with the given sign.
beginComment :: String -> Int -> AlexAction Keyword

-- | End a comment that started with the given begin comment sign.
endComment :: String -> AlexAction Keyword
alexEOF :: Alex Keyword
comment :: Int
data AlexAddr
AlexA# :: Addr# -> AlexAddr
instance Eq Keyword
instance Eq AlexPosn
instance Monad Alex
instance Show AlexPosn
instance Show Keyword


-- | A simple module for timing IO action.
module System.Timing

-- | Execute an IO action and return its result plus the time it took to
--   execute it.
timed :: IO a -> IO (a, NominalDiffTime)

-- | Execute an IO action and return the time it took to execute it.
timed_ :: IO a -> IO NominalDiffTime


-- | Using Isabelle to check theory files.
--   
--   Requirements:
--   
--   <ol>
--   <li>A working installation of Isabelle2009-1
--   (http:<i></i>isabelle.in.tum.de/) 2. The 'isabelle' command must be on
--   the PATH.</li>
--   </ol>
module System.Isabelle

-- | Use Isabelle to check the correctness of a theory file.
checkTheoryFile :: FilePath -> Maybe Int -> Int -> String -> FilePath -> IO (IO String, Maybe String)


-- | This module provides a simple interface for building .dot graph files,
--   for input into the dot and graphviz tools. It includes a monadic
--   interface for building graphs.
module Text.Dot
data Dot a

-- | <a>node</a> takes a list of attributes, generates a new node, and
--   gives a <a>NodeId</a>.
node :: [(String, String)] -> Dot NodeId
data NodeId

-- | <a>userNodeId</a> allows a user to use their own (Int-based) node
--   id's, without needing to remap them.
userNodeId :: Int -> NodeId

-- | <a>userNode</a> takes a NodeId, and adds some attributes to that node.
userNode :: NodeId -> [(String, String)] -> Dot ()

-- | <a>edge</a> generates an edge between two <a>NodeId</a>s, with
--   attributes.
edge :: NodeId -> NodeId -> [(String, String)] -> Dot ()
showDot :: Dot a -> String

-- | <a>scope</a> groups a subgraph together; in dot these are the
--   subgraphs inside <a>{</a> and <a>}</a>.
scope :: Dot a -> Dot a

-- | <a>attribute</a> gives a attribute to the current scope.
attribute :: (String, String) -> Dot ()

-- | <a>nodeAttributes</a> sets attributes for all the following nodes in
--   the scope.
nodeAttributes :: [(String, String)] -> Dot ()

-- | <a>edgeAttributes</a> sets attributes for all the following edges in
--   the scope.
edgeAttributes :: [(String, String)] -> Dot ()

-- | <a>graphAttributes</a> sets attributes for current graph.
graphAttributes :: [(String, String)] -> Dot ()

-- | <a>share</a> is when a set of nodes share specific attributes. Usually
--   used for layout tweaking.
share :: [(String, String)] -> [NodeId] -> Dot ()

-- | <a>same</a> provides a combinator for a common pattern; a set of
--   <a>NodeId</a>s with the same rank.
same :: [NodeId] -> Dot ()

-- | <a>cluster</a> builds an explicit, internally named subgraph (called
--   cluster).
cluster :: Dot a -> Dot (NodeId, a)

-- | Specifies the construction of a record; i.e., mentions all fields
--   possibly together with ports and their horizontal and vertical
--   nesting. (see: record shapes in the DOT documentation.)
data Record a

-- | A simple field of a record.
field :: String -> Record a

-- | A field together with a port which can be used to create direct edges
--   to this field. Note that you can use any type to identify the ports.
--   When creating a record node you will get back an association list
--   between your record identifiers and their concrete node ids.
portField :: a -> String -> Record a

-- | Concatenate records horizontally.
hcat :: [Record a] -> Record a

-- | Concatenate a list strings interpreted as simple fields horizontally.
hcat' :: [String] -> Record a

-- | Concatenate records vertically.
vcat :: [Record a] -> Record a

-- | Concatenate a list strings interpreted as simple fields vertically.
vcat' :: [String] -> Record a

-- | Create a record node with the given attributes. It returns the node-id
--   of the created node together with an association list mapping the port
--   idenfiers given in the record to their corresponding node-ids. This
--   list is ordered according to a left-to-rigth traversal of the record
--   description.
record :: Record a -> [(String, String)] -> Dot (NodeId, [(a, NodeId)])

-- | A variant of <a>record</a> ignoring the port identifiers.
record' :: Record a -> [(String, String)] -> Dot (NodeId, [NodeId])

-- | A variant of <a>record</a> ignoring the port to node-id association
--   list.
record_ :: Record a -> [(String, String)] -> Dot NodeId

-- | Like <a>record</a>, but creates record nodes with rounded corners;
--   i.e. uses the "Mrecord" shape instead of the "record" shape.
mrecord :: Record a -> [(String, String)] -> Dot (NodeId, [(a, NodeId)])

-- | A variant of <a>mrecord</a> ignoring the port identifiers.
mrecord' :: Record a -> [(String, String)] -> Dot (NodeId, [NodeId])

-- | A variant of <a>mrecord</a> ignoring the port to node-id association
--   list.
mrecord_ :: Record a -> [(String, String)] -> Dot NodeId
instance Eq a => Eq (Record a)
instance Ord a => Ord (Record a)
instance Show a => Show (Record a)
instance Monad Dot
instance Show NodeId


-- | <a>Document</a> class allowing to have different interpretations of
--   the HughesPJ pretty-printing combinators.
module Text.PrettyPrint.Class

-- | The abstract type of documents. The <a>Show</a> instance is equivalent
--   to using <a>render</a>.
data Doc :: *
class Document d
char :: Document d => Char -> d
text :: Document d => String -> d
zeroWidthText :: Document d => String -> d
emptyDoc :: Document d => d
(<>) :: Document d => d -> d -> d
(<->) :: Document d => d -> d -> d
hcat :: Document d => [d] -> d
hsep :: Document d => [d] -> d
($$) :: Document d => d -> d -> d
($-$) :: Document d => d -> d -> d
vcat :: Document d => [d] -> d
sep :: Document d => [d] -> d
cat :: Document d => [d] -> d
fsep :: Document d => [d] -> d
fcat :: Document d => [d] -> d
nest :: Document d => Int -> d -> d
caseEmptyDoc :: Document d => d -> d -> d -> d

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | Renders the document as a string using the default <a>style</a>.
render :: Doc -> String

-- | Render the document as a string using a specified style.
renderStyle :: Style -> Doc -> String

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | A rendering style.
data Style :: *
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
mode :: Style -> Mode

-- | Length of line, in chars
lineLength :: Style -> Int

-- | Ratio of ribbon length to line length
ribbonsPerLine :: Style -> Float

-- | Rendering mode.
data Mode :: *

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | Vertical concatentation of two documents with an empty line in
--   between.
($--$) :: Document d => d -> d -> d
semi :: Document d => d
colon :: Document d => d
comma :: Document d => d
space :: Document d => d
equals :: Document d => d
lparen :: Document d => d
rparen :: Document d => d
lbrack :: Document d => d
rbrack :: Document d => d
lbrace :: Document d => d
rbrace :: Document d => d
int :: Document d => Int -> d
integer :: Document d => Integer -> d
float :: Document d => Float -> d
double :: Document d => Double -> d
rational :: Document d => Rational -> d
quotes :: Document d => d -> d
doubleQuotes :: Document d => d -> d
parens :: Document d => d -> d
brackets :: Document d => d -> d
braces :: Document d => d -> d
hang :: Document d => d -> Int -> d -> d
punctuate :: Document d => d -> [d] -> [d]
instance Document Doc

module Control.Concurrent.ManagedThreads
data ThreadManager

-- | Create a new thread manager.
newManager :: IO ThreadManager

-- | Create a new managed thread.
forkManaged :: ThreadManager -> IO () -> IO ThreadId

-- | Immediately return the status of a managed thread.
getStatus :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus)

-- | Block until a specific managed thread terminates.
waitFor :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus)

-- | Block until all managed threads terminate.
waitAll :: ThreadManager -> IO ()

-- | Do a parallel sequencing of a list of IO commands using n worker
--   threads and gather their results in a list again.
nParSequenceIO :: Int -> [IO a] -> IO [a]

-- | Do a parallel sequencing of a list of IO commands using n worker
--   threads.
nParSequenceIO_ :: Int -> [IO a] -> IO ()

-- | Do a parallel map of an IO cmd over a list using n worker threads.
nParMapIO :: Int -> (a -> IO b) -> [a] -> IO [b]

-- | Do a parallel map of an IO cmd over a list using n worker threads
--   while ignoring the results.
nParMapIO_ :: Int -> (a -> IO b) -> [a] -> IO ()

-- | Parallel execution of a command using n worker threads. The channel
--   argument can be used to report exactly one (!) progress value to the
--   display function. NOTE: If the executed command is blocking, then you
--   need to use the threaded runtime
nParCmd_ :: Int -> (Int -> Int -> b -> IO ()) -> [Chan b -> IO a] -> IO ()

-- | Like <tt>nParCmd_</tt> but uses the number of processing cores+1 as a
--   default for the number of worker treads. You can change their number
--   by adding to the command line of a program linked with the threaded
--   library: +RTS -N<a>no-of-cores</a> -RTS
parCmd_ :: (Int -> Int -> b -> IO ()) -> [Chan b -> IO a] -> IO ()
instance Show ThreadStatus
instance Eq ThreadManager


-- | A monad supporting labeling of values and a monad transformer
--   supporting the consistent labeling of keys.
--   
--   TODO: Split module into transformer part and type class instance part
--   along the lines of the transformers package.
module Control.Monad.Label

-- | A monad allowing for labelling keys.
class (Applicative m, Monad m) => MonadLabel k l m
label :: MonadLabel k l m => k -> m l

-- | A monad transformer implementing consistent (equal keys get equal
--   labels) labeling of keys with a sequence of labels.
newtype ConsistentLabelsT k l m a
ConsistentLabelsT :: StateT ([l], Map k l) m a -> ConsistentLabelsT k l m a
unConsistentLabelsT :: ConsistentLabelsT k l m a -> StateT ([l], Map k l) m a

-- | Run a computation requiring consistent labels.
runConsistentLabelsT :: ConsistentLabelsT k l m a -> [l] -> m (a, ([l], Map k l))

-- | Evaluate a computation requiring consistent labels.
evalConsistentLabelsT :: Functor m => ConsistentLabelsT k l m a -> [l] -> m a

-- | Execute a computation requiring consistent labels.
execConsistentLabelsT :: Functor m => ConsistentLabelsT k l m a -> [l] -> m ([l], Map k l)
type ConsistentLabels k l = ConsistentLabelsT k l Identity

-- | Run a computation requiring consistent labels.
runConsistentLabels :: ConsistentLabels k l a -> [l] -> (a, ([l], Map k l))

-- | Evaluate a computation requiring consistent labels.
evalConsistentLabels :: ConsistentLabels k l a -> [l] -> a

-- | Execute a computation requiring consistent labels.
execConsistentLabels :: ConsistentLabels k l a -> [l] -> ([l], Map k l)
instance Functor m => Functor (ConsistentLabelsT k l m)
instance (Monad m, Functor m) => Applicative (ConsistentLabelsT k l m)
instance Monad m => Monad (ConsistentLabelsT k l m)
instance MonadTrans (ConsistentLabelsT k l)
instance (Ord k, Applicative m, Monad m) => MonadLabel k l (ConsistentLabelsT k l m)
instance MonadLabel k l m => MonadLabel k l (ReaderT r m)
instance MonadLabel k l m => MonadLabel k l (StateT s m)


-- | A monad for implemented bounded depth-first-search and
--   branch-and-bound search.
module Control.Monad.BoundedDFS

-- | A monad with integer operation cost recording.
class Monad m => MonadCost c m | m -> c
updateCost :: MonadCost c m => (c -> c) -> m ()

-- | An unbounded depth-first search monad for searches formulated using
--   MonadPlus.
newtype UnboundedDFS c a
UnboundedDFS :: Maybe a -> UnboundedDFS c a
runUnboundedDFS :: UnboundedDFS c a -> Maybe a

-- | A cost bounded depth-first search monad.
--   
--   All choices are handled committing and there is no differentiation
--   between failure due to cost overrun and other failures.
newtype BoundedDFS c a
BoundedDFS :: ReaderT (c -> Bool) (StateT c Maybe) a -> BoundedDFS c a
unBoundedDFS :: BoundedDFS c a -> ReaderT (c -> Bool) (StateT c Maybe) a

-- | Run a cost bounded depth-first search.
runBoundedDFS :: BoundedDFS c a -> (c -> Bool) -> c -> Maybe (a, c)

-- | Evaluate a cost bounded depth-first search.
evalBoundedDFS :: BoundedDFS c a -> (c -> Bool) -> c -> Maybe a

-- | Execute a cost bounded depth-first search.
execBoundedDFS :: BoundedDFS c a -> (c -> Bool) -> c -> Maybe c

-- | A branch and bound monad for finding results with the smallest costs.
newtype BranchAndBound c a
BranchAndBound :: ReaderT (c -> Bool) (StateT c Maybe) a -> BranchAndBound c a
unBranchAndBound :: BranchAndBound c a -> ReaderT (c -> Bool) (StateT c Maybe) a

-- | Run a branch and bound search.
runBranchAndBound :: Cost c => BranchAndBound c a -> c -> Maybe (a, c)

-- | Evaluate a branch and bound search.
evalBranchAndBound :: Cost c => BranchAndBound c a -> c -> Maybe a

-- | Execute a branch and bound search.
execBranchAndBound :: Cost c => BranchAndBound c a -> c -> Maybe c
instance Monad (UnboundedDFS c)
instance Monad (BoundedDFS c)
instance Monad (BranchAndBound c)
instance Cost c => MonadPlus (BranchAndBound c)
instance (Ord a, Num a) => Cost (Maybe a)
instance MonadCost c (BranchAndBound c)
instance MonadPlus (BoundedDFS c)
instance MonadCost c (BoundedDFS c)
instance MonadPlus (UnboundedDFS c)
instance MonadCost c (UnboundedDFS c)


-- | A persistent, but not so efficient union-find structure.
module Data.UnionFind
newtype UnionFind a
UnionFind :: Map a a -> UnionFind a
unUnionFind :: UnionFind a -> Map a a
con_UnionFind :: Constr
ty_T :: DataType

-- | Smart constructor from a <a>Map</a> to a union-find structure.
unionFind :: Ord a => Map a a -> UnionFind a
map :: (Ord a, Ord b) => (a -> b) -> UnionFind a -> UnionFind b

-- | <tt>empty</tt> is the syntactic identity equivalence relation.
empty :: UnionFind a

-- | <tt>size uf</tt> returns the number of stored equalities.
size :: UnionFind a -> Int

-- | <tt>equate x y uf</tt> inserts the equality <tt>x = y</tt> into
--   <tt>uf</tt>.
equate :: Ord a => a -> a -> UnionFind a -> UnionFind a
fromList :: Ord a => [(a, a)] -> UnionFind a
equateList :: Ord a => UnionFind a -> [(a, a)] -> UnionFind a
toList :: UnionFind a -> [(a, a)]
union :: Ord a => UnionFind a -> UnionFind a -> UnionFind a

-- | <tt>find x uf</tt> returns the representative of the equivalence class
--   that <tt>x</tt> belongs to in <tt>uf</tt>, if there is any.
find :: Ord a => a -> UnionFind a -> Maybe a

-- | <tt>findWithDefault def x uf</tt> returns the representative of the
--   equivalence class that <tt>x</tt> belongs to in <tt>uf</tt> or
--   <tt>def</tt>, if there is no representative.
findWithDefault :: Ord a => a -> a -> UnionFind a -> a

-- | <tt>(x,y) <a>equiv</a> uf</tt> iff <tt>x</tt> and <tt>y</tt> are in
--   the same equivalence class with respect to <tt>uf</tt>.
equiv :: Ord a => (a, a) -> UnionFind a -> Bool
instance Typeable1 UnionFind
instance Eq a => Eq (UnionFind a)
instance Ord a => Ord (UnionFind a)
instance Show a => Show (UnionFind a)
instance (Data a, Ord a) => Data (UnionFind a)
instance Ord a => Monoid (UnionFind a)


-- | A simple color module for handling RGB and HSV representations of
--   colors.
module Data.Color
data RGB a
RGB :: !a -> !a -> !a -> RGB a
rgbR :: RGB a -> !a
rgbG :: RGB a -> !a
rgbB :: RGB a -> !a
data HSV a
HSV :: !a -> !a -> !a -> HSV a
hsvH :: HSV a -> !a
hsvS :: HSV a -> !a
hsvV :: HSV a -> !a

-- | Hexadecimal representation of an RGB value
rgbToHex :: RealFrac t => RGB t -> String

-- | Hexadecimal representation of an HSV value; i.e., of its corresponding
--   RGB value.
hsvToHex :: RealFrac t => HSV t -> [Char]
red :: Fractional t => RGB t
green :: Fractional t => RGB t
blue :: Fractional t => RGB t
rgbToGray :: Ord t => RGB t -> t
hsvToGray :: Num t => HSV t -> HSV t

-- | RGB to HSV conversion. Pre: 0 &lt;= r,g,b &lt;= 1 (Source:
--   http:<i></i>de.wikipedia.org<i>wiki</i>HSV-Farbraum)
rgbToHSV :: (Fractional t, Ord t) => RGB t -> HSV t

-- | HSV to RGB conversion. Pre: 0 &lt;= h &lt;= 360 and 0 &lt;= s,v &lt;=
--   1 (Source: http:<i></i>de.wikipedia.org<i>wiki</i>HSV-Farbraum)
hsvToRGB :: RealFrac t => HSV t -> RGB t

-- | Build color groups according to the list of group sizes using the
--   default <a>colorGroupStyle</a> for the function <a>genColorGroups</a>.
colorGroups :: Double -> [Int] -> [((Int, Int), HSV Double)]

-- | Build color groups according to the list of group sizes using the
--   default light <a>lightColorGroupStyle</a> for the function
--   <a>genColorGroups</a>.
lightColorGroups :: Double -> [Int] -> [((Int, Int), HSV Double)]
instance Eq a => Eq (RGB a)
instance Ord a => Ord (RGB a)
instance Eq a => Eq (HSV a)
instance Ord a => Ord (HSV a)
instance Eq t => Eq (ColorParams t)
instance Ord t => Ord (ColorParams t)
instance Show t => Show (ColorParams t)
instance Functor HSV
instance Show a => Show (HSV a)
instance Functor RGB
instance Show a => Show (RGB a)


-- | Re-export basic control structures for easier imports.
module Control.Basics


-- | Simple vertice list based representation of DAGs and some common
--   operations on it.
module Data.DAG.Simple

-- | Produce a topological sorting of the given relation. If the relation
--   is cyclic, then the result is at least some permutation of all
--   elements of the given relation.
toposort :: Ord a => [(a, a)] -> [a]

-- | Compute the set of nodes reachable from the given set of nodes.
reachableSet :: Ord a => [a] -> [(a, a)] -> Set a

-- | Is the relation cyclic.
cyclic :: Ord a => [(a, a)] -> Bool

module Extension.Prelude
implies :: Bool -> Bool -> Bool
singleton :: a -> [a]

-- | check whether the given list contains no duplicates
unique :: Eq a => [a] -> Bool

-- | Sort list and remove duplicates. O(n*log n)
sortednub :: Ord a => [a] -> [a]

-- | <i></i>O(n*log n).<i></i> Sort list and remove duplicates with respect
--   to a projection.
sortednubOn :: Ord b => (a -> b) -> [a] -> [a]

-- | Keep only the first element of elements having the same projected
--   value
nubOn :: Eq b => (a -> b) -> [a] -> [a]

-- | <i></i>O(n).<i></i> Group on a projection of the data to group
groupOn :: Eq b => (a -> b) -> [a] -> [[a]]

-- | sort on a projection of the data to sort
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | sort on a projection of the data to sort, memorizing the results of
--   the projection in order to avoid recomputation.
sortOnMemo :: Ord b => (a -> b) -> [a] -> [a]

-- | sort and group on a projection
groupSortOn :: Ord b => (a -> b) -> [a] -> [[a]]

-- | partition the given set into equality classes with respect to the
--   representative given by the projection function
eqClasses :: (Eq b, Ord b) => (a -> b) -> [a] -> [[a]]
eqClassesBy :: (b -> b -> Ordering) -> (a -> b) -> [a] -> [[a]]

-- | split a list into sublists whenever the predicate identifies an
--   element as a separator. Note that the separator is not retained and a
--   separator at the very end is ignored.
splitBy :: (a -> Bool) -> [a] -> [[a]]

-- | the list of all permutations of a given list permutations :: [a] -&gt;
--   [[a]] permutations [] = [[]] permutations zs = aux zs [] where aux []
--   _ = [] aux (x:xs) ys = [x:p | p &lt;- permutations (xs++ys)] ++ aux xs
--   (x:ys)
--   
--   the list of all combinations of n elements of a list. E.g. choose 2
--   [1,2,3] = [[1,2],[1,3],[2,3]]
choose :: Int -> [a] -> [[a]]

-- | build the list of lists each leaving another element out. (From left
--   to right)
leaveOneOut :: [a] -> [[a]]

-- | An element masks another element if the predicate is true. This
--   function keeps only the elements not masked by a previous element in
--   the list.
keepFirst :: (a -> a -> Bool) -> [a] -> [a]

-- | These functions were inspired by the ML library accompanying the
--   Isabelle theorem prover (<a>http://isabelle.in.tum.de/</a>)
--   
--   swap the elements of a pair
swap :: (a, b) -> (b, a)

-- | sort the elements of a pair
sortPair :: Ord a => (a, a) -> (a, a)
isRight :: Either a b -> Bool
isLeft :: Either a b -> Bool

-- | Name values of a given type
type Named a = (String, a)

-- | Extend a list with the given separators to be flushed right.
flushRightBy :: [a] -> Int -> [a] -> [a]

-- | Extend a string with spaces to be flushed right.
flushRight :: Int -> String -> String

-- | Extend a list with the given separators to be flushed left.
flushLeftBy :: [a] -> Int -> [a] -> [a]

-- | Extend a string with spaces to be flushed left.
flushLeft :: Int -> String -> String

-- | marks a string as being a warning
warning :: String -> String

-- | abbreviation to print to stderr
putErr :: String -> IO ()

-- | abbreviation to println to stderr
putErrLn :: String -> IO ()

-- | Inject the elements of a list as alternatives.
oneOfList :: Alternative f => [a] -> f a

-- | Inject the elements of a set as alternatives.
oneOfSet :: Alternative f => Set a -> f a

-- | Inject the elements of a map as alternatives.
oneOfMap :: Alternative f => Map k v -> f (k, v)

-- | A monadic if statement
ifM :: Monad m => m Bool -> m a -> m a -> m a

-- | Gather all error free computations.
errorFree :: MonadPlus m => [m a] -> m [a]

-- | Gather all error free computations and ensure that at least one was
--   error free.
errorFree1 :: MonadPlus m => [m a] -> m [a]


-- | Simple table representation. This module is meant to be imported
--   qualified.
module Data.Table

-- | A column alignment.
data Alignment
AlignLeft :: Alignment
AlignRight :: Alignment

-- | A table with aligned rows.
data Table a
toList :: a -> Table a -> [[a]]

-- | The alignment for each column
alignments :: Table a -> IntMap Alignment

-- | The default alignment to be used for a row.
defaultAlignment :: Alignment

-- | The number of columns of the table.
columns :: Table a -> Int

-- | The number of rows of the table.
rows :: Table a -> Int

-- | Emtpy table.
empty :: Table a

-- | Convert a list of rows to a table.
fromList :: [[a]] -> Table a

-- | Add a new empty row to the table.
newRow :: Table a -> Table a

-- | Set the alignment of the given column.
setAlignment :: Int -> Alignment -> Table a -> Table a

-- | Append a cell at the end of the last row
appendCell :: a -> Table a -> Table a

-- | Append a cell containing a number; i.e. round and right align.
appendNumCell :: RealFrac a => Int -> a -> Table String -> Table String

-- | Retrieve the contents of a cell if it exists.
getCell :: (Int, Int) -> Table a -> Maybe a

-- | Set the contents of a cell.
setCell :: (Int, Int) -> a -> Table a -> Table a
headerLastCell :: a -> Table a -> Table a

-- | Set the alignemnt of the last cell.
alignLastCell :: Alignment -> Table a -> Table a

-- | Convert a table to the body of a LaTeX table.
toLaTeX :: (a -> String) -> Table a -> String
instance Eq Alignment
instance Ord Alignment
instance Show Alignment
instance Eq a => Eq (Table a)
instance Ord a => Ord (Table a)
instance Show a => Show (Table a)
instance Functor Table


-- | Generating Isabelle/ISAR theory files using <tt>Text.PrettyPrint</tt>.
module Text.Isar

-- | Values that can be output as ISAR code.
--   
--   Minimal definition: <a>isar</a>
class Isar a
isar :: Isar a => IsarConf -> a -> Doc

-- | The ISAR style to be used for output.
data IsarStyle
PlainText :: IsarStyle
XSymbol :: IsarStyle

-- | The configuration to be used for output. Apart from the ISAR style,
--   the configuration also stores the representation of the reachable
--   state of the protocol which we are reasoning about.
data IsarConf
IsarConf :: IsarStyle -> Doc -> Doc -> Doc -> IsarConf
isarStyle :: IsarConf -> IsarStyle

-- | The ISAR code of the trace
isarTrace :: IsarConf -> Doc

-- | The ISAR code of the thread pool
isarPool :: IsarConf -> Doc

-- | The ISAR code of the substitution
isarSubst :: IsarConf -> Doc

-- | Default configuration: plaintext ISAR style and reachable state
--   <tt>(t,r,s)</tt>.
defaultIsarConf :: IsarConf

-- | Check if the plaintext style was chosen.
isPlainStyle :: IsarConf -> Bool

-- | Output as ISAR code using <a>defaultIsarConf</a>.
isarPlain :: Isar a => a -> Doc

-- | Output as ISAR code using <a>defaultIsarConf</a> with the XSymbol
--   style.
isarXSymbol :: Isar a => a -> Doc

-- | Isabelle representation of the exeuction system state of our
--   operational semantics.
isaExecutionSystemState :: IsarConf -> Doc

-- | A short right arrow: <tt>-&gt;</tt>
isarightArrow :: Document d => IsarConf -> d

-- | A long double right arrow: <tt>==&gt;</tt>
isaLongRightArrow :: Document d => IsarConf -> d

-- | A left parenthesis with an additional vertical line: <tt>(|</tt>
isaLParr :: Document d => IsarConf -> d

-- | A right parenthesis with an additional vertical line: <tt>|)</tt>
isaRParr :: Document d => IsarConf -> d

-- | A left bracket with an additional vertical line: <tt>[|</tt>
isaLBrack :: Document d => IsarConf -> d

-- | A right bracket with an additional vertical line: <tt>|]</tt>
isaRBrack :: Document d => IsarConf -> d

-- | The meta all quantifier: <tt>!!</tt>
isaMetaAll :: Document d => IsarConf -> d

-- | The exists symbol: <tt>?</tt>
isaExists :: Document d => IsarConf -> d

-- | The logical and symbol: <tt>&amp;</tt>
isaAnd :: Document d => IsarConf -> d

-- | A 'not in' symbol: <tt>~:</tt>
isaNotIn :: Document d => IsarConf -> d

-- | An 'in' symbol: <tt>:</tt>
isaIn :: Document d => IsarConf -> d

-- | The non-strict subset symbol.
isaSubsetEq :: Document d => IsarConf -> d

-- | The greek letter alpha: <tt>\<a>alpha</a></tt>
isaAlpha :: Document d => IsarConf -> d

-- | The sublocale sign.
isaSublocale :: Document d => IsarConf -> d

-- | Nest a document surrounded by a leading and a finishing document
--   breaking lead, body, and finish onto separate lines, if they don't fit
--   on a single line.
nestBetween :: Document d => Int -> d -> d -> d -> d

-- | Nest a document surrounded by a leading and a finishing document with
--   an non-compulsory break between lead and body.
nestShort :: Document d => Int -> d -> d -> d -> d

-- | Nest document between two strings and indent body by <tt>length lead +
--   1</tt>.
nestShort' :: Document d => String -> String -> d -> d

-- | Like <a>nestShort</a> but doesn't print the lead and finish, if the
--   document is empty.
nestShortNonEmpty :: Document d => Int -> d -> d -> d -> d

-- | Like <a>nestShort'</a> but doesn't print the lead and finish, if the
--   document is empty.
nestShortNonEmpty' :: Document d => String -> String -> d -> d

-- | Output text with a fixed width: if it is smaller then nothing happens,
--   otherwise care is taken to make the text appear having the given
--   width.
fixedWidthText :: Document d => Int -> String -> d

-- | Print string as symbol having width 1.
symbol :: Document d => String -> d

-- | Number a list of documents that are vertically separated by the given
--   separator.
numbered :: Document d => d -> [d] -> d

-- | Number a list of documents with numbers terminated by <a>.</a> and
--   vertically separate using an empty line.
numbered' :: Document d => [d] -> d
instance Eq IsarStyle
instance Show IsarStyle
instance Show IsarConf


-- | Security protocol represented as a set of roles which are sequences of
--   send and receive steps.
module Scyther.Protocol

-- | An identifier.
newtype Id
Id :: String -> Id
getId :: Id -> String

-- | A message pattern.
data Pattern

-- | A global constant.
PConst :: Id -> Pattern

-- | A message to be freshly generated.
PFresh :: Id -> Pattern

-- | An agent variable.
PAVar :: Id -> Pattern

-- | A message variable.
PMVar :: Id -> Pattern

-- | Hashing
PHash :: Pattern -> Pattern

-- | Pairing
PTup :: Pattern -> Pattern -> Pattern

-- | Symmetric or asymmetric encryption (depent on the key).
PEnc :: Pattern -> Pattern -> Pattern

-- | A signature to be verified with the given key.
PSign :: Pattern -> Pattern -> Pattern

-- | A long-term unidirectional symmetric key.
PSymK :: Pattern -> Pattern -> Pattern

-- | A long-term bi-directional symmetric key.
PShrK :: Pattern -> Pattern -> Pattern

-- | A long-term public key.
PAsymPK :: Pattern -> Pattern

-- | A long-term private key
PAsymSK :: Pattern -> Pattern

-- | A label of a role step.
newtype Label
Label :: String -> Label
getLabel :: Label -> String

-- | A role step.
data RoleStep

-- | A send step.
Send :: Label -> Pattern -> RoleStep

-- | A receive step.
Recv :: Label -> Pattern -> RoleStep

-- | A role of a protocol. Its name has no operational meaning, but is
--   carried along to allow for human readable printing.
data Role
Role :: String -> [RoleStep] -> Role
roleName :: Role -> String
roleSteps :: Role -> [RoleStep]

-- | A protocol. As for roles, its name has no operational meaning, but is
--   carried along to allow for human readable printing.
data Protocol
Protocol :: String -> [Role] -> Protocol
protoName :: Protocol -> String
protoRoles :: Protocol -> [Role]

-- | An order relation on role steps of a role.
type RoleStepOrder = [((RoleStep, Role), (RoleStep, Role))]

-- | Free message variables of a pattern.
patFMV :: Pattern -> Set Id

-- | Free agent variables of a pattern.
patFAV :: Pattern -> Set Id

-- | Pattern subterms.
subpatterns :: Pattern -> Set Pattern

-- | Accessible pattern subterms.
patternparts :: Pattern -> Set Pattern

-- | Splitting top-level pairs.
splitpatterns :: Pattern -> Set Pattern

-- | Pattern of of a role step
stepPat :: RoleStep -> Pattern

-- | The string label of a role step.
stepLabel :: RoleStep -> String

-- | Frees message variables of a role step.
stepFMV :: RoleStep -> Set Id

-- | Frees agent variables of a role step.
stepFAV :: RoleStep -> Set Id

-- | Free message variables of a role.
roleFMV :: Role -> Set Id

-- | Free agent variables of a role.
roleFAV :: Role -> Set Id

-- | Find a role step in a role according to its label.
lookupRoleStep :: String -> Role -> Maybe RoleStep

-- | Check if a role is well-formed; i.e., all steps are distinct, no
--   message variable is sent before it is received, and patterns do not
--   contain long-term-keys in accessible positions.
wfRole :: Role -> [ProtoIllformedness]

-- | The order of role steps as they are given in the role.
roleOrd :: Role -> RoleStepOrder

-- | Find a role in a protocol according to its name.
lookupRole :: String -> Protocol -> Maybe Role

-- | The name of the locale assuming a reachable state of the given
--   protocol.
stateLocale :: Protocol -> String

-- | The name of the locale assuming a reachable state satisfying the
--   axioms of the theory.
restrictedStateLocale :: Protocol -> String

-- | The name of the locale assuming weak atomicity of the given protocol.
weakAtomicityLocale :: Protocol -> String

-- | The name of the weak atomicity type invariant of the given protocol.
weakAtomicityInvariant :: Protocol -> String

-- | The order of role steps in the protocol such that every send step is
--   occurs before every receive step having the same label.
labelOrd :: Protocol -> RoleStepOrder

-- | The combination of all role orders and the label order of the
--   protocol.
protoOrd :: Protocol -> RoleStepOrder
data ProtoIllformedness

-- | Check if a protocol is well-formed; i.e., all roles are well-formed.
wfProto :: Protocol -> [ProtoIllformedness]

-- | Pretty print a protocol ill-formedness.
sptProtoIllformedness :: ProtoIllformedness -> Doc

-- | Pretty print a rolestep in ISAR format. If a role is given, then the
--   label of the role step in this role is used to abbreviate the step
--   name.
isaRoleStep :: IsarConf -> Maybe Role -> RoleStep -> Doc
sptId :: Id -> Doc
sptLabel :: Label -> Doc
sptPattern :: Pattern -> Doc

-- | Pretty print a rolestep. If a role is given, then the label of the
--   role step in this role is used to abbreviate the step name.
sptRoleStep :: Maybe Role -> RoleStep -> Doc

-- | Pretty print a role in SP theory format.
sptRole :: Role -> Doc

-- | Pretty print a protocol in SP theory format.
sptProtocol :: Protocol -> Doc
instance Typeable Id
instance Typeable Pattern
instance Typeable Label
instance Typeable RoleStep
instance Typeable Role
instance Typeable Protocol
instance Eq Id
instance Ord Id
instance Data Id
instance Eq Pattern
instance Ord Pattern
instance Show Pattern
instance Data Pattern
instance Eq Label
instance Ord Label
instance Show Label
instance Data Label
instance Eq RoleStep
instance Ord RoleStep
instance Show RoleStep
instance Data RoleStep
instance Eq Role
instance Ord Role
instance Show Role
instance Data Role
instance Eq Protocol
instance Ord Protocol
instance Show Protocol
instance Data Protocol
instance Eq ProtoIllformedness
instance Ord ProtoIllformedness
instance Show ProtoIllformedness
instance Isar Protocol
instance Isar Role
instance Isar RoleStep
instance Isar Pattern
instance Isar Label
instance Isar Id
instance Show Id


-- | The actual messages being sent and received over the network are
--   always ground. Here we develop a representation of the denotations of
--   actual messages that may occur during a security proof. This involves
--   symbolically instantiated variables and symbolically inverted keys.
module Scyther.Message

-- | A logical variable for a thread identifier. Note that these are the
--   only free logical variables being used during proofs. Depending on
--   their context they are either universally or existentially quantified.
newtype TID
TID :: Int -> TID
getTID :: TID -> Int

-- | A local identifier.
newtype LocalId
LocalId :: (Id, TID) -> LocalId
getLocalId :: LocalId -> (Id, TID)

-- | A fresh message.
newtype Fresh
Fresh :: LocalId -> Fresh
getFresh :: Fresh -> LocalId

-- | An agent variable.
newtype AVar
AVar :: LocalId -> AVar
getAVar :: AVar -> LocalId

-- | A message variable.
newtype MVar
MVar :: LocalId -> MVar
getMVar :: MVar -> LocalId

-- | An agent name identifier
newtype AgentId
AgentId :: Int -> AgentId
agentId :: AgentId -> Int

-- | Denotations of messages as they occurr during reasoning. Note that we
--   do not model agents, as in the proofs that we want to do no actual
--   agent reference will be needed.
--   
--   Note: This is <i>no free algebra</i> due to the nested equalities on
--   thread identifiers and the key-inversion function. However, there is
--   still a most general unifier. The easiest way to understand these
--   messages is to map them to the corresponding Isabelle proof states.
data Message

-- | A global constant.
MConst :: Id -> Message

-- | A freshly generated message.
MFresh :: Fresh -> Message

-- | A symbolically instantiated agent variable.
MAVar :: AVar -> Message

-- | A symbolically instantiated message variable;
MMVar :: MVar -> Message

-- | Some agent name <tt>MVar (LocalId (Id "v", TID 1))</tt> corresponds to
--   <tt>s(|MV ''v'' tid1|)</tt>.
MAgent :: AgentId -> Message

-- | Hashing
MHash :: Message -> Message

-- | Pairing
MTup :: Message -> Message -> Message

-- | Encryption or signing depending on the key (the second argument)
MEnc :: Message -> Message -> Message

-- | A long-term uni-directional symmetric key
MSymK :: Message -> Message -> Message

-- | A long-term bi-directional symmetric key.
MShrK :: Message -> Message -> Message

-- | A long-term asymmetric public key.
MAsymPK :: Message -> Message

-- | A long-term asymmetric private key.
MAsymSK :: Message -> Message

-- | An application of the key inversion function.
MInvKey :: Message -> Message

-- | Identifier of a local id.
lidId :: LocalId -> Id

-- | Thread identifier of a local id.
lidTID :: LocalId -> TID

-- | The thread corresponding to an agent variable
avarTID :: AVar -> TID

-- | The thread corresponding to an message variable
mvarTID :: MVar -> TID

-- | Free message variables of a message.
msgFMV :: Message -> [MVar]

-- | Fresh messages of a message.
msgFresh :: Message -> [Fresh]

-- | Agent identifiers of a message.
msgAgentIds :: Message -> [AgentId]

-- | Thread identifiers of a message.
msgTIDs :: Message -> [TID]

-- | A message is trivial iff it is a tuple or it is guaranteed to be in
--   the initial intruder knowledge (i.e., global constants and agent
--   variables).
--   
--   PRE: Message must be normalized.
trivial :: Message -> Bool

-- | The submessages of message.
submessages :: Message -> Set Message

-- | The accessible submessages of message.
messageparts :: Message -> Set Message
mapFresh :: (LocalId -> LocalId) -> Fresh -> Fresh
mapAVar :: (LocalId -> LocalId) -> AVar -> AVar
mapMVar :: (LocalId -> LocalId) -> MVar -> MVar

-- | Instantiate a pattern to a message. Variables are instantiated
--   symbolically. The resulting message is guaranteed to be normalized
--   w.r.t <a>normMsg</a>.
inst :: TID -> Pattern -> Message

-- | Normalize a message; i.e., apply key-inversion if possible and swap
--   shared key arguments, if required.
normMsg :: Message -> Message

-- | Splits a message into the list of non-<a>trivial</a> messages
--   accessible using projection only.
--   
--   Postcondition: All messages in the list are non-<a>trivial</a>.
splitNonTrivial :: Message -> [Message]
sptTID :: TID -> Doc
sptAgentId :: AgentId -> Doc
sptFresh :: Fresh -> Doc
sptAVar :: AVar -> Doc
sptMVar :: MVar -> Doc
sptMessage :: Message -> Doc
instance Typeable TID
instance Typeable AgentId
instance Typeable LocalId
instance Typeable AVar
instance Typeable MVar
instance Typeable Fresh
instance Typeable Message
instance Eq TID
instance Ord TID
instance Enum TID
instance Num TID
instance Data TID
instance Eq AgentId
instance Ord AgentId
instance Enum AgentId
instance Num AgentId
instance Data AgentId
instance Eq LocalId
instance Ord LocalId
instance Data LocalId
instance Eq AVar
instance Ord AVar
instance Show AVar
instance Data AVar
instance Eq MVar
instance Ord MVar
instance Show MVar
instance Data MVar
instance Eq Fresh
instance Ord Fresh
instance Show Fresh
instance Data Fresh
instance Eq Message
instance Ord Message
instance Show Message
instance Data Message
instance Isar Message
instance Isar MVar
instance Isar AVar
instance Isar Fresh
instance Isar LocalId
instance Isar AgentId
instance Isar TID
instance Show LocalId
instance Show AgentId
instance Show TID

module Scyther.Equalities

-- | Equalities over thread identifers.
--   
--   Logically these are equalities between logical thread identifier
--   variables.
type TIDEq = (TID, TID)

-- | A thread to role assignment.
type TIDRoleEq = (TID, Role)

-- | The role equalities serve a double function:
type RoleEq = (Role, Role)
type AgentEqRHS = Either AgentId AVar
type AgentEq = (AgentId, AgentEqRHS)

-- | Equalities between different agent variables.
--   
--   We do not have to reason about equalities between an agent variable
--   and some other message because our semantics guarantees that agent
--   variables are only instantiated with agent names. Hence, they can only
--   be equal to other agent variables or message variables. In the latter
--   case, we store the equality the other way round; assigning the agent
--   variable to the message variable.
type AVarEq = (AVar, AVar)

-- | Equalities between message variables and arbitrary messages.
type MVarEq = (MVar, Message)

-- | Equalities between messages.
type MsgEq = (Message, Message)

-- | Some representable equality.
data AnyEq
TIDEq :: !TIDEq -> AnyEq
TIDRoleEq :: !TIDRoleEq -> AnyEq
RoleEq :: !RoleEq -> AnyEq
AgentEq :: !AgentEq -> AnyEq
AVarEq :: !AVarEq -> AnyEq
MVarEq :: !MVarEq -> AnyEq
MsgEq :: !MsgEq -> AnyEq

-- | Convert an agent equality to a message equality.
agentEqToMsgEq :: AgentEq -> MsgEq

-- | Convert a message variable equallity to a message equality.
mvarEqToMsgEq :: MVarEq -> MsgEq

-- | A conjunction of equality facts.
--   
--   Invariants for a value <tt>eqs = Equalities tideqs roleeqs avareqs
--   mvareqs agnteqs</tt>:
--   
--   <ol>
--   <li>Domain and range normalized with respect to equalities. Note that
--   this implies substitution must always consider TID substitution
--   first.</li>
--   </ol>
--   
--   forall tid : ran(tideqs). substTID eqs tid = tid forall tid :
--   dom(roleeqs). substTID eqs tid = tid forall (lid, lid') : avareqs.
--   substLocalId eqs lid = lid &amp; substAVar eqs lid' = lid' forall
--   (lid, m) : mvareqs. substLocalId eqs lid = lid &amp; substMsg eqs m =
--   m
--   
--   TODO: Complete properties for Agent ID's
--   
--   forall aid : dom(agnteqs). substAgentId eqs aid = Just (Left aid)
--   forall : dom(agnteqs). substAgentId eqs aid = Just (Left aid)
--   
--   <ol>
--   <li>Origin always greater than image for symmetric eqs.</li>
--   </ol>
--   
--   forall (tid, tid') : tideqs. tid &gt; tid' forall (lid, lid') :
--   avareqs. lid &gt; lid'
--   
--   <ol>
--   <li>Range of message variable equalities normalized with respect to
--   key inversion.</li>
--   </ol>
--   
--   forall m : ran(mvareqs). normMsg m = m
--   
--   <ol>
--   <li>All thread identifiers are in the domain of roleeqs.</li>
--   <li>All agent identifiers are in the domain of agnteqs.</li>
--   <li>No cycles.</li>
--   </ol>
data Equalities

-- | Empty equality premises.
empty :: Equalities

-- | Solve a list of unification equations.
--   
--   The unification is performed modulo key inversion and thread
--   identifier equalities. Additional thread identifier equalities may
--   result from equalities over fresh messages. Bidirectional keys are
--   handled by delaying their solution until only one solution is
--   possible.
solve :: Monad m => [AnyEq] -> Equalities -> m Equalities

-- | Remove the thread identifier equalities. This is logically safe iff
--   there is no fact outside the equalities that still refers to the
--   dropped thread identifiers.
trimTIDEqs :: Equalities -> ([TID], Equalities)

-- | Remove the agent identifiers equalities. This is logically safe iff
--   there is no fact outside the equalities that still refers to the
--   dropped agent identifiers.
trimAgentEqs :: Equalities -> ([AgentId], Equalities)

-- | The list of thread identifier equalities.
getTIDEqs :: Equalities -> [TIDEq]

-- | The list of role equalities.
getTIDRoleEqs :: Equalities -> [TIDRoleEq]

-- | The list of agent variable equalities.
getAgentEqs :: Equalities -> [AgentEq]

-- | The list of agent variable equalities.
getAVarEqs :: Equalities -> [AVarEq]

-- | The list of message variable equalities.
getMVarEqs :: Equalities -> [MVarEq]

-- | The list of postponed message equalities.
getPostEqs :: Equalities -> [MsgEq]

-- | Convert a set of equalities to a list of equalities.
--   
--   POST: Order of equalities equal to order in result of <a>toLists</a>.
toAnyEqs :: Equalities -> [AnyEq]

-- | The threads occurring in an equality.
anyEqTIDs :: AnyEq -> [TID]

-- | Substitute a thread identifier according to thread identifier
--   equalities.
substTID :: Equalities -> TID -> TID

-- | Substitute a local identifier according to thread identifier
--   equalities.
substLocalId :: Equalities -> LocalId -> LocalId

-- | Substitute a local identifier belonging to an agent variable.
substAVar :: Equalities -> AVar -> AVar

-- | Substitute a local identifier belonging to a message variable.
substMVar :: Equalities -> MVar -> Message

-- | Substitute an agent id representing an arbitrary agent name.
substAgentId :: Equalities -> AgentId -> AgentEqRHS

-- | Substitute the right-hand-side of an agent id equality.
substAgentEqRHS :: Equalities -> AgentEqRHS -> AgentEqRHS

-- | Substitute message constituents according to equalities.
--   
--   POST: Message normalized w.r.t. <a>normMsg</a>.
substMsg :: Equalities -> Message -> Message

-- | Substitute both sides of a representable equality.
substAnyEq :: Equalities -> AnyEq -> AnyEq

-- | Retrieve the role of a thread.
threadRole :: TID -> Equalities -> Maybe Role

-- | The maximal mapped thread identifier.
maxMappedTID :: Equalities -> Maybe TID

-- | The maximal mapped agent identifier.
maxMappedAgentId :: Equalities -> Maybe AgentId

-- | Check if an equality is reflexive.
reflexive :: AnyEq -> Bool

-- | True if no equalities are present.
null :: Equalities -> Bool
newtype Mapping
Mapping :: Equalities -> Mapping
getMappingEqs :: Mapping -> Equalities

-- | An empty mapping.
emptyMapping :: Mapping

-- | A mapping of logical variables and the corresponding substitution can
--   be represented as an abstract Equalities value. However, it violates
--   the invariant that the domain of the equalities must be invariant
--   under substitution. This is OK, as domain and range of a mapping are
--   from different logical contexts.
mkMapping :: Map TID TID -> Map AgentId AgentId -> Mapping

-- | Add a mapping from one thread identifier to another one, possibly
--   overriding an existing mapping.
addTIDMapping :: TID -> TID -> Mapping -> Mapping

-- | Add a mapping from one thread identifier to another one, possibly
--   overriding an existing mapping.
addAgentIdMapping :: AgentId -> AgentId -> Mapping -> Mapping

-- | Add a mapping from one thread identifier to an other role, possibly
--   overriding an existing mapping.
addTIDRoleMapping :: TID -> Role -> Mapping -> Mapping

-- | Delete the mapping of the given thread identifier.
deleteTIDMapping :: TID -> Mapping -> Mapping

-- | Delete the mapping of the given agent identifier.
deleteAgentIdMapping :: AgentId -> Mapping -> Mapping
sptAnyEq :: AnyEq -> Doc
instance Typeable AnyEq
instance Typeable Equalities
instance Typeable Mapping
instance Eq AnyEq
instance Ord AnyEq
instance Show AnyEq
instance Data AnyEq
instance Eq Equalities
instance Ord Equalities
instance Show Equalities
instance Data Equalities
instance Eq Mapping
instance Ord Mapping
instance Show Mapping
instance Data Mapping
instance Isar AnyEq


-- | Symbolic events that we are reasoning about
module Scyther.Event

-- | The logical denotation of an event of the execution of a security
--   protocol.
data Event

-- | The thread executed the role step.
Step :: TID -> RoleStep -> Event

-- | The message was learnt by the intruder.
Learn :: Message -> Event

-- | Substitute an event according to the equalities.
substEv :: Equalities -> Event -> Event

-- | Substitute an event order according to the equalities.
substEvOrd :: Equalities -> (Event, Event) -> (Event, Event)

-- | The threads associated to an event.
evTIDs :: Event -> [TID]

-- | The threads associated to an event order.
evOrdTIDs :: (Event, Event) -> [TID]

-- | The event order induced by the trace of the reachable state we are
--   reasoning about.
type EventOrder = Set (Event, Event)

-- | Is the event order cyclic?
cyclic :: EventOrder -> Bool

-- | Must an event have happened before another one with respect to the
--   given event order.
--   
--   <i>before evord from to</i> holds iff the event order <i>evord</i>
--   implies that the event <i>from</i> must have happened before the event
--   <i>to</i> in the reachable state we are reasoning about.
before :: EventOrder -> Event -> Event -> Bool

-- | Render an event in the Isar format.
isaEvent :: IsarConf -> Mapping -> Event -> Doc

-- | Render an event order in the Isar format. See <a>isaEvent</a> for an
--   explanation of the mapping.
isaEventOrd :: IsarConf -> Mapping -> (Event, Event) -> Doc

-- | Render a fact that an event happened in security protocol theory
--   format.
sptEvent :: Mapping -> Event -> Doc

-- | Render an event in security protocol theory format without any added
--   tagging; i.e. learned messages are rendered as is, and executed steps
--   are rendered as a tuple of thread identifier and role step
--   (abbreviated if possible).
sptRawEvent :: Mapping -> Event -> Doc

-- | Render an event order in security protocol theory format.
sptEventOrd :: Mapping -> [Event] -> Doc
instance Typeable Event
instance Eq Event
instance Ord Event
instance Show Event
instance Data Event
instance Isar Event


-- | Building typing invariants for security protocol in order to enable
--   verification in an untyped model.
module Scyther.Typing
data Type
AgentT :: Type
ConstT :: Id -> Type
NonceT :: Role -> Id -> Type
HashT :: Type -> Type
EncT :: Type -> Type -> Type
TupT :: Type -> Type -> Type
SymKT :: Type -> Type -> Type
AsymPKT :: Type -> Type
AsymSKT :: Type -> Type
KnownT :: RoleStep -> Type
SumT :: Type -> Type -> Type

-- | A type assignment for variables of several roles.
data Typing
WeaklyAtomic :: Typing
Typing :: (Map (Id, Role) Type) -> Typing

-- | Compute a typing from the message sequence chart of the protocol
--   implicitly given by the corresponding labels.
--   
--   FIXME: This is quite a hack and could be done much better: do it!
mscTyping :: Protocol -> Maybe Typing

-- | Pretty print a type in Isar syntax; paramatrized over the role of the
--   variable that this type describes. This role is used for abbreviating
--   role steps by the <tt>role_label</tt> constant symbols defined in
--   Isabelle.
isaType :: IsarConf -> Maybe Role -> Type -> Doc

-- | Pretty print a type that may be a weak atomicity type.
isaOptType :: IsarConf -> Maybe Role -> Maybe Type -> Doc

-- | Pretty print a type in security protocol theory format. If the role is
--   given then the type describes a variable of this role. The steps of
--   this role are abbreviated accordingly.
sptType :: Maybe Role -> Type -> Doc

-- | Pretty print a type that may be a weak atomicity type in the security
--   protocol theory format.
sptOptType :: Maybe Role -> Maybe Type -> Doc
sptTyping :: Typing -> Doc
instance Typeable Type
instance Typeable Typing
instance Eq Type
instance Ord Type
instance Show Type
instance Data Type
instance Eq Typing
instance Ord Typing
instance Show Typing
instance Data Typing
instance Isar Typing
instance Isar Type

module Scyther.Formula

-- | A representable logical atom.
data Atom

-- | <a>False</a> in Isabelle.
AFalse :: Atom

-- | An equality
AEq :: AnyEq -> Atom

-- | An event must have happened.
AEv :: Event -> Atom

-- | An event order.
AEvOrd :: (Event, Event) -> Atom

-- | A compromised agent variable.
ACompr :: Message -> Atom

-- | An uncompromised agent variable.
AUncompr :: Message -> Atom

-- | A claim that a variable is of the given type; Nothing stands for
--   weakly-atomic.
AHasType :: MVar -> (Maybe Type) -> Atom

-- | A claim that the current state of a protocol is approximated by the
--   given typing.
ATyping :: Typing -> Atom

-- | A claim that the current state is reachable.
AReachable :: Protocol -> Atom

-- | A representable logical formula. Currently these are monotonic
--   formula.
data Formula
FAtom :: Atom -> Formula
FConj :: Formula -> Formula -> Formula
FExists :: (Either TID AgentId) -> Formula -> Formula

-- | Substitute all variables in an atom.
--   
--   NOTE: A <tt>HasType</tt> atom will only have its thread identifier
--   substituted, but not the whole message variable.
substAtom :: Equalities -> Atom -> Atom

-- | Relabel quantified TIDs according to the given list of labels.
relabelTIDs :: [TID] -> Formula -> Formula

-- | True iff the formula does contain an existential quantifier.
hasQuantifiers :: Formula -> Bool

-- | Split all toplevel conjunctions.
conjuncts :: Formula -> [Formula]

-- | Convert a formula consisting of conjunctions only to a list of atoms.
--   Uses <a>fail</a> for error reporting.
conjunctionToAtoms :: MonadPlus m => Formula -> m [Atom]

-- | A formula is a single atom claiming well-typedness.
isTypingFormula :: Formula -> Bool

-- | Extract the typing from a singleton well-typedness formula.
destTypingFormula :: Formula -> Maybe Typing

-- | Compute the threads associated to the given atom.
atomTIDs :: Atom -> [TID]

-- | Find the first conjoined thread to role equality for this thread, if
--   there is any.
findRole :: TID -> Formula -> Maybe Role

-- | A compromised agent variable in Isar format.
isaCompr :: IsarConf -> Message -> Doc

-- | An uncompromised agent variable in Isar format.
isaUncompr :: IsarConf -> Message -> Doc

-- | Pretty print an atom in security protocol theory format.
sptAtom :: Mapping -> Atom -> Doc

-- | Pretty print an atom in Isar format.
isaAtom :: IsarConf -> Mapping -> Atom -> Doc

-- | A formula in Isar format.
isaFormula :: IsarConf -> Mapping -> Formula -> Doc

-- | A formula in security protocol theory format.
sptFormula :: Mapping -> Formula -> Doc
instance Typeable Atom
instance Typeable Formula
instance Eq Atom
instance Show Atom
instance Ord Atom
instance Data Atom
instance Eq Formula
instance Show Formula
instance Ord Formula
instance Data Formula


-- | Conjunctions of the logical facts needed during a proof using
--   decryption chain reasoning.
module Scyther.Facts

-- | A conjunction of logical facts.
--   
--   Invariants that hold for a value <tt>facts = Facts _ evs evord co uc
--   eqs</tt>:
--   
--   <ol>
--   <li>All facts are invariant under their corresponding substitution.
--   This excludes the quantifiers, as they are no facts.</li>
--   <li>All trivial learn events are removed (or split in case of a
--   pair).</li>
--   </ol>
--   
--   We assume that all thread identifiers that are assigned to a role are
--   locally quantified. The kind of quantification depends on the context.
--   If the set of facts models the premises of a proof state then this
--   would be universal quantification. If the set of facts models an
--   authentication conclusion this would be existential quantification.
data Facts

-- | The protocol that the current state is a reachable state of.
protocol :: Facts -> Protocol

-- | Empty set of facts; logically equivalent to true.
empty :: Protocol -> Facts

-- | Get a fresh TID and the updated set of facts.
freshTID :: Facts -> (TID, Facts)

-- | Get a fresh AgentId and the updated set of facts.
freshAgentId :: Facts -> (AgentId, Facts)

-- | Tries to quantify the given thread identifier. If it is already
--   quantified <a>fail</a> is called in the given monad.
quantifyTID :: Monad m => TID -> Facts -> m Facts

-- | Tries to quantify the given agent identifier. If it is already
--   quantified <a>fail</a> is called in the given monad.
quantifyAgentId :: Monad m => AgentId -> Facts -> m Facts

-- | Build the conjunction of the atoms and the facts; a result of
--   <a>Nothing</a> means that the conjunction is logically equivalent to
--   False. This will occur in case <a>AFalse</a> is conjoined or an
--   equality that cannot be unified.
--   
--   PRE: The atom must pass certification under the given facts.
--   
--   PRE: The atom must not be a <tt>AHasTyp</tt> or a <a>ATyping</a> atom,
--   as they are not representable by <a>Facts</a>
conjoinAtoms :: Monad m => [Atom] -> Facts -> m (Maybe Facts)

-- | Set the typing.
--   
--   PRE: There mustn't be a different existing typing.
--   
--   Uses <a>fail</a> for error reporting.
setTyping :: Monad m => Typing -> Facts -> m Facts

-- | True if no premises apart from state reachability and the optional
--   well-typedness claim are present. Note that there may be quantifiers
--   and covered goals.
nullFacts :: Facts -> Bool

-- | Possible unifiers making the first set of facts provable under the
--   second set of facts. resulting equalities describe the mapping from
--   all logical variables of the first set of facts logical variables of
--   the second set of facts.
--   
--   NOTE: You may want to use <a>trimQuantifiers</a> before using this
--   function to avoid getting superfluous unifiers.
freeVariableMappings :: Facts -> Facts -> [Mapping]
proveFacts :: Facts -> Facts -> Mapping -> Bool

-- | Check if a set of facts is trivially contradictory.
--   
--   NOTE: This is not the same as trying to prove the atom AFalse under
--   these premises. The checks are separated due to efficiency reasons.
proveFalse :: Facts -> Bool

-- | True iff the facts imply the validity of the given atom. Note that
--   this check is incomplete; i.e. there may be atoms that would be true
--   under these facts, but are not detected as such.
--   
--   PRE: Trivial learn events must be split. You may achieve this using
--   <a>removeTrivialFacts</a>.
proveAtom :: Facts -> Atom -> Bool

-- | Try to prove that the formula holds under these facts.
proveFormula :: Facts -> Formula -> Bool

-- | Represent the facts as a set of atoms.
toAtoms :: Facts -> [Atom]

-- | The next free thread identifier
nextTID :: Facts -> TID

-- | The next free agent identifier
nextAgentId :: Facts -> AgentId

-- | The list of thread ids that are quantified.
quantifiedTIDs :: Facts -> [TID]

-- | Substitute an event.
substEv :: Facts -> Event -> Event

-- | The role assigned to a thread.
threadRole :: TID -> Facts -> Maybe Role

-- | Create a mapping from the equalities of the facts.
eqsToMapping :: Facts -> Mapping

-- | Apply the mapping of agent and thread equalities to the facts.
--   
--   TODO: Improve error handling. Currently, <a>error</a> is called if the
--   facts are contradictory after the substitution.
applyMapping :: Mapping -> Facts -> Facts

-- | Sort open messages ascending with respect to the maximal thread id.
oldestOpenMessages :: Facts -> [Message]

-- | Apply the chain rule to a message in the context of a protocol and a
--   set of established facts. Returns the list of facts corresponding to
--   the disjunctions in the conclusion of the chain rule, which are not
--   trivially false due to syntactic inequality.
chainRuleFacts :: MonadPlus m => Message -> Facts -> m [((String, [Either TID AgentId]), Facts)]

-- | Saturate facts modulo removal of trivial facts; i.e. apply all rules
--   except the chain rule eagerly and remove trivial facts.
saturateFacts :: Facts -> Facts

-- | Make use of the typing assumption by checking for instantiated message
--   variables if their instantiation does not agree with the structural
--   type and hence they must be known before the given step.
--   
--   Is equal to <a>mzero</a> in case the facts don't contain a typing.
exploitTypingFacts :: MonadPlus m => Facts -> m Facts

-- | Try to find a long-term-key that must be secret due to the
--   uncompromisedness assumptions, but is claimed to be known to the
--   intruder; i.e. if this method returns a message, then the premises are
--   contradictory.
exploitLongTermKeySecrecy :: Facts -> Maybe Message

-- | Equalities that can be splitted.
splittableEqs :: Facts -> [MsgEq]

-- | Split an equality between bi-directional symmetric shared keys.
splitEqFacts :: MsgEq -> Facts -> [Maybe Facts]

-- | Pretty print the facts in Isar format.
isaFacts :: IsarConf -> Facts -> ([Doc], [Doc], [Doc])

-- | Pretty print the facts in security protocol theory format.
sptFacts :: Facts -> ([Doc], [Doc], [Doc])
instance Typeable Facts
instance Eq Facts
instance Ord Facts
instance Show Facts
instance Data Facts
instance Eq a => Eq (Cert a)
instance Ord a => Ord (Cert a)
instance Show a => Show (Cert a)

module Scyther.Sequent

-- | A sequent with a conjunction of a set of facts as the premise and a
--   single formula as the conclusion denoting a statement about a
--   reachable state of a protocol.
data Sequent
Sequent :: Facts -> Formula -> Sequent
sePrem :: Sequent -> Facts
seConcl :: Sequent -> Formula

-- | The protocol of a sequent.
seProto :: Sequent -> Protocol

-- | The named list of sequents which need to be proven in order to prove
--   that the given protocol is well typed or weakly-atomic
--   
--   PRE: The conclusion of the sequent must be typing atom.
--   
--   Uses <a>fail</a> for error reporting.
wellTypedCases :: MonadPlus m => Sequent -> m [(String, Sequent)]

-- | Try to saturate a sequent, if possible and leading to new facts.
saturate :: MonadPlus m => Sequent -> m Sequent

-- | Like <a>fruleInst</a> but tries all mappings.
frule :: MonadPlus m => Sequent -> Sequent -> m (Mapping, Maybe Sequent)

-- | Emulate a variant Isabelle's <a>frule</a> tactic. It works only if the
--   given maping of free variables of the rule makes the premise of the
--   rule provable under the given proof state. Then, the conclusion of the
--   rule with free variables mapped accordingly is added to premises of
--   the proof state. The last step works currently only for conclusions
--   being false of pure conclusions.
--   
--   NOTE that <a>frule</a> works only for rules that contain no
--   existential quantifiers in the conclusion.
fruleInst :: MonadPlus m => Sequent -> Mapping -> Sequent -> m (Maybe Sequent)

-- | Try to use the chain rule.
--   
--   MonadPlus is used to report a failure to apply the rule.
chainRule :: MonadPlus m => Sequent -> Message -> m [((String, [Either TID AgentId]), Sequent)]

-- | Split a splittable equality. splitting can be done.
splitEq :: MsgEq -> Sequent -> [Maybe Sequent]

-- | Try to exploit the typing. Fails if no new facts could be derived.
exploitTyping :: MonadPlus m => Sequent -> m Sequent

-- | Make all thread identifiers occurring in the sequent unique by
--   consistently relabeling the thread identifiers in the conclusion.
uniqueTIDQuantifiers :: Sequent -> Sequent
instance Typeable Sequent
instance Eq Sequent
instance Show Sequent
instance Ord Sequent
instance Data Sequent


-- | .dot file generation for elements of a security protocol theory.
module Scyther.Theory.Dot

-- | Dot a sequent with some marked events.
dotSequentMarked :: Set Event -> Sequent -> Dot ()

-- | Convert a protocol to a dot graph.
dotProtocol :: Protocol -> Dot ()

-- | Convert a .dot file to a .png file using the dot tool.
graphvizDotToPng :: FilePath -> FilePath -> FilePath -> Chan String -> IO ()


-- | A representation for proofs constructed using our security protocol
--   verification theory.
module Scyther.Proof

-- | A proof of a sequent.
data Proof

-- | Assumed as an axiom.
Axiom :: Sequent -> Proof

-- | A possible attack on the given sequent.
PossibleAttack :: Sequent -> Sequent -> Proof

-- | A missing proof and the reason why it is missing plus a flag for
--   displaying the sequent.
Missing :: Sequent -> String -> Bool -> Proof

-- | A trivial proof for the sequent and the reason why it is trivial.
Trivial :: Sequent -> TrivReason -> Proof

-- | An application of a rule/theorem and the proofs for all the resulting
--   sequents.
RuleApp :: Sequent -> Rule -> [Proof] -> Proof

-- | Triviality reasons.
data TrivReason
TrivContradictoryPremises :: TrivReason
TrivPremisesImplyConclusion :: TrivReason
TrivLongTermKeySecrecy :: Message -> TrivReason

-- | Supported rules.
data Rule
Saturate :: Rule
ForwardResolution :: (Named Sequent) -> Mapping -> Rule
ChainRule :: Message -> [(String, [Either TID AgentId])] -> Rule
SplitEq :: MsgEq -> [Bool] -> Rule
TypingCases :: [String] -> Rule

-- | Use a (possibly bounded) depth-first search for finding the proof.
--   TODO: Make error handling explicit.
dfsProof :: Maybe Int -> (Facts -> [Message]) -> [Named Sequent] -> Sequent -> Maybe Proof

-- | Use branch-and-bound search to find the shortest proof. TODO: Make
--   error handling explicit.
shortestProof :: Maybe Int -> (Facts -> [Message]) -> [Named Sequent] -> Sequent -> Maybe Proof

-- | Minimize a proof by removing all unnecesary forward resolutions.
minimizeProof :: Proof -> Proof

-- | Map the sequents of the proof.
mapProofSequents :: (Sequent -> Sequent) -> Proof -> Proof

-- | Extract the proven sequent from a proof.
prfSequent :: Proof -> Sequent

-- | Extract the protocol concerned by a proof.
prfProto :: Proof -> Protocol

-- | True iff the proof is an axiom definition.
--   
--   NOTE: This checks only if the proof is directly by axiom.
isAxiomProof :: Proof -> Bool

-- | True iff the proof is trivial.
isTrivialProof :: Proof -> Bool

-- | A proof is complete iff no <a>Missing</a> proof or
--   <a>PossibleAttack</a> is part of it.
complete :: Proof -> Bool

-- | A proof is sound iff it is complete and each inference step is sound.
sound :: Proof -> Bool

-- | Output the set of theorems a proof depends on.
depends :: Proof -> Set (String, Protocol)

-- | Extracts the first type invariant occurring in a forward resolution.
--   This is required because in Isabelle type invariants are handled using
--   locales, while we are handling them using forward resolution.
--   
--   Note that our system here is more general, but for the current setup,
--   we do not see this generality.
extractTypeInvariant :: Proof -> Maybe (Named Typing)

-- | Proof size datatype counting number of chain rule applications and the
--   number of forward resolutions. The <a>Monoid</a> instance corresponds
--   to adding proof sizes.
data ProofSize

-- | Extract the raw proof size information.
getProofSize :: ProofSize -> (Int, Int, Int)

-- | The size of a missing proof.
missingProofSize :: ProofSize

-- | Compute the size of a proof.
proofSize :: Proof -> ProofSize

-- | Check if there exists a case where the prover gets stuck using
--   unbounded DFS and the given heuristic and theorems to reuse.
existsPossibleAttack :: (Facts -> [Message]) -> [Named Sequent] -> Sequent -> Maybe Proof
displayChainRule :: Protocol -> Maybe Typing -> Proof
instance Typeable TrivReason
instance Typeable Rule
instance Typeable Proof
instance Eq TrivReason
instance Show TrivReason
instance Data TrivReason
instance Eq Rule
instance Show Rule
instance Data Rule
instance Eq Proof
instance Show Proof
instance Data Proof
instance Eq ProofSize
instance Ord ProofSize
instance Monoid ProofSize
instance Show ProofSize

module Scyther.Theory

-- | A theorem is just a named proof.
type Theorem = Named Proof

-- | The protocol of a theorem.
thmProto :: Theorem -> Protocol

-- | The name of a theorem.
thmName :: Theorem -> String

-- | The sequent of a theorem.
thmSequent :: Theorem -> Sequent

-- | The proof of a theorem.
thmProof :: Theorem -> Proof

-- | Check if a theorem is an axiom.
isAxiom :: Theorem -> Bool

-- | A theory item is a (meta-)logical fact representable by our security
--   protocol theory.
data ThyItem
ThyProtocol :: Protocol -> ThyItem
ThySequent :: (Named Sequent) -> ThyItem
ThyTheorem :: (Named Proof) -> ThyItem
ThyText :: String -> ThyItem
data Theory
Theory :: String -> [ThyItem] -> Theory
thyName :: Theory -> String
thyItems :: Theory -> [ThyItem]

-- | Adapt the theory name to the base name of the given file.
adaptTheoryName :: FilePath -> Theory -> Theory

-- | Insert a theory item into a theory.
insertItem :: ThyItem -> Theory -> Theory

-- | Only keep theorems for which the given predicate is true or which are
--   referenced by some kept theorem.
shrinkTheory :: (String -> Bool) -> Theory -> Theory

-- | Prove all claims with the given heuristic optionally using the given
--   bound.
proveSequents :: (Sequent -> Theorem -> Bool) -> ([Named Sequent] -> Sequent -> Maybe Proof) -> Theory -> Theory

-- | Map the sequents of a theory.
mapTheorySequents :: (Sequent -> Sequent) -> Theory -> Theory

-- | Most proofs require a typing invariant to be present for the protocol
--   under investigation. We try to derive one from the protcol
--   specification for every protocol that has none.
addMissingTypingInvariants :: Theory -> Theory

-- | Ensures that all roles are globally uniquely named by prefixing all
--   role names with their corresponding protocol name, if two roles have
--   equal names.
ensureUniqueRoleNames :: Theory -> Theory

-- | Compose all protocol in the theory in parallel. Assumes that both
--   protocol names as well as role names are <i>globally</i> unique.
composeParallel :: Theory -> Theory

-- | Find a protocol in the theory according to its name.
lookupProtocol :: String -> Theory -> Maybe Protocol

-- | Find all unsound theorems of the theory.
unsoundTheorems :: Theory -> [(Protocol, String)]

-- | Total proof size.
theoryProofSize :: Theory -> ProofSize
theoryOverview :: Theory -> Theory

-- | Count and classify the properties selected by the given predicate into
--   secrecy properties, authentication properties, and other properties.
classifyProperties :: (String -> Bool) -> Theory -> (Int, Int, Int)
instance Typeable ThyItem
instance Typeable Theory
instance Eq ThyItem
instance Show ThyItem
instance Data ThyItem
instance Eq Theory
instance Show Theory
instance Data Theory

module Scyther.Theory.Parser

-- | The tokens delivered by our Alex based scanner
type Token = (SourcePos, Keyword)

-- | Lexable Keywords
data Keyword
IDENT :: String -> Keyword
SQUOTE :: Keyword
DQUOTE :: Keyword
RIGHTARROW :: Keyword
LEFTARROW :: Keyword
LONGRIGHTARROW :: Keyword
LONGLEFTARROW :: Keyword
COMMA :: Keyword
DOT :: Keyword
COLON :: Keyword
QUESTIONMARK :: Keyword
AND :: Keyword
MID :: Keyword
DOLLAR :: Keyword
SHARP :: Keyword
LPAREN :: Keyword
RPAREN :: Keyword
LBRACKET :: Keyword
RBRACKET :: Keyword
LBRACE :: Keyword
RBRACE :: Keyword
TILDE :: Keyword
HAT :: Keyword
STAR :: Keyword
UNDERSCORE :: Keyword
MINUS :: Keyword
PLUS :: Keyword
EQUAL :: Keyword
LESS :: Keyword
GREATER :: Keyword
EOF :: Keyword
FORALL :: Keyword
EXISTS :: Keyword
LAND :: Keyword
LOR :: Keyword
LNOT :: Keyword
APPROX :: Keyword
DUMMY_KEYWORD :: Keyword

-- | Scan a string using the given filename in the error messages.
--   
--   NOTE: Lexical errors are thrown using <a>error</a>.
scanString :: FilePath -> String -> [Token]

-- | Scan a file
scanFile :: FilePath -> IO [Token]

-- | A parser with an arbitrary user state for a stream of tokens.
type Parser s a = Parsec [Token] s a

-- | Parser s a theory file.
parseFile :: Parser s a -> s -> FilePath -> IO a

-- | Lift a maybe to a monad plus action.
liftMaybe :: MonadPlus m => Maybe a -> m a

-- | Lift a maybe to a monad action with the given failure message.
liftMaybe' :: Monad m => String -> Maybe a -> m a

-- | Parse a token based on the acceptance condition
token :: (Keyword -> Maybe a) -> Parser s a

-- | Parse a term.
kw :: Keyword -> Parser s ()

-- | Parse content between keywords.
betweenKWs :: Keyword -> Keyword -> Parser s a -> Parser s a

-- | A comma separated list of elements.
commaSep :: Parser s a -> Parser s [a]

-- | A comma separated non-empty list of elements.
commaSep1 :: Parser s a -> Parser s [a]

-- | Parse a list of items '[' item ',' ... ',' item ']'
list :: Parser s a -> Parser s [a]

-- | Between braces.
braced :: Parser s a -> Parser s a

-- | Between parentheses.
parens :: Parser s a -> Parser s a

-- | Between parentheses.
brackets :: Parser s a -> Parser s a

-- | Between single quotes.
singleQuoted :: Parser s a -> Parser s a

-- | Between double quotes.
doubleQuoted :: Parser s a -> Parser s a

-- | Parse an identifier as a string
identifier :: Parser s String

-- | Parse a fixed string which could be an identifier.
string :: String -> Parser s ()

-- | Parse a sequence of fixed strings.
strings :: [String] -> Parser s ()

-- | Parse an integer.
integer :: Parser s Int

-- | Left-hand-side of a function application written with the given
--   delimiter.
genFunOpen :: Parser s a -> Parser s b -> Parser s a

-- | Left-hand-side of a function application.
genFunApp :: Parser s a -> Parser s b -> Parser s d -> Parser s c -> Parser s c

-- | Left-hand-side of a function application.
funOpen :: String -> Parser s ()

-- | A function application.
funApp :: String -> Parser s a -> Parser s a

-- | Parse a protocol.
protocol :: Parser s Protocol

-- | Parse a claim.
claims :: (String -> Maybe Protocol) -> Parser s [ThyItem]

-- | Parse a theory.
theory :: Parser s Theory

-- | Parse a security protocol theory given as a string using the given
--   filename for the error messages
parseTheory :: FilePath -> IO Theory
mkLTSPat :: Pattern -> Pattern
mkMultIdentityPat :: Pattern
mkExpPat :: Pattern -> Pattern -> Pattern
mkMultPat :: Pattern -> Pattern -> Pattern
destLTSPat :: Pattern -> Maybe Pattern
destMultIdentityPat :: Pattern -> Maybe ()
destExpPat :: Pattern -> Maybe (Pattern, Pattern)
destMultPat :: Pattern -> Maybe (Pattern, Pattern)


-- | Pretty printing a security protocol theory.
module Scyther.Theory.Pretty
newtype TaggedIdentityT t m a
TaggedIdentityT :: m a -> TaggedIdentityT t m a
unTaggedIdentityT :: TaggedIdentityT t m a -> m a
runTaggedIdentityT :: t -> TaggedIdentityT t m a -> m a

-- | Phantom type marking slim output.
data SlimOutput
SlimOutput :: SlimOutput

-- | A monad for inserting markup into output.
class (Applicative m, Monad m) => MarkupMonad m
withGraph :: (MarkupMonad m, Document d) => Dot a -> m d -> m d
withExplanation :: (MarkupMonad m, Document d) => String -> m d -> m d
theoremRef :: (MarkupMonad m, Document d) => Protocol -> String -> m d
theoremDef :: (MarkupMonad m, Document d) => Theorem -> m d -> m d
keyword :: (MarkupMonad m, Document d) => String -> m d -> m d
noteCases :: (MarkupMonad m, Document d) => Dot a -> [(String, Dot b)] -> [(String, Dot b)] -> m d -> m d

-- | A pretty printing monad allowing for economically replacing parts of
--   the pretty printer.
class MarkupMonad m => PrettyMonad m
prettyTID :: PrettyMonad m => TID -> m Doc
prettyAgentId :: PrettyMonad m => AgentId -> m Doc
prettyMessage :: PrettyMonad m => Message -> m Doc
prettyFacts :: PrettyMonad m => Facts -> m ([Doc], [Doc], [Doc])
prettyFormula :: PrettyMonad m => Mapping -> Formula -> m Doc
prettySequent :: PrettyMonad m => Sequent -> m Doc
ensureProofMode :: PrettyMonad m => (Bool, Bool) -> m Doc
withFactsMode :: PrettyMonad m => (Bool, Bool) -> m Doc -> m Doc
prettyTrivial :: PrettyMonad m => Sequent -> TrivReason -> m Doc
prettyMissing :: PrettyMonad m => Sequent -> String -> m Doc
prettySaturate :: PrettyMonad m => Sequent -> m Doc
prettyForwardContradiction :: PrettyMonad m => m Doc -> m Doc
prettyForwardResolution :: PrettyMonad m => m Doc -> Sequent -> Mapping -> m Doc
prettyNextCase :: PrettyMonad m => m Doc
prettyChainRuleSplitCases :: PrettyMonad m => [ChainRuleCase] -> m ([ChainRuleCase], [ChainRuleCase])
prettyChainRuleApplication :: PrettyMonad m => m Doc -> m Doc
prettyChainRuleCase :: PrettyMonad m => (String, [Either TID AgentId]) -> m Doc
prettyChainRuleQED :: PrettyMonad m => Message -> [ChainRuleCase] -> m Doc
prettyTypeCheckInduction :: PrettyMonad m => Protocol -> String -> Typing -> (m Doc, m Doc -> m Doc, m Doc)
prettyTypingCase :: PrettyMonad m => String -> Typing -> String -> Sequent -> m Doc
prettySplitEqCase :: (PrettyMonad m, PrettyMonad m) => String -> m Doc
prettySplitEqApplication :: (PrettyMonad m, PrettyMonad m) => MsgEq -> m Doc
prettySplitEqQed :: (PrettyMonad m, PrettyMonad m) => m Doc
prettyComment :: PrettyMonad m => String -> m Doc
prettyProtoDef :: PrettyMonad m => Protocol -> [Theorem] -> m Doc
prettyTheorem :: PrettyMonad m => Theorem -> m Doc
prettyTheoryDef :: PrettyMonad m => String -> Doc -> m Doc

-- | Pretty print a theory.
prettyTheory :: PrettyMonad m => Theory -> m Doc

-- | Pretty print soundness information.
prettySoundness :: Applicative f => Theory -> f Doc
instance Functor m => Functor (TaggedIdentityT t m)
instance Applicative m => Applicative (TaggedIdentityT t m)
instance Monad m => Monad (TaggedIdentityT t m)
instance MarkupMonad m => PrettyMonad (TaggedIdentityT SlimOutput m)
instance MarkupMonad m => PrettyMonad (ReaderT IsarConf m)
instance MarkupMonad m => MarkupMonad (TaggedIdentityT t m)
instance MarkupMonad m => MarkupMonad (ReaderT r m)
instance MarkupMonad Identity
instance MonadTrans (TaggedIdentityT t)
instance (Document d, Applicative f) => Document (f d)


-- | Converting security protocol theories to a bunch of HTML files and
--   images.
module Scyther.Theory.Html

-- | Input for generation process that needs to be supplied from a caller
--   of <tt>theoryToHtml</tt>.
data GenerationInput
GenerationInput :: String -> UTCTime -> String -> FilePath -> FilePath -> FilePath -> HtmlMarkup Doc -> (FilePath -> String) -> String -> String -> Maybe (FilePath -> IO (IO String, Maybe String)) -> GenerationInput

-- | Arbitrary html for the header
giHeader :: GenerationInput -> String

-- | Generation time.
giTime :: GenerationInput -> UTCTime

-- | Description of the system we run on.
giSystem :: GenerationInput -> String

-- | Path to input file.
giInputFile :: GenerationInput -> FilePath

-- | Path to template index.
giTemplate :: GenerationInput -> FilePath

-- | Path to the output directory.
giOutDir :: GenerationInput -> FilePath

-- | Document representing theory to output.
giMarkup :: GenerationInput -> HtmlMarkup Doc

-- | A function mapping the output file name to a string representation of
--   Isabelle/HOL certificate. The generation time will be measured as the
--   time it takes to write this string to the output file.
giProofScript :: GenerationInput -> FilePath -> String

-- | <tt>dot</tt> tool to use.
giDotTool :: GenerationInput -> String

-- | The command line that was used in this call to scyther-proof.
giCmdLine :: GenerationInput -> String

-- | A checking function calling isabelle with the right parameters and
--   returning an IO function for retrieving the logfile contents and an
--   error message in case the check didn't succeed.
giIsabelle :: GenerationInput -> Maybe (FilePath -> IO (IO String, Maybe String))

-- | Convert a security protocol theory to a HTML file visualizing it.
theoryToHtml :: GenerationInput -> IO ()
evalHtmlMarkup :: HtmlMarkup a -> a
instance Eq GraphIdx
instance Ord GraphIdx
instance Num GraphIdx
instance Enum GraphIdx
instance JSON GraphIdx
instance Functor HtmlMarkup
instance Applicative HtmlMarkup
instance Monad HtmlMarkup
instance MarkupMonad HtmlMarkup
instance MonadState HtmlMarkupState HtmlMarkup
instance Show GraphIdx
