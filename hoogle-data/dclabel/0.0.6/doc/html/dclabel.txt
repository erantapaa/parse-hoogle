-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Disjunction Category Label Format
--   
--   The <i>DC Label</i> (DCLabel) library provides dynamic information
--   flow control label format in the form of conjunctions of disjunctions
--   of principals. Most code should import module <a>DCLabel.Safe</a>;
--   trusted code should import <a>DCLabel.TCB</a>. The core functionality
--   of the library is documented in <a>DCLabel.Core</a>, while the small
--   EDSL used to create labels is documents in <a>DCLabel.NanoEDSL</a>.
--   DCLabel was implemented by David Mazieres
--   (<a>http://www.scs.stanford.edu/~dm/</a>), Deian Stefan
--   (<a>http://www.scs.stanford.edu/~deian/</a>), and Alejandro Russo
--   (<a>http://www.cse.chalmers.se/~russo/</a>).
@package dclabel
@version 0.0.6


-- | This module implements Disjunction Category Labels.
--   
--   A DCLabel is a pair of <a>secrecy</a> and <a>integrity</a> category
--   sets or components, of type <a>Component</a>. Each component is simply
--   a set of clauses in propositional logic (without negation). A
--   component can either correspond to the term <a>MkComponentAll</a>,
--   representing falsehood, or a set of categories (clauses): (of type
--   <a>Conj</a>) corresponding to the conjunction of ategories (of type
--   <a>Disj</a>). Each category, in turn, is a disjunction of
--   <a>Principal</a>s, where a <a>Principal</a> is just a
--   <tt>ByteString</tt> whose meaning is up to the application.
--   
--   A category imposes an information flow restriction. In the case of
--   secrecy, a category restricts who can read, receive, or propagate the
--   information, while in the case of integrity it restricts who can
--   modify a piece of data. The principals constructing a category are
--   said to <i>own</i> the category.
--   
--   For information to flow from a source labeled <tt>L_1</tt> to a sink
--   <tt>L_2</tt>, the restrictions imposed by the categories of
--   <tt>L_2</tt> must at least as restrictive as all the restrictions
--   imposed by the categories of <tt>L_1</tt> (hence the conjunction) in
--   the case of secrecy, and at least as permissive in the case of
--   integrity. More specifically, for information to flow from
--   <tt>L_1</tt> to <tt>L_2</tt>, the labels must satisfy the
--   "can-flow-to" relation: <tt>L_1 ⊑ L_2</tt>. The ⊑ label check is
--   implemented by the <a>canflowto</a> function. For labels
--   <tt>L_1=&lt;S_1, I_1&gt;</tt>, <tt>L_2=&lt;S_2, I_2&gt;</tt> the
--   can-flow-to relation is satisfied if the secrecy category set
--   <tt>S_2</tt> <a>implies</a> <tt>S_1</tt> and <tt>I_1</tt>
--   <a>implies</a> <tt>I_2</tt> (recall that a category set is a
--   conjunction of disjunctions of principals). For example, <tt>&lt;{[P_1
--   ⋁ P_2]},{}&gt; ⊑ &lt;{[P_1]},{}&gt;</tt> because data that can be read
--   by <tt>P_1</tt> is more restricting than that readable by <tt>P_1</tt>
--   or <tt>P_2</tt>. Conversely, <tt>&lt;{{},[P_1]}&gt; ⊑ &lt;{},[P_1 ⋁
--   P_2]},{}&gt;</tt> because data vouched for by <tt>P_1</tt> or
--   <tt>P_2</tt> is more permissive than just <tt>P_1</tt> (note the same
--   idea holds when writing to sinks with such labeling).
--   
--   A piece of a code running with a privilege object (of type
--   <a>TCBPriv</a>), i.e., owning a <a>Principal</a> confers the right to
--   modify labels by removing any <a>secrecy</a> categories containing
--   that <a>Principal</a> and adding any <a>integrity</a> categories
--   containing the <a>Principal</a> (hence the name disjunction
--   categories: the category <tt>[P1 ⋁ P2]</tt> can be <i>downgraded</i>
--   by either <a>Principal</a> <tt>P1</tt> or <tt>P2</tt>). More
--   specifically, privileges can be used to bypass information flow
--   restrictions by using the more permissive "can-flow-to given
--   permission" relation:⊑ᵨ. The label check function implementing this
--   restriction is <a>canflowto_p</a>, taking an additional argument (of
--   type <a>TCBPriv</a>). For example, if <tt>L_1=&lt;{[P_1 ⋁ P_2] ⋀
--   [P_3]},{}&gt;</tt>, and <tt>L_2=&lt;{[P_1]},{}&gt;</tt>, then <tt>L_1
--   ⋢ L_2</tt>, but given a privilege object corresponding to
--   <tt>[P_3]</tt> the <tt>L_1 ⊑ᵨ L_2</tt> holds.
--   
--   To construct DC labels and privilege objects the constructors exported
--   by this module may be used, but we strongly suggest using
--   <a>DCLabel.NanoEDSL</a> as exported by <a>DCLabel.TCB</a> and
--   <a>DCLabel.Safe</a>. The former is to be used by trusted code only,
--   while the latter module should be imported by untrusted code as it
--   prevents the creation of arbitrary privileges.
module DCLabel.Core

-- | A category, i.e., disjunction, of <a>Principal</a>s. The empty list
--   '[]' corresponds to the disjunction of all principals. Conceptually,
--   <tt>[] = [P_1 ⋁ P_2 ⋁ ...]</tt>
newtype Disj
MkDisj :: [Principal] -> Disj
disj :: Disj -> [Principal]

-- | A category set, i.e., a conjunction of disjunctions. The empty list
--   '[]' corresponds to the single disjunction of all principals. In other
--   words, conceptually, <tt>[] = {[P_1 ⋁ P_2 ⋁ ...]}</tt> Logically '[]'
--   = <tt>True</tt>.
newtype Conj
MkConj :: [Disj] -> Conj
conj :: Conj -> [Disj]

-- | A components is a conjunction of disjunctions, where
--   <tt>MkComponentAll</tt> is the constructor that is associated with the
--   logical <tt>False</tt>.
data Component
MkComponentAll :: Component
MkComponent :: Conj -> Component
component :: Component -> Conj

-- | A component without any disjunctions or conjunctions. This component,
--   conceptually corresponds to the label consisting of a single category
--   containing all principals. Conceptually (in a closed-world system),
--   <tt>emptyComponent = &lt;{[P_1 ⋁ P_2 ⋁ ...]}&gt;</tt>. Logically, of
--   course, this is equivalent to <tt>True</tt>.
emptyComponent :: Component

-- | The dual of <a>emptyComponent</a>, <a>allComponent</a> consists of the
--   conjunction of all possible disjunctions, i.e., it is the label that
--   implies all other labels. Conceptually (in a closed-world system),
--   <tt>allComponent = &lt;{[P_1] ⋀ [P_2] ⋀ ...}&gt;</tt> Logically, of
--   course, this is equivalent to <tt>False</tt>.
allComponent :: Component

-- | Labels form a partial order according to the ⊑ relation. Specifically,
--   this means that for any two labels <tt>L_1</tt> and <tt>L_2</tt> there
--   is a unique label <tt>L_3 = L_1 ⊔ L_2</tt>, known as the <i>join</i>,
--   such that <tt>L_1 ⊑ L_3</tt> and <tt>L_2 ⊑ L_3</tt>. Similarly, there
--   is a unique label <tt>L_3' = L_1 ⊓ L_2</tt>, known as the <i>meet</i>,
--   such that <tt>L_3 ⊑ L_1</tt> and <tt>L_3 ⊑ L_2</tt>. This class
--   defines a <i>bounded</i> lattice, which further requires the
--   definition of the <i>bottom</i> ⊥ and <i>top</i> ⊤ elements of the
--   lattice, such that <tt>⊥ ⊑ L</tt> and <tt>L ⊑ ⊤</tt> for any label
--   <tt>L</tt>.
class Eq a => Lattice a
bottom :: Lattice a => a
top :: Lattice a => a
join :: Lattice a => a -> a -> a
meet :: Lattice a => a -> a -> a
canflowto :: Lattice a => a -> a -> Bool

-- | Class used to reduce labels and components to unique label normal form
--   (LNF), which corresponds to conjunctive normal form of principals. We
--   use this class to overload the reduce function used by the
--   <a>Component</a>, <a>DCLabel</a>, etc.
class ToLNF a
toLNF :: ToLNF a => a -> a

-- | A <tt>DCLabel</tt> is a pair of secrecy and integrity category sets,
--   i.e., a pair of <a>Component</a>s.
data DCLabel
MkDCLabel :: Component -> Component -> DCLabel

-- | Integrity category set.
secrecy :: DCLabel -> Component

-- | Secrecy category set.
integrity :: DCLabel -> Component

-- | Principal is a simple string representing a source of authority. Any
--   piece of code can create principals, regarless of how untrusted it is.
--   However, for principals to be used in integrity components or be
--   ignoerd a corresponding privilege (<a>TCBPriv</a>) must be created (by
--   trusted code) or delegated.
newtype Principal
MkPrincipal :: ByteString -> Principal
name :: Principal -> ByteString

-- | Generates a principal from an string.
class CreatePrincipal s
principal :: CreatePrincipal s => s -> Principal

-- | Privilege object is just a conjunction of disjunctions, i.e.,
--   <a>Component</a>. A trusted privileged object must be introduced by
--   trusted code, after which trusted privileged objects can be created by
--   delegation.
data TCBPriv
MkTCBPriv :: Component -> TCBPriv
priv :: TCBPriv -> Component

-- | Untrusted privileged object, which can be converted to a
--   <a>TCBPriv</a> with <a>delegatePriv</a>.
type Priv = Component

-- | Class extending <a>Lattice</a>, by allowing for the more relaxed label
--   comparison <tt>canflowto_p</tt>.
class Lattice a => RelaxedLattice a
canflowto_p :: RelaxedLattice a => TCBPriv -> a -> a -> Bool

-- | Privilege object corresponding to no privileges.
noPriv :: TCBPriv

-- | Privilege object corresponding to the "root", or all privileges. Any
--   other privilege may be delegated using this privilege object and it
--   must therefore not be exported to untrusted code.
rootPrivTCB :: TCBPriv

-- | Given trusted privilege and a "desired" untrusted privilege, return a
--   trusted version of the untrusted privilege, if the provided (trusted)
--   privilege implies it.
delegatePriv :: TCBPriv -> Priv -> Maybe TCBPriv

-- | This function creates any privilege object given an untrusted
--   privilege <a>Priv</a>. Note that this function should not be exported
--   to untrusted code.
createPrivTCB :: Priv -> TCBPriv

-- | Class used for checking if a computation can use a privilege in place
--   of the other. This notion is similar to the DLM "can-act-for".
class CanDelegate a b
canDelegate :: CanDelegate a b => a -> b -> Bool

-- | We say a <a>TCBPriv</a> privilege object owns a category when the
--   privileges allow code to bypass restrictions implied by the category.
--   This is the case if and only if the <a>TCBPriv</a> object contains one
--   of the <a>Principal</a>s in the <a>Disj</a>. This class is used to
--   check ownership
class Owns a
owns :: Owns a => TCBPriv -> a -> Bool

-- | Given two components, take the union of the disjunctions, i.e., simply
--   perform an "and". Note the new component is not necessarily in LNF.
and_component :: Component -> Component -> Component

-- | Given two components, perform an "or". Note that the new component is
--   not necessarily in LNF.
or_component :: Component -> Component -> Component

-- | Removes any duplicate principals from categories, and any duplicate
--   categories from the component. To return a clean component, it sorts
--   the component and removes empty disjunctions.
cleanComponent :: Component -> Component

-- | Determines if a component logically implies another component. In
--   other words, d_1 ⋀ ... ⋀ d_n =&gt; d_1' ⋀ ... ⋀ d_n'.
--   
--   Properties:
--   
--   <ul>
--   <li>∀ X, <a>allComponent</a> `<a>implies</a>` X := True</li>
--   <li>∀ X≠<a>allComponent</a>, X `<a>implies</a>` <a>allComponent</a> :=
--   False</li>
--   <li>∀ X, X `<a>implies</a>` <a>emptyComponent</a> := True</li>
--   <li>∀ X≠<a>emptyComponent</a>, <a>emptyComponent</a> `<a>implies</a>`
--   X := False</li>
--   </ul>
implies :: Component -> Component -> Bool

-- | Class used to convert list of principals to a disjunction category and
--   vice versa.
class DisjToFromList a
listToDisj :: DisjToFromList a => [a] -> Disj
disjToList :: DisjToFromList a => Disj -> [a]

-- | Given a list of categories, return a component.
listToComponent :: [Disj] -> Component

-- | Given a component return a list of categories.
componentToList :: Component -> [Disj]
instance Eq Principal
instance Ord Principal
instance Show Principal
instance Read Principal
instance Eq Disj
instance Ord Disj
instance Show Disj
instance Read Disj
instance Eq Conj
instance Ord Conj
instance Show Conj
instance Read Conj
instance Show Component
instance Read Component
instance Eq DCLabel
instance Show DCLabel
instance Read DCLabel
instance Eq TCBPriv
instance Show TCBPriv
instance Serialize DCLabel
instance Serialize Component
instance Serialize Conj
instance Serialize Disj
instance Serialize Principal
instance DisjToFromList ByteString
instance DisjToFromList String
instance DisjToFromList Principal
instance Owns Component
instance Owns Disj
instance CanDelegate TCBPriv TCBPriv
instance CanDelegate TCBPriv Priv
instance CanDelegate Priv TCBPriv
instance CanDelegate Priv Priv
instance Monoid TCBPriv
instance RelaxedLattice DCLabel
instance CreatePrincipal String
instance CreatePrincipal ByteString
instance Lattice DCLabel
instance ToLNF DCLabel
instance ToLNF Component
instance Eq Component


-- | This module implements a `<tt>nano</tt>`, very simple, embedded domain
--   specific language to create <a>Component</a>s and <a>Priv</a>ilages
--   from conjunctions of principal disjunctions.
--   
--   A 'Component'/'Priv' is created using the (<a>.\/.</a>) and
--   (<a>./\.</a>) operators. The disjunction operator (<a>.\/.</a>) is
--   used to create a category from <a>Principal</a>s, <a>String</a>s, or a
--   disjunctive sub-expression. For example:
--   
--   <pre>
--   p1 = <a>principal</a> "p1"
--   p2 = <a>principal</a> "p2"
--   p3 = <a>principal</a> "p3"
--   e1 = p1 <a>.\/.</a> p2
--   e2 = e1 <a>.\/.</a> "p4"
--   </pre>
--   
--   Similarly, the conjunction operator (<a>./\.</a>) is used to create
--   category-sets from <tt>Principals</tt>, <tt>Strings</tt>, and
--   conjunctive or disjunctive sub-expressions. For example:
--   
--   <pre>
--   e3 = p1 <a>.\/.</a> p2
--   e4 = e1 <a>./\.</a> "p4" <a>./\.</a> p3
--   </pre>
--   
--   <i>Note</i> that because a category consists of a disjunction of
--   principals, and a category set is composed of the conjunction of
--   categories, (<a>.\/.</a>) binds more tightly than (<a>./\.</a>).
--   
--   Given two <a>Component</a>s, one for secrecy and one for integrity,
--   you can create a <a>DCLabel</a> with <a>newDC</a>. And, similarly,
--   given a <a>TCBPriv</a> and <a>Priv</a> you can create a new minted
--   privilege with <a>newTCBPriv</a>.
--   
--   Consider the following, example:
--   
--   <pre>
--   l1 = "Alice" <a>.\/.</a> "Bob" <a>./\.</a> "Carla" 
--   l2 = "Alice" <a>./\.</a> "Carla" 
--   dc1 = <a>newDC</a> l1 l2
--   dc2 = <a>newDC</a> "Deian" "Alice"
--   pr = <a>createPrivTCB</a> $ <a>newPriv</a> ("Alice" <a>./\.</a> "Carla")
--   </pre>
--   
--   where
--   
--   <ul>
--   <li><pre> dc1 = &lt;{["Alice" ⋁ "Bob"] ⋀ ["Carla"]} , {["Alice"] ⋀
--   ["Carla"]}&gt;</pre></li>
--   <li><pre> dc2 = &lt;{["Deian"]} , {["Alice"]}&gt;</pre></li>
--   <li><pre> <a>canflowto</a> dc1 dc2 = False</pre></li>
--   <li><pre> <a>canflowto_p</a> pr dc1 dc2 = True</pre></li>
--   </ul>
module DCLabel.NanoEDSL
(.\/.) :: DisjunctionOf a b => a -> b -> Component
(./\.) :: ConjunctionOf a b => a -> b -> Component

-- | Empty component (logically this is <tt>True</tt>).
(<>) :: Component

-- | All component (logically this is <tt>False</tt>).
(><) :: Component
singleton :: Singleton a => a -> Component
newDC :: NewDC a b => a -> b -> DCLabel

-- | Class used to create <a>Priv</a>s and <a>TCBPriv</a>s.
class NewPriv a where newTCBPriv p = delegatePriv p . newPriv
newPriv :: NewPriv a => a -> Priv
newTCBPriv :: NewPriv a => TCBPriv -> a -> Maybe TCBPriv
instance IsString Principal
instance NewPriv String
instance NewPriv Principal
instance NewPriv Component
instance NewDC String String
instance NewDC Component String
instance NewDC String Component
instance NewDC Principal Principal
instance NewDC Component Principal
instance NewDC Principal Component
instance NewDC Component Component
instance ConjunctionOf Disj String
instance ConjunctionOf String Disj
instance ConjunctionOf Disj Principal
instance ConjunctionOf Principal Disj
instance ConjunctionOf Component Disj
instance ConjunctionOf Disj Component
instance ConjunctionOf Disj Disj
instance ConjunctionOf Component String
instance ConjunctionOf String Component
instance ConjunctionOf String String
instance ConjunctionOf Component Component
instance ConjunctionOf Component Principal
instance ConjunctionOf Principal Component
instance ConjunctionOf Principal Principal
instance DisjunctionOf Component String
instance DisjunctionOf String Component
instance DisjunctionOf String String
instance DisjunctionOf Component Component
instance DisjunctionOf Component Principal
instance DisjunctionOf Principal Component
instance DisjunctionOf Principal Principal
instance Singleton ByteString
instance Singleton String
instance Singleton Principal


-- | This module exports an unsafe-subset of <a>DCLabel.Core</a>,
--   implementing Disjunction Category Labels. A subset of the exported
--   functions and constructors shoul not be exposed to untrusted code;
--   instead, untursted code should import the <a>DCLabel.Safe</a> module.
module DCLabel.TCB


-- | This module implements secrecy-only DC Labels.
module DCLabel.Secrecy

-- | A secrecy-only DC label.
newtype SLabel
MkSLabel :: DCLabel -> SLabel
instance Eq SLabel
instance Show SLabel
instance Read SLabel
instance RelaxedLattice SLabel
instance Lattice SLabel
instance ToLNF SLabel


-- | This module implements integrity-only DC Labels.
module DCLabel.Integrity

-- | An integrity-only DC label.
newtype ILabel
MkILabel :: DCLabel -> ILabel
instance Eq ILabel
instance Show ILabel
instance Read ILabel
instance RelaxedLattice ILabel
instance Lattice ILabel
instance ToLNF ILabel


-- | This module exports a function <a>prettyShow</a> that pretty prints
--   <a>Principal</a>s, <a>Disj</a>unctions, <a>Conj</a>unctions,
--   <a>Component</a>s and <a>DCLabel</a>s.
module DCLabel.PrettyShow

-- | Class used to create a <a>Doc</a> type of DCLabel-related types
class PrettyShow a
pShow :: PrettyShow a => a -> Doc

-- | Render a <a>PrettyShow</a> type to a string.
prettyShow :: PrettyShow a => a -> String
instance PrettyShow ILabel
instance PrettyShow SLabel
instance PrettyShow TCBPriv
instance PrettyShow Principal
instance PrettyShow DCLabel
instance PrettyShow Component
instance PrettyShow Conj
instance PrettyShow Disj


-- | This module exports a safe-subset of <a>DCLabel.Core</a>, implementing
--   Disjunction Category Components. The exported functions and
--   constructors may be used by untrusted code, guaranteeing that they
--   cannot perform anything unsafe.
module DCLabel.Safe
join :: Lattice a => a -> a -> a
meet :: Lattice a => a -> a -> a
top :: Lattice a => a
bottom :: Lattice a => a
canflowto :: Lattice a => a -> a -> Bool

-- | A components is a conjunction of disjunctions, where
--   <tt>MkComponentAll</tt> is the constructor that is associated with the
--   logical <tt>False</tt>.
data Component
MkComponentAll :: Component
MkComponent :: Conj -> Component
component :: Component -> Conj

-- | A <tt>DCLabel</tt> is a pair of secrecy and integrity category sets,
--   i.e., a pair of <a>Component</a>s.
data DCLabel
MkDCLabel :: Component -> Component -> DCLabel

-- | Integrity category set.
secrecy :: DCLabel -> Component

-- | Secrecy category set.
integrity :: DCLabel -> Component

-- | A category, i.e., disjunction, of <a>Principal</a>s. The empty list
--   '[]' corresponds to the disjunction of all principals. Conceptually,
--   <tt>[] = [P_1 ⋁ P_2 ⋁ ...]</tt>
newtype Disj
MkDisj :: [Principal] -> Disj
disj :: Disj -> [Principal]

-- | A category set, i.e., a conjunction of disjunctions. The empty list
--   '[]' corresponds to the single disjunction of all principals. In other
--   words, conceptually, <tt>[] = {[P_1 ⋁ P_2 ⋁ ...]}</tt> Logically '[]'
--   = <tt>True</tt>.
newtype Conj
MkConj :: [Disj] -> Conj
conj :: Conj -> [Disj]

-- | Principal is a simple string representing a source of authority. Any
--   piece of code can create principals, regarless of how untrusted it is.
--   However, for principals to be used in integrity components or be
--   ignoerd a corresponding privilege (<a>TCBPriv</a>) must be created (by
--   trusted code) or delegated.
data Principal
principal :: CreatePrincipal s => s -> Principal
name :: Principal -> ByteString
singleton :: Singleton a => a -> Component
listToDisj :: DisjToFromList a => [a] -> Disj
disjToList :: DisjToFromList a => Disj -> [a]

-- | Given a list of categories, return a component.
listToComponent :: [Disj] -> Component

-- | Given a component return a list of categories.
componentToList :: Component -> [Disj]
(.\/.) :: DisjunctionOf a b => a -> b -> Component
(./\.) :: ConjunctionOf a b => a -> b -> Component

-- | Empty component (logically this is <tt>True</tt>).
(<>) :: Component

-- | All component (logically this is <tt>False</tt>).
(><) :: Component
newDC :: NewDC a b => a -> b -> DCLabel

-- | Privilege object is just a conjunction of disjunctions, i.e.,
--   <a>Component</a>. A trusted privileged object must be introduced by
--   trusted code, after which trusted privileged objects can be created by
--   delegation.
data TCBPriv
priv :: TCBPriv -> Component

-- | Untrusted privileged object, which can be converted to a
--   <a>TCBPriv</a> with <a>delegatePriv</a>.
type Priv = Component

-- | Relaxed partial-order relation
canflowto_p :: RelaxedLattice a => TCBPriv -> a -> a -> Bool

-- | Given trusted privilege and a "desired" untrusted privilege, return a
--   trusted version of the untrusted privilege, if the provided (trusted)
--   privilege implies it.
delegatePriv :: TCBPriv -> Priv -> Maybe TCBPriv

-- | Can use first privilege in place of second.
canDelegate :: CanDelegate a b => a -> b -> Bool

-- | Checks if category restriction can be bypassed given the privilege.
owns :: Owns a => TCBPriv -> a -> Bool

-- | Class used to create <a>Priv</a>s and <a>TCBPriv</a>s.
class NewPriv a where newTCBPriv p = delegatePriv p . newPriv
newPriv :: NewPriv a => a -> Priv
newTCBPriv :: NewPriv a => TCBPriv -> a -> Maybe TCBPriv

-- | Privilege object corresponding to no privileges.
noPriv :: TCBPriv
