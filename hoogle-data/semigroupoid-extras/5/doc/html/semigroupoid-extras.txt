-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Semigroupoids that depend on PolyKinds
--   
@package semigroupoid-extras
@version 5


module Data.Profunctor.Collage

-- | The cograph of a <a>Profunctor</a>.
data Collage k b a
L :: (b -> b') -> Collage k (Left b) (Left b')
R :: (a -> a') -> Collage k (Right a) (Right a')
C :: k b a -> Collage k (Left b) (Right a)
instance Profunctor k => Ob (Collage k) ('Right a)
instance Profunctor k => Ob (Collage k) ('Left a)
instance Profunctor k => Semigroupoid (Collage k)


module Data.Semigroupoid.Coproduct
data Coproduct j k a b
L :: j a b -> Coproduct j k (Left a) (Left b)
R :: k a b -> Coproduct j k (Right a) (Right b)
distributeDualCoproduct :: Dual (Coproduct j k) a b -> Coproduct (Dual j) (Dual k) a b
factorDualCoproduct :: Coproduct (Dual j) (Dual k) a b -> Dual (Coproduct j k) a b
instance (Semigroupoid l, Ob r a) => Ob (Coproduct l r) ('Right a)
instance (Ob l a, Semigroupoid r) => Ob (Coproduct l r) ('Left a)
instance (Groupoid j, Groupoid k2) => Groupoid (Coproduct j k2)
instance (Semigroupoid j, Semigroupoid k2) => Semigroupoid (Coproduct j k2)


module Data.Semigroupoid.Product
data Product j k a b
Pair :: j a b -> k a' b' -> Product j k '(a, a') '(b, b')
distributeDualProduct :: Dual (Product j k) a b -> Product (Dual j) (Dual k) a b
factorDualProduct :: Product (Dual j) (Dual k) a b -> Dual (Product j k) a b
instance (Ob l a, Ob r b) => Ob (Product l r) '(a, b)
instance (Groupoid j, Groupoid k2) => Groupoid (Product j k2)
instance (Semigroupoid j, Semigroupoid k2) => Semigroupoid (Product j k2)


module Data.Semifunctor

-- | Semifunctors map objects to objects, and arrows to arrows preserving
--   connectivity as normal functors, but do not purport to preserve
--   identity arrows. We apply them to semigroupoids, because those don't
--   even claim to offer identity arrows!
class (Semigroupoid c, Semigroupoid d) => Semifunctor f c d | f c -> d, f d -> c
semimap :: Semifunctor f c d => c a b -> d (f a) (f b)

-- | Used to map a more traditional bifunctor into a semifunctor
data Bi p a
Bi :: p a b -> Bi p '(a, b)
(#) :: a -> b -> Bi (,) '(a, b)
semibimap :: Semifunctor p (Product l r) cod => l a b -> r c d -> cod (p '(a, c)) (p '(b, d))
semifirst :: (Semifunctor p (Product l r) cod, Ob r c) => l a b -> cod (p '(a, c)) (p '(b, c))
semisecond :: (Semifunctor p (Product l r) cod, Ob l a) => r b c -> cod (p '(a, b)) (p '(a, c))
first :: (Semifunctor p (Product l r) cod, Category r) => l a b -> cod (p '(a, c)) (p '(b, c))
second :: (Semifunctor p (Product l r) cod, Category l) => r b c -> cod (p '(a, b)) (p '(a, c))
data WrappedFunctor f a
WrapFunctor :: f a -> WrappedFunctor f a
unwrapFunctor :: WrappedFunctor f a -> f a
data WrappedTraversable1 f a
WrapTraversable1 :: f a -> WrappedTraversable1 f a
unwrapTraversable1 :: WrappedTraversable1 f a -> f a
instance Bind m => Semifunctor (Bi Either) (Product (Kleisli m) (Kleisli m)) (Kleisli m)
instance Bind m => Semifunctor (Bi (,)) (Product (Kleisli m) (Kleisli m)) (Kleisli m)
instance Semifunctor (Bi Either) (Product (->) (->)) (->)
instance Semifunctor (Bi (,)) (Product (->) (->)) (->)
instance Semifunctor f c d => Semifunctor f (Dual c) (Dual d)
instance (Traversable1 f, Bind m) => Semifunctor (WrappedTraversable1 f) (Kleisli m) (Kleisli m)
instance (Traversable f, Bind m, Monad m) => Semifunctor (WrappedFunctor f) (Kleisli m) (Kleisli m)
instance Functor f => Semifunctor (WrappedFunctor f) (->) (->)


module Data.Semifunctor.Associative
class Semifunctor p (Product k k) k => Associative k p
associate :: Associative k p => k (p '(p '(a, b), c)) (p '(a, p '(b, c)))
kleisliAssociate :: (Monad m, Semifunctor p (Product (Kleisli m) (Kleisli m)) (Kleisli m), Associative (->) p) => Kleisli m (p '(p '(a, b), c)) (p '(a, p '(b, c)))
class Semifunctor p (Product k k) k => Disassociative k p
disassociate :: Disassociative k p => k (p '(a, p '(b, c))) (p '(p '(a, b), c))
kleisliDisassociate :: (Monad m, Semifunctor p (Product (Kleisli m) (Kleisli m)) (Kleisli m), Disassociative (->) p) => Kleisli m (p '(a, p '(b, c))) (p '(p '(a, b), c))
instance (Bind m, Monad m) => Disassociative (Kleisli m) (Bi (,))
instance (Bind m, Monad m) => Disassociative (Kleisli m) (Bi Either)
instance Disassociative (->) (Bi (,))
instance Disassociative (->) (Bi Either)
instance (Bind m, Monad m) => Associative (Kleisli m) (Bi (,))
instance (Bind m, Monad m) => Associative (Kleisli m) (Bi Either)
instance Associative (->) (Bi (,))
instance Associative (->) (Bi Either)


module Data.Semifunctor.Braided
class Associative k p => Braided k p
braid :: Braided k p => k (p '(a, b)) (p '(b, a))
kleisliBraid :: (Monad m, Semifunctor p (Product (Kleisli m) (Kleisli m)) (Kleisli m), Braided (->) p) => Kleisli m (p '(a, b)) (p '(b, a))
class Braided k p => Symmetric k p
swap :: Symmetric k p => k (p '(a, b)) (p '(b, a))
instance (Bind m, Monad m) => Symmetric (Kleisli m) (Bi (,))
instance (Bind m, Monad m) => Symmetric (Kleisli m) (Bi Either)
instance Symmetric (->) (Bi (,))
instance Symmetric (->) (Bi Either)
instance (Bind m, Monad m) => Braided (Kleisli m) (Bi (,))
instance (Bind m, Monad m) => Braided (Kleisli m) (Bi Either)
instance Braided (->) (Bi (,))
instance Braided (->) (Bi Either)
