-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interface for DBM-like database systems
--   
--   This module provides a generic infrastructure for supporting storage
--   of hash-like items with String-to-String mappings. It can be used for
--   in-memory or on-disk storage.
--   
--   Two simple backend drivers are included with this package: one that is
--   RAM-only, and one that is persistent and disk-backed. The hdbc-anydbm
--   package provides another driver, which lets you use simple tables in
--   any SQL database to provide a DBM-like interface. MissingPy also
--   provides a Python driver which lets you use any Python anydbm driver
--   under Haskell AnyDBM.
@package anydbm
@version 1.0.7


-- | Written by John Goerzen, jgoerzen@complete.org
--   
--   This module provides a generic infrastructure for supporting storage
--   of hash-like items with String -&gt; String mappings. It can be used
--   for in-memory or on-disk items.
module Database.AnyDBM

-- | The main class for items implementing this interface.
--   
--   People implementing this class should provide methods for:
--   
--   <ul>
--   <li><a>closeA</a> (unless you have no persistent storage)</li>
--   <li><a>flushA</a> (unless you have no persistent storage)</li>
--   <li><a>insertA</a></li>
--   <li><a>deleteA</a></li>
--   <li><a>lookupA</a></li>
--   <li>either <a>toListA</a> or <a>keysA</a></li>
--   </ul>
class AnyDBM a where valuesA h = do { l <- toListA h; return $ map snd l } keysA h = do { l <- toListA h; return $ map fst l } toListA h = let conv k = do { v <- forceLookupA h k; return (k, v) } in do { k <- keysA h; mapM conv k } forceLookupA h key = do { x <- lookupA h key; case x of { Just y -> return y Nothing -> throwIO $ PatternMatchFail key } } insertListA h [] = return () insertListA h ((key, val) : xs) = do { insertA h key val; insertListA h xs } hasKeyA h k = do { l <- lookupA h k; case l of { Nothing -> return False Just _ -> return True } } closeA h = flushA h flushA h = return ()
closeA :: AnyDBM a => a -> IO ()
flushA :: AnyDBM a => a -> IO ()
insertA :: AnyDBM a => a -> String -> String -> IO ()
deleteA :: AnyDBM a => a -> String -> IO ()
hasKeyA :: AnyDBM a => a -> String -> IO Bool
lookupA :: AnyDBM a => a -> String -> IO (Maybe String)
forceLookupA :: AnyDBM a => a -> String -> IO String
insertListA :: AnyDBM a => a -> [(String, String)] -> IO ()
toListA :: AnyDBM a => a -> IO [(String, String)]
keysA :: AnyDBM a => a -> IO [String]
valuesA :: AnyDBM a => a -> IO [String]

-- | Similar to MapM, but for <a>AnyDBM</a> objects.
mapA :: AnyDBM a => a -> ((String, String) -> IO b) -> IO [b]

-- | Similar to <a>strFromAL</a> -- get a string representation of the
--   entire AnyDBM.
strFromA :: AnyDBM a => a -> IO String

-- | Similar to <a>strToAL</a> -- load a string representation into the
--   AnyDBM. You must supply an existing AnyDBM object; the items loaded
--   from the string will be added to it.
strToA :: AnyDBM a => a -> String -> IO ()
instance [overlap ok] AnyDBM (HashTable String String)


-- | Written by John Goerzen, jgoerzen@complete.org
--   
--   Support for working with Maps through the <a>Database.AnyDBM</a>
--   framework.
module Database.AnyDBM.MapDBM

-- | The type of the MapDBM.
type MapDBM = MVar (Map String String)

-- | Makes a new MapDBM with an empty Map.
newMapDBM :: IO MapDBM

-- | Sets the embedded Map in this <a>MapDBM</a> to the given <a>Map</a>.
setMapDBM :: MapDBM -> Map String String -> IO ()

-- | Gets the embedded Map in this <a>MapDBM</a>.
getMapDBM :: MapDBM -> IO (Map String String)
instance [overlap ok] AnyDBM MapDBM


-- | Written by John Goerzen, jgoerzen@complete.org
--   
--   This <a>AnyDBM</a> implementation is very simple. It can store data
--   on-disk in a persistent fashion, using a very simple String
--   representation. While the file is open, an in-memory cache is
--   maintained. The data is written out during a call to <tt>flush</tt> or
--   <tt>close</tt>.
module Database.AnyDBM.StringDBM

-- | The type of the StringDBM instances.
data StringDBM

-- | Opens a <a>StringDBM</a> file. Please note: only ReadMode, WriteMode,
--   and ReadWriteMode are supported for the IOMode. AppendMode is not
--   supported.
--   
--   <pre>
--   openStringDBM = openStringVDBM SystemFS
--   </pre>
openStringDBM :: FilePath -> IOMode -> IO StringDBM

-- | Opens a <a>StringDBM</a> file. Please note: only ReadMode, WriteMode,
--   and ReadWriteMode are supported for the IOMode. AppendMode is not
--   supported.
--   
--   To work on your system's normal (real) filesystem, just specify
--   <a>SystemFS</a> for the first argument.
openStringVDBM :: HVFSOpenable a => a -> FilePath -> IOMode -> IO StringDBM
data SystemFS :: *
SystemFS :: SystemFS

-- | See <a>openFile</a>
data IOMode :: *
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode
instance [overlap ok] AnyDBM StringDBM
