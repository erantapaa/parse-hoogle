-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extra utilities for pipes
--   
--   This package holds miscellaneous utilities related to the
--   <tt>pipes</tt> library.
@package pipes-extras
@version 1.0.0


-- | Unassorted utilities for <tt>pipes</tt>
module Pipes.Extras

-- | Like <a>arr</a> from <a>Arrow</a>
arr :: Monad m => (a -> b) -> Pipe a b m r

-- | Like <a>left</a> from <a>ArrowChoice</a>
left :: Monad m => Pipe a b m r -> Pipe (Either a x) (Either b x) m r

-- | Like <a>right</a> from <a>ArrowChoice</a>
right :: Monad m => Pipe a b m r -> Pipe (Either x a) (Either x b) m r

-- | Like (<a>+++</a>) from <a>ArrowChoice</a>
--   
--   <pre>
--   pL +++ pR = left pL &gt;-&gt; right pR
--   </pre>
(+++) :: Monad m => Pipe a b m r -> Pipe c d m r -> Pipe (Either a c) (Either b d) m r

-- | It helps to think in terms of the following simpler types:
--   
--   <pre>
--   input :: Monad m =&gt; Setter' (Consumer a   m r) a
--   input :: Monad m =&gt; Setter' (Pipe     a b m r) a
--   </pre>
--   
--   Note: This only works with <tt>lens</tt> and not
--   <tt>lens-family-core</tt>
input :: Monad m => Setter (Proxy x' b y' y m r) (Proxy x' a y' y m r) a b

-- | It helps to think in terms of the following simpler types:
--   
--   <pre>
--   output :: Monad m =&gt; Setter' (Producer b m r) b
--   output :: Monad m =&gt; Setter' (Pipe   a b m r) b
--   </pre>
--   
--   Note: This only works with <tt>lens</tt> and not
--   <tt>lens-family-core</tt>
output :: Monad m => Setter (Proxy x' x y' a m r) (Proxy x' x y' b m r) a b

-- | Ask whether or not to let values pass through
--   
--   <pre>
--   &gt;&gt;&gt; runEffect $ each [1..3] &gt;-&gt; check &gt;-&gt; Pipes.print
--   Allow &lt;1&gt; [Y/n]?
--   y&lt;Enter&gt;
--   1
--   Allow &lt;2&gt; [Y/n]?
--   no&lt;Enter&gt;
--   Allow &lt;3&gt; [Y/n]?
--   YES&lt;Enter&gt;
--   3
--   </pre>
check :: Show a => Pipe a a IO r

-- | Add a delay (in seconds) between each element
delay :: Double -> Pipe a a IO r

-- | Display a progress bar
--   
--   This is very simple and only works if nothing else writes to the
--   terminal
--   
--   Try this:
--   
--   <pre>
--   &gt;&gt;&gt; runEffect $ each [1..] &gt;-&gt; progress &gt;-&gt; delay 0.1 &gt;-&gt; Pipes.Prelude.drain
--   </pre>
progress :: Pipe a a IO r

-- | Strict fold of the elements of a <a>Producer</a>
fold :: Monad m => Fold a b -> Producer a m () -> m b

-- | Strict, monadic fold of the elements of a <a>Producer</a>
foldM :: Monad m => FoldM m a b -> Producer a m () -> m b

-- | Strict left scan
scan :: Monad m => Fold a b -> Pipe a b m r

-- | Strict, monadic left scan
scanM :: Monad m => FoldM m a b -> Pipe a b m r

-- | Strict left scan without explicit initial state
scan1 :: Monad m => (x -> a -> x) -> (a -> x) -> (x -> b) -> Pipe a b m r

-- | Strict, monadic left scan without explicit initial state
scan1M :: Monad m => (x -> a -> m x) -> (a -> m x) -> (x -> m b) -> Pipe a b m r

-- | Strict, endomorphic left scan without explicit initial state.
--   
--   <pre>
--   -- Compute exponential moving average
--   ema :: (Monad m, Fractional a) =&gt; a -&gt; Pipe a a m r
--   ema α = scan1i (\last input -&gt; last * α + input * (1 - α)
--   </pre>
scan1i :: Monad m => (a -> a -> a) -> Pipe a a m r

-- | Strict, monadic and endomorphic left scan without explicit initial
--   state
scan1iM :: Monad m => (a -> a -> m a) -> Pipe a a m r
