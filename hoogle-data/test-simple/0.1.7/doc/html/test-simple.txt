-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple Perl inspired testing
--   
@package test-simple
@version 0.1.7


-- | Test.Simple is yet another testing library for Haskell. It has testing
--   primitives familiar to recovering Perl programmers :).
--   
--   Having <a>MonadPlus</a> instance allows to cut tests early e.g using
--   <a>guard</a> function.
--   
--   Being monad transformer it includes integration with
--   <tt>QuickCheck</tt> by declaring <a>Testable</a> instance on
--   <tt>TestSimpleT Gen a</tt>.
--   
--   Test.Simple also has the ability to run in pure context (see
--   <a>runTestSimple</a> function).
--   
--   Here is an example suitable for cabal test-suite integration. Note
--   that TemplateHaskell usage is optional and is needed for test failure
--   locations only.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   
--   import Test.Simple
--   import Control.Monad
--   
--   main :: IO ()
--   main = testSimpleMain $ do
--             plan 7
--             ok True
--             is 1 1
--             isnt "a" "b"
--             like "abcd" "bc"
--             unlike "a" "b"
--             diag "Successful so far, failures follow ..."
--             $loc &gt;&gt; ok False -- location will be recorded
--             is "a" "b" &gt;&gt;= guard
--             diag "I am not being called" -- not reached because of the guard: MonadPlus FTW!
--    
--   </pre>
module Test.Simple

-- | Test.Simple is implemented as monad transformer.
data TestSimpleT m a

-- | Is used in <a>like</a>, <a>unlike</a> tests.
class Likeable a b
isLike :: Likeable a b => a -> b -> Bool

-- | Runs <a>TestSimpleT</a> transformer in <a>IO</a>. Outputs results in
--   TAP format. Exits with error on test failure.
testSimpleMain :: MonadIO m => TestSimpleT m a -> m ()

-- | Runs <a>TestSimpleT</a> transformer. Returns whether the tests where
--   successful and resulting output.
runTestSimple :: Monad m => TestSimpleT m a -> m (Bool, [String])

-- | Run some <a>Testable</a> monad through <tt>QuickCheck</tt> function.
--   Exit with failure on error.
qcTestSimpleWith :: (Testable (m a), Monad m) => (m a -> IO Result) -> m a -> IO ()

-- | Run some <a>Testable</a> monad through <tt>QuickCheck</tt>. Exit with
--   failure on error. Equivalent to <a>qcTestSimpleWith</a>
--   <a>quickCheckResult</a>
qcTestSimpleMain :: (Testable (m a), Monad m) => m a -> IO ()

-- | Sets expected number of tests. Running more or less tests is
--   considered failure. Note, that plans are composable, e.g:
--   
--   <pre>
--   (plan 1 &gt;&gt; ok True) &gt;&gt; (plan 1 &gt;&gt; ok True)
--   </pre>
--   
--   will expect 2 tests.
plan :: Monad m => Int -> TestSimpleT m ()

-- | Is <tt>Bool</tt> ok?
ok :: Monad m => Bool -> TestSimpleT m Bool

-- | Are values different?
isnt :: (Eq a, Show a, Monad m) => a -> a -> TestSimpleT m Bool

-- | Are values equal?
is :: (Eq a, Show a, Monad m) => a -> a -> TestSimpleT m Bool

-- | Is <tt>a</tt> like <tt>b</tt>?
like :: (Show a, Show b, Likeable a b, Monad m) => a -> b -> TestSimpleT m Bool

-- | Is <tt>a</tt> unlike <tt>b</tt>?
unlike :: (Show a, Show b, Likeable a b, Monad m) => a -> b -> TestSimpleT m Bool

-- | Is <a>Either</a> right?
isRight :: (Monad m, Show a) => Either a b -> TestSimpleT m Bool

-- | Records current location to output in case of failures. Necessary
--   caveat: failing later without updating location produces the last
--   location recorded.
loc :: Q Exp

-- | Outputs diagnostics message.
diag :: Monad m => String -> TestSimpleT m ()

-- | Generates and logs (through <a>diag</a>) arbitrary value. Also outputs
--   current location.
diagen :: Show a => String -> Gen a -> TestSimpleT Gen a
instance Functor m => Functor (TestSimpleT m)
instance MonadTrans TestSimpleT
instance Monad m => Monad (TestSimpleT m)
instance Monad m => MonadPlus (TestSimpleT m)
instance Monad m => MonadState TSState (TestSimpleT m)
instance MonadIO m => MonadIO (TestSimpleT m)
instance (Monad m, Functor m) => Alternative (TestSimpleT m)
instance (Monad m, Functor m) => Applicative (TestSimpleT m)
instance Testable (TestSimpleT (PropertyM IO) a)
instance Testable (TestSimpleT Gen a)
instance Eq a => Likeable [a] [a]
