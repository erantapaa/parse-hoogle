-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Declarative, compositional Wai responses
--   
--   A method to writing Wai responses
--   
--   This library attempts to make it easier to write nice Wai response
--   handlers by giving us a Sinatra/ <a>Scotty</a>-like syntax for
--   declaring HTTP-verb oriented routes, in addition to file-extension
--   handling and rose-tree like composition. Not only do we have literal
--   route specification, like <a>Scotty</a> &amp; <a>Spock</a>, but we can
--   also embed <a>Attoparsec</a> parsers and <a>Regular Expressions</a>
--   <i>directly</i> in our routes, with our handlers reflecting their
--   results. You can find more information on the <a>demo</a>.
--   
--   As an example:
--   
--   <pre>
--   router :: Application
--   router = route handlers
--     where
--       handlers = do
--         handle o
--           (Just $ get $ text "home")
--           Nothing
--         handle ("foo" &lt;/&gt; "bar")
--           (Just $ get $ text "foobar") $ Just $
--           handle (p ("baz", double) &lt;/&gt; o)
--             (Just $ \d -&gt; get $ text $ LT.pack (show d) &lt;&gt; " bazs")
--             Nothing
--         handle (p ("num",double) &lt;/&gt; o)
--           (Just $ \d -&gt; get $ text $ LT.pack $ show d) $ Just $ do
--           handle "bar"
--              (Just $ \d -&gt; get $ do
--                       text $ (LT.pack $ show d) &lt;&gt; " bars")
--                       json $ (LT.pack $ show d) &lt;&gt; " bars!")
--              Nothing
--           handle (r ("email", mkRegex "(^[-a-zA-Z0-9_.]+@[-a-zA-Z0-9]+\\.[-a-zA-Z0-9.]+$)") &lt;/&gt; o)
--              (Just $ \d e -&gt; get $ textOnly $ (LT.pack $ show d) &lt;&gt; " " &lt;&gt; (LT.pack $ show e)
--   </pre>
--   
--   The route specification syntax is a little strange right now -
--   <tt>l</tt> specifies a "literal chunk" of a handlable url (ie - <tt>l
--   "foo" &lt;/&gt; l "bar" &lt;/&gt; o</tt> would represent the url
--   <tt>/foo/bar</tt>), while <tt>p</tt> represents a "parsable" url
--   chunk, which expects a pair - the left element being merely a
--   reference name for the parser during internal plumbing, and the right
--   being the actual <tt>Parser</tt>. <tt>o</tt> represents the end of a
--   url string, and can be used alone in a handler to capture requests to
--   the root path.
--   
--   Each route being handled needs some kind of content. For every parsed
--   url chunk, the route expects a function of arity matching 1-for-1 with
--   the parsed contents. For example, <tt>d -&gt; ...</tt> in the
--   demonstration above is such a function, where <tt>d :: Double</tt>.
--   
--   Internally, we match against both the file extension and Accept
--   headers in the HTTP request - the Accept header may override the file
--   extension.
--   
--   When we test our application:
--   
--   <pre>
--   λ&gt; curl localhost:3000/ -H "Accept: text/plain, */*"
--   ↪ "home"
--   </pre>
--   
--   requests may end with index
--   
--   <pre>
--   λ&gt; curl localhost:3000/index -H "Accept: text/plain, */*"
--   ↪ "home"
--   </pre>
--   
--   and specify the file extension
--   
--   <pre>
--   λ&gt; curl localhost:3000/index.txt -H "Accept: text/plain, */*"
--   ↪ "home"
--   </pre>
--   
--   each responding with the "closest" available file type
--   
--   <pre>
--   λ&gt; curl localhost:3000/index.html -H "Accept: text/html, */*"
--   ↪ "home"
--   </pre>
--   
--   <pre>
--   λ&gt; curl localhost:3000/foo/bar -H "Accept: text/plain, */*"
--   ↪ "foobar"
--   </pre>
--   
--   <pre>
--   λ&gt; curl localhost:3000/foo/bar.txt -H "Accept: text/plain, */*"
--   ↪ "foobar"
--   </pre>
--   
--   <pre>
--   λ&gt; curl localhost:3000/foo/bar/5678.5678 -H "Accept: text/plain, */*"
--   ↪ "5678.5678 bazs"
--   </pre>
--   
--   <pre>
--   λ&gt; curl localhost:3000/1234.1234 -H "Accept: text/plain, */*"
--   ↪ "1234.1234"
--   </pre>
--   
--   <pre>
--   λ&gt; curl localhost:3000/2e5 -H "Accept: text/plain, */*"
--   ↪ "200000.0"
--   </pre>
--   
--   <pre>
--   λ&gt; curl localhost:3000/1234.1234/bar -H "Accept: text/plain, */*"
--   ↪ "1234.1234 bars"
--   </pre>
@package nested-routes
@version 3.1.0

module Web.Routes.Nested.Types.UrlChunks

-- | Constrained to AttoParsec &amp; T.Text
data EitherUrlChunk (x :: Maybe *)
[:=] :: Text -> EitherUrlChunk Nothing
[:~] :: (Text, Parser r) -> EitherUrlChunk (Just r)
[:*] :: (Text, Regex) -> EitherUrlChunk (Just [String])
l :: Text -> EitherUrlChunk Nothing
p :: (Text, Parser r) -> EitherUrlChunk (Just r)
r :: (Text, Regex) -> EitherUrlChunk (Just [String])

-- | Container when defining route paths
data UrlChunks (xs :: [Maybe *])
[Cons] :: EitherUrlChunk mx -> UrlChunks xs -> UrlChunks (mx : xs)
[Root] :: UrlChunks []
(</>) :: EitherUrlChunk mx -> UrlChunks xs -> UrlChunks (mx : xs)
o :: UrlChunks []
instance (x ~ 'Nothing) => IsString (EitherUrlChunk x)

module Web.Routes.Nested.VerbListener
data Verb
[Get] :: Verb
[Post] :: Verb
[Put] :: Verb
[Delete] :: Verb
type BodyLength = Word64
newtype Verbs m r
[Verbs] :: Map Verb (Maybe (ByteString -> m (), Maybe BodyLength), Either r (Request -> r)) -> Verbs m r
[unVerbs] :: Verbs m r -> Map Verb (Maybe (ByteString -> m (), Maybe BodyLength), Either r (Request -> r))
supplyReq :: Request -> Map Verb (Maybe (ByteString -> m (), Maybe BodyLength), Either r (Request -> r)) -> Map Verb (Maybe (ByteString -> m (), Maybe BodyLength), r)
newtype VerbListenerT r m a
[VerbListenerT] :: WriterT (Verbs m r) m a -> VerbListenerT r m a
[runVerbListenerT] :: VerbListenerT r m a -> WriterT (Verbs m r) m a
foldMWithKey :: Monad m => (acc -> Verb -> a -> m acc) -> acc -> Map Verb a -> m acc
get :: (Monad m) => r -> VerbListenerT r m ()
getReq :: (Monad m) => (Request -> r) -> VerbListenerT r m ()
post :: (Monad m, MonadIO m) => (ByteString -> m ()) -> r -> VerbListenerT r m ()
postReq :: (Monad m, MonadIO m) => (ByteString -> m ()) -> (Request -> r) -> VerbListenerT r m ()
postMax :: (Monad m, MonadIO m) => BodyLength -> (ByteString -> m ()) -> r -> VerbListenerT r m ()
postMaxReq :: (Monad m, MonadIO m) => BodyLength -> (ByteString -> m ()) -> (Request -> r) -> VerbListenerT r m ()
put :: (Monad m, MonadIO m) => (ByteString -> m ()) -> r -> VerbListenerT r m ()
putReq :: (Monad m, MonadIO m) => (ByteString -> m ()) -> (Request -> r) -> VerbListenerT r m ()
putMax :: (Monad m, MonadIO m) => BodyLength -> (ByteString -> m ()) -> r -> VerbListenerT r m ()
putMaxReq :: (Monad m, MonadIO m) => BodyLength -> (ByteString -> m ()) -> (Request -> r) -> VerbListenerT r m ()
delete :: (Monad m) => r -> VerbListenerT r m ()
deleteReq :: (Monad m) => (Request -> r) -> VerbListenerT r m ()
instance MonadIO m => MonadIO (VerbListenerT r m)
instance Monad m => Monad (VerbListenerT r m)
instance Applicative m => Applicative (VerbListenerT r m)
instance Functor m => Functor (VerbListenerT r m)
instance Monoid (Verbs m r)
instance Ord Verb
instance Eq Verb
instance Show Verb
instance Functor (Verbs m)
instance Foldable (Verbs m)
instance MonadTrans (VerbListenerT r)

module Web.Routes.Nested.FileExtListener.Types
data FileExt
[Html] :: FileExt
[Css] :: FileExt
[JavaScript] :: FileExt
[Json] :: FileExt
[Text] :: FileExt
toExt :: Text -> Maybe FileExt
newtype FileExts a
[FileExts] :: Map FileExt a -> FileExts a
[unFileExts] :: FileExts a -> Map FileExt a
newtype FileExtListenerT r m a
[FileExtListenerT] :: WriterT (FileExts r) m a -> FileExtListenerT r m a
[runFileExtListenerT] :: FileExtListenerT r m a -> WriterT (FileExts r) m a
instance MonadTrans (FileExtListenerT r)
instance MonadIO m => MonadIO (FileExtListenerT r m)
instance Monad m => Monad (FileExtListenerT r m)
instance Applicative m => Applicative (FileExtListenerT r m)
instance Functor m => Functor (FileExtListenerT r m)
instance Traversable FileExts
instance Foldable FileExts
instance Functor FileExts
instance Monoid (FileExts a)
instance Eq a => Eq (FileExts a)
instance Show a => Show (FileExts a)
instance Ord FileExt
instance Eq FileExt
instance Show FileExt

module Web.Routes.Nested.FileExtListener.Builder

-- | A builder is ambiguous, therefore we require <tt>RequestHeaders</tt>
--   and a <tt>FileExt</tt> to be explicitly supplied.
builder :: Monad m => FileExt -> RequestHeaders -> Builder -> FileExtListenerT Response m ()
builderStatus :: Monad m => FileExt -> Status -> RequestHeaders -> Builder -> FileExtListenerT Response m ()
builderOnly :: RequestHeaders -> Builder -> Response

-- | The exact same thing as <tt>Network.Wai.responseBuilder</tt>.
builderOnlyStatus :: Status -> RequestHeaders -> Builder -> Response

module Web.Routes.Nested.FileExtListener.ByteString

-- | <tt>ByteString</tt> is ambiguous - we need to know what
--   <tt>RequestHeaders</tt> and <tt>FileExt</tt> should be associated.
bytestring :: Monad m => FileExt -> RequestHeaders -> ByteString -> FileExtListenerT Response m ()
bytestringStatus :: Monad m => FileExt -> Status -> RequestHeaders -> ByteString -> FileExtListenerT Response m ()
bytestringOnly :: RequestHeaders -> ByteString -> Response

-- | The exact same thing as <tt>Network.Wai.responseLBS</tt>.
bytestringOnlyStatus :: Status -> RequestHeaders -> ByteString -> Response

module Web.Routes.Nested.FileExtListener.Blaze

-- | Uses <tt>Html</tt> as the key in the map, and <tt>"text/html"</tt> as
--   the content type.
blaze :: Monad m => Html -> FileExtListenerT Response m ()
blazeStatus :: Monad m => Status -> Html -> FileExtListenerT Response m ()
blazeHeaders :: Monad m => RequestHeaders -> Html -> FileExtListenerT Response m ()
blazeStatusHeaders :: Monad m => Status -> RequestHeaders -> Html -> FileExtListenerT Response m ()
blazeOnly :: Html -> Response
blazeOnlyHeaders :: RequestHeaders -> Html -> Response
blazeOnlyStatus :: Status -> Html -> Response
blazeOnlyStatusHeaders :: Status -> RequestHeaders -> Html -> Response

module Web.Routes.Nested.FileExtListener.Lucid

-- | Uses the <tt>Html</tt> key in the map, and <tt>"text/html"</tt> as the
--   content type.
lucid :: Monad m => HtmlT m () -> FileExtListenerT Response m ()
lucidStatus :: Monad m => Status -> HtmlT m () -> FileExtListenerT Response m ()
lucidHeaders :: Monad m => RequestHeaders -> HtmlT m () -> FileExtListenerT Response m ()
lucidStatusHeaders :: Monad m => Status -> RequestHeaders -> HtmlT m () -> FileExtListenerT Response m ()
lucidOnly :: Monad m => HtmlT m () -> m Response
lucidOnlyStatus :: Monad m => Status -> HtmlT m () -> m Response
lucidOnlyHeaders :: Monad m => RequestHeaders -> HtmlT m () -> m Response
lucidOnlyStatusHeaders :: Monad m => Status -> RequestHeaders -> HtmlT m () -> m Response

module Web.Routes.Nested.FileExtListener.Text

-- | Uses <tt>Text</tt> as the key in the map, and <tt>"text/plain"</tt> as
--   the content type.
text :: Monad m => Text -> FileExtListenerT Response m ()
textStatus :: Monad m => Status -> Text -> FileExtListenerT Response m ()
textHeaders :: Monad m => RequestHeaders -> Text -> FileExtListenerT Response m ()
textStatusHeaders :: Monad m => Status -> RequestHeaders -> Text -> FileExtListenerT Response m ()
textOnly :: Text -> Response
textOnlyStatus :: Status -> Text -> Response
textOnlyHeaders :: RequestHeaders -> Text -> Response
textOnlyStatusHeaders :: Status -> RequestHeaders -> Text -> Response

module Web.Routes.Nested.FileExtListener.Json

-- | Uses <tt>Json</tt> as the key in the map, and
--   <tt>"application/json"</tt> as the content type.
json :: (ToJSON j, Monad m) => j -> FileExtListenerT Response m ()
jsonStatus :: (ToJSON j, Monad m) => Status -> j -> FileExtListenerT Response m ()

-- | Uses <tt>Json</tt> as the key in the map, and
--   <tt>"application/javascript"</tt> as the content type.
jsonp :: (ToJSON j, Monad m) => j -> FileExtListenerT Response m ()
jsonpStatus :: (ToJSON j, Monad m) => Status -> j -> FileExtListenerT Response m ()
jsonHeaders :: (ToJSON j, Monad m) => RequestHeaders -> j -> FileExtListenerT Response m ()
jsonStatusHeaders :: (ToJSON j, Monad m) => Status -> RequestHeaders -> j -> FileExtListenerT Response m ()
jsonOnly :: ToJSON j => j -> Response
jsonOnlyStatus :: ToJSON j => Status -> j -> Response
jsonpOnly :: ToJSON j => j -> Response
jsonpOnlyStatus :: ToJSON j => Status -> j -> Response
jsonOnlyHeaders :: ToJSON j => RequestHeaders -> j -> Response
jsonOnlyStatusHeaders :: ToJSON j => Status -> RequestHeaders -> j -> Response

module Web.Routes.Nested.FileExtListener.Clay

-- | Uses <tt>Text</tt> as the key in the map, and <tt>"text/css"</tt> as
--   the content type.
clay :: Monad m => Config -> [App] -> Css -> FileExtListenerT Response m ()
clayStatus :: Monad m => Config -> [App] -> Status -> Css -> FileExtListenerT Response m ()
clayHeaders :: Monad m => Config -> [App] -> RequestHeaders -> Css -> FileExtListenerT Response m ()
clayStatusHeaders :: Monad m => Config -> [App] -> Status -> RequestHeaders -> Css -> FileExtListenerT Response m ()
clayOnly :: Config -> [App] -> Css -> Response
clayOnlyStatus :: Config -> [App] -> Status -> Css -> Response
clayOnlyHeaders :: Config -> [App] -> RequestHeaders -> Css -> Response
clayOnlyStatusHeaders :: Config -> [App] -> Status -> RequestHeaders -> Css -> Response

module Web.Routes.Nested.FileExtListener.Julius

-- | Uses <tt>julius</tt> as the key in the map, and
--   <tt>"application/javascript"</tt> as the content type.
julius :: Monad m => Javascript -> FileExtListenerT Response m ()
juliusStatus :: Monad m => Status -> Javascript -> FileExtListenerT Response m ()
juliusHeaders :: Monad m => RequestHeaders -> Javascript -> FileExtListenerT Response m ()
juliusStatusHeaders :: Monad m => Status -> RequestHeaders -> Javascript -> FileExtListenerT Response m ()
juliusOnly :: Javascript -> Response
juliusOnlyStatus :: Status -> Javascript -> Response
juliusOnlyHeaders :: RequestHeaders -> Javascript -> Response
juliusOnlyStatusHeaders :: Status -> RequestHeaders -> Javascript -> Response

module Web.Routes.Nested.FileExtListener.Lucius

-- | Uses <tt>lucius</tt> as the key in the map, and <tt>"lucius/css"</tt>
--   as the content type.
lucius :: Monad m => Css -> FileExtListenerT Response m ()
luciusStatus :: Monad m => Status -> Css -> FileExtListenerT Response m ()
luciusHeaders :: Monad m => RequestHeaders -> Css -> FileExtListenerT Response m ()
luciusStatusHeaders :: Monad m => Status -> RequestHeaders -> Css -> FileExtListenerT Response m ()
luciusOnly :: Css -> Response
luciusOnlyStatus :: Status -> Css -> Response
luciusOnlyHeaders :: RequestHeaders -> Css -> Response
luciusOnlyStatusHeaders :: Status -> RequestHeaders -> Css -> Response

module Web.Routes.Nested.FileExtListener.Cassius

-- | Uses <tt>cassius</tt> as the key in the map, and
--   <tt>"cassius/plain"</tt> as the content type.
cassius :: Monad m => Css -> FileExtListenerT Response m ()
cassiusStatus :: Monad m => Status -> Css -> FileExtListenerT Response m ()
cassiusHeaders :: Monad m => RequestHeaders -> Css -> FileExtListenerT Response m ()
cassiusStatusHeaders :: Monad m => Status -> RequestHeaders -> Css -> FileExtListenerT Response m ()
cassiusOnly :: Css -> Response
cassiusOnlyStatus :: Status -> Css -> Response
cassiusOnlyHeaders :: RequestHeaders -> Css -> Response
cassiusOnlyStatusHeaders :: Status -> RequestHeaders -> Css -> Response

module Web.Routes.Nested.FileExtListener

module Web.Routes.Nested.Types
class Singleton chunks a trie | chunks a -> trie
singleton :: Singleton chunks a trie => chunks -> a -> trie
class Extend eitherUrlChunk child result | eitherUrlChunk child -> result
extend :: Extend eitherUrlChunk child result => eitherUrlChunk -> child -> result
class Extrude chunks start result | chunks start -> result
extrude :: Extrude chunks start result => chunks -> start -> result
eitherToMaybe :: Either String r -> Maybe r
restAreLits :: UrlChunks xs -> Bool
class ToNE chunks
toNE :: ToNE chunks => chunks -> NonEmpty Text
class ToL chunks
toL :: ToL chunks => chunks -> [Text]
instance Singleton (UrlChunks '[]) a (RUPTrie Text a)
instance (Singleton (UrlChunks xs) a trie0, Extend (EitherUrlChunk x) trie0 trie1) => Singleton (UrlChunks (x : xs)) a trie1
instance Extend (EitherUrlChunk 'Nothing) (RUPTrie Text a) (RUPTrie Text a)
instance Extend (EitherUrlChunk ('Just r)) (RUPTrie Text (r -> a)) (RUPTrie Text a)
instance Extrude (UrlChunks '[]) (RUPTrie Text a) (RUPTrie Text a)
instance (Extrude (UrlChunks xs) trie0 trie1, Extend (EitherUrlChunk x) trie1 trie2) => Extrude (UrlChunks (x : xs)) trie0 trie2
instance ToNE (UrlChunks '['Nothing])
instance ToNE (UrlChunks xs) => ToNE (UrlChunks ('Nothing : xs))
instance ToL (UrlChunks '[])
instance ToL (UrlChunks xs) => ToL (UrlChunks ('Nothing : xs))

module Web.Routes.Nested
newtype HandlerT x m a
[HandlerT] :: WriterT (RUPTrie Text x, RUPTrie Text x) m a -> HandlerT x m a
[runHandler] :: HandlerT x m a -> WriterT (RUPTrie Text x, RUPTrie Text x) m a
type ActionT m a = VerbListenerT (FileExtListenerT Response m a) m a

-- | For routes ending with a literal.
handle :: (Monad m, Functor m, cleanxs ~ OnlyJusts xs, HasResult childType (ActionT m ()), ExpectArity cleanxs childType, Singleton (UrlChunks xs) childType (RUPTrie Text result), Extrude (UrlChunks xs) (RUPTrie Text childType) (RUPTrie Text result), (ArityMinusTypeList childType cleanxs) ~ result, childType ~ TypeListToArity cleanxs result) => UrlChunks xs -> Maybe childType -> Maybe (HandlerT childType m ()) -> HandlerT result m ()
parent :: (Monad m, Functor m, cleanxs ~ OnlyJusts xs, Singleton (UrlChunks xs) childType (RUPTrie Text result), Extrude (UrlChunks xs) (RUPTrie Text childType) (RUPTrie Text result), (ArityMinusTypeList childType cleanxs) ~ result, childType ~ TypeListToArity cleanxs result) => UrlChunks xs -> HandlerT childType m () -> HandlerT result m ()
notFound :: (Monad m, Functor m, cleanxs ~ OnlyJusts xs, HasResult childType (ActionT m ()), ExpectArity cleanxs childType, Singleton (UrlChunks xs) childType (RUPTrie Text result), Extrude (UrlChunks xs) (RUPTrie Text childType) (RUPTrie Text result), (ArityMinusTypeList childType cleanxs) ~ result, childType ~ TypeListToArity cleanxs result) => UrlChunks xs -> Maybe childType -> Maybe (HandlerT childType m ()) -> HandlerT result m ()

-- | Turns a <tt>HandlerT</tt> into a Wai <tt>Application</tt>
route :: (Functor m, Monad m, MonadIO m) => HandlerT (ActionT m ()) m a -> Request -> (Response -> IO ResponseReceived) -> m ResponseReceived
instance MonadTrans (HandlerT x)
instance MonadIO m => MonadIO (HandlerT x m)
instance Monad m => Monad (HandlerT x m)
instance Applicative m => Applicative (HandlerT x m)
instance Functor m => Functor (HandlerT x m)
