-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typesafe URLs for Wai applications.
--   
@package wai-routes
@version 0.7.1


-- | Defines the commonly used content types
module Network.Wai.Middleware.Routes.ContentTypes

-- | Creates a content type header Ready to be passed to
--   <tt>responseLBS</tt>
contentType :: HeaderName
typeHtml :: ByteString
typePlain :: ByteString
typeJson :: ByteString
typeXml :: ByteString
typeAtom :: ByteString
typeRss :: ByteString
typeJpeg :: ByteString
typePng :: ByteString
typeGif :: ByteString
typeSvg :: ByteString
typeJavascript :: ByteString
typeCss :: ByteString
typeFlv :: ByteString
typeOgv :: ByteString
typeOctet :: ByteString

module Network.Wai.Middleware.Routes.Class
class Eq (Route a) => RenderRoute a where data family Route a
renderRoute :: RenderRoute a => Route a -> ([Text], [(Text, Text)])
class RenderRoute a => ParseRoute a
parseRoute :: ParseRoute a => ([Text], [(Text, Text)]) -> Maybe (Route a)
class RenderRoute a => RouteAttrs a
routeAttrs :: RouteAttrs a => Route a -> Set Text


-- | Warning! This module is considered internal and may have breaking
--   changes
module Network.Wai.Middleware.Routes.TH.Types
data Resource typ
Resource :: String -> [Piece typ] -> Dispatch typ -> [String] -> CheckOverlap -> Resource typ
resourceName :: Resource typ -> String
resourcePieces :: Resource typ -> [Piece typ]
resourceDispatch :: Resource typ -> Dispatch typ
resourceAttrs :: Resource typ -> [String]
resourceCheck :: Resource typ -> CheckOverlap
data ResourceTree typ
ResourceLeaf :: (Resource typ) -> ResourceTree typ
ResourceParent :: String -> CheckOverlap -> [Piece typ] -> [ResourceTree typ] -> ResourceTree typ
data Piece typ
Static :: String -> Piece typ
Dynamic :: typ -> Piece typ
data Dispatch typ
Methods :: Maybe typ -> [String] -> Dispatch typ

-- | type of the multi piece at the end
methodsMulti :: Dispatch typ -> Maybe typ

-- | supported request methods
methodsMethods :: Dispatch typ -> [String]
Subsite :: typ -> String -> Dispatch typ
subsiteType :: Dispatch typ -> typ
subsiteFunc :: Dispatch typ -> String
type CheckOverlap = Bool
data FlatResource a
FlatResource :: [(String, [Piece a])] -> String -> [Piece a] -> Dispatch a -> Bool -> FlatResource a
frParentPieces :: FlatResource a -> [(String, [Piece a])]
frName :: FlatResource a -> String
frPieces :: FlatResource a -> [Piece a]
frDispatch :: FlatResource a -> Dispatch a
frCheck :: FlatResource a -> Bool
resourceMulti :: Resource typ -> Maybe typ
resourceTreePieces :: ResourceTree typ -> [Piece typ]
resourceTreeName :: ResourceTree typ -> String
flatten :: [ResourceTree a] -> [FlatResource a]
instance Show typ => Show (Piece typ)
instance Show typ => Show (Dispatch typ)
instance Show typ => Show (Resource typ)
instance Functor Resource
instance Functor ResourceTree
instance Lift t => Lift (Dispatch t)
instance Functor Dispatch
instance Lift t => Lift (Piece t)
instance Functor Piece
instance Lift t => Lift (Resource t)
instance Lift t => Lift (ResourceTree t)

module Network.Wai.Middleware.Routes.TH.RenderRoute

-- | Generate the <a>RenderRoute</a> instance.
--   
--   This includes both the <a>Route</a> associated type and the
--   <a>renderRoute</a> method. This function uses both <a>mkRouteCons</a>
--   and <tt>mkRenderRouteClasses</tt>.
mkRenderRouteInstance :: Type -> [ResourceTree Type] -> Q [Dec]

-- | A more general version of <a>mkRenderRouteInstance</a> which takes an
--   additional context.
mkRenderRouteInstance' :: Cxt -> Type -> [ResourceTree Type] -> Q [Dec]

-- | Generate the constructors of a route data type.
mkRouteCons :: [ResourceTree Type] -> ([Con], [Dec])

-- | Clauses for the <a>renderRoute</a> method.
mkRenderRouteClauses :: [ResourceTree Type] -> Q [Clause]

module Network.Wai.Middleware.Routes.TH.RouteAttrs
mkRouteAttrsInstance :: Type -> [ResourceTree a] -> Q Dec

module Network.Wai.Middleware.Routes.TH.Dispatch
data MkDispatchSettings
MkDispatchSettings :: Q Exp -> Q Exp -> Q Exp -> Q Exp -> Q Exp -> Q Exp -> Q Exp -> (Maybe String -> String -> Q Exp) -> MkDispatchSettings
mdsRunHandler :: MkDispatchSettings -> Q Exp
mdsSubDispatcher :: MkDispatchSettings -> Q Exp
mdsGetPathInfo :: MkDispatchSettings -> Q Exp
mdsSetPathInfo :: MkDispatchSettings -> Q Exp
mdsMethod :: MkDispatchSettings -> Q Exp
mds404 :: MkDispatchSettings -> Q Exp
mds405 :: MkDispatchSettings -> Q Exp
mdsGetHandler :: MkDispatchSettings -> Maybe String -> String -> Q Exp

-- | A simpler version of
--   Network.Wai.Middleware.Routes.TH.Dispatch.mkDispatchClause, based on
--   view patterns.
--   
--   Since 1.4.0
mkDispatchClause :: MkDispatchSettings -> [ResourceTree a] -> Q Clause
defaultGetHandler :: Maybe String -> String -> Q Exp

module Network.Wai.Middleware.Routes.TH.ParseRoute
mkParseRouteInstance :: Type -> [ResourceTree a] -> Q Dec


-- | Check for overlapping routes.
module Network.Wai.Middleware.Routes.Overlap
findOverlapNames :: [ResourceTree t] -> [(String, String)]
data Overlap t
Overlap :: ([String] -> [String]) -> ResourceTree t -> ResourceTree t -> Overlap t

-- | parent resource trees
overlapParents :: Overlap t -> [String] -> [String]
overlap1 :: Overlap t -> ResourceTree t
overlap2 :: Overlap t -> ResourceTree t

module Network.Wai.Middleware.Routes.TH

module Network.Wai.Middleware.Routes.Parse

-- | A quasi-quoter to parse a string into a list of <a>Resource</a>s.
--   Checks for overlapping routes, failing if present; use
--   <a>parseRoutesNoCheck</a> to skip the checking. See documentation site
--   for details on syntax.
parseRoutes :: QuasiQuoter
parseRoutesFile :: FilePath -> Q Exp

-- | Same as <a>parseRoutes</a>, but performs no overlap checking.
parseRoutesNoCheck :: QuasiQuoter
parseRoutesFileNoCheck :: FilePath -> Q Exp
parseType :: String -> Type
parseTypeTree :: String -> Maybe TypeTree
data TypeTree
TTTerm :: String -> TypeTree
TTApp :: TypeTree -> TypeTree -> TypeTree
TTList :: TypeTree -> TypeTree
instance Show TypeTree
instance Eq TypeTree


-- | This package provides typesafe URLs for Wai applications.
module Network.Wai.Middleware.Routes.Routes

-- | A quasi-quoter to parse a string into a list of <a>Resource</a>s.
--   Checks for overlapping routes, failing if present; use
--   <a>parseRoutesNoCheck</a> to skip the checking. See documentation site
--   for details on syntax.
parseRoutes :: QuasiQuoter
parseRoutesFile :: FilePath -> Q Exp

-- | Same as <a>parseRoutes</a>, but performs no overlap checking.
parseRoutesNoCheck :: QuasiQuoter
parseRoutesFileNoCheck :: FilePath -> Q Exp

-- | Generates all the things needed for efficient routing, including your
--   application's <a>Route</a> datatype, and <a>RenderRoute</a>,
--   <a>ParseRoute</a>, and <tt>RouteAttr</tt> instances, and
--   <a>Routable</a> instance
mkRoute :: String -> [ResourceTree String] -> Q [Dec]

-- | Generates everything except <a>Routable</a> instance and dispatch
--   function
mkRouteData :: String -> [ResourceTree String] -> Q [Dec]

-- | Generates a <a>Routable</a> instance and dispatch function
mkRouteDispatch :: String -> [ResourceTree String] -> Q [Dec]
mkRouteSubDispatch :: [ResourceTree a] -> Q Exp

-- | Generates the application middleware from a <a>Routable</a> master
--   datatype
routeDispatch :: Routable master master => master -> Middleware

-- | Renders a <a>Route</a> as Text
showRoute :: RenderRoute master => Route master -> Text

-- | Render a <a>Route</a> and Query parameters to Text
showRouteQuery :: RenderRoute master => Route master -> [(Text, Text)] -> Text

-- | Read a route from Text Returns Nothing if Route reading failed. Just
--   route otherwise
readRoute :: ParseRoute master => Text -> Maybe (Route master)

-- | A <a>Handler</a> generates an App from the master datatype
type Handler master = HandlerS master master
type HandlerS sub master = Env sub master -> App sub
type ResponseHandler = (Response -> IO ResponseReceived) -> IO ResponseReceived

-- | A <a>Routable</a> instance can be used in dispatching. An appropriate
--   instance for your site datatype is automatically generated by
--   <a>mkRoute</a>.
class Routable sub master
dispatcher :: Routable sub master => HandlerS sub master
class Eq (Route a) => RenderRoute a where data family Route a
renderRoute :: RenderRoute a => Route a -> ([Text], [(Text, Text)])
class RenderRoute a => ParseRoute a
parseRoute :: ParseRoute a => ([Text], [(Text, Text)]) -> Maybe (Route a)
class RenderRoute a => RouteAttrs a
routeAttrs :: RouteAttrs a => Route a -> Set Text
data Env sub master
Env :: master -> sub -> (Route sub -> Route master) -> Env sub master
envMaster :: Env sub master -> master
envSub :: Env sub master -> sub
envToMaster :: Env sub master -> Route sub -> Route master
data RequestData master
waiReq :: RequestData master -> Request
nextApp :: RequestData master -> Application
currentRoute :: RequestData master -> Maybe (Route master)

-- | Run the next application in the stack
runNext :: App master


-- | Defines a Routing Monad that provides easy composition of Routes
module Network.Wai.Middleware.Routes.Monad

-- | The Route Monad
data RouteM a

-- | Set the default action of the Application. You should only call this
--   once in an application. Subsequent invocations override the previous
--   settings.
defaultAction :: Application -> RouteM ()

-- | Add a middleware to the application. Middleware is nested so the one
--   declared earlier is outer.
middleware :: Middleware -> RouteM ()

-- | Add a route to the application. Routes are ordered so the one declared
--   earlier is matched first.
route :: Routable master master => master -> RouteM ()

-- | Convert a RouteM Monadic value into a wai application.
toWaiApp :: RouteM () -> IO Application
instance Applicative RouteM
instance Monad RouteM
instance MonadIO RouteM
instance Functor RouteM
instance MonadState RouteState RouteM


-- | Provides a HandlerM Monad that makes it easy to build Handlers
module Network.Wai.Middleware.Routes.Handler

-- | The HandlerM Monad
type HandlerM sub master a = HandlerMI sub master IO a

-- | <a>Run</a> HandlerM, resulting in a Handler
runHandlerM :: HandlerM sub master () -> HandlerS sub master

-- | Get the request
request :: HandlerM sub master Request

-- | Get the current route attributes
routeAttrSet :: RouteAttrs sub => HandlerM sub master (Set Text)

-- | Get the attributes for the current root route
rootRouteAttrSet :: RouteAttrs master => HandlerM sub master (Set Text)

-- | Get the current route
maybeRoute :: HandlerM sub master (Maybe (Route sub))

-- | Get the current root route
maybeRootRoute :: HandlerM sub master (Maybe (Route master))

-- | Get the master
master :: HandlerM sub master master

-- | Add a header to the application response TODO: Differentiate between
--   setting and adding headers
header :: HeaderName -> ByteString -> HandlerM sub master ()

-- | Set the response status
status :: Status -> HandlerM sub master ()

-- | Set the response body TODO: Add functions to append to body, and also
--   to flush body contents
raw :: ByteString -> HandlerM sub master ()

-- | Set the body of the response to the JSON encoding of the given value.
--   Also sets "Content-Type" header to "application/json".
json :: ToJSON a => a -> HandlerM sub master ()

-- | Set the body of the response to the given <a>Text</a> value. Also sets
--   "Content-Type" header to "text/plain".
plain :: Text -> HandlerM sub master ()

-- | Set the body of the response to the given <a>Text</a> value. Also sets
--   "Content-Type" header to "text/html".
html :: Text -> HandlerM sub master ()

-- | Run the next application
next :: HandlerM sub master ()
instance (Monad m, Functor m) => Applicative (HandlerMI sub master m)
instance Monad m => Monad (HandlerMI sub master m)
instance MonadIO m => MonadIO (HandlerMI sub master m)
instance Functor m => Functor (HandlerMI sub master m)
instance MonadTrans (HandlerMI sub master)
instance Monad m => MonadState (HandlerState sub master) (HandlerMI sub master m)


-- | This package provides typesafe URLs for Wai applications.
module Network.Wai.Middleware.Routes

-- | A quasi-quoter to parse a string into a list of <a>Resource</a>s.
--   Checks for overlapping routes, failing if present; use
--   <a>parseRoutesNoCheck</a> to skip the checking. See documentation site
--   for details on syntax.
parseRoutes :: QuasiQuoter
parseRoutesFile :: FilePath -> Q Exp

-- | Same as <a>parseRoutes</a>, but performs no overlap checking.
parseRoutesNoCheck :: QuasiQuoter
parseRoutesFileNoCheck :: FilePath -> Q Exp

-- | Generates all the things needed for efficient routing, including your
--   application's <a>Route</a> datatype, and <a>RenderRoute</a>,
--   <a>ParseRoute</a>, and <tt>RouteAttr</tt> instances, and
--   <a>Routable</a> instance
mkRoute :: String -> [ResourceTree String] -> Q [Dec]

-- | Generates everything except <a>Routable</a> instance and dispatch
--   function
mkRouteData :: String -> [ResourceTree String] -> Q [Dec]

-- | Generates a <a>Routable</a> instance and dispatch function
mkRouteDispatch :: String -> [ResourceTree String] -> Q [Dec]
mkRouteSubDispatch :: [ResourceTree a] -> Q Exp

-- | Generates the application middleware from a <a>Routable</a> master
--   datatype
routeDispatch :: Routable master master => master -> Middleware

-- | Renders a <a>Route</a> as Text
showRoute :: RenderRoute master => Route master -> Text

-- | Render a <a>Route</a> and Query parameters to Text
showRouteQuery :: RenderRoute master => Route master -> [(Text, Text)] -> Text

-- | Read a route from Text Returns Nothing if Route reading failed. Just
--   route otherwise
readRoute :: ParseRoute master => Text -> Maybe (Route master)

-- | A <a>Handler</a> generates an App from the master datatype
type Handler master = HandlerS master master
type HandlerS sub master = Env sub master -> App sub

-- | A <a>Routable</a> instance can be used in dispatching. An appropriate
--   instance for your site datatype is automatically generated by
--   <a>mkRoute</a>.
class Routable sub master
dispatcher :: Routable sub master => HandlerS sub master
class Eq (Route a) => RenderRoute a where data family Route a
renderRoute :: RenderRoute a => Route a -> ([Text], [(Text, Text)])
class RenderRoute a => ParseRoute a
parseRoute :: ParseRoute a => ([Text], [(Text, Text)]) -> Maybe (Route a)
class RenderRoute a => RouteAttrs a
routeAttrs :: RouteAttrs a => Route a -> Set Text
data RequestData master
waiReq :: RequestData master -> Request
nextApp :: RequestData master -> Application

-- | Run the next application in the stack
runNext :: App master

-- | The Route Monad
data RouteM a

-- | Set the default action of the Application. You should only call this
--   once in an application. Subsequent invocations override the previous
--   settings.
defaultAction :: Application -> RouteM ()

-- | Add a middleware to the application. Middleware is nested so the one
--   declared earlier is outer.
middleware :: Middleware -> RouteM ()

-- | Add a route to the application. Routes are ordered so the one declared
--   earlier is matched first.
route :: Routable master master => master -> RouteM ()

-- | Convert a RouteM Monadic value into a wai application.
toWaiApp :: RouteM () -> IO Application

-- | The HandlerM Monad
type HandlerM sub master a = HandlerMI sub master IO a

-- | <a>Run</a> HandlerM, resulting in a Handler
runHandlerM :: HandlerM sub master () -> HandlerS sub master

-- | Get the request
request :: HandlerM sub master Request

-- | Get the current root route
maybeRootRoute :: HandlerM sub master (Maybe (Route master))

-- | Get the current route
maybeRoute :: HandlerM sub master (Maybe (Route sub))

-- | Get the current route attributes
routeAttrSet :: RouteAttrs sub => HandlerM sub master (Set Text)

-- | Get the attributes for the current root route
rootRouteAttrSet :: RouteAttrs master => HandlerM sub master (Set Text)

-- | Get the master
master :: HandlerM sub master master

-- | Add a header to the application response TODO: Differentiate between
--   setting and adding headers
header :: HeaderName -> ByteString -> HandlerM sub master ()

-- | Set the response status
status :: Status -> HandlerM sub master ()

-- | Set the response body TODO: Add functions to append to body, and also
--   to flush body contents
raw :: ByteString -> HandlerM sub master ()

-- | Set the body of the response to the JSON encoding of the given value.
--   Also sets "Content-Type" header to "application/json".
json :: ToJSON a => a -> HandlerM sub master ()

-- | Set the body of the response to the given <a>Text</a> value. Also sets
--   "Content-Type" header to "text/plain".
plain :: Text -> HandlerM sub master ()

-- | Set the body of the response to the given <a>Text</a> value. Also sets
--   "Content-Type" header to "text/html".
html :: Text -> HandlerM sub master ()

-- | Run the next application
next :: HandlerM sub master ()
