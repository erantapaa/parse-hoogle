-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A data type for non-exclusive disjunction.
--   
@package data-or
@version 1.0.0.5


-- | A data type for non-exclusive disjunction. This is helpful for things
--   like a generic merge function on sets/maps which could be union,
--   mutual difference, etc. based on which <a>Or</a> value a function
--   argument returns. Also useful for non-truncating zips (cf.
--   <a>zipOr</a>) and other cases where you sometimes want an
--   <a>Either</a> and sometimes want a pair.
module Data.Or

-- | A data type for non-exclusive disjunction.
data Or a b
Fst :: a -> Or a b
Both :: a -> b -> Or a b
Snd :: b -> Or a b

-- | Functional eliminator for <a>Or</a>.
elimOr :: (a -> c) -> (a -> b -> c) -> (b -> c) -> Or a b -> c

-- | Convert an <a>Either</a> into an <a>Or</a>.
eitherOr :: Either a b -> Or a b

-- | A variant of <a>zip</a> which exhausts both lists, annotating which
--   list the elements came from. It will return zero or more
--   <tt>Both</tt>, followed by either zero or more <tt>Fst</tt> or else
--   zero or more <tt>Snd</tt>.
--   
--   On GHC this is a "good producer" for list fusion.
zipOr :: [a] -> [b] -> [Or a b]

-- | A variant of <a>zipOr</a> with a custom <a>Or</a>-homomorphism.
--   
--   On GHC this is a "good producer" for list fusion.
zipOrWith :: (Or a b -> c) -> [a] -> [b] -> [c]

-- | A variant of <a>zipOr</a> with a custom list-homomorphism.
zipOrBy :: (Or a b -> c -> c) -> c -> [a] -> [b] -> c

-- | A variant of <a>zipOr</a> with both a custom <a>Or</a>-homomorphism
--   and a custom list-homomorphism. This is no more powerful than
--   <a>zipOrBy</a>, but it may be more convenient to separate the handling
--   of <a>Or</a> from the handling of <tt>(:)</tt>.
zipOrWithBy :: (Or a b -> c) -> (c -> d -> d) -> d -> [a] -> [b] -> d
instance (Read a, Read b) => Read (Or a b)
instance (Show a, Show b) => Show (Or a b)
instance (Eq a, Eq b) => Eq (Or a b)
