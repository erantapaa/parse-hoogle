-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A compiler for Fay, a Haskell subset that compiles to JavaScript.
--   
@package fay
@version 0.23.1.7

module Fay.Types.CompileResult
data CompileResult
CompileResult :: String -> [(String, FilePath)] -> Maybe [Mapping] -> CompileResult
resOutput :: CompileResult -> String
resImported :: CompileResult -> [(String, FilePath)]
resSourceMappings :: CompileResult -> Maybe [Mapping]
instance Show CompileResult

module Fay.Compiler.Parse

-- | Parse some Fay code.
parseFay :: Parseable ast => FilePath -> String -> ParseResult ast
defaultExtensions :: [Extension]


-- | Re-exports of base functionality. Note that this module is just used
--   inside the compiler. It's not compiled to JavaScript. Based on the
--   base-extended package (c) 2013 Simon Meier, licensed as BSD3.
module Fay.Compiler.Prelude

-- | Do any of the (monadic) predicates match?
anyM :: Monad m => (a -> m Bool) -> [a] -> m Bool

-- | Flip of map.
for :: Functor f => f a -> (a -> b) -> f b

-- | Alias of liftIO, I hate typing it. Hate reading it.
io :: MonadIO m => IO a -> m a

-- | Read from a process returning both std err and out.
readAllFromProcess :: FilePath -> [String] -> String -> IO (Either (String, String) (String, String))

module Fay.Types.CompileError

-- | Error type.
data CompileError
Couldn'tFindImport :: ModuleName -> [FilePath] -> CompileError
EmptyDoBlock :: CompileError
FfiFormatBadChars :: SrcSpanInfo -> String -> CompileError
FfiFormatIncompleteArg :: SrcSpanInfo -> CompileError
FfiFormatInvalidJavaScript :: SrcSpanInfo -> String -> String -> CompileError
FfiFormatNoSuchArg :: SrcSpanInfo -> Int -> CompileError
FfiNeedsTypeSig :: Exp -> CompileError
GHCError :: String -> CompileError
InvalidDoBlock :: CompileError
ParseError :: SrcLoc -> String -> CompileError
ShouldBeDesugared :: String -> CompileError
UnableResolveQualified :: QName -> CompileError
UnsupportedDeclaration :: Decl -> CompileError
UnsupportedEnum :: Exp -> CompileError
UnsupportedExportSpec :: ExportSpec -> CompileError
UnsupportedExpression :: Exp -> CompileError
UnsupportedFieldPattern :: PatField -> CompileError
UnsupportedImport :: ImportDecl -> CompileError
UnsupportedLet :: CompileError
UnsupportedLetBinding :: Decl -> CompileError
UnsupportedLiteral :: Literal -> CompileError
UnsupportedModuleSyntax :: String -> Module -> CompileError
UnsupportedPattern :: Pat -> CompileError
UnsupportedQualStmt :: QualStmt -> CompileError
UnsupportedRecursiveDo :: CompileError
UnsupportedRhs :: Rhs -> CompileError
UnsupportedWhereInAlt :: Alt -> CompileError
UnsupportedWhereInMatch :: Match -> CompileError
instance Show CompileError


-- | Convert a Haskell value to a (JSON representation of a) Fay value.
module Fay.Convert

-- | Convert a Haskell value to a Fay json value. This can fail when
--   primitive values aren't handled by explicit cases. <a>encodeFay</a>
--   can be used to resolve this issue.
showToFay :: Data a => a -> Maybe Value

-- | Convert a Fay json value to a Haskell value.
readFromFay :: Data a => Value -> Maybe a

-- | Convert a Fay json value to a Haskell value. This is like readFromFay,
--   except it yields helpful error messages on failure.
readFromFay' :: Data a => Value -> Either String a

-- | Convert a Haskell value to a Fay json value. This can fail when
--   primitive values aren't handled by explicit cases. When this happens,
--   you can add additional cases via the first parameter.
--   
--   The first parameter is a function that can be used to override the
--   conversion. This usually looks like using <a>extQ</a> to additional
--   type- specific cases.
encodeFay :: (GenericQ Value -> GenericQ Value) -> GenericQ Value

-- | Convert a Fay json value to a Haskell value.
--   
--   The first parameter is a function that can be used to override the
--   conversion. This usually looks like using <a>extR</a> to additional
--   type- specific cases.
decodeFay :: Data b => (forall a. Data a => Value -> Either String a -> Either String a) -> Value -> Either String b


-- | Configuring the compiler
module Fay.Config

-- | Configuration of the compiler. The fields with a leading underscore
data Config
defaultConfig :: Config
defaultConfigWithSandbox :: IO Config

-- | Reading _configDirectoryIncludes is safe to do.
configDirectoryIncludes :: Config -> [(Maybe String, FilePath)]

-- | Get all include directories without the package mapping.
configDirectoryIncludePaths :: Config -> [FilePath]

-- | Get all include directories not included through packages.
nonPackageConfigDirectoryIncludePaths :: Config -> [FilePath]

-- | Add a mapping from (maybe) a package to a source directory
addConfigDirectoryInclude :: Maybe String -> FilePath -> Config -> Config

-- | Add several include directories.
addConfigDirectoryIncludes :: [(Maybe String, FilePath)] -> Config -> Config

-- | Add several include directories without package references.
addConfigDirectoryIncludePaths :: [FilePath] -> Config -> Config

-- | Reading _configPackages is safe to do.
configPackages :: Config -> [String]

-- | Add a package to compilation
addConfigPackage :: String -> Config -> Config

-- | Add several packages to compilation
addConfigPackages :: [String] -> Config -> Config

-- | Should a strict wrapper be generated for this module?
shouldExportStrictWrapper :: ModuleName a -> Config -> Bool
instance Show Config
instance Default Config


-- | All Fay types and instances.
module Fay.Types

-- | Statement type.
data JsStmt
JsVar :: JsName -> JsExp -> JsStmt
JsIf :: JsExp -> [JsStmt] -> [JsStmt] -> JsStmt
JsEarlyReturn :: JsExp -> JsStmt
JsThrow :: JsExp -> JsStmt
JsWhile :: JsExp -> [JsStmt] -> JsStmt
JsUpdate :: JsName -> JsExp -> JsStmt
JsSetProp :: JsName -> JsName -> JsExp -> JsStmt
JsSetQName :: (Maybe SrcSpan) -> QName -> JsExp -> JsStmt
JsSetModule :: ModulePath -> JsExp -> JsStmt
JsSetConstructor :: QName -> JsExp -> JsStmt
JsSetPropExtern :: JsName -> JsName -> JsExp -> JsStmt
JsContinue :: JsStmt
JsBlock :: [JsStmt] -> JsStmt
JsExpStmt :: JsExp -> JsStmt

-- | Expression type.
data JsExp
JsName :: JsName -> JsExp
JsRawExp :: String -> JsExp
JsSeq :: [JsExp] -> JsExp
JsFun :: (Maybe JsName) -> [JsName] -> [JsStmt] -> (Maybe JsExp) -> JsExp
JsLit :: JsLit -> JsExp
JsApp :: JsExp -> [JsExp] -> JsExp
JsNegApp :: JsExp -> JsExp
JsTernaryIf :: JsExp -> JsExp -> JsExp -> JsExp
JsNull :: JsExp
JsParen :: JsExp -> JsExp
JsGetProp :: JsExp -> JsName -> JsExp
JsLookup :: JsExp -> JsExp -> JsExp
JsUpdateProp :: JsExp -> JsName -> JsExp -> JsExp
JsGetPropExtern :: JsExp -> String -> JsExp
JsUpdatePropExtern :: JsExp -> JsName -> JsExp -> JsExp
JsList :: [JsExp] -> JsExp
JsNew :: JsName -> [JsExp] -> JsExp
JsThrowExp :: JsExp -> JsExp
JsInstanceOf :: JsExp -> JsName -> JsExp
JsIndex :: Int -> JsExp -> JsExp
JsEq :: JsExp -> JsExp -> JsExp
JsNeq :: JsExp -> JsExp -> JsExp
JsInfix :: String -> JsExp -> JsExp -> JsExp
JsObj :: [(String, JsExp)] -> JsExp
JsLitObj :: [(Name, JsExp)] -> JsExp
JsUndefined :: JsExp
JsAnd :: JsExp -> JsExp -> JsExp
JsOr :: JsExp -> JsExp -> JsExp

-- | Literal value type.
data JsLit
JsChar :: Char -> JsLit
JsStr :: String -> JsLit
JsInt :: Int -> JsLit
JsFloating :: Double -> JsLit
JsBool :: Bool -> JsLit

-- | A name of some kind.
data JsName
JsNameVar :: QName -> JsName
JsThis :: JsName
JsParametrizedType :: JsName
JsThunk :: JsName
JsForce :: JsName
JsApply :: JsName
JsParam :: Integer -> JsName
JsTmp :: Integer -> JsName
JsConstructor :: QName -> JsName
JsBuiltIn :: Name -> JsName
JsModuleName :: ModuleName -> JsName

-- | Error type.
data CompileError
Couldn'tFindImport :: ModuleName -> [FilePath] -> CompileError
EmptyDoBlock :: CompileError
FfiFormatBadChars :: SrcSpanInfo -> String -> CompileError
FfiFormatIncompleteArg :: SrcSpanInfo -> CompileError
FfiFormatInvalidJavaScript :: SrcSpanInfo -> String -> String -> CompileError
FfiFormatNoSuchArg :: SrcSpanInfo -> Int -> CompileError
FfiNeedsTypeSig :: Exp -> CompileError
GHCError :: String -> CompileError
InvalidDoBlock :: CompileError
ParseError :: SrcLoc -> String -> CompileError
ShouldBeDesugared :: String -> CompileError
UnableResolveQualified :: QName -> CompileError
UnsupportedDeclaration :: Decl -> CompileError
UnsupportedEnum :: Exp -> CompileError
UnsupportedExportSpec :: ExportSpec -> CompileError
UnsupportedExpression :: Exp -> CompileError
UnsupportedFieldPattern :: PatField -> CompileError
UnsupportedImport :: ImportDecl -> CompileError
UnsupportedLet :: CompileError
UnsupportedLetBinding :: Decl -> CompileError
UnsupportedLiteral :: Literal -> CompileError
UnsupportedModuleSyntax :: String -> Module -> CompileError
UnsupportedPattern :: Pat -> CompileError
UnsupportedQualStmt :: QualStmt -> CompileError
UnsupportedRecursiveDo :: CompileError
UnsupportedRhs :: Rhs -> CompileError
UnsupportedWhereInAlt :: Alt -> CompileError
UnsupportedWhereInMatch :: Match -> CompileError

-- | Compile monad.
newtype Compile a
Compile :: RWST CompileReader CompileWriter CompileState (ExceptT CompileError (ModuleT (ModuleInfo Compile) IO)) a -> Compile a

-- | Uns the compiler
unCompile :: Compile a -> RWST CompileReader CompileWriter CompileState (ExceptT CompileError (ModuleT (ModuleInfo Compile) IO)) a
type CompileModule a = ModuleT Symbols IO (Either CompileError (a, CompileState, CompileWriter))

-- | Print some value.
class Printable a
printJS :: Printable a => a -> Printer

-- | The JavaScript FFI interfacing monad.
data Fay a

-- | Configuration and globals for the compiler.
data CompileReader
CompileReader :: Config -> (Sign -> Literal -> Compile JsExp) -> (Bool -> [Decl] -> Compile [JsStmt]) -> CompileReader

-- | The compilation configuration.
readerConfig :: CompileReader -> Config
readerCompileLit :: CompileReader -> Sign -> Literal -> Compile JsExp
readerCompileDecls :: CompileReader -> Bool -> [Decl] -> Compile [JsStmt]
data CompileResult
CompileResult :: String -> [(String, FilePath)] -> Maybe [Mapping] -> CompileResult
resOutput :: CompileResult -> String
resImported :: CompileResult -> [(String, FilePath)]
resSourceMappings :: CompileResult -> Maybe [Mapping]

-- | Things written out by the compiler.
data CompileWriter
CompileWriter :: [JsStmt] -> [(String, JsExp)] -> [(String, JsExp)] -> CompileWriter

-- | Constructors.
writerCons :: CompileWriter -> [JsStmt]

-- | Fay to JS dispatchers.
writerFayToJs :: CompileWriter -> [(String, JsExp)]

-- | JS to Fay dispatchers.
writerJsToFay :: CompileWriter -> [(String, JsExp)]

-- | Configuration of the compiler. The fields with a leading underscore
data Config

-- | State of the compiler.
data CompileState
CompileState :: Map ModuleName Symbols -> [(QName, [QName])] -> [(QName, [Name])] -> [(QName, Maybe QName, Type)] -> [(ModuleName, FilePath)] -> Integer -> ModuleName -> Set ModulePath -> Bool -> Map QName Type -> CompileState

-- | Exported identifiers for all modules
stateInterfaces :: CompileState -> Map ModuleName Symbols

-- | Map types to constructors
stateRecordTypes :: CompileState -> [(QName, [QName])]

-- | Map constructors to fields
stateRecords :: CompileState -> [(QName, [Name])]

-- | Newtype constructor, destructor, wrapped type tuple
stateNewtypes :: CompileState -> [(QName, Maybe QName, Type)]

-- | Map of all imported modules and their source locations.
stateImported :: CompileState -> [(ModuleName, FilePath)]

-- | Depth of the current lexical scope, used for creating unshadowing
--   variables.
stateNameDepth :: CompileState -> Integer

-- | Name of the module currently being compiled.
stateModuleName :: CompileState -> ModuleName

-- | Module paths that have code generated for them.
stateJsModulePaths :: CompileState -> Set ModulePath

-- | Use JS Strings instead of [Char] for string literals?
stateUseFromString :: CompileState -> Bool

-- | Module level declarations having explicit type signatures
stateTypeSigs :: CompileState -> Map QName Type

-- | These are the data types that are serializable directly to native JS
--   data types. Strings, floating points and arrays. The others are:
--   actions in the JS monad, which are thunks that shouldn't be forced
--   when serialized but wrapped up as JS zero-arg functions, and unknown
--   types can't be converted but should at least be forced.
data FundamentalType
FunctionType :: [FundamentalType] -> FundamentalType
JsType :: FundamentalType -> FundamentalType
ListType :: FundamentalType -> FundamentalType
TupleType :: [FundamentalType] -> FundamentalType
UserDefined :: Name -> [FundamentalType] -> FundamentalType
Defined :: FundamentalType -> FundamentalType
Nullable :: FundamentalType -> FundamentalType
DateType :: FundamentalType
StringType :: FundamentalType
DoubleType :: FundamentalType
IntType :: FundamentalType
BoolType :: FundamentalType
PtrType :: FundamentalType
Automatic :: FundamentalType
UnknownType :: FundamentalType

-- | The state of the pretty printer.
data PrintState
PrintState :: Int -> Int -> Int -> Bool -> PrintState

-- | The current line.
psLine :: PrintState -> Int

-- | Current column.
psColumn :: PrintState -> Int

-- | Current indentation level.
psIndentLevel :: PrintState -> Int

-- | Just outputted a newline?
psNewline :: PrintState -> Bool

-- | Default state.
defaultPrintState :: PrintState

-- | Global options of the printer
data PrintReader
PrintReader :: Bool -> Bool -> Bool -> PrintReader

-- | Are we to pretty print?
prPretty :: PrintReader -> Bool

-- | Use pretty thunk names?
prPrettyThunks :: PrintReader -> Bool

-- | Use pretty operators?
prPrettyOperators :: PrintReader -> Bool

-- | default printer options (non-pretty printing)
defaultPrintReader :: PrintReader

-- | Output of printer
data PrintWriter
PrintWriter :: [Mapping] -> ShowS -> PrintWriter

-- | Source mappings.
pwMappings :: PrintWriter -> [Mapping]

-- | The current output.
pwOutput :: PrintWriter -> ShowS
pwOutputString :: PrintWriter -> String

-- | The printer.
newtype Printer
Printer :: RWS PrintReader PrintWriter PrintState () -> Printer
runPrinter :: Printer -> RWS PrintReader PrintWriter PrintState ()
execPrinter :: Printer -> PrintReader -> PrintWriter

-- | Print the given printer indented.
indented :: Printer -> Printer

-- | exec one of Printers depending on PrintReader property.
askIf :: (PrintReader -> Bool) -> Printer -> Printer -> Printer

-- | Output a newline and makes next line indented when prPretty is True.
--   Does nothing when prPretty is False
newline :: Printer

-- | Write out a raw string, respecting the indentation Note: if you pass a
--   string with newline characters, it will print them out even if
--   prPretty is set to False. Also next line won't be indented. If you
--   want write a smart newline (that is the one which will be written out
--   only if prPretty is true, and after which the line will be indented)
--   use <a>newline</a>)
write :: String -> Printer

-- | Generate a mapping from the Haskell location to the current point in
--   the output.
mapping :: SrcSpan -> Printer

-- | The serialization context indicates whether we're currently
--   serializing some value or a particular field in a user-defined data
--   type.
data SerializeContext
SerializeAnywhere :: SerializeContext
SerializeUserArg :: Int -> SerializeContext

-- | The name of a module split into a list for code generation.
data ModulePath

-- | Construct the complete ModulePath from a ModuleName.
mkModulePath :: ModuleName a -> ModulePath

-- | Construct intermediate module paths from a ModuleName. mkModulePaths
--   <a>A.B</a> =&gt; [[<a>A</a>], [<a>A</a>,<a>B</a>]]
mkModulePaths :: ModuleName a -> [ModulePath]

-- | Converting a QName to a ModulePath is only relevant for constructors
--   since they can conflict with module names.
mkModulePathFromQName :: QName a -> ModulePath
instance Show CompileState
instance Show CompileWriter
instance Applicative Compile
instance Functor Compile
instance Monad Compile
instance MonadError CompileError Compile
instance MonadIO Compile
instance MonadReader CompileReader Compile
instance MonadState CompileState Compile
instance MonadWriter CompileWriter Compile
instance Applicative Fay
instance Functor Fay
instance Monad Fay
instance MonadModule Compile
instance Monoid CompileWriter


-- | Desugars a reasonable amount of syntax to reduce duplication in code
--   generation.
module Fay.Compiler.Desugar

-- | Top level, desugar a whole module possibly returning errors
desugar :: (Data l, Typeable l) => l -> Module l -> IO (Either CompileError (Module l))

-- | Desugar with the option to specify a prefix for generated names.
--   Useful if you want to provide valid haskell name that HSE can print.
desugar' :: (Data l, Typeable l) => String -> l -> Module l -> IO (Either CompileError (Module l))

-- | (a) =&gt; a for patterns
desugarExpParen :: (Data l, Typeable l) => Module l -> Module l
desugarPatParen :: (Data l, Typeable l) => Module l -> Module l


-- | The internal FFI module.
module Fay.FFI

-- | The JavaScript FFI interfacing monad.
data Fay a

-- | Values that may be null Nullable x decodes to x, Null decodes to null.
data Nullable a
Nullable :: a -> Nullable a
Null :: Nullable a

-- | Values that may be undefined Defined x encodes to x, Undefined decodes
--   to undefined. An undefined property in a record will be removed when
--   encoding.
data Defined a
Defined :: a -> Defined a
Undefined :: Defined a

-- | Do not serialize the specified type. This is useful for, e.g.
--   
--   <pre>
--   foo :: String -&gt; String
--   foo = ffi "%1"
--   </pre>
--   
--   This would normally serialize and unserialize the string, for no
--   reason, in this case. Instead:
--   
--   <pre>
--   foo :: Ptr String -&gt; Ptr String
--   </pre>
--   
--   Will just give an identity function.
type Ptr a = a

-- | The opposite of <a>Ptr</a>. Serialize the specified polymorphic type.
--   
--   <pre>
--   foo :: Automatic a -&gt; String
--   </pre>
type Automatic a = a

-- | Declare a foreign action.
ffi :: IsString s => s -> a


-- | The Haskell→Javascript compiler.
module Fay.Compiler

-- | Runs compilation for a single module.
runCompileModule :: CompileReader -> CompileState -> Compile a -> CompileModule a

-- | Compile a Haskell source string to a JavaScript source string.
compileViaStr :: FilePath -> Config -> (Module -> Compile [JsStmt]) -> String -> IO (Either CompileError (Printer, CompileState, CompileWriter))

-- | Compile a module
compileWith :: Monoid a => FilePath -> (a -> Module -> Compile a) -> (FilePath -> String -> Compile a) -> (X -> Module -> IO (Either CompileError Module)) -> String -> Compile (a, CompileState, CompileWriter)

-- | Compile Haskell expression.
compileExp :: Exp -> Compile JsExp

-- | Compile a declaration.
compileDecl :: Bool -> Decl -> Compile [JsStmt]

-- | Compile the top-level Fay module.
compileToplevelModule :: FilePath -> Module -> Compile [JsStmt]

-- | Compile a source string.
compileModuleFromContents :: String -> Compile ([JsStmt], [JsStmt])

-- | Compile a parse HSE module.
compileModuleFromAST :: ([JsStmt], [JsStmt]) -> Module -> Compile ([JsStmt], [JsStmt])

-- | Parse some Fay code.
parseFay :: Parseable ast => FilePath -> String -> ParseResult ast


-- | Main library entry point.
module Fay

-- | Error type.
data CompileError
Couldn'tFindImport :: ModuleName -> [FilePath] -> CompileError
EmptyDoBlock :: CompileError
FfiFormatBadChars :: SrcSpanInfo -> String -> CompileError
FfiFormatIncompleteArg :: SrcSpanInfo -> CompileError
FfiFormatInvalidJavaScript :: SrcSpanInfo -> String -> String -> CompileError
FfiFormatNoSuchArg :: SrcSpanInfo -> Int -> CompileError
FfiNeedsTypeSig :: Exp -> CompileError
GHCError :: String -> CompileError
InvalidDoBlock :: CompileError
ParseError :: SrcLoc -> String -> CompileError
ShouldBeDesugared :: String -> CompileError
UnableResolveQualified :: QName -> CompileError
UnsupportedDeclaration :: Decl -> CompileError
UnsupportedEnum :: Exp -> CompileError
UnsupportedExportSpec :: ExportSpec -> CompileError
UnsupportedExpression :: Exp -> CompileError
UnsupportedFieldPattern :: PatField -> CompileError
UnsupportedImport :: ImportDecl -> CompileError
UnsupportedLet :: CompileError
UnsupportedLetBinding :: Decl -> CompileError
UnsupportedLiteral :: Literal -> CompileError
UnsupportedModuleSyntax :: String -> Module -> CompileError
UnsupportedPattern :: Pat -> CompileError
UnsupportedQualStmt :: QualStmt -> CompileError
UnsupportedRecursiveDo :: CompileError
UnsupportedRhs :: Rhs -> CompileError
UnsupportedWhereInAlt :: Alt -> CompileError
UnsupportedWhereInMatch :: Match -> CompileError

-- | State of the compiler.
data CompileState
CompileState :: Map ModuleName Symbols -> [(QName, [QName])] -> [(QName, [Name])] -> [(QName, Maybe QName, Type)] -> [(ModuleName, FilePath)] -> Integer -> ModuleName -> Set ModulePath -> Bool -> Map QName Type -> CompileState

-- | Exported identifiers for all modules
stateInterfaces :: CompileState -> Map ModuleName Symbols

-- | Map types to constructors
stateRecordTypes :: CompileState -> [(QName, [QName])]

-- | Map constructors to fields
stateRecords :: CompileState -> [(QName, [Name])]

-- | Newtype constructor, destructor, wrapped type tuple
stateNewtypes :: CompileState -> [(QName, Maybe QName, Type)]

-- | Map of all imported modules and their source locations.
stateImported :: CompileState -> [(ModuleName, FilePath)]

-- | Depth of the current lexical scope, used for creating unshadowing
--   variables.
stateNameDepth :: CompileState -> Integer

-- | Name of the module currently being compiled.
stateModuleName :: CompileState -> ModuleName

-- | Module paths that have code generated for them.
stateJsModulePaths :: CompileState -> Set ModulePath

-- | Use JS Strings instead of [Char] for string literals?
stateUseFromString :: CompileState -> Bool

-- | Module level declarations having explicit type signatures
stateTypeSigs :: CompileState -> Map QName Type
data CompileResult
CompileResult :: String -> [(String, FilePath)] -> Maybe [Mapping] -> CompileResult
resOutput :: CompileResult -> String
resImported :: CompileResult -> [(String, FilePath)]
resSourceMappings :: CompileResult -> Maybe [Mapping]

-- | Compile the given file.
compileFile :: Config -> FilePath -> IO (Either CompileError String)

-- | Compile a file returning the resulting internal state of the compiler.
--   Don't use this directly, it's only exposed for the test suite.
compileFileWithState :: Config -> FilePath -> IO (Either CompileError (String, Maybe [Mapping], CompileState))

-- | Compile a file returning additional generated metadata.
compileFileWithResult :: Config -> FilePath -> IO (Either CompileError CompileResult)

-- | Compile the given file and write the output to the given path, or if
--   nothing given, stdout.
compileFromTo :: Config -> FilePath -> Maybe FilePath -> IO ()

-- | Compile the given file and write to the output, also generates HTML
--   and sourcemap files if configured.
compileFromToAndGenerateHtml :: Config -> FilePath -> FilePath -> IO (Either CompileError String)

-- | Convert a Haskell filename to a JS filename.
toJsName :: String -> String

-- | Print a compile error for human consumption.
showCompileError :: CompileError -> String

-- | Get the JS runtime source. This will return the user supplied runtime
--   if it exists.
getConfigRuntime :: Config -> IO String

-- | Get the default JS runtime source.
getRuntime :: IO String
