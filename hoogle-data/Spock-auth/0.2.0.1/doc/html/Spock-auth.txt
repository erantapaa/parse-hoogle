-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides authentification helpers for Spock
--   
--   Provides authentification helpers for Spock
@package Spock-auth
@version 0.2.0.1

module Web.Spock.Auth

-- | Plug this into the <a>spock</a> function to create SessionCfg
authSessCfg :: AuthCfg sess -> SessionCfg (VisitorSession sess userId)

-- | Configuration
data AuthCfg sess
AuthCfg :: NominalDiffTime -> sess -> AuthCfg sess
ac_sessionTTL :: AuthCfg sess -> NominalDiffTime
ac_emptySession :: AuthCfg sess -> sess

-- | Replacement for <a>writeSession</a>
writeSessionData :: sess -> SpockAction conn (VisitorSession sess userId) st ()

-- | Replacement for <a>readSession</a>
readSessionData :: SpockAction conn (VisitorSession sess userId) st sess

-- | Replacement for <a>modifySession</a>
modifySessionData :: (sess -> sess) -> SpockAction conn (VisitorSession sess userId) st ()
data VisitorSession sess userId

-- | Describes why access was denied to a user
data NoAccessReason
NotEnoughRights :: NoAccessReason
NotLoggedIn :: NoAccessReason
NotValidUser :: NoAccessReason

-- | Define what happens to non-authorized requests
type NoAccessHandler conn sess userId st = NoAccessReason -> SpockAction conn (VisitorSession sess userId) st ()

-- | How should a session be transformed into a user? Can access the
--   database using <a>runQuery</a>
type LoadUserFun conn sess userId st user = userId -> SpockAction conn (VisitorSession sess userId) st (Maybe user)

-- | What rights does the current user have? Can access the database using
--   <a>runQuery</a>
type CheckRightsFun conn sess userId st user = user -> [UserRights] -> SpockAction conn (VisitorSession sess userId) st Bool

-- | Assign the current session roles/permission, eg. admin or user
type UserRights = Text

-- | Mark current visitor as logged in
markAsLoggedIn :: userId -> SpockAction conn (VisitorSession sess userId) st ()

-- | Mark current visitor as guest
markAsGuest :: SpockAction conn (VisitorSession sess userId) st ()

-- | Before the request is performed, you can check if the signed in user
--   has permissions to view the contents of the request. You may want to
--   define a helper function that proxies this function to not pass around
--   <a>NoAccessHandler</a>, <a>LoadUserFun</a> and <a>CheckRightsFun</a>
--   all the time. Example:
--   
--   <pre>
--   type MyWebMonad a = SpockAction Connection (VisitorSession () UserId) () a
--   newtype MyUser = MyUser { unMyUser :: T.Text }
--   
--   http403 msg =
--      do status Http.status403
--         text (show msg)
--   
--   login :: Http.StdMethod
--         -&gt; [UserRights]
--         -&gt; RoutePattern
--         -&gt; (MyUser -&gt; MyWebMonad ())
--         -&gt; MyWebMonad ()
--   login =
--       userRoute http403 myLoadUser myCheckRights
--   </pre>
userRoute :: NoAccessHandler conn sess userId st -> LoadUserFun conn sess userId st user -> CheckRightsFun conn sess userId st user -> StdMethod -> [UserRights] -> Text -> (user -> SpockAction conn (VisitorSession sess userId) st ()) -> SpockM conn (VisitorSession sess userId) st ()
instance Show NoAccessReason
instance Eq NoAccessReason
instance Read NoAccessReason
instance Enum NoAccessReason
instance Show userId => Show (SessionType userId)
instance Eq userId => Eq (SessionType userId)
instance (Show sess, Show userId) => Show (VisitorSession sess userId)
instance (Eq sess, Eq userId) => Eq (VisitorSession sess userId)
