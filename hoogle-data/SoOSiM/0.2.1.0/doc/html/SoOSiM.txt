-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Abstract full system simulator
--   
--   SoOSiM is a simulator developed for the purpose of exploring operating
--   system concepts and operating system modules. The simulator provides a
--   highly abstracted view of a computing system, consisting of computing
--   nodes, and components that are concurrently executed on these nodes.
--   OS modules are subsequently modelled as components that progress as a
--   result of reacting to two types of events: messages from other
--   components, or a system-wide tick event. Using this abstract view, a
--   developer can quickly formalize assertions regarding the interaction
--   between operating system modules and applications.
@package SoOSiM
@version 0.2.1.0

module SoOSiM.Types

-- | Type class that defines an OS component
class ComponentInterface s where type family Send s type family Receive s type family State s
initState :: ComponentInterface s => s -> State s
componentName :: ComponentInterface s => s -> ComponentName
componentBehaviour :: ComponentInterface s => s -> State s -> Input (Receive s) -> Sim (State s)

-- | The simulator monad used by the OS components offers resumable
--   computations in the form of coroutines. These resumable computations
--   expect a value of type <a>Dynamic</a>, and return a value of type
--   <tt>a</tt>.
--   
--   We need resumable computations to simulate synchronous messaging
--   between two components. When a component synchronously sends a message
--   to another component, we store the rest of the computation as part of
--   the execution context in the simulator state. When a message is send
--   back, the stored computation will continue with the message content
--   (of type <a>Dynamic</a>).
--   
--   To suspend a computation you simply do: 'request <a>componentId</a>'
--   
--   Where the <a>componentId</a> is the ID of the OS component you are
--   expecting a message from. The execute a resumeable computation you
--   simply do: 'resume <a>comp</a>'
newtype Sim a
Sim :: SimInternal a -> Sim a
runSim :: Sim a -> SimInternal a

-- | Events send to components by the simulator
data Input a

-- | A message send another component: the field argument is the
--   <a>ComponentId</a> of the sender, the second field the message content
Message :: a -> ReturnAddress -> Input a

-- | Event send every simulation round
Tick :: Input a
newtype ReturnAddress
RA :: (ComponentId, TVar Dynamic) -> ReturnAddress
unRA :: ReturnAddress -> (ComponentId, TVar Dynamic)
type ComponentId = Unique
type ComponentName = String
type NodeId = Unique

-- | Context of a running component in the simulator.
--   
--   We need existential types because we need to make a single collection
--   of several component contexts, each having their own type representing
--   their internal state.
data ComponentContext
CC :: s -> ComponentId -> ComponentId -> TVar (ComponentStatus s) -> TVar (State s) -> TVar [Input Dynamic] -> [String] -> TVar SimMetaData -> ComponentContext

-- | Interface type
componentIface :: ComponentContext -> s

-- | <a>ComponentId</a> of this component
componentId :: ComponentContext -> ComponentId

-- | <a>ComponentId</a> of the component that created this component
creator :: ComponentContext -> ComponentId

-- | Status of the component
currentStatus :: ComponentContext -> TVar (ComponentStatus s)

-- | State internal to the component
componentState :: ComponentContext -> TVar (State s)

-- | Message waiting to be processed by the component
msgBuffer :: ComponentContext -> TVar [Input Dynamic]

-- | Trace message buffer
traceMsgs :: ComponentContext -> [String]

-- | Statistical information regarding a component
simMetaData :: ComponentContext -> TVar SimMetaData

-- | Status of a running component
data ComponentStatus a

-- | Component is doing nothing
ReadyToIdle :: ComponentStatus a

-- | Component is waiting for a message from <a>ComponentId</a>, will
--   continue with computation ('(' -&gt; <tt>SimM</tt> a) once received
WaitingFor :: ComponentId -> (() -> Sim (State a)) -> ComponentStatus a

-- | Component is busy doing computations
ReadyToRun :: ComponentStatus a

-- | Module scheduled for deletion
Killed :: ComponentStatus a
data RequestOrYield request response x
Request :: request -> (response -> x) -> RequestOrYield request response x
Yield :: x -> RequestOrYield request response x
Kill :: RequestOrYield request response x

-- | Nodes represent computing entities in the simulator, and host the OS
--   components and application threads
data Node
Node :: NodeId -> NodeInfo -> Map ComponentName ComponentId -> IntMap ComponentContext -> IntMap Dynamic -> [ComponentId] -> Node

-- | Globally Unique ID of the node
nodeId :: Node -> NodeId

-- | Meta-data describing the node
nodeInfo :: Node -> NodeInfo

-- | Lookup table of OS components running on the node, key: the
--   <a>ComponentName</a>, value: unique <a>ComponentId</a>
nodeComponentLookup :: Node -> Map ComponentName ComponentId

-- | Map of component contexts, key is the <a>ComponentId</a>
nodeComponents :: Node -> IntMap ComponentContext

-- | Node-local memory
nodeMemory :: Node -> IntMap Dynamic
nodeComponentOrder :: Node -> [ComponentId]
data SimMetaData
SimMetaData :: Int -> Int -> Int -> Map ComponentId Int -> Map ComponentId Int -> SimMetaData
cyclesRunning :: SimMetaData -> Int
cyclesWaiting :: SimMetaData -> Int
cyclesIdling :: SimMetaData -> Int

-- | Key: senderId; Value: number of messages
msgsReceived :: SimMetaData -> Map ComponentId Int

-- | Key: receiverId: Value: number of messages
msgsSend :: SimMetaData -> Map ComponentId Int

-- | The internal monad of the simulator is currently a simple state-monad
--   wrapping STM
type SimMonad = StateT SimState STM
type SimInternal = Coroutine (RequestOrYield Unique ()) SimMonad

-- | The internal simulator state
data SimState
SimState :: ComponentId -> NodeId -> IntMap Node -> Supply -> SimState

-- | The <a>ComponentId</a> of the component currently under evaluation
currentComponent :: SimState -> ComponentId

-- | The <a>NodeId</a> of the node containing the component currently under
--   evaluation
currentNode :: SimState -> NodeId

-- | The set of nodes comprising the entire system
nodes :: SimState -> IntMap Node

-- | Unlimited supply of unique values
uniqueSupply :: SimState -> Supply

-- | Meta-data describing the functionaly of the computing node, currently
--   just a singleton type.
data NodeInfo
NodeInfo :: NodeInfo
instance Functor Sim
instance Monad Sim
instance MonadState SimState Sim
instance MonadUnique Sim
instance MonadUnique SimMonad
instance Functor (RequestOrYield x f)
instance MonadUnique SimInternal
instance MonadState SimState SimInternal
instance Show (Input a)

module SoOSiM

-- | Create a new component
createComponent :: (ComponentInterface iface, Typeable (Receive iface)) => iface -> Sim ComponentId

-- | Synchronously invoke another component
invoke :: (ComponentInterface iface, Typeable (Receive iface), Typeable (Send iface)) => iface -> ComponentId -> Receive iface -> Sim (Send iface)

-- | Invoke another component, handle response asynchronously
invokeAsync :: (ComponentInterface iface, Typeable (Receive iface), Typeable (Send iface)) => iface -> ComponentId -> Receive iface -> (Send iface -> Sim ()) -> Sim ()

-- | Respond to an invocation
respond :: (ComponentInterface iface, Typeable (Send iface)) => iface -> ReturnAddress -> (Send iface) -> Sim ()

-- | Yield internal state to the simulator scheduler
yield :: a -> Sim a

-- | Read memory of local node
readMemory :: Int -> Sim Dynamic

-- | Write memory of local node
writeMemory :: Typeable a => Int -> a -> Sim ()

-- | Get the unique <a>ComponentId</a> of a component implementing an
--   interface
componentLookup :: ComponentInterface iface => iface -> Sim (Maybe ComponentId)
traceMsg :: String -> Sim ()

-- | Create a new node
createNode :: Sim NodeId
runSTM :: STM a -> Sim a

-- | Get the component id of your component
getComponentId :: Sim ComponentId

-- | Get the node id of of the node your component is currently running on
getNodeId :: Sim NodeId

-- | Return the <a>ComponentId</a> of the component that created the
--   current component
componentCreator :: Sim ComponentId

-- | Create a new component
createComponentN :: (ComponentInterface iface, Typeable (Receive iface)) => iface -> NodeId -> Sim ComponentId

-- | Create a new component
createComponentNP :: (ComponentInterface iface, Typeable (Receive iface)) => NodeId -> ComponentId -> iface -> Sim ComponentId

-- | Synchronously invoke another component
invokeS :: (ComponentInterface iface, Typeable (Receive iface), Typeable (Send iface)) => iface -> Maybe ComponentId -> ComponentId -> Receive iface -> Sim (Send iface)

-- | Invoke another component, handle response asynchronously
invokeAsyncS :: (ComponentInterface iface, Typeable (Receive iface), Typeable (Send iface)) => iface -> Maybe ComponentId -> ComponentId -> (Receive iface) -> (Send iface -> Sim ()) -> Sim ()

-- | Respond to an invocation
respondS :: (ComponentInterface iface, Typeable (Send iface)) => iface -> Maybe ComponentId -> ReturnAddress -> (Send iface) -> Sim ()

-- | Read memory of local node
readMemoryN :: Maybe NodeId -> Int -> Sim Dynamic

-- | Write memory of local node
writeMemoryN :: Typeable a => Maybe NodeId -> Int -> a -> Sim ()

-- | Type class that defines an OS component
class ComponentInterface s where type family Send s type family Receive s type family State s
initState :: ComponentInterface s => s -> State s
componentName :: ComponentInterface s => s -> ComponentName
componentBehaviour :: ComponentInterface s => s -> State s -> Input (Receive s) -> Sim (State s)

-- | Events send to components by the simulator
data Input a

-- | A message send another component: the field argument is the
--   <a>ComponentId</a> of the sender, the second field the message content
Message :: a -> ReturnAddress -> Input a

-- | Event send every simulation round
Tick :: Input a

-- | The simulator monad used by the OS components offers resumable
--   computations in the form of coroutines. These resumable computations
--   expect a value of type <a>Dynamic</a>, and return a value of type
--   <tt>a</tt>.
--   
--   We need resumable computations to simulate synchronous messaging
--   between two components. When a component synchronously sends a message
--   to another component, we store the rest of the computation as part of
--   the execution context in the simulator state. When a message is send
--   back, the stored computation will continue with the message content
--   (of type <a>Dynamic</a>).
--   
--   To suspend a computation you simply do: 'request <a>componentId</a>'
--   
--   Where the <a>componentId</a> is the ID of the OS component you are
--   expecting a message from. The execute a resumeable computation you
--   simply do: 'resume <a>comp</a>'
data Sim a
type ComponentId = Unique
type ComponentName = String
type NodeId = Unique

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable a

-- | A value of type <a>Dynamic</a> is an object encapsulated together with
--   its type.
--   
--   A <a>Dynamic</a> may only represent a monomorphic value; an attempt to
--   create a value of type <a>Dynamic</a> from a polymorphically-typed
--   expression will result in an ambiguity error (see <a>toDyn</a>).
--   
--   <a>Show</a>ing a value of type <a>Dynamic</a> returns a pretty-printed
--   representation of the object's type; useful for debugging.
data Dynamic :: *
tick :: SimState -> IO SimState
ignore :: a -> Sim ()
unmarshall :: Typeable a => String -> Dynamic -> a
returnAddress :: ReturnAddress -> ComponentId
