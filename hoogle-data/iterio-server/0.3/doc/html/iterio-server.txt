-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library for building servers with IterIO
--   
--   This module contains a set of generic building blocks for building
--   servers with IterIO.
@package iterio-server
@version 0.3


-- | Generic building blocks for creating TCP Servers based on
--   <tt>IterIO</tt>
module Data.IterIO.Server.TCPServer

-- | <a>TCPServer</a> holds all the information necessary to run bind to a
--   sock and respond to TCP requests from the network.
data TCPServer inp m
TCPServer :: PortNumber -> Inum inp inp m () -> (Socket -> m (Iter inp m (), Onum inp m ())) -> (m () -> IO ()) -> TCPServer inp m

-- | The TCP port the server will listen for incomming connections on.
serverPort :: TCPServer inp m -> PortNumber

-- | This <a>Inum</a> implements the actual functionality of the server.
--   The input and output of the <a>Inum</a> correspond to the input and
--   output of the socket.
serverHandler :: TCPServer inp m -> Inum inp inp m ()

-- | A function to transform an accept incomming connection into an iter
--   and onum. Most servers should just use <tt>defaultSocketAcceptor</tt>
--   but this can be used for special cases, e.g. accepting SSL connections
--   with <a>iterSSL</a>.
serverAcceptor :: TCPServer inp m -> Socket -> m (Iter inp m (), Onum inp m ())

-- | Must execute the monadic result. Servers operating in the <a>IO</a>
--   Monad can use <a>id</a>.
serverResultHandler :: TCPServer inp m -> m () -> IO ()

-- | Runs a <a>TCPServer</a> in a loop.
runTCPServer :: (ListLikeIO inp e, ChunkData inp, Monad m) => TCPServer inp m -> IO ()

-- | This acceptor creates an <a>Iter</a> and <a>Onum</a> using
--   <a>handleI</a> and <a>enumHandle</a> respectively.
defaultServerAcceptor :: (ListLikeIO inp e, ChunkData inp, MonadIO m) => Socket -> m (Iter inp m (), Onum inp m a)

-- | For convenience, a TCPServer in the <a>IO</a> Monad with null
--   defaults:
--   
--   <ul>
--   <li>Port 0 (next availabel port)</li>
--   <li>Handler set to <a>inumNop</a></li>
--   <li>Acceptor set to <a>defaultServerAcceptor</a></li>
--   <li>Request handler set to <a>id</a> (noop)</li>
--   </ul>
minimalTCPServer :: (ListLikeIO inp e, ChunkData inp) => TCPServer inp IO

-- | Creates a simple HTTP server from an <tt>HTTPRequestHandler</tt>.
simpleHttpServer :: PortNumber -> HttpRequestHandler IO () -> TCPServer ByteString IO

-- | Creates a <a>TCPServer</a> that echoes each line from the client until
--   EOF.
echoServer :: PortNumber -> TCPServer String IO
instance Show (TCPServer inp m)


-- | Defines the <a>Action</a> monad which abstracts some of the details of
--   handling HTTP requests with IterIO.
module Data.IterIO.Http.Support.Action

-- | A <a>StateT</a> monad in which requests can be handled. It keeps track
--   of the <a>HttpReq</a>, the form parameters from the request body and
--   an <a>HttpResp</a> used to reply to the client.
type Action t b m a = StateT (ActionState t b m) m a
data ActionState t b m
ActionState :: HttpReq t -> HttpResp m -> [Param] -> b -> ActionState t b m
actionReq :: ActionState t b m -> HttpReq t
actionResp :: ActionState t b m -> HttpResp m
actionParams :: ActionState t b m -> [Param]
actionBody :: ActionState t b m -> b

-- | A request parameter from a form field in the HTTP body
data Param
Param :: ByteString -> ByteString -> [(ByteString, ByteString)] -> Param
paramKey :: Param -> ByteString
paramValue :: Param -> ByteString

-- | Header of a <tt>multipart/form-data</tt> post
paramHeaders :: Param -> [(ByteString, ByteString)]

-- | Returns a list of all <a>Param</a>s.
params :: Monad m => Action t b m [Param]

-- | Returns the <a>Param</a> corresponding to the specified key or
--   <a>Nothing</a> if one is not present in the request.
param :: Monad m => ByteString -> Action t b m (Maybe Param)

-- | Force get parameter value
paramVal :: Monad m => ByteString -> Action t b m (ByteString)

-- | Get (maybe) paramater value and transform it with <tt>f</tt>
paramValM :: Monad m => (ByteString -> a) -> ByteString -> Action t b m (Maybe a)

-- | Set the list of <a>Param</a>s.
setParams :: Monad m => [Param] -> Action t b m [Param]

-- | Returns the body of the current request.
getBody :: Monad m => Action t b m b

-- | Returns the <a>HttpReq</a> for the current request.
getHttpReq :: Monad m => Action t b m (HttpReq t)

-- | Sets a the value for "_sess" in the cookie to the given string.
setSession :: Monad m => String -> Action t b m ()

-- | Removes the "_sess" key-value pair from the cookie.
destroySession :: Monad m => Action t b m ()

-- | Returns the value of an Http Header from the request if it exists
--   otherwise <a>Nothing</a>
requestHeader :: Monad m => ByteString -> Action t b m (Maybe ByteString)
instance [safe] Show Param


-- | Utility functions for responding to HTTP requests from within an
--   <a>Action</a>.
module Data.IterIO.Http.Support.Responses

-- | Responds to the client with a <tt>200</tt> (Success) response with the
--   given body and mime-type.
render :: Monad m => String -> ByteString -> Action t b m ()

-- | Responds to the client with a <tt>303</tt> (Temporary Redirect)
--   response to the given path.
redirectTo :: Monad m => String -> Action t b m ()

-- | Redirect "back" according to the "referer" header.
redirectBack :: Monad m => Action t b m ()

-- | Responds to the client with an empty <tt>404</tt> (Not Found)
--   response.
respond404 :: Monad m => Action t b m ()

-- | Replaces the HTTP status in the current <a>HttpResp</a> with the given
--   <a>HttpStatus</a>.
respondStat :: Monad m => HttpStatus -> Action t b m ()


-- | Utility functions for routing.
module Data.IterIO.Http.Support.Routing

-- | An <tt>ActionRoute</tt> either matches an <a>HttpReq</a> and returns a
--   corresponding <a>Action</a> that responds to it, or <a>Nothing</a>
--   signifying, no approriate <a>Action</a> was found.
--   <tt>ActionRoute</tt>s can be strung together with, e.g.,
--   <a>mappend</a> such that each will be searched in turn until an
--   <a>Action</a> responding to the <a>HttpReq</a> is found.
newtype ActionRoute b m s
ActionRoute :: (HttpReq s -> m (Maybe (Action s b m ()))) -> ActionRoute b m s

-- | Runs an <a>ActionRoute</a>. If it satisfies the request, the
--   underlying <a>Action</a> is returned, otherwise an <a>Action</a>
--   responding with HTTP 404 (Not Found) is returned instead. Can be used
--   at the top of a request handler, for example:
--   
--   <pre>
--   httpHandler :: Action b m ()
--   httpHandler = runActionRoute $ mconcat [
--       routeTop $ routeAction homeAction
--     , routeMethod "POST" $ routeAction handleForm
--     , routeMethod "GET" $ routeAction showForm
--     ]
--   </pre>
--   
--   But also can be nested inside of another action to created nested
--   routes, or state dependant routes:
--   
--   <pre>
--   httpHandler :: Action b m ()
--   httpHandler = runActionRoute $ mconcat [
--       routeTop $ routeAction homeAction
--     , routeName "foo" $ routeAction $ runActionRoute $ mconcat [
--           routeMethod "GET" $ runAction showForm
--         , routeMethod "POST" $ runAction handleForm
--         ]
--     ]
--   </pre>
--   
--   or
--   
--   <pre>
--   handleForm = do
--     day &lt;- lift $ getDayOfWeek
--     case mod day 2 of
--       0 -&gt; runActionRoute $ routeName "stts" $ routeAction doRes
--       1 -&gt; runActionRoute $ routeName "mwf" $ routeAction doRes
--   </pre>
runActionRoute :: Monad m => ActionRoute b m s -> Action s b m ()

-- | Like <a>runAction</a> but consumes the rest of the request for the
--   body
runIterAction :: Monad m => Action s ByteString m a -> HttpReq s -> Iter ByteString m (HttpResp m)

-- | Runs an <a>Action</a> given an <a>HttpReq</a> and body. Returns the
--   <a>HttpResp</a> generated by the <a>Action</a>.
runAction :: Monad m => Action s b m a -> HttpReq s -> b -> m (HttpResp m)

-- | Routes an <a>Action</a>
routeAction :: Monad m => Action t b m () -> ActionRoute b m t

-- | Routes an <a>Action</a> to the given URL pattern. Patterns can include
--   directories as well as variable patterns (prefixed with <tt>:</tt>) to
--   be passed into the <a>Action</a> as extra <a>Param</a>s. Some examples
--   of URL patters:
--   
--   <ul>
--   <li>/posts/:id</li>
--   <li>/posts/:id/new</li>
--   <li>/:date/posts/:category/new</li>
--   </ul>
routePattern :: Monad m => String -> ActionRoute b m t -> ActionRoute b m t

-- | Routes a specific directory name, like <tt>routeMap</tt> for a
--   singleton map.
routeName :: Monad m => String -> ActionRoute b m s -> ActionRoute b m s

-- | Matches any directory name, but additionally pushes it onto the front
--   of the <a>reqPathParams</a> list in the <a>HttpReq</a> structure. This
--   allows the name to serve as a variable argument to the eventual
--   handling function.
routeVar :: Monad m => ActionRoute b m s -> ActionRoute b m s

-- | Match request with path "/".
routeTop :: Monad m => ActionRoute b m s -> ActionRoute b m s

-- | Match requests with the given method ("GET", "POST", etc).
routeMethod :: Monad m => String -> ActionRoute b m s -> ActionRoute b m s
routeFileSys :: (String -> ByteString) -> FilePath -> ActionRoute b IO t
instance [safe] Monad m => Monoid (ActionRoute b m s)


-- | This module defines the <a>RestController</a> class
module Data.IterIO.Http.Support.RestController

-- | The class <tt>RestController</tt> allows a set of actions to be routed
--   using RESTful HTTP verbs.
class Monad m => RestController t b m a where restIndex _ = respond404 restShow _ _ = respond404 restNew _ = respond404 restCreate _ = respond404 restEdit _ _ = respond404 restUpdate _ _ = respond404 restDestroy _ _ = respond404
restIndex :: RestController t b m a => a -> Action t b m ()
restShow :: RestController t b m a => a -> ByteString -> Action t b m ()
restNew :: RestController t b m a => a -> Action t b m ()
restCreate :: RestController t b m a => a -> Action t b m ()
restEdit :: RestController t b m a => a -> ByteString -> Action t b m ()
restUpdate :: RestController t b m a => a -> ByteString -> Action t b m ()
restDestroy :: RestController t b m a => a -> ByteString -> Action t b m ()

-- | Routes URLs under the given <tt>String</tt> to actions in a
--   <tt>RestController</tt>. For example
--   
--   <pre>
--   routeRestController <a>posts</a> myRestController
--   </pre>
--   
--   will map the follwoing URLs:
--   
--   <ul>
--   <li>GET /posts =&gt; myRestController#restIndex</li>
--   <li>POST /posts =&gt; myRestController#restCreate</li>
--   <li>GET /posts/:id =&gt; myRestController#restShow</li>
--   <li>GET /posts/:id/edit =&gt; myRestController#restEdit</li>
--   <li>GET /posts/:id/new =&gt; myRestController#restNew</li>
--   <li>DELETE /posts/:id =&gt; myRestController#restDestroy</li>
--   <li>PUT /posts/:id =&gt; myRestController#restUpdate</li>
--   </ul>
routeRestController :: RestController t b m a => String -> a -> ActionRoute b m t

module Data.IterIO.Http.Support.Utils

-- | For <a>Action</a>s where the body type is a <a>ByteString</a>, parse
--   the body with 'parseParams\'' and prepend the result to the
--   <tt>Action'</tt>s <a>Param</a>s
parseParams :: Monad m => Action t ByteString m [Param]

-- | Parse url encoded or form encoded paramters from an HTTP body.
parseParams' :: Monad m => HttpReq a -> ByteString -> m [Param]

module Data.IterIO.Http.Support
